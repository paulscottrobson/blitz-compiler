;
;	This file is automatically generated
;
;
;	This file is automatically generated.
;
C64_END                  = $80 ; $80 end
C64_FOR                  = $81 ; $81 for
C64_NEXT                 = $82 ; $82 next
C64_DATA                 = $83 ; $83 data
C64_INPUTHASH            = $84 ; $84 input#
C64_INPUT                = $85 ; $85 input
C64_DIM                  = $86 ; $86 dim
C64_READ                 = $87 ; $87 read
C64_LET                  = $88 ; $88 let
C64_GOTO                 = $89 ; $89 goto
C64_RUN                  = $8a ; $8a run
C64_IF                   = $8b ; $8b if
C64_RESTORE              = $8c ; $8c restore
C64_GOSUB                = $8d ; $8d gosub
C64_RETURN               = $8e ; $8e return
C64_REM                  = $8f ; $8f rem
C64_STOP                 = $90 ; $90 stop
C64_ON                   = $91 ; $91 on
C64_WAIT                 = $92 ; $92 wait
C64_LOAD                 = $93 ; $93 load
C64_SAVE                 = $94 ; $94 save
C64_VERIFY               = $95 ; $95 verify
C64_DEF                  = $96 ; $96 def
C64_POKE                 = $97 ; $97 poke
C64_PRINTHASH            = $98 ; $98 print#
C64_PRINT                = $99 ; $99 print
C64_CONT                 = $9a ; $9a cont
C64_LIST                 = $9b ; $9b list
C64_CLR                  = $9c ; $9c clr
C64_CMD                  = $9d ; $9d cmd
C64_SYS                  = $9e ; $9e sys
C64_OPEN                 = $9f ; $9f open
C64_CLOSE                = $a0 ; $a0 close
C64_GET                  = $a1 ; $a1 get
C64_NEW                  = $a2 ; $a2 new
C64_TABLB                = $a3 ; $a3 tab(
C64_TO                   = $a4 ; $a4 to
C64_FN                   = $a5 ; $a5 fn
C64_SPCLB                = $a6 ; $a6 spc(
C64_THEN                 = $a7 ; $a7 then
C64_NOT                  = $a8 ; $a8 not
C64_STEP                 = $a9 ; $a9 step
C64_PLUS                 = $aa ; $aa +
C64_MINUS                = $ab ; $ab -
C64_TIMES                = $ac ; $ac *
C64_DIVIDE               = $ad ; $ad /
C64_POWER                = $ae ; $ae ^
C64_AND                  = $af ; $af and
C64_OR                   = $b0 ; $b0 or
C64_GREATER              = $b1 ; $b1 >
C64_EQUAL                = $b2 ; $b2 =
C64_LESS                 = $b3 ; $b3 <
C64_SGN                  = $b4 ; $b4 sgn
C64_INT                  = $b5 ; $b5 int
C64_ABS                  = $b6 ; $b6 abs
C64_USR                  = $b7 ; $b7 usr
C64_FRE                  = $b8 ; $b8 fre
C64_POS                  = $b9 ; $b9 pos
C64_SQR                  = $ba ; $ba sqr
C64_RND                  = $bb ; $bb rnd
C64_LOG                  = $bc ; $bc log
C64_EXP                  = $bd ; $bd exp
C64_COS                  = $be ; $be cos
C64_SIN                  = $bf ; $bf sin
C64_TAN                  = $c0 ; $c0 tan
C64_ATN                  = $c1 ; $c1 atn
C64_PEEK                 = $c2 ; $c2 peek
C64_LEN                  = $c3 ; $c3 len
C64_STRDOLLAR            = $c4 ; $c4 str$
C64_VAL                  = $c5 ; $c5 val
C64_ASC                  = $c6 ; $c6 asc
C64_CHRDOLLAR            = $c7 ; $c7 chr$
C64_LEFTDOLLAR           = $c8 ; $c8 left$
C64_RIGHTDOLLAR          = $c9 ; $c9 right$
C64_MIDDOLLAR            = $ca ; $ca mid$
C64_GO                   = $cb ; $cb go
C64_MON                  = $ce80 ; $ce80 mon
C64_DOS                  = $ce81 ; $ce81 dos
C64_OLD                  = $ce82 ; $ce82 old
C64_GEOS                 = $ce83 ; $ce83 geos
C64_VPOKE                = $ce84 ; $ce84 vpoke
C64_VLOAD                = $ce85 ; $ce85 vload
C64_SCREEN               = $ce86 ; $ce86 screen
C64_PSET                 = $ce87 ; $ce87 pset
C64_LINE                 = $ce88 ; $ce88 line
C64_FRAME                = $ce89 ; $ce89 frame
C64_RECT                 = $ce8a ; $ce8a rect
C64_CHAR                 = $ce8b ; $ce8b char
C64_MOUSE                = $ce8c ; $ce8c mouse
C64_COLOR                = $ce8d ; $ce8d color
C64_TEST                 = $ce8e ; $ce8e test
C64_RESET                = $ce8f ; $ce8f reset
C64_CLS                  = $ce90 ; $ce90 cls
C64_CODEX                = $ce91 ; $ce91 codex
C64_LOCATE               = $ce92 ; $ce92 locate
C64_BOOT                 = $ce93 ; $ce93 boot
C64_KEYMAP               = $ce94 ; $ce94 keymap
C64_BLOAD                = $ce95 ; $ce95 bload
C64_BVLOAD               = $ce96 ; $ce96 bvload
C64_BVERIFY              = $ce97 ; $ce97 bverify
C64_BANK                 = $ce98 ; $ce98 bank
C64_FMINIT               = $ce99 ; $ce99 fminit
C64_FMNOTE               = $ce9a ; $ce9a fmnote
C64_FMDRUM               = $ce9b ; $ce9b fmdrum
C64_FMINST               = $ce9c ; $ce9c fminst
C64_FMVIB                = $ce9d ; $ce9d fmvib
C64_FMFREQ               = $ce9e ; $ce9e fmfreq
C64_FMVOL                = $ce9f ; $ce9f fmvol
C64_FMPAN                = $cea0 ; $cea0 fmpan
C64_FMPLAY               = $cea1 ; $cea1 fmplay
C64_FMCHORD              = $cea2 ; $cea2 fmchord
C64_FMPOKE               = $cea3 ; $cea3 fmpoke
C64_PSGINIT              = $cea4 ; $cea4 psginit
C64_PSGNOTE              = $cea5 ; $cea5 psgnote
C64_PSGVOL               = $cea6 ; $cea6 psgvol
C64_PSGWAV               = $cea7 ; $cea7 psgwav
C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
C64_PSGPAN               = $cea9 ; $cea9 psgpan
C64_PSGPLAY              = $ceaa ; $ceaa psgplay
C64_PSGCHORD             = $ceab ; $ceab psgchord
C64_REBOOT               = $ceac ; $ceac reboot
C64_POWEROFF             = $cead ; $cead poweroff
C64_I2CPOKE              = $ceae ; $ceae i2cpoke
C64_SLEEP                = $ceaf ; $ceaf sleep
C64_BSAVE                = $ceb0 ; $ceb0 bsave
C64_MENU                 = $ceb1 ; $ceb1 menu
C64_REN                  = $ceb2 ; $ceb2 ren
C64_LINPUT               = $ceb3 ; $ceb3 linput
C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
C64_HELP                 = $ceb6 ; $ceb6 help
C64_VPEEK                = $ced0 ; $ced0 vpeek
C64_MX                   = $ced1 ; $ced1 mx
C64_MY                   = $ced2 ; $ced2 my
C64_MB                   = $ced3 ; $ced3 mb
C64_JOY                  = $ced4 ; $ced4 joy
C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
C64_BINDOLLAR            = $ced6 ; $ced6 bin$
C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
C64_POINTER              = $ced8 ; $ced8 pointer
C64_STRPTR               = $ced9 ; $ced9 strptr
C64_RPTDOLLAR            = $ceda ; $ceda rpt$
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		config.inc
;		Purpose:	Configuration for runtime
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

;
;		When compileing, PCode is stored from here onwards
;
PCodeStart = $6000
;
;		Work area space and size
;
WorkArea = $8000
WorkAreaSize = $1F00
;
;		Calculate top string address, e.g. stack/string seperation
;
StringTopAddress = WorkArea + WorkAreaSize - (1 + (WorkAreaSize >> 12)) * 256
StackTopAddress = WorkArea + WorkAreaSize
VariableStart = WorkArea

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		data.inc
;		Purpose:	Common Data
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Mandatory Zero page code
;
; ************************************************************************************************

		.section zeropage
zsTemp: 									; string temporary area.
		.fill 	2
runtimeStackPtr: 							; runtime stack pointer
		.fill 	2
		.send zeropage


; ************************************************************************************************
;
;										Non Zero Page Data
;
; ************************************************************************************************

		.section storage

stringLowMemory:
		.fill 	2		
stringHighMemory:
		.fill 	2

		.send 	storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

;
;	This file is automatically generated.
;
error_range .macro
	jmp	ErrorV_range
	.endm
error_value .macro
	jmp	ErrorV_value
	.endm
error_syntax .macro
	jmp	ErrorV_syntax
	.endm
error_type .macro
	jmp	ErrorV_type
	.endm
error_unimplemented .macro
	jmp	ErrorV_unimplemented
	.endm
error_assert .macro
	jmp	ErrorV_assert
	.endm
error_line .macro
	jmp	ErrorV_line
	.endm
error_internal .macro
	jmp	ErrorV_internal
	.endm
error_divzero .macro
	jmp	ErrorV_divzero
	.endm
error_structure .macro
	jmp	ErrorV_structure
	.endm
error_stop .macro
	jmp	ErrorV_stop
	.endm
error_data .macro
	jmp	ErrorV_data
	.endm
error_undeclared .macro
	jmp	ErrorV_undeclared
	.endm
error_redefine .macro
	jmp	ErrorV_redefine
	.endm
error_index .macro
	jmp	ErrorV_index
	.endm
error_memory .macro
	jmp	ErrorV_memory
	.endm
error_channel .macro
	jmp	ErrorV_channel
	.endm
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		frames.inc
;		Purpose:	Stack frames
;		Created:	19th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;						Upper 3 bits : identifier, lower 5 : total frame size
;
; ************************************************************************************************

FRAME_GOSUB = $E4 							; Gosub has 4 bytes
FRAME_FOR = $C0+19 							; For has 19 bytes

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		integers.asm
;		Purpose:	Integer value read/write
;		Created:	14th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Faster make-integer
;
; ************************************************************************************************

floatinteger .macro
		jsr 	FloatIntegerPart
		.endm

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
;
;	This file is automatically generated
;
PCD_STARTBINARY = $80
PCD_ENDBINARY = $8d
PCD_STARTCOMMAND = $8d
PCD_ENDCOMMAND = $ca
PCD_STARTSYSTEM = $ca
PCD_ENDSYSTEM = $d5

PCD_PLUS             = $80 ; +
PCD_MINUS            = $81 ; -
PCD_TIMES            = $82 ; *
PCD_DIVIDE           = $83 ; /
PCD_POWER            = $84 ; ^
PCD_AND              = $85 ; and
PCD_OR               = $86 ; or
PCD_GREATER          = $87 ; >
PCD_EQUAL            = $88 ; =
PCD_LESS             = $89 ; <
PCD_GREATEREQUAL     = $8a ; >=
PCD_LESSGREATER      = $8b ; <>
PCD_LESSEQUAL        = $8c ; <=
PCD_ABS              = $8d ; abs
PCD_ARRAY            = $8e ; array
PCD_ASC              = $8f ; asc
PCD_ASSERT           = $90 ; assert
PCD_BINDOLLAR        = $91 ; bin$
PCD_PRINTCMD_CHR     = $92 ; print.chr
PCD_CHRDOLLAR        = $93 ; chr$
PCD_SCMD_CMP         = $94 ; s.cmp
PCD_FOR              = $95 ; for
PCD_FRE              = $96 ; fre
PCD_GET              = $97 ; get
PCD_RETURN           = $98 ; return
PCD_PSET             = $99 ; pset
PCD_LINE             = $9a ; line
PCD_RECT             = $9b ; rect
PCD_FRAME            = $9c ; frame
PCD_CHAR             = $9d ; char
PCD_HEXDOLLAR        = $9e ; hex$
PCD_INPUT            = $9f ; input
PCD_INPUTDOLLAR      = $a0 ; input$
PCD_INPUTCMD_START   = $a1 ; input.start
PCD_LEN              = $a2 ; len
PCD_FCMD_CMP         = $a3 ; f.cmp
PCD_INTCMD_DIV       = $a4 ; int.div
PCD_NEGATE           = $a5 ; negate
PCD_NEWCMD_LINE      = $a6 ; new.line
PCD_NEXT             = $a7 ; next
PCD_NOT              = $a8 ; not
PCD_ON               = $a9 ; on
PCD_MOREON           = $aa ; moreon
PCD_PEEK             = $ab ; peek
PCD_POKE             = $ac ; poke
PCD_POS              = $ad ; pos
PCD_GETCHANNEL       = $ae ; getchannel
PCD_SETCHANNEL       = $af ; setchannel
PCD_PRINTCMD_N       = $b0 ; print.n
PCD_PRINTCMD_S       = $b1 ; print.s
PCD_READ             = $b2 ; read
PCD_READDOLLAR       = $b3 ; read$
PCD_RND              = $b4 ; rnd
PCD_CONCAT           = $b5 ; concat
PCD_SGN              = $b6 ; sgn
PCD_PRINTCMD_TAB     = $b7 ; print.tab
PCD_PRINTCMD_POS     = $b8 ; print.pos
PCD_PRINTCMD_SPC     = $b9 ; print.spc
PCD_STRDOLLAR        = $ba ; str$
PCD_LEFTDOLLAR       = $bb ; left$
PCD_RIGHTDOLLAR      = $bc ; right$
PCD_MIDDOLLAR        = $bd ; mid$
PCD_SWAP             = $be ; swap
PCD_TI               = $bf ; ti
PCD_TIDOLLAR         = $c0 ; ti$
PCD_USR              = $c1 ; usr
PCD_VAL              = $c2 ; val
PCD_CLOSE            = $c3 ; close
PCD_EXIT             = $c4 ; exit
PCD_DEBUG            = $c5 ; debug
PCD_OPEN             = $c6 ; open
PCD_SCREEN           = $c7 ; screen
PCD_VPOKE            = $c8 ; vpoke
PCD_VPEEK            = $c9 ; vpeek
PCD_CMD_SHIFT        = $ca ; .shift
PCD_CMD_BYTE         = $cb ; .byte
PCD_CMD_WORD         = $cc ; .word
PCD_CMD_FLOAT        = $cd ; .float
PCD_CMD_STRING       = $ce ; .string
PCD_CMD_DATA         = $cf ; .data
PCD_CMD_GOTO         = $d0 ; .goto
PCD_CMD_GOSUB        = $d1 ; .gosub
PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
PCD_CMD_VARSPACE     = $d4 ; .varspace
PCD_CLR              = $ca80 ; clr
PCD_DIM              = $ca81 ; dim
PCD_END              = $ca82 ; end
PCD_JOY              = $ca83 ; joy
PCD_INT              = $ca84 ; int
PCD_SQR              = $ca85 ; sqr
PCD_LOG              = $ca86 ; log
PCD_EXP              = $ca87 ; exp
PCD_COS              = $ca88 ; cos
PCD_SIN              = $ca89 ; sin
PCD_TAN              = $ca8a ; tan
PCD_ATN              = $ca8b ; atn
PCD_MOUSE            = $ca8c ; mouse
PCD_MB               = $ca8d ; mb
PCD_MX               = $ca8e ; mx
PCD_MY               = $ca8f ; my
PCD_RESTORE          = $ca90 ; restore
PCD_STOP             = $ca91 ; stop
PCD_SYS              = $ca92 ; sys
PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
PCD_WAIT             = $ca94 ; wait
PCD_I2CPOKE          = $ca95 ; i2cpoke
PCD_I2CPEEK          = $ca96 ; i2cpeek
PCD_BANK             = $ca97 ; bank
PCD_SLEEP            = $ca98 ; sleep
PCD_FMINIT           = $ca99 ; fminit
PCD_FMNOTE           = $ca9a ; fmnote
PCD_FMDRUM           = $ca9b ; fmdrum
PCD_FMINST           = $ca9c ; fminst
PCD_FMVIB            = $ca9d ; fmvib
PCD_FMFREQ           = $ca9e ; fmfreq
PCD_FMVOL            = $ca9f ; fmvol
PCD_FMPAN            = $caa0 ; fmpan
PCD_FMPLAY           = $caa1 ; fmplay
PCD_FMCHORD          = $caa2 ; fmchord
PCD_FMPOKE           = $caa3 ; fmpoke
PCD_PSGINIT          = $caa4 ; psginit
PCD_PSGNOTE          = $caa5 ; psgnote
PCD_PSGVOL           = $caa6 ; psgvol
PCD_PSGWAV           = $caa7 ; psgwav
PCD_PSGFREQ          = $caa8 ; psgfreq
PCD_PSGPAN           = $caa9 ; psgpan
PCD_PSGPLAY          = $caaa ; psgplay
PCD_PSGCHORD         = $caab ; psgchord
PCD_CLS              = $caac ; cls
PCD_LOCATE           = $caad ; locate
PCD_COLOR            = $caae ; color
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		runtime.inc
;		Purpose:	Runtime includes
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

entercmd 	.macro
		plx
		.endm

exitcmd 	.macro
		jmp 	NextCommand
		.endm

		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		write_int.asm
;		Purpose:	WriteInteger
;		Created:	13th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;							  Macro to set up working address
;
; ************************************************************************************************

vaddress .macro
		lda 	(codePtr),y 				; get the LSB of the halved offset.
		sta 	zTemp0 						; save in MSB

		dey 								; get the upper 3 bits
		lda 	(codePtr),y
		and 	#7
		iny
		iny

		asl 	zTemp0 						; shift zTemp0:A left
		rol 	a 							; carry will be clear.
		adc 	#VariableStart >> 8 		; point to variable page.
		sta 	zTemp0+1
		.endm

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		vera.inc
;		Purpose:	Vera constants
;		Created:	29th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code
		
VRAMLow0 = $9F20
VRAMMed0 = $9F21
VRAMHigh0 = $9F22
VRAMData0 = $9F23

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_audio_include.inc
;		Purpose:	Addresses X16 Kernal (Audio API)
;		Created:	7th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************
;
;		All these have to be called by JSRFAR.
;
X16A_audio_init=$C09F
X16A_bas_fmchordstring=$C08D
X16A_bas_fmfreq=$C000
X16A_bas_fmnote=$C003
X16A_bas_fmplaystring=$C006
X16A_bas_fmvib=$C009
X16A_bas_playstringvoice=$C00C
X16A_bas_psgchordstring=$C090
X16A_bas_psgfreq=$C00F
X16A_bas_psgnote=$C012
X16A_bas_psgwav=$C015
X16A_bas_psgplaystring=$C018
X16A_notecon_bas2fm=$C01B
X16A_notecon_bas2midi=$C01E
X16A_notecon_bas2psg=$C021
X16A_notecon_fm2bas=$C024
X16A_notecon_fm2midi=$C027
X16A_notecon_fm2psg=$C02A
X16A_notecon_freq2bas=$C02D
X16A_notecon_freq2fm=$C030
X16A_notecon_freq2midi=$C033
X16A_notecon_freq2psg=$C036
X16A_notecon_midi2bas=$C039
X16A_notecon_midi2fm=$C03C
X16A_notecon_midi2psg=$C03F
X16A_notecon_psg2bas=$C042
X16A_notecon_psg2fm=$C045
X16A_notecon_psg2midi=$C048
X16A_psg_getatten=$C093
X16A_psg_getpan=$C096
X16A_psg_init=$C04B
X16A_psg_playfreq=$C04E
X16A_psg_read=$C051
X16A_psg_setatten=$C054
X16A_psg_setfreq=$C057
X16A_psg_setpan=$C05A
X16A_psg_setvol=$C05D
X16A_psg_write=$C060
X16A_psg_write_fast=$C0A2
X16A_ym_getatten=$C099
X16A_ym_getpan=$C09C
X16A_ym_init=$C063
X16A_ym_loaddefpatches=$C066
X16A_ym_loadpatch=$C069
X16A_ym_loadpatchlfn=$C06C
X16A_ym_playdrum=$C06F
X16A_ym_playnote=$C072
X16A_ym_setatten=$C075
X16A_ym_setdrum=$C078
X16A_ym_setnote=$C07B
X16A_ym_setpan=$C07E
X16A_ym_read=$C081
X16A_ym_release=$C084
X16A_ym_trigger=$C087
X16A_ym_write=$C08A
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_include.inc
;		Purpose:	Addresses X16 Kernal
;		Created:	2nd May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

X16_r0 = 2
X16_r1 = 4
X16_r2 = 6
X16_r3 = 8
X16_r4 = 10

X16_ACPTR=$FFA5
X16_BASIN=$FFCF
X16_BSAVE=$FEBA
X16_BSOUT=$FFD2
X16_CIOUT=$FFA8
X16_CLALL=$FFE7
X16_CLOSE=$FFC3
X16_CHKIN=$FFC6
X16_CHKOUT=$FFC9
X16_clock_get_date_time=$FF50
X16_clock_set_date_time=$FF4D
X16_CHRIN=$FFCF
X16_CHROUT=$FFD2
X16_CLOSE_ALL=$FF4A
X16_CLRCHN=$FFCC
X16_console_init=$FEDB
X16_console_get_char=$FEE1
X16_console_put_char=$FEDE
X16_console_put_image=$FED8
X16_console_set_paging_message=$FED5
X16_enter_basic=$FF47
X16_entropy_get=$FECF
X16_fetch=$FF74
X16_FB_cursor_next_line=$FF02
X16_FB_cursor_position=$FEFF
X16_FB_fill_pixels=$FF17
X16_FB_filter_pixels=$FF1A
X16_FB_get_info=$FEF9
X16_FB_get_pixel=$FF05
X16_FB_get_pixels=$FF08
X16_FB_init=$FEF6
X16_FB_move_pixels=$FF1D
X16_FB_set_8_pixels=$FF11
X16_FB_set_8_pixels_opaque=$FF14
X16_FB_set_palette=$FEFC
X16_FB_set_pixel=$FF0B
X16_FB_set_pixels=$FF0E
X16_GETIN=$FFE4
X16_GRAPH_clear=$FF23
X16_GRAPH_draw_image=$FF38
X16_GRAPH_draw_line=$FF2C
X16_GRAPH_draw_oval=$FF35
X16_GRAPH_draw_rect=$FF2F
X16_GRAPH_get_char_size=$FF3E
X16_GRAPH_init=$FF20
X16_GRAPH_move_rect=$FF32
X16_GRAPH_put_char=$FF41
X16_GRAPH_set_colors=$FF29
X16_GRAPH_set_font=$FF3B
X16_GRAPH_set_window=$FF26
X16_i2c_read_byte=$FEC6
X16_i2c_write_byte=$FEC9
X16_IOBASE=$FFF3
X16_JSRFAR=$FF6E
X16_joystick_get=$FF56
X16_joystick_scan=$FF53
X16_kbdbuf_get_modifiers=$FEC0
X16_kbdbuf_peek=$FEBD
X16_kbdbuf_put=$FEC3
X16_keymap=$FED2
X16_LISTEN=$FFB1
X16_LKUPLA=$FF59
X16_LKUPSA=$FF5C
X16_LOAD=$FFD5
X16_MACPTR=$FF44
X16_MEMBOT=$FF9C
X16_memory_copy=$FEE7
X16_memory_crc=$FEEA
X16_memory_decompress=$FEED
X16_memory_fill=$FEE4
X16_MEMTOP=$FF99
X16_monitor=$FECC
X16_mouse_config=$FF68
X16_mouse_get=$FF6B
X16_mouse_scan=$FF71
X16_OPEN=$FFC0
X16_PFKEY=$FF65
X16_PLOT=$FFF0
X16_PRIMM=$FF7D
X16_RDTIM=$FFDE
X16_READST=$FFB7
X16_SAVE=$FFD8
X16_SCREEN=$FFED
X16_screen_mode=$FF5F
X16_screen_set_charset=$FF62
X16_SECOND=$FF93
X16_SETLFS=$FFBA
X16_SETMSG=$FF90
X16_SETNAM=$FFBD
X16_SETTIM=$FFDB
X16_SETTMO=$FFA2
X16_sprite_set_image=$FEF0
X16_sprite_set_position=$FEF3
X16_stash=$FF77
X16_STOP=$FFE1
X16_TALK=$FFB4
X16_TKSA=$FF96
X16_UDTIM=$FFEA
X16_UNLSN=$FFAE
X16_UNTLK=$FFAB

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_machinecode.inc
;		Purpose:	Addresses for SYS and USR
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;								Addresses for SYS and USR
;
; ************************************************************************************************
;
;		Vector for USR() function
;
USRRoutineAddress = $311
;
;		Register addresses for SYS command
;
SYS_Reg_A = $30C
SYS_Reg_X = $30D
SYS_Reg_Y = $30E
SYS_Reg_S = $30F

; ************************************************************************************************
;
;									Select RAM/ROM bank
;
; ************************************************************************************************

SelectRAMBank = 0
SelectROMBank = 1

; ************************************************************************************************
;
;						  ROM Bank audio code is in (for JSRFAR)
;
; ************************************************************************************************

X16_AudioCodeBank = $0A

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		00runtime.asm
;		Purpose:	Runtime interpreter main
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

StartRuntime:	
		ldx 	#$FF 						; reset stack.
		txs

		jsr 	ClearMemory 				; clear memory.
		jsr 	XRuntimeSetup 				; initialise the runtime stuff.
	 	jsr		SetDefaultChannel			; set default input/output channel.


		.set16 	codePtr,EndProgram+2 		; also used in RESTORE
		stz 	codePage

		jsr 	RestoreCode 				; which we now call
		;
		;		Main Run Loop
		;
		ldy 	#0	
NextCommand:
		lda 	(codePtr),y 				; get next
		bmi 	NXCommand 					; -if -ve command
		iny
		cmp 	#64 						; 64..127 is load and store.
		bcc 	PushByteA 					; 0..63 is short constants.
		;
		;		Load/Store dispatch.
		;
NXLoadStore:
		cmp		#120 						; is it an indirect read/write
		bcs 	NXIndirectLoadStore
		lsr 	a 							; / 4, so $48 => $12,
		lsr 	a 
		and 	#$0E
		phx 								; get ready to jump
		tax
		jmp 	(ReadWriteVectors,x) 		; go via the jump table.

ReadWriteVectors:
		.word 	ReadFloatCommand			; read float
		.word 	WriteFloatCommand 			; write float
		.word 	ReadIntegerCommand 			; read integer
		.word 	WriteIntegerCommand 		; write integer
		.word 	ReadStringCommand 			; read string
		.word 	WriteStringCommand 			; write string
		.word 	Unimplemented 				
		.word 	Unimplemented 		
		;
		;		Indirect Load/store dispatch
		;
NXIndirectLoadStore:
		and 	#7
		asl 	a
		phx
		tax
		jmp 	(IndirectVectors,x)

IndirectVectors:
		.word 	IndFloatRead 				; float read				
		.word 	IndInt16Read 				; int16 read				
		.word 	IndStringRead 				; string read				
		.word 	Unimplemented
		.word 	IndFloatWrite				; float write
		.word 	IndInt16Write 				; int16 write				
		.word 	IndStringWrite 				; string write				
		.word 	Unimplemented
		;		
		;		Push byte on stack
		;
PushByteCommand: ;; [.byte]			
		.entercmd
		lda 	(codePtr),y 				; get byte to write.
		iny
PushByteA:		
		inx 								; push constant on stack
		sta 	NSMantissa0,x 				; save byte
		stz 	NSMantissa1,x 				; clear MSB
ClearRestWord:		
		stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
		stz 	NSMantissa3,x
		stz 	NSExponent,x
		stz 	NSStatus,x
		bra 	NextCommand
		;
		;		Push a word on the stack
		;
PushWordCommand: ;; [.word]
		.entercmd
		inx
		lda 	(codePtr),y 				; word to stack
		iny
		sta 	NSMantissa0,x		
		lda 	(codePtr),y
		iny
		sta 	NSMantissa1,x		
		bra 	ClearRestWord 				; handle everything else.
		;
		;		Execute a command
		;
NXCommand:
		iny 								; consume command.
		bpl 	_NXCommandNoFixUp
		jsr 	FixUpY
_NXCommandNoFixUp:		
		asl 	a 							; shift left 
		phx 								; save SP on stack
		tax				 					; and jump indirect
		jmp 	(VectorTable,x)

; ************************************************************************************************
;
;		Called after Y is negative after incrementing in the two main fetches, it resets
;		Y to zero and adds it to the codePtr ; thus we don't do lots of 16 bit increments,
;		nor are we limited to 1/4 k of P-Code per line.
;
; ************************************************************************************************

FixUpY:	
		pha
		tya
		clc 
		adc 	codePtr
		sta 	codePtr
		bcc 	_NoCPCarry
		inc 	codePtr+1
_NoCPCarry:
		ldy 	#0
		pla
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		abs.asm
;		Purpose:	Absolute value of TOS
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									     Absolute TOS
;
; ************************************************************************************************

AbsoluteTOS:	;; [abs]
		.entercmd
		stz 	NSStatus,x 					; dereferenced so just clear the status byte.
		.exitcmd

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		allocate.asm
;		Purpose:	Allocate variable memory
;		Created:	25th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;					Command which receives limit of variable memory
;
; ************************************************************************************************

CommandVarSpace: ;; [.varspace]
		.entercmd
		
		lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
		sta 	availableMemory
		iny 
		lda 	(codePtr),y
		clc 
		adc 	#WorkArea >> 8 				; offset to actual address.
		sta 	availableMemory+1
		iny

		.exitcmd
		.send 	code

		.section zeropage
availableMemory: 							; available memory as offset
		.fill 	2
		.send zeropage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		andor.asm
;		Purpose:	And/Or operators
;		Created:	14th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									AND/OR code
;
; ************************************************************************************************

BinaryAnd: ;; [and]
		.entercmd
		sec
		bra 	AndOrCommon
BinaryOr: ;; [or]
		.entercmd
		clc

AndOrCommon:
		php 								; save AND/OR flag
			 								; convert both to 16 bit format.
		jsr 	GetInteger16Bit
		dex		
		jsr 	GetInteger16Bit

		plp
		bcc 	_AOCOrCode
	
		lda 	NSMantissa0,x 				; AND code
		and		NSMantissa0+1,x
		sta 	NSMantissa0,x
		lda 	NSMantissa1,x
		and		NSMantissa1+1,x
		sta 	NSMantissa1,x
		bra 	_AOCComplete
_AOCOrCode:
		lda 	NSMantissa0,x 				; OR code
		ora		NSMantissa0+1,x
		sta 	NSMantissa0,x
		lda 	NSMantissa1,x
		ora		NSMantissa1+1,x
		sta 	NSMantissa1,x
_AOCComplete:		
		stz 	NSStatus,x 					; make integer ?
		bit 	NSMantissa1,x 				; result is -ve
		bpl 	_AOCExit

		jsr 	Negate16Bit 				; 2's complement
		lda 	#$80 						; make it -ve
		sta 	NSStatus,x
_AOCExit:		
		.exitcmd

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		array.asm
;		Purpose:	Convert an array index reference to a physical address
;		Created:	27th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;						<i1> <i2> <i3> <icount> ARRAY <address>
;
; ************************************************************************************************

ArrayConvert: ;; [array]
		.entercmd
		phy
		;
		;		Convert to a real address in zTemp1
		;
		lda 	NSMantissa0,x
		sta 	zTemp1
		lda 	NSMantissa1,x
		clc
		adc 	#(WorkArea >> 8)		
		sta 	zTemp1+1
		;
		;		Set up for following, firstly get the number of levels to zTemp2, and point the 
		;		stack to the first level.
		;
		dex 								; count of indices to follow -> zTemp2
		jsr 	GetInteger8Bit 
		sta 	zTemp2 						; subtract from stack.

		txa
		sec
		sbc 	zTemp2
		tax 
		phx 								; stack points at the first index, which will be replaced.		
		;
		;		The loop for following down the indices
		;
_ACIndexLoop:		
		jsr 	FloatIntegerPart 			; integer array index
		jsr 	GetInteger16Bit 			; get the index => zTemp0
		ldy 	#1 							; compare against the index count.
		lda 	zTemp0
		cmp 	(zTemp1)
		lda 	zTemp0+1
		sbc 	(zTemp1),y
		bcs 	_ACBadIndex 				; index error.
		dec 	zTemp2 						; decrement count, if zero, then innermost level
		beq 	_ACInnerLevel
		;
		;		Follow down a level
		;
		ldy 	#2 							; check sub index.
		lda 	(zTemp1),y
		bpl 	_ACBadIndex

		asl 	zTemp0 						; double the index and add it to the base address
		rol 	zTemp0+1 					
		clc
		lda		zTemp0
		adc 	zTemp1
		sta 	zTemp0	
		lda		zTemp0+1
		adc 	zTemp1+1
		sta 	zTemp0+1
		;
		;		Follow the link address and set up zTemp1 one level down.
		;
		ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
		lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
		sta 	zTemp1
		iny
		lda 	(zTemp0),y
		clc
		adc 	#(WorkArea >> 8)
		sta 	zTemp1+1
		inx 								; next index
		bra 	_ACIndexLoop
		;
		;		Reached the innermost level.
		;
_ACInnerLevel:
		;
		;		Check it is an inner level, and get the type
		;
		ldy 	#2
		lda 	(zTemp1),y
		bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
		and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
		cmp 	#NSSIFloat
		bne 	_ACNotFloat
		;
		;		x2 or x6 depending on type.
		;
		lda 	zTemp0+1 					; double and add zTemp0 (x3)
		pha
		lda 	zTemp0

		asl 	zTemp0 						; x 2
		rol 	zTemp0+1

		clc 								; add back x 3
		adc 	zTemp0
		sta 	zTemp0
		pla
		adc 	zTemp0+1
		sta 	zTemp0+1
_ACNotFloat:
		asl 	zTemp0 						; x 2 or x 6 depending. 
		rol 	zTemp0+1
		;
		;		Add 3 , the prefix of the array structure
		;
		clc
		lda 	zTemp0
		adc 	#3
		sta 	zTemp0
		bcc 	_ACNoCarry
		inc 	zTemp0+1
_ACNoCarry:		
		;
		;		Add the base address of the array, making it back into an offset.
		;	
		plx 								; X points to first slot of array parameters
		clc
		lda 	zTemp0
		adc 	zTemp1
		sta 	NSMantissa0,x
		lda 	zTemp0+1
		adc 	zTemp1+1
		sec 	
		sbc 	#(WorkArea >> 8)
		sta 	NSMantissa1,x
		stz 	NSMantissa2,x
		stz 	NSMantissa3,x
		stz 	NSStatus,x
		stz 	NSExponent,x
		ply 	 							; restore code pointer

		.exitcmd

_ACBadIndex:
		.error_index

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		asc.asm
;		Purpose:	ASCII value of string first character
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;								  ASCII value of first character.
;
; ************************************************************************************************

		.section code

UnaryAsc: ;; [asc]
		.entercmd
		phy
		;
		lda 	NSMantissa0,x 				; string address.
		sta 	zTemp0
		lda 	NSMantissa1,x
		sta 	zTemp0+1
		;
		lda 	(zTemp0) 					; if empty string return zero
		beq 	_UAExit
		phy 								; otherwise first character
		ldy 	#1
		lda 	(zTemp0),y
		ply
_UAExit:
		jsr 	FloatSetByte
		ply
		.exitcmd

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		assert.asm
;		Purpose:	Assert
;		Created:	14th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										ASSERT command
;
; ************************************************************************************************

CommandAssert: ;; [assert]
		.entercmd
		cpx 	#0 							; check only one element on stack
		bne 	_CAFail
		jsr 	FloatIsZero 				; is it zero ?
		beq 	_CAFail
		dex	
		.exitcmd

_CAFail:
		.error_assert		

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		audioparams.asm
;		Purpose:	Audio Parameter functions for FM_ PSG_
;		Created:	9th May 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								Get parameters either as A:0X or A:YX
;
; ************************************************************************************************

X16_Audio_Parameters8_16:
		jsr 	X16_Audio_Parameters8_8	
		ldy 	NSMantissa1+1
		rts

X16_Audio_Parameters8_8:
		ldx 	#1
		.floatinteger
		dex
		.floatinteger
		jsr 	GetInteger8Bit
		ldx 	NSMantissa0+1
		ldy 	#0
		rts

; ************************************************************************************************
;
;						Get parameters as a string : A:Length YX:String
;
; ************************************************************************************************

X16_Audio_Parameters8_String:
		jsr 	X16_Audio_Parameters8_16 	; get as numbers.
		;
		phx 								; set the voice
		phy
		jsr 	X16_JSRFAR
		jsr 	X16A_bas_playstringvoice
		.byte 	X16_AudioCodeBank
		ply
		plx
		;
		stx 	zTemp0
		sty 	zTemp0+1
		lda 	(zTemp0) 					; read length
		inx 								; point YX to first character.
		bne 	_X16APSSkip
		iny
_X16APSSkip:
		rts		
		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		bin.asm
;		Purpose:	Binary conversion
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code
		
; ************************************************************************************************
;
;								BIN$ (integer to string)
;
; ************************************************************************************************

Unary16Bin: ;; [bin$]
		.entercmd
		jsr 	GetInteger16Bit				; 16 bit int 
		lda 	#16 						; allocate / set 16 bytes.
		jsr 	StringAllocTemp
		lda 	zTemp0+1
		beq 	_UBNoHigh
		jsr 	_UBWriteBinary
_UBNoHigh:
		lda 	zTemp0
		jsr 	_UBWriteBinary
		.exitcmd

_UBWriteBinary:	
		phy	
		ldy 	#8
_UBWLoop:
		asl 	a
		pha
		lda  	#0
		adc 	#48		
		jsr 	StringWriteChar
		pla
		dey
		bne 	_UBWLoop
		ply
		rts


		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		charprint.asm
;		Purpose:	Print top of stack as character
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						  			Print CHR$(S[X])
;
; ************************************************************************************************

PrintCharacter: ;; [print.chr]
		.entercmd
		lda 	NSMantissa0,x 	
		dex
		jsr 	VectorPrintCharacter
		.exitcmd
		
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		chr.asm
;		Purpose:	Convert number to character.
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;											CHR$(n)
;
; ************************************************************************************************

		.section code

UnaryChr: ;; [chr$]
		.entercmd
		jsr 	GetInteger8Bit 				; get integer to convert.
		pha 								; save it and allocate for it
		lda 	#1 							; 1 character
		jsr 	StringAllocTemp 	
		lda 	#1 							; length 1.
		sta 	(zsTemp)
		pla 								; character code makes string.
		phy
		ldy 	#1
		sta 	(zsTemp),y
		ply
		.exitcmd

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		clr.asm
;		Purpose:	Clear memory down
;		Created:	13th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										CLR command
;
; ************************************************************************************************

CommandClr: ;; [!CLR]
		.entercmd
		jsr 	ClearMemory
		.exitcmd

; ************************************************************************************************
;
;					Clear workspace, reset string system, reset BASIC stack
;
; ************************************************************************************************

ClearMemory:		
		;
		;		Zero workspace
		;
		.set16 zTemp0,WorkArea 							; erase the work area
		phy
		ldy 	#0
_ClearLoop1:	
		lda 	#0
		sta 	(zTemp0),y
		iny
		bne 	_ClearLoop1	
		inc 	zTemp0+1
		lda 	zTemp0+1
		cmp 	#(WorkArea+WorkAreaSize) >> 8
		bne 	_ClearLoop1
		;
		;		Initialise strings
		;
		.set16 	stringHighMemory,StringTopAddress 		; reset string memory alloc pointer
		stz 	stringInitialised 						; string system not initialised
		;
		;		Initialise stack
		;
		.set16 	runtimeStackPtr,StackTopAddress-1 		; current TOS
		lda 	#$FF 									; duff marker in case we try to remove it.
		sta 	(runtimeStackPtr)
		ply
		rts

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		compare.asm
;		Purpose:	Compare strings
;		Created:	12th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						  Compare String S[X],S[X+1] - return 255,0,1
;
; ************************************************************************************************

CompareStrings: ;; [s.cmp]
		.entercmd

		dex
		
		lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
		sta 	zTemp0
		lda 	NSMantissa1,x
		sta 	zTemp0+1

		lda 	NSMantissa0+1,x 			
		sta 	zTemp1
		lda 	NSMantissa1+1,x
		sta 	zTemp1+1

		phx
		phy

		lda 	(zTemp0)					; work out number to compare
		cmp 	(zTemp1)
		bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
		lda 	(zTemp1)
_CSNIsSmallest:
		tax 								; count in X
		beq 	_CSNMatches 				; if zero already matches as far as we can go.
		ldy 	#0 							; start from offset 1
_CSNCompareString:
		iny 								; pre increment
		lda 	(zTemp0),y
		cmp 	(zTemp1),y
		bne 	_CSNDifferent 				; numbers are different.
		dex
		bne 	_CSNCompareString 			; compare common characters in two strings.
_CSNMatches:
		sec			
		lda 	(zTemp0)					; compare lengths
		sbc 	(zTemp1)
		beq 	_CSNSExit 					; if zero, then strings match and exit.
_CSNDifferent:
		lda 	#$FF
		bcc 	_CSNSExit
		lda 	#$01
_CSNSExit:
		ply
		plx
		cmp 	#0 							; set the flags.
		jsr 	FloatSetByte 				; output the byte
		.exitcmd

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		concrete.asm
;		Purpose:	Concrete string memory
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Concrete String YA -> YA
;
; ************************************************************************************************

StringConcrete:	
		stz 	stringInitialised	 		; initialise next usage

		sty 	zTemp2+1 					; save pointer to new string
		sta 	zTemp2
		;
		lda 	(zTemp2) 					; length required
		lsr 	a 							; allow half as much for expansion.
		clc
		adc 	(zTemp2)
		bcc 	_SCNoOverflow
		lda 	#255
_SCNoOverflow:
		cmp 	#10 						; and a minimum of 10
		bcs 	_SCNoMinimum		
		lda 	#10
_SCNoMinimum:
		sta 	zTemp1 						; save max length.
		;
		sec
		lda		stringHighMemory 			; subtract max length from high memory.
		sbc 	zTemp1
		tay
		lda 	stringHighMemory+1 	
		sbc 	#0
		pha
		;
		sec 								; subtract 3 more
		tya 							
		sbc 	#3
		sta 	stringHighMemory 			; to string high memory/zsTemp
		sta 	zsTemp
		;
		pla
		sbc 	#0
		sta 	stringHighMemory+1
		sta 	zsTemp+1
		;
		lda 	zTemp1 						; set max length.
		sta 	(zsTemp)
		ldy 	#1 							; clear control byte.
		lda 	#0
		sta 	(zsTemp),y
		;
		lda 	zsTemp 						; new empty string in YA.
		ldy 	zsTemp+1
		rts

		.send code

; ************************************************************************************************
;
;		Concreted string (total size = MaxLength + 3)
;
;		[Max length] [Control] [Act Length] [Data]
;		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		data.asm
;		Purpose:	Skip inline DATA
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									.data <len> ASCIIZ code.
;
; ************************************************************************************************

CommandData: ;; [.data]
		.entercmd
		tya 								; data length +1 added to Y
		sec 								
		adc 	(codePtr),y 				; next instruction
		tay
		.exitcmd

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		dim.asm
;		Purpose:	Create new array
;		Created:	26th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;					<dim1> <dim2> <dim.n> <n> <type.data> DIM <base.address>
;
; ************************************************************************************************

CommandDIM: ;; [!dim]
		.entercmd
		phy
		jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
		sta 	dimType
		dex 								; this is the number of indices
		jsr 	GetInteger8Bit 
		sta 	zTemp1 						; subtract n from X so X points at the *first*
		txa 								; dimension.
		sec
		sbc 	zTemp1
		tax
		lda 	zTemp1 						; number of indices.
		jsr 	DIMCreateOneLevel 			; create one at this level
		;
		sta 	NSMantissa0,x 				; set it as a return address as an integer
		tya
		sta 	NSMantissa1,x
		stz 	NSMantissa2,x
		stz 	NSMantissa3,x
		stz 	NSStatus,x
		stz 	NSExponent,x
		ply
		.exitcmd

; ************************************************************************************************
;
;		Create one level , at depth A, with the stack,X being the extent of the index
;		returns the offset address in YA.
;
; ************************************************************************************************

DIMCreateOneLevel:
		;
		;		Save the start on the stack
		;
		ldy 	availableMemory 			; push the start of this block on the stack.
		phy
		ldy 	availableMemory+1
		phy
		;
		;		Get dimension and bump it because A(10) is 11 elements.
		;
		tay 			 					; save current level into Y
		jsr		GetInteger16Bit 			; size of dimension to zTemp0
		inc 	zTemp0 						; bump the size of the dimension as we need one more
		bne 	_DCOLNoCarry
		inc 	zTemp0+1
_DCOLNoCarry:
		lda 	zTemp0 						; write out the +1 size of the dimension
		;
		;		Write out the header and the size/type byte
		;
		jsr 	DIMWriteByte
		lda 	zTemp0+1
		jsr 	DIMWriteByte
		lda 	dimType 					; get type information
		and 	#$7F
		cpy 	#1
		beq 	_DCOLNoSubLevel
		ora 	#$80 						; set sublevel bit if there is one.
_DCOLNoSubLevel:		 			
		jsr 	DIMWriteByte
		;
		;		Save start and count 
		;
		lda 	availableMemory
		sta 	zTemp1
		lda 	availableMemory+1
		sta 	zTemp1+1
		;
		lda 	zTemp0
		sta 	zTemp2
		lda 	zTemp0+1
		sta 	zTemp2+1
		;
		;		Erase the level to all zeros.
		;
_DCOLFillArray:
		jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data

		lda 	zTemp0 						; decrement one from count.
		bne 	_DCOLNoBorrow
		dec 	zTemp0+1
_DCOLNoBorrow:
		dec 	zTemp0
		;
		lda 	zTemp0 						; until completed.
		ora 	zTemp0+1		
		bne 	_DCOLFillArray
		;
		;		Check if we need to recursively fill.
		;
		cpy 	#1 							
		beq 	_DCOLExit
		;
		;		Need to work though again filling in with lower levels.
		; 		elements go at zTemp1, count in zTemp2, so these must be stacked
		;		when the creator is called recursively.
		;
_DCOLRecursionLoop:
		phx 								; save XY
		phy

		lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
		pha
		lda 	zTemp1+1
		pha
		lda 	zTemp2
		pha
		lda 	zTemp2+1
		pha

		dey  								; lower level -> A
		tya
		inx 								; next index size
		jsr 	DIMCreateOneLevel 			; create a level, return in YA

		plx 								; restore zTemp2 (count) and zTemp1 (position)
		stx 	zTemp2+1
		plx
		stx 	zTemp2
		plx
		stx 	zTemp1+1
		plx
		stx 	zTemp1
		;
		sta 	(zTemp1) 					; write out position
		tya
		ldy 	#1
		sta 	(zTemp1),y
		;
		ply 								; restore XY
		plx

		clc
		lda 	zTemp1 						; add 2 to zTemp1
		adc 	#2
		sta 	zTemp1
		bcc 	_DCOLRNoCarry
		inc 	zTemp1+1
_DCOLRNoCarry:
		lda 	zTemp2 						; decrement one from count in zTemp2
		bne 	_DCOLRNoBorrow
		dec 	zTemp2+1
_DCOLRNoBorrow:
		dec 	zTemp2
		;
		lda 	zTemp2 						; until completed.
		ora 	zTemp2+1		
		bne 	_DCOLRecursionLoop
		;
		;		Pop the start off the stack and return.
		;
_DCOLExit:		
		pla 								; get MSB, make offset again
		sec
		sbc 	#WorkArea >> 8
		tay
		pla 								; YA now contains offset address.
		rts

; ************************************************************************************************
;
;					Write out an array element of the appropriate size, empty
;
; ************************************************************************************************

DIMWriteElement:
		phx
		ldx	 	#2 							; work out size is 2 or 6
		cpy 	#1 							; do we have a sub level, if so 2.
		bne 	_DIMWENotFloat
		lda 	dimType 					
		and 	#NSSTypeMask+NSSIInt16
		cmp 	#NSSIFloat
		bne 	_DIMWENotFloat
		ldx 	#6
_DIMWENotFloat:
		lda 	#0
		jsr 	DIMWriteByte
		dex
		bne 	_DIMWENotFloat
		plx 			
		rts

; ************************************************************************************************
;
;							Write a single byte out to free memory
;
; ************************************************************************************************
	
DIMWriteByte:
		sta 	(availableMemory)
		inc 	availableMemory
		bne 	_DIMWBSkip
		inc 	availableMemory+1
		pha
		lda 	availableMemory+1 			; check out of memory
		cmp 	stringHighMemory+1
		bcs 	_DIMWBMemory
		pla
_DIMWBSkip:
		rts
_DIMWBMemory:
		.error_memory
		
		.send 	code

		.section storage
dimType:									; type bits being checked for.
		.fill 	1
		.send storage		

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		end.asm
;		Purpose:	END command
;		Created:	19th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										END command
;
; ************************************************************************************************

CommandEnd: ;; [!end]
		.entercmd
		stx 	zTemp0
		jmp 	$FFFF

; ************************************************************************************************

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		errorhandler.asm
;		Purpose:	Error handler
;		Created:	12th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

Unimplemented:
		jmp 	ErrorV_unimplemented
		
ErrorHandler:
		tya
		clc
		adc 	codePtr
		sta 	codePtr
		bcc 	_EHNoCarry
		inc 	codePtr+1
_EHNoCarry:		
		pla
		ply
		sta 	zTemp0
		sty 	zTemp0+1
		ldx 	#0 							; output to channel #0 
		ldy 	#1
_EHDisplayMsg:
		lda 	(zTemp0),y
		jsr 	XPrintCharacterToChannel
		iny
		lda 	(zTemp0),y
		bne 	_EHDisplayMsg
		lda 	#32
		jsr 	XPrintCharacterToChannel
		lda 	#64
		jsr 	XPrintCharacterToChannel
		lda 	#32
		jsr 	XPrintCharacterToChannel
		jsr 	EHDisplayCodePtr
_EHStop:bra 	_EHStop

EHDisplayCodePtr:
		lda 	#32
		jsr 	XPrintCharacterToChannel
		sec
		lda 	codePtr
		sbc 	#(EndProgram+2) & $FF
		pha
		lda 	codePtr+1
		sbc 	#(EndProgram+2) >> 8
		jsr 	_EHDisplayHex
		pla
		jsr 	_EHDisplayHex
		rts

_EHDisplayHex:
		pha
		lsr 	a
		lsr 	a
		lsr 	a
		lsr 	a
		jsr 	_EHDisplayNibble
		pla		
_EHDisplayNibble:
		and 	#15
		cmp 	#10
		bcc 	_EHNotHex
		adc 	#6
_EHNotHex:
		adc 	#48
		jmp 	XPrintCharacterToChannel
						
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
;
;	This file is automatically generated.
;
	.section code
ErrorV_range:
	jsr	ErrorHandler
	.text	"OUT OF RANGE",0
ErrorV_value:
	jsr	ErrorHandler
	.text	"BAD VALUE",0
ErrorV_syntax:
	jsr	ErrorHandler
	.text	"SYNTAX ERROR",0
ErrorV_type:
	jsr	ErrorHandler
	.text	"TYPE MISMATCH",0
ErrorV_unimplemented:
	jsr	ErrorHandler
	.text	"NOT IMPLEMENTED",0
ErrorV_assert:
	jsr	ErrorHandler
	.text	"ASSERT FAIL",0
ErrorV_line:
	jsr	ErrorHandler
	.text	"UNKNOWN LINE NUMBER",0
ErrorV_internal:
	jsr	ErrorHandler
	.text	"INTERNAL ERROR",0
ErrorV_divzero:
	jsr	ErrorHandler
	.text	"DIVIDE BY ZERO",0
ErrorV_structure:
	jsr	ErrorHandler
	.text	"STRUCTURE IMBALANCE",0
ErrorV_stop:
	jsr	ErrorHandler
	.text	"PROGRAM STOPPED",0
ErrorV_data:
	jsr	ErrorHandler
	.text	"OUT OF DATA",0
ErrorV_undeclared:
	jsr	ErrorHandler
	.text	"UNKNOWN ARRAY",0
ErrorV_redefine:
	jsr	ErrorHandler
	.text	"ARRAY REDEFINED",0
ErrorV_index:
	jsr	ErrorHandler
	.text	"BAD ARRAY INDEX",0
ErrorV_memory:
	jsr	ErrorHandler
	.text	"OUT OF MEMORY",0
ErrorV_channel:
	jsr	ErrorHandler
	.text	"INPUT/OUTPUT ERROR",0
	.send code
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		for.asm
;		Purpose:	FOR command
;		Created:	20th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								<RefAddr|Type> <Terminal> <Step> FOR
;
; ************************************************************************************************

CommandFor: ;; [for]
		.entercmd
		lda 	#FRAME_FOR 					; open frame
		jsr 	StackOpenFrame 			
		jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.

		ldy 	#7 							; copy step out
		jsr 	CopyTOSToOffsetY
		dex
		ldy 	#13 						; copy terminal value.
		jsr 	CopyTOSToOffsetY
		dex

		lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
		and 	#$80
		ldy 	#4
		sta 	(runtimeStackPtr),y

		lda 	NSMantissa0,x 				; copy the reference address
		ldy 	#5 							; adjusted to be a real address
		sta 	(runtimeStackPtr),y
		sta 	zTemp0 						; also to zTemp0
		iny
		lda 	NSMantissa1,x
		clc
		and 	#$7F 						; throw the type bit.
		sta 	(runtimeStackPtr),y
		adc 	#VariableStart >> 8 		; point to variable page.
		sta 	zTemp0+1
		dex 								; throw reference.
		;
		;		We look for optimisation options. Here we have optimisation
		; 		if the index value, step value, and terminal value are all
		; 		positive integers, step is 1 byte - we can do it much more quickly.
		;
		ldy 	#5 							; check the index, step and terminal values
		lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
		ldy 	#12 
		ora 	(runtimeStackPtr),y
		ldy 	#18
		ora 	(runtimeStackPtr),y
		and 	#$80 						; only interested in sign bit.
		;
		dey 								; now the exponents.
		ora 	(zTemp0),y
		ldy 	#11
		ora 	(runtimeStackPtr),y
		ldy 	#17
		ora 	(runtimeStackPtr),y

		ldy 	#8 							; step must be 1 byte.
		ora 	(runtimeStackPtr),y
		iny
		ora 	(runtimeStackPtr),y
		iny
		ora 	(runtimeStackPtr),y

		bne 	_CFNoOptimise 	

		ldy 	#4 							; set the runtime stack pointer optimisation flag.
		lda 	(runtimeStackPtr),y
		ora 	#$40
		sta 	(runtimeStackPtr),y

_CFNoOptimise:
		ldy 	#0
		.exitcmd	

; ************************************************************************************************
;
;								Copy TOS to stack frame offset Y
;
; ************************************************************************************************

CopyTOSToOffsetY:
		lda 	NSMantissa0,x
		sta 	(runtimeStackPtr),y
		iny
		lda 	NSMantissa1,x
		sta 	(runtimeStackPtr),y
		iny
		lda 	NSMantissa2,x
		sta 	(runtimeStackPtr),y
		iny
		lda 	NSMantissa3,x
		sta 	(runtimeStackPtr),y
		iny
		lda 	NSExponent,x
		sta 	(runtimeStackPtr),y
		iny
		lda 	NSStatus,x
		sta 	(runtimeStackPtr),y
		rts

; ************************************************************************************************
;
;		0	FOR Marker 				[1]
;		1 	Page/Position for loop 	[3]
;		4 	Control 				[1] 	Integer/Int16:7 ; optimised:6
;		5 	Index Variable 			[2]  	Offset Address 
;		7 	Step (+1 optimise) 		[6]
;		13	Terminal Value.	 		[6]
;
; ************************************************************************************************

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		forward.asm
;		Purpose:	Move object pointer forward
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Move objPtr forwards. CS if end
;
; ************************************************************************************************

MoveObjectForward:

		lda 	(objPtr) 					; get next
		
		cmp 	#$FF  						
		beq 	_MOFEnd

		cmp 	#$40 						; 00-3F
		bcc 	_MOFAdvance1 				; forward 1

		ldy 	#2 							; 40-6F
		cmp 	#$70 						; forward 2
		bcc 	_MOFAdvanceY 				

		cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
		bcc 	_MOFAdvance1 				; forward 1

		tay 								; read the size.
		lda 	MOFSizeTable-PCD_STARTSYSTEM,y
		tay
		iny 								; add 1 for the system token.
		bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.

		ldy 	#1 							; get length byte
		lda 	(objPtr),y
		tay 								; into Y.

		clc
		lda 	objPtr						; add 2 to the object pointer
		adc 	#2
		sta 	objPtr
		bcc 	_MOFNoCarry1
		inc 	objPtr+1
_MOFNoCarry1:		
		bra 	_MOFAdvanceY

_MOFAdvance1:
		ldy 	#1
_MOFAdvanceY:				
		tya 								; add X to objPtr
		clc
		adc 	objPtr
		sta 	objPtr
		bcc 	_MOFNoCarry2
		inc 	objPtr+1
_MOFNoCarry2:		
		clc 								; not completed.
		rts
		;
		;		At the end so advance past $FF end marker and return CS.
		;
_MOFEnd:
		inc 	objPtr
		bne 	_MOFENoCarry
		inc 	objPtr+1
_MOFENoCarry:
		sec
		rts		

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		frames.asm
;		Purpose:	Stack frame routines
;		Created:	19th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Open a frame
;
; ************************************************************************************************

StackOpenFrame:
		pha 								; save frame marker
		and 	#$1F 						; bytes required.
		sta 	zTemp0
		;
		sec 								; subtract from runtime stack pointer.
		lda		runtimeStackPtr
		sbc 	zTemp0
		sta 	runtimeStackPtr
		lda		runtimeStackPtr+1
		sbc 	#0
		sta 	runtimeStackPtr+1
		;
		pla 								; put frame marker at +0
		sta 	(runtimeStackPtr)
		rts

; ************************************************************************************************
;
;										Close a frame
;
; ************************************************************************************************

StackCloseFrame:
		lda 	(runtimeStackPtr)			; get frame marker
		and 	#$1F 						; size
		clc
		adc 	runtimeStackPtr
		sta 	runtimeStackPtr
		bcc 	_SCFNoCarry
		inc 	runtimeStackPtr+1
_SCFNoCarry:
		rts

; ************************************************************************************************
;
;									Find frame of type A
;
; ************************************************************************************************

StackFindFrame:
		sta 	requiredFrame
_SFFLoop:
		lda 	(runtimeStackPtr) 			; get TOS
		cmp 	#$FF 						; if found $FF then this is a fail.
		beq 	SCFFail 			
		cmp 	requiredFrame 				; found this type ?
		beq 	_SFFFound
		jsr 	StackCloseFrame 			; close the top frame
		bra 	_SFFLoop 					; and try te next.
_SFFFound:
		rts		

; ************************************************************************************************
;
;										Check a frame
;
; ************************************************************************************************

StackCheckFrame:
		cmp 	(runtimeStackPtr) 			; matches current frame
		bne 	SCFFail
		rts
SCFFail:
		.error_structure

		.send code

		.section storage
requiredFrame:
		.fill 	1
		.send 	storage		
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;		22/06/23 		Added StackFindFrame which looks for a frame of this type and throws
;						non matchers.
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		fre.asm
;		Purpose:	Calculate free space
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;											FRE() function
;
; ************************************************************************************************

UnaryFre:	;; [fre]
		.entercmd

		jsr 	FloatSetZero 				; zero the result (32 bit integer)
		sec
		lda 	stringHighMemory 			; calculate the free memory.
		sbc 	stringLowMemory
		sta		NSMantissa0,x
		lda 	stringHighMemory+1
		sbc 	stringLowMemory+1
		sta		NSMantissa1,x
		
		.exitcmd

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		get.asm
;		Purpose:	Get 1 character from input stream
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;								GET char to stack as string
;
; ************************************************************************************************

		.section code

CommandGet: ;; [get]
		.entercmd
		inx
		lda 	#1 							; 1 character space
		jsr 	StringAllocTemp 	

		jsr 	VectorGetCharacter 			; get a character
		cmp 	#0
		beq 	_CGNone

		phy
		ldy 	#1 							; store char
		sta 	(zsTemp),y
		tya 								; store length.
		sta 	(zsTemp)
		ply
_CGNone:		
		.exitcmd

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		gosub.asm
;		Purpose:	Gosub/Return commands
;		Created:	19th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								Gosub <Page and Address follows>
;
; ************************************************************************************************

CommandGosub: ;; [.gosub]
		.entercmd
		lda 	#FRAME_GOSUB
		jsr 	StackOpenFrame
		jsr 	StackSaveCurrentPosition
		jmp 	PerformGOTO

CommandReturn: ;; [return]
		.entercmd
		lda 	#FRAME_GOSUB
		jsr 	StackFindFrame
		jsr 	StackLoadCurrentPosition
		iny
		iny
		iny
		jsr 	StackCloseFrame
		.exitcmd


		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;		22/06/23 		Uses FindFrame on Return, so will throw any incomplete NEXTs.
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		goto.asm
;		Purpose:	Goto command
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								Goto <Page and Address follows>
;	 							   (Page currently not used)
;
; ************************************************************************************************

CommandGoto: ;; [.goto]
		.entercmd
		;
		;		Come here to actually do the GOTO.
		;
PerformGOTO:		
		iny
		iny 								; push MSB of offset on stack
		lda 	(codePtr),y
		pha
		dey 								; point LSB of offset

		clc 								; add LSB
		lda 	(codePtr),y
		adc 	codePtr
		sta 	codePtr

		pla 								; restore offset MSB and add
		adc 	codePtr+1
		sta 	codePtr+1		

		dey 								; fix up.
		.exitcmd

; ************************************************************************************************
;
;									Conditional Gotos
;
; ************************************************************************************************

CommandGotoZ: ;; [.goto.z]
		.entercmd
		jsr 	FloatIsZero
		dex 
		cmp 	#0
		beq 	PerformGOTO
		iny
		iny
		iny
		.exitcmd

CommandGotoNZ: ;; [.goto.nz]
		.entercmd
		jsr 	FloatIsZero
		dex 
		cmp 	#0
		bne 	PerformGOTO
		iny
		iny
		iny
		.exitcmd

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		graphics.asm
;		Purpose:	Graphics commands
;		Created:	9th May 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										PSET Command
;
; ************************************************************************************************

Command_PSET: ;; [pset]
		.entercmd
		phy
		jsr 	GetInteger8Bit 				; get the colour
		pha
		ldx 	#0 							; copy 0/1 to r0,r1
		ldy 	#X16_r0
		jsr 	GraphicsCopy2
		jsr 	X16_FB_cursor_position 		; set position.
		pla 								; set pixel.
		jsr 	X16_FB_set_pixel
		ply
		ldx 	#$FF
		.exitcmd

; ************************************************************************************************
;
;										LINE Command
;
; ************************************************************************************************

Command_LINE: ;; [line]
		.entercmd
		phy
		jsr 	GraphicsColour
		ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
		ldy 	#X16_r0
		jsr 	GraphicsCopy4
		jsr 	X16_GRAPH_draw_line
		ply
		ldx 	#$FF
		.exitcmd

; ************************************************************************************************
;
;										RECT Command
;
; ************************************************************************************************

Command_RECT: ;; [rect]
		.entercmd
		phy
		jsr 	GraphicsRectCoords
		sec
		jsr 	X16_GRAPH_draw_rect
		ply
		ldx 	#$FF
		.exitcmd

; ************************************************************************************************
;
;										FRAME Command
;
; ************************************************************************************************

Command_FRAME: ;; [frame]
		.entercmd
		phy
		jsr 	GraphicsRectCoords
		clc
		jsr 	X16_GRAPH_draw_rect
		ply
		ldx 	#$FF
		.exitcmd

; ************************************************************************************************
;
;										CHAR Command
;
; ************************************************************************************************

Command_CHAR: ;; [char]
		.entercmd
		phy
		dex  								; set the draw colour
		jsr 	GraphicsColour
		ldx 	#0 							; copy 0/1 to r0,r1
		ldy 	#X16_r0
		jsr 	GraphicsCopy2
		;
		lda 	NSMantissa0+3 				; copy string address to zTemp0
		sta 	zTemp0
		lda 	NSMantissa1+3
		sta 	zTemp0+1
		lda 	(zTemp0) 					; count of chars to zTemp1
		sta 	zTemp1
_CCLoop:
		lda 	zTemp1 						; done all chars ?
		beq 	_CCExit
		dec 	zTemp1 						; dec counter		
		inc 	zTemp0 						; pre-bump pointer
		bne 	_CCNoCarry
		inc 	zTemp0+1
_CCNoCarry:
		lda 	(zTemp0) 					; get character 
		jsr 	X16_GRAPH_put_char 			; write it
		bra 	_CCLoop						; go round.
_CCExit:		
		ply
		ldx 	#$FF
		.exitcmd

; ************************************************************************************************
;
;								Set colour to stack X
;
; ************************************************************************************************

GraphicsColour:
		jsr 	GetInteger8Bit
		tax
		ldy 	#0
		jsr 	X16_GRAPH_set_colors
		rts

; ************************************************************************************************
;
;								Copy stack X,X+n to rY,Y+n
;
; ************************************************************************************************

GraphicsCopy4:
		jsr 	GraphicsCopy2
GraphicsCopy2:
		jsr 	GraphicsCopy1
GraphicsCopy1:		
		.floatinteger
		lda 	NSMantissa0,x
		sta 	0,y
		lda 	NSMantissa1,x
		sta 	1,y
		inx
		iny
		iny
		rts

; ************************************************************************************************
;
;								Set up Rectangle and colour
;
; ************************************************************************************************

GraphicsRectCoords:
		jsr 	GraphicsColour 				; set colour
		ldx 	#0 							; copy in order.
		ldy 	#X16_r0
		jsr 	GraphicsCopy4 
		ldx 	#X16_r0 					; sort r0/r2
		jsr 	_GRCSortSubtract
		ldx 	#X16_r1 					; sort r1/r3
		jsr 	_GRCSortSubtract
		stz 	8,x 						; zero rounding
		stz 	9,x 
		rts

_GRCSortSubtract:
		lda 	4,x 						; calculate r2-r0
		cmp 	0,x
		lda 	5,x
		sbc 	1,x
		bcs 	_GRCNoSwap 					; >= swap.
		jsr 	_GRCSwapByte 				; swap 0/2
		inx
		jsr 	_GRCSwapByte 				; swap 1/3
		dex
_GRCNoSwap:		
		sec 								; calculate width/height into 4,5
		lda 	4,x
		sbc 	0,x
		sta 	4,x

		lda 	5,x
		sbc 	1,x
		sta 	5,x
		rts

_GRCSwapByte:
		lda 	4,x
		pha
		lda 	0,x
		sta 	4,x
		pla
		sta 	0,x
		rts		
		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		hex.asm
;		Purpose:	Hexadecimal conversion
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code
		
; ************************************************************************************************
;
;								BIN$ (integer to string)
;
; ************************************************************************************************

Unary16Hex: ;; [hex$]
		.entercmd
		jsr 	GetInteger16Bit
		lda 	#4 							; allocate / set 4 bytes.
		jsr 	StringAllocTemp
		lda 	zTemp0+1
		beq 	_UHNoHigh
		jsr 	_UHWriteHex
_UHNoHigh:
		lda 	zTemp0
		jsr 	_UHWriteHex
		.exitcmd

_UHWriteHex:		
		pha
		lsr 	a
		lsr 	a
		lsr 	a
		lsr 	a
		jsr 	_UHWriteNibl
		pla
_UHWriteNibl:				
		and 	#15
		cmp 	#10
		bcc 	_UHDigit
		adc 	#6
_UHDigit:
		adc 	#48
		jsr 	StringWriteChar
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		indirect.asm
;		Purpose:	Indirect Read/Writes
;		Created:	27th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								<offset> [#%$]@ <data
;
; ************************************************************************************************

rcall 	.macro
		.entercmd
		lda 	NSMantissa0,x 				; copy address
		sta 	zTemp0
		lda 	NSMantissa1,x
		clc
		adc 	#(WorkArea >> 8)
		sta 	zTemp0+1
		dex 								; throw the address
		jsr 	\1 							; call read routine
		.exitcmd
		.endm

IndFloatRead:
		.rcall 	ReadFloatZTemp0Sub
IndInt16Read:
		.rcall 	ReadIntegerZTemp0Sub
IndStringRead:
		.rcall 	ReadStringZTemp0Sub

; ************************************************************************************************
;
;								<offset> <data> [#%$]!
;
; ************************************************************************************************

wcall .macro
		.entercmd
		lda 	NSMantissa0-1,x 			; copy address
		sta 	zTemp0
		lda 	NSMantissa1-1,x
		clc
		adc 	#(WorkArea >> 8)
		sta 	zTemp0+1
		jsr 	\1 							; call write routine
		dex 								; throw the address as well.
		.exitcmd
		.endm

IndFloatWrite:
		.wcall 	WriteFloatZTemp0Sub
IndInt16Write:
		.wcall 	WriteIntegerZTemp0Sub
IndStringWrite:
		.wcall 	WriteStringZTemp0Sub

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		input.asm
;		Purpose:	Input commands
;		Created:	1stMay 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										Input Commands
;
; ************************************************************************************************

CommandInput: ;; [input]
		.entercmd
		phy 								; save Y
		inx									; space on stack
_INError:		
		jsr 	InputStringToBuffer 		; input from keyboard
		.set16 	zTemp0,ReadBufferSize		; convert from here
		jsr 	ValEvaluateZTemp0
		bcs 	_INError 					; failed, try again.
		ply 								; restore Y
		.exitcmd

CommandInputString: ;; [input$]
		.entercmd
		phy 								; save Y
		jsr 	InputStringToBuffer 		; input from keyboard
		inx 								; make space on stack
		jsr 	FloatSetZero 				; store as string on stack
		lda 	#ReadBufferSize & $FF
		sta 	NSMantissa0,x
		lda 	#ReadBufferSize >> 8
		sta 	NSMantissa1,x
		lda 	#NSSString
		sta 	NSStatus,x
		ply 								; restore Y
		.exitcmd

CommandInputReset: ;; [input.start]	
		.entercmd	
		stz 	InputBuffer
		.exitcmd	

InputStringToBuffer:
		.set16 	ReadBumpNextVec,InputBumpNext
		.set16 	ReadLookNextVec,InputLookNext
		jmp 	GetStringToBuffer


; ************************************************************************************************
;
;		Look at the next input character - return CS if we have new line input, forces an end.
;		$00 if end of data.
;
; ************************************************************************************************

InputLookNext:		
		phx
_ILNRetry:		
		lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
		bne 	_ILNNotEmpty
		jsr 	InputGetNewLine 			; get a new line 
		stz 	InputBufferPos 				; reset read position.
		bra 	_ILNRetry

_ILNNotEmpty:		
		ldx 	InputBufferPos 				; get head available character
		lda 	InputBuffer,x 				
		bne 	_ILNExit 					; if not EOS return it with CC.
_ILNNextLine:		
		stz 	InputBuffer 				; clear the buffer, indicating new line next time.
		sec 								; return CS,Zero
		plx
		lda 	#13 						
		rts
_ILNExit:	
		plx
		cmp 	#0 							; return CC, Z Flag set.
		clc
		rts

; ************************************************************************************************
;
;								Consume 1 input character
;
; ************************************************************************************************

InputBumpNext:
		inc 	InputBufferPos
		rts

; ************************************************************************************************
;
;							Get a new line into the ReadBuffer
;
; ************************************************************************************************

InputGetNewLine:
		pha
		phx
		phy
		lda 	#"?"
		jsr 	IGNLEchoIfScreen
		ldy 	#0 							; line position.
_IGNLLoop:
		jsr 	VectorGetCharacter 			; get a character
		cmp 	#0
		beq 	_IGNLLoop
		cmp 	#$14 						; Backspace ?
		beq 	_IGNBackspace
		cmp 	#$0D 						; Return ?
		beq 	_IGNExit
		cpy 	#80 						; buffer full ?
		beq 	_IGNLLoop
		sta 	InputBuffer,y
		iny
		jsr 	IGNLEchoIfScreen
		bra 	_IGNLLoop

_IGNBackspace:
		cpy 	#0
		beq 	_IGNLLoop
		jsr 	IGNLEchoIfScreen
		dey
		bra 	_IGNLLoop
_IGNExit:
		jsr 	IGNLEchoIfScreen
		lda 	#0 							; make ASCIIZ
		sta 	InputBuffer,y
		stz 	InputBufferPos 				; reset position to start of input buffer.
		ply
		plx
		pla
		rts		

; ************************************************************************************************
;
;								Print A if output channel is screen.
;
; ************************************************************************************************

IGNLEchoIfScreen:
		ldx 	currentChannel
		bne 	_IGNLEExit
		jsr 	VectorPrintCharacter
_IGNLEExit:				
		rts

		.send 	code
		
		.section storage
InputBuffer:
		.fill 	81		
InputBufferPos:
		.fill 	1
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		integers.asm
;		Purpose:	Integer value read/write
;		Created:	14th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code


GetInteger8Bit:
		.floatinteger
		lda 	NSMantissa0,x
		rts

GetInteger16Bit:
		.floatinteger
		bit 	NSStatus,x
		bmi 	Negate16Bit
		lda 	NSMantissa0,x
		sta 	zTemp0
		lda 	NSMantissa1,x
		sta 	zTemp0+1
		rts
Negate16Bit:
		sec
		lda 	#0
		sbc 	NSMantissa0,x
		sta 	NSMantissa0,x
		sta 	zTemp0
		lda 	#0
		sbc 	NSMantissa1,x
		sta 	NSMantissa1,x
		sta 	zTemp0+1
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		joy.asm
;		Purpose:	Joystick function
;		Created:	9th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code
		
; ************************************************************************************************
;
;								JOY(n) read joystick
;
; ************************************************************************************************

UnaryJoy: ;; [!joy]
		.entercmd
		jsr 	GetInteger8Bit 				; port #
		pha 								; zero the result.
		jsr 	FloatSetZero
		pla
		phy
		phx
		jsr 	X16_joystick_get 			; read joystick.
		cpy 	#0 							; check no hardware
		bne 	_UJNoHardware

		tay 								; move XA -> AY
		txa
		plx 								; we can update it now.
		eor 	#$FF
		sta 	NSMantissa1,x
		tya
		eor 	#$FF
		sta 	NSMantissa0,x
		ply 								; restore Y
		.exitcmd

_UJNoHardware:
		plx
		ply
		lda 	#1 							; set result to -1
		jsr 	FloatSetByte
		jsr 	FloatNegate
		.exitcmd

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		len.asm
;		Purpose:	Length of string.
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;								  End current program
;
; ************************************************************************************************

		.section code

UnaryLen: ;; [len]
		.entercmd

		lda 	NSMantissa0,x 				; string address.
		sta 	zTemp0
		lda 	NSMantissa1,x
		sta 	zTemp0+1
		;
		lda 	(zTemp0) 					; get length
		jsr 	FloatSetByte

		.exitcmd

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
;
;	This file is automatically generated
;
	.section code
LinkFloatAdd: ;; [+]
	.entercmd
	phy
	jsr	FloatAdd
	ply
	.exitcmd
LinkFloatSubtract: ;; [-]
	.entercmd
	phy
	jsr	FloatSubtract
	ply
	.exitcmd
LinkFloatMultiply: ;; [*]
	.entercmd
	phy
	jsr	FloatMultiply
	ply
	.exitcmd
LinkFloatDivide: ;; [/]
	.entercmd
	phy
	jsr	FloatDivide
	bcs	DivZeroError
	ply
	.exitcmd
LinkFloatPower: ;; [^]
	.entercmd
	phy
	jsr	FloatPower
	bcs	MapRangeError
	ply
	.exitcmd
LinkCompareGreater: ;; [>]
	.entercmd
	phy
	jsr	CompareGreater
	ply
	.exitcmd
LinkCompareEqual: ;; [=]
	.entercmd
	phy
	jsr	CompareEqual
	ply
	.exitcmd
LinkCompareLess: ;; [<]
	.entercmd
	phy
	jsr	CompareLess
	ply
	.exitcmd
LinkCompareGreaterEqual: ;; [>=]
	.entercmd
	phy
	jsr	CompareGreaterEqual
	ply
	.exitcmd
LinkCompareNotEqual: ;; [<>]
	.entercmd
	phy
	jsr	CompareNotEqual
	ply
	.exitcmd
LinkCompareLessEqual: ;; [<=]
	.entercmd
	phy
	jsr	CompareLessEqual
	ply
	.exitcmd
LinkFloatIntegerPartDown: ;; [!int]
	.entercmd
	phy
	jsr	FloatIntegerPartDown
	ply
	.exitcmd
LinkFloatSquareRoot: ;; [!sqr]
	.entercmd
	phy
	jsr	FloatSquareRoot
	bcs	MapRangeError
	ply
	.exitcmd
MapRangeError:
	.error_range
DivZeroError:
	.error_divzero
LinkFloatLogarithm: ;; [!log]
	.entercmd
	phy
	jsr	FloatLogarithm
	bcs	MapRangeError
	ply
	.exitcmd
LinkFloatExponent: ;; [!exp]
	.entercmd
	phy
	jsr	FloatExponent
	ply
	.exitcmd
LinkFloatCosine: ;; [!cos]
	.entercmd
	phy
	jsr	FloatCosine
	ply
	.exitcmd
LinkFloatSine: ;; [!sin]
	.entercmd
	phy
	jsr	FloatSine
	ply
	.exitcmd
LinkFloatTangent: ;; [!tan]
	.entercmd
	phy
	jsr	FloatTangent
	ply
	.exitcmd
LinkFloatArcTan: ;; [!atn]
	.entercmd
	phy
	jsr	FloatArcTan
	bcs	MapRangeError
	ply
	.exitcmd
LinkFloatCompare: ;; [f.cmp]
	.entercmd
	phy
	jsr	FloatCompare
	ply
	.exitcmd
LinkDivideInt32: ;; [int.div]
	.entercmd
	phy
	jsr	DivideInt32
	bcs	MapRangeError
	ply
	.exitcmd
	.send code
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		location.asm
;		Purpose:	Save/Restore location on stack.
;		Created:	19th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;					Normalise position so it Y = 0 and save at stack offset +1
;
; ************************************************************************************************

StackSaveCurrentPosition:
		jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
		phy
		ldy 	#1
		lda 	codePage
		sta 	(runtimeStackPtr),y
		iny
		lda 	codePtr
		sta 	(runtimeStackPtr),y
		iny
		lda 	codePtr+1
		sta 	(runtimeStackPtr),y
		ply
		rts

; ************************************************************************************************
;
;										Close a frame
;
; ************************************************************************************************

StackLoadCurrentPosition:
		ldy 	#1
		lda 	(runtimeStackPtr),y
		sta 	codePage
		iny
		lda 	(runtimeStackPtr),y
		sta 	codePtr
		iny
		lda 	(runtimeStackPtr),y
		sta 	codePtr+1
		ldy 	#0
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		mouse.asm
;		Purpose:	Mouse commands/functions
;		Created:	9th May 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								MOUSE command
;
; ************************************************************************************************

XCommandMouse: ;; [!mouse]
		.entercmd
		jsr 	GetInteger8Bit 				; mouse control.
		dex
		phx
		phy
		pha
		sec 								; get screen resolution
		jsr 	X16_screen_mode
		pla
		jsr 	X16_mouse_config 			; config the mouse
		ply
		plx
		.exitcmd

; ************************************************************************************************
;
;									Mouse status functions
;
; ************************************************************************************************

XUnaryMB: ;; [!mb]
		.entercmd
		jsr 	XUnaryMouseCommon
		lda 	zTemp2
		inx
		jsr 	FloatSetByte
		.exitcmd

XUnaryMX: ;; [!mx]
		.entercmd
		jsr 	XUnaryMouseCommon
		lda 	zTemp0
		inx
		jsr 	FloatSetByte
		lda 	zTemp0+1
		sta 	NSMantissa1,x
		.exitcmd

XUnaryMY: ;; [!my]
		.entercmd
		jsr 	XUnaryMouseCommon
		lda 	zTemp1
		inx
		jsr 	FloatSetByte
		lda 	zTemp1+1
		sta 	NSMantissa1,x
		.exitcmd

XUnaryMouseCommon:
		phx
		phy
		ldx 	#zTemp0
		jsr 	X16_mouse_get
		sta 	zTemp2
		ply
		plx
		rts

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		negation.asm
;		Purpose:	Negate TOS
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										Negate TOS
;
; ************************************************************************************************

NegateTOS:	;; [negate]
		.entercmd
		jsr 	FloatNegate
		.exitcmd

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		newline.asm
;		Purpose:	Newline command
;		Created:	13th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									Newline command
;
; ************************************************************************************************

CommandNewLine: ;; [new.line]
		.entercmd
		.resetStringSystem
		ldx 	#$FF
		.exitcmd

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		next.asm
;		Purpose:	NEXT command
;		Created:	20th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										<RefAddr|$FFFF> NEXT
;
; ************************************************************************************************

CommandNext: ;; [next]
		.entercmd
_CNRetry:		
		lda 	#FRAME_FOR 					; find the FOR 
		jsr 	StackFindFrame
		jsr 	FixUpY 						; so we can use Y		
		;
		;		Index variable check ?
		;
		lda 	NSMantissa0,x 				; check no index variable, both are $FF
		and 	NSMantissa1,x
		cmp 	#$FF
		beq 	_CNNoIndexVariable

		lda 	NSMantissa0,x
		ldy 	#5
		cmp 	(runtimeStackPtr),y
		bne 	_CNNIndexFail
		lda 	NSMantissa1,x
		iny
		cmp 	(runtimeStackPtr),y
		beq 	_CNNoIndexVariable
_CNNIndexFail:		
		ldy 	#0 							; so we don't fix up Y again !
		jsr 	StackCloseFrame 			; close this frame
		bra 	_CNRetry


_CNNoIndexVariable:
		dex

		ldy 	#4 							; check for optimised NEXT
		lda 	(runtimeStackPtr),y
		and 	#$40	 					; bit 6
		bne 	_CNOptimisedNext
		;
		;		Increment the index, overwrite index reference with index value
		;		
		ldy 	#5 							; copy address to zTemp0, save for write back
		lda 	(runtimeStackPtr),y
		pha
		sta 	zTemp0
		iny
		lda 	(runtimeStackPtr),y
		clc 
		adc 	#VariableStart >> 8 		; point to variable page.
		pha
		sta 	zTemp0+1
		jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
		;		
		ldy 	#7  						; read step onto stack +1
		inx 
		jsr 	CopyOffsetYToTOS 			
		;
		jsr 	FloatAdd

		pla 								; restore address
		sta 	zTemp0+1
		pla
		sta 	zTemp0
		jsr 	WriteFloatZTemp0Sub			; write float.
		;
		;		Now check against terminal value
		;
		inx  								; recover written
		inx 								; load offset
		ldy 	#13
		jsr 	CopyOffsetYToTOS
		jsr 	FloatCompare 				; and compare the floats.
		dex 								; throw result (in NSMantissa0+1)

		ldy 	#12 						; get the sign of the step.
		lda 	(runtimeStackPtr),y
		bmi 	_CNDownStep
		;
		lda 	NSMantissa0+1,x 			; get comparator
		cmp 	#1 							; gone higher
		beq 	_CNExitFor 					; if so exit the loop
		bra 	_CNLoopBack
_CNDownStep:
		lda 	NSMantissa0+1,x 			; get comparator
		cmp 	#255 						; gone lower
		beq 	_CNExitFor		
		;
		; 		Here to loop back
		;
_CNLoopBack:
		jsr 	StackLoadCurrentPosition 	; loop back
		ldy 	#0
		.exitcmd
		;
		; 		Here to exit out.
		;
_CNExitFor:						
		jsr 	StackCloseFrame 			; remove the frame and exit
		ldy 	#0
		.exitcmd
;
; 		Optimised next code.
;
_CNOptimisedNext:
		ldy 	#5 							; copy address to zTemp0, save for write back
		lda 	(runtimeStackPtr),y
		sta 	zTemp0
		iny
		lda 	(runtimeStackPtr),y
		clc 
		adc 	#VariableStart >> 8 		; point to variable page.
		sta 	zTemp0+1
		;
		;		Increment it - we don't worry about carry out because the test is unsigned.
		;
		ldy 	#7 							; STEP value
		lda 	(runtimeStackPtr),y
		ldy 	#$FF
		clc		
_CNOIncrement:
		iny
		adc 	(zTemp0),y
		sta 	(zTemp0),y
		beq 	_CNOIncrement
		;
		;		Point zTemp1 to the terminal value, easier access
		;
		clc
		lda 	runtimeStackPtr
		adc 	#13
		sta 	zTemp1
		lda 	runtimeStackPtr+1
		adc 	#0
		sta 	zTemp1+1
		;
		;		Calculate terminal - value, when this goes -ve loop over.
		;
		ldy 	#0
		lda 	(zTemp1),y 					; byte 0
		cmp 	(zTemp0),y
		iny
		lda 	(zTemp1),y 					; byte 1
		sbc 	(zTemp0),y
		iny
		lda 	(zTemp1),y 					; byte 2
		sbc 	(zTemp0),y
		iny
		lda 	(zTemp1),y 					; byte 3
		sbc 	(zTemp0),y
		bcc	 	_CNExitFor
		bra 	_CNLoopBack

; ************************************************************************************************
;
;								Copy Stack frame offset Y to TOS
;
; ************************************************************************************************

CopyOffsetYToTOS:
		lda 	(runtimeStackPtr),y
		sta 	NSMantissa0,x
		iny
		lda 	(runtimeStackPtr),y
		sta 	NSMantissa1,x
		iny
		lda 	(runtimeStackPtr),y
		sta 	NSMantissa2,x
		iny
		lda 	(runtimeStackPtr),y
		sta 	NSMantissa3,x
		iny
		lda 	(runtimeStackPtr),y
		sta 	NSExponent,x
		iny
		lda 	(runtimeStackPtr),y
		sta 	NSStatus,x
		rts

		.exitcmd	

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;		23/06/23 		Does a search rather than a check. If the index variable match fails,
; 						keeps closing frames until it finds the right one, copying MS Basic standard.
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		not.asm
;		Purpose:	NOT of TOS
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									     Not TOS
;
; ************************************************************************************************

NotTOS:	;; [not]
		.entercmd
		.floatinteger
		stz 	NSMantissa2,x 				; chop down to 16 bit.
		stz 	NSMantissa3,x

		jsr 	FloatNegate		 			; negate

		inx 								; and subtract 1.
		lda 	#1
		jsr 	FloatSetByte
		jsr 	FloatSubtract

_NotTOSSkip:
		.exitcmd

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		on.asm
;		Purpose:	Handler for On/Goto and On/Gosubj
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;						On <GOTO> xxx <moreon> <GOTO> xxx <moreon> etc.
;
; ************************************************************************************************
;
;		ON a GOSUB 100,200,300 is compiled as
;		
;		<get a> ON GOSUB100 MOREON GOSUB200 MOREON GOSUB300
;

CommandOn: ;; [on]
		.entercmd
		jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
		sta 	onCount 					; save it.
		jsr 	FixUpY 						; Y = 0
_CONFind:
		dec 	onCount 					; reached zero, do this one
		beq 	_CONFound
		iny 								; skip over the token (GOTO or GOSUB page, and line #)
		iny
		iny
		iny
		lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
		iny
		cmp 	#PCD_MOREON
		beq 	_CONFind
		dey 								; point to character after last GOTO/GOSUB
_CONFound:
		.exitcmd

; ************************************************************************************************
;
;		MOREON is executed on return from ON GOSUB and simply skips all the options
;		remaining.
;
; ************************************************************************************************

CommandMoreOn: ;; [moreon] 					
		.entercmd 							; executing MoreOn skips the whole following GOTO
		iny 								; so it goes to the first non-goto/gosub
		iny
		iny
		iny
		.exitcmd

		.send 	code
		
		.section storage
onCount:
		.fill 	1		
		.send storage
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
;
;	This file is automatically generated
;
.section code
MOFSizeTable:
	.byte	1         	; $ca .shift
	.byte	1         	; $cb .byte
	.byte	2         	; $cc .word
	.byte	5         	; $cd .float
	.byte	255       	; $ce .string
	.byte	255       	; $cf .data
	.byte	3         	; $d0 .goto
	.byte	3         	; $d1 .gosub
	.byte	3         	; $d2 .goto.z
	.byte	3         	; $d3 .goto.nz
	.byte	2         	; $d4 .varspace
.send code
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		peek.asm
;		Purpose:	Read Memory
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									 Peek TOS.
;
; ************************************************************************************************

UnaryPeek:	;; [peek]
		.entercmd
		jsr 	GetInteger16Bit

		phx
		phy
		ldx 	zTemp0
		ldy 	zTemp0+1
		jsr 	XPeekMemory
		ply
		plx
		jsr 	FloatSetByte

		.exitcmd

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		poke.asm
;		Purpose:	Poke command
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										POKE command
;
; ************************************************************************************************

CommandPOKE: ;; [poke]
		.entercmd
		phx 								; save XY
		phy
		jsr 	GetInteger8Bit 				; get byte to POKE and save it
		pha 								
		lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
		tay
		lda 	NSMantissa0-1,x
		tax
		pla
		jsr 	XPokeMemory
		ply 								; restore YX and drop 2
		plx
		dex
		dex
		.exitcmd


; ************************************************************************************************

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		pos.asm
;		Purpose:	Get screen horizontal position
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;								POS(0) horizontal position
;
; ************************************************************************************************

		.section code

UnaryPos: ;; [pos]
		.entercmd
		jsr 	XGetHPos
		jsr 	FloatSetByte
		.exitcmd

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		print.asm
;		Purpose:	Print Indirection Control etc.
;		Created:	19th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							Get/Set Print Channel from/to stack
;
; ************************************************************************************************

GetChannel: ;; [getchannel]
		.entercmd
		lda 	currentChannel
		inx
		jsr 	FloatSetByte
		.exitcmd

SetChannel: ;; [setchannel]
		.entercmd
		jsr 	FloatIntegerPart
		lda 	NSMantissa0,x
		sta 	currentChannel
		dex
		.exitcmd

SetDefaultChannel:
		stz 	currentChannel
		rts

; ************************************************************************************************
;
;						  				Print Character
;
; ************************************************************************************************

VectorPrintCharacter:
		phx
		ldx 	currentChannel

;
;		Check we're sending it to the correct channel.
;
;		pha
;		txa
;		ora 	#48
;		jsr 	XPrintCharacterToChannel
;		pla

		jsr 	XPrintCharacterToChannel
		plx
		rts

; ************************************************************************************************
;
;						  				Get Character
;
; ************************************************************************************************

VectorGetCharacter:
		phx
		ldx 	currentChannel
		jsr 	XGetCharacterFromChannel
		plx
		rts

		.send code

		.section storage
currentChannel:
		.fill 	1
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		printvalues.asm
;		Purpose:	Print String/Number
;		Created:	19th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						  				Print number
;
; ************************************************************************************************

PrintNumber: ;; [print.n]
		.entercmd
		lda 	#7
		jsr 	FloatToString 				; to number in decimal buffer
		dex 								; drop
		phx
		ldx 	#0 							; print buffer.
_PNLoop:
		lda 	decimalBuffer,x
		jsr 	VectorPrintCharacter
		inx
		lda	 	decimalBuffer,x
		bne 	_PNLoop
		lda 	#32 						; trailing space
		jsr 	VectorPrintCharacter
		plx
		.exitcmd

; ************************************************************************************************
;
;						  				Print string
;
; ************************************************************************************************

PrintString: ;; [print.s]
		.entercmd
		lda 	NSMantissa0,x 				; point zTemp0 to string
		sta 	zTemp0
		lda 	NSMantissa1,x
		sta 	zTemp0+1
		dex 								; drop
		phx
		phy
		lda 	(zTemp0) 					; X = count
		tax
		ldy 	#1 							; Y = position
_PSLoop:
		cpx 	#0 							; complete ?
		beq 	_PSExit
		dex 								; dec count
		lda 	(zTemp0),y 					; print char and bump
		jsr 	VectorPrintCharacter
		iny
		bra 	_PSLoop

_PSExit:
		ply
		plx
		.exitcmd


		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		pushnumber.asm
;		Purpose:	Push number onto stack 
;		Created:	14th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								Push Number <EXP> <MANTISSA W/SIGN>
;
; ************************************************************************************************

CommandPushN: ;; [.float]
		.entercmd

		inx 								; next slot on stack		

		lda 	(codePtr),y 				; exponent
		sta 	NSExponent,x
		iny

		lda 	(codePtr),y 				; mantissa
		sta 	NSMantissa0,x
		iny
		lda 	(codePtr),y 				
		sta 	NSMantissa1,x
		iny
		lda 	(codePtr),y 				
		sta 	NSMantissa2,x
		iny
		lda 	(codePtr),y 				
		pha
		and 	#$7F
		sta 	NSMantissa3,x
		pla 								; sign in mantissa3:7
		and 	#$80
		sta 	NSStatus,x
		iny
		.exitcmd

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		pushstring.asm
;		Purpose:	Push string constant onto stack 
;		Created:	14th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								Push String <LEN> <ASCIIZCount>
;
; ************************************************************************************************

CommandPushS: ;; [.string]
		.entercmd
		inx 								; next slot on stack		
		;
		clc
		tya
		adc 	codePtr 					; the string is inline
		sta 	NSMantissa0,x
		lda 	codePtr+1
		adc 	#0
		sta 	NSMantissa1,x
		stz 	NSMantissa2,x
		stz 	NSMantissa3,x
		;
		lda 	#NSSString
		sta 	NSStatus,x
		;
		tya 								; string length +1 added to Y
		sec 								
		adc 	(codePtr),y 				; next instruction
		tay
		.exitcmd

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		read.asm
;		Purpose:	Data extraction functions
;		Created:	22nd April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;						Extracts from Data as a string/number
;
; ************************************************************************************************

CommandRead: ;; [read]
		.entercmd
		phy 								; save Y
		jsr 	ReadStringToBuffer 			; read element into buffer
		inx									; space on stack
		.set16 	zTemp0,ReadBufferSize		; convert from here
		jsr 	ValEvaluateZTemp0
		bcs 	_CRError 					; failed
		ply 								; restore Y
		.exitcmd

_CRError:
		.error_value

CommandReadString: ;; [read$]
		.entercmd
		phy 								; save Y
		jsr 	ReadStringToBuffer 			; read text
		inx 								; make space on stack
		jsr 	FloatSetZero 				; store as string on stack
		lda 	#ReadBufferSize & $FF
		sta 	NSMantissa0,x
		lda 	#ReadBufferSize >> 8
		sta 	NSMantissa1,x
		lda 	#NSSString
		sta 	NSStatus,x
		ply 								; restore Y
		.exitcmd

; ************************************************************************************************
;
;									Get string into buffer
;
; ************************************************************************************************

ReadStringToBuffer:
		.set16 	ReadBumpNextVec,ReadBumpNext
		.set16 	ReadLookNextVec,ReadLookNext
GetStringToBuffer:		
		jsr		GetLookNext 				; skip all leading spaces.
		beq 	_RBError 					; end of data
		bcs 	GetStringToBuffer 			; switched to new data line.
		cmp 	#' ' 						; non space got something
		bcs 	_RBNoSpace
		jsr 	GetBumpNext 				; consume space and loop round.
		bra 	GetStringToBuffer
_RBNoSpace:
		stz 	ReadBufferSize 				; empty the buffer.
		cmp 	#'"' 						; is it a '"'
		bne 	_RBCommaSep
		sta 	ReadSep 					; use as a seperator
		jsr 	GetBumpNext 				; consume the '"'
		bra 	_RBGetText
_RBCommaSep:	
		lda 	#","						; get till comma 		
		sta 	ReadSep
		;
		;		Main loop
		;
_RBGetText:		
		jsr 	GetLookNext 				; what follows
		bcs 	_RBEndGet 					; if new DATA line, the end without consumption
		jsr 	GetBumpNext 				; consume it whatever
		cmp 	ReadSep 					; if found the seperator.
		beq 	_RBEndGet 					; exit after consumption
		phx
		ldx 	ReadBufferSize 				; copy into buffer.
		inc 	ReadBufferSize
		sta 	ReadBuffer,x
		stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
		plx
		bra 	_RBGetText
_RBEndGet: 									; value is in the read buffer,	
		cmp 	#'"'
		bne 	_RBNotQuote
		jsr 	GetBumpNext
_RBNotQuote:		
		rts

_RBError:
		.error_data

GetBumpNext:
		jmp 	(ReadBumpNextVec)
GetLookNext:
		jmp 	(ReadLookNextVec)

; ************************************************************************************************
;
;		Look at the next data element - return CS if we have changed lines, forces an end.
;		$00 if end of data.
;
; ************************************************************************************************

ReadLookNext:
		lda 	dataRemaining 				; any data remaining
		beq 	_RLNFindData
		lda 	(objPtr) 					; return that object.
		clc
		rts
_RLNFindData:
		lda 	(objPtr) 					; see where we are
		cmp 	#$FF 						; if at $FF then end, error.
		beq 	_RLNNoData
		cmp 	#PCD_CMD_DATA 				; Found DATA
		beq 	_RLNHaveData
_RLNNext:		
		jsr 	MoveObjectForward			; else scan forward.
		bra 	_RLNFindData
		;
_RLNHaveData:
		ldy 	#1 							; get length
		lda 	(objPtr),y		
		beq 	_RLNNext 					; skip if DATA alone
		jsr 	ReadBumpNext 				; advance by two
		jsr 	ReadBumpNext
		sta 	dataRemaining 				; set data left count.
		sec
		rts
_RLNNoData: 								; out of data.
		lda 	#0
		sec
		rts		

; ************************************************************************************************
;
;								Consume 1 data character
;
; ************************************************************************************************

ReadBumpNext:
		inc 	objPtr
		bne 	_RBNSkip
		inc 	objPtr+1
_RBNSkip:		
		dec 	dataRemaining
		rts		
		.send code
		
		.section storage 				
ReadSep:									; read seperator.
		.fill 	1
ReadBufferSize: 							; buffer for read.
		.fill 	1		
ReadBuffer:
		.fill 	255		
ReadBumpNextVec: 							; data vectors
		.fill 	2		
ReadLookNextVec:
		.fill 	2		
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		read_float.asm
;		Purpose:	Read iFloat32
;		Created:	13th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								Write float (2 byte command)
;
; ************************************************************************************************

ReadFloatCommand:
		.entercmd
		.vaddress
		jsr 	ReadFloatZTemp0Sub
		.exitcmd

ReadFloatZTemp0Sub:
		phy 								; start write
		ldy 	#1
		inx

		lda 	(zTemp0)
		sta 	NSMantissa0,x
		
		lda 	(zTemp0),y
		sta 	NSMantissa1,x
		iny

		lda 	(zTemp0),y
		sta 	NSMantissa2,x
		iny

		lda 	(zTemp0),y
		sta 	NSMantissa3,x
		iny

		lda 	(zTemp0),y
		sta 	NSExponent,x
		iny

		lda 	(zTemp0),y
		sta 	NSStatus,x

		ply
		rts

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		read_int.asm
;		Purpose:	ReadInteger
;		Created:	13th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								Write integer (2 byte command)
;
; ************************************************************************************************

ReadIntegerCommand:
		.entercmd
		.vaddress
		jsr 	ReadIntegerZTemp0Sub
		.exitcmd

ReadIntegerZTemp0Sub:
		phy 								; start write
		ldy 	#1
		inx 								; prepare
		stz 	NSMantissa2,x
		stz 	NSMantissa3,x
		stz 	NSExponent,x
		stz 	NSStatus,x

		lda 	(zTemp0),y 					; get MSB, do -ve code.
		bmi 	_RIZNegative

		sta 	NSMantissa1,x 				; +ve read
		lda 	(zTemp0)
		sta 	NSMantissa0,x
		ply
		rts

_RIZNegative:
		sec 								; -ve read
		lda 	#0
		sbc 	(zTemp0)
		sta 	NSMantissa0,x
		lda 	#0
		sbc 	(zTemp0),y
		sta 	NSMantissa1,x
		lda 	#$80
		sta 	NSStatus,x
		ply
		rts
		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		read_string.asm
;		Purpose:	Read String
;		Created:	17th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								Read string (2 byte command)
;
; ************************************************************************************************

ReadStringCommand:
		.entercmd
		.vaddress
		jsr 	ReadStringZTemp0Sub
		.exitcmd
		
ReadStringZTemp0Sub:
		phy 								; start write
		inx 								; prepare
		stz 	NSMantissa2,x
		stz 	NSMantissa3,x
		stz 	NSExponent,x
		lda 	#NSSString
		stz 	NSStatus,x

		clc
		lda 	(zTemp0)					; read address of block add 2.
		adc 	#2 							; this points to actual data
		sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0

		ldy 	#1
		lda 	(zTemp0),y
		adc 	#0
		sta 	NSMantissa1,x 				; +ve read

		bne 	_RSZNoDefault 				; if read $00 use a default value.

		lda 	#_RSZNull & $FF
		sta 	NSMantissa0,x
		lda 	#_RSZNull >> 8
		sta 	NSMantissa1,x
_RSZNoDefault:		

		ply
		rts

_RSZNull:	 								; dummy empty string
		.byte 	0
		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		restore.asm
;		Purpose:	Restore Data Pointer
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										ASSERT command
;
; ************************************************************************************************

CommandRestore: ;; [!restore]
		.entercmd
		jsr 	RestoreCode
		.exitcmd

RestoreCode:
		.set16 	objPtr,EndProgram+2 		; reset pointer and page
		stz  	objPage
		stz 	dataRemaining 				; no data remaining.
		rts

		.send 	code

		.section storage
dataRemaining: 								; number of bytes remaining in current data statement
		.fill 	1		 					; 0 if not in data statement
		.send storage
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		rnd.asm
;		Purpose:	Random number function
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											RND function
;
; ************************************************************************************************

UnaryRND:	;; [rnd]
		.entercmd

		bit 	NSStatus,x 					; -ve then set seed from operand
		bpl 	_URNoSeed

		jsr 	FloatNormalise 				; some float value
		lda 	NSMantissa0,x 				; copy to Mantissa
		sta 	randomSeed+0
		lda 	NSMantissa1,x
		sta 	randomSeed+1
		lda 	NSMantissa2,x
		sta 	randomSeed+2
		lda 	NSMantissa3,x
		sta 	randomSeed+3
_URNoSeed:
		jsr 	RandomNumberGenerator 		; create a number and copy to mantissa

		lda 	randomSeed+0
		sta 	NSMantissa0,x		
		lda 	randomSeed+1
		sta 	NSMantissa1,x		
		lda 	randomSeed+2
		sta 	NSMantissa2,x		
		lda 	randomSeed+3
		and 	#$7F
		sta 	NSMantissa3,x		
		lda 	#(-31 & $FF)
		sta 	NSExponent,x
		stz 	NSStatus,x
		
		.exitcmd

; ************************************************************************************************
;
;						Random number generator, originally by Brad Smith
;
; ************************************************************************************************

RandomNumberGenerator:
		phy
		lda 	randomSeed+0 				; check if zero
		ora 	randomSeed+1
		ora 	randomSeed+2
		ora 	randomSeed+3
		bne 	_RNGNoSeed

		dec 	randomSeed+3 				; if so tweak and flog
		ldy 	#100
		bra 	_RNGLoop

_RNGNoSeed:									; do 8 times.
		ldy 	#8
		lda 	randomSeed+0
_RNGLoop:
		asl		a
		rol 	randomSeed+1
		rol 	randomSeed+2
		rol 	randomSeed+3
		bcc		_RNGSkip
		eor 	#$C5
_RNGSkip:	
		dey
		bne		_RNGLoop
		sta 	randomSeed+0
		ply
		rts

		.send code

		.section storage
randomSeed:
		.fill 	4
		.send 	storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		sconcat.asm
;		Purpose:	Concatenate strings
;		Created:	14th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						  Concatenate Strings S[X],S[X+1]
;
; ************************************************************************************************

StringConcatenate: ;; [concat]
		.entercmd

		dex

		lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
		sta 	zTemp1
		lda 	NSMantissa1,x
		sta 	zTemp1+1

		lda 	NSMantissa0+1,x 			
		sta 	zTemp2
		lda 	NSMantissa1+1,x
		sta 	zTemp2+1

		clc 								; work out total length
		lda 	(zTemp1) 					
		adc 	(zTemp2) 
		bcs 	_BCLength 					; more than 255 characters. 			

		pha 								; save total
		jsr 	StringAllocTemp 			; space for result.
		pla 								; write total as first.
		sta 	(zsTemp)

		jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
		lda 	zTemp2 						; copy address zTemp2->1
		sta 	zTemp1
		lda 	zTemp2+1
		sta 	zTemp1+1
		jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
		.exitcmd
		
_BCLength:
		.error_range

_BCCopyZTemp1:
		lda 	(zTemp1) 					; bytes to copy
		beq 	_BCCExit 					; none.
		phx 								; save XY
		phy
		tax 								; count in X.
		ldy 	#1
_BCCLoop:
		inc 	zsTemp 						; bump pointer, pre-increment
		bne 	_BCCNoCarry
		inc 	zsTemp+1
_BCCNoCarry:		
		lda 	(zTemp1),y				 	; copy bytes
		sta 	(zsTemp)
		iny
		dex 								; X times
		bne 	_BCCLoop
		ply 								; restore YX
		plx
_BCCExit:
		rts		

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		setup.asm
;		Purpose:	Set up Runtime Hardware specific stuff.
;		Created:	8th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code
		
; ************************************************************************************************
;
;							Initialise Runtime specific hardware stuff
;
; ************************************************************************************************

XRuntimeSetup:
 		lda 	#$FF 						; default banks to access.
 		sta 	ramBank
 		sta 	romBank
		rts
		
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		sgn.asm
;		Purpose:	Sign of TOS
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									 Signed part of TOS
;
; ************************************************************************************************

SignTOS:	;; [sgn]
		.entercmd
		jsr 	FloatIsZero 				; if zero
		beq 	_SGZero  					; return Int Zero

		lda 	NSStatus,x 					; get status w/sign
		pha
		lda 	#1 							; set result to 1
		jsr 	FloatSetByte
		pla
		and		#$80 						; copy the sign byte out
		sta 	NSStatus,x  				; so it will be -1 or 1
		bra 	_SGExit

_SGZero:
		jsr 	FloatSetZero
_SGExit:
		.exitcmd

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		shift.asm
;		Purpose:	Shifted opcodes
;		Created:	22nd April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										Shifted commands
;
; ************************************************************************************************

CommandShift: ;; [.shift]
		lda 	(codePtr),y 				; get shifted command (X already pushed)
		iny
		asl 	a 							; double into X
		tax 	
		jmp 	(ShiftVectorTable,x) 		; go there.

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		spctabprint.asm
;		Purpose:	Print SPC()/TAB()/TABSTOP functionality
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						  		Print to next TAB stop
;
; ************************************************************************************************

PrintTab: ;; [print.tab]
		.entercmd
		jsr 	XGetHPos
_PTMod10: 									; subtract 10 till borrow
		sec
		sbc 	#10
		bcs 	_PTMod10		
		eor 	#255 						; subtract from 10 effectively. negate it
		inc 	a 							; if modulus is 0, then this will be -10 => 10
		bra 	PrintSpaceLoop

; ************************************************************************************************
;
;						  		Print to TAB() e.g. position
;
; ************************************************************************************************

PrintPos: ;; [print.pos]
		.entercmd
		jsr		XGetHPos 					; get current position
		sta 	zTemp0
		sec 								; calculate spaces required
		lda 	NSMantissa0,x 				
		dex
		sbc 	zTemp0
		bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
		.exitcmd

; ************************************************************************************************
;
;						  			Print SPC(S[X])
;
; ************************************************************************************************

PrintSpace: ;; [print.spc]
		.entercmd
		lda 	NSMantissa0,x 	
		dex
PrintSpaceLoop:	
		cmp 	#0
		beq 	_PSExit
		pha
		lda 	#" "
		jsr 	VectorPrintCharacter
		pla
		dec 	a
		bra 	PrintSpaceLoop
_PSExit:
		.exitcmd
		
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		stop.asm
;		Purpose:	Stop command
;		Created:	19th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										STOP command
;
; ************************************************************************************************

CommandStop: ;; [!stop]
		.entercmd
		.error_stop

; ************************************************************************************************

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		str.asm
;		Purpose:	Convert number to string
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										str$() function
;
; ************************************************************************************************

Unary_Str: ;; [str$]
		.entercmd
		phy
		lda 	#8 							; maximum decimal places.
		jsr 	FloatToString 				; do the conversion.
		lda		#33 						; create buffer
		jsr 	StringAllocTemp 			; allocate memory		
		ldy 	#1  						; copy the converted string into the buffer.
_USCopy:
		lda 	decimalBuffer-1,y
		beq 	_USExit
		sta 	(zsTemp),y
		iny
		bra 	_USCopy
_USExit:		
		tya
		dec 	a
		sta 	(zsTemp)
		ply
		.exitcmd

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		stralloc.asm
;		Purpose:	Allocate string memory
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;				Temporary string allocation reset (call if cmd manipulates strings)
;
; ************************************************************************************************

resetStringSystem .macro
		stz 	stringInitialised
		.endm

; ************************************************************************************************
;
;							Initialise string system if required
;
; ************************************************************************************************

StringInitialise:
		pha
		lda 	stringInitialised 			; already done
		bne 	_SIExit

		lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
		sta 	stringTempPointer
		lda 	stringHighMemory+1
		dec 	a
		dec 	a
		sta 	stringTempPointer+1

		dec 	stringInitialised 			; set the initialised flag.
_SIExit:
		lda 	availableMemory+1 			; check out of memory
		inc 	a
		inc 	a
		cmp 	stringHighMemory+1
		bcs 	_SIMemory
		pla
		rts
_SIMemory:
		.error_memory

; ************************************************************************************************
;
;								Allocate space for a string of length A.
;
; ************************************************************************************************

StringAllocTemp:
		jsr 	StringInitialise 			; check it is initialised.

		eor 	#$FF 						; subtract A+1 from temp pointer.
		clc
		adc 	stringTempPointer 			; subtract 32 from temp pointer and
		sta 	stringTempPointer 			; save in zsTemp and stackas well.
		sta 	zsTemp
		sta 	NSMantissa0,x

		lda 	stringTempPointer+1
		adc 	#$FF
		sta 	stringTempPointer+1
		sta 	zsTemp+1
		sta 	NSMantissa1,x
		stz 	NSMantissa2,x
		stz 	NSMantissa3,x

		lda 	#0 							; clear string.
		sta 	(zsTemp)
		lda 	#NSSString 			 		; mark as string
		sta 	NSStatus,x
		rts

; ************************************************************************************************
;		
; 										Write A to String
;
; ************************************************************************************************

StringWriteChar:
		phy
		pha
		lda 	(zsTemp)
		inc 	a
		sta 	(zsTemp)
		tay
		pla
		sta 	(zsTemp),y
		ply
		rts

		.send code
		
		.section storage
stringInitialised:							; non zero if string system not set up
		.fill 	1		
stringTempPointer: 							; allocated temporary pointer
		.fill 	2
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		substring.asm
;		Purpose:	Left$/Mid$/Right$ - put here as Left/Right are same code.
;		Created:	3rd April 2023
;		Reviewed: 	27th November 2022
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								<string> <size> Left$
;
; ************************************************************************************************

Unary_Left: 	;; [left$]
		.entercmd
		phy
		clc 								; only one parameter
		jsr 	GetInteger8Bit 				; push the length of the string.
		pha
		dex
		lda 	#0 							; push the start position.
		pha
		jsr 	UnarySStringToZTemp0
		bra 	SubstringMain 				; stack now points to the string to slice.

; ************************************************************************************************
;
;								<string> <size> Right$
;
; ************************************************************************************************

Unary_Right: 	;; [right$]
		.entercmd
		phy
		lda 	#255 						; push 255, we want all the string.		
		;
		jsr 	GetInteger8Bit 				; push the right length of the string.
		pha
		dex
		jsr 	UnarySStringToZTemp0

		pla 								; this is the right requirement
		sec
		eor 	#$FF
		adc 	(zTemp0)
		bcs 	_URHaveCount
		lda 	#0 							; overflow, start from 0
_URHaveCount:		
		ldy 	#255 						; whole string
		phy		
		pha 								; start position
		bra 	SubstringMain

; ************************************************************************************************
;
;								<string> <start> <size> Mid$
;
; ************************************************************************************************

Unary_Mid: 	;; [mid$]
		.entercmd
		phy
		jsr 	GetInteger8Bit 				; push the length of the string required.
		pha
		dex
		jsr 	GetInteger8Bit 				; put the start position.
		beq 	_UMError
		dec 	a
		pha
		dex
		jsr 	UnarySStringToZTemp0
		bra 	SubstringMain 				; stack now points to the string to slice.
_UMError:		
		.error_range

UnarySStringToZTemp0:
		lda 	NSMantissa0,x
		sta 	zTemp0
		lda 	NSMantissa1,x
		sta 	zTemp0+1
		rts

; ************************************************************************************************
;
;				String address in zTemp0. TOS is the start offset. TOS2 is the count.
;
; ************************************************************************************************

SubstringMain:		
		pla 								; get the start offset
		ply 								; get the count to do.
		cmp 	(zTemp0) 					; if start >= length then return NULL.
		bcs 	_SSReturnNull
		;
		sta 	zTemp1 						; save start position.
		sty 	zTemp1+1 					; save count
		;
		clc 
		adc 	zTemp1+1 					; this is the end position.
		bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
		;
		cmp 	(zTemp0) 					; ok if limit is <= length.
		beq 	_SMIsOkay
		bcc 	_SMIsOkay
_SMTruncateToEnd:
		lda 	(zTemp0) 					; end position is length.
_SMIsOkay:									; zTemp1 is start offset, zTemp2 is end.
		sta 	zTemp1+1
		;
		sec		 							; work out size
		lda 	zTemp1+1 					
		sbc 	zTemp1
		beq 	_SSReturnNull 				; if size = 0 then return empty string.
		jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
		;
		ldy 	zTemp1 						; start
_SMCopy:
		cpy 	zTemp1+1 					; exit if reached end
		beq 	_SMExit

		iny 								; bump and
		lda 	(zTemp0),y 					; get character (prefix)
		phy
		pha
		lda 	(zsTemp) 					; bump length => Y
		inc 	a
		tay
		sta 	(zsTemp)
		pla 								; write character out
		sta 	(zsTemp),y 				
		ply 								; restore Y
		bra 	_SMCopy
_SMExit:
		ply
		.exitcmd

_SSReturnNull:
		lda 	#SSRNull & $FF 				; set up mantissa
		sta 	NSMantissa0,x
		lda 	#SSRNull >> 8
		sta 	NSMantissa1,x
		stz 	NSMantissa2,x
		stz 	NSMantissa3,x
		lda 	#NSSString
		sta 	NSStatus,x
		bra 	_SMExit

SSRNull:
		.word 	0		



		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		swap.asm
;		Purpose:	Swap top two stack elements
;		Created:	28th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									Swap top two elements
;
; ************************************************************************************************

swap 	.macro
		lda 	\1,x
		pha
		lda 	\1-1,x
		sta 	\1,x
		pla
		sta 	\1-1,x
		.endm

CommandSwap: ;; [swap]
		.entercmd
		.swap 	NSMantissa0		  
		.swap 	NSMantissa1
		.swap 	NSMantissa2		  
		.swap 	NSMantissa3		  
		.swap 	NSExponent		  
		.swap 	NSStatus
		.exitcmd
		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		sys.asm
;		Purpose:	Sys command
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										POKE command
;
; ************************************************************************************************

CommandSYS: ;; [!sys]
		.entercmd
		phx 								; save XY
		phy
		jsr 	FloatIntegerPart

		lda 	NSMantissa1,x 				; get call address => zTemp0
		sta 	zTemp0+1 			
		lda 	NSMantissa0,x
		sta 	zTemp0

		ldx 	SYS_Reg_X 					; load registers
		ldy 	SYS_Reg_Y
		lda 	SYS_Reg_S
		pha
		lda 	SYS_Reg_A
		plp

		jsr 	_CSZTemp0

		php
		stx 	SYS_Reg_X 					; load registers
		sty 	SYS_Reg_Y
		sta 	SYS_Reg_A
		pla
		sta 	SYS_Reg_S

		ply 								; restore YX and drop 2
		plx
		dex
		.exitcmd

_CSZTemp0:
		jmp 	(zTemp0)

; ************************************************************************************************

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		ti.asm
;		Purpose:	Read time in jiffies as integer (ti) or string (ti$)
;		Created:	20th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									     Time to TOS
;
; ************************************************************************************************

TimeTOS:	;; [ti]
		.entercmd
		jsr 	TIPushClock 				; push clock to TOS
		.exitcmd

TimeString: ;; [ti$]
		.entercmd
		jsr 	TIPushClock 				; push clock to TOS
		jsr 	_TSDivMod60 				; result in seconds

		jsr 	_TSDivMod60 				; seconds
		pha
		jsr 	_TSDivMod60 				; minutes
		pha
		lda 	#24 						; hours
		jsr 	_TSDivModA
		pha

		lda 	#6
		jsr 	StringAllocTemp
		pla
		jsr 	_TSWriteDecimal
		pla
		jsr 	_TSWriteDecimal
		pla
		jsr 	_TSWriteDecimal

		.exitcmd

; ************************************************************************************************
;
;								Divide S[X] by A/60, return modulus in A
;
; ************************************************************************************************

_TSDivMod60:
		lda 	#60
_TSDivModA:
		inx
		jsr 	FloatSetByte
		dex
		jsr 	Int32Divide
		lda 	NSMantissa0,x 				; get modulus
		pha
		jsr 	NSMCopyPlusTwoToZero 		
		pla
		rts

; ************************************************************************************************
;
;									Convert A to BCD, Copy to string
;
; ************************************************************************************************

_TSWriteDecimal:
		phx
		ldx 	#'0'
_TSWDLoop:
		cmp 	#10
		bcc 	_TSWDEnd
		sbc 	#10
		inx
		bra 	_TSWDLoop
_TSWDEnd:
		pha
		txa
		jsr 	StringWriteChar
		pla
		ora 	#'0'
		jsr 	StringWriteChar				
		plx	
		rts
		
; ************************************************************************************************
;
;									Push clock (60Hz) to TOS
;	
; ************************************************************************************************

TIPushClock:
		phy
		inx 								; push 0 on the stack
		jsr 	FloatSetZero
		phx
		jsr 	XReadClock 					; read time into YXA
		stx 	zTemp0
		plx
		sta 	NSMantissa0,x
		lda 	zTemp0
		sta 	NSMantissa1,x
		tya
		sta 	NSMantissa2,x
		ply
		rts
		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		tiwrite.asm
;		Purpose:	Set TI from string
;		Created:	4th May 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										TI$ = functionality
;
; ************************************************************************************************

CommandTIWrite: ;; [!ti$.write]
		.entercmd
		lda 	NSMantissa0,x 				; copy string address to ZSTemp
		sta 	zsTemp
		lda 	NSMantissa1,x
		sta 	zsTemp+1
		lda 	(zsTemp) 					; check if it is six
		cmp 	#6
		bne 	_CTIWError
		jsr 	FloatSetZero
		jsr 	_CTIWDigitPair 				; do a digit pair 3 times
		jsr 	_CTIWDigitPair
		jsr 	_CTIWDigitPair
		lda 	#60 						; multiply the result by 60.
		jsr 	_CTIWMultiply

		phx
		phy

		lda 	NSMantissa1,x 				; get time into YXA
		pha
		lda 	NSMantissa2,x
		tay
		lda 	NSMantissa0,x
		plx

		jsr 	XWriteClock 				; update the clock.

		ply
		plx
		dex 								; throw result.
		.exitcmd
;
;		Add a pair of digits x 60
;
_CTIWDigitPair:
		lda 	#6 							; x 6 
		jsr 	_CTIWMultiply
		jsr 	_CTIWAddDigit 				; add digit
		lda 	#10 						; x 10
		jsr 	_CTIWMultiply
		jsr 	_CTIWAddDigit 				; add digit
		rts
;
;		Add the next digit, validating.
;		
_CTIWAddDigit:
		inc 	zsTemp 						; pre-increment
		bne 	_CTIWASkip
		inc 	zsTemp+1
_CTIWASkip:
		lda 	(zsTemp) 					; read and validate it
		sec
		sbc 	#"0"
		bcc 	_CTIWError
		cmp 	#9+1
		bcs 	_CTIWError
		inx 								; store at +1
		jsr 	FloatSetByte
		dex
		jsr 	FloatAddTopTwoStack
		rts

;
;		Multiply by A
;
_CTIWMultiply: 								
		inx
		jsr 	FloatSetByte
		dex
		jsr 	FloatMultiplyShort
		rts

_CTIWError:
		.error_value

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		usr.asm
;		Purpose:	USR() function
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;											USR() function
;
; ************************************************************************************************

UnaryUsr:	;; [usr]
		.entercmd
		phy
		jsr 	_UUCallVector
		ply
		.exitcmd

_UUCallVector:
		jmp 	(USRRoutineAddress)
		
		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		val.asm
;		Purpose:	String to Integer/Float#
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section	code

; ************************************************************************************************
;
; 											Val(String)
;
; ************************************************************************************************

ValUnary: ;; [val]	
		.entercmd 							; restore stack pos
		lda 	NSMantissa0,x
		sta 	zTemp0
		lda 	NSMantissa1,x
		sta 	zTemp0+1
		jsr 	ValEvaluateZTemp0
		bcs 	_VUError 					; couldn't convert
		.exitcmd
_VUError:
		.error_value



; ************************************************************************************************
;
;								Evaluate value at zTemp0 into X.
;
; ************************************************************************************************

ValEvaluateZTemp0:
		phy
		lda 	(zTemp0) 					; check not empty string
		beq 	_VMCFail2 		
		ldy 	#0 							; start position		
_VMCSpaces:
		iny 								; skip leading spaces
		lda 	(zTemp0),y		
		cmp 	#" "		
		beq 	_VMCSpaces
		pha 								; save first character
		cmp 	#"-"		 				; is it - ?
		bne 	_VMCStart
		iny 								; skip over - if so.
		;
		;		Evaluation loop
		;
_VMCStart:		
		sec 								; initialise first time round.
_VMCNext:
		tya 								; reached end of string
		dec 	a
		eor 	(zTemp0) 					; compare length preserve carry.
		beq 	_VMCSuccess 				; successful.

		lda 	(zTemp0),y 					; encode a number.
		iny
		jsr 	FloatEncode 				; send it to the number-builder
		bcc 	_VMCFail 					; if failed, give up.
		clc 								; next time round, countinue
		bra 	_VMCNext

_VMCFail:
		pla
_VMCFail2:		
		ply
		sec
		rts

_VMCSuccess:
		lda 	#0 							; construct final
		jsr 	FloatEncode 				; by sending a duff value.
		pla 								; if it was -ve
		cmp 	#"-"
		bne 	_VMCNotNegative
		jsr		FloatNegate 				; negate it.
_VMCNotNegative:		
		ply
		clc
		rts		

		.send	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
;
;	This file is automatically generated
;
	.section code
VectorTable:
	.word	LinkFloatAdd             ; $80 +
	.word	LinkFloatSubtract        ; $81 -
	.word	LinkFloatMultiply        ; $82 *
	.word	LinkFloatDivide          ; $83 /
	.word	LinkFloatPower           ; $84 ^
	.word	BinaryAnd                ; $85 and
	.word	BinaryOr                 ; $86 or
	.word	LinkCompareGreater       ; $87 >
	.word	LinkCompareEqual         ; $88 =
	.word	LinkCompareLess          ; $89 <
	.word	LinkCompareGreaterEqual  ; $8a >=
	.word	LinkCompareNotEqual      ; $8b <>
	.word	LinkCompareLessEqual     ; $8c <=
	.word	AbsoluteTOS              ; $8d abs
	.word	ArrayConvert             ; $8e array
	.word	UnaryAsc                 ; $8f asc
	.word	CommandAssert            ; $90 assert
	.word	Unary16Bin               ; $91 bin$
	.word	PrintCharacter           ; $92 print.chr
	.word	UnaryChr                 ; $93 chr$
	.word	CompareStrings           ; $94 s.cmp
	.word	CommandFor               ; $95 for
	.word	UnaryFre                 ; $96 fre
	.word	CommandGet               ; $97 get
	.word	CommandReturn            ; $98 return
	.word	Command_PSET             ; $99 pset
	.word	Command_LINE             ; $9a line
	.word	Command_RECT             ; $9b rect
	.word	Command_FRAME            ; $9c frame
	.word	Command_CHAR             ; $9d char
	.word	Unary16Hex               ; $9e hex$
	.word	CommandInput             ; $9f input
	.word	CommandInputString       ; $a0 input$
	.word	CommandInputReset        ; $a1 input.start
	.word	UnaryLen                 ; $a2 len
	.word	LinkFloatCompare         ; $a3 f.cmp
	.word	LinkDivideInt32          ; $a4 int.div
	.word	NegateTOS                ; $a5 negate
	.word	CommandNewLine           ; $a6 new.line
	.word	CommandNext              ; $a7 next
	.word	NotTOS                   ; $a8 not
	.word	CommandOn                ; $a9 on
	.word	CommandMoreOn            ; $aa moreon
	.word	UnaryPeek                ; $ab peek
	.word	CommandPOKE              ; $ac poke
	.word	UnaryPos                 ; $ad pos
	.word	GetChannel               ; $ae getchannel
	.word	SetChannel               ; $af setchannel
	.word	PrintNumber              ; $b0 print.n
	.word	PrintString              ; $b1 print.s
	.word	CommandRead              ; $b2 read
	.word	CommandReadString        ; $b3 read$
	.word	UnaryRND                 ; $b4 rnd
	.word	StringConcatenate        ; $b5 concat
	.word	SignTOS                  ; $b6 sgn
	.word	PrintTab                 ; $b7 print.tab
	.word	PrintPos                 ; $b8 print.pos
	.word	PrintSpace               ; $b9 print.spc
	.word	Unary_Str                ; $ba str$
	.word	Unary_Left               ; $bb left$
	.word	Unary_Right              ; $bc right$
	.word	Unary_Mid                ; $bd mid$
	.word	CommandSwap              ; $be swap
	.word	TimeTOS                  ; $bf ti
	.word	TimeString               ; $c0 ti$
	.word	UnaryUsr                 ; $c1 usr
	.word	ValUnary                 ; $c2 val
	.word	CommandClose             ; $c3 close
	.word	CommandExit              ; $c4 exit
	.word	CommandDebug             ; $c5 debug
	.word	CommandOpen              ; $c6 open
	.word	CommandScreen            ; $c7 screen
	.word	CommandVPOKE             ; $c8 vpoke
	.word	CommandVPEEK             ; $c9 vpeek
	.word	CommandShift             ; $ca .shift
	.word	PushByteCommand          ; $cb .byte
	.word	PushWordCommand          ; $cc .word
	.word	CommandPushN             ; $cd .float
	.word	CommandPushS             ; $ce .string
	.word	CommandData              ; $cf .data
	.word	CommandGoto              ; $d0 .goto
	.word	CommandGosub             ; $d1 .gosub
	.word	CommandGotoZ             ; $d2 .goto.z
	.word	CommandGotoNZ            ; $d3 .goto.nz
	.word	CommandVarSpace          ; $d4 .varspace


ShiftVectorTable:
	.word	CommandClr               ; $ca80 clr
	.word	CommandDIM               ; $ca81 dim
	.word	CommandEnd               ; $ca82 end
	.word	UnaryJoy                 ; $ca83 joy
	.word	LinkFloatIntegerPartDown ; $ca84 int
	.word	LinkFloatSquareRoot      ; $ca85 sqr
	.word	LinkFloatLogarithm       ; $ca86 log
	.word	LinkFloatExponent        ; $ca87 exp
	.word	LinkFloatCosine          ; $ca88 cos
	.word	LinkFloatSine            ; $ca89 sin
	.word	LinkFloatTangent         ; $ca8a tan
	.word	LinkFloatArcTan          ; $ca8b atn
	.word	XCommandMouse            ; $ca8c mouse
	.word	XUnaryMB                 ; $ca8d mb
	.word	XUnaryMX                 ; $ca8e mx
	.word	XUnaryMY                 ; $ca8f my
	.word	CommandRestore           ; $ca90 restore
	.word	CommandStop              ; $ca91 stop
	.word	CommandSYS               ; $ca92 sys
	.word	CommandTIWrite           ; $ca93 ti$.write
	.word	CommandWAIT              ; $ca94 wait
	.word	X16I2CPoke               ; $ca95 i2cpoke
	.word	X16I2CPeek               ; $ca96 i2cpeek
	.word	CommandBank              ; $ca97 bank
	.word	XCommandSleep            ; $ca98 sleep
	.word	X16_Audio_FMINIT         ; $ca99 fminit
	.word	X16_Audio_FMNOTE         ; $ca9a fmnote
	.word	X16_Audio_FMDRUM         ; $ca9b fmdrum
	.word	X16_Audio_FMINST         ; $ca9c fminst
	.word	X16_Audio_FMVIB          ; $ca9d fmvib
	.word	X16_Audio_FMFREQ         ; $ca9e fmfreq
	.word	X16_Audio_FMVOL          ; $ca9f fmvol
	.word	X16_Audio_FMPAN          ; $caa0 fmpan
	.word	X16_Audio_FMPLAY         ; $caa1 fmplay
	.word	X16_Audio_FMCHORD        ; $caa2 fmchord
	.word	X16_Audio_FMPOKE         ; $caa3 fmpoke
	.word	X16_Audio_PSGINIT        ; $caa4 psginit
	.word	X16_Audio_PSGNOTE        ; $caa5 psgnote
	.word	X16_Audio_PSGVOL         ; $caa6 psgvol
	.word	X16_Audio_PSGWAV         ; $caa7 psgwav
	.word	X16_Audio_PSGFREQ        ; $caa8 psgfreq
	.word	X16_Audio_PSGPAN         ; $caa9 psgpan
	.word	X16_Audio_PSGPLAY        ; $caaa psgplay
	.word	X16_Audio_PSGCHORD       ; $caab psgchord
	.word	CommandCls               ; $caac cls
	.word	CommandLocate            ; $caad locate
	.word	CommandColor             ; $caae color
	.send code
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		wait.asm
;		Purpose:	Wait command
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										WAIT command
;
; ************************************************************************************************

CommandWAIT: ;; [!wait]
		.entercmd
		lda 	NSMantissa0-2,x 			; get wait address
		sta 	zTemp0
		lda 	NSMantissa1-2,x
		sta 	zTemp0+1
_WaitLoop:
		lda 	(zTemp0) 					; read it
		and 	NSMantissa0-1,x		 		; and with mask
		eor 	NSMantissa0-0,x 			; toggle
		beq 	_WaitLoop 					; keep going if zero

		dex 								; drop 3.
		dex
		dex
		.exitcmd


; ************************************************************************************************

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		write_float.asm
;		Purpose:	Write iFloat32
;		Created:	13th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								Write float (2 byte command)
;
; ************************************************************************************************

WriteFloatCommand:
		.entercmd
		.vaddress
		jsr 	WriteFloatZTemp0Sub
		.exitcmd

WriteFloatZTemp0Sub:
		phy 								; ldart write
		ldy 	#1

		lda 	NSMantissa0,x
		sta 	(zTemp0)
		
		lda 	NSMantissa1,x
		sta 	(zTemp0),y
		iny

		lda 	NSMantissa2,x
		sta 	(zTemp0),y
		iny

		lda 	NSMantissa3,x
		sta 	(zTemp0),y
		iny

		lda 	NSExponent,x
		sta 	(zTemp0),y
		iny

		lda 	NSStatus,x
		sta 	(zTemp0),y

		dex
		ply
		rts
		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		write_int.asm
;		Purpose:	WriteInteger
;		Created:	13th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								Write integer (2 byte command)
;
; ************************************************************************************************

WriteIntegerCommand:
		.entercmd
		.vaddress
		jsr 	WriteIntegerZTemp0Sub
		.exitcmd

WriteIntegerZTemp0Sub:
		.floatinteger
		phy 								; start write
		ldy 	#1
		lda 	NSStatus,x 					; negate 2's comp if -ve
		bmi 	_WIZNegative

		lda 	NSMantissa0,x 				; +ve write
		sta 	(zTemp0)
		lda 	NSMantissa1,x
		sta 	(zTemp0),y
		ply
		dex
		rts

_WIZNegative:
		sec 								; -ve read
		lda 	#0
		sbc 	NSMantissa0,x
		sta 	(zTemp0)
		lda 	#0
		sbc 	NSMantissa1,x
		sta 	(zTemp0),y
		ply
		dex
		rts
		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		write_string.asm
;		Purpose:	Write String
;		Created:	17th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								Write string (2 byte command)
;
; ************************************************************************************************

WriteStringCommand:
		.entercmd
		.vaddress
		jsr 	WriteStringZTemp0Sub
		.exitcmd

WriteStringZTemp0Sub:
		phy

		ldy 	#1 							; if it is zero we must concrete whatever.
		lda 	(zTemp0)
		ora 	(zTemp0),y
		beq 	_WSConcrete

		lda 	(zTemp0) 					; put address of actual string in zTemp1
		sta 	zTemp1
		lda 	(zTemp0),y
		sta 	zTemp1+1

		lda 	NSMantissa0,x 				; copy source to zTemp2
		sta 	zTemp2
		lda 	NSMantissa1,x
		sta 	zTemp2+1

		lda 	(zTemp1) 					; space available
		cmp 	(zTemp2) 					; if >= required length then copy
		bcs 	_WSCopy

		ldy 	#1 							; set the 'available for reclaim' flag
		lda 	(zTemp1),y
		ora 	#$80
		sta 	(zTemp1),y
		;
		;		Otherwise concrete it
		;
_WSConcrete:		
		lda 	NSMantissa1,x 				; string in YA
		tay
		lda 	NSMantissa0,x
		jsr 	StringConcrete
		;
		;		Update the address.
		;
		sta 	(zTemp0) 					; save returned address
		tya
		ldy 	#1
		sta 	(zTemp0),y		
		;
		;		Copy old string to new string space.
		;
_WSCopy		
		clc  								; copy target+2 to zTemp2
		lda 	(zTemp0)
		adc 	#2
		sta 	zTemp2
		ldy 	#1
		lda 	(zTemp0),y
		adc 	#0
		sta 	zTemp2+1
		;
		lda 	NSMantissa0,x 				; copy source to zTemp1
		sta 	zTemp1
		lda 	NSMantissa1,x
		sta 	zTemp1+1
		;
		lda 	(zTemp1) 					; length of string .. 0 inclusive
		tay
_WSCopyLoop:		
		lda 	(zTemp1),y
		sta 	(zTemp2),y
		dey 
		cpy 	#$FF
		bne 	_WSCopyLoop
	
		dex
		ply
		rts
		
		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_close.asm
;		Purpose:	CLOSE
;		Created:	2nd May 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;					<logical> CLOSE (cancels CMD effect if that channel closed)
;
; ************************************************************************************************

CommandClose: ;; [close]
		.entercmd
		jsr 	GetInteger8Bit 				; channel to close
		cmp 	currentChannel 				; is it the current channel
		bne 	_CCNotCurrent
		stz 	currentChannel 				; effectively disables CMD
_CCNotCurrent:
		jsr 	X16_CLOSE 					; close the file		
		.exitcmd


		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_exit.asm
;		Purpose:	Exit emulator
;		Created:	13th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								Exit emulator command
;
; ************************************************************************************************

CommandExit: ;; [exit]
		.entercmd
		stx 	zTemp0 						; stack position.
		jmp 	$FFFF 						; exits the emulator.

CommandDebug: ;; [debug]
		.entercmd
		.debug
		.exitcmd

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_getchar.asm
;		Purpose:	Character input interface
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code
		
; ************************************************************************************************
;
;						Get Input from Channel if available, else return 0
;										0 is the Keyboard
;
; ************************************************************************************************

XGetCharacterFromChannel:
		phx
		phy
		cpx 	#0 							; is it default
		bne 	_XGetChannel
		jsr 	X16_CLRCHN 					; set default channel
		bra 	_XGetChar
_XGetChannel:		
		jsr 	X16_CHKIN					; CHKIN set channel
		jsr 	X16_READST 					; check okay
		bne 	_XGCError
_XGetChar:		
		jsr 	X16_GETIN
		ply
		plx
		rts
_XGCError:
		.error_channel

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_getxpos.asm
;		Purpose:	Get horizontal position
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							Get horizontal character position.
;
; ************************************************************************************************

XGetHPos:
		phx
		phy
		sec
		jsr 	X16_PLOT
		tya
		ply
		plx
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_i2c.asm
;		Purpose:	I2C Peek/Poke
;		Created:	9th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								I2CPOKE device,register,value
;
; ************************************************************************************************

X16I2CPoke: ;; [!I2CPOKE]
		.entercmd
		phy
		jsr 	GetInteger8Bit 				; value
		pha
		dex
		jsr 	GetInteger8Bit 				; register
		pha
		dex
		jsr 	GetInteger8Bit 				; device
		tax 			
		ply
		pla
		jsr 	X16_i2c_write_byte 			; write the byte out.
		bcs 	X16I2CError
		ply
		ldx 	#$FF
		.exitcmd

X16I2CError:
		.error_channel 

; ************************************************************************************************
;
;									I2CPEEK(device,register)
;
; ************************************************************************************************

X16I2CPeek: ;; [!I2CPEEK]		
		.entercmd
		phx
		phy
		jsr 	GetInteger8Bit 				; register
		pha
		dex
		jsr 	GetInteger8Bit 				; device
		tax 								; X device
		ply 								; Y register
		jsr 	X16_i2c_read_byte 			; read I2C
		bcs 	X16I2CError
		ply 								; restore Y/X
		plx
		dex 								; drop TOS (register)
		jsr 	FloatSetByte 				; write read value to TOS.
		.exitcmd

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_open.asm
;		Purpose:	OPEN
;		Created:	2nd May 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;					<logical> <device> <secondary> <filename> OPEN command
;
; ************************************************************************************************

CommandOpen: ;; [open]
		.entercmd
		;
		;		Set up the file name
		;
		lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
		sta 	zTemp0
		tax
		lda 	NSMantissa1+3 
		sta 	zTemp0+1
		tay

		inx 								; XY points to first character
		bne 	_CONoCarry
		iny
_CONoCarry:		
		lda 	(zTemp0) 					; get length of filename
		jsr 	X16_SETNAM
		;
		; 		Set up the logical channel.
		;
		lda 	NSMantissa0+0
		ldx 	NSMantissa0+1
		ldy 	NSMantissa0+2
		jsr 	X16_SETLFS
		;
		;		Open
		;
		jsr 	X16_OPEN
		bcs 	_COError
		.exitcmd
_COError:
		.error_channel

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_peekpoke.asm
;		Purpose:	Read/Write memory
;		Created:	20th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											Write Memory
;
; ************************************************************************************************

XPokeMemory:
		stx 	zTemp0
		sty 	zTemp0+1

		ldy 	SelectRAMBank 				; old RAM bank in Y
		ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
		cpx 	#$FF
		beq 	_XPMNoSwitch
		stx 	SelectRAMBank
_XPMNoSwitch:
		sta 	(zTemp0) 					; do the POKE
		sty 	SelectRAMBank 				; reselect previous RAM Bank.		
_XPMExit:
		rts

; ************************************************************************************************
;
;											Read Memory
;
; ************************************************************************************************

XPeekMemory:
		stx 	zTemp0
		sty 	zTemp0+1

		ldy 	SelectRAMBank 				; old RAM bank in Y
		ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
		cpx 	#$FF
		beq 	_XPMNoSwitch
		stx 	SelectRAMBank
_XPMNoSwitch:
		lda 	(zTemp0) 					; do the PEEK
		sty 	SelectRAMBank 				; reselect previous RAM bank.
		rts


; ************************************************************************************************
;
;											BANK command
;
; ************************************************************************************************

CommandBank: ;; [!bank]
		.entercmd
		lda 	NSMantissa0 				; RAM bank
		sta 	ramBank 					; store & make current
		sta 	SelectRAMBank
		lda 	NSMantissa0+1 		 		; ROM specified 
		cmp 	#$FF
		beq 	_CBNoUpdate
		sta 	romBank 					; this doesn't set the hardware page.
_CBNoUpdate:		
		ldx 	#$FF
		.exitcmd

		.send code

		.section storage
ramBank:
		.fill 	1
romBank:
		.fill 	1
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		printchar.asm
;		Purpose:	Character output interface
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code
		
; ************************************************************************************************
;
;						Print character A to Channel X: 13 should be CR, 32 space
;
;										Channel 0 is the screen.
;
; ************************************************************************************************

XPrintCharacterToChannel:
		pha
		phx
		phy

		pha  								; save char
		cpx 	#0 							; check default (0)
		bne 	_XPCNotDefault
		jsr 	X16_CLRCHN					; set default channel
		bra 	_XPCSend
_XPCNotDefault:		
		jsr 	X16_CHKOUT 					; CHKOUT set channel
		jsr 	X16_READST 					; check okay
		bne 	_XPCError
_XPCSend:		
		pla 								; restore character
		jsr 	X16_BSOUT 					; print

		ply
		plx
		pla
		rts
_XPCError:
		.error_channel

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_readwriteclock.asm
;		Purpose:	Read/Write 60Hz clock
;		Created:	20th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Read Clock into YXA
;
; ************************************************************************************************

XReadClock:
		jsr 	X16_RDTIM
		rts
		
XWriteClock:
		pha
		phx
		phy
		jsr 	X16_SETTIM
		ply
		plx
		pla
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_screen.asm
;		Purpose:	Screen Command
;		Created:	4th May 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;											Screen Command
;
; ************************************************************************************************

CommandScreen: ;; [screen]
		.entercmd
		phx
		phy
		jsr 	GetInteger8Bit
		clc 
		jsr 	X16_screen_mode
		ply
		plx
		.exitcmd

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_sleep.asm
;		Purpose:	Sleep for n ticks
;		Created:	9th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Sleep for N ticks.
;
; ************************************************************************************************

XCommandSleep: ;; [!sleep]
		.entercmd
		phy
		.floatinteger 						; make everything integer
		dex
		jsr 	XReadClock 					; read clock to YXA
		;
		clc 								; calculate end time in zTemp0
		adc 	NSMantissa0
		sta 	zTemp0
		txa
		adc 	NSMantissa1
		sta 	zTemp0+1

_XCWait:
		jsr 	XReadClock 					; and wait for it.
		cmp 	zTemp0
		bne 	_XCWait
		cpx 	zTemp0+1
		bne 	_XCWait

		ldx 	#$FF
		ply
		.exitcmd

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
;
;	This file is automatically generated.
;
	.section code
X16_Audio_FMINIT: ;; [!FMINIT]
	.entercmd
	phy
	jsr		X16_JSRFAR
	.word	X16A_ym_init
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_FMNOTE: ;; [!FMNOTE]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_8
	clc
	jsr		X16_JSRFAR
	.word	X16A_bas_fmnote
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_FMDRUM: ;; [!FMDRUM]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_8
	clc
	jsr		X16_JSRFAR
	.word	X16A_ym_playdrum
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_FMINST: ;; [!FMINST]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_8
	sec
	jsr		X16_JSRFAR
	.word	X16A_ym_loadpatch
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_FMVIB: ;; [!FMVIB]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_8
	clc
	jsr		X16_JSRFAR
	.word	X16A_bas_fmvib
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_FMFREQ: ;; [!FMFREQ]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_16
	jsr		X16_JSRFAR
	.word	X16A_bas_fmfreq
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_FMVOL: ;; [!FMVOL]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_8
	clc
	jsr		X16_JSRFAR
	.word	X16A_ym_setatten
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_FMPAN: ;; [!FMPAN]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_8
	clc
	jsr		X16_JSRFAR
	.word	X16A_ym_setpan
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_FMPLAY: ;; [!FMPLAY]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_String
	jsr		X16_JSRFAR
	.word	X16A_bas_fmplaystring
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_FMCHORD: ;; [!FMCHORD]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_String
	jsr		X16_JSRFAR
	.word	X16A_bas_fmchordstring
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_FMPOKE: ;; [!FMPOKE]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_8
	clc
	jsr		X16_JSRFAR
	.word	X16A_ym_write
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_PSGINIT: ;; [!PSGINIT]
	.entercmd
	phy
	jsr		X16_JSRFAR
	.word	X16A_psg_init
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_PSGNOTE: ;; [!PSGNOTE]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_8
	clc
	jsr		X16_JSRFAR
	.word	X16A_bas_psgnote
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_PSGVOL: ;; [!PSGVOL]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_8
	clc
	jsr		X16_JSRFAR
	.word	X16A_psg_setatten
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_PSGWAV: ;; [!PSGWAV]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_8
	clc
	jsr		X16_JSRFAR
	.word	X16A_bas_psgwav
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_PSGFREQ: ;; [!PSGFREQ]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_16
	jsr		X16_JSRFAR
	.word	X16A_bas_psgfreq
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_PSGPAN: ;; [!PSGPAN]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_8
	clc
	jsr		X16_JSRFAR
	.word	X16A_psg_setpan
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_PSGPLAY: ;; [!PSGPLAY]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_String
	jsr		X16_JSRFAR
	.word	X16A_bas_psgplaystring
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


X16_Audio_PSGCHORD: ;; [!PSGCHORD]
	.entercmd
	phy
	jsr		X16_Audio_Parameters8_String
	jsr		X16_JSRFAR
	.word	X16A_bas_psgchordstring
	.byte	X16_AudioCodeBank
	ldx	#$FF
	ply
	.exitcmd


	.send code
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_text.asm
;		Purpose:	Text I/O Commands
;		Created:	8th May 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										Clear Screen Command
;
; ************************************************************************************************

CommandCls: ;; [!cls]
		.entercmd
		lda 	#147
		jsr 	XPrintCharacterToChannel
		.exitcmd

; ************************************************************************************************
;
;										Locate X[,Y] command
;
; ************************************************************************************************

CommandLocate: ;; [!locate]
		.entercmd
		.floatinteger 						; make everything integer
		dex
		.floatinteger
		dex
		lda 	#$13 						; home.
		jsr 	XPrintCharacterToChannel
		lda 	#$1D 						; do cursor rights
		ldx 	NSMantissa0
		jsr 	_CLOutputXA
		lda 	#$11 						; do cursor downs.
		ldx 	NSMantissa0+1
		jsr 	_CLOutputXA
		.exitcmd

_CLOutputXA: 								; output X A's, 1 based.
		dex
		beq 	_CLOExit
		bmi 	_CLOExit
		jsr 	XPrintCharacterToChannel
		bra 	_CLOutputXA
_CLOExit:
		rts		

; ************************************************************************************************
;
;										Color F[,B]
;
; ************************************************************************************************

CommandColor: ;; [!color]
		.entercmd
		.floatinteger 						; make everything integer
		dex
		.floatinteger
		dex
		lda 	NSMantissa0+1 				; bgr specified
		cmp 	#$FF  				
		beq 	_CCNoBGR 					; if so, change background
		jsr 	_CCSetColour
		lda 	#$01 						; swap FGR/BGR
		jsr 	XPrintCharacterToChannel
_CCNoBGR:
		lda 	NSMantissa0
		jsr 	_CCSetColour		
		.exitcmd

_CCSetColour:
		and 	#15 						; look up in control codes table.
		tax
		lda 	_CCCommandTable,x
		jsr 	XPrintCharacterToChannel
		rts

_CCCommandTable:
		.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
		.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_vpoke.asm
;		Purpose:	VPoke command
;		Created:	29th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code
		
; ************************************************************************************************
;
;								VPOKE bank,address,data
;
; ************************************************************************************************

CommandVPOKE: ;; [vpoke]
		.entercmd

		jsr 	GetInteger8Bit 				; poke value
		pha
		dex

		.floatinteger 						; address (MED/LO)
		lda 	NSMantissa0,x
		sta 	VRAMLow0
		lda 	NSMantissa1,x
		sta 	VRAMMed0
		dex

		.floatinteger 						; address (HI)
		jsr 	GetInteger8Bit
		sta 	VRAMHigh0
		dex

		pla 								; poke value back
		sta 	VRAMData0					; and write it out.

		.exitcmd

; ************************************************************************************************
;
;								VPOKE bank,address,data
;
; ************************************************************************************************

CommandVPEEK: ;; [vpeek]
		.entercmd

		.floatinteger 						; address (MED/LO)
		lda 	NSMantissa0,x
		sta 	VRAMLow0
		lda 	NSMantissa1,x
		sta 	VRAMMed0
		dex

		.floatinteger 						; address (HI)
		jsr 	GetInteger8Bit
		sta 	VRAMHigh0

		lda 	VRAMData0					; read data
		jsr 	FloatSetByte 				; return as byte
		.exitcmd

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
