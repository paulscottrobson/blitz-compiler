;
;	This file is automatically generated
;
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		api.inc
;		Purpose:	API Constants for compiler
;		Created:	7th October 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Mandatory Zero page code
;
; ************************************************************************************************
;
;		Open the input file or from memory.
;
BLC_OPENIN = 0
;
;		Close the input file. Cannot be reopened.
;
BLC_CLOSEIN = 1
;
;		Read the next line from the source file. This should be returned into YX and should
; 		point to the line number data ; e.g. the offset to next, line number etc.
;		Returns CS if line available, CC finished.
;
BLC_READIN = 2
;
;		Reset the code writing pointer. Code has to be stored in memory as it is passed over
; 		at the end to fix up all the line number references. It can be stored on BLC_CLOSEOUT
;
BLC_RESETOUT = 3
;
;		Close the output - at this point you can write the generated code if you want.
;
BLC_CLOSEOUT = 4
;
;		Write a byte X at the object pointer and bump that address.
;
BLC_WRITEOUT = 5
;
;		Print character X to display / stream for errors & information
;
BLC_PRINTCHAR = 6

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		data.inc
;		Purpose:	Compiler Data
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Mandatory Zero page code
;
; ************************************************************************************************

		.section zeropage
srcPtr: 									; pointer in source buffer
		.fill 	2		
		.send zeropage


; ************************************************************************************************
;
;										Non Zero Page Data
;
; ************************************************************************************************

		.section storage
currentLineNumber:							; current line number.
		.fill 	2		
		.send 	storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		macros.inc
;		Purpose:	Command macros
;		Created:	25th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							Size independent write keyword as constant
;
; ************************************************************************************************

keyword .macro
		.if (\1) > 255
		lda 	#(\1) >> 8
		jsr 	WriteCodeByte
		.endif
		lda 	#(\1) & $FF
		jsr 	WriteCodeByte
		.endm


		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_storage.inc
;		Purpose:	Storage access macros
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

storage_access .macro
		.endm

storage_release .macro
		.endm

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		altbase.asm
;		Purpose:	Handle other bases
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						Compile a 16 bit other base constant. Type marker in A
;
; ************************************************************************************************

InlineNonDecimal:
		ldx 	#2 							; get size in X
		cmp 	#"%" 						
		beq 	_INDBinary
		ldx 	#16
_INDBinary:									
		sta 	zTemp1 						; size => zTemp1
		stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
		stz 	zTemp0 						; zero result
		stz 	zTemp0+1
_INDLoop:
		jsr 	LookNext 					; check next character
		jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
		bcc		_INDDone 					; didn't convert
		cmp 	zTemp1 						; size too large ?
		bcs 	_INDDone
		;
		jsr 	_INDShift 					; x 2 or x 16
		cpx 	#2
		beq 	_INDNotHex
		jsr 	_INDShift
		jsr 	_INDShift
		jsr 	_INDShift
_INDNotHex:
		ora 	zTemp0 						; or digit into result
		sta 	zTemp0 		
		jsr 	GetNext 					; consume
		inc 	zTemp1+1 					; bump count
		bra 	_INDLoop
		;
_INDDone:
		lda 	zTemp1+1 					; done at least 1 ?
		beq 	_INDError
		ldy 	zTemp0+1 					; push constant
		lda 	zTemp0	
		jsr 	PushIntegerYA
		rts

_INDError:
		.error_syntax
		
_INDShift:
		asl 	zTemp0
		rol 	zTemp0+1
		rts		
		.send code

		.section storage
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		api.asm
;		Purpose:	Short version of common API functions
;		Created:	7th October 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Get line number of current line -> YA
;
; ************************************************************************************************		

GetLineNumber:
		ldy 	currentLineNumber+1
		lda 	currentLineNumber
		rts
		
; ************************************************************************************************
;
;									Write byte A to output
;
; ************************************************************************************************

WriteCodeByte:
		pha 								; save on stack
		phx
		phy
		tax
		lda 	#BLC_WRITEOUT
		jsr 	CallAPIHandler
		ply 								; restore from stack
		plx
		pla
		rts

; ************************************************************************************************
;
;								Print character A to Screen/Error Stream
;
; ************************************************************************************************

PrintCharacter
		pha
		phx
		phy
		tax
		lda 	#BLC_PRINTCHAR
		jsr 	CallAPIHandler
		ply
		plx
		pla
		rts

; ************************************************************************************************
;
;					Process new line - set source pointer, extract line number
;
; ************************************************************************************************
 
ProcessNewLine:
		stx 	zTemp0 						; save address in zTemp0
		sty 	zTemp0+1

		clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
		txa
		adc 	#4
		sta 	srcPtr
		tya
		adc 	#0
		sta 	srcPtr+1

		ldy 	#2							; read and save line number
		lda 	(zTemp0),y
		sta 	currentLineNumber
		iny
		lda 	(zTemp0),y
		sta 	currentLineNumber+1
		rts

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		buffer.asm
;		Purpose:	Buffer for inline data, strings etc.
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Clear the buffer
;
; ************************************************************************************************

BufferClear:
		stz 	bufferSize
		rts		

; ************************************************************************************************
;
;									 Write A to the buffer
;
; ************************************************************************************************

BufferWrite:
		phx
		ldx 	bufferSize
		sta 	dataBuffer,x
		inc 	bufferSize
		plx
		rts

; ************************************************************************************************
;
;								Output buffer as data block
;
; ************************************************************************************************

BufferOutput:
		lda 	bufferSize
		jsr 	WriteCodeByte
		ldx 	#0
_BOLoop:
		cpx 	bufferSize
		beq 	_BOExit
		lda 	dataBuffer,x
		jsr 	WriteCodeByte
		inx
		bra 	_BOLoop
_BOExit:
		rts		
		.send code

		.section storage
bufferSize:
		.fill 	1
dataBuffer:
		.fill 	256
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		check.asm
;		Purpose:	Token presence check
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

	
; ************************************************************************************************
;
;									Check Next char various
;
; ************************************************************************************************

CheckNextComma:
		lda	 	#","
		bra 	CheckNextA
CheckNextRParen:
		lda	 	#")"
		bra 	CheckNextA
CheckNextLParen:
		lda 	#"("
CheckNextA:
		sta 	checkCharacter 				; save test character
_CNALoop:		
		jsr 	GetNextNonSpace 			; get next skipping spaces.
		cmp 	checkCharacter 				; matches ?
		beq 	_CNAExit
		.error_syntax
_CNAExit:		
		rts
		.send code

		.section storage
checkCharacter:
		.fill 	1
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		00compiler.asm
;		Purpose:	Compiler main
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						On entry YX points to API.  On Exit CC if okay.
;
; ************************************************************************************************

StartCompiler:
		stx 	zTemp0 						; access API
		sty 	zTemp0+1

		ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
		ldx 	#CompilerErrorHandler & $FF
		jsr 	SetErrorHandler
		;
		ldy 	#1 							; copy API vector		
		lda 	(zTemp0)	
		sta 	APIVector
		lda 	(zTemp0),y
		sta 	APIVector+1

		iny 								; copy data area range.
		lda 	(zTemp0),y 					
		sta 	compilerStartHigh
		iny
		lda 	(zTemp0),y 					
		sta 	compilerEndHigh

		tsx 								; save stack pointer
		stx 	compilerSP

		jsr 	STRReset 					; reset storage (line#, variable)

		lda 	#BLC_OPENIN					; reset data input
		jsr 	CallAPIHandler

		lda 	#BLC_RESETOUT 				; reset data output.
		jsr 	CallAPIHandler
		;
		;		Compile _variable.space, filled in on pass 2.
		;
		lda 	#PCD_CMD_VARSPACE
		jsr 	WriteCodeByte
		lda 	#0
		jsr 	WriteCodeByte
		jsr 	WriteCodeByte
		;
		;		Main compilation loop
		;
MainCompileLoop:
		lda 	#BLC_READIN 				; read next line into the buffer.		
		jsr 	CallAPIHandler

		bcc 	SaveCodeAndExit 			; end of source.
		jsr 	ProcessNewLine 				; set up pointer and line number.
		;
		jsr 	GetLineNumber 				; get line #
		jsr 	STRMarkLine 				; remember the code position and number of this line.
		lda 	#PCD_NEWCMD_LINE 			; generate new command line
		jsr 	WriteCodeByte

_MCLSameLine:
		jsr 	GetNextNonSpace 			; get the first character.
		beq 	MainCompileLoop 			; end of line, get next line.
		cmp 	#":"						; if : then loop back.
		beq 	_MCLSameLine

		cmp 	#0 							; if ASCII then check for implied LET.		
		bpl 	_MCLCheckAssignment 

		ldx 	#CommandTables & $FF 		; do command tables.
		ldy 	#CommandTables >> 8
		jsr 	GeneratorProcess
		bcs 	_MCLSameLine 				; keep trying to compile the line.

_MCLSyntax: 								; syntax error.
		.error_syntax
		;
		;		Implied assignment ?
		;
_MCLCheckAssignment:
		jsr 	CharIsAlpha 				; if not alpha then syntax error
		bcc 	_MCLSyntax
		jsr 	CommandLETHaveFirst  		; LET first character, do assign
		bra		_MCLSameLine 				; loop back.
		;
		;		End of compile, fix up GOTO/GOSUB etc., save it and exit.
		;
SaveCodeAndExit:
		lda 	#BLC_CLOSEIN				; finish input.
		jsr 	CallAPIHandler

		lda 	#$FF 						; fake line number $FFFF for forward THEN.
		tay
		jsr 	STRMarkLine
		lda 	#PCD_EXIT 					; add an END
		jsr 	WriteCodeByte
		lda 	#$FF 						; add end marker
		jsr 	WriteCodeByte
		jsr 	FixBranches 				; fix up GOTO/GOSUB etc.

		lda 	#BLC_CLOSEOUT 				; close output store 
		jsr 	CallAPIHandler
		clc 								; CC = success

ExitCompiler:		
		ldx 	compilerSP 					; reload SP and exit.
		txs
		rts

; ************************************************************************************************
;
;										Call API Functions
;
; ************************************************************************************************

CallAPIHandler:
		jmp 	(APIVector)

		.send code

		.section storage
compilerSP:									; stack pointer 6502 on entry.
		.fill 	1
APIVector: 									; call API here
		.fill 	2		
compilerStartHigh:							; MSB of workspace start address
		.fill 	1		
compilerEndHigh:							; MSB of workspace end address
		.fill 	1		
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		constant.asm
;		Purpose:	Output integer constants
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Output code to push integer YA / A
;
; ************************************************************************************************

PushIntegerYA:
		cpy 	#0 							; 0-255
		beq 	PushIntegerA
		pha
		lda 	#PCD_CMD_WORD 				; send .word
		jsr 	WriteCodeByte 	
		pla 								; then LSB
		jsr 	WriteCodeByte 	
		tya 								; then MSB
		jsr 	WriteCodeByte 	
		rts

PushIntegerA:
		cmp 	#64 						; if > 64 send byte as is
		bcc 	_PIWriteA
		pha 								
		lda 	#PCD_CMD_BYTE 				; send .byte
		jsr 	WriteCodeByte 	
		pla
_PIWriteA:		
		jsr 	WriteCodeByte
		rts

; ************************************************************************************************
;
;										Push TOS Float
;
; ************************************************************************************************

PushFloatCommand:
		lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
		jsr 	WriteCodeByte
		lda 	NSExponent,x 				; and the data
		jsr 	WriteCodeByte
		lda 	NSMantissa0,x
		jsr 	WriteCodeByte
		lda 	NSMantissa1,x
		jsr 	WriteCodeByte
		lda 	NSMantissa2,x
		jsr 	WriteCodeByte
		lda 	NSStatus,x 					; with sign packed in byte 3 MSB
		and 	#$80
		ora 	NSMantissa3,x
		jsr 	WriteCodeByte
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		create.asm
;		Purpose:	Create variable.
;		Created:	25th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;		  		   XYmake  contains a variable name. Allocate space for it and create it. 
;										Return variable address in YX
;
; ************************************************************************************************

		.section code

CreateVariableRecord:
		pha

		.storage_access

		lda 	freeVariableMemory 		; push current free address on stack.
		pha
		lda 	freeVariableMemory+1
		pha

		lda 	variableListEnd  		; copy end of list to zTemp0
		sta 	zTemp0	
		lda 	variableListEnd+1
		sta 	zTemp0+1

		lda 	#6 						; default size if 6 (offset link 3 bytes)
		sta 	(zTemp0)

		tya
		ldy 	#2 						; write out the name.
		sta 	(zTemp0),y
		dey
		txa
		sta 	(zTemp0),y

		ldy 	#3 						; write out the address.
		lda 	freeVariableMemory
		sta 	(zTemp0),y
		iny
		lda 	freeVariableMemory+1
		sta 	(zTemp0),y

		ldy 	#6 						; write EOL marker next record.
		lda 	#0
		sta 	(zTemp0),y

		clc
		lda 	(zTemp0) 				; add offset to variableListEnd
		adc  	variableListEnd
		sta 	variableListEnd
		bcc 	_CVNoCarry2
		inc 	variableListEnd+1
_CVNoCarry2:		
		.storage_release
		ply 							
		plx
		pla
		rts

; ************************************************************************************************
;
;			Set the last defined variable record to the current code position.
;
; ************************************************************************************************

SetVariableRecordToCodePosition:
		.storage_access
		pha
		phy
		ldy 	#3
		lda 	objPtr+1
		sta 	(zTemp0),y
		iny 	
		lda 	objPtr
		sta 	(zTemp0),y
		ply
		pla
		.storage_release
		rts

; ************************************************************************************************
;
;									Allocate bytes for type A
;
; ************************************************************************************************

AllocateBytesForType:
		pha
		phx
		ldx 	#2 						; bytes to allocate
		and 	#NSSTypeMask+NSSIInt16
		cmp 	#NSSIFloat
		bne 	_CVNotFloat
		ldx 	#6
_CVNotFloat:
		txa 							; add 6 or 2 to the free memory pointer.
		clc
		adc 	freeVariableMemory
		sta 	freeVariableMemory
		bcc 	_CVNoCarry1
		inc 	freeVariableMemory+1
_CVNoCarry1:				
		plx
		pla
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		data.asm
;		Purpose:	Compile DATA Statements
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Compile a Data Block
;
; ************************************************************************************************

CommandDATA:
		jsr 	BufferClear 				; copy it to the buffer
		jsr 	LookNextNonSpace
_CTDataLoop:
		jsr 	LookNext 					; reached EOL
		beq 	_CTDataDone
		;
		jsr 	BufferWrite 				; write and consume
		jsr 	GetNext
		bra 	_CTDataLoop
_CTDataDone:
		lda 	#PCD_CMD_DATA 				; output command and buffer
		jsr 	WriteCodeByte
		jsr 	BufferOutput
		rts		

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		deffn.asm
;		Purpose:	Def Fn command
;		Created:	29th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										DEF FN
;
; ************************************************************************************************

CommandDEF: 		
		;
		;		Skip to EOL.
		;
		lda 	#0 							; constant 0 (for GOTOZ)
		jsr 	PushIntegerA
		jsr 	CompileGotoEOL 				; compile skip over DEF
		;
		;	 	Check FN keyword
		;
		lda 	#C64_FN
		jsr 	CheckNextA
		;
		;		Identify FNxx(
		;
		jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
		jsr 	ExtractVariableName 
		txa
		bpl 	_CDError
		;
		txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
		and 	#$7F
		tax
		tya
		ora 	#$80
		tay
		;
		;		Create the FNxx( record and give it the address.
		;
		jsr 	FindVariable				; does it already exist ?
		bcs 	_CDError 					; if so, that's an error.
		jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
		jsr 	SetVariableRecordToCodePosition
		;
		;		Get the address to update.
		;
		jsr 	GetNextNonSpace
		jsr 	GetReferenceTerm 			; get var ref, not array
		cmp 	#0
		bmi 	_CDError 	
		sta 	defType 					; save type		
		stx 	defVariable 				; save var ref 
		sty 	defVariable+1
		and 	#NSSString 					; only numbers.
		bne 	_CDError
		jsr 	CheckNextRParen 			; check )
		lda 	#C64_EQUAL
		jsr 	CheckNextA 					; check =
		;	
		;		Now generate the code.
		;
		clc 								; if this is DEF FNxx(A), read A
		jsr 	CDReadWriteVariable
		.keyword PCD_SWAP 					; old A 2nd, new A 1st
		sec
		jsr 	CDReadWriteVariable 		; A is now updated
		jsr 	CompileExpressionAt0 		; the actual body of the function.
		.keyword PCD_SWAP 					; result 2nd, old A 1st
		sec
		jsr 	CDReadWriteVariable 		; A is now reset to its old value
		.keyword PCD_RETURN 				; return as we'll call it from a subroutine
		rts


_CDError:
		.error_syntax

CDReadWriteVariable:
		ldy 	defVariable+1 				; set up YX
		ldx 	defVariable
		lda 	defType
		jsr 	GetSetVariable
		rts
		.send code

		.section storage
defType:
		.fill 	1
defVariable:
		.fill 	2
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		dim.asm
;		Purpose:	DIM command
;		Created:	26th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											DIM command
;
; ************************************************************************************************

CommandDIM:
		jsr 	GetNextNonSpace 			; get the first non space character
		jsr 	ExtractVariableName 		; variable name to XY
		phx 								; save name with type bits.
		cpx 	#0 							; check it is an array.
		bpl 	_CDError
		jsr 	FindVariable	 			; see if already exist
		bcs 	_CDRedefine 				; it still exists.
		jsr 	CreateVariableRecord 		; create the basic variable 
		jsr 	AllocateBytesForType 		; allocate memory for it

		pla 								; restore type bits
		phy 								; save the address of the basic storage
		phx
		pha
		jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
		pla
		and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
		jsr 	PushIntegerA 				; push that type data out.

		.keyword PCD_DIM 					; call the keyword to dimension the array with this information.
		
		plx 								; restore address
		ply
		lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
		sec
		jsr 	GetSetVariable 				; store the address in the reference to the array structure.
		;
		jsr 	LookNextNonSpace 			; , follows ?
		cmp 	#","
		bne 	_CDExit
		jsr 	GetNext 					; consume comma
		bra 	CommandDIM 					; do another DIM
_CDExit:		
		rts		

_CDError:
		.error_syntax
_CDRedefine:
		.error_redefine

; ************************************************************************************************
;
;									Consume an index group
;
; ************************************************************************************************

OutputIndexGroup:
		stz 	IndexCount 					; count of number of indices.
_OIGNext:
		jsr 	CompileExpressionAt0 		; get a dimension
		and 	#NSSTypeMask 				; check it is numeric
		cmp 	#NSSIFloat
		bne 	_OIGType
		inc 	IndexCount 					; bump the counter.
		jsr 	LookNextNonSpace 			; does a , follow ?
		cmp 	#","
		bne 	_OIGCheckEnd
		jsr 	GetNext 					; consume comma
		bra 	_OIGNext 					; get next dimension
_OIGCheckEnd:
		jsr 	CheckNextRParen 			; check and consume )
		lda 	IndexCount
		jsr 	PushIntegerA 				; compile the dimension count.
		rts

_OIGType:
		.error_type
		
		.send code

		.section storage
IndexCount:
		.fill 	1
		.send storage		

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		errorhandler.asm
;		Purpose:	Error handler
;		Created:	1st May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code
	
CompilerErrorHandler:
		pla
		ply
		sta 	zTemp0
		sty 	zTemp0+1
		ldx 	#0 							; output msg to channel #0 
		ldy 	#1
_EHDisplayMsg:
		lda 	(zTemp0),y
		jsr 	PrintCharacter
		iny
		lda 	(zTemp0),y
		bne 	_EHDisplayMsg
		lda 	#32
		jsr 	PrintCharacter
		lda 	#64
		jsr 	PrintCharacter
		;
		ldx 	#0 							; convert line# to string
		jsr 	FloatSetByte
		jsr 	GetLineNumber
		sta 	NSMantissa0,x
		tya
		sta 	NSMantissa1,x
		jsr 	FloatToString
		ldy 	#0 							; display that string.
		ldx 	#0
_EHDisplayLine:
		lda 	decimalBuffer,y
		jsr 	PrintCharacter
		iny
		lda 	decimalBuffer,y
		bne 	_EHDisplayLine
		lda 	#13
		jsr 	PrintCharacter
		sec 								; CS = error	
		jmp 	ExitCompiler
						
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		expression.asm
;		Purpose:	Expression evaluator
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Compile expression precedence A/0
;
; ************************************************************************************************

CompileExpressionAt0:
		lda 	#0
CompileExpressionAtA:
		pha  								; save level
		jsr 	CompileTerm 				; compile a term.
		plx 								; get level back into X
		;
		;		Expression main loop - X is the precedence level, A the type.
		;
_ECALoop:				
		pha 								; save type on stack.
		jsr 	LookNextNonSpace 			; get the next character
		cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
		bcc 	_ECAExit
		cmp 	#C64_LESS+1
		bcc 	_ECAHaveToken
_ECAExit:
		pla 								; throw type off stack
		rts
		;
		;		Have a partial token - check precedence (because the >= <= <> precedence is the same as < and >)
		;
_ECAHaveToken:		
		stx 	zTemp0 						; save current precedence in zTemp0
		tax 								; X contains the operator token

		lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
		cmp 	zTemp0 						; if < then exit
		bcc 	_ECAExit
		sta 	zTemp0+1 					; save the precedence of the operator.
		jsr 	GetNext 					; consume the token.
		;
		;		Now check for >= <= <>
		;
		cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
		beq 	_ECAGreaterCheck
		cpx 	#C64_LESS
		bne 	_ECAHaveFullToken
		;
		jsr 	LookNext 					; checks for < (<= or <>)
		cmp 	#C64_GREATER 				; <> is 2 on from <
		beq	 	_ECAToNotEqual
		cmp 	#C64_EQUAL 					; <= is 3 on from <
		bne 	_ECAHaveFullToken
		bra 	_ECAAddEqual

_ECAGreaterCheck: 							; checks for > (>=)		
		jsr 	LookNext
		cmp 	#C64_EQUAL
		bne 	_ECAHaveFullToken
_ECAAddEqual:
		inx 								; > => >= and < to <= is three tokens on.
_ECAToNotEqual:		
		inx
		inx
		jsr 	GetNext 					; consume the = or > in >= <= <>		
_ECAHaveFullToken:		
		;
		;		Check for + string => concat
		;
		cpx 	#C64_PLUS
		bne 	_ECANotConcat
		pla 								; get type back
		pha
		and 	#NSSTypeMask
		cmp 	#NSSString
		bne 	_ECANotConcat
		ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
_ECANotConcat:		
		;
		;		Now have the correct token in X.
		;
		phx 								; save operator on the stack
		ldx 	zTemp0 						; push current precedence on the stack
		phx
		;
		;		Evaluate the RHS
		;
		lda 	zTemp0+1 					; get precedence of operator
		inc 	a
		jsr 	CompileExpressionAtA 		; and compile at the next level up.
		sta 	zTemp0 						; save type in zTemp0
		;
		plx 								; restore current precedence in X

		pla 								; restore operator
		sta 	zTemp0+1 					; save it in zTemp0+1.
		;
		;		Check if we need f.cmp or s.cmp
		;
		cmp 	#C64_GREATER 				; check for not compare
		bcc 	_ECANotCompare
		cmp 	#C64_GREATER+6
		bcs 	_ECANotCompare
		ply 								; get type into Y
		phy 
		pha 								; save operator

		tya 								; get type
		ldy 	#PCD_SCMD_CMP 				; Y is the token to use
		and 	#NSSTypeMask 				
		cmp 	#NSSString
		beq 	_ECANotString
		ldy 	#PCD_FCMD_CMP
_ECANotString:		
		tya									; output token Y
		jsr 	WriteCodeByte
		pla 								; restore operator.
_ECANotCompare:		
		;
		;		Compile the operator, which may be wrong (e.g. multiplying strings)
		;
		clc 								; convert to P-Code and compile.
		adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
		jsr 	WriteCodeByte
		;
		;		Check the types match
		;
		pla 								; type of current result
		eor 	zTemp0 						; check compatible with r-expr type
		and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
		bne		_ECAType
		;
		lda 	zTemp0 						; get type back
		cmp 	#NSSString 					; if it is a number, then all operators work.
		bne 	_ECAGoLoop 			
		;
		;		For strings only, check the command is valid (e.g. only + and comparators)
		;
		lda 	zTemp0+1 					; check operator is + or comparator
		cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
		beq 	_ECAOkayString 				; (this is post conversion)

		cmp 	#C64_GREATER 				; must be a comparison then.
		bcc 	_ECAType
		cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
		bcs 	_ECAType
		lda 	#NSSIFloat 					; compare returns number.
		jmp 	_ECALoop

_ECAType: 									; types mixed ?
		.error_type

_ECAOkayString:		
		lda 	#NSSString 					; current is string, go round again.
_ECAGoLoop:		
		jmp 	_ECALoop

; ************************************************************************************************
;
;										Operator precedence table
;
; ************************************************************************************************

PrecedenceTable:
		.byte 	3 					; '+'
		.byte 	3 					; '-'
		.byte 	4 					; '*'
		.byte 	4 					; '/'
		.byte 	5 					; '^'
		.byte 	1 					; 'and'
		.byte 	0 					; 'or'
		.byte 	2 					; '>'
		.byte 	2 					; '='
		.byte 	2 					; '<'
		.byte 	2 					; '>='
		.byte 	2 					; '<='
		.byte 	2 					; '<>'

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		findvar.asm
;		Purpose:	Find variable.
;		Created:	25th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;		  XY contains a variable name. Find it, returning address in YXA and CS if found
;		
;					  Returns $8000 > for special variables TI ($8000) TI$($C001)
;
; ************************************************************************************************

		.section code

FindVariable:
		stx 	zTemp1 						; save name.
		sty 	zTemp1+1
		;
		;		Check for TI $1409 and TI$ $5409 which return 6 and 8 as addresses.
		;
_IVCheckSpecial:		
		cpy 	#$09	 					; both end $09 e.g. I
		bne 	_IVStandard
		cpx 	#$14 						; TI is $14
		beq 	_IVTIFloat
		cpx 	#$54 						; TI$ is $54
		bne 	_IVStandard
		ldy 	#$C0 						; TI$ returns string $C001
		ldx 	#$01
		lda 	#NSSString
		sec
		rts
_IVTIFloat: 								; TI returns ifloat at $8000
		ldy 	#$80
		ldx 	#$00
		lda 	#0
		sec
		rts
		;
		;		Not TI or TI$
		;
_IVStandard:
		lda 	compilerStartHigh			; start scanning from here.
		sta 	zTemp0+1
		stz 	zTemp0

		.storage_access
_IVCheckLoop:
		lda 	(zTemp0) 					; finished ?
		beq  	_IVNotFound 				; if so, return with CC.
		;
		ldy 	#1 							; match ?
		lda 	(zTemp0),y
		cmp 	zTemp1
		bne	 	_IVNext
		iny
		lda 	(zTemp0),y
		cmp 	zTemp1+1
		beq 	_IVFound
_IVNext: 									; go to next
		clc
		lda 	zTemp0
		adc 	(zTemp0)
		sta 	zTemp0
		bcc 	_IVCheckLoop
		inc 	zTemp0+1
		bra 	_IVCheckLoop
		;
_IVFound:		
		ldy 	#3 							; get address into YX
		lda 	(zTemp0),y
		tax
		iny
		lda 	(zTemp0),y
		pha
		iny
		lda 	(zTemp0),y
		ply
		.storage_release
		sec
		rts

_IVNotFound:
		.storage_release
		ldx 	zTemp1 						; get variable name back
		ldy 	zTemp1+1
		clc
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		fixbranches.asm
;		Purpose:	Fix up GOTO and GOSUB commands
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Fix up GOTO and GOSUB, and VARSPACE
;
; ************************************************************************************************

FixBranches:
		lda 	#BLC_RESETOUT				; back to the start of the *object* code.
		jsr 	CallAPIHandler
_FBLoop:
		lda 	(objPtr) 					; get the next one.
		cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
		beq 	_FBFixGotoGosub
		cmp 	#PCD_CMD_GOSUB
		beq 	_FBFixGotoGosub
		cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
		beq 	_FBFixGotoGosub
		cmp 	#PCD_CMD_GOTOCMD_Z 
		beq 	_FBFixGotoGosub
		cmp 	#PCD_CMD_VARSPACE
		beq 	_FBFixVarSpace
_FBNext:		
		jsr 	MoveObjectForward 			; move forward in object code.
		bcc 	_FBLoop 					; not finished
_FBExit:		
		rts
;
;		Found GOTO/GOSUB - look it up in the line# table and fix it up.
;
_FBFixGotoGosub:
		ldy 	#1							; line number in YA
		lda 	(objPtr),y
		pha
		iny
		lda 	(objPtr),y
		tay
		pla
		jsr 	STRFindLine			 		; find where it is YA
		bcc 	_FBFFound 					; not found, so must be >
		pha
		lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
		cmp 	#PCD_CMD_GOTOCMD_Z
		bne 	_FBFFail
		pla

_FBFFound:		
		jsr 	STRMakeOffset 				; make it an offset from X:YA
		
		phy	 								; patch the GOTO/GOSUB
		ldy 	#1
		sta 	(objPtr),y
		iny
		pla
		sta 	(objPtr),y
		bra 	_FBNext

_FBFFail:
		ldy 	#2
		lda 	(objPtr),y
		sta 	currentLineNumber
		iny
		lda 	(objPtr),y
		sta 	currentLineNumber+1
		.error_line

;
;		Found VarSpace, fix up with free space after variables
;
_FBFixVarSpace:
		ldy 	#1
		lda 	freeVariableMemory
		sta 	(objPtr),y
		iny
		lda 	freeVariableMemory+1
		sta 	(objPtr),y
		bra 	_FBNext

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		for.asm
;		Purpose:	FOR compile
;		Created:	20th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Compile FOR command
;
;				Creates [Initial] Index! [Reference|Type] [Terminal] [Step] FOR
;
; ************************************************************************************************

CommandFOR: 
		;
		;		FOR [variable]
		;
		jsr 	GetNextNonSpace 			; first letter of index variable, should be.
		jsr 	CharIsAlpha 				; if not alpha , error
		bcc 	_CFFail
		jsr 	GetReferenceTerm 			; figure out the reference.

		pha 								; save type
		and 	#NSSTypeMask 				; check it is numeric
		cmp 	#NSSIFloat 					
		bne 	_CFFail
		;
		; 		= [Start]
		;
		phy 								; save reference on the stack
		phx
		lda 	#C64_EQUAL 					; check for equal.
		jsr 	CheckNextA
		jsr 	CompileExpressionAt0 		; initial value
		plx 								; get reference back.
		ply
		phy
		phx
		sec 								; set initial value.
		jsr 	GetSetVariable
		;
		;		Push reference on the stack, Int16 flag in Bit15
		;
		plx
		ply
		pla
		and 	#NSSIInt16 	
		beq 	_CFNotInt16
		tya
		ora 	#$80
		tay
_CFNotInt16:
		txa 								; reference in YA
		jsr 	PushIntegerYA
		;
		;		TO [End]
		;
		lda 	#C64_TO
		jsr 	CheckNextA
		jsr 	CompileExpressionAt0 		; terminal value
		and 	#NSSTypeMask 				; check it is numeric
		cmp 	#NSSIFloat 					
		bne 	_CFFail
		;
		;		Optional STEP [n]
		;
		jsr 	LookNextNonSpace 			; followed by STEP
		cmp 	#C64_STEP
		bne 	_CFNoStep
		;
		jsr 	GetNext 					; consume it.
		jsr 	CompileExpressionAt0 		; terminal value
		and 	#NSSTypeMask 				; check it is numeric
		cmp 	#NSSIFloat 					
		bne 	_CFFail
		bra 	_CFParametersDone
		;
_CFNoStep:
		lda 	#1 							; default STEP e.g. 1
		jsr 	PushIntegerA
_CFParametersDone:		
		lda 	#PCD_FOR  					; compile FOR word.
		jsr 	WriteCodeByte
		rts



_CFFail:
		.error_syntax

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		functions.asm
;		Purpose:	FNx code
;		Created:	1st May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										FN handler
;
; ************************************************************************************************

FNCompile:
		;
		;		Identify FNxx(
		;
		jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
		jsr 	ExtractVariableName 
		cpx 	#0
		bpl 	_FNError
		;
		txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
		and 	#$7F
		tax
		tya
		ora 	#$80
		tay
		;
		;		Check to see if it is defined.
		;
		jsr 	FindVariable				; does it already exist ?
		bcc 	_FNError 					; no.
		jsr 	STRMakeOffset 				; convert to a relative address.

		cmp 	#0 							; fix up.
		bne 	_FNNoBorrow
		dey
_FNNoBorrow:
		dec 	a

		phy 								; save location of routine on stack.
		pha
		phx
		;
		;		Handle <expression>)
		;
		jsr 	CompileExpressionAt0
		jsr 	CheckNextRParen
		;
		;		Compile routine call
		;
		lda 	#PCD_CMD_GOSUB
		jsr 	WriteCodeByte
		pla
		jsr 	WriteCodeByte
		pla
		jsr 	WriteCodeByte
		pla
		jsr 	WriteCodeByte

		clc
		rts

_FNError:
		.error_value
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		gendata.asm
;		Purpose:	Generation data files
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

	
; ************************************************************************************************
;
;			Generator tables. Apologies for messy way of including those for alt systems
;
; ************************************************************************************************

CommandTables:
;
;	This file is automatically generated.
;
;
;	GO     X:CommandGOAlt N
;
	.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
;
;	GOTO    X:CommandGOTO N
;
	.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
;
;	GOSUB    X:CommandGOSUB N
;
	.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
;
;	LET    X:CommandLET N
;
	.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
;
;	INPUT    X:CommandINPUT N
;
	.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
;
;	INPUT#    C:CommandINPUTStream N
;
	.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
;
;	PRINT    X:CommandPRINT N
;
	.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
;
;	PRINT#    C:CommandPRINT N
;
	.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
;
;	REM    X:CommandREM N
;
	.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
;
;	FOR    X:CommandFOR N
;
	.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
;
;	NEXT    X:CommandNEXT N
;
	.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
;
;	GET    X:CommandGET N
;
	.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
;
;	DATA    X:CommandDATA N
;
	.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
;
;	READ    X:CommandREAD N
;
	.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
;
;	DIM    X:CommandDIM N
;
	.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
;
;	DEF    X:CommandDEF N
;
	.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
;
;	IF     # X:CommandIF N
;
	.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
;
;	WAIT    #,# X:CommandWAIT N
;
	.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
;
;	ON     # T X:CommandON N
;
	.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
;
;	SYS    # T N
;
	.byte	$07,$9e,$00,$e2,37579 & $FF,37579 >> 8,$06
;
;	POKE    #,# T N
;
	.byte	$07,$97,$00,$ea,$e1,173,$06
;
;	RETURN    T N
;
	.byte	$06,$8e,$00,$10,152,$06
;
;	STOP    T N
;
	.byte	$07,$90,$00,$20,37323 & $FF,37323 >> 8,$06
;
;	END    T N
;
	.byte	$07,$80,$00,$20,33483 & $FF,33483 >> 8,$06
;
;	RESTORE   T N
;
	.byte	$07,$8c,$00,$20,37067 & $FF,37067 >> 8,$06
;
;	This file is automatically generated.
;
;
;	CMD    # X:CommandCMD N
;
	.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
;
;	OPEN    #,# X:CommandOPEN T N
;
	.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,199,$06
;
;	CLOSE    # T N
;
	.byte	$06,$a0,$00,$e1,196,$06
;
;	CLS    T N
;
	.byte	$07,$ce,$90,$20,44235 & $FF,44235 >> 8,$06
;
;	LOCATE    # X:OptionalParameterCompile T N
;
	.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44491 & $FF,44491 >> 8,$06
;
;	COLOR    # X:OptionalParameterCompile T N
;
	.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44747 & $FF,44747 >> 8,$06
;
;	SCREEN    # T N
;
	.byte	$06,$ce,$86,$e1,200,$06
;
;	VPOKE    #,#,# T N
;
	.byte	$08,$ce,$84,$ea,$ea,$e1,201,$06
;
;	SLEEP    # T N
;
	.byte	$07,$ce,$af,$e2,39115 & $FF,39115 >> 8,$06
;
;	MOUSE    # T N
;
	.byte	$07,$ce,$8c,$e2,36043 & $FF,36043 >> 8,$06
;
;	I2CPOKE   #,#,# T N
;
	.byte	$09,$ce,$ae,$ea,$ea,$e2,38347 & $FF,38347 >> 8,$06
;
;	PSET    #,#,# T N
;
	.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
;
;	LINE    #,#,#,#,# T N
;
	.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
;
;	RECT    #,#,#,#,# T N
;
	.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
;
;	FRAME    #,#,#,#,# T N
;
	.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
;
;	CHAR    #,#,#,$ T N
;
	.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
;
;	This file is automatically generated.
;
;
;	FMINIT       T N
;
	.byte	$07,$ce,$99,$20,39371 & $FF,39371 >> 8,$06
;
;	FMNOTE      #,# T N
;
	.byte	$08,$ce,$9a,$ea,$e2,39627 & $FF,39627 >> 8,$06
;
;	FMDRUM      #,# T N
;
	.byte	$08,$ce,$9b,$ea,$e2,39883 & $FF,39883 >> 8,$06
;
;	FMINST      #,# T N
;
	.byte	$08,$ce,$9c,$ea,$e2,40139 & $FF,40139 >> 8,$06
;
;	FMVIB       #,# T N
;
	.byte	$08,$ce,$9d,$ea,$e2,40395 & $FF,40395 >> 8,$06
;
;	FMFREQ      #,# T N
;
	.byte	$08,$ce,$9e,$ea,$e2,40651 & $FF,40651 >> 8,$06
;
;	FMVOL       #,# T N
;
	.byte	$08,$ce,$9f,$ea,$e2,40907 & $FF,40907 >> 8,$06
;
;	FMPAN       #,# T N
;
	.byte	$08,$ce,$a0,$ea,$e2,41163 & $FF,41163 >> 8,$06
;
;	FMPLAY      #,$ T N
;
	.byte	$08,$ce,$a1,$ea,$f2,41419 & $FF,41419 >> 8,$06
;
;	FMCHORD     #,$ T N
;
	.byte	$08,$ce,$a2,$ea,$f2,41675 & $FF,41675 >> 8,$06
;
;	FMPOKE      #,# T N
;
	.byte	$08,$ce,$a3,$ea,$e2,41931 & $FF,41931 >> 8,$06
;
;	PSGINIT      T N
;
	.byte	$07,$ce,$a4,$20,42187 & $FF,42187 >> 8,$06
;
;	PSGNOTE     #,# T N
;
	.byte	$08,$ce,$a5,$ea,$e2,42443 & $FF,42443 >> 8,$06
;
;	PSGVOL      #,# T N
;
	.byte	$08,$ce,$a6,$ea,$e2,42699 & $FF,42699 >> 8,$06
;
;	PSGWAV      #,# T N
;
	.byte	$08,$ce,$a7,$ea,$e2,42955 & $FF,42955 >> 8,$06
;
;	PSGFREQ     #,# T N
;
	.byte	$08,$ce,$a8,$ea,$e2,43211 & $FF,43211 >> 8,$06
;
;	PSGPAN      #,# T N
;
	.byte	$08,$ce,$a9,$ea,$e2,43467 & $FF,43467 >> 8,$06
;
;	PSGPLAY     #,$ T N
;
	.byte	$08,$ce,$aa,$ea,$f2,43723 & $FF,43723 >> 8,$06
;
;	PSGCHORD    #,$ T N
;
	.byte	$08,$ce,$ab,$ea,$f2,43979 & $FF,43979 >> 8,$06
		.byte 	0

UnaryTables:
;
;	This file is automatically generated.
;
;
;	SGN    (#) T N
;
	.byte	$07,$b4,$00,$8e,$91,183,$06
;
;	INT    (#) T N
;
	.byte	$08,$b5,$00,$8e,$92,33995 & $FF,33995 >> 8,$06
;
;	ABS    (#) T N
;
	.byte	$07,$b6,$00,$8e,$91,141,$06
;
;	USR    (#) T N
;
	.byte	$07,$b7,$00,$8e,$91,194,$06
;
;	FRE    (#) T N
;
	.byte	$07,$b8,$00,$8e,$91,150,$06
;
;	POS    (#) T N
;
	.byte	$07,$b9,$00,$8e,$91,174,$06
;
;	SQR    (#) T N
;
	.byte	$08,$ba,$00,$8e,$92,34251 & $FF,34251 >> 8,$06
;
;	RND    (#) T N
;
	.byte	$07,$bb,$00,$8e,$91,181,$06
;
;	LOG    (#) T N
;
	.byte	$08,$bc,$00,$8e,$92,34507 & $FF,34507 >> 8,$06
;
;	EXP    (#) T N
;
	.byte	$08,$bd,$00,$8e,$92,34763 & $FF,34763 >> 8,$06
;
;	COS    (#) T N
;
	.byte	$08,$be,$00,$8e,$92,35019 & $FF,35019 >> 8,$06
;
;	SIN    (#) T N
;
	.byte	$08,$bf,$00,$8e,$92,35275 & $FF,35275 >> 8,$06
;
;	TAN    (#) T N
;
	.byte	$08,$c0,$00,$8e,$92,35531 & $FF,35531 >> 8,$06
;
;	ATN    (#) T N
;
	.byte	$08,$c1,$00,$8e,$92,35787 & $FF,35787 >> 8,$06
;
;	PEEK    (#) T N
;
	.byte	$07,$c2,$00,$8e,$91,171,$06
;
;	LEN    ($) T N
;
	.byte	$07,$c3,$00,$8f,$91,162,$06
;
;	STR$    (#) T S
;
	.byte	$07,$c4,$00,$8e,$91,187,$07
;
;	VAL    ($) T N
;
	.byte	$07,$c5,$00,$8f,$91,195,$06
;
;	ASC    ($) T N
;
	.byte	$07,$c6,$00,$8f,$91,143,$06
;
;	CHR$    (#) T S
;
	.byte	$07,$c7,$00,$8e,$91,147,$07
;
;	LEFT$   ($,#) T S
;
	.byte	$08,$c8,$00,$8f,$ae,$91,188,$07
;
;	RIGHT$    ($,#) T S
;
	.byte	$08,$c9,$00,$8f,$ae,$91,189,$07
;
;	MID$   ($,# X:OptionalParameterCompile ) T S
;
	.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,190,$07
;
;	NOT    X:NotUnaryCompile N
;
	.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
;
;	FN     X:FNCompile N
;
	.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
;
;	PI     T N
;
	.byte	$06,$ff,$00,$10,172,$06
;
;	This file is automatically generated.
;
;
;	BIN$     (#) T S
;
	.byte	$07,$ce,$d6,$8e,$91,145,$07
;
;	HEX$     (#) T S
;
	.byte	$07,$ce,$d5,$8e,$91,158,$07
;
;	VPEEK    (#,#) T N
;
	.byte	$08,$ce,$d0,$8e,$ae,$91,202,$06
;
;	JOY    (#) T N
;
	.byte	$08,$ce,$d4,$8e,$92,33739 & $FF,33739 >> 8,$06
;
;	MB     T N
;
	.byte	$07,$ce,$d3,$20,36299 & $FF,36299 >> 8,$06
;
;	MX     T N
;
	.byte	$07,$ce,$d1,$20,36555 & $FF,36555 >> 8,$06
;
;	MY     T N
;
	.byte	$07,$ce,$d2,$20,36811 & $FF,36811 >> 8,$06
;
;	I2CPEEK   (#,#) T N
;
	.byte	$09,$ce,$d7,$8e,$ae,$92,38603 & $FF,38603 >> 8,$06
		.byte 	0

		.send  code		

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		generator.asm
;		Purpose:	Generation processor
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code
	
; ************************************************************************************************
;
;						Generator for data at YX, first token in A
;					  		CS succeed, A = type, CC = Fail.
;
; ************************************************************************************************

GeneratorProcess:
		stx 	zTemp0 						; save generation pointer in zTemp0
		sty 	zTemp0+1
		;
		sta 	zTemp1 						; first match token
		stz 	zTemp1+1
		;
		;		X16 shift of $CE
		;
		cmp 	#$CE 						; check if shift
		bne 	_GPNotShifted
		jsr 	GetNext 					; get the shifted token
		sta 	zTemp1+1 					; match CE xx
_GPNotShifted:
		;
		;		Find the generator entry.
		;		
_GPSearch:		
		lda 	(zTemp0) 					; reached end ?
		clc
		beq 	_GPExit
		;
		ldy 	#1 							; tokens match
		lda 	(zTemp0),y
		cmp 	zTemp1
		bne 	_GPNext

		lda 	zTemp1+1 					; 2nd token ?
		beq 	_GPFound

		iny 								; check match.
		cmp 	(zTemp0),y
		beq 	_GPFound
		;
_GPNext:	
		clc 								; follow to next
		lda 	zTemp0		
		adc 	(zTemp0)
		sta 	zTemp0
		bcc 	_GPSearch
		inc 	zTemp0+1
		bra 	_GPSearch
		;
_GPFound:	
		clc 								; skip to action bytes		
		lda 	zTemp0 						; <offset> <token lo> <token hi> first
		adc 	#3
		sta 	zTemp0
		bcc 	_GPNoCarry
		inc 	zTemp0+1
_GPNoCarry:
		;
		;		Main execution loop.
		;		
_GPLoop:
		jsr 	GeneratorExecute 			; execute one command
		bcc 	_GPLoop 					; go back if not completed.
		sec 								; return with CS.
_GPExit:
		rts

		.send  code		

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		genexec.asm
;		Purpose:	Generation executor
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code


; ************************************************************************************************
;
;						    Execute command pair at (zTemp0).
;					  	CS completed, A = type, CC = keep going.
;
; ************************************************************************************************

GeneratorExecute:
		jsr 	_GEFetchZTemp0 				; get next.
		pha 								; split into 2 nibbles
		lsr 	a
		lsr 	a
		lsr		a
		lsr 	a
		jsr 	_GEExecuteNibble 			; MSB first
		pla
		bcs 	_GEHaveCompleted
		jsr 	_GEExecuteNibble 			; LSB second
_GEHaveCompleted:		
		rts

; ------------------------------------------------------------------------------------------------
;										 Execute NIBL A
; ------------------------------------------------------------------------------------------------

_GEExecuteNibble:
		and 	#$0F
		asl 	a
		tax 	
		jmp 	(_GEExecuteVectors,x)

_GEExecuteVectors:
		.word 	_GEXNop 					; 0  (no operation)
		.word 	_GEXToken1 					; 1  (compile 1 byte token)
		.word 	_GEXToken2 					; 2  (compile 2 byte token)
		.word 	_GEXExecute 				; 3  (run arbitrary code)
		.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
		.word 	_GEXNop 					; 5
		.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
		.word 	_GEXExitString 				; 7  exit return string type
		.word 	_GEXLParam 					; 8  check ( follows
		.word 	_GEXRParam 					; 9  check ) follows
		.word 	_GEXComma					; A  check , follows
		.word 	_GEXNop 					; B
		.word 	_GEXNop 					; C
		.word 	_GEXNop 					; D  
		.word 	_GEXNumber 					; E  compile get any number
		.word 	_GEXString 					; F  compile get any string

; ------------------------------------------------------------------------------------------------
;									 No Operations / Unused
; ------------------------------------------------------------------------------------------------

_GEXNop:				
		clc
		rts

; ------------------------------------------------------------------------------------------------
;									Compile 1/2 byte tokens
; ------------------------------------------------------------------------------------------------

_GEXToken2:
		jsr 	_GEFetchZTemp0
		jsr 	WriteCodeByte
_GEXToken1:
		jsr 	_GEFetchZTemp0
		jsr 	WriteCodeByte
		clc
		rts

; ------------------------------------------------------------------------------------------------
;										Exit with types
; ------------------------------------------------------------------------------------------------

_GEXExitNumber:
		lda 	#NSSIFloat
		sec
		rts

_GEXExitString:
		lda 	#NSSString
		sec
		rts

; ------------------------------------------------------------------------------------------------
;								 Check various characters follow
; ------------------------------------------------------------------------------------------------

_GEXLParam:
		lda 	#"("
		bra 	_GEXCheck
_GEXRParam:
		lda 	#")"
		bra 	_GEXCheck
_GEXComma:
		lda 	#","
_GEXCheck:
		sta 	zTemp2 						; save match
		jsr 	GetNextNonSpace 			; get next skipping spaces
		cmp 	zTemp2 						; check matches.
		bne 	_GEXSyntax
		clc
		rts
_GEXSyntax:
		.error_syntax

; ------------------------------------------------------------------------------------------------
;								 		Fetch, various types.
; ------------------------------------------------------------------------------------------------

_GEXNumber: 	
		jsr 	GEXCompileExpression 		; compile expression
		and 	#NSSTypeMask
		cmp  	#NSSIFloat
		bne 	_GEXType 	
		clc
		rts

_GEXString: 	
		jsr 	GEXCompileExpression 		; compile expression
		and 	#NSSTypeMask
		cmp  	#NSSString
		bne 	_GEXType 	
		clc
		rts

_GEXType:
		.error_type

; ------------------------------------------------------------------------------------------------
;							Execute 6502 code with Channel Redirect
; ------------------------------------------------------------------------------------------------

_GEXChannelExec:
		jsr 	ChannelPrefix 				; set up default
		jsr 	_GEXExecute
		php
		jsr 	ChannelPostfix 				; replace default.
		plp
		rts
		.debug

; ------------------------------------------------------------------------------------------------
;										Execute 6502 code
; ------------------------------------------------------------------------------------------------

_GEXExecute:
		jsr 	_GEFetchZTemp0 				; get vector		
		sta 	zTemp2 		
		jsr 	_GEFetchZTemp0
		sta 	zTemp2+1 		

		ldx 	zTemp0 						; push generation exec on to stack for reentrancy
		phx
		ldx 	zTemp0+1
		phx

		jsr 	_GECallZTemp2 				; execute code

		plx 								; recover generation exec
		stx 	zTemp0+1
		plx
		stx 	zTemp0
		rts		

_GECallZTemp2:
		jmp 	(zTemp2)		

; ------------------------------------------------------------------------------------------------
;										Get the next byte.
; ------------------------------------------------------------------------------------------------

_GEFetchZTemp0:
		lda 	(zTemp0)
		inc 	zTemp0
		bne 	_GEFZ0Skip
		inc 	zTemp0+1
_GEFZ0Skip:
		rts		

; ------------------------------------------------------------------------------------------------
;								Compile expression preserve state
; ------------------------------------------------------------------------------------------------

GEXCompileExpression:
		ldx 	zTemp0 						; push generation exec on to stack for reentrancy
		phx
		ldx 	zTemp0+1
		phx
		jsr 	CompileExpressionAt0 		; compile expression.
		plx 								; recover generation exec
		stx 	zTemp0+1
		plx
		stx 	zTemp0
		rts		

; ************************************************************************************************
;
;									Channel Prefix code.
;
; ************************************************************************************************

ChannelPrefix:
		lda 	#PCD_GETCHANNEL				; set channel onto stack
		jsr 	WriteCodeByte
		jsr 	GEXCompileExpression 		; channel #
		and 	#NSSTypeMask
		cmp 	#NSSIFloat
		bne 	_CPXType
		jsr 	CheckNextComma 				; check , follows.
		lda 	#PCD_SETCHANNEL				; set channel
		jsr 	WriteCodeByte
		clc
		rts
_CPXType:
		.error_type

; ************************************************************************************************
;
;									Channel Prefix code.
;
; ************************************************************************************************

ChannelPostfix:
		lda 	#PCD_SETCHANNEL				; set channel from TOS.
		jsr 	WriteCodeByte
		clc
		rts

		.send  code		

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		gensupport.asm
;		Purpose:	Support functions for generation
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;		MID$ has a support function because it has different numbers of parameters.
;		e.g. MID$(a$,b,c) or MID$(a$,b)
;
; ************************************************************************************************

OptionalParameterCompile:
		jsr 	LookNextNonSpace 			; what follows.
		;
		cmp 	#","
		bne 	_MidDefault
		jsr 	GetNext 					; consume ,
		jsr 	CompileExpressionAt0
		and 	#NSSTypeMask
		cmp 	#NSSIFloat
		bne 	MidFailType
		bra 	_MidComplete
_MidDefault:
		lda 	#255 						; default of 255
		jsr 	PushIntegerA
_MidComplete:
		clc
		rts

MidFailType:
		.error_type

; ************************************************************************************************
;
;		NOT has a support function as its single expression parameter is done part way
;		up precedence
;
; ************************************************************************************************

NotUnaryCompile:
											; precedence of comparators
		lda 	PrecedenceTable+C64_EQUAL-C64_PLUS		
		jsr 	CompileExpressionAtA 		; evaluate at that level
		and 	#NSSTypeMask 				; check compile returns number.
		cmp 	#NSSIFloat
		bne 	MidFailType
		lda 	#PCD_NOT 					; and NOT it.
		jsr 	WriteCodeByte		
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		get.asm
;		Purpose:	Support functions.
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;											Code Reads
;
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Examine next character
;
; ************************************************************************************************

LookNext:
		lda 	(srcPtr) 
		rts

; ************************************************************************************************
;
;								Examine next non space character
;
; ************************************************************************************************		

LookNextNonSpace:
		lda 	(srcPtr)
		cmp		#' '
		beq 	_LNNSkip
		cmp 	#0
		rts
_LNNSkip:
		jsr 	GetNext
		bra 	LookNextNonSpace
				
; ************************************************************************************************
;
;										Get next character
;
; ************************************************************************************************

GetNext:
		lda 	(srcPtr) 					; get next
		inc 	srcPtr
		bne 	_GNSkip
		inc 	srcPtr+1
_GNSkip:		
		cmp 	#0
		rts
		
; ************************************************************************************************
;
;								  Get next non-space character
;
; ************************************************************************************************

GetNextNonSpace:
		jsr 	GetNext
		cmp 	#' '
		beq 	GetNextNonSpace
		cmp 	#0
		rts

; ************************************************************************************************
;
;						   Check if digit (CS = true, CC = false)
;
; ************************************************************************************************

CharIsDigit:
		cmp 	#"0"
		bcc 	CCFalse
		cmp 	#"9"+1
		bcs 	CCFalse
CCTrue:
		sec
		rts
CCFalse:
		clc
		rts

; ************************************************************************************************
;
;						   Check if alpha (CS = true, CC = false)
;
; ************************************************************************************************

CharIsAlpha:
		cmp 	#"A"
		bcc 	CCFalse
		cmp 	#"Z"+1
		bcs 	CCFalse
		bra 	CCTrue

; ************************************************************************************************
;
;				Convert to hex-style, e.g. 0-9 => 0-9, A-Z 10-35, CS true, CC false
;
; ************************************************************************************************

ConvertHexStyle:
		sec
		sbc 	#"0" 						; check in range 0-9 first
		bcc 	CCFalse
		cmp 	#9+1
		bcc 	CCTrue
		;
		sec 								; shift into hex space A=>0 Z=>25
		sbc 	#"A"-"0"
		bcc 	CCFalse
		cmp 	#26 						; past Z ?
		bcs 	CCFalse
		adc 	#10 						; make valid quasi-hex 0-35
		bra 	CCTrue

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		get.asm
;		Purpose:	Get from input
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Get input (also GET#)
;
; ************************************************************************************************

CommandGET:
		jsr 	LookNextNonSpace 			; # follows ?
		cmp 	#"#"
		bne 	CommandGetBody
		;
		jsr 	GetNext 					; consume #
		jsr 	ChannelPrefix 				; do it as GET#
		jsr 	CommandGetBody
		jsr 	ChannelPostfix
		rts

CommandGetBody:
		jsr 	GetNextNonSpace 			; get the first character
		jsr 	GetReferenceTerm 			; identify variable to assign to
		pha
		and 	#NSSTypeMask 				; check if it is a string
		cmp 	#NSSString
		bne 	_CGType

		lda 	#PCD_GET 					; compile GET
		jsr 	WriteCodeByte
		sec
		pla
		jsr		GetSetVariable
		rts

_CGType:
		.error_type

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		getname.asm
;		Purpose:	Get variable name
;		Created:	25th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;				  Extract a reference object name (variable, array, function)
;					  to XY. Error if failed. On entry A contains first
;
; ************************************************************************************************

		.section code

ExtractVariableName:
		jsr 	CharIsAlpha
		bcc 	_IVSyntax
		;
		;		One or two character variable ?
		;
		and 	#31 						; reduce first character to 5 bits
		sta 	zTemp1 						; we'll build it in zTemp1
		stz 	zTemp1+1
		;
		jsr 	LookNext 					; is there a second character ?
		jsr 	CharIsAlpha  				; must be alphanumeric 
		bcs 	_IVHasSecond
		jsr 	CharIsDigit
		bcc 	_IVCheckType
_IVHasSecond:
		and 	#63 						; 6 bit ASCII.
		sta 	zTemp1+1
_IVGetNextCheck:		
		jsr 	GetNext 					; consume it
		;
		;		Check for % $ postfix.
		;
_IVCheckType:
		jsr 	LookNext					; check if string follows.
		jsr 	CharIsAlpha
		bcs 	_IVGetNextCheck
		jsr 	CharIsDigit
		bcs 	_IVGetNextCheck

		ldx 	#NSSString
		cmp 	#"$"
		beq 	_IVHasType
		ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
		cmp 	#"%"
		bne 	_IVCheckArray
_IVHasType:
		txa 								; Or X into zTemp1
		ora 	zTemp1
		sta 	zTemp1		
		jsr 	GetNext 					; consume it
		;
		;		Check for ( postfix
		;
_IVCheckArray:
		jsr 	LookNext 					; check if array follows
		cmp 	#"("
		bne 	_IVNotArray
		lda 	zTemp1 						; set array bit
		ora 	#NSSArray
		sta 	zTemp1		
		jsr 	GetNext 					; consume it
_IVNotArray:		
		ldx 	zTemp1
		ldy 	zTemp1+1
		rts

_IVSyntax:
		.error_syntax
		
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		gosub.asm
;		Purpose:	Gosub/Return command
;		Created:	19th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											GOTO
;
; ************************************************************************************************

CommandGOSUB: 
		lda 	#PCD_CMD_GOSUB
		jsr 	CompileBranchCommand
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		goto.asm
;		Purpose:	Goto command
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											GO TO
;
; ************************************************************************************************

CommandGOAlt:
		lda 	#C64_TO 					; GO TO alternative
		jsr 	CheckNextA
		bra 	CommandGOTO

; ************************************************************************************************
;
;											GOTO
;
; ************************************************************************************************

CommandGOTO: 
		lda 	#PCD_CMD_GOTO
		jsr 	CompileBranchCommand
		rts

; ************************************************************************************************
;
;						Compile a branch (GOTO/GOSUB) with following line #
;
; ************************************************************************************************

CompileBranchCommand:
		jsr 	WriteCodeByte 				; write the command out.
		jsr 	GetNextNonSpace
		jsr 	ParseConstant 				; get constant into YA
		bcc 	_CBCSyntax

 				
		jsr 	WriteCodeByte				; and compile the actual line number
		tya
		jsr 	WriteCodeByte
		rts		

_CBCSyntax:
		.error_syntax

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		if.asm
;		Purpose:	If command
;		Created:	19th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											IF
;
; ************************************************************************************************

CommandIF: 		
		jsr 	LookNextNonSpace 			; what follows the tests ?
		cmp 	#C64_GOTO 					; IF .. GOTO
		beq 	_CIGoto
		;
		lda 	#C64_THEN 					; should be THEN
		jsr 	CheckNextA
		;
		jsr 	LookNextNonSpace 			; THEN <number>
		jsr 	CharIsDigit
		bcs 	_CIGoto2
		bra 	CompileGotoEOL

_CIGoto:	
		jsr 	GetNext 					
_CIGoto2:		
		lda 	#PCD_CMD_GOTOCMD_NZ
		jsr 	CompileBranchCommand
		rts
		
CompileGotoEOL: 							; compile GOTOZ <next line>
		lda 	#PCD_CMD_GOTOCMD_Z
		jsr 	WriteCodeByte
		jsr 	GetLineNumber 				; Get the current line number => YA
		inc 	a 							; and branch to +1
		bne 	_CGENoCarry
		iny
_CGENoCarry:		
		jsr 	WriteCodeByte
		tya
		jsr 	WriteCodeByte
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		input.asm
;		Purpose:	INPUT command
;		Created:	1st May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											INPUT
;
; ************************************************************************************************

CommandINPUT:
		jsr 	LookNextNonSpace 			; check for "
		cmp 	#'"'
		bne 	CommandINPUTStream
		jsr 	CompileExpressionAt0
		.keyword PCD_PRINTCMD_S
		lda 	#","
		jsr 	CheckNextComma
CommandINPUTStream:
		.keyword PCD_INPUTCMD_START 		; new INPUT.
		ldx 	#PCD_INPUT 					; do READ with Data from INPUT
		ldy 	#PCD_INPUTDOLLAR
		jmp 	CommandReadInputCommon

		.send code

; ************************************************************************************************
;
;		Notes:
;			INPUT has an optional prompt ; INPUT# skips this code <string> print.s
;			Do the actual input.
;			Ignore blank lines.
; 			Behaves like READ in that it will grab data read , store keep going until have
; 			everything, use of , and "" etc.
;
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		let.asm
;		Purpose:	Assignment statement
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Assignment statement
;
; ************************************************************************************************

CommandLET:
		jsr 	GetNextNonSpace 			; get the first character
CommandLETHaveFirst:
		jsr 	GetReferenceTerm 			; identify variable to assign to
		phx 								; save target on the stack.
		phy
		pha
		lda 	#C64_EQUAL 					; check next is =
		jsr 	CheckNextA
		jsr 	CompileExpressionAt0 		; evaluate the RHS.

		sta 	zTemp0 						; save type returned
		pla 								; get type of assignment
		pha
		eor 	zTemp0 						; compare using EOR
		and 	#NSSTypeMask 				; so we can mask type as we only need n/s
		bne 	_CLType

		pla 								; restore and compile save code
		ply
		plx

		cpy 	#$C0 						; is it TI$ = "xxxxx"
		beq 	_CLTIString
		sec
		jsr		GetSetVariable
		rts

_CLTIString:
		.keyword PCD_TIDOLLARCMD_WRITE
		rts
		
_CLType:
		.error_type

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		mark_line.asm
;		Purpose:	Line Number Tracking
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Store current position, line YA
;
; ************************************************************************************************

STRMarkLine:
		pha
		sec 								; allocate 4 bytes (line #,address)
		lda 	lineNumberTable 			; and copy to zTemp0
		sbc 	#4
		sta 	lineNumberTable
		sta 	zTemp0
		lda 	lineNumberTable+1
		sbc 	#0
		sta 	lineNumberTable+1
		sta 	zTemp0+1

		.storage_access
		pla
		sta 	(zTemp0) 					; line # save it in +0,+1
		tya
		ldy 	#1
		sta 	(zTemp0),y
		;
		lda 	objPtr 						; save current address in +2,+3
		iny
		sta 	(zTemp0),y
		lda 	objPtr+1
		iny
		sta 	(zTemp0),y

		.storage_release
		rts

; ************************************************************************************************
;
;				Line number YA - find in table, return address YA 
;				
;				If FOUND: of the matching line, with Carry Clear.
;				If NOT FOUND : of the previous line (e.g. next code line), with Carry Set.
;
; ************************************************************************************************

STRFindLine:
		.storage_access

		sta 	zTemp0 						; zTemp0 line number being searched
		sty 	zTemp0+1
		
		lda 	compilerEndHigh 			; work backwards through table
		sta 	zTemp1+1
		stz 	zTemp1

_STRSearch:
		jsr 	_STRPrevLine 				; look at previous record.

		ldy 	#1
		lda 	(zTemp1) 					; check table line # >= target
		cmp 	zTemp0
		lda 	(zTemp1),y
		sbc 	zTemp0+1
		bcs 	_STRFound 					; >=
_STRNext: 									; next table entry.
		ldy 	#1 							; should not be required !
		lda 	(zTemp1),y
		cmp 	#$FF
		bne 	_STRSearch
		.error_internal

_STRFound:
		lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
		eor 	zTemp0
		bne 	_STRDifferent
		lda 	(zTemp1)
		eor 	zTemp0
		beq 	_STROut 					; if zero, exit with A = 0 and correct line.

_STRDifferent:
		lda 	#$FF 						
_STROut:
		clc  								; set carry if different, e.g. > rather than >=
		adc 	#255 				
		php
		iny 								; address into YA
		lda 	(zTemp1),y
		pha
		iny
		lda 	(zTemp1),y
		tay
		pla	
		.storage_release
		plp	
		rts

_STRPrevLine:
		sec 								; move backwards one entry.
		lda 	zTemp1
		sbc 	#4
		sta 	zTemp1
		lda 	zTemp1+1
		sbc 	#0
		sta 	zTemp1+1
		rts
; ************************************************************************************************
;
;								Make position X:YA to Offset X:YA
;
; ************************************************************************************************

STRMakeOffset:
		clc 								; borrow 1
		sbc 	objPtr
		pha
		tya
		sbc 	objPtr+1
		tay
		pla
		rts
		
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		nex.asm
;		Purpose:	NEXT compile
;		Created:	20th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Compile NEXT command
;
;								   Creates [Reference|$FFFF] NEXT
;
; ************************************************************************************************

CommandNEXT: 
		;
		;		NEXT [variable]
		;
		jsr 	LookNextNonSpace 			; first letter of index variable, should be.
		jsr 	CharIsAlpha 				; if not alpha , error
		bcc 	_CNNoReferenceGiven
		jsr 	GetNext
		jsr 	GetReferenceTerm 			; figure out the reference.
		txa 								; reference in YA
		jsr 	PushIntegerYA 				; write it out.
		bra 	_CNParametersDone
_CNNoReferenceGiven:
		lda 	#255 						; write out -1 no
		tay
		jsr 	PushIntegerYA 				; write it out.
_CNParametersDone:
		lda 	#PCD_NEXT  					; compile FOR word.
		jsr 	WriteCodeByte

		jsr 	LookNextNonSpace 			; look for , 
		cmp 	#","
		bne 	_CNExit
		jsr 	GetNext 					; consume ,
		bra 	CommandNEXT 				; and go round.

_CNExit:
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		on.asm
;		Purpose:	ON compiler
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											Compile ON
;
; ************************************************************************************************

CommandON:
		jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
		pha 								; save on stack

		ldx 	#PCD_CMD_GOTO
		cmp 	#C64_GOTO 					; must be GOTO/GOSUB
		beq 	_COCreateLoop
		ldx 	#PCD_CMD_GOSUB
		cmp 	#C64_GOSUB
		beq 	_COCreateLoop
		.error_syntax

_COCreateLoop:
		txa 								; compile a goto/gosub somewhere
		phx
		jsr 	CompileBranchCommand		
		plx
		jsr 	LookNextNonSpace			; ',' follows
		cmp 	#"," 						
		bne 	_COComplete 				; if so, more line numbers
		lda 	#PCD_MOREON 				; ON extends.
		jsr 	WriteCodeByte
		jsr 	GetNext
		bra 	_COCreateLoop

_COComplete:
		pla 								; throw GOTO/GOSUB
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		parsenumber.asm
;		Purpose:	Parse numeric constant
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;				Parse numeric constant into stack level 0, first char is in A
;				   Return CS if legitimate 16 bit +ve int with value in YA
;
; ************************************************************************************************

ParseConstant:
		ldx 	#0 
		jsr 	FloatEncodeStart 			; send first
_ParseLoop:
		jsr 	LookNext 					; send subsequent
		jsr 	FloatEncodeContinue
		bcc 	_ParseDone
		jsr 	GetNext 					; consume it
		bra 	_ParseLoop

_ParseDone:
		lda 	NSStatus,x 					; shouldn't be -ve ....
		and 	#$80
		ora 	NSExponent,x 				; 16 bit int check
		ora 	NSMantissa2,x
		ora 	NSMantissa3,x
		clc
		bne 	_ParseExit 					; exit with CC if need float to compile

		lda 	NSMantissa0,x 				; read into YA.
		ldy		NSMantissa1,x
		sec
_ParseExit:		
		rts		





		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		print.asm
;		Purpose:	Print compilation
;		Created:	19th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						  					Print Command
;
; ************************************************************************************************

CommandPRINT:
		jsr 	LookNextNonSpace			; what follows ?
		cmp 	#";" 						; semicolon, check end of command
		beq 	_CPCheckEnd
		cmp 	#"," 						; , TAB and check end of command
		beq 	_CPTabCheckEnd	
		jsr 	_CPAtEnd 					; check for : and EOL
		bcs 	_CPExitCR 					; exit with CR
		;
		;		TODO check TAB( and SPC(
		;
		jsr 	CompileExpressionAt0 		; so it is something to print
		ldx 	#PCD_PRINTCMD_S
		and 	#NSSString 					; if string
		bne 	_CPOut
		ldx 	#PCD_PRINTCMD_N
_CPOut:
		txa 								; print that thing
		jsr 	WriteCodeByte		
		bra 	CommandPRINT 				; and loop round/
		;
		;		, comes here
		;
_CPTabCheckEnd:
		lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
		jsr 	WriteCodeByte
		;
		;		; comes here and ,  - if end command after no CR.
		;
_CPCheckEnd:
		jsr 	GetNext 					; consume it.
		jsr 	LookNextNonSpace 			; what follows ?
		jsr 	_CPAtEnd 					; reached end
		bcc 	CommandPRINT 				; no, loop back
		rts
		;
		;		: and EOL come here.
		;
_CPExitCR:
		lda 	#13 						; code to print CR
		jsr 	PushIntegerA		
		lda 	#PCD_PRINTCMD_CHR
		jsr 	WriteCodeByte
		rts

;
;		Check ending character, is it EOS or :
;
_CPAtEnd:
		cmp 	#0
		beq 	_CPIsEnd
		cmp 	#":"
		beq 	_CPIsEnd
		clc
		rts
_CPIsEnd:
		sec
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		read.asm
;		Purpose:	Compile READ Statements
;		Created:	22nd April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Compile a READ
;
; ************************************************************************************************

CommandREAD:
		ldx 	#PCD_READ
		ldy 	#PCD_READDOLLAR
;
;		Code shared by READ and INPUT
;
CommandReadInputCommon:
		stx 	numberPCode
		sty 	stringPCode
_CRLoop:				
		jsr 	GetNextNonSpace 			; first char of identifier
		jsr 	CharIsAlpha 				; check A-Z
		bcc 	_CRSyntax
		jsr 	GetReferenceTerm 			; get the variable.
		pha 								; save type.

		and 	#NSSTypeMask 				; is it a string ?
		cmp 	#NSSString
		beq 	_CRString
		lda 	numberPCode 				; output read/input
		bra 	_CRHaveType
_CRString:		
		lda 	stringPCode					; output read$/input$
_CRHaveType:		
		jsr 	WriteCodeByte 				; so we have one typed data item.
		pla 								; restore type
		sec  								; write update code.
		jsr 	GetSetVariable
		jsr 	LookNextNonSpace 			; , follows ?
		cmp 	#","
		bne 	_CRExit 					; if not, end of READ.
		jsr 	GetNext 					; consume comma
		bra 	_CRLoop 					; keep going
_CRExit:		
		rts		
_CRSyntax:
		.error_syntax

		.send code

		.section storage
numberPCode:	
		.fill 	1
stringPCode:
		.fill 	1
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		readwrite.asm
;		Purpose:	Generate code to read/write variables
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;					On entry YX is the address and A the type data (bits 7..5)
;						CS => generate write code, CC => generate read code
;
; ************************************************************************************************

GetSetVariable:
		php 								; save direction on stack
		cpy 	#$00
		bmi 	_GSVReadWriteSpecial
		cmp 	#$00
		bmi 	_GSVArray
		;
		; 		64-79 is float, 80-95 is integer, 96-111 is string. So we multiply the
		;		type bits 5 & 6 byte 16 - but they are already multiplied by 32, so
		;
		and 	#NSSTypeMask+NSSIInt16 		; get type bits
		lsr 	a 							; divide by 2
		ora 	#64 						; and set bit 6.
		;
		plp
		bcc 	_GSVNotWrite
		ora 	#8  						; set bit 3 if it is write.
_GSVNotWrite:
		sta 	zTemp0
		;
		tya 	 							; shift X/Y right as the address stored is halved
		lsr 	a
		tay 	
		txa 
		ror 	a
		tax
		;
		tya 								; lower 3 bits of YX are ORed into the opcode
		ora 	zTemp0 						; which is the first byte of the opcode
		jsr 	WriteCodeByte
		;
		txa 								; and the lower 8 bits of YX are the second byte
		jsr 	WriteCodeByte
		rts
		;
		;		Special read/writes
		;
_GSVReadWriteSpecial:
		;
		;		TODO: TI TI$ code missing		
		;
		plp
		bcs 	_GSVSyntax		
		;
		;		Handle clock read
		;
		cpy 	#$C0 						; TI$ ?
		beq 	_GSVRWString
		.keyword PCD_TI
		rts
_GSVRWString:
		.keyword PCD_TIDOLLAR
		rts		

_GSVSyntax:
		.error_syntax
		;
		;		For arrays use the indirection @ %@ $@ ! %! $!
		;
_GSVArray:
		and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
		lsr 	a		 					; shift from 5,6 to 0,1
		lsr 	a		
		lsr 	a		
		lsr 	a		
		lsr 	a				
		plp 								; if writing array then set bit 2.
		bcc 	_GSVANotWrite
		ora 	#4
_GSVANotWrite:		
		ora 	#$78 						; make a valid opcode.
		jsr 	WriteCodeByte 				; and write it out
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		refterm.asm
;		Purpose:	Get reference term
;		Created:	25th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;		On entry, A contains the first character.  Extract the variable name and locate it
;		creating if necessary, returning offset in YX, type in A.
;
; ************************************************************************************************

		.section code

GetReferenceTerm:
		jsr 	ExtractVariableName 		; get name & type info
		cpx 	#0 							; check for array handler
		bmi 	_GRTArray
		phx 								; save type on stack
		jsr 	FindVariable 				; find it
		bcs 	_GRTNoCreate 				; create if required.
		jsr 	CreateVariableRecord 		; create a variable.
		jsr 	AllocateBytesForType 		; allocate memory for it
_GRTNoCreate:		
		pla 								; get type back, strip out type information.
		and 	#NSSTypeMask+NSSIInt16
		rts		
	
_GRTArray:
		phx 								; save type information 		
		jsr 	FindVariable 				; read its data, the base address in YX
		bcc 	_GRTUndeclared 				; undeclared array.
		phx 								; save base address
		phy
		jsr 	OutputIndexGroup 			; create an index group and generate them
		ply 								; get the array base address into YX
		plx
		lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
		clc
		jsr 	GetSetVariable 				; load the address of the array structure.
		.keyword PCD_ARRAY 					; convert that to an offset.

		pla 								; and the type data into A
		and 	#NSSTypeMask+NSSIInt16
		ora 	#$80 						; with the array flag set.
		rts		

_GRTUndeclared:
		.error_undeclared

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		rem.asm
;		Purpose:	Handle remark (ignore to EOL)
;		Created:	20th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								REM consumes the rest of the line.
;
; ************************************************************************************************

CommandREM: 
		jsr 	LookNext
		beq 	_CRExit
		jsr 	GetNext
		bra 	CommandREM
_CRExit:		
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		reset.asm
;		Purpose:	Reset information storage
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Reset the storage (variables,line#)
;
; ************************************************************************************************

STRReset:

		lda	 	compilerStartHigh 			; set up the two table pointers
		sta 	variableListEnd+1
		stz 	variableListEnd

		lda 	compilerEndHigh
		sta 	lineNumberTable+1
		stz 	lineNumberTable

		.storage_access 					; clear the head of the work area list.

		lda 	variableListEnd
		sta 	zTemp0+1
		stz 	zTemp0
		lda 	#0
		sta 	(zTemp0)

		.storage_release
		.set16 freeVariableMemory,0 		; clear the free variable memory record.
		rts
		.send code

		.section storage
lineNumberTable:							; line number table, works down.
		.fill 	2		
variableListEnd:							; known variables, works up.
		.fill 	2	
freeVariableMemory: 						; next free memory slot
		.fill 	2			
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		term.asm
;		Purpose:	Compile Code to Evaluate a term
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;			Compile code to evaluate a term. Will return in A, bits 6,5 the type of that
;			term which will either be 00 (float/int16) or 10 (string).
;
;			Terms can be :
; 				[A-Z][A-Z0-9]* 	variable/array - a reference is obtained, and the code to push this generated.
;				[0-9.]* 		numeric decimal constant
;				$[0-9A-F]* 		hexadecimal integer constant
;				%[0-1]* 		binary integer constant
;				".*?"			string constant
;				- <Term> 		A negated term (must be integer/float)
;				<Unary Token>	A unary function
;				(<expression>)	An expression.
;
; ************************************************************************************************

CompileTerm:
		jsr 	GetNextNonSpace 			; get first non space character.
		bmi 	_CTUnaryFunctions

		jsr 	CharIsDigit 				; found a number
		bcs 	_CTDigit
		cmp 	#"."
		beq 	_CTDigit

		cmp 	#'"' 						; found a string ?
		beq 	_CTString

		cmp 	#"%"						; binary or hexadecimal ?
		beq 	_CTOtherBase
		cmp 	#"$"
		beq 	_CTOtherBase

		cmp 	#"(" 						; check parenthesis
		beq 	_CTBrackets

		cmp 	#"A" 						; check variable/array ?
		bcc 	_CTSyntax
		cmp 	#"Z"+1
		bcs 	_CTSyntax

		jsr 	GetReferenceTerm 			; figure out what it is.
		pha 								; save type on stack
		clc 								; read it
		jsr 	GetSetVariable 			
		pla
		and 	#NSSTypeMask 				; reduce to basic type
		rts	

_CTSyntax:
		.error_syntax
		;
		;		Handle parenthesis
		;
_CTBrackets:
		jsr 	CompileExpressionAt0		
		pha
		jsr 	CheckNextRParen
		pla
		rts
		;
		;		Handle other base
		;
_CTOtherBase:
		jsr 	InlineNonDecimal 			; non decimal constant handler		
		lda 	#NSSIFloat					; return a iFloat32 integer
		rts
		;
		;		Compile a number
		;
_CTDigit:			
		jsr 	ParseConstant 				; parse out an number, first is in A already.
		bcc	 	_CTFloat 					; have a float or long int.
		jsr 	PushIntegerYA 				; code to push on stack
		lda 	#NSSIFloat					; return a iFloat32 integer
		rts
_CTFloat:
		jsr 	PushFloatCommand			; code to push float
		lda 	#NSSIFloat 					; return a iFloat32
		rts		
		;
		;		Compile a string
		;
_CTString:
		jsr 	BufferClear 				; copy it to the buffer
_CTStringLoop:
		jsr 	LookNext 					; reached EOL/EOS
		beq 	_CTSyntax
		cmp 	#'"'
		beq 	_CTStringDone
		;
		jsr 	BufferWrite 				; write and consume
		jsr 	GetNext
		bra 	_CTStringLoop
_CTStringDone:
		jsr 	GetNext 					; consume closing quote.
		lda 	#PCD_CMD_STRING 			; output command and buffer
		jsr 	WriteCodeByte
		jsr 	BufferOutput
		lda 	#NSSString 					; string type
		rts		
		;
		;		Handle unary functions and negation, as - is a C64 token
		;
_CTUnaryFunctions:		
		cmp 	#C64_MINUS 					; negation of term.
		beq 	_CTNegation

		ldx 	#UnaryTables & $FF 			; check vs unary tables.
		ldy 	#UnaryTables >> 8
		jsr 	GeneratorProcess
		bcc		_CTSyntax 	
		rts
		;
		;		Negate a number
		;	
_CTNegation:
		jsr 	CompileTerm 				; compile a term.
		pha
		and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
		cmp 	#NSSIFloat
		bne 	_CTType 					; error
		lda 	#PCD_NEGATE 				; compile negate
		jsr 	WriteCodeByte		
		pla 								; return original type.
		rts
_CTType:
		.error_type		
		
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		wait.asm
;		Purpose:	Handle Wait (optional parameter)
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										WAIT a,b [already done]
;
; ************************************************************************************************

CommandWAIT: 
		jsr 	LookNextNonSpace
		cmp 	#","
		beq 	_CWThirdParameter
		lda 	#0
		jsr 	PushIntegerA
_CWExit:		
		.keyword PCD_WAIT
		rts

_CWThirdParameter:
		jsr 	GetNext
		jsr 	CompileExpressionAtA
		and 	#NSSTypeMask
		cmp 	#NSSIFloat
		beq 	_CWExit
		.error_type

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_cmd.asm
;		Purpose:	CMD command
;		Created:	24th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											CMD command
;
; ************************************************************************************************

CommandCMD:
		lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
		jsr 	WriteCodeByte
		jsr 	LookNextNonSpace 			; followed by a , ?
		cmp 	#","
		bne 	_CCMDExit
		jsr 	GetNext 					; consume comma.
		jsr 	CommandPRINT 				; do the print code
_CCMDExit:
		rts		
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_open.asm
;		Purpose:	OPEN command
;		Created:	2nd May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						OPEN command - first 2 are already on the stack.
;
;		supports 	OPEN #,#
;					OPEN #,#,#
;					OPEN #,#,$
;					OPEN #,#,#,$
;
;		Adds dummies so whatever there are three integers and a string compiled.
;
; ************************************************************************************************

CommandOPEN:
		jsr 	LookNextNonSpace 			; followed by a , ?
		cmp 	#","
		bne 	_COTwoDefaults
		jsr 	GetNext 					; consume comma
		jsr 	CompileExpressionAt0 		; what follows could be text or number.
		and 	#NSSString 					; if a number want a string to follow
		beq 	_COThreeIntegers
		;
		;		n,n,$
		;
		lda 	#0		 					; so we have n,n,$,0 so swap !
		jsr 	PushIntegerA
		.keyword PCD_SWAP
		rts
		;
		;		Two numeric values, add default 0 and empty string.
		;
_COTwoDefaults:
		lda 	#0
		jsr 	PushIntegerA
_COCompileNullString:
		.keyword PCD_CMD_STRING
		lda 	#0
		jsr 	WriteCodeByte
		jsr 	WriteCodeByte
		rts		
		;
		;		Full constants e.g. 1,8,2 possibly no file name
		;
_COThreeIntegers:		
		jsr 	LookNextNonSpace 			; is there a , 
		cmp 	#","
		bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
		jsr 	GetNext
		jsr 	CompileExpressionAt0 		; should be a filename
		and 	#NSSString
		beq 	_COType
		rts
_COType:
		.error_type		
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
