;
;	This file is automatically generated
;
;
;	This file is automatically generated.
;
C64_END                  = $80 ; $80 end
C64_FOR                  = $81 ; $81 for
C64_NEXT                 = $82 ; $82 next
C64_DATA                 = $83 ; $83 data
C64_INPUTHASH            = $84 ; $84 input#
C64_INPUT                = $85 ; $85 input
C64_DIM                  = $86 ; $86 dim
C64_READ                 = $87 ; $87 read
C64_LET                  = $88 ; $88 let
C64_GOTO                 = $89 ; $89 goto
C64_RUN                  = $8a ; $8a run
C64_IF                   = $8b ; $8b if
C64_RESTORE              = $8c ; $8c restore
C64_GOSUB                = $8d ; $8d gosub
C64_RETURN               = $8e ; $8e return
C64_REM                  = $8f ; $8f rem
C64_STOP                 = $90 ; $90 stop
C64_ON                   = $91 ; $91 on
C64_WAIT                 = $92 ; $92 wait
C64_LOAD                 = $93 ; $93 load
C64_SAVE                 = $94 ; $94 save
C64_VERIFY               = $95 ; $95 verify
C64_DEF                  = $96 ; $96 def
C64_POKE                 = $97 ; $97 poke
C64_PRINTHASH            = $98 ; $98 print#
C64_PRINT                = $99 ; $99 print
C64_CONT                 = $9a ; $9a cont
C64_LIST                 = $9b ; $9b list
C64_CLR                  = $9c ; $9c clr
C64_CMD                  = $9d ; $9d cmd
C64_SYS                  = $9e ; $9e sys
C64_OPEN                 = $9f ; $9f open
C64_CLOSE                = $a0 ; $a0 close
C64_GET                  = $a1 ; $a1 get
C64_NEW                  = $a2 ; $a2 new
C64_TABLB                = $a3 ; $a3 tab(
C64_TO                   = $a4 ; $a4 to
C64_FN                   = $a5 ; $a5 fn
C64_SPCLB                = $a6 ; $a6 spc(
C64_THEN                 = $a7 ; $a7 then
C64_NOT                  = $a8 ; $a8 not
C64_STEP                 = $a9 ; $a9 step
C64_PLUS                 = $aa ; $aa +
C64_MINUS                = $ab ; $ab -
C64_TIMES                = $ac ; $ac *
C64_DIVIDE               = $ad ; $ad /
C64_POWER                = $ae ; $ae ^
C64_AND                  = $af ; $af and
C64_OR                   = $b0 ; $b0 or
C64_GREATER              = $b1 ; $b1 >
C64_EQUAL                = $b2 ; $b2 =
C64_LESS                 = $b3 ; $b3 <
C64_SGN                  = $b4 ; $b4 sgn
C64_INT                  = $b5 ; $b5 int
C64_ABS                  = $b6 ; $b6 abs
C64_USR                  = $b7 ; $b7 usr
C64_FRE                  = $b8 ; $b8 fre
C64_POS                  = $b9 ; $b9 pos
C64_SQR                  = $ba ; $ba sqr
C64_RND                  = $bb ; $bb rnd
C64_LOG                  = $bc ; $bc log
C64_EXP                  = $bd ; $bd exp
C64_COS                  = $be ; $be cos
C64_SIN                  = $bf ; $bf sin
C64_TAN                  = $c0 ; $c0 tan
C64_ATN                  = $c1 ; $c1 atn
C64_PEEK                 = $c2 ; $c2 peek
C64_LEN                  = $c3 ; $c3 len
C64_STRDOLLAR            = $c4 ; $c4 str$
C64_VAL                  = $c5 ; $c5 val
C64_ASC                  = $c6 ; $c6 asc
C64_CHRDOLLAR            = $c7 ; $c7 chr$
C64_LEFTDOLLAR           = $c8 ; $c8 left$
C64_RIGHTDOLLAR          = $c9 ; $c9 right$
C64_MIDDOLLAR            = $ca ; $ca mid$
C64_GO                   = $cb ; $cb go
C64_MON                  = $ce80 ; $ce80 mon
C64_DOS                  = $ce81 ; $ce81 dos
C64_OLD                  = $ce82 ; $ce82 old
C64_GEOS                 = $ce83 ; $ce83 geos
C64_VPOKE                = $ce84 ; $ce84 vpoke
C64_VLOAD                = $ce85 ; $ce85 vload
C64_SCREEN               = $ce86 ; $ce86 screen
C64_PSET                 = $ce87 ; $ce87 pset
C64_LINE                 = $ce88 ; $ce88 line
C64_FRAME                = $ce89 ; $ce89 frame
C64_RECT                 = $ce8a ; $ce8a rect
C64_CHAR                 = $ce8b ; $ce8b char
C64_MOUSE                = $ce8c ; $ce8c mouse
C64_COLOR                = $ce8d ; $ce8d color
C64_TEST                 = $ce8e ; $ce8e test
C64_RESET                = $ce8f ; $ce8f reset
C64_CLS                  = $ce90 ; $ce90 cls
C64_CODEX                = $ce91 ; $ce91 codex
C64_LOCATE               = $ce92 ; $ce92 locate
C64_BOOT                 = $ce93 ; $ce93 boot
C64_KEYMAP               = $ce94 ; $ce94 keymap
C64_BLOAD                = $ce95 ; $ce95 bload
C64_BVLOAD               = $ce96 ; $ce96 bvload
C64_BVERIFY              = $ce97 ; $ce97 bverify
C64_BANK                 = $ce98 ; $ce98 bank
C64_FMINIT               = $ce99 ; $ce99 fminit
C64_FMNOTE               = $ce9a ; $ce9a fmnote
C64_FMDRUM               = $ce9b ; $ce9b fmdrum
C64_FMINST               = $ce9c ; $ce9c fminst
C64_FMVIB                = $ce9d ; $ce9d fmvib
C64_FMFREQ               = $ce9e ; $ce9e fmfreq
C64_FMVOL                = $ce9f ; $ce9f fmvol
C64_FMPAN                = $cea0 ; $cea0 fmpan
C64_FMPLAY               = $cea1 ; $cea1 fmplay
C64_FMCHORD              = $cea2 ; $cea2 fmchord
C64_FMPOKE               = $cea3 ; $cea3 fmpoke
C64_PSGINIT              = $cea4 ; $cea4 psginit
C64_PSGNOTE              = $cea5 ; $cea5 psgnote
C64_PSGVOL               = $cea6 ; $cea6 psgvol
C64_PSGWAV               = $cea7 ; $cea7 psgwav
C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
C64_PSGPAN               = $cea9 ; $cea9 psgpan
C64_PSGPLAY              = $ceaa ; $ceaa psgplay
C64_PSGCHORD             = $ceab ; $ceab psgchord
C64_REBOOT               = $ceac ; $ceac reboot
C64_POWEROFF             = $cead ; $cead poweroff
C64_I2CPOKE              = $ceae ; $ceae i2cpoke
C64_SLEEP                = $ceaf ; $ceaf sleep
C64_BSAVE                = $ceb0 ; $ceb0 bsave
C64_MENU                 = $ceb1 ; $ceb1 menu
C64_REN                  = $ceb2 ; $ceb2 ren
C64_LINPUT               = $ceb3 ; $ceb3 linput
C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
C64_HELP                 = $ceb6 ; $ceb6 help
C64_VPEEK                = $ced0 ; $ced0 vpeek
C64_MX                   = $ced1 ; $ced1 mx
C64_MY                   = $ced2 ; $ced2 my
C64_MB                   = $ced3 ; $ced3 mb
C64_JOY                  = $ced4 ; $ced4 joy
C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
C64_BINDOLLAR            = $ced6 ; $ced6 bin$
C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
C64_POINTER              = $ced8 ; $ced8 pointer
C64_STRPTR               = $ced9 ; $ced9 strptr
C64_RPTDOLLAR            = $ceda ; $ceda rpt$
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		data.inc
;		Purpose:	Common Data
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Mandatory Zero page code
;
; ************************************************************************************************

		.section zeropage
srcPtr: 									; pointer in source buffer
		.fill 	2		
		.send zeropage


; ************************************************************************************************
;
;										Non Zero Page Data
;
; ************************************************************************************************

		.section storage
sourceBuffer: 								; current input line.
		.fill 	256		
currentLineNumber:							; current line number.
		.fill 	2		
		.send 	storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

;
;	This file is automatically generated.
;
error_range .macro
	jmp	ErrorV_range
	.endm
error_value .macro
	jmp	ErrorV_value
	.endm
error_syntax .macro
	jmp	ErrorV_syntax
	.endm
error_type .macro
	jmp	ErrorV_type
	.endm
error_unimplemented .macro
	jmp	ErrorV_unimplemented
	.endm
error_assert .macro
	jmp	ErrorV_assert
	.endm
error_line .macro
	jmp	ErrorV_line
	.endm
error_internal .macro
	jmp	ErrorV_internal
	.endm
error_divzero .macro
	jmp	ErrorV_divzero
	.endm
error_structure .macro
	jmp	ErrorV_structure
	.endm
error_stop .macro
	jmp	ErrorV_stop
	.endm
error_data .macro
	jmp	ErrorV_data
	.endm
error_undeclared .macro
	jmp	ErrorV_undeclared
	.endm
error_redefine .macro
	jmp	ErrorV_redefine
	.endm
error_index .macro
	jmp	ErrorV_index
	.endm
error_memory .macro
	jmp	ErrorV_memory
	.endm
error_channel .macro
	jmp	ErrorV_channel
	.endm
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		macros.inc
;		Purpose:	Command macros
;		Created:	25th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							Size independent write keyword as constant
;
; ************************************************************************************************

keyword .macro
		.if (\1) > 255
		lda 	#(\1) >> 8
		jsr 	WriteCodeByte
		.endif
		lda 	#(\1) & $FF
		jsr 	WriteCodeByte
		.endm


		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
;
;	This file is automatically generated
;
PCD_STARTBINARY = $80
PCD_ENDBINARY = $8d
PCD_STARTCOMMAND = $8d
PCD_ENDCOMMAND = $ca
PCD_STARTSYSTEM = $ca
PCD_ENDSYSTEM = $d5

PCD_PLUS             = $80 ; +
PCD_MINUS            = $81 ; -
PCD_TIMES            = $82 ; *
PCD_DIVIDE           = $83 ; /
PCD_POWER            = $84 ; ^
PCD_AND              = $85 ; and
PCD_OR               = $86 ; or
PCD_GREATER          = $87 ; >
PCD_EQUAL            = $88 ; =
PCD_LESS             = $89 ; <
PCD_GREATEREQUAL     = $8a ; >=
PCD_LESSGREATER      = $8b ; <>
PCD_LESSEQUAL        = $8c ; <=
PCD_ABS              = $8d ; abs
PCD_ARRAY            = $8e ; array
PCD_ASC              = $8f ; asc
PCD_ASSERT           = $90 ; assert
PCD_BINDOLLAR        = $91 ; bin$
PCD_PRINTCMD_CHR     = $92 ; print.chr
PCD_CHRDOLLAR        = $93 ; chr$
PCD_SCMD_CMP         = $94 ; s.cmp
PCD_FOR              = $95 ; for
PCD_FRE              = $96 ; fre
PCD_GET              = $97 ; get
PCD_RETURN           = $98 ; return
PCD_PSET             = $99 ; pset
PCD_LINE             = $9a ; line
PCD_RECT             = $9b ; rect
PCD_FRAME            = $9c ; frame
PCD_CHAR             = $9d ; char
PCD_HEXDOLLAR        = $9e ; hex$
PCD_INPUT            = $9f ; input
PCD_INPUTDOLLAR      = $a0 ; input$
PCD_INPUTCMD_START   = $a1 ; input.start
PCD_LEN              = $a2 ; len
PCD_FCMD_CMP         = $a3 ; f.cmp
PCD_INTCMD_DIV       = $a4 ; int.div
PCD_NEGATE           = $a5 ; negate
PCD_NEWCMD_LINE      = $a6 ; new.line
PCD_NEXT             = $a7 ; next
PCD_NOT              = $a8 ; not
PCD_ON               = $a9 ; on
PCD_MOREON           = $aa ; moreon
PCD_PEEK             = $ab ; peek
PCD_POKE             = $ac ; poke
PCD_POS              = $ad ; pos
PCD_GETCHANNEL       = $ae ; getchannel
PCD_SETCHANNEL       = $af ; setchannel
PCD_PRINTCMD_N       = $b0 ; print.n
PCD_PRINTCMD_S       = $b1 ; print.s
PCD_READ             = $b2 ; read
PCD_READDOLLAR       = $b3 ; read$
PCD_RND              = $b4 ; rnd
PCD_CONCAT           = $b5 ; concat
PCD_SGN              = $b6 ; sgn
PCD_PRINTCMD_TAB     = $b7 ; print.tab
PCD_PRINTCMD_POS     = $b8 ; print.pos
PCD_PRINTCMD_SPC     = $b9 ; print.spc
PCD_STRDOLLAR        = $ba ; str$
PCD_LEFTDOLLAR       = $bb ; left$
PCD_RIGHTDOLLAR      = $bc ; right$
PCD_MIDDOLLAR        = $bd ; mid$
PCD_SWAP             = $be ; swap
PCD_TI               = $bf ; ti
PCD_TIDOLLAR         = $c0 ; ti$
PCD_USR              = $c1 ; usr
PCD_VAL              = $c2 ; val
PCD_CLOSE            = $c3 ; close
PCD_EXIT             = $c4 ; exit
PCD_DEBUG            = $c5 ; debug
PCD_OPEN             = $c6 ; open
PCD_SCREEN           = $c7 ; screen
PCD_VPOKE            = $c8 ; vpoke
PCD_VPEEK            = $c9 ; vpeek
PCD_CMD_SHIFT        = $ca ; .shift
PCD_CMD_BYTE         = $cb ; .byte
PCD_CMD_WORD         = $cc ; .word
PCD_CMD_FLOAT        = $cd ; .float
PCD_CMD_STRING       = $ce ; .string
PCD_CMD_DATA         = $cf ; .data
PCD_CMD_GOTO         = $d0 ; .goto
PCD_CMD_GOSUB        = $d1 ; .gosub
PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
PCD_CMD_VARSPACE     = $d4 ; .varspace
PCD_CLR              = $ca80 ; clr
PCD_DIM              = $ca81 ; dim
PCD_END              = $ca82 ; end
PCD_JOY              = $ca83 ; joy
PCD_INT              = $ca84 ; int
PCD_SQR              = $ca85 ; sqr
PCD_LOG              = $ca86 ; log
PCD_EXP              = $ca87 ; exp
PCD_COS              = $ca88 ; cos
PCD_SIN              = $ca89 ; sin
PCD_TAN              = $ca8a ; tan
PCD_ATN              = $ca8b ; atn
PCD_MOUSE            = $ca8c ; mouse
PCD_MB               = $ca8d ; mb
PCD_MX               = $ca8e ; mx
PCD_MY               = $ca8f ; my
PCD_RESTORE          = $ca90 ; restore
PCD_STOP             = $ca91 ; stop
PCD_SYS              = $ca92 ; sys
PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
PCD_WAIT             = $ca94 ; wait
PCD_I2CPOKE          = $ca95 ; i2cpoke
PCD_I2CPEEK          = $ca96 ; i2cpeek
PCD_BANK             = $ca97 ; bank
PCD_SLEEP            = $ca98 ; sleep
PCD_FMINIT           = $ca99 ; fminit
PCD_FMNOTE           = $ca9a ; fmnote
PCD_FMDRUM           = $ca9b ; fmdrum
PCD_FMINST           = $ca9c ; fminst
PCD_FMVIB            = $ca9d ; fmvib
PCD_FMFREQ           = $ca9e ; fmfreq
PCD_FMVOL            = $ca9f ; fmvol
PCD_FMPAN            = $caa0 ; fmpan
PCD_FMPLAY           = $caa1 ; fmplay
PCD_FMCHORD          = $caa2 ; fmchord
PCD_FMPOKE           = $caa3 ; fmpoke
PCD_PSGINIT          = $caa4 ; psginit
PCD_PSGNOTE          = $caa5 ; psgnote
PCD_PSGVOL           = $caa6 ; psgvol
PCD_PSGWAV           = $caa7 ; psgwav
PCD_PSGFREQ          = $caa8 ; psgfreq
PCD_PSGPAN           = $caa9 ; psgpan
PCD_PSGPLAY          = $caaa ; psgplay
PCD_PSGCHORD         = $caab ; psgchord
PCD_CLS              = $caac ; cls
PCD_LOCATE           = $caad ; locate
PCD_COLOR            = $caae ; color
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_config.inc
;		Purpose:	Configuration for compiler
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************
;
;		Runtime p-code goes here. Needs to be on a page boundary.
;
PCodeStart = $4000
;
;		Work area space and size. Upwards is variables, Downwards is line number positions.
;
WorkArea = $8000
WorkAreaSize = $1F00

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_storage.inc
;		Purpose:	Storage access macros
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

storage_access .macro
		.endm

storage_release .macro
		.endm

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		altbase.asm
;		Purpose:	Handle other bases
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						Compile a 16 bit other base constant. Type marker in A
;
; ************************************************************************************************

InlineNonDecimal:
		ldx 	#2 							; get size in X
		cmp 	#"%" 						
		beq 	_INDBinary
		ldx 	#16
_INDBinary:									
		sta 	zTemp1 						; size => zTemp1
		stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
		stz 	zTemp0 						; zero result
		stz 	zTemp0+1
_INDLoop:
		jsr 	LookNext 					; check next character
		jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
		bcc		_INDDone 					; didn't convert
		cmp 	zTemp1 						; size too large ?
		bcs 	_INDDone
		;
		jsr 	_INDShift 					; x 2 or x 16
		cpx 	#2
		beq 	_INDNotHex
		jsr 	_INDShift
		jsr 	_INDShift
		jsr 	_INDShift
_INDNotHex:
		ora 	zTemp0 						; or digit into result
		sta 	zTemp0 		
		jsr 	GetNext 					; consume
		inc 	zTemp1+1 					; bump count
		bra 	_INDLoop
		;
_INDDone:
		lda 	zTemp1+1 					; done at least 1 ?
		beq 	_INDError
		ldy 	zTemp0+1 					; push constant
		lda 	zTemp0	
		jsr 	PushIntegerYA
		rts

_INDError:
		.error_syntax
		
_INDShift:
		asl 	zTemp0
		rol 	zTemp0+1
		rts		
		.send code

		.section storage
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		buffer.asm
;		Purpose:	Buffer for inline data, strings etc.
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Clear the buffer
;
; ************************************************************************************************

BufferClear:
		stz 	bufferSize
		rts		

; ************************************************************************************************
;
;									 Write A to the buffer
;
; ************************************************************************************************

BufferWrite:
		phx
		ldx 	bufferSize
		sta 	dataBuffer,x
		inc 	bufferSize
		plx
		rts

; ************************************************************************************************
;
;								Output buffer as data block
;
; ************************************************************************************************

BufferOutput:
		lda 	bufferSize
		jsr 	WriteCodeByte
		ldx 	#0
_BOLoop:
		cpx 	bufferSize
		beq 	_BOExit
		lda 	dataBuffer,x
		jsr 	WriteCodeByte
		inx
		bra 	_BOLoop
_BOExit:
		rts		
		.send code

		.section storage
bufferSize:
		.fill 	1
dataBuffer:
		.fill 	256
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		byte.asm
;		Purpose:	Wrapper for HWOWriteByte
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Write A with to output
;
; ************************************************************************************************

WriteCodeByte:
		pha 								; save on stack
		phx
		phy
		jsr 	OUTPUTWriteByte
		ply 								; restore from stack
		plx
		pla
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		check.asm
;		Purpose:	Token presence check
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

	
; ************************************************************************************************
;
;									Check Next char various
;
; ************************************************************************************************

CheckNextComma:
		lda	 	#","
		bra 	CheckNextA
CheckNextRParen:
		lda	 	#")"
		bra 	CheckNextA
CheckNextLParen:
		lda 	#"("
CheckNextA:
		sta 	checkCharacter 				; save test character
_CNALoop:		
		jsr 	GetNextNonSpace 			; get next skipping spaces.
		cmp 	checkCharacter 				; matches ?
		beq 	_CNAExit
		.error_syntax
_CNAExit:		
		rts
		.send code

		.section storage
checkCharacter:
		.fill 	1
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		close.asm
;		Purpose:	Close, perhaps Save the object code out
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Save the object code out
;
; ************************************************************************************************

OUTPUTClose:
		lda 	#(PCodeStart >> 8)
		ldx 	objPtr
		ldy 	objPtr+1
		jsr 	XSaveMemory
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		00compiler.asm
;		Purpose:	Compiler main
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

StartCompiler:	
		jsr 	STRReset 					; reset storage (line#, variable)
		jsr 	INPUTOpen 					; reset data input
		jsr 	OUTPUTOpen 					; reset data output.
		;
		;		Compile _variable.space, filled in on pass 2.
		;
		lda 	#PCD_CMD_VARSPACE
		jsr 	WriteCodeByte
		lda 	#0
		jsr 	WriteCodeByte
		jsr 	WriteCodeByte
		;
		;		Main compilation loop
		;
MainCompileLoop:
		jsr 	ReadNextLine 				; read next line into the buffer.
		bcc 	SaveCodeAndExit 			; end of source.
		;
		jsr 	GetLineNumber 				; get line #
		jsr 	STRMarkLine 				; remember the position and number of this line.
		lda 	#PCD_NEWCMD_LINE 			; generate new command line
		jsr 	WriteCodeByte

_MCLSameLine:
		jsr 	GetNextNonSpace 			; get the first character.
		beq 	MainCompileLoop 			; end of line, get next line.
		cmp 	#":"						; if : then loop back.
		beq 	_MCLSameLine

		cmp 	#0 							; if ASCII then check for implied LET.		
		bpl 	_MCLCheckAssignment 

		ldx 	#CommandTables & $FF 		; do command tables.
		ldy 	#CommandTables >> 8
		jsr 	GeneratorProcess
		bcs 	_MCLSameLine 				; keep trying to compile the line.

_MCLSyntax: 								; syntax error.
		.error_syntax
		;
		;		Implied assignment ?
		;
_MCLCheckAssignment:
		jsr 	CharIsAlpha 				; if not alpha then syntax error
		bcc 	_MCLSyntax
		jsr 	CommandLETHaveFirst  		; LET first character, do assign
		bra		_MCLSameLine 				; loop back.
		;
		;		End of compile, fix up GOTO/GOSUB etc., save it and exit.
		;
SaveCodeAndExit:
		jsr 	INPUTClose 					; finish input.
		lda 	#$FF 						; fake line number $FFFF for forward THEN.
		tay
		jsr 	STRMarkLine
		lda 	#PCD_EXIT 					; add an END
		jsr 	WriteCodeByte
		lda 	#$FF 						; add end marker
		jsr 	WriteCodeByte
		jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
		jsr 	OUTPUTClose
ExitCompiler:		
		jmp 	$FFFF
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		constant.asm
;		Purpose:	Output integer constants
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Output code to push integer YA / A
;
; ************************************************************************************************

PushIntegerYA:
		cpy 	#0 							; 0-255
		beq 	PushIntegerA
		pha
		lda 	#PCD_CMD_WORD 				; send .word
		jsr 	WriteCodeByte 	
		pla 								; then LSB
		jsr 	WriteCodeByte 	
		tya 								; then MSB
		jsr 	WriteCodeByte 	
		rts

PushIntegerA:
		cmp 	#64 						; if > 64 send byte as is
		bcc 	_PIWriteA
		pha 								
		lda 	#PCD_CMD_BYTE 				; send .byte
		jsr 	WriteCodeByte 	
		pla
_PIWriteA:		
		jsr 	WriteCodeByte
		rts

; ************************************************************************************************
;
;										Push TOS Float
;
; ************************************************************************************************

PushFloat:
		lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
		jsr 	WriteCodeByte
		lda 	NSExponent,x 				; and the data
		jsr 	WriteCodeByte
		lda 	NSMantissa0,x
		jsr 	WriteCodeByte
		lda 	NSMantissa1,x
		jsr 	WriteCodeByte
		lda 	NSMantissa2,x
		jsr 	WriteCodeByte
		lda 	NSStatus,x 					; with sign packed in byte 3 MSB
		and 	#$80
		ora 	NSMantissa3,x
		jsr 	WriteCodeByte
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		create.asm
;		Purpose:	Create variable.
;		Created:	25th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;		  		   XYmake  contains a variable name. Allocate space for it and create it. 
;										Return variable address in YX
;
; ************************************************************************************************

		.section code

CreateVariableRecord:
		pha

		.storage_access

		lda 	freeVariableMemory 		; push current free address on stack.
		pha
		lda 	freeVariableMemory+1
		pha

		lda 	variableListEnd  		; copy end of list to zTemp0
		sta 	zTemp0	
		lda 	variableListEnd+1
		sta 	zTemp0+1

		lda 	#6 						; default size if 6 (offset link 3 bytes)
		sta 	(zTemp0)

		tya
		ldy 	#2 						; write out the name.
		sta 	(zTemp0),y
		dey
		txa
		sta 	(zTemp0),y

		ldy 	#3 						; write out the address.
		lda 	freeVariableMemory
		sta 	(zTemp0),y
		iny
		lda 	freeVariableMemory+1
		sta 	(zTemp0),y

		ldy 	#6 						; write EOL marker next record.
		lda 	#0
		sta 	(zTemp0),y

		clc
		lda 	(zTemp0) 				; add offset to variableListEnd
		adc  	variableListEnd
		sta 	variableListEnd
		bcc 	_CVNoCarry2
		inc 	variableListEnd+1
_CVNoCarry2:		
		.storage_release
		ply 							
		plx
		pla
		rts

; ************************************************************************************************
;
;			Set the last defined variable record to the current code position.
;
; ************************************************************************************************

SetVariableRecordToCodePosition:
		.storage_access
		pha
		phy
		lda 	objPage
		ldy 	#3
		sta 	(zTemp0),y
		iny
		lda 	objPtr+1
		sta 	(zTemp0),y
		iny 	
		lda 	objPtr
		sta 	(zTemp0),y
		ply
		pla
		.storage_release
		rts

; ************************************************************************************************
;
;									Allocate bytes for type A
;
; ************************************************************************************************

AllocateBytesForType:
		pha
		phx
		ldx 	#2 						; bytes to allocate
		and 	#NSSTypeMask+NSSIInt16
		cmp 	#NSSIFloat
		bne 	_CVNotFloat
		ldx 	#6
_CVNotFloat:
		txa 							; add 6 or 2 to the free memory pointer.
		clc
		adc 	freeVariableMemory
		sta 	freeVariableMemory
		bcc 	_CVNoCarry1
		inc 	freeVariableMemory+1
_CVNoCarry1:				
		plx
		pla
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		data.asm
;		Purpose:	Compile DATA Statements
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Compile a Data Block
;
; ************************************************************************************************

CommandDATA:
		jsr 	BufferClear 				; copy it to the buffer
		jsr 	LookNextNonSpace
_CTDataLoop:
		jsr 	LookNext 					; reached EOL
		beq 	_CTDataDone
		;
		jsr 	BufferWrite 				; write and consume
		jsr 	GetNext
		bra 	_CTDataLoop
_CTDataDone:
		lda 	#PCD_CMD_DATA 				; output command and buffer
		jsr 	WriteCodeByte
		jsr 	BufferOutput
		rts		

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		deffn.asm
;		Purpose:	Def Fn command
;		Created:	29th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										DEF FN
;
; ************************************************************************************************

CommandDEF: 		
		;
		;		Skip to EOL.
		;
		lda 	#0 							; constant 0 (for GOTOZ)
		jsr 	PushIntegerA
		jsr 	CompileGotoEOL 				; compile skip over DEF
		;
		;	 	Check FN keyword
		;
		lda 	#C64_FN
		jsr 	CheckNextA
		;
		;		Identify FNxx(
		;
		jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
		jsr 	ExtractVariableName 
		txa
		bpl 	_CDError
		;
		txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
		and 	#$7F
		tax
		tya
		ora 	#$80
		tay
		;
		;		Create the FNxx( record and give it the address.
		;
		jsr 	FindVariable				; does it already exist ?
		bcs 	_CDError 					; if so, that's an error.
		jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
		jsr 	SetVariableRecordToCodePosition
		;
		;		Get the address to update.
		;
		jsr 	GetNextNonSpace
		jsr 	GetReferenceTerm 			; get var ref, not array
		cmp 	#0
		bmi 	_CDError 	
		sta 	defType 					; save type		
		stx 	defVariable 				; save var ref 
		sty 	defVariable+1
		and 	#NSSString 					; only numbers.
		bne 	_CDError
		jsr 	CheckNextRParen 			; check )
		lda 	#C64_EQUAL
		jsr 	CheckNextA 					; check =
		;	
		;		Now generate the code.
		;
		clc 								; if this is DEF FNxx(A), read A
		jsr 	CDReadWriteVariable
		.keyword PCD_SWAP 					; old A 2nd, new A 1st
		sec
		jsr 	CDReadWriteVariable 		; A is now updated
		jsr 	CompileExpressionAt0 		; the actual body of the function.
		.keyword PCD_SWAP 					; result 2nd, old A 1st
		sec
		jsr 	CDReadWriteVariable 		; A is now reset to its old value
		.keyword PCD_RETURN 				; return as we'll call it from a subroutine
		rts


_CDError:
		.error_syntax

CDReadWriteVariable:
		ldy 	defVariable+1 				; set up YX
		ldx 	defVariable
		lda 	defType
		jsr 	GetSetVariable
		rts
		.send code

		.section storage
defType:
		.fill 	1
defVariable:
		.fill 	2
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		dim.asm
;		Purpose:	DIM command
;		Created:	26th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											DIM command
;
; ************************************************************************************************

CommandDIM:
		jsr 	GetNextNonSpace 			; get the first non space character
		jsr 	ExtractVariableName 		; variable name to XY
		phx 								; save name with type bits.
		cpx 	#0 							; check it is an array.
		bpl 	_CDError
		jsr 	FindVariable	 			; see if already exist
		bcs 	_CDRedefine 				; it still exists.
		jsr 	CreateVariableRecord 		; create the basic variable 
		jsr 	AllocateBytesForType 		; allocate memory for it

		pla 								; restore type bits
		phy 								; save the address of the basic storage
		phx
		pha
		jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
		pla
		and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
		jsr 	PushIntegerA 				; push that type data out.

		.keyword PCD_DIM 					; call the keyword to dimension the array with this information.
		
		plx 								; restore address
		ply
		lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
		sec
		jsr 	GetSetVariable 				; store the address in the reference to the array structure.
		;
		jsr 	LookNextNonSpace 			; , follows ?
		cmp 	#","
		bne 	_CDExit
		jsr 	GetNext 					; consume comma
		bra 	CommandDIM 					; do another DIM
_CDExit:		
		rts		

_CDError:
		.error_syntax
_CDRedefine:
		.error_redefine

; ************************************************************************************************
;
;									Consume an index group
;
; ************************************************************************************************

OutputIndexGroup:
		stz 	IndexCount 					; count of number of indices.
_OIGNext:
		jsr 	CompileExpressionAt0 		; get a dimension
		and 	#NSSTypeMask 				; check it is numeric
		cmp 	#NSSIFloat
		bne 	_OIGType
		inc 	IndexCount 					; bump the counter.
		jsr 	LookNextNonSpace 			; does a , follow ?
		cmp 	#","
		bne 	_OIGCheckEnd
		jsr 	GetNext 					; consume comma
		bra 	_OIGNext 					; get next dimension
_OIGCheckEnd:
		jsr 	CheckNextRParen 			; check and consume )
		lda 	IndexCount
		jsr 	PushIntegerA 				; compile the dimension count.
		rts

_OIGType:
		.error_type
		
		.send code

		.section storage
IndexCount:
		.fill 	1
		.send storage		

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		errorhandler.asm
;		Purpose:	Error handler
;		Created:	1st May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code
	
ErrorHandler:
		pla
		ply
		sta 	zTemp0
		sty 	zTemp0+1
		ldx 	#0 							; output msg to channel #0 
		ldy 	#1
_EHDisplayMsg:
		lda 	(zTemp0),y
		jsr 	XPrintCharacter
		iny
		lda 	(zTemp0),y
		bne 	_EHDisplayMsg
		lda 	#32
		jsr 	XPrintCharacter
		lda 	#64
		jsr 	XPrintCharacter
		;
		ldx 	#0 							; convert line# to string
		jsr 	FloatSetByte
		jsr 	GetLineNumber
		sta 	NSMantissa0,x
		tya
		sta 	NSMantissa1,x
		jsr 	FloatToString
		ldy 	#0 							; display that string.
		ldx 	#0
_EHDisplayLine:
		lda 	decimalBuffer,y
		jsr 	XPrintCharacter
		iny
		lda 	decimalBuffer,y
		bne 	_EHDisplayLine
		lda 	#13
		jsr 	XPrintCharacter
		jmp 	ExitCompiler
						
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
;
;	This file is automatically generated.
;
	.section code
ErrorV_range:
	jsr	ErrorHandler
	.text	"OUT OF RANGE",0
ErrorV_value:
	jsr	ErrorHandler
	.text	"BAD VALUE",0
ErrorV_syntax:
	jsr	ErrorHandler
	.text	"SYNTAX ERROR",0
ErrorV_type:
	jsr	ErrorHandler
	.text	"TYPE MISMATCH",0
ErrorV_unimplemented:
	jsr	ErrorHandler
	.text	"NOT IMPLEMENTED",0
ErrorV_assert:
	jsr	ErrorHandler
	.text	"ASSERT FAIL",0
ErrorV_line:
	jsr	ErrorHandler
	.text	"UNKNOWN LINE NUMBER",0
ErrorV_internal:
	jsr	ErrorHandler
	.text	"INTERNAL ERROR",0
ErrorV_divzero:
	jsr	ErrorHandler
	.text	"DIVIDE BY ZERO",0
ErrorV_structure:
	jsr	ErrorHandler
	.text	"STRUCTURE IMBALANCE",0
ErrorV_stop:
	jsr	ErrorHandler
	.text	"PROGRAM STOPPED",0
ErrorV_data:
	jsr	ErrorHandler
	.text	"OUT OF DATA",0
ErrorV_undeclared:
	jsr	ErrorHandler
	.text	"UNKNOWN ARRAY",0
ErrorV_redefine:
	jsr	ErrorHandler
	.text	"ARRAY REDEFINED",0
ErrorV_index:
	jsr	ErrorHandler
	.text	"BAD ARRAY INDEX",0
ErrorV_memory:
	jsr	ErrorHandler
	.text	"OUT OF MEMORY",0
ErrorV_channel:
	jsr	ErrorHandler
	.text	"INPUT/OUTPUT ERROR",0
	.send code
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		expression.asm
;		Purpose:	Expression evaluator
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Compile expression precedence A/0
;
; ************************************************************************************************

CompileExpressionAt0:
		lda 	#0
CompileExpressionAtA:
		pha  								; save level
		jsr 	CompileTerm 				; compile a term.
		plx 								; get level back into X
		;
		;		Expression main loop - X is the precedence level, A the type.
		;
_ECALoop:				
		pha 								; save type on stack.
		jsr 	LookNextNonSpace 			; get the next character
		cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
		bcc 	_ECAExit
		cmp 	#C64_LESS+1
		bcc 	_ECAHaveToken
_ECAExit:
		pla 								; throw type off stack
		rts
		;
		;		Have a partial token - check precedence (because the >= <= <> precedence is the same as < and >)
		;
_ECAHaveToken:		
		stx 	zTemp0 						; save current precedence in zTemp0
		tax 								; X contains the operator token

		lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
		cmp 	zTemp0 						; if < then exit
		bcc 	_ECAExit
		sta 	zTemp0+1 					; save the precedence of the operator.
		jsr 	GetNext 					; consume the token.
		;
		;		Now check for >= <= <>
		;
		cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
		beq 	_ECAGreaterCheck
		cpx 	#C64_LESS
		bne 	_ECAHaveFullToken
		;
		jsr 	LookNext 					; checks for < (<= or <>)
		cmp 	#C64_GREATER 				; <> is 2 on from <
		beq	 	_ECAToNotEqual
		cmp 	#C64_EQUAL 					; <= is 3 on from <
		bne 	_ECAHaveFullToken
		bra 	_ECAAddEqual

_ECAGreaterCheck: 							; checks for > (>=)		
		jsr 	LookNext
		cmp 	#C64_EQUAL
		bne 	_ECAHaveFullToken
_ECAAddEqual:
		inx 								; > => >= and < to <= is three tokens on.
_ECAToNotEqual:		
		inx
		inx
		jsr 	GetNext 					; consume the = or > in >= <= <>		
_ECAHaveFullToken:		
		;
		;		Check for + string => concat
		;
		cpx 	#C64_PLUS
		bne 	_ECANotConcat
		pla 								; get type back
		pha
		and 	#NSSTypeMask
		cmp 	#NSSString
		bne 	_ECANotConcat
		ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
_ECANotConcat:		
		;
		;		Now have the correct token in X.
		;
		phx 								; save operator on the stack
		ldx 	zTemp0 						; push current precedence on the stack
		phx
		;
		;		Evaluate the RHS
		;
		lda 	zTemp0+1 					; get precedence of operator
		inc 	a
		jsr 	CompileExpressionAtA 		; and compile at the next level up.
		sta 	zTemp0 						; save type in zTemp0
		;
		plx 								; restore current precedence in X

		pla 								; restore operator
		sta 	zTemp0+1 					; save it in zTemp0+1.
		;
		;		Check if we need f.cmp or s.cmp
		;
		cmp 	#C64_GREATER 				; check for not compare
		bcc 	_ECANotCompare
		cmp 	#C64_GREATER+6
		bcs 	_ECANotCompare
		ply 								; get type into Y
		phy 
		pha 								; save operator

		tya 								; get type
		ldy 	#PCD_SCMD_CMP 				; Y is the token to use
		and 	#NSSTypeMask 				
		cmp 	#NSSString
		beq 	_ECANotString
		ldy 	#PCD_FCMD_CMP
_ECANotString:		
		tya									; output token Y
		jsr 	WriteCodeByte
		pla 								; restore operator.
_ECANotCompare:		
		;
		;		Compile the operator, which may be wrong (e.g. multiplying strings)
		;
		clc 								; convert to P-Code and compile.
		adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
		jsr 	WriteCodeByte
		;
		;		Check the types match
		;
		pla 								; type of current result
		eor 	zTemp0 						; check compatible with r-expr type
		and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
		bne		_ECAType
		;
		lda 	zTemp0 						; get type back
		cmp 	#NSSString 					; if it is a number, then all operators work.
		bne 	_ECAGoLoop 			
		;
		;		For strings only, check the command is valid (e.g. only + and comparators)
		;
		lda 	zTemp0+1 					; check operator is + or comparator
		cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
		beq 	_ECAOkayString 				; (this is post conversion)

		cmp 	#C64_GREATER 				; must be a comparison then.
		bcc 	_ECAType
		cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
		bcs 	_ECAType
		lda 	#NSSIFloat 					; compare returns number.
		jmp 	_ECALoop

_ECAType: 									; types mixed ?
		.error_type

_ECAOkayString:		
		lda 	#NSSString 					; current is string, go round again.
_ECAGoLoop:		
		jmp 	_ECALoop

; ************************************************************************************************
;
;										Operator precedence table
;
; ************************************************************************************************

PrecedenceTable:
		.byte 	3 					; '+'
		.byte 	3 					; '-'
		.byte 	4 					; '*'
		.byte 	4 					; '/'
		.byte 	5 					; '^'
		.byte 	1 					; 'and'
		.byte 	0 					; 'or'
		.byte 	2 					; '>'
		.byte 	2 					; '='
		.byte 	2 					; '<'
		.byte 	2 					; '>='
		.byte 	2 					; '<='
		.byte 	2 					; '<>'

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		findvar.asm
;		Purpose:	Find variable.
;		Created:	25th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;		  XY contains a variable name. Find it, returning address in YXA and CS if found
;		
;					  Returns $8000 > for special variables TI ($8000) TI$($C001)
;
; ************************************************************************************************

		.section code

FindVariable:
		stx 	zTemp1 						; save name.
		sty 	zTemp1+1
		;
		;		Check for TI $1409 and TI$ $5409 which return 6 and 8 as addresses.
		;
_IVCheckSpecial:		
		cpy 	#$09	 					; both end $09 e.g. I
		bne 	_IVStandard
		cpx 	#$14 						; TI is $14
		beq 	_IVTIFloat
		cpx 	#$54 						; TI$ is $54
		bne 	_IVStandard
		ldy 	#$C0 						; TI$ returns string $C001
		ldx 	#$01
		lda 	#NSSString
		sec
		rts
_IVTIFloat: 								; TI returns ifloat at $8000
		ldy 	#$80
		ldx 	#$00
		lda 	#0
		sec
		rts
		;
		;		Not TI or TI$
		;
_IVStandard:
		.set16 	zTemp0,WorkArea 			; start scanning from here.
		.storage_access
_IVCheckLoop:
		lda 	(zTemp0) 					; finished ?
		beq  	_IVNotFound 				; if so, return with CC.
		;
		ldy 	#1 							; match ?
		lda 	(zTemp0),y
		cmp 	zTemp1
		bne	 	_IVNext
		iny
		lda 	(zTemp0),y
		cmp 	zTemp1+1
		beq 	_IVFound
_IVNext: 									; go to next
		clc
		lda 	zTemp0
		adc 	(zTemp0)
		sta 	zTemp0
		bcc 	_IVCheckLoop
		inc 	zTemp0+1
		bra 	_IVCheckLoop
		;
_IVFound:		
		ldy 	#3 							; get address into YX
		lda 	(zTemp0),y
		tax
		iny
		lda 	(zTemp0),y
		pha
		iny
		lda 	(zTemp0),y
		ply
		.storage_release
		sec
		rts

_IVNotFound:
		.storage_release
		ldx 	zTemp1 						; get variable name back
		ldy 	zTemp1+1
		clc
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		fixbranches.asm
;		Purpose:	Fix up GOTO and GOSUB commands
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Fix up GOTO and GOSUB, and VARSPACE
;
; ************************************************************************************************

FixBranches:
		jsr 	OUTPUTRewind 				; back to the start of the *object* code.
_FBLoop:
		lda 	(objPtr) 					; get the next one.
		cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
		beq 	_FBFixGotoGosub
		cmp 	#PCD_CMD_GOSUB
		beq 	_FBFixGotoGosub
		cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
		beq 	_FBFixGotoGosub
		cmp 	#PCD_CMD_GOTOCMD_Z 
		beq 	_FBFixGotoGosub
		cmp 	#PCD_CMD_VARSPACE
		beq 	_FBFixVarSpace
_FBNext:		
		jsr 	MoveObjectForward 			; move forward in object code.
		bcc 	_FBLoop 					; not finished
_FBExit:		
		rts
;
;		Found GOTO/GOSUB - look it up in the line# table and fix it up.
;
_FBFixGotoGosub:
		ldy 	#1 							; if page is currently $FF
		lda 	(objPtr),y 					; then patch else leave.
		cmp 	#$FF
		bne 	_FBNext

		ldy 	#2							; line number in YA
		lda 	(objPtr),y
		pha
		iny
		lda 	(objPtr),y
		tay
		pla
		jsr 	STRFindLine			 		; find where it is X:YA
		bcc 	_FBFFound 					; not found, so must be >
		pha
		lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
		cmp 	#PCD_CMD_GOTOCMD_Z
		bne 	_FBFFail
		pla

_FBFFound:		
		jsr 	STRMakeOffset 				; make it an offset from X:YA
		
		phy	 								; patch the GOTO/GOSUB
		pha

		ldy 	#1
		txa
		sta 	(objPtr),y

		iny
		pla
		sta 	(objPtr),y

		iny
		pla
		sta 	(objPtr),y
		bra 	_FBNext

_FBFFail:
		ldy 	#2
		lda 	(objPtr),y
		sta 	currentLineNumber
		iny
		lda 	(objPtr),y
		sta 	currentLineNumber+1
		.error_line

;
;		Found VarSpace, fix up with free space after variables
;
_FBFixVarSpace:
		ldy 	#1
		lda 	freeVariableMemory
		sta 	(objPtr),y
		iny
		lda 	freeVariableMemory+1
		sta 	(objPtr),y
		bra 	_FBNext

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		for.asm
;		Purpose:	FOR compile
;		Created:	20th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Compile FOR command
;
;				Creates [Initial] Index! [Reference|Type] [Terminal] [Step] FOR
;
; ************************************************************************************************

CommandFOR: 
		;
		;		FOR [variable]
		;
		jsr 	GetNextNonSpace 			; first letter of index variable, should be.
		jsr 	CharIsAlpha 				; if not alpha , error
		bcc 	_CFFail
		jsr 	GetReferenceTerm 			; figure out the reference.

		pha 								; save type
		and 	#NSSTypeMask 				; check it is numeric
		cmp 	#NSSIFloat 					
		bne 	_CFFail
		;
		; 		= [Start]
		;
		phy 								; save reference on the stack
		phx
		lda 	#C64_EQUAL 					; check for equal.
		jsr 	CheckNextA
		jsr 	CompileExpressionAt0 		; initial value
		plx 								; get reference back.
		ply
		phy
		phx
		sec 								; set initial value.
		jsr 	GetSetVariable
		;
		;		Push reference on the stack, Int16 flag in Bit15
		;
		plx
		ply
		pla
		and 	#NSSIInt16 	
		beq 	_CFNotInt16
		tya
		ora 	#$80
		tay
_CFNotInt16:
		txa 								; reference in YA
		jsr 	PushIntegerYA
		;
		;		TO [End]
		;
		lda 	#C64_TO
		jsr 	CheckNextA
		jsr 	CompileExpressionAt0 		; terminal value
		and 	#NSSTypeMask 				; check it is numeric
		cmp 	#NSSIFloat 					
		bne 	_CFFail
		;
		;		Optional STEP [n]
		;
		jsr 	LookNextNonSpace 			; followed by STEP
		cmp 	#C64_STEP
		bne 	_CFNoStep
		;
		jsr 	GetNext 					; consume it.
		jsr 	CompileExpressionAt0 		; terminal value
		and 	#NSSTypeMask 				; check it is numeric
		cmp 	#NSSIFloat 					
		bne 	_CFFail
		bra 	_CFParametersDone
		;
_CFNoStep:
		lda 	#1 							; default STEP e.g. 1
		jsr 	PushIntegerA
_CFParametersDone:		
		lda 	#PCD_FOR  					; compile FOR word.
		jsr 	WriteCodeByte
		rts



_CFFail:
		.error_syntax

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		forward.asm
;		Purpose:	Move object pointer forward
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Move objPtr forwards. CS if end
;
; ************************************************************************************************

MoveObjectForward:

		lda 	(objPtr) 					; get next
		
		cmp 	#$FF  						
		beq 	_MOFEnd

		cmp 	#$40 						; 00-3F
		bcc 	_MOFAdvance1 				; forward 1

		ldy 	#2 							; 40-6F
		cmp 	#$70 						; forward 2
		bcc 	_MOFAdvanceY 				

		cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
		bcc 	_MOFAdvance1 				; forward 1

		tay 								; read the size.
		lda 	MOFSizeTable-PCD_STARTSYSTEM,y
		tay
		iny 								; add 1 for the system token.
		bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.

		ldy 	#1 							; get length byte
		lda 	(objPtr),y
		tay 								; into Y.

		clc
		lda 	objPtr						; add 2 to the object pointer
		adc 	#2
		sta 	objPtr
		bcc 	_MOFNoCarry1
		inc 	objPtr+1
_MOFNoCarry1:		
		bra 	_MOFAdvanceY

_MOFAdvance1:
		ldy 	#1
_MOFAdvanceY:				
		tya 								; add X to objPtr
		clc
		adc 	objPtr
		sta 	objPtr
		bcc 	_MOFNoCarry2
		inc 	objPtr+1
_MOFNoCarry2:		
		clc 								; not completed.
		rts
		;
		;		At the end so advance past $FF end marker and return CS.
		;
_MOFEnd:
		inc 	objPtr
		bne 	_MOFENoCarry
		inc 	objPtr+1
_MOFENoCarry:
		sec
		rts		

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		fromram.asm
;		Purpose:	Read input data from RAM appended to end of compiler.
;		Created:	8th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Open/Close the input system
;
; ************************************************************************************************

INPUTOpen:
		.set16 	srcInputPtr,EndProgram+2 	; the current read point.		
INPUTClose:
		rts
		
; ************************************************************************************************
;
;								Get the next character.
;
; ************************************************************************************************

INPUTGet:
		lda 	(srcInputPtr)
		inc 	srcInputPtr
		bne 	_IGSkip
		inc 	srcInputPtr+1
_IGSkip:
		rts

		.send code

		.section zeropage
srcInputPtr: 								; data from here
		.fill 	2
		.send zeropage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		functions.asm
;		Purpose:	FNx code
;		Created:	1st May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										FN handler
;
; ************************************************************************************************

FNCompile:
		;
		;		Identify FNxx(
		;
		jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
		jsr 	ExtractVariableName 
		cpx 	#0
		bpl 	_FNError
		;
		txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
		and 	#$7F
		tax
		tya
		ora 	#$80
		tay
		;
		;		Check to see if it is defined.
		;
		jsr 	FindVariable				; does it already exist ?
		bcc 	_FNError 					; no.
		jsr 	STRMakeOffset 				; convert to a relative address.

		cmp 	#0 							; fix up.
		bne 	_FNNoBorrow
		dey
_FNNoBorrow:
		dec 	a

		phy 								; save location of routine on stack.
		pha
		phx
		;
		;		Handle <expression>)
		;
		jsr 	CompileExpressionAt0
		jsr 	CheckNextRParen
		;
		;		Compile routine call
		;
		lda 	#PCD_CMD_GOSUB
		jsr 	WriteCodeByte
		pla
		jsr 	WriteCodeByte
		pla
		jsr 	WriteCodeByte
		pla
		jsr 	WriteCodeByte

		clc
		rts

_FNError:
		.error_value
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		gendata.asm
;		Purpose:	Generation data files
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

	
; ************************************************************************************************
;
;			Generator tables. Apologies for messy way of including those for alt systems
;
; ************************************************************************************************

CommandTables:
;
;	This file is automatically generated.
;
;
;	GO     X:CommandGOAlt N
;
	.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
;
;	GOTO    X:CommandGOTO N
;
	.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
;
;	GOSUB    X:CommandGOSUB N
;
	.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
;
;	LET    X:CommandLET N
;
	.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
;
;	INPUT    X:CommandINPUT N
;
	.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
;
;	INPUT#    C:CommandINPUTStream N
;
	.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
;
;	PRINT    X:CommandPRINT N
;
	.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
;
;	PRINT#    C:CommandPRINT N
;
	.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
;
;	REM    X:CommandREM N
;
	.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
;
;	FOR    X:CommandFOR N
;
	.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
;
;	NEXT    X:CommandNEXT N
;
	.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
;
;	GET    X:CommandGET N
;
	.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
;
;	DATA    X:CommandDATA N
;
	.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
;
;	READ    X:CommandREAD N
;
	.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
;
;	DIM    X:CommandDIM N
;
	.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
;
;	DEF    X:CommandDEF N
;
	.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
;
;	IF     # X:CommandIF N
;
	.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
;
;	WAIT    #,# X:CommandWAIT N
;
	.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
;
;	ON     # T X:CommandON N
;
	.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
;
;	SYS    # T N
;
	.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
;
;	POKE    #,# T N
;
	.byte	$07,$97,$00,$ea,$e1,172,$06
;
;	RETURN    T N
;
	.byte	$06,$8e,$00,$10,152,$06
;
;	STOP    T N
;
	.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
;
;	END    T N
;
	.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
;
;	RESTORE   T N
;
	.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
		;.include "../../x16_compiler/generation/x16_command.defc"
		;.include "../../x16_compiler/generated/x16_sound.defc"
		.byte 	0

UnaryTables:
;
;	This file is automatically generated.
;
;
;	SGN    (#) T N
;
	.byte	$07,$b4,$00,$8e,$91,182,$06
;
;	INT    (#) T N
;
	.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
;
;	ABS    (#) T N
;
	.byte	$07,$b6,$00,$8e,$91,141,$06
;
;	USR    (#) T N
;
	.byte	$07,$b7,$00,$8e,$91,193,$06
;
;	FRE    (#) T N
;
	.byte	$07,$b8,$00,$8e,$91,150,$06
;
;	POS    (#) T N
;
	.byte	$07,$b9,$00,$8e,$91,173,$06
;
;	SQR    (#) T N
;
	.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
;
;	RND    (#) T N
;
	.byte	$07,$bb,$00,$8e,$91,180,$06
;
;	LOG    (#) T N
;
	.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
;
;	EXP    (#) T N
;
	.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
;
;	COS    (#) T N
;
	.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
;
;	SIN    (#) T N
;
	.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
;
;	TAN    (#) T N
;
	.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
;
;	ATN    (#) T N
;
	.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
;
;	PEEK    (#) T N
;
	.byte	$07,$c2,$00,$8e,$91,171,$06
;
;	LEN    ($) T N
;
	.byte	$07,$c3,$00,$8f,$91,162,$06
;
;	STR$    (#) T S
;
	.byte	$07,$c4,$00,$8e,$91,186,$07
;
;	VAL    ($) T N
;
	.byte	$07,$c5,$00,$8f,$91,194,$06
;
;	ASC    ($) T N
;
	.byte	$07,$c6,$00,$8f,$91,143,$06
;
;	CHR$    (#) T S
;
	.byte	$07,$c7,$00,$8e,$91,147,$07
;
;	LEFT$   ($,#) T S
;
	.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
;
;	RIGHT$    ($,#) T S
;
	.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
;
;	MID$   ($,# X:OptionalParameterCompile ) T S
;
	.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
;
;	NOT    X:NotUnaryCompile N
;
	.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
;
;	FN     X:FNCompile N
;
	.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
		;	.include "../../x16_compiler/generation/x16_unary.defc"
		.byte 	0

		.send  code		

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		generator.asm
;		Purpose:	Generation processor
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code
	
; ************************************************************************************************
;
;						Generator for data at YX, first token in A
;					  		CS succeed, A = type, CC = Fail.
;
; ************************************************************************************************

GeneratorProcess:
		stx 	zTemp0 						; save generation pointer in zTemp0
		sty 	zTemp0+1
		;
		sta 	zTemp1 						; first match token
		stz 	zTemp1+1
		;
		;		X16 shift of $CE
		;
		cmp 	#$CE 						; check if shift
		bne 	_GPNotShifted
		jsr 	GetNext 					; get the shifted token
		sta 	zTemp1+1 					; match CE xx
_GPNotShifted:
		;
		;		Find the generator entry.
		;		
_GPSearch:		
		lda 	(zTemp0) 					; reached end ?
		clc
		beq 	_GPExit
		;
		ldy 	#1 							; tokens match
		lda 	(zTemp0),y
		cmp 	zTemp1
		bne 	_GPNext

		lda 	zTemp1+1 					; 2nd token ?
		beq 	_GPFound

		iny 								; check match.
		cmp 	(zTemp0),y
		beq 	_GPFound
		;
_GPNext:	
		clc 								; follow to next
		lda 	zTemp0		
		adc 	(zTemp0)
		sta 	zTemp0
		bcc 	_GPSearch
		inc 	zTemp0+1
		bra 	_GPSearch
		;
_GPFound:	
		clc 								; skip to action bytes		
		lda 	zTemp0 						; <offset> <token lo> <token hi> first
		adc 	#3
		sta 	zTemp0
		bcc 	_GPNoCarry
		inc 	zTemp0+1
_GPNoCarry:
		;
		;		Main execution loop.
		;		
_GPLoop:
		jsr 	GeneratorExecute 			; execute one command
		bcc 	_GPLoop 					; go back if not completed.
		sec 								; return with CS.
_GPExit:
		rts

		.send  code		

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		genexec.asm
;		Purpose:	Generation executor
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code


; ************************************************************************************************
;
;						    Execute command pair at (zTemp0).
;					  	CS completed, A = type, CC = keep going.
;
; ************************************************************************************************

GeneratorExecute:
		jsr 	_GEFetchZTemp0 				; get next.
		pha 								; split into 2 nibbles
		lsr 	a
		lsr 	a
		lsr		a
		lsr 	a
		jsr 	_GEExecuteNibble 			; MSB first
		pla
		bcs 	_GEHaveCompleted
		jsr 	_GEExecuteNibble 			; LSB second
_GEHaveCompleted:		
		rts

; ------------------------------------------------------------------------------------------------
;										 Execute NIBL A
; ------------------------------------------------------------------------------------------------

_GEExecuteNibble:
		and 	#$0F
		asl 	a
		tax 	
		jmp 	(_GEExecuteVectors,x)

_GEExecuteVectors:
		.word 	_GEXNop 					; 0  (no operation)
		.word 	_GEXToken1 					; 1  (compile 1 byte token)
		.word 	_GEXToken2 					; 2  (compile 2 byte token)
		.word 	_GEXExecute 				; 3  (run arbitrary code)
		.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
		.word 	_GEXNop 					; 5
		.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
		.word 	_GEXExitString 				; 7  exit return string type
		.word 	_GEXLParam 					; 8  check ( follows
		.word 	_GEXRParam 					; 9  check ) follows
		.word 	_GEXComma					; A  check , follows
		.word 	_GEXNop 					; B
		.word 	_GEXNop 					; C
		.word 	_GEXNop 					; D  
		.word 	_GEXNumber 					; E  compile get any number
		.word 	_GEXString 					; F  compile get any string

; ------------------------------------------------------------------------------------------------
;									 No Operations / Unused
; ------------------------------------------------------------------------------------------------

_GEXNop:				
		clc
		rts

; ------------------------------------------------------------------------------------------------
;									Compile 1/2 byte tokens
; ------------------------------------------------------------------------------------------------

_GEXToken2:
		jsr 	_GEFetchZTemp0
		jsr 	WriteCodeByte
_GEXToken1:
		jsr 	_GEFetchZTemp0
		jsr 	WriteCodeByte
		rts

; ------------------------------------------------------------------------------------------------
;										Exit with types
; ------------------------------------------------------------------------------------------------

_GEXExitNumber:
		lda 	#NSSIFloat
		sec
		rts

_GEXExitString:
		lda 	#NSSString
		sec
		rts

; ------------------------------------------------------------------------------------------------
;								 Check various characters follow
; ------------------------------------------------------------------------------------------------

_GEXLParam:
		lda 	#"("
		bra 	_GEXCheck
_GEXRParam:
		lda 	#")"
		bra 	_GEXCheck
_GEXComma:
		lda 	#","
_GEXCheck:
		sta 	zTemp2 						; save match
		jsr 	GetNextNonSpace 			; get next skipping spaces
		cmp 	zTemp2 						; check matches.
		bne 	_GEXSyntax
		clc
		rts
_GEXSyntax:
		.error_syntax

; ------------------------------------------------------------------------------------------------
;								 		Fetch, various types.
; ------------------------------------------------------------------------------------------------

_GEXNumber: 	
		jsr 	GEXCompileExpression 		; compile expression
		and 	#NSSTypeMask
		cmp  	#NSSIFloat
		bne 	_GEXType 	
		clc
		rts

_GEXString: 	
		jsr 	GEXCompileExpression 		; compile expression
		and 	#NSSTypeMask
		cmp  	#NSSString
		bne 	_GEXType 	
		clc
		rts

_GEXType:
		.error_type

; ------------------------------------------------------------------------------------------------
;							Execute 6502 code with Channel Redirect
; ------------------------------------------------------------------------------------------------

_GEXChannelExec:
		jsr 	ChannelPrefix 				; set up default
		jsr 	_GEXExecute
		php
		jsr 	ChannelPostfix 				; replace default.
		plp
		rts
		.debug

; ------------------------------------------------------------------------------------------------
;										Execute 6502 code
; ------------------------------------------------------------------------------------------------

_GEXExecute:
		jsr 	_GEFetchZTemp0 				; get vector		
		sta 	zTemp2 		
		jsr 	_GEFetchZTemp0
		sta 	zTemp2+1 		

		ldx 	zTemp0 						; push generation exec on to stack for reentrancy
		phx
		ldx 	zTemp0+1
		phx

		jsr 	_GECallZTemp2 				; execute code

		plx 								; recover generation exec
		stx 	zTemp0+1
		plx
		stx 	zTemp0
		rts		

_GECallZTemp2:
		jmp 	(zTemp2)		

; ------------------------------------------------------------------------------------------------
;										Get the next byte.
; ------------------------------------------------------------------------------------------------

_GEFetchZTemp0:
		lda 	(zTemp0)
		inc 	zTemp0
		bne 	_GEFZ0Skip
		inc 	zTemp0+1
_GEFZ0Skip:
		rts		

; ------------------------------------------------------------------------------------------------
;								Compile expression preserve state
; ------------------------------------------------------------------------------------------------

GEXCompileExpression:
		ldx 	zTemp0 						; push generation exec on to stack for reentrancy
		phx
		ldx 	zTemp0+1
		phx
		jsr 	CompileExpressionAt0 		; compile expression.
		plx 								; recover generation exec
		stx 	zTemp0+1
		plx
		stx 	zTemp0
		rts		

; ************************************************************************************************
;
;									Channel Prefix code.
;
; ************************************************************************************************

ChannelPrefix:
		lda 	#PCD_GETCHANNEL				; set channel onto stack
		jsr 	WriteCodeByte
		jsr 	GEXCompileExpression 		; channel #
		and 	#NSSTypeMask
		cmp 	#NSSIFloat
		bne 	_CPXType
		jsr 	CheckNextComma 				; check , follows.
		lda 	#PCD_SETCHANNEL				; set channel
		jsr 	WriteCodeByte
		rts
_CPXType:
		.error_type

; ************************************************************************************************
;
;									Channel Prefix code.
;
; ************************************************************************************************

ChannelPostfix:
		lda 	#PCD_SETCHANNEL				; set channel from TOS.
		jsr 	WriteCodeByte
		rts

		.send  code		

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		gensupport.asm
;		Purpose:	Support functions for generation
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;		MID$ has a support function because it has different numbers of parameters.
;		e.g. MID$(a$,b,c) or MID$(a$,b)
;
; ************************************************************************************************

OptionalParameterCompile:
		jsr 	LookNextNonSpace 			; what follows.
		;
		cmp 	#","
		bne 	_MidDefault
		jsr 	GetNext 					; consume ,
		jsr 	CompileExpressionAt0
		and 	#NSSTypeMask
		cmp 	#NSSIFloat
		bne 	MidFailType
		bra 	_MidComplete
_MidDefault:
		lda 	#255 						; default of 255
		jsr 	PushIntegerA
_MidComplete:
		clc
		rts

MidFailType:
		.error_type

; ************************************************************************************************
;
;		NOT has a support function as its single expression parameter is done part way
;		up precedence
;
; ************************************************************************************************

NotUnaryCompile:
											; precedence of comparators
		lda 	PrecedenceTable+C64_EQUAL-C64_PLUS		
		jsr 	CompileExpressionAtA 		; evaluate at that level
		and 	#NSSTypeMask 				; check compile returns number.
		cmp 	#NSSIFloat
		bne 	MidFailType
		lda 	#PCD_NOT 					; and NOT it.
		jsr 	WriteCodeByte		
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		get.asm
;		Purpose:	Support functions.
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;											Code Reads
;
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Examine next character
;
; ************************************************************************************************

LookNext:
		lda 	(srcPtr) 
		rts

; ************************************************************************************************
;
;								Examine next non space character
;
; ************************************************************************************************		

LookNextNonSpace:
		lda 	(srcPtr)
		cmp		#' '
		beq 	_LNNSkip
		cmp 	#0
		rts
_LNNSkip:
		jsr 	GetNext
		bra 	LookNextNonSpace
				
; ************************************************************************************************
;
;										Get next character
;
; ************************************************************************************************

GetNext:
		lda 	(srcPtr) 					; get next
		inc 	srcPtr
		bne 	_GNSkip
		inc 	srcPtr+1
_GNSkip:		
		cmp 	#0
		rts
		
; ************************************************************************************************
;
;								  Get next non-space character
;
; ************************************************************************************************

GetNextNonSpace:
		jsr 	GetNext
		cmp 	#' '
		beq 	GetNextNonSpace
		cmp 	#0
		rts

; ************************************************************************************************
;
;						   Check if digit (CS = true, CC = false)
;
; ************************************************************************************************

CharIsDigit:
		cmp 	#"0"
		bcc 	CCFalse
		cmp 	#"9"+1
		bcs 	CCFalse
CCTrue:
		sec
		rts
CCFalse:
		clc
		rts

; ************************************************************************************************
;
;						   Check if alpha (CS = true, CC = false)
;
; ************************************************************************************************

CharIsAlpha:
		cmp 	#"A"
		bcc 	CCFalse
		cmp 	#"Z"+1
		bcs 	CCFalse
		bra 	CCTrue

; ************************************************************************************************
;
;				Convert to hex-style, e.g. 0-9 => 0-9, A-Z 10-35, CS true, CC false
;
; ************************************************************************************************

ConvertHexStyle:
		sec
		sbc 	#"0" 						; check in range 0-9 first
		bcc 	CCFalse
		cmp 	#9+1
		bcc 	CCTrue
		;
		sec 								; shift into hex space A=>0 Z=>25
		sbc 	#"A"-"0"
		bcc 	CCFalse
		cmp 	#26 						; past Z ?
		bcs 	CCFalse
		adc 	#10 						; make valid quasi-hex 0-35
		bra 	CCTrue

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		get.asm
;		Purpose:	Get from input
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Get input (also GET#)
;
; ************************************************************************************************

CommandGET:
		jsr 	LookNextNonSpace 			; # follows ?
		cmp 	#"#"
		bne 	CommandGetBody
		;
		jsr 	GetNext 					; consume #
		jsr 	ChannelPrefix 				; do it as GET#
		jsr 	CommandGetBody
		jsr 	ChannelPostfix
		rts

CommandGetBody:
		jsr 	GetNextNonSpace 			; get the first character
		jsr 	GetReferenceTerm 			; identify variable to assign to
		pha
		and 	#NSSTypeMask 				; check if it is a string
		cmp 	#NSSString
		bne 	_CGType

		lda 	#PCD_GET 					; compile GET
		jsr 	WriteCodeByte
		sec
		pla
		jsr		GetSetVariable
		rts

_CGType:
		.error_type

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		getname.asm
;		Purpose:	Get variable name
;		Created:	25th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;				  Extract a reference object name (variable, array, function)
;					  to XY. Error if failed. On entry A contains first
;
; ************************************************************************************************

		.section code

ExtractVariableName:
		jsr 	CharIsAlpha
		bcc 	_IVSyntax
		;
		;		One or two character variable ?
		;
		and 	#31 						; reduce first character to 5 bits
		sta 	zTemp1 						; we'll build it in zTemp1
		stz 	zTemp1+1
		;
		jsr 	LookNext 					; is there a second character ?
		jsr 	CharIsAlpha  				; must be alphanumeric 
		bcs 	_IVHasSecond
		jsr 	CharIsDigit
		bcc 	_IVCheckType
_IVHasSecond:
		and 	#63 						; 6 bit ASCII.
		sta 	zTemp1+1
_IVGetNextCheck:		
		jsr 	GetNext 					; consume it
		;
		;		Check for % $ postfix.
		;
_IVCheckType:
		jsr 	LookNext					; check if string follows.
		jsr 	CharIsAlpha
		bcs 	_IVGetNextCheck
		jsr 	CharIsDigit
		bcs 	_IVGetNextCheck

		ldx 	#NSSString
		cmp 	#"$"
		beq 	_IVHasType
		ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
		cmp 	#"%"
		bne 	_IVCheckArray
_IVHasType:
		txa 								; Or X into zTemp1
		ora 	zTemp1
		sta 	zTemp1		
		jsr 	GetNext 					; consume it
		;
		;		Check for ( postfix
		;
_IVCheckArray:
		jsr 	LookNext 					; check if array follows
		cmp 	#"("
		bne 	_IVNotArray
		lda 	zTemp1 						; set array bit
		ora 	#NSSArray
		sta 	zTemp1		
		jsr 	GetNext 					; consume it
_IVNotArray:		
		ldx 	zTemp1
		ldy 	zTemp1+1
		rts

_IVSyntax:
		.error_syntax
		
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		gosub.asm
;		Purpose:	Gosub/Return command
;		Created:	19th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											GOTO
;
; ************************************************************************************************

CommandGOSUB: 
		lda 	#PCD_CMD_GOSUB
		jsr 	CompileBranchCommand
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		goto.asm
;		Purpose:	Goto command
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											GO TO
;
; ************************************************************************************************

CommandGOAlt:
		lda 	#C64_TO 					; GO TO alternative
		jsr 	CheckNextA
		bra 	CommandGOTO

; ************************************************************************************************
;
;											GOTO
;
; ************************************************************************************************

CommandGOTO: 
		lda 	#PCD_CMD_GOTO
		jsr 	CompileBranchCommand
		rts

; ************************************************************************************************
;
;						Compile a branch (GOTO/GOSUB) with following line #
;
; ************************************************************************************************

CompileBranchCommand:
		jsr 	WriteCodeByte 				; write the command out.
		jsr 	GetNextNonSpace
		jsr 	ParseConstant 				; get constant into YA
		bcc 	_CBCSyntax

		pha
		lda 	#$FF 						; no address yet.
		jsr 	WriteCodeByte
		pla 								; and compile the actual line number
		jsr 	WriteCodeByte
		tya
		jsr 	WriteCodeByte
		rts		

_CBCSyntax:
		.error_syntax

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		if.asm
;		Purpose:	If command
;		Created:	19th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											IF
;
; ************************************************************************************************

CommandIF: 		
		jsr 	LookNextNonSpace 			; what follows the tests ?
		cmp 	#C64_GOTO 					; IF .. GOTO
		beq 	_CIGoto
		;
		lda 	#C64_THEN 					; should be THEN
		jsr 	CheckNextA
		;
		jsr 	LookNextNonSpace 			; THEN <number>
		jsr 	CharIsDigit
		bcs 	_CIGoto2
		bra 	CompileGotoEOL

_CIGoto:	
		jsr 	GetNext
_CIGoto2:		
		lda 	#PCD_CMD_GOTOCMD_NZ
		jsr 	CompileBranchCommand
		rts
		
CompileGotoEOL: 							; compile GOTOZ <next line>
		lda 	#PCD_CMD_GOTOCMD_Z
		jsr 	WriteCodeByte
		lda 	#$FF
		jsr 	WriteCodeByte

		jsr 	GetLineNumber 				; Get the current line number => YA
		inc 	a 							; and branch to +1
		bne 	_CGENoCarry
		iny
_CGENoCarry:		
		jsr 	WriteCodeByte
		tya
		jsr 	WriteCodeByte
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		input.asm
;		Purpose:	INPUT command
;		Created:	1st May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											INPUT
;
; ************************************************************************************************

CommandINPUT:
		jsr 	LookNextNonSpace 			; check for "
		cmp 	#'"'
		bne 	CommandINPUTStream
		jsr 	CompileExpressionAt0
		.keyword PCD_PRINTCMD_S
		lda 	#","
		jsr 	CheckNextComma
CommandINPUTStream:
		.keyword PCD_INPUTCMD_START 		; new INPUT.
		ldx 	#PCD_INPUT 					; do READ with Data from INPUT
		ldy 	#PCD_INPUTDOLLAR
		jmp 	CommandReadInputCommon

		.send code

; ************************************************************************************************
;
;		Notes:
;			INPUT has an optional prompt ; INPUT# skips this code <string> print.s
;			Do the actual input.
;			Ignore blank lines.
; 			Behaves like READ in that it will grab data read , store keep going until have
; 			everything, use of , and "" etc.
;
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		let.asm
;		Purpose:	Assignment statement
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Assignment statement
;
; ************************************************************************************************

CommandLET:
		jsr 	GetNextNonSpace 			; get the first character
CommandLETHaveFirst:
		jsr 	GetReferenceTerm 			; identify variable to assign to
		phx 								; save target on the stack.
		phy
		pha
		lda 	#C64_EQUAL 					; check next is =
		jsr 	CheckNextA
		jsr 	CompileExpressionAt0 		; evaluate the RHS.

		sta 	zTemp0 						; save type returned
		pla 								; get type of assignment
		pha
		eor 	zTemp0 						; compare using EOR
		and 	#NSSTypeMask 				; so we can mask type as we only need n/s
		bne 	_CLType

		pla 								; restore and compile save code
		ply
		plx

		cpy 	#$C0 						; is it TI$ = "xxxxx"
		beq 	_CLTIString
		sec
		jsr		GetSetVariable
		rts

_CLTIString:
		.keyword PCD_TIDOLLARCMD_WRITE
		rts
		
_CLType:
		.error_type

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		line.asm
;		Purpose:	Read in next line etc.
;		Created:	8th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						Read next line into buffer. reset PTR. CC if nothing.
;
; ************************************************************************************************

ReadNextLine:
		jsr 	INPUTGet 					; check offset is not zero.
		sta 	zTemp0
		jsr 	INPUTGet
		ora 	zTemp0
		bne 	_RNLBody 
		clc 		
		rts						; end of file.
_RNLBody:
		jsr 	INPUTGet 					; read and save line number
		sta 	currentLineNumber
		jsr 	INPUTGet
		sta 	currentLineNumber+1
		ldx 	#0 							; read line into buffer
_RNLRead:
		jsr 	INPUTGet		
		sta 	sourceBuffer,x
		inx
		cmp 	#0
		bne 	_RNLRead
		.set16 	srcPtr,sourceBuffer 		; start reading from the source buffer.
		sec
		rts

; ************************************************************************************************
;
;								Get line number of current line -> YA
;
; ************************************************************************************************		

GetLineNumber:
		ldy 	currentLineNumber+1
		lda 	currentLineNumber
		rts

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		line.asm
;		Purpose:	Line Number Tracking
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Store current position, line YA
;
; ************************************************************************************************

STRMarkLine:
		pha
		sec 								; allocate 5 bytes (line #, page+address)
		lda 	lineNumberTable 			; and copy to zTemp0
		sbc 	#5
		sta 	lineNumberTable
		sta 	zTemp0
		lda 	lineNumberTable+1
		sbc 	#0
		sta 	lineNumberTable+1
		sta 	zTemp0+1

		.storage_access
		pla
		sta 	(zTemp0) 					; save it in +0,+1
		tya
		ldy 	#1
		sta 	(zTemp0),y
		;
		lda 	objPage 					; and page# in +2
		iny
		sta 	(zTemp0),y

		lda 	objPtr 						; save current address in +3,+4
		iny
		sta 	(zTemp0),y
		lda 	objPtr+1
		iny
		sta 	(zTemp0),y

		.storage_release
		rts

; ************************************************************************************************
;
;				Line number YA - find in table, return page X address YA 
;				
;				If FOUND: of the matching line, with Carry Clear.
;				If NOT FOUND : of the previous line (e.g. next code line), with Carry Set.
;
; ************************************************************************************************

STRFindLine:
		.storage_access

		sta 	zTemp0 						; zTemp0 line number being searched
		sty 	zTemp0+1
		.set16 	zTemp1,WorkArea+WorkAreaSize ; work backwards through table

_STRSearch:
		jsr 	_STRPrevLine 				; look at previous record.

		ldy 	#1
		lda 	(zTemp1) 					; check table line # >= target
		cmp 	zTemp0
		lda 	(zTemp1),y
		sbc 	zTemp0+1
		bcs 	_STRFound 					; >=
_STRNext: 									; next table entry.
		ldy 	#1 							; should not be required !
		lda 	(zTemp1),y
		cmp 	#$FF
		bne 	_STRSearch
		.error_internal

_STRFound:
		lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
		eor 	zTemp0
		bne 	_STRDifferent
		lda 	(zTemp1)
		eor 	zTemp0
		beq 	_STROut 					; if zero, exit with A = 0 and correct line.
_STRDifferent:
		lda 	#$FF 						
_STROut:
		clc  								; set carry if different, e.g. > rather than >=
		adc 	#255 				
		php
		iny 								; page into X
		lda 	(zTemp1),y
		tax
		iny 								; address into YA
		lda 	(zTemp1),y
		pha
		iny
		lda 	(zTemp1),y
		tay
		pla	
		.storage_release
		plp	
		rts

_STRPrevLine:
		sec 								; move backwards one entry.
		lda 	zTemp1
		sbc 	#5
		sta 	zTemp1
		lda 	zTemp1+1
		sbc 	#0
		sta 	zTemp1+1
		rts
; ************************************************************************************************
;
;								Make position X:YA to Offset X:YA
;
; ************************************************************************************************

STRMakeOffset:
		clc 								; borrow 1
		sbc 	objPtr
		pha
		tya
		sbc 	objPtr+1
		tay
		pla
		rts
		
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		nex.asm
;		Purpose:	NEXT compile
;		Created:	20th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Compile NEXT command
;
;								   Creates [Reference|$FFFF] NEXT
;
; ************************************************************************************************

CommandNEXT: 
		;
		;		NEXT [variable]
		;
		jsr 	LookNextNonSpace 			; first letter of index variable, should be.
		jsr 	CharIsAlpha 				; if not alpha , error
		bcc 	_CNNoReferenceGiven
		jsr 	GetNext
		jsr 	GetReferenceTerm 			; figure out the reference.
		txa 								; reference in YA
		jsr 	PushIntegerYA 				; write it out.
		bra 	_CNParametersDone
_CNNoReferenceGiven:
		lda 	#255 						; write out -1 no
		tay
		jsr 	PushIntegerYA 				; write it out.
_CNParametersDone:
		lda 	#PCD_NEXT  					; compile FOR word.
		jsr 	WriteCodeByte

		jsr 	LookNextNonSpace 			; look for , 
		cmp 	#","
		bne 	_CNExit
		jsr 	GetNext 					; consume ,
		bra 	CommandNEXT 				; and go round.

_CNExit:
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		on.asm
;		Purpose:	ON compiler
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											Compile ON
;
; ************************************************************************************************

CommandON:
		jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
		pha 								; save on stack

		ldx 	#PCD_CMD_GOTO
		cmp 	#C64_GOTO 					; must be GOTO/GOSUB
		beq 	_COCreateLoop
		ldx 	#PCD_CMD_GOSUB
		cmp 	#C64_GOSUB
		beq 	_COCreateLoop
		.error_syntax

_COCreateLoop:
		txa 								; compile a goto/gosub somewhere
		phx
		jsr 	CompileBranchCommand		
		plx
		jsr 	LookNextNonSpace			; ',' follows
		cmp 	#"," 						
		bne 	_COComplete 				; if so, more line numbers
		lda 	#PCD_MOREON 				; ON extends.
		jsr 	WriteCodeByte
		jsr 	GetNext
		bra 	_COCreateLoop

_COComplete:
		pla 								; throw GOTO/GOSUB
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		open.asm
;		Purpose:	Open/Reopen the output
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Reset the output system
;						(note this is all gone throught TWICE)
;
; ************************************************************************************************

OUTPUTOpen:
OUTPUTRewind:
		stz 	objPage
		.set16 	objPtr,PCodeStart
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		parsenumber.asm
;		Purpose:	Parse numeric constant
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;				Parse numeric constant into stack level 0, first char is in A
;				   Return CS if legitimate 16 bit +ve int with value in YA
;
; ************************************************************************************************

ParseConstant:
		ldx 	#0 
		jsr 	FloatEncodeStart 			; send first
_ParseLoop:
		jsr 	LookNext 					; send subsequent
		jsr 	FloatEncodeContinue
		bcc 	_ParseDone
		jsr 	GetNext 					; consume it
		bra 	_ParseLoop

_ParseDone:
		lda 	NSStatus,x 					; shouldn't be -ve ....
		and 	#$80
		ora 	NSExponent,x 				; 16 bit int check
		ora 	NSMantissa2,x
		ora 	NSMantissa3,x
		clc
		bne 	_ParseExit 					; exit with CC if need float to compile

		lda 	NSMantissa0,x 				; read into YA.
		ldy		NSMantissa1,x
		sec
_ParseExit:		
		rts		





		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
;
;	This file is automatically generated
;
.section code
MOFSizeTable:
	.byte	1         	; $ca .shift
	.byte	1         	; $cb .byte
	.byte	2         	; $cc .word
	.byte	5         	; $cd .float
	.byte	255       	; $ce .string
	.byte	255       	; $cf .data
	.byte	3         	; $d0 .goto
	.byte	3         	; $d1 .gosub
	.byte	3         	; $d2 .goto.z
	.byte	3         	; $d3 .goto.nz
	.byte	2         	; $d4 .varspace
.send code
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		print.asm
;		Purpose:	Print compilation
;		Created:	19th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						  					Print Command
;
; ************************************************************************************************

CommandPRINT:
		jsr 	LookNextNonSpace			; what follows ?
		cmp 	#";" 						; semicolon, check end of command
		beq 	_CPCheckEnd
		cmp 	#"," 						; , TAB and check end of command
		beq 	_CPTabCheckEnd	
		jsr 	_CPAtEnd 					; check for : and EOL
		bcs 	_CPExitCR 					; exit with CR
		;
		;		TODO check TAB( and SPC(
		;
		jsr 	CompileExpressionAt0 		; so it is something to print
		ldx 	#PCD_PRINTCMD_S
		and 	#NSSString 					; if string
		bne 	_CPOut
		ldx 	#PCD_PRINTCMD_N
_CPOut:
		txa 								; print that thing
		jsr 	WriteCodeByte		
		bra 	CommandPRINT 				; and loop round/
		;
		;		, comes here
		;
_CPTabCheckEnd:
		lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
		jsr 	WriteCodeByte
		;
		;		; comes here and ,  - if end command after no CR.
		;
_CPCheckEnd:
		jsr 	GetNext 					; consume it.
		jsr 	LookNextNonSpace 			; what follows ?
		jsr 	_CPAtEnd 					; reached end
		bcc 	CommandPRINT 				; no, loop back
		rts
		;
		;		: and EOL come here.
		;
_CPExitCR:
		lda 	#13 						; code to print CR
		jsr 	PushIntegerA		
		lda 	#PCD_PRINTCMD_CHR
		jsr 	WriteCodeByte
		rts

;
;		Check ending character, is it EOS or :
;
_CPAtEnd:
		cmp 	#0
		beq 	_CPIsEnd
		cmp 	#":"
		beq 	_CPIsEnd
		clc
		rts
_CPIsEnd:
		sec
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		read.asm
;		Purpose:	Compile READ Statements
;		Created:	22nd April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Compile a READ
;
; ************************************************************************************************

CommandREAD:
		ldx 	#PCD_READ
		ldy 	#PCD_READDOLLAR
;
;		Code shared by READ and INPUT
;
CommandReadInputCommon:
		stx 	numberPCode
		sty 	stringPCode
_CRLoop:				
		jsr 	GetNextNonSpace 			; first char of identifier
		jsr 	CharIsAlpha 				; check A-Z
		bcc 	_CRSyntax
		jsr 	GetReferenceTerm 			; get the variable.
		pha 								; save type.

		and 	#NSSTypeMask 				; is it a string ?
		cmp 	#NSSString
		beq 	_CRString
		lda 	numberPCode 				; output read/input
		bra 	_CRHaveType
_CRString:		
		lda 	stringPCode					; output read$/input$
_CRHaveType:		
		jsr 	WriteCodeByte 				; so we have one typed data item.
		pla 								; restore type
		sec  								; write update code.
		jsr 	GetSetVariable
		jsr 	LookNextNonSpace 			; , follows ?
		cmp 	#","
		bne 	_CRExit 					; if not, end of READ.
		jsr 	GetNext 					; consume comma
		bra 	_CRLoop 					; keep going
_CRExit:		
		rts		
_CRSyntax:
		.error_syntax

		.send code

		.section storage
numberPCode:	
		.fill 	1
stringPCode:
		.fill 	1
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		readwrite.asm
;		Purpose:	Generate code to read/write variables
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;					On entry YX is the address and A the type data (bits 7..5)
;						CS => generate write code, CC => generate read code
;
; ************************************************************************************************

GetSetVariable:
		php 								; save direction on stack
		cpy 	#$00
		bmi 	_GSVReadWriteSpecial
		cmp 	#$00
		bmi 	_GSVArray
		;
		; 		64-79 is float, 80-95 is integer, 96-111 is string. So we multiply the
		;		type bits 5 & 6 byte 16 - but they are already multiplied by 32, so
		;
		and 	#NSSTypeMask+NSSIInt16 		; get type bits
		lsr 	a 							; divide by 2
		ora 	#64 						; and set bit 6.
		;
		plp
		bcc 	_GSVNotWrite
		ora 	#8  						; set bit 3 if it is write.
_GSVNotWrite:
		sta 	zTemp0
		;
		tya 	 							; shift X/Y right as the address stored is halved
		lsr 	a
		tay 	
		txa 
		ror 	a
		tax
		;
		tya 								; lower 3 bits of YX are ORed into the opcode
		ora 	zTemp0 						; which is the first byte of the opcode
		jsr 	WriteCodeByte
		;
		txa 								; and the lower 8 bits of YX are the second byte
		jsr 	WriteCodeByte
		rts
		;
		;		Special read/writes
		;
_GSVReadWriteSpecial:
		;
		;		TODO: TI TI$ code missing		
		;
		plp
		bcs 	_GSVSyntax		
		;
		;		Handle clock read
		;
		cpy 	#$C0 						; TI$ ?
		beq 	_GSVRWString
		.keyword PCD_TI
		rts
_GSVRWString:
		.keyword PCD_TIDOLLAR
		rts		

_GSVSyntax:
		.error_syntax
		;
		;		For arrays use the indirection @ %@ $@ ! %! $!
		;
_GSVArray:
		and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
		lsr 	a		 					; shift from 5,6 to 0,1
		lsr 	a		
		lsr 	a		
		lsr 	a		
		lsr 	a				
		plp 								; if writing array then set bit 2.
		bcc 	_GSVANotWrite
		ora 	#4
_GSVANotWrite:		
		ora 	#$78 						; make a valid opcode.
		jsr 	WriteCodeByte 				; and write it out
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		refterm.asm
;		Purpose:	Get reference term
;		Created:	25th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;		On entry, A contains the first character.  Extract the variable name and locate it
;		creating if necessary, returning offset in YX, type in A.
;
; ************************************************************************************************

		.section code

GetReferenceTerm:
		jsr 	ExtractVariableName 		; get name & type info
		cpx 	#0 							; check for array handler
		bmi 	_GRTArray
		phx 								; save type on stack
		jsr 	FindVariable 				; find it
		bcs 	_GRTNoCreate 				; create if required.
		jsr 	CreateVariableRecord 		; create a variable.
		jsr 	AllocateBytesForType 		; allocate memory for it
_GRTNoCreate:		
		pla 								; get type back, strip out type information.
		and 	#NSSTypeMask+NSSIInt16
		rts		
	
_GRTArray:
		phx 								; save type information 		
		jsr 	FindVariable 				; read its data, the base address in YX
		bcc 	_GRTUndeclared 				; undeclared array.
		phx 								; save base address
		phy
		jsr 	OutputIndexGroup 			; create an index group and generate them
		ply 								; get the array base address into YX
		plx
		lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
		clc
		jsr 	GetSetVariable 				; load the address of the array structure.
		.keyword PCD_ARRAY 					; convert that to an offset.

		pla 								; and the type data into A
		and 	#NSSTypeMask+NSSIInt16
		ora 	#$80 						; with the array flag set.
		rts		

_GRTUndeclared:
		.error_undeclared

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		rem.asm
;		Purpose:	Handle remark (ignore to EOL)
;		Created:	20th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								REM consumes the rest of the line.
;
; ************************************************************************************************

CommandREM: 
		jsr 	LookNext
		beq 	_CRExit
		jsr 	GetNext
		bra 	CommandREM
_CRExit:		
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		reset.asm
;		Purpose:	Reset information storage
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Reset the storage (variables,line#)
;
; ************************************************************************************************

STRReset:
		.set16  variableListEnd,WorkArea 	; set up the two table pointers
		.set16 	lineNumberTable,WorkArea+WorkAreaSize
		.storage_access 					; clear the head of the work area list.
		stz 	WorkArea
		.storage_release
		.set16 freeVariableMemory,0 		; clear the free variable memory record.
		rts
		.send code


		.section storage
lineNumberTable:							; line number table, works down.
		.fill 	2		
variableListEnd:							; known variables, works up.
		.fill 	2	
freeVariableMemory: 						; next free memory slot
		.fill 	2			
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		term.asm
;		Purpose:	Compile Code to Evaluate a term
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;			Compile code to evaluate a term. Will return in A, bits 6,5 the type of that
;			term which will either be 00 (float/int16) or 10 (string).
;
;			Terms can be :
; 				[A-Z][A-Z0-9]* 	variable/array - a reference is obtained, and the code to push this generated.
;				[0-9.]* 		numeric decimal constant
;				$[0-9A-F]* 		hexadecimal integer constant
;				%[0-1]* 		binary integer constant
;				".*?"			string constant
;				- <Term> 		A negated term (must be integer/float)
;				<Unary Token>	A unary function
;				(<expression>)	An expression.
;
; ************************************************************************************************

CompileTerm:
		jsr 	GetNextNonSpace 			; get first non space character.
		bmi 	_CTUnaryFunctions

		jsr 	CharIsDigit 				; found a number
		bcs 	_CTDigit
		cmp 	#"."
		beq 	_CTDigit

		cmp 	#'"' 						; found a string ?
		beq 	_CTString

		cmp 	#"%"						; binary or hexadecimal ?
		beq 	_CTOtherBase
		cmp 	#"$"
		beq 	_CTOtherBase

		cmp 	#"(" 						; check parenthesis
		beq 	_CTBrackets

		cmp 	#"A" 						; check variable/array ?
		bcc 	_CTSyntax
		cmp 	#"Z"+1
		bcs 	_CTSyntax

		jsr 	GetReferenceTerm 			; figure out what it is.
		pha 								; save type on stack
		clc 								; read it
		jsr 	GetSetVariable 			
		pla
		and 	#NSSTypeMask 				; reduce to basic type
		rts	

_CTSyntax:
		.error_syntax
		;
		;		Handle parenthesis
		;
_CTBrackets:
		jsr 	CompileExpressionAt0		
		pha
		jsr 	CheckNextRParen
		pla
		rts
		;
		;		Handle other base
		;
_CTOtherBase:
		jsr 	InlineNonDecimal 			; non decimal constant handler		
		lda 	#NSSIFloat					; return a iFloat32 integer
		rts
		;
		;		Compile a number
		;
_CTDigit:			
		jsr 	ParseConstant 				; parse out an number, first is in A already.
		bcc	 	_CTFloat 					; have a float or long int.
		jsr 	PushIntegerYA 				; code to push on stack
		lda 	#NSSIFloat					; return a iFloat32 integer
		rts
_CTFloat:
		jsr 	PushFloat  					; code to push float
		lda 	#NSSIFloat 					; return a iFloat32
		rts		
		;
		;		Compile a string
		;
_CTString:
		jsr 	BufferClear 				; copy it to the buffer
_CTStringLoop:
		jsr 	LookNext 					; reached EOL/EOS
		beq 	_CTSyntax
		cmp 	#'"'
		beq 	_CTStringDone
		;
		jsr 	BufferWrite 				; write and consume
		jsr 	GetNext
		bra 	_CTStringLoop
_CTStringDone:
		jsr 	GetNext 					; consume closing quote.
		lda 	#PCD_CMD_STRING 			; output command and buffer
		jsr 	WriteCodeByte
		jsr 	BufferOutput
		lda 	#NSSString 					; string type
		rts		
		;
		;		Handle unary functions and negation, as - is a C64 token
		;
_CTUnaryFunctions:		
		cmp 	#C64_MINUS 					; negation of term.
		beq 	_CTNegation

		ldx 	#UnaryTables & $FF 			; check vs unary tables.
		ldy 	#UnaryTables >> 8
		jsr 	GeneratorProcess
		bcc		_CTSyntax 	
		rts
		;
		;		Negate a number
		;	
_CTNegation:
		jsr 	CompileTerm 				; compile a term.
		pha
		and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
		cmp 	#NSSIFloat
		bne 	_CTType 					; error
		lda 	#PCD_NEGATE 				; compile negate
		jsr 	WriteCodeByte		
		pla 								; return original type.
		rts
_CTType:
		.error_type		
		
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		wait.asm
;		Purpose:	Handle Wait (optional parameter)
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										WAIT a,b [already done]
;
; ************************************************************************************************

CommandWAIT: 
		jsr 	LookNextNonSpace
		cmp 	#","
		beq 	_CWThirdParameter
		lda 	#0
		jsr 	PushIntegerA
_CWExit:		
		.keyword PCD_WAIT
		rts

_CWThirdParameter:
		jsr 	GetNext
		jsr 	CompileExpressionAtA
		and 	#NSSTypeMask
		cmp 	#NSSIFloat
		beq 	_CWExit
		.error_type

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		writebyte.asm
;		Purpose:	Write a single byte to the output.
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Write A to output (raw)
;
; ************************************************************************************************

OUTPUTWriteByte:
		sta 	(objPtr)
		inc 	objPtr
		bne 	_HWOWBNoCarry
		inc 	objPtr+1
_HWOWBNoCarry:		
		rts
		
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_cmd.asm
;		Purpose:	CMD command
;		Created:	24th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											CMD command
;
; ************************************************************************************************

CommandCMD:
		lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
		jsr 	WriteCodeByte
		jsr 	LookNextNonSpace 			; followed by a , ?
		cmp 	#","
		bne 	_CCMDExit
		jsr 	GetNext 					; consume comma.
		jsr 	CommandPRINT 				; do the print code
_CCMDExit:
		rts		
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_open.asm
;		Purpose:	OPEN command
;		Created:	2nd May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						OPEN command - first 2 are already on the stack.
;
;		supports 	OPEN #,#
;					OPEN #,#,#
;					OPEN #,#,$
;					OPEN #,#,#,$
;
;		Adds dummies so whatever there are three integers and a string compiled.
;
; ************************************************************************************************

CommandOPEN:
		jsr 	LookNextNonSpace 			; followed by a , ?
		cmp 	#","
		bne 	_COTwoDefaults
		jsr 	GetNext 					; consume comma
		jsr 	CompileExpressionAt0 		; what follows could be text or number.
		and 	#NSSString 					; if a number want a string to follow
		beq 	_COThreeIntegers
		;
		;		n,n,$
		;
		lda 	#0		 					; so we have n,n,$,0 so swap !
		jsr 	PushIntegerA
		.keyword PCD_SWAP
		rts
		;
		;		Two numeric values, add default 0 and empty string.
		;
_COTwoDefaults:
		lda 	#0
		jsr 	PushIntegerA
_COCompileNullString:
		.keyword PCD_CMD_STRING
		lda 	#0
		jsr 	WriteCodeByte
		jsr 	WriteCodeByte
		rts		
		;
		;		Full constants e.g. 1,8,2 possibly no file name
		;
_COThreeIntegers:		
		jsr 	LookNextNonSpace 			; is there a , 
		cmp 	#","
		bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
		jsr 	GetNext
		jsr 	CompileExpressionAt0 		; should be a filename
		and 	#NSSString
		beq 	_COType
		rts
_COType:
		.error_type		
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		printchar.asm
;		Purpose:	Character output interface
;		Created:	8th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code
		
; ************************************************************************************************
;
;								Print character A to Screen/Error Stream
;
; ************************************************************************************************

XPrintCharacter
		pha
		phx
		phy
		jsr 	$FFD2
		ply
		plx
		pla
		rts
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_save.asm
;		Purpose:	Write out the object data.
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							Save compiled code from A:00 to YX
;
; ************************************************************************************************

XSaveMemory:
		phx
		phy
		pha

		lda 	#0 							; set LFS
		ldx 	#8
		ldy 	#0
		jsr 	$FFBA

		lda 	#8 							; set file name
		ldx 	#SaveName & $FF
		ldy 	#SaveName >> 8
		jsr 	$FFBD

		pla 								; set up the start address.
		sta 	zTemp0+1
		stz 	zTemp0

		lda 	#zTemp0 					; from index.
		ply 								; end in YX
		plx
		jsr 	$FFD8 						; write out.
		rts

SaveName:
		.text 	"CODE.BIN"
		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
