
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Sat Oct  7 09:22:49 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.1000					WrapperBoot:
.1000	a2 0a		ldx #$0a			ldx 	#APIDesc & $FF
.1002	a0 10		ldy #$10			ldy 	#APIDesc >> 8
.1004	20 41 11	jsr $1141			jsr 	StartCompiler
.1007	4c ff ff	jmp $ffff			jmp 	$FFFF
.100a					APIDesc:
>100a							.fill 	2
>100c	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>100d	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing file: testing/api/close.asm

.100e					APIOClose:
.100e	a9 40		lda #$40			lda 	#(PCodeStart >> 8)
.1010	a6 29		ldx $29				ldx 	objPtr
.1012	a4 2a		ldy $2a				ldy 	objPtr+1
.1014	20 71 10	jsr $1071			jsr 	APISaveMemory
.1017	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/fromram.asm

.1018					APIIOpen:
.1018	a9 a1		lda #$a1			lda 	#((EndProgram+2) & $FF)
.101a	85 22		sta $22				sta 	0+srcInputPtr
.101c	a9 26		lda #$26			lda 	#((EndProgram+2) >> 8) & $FF
.101e	85 23		sta $23				sta 	1+srcInputPtr
.1020					APIIClose:
.1020	60		rts				rts
.0022					srcInputPtr:
>0022							.fill 	2

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/line.asm

.1021					ReadNextLine:
.1021	b2 22		lda ($22)			lda 	(srcInputPtr) 			; reached the end of the program (address link = $0000)
.1023	a0 01		ldy #$01			ldy 	#1
.1025	11 22		ora ($22),y			ora 	(srcInputPtr),y
.1027	d0 02		bne $102b			bne 	_RNLBody
.1029	18		clc				clc
.102a	60		rts				rts									; end of file.
.102b					_RNLBody:
.102b	c8		iny				iny 								; read and save line number
.102c	b1 22		lda ($22),y			lda 	(srcInputPtr),y
.102e	8d 00 06	sta $0600			sta 	currentLineNumber
.1031	c8		iny				iny
.1032	b1 22		lda ($22),y			lda 	(srcInputPtr),y
.1034	8d 01 06	sta $0601			sta 	currentLineNumber+1
.1037	c8		iny				iny 								; first character of line.
.1038	a2 00		ldx #$00			ldx 	#0 							; read line into buffer
.103a					_RNLRead:
.103a	b1 22		lda ($22),y			lda 	(srcInputPtr),y 			; copy into buffer.
.103c	9d 00 04	sta $0400,x			sta 	srcBuffer,x
.103f	c8		iny				iny
.1040	e8		inx				inx
.1041	c9 00		cmp #$00			cmp 	#0
.1043	d0 f5		bne $103a			bne 	_RNLRead
.1045	98		tya				tya 								; advance src input pointer to next.
.1046	18		clc				clc
.1047	65 22		adc $22				adc 	srcInputPtr
.1049	85 22		sta $22				sta 	srcInputPtr
.104b	90 02		bcc $104f			bcc 	_RNLNoCarry
.104d	e6 23		inc $23				inc 	srcInputPtr+1
.104f					_RNLNoCarry:
.104f	a9 00		lda #$00			lda 	#((srcBuffer) & $FF)
.1051	85 24		sta $24				sta 	0+srcPtr
.1053	a9 04		lda #$04			lda 	#((srcBuffer) >> 8) & $FF
.1055	85 25		sta $25				sta 	1+srcPtr
.1057	38		sec				sec
.1058	60		rts				rts
.0400					srcBuffer:
>0400						.fill 	256

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/open.asm

.1059					APIOOpen:
.1059					APIORewind:
.1059	64 2b		stz $2b				stz 	objPage
.105b	a9 00		lda #$00			lda 	#((PCodeStart) & $FF)
.105d	85 29		sta $29				sta 	0+objPtr
.105f	a9 40		lda #$40			lda 	#((PCodeStart) >> 8) & $FF
.1061	85 2a		sta $2a				sta 	1+objPtr
.1063	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/writebyte.asm

.1064					APIOWriteByte:
.1064	92 29		sta ($29)			sta 	(objPtr)
.1066	e6 29		inc $29				inc 	objPtr
.1068	d0 02		bne $106c			bne 	_HWOWBNoCarry
.106a	e6 2a		inc $2a				inc 	objPtr+1
.106c					_HWOWBNoCarry:
.106c	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_config.inc

=$4000					PCodeStart = $4000

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_printchar.asm

.106d					APIOPrintCharacter
.106d	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1070	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_save.asm

.1071					APISaveMemory:
.1071	da		phx				phx
.1072	5a		phy				phy
.1073	48		pha				pha
.1074	a9 00		lda #$00			lda 	#0 							; set LFS
.1076	a2 08		ldx #$08			ldx 	#8
.1078	a0 00		ldy #$00			ldy 	#0
.107a	20 ba ff	jsr $ffba			jsr 	$FFBA
.107d	a9 08		lda #$08			lda 	#8 							; set file name
.107f	a2 93		ldx #$93			ldx 	#SaveName & $FF
.1081	a0 10		ldy #$10			ldy 	#SaveName >> 8
.1083	20 bd ff	jsr $ffbd			jsr 	$FFBD
.1086	68		pla				pla 								; set up the start address.
.1087	85 2d		sta $2d				sta 	zTemp0+1
.1089	64 2c		stz $2c				stz 	zTemp0
.108b	a9 2c		lda #$2c			lda 	#zTemp0 					; from index.
.108d	7a		ply				ply 								; end in YX
.108e	fa		plx				plx
.108f	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.1092	60		rts				rts
.1093					SaveName:
>1093	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Return to file: testing/testing.asm


;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
.0024					srcPtr:
>0024							.fill 	2
.0500					sourceBuffer:
>0500							.fill 	256
.0600					currentLineNumber:
>0600							.fill 	2
.109b					InlineNonDecimal:
.109b	a2 02		ldx #$02			ldx 	#2 							; get size in X
.109d	c9 25		cmp #$25			cmp 	#"%"
.109f	f0 02		beq $10a3			beq 	_INDBinary
.10a1	a2 10		ldx #$10			ldx 	#16
.10a3					_INDBinary:
.10a3	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.10a5	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.10a7	64 2c		stz $2c				stz 	zTemp0 						; zero result
.10a9	64 2d		stz $2d				stz 	zTemp0+1
.10ab					_INDLoop:
.10ab	20 1e 1a	jsr $1a1e			jsr 	LookNext 					; check next character
.10ae	20 5a 1a	jsr $1a5a			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.10b1	90 1f		bcc $10d2			bcc		_INDDone 					; didn't convert
.10b3	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.10b5	b0 1b		bcs $10d2			bcs 	_INDDone
.10b7	20 e1 10	jsr $10e1			jsr 	_INDShift 					; x 2 or x 16
.10ba	e0 02		cpx #$02			cpx 	#2
.10bc	f0 09		beq $10c7			beq 	_INDNotHex
.10be	20 e1 10	jsr $10e1			jsr 	_INDShift
.10c1	20 e1 10	jsr $10e1			jsr 	_INDShift
.10c4	20 e1 10	jsr $10e1			jsr 	_INDShift
.10c7					_INDNotHex:
.10c7	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.10c9	85 2c		sta $2c				sta 	zTemp0
.10cb	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume
.10ce	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.10d0	80 d9		bra $10ab			bra 	_INDLoop
.10d2					_INDDone:
.10d2	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.10d4	f0 08		beq $10de			beq 	_INDError
.10d6	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.10d8	a5 2c		lda $2c				lda 	zTemp0
.10da	20 cb 11	jsr $11cb			jsr 	PushIntegerYA
.10dd	60		rts				rts
.10de					_INDError:
.10de	4c 2e 1f	jmp $1f2e		jmp	ErrorV_syntax
.10e1					_INDShift:
.10e1	06 2c		asl $2c				asl 	zTemp0
.10e3	26 2d		rol $2d				rol 	zTemp0+1
.10e5	60		rts				rts
.10e6					GetLineNumber:
.10e6	ac 01 06	ldy $0601			ldy 	currentLineNumber+1
.10e9	ad 00 06	lda $0600			lda 	currentLineNumber
.10ec	60		rts				rts
.10ed					WriteCodeByte:
.10ed	48		pha				pha 								; save on stack
.10ee	da		phx				phx
.10ef	5a		phy				phy
.10f0	20 64 10	jsr $1064			jsr 	APIOWriteByte
.10f3	7a		ply				ply 								; restore from stack
.10f4	fa		plx				plx
.10f5	68		pla				pla
.10f6	60		rts				rts
.10f7					PrintCharacter
.10f7	48		pha				pha
.10f8	da		phx				phx
.10f9	5a		phy				phy
.10fa	20 6d 10	jsr $106d			jsr 	APIOPrintCharacter
.10fd	7a		ply				ply
.10fe	fa		plx				plx
.10ff	68		pla				pla
.1100	60		rts				rts
.1101					BufferClear:
.1101	9c 02 06	stz $0602			stz 	bufferSize
.1104	60		rts				rts
.1105					BufferWrite:
.1105	da		phx				phx
.1106	ae 02 06	ldx $0602			ldx 	bufferSize
.1109	9d 03 06	sta $0603,x			sta 	dataBuffer,x
.110c	ee 02 06	inc $0602			inc 	bufferSize
.110f	fa		plx				plx
.1110	60		rts				rts
.1111					BufferOutput:
.1111	ad 02 06	lda $0602			lda 	bufferSize
.1114	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1117	a2 00		ldx #$00			ldx 	#0
.1119					_BOLoop:
.1119	ec 02 06	cpx $0602			cpx 	bufferSize
.111c	f0 09		beq $1127			beq 	_BOExit
.111e	bd 03 06	lda $0603,x			lda 	dataBuffer,x
.1121	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1124	e8		inx				inx
.1125	80 f2		bra $1119			bra 	_BOLoop
.1127					_BOExit:
.1127	60		rts				rts
.0602					bufferSize:
>0602							.fill 	1
.0603					dataBuffer:
>0603							.fill 	256
.1128					CheckNextComma:
.1128	a9 2c		lda #$2c			lda	 	#","
.112a	80 06		bra $1132			bra 	CheckNextA
.112c					CheckNextRParen:
.112c	a9 29		lda #$29			lda	 	#")"
.112e	80 02		bra $1132			bra 	CheckNextA
.1130					CheckNextLParen:
.1130	a9 28		lda #$28			lda 	#"("
.1132					CheckNextA:
.1132	8d 03 07	sta $0703			sta 	checkCharacter 				; save test character
.1135					_CNALoop:
.1135	20 3a 1a	jsr $1a3a			jsr 	GetNextNonSpace 			; get next skipping spaces.
.1138	cd 03 07	cmp $0703			cmp 	checkCharacter 				; matches ?
.113b	f0 03		beq $1140			beq 	_CNAExit
.113d	4c 2e 1f	jmp $1f2e		jmp	ErrorV_syntax
.1140					_CNAExit:
.1140	60		rts				rts
.0703					checkCharacter:
>0703							.fill 	1
.1141					StartCompiler:
.1141	86 2c		stx $2c				stx 	zTemp0 						; access API
.1143	84 2d		sty $2d				sty 	zTemp0+1
.1145	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.1147	b2 2c		lda ($2c)			lda 	(zTemp0)
.1149	8d 05 07	sta $0705			sta 	APIVector
.114c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.114e	8d 06 07	sta $0706			sta 	APIVector+1
.1151	c8		iny				iny 								; copy data area range.
.1152	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1154	8d 07 07	sta $0707			sta 	compilerStartHigh
.1157	c8		iny				iny
.1158	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.115a	8d 08 07	sta $0708			sta 	compilerEndHigh
.115d	ba		tsx				tsx 								; save stack pointer
.115e	8e 04 07	stx $0704			stx 	compilerSP
.1161	20 d3 1d	jsr $1dd3			jsr 	STRReset 					; reset storage (line#, variable)
.1164	20 18 10	jsr $1018			jsr 	APIIOpen 					; reset data input
.1167	20 59 10	jsr $1059			jsr 	APIOOpen 					; reset data output.
.116a	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.116c	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.116f	a9 00		lda #$00			lda 	#0
.1171	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1174	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1177					MainCompileLoop:
.1177	20 21 10	jsr $1021			jsr 	ReadNextLine 				; read next line into the buffer.
.117a	90 2e		bcc $11aa			bcc 	SaveCodeAndExit 			; end of source.
.117c	20 e6 10	jsr $10e6			jsr 	GetLineNumber 				; get line #
.117f	20 b4 1b	jsr $1bb4			jsr 	STRMarkLine 				; remember the position and number of this line.
.1182	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.1184	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1187					_MCLSameLine:
.1187	20 3a 1a	jsr $1a3a			jsr 	GetNextNonSpace 			; get the first character.
.118a	f0 eb		beq $1177			beq 	MainCompileLoop 			; end of line, get next line.
.118c	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.118e	f0 f7		beq $1187			beq 	_MCLSameLine
.1190	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.1192	10 0c		bpl $11a0			bpl 	_MCLCheckAssignment
.1194	a2 fb		ldx #$fb			ldx 	#CommandTables & $FF 		; do command tables.
.1196	a0 15		ldy #$15			ldy 	#CommandTables >> 8
.1198	20 c3 18	jsr $18c3			jsr 	GeneratorProcess
.119b	b0 ea		bcs $1187			bcs 	_MCLSameLine 				; keep trying to compile the line.
.119d					_MCLSyntax:
.119d	4c 2e 1f	jmp $1f2e		jmp	ErrorV_syntax
.11a0					_MCLCheckAssignment:
.11a0	20 50 1a	jsr $1a50			jsr 	CharIsAlpha 				; if not alpha then syntax error
.11a3	90 f8		bcc $119d			bcc 	_MCLSyntax
.11a5	20 82 1b	jsr $1b82			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.11a8	80 dd		bra $1187			bra		_MCLSameLine 				; loop back.
.11aa					SaveCodeAndExit:
.11aa	20 20 10	jsr $1020			jsr 	APIIClose 					; finish input.
.11ad	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.11af	a8		tay				tay
.11b0	20 b4 1b	jsr $1bb4			jsr 	STRMarkLine
.11b3	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.11b5	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.11b8	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.11ba	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.11bd	20 e7 14	jsr $14e7			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.11c0	20 0e 10	jsr $100e			jsr 	APIOClose
.11c3					ExitCompiler:
.11c3	ae 04 07	ldx $0704			ldx 	compilerSP 					; reload SP and exit.
.11c6	9a		txs				txs
.11c7	60		rts				rts
.11c8					CallAPIHandler:
.11c8	6c 05 07	jmp ($0705)			jmp 	(APIVector)
.0704					compilerSP:
>0704							.fill 	1
.0705					APIVector:
>0705							.fill 	2
.0707					compilerStartHigh:
>0707							.fill 	1
.0708					compilerEndHigh:
>0708							.fill 	1
.11cb					PushIntegerYA:
.11cb	c0 00		cpy #$00			cpy 	#0 							; 0-255
.11cd	f0 0f		beq $11de			beq 	PushIntegerA
.11cf	48		pha				pha
.11d0	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.11d2	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.11d5	68		pla				pla 								; then LSB
.11d6	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.11d9	98		tya				tya 								; then MSB
.11da	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.11dd	60		rts				rts
.11de					PushIntegerA:
.11de	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.11e0	90 07		bcc $11e9			bcc 	_PIWriteA
.11e2	48		pha				pha
.11e3	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.11e5	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.11e8	68		pla				pla
.11e9					_PIWriteA:
.11e9	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.11ec	60		rts				rts
.11ed					PushFloat:
.11ed	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.11ef	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.11f2	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.11f4	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.11f7	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.11f9	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.11fc	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.11fe	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1201	b5 56		lda $56,x			lda 	NSMantissa2,x
.1203	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1206	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.1208	29 80		and #$80			and 	#$80
.120a	15 62		ora $62,x			ora 	NSMantissa3,x
.120c	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.120f	60		rts				rts
.1210					CreateVariableRecord:
.1210	48		pha				pha
.1211	ad 13 07	lda $0713			lda 	freeVariableMemory 		; push current free address on stack.
.1214	48		pha				pha
.1215	ad 14 07	lda $0714			lda 	freeVariableMemory+1
.1218	48		pha				pha
.1219	ad 11 07	lda $0711			lda 	variableListEnd  		; copy end of list to zTemp0
.121c	85 2c		sta $2c				sta 	zTemp0
.121e	ad 12 07	lda $0712			lda 	variableListEnd+1
.1221	85 2d		sta $2d				sta 	zTemp0+1
.1223	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.1225	92 2c		sta ($2c)			sta 	(zTemp0)
.1227	98		tya				tya
.1228	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.122a	91 2c		sta ($2c),y			sta 	(zTemp0),y
.122c	88		dey				dey
.122d	8a		txa				txa
.122e	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1230	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.1232	ad 13 07	lda $0713			lda 	freeVariableMemory
.1235	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1237	c8		iny				iny
.1238	ad 14 07	lda $0714			lda 	freeVariableMemory+1
.123b	91 2c		sta ($2c),y			sta 	(zTemp0),y
.123d	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.123f	a9 00		lda #$00			lda 	#0
.1241	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1243	18		clc				clc
.1244	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.1246	6d 11 07	adc $0711			adc  	variableListEnd
.1249	8d 11 07	sta $0711			sta 	variableListEnd
.124c	90 03		bcc $1251			bcc 	_CVNoCarry2
.124e	ee 12 07	inc $0712			inc 	variableListEnd+1
.1251					_CVNoCarry2:
.1251	7a		ply				ply
.1252	fa		plx				plx
.1253	68		pla				pla
.1254	60		rts				rts
.1255					SetVariableRecordToCodePosition:
.1255	48		pha				pha
.1256	5a		phy				phy
.1257	a5 2b		lda $2b				lda 	objPage
.1259	a0 03		ldy #$03			ldy 	#3
.125b	91 2c		sta ($2c),y			sta 	(zTemp0),y
.125d	c8		iny				iny
.125e	a5 2a		lda $2a				lda 	objPtr+1
.1260	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1262	c8		iny				iny
.1263	a5 29		lda $29				lda 	objPtr
.1265	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1267	7a		ply				ply
.1268	68		pla				pla
.1269	60		rts				rts
.126a					AllocateBytesForType:
.126a	48		pha				pha
.126b	da		phx				phx
.126c	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.126e	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1270	c9 00		cmp #$00			cmp 	#NSSIFloat
.1272	d0 02		bne $1276			bne 	_CVNotFloat
.1274	a2 06		ldx #$06			ldx 	#6
.1276					_CVNotFloat:
.1276	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.1277	18		clc				clc
.1278	6d 13 07	adc $0713			adc 	freeVariableMemory
.127b	8d 13 07	sta $0713			sta 	freeVariableMemory
.127e	90 03		bcc $1283			bcc 	_CVNoCarry1
.1280	ee 14 07	inc $0714			inc 	freeVariableMemory+1
.1283					_CVNoCarry1:
.1283	fa		plx				plx
.1284	68		pla				pla
.1285	60		rts				rts
.1286					CommandDATA:
.1286	20 01 11	jsr $1101			jsr 	BufferClear 				; copy it to the buffer
.1289	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace
.128c					_CTDataLoop:
.128c	20 1e 1a	jsr $1a1e			jsr 	LookNext 					; reached EOL
.128f	f0 08		beq $1299			beq 	_CTDataDone
.1291	20 05 11	jsr $1105			jsr 	BufferWrite 				; write and consume
.1294	20 2f 1a	jsr $1a2f			jsr 	GetNext
.1297	80 f3		bra $128c			bra 	_CTDataLoop
.1299					_CTDataDone:
.1299	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.129b	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.129e	20 11 11	jsr $1111			jsr 	BufferOutput
.12a1	60		rts				rts
.12a2					CommandDEF:
.12a2	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.12a4	20 de 11	jsr $11de			jsr 	PushIntegerA
.12a7	20 46 1b	jsr $1b46			jsr 	CompileGotoEOL 				; compile skip over DEF
.12aa	a9 a5		lda #$a5			lda 	#C64_FN
.12ac	20 32 11	jsr $1132			jsr 	CheckNextA
.12af	20 3a 1a	jsr $1a3a			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.12b2	20 9f 1a	jsr $1a9f			jsr 	ExtractVariableName
.12b5	8a		txa				txa
.12b6	10 51		bpl $1309			bpl 	_CDError
.12b8	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.12b9	29 7f		and #$7f			and 	#$7F
.12bb	aa		tax				tax
.12bc	98		tya				tya
.12bd	09 80		ora #$80			ora 	#$80
.12bf	a8		tay				tay
.12c0	20 8b 14	jsr $148b			jsr 	FindVariable				; does it already exist ?
.12c3	b0 44		bcs $1309			bcs 	_CDError 					; if so, that's an error.
.12c5	20 10 12	jsr $1210			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.12c8	20 55 12	jsr $1255			jsr 	SetVariableRecordToCodePosition
.12cb	20 3a 1a	jsr $1a3a			jsr 	GetNextNonSpace
.12ce	20 90 1d	jsr $1d90			jsr 	GetReferenceTerm 			; get var ref, not array
.12d1	c9 00		cmp #$00			cmp 	#0
.12d3	30 34		bmi $1309			bmi 	_CDError
.12d5	8d 09 07	sta $0709			sta 	defType 					; save type
.12d8	8e 0a 07	stx $070a			stx 	defVariable 				; save var ref
.12db	8c 0b 07	sty $070b			sty 	defVariable+1
.12de	29 40		and #$40			and 	#NSSString 					; only numbers.
.12e0	d0 27		bne $1309			bne 	_CDError
.12e2	20 2c 11	jsr $112c			jsr 	CheckNextRParen 			; check )
.12e5	a9 b2		lda #$b2			lda 	#C64_EQUAL
.12e7	20 32 11	jsr $1132			jsr 	CheckNextA 					; check =
.12ea	18		clc				clc 								; if this is DEF FNxx(A), read A
.12eb	20 0c 13	jsr $130c			jsr 	CDReadWriteVariable
.12ee	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.12f0	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.12f3	38		sec				sec
.12f4	20 0c 13	jsr $130c			jsr 	CDReadWriteVariable 		; A is now updated
.12f7	20 d1 13	jsr $13d1			jsr 	CompileExpressionAt0 		; the actual body of the function.
.12fa	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.12fc	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.12ff	38		sec				sec
.1300	20 0c 13	jsr $130c			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.1303	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.1305	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1308	60		rts				rts
.1309					_CDError:
.1309	4c 2e 1f	jmp $1f2e		jmp	ErrorV_syntax
.130c					CDReadWriteVariable:
.130c	ac 0b 07	ldy $070b			ldy 	defVariable+1 				; set up YX
.130f	ae 0a 07	ldx $070a			ldx 	defVariable
.1312	ad 09 07	lda $0709			lda 	defType
.1315	20 42 1d	jsr $1d42			jsr 	GetSetVariable
.1318	60		rts				rts
.0709					defType:
>0709							.fill 	1
.070a					defVariable:
>070a							.fill 	2
.1319					CommandDIM:
.1319	20 3a 1a	jsr $1a3a			jsr 	GetNextNonSpace 			; get the first non space character
.131c	20 9f 1a	jsr $1a9f			jsr 	ExtractVariableName 		; variable name to XY
.131f	da		phx				phx 								; save name with type bits.
.1320	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.1322	10 37		bpl $135b			bpl 	_CDError
.1324	20 8b 14	jsr $148b			jsr 	FindVariable	 			; see if already exist
.1327	b0 35		bcs $135e			bcs 	_CDRedefine 				; it still exists.
.1329	20 10 12	jsr $1210			jsr 	CreateVariableRecord 		; create the basic variable
.132c	20 6a 12	jsr $126a			jsr 	AllocateBytesForType 		; allocate memory for it
.132f	68		pla				pla 								; restore type bits
.1330	5a		phy				phy 								; save the address of the basic storage
.1331	da		phx				phx
.1332	48		pha				pha
.1333	20 61 13	jsr $1361			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.1336	68		pla				pla
.1337	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.1339	20 de 11	jsr $11de			jsr 	PushIntegerA 				; push that type data out.
.133c	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.133e	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1341	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.1343	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1346	fa		plx				plx 								; restore address
.1347	7a		ply				ply
.1348	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.134a	38		sec				sec
.134b	20 42 1d	jsr $1d42			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.134e	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; , follows ?
.1351	c9 2c		cmp #$2c			cmp 	#","
.1353	d0 05		bne $135a			bne 	_CDExit
.1355	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume comma
.1358	80 bf		bra $1319			bra 	CommandDIM 					; do another DIM
.135a					_CDExit:
.135a	60		rts				rts
.135b					_CDError:
.135b	4c 2e 1f	jmp $1f2e		jmp	ErrorV_syntax
.135e					_CDRedefine:
.135e	4c f6 1f	jmp $1ff6		jmp	ErrorV_redefine
.1361					OutputIndexGroup:
.1361	9c 0c 07	stz $070c			stz 	IndexCount 					; count of number of indices.
.1364					_OIGNext:
.1364	20 d1 13	jsr $13d1			jsr 	CompileExpressionAt0 		; get a dimension
.1367	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1369	c9 00		cmp #$00			cmp 	#NSSIFloat
.136b	d0 19		bne $1386			bne 	_OIGType
.136d	ee 0c 07	inc $070c			inc 	IndexCount 					; bump the counter.
.1370	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; does a , follow ?
.1373	c9 2c		cmp #$2c			cmp 	#","
.1375	d0 05		bne $137c			bne 	_OIGCheckEnd
.1377	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume comma
.137a	80 e8		bra $1364			bra 	_OIGNext 					; get next dimension
.137c					_OIGCheckEnd:
.137c	20 2c 11	jsr $112c			jsr 	CheckNextRParen 			; check and consume )
.137f	ad 0c 07	lda $070c			lda 	IndexCount
.1382	20 de 11	jsr $11de			jsr 	PushIntegerA 				; compile the dimension count.
.1385	60		rts				rts
.1386					_OIGType:
.1386	4c 3e 1f	jmp $1f3e		jmp	ErrorV_type
.070c					IndexCount:
>070c							.fill 	1
.1389					ErrorHandler:
.1389	68		pla				pla
.138a	7a		ply				ply
.138b	85 2c		sta $2c				sta 	zTemp0
.138d	84 2d		sty $2d				sty 	zTemp0+1
.138f	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.1391	a0 01		ldy #$01			ldy 	#1
.1393					_EHDisplayMsg:
.1393	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1395	20 f7 10	jsr $10f7			jsr 	PrintCharacter
.1398	c8		iny				iny
.1399	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.139b	d0 f6		bne $1393			bne 	_EHDisplayMsg
.139d	a9 20		lda #$20			lda 	#32
.139f	20 f7 10	jsr $10f7			jsr 	PrintCharacter
.13a2	a9 40		lda #$40			lda 	#64
.13a4	20 f7 10	jsr $10f7			jsr 	PrintCharacter
.13a7	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.13a9	20 76 26	jsr $2676			jsr 	FloatSetByte
.13ac	20 e6 10	jsr $10e6			jsr 	GetLineNumber
.13af	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13b1	98		tya				tya
.13b2	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13b4	20 5c 25	jsr $255c			jsr 	FloatToString
.13b7	a0 00		ldy #$00			ldy 	#0 							; display that string.
.13b9	a2 00		ldx #$00			ldx 	#0
.13bb					_EHDisplayLine:
.13bb	b9 3c 07	lda $073c,y			lda 	decimalBuffer,y
.13be	20 f7 10	jsr $10f7			jsr 	PrintCharacter
.13c1	c8		iny				iny
.13c2	b9 3c 07	lda $073c,y			lda 	decimalBuffer,y
.13c5	d0 f4		bne $13bb			bne 	_EHDisplayLine
.13c7	a9 0d		lda #$0d			lda 	#13
.13c9	20 f7 10	jsr $10f7			jsr 	PrintCharacter
.13cc	80 fe		bra $13cc	_EHHalt:bra 	_EHHalt
.13ce	4c c3 11	jmp $11c3			jmp 	ExitCompiler
.13d1					CompileExpressionAt0:
.13d1	a9 00		lda #$00			lda 	#0
.13d3					CompileExpressionAtA:
.13d3	48		pha				pha  								; save level
.13d4	20 fb 1d	jsr $1dfb			jsr 	CompileTerm 				; compile a term.
.13d7	fa		plx				plx 								; get level back into X
.13d8					_ECALoop:
.13d8	48		pha				pha 								; save type on stack.
.13d9	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; get the next character
.13dc	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.13de	90 04		bcc $13e4			bcc 	_ECAExit
.13e0	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.13e2	90 02		bcc $13e6			bcc 	_ECAHaveToken
.13e4					_ECAExit:
.13e4	68		pla				pla 								; throw type off stack
.13e5	60		rts				rts
.13e6					_ECAHaveToken:
.13e6	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.13e8	aa		tax				tax 								; X contains the operator token
.13e9	bd d4 13	lda $13d4,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.13ec	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.13ee	90 f4		bcc $13e4			bcc 	_ECAExit
.13f0	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.13f2	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume the token.
.13f5	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.13f7	f0 11		beq $140a			beq 	_ECAGreaterCheck
.13f9	e0 b3		cpx #$b3			cpx 	#C64_LESS
.13fb	d0 1a		bne $1417			bne 	_ECAHaveFullToken
.13fd	20 1e 1a	jsr $1a1e			jsr 	LookNext 					; checks for < (<= or <>)
.1400	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.1402	f0 0e		beq $1412			beq	 	_ECAToNotEqual
.1404	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.1406	d0 0f		bne $1417			bne 	_ECAHaveFullToken
.1408	80 07		bra $1411			bra 	_ECAAddEqual
.140a					_ECAGreaterCheck:
.140a	20 1e 1a	jsr $1a1e			jsr 	LookNext
.140d	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.140f	d0 06		bne $1417			bne 	_ECAHaveFullToken
.1411					_ECAAddEqual:
.1411	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.1412					_ECAToNotEqual:
.1412	e8		inx				inx
.1413	e8		inx				inx
.1414	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume the = or > in >= <= <>
.1417					_ECAHaveFullToken:
.1417	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.1419	d0 0a		bne $1425			bne 	_ECANotConcat
.141b	68		pla				pla 								; get type back
.141c	48		pha				pha
.141d	29 40		and #$40			and 	#NSSTypeMask
.141f	c9 40		cmp #$40			cmp 	#NSSString
.1421	d0 02		bne $1425			bne 	_ECANotConcat
.1423	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1425					_ECANotConcat:
.1425	da		phx				phx 								; save operator on the stack
.1426	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.1428	da		phx				phx
.1429	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.142b	1a		inc a				inc 	a
.142c	20 d3 13	jsr $13d3			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.142f	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.1431	fa		plx				plx 								; restore current precedence in X
.1432	68		pla				pla 								; restore operator
.1433	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.1435	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.1437	90 17		bcc $1450			bcc 	_ECANotCompare
.1439	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.143b	b0 13		bcs $1450			bcs 	_ECANotCompare
.143d	7a		ply				ply 								; get type into Y
.143e	5a		phy				phy
.143f	48		pha				pha 								; save operator
.1440	98		tya				tya 								; get type
.1441	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.1443	29 40		and #$40			and 	#NSSTypeMask
.1445	c9 40		cmp #$40			cmp 	#NSSString
.1447	f0 02		beq $144b			beq 	_ECANotString
.1449	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.144b					_ECANotString:
.144b	98		tya				tya									; output token Y
.144c	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.144f	68		pla				pla 								; restore operator.
.1450					_ECANotCompare:
.1450	18		clc				clc 								; convert to P-Code and compile.
.1451	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.1453	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1456	68		pla				pla 								; type of current result
.1457	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.1459	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.145b	d0 19		bne $1476			bne		_ECAType
.145d	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.145f	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.1461	d0 18		bne $147b			bne 	_ECAGoLoop
.1463	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.1465	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1467	f0 10		beq $1479			beq 	_ECAOkayString 				; (this is post conversion)
.1469	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.146b	90 09		bcc $1476			bcc 	_ECAType
.146d	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.146f	b0 05		bcs $1476			bcs 	_ECAType
.1471	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.1473	4c d8 13	jmp $13d8			jmp 	_ECALoop
.1476					_ECAType:
.1476	4c 3e 1f	jmp $1f3e		jmp	ErrorV_type
.1479					_ECAOkayString:
.1479	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.147b					_ECAGoLoop:
.147b	4c d8 13	jmp $13d8			jmp 	_ECALoop
.147e					PrecedenceTable:
>147e	03						.byte 	3 					; '+'
>147f	03						.byte 	3 					; '-'
>1480	04						.byte 	4 					; '*'
>1481	04						.byte 	4 					; '/'
>1482	05						.byte 	5 					; '^'
>1483	01						.byte 	1 					; 'and'
>1484	00						.byte 	0 					; 'or'
>1485	02						.byte 	2 					; '>'
>1486	02						.byte 	2 					; '='
>1487	02						.byte 	2 					; '<'
>1488	02						.byte 	2 					; '>='
>1489	02						.byte 	2 					; '<='
>148a	02						.byte 	2 					; '<>'
.148b					FindVariable:
.148b	86 2e		stx $2e				stx 	zTemp1 						; save name.
.148d	84 2f		sty $2f				sty 	zTemp1+1
.148f					_IVCheckSpecial:
.148f	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.1491	d0 18		bne $14ab			bne 	_IVStandard
.1493	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.1495	f0 0c		beq $14a3			beq 	_IVTIFloat
.1497	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.1499	d0 10		bne $14ab			bne 	_IVStandard
.149b	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.149d	a2 01		ldx #$01			ldx 	#$01
.149f	a9 40		lda #$40			lda 	#NSSString
.14a1	38		sec				sec
.14a2	60		rts				rts
.14a3					_IVTIFloat:
.14a3	a0 80		ldy #$80			ldy 	#$80
.14a5	a2 00		ldx #$00			ldx 	#$00
.14a7	a9 00		lda #$00			lda 	#0
.14a9	38		sec				sec
.14aa	60		rts				rts
.14ab					_IVStandard:
.14ab	ad 07 07	lda $0707			lda 	compilerStartHigh			; start scanning from here.
.14ae	85 2d		sta $2d				sta 	zTemp0+1
.14b0	64 2c		stz $2c				stz 	zTemp0
.14b2					_IVCheckLoop:
.14b2	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.14b4	f0 2b		beq $14e1			beq  	_IVNotFound 				; if so, return with CC.
.14b6	a0 01		ldy #$01			ldy 	#1 							; match ?
.14b8	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14ba	c5 2e		cmp $2e				cmp 	zTemp1
.14bc	d0 07		bne $14c5			bne	 	_IVNext
.14be	c8		iny				iny
.14bf	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14c1	c5 2f		cmp $2f				cmp 	zTemp1+1
.14c3	f0 0d		beq $14d2			beq 	_IVFound
.14c5					_IVNext:
.14c5	18		clc				clc
.14c6	a5 2c		lda $2c				lda 	zTemp0
.14c8	72 2c		adc ($2c)			adc 	(zTemp0)
.14ca	85 2c		sta $2c				sta 	zTemp0
.14cc	90 e4		bcc $14b2			bcc 	_IVCheckLoop
.14ce	e6 2d		inc $2d				inc 	zTemp0+1
.14d0	80 e0		bra $14b2			bra 	_IVCheckLoop
.14d2					_IVFound:
.14d2	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.14d4	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14d6	aa		tax				tax
.14d7	c8		iny				iny
.14d8	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14da	48		pha				pha
.14db	c8		iny				iny
.14dc	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14de	7a		ply				ply
.14df	38		sec				sec
.14e0	60		rts				rts
.14e1					_IVNotFound:
.14e1	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.14e3	a4 2f		ldy $2f				ldy 	zTemp1+1
.14e5	18		clc				clc
.14e6	60		rts				rts
.14e7					FixBranches:
.14e7	20 59 10	jsr $1059			jsr 	APIORewind 					; back to the start of the *object* code.
.14ea					_FBLoop:
.14ea	b2 29		lda ($29)			lda 	(objPtr) 					; get the next one.
.14ec	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.14ee	f0 16		beq $1506			beq 	_FBFixGotoGosub
.14f0	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.14f2	f0 12		beq $1506			beq 	_FBFixGotoGosub
.14f4	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.14f6	f0 0e		beq $1506			beq 	_FBFixGotoGosub
.14f8	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.14fa	f0 0a		beq $1506			beq 	_FBFixGotoGosub
.14fc	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.14fe	f0 49		beq $1549			beq 	_FBFixVarSpace
.1500					_FBNext:
.1500	20 43 20	jsr $2043			jsr 	MoveObjectForward 			; move forward in object code.
.1503	90 e5		bcc $14ea			bcc 	_FBLoop 					; not finished
.1505					_FBExit:
.1505	60		rts				rts
.1506					_FBFixGotoGosub:
.1506	a0 01		ldy #$01			ldy 	#1 							; if page is currently $FF
.1508	b1 29		lda ($29),y			lda 	(objPtr),y 					; then patch else leave.
.150a	c9 ff		cmp #$ff			cmp 	#$FF
.150c	d0 f2		bne $1500			bne 	_FBNext
.150e	a0 02		ldy #$02			ldy 	#2							; line number in YA
.1510	b1 29		lda ($29),y			lda 	(objPtr),y
.1512	48		pha				pha
.1513	c8		iny				iny
.1514	b1 29		lda ($29),y			lda 	(objPtr),y
.1516	a8		tay				tay
.1517	68		pla				pla
.1518	20 e2 1b	jsr $1be2			jsr 	STRFindLine			 		; find where it is X:YA
.151b	90 08		bcc $1525			bcc 	_FBFFound 					; not found, so must be >
.151d	48		pha				pha
.151e	b2 29		lda ($29)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.1520	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1522	d0 15		bne $1539			bne 	_FBFFail
.1524	68		pla				pla
.1525					_FBFFound:
.1525	20 36 1c	jsr $1c36			jsr 	STRMakeOffset 				; make it an offset from X:YA
.1528	5a		phy				phy	 								; patch the GOTO/GOSUB
.1529	48		pha				pha
.152a	a0 01		ldy #$01			ldy 	#1
.152c	8a		txa				txa
.152d	91 29		sta ($29),y			sta 	(objPtr),y
.152f	c8		iny				iny
.1530	68		pla				pla
.1531	91 29		sta ($29),y			sta 	(objPtr),y
.1533	c8		iny				iny
.1534	68		pla				pla
.1535	91 29		sta ($29),y			sta 	(objPtr),y
.1537	80 c7		bra $1500			bra 	_FBNext
.1539					_FBFFail:
.1539	a0 02		ldy #$02			ldy 	#2
.153b	b1 29		lda ($29),y			lda 	(objPtr),y
.153d	8d 00 06	sta $0600			sta 	currentLineNumber
.1540	c8		iny				iny
.1541	b1 29		lda ($29),y			lda 	(objPtr),y
.1543	8d 01 06	sta $0601			sta 	currentLineNumber+1
.1546	4c 71 1f	jmp $1f71		jmp	ErrorV_line
.1549					_FBFixVarSpace:
.1549	a0 01		ldy #$01			ldy 	#1
.154b	ad 13 07	lda $0713			lda 	freeVariableMemory
.154e	91 29		sta ($29),y			sta 	(objPtr),y
.1550	c8		iny				iny
.1551	ad 14 07	lda $0714			lda 	freeVariableMemory+1
.1554	91 29		sta ($29),y			sta 	(objPtr),y
.1556	80 a8		bra $1500			bra 	_FBNext
.1558					CommandFOR:
.1558	20 3a 1a	jsr $1a3a			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.155b	20 50 1a	jsr $1a50			jsr 	CharIsAlpha 				; if not alpha , error
.155e	90 59		bcc $15b9			bcc 	_CFFail
.1560	20 90 1d	jsr $1d90			jsr 	GetReferenceTerm 			; figure out the reference.
.1563	48		pha				pha 								; save type
.1564	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1566	c9 00		cmp #$00			cmp 	#NSSIFloat
.1568	d0 4f		bne $15b9			bne 	_CFFail
.156a	5a		phy				phy 								; save reference on the stack
.156b	da		phx				phx
.156c	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.156e	20 32 11	jsr $1132			jsr 	CheckNextA
.1571	20 d1 13	jsr $13d1			jsr 	CompileExpressionAt0 		; initial value
.1574	fa		plx				plx 								; get reference back.
.1575	7a		ply				ply
.1576	5a		phy				phy
.1577	da		phx				phx
.1578	38		sec				sec 								; set initial value.
.1579	20 42 1d	jsr $1d42			jsr 	GetSetVariable
.157c	fa		plx				plx
.157d	7a		ply				ply
.157e	68		pla				pla
.157f	29 20		and #$20			and 	#NSSIInt16
.1581	f0 04		beq $1587			beq 	_CFNotInt16
.1583	98		tya				tya
.1584	09 80		ora #$80			ora 	#$80
.1586	a8		tay				tay
.1587					_CFNotInt16:
.1587	8a		txa				txa 								; reference in YA
.1588	20 cb 11	jsr $11cb			jsr 	PushIntegerYA
.158b	a9 a4		lda #$a4			lda 	#C64_TO
.158d	20 32 11	jsr $1132			jsr 	CheckNextA
.1590	20 d1 13	jsr $13d1			jsr 	CompileExpressionAt0 		; terminal value
.1593	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1595	c9 00		cmp #$00			cmp 	#NSSIFloat
.1597	d0 20		bne $15b9			bne 	_CFFail
.1599	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; followed by STEP
.159c	c9 a9		cmp #$a9			cmp 	#C64_STEP
.159e	d0 0e		bne $15ae			bne 	_CFNoStep
.15a0	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume it.
.15a3	20 d1 13	jsr $13d1			jsr 	CompileExpressionAt0 		; terminal value
.15a6	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15a8	c9 00		cmp #$00			cmp 	#NSSIFloat
.15aa	d0 0d		bne $15b9			bne 	_CFFail
.15ac	80 05		bra $15b3			bra 	_CFParametersDone
.15ae					_CFNoStep:
.15ae	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.15b0	20 de 11	jsr $11de			jsr 	PushIntegerA
.15b3					_CFParametersDone:
.15b3	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.15b5	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.15b8	60		rts				rts
.15b9					_CFFail:
.15b9	4c 2e 1f	jmp $1f2e		jmp	ErrorV_syntax
.15bc					FNCompile:
.15bc	20 3a 1a	jsr $1a3a			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.15bf	20 9f 1a	jsr $1a9f			jsr 	ExtractVariableName
.15c2	e0 00		cpx #$00			cpx 	#0
.15c4	10 32		bpl $15f8			bpl 	_FNError
.15c6	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.15c7	29 7f		and #$7f			and 	#$7F
.15c9	aa		tax				tax
.15ca	98		tya				tya
.15cb	09 80		ora #$80			ora 	#$80
.15cd	a8		tay				tay
.15ce	20 8b 14	jsr $148b			jsr 	FindVariable				; does it already exist ?
.15d1	90 25		bcc $15f8			bcc 	_FNError 					; no.
.15d3	20 36 1c	jsr $1c36			jsr 	STRMakeOffset 				; convert to a relative address.
.15d6	c9 00		cmp #$00			cmp 	#0 							; fix up.
.15d8	d0 01		bne $15db			bne 	_FNNoBorrow
.15da	88		dey				dey
.15db					_FNNoBorrow:
.15db	3a		dec a				dec 	a
.15dc	5a		phy				phy 								; save location of routine on stack.
.15dd	48		pha				pha
.15de	da		phx				phx
.15df	20 d1 13	jsr $13d1			jsr 	CompileExpressionAt0
.15e2	20 2c 11	jsr $112c			jsr 	CheckNextRParen
.15e5	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.15e7	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.15ea	68		pla				pla
.15eb	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.15ee	68		pla				pla
.15ef	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.15f2	68		pla				pla
.15f3	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.15f6	18		clc				clc
.15f7	60		rts				rts
.15f8					_FNError:
.15f8	4c 21 1f	jmp $1f21		jmp	ErrorV_value
.15fb					CommandTables:
>15fb	07 cb 00 03 fd 1a 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>1602	07 89 00 03 04 1b 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>1609	07 8d 00 03 f7 1a 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>1610	07 88 00 03 7f 1b 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>1617	07 85 00 03 5f 1b 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>161e	07 84 00 04 73 1b 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>1625	07 99 00 03 bd 1c 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>162c	07 98 00 04 bd 1c 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1633	07 8f 00 03 c8 1d 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>163a	07 81 00 03 58 15 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>1641	07 82 00 03 40 1c 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>1648	07 a1 00 03 70 1a 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>164f	07 83 00 03 86 12 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>1656	07 87 00 03 06 1d 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>165d	07 86 00 03 19 13 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>1664	07 96 00 03 a2 12 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>166b	07 8b 00 e3 27 1b 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>1672	08 92 00 ea e3 94 1e 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>167a	09 91 00 e1 a9 03 6c 1c			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>1682	06
>1683	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>168a	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>1691	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>1697	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>169e	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>16a5	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>16ac	07 9d 00 e3 ba 1e 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>16b3	0a 9f 00 ea e3 cd 1e 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>16bb	c6 06
>16bd	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>16c3	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>16ca	0a ce 92 e3 ed 19 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>16d2	ad 06
>16d4	0a ce 8d e3 ed 19 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>16dc	ae 06
>16de	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>16e4	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>16ec	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>16f3	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>16fa	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>1702	06
>1703	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>170b	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>1713	9a 06
>1715	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>171d	9b 06
>171f	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>1727	9c 06
>1729	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>1731	06
>1732	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>1739	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>1741	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>1749	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>1751	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>1759	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>1761	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>1769	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>1771	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>1779	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>1781	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>1789	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>1790	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>1798	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>17a0	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>17a8	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>17b0	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>17b8	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>17c0	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>17c8	00						.byte 	0
.17c9					UnaryTables:
>17c9	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>17d0	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>17d8	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>17df	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>17e6	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>17ed	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>17f4	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>17fc	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>1803	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>180b	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>1813	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>181b	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>1823	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>182b	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>1833	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>183a	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>1841	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>1848	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>184f	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>1856	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>185d	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>1865	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>186d	0b ca 00 8f ae 03 ed 19			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>1875	91 bd 07
>1878	07 a8 00 03 0c 1a 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>187f	07 a5 00 03 bc 15 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>1886	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>188d	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>1894	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>189c	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>18a4	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>18ab	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>18b2	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>18b9	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>18c1	06
>18c2	00						.byte 	0
.18c3					GeneratorProcess:
.18c3	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.18c5	84 2d		sty $2d				sty 	zTemp0+1
.18c7	85 2e		sta $2e				sta 	zTemp1 						; first match token
.18c9	64 2f		stz $2f				stz 	zTemp1+1
.18cb	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.18cd	d0 05		bne $18d4			bne 	_GPNotShifted
.18cf	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; get the shifted token
.18d2	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.18d4					_GPNotShifted:
.18d4					_GPSearch:
.18d4	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.18d6	18		clc				clc
.18d7	f0 2f		beq $1908			beq 	_GPExit
.18d9	a0 01		ldy #$01			ldy 	#1 							; tokens match
.18db	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.18dd	c5 2e		cmp $2e				cmp 	zTemp1
.18df	d0 09		bne $18ea			bne 	_GPNext
.18e1	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.18e3	f0 12		beq $18f7			beq 	_GPFound
.18e5	c8		iny				iny 								; check match.
.18e6	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.18e8	f0 0d		beq $18f7			beq 	_GPFound
.18ea					_GPNext:
.18ea	18		clc				clc 								; follow to next
.18eb	a5 2c		lda $2c				lda 	zTemp0
.18ed	72 2c		adc ($2c)			adc 	(zTemp0)
.18ef	85 2c		sta $2c				sta 	zTemp0
.18f1	90 e1		bcc $18d4			bcc 	_GPSearch
.18f3	e6 2d		inc $2d				inc 	zTemp0+1
.18f5	80 dd		bra $18d4			bra 	_GPSearch
.18f7					_GPFound:
.18f7	18		clc				clc 								; skip to action bytes
.18f8	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.18fa	69 03		adc #$03			adc 	#3
.18fc	85 2c		sta $2c				sta 	zTemp0
.18fe	90 02		bcc $1902			bcc 	_GPNoCarry
.1900	e6 2d		inc $2d				inc 	zTemp0+1
.1902					_GPNoCarry:
.1902					_GPLoop:
.1902	20 09 19	jsr $1909			jsr 	GeneratorExecute 			; execute one command
.1905	90 fb		bcc $1902			bcc 	_GPLoop 					; go back if not completed.
.1907	38		sec				sec 								; return with CS.
.1908					_GPExit:
.1908	60		rts				rts
.1909					GeneratorExecute:
.1909	20 b4 19	jsr $19b4			jsr 	_GEFetchZTemp0 				; get next.
.190c	48		pha				pha 								; split into 2 nibbles
.190d	4a		lsr a				lsr 	a
.190e	4a		lsr a				lsr 	a
.190f	4a		lsr a				lsr		a
.1910	4a		lsr a				lsr 	a
.1911	20 1b 19	jsr $191b			jsr 	_GEExecuteNibble 			; MSB first
.1914	68		pla				pla
.1915	b0 03		bcs $191a			bcs 	_GEHaveCompleted
.1917	20 1b 19	jsr $191b			jsr 	_GEExecuteNibble 			; LSB second
.191a					_GEHaveCompleted:
.191a	60		rts				rts
.191b					_GEExecuteNibble:
.191b	29 0f		and #$0f			and 	#$0F
.191d	0a		asl a				asl 	a
.191e	aa		tax				tax
.191f	7c 22 19	jmp ($1922,x)			jmp 	(_GEExecuteVectors,x)
.1922					_GEExecuteVectors:
>1922	42 19						.word 	_GEXNop 					; 0  (no operation)
>1924	4a 19						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>1926	44 19						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>1928	97 19						.word 	_GEXExecute 				; 3  (run arbitrary code)
>192a	8a 19						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>192c	42 19						.word 	_GEXNop 					; 5
>192e	51 19						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>1930	55 19						.word 	_GEXExitString 				; 7  exit return string type
>1932	59 19						.word 	_GEXLParam 					; 8  check ( follows
>1934	5d 19						.word 	_GEXRParam 					; 9  check ) follows
>1936	61 19						.word 	_GEXComma					; A  check , follows
>1938	42 19						.word 	_GEXNop 					; B
>193a	42 19						.word 	_GEXNop 					; C
>193c	42 19						.word 	_GEXNop 					; D
>193e	71 19						.word 	_GEXNumber 					; E  compile get any number
>1940	7c 19						.word 	_GEXString 					; F  compile get any string
.1942					_GEXNop:
.1942	18		clc				clc
.1943	60		rts				rts
.1944					_GEXToken2:
.1944	20 b4 19	jsr $19b4			jsr 	_GEFetchZTemp0
.1947	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.194a					_GEXToken1:
.194a	20 b4 19	jsr $19b4			jsr 	_GEFetchZTemp0
.194d	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1950	60		rts				rts
.1951					_GEXExitNumber:
.1951	a9 00		lda #$00			lda 	#NSSIFloat
.1953	38		sec				sec
.1954	60		rts				rts
.1955					_GEXExitString:
.1955	a9 40		lda #$40			lda 	#NSSString
.1957	38		sec				sec
.1958	60		rts				rts
.1959					_GEXLParam:
.1959	a9 28		lda #$28			lda 	#"("
.195b	80 06		bra $1963			bra 	_GEXCheck
.195d					_GEXRParam:
.195d	a9 29		lda #$29			lda 	#")"
.195f	80 02		bra $1963			bra 	_GEXCheck
.1961					_GEXComma:
.1961	a9 2c		lda #$2c			lda 	#","
.1963					_GEXCheck:
.1963	85 30		sta $30				sta 	zTemp2 						; save match
.1965	20 3a 1a	jsr $1a3a			jsr 	GetNextNonSpace 			; get next skipping spaces
.1968	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.196a	d0 02		bne $196e			bne 	_GEXSyntax
.196c	18		clc				clc
.196d	60		rts				rts
.196e					_GEXSyntax:
.196e	4c 2e 1f	jmp $1f2e		jmp	ErrorV_syntax
.1971					_GEXNumber:
.1971	20 bd 19	jsr $19bd			jsr 	GEXCompileExpression 		; compile expression
.1974	29 40		and #$40			and 	#NSSTypeMask
.1976	c9 00		cmp #$00			cmp  	#NSSIFloat
.1978	d0 0d		bne $1987			bne 	_GEXType
.197a	18		clc				clc
.197b	60		rts				rts
.197c					_GEXString:
.197c	20 bd 19	jsr $19bd			jsr 	GEXCompileExpression 		; compile expression
.197f	29 40		and #$40			and 	#NSSTypeMask
.1981	c9 40		cmp #$40			cmp  	#NSSString
.1983	d0 02		bne $1987			bne 	_GEXType
.1985	18		clc				clc
.1986	60		rts				rts
.1987					_GEXType:
.1987	4c 3e 1f	jmp $1f3e		jmp	ErrorV_type
.198a					_GEXChannelExec:
.198a	20 cd 19	jsr $19cd			jsr 	ChannelPrefix 				; set up default
.198d	20 97 19	jsr $1997			jsr 	_GEXExecute
.1990	08		php				php
.1991	20 e7 19	jsr $19e7			jsr 	ChannelPostfix 				; replace default.
.1994	28		plp				plp
.1995	60		rts				rts
>1996	db						.byte 	$DB 						; causes a break in the emulator
.1997					_GEXExecute:
.1997	20 b4 19	jsr $19b4			jsr 	_GEFetchZTemp0 				; get vector
.199a	85 30		sta $30				sta 	zTemp2
.199c	20 b4 19	jsr $19b4			jsr 	_GEFetchZTemp0
.199f	85 31		sta $31				sta 	zTemp2+1
.19a1	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19a3	da		phx				phx
.19a4	a6 2d		ldx $2d				ldx 	zTemp0+1
.19a6	da		phx				phx
.19a7	20 b1 19	jsr $19b1			jsr 	_GECallZTemp2 				; execute code
.19aa	fa		plx				plx 								; recover generation exec
.19ab	86 2d		stx $2d				stx 	zTemp0+1
.19ad	fa		plx				plx
.19ae	86 2c		stx $2c				stx 	zTemp0
.19b0	60		rts				rts
.19b1					_GECallZTemp2:
.19b1	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.19b4					_GEFetchZTemp0:
.19b4	b2 2c		lda ($2c)			lda 	(zTemp0)
.19b6	e6 2c		inc $2c				inc 	zTemp0
.19b8	d0 02		bne $19bc			bne 	_GEFZ0Skip
.19ba	e6 2d		inc $2d				inc 	zTemp0+1
.19bc					_GEFZ0Skip:
.19bc	60		rts				rts
.19bd					GEXCompileExpression:
.19bd	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19bf	da		phx				phx
.19c0	a6 2d		ldx $2d				ldx 	zTemp0+1
.19c2	da		phx				phx
.19c3	20 d1 13	jsr $13d1			jsr 	CompileExpressionAt0 		; compile expression.
.19c6	fa		plx				plx 								; recover generation exec
.19c7	86 2d		stx $2d				stx 	zTemp0+1
.19c9	fa		plx				plx
.19ca	86 2c		stx $2c				stx 	zTemp0
.19cc	60		rts				rts
.19cd					ChannelPrefix:
.19cd	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.19cf	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.19d2	20 bd 19	jsr $19bd			jsr 	GEXCompileExpression 		; channel #
.19d5	29 40		and #$40			and 	#NSSTypeMask
.19d7	c9 00		cmp #$00			cmp 	#NSSIFloat
.19d9	d0 09		bne $19e4			bne 	_CPXType
.19db	20 28 11	jsr $1128			jsr 	CheckNextComma 				; check , follows.
.19de	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.19e0	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.19e3	60		rts				rts
.19e4					_CPXType:
.19e4	4c 3e 1f	jmp $1f3e		jmp	ErrorV_type
.19e7					ChannelPostfix:
.19e7	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.19e9	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.19ec	60		rts				rts
.19ed					OptionalParameterCompile:
.19ed	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; what follows.
.19f0	c9 2c		cmp #$2c			cmp 	#","
.19f2	d0 0e		bne $1a02			bne 	_MidDefault
.19f4	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume ,
.19f7	20 d1 13	jsr $13d1			jsr 	CompileExpressionAt0
.19fa	29 40		and #$40			and 	#NSSTypeMask
.19fc	c9 00		cmp #$00			cmp 	#NSSIFloat
.19fe	d0 09		bne $1a09			bne 	MidFailType
.1a00	80 05		bra $1a07			bra 	_MidComplete
.1a02					_MidDefault:
.1a02	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1a04	20 de 11	jsr $11de			jsr 	PushIntegerA
.1a07					_MidComplete:
.1a07	18		clc				clc
.1a08	60		rts				rts
.1a09					MidFailType:
.1a09	4c 3e 1f	jmp $1f3e		jmp	ErrorV_type
.1a0c					NotUnaryCompile:
.1a0c	ad 86 14	lda $1486			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1a0f	20 d3 13	jsr $13d3			jsr 	CompileExpressionAtA 		; evaluate at that level
.1a12	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1a14	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a16	d0 f1		bne $1a09			bne 	MidFailType
.1a18	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1a1a	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1a1d	60		rts				rts
.1a1e					LookNext:
.1a1e	b2 24		lda ($24)			lda 	(srcPtr)
.1a20	60		rts				rts
.1a21					LookNextNonSpace:
.1a21	b2 24		lda ($24)			lda 	(srcPtr)
.1a23	c9 20		cmp #$20			cmp		#' '
.1a25	f0 03		beq $1a2a			beq 	_LNNSkip
.1a27	c9 00		cmp #$00			cmp 	#0
.1a29	60		rts				rts
.1a2a					_LNNSkip:
.1a2a	20 2f 1a	jsr $1a2f			jsr 	GetNext
.1a2d	80 f2		bra $1a21			bra 	LookNextNonSpace
.1a2f					GetNext:
.1a2f	b2 24		lda ($24)			lda 	(srcPtr) 					; get next
.1a31	e6 24		inc $24				inc 	srcPtr
.1a33	d0 02		bne $1a37			bne 	_GNSkip
.1a35	e6 25		inc $25				inc 	srcPtr+1
.1a37					_GNSkip:
.1a37	c9 00		cmp #$00			cmp 	#0
.1a39	60		rts				rts
.1a3a					GetNextNonSpace:
.1a3a	20 2f 1a	jsr $1a2f			jsr 	GetNext
.1a3d	c9 20		cmp #$20			cmp 	#' '
.1a3f	f0 f9		beq $1a3a			beq 	GetNextNonSpace
.1a41	c9 00		cmp #$00			cmp 	#0
.1a43	60		rts				rts
.1a44					CharIsDigit:
.1a44	c9 30		cmp #$30			cmp 	#"0"
.1a46	90 06		bcc $1a4e			bcc 	CCFalse
.1a48	c9 3a		cmp #$3a			cmp 	#"9"+1
.1a4a	b0 02		bcs $1a4e			bcs 	CCFalse
.1a4c					CCTrue:
.1a4c	38		sec				sec
.1a4d	60		rts				rts
.1a4e					CCFalse:
.1a4e	18		clc				clc
.1a4f	60		rts				rts
.1a50					CharIsAlpha:
.1a50	c9 41		cmp #$41			cmp 	#"A"
.1a52	90 fa		bcc $1a4e			bcc 	CCFalse
.1a54	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1a56	b0 f6		bcs $1a4e			bcs 	CCFalse
.1a58	80 f2		bra $1a4c			bra 	CCTrue
.1a5a					ConvertHexStyle:
.1a5a	38		sec				sec
.1a5b	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1a5d	90 ef		bcc $1a4e			bcc 	CCFalse
.1a5f	c9 0a		cmp #$0a			cmp 	#9+1
.1a61	90 e9		bcc $1a4c			bcc 	CCTrue
.1a63	38		sec				sec 								; shift into hex space A=>0 Z=>25
.1a64	e9 11		sbc #$11			sbc 	#"A"-"0"
.1a66	90 e6		bcc $1a4e			bcc 	CCFalse
.1a68	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.1a6a	b0 e2		bcs $1a4e			bcs 	CCFalse
.1a6c	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.1a6e	80 dc		bra $1a4c			bra 	CCTrue
.1a70					CommandGET:
.1a70	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; # follows ?
.1a73	c9 23		cmp #$23			cmp 	#"#"
.1a75	d0 0d		bne $1a84			bne 	CommandGetBody
.1a77	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume #
.1a7a	20 cd 19	jsr $19cd			jsr 	ChannelPrefix 				; do it as GET#
.1a7d	20 84 1a	jsr $1a84			jsr 	CommandGetBody
.1a80	20 e7 19	jsr $19e7			jsr 	ChannelPostfix
.1a83	60		rts				rts
.1a84					CommandGetBody:
.1a84	20 3a 1a	jsr $1a3a			jsr 	GetNextNonSpace 			; get the first character
.1a87	20 90 1d	jsr $1d90			jsr 	GetReferenceTerm 			; identify variable to assign to
.1a8a	48		pha				pha
.1a8b	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1a8d	c9 40		cmp #$40			cmp 	#NSSString
.1a8f	d0 0b		bne $1a9c			bne 	_CGType
.1a91	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1a93	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1a96	38		sec				sec
.1a97	68		pla				pla
.1a98	20 42 1d	jsr $1d42			jsr		GetSetVariable
.1a9b	60		rts				rts
.1a9c					_CGType:
.1a9c	4c 3e 1f	jmp $1f3e		jmp	ErrorV_type
.1a9f					ExtractVariableName:
.1a9f	20 50 1a	jsr $1a50			jsr 	CharIsAlpha
.1aa2	90 50		bcc $1af4			bcc 	_IVSyntax
.1aa4	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.1aa6	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.1aa8	64 2f		stz $2f				stz 	zTemp1+1
.1aaa	20 1e 1a	jsr $1a1e			jsr 	LookNext 					; is there a second character ?
.1aad	20 50 1a	jsr $1a50			jsr 	CharIsAlpha  				; must be alphanumeric
.1ab0	b0 05		bcs $1ab7			bcs 	_IVHasSecond
.1ab2	20 44 1a	jsr $1a44			jsr 	CharIsDigit
.1ab5	90 07		bcc $1abe			bcc 	_IVCheckType
.1ab7					_IVHasSecond:
.1ab7	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.1ab9	85 2f		sta $2f				sta 	zTemp1+1
.1abb					_IVGetNextCheck:
.1abb	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume it
.1abe					_IVCheckType:
.1abe	20 1e 1a	jsr $1a1e			jsr 	LookNext					; check if string follows.
.1ac1	20 50 1a	jsr $1a50			jsr 	CharIsAlpha
.1ac4	b0 f5		bcs $1abb			bcs 	_IVGetNextCheck
.1ac6	20 44 1a	jsr $1a44			jsr 	CharIsDigit
.1ac9	b0 f0		bcs $1abb			bcs 	_IVGetNextCheck
.1acb	a2 40		ldx #$40			ldx 	#NSSString
.1acd	c9 24		cmp #$24			cmp 	#"$"
.1acf	f0 06		beq $1ad7			beq 	_IVHasType
.1ad1	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.1ad3	c9 25		cmp #$25			cmp 	#"%"
.1ad5	d0 08		bne $1adf			bne 	_IVCheckArray
.1ad7					_IVHasType:
.1ad7	8a		txa				txa 								; Or X into zTemp1
.1ad8	05 2e		ora $2e				ora 	zTemp1
.1ada	85 2e		sta $2e				sta 	zTemp1
.1adc	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume it
.1adf					_IVCheckArray:
.1adf	20 1e 1a	jsr $1a1e			jsr 	LookNext 					; check if array follows
.1ae2	c9 28		cmp #$28			cmp 	#"("
.1ae4	d0 09		bne $1aef			bne 	_IVNotArray
.1ae6	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.1ae8	09 80		ora #$80			ora 	#NSSArray
.1aea	85 2e		sta $2e				sta 	zTemp1
.1aec	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume it
.1aef					_IVNotArray:
.1aef	a6 2e		ldx $2e				ldx 	zTemp1
.1af1	a4 2f		ldy $2f				ldy 	zTemp1+1
.1af3	60		rts				rts
.1af4					_IVSyntax:
.1af4	4c 2e 1f	jmp $1f2e		jmp	ErrorV_syntax
.1af7					CommandGOSUB:
.1af7	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1af9	20 0a 1b	jsr $1b0a			jsr 	CompileBranchCommand
.1afc	60		rts				rts
.1afd					CommandGOAlt:
.1afd	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1aff	20 32 11	jsr $1132			jsr 	CheckNextA
.1b02	80 00		bra $1b04			bra 	CommandGOTO
.1b04					CommandGOTO:
.1b04	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1b06	20 0a 1b	jsr $1b0a			jsr 	CompileBranchCommand
.1b09	60		rts				rts
.1b0a					CompileBranchCommand:
.1b0a	20 ed 10	jsr $10ed			jsr 	WriteCodeByte 				; write the command out.
.1b0d	20 3a 1a	jsr $1a3a			jsr 	GetNextNonSpace
.1b10	20 98 1c	jsr $1c98			jsr 	ParseConstant 				; get constant into YA
.1b13	90 0f		bcc $1b24			bcc 	_CBCSyntax
.1b15	48		pha				pha
.1b16	a9 ff		lda #$ff			lda 	#$FF 						; no address yet.
.1b18	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1b1b	68		pla				pla 								; and compile the actual line number
.1b1c	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1b1f	98		tya				tya
.1b20	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1b23	60		rts				rts
.1b24					_CBCSyntax:
.1b24	4c 2e 1f	jmp $1f2e		jmp	ErrorV_syntax
.1b27					CommandIF:
.1b27	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; what follows the tests ?
.1b2a	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1b2c	f0 0f		beq $1b3d			beq 	_CIGoto
.1b2e	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1b30	20 32 11	jsr $1132			jsr 	CheckNextA
.1b33	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; THEN <number>
.1b36	20 44 1a	jsr $1a44			jsr 	CharIsDigit
.1b39	b0 05		bcs $1b40			bcs 	_CIGoto2
.1b3b	80 09		bra $1b46			bra 	CompileGotoEOL
.1b3d					_CIGoto:
.1b3d	20 2f 1a	jsr $1a2f			jsr 	GetNext
.1b40					_CIGoto2:
.1b40	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1b42	20 0a 1b	jsr $1b0a			jsr 	CompileBranchCommand
.1b45	60		rts				rts
.1b46					CompileGotoEOL:
.1b46	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.1b48	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1b4b	a9 ff		lda #$ff			lda 	#$FF
.1b4d	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1b50	20 e6 10	jsr $10e6			jsr 	GetLineNumber 				; Get the current line number => YA
.1b53	1a		inc a				inc 	a 							; and branch to +1
.1b54	d0 01		bne $1b57			bne 	_CGENoCarry
.1b56	c8		iny				iny
.1b57					_CGENoCarry:
.1b57	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1b5a	98		tya				tya
.1b5b	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1b5e	60		rts				rts
.1b5f					CommandINPUT:
.1b5f	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; check for "
.1b62	c9 22		cmp #$22			cmp 	#'"'
.1b64	d0 0d		bne $1b73			bne 	CommandINPUTStream
.1b66	20 d1 13	jsr $13d1			jsr 	CompileExpressionAt0
.1b69	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1b6b	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1b6e	a9 2c		lda #$2c			lda 	#","
.1b70	20 28 11	jsr $1128			jsr 	CheckNextComma
.1b73					CommandINPUTStream:
.1b73	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1b75	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1b78	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.1b7a	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1b7c	4c 0a 1d	jmp $1d0a			jmp 	CommandReadInputCommon
.1b7f					CommandLET:
.1b7f	20 3a 1a	jsr $1a3a			jsr 	GetNextNonSpace 			; get the first character
.1b82					CommandLETHaveFirst:
.1b82	20 90 1d	jsr $1d90			jsr 	GetReferenceTerm 			; identify variable to assign to
.1b85	da		phx				phx 								; save target on the stack.
.1b86	5a		phy				phy
.1b87	48		pha				pha
.1b88	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.1b8a	20 32 11	jsr $1132			jsr 	CheckNextA
.1b8d	20 d1 13	jsr $13d1			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1b90	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.1b92	68		pla				pla 								; get type of assignment
.1b93	48		pha				pha
.1b94	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.1b96	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.1b98	d0 17		bne $1bb1			bne 	_CLType
.1b9a	68		pla				pla 								; restore and compile save code
.1b9b	7a		ply				ply
.1b9c	fa		plx				plx
.1b9d	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.1b9f	f0 05		beq $1ba6			beq 	_CLTIString
.1ba1	38		sec				sec
.1ba2	20 42 1d	jsr $1d42			jsr		GetSetVariable
.1ba5	60		rts				rts
.1ba6					_CLTIString:
.1ba6	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.1ba8	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1bab	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.1bad	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1bb0	60		rts				rts
.1bb1					_CLType:
.1bb1	4c 3e 1f	jmp $1f3e		jmp	ErrorV_type
.1bb4					STRMarkLine:
.1bb4	48		pha				pha
.1bb5	38		sec				sec 								; allocate 5 bytes (line #, page+address)
.1bb6	ad 0f 07	lda $070f			lda 	lineNumberTable 			; and copy to zTemp0
.1bb9	e9 05		sbc #$05			sbc 	#5
.1bbb	8d 0f 07	sta $070f			sta 	lineNumberTable
.1bbe	85 2c		sta $2c				sta 	zTemp0
.1bc0	ad 10 07	lda $0710			lda 	lineNumberTable+1
.1bc3	e9 00		sbc #$00			sbc 	#0
.1bc5	8d 10 07	sta $0710			sta 	lineNumberTable+1
.1bc8	85 2d		sta $2d				sta 	zTemp0+1
.1bca	68		pla				pla
.1bcb	92 2c		sta ($2c)			sta 	(zTemp0) 					; save it in +0,+1
.1bcd	98		tya				tya
.1bce	a0 01		ldy #$01			ldy 	#1
.1bd0	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1bd2	a5 2b		lda $2b				lda 	objPage 					; and page# in +2
.1bd4	c8		iny				iny
.1bd5	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1bd7	a5 29		lda $29				lda 	objPtr 						; save current address in +3,+4
.1bd9	c8		iny				iny
.1bda	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1bdc	a5 2a		lda $2a				lda 	objPtr+1
.1bde	c8		iny				iny
.1bdf	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1be1	60		rts				rts
.1be2					STRFindLine:
.1be2	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.1be4	84 2d		sty $2d				sty 	zTemp0+1
.1be6	ad 08 07	lda $0708			lda 	compilerEndHigh 			; work backwards through table
.1be9	85 2f		sta $2f				sta 	zTemp1+1
.1beb	64 2e		stz $2e				stz 	zTemp1
.1bed					_STRSearch:
.1bed	20 28 1c	jsr $1c28			jsr 	_STRPrevLine 				; look at previous record.
.1bf0	a0 01		ldy #$01			ldy 	#1
.1bf2	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.1bf4	c5 2c		cmp $2c				cmp 	zTemp0
.1bf6	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1bf8	e5 2d		sbc $2d				sbc 	zTemp0+1
.1bfa	b0 0b		bcs $1c07			bcs 	_STRFound 					; >=
.1bfc					_STRNext:
.1bfc	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1bfe	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1c00	c9 ff		cmp #$ff			cmp 	#$FF
.1c02	d0 e9		bne $1bed			bne 	_STRSearch
.1c04	4c 88 1f	jmp $1f88		jmp	ErrorV_internal
.1c07					_STRFound:
.1c07	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1c09	45 2c		eor $2c				eor 	zTemp0
.1c0b	d0 06		bne $1c13			bne 	_STRDifferent
.1c0d	b2 2e		lda ($2e)			lda 	(zTemp1)
.1c0f	45 2c		eor $2c				eor 	zTemp0
.1c11	f0 02		beq $1c15			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1c13					_STRDifferent:
.1c13	a9 ff		lda #$ff			lda 	#$FF
.1c15					_STROut:
.1c15	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1c16	69 ff		adc #$ff			adc 	#255
.1c18	08		php				php
.1c19	c8		iny				iny 								; page into X
.1c1a	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1c1c	aa		tax				tax
.1c1d	c8		iny				iny 								; address into YA
.1c1e	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1c20	48		pha				pha
.1c21	c8		iny				iny
.1c22	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1c24	a8		tay				tay
.1c25	68		pla				pla
.1c26	28		plp				plp
.1c27	60		rts				rts
.1c28					_STRPrevLine:
.1c28	38		sec				sec 								; move backwards one entry.
.1c29	a5 2e		lda $2e				lda 	zTemp1
.1c2b	e9 05		sbc #$05			sbc 	#5
.1c2d	85 2e		sta $2e				sta 	zTemp1
.1c2f	a5 2f		lda $2f				lda 	zTemp1+1
.1c31	e9 00		sbc #$00			sbc 	#0
.1c33	85 2f		sta $2f				sta 	zTemp1+1
.1c35	60		rts				rts
.1c36					STRMakeOffset:
.1c36	18		clc				clc 								; borrow 1
.1c37	e5 29		sbc $29				sbc 	objPtr
.1c39	48		pha				pha
.1c3a	98		tya				tya
.1c3b	e5 2a		sbc $2a				sbc 	objPtr+1
.1c3d	a8		tay				tay
.1c3e	68		pla				pla
.1c3f	60		rts				rts
.1c40					CommandNEXT:
.1c40	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1c43	20 50 1a	jsr $1a50			jsr 	CharIsAlpha 				; if not alpha , error
.1c46	90 0c		bcc $1c54			bcc 	_CNNoReferenceGiven
.1c48	20 2f 1a	jsr $1a2f			jsr 	GetNext
.1c4b	20 90 1d	jsr $1d90			jsr 	GetReferenceTerm 			; figure out the reference.
.1c4e	8a		txa				txa 								; reference in YA
.1c4f	20 cb 11	jsr $11cb			jsr 	PushIntegerYA 				; write it out.
.1c52	80 06		bra $1c5a			bra 	_CNParametersDone
.1c54					_CNNoReferenceGiven:
.1c54	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1c56	a8		tay				tay
.1c57	20 cb 11	jsr $11cb			jsr 	PushIntegerYA 				; write it out.
.1c5a					_CNParametersDone:
.1c5a	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1c5c	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1c5f	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; look for ,
.1c62	c9 2c		cmp #$2c			cmp 	#","
.1c64	d0 05		bne $1c6b			bne 	_CNExit
.1c66	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume ,
.1c69	80 d5		bra $1c40			bra 	CommandNEXT 				; and go round.
.1c6b					_CNExit:
.1c6b	60		rts				rts
.1c6c					CommandON:
.1c6c	20 3a 1a	jsr $1a3a			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1c6f	48		pha				pha 								; save on stack
.1c70	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1c72	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1c74	f0 09		beq $1c7f			beq 	_COCreateLoop
.1c76	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1c78	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1c7a	f0 03		beq $1c7f			beq 	_COCreateLoop
.1c7c	4c 2e 1f	jmp $1f2e		jmp	ErrorV_syntax
.1c7f					_COCreateLoop:
.1c7f	8a		txa				txa 								; compile a goto/gosub somewhere
.1c80	da		phx				phx
.1c81	20 0a 1b	jsr $1b0a			jsr 	CompileBranchCommand
.1c84	fa		plx				plx
.1c85	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace			; ',' follows
.1c88	c9 2c		cmp #$2c			cmp 	#","
.1c8a	d0 0a		bne $1c96			bne 	_COComplete 				; if so, more line numbers
.1c8c	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1c8e	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1c91	20 2f 1a	jsr $1a2f			jsr 	GetNext
.1c94	80 e9		bra $1c7f			bra 	_COCreateLoop
.1c96					_COComplete:
.1c96	68		pla				pla 								; throw GOTO/GOSUB
.1c97	60		rts				rts
.1c98					ParseConstant:
.1c98	a2 00		ldx #$00			ldx 	#0
.1c9a	20 54 24	jsr $2454			jsr 	FloatEncodeStart 			; send first
.1c9d					_ParseLoop:
.1c9d	20 1e 1a	jsr $1a1e			jsr 	LookNext 					; send subsequent
.1ca0	20 57 24	jsr $2457			jsr 	FloatEncodeContinue
.1ca3	90 05		bcc $1caa			bcc 	_ParseDone
.1ca5	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume it
.1ca8	80 f3		bra $1c9d			bra 	_ParseLoop
.1caa					_ParseDone:
.1caa	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1cac	29 80		and #$80			and 	#$80
.1cae	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.1cb0	15 56		ora $56,x			ora 	NSMantissa2,x
.1cb2	15 62		ora $62,x			ora 	NSMantissa3,x
.1cb4	18		clc				clc
.1cb5	d0 05		bne $1cbc			bne 	_ParseExit 					; exit with CC if need float to compile
.1cb7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.1cb9	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.1cbb	38		sec				sec
.1cbc					_ParseExit:
.1cbc	60		rts				rts
.1cbd					CommandPRINT:
.1cbd	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace			; what follows ?
.1cc0	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1cc2	f0 1f		beq $1ce3			beq 	_CPCheckEnd
.1cc4	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1cc6	f0 16		beq $1cde			beq 	_CPTabCheckEnd
.1cc8	20 fa 1c	jsr $1cfa			jsr 	_CPAtEnd 					; check for : and EOL
.1ccb	b0 22		bcs $1cef			bcs 	_CPExitCR 					; exit with CR
.1ccd	20 d1 13	jsr $13d1			jsr 	CompileExpressionAt0 		; so it is something to print
.1cd0	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1cd2	29 40		and #$40			and 	#NSSString 					; if string
.1cd4	d0 02		bne $1cd8			bne 	_CPOut
.1cd6	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1cd8					_CPOut:
.1cd8	8a		txa				txa 								; print that thing
.1cd9	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1cdc	80 df		bra $1cbd			bra 	CommandPRINT 				; and loop round/
.1cde					_CPTabCheckEnd:
.1cde	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1ce0	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1ce3					_CPCheckEnd:
.1ce3	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume it.
.1ce6	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; what follows ?
.1ce9	20 fa 1c	jsr $1cfa			jsr 	_CPAtEnd 					; reached end
.1cec	90 cf		bcc $1cbd			bcc 	CommandPRINT 				; no, loop back
.1cee	60		rts				rts
.1cef					_CPExitCR:
.1cef	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1cf1	20 de 11	jsr $11de			jsr 	PushIntegerA
.1cf4	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1cf6	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1cf9	60		rts				rts
.1cfa					_CPAtEnd:
.1cfa	c9 00		cmp #$00			cmp 	#0
.1cfc	f0 06		beq $1d04			beq 	_CPIsEnd
.1cfe	c9 3a		cmp #$3a			cmp 	#":"
.1d00	f0 02		beq $1d04			beq 	_CPIsEnd
.1d02	18		clc				clc
.1d03	60		rts				rts
.1d04					_CPIsEnd:
.1d04	38		sec				sec
.1d05	60		rts				rts
.1d06					CommandREAD:
.1d06	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1d08	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1d0a					CommandReadInputCommon:
.1d0a	8e 0d 07	stx $070d			stx 	numberPCode
.1d0d	8c 0e 07	sty $070e			sty 	stringPCode
.1d10					_CRLoop:
.1d10	20 3a 1a	jsr $1a3a			jsr 	GetNextNonSpace 			; first char of identifier
.1d13	20 50 1a	jsr $1a50			jsr 	CharIsAlpha 				; check A-Z
.1d16	90 27		bcc $1d3f			bcc 	_CRSyntax
.1d18	20 90 1d	jsr $1d90			jsr 	GetReferenceTerm 			; get the variable.
.1d1b	48		pha				pha 								; save type.
.1d1c	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1d1e	c9 40		cmp #$40			cmp 	#NSSString
.1d20	f0 05		beq $1d27			beq 	_CRString
.1d22	ad 0d 07	lda $070d			lda 	numberPCode 				; output read/input
.1d25	80 03		bra $1d2a			bra 	_CRHaveType
.1d27					_CRString:
.1d27	ad 0e 07	lda $070e			lda 	stringPCode					; output read$/input$
.1d2a					_CRHaveType:
.1d2a	20 ed 10	jsr $10ed			jsr 	WriteCodeByte 				; so we have one typed data item.
.1d2d	68		pla				pla 								; restore type
.1d2e	38		sec				sec  								; write update code.
.1d2f	20 42 1d	jsr $1d42			jsr 	GetSetVariable
.1d32	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; , follows ?
.1d35	c9 2c		cmp #$2c			cmp 	#","
.1d37	d0 05		bne $1d3e			bne 	_CRExit 					; if not, end of READ.
.1d39	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume comma
.1d3c	80 d2		bra $1d10			bra 	_CRLoop 					; keep going
.1d3e					_CRExit:
.1d3e	60		rts				rts
.1d3f					_CRSyntax:
.1d3f	4c 2e 1f	jmp $1f2e		jmp	ErrorV_syntax
.070d					numberPCode:
>070d							.fill 	1
.070e					stringPCode:
>070e							.fill 	1
.1d42					GetSetVariable:
.1d42	08		php				php 								; save direction on stack
.1d43	c0 00		cpy #$00			cpy 	#$00
.1d45	30 21		bmi $1d68			bmi 	_GSVReadWriteSpecial
.1d47	c9 00		cmp #$00			cmp 	#$00
.1d49	30 33		bmi $1d7e			bmi 	_GSVArray
.1d4b	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1d4d	4a		lsr a				lsr 	a 							; divide by 2
.1d4e	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1d50	28		plp				plp
.1d51	90 02		bcc $1d55			bcc 	_GSVNotWrite
.1d53	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1d55					_GSVNotWrite:
.1d55	85 2c		sta $2c				sta 	zTemp0
.1d57	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1d58	4a		lsr a				lsr 	a
.1d59	a8		tay				tay
.1d5a	8a		txa				txa
.1d5b	6a		ror a				ror 	a
.1d5c	aa		tax				tax
.1d5d	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1d5e	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.1d60	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1d63	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1d64	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1d67	60		rts				rts
.1d68					_GSVReadWriteSpecial:
.1d68	28		plp				plp
.1d69	b0 10		bcs $1d7b			bcs 	_GSVSyntax
.1d6b	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1d6d	f0 06		beq $1d75			beq 	_GSVRWString
.1d6f	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1d71	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1d74	60		rts				rts
.1d75					_GSVRWString:
.1d75	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1d77	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1d7a	60		rts				rts
.1d7b					_GSVSyntax:
.1d7b	4c 2e 1f	jmp $1f2e		jmp	ErrorV_syntax
.1d7e					_GSVArray:
.1d7e	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1d80	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1d81	4a		lsr a				lsr 	a
.1d82	4a		lsr a				lsr 	a
.1d83	4a		lsr a				lsr 	a
.1d84	4a		lsr a				lsr 	a
.1d85	28		plp				plp 								; if writing array then set bit 2.
.1d86	90 02		bcc $1d8a			bcc 	_GSVANotWrite
.1d88	09 04		ora #$04			ora 	#4
.1d8a					_GSVANotWrite:
.1d8a	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1d8c	20 ed 10	jsr $10ed			jsr 	WriteCodeByte 				; and write it out
.1d8f	60		rts				rts
.1d90					GetReferenceTerm:
.1d90	20 9f 1a	jsr $1a9f			jsr 	ExtractVariableName 		; get name & type info
.1d93	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1d95	30 10		bmi $1da7			bmi 	_GRTArray
.1d97	da		phx				phx 								; save type on stack
.1d98	20 8b 14	jsr $148b			jsr 	FindVariable 				; find it
.1d9b	b0 06		bcs $1da3			bcs 	_GRTNoCreate 				; create if required.
.1d9d	20 10 12	jsr $1210			jsr 	CreateVariableRecord 		; create a variable.
.1da0	20 6a 12	jsr $126a			jsr 	AllocateBytesForType 		; allocate memory for it
.1da3					_GRTNoCreate:
.1da3	68		pla				pla 								; get type back, strip out type information.
.1da4	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1da6	60		rts				rts
.1da7					_GRTArray:
.1da7	da		phx				phx 								; save type information
.1da8	20 8b 14	jsr $148b			jsr 	FindVariable 				; read its data, the base address in YX
.1dab	90 18		bcc $1dc5			bcc 	_GRTUndeclared 				; undeclared array.
.1dad	da		phx				phx 								; save base address
.1dae	5a		phy				phy
.1daf	20 61 13	jsr $1361			jsr 	OutputIndexGroup 			; create an index group and generate them
.1db2	7a		ply				ply 								; get the array base address into YX
.1db3	fa		plx				plx
.1db4	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1db6	18		clc				clc
.1db7	20 42 1d	jsr $1d42			jsr 	GetSetVariable 				; load the address of the array structure.
.1dba	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1dbc	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1dbf	68		pla				pla 								; and the type data into A
.1dc0	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1dc2	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1dc4	60		rts				rts
.1dc5					_GRTUndeclared:
.1dc5	4c e5 1f	jmp $1fe5		jmp	ErrorV_undeclared
.1dc8					CommandREM:
.1dc8	20 1e 1a	jsr $1a1e			jsr 	LookNext
.1dcb	f0 05		beq $1dd2			beq 	_CRExit
.1dcd	20 2f 1a	jsr $1a2f			jsr 	GetNext
.1dd0	80 f6		bra $1dc8			bra 	CommandREM
.1dd2					_CRExit:
.1dd2	60		rts				rts
.1dd3					STRReset:
.1dd3	ad 07 07	lda $0707			lda	 	compilerStartHigh 			; set up the two table pointers
.1dd6	8d 12 07	sta $0712			sta 	variableListEnd+1
.1dd9	9c 11 07	stz $0711			stz 	variableListEnd
.1ddc	ad 08 07	lda $0708			lda 	compilerEndHigh
.1ddf	8d 10 07	sta $0710			sta 	lineNumberTable+1
.1de2	9c 0f 07	stz $070f			stz 	lineNumberTable
.1de5	ad 11 07	lda $0711			lda 	variableListEnd
.1de8	85 2d		sta $2d				sta 	zTemp0+1
.1dea	64 2c		stz $2c				stz 	zTemp0
.1dec	a9 00		lda #$00			lda 	#0
.1dee	92 2c		sta ($2c)			sta 	(zTemp0)
.1df0	a9 00		lda #$00			lda 	#((0) & $FF)
.1df2	8d 13 07	sta $0713			sta 	0+freeVariableMemory
.1df5	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1df7	8d 14 07	sta $0714			sta 	1+freeVariableMemory
.1dfa	60		rts				rts
.070f					lineNumberTable:
>070f							.fill 	2
.0711					variableListEnd:
>0711							.fill 	2
.0713					freeVariableMemory:
>0713							.fill 	2
.1dfb					CompileTerm:
.1dfb	20 3a 1a	jsr $1a3a			jsr 	GetNextNonSpace 			; get first non space character.
.1dfe	30 72		bmi $1e72			bmi 	_CTUnaryFunctions
.1e00	20 44 1a	jsr $1a44			jsr 	CharIsDigit 				; found a number
.1e03	b0 3a		bcs $1e3f			bcs 	_CTDigit
.1e05	c9 2e		cmp #$2e			cmp 	#"."
.1e07	f0 36		beq $1e3f			beq 	_CTDigit
.1e09	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1e0b	f0 43		beq $1e50			beq 	_CTString
.1e0d	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1e0f	f0 28		beq $1e39			beq 	_CTOtherBase
.1e11	c9 24		cmp #$24			cmp 	#"$"
.1e13	f0 24		beq $1e39			beq 	_CTOtherBase
.1e15	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1e17	f0 17		beq $1e30			beq 	_CTBrackets
.1e19	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1e1b	90 10		bcc $1e2d			bcc 	_CTSyntax
.1e1d	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1e1f	b0 0c		bcs $1e2d			bcs 	_CTSyntax
.1e21	20 90 1d	jsr $1d90			jsr 	GetReferenceTerm 			; figure out what it is.
.1e24	48		pha				pha 								; save type on stack
.1e25	18		clc				clc 								; read it
.1e26	20 42 1d	jsr $1d42			jsr 	GetSetVariable
.1e29	68		pla				pla
.1e2a	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1e2c	60		rts				rts
.1e2d					_CTSyntax:
.1e2d	4c 2e 1f	jmp $1f2e		jmp	ErrorV_syntax
.1e30					_CTBrackets:
.1e30	20 d1 13	jsr $13d1			jsr 	CompileExpressionAt0
.1e33	48		pha				pha
.1e34	20 2c 11	jsr $112c			jsr 	CheckNextRParen
.1e37	68		pla				pla
.1e38	60		rts				rts
.1e39					_CTOtherBase:
.1e39	20 9b 10	jsr $109b			jsr 	InlineNonDecimal 			; non decimal constant handler
.1e3c	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e3e	60		rts				rts
.1e3f					_CTDigit:
.1e3f	20 98 1c	jsr $1c98			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1e42	90 06		bcc $1e4a			bcc	 	_CTFloat 					; have a float or long int.
.1e44	20 cb 11	jsr $11cb			jsr 	PushIntegerYA 				; code to push on stack
.1e47	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e49	60		rts				rts
.1e4a					_CTFloat:
.1e4a	20 ed 11	jsr $11ed			jsr 	PushFloat  					; code to push float
.1e4d	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1e4f	60		rts				rts
.1e50					_CTString:
.1e50	20 01 11	jsr $1101			jsr 	BufferClear 				; copy it to the buffer
.1e53					_CTStringLoop:
.1e53	20 1e 1a	jsr $1a1e			jsr 	LookNext 					; reached EOL/EOS
.1e56	f0 d5		beq $1e2d			beq 	_CTSyntax
.1e58	c9 22		cmp #$22			cmp 	#'"'
.1e5a	f0 08		beq $1e64			beq 	_CTStringDone
.1e5c	20 05 11	jsr $1105			jsr 	BufferWrite 				; write and consume
.1e5f	20 2f 1a	jsr $1a2f			jsr 	GetNext
.1e62	80 ef		bra $1e53			bra 	_CTStringLoop
.1e64					_CTStringDone:
.1e64	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume closing quote.
.1e67	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1e69	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1e6c	20 11 11	jsr $1111			jsr 	BufferOutput
.1e6f	a9 40		lda #$40			lda 	#NSSString 					; string type
.1e71	60		rts				rts
.1e72					_CTUnaryFunctions:
.1e72	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1e74	f0 0a		beq $1e80			beq 	_CTNegation
.1e76	a2 c9		ldx #$c9			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1e78	a0 17		ldy #$17			ldy 	#UnaryTables >> 8
.1e7a	20 c3 18	jsr $18c3			jsr 	GeneratorProcess
.1e7d	90 ae		bcc $1e2d			bcc		_CTSyntax
.1e7f	60		rts				rts
.1e80					_CTNegation:
.1e80	20 fb 1d	jsr $1dfb			jsr 	CompileTerm 				; compile a term.
.1e83	48		pha				pha
.1e84	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1e86	c9 00		cmp #$00			cmp 	#NSSIFloat
.1e88	d0 07		bne $1e91			bne 	_CTType 					; error
.1e8a	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1e8c	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1e8f	68		pla				pla 								; return original type.
.1e90	60		rts				rts
.1e91					_CTType:
.1e91	4c 3e 1f	jmp $1f3e		jmp	ErrorV_type
.1e94					CommandWAIT:
.1e94	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace
.1e97	c9 2c		cmp #$2c			cmp 	#","
.1e99	f0 10		beq $1eab			beq 	_CWThirdParameter
.1e9b	a9 00		lda #$00			lda 	#0
.1e9d	20 de 11	jsr $11de			jsr 	PushIntegerA
.1ea0					_CWExit:
.1ea0	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1ea2	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1ea5	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1ea7	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1eaa	60		rts				rts
.1eab					_CWThirdParameter:
.1eab	20 2f 1a	jsr $1a2f			jsr 	GetNext
.1eae	20 d3 13	jsr $13d3			jsr 	CompileExpressionAtA
.1eb1	29 40		and #$40			and 	#NSSTypeMask
.1eb3	c9 00		cmp #$00			cmp 	#NSSIFloat
.1eb5	f0 e9		beq $1ea0			beq 	_CWExit
.1eb7	4c 3e 1f	jmp $1f3e		jmp	ErrorV_type
.1eba					CommandCMD:
.1eba	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.1ebc	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1ebf	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; followed by a , ?
.1ec2	c9 2c		cmp #$2c			cmp 	#","
.1ec4	d0 06		bne $1ecc			bne 	_CCMDExit
.1ec6	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume comma.
.1ec9	20 bd 1c	jsr $1cbd			jsr 	CommandPRINT 				; do the print code
.1ecc					_CCMDExit:
.1ecc	60		rts				rts
.1ecd					CommandOPEN:
.1ecd	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; followed by a , ?
.1ed0	c9 2c		cmp #$2c			cmp 	#","
.1ed2	d0 15		bne $1ee9			bne 	_COTwoDefaults
.1ed4	20 2f 1a	jsr $1a2f			jsr 	GetNext 					; consume comma
.1ed7	20 d1 13	jsr $13d1			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1eda	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1edc	f0 1e		beq $1efc			beq 	_COThreeIntegers
.1ede	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1ee0	20 de 11	jsr $11de			jsr 	PushIntegerA
.1ee3	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1ee5	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1ee8	60		rts				rts
.1ee9					_COTwoDefaults:
.1ee9	a9 00		lda #$00			lda 	#0
.1eeb	20 de 11	jsr $11de			jsr 	PushIntegerA
.1eee					_COCompileNullString:
.1eee	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1ef0	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1ef3	a9 00		lda #$00			lda 	#0
.1ef5	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1ef8	20 ed 10	jsr $10ed			jsr 	WriteCodeByte
.1efb	60		rts				rts
.1efc					_COThreeIntegers:
.1efc	20 21 1a	jsr $1a21			jsr 	LookNextNonSpace 			; is there a ,
.1eff	c9 2c		cmp #$2c			cmp 	#","
.1f01	d0 eb		bne $1eee			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1f03	20 2f 1a	jsr $1a2f			jsr 	GetNext
.1f06	20 d1 13	jsr $13d1			jsr 	CompileExpressionAt0 		; should be a filename
.1f09	29 40		and #$40			and 	#NSSString
.1f0b	f0 01		beq $1f0e			beq 	_COType
.1f0d	60		rts				rts
.1f0e					_COType:
.1f0e	4c 3e 1f	jmp $1f3e		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					codePage:
>0028							.fill 	1
.0029					objPtr:
>0029							.fill 	2
.002b					objPage:
>002b							.fill 	1
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1f11					ErrorV_range:
.1f11	20 89 13	jsr $1389		jsr	ErrorHandler
>1f14	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f1c	41 4e 47 45 00
.1f21					ErrorV_value:
.1f21	20 89 13	jsr $1389		jsr	ErrorHandler
>1f24	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f2c	45 00
.1f2e					ErrorV_syntax:
.1f2e	20 89 13	jsr $1389		jsr	ErrorHandler
>1f31	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f39	52 52 4f 52 00
.1f3e					ErrorV_type:
.1f3e	20 89 13	jsr $1389		jsr	ErrorHandler
>1f41	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f49	4d 41 54 43 48 00
.1f4f					ErrorV_unimplemented:
.1f4f	20 89 13	jsr $1389		jsr	ErrorHandler
>1f52	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f5a	45 4d 45 4e 54 45 44 00
.1f62					ErrorV_assert:
.1f62	20 89 13	jsr $1389		jsr	ErrorHandler
>1f65	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f6d	41 49 4c 00
.1f71					ErrorV_line:
.1f71	20 89 13	jsr $1389		jsr	ErrorHandler
>1f74	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f7c	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f88					ErrorV_internal:
.1f88	20 89 13	jsr $1389		jsr	ErrorHandler
>1f8b	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f93	20 45 52 52 4f 52 00
.1f9a					ErrorV_divzero:
.1f9a	20 89 13	jsr $1389		jsr	ErrorHandler
>1f9d	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fa5	59 20 5a 45 52 4f 00
.1fac					ErrorV_structure:
.1fac	20 89 13	jsr $1389		jsr	ErrorHandler
>1faf	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fb7	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fc3					ErrorV_stop:
.1fc3	20 89 13	jsr $1389		jsr	ErrorHandler
>1fc6	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fce	53 54 4f 50 50 45 44 00
.1fd6					ErrorV_data:
.1fd6	20 89 13	jsr $1389		jsr	ErrorHandler
>1fd9	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fe1	41 54 41 00
.1fe5					ErrorV_undeclared:
.1fe5	20 89 13	jsr $1389		jsr	ErrorHandler
>1fe8	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1ff0	41 52 52 41 59 00
.1ff6					ErrorV_redefine:
.1ff6	20 89 13	jsr $1389		jsr	ErrorHandler
>1ff9	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>2001	44 45 46 49 4e 45 44 00
.2009					ErrorV_index:
.2009	20 89 13	jsr $1389		jsr	ErrorHandler
>200c	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2014	59 20 49 4e 44 45 58 00
.201c					ErrorV_memory:
.201c	20 89 13	jsr $1389		jsr	ErrorHandler
>201f	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2027	45 4d 4f 52 59 00
.202d					ErrorV_channel:
.202d	20 89 13	jsr $1389		jsr	ErrorHandler
>2030	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2038	54 50 55 54 20 45 52 52 4f 52 00
.2043					MoveObjectForward:
.2043	b2 29		lda ($29)			lda 	(objPtr) 					; get next
.2045	c9 ff		cmp #$ff			cmp 	#$FF
.2047	f0 36		beq $207f			beq 	_MOFEnd
.2049	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.204b	90 24		bcc $2071			bcc 	_MOFAdvance1 				; forward 1
.204d	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.204f	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2051	90 20		bcc $2073			bcc 	_MOFAdvanceY
.2053	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2055	90 1a		bcc $2071			bcc 	_MOFAdvance1 				; forward 1
.2057	a8		tay				tay 								; read the size.
.2058	b9 bd 1f	lda $1fbd,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.205b	a8		tay				tay
.205c	c8		iny				iny 								; add 1 for the system token.
.205d	d0 14		bne $2073			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.205f	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2061	b1 29		lda ($29),y			lda 	(objPtr),y
.2063	a8		tay				tay 								; into Y.
.2064	18		clc				clc
.2065	a5 29		lda $29				lda 	objPtr						; add 2 to the object pointer
.2067	69 02		adc #$02			adc 	#2
.2069	85 29		sta $29				sta 	objPtr
.206b	90 02		bcc $206f			bcc 	_MOFNoCarry1
.206d	e6 2a		inc $2a				inc 	objPtr+1
.206f					_MOFNoCarry1:
.206f	80 02		bra $2073			bra 	_MOFAdvanceY
.2071					_MOFAdvance1:
.2071	a0 01		ldy #$01			ldy 	#1
.2073					_MOFAdvanceY:
.2073	98		tya				tya 								; add X to objPtr
.2074	18		clc				clc
.2075	65 29		adc $29				adc 	objPtr
.2077	85 29		sta $29				sta 	objPtr
.2079	90 02		bcc $207d			bcc 	_MOFNoCarry2
.207b	e6 2a		inc $2a				inc 	objPtr+1
.207d					_MOFNoCarry2:
.207d	18		clc				clc 								; not completed.
.207e	60		rts				rts
.207f					_MOFEnd:
.207f	e6 29		inc $29				inc 	objPtr
.2081	d0 02		bne $2085			bne 	_MOFENoCarry
.2083	e6 2a		inc $2a				inc 	objPtr+1
.2085					_MOFENoCarry:
.2085	38		sec				sec
.2086	60		rts				rts
.2087					MOFSizeTable:
>2087	01					.byte	1         	; $ca .shift
>2088	01					.byte	1         	; $cb .byte
>2089	02					.byte	2         	; $cc .word
>208a	05					.byte	5         	; $cd .float
>208b	ff					.byte	255       	; $ce .string
>208c	ff					.byte	255       	; $cf .data
>208d	03					.byte	3         	; $d0 .goto
>208e	03					.byte	3         	; $d1 .gosub
>208f	03					.byte	3         	; $d2 .goto.z
>2090	03					.byte	3         	; $d3 .goto.nz
>2091	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0715					numberBuffer:
>0715							.fill 	34
.2092					FloatSubtract:
.2092	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.2094	49 80		eor #$80			eor 	#$80
.2096	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.2098					FloatAdd:
.2098	ca		dex				dex
.2099	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.209b	15 6f		ora $6f,x			ora 	NSExponent+1,x
.209d	15 62		ora $62,x			ora 	NSMantissa3,x
.209f	15 63		ora $63,x			ora 	NSMantissa3+1,x
.20a1	d0 04		bne $20a7			bne 	_FAUseFloat
.20a3	20 34 24	jsr $2434			jsr 	FloatInt32Add 				; use the int32 one.
.20a6	60		rts				rts
.20a7					_FAUseFloat:
.20a7	20 c9 23	jsr $23c9			jsr 	FloatNormalise 				; normalise S[X]
.20aa	f0 51		beq $20fd			beq 	_FAReturn1
.20ac	e8		inx				inx 								; normalise S[X+1]
.20ad	20 c9 23	jsr $23c9			jsr 	FloatNormalise
.20b0	ca		dex				dex
.20b1	c9 00		cmp #$00			cmp 	#0
.20b3	f0 60		beq $2115			beq 	_FAExit 					; if so, just return A
.20b5	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20b7	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20b9	f0 18		beq $20d3			beq 	_FAExponentsEqual
.20bb	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20bd	a8		tay				tay
.20be	38		sec				sec 								; do a signed comparison of the exponents.
.20bf	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20c1	50 02		bvc $20c5			bvc 	_FANoSignedChange
.20c3	49 80		eor #$80			eor 	#$80
.20c5					_FANoSignedChange:
.20c5	29 80		and #$80			and 	#$80
.20c7	10 02		bpl $20cb			bpl 	_FAHaveMax
.20c9	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.20cb					_FAHaveMax:
.20cb	20 16 21	jsr $2116			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20ce	e8		inx				inx
.20cf	20 16 21	jsr $2116			jsr 	_FAShiftToExponent
.20d2	ca		dex				dex
.20d3					_FAExponentsEqual:
.20d3	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.20d5	55 33		eor $33,x			eor 	NSStatus+1,x
.20d7	30 0e		bmi $20e7			bmi 	_FADifferentSigns
.20d9	20 00 24	jsr $2400			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20dc	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20de	10 35		bpl $2115			bpl 	_FAExit 					; if no, we are done.
.20e0	20 8d 26	jsr $268d			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20e3	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.20e5	80 2e		bra $2115			bra 	_FAExit
.20e7					_FADifferentSigns:
.20e7	20 1a 24	jsr $241a			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20ea	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.20ec	10 06		bpl $20f4			bpl 	_FACheckZero 				; if no, check for -0
.20ee	20 36 26	jsr $2636			jsr 	FloatNegate 					; netate result
.20f1	20 3d 26	jsr $263d			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20f4					_FACheckZero:
.20f4	20 96 26	jsr $2696			jsr 	FloatIsZero	 				; check for -0
.20f7	d0 1c		bne $2115			bne 	_FAExit
.20f9	74 32		stz $32,x			stz 	NSStatus,x
.20fb	80 18		bra $2115			bra 	_FAExit
.20fd					_FAReturn1:
.20fd	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20ff	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2101	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2103	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2105	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.2107	95 56		sta $56,x			sta 	NSMantissa2,x
.2109	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.210b	95 62		sta $62,x			sta 	NSMantissa3,x
.210d	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.210f	95 6e		sta $6e,x			sta 	NSExponent,x
.2111	b5 33		lda $33,x			lda 	NSStatus+1,x
.2113	95 32		sta $32,x			sta 	NSStatus,x
.2115					_FAExit:
.2115	60		rts				rts
.2116					_FAShiftToExponent:
.2116					_FAShiftToExponent2:
.2116	98		tya				tya 								; compare Y to exponent
.2117	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2119	f0 07		beq $2122			beq 	_FASEExit 					; exit if so.
.211b	20 8d 26	jsr $268d			jsr 	FloatShiftRight	 			; shift the mantissa right
.211e	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.2120	80 f4		bra $2116			bra 	_FAShiftToExponent2
.2122					_FASEExit:
.2122	60		rts				rts
.2123					CompareEqual:
.2123	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2125	d0 09		bne $2130			bne 	ReturnFalse
.2127					ReturnTrue:
.2127	a9 01		lda #$01			lda 	#1
.2129	95 3e		sta $3e,x			sta 	NSMantissa0,x
.212b	a9 80		lda #$80			lda 	#$80
.212d	95 32		sta $32,x			sta 	NSStatus,x
.212f	60		rts				rts
.2130					ReturnFalse:
.2130	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2132	60		rts				rts
.2133					CompareNotEqual:
.2133	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2135	d0 f0		bne $2127			bne 	ReturnTrue
.2137	80 f7		bra $2130			bra 	ReturnFalse
.2139					CompareLess:
.2139	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.213b	c9 ff		cmp #$ff			cmp 	#$FF
.213d	f0 e8		beq $2127			beq 	ReturnTrue
.213f	80 ef		bra $2130			bra 	ReturnFalse
.2141					CompareGreater:
.2141	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2143	c9 01		cmp #$01			cmp 	#$01
.2145	f0 e0		beq $2127			beq 	ReturnTrue
.2147	80 e7		bra $2130			bra 	ReturnFalse
.2149					CompareLessEqual:
.2149	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.214b	c9 01		cmp #$01			cmp 	#$01
.214d	d0 d8		bne $2127			bne 	ReturnTrue
.214f	80 df		bra $2130			bra 	ReturnFalse
.2151					CompareGreaterEqual:
.2151	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2153	c9 ff		cmp #$ff			cmp 	#$FF
.2155	d0 d0		bne $2127			bne 	ReturnTrue
.2157	80 d7		bra $2130			bra 	ReturnFalse
.2159					FloatCompare:
.2159	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.215b	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.215d	48		pha				pha
.215e	20 92 20	jsr $2092			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2161	68		pla				pla
.2162	d0 0c		bne $2170			bne 	_FCCompareFloat
.2164	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2166	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2168	15 56		ora $56,x			ora 	NSMantissa2,x
.216a	15 62		ora $62,x			ora 	NSMantissa3,x
.216c	f0 14		beq $2182			beq 	_FCExit 					; if zero, return zero
.216e	80 0a		bra $217a			bra 	_FCSign
.2170					_FCCompareFloat:
.2170	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2172	29 f0		and #$f0			and 	#$F0
.2174	15 56		ora $56,x			ora 	NSMantissa2,x
.2176	15 62		ora $62,x			ora 	NSMantissa3,x
.2178	f0 08		beq $2182			beq 	_FCExit 					; zero, so approximately identical
.217a					_FCSign:
.217a	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.217c	34 32		bit $32,x			bit 	NSStatus,x
.217e	10 02		bpl $2182			bpl 	_FCExit
.2180					_FCNegative:
.2180	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2182					_FCExit:
.2182	20 76 26	jsr $2676			jsr 	FloatSetByte 				; set the result 255,0,1
.2185	60		rts				rts
.2186					FloatScalarTable:
>2186	66 66 66 66				.dword $66666666 ; 0.1
>218a	de					.byte $de
>218b	1f 85 eb 51				.dword $51eb851f ; 0.01
>218f	db					.byte $db
>2190	4c 37 89 41				.dword $4189374c ; 0.001
>2194	d8					.byte $d8
>2195	ac 8b db 68				.dword $68db8bac ; 0.0001
>2199	d4					.byte $d4
>219a	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>219e	d1					.byte $d1
>219f	83 de 1b 43				.dword $431bde83 ; 1e-06
>21a3	ce					.byte $ce
>21a4	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21a8	ca					.byte $ca
>21a9	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21ad	c7					.byte $c7
>21ae	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21b2	c4					.byte $c4
>21b3	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21b7	c0					.byte $c0
>21b8	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21bc	bd					.byte $bd
.21bd					FloatDivide:
.21bd	48		pha				pha
.21be	20 c9 23	jsr $23c9			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21c1	ca		dex				dex
.21c2	c9 00		cmp #$00			cmp 	#0
.21c4	f0 1e		beq $21e4			beq 	_FDZero
.21c6	20 c9 23	jsr $23c9			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21c9	f0 16		beq $21e1			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21cb	20 2c 22	jsr $222c			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21ce	20 f9 21	jsr $21f9			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21d1	20 c9 23	jsr $23c9			jsr		FloatNormalise 				; renormalise
.21d4	20 bf 23	jsr $23bf			jsr 	FloatCalculateSign 			; calculate result sign
.21d7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.21d9	38		sec				sec
.21da	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.21dc	38		sec				sec
.21dd	e9 1e		sbc #$1e			sbc 	#30
.21df	95 6e		sta $6e,x			sta 	NSExponent,x
.21e1					_FDExit:
.21e1	68		pla				pla
.21e2	18		clc				clc
.21e3	60		rts				rts
.21e4					_FDZero:
.21e4	68		pla				pla
.21e5	38		sec				sec
.21e6	60		rts				rts
.21e7					DivideInt32:
.21e7	20 af 22	jsr $22af			jsr 	FloatIntegerPart 			; make both integers
.21ea	ca		dex				dex
.21eb	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.21ee	20 0a 22	jsr $220a			jsr 	Int32Divide 				; divide
.21f1	20 f9 21	jsr $21f9			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21f4	20 bf 23	jsr $23bf			jsr 	FloatCalculateSign 			; calculate result sign
.21f7	18		clc				clc
.21f8	60		rts				rts
.21f9					NSMCopyPlusTwoToZero:
.21f9	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21fb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21fd	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21ff	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2201	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.2203	95 56		sta $56,x			sta 	NSMantissa2,x
.2205	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.2207	95 62		sta $62,x			sta 	NSMantissa3,x
.2209	60		rts				rts
.220a					Int32Divide:
.220a	48		pha				pha 								; save AXY
.220b	5a		phy				phy
.220c	20 57 26	jsr $2657			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.220f	20 70 26	jsr $2670			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2212	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2214					_I32DivideLoop:
.2214	e8		inx				inx
.2215	e8		inx				inx
.2216	20 83 26	jsr $2683			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2219	ca		dex				dex
.221a	ca		dex				dex
.221b	20 84 26	jsr $2684			jsr 	FloatRotateLeft
.221e	20 4a 22	jsr $224a			jsr 	FloatDivideCheck 			; check if subtract possible
.2221	90 02		bcc $2225			bcc 	_I32DivideNoCarryIn
.2223	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2225					_I32DivideNoCarryIn:
.2225	88		dey				dey 								; loop round till division completed.
.2226	d0 ec		bne $2214			bne 	_I32DivideLoop
.2228	7a		ply				ply 								; restore AXY and exit
.2229	68		pla				pla
.222a	18		clc				clc
.222b	60		rts				rts
.222c					Int32ShiftDivide:
.222c	48		pha				pha 								; save AY
.222d	5a		phy				phy
.222e	e8		inx				inx 								; clear S[X+2]
.222f	e8		inx				inx
.2230	20 74 26	jsr $2674			jsr 	FloatSetZero
.2233	ca		dex				dex
.2234	ca		dex				dex
.2235	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2237					_I32SDLoop:
.2237	20 4a 22	jsr $224a			jsr 	FloatDivideCheck 			; check if subtract possible
.223a	e8		inx				inx
.223b	e8		inx				inx
.223c	20 84 26	jsr $2684			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.223f	ca		dex				dex
.2240	ca		dex				dex
.2241	20 84 26	jsr $2684			jsr 	FloatRotateLeft
.2244	88		dey				dey 	 							; do 31 times
.2245	d0 f0		bne $2237			bne 	_I32SDLoop
.2247	7a		ply				ply 								; restore AY and exit
.2248	68		pla				pla
.2249	60		rts				rts
.224a					FloatDivideCheck:
.224a	20 1a 24	jsr $241a			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.224d	b0 04		bcs $2253			bcs 	_DCSExit 					; if carry set, then could do, exit
.224f	20 00 24	jsr $2400			jsr 	FloatAddTopTwoStack 		; add it back in
.2252	18		clc				clc 								; and return False
.2253					_DCSExit:
.2253	60		rts				rts
.2254					FloatFractionalPart:
.2254	5a		phy				phy
.2255	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.2257	29 7f		and #$7f			and 	#$7F
.2259	95 32		sta $32,x			sta 	NSStatus,x
.225b	20 c9 23	jsr $23c9			jsr 	FloatNormalise
.225e	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2260	38		sec				sec
.2261	e9 e0		sbc #$e0			sbc 	#$E0
.2263	90 29		bcc $228e			bcc 	_FFPExit 					; already fractional
.2265	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2267	b0 22		bcs $228b			bcs 	_FFPZero
.2269	a8		tay				tay 								; put count to do in Y
.226a	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.226c	20 93 22	jsr $2293			jsr 	_FFPPartial
.226f	95 62		sta $62,x			sta 	NSMantissa3,x
.2271	b5 56		lda $56,x			lda 	NSMantissa2,x
.2273	20 93 22	jsr $2293			jsr 	_FFPPartial
.2276	95 56		sta $56,x			sta 	NSMantissa2,x
.2278	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.227a	20 93 22	jsr $2293			jsr 	_FFPPartial
.227d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.227f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2281	20 93 22	jsr $2293			jsr 	_FFPPartial
.2284	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2286	20 96 26	jsr $2696			jsr 	FloatIsZero 					; zeroed check.
.2289	d0 03		bne $228e			bne 	_FFPExit
.228b					_FFPZero:
.228b	20 74 26	jsr $2674			jsr 	FloatSetZero
.228e					_FFPExit:
.228e	20 c9 23	jsr $23c9			jsr 	FloatNormalise
.2291	7a		ply				ply
.2292	60		rts				rts
.2293					_FFPPartial:
.2293	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2295	f0 17		beq $22ae			beq 	_FFFPPExit
.2297	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.2299	b0 0c		bcs $22a7			bcs 	_FFFPPWholeByte
.229b	5a		phy				phy
.229c					_FFFPPLeft:
.229c	0a		asl a				asl 	a
.229d	88		dey				dey
.229e	d0 fc		bne $229c			bne 	_FFFPPLeft
.22a0	7a		ply				ply
.22a1					_FFFPPRight:
.22a1	4a		lsr a				lsr 	a
.22a2	88		dey				dey
.22a3	d0 fc		bne $22a1			bne 	_FFFPPRight
.22a5	80 07		bra $22ae			bra 	_FFFPPExit
.22a7					_FFFPPWholeByte:
.22a7	98		tya				tya 								; subtract 8 from count
.22a8	38		sec				sec
.22a9	e9 08		sbc #$08			sbc 	#8
.22ab	a8		tay				tay
.22ac	a9 00		lda #$00			lda 	#0 							; and clear all
.22ae					_FFFPPExit:
.22ae	60		rts				rts
.22af					FloatIntegerPart:
.22af	48		pha				pha
.22b0	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22b2	f0 1d		beq $22d1			beq 	_FIPExit 					; if so do nothing
.22b4	20 96 26	jsr $2696			jsr 	FloatIsZero 				; is it zero ?
.22b7	f0 15		beq $22ce			beq 	_FIPZero 					; if so return zero.
.22b9	20 c9 23	jsr $23c9			jsr 	FloatNormalise 				; normalise
.22bc	f0 10		beq $22ce			beq 	_FIPZero 					; normalised to zero, exit zero
.22be					_FIPShift:
.22be	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22c0	10 07		bpl $22c9			bpl 	_FIPCheckZero
.22c2	20 8d 26	jsr $268d			jsr 	FloatShiftRight 			; shift mantissa right
.22c5	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22c7	80 f5		bra $22be			bra 	_FIPShift
.22c9					_FIPCheckZero:
.22c9	20 96 26	jsr $2696			jsr 	FloatIsZero 				; avoid -0 problem
.22cc	d0 03		bne $22d1			bne 	_FIPExit 					; set to zero if mantissa zero.
.22ce					_FIPZero:
.22ce	20 74 26	jsr $2674			jsr 	FloatSetZero
.22d1					_FIPExit:
.22d1	68		pla				pla
.22d2	60		rts				rts
.22d3					FloatIntegerPartDown:
.22d3	48		pha				pha
.22d4	5a		phy				phy
.22d5	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22d7	f0 36		beq $230f			beq 	_FIPExit 					; if so do nothing
.22d9	20 96 26	jsr $2696			jsr 	FloatIsZero 				; is it zero ?
.22dc	f0 2e		beq $230c			beq 	_FIPZero 					; if so return zero.
.22de	20 c9 23	jsr $23c9			jsr 	FloatNormalise 				; normalise
.22e1	f0 29		beq $230c			beq 	_FIPZero 					; normalised to zero, exit zero
.22e3	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22e5					_FIPShift:
.22e5	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22e7	10 0a		bpl $22f3			bpl 	_FIPCheckDown
.22e9	20 8d 26	jsr $268d			jsr 	FloatShiftRight 			; shift mantissa right
.22ec	90 01		bcc $22ef			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22ee	c8		iny				iny
.22ef					_FIPNoFrac:
.22ef	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22f1	80 f2		bra $22e5			bra 	_FIPShift
.22f3					_FIPCheckDown:
.22f3	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22f5	f0 10		beq $2307			beq 	_FIPCheckZero
.22f7	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22f9	10 0c		bpl $2307			bpl 	_FIPCheckZero
.22fb	e8		inx				inx 								; -ve so round *down*.
.22fc	a9 01		lda #$01			lda 	#1
.22fe	20 76 26	jsr $2676			jsr 	FloatSetByte
.2301	20 36 26	jsr $2636			jsr 	FloatNegate
.2304	20 98 20	jsr $2098			jsr 	FloatAdd
.2307					_FIPCheckZero:
.2307	20 96 26	jsr $2696			jsr 	FloatIsZero 				; avoid -0 problem
.230a	d0 03		bne $230f			bne 	_FIPExit 					; set to zero if mantissa zero.
.230c					_FIPZero:
.230c	20 74 26	jsr $2674			jsr 	FloatSetZero
.230f					_FIPExit:
.230f	7a		ply				ply
.2310	68		pla				pla
.2311	60		rts				rts
.2312					FloatInt8Multiply:
.2312	5a		phy				phy
.2313	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2315	a8		tay				tay
.2316	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2318					_FI8MLoop:
.2318	98		tya				tya 								; shift right shifter right into carry
.2319	4a		lsr a				lsr 	a
.231a	a8		tay				tay
.231b	90 0d		bcc $232a			bcc 	_FI8MNoAdd
.231d	18		clc				clc
.231e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2320	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.2322	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2324	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2326	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.2328	95 4a		sta $4a,x			sta 	NSMantissa1,x
.232a					_FI8MNoAdd:
.232a	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.232c	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.232e	c0 00		cpy #$00			cpy 	#0
.2330	d0 e6		bne $2318			bne 	_FI8MLoop 					; until right shifter zero.
.2332	7a		ply				ply
.2333	60		rts				rts
.2334					FloatMultiply:
.2334	ca		dex				dex
.2335	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.2337	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2339	15 62		ora $62,x			ora 	NSMantissa3,x
.233b	15 63		ora $63,x			ora 	NSMantissa3+1,x
.233d	d0 21		bne $2360			bne 	_FMUseFloat
.233f	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2341	15 33		ora $33,x			ora 	NSStatus+1,x
.2343	29 80		and #$80			and 	#$80
.2345	15 62		ora $62,x			ora 	NSMantissa3,x
.2347	15 56		ora $56,x			ora 	NSMantissa2,x
.2349	15 4a		ora $4a,x			ora 	NSMantissa1,x
.234b	15 63		ora $63,x			ora 	NSMantissa3+1,x
.234d	15 57		ora $57,x			ora 	NSMantissa2+1,x
.234f	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2351	d0 04		bne $2357			bne 	_FMInt32
.2353	20 12 23	jsr $2312			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2356	60		rts				rts
.2357					_FMInt32:
.2357	20 81 23	jsr $2381			jsr 	FloatMultiplyShort			; use the int32 one.
.235a	18		clc				clc 								; fix it up if gone out of range
.235b	75 6e		adc $6e,x			adc 	NSExponent,x
.235d	95 6e		sta $6e,x			sta 	NSExponent,x
.235f	60		rts				rts
.2360					_FMUseFloat:
.2360	20 c9 23	jsr $23c9			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2363	f0 18		beq $237d			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2365	e8		inx				inx
.2366	20 c9 23	jsr $23c9			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2369	ca		dex				dex
.236a	c9 00		cmp #$00			cmp 	#0
.236c	f0 0c		beq $237a			beq 	_FDSetZero
.236e	20 81 23	jsr $2381			jsr 	FloatMultiplyShort 			; calculate the result.
.2371	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2373	18		clc				clc
.2374	75 6f		adc $6f,x			adc 	NSExponent+1,x
.2376	95 6e		sta $6e,x			sta 	NSExponent,x
.2378	80 03		bra $237d			bra 	_FDExit
.237a					_FDSetZero:
.237a	20 74 26	jsr $2674			jsr 	FloatSetZero 				; return 0
.237d					_FDExit:
.237d	20 c9 23	jsr $23c9			jsr 	FloatNormalise 				; normalise the result
.2380	60		rts				rts
.2381					FloatMultiplyShort:
.2381	5a		phy				phy 								; save Y
.2382	20 57 26	jsr $2657			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2385	20 70 26	jsr $2670			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2388	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.238a					_I32MLoop:
.238a	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.238c	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.238e	15 58		ora $58,x			ora 	NSMantissa2+2,x
.2390	15 64		ora $64,x			ora 	NSMantissa3+2,x
.2392	f0 25		beq $23b9			beq 	_I32MExit 					; exit if zero
.2394	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2396	29 01		and #$01			and 	#1
.2398	f0 0d		beq $23a7			beq 	_I32MNoAdd
.239a	20 00 24	jsr $2400			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.239d	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.239f	10 06		bpl $23a7			bpl 	_I32MNoAdd
.23a1					_I32ShiftRight:
.23a1	20 8d 26	jsr $268d			jsr 	FloatShiftRight 			; shift S[X] right
.23a4	c8		iny				iny 								; increment shift count
.23a5	80 09		bra $23b0			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23a7					_I32MNoAdd:
.23a7	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23a9	70 f6		bvs $23a1			bvs 	_I32ShiftRight 				; instead.
.23ab	e8		inx				inx
.23ac	20 83 26	jsr $2683			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23af	ca		dex				dex
.23b0					_I32MShiftUpper:
.23b0	e8		inx				inx 								; shift S[X+2] right
.23b1	e8		inx				inx
.23b2	20 8d 26	jsr $268d			jsr 	FloatShiftRight
.23b5	ca		dex				dex
.23b6	ca		dex				dex
.23b7	80 d1		bra $238a			bra 	_I32MLoop 					; try again.
.23b9					_I32MExit:
.23b9	20 bf 23	jsr $23bf			jsr 	FloatCalculateSign
.23bc	98		tya				tya 								; shift in A
.23bd	7a		ply				ply 								; restore Y and exit
.23be	60		rts				rts
.23bf					FloatCalculateSign:
.23bf	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23c1	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23c3	55 33		eor $33,x			eor 	NSStatus+1,x
.23c5	0a		asl a				asl 	a 							; shift bit 7 into carry
.23c6	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23c8	60		rts				rts
.23c9					FloatNormalise:
.23c9	20 96 26	jsr $2696			jsr 	FloatIsZero 				; if zero exit
.23cc	d0 07		bne $23d5			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23ce	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.23d0	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.23d2	a9 00		lda #$00			lda 	#0 							; set Z flag
.23d4	60		rts				rts
.23d5					_NSNormaliseOptimise:
.23d5	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23d7	d0 19		bne $23f2			bne 	_NSNormaliseLoop
.23d9	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.23db	30 15		bmi $23f2			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23dd	95 62		sta $62,x			sta 	NSMantissa3,x
.23df	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.23e1	95 56		sta $56,x			sta 	NSMantissa2,x
.23e3	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.23e5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23e7	74 3e		stz $3e,x			stz 	NSMantissa0,x
.23e9	b5 6e		lda $6e,x			lda 	NSExponent,x
.23eb	38		sec				sec
.23ec	e9 08		sbc #$08			sbc 	#8
.23ee	95 6e		sta $6e,x			sta 	NSExponent,x
.23f0	80 e3		bra $23d5			bra 	_NSNormaliseOptimise
.23f2					_NSNormaliseLoop:
.23f2	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23f4	70 07		bvs $23fd			bvs 	_NSNExit 					; exit if so with Z flag clear
.23f6	20 83 26	jsr $2683			jsr 	FloatShiftLeft 				; shift mantissa left
.23f9	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23fb	80 f5		bra $23f2			bra 	_NSNormaliseLoop
.23fd					_NSNExit:
.23fd	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23ff	60		rts				rts
.2400					FloatAddTopTwoStack:
.2400	18		clc				clc
.2401	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2403	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.2405	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2407	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2409	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.240b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.240d	b5 56		lda $56,x			lda		NSMantissa2,x
.240f	75 57		adc $57,x			adc 		NSMantissa2+1,x
.2411	95 56		sta $56,x			sta 	NSMantissa2,x
.2413	b5 62		lda $62,x			lda		NSMantissa3,x
.2415	75 63		adc $63,x			adc 		NSMantissa3+1,x
.2417	95 62		sta $62,x			sta 	NSMantissa3,x
.2419	60		rts				rts
.241a					FloatSubTopTwoStack:
.241a	38		sec				sec
.241b	b5 3e		lda $3e,x			lda		NSMantissa0,x
.241d	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.241f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2421	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2423	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.2425	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2427	b5 56		lda $56,x			lda		NSMantissa2,x
.2429	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.242b	95 56		sta $56,x			sta 	NSMantissa2,x
.242d	b5 62		lda $62,x			lda		NSMantissa3,x
.242f	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.2431	95 62		sta $62,x			sta 	NSMantissa3,x
.2433	60		rts				rts
.2434					FloatInt32Add:
.2434	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2436	55 33		eor $33,x			eor 	NSStatus+1,x
.2438	30 04		bmi $243e			bmi 	_DiffSigns
.243a	20 00 24	jsr $2400			jsr		FloatAddTopTwoStack
.243d	60		rts				rts
.243e					_DiffSigns:
.243e	20 1a 24	jsr $241a			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2441	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2443	10 07		bpl $244c			bpl 	_AddExit
.2445	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2447	95 32		sta $32,x			sta 	NSStatus,x
.2449	20 3d 26	jsr $263d			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.244c					_AddExit:
.244c	20 96 26	jsr $2696			jsr 	FloatIsZero 				; check for -0
.244f	d0 02		bne $2453			bne 	_AddNonZero
.2451	74 32		stz $32,x			stz 	NSStatus,x
.2453					_AddNonZero:
.2453	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2454					FloatEncodeStart:
.2454	38		sec				sec
.2455	80 01		bra $2458			bra 	FloatEncodeContinue+1
.2457					FloatEncodeContinue:
.2457	18		clc				clc
.2458					FloatEncode:
.2458	08		php				php 								; save reset flag.
.2459	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.245b	f0 15		beq $2472			beq 	_ENIsOkay
.245d	c9 30		cmp #$30			cmp 	#"0"
.245f	90 04		bcc $2465			bcc 	_ENBadNumber
.2461	c9 3a		cmp #$3a			cmp 	#"9"+1
.2463	90 0d		bcc $2472			bcc 	_ENIsOkay
.2465					_ENBadNumber:
.2465	28		plp				plp 								; throw saved reset
.2466	ad 37 07	lda $0737			lda 	encodeState 				; if in decimal mode, construct final number
.2469	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.246b	d0 03		bne $2470			bne 	_ENFail
.246d	4c ea 24	jmp $24ea			jmp 	_ENConstructFinal
.2470					_ENFail:
.2470	18		clc				clc 								; not allowed
.2471	60		rts				rts
.2472					_ENIsOkay:
.2472	28		plp				plp 								; are we restarting
.2473	90 15		bcc $248a			bcc 	_ENNoRestart
.2475					_ENStartEncode:
.2475	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2477	f0 0c		beq $2485			beq 	_ENFirstDP
.2479	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.247b	20 76 26	jsr $2676			jsr 	FloatSetByte 				; in single byte mode.
.247e	a9 01		lda #$01			lda 	#ESTA_Low
.2480					_ENExitChange:
.2480	8d 37 07	sta $0737			sta 	encodeState 				; save new state
.2483	38		sec				sec
.2484	60		rts				rts
.2485					_ENFirstDP:
.2485	20 74 26	jsr $2674			jsr 	FloatSetZero 				; clear integer part
.2488	80 3c		bra $24c6			bra 	_ESTASwitchFloat			; go straight to float and exi
.248a					_ENNoRestart:
.248a	48		pha				pha 								; save digit or DP on stack.
.248b	ad 37 07	lda $0737			lda 	encodeState 				; get current state
.248e	c9 01		cmp #$01			cmp 	#ESTA_Low
.2490	f0 09		beq $249b			beq  	_ESTALowState
.2492	c9 02		cmp #$02			cmp 	#ESTA_High
.2494	f0 26		beq $24bc			beq 	_ESTAHighState
.2496	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2498	f0 38		beq $24d2			beq 	_ESTADecimalState
>249a	db						.byte 	$DB 						; causes a break in the emulator
.249b					_ESTALowState:
.249b	68		pla				pla 								; get value back
.249c	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.249e	f0 26		beq $24c6			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24a0	29 0f		and #$0f			and 	#15 						; make digit
.24a2	8d 38 07	sta $0738			sta 	digitTemp 					; save it.
.24a5	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24a7	0a		asl a				asl 	a
.24a8	0a		asl a				asl 	a
.24a9	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24ab	0a		asl a				asl 	a
.24ac	6d 38 07	adc $0738			adc 	digitTemp
.24af	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24b1	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24b3	90 05		bcc $24ba			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24b5	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24b7	8d 37 07	sta $0737			sta 	encodeState
.24ba					_ESTANoSwitch:
.24ba	38		sec				sec
.24bb	60		rts				rts
.24bc					_ESTAHighState:
.24bc	68		pla				pla 								; get value back
.24bd	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24bf	f0 05		beq $24c6			beq 	_ESTASwitchFloat
.24c1	20 1c 25	jsr $251c			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24c4	38		sec				sec
.24c5	60		rts				rts
.24c6					_ESTASwitchFloat:
.24c6	9c 39 07	stz $0739			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24c9	e8		inx				inx 								; zero the decimal additive.
.24ca	20 74 26	jsr $2674			jsr 	FloatSetZero
.24cd	ca		dex				dex
.24ce	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24d0	80 ae		bra $2480			bra 	_ENExitChange
.24d2					_ESTADecimalState:
.24d2	68		pla				pla 								; digit.
.24d3	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24d5	f0 99		beq $2470			beq 	_ENFail
.24d7	e8		inx				inx 								; put digit into fractional part of X+1
.24d8	20 1c 25	jsr $251c			jsr 	ESTAShiftDigitIntoMantissa
.24db	ca		dex				dex
.24dc	ee 39 07	inc $0739			inc 	decimalCount 				; bump the count of decimals
.24df	ad 39 07	lda $0739			lda 	decimalCount 				; too many decimal digits.
.24e2	c9 0b		cmp #$0b			cmp 	#11
.24e4	f0 02		beq $24e8			beq 	_ESTADSFail
.24e6	38		sec				sec
.24e7	60		rts				rts
.24e8					_ESTADSFail:
.24e8	18		clc				clc
.24e9	60		rts				rts
.24ea					_ENConstructFinal:
.24ea	ad 39 07	lda $0739			lda 	decimalCount 				; get decimal count
.24ed	f0 2b		beq $251a			beq 	_ENCFExit 					; no decimals
.24ef	5a		phy				phy
.24f0	0a		asl a				asl 	a 							; x 4 and CLC
.24f1	0a		asl a				asl 	a
.24f2	6d 39 07	adc $0739			adc 	decimalCount
.24f5	a8		tay				tay
.24f6	b9 81 21	lda $2181,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24f9	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24fb	b9 82 21	lda $2182,y			lda 	FloatScalarTable-5+1,y
.24fe	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2500	b9 83 21	lda $2183,y			lda 	FloatScalarTable-5+2,y
.2503	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2505	b9 84 21	lda $2184,y			lda 	FloatScalarTable-5+3,y
.2508	95 64		sta $64,x			sta 	NSMantissa3+2,x
.250a	b9 85 21	lda $2185,y			lda 	FloatScalarTable-5+4,y
.250d	95 70		sta $70,x			sta 	NSExponent+2,x
.250f	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.2511	e8		inx				inx 								; multiply decimal const by decimal scalar
.2512	e8		inx				inx
.2513	20 34 23	jsr $2334			jsr 	FloatMultiply
.2516	20 98 20	jsr $2098			jsr 	FloatAdd 					; add to integer part.
.2519	7a		ply				ply
.251a					_ENCFExit:
.251a	18		clc				clc 								; reject the digit.
.251b	60		rts				rts
.251c					ESTAShiftDigitIntoMantissa:
.251c	29 0f		and #$0f			and 	#15 						; save digit
.251e	48		pha				pha
.251f	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2521	48		pha				pha
.2522	b5 56		lda $56,x			lda 	NSMantissa2,x
.2524	48		pha				pha
.2525	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2527	48		pha				pha
.2528	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.252a	48		pha				pha
.252b	20 83 26	jsr $2683			jsr 	FloatShiftLeft 				; x 2
.252e	20 83 26	jsr $2683			jsr 	FloatShiftLeft 				; x 4
.2531	18		clc				clc 								; pop mantissa and add
.2532	68		pla				pla
.2533	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2535	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2537	68		pla				pla
.2538	75 4a		adc $4a,x			adc 	NSMantissa1,x
.253a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.253c	68		pla				pla
.253d	75 56		adc $56,x			adc 	NSMantissa2,x
.253f	95 56		sta $56,x			sta 	NSMantissa2,x
.2541	68		pla				pla
.2542	75 62		adc $62,x			adc 	NSMantissa3,x
.2544	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.2546	20 83 26	jsr $2683			jsr 	FloatShiftLeft 				; x 10
.2549	68		pla				pla 								; add digit
.254a	18		clc				clc
.254b	75 3e		adc $3e,x			adc 	NSMantissa0,x
.254d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.254f	90 0a		bcc $255b			bcc 	_ESTASDExit
.2551	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2553	d0 06		bne $255b			bne 	_ESTASDExit
.2555	f6 56		inc $56,x			inc 	NSMantissa2,x
.2557	d0 02		bne $255b			bne 	_ESTASDExit
.2559	f6 62		inc $62,x			inc 	NSMantissa3,x
.255b					_ESTASDExit:
.255b	60		rts				rts
.0737					encodeState:
>0737							.fill 	1
.0738					digitTemp:
>0738							.fill 	1
.0739					decimalCount:
>0739							.fill 	1
.255c					FloatToString:
.255c	da		phx				phx
.255d	5a		phy				phy 								; save code position
.255e	8d 3a 07	sta $073a			sta 	decimalPlaces	 			; save number of DPs.
.2561	9c 3b 07	stz $073b			stz 	dbOffset 					; offset into decimal buffer = start.
.2564	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.2566	10 08		bpl $2570			bpl 	_CNTSNotNegative
.2568	29 7f		and #$7f			and 	#$7F 						; make +ve
.256a	95 32		sta $32,x			sta 	NSStatus,x
.256c	a9 2d		lda #$2d			lda 	#"-"
.256e	80 02		bra $2572			bra 	_CNTMain
.2570					_CNTSNotNegative:
.2570	a9 20		lda #$20			lda 	#" "
.2572					_CNTMain:
.2572	20 d4 25	jsr $25d4			jsr 	WriteDecimalBuffer
.2575	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.2577	f0 0d		beq $2586			beq 	_CNTSNotFloat
.2579	e8		inx				inx 								; round up so we don't get too many 6.999999
.257a	a9 01		lda #$01			lda 	#1
.257c	20 76 26	jsr $2676			jsr 	FloatSetByte
.257f	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2581	95 6e		sta $6e,x			sta 	NSExponent,x
.2583	20 98 20	jsr $2098			jsr 	FloatAdd
.2586					_CNTSNotFloat:
.2586	20 b6 25	jsr $25b6			jsr 	MakePlusTwoString 			; do the integer part.
.2589	20 54 22	jsr $2254			jsr 	FloatFractionalPart 		; get the fractional part
.258c	20 c9 23	jsr $23c9			jsr 	FloatNormalise					; normalise , exit if zero
.258f	f0 22		beq $25b3			beq 	_CNTSExit
.2591	a9 2e		lda #$2e			lda 	#"."
.2593	20 d4 25	jsr $25d4			jsr 	WriteDecimalBuffer 			; write decimal place
.2596					_CNTSDecimal:
.2596	ce 3a 07	dec $073a			dec 	decimalPlaces 				; done all the decimals
.2599	30 18		bmi $25b3			bmi 	_CNTSExit
.259b	e8		inx				inx 								; x 10.0
.259c	a9 0a		lda #$0a			lda 	#10
.259e	20 76 26	jsr $2676			jsr 	FloatSetByte
.25a1	20 34 23	jsr $2334			jsr 	FloatMultiply
.25a4	20 b6 25	jsr $25b6			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25a7	20 54 22	jsr $2254			jsr 	FloatFractionalPart 		; get the fractional part
.25aa	20 c9 23	jsr $23c9			jsr 	FloatNormalise 				; normalise it.
.25ad	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25af	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25b1	b0 e3		bcs $2596			bcs 	_CNTSDecimal 				; keep going.
.25b3					_CNTSExit:
.25b3	7a		ply				ply
.25b4	fa		plx				plx
.25b5	60		rts				rts
.25b6					MakePlusTwoString:
.25b6	da		phx				phx
.25b7	20 57 26	jsr $2657			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25ba	e8		inx				inx 								; access it
.25bb	e8		inx				inx
.25bc	20 af 22	jsr $22af			jsr 	FloatIntegerPart 			; make it an integer
.25bf	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25c1	20 f3 25	jsr $25f3			jsr 	ConvertInt32
.25c4	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25c6					_MPTSCopy:
.25c6	bd 15 07	lda $0715,x			lda 	numberBuffer,x
.25c9	20 d4 25	jsr $25d4			jsr 	WriteDecimalBuffer
.25cc	e8		inx				inx
.25cd	bd 15 07	lda $0715,x			lda 	numberBuffer,x
.25d0	d0 f4		bne $25c6			bne 	_MPTSCopy
.25d2	fa		plx				plx
.25d3	60		rts				rts
.25d4					WriteDecimalBuffer:
.25d4	da		phx				phx
.25d5	ae 3b 07	ldx $073b			ldx 	dbOffset
.25d8	9d 3c 07	sta $073c,x			sta 	decimalBuffer,x
.25db	9e 3d 07	stz $073d,x			stz 	decimalBuffer+1,x
.25de	ee 3b 07	inc $073b			inc 	dbOffset
.25e1	fa		plx				plx
.25e2	60		rts				rts
.073a					decimalPlaces:
>073a							.fill 	1
.073b					dbOffset:
>073b							.fill 	1
.073c					decimalBuffer:
>073c							.fill 	32
.25e3					ConvertInt16:
.25e3	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.25e5	86 4a		stx $4a				stx 	NSMantissa1
.25e7	64 56		stz $56				stz 	NSMantissa2
.25e9	64 62		stz $62				stz 	NSMantissa3
.25eb	64 32		stz $32				stz 	NSStatus 					; positive integer
.25ed	a2 00		ldx #$00			ldx 	#0 							; stack level
.25ef	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25f1	80 00		bra $25f3			bra 	ConvertInt32
.25f3					ConvertInt32:
.25f3	5a		phy				phy
.25f4	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25f6	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25f8	10 08		bpl $2602			bpl 	_CI32NotNeg
.25fa	48		pha				pha
.25fb	a9 2d		lda #$2d			lda 	#'-'
.25fd	99 15 07	sta $0715,y			sta 	numberBuffer,y
.2600	c8		iny				iny
.2601	68		pla				pla
.2602					_CI32NotNeg:
.2602	20 10 26	jsr $2610			jsr 	_CI32DivideConvert 			; recursive conversion
.2605	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2607	99 15 07	sta $0715,y			sta 	numberBuffer,y
.260a	7a		ply				ply
.260b	a2 07		ldx #$07			ldx 	#numberBuffer >> 8 			; return address in XA
.260d	a9 15		lda #$15			lda 	#numberBuffer & $FF
.260f	60		rts				rts
.2610					_CI32DivideConvert:
.2610	e8		inx				inx 								; write to next slot up
.2611	20 76 26	jsr $2676			jsr 	FloatSetByte 		 		; write the base out.
.2614	ca		dex				dex
.2615	20 0a 22	jsr $220a			jsr 	Int32Divide 				; divide
.2618	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.261a	48		pha				pha
.261b	20 f9 21	jsr $21f9			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.261e	20 96 26	jsr $2696			jsr 	FloatIsZero 				; is it zero ?
.2621	f0 05		beq $2628			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2623	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2625	20 10 26	jsr $2610			jsr 	_CI32DivideConvert 			; and recusrively call.
.2628					_CI32NoRecurse:
.2628	68		pla				pla 								; remainder
.2629	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.262b	90 02		bcc $262f			bcc 	_CI32NotHex
.262d	69 26		adc #$26			adc 	#6+32
.262f					_CI32NotHex:
.262f	69 30		adc #$30			adc 	#48
.2631	99 15 07	sta $0715,y			sta 	numberBuffer,y 				; write out and exit
.2634	c8		iny				iny
.2635	60		rts				rts
.2636					FloatNegate:
.2636	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2638	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.263a	95 32		sta $32,x			sta 	NSStatus,x
.263c	60		rts				rts
.263d					FloatNegateMantissa:
.263d	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.263e	a9 00		lda #$00			lda 	#0
.2640	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2642	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2644	a9 00		lda #$00			lda 	#0
.2646	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.2648	95 4a		sta $4a,x			sta 	NSMantissa1,x
.264a	a9 00		lda #$00			lda 	#0
.264c	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.264e	95 56		sta $56,x			sta 	NSMantissa2,x
.2650	a9 00		lda #$00			lda 	#0
.2652	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2654	95 62		sta $62,x			sta 	NSMantissa3,x
.2656	60		rts				rts
.2657					FloatShiftUpTwo:
.2657	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2659	95 40		sta $40,x			sta 	NSMantissa0+2,x
.265b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.265d	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.265f	b5 56		lda $56,x			lda 	NSMantissa2,x
.2661	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2663	b5 62		lda $62,x			lda 	NSMantissa3,x
.2665	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2667	b5 6e		lda $6e,x			lda 	NSExponent,x
.2669	95 70		sta $70,x			sta 	NSExponent+2,x
.266b	b5 32		lda $32,x			lda 	NSStatus,x
.266d	95 34		sta $34,x			sta 	NSStatus+2,x
.266f	60		rts				rts
.2670					FloatSetZeroMantissaOnly:
.2670	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2672	80 08		bra $267c			bra 	FloatZero13
.2674					FloatSetZero:
.2674	a9 00		lda #$00			lda 	#0
.2676					FloatSetByte:
.2676	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2678					FloatSetMantissa:
.2678	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.267a	74 32		stz $32,x			stz 	NSStatus,x
.267c					FloatZero13:
.267c	74 4a		stz $4a,x			stz 	NSMantissa1,x
.267e	74 56		stz $56,x			stz 	NSMantissa2,x
.2680	74 62		stz $62,x			stz 	NSMantissa3,x
.2682	60		rts				rts
.2683					FloatShiftLeft:
.2683	18		clc				clc
.2684					FloatRotateLeft:
.2684	36 3e		rol $3e,x			rol 	NSMantissa0,x
.2686	36 4a		rol $4a,x			rol		NSMantissa1,x
.2688	36 56		rol $56,x			rol		NSMantissa2,x
.268a	36 62		rol $62,x			rol		NSMantissa3,x
.268c	60		rts				rts
.268d					FloatShiftRight:
.268d	56 62		lsr $62,x			lsr 	NSMantissa3,x
.268f	76 56		ror $56,x			ror		NSMantissa2,x
.2691	76 4a		ror $4a,x			ror		NSMantissa1,x
.2693	76 3e		ror $3e,x			ror		NSMantissa0,x
.2695	60		rts				rts
.2696					FloatIsZero:
.2696	b5 62		lda $62,x			lda 	NSMantissa3,x
.2698	15 56		ora $56,x			ora		NSMantissa2,x
.269a	15 4a		ora $4a,x			ora		NSMantissa1,x
.269c	15 3e		ora $3e,x			ora		NSMantissa0,x
.269e	60		rts				rts

;******  Processing input file: testing/testend.asm

.269f					EndProgram:
>269f	01 08 0c 08 0a 00 4e 20				.binary "code/tokenised.dat"
>26a7	b2 20 31 34 00 15 08 14 00 ce 86 20 33 00 32 08
>26b7	3c 00 99 20 c7 28 31 34 37 29 3b 22 48 45 4c 4c
>26c7	4f 20 57 4f 52 4c 44 20 21 22 00 4e 08 46 00 86
>26d7	20 42 58 28 4e 29 3a 86 20 42 59 28 4e 29 3a 86
>26e7	20 42 43 28 4e 29 00 62 08 4b 00 86 20 44 58 28
>26f7	4e 29 3a 86 20 44 59 28 4e 29 00 70 08 50 00 81
>2707	20 42 b2 30 20 a4 20 4e 00 89 08 5a 00 42 58 28
>2717	42 29 b2 b5 28 bb 28 31 29 ac 34 30 29 ac 32 aa
>2727	31 00 a2 08 64 00 42 59 28 42 29 b2 b5 28 bb 28
>2737	31 29 ac 33 30 29 ac 32 35 36 00 b9 08 69 00 42
>2747	43 28 42 29 b2 b5 28 bb 28 31 29 ac 31 34 29 aa
>2757	31 00 cd 08 6a 00 44 58 28 42 29 b2 b5 28 bb 28
>2767	31 29 ac 32 29 00 e3 08 6c 00 8f 20 44 59 28 42
>2777	29 b2 b5 28 bb 28 31 29 ac 32 29 00 ef 08 6d 00
>2787	44 59 28 42 29 b2 31 00 f7 08 6e 00 82 20 42 00
>2797	fd 08 78 00 8f 00 11 09 82 00 81 59 b2 30 a4 32
>27a7	39 3a 81 58 b2 30 a4 33 39 00 27 09 8c 00 51 b2
>27b7	59 ac 32 35 36 aa 58 ac 32 aa 34 35 30 35 36 00
>27c7	3f 09 96 00 ce 84 20 31 2c 51 2c 38 31 3a ce 84
>27d7	31 2c 51 aa 31 2c 30 00 48 09 a0 00 82 58 2c 59
>27e7	00 54 09 c8 00 81 20 42 b2 31 a4 4e 00 71 09 d2
>27f7	00 ce 84 20 31 2c 34 35 30 35 36 aa 42 59 28 42
>2807	29 aa 42 58 28 42 29 2c 30 00 7f 09 e6 00 44 58
>2817	42 b2 44 58 28 42 29 00 90 09 f0 00 8b 44 58 42
>2827	b2 30 a7 8d 31 30 31 30 00 a1 09 fa 00 8b 44 58
>2837	42 b2 31 a7 8d 31 30 34 30 00 af 09 ff 00 44 59
>2847	42 b2 44 59 28 42 29 00 c0 09 04 01 8b 44 59 42
>2857	b2 30 a7 8d 31 30 37 30 00 d1 09 0e 01 8b 44 59
>2867	42 b2 31 a7 8d 31 31 30 30 00 f2 09 18 01 ce 84
>2877	20 31 2c 34 35 30 35 36 aa 42 59 28 42 29 aa 42
>2887	58 28 42 29 2c 42 43 28 42 29 00 f9 09 22 01 82
>2897	42 00 03 0a 2c 01 89 20 32 30 30 00 09 0a e8 03
>28a7	8f 00 17 0a f2 03 42 58 42 b2 42 58 28 42 29 00
>28b7	2c 0a f3 03 8b 42 58 42 b2 31 a7 44 58 28 42 29
>28c7	b2 31 3a 8e 00 3e 0a fc 03 42 58 28 42 29 b2 42
>28d7	58 42 ab 32 3a 8e 00 44 0a 06 04 8f 00 52 0a 10
>28e7	04 42 58 42 b2 42 58 28 42 29 00 72 0a 11 04 8b
>28f7	42 58 42 b2 37 39 a7 20 42 58 28 42 29 b2 37 37
>2907	3a 44 58 28 42 29 b2 30 3a 8e 00 84 0a 1a 04 42
>2917	58 28 42 29 b2 42 58 42 aa 32 3a 8e 00 8a 0a 24
>2927	04 8f 00 98 0a 2e 04 42 59 42 b2 42 59 28 42 29
>2937	00 ad 0a 2f 04 8b 42 59 42 b2 30 a7 44 59 28 42
>2947	29 b2 31 3a 8e 00 c1 0a 38 04 42 59 28 42 29 b2
>2957	42 59 42 ab 32 35 36 3a 8e 00 c7 0a 42 04 8f 00
>2967	d5 0a 4c 04 42 59 42 b2 42 59 28 42 29 00 f8 0a
>2977	4d 04 8b 42 59 42 b2 37 34 32 34 a7 42 59 28 42
>2987	29 b2 37 31 36 38 3a 44 59 28 42 29 b2 30 3a 8e
>2997	00 0c 0b 56 04 42 59 28 42 29 b2 42 59 42 aa 32
>29a7	35 36 3a 8e 00 00 00

;******  End of listing
