
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Sun Oct  8 16:13:00 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.1000					WrapperBoot:
.1000	a2 0a		ldx #$0a			ldx 	#APIDesc & $FF
.1002	a0 10		ldy #$10			ldy 	#APIDesc >> 8
.1004	20 74 11	jsr $1174			jsr 	StartCompiler
.1007	4c ff ff	jmp $ffff			jmp 	$FFFF
.100a					APIDesc:
>100a	0e 10						.word 	TestAPI 					; the testing API.
>100c	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>100d	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing file: testing/api/api.asm

=$a000					PCodeMemory = $A000
.100e					TestAPI:
.100e	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.1010	f0 19		beq $102b			beq 	_TAOpenIn
.1012	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.1014	f0 1d		beq $1033			beq 	_TACloseIn
.1016	c9 02		cmp #$02			cmp 	#BLC_READIN
.1018	f0 1a		beq $1034			beq 	_TARead
.101a	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.101c	f0 19		beq $1037			beq 	_TAResetOut
.101e	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.1020	f0 22		beq $1044			beq 	_TACloseOut
.1022	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.1024	f0 28		beq $104e			beq 	_TAWriteByte
.1026	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.1028	f0 2e		beq $1058			beq 	_TAPrintScreen
>102a	db						.byte 	$DB 						; causes a break in the emulator
.102b					_TAOpenIn:
.102b	a9 be		lda #$be			lda 	#((EndProgram+2) & $FF)
.102d	85 22		sta $22				sta 	0+srcInputPtr
.102f	a9 26		lda #$26			lda 	#((EndProgram+2) >> 8) & $FF
.1031	85 23		sta $23				sta 	1+srcInputPtr
.1033					_TACloseIn:
.1033	60		rts				rts
.1034					_TARead:
.1034	4c 5c 10	jmp $105c			jmp 	ReadNextLine
.1037					_TAResetOut:
.1037	a9 01		lda #$01			lda 	#1
.1039	85 00		sta $00				sta 	0
.103b	a9 00		lda #$00			lda 	#((PCodeMemory) & $FF)
.103d	85 28		sta $28				sta 	0+objPtr
.103f	a9 a0		lda #$a0			lda 	#((PCodeMemory) >> 8) & $FF
.1041	85 29		sta $29				sta 	1+objPtr
.1043	60		rts				rts
.1044					_TACloseOut:
.1044	a9 a0		lda #$a0			lda 	#PCodeMemory >> 8
.1046	a6 28		ldx $28				ldx 	objPtr
.1048	a4 29		ldy $29				ldy 	objPtr+1
.104a	20 81 10	jsr $1081			jsr 	APISaveMemory
.104d	60		rts				rts
.104e					_TAWriteByte:
.104e	8a		txa				txa
.104f	92 28		sta ($28)			sta 	(objPtr)
.1051	e6 28		inc $28				inc 	objPtr
.1053	d0 02		bne $1057			bne 	_HWOWBNoCarry
.1055	e6 29		inc $29				inc 	objPtr+1
.1057					_HWOWBNoCarry:
.1057	60		rts				rts
.1058					_TAPrintScreen:
.1058	8a		txa				txa
.1059	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.0022					srcInputPtr:
>0022							.fill 	2

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/line.asm

.105c					ReadNextLine:
.105c	b2 22		lda ($22)			lda 	(srcInputPtr) 				; reached the end of the program (address link = $0000)
.105e	a0 01		ldy #$01			ldy 	#1
.1060	11 22		ora ($22),y			ora 	(srcInputPtr),y
.1062	d0 02		bne $1066			bne 	_RLAHaveData
.1064	18		clc				clc
.1065	60		rts				rts									; end of file.
.1066					_RLAHaveData:
.1066	a6 22		ldx $22				ldx 	srcInputPtr 				; remember the line start
.1068	a4 23		ldy $23				ldy 	srcInputPtr+1
.106a	5a		phy				phy
.106b	a0 04		ldy #$04			ldy 	#4 							; must be at least four bytes (address/line#)
.106d					_RNLRead:
.106d	b1 22		lda ($22),y			lda 	(srcInputPtr),y 			; find the end of the line.
.106f	c8		iny				iny
.1070	c9 00		cmp #$00			cmp 	#0
.1072	d0 f9		bne $106d			bne 	_RNLRead
.1074	98		tya				tya 								; advance src input pointer to next.
.1075	18		clc				clc
.1076	65 22		adc $22				adc 	srcInputPtr
.1078	85 22		sta $22				sta 	srcInputPtr
.107a	90 02		bcc $107e			bcc 	_RNLNoCarry
.107c	e6 23		inc $23				inc 	srcInputPtr+1
.107e					_RNLNoCarry:
.107e	7a		ply				ply 								; address of line now in YX.
.107f	38		sec				sec
.1080	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/save.asm

.1081					APISaveMemory:
.1081	da		phx				phx
.1082	5a		phy				phy
.1083	48		pha				pha
.1084	a9 00		lda #$00			lda 	#0 							; set LFS
.1086	a2 08		ldx #$08			ldx 	#8
.1088	a0 00		ldy #$00			ldy 	#0
.108a	20 ba ff	jsr $ffba			jsr 	$FFBA
.108d	a9 08		lda #$08			lda 	#8 							; set file name
.108f	a2 a3		ldx #$a3			ldx 	#SaveName & $FF
.1091	a0 10		ldy #$10			ldy 	#SaveName >> 8
.1093	20 bd ff	jsr $ffbd			jsr 	$FFBD
.1096	68		pla				pla 								; set up the start address.
.1097	85 2b		sta $2b				sta 	zTemp0+1
.1099	64 2a		stz $2a				stz 	zTemp0
.109b	a9 2a		lda #$2a			lda 	#zTemp0 					; from index.
.109d	7a		ply				ply 								; end in YX
.109e	fa		plx				plx
.109f	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.10a2	60		rts				rts
.10a3					SaveName:
>10a3	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Return to file: testing/testing.asm


;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.0024					srcPtr:
>0024							.fill 	2
.0400					currentLineNumber:
>0400							.fill 	2
.10ab					InlineNonDecimal:
.10ab	a2 02		ldx #$02			ldx 	#2 							; get size in X
.10ad	c9 25		cmp #$25			cmp 	#"%"
.10af	f0 02		beq $10b3			beq 	_INDBinary
.10b1	a2 10		ldx #$10			ldx 	#16
.10b3					_INDBinary:
.10b3	85 2c		sta $2c				sta 	zTemp1 						; size => zTemp1
.10b5	64 2d		stz $2d				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.10b7	64 2a		stz $2a				stz 	zTemp0 						; zero result
.10b9	64 2b		stz $2b				stz 	zTemp0+1
.10bb					_INDLoop:
.10bb	20 50 1a	jsr $1a50			jsr 	LookNext 					; check next character
.10be	20 8c 1a	jsr $1a8c			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.10c1	90 1f		bcc $10e2			bcc		_INDDone 					; didn't convert
.10c3	c5 2c		cmp $2c				cmp 	zTemp1 						; size too large ?
.10c5	b0 1b		bcs $10e2			bcs 	_INDDone
.10c7	20 f1 10	jsr $10f1			jsr 	_INDShift 					; x 2 or x 16
.10ca	e0 02		cpx #$02			cpx 	#2
.10cc	f0 09		beq $10d7			beq 	_INDNotHex
.10ce	20 f1 10	jsr $10f1			jsr 	_INDShift
.10d1	20 f1 10	jsr $10f1			jsr 	_INDShift
.10d4	20 f1 10	jsr $10f1			jsr 	_INDShift
.10d7					_INDNotHex:
.10d7	05 2a		ora $2a				ora 	zTemp0 						; or digit into result
.10d9	85 2a		sta $2a				sta 	zTemp0
.10db	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume
.10de	e6 2d		inc $2d				inc 	zTemp1+1 					; bump count
.10e0	80 d9		bra $10bb			bra 	_INDLoop
.10e2					_INDDone:
.10e2	a5 2d		lda $2d				lda 	zTemp1+1 					; done at least 1 ?
.10e4	f0 08		beq $10ee			beq 	_INDError
.10e6	a4 2b		ldy $2b				ldy 	zTemp0+1 					; push constant
.10e8	a5 2a		lda $2a				lda 	zTemp0
.10ea	20 0b 12	jsr $120b			jsr 	PushIntegerYA
.10ed	60		rts				rts
.10ee					_INDError:
.10ee	4c 4b 1f	jmp $1f4b		jmp	ErrorV_syntax
.10f1					_INDShift:
.10f1	06 2a		asl $2a				asl 	zTemp0
.10f3	26 2b		rol $2b				rol 	zTemp0+1
.10f5	60		rts				rts
.10f6					GetLineNumber:
.10f6	ac 01 04	ldy $0401			ldy 	currentLineNumber+1
.10f9	ad 00 04	lda $0400			lda 	currentLineNumber
.10fc	60		rts				rts
.10fd					WriteCodeByte:
.10fd	48		pha				pha 								; save on stack
.10fe	da		phx				phx
.10ff	5a		phy				phy
.1100	aa		tax				tax
.1101	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.1103	20 08 12	jsr $1208			jsr 	CallAPIHandler
.1106	7a		ply				ply 								; restore from stack
.1107	fa		plx				plx
.1108	68		pla				pla
.1109	60		rts				rts
.110a					PrintCharacter
.110a	48		pha				pha
.110b	da		phx				phx
.110c	5a		phy				phy
.110d	aa		tax				tax
.110e	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.1110	20 08 12	jsr $1208			jsr 	CallAPIHandler
.1113	7a		ply				ply
.1114	fa		plx				plx
.1115	68		pla				pla
.1116	60		rts				rts
.1117					ProcessNewLine:
.1117	86 2a		stx $2a				stx 	zTemp0 						; save address in zTemp0
.1119	84 2b		sty $2b				sty 	zTemp0+1
.111b	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.111c	8a		txa				txa
.111d	69 04		adc #$04			adc 	#4
.111f	85 24		sta $24				sta 	srcPtr
.1121	98		tya				tya
.1122	69 00		adc #$00			adc 	#0
.1124	85 25		sta $25				sta 	srcPtr+1
.1126	a0 02		ldy #$02			ldy 	#2							; read and save line number
.1128	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.112a	8d 00 04	sta $0400			sta 	currentLineNumber
.112d	c8		iny				iny
.112e	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1130	8d 01 04	sta $0401			sta 	currentLineNumber+1
.1133	60		rts				rts
.1134					BufferClear:
.1134	9c 02 04	stz $0402			stz 	bufferSize
.1137	60		rts				rts
.1138					BufferWrite:
.1138	da		phx				phx
.1139	ae 02 04	ldx $0402			ldx 	bufferSize
.113c	9d 03 04	sta $0403,x			sta 	dataBuffer,x
.113f	ee 02 04	inc $0402			inc 	bufferSize
.1142	fa		plx				plx
.1143	60		rts				rts
.1144					BufferOutput:
.1144	ad 02 04	lda $0402			lda 	bufferSize
.1147	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.114a	a2 00		ldx #$00			ldx 	#0
.114c					_BOLoop:
.114c	ec 02 04	cpx $0402			cpx 	bufferSize
.114f	f0 09		beq $115a			beq 	_BOExit
.1151	bd 03 04	lda $0403,x			lda 	dataBuffer,x
.1154	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1157	e8		inx				inx
.1158	80 f2		bra $114c			bra 	_BOLoop
.115a					_BOExit:
.115a	60		rts				rts
.0402					bufferSize:
>0402							.fill 	1
.0403					dataBuffer:
>0403							.fill 	256
.115b					CheckNextComma:
.115b	a9 2c		lda #$2c			lda	 	#","
.115d	80 06		bra $1165			bra 	CheckNextA
.115f					CheckNextRParen:
.115f	a9 29		lda #$29			lda	 	#")"
.1161	80 02		bra $1165			bra 	CheckNextA
.1163					CheckNextLParen:
.1163	a9 28		lda #$28			lda 	#"("
.1165					CheckNextA:
.1165	8d 03 05	sta $0503			sta 	checkCharacter 				; save test character
.1168					_CNALoop:
.1168	20 6c 1a	jsr $1a6c			jsr 	GetNextNonSpace 			; get next skipping spaces.
.116b	cd 03 05	cmp $0503			cmp 	checkCharacter 				; matches ?
.116e	f0 03		beq $1173			beq 	_CNAExit
.1170	4c 4b 1f	jmp $1f4b		jmp	ErrorV_syntax
.1173					_CNAExit:
.1173	60		rts				rts
.0503					checkCharacter:
>0503							.fill 	1
.1174					StartCompiler:
.1174	86 2a		stx $2a				stx 	zTemp0 						; access API
.1176	84 2b		sty $2b				sty 	zTemp0+1
.1178	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.117a	b2 2a		lda ($2a)			lda 	(zTemp0)
.117c	8d 05 05	sta $0505			sta 	APIVector
.117f	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1181	8d 06 05	sta $0506			sta 	APIVector+1
.1184	c8		iny				iny 								; copy data area range.
.1185	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1187	8d 07 05	sta $0507			sta 	compilerStartHigh
.118a	c8		iny				iny
.118b	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.118d	8d 08 05	sta $0508			sta 	compilerEndHigh
.1190	ba		tsx				tsx 								; save stack pointer
.1191	8e 04 05	stx $0504			stx 	compilerSP
.1194	20 f0 1d	jsr $1df0			jsr 	STRReset 					; reset storage (line#, variable)
.1197	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.1199	20 08 12	jsr $1208			jsr 	CallAPIHandler
.119c	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.119e	20 08 12	jsr $1208			jsr 	CallAPIHandler
.11a1	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.11a3	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.11a6	a9 00		lda #$00			lda 	#0
.11a8	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.11ab	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.11ae					MainCompileLoop:
.11ae	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.11b0	20 08 12	jsr $1208			jsr 	CallAPIHandler
.11b3	90 31		bcc $11e6			bcc 	SaveCodeAndExit 			; end of source.
.11b5	20 17 11	jsr $1117			jsr 	ProcessNewLine 				; set up pointer and line number.
.11b8	20 f6 10	jsr $10f6			jsr 	GetLineNumber 				; get line #
.11bb	20 da 1b	jsr $1bda			jsr 	STRMarkLine 				; remember the code position and number of this line.
.11be	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.11c0	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.11c3					_MCLSameLine:
.11c3	20 6c 1a	jsr $1a6c			jsr 	GetNextNonSpace 			; get the first character.
.11c6	f0 e6		beq $11ae			beq 	MainCompileLoop 			; end of line, get next line.
.11c8	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.11ca	f0 f7		beq $11c3			beq 	_MCLSameLine
.11cc	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.11ce	10 0c		bpl $11dc			bpl 	_MCLCheckAssignment
.11d0	a2 2a		ldx #$2a			ldx 	#CommandTables & $FF 		; do command tables.
.11d2	a0 16		ldy #$16			ldy 	#CommandTables >> 8
.11d4	20 f2 18	jsr $18f2			jsr 	GeneratorProcess
.11d7	b0 ea		bcs $11c3			bcs 	_MCLSameLine 				; keep trying to compile the line.
.11d9					_MCLSyntax:
.11d9	4c 4b 1f	jmp $1f4b		jmp	ErrorV_syntax
.11dc					_MCLCheckAssignment:
.11dc	20 82 1a	jsr $1a82			jsr 	CharIsAlpha 				; if not alpha then syntax error
.11df	90 f8		bcc $11d9			bcc 	_MCLSyntax
.11e1	20 a8 1b	jsr $1ba8			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.11e4	80 dd		bra $11c3			bra		_MCLSameLine 				; loop back.
.11e6					SaveCodeAndExit:
.11e6	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.11e8	20 08 12	jsr $1208			jsr 	CallAPIHandler
.11eb	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.11ed	a8		tay				tay
.11ee	20 da 1b	jsr $1bda			jsr 	STRMarkLine
.11f1	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.11f3	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.11f6	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.11f8	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.11fb	20 22 15	jsr $1522			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.11fe	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.1200	20 08 12	jsr $1208			jsr 	CallAPIHandler
.1203					ExitCompiler:
.1203	ae 04 05	ldx $0504			ldx 	compilerSP 					; reload SP and exit.
.1206	9a		txs				txs
.1207	60		rts				rts
.1208					CallAPIHandler:
.1208	6c 05 05	jmp ($0505)			jmp 	(APIVector)
.0504					compilerSP:
>0504							.fill 	1
.0505					APIVector:
>0505							.fill 	2
.0507					compilerStartHigh:
>0507							.fill 	1
.0508					compilerEndHigh:
>0508							.fill 	1
.120b					PushIntegerYA:
.120b	c0 00		cpy #$00			cpy 	#0 							; 0-255
.120d	f0 0f		beq $121e			beq 	PushIntegerA
.120f	48		pha				pha
.1210	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.1212	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1215	68		pla				pla 								; then LSB
.1216	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1219	98		tya				tya 								; then MSB
.121a	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.121d	60		rts				rts
.121e					PushIntegerA:
.121e	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.1220	90 07		bcc $1229			bcc 	_PIWriteA
.1222	48		pha				pha
.1223	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.1225	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1228	68		pla				pla
.1229					_PIWriteA:
.1229	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.122c	60		rts				rts
.122d					PushFloat:
.122d	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.122f	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1232	b5 6c		lda $6c,x			lda 	NSExponent,x 				; and the data
.1234	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1237	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1239	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.123c	b5 48		lda $48,x			lda 	NSMantissa1,x
.123e	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1241	b5 54		lda $54,x			lda 	NSMantissa2,x
.1243	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1246	b5 30		lda $30,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.1248	29 80		and #$80			and 	#$80
.124a	15 60		ora $60,x			ora 	NSMantissa3,x
.124c	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.124f	60		rts				rts
.1250					CreateVariableRecord:
.1250	48		pha				pha
.1251	ad 13 05	lda $0513			lda 	freeVariableMemory 		; push current free address on stack.
.1254	48		pha				pha
.1255	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1258	48		pha				pha
.1259	ad 11 05	lda $0511			lda 	variableListEnd  		; copy end of list to zTemp0
.125c	85 2a		sta $2a				sta 	zTemp0
.125e	ad 12 05	lda $0512			lda 	variableListEnd+1
.1261	85 2b		sta $2b				sta 	zTemp0+1
.1263	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.1265	92 2a		sta ($2a)			sta 	(zTemp0)
.1267	98		tya				tya
.1268	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.126a	91 2a		sta ($2a),y			sta 	(zTemp0),y
.126c	88		dey				dey
.126d	8a		txa				txa
.126e	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1270	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.1272	ad 13 05	lda $0513			lda 	freeVariableMemory
.1275	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1277	c8		iny				iny
.1278	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.127b	91 2a		sta ($2a),y			sta 	(zTemp0),y
.127d	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.127f	a9 00		lda #$00			lda 	#0
.1281	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1283	18		clc				clc
.1284	b2 2a		lda ($2a)			lda 	(zTemp0) 				; add offset to variableListEnd
.1286	6d 11 05	adc $0511			adc  	variableListEnd
.1289	8d 11 05	sta $0511			sta 	variableListEnd
.128c	90 03		bcc $1291			bcc 	_CVNoCarry2
.128e	ee 12 05	inc $0512			inc 	variableListEnd+1
.1291					_CVNoCarry2:
.1291	7a		ply				ply
.1292	fa		plx				plx
.1293	68		pla				pla
.1294	60		rts				rts
.1295					SetVariableRecordToCodePosition:
.1295	48		pha				pha
.1296	5a		phy				phy
.1297	a0 03		ldy #$03			ldy 	#3
.1299	a5 29		lda $29				lda 	objPtr+1
.129b	91 2a		sta ($2a),y			sta 	(zTemp0),y
.129d	c8		iny				iny
.129e	a5 28		lda $28				lda 	objPtr
.12a0	91 2a		sta ($2a),y			sta 	(zTemp0),y
.12a2	7a		ply				ply
.12a3	68		pla				pla
.12a4	60		rts				rts
.12a5					AllocateBytesForType:
.12a5	48		pha				pha
.12a6	da		phx				phx
.12a7	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.12a9	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.12ab	c9 00		cmp #$00			cmp 	#NSSIFloat
.12ad	d0 02		bne $12b1			bne 	_CVNotFloat
.12af	a2 06		ldx #$06			ldx 	#6
.12b1					_CVNotFloat:
.12b1	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.12b2	18		clc				clc
.12b3	6d 13 05	adc $0513			adc 	freeVariableMemory
.12b6	8d 13 05	sta $0513			sta 	freeVariableMemory
.12b9	90 03		bcc $12be			bcc 	_CVNoCarry1
.12bb	ee 14 05	inc $0514			inc 	freeVariableMemory+1
.12be					_CVNoCarry1:
.12be	fa		plx				plx
.12bf	68		pla				pla
.12c0	60		rts				rts
.12c1					CommandDATA:
.12c1	20 34 11	jsr $1134			jsr 	BufferClear 				; copy it to the buffer
.12c4	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace
.12c7					_CTDataLoop:
.12c7	20 50 1a	jsr $1a50			jsr 	LookNext 					; reached EOL
.12ca	f0 08		beq $12d4			beq 	_CTDataDone
.12cc	20 38 11	jsr $1138			jsr 	BufferWrite 				; write and consume
.12cf	20 61 1a	jsr $1a61			jsr 	GetNext
.12d2	80 f3		bra $12c7			bra 	_CTDataLoop
.12d4					_CTDataDone:
.12d4	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.12d6	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.12d9	20 44 11	jsr $1144			jsr 	BufferOutput
.12dc	60		rts				rts
.12dd					CommandDEF:
.12dd	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.12df	20 1e 12	jsr $121e			jsr 	PushIntegerA
.12e2	20 71 1b	jsr $1b71			jsr 	CompileGotoEOL 				; compile skip over DEF
.12e5	a9 a5		lda #$a5			lda 	#C64_FN
.12e7	20 65 11	jsr $1165			jsr 	CheckNextA
.12ea	20 6c 1a	jsr $1a6c			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.12ed	20 d1 1a	jsr $1ad1			jsr 	ExtractVariableName
.12f0	8a		txa				txa
.12f1	10 51		bpl $1344			bpl 	_CDError
.12f3	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.12f4	29 7f		and #$7f			and 	#$7F
.12f6	aa		tax				tax
.12f7	98		tya				tya
.12f8	09 80		ora #$80			ora 	#$80
.12fa	a8		tay				tay
.12fb	20 c6 14	jsr $14c6			jsr 	FindVariable				; does it already exist ?
.12fe	b0 44		bcs $1344			bcs 	_CDError 					; if so, that's an error.
.1300	20 50 12	jsr $1250			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.1303	20 95 12	jsr $1295			jsr 	SetVariableRecordToCodePosition
.1306	20 6c 1a	jsr $1a6c			jsr 	GetNextNonSpace
.1309	20 ad 1d	jsr $1dad			jsr 	GetReferenceTerm 			; get var ref, not array
.130c	c9 00		cmp #$00			cmp 	#0
.130e	30 34		bmi $1344			bmi 	_CDError
.1310	8d 09 05	sta $0509			sta 	defType 					; save type
.1313	8e 0a 05	stx $050a			stx 	defVariable 				; save var ref
.1316	8c 0b 05	sty $050b			sty 	defVariable+1
.1319	29 40		and #$40			and 	#NSSString 					; only numbers.
.131b	d0 27		bne $1344			bne 	_CDError
.131d	20 5f 11	jsr $115f			jsr 	CheckNextRParen 			; check )
.1320	a9 b2		lda #$b2			lda 	#C64_EQUAL
.1322	20 65 11	jsr $1165			jsr 	CheckNextA 					; check =
.1325	18		clc				clc 								; if this is DEF FNxx(A), read A
.1326	20 47 13	jsr $1347			jsr 	CDReadWriteVariable
.1329	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.132b	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.132e	38		sec				sec
.132f	20 47 13	jsr $1347			jsr 	CDReadWriteVariable 		; A is now updated
.1332	20 0c 14	jsr $140c			jsr 	CompileExpressionAt0 		; the actual body of the function.
.1335	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1337	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.133a	38		sec				sec
.133b	20 47 13	jsr $1347			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.133e	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.1340	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1343	60		rts				rts
.1344					_CDError:
.1344	4c 4b 1f	jmp $1f4b		jmp	ErrorV_syntax
.1347					CDReadWriteVariable:
.1347	ac 0b 05	ldy $050b			ldy 	defVariable+1 				; set up YX
.134a	ae 0a 05	ldx $050a			ldx 	defVariable
.134d	ad 09 05	lda $0509			lda 	defType
.1350	20 5f 1d	jsr $1d5f			jsr 	GetSetVariable
.1353	60		rts				rts
.0509					defType:
>0509							.fill 	1
.050a					defVariable:
>050a							.fill 	2
.1354					CommandDIM:
.1354	20 6c 1a	jsr $1a6c			jsr 	GetNextNonSpace 			; get the first non space character
.1357	20 d1 1a	jsr $1ad1			jsr 	ExtractVariableName 		; variable name to XY
.135a	da		phx				phx 								; save name with type bits.
.135b	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.135d	10 37		bpl $1396			bpl 	_CDError
.135f	20 c6 14	jsr $14c6			jsr 	FindVariable	 			; see if already exist
.1362	b0 35		bcs $1399			bcs 	_CDRedefine 				; it still exists.
.1364	20 50 12	jsr $1250			jsr 	CreateVariableRecord 		; create the basic variable
.1367	20 a5 12	jsr $12a5			jsr 	AllocateBytesForType 		; allocate memory for it
.136a	68		pla				pla 								; restore type bits
.136b	5a		phy				phy 								; save the address of the basic storage
.136c	da		phx				phx
.136d	48		pha				pha
.136e	20 9c 13	jsr $139c			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.1371	68		pla				pla
.1372	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.1374	20 1e 12	jsr $121e			jsr 	PushIntegerA 				; push that type data out.
.1377	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.1379	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.137c	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.137e	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1381	fa		plx				plx 								; restore address
.1382	7a		ply				ply
.1383	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1385	38		sec				sec
.1386	20 5f 1d	jsr $1d5f			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.1389	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; , follows ?
.138c	c9 2c		cmp #$2c			cmp 	#","
.138e	d0 05		bne $1395			bne 	_CDExit
.1390	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume comma
.1393	80 bf		bra $1354			bra 	CommandDIM 					; do another DIM
.1395					_CDExit:
.1395	60		rts				rts
.1396					_CDError:
.1396	4c 4b 1f	jmp $1f4b		jmp	ErrorV_syntax
.1399					_CDRedefine:
.1399	4c 13 20	jmp $2013		jmp	ErrorV_redefine
.139c					OutputIndexGroup:
.139c	9c 0c 05	stz $050c			stz 	IndexCount 					; count of number of indices.
.139f					_OIGNext:
.139f	20 0c 14	jsr $140c			jsr 	CompileExpressionAt0 		; get a dimension
.13a2	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.13a4	c9 00		cmp #$00			cmp 	#NSSIFloat
.13a6	d0 19		bne $13c1			bne 	_OIGType
.13a8	ee 0c 05	inc $050c			inc 	IndexCount 					; bump the counter.
.13ab	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; does a , follow ?
.13ae	c9 2c		cmp #$2c			cmp 	#","
.13b0	d0 05		bne $13b7			bne 	_OIGCheckEnd
.13b2	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume comma
.13b5	80 e8		bra $139f			bra 	_OIGNext 					; get next dimension
.13b7					_OIGCheckEnd:
.13b7	20 5f 11	jsr $115f			jsr 	CheckNextRParen 			; check and consume )
.13ba	ad 0c 05	lda $050c			lda 	IndexCount
.13bd	20 1e 12	jsr $121e			jsr 	PushIntegerA 				; compile the dimension count.
.13c0	60		rts				rts
.13c1					_OIGType:
.13c1	4c 5b 1f	jmp $1f5b		jmp	ErrorV_type
.050c					IndexCount:
>050c							.fill 	1
.13c4					ErrorHandler:
.13c4	68		pla				pla
.13c5	7a		ply				ply
.13c6	85 2a		sta $2a				sta 	zTemp0
.13c8	84 2b		sty $2b				sty 	zTemp0+1
.13ca	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.13cc	a0 01		ldy #$01			ldy 	#1
.13ce					_EHDisplayMsg:
.13ce	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.13d0	20 0a 11	jsr $110a			jsr 	PrintCharacter
.13d3	c8		iny				iny
.13d4	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.13d6	d0 f6		bne $13ce			bne 	_EHDisplayMsg
.13d8	a9 20		lda #$20			lda 	#32
.13da	20 0a 11	jsr $110a			jsr 	PrintCharacter
.13dd	a9 40		lda #$40			lda 	#64
.13df	20 0a 11	jsr $110a			jsr 	PrintCharacter
.13e2	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.13e4	20 93 26	jsr $2693			jsr 	FloatSetByte
.13e7	20 f6 10	jsr $10f6			jsr 	GetLineNumber
.13ea	95 3c		sta $3c,x			sta 	NSMantissa0,x
.13ec	98		tya				tya
.13ed	95 48		sta $48,x			sta 	NSMantissa1,x
.13ef	20 79 25	jsr $2579			jsr 	FloatToString
.13f2	a0 00		ldy #$00			ldy 	#0 							; display that string.
.13f4	a2 00		ldx #$00			ldx 	#0
.13f6					_EHDisplayLine:
.13f6	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13f9	20 0a 11	jsr $110a			jsr 	PrintCharacter
.13fc	c8		iny				iny
.13fd	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.1400	d0 f4		bne $13f6			bne 	_EHDisplayLine
.1402	a9 0d		lda #$0d			lda 	#13
.1404	20 0a 11	jsr $110a			jsr 	PrintCharacter
.1407	80 fe		bra $1407	_EHHalt:bra 	_EHHalt
.1409	4c 03 12	jmp $1203			jmp 	ExitCompiler
.140c					CompileExpressionAt0:
.140c	a9 00		lda #$00			lda 	#0
.140e					CompileExpressionAtA:
.140e	48		pha				pha  								; save level
.140f	20 18 1e	jsr $1e18			jsr 	CompileTerm 				; compile a term.
.1412	fa		plx				plx 								; get level back into X
.1413					_ECALoop:
.1413	48		pha				pha 								; save type on stack.
.1414	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; get the next character
.1417	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.1419	90 04		bcc $141f			bcc 	_ECAExit
.141b	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.141d	90 02		bcc $1421			bcc 	_ECAHaveToken
.141f					_ECAExit:
.141f	68		pla				pla 								; throw type off stack
.1420	60		rts				rts
.1421					_ECAHaveToken:
.1421	86 2a		stx $2a				stx 	zTemp0 						; save current precedence in zTemp0
.1423	aa		tax				tax 								; X contains the operator token
.1424	bd 0f 14	lda $140f,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.1427	c5 2a		cmp $2a				cmp 	zTemp0 						; if < then exit
.1429	90 f4		bcc $141f			bcc 	_ECAExit
.142b	85 2b		sta $2b				sta 	zTemp0+1 					; save the precedence of the operator.
.142d	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume the token.
.1430	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.1432	f0 11		beq $1445			beq 	_ECAGreaterCheck
.1434	e0 b3		cpx #$b3			cpx 	#C64_LESS
.1436	d0 1a		bne $1452			bne 	_ECAHaveFullToken
.1438	20 50 1a	jsr $1a50			jsr 	LookNext 					; checks for < (<= or <>)
.143b	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.143d	f0 0e		beq $144d			beq	 	_ECAToNotEqual
.143f	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.1441	d0 0f		bne $1452			bne 	_ECAHaveFullToken
.1443	80 07		bra $144c			bra 	_ECAAddEqual
.1445					_ECAGreaterCheck:
.1445	20 50 1a	jsr $1a50			jsr 	LookNext
.1448	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.144a	d0 06		bne $1452			bne 	_ECAHaveFullToken
.144c					_ECAAddEqual:
.144c	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.144d					_ECAToNotEqual:
.144d	e8		inx				inx
.144e	e8		inx				inx
.144f	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume the = or > in >= <= <>
.1452					_ECAHaveFullToken:
.1452	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.1454	d0 0a		bne $1460			bne 	_ECANotConcat
.1456	68		pla				pla 								; get type back
.1457	48		pha				pha
.1458	29 40		and #$40			and 	#NSSTypeMask
.145a	c9 40		cmp #$40			cmp 	#NSSString
.145c	d0 02		bne $1460			bne 	_ECANotConcat
.145e	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1460					_ECANotConcat:
.1460	da		phx				phx 								; save operator on the stack
.1461	a6 2a		ldx $2a				ldx 	zTemp0 						; push current precedence on the stack
.1463	da		phx				phx
.1464	a5 2b		lda $2b				lda 	zTemp0+1 					; get precedence of operator
.1466	1a		inc a				inc 	a
.1467	20 0e 14	jsr $140e			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.146a	85 2a		sta $2a				sta 	zTemp0 						; save type in zTemp0
.146c	fa		plx				plx 								; restore current precedence in X
.146d	68		pla				pla 								; restore operator
.146e	85 2b		sta $2b				sta 	zTemp0+1 					; save it in zTemp0+1.
.1470	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.1472	90 17		bcc $148b			bcc 	_ECANotCompare
.1474	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.1476	b0 13		bcs $148b			bcs 	_ECANotCompare
.1478	7a		ply				ply 								; get type into Y
.1479	5a		phy				phy
.147a	48		pha				pha 								; save operator
.147b	98		tya				tya 								; get type
.147c	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.147e	29 40		and #$40			and 	#NSSTypeMask
.1480	c9 40		cmp #$40			cmp 	#NSSString
.1482	f0 02		beq $1486			beq 	_ECANotString
.1484	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.1486					_ECANotString:
.1486	98		tya				tya									; output token Y
.1487	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.148a	68		pla				pla 								; restore operator.
.148b					_ECANotCompare:
.148b	18		clc				clc 								; convert to P-Code and compile.
.148c	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.148e	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1491	68		pla				pla 								; type of current result
.1492	45 2a		eor $2a				eor 	zTemp0 						; check compatible with r-expr type
.1494	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.1496	d0 19		bne $14b1			bne		_ECAType
.1498	a5 2a		lda $2a				lda 	zTemp0 						; get type back
.149a	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.149c	d0 18		bne $14b6			bne 	_ECAGoLoop
.149e	a5 2b		lda $2b				lda 	zTemp0+1 					; check operator is + or comparator
.14a0	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.14a2	f0 10		beq $14b4			beq 	_ECAOkayString 				; (this is post conversion)
.14a4	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.14a6	90 09		bcc $14b1			bcc 	_ECAType
.14a8	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.14aa	b0 05		bcs $14b1			bcs 	_ECAType
.14ac	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.14ae	4c 13 14	jmp $1413			jmp 	_ECALoop
.14b1					_ECAType:
.14b1	4c 5b 1f	jmp $1f5b		jmp	ErrorV_type
.14b4					_ECAOkayString:
.14b4	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.14b6					_ECAGoLoop:
.14b6	4c 13 14	jmp $1413			jmp 	_ECALoop
.14b9					PrecedenceTable:
>14b9	03						.byte 	3 					; '+'
>14ba	03						.byte 	3 					; '-'
>14bb	04						.byte 	4 					; '*'
>14bc	04						.byte 	4 					; '/'
>14bd	05						.byte 	5 					; '^'
>14be	01						.byte 	1 					; 'and'
>14bf	00						.byte 	0 					; 'or'
>14c0	02						.byte 	2 					; '>'
>14c1	02						.byte 	2 					; '='
>14c2	02						.byte 	2 					; '<'
>14c3	02						.byte 	2 					; '>='
>14c4	02						.byte 	2 					; '<='
>14c5	02						.byte 	2 					; '<>'
.14c6					FindVariable:
.14c6	86 2c		stx $2c				stx 	zTemp1 						; save name.
.14c8	84 2d		sty $2d				sty 	zTemp1+1
.14ca					_IVCheckSpecial:
.14ca	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.14cc	d0 18		bne $14e6			bne 	_IVStandard
.14ce	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.14d0	f0 0c		beq $14de			beq 	_IVTIFloat
.14d2	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.14d4	d0 10		bne $14e6			bne 	_IVStandard
.14d6	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.14d8	a2 01		ldx #$01			ldx 	#$01
.14da	a9 40		lda #$40			lda 	#NSSString
.14dc	38		sec				sec
.14dd	60		rts				rts
.14de					_IVTIFloat:
.14de	a0 80		ldy #$80			ldy 	#$80
.14e0	a2 00		ldx #$00			ldx 	#$00
.14e2	a9 00		lda #$00			lda 	#0
.14e4	38		sec				sec
.14e5	60		rts				rts
.14e6					_IVStandard:
.14e6	ad 07 05	lda $0507			lda 	compilerStartHigh			; start scanning from here.
.14e9	85 2b		sta $2b				sta 	zTemp0+1
.14eb	64 2a		stz $2a				stz 	zTemp0
.14ed					_IVCheckLoop:
.14ed	b2 2a		lda ($2a)			lda 	(zTemp0) 					; finished ?
.14ef	f0 2b		beq $151c			beq  	_IVNotFound 				; if so, return with CC.
.14f1	a0 01		ldy #$01			ldy 	#1 							; match ?
.14f3	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14f5	c5 2c		cmp $2c				cmp 	zTemp1
.14f7	d0 07		bne $1500			bne	 	_IVNext
.14f9	c8		iny				iny
.14fa	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14fc	c5 2d		cmp $2d				cmp 	zTemp1+1
.14fe	f0 0d		beq $150d			beq 	_IVFound
.1500					_IVNext:
.1500	18		clc				clc
.1501	a5 2a		lda $2a				lda 	zTemp0
.1503	72 2a		adc ($2a)			adc 	(zTemp0)
.1505	85 2a		sta $2a				sta 	zTemp0
.1507	90 e4		bcc $14ed			bcc 	_IVCheckLoop
.1509	e6 2b		inc $2b				inc 	zTemp0+1
.150b	80 e0		bra $14ed			bra 	_IVCheckLoop
.150d					_IVFound:
.150d	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.150f	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1511	aa		tax				tax
.1512	c8		iny				iny
.1513	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1515	48		pha				pha
.1516	c8		iny				iny
.1517	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1519	7a		ply				ply
.151a	38		sec				sec
.151b	60		rts				rts
.151c					_IVNotFound:
.151c	a6 2c		ldx $2c				ldx 	zTemp1 						; get variable name back
.151e	a4 2d		ldy $2d				ldy 	zTemp1+1
.1520	18		clc				clc
.1521	60		rts				rts
.1522					FixBranches:
.1522	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.1524	20 08 12	jsr $1208			jsr 	CallAPIHandler
.1527					_FBLoop:
.1527	b2 28		lda ($28)			lda 	(objPtr) 					; get the next one.
.1529	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.152b	f0 16		beq $1543			beq 	_FBFixGotoGosub
.152d	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.152f	f0 12		beq $1543			beq 	_FBFixGotoGosub
.1531	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.1533	f0 0e		beq $1543			beq 	_FBFixGotoGosub
.1535	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1537	f0 0a		beq $1543			beq 	_FBFixGotoGosub
.1539	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.153b	f0 3b		beq $1578			beq 	_FBFixVarSpace
.153d					_FBNext:
.153d	20 60 20	jsr $2060			jsr 	MoveObjectForward 			; move forward in object code.
.1540	90 e5		bcc $1527			bcc 	_FBLoop 					; not finished
.1542					_FBExit:
.1542	60		rts				rts
.1543					_FBFixGotoGosub:
.1543	a0 01		ldy #$01			ldy 	#1							; line number in YA
.1545	b1 28		lda ($28),y			lda 	(objPtr),y
.1547	48		pha				pha
.1548	c8		iny				iny
.1549	b1 28		lda ($28),y			lda 	(objPtr),y
.154b	a8		tay				tay
.154c	68		pla				pla
.154d	20 03 1c	jsr $1c03			jsr 	STRFindLine			 		; find where it is YA
.1550	90 08		bcc $155a			bcc 	_FBFFound 					; not found, so must be >
.1552	48		pha				pha
.1553	b2 28		lda ($28)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.1555	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1557	d0 0f		bne $1568			bne 	_FBFFail
.1559	68		pla				pla
.155a					_FBFFound:
.155a	20 53 1c	jsr $1c53			jsr 	STRMakeOffset 				; make it an offset from X:YA
.155d	5a		phy				phy	 								; patch the GOTO/GOSUB
.155e	a0 01		ldy #$01			ldy 	#1
.1560	91 28		sta ($28),y			sta 	(objPtr),y
.1562	c8		iny				iny
.1563	68		pla				pla
.1564	91 28		sta ($28),y			sta 	(objPtr),y
.1566	80 d5		bra $153d			bra 	_FBNext
.1568					_FBFFail:
.1568	a0 02		ldy #$02			ldy 	#2
.156a	b1 28		lda ($28),y			lda 	(objPtr),y
.156c	8d 00 04	sta $0400			sta 	currentLineNumber
.156f	c8		iny				iny
.1570	b1 28		lda ($28),y			lda 	(objPtr),y
.1572	8d 01 04	sta $0401			sta 	currentLineNumber+1
.1575	4c 8e 1f	jmp $1f8e		jmp	ErrorV_line
.1578					_FBFixVarSpace:
.1578	a0 01		ldy #$01			ldy 	#1
.157a	ad 13 05	lda $0513			lda 	freeVariableMemory
.157d	91 28		sta ($28),y			sta 	(objPtr),y
.157f	c8		iny				iny
.1580	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1583	91 28		sta ($28),y			sta 	(objPtr),y
.1585	80 b6		bra $153d			bra 	_FBNext
.1587					CommandFOR:
.1587	20 6c 1a	jsr $1a6c			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.158a	20 82 1a	jsr $1a82			jsr 	CharIsAlpha 				; if not alpha , error
.158d	90 59		bcc $15e8			bcc 	_CFFail
.158f	20 ad 1d	jsr $1dad			jsr 	GetReferenceTerm 			; figure out the reference.
.1592	48		pha				pha 								; save type
.1593	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1595	c9 00		cmp #$00			cmp 	#NSSIFloat
.1597	d0 4f		bne $15e8			bne 	_CFFail
.1599	5a		phy				phy 								; save reference on the stack
.159a	da		phx				phx
.159b	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.159d	20 65 11	jsr $1165			jsr 	CheckNextA
.15a0	20 0c 14	jsr $140c			jsr 	CompileExpressionAt0 		; initial value
.15a3	fa		plx				plx 								; get reference back.
.15a4	7a		ply				ply
.15a5	5a		phy				phy
.15a6	da		phx				phx
.15a7	38		sec				sec 								; set initial value.
.15a8	20 5f 1d	jsr $1d5f			jsr 	GetSetVariable
.15ab	fa		plx				plx
.15ac	7a		ply				ply
.15ad	68		pla				pla
.15ae	29 20		and #$20			and 	#NSSIInt16
.15b0	f0 04		beq $15b6			beq 	_CFNotInt16
.15b2	98		tya				tya
.15b3	09 80		ora #$80			ora 	#$80
.15b5	a8		tay				tay
.15b6					_CFNotInt16:
.15b6	8a		txa				txa 								; reference in YA
.15b7	20 0b 12	jsr $120b			jsr 	PushIntegerYA
.15ba	a9 a4		lda #$a4			lda 	#C64_TO
.15bc	20 65 11	jsr $1165			jsr 	CheckNextA
.15bf	20 0c 14	jsr $140c			jsr 	CompileExpressionAt0 		; terminal value
.15c2	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15c4	c9 00		cmp #$00			cmp 	#NSSIFloat
.15c6	d0 20		bne $15e8			bne 	_CFFail
.15c8	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; followed by STEP
.15cb	c9 a9		cmp #$a9			cmp 	#C64_STEP
.15cd	d0 0e		bne $15dd			bne 	_CFNoStep
.15cf	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume it.
.15d2	20 0c 14	jsr $140c			jsr 	CompileExpressionAt0 		; terminal value
.15d5	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15d7	c9 00		cmp #$00			cmp 	#NSSIFloat
.15d9	d0 0d		bne $15e8			bne 	_CFFail
.15db	80 05		bra $15e2			bra 	_CFParametersDone
.15dd					_CFNoStep:
.15dd	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.15df	20 1e 12	jsr $121e			jsr 	PushIntegerA
.15e2					_CFParametersDone:
.15e2	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.15e4	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.15e7	60		rts				rts
.15e8					_CFFail:
.15e8	4c 4b 1f	jmp $1f4b		jmp	ErrorV_syntax
.15eb					FNCompile:
.15eb	20 6c 1a	jsr $1a6c			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.15ee	20 d1 1a	jsr $1ad1			jsr 	ExtractVariableName
.15f1	e0 00		cpx #$00			cpx 	#0
.15f3	10 32		bpl $1627			bpl 	_FNError
.15f5	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.15f6	29 7f		and #$7f			and 	#$7F
.15f8	aa		tax				tax
.15f9	98		tya				tya
.15fa	09 80		ora #$80			ora 	#$80
.15fc	a8		tay				tay
.15fd	20 c6 14	jsr $14c6			jsr 	FindVariable				; does it already exist ?
.1600	90 25		bcc $1627			bcc 	_FNError 					; no.
.1602	20 53 1c	jsr $1c53			jsr 	STRMakeOffset 				; convert to a relative address.
.1605	c9 00		cmp #$00			cmp 	#0 							; fix up.
.1607	d0 01		bne $160a			bne 	_FNNoBorrow
.1609	88		dey				dey
.160a					_FNNoBorrow:
.160a	3a		dec a				dec 	a
.160b	5a		phy				phy 								; save location of routine on stack.
.160c	48		pha				pha
.160d	da		phx				phx
.160e	20 0c 14	jsr $140c			jsr 	CompileExpressionAt0
.1611	20 5f 11	jsr $115f			jsr 	CheckNextRParen
.1614	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1616	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1619	68		pla				pla
.161a	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.161d	68		pla				pla
.161e	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1621	68		pla				pla
.1622	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1625	18		clc				clc
.1626	60		rts				rts
.1627					_FNError:
.1627	4c 3e 1f	jmp $1f3e		jmp	ErrorV_value
.162a					CommandTables:
>162a	07 cb 00 03 2f 1b 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>1631	07 89 00 03 36 1b 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>1638	07 8d 00 03 29 1b 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>163f	07 88 00 03 a5 1b 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>1646	07 85 00 03 85 1b 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>164d	07 84 00 04 99 1b 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>1654	07 99 00 03 da 1c 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>165b	07 98 00 04 da 1c 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1662	07 8f 00 03 e5 1d 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>1669	07 81 00 03 87 15 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>1670	07 82 00 03 5d 1c 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>1677	07 a1 00 03 a2 1a 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>167e	07 83 00 03 c1 12 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>1685	07 87 00 03 23 1d 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>168c	07 86 00 03 54 13 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>1693	07 96 00 03 dd 12 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>169a	07 8b 00 e3 52 1b 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>16a1	08 92 00 ea e3 b1 1e 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>16a9	09 91 00 e1 a9 03 89 1c			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>16b1	06
>16b2	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>16b9	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>16c0	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>16c6	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>16cd	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>16d4	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>16db	07 9d 00 e3 d7 1e 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>16e2	0a 9f 00 ea e3 ea 1e 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>16ea	c6 06
>16ec	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>16f2	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>16f9	0a ce 92 e3 1f 1a 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>1701	ad 06
>1703	0a ce 8d e3 1f 1a 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>170b	ae 06
>170d	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>1713	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>171b	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>1722	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>1729	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>1731	06
>1732	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>173a	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>1742	9a 06
>1744	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>174c	9b 06
>174e	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>1756	9c 06
>1758	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>1760	06
>1761	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>1768	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>1770	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>1778	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>1780	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>1788	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>1790	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>1798	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>17a0	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>17a8	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>17b0	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>17b8	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>17bf	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>17c7	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>17cf	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>17d7	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>17df	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>17e7	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>17ef	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>17f7	00						.byte 	0
.17f8					UnaryTables:
>17f8	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>17ff	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>1807	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>180e	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>1815	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>181c	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>1823	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>182b	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>1832	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>183a	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>1842	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>184a	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>1852	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>185a	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>1862	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>1869	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>1870	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>1877	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>187e	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>1885	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>188c	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>1894	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>189c	0b ca 00 8f ae 03 1f 1a			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>18a4	91 bd 07
>18a7	07 a8 00 03 3e 1a 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>18ae	07 a5 00 03 eb 15 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>18b5	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>18bc	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>18c3	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>18cb	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>18d3	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>18da	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>18e1	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>18e8	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>18f0	06
>18f1	00						.byte 	0
.18f2					GeneratorProcess:
.18f2	86 2a		stx $2a				stx 	zTemp0 						; save generation pointer in zTemp0
.18f4	84 2b		sty $2b				sty 	zTemp0+1
.18f6	85 2c		sta $2c				sta 	zTemp1 						; first match token
.18f8	64 2d		stz $2d				stz 	zTemp1+1
.18fa	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.18fc	d0 05		bne $1903			bne 	_GPNotShifted
.18fe	20 61 1a	jsr $1a61			jsr 	GetNext 					; get the shifted token
.1901	85 2d		sta $2d				sta 	zTemp1+1 					; match CE xx
.1903					_GPNotShifted:
.1903					_GPSearch:
.1903	b2 2a		lda ($2a)			lda 	(zTemp0) 					; reached end ?
.1905	18		clc				clc
.1906	f0 2f		beq $1937			beq 	_GPExit
.1908	a0 01		ldy #$01			ldy 	#1 							; tokens match
.190a	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.190c	c5 2c		cmp $2c				cmp 	zTemp1
.190e	d0 09		bne $1919			bne 	_GPNext
.1910	a5 2d		lda $2d				lda 	zTemp1+1 					; 2nd token ?
.1912	f0 12		beq $1926			beq 	_GPFound
.1914	c8		iny				iny 								; check match.
.1915	d1 2a		cmp ($2a),y			cmp 	(zTemp0),y
.1917	f0 0d		beq $1926			beq 	_GPFound
.1919					_GPNext:
.1919	18		clc				clc 								; follow to next
.191a	a5 2a		lda $2a				lda 	zTemp0
.191c	72 2a		adc ($2a)			adc 	(zTemp0)
.191e	85 2a		sta $2a				sta 	zTemp0
.1920	90 e1		bcc $1903			bcc 	_GPSearch
.1922	e6 2b		inc $2b				inc 	zTemp0+1
.1924	80 dd		bra $1903			bra 	_GPSearch
.1926					_GPFound:
.1926	18		clc				clc 								; skip to action bytes
.1927	a5 2a		lda $2a				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.1929	69 03		adc #$03			adc 	#3
.192b	85 2a		sta $2a				sta 	zTemp0
.192d	90 02		bcc $1931			bcc 	_GPNoCarry
.192f	e6 2b		inc $2b				inc 	zTemp0+1
.1931					_GPNoCarry:
.1931					_GPLoop:
.1931	20 38 19	jsr $1938			jsr 	GeneratorExecute 			; execute one command
.1934	90 fb		bcc $1931			bcc 	_GPLoop 					; go back if not completed.
.1936	38		sec				sec 								; return with CS.
.1937					_GPExit:
.1937	60		rts				rts
.1938					GeneratorExecute:
.1938	20 e4 19	jsr $19e4			jsr 	_GEFetchZTemp0 				; get next.
.193b	48		pha				pha 								; split into 2 nibbles
.193c	4a		lsr a				lsr 	a
.193d	4a		lsr a				lsr 	a
.193e	4a		lsr a				lsr		a
.193f	4a		lsr a				lsr 	a
.1940	20 4a 19	jsr $194a			jsr 	_GEExecuteNibble 			; MSB first
.1943	68		pla				pla
.1944	b0 03		bcs $1949			bcs 	_GEHaveCompleted
.1946	20 4a 19	jsr $194a			jsr 	_GEExecuteNibble 			; LSB second
.1949					_GEHaveCompleted:
.1949	60		rts				rts
.194a					_GEExecuteNibble:
.194a	29 0f		and #$0f			and 	#$0F
.194c	0a		asl a				asl 	a
.194d	aa		tax				tax
.194e	7c 51 19	jmp ($1951,x)			jmp 	(_GEExecuteVectors,x)
.1951					_GEExecuteVectors:
>1951	71 19						.word 	_GEXNop 					; 0  (no operation)
>1953	79 19						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>1955	73 19						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>1957	c7 19						.word 	_GEXExecute 				; 3  (run arbitrary code)
>1959	ba 19						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>195b	71 19						.word 	_GEXNop 					; 5
>195d	81 19						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>195f	85 19						.word 	_GEXExitString 				; 7  exit return string type
>1961	89 19						.word 	_GEXLParam 					; 8  check ( follows
>1963	8d 19						.word 	_GEXRParam 					; 9  check ) follows
>1965	91 19						.word 	_GEXComma					; A  check , follows
>1967	71 19						.word 	_GEXNop 					; B
>1969	71 19						.word 	_GEXNop 					; C
>196b	71 19						.word 	_GEXNop 					; D
>196d	a1 19						.word 	_GEXNumber 					; E  compile get any number
>196f	ac 19						.word 	_GEXString 					; F  compile get any string
.1971					_GEXNop:
.1971	18		clc				clc
.1972	60		rts				rts
.1973					_GEXToken2:
.1973	20 e4 19	jsr $19e4			jsr 	_GEFetchZTemp0
.1976	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1979					_GEXToken1:
.1979	20 e4 19	jsr $19e4			jsr 	_GEFetchZTemp0
.197c	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.197f	18		clc				clc
.1980	60		rts				rts
.1981					_GEXExitNumber:
.1981	a9 00		lda #$00			lda 	#NSSIFloat
.1983	38		sec				sec
.1984	60		rts				rts
.1985					_GEXExitString:
.1985	a9 40		lda #$40			lda 	#NSSString
.1987	38		sec				sec
.1988	60		rts				rts
.1989					_GEXLParam:
.1989	a9 28		lda #$28			lda 	#"("
.198b	80 06		bra $1993			bra 	_GEXCheck
.198d					_GEXRParam:
.198d	a9 29		lda #$29			lda 	#")"
.198f	80 02		bra $1993			bra 	_GEXCheck
.1991					_GEXComma:
.1991	a9 2c		lda #$2c			lda 	#","
.1993					_GEXCheck:
.1993	85 2e		sta $2e				sta 	zTemp2 						; save match
.1995	20 6c 1a	jsr $1a6c			jsr 	GetNextNonSpace 			; get next skipping spaces
.1998	c5 2e		cmp $2e				cmp 	zTemp2 						; check matches.
.199a	d0 02		bne $199e			bne 	_GEXSyntax
.199c	18		clc				clc
.199d	60		rts				rts
.199e					_GEXSyntax:
.199e	4c 4b 1f	jmp $1f4b		jmp	ErrorV_syntax
.19a1					_GEXNumber:
.19a1	20 ed 19	jsr $19ed			jsr 	GEXCompileExpression 		; compile expression
.19a4	29 40		and #$40			and 	#NSSTypeMask
.19a6	c9 00		cmp #$00			cmp  	#NSSIFloat
.19a8	d0 0d		bne $19b7			bne 	_GEXType
.19aa	18		clc				clc
.19ab	60		rts				rts
.19ac					_GEXString:
.19ac	20 ed 19	jsr $19ed			jsr 	GEXCompileExpression 		; compile expression
.19af	29 40		and #$40			and 	#NSSTypeMask
.19b1	c9 40		cmp #$40			cmp  	#NSSString
.19b3	d0 02		bne $19b7			bne 	_GEXType
.19b5	18		clc				clc
.19b6	60		rts				rts
.19b7					_GEXType:
.19b7	4c 5b 1f	jmp $1f5b		jmp	ErrorV_type
.19ba					_GEXChannelExec:
.19ba	20 fd 19	jsr $19fd			jsr 	ChannelPrefix 				; set up default
.19bd	20 c7 19	jsr $19c7			jsr 	_GEXExecute
.19c0	08		php				php
.19c1	20 18 1a	jsr $1a18			jsr 	ChannelPostfix 				; replace default.
.19c4	28		plp				plp
.19c5	60		rts				rts
>19c6	db						.byte 	$DB 						; causes a break in the emulator
.19c7					_GEXExecute:
.19c7	20 e4 19	jsr $19e4			jsr 	_GEFetchZTemp0 				; get vector
.19ca	85 2e		sta $2e				sta 	zTemp2
.19cc	20 e4 19	jsr $19e4			jsr 	_GEFetchZTemp0
.19cf	85 2f		sta $2f				sta 	zTemp2+1
.19d1	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19d3	da		phx				phx
.19d4	a6 2b		ldx $2b				ldx 	zTemp0+1
.19d6	da		phx				phx
.19d7	20 e1 19	jsr $19e1			jsr 	_GECallZTemp2 				; execute code
.19da	fa		plx				plx 								; recover generation exec
.19db	86 2b		stx $2b				stx 	zTemp0+1
.19dd	fa		plx				plx
.19de	86 2a		stx $2a				stx 	zTemp0
.19e0	60		rts				rts
.19e1					_GECallZTemp2:
.19e1	6c 2e 00	jmp ($002e)			jmp 	(zTemp2)
.19e4					_GEFetchZTemp0:
.19e4	b2 2a		lda ($2a)			lda 	(zTemp0)
.19e6	e6 2a		inc $2a				inc 	zTemp0
.19e8	d0 02		bne $19ec			bne 	_GEFZ0Skip
.19ea	e6 2b		inc $2b				inc 	zTemp0+1
.19ec					_GEFZ0Skip:
.19ec	60		rts				rts
.19ed					GEXCompileExpression:
.19ed	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19ef	da		phx				phx
.19f0	a6 2b		ldx $2b				ldx 	zTemp0+1
.19f2	da		phx				phx
.19f3	20 0c 14	jsr $140c			jsr 	CompileExpressionAt0 		; compile expression.
.19f6	fa		plx				plx 								; recover generation exec
.19f7	86 2b		stx $2b				stx 	zTemp0+1
.19f9	fa		plx				plx
.19fa	86 2a		stx $2a				stx 	zTemp0
.19fc	60		rts				rts
.19fd					ChannelPrefix:
.19fd	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.19ff	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1a02	20 ed 19	jsr $19ed			jsr 	GEXCompileExpression 		; channel #
.1a05	29 40		and #$40			and 	#NSSTypeMask
.1a07	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a09	d0 0a		bne $1a15			bne 	_CPXType
.1a0b	20 5b 11	jsr $115b			jsr 	CheckNextComma 				; check , follows.
.1a0e	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.1a10	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1a13	18		clc				clc
.1a14	60		rts				rts
.1a15					_CPXType:
.1a15	4c 5b 1f	jmp $1f5b		jmp	ErrorV_type
.1a18					ChannelPostfix:
.1a18	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.1a1a	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1a1d	18		clc				clc
.1a1e	60		rts				rts
.1a1f					OptionalParameterCompile:
.1a1f	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; what follows.
.1a22	c9 2c		cmp #$2c			cmp 	#","
.1a24	d0 0e		bne $1a34			bne 	_MidDefault
.1a26	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume ,
.1a29	20 0c 14	jsr $140c			jsr 	CompileExpressionAt0
.1a2c	29 40		and #$40			and 	#NSSTypeMask
.1a2e	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a30	d0 09		bne $1a3b			bne 	MidFailType
.1a32	80 05		bra $1a39			bra 	_MidComplete
.1a34					_MidDefault:
.1a34	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1a36	20 1e 12	jsr $121e			jsr 	PushIntegerA
.1a39					_MidComplete:
.1a39	18		clc				clc
.1a3a	60		rts				rts
.1a3b					MidFailType:
.1a3b	4c 5b 1f	jmp $1f5b		jmp	ErrorV_type
.1a3e					NotUnaryCompile:
.1a3e	ad c1 14	lda $14c1			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1a41	20 0e 14	jsr $140e			jsr 	CompileExpressionAtA 		; evaluate at that level
.1a44	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1a46	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a48	d0 f1		bne $1a3b			bne 	MidFailType
.1a4a	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1a4c	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1a4f	60		rts				rts
.1a50					LookNext:
.1a50	b2 24		lda ($24)			lda 	(srcPtr)
.1a52	60		rts				rts
.1a53					LookNextNonSpace:
.1a53	b2 24		lda ($24)			lda 	(srcPtr)
.1a55	c9 20		cmp #$20			cmp		#' '
.1a57	f0 03		beq $1a5c			beq 	_LNNSkip
.1a59	c9 00		cmp #$00			cmp 	#0
.1a5b	60		rts				rts
.1a5c					_LNNSkip:
.1a5c	20 61 1a	jsr $1a61			jsr 	GetNext
.1a5f	80 f2		bra $1a53			bra 	LookNextNonSpace
.1a61					GetNext:
.1a61	b2 24		lda ($24)			lda 	(srcPtr) 					; get next
.1a63	e6 24		inc $24				inc 	srcPtr
.1a65	d0 02		bne $1a69			bne 	_GNSkip
.1a67	e6 25		inc $25				inc 	srcPtr+1
.1a69					_GNSkip:
.1a69	c9 00		cmp #$00			cmp 	#0
.1a6b	60		rts				rts
.1a6c					GetNextNonSpace:
.1a6c	20 61 1a	jsr $1a61			jsr 	GetNext
.1a6f	c9 20		cmp #$20			cmp 	#' '
.1a71	f0 f9		beq $1a6c			beq 	GetNextNonSpace
.1a73	c9 00		cmp #$00			cmp 	#0
.1a75	60		rts				rts
.1a76					CharIsDigit:
.1a76	c9 30		cmp #$30			cmp 	#"0"
.1a78	90 06		bcc $1a80			bcc 	CCFalse
.1a7a	c9 3a		cmp #$3a			cmp 	#"9"+1
.1a7c	b0 02		bcs $1a80			bcs 	CCFalse
.1a7e					CCTrue:
.1a7e	38		sec				sec
.1a7f	60		rts				rts
.1a80					CCFalse:
.1a80	18		clc				clc
.1a81	60		rts				rts
.1a82					CharIsAlpha:
.1a82	c9 41		cmp #$41			cmp 	#"A"
.1a84	90 fa		bcc $1a80			bcc 	CCFalse
.1a86	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1a88	b0 f6		bcs $1a80			bcs 	CCFalse
.1a8a	80 f2		bra $1a7e			bra 	CCTrue
.1a8c					ConvertHexStyle:
.1a8c	38		sec				sec
.1a8d	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1a8f	90 ef		bcc $1a80			bcc 	CCFalse
.1a91	c9 0a		cmp #$0a			cmp 	#9+1
.1a93	90 e9		bcc $1a7e			bcc 	CCTrue
.1a95	38		sec				sec 								; shift into hex space A=>0 Z=>25
.1a96	e9 11		sbc #$11			sbc 	#"A"-"0"
.1a98	90 e6		bcc $1a80			bcc 	CCFalse
.1a9a	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.1a9c	b0 e2		bcs $1a80			bcs 	CCFalse
.1a9e	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.1aa0	80 dc		bra $1a7e			bra 	CCTrue
.1aa2					CommandGET:
.1aa2	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; # follows ?
.1aa5	c9 23		cmp #$23			cmp 	#"#"
.1aa7	d0 0d		bne $1ab6			bne 	CommandGetBody
.1aa9	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume #
.1aac	20 fd 19	jsr $19fd			jsr 	ChannelPrefix 				; do it as GET#
.1aaf	20 b6 1a	jsr $1ab6			jsr 	CommandGetBody
.1ab2	20 18 1a	jsr $1a18			jsr 	ChannelPostfix
.1ab5	60		rts				rts
.1ab6					CommandGetBody:
.1ab6	20 6c 1a	jsr $1a6c			jsr 	GetNextNonSpace 			; get the first character
.1ab9	20 ad 1d	jsr $1dad			jsr 	GetReferenceTerm 			; identify variable to assign to
.1abc	48		pha				pha
.1abd	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1abf	c9 40		cmp #$40			cmp 	#NSSString
.1ac1	d0 0b		bne $1ace			bne 	_CGType
.1ac3	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1ac5	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1ac8	38		sec				sec
.1ac9	68		pla				pla
.1aca	20 5f 1d	jsr $1d5f			jsr		GetSetVariable
.1acd	60		rts				rts
.1ace					_CGType:
.1ace	4c 5b 1f	jmp $1f5b		jmp	ErrorV_type
.1ad1					ExtractVariableName:
.1ad1	20 82 1a	jsr $1a82			jsr 	CharIsAlpha
.1ad4	90 50		bcc $1b26			bcc 	_IVSyntax
.1ad6	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.1ad8	85 2c		sta $2c				sta 	zTemp1 						; we'll build it in zTemp1
.1ada	64 2d		stz $2d				stz 	zTemp1+1
.1adc	20 50 1a	jsr $1a50			jsr 	LookNext 					; is there a second character ?
.1adf	20 82 1a	jsr $1a82			jsr 	CharIsAlpha  				; must be alphanumeric
.1ae2	b0 05		bcs $1ae9			bcs 	_IVHasSecond
.1ae4	20 76 1a	jsr $1a76			jsr 	CharIsDigit
.1ae7	90 07		bcc $1af0			bcc 	_IVCheckType
.1ae9					_IVHasSecond:
.1ae9	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.1aeb	85 2d		sta $2d				sta 	zTemp1+1
.1aed					_IVGetNextCheck:
.1aed	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume it
.1af0					_IVCheckType:
.1af0	20 50 1a	jsr $1a50			jsr 	LookNext					; check if string follows.
.1af3	20 82 1a	jsr $1a82			jsr 	CharIsAlpha
.1af6	b0 f5		bcs $1aed			bcs 	_IVGetNextCheck
.1af8	20 76 1a	jsr $1a76			jsr 	CharIsDigit
.1afb	b0 f0		bcs $1aed			bcs 	_IVGetNextCheck
.1afd	a2 40		ldx #$40			ldx 	#NSSString
.1aff	c9 24		cmp #$24			cmp 	#"$"
.1b01	f0 06		beq $1b09			beq 	_IVHasType
.1b03	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.1b05	c9 25		cmp #$25			cmp 	#"%"
.1b07	d0 08		bne $1b11			bne 	_IVCheckArray
.1b09					_IVHasType:
.1b09	8a		txa				txa 								; Or X into zTemp1
.1b0a	05 2c		ora $2c				ora 	zTemp1
.1b0c	85 2c		sta $2c				sta 	zTemp1
.1b0e	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume it
.1b11					_IVCheckArray:
.1b11	20 50 1a	jsr $1a50			jsr 	LookNext 					; check if array follows
.1b14	c9 28		cmp #$28			cmp 	#"("
.1b16	d0 09		bne $1b21			bne 	_IVNotArray
.1b18	a5 2c		lda $2c				lda 	zTemp1 						; set array bit
.1b1a	09 80		ora #$80			ora 	#NSSArray
.1b1c	85 2c		sta $2c				sta 	zTemp1
.1b1e	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume it
.1b21					_IVNotArray:
.1b21	a6 2c		ldx $2c				ldx 	zTemp1
.1b23	a4 2d		ldy $2d				ldy 	zTemp1+1
.1b25	60		rts				rts
.1b26					_IVSyntax:
.1b26	4c 4b 1f	jmp $1f4b		jmp	ErrorV_syntax
.1b29					CommandGOSUB:
.1b29	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1b2b	20 3c 1b	jsr $1b3c			jsr 	CompileBranchCommand
.1b2e	60		rts				rts
.1b2f					CommandGOAlt:
.1b2f	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1b31	20 65 11	jsr $1165			jsr 	CheckNextA
.1b34	80 00		bra $1b36			bra 	CommandGOTO
.1b36					CommandGOTO:
.1b36	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1b38	20 3c 1b	jsr $1b3c			jsr 	CompileBranchCommand
.1b3b	60		rts				rts
.1b3c					CompileBranchCommand:
.1b3c	20 fd 10	jsr $10fd			jsr 	WriteCodeByte 				; write the command out.
.1b3f	20 6c 1a	jsr $1a6c			jsr 	GetNextNonSpace
.1b42	20 b5 1c	jsr $1cb5			jsr 	ParseConstant 				; get constant into YA
.1b45	90 08		bcc $1b4f			bcc 	_CBCSyntax
.1b47	20 fd 10	jsr $10fd			jsr 	WriteCodeByte				; and compile the actual line number
.1b4a	98		tya				tya
.1b4b	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1b4e	60		rts				rts
.1b4f					_CBCSyntax:
.1b4f	4c 4b 1f	jmp $1f4b		jmp	ErrorV_syntax
.1b52					CommandIF:
.1b52	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; what follows the tests ?
.1b55	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1b57	f0 0f		beq $1b68			beq 	_CIGoto
.1b59	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1b5b	20 65 11	jsr $1165			jsr 	CheckNextA
.1b5e	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; THEN <number>
.1b61	20 76 1a	jsr $1a76			jsr 	CharIsDigit
.1b64	b0 05		bcs $1b6b			bcs 	_CIGoto2
.1b66	80 09		bra $1b71			bra 	CompileGotoEOL
.1b68					_CIGoto:
.1b68	20 61 1a	jsr $1a61			jsr 	GetNext
.1b6b					_CIGoto2:
.1b6b	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1b6d	20 3c 1b	jsr $1b3c			jsr 	CompileBranchCommand
.1b70	60		rts				rts
.1b71					CompileGotoEOL:
.1b71	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.1b73	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1b76	20 f6 10	jsr $10f6			jsr 	GetLineNumber 				; Get the current line number => YA
.1b79	1a		inc a				inc 	a 							; and branch to +1
.1b7a	d0 01		bne $1b7d			bne 	_CGENoCarry
.1b7c	c8		iny				iny
.1b7d					_CGENoCarry:
.1b7d	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1b80	98		tya				tya
.1b81	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1b84	60		rts				rts
.1b85					CommandINPUT:
.1b85	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; check for "
.1b88	c9 22		cmp #$22			cmp 	#'"'
.1b8a	d0 0d		bne $1b99			bne 	CommandINPUTStream
.1b8c	20 0c 14	jsr $140c			jsr 	CompileExpressionAt0
.1b8f	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1b91	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1b94	a9 2c		lda #$2c			lda 	#","
.1b96	20 5b 11	jsr $115b			jsr 	CheckNextComma
.1b99					CommandINPUTStream:
.1b99	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1b9b	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1b9e	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.1ba0	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1ba2	4c 27 1d	jmp $1d27			jmp 	CommandReadInputCommon
.1ba5					CommandLET:
.1ba5	20 6c 1a	jsr $1a6c			jsr 	GetNextNonSpace 			; get the first character
.1ba8					CommandLETHaveFirst:
.1ba8	20 ad 1d	jsr $1dad			jsr 	GetReferenceTerm 			; identify variable to assign to
.1bab	da		phx				phx 								; save target on the stack.
.1bac	5a		phy				phy
.1bad	48		pha				pha
.1bae	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.1bb0	20 65 11	jsr $1165			jsr 	CheckNextA
.1bb3	20 0c 14	jsr $140c			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1bb6	85 2a		sta $2a				sta 	zTemp0 						; save type returned
.1bb8	68		pla				pla 								; get type of assignment
.1bb9	48		pha				pha
.1bba	45 2a		eor $2a				eor 	zTemp0 						; compare using EOR
.1bbc	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.1bbe	d0 17		bne $1bd7			bne 	_CLType
.1bc0	68		pla				pla 								; restore and compile save code
.1bc1	7a		ply				ply
.1bc2	fa		plx				plx
.1bc3	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.1bc5	f0 05		beq $1bcc			beq 	_CLTIString
.1bc7	38		sec				sec
.1bc8	20 5f 1d	jsr $1d5f			jsr		GetSetVariable
.1bcb	60		rts				rts
.1bcc					_CLTIString:
.1bcc	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.1bce	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1bd1	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.1bd3	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1bd6	60		rts				rts
.1bd7					_CLType:
.1bd7	4c 5b 1f	jmp $1f5b		jmp	ErrorV_type
.1bda					STRMarkLine:
.1bda	48		pha				pha
.1bdb	38		sec				sec 								; allocate 4 bytes (line #,address)
.1bdc	ad 0f 05	lda $050f			lda 	lineNumberTable 			; and copy to zTemp0
.1bdf	e9 04		sbc #$04			sbc 	#4
.1be1	8d 0f 05	sta $050f			sta 	lineNumberTable
.1be4	85 2a		sta $2a				sta 	zTemp0
.1be6	ad 10 05	lda $0510			lda 	lineNumberTable+1
.1be9	e9 00		sbc #$00			sbc 	#0
.1beb	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1bee	85 2b		sta $2b				sta 	zTemp0+1
.1bf0	68		pla				pla
.1bf1	92 2a		sta ($2a)			sta 	(zTemp0) 					; line # save it in +0,+1
.1bf3	98		tya				tya
.1bf4	a0 01		ldy #$01			ldy 	#1
.1bf6	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1bf8	a5 28		lda $28				lda 	objPtr 						; save current address in +2,+3
.1bfa	c8		iny				iny
.1bfb	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1bfd	a5 29		lda $29				lda 	objPtr+1
.1bff	c8		iny				iny
.1c00	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1c02	60		rts				rts
.1c03					STRFindLine:
.1c03	85 2a		sta $2a				sta 	zTemp0 						; zTemp0 line number being searched
.1c05	84 2b		sty $2b				sty 	zTemp0+1
.1c07	ad 08 05	lda $0508			lda 	compilerEndHigh 			; work backwards through table
.1c0a	85 2d		sta $2d				sta 	zTemp1+1
.1c0c	64 2c		stz $2c				stz 	zTemp1
.1c0e					_STRSearch:
.1c0e	20 45 1c	jsr $1c45			jsr 	_STRPrevLine 				; look at previous record.
.1c11	a0 01		ldy #$01			ldy 	#1
.1c13	b2 2c		lda ($2c)			lda 	(zTemp1) 					; check table line # >= target
.1c15	c5 2a		cmp $2a				cmp 	zTemp0
.1c17	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c19	e5 2b		sbc $2b				sbc 	zTemp0+1
.1c1b	b0 0b		bcs $1c28			bcs 	_STRFound 					; >=
.1c1d					_STRNext:
.1c1d	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1c1f	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c21	c9 ff		cmp #$ff			cmp 	#$FF
.1c23	d0 e9		bne $1c0e			bne 	_STRSearch
.1c25	4c a5 1f	jmp $1fa5		jmp	ErrorV_internal
.1c28					_STRFound:
.1c28	b2 2c		lda ($2c)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1c2a	45 2a		eor $2a				eor 	zTemp0
.1c2c	d0 06		bne $1c34			bne 	_STRDifferent
.1c2e	b2 2c		lda ($2c)			lda 	(zTemp1)
.1c30	45 2a		eor $2a				eor 	zTemp0
.1c32	f0 02		beq $1c36			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1c34					_STRDifferent:
.1c34	a9 ff		lda #$ff			lda 	#$FF
.1c36					_STROut:
.1c36	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1c37	69 ff		adc #$ff			adc 	#255
.1c39	08		php				php
.1c3a	c8		iny				iny 								; address into YA
.1c3b	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c3d	48		pha				pha
.1c3e	c8		iny				iny
.1c3f	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c41	a8		tay				tay
.1c42	68		pla				pla
.1c43	28		plp				plp
.1c44	60		rts				rts
.1c45					_STRPrevLine:
.1c45	38		sec				sec 								; move backwards one entry.
.1c46	a5 2c		lda $2c				lda 	zTemp1
.1c48	e9 04		sbc #$04			sbc 	#4
.1c4a	85 2c		sta $2c				sta 	zTemp1
.1c4c	a5 2d		lda $2d				lda 	zTemp1+1
.1c4e	e9 00		sbc #$00			sbc 	#0
.1c50	85 2d		sta $2d				sta 	zTemp1+1
.1c52	60		rts				rts
.1c53					STRMakeOffset:
.1c53	18		clc				clc 								; borrow 1
.1c54	e5 28		sbc $28				sbc 	objPtr
.1c56	48		pha				pha
.1c57	98		tya				tya
.1c58	e5 29		sbc $29				sbc 	objPtr+1
.1c5a	a8		tay				tay
.1c5b	68		pla				pla
.1c5c	60		rts				rts
.1c5d					CommandNEXT:
.1c5d	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1c60	20 82 1a	jsr $1a82			jsr 	CharIsAlpha 				; if not alpha , error
.1c63	90 0c		bcc $1c71			bcc 	_CNNoReferenceGiven
.1c65	20 61 1a	jsr $1a61			jsr 	GetNext
.1c68	20 ad 1d	jsr $1dad			jsr 	GetReferenceTerm 			; figure out the reference.
.1c6b	8a		txa				txa 								; reference in YA
.1c6c	20 0b 12	jsr $120b			jsr 	PushIntegerYA 				; write it out.
.1c6f	80 06		bra $1c77			bra 	_CNParametersDone
.1c71					_CNNoReferenceGiven:
.1c71	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1c73	a8		tay				tay
.1c74	20 0b 12	jsr $120b			jsr 	PushIntegerYA 				; write it out.
.1c77					_CNParametersDone:
.1c77	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1c79	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1c7c	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; look for ,
.1c7f	c9 2c		cmp #$2c			cmp 	#","
.1c81	d0 05		bne $1c88			bne 	_CNExit
.1c83	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume ,
.1c86	80 d5		bra $1c5d			bra 	CommandNEXT 				; and go round.
.1c88					_CNExit:
.1c88	60		rts				rts
.1c89					CommandON:
.1c89	20 6c 1a	jsr $1a6c			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1c8c	48		pha				pha 								; save on stack
.1c8d	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1c8f	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1c91	f0 09		beq $1c9c			beq 	_COCreateLoop
.1c93	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1c95	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1c97	f0 03		beq $1c9c			beq 	_COCreateLoop
.1c99	4c 4b 1f	jmp $1f4b		jmp	ErrorV_syntax
.1c9c					_COCreateLoop:
.1c9c	8a		txa				txa 								; compile a goto/gosub somewhere
.1c9d	da		phx				phx
.1c9e	20 3c 1b	jsr $1b3c			jsr 	CompileBranchCommand
.1ca1	fa		plx				plx
.1ca2	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace			; ',' follows
.1ca5	c9 2c		cmp #$2c			cmp 	#","
.1ca7	d0 0a		bne $1cb3			bne 	_COComplete 				; if so, more line numbers
.1ca9	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1cab	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1cae	20 61 1a	jsr $1a61			jsr 	GetNext
.1cb1	80 e9		bra $1c9c			bra 	_COCreateLoop
.1cb3					_COComplete:
.1cb3	68		pla				pla 								; throw GOTO/GOSUB
.1cb4	60		rts				rts
.1cb5					ParseConstant:
.1cb5	a2 00		ldx #$00			ldx 	#0
.1cb7	20 71 24	jsr $2471			jsr 	FloatEncodeStart 			; send first
.1cba					_ParseLoop:
.1cba	20 50 1a	jsr $1a50			jsr 	LookNext 					; send subsequent
.1cbd	20 74 24	jsr $2474			jsr 	FloatEncodeContinue
.1cc0	90 05		bcc $1cc7			bcc 	_ParseDone
.1cc2	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume it
.1cc5	80 f3		bra $1cba			bra 	_ParseLoop
.1cc7					_ParseDone:
.1cc7	b5 30		lda $30,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1cc9	29 80		and #$80			and 	#$80
.1ccb	15 6c		ora $6c,x			ora 	NSExponent,x 				; 16 bit int check
.1ccd	15 54		ora $54,x			ora 	NSMantissa2,x
.1ccf	15 60		ora $60,x			ora 	NSMantissa3,x
.1cd1	18		clc				clc
.1cd2	d0 05		bne $1cd9			bne 	_ParseExit 					; exit with CC if need float to compile
.1cd4	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; read into YA.
.1cd6	b4 48		ldy $48,x			ldy		NSMantissa1,x
.1cd8	38		sec				sec
.1cd9					_ParseExit:
.1cd9	60		rts				rts
.1cda					CommandPRINT:
.1cda	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace			; what follows ?
.1cdd	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1cdf	f0 1f		beq $1d00			beq 	_CPCheckEnd
.1ce1	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1ce3	f0 16		beq $1cfb			beq 	_CPTabCheckEnd
.1ce5	20 17 1d	jsr $1d17			jsr 	_CPAtEnd 					; check for : and EOL
.1ce8	b0 22		bcs $1d0c			bcs 	_CPExitCR 					; exit with CR
.1cea	20 0c 14	jsr $140c			jsr 	CompileExpressionAt0 		; so it is something to print
.1ced	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1cef	29 40		and #$40			and 	#NSSString 					; if string
.1cf1	d0 02		bne $1cf5			bne 	_CPOut
.1cf3	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1cf5					_CPOut:
.1cf5	8a		txa				txa 								; print that thing
.1cf6	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1cf9	80 df		bra $1cda			bra 	CommandPRINT 				; and loop round/
.1cfb					_CPTabCheckEnd:
.1cfb	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1cfd	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1d00					_CPCheckEnd:
.1d00	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume it.
.1d03	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; what follows ?
.1d06	20 17 1d	jsr $1d17			jsr 	_CPAtEnd 					; reached end
.1d09	90 cf		bcc $1cda			bcc 	CommandPRINT 				; no, loop back
.1d0b	60		rts				rts
.1d0c					_CPExitCR:
.1d0c	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1d0e	20 1e 12	jsr $121e			jsr 	PushIntegerA
.1d11	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1d13	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1d16	60		rts				rts
.1d17					_CPAtEnd:
.1d17	c9 00		cmp #$00			cmp 	#0
.1d19	f0 06		beq $1d21			beq 	_CPIsEnd
.1d1b	c9 3a		cmp #$3a			cmp 	#":"
.1d1d	f0 02		beq $1d21			beq 	_CPIsEnd
.1d1f	18		clc				clc
.1d20	60		rts				rts
.1d21					_CPIsEnd:
.1d21	38		sec				sec
.1d22	60		rts				rts
.1d23					CommandREAD:
.1d23	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1d25	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1d27					CommandReadInputCommon:
.1d27	8e 0d 05	stx $050d			stx 	numberPCode
.1d2a	8c 0e 05	sty $050e			sty 	stringPCode
.1d2d					_CRLoop:
.1d2d	20 6c 1a	jsr $1a6c			jsr 	GetNextNonSpace 			; first char of identifier
.1d30	20 82 1a	jsr $1a82			jsr 	CharIsAlpha 				; check A-Z
.1d33	90 27		bcc $1d5c			bcc 	_CRSyntax
.1d35	20 ad 1d	jsr $1dad			jsr 	GetReferenceTerm 			; get the variable.
.1d38	48		pha				pha 								; save type.
.1d39	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1d3b	c9 40		cmp #$40			cmp 	#NSSString
.1d3d	f0 05		beq $1d44			beq 	_CRString
.1d3f	ad 0d 05	lda $050d			lda 	numberPCode 				; output read/input
.1d42	80 03		bra $1d47			bra 	_CRHaveType
.1d44					_CRString:
.1d44	ad 0e 05	lda $050e			lda 	stringPCode					; output read$/input$
.1d47					_CRHaveType:
.1d47	20 fd 10	jsr $10fd			jsr 	WriteCodeByte 				; so we have one typed data item.
.1d4a	68		pla				pla 								; restore type
.1d4b	38		sec				sec  								; write update code.
.1d4c	20 5f 1d	jsr $1d5f			jsr 	GetSetVariable
.1d4f	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; , follows ?
.1d52	c9 2c		cmp #$2c			cmp 	#","
.1d54	d0 05		bne $1d5b			bne 	_CRExit 					; if not, end of READ.
.1d56	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume comma
.1d59	80 d2		bra $1d2d			bra 	_CRLoop 					; keep going
.1d5b					_CRExit:
.1d5b	60		rts				rts
.1d5c					_CRSyntax:
.1d5c	4c 4b 1f	jmp $1f4b		jmp	ErrorV_syntax
.050d					numberPCode:
>050d							.fill 	1
.050e					stringPCode:
>050e							.fill 	1
.1d5f					GetSetVariable:
.1d5f	08		php				php 								; save direction on stack
.1d60	c0 00		cpy #$00			cpy 	#$00
.1d62	30 21		bmi $1d85			bmi 	_GSVReadWriteSpecial
.1d64	c9 00		cmp #$00			cmp 	#$00
.1d66	30 33		bmi $1d9b			bmi 	_GSVArray
.1d68	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1d6a	4a		lsr a				lsr 	a 							; divide by 2
.1d6b	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1d6d	28		plp				plp
.1d6e	90 02		bcc $1d72			bcc 	_GSVNotWrite
.1d70	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1d72					_GSVNotWrite:
.1d72	85 2a		sta $2a				sta 	zTemp0
.1d74	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1d75	4a		lsr a				lsr 	a
.1d76	a8		tay				tay
.1d77	8a		txa				txa
.1d78	6a		ror a				ror 	a
.1d79	aa		tax				tax
.1d7a	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1d7b	05 2a		ora $2a				ora 	zTemp0 						; which is the first byte of the opcode
.1d7d	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1d80	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1d81	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1d84	60		rts				rts
.1d85					_GSVReadWriteSpecial:
.1d85	28		plp				plp
.1d86	b0 10		bcs $1d98			bcs 	_GSVSyntax
.1d88	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1d8a	f0 06		beq $1d92			beq 	_GSVRWString
.1d8c	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1d8e	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1d91	60		rts				rts
.1d92					_GSVRWString:
.1d92	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1d94	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1d97	60		rts				rts
.1d98					_GSVSyntax:
.1d98	4c 4b 1f	jmp $1f4b		jmp	ErrorV_syntax
.1d9b					_GSVArray:
.1d9b	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1d9d	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1d9e	4a		lsr a				lsr 	a
.1d9f	4a		lsr a				lsr 	a
.1da0	4a		lsr a				lsr 	a
.1da1	4a		lsr a				lsr 	a
.1da2	28		plp				plp 								; if writing array then set bit 2.
.1da3	90 02		bcc $1da7			bcc 	_GSVANotWrite
.1da5	09 04		ora #$04			ora 	#4
.1da7					_GSVANotWrite:
.1da7	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1da9	20 fd 10	jsr $10fd			jsr 	WriteCodeByte 				; and write it out
.1dac	60		rts				rts
.1dad					GetReferenceTerm:
.1dad	20 d1 1a	jsr $1ad1			jsr 	ExtractVariableName 		; get name & type info
.1db0	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1db2	30 10		bmi $1dc4			bmi 	_GRTArray
.1db4	da		phx				phx 								; save type on stack
.1db5	20 c6 14	jsr $14c6			jsr 	FindVariable 				; find it
.1db8	b0 06		bcs $1dc0			bcs 	_GRTNoCreate 				; create if required.
.1dba	20 50 12	jsr $1250			jsr 	CreateVariableRecord 		; create a variable.
.1dbd	20 a5 12	jsr $12a5			jsr 	AllocateBytesForType 		; allocate memory for it
.1dc0					_GRTNoCreate:
.1dc0	68		pla				pla 								; get type back, strip out type information.
.1dc1	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1dc3	60		rts				rts
.1dc4					_GRTArray:
.1dc4	da		phx				phx 								; save type information
.1dc5	20 c6 14	jsr $14c6			jsr 	FindVariable 				; read its data, the base address in YX
.1dc8	90 18		bcc $1de2			bcc 	_GRTUndeclared 				; undeclared array.
.1dca	da		phx				phx 								; save base address
.1dcb	5a		phy				phy
.1dcc	20 9c 13	jsr $139c			jsr 	OutputIndexGroup 			; create an index group and generate them
.1dcf	7a		ply				ply 								; get the array base address into YX
.1dd0	fa		plx				plx
.1dd1	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1dd3	18		clc				clc
.1dd4	20 5f 1d	jsr $1d5f			jsr 	GetSetVariable 				; load the address of the array structure.
.1dd7	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1dd9	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1ddc	68		pla				pla 								; and the type data into A
.1ddd	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1ddf	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1de1	60		rts				rts
.1de2					_GRTUndeclared:
.1de2	4c 02 20	jmp $2002		jmp	ErrorV_undeclared
.1de5					CommandREM:
.1de5	20 50 1a	jsr $1a50			jsr 	LookNext
.1de8	f0 05		beq $1def			beq 	_CRExit
.1dea	20 61 1a	jsr $1a61			jsr 	GetNext
.1ded	80 f6		bra $1de5			bra 	CommandREM
.1def					_CRExit:
.1def	60		rts				rts
.1df0					STRReset:
.1df0	ad 07 05	lda $0507			lda	 	compilerStartHigh 			; set up the two table pointers
.1df3	8d 12 05	sta $0512			sta 	variableListEnd+1
.1df6	9c 11 05	stz $0511			stz 	variableListEnd
.1df9	ad 08 05	lda $0508			lda 	compilerEndHigh
.1dfc	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1dff	9c 0f 05	stz $050f			stz 	lineNumberTable
.1e02	ad 11 05	lda $0511			lda 	variableListEnd
.1e05	85 2b		sta $2b				sta 	zTemp0+1
.1e07	64 2a		stz $2a				stz 	zTemp0
.1e09	a9 00		lda #$00			lda 	#0
.1e0b	92 2a		sta ($2a)			sta 	(zTemp0)
.1e0d	a9 00		lda #$00			lda 	#((0) & $FF)
.1e0f	8d 13 05	sta $0513			sta 	0+freeVariableMemory
.1e12	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1e14	8d 14 05	sta $0514			sta 	1+freeVariableMemory
.1e17	60		rts				rts
.050f					lineNumberTable:
>050f							.fill 	2
.0511					variableListEnd:
>0511							.fill 	2
.0513					freeVariableMemory:
>0513							.fill 	2
.1e18					CompileTerm:
.1e18	20 6c 1a	jsr $1a6c			jsr 	GetNextNonSpace 			; get first non space character.
.1e1b	30 72		bmi $1e8f			bmi 	_CTUnaryFunctions
.1e1d	20 76 1a	jsr $1a76			jsr 	CharIsDigit 				; found a number
.1e20	b0 3a		bcs $1e5c			bcs 	_CTDigit
.1e22	c9 2e		cmp #$2e			cmp 	#"."
.1e24	f0 36		beq $1e5c			beq 	_CTDigit
.1e26	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1e28	f0 43		beq $1e6d			beq 	_CTString
.1e2a	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1e2c	f0 28		beq $1e56			beq 	_CTOtherBase
.1e2e	c9 24		cmp #$24			cmp 	#"$"
.1e30	f0 24		beq $1e56			beq 	_CTOtherBase
.1e32	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1e34	f0 17		beq $1e4d			beq 	_CTBrackets
.1e36	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1e38	90 10		bcc $1e4a			bcc 	_CTSyntax
.1e3a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1e3c	b0 0c		bcs $1e4a			bcs 	_CTSyntax
.1e3e	20 ad 1d	jsr $1dad			jsr 	GetReferenceTerm 			; figure out what it is.
.1e41	48		pha				pha 								; save type on stack
.1e42	18		clc				clc 								; read it
.1e43	20 5f 1d	jsr $1d5f			jsr 	GetSetVariable
.1e46	68		pla				pla
.1e47	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1e49	60		rts				rts
.1e4a					_CTSyntax:
.1e4a	4c 4b 1f	jmp $1f4b		jmp	ErrorV_syntax
.1e4d					_CTBrackets:
.1e4d	20 0c 14	jsr $140c			jsr 	CompileExpressionAt0
.1e50	48		pha				pha
.1e51	20 5f 11	jsr $115f			jsr 	CheckNextRParen
.1e54	68		pla				pla
.1e55	60		rts				rts
.1e56					_CTOtherBase:
.1e56	20 ab 10	jsr $10ab			jsr 	InlineNonDecimal 			; non decimal constant handler
.1e59	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e5b	60		rts				rts
.1e5c					_CTDigit:
.1e5c	20 b5 1c	jsr $1cb5			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1e5f	90 06		bcc $1e67			bcc	 	_CTFloat 					; have a float or long int.
.1e61	20 0b 12	jsr $120b			jsr 	PushIntegerYA 				; code to push on stack
.1e64	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e66	60		rts				rts
.1e67					_CTFloat:
.1e67	20 2d 12	jsr $122d			jsr 	PushFloat  					; code to push float
.1e6a	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1e6c	60		rts				rts
.1e6d					_CTString:
.1e6d	20 34 11	jsr $1134			jsr 	BufferClear 				; copy it to the buffer
.1e70					_CTStringLoop:
.1e70	20 50 1a	jsr $1a50			jsr 	LookNext 					; reached EOL/EOS
.1e73	f0 d5		beq $1e4a			beq 	_CTSyntax
.1e75	c9 22		cmp #$22			cmp 	#'"'
.1e77	f0 08		beq $1e81			beq 	_CTStringDone
.1e79	20 38 11	jsr $1138			jsr 	BufferWrite 				; write and consume
.1e7c	20 61 1a	jsr $1a61			jsr 	GetNext
.1e7f	80 ef		bra $1e70			bra 	_CTStringLoop
.1e81					_CTStringDone:
.1e81	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume closing quote.
.1e84	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1e86	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1e89	20 44 11	jsr $1144			jsr 	BufferOutput
.1e8c	a9 40		lda #$40			lda 	#NSSString 					; string type
.1e8e	60		rts				rts
.1e8f					_CTUnaryFunctions:
.1e8f	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1e91	f0 0a		beq $1e9d			beq 	_CTNegation
.1e93	a2 f8		ldx #$f8			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1e95	a0 17		ldy #$17			ldy 	#UnaryTables >> 8
.1e97	20 f2 18	jsr $18f2			jsr 	GeneratorProcess
.1e9a	90 ae		bcc $1e4a			bcc		_CTSyntax
.1e9c	60		rts				rts
.1e9d					_CTNegation:
.1e9d	20 18 1e	jsr $1e18			jsr 	CompileTerm 				; compile a term.
.1ea0	48		pha				pha
.1ea1	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1ea3	c9 00		cmp #$00			cmp 	#NSSIFloat
.1ea5	d0 07		bne $1eae			bne 	_CTType 					; error
.1ea7	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1ea9	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1eac	68		pla				pla 								; return original type.
.1ead	60		rts				rts
.1eae					_CTType:
.1eae	4c 5b 1f	jmp $1f5b		jmp	ErrorV_type
.1eb1					CommandWAIT:
.1eb1	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace
.1eb4	c9 2c		cmp #$2c			cmp 	#","
.1eb6	f0 10		beq $1ec8			beq 	_CWThirdParameter
.1eb8	a9 00		lda #$00			lda 	#0
.1eba	20 1e 12	jsr $121e			jsr 	PushIntegerA
.1ebd					_CWExit:
.1ebd	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1ebf	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1ec2	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1ec4	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1ec7	60		rts				rts
.1ec8					_CWThirdParameter:
.1ec8	20 61 1a	jsr $1a61			jsr 	GetNext
.1ecb	20 0e 14	jsr $140e			jsr 	CompileExpressionAtA
.1ece	29 40		and #$40			and 	#NSSTypeMask
.1ed0	c9 00		cmp #$00			cmp 	#NSSIFloat
.1ed2	f0 e9		beq $1ebd			beq 	_CWExit
.1ed4	4c 5b 1f	jmp $1f5b		jmp	ErrorV_type
.1ed7					CommandCMD:
.1ed7	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.1ed9	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1edc	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; followed by a , ?
.1edf	c9 2c		cmp #$2c			cmp 	#","
.1ee1	d0 06		bne $1ee9			bne 	_CCMDExit
.1ee3	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume comma.
.1ee6	20 da 1c	jsr $1cda			jsr 	CommandPRINT 				; do the print code
.1ee9					_CCMDExit:
.1ee9	60		rts				rts
.1eea					CommandOPEN:
.1eea	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; followed by a , ?
.1eed	c9 2c		cmp #$2c			cmp 	#","
.1eef	d0 15		bne $1f06			bne 	_COTwoDefaults
.1ef1	20 61 1a	jsr $1a61			jsr 	GetNext 					; consume comma
.1ef4	20 0c 14	jsr $140c			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1ef7	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1ef9	f0 1e		beq $1f19			beq 	_COThreeIntegers
.1efb	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1efd	20 1e 12	jsr $121e			jsr 	PushIntegerA
.1f00	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1f02	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1f05	60		rts				rts
.1f06					_COTwoDefaults:
.1f06	a9 00		lda #$00			lda 	#0
.1f08	20 1e 12	jsr $121e			jsr 	PushIntegerA
.1f0b					_COCompileNullString:
.1f0b	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1f0d	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1f10	a9 00		lda #$00			lda 	#0
.1f12	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1f15	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1f18	60		rts				rts
.1f19					_COThreeIntegers:
.1f19	20 53 1a	jsr $1a53			jsr 	LookNextNonSpace 			; is there a ,
.1f1c	c9 2c		cmp #$2c			cmp 	#","
.1f1e	d0 eb		bne $1f0b			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1f20	20 61 1a	jsr $1a61			jsr 	GetNext
.1f23	20 0c 14	jsr $140c			jsr 	CompileExpressionAt0 		; should be a filename
.1f26	29 40		and #$40			and 	#NSSString
.1f28	f0 01		beq $1f2b			beq 	_COType
.1f2a	60		rts				rts
.1f2b					_COType:
.1f2b	4c 5b 1f	jmp $1f5b		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					objPtr:
>0028							.fill 	2
.002a					zTemp0:
>002a							.fill 	2
.002c					zTemp1:
>002c							.fill 	2
.002e					zTemp2:
>002e							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1f2e					ErrorV_range:
.1f2e	20 c4 13	jsr $13c4		jsr	ErrorHandler
>1f31	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f39	41 4e 47 45 00
.1f3e					ErrorV_value:
.1f3e	20 c4 13	jsr $13c4		jsr	ErrorHandler
>1f41	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f49	45 00
.1f4b					ErrorV_syntax:
.1f4b	20 c4 13	jsr $13c4		jsr	ErrorHandler
>1f4e	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f56	52 52 4f 52 00
.1f5b					ErrorV_type:
.1f5b	20 c4 13	jsr $13c4		jsr	ErrorHandler
>1f5e	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f66	4d 41 54 43 48 00
.1f6c					ErrorV_unimplemented:
.1f6c	20 c4 13	jsr $13c4		jsr	ErrorHandler
>1f6f	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f77	45 4d 45 4e 54 45 44 00
.1f7f					ErrorV_assert:
.1f7f	20 c4 13	jsr $13c4		jsr	ErrorHandler
>1f82	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f8a	41 49 4c 00
.1f8e					ErrorV_line:
.1f8e	20 c4 13	jsr $13c4		jsr	ErrorHandler
>1f91	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f99	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1fa5					ErrorV_internal:
.1fa5	20 c4 13	jsr $13c4		jsr	ErrorHandler
>1fa8	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1fb0	20 45 52 52 4f 52 00
.1fb7					ErrorV_divzero:
.1fb7	20 c4 13	jsr $13c4		jsr	ErrorHandler
>1fba	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fc2	59 20 5a 45 52 4f 00
.1fc9					ErrorV_structure:
.1fc9	20 c4 13	jsr $13c4		jsr	ErrorHandler
>1fcc	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fd4	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fe0					ErrorV_stop:
.1fe0	20 c4 13	jsr $13c4		jsr	ErrorHandler
>1fe3	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1feb	53 54 4f 50 50 45 44 00
.1ff3					ErrorV_data:
.1ff3	20 c4 13	jsr $13c4		jsr	ErrorHandler
>1ff6	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1ffe	41 54 41 00
.2002					ErrorV_undeclared:
.2002	20 c4 13	jsr $13c4		jsr	ErrorHandler
>2005	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>200d	41 52 52 41 59 00
.2013					ErrorV_redefine:
.2013	20 c4 13	jsr $13c4		jsr	ErrorHandler
>2016	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>201e	44 45 46 49 4e 45 44 00
.2026					ErrorV_index:
.2026	20 c4 13	jsr $13c4		jsr	ErrorHandler
>2029	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2031	59 20 49 4e 44 45 58 00
.2039					ErrorV_memory:
.2039	20 c4 13	jsr $13c4		jsr	ErrorHandler
>203c	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2044	45 4d 4f 52 59 00
.204a					ErrorV_channel:
.204a	20 c4 13	jsr $13c4		jsr	ErrorHandler
>204d	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2055	54 50 55 54 20 45 52 52 4f 52 00
.2060					MoveObjectForward:
.2060	b2 28		lda ($28)			lda 	(objPtr) 					; get next
.2062	c9 ff		cmp #$ff			cmp 	#$FF
.2064	f0 36		beq $209c			beq 	_MOFEnd
.2066	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.2068	90 24		bcc $208e			bcc 	_MOFAdvance1 				; forward 1
.206a	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.206c	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.206e	90 20		bcc $2090			bcc 	_MOFAdvanceY
.2070	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2072	90 1a		bcc $208e			bcc 	_MOFAdvance1 				; forward 1
.2074	a8		tay				tay 								; read the size.
.2075	b9 da 1f	lda $1fda,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.2078	a8		tay				tay
.2079	c8		iny				iny 								; add 1 for the system token.
.207a	d0 14		bne $2090			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.207c	a0 01		ldy #$01			ldy 	#1 							; get length byte
.207e	b1 28		lda ($28),y			lda 	(objPtr),y
.2080	a8		tay				tay 								; into Y.
.2081	18		clc				clc
.2082	a5 28		lda $28				lda 	objPtr						; add 2 to the object pointer
.2084	69 02		adc #$02			adc 	#2
.2086	85 28		sta $28				sta 	objPtr
.2088	90 02		bcc $208c			bcc 	_MOFNoCarry1
.208a	e6 29		inc $29				inc 	objPtr+1
.208c					_MOFNoCarry1:
.208c	80 02		bra $2090			bra 	_MOFAdvanceY
.208e					_MOFAdvance1:
.208e	a0 01		ldy #$01			ldy 	#1
.2090					_MOFAdvanceY:
.2090	98		tya				tya 								; add Y to objPtr
.2091	18		clc				clc
.2092	65 28		adc $28				adc 	objPtr
.2094	85 28		sta $28				sta 	objPtr
.2096	90 02		bcc $209a			bcc 	_MOFNoCarry2
.2098	e6 29		inc $29				inc 	objPtr+1
.209a					_MOFNoCarry2:
.209a	18		clc				clc 								; not completed.
.209b	60		rts				rts
.209c					_MOFEnd:
.209c	e6 28		inc $28				inc 	objPtr
.209e	d0 02		bne $20a2			bne 	_MOFENoCarry
.20a0	e6 29		inc $29				inc 	objPtr+1
.20a2					_MOFENoCarry:
.20a2	38		sec				sec
.20a3	60		rts				rts
.20a4					MOFSizeTable:
>20a4	01					.byte	1         	; $ca .shift
>20a5	01					.byte	1         	; $cb .byte
>20a6	02					.byte	2         	; $cc .word
>20a7	05					.byte	5         	; $cd .float
>20a8	ff					.byte	255       	; $ce .string
>20a9	ff					.byte	255       	; $cf .data
>20aa	02					.byte	2         	; $d0 .goto
>20ab	02					.byte	2         	; $d1 .gosub
>20ac	02					.byte	2         	; $d2 .goto.z
>20ad	02					.byte	2         	; $d3 .goto.nz
>20ae	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0030					NSStatus:
>0030							.fill 	MathStackSize
.003c					NSMantissa0:
>003c							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0048					NSMantissa1:
>0048							.fill 	MathStackSize
.0054					NSMantissa2:
>0054							.fill 	MathStackSize
.0060					NSMantissa3:
>0060							.fill 	MathStackSize
.006c					NSExponent:
>006c							.fill 	MathStackSize
.0515					numberBuffer:
>0515							.fill 	34
.20af					FloatSubtract:
.20af	b5 30		lda $30,x			lda 	NSStatus,x 					; negate top of stack
.20b1	49 80		eor #$80			eor 	#$80
.20b3	95 30		sta $30,x			sta 	NSStatus,x					; and fall through.
.20b5					FloatAdd:
.20b5	ca		dex				dex
.20b6	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised.
.20b8	15 6d		ora $6d,x			ora 	NSExponent+1,x
.20ba	15 60		ora $60,x			ora 	NSMantissa3,x
.20bc	15 61		ora $61,x			ora 	NSMantissa3+1,x
.20be	d0 04		bne $20c4			bne 	_FAUseFloat
.20c0	20 51 24	jsr $2451			jsr 	FloatInt32Add 				; use the int32 one.
.20c3	60		rts				rts
.20c4					_FAUseFloat:
.20c4	20 e6 23	jsr $23e6			jsr 	FloatNormalise 				; normalise S[X]
.20c7	f0 51		beq $211a			beq 	_FAReturn1
.20c9	e8		inx				inx 								; normalise S[X+1]
.20ca	20 e6 23	jsr $23e6			jsr 	FloatNormalise
.20cd	ca		dex				dex
.20ce	c9 00		cmp #$00			cmp 	#0
.20d0	f0 60		beq $2132			beq 	_FAExit 					; if so, just return A
.20d2	b5 6c		lda $6c,x			lda 	NSExponent,x 				; are the exponents the same ?
.20d4	d5 6d		cmp $6d,x			cmp 	NSExponent+1,x
.20d6	f0 18		beq $20f0			beq 	_FAExponentsEqual
.20d8	b5 6c		lda $6c,x			lda 	NSExponent,x 				; work out the larger exponent
.20da	a8		tay				tay
.20db	38		sec				sec 								; do a signed comparison of the exponents.
.20dc	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.20de	50 02		bvc $20e2			bvc 	_FANoSignedChange
.20e0	49 80		eor #$80			eor 	#$80
.20e2					_FANoSignedChange:
.20e2	29 80		and #$80			and 	#$80
.20e4	10 02		bpl $20e8			bpl 	_FAHaveMax
.20e6	b4 6d		ldy $6d,x			ldy 	NSExponent+1,x
.20e8					_FAHaveMax:
.20e8	20 33 21	jsr $2133			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20eb	e8		inx				inx
.20ec	20 33 21	jsr $2133			jsr 	_FAShiftToExponent
.20ef	ca		dex				dex
.20f0					_FAExponentsEqual:
.20f0	b5 30		lda $30,x			lda 	NSStatus,x 					; are the signs the same
.20f2	55 31		eor $31,x			eor 	NSStatus+1,x
.20f4	30 0e		bmi $2104			bmi 	_FADifferentSigns
.20f6	20 1d 24	jsr $241d			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20f9	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20fb	10 35		bpl $2132			bpl 	_FAExit 					; if no, we are done.
.20fd	20 aa 26	jsr $26aa			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.2100	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump the exponent and exit
.2102	80 2e		bra $2132			bra 	_FAExit
.2104					_FADifferentSigns:
.2104	20 37 24	jsr $2437			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.2107	b5 60		lda $60,x			lda 	NSMantissa3,x 				; is the result negative ?
.2109	10 06		bpl $2111			bpl 	_FACheckZero 				; if no, check for -0
.210b	20 53 26	jsr $2653			jsr 	FloatNegate 					; netate result
.210e	20 5a 26	jsr $265a			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.2111					_FACheckZero:
.2111	20 b3 26	jsr $26b3			jsr 	FloatIsZero	 				; check for -0
.2114	d0 1c		bne $2132			bne 	_FAExit
.2116	74 30		stz $30,x			stz 	NSStatus,x
.2118	80 18		bra $2132			bra 	_FAExit
.211a					_FAReturn1:
.211a	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.211c	95 3c		sta $3c,x			sta 	NSMantissa0,x
.211e	b5 49		lda $49,x			lda 	NSMantissa1+1,x
.2120	95 48		sta $48,x			sta 	NSMantissa1,x
.2122	b5 55		lda $55,x			lda 	NSMantissa2+1,x
.2124	95 54		sta $54,x			sta 	NSMantissa2,x
.2126	b5 61		lda $61,x			lda 	NSMantissa3+1,x
.2128	95 60		sta $60,x			sta 	NSMantissa3,x
.212a	b5 6d		lda $6d,x			lda 	NSExponent+1,x
.212c	95 6c		sta $6c,x			sta 	NSExponent,x
.212e	b5 31		lda $31,x			lda 	NSStatus+1,x
.2130	95 30		sta $30,x			sta 	NSStatus,x
.2132					_FAExit:
.2132	60		rts				rts
.2133					_FAShiftToExponent:
.2133					_FAShiftToExponent2:
.2133	98		tya				tya 								; compare Y to exponent
.2134	d5 6c		cmp $6c,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2136	f0 07		beq $213f			beq 	_FASEExit 					; exit if so.
.2138	20 aa 26	jsr $26aa			jsr 	FloatShiftRight	 			; shift the mantissa right
.213b	f6 6c		inc $6c,x			inc 	NSExponent,x 				; increment exponent
.213d	80 f4		bra $2133			bra 	_FAShiftToExponent2
.213f					_FASEExit:
.213f	60		rts				rts
.2140					CompareEqual:
.2140	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2142	d0 09		bne $214d			bne 	ReturnFalse
.2144					ReturnTrue:
.2144	a9 01		lda #$01			lda 	#1
.2146	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2148	a9 80		lda #$80			lda 	#$80
.214a	95 30		sta $30,x			sta 	NSStatus,x
.214c	60		rts				rts
.214d					ReturnFalse:
.214d	74 3c		stz $3c,x			stz 	NSMantissa0,x
.214f	60		rts				rts
.2150					CompareNotEqual:
.2150	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2152	d0 f0		bne $2144			bne 	ReturnTrue
.2154	80 f7		bra $214d			bra 	ReturnFalse
.2156					CompareLess:
.2156	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2158	c9 ff		cmp #$ff			cmp 	#$FF
.215a	f0 e8		beq $2144			beq 	ReturnTrue
.215c	80 ef		bra $214d			bra 	ReturnFalse
.215e					CompareGreater:
.215e	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2160	c9 01		cmp #$01			cmp 	#$01
.2162	f0 e0		beq $2144			beq 	ReturnTrue
.2164	80 e7		bra $214d			bra 	ReturnFalse
.2166					CompareLessEqual:
.2166	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2168	c9 01		cmp #$01			cmp 	#$01
.216a	d0 d8		bne $2144			bne 	ReturnTrue
.216c	80 df		bra $214d			bra 	ReturnFalse
.216e					CompareGreaterEqual:
.216e	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2170	c9 ff		cmp #$ff			cmp 	#$FF
.2172	d0 d0		bne $2144			bne 	ReturnTrue
.2174	80 d7		bra $214d			bra 	ReturnFalse
.2176					FloatCompare:
.2176	b5 6c		lda $6c,x			lda 	NSExponent,x 				; float comparison.
.2178	15 6b		ora $6b,x			ora 	NSExponent-1,x 				; integer if both integer.
.217a	48		pha				pha
.217b	20 af 20	jsr $20af			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.217e	68		pla				pla
.217f	d0 0c		bne $218d			bne 	_FCCompareFloat
.2181	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2183	15 48		ora $48,x			ora 	NSMantissa1,x
.2185	15 54		ora $54,x			ora 	NSMantissa2,x
.2187	15 60		ora $60,x			ora 	NSMantissa3,x
.2189	f0 14		beq $219f			beq 	_FCExit 					; if zero, return zero
.218b	80 0a		bra $2197			bra 	_FCSign
.218d					_FCCompareFloat:
.218d	b5 48		lda $48,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.218f	29 f0		and #$f0			and 	#$F0
.2191	15 54		ora $54,x			ora 	NSMantissa2,x
.2193	15 60		ora $60,x			ora 	NSMantissa3,x
.2195	f0 08		beq $219f			beq 	_FCExit 					; zero, so approximately identical
.2197					_FCSign:
.2197	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2199	34 30		bit $30,x			bit 	NSStatus,x
.219b	10 02		bpl $219f			bpl 	_FCExit
.219d					_FCNegative:
.219d	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.219f					_FCExit:
.219f	20 93 26	jsr $2693			jsr 	FloatSetByte 				; set the result 255,0,1
.21a2	60		rts				rts
.21a3					FloatScalarTable:
>21a3	66 66 66 66				.dword $66666666 ; 0.1
>21a7	de					.byte $de
>21a8	1f 85 eb 51				.dword $51eb851f ; 0.01
>21ac	db					.byte $db
>21ad	4c 37 89 41				.dword $4189374c ; 0.001
>21b1	d8					.byte $d8
>21b2	ac 8b db 68				.dword $68db8bac ; 0.0001
>21b6	d4					.byte $d4
>21b7	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>21bb	d1					.byte $d1
>21bc	83 de 1b 43				.dword $431bde83 ; 1e-06
>21c0	ce					.byte $ce
>21c1	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21c5	ca					.byte $ca
>21c6	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21ca	c7					.byte $c7
>21cb	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21cf	c4					.byte $c4
>21d0	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21d4	c0					.byte $c0
>21d5	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21d9	bd					.byte $bd
.21da					FloatDivide:
.21da	48		pha				pha
.21db	20 e6 23	jsr $23e6			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21de	ca		dex				dex
.21df	c9 00		cmp #$00			cmp 	#0
.21e1	f0 1e		beq $2201			beq 	_FDZero
.21e3	20 e6 23	jsr $23e6			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21e6	f0 16		beq $21fe			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21e8	20 49 22	jsr $2249			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21eb	20 16 22	jsr $2216			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21ee	20 e6 23	jsr $23e6			jsr		FloatNormalise 				; renormalise
.21f1	20 dc 23	jsr $23dc			jsr 	FloatCalculateSign 			; calculate result sign
.21f4	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent
.21f6	38		sec				sec
.21f7	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.21f9	38		sec				sec
.21fa	e9 1e		sbc #$1e			sbc 	#30
.21fc	95 6c		sta $6c,x			sta 	NSExponent,x
.21fe					_FDExit:
.21fe	68		pla				pla
.21ff	18		clc				clc
.2200	60		rts				rts
.2201					_FDZero:
.2201	68		pla				pla
.2202	38		sec				sec
.2203	60		rts				rts
.2204					DivideInt32:
.2204	20 cc 22	jsr $22cc			jsr 	FloatIntegerPart 			; make both integers
.2207	ca		dex				dex
.2208	20 cc 22	jsr $22cc			jsr 	FloatIntegerPart
.220b	20 27 22	jsr $2227			jsr 	Int32Divide 				; divide
.220e	20 16 22	jsr $2216			jsr 	NSMCopyPlusTwoToZero 		; copy result
.2211	20 dc 23	jsr $23dc			jsr 	FloatCalculateSign 			; calculate result sign
.2214	18		clc				clc
.2215	60		rts				rts
.2216					NSMCopyPlusTwoToZero:
.2216	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.2218	95 3c		sta $3c,x			sta 	NSMantissa0,x
.221a	b5 4a		lda $4a,x			lda 	NSMantissa1+2,x
.221c	95 48		sta $48,x			sta 	NSMantissa1,x
.221e	b5 56		lda $56,x			lda 	NSMantissa2+2,x
.2220	95 54		sta $54,x			sta 	NSMantissa2,x
.2222	b5 62		lda $62,x			lda 	NSMantissa3+2,x
.2224	95 60		sta $60,x			sta 	NSMantissa3,x
.2226	60		rts				rts
.2227					Int32Divide:
.2227	48		pha				pha 								; save AXY
.2228	5a		phy				phy
.2229	20 74 26	jsr $2674			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.222c	20 8d 26	jsr $268d			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.222f	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2231					_I32DivideLoop:
.2231	e8		inx				inx
.2232	e8		inx				inx
.2233	20 a0 26	jsr $26a0			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2236	ca		dex				dex
.2237	ca		dex				dex
.2238	20 a1 26	jsr $26a1			jsr 	FloatRotateLeft
.223b	20 67 22	jsr $2267			jsr 	FloatDivideCheck 			; check if subtract possible
.223e	90 02		bcc $2242			bcc 	_I32DivideNoCarryIn
.2240	f6 3e		inc $3e,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2242					_I32DivideNoCarryIn:
.2242	88		dey				dey 								; loop round till division completed.
.2243	d0 ec		bne $2231			bne 	_I32DivideLoop
.2245	7a		ply				ply 								; restore AXY and exit
.2246	68		pla				pla
.2247	18		clc				clc
.2248	60		rts				rts
.2249					Int32ShiftDivide:
.2249	48		pha				pha 								; save AY
.224a	5a		phy				phy
.224b	e8		inx				inx 								; clear S[X+2]
.224c	e8		inx				inx
.224d	20 91 26	jsr $2691			jsr 	FloatSetZero
.2250	ca		dex				dex
.2251	ca		dex				dex
.2252	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2254					_I32SDLoop:
.2254	20 67 22	jsr $2267			jsr 	FloatDivideCheck 			; check if subtract possible
.2257	e8		inx				inx
.2258	e8		inx				inx
.2259	20 a1 26	jsr $26a1			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.225c	ca		dex				dex
.225d	ca		dex				dex
.225e	20 a1 26	jsr $26a1			jsr 	FloatRotateLeft
.2261	88		dey				dey 	 							; do 31 times
.2262	d0 f0		bne $2254			bne 	_I32SDLoop
.2264	7a		ply				ply 								; restore AY and exit
.2265	68		pla				pla
.2266	60		rts				rts
.2267					FloatDivideCheck:
.2267	20 37 24	jsr $2437			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.226a	b0 04		bcs $2270			bcs 	_DCSExit 					; if carry set, then could do, exit
.226c	20 1d 24	jsr $241d			jsr 	FloatAddTopTwoStack 		; add it back in
.226f	18		clc				clc 								; and return False
.2270					_DCSExit:
.2270	60		rts				rts
.2271					FloatFractionalPart:
.2271	5a		phy				phy
.2272	b5 30		lda $30,x			lda 	NSStatus,x 					; take absolute value
.2274	29 7f		and #$7f			and 	#$7F
.2276	95 30		sta $30,x			sta 	NSStatus,x
.2278	20 e6 23	jsr $23e6			jsr 	FloatNormalise
.227b	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.227d	38		sec				sec
.227e	e9 e0		sbc #$e0			sbc 	#$E0
.2280	90 29		bcc $22ab			bcc 	_FFPExit 					; already fractional
.2282	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2284	b0 22		bcs $22a8			bcs 	_FFPZero
.2286	a8		tay				tay 								; put count to do in Y
.2287	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do each in turn.
.2289	20 b0 22	jsr $22b0			jsr 	_FFPPartial
.228c	95 60		sta $60,x			sta 	NSMantissa3,x
.228e	b5 54		lda $54,x			lda 	NSMantissa2,x
.2290	20 b0 22	jsr $22b0			jsr 	_FFPPartial
.2293	95 54		sta $54,x			sta 	NSMantissa2,x
.2295	b5 48		lda $48,x			lda 	NSMantissa1,x
.2297	20 b0 22	jsr $22b0			jsr 	_FFPPartial
.229a	95 48		sta $48,x			sta 	NSMantissa1,x
.229c	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.229e	20 b0 22	jsr $22b0			jsr 	_FFPPartial
.22a1	95 3c		sta $3c,x			sta 	NSMantissa0,x
.22a3	20 b3 26	jsr $26b3			jsr 	FloatIsZero 					; zeroed check.
.22a6	d0 03		bne $22ab			bne 	_FFPExit
.22a8					_FFPZero:
.22a8	20 91 26	jsr $2691			jsr 	FloatSetZero
.22ab					_FFPExit:
.22ab	20 e6 23	jsr $23e6			jsr 	FloatNormalise
.22ae	7a		ply				ply
.22af	60		rts				rts
.22b0					_FFPPartial:
.22b0	c0 00		cpy #$00			cpy 	#0 							; no more to do
.22b2	f0 17		beq $22cb			beq 	_FFFPPExit
.22b4	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.22b6	b0 0c		bcs $22c4			bcs 	_FFFPPWholeByte
.22b8	5a		phy				phy
.22b9					_FFFPPLeft:
.22b9	0a		asl a				asl 	a
.22ba	88		dey				dey
.22bb	d0 fc		bne $22b9			bne 	_FFFPPLeft
.22bd	7a		ply				ply
.22be					_FFFPPRight:
.22be	4a		lsr a				lsr 	a
.22bf	88		dey				dey
.22c0	d0 fc		bne $22be			bne 	_FFFPPRight
.22c2	80 07		bra $22cb			bra 	_FFFPPExit
.22c4					_FFFPPWholeByte:
.22c4	98		tya				tya 								; subtract 8 from count
.22c5	38		sec				sec
.22c6	e9 08		sbc #$08			sbc 	#8
.22c8	a8		tay				tay
.22c9	a9 00		lda #$00			lda 	#0 							; and clear all
.22cb					_FFFPPExit:
.22cb	60		rts				rts
.22cc					FloatIntegerPart:
.22cc	48		pha				pha
.22cd	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.22cf	f0 1d		beq $22ee			beq 	_FIPExit 					; if so do nothing
.22d1	20 b3 26	jsr $26b3			jsr 	FloatIsZero 				; is it zero ?
.22d4	f0 15		beq $22eb			beq 	_FIPZero 					; if so return zero.
.22d6	20 e6 23	jsr $23e6			jsr 	FloatNormalise 				; normalise
.22d9	f0 10		beq $22eb			beq 	_FIPZero 					; normalised to zero, exit zero
.22db					_FIPShift:
.22db	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22dd	10 07		bpl $22e6			bpl 	_FIPCheckZero
.22df	20 aa 26	jsr $26aa			jsr 	FloatShiftRight 			; shift mantissa right
.22e2	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.22e4	80 f5		bra $22db			bra 	_FIPShift
.22e6					_FIPCheckZero:
.22e6	20 b3 26	jsr $26b3			jsr 	FloatIsZero 				; avoid -0 problem
.22e9	d0 03		bne $22ee			bne 	_FIPExit 					; set to zero if mantissa zero.
.22eb					_FIPZero:
.22eb	20 91 26	jsr $2691			jsr 	FloatSetZero
.22ee					_FIPExit:
.22ee	68		pla				pla
.22ef	60		rts				rts
.22f0					FloatIntegerPartDown:
.22f0	48		pha				pha
.22f1	5a		phy				phy
.22f2	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.22f4	f0 36		beq $232c			beq 	_FIPExit 					; if so do nothing
.22f6	20 b3 26	jsr $26b3			jsr 	FloatIsZero 				; is it zero ?
.22f9	f0 2e		beq $2329			beq 	_FIPZero 					; if so return zero.
.22fb	20 e6 23	jsr $23e6			jsr 	FloatNormalise 				; normalise
.22fe	f0 29		beq $2329			beq 	_FIPZero 					; normalised to zero, exit zero
.2300	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.2302					_FIPShift:
.2302	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2304	10 0a		bpl $2310			bpl 	_FIPCheckDown
.2306	20 aa 26	jsr $26aa			jsr 	FloatShiftRight 			; shift mantissa right
.2309	90 01		bcc $230c			bcc 	_FIPNoFrac 					; shifted a zero out ?
.230b	c8		iny				iny
.230c					_FIPNoFrac:
.230c	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.230e	80 f2		bra $2302			bra 	_FIPShift
.2310					_FIPCheckDown:
.2310	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.2312	f0 10		beq $2324			beq 	_FIPCheckZero
.2314	34 30		bit $30,x			bit 	NSStatus,x 					; +ve
.2316	10 0c		bpl $2324			bpl 	_FIPCheckZero
.2318	e8		inx				inx 								; -ve so round *down*.
.2319	a9 01		lda #$01			lda 	#1
.231b	20 93 26	jsr $2693			jsr 	FloatSetByte
.231e	20 53 26	jsr $2653			jsr 	FloatNegate
.2321	20 b5 20	jsr $20b5			jsr 	FloatAdd
.2324					_FIPCheckZero:
.2324	20 b3 26	jsr $26b3			jsr 	FloatIsZero 				; avoid -0 problem
.2327	d0 03		bne $232c			bne 	_FIPExit 					; set to zero if mantissa zero.
.2329					_FIPZero:
.2329	20 91 26	jsr $2691			jsr 	FloatSetZero
.232c					_FIPExit:
.232c	7a		ply				ply
.232d	68		pla				pla
.232e	60		rts				rts
.232f					FloatInt8Multiply:
.232f	5a		phy				phy
.2330	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2332	a8		tay				tay
.2333	74 3c		stz $3c,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2335					_FI8MLoop:
.2335	98		tya				tya 								; shift right shifter right into carry
.2336	4a		lsr a				lsr 	a
.2337	a8		tay				tay
.2338	90 0d		bcc $2347			bcc 	_FI8MNoAdd
.233a	18		clc				clc
.233b	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.233d	75 3d		adc $3d,x			adc 	NSMantissa0+1,x
.233f	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2341	b5 48		lda $48,x			lda 	NSMantissa1,x
.2343	75 49		adc $49,x			adc 	NSMantissa1+1,x
.2345	95 48		sta $48,x			sta 	NSMantissa1,x
.2347					_FI8MNoAdd:
.2347	16 3d		asl $3d,x			asl 	NSMantissa0+1,x 			; shift adder left
.2349	36 49		rol $49,x			rol 	NSMantissa1+1,x
.234b	c0 00		cpy #$00			cpy 	#0
.234d	d0 e6		bne $2335			bne 	_FI8MLoop 					; until right shifter zero.
.234f	7a		ply				ply
.2350	60		rts				rts
.2351					FloatMultiply:
.2351	ca		dex				dex
.2352	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised ?
.2354	15 6d		ora $6d,x			ora 	NSExponent+1,x
.2356	15 60		ora $60,x			ora 	NSMantissa3,x
.2358	15 61		ora $61,x			ora 	NSMantissa3+1,x
.235a	d0 21		bne $237d			bne 	_FMUseFloat
.235c	b5 30		lda $30,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.235e	15 31		ora $31,x			ora 	NSStatus+1,x
.2360	29 80		and #$80			and 	#$80
.2362	15 60		ora $60,x			ora 	NSMantissa3,x
.2364	15 54		ora $54,x			ora 	NSMantissa2,x
.2366	15 48		ora $48,x			ora 	NSMantissa1,x
.2368	15 61		ora $61,x			ora 	NSMantissa3+1,x
.236a	15 55		ora $55,x			ora 	NSMantissa2+1,x
.236c	15 49		ora $49,x			ora 	NSMantissa1+1,x
.236e	d0 04		bne $2374			bne 	_FMInt32
.2370	20 2f 23	jsr $232f			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2373	60		rts				rts
.2374					_FMInt32:
.2374	20 9e 23	jsr $239e			jsr 	FloatMultiplyShort			; use the int32 one.
.2377	18		clc				clc 								; fix it up if gone out of range
.2378	75 6c		adc $6c,x			adc 	NSExponent,x
.237a	95 6c		sta $6c,x			sta 	NSExponent,x
.237c	60		rts				rts
.237d					_FMUseFloat:
.237d	20 e6 23	jsr $23e6			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2380	f0 18		beq $239a			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2382	e8		inx				inx
.2383	20 e6 23	jsr $23e6			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2386	ca		dex				dex
.2387	c9 00		cmp #$00			cmp 	#0
.2389	f0 0c		beq $2397			beq 	_FDSetZero
.238b	20 9e 23	jsr $239e			jsr 	FloatMultiplyShort 			; calculate the result.
.238e	75 6c		adc $6c,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2390	18		clc				clc
.2391	75 6d		adc $6d,x			adc 	NSExponent+1,x
.2393	95 6c		sta $6c,x			sta 	NSExponent,x
.2395	80 03		bra $239a			bra 	_FDExit
.2397					_FDSetZero:
.2397	20 91 26	jsr $2691			jsr 	FloatSetZero 				; return 0
.239a					_FDExit:
.239a	20 e6 23	jsr $23e6			jsr 	FloatNormalise 				; normalise the result
.239d	60		rts				rts
.239e					FloatMultiplyShort:
.239e	5a		phy				phy 								; save Y
.239f	20 74 26	jsr $2674			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.23a2	20 8d 26	jsr $268d			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.23a5	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.23a7					_I32MLoop:
.23a7	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.23a9	15 4a		ora $4a,x			ora 	NSMantissa1+2,x
.23ab	15 56		ora $56,x			ora 	NSMantissa2+2,x
.23ad	15 62		ora $62,x			ora 	NSMantissa3+2,x
.23af	f0 25		beq $23d6			beq 	_I32MExit 					; exit if zero
.23b1	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.23b3	29 01		and #$01			and 	#1
.23b5	f0 0d		beq $23c4			beq 	_I32MNoAdd
.23b7	20 1d 24	jsr $241d			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.23ba	b5 60		lda $60,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.23bc	10 06		bpl $23c4			bpl 	_I32MNoAdd
.23be					_I32ShiftRight:
.23be	20 aa 26	jsr $26aa			jsr 	FloatShiftRight 			; shift S[X] right
.23c1	c8		iny				iny 								; increment shift count
.23c2	80 09		bra $23cd			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23c4					_I32MNoAdd:
.23c4	34 61		bit $61,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23c6	70 f6		bvs $23be			bvs 	_I32ShiftRight 				; instead.
.23c8	e8		inx				inx
.23c9	20 a0 26	jsr $26a0			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23cc	ca		dex				dex
.23cd					_I32MShiftUpper:
.23cd	e8		inx				inx 								; shift S[X+2] right
.23ce	e8		inx				inx
.23cf	20 aa 26	jsr $26aa			jsr 	FloatShiftRight
.23d2	ca		dex				dex
.23d3	ca		dex				dex
.23d4	80 d1		bra $23a7			bra 	_I32MLoop 					; try again.
.23d6					_I32MExit:
.23d6	20 dc 23	jsr $23dc			jsr 	FloatCalculateSign
.23d9	98		tya				tya 								; shift in A
.23da	7a		ply				ply 								; restore Y and exit
.23db	60		rts				rts
.23dc					FloatCalculateSign:
.23dc	b5 30		lda $30,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23de	16 30		asl $30,x			asl 	NSStatus,x 					; shift result left
.23e0	55 31		eor $31,x			eor 	NSStatus+1,x
.23e2	0a		asl a				asl 	a 							; shift bit 7 into carry
.23e3	76 30		ror $30,x			ror 	NSStatus,x 					; shift right into status byte.
.23e5	60		rts				rts
.23e6					FloatNormalise:
.23e6	20 b3 26	jsr $26b3			jsr 	FloatIsZero 				; if zero exit
.23e9	d0 07		bne $23f2			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23eb	16 30		asl $30,x			asl 	NSStatus,x 					; clear the sign bit.
.23ed	76 30		ror $30,x			ror 	NSStatus,x 					; (no -0)
.23ef	a9 00		lda #$00			lda 	#0 							; set Z flag
.23f1	60		rts				rts
.23f2					_NSNormaliseOptimise:
.23f2	b5 60		lda $60,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23f4	d0 19		bne $240f			bne 	_NSNormaliseLoop
.23f6	b5 54		lda $54,x			lda 	NSMantissa2,x 				; byte normalise
.23f8	30 15		bmi $240f			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23fa	95 60		sta $60,x			sta 	NSMantissa3,x
.23fc	b5 48		lda $48,x			lda 	NSMantissa1,x
.23fe	95 54		sta $54,x			sta 	NSMantissa2,x
.2400	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2402	95 48		sta $48,x			sta 	NSMantissa1,x
.2404	74 3c		stz $3c,x			stz 	NSMantissa0,x
.2406	b5 6c		lda $6c,x			lda 	NSExponent,x
.2408	38		sec				sec
.2409	e9 08		sbc #$08			sbc 	#8
.240b	95 6c		sta $6c,x			sta 	NSExponent,x
.240d	80 e3		bra $23f2			bra 	_NSNormaliseOptimise
.240f					_NSNormaliseLoop:
.240f	34 60		bit $60,x			bit 	NSMantissa3,x 				; bit 30 set ?
.2411	70 07		bvs $241a			bvs 	_NSNExit 					; exit if so with Z flag clear
.2413	20 a0 26	jsr $26a0			jsr 	FloatShiftLeft 				; shift mantissa left
.2416	d6 6c		dec $6c,x			dec 	NSExponent,x 				; adjust exponent
.2418	80 f5		bra $240f			bra 	_NSNormaliseLoop
.241a					_NSNExit:
.241a	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.241c	60		rts				rts
.241d					FloatAddTopTwoStack:
.241d	18		clc				clc
.241e	b5 3c		lda $3c,x			lda		NSMantissa0,x
.2420	75 3d		adc $3d,x			adc 		NSMantissa0+1,x
.2422	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2424	b5 48		lda $48,x			lda		NSMantissa1,x
.2426	75 49		adc $49,x			adc 		NSMantissa1+1,x
.2428	95 48		sta $48,x			sta 	NSMantissa1,x
.242a	b5 54		lda $54,x			lda		NSMantissa2,x
.242c	75 55		adc $55,x			adc 		NSMantissa2+1,x
.242e	95 54		sta $54,x			sta 	NSMantissa2,x
.2430	b5 60		lda $60,x			lda		NSMantissa3,x
.2432	75 61		adc $61,x			adc 		NSMantissa3+1,x
.2434	95 60		sta $60,x			sta 	NSMantissa3,x
.2436	60		rts				rts
.2437					FloatSubTopTwoStack:
.2437	38		sec				sec
.2438	b5 3c		lda $3c,x			lda		NSMantissa0,x
.243a	f5 3d		sbc $3d,x			sbc 		NSMantissa0+1,x
.243c	95 3c		sta $3c,x			sta 	NSMantissa0,x
.243e	b5 48		lda $48,x			lda		NSMantissa1,x
.2440	f5 49		sbc $49,x			sbc 		NSMantissa1+1,x
.2442	95 48		sta $48,x			sta 	NSMantissa1,x
.2444	b5 54		lda $54,x			lda		NSMantissa2,x
.2446	f5 55		sbc $55,x			sbc 		NSMantissa2+1,x
.2448	95 54		sta $54,x			sta 	NSMantissa2,x
.244a	b5 60		lda $60,x			lda		NSMantissa3,x
.244c	f5 61		sbc $61,x			sbc 		NSMantissa3+1,x
.244e	95 60		sta $60,x			sta 	NSMantissa3,x
.2450	60		rts				rts
.2451					FloatInt32Add:
.2451	b5 30		lda $30,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2453	55 31		eor $31,x			eor 	NSStatus+1,x
.2455	30 04		bmi $245b			bmi 	_DiffSigns
.2457	20 1d 24	jsr $241d			jsr		FloatAddTopTwoStack
.245a	60		rts				rts
.245b					_DiffSigns:
.245b	20 37 24	jsr $2437			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.245e	34 60		bit $60,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2460	10 07		bpl $2469			bpl 	_AddExit
.2462	b5 31		lda $31,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2464	95 30		sta $30,x			sta 	NSStatus,x
.2466	20 5a 26	jsr $265a			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2469					_AddExit:
.2469	20 b3 26	jsr $26b3			jsr 	FloatIsZero 				; check for -0
.246c	d0 02		bne $2470			bne 	_AddNonZero
.246e	74 30		stz $30,x			stz 	NSStatus,x
.2470					_AddNonZero:
.2470	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2471					FloatEncodeStart:
.2471	38		sec				sec
.2472	80 01		bra $2475			bra 	FloatEncodeContinue+1
.2474					FloatEncodeContinue:
.2474	18		clc				clc
.2475					FloatEncode:
.2475	08		php				php 								; save reset flag.
.2476	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2478	f0 15		beq $248f			beq 	_ENIsOkay
.247a	c9 30		cmp #$30			cmp 	#"0"
.247c	90 04		bcc $2482			bcc 	_ENBadNumber
.247e	c9 3a		cmp #$3a			cmp 	#"9"+1
.2480	90 0d		bcc $248f			bcc 	_ENIsOkay
.2482					_ENBadNumber:
.2482	28		plp				plp 								; throw saved reset
.2483	ad 37 05	lda $0537			lda 	encodeState 				; if in decimal mode, construct final number
.2486	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2488	d0 03		bne $248d			bne 	_ENFail
.248a	4c 07 25	jmp $2507			jmp 	_ENConstructFinal
.248d					_ENFail:
.248d	18		clc				clc 								; not allowed
.248e	60		rts				rts
.248f					_ENIsOkay:
.248f	28		plp				plp 								; are we restarting
.2490	90 15		bcc $24a7			bcc 	_ENNoRestart
.2492					_ENStartEncode:
.2492	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2494	f0 0c		beq $24a2			beq 	_ENFirstDP
.2496	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2498	20 93 26	jsr $2693			jsr 	FloatSetByte 				; in single byte mode.
.249b	a9 01		lda #$01			lda 	#ESTA_Low
.249d					_ENExitChange:
.249d	8d 37 05	sta $0537			sta 	encodeState 				; save new state
.24a0	38		sec				sec
.24a1	60		rts				rts
.24a2					_ENFirstDP:
.24a2	20 91 26	jsr $2691			jsr 	FloatSetZero 				; clear integer part
.24a5	80 3c		bra $24e3			bra 	_ESTASwitchFloat			; go straight to float and exi
.24a7					_ENNoRestart:
.24a7	48		pha				pha 								; save digit or DP on stack.
.24a8	ad 37 05	lda $0537			lda 	encodeState 				; get current state
.24ab	c9 01		cmp #$01			cmp 	#ESTA_Low
.24ad	f0 09		beq $24b8			beq  	_ESTALowState
.24af	c9 02		cmp #$02			cmp 	#ESTA_High
.24b1	f0 26		beq $24d9			beq 	_ESTAHighState
.24b3	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.24b5	f0 38		beq $24ef			beq 	_ESTADecimalState
>24b7	db						.byte 	$DB 						; causes a break in the emulator
.24b8					_ESTALowState:
.24b8	68		pla				pla 								; get value back
.24b9	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.24bb	f0 26		beq $24e3			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24bd	29 0f		and #$0f			and 	#15 						; make digit
.24bf	8d 38 05	sta $0538			sta 	digitTemp 					; save it.
.24c2	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24c4	0a		asl a				asl 	a
.24c5	0a		asl a				asl 	a
.24c6	75 3c		adc $3c,x			adc 	NSMantissa0,x
.24c8	0a		asl a				asl 	a
.24c9	6d 38 05	adc $0538			adc 	digitTemp
.24cc	95 3c		sta $3c,x			sta 	NSMantissa0,x
.24ce	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24d0	90 05		bcc $24d7			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24d2	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24d4	8d 37 05	sta $0537			sta 	encodeState
.24d7					_ESTANoSwitch:
.24d7	38		sec				sec
.24d8	60		rts				rts
.24d9					_ESTAHighState:
.24d9	68		pla				pla 								; get value back
.24da	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24dc	f0 05		beq $24e3			beq 	_ESTASwitchFloat
.24de	20 39 25	jsr $2539			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24e1	38		sec				sec
.24e2	60		rts				rts
.24e3					_ESTASwitchFloat:
.24e3	9c 39 05	stz $0539			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24e6	e8		inx				inx 								; zero the decimal additive.
.24e7	20 91 26	jsr $2691			jsr 	FloatSetZero
.24ea	ca		dex				dex
.24eb	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24ed	80 ae		bra $249d			bra 	_ENExitChange
.24ef					_ESTADecimalState:
.24ef	68		pla				pla 								; digit.
.24f0	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24f2	f0 99		beq $248d			beq 	_ENFail
.24f4	e8		inx				inx 								; put digit into fractional part of X+1
.24f5	20 39 25	jsr $2539			jsr 	ESTAShiftDigitIntoMantissa
.24f8	ca		dex				dex
.24f9	ee 39 05	inc $0539			inc 	decimalCount 				; bump the count of decimals
.24fc	ad 39 05	lda $0539			lda 	decimalCount 				; too many decimal digits.
.24ff	c9 0b		cmp #$0b			cmp 	#11
.2501	f0 02		beq $2505			beq 	_ESTADSFail
.2503	38		sec				sec
.2504	60		rts				rts
.2505					_ESTADSFail:
.2505	18		clc				clc
.2506	60		rts				rts
.2507					_ENConstructFinal:
.2507	ad 39 05	lda $0539			lda 	decimalCount 				; get decimal count
.250a	f0 2b		beq $2537			beq 	_ENCFExit 					; no decimals
.250c	5a		phy				phy
.250d	0a		asl a				asl 	a 							; x 4 and CLC
.250e	0a		asl a				asl 	a
.250f	6d 39 05	adc $0539			adc 	decimalCount
.2512	a8		tay				tay
.2513	b9 9e 21	lda $219e,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.2516	95 3e		sta $3e,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.2518	b9 9f 21	lda $219f,y			lda 	FloatScalarTable-5+1,y
.251b	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.251d	b9 a0 21	lda $21a0,y			lda 	FloatScalarTable-5+2,y
.2520	95 56		sta $56,x			sta 	NSMantissa2+2,x
.2522	b9 a1 21	lda $21a1,y			lda 	FloatScalarTable-5+3,y
.2525	95 62		sta $62,x			sta 	NSMantissa3+2,x
.2527	b9 a2 21	lda $21a2,y			lda 	FloatScalarTable-5+4,y
.252a	95 6e		sta $6e,x			sta 	NSExponent+2,x
.252c	74 32		stz $32,x			stz 	NSStatus+2,x 				; make +ve
.252e	e8		inx				inx 								; multiply decimal const by decimal scalar
.252f	e8		inx				inx
.2530	20 51 23	jsr $2351			jsr 	FloatMultiply
.2533	20 b5 20	jsr $20b5			jsr 	FloatAdd 					; add to integer part.
.2536	7a		ply				ply
.2537					_ENCFExit:
.2537	18		clc				clc 								; reject the digit.
.2538	60		rts				rts
.2539					ESTAShiftDigitIntoMantissa:
.2539	29 0f		and #$0f			and 	#15 						; save digit
.253b	48		pha				pha
.253c	b5 60		lda $60,x			lda 	NSMantissa3,x 				; push mantissa on stack
.253e	48		pha				pha
.253f	b5 54		lda $54,x			lda 	NSMantissa2,x
.2541	48		pha				pha
.2542	b5 48		lda $48,x			lda 	NSMantissa1,x
.2544	48		pha				pha
.2545	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2547	48		pha				pha
.2548	20 a0 26	jsr $26a0			jsr 	FloatShiftLeft 				; x 2
.254b	20 a0 26	jsr $26a0			jsr 	FloatShiftLeft 				; x 4
.254e	18		clc				clc 								; pop mantissa and add
.254f	68		pla				pla
.2550	75 3c		adc $3c,x			adc 	NSMantissa0,x
.2552	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2554	68		pla				pla
.2555	75 48		adc $48,x			adc 	NSMantissa1,x
.2557	95 48		sta $48,x			sta 	NSMantissa1,x
.2559	68		pla				pla
.255a	75 54		adc $54,x			adc 	NSMantissa2,x
.255c	95 54		sta $54,x			sta 	NSMantissa2,x
.255e	68		pla				pla
.255f	75 60		adc $60,x			adc 	NSMantissa3,x
.2561	95 60		sta $60,x			sta 	NSMantissa3,x 				; x 5
.2563	20 a0 26	jsr $26a0			jsr 	FloatShiftLeft 				; x 10
.2566	68		pla				pla 								; add digit
.2567	18		clc				clc
.2568	75 3c		adc $3c,x			adc 	NSMantissa0,x
.256a	95 3c		sta $3c,x			sta 	NSMantissa0,x
.256c	90 0a		bcc $2578			bcc 	_ESTASDExit
.256e	f6 48		inc $48,x			inc 	NSMantissa1,x
.2570	d0 06		bne $2578			bne 	_ESTASDExit
.2572	f6 54		inc $54,x			inc 	NSMantissa2,x
.2574	d0 02		bne $2578			bne 	_ESTASDExit
.2576	f6 60		inc $60,x			inc 	NSMantissa3,x
.2578					_ESTASDExit:
.2578	60		rts				rts
.0537					encodeState:
>0537							.fill 	1
.0538					digitTemp:
>0538							.fill 	1
.0539					decimalCount:
>0539							.fill 	1
.2579					FloatToString:
.2579	da		phx				phx
.257a	5a		phy				phy 								; save code position
.257b	8d 3a 05	sta $053a			sta 	decimalPlaces	 			; save number of DPs.
.257e	9c 3b 05	stz $053b			stz 	dbOffset 					; offset into decimal buffer = start.
.2581	b5 30		lda $30,x			lda 	NSStatus,x  				; is it -ve.
.2583	10 08		bpl $258d			bpl 	_CNTSNotNegative
.2585	29 7f		and #$7f			and 	#$7F 						; make +ve
.2587	95 30		sta $30,x			sta 	NSStatus,x
.2589	a9 2d		lda #$2d			lda 	#"-"
.258b	80 02		bra $258f			bra 	_CNTMain
.258d					_CNTSNotNegative:
.258d	a9 20		lda #$20			lda 	#" "
.258f					_CNTMain:
.258f	20 f1 25	jsr $25f1			jsr 	WriteDecimalBuffer
.2592	b5 6c		lda $6c,x			lda 	NSExponent,x 				; check if decimal
.2594	f0 0d		beq $25a3			beq 	_CNTSNotFloat
.2596	e8		inx				inx 								; round up so we don't get too many 6.999999
.2597	a9 01		lda #$01			lda 	#1
.2599	20 93 26	jsr $2693			jsr 	FloatSetByte
.259c	b5 6b		lda $6b,x			lda		NSExponent-1,x
.259e	95 6c		sta $6c,x			sta 	NSExponent,x
.25a0	20 b5 20	jsr $20b5			jsr 	FloatAdd
.25a3					_CNTSNotFloat:
.25a3	20 d3 25	jsr $25d3			jsr 	MakePlusTwoString 			; do the integer part.
.25a6	20 71 22	jsr $2271			jsr 	FloatFractionalPart 		; get the fractional part
.25a9	20 e6 23	jsr $23e6			jsr 	FloatNormalise					; normalise , exit if zero
.25ac	f0 22		beq $25d0			beq 	_CNTSExit
.25ae	a9 2e		lda #$2e			lda 	#"."
.25b0	20 f1 25	jsr $25f1			jsr 	WriteDecimalBuffer 			; write decimal place
.25b3					_CNTSDecimal:
.25b3	ce 3a 05	dec $053a			dec 	decimalPlaces 				; done all the decimals
.25b6	30 18		bmi $25d0			bmi 	_CNTSExit
.25b8	e8		inx				inx 								; x 10.0
.25b9	a9 0a		lda #$0a			lda 	#10
.25bb	20 93 26	jsr $2693			jsr 	FloatSetByte
.25be	20 51 23	jsr $2351			jsr 	FloatMultiply
.25c1	20 d3 25	jsr $25d3			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25c4	20 71 22	jsr $2271			jsr 	FloatFractionalPart 		; get the fractional part
.25c7	20 e6 23	jsr $23e6			jsr 	FloatNormalise 				; normalise it.
.25ca	b5 6c		lda $6c,x			lda 	NSExponent,x 				; gone to zero, exit.
.25cc	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25ce	b0 e3		bcs $25b3			bcs 	_CNTSDecimal 				; keep going.
.25d0					_CNTSExit:
.25d0	7a		ply				ply
.25d1	fa		plx				plx
.25d2	60		rts				rts
.25d3					MakePlusTwoString:
.25d3	da		phx				phx
.25d4	20 74 26	jsr $2674			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25d7	e8		inx				inx 								; access it
.25d8	e8		inx				inx
.25d9	20 cc 22	jsr $22cc			jsr 	FloatIntegerPart 			; make it an integer
.25dc	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25de	20 10 26	jsr $2610			jsr 	ConvertInt32
.25e1	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25e3					_MPTSCopy:
.25e3	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25e6	20 f1 25	jsr $25f1			jsr 	WriteDecimalBuffer
.25e9	e8		inx				inx
.25ea	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25ed	d0 f4		bne $25e3			bne 	_MPTSCopy
.25ef	fa		plx				plx
.25f0	60		rts				rts
.25f1					WriteDecimalBuffer:
.25f1	da		phx				phx
.25f2	ae 3b 05	ldx $053b			ldx 	dbOffset
.25f5	9d 3c 05	sta $053c,x			sta 	decimalBuffer,x
.25f8	9e 3d 05	stz $053d,x			stz 	decimalBuffer+1,x
.25fb	ee 3b 05	inc $053b			inc 	dbOffset
.25fe	fa		plx				plx
.25ff	60		rts				rts
.053a					decimalPlaces:
>053a							.fill 	1
.053b					dbOffset:
>053b							.fill 	1
.053c					decimalBuffer:
>053c							.fill 	32
.2600					ConvertInt16:
.2600	85 3c		sta $3c				sta 	NSMantissa0 				; set up as 32 bit conversion
.2602	86 48		stx $48				stx 	NSMantissa1
.2604	64 54		stz $54				stz 	NSMantissa2
.2606	64 60		stz $60				stz 	NSMantissa3
.2608	64 30		stz $30				stz 	NSStatus 					; positive integer
.260a	a2 00		ldx #$00			ldx 	#0 							; stack level
.260c	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.260e	80 00		bra $2610			bra 	ConvertInt32
.2610					ConvertInt32:
.2610	5a		phy				phy
.2611	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.2613	24 30		bit $30				bit 	NSStatus 					; output a - if not negative.
.2615	10 08		bpl $261f			bpl 	_CI32NotNeg
.2617	48		pha				pha
.2618	a9 2d		lda #$2d			lda 	#'-'
.261a	99 15 05	sta $0515,y			sta 	numberBuffer,y
.261d	c8		iny				iny
.261e	68		pla				pla
.261f					_CI32NotNeg:
.261f	20 2d 26	jsr $262d			jsr 	_CI32DivideConvert 			; recursive conversion
.2622	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2624	99 15 05	sta $0515,y			sta 	numberBuffer,y
.2627	7a		ply				ply
.2628	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.262a	a9 15		lda #$15			lda 	#numberBuffer & $FF
.262c	60		rts				rts
.262d					_CI32DivideConvert:
.262d	e8		inx				inx 								; write to next slot up
.262e	20 93 26	jsr $2693			jsr 	FloatSetByte 		 		; write the base out.
.2631	ca		dex				dex
.2632	20 27 22	jsr $2227			jsr 	Int32Divide 				; divide
.2635	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; save remainder
.2637	48		pha				pha
.2638	20 16 22	jsr $2216			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.263b	20 b3 26	jsr $26b3			jsr 	FloatIsZero 				; is it zero ?
.263e	f0 05		beq $2645			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2640	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2642	20 2d 26	jsr $262d			jsr 	_CI32DivideConvert 			; and recusrively call.
.2645					_CI32NoRecurse:
.2645	68		pla				pla 								; remainder
.2646	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2648	90 02		bcc $264c			bcc 	_CI32NotHex
.264a	69 26		adc #$26			adc 	#6+32
.264c					_CI32NotHex:
.264c	69 30		adc #$30			adc 	#48
.264e	99 15 05	sta $0515,y			sta 	numberBuffer,y 				; write out and exit
.2651	c8		iny				iny
.2652	60		rts				rts
.2653					FloatNegate:
.2653	b5 30		lda $30,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2655	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2657	95 30		sta $30,x			sta 	NSStatus,x
.2659	60		rts				rts
.265a					FloatNegateMantissa:
.265a	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.265b	a9 00		lda #$00			lda 	#0
.265d	f5 3c		sbc $3c,x			sbc 	NSMantissa0,x
.265f	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2661	a9 00		lda #$00			lda 	#0
.2663	f5 48		sbc $48,x			sbc 	NSMantissa1,x
.2665	95 48		sta $48,x			sta 	NSMantissa1,x
.2667	a9 00		lda #$00			lda 	#0
.2669	f5 54		sbc $54,x			sbc 	NSMantissa2,x
.266b	95 54		sta $54,x			sta 	NSMantissa2,x
.266d	a9 00		lda #$00			lda 	#0
.266f	f5 60		sbc $60,x			sbc 	NSMantissa3,x
.2671	95 60		sta $60,x			sta 	NSMantissa3,x
.2673	60		rts				rts
.2674					FloatShiftUpTwo:
.2674	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2676	95 3e		sta $3e,x			sta 	NSMantissa0+2,x
.2678	b5 48		lda $48,x			lda 	NSMantissa1,x
.267a	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.267c	b5 54		lda $54,x			lda 	NSMantissa2,x
.267e	95 56		sta $56,x			sta 	NSMantissa2+2,x
.2680	b5 60		lda $60,x			lda 	NSMantissa3,x
.2682	95 62		sta $62,x			sta 	NSMantissa3+2,x
.2684	b5 6c		lda $6c,x			lda 	NSExponent,x
.2686	95 6e		sta $6e,x			sta 	NSExponent+2,x
.2688	b5 30		lda $30,x			lda 	NSStatus,x
.268a	95 32		sta $32,x			sta 	NSStatus+2,x
.268c	60		rts				rts
.268d					FloatSetZeroMantissaOnly:
.268d	74 3c		stz $3c,x			stz 	NSMantissa0,x
.268f	80 08		bra $2699			bra 	FloatZero13
.2691					FloatSetZero:
.2691	a9 00		lda #$00			lda 	#0
.2693					FloatSetByte:
.2693	74 6c		stz $6c,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2695					FloatSetMantissa:
.2695	95 3c		sta $3c,x			sta 	NSMantissa0,x 				; zero mantissa
.2697	74 30		stz $30,x			stz 	NSStatus,x
.2699					FloatZero13:
.2699	74 48		stz $48,x			stz 	NSMantissa1,x
.269b	74 54		stz $54,x			stz 	NSMantissa2,x
.269d	74 60		stz $60,x			stz 	NSMantissa3,x
.269f	60		rts				rts
.26a0					FloatShiftLeft:
.26a0	18		clc				clc
.26a1					FloatRotateLeft:
.26a1	36 3c		rol $3c,x			rol 	NSMantissa0,x
.26a3	36 48		rol $48,x			rol		NSMantissa1,x
.26a5	36 54		rol $54,x			rol		NSMantissa2,x
.26a7	36 60		rol $60,x			rol		NSMantissa3,x
.26a9	60		rts				rts
.26aa					FloatShiftRight:
.26aa	56 60		lsr $60,x			lsr 	NSMantissa3,x
.26ac	76 54		ror $54,x			ror		NSMantissa2,x
.26ae	76 48		ror $48,x			ror		NSMantissa1,x
.26b0	76 3c		ror $3c,x			ror		NSMantissa0,x
.26b2	60		rts				rts
.26b3					FloatIsZero:
.26b3	b5 60		lda $60,x			lda 	NSMantissa3,x
.26b5	15 54		ora $54,x			ora		NSMantissa2,x
.26b7	15 48		ora $48,x			ora		NSMantissa1,x
.26b9	15 3c		ora $3c,x			ora		NSMantissa0,x
.26bb	60		rts				rts

;******  Processing input file: testing/testend.asm

.26bc					EndProgram:
>26bc	01 08 0a 08 01 00 43 52				.binary "code/tokenised.dat"
>26c4	b2 31 00 13 08 02 00 43 43 b2 31 00 1c 08 03 00
>26d4	46 52 b2 31 00 25 08 04 00 46 43 b2 31 00 30 08
>26e4	05 00 4b 31 b2 24 36 30 00 3a 08 06 00 52 5a b2
>26f4	43 52 00 44 08 07 00 43 5a b2 43 43 00 4e 08 08
>2704	00 52 59 b2 46 52 00 58 08 09 00 43 59 b2 46 43
>2714	00 86 08 0a 00 86 52 4f 28 36 30 29 3a 8f 20 52
>2724	4f 57 20 4f 46 46 53 45 54 20 81 20 54 48 45 20
>2734	56 49 44 45 4f 20 97 20 54 52 49 43 4b 53 00 97
>2744	08 0b 00 81 49 b2 24 42 30 a4 24 45 42 a9 31 00
>2754	ba 08 0c 00 52 4f 28 49 ab 24 41 46 29 b2 49 3a
>2764	8f 20 55 53 45 20 49 4e 44 45 58 20 31 20 a4 20
>2774	36 30 00 c1 08 0d 00 82 49 00 da 08 0e 00 ce 8d
>2784	31 2c 36 3a 8f 20 57 48 49 54 45 20 91 20 42 4c
>2794	55 45 00 f3 08 0f 00 ce 86 33 3a 8f 20 34 30 20
>27a4	43 4f 4c 2c 20 33 30 20 52 4f 57 00 fd 08 10 00
>27b4	ce 8d 30 2c 36 00 08 09 11 00 ce 92 31 2c 33 39
>27c4	00 13 09 12 00 99 22 56 2a 22 3b 00 1d 09 13 00
>27d4	ce 8d 34 2c 36 00 27 09 14 00 ce 92 31 2c 32 00
>27e4	3d 09 15 00 99 22 44 49 53 50 4c 41 59 2d 43 4f
>27f4	44 45 53 22 3b 00 48 09 16 00 ce 92 31 2c 32 34
>2804	00 5d 09 17 00 99 22 43 55 52 52 45 4e 54 2d 46
>2814	4f 4e 54 22 3b 00 68 09 18 00 ce 92 32 31 2c 31
>2824	00 84 09 19 00 99 22 50 52 49 4e 54 2d 43 4f 44
>2834	45 53 20 28 48 45 58 20 24 29 22 3b 00 8e 09 1a
>2844	00 ce 8d 31 2c 36 00 97 09 1b 00 8d 32 34 39 00
>2854	a0 09 1c 00 8d 31 31 37 00 a9 09 1d 00 8d 31 33
>2864	36 00 b1 09 1e 00 8d 35 38 00 c4 09 1f 00 8f 20
>2874	a1 20 4b 45 59 42 4f 41 52 44 20 85 00 cc 09 20
>2884	00 a1 41 24 00 f2 09 21 00 41 b2 c6 28 41 24 29
>2894	3a 8f 20 43 91 56 45 52 54 20 53 54 52 49 4e 47
>28a4	20 a4 20 4e 55 4d 45 52 49 43 00 15 0a 22 00 8f
>28b4	20 ce 8b 41 43 54 45 52 20 4d 41 50 20 44 49 53
>28c4	50 4c 41 59 20 4d 4f 56 45 4d 45 4e 54 00 31 0a
>28d4	23 00 8b 41 b2 38 37 a7 52 5a b2 52 5a ab 31 3a
>28e4	8d 35 38 3a 8f 20 27 57 27 00 4d 0a 24 00 8b 41
>28f4	b2 38 33 a7 52 5a b2 52 5a aa 31 3a 8d 35 38 3a
>2904	8f 20 27 53 27 00 69 0a 25 00 8b 41 b2 36 35 a7
>2914	43 5a b2 43 5a ab 31 3a 8d 35 38 3a 8f 20 27 41
>2924	27 00 85 0a 26 00 8b 41 b2 36 38 a7 43 5a b2 43
>2934	5a aa 31 3a 8d 35 38 3a 8f 20 27 44 27 00 a0 0a
>2944	27 00 8f 20 46 91 54 20 44 49 53 50 4c 41 59 20
>2954	4d 4f 56 45 4d 45 4e 54 00 c2 0a 28 00 8b 41 b2
>2964	31 34 35 a7 52 59 b2 52 59 ab 31 3a 8d 35 38 3a
>2974	8f 20 55 50 20 41 52 52 4f 57 00 e5 0a 29 00 8b
>2984	41 b2 31 37 a7 52 59 b2 52 59 aa 31 3a 8d 35 38
>2994	3a 8f 20 44 4f 57 4e 20 41 52 52 4f 57 00 09 0b
>29a4	2a 00 8b 41 b2 31 35 37 a7 43 59 b2 43 59 ab 31
>29b4	3a 8d 35 38 3a 8f 20 4c 45 46 54 20 41 52 52 4f
>29c4	57 00 2d 0b 2b 00 8b 41 b2 32 39 a7 43 59 b2 43
>29d4	59 aa 31 3a 8d 35 38 3a 8f 20 52 49 47 48 54 20
>29e4	41 52 52 4f 57 00 4b 0b 2c 00 8b 41 b2 33 32 a7
>29f4	8d 31 34 37 3a 8d 35 38 3a 8f 20 53 50 41 43 45
>2a04	42 41 52 00 6b 0b 2d 00 8b 41 b2 37 33 a7 8d 33
>2a14	30 31 3a 8d 35 38 3a 8f 20 49 20 81 20 49 4e 56
>2a24	45 52 54 00 8e 0b 2e 00 8b 41 b2 36 37 a7 8d 32
>2a34	36 34 3a 8d 35 38 3a 8f 20 43 20 81 20 43 4c 45
>2a44	41 52 20 41 4c 4c 00 af 0b 2f 00 8b 41 b2 36 39
>2a54	a7 8d 32 37 34 3a 8d 35 38 3a 8f 20 53 20 81 20
>2a64	53 45 54 20 41 4c 4c 00 cd 0b 30 00 8b 41 b2 37
>2a74	35 a7 8d 32 38 34 3a 8d 35 38 3a 8f 20 4b 20 81
>2a84	20 43 4f 50 59 00 e2 0b 31 00 8b 41 b2 38 36 a7
>2a94	8d 31 39 37 3a 8f 20 94 20 56 00 fb 0b 32 00 8b
>2aa4	41 b2 37 36 a7 8d 32 32 34 3a 8d 35 38 3a 8f 20
>2ab4	93 20 4c 00 18 0c 33 00 8b 41 b2 38 38 a7 8d 31
>2ac4	35 38 3a 8f 20 58 20 bd b0 54 20 43 4f 4d 4d af
>2ad4	00 40 0c 34 00 5a 5a b2 30 3a 8f 20 44 91 27 54
>2ae4	20 55 50 44 41 54 45 20 54 48 45 20 44 49 53 50
>2af4	4c 41 59 ab 46 91 54 53 00 76 0c 35 00 8b 41 b2
>2b04	39 33 a7 4b 31 b2 4b 31 aa 38 3a 5a 5a b2 31 3a
>2b14	8b 28 4b 31 b1 31 39 32 29 a7 4b 31 b2 30 3a 8f
>2b24	20 4b 45 59 20 5d 20 49 4e 43 8f 45 4e 54 00 ac
>2b34	0c 36 00 8b 41 b2 39 31 a7 4b 31 b2 4b 31 ab 38
>2b44	3a 5a 5a b2 31 3a 8b 28 4b 31 b3 30 29 a7 4b 31
>2b54	b2 31 39 32 3a 8f 20 4b 45 59 20 5b 20 44 45 43
>2b64	8f 45 4e 54 00 bd 0c 37 00 8b 28 5a 5a b2 31 29
>2b74	a7 8d 31 31 37 00 d5 0c 38 00 8b 41 b2 32 37 a7
>2b84	89 33 35 35 3a 8f 20 45 53 43 41 50 45 00 dd 0c
>2b94	39 00 89 33 31 00 e8 0c 3a 00 58 b2 43 43 aa 31
>2ba4	00 f3 0c 3b 00 59 b2 43 52 aa 31 00 fd 0c 3c 00
>2bb4	44 b2 24 36 31 00 06 0d 3d 00 8d 33 34 38 00 0e
>2bc4	0d 3e 00 99 22 22 00 19 0d 3f 00 ce 8d 31 33 2c
>2bd4	36 00 3e 0d 40 00 8f 20 55 50 44 41 54 45 20 ce
>2be4	8b 41 43 54 45 52 20 44 49 53 50 4c 41 59 20 4d
>2bf4	41 52 4b 45 52 53 00 4c 0d 41 00 ce 92 43 52 aa
>2c04	31 2c 31 38 00 56 0d 42 00 99 22 20 22 3b 00 68
>2c14	0d 43 00 8b 28 52 5a b1 31 36 29 a7 52 5a b2 31
>2c24	00 7a 0d 44 00 8b 28 52 5a b3 31 29 a7 52 5a b2
>2c34	31 36 00 84 0d 45 00 43 52 b2 52 5a 00 92 0d 46
>2c44	00 ce 92 43 52 aa 31 2c 31 38 00 9f 0d 47 00 99
>2c54	c7 28 24 35 46 29 3b 00 ad 0d 48 00 ce 92 31 38
>2c64	2c 43 43 aa 31 00 b7 0d 49 00 99 22 20 22 3b 00
>2c74	c9 0d 4a 00 8b 28 43 5a b1 31 36 29 a7 43 5a b2
>2c84	31 00 db 0d 4b 00 8b 28 43 5a b3 31 29 a7 43 5a
>2c94	b2 31 36 00 e5 0d 4c 00 43 43 b2 43 5a 00 f3 0d
>2ca4	4d 00 ce 92 31 38 2c 43 43 aa 31 00 fd 0d 4e 00
>2cb4	99 22 5e 22 3b 00 1e 0e 4f 00 8f 20 55 50 44 41
>2cc4	54 45 20 46 91 54 20 44 49 53 50 4c 41 59 20 4d
>2cd4	41 52 4b 45 52 53 00 2c 0e 50 00 ce 92 46 52 aa
>2ce4	31 2c 33 38 00 36 0e 51 00 99 22 20 22 3b 00 47
>2cf4	0e 52 00 8b 28 52 59 b1 38 29 a7 52 59 b2 31 00
>2d04	58 0e 53 00 8b 28 52 59 b3 31 29 a7 52 59 b2 38
>2d14	00 62 0e 54 00 46 52 b2 52 59 00 70 0e 55 00 ce
>2d24	92 46 52 aa 31 2c 33 38 00 7d 0e 56 00 99 c7 28
>2d34	24 35 46 29 3b 00 8c 0e 57 00 ce 92 31 30 2c 46
>2d44	43 aa 32 39 00 96 0e 58 00 99 22 20 22 3b 00 a7
>2d54	0e 59 00 8b 28 43 59 b1 38 29 a7 43 59 b2 31 00
>2d64	b8 0e 5a 00 8b 28 43 59 b3 31 29 a7 43 59 b2 38
>2d74	00 c2 0e 5b 00 46 43 b2 43 59 00 d1 0e 5c 00 ce
>2d84	92 31 30 2c 46 43 aa 32 39 00 db 0e 5d 00 99 22
>2d94	5e 22 3b 00 00 0f 5e 00 44 b2 24 46 30 30 30 aa
>2da4	28 28 28 28 43 52 ab 31 29 ac 31 36 29 aa 28 43
>2db4	43 ab 31 29 29 ac 38 29 00 0a 0f 5f 00 ce 8d 33
>2dc4	2c 36 00 15 0f 60 00 81 49 b2 31 a4 38 00 22 0f
>2dd4	61 00 ce 92 31 aa 49 2c 32 34 00 32 0f 62 00 99
>2de4	22 24 22 3b ce d5 28 44 29 3b 00 40 0f 63 00 56
>2df4	b2 ce d0 28 31 2c 44 29 00 4d 0f 64 00 ce 92 31
>2e04	aa 49 2c 33 30 00 59 0f 65 00 99 ce d6 28 56 29
>2e14	3b 00 63 0f 66 00 44 b2 44 aa 31 00 6a 0f 67 00
>2e24	82 49 00 75 0f 68 00 ce 92 31 2c 31 37 00 82 0f
>2e34	69 00 99 22 20 20 20 20 22 3b 00 8d 0f 6a 00 ce
>2e44	92 31 2c 31 37 00 a7 0f 6b 00 99 28 28 28 43 52
>2e54	ab 31 29 ac 31 36 29 aa 28 43 43 ab 31 29 29 00
>2e64	b2 0f 6c 00 58 b2 43 43 aa 31 00 bd 0f 6d 00 59
>2e74	b2 43 52 aa 31 00 c7 0f 6e 00 44 b2 24 45 37 00
>2e84	d0 0f 6f 00 8d 33 34 38 00 dc 0f 70 00 58 b2 46
>2e94	43 aa 32 39 00 e7 0f 71 00 59 b2 46 52 aa 31 00
>2ea4	fb 0f 72 00 8f 20 28 55 53 45 20 53 41 4d 45 20
>2eb4	ce 8d 29 00 04 10 73 00 8d 33 34 38 00 0a 10 74
>2ec4	00 8e 00 12 10 75 00 58 b2 31 00 1b 10 76 00 59
>2ed4	b2 32 32 00 24 10 77 00 49 b2 4b 31 00 2d 10 78
>2ee4	00 49 32 b2 30 00 37 10 79 00 ce 8d 31 2c 36 00
>2ef4	40 10 7a 00 5a 5a b2 30 00 65 10 7b 00 8b 28 28
>2f04	49 b1 b2 33 32 29 af 28 49 b3 b2 31 32 37 29 29
>2f14	a7 5a 5a b2 31 3a 8f 20 99 41 42 4c 45 00 8b 10
>2f24	7c 00 8b 28 28 49 b1 b2 31 36 30 29 af 28 49 b3
>2f34	b2 32 35 35 29 29 a7 5a 5a b2 31 3a 8f 20 99 41
>2f44	42 4c 45 00 9d 10 7d 00 ce 92 59 2c 58 3a 99 22
>2f54	20 20 20 22 3b 00 af 10 7e 00 ce 92 59 2c 58 3a
>2f64	99 ce d5 28 49 29 3b 00 bb 10 7f 00 ce 92 59 2c
>2f74	58 aa 33 00 d8 10 80 00 8b 28 5a 5a b2 30 29 a7
>2f84	99 22 2e 22 3b 3a 8f 20 4e 91 ab 99 41 42 4c 45
>2f94	00 ec 10 81 00 8b 28 5a 5a b3 b1 30 29 a7 99 c7
>2fa4	28 49 29 3b 00 fe 10 82 00 58 b2 58 aa 35 3a 49
>2fb4	32 b2 49 32 aa 31 00 14 11 83 00 8b 28 58 b1 34
>2fc4	30 29 a7 59 b2 59 aa 31 3a 58 b2 31 00 1e 11 84
>2fd4	00 49 b2 49 aa 31 00 30 11 85 00 8b 28 49 32 b1
>2fe4	36 33 29 a7 89 31 33 35 00 39 11 86 00 89 31 32
>2ff4	32 00 3f 11 87 00 8e 00 47 11 88 00 58 b2 32 00
>3004	4f 11 89 00 59 b2 32 00 57 11 8a 00 44 b2 30 00
>3014	69 11 8b 00 8b 28 44 b1 32 35 35 29 a7 89 31 34
>3024	35 00 72 11 8c 00 8d 33 34 33 00 7c 11 8d 00 58
>3034	b2 58 aa 31 00 92 11 8e 00 8b 28 58 b1 31 37 29
>3044	a7 59 b2 59 aa 31 3a 58 b2 32 00 9c 11 8f 00 44
>3054	b2 44 aa 31 00 a5 11 90 00 89 31 33 39 00 b5 11
>3064	91 00 8f 20 44 49 53 50 4c 41 59 20 80 00 bb 11
>3074	92 00 8e 00 e0 11 93 00 44 b2 24 46 30 30 30 aa
>3084	28 28 28 28 43 52 ab 31 29 ac 31 36 29 aa 28 43
>3094	43 ab 31 29 29 ac 38 29 00 05 12 94 00 44 b2 44
>30a4	aa 28 46 52 ab 31 29 3a 8f 20 49 4e 43 8f 45 4e
>30b4	54 20 54 48 45 20 46 91 54 20 52 4f 57 00 13 12
>30c4	95 00 56 b2 ce d0 28 31 2c 44 29 00 1d 12 96 00
>30d4	54 b2 32 35 36 00 2c 12 97 00 81 49 b2 46 43 a4
>30e4	31 a9 ab 31 00 39 12 98 00 54 b2 b5 28 54 ad 32
>30f4	29 00 40 12 99 00 82 49 00 54 12 9a 00 56 b2 28
>3104	56 aa 54 29 ab 32 ac 28 56 af 54 29 00 60 12 9b
>3114	00 ce 84 31 2c 44 2c 56 00 69 12 9c 00 8d 33 35
>3124	33 00 6f 12 9d 00 8e 00 79 12 9e 00 ce 8d 37 2c
>3134	36 00 84 12 9f 00 ce 92 32 2c 31 39 00 91 12 a0
>3144	00 99 22 57 41 49 54 22 3b 00 9c 12 a1 00 ce 92
>3154	33 2c 31 39 00 a8 12 a2 00 99 22 45 58 50 22 3b
>3164	00 b5 12 a3 00 55 31 b2 24 46 30 30 30 00 c3 12
>3174	a4 00 55 32 b2 55 31 aa 31 32 37 00 cc 12 a5 00
>3184	49 4e b2 31 00 f4 12 a6 00 58 b2 32 38 30 30 30
>3194	aa 28 43 52 ac 32 30 30 30 29 3a 8f 20 42 41 53
>31a4	49 43 20 ce 88 20 4e 55 ce d3 45 52 00 fd 12 a7
>31b4	00 49 32 b2 30 00 06 13 a8 00 49 33 b2 31 00 18
>31c4	13 a9 00 8b 28 49 4e b2 43 52 29 a7 89 31 37 32
>31d4	00 43 13 aa 00 49 32 b2 49 32 aa 31 32 38 3a 8f
>31e4	20 41 43 43 4f 55 4e 54 20 81 20 a8 20 4f 55 54
>31f4	50 55 54 49 4e 47 20 54 48 49 53 00 4c 13 ab 00
>3204	89 31 38 38 00 80 13 ac 00 46 24 b2 22 40 3a 46
>3214	4f 4e 54 22 aa c4 28 49 4e 29 aa 22 2e 42 41 53
>3224	2c 53 2c 57 22 3a 8f 20 53 45 51 55 45 4e 54 49
>3234	41 4c 20 57 52 49 54 45 00 8e 13 ad 00 9f 31 2c
>3244	38 2c 32 2c 46 24 00 99 13 ae 00 ce 92 31 39 2c
>3254	31 00 a6 13 af 00 99 22 20 20 20 20 20 22 00 b1
>3264	13 b0 00 ce 92 31 39 2c 31 00 b9 13 b1 00 99 53
>3274	54 00 c6 13 b2 00 81 49 b2 55 31 a4 55 32 00 f3
>3284	13 b3 00 8b 28 49 33 b2 31 29 a7 98 31 2c 58 3b
>3294	22 20 52 45 4d 20 46 4f 4e 54 20 22 3b b5 28 49
>32a4	32 ad 38 29 3a 58 b2 58 aa 31 30 00 01 14 b4 00
>32b4	56 b2 ce d0 28 31 2c 49 29 00 28 14 b5 00 98 31
>32c4	2c 58 3b 22 20 56 50 4f 4b 45 20 31 2c 24 22 3b
>32d4	ce d5 28 49 29 3b 22 2c 25 22 2c ce d6 28 56 29
>32e4	00 33 14 b6 00 58 b2 58 aa 31 30 00 3f 14 b7 00
>32f4	49 33 b2 49 33 aa 31 00 50 14 b8 00 8b 28 49 33
>3304	b1 38 29 a7 49 33 b2 31 00 5c 14 b9 00 49 32 b2
>3314	49 32 aa 31 00 63 14 ba 00 82 49 00 6a 14 bb 00
>3324	a0 31 00 98 14 bc 00 8b 28 49 4e b3 31 36 29 a7
>3334	49 4e b2 49 4e aa 31 3a 55 31 b2 55 31 aa 31 32
>3344	38 3a 55 32 b2 55 32 aa 31 32 38 3a 89 31 36 39
>3354	00 a2 14 bd 00 ce 8d 31 2c 36 00 ad 14 be 00 ce
>3364	92 32 2c 31 39 00 ba 14 bf 00 99 22 20 20 20 20
>3374	22 3b 00 c5 14 c0 00 ce 92 33 2c 31 39 00 d2 14
>3384	c1 00 99 22 20 20 20 20 22 3b 00 dd 14 c2 00 ce
>3394	92 34 2c 31 39 00 ea 14 c3 00 99 22 20 20 20 20
>33a4	22 3b 00 f0 14 c4 00 8e 00 fa 14 c5 00 ce 8d 37
>33b4	2c 36 00 05 15 c6 00 ce 92 32 2c 31 39 00 12 15
>33c4	c7 00 99 22 57 41 49 54 22 3b 00 1d 15 c8 00 ce
>33d4	92 33 2c 31 39 00 2a 15 c9 00 99 22 53 41 56 45
>33e4	22 3b 00 61 15 ca 00 46 24 b2 22 40 3a 58 31 36
>33f4	46 4f 4e 54 22 aa c4 28 43 52 29 aa 22 2e 44 41
>3404	54 2c 53 2c 57 22 3a 8f 20 53 45 51 55 45 4e 54
>3414	49 41 4c 20 57 52 49 54 45 00 6f 15 cb 00 9f 31
>3424	2c 38 2c 32 2c 46 24 00 7a 15 cc 00 ce 92 31 39
>3434	2c 31 00 87 15 cd 00 99 22 20 20 20 20 20 22 00
>3444	92 15 ce 00 ce 92 31 39 2c 31 00 9a 15 cf 00 99
>3454	53 54 00 b5 15 d0 00 8b 28 53 54 b2 30 29 a7 ce
>3464	92 43 52 aa 31 2c 31 3a 99 22 20 22 3b 00 cd 15
>3474	d1 00 55 31 b2 24 46 30 30 30 aa 28 43 52 ab 31
>3484	29 ac 31 32 38 00 ee 15 d2 00 55 32 b2 55 31 aa
>3494	31 32 37 3a 8f 20 31 36 20 42 59 54 45 53 20 50
>34a4	45 52 20 52 4f 57 00 0b 16 d3 00 81 49 b2 55 31
>34b4	a4 55 32 3a 8f 20 24 46 30 30 30 20 a4 20 24 46
>34c4	37 46 46 00 19 16 d4 00 56 b2 ce d0 28 31 2c 49
>34d4	29 00 22 16 d5 00 98 31 2c 56 00 29 16 d6 00 82
>34e4	49 00 30 16 d7 00 a0 31 00 3a 16 d8 00 ce 8d 31
>34f4	2c 36 00 45 16 d9 00 ce 92 32 2c 31 39 00 52 16
>3504	da 00 99 22 20 20 20 20 22 3b 00 5d 16 db 00 ce
>3514	92 33 2c 31 39 00 6a 16 dc 00 99 22 20 20 20 20
>3524	22 3b 00 75 16 dd 00 ce 92 34 2c 31 39 00 82 16
>3534	de 00 99 22 20 20 20 20 22 3b 00 88 16 df 00 8e
>3544	00 92 16 e0 00 ce 8d 37 2c 36 00 9d 16 e1 00 ce
>3554	92 32 2c 31 39 00 aa 16 e2 00 99 22 57 41 49 54
>3564	22 3b 00 b5 16 e3 00 ce 92 33 2c 31 39 00 c2 16
>3574	e4 00 99 22 4c 4f 41 44 22 3b 00 f3 16 e5 00 46
>3584	24 b2 22 58 31 36 46 4f 4e 54 22 aa c4 28 43 52
>3594	29 aa 22 2e 44 41 54 2c 53 2c 52 22 3a 8f 20 53
>35a4	45 51 55 45 4e 54 49 41 4c 20 87 00 01 17 e6 00
>35b4	9f 31 2c 38 2c 32 2c 46 24 00 0c 17 e7 00 ce 92
>35c4	31 39 2c 31 00 19 17 e8 00 99 22 20 20 20 20 20
>35d4	22 00 24 17 e9 00 ce 92 31 39 2c 31 00 2c 17 ea
>35e4	00 99 53 54 00 47 17 eb 00 8b 28 53 54 b2 30 29
>35f4	a7 ce 92 43 52 aa 31 2c 31 3a 99 22 20 22 3b 00
>3604	5f 17 ec 00 55 31 b2 24 46 30 30 30 aa 28 43 52
>3614	ab 31 29 ac 31 32 38 00 7f 17 ed 00 55 32 b2 55
>3624	31 aa 31 32 37 3a 8f 20 38 20 42 59 54 45 53 20
>3634	50 45 52 20 46 91 54 00 9c 17 ee 00 81 49 b2 55
>3644	31 a4 55 32 3a 8f 20 24 46 30 30 30 20 a4 20 24
>3654	46 37 46 46 00 a5 17 ef 00 84 31 2c 56 00 b1 17
>3664	f0 00 ce 84 31 2c 49 2c 56 00 b8 17 f1 00 82 49
>3674	00 bf 17 f2 00 a0 31 00 c9 17 f3 00 ce 8d 31 2c
>3684	36 00 d4 17 f4 00 ce 92 32 2c 31 39 00 e1 17 f5
>3694	00 99 22 20 20 20 20 22 3b 00 ec 17 f6 00 ce 92
>36a4	33 2c 31 39 00 f9 17 f7 00 99 22 20 20 20 20 22
>36b4	3b 00 ff 17 f8 00 8e 00 26 18 f9 00 ce 8d 31 32
>36c4	2c 36 3a 8f 20 20 20 20 31 32 33 34 35 36 37 38
>36d4	39 30 31 32 33 34 35 36 37 38 39 30 31 32 00 4d
>36e4	18 fa 00 ce 92 31 31 2c 31 39 3a 99 22 41 52 52
>36f4	4f 57 20 4b 45 59 53 20 20 20 4d 4f 56 45 20 46
>3704	4f 4e 54 22 3b 00 74 18 fb 00 ce 92 31 32 2c 31
>3714	39 3a 99 22 57 2d 41 2d 53 2d 44 20 20 20 4d 4f
>3724	56 45 20 44 49 53 50 4c 41 59 22 3b 00 9b 18 fc
>3734	00 ce 92 31 33 2c 31 39 3a 99 22 53 50 41 43 45
>3744	20 20 54 4f 47 47 4c 45 20 46 4f 4e 54 20 42 49
>3754	54 22 3b 00 c2 18 fd 00 ce 92 31 34 2c 31 39 3a
>3764	99 22 56 20 20 53 41 56 45 20 20 20 58 31 36 46
>3774	4f 4e 54 4e 2e 44 41 54 22 3b 00 e9 18 fe 00 ce
>3784	92 31 35 2c 31 39 3a 99 22 4c 20 20 4c 4f 41 44
>3794	20 20 20 58 31 36 46 4f 4e 54 4e 2e 44 41 54 22
>37a4	3b 00 10 19 ff 00 ce 92 31 36 2c 31 39 3a 99 22
>37b4	58 20 20 45 58 50 4f 52 54 20 20 20 20 46 4f 4e
>37c4	54 4e 2e 42 41 53 22 3b 00 37 19 00 01 ce 92 31
>37d4	37 2c 31 39 3a 99 22 49 20 20 49 4e 56 45 52 54
>37e4	20 52 4f 57 2d 43 4f 4c 2d 42 4f 54 48 22 3b 00
>37f4	5e 19 01 01 ce 92 31 38 2c 31 39 3a 99 22 43 20
>3804	20 43 4c 45 41 52 20 41 4c 4c 2f 45 3d 53 45 54
>3814	20 41 4c 4c 22 3b 00 85 19 02 01 ce 92 31 39 2c
>3824	31 39 3a 99 22 5b 20 5d 20 20 44 45 43 20 2f 20
>3834	49 4e 43 20 44 49 53 50 4c 41 59 22 3b 00 ac 19
>3844	03 01 ce 92 32 30 2c 31 39 3a 99 22 4b 20 20 43
>3854	4f 50 59 20 20 20 20 20 2f 20 45 53 43 20 45 58
>3864	49 54 22 3b 00 eb 19 04 01 8f 20 20 20 20 20 20
>3874	20 20 20 20 20 20 20 20 20 20 20 31 32 33 34 35
>3884	36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31
>3894	32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37
>38a4	38 39 30 00 21 1a 05 01 ce 92 33 30 2c 31 3a 99
>38b4	22 55 53 45 20 53 48 49 46 54 2b 41 4c 54 20 54
>38c4	4f 20 52 45 53 54 4f 52 45 20 4f 52 49 47 49 4e
>38d4	41 4c 20 46 4f 4e 54 22 3b 00 2b 1a 06 01 ce 8d
>38e4	31 2c 36 00 31 1a 07 01 8e 00 56 1a 08 01 44 b2
>38f4	24 46 30 30 30 aa 28 28 28 28 43 52 ab 31 29 ac
>3904	31 36 29 aa 28 43 43 ab 31 29 29 ac 38 29 00 60
>3914	1a 09 01 43 41 b2 46 52 00 6c 1a 0a 01 81 46 52
>3924	b2 31 a4 38 00 7c 1a 0b 01 44 31 b2 44 aa 28 46
>3934	52 ab 31 29 00 86 1a 0c 01 56 b2 24 30 30 00 93
>3944	1a 0d 01 ce 84 31 2c 44 31 2c 56 00 9b 1a 0e 01
>3954	82 46 52 00 a5 1a 0f 01 46 52 b2 43 41 00 ae 1a
>3964	10 01 8d 33 35 33 00 b4 1a 11 01 8e 00 d9 1a 12
>3974	01 44 b2 24 46 30 30 30 aa 28 28 28 28 43 52 ab
>3984	31 29 ac 31 36 29 aa 28 43 43 ab 31 29 29 ac 38
>3994	29 00 e3 1a 13 01 43 41 b2 46 52 00 ef 1a 14 01
>39a4	81 46 52 b2 31 a4 38 00 ff 1a 15 01 44 31 b2 44
>39b4	aa 28 46 52 ab 31 29 00 09 1b 16 01 56 b2 24 46
>39c4	46 00 16 1b 17 01 ce 84 31 2c 44 31 2c 56 00 1e
>39d4	1b 18 01 82 46 52 00 28 1b 19 01 46 52 b2 43 41
>39e4	00 31 1b 1a 01 8d 33 35 33 00 37 1b 1b 01 8e 00
>39f4	43 1b 1c 01 ce 92 32 31 2c 31 38 00 4d 1b 1d 01
>3a04	ce 8d 37 2c 36 00 63 1b 1e 01 99 22 57 48 49 43
>3a14	48 20 28 30 2d 32 35 35 29 22 3b 00 6a 1b 1f 01
>3a24	85 41 00 a5 1b 20 01 8b 28 41 b2 28 28 28 43 52
>3a34	ab 31 29 ac 31 36 29 aa 28 43 43 ab 31 29 ac 38
>3a44	29 29 a7 89 32 39 36 3a 8f 20 54 41 52 a1 ad 53
>3a54	4f 55 52 43 45 20 49 53 20 53 41 4d 45 00 d1 1b
>3a64	21 01 44 b2 24 46 30 30 30 aa 28 28 28 28 43 52
>3a74	ab 31 29 ac 31 36 29 aa 28 43 43 ab 31 29 29 ac
>3a84	38 29 3a 8f 20 54 41 52 a1 00 ed 1b 22 01 44 31
>3a94	b2 24 46 30 30 30 aa 28 41 ac 38 29 3a 8f 20 53
>3aa4	4f 55 52 43 45 00 f8 1b 23 01 81 49 b2 30 a4 37
>3ab4	00 09 1c 24 01 56 b2 ce d0 28 31 2c 44 31 aa 49
>3ac4	29 00 17 1c 25 01 ce 84 31 2c 44 aa 49 2c 56 00
>3ad4	1e 1c 26 01 82 49 00 27 1c 27 01 8d 33 35 33 00
>3ae4	33 1c 28 01 ce 92 32 31 2c 31 38 00 3d 1c 29 01
>3af4	ce 8d 31 2c 36 00 5c 1c 2a 01 99 22 20 20 20 20
>3b04	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
>3b14	20 20 22 3b 00 64 1c 2b 01 41 b2 30 00 6a 1c 2c
>3b24	01 8e 00 72 1c 2d 01 99 22 22 00 7e 1c 2e 01 ce
>3b34	92 32 31 2c 31 38 00 88 1c 2f 01 ce 8d 37 2c 36
>3b44	00 a7 1c 30 01 99 22 43 3d 43 4f 4c 2c 52 2d 52
>3b54	4f 57 2c 42 2d 42 4f 54 48 2f 45 53 43 22 3b 00
>3b64	af 1c 31 01 41 b2 30 00 b7 1c 32 01 a1 41 24 00
>3b74	c3 1c 33 01 41 b2 c6 28 41 24 29 00 d1 1c 34 01
>3b84	8b 41 b2 30 a7 89 33 30 36 00 ea 1c 35 01 8b 41
>3b94	b2 36 37 a7 89 33 32 33 3a 8f 20 4f 50 54 49 91
>3ba4	20 43 00 03 1d 36 01 8b 41 b2 38 32 a7 89 33 33
>3bb4	30 3a 8f 20 4f 50 54 49 91 20 52 00 1b 1d 37 01
>3bc4	8b 41 b2 32 37 a7 89 33 33 37 3a 8f 20 45 53 43
>3bd4	41 50 45 00 25 1d 38 01 43 41 b2 46 43 00 2f 1d
>3be4	39 01 43 42 b2 46 52 00 3b 1d 3a 01 81 46 43 b2
>3bf4	31 a4 38 00 47 1d 3b 01 81 46 52 b2 31 a4 38 00
>3c04	50 1d 3c 01 8d 31 34 37 00 58 1d 3d 01 82 46 52
>3c14	00 60 1d 3e 01 82 46 43 00 6a 1d 3f 01 46 43 b2
>3c24	43 41 00 74 1d 40 01 46 52 b2 43 42 00 7d 1d 41
>3c34	01 8d 33 35 33 00 86 1d 42 01 89 33 33 37 00 90
>3c44	1d 43 01 43 41 b2 46 52 00 9c 1d 44 01 81 46 52
>3c54	b2 31 a4 38 00 a5 1d 45 01 8d 31 34 37 00 ad 1d
>3c64	46 01 82 46 52 00 b7 1d 47 01 46 52 b2 43 41 00
>3c74	c0 1d 48 01 8d 33 35 33 00 c9 1d 49 01 89 33 33
>3c84	37 00 d3 1d 4a 01 43 41 b2 46 43 00 df 1d 4b 01
>3c94	81 46 43 b2 31 a4 38 00 e8 1d 4c 01 8d 31 34 37
>3ca4	00 f0 1d 4d 01 82 46 43 00 fa 1d 4e 01 46 43 b2
>3cb4	43 41 00 03 1e 4f 01 8d 33 35 33 00 0c 1e 50 01
>3cc4	89 33 33 37 00 18 1e 51 01 ce 92 32 31 2c 31 38
>3cd4	00 22 1e 52 01 ce 8d 31 2c 36 00 42 1e 53 01 8f
>3ce4	20 20 20 20 31 32 33 34 35 36 37 38 39 30 31 32
>3cf4	33 34 35 36 37 38 39 30 31 32 00 61 1e 54 01 99
>3d04	22 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
>3d14	20 20 20 20 20 20 20 22 3b 00 69 1e 55 01 41 b2
>3d24	30 00 6f 1e 56 01 8e 00 82 1e 57 01 97 24 39 46
>3d34	32 30 2c 28 58 ab 31 29 ac 32 00 93 1e 58 01 97
>3d44	24 39 46 32 31 2c 52 4f 28 59 29 00 a2 1e 59 01
>3d54	97 24 39 46 32 32 2c 24 32 31 00 af 1e 5a 01 97
>3d64	24 39 46 32 33 2c 44 00 b5 1e 5b 01 8e 00 cc 1e
>3d74	5c 01 97 24 39 46 32 30 2c 28 28 58 ab 31 29 ac
>3d84	32 29 aa 31 00 dd 1e 5d 01 97 24 39 46 32 31 2c
>3d94	52 4f 28 59 29 00 ec 1e 5e 01 97 24 39 46 32 32
>3da4	2c 24 32 31 00 f9 1e 5f 01 97 24 39 46 32 33 2c
>3db4	44 00 ff 1e 60 01 8e 00 10 1f 61 01 ce 92 43 52
>3dc4	aa 31 3a 99 22 2a 22 3b 00 16 1f 62 01 8e 00 21
>3dd4	1f 63 01 ce 92 32 39 2c 31 00 27 1f 64 01 80 00
>3de4	00 00

;******  End of listing
