
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Sat Oct  7 15:59:59 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.1000					WrapperBoot:
.1000	a2 0a		ldx #$0a			ldx 	#APIDesc & $FF
.1002	a0 10		ldy #$10			ldy 	#APIDesc >> 8
.1004	20 65 11	jsr $1165			jsr 	StartCompiler
.1007	4c ff ff	jmp $ffff			jmp 	$FFFF
.100a					APIDesc:
>100a	0e 10						.word 	TestAPI 					; the testing API.
>100c	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>100d	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing file: testing/api/api.asm

=$a000					PCodeMemory = $A000
.100e					TestAPI:
.100e	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.1010	f0 11		beq $1023			beq 	_TAOpenIn
.1012	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.1014	f0 15		beq $102b			beq 	_TACloseIn
.1016	c9 02		cmp #$02			cmp 	#BLC_READIN
.1018	f0 12		beq $102c			beq 	_TARead
.101a	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.101c	f0 11		beq $102f			beq 	_TAResetOut
.101e	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.1020	f0 16		beq $1038			beq 	_TAWriteByte
>1022	db						.byte 	$DB 						; causes a break in the emulator
.1023					_TAOpenIn:
.1023	a9 aa		lda #$aa			lda 	#((EndProgram+2) & $FF)
.1025	85 22		sta $22				sta 	0+srcInputPtr
.1027	a9 26		lda #$26			lda 	#((EndProgram+2) >> 8) & $FF
.1029	85 23		sta $23				sta 	1+srcInputPtr
.102b					_TACloseIn:
.102b	60		rts				rts
.102c					_TARead:
.102c	4c 4c 10	jmp $104c			jmp 	ReadNextLine
.102f					_TAResetOut:
.102f	a9 00		lda #$00			lda 	#((PCodeMemory) & $FF)
.1031	85 28		sta $28				sta 	0+objPtr
.1033	a9 a0		lda #$a0			lda 	#((PCodeMemory) >> 8) & $FF
.1035	85 29		sta $29				sta 	1+objPtr
.1037	60		rts				rts
.1038					_TAWriteByte:
.1038					APIOWriteByte:
.1038	8a		txa				txa
.1039	92 28		sta ($28)			sta 	(objPtr)
.103b	e6 28		inc $28				inc 	objPtr
.103d	d0 02		bne $1041			bne 	_HWOWBNoCarry
.103f	e6 29		inc $29				inc 	objPtr+1
.1041					_HWOWBNoCarry:
.1041	60		rts				rts
.0022					srcInputPtr:
>0022							.fill 	2

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/close.asm

.1042					APIOClose:
.1042	a9 a0		lda #$a0			lda 	#PCodeMemory >> 8
.1044	a6 28		ldx $28				ldx 	objPtr
.1046	a4 29		ldy $29				ldy 	objPtr+1
.1048	20 75 10	jsr $1075			jsr 	APISaveMemory
.104b	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/fromram.asm


;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/line.asm

.104c					ReadNextLine:
.104c	b2 22		lda ($22)			lda 	(srcInputPtr) 				; reached the end of the program (address link = $0000)
.104e	a0 01		ldy #$01			ldy 	#1
.1050	11 22		ora ($22),y			ora 	(srcInputPtr),y
.1052	d0 02		bne $1056			bne 	_RLAHaveData
.1054	18		clc				clc
.1055	60		rts				rts									; end of file.
.1056					_RLAHaveData:
.1056	a6 22		ldx $22				ldx 	srcInputPtr 				; remember the line start
.1058	a4 23		ldy $23				ldy 	srcInputPtr+1
.105a	5a		phy				phy
.105b	a0 04		ldy #$04			ldy 	#4 							; must be at least four bytes (address/line#)
.105d					_RNLRead:
.105d	b1 22		lda ($22),y			lda 	(srcInputPtr),y 			; find the end of the line.
.105f	c8		iny				iny
.1060	c9 00		cmp #$00			cmp 	#0
.1062	d0 f9		bne $105d			bne 	_RNLRead
.1064	98		tya				tya 								; advance src input pointer to next.
.1065	18		clc				clc
.1066	65 22		adc $22				adc 	srcInputPtr
.1068	85 22		sta $22				sta 	srcInputPtr
.106a	90 02		bcc $106e			bcc 	_RNLNoCarry
.106c	e6 23		inc $23				inc 	srcInputPtr+1
.106e					_RNLNoCarry:
.106e	7a		ply				ply 								; address of line now in YX.
.106f	38		sec				sec
.1070	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/open.asm


;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/writebyte.asm


;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_printchar.asm

.1071					APIOPrintCharacter
.1071	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1074	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_save.asm

.1075					APISaveMemory:
.1075	da		phx				phx
.1076	5a		phy				phy
.1077	48		pha				pha
.1078	a9 00		lda #$00			lda 	#0 							; set LFS
.107a	a2 08		ldx #$08			ldx 	#8
.107c	a0 00		ldy #$00			ldy 	#0
.107e	20 ba ff	jsr $ffba			jsr 	$FFBA
.1081	a9 08		lda #$08			lda 	#8 							; set file name
.1083	a2 97		ldx #$97			ldx 	#SaveName & $FF
.1085	a0 10		ldy #$10			ldy 	#SaveName >> 8
.1087	20 bd ff	jsr $ffbd			jsr 	$FFBD
.108a	68		pla				pla 								; set up the start address.
.108b	85 2b		sta $2b				sta 	zTemp0+1
.108d	64 2a		stz $2a				stz 	zTemp0
.108f	a9 2a		lda #$2a			lda 	#zTemp0 					; from index.
.1091	7a		ply				ply 								; end in YX
.1092	fa		plx				plx
.1093	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.1096	60		rts				rts
.1097					SaveName:
>1097	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Return to file: testing/testing.asm


;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.0024					srcPtr:
>0024							.fill 	2
.0400					currentLineNumber:
>0400							.fill 	2
.109f					InlineNonDecimal:
.109f	a2 02		ldx #$02			ldx 	#2 							; get size in X
.10a1	c9 25		cmp #$25			cmp 	#"%"
.10a3	f0 02		beq $10a7			beq 	_INDBinary
.10a5	a2 10		ldx #$10			ldx 	#16
.10a7					_INDBinary:
.10a7	85 2c		sta $2c				sta 	zTemp1 						; size => zTemp1
.10a9	64 2d		stz $2d				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.10ab	64 2a		stz $2a				stz 	zTemp0 						; zero result
.10ad	64 2b		stz $2b				stz 	zTemp0+1
.10af					_INDLoop:
.10af	20 3c 1a	jsr $1a3c			jsr 	LookNext 					; check next character
.10b2	20 78 1a	jsr $1a78			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.10b5	90 1f		bcc $10d6			bcc		_INDDone 					; didn't convert
.10b7	c5 2c		cmp $2c				cmp 	zTemp1 						; size too large ?
.10b9	b0 1b		bcs $10d6			bcs 	_INDDone
.10bb	20 e5 10	jsr $10e5			jsr 	_INDShift 					; x 2 or x 16
.10be	e0 02		cpx #$02			cpx 	#2
.10c0	f0 09		beq $10cb			beq 	_INDNotHex
.10c2	20 e5 10	jsr $10e5			jsr 	_INDShift
.10c5	20 e5 10	jsr $10e5			jsr 	_INDShift
.10c8	20 e5 10	jsr $10e5			jsr 	_INDShift
.10cb					_INDNotHex:
.10cb	05 2a		ora $2a				ora 	zTemp0 						; or digit into result
.10cd	85 2a		sta $2a				sta 	zTemp0
.10cf	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume
.10d2	e6 2d		inc $2d				inc 	zTemp1+1 					; bump count
.10d4	80 d9		bra $10af			bra 	_INDLoop
.10d6					_INDDone:
.10d6	a5 2d		lda $2d				lda 	zTemp1+1 					; done at least 1 ?
.10d8	f0 08		beq $10e2			beq 	_INDError
.10da	a4 2b		ldy $2b				ldy 	zTemp0+1 					; push constant
.10dc	a5 2a		lda $2a				lda 	zTemp0
.10de	20 fa 11	jsr $11fa			jsr 	PushIntegerYA
.10e1	60		rts				rts
.10e2					_INDError:
.10e2	4c 37 1f	jmp $1f37		jmp	ErrorV_syntax
.10e5					_INDShift:
.10e5	06 2a		asl $2a				asl 	zTemp0
.10e7	26 2b		rol $2b				rol 	zTemp0+1
.10e9	60		rts				rts
.10ea					GetLineNumber:
.10ea	ac 01 04	ldy $0401			ldy 	currentLineNumber+1
.10ed	ad 00 04	lda $0400			lda 	currentLineNumber
.10f0	60		rts				rts
.10f1					WriteCodeByte:
.10f1	48		pha				pha 								; save on stack
.10f2	da		phx				phx
.10f3	5a		phy				phy
.10f4	aa		tax				tax
.10f5	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.10f7	20 f7 11	jsr $11f7			jsr 	CallAPIHandler
.10fa	7a		ply				ply 								; restore from stack
.10fb	fa		plx				plx
.10fc	68		pla				pla
.10fd	60		rts				rts
.10fe					PrintCharacter
.10fe	48		pha				pha
.10ff	da		phx				phx
.1100	5a		phy				phy
.1101	20 71 10	jsr $1071			jsr 	APIOPrintCharacter
.1104	7a		ply				ply
.1105	fa		plx				plx
.1106	68		pla				pla
.1107	60		rts				rts
.1108					ProcessNewLine:
.1108	86 2a		stx $2a				stx 	zTemp0 						; save address in zTemp0
.110a	84 2b		sty $2b				sty 	zTemp0+1
.110c	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.110d	8a		txa				txa
.110e	69 04		adc #$04			adc 	#4
.1110	85 24		sta $24				sta 	srcPtr
.1112	98		tya				tya
.1113	69 00		adc #$00			adc 	#0
.1115	85 25		sta $25				sta 	srcPtr+1
.1117	a0 02		ldy #$02			ldy 	#2							; read and save line number
.1119	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.111b	8d 00 04	sta $0400			sta 	currentLineNumber
.111e	c8		iny				iny
.111f	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1121	8d 01 04	sta $0401			sta 	currentLineNumber+1
.1124	60		rts				rts
.1125					BufferClear:
.1125	9c 02 04	stz $0402			stz 	bufferSize
.1128	60		rts				rts
.1129					BufferWrite:
.1129	da		phx				phx
.112a	ae 02 04	ldx $0402			ldx 	bufferSize
.112d	9d 03 04	sta $0403,x			sta 	dataBuffer,x
.1130	ee 02 04	inc $0402			inc 	bufferSize
.1133	fa		plx				plx
.1134	60		rts				rts
.1135					BufferOutput:
.1135	ad 02 04	lda $0402			lda 	bufferSize
.1138	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.113b	a2 00		ldx #$00			ldx 	#0
.113d					_BOLoop:
.113d	ec 02 04	cpx $0402			cpx 	bufferSize
.1140	f0 09		beq $114b			beq 	_BOExit
.1142	bd 03 04	lda $0403,x			lda 	dataBuffer,x
.1145	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1148	e8		inx				inx
.1149	80 f2		bra $113d			bra 	_BOLoop
.114b					_BOExit:
.114b	60		rts				rts
.0402					bufferSize:
>0402							.fill 	1
.0403					dataBuffer:
>0403							.fill 	256
.114c					CheckNextComma:
.114c	a9 2c		lda #$2c			lda	 	#","
.114e	80 06		bra $1156			bra 	CheckNextA
.1150					CheckNextRParen:
.1150	a9 29		lda #$29			lda	 	#")"
.1152	80 02		bra $1156			bra 	CheckNextA
.1154					CheckNextLParen:
.1154	a9 28		lda #$28			lda 	#"("
.1156					CheckNextA:
.1156	8d 03 05	sta $0503			sta 	checkCharacter 				; save test character
.1159					_CNALoop:
.1159	20 58 1a	jsr $1a58			jsr 	GetNextNonSpace 			; get next skipping spaces.
.115c	cd 03 05	cmp $0503			cmp 	checkCharacter 				; matches ?
.115f	f0 03		beq $1164			beq 	_CNAExit
.1161	4c 37 1f	jmp $1f37		jmp	ErrorV_syntax
.1164					_CNAExit:
.1164	60		rts				rts
.0503					checkCharacter:
>0503							.fill 	1
.1165					StartCompiler:
.1165	86 2a		stx $2a				stx 	zTemp0 						; access API
.1167	84 2b		sty $2b				sty 	zTemp0+1
.1169	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.116b	b2 2a		lda ($2a)			lda 	(zTemp0)
.116d	8d 05 05	sta $0505			sta 	APIVector
.1170	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1172	8d 06 05	sta $0506			sta 	APIVector+1
.1175	c8		iny				iny 								; copy data area range.
.1176	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1178	8d 07 05	sta $0507			sta 	compilerStartHigh
.117b	c8		iny				iny
.117c	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.117e	8d 08 05	sta $0508			sta 	compilerEndHigh
.1181	ba		tsx				tsx 								; save stack pointer
.1182	8e 04 05	stx $0504			stx 	compilerSP
.1185	20 dc 1d	jsr $1ddc			jsr 	STRReset 					; reset storage (line#, variable)
.1188	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.118a	20 f7 11	jsr $11f7			jsr 	CallAPIHandler
.118d	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.118f	20 f7 11	jsr $11f7			jsr 	CallAPIHandler
.1192	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.1194	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1197	a9 00		lda #$00			lda 	#0
.1199	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.119c	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.119f					MainCompileLoop:
.119f	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.11a1	20 f7 11	jsr $11f7			jsr 	CallAPIHandler
.11a4	90 31		bcc $11d7			bcc 	SaveCodeAndExit 			; end of source.
.11a6	20 08 11	jsr $1108			jsr 	ProcessNewLine 				; set up pointer and line number.
.11a9	20 ea 10	jsr $10ea			jsr 	GetLineNumber 				; get line #
.11ac	20 c6 1b	jsr $1bc6			jsr 	STRMarkLine 				; remember the code position and number of this line.
.11af	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.11b1	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.11b4					_MCLSameLine:
.11b4	20 58 1a	jsr $1a58			jsr 	GetNextNonSpace 			; get the first character.
.11b7	f0 e6		beq $119f			beq 	MainCompileLoop 			; end of line, get next line.
.11b9	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.11bb	f0 f7		beq $11b4			beq 	_MCLSameLine
.11bd	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.11bf	10 0c		bpl $11cd			bpl 	_MCLCheckAssignment
.11c1	a2 19		ldx #$19			ldx 	#CommandTables & $FF 		; do command tables.
.11c3	a0 16		ldy #$16			ldy 	#CommandTables >> 8
.11c5	20 e1 18	jsr $18e1			jsr 	GeneratorProcess
.11c8	b0 ea		bcs $11b4			bcs 	_MCLSameLine 				; keep trying to compile the line.
.11ca					_MCLSyntax:
.11ca	4c 37 1f	jmp $1f37		jmp	ErrorV_syntax
.11cd					_MCLCheckAssignment:
.11cd	20 6e 1a	jsr $1a6e			jsr 	CharIsAlpha 				; if not alpha then syntax error
.11d0	90 f8		bcc $11ca			bcc 	_MCLSyntax
.11d2	20 94 1b	jsr $1b94			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.11d5	80 dd		bra $11b4			bra		_MCLSameLine 				; loop back.
.11d7					SaveCodeAndExit:
.11d7	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.11d9	20 f7 11	jsr $11f7			jsr 	CallAPIHandler
.11dc	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.11de	a8		tay				tay
.11df	20 c6 1b	jsr $1bc6			jsr 	STRMarkLine
.11e2	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.11e4	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.11e7	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.11e9	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.11ec	20 11 15	jsr $1511			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.11ef	20 42 10	jsr $1042			jsr 	APIOClose
.11f2					ExitCompiler:
.11f2	ae 04 05	ldx $0504			ldx 	compilerSP 					; reload SP and exit.
.11f5	9a		txs				txs
.11f6	60		rts				rts
.11f7					CallAPIHandler:
.11f7	6c 05 05	jmp ($0505)			jmp 	(APIVector)
.0504					compilerSP:
>0504							.fill 	1
.0505					APIVector:
>0505							.fill 	2
.0507					compilerStartHigh:
>0507							.fill 	1
.0508					compilerEndHigh:
>0508							.fill 	1
.11fa					PushIntegerYA:
.11fa	c0 00		cpy #$00			cpy 	#0 							; 0-255
.11fc	f0 0f		beq $120d			beq 	PushIntegerA
.11fe	48		pha				pha
.11ff	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.1201	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1204	68		pla				pla 								; then LSB
.1205	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1208	98		tya				tya 								; then MSB
.1209	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.120c	60		rts				rts
.120d					PushIntegerA:
.120d	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.120f	90 07		bcc $1218			bcc 	_PIWriteA
.1211	48		pha				pha
.1212	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.1214	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1217	68		pla				pla
.1218					_PIWriteA:
.1218	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.121b	60		rts				rts
.121c					PushFloat:
.121c	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.121e	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1221	b5 6c		lda $6c,x			lda 	NSExponent,x 				; and the data
.1223	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1226	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1228	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.122b	b5 48		lda $48,x			lda 	NSMantissa1,x
.122d	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1230	b5 54		lda $54,x			lda 	NSMantissa2,x
.1232	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1235	b5 30		lda $30,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.1237	29 80		and #$80			and 	#$80
.1239	15 60		ora $60,x			ora 	NSMantissa3,x
.123b	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.123e	60		rts				rts
.123f					CreateVariableRecord:
.123f	48		pha				pha
.1240	ad 13 05	lda $0513			lda 	freeVariableMemory 		; push current free address on stack.
.1243	48		pha				pha
.1244	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1247	48		pha				pha
.1248	ad 11 05	lda $0511			lda 	variableListEnd  		; copy end of list to zTemp0
.124b	85 2a		sta $2a				sta 	zTemp0
.124d	ad 12 05	lda $0512			lda 	variableListEnd+1
.1250	85 2b		sta $2b				sta 	zTemp0+1
.1252	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.1254	92 2a		sta ($2a)			sta 	(zTemp0)
.1256	98		tya				tya
.1257	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.1259	91 2a		sta ($2a),y			sta 	(zTemp0),y
.125b	88		dey				dey
.125c	8a		txa				txa
.125d	91 2a		sta ($2a),y			sta 	(zTemp0),y
.125f	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.1261	ad 13 05	lda $0513			lda 	freeVariableMemory
.1264	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1266	c8		iny				iny
.1267	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.126a	91 2a		sta ($2a),y			sta 	(zTemp0),y
.126c	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.126e	a9 00		lda #$00			lda 	#0
.1270	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1272	18		clc				clc
.1273	b2 2a		lda ($2a)			lda 	(zTemp0) 				; add offset to variableListEnd
.1275	6d 11 05	adc $0511			adc  	variableListEnd
.1278	8d 11 05	sta $0511			sta 	variableListEnd
.127b	90 03		bcc $1280			bcc 	_CVNoCarry2
.127d	ee 12 05	inc $0512			inc 	variableListEnd+1
.1280					_CVNoCarry2:
.1280	7a		ply				ply
.1281	fa		plx				plx
.1282	68		pla				pla
.1283	60		rts				rts
.1284					SetVariableRecordToCodePosition:
.1284	48		pha				pha
.1285	5a		phy				phy
.1286	a0 03		ldy #$03			ldy 	#3
.1288	a5 29		lda $29				lda 	objPtr+1
.128a	91 2a		sta ($2a),y			sta 	(zTemp0),y
.128c	c8		iny				iny
.128d	a5 28		lda $28				lda 	objPtr
.128f	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1291	7a		ply				ply
.1292	68		pla				pla
.1293	60		rts				rts
.1294					AllocateBytesForType:
.1294	48		pha				pha
.1295	da		phx				phx
.1296	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.1298	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.129a	c9 00		cmp #$00			cmp 	#NSSIFloat
.129c	d0 02		bne $12a0			bne 	_CVNotFloat
.129e	a2 06		ldx #$06			ldx 	#6
.12a0					_CVNotFloat:
.12a0	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.12a1	18		clc				clc
.12a2	6d 13 05	adc $0513			adc 	freeVariableMemory
.12a5	8d 13 05	sta $0513			sta 	freeVariableMemory
.12a8	90 03		bcc $12ad			bcc 	_CVNoCarry1
.12aa	ee 14 05	inc $0514			inc 	freeVariableMemory+1
.12ad					_CVNoCarry1:
.12ad	fa		plx				plx
.12ae	68		pla				pla
.12af	60		rts				rts
.12b0					CommandDATA:
.12b0	20 25 11	jsr $1125			jsr 	BufferClear 				; copy it to the buffer
.12b3	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace
.12b6					_CTDataLoop:
.12b6	20 3c 1a	jsr $1a3c			jsr 	LookNext 					; reached EOL
.12b9	f0 08		beq $12c3			beq 	_CTDataDone
.12bb	20 29 11	jsr $1129			jsr 	BufferWrite 				; write and consume
.12be	20 4d 1a	jsr $1a4d			jsr 	GetNext
.12c1	80 f3		bra $12b6			bra 	_CTDataLoop
.12c3					_CTDataDone:
.12c3	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.12c5	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.12c8	20 35 11	jsr $1135			jsr 	BufferOutput
.12cb	60		rts				rts
.12cc					CommandDEF:
.12cc	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.12ce	20 0d 12	jsr $120d			jsr 	PushIntegerA
.12d1	20 5d 1b	jsr $1b5d			jsr 	CompileGotoEOL 				; compile skip over DEF
.12d4	a9 a5		lda #$a5			lda 	#C64_FN
.12d6	20 56 11	jsr $1156			jsr 	CheckNextA
.12d9	20 58 1a	jsr $1a58			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.12dc	20 bd 1a	jsr $1abd			jsr 	ExtractVariableName
.12df	8a		txa				txa
.12e0	10 51		bpl $1333			bpl 	_CDError
.12e2	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.12e3	29 7f		and #$7f			and 	#$7F
.12e5	aa		tax				tax
.12e6	98		tya				tya
.12e7	09 80		ora #$80			ora 	#$80
.12e9	a8		tay				tay
.12ea	20 b5 14	jsr $14b5			jsr 	FindVariable				; does it already exist ?
.12ed	b0 44		bcs $1333			bcs 	_CDError 					; if so, that's an error.
.12ef	20 3f 12	jsr $123f			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.12f2	20 84 12	jsr $1284			jsr 	SetVariableRecordToCodePosition
.12f5	20 58 1a	jsr $1a58			jsr 	GetNextNonSpace
.12f8	20 99 1d	jsr $1d99			jsr 	GetReferenceTerm 			; get var ref, not array
.12fb	c9 00		cmp #$00			cmp 	#0
.12fd	30 34		bmi $1333			bmi 	_CDError
.12ff	8d 09 05	sta $0509			sta 	defType 					; save type
.1302	8e 0a 05	stx $050a			stx 	defVariable 				; save var ref
.1305	8c 0b 05	sty $050b			sty 	defVariable+1
.1308	29 40		and #$40			and 	#NSSString 					; only numbers.
.130a	d0 27		bne $1333			bne 	_CDError
.130c	20 50 11	jsr $1150			jsr 	CheckNextRParen 			; check )
.130f	a9 b2		lda #$b2			lda 	#C64_EQUAL
.1311	20 56 11	jsr $1156			jsr 	CheckNextA 					; check =
.1314	18		clc				clc 								; if this is DEF FNxx(A), read A
.1315	20 36 13	jsr $1336			jsr 	CDReadWriteVariable
.1318	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.131a	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.131d	38		sec				sec
.131e	20 36 13	jsr $1336			jsr 	CDReadWriteVariable 		; A is now updated
.1321	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; the actual body of the function.
.1324	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1326	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1329	38		sec				sec
.132a	20 36 13	jsr $1336			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.132d	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.132f	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1332	60		rts				rts
.1333					_CDError:
.1333	4c 37 1f	jmp $1f37		jmp	ErrorV_syntax
.1336					CDReadWriteVariable:
.1336	ac 0b 05	ldy $050b			ldy 	defVariable+1 				; set up YX
.1339	ae 0a 05	ldx $050a			ldx 	defVariable
.133c	ad 09 05	lda $0509			lda 	defType
.133f	20 4b 1d	jsr $1d4b			jsr 	GetSetVariable
.1342	60		rts				rts
.0509					defType:
>0509							.fill 	1
.050a					defVariable:
>050a							.fill 	2
.1343					CommandDIM:
.1343	20 58 1a	jsr $1a58			jsr 	GetNextNonSpace 			; get the first non space character
.1346	20 bd 1a	jsr $1abd			jsr 	ExtractVariableName 		; variable name to XY
.1349	da		phx				phx 								; save name with type bits.
.134a	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.134c	10 37		bpl $1385			bpl 	_CDError
.134e	20 b5 14	jsr $14b5			jsr 	FindVariable	 			; see if already exist
.1351	b0 35		bcs $1388			bcs 	_CDRedefine 				; it still exists.
.1353	20 3f 12	jsr $123f			jsr 	CreateVariableRecord 		; create the basic variable
.1356	20 94 12	jsr $1294			jsr 	AllocateBytesForType 		; allocate memory for it
.1359	68		pla				pla 								; restore type bits
.135a	5a		phy				phy 								; save the address of the basic storage
.135b	da		phx				phx
.135c	48		pha				pha
.135d	20 8b 13	jsr $138b			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.1360	68		pla				pla
.1361	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.1363	20 0d 12	jsr $120d			jsr 	PushIntegerA 				; push that type data out.
.1366	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.1368	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.136b	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.136d	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1370	fa		plx				plx 								; restore address
.1371	7a		ply				ply
.1372	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1374	38		sec				sec
.1375	20 4b 1d	jsr $1d4b			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.1378	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; , follows ?
.137b	c9 2c		cmp #$2c			cmp 	#","
.137d	d0 05		bne $1384			bne 	_CDExit
.137f	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume comma
.1382	80 bf		bra $1343			bra 	CommandDIM 					; do another DIM
.1384					_CDExit:
.1384	60		rts				rts
.1385					_CDError:
.1385	4c 37 1f	jmp $1f37		jmp	ErrorV_syntax
.1388					_CDRedefine:
.1388	4c ff 1f	jmp $1fff		jmp	ErrorV_redefine
.138b					OutputIndexGroup:
.138b	9c 0c 05	stz $050c			stz 	IndexCount 					; count of number of indices.
.138e					_OIGNext:
.138e	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; get a dimension
.1391	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1393	c9 00		cmp #$00			cmp 	#NSSIFloat
.1395	d0 19		bne $13b0			bne 	_OIGType
.1397	ee 0c 05	inc $050c			inc 	IndexCount 					; bump the counter.
.139a	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; does a , follow ?
.139d	c9 2c		cmp #$2c			cmp 	#","
.139f	d0 05		bne $13a6			bne 	_OIGCheckEnd
.13a1	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume comma
.13a4	80 e8		bra $138e			bra 	_OIGNext 					; get next dimension
.13a6					_OIGCheckEnd:
.13a6	20 50 11	jsr $1150			jsr 	CheckNextRParen 			; check and consume )
.13a9	ad 0c 05	lda $050c			lda 	IndexCount
.13ac	20 0d 12	jsr $120d			jsr 	PushIntegerA 				; compile the dimension count.
.13af	60		rts				rts
.13b0					_OIGType:
.13b0	4c 47 1f	jmp $1f47		jmp	ErrorV_type
.050c					IndexCount:
>050c							.fill 	1
.13b3					ErrorHandler:
.13b3	68		pla				pla
.13b4	7a		ply				ply
.13b5	85 2a		sta $2a				sta 	zTemp0
.13b7	84 2b		sty $2b				sty 	zTemp0+1
.13b9	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.13bb	a0 01		ldy #$01			ldy 	#1
.13bd					_EHDisplayMsg:
.13bd	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.13bf	20 fe 10	jsr $10fe			jsr 	PrintCharacter
.13c2	c8		iny				iny
.13c3	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.13c5	d0 f6		bne $13bd			bne 	_EHDisplayMsg
.13c7	a9 20		lda #$20			lda 	#32
.13c9	20 fe 10	jsr $10fe			jsr 	PrintCharacter
.13cc	a9 40		lda #$40			lda 	#64
.13ce	20 fe 10	jsr $10fe			jsr 	PrintCharacter
.13d1	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.13d3	20 7f 26	jsr $267f			jsr 	FloatSetByte
.13d6	20 ea 10	jsr $10ea			jsr 	GetLineNumber
.13d9	95 3c		sta $3c,x			sta 	NSMantissa0,x
.13db	98		tya				tya
.13dc	95 48		sta $48,x			sta 	NSMantissa1,x
.13de	20 65 25	jsr $2565			jsr 	FloatToString
.13e1	a0 00		ldy #$00			ldy 	#0 							; display that string.
.13e3	a2 00		ldx #$00			ldx 	#0
.13e5					_EHDisplayLine:
.13e5	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13e8	20 fe 10	jsr $10fe			jsr 	PrintCharacter
.13eb	c8		iny				iny
.13ec	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13ef	d0 f4		bne $13e5			bne 	_EHDisplayLine
.13f1	a9 0d		lda #$0d			lda 	#13
.13f3	20 fe 10	jsr $10fe			jsr 	PrintCharacter
.13f6	80 fe		bra $13f6	_EHHalt:bra 	_EHHalt
.13f8	4c f2 11	jmp $11f2			jmp 	ExitCompiler
.13fb					CompileExpressionAt0:
.13fb	a9 00		lda #$00			lda 	#0
.13fd					CompileExpressionAtA:
.13fd	48		pha				pha  								; save level
.13fe	20 04 1e	jsr $1e04			jsr 	CompileTerm 				; compile a term.
.1401	fa		plx				plx 								; get level back into X
.1402					_ECALoop:
.1402	48		pha				pha 								; save type on stack.
.1403	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; get the next character
.1406	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.1408	90 04		bcc $140e			bcc 	_ECAExit
.140a	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.140c	90 02		bcc $1410			bcc 	_ECAHaveToken
.140e					_ECAExit:
.140e	68		pla				pla 								; throw type off stack
.140f	60		rts				rts
.1410					_ECAHaveToken:
.1410	86 2a		stx $2a				stx 	zTemp0 						; save current precedence in zTemp0
.1412	aa		tax				tax 								; X contains the operator token
.1413	bd fe 13	lda $13fe,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.1416	c5 2a		cmp $2a				cmp 	zTemp0 						; if < then exit
.1418	90 f4		bcc $140e			bcc 	_ECAExit
.141a	85 2b		sta $2b				sta 	zTemp0+1 					; save the precedence of the operator.
.141c	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume the token.
.141f	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.1421	f0 11		beq $1434			beq 	_ECAGreaterCheck
.1423	e0 b3		cpx #$b3			cpx 	#C64_LESS
.1425	d0 1a		bne $1441			bne 	_ECAHaveFullToken
.1427	20 3c 1a	jsr $1a3c			jsr 	LookNext 					; checks for < (<= or <>)
.142a	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.142c	f0 0e		beq $143c			beq	 	_ECAToNotEqual
.142e	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.1430	d0 0f		bne $1441			bne 	_ECAHaveFullToken
.1432	80 07		bra $143b			bra 	_ECAAddEqual
.1434					_ECAGreaterCheck:
.1434	20 3c 1a	jsr $1a3c			jsr 	LookNext
.1437	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.1439	d0 06		bne $1441			bne 	_ECAHaveFullToken
.143b					_ECAAddEqual:
.143b	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.143c					_ECAToNotEqual:
.143c	e8		inx				inx
.143d	e8		inx				inx
.143e	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume the = or > in >= <= <>
.1441					_ECAHaveFullToken:
.1441	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.1443	d0 0a		bne $144f			bne 	_ECANotConcat
.1445	68		pla				pla 								; get type back
.1446	48		pha				pha
.1447	29 40		and #$40			and 	#NSSTypeMask
.1449	c9 40		cmp #$40			cmp 	#NSSString
.144b	d0 02		bne $144f			bne 	_ECANotConcat
.144d	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.144f					_ECANotConcat:
.144f	da		phx				phx 								; save operator on the stack
.1450	a6 2a		ldx $2a				ldx 	zTemp0 						; push current precedence on the stack
.1452	da		phx				phx
.1453	a5 2b		lda $2b				lda 	zTemp0+1 					; get precedence of operator
.1455	1a		inc a				inc 	a
.1456	20 fd 13	jsr $13fd			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.1459	85 2a		sta $2a				sta 	zTemp0 						; save type in zTemp0
.145b	fa		plx				plx 								; restore current precedence in X
.145c	68		pla				pla 								; restore operator
.145d	85 2b		sta $2b				sta 	zTemp0+1 					; save it in zTemp0+1.
.145f	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.1461	90 17		bcc $147a			bcc 	_ECANotCompare
.1463	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.1465	b0 13		bcs $147a			bcs 	_ECANotCompare
.1467	7a		ply				ply 								; get type into Y
.1468	5a		phy				phy
.1469	48		pha				pha 								; save operator
.146a	98		tya				tya 								; get type
.146b	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.146d	29 40		and #$40			and 	#NSSTypeMask
.146f	c9 40		cmp #$40			cmp 	#NSSString
.1471	f0 02		beq $1475			beq 	_ECANotString
.1473	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.1475					_ECANotString:
.1475	98		tya				tya									; output token Y
.1476	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1479	68		pla				pla 								; restore operator.
.147a					_ECANotCompare:
.147a	18		clc				clc 								; convert to P-Code and compile.
.147b	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.147d	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1480	68		pla				pla 								; type of current result
.1481	45 2a		eor $2a				eor 	zTemp0 						; check compatible with r-expr type
.1483	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.1485	d0 19		bne $14a0			bne		_ECAType
.1487	a5 2a		lda $2a				lda 	zTemp0 						; get type back
.1489	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.148b	d0 18		bne $14a5			bne 	_ECAGoLoop
.148d	a5 2b		lda $2b				lda 	zTemp0+1 					; check operator is + or comparator
.148f	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1491	f0 10		beq $14a3			beq 	_ECAOkayString 				; (this is post conversion)
.1493	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.1495	90 09		bcc $14a0			bcc 	_ECAType
.1497	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.1499	b0 05		bcs $14a0			bcs 	_ECAType
.149b	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.149d	4c 02 14	jmp $1402			jmp 	_ECALoop
.14a0					_ECAType:
.14a0	4c 47 1f	jmp $1f47		jmp	ErrorV_type
.14a3					_ECAOkayString:
.14a3	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.14a5					_ECAGoLoop:
.14a5	4c 02 14	jmp $1402			jmp 	_ECALoop
.14a8					PrecedenceTable:
>14a8	03						.byte 	3 					; '+'
>14a9	03						.byte 	3 					; '-'
>14aa	04						.byte 	4 					; '*'
>14ab	04						.byte 	4 					; '/'
>14ac	05						.byte 	5 					; '^'
>14ad	01						.byte 	1 					; 'and'
>14ae	00						.byte 	0 					; 'or'
>14af	02						.byte 	2 					; '>'
>14b0	02						.byte 	2 					; '='
>14b1	02						.byte 	2 					; '<'
>14b2	02						.byte 	2 					; '>='
>14b3	02						.byte 	2 					; '<='
>14b4	02						.byte 	2 					; '<>'
.14b5					FindVariable:
.14b5	86 2c		stx $2c				stx 	zTemp1 						; save name.
.14b7	84 2d		sty $2d				sty 	zTemp1+1
.14b9					_IVCheckSpecial:
.14b9	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.14bb	d0 18		bne $14d5			bne 	_IVStandard
.14bd	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.14bf	f0 0c		beq $14cd			beq 	_IVTIFloat
.14c1	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.14c3	d0 10		bne $14d5			bne 	_IVStandard
.14c5	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.14c7	a2 01		ldx #$01			ldx 	#$01
.14c9	a9 40		lda #$40			lda 	#NSSString
.14cb	38		sec				sec
.14cc	60		rts				rts
.14cd					_IVTIFloat:
.14cd	a0 80		ldy #$80			ldy 	#$80
.14cf	a2 00		ldx #$00			ldx 	#$00
.14d1	a9 00		lda #$00			lda 	#0
.14d3	38		sec				sec
.14d4	60		rts				rts
.14d5					_IVStandard:
.14d5	ad 07 05	lda $0507			lda 	compilerStartHigh			; start scanning from here.
.14d8	85 2b		sta $2b				sta 	zTemp0+1
.14da	64 2a		stz $2a				stz 	zTemp0
.14dc					_IVCheckLoop:
.14dc	b2 2a		lda ($2a)			lda 	(zTemp0) 					; finished ?
.14de	f0 2b		beq $150b			beq  	_IVNotFound 				; if so, return with CC.
.14e0	a0 01		ldy #$01			ldy 	#1 							; match ?
.14e2	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14e4	c5 2c		cmp $2c				cmp 	zTemp1
.14e6	d0 07		bne $14ef			bne	 	_IVNext
.14e8	c8		iny				iny
.14e9	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14eb	c5 2d		cmp $2d				cmp 	zTemp1+1
.14ed	f0 0d		beq $14fc			beq 	_IVFound
.14ef					_IVNext:
.14ef	18		clc				clc
.14f0	a5 2a		lda $2a				lda 	zTemp0
.14f2	72 2a		adc ($2a)			adc 	(zTemp0)
.14f4	85 2a		sta $2a				sta 	zTemp0
.14f6	90 e4		bcc $14dc			bcc 	_IVCheckLoop
.14f8	e6 2b		inc $2b				inc 	zTemp0+1
.14fa	80 e0		bra $14dc			bra 	_IVCheckLoop
.14fc					_IVFound:
.14fc	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.14fe	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1500	aa		tax				tax
.1501	c8		iny				iny
.1502	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1504	48		pha				pha
.1505	c8		iny				iny
.1506	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1508	7a		ply				ply
.1509	38		sec				sec
.150a	60		rts				rts
.150b					_IVNotFound:
.150b	a6 2c		ldx $2c				ldx 	zTemp1 						; get variable name back
.150d	a4 2d		ldy $2d				ldy 	zTemp1+1
.150f	18		clc				clc
.1510	60		rts				rts
.1511					FixBranches:
.1511	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.1513	20 f7 11	jsr $11f7			jsr 	CallAPIHandler
.1516					_FBLoop:
.1516	b2 28		lda ($28)			lda 	(objPtr) 					; get the next one.
.1518	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.151a	f0 16		beq $1532			beq 	_FBFixGotoGosub
.151c	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.151e	f0 12		beq $1532			beq 	_FBFixGotoGosub
.1520	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.1522	f0 0e		beq $1532			beq 	_FBFixGotoGosub
.1524	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1526	f0 0a		beq $1532			beq 	_FBFixGotoGosub
.1528	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.152a	f0 3b		beq $1567			beq 	_FBFixVarSpace
.152c					_FBNext:
.152c	20 4c 20	jsr $204c			jsr 	MoveObjectForward 			; move forward in object code.
.152f	90 e5		bcc $1516			bcc 	_FBLoop 					; not finished
.1531					_FBExit:
.1531	60		rts				rts
.1532					_FBFixGotoGosub:
.1532	a0 01		ldy #$01			ldy 	#1							; line number in YA
.1534	b1 28		lda ($28),y			lda 	(objPtr),y
.1536	48		pha				pha
.1537	c8		iny				iny
.1538	b1 28		lda ($28),y			lda 	(objPtr),y
.153a	a8		tay				tay
.153b	68		pla				pla
.153c	20 ef 1b	jsr $1bef			jsr 	STRFindLine			 		; find where it is YA
.153f	90 08		bcc $1549			bcc 	_FBFFound 					; not found, so must be >
.1541	48		pha				pha
.1542	b2 28		lda ($28)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.1544	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1546	d0 0f		bne $1557			bne 	_FBFFail
.1548	68		pla				pla
.1549					_FBFFound:
.1549	20 3f 1c	jsr $1c3f			jsr 	STRMakeOffset 				; make it an offset from X:YA
.154c	5a		phy				phy	 								; patch the GOTO/GOSUB
.154d	a0 01		ldy #$01			ldy 	#1
.154f	91 28		sta ($28),y			sta 	(objPtr),y
.1551	c8		iny				iny
.1552	68		pla				pla
.1553	91 28		sta ($28),y			sta 	(objPtr),y
.1555	80 d5		bra $152c			bra 	_FBNext
.1557					_FBFFail:
.1557	a0 02		ldy #$02			ldy 	#2
.1559	b1 28		lda ($28),y			lda 	(objPtr),y
.155b	8d 00 04	sta $0400			sta 	currentLineNumber
.155e	c8		iny				iny
.155f	b1 28		lda ($28),y			lda 	(objPtr),y
.1561	8d 01 04	sta $0401			sta 	currentLineNumber+1
.1564	4c 7a 1f	jmp $1f7a		jmp	ErrorV_line
.1567					_FBFixVarSpace:
.1567	a0 01		ldy #$01			ldy 	#1
.1569	ad 13 05	lda $0513			lda 	freeVariableMemory
.156c	91 28		sta ($28),y			sta 	(objPtr),y
.156e	c8		iny				iny
.156f	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1572	91 28		sta ($28),y			sta 	(objPtr),y
.1574	80 b6		bra $152c			bra 	_FBNext
.1576					CommandFOR:
.1576	20 58 1a	jsr $1a58			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.1579	20 6e 1a	jsr $1a6e			jsr 	CharIsAlpha 				; if not alpha , error
.157c	90 59		bcc $15d7			bcc 	_CFFail
.157e	20 99 1d	jsr $1d99			jsr 	GetReferenceTerm 			; figure out the reference.
.1581	48		pha				pha 								; save type
.1582	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1584	c9 00		cmp #$00			cmp 	#NSSIFloat
.1586	d0 4f		bne $15d7			bne 	_CFFail
.1588	5a		phy				phy 								; save reference on the stack
.1589	da		phx				phx
.158a	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.158c	20 56 11	jsr $1156			jsr 	CheckNextA
.158f	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; initial value
.1592	fa		plx				plx 								; get reference back.
.1593	7a		ply				ply
.1594	5a		phy				phy
.1595	da		phx				phx
.1596	38		sec				sec 								; set initial value.
.1597	20 4b 1d	jsr $1d4b			jsr 	GetSetVariable
.159a	fa		plx				plx
.159b	7a		ply				ply
.159c	68		pla				pla
.159d	29 20		and #$20			and 	#NSSIInt16
.159f	f0 04		beq $15a5			beq 	_CFNotInt16
.15a1	98		tya				tya
.15a2	09 80		ora #$80			ora 	#$80
.15a4	a8		tay				tay
.15a5					_CFNotInt16:
.15a5	8a		txa				txa 								; reference in YA
.15a6	20 fa 11	jsr $11fa			jsr 	PushIntegerYA
.15a9	a9 a4		lda #$a4			lda 	#C64_TO
.15ab	20 56 11	jsr $1156			jsr 	CheckNextA
.15ae	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; terminal value
.15b1	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15b3	c9 00		cmp #$00			cmp 	#NSSIFloat
.15b5	d0 20		bne $15d7			bne 	_CFFail
.15b7	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; followed by STEP
.15ba	c9 a9		cmp #$a9			cmp 	#C64_STEP
.15bc	d0 0e		bne $15cc			bne 	_CFNoStep
.15be	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume it.
.15c1	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; terminal value
.15c4	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15c6	c9 00		cmp #$00			cmp 	#NSSIFloat
.15c8	d0 0d		bne $15d7			bne 	_CFFail
.15ca	80 05		bra $15d1			bra 	_CFParametersDone
.15cc					_CFNoStep:
.15cc	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.15ce	20 0d 12	jsr $120d			jsr 	PushIntegerA
.15d1					_CFParametersDone:
.15d1	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.15d3	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.15d6	60		rts				rts
.15d7					_CFFail:
.15d7	4c 37 1f	jmp $1f37		jmp	ErrorV_syntax
.15da					FNCompile:
.15da	20 58 1a	jsr $1a58			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.15dd	20 bd 1a	jsr $1abd			jsr 	ExtractVariableName
.15e0	e0 00		cpx #$00			cpx 	#0
.15e2	10 32		bpl $1616			bpl 	_FNError
.15e4	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.15e5	29 7f		and #$7f			and 	#$7F
.15e7	aa		tax				tax
.15e8	98		tya				tya
.15e9	09 80		ora #$80			ora 	#$80
.15eb	a8		tay				tay
.15ec	20 b5 14	jsr $14b5			jsr 	FindVariable				; does it already exist ?
.15ef	90 25		bcc $1616			bcc 	_FNError 					; no.
.15f1	20 3f 1c	jsr $1c3f			jsr 	STRMakeOffset 				; convert to a relative address.
.15f4	c9 00		cmp #$00			cmp 	#0 							; fix up.
.15f6	d0 01		bne $15f9			bne 	_FNNoBorrow
.15f8	88		dey				dey
.15f9					_FNNoBorrow:
.15f9	3a		dec a				dec 	a
.15fa	5a		phy				phy 								; save location of routine on stack.
.15fb	48		pha				pha
.15fc	da		phx				phx
.15fd	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0
.1600	20 50 11	jsr $1150			jsr 	CheckNextRParen
.1603	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1605	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1608	68		pla				pla
.1609	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.160c	68		pla				pla
.160d	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1610	68		pla				pla
.1611	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1614	18		clc				clc
.1615	60		rts				rts
.1616					_FNError:
.1616	4c 2a 1f	jmp $1f2a		jmp	ErrorV_value
.1619					CommandTables:
>1619	07 cb 00 03 1b 1b 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>1620	07 89 00 03 22 1b 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>1627	07 8d 00 03 15 1b 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>162e	07 88 00 03 91 1b 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>1635	07 85 00 03 71 1b 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>163c	07 84 00 04 85 1b 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>1643	07 99 00 03 c6 1c 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>164a	07 98 00 04 c6 1c 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1651	07 8f 00 03 d1 1d 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>1658	07 81 00 03 76 15 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>165f	07 82 00 03 49 1c 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>1666	07 a1 00 03 8e 1a 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>166d	07 83 00 03 b0 12 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>1674	07 87 00 03 0f 1d 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>167b	07 86 00 03 43 13 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>1682	07 96 00 03 cc 12 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>1689	07 8b 00 e3 3e 1b 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>1690	08 92 00 ea e3 9d 1e 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>1698	09 91 00 e1 a9 03 75 1c			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>16a0	06
>16a1	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>16a8	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>16af	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>16b5	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>16bc	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>16c3	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>16ca	07 9d 00 e3 c3 1e 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>16d1	0a 9f 00 ea e3 d6 1e 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>16d9	c6 06
>16db	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>16e1	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>16e8	0a ce 92 e3 0b 1a 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>16f0	ad 06
>16f2	0a ce 8d e3 0b 1a 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>16fa	ae 06
>16fc	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>1702	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>170a	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>1711	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>1718	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>1720	06
>1721	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>1729	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>1731	9a 06
>1733	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>173b	9b 06
>173d	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>1745	9c 06
>1747	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>174f	06
>1750	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>1757	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>175f	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>1767	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>176f	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>1777	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>177f	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>1787	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>178f	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>1797	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>179f	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>17a7	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>17ae	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>17b6	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>17be	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>17c6	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>17ce	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>17d6	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>17de	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>17e6	00						.byte 	0
.17e7					UnaryTables:
>17e7	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>17ee	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>17f6	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>17fd	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>1804	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>180b	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>1812	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>181a	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>1821	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>1829	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>1831	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>1839	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>1841	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>1849	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>1851	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>1858	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>185f	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>1866	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>186d	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>1874	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>187b	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>1883	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>188b	0b ca 00 8f ae 03 0b 1a			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>1893	91 bd 07
>1896	07 a8 00 03 2a 1a 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>189d	07 a5 00 03 da 15 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>18a4	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>18ab	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>18b2	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>18ba	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>18c2	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>18c9	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>18d0	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>18d7	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>18df	06
>18e0	00						.byte 	0
.18e1					GeneratorProcess:
.18e1	86 2a		stx $2a				stx 	zTemp0 						; save generation pointer in zTemp0
.18e3	84 2b		sty $2b				sty 	zTemp0+1
.18e5	85 2c		sta $2c				sta 	zTemp1 						; first match token
.18e7	64 2d		stz $2d				stz 	zTemp1+1
.18e9	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.18eb	d0 05		bne $18f2			bne 	_GPNotShifted
.18ed	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; get the shifted token
.18f0	85 2d		sta $2d				sta 	zTemp1+1 					; match CE xx
.18f2					_GPNotShifted:
.18f2					_GPSearch:
.18f2	b2 2a		lda ($2a)			lda 	(zTemp0) 					; reached end ?
.18f4	18		clc				clc
.18f5	f0 2f		beq $1926			beq 	_GPExit
.18f7	a0 01		ldy #$01			ldy 	#1 							; tokens match
.18f9	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.18fb	c5 2c		cmp $2c				cmp 	zTemp1
.18fd	d0 09		bne $1908			bne 	_GPNext
.18ff	a5 2d		lda $2d				lda 	zTemp1+1 					; 2nd token ?
.1901	f0 12		beq $1915			beq 	_GPFound
.1903	c8		iny				iny 								; check match.
.1904	d1 2a		cmp ($2a),y			cmp 	(zTemp0),y
.1906	f0 0d		beq $1915			beq 	_GPFound
.1908					_GPNext:
.1908	18		clc				clc 								; follow to next
.1909	a5 2a		lda $2a				lda 	zTemp0
.190b	72 2a		adc ($2a)			adc 	(zTemp0)
.190d	85 2a		sta $2a				sta 	zTemp0
.190f	90 e1		bcc $18f2			bcc 	_GPSearch
.1911	e6 2b		inc $2b				inc 	zTemp0+1
.1913	80 dd		bra $18f2			bra 	_GPSearch
.1915					_GPFound:
.1915	18		clc				clc 								; skip to action bytes
.1916	a5 2a		lda $2a				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.1918	69 03		adc #$03			adc 	#3
.191a	85 2a		sta $2a				sta 	zTemp0
.191c	90 02		bcc $1920			bcc 	_GPNoCarry
.191e	e6 2b		inc $2b				inc 	zTemp0+1
.1920					_GPNoCarry:
.1920					_GPLoop:
.1920	20 27 19	jsr $1927			jsr 	GeneratorExecute 			; execute one command
.1923	90 fb		bcc $1920			bcc 	_GPLoop 					; go back if not completed.
.1925	38		sec				sec 								; return with CS.
.1926					_GPExit:
.1926	60		rts				rts
.1927					GeneratorExecute:
.1927	20 d2 19	jsr $19d2			jsr 	_GEFetchZTemp0 				; get next.
.192a	48		pha				pha 								; split into 2 nibbles
.192b	4a		lsr a				lsr 	a
.192c	4a		lsr a				lsr 	a
.192d	4a		lsr a				lsr		a
.192e	4a		lsr a				lsr 	a
.192f	20 39 19	jsr $1939			jsr 	_GEExecuteNibble 			; MSB first
.1932	68		pla				pla
.1933	b0 03		bcs $1938			bcs 	_GEHaveCompleted
.1935	20 39 19	jsr $1939			jsr 	_GEExecuteNibble 			; LSB second
.1938					_GEHaveCompleted:
.1938	60		rts				rts
.1939					_GEExecuteNibble:
.1939	29 0f		and #$0f			and 	#$0F
.193b	0a		asl a				asl 	a
.193c	aa		tax				tax
.193d	7c 40 19	jmp ($1940,x)			jmp 	(_GEExecuteVectors,x)
.1940					_GEExecuteVectors:
>1940	60 19						.word 	_GEXNop 					; 0  (no operation)
>1942	68 19						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>1944	62 19						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>1946	b5 19						.word 	_GEXExecute 				; 3  (run arbitrary code)
>1948	a8 19						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>194a	60 19						.word 	_GEXNop 					; 5
>194c	6f 19						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>194e	73 19						.word 	_GEXExitString 				; 7  exit return string type
>1950	77 19						.word 	_GEXLParam 					; 8  check ( follows
>1952	7b 19						.word 	_GEXRParam 					; 9  check ) follows
>1954	7f 19						.word 	_GEXComma					; A  check , follows
>1956	60 19						.word 	_GEXNop 					; B
>1958	60 19						.word 	_GEXNop 					; C
>195a	60 19						.word 	_GEXNop 					; D
>195c	8f 19						.word 	_GEXNumber 					; E  compile get any number
>195e	9a 19						.word 	_GEXString 					; F  compile get any string
.1960					_GEXNop:
.1960	18		clc				clc
.1961	60		rts				rts
.1962					_GEXToken2:
.1962	20 d2 19	jsr $19d2			jsr 	_GEFetchZTemp0
.1965	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1968					_GEXToken1:
.1968	20 d2 19	jsr $19d2			jsr 	_GEFetchZTemp0
.196b	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.196e	60		rts				rts
.196f					_GEXExitNumber:
.196f	a9 00		lda #$00			lda 	#NSSIFloat
.1971	38		sec				sec
.1972	60		rts				rts
.1973					_GEXExitString:
.1973	a9 40		lda #$40			lda 	#NSSString
.1975	38		sec				sec
.1976	60		rts				rts
.1977					_GEXLParam:
.1977	a9 28		lda #$28			lda 	#"("
.1979	80 06		bra $1981			bra 	_GEXCheck
.197b					_GEXRParam:
.197b	a9 29		lda #$29			lda 	#")"
.197d	80 02		bra $1981			bra 	_GEXCheck
.197f					_GEXComma:
.197f	a9 2c		lda #$2c			lda 	#","
.1981					_GEXCheck:
.1981	85 2e		sta $2e				sta 	zTemp2 						; save match
.1983	20 58 1a	jsr $1a58			jsr 	GetNextNonSpace 			; get next skipping spaces
.1986	c5 2e		cmp $2e				cmp 	zTemp2 						; check matches.
.1988	d0 02		bne $198c			bne 	_GEXSyntax
.198a	18		clc				clc
.198b	60		rts				rts
.198c					_GEXSyntax:
.198c	4c 37 1f	jmp $1f37		jmp	ErrorV_syntax
.198f					_GEXNumber:
.198f	20 db 19	jsr $19db			jsr 	GEXCompileExpression 		; compile expression
.1992	29 40		and #$40			and 	#NSSTypeMask
.1994	c9 00		cmp #$00			cmp  	#NSSIFloat
.1996	d0 0d		bne $19a5			bne 	_GEXType
.1998	18		clc				clc
.1999	60		rts				rts
.199a					_GEXString:
.199a	20 db 19	jsr $19db			jsr 	GEXCompileExpression 		; compile expression
.199d	29 40		and #$40			and 	#NSSTypeMask
.199f	c9 40		cmp #$40			cmp  	#NSSString
.19a1	d0 02		bne $19a5			bne 	_GEXType
.19a3	18		clc				clc
.19a4	60		rts				rts
.19a5					_GEXType:
.19a5	4c 47 1f	jmp $1f47		jmp	ErrorV_type
.19a8					_GEXChannelExec:
.19a8	20 eb 19	jsr $19eb			jsr 	ChannelPrefix 				; set up default
.19ab	20 b5 19	jsr $19b5			jsr 	_GEXExecute
.19ae	08		php				php
.19af	20 05 1a	jsr $1a05			jsr 	ChannelPostfix 				; replace default.
.19b2	28		plp				plp
.19b3	60		rts				rts
>19b4	db						.byte 	$DB 						; causes a break in the emulator
.19b5					_GEXExecute:
.19b5	20 d2 19	jsr $19d2			jsr 	_GEFetchZTemp0 				; get vector
.19b8	85 2e		sta $2e				sta 	zTemp2
.19ba	20 d2 19	jsr $19d2			jsr 	_GEFetchZTemp0
.19bd	85 2f		sta $2f				sta 	zTemp2+1
.19bf	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19c1	da		phx				phx
.19c2	a6 2b		ldx $2b				ldx 	zTemp0+1
.19c4	da		phx				phx
.19c5	20 cf 19	jsr $19cf			jsr 	_GECallZTemp2 				; execute code
.19c8	fa		plx				plx 								; recover generation exec
.19c9	86 2b		stx $2b				stx 	zTemp0+1
.19cb	fa		plx				plx
.19cc	86 2a		stx $2a				stx 	zTemp0
.19ce	60		rts				rts
.19cf					_GECallZTemp2:
.19cf	6c 2e 00	jmp ($002e)			jmp 	(zTemp2)
.19d2					_GEFetchZTemp0:
.19d2	b2 2a		lda ($2a)			lda 	(zTemp0)
.19d4	e6 2a		inc $2a				inc 	zTemp0
.19d6	d0 02		bne $19da			bne 	_GEFZ0Skip
.19d8	e6 2b		inc $2b				inc 	zTemp0+1
.19da					_GEFZ0Skip:
.19da	60		rts				rts
.19db					GEXCompileExpression:
.19db	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19dd	da		phx				phx
.19de	a6 2b		ldx $2b				ldx 	zTemp0+1
.19e0	da		phx				phx
.19e1	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; compile expression.
.19e4	fa		plx				plx 								; recover generation exec
.19e5	86 2b		stx $2b				stx 	zTemp0+1
.19e7	fa		plx				plx
.19e8	86 2a		stx $2a				stx 	zTemp0
.19ea	60		rts				rts
.19eb					ChannelPrefix:
.19eb	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.19ed	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.19f0	20 db 19	jsr $19db			jsr 	GEXCompileExpression 		; channel #
.19f3	29 40		and #$40			and 	#NSSTypeMask
.19f5	c9 00		cmp #$00			cmp 	#NSSIFloat
.19f7	d0 09		bne $1a02			bne 	_CPXType
.19f9	20 4c 11	jsr $114c			jsr 	CheckNextComma 				; check , follows.
.19fc	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.19fe	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1a01	60		rts				rts
.1a02					_CPXType:
.1a02	4c 47 1f	jmp $1f47		jmp	ErrorV_type
.1a05					ChannelPostfix:
.1a05	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.1a07	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1a0a	60		rts				rts
.1a0b					OptionalParameterCompile:
.1a0b	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; what follows.
.1a0e	c9 2c		cmp #$2c			cmp 	#","
.1a10	d0 0e		bne $1a20			bne 	_MidDefault
.1a12	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume ,
.1a15	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0
.1a18	29 40		and #$40			and 	#NSSTypeMask
.1a1a	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a1c	d0 09		bne $1a27			bne 	MidFailType
.1a1e	80 05		bra $1a25			bra 	_MidComplete
.1a20					_MidDefault:
.1a20	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1a22	20 0d 12	jsr $120d			jsr 	PushIntegerA
.1a25					_MidComplete:
.1a25	18		clc				clc
.1a26	60		rts				rts
.1a27					MidFailType:
.1a27	4c 47 1f	jmp $1f47		jmp	ErrorV_type
.1a2a					NotUnaryCompile:
.1a2a	ad b0 14	lda $14b0			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1a2d	20 fd 13	jsr $13fd			jsr 	CompileExpressionAtA 		; evaluate at that level
.1a30	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1a32	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a34	d0 f1		bne $1a27			bne 	MidFailType
.1a36	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1a38	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1a3b	60		rts				rts
.1a3c					LookNext:
.1a3c	b2 24		lda ($24)			lda 	(srcPtr)
.1a3e	60		rts				rts
.1a3f					LookNextNonSpace:
.1a3f	b2 24		lda ($24)			lda 	(srcPtr)
.1a41	c9 20		cmp #$20			cmp		#' '
.1a43	f0 03		beq $1a48			beq 	_LNNSkip
.1a45	c9 00		cmp #$00			cmp 	#0
.1a47	60		rts				rts
.1a48					_LNNSkip:
.1a48	20 4d 1a	jsr $1a4d			jsr 	GetNext
.1a4b	80 f2		bra $1a3f			bra 	LookNextNonSpace
.1a4d					GetNext:
.1a4d	b2 24		lda ($24)			lda 	(srcPtr) 					; get next
.1a4f	e6 24		inc $24				inc 	srcPtr
.1a51	d0 02		bne $1a55			bne 	_GNSkip
.1a53	e6 25		inc $25				inc 	srcPtr+1
.1a55					_GNSkip:
.1a55	c9 00		cmp #$00			cmp 	#0
.1a57	60		rts				rts
.1a58					GetNextNonSpace:
.1a58	20 4d 1a	jsr $1a4d			jsr 	GetNext
.1a5b	c9 20		cmp #$20			cmp 	#' '
.1a5d	f0 f9		beq $1a58			beq 	GetNextNonSpace
.1a5f	c9 00		cmp #$00			cmp 	#0
.1a61	60		rts				rts
.1a62					CharIsDigit:
.1a62	c9 30		cmp #$30			cmp 	#"0"
.1a64	90 06		bcc $1a6c			bcc 	CCFalse
.1a66	c9 3a		cmp #$3a			cmp 	#"9"+1
.1a68	b0 02		bcs $1a6c			bcs 	CCFalse
.1a6a					CCTrue:
.1a6a	38		sec				sec
.1a6b	60		rts				rts
.1a6c					CCFalse:
.1a6c	18		clc				clc
.1a6d	60		rts				rts
.1a6e					CharIsAlpha:
.1a6e	c9 41		cmp #$41			cmp 	#"A"
.1a70	90 fa		bcc $1a6c			bcc 	CCFalse
.1a72	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1a74	b0 f6		bcs $1a6c			bcs 	CCFalse
.1a76	80 f2		bra $1a6a			bra 	CCTrue
.1a78					ConvertHexStyle:
.1a78	38		sec				sec
.1a79	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1a7b	90 ef		bcc $1a6c			bcc 	CCFalse
.1a7d	c9 0a		cmp #$0a			cmp 	#9+1
.1a7f	90 e9		bcc $1a6a			bcc 	CCTrue
.1a81	38		sec				sec 								; shift into hex space A=>0 Z=>25
.1a82	e9 11		sbc #$11			sbc 	#"A"-"0"
.1a84	90 e6		bcc $1a6c			bcc 	CCFalse
.1a86	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.1a88	b0 e2		bcs $1a6c			bcs 	CCFalse
.1a8a	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.1a8c	80 dc		bra $1a6a			bra 	CCTrue
.1a8e					CommandGET:
.1a8e	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; # follows ?
.1a91	c9 23		cmp #$23			cmp 	#"#"
.1a93	d0 0d		bne $1aa2			bne 	CommandGetBody
.1a95	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume #
.1a98	20 eb 19	jsr $19eb			jsr 	ChannelPrefix 				; do it as GET#
.1a9b	20 a2 1a	jsr $1aa2			jsr 	CommandGetBody
.1a9e	20 05 1a	jsr $1a05			jsr 	ChannelPostfix
.1aa1	60		rts				rts
.1aa2					CommandGetBody:
.1aa2	20 58 1a	jsr $1a58			jsr 	GetNextNonSpace 			; get the first character
.1aa5	20 99 1d	jsr $1d99			jsr 	GetReferenceTerm 			; identify variable to assign to
.1aa8	48		pha				pha
.1aa9	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1aab	c9 40		cmp #$40			cmp 	#NSSString
.1aad	d0 0b		bne $1aba			bne 	_CGType
.1aaf	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1ab1	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1ab4	38		sec				sec
.1ab5	68		pla				pla
.1ab6	20 4b 1d	jsr $1d4b			jsr		GetSetVariable
.1ab9	60		rts				rts
.1aba					_CGType:
.1aba	4c 47 1f	jmp $1f47		jmp	ErrorV_type
.1abd					ExtractVariableName:
.1abd	20 6e 1a	jsr $1a6e			jsr 	CharIsAlpha
.1ac0	90 50		bcc $1b12			bcc 	_IVSyntax
.1ac2	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.1ac4	85 2c		sta $2c				sta 	zTemp1 						; we'll build it in zTemp1
.1ac6	64 2d		stz $2d				stz 	zTemp1+1
.1ac8	20 3c 1a	jsr $1a3c			jsr 	LookNext 					; is there a second character ?
.1acb	20 6e 1a	jsr $1a6e			jsr 	CharIsAlpha  				; must be alphanumeric
.1ace	b0 05		bcs $1ad5			bcs 	_IVHasSecond
.1ad0	20 62 1a	jsr $1a62			jsr 	CharIsDigit
.1ad3	90 07		bcc $1adc			bcc 	_IVCheckType
.1ad5					_IVHasSecond:
.1ad5	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.1ad7	85 2d		sta $2d				sta 	zTemp1+1
.1ad9					_IVGetNextCheck:
.1ad9	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume it
.1adc					_IVCheckType:
.1adc	20 3c 1a	jsr $1a3c			jsr 	LookNext					; check if string follows.
.1adf	20 6e 1a	jsr $1a6e			jsr 	CharIsAlpha
.1ae2	b0 f5		bcs $1ad9			bcs 	_IVGetNextCheck
.1ae4	20 62 1a	jsr $1a62			jsr 	CharIsDigit
.1ae7	b0 f0		bcs $1ad9			bcs 	_IVGetNextCheck
.1ae9	a2 40		ldx #$40			ldx 	#NSSString
.1aeb	c9 24		cmp #$24			cmp 	#"$"
.1aed	f0 06		beq $1af5			beq 	_IVHasType
.1aef	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.1af1	c9 25		cmp #$25			cmp 	#"%"
.1af3	d0 08		bne $1afd			bne 	_IVCheckArray
.1af5					_IVHasType:
.1af5	8a		txa				txa 								; Or X into zTemp1
.1af6	05 2c		ora $2c				ora 	zTemp1
.1af8	85 2c		sta $2c				sta 	zTemp1
.1afa	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume it
.1afd					_IVCheckArray:
.1afd	20 3c 1a	jsr $1a3c			jsr 	LookNext 					; check if array follows
.1b00	c9 28		cmp #$28			cmp 	#"("
.1b02	d0 09		bne $1b0d			bne 	_IVNotArray
.1b04	a5 2c		lda $2c				lda 	zTemp1 						; set array bit
.1b06	09 80		ora #$80			ora 	#NSSArray
.1b08	85 2c		sta $2c				sta 	zTemp1
.1b0a	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume it
.1b0d					_IVNotArray:
.1b0d	a6 2c		ldx $2c				ldx 	zTemp1
.1b0f	a4 2d		ldy $2d				ldy 	zTemp1+1
.1b11	60		rts				rts
.1b12					_IVSyntax:
.1b12	4c 37 1f	jmp $1f37		jmp	ErrorV_syntax
.1b15					CommandGOSUB:
.1b15	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1b17	20 28 1b	jsr $1b28			jsr 	CompileBranchCommand
.1b1a	60		rts				rts
.1b1b					CommandGOAlt:
.1b1b	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1b1d	20 56 11	jsr $1156			jsr 	CheckNextA
.1b20	80 00		bra $1b22			bra 	CommandGOTO
.1b22					CommandGOTO:
.1b22	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1b24	20 28 1b	jsr $1b28			jsr 	CompileBranchCommand
.1b27	60		rts				rts
.1b28					CompileBranchCommand:
.1b28	20 f1 10	jsr $10f1			jsr 	WriteCodeByte 				; write the command out.
.1b2b	20 58 1a	jsr $1a58			jsr 	GetNextNonSpace
.1b2e	20 a1 1c	jsr $1ca1			jsr 	ParseConstant 				; get constant into YA
.1b31	90 08		bcc $1b3b			bcc 	_CBCSyntax
.1b33	20 f1 10	jsr $10f1			jsr 	WriteCodeByte				; and compile the actual line number
.1b36	98		tya				tya
.1b37	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1b3a	60		rts				rts
.1b3b					_CBCSyntax:
.1b3b	4c 37 1f	jmp $1f37		jmp	ErrorV_syntax
.1b3e					CommandIF:
.1b3e	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; what follows the tests ?
.1b41	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1b43	f0 0f		beq $1b54			beq 	_CIGoto
.1b45	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1b47	20 56 11	jsr $1156			jsr 	CheckNextA
.1b4a	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; THEN <number>
.1b4d	20 62 1a	jsr $1a62			jsr 	CharIsDigit
.1b50	b0 05		bcs $1b57			bcs 	_CIGoto2
.1b52	80 09		bra $1b5d			bra 	CompileGotoEOL
.1b54					_CIGoto:
.1b54	20 4d 1a	jsr $1a4d			jsr 	GetNext
.1b57					_CIGoto2:
.1b57	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1b59	20 28 1b	jsr $1b28			jsr 	CompileBranchCommand
.1b5c	60		rts				rts
.1b5d					CompileGotoEOL:
.1b5d	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.1b5f	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1b62	20 ea 10	jsr $10ea			jsr 	GetLineNumber 				; Get the current line number => YA
.1b65	1a		inc a				inc 	a 							; and branch to +1
.1b66	d0 01		bne $1b69			bne 	_CGENoCarry
.1b68	c8		iny				iny
.1b69					_CGENoCarry:
.1b69	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1b6c	98		tya				tya
.1b6d	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1b70	60		rts				rts
.1b71					CommandINPUT:
.1b71	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; check for "
.1b74	c9 22		cmp #$22			cmp 	#'"'
.1b76	d0 0d		bne $1b85			bne 	CommandINPUTStream
.1b78	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0
.1b7b	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1b7d	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1b80	a9 2c		lda #$2c			lda 	#","
.1b82	20 4c 11	jsr $114c			jsr 	CheckNextComma
.1b85					CommandINPUTStream:
.1b85	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1b87	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1b8a	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.1b8c	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1b8e	4c 13 1d	jmp $1d13			jmp 	CommandReadInputCommon
.1b91					CommandLET:
.1b91	20 58 1a	jsr $1a58			jsr 	GetNextNonSpace 			; get the first character
.1b94					CommandLETHaveFirst:
.1b94	20 99 1d	jsr $1d99			jsr 	GetReferenceTerm 			; identify variable to assign to
.1b97	da		phx				phx 								; save target on the stack.
.1b98	5a		phy				phy
.1b99	48		pha				pha
.1b9a	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.1b9c	20 56 11	jsr $1156			jsr 	CheckNextA
.1b9f	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1ba2	85 2a		sta $2a				sta 	zTemp0 						; save type returned
.1ba4	68		pla				pla 								; get type of assignment
.1ba5	48		pha				pha
.1ba6	45 2a		eor $2a				eor 	zTemp0 						; compare using EOR
.1ba8	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.1baa	d0 17		bne $1bc3			bne 	_CLType
.1bac	68		pla				pla 								; restore and compile save code
.1bad	7a		ply				ply
.1bae	fa		plx				plx
.1baf	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.1bb1	f0 05		beq $1bb8			beq 	_CLTIString
.1bb3	38		sec				sec
.1bb4	20 4b 1d	jsr $1d4b			jsr		GetSetVariable
.1bb7	60		rts				rts
.1bb8					_CLTIString:
.1bb8	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.1bba	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1bbd	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.1bbf	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1bc2	60		rts				rts
.1bc3					_CLType:
.1bc3	4c 47 1f	jmp $1f47		jmp	ErrorV_type
.1bc6					STRMarkLine:
.1bc6	48		pha				pha
.1bc7	38		sec				sec 								; allocate 4 bytes (line #,address)
.1bc8	ad 0f 05	lda $050f			lda 	lineNumberTable 			; and copy to zTemp0
.1bcb	e9 04		sbc #$04			sbc 	#4
.1bcd	8d 0f 05	sta $050f			sta 	lineNumberTable
.1bd0	85 2a		sta $2a				sta 	zTemp0
.1bd2	ad 10 05	lda $0510			lda 	lineNumberTable+1
.1bd5	e9 00		sbc #$00			sbc 	#0
.1bd7	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1bda	85 2b		sta $2b				sta 	zTemp0+1
.1bdc	68		pla				pla
.1bdd	92 2a		sta ($2a)			sta 	(zTemp0) 					; line # save it in +0,+1
.1bdf	98		tya				tya
.1be0	a0 01		ldy #$01			ldy 	#1
.1be2	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1be4	a5 28		lda $28				lda 	objPtr 						; save current address in +2,+3
.1be6	c8		iny				iny
.1be7	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1be9	a5 29		lda $29				lda 	objPtr+1
.1beb	c8		iny				iny
.1bec	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1bee	60		rts				rts
.1bef					STRFindLine:
.1bef	85 2a		sta $2a				sta 	zTemp0 						; zTemp0 line number being searched
.1bf1	84 2b		sty $2b				sty 	zTemp0+1
.1bf3	ad 08 05	lda $0508			lda 	compilerEndHigh 			; work backwards through table
.1bf6	85 2d		sta $2d				sta 	zTemp1+1
.1bf8	64 2c		stz $2c				stz 	zTemp1
.1bfa					_STRSearch:
.1bfa	20 31 1c	jsr $1c31			jsr 	_STRPrevLine 				; look at previous record.
.1bfd	a0 01		ldy #$01			ldy 	#1
.1bff	b2 2c		lda ($2c)			lda 	(zTemp1) 					; check table line # >= target
.1c01	c5 2a		cmp $2a				cmp 	zTemp0
.1c03	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c05	e5 2b		sbc $2b				sbc 	zTemp0+1
.1c07	b0 0b		bcs $1c14			bcs 	_STRFound 					; >=
.1c09					_STRNext:
.1c09	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1c0b	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c0d	c9 ff		cmp #$ff			cmp 	#$FF
.1c0f	d0 e9		bne $1bfa			bne 	_STRSearch
.1c11	4c 91 1f	jmp $1f91		jmp	ErrorV_internal
.1c14					_STRFound:
.1c14	b2 2c		lda ($2c)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1c16	45 2a		eor $2a				eor 	zTemp0
.1c18	d0 06		bne $1c20			bne 	_STRDifferent
.1c1a	b2 2c		lda ($2c)			lda 	(zTemp1)
.1c1c	45 2a		eor $2a				eor 	zTemp0
.1c1e	f0 02		beq $1c22			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1c20					_STRDifferent:
.1c20	a9 ff		lda #$ff			lda 	#$FF
.1c22					_STROut:
.1c22	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1c23	69 ff		adc #$ff			adc 	#255
.1c25	08		php				php
.1c26	c8		iny				iny 								; address into YA
.1c27	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c29	48		pha				pha
.1c2a	c8		iny				iny
.1c2b	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c2d	a8		tay				tay
.1c2e	68		pla				pla
.1c2f	28		plp				plp
.1c30	60		rts				rts
.1c31					_STRPrevLine:
.1c31	38		sec				sec 								; move backwards one entry.
.1c32	a5 2c		lda $2c				lda 	zTemp1
.1c34	e9 04		sbc #$04			sbc 	#4
.1c36	85 2c		sta $2c				sta 	zTemp1
.1c38	a5 2d		lda $2d				lda 	zTemp1+1
.1c3a	e9 00		sbc #$00			sbc 	#0
.1c3c	85 2d		sta $2d				sta 	zTemp1+1
.1c3e	60		rts				rts
.1c3f					STRMakeOffset:
.1c3f	18		clc				clc 								; borrow 1
.1c40	e5 28		sbc $28				sbc 	objPtr
.1c42	48		pha				pha
.1c43	98		tya				tya
.1c44	e5 29		sbc $29				sbc 	objPtr+1
.1c46	a8		tay				tay
.1c47	68		pla				pla
.1c48	60		rts				rts
.1c49					CommandNEXT:
.1c49	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1c4c	20 6e 1a	jsr $1a6e			jsr 	CharIsAlpha 				; if not alpha , error
.1c4f	90 0c		bcc $1c5d			bcc 	_CNNoReferenceGiven
.1c51	20 4d 1a	jsr $1a4d			jsr 	GetNext
.1c54	20 99 1d	jsr $1d99			jsr 	GetReferenceTerm 			; figure out the reference.
.1c57	8a		txa				txa 								; reference in YA
.1c58	20 fa 11	jsr $11fa			jsr 	PushIntegerYA 				; write it out.
.1c5b	80 06		bra $1c63			bra 	_CNParametersDone
.1c5d					_CNNoReferenceGiven:
.1c5d	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1c5f	a8		tay				tay
.1c60	20 fa 11	jsr $11fa			jsr 	PushIntegerYA 				; write it out.
.1c63					_CNParametersDone:
.1c63	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1c65	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1c68	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; look for ,
.1c6b	c9 2c		cmp #$2c			cmp 	#","
.1c6d	d0 05		bne $1c74			bne 	_CNExit
.1c6f	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume ,
.1c72	80 d5		bra $1c49			bra 	CommandNEXT 				; and go round.
.1c74					_CNExit:
.1c74	60		rts				rts
.1c75					CommandON:
.1c75	20 58 1a	jsr $1a58			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1c78	48		pha				pha 								; save on stack
.1c79	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1c7b	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1c7d	f0 09		beq $1c88			beq 	_COCreateLoop
.1c7f	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1c81	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1c83	f0 03		beq $1c88			beq 	_COCreateLoop
.1c85	4c 37 1f	jmp $1f37		jmp	ErrorV_syntax
.1c88					_COCreateLoop:
.1c88	8a		txa				txa 								; compile a goto/gosub somewhere
.1c89	da		phx				phx
.1c8a	20 28 1b	jsr $1b28			jsr 	CompileBranchCommand
.1c8d	fa		plx				plx
.1c8e	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace			; ',' follows
.1c91	c9 2c		cmp #$2c			cmp 	#","
.1c93	d0 0a		bne $1c9f			bne 	_COComplete 				; if so, more line numbers
.1c95	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1c97	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1c9a	20 4d 1a	jsr $1a4d			jsr 	GetNext
.1c9d	80 e9		bra $1c88			bra 	_COCreateLoop
.1c9f					_COComplete:
.1c9f	68		pla				pla 								; throw GOTO/GOSUB
.1ca0	60		rts				rts
.1ca1					ParseConstant:
.1ca1	a2 00		ldx #$00			ldx 	#0
.1ca3	20 5d 24	jsr $245d			jsr 	FloatEncodeStart 			; send first
.1ca6					_ParseLoop:
.1ca6	20 3c 1a	jsr $1a3c			jsr 	LookNext 					; send subsequent
.1ca9	20 60 24	jsr $2460			jsr 	FloatEncodeContinue
.1cac	90 05		bcc $1cb3			bcc 	_ParseDone
.1cae	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume it
.1cb1	80 f3		bra $1ca6			bra 	_ParseLoop
.1cb3					_ParseDone:
.1cb3	b5 30		lda $30,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1cb5	29 80		and #$80			and 	#$80
.1cb7	15 6c		ora $6c,x			ora 	NSExponent,x 				; 16 bit int check
.1cb9	15 54		ora $54,x			ora 	NSMantissa2,x
.1cbb	15 60		ora $60,x			ora 	NSMantissa3,x
.1cbd	18		clc				clc
.1cbe	d0 05		bne $1cc5			bne 	_ParseExit 					; exit with CC if need float to compile
.1cc0	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; read into YA.
.1cc2	b4 48		ldy $48,x			ldy		NSMantissa1,x
.1cc4	38		sec				sec
.1cc5					_ParseExit:
.1cc5	60		rts				rts
.1cc6					CommandPRINT:
.1cc6	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace			; what follows ?
.1cc9	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1ccb	f0 1f		beq $1cec			beq 	_CPCheckEnd
.1ccd	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1ccf	f0 16		beq $1ce7			beq 	_CPTabCheckEnd
.1cd1	20 03 1d	jsr $1d03			jsr 	_CPAtEnd 					; check for : and EOL
.1cd4	b0 22		bcs $1cf8			bcs 	_CPExitCR 					; exit with CR
.1cd6	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; so it is something to print
.1cd9	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1cdb	29 40		and #$40			and 	#NSSString 					; if string
.1cdd	d0 02		bne $1ce1			bne 	_CPOut
.1cdf	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1ce1					_CPOut:
.1ce1	8a		txa				txa 								; print that thing
.1ce2	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1ce5	80 df		bra $1cc6			bra 	CommandPRINT 				; and loop round/
.1ce7					_CPTabCheckEnd:
.1ce7	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1ce9	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1cec					_CPCheckEnd:
.1cec	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume it.
.1cef	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; what follows ?
.1cf2	20 03 1d	jsr $1d03			jsr 	_CPAtEnd 					; reached end
.1cf5	90 cf		bcc $1cc6			bcc 	CommandPRINT 				; no, loop back
.1cf7	60		rts				rts
.1cf8					_CPExitCR:
.1cf8	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1cfa	20 0d 12	jsr $120d			jsr 	PushIntegerA
.1cfd	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1cff	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1d02	60		rts				rts
.1d03					_CPAtEnd:
.1d03	c9 00		cmp #$00			cmp 	#0
.1d05	f0 06		beq $1d0d			beq 	_CPIsEnd
.1d07	c9 3a		cmp #$3a			cmp 	#":"
.1d09	f0 02		beq $1d0d			beq 	_CPIsEnd
.1d0b	18		clc				clc
.1d0c	60		rts				rts
.1d0d					_CPIsEnd:
.1d0d	38		sec				sec
.1d0e	60		rts				rts
.1d0f					CommandREAD:
.1d0f	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1d11	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1d13					CommandReadInputCommon:
.1d13	8e 0d 05	stx $050d			stx 	numberPCode
.1d16	8c 0e 05	sty $050e			sty 	stringPCode
.1d19					_CRLoop:
.1d19	20 58 1a	jsr $1a58			jsr 	GetNextNonSpace 			; first char of identifier
.1d1c	20 6e 1a	jsr $1a6e			jsr 	CharIsAlpha 				; check A-Z
.1d1f	90 27		bcc $1d48			bcc 	_CRSyntax
.1d21	20 99 1d	jsr $1d99			jsr 	GetReferenceTerm 			; get the variable.
.1d24	48		pha				pha 								; save type.
.1d25	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1d27	c9 40		cmp #$40			cmp 	#NSSString
.1d29	f0 05		beq $1d30			beq 	_CRString
.1d2b	ad 0d 05	lda $050d			lda 	numberPCode 				; output read/input
.1d2e	80 03		bra $1d33			bra 	_CRHaveType
.1d30					_CRString:
.1d30	ad 0e 05	lda $050e			lda 	stringPCode					; output read$/input$
.1d33					_CRHaveType:
.1d33	20 f1 10	jsr $10f1			jsr 	WriteCodeByte 				; so we have one typed data item.
.1d36	68		pla				pla 								; restore type
.1d37	38		sec				sec  								; write update code.
.1d38	20 4b 1d	jsr $1d4b			jsr 	GetSetVariable
.1d3b	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; , follows ?
.1d3e	c9 2c		cmp #$2c			cmp 	#","
.1d40	d0 05		bne $1d47			bne 	_CRExit 					; if not, end of READ.
.1d42	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume comma
.1d45	80 d2		bra $1d19			bra 	_CRLoop 					; keep going
.1d47					_CRExit:
.1d47	60		rts				rts
.1d48					_CRSyntax:
.1d48	4c 37 1f	jmp $1f37		jmp	ErrorV_syntax
.050d					numberPCode:
>050d							.fill 	1
.050e					stringPCode:
>050e							.fill 	1
.1d4b					GetSetVariable:
.1d4b	08		php				php 								; save direction on stack
.1d4c	c0 00		cpy #$00			cpy 	#$00
.1d4e	30 21		bmi $1d71			bmi 	_GSVReadWriteSpecial
.1d50	c9 00		cmp #$00			cmp 	#$00
.1d52	30 33		bmi $1d87			bmi 	_GSVArray
.1d54	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1d56	4a		lsr a				lsr 	a 							; divide by 2
.1d57	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1d59	28		plp				plp
.1d5a	90 02		bcc $1d5e			bcc 	_GSVNotWrite
.1d5c	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1d5e					_GSVNotWrite:
.1d5e	85 2a		sta $2a				sta 	zTemp0
.1d60	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1d61	4a		lsr a				lsr 	a
.1d62	a8		tay				tay
.1d63	8a		txa				txa
.1d64	6a		ror a				ror 	a
.1d65	aa		tax				tax
.1d66	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1d67	05 2a		ora $2a				ora 	zTemp0 						; which is the first byte of the opcode
.1d69	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1d6c	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1d6d	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1d70	60		rts				rts
.1d71					_GSVReadWriteSpecial:
.1d71	28		plp				plp
.1d72	b0 10		bcs $1d84			bcs 	_GSVSyntax
.1d74	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1d76	f0 06		beq $1d7e			beq 	_GSVRWString
.1d78	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1d7a	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1d7d	60		rts				rts
.1d7e					_GSVRWString:
.1d7e	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1d80	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1d83	60		rts				rts
.1d84					_GSVSyntax:
.1d84	4c 37 1f	jmp $1f37		jmp	ErrorV_syntax
.1d87					_GSVArray:
.1d87	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1d89	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1d8a	4a		lsr a				lsr 	a
.1d8b	4a		lsr a				lsr 	a
.1d8c	4a		lsr a				lsr 	a
.1d8d	4a		lsr a				lsr 	a
.1d8e	28		plp				plp 								; if writing array then set bit 2.
.1d8f	90 02		bcc $1d93			bcc 	_GSVANotWrite
.1d91	09 04		ora #$04			ora 	#4
.1d93					_GSVANotWrite:
.1d93	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1d95	20 f1 10	jsr $10f1			jsr 	WriteCodeByte 				; and write it out
.1d98	60		rts				rts
.1d99					GetReferenceTerm:
.1d99	20 bd 1a	jsr $1abd			jsr 	ExtractVariableName 		; get name & type info
.1d9c	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1d9e	30 10		bmi $1db0			bmi 	_GRTArray
.1da0	da		phx				phx 								; save type on stack
.1da1	20 b5 14	jsr $14b5			jsr 	FindVariable 				; find it
.1da4	b0 06		bcs $1dac			bcs 	_GRTNoCreate 				; create if required.
.1da6	20 3f 12	jsr $123f			jsr 	CreateVariableRecord 		; create a variable.
.1da9	20 94 12	jsr $1294			jsr 	AllocateBytesForType 		; allocate memory for it
.1dac					_GRTNoCreate:
.1dac	68		pla				pla 								; get type back, strip out type information.
.1dad	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1daf	60		rts				rts
.1db0					_GRTArray:
.1db0	da		phx				phx 								; save type information
.1db1	20 b5 14	jsr $14b5			jsr 	FindVariable 				; read its data, the base address in YX
.1db4	90 18		bcc $1dce			bcc 	_GRTUndeclared 				; undeclared array.
.1db6	da		phx				phx 								; save base address
.1db7	5a		phy				phy
.1db8	20 8b 13	jsr $138b			jsr 	OutputIndexGroup 			; create an index group and generate them
.1dbb	7a		ply				ply 								; get the array base address into YX
.1dbc	fa		plx				plx
.1dbd	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1dbf	18		clc				clc
.1dc0	20 4b 1d	jsr $1d4b			jsr 	GetSetVariable 				; load the address of the array structure.
.1dc3	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1dc5	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1dc8	68		pla				pla 								; and the type data into A
.1dc9	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1dcb	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1dcd	60		rts				rts
.1dce					_GRTUndeclared:
.1dce	4c ee 1f	jmp $1fee		jmp	ErrorV_undeclared
.1dd1					CommandREM:
.1dd1	20 3c 1a	jsr $1a3c			jsr 	LookNext
.1dd4	f0 05		beq $1ddb			beq 	_CRExit
.1dd6	20 4d 1a	jsr $1a4d			jsr 	GetNext
.1dd9	80 f6		bra $1dd1			bra 	CommandREM
.1ddb					_CRExit:
.1ddb	60		rts				rts
.1ddc					STRReset:
.1ddc	ad 07 05	lda $0507			lda	 	compilerStartHigh 			; set up the two table pointers
.1ddf	8d 12 05	sta $0512			sta 	variableListEnd+1
.1de2	9c 11 05	stz $0511			stz 	variableListEnd
.1de5	ad 08 05	lda $0508			lda 	compilerEndHigh
.1de8	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1deb	9c 0f 05	stz $050f			stz 	lineNumberTable
.1dee	ad 11 05	lda $0511			lda 	variableListEnd
.1df1	85 2b		sta $2b				sta 	zTemp0+1
.1df3	64 2a		stz $2a				stz 	zTemp0
.1df5	a9 00		lda #$00			lda 	#0
.1df7	92 2a		sta ($2a)			sta 	(zTemp0)
.1df9	a9 00		lda #$00			lda 	#((0) & $FF)
.1dfb	8d 13 05	sta $0513			sta 	0+freeVariableMemory
.1dfe	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1e00	8d 14 05	sta $0514			sta 	1+freeVariableMemory
.1e03	60		rts				rts
.050f					lineNumberTable:
>050f							.fill 	2
.0511					variableListEnd:
>0511							.fill 	2
.0513					freeVariableMemory:
>0513							.fill 	2
.1e04					CompileTerm:
.1e04	20 58 1a	jsr $1a58			jsr 	GetNextNonSpace 			; get first non space character.
.1e07	30 72		bmi $1e7b			bmi 	_CTUnaryFunctions
.1e09	20 62 1a	jsr $1a62			jsr 	CharIsDigit 				; found a number
.1e0c	b0 3a		bcs $1e48			bcs 	_CTDigit
.1e0e	c9 2e		cmp #$2e			cmp 	#"."
.1e10	f0 36		beq $1e48			beq 	_CTDigit
.1e12	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1e14	f0 43		beq $1e59			beq 	_CTString
.1e16	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1e18	f0 28		beq $1e42			beq 	_CTOtherBase
.1e1a	c9 24		cmp #$24			cmp 	#"$"
.1e1c	f0 24		beq $1e42			beq 	_CTOtherBase
.1e1e	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1e20	f0 17		beq $1e39			beq 	_CTBrackets
.1e22	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1e24	90 10		bcc $1e36			bcc 	_CTSyntax
.1e26	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1e28	b0 0c		bcs $1e36			bcs 	_CTSyntax
.1e2a	20 99 1d	jsr $1d99			jsr 	GetReferenceTerm 			; figure out what it is.
.1e2d	48		pha				pha 								; save type on stack
.1e2e	18		clc				clc 								; read it
.1e2f	20 4b 1d	jsr $1d4b			jsr 	GetSetVariable
.1e32	68		pla				pla
.1e33	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1e35	60		rts				rts
.1e36					_CTSyntax:
.1e36	4c 37 1f	jmp $1f37		jmp	ErrorV_syntax
.1e39					_CTBrackets:
.1e39	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0
.1e3c	48		pha				pha
.1e3d	20 50 11	jsr $1150			jsr 	CheckNextRParen
.1e40	68		pla				pla
.1e41	60		rts				rts
.1e42					_CTOtherBase:
.1e42	20 9f 10	jsr $109f			jsr 	InlineNonDecimal 			; non decimal constant handler
.1e45	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e47	60		rts				rts
.1e48					_CTDigit:
.1e48	20 a1 1c	jsr $1ca1			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1e4b	90 06		bcc $1e53			bcc	 	_CTFloat 					; have a float or long int.
.1e4d	20 fa 11	jsr $11fa			jsr 	PushIntegerYA 				; code to push on stack
.1e50	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e52	60		rts				rts
.1e53					_CTFloat:
.1e53	20 1c 12	jsr $121c			jsr 	PushFloat  					; code to push float
.1e56	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1e58	60		rts				rts
.1e59					_CTString:
.1e59	20 25 11	jsr $1125			jsr 	BufferClear 				; copy it to the buffer
.1e5c					_CTStringLoop:
.1e5c	20 3c 1a	jsr $1a3c			jsr 	LookNext 					; reached EOL/EOS
.1e5f	f0 d5		beq $1e36			beq 	_CTSyntax
.1e61	c9 22		cmp #$22			cmp 	#'"'
.1e63	f0 08		beq $1e6d			beq 	_CTStringDone
.1e65	20 29 11	jsr $1129			jsr 	BufferWrite 				; write and consume
.1e68	20 4d 1a	jsr $1a4d			jsr 	GetNext
.1e6b	80 ef		bra $1e5c			bra 	_CTStringLoop
.1e6d					_CTStringDone:
.1e6d	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume closing quote.
.1e70	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1e72	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1e75	20 35 11	jsr $1135			jsr 	BufferOutput
.1e78	a9 40		lda #$40			lda 	#NSSString 					; string type
.1e7a	60		rts				rts
.1e7b					_CTUnaryFunctions:
.1e7b	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1e7d	f0 0a		beq $1e89			beq 	_CTNegation
.1e7f	a2 e7		ldx #$e7			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1e81	a0 17		ldy #$17			ldy 	#UnaryTables >> 8
.1e83	20 e1 18	jsr $18e1			jsr 	GeneratorProcess
.1e86	90 ae		bcc $1e36			bcc		_CTSyntax
.1e88	60		rts				rts
.1e89					_CTNegation:
.1e89	20 04 1e	jsr $1e04			jsr 	CompileTerm 				; compile a term.
.1e8c	48		pha				pha
.1e8d	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1e8f	c9 00		cmp #$00			cmp 	#NSSIFloat
.1e91	d0 07		bne $1e9a			bne 	_CTType 					; error
.1e93	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1e95	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1e98	68		pla				pla 								; return original type.
.1e99	60		rts				rts
.1e9a					_CTType:
.1e9a	4c 47 1f	jmp $1f47		jmp	ErrorV_type
.1e9d					CommandWAIT:
.1e9d	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace
.1ea0	c9 2c		cmp #$2c			cmp 	#","
.1ea2	f0 10		beq $1eb4			beq 	_CWThirdParameter
.1ea4	a9 00		lda #$00			lda 	#0
.1ea6	20 0d 12	jsr $120d			jsr 	PushIntegerA
.1ea9					_CWExit:
.1ea9	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1eab	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1eae	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1eb0	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1eb3	60		rts				rts
.1eb4					_CWThirdParameter:
.1eb4	20 4d 1a	jsr $1a4d			jsr 	GetNext
.1eb7	20 fd 13	jsr $13fd			jsr 	CompileExpressionAtA
.1eba	29 40		and #$40			and 	#NSSTypeMask
.1ebc	c9 00		cmp #$00			cmp 	#NSSIFloat
.1ebe	f0 e9		beq $1ea9			beq 	_CWExit
.1ec0	4c 47 1f	jmp $1f47		jmp	ErrorV_type
.1ec3					CommandCMD:
.1ec3	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.1ec5	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1ec8	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; followed by a , ?
.1ecb	c9 2c		cmp #$2c			cmp 	#","
.1ecd	d0 06		bne $1ed5			bne 	_CCMDExit
.1ecf	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume comma.
.1ed2	20 c6 1c	jsr $1cc6			jsr 	CommandPRINT 				; do the print code
.1ed5					_CCMDExit:
.1ed5	60		rts				rts
.1ed6					CommandOPEN:
.1ed6	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; followed by a , ?
.1ed9	c9 2c		cmp #$2c			cmp 	#","
.1edb	d0 15		bne $1ef2			bne 	_COTwoDefaults
.1edd	20 4d 1a	jsr $1a4d			jsr 	GetNext 					; consume comma
.1ee0	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1ee3	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1ee5	f0 1e		beq $1f05			beq 	_COThreeIntegers
.1ee7	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1ee9	20 0d 12	jsr $120d			jsr 	PushIntegerA
.1eec	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1eee	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1ef1	60		rts				rts
.1ef2					_COTwoDefaults:
.1ef2	a9 00		lda #$00			lda 	#0
.1ef4	20 0d 12	jsr $120d			jsr 	PushIntegerA
.1ef7					_COCompileNullString:
.1ef7	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1ef9	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1efc	a9 00		lda #$00			lda 	#0
.1efe	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1f01	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1f04	60		rts				rts
.1f05					_COThreeIntegers:
.1f05	20 3f 1a	jsr $1a3f			jsr 	LookNextNonSpace 			; is there a ,
.1f08	c9 2c		cmp #$2c			cmp 	#","
.1f0a	d0 eb		bne $1ef7			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1f0c	20 4d 1a	jsr $1a4d			jsr 	GetNext
.1f0f	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; should be a filename
.1f12	29 40		and #$40			and 	#NSSString
.1f14	f0 01		beq $1f17			beq 	_COType
.1f16	60		rts				rts
.1f17					_COType:
.1f17	4c 47 1f	jmp $1f47		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					objPtr:
>0028							.fill 	2
.002a					zTemp0:
>002a							.fill 	2
.002c					zTemp1:
>002c							.fill 	2
.002e					zTemp2:
>002e							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1f1a					ErrorV_range:
.1f1a	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f1d	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f25	41 4e 47 45 00
.1f2a					ErrorV_value:
.1f2a	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f2d	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f35	45 00
.1f37					ErrorV_syntax:
.1f37	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f3a	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f42	52 52 4f 52 00
.1f47					ErrorV_type:
.1f47	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f4a	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f52	4d 41 54 43 48 00
.1f58					ErrorV_unimplemented:
.1f58	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f5b	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f63	45 4d 45 4e 54 45 44 00
.1f6b					ErrorV_assert:
.1f6b	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f6e	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f76	41 49 4c 00
.1f7a					ErrorV_line:
.1f7a	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f7d	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f85	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f91					ErrorV_internal:
.1f91	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f94	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f9c	20 45 52 52 4f 52 00
.1fa3					ErrorV_divzero:
.1fa3	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1fa6	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fae	59 20 5a 45 52 4f 00
.1fb5					ErrorV_structure:
.1fb5	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1fb8	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fc0	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fcc					ErrorV_stop:
.1fcc	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1fcf	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fd7	53 54 4f 50 50 45 44 00
.1fdf					ErrorV_data:
.1fdf	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1fe2	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fea	41 54 41 00
.1fee					ErrorV_undeclared:
.1fee	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1ff1	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1ff9	41 52 52 41 59 00
.1fff					ErrorV_redefine:
.1fff	20 b3 13	jsr $13b3		jsr	ErrorHandler
>2002	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>200a	44 45 46 49 4e 45 44 00
.2012					ErrorV_index:
.2012	20 b3 13	jsr $13b3		jsr	ErrorHandler
>2015	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>201d	59 20 49 4e 44 45 58 00
.2025					ErrorV_memory:
.2025	20 b3 13	jsr $13b3		jsr	ErrorHandler
>2028	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2030	45 4d 4f 52 59 00
.2036					ErrorV_channel:
.2036	20 b3 13	jsr $13b3		jsr	ErrorHandler
>2039	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2041	54 50 55 54 20 45 52 52 4f 52 00
.204c					MoveObjectForward:
.204c	b2 28		lda ($28)			lda 	(objPtr) 					; get next
.204e	c9 ff		cmp #$ff			cmp 	#$FF
.2050	f0 36		beq $2088			beq 	_MOFEnd
.2052	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.2054	90 24		bcc $207a			bcc 	_MOFAdvance1 				; forward 1
.2056	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.2058	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.205a	90 20		bcc $207c			bcc 	_MOFAdvanceY
.205c	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.205e	90 1a		bcc $207a			bcc 	_MOFAdvance1 				; forward 1
.2060	a8		tay				tay 								; read the size.
.2061	b9 c6 1f	lda $1fc6,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.2064	a8		tay				tay
.2065	c8		iny				iny 								; add 1 for the system token.
.2066	d0 14		bne $207c			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2068	a0 01		ldy #$01			ldy 	#1 							; get length byte
.206a	b1 28		lda ($28),y			lda 	(objPtr),y
.206c	a8		tay				tay 								; into Y.
.206d	18		clc				clc
.206e	a5 28		lda $28				lda 	objPtr						; add 2 to the object pointer
.2070	69 02		adc #$02			adc 	#2
.2072	85 28		sta $28				sta 	objPtr
.2074	90 02		bcc $2078			bcc 	_MOFNoCarry1
.2076	e6 29		inc $29				inc 	objPtr+1
.2078					_MOFNoCarry1:
.2078	80 02		bra $207c			bra 	_MOFAdvanceY
.207a					_MOFAdvance1:
.207a	a0 01		ldy #$01			ldy 	#1
.207c					_MOFAdvanceY:
.207c	98		tya				tya 								; add Y to objPtr
.207d	18		clc				clc
.207e	65 28		adc $28				adc 	objPtr
.2080	85 28		sta $28				sta 	objPtr
.2082	90 02		bcc $2086			bcc 	_MOFNoCarry2
.2084	e6 29		inc $29				inc 	objPtr+1
.2086					_MOFNoCarry2:
.2086	18		clc				clc 								; not completed.
.2087	60		rts				rts
.2088					_MOFEnd:
.2088	e6 28		inc $28				inc 	objPtr
.208a	d0 02		bne $208e			bne 	_MOFENoCarry
.208c	e6 29		inc $29				inc 	objPtr+1
.208e					_MOFENoCarry:
.208e	38		sec				sec
.208f	60		rts				rts
.2090					MOFSizeTable:
>2090	01					.byte	1         	; $ca .shift
>2091	01					.byte	1         	; $cb .byte
>2092	02					.byte	2         	; $cc .word
>2093	05					.byte	5         	; $cd .float
>2094	ff					.byte	255       	; $ce .string
>2095	ff					.byte	255       	; $cf .data
>2096	02					.byte	2         	; $d0 .goto
>2097	02					.byte	2         	; $d1 .gosub
>2098	02					.byte	2         	; $d2 .goto.z
>2099	02					.byte	2         	; $d3 .goto.nz
>209a	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0030					NSStatus:
>0030							.fill 	MathStackSize
.003c					NSMantissa0:
>003c							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0048					NSMantissa1:
>0048							.fill 	MathStackSize
.0054					NSMantissa2:
>0054							.fill 	MathStackSize
.0060					NSMantissa3:
>0060							.fill 	MathStackSize
.006c					NSExponent:
>006c							.fill 	MathStackSize
.0515					numberBuffer:
>0515							.fill 	34
.209b					FloatSubtract:
.209b	b5 30		lda $30,x			lda 	NSStatus,x 					; negate top of stack
.209d	49 80		eor #$80			eor 	#$80
.209f	95 30		sta $30,x			sta 	NSStatus,x					; and fall through.
.20a1					FloatAdd:
.20a1	ca		dex				dex
.20a2	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised.
.20a4	15 6d		ora $6d,x			ora 	NSExponent+1,x
.20a6	15 60		ora $60,x			ora 	NSMantissa3,x
.20a8	15 61		ora $61,x			ora 	NSMantissa3+1,x
.20aa	d0 04		bne $20b0			bne 	_FAUseFloat
.20ac	20 3d 24	jsr $243d			jsr 	FloatInt32Add 				; use the int32 one.
.20af	60		rts				rts
.20b0					_FAUseFloat:
.20b0	20 d2 23	jsr $23d2			jsr 	FloatNormalise 				; normalise S[X]
.20b3	f0 51		beq $2106			beq 	_FAReturn1
.20b5	e8		inx				inx 								; normalise S[X+1]
.20b6	20 d2 23	jsr $23d2			jsr 	FloatNormalise
.20b9	ca		dex				dex
.20ba	c9 00		cmp #$00			cmp 	#0
.20bc	f0 60		beq $211e			beq 	_FAExit 					; if so, just return A
.20be	b5 6c		lda $6c,x			lda 	NSExponent,x 				; are the exponents the same ?
.20c0	d5 6d		cmp $6d,x			cmp 	NSExponent+1,x
.20c2	f0 18		beq $20dc			beq 	_FAExponentsEqual
.20c4	b5 6c		lda $6c,x			lda 	NSExponent,x 				; work out the larger exponent
.20c6	a8		tay				tay
.20c7	38		sec				sec 								; do a signed comparison of the exponents.
.20c8	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.20ca	50 02		bvc $20ce			bvc 	_FANoSignedChange
.20cc	49 80		eor #$80			eor 	#$80
.20ce					_FANoSignedChange:
.20ce	29 80		and #$80			and 	#$80
.20d0	10 02		bpl $20d4			bpl 	_FAHaveMax
.20d2	b4 6d		ldy $6d,x			ldy 	NSExponent+1,x
.20d4					_FAHaveMax:
.20d4	20 1f 21	jsr $211f			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20d7	e8		inx				inx
.20d8	20 1f 21	jsr $211f			jsr 	_FAShiftToExponent
.20db	ca		dex				dex
.20dc					_FAExponentsEqual:
.20dc	b5 30		lda $30,x			lda 	NSStatus,x 					; are the signs the same
.20de	55 31		eor $31,x			eor 	NSStatus+1,x
.20e0	30 0e		bmi $20f0			bmi 	_FADifferentSigns
.20e2	20 09 24	jsr $2409			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20e5	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20e7	10 35		bpl $211e			bpl 	_FAExit 					; if no, we are done.
.20e9	20 96 26	jsr $2696			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20ec	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump the exponent and exit
.20ee	80 2e		bra $211e			bra 	_FAExit
.20f0					_FADifferentSigns:
.20f0	20 23 24	jsr $2423			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20f3	b5 60		lda $60,x			lda 	NSMantissa3,x 				; is the result negative ?
.20f5	10 06		bpl $20fd			bpl 	_FACheckZero 				; if no, check for -0
.20f7	20 3f 26	jsr $263f			jsr 	FloatNegate 					; netate result
.20fa	20 46 26	jsr $2646			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20fd					_FACheckZero:
.20fd	20 9f 26	jsr $269f			jsr 	FloatIsZero	 				; check for -0
.2100	d0 1c		bne $211e			bne 	_FAExit
.2102	74 30		stz $30,x			stz 	NSStatus,x
.2104	80 18		bra $211e			bra 	_FAExit
.2106					_FAReturn1:
.2106	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.2108	95 3c		sta $3c,x			sta 	NSMantissa0,x
.210a	b5 49		lda $49,x			lda 	NSMantissa1+1,x
.210c	95 48		sta $48,x			sta 	NSMantissa1,x
.210e	b5 55		lda $55,x			lda 	NSMantissa2+1,x
.2110	95 54		sta $54,x			sta 	NSMantissa2,x
.2112	b5 61		lda $61,x			lda 	NSMantissa3+1,x
.2114	95 60		sta $60,x			sta 	NSMantissa3,x
.2116	b5 6d		lda $6d,x			lda 	NSExponent+1,x
.2118	95 6c		sta $6c,x			sta 	NSExponent,x
.211a	b5 31		lda $31,x			lda 	NSStatus+1,x
.211c	95 30		sta $30,x			sta 	NSStatus,x
.211e					_FAExit:
.211e	60		rts				rts
.211f					_FAShiftToExponent:
.211f					_FAShiftToExponent2:
.211f	98		tya				tya 								; compare Y to exponent
.2120	d5 6c		cmp $6c,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2122	f0 07		beq $212b			beq 	_FASEExit 					; exit if so.
.2124	20 96 26	jsr $2696			jsr 	FloatShiftRight	 			; shift the mantissa right
.2127	f6 6c		inc $6c,x			inc 	NSExponent,x 				; increment exponent
.2129	80 f4		bra $211f			bra 	_FAShiftToExponent2
.212b					_FASEExit:
.212b	60		rts				rts
.212c					CompareEqual:
.212c	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.212e	d0 09		bne $2139			bne 	ReturnFalse
.2130					ReturnTrue:
.2130	a9 01		lda #$01			lda 	#1
.2132	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2134	a9 80		lda #$80			lda 	#$80
.2136	95 30		sta $30,x			sta 	NSStatus,x
.2138	60		rts				rts
.2139					ReturnFalse:
.2139	74 3c		stz $3c,x			stz 	NSMantissa0,x
.213b	60		rts				rts
.213c					CompareNotEqual:
.213c	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.213e	d0 f0		bne $2130			bne 	ReturnTrue
.2140	80 f7		bra $2139			bra 	ReturnFalse
.2142					CompareLess:
.2142	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2144	c9 ff		cmp #$ff			cmp 	#$FF
.2146	f0 e8		beq $2130			beq 	ReturnTrue
.2148	80 ef		bra $2139			bra 	ReturnFalse
.214a					CompareGreater:
.214a	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.214c	c9 01		cmp #$01			cmp 	#$01
.214e	f0 e0		beq $2130			beq 	ReturnTrue
.2150	80 e7		bra $2139			bra 	ReturnFalse
.2152					CompareLessEqual:
.2152	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2154	c9 01		cmp #$01			cmp 	#$01
.2156	d0 d8		bne $2130			bne 	ReturnTrue
.2158	80 df		bra $2139			bra 	ReturnFalse
.215a					CompareGreaterEqual:
.215a	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.215c	c9 ff		cmp #$ff			cmp 	#$FF
.215e	d0 d0		bne $2130			bne 	ReturnTrue
.2160	80 d7		bra $2139			bra 	ReturnFalse
.2162					FloatCompare:
.2162	b5 6c		lda $6c,x			lda 	NSExponent,x 				; float comparison.
.2164	15 6b		ora $6b,x			ora 	NSExponent-1,x 				; integer if both integer.
.2166	48		pha				pha
.2167	20 9b 20	jsr $209b			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.216a	68		pla				pla
.216b	d0 0c		bne $2179			bne 	_FCCompareFloat
.216d	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.216f	15 48		ora $48,x			ora 	NSMantissa1,x
.2171	15 54		ora $54,x			ora 	NSMantissa2,x
.2173	15 60		ora $60,x			ora 	NSMantissa3,x
.2175	f0 14		beq $218b			beq 	_FCExit 					; if zero, return zero
.2177	80 0a		bra $2183			bra 	_FCSign
.2179					_FCCompareFloat:
.2179	b5 48		lda $48,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.217b	29 f0		and #$f0			and 	#$F0
.217d	15 54		ora $54,x			ora 	NSMantissa2,x
.217f	15 60		ora $60,x			ora 	NSMantissa3,x
.2181	f0 08		beq $218b			beq 	_FCExit 					; zero, so approximately identical
.2183					_FCSign:
.2183	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2185	34 30		bit $30,x			bit 	NSStatus,x
.2187	10 02		bpl $218b			bpl 	_FCExit
.2189					_FCNegative:
.2189	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.218b					_FCExit:
.218b	20 7f 26	jsr $267f			jsr 	FloatSetByte 				; set the result 255,0,1
.218e	60		rts				rts
.218f					FloatScalarTable:
>218f	66 66 66 66				.dword $66666666 ; 0.1
>2193	de					.byte $de
>2194	1f 85 eb 51				.dword $51eb851f ; 0.01
>2198	db					.byte $db
>2199	4c 37 89 41				.dword $4189374c ; 0.001
>219d	d8					.byte $d8
>219e	ac 8b db 68				.dword $68db8bac ; 0.0001
>21a2	d4					.byte $d4
>21a3	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>21a7	d1					.byte $d1
>21a8	83 de 1b 43				.dword $431bde83 ; 1e-06
>21ac	ce					.byte $ce
>21ad	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21b1	ca					.byte $ca
>21b2	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21b6	c7					.byte $c7
>21b7	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21bb	c4					.byte $c4
>21bc	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21c0	c0					.byte $c0
>21c1	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21c5	bd					.byte $bd
.21c6					FloatDivide:
.21c6	48		pha				pha
.21c7	20 d2 23	jsr $23d2			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21ca	ca		dex				dex
.21cb	c9 00		cmp #$00			cmp 	#0
.21cd	f0 1e		beq $21ed			beq 	_FDZero
.21cf	20 d2 23	jsr $23d2			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21d2	f0 16		beq $21ea			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21d4	20 35 22	jsr $2235			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21d7	20 02 22	jsr $2202			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21da	20 d2 23	jsr $23d2			jsr		FloatNormalise 				; renormalise
.21dd	20 c8 23	jsr $23c8			jsr 	FloatCalculateSign 			; calculate result sign
.21e0	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent
.21e2	38		sec				sec
.21e3	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.21e5	38		sec				sec
.21e6	e9 1e		sbc #$1e			sbc 	#30
.21e8	95 6c		sta $6c,x			sta 	NSExponent,x
.21ea					_FDExit:
.21ea	68		pla				pla
.21eb	18		clc				clc
.21ec	60		rts				rts
.21ed					_FDZero:
.21ed	68		pla				pla
.21ee	38		sec				sec
.21ef	60		rts				rts
.21f0					DivideInt32:
.21f0	20 b8 22	jsr $22b8			jsr 	FloatIntegerPart 			; make both integers
.21f3	ca		dex				dex
.21f4	20 b8 22	jsr $22b8			jsr 	FloatIntegerPart
.21f7	20 13 22	jsr $2213			jsr 	Int32Divide 				; divide
.21fa	20 02 22	jsr $2202			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21fd	20 c8 23	jsr $23c8			jsr 	FloatCalculateSign 			; calculate result sign
.2200	18		clc				clc
.2201	60		rts				rts
.2202					NSMCopyPlusTwoToZero:
.2202	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.2204	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2206	b5 4a		lda $4a,x			lda 	NSMantissa1+2,x
.2208	95 48		sta $48,x			sta 	NSMantissa1,x
.220a	b5 56		lda $56,x			lda 	NSMantissa2+2,x
.220c	95 54		sta $54,x			sta 	NSMantissa2,x
.220e	b5 62		lda $62,x			lda 	NSMantissa3+2,x
.2210	95 60		sta $60,x			sta 	NSMantissa3,x
.2212	60		rts				rts
.2213					Int32Divide:
.2213	48		pha				pha 								; save AXY
.2214	5a		phy				phy
.2215	20 60 26	jsr $2660			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2218	20 79 26	jsr $2679			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.221b	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.221d					_I32DivideLoop:
.221d	e8		inx				inx
.221e	e8		inx				inx
.221f	20 8c 26	jsr $268c			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2222	ca		dex				dex
.2223	ca		dex				dex
.2224	20 8d 26	jsr $268d			jsr 	FloatRotateLeft
.2227	20 53 22	jsr $2253			jsr 	FloatDivideCheck 			; check if subtract possible
.222a	90 02		bcc $222e			bcc 	_I32DivideNoCarryIn
.222c	f6 3e		inc $3e,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.222e					_I32DivideNoCarryIn:
.222e	88		dey				dey 								; loop round till division completed.
.222f	d0 ec		bne $221d			bne 	_I32DivideLoop
.2231	7a		ply				ply 								; restore AXY and exit
.2232	68		pla				pla
.2233	18		clc				clc
.2234	60		rts				rts
.2235					Int32ShiftDivide:
.2235	48		pha				pha 								; save AY
.2236	5a		phy				phy
.2237	e8		inx				inx 								; clear S[X+2]
.2238	e8		inx				inx
.2239	20 7d 26	jsr $267d			jsr 	FloatSetZero
.223c	ca		dex				dex
.223d	ca		dex				dex
.223e	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2240					_I32SDLoop:
.2240	20 53 22	jsr $2253			jsr 	FloatDivideCheck 			; check if subtract possible
.2243	e8		inx				inx
.2244	e8		inx				inx
.2245	20 8d 26	jsr $268d			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.2248	ca		dex				dex
.2249	ca		dex				dex
.224a	20 8d 26	jsr $268d			jsr 	FloatRotateLeft
.224d	88		dey				dey 	 							; do 31 times
.224e	d0 f0		bne $2240			bne 	_I32SDLoop
.2250	7a		ply				ply 								; restore AY and exit
.2251	68		pla				pla
.2252	60		rts				rts
.2253					FloatDivideCheck:
.2253	20 23 24	jsr $2423			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.2256	b0 04		bcs $225c			bcs 	_DCSExit 					; if carry set, then could do, exit
.2258	20 09 24	jsr $2409			jsr 	FloatAddTopTwoStack 		; add it back in
.225b	18		clc				clc 								; and return False
.225c					_DCSExit:
.225c	60		rts				rts
.225d					FloatFractionalPart:
.225d	5a		phy				phy
.225e	b5 30		lda $30,x			lda 	NSStatus,x 					; take absolute value
.2260	29 7f		and #$7f			and 	#$7F
.2262	95 30		sta $30,x			sta 	NSStatus,x
.2264	20 d2 23	jsr $23d2			jsr 	FloatNormalise
.2267	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2269	38		sec				sec
.226a	e9 e0		sbc #$e0			sbc 	#$E0
.226c	90 29		bcc $2297			bcc 	_FFPExit 					; already fractional
.226e	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2270	b0 22		bcs $2294			bcs 	_FFPZero
.2272	a8		tay				tay 								; put count to do in Y
.2273	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do each in turn.
.2275	20 9c 22	jsr $229c			jsr 	_FFPPartial
.2278	95 60		sta $60,x			sta 	NSMantissa3,x
.227a	b5 54		lda $54,x			lda 	NSMantissa2,x
.227c	20 9c 22	jsr $229c			jsr 	_FFPPartial
.227f	95 54		sta $54,x			sta 	NSMantissa2,x
.2281	b5 48		lda $48,x			lda 	NSMantissa1,x
.2283	20 9c 22	jsr $229c			jsr 	_FFPPartial
.2286	95 48		sta $48,x			sta 	NSMantissa1,x
.2288	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.228a	20 9c 22	jsr $229c			jsr 	_FFPPartial
.228d	95 3c		sta $3c,x			sta 	NSMantissa0,x
.228f	20 9f 26	jsr $269f			jsr 	FloatIsZero 					; zeroed check.
.2292	d0 03		bne $2297			bne 	_FFPExit
.2294					_FFPZero:
.2294	20 7d 26	jsr $267d			jsr 	FloatSetZero
.2297					_FFPExit:
.2297	20 d2 23	jsr $23d2			jsr 	FloatNormalise
.229a	7a		ply				ply
.229b	60		rts				rts
.229c					_FFPPartial:
.229c	c0 00		cpy #$00			cpy 	#0 							; no more to do
.229e	f0 17		beq $22b7			beq 	_FFFPPExit
.22a0	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.22a2	b0 0c		bcs $22b0			bcs 	_FFFPPWholeByte
.22a4	5a		phy				phy
.22a5					_FFFPPLeft:
.22a5	0a		asl a				asl 	a
.22a6	88		dey				dey
.22a7	d0 fc		bne $22a5			bne 	_FFFPPLeft
.22a9	7a		ply				ply
.22aa					_FFFPPRight:
.22aa	4a		lsr a				lsr 	a
.22ab	88		dey				dey
.22ac	d0 fc		bne $22aa			bne 	_FFFPPRight
.22ae	80 07		bra $22b7			bra 	_FFFPPExit
.22b0					_FFFPPWholeByte:
.22b0	98		tya				tya 								; subtract 8 from count
.22b1	38		sec				sec
.22b2	e9 08		sbc #$08			sbc 	#8
.22b4	a8		tay				tay
.22b5	a9 00		lda #$00			lda 	#0 							; and clear all
.22b7					_FFFPPExit:
.22b7	60		rts				rts
.22b8					FloatIntegerPart:
.22b8	48		pha				pha
.22b9	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.22bb	f0 1d		beq $22da			beq 	_FIPExit 					; if so do nothing
.22bd	20 9f 26	jsr $269f			jsr 	FloatIsZero 				; is it zero ?
.22c0	f0 15		beq $22d7			beq 	_FIPZero 					; if so return zero.
.22c2	20 d2 23	jsr $23d2			jsr 	FloatNormalise 				; normalise
.22c5	f0 10		beq $22d7			beq 	_FIPZero 					; normalised to zero, exit zero
.22c7					_FIPShift:
.22c7	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22c9	10 07		bpl $22d2			bpl 	_FIPCheckZero
.22cb	20 96 26	jsr $2696			jsr 	FloatShiftRight 			; shift mantissa right
.22ce	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.22d0	80 f5		bra $22c7			bra 	_FIPShift
.22d2					_FIPCheckZero:
.22d2	20 9f 26	jsr $269f			jsr 	FloatIsZero 				; avoid -0 problem
.22d5	d0 03		bne $22da			bne 	_FIPExit 					; set to zero if mantissa zero.
.22d7					_FIPZero:
.22d7	20 7d 26	jsr $267d			jsr 	FloatSetZero
.22da					_FIPExit:
.22da	68		pla				pla
.22db	60		rts				rts
.22dc					FloatIntegerPartDown:
.22dc	48		pha				pha
.22dd	5a		phy				phy
.22de	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.22e0	f0 36		beq $2318			beq 	_FIPExit 					; if so do nothing
.22e2	20 9f 26	jsr $269f			jsr 	FloatIsZero 				; is it zero ?
.22e5	f0 2e		beq $2315			beq 	_FIPZero 					; if so return zero.
.22e7	20 d2 23	jsr $23d2			jsr 	FloatNormalise 				; normalise
.22ea	f0 29		beq $2315			beq 	_FIPZero 					; normalised to zero, exit zero
.22ec	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22ee					_FIPShift:
.22ee	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22f0	10 0a		bpl $22fc			bpl 	_FIPCheckDown
.22f2	20 96 26	jsr $2696			jsr 	FloatShiftRight 			; shift mantissa right
.22f5	90 01		bcc $22f8			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22f7	c8		iny				iny
.22f8					_FIPNoFrac:
.22f8	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.22fa	80 f2		bra $22ee			bra 	_FIPShift
.22fc					_FIPCheckDown:
.22fc	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22fe	f0 10		beq $2310			beq 	_FIPCheckZero
.2300	34 30		bit $30,x			bit 	NSStatus,x 					; +ve
.2302	10 0c		bpl $2310			bpl 	_FIPCheckZero
.2304	e8		inx				inx 								; -ve so round *down*.
.2305	a9 01		lda #$01			lda 	#1
.2307	20 7f 26	jsr $267f			jsr 	FloatSetByte
.230a	20 3f 26	jsr $263f			jsr 	FloatNegate
.230d	20 a1 20	jsr $20a1			jsr 	FloatAdd
.2310					_FIPCheckZero:
.2310	20 9f 26	jsr $269f			jsr 	FloatIsZero 				; avoid -0 problem
.2313	d0 03		bne $2318			bne 	_FIPExit 					; set to zero if mantissa zero.
.2315					_FIPZero:
.2315	20 7d 26	jsr $267d			jsr 	FloatSetZero
.2318					_FIPExit:
.2318	7a		ply				ply
.2319	68		pla				pla
.231a	60		rts				rts
.231b					FloatInt8Multiply:
.231b	5a		phy				phy
.231c	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.231e	a8		tay				tay
.231f	74 3c		stz $3c,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2321					_FI8MLoop:
.2321	98		tya				tya 								; shift right shifter right into carry
.2322	4a		lsr a				lsr 	a
.2323	a8		tay				tay
.2324	90 0d		bcc $2333			bcc 	_FI8MNoAdd
.2326	18		clc				clc
.2327	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2329	75 3d		adc $3d,x			adc 	NSMantissa0+1,x
.232b	95 3c		sta $3c,x			sta 	NSMantissa0,x
.232d	b5 48		lda $48,x			lda 	NSMantissa1,x
.232f	75 49		adc $49,x			adc 	NSMantissa1+1,x
.2331	95 48		sta $48,x			sta 	NSMantissa1,x
.2333					_FI8MNoAdd:
.2333	16 3d		asl $3d,x			asl 	NSMantissa0+1,x 			; shift adder left
.2335	36 49		rol $49,x			rol 	NSMantissa1+1,x
.2337	c0 00		cpy #$00			cpy 	#0
.2339	d0 e6		bne $2321			bne 	_FI8MLoop 					; until right shifter zero.
.233b	7a		ply				ply
.233c	60		rts				rts
.233d					FloatMultiply:
.233d	ca		dex				dex
.233e	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised ?
.2340	15 6d		ora $6d,x			ora 	NSExponent+1,x
.2342	15 60		ora $60,x			ora 	NSMantissa3,x
.2344	15 61		ora $61,x			ora 	NSMantissa3+1,x
.2346	d0 21		bne $2369			bne 	_FMUseFloat
.2348	b5 30		lda $30,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.234a	15 31		ora $31,x			ora 	NSStatus+1,x
.234c	29 80		and #$80			and 	#$80
.234e	15 60		ora $60,x			ora 	NSMantissa3,x
.2350	15 54		ora $54,x			ora 	NSMantissa2,x
.2352	15 48		ora $48,x			ora 	NSMantissa1,x
.2354	15 61		ora $61,x			ora 	NSMantissa3+1,x
.2356	15 55		ora $55,x			ora 	NSMantissa2+1,x
.2358	15 49		ora $49,x			ora 	NSMantissa1+1,x
.235a	d0 04		bne $2360			bne 	_FMInt32
.235c	20 1b 23	jsr $231b			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.235f	60		rts				rts
.2360					_FMInt32:
.2360	20 8a 23	jsr $238a			jsr 	FloatMultiplyShort			; use the int32 one.
.2363	18		clc				clc 								; fix it up if gone out of range
.2364	75 6c		adc $6c,x			adc 	NSExponent,x
.2366	95 6c		sta $6c,x			sta 	NSExponent,x
.2368	60		rts				rts
.2369					_FMUseFloat:
.2369	20 d2 23	jsr $23d2			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.236c	f0 18		beq $2386			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.236e	e8		inx				inx
.236f	20 d2 23	jsr $23d2			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2372	ca		dex				dex
.2373	c9 00		cmp #$00			cmp 	#0
.2375	f0 0c		beq $2383			beq 	_FDSetZero
.2377	20 8a 23	jsr $238a			jsr 	FloatMultiplyShort 			; calculate the result.
.237a	75 6c		adc $6c,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.237c	18		clc				clc
.237d	75 6d		adc $6d,x			adc 	NSExponent+1,x
.237f	95 6c		sta $6c,x			sta 	NSExponent,x
.2381	80 03		bra $2386			bra 	_FDExit
.2383					_FDSetZero:
.2383	20 7d 26	jsr $267d			jsr 	FloatSetZero 				; return 0
.2386					_FDExit:
.2386	20 d2 23	jsr $23d2			jsr 	FloatNormalise 				; normalise the result
.2389	60		rts				rts
.238a					FloatMultiplyShort:
.238a	5a		phy				phy 								; save Y
.238b	20 60 26	jsr $2660			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.238e	20 79 26	jsr $2679			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2391	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2393					_I32MLoop:
.2393	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2395	15 4a		ora $4a,x			ora 	NSMantissa1+2,x
.2397	15 56		ora $56,x			ora 	NSMantissa2+2,x
.2399	15 62		ora $62,x			ora 	NSMantissa3+2,x
.239b	f0 25		beq $23c2			beq 	_I32MExit 					; exit if zero
.239d	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.239f	29 01		and #$01			and 	#1
.23a1	f0 0d		beq $23b0			beq 	_I32MNoAdd
.23a3	20 09 24	jsr $2409			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.23a6	b5 60		lda $60,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.23a8	10 06		bpl $23b0			bpl 	_I32MNoAdd
.23aa					_I32ShiftRight:
.23aa	20 96 26	jsr $2696			jsr 	FloatShiftRight 			; shift S[X] right
.23ad	c8		iny				iny 								; increment shift count
.23ae	80 09		bra $23b9			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23b0					_I32MNoAdd:
.23b0	34 61		bit $61,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23b2	70 f6		bvs $23aa			bvs 	_I32ShiftRight 				; instead.
.23b4	e8		inx				inx
.23b5	20 8c 26	jsr $268c			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23b8	ca		dex				dex
.23b9					_I32MShiftUpper:
.23b9	e8		inx				inx 								; shift S[X+2] right
.23ba	e8		inx				inx
.23bb	20 96 26	jsr $2696			jsr 	FloatShiftRight
.23be	ca		dex				dex
.23bf	ca		dex				dex
.23c0	80 d1		bra $2393			bra 	_I32MLoop 					; try again.
.23c2					_I32MExit:
.23c2	20 c8 23	jsr $23c8			jsr 	FloatCalculateSign
.23c5	98		tya				tya 								; shift in A
.23c6	7a		ply				ply 								; restore Y and exit
.23c7	60		rts				rts
.23c8					FloatCalculateSign:
.23c8	b5 30		lda $30,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23ca	16 30		asl $30,x			asl 	NSStatus,x 					; shift result left
.23cc	55 31		eor $31,x			eor 	NSStatus+1,x
.23ce	0a		asl a				asl 	a 							; shift bit 7 into carry
.23cf	76 30		ror $30,x			ror 	NSStatus,x 					; shift right into status byte.
.23d1	60		rts				rts
.23d2					FloatNormalise:
.23d2	20 9f 26	jsr $269f			jsr 	FloatIsZero 				; if zero exit
.23d5	d0 07		bne $23de			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23d7	16 30		asl $30,x			asl 	NSStatus,x 					; clear the sign bit.
.23d9	76 30		ror $30,x			ror 	NSStatus,x 					; (no -0)
.23db	a9 00		lda #$00			lda 	#0 							; set Z flag
.23dd	60		rts				rts
.23de					_NSNormaliseOptimise:
.23de	b5 60		lda $60,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23e0	d0 19		bne $23fb			bne 	_NSNormaliseLoop
.23e2	b5 54		lda $54,x			lda 	NSMantissa2,x 				; byte normalise
.23e4	30 15		bmi $23fb			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23e6	95 60		sta $60,x			sta 	NSMantissa3,x
.23e8	b5 48		lda $48,x			lda 	NSMantissa1,x
.23ea	95 54		sta $54,x			sta 	NSMantissa2,x
.23ec	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.23ee	95 48		sta $48,x			sta 	NSMantissa1,x
.23f0	74 3c		stz $3c,x			stz 	NSMantissa0,x
.23f2	b5 6c		lda $6c,x			lda 	NSExponent,x
.23f4	38		sec				sec
.23f5	e9 08		sbc #$08			sbc 	#8
.23f7	95 6c		sta $6c,x			sta 	NSExponent,x
.23f9	80 e3		bra $23de			bra 	_NSNormaliseOptimise
.23fb					_NSNormaliseLoop:
.23fb	34 60		bit $60,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23fd	70 07		bvs $2406			bvs 	_NSNExit 					; exit if so with Z flag clear
.23ff	20 8c 26	jsr $268c			jsr 	FloatShiftLeft 				; shift mantissa left
.2402	d6 6c		dec $6c,x			dec 	NSExponent,x 				; adjust exponent
.2404	80 f5		bra $23fb			bra 	_NSNormaliseLoop
.2406					_NSNExit:
.2406	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.2408	60		rts				rts
.2409					FloatAddTopTwoStack:
.2409	18		clc				clc
.240a	b5 3c		lda $3c,x			lda		NSMantissa0,x
.240c	75 3d		adc $3d,x			adc 		NSMantissa0+1,x
.240e	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2410	b5 48		lda $48,x			lda		NSMantissa1,x
.2412	75 49		adc $49,x			adc 		NSMantissa1+1,x
.2414	95 48		sta $48,x			sta 	NSMantissa1,x
.2416	b5 54		lda $54,x			lda		NSMantissa2,x
.2418	75 55		adc $55,x			adc 		NSMantissa2+1,x
.241a	95 54		sta $54,x			sta 	NSMantissa2,x
.241c	b5 60		lda $60,x			lda		NSMantissa3,x
.241e	75 61		adc $61,x			adc 		NSMantissa3+1,x
.2420	95 60		sta $60,x			sta 	NSMantissa3,x
.2422	60		rts				rts
.2423					FloatSubTopTwoStack:
.2423	38		sec				sec
.2424	b5 3c		lda $3c,x			lda		NSMantissa0,x
.2426	f5 3d		sbc $3d,x			sbc 		NSMantissa0+1,x
.2428	95 3c		sta $3c,x			sta 	NSMantissa0,x
.242a	b5 48		lda $48,x			lda		NSMantissa1,x
.242c	f5 49		sbc $49,x			sbc 		NSMantissa1+1,x
.242e	95 48		sta $48,x			sta 	NSMantissa1,x
.2430	b5 54		lda $54,x			lda		NSMantissa2,x
.2432	f5 55		sbc $55,x			sbc 		NSMantissa2+1,x
.2434	95 54		sta $54,x			sta 	NSMantissa2,x
.2436	b5 60		lda $60,x			lda		NSMantissa3,x
.2438	f5 61		sbc $61,x			sbc 		NSMantissa3+1,x
.243a	95 60		sta $60,x			sta 	NSMantissa3,x
.243c	60		rts				rts
.243d					FloatInt32Add:
.243d	b5 30		lda $30,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.243f	55 31		eor $31,x			eor 	NSStatus+1,x
.2441	30 04		bmi $2447			bmi 	_DiffSigns
.2443	20 09 24	jsr $2409			jsr		FloatAddTopTwoStack
.2446	60		rts				rts
.2447					_DiffSigns:
.2447	20 23 24	jsr $2423			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.244a	34 60		bit $60,x			bit 	NSMantissa3,x 				; result is +ve, okay
.244c	10 07		bpl $2455			bpl 	_AddExit
.244e	b5 31		lda $31,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2450	95 30		sta $30,x			sta 	NSStatus,x
.2452	20 46 26	jsr $2646			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2455					_AddExit:
.2455	20 9f 26	jsr $269f			jsr 	FloatIsZero 				; check for -0
.2458	d0 02		bne $245c			bne 	_AddNonZero
.245a	74 30		stz $30,x			stz 	NSStatus,x
.245c					_AddNonZero:
.245c	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.245d					FloatEncodeStart:
.245d	38		sec				sec
.245e	80 01		bra $2461			bra 	FloatEncodeContinue+1
.2460					FloatEncodeContinue:
.2460	18		clc				clc
.2461					FloatEncode:
.2461	08		php				php 								; save reset flag.
.2462	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2464	f0 15		beq $247b			beq 	_ENIsOkay
.2466	c9 30		cmp #$30			cmp 	#"0"
.2468	90 04		bcc $246e			bcc 	_ENBadNumber
.246a	c9 3a		cmp #$3a			cmp 	#"9"+1
.246c	90 0d		bcc $247b			bcc 	_ENIsOkay
.246e					_ENBadNumber:
.246e	28		plp				plp 								; throw saved reset
.246f	ad 37 05	lda $0537			lda 	encodeState 				; if in decimal mode, construct final number
.2472	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2474	d0 03		bne $2479			bne 	_ENFail
.2476	4c f3 24	jmp $24f3			jmp 	_ENConstructFinal
.2479					_ENFail:
.2479	18		clc				clc 								; not allowed
.247a	60		rts				rts
.247b					_ENIsOkay:
.247b	28		plp				plp 								; are we restarting
.247c	90 15		bcc $2493			bcc 	_ENNoRestart
.247e					_ENStartEncode:
.247e	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2480	f0 0c		beq $248e			beq 	_ENFirstDP
.2482	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2484	20 7f 26	jsr $267f			jsr 	FloatSetByte 				; in single byte mode.
.2487	a9 01		lda #$01			lda 	#ESTA_Low
.2489					_ENExitChange:
.2489	8d 37 05	sta $0537			sta 	encodeState 				; save new state
.248c	38		sec				sec
.248d	60		rts				rts
.248e					_ENFirstDP:
.248e	20 7d 26	jsr $267d			jsr 	FloatSetZero 				; clear integer part
.2491	80 3c		bra $24cf			bra 	_ESTASwitchFloat			; go straight to float and exi
.2493					_ENNoRestart:
.2493	48		pha				pha 								; save digit or DP on stack.
.2494	ad 37 05	lda $0537			lda 	encodeState 				; get current state
.2497	c9 01		cmp #$01			cmp 	#ESTA_Low
.2499	f0 09		beq $24a4			beq  	_ESTALowState
.249b	c9 02		cmp #$02			cmp 	#ESTA_High
.249d	f0 26		beq $24c5			beq 	_ESTAHighState
.249f	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.24a1	f0 38		beq $24db			beq 	_ESTADecimalState
>24a3	db						.byte 	$DB 						; causes a break in the emulator
.24a4					_ESTALowState:
.24a4	68		pla				pla 								; get value back
.24a5	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.24a7	f0 26		beq $24cf			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24a9	29 0f		and #$0f			and 	#15 						; make digit
.24ab	8d 38 05	sta $0538			sta 	digitTemp 					; save it.
.24ae	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24b0	0a		asl a				asl 	a
.24b1	0a		asl a				asl 	a
.24b2	75 3c		adc $3c,x			adc 	NSMantissa0,x
.24b4	0a		asl a				asl 	a
.24b5	6d 38 05	adc $0538			adc 	digitTemp
.24b8	95 3c		sta $3c,x			sta 	NSMantissa0,x
.24ba	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24bc	90 05		bcc $24c3			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24be	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24c0	8d 37 05	sta $0537			sta 	encodeState
.24c3					_ESTANoSwitch:
.24c3	38		sec				sec
.24c4	60		rts				rts
.24c5					_ESTAHighState:
.24c5	68		pla				pla 								; get value back
.24c6	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24c8	f0 05		beq $24cf			beq 	_ESTASwitchFloat
.24ca	20 25 25	jsr $2525			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24cd	38		sec				sec
.24ce	60		rts				rts
.24cf					_ESTASwitchFloat:
.24cf	9c 39 05	stz $0539			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24d2	e8		inx				inx 								; zero the decimal additive.
.24d3	20 7d 26	jsr $267d			jsr 	FloatSetZero
.24d6	ca		dex				dex
.24d7	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24d9	80 ae		bra $2489			bra 	_ENExitChange
.24db					_ESTADecimalState:
.24db	68		pla				pla 								; digit.
.24dc	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24de	f0 99		beq $2479			beq 	_ENFail
.24e0	e8		inx				inx 								; put digit into fractional part of X+1
.24e1	20 25 25	jsr $2525			jsr 	ESTAShiftDigitIntoMantissa
.24e4	ca		dex				dex
.24e5	ee 39 05	inc $0539			inc 	decimalCount 				; bump the count of decimals
.24e8	ad 39 05	lda $0539			lda 	decimalCount 				; too many decimal digits.
.24eb	c9 0b		cmp #$0b			cmp 	#11
.24ed	f0 02		beq $24f1			beq 	_ESTADSFail
.24ef	38		sec				sec
.24f0	60		rts				rts
.24f1					_ESTADSFail:
.24f1	18		clc				clc
.24f2	60		rts				rts
.24f3					_ENConstructFinal:
.24f3	ad 39 05	lda $0539			lda 	decimalCount 				; get decimal count
.24f6	f0 2b		beq $2523			beq 	_ENCFExit 					; no decimals
.24f8	5a		phy				phy
.24f9	0a		asl a				asl 	a 							; x 4 and CLC
.24fa	0a		asl a				asl 	a
.24fb	6d 39 05	adc $0539			adc 	decimalCount
.24fe	a8		tay				tay
.24ff	b9 8a 21	lda $218a,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.2502	95 3e		sta $3e,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.2504	b9 8b 21	lda $218b,y			lda 	FloatScalarTable-5+1,y
.2507	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.2509	b9 8c 21	lda $218c,y			lda 	FloatScalarTable-5+2,y
.250c	95 56		sta $56,x			sta 	NSMantissa2+2,x
.250e	b9 8d 21	lda $218d,y			lda 	FloatScalarTable-5+3,y
.2511	95 62		sta $62,x			sta 	NSMantissa3+2,x
.2513	b9 8e 21	lda $218e,y			lda 	FloatScalarTable-5+4,y
.2516	95 6e		sta $6e,x			sta 	NSExponent+2,x
.2518	74 32		stz $32,x			stz 	NSStatus+2,x 				; make +ve
.251a	e8		inx				inx 								; multiply decimal const by decimal scalar
.251b	e8		inx				inx
.251c	20 3d 23	jsr $233d			jsr 	FloatMultiply
.251f	20 a1 20	jsr $20a1			jsr 	FloatAdd 					; add to integer part.
.2522	7a		ply				ply
.2523					_ENCFExit:
.2523	18		clc				clc 								; reject the digit.
.2524	60		rts				rts
.2525					ESTAShiftDigitIntoMantissa:
.2525	29 0f		and #$0f			and 	#15 						; save digit
.2527	48		pha				pha
.2528	b5 60		lda $60,x			lda 	NSMantissa3,x 				; push mantissa on stack
.252a	48		pha				pha
.252b	b5 54		lda $54,x			lda 	NSMantissa2,x
.252d	48		pha				pha
.252e	b5 48		lda $48,x			lda 	NSMantissa1,x
.2530	48		pha				pha
.2531	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2533	48		pha				pha
.2534	20 8c 26	jsr $268c			jsr 	FloatShiftLeft 				; x 2
.2537	20 8c 26	jsr $268c			jsr 	FloatShiftLeft 				; x 4
.253a	18		clc				clc 								; pop mantissa and add
.253b	68		pla				pla
.253c	75 3c		adc $3c,x			adc 	NSMantissa0,x
.253e	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2540	68		pla				pla
.2541	75 48		adc $48,x			adc 	NSMantissa1,x
.2543	95 48		sta $48,x			sta 	NSMantissa1,x
.2545	68		pla				pla
.2546	75 54		adc $54,x			adc 	NSMantissa2,x
.2548	95 54		sta $54,x			sta 	NSMantissa2,x
.254a	68		pla				pla
.254b	75 60		adc $60,x			adc 	NSMantissa3,x
.254d	95 60		sta $60,x			sta 	NSMantissa3,x 				; x 5
.254f	20 8c 26	jsr $268c			jsr 	FloatShiftLeft 				; x 10
.2552	68		pla				pla 								; add digit
.2553	18		clc				clc
.2554	75 3c		adc $3c,x			adc 	NSMantissa0,x
.2556	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2558	90 0a		bcc $2564			bcc 	_ESTASDExit
.255a	f6 48		inc $48,x			inc 	NSMantissa1,x
.255c	d0 06		bne $2564			bne 	_ESTASDExit
.255e	f6 54		inc $54,x			inc 	NSMantissa2,x
.2560	d0 02		bne $2564			bne 	_ESTASDExit
.2562	f6 60		inc $60,x			inc 	NSMantissa3,x
.2564					_ESTASDExit:
.2564	60		rts				rts
.0537					encodeState:
>0537							.fill 	1
.0538					digitTemp:
>0538							.fill 	1
.0539					decimalCount:
>0539							.fill 	1
.2565					FloatToString:
.2565	da		phx				phx
.2566	5a		phy				phy 								; save code position
.2567	8d 3a 05	sta $053a			sta 	decimalPlaces	 			; save number of DPs.
.256a	9c 3b 05	stz $053b			stz 	dbOffset 					; offset into decimal buffer = start.
.256d	b5 30		lda $30,x			lda 	NSStatus,x  				; is it -ve.
.256f	10 08		bpl $2579			bpl 	_CNTSNotNegative
.2571	29 7f		and #$7f			and 	#$7F 						; make +ve
.2573	95 30		sta $30,x			sta 	NSStatus,x
.2575	a9 2d		lda #$2d			lda 	#"-"
.2577	80 02		bra $257b			bra 	_CNTMain
.2579					_CNTSNotNegative:
.2579	a9 20		lda #$20			lda 	#" "
.257b					_CNTMain:
.257b	20 dd 25	jsr $25dd			jsr 	WriteDecimalBuffer
.257e	b5 6c		lda $6c,x			lda 	NSExponent,x 				; check if decimal
.2580	f0 0d		beq $258f			beq 	_CNTSNotFloat
.2582	e8		inx				inx 								; round up so we don't get too many 6.999999
.2583	a9 01		lda #$01			lda 	#1
.2585	20 7f 26	jsr $267f			jsr 	FloatSetByte
.2588	b5 6b		lda $6b,x			lda		NSExponent-1,x
.258a	95 6c		sta $6c,x			sta 	NSExponent,x
.258c	20 a1 20	jsr $20a1			jsr 	FloatAdd
.258f					_CNTSNotFloat:
.258f	20 bf 25	jsr $25bf			jsr 	MakePlusTwoString 			; do the integer part.
.2592	20 5d 22	jsr $225d			jsr 	FloatFractionalPart 		; get the fractional part
.2595	20 d2 23	jsr $23d2			jsr 	FloatNormalise					; normalise , exit if zero
.2598	f0 22		beq $25bc			beq 	_CNTSExit
.259a	a9 2e		lda #$2e			lda 	#"."
.259c	20 dd 25	jsr $25dd			jsr 	WriteDecimalBuffer 			; write decimal place
.259f					_CNTSDecimal:
.259f	ce 3a 05	dec $053a			dec 	decimalPlaces 				; done all the decimals
.25a2	30 18		bmi $25bc			bmi 	_CNTSExit
.25a4	e8		inx				inx 								; x 10.0
.25a5	a9 0a		lda #$0a			lda 	#10
.25a7	20 7f 26	jsr $267f			jsr 	FloatSetByte
.25aa	20 3d 23	jsr $233d			jsr 	FloatMultiply
.25ad	20 bf 25	jsr $25bf			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25b0	20 5d 22	jsr $225d			jsr 	FloatFractionalPart 		; get the fractional part
.25b3	20 d2 23	jsr $23d2			jsr 	FloatNormalise 				; normalise it.
.25b6	b5 6c		lda $6c,x			lda 	NSExponent,x 				; gone to zero, exit.
.25b8	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25ba	b0 e3		bcs $259f			bcs 	_CNTSDecimal 				; keep going.
.25bc					_CNTSExit:
.25bc	7a		ply				ply
.25bd	fa		plx				plx
.25be	60		rts				rts
.25bf					MakePlusTwoString:
.25bf	da		phx				phx
.25c0	20 60 26	jsr $2660			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25c3	e8		inx				inx 								; access it
.25c4	e8		inx				inx
.25c5	20 b8 22	jsr $22b8			jsr 	FloatIntegerPart 			; make it an integer
.25c8	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25ca	20 fc 25	jsr $25fc			jsr 	ConvertInt32
.25cd	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25cf					_MPTSCopy:
.25cf	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25d2	20 dd 25	jsr $25dd			jsr 	WriteDecimalBuffer
.25d5	e8		inx				inx
.25d6	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25d9	d0 f4		bne $25cf			bne 	_MPTSCopy
.25db	fa		plx				plx
.25dc	60		rts				rts
.25dd					WriteDecimalBuffer:
.25dd	da		phx				phx
.25de	ae 3b 05	ldx $053b			ldx 	dbOffset
.25e1	9d 3c 05	sta $053c,x			sta 	decimalBuffer,x
.25e4	9e 3d 05	stz $053d,x			stz 	decimalBuffer+1,x
.25e7	ee 3b 05	inc $053b			inc 	dbOffset
.25ea	fa		plx				plx
.25eb	60		rts				rts
.053a					decimalPlaces:
>053a							.fill 	1
.053b					dbOffset:
>053b							.fill 	1
.053c					decimalBuffer:
>053c							.fill 	32
.25ec					ConvertInt16:
.25ec	85 3c		sta $3c				sta 	NSMantissa0 				; set up as 32 bit conversion
.25ee	86 48		stx $48				stx 	NSMantissa1
.25f0	64 54		stz $54				stz 	NSMantissa2
.25f2	64 60		stz $60				stz 	NSMantissa3
.25f4	64 30		stz $30				stz 	NSStatus 					; positive integer
.25f6	a2 00		ldx #$00			ldx 	#0 							; stack level
.25f8	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25fa	80 00		bra $25fc			bra 	ConvertInt32
.25fc					ConvertInt32:
.25fc	5a		phy				phy
.25fd	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25ff	24 30		bit $30				bit 	NSStatus 					; output a - if not negative.
.2601	10 08		bpl $260b			bpl 	_CI32NotNeg
.2603	48		pha				pha
.2604	a9 2d		lda #$2d			lda 	#'-'
.2606	99 15 05	sta $0515,y			sta 	numberBuffer,y
.2609	c8		iny				iny
.260a	68		pla				pla
.260b					_CI32NotNeg:
.260b	20 19 26	jsr $2619			jsr 	_CI32DivideConvert 			; recursive conversion
.260e	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2610	99 15 05	sta $0515,y			sta 	numberBuffer,y
.2613	7a		ply				ply
.2614	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.2616	a9 15		lda #$15			lda 	#numberBuffer & $FF
.2618	60		rts				rts
.2619					_CI32DivideConvert:
.2619	e8		inx				inx 								; write to next slot up
.261a	20 7f 26	jsr $267f			jsr 	FloatSetByte 		 		; write the base out.
.261d	ca		dex				dex
.261e	20 13 22	jsr $2213			jsr 	Int32Divide 				; divide
.2621	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; save remainder
.2623	48		pha				pha
.2624	20 02 22	jsr $2202			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2627	20 9f 26	jsr $269f			jsr 	FloatIsZero 				; is it zero ?
.262a	f0 05		beq $2631			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.262c	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.262e	20 19 26	jsr $2619			jsr 	_CI32DivideConvert 			; and recusrively call.
.2631					_CI32NoRecurse:
.2631	68		pla				pla 								; remainder
.2632	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2634	90 02		bcc $2638			bcc 	_CI32NotHex
.2636	69 26		adc #$26			adc 	#6+32
.2638					_CI32NotHex:
.2638	69 30		adc #$30			adc 	#48
.263a	99 15 05	sta $0515,y			sta 	numberBuffer,y 				; write out and exit
.263d	c8		iny				iny
.263e	60		rts				rts
.263f					FloatNegate:
.263f	b5 30		lda $30,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2641	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2643	95 30		sta $30,x			sta 	NSStatus,x
.2645	60		rts				rts
.2646					FloatNegateMantissa:
.2646	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2647	a9 00		lda #$00			lda 	#0
.2649	f5 3c		sbc $3c,x			sbc 	NSMantissa0,x
.264b	95 3c		sta $3c,x			sta 	NSMantissa0,x
.264d	a9 00		lda #$00			lda 	#0
.264f	f5 48		sbc $48,x			sbc 	NSMantissa1,x
.2651	95 48		sta $48,x			sta 	NSMantissa1,x
.2653	a9 00		lda #$00			lda 	#0
.2655	f5 54		sbc $54,x			sbc 	NSMantissa2,x
.2657	95 54		sta $54,x			sta 	NSMantissa2,x
.2659	a9 00		lda #$00			lda 	#0
.265b	f5 60		sbc $60,x			sbc 	NSMantissa3,x
.265d	95 60		sta $60,x			sta 	NSMantissa3,x
.265f	60		rts				rts
.2660					FloatShiftUpTwo:
.2660	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2662	95 3e		sta $3e,x			sta 	NSMantissa0+2,x
.2664	b5 48		lda $48,x			lda 	NSMantissa1,x
.2666	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.2668	b5 54		lda $54,x			lda 	NSMantissa2,x
.266a	95 56		sta $56,x			sta 	NSMantissa2+2,x
.266c	b5 60		lda $60,x			lda 	NSMantissa3,x
.266e	95 62		sta $62,x			sta 	NSMantissa3+2,x
.2670	b5 6c		lda $6c,x			lda 	NSExponent,x
.2672	95 6e		sta $6e,x			sta 	NSExponent+2,x
.2674	b5 30		lda $30,x			lda 	NSStatus,x
.2676	95 32		sta $32,x			sta 	NSStatus+2,x
.2678	60		rts				rts
.2679					FloatSetZeroMantissaOnly:
.2679	74 3c		stz $3c,x			stz 	NSMantissa0,x
.267b	80 08		bra $2685			bra 	FloatZero13
.267d					FloatSetZero:
.267d	a9 00		lda #$00			lda 	#0
.267f					FloatSetByte:
.267f	74 6c		stz $6c,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2681					FloatSetMantissa:
.2681	95 3c		sta $3c,x			sta 	NSMantissa0,x 				; zero mantissa
.2683	74 30		stz $30,x			stz 	NSStatus,x
.2685					FloatZero13:
.2685	74 48		stz $48,x			stz 	NSMantissa1,x
.2687	74 54		stz $54,x			stz 	NSMantissa2,x
.2689	74 60		stz $60,x			stz 	NSMantissa3,x
.268b	60		rts				rts
.268c					FloatShiftLeft:
.268c	18		clc				clc
.268d					FloatRotateLeft:
.268d	36 3c		rol $3c,x			rol 	NSMantissa0,x
.268f	36 48		rol $48,x			rol		NSMantissa1,x
.2691	36 54		rol $54,x			rol		NSMantissa2,x
.2693	36 60		rol $60,x			rol		NSMantissa3,x
.2695	60		rts				rts
.2696					FloatShiftRight:
.2696	56 60		lsr $60,x			lsr 	NSMantissa3,x
.2698	76 54		ror $54,x			ror		NSMantissa2,x
.269a	76 48		ror $48,x			ror		NSMantissa1,x
.269c	76 3c		ror $3c,x			ror		NSMantissa0,x
.269e	60		rts				rts
.269f					FloatIsZero:
.269f	b5 60		lda $60,x			lda 	NSMantissa3,x
.26a1	15 54		ora $54,x			ora		NSMantissa2,x
.26a3	15 48		ora $48,x			ora		NSMantissa1,x
.26a5	15 3c		ora $3c,x			ora		NSMantissa0,x
.26a7	60		rts				rts

;******  Processing input file: testing/testend.asm

.26a8					EndProgram:
>26a8	01 08 0c 08 0a 00 4e 20				.binary "code/tokenised.dat"
>26b0	b2 20 31 34 00 15 08 14 00 ce 86 20 33 00 32 08
>26c0	3c 00 99 20 c7 28 31 34 37 29 3b 22 48 45 4c 4c
>26d0	4f 20 57 4f 52 4c 44 20 21 22 00 38 08 3d 00 90
>26e0	00 54 08 46 00 86 20 42 58 28 4e 29 3a 86 20 42
>26f0	59 28 4e 29 3a 86 20 42 43 28 4e 29 00 68 08 4b
>2700	00 86 20 44 58 28 4e 29 3a 86 20 44 59 28 4e 29
>2710	00 76 08 50 00 81 20 42 b2 30 20 a4 20 4e 00 8f
>2720	08 5a 00 42 58 28 42 29 b2 b5 28 bb 28 31 29 ac
>2730	34 30 29 ac 32 aa 31 00 a8 08 64 00 42 59 28 42
>2740	29 b2 b5 28 bb 28 31 29 ac 33 30 29 ac 32 35 36
>2750	00 bf 08 69 00 42 43 28 42 29 b2 b5 28 bb 28 31
>2760	29 ac 31 34 29 aa 31 00 d3 08 6a 00 44 58 28 42
>2770	29 b2 b5 28 bb 28 31 29 ac 32 29 00 e9 08 6c 00
>2780	8f 20 44 59 28 42 29 b2 b5 28 bb 28 31 29 ac 32
>2790	29 00 f5 08 6d 00 44 59 28 42 29 b2 31 00 fd 08
>27a0	6e 00 82 20 42 00 03 09 78 00 8f 00 17 09 82 00
>27b0	81 59 b2 30 a4 32 39 3a 81 58 b2 30 a4 33 39 00
>27c0	2d 09 8c 00 51 b2 59 ac 32 35 36 aa 58 ac 32 aa
>27d0	34 35 30 35 36 00 45 09 96 00 ce 84 20 31 2c 51
>27e0	2c 38 31 3a ce 84 31 2c 51 aa 31 2c 30 00 4e 09
>27f0	a0 00 82 58 2c 59 00 5a 09 c8 00 81 20 42 b2 31
>2800	a4 4e 00 77 09 d2 00 ce 84 20 31 2c 34 35 30 35
>2810	36 aa 42 59 28 42 29 aa 42 58 28 42 29 2c 30 00
>2820	85 09 e6 00 44 58 42 b2 44 58 28 42 29 00 96 09
>2830	f0 00 8b 44 58 42 b2 30 a7 8d 31 30 31 30 00 a7
>2840	09 fa 00 8b 44 58 42 b2 31 a7 8d 31 30 34 30 00
>2850	b5 09 ff 00 44 59 42 b2 44 59 28 42 29 00 c6 09
>2860	04 01 8b 44 59 42 b2 30 a7 8d 31 30 37 30 00 d7
>2870	09 0e 01 8b 44 59 42 b2 31 a7 8d 31 31 30 30 00
>2880	f8 09 18 01 ce 84 20 31 2c 34 35 30 35 36 aa 42
>2890	59 28 42 29 aa 42 58 28 42 29 2c 42 43 28 42 29
>28a0	00 ff 09 22 01 82 42 00 09 0a 2c 01 89 20 32 30
>28b0	30 00 0f 0a e8 03 8f 00 1d 0a f2 03 42 58 42 b2
>28c0	42 58 28 42 29 00 32 0a f3 03 8b 42 58 42 b2 31
>28d0	a7 44 58 28 42 29 b2 31 3a 8e 00 44 0a fc 03 42
>28e0	58 28 42 29 b2 42 58 42 ab 32 3a 8e 00 4a 0a 06
>28f0	04 8f 00 58 0a 10 04 42 58 42 b2 42 58 28 42 29
>2900	00 78 0a 11 04 8b 42 58 42 b2 37 39 a7 20 42 58
>2910	28 42 29 b2 37 37 3a 44 58 28 42 29 b2 30 3a 8e
>2920	00 8a 0a 1a 04 42 58 28 42 29 b2 42 58 42 aa 32
>2930	3a 8e 00 90 0a 24 04 8f 00 9e 0a 2e 04 42 59 42
>2940	b2 42 59 28 42 29 00 b3 0a 2f 04 8b 42 59 42 b2
>2950	30 a7 44 59 28 42 29 b2 31 3a 8e 00 c7 0a 38 04
>2960	42 59 28 42 29 b2 42 59 42 ab 32 35 36 3a 8e 00
>2970	cd 0a 42 04 8f 00 db 0a 4c 04 42 59 42 b2 42 59
>2980	28 42 29 00 fe 0a 4d 04 8b 42 59 42 b2 37 34 32
>2990	34 a7 42 59 28 42 29 b2 37 31 36 38 3a 44 59 28
>29a0	42 29 b2 30 3a 8e 00 12 0b 56 04 42 59 28 42 29
>29b0	b2 42 59 42 aa 32 35 36 3a 8e 00 00 00

;******  End of listing
