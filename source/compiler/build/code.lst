
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Sat Oct  7 16:37:30 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.1000					WrapperBoot:
.1000	a2 0a		ldx #$0a			ldx 	#APIDesc & $FF
.1002	a0 10		ldy #$10			ldy 	#APIDesc >> 8
.1004	20 65 11	jsr $1165			jsr 	StartCompiler
.1007	4c ff ff	jmp $ffff			jmp 	$FFFF
.100a					APIDesc:
>100a	0e 10						.word 	TestAPI 					; the testing API.
>100c	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>100d	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing file: testing/api/api.asm

=$a000					PCodeMemory = $A000
.100e					TestAPI:
.100e	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.1010	f0 11		beq $1023			beq 	_TAOpenIn
.1012	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.1014	f0 15		beq $102b			beq 	_TACloseIn
.1016	c9 02		cmp #$02			cmp 	#BLC_READIN
.1018	f0 12		beq $102c			beq 	_TARead
.101a	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.101c	f0 11		beq $102f			beq 	_TAResetOut
.101e	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.1020	f0 16		beq $1038			beq 	_TAWriteByte
>1022	db						.byte 	$DB 						; causes a break in the emulator
.1023					_TAOpenIn:
.1023	a9 ad		lda #$ad			lda 	#((EndProgram+2) & $FF)
.1025	85 22		sta $22				sta 	0+srcInputPtr
.1027	a9 26		lda #$26			lda 	#((EndProgram+2) >> 8) & $FF
.1029	85 23		sta $23				sta 	1+srcInputPtr
.102b					_TACloseIn:
.102b	60		rts				rts
.102c					_TARead:
.102c	4c 4c 10	jmp $104c			jmp 	ReadNextLine
.102f					_TAResetOut:
.102f	a9 00		lda #$00			lda 	#((PCodeMemory) & $FF)
.1031	85 28		sta $28				sta 	0+objPtr
.1033	a9 a0		lda #$a0			lda 	#((PCodeMemory) >> 8) & $FF
.1035	85 29		sta $29				sta 	1+objPtr
.1037	60		rts				rts
.1038					_TAWriteByte:
.1038					APIOWriteByte:
.1038	8a		txa				txa
.1039	92 28		sta ($28)			sta 	(objPtr)
.103b	e6 28		inc $28				inc 	objPtr
.103d	d0 02		bne $1041			bne 	_HWOWBNoCarry
.103f	e6 29		inc $29				inc 	objPtr+1
.1041					_HWOWBNoCarry:
.1041	60		rts				rts
.0022					srcInputPtr:
>0022							.fill 	2

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/close.asm

.1042					APIOClose:
.1042	a9 a0		lda #$a0			lda 	#PCodeMemory >> 8
.1044	a6 28		ldx $28				ldx 	objPtr
.1046	a4 29		ldy $29				ldy 	objPtr+1
.1048	20 75 10	jsr $1075			jsr 	APISaveMemory
.104b	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/fromram.asm


;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/line.asm

.104c					ReadNextLine:
.104c	b2 22		lda ($22)			lda 	(srcInputPtr) 				; reached the end of the program (address link = $0000)
.104e	a0 01		ldy #$01			ldy 	#1
.1050	11 22		ora ($22),y			ora 	(srcInputPtr),y
.1052	d0 02		bne $1056			bne 	_RLAHaveData
.1054	18		clc				clc
.1055	60		rts				rts									; end of file.
.1056					_RLAHaveData:
.1056	a6 22		ldx $22				ldx 	srcInputPtr 				; remember the line start
.1058	a4 23		ldy $23				ldy 	srcInputPtr+1
.105a	5a		phy				phy
.105b	a0 04		ldy #$04			ldy 	#4 							; must be at least four bytes (address/line#)
.105d					_RNLRead:
.105d	b1 22		lda ($22),y			lda 	(srcInputPtr),y 			; find the end of the line.
.105f	c8		iny				iny
.1060	c9 00		cmp #$00			cmp 	#0
.1062	d0 f9		bne $105d			bne 	_RNLRead
.1064	98		tya				tya 								; advance src input pointer to next.
.1065	18		clc				clc
.1066	65 22		adc $22				adc 	srcInputPtr
.1068	85 22		sta $22				sta 	srcInputPtr
.106a	90 02		bcc $106e			bcc 	_RNLNoCarry
.106c	e6 23		inc $23				inc 	srcInputPtr+1
.106e					_RNLNoCarry:
.106e	7a		ply				ply 								; address of line now in YX.
.106f	38		sec				sec
.1070	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/open.asm


;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/writebyte.asm


;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_printchar.asm

.1071					APIOPrintCharacter
.1071	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1074	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_save.asm

.1075					APISaveMemory:
.1075	da		phx				phx
.1076	5a		phy				phy
.1077	48		pha				pha
.1078	a9 00		lda #$00			lda 	#0 							; set LFS
.107a	a2 08		ldx #$08			ldx 	#8
.107c	a0 00		ldy #$00			ldy 	#0
.107e	20 ba ff	jsr $ffba			jsr 	$FFBA
.1081	a9 08		lda #$08			lda 	#8 							; set file name
.1083	a2 97		ldx #$97			ldx 	#SaveName & $FF
.1085	a0 10		ldy #$10			ldy 	#SaveName >> 8
.1087	20 bd ff	jsr $ffbd			jsr 	$FFBD
.108a	68		pla				pla 								; set up the start address.
.108b	85 2b		sta $2b				sta 	zTemp0+1
.108d	64 2a		stz $2a				stz 	zTemp0
.108f	a9 2a		lda #$2a			lda 	#zTemp0 					; from index.
.1091	7a		ply				ply 								; end in YX
.1092	fa		plx				plx
.1093	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.1096	60		rts				rts
.1097					SaveName:
>1097	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Return to file: testing/testing.asm


;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.0024					srcPtr:
>0024							.fill 	2
.0400					currentLineNumber:
>0400							.fill 	2
.109f					InlineNonDecimal:
.109f	a2 02		ldx #$02			ldx 	#2 							; get size in X
.10a1	c9 25		cmp #$25			cmp 	#"%"
.10a3	f0 02		beq $10a7			beq 	_INDBinary
.10a5	a2 10		ldx #$10			ldx 	#16
.10a7					_INDBinary:
.10a7	85 2c		sta $2c				sta 	zTemp1 						; size => zTemp1
.10a9	64 2d		stz $2d				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.10ab	64 2a		stz $2a				stz 	zTemp0 						; zero result
.10ad	64 2b		stz $2b				stz 	zTemp0+1
.10af					_INDLoop:
.10af	20 3f 1a	jsr $1a3f			jsr 	LookNext 					; check next character
.10b2	20 7b 1a	jsr $1a7b			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.10b5	90 1f		bcc $10d6			bcc		_INDDone 					; didn't convert
.10b7	c5 2c		cmp $2c				cmp 	zTemp1 						; size too large ?
.10b9	b0 1b		bcs $10d6			bcs 	_INDDone
.10bb	20 e5 10	jsr $10e5			jsr 	_INDShift 					; x 2 or x 16
.10be	e0 02		cpx #$02			cpx 	#2
.10c0	f0 09		beq $10cb			beq 	_INDNotHex
.10c2	20 e5 10	jsr $10e5			jsr 	_INDShift
.10c5	20 e5 10	jsr $10e5			jsr 	_INDShift
.10c8	20 e5 10	jsr $10e5			jsr 	_INDShift
.10cb					_INDNotHex:
.10cb	05 2a		ora $2a				ora 	zTemp0 						; or digit into result
.10cd	85 2a		sta $2a				sta 	zTemp0
.10cf	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume
.10d2	e6 2d		inc $2d				inc 	zTemp1+1 					; bump count
.10d4	80 d9		bra $10af			bra 	_INDLoop
.10d6					_INDDone:
.10d6	a5 2d		lda $2d				lda 	zTemp1+1 					; done at least 1 ?
.10d8	f0 08		beq $10e2			beq 	_INDError
.10da	a4 2b		ldy $2b				ldy 	zTemp0+1 					; push constant
.10dc	a5 2a		lda $2a				lda 	zTemp0
.10de	20 fa 11	jsr $11fa			jsr 	PushIntegerYA
.10e1	60		rts				rts
.10e2					_INDError:
.10e2	4c 3a 1f	jmp $1f3a		jmp	ErrorV_syntax
.10e5					_INDShift:
.10e5	06 2a		asl $2a				asl 	zTemp0
.10e7	26 2b		rol $2b				rol 	zTemp0+1
.10e9	60		rts				rts
.10ea					GetLineNumber:
.10ea	ac 01 04	ldy $0401			ldy 	currentLineNumber+1
.10ed	ad 00 04	lda $0400			lda 	currentLineNumber
.10f0	60		rts				rts
.10f1					WriteCodeByte:
.10f1	48		pha				pha 								; save on stack
.10f2	da		phx				phx
.10f3	5a		phy				phy
.10f4	aa		tax				tax
.10f5	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.10f7	20 f7 11	jsr $11f7			jsr 	CallAPIHandler
.10fa	7a		ply				ply 								; restore from stack
.10fb	fa		plx				plx
.10fc	68		pla				pla
.10fd	60		rts				rts
.10fe					PrintCharacter
.10fe	48		pha				pha
.10ff	da		phx				phx
.1100	5a		phy				phy
.1101	20 71 10	jsr $1071			jsr 	APIOPrintCharacter
.1104	7a		ply				ply
.1105	fa		plx				plx
.1106	68		pla				pla
.1107	60		rts				rts
.1108					ProcessNewLine:
.1108	86 2a		stx $2a				stx 	zTemp0 						; save address in zTemp0
.110a	84 2b		sty $2b				sty 	zTemp0+1
.110c	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.110d	8a		txa				txa
.110e	69 04		adc #$04			adc 	#4
.1110	85 24		sta $24				sta 	srcPtr
.1112	98		tya				tya
.1113	69 00		adc #$00			adc 	#0
.1115	85 25		sta $25				sta 	srcPtr+1
.1117	a0 02		ldy #$02			ldy 	#2							; read and save line number
.1119	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.111b	8d 00 04	sta $0400			sta 	currentLineNumber
.111e	c8		iny				iny
.111f	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1121	8d 01 04	sta $0401			sta 	currentLineNumber+1
.1124	60		rts				rts
.1125					BufferClear:
.1125	9c 02 04	stz $0402			stz 	bufferSize
.1128	60		rts				rts
.1129					BufferWrite:
.1129	da		phx				phx
.112a	ae 02 04	ldx $0402			ldx 	bufferSize
.112d	9d 03 04	sta $0403,x			sta 	dataBuffer,x
.1130	ee 02 04	inc $0402			inc 	bufferSize
.1133	fa		plx				plx
.1134	60		rts				rts
.1135					BufferOutput:
.1135	ad 02 04	lda $0402			lda 	bufferSize
.1138	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.113b	a2 00		ldx #$00			ldx 	#0
.113d					_BOLoop:
.113d	ec 02 04	cpx $0402			cpx 	bufferSize
.1140	f0 09		beq $114b			beq 	_BOExit
.1142	bd 03 04	lda $0403,x			lda 	dataBuffer,x
.1145	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1148	e8		inx				inx
.1149	80 f2		bra $113d			bra 	_BOLoop
.114b					_BOExit:
.114b	60		rts				rts
.0402					bufferSize:
>0402							.fill 	1
.0403					dataBuffer:
>0403							.fill 	256
.114c					CheckNextComma:
.114c	a9 2c		lda #$2c			lda	 	#","
.114e	80 06		bra $1156			bra 	CheckNextA
.1150					CheckNextRParen:
.1150	a9 29		lda #$29			lda	 	#")"
.1152	80 02		bra $1156			bra 	CheckNextA
.1154					CheckNextLParen:
.1154	a9 28		lda #$28			lda 	#"("
.1156					CheckNextA:
.1156	8d 03 05	sta $0503			sta 	checkCharacter 				; save test character
.1159					_CNALoop:
.1159	20 5b 1a	jsr $1a5b			jsr 	GetNextNonSpace 			; get next skipping spaces.
.115c	cd 03 05	cmp $0503			cmp 	checkCharacter 				; matches ?
.115f	f0 03		beq $1164			beq 	_CNAExit
.1161	4c 3a 1f	jmp $1f3a		jmp	ErrorV_syntax
.1164					_CNAExit:
.1164	60		rts				rts
.0503					checkCharacter:
>0503							.fill 	1
.1165					StartCompiler:
.1165	86 2a		stx $2a				stx 	zTemp0 						; access API
.1167	84 2b		sty $2b				sty 	zTemp0+1
.1169	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.116b	b2 2a		lda ($2a)			lda 	(zTemp0)
.116d	8d 05 05	sta $0505			sta 	APIVector
.1170	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1172	8d 06 05	sta $0506			sta 	APIVector+1
.1175	c8		iny				iny 								; copy data area range.
.1176	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1178	8d 07 05	sta $0507			sta 	compilerStartHigh
.117b	c8		iny				iny
.117c	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.117e	8d 08 05	sta $0508			sta 	compilerEndHigh
.1181	ba		tsx				tsx 								; save stack pointer
.1182	8e 04 05	stx $0504			stx 	compilerSP
.1185	20 df 1d	jsr $1ddf			jsr 	STRReset 					; reset storage (line#, variable)
.1188	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.118a	20 f7 11	jsr $11f7			jsr 	CallAPIHandler
.118d	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.118f	20 f7 11	jsr $11f7			jsr 	CallAPIHandler
.1192	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.1194	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1197	a9 00		lda #$00			lda 	#0
.1199	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.119c	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.119f					MainCompileLoop:
.119f	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.11a1	20 f7 11	jsr $11f7			jsr 	CallAPIHandler
.11a4	90 31		bcc $11d7			bcc 	SaveCodeAndExit 			; end of source.
.11a6	20 08 11	jsr $1108			jsr 	ProcessNewLine 				; set up pointer and line number.
.11a9	20 ea 10	jsr $10ea			jsr 	GetLineNumber 				; get line #
.11ac	20 c9 1b	jsr $1bc9			jsr 	STRMarkLine 				; remember the code position and number of this line.
.11af	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.11b1	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.11b4					_MCLSameLine:
.11b4	20 5b 1a	jsr $1a5b			jsr 	GetNextNonSpace 			; get the first character.
.11b7	f0 e6		beq $119f			beq 	MainCompileLoop 			; end of line, get next line.
.11b9	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.11bb	f0 f7		beq $11b4			beq 	_MCLSameLine
.11bd	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.11bf	10 0c		bpl $11cd			bpl 	_MCLCheckAssignment
.11c1	a2 19		ldx #$19			ldx 	#CommandTables & $FF 		; do command tables.
.11c3	a0 16		ldy #$16			ldy 	#CommandTables >> 8
.11c5	20 e1 18	jsr $18e1			jsr 	GeneratorProcess
.11c8	b0 ea		bcs $11b4			bcs 	_MCLSameLine 				; keep trying to compile the line.
.11ca					_MCLSyntax:
.11ca	4c 3a 1f	jmp $1f3a		jmp	ErrorV_syntax
.11cd					_MCLCheckAssignment:
.11cd	20 71 1a	jsr $1a71			jsr 	CharIsAlpha 				; if not alpha then syntax error
.11d0	90 f8		bcc $11ca			bcc 	_MCLSyntax
.11d2	20 97 1b	jsr $1b97			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.11d5	80 dd		bra $11b4			bra		_MCLSameLine 				; loop back.
.11d7					SaveCodeAndExit:
.11d7	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.11d9	20 f7 11	jsr $11f7			jsr 	CallAPIHandler
.11dc	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.11de	a8		tay				tay
.11df	20 c9 1b	jsr $1bc9			jsr 	STRMarkLine
.11e2	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.11e4	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.11e7	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.11e9	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.11ec	20 11 15	jsr $1511			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.11ef	20 42 10	jsr $1042			jsr 	APIOClose
.11f2					ExitCompiler:
.11f2	ae 04 05	ldx $0504			ldx 	compilerSP 					; reload SP and exit.
.11f5	9a		txs				txs
.11f6	60		rts				rts
.11f7					CallAPIHandler:
.11f7	6c 05 05	jmp ($0505)			jmp 	(APIVector)
.0504					compilerSP:
>0504							.fill 	1
.0505					APIVector:
>0505							.fill 	2
.0507					compilerStartHigh:
>0507							.fill 	1
.0508					compilerEndHigh:
>0508							.fill 	1
.11fa					PushIntegerYA:
.11fa	c0 00		cpy #$00			cpy 	#0 							; 0-255
.11fc	f0 0f		beq $120d			beq 	PushIntegerA
.11fe	48		pha				pha
.11ff	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.1201	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1204	68		pla				pla 								; then LSB
.1205	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1208	98		tya				tya 								; then MSB
.1209	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.120c	60		rts				rts
.120d					PushIntegerA:
.120d	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.120f	90 07		bcc $1218			bcc 	_PIWriteA
.1211	48		pha				pha
.1212	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.1214	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1217	68		pla				pla
.1218					_PIWriteA:
.1218	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.121b	60		rts				rts
.121c					PushFloat:
.121c	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.121e	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1221	b5 6c		lda $6c,x			lda 	NSExponent,x 				; and the data
.1223	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1226	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1228	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.122b	b5 48		lda $48,x			lda 	NSMantissa1,x
.122d	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1230	b5 54		lda $54,x			lda 	NSMantissa2,x
.1232	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1235	b5 30		lda $30,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.1237	29 80		and #$80			and 	#$80
.1239	15 60		ora $60,x			ora 	NSMantissa3,x
.123b	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.123e	60		rts				rts
.123f					CreateVariableRecord:
.123f	48		pha				pha
.1240	ad 13 05	lda $0513			lda 	freeVariableMemory 		; push current free address on stack.
.1243	48		pha				pha
.1244	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1247	48		pha				pha
.1248	ad 11 05	lda $0511			lda 	variableListEnd  		; copy end of list to zTemp0
.124b	85 2a		sta $2a				sta 	zTemp0
.124d	ad 12 05	lda $0512			lda 	variableListEnd+1
.1250	85 2b		sta $2b				sta 	zTemp0+1
.1252	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.1254	92 2a		sta ($2a)			sta 	(zTemp0)
.1256	98		tya				tya
.1257	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.1259	91 2a		sta ($2a),y			sta 	(zTemp0),y
.125b	88		dey				dey
.125c	8a		txa				txa
.125d	91 2a		sta ($2a),y			sta 	(zTemp0),y
.125f	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.1261	ad 13 05	lda $0513			lda 	freeVariableMemory
.1264	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1266	c8		iny				iny
.1267	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.126a	91 2a		sta ($2a),y			sta 	(zTemp0),y
.126c	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.126e	a9 00		lda #$00			lda 	#0
.1270	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1272	18		clc				clc
.1273	b2 2a		lda ($2a)			lda 	(zTemp0) 				; add offset to variableListEnd
.1275	6d 11 05	adc $0511			adc  	variableListEnd
.1278	8d 11 05	sta $0511			sta 	variableListEnd
.127b	90 03		bcc $1280			bcc 	_CVNoCarry2
.127d	ee 12 05	inc $0512			inc 	variableListEnd+1
.1280					_CVNoCarry2:
.1280	7a		ply				ply
.1281	fa		plx				plx
.1282	68		pla				pla
.1283	60		rts				rts
.1284					SetVariableRecordToCodePosition:
.1284	48		pha				pha
.1285	5a		phy				phy
.1286	a0 03		ldy #$03			ldy 	#3
.1288	a5 29		lda $29				lda 	objPtr+1
.128a	91 2a		sta ($2a),y			sta 	(zTemp0),y
.128c	c8		iny				iny
.128d	a5 28		lda $28				lda 	objPtr
.128f	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1291	7a		ply				ply
.1292	68		pla				pla
.1293	60		rts				rts
.1294					AllocateBytesForType:
.1294	48		pha				pha
.1295	da		phx				phx
.1296	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.1298	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.129a	c9 00		cmp #$00			cmp 	#NSSIFloat
.129c	d0 02		bne $12a0			bne 	_CVNotFloat
.129e	a2 06		ldx #$06			ldx 	#6
.12a0					_CVNotFloat:
.12a0	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.12a1	18		clc				clc
.12a2	6d 13 05	adc $0513			adc 	freeVariableMemory
.12a5	8d 13 05	sta $0513			sta 	freeVariableMemory
.12a8	90 03		bcc $12ad			bcc 	_CVNoCarry1
.12aa	ee 14 05	inc $0514			inc 	freeVariableMemory+1
.12ad					_CVNoCarry1:
.12ad	fa		plx				plx
.12ae	68		pla				pla
.12af	60		rts				rts
.12b0					CommandDATA:
.12b0	20 25 11	jsr $1125			jsr 	BufferClear 				; copy it to the buffer
.12b3	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace
.12b6					_CTDataLoop:
.12b6	20 3f 1a	jsr $1a3f			jsr 	LookNext 					; reached EOL
.12b9	f0 08		beq $12c3			beq 	_CTDataDone
.12bb	20 29 11	jsr $1129			jsr 	BufferWrite 				; write and consume
.12be	20 50 1a	jsr $1a50			jsr 	GetNext
.12c1	80 f3		bra $12b6			bra 	_CTDataLoop
.12c3					_CTDataDone:
.12c3	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.12c5	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.12c8	20 35 11	jsr $1135			jsr 	BufferOutput
.12cb	60		rts				rts
.12cc					CommandDEF:
.12cc	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.12ce	20 0d 12	jsr $120d			jsr 	PushIntegerA
.12d1	20 60 1b	jsr $1b60			jsr 	CompileGotoEOL 				; compile skip over DEF
.12d4	a9 a5		lda #$a5			lda 	#C64_FN
.12d6	20 56 11	jsr $1156			jsr 	CheckNextA
.12d9	20 5b 1a	jsr $1a5b			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.12dc	20 c0 1a	jsr $1ac0			jsr 	ExtractVariableName
.12df	8a		txa				txa
.12e0	10 51		bpl $1333			bpl 	_CDError
.12e2	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.12e3	29 7f		and #$7f			and 	#$7F
.12e5	aa		tax				tax
.12e6	98		tya				tya
.12e7	09 80		ora #$80			ora 	#$80
.12e9	a8		tay				tay
.12ea	20 b5 14	jsr $14b5			jsr 	FindVariable				; does it already exist ?
.12ed	b0 44		bcs $1333			bcs 	_CDError 					; if so, that's an error.
.12ef	20 3f 12	jsr $123f			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.12f2	20 84 12	jsr $1284			jsr 	SetVariableRecordToCodePosition
.12f5	20 5b 1a	jsr $1a5b			jsr 	GetNextNonSpace
.12f8	20 9c 1d	jsr $1d9c			jsr 	GetReferenceTerm 			; get var ref, not array
.12fb	c9 00		cmp #$00			cmp 	#0
.12fd	30 34		bmi $1333			bmi 	_CDError
.12ff	8d 09 05	sta $0509			sta 	defType 					; save type
.1302	8e 0a 05	stx $050a			stx 	defVariable 				; save var ref
.1305	8c 0b 05	sty $050b			sty 	defVariable+1
.1308	29 40		and #$40			and 	#NSSString 					; only numbers.
.130a	d0 27		bne $1333			bne 	_CDError
.130c	20 50 11	jsr $1150			jsr 	CheckNextRParen 			; check )
.130f	a9 b2		lda #$b2			lda 	#C64_EQUAL
.1311	20 56 11	jsr $1156			jsr 	CheckNextA 					; check =
.1314	18		clc				clc 								; if this is DEF FNxx(A), read A
.1315	20 36 13	jsr $1336			jsr 	CDReadWriteVariable
.1318	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.131a	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.131d	38		sec				sec
.131e	20 36 13	jsr $1336			jsr 	CDReadWriteVariable 		; A is now updated
.1321	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; the actual body of the function.
.1324	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1326	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1329	38		sec				sec
.132a	20 36 13	jsr $1336			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.132d	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.132f	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1332	60		rts				rts
.1333					_CDError:
.1333	4c 3a 1f	jmp $1f3a		jmp	ErrorV_syntax
.1336					CDReadWriteVariable:
.1336	ac 0b 05	ldy $050b			ldy 	defVariable+1 				; set up YX
.1339	ae 0a 05	ldx $050a			ldx 	defVariable
.133c	ad 09 05	lda $0509			lda 	defType
.133f	20 4e 1d	jsr $1d4e			jsr 	GetSetVariable
.1342	60		rts				rts
.0509					defType:
>0509							.fill 	1
.050a					defVariable:
>050a							.fill 	2
.1343					CommandDIM:
.1343	20 5b 1a	jsr $1a5b			jsr 	GetNextNonSpace 			; get the first non space character
.1346	20 c0 1a	jsr $1ac0			jsr 	ExtractVariableName 		; variable name to XY
.1349	da		phx				phx 								; save name with type bits.
.134a	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.134c	10 37		bpl $1385			bpl 	_CDError
.134e	20 b5 14	jsr $14b5			jsr 	FindVariable	 			; see if already exist
.1351	b0 35		bcs $1388			bcs 	_CDRedefine 				; it still exists.
.1353	20 3f 12	jsr $123f			jsr 	CreateVariableRecord 		; create the basic variable
.1356	20 94 12	jsr $1294			jsr 	AllocateBytesForType 		; allocate memory for it
.1359	68		pla				pla 								; restore type bits
.135a	5a		phy				phy 								; save the address of the basic storage
.135b	da		phx				phx
.135c	48		pha				pha
.135d	20 8b 13	jsr $138b			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.1360	68		pla				pla
.1361	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.1363	20 0d 12	jsr $120d			jsr 	PushIntegerA 				; push that type data out.
.1366	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.1368	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.136b	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.136d	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1370	fa		plx				plx 								; restore address
.1371	7a		ply				ply
.1372	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1374	38		sec				sec
.1375	20 4e 1d	jsr $1d4e			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.1378	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; , follows ?
.137b	c9 2c		cmp #$2c			cmp 	#","
.137d	d0 05		bne $1384			bne 	_CDExit
.137f	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume comma
.1382	80 bf		bra $1343			bra 	CommandDIM 					; do another DIM
.1384					_CDExit:
.1384	60		rts				rts
.1385					_CDError:
.1385	4c 3a 1f	jmp $1f3a		jmp	ErrorV_syntax
.1388					_CDRedefine:
.1388	4c 02 20	jmp $2002		jmp	ErrorV_redefine
.138b					OutputIndexGroup:
.138b	9c 0c 05	stz $050c			stz 	IndexCount 					; count of number of indices.
.138e					_OIGNext:
.138e	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; get a dimension
.1391	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1393	c9 00		cmp #$00			cmp 	#NSSIFloat
.1395	d0 19		bne $13b0			bne 	_OIGType
.1397	ee 0c 05	inc $050c			inc 	IndexCount 					; bump the counter.
.139a	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; does a , follow ?
.139d	c9 2c		cmp #$2c			cmp 	#","
.139f	d0 05		bne $13a6			bne 	_OIGCheckEnd
.13a1	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume comma
.13a4	80 e8		bra $138e			bra 	_OIGNext 					; get next dimension
.13a6					_OIGCheckEnd:
.13a6	20 50 11	jsr $1150			jsr 	CheckNextRParen 			; check and consume )
.13a9	ad 0c 05	lda $050c			lda 	IndexCount
.13ac	20 0d 12	jsr $120d			jsr 	PushIntegerA 				; compile the dimension count.
.13af	60		rts				rts
.13b0					_OIGType:
.13b0	4c 4a 1f	jmp $1f4a		jmp	ErrorV_type
.050c					IndexCount:
>050c							.fill 	1
.13b3					ErrorHandler:
.13b3	68		pla				pla
.13b4	7a		ply				ply
.13b5	85 2a		sta $2a				sta 	zTemp0
.13b7	84 2b		sty $2b				sty 	zTemp0+1
.13b9	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.13bb	a0 01		ldy #$01			ldy 	#1
.13bd					_EHDisplayMsg:
.13bd	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.13bf	20 fe 10	jsr $10fe			jsr 	PrintCharacter
.13c2	c8		iny				iny
.13c3	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.13c5	d0 f6		bne $13bd			bne 	_EHDisplayMsg
.13c7	a9 20		lda #$20			lda 	#32
.13c9	20 fe 10	jsr $10fe			jsr 	PrintCharacter
.13cc	a9 40		lda #$40			lda 	#64
.13ce	20 fe 10	jsr $10fe			jsr 	PrintCharacter
.13d1	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.13d3	20 82 26	jsr $2682			jsr 	FloatSetByte
.13d6	20 ea 10	jsr $10ea			jsr 	GetLineNumber
.13d9	95 3c		sta $3c,x			sta 	NSMantissa0,x
.13db	98		tya				tya
.13dc	95 48		sta $48,x			sta 	NSMantissa1,x
.13de	20 68 25	jsr $2568			jsr 	FloatToString
.13e1	a0 00		ldy #$00			ldy 	#0 							; display that string.
.13e3	a2 00		ldx #$00			ldx 	#0
.13e5					_EHDisplayLine:
.13e5	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13e8	20 fe 10	jsr $10fe			jsr 	PrintCharacter
.13eb	c8		iny				iny
.13ec	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13ef	d0 f4		bne $13e5			bne 	_EHDisplayLine
.13f1	a9 0d		lda #$0d			lda 	#13
.13f3	20 fe 10	jsr $10fe			jsr 	PrintCharacter
.13f6	80 fe		bra $13f6	_EHHalt:bra 	_EHHalt
.13f8	4c f2 11	jmp $11f2			jmp 	ExitCompiler
.13fb					CompileExpressionAt0:
.13fb	a9 00		lda #$00			lda 	#0
.13fd					CompileExpressionAtA:
.13fd	48		pha				pha  								; save level
.13fe	20 07 1e	jsr $1e07			jsr 	CompileTerm 				; compile a term.
.1401	fa		plx				plx 								; get level back into X
.1402					_ECALoop:
.1402	48		pha				pha 								; save type on stack.
.1403	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; get the next character
.1406	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.1408	90 04		bcc $140e			bcc 	_ECAExit
.140a	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.140c	90 02		bcc $1410			bcc 	_ECAHaveToken
.140e					_ECAExit:
.140e	68		pla				pla 								; throw type off stack
.140f	60		rts				rts
.1410					_ECAHaveToken:
.1410	86 2a		stx $2a				stx 	zTemp0 						; save current precedence in zTemp0
.1412	aa		tax				tax 								; X contains the operator token
.1413	bd fe 13	lda $13fe,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.1416	c5 2a		cmp $2a				cmp 	zTemp0 						; if < then exit
.1418	90 f4		bcc $140e			bcc 	_ECAExit
.141a	85 2b		sta $2b				sta 	zTemp0+1 					; save the precedence of the operator.
.141c	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume the token.
.141f	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.1421	f0 11		beq $1434			beq 	_ECAGreaterCheck
.1423	e0 b3		cpx #$b3			cpx 	#C64_LESS
.1425	d0 1a		bne $1441			bne 	_ECAHaveFullToken
.1427	20 3f 1a	jsr $1a3f			jsr 	LookNext 					; checks for < (<= or <>)
.142a	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.142c	f0 0e		beq $143c			beq	 	_ECAToNotEqual
.142e	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.1430	d0 0f		bne $1441			bne 	_ECAHaveFullToken
.1432	80 07		bra $143b			bra 	_ECAAddEqual
.1434					_ECAGreaterCheck:
.1434	20 3f 1a	jsr $1a3f			jsr 	LookNext
.1437	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.1439	d0 06		bne $1441			bne 	_ECAHaveFullToken
.143b					_ECAAddEqual:
.143b	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.143c					_ECAToNotEqual:
.143c	e8		inx				inx
.143d	e8		inx				inx
.143e	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume the = or > in >= <= <>
.1441					_ECAHaveFullToken:
.1441	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.1443	d0 0a		bne $144f			bne 	_ECANotConcat
.1445	68		pla				pla 								; get type back
.1446	48		pha				pha
.1447	29 40		and #$40			and 	#NSSTypeMask
.1449	c9 40		cmp #$40			cmp 	#NSSString
.144b	d0 02		bne $144f			bne 	_ECANotConcat
.144d	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.144f					_ECANotConcat:
.144f	da		phx				phx 								; save operator on the stack
.1450	a6 2a		ldx $2a				ldx 	zTemp0 						; push current precedence on the stack
.1452	da		phx				phx
.1453	a5 2b		lda $2b				lda 	zTemp0+1 					; get precedence of operator
.1455	1a		inc a				inc 	a
.1456	20 fd 13	jsr $13fd			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.1459	85 2a		sta $2a				sta 	zTemp0 						; save type in zTemp0
.145b	fa		plx				plx 								; restore current precedence in X
.145c	68		pla				pla 								; restore operator
.145d	85 2b		sta $2b				sta 	zTemp0+1 					; save it in zTemp0+1.
.145f	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.1461	90 17		bcc $147a			bcc 	_ECANotCompare
.1463	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.1465	b0 13		bcs $147a			bcs 	_ECANotCompare
.1467	7a		ply				ply 								; get type into Y
.1468	5a		phy				phy
.1469	48		pha				pha 								; save operator
.146a	98		tya				tya 								; get type
.146b	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.146d	29 40		and #$40			and 	#NSSTypeMask
.146f	c9 40		cmp #$40			cmp 	#NSSString
.1471	f0 02		beq $1475			beq 	_ECANotString
.1473	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.1475					_ECANotString:
.1475	98		tya				tya									; output token Y
.1476	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1479	68		pla				pla 								; restore operator.
.147a					_ECANotCompare:
.147a	18		clc				clc 								; convert to P-Code and compile.
.147b	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.147d	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1480	68		pla				pla 								; type of current result
.1481	45 2a		eor $2a				eor 	zTemp0 						; check compatible with r-expr type
.1483	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.1485	d0 19		bne $14a0			bne		_ECAType
.1487	a5 2a		lda $2a				lda 	zTemp0 						; get type back
.1489	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.148b	d0 18		bne $14a5			bne 	_ECAGoLoop
.148d	a5 2b		lda $2b				lda 	zTemp0+1 					; check operator is + or comparator
.148f	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1491	f0 10		beq $14a3			beq 	_ECAOkayString 				; (this is post conversion)
.1493	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.1495	90 09		bcc $14a0			bcc 	_ECAType
.1497	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.1499	b0 05		bcs $14a0			bcs 	_ECAType
.149b	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.149d	4c 02 14	jmp $1402			jmp 	_ECALoop
.14a0					_ECAType:
.14a0	4c 4a 1f	jmp $1f4a		jmp	ErrorV_type
.14a3					_ECAOkayString:
.14a3	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.14a5					_ECAGoLoop:
.14a5	4c 02 14	jmp $1402			jmp 	_ECALoop
.14a8					PrecedenceTable:
>14a8	03						.byte 	3 					; '+'
>14a9	03						.byte 	3 					; '-'
>14aa	04						.byte 	4 					; '*'
>14ab	04						.byte 	4 					; '/'
>14ac	05						.byte 	5 					; '^'
>14ad	01						.byte 	1 					; 'and'
>14ae	00						.byte 	0 					; 'or'
>14af	02						.byte 	2 					; '>'
>14b0	02						.byte 	2 					; '='
>14b1	02						.byte 	2 					; '<'
>14b2	02						.byte 	2 					; '>='
>14b3	02						.byte 	2 					; '<='
>14b4	02						.byte 	2 					; '<>'
.14b5					FindVariable:
.14b5	86 2c		stx $2c				stx 	zTemp1 						; save name.
.14b7	84 2d		sty $2d				sty 	zTemp1+1
.14b9					_IVCheckSpecial:
.14b9	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.14bb	d0 18		bne $14d5			bne 	_IVStandard
.14bd	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.14bf	f0 0c		beq $14cd			beq 	_IVTIFloat
.14c1	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.14c3	d0 10		bne $14d5			bne 	_IVStandard
.14c5	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.14c7	a2 01		ldx #$01			ldx 	#$01
.14c9	a9 40		lda #$40			lda 	#NSSString
.14cb	38		sec				sec
.14cc	60		rts				rts
.14cd					_IVTIFloat:
.14cd	a0 80		ldy #$80			ldy 	#$80
.14cf	a2 00		ldx #$00			ldx 	#$00
.14d1	a9 00		lda #$00			lda 	#0
.14d3	38		sec				sec
.14d4	60		rts				rts
.14d5					_IVStandard:
.14d5	ad 07 05	lda $0507			lda 	compilerStartHigh			; start scanning from here.
.14d8	85 2b		sta $2b				sta 	zTemp0+1
.14da	64 2a		stz $2a				stz 	zTemp0
.14dc					_IVCheckLoop:
.14dc	b2 2a		lda ($2a)			lda 	(zTemp0) 					; finished ?
.14de	f0 2b		beq $150b			beq  	_IVNotFound 				; if so, return with CC.
.14e0	a0 01		ldy #$01			ldy 	#1 							; match ?
.14e2	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14e4	c5 2c		cmp $2c				cmp 	zTemp1
.14e6	d0 07		bne $14ef			bne	 	_IVNext
.14e8	c8		iny				iny
.14e9	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14eb	c5 2d		cmp $2d				cmp 	zTemp1+1
.14ed	f0 0d		beq $14fc			beq 	_IVFound
.14ef					_IVNext:
.14ef	18		clc				clc
.14f0	a5 2a		lda $2a				lda 	zTemp0
.14f2	72 2a		adc ($2a)			adc 	(zTemp0)
.14f4	85 2a		sta $2a				sta 	zTemp0
.14f6	90 e4		bcc $14dc			bcc 	_IVCheckLoop
.14f8	e6 2b		inc $2b				inc 	zTemp0+1
.14fa	80 e0		bra $14dc			bra 	_IVCheckLoop
.14fc					_IVFound:
.14fc	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.14fe	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1500	aa		tax				tax
.1501	c8		iny				iny
.1502	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1504	48		pha				pha
.1505	c8		iny				iny
.1506	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1508	7a		ply				ply
.1509	38		sec				sec
.150a	60		rts				rts
.150b					_IVNotFound:
.150b	a6 2c		ldx $2c				ldx 	zTemp1 						; get variable name back
.150d	a4 2d		ldy $2d				ldy 	zTemp1+1
.150f	18		clc				clc
.1510	60		rts				rts
.1511					FixBranches:
.1511	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.1513	20 f7 11	jsr $11f7			jsr 	CallAPIHandler
.1516					_FBLoop:
.1516	b2 28		lda ($28)			lda 	(objPtr) 					; get the next one.
.1518	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.151a	f0 16		beq $1532			beq 	_FBFixGotoGosub
.151c	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.151e	f0 12		beq $1532			beq 	_FBFixGotoGosub
.1520	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.1522	f0 0e		beq $1532			beq 	_FBFixGotoGosub
.1524	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1526	f0 0a		beq $1532			beq 	_FBFixGotoGosub
.1528	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.152a	f0 3b		beq $1567			beq 	_FBFixVarSpace
.152c					_FBNext:
.152c	20 4f 20	jsr $204f			jsr 	MoveObjectForward 			; move forward in object code.
.152f	90 e5		bcc $1516			bcc 	_FBLoop 					; not finished
.1531					_FBExit:
.1531	60		rts				rts
.1532					_FBFixGotoGosub:
.1532	a0 01		ldy #$01			ldy 	#1							; line number in YA
.1534	b1 28		lda ($28),y			lda 	(objPtr),y
.1536	48		pha				pha
.1537	c8		iny				iny
.1538	b1 28		lda ($28),y			lda 	(objPtr),y
.153a	a8		tay				tay
.153b	68		pla				pla
.153c	20 f2 1b	jsr $1bf2			jsr 	STRFindLine			 		; find where it is YA
.153f	90 08		bcc $1549			bcc 	_FBFFound 					; not found, so must be >
.1541	48		pha				pha
.1542	b2 28		lda ($28)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.1544	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1546	d0 0f		bne $1557			bne 	_FBFFail
.1548	68		pla				pla
.1549					_FBFFound:
.1549	20 42 1c	jsr $1c42			jsr 	STRMakeOffset 				; make it an offset from X:YA
.154c	5a		phy				phy	 								; patch the GOTO/GOSUB
.154d	a0 01		ldy #$01			ldy 	#1
.154f	91 28		sta ($28),y			sta 	(objPtr),y
.1551	c8		iny				iny
.1552	68		pla				pla
.1553	91 28		sta ($28),y			sta 	(objPtr),y
.1555	80 d5		bra $152c			bra 	_FBNext
.1557					_FBFFail:
.1557	a0 02		ldy #$02			ldy 	#2
.1559	b1 28		lda ($28),y			lda 	(objPtr),y
.155b	8d 00 04	sta $0400			sta 	currentLineNumber
.155e	c8		iny				iny
.155f	b1 28		lda ($28),y			lda 	(objPtr),y
.1561	8d 01 04	sta $0401			sta 	currentLineNumber+1
.1564	4c 7d 1f	jmp $1f7d		jmp	ErrorV_line
.1567					_FBFixVarSpace:
.1567	a0 01		ldy #$01			ldy 	#1
.1569	ad 13 05	lda $0513			lda 	freeVariableMemory
.156c	91 28		sta ($28),y			sta 	(objPtr),y
.156e	c8		iny				iny
.156f	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1572	91 28		sta ($28),y			sta 	(objPtr),y
.1574	80 b6		bra $152c			bra 	_FBNext
.1576					CommandFOR:
.1576	20 5b 1a	jsr $1a5b			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.1579	20 71 1a	jsr $1a71			jsr 	CharIsAlpha 				; if not alpha , error
.157c	90 59		bcc $15d7			bcc 	_CFFail
.157e	20 9c 1d	jsr $1d9c			jsr 	GetReferenceTerm 			; figure out the reference.
.1581	48		pha				pha 								; save type
.1582	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1584	c9 00		cmp #$00			cmp 	#NSSIFloat
.1586	d0 4f		bne $15d7			bne 	_CFFail
.1588	5a		phy				phy 								; save reference on the stack
.1589	da		phx				phx
.158a	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.158c	20 56 11	jsr $1156			jsr 	CheckNextA
.158f	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; initial value
.1592	fa		plx				plx 								; get reference back.
.1593	7a		ply				ply
.1594	5a		phy				phy
.1595	da		phx				phx
.1596	38		sec				sec 								; set initial value.
.1597	20 4e 1d	jsr $1d4e			jsr 	GetSetVariable
.159a	fa		plx				plx
.159b	7a		ply				ply
.159c	68		pla				pla
.159d	29 20		and #$20			and 	#NSSIInt16
.159f	f0 04		beq $15a5			beq 	_CFNotInt16
.15a1	98		tya				tya
.15a2	09 80		ora #$80			ora 	#$80
.15a4	a8		tay				tay
.15a5					_CFNotInt16:
.15a5	8a		txa				txa 								; reference in YA
.15a6	20 fa 11	jsr $11fa			jsr 	PushIntegerYA
.15a9	a9 a4		lda #$a4			lda 	#C64_TO
.15ab	20 56 11	jsr $1156			jsr 	CheckNextA
.15ae	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; terminal value
.15b1	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15b3	c9 00		cmp #$00			cmp 	#NSSIFloat
.15b5	d0 20		bne $15d7			bne 	_CFFail
.15b7	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; followed by STEP
.15ba	c9 a9		cmp #$a9			cmp 	#C64_STEP
.15bc	d0 0e		bne $15cc			bne 	_CFNoStep
.15be	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume it.
.15c1	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; terminal value
.15c4	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15c6	c9 00		cmp #$00			cmp 	#NSSIFloat
.15c8	d0 0d		bne $15d7			bne 	_CFFail
.15ca	80 05		bra $15d1			bra 	_CFParametersDone
.15cc					_CFNoStep:
.15cc	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.15ce	20 0d 12	jsr $120d			jsr 	PushIntegerA
.15d1					_CFParametersDone:
.15d1	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.15d3	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.15d6	60		rts				rts
.15d7					_CFFail:
.15d7	4c 3a 1f	jmp $1f3a		jmp	ErrorV_syntax
.15da					FNCompile:
.15da	20 5b 1a	jsr $1a5b			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.15dd	20 c0 1a	jsr $1ac0			jsr 	ExtractVariableName
.15e0	e0 00		cpx #$00			cpx 	#0
.15e2	10 32		bpl $1616			bpl 	_FNError
.15e4	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.15e5	29 7f		and #$7f			and 	#$7F
.15e7	aa		tax				tax
.15e8	98		tya				tya
.15e9	09 80		ora #$80			ora 	#$80
.15eb	a8		tay				tay
.15ec	20 b5 14	jsr $14b5			jsr 	FindVariable				; does it already exist ?
.15ef	90 25		bcc $1616			bcc 	_FNError 					; no.
.15f1	20 42 1c	jsr $1c42			jsr 	STRMakeOffset 				; convert to a relative address.
.15f4	c9 00		cmp #$00			cmp 	#0 							; fix up.
.15f6	d0 01		bne $15f9			bne 	_FNNoBorrow
.15f8	88		dey				dey
.15f9					_FNNoBorrow:
.15f9	3a		dec a				dec 	a
.15fa	5a		phy				phy 								; save location of routine on stack.
.15fb	48		pha				pha
.15fc	da		phx				phx
.15fd	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0
.1600	20 50 11	jsr $1150			jsr 	CheckNextRParen
.1603	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1605	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1608	68		pla				pla
.1609	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.160c	68		pla				pla
.160d	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1610	68		pla				pla
.1611	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1614	18		clc				clc
.1615	60		rts				rts
.1616					_FNError:
.1616	4c 2d 1f	jmp $1f2d		jmp	ErrorV_value
.1619					CommandTables:
>1619	07 cb 00 03 1e 1b 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>1620	07 89 00 03 25 1b 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>1627	07 8d 00 03 18 1b 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>162e	07 88 00 03 94 1b 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>1635	07 85 00 03 74 1b 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>163c	07 84 00 04 88 1b 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>1643	07 99 00 03 c9 1c 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>164a	07 98 00 04 c9 1c 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1651	07 8f 00 03 d4 1d 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>1658	07 81 00 03 76 15 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>165f	07 82 00 03 4c 1c 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>1666	07 a1 00 03 91 1a 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>166d	07 83 00 03 b0 12 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>1674	07 87 00 03 12 1d 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>167b	07 86 00 03 43 13 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>1682	07 96 00 03 cc 12 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>1689	07 8b 00 e3 41 1b 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>1690	08 92 00 ea e3 a0 1e 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>1698	09 91 00 e1 a9 03 78 1c			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>16a0	06
>16a1	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>16a8	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>16af	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>16b5	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>16bc	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>16c3	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>16ca	07 9d 00 e3 c6 1e 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>16d1	0a 9f 00 ea e3 d9 1e 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>16d9	c6 06
>16db	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>16e1	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>16e8	0a ce 92 e3 0e 1a 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>16f0	ad 06
>16f2	0a ce 8d e3 0e 1a 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>16fa	ae 06
>16fc	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>1702	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>170a	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>1711	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>1718	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>1720	06
>1721	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>1729	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>1731	9a 06
>1733	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>173b	9b 06
>173d	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>1745	9c 06
>1747	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>174f	06
>1750	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>1757	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>175f	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>1767	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>176f	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>1777	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>177f	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>1787	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>178f	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>1797	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>179f	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>17a7	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>17ae	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>17b6	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>17be	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>17c6	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>17ce	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>17d6	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>17de	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>17e6	00						.byte 	0
.17e7					UnaryTables:
>17e7	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>17ee	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>17f6	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>17fd	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>1804	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>180b	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>1812	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>181a	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>1821	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>1829	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>1831	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>1839	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>1841	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>1849	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>1851	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>1858	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>185f	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>1866	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>186d	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>1874	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>187b	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>1883	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>188b	0b ca 00 8f ae 03 0e 1a			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>1893	91 bd 07
>1896	07 a8 00 03 2d 1a 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>189d	07 a5 00 03 da 15 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>18a4	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>18ab	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>18b2	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>18ba	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>18c2	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>18c9	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>18d0	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>18d7	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>18df	06
>18e0	00						.byte 	0
.18e1					GeneratorProcess:
.18e1	86 2a		stx $2a				stx 	zTemp0 						; save generation pointer in zTemp0
.18e3	84 2b		sty $2b				sty 	zTemp0+1
.18e5	85 2c		sta $2c				sta 	zTemp1 						; first match token
.18e7	64 2d		stz $2d				stz 	zTemp1+1
.18e9	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.18eb	d0 05		bne $18f2			bne 	_GPNotShifted
.18ed	20 50 1a	jsr $1a50			jsr 	GetNext 					; get the shifted token
.18f0	85 2d		sta $2d				sta 	zTemp1+1 					; match CE xx
.18f2					_GPNotShifted:
.18f2					_GPSearch:
.18f2	b2 2a		lda ($2a)			lda 	(zTemp0) 					; reached end ?
.18f4	18		clc				clc
.18f5	f0 2f		beq $1926			beq 	_GPExit
.18f7	a0 01		ldy #$01			ldy 	#1 							; tokens match
.18f9	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.18fb	c5 2c		cmp $2c				cmp 	zTemp1
.18fd	d0 09		bne $1908			bne 	_GPNext
.18ff	a5 2d		lda $2d				lda 	zTemp1+1 					; 2nd token ?
.1901	f0 12		beq $1915			beq 	_GPFound
.1903	c8		iny				iny 								; check match.
.1904	d1 2a		cmp ($2a),y			cmp 	(zTemp0),y
.1906	f0 0d		beq $1915			beq 	_GPFound
.1908					_GPNext:
.1908	18		clc				clc 								; follow to next
.1909	a5 2a		lda $2a				lda 	zTemp0
.190b	72 2a		adc ($2a)			adc 	(zTemp0)
.190d	85 2a		sta $2a				sta 	zTemp0
.190f	90 e1		bcc $18f2			bcc 	_GPSearch
.1911	e6 2b		inc $2b				inc 	zTemp0+1
.1913	80 dd		bra $18f2			bra 	_GPSearch
.1915					_GPFound:
.1915	18		clc				clc 								; skip to action bytes
.1916	a5 2a		lda $2a				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.1918	69 03		adc #$03			adc 	#3
.191a	85 2a		sta $2a				sta 	zTemp0
.191c	90 02		bcc $1920			bcc 	_GPNoCarry
.191e	e6 2b		inc $2b				inc 	zTemp0+1
.1920					_GPNoCarry:
.1920					_GPLoop:
.1920	20 27 19	jsr $1927			jsr 	GeneratorExecute 			; execute one command
.1923	90 fb		bcc $1920			bcc 	_GPLoop 					; go back if not completed.
.1925	38		sec				sec 								; return with CS.
.1926					_GPExit:
.1926	60		rts				rts
.1927					GeneratorExecute:
.1927	20 d3 19	jsr $19d3			jsr 	_GEFetchZTemp0 				; get next.
.192a	48		pha				pha 								; split into 2 nibbles
.192b	4a		lsr a				lsr 	a
.192c	4a		lsr a				lsr 	a
.192d	4a		lsr a				lsr		a
.192e	4a		lsr a				lsr 	a
.192f	20 39 19	jsr $1939			jsr 	_GEExecuteNibble 			; MSB first
.1932	68		pla				pla
.1933	b0 03		bcs $1938			bcs 	_GEHaveCompleted
.1935	20 39 19	jsr $1939			jsr 	_GEExecuteNibble 			; LSB second
.1938					_GEHaveCompleted:
.1938	60		rts				rts
.1939					_GEExecuteNibble:
.1939	29 0f		and #$0f			and 	#$0F
.193b	0a		asl a				asl 	a
.193c	aa		tax				tax
.193d	7c 40 19	jmp ($1940,x)			jmp 	(_GEExecuteVectors,x)
.1940					_GEExecuteVectors:
>1940	60 19						.word 	_GEXNop 					; 0  (no operation)
>1942	68 19						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>1944	62 19						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>1946	b6 19						.word 	_GEXExecute 				; 3  (run arbitrary code)
>1948	a9 19						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>194a	60 19						.word 	_GEXNop 					; 5
>194c	70 19						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>194e	74 19						.word 	_GEXExitString 				; 7  exit return string type
>1950	78 19						.word 	_GEXLParam 					; 8  check ( follows
>1952	7c 19						.word 	_GEXRParam 					; 9  check ) follows
>1954	80 19						.word 	_GEXComma					; A  check , follows
>1956	60 19						.word 	_GEXNop 					; B
>1958	60 19						.word 	_GEXNop 					; C
>195a	60 19						.word 	_GEXNop 					; D
>195c	90 19						.word 	_GEXNumber 					; E  compile get any number
>195e	9b 19						.word 	_GEXString 					; F  compile get any string
.1960					_GEXNop:
.1960	18		clc				clc
.1961	60		rts				rts
.1962					_GEXToken2:
.1962	20 d3 19	jsr $19d3			jsr 	_GEFetchZTemp0
.1965	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1968					_GEXToken1:
.1968	20 d3 19	jsr $19d3			jsr 	_GEFetchZTemp0
.196b	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.196e	18		clc				clc
.196f	60		rts				rts
.1970					_GEXExitNumber:
.1970	a9 00		lda #$00			lda 	#NSSIFloat
.1972	38		sec				sec
.1973	60		rts				rts
.1974					_GEXExitString:
.1974	a9 40		lda #$40			lda 	#NSSString
.1976	38		sec				sec
.1977	60		rts				rts
.1978					_GEXLParam:
.1978	a9 28		lda #$28			lda 	#"("
.197a	80 06		bra $1982			bra 	_GEXCheck
.197c					_GEXRParam:
.197c	a9 29		lda #$29			lda 	#")"
.197e	80 02		bra $1982			bra 	_GEXCheck
.1980					_GEXComma:
.1980	a9 2c		lda #$2c			lda 	#","
.1982					_GEXCheck:
.1982	85 2e		sta $2e				sta 	zTemp2 						; save match
.1984	20 5b 1a	jsr $1a5b			jsr 	GetNextNonSpace 			; get next skipping spaces
.1987	c5 2e		cmp $2e				cmp 	zTemp2 						; check matches.
.1989	d0 02		bne $198d			bne 	_GEXSyntax
.198b	18		clc				clc
.198c	60		rts				rts
.198d					_GEXSyntax:
.198d	4c 3a 1f	jmp $1f3a		jmp	ErrorV_syntax
.1990					_GEXNumber:
.1990	20 dc 19	jsr $19dc			jsr 	GEXCompileExpression 		; compile expression
.1993	29 40		and #$40			and 	#NSSTypeMask
.1995	c9 00		cmp #$00			cmp  	#NSSIFloat
.1997	d0 0d		bne $19a6			bne 	_GEXType
.1999	18		clc				clc
.199a	60		rts				rts
.199b					_GEXString:
.199b	20 dc 19	jsr $19dc			jsr 	GEXCompileExpression 		; compile expression
.199e	29 40		and #$40			and 	#NSSTypeMask
.19a0	c9 40		cmp #$40			cmp  	#NSSString
.19a2	d0 02		bne $19a6			bne 	_GEXType
.19a4	18		clc				clc
.19a5	60		rts				rts
.19a6					_GEXType:
.19a6	4c 4a 1f	jmp $1f4a		jmp	ErrorV_type
.19a9					_GEXChannelExec:
.19a9	20 ec 19	jsr $19ec			jsr 	ChannelPrefix 				; set up default
.19ac	20 b6 19	jsr $19b6			jsr 	_GEXExecute
.19af	08		php				php
.19b0	20 07 1a	jsr $1a07			jsr 	ChannelPostfix 				; replace default.
.19b3	28		plp				plp
.19b4	60		rts				rts
>19b5	db						.byte 	$DB 						; causes a break in the emulator
.19b6					_GEXExecute:
.19b6	20 d3 19	jsr $19d3			jsr 	_GEFetchZTemp0 				; get vector
.19b9	85 2e		sta $2e				sta 	zTemp2
.19bb	20 d3 19	jsr $19d3			jsr 	_GEFetchZTemp0
.19be	85 2f		sta $2f				sta 	zTemp2+1
.19c0	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19c2	da		phx				phx
.19c3	a6 2b		ldx $2b				ldx 	zTemp0+1
.19c5	da		phx				phx
.19c6	20 d0 19	jsr $19d0			jsr 	_GECallZTemp2 				; execute code
.19c9	fa		plx				plx 								; recover generation exec
.19ca	86 2b		stx $2b				stx 	zTemp0+1
.19cc	fa		plx				plx
.19cd	86 2a		stx $2a				stx 	zTemp0
.19cf	60		rts				rts
.19d0					_GECallZTemp2:
.19d0	6c 2e 00	jmp ($002e)			jmp 	(zTemp2)
.19d3					_GEFetchZTemp0:
.19d3	b2 2a		lda ($2a)			lda 	(zTemp0)
.19d5	e6 2a		inc $2a				inc 	zTemp0
.19d7	d0 02		bne $19db			bne 	_GEFZ0Skip
.19d9	e6 2b		inc $2b				inc 	zTemp0+1
.19db					_GEFZ0Skip:
.19db	60		rts				rts
.19dc					GEXCompileExpression:
.19dc	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19de	da		phx				phx
.19df	a6 2b		ldx $2b				ldx 	zTemp0+1
.19e1	da		phx				phx
.19e2	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; compile expression.
.19e5	fa		plx				plx 								; recover generation exec
.19e6	86 2b		stx $2b				stx 	zTemp0+1
.19e8	fa		plx				plx
.19e9	86 2a		stx $2a				stx 	zTemp0
.19eb	60		rts				rts
.19ec					ChannelPrefix:
.19ec	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.19ee	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.19f1	20 dc 19	jsr $19dc			jsr 	GEXCompileExpression 		; channel #
.19f4	29 40		and #$40			and 	#NSSTypeMask
.19f6	c9 00		cmp #$00			cmp 	#NSSIFloat
.19f8	d0 0a		bne $1a04			bne 	_CPXType
.19fa	20 4c 11	jsr $114c			jsr 	CheckNextComma 				; check , follows.
.19fd	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.19ff	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1a02	18		clc				clc
.1a03	60		rts				rts
.1a04					_CPXType:
.1a04	4c 4a 1f	jmp $1f4a		jmp	ErrorV_type
.1a07					ChannelPostfix:
.1a07	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.1a09	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1a0c	18		clc				clc
.1a0d	60		rts				rts
.1a0e					OptionalParameterCompile:
.1a0e	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; what follows.
.1a11	c9 2c		cmp #$2c			cmp 	#","
.1a13	d0 0e		bne $1a23			bne 	_MidDefault
.1a15	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume ,
.1a18	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0
.1a1b	29 40		and #$40			and 	#NSSTypeMask
.1a1d	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a1f	d0 09		bne $1a2a			bne 	MidFailType
.1a21	80 05		bra $1a28			bra 	_MidComplete
.1a23					_MidDefault:
.1a23	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1a25	20 0d 12	jsr $120d			jsr 	PushIntegerA
.1a28					_MidComplete:
.1a28	18		clc				clc
.1a29	60		rts				rts
.1a2a					MidFailType:
.1a2a	4c 4a 1f	jmp $1f4a		jmp	ErrorV_type
.1a2d					NotUnaryCompile:
.1a2d	ad b0 14	lda $14b0			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1a30	20 fd 13	jsr $13fd			jsr 	CompileExpressionAtA 		; evaluate at that level
.1a33	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1a35	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a37	d0 f1		bne $1a2a			bne 	MidFailType
.1a39	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1a3b	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1a3e	60		rts				rts
.1a3f					LookNext:
.1a3f	b2 24		lda ($24)			lda 	(srcPtr)
.1a41	60		rts				rts
.1a42					LookNextNonSpace:
.1a42	b2 24		lda ($24)			lda 	(srcPtr)
.1a44	c9 20		cmp #$20			cmp		#' '
.1a46	f0 03		beq $1a4b			beq 	_LNNSkip
.1a48	c9 00		cmp #$00			cmp 	#0
.1a4a	60		rts				rts
.1a4b					_LNNSkip:
.1a4b	20 50 1a	jsr $1a50			jsr 	GetNext
.1a4e	80 f2		bra $1a42			bra 	LookNextNonSpace
.1a50					GetNext:
.1a50	b2 24		lda ($24)			lda 	(srcPtr) 					; get next
.1a52	e6 24		inc $24				inc 	srcPtr
.1a54	d0 02		bne $1a58			bne 	_GNSkip
.1a56	e6 25		inc $25				inc 	srcPtr+1
.1a58					_GNSkip:
.1a58	c9 00		cmp #$00			cmp 	#0
.1a5a	60		rts				rts
.1a5b					GetNextNonSpace:
.1a5b	20 50 1a	jsr $1a50			jsr 	GetNext
.1a5e	c9 20		cmp #$20			cmp 	#' '
.1a60	f0 f9		beq $1a5b			beq 	GetNextNonSpace
.1a62	c9 00		cmp #$00			cmp 	#0
.1a64	60		rts				rts
.1a65					CharIsDigit:
.1a65	c9 30		cmp #$30			cmp 	#"0"
.1a67	90 06		bcc $1a6f			bcc 	CCFalse
.1a69	c9 3a		cmp #$3a			cmp 	#"9"+1
.1a6b	b0 02		bcs $1a6f			bcs 	CCFalse
.1a6d					CCTrue:
.1a6d	38		sec				sec
.1a6e	60		rts				rts
.1a6f					CCFalse:
.1a6f	18		clc				clc
.1a70	60		rts				rts
.1a71					CharIsAlpha:
.1a71	c9 41		cmp #$41			cmp 	#"A"
.1a73	90 fa		bcc $1a6f			bcc 	CCFalse
.1a75	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1a77	b0 f6		bcs $1a6f			bcs 	CCFalse
.1a79	80 f2		bra $1a6d			bra 	CCTrue
.1a7b					ConvertHexStyle:
.1a7b	38		sec				sec
.1a7c	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1a7e	90 ef		bcc $1a6f			bcc 	CCFalse
.1a80	c9 0a		cmp #$0a			cmp 	#9+1
.1a82	90 e9		bcc $1a6d			bcc 	CCTrue
.1a84	38		sec				sec 								; shift into hex space A=>0 Z=>25
.1a85	e9 11		sbc #$11			sbc 	#"A"-"0"
.1a87	90 e6		bcc $1a6f			bcc 	CCFalse
.1a89	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.1a8b	b0 e2		bcs $1a6f			bcs 	CCFalse
.1a8d	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.1a8f	80 dc		bra $1a6d			bra 	CCTrue
.1a91					CommandGET:
.1a91	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; # follows ?
.1a94	c9 23		cmp #$23			cmp 	#"#"
.1a96	d0 0d		bne $1aa5			bne 	CommandGetBody
.1a98	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume #
.1a9b	20 ec 19	jsr $19ec			jsr 	ChannelPrefix 				; do it as GET#
.1a9e	20 a5 1a	jsr $1aa5			jsr 	CommandGetBody
.1aa1	20 07 1a	jsr $1a07			jsr 	ChannelPostfix
.1aa4	60		rts				rts
.1aa5					CommandGetBody:
.1aa5	20 5b 1a	jsr $1a5b			jsr 	GetNextNonSpace 			; get the first character
.1aa8	20 9c 1d	jsr $1d9c			jsr 	GetReferenceTerm 			; identify variable to assign to
.1aab	48		pha				pha
.1aac	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1aae	c9 40		cmp #$40			cmp 	#NSSString
.1ab0	d0 0b		bne $1abd			bne 	_CGType
.1ab2	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1ab4	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1ab7	38		sec				sec
.1ab8	68		pla				pla
.1ab9	20 4e 1d	jsr $1d4e			jsr		GetSetVariable
.1abc	60		rts				rts
.1abd					_CGType:
.1abd	4c 4a 1f	jmp $1f4a		jmp	ErrorV_type
.1ac0					ExtractVariableName:
.1ac0	20 71 1a	jsr $1a71			jsr 	CharIsAlpha
.1ac3	90 50		bcc $1b15			bcc 	_IVSyntax
.1ac5	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.1ac7	85 2c		sta $2c				sta 	zTemp1 						; we'll build it in zTemp1
.1ac9	64 2d		stz $2d				stz 	zTemp1+1
.1acb	20 3f 1a	jsr $1a3f			jsr 	LookNext 					; is there a second character ?
.1ace	20 71 1a	jsr $1a71			jsr 	CharIsAlpha  				; must be alphanumeric
.1ad1	b0 05		bcs $1ad8			bcs 	_IVHasSecond
.1ad3	20 65 1a	jsr $1a65			jsr 	CharIsDigit
.1ad6	90 07		bcc $1adf			bcc 	_IVCheckType
.1ad8					_IVHasSecond:
.1ad8	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.1ada	85 2d		sta $2d				sta 	zTemp1+1
.1adc					_IVGetNextCheck:
.1adc	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume it
.1adf					_IVCheckType:
.1adf	20 3f 1a	jsr $1a3f			jsr 	LookNext					; check if string follows.
.1ae2	20 71 1a	jsr $1a71			jsr 	CharIsAlpha
.1ae5	b0 f5		bcs $1adc			bcs 	_IVGetNextCheck
.1ae7	20 65 1a	jsr $1a65			jsr 	CharIsDigit
.1aea	b0 f0		bcs $1adc			bcs 	_IVGetNextCheck
.1aec	a2 40		ldx #$40			ldx 	#NSSString
.1aee	c9 24		cmp #$24			cmp 	#"$"
.1af0	f0 06		beq $1af8			beq 	_IVHasType
.1af2	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.1af4	c9 25		cmp #$25			cmp 	#"%"
.1af6	d0 08		bne $1b00			bne 	_IVCheckArray
.1af8					_IVHasType:
.1af8	8a		txa				txa 								; Or X into zTemp1
.1af9	05 2c		ora $2c				ora 	zTemp1
.1afb	85 2c		sta $2c				sta 	zTemp1
.1afd	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume it
.1b00					_IVCheckArray:
.1b00	20 3f 1a	jsr $1a3f			jsr 	LookNext 					; check if array follows
.1b03	c9 28		cmp #$28			cmp 	#"("
.1b05	d0 09		bne $1b10			bne 	_IVNotArray
.1b07	a5 2c		lda $2c				lda 	zTemp1 						; set array bit
.1b09	09 80		ora #$80			ora 	#NSSArray
.1b0b	85 2c		sta $2c				sta 	zTemp1
.1b0d	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume it
.1b10					_IVNotArray:
.1b10	a6 2c		ldx $2c				ldx 	zTemp1
.1b12	a4 2d		ldy $2d				ldy 	zTemp1+1
.1b14	60		rts				rts
.1b15					_IVSyntax:
.1b15	4c 3a 1f	jmp $1f3a		jmp	ErrorV_syntax
.1b18					CommandGOSUB:
.1b18	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1b1a	20 2b 1b	jsr $1b2b			jsr 	CompileBranchCommand
.1b1d	60		rts				rts
.1b1e					CommandGOAlt:
.1b1e	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1b20	20 56 11	jsr $1156			jsr 	CheckNextA
.1b23	80 00		bra $1b25			bra 	CommandGOTO
.1b25					CommandGOTO:
.1b25	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1b27	20 2b 1b	jsr $1b2b			jsr 	CompileBranchCommand
.1b2a	60		rts				rts
.1b2b					CompileBranchCommand:
.1b2b	20 f1 10	jsr $10f1			jsr 	WriteCodeByte 				; write the command out.
.1b2e	20 5b 1a	jsr $1a5b			jsr 	GetNextNonSpace
.1b31	20 a4 1c	jsr $1ca4			jsr 	ParseConstant 				; get constant into YA
.1b34	90 08		bcc $1b3e			bcc 	_CBCSyntax
.1b36	20 f1 10	jsr $10f1			jsr 	WriteCodeByte				; and compile the actual line number
.1b39	98		tya				tya
.1b3a	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1b3d	60		rts				rts
.1b3e					_CBCSyntax:
.1b3e	4c 3a 1f	jmp $1f3a		jmp	ErrorV_syntax
.1b41					CommandIF:
.1b41	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; what follows the tests ?
.1b44	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1b46	f0 0f		beq $1b57			beq 	_CIGoto
.1b48	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1b4a	20 56 11	jsr $1156			jsr 	CheckNextA
.1b4d	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; THEN <number>
.1b50	20 65 1a	jsr $1a65			jsr 	CharIsDigit
.1b53	b0 05		bcs $1b5a			bcs 	_CIGoto2
.1b55	80 09		bra $1b60			bra 	CompileGotoEOL
.1b57					_CIGoto:
.1b57	20 50 1a	jsr $1a50			jsr 	GetNext
.1b5a					_CIGoto2:
.1b5a	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1b5c	20 2b 1b	jsr $1b2b			jsr 	CompileBranchCommand
.1b5f	60		rts				rts
.1b60					CompileGotoEOL:
.1b60	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.1b62	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1b65	20 ea 10	jsr $10ea			jsr 	GetLineNumber 				; Get the current line number => YA
.1b68	1a		inc a				inc 	a 							; and branch to +1
.1b69	d0 01		bne $1b6c			bne 	_CGENoCarry
.1b6b	c8		iny				iny
.1b6c					_CGENoCarry:
.1b6c	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1b6f	98		tya				tya
.1b70	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1b73	60		rts				rts
.1b74					CommandINPUT:
.1b74	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; check for "
.1b77	c9 22		cmp #$22			cmp 	#'"'
.1b79	d0 0d		bne $1b88			bne 	CommandINPUTStream
.1b7b	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0
.1b7e	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1b80	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1b83	a9 2c		lda #$2c			lda 	#","
.1b85	20 4c 11	jsr $114c			jsr 	CheckNextComma
.1b88					CommandINPUTStream:
.1b88	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1b8a	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1b8d	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.1b8f	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1b91	4c 16 1d	jmp $1d16			jmp 	CommandReadInputCommon
.1b94					CommandLET:
.1b94	20 5b 1a	jsr $1a5b			jsr 	GetNextNonSpace 			; get the first character
.1b97					CommandLETHaveFirst:
.1b97	20 9c 1d	jsr $1d9c			jsr 	GetReferenceTerm 			; identify variable to assign to
.1b9a	da		phx				phx 								; save target on the stack.
.1b9b	5a		phy				phy
.1b9c	48		pha				pha
.1b9d	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.1b9f	20 56 11	jsr $1156			jsr 	CheckNextA
.1ba2	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1ba5	85 2a		sta $2a				sta 	zTemp0 						; save type returned
.1ba7	68		pla				pla 								; get type of assignment
.1ba8	48		pha				pha
.1ba9	45 2a		eor $2a				eor 	zTemp0 						; compare using EOR
.1bab	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.1bad	d0 17		bne $1bc6			bne 	_CLType
.1baf	68		pla				pla 								; restore and compile save code
.1bb0	7a		ply				ply
.1bb1	fa		plx				plx
.1bb2	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.1bb4	f0 05		beq $1bbb			beq 	_CLTIString
.1bb6	38		sec				sec
.1bb7	20 4e 1d	jsr $1d4e			jsr		GetSetVariable
.1bba	60		rts				rts
.1bbb					_CLTIString:
.1bbb	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.1bbd	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1bc0	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.1bc2	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1bc5	60		rts				rts
.1bc6					_CLType:
.1bc6	4c 4a 1f	jmp $1f4a		jmp	ErrorV_type
.1bc9					STRMarkLine:
.1bc9	48		pha				pha
.1bca	38		sec				sec 								; allocate 4 bytes (line #,address)
.1bcb	ad 0f 05	lda $050f			lda 	lineNumberTable 			; and copy to zTemp0
.1bce	e9 04		sbc #$04			sbc 	#4
.1bd0	8d 0f 05	sta $050f			sta 	lineNumberTable
.1bd3	85 2a		sta $2a				sta 	zTemp0
.1bd5	ad 10 05	lda $0510			lda 	lineNumberTable+1
.1bd8	e9 00		sbc #$00			sbc 	#0
.1bda	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1bdd	85 2b		sta $2b				sta 	zTemp0+1
.1bdf	68		pla				pla
.1be0	92 2a		sta ($2a)			sta 	(zTemp0) 					; line # save it in +0,+1
.1be2	98		tya				tya
.1be3	a0 01		ldy #$01			ldy 	#1
.1be5	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1be7	a5 28		lda $28				lda 	objPtr 						; save current address in +2,+3
.1be9	c8		iny				iny
.1bea	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1bec	a5 29		lda $29				lda 	objPtr+1
.1bee	c8		iny				iny
.1bef	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1bf1	60		rts				rts
.1bf2					STRFindLine:
.1bf2	85 2a		sta $2a				sta 	zTemp0 						; zTemp0 line number being searched
.1bf4	84 2b		sty $2b				sty 	zTemp0+1
.1bf6	ad 08 05	lda $0508			lda 	compilerEndHigh 			; work backwards through table
.1bf9	85 2d		sta $2d				sta 	zTemp1+1
.1bfb	64 2c		stz $2c				stz 	zTemp1
.1bfd					_STRSearch:
.1bfd	20 34 1c	jsr $1c34			jsr 	_STRPrevLine 				; look at previous record.
.1c00	a0 01		ldy #$01			ldy 	#1
.1c02	b2 2c		lda ($2c)			lda 	(zTemp1) 					; check table line # >= target
.1c04	c5 2a		cmp $2a				cmp 	zTemp0
.1c06	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c08	e5 2b		sbc $2b				sbc 	zTemp0+1
.1c0a	b0 0b		bcs $1c17			bcs 	_STRFound 					; >=
.1c0c					_STRNext:
.1c0c	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1c0e	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c10	c9 ff		cmp #$ff			cmp 	#$FF
.1c12	d0 e9		bne $1bfd			bne 	_STRSearch
.1c14	4c 94 1f	jmp $1f94		jmp	ErrorV_internal
.1c17					_STRFound:
.1c17	b2 2c		lda ($2c)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1c19	45 2a		eor $2a				eor 	zTemp0
.1c1b	d0 06		bne $1c23			bne 	_STRDifferent
.1c1d	b2 2c		lda ($2c)			lda 	(zTemp1)
.1c1f	45 2a		eor $2a				eor 	zTemp0
.1c21	f0 02		beq $1c25			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1c23					_STRDifferent:
.1c23	a9 ff		lda #$ff			lda 	#$FF
.1c25					_STROut:
.1c25	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1c26	69 ff		adc #$ff			adc 	#255
.1c28	08		php				php
.1c29	c8		iny				iny 								; address into YA
.1c2a	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c2c	48		pha				pha
.1c2d	c8		iny				iny
.1c2e	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c30	a8		tay				tay
.1c31	68		pla				pla
.1c32	28		plp				plp
.1c33	60		rts				rts
.1c34					_STRPrevLine:
.1c34	38		sec				sec 								; move backwards one entry.
.1c35	a5 2c		lda $2c				lda 	zTemp1
.1c37	e9 04		sbc #$04			sbc 	#4
.1c39	85 2c		sta $2c				sta 	zTemp1
.1c3b	a5 2d		lda $2d				lda 	zTemp1+1
.1c3d	e9 00		sbc #$00			sbc 	#0
.1c3f	85 2d		sta $2d				sta 	zTemp1+1
.1c41	60		rts				rts
.1c42					STRMakeOffset:
.1c42	18		clc				clc 								; borrow 1
.1c43	e5 28		sbc $28				sbc 	objPtr
.1c45	48		pha				pha
.1c46	98		tya				tya
.1c47	e5 29		sbc $29				sbc 	objPtr+1
.1c49	a8		tay				tay
.1c4a	68		pla				pla
.1c4b	60		rts				rts
.1c4c					CommandNEXT:
.1c4c	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1c4f	20 71 1a	jsr $1a71			jsr 	CharIsAlpha 				; if not alpha , error
.1c52	90 0c		bcc $1c60			bcc 	_CNNoReferenceGiven
.1c54	20 50 1a	jsr $1a50			jsr 	GetNext
.1c57	20 9c 1d	jsr $1d9c			jsr 	GetReferenceTerm 			; figure out the reference.
.1c5a	8a		txa				txa 								; reference in YA
.1c5b	20 fa 11	jsr $11fa			jsr 	PushIntegerYA 				; write it out.
.1c5e	80 06		bra $1c66			bra 	_CNParametersDone
.1c60					_CNNoReferenceGiven:
.1c60	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1c62	a8		tay				tay
.1c63	20 fa 11	jsr $11fa			jsr 	PushIntegerYA 				; write it out.
.1c66					_CNParametersDone:
.1c66	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1c68	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1c6b	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; look for ,
.1c6e	c9 2c		cmp #$2c			cmp 	#","
.1c70	d0 05		bne $1c77			bne 	_CNExit
.1c72	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume ,
.1c75	80 d5		bra $1c4c			bra 	CommandNEXT 				; and go round.
.1c77					_CNExit:
.1c77	60		rts				rts
.1c78					CommandON:
.1c78	20 5b 1a	jsr $1a5b			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1c7b	48		pha				pha 								; save on stack
.1c7c	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1c7e	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1c80	f0 09		beq $1c8b			beq 	_COCreateLoop
.1c82	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1c84	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1c86	f0 03		beq $1c8b			beq 	_COCreateLoop
.1c88	4c 3a 1f	jmp $1f3a		jmp	ErrorV_syntax
.1c8b					_COCreateLoop:
.1c8b	8a		txa				txa 								; compile a goto/gosub somewhere
.1c8c	da		phx				phx
.1c8d	20 2b 1b	jsr $1b2b			jsr 	CompileBranchCommand
.1c90	fa		plx				plx
.1c91	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace			; ',' follows
.1c94	c9 2c		cmp #$2c			cmp 	#","
.1c96	d0 0a		bne $1ca2			bne 	_COComplete 				; if so, more line numbers
.1c98	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1c9a	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1c9d	20 50 1a	jsr $1a50			jsr 	GetNext
.1ca0	80 e9		bra $1c8b			bra 	_COCreateLoop
.1ca2					_COComplete:
.1ca2	68		pla				pla 								; throw GOTO/GOSUB
.1ca3	60		rts				rts
.1ca4					ParseConstant:
.1ca4	a2 00		ldx #$00			ldx 	#0
.1ca6	20 60 24	jsr $2460			jsr 	FloatEncodeStart 			; send first
.1ca9					_ParseLoop:
.1ca9	20 3f 1a	jsr $1a3f			jsr 	LookNext 					; send subsequent
.1cac	20 63 24	jsr $2463			jsr 	FloatEncodeContinue
.1caf	90 05		bcc $1cb6			bcc 	_ParseDone
.1cb1	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume it
.1cb4	80 f3		bra $1ca9			bra 	_ParseLoop
.1cb6					_ParseDone:
.1cb6	b5 30		lda $30,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1cb8	29 80		and #$80			and 	#$80
.1cba	15 6c		ora $6c,x			ora 	NSExponent,x 				; 16 bit int check
.1cbc	15 54		ora $54,x			ora 	NSMantissa2,x
.1cbe	15 60		ora $60,x			ora 	NSMantissa3,x
.1cc0	18		clc				clc
.1cc1	d0 05		bne $1cc8			bne 	_ParseExit 					; exit with CC if need float to compile
.1cc3	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; read into YA.
.1cc5	b4 48		ldy $48,x			ldy		NSMantissa1,x
.1cc7	38		sec				sec
.1cc8					_ParseExit:
.1cc8	60		rts				rts
.1cc9					CommandPRINT:
.1cc9	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace			; what follows ?
.1ccc	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1cce	f0 1f		beq $1cef			beq 	_CPCheckEnd
.1cd0	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1cd2	f0 16		beq $1cea			beq 	_CPTabCheckEnd
.1cd4	20 06 1d	jsr $1d06			jsr 	_CPAtEnd 					; check for : and EOL
.1cd7	b0 22		bcs $1cfb			bcs 	_CPExitCR 					; exit with CR
.1cd9	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; so it is something to print
.1cdc	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1cde	29 40		and #$40			and 	#NSSString 					; if string
.1ce0	d0 02		bne $1ce4			bne 	_CPOut
.1ce2	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1ce4					_CPOut:
.1ce4	8a		txa				txa 								; print that thing
.1ce5	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1ce8	80 df		bra $1cc9			bra 	CommandPRINT 				; and loop round/
.1cea					_CPTabCheckEnd:
.1cea	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1cec	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1cef					_CPCheckEnd:
.1cef	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume it.
.1cf2	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; what follows ?
.1cf5	20 06 1d	jsr $1d06			jsr 	_CPAtEnd 					; reached end
.1cf8	90 cf		bcc $1cc9			bcc 	CommandPRINT 				; no, loop back
.1cfa	60		rts				rts
.1cfb					_CPExitCR:
.1cfb	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1cfd	20 0d 12	jsr $120d			jsr 	PushIntegerA
.1d00	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1d02	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1d05	60		rts				rts
.1d06					_CPAtEnd:
.1d06	c9 00		cmp #$00			cmp 	#0
.1d08	f0 06		beq $1d10			beq 	_CPIsEnd
.1d0a	c9 3a		cmp #$3a			cmp 	#":"
.1d0c	f0 02		beq $1d10			beq 	_CPIsEnd
.1d0e	18		clc				clc
.1d0f	60		rts				rts
.1d10					_CPIsEnd:
.1d10	38		sec				sec
.1d11	60		rts				rts
.1d12					CommandREAD:
.1d12	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1d14	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1d16					CommandReadInputCommon:
.1d16	8e 0d 05	stx $050d			stx 	numberPCode
.1d19	8c 0e 05	sty $050e			sty 	stringPCode
.1d1c					_CRLoop:
.1d1c	20 5b 1a	jsr $1a5b			jsr 	GetNextNonSpace 			; first char of identifier
.1d1f	20 71 1a	jsr $1a71			jsr 	CharIsAlpha 				; check A-Z
.1d22	90 27		bcc $1d4b			bcc 	_CRSyntax
.1d24	20 9c 1d	jsr $1d9c			jsr 	GetReferenceTerm 			; get the variable.
.1d27	48		pha				pha 								; save type.
.1d28	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1d2a	c9 40		cmp #$40			cmp 	#NSSString
.1d2c	f0 05		beq $1d33			beq 	_CRString
.1d2e	ad 0d 05	lda $050d			lda 	numberPCode 				; output read/input
.1d31	80 03		bra $1d36			bra 	_CRHaveType
.1d33					_CRString:
.1d33	ad 0e 05	lda $050e			lda 	stringPCode					; output read$/input$
.1d36					_CRHaveType:
.1d36	20 f1 10	jsr $10f1			jsr 	WriteCodeByte 				; so we have one typed data item.
.1d39	68		pla				pla 								; restore type
.1d3a	38		sec				sec  								; write update code.
.1d3b	20 4e 1d	jsr $1d4e			jsr 	GetSetVariable
.1d3e	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; , follows ?
.1d41	c9 2c		cmp #$2c			cmp 	#","
.1d43	d0 05		bne $1d4a			bne 	_CRExit 					; if not, end of READ.
.1d45	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume comma
.1d48	80 d2		bra $1d1c			bra 	_CRLoop 					; keep going
.1d4a					_CRExit:
.1d4a	60		rts				rts
.1d4b					_CRSyntax:
.1d4b	4c 3a 1f	jmp $1f3a		jmp	ErrorV_syntax
.050d					numberPCode:
>050d							.fill 	1
.050e					stringPCode:
>050e							.fill 	1
.1d4e					GetSetVariable:
.1d4e	08		php				php 								; save direction on stack
.1d4f	c0 00		cpy #$00			cpy 	#$00
.1d51	30 21		bmi $1d74			bmi 	_GSVReadWriteSpecial
.1d53	c9 00		cmp #$00			cmp 	#$00
.1d55	30 33		bmi $1d8a			bmi 	_GSVArray
.1d57	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1d59	4a		lsr a				lsr 	a 							; divide by 2
.1d5a	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1d5c	28		plp				plp
.1d5d	90 02		bcc $1d61			bcc 	_GSVNotWrite
.1d5f	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1d61					_GSVNotWrite:
.1d61	85 2a		sta $2a				sta 	zTemp0
.1d63	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1d64	4a		lsr a				lsr 	a
.1d65	a8		tay				tay
.1d66	8a		txa				txa
.1d67	6a		ror a				ror 	a
.1d68	aa		tax				tax
.1d69	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1d6a	05 2a		ora $2a				ora 	zTemp0 						; which is the first byte of the opcode
.1d6c	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1d6f	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1d70	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1d73	60		rts				rts
.1d74					_GSVReadWriteSpecial:
.1d74	28		plp				plp
.1d75	b0 10		bcs $1d87			bcs 	_GSVSyntax
.1d77	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1d79	f0 06		beq $1d81			beq 	_GSVRWString
.1d7b	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1d7d	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1d80	60		rts				rts
.1d81					_GSVRWString:
.1d81	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1d83	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1d86	60		rts				rts
.1d87					_GSVSyntax:
.1d87	4c 3a 1f	jmp $1f3a		jmp	ErrorV_syntax
.1d8a					_GSVArray:
.1d8a	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1d8c	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1d8d	4a		lsr a				lsr 	a
.1d8e	4a		lsr a				lsr 	a
.1d8f	4a		lsr a				lsr 	a
.1d90	4a		lsr a				lsr 	a
.1d91	28		plp				plp 								; if writing array then set bit 2.
.1d92	90 02		bcc $1d96			bcc 	_GSVANotWrite
.1d94	09 04		ora #$04			ora 	#4
.1d96					_GSVANotWrite:
.1d96	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1d98	20 f1 10	jsr $10f1			jsr 	WriteCodeByte 				; and write it out
.1d9b	60		rts				rts
.1d9c					GetReferenceTerm:
.1d9c	20 c0 1a	jsr $1ac0			jsr 	ExtractVariableName 		; get name & type info
.1d9f	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1da1	30 10		bmi $1db3			bmi 	_GRTArray
.1da3	da		phx				phx 								; save type on stack
.1da4	20 b5 14	jsr $14b5			jsr 	FindVariable 				; find it
.1da7	b0 06		bcs $1daf			bcs 	_GRTNoCreate 				; create if required.
.1da9	20 3f 12	jsr $123f			jsr 	CreateVariableRecord 		; create a variable.
.1dac	20 94 12	jsr $1294			jsr 	AllocateBytesForType 		; allocate memory for it
.1daf					_GRTNoCreate:
.1daf	68		pla				pla 								; get type back, strip out type information.
.1db0	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1db2	60		rts				rts
.1db3					_GRTArray:
.1db3	da		phx				phx 								; save type information
.1db4	20 b5 14	jsr $14b5			jsr 	FindVariable 				; read its data, the base address in YX
.1db7	90 18		bcc $1dd1			bcc 	_GRTUndeclared 				; undeclared array.
.1db9	da		phx				phx 								; save base address
.1dba	5a		phy				phy
.1dbb	20 8b 13	jsr $138b			jsr 	OutputIndexGroup 			; create an index group and generate them
.1dbe	7a		ply				ply 								; get the array base address into YX
.1dbf	fa		plx				plx
.1dc0	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1dc2	18		clc				clc
.1dc3	20 4e 1d	jsr $1d4e			jsr 	GetSetVariable 				; load the address of the array structure.
.1dc6	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1dc8	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1dcb	68		pla				pla 								; and the type data into A
.1dcc	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1dce	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1dd0	60		rts				rts
.1dd1					_GRTUndeclared:
.1dd1	4c f1 1f	jmp $1ff1		jmp	ErrorV_undeclared
.1dd4					CommandREM:
.1dd4	20 3f 1a	jsr $1a3f			jsr 	LookNext
.1dd7	f0 05		beq $1dde			beq 	_CRExit
.1dd9	20 50 1a	jsr $1a50			jsr 	GetNext
.1ddc	80 f6		bra $1dd4			bra 	CommandREM
.1dde					_CRExit:
.1dde	60		rts				rts
.1ddf					STRReset:
.1ddf	ad 07 05	lda $0507			lda	 	compilerStartHigh 			; set up the two table pointers
.1de2	8d 12 05	sta $0512			sta 	variableListEnd+1
.1de5	9c 11 05	stz $0511			stz 	variableListEnd
.1de8	ad 08 05	lda $0508			lda 	compilerEndHigh
.1deb	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1dee	9c 0f 05	stz $050f			stz 	lineNumberTable
.1df1	ad 11 05	lda $0511			lda 	variableListEnd
.1df4	85 2b		sta $2b				sta 	zTemp0+1
.1df6	64 2a		stz $2a				stz 	zTemp0
.1df8	a9 00		lda #$00			lda 	#0
.1dfa	92 2a		sta ($2a)			sta 	(zTemp0)
.1dfc	a9 00		lda #$00			lda 	#((0) & $FF)
.1dfe	8d 13 05	sta $0513			sta 	0+freeVariableMemory
.1e01	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1e03	8d 14 05	sta $0514			sta 	1+freeVariableMemory
.1e06	60		rts				rts
.050f					lineNumberTable:
>050f							.fill 	2
.0511					variableListEnd:
>0511							.fill 	2
.0513					freeVariableMemory:
>0513							.fill 	2
.1e07					CompileTerm:
.1e07	20 5b 1a	jsr $1a5b			jsr 	GetNextNonSpace 			; get first non space character.
.1e0a	30 72		bmi $1e7e			bmi 	_CTUnaryFunctions
.1e0c	20 65 1a	jsr $1a65			jsr 	CharIsDigit 				; found a number
.1e0f	b0 3a		bcs $1e4b			bcs 	_CTDigit
.1e11	c9 2e		cmp #$2e			cmp 	#"."
.1e13	f0 36		beq $1e4b			beq 	_CTDigit
.1e15	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1e17	f0 43		beq $1e5c			beq 	_CTString
.1e19	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1e1b	f0 28		beq $1e45			beq 	_CTOtherBase
.1e1d	c9 24		cmp #$24			cmp 	#"$"
.1e1f	f0 24		beq $1e45			beq 	_CTOtherBase
.1e21	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1e23	f0 17		beq $1e3c			beq 	_CTBrackets
.1e25	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1e27	90 10		bcc $1e39			bcc 	_CTSyntax
.1e29	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1e2b	b0 0c		bcs $1e39			bcs 	_CTSyntax
.1e2d	20 9c 1d	jsr $1d9c			jsr 	GetReferenceTerm 			; figure out what it is.
.1e30	48		pha				pha 								; save type on stack
.1e31	18		clc				clc 								; read it
.1e32	20 4e 1d	jsr $1d4e			jsr 	GetSetVariable
.1e35	68		pla				pla
.1e36	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1e38	60		rts				rts
.1e39					_CTSyntax:
.1e39	4c 3a 1f	jmp $1f3a		jmp	ErrorV_syntax
.1e3c					_CTBrackets:
.1e3c	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0
.1e3f	48		pha				pha
.1e40	20 50 11	jsr $1150			jsr 	CheckNextRParen
.1e43	68		pla				pla
.1e44	60		rts				rts
.1e45					_CTOtherBase:
.1e45	20 9f 10	jsr $109f			jsr 	InlineNonDecimal 			; non decimal constant handler
.1e48	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e4a	60		rts				rts
.1e4b					_CTDigit:
.1e4b	20 a4 1c	jsr $1ca4			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1e4e	90 06		bcc $1e56			bcc	 	_CTFloat 					; have a float or long int.
.1e50	20 fa 11	jsr $11fa			jsr 	PushIntegerYA 				; code to push on stack
.1e53	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e55	60		rts				rts
.1e56					_CTFloat:
.1e56	20 1c 12	jsr $121c			jsr 	PushFloat  					; code to push float
.1e59	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1e5b	60		rts				rts
.1e5c					_CTString:
.1e5c	20 25 11	jsr $1125			jsr 	BufferClear 				; copy it to the buffer
.1e5f					_CTStringLoop:
.1e5f	20 3f 1a	jsr $1a3f			jsr 	LookNext 					; reached EOL/EOS
.1e62	f0 d5		beq $1e39			beq 	_CTSyntax
.1e64	c9 22		cmp #$22			cmp 	#'"'
.1e66	f0 08		beq $1e70			beq 	_CTStringDone
.1e68	20 29 11	jsr $1129			jsr 	BufferWrite 				; write and consume
.1e6b	20 50 1a	jsr $1a50			jsr 	GetNext
.1e6e	80 ef		bra $1e5f			bra 	_CTStringLoop
.1e70					_CTStringDone:
.1e70	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume closing quote.
.1e73	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1e75	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1e78	20 35 11	jsr $1135			jsr 	BufferOutput
.1e7b	a9 40		lda #$40			lda 	#NSSString 					; string type
.1e7d	60		rts				rts
.1e7e					_CTUnaryFunctions:
.1e7e	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1e80	f0 0a		beq $1e8c			beq 	_CTNegation
.1e82	a2 e7		ldx #$e7			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1e84	a0 17		ldy #$17			ldy 	#UnaryTables >> 8
.1e86	20 e1 18	jsr $18e1			jsr 	GeneratorProcess
.1e89	90 ae		bcc $1e39			bcc		_CTSyntax
.1e8b	60		rts				rts
.1e8c					_CTNegation:
.1e8c	20 07 1e	jsr $1e07			jsr 	CompileTerm 				; compile a term.
.1e8f	48		pha				pha
.1e90	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1e92	c9 00		cmp #$00			cmp 	#NSSIFloat
.1e94	d0 07		bne $1e9d			bne 	_CTType 					; error
.1e96	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1e98	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1e9b	68		pla				pla 								; return original type.
.1e9c	60		rts				rts
.1e9d					_CTType:
.1e9d	4c 4a 1f	jmp $1f4a		jmp	ErrorV_type
.1ea0					CommandWAIT:
.1ea0	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace
.1ea3	c9 2c		cmp #$2c			cmp 	#","
.1ea5	f0 10		beq $1eb7			beq 	_CWThirdParameter
.1ea7	a9 00		lda #$00			lda 	#0
.1ea9	20 0d 12	jsr $120d			jsr 	PushIntegerA
.1eac					_CWExit:
.1eac	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1eae	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1eb1	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1eb3	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1eb6	60		rts				rts
.1eb7					_CWThirdParameter:
.1eb7	20 50 1a	jsr $1a50			jsr 	GetNext
.1eba	20 fd 13	jsr $13fd			jsr 	CompileExpressionAtA
.1ebd	29 40		and #$40			and 	#NSSTypeMask
.1ebf	c9 00		cmp #$00			cmp 	#NSSIFloat
.1ec1	f0 e9		beq $1eac			beq 	_CWExit
.1ec3	4c 4a 1f	jmp $1f4a		jmp	ErrorV_type
.1ec6					CommandCMD:
.1ec6	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.1ec8	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1ecb	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; followed by a , ?
.1ece	c9 2c		cmp #$2c			cmp 	#","
.1ed0	d0 06		bne $1ed8			bne 	_CCMDExit
.1ed2	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume comma.
.1ed5	20 c9 1c	jsr $1cc9			jsr 	CommandPRINT 				; do the print code
.1ed8					_CCMDExit:
.1ed8	60		rts				rts
.1ed9					CommandOPEN:
.1ed9	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; followed by a , ?
.1edc	c9 2c		cmp #$2c			cmp 	#","
.1ede	d0 15		bne $1ef5			bne 	_COTwoDefaults
.1ee0	20 50 1a	jsr $1a50			jsr 	GetNext 					; consume comma
.1ee3	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1ee6	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1ee8	f0 1e		beq $1f08			beq 	_COThreeIntegers
.1eea	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1eec	20 0d 12	jsr $120d			jsr 	PushIntegerA
.1eef	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1ef1	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1ef4	60		rts				rts
.1ef5					_COTwoDefaults:
.1ef5	a9 00		lda #$00			lda 	#0
.1ef7	20 0d 12	jsr $120d			jsr 	PushIntegerA
.1efa					_COCompileNullString:
.1efa	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1efc	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1eff	a9 00		lda #$00			lda 	#0
.1f01	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1f04	20 f1 10	jsr $10f1			jsr 	WriteCodeByte
.1f07	60		rts				rts
.1f08					_COThreeIntegers:
.1f08	20 42 1a	jsr $1a42			jsr 	LookNextNonSpace 			; is there a ,
.1f0b	c9 2c		cmp #$2c			cmp 	#","
.1f0d	d0 eb		bne $1efa			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1f0f	20 50 1a	jsr $1a50			jsr 	GetNext
.1f12	20 fb 13	jsr $13fb			jsr 	CompileExpressionAt0 		; should be a filename
.1f15	29 40		and #$40			and 	#NSSString
.1f17	f0 01		beq $1f1a			beq 	_COType
.1f19	60		rts				rts
.1f1a					_COType:
.1f1a	4c 4a 1f	jmp $1f4a		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					objPtr:
>0028							.fill 	2
.002a					zTemp0:
>002a							.fill 	2
.002c					zTemp1:
>002c							.fill 	2
.002e					zTemp2:
>002e							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1f1d					ErrorV_range:
.1f1d	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f20	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f28	41 4e 47 45 00
.1f2d					ErrorV_value:
.1f2d	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f30	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f38	45 00
.1f3a					ErrorV_syntax:
.1f3a	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f3d	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f45	52 52 4f 52 00
.1f4a					ErrorV_type:
.1f4a	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f4d	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f55	4d 41 54 43 48 00
.1f5b					ErrorV_unimplemented:
.1f5b	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f5e	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f66	45 4d 45 4e 54 45 44 00
.1f6e					ErrorV_assert:
.1f6e	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f71	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f79	41 49 4c 00
.1f7d					ErrorV_line:
.1f7d	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f80	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f88	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f94					ErrorV_internal:
.1f94	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1f97	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f9f	20 45 52 52 4f 52 00
.1fa6					ErrorV_divzero:
.1fa6	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1fa9	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fb1	59 20 5a 45 52 4f 00
.1fb8					ErrorV_structure:
.1fb8	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1fbb	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fc3	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fcf					ErrorV_stop:
.1fcf	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1fd2	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fda	53 54 4f 50 50 45 44 00
.1fe2					ErrorV_data:
.1fe2	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1fe5	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fed	41 54 41 00
.1ff1					ErrorV_undeclared:
.1ff1	20 b3 13	jsr $13b3		jsr	ErrorHandler
>1ff4	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1ffc	41 52 52 41 59 00
.2002					ErrorV_redefine:
.2002	20 b3 13	jsr $13b3		jsr	ErrorHandler
>2005	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>200d	44 45 46 49 4e 45 44 00
.2015					ErrorV_index:
.2015	20 b3 13	jsr $13b3		jsr	ErrorHandler
>2018	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2020	59 20 49 4e 44 45 58 00
.2028					ErrorV_memory:
.2028	20 b3 13	jsr $13b3		jsr	ErrorHandler
>202b	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2033	45 4d 4f 52 59 00
.2039					ErrorV_channel:
.2039	20 b3 13	jsr $13b3		jsr	ErrorHandler
>203c	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2044	54 50 55 54 20 45 52 52 4f 52 00
.204f					MoveObjectForward:
.204f	b2 28		lda ($28)			lda 	(objPtr) 					; get next
.2051	c9 ff		cmp #$ff			cmp 	#$FF
.2053	f0 36		beq $208b			beq 	_MOFEnd
.2055	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.2057	90 24		bcc $207d			bcc 	_MOFAdvance1 				; forward 1
.2059	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.205b	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.205d	90 20		bcc $207f			bcc 	_MOFAdvanceY
.205f	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2061	90 1a		bcc $207d			bcc 	_MOFAdvance1 				; forward 1
.2063	a8		tay				tay 								; read the size.
.2064	b9 c9 1f	lda $1fc9,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.2067	a8		tay				tay
.2068	c8		iny				iny 								; add 1 for the system token.
.2069	d0 14		bne $207f			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.206b	a0 01		ldy #$01			ldy 	#1 							; get length byte
.206d	b1 28		lda ($28),y			lda 	(objPtr),y
.206f	a8		tay				tay 								; into Y.
.2070	18		clc				clc
.2071	a5 28		lda $28				lda 	objPtr						; add 2 to the object pointer
.2073	69 02		adc #$02			adc 	#2
.2075	85 28		sta $28				sta 	objPtr
.2077	90 02		bcc $207b			bcc 	_MOFNoCarry1
.2079	e6 29		inc $29				inc 	objPtr+1
.207b					_MOFNoCarry1:
.207b	80 02		bra $207f			bra 	_MOFAdvanceY
.207d					_MOFAdvance1:
.207d	a0 01		ldy #$01			ldy 	#1
.207f					_MOFAdvanceY:
.207f	98		tya				tya 								; add Y to objPtr
.2080	18		clc				clc
.2081	65 28		adc $28				adc 	objPtr
.2083	85 28		sta $28				sta 	objPtr
.2085	90 02		bcc $2089			bcc 	_MOFNoCarry2
.2087	e6 29		inc $29				inc 	objPtr+1
.2089					_MOFNoCarry2:
.2089	18		clc				clc 								; not completed.
.208a	60		rts				rts
.208b					_MOFEnd:
.208b	e6 28		inc $28				inc 	objPtr
.208d	d0 02		bne $2091			bne 	_MOFENoCarry
.208f	e6 29		inc $29				inc 	objPtr+1
.2091					_MOFENoCarry:
.2091	38		sec				sec
.2092	60		rts				rts
.2093					MOFSizeTable:
>2093	01					.byte	1         	; $ca .shift
>2094	01					.byte	1         	; $cb .byte
>2095	02					.byte	2         	; $cc .word
>2096	05					.byte	5         	; $cd .float
>2097	ff					.byte	255       	; $ce .string
>2098	ff					.byte	255       	; $cf .data
>2099	02					.byte	2         	; $d0 .goto
>209a	02					.byte	2         	; $d1 .gosub
>209b	02					.byte	2         	; $d2 .goto.z
>209c	02					.byte	2         	; $d3 .goto.nz
>209d	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0030					NSStatus:
>0030							.fill 	MathStackSize
.003c					NSMantissa0:
>003c							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0048					NSMantissa1:
>0048							.fill 	MathStackSize
.0054					NSMantissa2:
>0054							.fill 	MathStackSize
.0060					NSMantissa3:
>0060							.fill 	MathStackSize
.006c					NSExponent:
>006c							.fill 	MathStackSize
.0515					numberBuffer:
>0515							.fill 	34
.209e					FloatSubtract:
.209e	b5 30		lda $30,x			lda 	NSStatus,x 					; negate top of stack
.20a0	49 80		eor #$80			eor 	#$80
.20a2	95 30		sta $30,x			sta 	NSStatus,x					; and fall through.
.20a4					FloatAdd:
.20a4	ca		dex				dex
.20a5	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised.
.20a7	15 6d		ora $6d,x			ora 	NSExponent+1,x
.20a9	15 60		ora $60,x			ora 	NSMantissa3,x
.20ab	15 61		ora $61,x			ora 	NSMantissa3+1,x
.20ad	d0 04		bne $20b3			bne 	_FAUseFloat
.20af	20 40 24	jsr $2440			jsr 	FloatInt32Add 				; use the int32 one.
.20b2	60		rts				rts
.20b3					_FAUseFloat:
.20b3	20 d5 23	jsr $23d5			jsr 	FloatNormalise 				; normalise S[X]
.20b6	f0 51		beq $2109			beq 	_FAReturn1
.20b8	e8		inx				inx 								; normalise S[X+1]
.20b9	20 d5 23	jsr $23d5			jsr 	FloatNormalise
.20bc	ca		dex				dex
.20bd	c9 00		cmp #$00			cmp 	#0
.20bf	f0 60		beq $2121			beq 	_FAExit 					; if so, just return A
.20c1	b5 6c		lda $6c,x			lda 	NSExponent,x 				; are the exponents the same ?
.20c3	d5 6d		cmp $6d,x			cmp 	NSExponent+1,x
.20c5	f0 18		beq $20df			beq 	_FAExponentsEqual
.20c7	b5 6c		lda $6c,x			lda 	NSExponent,x 				; work out the larger exponent
.20c9	a8		tay				tay
.20ca	38		sec				sec 								; do a signed comparison of the exponents.
.20cb	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.20cd	50 02		bvc $20d1			bvc 	_FANoSignedChange
.20cf	49 80		eor #$80			eor 	#$80
.20d1					_FANoSignedChange:
.20d1	29 80		and #$80			and 	#$80
.20d3	10 02		bpl $20d7			bpl 	_FAHaveMax
.20d5	b4 6d		ldy $6d,x			ldy 	NSExponent+1,x
.20d7					_FAHaveMax:
.20d7	20 22 21	jsr $2122			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20da	e8		inx				inx
.20db	20 22 21	jsr $2122			jsr 	_FAShiftToExponent
.20de	ca		dex				dex
.20df					_FAExponentsEqual:
.20df	b5 30		lda $30,x			lda 	NSStatus,x 					; are the signs the same
.20e1	55 31		eor $31,x			eor 	NSStatus+1,x
.20e3	30 0e		bmi $20f3			bmi 	_FADifferentSigns
.20e5	20 0c 24	jsr $240c			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20e8	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20ea	10 35		bpl $2121			bpl 	_FAExit 					; if no, we are done.
.20ec	20 99 26	jsr $2699			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20ef	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump the exponent and exit
.20f1	80 2e		bra $2121			bra 	_FAExit
.20f3					_FADifferentSigns:
.20f3	20 26 24	jsr $2426			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20f6	b5 60		lda $60,x			lda 	NSMantissa3,x 				; is the result negative ?
.20f8	10 06		bpl $2100			bpl 	_FACheckZero 				; if no, check for -0
.20fa	20 42 26	jsr $2642			jsr 	FloatNegate 					; netate result
.20fd	20 49 26	jsr $2649			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.2100					_FACheckZero:
.2100	20 a2 26	jsr $26a2			jsr 	FloatIsZero	 				; check for -0
.2103	d0 1c		bne $2121			bne 	_FAExit
.2105	74 30		stz $30,x			stz 	NSStatus,x
.2107	80 18		bra $2121			bra 	_FAExit
.2109					_FAReturn1:
.2109	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.210b	95 3c		sta $3c,x			sta 	NSMantissa0,x
.210d	b5 49		lda $49,x			lda 	NSMantissa1+1,x
.210f	95 48		sta $48,x			sta 	NSMantissa1,x
.2111	b5 55		lda $55,x			lda 	NSMantissa2+1,x
.2113	95 54		sta $54,x			sta 	NSMantissa2,x
.2115	b5 61		lda $61,x			lda 	NSMantissa3+1,x
.2117	95 60		sta $60,x			sta 	NSMantissa3,x
.2119	b5 6d		lda $6d,x			lda 	NSExponent+1,x
.211b	95 6c		sta $6c,x			sta 	NSExponent,x
.211d	b5 31		lda $31,x			lda 	NSStatus+1,x
.211f	95 30		sta $30,x			sta 	NSStatus,x
.2121					_FAExit:
.2121	60		rts				rts
.2122					_FAShiftToExponent:
.2122					_FAShiftToExponent2:
.2122	98		tya				tya 								; compare Y to exponent
.2123	d5 6c		cmp $6c,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2125	f0 07		beq $212e			beq 	_FASEExit 					; exit if so.
.2127	20 99 26	jsr $2699			jsr 	FloatShiftRight	 			; shift the mantissa right
.212a	f6 6c		inc $6c,x			inc 	NSExponent,x 				; increment exponent
.212c	80 f4		bra $2122			bra 	_FAShiftToExponent2
.212e					_FASEExit:
.212e	60		rts				rts
.212f					CompareEqual:
.212f	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2131	d0 09		bne $213c			bne 	ReturnFalse
.2133					ReturnTrue:
.2133	a9 01		lda #$01			lda 	#1
.2135	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2137	a9 80		lda #$80			lda 	#$80
.2139	95 30		sta $30,x			sta 	NSStatus,x
.213b	60		rts				rts
.213c					ReturnFalse:
.213c	74 3c		stz $3c,x			stz 	NSMantissa0,x
.213e	60		rts				rts
.213f					CompareNotEqual:
.213f	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2141	d0 f0		bne $2133			bne 	ReturnTrue
.2143	80 f7		bra $213c			bra 	ReturnFalse
.2145					CompareLess:
.2145	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2147	c9 ff		cmp #$ff			cmp 	#$FF
.2149	f0 e8		beq $2133			beq 	ReturnTrue
.214b	80 ef		bra $213c			bra 	ReturnFalse
.214d					CompareGreater:
.214d	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.214f	c9 01		cmp #$01			cmp 	#$01
.2151	f0 e0		beq $2133			beq 	ReturnTrue
.2153	80 e7		bra $213c			bra 	ReturnFalse
.2155					CompareLessEqual:
.2155	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2157	c9 01		cmp #$01			cmp 	#$01
.2159	d0 d8		bne $2133			bne 	ReturnTrue
.215b	80 df		bra $213c			bra 	ReturnFalse
.215d					CompareGreaterEqual:
.215d	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.215f	c9 ff		cmp #$ff			cmp 	#$FF
.2161	d0 d0		bne $2133			bne 	ReturnTrue
.2163	80 d7		bra $213c			bra 	ReturnFalse
.2165					FloatCompare:
.2165	b5 6c		lda $6c,x			lda 	NSExponent,x 				; float comparison.
.2167	15 6b		ora $6b,x			ora 	NSExponent-1,x 				; integer if both integer.
.2169	48		pha				pha
.216a	20 9e 20	jsr $209e			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.216d	68		pla				pla
.216e	d0 0c		bne $217c			bne 	_FCCompareFloat
.2170	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2172	15 48		ora $48,x			ora 	NSMantissa1,x
.2174	15 54		ora $54,x			ora 	NSMantissa2,x
.2176	15 60		ora $60,x			ora 	NSMantissa3,x
.2178	f0 14		beq $218e			beq 	_FCExit 					; if zero, return zero
.217a	80 0a		bra $2186			bra 	_FCSign
.217c					_FCCompareFloat:
.217c	b5 48		lda $48,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.217e	29 f0		and #$f0			and 	#$F0
.2180	15 54		ora $54,x			ora 	NSMantissa2,x
.2182	15 60		ora $60,x			ora 	NSMantissa3,x
.2184	f0 08		beq $218e			beq 	_FCExit 					; zero, so approximately identical
.2186					_FCSign:
.2186	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2188	34 30		bit $30,x			bit 	NSStatus,x
.218a	10 02		bpl $218e			bpl 	_FCExit
.218c					_FCNegative:
.218c	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.218e					_FCExit:
.218e	20 82 26	jsr $2682			jsr 	FloatSetByte 				; set the result 255,0,1
.2191	60		rts				rts
.2192					FloatScalarTable:
>2192	66 66 66 66				.dword $66666666 ; 0.1
>2196	de					.byte $de
>2197	1f 85 eb 51				.dword $51eb851f ; 0.01
>219b	db					.byte $db
>219c	4c 37 89 41				.dword $4189374c ; 0.001
>21a0	d8					.byte $d8
>21a1	ac 8b db 68				.dword $68db8bac ; 0.0001
>21a5	d4					.byte $d4
>21a6	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>21aa	d1					.byte $d1
>21ab	83 de 1b 43				.dword $431bde83 ; 1e-06
>21af	ce					.byte $ce
>21b0	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21b4	ca					.byte $ca
>21b5	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21b9	c7					.byte $c7
>21ba	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21be	c4					.byte $c4
>21bf	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21c3	c0					.byte $c0
>21c4	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21c8	bd					.byte $bd
.21c9					FloatDivide:
.21c9	48		pha				pha
.21ca	20 d5 23	jsr $23d5			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21cd	ca		dex				dex
.21ce	c9 00		cmp #$00			cmp 	#0
.21d0	f0 1e		beq $21f0			beq 	_FDZero
.21d2	20 d5 23	jsr $23d5			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21d5	f0 16		beq $21ed			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21d7	20 38 22	jsr $2238			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21da	20 05 22	jsr $2205			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21dd	20 d5 23	jsr $23d5			jsr		FloatNormalise 				; renormalise
.21e0	20 cb 23	jsr $23cb			jsr 	FloatCalculateSign 			; calculate result sign
.21e3	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent
.21e5	38		sec				sec
.21e6	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.21e8	38		sec				sec
.21e9	e9 1e		sbc #$1e			sbc 	#30
.21eb	95 6c		sta $6c,x			sta 	NSExponent,x
.21ed					_FDExit:
.21ed	68		pla				pla
.21ee	18		clc				clc
.21ef	60		rts				rts
.21f0					_FDZero:
.21f0	68		pla				pla
.21f1	38		sec				sec
.21f2	60		rts				rts
.21f3					DivideInt32:
.21f3	20 bb 22	jsr $22bb			jsr 	FloatIntegerPart 			; make both integers
.21f6	ca		dex				dex
.21f7	20 bb 22	jsr $22bb			jsr 	FloatIntegerPart
.21fa	20 16 22	jsr $2216			jsr 	Int32Divide 				; divide
.21fd	20 05 22	jsr $2205			jsr 	NSMCopyPlusTwoToZero 		; copy result
.2200	20 cb 23	jsr $23cb			jsr 	FloatCalculateSign 			; calculate result sign
.2203	18		clc				clc
.2204	60		rts				rts
.2205					NSMCopyPlusTwoToZero:
.2205	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.2207	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2209	b5 4a		lda $4a,x			lda 	NSMantissa1+2,x
.220b	95 48		sta $48,x			sta 	NSMantissa1,x
.220d	b5 56		lda $56,x			lda 	NSMantissa2+2,x
.220f	95 54		sta $54,x			sta 	NSMantissa2,x
.2211	b5 62		lda $62,x			lda 	NSMantissa3+2,x
.2213	95 60		sta $60,x			sta 	NSMantissa3,x
.2215	60		rts				rts
.2216					Int32Divide:
.2216	48		pha				pha 								; save AXY
.2217	5a		phy				phy
.2218	20 63 26	jsr $2663			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.221b	20 7c 26	jsr $267c			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.221e	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2220					_I32DivideLoop:
.2220	e8		inx				inx
.2221	e8		inx				inx
.2222	20 8f 26	jsr $268f			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2225	ca		dex				dex
.2226	ca		dex				dex
.2227	20 90 26	jsr $2690			jsr 	FloatRotateLeft
.222a	20 56 22	jsr $2256			jsr 	FloatDivideCheck 			; check if subtract possible
.222d	90 02		bcc $2231			bcc 	_I32DivideNoCarryIn
.222f	f6 3e		inc $3e,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2231					_I32DivideNoCarryIn:
.2231	88		dey				dey 								; loop round till division completed.
.2232	d0 ec		bne $2220			bne 	_I32DivideLoop
.2234	7a		ply				ply 								; restore AXY and exit
.2235	68		pla				pla
.2236	18		clc				clc
.2237	60		rts				rts
.2238					Int32ShiftDivide:
.2238	48		pha				pha 								; save AY
.2239	5a		phy				phy
.223a	e8		inx				inx 								; clear S[X+2]
.223b	e8		inx				inx
.223c	20 80 26	jsr $2680			jsr 	FloatSetZero
.223f	ca		dex				dex
.2240	ca		dex				dex
.2241	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2243					_I32SDLoop:
.2243	20 56 22	jsr $2256			jsr 	FloatDivideCheck 			; check if subtract possible
.2246	e8		inx				inx
.2247	e8		inx				inx
.2248	20 90 26	jsr $2690			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.224b	ca		dex				dex
.224c	ca		dex				dex
.224d	20 90 26	jsr $2690			jsr 	FloatRotateLeft
.2250	88		dey				dey 	 							; do 31 times
.2251	d0 f0		bne $2243			bne 	_I32SDLoop
.2253	7a		ply				ply 								; restore AY and exit
.2254	68		pla				pla
.2255	60		rts				rts
.2256					FloatDivideCheck:
.2256	20 26 24	jsr $2426			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.2259	b0 04		bcs $225f			bcs 	_DCSExit 					; if carry set, then could do, exit
.225b	20 0c 24	jsr $240c			jsr 	FloatAddTopTwoStack 		; add it back in
.225e	18		clc				clc 								; and return False
.225f					_DCSExit:
.225f	60		rts				rts
.2260					FloatFractionalPart:
.2260	5a		phy				phy
.2261	b5 30		lda $30,x			lda 	NSStatus,x 					; take absolute value
.2263	29 7f		and #$7f			and 	#$7F
.2265	95 30		sta $30,x			sta 	NSStatus,x
.2267	20 d5 23	jsr $23d5			jsr 	FloatNormalise
.226a	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.226c	38		sec				sec
.226d	e9 e0		sbc #$e0			sbc 	#$E0
.226f	90 29		bcc $229a			bcc 	_FFPExit 					; already fractional
.2271	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2273	b0 22		bcs $2297			bcs 	_FFPZero
.2275	a8		tay				tay 								; put count to do in Y
.2276	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do each in turn.
.2278	20 9f 22	jsr $229f			jsr 	_FFPPartial
.227b	95 60		sta $60,x			sta 	NSMantissa3,x
.227d	b5 54		lda $54,x			lda 	NSMantissa2,x
.227f	20 9f 22	jsr $229f			jsr 	_FFPPartial
.2282	95 54		sta $54,x			sta 	NSMantissa2,x
.2284	b5 48		lda $48,x			lda 	NSMantissa1,x
.2286	20 9f 22	jsr $229f			jsr 	_FFPPartial
.2289	95 48		sta $48,x			sta 	NSMantissa1,x
.228b	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.228d	20 9f 22	jsr $229f			jsr 	_FFPPartial
.2290	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2292	20 a2 26	jsr $26a2			jsr 	FloatIsZero 					; zeroed check.
.2295	d0 03		bne $229a			bne 	_FFPExit
.2297					_FFPZero:
.2297	20 80 26	jsr $2680			jsr 	FloatSetZero
.229a					_FFPExit:
.229a	20 d5 23	jsr $23d5			jsr 	FloatNormalise
.229d	7a		ply				ply
.229e	60		rts				rts
.229f					_FFPPartial:
.229f	c0 00		cpy #$00			cpy 	#0 							; no more to do
.22a1	f0 17		beq $22ba			beq 	_FFFPPExit
.22a3	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.22a5	b0 0c		bcs $22b3			bcs 	_FFFPPWholeByte
.22a7	5a		phy				phy
.22a8					_FFFPPLeft:
.22a8	0a		asl a				asl 	a
.22a9	88		dey				dey
.22aa	d0 fc		bne $22a8			bne 	_FFFPPLeft
.22ac	7a		ply				ply
.22ad					_FFFPPRight:
.22ad	4a		lsr a				lsr 	a
.22ae	88		dey				dey
.22af	d0 fc		bne $22ad			bne 	_FFFPPRight
.22b1	80 07		bra $22ba			bra 	_FFFPPExit
.22b3					_FFFPPWholeByte:
.22b3	98		tya				tya 								; subtract 8 from count
.22b4	38		sec				sec
.22b5	e9 08		sbc #$08			sbc 	#8
.22b7	a8		tay				tay
.22b8	a9 00		lda #$00			lda 	#0 							; and clear all
.22ba					_FFFPPExit:
.22ba	60		rts				rts
.22bb					FloatIntegerPart:
.22bb	48		pha				pha
.22bc	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.22be	f0 1d		beq $22dd			beq 	_FIPExit 					; if so do nothing
.22c0	20 a2 26	jsr $26a2			jsr 	FloatIsZero 				; is it zero ?
.22c3	f0 15		beq $22da			beq 	_FIPZero 					; if so return zero.
.22c5	20 d5 23	jsr $23d5			jsr 	FloatNormalise 				; normalise
.22c8	f0 10		beq $22da			beq 	_FIPZero 					; normalised to zero, exit zero
.22ca					_FIPShift:
.22ca	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22cc	10 07		bpl $22d5			bpl 	_FIPCheckZero
.22ce	20 99 26	jsr $2699			jsr 	FloatShiftRight 			; shift mantissa right
.22d1	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.22d3	80 f5		bra $22ca			bra 	_FIPShift
.22d5					_FIPCheckZero:
.22d5	20 a2 26	jsr $26a2			jsr 	FloatIsZero 				; avoid -0 problem
.22d8	d0 03		bne $22dd			bne 	_FIPExit 					; set to zero if mantissa zero.
.22da					_FIPZero:
.22da	20 80 26	jsr $2680			jsr 	FloatSetZero
.22dd					_FIPExit:
.22dd	68		pla				pla
.22de	60		rts				rts
.22df					FloatIntegerPartDown:
.22df	48		pha				pha
.22e0	5a		phy				phy
.22e1	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.22e3	f0 36		beq $231b			beq 	_FIPExit 					; if so do nothing
.22e5	20 a2 26	jsr $26a2			jsr 	FloatIsZero 				; is it zero ?
.22e8	f0 2e		beq $2318			beq 	_FIPZero 					; if so return zero.
.22ea	20 d5 23	jsr $23d5			jsr 	FloatNormalise 				; normalise
.22ed	f0 29		beq $2318			beq 	_FIPZero 					; normalised to zero, exit zero
.22ef	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22f1					_FIPShift:
.22f1	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22f3	10 0a		bpl $22ff			bpl 	_FIPCheckDown
.22f5	20 99 26	jsr $2699			jsr 	FloatShiftRight 			; shift mantissa right
.22f8	90 01		bcc $22fb			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22fa	c8		iny				iny
.22fb					_FIPNoFrac:
.22fb	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.22fd	80 f2		bra $22f1			bra 	_FIPShift
.22ff					_FIPCheckDown:
.22ff	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.2301	f0 10		beq $2313			beq 	_FIPCheckZero
.2303	34 30		bit $30,x			bit 	NSStatus,x 					; +ve
.2305	10 0c		bpl $2313			bpl 	_FIPCheckZero
.2307	e8		inx				inx 								; -ve so round *down*.
.2308	a9 01		lda #$01			lda 	#1
.230a	20 82 26	jsr $2682			jsr 	FloatSetByte
.230d	20 42 26	jsr $2642			jsr 	FloatNegate
.2310	20 a4 20	jsr $20a4			jsr 	FloatAdd
.2313					_FIPCheckZero:
.2313	20 a2 26	jsr $26a2			jsr 	FloatIsZero 				; avoid -0 problem
.2316	d0 03		bne $231b			bne 	_FIPExit 					; set to zero if mantissa zero.
.2318					_FIPZero:
.2318	20 80 26	jsr $2680			jsr 	FloatSetZero
.231b					_FIPExit:
.231b	7a		ply				ply
.231c	68		pla				pla
.231d	60		rts				rts
.231e					FloatInt8Multiply:
.231e	5a		phy				phy
.231f	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2321	a8		tay				tay
.2322	74 3c		stz $3c,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2324					_FI8MLoop:
.2324	98		tya				tya 								; shift right shifter right into carry
.2325	4a		lsr a				lsr 	a
.2326	a8		tay				tay
.2327	90 0d		bcc $2336			bcc 	_FI8MNoAdd
.2329	18		clc				clc
.232a	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.232c	75 3d		adc $3d,x			adc 	NSMantissa0+1,x
.232e	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2330	b5 48		lda $48,x			lda 	NSMantissa1,x
.2332	75 49		adc $49,x			adc 	NSMantissa1+1,x
.2334	95 48		sta $48,x			sta 	NSMantissa1,x
.2336					_FI8MNoAdd:
.2336	16 3d		asl $3d,x			asl 	NSMantissa0+1,x 			; shift adder left
.2338	36 49		rol $49,x			rol 	NSMantissa1+1,x
.233a	c0 00		cpy #$00			cpy 	#0
.233c	d0 e6		bne $2324			bne 	_FI8MLoop 					; until right shifter zero.
.233e	7a		ply				ply
.233f	60		rts				rts
.2340					FloatMultiply:
.2340	ca		dex				dex
.2341	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised ?
.2343	15 6d		ora $6d,x			ora 	NSExponent+1,x
.2345	15 60		ora $60,x			ora 	NSMantissa3,x
.2347	15 61		ora $61,x			ora 	NSMantissa3+1,x
.2349	d0 21		bne $236c			bne 	_FMUseFloat
.234b	b5 30		lda $30,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.234d	15 31		ora $31,x			ora 	NSStatus+1,x
.234f	29 80		and #$80			and 	#$80
.2351	15 60		ora $60,x			ora 	NSMantissa3,x
.2353	15 54		ora $54,x			ora 	NSMantissa2,x
.2355	15 48		ora $48,x			ora 	NSMantissa1,x
.2357	15 61		ora $61,x			ora 	NSMantissa3+1,x
.2359	15 55		ora $55,x			ora 	NSMantissa2+1,x
.235b	15 49		ora $49,x			ora 	NSMantissa1+1,x
.235d	d0 04		bne $2363			bne 	_FMInt32
.235f	20 1e 23	jsr $231e			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2362	60		rts				rts
.2363					_FMInt32:
.2363	20 8d 23	jsr $238d			jsr 	FloatMultiplyShort			; use the int32 one.
.2366	18		clc				clc 								; fix it up if gone out of range
.2367	75 6c		adc $6c,x			adc 	NSExponent,x
.2369	95 6c		sta $6c,x			sta 	NSExponent,x
.236b	60		rts				rts
.236c					_FMUseFloat:
.236c	20 d5 23	jsr $23d5			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.236f	f0 18		beq $2389			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2371	e8		inx				inx
.2372	20 d5 23	jsr $23d5			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2375	ca		dex				dex
.2376	c9 00		cmp #$00			cmp 	#0
.2378	f0 0c		beq $2386			beq 	_FDSetZero
.237a	20 8d 23	jsr $238d			jsr 	FloatMultiplyShort 			; calculate the result.
.237d	75 6c		adc $6c,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.237f	18		clc				clc
.2380	75 6d		adc $6d,x			adc 	NSExponent+1,x
.2382	95 6c		sta $6c,x			sta 	NSExponent,x
.2384	80 03		bra $2389			bra 	_FDExit
.2386					_FDSetZero:
.2386	20 80 26	jsr $2680			jsr 	FloatSetZero 				; return 0
.2389					_FDExit:
.2389	20 d5 23	jsr $23d5			jsr 	FloatNormalise 				; normalise the result
.238c	60		rts				rts
.238d					FloatMultiplyShort:
.238d	5a		phy				phy 								; save Y
.238e	20 63 26	jsr $2663			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2391	20 7c 26	jsr $267c			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2394	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2396					_I32MLoop:
.2396	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2398	15 4a		ora $4a,x			ora 	NSMantissa1+2,x
.239a	15 56		ora $56,x			ora 	NSMantissa2+2,x
.239c	15 62		ora $62,x			ora 	NSMantissa3+2,x
.239e	f0 25		beq $23c5			beq 	_I32MExit 					; exit if zero
.23a0	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.23a2	29 01		and #$01			and 	#1
.23a4	f0 0d		beq $23b3			beq 	_I32MNoAdd
.23a6	20 0c 24	jsr $240c			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.23a9	b5 60		lda $60,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.23ab	10 06		bpl $23b3			bpl 	_I32MNoAdd
.23ad					_I32ShiftRight:
.23ad	20 99 26	jsr $2699			jsr 	FloatShiftRight 			; shift S[X] right
.23b0	c8		iny				iny 								; increment shift count
.23b1	80 09		bra $23bc			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23b3					_I32MNoAdd:
.23b3	34 61		bit $61,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23b5	70 f6		bvs $23ad			bvs 	_I32ShiftRight 				; instead.
.23b7	e8		inx				inx
.23b8	20 8f 26	jsr $268f			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23bb	ca		dex				dex
.23bc					_I32MShiftUpper:
.23bc	e8		inx				inx 								; shift S[X+2] right
.23bd	e8		inx				inx
.23be	20 99 26	jsr $2699			jsr 	FloatShiftRight
.23c1	ca		dex				dex
.23c2	ca		dex				dex
.23c3	80 d1		bra $2396			bra 	_I32MLoop 					; try again.
.23c5					_I32MExit:
.23c5	20 cb 23	jsr $23cb			jsr 	FloatCalculateSign
.23c8	98		tya				tya 								; shift in A
.23c9	7a		ply				ply 								; restore Y and exit
.23ca	60		rts				rts
.23cb					FloatCalculateSign:
.23cb	b5 30		lda $30,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23cd	16 30		asl $30,x			asl 	NSStatus,x 					; shift result left
.23cf	55 31		eor $31,x			eor 	NSStatus+1,x
.23d1	0a		asl a				asl 	a 							; shift bit 7 into carry
.23d2	76 30		ror $30,x			ror 	NSStatus,x 					; shift right into status byte.
.23d4	60		rts				rts
.23d5					FloatNormalise:
.23d5	20 a2 26	jsr $26a2			jsr 	FloatIsZero 				; if zero exit
.23d8	d0 07		bne $23e1			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23da	16 30		asl $30,x			asl 	NSStatus,x 					; clear the sign bit.
.23dc	76 30		ror $30,x			ror 	NSStatus,x 					; (no -0)
.23de	a9 00		lda #$00			lda 	#0 							; set Z flag
.23e0	60		rts				rts
.23e1					_NSNormaliseOptimise:
.23e1	b5 60		lda $60,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23e3	d0 19		bne $23fe			bne 	_NSNormaliseLoop
.23e5	b5 54		lda $54,x			lda 	NSMantissa2,x 				; byte normalise
.23e7	30 15		bmi $23fe			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23e9	95 60		sta $60,x			sta 	NSMantissa3,x
.23eb	b5 48		lda $48,x			lda 	NSMantissa1,x
.23ed	95 54		sta $54,x			sta 	NSMantissa2,x
.23ef	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.23f1	95 48		sta $48,x			sta 	NSMantissa1,x
.23f3	74 3c		stz $3c,x			stz 	NSMantissa0,x
.23f5	b5 6c		lda $6c,x			lda 	NSExponent,x
.23f7	38		sec				sec
.23f8	e9 08		sbc #$08			sbc 	#8
.23fa	95 6c		sta $6c,x			sta 	NSExponent,x
.23fc	80 e3		bra $23e1			bra 	_NSNormaliseOptimise
.23fe					_NSNormaliseLoop:
.23fe	34 60		bit $60,x			bit 	NSMantissa3,x 				; bit 30 set ?
.2400	70 07		bvs $2409			bvs 	_NSNExit 					; exit if so with Z flag clear
.2402	20 8f 26	jsr $268f			jsr 	FloatShiftLeft 				; shift mantissa left
.2405	d6 6c		dec $6c,x			dec 	NSExponent,x 				; adjust exponent
.2407	80 f5		bra $23fe			bra 	_NSNormaliseLoop
.2409					_NSNExit:
.2409	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.240b	60		rts				rts
.240c					FloatAddTopTwoStack:
.240c	18		clc				clc
.240d	b5 3c		lda $3c,x			lda		NSMantissa0,x
.240f	75 3d		adc $3d,x			adc 		NSMantissa0+1,x
.2411	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2413	b5 48		lda $48,x			lda		NSMantissa1,x
.2415	75 49		adc $49,x			adc 		NSMantissa1+1,x
.2417	95 48		sta $48,x			sta 	NSMantissa1,x
.2419	b5 54		lda $54,x			lda		NSMantissa2,x
.241b	75 55		adc $55,x			adc 		NSMantissa2+1,x
.241d	95 54		sta $54,x			sta 	NSMantissa2,x
.241f	b5 60		lda $60,x			lda		NSMantissa3,x
.2421	75 61		adc $61,x			adc 		NSMantissa3+1,x
.2423	95 60		sta $60,x			sta 	NSMantissa3,x
.2425	60		rts				rts
.2426					FloatSubTopTwoStack:
.2426	38		sec				sec
.2427	b5 3c		lda $3c,x			lda		NSMantissa0,x
.2429	f5 3d		sbc $3d,x			sbc 		NSMantissa0+1,x
.242b	95 3c		sta $3c,x			sta 	NSMantissa0,x
.242d	b5 48		lda $48,x			lda		NSMantissa1,x
.242f	f5 49		sbc $49,x			sbc 		NSMantissa1+1,x
.2431	95 48		sta $48,x			sta 	NSMantissa1,x
.2433	b5 54		lda $54,x			lda		NSMantissa2,x
.2435	f5 55		sbc $55,x			sbc 		NSMantissa2+1,x
.2437	95 54		sta $54,x			sta 	NSMantissa2,x
.2439	b5 60		lda $60,x			lda		NSMantissa3,x
.243b	f5 61		sbc $61,x			sbc 		NSMantissa3+1,x
.243d	95 60		sta $60,x			sta 	NSMantissa3,x
.243f	60		rts				rts
.2440					FloatInt32Add:
.2440	b5 30		lda $30,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2442	55 31		eor $31,x			eor 	NSStatus+1,x
.2444	30 04		bmi $244a			bmi 	_DiffSigns
.2446	20 0c 24	jsr $240c			jsr		FloatAddTopTwoStack
.2449	60		rts				rts
.244a					_DiffSigns:
.244a	20 26 24	jsr $2426			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.244d	34 60		bit $60,x			bit 	NSMantissa3,x 				; result is +ve, okay
.244f	10 07		bpl $2458			bpl 	_AddExit
.2451	b5 31		lda $31,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2453	95 30		sta $30,x			sta 	NSStatus,x
.2455	20 49 26	jsr $2649			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2458					_AddExit:
.2458	20 a2 26	jsr $26a2			jsr 	FloatIsZero 				; check for -0
.245b	d0 02		bne $245f			bne 	_AddNonZero
.245d	74 30		stz $30,x			stz 	NSStatus,x
.245f					_AddNonZero:
.245f	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2460					FloatEncodeStart:
.2460	38		sec				sec
.2461	80 01		bra $2464			bra 	FloatEncodeContinue+1
.2463					FloatEncodeContinue:
.2463	18		clc				clc
.2464					FloatEncode:
.2464	08		php				php 								; save reset flag.
.2465	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2467	f0 15		beq $247e			beq 	_ENIsOkay
.2469	c9 30		cmp #$30			cmp 	#"0"
.246b	90 04		bcc $2471			bcc 	_ENBadNumber
.246d	c9 3a		cmp #$3a			cmp 	#"9"+1
.246f	90 0d		bcc $247e			bcc 	_ENIsOkay
.2471					_ENBadNumber:
.2471	28		plp				plp 								; throw saved reset
.2472	ad 37 05	lda $0537			lda 	encodeState 				; if in decimal mode, construct final number
.2475	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2477	d0 03		bne $247c			bne 	_ENFail
.2479	4c f6 24	jmp $24f6			jmp 	_ENConstructFinal
.247c					_ENFail:
.247c	18		clc				clc 								; not allowed
.247d	60		rts				rts
.247e					_ENIsOkay:
.247e	28		plp				plp 								; are we restarting
.247f	90 15		bcc $2496			bcc 	_ENNoRestart
.2481					_ENStartEncode:
.2481	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2483	f0 0c		beq $2491			beq 	_ENFirstDP
.2485	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2487	20 82 26	jsr $2682			jsr 	FloatSetByte 				; in single byte mode.
.248a	a9 01		lda #$01			lda 	#ESTA_Low
.248c					_ENExitChange:
.248c	8d 37 05	sta $0537			sta 	encodeState 				; save new state
.248f	38		sec				sec
.2490	60		rts				rts
.2491					_ENFirstDP:
.2491	20 80 26	jsr $2680			jsr 	FloatSetZero 				; clear integer part
.2494	80 3c		bra $24d2			bra 	_ESTASwitchFloat			; go straight to float and exi
.2496					_ENNoRestart:
.2496	48		pha				pha 								; save digit or DP on stack.
.2497	ad 37 05	lda $0537			lda 	encodeState 				; get current state
.249a	c9 01		cmp #$01			cmp 	#ESTA_Low
.249c	f0 09		beq $24a7			beq  	_ESTALowState
.249e	c9 02		cmp #$02			cmp 	#ESTA_High
.24a0	f0 26		beq $24c8			beq 	_ESTAHighState
.24a2	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.24a4	f0 38		beq $24de			beq 	_ESTADecimalState
>24a6	db						.byte 	$DB 						; causes a break in the emulator
.24a7					_ESTALowState:
.24a7	68		pla				pla 								; get value back
.24a8	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.24aa	f0 26		beq $24d2			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24ac	29 0f		and #$0f			and 	#15 						; make digit
.24ae	8d 38 05	sta $0538			sta 	digitTemp 					; save it.
.24b1	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24b3	0a		asl a				asl 	a
.24b4	0a		asl a				asl 	a
.24b5	75 3c		adc $3c,x			adc 	NSMantissa0,x
.24b7	0a		asl a				asl 	a
.24b8	6d 38 05	adc $0538			adc 	digitTemp
.24bb	95 3c		sta $3c,x			sta 	NSMantissa0,x
.24bd	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24bf	90 05		bcc $24c6			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24c1	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24c3	8d 37 05	sta $0537			sta 	encodeState
.24c6					_ESTANoSwitch:
.24c6	38		sec				sec
.24c7	60		rts				rts
.24c8					_ESTAHighState:
.24c8	68		pla				pla 								; get value back
.24c9	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24cb	f0 05		beq $24d2			beq 	_ESTASwitchFloat
.24cd	20 28 25	jsr $2528			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24d0	38		sec				sec
.24d1	60		rts				rts
.24d2					_ESTASwitchFloat:
.24d2	9c 39 05	stz $0539			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24d5	e8		inx				inx 								; zero the decimal additive.
.24d6	20 80 26	jsr $2680			jsr 	FloatSetZero
.24d9	ca		dex				dex
.24da	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24dc	80 ae		bra $248c			bra 	_ENExitChange
.24de					_ESTADecimalState:
.24de	68		pla				pla 								; digit.
.24df	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24e1	f0 99		beq $247c			beq 	_ENFail
.24e3	e8		inx				inx 								; put digit into fractional part of X+1
.24e4	20 28 25	jsr $2528			jsr 	ESTAShiftDigitIntoMantissa
.24e7	ca		dex				dex
.24e8	ee 39 05	inc $0539			inc 	decimalCount 				; bump the count of decimals
.24eb	ad 39 05	lda $0539			lda 	decimalCount 				; too many decimal digits.
.24ee	c9 0b		cmp #$0b			cmp 	#11
.24f0	f0 02		beq $24f4			beq 	_ESTADSFail
.24f2	38		sec				sec
.24f3	60		rts				rts
.24f4					_ESTADSFail:
.24f4	18		clc				clc
.24f5	60		rts				rts
.24f6					_ENConstructFinal:
.24f6	ad 39 05	lda $0539			lda 	decimalCount 				; get decimal count
.24f9	f0 2b		beq $2526			beq 	_ENCFExit 					; no decimals
.24fb	5a		phy				phy
.24fc	0a		asl a				asl 	a 							; x 4 and CLC
.24fd	0a		asl a				asl 	a
.24fe	6d 39 05	adc $0539			adc 	decimalCount
.2501	a8		tay				tay
.2502	b9 8d 21	lda $218d,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.2505	95 3e		sta $3e,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.2507	b9 8e 21	lda $218e,y			lda 	FloatScalarTable-5+1,y
.250a	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.250c	b9 8f 21	lda $218f,y			lda 	FloatScalarTable-5+2,y
.250f	95 56		sta $56,x			sta 	NSMantissa2+2,x
.2511	b9 90 21	lda $2190,y			lda 	FloatScalarTable-5+3,y
.2514	95 62		sta $62,x			sta 	NSMantissa3+2,x
.2516	b9 91 21	lda $2191,y			lda 	FloatScalarTable-5+4,y
.2519	95 6e		sta $6e,x			sta 	NSExponent+2,x
.251b	74 32		stz $32,x			stz 	NSStatus+2,x 				; make +ve
.251d	e8		inx				inx 								; multiply decimal const by decimal scalar
.251e	e8		inx				inx
.251f	20 40 23	jsr $2340			jsr 	FloatMultiply
.2522	20 a4 20	jsr $20a4			jsr 	FloatAdd 					; add to integer part.
.2525	7a		ply				ply
.2526					_ENCFExit:
.2526	18		clc				clc 								; reject the digit.
.2527	60		rts				rts
.2528					ESTAShiftDigitIntoMantissa:
.2528	29 0f		and #$0f			and 	#15 						; save digit
.252a	48		pha				pha
.252b	b5 60		lda $60,x			lda 	NSMantissa3,x 				; push mantissa on stack
.252d	48		pha				pha
.252e	b5 54		lda $54,x			lda 	NSMantissa2,x
.2530	48		pha				pha
.2531	b5 48		lda $48,x			lda 	NSMantissa1,x
.2533	48		pha				pha
.2534	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2536	48		pha				pha
.2537	20 8f 26	jsr $268f			jsr 	FloatShiftLeft 				; x 2
.253a	20 8f 26	jsr $268f			jsr 	FloatShiftLeft 				; x 4
.253d	18		clc				clc 								; pop mantissa and add
.253e	68		pla				pla
.253f	75 3c		adc $3c,x			adc 	NSMantissa0,x
.2541	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2543	68		pla				pla
.2544	75 48		adc $48,x			adc 	NSMantissa1,x
.2546	95 48		sta $48,x			sta 	NSMantissa1,x
.2548	68		pla				pla
.2549	75 54		adc $54,x			adc 	NSMantissa2,x
.254b	95 54		sta $54,x			sta 	NSMantissa2,x
.254d	68		pla				pla
.254e	75 60		adc $60,x			adc 	NSMantissa3,x
.2550	95 60		sta $60,x			sta 	NSMantissa3,x 				; x 5
.2552	20 8f 26	jsr $268f			jsr 	FloatShiftLeft 				; x 10
.2555	68		pla				pla 								; add digit
.2556	18		clc				clc
.2557	75 3c		adc $3c,x			adc 	NSMantissa0,x
.2559	95 3c		sta $3c,x			sta 	NSMantissa0,x
.255b	90 0a		bcc $2567			bcc 	_ESTASDExit
.255d	f6 48		inc $48,x			inc 	NSMantissa1,x
.255f	d0 06		bne $2567			bne 	_ESTASDExit
.2561	f6 54		inc $54,x			inc 	NSMantissa2,x
.2563	d0 02		bne $2567			bne 	_ESTASDExit
.2565	f6 60		inc $60,x			inc 	NSMantissa3,x
.2567					_ESTASDExit:
.2567	60		rts				rts
.0537					encodeState:
>0537							.fill 	1
.0538					digitTemp:
>0538							.fill 	1
.0539					decimalCount:
>0539							.fill 	1
.2568					FloatToString:
.2568	da		phx				phx
.2569	5a		phy				phy 								; save code position
.256a	8d 3a 05	sta $053a			sta 	decimalPlaces	 			; save number of DPs.
.256d	9c 3b 05	stz $053b			stz 	dbOffset 					; offset into decimal buffer = start.
.2570	b5 30		lda $30,x			lda 	NSStatus,x  				; is it -ve.
.2572	10 08		bpl $257c			bpl 	_CNTSNotNegative
.2574	29 7f		and #$7f			and 	#$7F 						; make +ve
.2576	95 30		sta $30,x			sta 	NSStatus,x
.2578	a9 2d		lda #$2d			lda 	#"-"
.257a	80 02		bra $257e			bra 	_CNTMain
.257c					_CNTSNotNegative:
.257c	a9 20		lda #$20			lda 	#" "
.257e					_CNTMain:
.257e	20 e0 25	jsr $25e0			jsr 	WriteDecimalBuffer
.2581	b5 6c		lda $6c,x			lda 	NSExponent,x 				; check if decimal
.2583	f0 0d		beq $2592			beq 	_CNTSNotFloat
.2585	e8		inx				inx 								; round up so we don't get too many 6.999999
.2586	a9 01		lda #$01			lda 	#1
.2588	20 82 26	jsr $2682			jsr 	FloatSetByte
.258b	b5 6b		lda $6b,x			lda		NSExponent-1,x
.258d	95 6c		sta $6c,x			sta 	NSExponent,x
.258f	20 a4 20	jsr $20a4			jsr 	FloatAdd
.2592					_CNTSNotFloat:
.2592	20 c2 25	jsr $25c2			jsr 	MakePlusTwoString 			; do the integer part.
.2595	20 60 22	jsr $2260			jsr 	FloatFractionalPart 		; get the fractional part
.2598	20 d5 23	jsr $23d5			jsr 	FloatNormalise					; normalise , exit if zero
.259b	f0 22		beq $25bf			beq 	_CNTSExit
.259d	a9 2e		lda #$2e			lda 	#"."
.259f	20 e0 25	jsr $25e0			jsr 	WriteDecimalBuffer 			; write decimal place
.25a2					_CNTSDecimal:
.25a2	ce 3a 05	dec $053a			dec 	decimalPlaces 				; done all the decimals
.25a5	30 18		bmi $25bf			bmi 	_CNTSExit
.25a7	e8		inx				inx 								; x 10.0
.25a8	a9 0a		lda #$0a			lda 	#10
.25aa	20 82 26	jsr $2682			jsr 	FloatSetByte
.25ad	20 40 23	jsr $2340			jsr 	FloatMultiply
.25b0	20 c2 25	jsr $25c2			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25b3	20 60 22	jsr $2260			jsr 	FloatFractionalPart 		; get the fractional part
.25b6	20 d5 23	jsr $23d5			jsr 	FloatNormalise 				; normalise it.
.25b9	b5 6c		lda $6c,x			lda 	NSExponent,x 				; gone to zero, exit.
.25bb	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25bd	b0 e3		bcs $25a2			bcs 	_CNTSDecimal 				; keep going.
.25bf					_CNTSExit:
.25bf	7a		ply				ply
.25c0	fa		plx				plx
.25c1	60		rts				rts
.25c2					MakePlusTwoString:
.25c2	da		phx				phx
.25c3	20 63 26	jsr $2663			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25c6	e8		inx				inx 								; access it
.25c7	e8		inx				inx
.25c8	20 bb 22	jsr $22bb			jsr 	FloatIntegerPart 			; make it an integer
.25cb	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25cd	20 ff 25	jsr $25ff			jsr 	ConvertInt32
.25d0	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25d2					_MPTSCopy:
.25d2	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25d5	20 e0 25	jsr $25e0			jsr 	WriteDecimalBuffer
.25d8	e8		inx				inx
.25d9	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25dc	d0 f4		bne $25d2			bne 	_MPTSCopy
.25de	fa		plx				plx
.25df	60		rts				rts
.25e0					WriteDecimalBuffer:
.25e0	da		phx				phx
.25e1	ae 3b 05	ldx $053b			ldx 	dbOffset
.25e4	9d 3c 05	sta $053c,x			sta 	decimalBuffer,x
.25e7	9e 3d 05	stz $053d,x			stz 	decimalBuffer+1,x
.25ea	ee 3b 05	inc $053b			inc 	dbOffset
.25ed	fa		plx				plx
.25ee	60		rts				rts
.053a					decimalPlaces:
>053a							.fill 	1
.053b					dbOffset:
>053b							.fill 	1
.053c					decimalBuffer:
>053c							.fill 	32
.25ef					ConvertInt16:
.25ef	85 3c		sta $3c				sta 	NSMantissa0 				; set up as 32 bit conversion
.25f1	86 48		stx $48				stx 	NSMantissa1
.25f3	64 54		stz $54				stz 	NSMantissa2
.25f5	64 60		stz $60				stz 	NSMantissa3
.25f7	64 30		stz $30				stz 	NSStatus 					; positive integer
.25f9	a2 00		ldx #$00			ldx 	#0 							; stack level
.25fb	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25fd	80 00		bra $25ff			bra 	ConvertInt32
.25ff					ConvertInt32:
.25ff	5a		phy				phy
.2600	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.2602	24 30		bit $30				bit 	NSStatus 					; output a - if not negative.
.2604	10 08		bpl $260e			bpl 	_CI32NotNeg
.2606	48		pha				pha
.2607	a9 2d		lda #$2d			lda 	#'-'
.2609	99 15 05	sta $0515,y			sta 	numberBuffer,y
.260c	c8		iny				iny
.260d	68		pla				pla
.260e					_CI32NotNeg:
.260e	20 1c 26	jsr $261c			jsr 	_CI32DivideConvert 			; recursive conversion
.2611	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2613	99 15 05	sta $0515,y			sta 	numberBuffer,y
.2616	7a		ply				ply
.2617	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.2619	a9 15		lda #$15			lda 	#numberBuffer & $FF
.261b	60		rts				rts
.261c					_CI32DivideConvert:
.261c	e8		inx				inx 								; write to next slot up
.261d	20 82 26	jsr $2682			jsr 	FloatSetByte 		 		; write the base out.
.2620	ca		dex				dex
.2621	20 16 22	jsr $2216			jsr 	Int32Divide 				; divide
.2624	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; save remainder
.2626	48		pha				pha
.2627	20 05 22	jsr $2205			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.262a	20 a2 26	jsr $26a2			jsr 	FloatIsZero 				; is it zero ?
.262d	f0 05		beq $2634			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.262f	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2631	20 1c 26	jsr $261c			jsr 	_CI32DivideConvert 			; and recusrively call.
.2634					_CI32NoRecurse:
.2634	68		pla				pla 								; remainder
.2635	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2637	90 02		bcc $263b			bcc 	_CI32NotHex
.2639	69 26		adc #$26			adc 	#6+32
.263b					_CI32NotHex:
.263b	69 30		adc #$30			adc 	#48
.263d	99 15 05	sta $0515,y			sta 	numberBuffer,y 				; write out and exit
.2640	c8		iny				iny
.2641	60		rts				rts
.2642					FloatNegate:
.2642	b5 30		lda $30,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2644	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2646	95 30		sta $30,x			sta 	NSStatus,x
.2648	60		rts				rts
.2649					FloatNegateMantissa:
.2649	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.264a	a9 00		lda #$00			lda 	#0
.264c	f5 3c		sbc $3c,x			sbc 	NSMantissa0,x
.264e	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2650	a9 00		lda #$00			lda 	#0
.2652	f5 48		sbc $48,x			sbc 	NSMantissa1,x
.2654	95 48		sta $48,x			sta 	NSMantissa1,x
.2656	a9 00		lda #$00			lda 	#0
.2658	f5 54		sbc $54,x			sbc 	NSMantissa2,x
.265a	95 54		sta $54,x			sta 	NSMantissa2,x
.265c	a9 00		lda #$00			lda 	#0
.265e	f5 60		sbc $60,x			sbc 	NSMantissa3,x
.2660	95 60		sta $60,x			sta 	NSMantissa3,x
.2662	60		rts				rts
.2663					FloatShiftUpTwo:
.2663	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2665	95 3e		sta $3e,x			sta 	NSMantissa0+2,x
.2667	b5 48		lda $48,x			lda 	NSMantissa1,x
.2669	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.266b	b5 54		lda $54,x			lda 	NSMantissa2,x
.266d	95 56		sta $56,x			sta 	NSMantissa2+2,x
.266f	b5 60		lda $60,x			lda 	NSMantissa3,x
.2671	95 62		sta $62,x			sta 	NSMantissa3+2,x
.2673	b5 6c		lda $6c,x			lda 	NSExponent,x
.2675	95 6e		sta $6e,x			sta 	NSExponent+2,x
.2677	b5 30		lda $30,x			lda 	NSStatus,x
.2679	95 32		sta $32,x			sta 	NSStatus+2,x
.267b	60		rts				rts
.267c					FloatSetZeroMantissaOnly:
.267c	74 3c		stz $3c,x			stz 	NSMantissa0,x
.267e	80 08		bra $2688			bra 	FloatZero13
.2680					FloatSetZero:
.2680	a9 00		lda #$00			lda 	#0
.2682					FloatSetByte:
.2682	74 6c		stz $6c,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2684					FloatSetMantissa:
.2684	95 3c		sta $3c,x			sta 	NSMantissa0,x 				; zero mantissa
.2686	74 30		stz $30,x			stz 	NSStatus,x
.2688					FloatZero13:
.2688	74 48		stz $48,x			stz 	NSMantissa1,x
.268a	74 54		stz $54,x			stz 	NSMantissa2,x
.268c	74 60		stz $60,x			stz 	NSMantissa3,x
.268e	60		rts				rts
.268f					FloatShiftLeft:
.268f	18		clc				clc
.2690					FloatRotateLeft:
.2690	36 3c		rol $3c,x			rol 	NSMantissa0,x
.2692	36 48		rol $48,x			rol		NSMantissa1,x
.2694	36 54		rol $54,x			rol		NSMantissa2,x
.2696	36 60		rol $60,x			rol		NSMantissa3,x
.2698	60		rts				rts
.2699					FloatShiftRight:
.2699	56 60		lsr $60,x			lsr 	NSMantissa3,x
.269b	76 54		ror $54,x			ror		NSMantissa2,x
.269d	76 48		ror $48,x			ror		NSMantissa1,x
.269f	76 3c		ror $3c,x			ror		NSMantissa0,x
.26a1	60		rts				rts
.26a2					FloatIsZero:
.26a2	b5 60		lda $60,x			lda 	NSMantissa3,x
.26a4	15 54		ora $54,x			ora		NSMantissa2,x
.26a6	15 48		ora $48,x			ora		NSMantissa1,x
.26a8	15 3c		ora $3c,x			ora		NSMantissa0,x
.26aa	60		rts				rts

;******  Processing input file: testing/testend.asm

.26ab					EndProgram:
>26ab	01 08 0c 08 0a 00 4e 20				.binary "code/tokenised.dat"
>26b3	b2 20 31 34 00 15 08 14 00 ce 86 20 33 00 32 08
>26c3	3c 00 99 20 c7 28 31 34 37 29 3b 22 48 45 4c 4c
>26d3	4f 20 57 4f 52 4c 44 20 21 22 00 4e 08 46 00 86
>26e3	20 42 58 28 4e 29 3a 86 20 42 59 28 4e 29 3a 86
>26f3	20 42 43 28 4e 29 00 62 08 4b 00 86 20 44 58 28
>2703	4e 29 3a 86 20 44 59 28 4e 29 00 70 08 50 00 81
>2713	20 42 b2 30 20 a4 20 4e 00 89 08 5a 00 42 58 28
>2723	42 29 b2 b5 28 bb 28 31 29 ac 34 30 29 ac 32 aa
>2733	31 00 a2 08 64 00 42 59 28 42 29 b2 b5 28 bb 28
>2743	31 29 ac 33 30 29 ac 32 35 36 00 b9 08 69 00 42
>2753	43 28 42 29 b2 b5 28 bb 28 31 29 ac 31 34 29 aa
>2763	31 00 cd 08 6a 00 44 58 28 42 29 b2 b5 28 bb 28
>2773	31 29 ac 32 29 00 e3 08 6c 00 8f 20 44 59 28 42
>2783	29 b2 b5 28 bb 28 31 29 ac 32 29 00 ef 08 6d 00
>2793	44 59 28 42 29 b2 31 00 f7 08 6e 00 82 20 42 00
>27a3	fd 08 78 00 8f 00 11 09 82 00 81 59 b2 30 a4 32
>27b3	39 3a 81 58 b2 30 a4 33 39 00 27 09 8c 00 51 b2
>27c3	59 ac 32 35 36 aa 58 ac 32 aa 34 35 30 35 36 00
>27d3	3f 09 96 00 ce 84 20 31 2c 51 2c 38 31 3a ce 84
>27e3	31 2c 51 aa 31 2c 30 00 48 09 a0 00 82 58 2c 59
>27f3	00 54 09 c8 00 81 20 42 b2 31 a4 4e 00 71 09 d2
>2803	00 ce 84 20 31 2c 34 35 30 35 36 aa 42 59 28 42
>2813	29 aa 42 58 28 42 29 2c 30 00 7f 09 e6 00 44 58
>2823	42 b2 44 58 28 42 29 00 90 09 f0 00 8b 44 58 42
>2833	b2 30 a7 8d 31 30 31 30 00 a1 09 fa 00 8b 44 58
>2843	42 b2 31 a7 8d 31 30 34 30 00 af 09 ff 00 44 59
>2853	42 b2 44 59 28 42 29 00 c0 09 04 01 8b 44 59 42
>2863	b2 30 a7 8d 31 30 37 30 00 d1 09 0e 01 8b 44 59
>2873	42 b2 31 a7 8d 31 31 30 30 00 f2 09 18 01 ce 84
>2883	20 31 2c 34 35 30 35 36 aa 42 59 28 42 29 aa 42
>2893	58 28 42 29 2c 42 43 28 42 29 00 f9 09 22 01 82
>28a3	42 00 03 0a 2c 01 89 20 32 30 30 00 09 0a e8 03
>28b3	8f 00 17 0a f2 03 42 58 42 b2 42 58 28 42 29 00
>28c3	2c 0a f3 03 8b 42 58 42 b2 31 a7 44 58 28 42 29
>28d3	b2 31 3a 8e 00 3e 0a fc 03 42 58 28 42 29 b2 42
>28e3	58 42 ab 32 3a 8e 00 44 0a 06 04 8f 00 52 0a 10
>28f3	04 42 58 42 b2 42 58 28 42 29 00 72 0a 11 04 8b
>2903	42 58 42 b2 37 39 a7 20 42 58 28 42 29 b2 37 37
>2913	3a 44 58 28 42 29 b2 30 3a 8e 00 84 0a 1a 04 42
>2923	58 28 42 29 b2 42 58 42 aa 32 3a 8e 00 8a 0a 24
>2933	04 8f 00 98 0a 2e 04 42 59 42 b2 42 59 28 42 29
>2943	00 ad 0a 2f 04 8b 42 59 42 b2 30 a7 44 59 28 42
>2953	29 b2 31 3a 8e 00 c1 0a 38 04 42 59 28 42 29 b2
>2963	42 59 42 ab 32 35 36 3a 8e 00 c7 0a 42 04 8f 00
>2973	d5 0a 4c 04 42 59 42 b2 42 59 28 42 29 00 f8 0a
>2983	4d 04 8b 42 59 42 b2 37 34 32 34 a7 42 59 28 42
>2993	29 b2 37 31 36 38 3a 44 59 28 42 29 b2 30 3a 8e
>29a3	00 0c 0b 56 04 42 59 28 42 29 b2 42 59 42 aa 32
>29b3	35 36 3a 8e 00 00 00

;******  End of listing
