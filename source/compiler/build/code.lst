
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Sat Oct  7 15:45:41 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.1000					WrapperBoot:
.1000	a2 0a		ldx #$0a			ldx 	#APIDesc & $FF
.1002	a0 10		ldy #$10			ldy 	#APIDesc >> 8
.1004	20 5d 11	jsr $115d			jsr 	StartCompiler
.1007	4c ff ff	jmp $ffff			jmp 	$FFFF
.100a					APIDesc:
>100a	0e 10						.word 	TestAPI 					; the testing API.
>100c	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>100d	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing file: testing/api/api.asm

=$a000					PCodeMemory = $A000
.100e					TestAPI:
.100e	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.1010	f0 0d		beq $101f			beq 	_TAOpenIn
.1012	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.1014	f0 11		beq $1027			beq 	_TACloseIn
.1016	c9 02		cmp #$02			cmp 	#BLC_READIN
.1018	f0 0e		beq $1028			beq 	_TARead
.101a	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.101c	f0 0d		beq $102b			beq 	_TAResetOut
>101e	db						.byte 	$DB 						; causes a break in the emulator
.101f					_TAOpenIn:
.101f	a9 a2		lda #$a2			lda 	#((EndProgram+2) & $FF)
.1021	85 22		sta $22				sta 	0+srcInputPtr
.1023	a9 26		lda #$26			lda 	#((EndProgram+2) >> 8) & $FF
.1025	85 23		sta $23				sta 	1+srcInputPtr
.1027					_TACloseIn:
.1027	60		rts				rts
.1028					_TARead:
.1028	4c 3e 10	jmp $103e			jmp 	ReadNextLine
.102b					_TAResetOut:
.102b	a9 00		lda #$00			lda 	#((PCodeMemory) & $FF)
.102d	85 28		sta $28				sta 	0+objPtr
.102f	a9 a0		lda #$a0			lda 	#((PCodeMemory) >> 8) & $FF
.1031	85 29		sta $29				sta 	1+objPtr
.1033	60		rts				rts
.0022					srcInputPtr:
>0022							.fill 	2

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/close.asm

.1034					APIOClose:
.1034	a9 a0		lda #$a0			lda 	#PCodeMemory >> 8
.1036	a6 28		ldx $28				ldx 	objPtr
.1038	a4 29		ldy $29				ldy 	objPtr+1
.103a	20 70 10	jsr $1070			jsr 	APISaveMemory
.103d	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/fromram.asm


;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/line.asm

.103e					ReadNextLine:
.103e	b2 22		lda ($22)			lda 	(srcInputPtr) 				; reached the end of the program (address link = $0000)
.1040	a0 01		ldy #$01			ldy 	#1
.1042	11 22		ora ($22),y			ora 	(srcInputPtr),y
.1044	d0 02		bne $1048			bne 	_RLAHaveData
.1046	18		clc				clc
.1047	60		rts				rts									; end of file.
.1048					_RLAHaveData:
.1048	a6 22		ldx $22				ldx 	srcInputPtr 				; remember the line start
.104a	a4 23		ldy $23				ldy 	srcInputPtr+1
.104c	5a		phy				phy
.104d	a0 04		ldy #$04			ldy 	#4 							; must be at least four bytes (address/line#)
.104f					_RNLRead:
.104f	b1 22		lda ($22),y			lda 	(srcInputPtr),y 			; find the end of the line.
.1051	c8		iny				iny
.1052	c9 00		cmp #$00			cmp 	#0
.1054	d0 f9		bne $104f			bne 	_RNLRead
.1056	98		tya				tya 								; advance src input pointer to next.
.1057	18		clc				clc
.1058	65 22		adc $22				adc 	srcInputPtr
.105a	85 22		sta $22				sta 	srcInputPtr
.105c	90 02		bcc $1060			bcc 	_RNLNoCarry
.105e	e6 23		inc $23				inc 	srcInputPtr+1
.1060					_RNLNoCarry:
.1060	7a		ply				ply 								; address of line now in YX.
.1061	38		sec				sec
.1062	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/open.asm


;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/writebyte.asm

.1063					APIOWriteByte:
.1063	92 28		sta ($28)			sta 	(objPtr)
.1065	e6 28		inc $28				inc 	objPtr
.1067	d0 02		bne $106b			bne 	_HWOWBNoCarry
.1069	e6 29		inc $29				inc 	objPtr+1
.106b					_HWOWBNoCarry:
.106b	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_printchar.asm

.106c					APIOPrintCharacter
.106c	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.106f	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_save.asm

.1070					APISaveMemory:
.1070	da		phx				phx
.1071	5a		phy				phy
.1072	48		pha				pha
.1073	a9 00		lda #$00			lda 	#0 							; set LFS
.1075	a2 08		ldx #$08			ldx 	#8
.1077	a0 00		ldy #$00			ldy 	#0
.1079	20 ba ff	jsr $ffba			jsr 	$FFBA
.107c	a9 08		lda #$08			lda 	#8 							; set file name
.107e	a2 92		ldx #$92			ldx 	#SaveName & $FF
.1080	a0 10		ldy #$10			ldy 	#SaveName >> 8
.1082	20 bd ff	jsr $ffbd			jsr 	$FFBD
.1085	68		pla				pla 								; set up the start address.
.1086	85 2b		sta $2b				sta 	zTemp0+1
.1088	64 2a		stz $2a				stz 	zTemp0
.108a	a9 2a		lda #$2a			lda 	#zTemp0 					; from index.
.108c	7a		ply				ply 								; end in YX
.108d	fa		plx				plx
.108e	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.1091	60		rts				rts
.1092					SaveName:
>1092	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Return to file: testing/testing.asm


;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.0024					srcPtr:
>0024							.fill 	2
.0400					currentLineNumber:
>0400							.fill 	2
.109a					InlineNonDecimal:
.109a	a2 02		ldx #$02			ldx 	#2 							; get size in X
.109c	c9 25		cmp #$25			cmp 	#"%"
.109e	f0 02		beq $10a2			beq 	_INDBinary
.10a0	a2 10		ldx #$10			ldx 	#16
.10a2					_INDBinary:
.10a2	85 2c		sta $2c				sta 	zTemp1 						; size => zTemp1
.10a4	64 2d		stz $2d				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.10a6	64 2a		stz $2a				stz 	zTemp0 						; zero result
.10a8	64 2b		stz $2b				stz 	zTemp0+1
.10aa					_INDLoop:
.10aa	20 34 1a	jsr $1a34			jsr 	LookNext 					; check next character
.10ad	20 70 1a	jsr $1a70			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.10b0	90 1f		bcc $10d1			bcc		_INDDone 					; didn't convert
.10b2	c5 2c		cmp $2c				cmp 	zTemp1 						; size too large ?
.10b4	b0 1b		bcs $10d1			bcs 	_INDDone
.10b6	20 e0 10	jsr $10e0			jsr 	_INDShift 					; x 2 or x 16
.10b9	e0 02		cpx #$02			cpx 	#2
.10bb	f0 09		beq $10c6			beq 	_INDNotHex
.10bd	20 e0 10	jsr $10e0			jsr 	_INDShift
.10c0	20 e0 10	jsr $10e0			jsr 	_INDShift
.10c3	20 e0 10	jsr $10e0			jsr 	_INDShift
.10c6					_INDNotHex:
.10c6	05 2a		ora $2a				ora 	zTemp0 						; or digit into result
.10c8	85 2a		sta $2a				sta 	zTemp0
.10ca	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume
.10cd	e6 2d		inc $2d				inc 	zTemp1+1 					; bump count
.10cf	80 d9		bra $10aa			bra 	_INDLoop
.10d1					_INDDone:
.10d1	a5 2d		lda $2d				lda 	zTemp1+1 					; done at least 1 ?
.10d3	f0 08		beq $10dd			beq 	_INDError
.10d5	a4 2b		ldy $2b				ldy 	zTemp0+1 					; push constant
.10d7	a5 2a		lda $2a				lda 	zTemp0
.10d9	20 f2 11	jsr $11f2			jsr 	PushIntegerYA
.10dc	60		rts				rts
.10dd					_INDError:
.10dd	4c 2f 1f	jmp $1f2f		jmp	ErrorV_syntax
.10e0					_INDShift:
.10e0	06 2a		asl $2a				asl 	zTemp0
.10e2	26 2b		rol $2b				rol 	zTemp0+1
.10e4	60		rts				rts
.10e5					GetLineNumber:
.10e5	ac 01 04	ldy $0401			ldy 	currentLineNumber+1
.10e8	ad 00 04	lda $0400			lda 	currentLineNumber
.10eb	60		rts				rts
.10ec					WriteCodeByte:
.10ec	48		pha				pha 								; save on stack
.10ed	da		phx				phx
.10ee	5a		phy				phy
.10ef	20 63 10	jsr $1063			jsr 	APIOWriteByte
.10f2	7a		ply				ply 								; restore from stack
.10f3	fa		plx				plx
.10f4	68		pla				pla
.10f5	60		rts				rts
.10f6					PrintCharacter
.10f6	48		pha				pha
.10f7	da		phx				phx
.10f8	5a		phy				phy
.10f9	20 6c 10	jsr $106c			jsr 	APIOPrintCharacter
.10fc	7a		ply				ply
.10fd	fa		plx				plx
.10fe	68		pla				pla
.10ff	60		rts				rts
.1100					ProcessNewLine:
.1100	86 2a		stx $2a				stx 	zTemp0 						; save address in zTemp0
.1102	84 2b		sty $2b				sty 	zTemp0+1
.1104	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.1105	8a		txa				txa
.1106	69 04		adc #$04			adc 	#4
.1108	85 24		sta $24				sta 	srcPtr
.110a	98		tya				tya
.110b	69 00		adc #$00			adc 	#0
.110d	85 25		sta $25				sta 	srcPtr+1
.110f	a0 02		ldy #$02			ldy 	#2							; read and save line number
.1111	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1113	8d 00 04	sta $0400			sta 	currentLineNumber
.1116	c8		iny				iny
.1117	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1119	8d 01 04	sta $0401			sta 	currentLineNumber+1
.111c	60		rts				rts
.111d					BufferClear:
.111d	9c 02 04	stz $0402			stz 	bufferSize
.1120	60		rts				rts
.1121					BufferWrite:
.1121	da		phx				phx
.1122	ae 02 04	ldx $0402			ldx 	bufferSize
.1125	9d 03 04	sta $0403,x			sta 	dataBuffer,x
.1128	ee 02 04	inc $0402			inc 	bufferSize
.112b	fa		plx				plx
.112c	60		rts				rts
.112d					BufferOutput:
.112d	ad 02 04	lda $0402			lda 	bufferSize
.1130	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1133	a2 00		ldx #$00			ldx 	#0
.1135					_BOLoop:
.1135	ec 02 04	cpx $0402			cpx 	bufferSize
.1138	f0 09		beq $1143			beq 	_BOExit
.113a	bd 03 04	lda $0403,x			lda 	dataBuffer,x
.113d	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1140	e8		inx				inx
.1141	80 f2		bra $1135			bra 	_BOLoop
.1143					_BOExit:
.1143	60		rts				rts
.0402					bufferSize:
>0402							.fill 	1
.0403					dataBuffer:
>0403							.fill 	256
.1144					CheckNextComma:
.1144	a9 2c		lda #$2c			lda	 	#","
.1146	80 06		bra $114e			bra 	CheckNextA
.1148					CheckNextRParen:
.1148	a9 29		lda #$29			lda	 	#")"
.114a	80 02		bra $114e			bra 	CheckNextA
.114c					CheckNextLParen:
.114c	a9 28		lda #$28			lda 	#"("
.114e					CheckNextA:
.114e	8d 03 05	sta $0503			sta 	checkCharacter 				; save test character
.1151					_CNALoop:
.1151	20 50 1a	jsr $1a50			jsr 	GetNextNonSpace 			; get next skipping spaces.
.1154	cd 03 05	cmp $0503			cmp 	checkCharacter 				; matches ?
.1157	f0 03		beq $115c			beq 	_CNAExit
.1159	4c 2f 1f	jmp $1f2f		jmp	ErrorV_syntax
.115c					_CNAExit:
.115c	60		rts				rts
.0503					checkCharacter:
>0503							.fill 	1
.115d					StartCompiler:
.115d	86 2a		stx $2a				stx 	zTemp0 						; access API
.115f	84 2b		sty $2b				sty 	zTemp0+1
.1161	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.1163	b2 2a		lda ($2a)			lda 	(zTemp0)
.1165	8d 05 05	sta $0505			sta 	APIVector
.1168	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.116a	8d 06 05	sta $0506			sta 	APIVector+1
.116d	c8		iny				iny 								; copy data area range.
.116e	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1170	8d 07 05	sta $0507			sta 	compilerStartHigh
.1173	c8		iny				iny
.1174	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1176	8d 08 05	sta $0508			sta 	compilerEndHigh
.1179	ba		tsx				tsx 								; save stack pointer
.117a	8e 04 05	stx $0504			stx 	compilerSP
.117d	20 d4 1d	jsr $1dd4			jsr 	STRReset 					; reset storage (line#, variable)
.1180	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.1182	20 ef 11	jsr $11ef			jsr 	CallAPIHandler
.1185	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.1187	20 ef 11	jsr $11ef			jsr 	CallAPIHandler
.118a	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.118c	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.118f	a9 00		lda #$00			lda 	#0
.1191	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1194	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1197					MainCompileLoop:
.1197	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.1199	20 ef 11	jsr $11ef			jsr 	CallAPIHandler
.119c	90 31		bcc $11cf			bcc 	SaveCodeAndExit 			; end of source.
.119e	20 00 11	jsr $1100			jsr 	ProcessNewLine 				; set up pointer and line number.
.11a1	20 e5 10	jsr $10e5			jsr 	GetLineNumber 				; get line #
.11a4	20 be 1b	jsr $1bbe			jsr 	STRMarkLine 				; remember the code position and number of this line.
.11a7	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.11a9	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.11ac					_MCLSameLine:
.11ac	20 50 1a	jsr $1a50			jsr 	GetNextNonSpace 			; get the first character.
.11af	f0 e6		beq $1197			beq 	MainCompileLoop 			; end of line, get next line.
.11b1	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.11b3	f0 f7		beq $11ac			beq 	_MCLSameLine
.11b5	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.11b7	10 0c		bpl $11c5			bpl 	_MCLCheckAssignment
.11b9	a2 11		ldx #$11			ldx 	#CommandTables & $FF 		; do command tables.
.11bb	a0 16		ldy #$16			ldy 	#CommandTables >> 8
.11bd	20 d9 18	jsr $18d9			jsr 	GeneratorProcess
.11c0	b0 ea		bcs $11ac			bcs 	_MCLSameLine 				; keep trying to compile the line.
.11c2					_MCLSyntax:
.11c2	4c 2f 1f	jmp $1f2f		jmp	ErrorV_syntax
.11c5					_MCLCheckAssignment:
.11c5	20 66 1a	jsr $1a66			jsr 	CharIsAlpha 				; if not alpha then syntax error
.11c8	90 f8		bcc $11c2			bcc 	_MCLSyntax
.11ca	20 8c 1b	jsr $1b8c			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.11cd	80 dd		bra $11ac			bra		_MCLSameLine 				; loop back.
.11cf					SaveCodeAndExit:
.11cf	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.11d1	20 ef 11	jsr $11ef			jsr 	CallAPIHandler
.11d4	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.11d6	a8		tay				tay
.11d7	20 be 1b	jsr $1bbe			jsr 	STRMarkLine
.11da	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.11dc	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.11df	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.11e1	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.11e4	20 09 15	jsr $1509			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.11e7	20 34 10	jsr $1034			jsr 	APIOClose
.11ea					ExitCompiler:
.11ea	ae 04 05	ldx $0504			ldx 	compilerSP 					; reload SP and exit.
.11ed	9a		txs				txs
.11ee	60		rts				rts
.11ef					CallAPIHandler:
.11ef	6c 05 05	jmp ($0505)			jmp 	(APIVector)
.0504					compilerSP:
>0504							.fill 	1
.0505					APIVector:
>0505							.fill 	2
.0507					compilerStartHigh:
>0507							.fill 	1
.0508					compilerEndHigh:
>0508							.fill 	1
.11f2					PushIntegerYA:
.11f2	c0 00		cpy #$00			cpy 	#0 							; 0-255
.11f4	f0 0f		beq $1205			beq 	PushIntegerA
.11f6	48		pha				pha
.11f7	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.11f9	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.11fc	68		pla				pla 								; then LSB
.11fd	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1200	98		tya				tya 								; then MSB
.1201	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1204	60		rts				rts
.1205					PushIntegerA:
.1205	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.1207	90 07		bcc $1210			bcc 	_PIWriteA
.1209	48		pha				pha
.120a	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.120c	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.120f	68		pla				pla
.1210					_PIWriteA:
.1210	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1213	60		rts				rts
.1214					PushFloat:
.1214	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.1216	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1219	b5 6c		lda $6c,x			lda 	NSExponent,x 				; and the data
.121b	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.121e	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1220	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1223	b5 48		lda $48,x			lda 	NSMantissa1,x
.1225	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1228	b5 54		lda $54,x			lda 	NSMantissa2,x
.122a	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.122d	b5 30		lda $30,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.122f	29 80		and #$80			and 	#$80
.1231	15 60		ora $60,x			ora 	NSMantissa3,x
.1233	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1236	60		rts				rts
.1237					CreateVariableRecord:
.1237	48		pha				pha
.1238	ad 13 05	lda $0513			lda 	freeVariableMemory 		; push current free address on stack.
.123b	48		pha				pha
.123c	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.123f	48		pha				pha
.1240	ad 11 05	lda $0511			lda 	variableListEnd  		; copy end of list to zTemp0
.1243	85 2a		sta $2a				sta 	zTemp0
.1245	ad 12 05	lda $0512			lda 	variableListEnd+1
.1248	85 2b		sta $2b				sta 	zTemp0+1
.124a	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.124c	92 2a		sta ($2a)			sta 	(zTemp0)
.124e	98		tya				tya
.124f	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.1251	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1253	88		dey				dey
.1254	8a		txa				txa
.1255	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1257	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.1259	ad 13 05	lda $0513			lda 	freeVariableMemory
.125c	91 2a		sta ($2a),y			sta 	(zTemp0),y
.125e	c8		iny				iny
.125f	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1262	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1264	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.1266	a9 00		lda #$00			lda 	#0
.1268	91 2a		sta ($2a),y			sta 	(zTemp0),y
.126a	18		clc				clc
.126b	b2 2a		lda ($2a)			lda 	(zTemp0) 				; add offset to variableListEnd
.126d	6d 11 05	adc $0511			adc  	variableListEnd
.1270	8d 11 05	sta $0511			sta 	variableListEnd
.1273	90 03		bcc $1278			bcc 	_CVNoCarry2
.1275	ee 12 05	inc $0512			inc 	variableListEnd+1
.1278					_CVNoCarry2:
.1278	7a		ply				ply
.1279	fa		plx				plx
.127a	68		pla				pla
.127b	60		rts				rts
.127c					SetVariableRecordToCodePosition:
.127c	48		pha				pha
.127d	5a		phy				phy
.127e	a0 03		ldy #$03			ldy 	#3
.1280	a5 29		lda $29				lda 	objPtr+1
.1282	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1284	c8		iny				iny
.1285	a5 28		lda $28				lda 	objPtr
.1287	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1289	7a		ply				ply
.128a	68		pla				pla
.128b	60		rts				rts
.128c					AllocateBytesForType:
.128c	48		pha				pha
.128d	da		phx				phx
.128e	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.1290	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1292	c9 00		cmp #$00			cmp 	#NSSIFloat
.1294	d0 02		bne $1298			bne 	_CVNotFloat
.1296	a2 06		ldx #$06			ldx 	#6
.1298					_CVNotFloat:
.1298	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.1299	18		clc				clc
.129a	6d 13 05	adc $0513			adc 	freeVariableMemory
.129d	8d 13 05	sta $0513			sta 	freeVariableMemory
.12a0	90 03		bcc $12a5			bcc 	_CVNoCarry1
.12a2	ee 14 05	inc $0514			inc 	freeVariableMemory+1
.12a5					_CVNoCarry1:
.12a5	fa		plx				plx
.12a6	68		pla				pla
.12a7	60		rts				rts
.12a8					CommandDATA:
.12a8	20 1d 11	jsr $111d			jsr 	BufferClear 				; copy it to the buffer
.12ab	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace
.12ae					_CTDataLoop:
.12ae	20 34 1a	jsr $1a34			jsr 	LookNext 					; reached EOL
.12b1	f0 08		beq $12bb			beq 	_CTDataDone
.12b3	20 21 11	jsr $1121			jsr 	BufferWrite 				; write and consume
.12b6	20 45 1a	jsr $1a45			jsr 	GetNext
.12b9	80 f3		bra $12ae			bra 	_CTDataLoop
.12bb					_CTDataDone:
.12bb	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.12bd	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.12c0	20 2d 11	jsr $112d			jsr 	BufferOutput
.12c3	60		rts				rts
.12c4					CommandDEF:
.12c4	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.12c6	20 05 12	jsr $1205			jsr 	PushIntegerA
.12c9	20 55 1b	jsr $1b55			jsr 	CompileGotoEOL 				; compile skip over DEF
.12cc	a9 a5		lda #$a5			lda 	#C64_FN
.12ce	20 4e 11	jsr $114e			jsr 	CheckNextA
.12d1	20 50 1a	jsr $1a50			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.12d4	20 b5 1a	jsr $1ab5			jsr 	ExtractVariableName
.12d7	8a		txa				txa
.12d8	10 51		bpl $132b			bpl 	_CDError
.12da	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.12db	29 7f		and #$7f			and 	#$7F
.12dd	aa		tax				tax
.12de	98		tya				tya
.12df	09 80		ora #$80			ora 	#$80
.12e1	a8		tay				tay
.12e2	20 ad 14	jsr $14ad			jsr 	FindVariable				; does it already exist ?
.12e5	b0 44		bcs $132b			bcs 	_CDError 					; if so, that's an error.
.12e7	20 37 12	jsr $1237			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.12ea	20 7c 12	jsr $127c			jsr 	SetVariableRecordToCodePosition
.12ed	20 50 1a	jsr $1a50			jsr 	GetNextNonSpace
.12f0	20 91 1d	jsr $1d91			jsr 	GetReferenceTerm 			; get var ref, not array
.12f3	c9 00		cmp #$00			cmp 	#0
.12f5	30 34		bmi $132b			bmi 	_CDError
.12f7	8d 09 05	sta $0509			sta 	defType 					; save type
.12fa	8e 0a 05	stx $050a			stx 	defVariable 				; save var ref
.12fd	8c 0b 05	sty $050b			sty 	defVariable+1
.1300	29 40		and #$40			and 	#NSSString 					; only numbers.
.1302	d0 27		bne $132b			bne 	_CDError
.1304	20 48 11	jsr $1148			jsr 	CheckNextRParen 			; check )
.1307	a9 b2		lda #$b2			lda 	#C64_EQUAL
.1309	20 4e 11	jsr $114e			jsr 	CheckNextA 					; check =
.130c	18		clc				clc 								; if this is DEF FNxx(A), read A
.130d	20 2e 13	jsr $132e			jsr 	CDReadWriteVariable
.1310	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1312	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1315	38		sec				sec
.1316	20 2e 13	jsr $132e			jsr 	CDReadWriteVariable 		; A is now updated
.1319	20 f3 13	jsr $13f3			jsr 	CompileExpressionAt0 		; the actual body of the function.
.131c	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.131e	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1321	38		sec				sec
.1322	20 2e 13	jsr $132e			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.1325	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.1327	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.132a	60		rts				rts
.132b					_CDError:
.132b	4c 2f 1f	jmp $1f2f		jmp	ErrorV_syntax
.132e					CDReadWriteVariable:
.132e	ac 0b 05	ldy $050b			ldy 	defVariable+1 				; set up YX
.1331	ae 0a 05	ldx $050a			ldx 	defVariable
.1334	ad 09 05	lda $0509			lda 	defType
.1337	20 43 1d	jsr $1d43			jsr 	GetSetVariable
.133a	60		rts				rts
.0509					defType:
>0509							.fill 	1
.050a					defVariable:
>050a							.fill 	2
.133b					CommandDIM:
.133b	20 50 1a	jsr $1a50			jsr 	GetNextNonSpace 			; get the first non space character
.133e	20 b5 1a	jsr $1ab5			jsr 	ExtractVariableName 		; variable name to XY
.1341	da		phx				phx 								; save name with type bits.
.1342	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.1344	10 37		bpl $137d			bpl 	_CDError
.1346	20 ad 14	jsr $14ad			jsr 	FindVariable	 			; see if already exist
.1349	b0 35		bcs $1380			bcs 	_CDRedefine 				; it still exists.
.134b	20 37 12	jsr $1237			jsr 	CreateVariableRecord 		; create the basic variable
.134e	20 8c 12	jsr $128c			jsr 	AllocateBytesForType 		; allocate memory for it
.1351	68		pla				pla 								; restore type bits
.1352	5a		phy				phy 								; save the address of the basic storage
.1353	da		phx				phx
.1354	48		pha				pha
.1355	20 83 13	jsr $1383			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.1358	68		pla				pla
.1359	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.135b	20 05 12	jsr $1205			jsr 	PushIntegerA 				; push that type data out.
.135e	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.1360	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1363	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.1365	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1368	fa		plx				plx 								; restore address
.1369	7a		ply				ply
.136a	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.136c	38		sec				sec
.136d	20 43 1d	jsr $1d43			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.1370	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; , follows ?
.1373	c9 2c		cmp #$2c			cmp 	#","
.1375	d0 05		bne $137c			bne 	_CDExit
.1377	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume comma
.137a	80 bf		bra $133b			bra 	CommandDIM 					; do another DIM
.137c					_CDExit:
.137c	60		rts				rts
.137d					_CDError:
.137d	4c 2f 1f	jmp $1f2f		jmp	ErrorV_syntax
.1380					_CDRedefine:
.1380	4c f7 1f	jmp $1ff7		jmp	ErrorV_redefine
.1383					OutputIndexGroup:
.1383	9c 0c 05	stz $050c			stz 	IndexCount 					; count of number of indices.
.1386					_OIGNext:
.1386	20 f3 13	jsr $13f3			jsr 	CompileExpressionAt0 		; get a dimension
.1389	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.138b	c9 00		cmp #$00			cmp 	#NSSIFloat
.138d	d0 19		bne $13a8			bne 	_OIGType
.138f	ee 0c 05	inc $050c			inc 	IndexCount 					; bump the counter.
.1392	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; does a , follow ?
.1395	c9 2c		cmp #$2c			cmp 	#","
.1397	d0 05		bne $139e			bne 	_OIGCheckEnd
.1399	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume comma
.139c	80 e8		bra $1386			bra 	_OIGNext 					; get next dimension
.139e					_OIGCheckEnd:
.139e	20 48 11	jsr $1148			jsr 	CheckNextRParen 			; check and consume )
.13a1	ad 0c 05	lda $050c			lda 	IndexCount
.13a4	20 05 12	jsr $1205			jsr 	PushIntegerA 				; compile the dimension count.
.13a7	60		rts				rts
.13a8					_OIGType:
.13a8	4c 3f 1f	jmp $1f3f		jmp	ErrorV_type
.050c					IndexCount:
>050c							.fill 	1
.13ab					ErrorHandler:
.13ab	68		pla				pla
.13ac	7a		ply				ply
.13ad	85 2a		sta $2a				sta 	zTemp0
.13af	84 2b		sty $2b				sty 	zTemp0+1
.13b1	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.13b3	a0 01		ldy #$01			ldy 	#1
.13b5					_EHDisplayMsg:
.13b5	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.13b7	20 f6 10	jsr $10f6			jsr 	PrintCharacter
.13ba	c8		iny				iny
.13bb	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.13bd	d0 f6		bne $13b5			bne 	_EHDisplayMsg
.13bf	a9 20		lda #$20			lda 	#32
.13c1	20 f6 10	jsr $10f6			jsr 	PrintCharacter
.13c4	a9 40		lda #$40			lda 	#64
.13c6	20 f6 10	jsr $10f6			jsr 	PrintCharacter
.13c9	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.13cb	20 77 26	jsr $2677			jsr 	FloatSetByte
.13ce	20 e5 10	jsr $10e5			jsr 	GetLineNumber
.13d1	95 3c		sta $3c,x			sta 	NSMantissa0,x
.13d3	98		tya				tya
.13d4	95 48		sta $48,x			sta 	NSMantissa1,x
.13d6	20 5d 25	jsr $255d			jsr 	FloatToString
.13d9	a0 00		ldy #$00			ldy 	#0 							; display that string.
.13db	a2 00		ldx #$00			ldx 	#0
.13dd					_EHDisplayLine:
.13dd	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13e0	20 f6 10	jsr $10f6			jsr 	PrintCharacter
.13e3	c8		iny				iny
.13e4	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13e7	d0 f4		bne $13dd			bne 	_EHDisplayLine
.13e9	a9 0d		lda #$0d			lda 	#13
.13eb	20 f6 10	jsr $10f6			jsr 	PrintCharacter
.13ee	80 fe		bra $13ee	_EHHalt:bra 	_EHHalt
.13f0	4c ea 11	jmp $11ea			jmp 	ExitCompiler
.13f3					CompileExpressionAt0:
.13f3	a9 00		lda #$00			lda 	#0
.13f5					CompileExpressionAtA:
.13f5	48		pha				pha  								; save level
.13f6	20 fc 1d	jsr $1dfc			jsr 	CompileTerm 				; compile a term.
.13f9	fa		plx				plx 								; get level back into X
.13fa					_ECALoop:
.13fa	48		pha				pha 								; save type on stack.
.13fb	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; get the next character
.13fe	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.1400	90 04		bcc $1406			bcc 	_ECAExit
.1402	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.1404	90 02		bcc $1408			bcc 	_ECAHaveToken
.1406					_ECAExit:
.1406	68		pla				pla 								; throw type off stack
.1407	60		rts				rts
.1408					_ECAHaveToken:
.1408	86 2a		stx $2a				stx 	zTemp0 						; save current precedence in zTemp0
.140a	aa		tax				tax 								; X contains the operator token
.140b	bd f6 13	lda $13f6,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.140e	c5 2a		cmp $2a				cmp 	zTemp0 						; if < then exit
.1410	90 f4		bcc $1406			bcc 	_ECAExit
.1412	85 2b		sta $2b				sta 	zTemp0+1 					; save the precedence of the operator.
.1414	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume the token.
.1417	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.1419	f0 11		beq $142c			beq 	_ECAGreaterCheck
.141b	e0 b3		cpx #$b3			cpx 	#C64_LESS
.141d	d0 1a		bne $1439			bne 	_ECAHaveFullToken
.141f	20 34 1a	jsr $1a34			jsr 	LookNext 					; checks for < (<= or <>)
.1422	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.1424	f0 0e		beq $1434			beq	 	_ECAToNotEqual
.1426	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.1428	d0 0f		bne $1439			bne 	_ECAHaveFullToken
.142a	80 07		bra $1433			bra 	_ECAAddEqual
.142c					_ECAGreaterCheck:
.142c	20 34 1a	jsr $1a34			jsr 	LookNext
.142f	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.1431	d0 06		bne $1439			bne 	_ECAHaveFullToken
.1433					_ECAAddEqual:
.1433	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.1434					_ECAToNotEqual:
.1434	e8		inx				inx
.1435	e8		inx				inx
.1436	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume the = or > in >= <= <>
.1439					_ECAHaveFullToken:
.1439	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.143b	d0 0a		bne $1447			bne 	_ECANotConcat
.143d	68		pla				pla 								; get type back
.143e	48		pha				pha
.143f	29 40		and #$40			and 	#NSSTypeMask
.1441	c9 40		cmp #$40			cmp 	#NSSString
.1443	d0 02		bne $1447			bne 	_ECANotConcat
.1445	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1447					_ECANotConcat:
.1447	da		phx				phx 								; save operator on the stack
.1448	a6 2a		ldx $2a				ldx 	zTemp0 						; push current precedence on the stack
.144a	da		phx				phx
.144b	a5 2b		lda $2b				lda 	zTemp0+1 					; get precedence of operator
.144d	1a		inc a				inc 	a
.144e	20 f5 13	jsr $13f5			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.1451	85 2a		sta $2a				sta 	zTemp0 						; save type in zTemp0
.1453	fa		plx				plx 								; restore current precedence in X
.1454	68		pla				pla 								; restore operator
.1455	85 2b		sta $2b				sta 	zTemp0+1 					; save it in zTemp0+1.
.1457	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.1459	90 17		bcc $1472			bcc 	_ECANotCompare
.145b	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.145d	b0 13		bcs $1472			bcs 	_ECANotCompare
.145f	7a		ply				ply 								; get type into Y
.1460	5a		phy				phy
.1461	48		pha				pha 								; save operator
.1462	98		tya				tya 								; get type
.1463	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.1465	29 40		and #$40			and 	#NSSTypeMask
.1467	c9 40		cmp #$40			cmp 	#NSSString
.1469	f0 02		beq $146d			beq 	_ECANotString
.146b	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.146d					_ECANotString:
.146d	98		tya				tya									; output token Y
.146e	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1471	68		pla				pla 								; restore operator.
.1472					_ECANotCompare:
.1472	18		clc				clc 								; convert to P-Code and compile.
.1473	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.1475	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1478	68		pla				pla 								; type of current result
.1479	45 2a		eor $2a				eor 	zTemp0 						; check compatible with r-expr type
.147b	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.147d	d0 19		bne $1498			bne		_ECAType
.147f	a5 2a		lda $2a				lda 	zTemp0 						; get type back
.1481	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.1483	d0 18		bne $149d			bne 	_ECAGoLoop
.1485	a5 2b		lda $2b				lda 	zTemp0+1 					; check operator is + or comparator
.1487	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1489	f0 10		beq $149b			beq 	_ECAOkayString 				; (this is post conversion)
.148b	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.148d	90 09		bcc $1498			bcc 	_ECAType
.148f	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.1491	b0 05		bcs $1498			bcs 	_ECAType
.1493	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.1495	4c fa 13	jmp $13fa			jmp 	_ECALoop
.1498					_ECAType:
.1498	4c 3f 1f	jmp $1f3f		jmp	ErrorV_type
.149b					_ECAOkayString:
.149b	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.149d					_ECAGoLoop:
.149d	4c fa 13	jmp $13fa			jmp 	_ECALoop
.14a0					PrecedenceTable:
>14a0	03						.byte 	3 					; '+'
>14a1	03						.byte 	3 					; '-'
>14a2	04						.byte 	4 					; '*'
>14a3	04						.byte 	4 					; '/'
>14a4	05						.byte 	5 					; '^'
>14a5	01						.byte 	1 					; 'and'
>14a6	00						.byte 	0 					; 'or'
>14a7	02						.byte 	2 					; '>'
>14a8	02						.byte 	2 					; '='
>14a9	02						.byte 	2 					; '<'
>14aa	02						.byte 	2 					; '>='
>14ab	02						.byte 	2 					; '<='
>14ac	02						.byte 	2 					; '<>'
.14ad					FindVariable:
.14ad	86 2c		stx $2c				stx 	zTemp1 						; save name.
.14af	84 2d		sty $2d				sty 	zTemp1+1
.14b1					_IVCheckSpecial:
.14b1	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.14b3	d0 18		bne $14cd			bne 	_IVStandard
.14b5	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.14b7	f0 0c		beq $14c5			beq 	_IVTIFloat
.14b9	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.14bb	d0 10		bne $14cd			bne 	_IVStandard
.14bd	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.14bf	a2 01		ldx #$01			ldx 	#$01
.14c1	a9 40		lda #$40			lda 	#NSSString
.14c3	38		sec				sec
.14c4	60		rts				rts
.14c5					_IVTIFloat:
.14c5	a0 80		ldy #$80			ldy 	#$80
.14c7	a2 00		ldx #$00			ldx 	#$00
.14c9	a9 00		lda #$00			lda 	#0
.14cb	38		sec				sec
.14cc	60		rts				rts
.14cd					_IVStandard:
.14cd	ad 07 05	lda $0507			lda 	compilerStartHigh			; start scanning from here.
.14d0	85 2b		sta $2b				sta 	zTemp0+1
.14d2	64 2a		stz $2a				stz 	zTemp0
.14d4					_IVCheckLoop:
.14d4	b2 2a		lda ($2a)			lda 	(zTemp0) 					; finished ?
.14d6	f0 2b		beq $1503			beq  	_IVNotFound 				; if so, return with CC.
.14d8	a0 01		ldy #$01			ldy 	#1 							; match ?
.14da	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14dc	c5 2c		cmp $2c				cmp 	zTemp1
.14de	d0 07		bne $14e7			bne	 	_IVNext
.14e0	c8		iny				iny
.14e1	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14e3	c5 2d		cmp $2d				cmp 	zTemp1+1
.14e5	f0 0d		beq $14f4			beq 	_IVFound
.14e7					_IVNext:
.14e7	18		clc				clc
.14e8	a5 2a		lda $2a				lda 	zTemp0
.14ea	72 2a		adc ($2a)			adc 	(zTemp0)
.14ec	85 2a		sta $2a				sta 	zTemp0
.14ee	90 e4		bcc $14d4			bcc 	_IVCheckLoop
.14f0	e6 2b		inc $2b				inc 	zTemp0+1
.14f2	80 e0		bra $14d4			bra 	_IVCheckLoop
.14f4					_IVFound:
.14f4	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.14f6	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14f8	aa		tax				tax
.14f9	c8		iny				iny
.14fa	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14fc	48		pha				pha
.14fd	c8		iny				iny
.14fe	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1500	7a		ply				ply
.1501	38		sec				sec
.1502	60		rts				rts
.1503					_IVNotFound:
.1503	a6 2c		ldx $2c				ldx 	zTemp1 						; get variable name back
.1505	a4 2d		ldy $2d				ldy 	zTemp1+1
.1507	18		clc				clc
.1508	60		rts				rts
.1509					FixBranches:
.1509	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.150b	20 ef 11	jsr $11ef			jsr 	CallAPIHandler
.150e					_FBLoop:
.150e	b2 28		lda ($28)			lda 	(objPtr) 					; get the next one.
.1510	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.1512	f0 16		beq $152a			beq 	_FBFixGotoGosub
.1514	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.1516	f0 12		beq $152a			beq 	_FBFixGotoGosub
.1518	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.151a	f0 0e		beq $152a			beq 	_FBFixGotoGosub
.151c	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.151e	f0 0a		beq $152a			beq 	_FBFixGotoGosub
.1520	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.1522	f0 3b		beq $155f			beq 	_FBFixVarSpace
.1524					_FBNext:
.1524	20 44 20	jsr $2044			jsr 	MoveObjectForward 			; move forward in object code.
.1527	90 e5		bcc $150e			bcc 	_FBLoop 					; not finished
.1529					_FBExit:
.1529	60		rts				rts
.152a					_FBFixGotoGosub:
.152a	a0 01		ldy #$01			ldy 	#1							; line number in YA
.152c	b1 28		lda ($28),y			lda 	(objPtr),y
.152e	48		pha				pha
.152f	c8		iny				iny
.1530	b1 28		lda ($28),y			lda 	(objPtr),y
.1532	a8		tay				tay
.1533	68		pla				pla
.1534	20 e7 1b	jsr $1be7			jsr 	STRFindLine			 		; find where it is YA
.1537	90 08		bcc $1541			bcc 	_FBFFound 					; not found, so must be >
.1539	48		pha				pha
.153a	b2 28		lda ($28)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.153c	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.153e	d0 0f		bne $154f			bne 	_FBFFail
.1540	68		pla				pla
.1541					_FBFFound:
.1541	20 37 1c	jsr $1c37			jsr 	STRMakeOffset 				; make it an offset from X:YA
.1544	5a		phy				phy	 								; patch the GOTO/GOSUB
.1545	a0 01		ldy #$01			ldy 	#1
.1547	91 28		sta ($28),y			sta 	(objPtr),y
.1549	c8		iny				iny
.154a	68		pla				pla
.154b	91 28		sta ($28),y			sta 	(objPtr),y
.154d	80 d5		bra $1524			bra 	_FBNext
.154f					_FBFFail:
.154f	a0 02		ldy #$02			ldy 	#2
.1551	b1 28		lda ($28),y			lda 	(objPtr),y
.1553	8d 00 04	sta $0400			sta 	currentLineNumber
.1556	c8		iny				iny
.1557	b1 28		lda ($28),y			lda 	(objPtr),y
.1559	8d 01 04	sta $0401			sta 	currentLineNumber+1
.155c	4c 72 1f	jmp $1f72		jmp	ErrorV_line
.155f					_FBFixVarSpace:
.155f	a0 01		ldy #$01			ldy 	#1
.1561	ad 13 05	lda $0513			lda 	freeVariableMemory
.1564	91 28		sta ($28),y			sta 	(objPtr),y
.1566	c8		iny				iny
.1567	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.156a	91 28		sta ($28),y			sta 	(objPtr),y
.156c	80 b6		bra $1524			bra 	_FBNext
.156e					CommandFOR:
.156e	20 50 1a	jsr $1a50			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.1571	20 66 1a	jsr $1a66			jsr 	CharIsAlpha 				; if not alpha , error
.1574	90 59		bcc $15cf			bcc 	_CFFail
.1576	20 91 1d	jsr $1d91			jsr 	GetReferenceTerm 			; figure out the reference.
.1579	48		pha				pha 								; save type
.157a	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.157c	c9 00		cmp #$00			cmp 	#NSSIFloat
.157e	d0 4f		bne $15cf			bne 	_CFFail
.1580	5a		phy				phy 								; save reference on the stack
.1581	da		phx				phx
.1582	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.1584	20 4e 11	jsr $114e			jsr 	CheckNextA
.1587	20 f3 13	jsr $13f3			jsr 	CompileExpressionAt0 		; initial value
.158a	fa		plx				plx 								; get reference back.
.158b	7a		ply				ply
.158c	5a		phy				phy
.158d	da		phx				phx
.158e	38		sec				sec 								; set initial value.
.158f	20 43 1d	jsr $1d43			jsr 	GetSetVariable
.1592	fa		plx				plx
.1593	7a		ply				ply
.1594	68		pla				pla
.1595	29 20		and #$20			and 	#NSSIInt16
.1597	f0 04		beq $159d			beq 	_CFNotInt16
.1599	98		tya				tya
.159a	09 80		ora #$80			ora 	#$80
.159c	a8		tay				tay
.159d					_CFNotInt16:
.159d	8a		txa				txa 								; reference in YA
.159e	20 f2 11	jsr $11f2			jsr 	PushIntegerYA
.15a1	a9 a4		lda #$a4			lda 	#C64_TO
.15a3	20 4e 11	jsr $114e			jsr 	CheckNextA
.15a6	20 f3 13	jsr $13f3			jsr 	CompileExpressionAt0 		; terminal value
.15a9	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15ab	c9 00		cmp #$00			cmp 	#NSSIFloat
.15ad	d0 20		bne $15cf			bne 	_CFFail
.15af	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; followed by STEP
.15b2	c9 a9		cmp #$a9			cmp 	#C64_STEP
.15b4	d0 0e		bne $15c4			bne 	_CFNoStep
.15b6	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume it.
.15b9	20 f3 13	jsr $13f3			jsr 	CompileExpressionAt0 		; terminal value
.15bc	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15be	c9 00		cmp #$00			cmp 	#NSSIFloat
.15c0	d0 0d		bne $15cf			bne 	_CFFail
.15c2	80 05		bra $15c9			bra 	_CFParametersDone
.15c4					_CFNoStep:
.15c4	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.15c6	20 05 12	jsr $1205			jsr 	PushIntegerA
.15c9					_CFParametersDone:
.15c9	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.15cb	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.15ce	60		rts				rts
.15cf					_CFFail:
.15cf	4c 2f 1f	jmp $1f2f		jmp	ErrorV_syntax
.15d2					FNCompile:
.15d2	20 50 1a	jsr $1a50			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.15d5	20 b5 1a	jsr $1ab5			jsr 	ExtractVariableName
.15d8	e0 00		cpx #$00			cpx 	#0
.15da	10 32		bpl $160e			bpl 	_FNError
.15dc	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.15dd	29 7f		and #$7f			and 	#$7F
.15df	aa		tax				tax
.15e0	98		tya				tya
.15e1	09 80		ora #$80			ora 	#$80
.15e3	a8		tay				tay
.15e4	20 ad 14	jsr $14ad			jsr 	FindVariable				; does it already exist ?
.15e7	90 25		bcc $160e			bcc 	_FNError 					; no.
.15e9	20 37 1c	jsr $1c37			jsr 	STRMakeOffset 				; convert to a relative address.
.15ec	c9 00		cmp #$00			cmp 	#0 							; fix up.
.15ee	d0 01		bne $15f1			bne 	_FNNoBorrow
.15f0	88		dey				dey
.15f1					_FNNoBorrow:
.15f1	3a		dec a				dec 	a
.15f2	5a		phy				phy 								; save location of routine on stack.
.15f3	48		pha				pha
.15f4	da		phx				phx
.15f5	20 f3 13	jsr $13f3			jsr 	CompileExpressionAt0
.15f8	20 48 11	jsr $1148			jsr 	CheckNextRParen
.15fb	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.15fd	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1600	68		pla				pla
.1601	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1604	68		pla				pla
.1605	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1608	68		pla				pla
.1609	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.160c	18		clc				clc
.160d	60		rts				rts
.160e					_FNError:
.160e	4c 22 1f	jmp $1f22		jmp	ErrorV_value
.1611					CommandTables:
>1611	07 cb 00 03 13 1b 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>1618	07 89 00 03 1a 1b 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>161f	07 8d 00 03 0d 1b 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>1626	07 88 00 03 89 1b 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>162d	07 85 00 03 69 1b 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>1634	07 84 00 04 7d 1b 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>163b	07 99 00 03 be 1c 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1642	07 98 00 04 be 1c 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1649	07 8f 00 03 c9 1d 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>1650	07 81 00 03 6e 15 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>1657	07 82 00 03 41 1c 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>165e	07 a1 00 03 86 1a 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>1665	07 83 00 03 a8 12 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>166c	07 87 00 03 07 1d 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>1673	07 86 00 03 3b 13 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>167a	07 96 00 03 c4 12 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>1681	07 8b 00 e3 36 1b 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>1688	08 92 00 ea e3 95 1e 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>1690	09 91 00 e1 a9 03 6d 1c			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>1698	06
>1699	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>16a0	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>16a7	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>16ad	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>16b4	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>16bb	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>16c2	07 9d 00 e3 bb 1e 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>16c9	0a 9f 00 ea e3 ce 1e 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>16d1	c6 06
>16d3	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>16d9	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>16e0	0a ce 92 e3 03 1a 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>16e8	ad 06
>16ea	0a ce 8d e3 03 1a 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>16f2	ae 06
>16f4	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>16fa	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>1702	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>1709	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>1710	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>1718	06
>1719	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>1721	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>1729	9a 06
>172b	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>1733	9b 06
>1735	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>173d	9c 06
>173f	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>1747	06
>1748	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>174f	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>1757	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>175f	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>1767	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>176f	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>1777	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>177f	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>1787	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>178f	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>1797	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>179f	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>17a6	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>17ae	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>17b6	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>17be	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>17c6	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>17ce	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>17d6	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>17de	00						.byte 	0
.17df					UnaryTables:
>17df	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>17e6	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>17ee	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>17f5	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>17fc	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>1803	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>180a	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>1812	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>1819	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>1821	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>1829	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>1831	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>1839	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>1841	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>1849	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>1850	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>1857	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>185e	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>1865	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>186c	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>1873	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>187b	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>1883	0b ca 00 8f ae 03 03 1a			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>188b	91 bd 07
>188e	07 a8 00 03 22 1a 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>1895	07 a5 00 03 d2 15 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>189c	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>18a3	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>18aa	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>18b2	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>18ba	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>18c1	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>18c8	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>18cf	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>18d7	06
>18d8	00						.byte 	0
.18d9					GeneratorProcess:
.18d9	86 2a		stx $2a				stx 	zTemp0 						; save generation pointer in zTemp0
.18db	84 2b		sty $2b				sty 	zTemp0+1
.18dd	85 2c		sta $2c				sta 	zTemp1 						; first match token
.18df	64 2d		stz $2d				stz 	zTemp1+1
.18e1	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.18e3	d0 05		bne $18ea			bne 	_GPNotShifted
.18e5	20 45 1a	jsr $1a45			jsr 	GetNext 					; get the shifted token
.18e8	85 2d		sta $2d				sta 	zTemp1+1 					; match CE xx
.18ea					_GPNotShifted:
.18ea					_GPSearch:
.18ea	b2 2a		lda ($2a)			lda 	(zTemp0) 					; reached end ?
.18ec	18		clc				clc
.18ed	f0 2f		beq $191e			beq 	_GPExit
.18ef	a0 01		ldy #$01			ldy 	#1 							; tokens match
.18f1	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.18f3	c5 2c		cmp $2c				cmp 	zTemp1
.18f5	d0 09		bne $1900			bne 	_GPNext
.18f7	a5 2d		lda $2d				lda 	zTemp1+1 					; 2nd token ?
.18f9	f0 12		beq $190d			beq 	_GPFound
.18fb	c8		iny				iny 								; check match.
.18fc	d1 2a		cmp ($2a),y			cmp 	(zTemp0),y
.18fe	f0 0d		beq $190d			beq 	_GPFound
.1900					_GPNext:
.1900	18		clc				clc 								; follow to next
.1901	a5 2a		lda $2a				lda 	zTemp0
.1903	72 2a		adc ($2a)			adc 	(zTemp0)
.1905	85 2a		sta $2a				sta 	zTemp0
.1907	90 e1		bcc $18ea			bcc 	_GPSearch
.1909	e6 2b		inc $2b				inc 	zTemp0+1
.190b	80 dd		bra $18ea			bra 	_GPSearch
.190d					_GPFound:
.190d	18		clc				clc 								; skip to action bytes
.190e	a5 2a		lda $2a				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.1910	69 03		adc #$03			adc 	#3
.1912	85 2a		sta $2a				sta 	zTemp0
.1914	90 02		bcc $1918			bcc 	_GPNoCarry
.1916	e6 2b		inc $2b				inc 	zTemp0+1
.1918					_GPNoCarry:
.1918					_GPLoop:
.1918	20 1f 19	jsr $191f			jsr 	GeneratorExecute 			; execute one command
.191b	90 fb		bcc $1918			bcc 	_GPLoop 					; go back if not completed.
.191d	38		sec				sec 								; return with CS.
.191e					_GPExit:
.191e	60		rts				rts
.191f					GeneratorExecute:
.191f	20 ca 19	jsr $19ca			jsr 	_GEFetchZTemp0 				; get next.
.1922	48		pha				pha 								; split into 2 nibbles
.1923	4a		lsr a				lsr 	a
.1924	4a		lsr a				lsr 	a
.1925	4a		lsr a				lsr		a
.1926	4a		lsr a				lsr 	a
.1927	20 31 19	jsr $1931			jsr 	_GEExecuteNibble 			; MSB first
.192a	68		pla				pla
.192b	b0 03		bcs $1930			bcs 	_GEHaveCompleted
.192d	20 31 19	jsr $1931			jsr 	_GEExecuteNibble 			; LSB second
.1930					_GEHaveCompleted:
.1930	60		rts				rts
.1931					_GEExecuteNibble:
.1931	29 0f		and #$0f			and 	#$0F
.1933	0a		asl a				asl 	a
.1934	aa		tax				tax
.1935	7c 38 19	jmp ($1938,x)			jmp 	(_GEExecuteVectors,x)
.1938					_GEExecuteVectors:
>1938	58 19						.word 	_GEXNop 					; 0  (no operation)
>193a	60 19						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>193c	5a 19						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>193e	ad 19						.word 	_GEXExecute 				; 3  (run arbitrary code)
>1940	a0 19						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>1942	58 19						.word 	_GEXNop 					; 5
>1944	67 19						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>1946	6b 19						.word 	_GEXExitString 				; 7  exit return string type
>1948	6f 19						.word 	_GEXLParam 					; 8  check ( follows
>194a	73 19						.word 	_GEXRParam 					; 9  check ) follows
>194c	77 19						.word 	_GEXComma					; A  check , follows
>194e	58 19						.word 	_GEXNop 					; B
>1950	58 19						.word 	_GEXNop 					; C
>1952	58 19						.word 	_GEXNop 					; D
>1954	87 19						.word 	_GEXNumber 					; E  compile get any number
>1956	92 19						.word 	_GEXString 					; F  compile get any string
.1958					_GEXNop:
.1958	18		clc				clc
.1959	60		rts				rts
.195a					_GEXToken2:
.195a	20 ca 19	jsr $19ca			jsr 	_GEFetchZTemp0
.195d	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1960					_GEXToken1:
.1960	20 ca 19	jsr $19ca			jsr 	_GEFetchZTemp0
.1963	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1966	60		rts				rts
.1967					_GEXExitNumber:
.1967	a9 00		lda #$00			lda 	#NSSIFloat
.1969	38		sec				sec
.196a	60		rts				rts
.196b					_GEXExitString:
.196b	a9 40		lda #$40			lda 	#NSSString
.196d	38		sec				sec
.196e	60		rts				rts
.196f					_GEXLParam:
.196f	a9 28		lda #$28			lda 	#"("
.1971	80 06		bra $1979			bra 	_GEXCheck
.1973					_GEXRParam:
.1973	a9 29		lda #$29			lda 	#")"
.1975	80 02		bra $1979			bra 	_GEXCheck
.1977					_GEXComma:
.1977	a9 2c		lda #$2c			lda 	#","
.1979					_GEXCheck:
.1979	85 2e		sta $2e				sta 	zTemp2 						; save match
.197b	20 50 1a	jsr $1a50			jsr 	GetNextNonSpace 			; get next skipping spaces
.197e	c5 2e		cmp $2e				cmp 	zTemp2 						; check matches.
.1980	d0 02		bne $1984			bne 	_GEXSyntax
.1982	18		clc				clc
.1983	60		rts				rts
.1984					_GEXSyntax:
.1984	4c 2f 1f	jmp $1f2f		jmp	ErrorV_syntax
.1987					_GEXNumber:
.1987	20 d3 19	jsr $19d3			jsr 	GEXCompileExpression 		; compile expression
.198a	29 40		and #$40			and 	#NSSTypeMask
.198c	c9 00		cmp #$00			cmp  	#NSSIFloat
.198e	d0 0d		bne $199d			bne 	_GEXType
.1990	18		clc				clc
.1991	60		rts				rts
.1992					_GEXString:
.1992	20 d3 19	jsr $19d3			jsr 	GEXCompileExpression 		; compile expression
.1995	29 40		and #$40			and 	#NSSTypeMask
.1997	c9 40		cmp #$40			cmp  	#NSSString
.1999	d0 02		bne $199d			bne 	_GEXType
.199b	18		clc				clc
.199c	60		rts				rts
.199d					_GEXType:
.199d	4c 3f 1f	jmp $1f3f		jmp	ErrorV_type
.19a0					_GEXChannelExec:
.19a0	20 e3 19	jsr $19e3			jsr 	ChannelPrefix 				; set up default
.19a3	20 ad 19	jsr $19ad			jsr 	_GEXExecute
.19a6	08		php				php
.19a7	20 fd 19	jsr $19fd			jsr 	ChannelPostfix 				; replace default.
.19aa	28		plp				plp
.19ab	60		rts				rts
>19ac	db						.byte 	$DB 						; causes a break in the emulator
.19ad					_GEXExecute:
.19ad	20 ca 19	jsr $19ca			jsr 	_GEFetchZTemp0 				; get vector
.19b0	85 2e		sta $2e				sta 	zTemp2
.19b2	20 ca 19	jsr $19ca			jsr 	_GEFetchZTemp0
.19b5	85 2f		sta $2f				sta 	zTemp2+1
.19b7	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19b9	da		phx				phx
.19ba	a6 2b		ldx $2b				ldx 	zTemp0+1
.19bc	da		phx				phx
.19bd	20 c7 19	jsr $19c7			jsr 	_GECallZTemp2 				; execute code
.19c0	fa		plx				plx 								; recover generation exec
.19c1	86 2b		stx $2b				stx 	zTemp0+1
.19c3	fa		plx				plx
.19c4	86 2a		stx $2a				stx 	zTemp0
.19c6	60		rts				rts
.19c7					_GECallZTemp2:
.19c7	6c 2e 00	jmp ($002e)			jmp 	(zTemp2)
.19ca					_GEFetchZTemp0:
.19ca	b2 2a		lda ($2a)			lda 	(zTemp0)
.19cc	e6 2a		inc $2a				inc 	zTemp0
.19ce	d0 02		bne $19d2			bne 	_GEFZ0Skip
.19d0	e6 2b		inc $2b				inc 	zTemp0+1
.19d2					_GEFZ0Skip:
.19d2	60		rts				rts
.19d3					GEXCompileExpression:
.19d3	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19d5	da		phx				phx
.19d6	a6 2b		ldx $2b				ldx 	zTemp0+1
.19d8	da		phx				phx
.19d9	20 f3 13	jsr $13f3			jsr 	CompileExpressionAt0 		; compile expression.
.19dc	fa		plx				plx 								; recover generation exec
.19dd	86 2b		stx $2b				stx 	zTemp0+1
.19df	fa		plx				plx
.19e0	86 2a		stx $2a				stx 	zTemp0
.19e2	60		rts				rts
.19e3					ChannelPrefix:
.19e3	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.19e5	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.19e8	20 d3 19	jsr $19d3			jsr 	GEXCompileExpression 		; channel #
.19eb	29 40		and #$40			and 	#NSSTypeMask
.19ed	c9 00		cmp #$00			cmp 	#NSSIFloat
.19ef	d0 09		bne $19fa			bne 	_CPXType
.19f1	20 44 11	jsr $1144			jsr 	CheckNextComma 				; check , follows.
.19f4	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.19f6	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.19f9	60		rts				rts
.19fa					_CPXType:
.19fa	4c 3f 1f	jmp $1f3f		jmp	ErrorV_type
.19fd					ChannelPostfix:
.19fd	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.19ff	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1a02	60		rts				rts
.1a03					OptionalParameterCompile:
.1a03	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; what follows.
.1a06	c9 2c		cmp #$2c			cmp 	#","
.1a08	d0 0e		bne $1a18			bne 	_MidDefault
.1a0a	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume ,
.1a0d	20 f3 13	jsr $13f3			jsr 	CompileExpressionAt0
.1a10	29 40		and #$40			and 	#NSSTypeMask
.1a12	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a14	d0 09		bne $1a1f			bne 	MidFailType
.1a16	80 05		bra $1a1d			bra 	_MidComplete
.1a18					_MidDefault:
.1a18	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1a1a	20 05 12	jsr $1205			jsr 	PushIntegerA
.1a1d					_MidComplete:
.1a1d	18		clc				clc
.1a1e	60		rts				rts
.1a1f					MidFailType:
.1a1f	4c 3f 1f	jmp $1f3f		jmp	ErrorV_type
.1a22					NotUnaryCompile:
.1a22	ad a8 14	lda $14a8			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1a25	20 f5 13	jsr $13f5			jsr 	CompileExpressionAtA 		; evaluate at that level
.1a28	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1a2a	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a2c	d0 f1		bne $1a1f			bne 	MidFailType
.1a2e	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1a30	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1a33	60		rts				rts
.1a34					LookNext:
.1a34	b2 24		lda ($24)			lda 	(srcPtr)
.1a36	60		rts				rts
.1a37					LookNextNonSpace:
.1a37	b2 24		lda ($24)			lda 	(srcPtr)
.1a39	c9 20		cmp #$20			cmp		#' '
.1a3b	f0 03		beq $1a40			beq 	_LNNSkip
.1a3d	c9 00		cmp #$00			cmp 	#0
.1a3f	60		rts				rts
.1a40					_LNNSkip:
.1a40	20 45 1a	jsr $1a45			jsr 	GetNext
.1a43	80 f2		bra $1a37			bra 	LookNextNonSpace
.1a45					GetNext:
.1a45	b2 24		lda ($24)			lda 	(srcPtr) 					; get next
.1a47	e6 24		inc $24				inc 	srcPtr
.1a49	d0 02		bne $1a4d			bne 	_GNSkip
.1a4b	e6 25		inc $25				inc 	srcPtr+1
.1a4d					_GNSkip:
.1a4d	c9 00		cmp #$00			cmp 	#0
.1a4f	60		rts				rts
.1a50					GetNextNonSpace:
.1a50	20 45 1a	jsr $1a45			jsr 	GetNext
.1a53	c9 20		cmp #$20			cmp 	#' '
.1a55	f0 f9		beq $1a50			beq 	GetNextNonSpace
.1a57	c9 00		cmp #$00			cmp 	#0
.1a59	60		rts				rts
.1a5a					CharIsDigit:
.1a5a	c9 30		cmp #$30			cmp 	#"0"
.1a5c	90 06		bcc $1a64			bcc 	CCFalse
.1a5e	c9 3a		cmp #$3a			cmp 	#"9"+1
.1a60	b0 02		bcs $1a64			bcs 	CCFalse
.1a62					CCTrue:
.1a62	38		sec				sec
.1a63	60		rts				rts
.1a64					CCFalse:
.1a64	18		clc				clc
.1a65	60		rts				rts
.1a66					CharIsAlpha:
.1a66	c9 41		cmp #$41			cmp 	#"A"
.1a68	90 fa		bcc $1a64			bcc 	CCFalse
.1a6a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1a6c	b0 f6		bcs $1a64			bcs 	CCFalse
.1a6e	80 f2		bra $1a62			bra 	CCTrue
.1a70					ConvertHexStyle:
.1a70	38		sec				sec
.1a71	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1a73	90 ef		bcc $1a64			bcc 	CCFalse
.1a75	c9 0a		cmp #$0a			cmp 	#9+1
.1a77	90 e9		bcc $1a62			bcc 	CCTrue
.1a79	38		sec				sec 								; shift into hex space A=>0 Z=>25
.1a7a	e9 11		sbc #$11			sbc 	#"A"-"0"
.1a7c	90 e6		bcc $1a64			bcc 	CCFalse
.1a7e	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.1a80	b0 e2		bcs $1a64			bcs 	CCFalse
.1a82	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.1a84	80 dc		bra $1a62			bra 	CCTrue
.1a86					CommandGET:
.1a86	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; # follows ?
.1a89	c9 23		cmp #$23			cmp 	#"#"
.1a8b	d0 0d		bne $1a9a			bne 	CommandGetBody
.1a8d	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume #
.1a90	20 e3 19	jsr $19e3			jsr 	ChannelPrefix 				; do it as GET#
.1a93	20 9a 1a	jsr $1a9a			jsr 	CommandGetBody
.1a96	20 fd 19	jsr $19fd			jsr 	ChannelPostfix
.1a99	60		rts				rts
.1a9a					CommandGetBody:
.1a9a	20 50 1a	jsr $1a50			jsr 	GetNextNonSpace 			; get the first character
.1a9d	20 91 1d	jsr $1d91			jsr 	GetReferenceTerm 			; identify variable to assign to
.1aa0	48		pha				pha
.1aa1	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1aa3	c9 40		cmp #$40			cmp 	#NSSString
.1aa5	d0 0b		bne $1ab2			bne 	_CGType
.1aa7	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1aa9	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1aac	38		sec				sec
.1aad	68		pla				pla
.1aae	20 43 1d	jsr $1d43			jsr		GetSetVariable
.1ab1	60		rts				rts
.1ab2					_CGType:
.1ab2	4c 3f 1f	jmp $1f3f		jmp	ErrorV_type
.1ab5					ExtractVariableName:
.1ab5	20 66 1a	jsr $1a66			jsr 	CharIsAlpha
.1ab8	90 50		bcc $1b0a			bcc 	_IVSyntax
.1aba	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.1abc	85 2c		sta $2c				sta 	zTemp1 						; we'll build it in zTemp1
.1abe	64 2d		stz $2d				stz 	zTemp1+1
.1ac0	20 34 1a	jsr $1a34			jsr 	LookNext 					; is there a second character ?
.1ac3	20 66 1a	jsr $1a66			jsr 	CharIsAlpha  				; must be alphanumeric
.1ac6	b0 05		bcs $1acd			bcs 	_IVHasSecond
.1ac8	20 5a 1a	jsr $1a5a			jsr 	CharIsDigit
.1acb	90 07		bcc $1ad4			bcc 	_IVCheckType
.1acd					_IVHasSecond:
.1acd	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.1acf	85 2d		sta $2d				sta 	zTemp1+1
.1ad1					_IVGetNextCheck:
.1ad1	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume it
.1ad4					_IVCheckType:
.1ad4	20 34 1a	jsr $1a34			jsr 	LookNext					; check if string follows.
.1ad7	20 66 1a	jsr $1a66			jsr 	CharIsAlpha
.1ada	b0 f5		bcs $1ad1			bcs 	_IVGetNextCheck
.1adc	20 5a 1a	jsr $1a5a			jsr 	CharIsDigit
.1adf	b0 f0		bcs $1ad1			bcs 	_IVGetNextCheck
.1ae1	a2 40		ldx #$40			ldx 	#NSSString
.1ae3	c9 24		cmp #$24			cmp 	#"$"
.1ae5	f0 06		beq $1aed			beq 	_IVHasType
.1ae7	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.1ae9	c9 25		cmp #$25			cmp 	#"%"
.1aeb	d0 08		bne $1af5			bne 	_IVCheckArray
.1aed					_IVHasType:
.1aed	8a		txa				txa 								; Or X into zTemp1
.1aee	05 2c		ora $2c				ora 	zTemp1
.1af0	85 2c		sta $2c				sta 	zTemp1
.1af2	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume it
.1af5					_IVCheckArray:
.1af5	20 34 1a	jsr $1a34			jsr 	LookNext 					; check if array follows
.1af8	c9 28		cmp #$28			cmp 	#"("
.1afa	d0 09		bne $1b05			bne 	_IVNotArray
.1afc	a5 2c		lda $2c				lda 	zTemp1 						; set array bit
.1afe	09 80		ora #$80			ora 	#NSSArray
.1b00	85 2c		sta $2c				sta 	zTemp1
.1b02	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume it
.1b05					_IVNotArray:
.1b05	a6 2c		ldx $2c				ldx 	zTemp1
.1b07	a4 2d		ldy $2d				ldy 	zTemp1+1
.1b09	60		rts				rts
.1b0a					_IVSyntax:
.1b0a	4c 2f 1f	jmp $1f2f		jmp	ErrorV_syntax
.1b0d					CommandGOSUB:
.1b0d	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1b0f	20 20 1b	jsr $1b20			jsr 	CompileBranchCommand
.1b12	60		rts				rts
.1b13					CommandGOAlt:
.1b13	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1b15	20 4e 11	jsr $114e			jsr 	CheckNextA
.1b18	80 00		bra $1b1a			bra 	CommandGOTO
.1b1a					CommandGOTO:
.1b1a	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1b1c	20 20 1b	jsr $1b20			jsr 	CompileBranchCommand
.1b1f	60		rts				rts
.1b20					CompileBranchCommand:
.1b20	20 ec 10	jsr $10ec			jsr 	WriteCodeByte 				; write the command out.
.1b23	20 50 1a	jsr $1a50			jsr 	GetNextNonSpace
.1b26	20 99 1c	jsr $1c99			jsr 	ParseConstant 				; get constant into YA
.1b29	90 08		bcc $1b33			bcc 	_CBCSyntax
.1b2b	20 ec 10	jsr $10ec			jsr 	WriteCodeByte				; and compile the actual line number
.1b2e	98		tya				tya
.1b2f	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b32	60		rts				rts
.1b33					_CBCSyntax:
.1b33	4c 2f 1f	jmp $1f2f		jmp	ErrorV_syntax
.1b36					CommandIF:
.1b36	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; what follows the tests ?
.1b39	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1b3b	f0 0f		beq $1b4c			beq 	_CIGoto
.1b3d	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1b3f	20 4e 11	jsr $114e			jsr 	CheckNextA
.1b42	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; THEN <number>
.1b45	20 5a 1a	jsr $1a5a			jsr 	CharIsDigit
.1b48	b0 05		bcs $1b4f			bcs 	_CIGoto2
.1b4a	80 09		bra $1b55			bra 	CompileGotoEOL
.1b4c					_CIGoto:
.1b4c	20 45 1a	jsr $1a45			jsr 	GetNext
.1b4f					_CIGoto2:
.1b4f	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1b51	20 20 1b	jsr $1b20			jsr 	CompileBranchCommand
.1b54	60		rts				rts
.1b55					CompileGotoEOL:
.1b55	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.1b57	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b5a	20 e5 10	jsr $10e5			jsr 	GetLineNumber 				; Get the current line number => YA
.1b5d	1a		inc a				inc 	a 							; and branch to +1
.1b5e	d0 01		bne $1b61			bne 	_CGENoCarry
.1b60	c8		iny				iny
.1b61					_CGENoCarry:
.1b61	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b64	98		tya				tya
.1b65	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b68	60		rts				rts
.1b69					CommandINPUT:
.1b69	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; check for "
.1b6c	c9 22		cmp #$22			cmp 	#'"'
.1b6e	d0 0d		bne $1b7d			bne 	CommandINPUTStream
.1b70	20 f3 13	jsr $13f3			jsr 	CompileExpressionAt0
.1b73	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1b75	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b78	a9 2c		lda #$2c			lda 	#","
.1b7a	20 44 11	jsr $1144			jsr 	CheckNextComma
.1b7d					CommandINPUTStream:
.1b7d	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1b7f	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b82	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.1b84	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1b86	4c 0b 1d	jmp $1d0b			jmp 	CommandReadInputCommon
.1b89					CommandLET:
.1b89	20 50 1a	jsr $1a50			jsr 	GetNextNonSpace 			; get the first character
.1b8c					CommandLETHaveFirst:
.1b8c	20 91 1d	jsr $1d91			jsr 	GetReferenceTerm 			; identify variable to assign to
.1b8f	da		phx				phx 								; save target on the stack.
.1b90	5a		phy				phy
.1b91	48		pha				pha
.1b92	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.1b94	20 4e 11	jsr $114e			jsr 	CheckNextA
.1b97	20 f3 13	jsr $13f3			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1b9a	85 2a		sta $2a				sta 	zTemp0 						; save type returned
.1b9c	68		pla				pla 								; get type of assignment
.1b9d	48		pha				pha
.1b9e	45 2a		eor $2a				eor 	zTemp0 						; compare using EOR
.1ba0	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.1ba2	d0 17		bne $1bbb			bne 	_CLType
.1ba4	68		pla				pla 								; restore and compile save code
.1ba5	7a		ply				ply
.1ba6	fa		plx				plx
.1ba7	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.1ba9	f0 05		beq $1bb0			beq 	_CLTIString
.1bab	38		sec				sec
.1bac	20 43 1d	jsr $1d43			jsr		GetSetVariable
.1baf	60		rts				rts
.1bb0					_CLTIString:
.1bb0	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.1bb2	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1bb5	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.1bb7	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1bba	60		rts				rts
.1bbb					_CLType:
.1bbb	4c 3f 1f	jmp $1f3f		jmp	ErrorV_type
.1bbe					STRMarkLine:
.1bbe	48		pha				pha
.1bbf	38		sec				sec 								; allocate 4 bytes (line #,address)
.1bc0	ad 0f 05	lda $050f			lda 	lineNumberTable 			; and copy to zTemp0
.1bc3	e9 04		sbc #$04			sbc 	#4
.1bc5	8d 0f 05	sta $050f			sta 	lineNumberTable
.1bc8	85 2a		sta $2a				sta 	zTemp0
.1bca	ad 10 05	lda $0510			lda 	lineNumberTable+1
.1bcd	e9 00		sbc #$00			sbc 	#0
.1bcf	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1bd2	85 2b		sta $2b				sta 	zTemp0+1
.1bd4	68		pla				pla
.1bd5	92 2a		sta ($2a)			sta 	(zTemp0) 					; line # save it in +0,+1
.1bd7	98		tya				tya
.1bd8	a0 01		ldy #$01			ldy 	#1
.1bda	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1bdc	a5 28		lda $28				lda 	objPtr 						; save current address in +2,+3
.1bde	c8		iny				iny
.1bdf	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1be1	a5 29		lda $29				lda 	objPtr+1
.1be3	c8		iny				iny
.1be4	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1be6	60		rts				rts
.1be7					STRFindLine:
.1be7	85 2a		sta $2a				sta 	zTemp0 						; zTemp0 line number being searched
.1be9	84 2b		sty $2b				sty 	zTemp0+1
.1beb	ad 08 05	lda $0508			lda 	compilerEndHigh 			; work backwards through table
.1bee	85 2d		sta $2d				sta 	zTemp1+1
.1bf0	64 2c		stz $2c				stz 	zTemp1
.1bf2					_STRSearch:
.1bf2	20 29 1c	jsr $1c29			jsr 	_STRPrevLine 				; look at previous record.
.1bf5	a0 01		ldy #$01			ldy 	#1
.1bf7	b2 2c		lda ($2c)			lda 	(zTemp1) 					; check table line # >= target
.1bf9	c5 2a		cmp $2a				cmp 	zTemp0
.1bfb	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1bfd	e5 2b		sbc $2b				sbc 	zTemp0+1
.1bff	b0 0b		bcs $1c0c			bcs 	_STRFound 					; >=
.1c01					_STRNext:
.1c01	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1c03	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c05	c9 ff		cmp #$ff			cmp 	#$FF
.1c07	d0 e9		bne $1bf2			bne 	_STRSearch
.1c09	4c 89 1f	jmp $1f89		jmp	ErrorV_internal
.1c0c					_STRFound:
.1c0c	b2 2c		lda ($2c)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1c0e	45 2a		eor $2a				eor 	zTemp0
.1c10	d0 06		bne $1c18			bne 	_STRDifferent
.1c12	b2 2c		lda ($2c)			lda 	(zTemp1)
.1c14	45 2a		eor $2a				eor 	zTemp0
.1c16	f0 02		beq $1c1a			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1c18					_STRDifferent:
.1c18	a9 ff		lda #$ff			lda 	#$FF
.1c1a					_STROut:
.1c1a	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1c1b	69 ff		adc #$ff			adc 	#255
.1c1d	08		php				php
.1c1e	c8		iny				iny 								; address into YA
.1c1f	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c21	48		pha				pha
.1c22	c8		iny				iny
.1c23	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c25	a8		tay				tay
.1c26	68		pla				pla
.1c27	28		plp				plp
.1c28	60		rts				rts
.1c29					_STRPrevLine:
.1c29	38		sec				sec 								; move backwards one entry.
.1c2a	a5 2c		lda $2c				lda 	zTemp1
.1c2c	e9 04		sbc #$04			sbc 	#4
.1c2e	85 2c		sta $2c				sta 	zTemp1
.1c30	a5 2d		lda $2d				lda 	zTemp1+1
.1c32	e9 00		sbc #$00			sbc 	#0
.1c34	85 2d		sta $2d				sta 	zTemp1+1
.1c36	60		rts				rts
.1c37					STRMakeOffset:
.1c37	18		clc				clc 								; borrow 1
.1c38	e5 28		sbc $28				sbc 	objPtr
.1c3a	48		pha				pha
.1c3b	98		tya				tya
.1c3c	e5 29		sbc $29				sbc 	objPtr+1
.1c3e	a8		tay				tay
.1c3f	68		pla				pla
.1c40	60		rts				rts
.1c41					CommandNEXT:
.1c41	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1c44	20 66 1a	jsr $1a66			jsr 	CharIsAlpha 				; if not alpha , error
.1c47	90 0c		bcc $1c55			bcc 	_CNNoReferenceGiven
.1c49	20 45 1a	jsr $1a45			jsr 	GetNext
.1c4c	20 91 1d	jsr $1d91			jsr 	GetReferenceTerm 			; figure out the reference.
.1c4f	8a		txa				txa 								; reference in YA
.1c50	20 f2 11	jsr $11f2			jsr 	PushIntegerYA 				; write it out.
.1c53	80 06		bra $1c5b			bra 	_CNParametersDone
.1c55					_CNNoReferenceGiven:
.1c55	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1c57	a8		tay				tay
.1c58	20 f2 11	jsr $11f2			jsr 	PushIntegerYA 				; write it out.
.1c5b					_CNParametersDone:
.1c5b	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1c5d	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1c60	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; look for ,
.1c63	c9 2c		cmp #$2c			cmp 	#","
.1c65	d0 05		bne $1c6c			bne 	_CNExit
.1c67	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume ,
.1c6a	80 d5		bra $1c41			bra 	CommandNEXT 				; and go round.
.1c6c					_CNExit:
.1c6c	60		rts				rts
.1c6d					CommandON:
.1c6d	20 50 1a	jsr $1a50			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1c70	48		pha				pha 								; save on stack
.1c71	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1c73	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1c75	f0 09		beq $1c80			beq 	_COCreateLoop
.1c77	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1c79	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1c7b	f0 03		beq $1c80			beq 	_COCreateLoop
.1c7d	4c 2f 1f	jmp $1f2f		jmp	ErrorV_syntax
.1c80					_COCreateLoop:
.1c80	8a		txa				txa 								; compile a goto/gosub somewhere
.1c81	da		phx				phx
.1c82	20 20 1b	jsr $1b20			jsr 	CompileBranchCommand
.1c85	fa		plx				plx
.1c86	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace			; ',' follows
.1c89	c9 2c		cmp #$2c			cmp 	#","
.1c8b	d0 0a		bne $1c97			bne 	_COComplete 				; if so, more line numbers
.1c8d	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1c8f	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1c92	20 45 1a	jsr $1a45			jsr 	GetNext
.1c95	80 e9		bra $1c80			bra 	_COCreateLoop
.1c97					_COComplete:
.1c97	68		pla				pla 								; throw GOTO/GOSUB
.1c98	60		rts				rts
.1c99					ParseConstant:
.1c99	a2 00		ldx #$00			ldx 	#0
.1c9b	20 55 24	jsr $2455			jsr 	FloatEncodeStart 			; send first
.1c9e					_ParseLoop:
.1c9e	20 34 1a	jsr $1a34			jsr 	LookNext 					; send subsequent
.1ca1	20 58 24	jsr $2458			jsr 	FloatEncodeContinue
.1ca4	90 05		bcc $1cab			bcc 	_ParseDone
.1ca6	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume it
.1ca9	80 f3		bra $1c9e			bra 	_ParseLoop
.1cab					_ParseDone:
.1cab	b5 30		lda $30,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1cad	29 80		and #$80			and 	#$80
.1caf	15 6c		ora $6c,x			ora 	NSExponent,x 				; 16 bit int check
.1cb1	15 54		ora $54,x			ora 	NSMantissa2,x
.1cb3	15 60		ora $60,x			ora 	NSMantissa3,x
.1cb5	18		clc				clc
.1cb6	d0 05		bne $1cbd			bne 	_ParseExit 					; exit with CC if need float to compile
.1cb8	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; read into YA.
.1cba	b4 48		ldy $48,x			ldy		NSMantissa1,x
.1cbc	38		sec				sec
.1cbd					_ParseExit:
.1cbd	60		rts				rts
.1cbe					CommandPRINT:
.1cbe	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace			; what follows ?
.1cc1	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1cc3	f0 1f		beq $1ce4			beq 	_CPCheckEnd
.1cc5	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1cc7	f0 16		beq $1cdf			beq 	_CPTabCheckEnd
.1cc9	20 fb 1c	jsr $1cfb			jsr 	_CPAtEnd 					; check for : and EOL
.1ccc	b0 22		bcs $1cf0			bcs 	_CPExitCR 					; exit with CR
.1cce	20 f3 13	jsr $13f3			jsr 	CompileExpressionAt0 		; so it is something to print
.1cd1	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1cd3	29 40		and #$40			and 	#NSSString 					; if string
.1cd5	d0 02		bne $1cd9			bne 	_CPOut
.1cd7	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1cd9					_CPOut:
.1cd9	8a		txa				txa 								; print that thing
.1cda	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1cdd	80 df		bra $1cbe			bra 	CommandPRINT 				; and loop round/
.1cdf					_CPTabCheckEnd:
.1cdf	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1ce1	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1ce4					_CPCheckEnd:
.1ce4	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume it.
.1ce7	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; what follows ?
.1cea	20 fb 1c	jsr $1cfb			jsr 	_CPAtEnd 					; reached end
.1ced	90 cf		bcc $1cbe			bcc 	CommandPRINT 				; no, loop back
.1cef	60		rts				rts
.1cf0					_CPExitCR:
.1cf0	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1cf2	20 05 12	jsr $1205			jsr 	PushIntegerA
.1cf5	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1cf7	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1cfa	60		rts				rts
.1cfb					_CPAtEnd:
.1cfb	c9 00		cmp #$00			cmp 	#0
.1cfd	f0 06		beq $1d05			beq 	_CPIsEnd
.1cff	c9 3a		cmp #$3a			cmp 	#":"
.1d01	f0 02		beq $1d05			beq 	_CPIsEnd
.1d03	18		clc				clc
.1d04	60		rts				rts
.1d05					_CPIsEnd:
.1d05	38		sec				sec
.1d06	60		rts				rts
.1d07					CommandREAD:
.1d07	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1d09	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1d0b					CommandReadInputCommon:
.1d0b	8e 0d 05	stx $050d			stx 	numberPCode
.1d0e	8c 0e 05	sty $050e			sty 	stringPCode
.1d11					_CRLoop:
.1d11	20 50 1a	jsr $1a50			jsr 	GetNextNonSpace 			; first char of identifier
.1d14	20 66 1a	jsr $1a66			jsr 	CharIsAlpha 				; check A-Z
.1d17	90 27		bcc $1d40			bcc 	_CRSyntax
.1d19	20 91 1d	jsr $1d91			jsr 	GetReferenceTerm 			; get the variable.
.1d1c	48		pha				pha 								; save type.
.1d1d	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1d1f	c9 40		cmp #$40			cmp 	#NSSString
.1d21	f0 05		beq $1d28			beq 	_CRString
.1d23	ad 0d 05	lda $050d			lda 	numberPCode 				; output read/input
.1d26	80 03		bra $1d2b			bra 	_CRHaveType
.1d28					_CRString:
.1d28	ad 0e 05	lda $050e			lda 	stringPCode					; output read$/input$
.1d2b					_CRHaveType:
.1d2b	20 ec 10	jsr $10ec			jsr 	WriteCodeByte 				; so we have one typed data item.
.1d2e	68		pla				pla 								; restore type
.1d2f	38		sec				sec  								; write update code.
.1d30	20 43 1d	jsr $1d43			jsr 	GetSetVariable
.1d33	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; , follows ?
.1d36	c9 2c		cmp #$2c			cmp 	#","
.1d38	d0 05		bne $1d3f			bne 	_CRExit 					; if not, end of READ.
.1d3a	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume comma
.1d3d	80 d2		bra $1d11			bra 	_CRLoop 					; keep going
.1d3f					_CRExit:
.1d3f	60		rts				rts
.1d40					_CRSyntax:
.1d40	4c 2f 1f	jmp $1f2f		jmp	ErrorV_syntax
.050d					numberPCode:
>050d							.fill 	1
.050e					stringPCode:
>050e							.fill 	1
.1d43					GetSetVariable:
.1d43	08		php				php 								; save direction on stack
.1d44	c0 00		cpy #$00			cpy 	#$00
.1d46	30 21		bmi $1d69			bmi 	_GSVReadWriteSpecial
.1d48	c9 00		cmp #$00			cmp 	#$00
.1d4a	30 33		bmi $1d7f			bmi 	_GSVArray
.1d4c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1d4e	4a		lsr a				lsr 	a 							; divide by 2
.1d4f	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1d51	28		plp				plp
.1d52	90 02		bcc $1d56			bcc 	_GSVNotWrite
.1d54	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1d56					_GSVNotWrite:
.1d56	85 2a		sta $2a				sta 	zTemp0
.1d58	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1d59	4a		lsr a				lsr 	a
.1d5a	a8		tay				tay
.1d5b	8a		txa				txa
.1d5c	6a		ror a				ror 	a
.1d5d	aa		tax				tax
.1d5e	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1d5f	05 2a		ora $2a				ora 	zTemp0 						; which is the first byte of the opcode
.1d61	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1d64	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1d65	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1d68	60		rts				rts
.1d69					_GSVReadWriteSpecial:
.1d69	28		plp				plp
.1d6a	b0 10		bcs $1d7c			bcs 	_GSVSyntax
.1d6c	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1d6e	f0 06		beq $1d76			beq 	_GSVRWString
.1d70	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1d72	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1d75	60		rts				rts
.1d76					_GSVRWString:
.1d76	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1d78	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1d7b	60		rts				rts
.1d7c					_GSVSyntax:
.1d7c	4c 2f 1f	jmp $1f2f		jmp	ErrorV_syntax
.1d7f					_GSVArray:
.1d7f	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1d81	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1d82	4a		lsr a				lsr 	a
.1d83	4a		lsr a				lsr 	a
.1d84	4a		lsr a				lsr 	a
.1d85	4a		lsr a				lsr 	a
.1d86	28		plp				plp 								; if writing array then set bit 2.
.1d87	90 02		bcc $1d8b			bcc 	_GSVANotWrite
.1d89	09 04		ora #$04			ora 	#4
.1d8b					_GSVANotWrite:
.1d8b	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1d8d	20 ec 10	jsr $10ec			jsr 	WriteCodeByte 				; and write it out
.1d90	60		rts				rts
.1d91					GetReferenceTerm:
.1d91	20 b5 1a	jsr $1ab5			jsr 	ExtractVariableName 		; get name & type info
.1d94	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1d96	30 10		bmi $1da8			bmi 	_GRTArray
.1d98	da		phx				phx 								; save type on stack
.1d99	20 ad 14	jsr $14ad			jsr 	FindVariable 				; find it
.1d9c	b0 06		bcs $1da4			bcs 	_GRTNoCreate 				; create if required.
.1d9e	20 37 12	jsr $1237			jsr 	CreateVariableRecord 		; create a variable.
.1da1	20 8c 12	jsr $128c			jsr 	AllocateBytesForType 		; allocate memory for it
.1da4					_GRTNoCreate:
.1da4	68		pla				pla 								; get type back, strip out type information.
.1da5	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1da7	60		rts				rts
.1da8					_GRTArray:
.1da8	da		phx				phx 								; save type information
.1da9	20 ad 14	jsr $14ad			jsr 	FindVariable 				; read its data, the base address in YX
.1dac	90 18		bcc $1dc6			bcc 	_GRTUndeclared 				; undeclared array.
.1dae	da		phx				phx 								; save base address
.1daf	5a		phy				phy
.1db0	20 83 13	jsr $1383			jsr 	OutputIndexGroup 			; create an index group and generate them
.1db3	7a		ply				ply 								; get the array base address into YX
.1db4	fa		plx				plx
.1db5	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1db7	18		clc				clc
.1db8	20 43 1d	jsr $1d43			jsr 	GetSetVariable 				; load the address of the array structure.
.1dbb	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1dbd	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1dc0	68		pla				pla 								; and the type data into A
.1dc1	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1dc3	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1dc5	60		rts				rts
.1dc6					_GRTUndeclared:
.1dc6	4c e6 1f	jmp $1fe6		jmp	ErrorV_undeclared
.1dc9					CommandREM:
.1dc9	20 34 1a	jsr $1a34			jsr 	LookNext
.1dcc	f0 05		beq $1dd3			beq 	_CRExit
.1dce	20 45 1a	jsr $1a45			jsr 	GetNext
.1dd1	80 f6		bra $1dc9			bra 	CommandREM
.1dd3					_CRExit:
.1dd3	60		rts				rts
.1dd4					STRReset:
.1dd4	ad 07 05	lda $0507			lda	 	compilerStartHigh 			; set up the two table pointers
.1dd7	8d 12 05	sta $0512			sta 	variableListEnd+1
.1dda	9c 11 05	stz $0511			stz 	variableListEnd
.1ddd	ad 08 05	lda $0508			lda 	compilerEndHigh
.1de0	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1de3	9c 0f 05	stz $050f			stz 	lineNumberTable
.1de6	ad 11 05	lda $0511			lda 	variableListEnd
.1de9	85 2b		sta $2b				sta 	zTemp0+1
.1deb	64 2a		stz $2a				stz 	zTemp0
.1ded	a9 00		lda #$00			lda 	#0
.1def	92 2a		sta ($2a)			sta 	(zTemp0)
.1df1	a9 00		lda #$00			lda 	#((0) & $FF)
.1df3	8d 13 05	sta $0513			sta 	0+freeVariableMemory
.1df6	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1df8	8d 14 05	sta $0514			sta 	1+freeVariableMemory
.1dfb	60		rts				rts
.050f					lineNumberTable:
>050f							.fill 	2
.0511					variableListEnd:
>0511							.fill 	2
.0513					freeVariableMemory:
>0513							.fill 	2
.1dfc					CompileTerm:
.1dfc	20 50 1a	jsr $1a50			jsr 	GetNextNonSpace 			; get first non space character.
.1dff	30 72		bmi $1e73			bmi 	_CTUnaryFunctions
.1e01	20 5a 1a	jsr $1a5a			jsr 	CharIsDigit 				; found a number
.1e04	b0 3a		bcs $1e40			bcs 	_CTDigit
.1e06	c9 2e		cmp #$2e			cmp 	#"."
.1e08	f0 36		beq $1e40			beq 	_CTDigit
.1e0a	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1e0c	f0 43		beq $1e51			beq 	_CTString
.1e0e	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1e10	f0 28		beq $1e3a			beq 	_CTOtherBase
.1e12	c9 24		cmp #$24			cmp 	#"$"
.1e14	f0 24		beq $1e3a			beq 	_CTOtherBase
.1e16	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1e18	f0 17		beq $1e31			beq 	_CTBrackets
.1e1a	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1e1c	90 10		bcc $1e2e			bcc 	_CTSyntax
.1e1e	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1e20	b0 0c		bcs $1e2e			bcs 	_CTSyntax
.1e22	20 91 1d	jsr $1d91			jsr 	GetReferenceTerm 			; figure out what it is.
.1e25	48		pha				pha 								; save type on stack
.1e26	18		clc				clc 								; read it
.1e27	20 43 1d	jsr $1d43			jsr 	GetSetVariable
.1e2a	68		pla				pla
.1e2b	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1e2d	60		rts				rts
.1e2e					_CTSyntax:
.1e2e	4c 2f 1f	jmp $1f2f		jmp	ErrorV_syntax
.1e31					_CTBrackets:
.1e31	20 f3 13	jsr $13f3			jsr 	CompileExpressionAt0
.1e34	48		pha				pha
.1e35	20 48 11	jsr $1148			jsr 	CheckNextRParen
.1e38	68		pla				pla
.1e39	60		rts				rts
.1e3a					_CTOtherBase:
.1e3a	20 9a 10	jsr $109a			jsr 	InlineNonDecimal 			; non decimal constant handler
.1e3d	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e3f	60		rts				rts
.1e40					_CTDigit:
.1e40	20 99 1c	jsr $1c99			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1e43	90 06		bcc $1e4b			bcc	 	_CTFloat 					; have a float or long int.
.1e45	20 f2 11	jsr $11f2			jsr 	PushIntegerYA 				; code to push on stack
.1e48	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e4a	60		rts				rts
.1e4b					_CTFloat:
.1e4b	20 14 12	jsr $1214			jsr 	PushFloat  					; code to push float
.1e4e	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1e50	60		rts				rts
.1e51					_CTString:
.1e51	20 1d 11	jsr $111d			jsr 	BufferClear 				; copy it to the buffer
.1e54					_CTStringLoop:
.1e54	20 34 1a	jsr $1a34			jsr 	LookNext 					; reached EOL/EOS
.1e57	f0 d5		beq $1e2e			beq 	_CTSyntax
.1e59	c9 22		cmp #$22			cmp 	#'"'
.1e5b	f0 08		beq $1e65			beq 	_CTStringDone
.1e5d	20 21 11	jsr $1121			jsr 	BufferWrite 				; write and consume
.1e60	20 45 1a	jsr $1a45			jsr 	GetNext
.1e63	80 ef		bra $1e54			bra 	_CTStringLoop
.1e65					_CTStringDone:
.1e65	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume closing quote.
.1e68	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1e6a	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1e6d	20 2d 11	jsr $112d			jsr 	BufferOutput
.1e70	a9 40		lda #$40			lda 	#NSSString 					; string type
.1e72	60		rts				rts
.1e73					_CTUnaryFunctions:
.1e73	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1e75	f0 0a		beq $1e81			beq 	_CTNegation
.1e77	a2 df		ldx #$df			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1e79	a0 17		ldy #$17			ldy 	#UnaryTables >> 8
.1e7b	20 d9 18	jsr $18d9			jsr 	GeneratorProcess
.1e7e	90 ae		bcc $1e2e			bcc		_CTSyntax
.1e80	60		rts				rts
.1e81					_CTNegation:
.1e81	20 fc 1d	jsr $1dfc			jsr 	CompileTerm 				; compile a term.
.1e84	48		pha				pha
.1e85	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1e87	c9 00		cmp #$00			cmp 	#NSSIFloat
.1e89	d0 07		bne $1e92			bne 	_CTType 					; error
.1e8b	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1e8d	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1e90	68		pla				pla 								; return original type.
.1e91	60		rts				rts
.1e92					_CTType:
.1e92	4c 3f 1f	jmp $1f3f		jmp	ErrorV_type
.1e95					CommandWAIT:
.1e95	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace
.1e98	c9 2c		cmp #$2c			cmp 	#","
.1e9a	f0 10		beq $1eac			beq 	_CWThirdParameter
.1e9c	a9 00		lda #$00			lda 	#0
.1e9e	20 05 12	jsr $1205			jsr 	PushIntegerA
.1ea1					_CWExit:
.1ea1	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1ea3	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1ea6	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1ea8	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1eab	60		rts				rts
.1eac					_CWThirdParameter:
.1eac	20 45 1a	jsr $1a45			jsr 	GetNext
.1eaf	20 f5 13	jsr $13f5			jsr 	CompileExpressionAtA
.1eb2	29 40		and #$40			and 	#NSSTypeMask
.1eb4	c9 00		cmp #$00			cmp 	#NSSIFloat
.1eb6	f0 e9		beq $1ea1			beq 	_CWExit
.1eb8	4c 3f 1f	jmp $1f3f		jmp	ErrorV_type
.1ebb					CommandCMD:
.1ebb	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.1ebd	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1ec0	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; followed by a , ?
.1ec3	c9 2c		cmp #$2c			cmp 	#","
.1ec5	d0 06		bne $1ecd			bne 	_CCMDExit
.1ec7	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume comma.
.1eca	20 be 1c	jsr $1cbe			jsr 	CommandPRINT 				; do the print code
.1ecd					_CCMDExit:
.1ecd	60		rts				rts
.1ece					CommandOPEN:
.1ece	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; followed by a , ?
.1ed1	c9 2c		cmp #$2c			cmp 	#","
.1ed3	d0 15		bne $1eea			bne 	_COTwoDefaults
.1ed5	20 45 1a	jsr $1a45			jsr 	GetNext 					; consume comma
.1ed8	20 f3 13	jsr $13f3			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1edb	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1edd	f0 1e		beq $1efd			beq 	_COThreeIntegers
.1edf	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1ee1	20 05 12	jsr $1205			jsr 	PushIntegerA
.1ee4	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1ee6	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1ee9	60		rts				rts
.1eea					_COTwoDefaults:
.1eea	a9 00		lda #$00			lda 	#0
.1eec	20 05 12	jsr $1205			jsr 	PushIntegerA
.1eef					_COCompileNullString:
.1eef	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1ef1	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1ef4	a9 00		lda #$00			lda 	#0
.1ef6	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1ef9	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1efc	60		rts				rts
.1efd					_COThreeIntegers:
.1efd	20 37 1a	jsr $1a37			jsr 	LookNextNonSpace 			; is there a ,
.1f00	c9 2c		cmp #$2c			cmp 	#","
.1f02	d0 eb		bne $1eef			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1f04	20 45 1a	jsr $1a45			jsr 	GetNext
.1f07	20 f3 13	jsr $13f3			jsr 	CompileExpressionAt0 		; should be a filename
.1f0a	29 40		and #$40			and 	#NSSString
.1f0c	f0 01		beq $1f0f			beq 	_COType
.1f0e	60		rts				rts
.1f0f					_COType:
.1f0f	4c 3f 1f	jmp $1f3f		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					objPtr:
>0028							.fill 	2
.002a					zTemp0:
>002a							.fill 	2
.002c					zTemp1:
>002c							.fill 	2
.002e					zTemp2:
>002e							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1f12					ErrorV_range:
.1f12	20 ab 13	jsr $13ab		jsr	ErrorHandler
>1f15	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f1d	41 4e 47 45 00
.1f22					ErrorV_value:
.1f22	20 ab 13	jsr $13ab		jsr	ErrorHandler
>1f25	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f2d	45 00
.1f2f					ErrorV_syntax:
.1f2f	20 ab 13	jsr $13ab		jsr	ErrorHandler
>1f32	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f3a	52 52 4f 52 00
.1f3f					ErrorV_type:
.1f3f	20 ab 13	jsr $13ab		jsr	ErrorHandler
>1f42	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f4a	4d 41 54 43 48 00
.1f50					ErrorV_unimplemented:
.1f50	20 ab 13	jsr $13ab		jsr	ErrorHandler
>1f53	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f5b	45 4d 45 4e 54 45 44 00
.1f63					ErrorV_assert:
.1f63	20 ab 13	jsr $13ab		jsr	ErrorHandler
>1f66	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f6e	41 49 4c 00
.1f72					ErrorV_line:
.1f72	20 ab 13	jsr $13ab		jsr	ErrorHandler
>1f75	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f7d	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f89					ErrorV_internal:
.1f89	20 ab 13	jsr $13ab		jsr	ErrorHandler
>1f8c	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f94	20 45 52 52 4f 52 00
.1f9b					ErrorV_divzero:
.1f9b	20 ab 13	jsr $13ab		jsr	ErrorHandler
>1f9e	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fa6	59 20 5a 45 52 4f 00
.1fad					ErrorV_structure:
.1fad	20 ab 13	jsr $13ab		jsr	ErrorHandler
>1fb0	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fb8	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fc4					ErrorV_stop:
.1fc4	20 ab 13	jsr $13ab		jsr	ErrorHandler
>1fc7	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fcf	53 54 4f 50 50 45 44 00
.1fd7					ErrorV_data:
.1fd7	20 ab 13	jsr $13ab		jsr	ErrorHandler
>1fda	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fe2	41 54 41 00
.1fe6					ErrorV_undeclared:
.1fe6	20 ab 13	jsr $13ab		jsr	ErrorHandler
>1fe9	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1ff1	41 52 52 41 59 00
.1ff7					ErrorV_redefine:
.1ff7	20 ab 13	jsr $13ab		jsr	ErrorHandler
>1ffa	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>2002	44 45 46 49 4e 45 44 00
.200a					ErrorV_index:
.200a	20 ab 13	jsr $13ab		jsr	ErrorHandler
>200d	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2015	59 20 49 4e 44 45 58 00
.201d					ErrorV_memory:
.201d	20 ab 13	jsr $13ab		jsr	ErrorHandler
>2020	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2028	45 4d 4f 52 59 00
.202e					ErrorV_channel:
.202e	20 ab 13	jsr $13ab		jsr	ErrorHandler
>2031	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2039	54 50 55 54 20 45 52 52 4f 52 00
.2044					MoveObjectForward:
.2044	b2 28		lda ($28)			lda 	(objPtr) 					; get next
.2046	c9 ff		cmp #$ff			cmp 	#$FF
.2048	f0 36		beq $2080			beq 	_MOFEnd
.204a	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.204c	90 24		bcc $2072			bcc 	_MOFAdvance1 				; forward 1
.204e	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.2050	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2052	90 20		bcc $2074			bcc 	_MOFAdvanceY
.2054	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2056	90 1a		bcc $2072			bcc 	_MOFAdvance1 				; forward 1
.2058	a8		tay				tay 								; read the size.
.2059	b9 be 1f	lda $1fbe,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.205c	a8		tay				tay
.205d	c8		iny				iny 								; add 1 for the system token.
.205e	d0 14		bne $2074			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2060	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2062	b1 28		lda ($28),y			lda 	(objPtr),y
.2064	a8		tay				tay 								; into Y.
.2065	18		clc				clc
.2066	a5 28		lda $28				lda 	objPtr						; add 2 to the object pointer
.2068	69 02		adc #$02			adc 	#2
.206a	85 28		sta $28				sta 	objPtr
.206c	90 02		bcc $2070			bcc 	_MOFNoCarry1
.206e	e6 29		inc $29				inc 	objPtr+1
.2070					_MOFNoCarry1:
.2070	80 02		bra $2074			bra 	_MOFAdvanceY
.2072					_MOFAdvance1:
.2072	a0 01		ldy #$01			ldy 	#1
.2074					_MOFAdvanceY:
.2074	98		tya				tya 								; add Y to objPtr
.2075	18		clc				clc
.2076	65 28		adc $28				adc 	objPtr
.2078	85 28		sta $28				sta 	objPtr
.207a	90 02		bcc $207e			bcc 	_MOFNoCarry2
.207c	e6 29		inc $29				inc 	objPtr+1
.207e					_MOFNoCarry2:
.207e	18		clc				clc 								; not completed.
.207f	60		rts				rts
.2080					_MOFEnd:
.2080	e6 28		inc $28				inc 	objPtr
.2082	d0 02		bne $2086			bne 	_MOFENoCarry
.2084	e6 29		inc $29				inc 	objPtr+1
.2086					_MOFENoCarry:
.2086	38		sec				sec
.2087	60		rts				rts
.2088					MOFSizeTable:
>2088	01					.byte	1         	; $ca .shift
>2089	01					.byte	1         	; $cb .byte
>208a	02					.byte	2         	; $cc .word
>208b	05					.byte	5         	; $cd .float
>208c	ff					.byte	255       	; $ce .string
>208d	ff					.byte	255       	; $cf .data
>208e	02					.byte	2         	; $d0 .goto
>208f	02					.byte	2         	; $d1 .gosub
>2090	02					.byte	2         	; $d2 .goto.z
>2091	02					.byte	2         	; $d3 .goto.nz
>2092	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0030					NSStatus:
>0030							.fill 	MathStackSize
.003c					NSMantissa0:
>003c							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0048					NSMantissa1:
>0048							.fill 	MathStackSize
.0054					NSMantissa2:
>0054							.fill 	MathStackSize
.0060					NSMantissa3:
>0060							.fill 	MathStackSize
.006c					NSExponent:
>006c							.fill 	MathStackSize
.0515					numberBuffer:
>0515							.fill 	34
.2093					FloatSubtract:
.2093	b5 30		lda $30,x			lda 	NSStatus,x 					; negate top of stack
.2095	49 80		eor #$80			eor 	#$80
.2097	95 30		sta $30,x			sta 	NSStatus,x					; and fall through.
.2099					FloatAdd:
.2099	ca		dex				dex
.209a	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised.
.209c	15 6d		ora $6d,x			ora 	NSExponent+1,x
.209e	15 60		ora $60,x			ora 	NSMantissa3,x
.20a0	15 61		ora $61,x			ora 	NSMantissa3+1,x
.20a2	d0 04		bne $20a8			bne 	_FAUseFloat
.20a4	20 35 24	jsr $2435			jsr 	FloatInt32Add 				; use the int32 one.
.20a7	60		rts				rts
.20a8					_FAUseFloat:
.20a8	20 ca 23	jsr $23ca			jsr 	FloatNormalise 				; normalise S[X]
.20ab	f0 51		beq $20fe			beq 	_FAReturn1
.20ad	e8		inx				inx 								; normalise S[X+1]
.20ae	20 ca 23	jsr $23ca			jsr 	FloatNormalise
.20b1	ca		dex				dex
.20b2	c9 00		cmp #$00			cmp 	#0
.20b4	f0 60		beq $2116			beq 	_FAExit 					; if so, just return A
.20b6	b5 6c		lda $6c,x			lda 	NSExponent,x 				; are the exponents the same ?
.20b8	d5 6d		cmp $6d,x			cmp 	NSExponent+1,x
.20ba	f0 18		beq $20d4			beq 	_FAExponentsEqual
.20bc	b5 6c		lda $6c,x			lda 	NSExponent,x 				; work out the larger exponent
.20be	a8		tay				tay
.20bf	38		sec				sec 								; do a signed comparison of the exponents.
.20c0	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.20c2	50 02		bvc $20c6			bvc 	_FANoSignedChange
.20c4	49 80		eor #$80			eor 	#$80
.20c6					_FANoSignedChange:
.20c6	29 80		and #$80			and 	#$80
.20c8	10 02		bpl $20cc			bpl 	_FAHaveMax
.20ca	b4 6d		ldy $6d,x			ldy 	NSExponent+1,x
.20cc					_FAHaveMax:
.20cc	20 17 21	jsr $2117			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20cf	e8		inx				inx
.20d0	20 17 21	jsr $2117			jsr 	_FAShiftToExponent
.20d3	ca		dex				dex
.20d4					_FAExponentsEqual:
.20d4	b5 30		lda $30,x			lda 	NSStatus,x 					; are the signs the same
.20d6	55 31		eor $31,x			eor 	NSStatus+1,x
.20d8	30 0e		bmi $20e8			bmi 	_FADifferentSigns
.20da	20 01 24	jsr $2401			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20dd	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20df	10 35		bpl $2116			bpl 	_FAExit 					; if no, we are done.
.20e1	20 8e 26	jsr $268e			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20e4	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump the exponent and exit
.20e6	80 2e		bra $2116			bra 	_FAExit
.20e8					_FADifferentSigns:
.20e8	20 1b 24	jsr $241b			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20eb	b5 60		lda $60,x			lda 	NSMantissa3,x 				; is the result negative ?
.20ed	10 06		bpl $20f5			bpl 	_FACheckZero 				; if no, check for -0
.20ef	20 37 26	jsr $2637			jsr 	FloatNegate 					; netate result
.20f2	20 3e 26	jsr $263e			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20f5					_FACheckZero:
.20f5	20 97 26	jsr $2697			jsr 	FloatIsZero	 				; check for -0
.20f8	d0 1c		bne $2116			bne 	_FAExit
.20fa	74 30		stz $30,x			stz 	NSStatus,x
.20fc	80 18		bra $2116			bra 	_FAExit
.20fe					_FAReturn1:
.20fe	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.2100	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2102	b5 49		lda $49,x			lda 	NSMantissa1+1,x
.2104	95 48		sta $48,x			sta 	NSMantissa1,x
.2106	b5 55		lda $55,x			lda 	NSMantissa2+1,x
.2108	95 54		sta $54,x			sta 	NSMantissa2,x
.210a	b5 61		lda $61,x			lda 	NSMantissa3+1,x
.210c	95 60		sta $60,x			sta 	NSMantissa3,x
.210e	b5 6d		lda $6d,x			lda 	NSExponent+1,x
.2110	95 6c		sta $6c,x			sta 	NSExponent,x
.2112	b5 31		lda $31,x			lda 	NSStatus+1,x
.2114	95 30		sta $30,x			sta 	NSStatus,x
.2116					_FAExit:
.2116	60		rts				rts
.2117					_FAShiftToExponent:
.2117					_FAShiftToExponent2:
.2117	98		tya				tya 								; compare Y to exponent
.2118	d5 6c		cmp $6c,x			cmp 	NSExponent,x 				; reached the exponent required ?
.211a	f0 07		beq $2123			beq 	_FASEExit 					; exit if so.
.211c	20 8e 26	jsr $268e			jsr 	FloatShiftRight	 			; shift the mantissa right
.211f	f6 6c		inc $6c,x			inc 	NSExponent,x 				; increment exponent
.2121	80 f4		bra $2117			bra 	_FAShiftToExponent2
.2123					_FASEExit:
.2123	60		rts				rts
.2124					CompareEqual:
.2124	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2126	d0 09		bne $2131			bne 	ReturnFalse
.2128					ReturnTrue:
.2128	a9 01		lda #$01			lda 	#1
.212a	95 3c		sta $3c,x			sta 	NSMantissa0,x
.212c	a9 80		lda #$80			lda 	#$80
.212e	95 30		sta $30,x			sta 	NSStatus,x
.2130	60		rts				rts
.2131					ReturnFalse:
.2131	74 3c		stz $3c,x			stz 	NSMantissa0,x
.2133	60		rts				rts
.2134					CompareNotEqual:
.2134	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2136	d0 f0		bne $2128			bne 	ReturnTrue
.2138	80 f7		bra $2131			bra 	ReturnFalse
.213a					CompareLess:
.213a	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.213c	c9 ff		cmp #$ff			cmp 	#$FF
.213e	f0 e8		beq $2128			beq 	ReturnTrue
.2140	80 ef		bra $2131			bra 	ReturnFalse
.2142					CompareGreater:
.2142	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2144	c9 01		cmp #$01			cmp 	#$01
.2146	f0 e0		beq $2128			beq 	ReturnTrue
.2148	80 e7		bra $2131			bra 	ReturnFalse
.214a					CompareLessEqual:
.214a	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.214c	c9 01		cmp #$01			cmp 	#$01
.214e	d0 d8		bne $2128			bne 	ReturnTrue
.2150	80 df		bra $2131			bra 	ReturnFalse
.2152					CompareGreaterEqual:
.2152	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2154	c9 ff		cmp #$ff			cmp 	#$FF
.2156	d0 d0		bne $2128			bne 	ReturnTrue
.2158	80 d7		bra $2131			bra 	ReturnFalse
.215a					FloatCompare:
.215a	b5 6c		lda $6c,x			lda 	NSExponent,x 				; float comparison.
.215c	15 6b		ora $6b,x			ora 	NSExponent-1,x 				; integer if both integer.
.215e	48		pha				pha
.215f	20 93 20	jsr $2093			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2162	68		pla				pla
.2163	d0 0c		bne $2171			bne 	_FCCompareFloat
.2165	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2167	15 48		ora $48,x			ora 	NSMantissa1,x
.2169	15 54		ora $54,x			ora 	NSMantissa2,x
.216b	15 60		ora $60,x			ora 	NSMantissa3,x
.216d	f0 14		beq $2183			beq 	_FCExit 					; if zero, return zero
.216f	80 0a		bra $217b			bra 	_FCSign
.2171					_FCCompareFloat:
.2171	b5 48		lda $48,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2173	29 f0		and #$f0			and 	#$F0
.2175	15 54		ora $54,x			ora 	NSMantissa2,x
.2177	15 60		ora $60,x			ora 	NSMantissa3,x
.2179	f0 08		beq $2183			beq 	_FCExit 					; zero, so approximately identical
.217b					_FCSign:
.217b	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.217d	34 30		bit $30,x			bit 	NSStatus,x
.217f	10 02		bpl $2183			bpl 	_FCExit
.2181					_FCNegative:
.2181	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2183					_FCExit:
.2183	20 77 26	jsr $2677			jsr 	FloatSetByte 				; set the result 255,0,1
.2186	60		rts				rts
.2187					FloatScalarTable:
>2187	66 66 66 66				.dword $66666666 ; 0.1
>218b	de					.byte $de
>218c	1f 85 eb 51				.dword $51eb851f ; 0.01
>2190	db					.byte $db
>2191	4c 37 89 41				.dword $4189374c ; 0.001
>2195	d8					.byte $d8
>2196	ac 8b db 68				.dword $68db8bac ; 0.0001
>219a	d4					.byte $d4
>219b	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>219f	d1					.byte $d1
>21a0	83 de 1b 43				.dword $431bde83 ; 1e-06
>21a4	ce					.byte $ce
>21a5	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21a9	ca					.byte $ca
>21aa	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21ae	c7					.byte $c7
>21af	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21b3	c4					.byte $c4
>21b4	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21b8	c0					.byte $c0
>21b9	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21bd	bd					.byte $bd
.21be					FloatDivide:
.21be	48		pha				pha
.21bf	20 ca 23	jsr $23ca			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21c2	ca		dex				dex
.21c3	c9 00		cmp #$00			cmp 	#0
.21c5	f0 1e		beq $21e5			beq 	_FDZero
.21c7	20 ca 23	jsr $23ca			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21ca	f0 16		beq $21e2			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21cc	20 2d 22	jsr $222d			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21cf	20 fa 21	jsr $21fa			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21d2	20 ca 23	jsr $23ca			jsr		FloatNormalise 				; renormalise
.21d5	20 c0 23	jsr $23c0			jsr 	FloatCalculateSign 			; calculate result sign
.21d8	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent
.21da	38		sec				sec
.21db	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.21dd	38		sec				sec
.21de	e9 1e		sbc #$1e			sbc 	#30
.21e0	95 6c		sta $6c,x			sta 	NSExponent,x
.21e2					_FDExit:
.21e2	68		pla				pla
.21e3	18		clc				clc
.21e4	60		rts				rts
.21e5					_FDZero:
.21e5	68		pla				pla
.21e6	38		sec				sec
.21e7	60		rts				rts
.21e8					DivideInt32:
.21e8	20 b0 22	jsr $22b0			jsr 	FloatIntegerPart 			; make both integers
.21eb	ca		dex				dex
.21ec	20 b0 22	jsr $22b0			jsr 	FloatIntegerPart
.21ef	20 0b 22	jsr $220b			jsr 	Int32Divide 				; divide
.21f2	20 fa 21	jsr $21fa			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21f5	20 c0 23	jsr $23c0			jsr 	FloatCalculateSign 			; calculate result sign
.21f8	18		clc				clc
.21f9	60		rts				rts
.21fa					NSMCopyPlusTwoToZero:
.21fa	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21fc	95 3c		sta $3c,x			sta 	NSMantissa0,x
.21fe	b5 4a		lda $4a,x			lda 	NSMantissa1+2,x
.2200	95 48		sta $48,x			sta 	NSMantissa1,x
.2202	b5 56		lda $56,x			lda 	NSMantissa2+2,x
.2204	95 54		sta $54,x			sta 	NSMantissa2,x
.2206	b5 62		lda $62,x			lda 	NSMantissa3+2,x
.2208	95 60		sta $60,x			sta 	NSMantissa3,x
.220a	60		rts				rts
.220b					Int32Divide:
.220b	48		pha				pha 								; save AXY
.220c	5a		phy				phy
.220d	20 58 26	jsr $2658			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2210	20 71 26	jsr $2671			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2213	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2215					_I32DivideLoop:
.2215	e8		inx				inx
.2216	e8		inx				inx
.2217	20 84 26	jsr $2684			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.221a	ca		dex				dex
.221b	ca		dex				dex
.221c	20 85 26	jsr $2685			jsr 	FloatRotateLeft
.221f	20 4b 22	jsr $224b			jsr 	FloatDivideCheck 			; check if subtract possible
.2222	90 02		bcc $2226			bcc 	_I32DivideNoCarryIn
.2224	f6 3e		inc $3e,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2226					_I32DivideNoCarryIn:
.2226	88		dey				dey 								; loop round till division completed.
.2227	d0 ec		bne $2215			bne 	_I32DivideLoop
.2229	7a		ply				ply 								; restore AXY and exit
.222a	68		pla				pla
.222b	18		clc				clc
.222c	60		rts				rts
.222d					Int32ShiftDivide:
.222d	48		pha				pha 								; save AY
.222e	5a		phy				phy
.222f	e8		inx				inx 								; clear S[X+2]
.2230	e8		inx				inx
.2231	20 75 26	jsr $2675			jsr 	FloatSetZero
.2234	ca		dex				dex
.2235	ca		dex				dex
.2236	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2238					_I32SDLoop:
.2238	20 4b 22	jsr $224b			jsr 	FloatDivideCheck 			; check if subtract possible
.223b	e8		inx				inx
.223c	e8		inx				inx
.223d	20 85 26	jsr $2685			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.2240	ca		dex				dex
.2241	ca		dex				dex
.2242	20 85 26	jsr $2685			jsr 	FloatRotateLeft
.2245	88		dey				dey 	 							; do 31 times
.2246	d0 f0		bne $2238			bne 	_I32SDLoop
.2248	7a		ply				ply 								; restore AY and exit
.2249	68		pla				pla
.224a	60		rts				rts
.224b					FloatDivideCheck:
.224b	20 1b 24	jsr $241b			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.224e	b0 04		bcs $2254			bcs 	_DCSExit 					; if carry set, then could do, exit
.2250	20 01 24	jsr $2401			jsr 	FloatAddTopTwoStack 		; add it back in
.2253	18		clc				clc 								; and return False
.2254					_DCSExit:
.2254	60		rts				rts
.2255					FloatFractionalPart:
.2255	5a		phy				phy
.2256	b5 30		lda $30,x			lda 	NSStatus,x 					; take absolute value
.2258	29 7f		and #$7f			and 	#$7F
.225a	95 30		sta $30,x			sta 	NSStatus,x
.225c	20 ca 23	jsr $23ca			jsr 	FloatNormalise
.225f	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2261	38		sec				sec
.2262	e9 e0		sbc #$e0			sbc 	#$E0
.2264	90 29		bcc $228f			bcc 	_FFPExit 					; already fractional
.2266	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2268	b0 22		bcs $228c			bcs 	_FFPZero
.226a	a8		tay				tay 								; put count to do in Y
.226b	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do each in turn.
.226d	20 94 22	jsr $2294			jsr 	_FFPPartial
.2270	95 60		sta $60,x			sta 	NSMantissa3,x
.2272	b5 54		lda $54,x			lda 	NSMantissa2,x
.2274	20 94 22	jsr $2294			jsr 	_FFPPartial
.2277	95 54		sta $54,x			sta 	NSMantissa2,x
.2279	b5 48		lda $48,x			lda 	NSMantissa1,x
.227b	20 94 22	jsr $2294			jsr 	_FFPPartial
.227e	95 48		sta $48,x			sta 	NSMantissa1,x
.2280	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2282	20 94 22	jsr $2294			jsr 	_FFPPartial
.2285	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2287	20 97 26	jsr $2697			jsr 	FloatIsZero 					; zeroed check.
.228a	d0 03		bne $228f			bne 	_FFPExit
.228c					_FFPZero:
.228c	20 75 26	jsr $2675			jsr 	FloatSetZero
.228f					_FFPExit:
.228f	20 ca 23	jsr $23ca			jsr 	FloatNormalise
.2292	7a		ply				ply
.2293	60		rts				rts
.2294					_FFPPartial:
.2294	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2296	f0 17		beq $22af			beq 	_FFFPPExit
.2298	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.229a	b0 0c		bcs $22a8			bcs 	_FFFPPWholeByte
.229c	5a		phy				phy
.229d					_FFFPPLeft:
.229d	0a		asl a				asl 	a
.229e	88		dey				dey
.229f	d0 fc		bne $229d			bne 	_FFFPPLeft
.22a1	7a		ply				ply
.22a2					_FFFPPRight:
.22a2	4a		lsr a				lsr 	a
.22a3	88		dey				dey
.22a4	d0 fc		bne $22a2			bne 	_FFFPPRight
.22a6	80 07		bra $22af			bra 	_FFFPPExit
.22a8					_FFFPPWholeByte:
.22a8	98		tya				tya 								; subtract 8 from count
.22a9	38		sec				sec
.22aa	e9 08		sbc #$08			sbc 	#8
.22ac	a8		tay				tay
.22ad	a9 00		lda #$00			lda 	#0 							; and clear all
.22af					_FFFPPExit:
.22af	60		rts				rts
.22b0					FloatIntegerPart:
.22b0	48		pha				pha
.22b1	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.22b3	f0 1d		beq $22d2			beq 	_FIPExit 					; if so do nothing
.22b5	20 97 26	jsr $2697			jsr 	FloatIsZero 				; is it zero ?
.22b8	f0 15		beq $22cf			beq 	_FIPZero 					; if so return zero.
.22ba	20 ca 23	jsr $23ca			jsr 	FloatNormalise 				; normalise
.22bd	f0 10		beq $22cf			beq 	_FIPZero 					; normalised to zero, exit zero
.22bf					_FIPShift:
.22bf	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22c1	10 07		bpl $22ca			bpl 	_FIPCheckZero
.22c3	20 8e 26	jsr $268e			jsr 	FloatShiftRight 			; shift mantissa right
.22c6	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.22c8	80 f5		bra $22bf			bra 	_FIPShift
.22ca					_FIPCheckZero:
.22ca	20 97 26	jsr $2697			jsr 	FloatIsZero 				; avoid -0 problem
.22cd	d0 03		bne $22d2			bne 	_FIPExit 					; set to zero if mantissa zero.
.22cf					_FIPZero:
.22cf	20 75 26	jsr $2675			jsr 	FloatSetZero
.22d2					_FIPExit:
.22d2	68		pla				pla
.22d3	60		rts				rts
.22d4					FloatIntegerPartDown:
.22d4	48		pha				pha
.22d5	5a		phy				phy
.22d6	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.22d8	f0 36		beq $2310			beq 	_FIPExit 					; if so do nothing
.22da	20 97 26	jsr $2697			jsr 	FloatIsZero 				; is it zero ?
.22dd	f0 2e		beq $230d			beq 	_FIPZero 					; if so return zero.
.22df	20 ca 23	jsr $23ca			jsr 	FloatNormalise 				; normalise
.22e2	f0 29		beq $230d			beq 	_FIPZero 					; normalised to zero, exit zero
.22e4	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22e6					_FIPShift:
.22e6	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22e8	10 0a		bpl $22f4			bpl 	_FIPCheckDown
.22ea	20 8e 26	jsr $268e			jsr 	FloatShiftRight 			; shift mantissa right
.22ed	90 01		bcc $22f0			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22ef	c8		iny				iny
.22f0					_FIPNoFrac:
.22f0	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.22f2	80 f2		bra $22e6			bra 	_FIPShift
.22f4					_FIPCheckDown:
.22f4	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22f6	f0 10		beq $2308			beq 	_FIPCheckZero
.22f8	34 30		bit $30,x			bit 	NSStatus,x 					; +ve
.22fa	10 0c		bpl $2308			bpl 	_FIPCheckZero
.22fc	e8		inx				inx 								; -ve so round *down*.
.22fd	a9 01		lda #$01			lda 	#1
.22ff	20 77 26	jsr $2677			jsr 	FloatSetByte
.2302	20 37 26	jsr $2637			jsr 	FloatNegate
.2305	20 99 20	jsr $2099			jsr 	FloatAdd
.2308					_FIPCheckZero:
.2308	20 97 26	jsr $2697			jsr 	FloatIsZero 				; avoid -0 problem
.230b	d0 03		bne $2310			bne 	_FIPExit 					; set to zero if mantissa zero.
.230d					_FIPZero:
.230d	20 75 26	jsr $2675			jsr 	FloatSetZero
.2310					_FIPExit:
.2310	7a		ply				ply
.2311	68		pla				pla
.2312	60		rts				rts
.2313					FloatInt8Multiply:
.2313	5a		phy				phy
.2314	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2316	a8		tay				tay
.2317	74 3c		stz $3c,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2319					_FI8MLoop:
.2319	98		tya				tya 								; shift right shifter right into carry
.231a	4a		lsr a				lsr 	a
.231b	a8		tay				tay
.231c	90 0d		bcc $232b			bcc 	_FI8MNoAdd
.231e	18		clc				clc
.231f	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2321	75 3d		adc $3d,x			adc 	NSMantissa0+1,x
.2323	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2325	b5 48		lda $48,x			lda 	NSMantissa1,x
.2327	75 49		adc $49,x			adc 	NSMantissa1+1,x
.2329	95 48		sta $48,x			sta 	NSMantissa1,x
.232b					_FI8MNoAdd:
.232b	16 3d		asl $3d,x			asl 	NSMantissa0+1,x 			; shift adder left
.232d	36 49		rol $49,x			rol 	NSMantissa1+1,x
.232f	c0 00		cpy #$00			cpy 	#0
.2331	d0 e6		bne $2319			bne 	_FI8MLoop 					; until right shifter zero.
.2333	7a		ply				ply
.2334	60		rts				rts
.2335					FloatMultiply:
.2335	ca		dex				dex
.2336	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised ?
.2338	15 6d		ora $6d,x			ora 	NSExponent+1,x
.233a	15 60		ora $60,x			ora 	NSMantissa3,x
.233c	15 61		ora $61,x			ora 	NSMantissa3+1,x
.233e	d0 21		bne $2361			bne 	_FMUseFloat
.2340	b5 30		lda $30,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2342	15 31		ora $31,x			ora 	NSStatus+1,x
.2344	29 80		and #$80			and 	#$80
.2346	15 60		ora $60,x			ora 	NSMantissa3,x
.2348	15 54		ora $54,x			ora 	NSMantissa2,x
.234a	15 48		ora $48,x			ora 	NSMantissa1,x
.234c	15 61		ora $61,x			ora 	NSMantissa3+1,x
.234e	15 55		ora $55,x			ora 	NSMantissa2+1,x
.2350	15 49		ora $49,x			ora 	NSMantissa1+1,x
.2352	d0 04		bne $2358			bne 	_FMInt32
.2354	20 13 23	jsr $2313			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2357	60		rts				rts
.2358					_FMInt32:
.2358	20 82 23	jsr $2382			jsr 	FloatMultiplyShort			; use the int32 one.
.235b	18		clc				clc 								; fix it up if gone out of range
.235c	75 6c		adc $6c,x			adc 	NSExponent,x
.235e	95 6c		sta $6c,x			sta 	NSExponent,x
.2360	60		rts				rts
.2361					_FMUseFloat:
.2361	20 ca 23	jsr $23ca			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2364	f0 18		beq $237e			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2366	e8		inx				inx
.2367	20 ca 23	jsr $23ca			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.236a	ca		dex				dex
.236b	c9 00		cmp #$00			cmp 	#0
.236d	f0 0c		beq $237b			beq 	_FDSetZero
.236f	20 82 23	jsr $2382			jsr 	FloatMultiplyShort 			; calculate the result.
.2372	75 6c		adc $6c,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2374	18		clc				clc
.2375	75 6d		adc $6d,x			adc 	NSExponent+1,x
.2377	95 6c		sta $6c,x			sta 	NSExponent,x
.2379	80 03		bra $237e			bra 	_FDExit
.237b					_FDSetZero:
.237b	20 75 26	jsr $2675			jsr 	FloatSetZero 				; return 0
.237e					_FDExit:
.237e	20 ca 23	jsr $23ca			jsr 	FloatNormalise 				; normalise the result
.2381	60		rts				rts
.2382					FloatMultiplyShort:
.2382	5a		phy				phy 								; save Y
.2383	20 58 26	jsr $2658			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2386	20 71 26	jsr $2671			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2389	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.238b					_I32MLoop:
.238b	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.238d	15 4a		ora $4a,x			ora 	NSMantissa1+2,x
.238f	15 56		ora $56,x			ora 	NSMantissa2+2,x
.2391	15 62		ora $62,x			ora 	NSMantissa3+2,x
.2393	f0 25		beq $23ba			beq 	_I32MExit 					; exit if zero
.2395	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2397	29 01		and #$01			and 	#1
.2399	f0 0d		beq $23a8			beq 	_I32MNoAdd
.239b	20 01 24	jsr $2401			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.239e	b5 60		lda $60,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.23a0	10 06		bpl $23a8			bpl 	_I32MNoAdd
.23a2					_I32ShiftRight:
.23a2	20 8e 26	jsr $268e			jsr 	FloatShiftRight 			; shift S[X] right
.23a5	c8		iny				iny 								; increment shift count
.23a6	80 09		bra $23b1			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23a8					_I32MNoAdd:
.23a8	34 61		bit $61,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23aa	70 f6		bvs $23a2			bvs 	_I32ShiftRight 				; instead.
.23ac	e8		inx				inx
.23ad	20 84 26	jsr $2684			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23b0	ca		dex				dex
.23b1					_I32MShiftUpper:
.23b1	e8		inx				inx 								; shift S[X+2] right
.23b2	e8		inx				inx
.23b3	20 8e 26	jsr $268e			jsr 	FloatShiftRight
.23b6	ca		dex				dex
.23b7	ca		dex				dex
.23b8	80 d1		bra $238b			bra 	_I32MLoop 					; try again.
.23ba					_I32MExit:
.23ba	20 c0 23	jsr $23c0			jsr 	FloatCalculateSign
.23bd	98		tya				tya 								; shift in A
.23be	7a		ply				ply 								; restore Y and exit
.23bf	60		rts				rts
.23c0					FloatCalculateSign:
.23c0	b5 30		lda $30,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23c2	16 30		asl $30,x			asl 	NSStatus,x 					; shift result left
.23c4	55 31		eor $31,x			eor 	NSStatus+1,x
.23c6	0a		asl a				asl 	a 							; shift bit 7 into carry
.23c7	76 30		ror $30,x			ror 	NSStatus,x 					; shift right into status byte.
.23c9	60		rts				rts
.23ca					FloatNormalise:
.23ca	20 97 26	jsr $2697			jsr 	FloatIsZero 				; if zero exit
.23cd	d0 07		bne $23d6			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23cf	16 30		asl $30,x			asl 	NSStatus,x 					; clear the sign bit.
.23d1	76 30		ror $30,x			ror 	NSStatus,x 					; (no -0)
.23d3	a9 00		lda #$00			lda 	#0 							; set Z flag
.23d5	60		rts				rts
.23d6					_NSNormaliseOptimise:
.23d6	b5 60		lda $60,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23d8	d0 19		bne $23f3			bne 	_NSNormaliseLoop
.23da	b5 54		lda $54,x			lda 	NSMantissa2,x 				; byte normalise
.23dc	30 15		bmi $23f3			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23de	95 60		sta $60,x			sta 	NSMantissa3,x
.23e0	b5 48		lda $48,x			lda 	NSMantissa1,x
.23e2	95 54		sta $54,x			sta 	NSMantissa2,x
.23e4	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.23e6	95 48		sta $48,x			sta 	NSMantissa1,x
.23e8	74 3c		stz $3c,x			stz 	NSMantissa0,x
.23ea	b5 6c		lda $6c,x			lda 	NSExponent,x
.23ec	38		sec				sec
.23ed	e9 08		sbc #$08			sbc 	#8
.23ef	95 6c		sta $6c,x			sta 	NSExponent,x
.23f1	80 e3		bra $23d6			bra 	_NSNormaliseOptimise
.23f3					_NSNormaliseLoop:
.23f3	34 60		bit $60,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23f5	70 07		bvs $23fe			bvs 	_NSNExit 					; exit if so with Z flag clear
.23f7	20 84 26	jsr $2684			jsr 	FloatShiftLeft 				; shift mantissa left
.23fa	d6 6c		dec $6c,x			dec 	NSExponent,x 				; adjust exponent
.23fc	80 f5		bra $23f3			bra 	_NSNormaliseLoop
.23fe					_NSNExit:
.23fe	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.2400	60		rts				rts
.2401					FloatAddTopTwoStack:
.2401	18		clc				clc
.2402	b5 3c		lda $3c,x			lda		NSMantissa0,x
.2404	75 3d		adc $3d,x			adc 		NSMantissa0+1,x
.2406	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2408	b5 48		lda $48,x			lda		NSMantissa1,x
.240a	75 49		adc $49,x			adc 		NSMantissa1+1,x
.240c	95 48		sta $48,x			sta 	NSMantissa1,x
.240e	b5 54		lda $54,x			lda		NSMantissa2,x
.2410	75 55		adc $55,x			adc 		NSMantissa2+1,x
.2412	95 54		sta $54,x			sta 	NSMantissa2,x
.2414	b5 60		lda $60,x			lda		NSMantissa3,x
.2416	75 61		adc $61,x			adc 		NSMantissa3+1,x
.2418	95 60		sta $60,x			sta 	NSMantissa3,x
.241a	60		rts				rts
.241b					FloatSubTopTwoStack:
.241b	38		sec				sec
.241c	b5 3c		lda $3c,x			lda		NSMantissa0,x
.241e	f5 3d		sbc $3d,x			sbc 		NSMantissa0+1,x
.2420	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2422	b5 48		lda $48,x			lda		NSMantissa1,x
.2424	f5 49		sbc $49,x			sbc 		NSMantissa1+1,x
.2426	95 48		sta $48,x			sta 	NSMantissa1,x
.2428	b5 54		lda $54,x			lda		NSMantissa2,x
.242a	f5 55		sbc $55,x			sbc 		NSMantissa2+1,x
.242c	95 54		sta $54,x			sta 	NSMantissa2,x
.242e	b5 60		lda $60,x			lda		NSMantissa3,x
.2430	f5 61		sbc $61,x			sbc 		NSMantissa3+1,x
.2432	95 60		sta $60,x			sta 	NSMantissa3,x
.2434	60		rts				rts
.2435					FloatInt32Add:
.2435	b5 30		lda $30,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2437	55 31		eor $31,x			eor 	NSStatus+1,x
.2439	30 04		bmi $243f			bmi 	_DiffSigns
.243b	20 01 24	jsr $2401			jsr		FloatAddTopTwoStack
.243e	60		rts				rts
.243f					_DiffSigns:
.243f	20 1b 24	jsr $241b			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2442	34 60		bit $60,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2444	10 07		bpl $244d			bpl 	_AddExit
.2446	b5 31		lda $31,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2448	95 30		sta $30,x			sta 	NSStatus,x
.244a	20 3e 26	jsr $263e			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.244d					_AddExit:
.244d	20 97 26	jsr $2697			jsr 	FloatIsZero 				; check for -0
.2450	d0 02		bne $2454			bne 	_AddNonZero
.2452	74 30		stz $30,x			stz 	NSStatus,x
.2454					_AddNonZero:
.2454	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2455					FloatEncodeStart:
.2455	38		sec				sec
.2456	80 01		bra $2459			bra 	FloatEncodeContinue+1
.2458					FloatEncodeContinue:
.2458	18		clc				clc
.2459					FloatEncode:
.2459	08		php				php 								; save reset flag.
.245a	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.245c	f0 15		beq $2473			beq 	_ENIsOkay
.245e	c9 30		cmp #$30			cmp 	#"0"
.2460	90 04		bcc $2466			bcc 	_ENBadNumber
.2462	c9 3a		cmp #$3a			cmp 	#"9"+1
.2464	90 0d		bcc $2473			bcc 	_ENIsOkay
.2466					_ENBadNumber:
.2466	28		plp				plp 								; throw saved reset
.2467	ad 37 05	lda $0537			lda 	encodeState 				; if in decimal mode, construct final number
.246a	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.246c	d0 03		bne $2471			bne 	_ENFail
.246e	4c eb 24	jmp $24eb			jmp 	_ENConstructFinal
.2471					_ENFail:
.2471	18		clc				clc 								; not allowed
.2472	60		rts				rts
.2473					_ENIsOkay:
.2473	28		plp				plp 								; are we restarting
.2474	90 15		bcc $248b			bcc 	_ENNoRestart
.2476					_ENStartEncode:
.2476	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2478	f0 0c		beq $2486			beq 	_ENFirstDP
.247a	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.247c	20 77 26	jsr $2677			jsr 	FloatSetByte 				; in single byte mode.
.247f	a9 01		lda #$01			lda 	#ESTA_Low
.2481					_ENExitChange:
.2481	8d 37 05	sta $0537			sta 	encodeState 				; save new state
.2484	38		sec				sec
.2485	60		rts				rts
.2486					_ENFirstDP:
.2486	20 75 26	jsr $2675			jsr 	FloatSetZero 				; clear integer part
.2489	80 3c		bra $24c7			bra 	_ESTASwitchFloat			; go straight to float and exi
.248b					_ENNoRestart:
.248b	48		pha				pha 								; save digit or DP on stack.
.248c	ad 37 05	lda $0537			lda 	encodeState 				; get current state
.248f	c9 01		cmp #$01			cmp 	#ESTA_Low
.2491	f0 09		beq $249c			beq  	_ESTALowState
.2493	c9 02		cmp #$02			cmp 	#ESTA_High
.2495	f0 26		beq $24bd			beq 	_ESTAHighState
.2497	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2499	f0 38		beq $24d3			beq 	_ESTADecimalState
>249b	db						.byte 	$DB 						; causes a break in the emulator
.249c					_ESTALowState:
.249c	68		pla				pla 								; get value back
.249d	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.249f	f0 26		beq $24c7			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24a1	29 0f		and #$0f			and 	#15 						; make digit
.24a3	8d 38 05	sta $0538			sta 	digitTemp 					; save it.
.24a6	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24a8	0a		asl a				asl 	a
.24a9	0a		asl a				asl 	a
.24aa	75 3c		adc $3c,x			adc 	NSMantissa0,x
.24ac	0a		asl a				asl 	a
.24ad	6d 38 05	adc $0538			adc 	digitTemp
.24b0	95 3c		sta $3c,x			sta 	NSMantissa0,x
.24b2	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24b4	90 05		bcc $24bb			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24b6	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24b8	8d 37 05	sta $0537			sta 	encodeState
.24bb					_ESTANoSwitch:
.24bb	38		sec				sec
.24bc	60		rts				rts
.24bd					_ESTAHighState:
.24bd	68		pla				pla 								; get value back
.24be	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24c0	f0 05		beq $24c7			beq 	_ESTASwitchFloat
.24c2	20 1d 25	jsr $251d			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24c5	38		sec				sec
.24c6	60		rts				rts
.24c7					_ESTASwitchFloat:
.24c7	9c 39 05	stz $0539			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24ca	e8		inx				inx 								; zero the decimal additive.
.24cb	20 75 26	jsr $2675			jsr 	FloatSetZero
.24ce	ca		dex				dex
.24cf	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24d1	80 ae		bra $2481			bra 	_ENExitChange
.24d3					_ESTADecimalState:
.24d3	68		pla				pla 								; digit.
.24d4	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24d6	f0 99		beq $2471			beq 	_ENFail
.24d8	e8		inx				inx 								; put digit into fractional part of X+1
.24d9	20 1d 25	jsr $251d			jsr 	ESTAShiftDigitIntoMantissa
.24dc	ca		dex				dex
.24dd	ee 39 05	inc $0539			inc 	decimalCount 				; bump the count of decimals
.24e0	ad 39 05	lda $0539			lda 	decimalCount 				; too many decimal digits.
.24e3	c9 0b		cmp #$0b			cmp 	#11
.24e5	f0 02		beq $24e9			beq 	_ESTADSFail
.24e7	38		sec				sec
.24e8	60		rts				rts
.24e9					_ESTADSFail:
.24e9	18		clc				clc
.24ea	60		rts				rts
.24eb					_ENConstructFinal:
.24eb	ad 39 05	lda $0539			lda 	decimalCount 				; get decimal count
.24ee	f0 2b		beq $251b			beq 	_ENCFExit 					; no decimals
.24f0	5a		phy				phy
.24f1	0a		asl a				asl 	a 							; x 4 and CLC
.24f2	0a		asl a				asl 	a
.24f3	6d 39 05	adc $0539			adc 	decimalCount
.24f6	a8		tay				tay
.24f7	b9 82 21	lda $2182,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24fa	95 3e		sta $3e,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24fc	b9 83 21	lda $2183,y			lda 	FloatScalarTable-5+1,y
.24ff	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.2501	b9 84 21	lda $2184,y			lda 	FloatScalarTable-5+2,y
.2504	95 56		sta $56,x			sta 	NSMantissa2+2,x
.2506	b9 85 21	lda $2185,y			lda 	FloatScalarTable-5+3,y
.2509	95 62		sta $62,x			sta 	NSMantissa3+2,x
.250b	b9 86 21	lda $2186,y			lda 	FloatScalarTable-5+4,y
.250e	95 6e		sta $6e,x			sta 	NSExponent+2,x
.2510	74 32		stz $32,x			stz 	NSStatus+2,x 				; make +ve
.2512	e8		inx				inx 								; multiply decimal const by decimal scalar
.2513	e8		inx				inx
.2514	20 35 23	jsr $2335			jsr 	FloatMultiply
.2517	20 99 20	jsr $2099			jsr 	FloatAdd 					; add to integer part.
.251a	7a		ply				ply
.251b					_ENCFExit:
.251b	18		clc				clc 								; reject the digit.
.251c	60		rts				rts
.251d					ESTAShiftDigitIntoMantissa:
.251d	29 0f		and #$0f			and 	#15 						; save digit
.251f	48		pha				pha
.2520	b5 60		lda $60,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2522	48		pha				pha
.2523	b5 54		lda $54,x			lda 	NSMantissa2,x
.2525	48		pha				pha
.2526	b5 48		lda $48,x			lda 	NSMantissa1,x
.2528	48		pha				pha
.2529	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.252b	48		pha				pha
.252c	20 84 26	jsr $2684			jsr 	FloatShiftLeft 				; x 2
.252f	20 84 26	jsr $2684			jsr 	FloatShiftLeft 				; x 4
.2532	18		clc				clc 								; pop mantissa and add
.2533	68		pla				pla
.2534	75 3c		adc $3c,x			adc 	NSMantissa0,x
.2536	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2538	68		pla				pla
.2539	75 48		adc $48,x			adc 	NSMantissa1,x
.253b	95 48		sta $48,x			sta 	NSMantissa1,x
.253d	68		pla				pla
.253e	75 54		adc $54,x			adc 	NSMantissa2,x
.2540	95 54		sta $54,x			sta 	NSMantissa2,x
.2542	68		pla				pla
.2543	75 60		adc $60,x			adc 	NSMantissa3,x
.2545	95 60		sta $60,x			sta 	NSMantissa3,x 				; x 5
.2547	20 84 26	jsr $2684			jsr 	FloatShiftLeft 				; x 10
.254a	68		pla				pla 								; add digit
.254b	18		clc				clc
.254c	75 3c		adc $3c,x			adc 	NSMantissa0,x
.254e	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2550	90 0a		bcc $255c			bcc 	_ESTASDExit
.2552	f6 48		inc $48,x			inc 	NSMantissa1,x
.2554	d0 06		bne $255c			bne 	_ESTASDExit
.2556	f6 54		inc $54,x			inc 	NSMantissa2,x
.2558	d0 02		bne $255c			bne 	_ESTASDExit
.255a	f6 60		inc $60,x			inc 	NSMantissa3,x
.255c					_ESTASDExit:
.255c	60		rts				rts
.0537					encodeState:
>0537							.fill 	1
.0538					digitTemp:
>0538							.fill 	1
.0539					decimalCount:
>0539							.fill 	1
.255d					FloatToString:
.255d	da		phx				phx
.255e	5a		phy				phy 								; save code position
.255f	8d 3a 05	sta $053a			sta 	decimalPlaces	 			; save number of DPs.
.2562	9c 3b 05	stz $053b			stz 	dbOffset 					; offset into decimal buffer = start.
.2565	b5 30		lda $30,x			lda 	NSStatus,x  				; is it -ve.
.2567	10 08		bpl $2571			bpl 	_CNTSNotNegative
.2569	29 7f		and #$7f			and 	#$7F 						; make +ve
.256b	95 30		sta $30,x			sta 	NSStatus,x
.256d	a9 2d		lda #$2d			lda 	#"-"
.256f	80 02		bra $2573			bra 	_CNTMain
.2571					_CNTSNotNegative:
.2571	a9 20		lda #$20			lda 	#" "
.2573					_CNTMain:
.2573	20 d5 25	jsr $25d5			jsr 	WriteDecimalBuffer
.2576	b5 6c		lda $6c,x			lda 	NSExponent,x 				; check if decimal
.2578	f0 0d		beq $2587			beq 	_CNTSNotFloat
.257a	e8		inx				inx 								; round up so we don't get too many 6.999999
.257b	a9 01		lda #$01			lda 	#1
.257d	20 77 26	jsr $2677			jsr 	FloatSetByte
.2580	b5 6b		lda $6b,x			lda		NSExponent-1,x
.2582	95 6c		sta $6c,x			sta 	NSExponent,x
.2584	20 99 20	jsr $2099			jsr 	FloatAdd
.2587					_CNTSNotFloat:
.2587	20 b7 25	jsr $25b7			jsr 	MakePlusTwoString 			; do the integer part.
.258a	20 55 22	jsr $2255			jsr 	FloatFractionalPart 		; get the fractional part
.258d	20 ca 23	jsr $23ca			jsr 	FloatNormalise					; normalise , exit if zero
.2590	f0 22		beq $25b4			beq 	_CNTSExit
.2592	a9 2e		lda #$2e			lda 	#"."
.2594	20 d5 25	jsr $25d5			jsr 	WriteDecimalBuffer 			; write decimal place
.2597					_CNTSDecimal:
.2597	ce 3a 05	dec $053a			dec 	decimalPlaces 				; done all the decimals
.259a	30 18		bmi $25b4			bmi 	_CNTSExit
.259c	e8		inx				inx 								; x 10.0
.259d	a9 0a		lda #$0a			lda 	#10
.259f	20 77 26	jsr $2677			jsr 	FloatSetByte
.25a2	20 35 23	jsr $2335			jsr 	FloatMultiply
.25a5	20 b7 25	jsr $25b7			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25a8	20 55 22	jsr $2255			jsr 	FloatFractionalPart 		; get the fractional part
.25ab	20 ca 23	jsr $23ca			jsr 	FloatNormalise 				; normalise it.
.25ae	b5 6c		lda $6c,x			lda 	NSExponent,x 				; gone to zero, exit.
.25b0	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25b2	b0 e3		bcs $2597			bcs 	_CNTSDecimal 				; keep going.
.25b4					_CNTSExit:
.25b4	7a		ply				ply
.25b5	fa		plx				plx
.25b6	60		rts				rts
.25b7					MakePlusTwoString:
.25b7	da		phx				phx
.25b8	20 58 26	jsr $2658			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25bb	e8		inx				inx 								; access it
.25bc	e8		inx				inx
.25bd	20 b0 22	jsr $22b0			jsr 	FloatIntegerPart 			; make it an integer
.25c0	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25c2	20 f4 25	jsr $25f4			jsr 	ConvertInt32
.25c5	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25c7					_MPTSCopy:
.25c7	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25ca	20 d5 25	jsr $25d5			jsr 	WriteDecimalBuffer
.25cd	e8		inx				inx
.25ce	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25d1	d0 f4		bne $25c7			bne 	_MPTSCopy
.25d3	fa		plx				plx
.25d4	60		rts				rts
.25d5					WriteDecimalBuffer:
.25d5	da		phx				phx
.25d6	ae 3b 05	ldx $053b			ldx 	dbOffset
.25d9	9d 3c 05	sta $053c,x			sta 	decimalBuffer,x
.25dc	9e 3d 05	stz $053d,x			stz 	decimalBuffer+1,x
.25df	ee 3b 05	inc $053b			inc 	dbOffset
.25e2	fa		plx				plx
.25e3	60		rts				rts
.053a					decimalPlaces:
>053a							.fill 	1
.053b					dbOffset:
>053b							.fill 	1
.053c					decimalBuffer:
>053c							.fill 	32
.25e4					ConvertInt16:
.25e4	85 3c		sta $3c				sta 	NSMantissa0 				; set up as 32 bit conversion
.25e6	86 48		stx $48				stx 	NSMantissa1
.25e8	64 54		stz $54				stz 	NSMantissa2
.25ea	64 60		stz $60				stz 	NSMantissa3
.25ec	64 30		stz $30				stz 	NSStatus 					; positive integer
.25ee	a2 00		ldx #$00			ldx 	#0 							; stack level
.25f0	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25f2	80 00		bra $25f4			bra 	ConvertInt32
.25f4					ConvertInt32:
.25f4	5a		phy				phy
.25f5	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25f7	24 30		bit $30				bit 	NSStatus 					; output a - if not negative.
.25f9	10 08		bpl $2603			bpl 	_CI32NotNeg
.25fb	48		pha				pha
.25fc	a9 2d		lda #$2d			lda 	#'-'
.25fe	99 15 05	sta $0515,y			sta 	numberBuffer,y
.2601	c8		iny				iny
.2602	68		pla				pla
.2603					_CI32NotNeg:
.2603	20 11 26	jsr $2611			jsr 	_CI32DivideConvert 			; recursive conversion
.2606	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2608	99 15 05	sta $0515,y			sta 	numberBuffer,y
.260b	7a		ply				ply
.260c	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.260e	a9 15		lda #$15			lda 	#numberBuffer & $FF
.2610	60		rts				rts
.2611					_CI32DivideConvert:
.2611	e8		inx				inx 								; write to next slot up
.2612	20 77 26	jsr $2677			jsr 	FloatSetByte 		 		; write the base out.
.2615	ca		dex				dex
.2616	20 0b 22	jsr $220b			jsr 	Int32Divide 				; divide
.2619	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; save remainder
.261b	48		pha				pha
.261c	20 fa 21	jsr $21fa			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.261f	20 97 26	jsr $2697			jsr 	FloatIsZero 				; is it zero ?
.2622	f0 05		beq $2629			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2624	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2626	20 11 26	jsr $2611			jsr 	_CI32DivideConvert 			; and recusrively call.
.2629					_CI32NoRecurse:
.2629	68		pla				pla 								; remainder
.262a	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.262c	90 02		bcc $2630			bcc 	_CI32NotHex
.262e	69 26		adc #$26			adc 	#6+32
.2630					_CI32NotHex:
.2630	69 30		adc #$30			adc 	#48
.2632	99 15 05	sta $0515,y			sta 	numberBuffer,y 				; write out and exit
.2635	c8		iny				iny
.2636	60		rts				rts
.2637					FloatNegate:
.2637	b5 30		lda $30,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2639	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.263b	95 30		sta $30,x			sta 	NSStatus,x
.263d	60		rts				rts
.263e					FloatNegateMantissa:
.263e	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.263f	a9 00		lda #$00			lda 	#0
.2641	f5 3c		sbc $3c,x			sbc 	NSMantissa0,x
.2643	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2645	a9 00		lda #$00			lda 	#0
.2647	f5 48		sbc $48,x			sbc 	NSMantissa1,x
.2649	95 48		sta $48,x			sta 	NSMantissa1,x
.264b	a9 00		lda #$00			lda 	#0
.264d	f5 54		sbc $54,x			sbc 	NSMantissa2,x
.264f	95 54		sta $54,x			sta 	NSMantissa2,x
.2651	a9 00		lda #$00			lda 	#0
.2653	f5 60		sbc $60,x			sbc 	NSMantissa3,x
.2655	95 60		sta $60,x			sta 	NSMantissa3,x
.2657	60		rts				rts
.2658					FloatShiftUpTwo:
.2658	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.265a	95 3e		sta $3e,x			sta 	NSMantissa0+2,x
.265c	b5 48		lda $48,x			lda 	NSMantissa1,x
.265e	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.2660	b5 54		lda $54,x			lda 	NSMantissa2,x
.2662	95 56		sta $56,x			sta 	NSMantissa2+2,x
.2664	b5 60		lda $60,x			lda 	NSMantissa3,x
.2666	95 62		sta $62,x			sta 	NSMantissa3+2,x
.2668	b5 6c		lda $6c,x			lda 	NSExponent,x
.266a	95 6e		sta $6e,x			sta 	NSExponent+2,x
.266c	b5 30		lda $30,x			lda 	NSStatus,x
.266e	95 32		sta $32,x			sta 	NSStatus+2,x
.2670	60		rts				rts
.2671					FloatSetZeroMantissaOnly:
.2671	74 3c		stz $3c,x			stz 	NSMantissa0,x
.2673	80 08		bra $267d			bra 	FloatZero13
.2675					FloatSetZero:
.2675	a9 00		lda #$00			lda 	#0
.2677					FloatSetByte:
.2677	74 6c		stz $6c,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2679					FloatSetMantissa:
.2679	95 3c		sta $3c,x			sta 	NSMantissa0,x 				; zero mantissa
.267b	74 30		stz $30,x			stz 	NSStatus,x
.267d					FloatZero13:
.267d	74 48		stz $48,x			stz 	NSMantissa1,x
.267f	74 54		stz $54,x			stz 	NSMantissa2,x
.2681	74 60		stz $60,x			stz 	NSMantissa3,x
.2683	60		rts				rts
.2684					FloatShiftLeft:
.2684	18		clc				clc
.2685					FloatRotateLeft:
.2685	36 3c		rol $3c,x			rol 	NSMantissa0,x
.2687	36 48		rol $48,x			rol		NSMantissa1,x
.2689	36 54		rol $54,x			rol		NSMantissa2,x
.268b	36 60		rol $60,x			rol		NSMantissa3,x
.268d	60		rts				rts
.268e					FloatShiftRight:
.268e	56 60		lsr $60,x			lsr 	NSMantissa3,x
.2690	76 54		ror $54,x			ror		NSMantissa2,x
.2692	76 48		ror $48,x			ror		NSMantissa1,x
.2694	76 3c		ror $3c,x			ror		NSMantissa0,x
.2696	60		rts				rts
.2697					FloatIsZero:
.2697	b5 60		lda $60,x			lda 	NSMantissa3,x
.2699	15 54		ora $54,x			ora		NSMantissa2,x
.269b	15 48		ora $48,x			ora		NSMantissa1,x
.269d	15 3c		ora $3c,x			ora		NSMantissa0,x
.269f	60		rts				rts

;******  Processing input file: testing/testend.asm

.26a0					EndProgram:
>26a0	01 08 0c 08 0a 00 4e 20				.binary "code/tokenised.dat"
>26a8	b2 20 31 34 00 15 08 14 00 ce 86 20 33 00 32 08
>26b8	3c 00 99 20 c7 28 31 34 37 29 3b 22 48 45 4c 4c
>26c8	4f 20 57 4f 52 4c 44 20 21 22 00 4e 08 46 00 86
>26d8	20 42 58 28 4e 29 3a 86 20 42 59 28 4e 29 3a 86
>26e8	20 42 43 28 4e 29 00 62 08 4b 00 86 20 44 58 28
>26f8	4e 29 3a 86 20 44 59 28 4e 29 00 70 08 50 00 81
>2708	20 42 b2 30 20 a4 20 4e 00 89 08 5a 00 42 58 28
>2718	42 29 b2 b5 28 bb 28 31 29 ac 34 30 29 ac 32 aa
>2728	31 00 a2 08 64 00 42 59 28 42 29 b2 b5 28 bb 28
>2738	31 29 ac 33 30 29 ac 32 35 36 00 b9 08 69 00 42
>2748	43 28 42 29 b2 b5 28 bb 28 31 29 ac 31 34 29 aa
>2758	31 00 cd 08 6a 00 44 58 28 42 29 b2 b5 28 bb 28
>2768	31 29 ac 32 29 00 e3 08 6c 00 8f 20 44 59 28 42
>2778	29 b2 b5 28 bb 28 31 29 ac 32 29 00 ef 08 6d 00
>2788	44 59 28 42 29 b2 31 00 f7 08 6e 00 82 20 42 00
>2798	fd 08 78 00 8f 00 11 09 82 00 81 59 b2 30 a4 32
>27a8	39 3a 81 58 b2 30 a4 33 39 00 27 09 8c 00 51 b2
>27b8	59 ac 32 35 36 aa 58 ac 32 aa 34 35 30 35 36 00
>27c8	3f 09 96 00 ce 84 20 31 2c 51 2c 38 31 3a ce 84
>27d8	31 2c 51 aa 31 2c 30 00 48 09 a0 00 82 58 2c 59
>27e8	00 54 09 c8 00 81 20 42 b2 31 a4 4e 00 71 09 d2
>27f8	00 ce 84 20 31 2c 34 35 30 35 36 aa 42 59 28 42
>2808	29 aa 42 58 28 42 29 2c 30 00 7f 09 e6 00 44 58
>2818	42 b2 44 58 28 42 29 00 90 09 f0 00 8b 44 58 42
>2828	b2 30 a7 8d 31 30 31 30 00 a1 09 fa 00 8b 44 58
>2838	42 b2 31 a7 8d 31 30 34 30 00 af 09 ff 00 44 59
>2848	42 b2 44 59 28 42 29 00 c0 09 04 01 8b 44 59 42
>2858	b2 30 a7 8d 31 30 37 30 00 d1 09 0e 01 8b 44 59
>2868	42 b2 31 a7 8d 31 31 30 30 00 f2 09 18 01 ce 84
>2878	20 31 2c 34 35 30 35 36 aa 42 59 28 42 29 aa 42
>2888	58 28 42 29 2c 42 43 28 42 29 00 f9 09 22 01 82
>2898	42 00 03 0a 2c 01 89 20 32 30 30 00 09 0a e8 03
>28a8	8f 00 17 0a f2 03 42 58 42 b2 42 58 28 42 29 00
>28b8	2c 0a f3 03 8b 42 58 42 b2 31 a7 44 58 28 42 29
>28c8	b2 31 3a 8e 00 3e 0a fc 03 42 58 28 42 29 b2 42
>28d8	58 42 ab 32 3a 8e 00 44 0a 06 04 8f 00 52 0a 10
>28e8	04 42 58 42 b2 42 58 28 42 29 00 72 0a 11 04 8b
>28f8	42 58 42 b2 37 39 a7 20 42 58 28 42 29 b2 37 37
>2908	3a 44 58 28 42 29 b2 30 3a 8e 00 84 0a 1a 04 42
>2918	58 28 42 29 b2 42 58 42 aa 32 3a 8e 00 8a 0a 24
>2928	04 8f 00 98 0a 2e 04 42 59 42 b2 42 59 28 42 29
>2938	00 ad 0a 2f 04 8b 42 59 42 b2 30 a7 44 59 28 42
>2948	29 b2 31 3a 8e 00 c1 0a 38 04 42 59 28 42 29 b2
>2958	42 59 42 ab 32 35 36 3a 8e 00 c7 0a 42 04 8f 00
>2968	d5 0a 4c 04 42 59 42 b2 42 59 28 42 29 00 f8 0a
>2978	4d 04 8b 42 59 42 b2 37 34 32 34 a7 42 59 28 42
>2988	29 b2 37 31 36 38 3a 44 59 28 42 29 b2 30 3a 8e
>2998	00 0c 0b 56 04 42 59 28 42 29 b2 42 59 42 aa 32
>29a8	35 36 3a 8e 00 00 00

;******  End of listing
