
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl /home/paulr/Projects/blitz-compiler/documents/../source/common-source/wrapper.asm testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Fri Oct  6 17:09:03 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../source/common-source/wrapper.asm

=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.1000	4c 03 10	jmp $1003			jmp 	WrapperBoot
.0022					codePtr:
>0022							.fill 	2
.0024					codePage:
>0024							.fill 	1
.0025					objPtr:
>0025							.fill 	2
.0027					objPage:
>0027							.fill 	1
.0028					zTemp0:
>0028							.fill 	2
.002a					zTemp1:
>002a							.fill 	2
.002c					zTemp2:
>002c							.fill 	2

;******  Processing input file: testing/testing.asm

.1003					WrapperBoot:
.1003	a2 0e		ldx #$0e			ldx 	#APIDesc & $FF
.1005	a0 10		ldy #$10			ldy 	#APIDesc >> 8
.1007	20 b1 10	jsr $10b1			jsr 	StartCompiler
.100a	4c ff ff	jmp $ffff			jmp 	$FFFF
.100d	60		rts				rts
.100e					APIDesc:
>100e							.fill 	2
>1010	80						.byte 	$80
>1011	9f						.byte 	$9F

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
.002e					srcPtr:
>002e							.fill 	2
.0400					sourceBuffer:
>0400							.fill 	256
.0500					currentLineNumber:
>0500							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
=$4000					PCodeStart = $4000
=$8000					WorkArea = $8000
=$1f00					WorkAreaSize = $1F00
.1012					InlineNonDecimal:
.1012	a2 02		ldx #$02			ldx 	#2 							; get size in X
.1014	c9 25		cmp #$25			cmp 	#"%"
.1016	f0 02		beq $101a			beq 	_INDBinary
.1018	a2 10		ldx #$10			ldx 	#16
.101a					_INDBinary:
.101a	85 2a		sta $2a				sta 	zTemp1 						; size => zTemp1
.101c	64 2b		stz $2b				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.101e	64 28		stz $28				stz 	zTemp0 						; zero result
.1020	64 29		stz $29				stz 	zTemp0+1
.1022					_INDLoop:
.1022	20 13 1b	jsr $1b13			jsr 	LookNext 					; check next character
.1025	20 4f 1b	jsr $1b4f			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.1028	90 1f		bcc $1049			bcc		_INDDone 					; didn't convert
.102a	c5 2a		cmp $2a				cmp 	zTemp1 						; size too large ?
.102c	b0 1b		bcs $1049			bcs 	_INDDone
.102e	20 58 10	jsr $1058			jsr 	_INDShift 					; x 2 or x 16
.1031	e0 02		cpx #$02			cpx 	#2
.1033	f0 09		beq $103e			beq 	_INDNotHex
.1035	20 58 10	jsr $1058			jsr 	_INDShift
.1038	20 58 10	jsr $1058			jsr 	_INDShift
.103b	20 58 10	jsr $1058			jsr 	_INDShift
.103e					_INDNotHex:
.103e	05 28		ora $28				ora 	zTemp0 						; or digit into result
.1040	85 28		sta $28				sta 	zTemp0
.1042	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume
.1045	e6 2b		inc $2b				inc 	zTemp1+1 					; bump count
.1047	80 d9		bra $1022			bra 	_INDLoop
.1049					_INDDone:
.1049	a5 2b		lda $2b				lda 	zTemp1+1 					; done at least 1 ?
.104b	f0 08		beq $1055			beq 	_INDError
.104d	a4 29		ldy $29				ldy 	zTemp0+1 					; push constant
.104f	a5 28		lda $28				lda 	zTemp0
.1051	20 39 11	jsr $1139			jsr 	PushIntegerYA
.1054	60		rts				rts
.1055					_INDError:
.1055	4c 5a 13	jmp $135a		jmp	ErrorV_syntax
.1058					_INDShift:
.1058	06 28		asl $28				asl 	zTemp0
.105a	26 29		rol $29				rol 	zTemp0+1
.105c	60		rts				rts
.105d					BufferClear:
.105d	9c 02 05	stz $0502			stz 	bufferSize
.1060	60		rts				rts
.1061					BufferWrite:
.1061	da		phx				phx
.1062	ae 02 05	ldx $0502			ldx 	bufferSize
.1065	9d 03 05	sta $0503,x			sta 	dataBuffer,x
.1068	ee 02 05	inc $0502			inc 	bufferSize
.106b	fa		plx				plx
.106c	60		rts				rts
.106d					BufferOutput:
.106d	ad 02 05	lda $0502			lda 	bufferSize
.1070	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1073	a2 00		ldx #$00			ldx 	#0
.1075					_BOLoop:
.1075	ec 02 05	cpx $0502			cpx 	bufferSize
.1078	f0 09		beq $1083			beq 	_BOExit
.107a	bd 03 05	lda $0503,x			lda 	dataBuffer,x
.107d	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1080	e8		inx				inx
.1081	80 f2		bra $1075			bra 	_BOLoop
.1083					_BOExit:
.1083	60		rts				rts
.0502					bufferSize:
>0502							.fill 	1
.0503					dataBuffer:
>0503							.fill 	256
.1084					WriteCodeByte:
.1084	48		pha				pha 								; save on stack
.1085	da		phx				phx
.1086	5a		phy				phy
.1087	20 f8 1f	jsr $1ff8			jsr 	OUTPUTWriteByte
.108a	7a		ply				ply 								; restore from stack
.108b	fa		plx				plx
.108c	68		pla				pla
.108d	60		rts				rts
.108e					CheckNextComma:
.108e	a9 2c		lda #$2c			lda	 	#","
.1090	80 06		bra $1098			bra 	CheckNextA
.1092					CheckNextRParen:
.1092	a9 29		lda #$29			lda	 	#")"
.1094	80 02		bra $1098			bra 	CheckNextA
.1096					CheckNextLParen:
.1096	a9 28		lda #$28			lda 	#"("
.1098					CheckNextA:
.1098	8d 03 06	sta $0603			sta 	checkCharacter 				; save test character
.109b					_CNALoop:
.109b	20 2f 1b	jsr $1b2f			jsr 	GetNextNonSpace 			; get next skipping spaces.
.109e	cd 03 06	cmp $0603			cmp 	checkCharacter 				; matches ?
.10a1	f0 03		beq $10a6			beq 	_CNAExit
.10a3	4c 5a 13	jmp $135a		jmp	ErrorV_syntax
.10a6					_CNAExit:
.10a6	60		rts				rts
.0603					checkCharacter:
>0603							.fill 	1
.10a7					OUTPUTClose:
.10a7	a9 40		lda #$40			lda 	#(PCodeStart >> 8)
.10a9	a6 25		ldx $25				ldx 	objPtr
.10ab	a4 26		ldy $26				ldy 	objPtr+1
.10ad	20 62 20	jsr $2062			jsr 	XSaveMemory
.10b0	60		rts				rts
.10b1					StartCompiler:
.10b1	86 28		stx $28				stx 	zTemp0 						; access API
.10b3	84 29		sty $29				sty 	zTemp0+1
>10b5	db						.byte 	$DB 						; causes a break in the emulator
.10b6	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.10b8	b2 28		lda ($28)			lda 	(zTemp0)
.10ba	8d 05 06	sta $0605			sta 	APIVector
.10bd	b1 28		lda ($28),y			lda 	(zTemp0),y
.10bf	8d 06 06	sta $0606			sta 	APIVector+1
.10c2	c8		iny				iny 								; copy data area range.
.10c3	b1 28		lda ($28),y			lda 	(zTemp0),y
.10c5	8d 07 06	sta $0607			sta 	compilerStartLow
.10c8	c8		iny				iny
.10c9	b1 28		lda ($28),y			lda 	(zTemp0),y
.10cb	8d 08 06	sta $0608			sta 	compilerStartHigh
.10ce	ba		tsx				tsx 								; save stack pointer
.10cf	8e 04 06	stx $0604			stx 	compilerSP
.10d2	20 17 1f	jsr $1f17			jsr 	STRReset 					; reset storage (line#, variable)
.10d5	20 9f 16	jsr $169f			jsr 	INPUTOpen 					; reset data input
.10d8	20 c6 1d	jsr $1dc6			jsr 	OUTPUTOpen 					; reset data output.
.10db	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.10dd	20 84 10	jsr $1084			jsr 	WriteCodeByte
.10e0	a9 00		lda #$00			lda 	#0
.10e2	20 84 10	jsr $1084			jsr 	WriteCodeByte
.10e5	20 84 10	jsr $1084			jsr 	WriteCodeByte
.10e8					MainCompileLoop:
.10e8	20 a9 1c	jsr $1ca9			jsr 	ReadNextLine 				; read next line into the buffer.
.10eb	90 2e		bcc $111b			bcc 	SaveCodeAndExit 			; end of source.
.10ed	20 da 1c	jsr $1cda			jsr 	GetLineNumber 				; get line #
.10f0	20 e1 1c	jsr $1ce1			jsr 	STRMarkLine 				; remember the position and number of this line.
.10f3	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.10f5	20 84 10	jsr $1084			jsr 	WriteCodeByte
.10f8					_MCLSameLine:
.10f8	20 2f 1b	jsr $1b2f			jsr 	GetNextNonSpace 			; get the first character.
.10fb	f0 eb		beq $10e8			beq 	MainCompileLoop 			; end of line, get next line.
.10fd	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.10ff	f0 f7		beq $10f8			beq 	_MCLSameLine
.1101	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.1103	10 0c		bpl $1111			bpl 	_MCLCheckAssignment
.1105	a2 f0		ldx #$f0			ldx 	#CommandTables & $FF 		; do command tables.
.1107	a0 16		ldy #$16			ldy 	#CommandTables >> 8
.1109	20 b8 19	jsr $19b8			jsr 	GeneratorProcess
.110c	b0 ea		bcs $10f8			bcs 	_MCLSameLine 				; keep trying to compile the line.
.110e					_MCLSyntax:
.110e	4c 5a 13	jmp $135a		jmp	ErrorV_syntax
.1111					_MCLCheckAssignment:
.1111	20 45 1b	jsr $1b45			jsr 	CharIsAlpha 				; if not alpha then syntax error
.1114	90 f8		bcc $110e			bcc 	_MCLSyntax
.1116	20 77 1c	jsr $1c77			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.1119	80 dd		bra $10f8			bra		_MCLSameLine 				; loop back.
.111b					SaveCodeAndExit:
.111b	20 a7 16	jsr $16a7			jsr 	INPUTClose 					; finish input.
.111e	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.1120	a8		tay				tay
.1121	20 e1 1c	jsr $1ce1			jsr 	STRMarkLine
.1124	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.1126	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1129	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.112b	20 84 10	jsr $1084			jsr 	WriteCodeByte
.112e	20 86 15	jsr $1586			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.1131	20 a7 10	jsr $10a7			jsr 	OUTPUTClose
.1134					ExitCompiler:
.1134	ae 04 06	ldx $0604			ldx 	compilerSP 					; reload SP and exit.
.1137	9a		txs				txs
.1138	60		rts				rts
.0604					compilerSP:
>0604							.fill 	1
.0605					APIVector:
>0605							.fill 	2
.0607					compilerStartLow:
>0607							.fill 	1
.0608					compilerStartHigh:
>0608							.fill 	1
.1139					PushIntegerYA:
.1139	c0 00		cpy #$00			cpy 	#0 							; 0-255
.113b	f0 0f		beq $114c			beq 	PushIntegerA
.113d	48		pha				pha
.113e	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.1140	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1143	68		pla				pla 								; then LSB
.1144	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1147	98		tya				tya 								; then MSB
.1148	20 84 10	jsr $1084			jsr 	WriteCodeByte
.114b	60		rts				rts
.114c					PushIntegerA:
.114c	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.114e	90 07		bcc $1157			bcc 	_PIWriteA
.1150	48		pha				pha
.1151	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.1153	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1156	68		pla				pla
.1157					_PIWriteA:
.1157	20 84 10	jsr $1084			jsr 	WriteCodeByte
.115a	60		rts				rts
.115b					PushFloat:
.115b	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.115d	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1160	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.1162	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1165	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1167	20 84 10	jsr $1084			jsr 	WriteCodeByte
.116a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.116c	20 84 10	jsr $1084			jsr 	WriteCodeByte
.116f	b5 56		lda $56,x			lda 	NSMantissa2,x
.1171	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1174	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.1176	29 80		and #$80			and 	#$80
.1178	15 62		ora $62,x			ora 	NSMantissa3,x
.117a	20 84 10	jsr $1084			jsr 	WriteCodeByte
.117d	60		rts				rts
.117e					CreateVariableRecord:
.117e	48		pha				pha
.117f	ad 13 06	lda $0613			lda 	freeVariableMemory 		; push current free address on stack.
.1182	48		pha				pha
.1183	ad 14 06	lda $0614			lda 	freeVariableMemory+1
.1186	48		pha				pha
.1187	ad 11 06	lda $0611			lda 	variableListEnd  		; copy end of list to zTemp0
.118a	85 28		sta $28				sta 	zTemp0
.118c	ad 12 06	lda $0612			lda 	variableListEnd+1
.118f	85 29		sta $29				sta 	zTemp0+1
.1191	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.1193	92 28		sta ($28)			sta 	(zTemp0)
.1195	98		tya				tya
.1196	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.1198	91 28		sta ($28),y			sta 	(zTemp0),y
.119a	88		dey				dey
.119b	8a		txa				txa
.119c	91 28		sta ($28),y			sta 	(zTemp0),y
.119e	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.11a0	ad 13 06	lda $0613			lda 	freeVariableMemory
.11a3	91 28		sta ($28),y			sta 	(zTemp0),y
.11a5	c8		iny				iny
.11a6	ad 14 06	lda $0614			lda 	freeVariableMemory+1
.11a9	91 28		sta ($28),y			sta 	(zTemp0),y
.11ab	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.11ad	a9 00		lda #$00			lda 	#0
.11af	91 28		sta ($28),y			sta 	(zTemp0),y
.11b1	18		clc				clc
.11b2	b2 28		lda ($28)			lda 	(zTemp0) 				; add offset to variableListEnd
.11b4	6d 11 06	adc $0611			adc  	variableListEnd
.11b7	8d 11 06	sta $0611			sta 	variableListEnd
.11ba	90 03		bcc $11bf			bcc 	_CVNoCarry2
.11bc	ee 12 06	inc $0612			inc 	variableListEnd+1
.11bf					_CVNoCarry2:
.11bf	7a		ply				ply
.11c0	fa		plx				plx
.11c1	68		pla				pla
.11c2	60		rts				rts
.11c3					SetVariableRecordToCodePosition:
.11c3	48		pha				pha
.11c4	5a		phy				phy
.11c5	a5 27		lda $27				lda 	objPage
.11c7	a0 03		ldy #$03			ldy 	#3
.11c9	91 28		sta ($28),y			sta 	(zTemp0),y
.11cb	c8		iny				iny
.11cc	a5 26		lda $26				lda 	objPtr+1
.11ce	91 28		sta ($28),y			sta 	(zTemp0),y
.11d0	c8		iny				iny
.11d1	a5 25		lda $25				lda 	objPtr
.11d3	91 28		sta ($28),y			sta 	(zTemp0),y
.11d5	7a		ply				ply
.11d6	68		pla				pla
.11d7	60		rts				rts
.11d8					AllocateBytesForType:
.11d8	48		pha				pha
.11d9	da		phx				phx
.11da	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.11dc	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.11de	c9 00		cmp #$00			cmp 	#NSSIFloat
.11e0	d0 02		bne $11e4			bne 	_CVNotFloat
.11e2	a2 06		ldx #$06			ldx 	#6
.11e4					_CVNotFloat:
.11e4	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.11e5	18		clc				clc
.11e6	6d 13 06	adc $0613			adc 	freeVariableMemory
.11e9	8d 13 06	sta $0613			sta 	freeVariableMemory
.11ec	90 03		bcc $11f1			bcc 	_CVNoCarry1
.11ee	ee 14 06	inc $0614			inc 	freeVariableMemory+1
.11f1					_CVNoCarry1:
.11f1	fa		plx				plx
.11f2	68		pla				pla
.11f3	60		rts				rts
.11f4					CommandDATA:
.11f4	20 5d 10	jsr $105d			jsr 	BufferClear 				; copy it to the buffer
.11f7	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace
.11fa					_CTDataLoop:
.11fa	20 13 1b	jsr $1b13			jsr 	LookNext 					; reached EOL
.11fd	f0 08		beq $1207			beq 	_CTDataDone
.11ff	20 61 10	jsr $1061			jsr 	BufferWrite 				; write and consume
.1202	20 24 1b	jsr $1b24			jsr 	GetNext
.1205	80 f3		bra $11fa			bra 	_CTDataLoop
.1207					_CTDataDone:
.1207	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.1209	20 84 10	jsr $1084			jsr 	WriteCodeByte
.120c	20 6d 10	jsr $106d			jsr 	BufferOutput
.120f	60		rts				rts
.1210					CommandDEF:
.1210	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.1212	20 4c 11	jsr $114c			jsr 	PushIntegerA
.1215	20 3b 1c	jsr $1c3b			jsr 	CompileGotoEOL 				; compile skip over DEF
.1218	a9 a5		lda #$a5			lda 	#C64_FN
.121a	20 98 10	jsr $1098			jsr 	CheckNextA
.121d	20 2f 1b	jsr $1b2f			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.1220	20 94 1b	jsr $1b94			jsr 	ExtractVariableName
.1223	8a		txa				txa
.1224	10 51		bpl $1277			bpl 	_CDError
.1226	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.1227	29 7f		and #$7f			and 	#$7F
.1229	aa		tax				tax
.122a	98		tya				tya
.122b	09 80		ora #$80			ora 	#$80
.122d	a8		tay				tay
.122e	20 29 15	jsr $1529			jsr 	FindVariable				; does it already exist ?
.1231	b0 44		bcs $1277			bcs 	_CDError 					; if so, that's an error.
.1233	20 7e 11	jsr $117e			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.1236	20 c3 11	jsr $11c3			jsr 	SetVariableRecordToCodePosition
.1239	20 2f 1b	jsr $1b2f			jsr 	GetNextNonSpace
.123c	20 d4 1e	jsr $1ed4			jsr 	GetReferenceTerm 			; get var ref, not array
.123f	c9 00		cmp #$00			cmp 	#0
.1241	30 34		bmi $1277			bmi 	_CDError
.1243	8d 09 06	sta $0609			sta 	defType 					; save type
.1246	8e 0a 06	stx $060a			stx 	defVariable 				; save var ref
.1249	8c 0b 06	sty $060b			sty 	defVariable+1
.124c	29 40		and #$40			and 	#NSSString 					; only numbers.
.124e	d0 27		bne $1277			bne 	_CDError
.1250	20 92 10	jsr $1092			jsr 	CheckNextRParen 			; check )
.1253	a9 b2		lda #$b2			lda 	#C64_EQUAL
.1255	20 98 10	jsr $1098			jsr 	CheckNextA 					; check =
.1258	18		clc				clc 								; if this is DEF FNxx(A), read A
.1259	20 7a 12	jsr $127a			jsr 	CDReadWriteVariable
.125c	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.125e	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1261	38		sec				sec
.1262	20 7a 12	jsr $127a			jsr 	CDReadWriteVariable 		; A is now updated
.1265	20 6f 14	jsr $146f			jsr 	CompileExpressionAt0 		; the actual body of the function.
.1268	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.126a	20 84 10	jsr $1084			jsr 	WriteCodeByte
.126d	38		sec				sec
.126e	20 7a 12	jsr $127a			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.1271	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.1273	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1276	60		rts				rts
.1277					_CDError:
.1277	4c 5a 13	jmp $135a		jmp	ErrorV_syntax
.127a					CDReadWriteVariable:
.127a	ac 0b 06	ldy $060b			ldy 	defVariable+1 				; set up YX
.127d	ae 0a 06	ldx $060a			ldx 	defVariable
.1280	ad 09 06	lda $0609			lda 	defType
.1283	20 86 1e	jsr $1e86			jsr 	GetSetVariable
.1286	60		rts				rts
.0609					defType:
>0609							.fill 	1
.060a					defVariable:
>060a							.fill 	2
.1287					CommandDIM:
.1287	20 2f 1b	jsr $1b2f			jsr 	GetNextNonSpace 			; get the first non space character
.128a	20 94 1b	jsr $1b94			jsr 	ExtractVariableName 		; variable name to XY
.128d	da		phx				phx 								; save name with type bits.
.128e	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.1290	10 37		bpl $12c9			bpl 	_CDError
.1292	20 29 15	jsr $1529			jsr 	FindVariable	 			; see if already exist
.1295	b0 35		bcs $12cc			bcs 	_CDRedefine 				; it still exists.
.1297	20 7e 11	jsr $117e			jsr 	CreateVariableRecord 		; create the basic variable
.129a	20 d8 11	jsr $11d8			jsr 	AllocateBytesForType 		; allocate memory for it
.129d	68		pla				pla 								; restore type bits
.129e	5a		phy				phy 								; save the address of the basic storage
.129f	da		phx				phx
.12a0	48		pha				pha
.12a1	20 cf 12	jsr $12cf			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.12a4	68		pla				pla
.12a5	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.12a7	20 4c 11	jsr $114c			jsr 	PushIntegerA 				; push that type data out.
.12aa	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.12ac	20 84 10	jsr $1084			jsr 	WriteCodeByte
.12af	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.12b1	20 84 10	jsr $1084			jsr 	WriteCodeByte
.12b4	fa		plx				plx 								; restore address
.12b5	7a		ply				ply
.12b6	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.12b8	38		sec				sec
.12b9	20 86 1e	jsr $1e86			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.12bc	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; , follows ?
.12bf	c9 2c		cmp #$2c			cmp 	#","
.12c1	d0 05		bne $12c8			bne 	_CDExit
.12c3	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume comma
.12c6	80 bf		bra $1287			bra 	CommandDIM 					; do another DIM
.12c8					_CDExit:
.12c8	60		rts				rts
.12c9					_CDError:
.12c9	4c 5a 13	jmp $135a		jmp	ErrorV_syntax
.12cc					_CDRedefine:
.12cc	4c 22 14	jmp $1422		jmp	ErrorV_redefine
.12cf					OutputIndexGroup:
.12cf	9c 0c 06	stz $060c			stz 	IndexCount 					; count of number of indices.
.12d2					_OIGNext:
.12d2	20 6f 14	jsr $146f			jsr 	CompileExpressionAt0 		; get a dimension
.12d5	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.12d7	c9 00		cmp #$00			cmp 	#NSSIFloat
.12d9	d0 19		bne $12f4			bne 	_OIGType
.12db	ee 0c 06	inc $060c			inc 	IndexCount 					; bump the counter.
.12de	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; does a , follow ?
.12e1	c9 2c		cmp #$2c			cmp 	#","
.12e3	d0 05		bne $12ea			bne 	_OIGCheckEnd
.12e5	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume comma
.12e8	80 e8		bra $12d2			bra 	_OIGNext 					; get next dimension
.12ea					_OIGCheckEnd:
.12ea	20 92 10	jsr $1092			jsr 	CheckNextRParen 			; check and consume )
.12ed	ad 0c 06	lda $060c			lda 	IndexCount
.12f0	20 4c 11	jsr $114c			jsr 	PushIntegerA 				; compile the dimension count.
.12f3	60		rts				rts
.12f4					_OIGType:
.12f4	4c 6a 13	jmp $136a		jmp	ErrorV_type
.060c					IndexCount:
>060c							.fill 	1
.12f7					ErrorHandler:
.12f7	68		pla				pla
.12f8	7a		ply				ply
.12f9	85 28		sta $28				sta 	zTemp0
.12fb	84 29		sty $29				sty 	zTemp0+1
.12fd	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.12ff	a0 01		ldy #$01			ldy 	#1
.1301					_EHDisplayMsg:
.1301	b1 28		lda ($28),y			lda 	(zTemp0),y
.1303	20 58 20	jsr $2058			jsr 	XPrintCharacter
.1306	c8		iny				iny
.1307	b1 28		lda ($28),y			lda 	(zTemp0),y
.1309	d0 f6		bne $1301			bne 	_EHDisplayMsg
.130b	a9 20		lda #$20			lda 	#32
.130d	20 58 20	jsr $2058			jsr 	XPrintCharacter
.1310	a9 40		lda #$40			lda 	#64
.1312	20 58 20	jsr $2058			jsr 	XPrintCharacter
.1315	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.1317	20 70 26	jsr $2670			jsr 	FloatSetByte
.131a	20 da 1c	jsr $1cda			jsr 	GetLineNumber
.131d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.131f	98		tya				tya
.1320	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1322	20 56 25	jsr $2556			jsr 	FloatToString
.1325	a0 00		ldy #$00			ldy 	#0 							; display that string.
.1327	a2 00		ldx #$00			ldx 	#0
.1329					_EHDisplayLine:
.1329	b9 3c 06	lda $063c,y			lda 	decimalBuffer,y
.132c	20 58 20	jsr $2058			jsr 	XPrintCharacter
.132f	c8		iny				iny
.1330	b9 3c 06	lda $063c,y			lda 	decimalBuffer,y
.1333	d0 f4		bne $1329			bne 	_EHDisplayLine
.1335	a9 0d		lda #$0d			lda 	#13
.1337	20 58 20	jsr $2058			jsr 	XPrintCharacter
.133a	4c 34 11	jmp $1134			jmp 	ExitCompiler
.133d					ErrorV_range:
.133d	20 f7 12	jsr $12f7		jsr	ErrorHandler
>1340	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1348	41 4e 47 45 00
.134d					ErrorV_value:
.134d	20 f7 12	jsr $12f7		jsr	ErrorHandler
>1350	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1358	45 00
.135a					ErrorV_syntax:
.135a	20 f7 12	jsr $12f7		jsr	ErrorHandler
>135d	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1365	52 52 4f 52 00
.136a					ErrorV_type:
.136a	20 f7 12	jsr $12f7		jsr	ErrorHandler
>136d	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1375	4d 41 54 43 48 00
.137b					ErrorV_unimplemented:
.137b	20 f7 12	jsr $12f7		jsr	ErrorHandler
>137e	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1386	45 4d 45 4e 54 45 44 00
.138e					ErrorV_assert:
.138e	20 f7 12	jsr $12f7		jsr	ErrorHandler
>1391	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1399	41 49 4c 00
.139d					ErrorV_line:
.139d	20 f7 12	jsr $12f7		jsr	ErrorHandler
>13a0	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>13a8	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.13b4					ErrorV_internal:
.13b4	20 f7 12	jsr $12f7		jsr	ErrorHandler
>13b7	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>13bf	20 45 52 52 4f 52 00
.13c6					ErrorV_divzero:
.13c6	20 f7 12	jsr $12f7		jsr	ErrorHandler
>13c9	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>13d1	59 20 5a 45 52 4f 00
.13d8					ErrorV_structure:
.13d8	20 f7 12	jsr $12f7		jsr	ErrorHandler
>13db	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>13e3	45 20 49 4d 42 41 4c 41 4e 43 45 00
.13ef					ErrorV_stop:
.13ef	20 f7 12	jsr $12f7		jsr	ErrorHandler
>13f2	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>13fa	53 54 4f 50 50 45 44 00
.1402					ErrorV_data:
.1402	20 f7 12	jsr $12f7		jsr	ErrorHandler
>1405	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>140d	41 54 41 00
.1411					ErrorV_undeclared:
.1411	20 f7 12	jsr $12f7		jsr	ErrorHandler
>1414	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>141c	41 52 52 41 59 00
.1422					ErrorV_redefine:
.1422	20 f7 12	jsr $12f7		jsr	ErrorHandler
>1425	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>142d	44 45 46 49 4e 45 44 00
.1435					ErrorV_index:
.1435	20 f7 12	jsr $12f7		jsr	ErrorHandler
>1438	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1440	59 20 49 4e 44 45 58 00
.1448					ErrorV_memory:
.1448	20 f7 12	jsr $12f7		jsr	ErrorHandler
>144b	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>1453	45 4d 4f 52 59 00
.1459					ErrorV_channel:
.1459	20 f7 12	jsr $12f7		jsr	ErrorHandler
>145c	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>1464	54 50 55 54 20 45 52 52 4f 52 00
.146f					CompileExpressionAt0:
.146f	a9 00		lda #$00			lda 	#0
.1471					CompileExpressionAtA:
.1471	48		pha				pha  								; save level
.1472	20 39 1f	jsr $1f39			jsr 	CompileTerm 				; compile a term.
.1475	fa		plx				plx 								; get level back into X
.1476					_ECALoop:
.1476	48		pha				pha 								; save type on stack.
.1477	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; get the next character
.147a	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.147c	90 04		bcc $1482			bcc 	_ECAExit
.147e	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.1480	90 02		bcc $1484			bcc 	_ECAHaveToken
.1482					_ECAExit:
.1482	68		pla				pla 								; throw type off stack
.1483	60		rts				rts
.1484					_ECAHaveToken:
.1484	86 28		stx $28				stx 	zTemp0 						; save current precedence in zTemp0
.1486	aa		tax				tax 								; X contains the operator token
.1487	bd 72 14	lda $1472,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.148a	c5 28		cmp $28				cmp 	zTemp0 						; if < then exit
.148c	90 f4		bcc $1482			bcc 	_ECAExit
.148e	85 29		sta $29				sta 	zTemp0+1 					; save the precedence of the operator.
.1490	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume the token.
.1493	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.1495	f0 11		beq $14a8			beq 	_ECAGreaterCheck
.1497	e0 b3		cpx #$b3			cpx 	#C64_LESS
.1499	d0 1a		bne $14b5			bne 	_ECAHaveFullToken
.149b	20 13 1b	jsr $1b13			jsr 	LookNext 					; checks for < (<= or <>)
.149e	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.14a0	f0 0e		beq $14b0			beq	 	_ECAToNotEqual
.14a2	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.14a4	d0 0f		bne $14b5			bne 	_ECAHaveFullToken
.14a6	80 07		bra $14af			bra 	_ECAAddEqual
.14a8					_ECAGreaterCheck:
.14a8	20 13 1b	jsr $1b13			jsr 	LookNext
.14ab	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.14ad	d0 06		bne $14b5			bne 	_ECAHaveFullToken
.14af					_ECAAddEqual:
.14af	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.14b0					_ECAToNotEqual:
.14b0	e8		inx				inx
.14b1	e8		inx				inx
.14b2	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume the = or > in >= <= <>
.14b5					_ECAHaveFullToken:
.14b5	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.14b7	d0 0a		bne $14c3			bne 	_ECANotConcat
.14b9	68		pla				pla 								; get type back
.14ba	48		pha				pha
.14bb	29 40		and #$40			and 	#NSSTypeMask
.14bd	c9 40		cmp #$40			cmp 	#NSSString
.14bf	d0 02		bne $14c3			bne 	_ECANotConcat
.14c1	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.14c3					_ECANotConcat:
.14c3	da		phx				phx 								; save operator on the stack
.14c4	a6 28		ldx $28				ldx 	zTemp0 						; push current precedence on the stack
.14c6	da		phx				phx
.14c7	a5 29		lda $29				lda 	zTemp0+1 					; get precedence of operator
.14c9	1a		inc a				inc 	a
.14ca	20 71 14	jsr $1471			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.14cd	85 28		sta $28				sta 	zTemp0 						; save type in zTemp0
.14cf	fa		plx				plx 								; restore current precedence in X
.14d0	68		pla				pla 								; restore operator
.14d1	85 29		sta $29				sta 	zTemp0+1 					; save it in zTemp0+1.
.14d3	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.14d5	90 17		bcc $14ee			bcc 	_ECANotCompare
.14d7	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.14d9	b0 13		bcs $14ee			bcs 	_ECANotCompare
.14db	7a		ply				ply 								; get type into Y
.14dc	5a		phy				phy
.14dd	48		pha				pha 								; save operator
.14de	98		tya				tya 								; get type
.14df	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.14e1	29 40		and #$40			and 	#NSSTypeMask
.14e3	c9 40		cmp #$40			cmp 	#NSSString
.14e5	f0 02		beq $14e9			beq 	_ECANotString
.14e7	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.14e9					_ECANotString:
.14e9	98		tya				tya									; output token Y
.14ea	20 84 10	jsr $1084			jsr 	WriteCodeByte
.14ed	68		pla				pla 								; restore operator.
.14ee					_ECANotCompare:
.14ee	18		clc				clc 								; convert to P-Code and compile.
.14ef	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.14f1	20 84 10	jsr $1084			jsr 	WriteCodeByte
.14f4	68		pla				pla 								; type of current result
.14f5	45 28		eor $28				eor 	zTemp0 						; check compatible with r-expr type
.14f7	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.14f9	d0 19		bne $1514			bne		_ECAType
.14fb	a5 28		lda $28				lda 	zTemp0 						; get type back
.14fd	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.14ff	d0 18		bne $1519			bne 	_ECAGoLoop
.1501	a5 29		lda $29				lda 	zTemp0+1 					; check operator is + or comparator
.1503	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1505	f0 10		beq $1517			beq 	_ECAOkayString 				; (this is post conversion)
.1507	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.1509	90 09		bcc $1514			bcc 	_ECAType
.150b	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.150d	b0 05		bcs $1514			bcs 	_ECAType
.150f	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.1511	4c 76 14	jmp $1476			jmp 	_ECALoop
.1514					_ECAType:
.1514	4c 6a 13	jmp $136a		jmp	ErrorV_type
.1517					_ECAOkayString:
.1517	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.1519					_ECAGoLoop:
.1519	4c 76 14	jmp $1476			jmp 	_ECALoop
.151c					PrecedenceTable:
>151c	03						.byte 	3 					; '+'
>151d	03						.byte 	3 					; '-'
>151e	04						.byte 	4 					; '*'
>151f	04						.byte 	4 					; '/'
>1520	05						.byte 	5 					; '^'
>1521	01						.byte 	1 					; 'and'
>1522	00						.byte 	0 					; 'or'
>1523	02						.byte 	2 					; '>'
>1524	02						.byte 	2 					; '='
>1525	02						.byte 	2 					; '<'
>1526	02						.byte 	2 					; '>='
>1527	02						.byte 	2 					; '<='
>1528	02						.byte 	2 					; '<>'
.1529					FindVariable:
.1529	86 2a		stx $2a				stx 	zTemp1 						; save name.
.152b	84 2b		sty $2b				sty 	zTemp1+1
.152d					_IVCheckSpecial:
.152d	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.152f	d0 18		bne $1549			bne 	_IVStandard
.1531	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.1533	f0 0c		beq $1541			beq 	_IVTIFloat
.1535	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.1537	d0 10		bne $1549			bne 	_IVStandard
.1539	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.153b	a2 01		ldx #$01			ldx 	#$01
.153d	a9 40		lda #$40			lda 	#NSSString
.153f	38		sec				sec
.1540	60		rts				rts
.1541					_IVTIFloat:
.1541	a0 80		ldy #$80			ldy 	#$80
.1543	a2 00		ldx #$00			ldx 	#$00
.1545	a9 00		lda #$00			lda 	#0
.1547	38		sec				sec
.1548	60		rts				rts
.1549					_IVStandard:
.1549	a9 00		lda #$00			lda 	#((WorkArea) & $FF)
.154b	85 28		sta $28				sta 	0+zTemp0
.154d	a9 80		lda #$80			lda 	#((WorkArea) >> 8) & $FF
.154f	85 29		sta $29				sta 	1+zTemp0
.1551					_IVCheckLoop:
.1551	b2 28		lda ($28)			lda 	(zTemp0) 					; finished ?
.1553	f0 2b		beq $1580			beq  	_IVNotFound 				; if so, return with CC.
.1555	a0 01		ldy #$01			ldy 	#1 							; match ?
.1557	b1 28		lda ($28),y			lda 	(zTemp0),y
.1559	c5 2a		cmp $2a				cmp 	zTemp1
.155b	d0 07		bne $1564			bne	 	_IVNext
.155d	c8		iny				iny
.155e	b1 28		lda ($28),y			lda 	(zTemp0),y
.1560	c5 2b		cmp $2b				cmp 	zTemp1+1
.1562	f0 0d		beq $1571			beq 	_IVFound
.1564					_IVNext:
.1564	18		clc				clc
.1565	a5 28		lda $28				lda 	zTemp0
.1567	72 28		adc ($28)			adc 	(zTemp0)
.1569	85 28		sta $28				sta 	zTemp0
.156b	90 e4		bcc $1551			bcc 	_IVCheckLoop
.156d	e6 29		inc $29				inc 	zTemp0+1
.156f	80 e0		bra $1551			bra 	_IVCheckLoop
.1571					_IVFound:
.1571	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.1573	b1 28		lda ($28),y			lda 	(zTemp0),y
.1575	aa		tax				tax
.1576	c8		iny				iny
.1577	b1 28		lda ($28),y			lda 	(zTemp0),y
.1579	48		pha				pha
.157a	c8		iny				iny
.157b	b1 28		lda ($28),y			lda 	(zTemp0),y
.157d	7a		ply				ply
.157e	38		sec				sec
.157f	60		rts				rts
.1580					_IVNotFound:
.1580	a6 2a		ldx $2a				ldx 	zTemp1 						; get variable name back
.1582	a4 2b		ldy $2b				ldy 	zTemp1+1
.1584	18		clc				clc
.1585	60		rts				rts
.1586					FixBranches:
.1586	20 c6 1d	jsr $1dc6			jsr 	OUTPUTRewind 				; back to the start of the *object* code.
.1589					_FBLoop:
.1589	b2 25		lda ($25)			lda 	(objPtr) 					; get the next one.
.158b	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.158d	f0 16		beq $15a5			beq 	_FBFixGotoGosub
.158f	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.1591	f0 12		beq $15a5			beq 	_FBFixGotoGosub
.1593	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.1595	f0 0e		beq $15a5			beq 	_FBFixGotoGosub
.1597	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1599	f0 0a		beq $15a5			beq 	_FBFixGotoGosub
.159b	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.159d	f0 49		beq $15e8			beq 	_FBFixVarSpace
.159f					_FBNext:
.159f	20 5b 16	jsr $165b			jsr 	MoveObjectForward 			; move forward in object code.
.15a2	90 e5		bcc $1589			bcc 	_FBLoop 					; not finished
.15a4					_FBExit:
.15a4	60		rts				rts
.15a5					_FBFixGotoGosub:
.15a5	a0 01		ldy #$01			ldy 	#1 							; if page is currently $FF
.15a7	b1 25		lda ($25),y			lda 	(objPtr),y 					; then patch else leave.
.15a9	c9 ff		cmp #$ff			cmp 	#$FF
.15ab	d0 f2		bne $159f			bne 	_FBNext
.15ad	a0 02		ldy #$02			ldy 	#2							; line number in YA
.15af	b1 25		lda ($25),y			lda 	(objPtr),y
.15b1	48		pha				pha
.15b2	c8		iny				iny
.15b3	b1 25		lda ($25),y			lda 	(objPtr),y
.15b5	a8		tay				tay
.15b6	68		pla				pla
.15b7	20 0f 1d	jsr $1d0f			jsr 	STRFindLine			 		; find where it is X:YA
.15ba	90 08		bcc $15c4			bcc 	_FBFFound 					; not found, so must be >
.15bc	48		pha				pha
.15bd	b2 25		lda ($25)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.15bf	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.15c1	d0 15		bne $15d8			bne 	_FBFFail
.15c3	68		pla				pla
.15c4					_FBFFound:
.15c4	20 64 1d	jsr $1d64			jsr 	STRMakeOffset 				; make it an offset from X:YA
.15c7	5a		phy				phy	 								; patch the GOTO/GOSUB
.15c8	48		pha				pha
.15c9	a0 01		ldy #$01			ldy 	#1
.15cb	8a		txa				txa
.15cc	91 25		sta ($25),y			sta 	(objPtr),y
.15ce	c8		iny				iny
.15cf	68		pla				pla
.15d0	91 25		sta ($25),y			sta 	(objPtr),y
.15d2	c8		iny				iny
.15d3	68		pla				pla
.15d4	91 25		sta ($25),y			sta 	(objPtr),y
.15d6	80 c7		bra $159f			bra 	_FBNext
.15d8					_FBFFail:
.15d8	a0 02		ldy #$02			ldy 	#2
.15da	b1 25		lda ($25),y			lda 	(objPtr),y
.15dc	8d 00 05	sta $0500			sta 	currentLineNumber
.15df	c8		iny				iny
.15e0	b1 25		lda ($25),y			lda 	(objPtr),y
.15e2	8d 01 05	sta $0501			sta 	currentLineNumber+1
.15e5	4c 9d 13	jmp $139d		jmp	ErrorV_line
.15e8					_FBFixVarSpace:
.15e8	a0 01		ldy #$01			ldy 	#1
.15ea	ad 13 06	lda $0613			lda 	freeVariableMemory
.15ed	91 25		sta ($25),y			sta 	(objPtr),y
.15ef	c8		iny				iny
.15f0	ad 14 06	lda $0614			lda 	freeVariableMemory+1
.15f3	91 25		sta ($25),y			sta 	(objPtr),y
.15f5	80 a8		bra $159f			bra 	_FBNext
.15f7					CommandFOR:
.15f7	20 2f 1b	jsr $1b2f			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.15fa	20 45 1b	jsr $1b45			jsr 	CharIsAlpha 				; if not alpha , error
.15fd	90 59		bcc $1658			bcc 	_CFFail
.15ff	20 d4 1e	jsr $1ed4			jsr 	GetReferenceTerm 			; figure out the reference.
.1602	48		pha				pha 								; save type
.1603	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1605	c9 00		cmp #$00			cmp 	#NSSIFloat
.1607	d0 4f		bne $1658			bne 	_CFFail
.1609	5a		phy				phy 								; save reference on the stack
.160a	da		phx				phx
.160b	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.160d	20 98 10	jsr $1098			jsr 	CheckNextA
.1610	20 6f 14	jsr $146f			jsr 	CompileExpressionAt0 		; initial value
.1613	fa		plx				plx 								; get reference back.
.1614	7a		ply				ply
.1615	5a		phy				phy
.1616	da		phx				phx
.1617	38		sec				sec 								; set initial value.
.1618	20 86 1e	jsr $1e86			jsr 	GetSetVariable
.161b	fa		plx				plx
.161c	7a		ply				ply
.161d	68		pla				pla
.161e	29 20		and #$20			and 	#NSSIInt16
.1620	f0 04		beq $1626			beq 	_CFNotInt16
.1622	98		tya				tya
.1623	09 80		ora #$80			ora 	#$80
.1625	a8		tay				tay
.1626					_CFNotInt16:
.1626	8a		txa				txa 								; reference in YA
.1627	20 39 11	jsr $1139			jsr 	PushIntegerYA
.162a	a9 a4		lda #$a4			lda 	#C64_TO
.162c	20 98 10	jsr $1098			jsr 	CheckNextA
.162f	20 6f 14	jsr $146f			jsr 	CompileExpressionAt0 		; terminal value
.1632	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1634	c9 00		cmp #$00			cmp 	#NSSIFloat
.1636	d0 20		bne $1658			bne 	_CFFail
.1638	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; followed by STEP
.163b	c9 a9		cmp #$a9			cmp 	#C64_STEP
.163d	d0 0e		bne $164d			bne 	_CFNoStep
.163f	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume it.
.1642	20 6f 14	jsr $146f			jsr 	CompileExpressionAt0 		; terminal value
.1645	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1647	c9 00		cmp #$00			cmp 	#NSSIFloat
.1649	d0 0d		bne $1658			bne 	_CFFail
.164b	80 05		bra $1652			bra 	_CFParametersDone
.164d					_CFNoStep:
.164d	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.164f	20 4c 11	jsr $114c			jsr 	PushIntegerA
.1652					_CFParametersDone:
.1652	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.1654	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1657	60		rts				rts
.1658					_CFFail:
.1658	4c 5a 13	jmp $135a		jmp	ErrorV_syntax
.165b					MoveObjectForward:
.165b	b2 25		lda ($25)			lda 	(objPtr) 					; get next
.165d	c9 ff		cmp #$ff			cmp 	#$FF
.165f	f0 36		beq $1697			beq 	_MOFEnd
.1661	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.1663	90 24		bcc $1689			bcc 	_MOFAdvance1 				; forward 1
.1665	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.1667	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.1669	90 20		bcc $168b			bcc 	_MOFAdvanceY
.166b	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.166d	90 1a		bcc $1689			bcc 	_MOFAdvance1 				; forward 1
.166f	a8		tay				tay 								; read the size.
.1670	b9 2c 1d	lda $1d2c,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.1673	a8		tay				tay
.1674	c8		iny				iny 								; add 1 for the system token.
.1675	d0 14		bne $168b			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.1677	a0 01		ldy #$01			ldy 	#1 							; get length byte
.1679	b1 25		lda ($25),y			lda 	(objPtr),y
.167b	a8		tay				tay 								; into Y.
.167c	18		clc				clc
.167d	a5 25		lda $25				lda 	objPtr						; add 2 to the object pointer
.167f	69 02		adc #$02			adc 	#2
.1681	85 25		sta $25				sta 	objPtr
.1683	90 02		bcc $1687			bcc 	_MOFNoCarry1
.1685	e6 26		inc $26				inc 	objPtr+1
.1687					_MOFNoCarry1:
.1687	80 02		bra $168b			bra 	_MOFAdvanceY
.1689					_MOFAdvance1:
.1689	a0 01		ldy #$01			ldy 	#1
.168b					_MOFAdvanceY:
.168b	98		tya				tya 								; add X to objPtr
.168c	18		clc				clc
.168d	65 25		adc $25				adc 	objPtr
.168f	85 25		sta $25				sta 	objPtr
.1691	90 02		bcc $1695			bcc 	_MOFNoCarry2
.1693	e6 26		inc $26				inc 	objPtr+1
.1695					_MOFNoCarry2:
.1695	18		clc				clc 								; not completed.
.1696	60		rts				rts
.1697					_MOFEnd:
.1697	e6 25		inc $25				inc 	objPtr
.1699	d0 02		bne $169d			bne 	_MOFENoCarry
.169b	e6 26		inc $26				inc 	objPtr+1
.169d					_MOFENoCarry:
.169d	38		sec				sec
.169e	60		rts				rts
.169f					INPUTOpen:
.169f	a9 9b		lda #$9b			lda 	#((EndProgram+2) & $FF)
.16a1	85 30		sta $30				sta 	0+srcInputPtr
.16a3	a9 26		lda #$26			lda 	#((EndProgram+2) >> 8) & $FF
.16a5	85 31		sta $31				sta 	1+srcInputPtr
.16a7					INPUTClose:
.16a7	60		rts				rts
.16a8					INPUTGet:
.16a8	b2 30		lda ($30)			lda 	(srcInputPtr)
.16aa	e6 30		inc $30				inc 	srcInputPtr
.16ac	d0 02		bne $16b0			bne 	_IGSkip
.16ae	e6 31		inc $31				inc 	srcInputPtr+1
.16b0					_IGSkip:
.16b0	60		rts				rts
.0030					srcInputPtr:
>0030							.fill 	2
.16b1					FNCompile:
.16b1	20 2f 1b	jsr $1b2f			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.16b4	20 94 1b	jsr $1b94			jsr 	ExtractVariableName
.16b7	e0 00		cpx #$00			cpx 	#0
.16b9	10 32		bpl $16ed			bpl 	_FNError
.16bb	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.16bc	29 7f		and #$7f			and 	#$7F
.16be	aa		tax				tax
.16bf	98		tya				tya
.16c0	09 80		ora #$80			ora 	#$80
.16c2	a8		tay				tay
.16c3	20 29 15	jsr $1529			jsr 	FindVariable				; does it already exist ?
.16c6	90 25		bcc $16ed			bcc 	_FNError 					; no.
.16c8	20 64 1d	jsr $1d64			jsr 	STRMakeOffset 				; convert to a relative address.
.16cb	c9 00		cmp #$00			cmp 	#0 							; fix up.
.16cd	d0 01		bne $16d0			bne 	_FNNoBorrow
.16cf	88		dey				dey
.16d0					_FNNoBorrow:
.16d0	3a		dec a				dec 	a
.16d1	5a		phy				phy 								; save location of routine on stack.
.16d2	48		pha				pha
.16d3	da		phx				phx
.16d4	20 6f 14	jsr $146f			jsr 	CompileExpressionAt0
.16d7	20 92 10	jsr $1092			jsr 	CheckNextRParen
.16da	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.16dc	20 84 10	jsr $1084			jsr 	WriteCodeByte
.16df	68		pla				pla
.16e0	20 84 10	jsr $1084			jsr 	WriteCodeByte
.16e3	68		pla				pla
.16e4	20 84 10	jsr $1084			jsr 	WriteCodeByte
.16e7	68		pla				pla
.16e8	20 84 10	jsr $1084			jsr 	WriteCodeByte
.16eb	18		clc				clc
.16ec	60		rts				rts
.16ed					_FNError:
.16ed	4c 4d 13	jmp $134d		jmp	ErrorV_value
.16f0					CommandTables:
>16f0	07 cb 00 03 f2 1b 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>16f7	07 89 00 03 f9 1b 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>16fe	07 8d 00 03 ec 1b 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>1705	07 88 00 03 74 1c 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>170c	07 85 00 03 54 1c 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>1713	07 84 00 04 68 1c 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>171a	07 99 00 03 01 1e 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1721	07 98 00 04 01 1e 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1728	07 8f 00 03 0c 1f 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>172f	07 81 00 03 f7 15 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>1736	07 82 00 03 6e 1d 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>173d	07 a1 00 03 65 1b 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>1744	07 83 00 03 f4 11 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>174b	07 87 00 03 4a 1e 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>1752	07 86 00 03 87 12 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>1759	07 96 00 03 10 12 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>1760	07 8b 00 e3 1c 1c 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>1767	08 92 00 ea e3 d2 1f 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>176f	09 91 00 e1 a9 03 9a 1d			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>1777	06
>1778	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>177f	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>1786	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>178c	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>1793	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>179a	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>17a1	07 9d 00 e3 01 20 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>17a8	0a 9f 00 ea e3 14 20 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>17b0	c6 06
>17b2	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>17b8	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>17bf	0a ce 92 e3 e2 1a 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>17c7	ad 06
>17c9	0a ce 8d e3 e2 1a 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>17d1	ae 06
>17d3	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>17d9	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>17e1	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>17e8	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>17ef	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>17f7	06
>17f8	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>1800	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>1808	9a 06
>180a	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>1812	9b 06
>1814	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>181c	9c 06
>181e	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>1826	06
>1827	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>182e	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>1836	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>183e	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>1846	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>184e	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>1856	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>185e	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>1866	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>186e	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>1876	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>187e	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>1885	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>188d	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>1895	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>189d	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>18a5	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>18ad	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>18b5	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>18bd	00						.byte 	0
.18be					UnaryTables:
>18be	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>18c5	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>18cd	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>18d4	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>18db	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>18e2	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>18e9	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>18f1	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>18f8	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>1900	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>1908	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>1910	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>1918	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>1920	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>1928	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>192f	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>1936	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>193d	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>1944	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>194b	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>1952	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>195a	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>1962	0b ca 00 8f ae 03 e2 1a			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>196a	91 bd 07
>196d	07 a8 00 03 01 1b 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>1974	07 a5 00 03 b1 16 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>197b	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>1982	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>1989	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>1991	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>1999	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>19a0	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>19a7	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>19ae	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>19b6	06
>19b7	00						.byte 	0
.19b8					GeneratorProcess:
.19b8	86 28		stx $28				stx 	zTemp0 						; save generation pointer in zTemp0
.19ba	84 29		sty $29				sty 	zTemp0+1
.19bc	85 2a		sta $2a				sta 	zTemp1 						; first match token
.19be	64 2b		stz $2b				stz 	zTemp1+1
.19c0	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.19c2	d0 05		bne $19c9			bne 	_GPNotShifted
.19c4	20 24 1b	jsr $1b24			jsr 	GetNext 					; get the shifted token
.19c7	85 2b		sta $2b				sta 	zTemp1+1 					; match CE xx
.19c9					_GPNotShifted:
.19c9					_GPSearch:
.19c9	b2 28		lda ($28)			lda 	(zTemp0) 					; reached end ?
.19cb	18		clc				clc
.19cc	f0 2f		beq $19fd			beq 	_GPExit
.19ce	a0 01		ldy #$01			ldy 	#1 							; tokens match
.19d0	b1 28		lda ($28),y			lda 	(zTemp0),y
.19d2	c5 2a		cmp $2a				cmp 	zTemp1
.19d4	d0 09		bne $19df			bne 	_GPNext
.19d6	a5 2b		lda $2b				lda 	zTemp1+1 					; 2nd token ?
.19d8	f0 12		beq $19ec			beq 	_GPFound
.19da	c8		iny				iny 								; check match.
.19db	d1 28		cmp ($28),y			cmp 	(zTemp0),y
.19dd	f0 0d		beq $19ec			beq 	_GPFound
.19df					_GPNext:
.19df	18		clc				clc 								; follow to next
.19e0	a5 28		lda $28				lda 	zTemp0
.19e2	72 28		adc ($28)			adc 	(zTemp0)
.19e4	85 28		sta $28				sta 	zTemp0
.19e6	90 e1		bcc $19c9			bcc 	_GPSearch
.19e8	e6 29		inc $29				inc 	zTemp0+1
.19ea	80 dd		bra $19c9			bra 	_GPSearch
.19ec					_GPFound:
.19ec	18		clc				clc 								; skip to action bytes
.19ed	a5 28		lda $28				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.19ef	69 03		adc #$03			adc 	#3
.19f1	85 28		sta $28				sta 	zTemp0
.19f3	90 02		bcc $19f7			bcc 	_GPNoCarry
.19f5	e6 29		inc $29				inc 	zTemp0+1
.19f7					_GPNoCarry:
.19f7					_GPLoop:
.19f7	20 fe 19	jsr $19fe			jsr 	GeneratorExecute 			; execute one command
.19fa	90 fb		bcc $19f7			bcc 	_GPLoop 					; go back if not completed.
.19fc	38		sec				sec 								; return with CS.
.19fd					_GPExit:
.19fd	60		rts				rts
.19fe					GeneratorExecute:
.19fe	20 a9 1a	jsr $1aa9			jsr 	_GEFetchZTemp0 				; get next.
.1a01	48		pha				pha 								; split into 2 nibbles
.1a02	4a		lsr a				lsr 	a
.1a03	4a		lsr a				lsr 	a
.1a04	4a		lsr a				lsr		a
.1a05	4a		lsr a				lsr 	a
.1a06	20 10 1a	jsr $1a10			jsr 	_GEExecuteNibble 			; MSB first
.1a09	68		pla				pla
.1a0a	b0 03		bcs $1a0f			bcs 	_GEHaveCompleted
.1a0c	20 10 1a	jsr $1a10			jsr 	_GEExecuteNibble 			; LSB second
.1a0f					_GEHaveCompleted:
.1a0f	60		rts				rts
.1a10					_GEExecuteNibble:
.1a10	29 0f		and #$0f			and 	#$0F
.1a12	0a		asl a				asl 	a
.1a13	aa		tax				tax
.1a14	7c 17 1a	jmp ($1a17,x)			jmp 	(_GEExecuteVectors,x)
.1a17					_GEExecuteVectors:
>1a17	37 1a						.word 	_GEXNop 					; 0  (no operation)
>1a19	3f 1a						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>1a1b	39 1a						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>1a1d	8c 1a						.word 	_GEXExecute 				; 3  (run arbitrary code)
>1a1f	7f 1a						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>1a21	37 1a						.word 	_GEXNop 					; 5
>1a23	46 1a						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>1a25	4a 1a						.word 	_GEXExitString 				; 7  exit return string type
>1a27	4e 1a						.word 	_GEXLParam 					; 8  check ( follows
>1a29	52 1a						.word 	_GEXRParam 					; 9  check ) follows
>1a2b	56 1a						.word 	_GEXComma					; A  check , follows
>1a2d	37 1a						.word 	_GEXNop 					; B
>1a2f	37 1a						.word 	_GEXNop 					; C
>1a31	37 1a						.word 	_GEXNop 					; D
>1a33	66 1a						.word 	_GEXNumber 					; E  compile get any number
>1a35	71 1a						.word 	_GEXString 					; F  compile get any string
.1a37					_GEXNop:
.1a37	18		clc				clc
.1a38	60		rts				rts
.1a39					_GEXToken2:
.1a39	20 a9 1a	jsr $1aa9			jsr 	_GEFetchZTemp0
.1a3c	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1a3f					_GEXToken1:
.1a3f	20 a9 1a	jsr $1aa9			jsr 	_GEFetchZTemp0
.1a42	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1a45	60		rts				rts
.1a46					_GEXExitNumber:
.1a46	a9 00		lda #$00			lda 	#NSSIFloat
.1a48	38		sec				sec
.1a49	60		rts				rts
.1a4a					_GEXExitString:
.1a4a	a9 40		lda #$40			lda 	#NSSString
.1a4c	38		sec				sec
.1a4d	60		rts				rts
.1a4e					_GEXLParam:
.1a4e	a9 28		lda #$28			lda 	#"("
.1a50	80 06		bra $1a58			bra 	_GEXCheck
.1a52					_GEXRParam:
.1a52	a9 29		lda #$29			lda 	#")"
.1a54	80 02		bra $1a58			bra 	_GEXCheck
.1a56					_GEXComma:
.1a56	a9 2c		lda #$2c			lda 	#","
.1a58					_GEXCheck:
.1a58	85 2c		sta $2c				sta 	zTemp2 						; save match
.1a5a	20 2f 1b	jsr $1b2f			jsr 	GetNextNonSpace 			; get next skipping spaces
.1a5d	c5 2c		cmp $2c				cmp 	zTemp2 						; check matches.
.1a5f	d0 02		bne $1a63			bne 	_GEXSyntax
.1a61	18		clc				clc
.1a62	60		rts				rts
.1a63					_GEXSyntax:
.1a63	4c 5a 13	jmp $135a		jmp	ErrorV_syntax
.1a66					_GEXNumber:
.1a66	20 b2 1a	jsr $1ab2			jsr 	GEXCompileExpression 		; compile expression
.1a69	29 40		and #$40			and 	#NSSTypeMask
.1a6b	c9 00		cmp #$00			cmp  	#NSSIFloat
.1a6d	d0 0d		bne $1a7c			bne 	_GEXType
.1a6f	18		clc				clc
.1a70	60		rts				rts
.1a71					_GEXString:
.1a71	20 b2 1a	jsr $1ab2			jsr 	GEXCompileExpression 		; compile expression
.1a74	29 40		and #$40			and 	#NSSTypeMask
.1a76	c9 40		cmp #$40			cmp  	#NSSString
.1a78	d0 02		bne $1a7c			bne 	_GEXType
.1a7a	18		clc				clc
.1a7b	60		rts				rts
.1a7c					_GEXType:
.1a7c	4c 6a 13	jmp $136a		jmp	ErrorV_type
.1a7f					_GEXChannelExec:
.1a7f	20 c2 1a	jsr $1ac2			jsr 	ChannelPrefix 				; set up default
.1a82	20 8c 1a	jsr $1a8c			jsr 	_GEXExecute
.1a85	08		php				php
.1a86	20 dc 1a	jsr $1adc			jsr 	ChannelPostfix 				; replace default.
.1a89	28		plp				plp
.1a8a	60		rts				rts
>1a8b	db						.byte 	$DB 						; causes a break in the emulator
.1a8c					_GEXExecute:
.1a8c	20 a9 1a	jsr $1aa9			jsr 	_GEFetchZTemp0 				; get vector
.1a8f	85 2c		sta $2c				sta 	zTemp2
.1a91	20 a9 1a	jsr $1aa9			jsr 	_GEFetchZTemp0
.1a94	85 2d		sta $2d				sta 	zTemp2+1
.1a96	a6 28		ldx $28				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.1a98	da		phx				phx
.1a99	a6 29		ldx $29				ldx 	zTemp0+1
.1a9b	da		phx				phx
.1a9c	20 a6 1a	jsr $1aa6			jsr 	_GECallZTemp2 				; execute code
.1a9f	fa		plx				plx 								; recover generation exec
.1aa0	86 29		stx $29				stx 	zTemp0+1
.1aa2	fa		plx				plx
.1aa3	86 28		stx $28				stx 	zTemp0
.1aa5	60		rts				rts
.1aa6					_GECallZTemp2:
.1aa6	6c 2c 00	jmp ($002c)			jmp 	(zTemp2)
.1aa9					_GEFetchZTemp0:
.1aa9	b2 28		lda ($28)			lda 	(zTemp0)
.1aab	e6 28		inc $28				inc 	zTemp0
.1aad	d0 02		bne $1ab1			bne 	_GEFZ0Skip
.1aaf	e6 29		inc $29				inc 	zTemp0+1
.1ab1					_GEFZ0Skip:
.1ab1	60		rts				rts
.1ab2					GEXCompileExpression:
.1ab2	a6 28		ldx $28				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.1ab4	da		phx				phx
.1ab5	a6 29		ldx $29				ldx 	zTemp0+1
.1ab7	da		phx				phx
.1ab8	20 6f 14	jsr $146f			jsr 	CompileExpressionAt0 		; compile expression.
.1abb	fa		plx				plx 								; recover generation exec
.1abc	86 29		stx $29				stx 	zTemp0+1
.1abe	fa		plx				plx
.1abf	86 28		stx $28				stx 	zTemp0
.1ac1	60		rts				rts
.1ac2					ChannelPrefix:
.1ac2	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.1ac4	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1ac7	20 b2 1a	jsr $1ab2			jsr 	GEXCompileExpression 		; channel #
.1aca	29 40		and #$40			and 	#NSSTypeMask
.1acc	c9 00		cmp #$00			cmp 	#NSSIFloat
.1ace	d0 09		bne $1ad9			bne 	_CPXType
.1ad0	20 8e 10	jsr $108e			jsr 	CheckNextComma 				; check , follows.
.1ad3	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.1ad5	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1ad8	60		rts				rts
.1ad9					_CPXType:
.1ad9	4c 6a 13	jmp $136a		jmp	ErrorV_type
.1adc					ChannelPostfix:
.1adc	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.1ade	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1ae1	60		rts				rts
.1ae2					OptionalParameterCompile:
.1ae2	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; what follows.
.1ae5	c9 2c		cmp #$2c			cmp 	#","
.1ae7	d0 0e		bne $1af7			bne 	_MidDefault
.1ae9	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume ,
.1aec	20 6f 14	jsr $146f			jsr 	CompileExpressionAt0
.1aef	29 40		and #$40			and 	#NSSTypeMask
.1af1	c9 00		cmp #$00			cmp 	#NSSIFloat
.1af3	d0 09		bne $1afe			bne 	MidFailType
.1af5	80 05		bra $1afc			bra 	_MidComplete
.1af7					_MidDefault:
.1af7	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1af9	20 4c 11	jsr $114c			jsr 	PushIntegerA
.1afc					_MidComplete:
.1afc	18		clc				clc
.1afd	60		rts				rts
.1afe					MidFailType:
.1afe	4c 6a 13	jmp $136a		jmp	ErrorV_type
.1b01					NotUnaryCompile:
.1b01	ad 24 15	lda $1524			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1b04	20 71 14	jsr $1471			jsr 	CompileExpressionAtA 		; evaluate at that level
.1b07	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1b09	c9 00		cmp #$00			cmp 	#NSSIFloat
.1b0b	d0 f1		bne $1afe			bne 	MidFailType
.1b0d	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1b0f	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1b12	60		rts				rts
.1b13					LookNext:
.1b13	b2 2e		lda ($2e)			lda 	(srcPtr)
.1b15	60		rts				rts
.1b16					LookNextNonSpace:
.1b16	b2 2e		lda ($2e)			lda 	(srcPtr)
.1b18	c9 20		cmp #$20			cmp		#' '
.1b1a	f0 03		beq $1b1f			beq 	_LNNSkip
.1b1c	c9 00		cmp #$00			cmp 	#0
.1b1e	60		rts				rts
.1b1f					_LNNSkip:
.1b1f	20 24 1b	jsr $1b24			jsr 	GetNext
.1b22	80 f2		bra $1b16			bra 	LookNextNonSpace
.1b24					GetNext:
.1b24	b2 2e		lda ($2e)			lda 	(srcPtr) 					; get next
.1b26	e6 2e		inc $2e				inc 	srcPtr
.1b28	d0 02		bne $1b2c			bne 	_GNSkip
.1b2a	e6 2f		inc $2f				inc 	srcPtr+1
.1b2c					_GNSkip:
.1b2c	c9 00		cmp #$00			cmp 	#0
.1b2e	60		rts				rts
.1b2f					GetNextNonSpace:
.1b2f	20 24 1b	jsr $1b24			jsr 	GetNext
.1b32	c9 20		cmp #$20			cmp 	#' '
.1b34	f0 f9		beq $1b2f			beq 	GetNextNonSpace
.1b36	c9 00		cmp #$00			cmp 	#0
.1b38	60		rts				rts
.1b39					CharIsDigit:
.1b39	c9 30		cmp #$30			cmp 	#"0"
.1b3b	90 06		bcc $1b43			bcc 	CCFalse
.1b3d	c9 3a		cmp #$3a			cmp 	#"9"+1
.1b3f	b0 02		bcs $1b43			bcs 	CCFalse
.1b41					CCTrue:
.1b41	38		sec				sec
.1b42	60		rts				rts
.1b43					CCFalse:
.1b43	18		clc				clc
.1b44	60		rts				rts
.1b45					CharIsAlpha:
.1b45	c9 41		cmp #$41			cmp 	#"A"
.1b47	90 fa		bcc $1b43			bcc 	CCFalse
.1b49	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1b4b	b0 f6		bcs $1b43			bcs 	CCFalse
.1b4d	80 f2		bra $1b41			bra 	CCTrue
.1b4f					ConvertHexStyle:
.1b4f	38		sec				sec
.1b50	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1b52	90 ef		bcc $1b43			bcc 	CCFalse
.1b54	c9 0a		cmp #$0a			cmp 	#9+1
.1b56	90 e9		bcc $1b41			bcc 	CCTrue
.1b58	38		sec				sec 								; shift into hex space A=>0 Z=>25
.1b59	e9 11		sbc #$11			sbc 	#"A"-"0"
.1b5b	90 e6		bcc $1b43			bcc 	CCFalse
.1b5d	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.1b5f	b0 e2		bcs $1b43			bcs 	CCFalse
.1b61	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.1b63	80 dc		bra $1b41			bra 	CCTrue
.1b65					CommandGET:
.1b65	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; # follows ?
.1b68	c9 23		cmp #$23			cmp 	#"#"
.1b6a	d0 0d		bne $1b79			bne 	CommandGetBody
.1b6c	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume #
.1b6f	20 c2 1a	jsr $1ac2			jsr 	ChannelPrefix 				; do it as GET#
.1b72	20 79 1b	jsr $1b79			jsr 	CommandGetBody
.1b75	20 dc 1a	jsr $1adc			jsr 	ChannelPostfix
.1b78	60		rts				rts
.1b79					CommandGetBody:
.1b79	20 2f 1b	jsr $1b2f			jsr 	GetNextNonSpace 			; get the first character
.1b7c	20 d4 1e	jsr $1ed4			jsr 	GetReferenceTerm 			; identify variable to assign to
.1b7f	48		pha				pha
.1b80	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1b82	c9 40		cmp #$40			cmp 	#NSSString
.1b84	d0 0b		bne $1b91			bne 	_CGType
.1b86	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1b88	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1b8b	38		sec				sec
.1b8c	68		pla				pla
.1b8d	20 86 1e	jsr $1e86			jsr		GetSetVariable
.1b90	60		rts				rts
.1b91					_CGType:
.1b91	4c 6a 13	jmp $136a		jmp	ErrorV_type
.1b94					ExtractVariableName:
.1b94	20 45 1b	jsr $1b45			jsr 	CharIsAlpha
.1b97	90 50		bcc $1be9			bcc 	_IVSyntax
.1b99	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.1b9b	85 2a		sta $2a				sta 	zTemp1 						; we'll build it in zTemp1
.1b9d	64 2b		stz $2b				stz 	zTemp1+1
.1b9f	20 13 1b	jsr $1b13			jsr 	LookNext 					; is there a second character ?
.1ba2	20 45 1b	jsr $1b45			jsr 	CharIsAlpha  				; must be alphanumeric
.1ba5	b0 05		bcs $1bac			bcs 	_IVHasSecond
.1ba7	20 39 1b	jsr $1b39			jsr 	CharIsDigit
.1baa	90 07		bcc $1bb3			bcc 	_IVCheckType
.1bac					_IVHasSecond:
.1bac	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.1bae	85 2b		sta $2b				sta 	zTemp1+1
.1bb0					_IVGetNextCheck:
.1bb0	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume it
.1bb3					_IVCheckType:
.1bb3	20 13 1b	jsr $1b13			jsr 	LookNext					; check if string follows.
.1bb6	20 45 1b	jsr $1b45			jsr 	CharIsAlpha
.1bb9	b0 f5		bcs $1bb0			bcs 	_IVGetNextCheck
.1bbb	20 39 1b	jsr $1b39			jsr 	CharIsDigit
.1bbe	b0 f0		bcs $1bb0			bcs 	_IVGetNextCheck
.1bc0	a2 40		ldx #$40			ldx 	#NSSString
.1bc2	c9 24		cmp #$24			cmp 	#"$"
.1bc4	f0 06		beq $1bcc			beq 	_IVHasType
.1bc6	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.1bc8	c9 25		cmp #$25			cmp 	#"%"
.1bca	d0 08		bne $1bd4			bne 	_IVCheckArray
.1bcc					_IVHasType:
.1bcc	8a		txa				txa 								; Or X into zTemp1
.1bcd	05 2a		ora $2a				ora 	zTemp1
.1bcf	85 2a		sta $2a				sta 	zTemp1
.1bd1	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume it
.1bd4					_IVCheckArray:
.1bd4	20 13 1b	jsr $1b13			jsr 	LookNext 					; check if array follows
.1bd7	c9 28		cmp #$28			cmp 	#"("
.1bd9	d0 09		bne $1be4			bne 	_IVNotArray
.1bdb	a5 2a		lda $2a				lda 	zTemp1 						; set array bit
.1bdd	09 80		ora #$80			ora 	#NSSArray
.1bdf	85 2a		sta $2a				sta 	zTemp1
.1be1	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume it
.1be4					_IVNotArray:
.1be4	a6 2a		ldx $2a				ldx 	zTemp1
.1be6	a4 2b		ldy $2b				ldy 	zTemp1+1
.1be8	60		rts				rts
.1be9					_IVSyntax:
.1be9	4c 5a 13	jmp $135a		jmp	ErrorV_syntax
.1bec					CommandGOSUB:
.1bec	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1bee	20 ff 1b	jsr $1bff			jsr 	CompileBranchCommand
.1bf1	60		rts				rts
.1bf2					CommandGOAlt:
.1bf2	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1bf4	20 98 10	jsr $1098			jsr 	CheckNextA
.1bf7	80 00		bra $1bf9			bra 	CommandGOTO
.1bf9					CommandGOTO:
.1bf9	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1bfb	20 ff 1b	jsr $1bff			jsr 	CompileBranchCommand
.1bfe	60		rts				rts
.1bff					CompileBranchCommand:
.1bff	20 84 10	jsr $1084			jsr 	WriteCodeByte 				; write the command out.
.1c02	20 2f 1b	jsr $1b2f			jsr 	GetNextNonSpace
.1c05	20 d1 1d	jsr $1dd1			jsr 	ParseConstant 				; get constant into YA
.1c08	90 0f		bcc $1c19			bcc 	_CBCSyntax
.1c0a	48		pha				pha
.1c0b	a9 ff		lda #$ff			lda 	#$FF 						; no address yet.
.1c0d	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1c10	68		pla				pla 								; and compile the actual line number
.1c11	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1c14	98		tya				tya
.1c15	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1c18	60		rts				rts
.1c19					_CBCSyntax:
.1c19	4c 5a 13	jmp $135a		jmp	ErrorV_syntax
.1c1c					CommandIF:
.1c1c	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; what follows the tests ?
.1c1f	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1c21	f0 0f		beq $1c32			beq 	_CIGoto
.1c23	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1c25	20 98 10	jsr $1098			jsr 	CheckNextA
.1c28	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; THEN <number>
.1c2b	20 39 1b	jsr $1b39			jsr 	CharIsDigit
.1c2e	b0 05		bcs $1c35			bcs 	_CIGoto2
.1c30	80 09		bra $1c3b			bra 	CompileGotoEOL
.1c32					_CIGoto:
.1c32	20 24 1b	jsr $1b24			jsr 	GetNext
.1c35					_CIGoto2:
.1c35	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1c37	20 ff 1b	jsr $1bff			jsr 	CompileBranchCommand
.1c3a	60		rts				rts
.1c3b					CompileGotoEOL:
.1c3b	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.1c3d	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1c40	a9 ff		lda #$ff			lda 	#$FF
.1c42	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1c45	20 da 1c	jsr $1cda			jsr 	GetLineNumber 				; Get the current line number => YA
.1c48	1a		inc a				inc 	a 							; and branch to +1
.1c49	d0 01		bne $1c4c			bne 	_CGENoCarry
.1c4b	c8		iny				iny
.1c4c					_CGENoCarry:
.1c4c	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1c4f	98		tya				tya
.1c50	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1c53	60		rts				rts
.1c54					CommandINPUT:
.1c54	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; check for "
.1c57	c9 22		cmp #$22			cmp 	#'"'
.1c59	d0 0d		bne $1c68			bne 	CommandINPUTStream
.1c5b	20 6f 14	jsr $146f			jsr 	CompileExpressionAt0
.1c5e	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1c60	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1c63	a9 2c		lda #$2c			lda 	#","
.1c65	20 8e 10	jsr $108e			jsr 	CheckNextComma
.1c68					CommandINPUTStream:
.1c68	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1c6a	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1c6d	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.1c6f	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1c71	4c 4e 1e	jmp $1e4e			jmp 	CommandReadInputCommon
.1c74					CommandLET:
.1c74	20 2f 1b	jsr $1b2f			jsr 	GetNextNonSpace 			; get the first character
.1c77					CommandLETHaveFirst:
.1c77	20 d4 1e	jsr $1ed4			jsr 	GetReferenceTerm 			; identify variable to assign to
.1c7a	da		phx				phx 								; save target on the stack.
.1c7b	5a		phy				phy
.1c7c	48		pha				pha
.1c7d	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.1c7f	20 98 10	jsr $1098			jsr 	CheckNextA
.1c82	20 6f 14	jsr $146f			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1c85	85 28		sta $28				sta 	zTemp0 						; save type returned
.1c87	68		pla				pla 								; get type of assignment
.1c88	48		pha				pha
.1c89	45 28		eor $28				eor 	zTemp0 						; compare using EOR
.1c8b	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.1c8d	d0 17		bne $1ca6			bne 	_CLType
.1c8f	68		pla				pla 								; restore and compile save code
.1c90	7a		ply				ply
.1c91	fa		plx				plx
.1c92	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.1c94	f0 05		beq $1c9b			beq 	_CLTIString
.1c96	38		sec				sec
.1c97	20 86 1e	jsr $1e86			jsr		GetSetVariable
.1c9a	60		rts				rts
.1c9b					_CLTIString:
.1c9b	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.1c9d	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1ca0	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.1ca2	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1ca5	60		rts				rts
.1ca6					_CLType:
.1ca6	4c 6a 13	jmp $136a		jmp	ErrorV_type
.1ca9					ReadNextLine:
.1ca9	20 a8 16	jsr $16a8			jsr 	INPUTGet 					; check offset is not zero.
.1cac	85 28		sta $28				sta 	zTemp0
.1cae	20 a8 16	jsr $16a8			jsr 	INPUTGet
.1cb1	05 28		ora $28				ora 	zTemp0
.1cb3	d0 02		bne $1cb7			bne 	_RNLBody
.1cb5	18		clc				clc
.1cb6	60		rts				rts						; end of file.
.1cb7					_RNLBody:
.1cb7	20 a8 16	jsr $16a8			jsr 	INPUTGet 					; read and save line number
.1cba	8d 00 05	sta $0500			sta 	currentLineNumber
.1cbd	20 a8 16	jsr $16a8			jsr 	INPUTGet
.1cc0	8d 01 05	sta $0501			sta 	currentLineNumber+1
.1cc3	a2 00		ldx #$00			ldx 	#0 							; read line into buffer
.1cc5					_RNLRead:
.1cc5	20 a8 16	jsr $16a8			jsr 	INPUTGet
.1cc8	9d 00 04	sta $0400,x			sta 	sourceBuffer,x
.1ccb	e8		inx				inx
.1ccc	c9 00		cmp #$00			cmp 	#0
.1cce	d0 f5		bne $1cc5			bne 	_RNLRead
.1cd0	a9 00		lda #$00			lda 	#((sourceBuffer) & $FF)
.1cd2	85 2e		sta $2e				sta 	0+srcPtr
.1cd4	a9 04		lda #$04			lda 	#((sourceBuffer) >> 8) & $FF
.1cd6	85 2f		sta $2f				sta 	1+srcPtr
.1cd8	38		sec				sec
.1cd9	60		rts				rts
.1cda					GetLineNumber:
.1cda	ac 01 05	ldy $0501			ldy 	currentLineNumber+1
.1cdd	ad 00 05	lda $0500			lda 	currentLineNumber
.1ce0	60		rts				rts
.1ce1					STRMarkLine:
.1ce1	48		pha				pha
.1ce2	38		sec				sec 								; allocate 5 bytes (line #, page+address)
.1ce3	ad 0f 06	lda $060f			lda 	lineNumberTable 			; and copy to zTemp0
.1ce6	e9 05		sbc #$05			sbc 	#5
.1ce8	8d 0f 06	sta $060f			sta 	lineNumberTable
.1ceb	85 28		sta $28				sta 	zTemp0
.1ced	ad 10 06	lda $0610			lda 	lineNumberTable+1
.1cf0	e9 00		sbc #$00			sbc 	#0
.1cf2	8d 10 06	sta $0610			sta 	lineNumberTable+1
.1cf5	85 29		sta $29				sta 	zTemp0+1
.1cf7	68		pla				pla
.1cf8	92 28		sta ($28)			sta 	(zTemp0) 					; save it in +0,+1
.1cfa	98		tya				tya
.1cfb	a0 01		ldy #$01			ldy 	#1
.1cfd	91 28		sta ($28),y			sta 	(zTemp0),y
.1cff	a5 27		lda $27				lda 	objPage 					; and page# in +2
.1d01	c8		iny				iny
.1d02	91 28		sta ($28),y			sta 	(zTemp0),y
.1d04	a5 25		lda $25				lda 	objPtr 						; save current address in +3,+4
.1d06	c8		iny				iny
.1d07	91 28		sta ($28),y			sta 	(zTemp0),y
.1d09	a5 26		lda $26				lda 	objPtr+1
.1d0b	c8		iny				iny
.1d0c	91 28		sta ($28),y			sta 	(zTemp0),y
.1d0e	60		rts				rts
.1d0f					STRFindLine:
.1d0f	85 28		sta $28				sta 	zTemp0 						; zTemp0 line number being searched
.1d11	84 29		sty $29				sty 	zTemp0+1
.1d13	a9 00		lda #$00			lda 	#((WorkArea+WorkAreaSize) & $FF)
.1d15	85 2a		sta $2a				sta 	0+zTemp1
.1d17	a9 9f		lda #$9f			lda 	#((WorkArea+WorkAreaSize) >> 8) & $FF
.1d19	85 2b		sta $2b				sta 	1+zTemp1
.1d1b					_STRSearch:
.1d1b	20 56 1d	jsr $1d56			jsr 	_STRPrevLine 				; look at previous record.
.1d1e	a0 01		ldy #$01			ldy 	#1
.1d20	b2 2a		lda ($2a)			lda 	(zTemp1) 					; check table line # >= target
.1d22	c5 28		cmp $28				cmp 	zTemp0
.1d24	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.1d26	e5 29		sbc $29				sbc 	zTemp0+1
.1d28	b0 0b		bcs $1d35			bcs 	_STRFound 					; >=
.1d2a					_STRNext:
.1d2a	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1d2c	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.1d2e	c9 ff		cmp #$ff			cmp 	#$FF
.1d30	d0 e9		bne $1d1b			bne 	_STRSearch
.1d32	4c b4 13	jmp $13b4		jmp	ErrorV_internal
.1d35					_STRFound:
.1d35	b2 2a		lda ($2a)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1d37	45 28		eor $28				eor 	zTemp0
.1d39	d0 06		bne $1d41			bne 	_STRDifferent
.1d3b	b2 2a		lda ($2a)			lda 	(zTemp1)
.1d3d	45 28		eor $28				eor 	zTemp0
.1d3f	f0 02		beq $1d43			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1d41					_STRDifferent:
.1d41	a9 ff		lda #$ff			lda 	#$FF
.1d43					_STROut:
.1d43	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1d44	69 ff		adc #$ff			adc 	#255
.1d46	08		php				php
.1d47	c8		iny				iny 								; page into X
.1d48	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.1d4a	aa		tax				tax
.1d4b	c8		iny				iny 								; address into YA
.1d4c	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.1d4e	48		pha				pha
.1d4f	c8		iny				iny
.1d50	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.1d52	a8		tay				tay
.1d53	68		pla				pla
.1d54	28		plp				plp
.1d55	60		rts				rts
.1d56					_STRPrevLine:
.1d56	38		sec				sec 								; move backwards one entry.
.1d57	a5 2a		lda $2a				lda 	zTemp1
.1d59	e9 05		sbc #$05			sbc 	#5
.1d5b	85 2a		sta $2a				sta 	zTemp1
.1d5d	a5 2b		lda $2b				lda 	zTemp1+1
.1d5f	e9 00		sbc #$00			sbc 	#0
.1d61	85 2b		sta $2b				sta 	zTemp1+1
.1d63	60		rts				rts
.1d64					STRMakeOffset:
.1d64	18		clc				clc 								; borrow 1
.1d65	e5 25		sbc $25				sbc 	objPtr
.1d67	48		pha				pha
.1d68	98		tya				tya
.1d69	e5 26		sbc $26				sbc 	objPtr+1
.1d6b	a8		tay				tay
.1d6c	68		pla				pla
.1d6d	60		rts				rts
.1d6e					CommandNEXT:
.1d6e	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1d71	20 45 1b	jsr $1b45			jsr 	CharIsAlpha 				; if not alpha , error
.1d74	90 0c		bcc $1d82			bcc 	_CNNoReferenceGiven
.1d76	20 24 1b	jsr $1b24			jsr 	GetNext
.1d79	20 d4 1e	jsr $1ed4			jsr 	GetReferenceTerm 			; figure out the reference.
.1d7c	8a		txa				txa 								; reference in YA
.1d7d	20 39 11	jsr $1139			jsr 	PushIntegerYA 				; write it out.
.1d80	80 06		bra $1d88			bra 	_CNParametersDone
.1d82					_CNNoReferenceGiven:
.1d82	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1d84	a8		tay				tay
.1d85	20 39 11	jsr $1139			jsr 	PushIntegerYA 				; write it out.
.1d88					_CNParametersDone:
.1d88	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1d8a	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1d8d	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; look for ,
.1d90	c9 2c		cmp #$2c			cmp 	#","
.1d92	d0 05		bne $1d99			bne 	_CNExit
.1d94	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume ,
.1d97	80 d5		bra $1d6e			bra 	CommandNEXT 				; and go round.
.1d99					_CNExit:
.1d99	60		rts				rts
.1d9a					CommandON:
.1d9a	20 2f 1b	jsr $1b2f			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1d9d	48		pha				pha 								; save on stack
.1d9e	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1da0	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1da2	f0 09		beq $1dad			beq 	_COCreateLoop
.1da4	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1da6	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1da8	f0 03		beq $1dad			beq 	_COCreateLoop
.1daa	4c 5a 13	jmp $135a		jmp	ErrorV_syntax
.1dad					_COCreateLoop:
.1dad	8a		txa				txa 								; compile a goto/gosub somewhere
.1dae	da		phx				phx
.1daf	20 ff 1b	jsr $1bff			jsr 	CompileBranchCommand
.1db2	fa		plx				plx
.1db3	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace			; ',' follows
.1db6	c9 2c		cmp #$2c			cmp 	#","
.1db8	d0 0a		bne $1dc4			bne 	_COComplete 				; if so, more line numbers
.1dba	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1dbc	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1dbf	20 24 1b	jsr $1b24			jsr 	GetNext
.1dc2	80 e9		bra $1dad			bra 	_COCreateLoop
.1dc4					_COComplete:
.1dc4	68		pla				pla 								; throw GOTO/GOSUB
.1dc5	60		rts				rts
.1dc6					OUTPUTOpen:
.1dc6					OUTPUTRewind:
.1dc6	64 27		stz $27				stz 	objPage
.1dc8	a9 00		lda #$00			lda 	#((PCodeStart) & $FF)
.1dca	85 25		sta $25				sta 	0+objPtr
.1dcc	a9 40		lda #$40			lda 	#((PCodeStart) >> 8) & $FF
.1dce	85 26		sta $26				sta 	1+objPtr
.1dd0	60		rts				rts
.1dd1					ParseConstant:
.1dd1	a2 00		ldx #$00			ldx 	#0
.1dd3	20 4e 24	jsr $244e			jsr 	FloatEncodeStart 			; send first
.1dd6					_ParseLoop:
.1dd6	20 13 1b	jsr $1b13			jsr 	LookNext 					; send subsequent
.1dd9	20 51 24	jsr $2451			jsr 	FloatEncodeContinue
.1ddc	90 05		bcc $1de3			bcc 	_ParseDone
.1dde	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume it
.1de1	80 f3		bra $1dd6			bra 	_ParseLoop
.1de3					_ParseDone:
.1de3	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1de5	29 80		and #$80			and 	#$80
.1de7	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.1de9	15 56		ora $56,x			ora 	NSMantissa2,x
.1deb	15 62		ora $62,x			ora 	NSMantissa3,x
.1ded	18		clc				clc
.1dee	d0 05		bne $1df5			bne 	_ParseExit 					; exit with CC if need float to compile
.1df0	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.1df2	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.1df4	38		sec				sec
.1df5					_ParseExit:
.1df5	60		rts				rts
.1df6					MOFSizeTable:
>1df6	01					.byte	1         	; $ca .shift
>1df7	01					.byte	1         	; $cb .byte
>1df8	02					.byte	2         	; $cc .word
>1df9	05					.byte	5         	; $cd .float
>1dfa	ff					.byte	255       	; $ce .string
>1dfb	ff					.byte	255       	; $cf .data
>1dfc	03					.byte	3         	; $d0 .goto
>1dfd	03					.byte	3         	; $d1 .gosub
>1dfe	03					.byte	3         	; $d2 .goto.z
>1dff	03					.byte	3         	; $d3 .goto.nz
>1e00	02					.byte	2         	; $d4 .varspace
.1e01					CommandPRINT:
.1e01	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace			; what follows ?
.1e04	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1e06	f0 1f		beq $1e27			beq 	_CPCheckEnd
.1e08	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1e0a	f0 16		beq $1e22			beq 	_CPTabCheckEnd
.1e0c	20 3e 1e	jsr $1e3e			jsr 	_CPAtEnd 					; check for : and EOL
.1e0f	b0 22		bcs $1e33			bcs 	_CPExitCR 					; exit with CR
.1e11	20 6f 14	jsr $146f			jsr 	CompileExpressionAt0 		; so it is something to print
.1e14	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1e16	29 40		and #$40			and 	#NSSString 					; if string
.1e18	d0 02		bne $1e1c			bne 	_CPOut
.1e1a	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1e1c					_CPOut:
.1e1c	8a		txa				txa 								; print that thing
.1e1d	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1e20	80 df		bra $1e01			bra 	CommandPRINT 				; and loop round/
.1e22					_CPTabCheckEnd:
.1e22	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1e24	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1e27					_CPCheckEnd:
.1e27	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume it.
.1e2a	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; what follows ?
.1e2d	20 3e 1e	jsr $1e3e			jsr 	_CPAtEnd 					; reached end
.1e30	90 cf		bcc $1e01			bcc 	CommandPRINT 				; no, loop back
.1e32	60		rts				rts
.1e33					_CPExitCR:
.1e33	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1e35	20 4c 11	jsr $114c			jsr 	PushIntegerA
.1e38	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1e3a	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1e3d	60		rts				rts
.1e3e					_CPAtEnd:
.1e3e	c9 00		cmp #$00			cmp 	#0
.1e40	f0 06		beq $1e48			beq 	_CPIsEnd
.1e42	c9 3a		cmp #$3a			cmp 	#":"
.1e44	f0 02		beq $1e48			beq 	_CPIsEnd
.1e46	18		clc				clc
.1e47	60		rts				rts
.1e48					_CPIsEnd:
.1e48	38		sec				sec
.1e49	60		rts				rts
.1e4a					CommandREAD:
.1e4a	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1e4c	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1e4e					CommandReadInputCommon:
.1e4e	8e 0d 06	stx $060d			stx 	numberPCode
.1e51	8c 0e 06	sty $060e			sty 	stringPCode
.1e54					_CRLoop:
.1e54	20 2f 1b	jsr $1b2f			jsr 	GetNextNonSpace 			; first char of identifier
.1e57	20 45 1b	jsr $1b45			jsr 	CharIsAlpha 				; check A-Z
.1e5a	90 27		bcc $1e83			bcc 	_CRSyntax
.1e5c	20 d4 1e	jsr $1ed4			jsr 	GetReferenceTerm 			; get the variable.
.1e5f	48		pha				pha 								; save type.
.1e60	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1e62	c9 40		cmp #$40			cmp 	#NSSString
.1e64	f0 05		beq $1e6b			beq 	_CRString
.1e66	ad 0d 06	lda $060d			lda 	numberPCode 				; output read/input
.1e69	80 03		bra $1e6e			bra 	_CRHaveType
.1e6b					_CRString:
.1e6b	ad 0e 06	lda $060e			lda 	stringPCode					; output read$/input$
.1e6e					_CRHaveType:
.1e6e	20 84 10	jsr $1084			jsr 	WriteCodeByte 				; so we have one typed data item.
.1e71	68		pla				pla 								; restore type
.1e72	38		sec				sec  								; write update code.
.1e73	20 86 1e	jsr $1e86			jsr 	GetSetVariable
.1e76	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; , follows ?
.1e79	c9 2c		cmp #$2c			cmp 	#","
.1e7b	d0 05		bne $1e82			bne 	_CRExit 					; if not, end of READ.
.1e7d	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume comma
.1e80	80 d2		bra $1e54			bra 	_CRLoop 					; keep going
.1e82					_CRExit:
.1e82	60		rts				rts
.1e83					_CRSyntax:
.1e83	4c 5a 13	jmp $135a		jmp	ErrorV_syntax
.060d					numberPCode:
>060d							.fill 	1
.060e					stringPCode:
>060e							.fill 	1
.1e86					GetSetVariable:
.1e86	08		php				php 								; save direction on stack
.1e87	c0 00		cpy #$00			cpy 	#$00
.1e89	30 21		bmi $1eac			bmi 	_GSVReadWriteSpecial
.1e8b	c9 00		cmp #$00			cmp 	#$00
.1e8d	30 33		bmi $1ec2			bmi 	_GSVArray
.1e8f	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1e91	4a		lsr a				lsr 	a 							; divide by 2
.1e92	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1e94	28		plp				plp
.1e95	90 02		bcc $1e99			bcc 	_GSVNotWrite
.1e97	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1e99					_GSVNotWrite:
.1e99	85 28		sta $28				sta 	zTemp0
.1e9b	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1e9c	4a		lsr a				lsr 	a
.1e9d	a8		tay				tay
.1e9e	8a		txa				txa
.1e9f	6a		ror a				ror 	a
.1ea0	aa		tax				tax
.1ea1	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1ea2	05 28		ora $28				ora 	zTemp0 						; which is the first byte of the opcode
.1ea4	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1ea7	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1ea8	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1eab	60		rts				rts
.1eac					_GSVReadWriteSpecial:
.1eac	28		plp				plp
.1ead	b0 10		bcs $1ebf			bcs 	_GSVSyntax
.1eaf	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1eb1	f0 06		beq $1eb9			beq 	_GSVRWString
.1eb3	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1eb5	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1eb8	60		rts				rts
.1eb9					_GSVRWString:
.1eb9	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1ebb	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1ebe	60		rts				rts
.1ebf					_GSVSyntax:
.1ebf	4c 5a 13	jmp $135a		jmp	ErrorV_syntax
.1ec2					_GSVArray:
.1ec2	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1ec4	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1ec5	4a		lsr a				lsr 	a
.1ec6	4a		lsr a				lsr 	a
.1ec7	4a		lsr a				lsr 	a
.1ec8	4a		lsr a				lsr 	a
.1ec9	28		plp				plp 								; if writing array then set bit 2.
.1eca	90 02		bcc $1ece			bcc 	_GSVANotWrite
.1ecc	09 04		ora #$04			ora 	#4
.1ece					_GSVANotWrite:
.1ece	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1ed0	20 84 10	jsr $1084			jsr 	WriteCodeByte 				; and write it out
.1ed3	60		rts				rts
.1ed4					GetReferenceTerm:
.1ed4	20 94 1b	jsr $1b94			jsr 	ExtractVariableName 		; get name & type info
.1ed7	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1ed9	30 10		bmi $1eeb			bmi 	_GRTArray
.1edb	da		phx				phx 								; save type on stack
.1edc	20 29 15	jsr $1529			jsr 	FindVariable 				; find it
.1edf	b0 06		bcs $1ee7			bcs 	_GRTNoCreate 				; create if required.
.1ee1	20 7e 11	jsr $117e			jsr 	CreateVariableRecord 		; create a variable.
.1ee4	20 d8 11	jsr $11d8			jsr 	AllocateBytesForType 		; allocate memory for it
.1ee7					_GRTNoCreate:
.1ee7	68		pla				pla 								; get type back, strip out type information.
.1ee8	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1eea	60		rts				rts
.1eeb					_GRTArray:
.1eeb	da		phx				phx 								; save type information
.1eec	20 29 15	jsr $1529			jsr 	FindVariable 				; read its data, the base address in YX
.1eef	90 18		bcc $1f09			bcc 	_GRTUndeclared 				; undeclared array.
.1ef1	da		phx				phx 								; save base address
.1ef2	5a		phy				phy
.1ef3	20 cf 12	jsr $12cf			jsr 	OutputIndexGroup 			; create an index group and generate them
.1ef6	7a		ply				ply 								; get the array base address into YX
.1ef7	fa		plx				plx
.1ef8	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1efa	18		clc				clc
.1efb	20 86 1e	jsr $1e86			jsr 	GetSetVariable 				; load the address of the array structure.
.1efe	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1f00	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1f03	68		pla				pla 								; and the type data into A
.1f04	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1f06	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1f08	60		rts				rts
.1f09					_GRTUndeclared:
.1f09	4c 11 14	jmp $1411		jmp	ErrorV_undeclared
.1f0c					CommandREM:
.1f0c	20 13 1b	jsr $1b13			jsr 	LookNext
.1f0f	f0 05		beq $1f16			beq 	_CRExit
.1f11	20 24 1b	jsr $1b24			jsr 	GetNext
.1f14	80 f6		bra $1f0c			bra 	CommandREM
.1f16					_CRExit:
.1f16	60		rts				rts
.1f17					STRReset:
.1f17	a9 00		lda #$00			lda 	#((WorkArea) & $FF)
.1f19	8d 11 06	sta $0611			sta 	0+variableListEnd
.1f1c	a9 80		lda #$80			lda 	#((WorkArea) >> 8) & $FF
.1f1e	8d 12 06	sta $0612			sta 	1+variableListEnd
.1f21	a9 00		lda #$00			lda 	#((WorkArea+WorkAreaSize) & $FF)
.1f23	8d 0f 06	sta $060f			sta 	0+lineNumberTable
.1f26	a9 9f		lda #$9f			lda 	#((WorkArea+WorkAreaSize) >> 8) & $FF
.1f28	8d 10 06	sta $0610			sta 	1+lineNumberTable
.1f2b	9c 00 80	stz $8000			stz 	WorkArea
.1f2e	a9 00		lda #$00			lda 	#((0) & $FF)
.1f30	8d 13 06	sta $0613			sta 	0+freeVariableMemory
.1f33	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1f35	8d 14 06	sta $0614			sta 	1+freeVariableMemory
.1f38	60		rts				rts
.060f					lineNumberTable:
>060f							.fill 	2
.0611					variableListEnd:
>0611							.fill 	2
.0613					freeVariableMemory:
>0613							.fill 	2
.1f39					CompileTerm:
.1f39	20 2f 1b	jsr $1b2f			jsr 	GetNextNonSpace 			; get first non space character.
.1f3c	30 72		bmi $1fb0			bmi 	_CTUnaryFunctions
.1f3e	20 39 1b	jsr $1b39			jsr 	CharIsDigit 				; found a number
.1f41	b0 3a		bcs $1f7d			bcs 	_CTDigit
.1f43	c9 2e		cmp #$2e			cmp 	#"."
.1f45	f0 36		beq $1f7d			beq 	_CTDigit
.1f47	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1f49	f0 43		beq $1f8e			beq 	_CTString
.1f4b	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1f4d	f0 28		beq $1f77			beq 	_CTOtherBase
.1f4f	c9 24		cmp #$24			cmp 	#"$"
.1f51	f0 24		beq $1f77			beq 	_CTOtherBase
.1f53	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1f55	f0 17		beq $1f6e			beq 	_CTBrackets
.1f57	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1f59	90 10		bcc $1f6b			bcc 	_CTSyntax
.1f5b	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1f5d	b0 0c		bcs $1f6b			bcs 	_CTSyntax
.1f5f	20 d4 1e	jsr $1ed4			jsr 	GetReferenceTerm 			; figure out what it is.
.1f62	48		pha				pha 								; save type on stack
.1f63	18		clc				clc 								; read it
.1f64	20 86 1e	jsr $1e86			jsr 	GetSetVariable
.1f67	68		pla				pla
.1f68	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1f6a	60		rts				rts
.1f6b					_CTSyntax:
.1f6b	4c 5a 13	jmp $135a		jmp	ErrorV_syntax
.1f6e					_CTBrackets:
.1f6e	20 6f 14	jsr $146f			jsr 	CompileExpressionAt0
.1f71	48		pha				pha
.1f72	20 92 10	jsr $1092			jsr 	CheckNextRParen
.1f75	68		pla				pla
.1f76	60		rts				rts
.1f77					_CTOtherBase:
.1f77	20 12 10	jsr $1012			jsr 	InlineNonDecimal 			; non decimal constant handler
.1f7a	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1f7c	60		rts				rts
.1f7d					_CTDigit:
.1f7d	20 d1 1d	jsr $1dd1			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1f80	90 06		bcc $1f88			bcc	 	_CTFloat 					; have a float or long int.
.1f82	20 39 11	jsr $1139			jsr 	PushIntegerYA 				; code to push on stack
.1f85	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1f87	60		rts				rts
.1f88					_CTFloat:
.1f88	20 5b 11	jsr $115b			jsr 	PushFloat  					; code to push float
.1f8b	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1f8d	60		rts				rts
.1f8e					_CTString:
.1f8e	20 5d 10	jsr $105d			jsr 	BufferClear 				; copy it to the buffer
.1f91					_CTStringLoop:
.1f91	20 13 1b	jsr $1b13			jsr 	LookNext 					; reached EOL/EOS
.1f94	f0 d5		beq $1f6b			beq 	_CTSyntax
.1f96	c9 22		cmp #$22			cmp 	#'"'
.1f98	f0 08		beq $1fa2			beq 	_CTStringDone
.1f9a	20 61 10	jsr $1061			jsr 	BufferWrite 				; write and consume
.1f9d	20 24 1b	jsr $1b24			jsr 	GetNext
.1fa0	80 ef		bra $1f91			bra 	_CTStringLoop
.1fa2					_CTStringDone:
.1fa2	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume closing quote.
.1fa5	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1fa7	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1faa	20 6d 10	jsr $106d			jsr 	BufferOutput
.1fad	a9 40		lda #$40			lda 	#NSSString 					; string type
.1faf	60		rts				rts
.1fb0					_CTUnaryFunctions:
.1fb0	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1fb2	f0 0a		beq $1fbe			beq 	_CTNegation
.1fb4	a2 be		ldx #$be			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1fb6	a0 18		ldy #$18			ldy 	#UnaryTables >> 8
.1fb8	20 b8 19	jsr $19b8			jsr 	GeneratorProcess
.1fbb	90 ae		bcc $1f6b			bcc		_CTSyntax
.1fbd	60		rts				rts
.1fbe					_CTNegation:
.1fbe	20 39 1f	jsr $1f39			jsr 	CompileTerm 				; compile a term.
.1fc1	48		pha				pha
.1fc2	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1fc4	c9 00		cmp #$00			cmp 	#NSSIFloat
.1fc6	d0 07		bne $1fcf			bne 	_CTType 					; error
.1fc8	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1fca	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1fcd	68		pla				pla 								; return original type.
.1fce	60		rts				rts
.1fcf					_CTType:
.1fcf	4c 6a 13	jmp $136a		jmp	ErrorV_type
.1fd2					CommandWAIT:
.1fd2	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace
.1fd5	c9 2c		cmp #$2c			cmp 	#","
.1fd7	f0 10		beq $1fe9			beq 	_CWThirdParameter
.1fd9	a9 00		lda #$00			lda 	#0
.1fdb	20 4c 11	jsr $114c			jsr 	PushIntegerA
.1fde					_CWExit:
.1fde	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1fe0	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1fe3	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1fe5	20 84 10	jsr $1084			jsr 	WriteCodeByte
.1fe8	60		rts				rts
.1fe9					_CWThirdParameter:
.1fe9	20 24 1b	jsr $1b24			jsr 	GetNext
.1fec	20 71 14	jsr $1471			jsr 	CompileExpressionAtA
.1fef	29 40		and #$40			and 	#NSSTypeMask
.1ff1	c9 00		cmp #$00			cmp 	#NSSIFloat
.1ff3	f0 e9		beq $1fde			beq 	_CWExit
.1ff5	4c 6a 13	jmp $136a		jmp	ErrorV_type
.1ff8					OUTPUTWriteByte:
.1ff8	92 25		sta ($25)			sta 	(objPtr)
.1ffa	e6 25		inc $25				inc 	objPtr
.1ffc	d0 02		bne $2000			bne 	_HWOWBNoCarry
.1ffe	e6 26		inc $26				inc 	objPtr+1
.2000					_HWOWBNoCarry:
.2000	60		rts				rts
.2001					CommandCMD:
.2001	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.2003	20 84 10	jsr $1084			jsr 	WriteCodeByte
.2006	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; followed by a , ?
.2009	c9 2c		cmp #$2c			cmp 	#","
.200b	d0 06		bne $2013			bne 	_CCMDExit
.200d	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume comma.
.2010	20 01 1e	jsr $1e01			jsr 	CommandPRINT 				; do the print code
.2013					_CCMDExit:
.2013	60		rts				rts
.2014					CommandOPEN:
.2014	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; followed by a , ?
.2017	c9 2c		cmp #$2c			cmp 	#","
.2019	d0 15		bne $2030			bne 	_COTwoDefaults
.201b	20 24 1b	jsr $1b24			jsr 	GetNext 					; consume comma
.201e	20 6f 14	jsr $146f			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.2021	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.2023	f0 1e		beq $2043			beq 	_COThreeIntegers
.2025	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.2027	20 4c 11	jsr $114c			jsr 	PushIntegerA
.202a	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.202c	20 84 10	jsr $1084			jsr 	WriteCodeByte
.202f	60		rts				rts
.2030					_COTwoDefaults:
.2030	a9 00		lda #$00			lda 	#0
.2032	20 4c 11	jsr $114c			jsr 	PushIntegerA
.2035					_COCompileNullString:
.2035	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.2037	20 84 10	jsr $1084			jsr 	WriteCodeByte
.203a	a9 00		lda #$00			lda 	#0
.203c	20 84 10	jsr $1084			jsr 	WriteCodeByte
.203f	20 84 10	jsr $1084			jsr 	WriteCodeByte
.2042	60		rts				rts
.2043					_COThreeIntegers:
.2043	20 16 1b	jsr $1b16			jsr 	LookNextNonSpace 			; is there a ,
.2046	c9 2c		cmp #$2c			cmp 	#","
.2048	d0 eb		bne $2035			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.204a	20 24 1b	jsr $1b24			jsr 	GetNext
.204d	20 6f 14	jsr $146f			jsr 	CompileExpressionAt0 		; should be a filename
.2050	29 40		and #$40			and 	#NSSString
.2052	f0 01		beq $2055			beq 	_COType
.2054	60		rts				rts
.2055					_COType:
.2055	4c 6a 13	jmp $136a		jmp	ErrorV_type
.2058					XPrintCharacter
.2058	48		pha				pha
.2059	da		phx				phx
.205a	5a		phy				phy
.205b	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.205e	7a		ply				ply
.205f	fa		plx				plx
.2060	68		pla				pla
.2061	60		rts				rts
.2062					XSaveMemory:
.2062	da		phx				phx
.2063	5a		phy				phy
.2064	48		pha				pha
.2065	a9 00		lda #$00			lda 	#0 							; set LFS
.2067	a2 08		ldx #$08			ldx 	#8
.2069	a0 00		ldy #$00			ldy 	#0
.206b	20 ba ff	jsr $ffba			jsr 	$FFBA
.206e	a9 08		lda #$08			lda 	#8 							; set file name
.2070	a2 84		ldx #$84			ldx 	#SaveName & $FF
.2072	a0 20		ldy #$20			ldy 	#SaveName >> 8
.2074	20 bd ff	jsr $ffbd			jsr 	$FFBD
.2077	68		pla				pla 								; set up the start address.
.2078	85 29		sta $29				sta 	zTemp0+1
.207a	64 28		stz $28				stz 	zTemp0
.207c	a9 28		lda #$28			lda 	#zTemp0 					; from index.
.207e	7a		ply				ply 								; end in YX
.207f	fa		plx				plx
.2080	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.2083	60		rts				rts
.2084					SaveName:
>2084	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0615					numberBuffer:
>0615							.fill 	34
.208c					FloatSubtract:
.208c	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.208e	49 80		eor #$80			eor 	#$80
.2090	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.2092					FloatAdd:
.2092	ca		dex				dex
.2093	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.2095	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2097	15 62		ora $62,x			ora 	NSMantissa3,x
.2099	15 63		ora $63,x			ora 	NSMantissa3+1,x
.209b	d0 04		bne $20a1			bne 	_FAUseFloat
.209d	20 2e 24	jsr $242e			jsr 	FloatInt32Add 				; use the int32 one.
.20a0	60		rts				rts
.20a1					_FAUseFloat:
.20a1	20 c3 23	jsr $23c3			jsr 	FloatNormalise 				; normalise S[X]
.20a4	f0 51		beq $20f7			beq 	_FAReturn1
.20a6	e8		inx				inx 								; normalise S[X+1]
.20a7	20 c3 23	jsr $23c3			jsr 	FloatNormalise
.20aa	ca		dex				dex
.20ab	c9 00		cmp #$00			cmp 	#0
.20ad	f0 60		beq $210f			beq 	_FAExit 					; if so, just return A
.20af	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20b1	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20b3	f0 18		beq $20cd			beq 	_FAExponentsEqual
.20b5	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20b7	a8		tay				tay
.20b8	38		sec				sec 								; do a signed comparison of the exponents.
.20b9	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20bb	50 02		bvc $20bf			bvc 	_FANoSignedChange
.20bd	49 80		eor #$80			eor 	#$80
.20bf					_FANoSignedChange:
.20bf	29 80		and #$80			and 	#$80
.20c1	10 02		bpl $20c5			bpl 	_FAHaveMax
.20c3	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.20c5					_FAHaveMax:
.20c5	20 10 21	jsr $2110			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20c8	e8		inx				inx
.20c9	20 10 21	jsr $2110			jsr 	_FAShiftToExponent
.20cc	ca		dex				dex
.20cd					_FAExponentsEqual:
.20cd	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.20cf	55 33		eor $33,x			eor 	NSStatus+1,x
.20d1	30 0e		bmi $20e1			bmi 	_FADifferentSigns
.20d3	20 fa 23	jsr $23fa			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20d6	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20d8	10 35		bpl $210f			bpl 	_FAExit 					; if no, we are done.
.20da	20 87 26	jsr $2687			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20dd	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.20df	80 2e		bra $210f			bra 	_FAExit
.20e1					_FADifferentSigns:
.20e1	20 14 24	jsr $2414			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20e4	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.20e6	10 06		bpl $20ee			bpl 	_FACheckZero 				; if no, check for -0
.20e8	20 30 26	jsr $2630			jsr 	FloatNegate 					; netate result
.20eb	20 37 26	jsr $2637			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20ee					_FACheckZero:
.20ee	20 90 26	jsr $2690			jsr 	FloatIsZero	 				; check for -0
.20f1	d0 1c		bne $210f			bne 	_FAExit
.20f3	74 32		stz $32,x			stz 	NSStatus,x
.20f5	80 18		bra $210f			bra 	_FAExit
.20f7					_FAReturn1:
.20f7	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20f9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20fb	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.20fd	95 4a		sta $4a,x			sta 	NSMantissa1,x
.20ff	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.2101	95 56		sta $56,x			sta 	NSMantissa2,x
.2103	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.2105	95 62		sta $62,x			sta 	NSMantissa3,x
.2107	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.2109	95 6e		sta $6e,x			sta 	NSExponent,x
.210b	b5 33		lda $33,x			lda 	NSStatus+1,x
.210d	95 32		sta $32,x			sta 	NSStatus,x
.210f					_FAExit:
.210f	60		rts				rts
.2110					_FAShiftToExponent:
.2110					_FAShiftToExponent2:
.2110	98		tya				tya 								; compare Y to exponent
.2111	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2113	f0 07		beq $211c			beq 	_FASEExit 					; exit if so.
.2115	20 87 26	jsr $2687			jsr 	FloatShiftRight	 			; shift the mantissa right
.2118	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.211a	80 f4		bra $2110			bra 	_FAShiftToExponent2
.211c					_FASEExit:
.211c	60		rts				rts
.211d					CompareEqual:
.211d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.211f	d0 09		bne $212a			bne 	ReturnFalse
.2121					ReturnTrue:
.2121	a9 01		lda #$01			lda 	#1
.2123	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2125	a9 80		lda #$80			lda 	#$80
.2127	95 32		sta $32,x			sta 	NSStatus,x
.2129	60		rts				rts
.212a					ReturnFalse:
.212a	74 3e		stz $3e,x			stz 	NSMantissa0,x
.212c	60		rts				rts
.212d					CompareNotEqual:
.212d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.212f	d0 f0		bne $2121			bne 	ReturnTrue
.2131	80 f7		bra $212a			bra 	ReturnFalse
.2133					CompareLess:
.2133	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2135	c9 ff		cmp #$ff			cmp 	#$FF
.2137	f0 e8		beq $2121			beq 	ReturnTrue
.2139	80 ef		bra $212a			bra 	ReturnFalse
.213b					CompareGreater:
.213b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.213d	c9 01		cmp #$01			cmp 	#$01
.213f	f0 e0		beq $2121			beq 	ReturnTrue
.2141	80 e7		bra $212a			bra 	ReturnFalse
.2143					CompareLessEqual:
.2143	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2145	c9 01		cmp #$01			cmp 	#$01
.2147	d0 d8		bne $2121			bne 	ReturnTrue
.2149	80 df		bra $212a			bra 	ReturnFalse
.214b					CompareGreaterEqual:
.214b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.214d	c9 ff		cmp #$ff			cmp 	#$FF
.214f	d0 d0		bne $2121			bne 	ReturnTrue
.2151	80 d7		bra $212a			bra 	ReturnFalse
.2153					FloatCompare:
.2153	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.2155	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.2157	48		pha				pha
.2158	20 8c 20	jsr $208c			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.215b	68		pla				pla
.215c	d0 0c		bne $216a			bne 	_FCCompareFloat
.215e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2160	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2162	15 56		ora $56,x			ora 	NSMantissa2,x
.2164	15 62		ora $62,x			ora 	NSMantissa3,x
.2166	f0 14		beq $217c			beq 	_FCExit 					; if zero, return zero
.2168	80 0a		bra $2174			bra 	_FCSign
.216a					_FCCompareFloat:
.216a	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.216c	29 f0		and #$f0			and 	#$F0
.216e	15 56		ora $56,x			ora 	NSMantissa2,x
.2170	15 62		ora $62,x			ora 	NSMantissa3,x
.2172	f0 08		beq $217c			beq 	_FCExit 					; zero, so approximately identical
.2174					_FCSign:
.2174	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2176	34 32		bit $32,x			bit 	NSStatus,x
.2178	10 02		bpl $217c			bpl 	_FCExit
.217a					_FCNegative:
.217a	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.217c					_FCExit:
.217c	20 70 26	jsr $2670			jsr 	FloatSetByte 				; set the result 255,0,1
.217f	60		rts				rts
.2180					FloatScalarTable:
>2180	66 66 66 66				.dword $66666666 ; 0.1
>2184	de					.byte $de
>2185	1f 85 eb 51				.dword $51eb851f ; 0.01
>2189	db					.byte $db
>218a	4c 37 89 41				.dword $4189374c ; 0.001
>218e	d8					.byte $d8
>218f	ac 8b db 68				.dword $68db8bac ; 0.0001
>2193	d4					.byte $d4
>2194	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>2198	d1					.byte $d1
>2199	83 de 1b 43				.dword $431bde83 ; 1e-06
>219d	ce					.byte $ce
>219e	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21a2	ca					.byte $ca
>21a3	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21a7	c7					.byte $c7
>21a8	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21ac	c4					.byte $c4
>21ad	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21b1	c0					.byte $c0
>21b2	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21b6	bd					.byte $bd
.21b7					FloatDivide:
.21b7	48		pha				pha
.21b8	20 c3 23	jsr $23c3			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21bb	ca		dex				dex
.21bc	c9 00		cmp #$00			cmp 	#0
.21be	f0 1e		beq $21de			beq 	_FDZero
.21c0	20 c3 23	jsr $23c3			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21c3	f0 16		beq $21db			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21c5	20 26 22	jsr $2226			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21c8	20 f3 21	jsr $21f3			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21cb	20 c3 23	jsr $23c3			jsr		FloatNormalise 				; renormalise
.21ce	20 b9 23	jsr $23b9			jsr 	FloatCalculateSign 			; calculate result sign
.21d1	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.21d3	38		sec				sec
.21d4	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.21d6	38		sec				sec
.21d7	e9 1e		sbc #$1e			sbc 	#30
.21d9	95 6e		sta $6e,x			sta 	NSExponent,x
.21db					_FDExit:
.21db	68		pla				pla
.21dc	18		clc				clc
.21dd	60		rts				rts
.21de					_FDZero:
.21de	68		pla				pla
.21df	38		sec				sec
.21e0	60		rts				rts
.21e1					DivideInt32:
.21e1	20 a9 22	jsr $22a9			jsr 	FloatIntegerPart 			; make both integers
.21e4	ca		dex				dex
.21e5	20 a9 22	jsr $22a9			jsr 	FloatIntegerPart
.21e8	20 04 22	jsr $2204			jsr 	Int32Divide 				; divide
.21eb	20 f3 21	jsr $21f3			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21ee	20 b9 23	jsr $23b9			jsr 	FloatCalculateSign 			; calculate result sign
.21f1	18		clc				clc
.21f2	60		rts				rts
.21f3					NSMCopyPlusTwoToZero:
.21f3	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21f5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21f7	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21f9	95 4a		sta $4a,x			sta 	NSMantissa1,x
.21fb	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.21fd	95 56		sta $56,x			sta 	NSMantissa2,x
.21ff	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.2201	95 62		sta $62,x			sta 	NSMantissa3,x
.2203	60		rts				rts
.2204					Int32Divide:
.2204	48		pha				pha 								; save AXY
.2205	5a		phy				phy
.2206	20 51 26	jsr $2651			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2209	20 6a 26	jsr $266a			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.220c	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.220e					_I32DivideLoop:
.220e	e8		inx				inx
.220f	e8		inx				inx
.2210	20 7d 26	jsr $267d			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2213	ca		dex				dex
.2214	ca		dex				dex
.2215	20 7e 26	jsr $267e			jsr 	FloatRotateLeft
.2218	20 44 22	jsr $2244			jsr 	FloatDivideCheck 			; check if subtract possible
.221b	90 02		bcc $221f			bcc 	_I32DivideNoCarryIn
.221d	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.221f					_I32DivideNoCarryIn:
.221f	88		dey				dey 								; loop round till division completed.
.2220	d0 ec		bne $220e			bne 	_I32DivideLoop
.2222	7a		ply				ply 								; restore AXY and exit
.2223	68		pla				pla
.2224	18		clc				clc
.2225	60		rts				rts
.2226					Int32ShiftDivide:
.2226	48		pha				pha 								; save AY
.2227	5a		phy				phy
.2228	e8		inx				inx 								; clear S[X+2]
.2229	e8		inx				inx
.222a	20 6e 26	jsr $266e			jsr 	FloatSetZero
.222d	ca		dex				dex
.222e	ca		dex				dex
.222f	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2231					_I32SDLoop:
.2231	20 44 22	jsr $2244			jsr 	FloatDivideCheck 			; check if subtract possible
.2234	e8		inx				inx
.2235	e8		inx				inx
.2236	20 7e 26	jsr $267e			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.2239	ca		dex				dex
.223a	ca		dex				dex
.223b	20 7e 26	jsr $267e			jsr 	FloatRotateLeft
.223e	88		dey				dey 	 							; do 31 times
.223f	d0 f0		bne $2231			bne 	_I32SDLoop
.2241	7a		ply				ply 								; restore AY and exit
.2242	68		pla				pla
.2243	60		rts				rts
.2244					FloatDivideCheck:
.2244	20 14 24	jsr $2414			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.2247	b0 04		bcs $224d			bcs 	_DCSExit 					; if carry set, then could do, exit
.2249	20 fa 23	jsr $23fa			jsr 	FloatAddTopTwoStack 		; add it back in
.224c	18		clc				clc 								; and return False
.224d					_DCSExit:
.224d	60		rts				rts
.224e					FloatFractionalPart:
.224e	5a		phy				phy
.224f	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.2251	29 7f		and #$7f			and 	#$7F
.2253	95 32		sta $32,x			sta 	NSStatus,x
.2255	20 c3 23	jsr $23c3			jsr 	FloatNormalise
.2258	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.225a	38		sec				sec
.225b	e9 e0		sbc #$e0			sbc 	#$E0
.225d	90 29		bcc $2288			bcc 	_FFPExit 					; already fractional
.225f	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2261	b0 22		bcs $2285			bcs 	_FFPZero
.2263	a8		tay				tay 								; put count to do in Y
.2264	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.2266	20 8d 22	jsr $228d			jsr 	_FFPPartial
.2269	95 62		sta $62,x			sta 	NSMantissa3,x
.226b	b5 56		lda $56,x			lda 	NSMantissa2,x
.226d	20 8d 22	jsr $228d			jsr 	_FFPPartial
.2270	95 56		sta $56,x			sta 	NSMantissa2,x
.2272	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2274	20 8d 22	jsr $228d			jsr 	_FFPPartial
.2277	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2279	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.227b	20 8d 22	jsr $228d			jsr 	_FFPPartial
.227e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2280	20 90 26	jsr $2690			jsr 	FloatIsZero 					; zeroed check.
.2283	d0 03		bne $2288			bne 	_FFPExit
.2285					_FFPZero:
.2285	20 6e 26	jsr $266e			jsr 	FloatSetZero
.2288					_FFPExit:
.2288	20 c3 23	jsr $23c3			jsr 	FloatNormalise
.228b	7a		ply				ply
.228c	60		rts				rts
.228d					_FFPPartial:
.228d	c0 00		cpy #$00			cpy 	#0 							; no more to do
.228f	f0 17		beq $22a8			beq 	_FFFPPExit
.2291	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.2293	b0 0c		bcs $22a1			bcs 	_FFFPPWholeByte
.2295	5a		phy				phy
.2296					_FFFPPLeft:
.2296	0a		asl a				asl 	a
.2297	88		dey				dey
.2298	d0 fc		bne $2296			bne 	_FFFPPLeft
.229a	7a		ply				ply
.229b					_FFFPPRight:
.229b	4a		lsr a				lsr 	a
.229c	88		dey				dey
.229d	d0 fc		bne $229b			bne 	_FFFPPRight
.229f	80 07		bra $22a8			bra 	_FFFPPExit
.22a1					_FFFPPWholeByte:
.22a1	98		tya				tya 								; subtract 8 from count
.22a2	38		sec				sec
.22a3	e9 08		sbc #$08			sbc 	#8
.22a5	a8		tay				tay
.22a6	a9 00		lda #$00			lda 	#0 							; and clear all
.22a8					_FFFPPExit:
.22a8	60		rts				rts
.22a9					FloatIntegerPart:
.22a9	48		pha				pha
.22aa	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22ac	f0 1d		beq $22cb			beq 	_FIPExit 					; if so do nothing
.22ae	20 90 26	jsr $2690			jsr 	FloatIsZero 				; is it zero ?
.22b1	f0 15		beq $22c8			beq 	_FIPZero 					; if so return zero.
.22b3	20 c3 23	jsr $23c3			jsr 	FloatNormalise 				; normalise
.22b6	f0 10		beq $22c8			beq 	_FIPZero 					; normalised to zero, exit zero
.22b8					_FIPShift:
.22b8	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22ba	10 07		bpl $22c3			bpl 	_FIPCheckZero
.22bc	20 87 26	jsr $2687			jsr 	FloatShiftRight 			; shift mantissa right
.22bf	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22c1	80 f5		bra $22b8			bra 	_FIPShift
.22c3					_FIPCheckZero:
.22c3	20 90 26	jsr $2690			jsr 	FloatIsZero 				; avoid -0 problem
.22c6	d0 03		bne $22cb			bne 	_FIPExit 					; set to zero if mantissa zero.
.22c8					_FIPZero:
.22c8	20 6e 26	jsr $266e			jsr 	FloatSetZero
.22cb					_FIPExit:
.22cb	68		pla				pla
.22cc	60		rts				rts
.22cd					FloatIntegerPartDown:
.22cd	48		pha				pha
.22ce	5a		phy				phy
.22cf	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22d1	f0 36		beq $2309			beq 	_FIPExit 					; if so do nothing
.22d3	20 90 26	jsr $2690			jsr 	FloatIsZero 				; is it zero ?
.22d6	f0 2e		beq $2306			beq 	_FIPZero 					; if so return zero.
.22d8	20 c3 23	jsr $23c3			jsr 	FloatNormalise 				; normalise
.22db	f0 29		beq $2306			beq 	_FIPZero 					; normalised to zero, exit zero
.22dd	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22df					_FIPShift:
.22df	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22e1	10 0a		bpl $22ed			bpl 	_FIPCheckDown
.22e3	20 87 26	jsr $2687			jsr 	FloatShiftRight 			; shift mantissa right
.22e6	90 01		bcc $22e9			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22e8	c8		iny				iny
.22e9					_FIPNoFrac:
.22e9	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22eb	80 f2		bra $22df			bra 	_FIPShift
.22ed					_FIPCheckDown:
.22ed	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22ef	f0 10		beq $2301			beq 	_FIPCheckZero
.22f1	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22f3	10 0c		bpl $2301			bpl 	_FIPCheckZero
.22f5	e8		inx				inx 								; -ve so round *down*.
.22f6	a9 01		lda #$01			lda 	#1
.22f8	20 70 26	jsr $2670			jsr 	FloatSetByte
.22fb	20 30 26	jsr $2630			jsr 	FloatNegate
.22fe	20 92 20	jsr $2092			jsr 	FloatAdd
.2301					_FIPCheckZero:
.2301	20 90 26	jsr $2690			jsr 	FloatIsZero 				; avoid -0 problem
.2304	d0 03		bne $2309			bne 	_FIPExit 					; set to zero if mantissa zero.
.2306					_FIPZero:
.2306	20 6e 26	jsr $266e			jsr 	FloatSetZero
.2309					_FIPExit:
.2309	7a		ply				ply
.230a	68		pla				pla
.230b	60		rts				rts
.230c					FloatInt8Multiply:
.230c	5a		phy				phy
.230d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.230f	a8		tay				tay
.2310	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2312					_FI8MLoop:
.2312	98		tya				tya 								; shift right shifter right into carry
.2313	4a		lsr a				lsr 	a
.2314	a8		tay				tay
.2315	90 0d		bcc $2324			bcc 	_FI8MNoAdd
.2317	18		clc				clc
.2318	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.231a	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.231c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.231e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2320	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.2322	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2324					_FI8MNoAdd:
.2324	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.2326	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.2328	c0 00		cpy #$00			cpy 	#0
.232a	d0 e6		bne $2312			bne 	_FI8MLoop 					; until right shifter zero.
.232c	7a		ply				ply
.232d	60		rts				rts
.232e					FloatMultiply:
.232e	ca		dex				dex
.232f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.2331	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2333	15 62		ora $62,x			ora 	NSMantissa3,x
.2335	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2337	d0 21		bne $235a			bne 	_FMUseFloat
.2339	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.233b	15 33		ora $33,x			ora 	NSStatus+1,x
.233d	29 80		and #$80			and 	#$80
.233f	15 62		ora $62,x			ora 	NSMantissa3,x
.2341	15 56		ora $56,x			ora 	NSMantissa2,x
.2343	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2345	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2347	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2349	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.234b	d0 04		bne $2351			bne 	_FMInt32
.234d	20 0c 23	jsr $230c			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2350	60		rts				rts
.2351					_FMInt32:
.2351	20 7b 23	jsr $237b			jsr 	FloatMultiplyShort			; use the int32 one.
.2354	18		clc				clc 								; fix it up if gone out of range
.2355	75 6e		adc $6e,x			adc 	NSExponent,x
.2357	95 6e		sta $6e,x			sta 	NSExponent,x
.2359	60		rts				rts
.235a					_FMUseFloat:
.235a	20 c3 23	jsr $23c3			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.235d	f0 18		beq $2377			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.235f	e8		inx				inx
.2360	20 c3 23	jsr $23c3			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2363	ca		dex				dex
.2364	c9 00		cmp #$00			cmp 	#0
.2366	f0 0c		beq $2374			beq 	_FDSetZero
.2368	20 7b 23	jsr $237b			jsr 	FloatMultiplyShort 			; calculate the result.
.236b	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.236d	18		clc				clc
.236e	75 6f		adc $6f,x			adc 	NSExponent+1,x
.2370	95 6e		sta $6e,x			sta 	NSExponent,x
.2372	80 03		bra $2377			bra 	_FDExit
.2374					_FDSetZero:
.2374	20 6e 26	jsr $266e			jsr 	FloatSetZero 				; return 0
.2377					_FDExit:
.2377	20 c3 23	jsr $23c3			jsr 	FloatNormalise 				; normalise the result
.237a	60		rts				rts
.237b					FloatMultiplyShort:
.237b	5a		phy				phy 								; save Y
.237c	20 51 26	jsr $2651			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.237f	20 6a 26	jsr $266a			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2382	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2384					_I32MLoop:
.2384	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2386	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.2388	15 58		ora $58,x			ora 	NSMantissa2+2,x
.238a	15 64		ora $64,x			ora 	NSMantissa3+2,x
.238c	f0 25		beq $23b3			beq 	_I32MExit 					; exit if zero
.238e	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2390	29 01		and #$01			and 	#1
.2392	f0 0d		beq $23a1			beq 	_I32MNoAdd
.2394	20 fa 23	jsr $23fa			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.2397	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.2399	10 06		bpl $23a1			bpl 	_I32MNoAdd
.239b					_I32ShiftRight:
.239b	20 87 26	jsr $2687			jsr 	FloatShiftRight 			; shift S[X] right
.239e	c8		iny				iny 								; increment shift count
.239f	80 09		bra $23aa			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23a1					_I32MNoAdd:
.23a1	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23a3	70 f6		bvs $239b			bvs 	_I32ShiftRight 				; instead.
.23a5	e8		inx				inx
.23a6	20 7d 26	jsr $267d			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23a9	ca		dex				dex
.23aa					_I32MShiftUpper:
.23aa	e8		inx				inx 								; shift S[X+2] right
.23ab	e8		inx				inx
.23ac	20 87 26	jsr $2687			jsr 	FloatShiftRight
.23af	ca		dex				dex
.23b0	ca		dex				dex
.23b1	80 d1		bra $2384			bra 	_I32MLoop 					; try again.
.23b3					_I32MExit:
.23b3	20 b9 23	jsr $23b9			jsr 	FloatCalculateSign
.23b6	98		tya				tya 								; shift in A
.23b7	7a		ply				ply 								; restore Y and exit
.23b8	60		rts				rts
.23b9					FloatCalculateSign:
.23b9	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23bb	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23bd	55 33		eor $33,x			eor 	NSStatus+1,x
.23bf	0a		asl a				asl 	a 							; shift bit 7 into carry
.23c0	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23c2	60		rts				rts
.23c3					FloatNormalise:
.23c3	20 90 26	jsr $2690			jsr 	FloatIsZero 				; if zero exit
.23c6	d0 07		bne $23cf			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23c8	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.23ca	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.23cc	a9 00		lda #$00			lda 	#0 							; set Z flag
.23ce	60		rts				rts
.23cf					_NSNormaliseOptimise:
.23cf	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23d1	d0 19		bne $23ec			bne 	_NSNormaliseLoop
.23d3	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.23d5	30 15		bmi $23ec			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23d7	95 62		sta $62,x			sta 	NSMantissa3,x
.23d9	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.23db	95 56		sta $56,x			sta 	NSMantissa2,x
.23dd	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.23df	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23e1	74 3e		stz $3e,x			stz 	NSMantissa0,x
.23e3	b5 6e		lda $6e,x			lda 	NSExponent,x
.23e5	38		sec				sec
.23e6	e9 08		sbc #$08			sbc 	#8
.23e8	95 6e		sta $6e,x			sta 	NSExponent,x
.23ea	80 e3		bra $23cf			bra 	_NSNormaliseOptimise
.23ec					_NSNormaliseLoop:
.23ec	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23ee	70 07		bvs $23f7			bvs 	_NSNExit 					; exit if so with Z flag clear
.23f0	20 7d 26	jsr $267d			jsr 	FloatShiftLeft 				; shift mantissa left
.23f3	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23f5	80 f5		bra $23ec			bra 	_NSNormaliseLoop
.23f7					_NSNExit:
.23f7	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23f9	60		rts				rts
.23fa					FloatAddTopTwoStack:
.23fa	18		clc				clc
.23fb	b5 3e		lda $3e,x			lda		NSMantissa0,x
.23fd	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.23ff	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2401	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2403	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.2405	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2407	b5 56		lda $56,x			lda		NSMantissa2,x
.2409	75 57		adc $57,x			adc 		NSMantissa2+1,x
.240b	95 56		sta $56,x			sta 	NSMantissa2,x
.240d	b5 62		lda $62,x			lda		NSMantissa3,x
.240f	75 63		adc $63,x			adc 		NSMantissa3+1,x
.2411	95 62		sta $62,x			sta 	NSMantissa3,x
.2413	60		rts				rts
.2414					FloatSubTopTwoStack:
.2414	38		sec				sec
.2415	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2417	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.2419	95 3e		sta $3e,x			sta 	NSMantissa0,x
.241b	b5 4a		lda $4a,x			lda		NSMantissa1,x
.241d	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.241f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2421	b5 56		lda $56,x			lda		NSMantissa2,x
.2423	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.2425	95 56		sta $56,x			sta 	NSMantissa2,x
.2427	b5 62		lda $62,x			lda		NSMantissa3,x
.2429	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.242b	95 62		sta $62,x			sta 	NSMantissa3,x
.242d	60		rts				rts
.242e					FloatInt32Add:
.242e	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2430	55 33		eor $33,x			eor 	NSStatus+1,x
.2432	30 04		bmi $2438			bmi 	_DiffSigns
.2434	20 fa 23	jsr $23fa			jsr		FloatAddTopTwoStack
.2437	60		rts				rts
.2438					_DiffSigns:
.2438	20 14 24	jsr $2414			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.243b	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.243d	10 07		bpl $2446			bpl 	_AddExit
.243f	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2441	95 32		sta $32,x			sta 	NSStatus,x
.2443	20 37 26	jsr $2637			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2446					_AddExit:
.2446	20 90 26	jsr $2690			jsr 	FloatIsZero 				; check for -0
.2449	d0 02		bne $244d			bne 	_AddNonZero
.244b	74 32		stz $32,x			stz 	NSStatus,x
.244d					_AddNonZero:
.244d	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.244e					FloatEncodeStart:
.244e	38		sec				sec
.244f	80 01		bra $2452			bra 	FloatEncodeContinue+1
.2451					FloatEncodeContinue:
.2451	18		clc				clc
.2452					FloatEncode:
.2452	08		php				php 								; save reset flag.
.2453	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2455	f0 15		beq $246c			beq 	_ENIsOkay
.2457	c9 30		cmp #$30			cmp 	#"0"
.2459	90 04		bcc $245f			bcc 	_ENBadNumber
.245b	c9 3a		cmp #$3a			cmp 	#"9"+1
.245d	90 0d		bcc $246c			bcc 	_ENIsOkay
.245f					_ENBadNumber:
.245f	28		plp				plp 								; throw saved reset
.2460	ad 37 06	lda $0637			lda 	encodeState 				; if in decimal mode, construct final number
.2463	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2465	d0 03		bne $246a			bne 	_ENFail
.2467	4c e4 24	jmp $24e4			jmp 	_ENConstructFinal
.246a					_ENFail:
.246a	18		clc				clc 								; not allowed
.246b	60		rts				rts
.246c					_ENIsOkay:
.246c	28		plp				plp 								; are we restarting
.246d	90 15		bcc $2484			bcc 	_ENNoRestart
.246f					_ENStartEncode:
.246f	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2471	f0 0c		beq $247f			beq 	_ENFirstDP
.2473	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2475	20 70 26	jsr $2670			jsr 	FloatSetByte 				; in single byte mode.
.2478	a9 01		lda #$01			lda 	#ESTA_Low
.247a					_ENExitChange:
.247a	8d 37 06	sta $0637			sta 	encodeState 				; save new state
.247d	38		sec				sec
.247e	60		rts				rts
.247f					_ENFirstDP:
.247f	20 6e 26	jsr $266e			jsr 	FloatSetZero 				; clear integer part
.2482	80 3c		bra $24c0			bra 	_ESTASwitchFloat			; go straight to float and exi
.2484					_ENNoRestart:
.2484	48		pha				pha 								; save digit or DP on stack.
.2485	ad 37 06	lda $0637			lda 	encodeState 				; get current state
.2488	c9 01		cmp #$01			cmp 	#ESTA_Low
.248a	f0 09		beq $2495			beq  	_ESTALowState
.248c	c9 02		cmp #$02			cmp 	#ESTA_High
.248e	f0 26		beq $24b6			beq 	_ESTAHighState
.2490	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2492	f0 38		beq $24cc			beq 	_ESTADecimalState
>2494	db						.byte 	$DB 						; causes a break in the emulator
.2495					_ESTALowState:
.2495	68		pla				pla 								; get value back
.2496	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.2498	f0 26		beq $24c0			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.249a	29 0f		and #$0f			and 	#15 						; make digit
.249c	8d 38 06	sta $0638			sta 	digitTemp 					; save it.
.249f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24a1	0a		asl a				asl 	a
.24a2	0a		asl a				asl 	a
.24a3	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24a5	0a		asl a				asl 	a
.24a6	6d 38 06	adc $0638			adc 	digitTemp
.24a9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24ab	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24ad	90 05		bcc $24b4			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24af	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24b1	8d 37 06	sta $0637			sta 	encodeState
.24b4					_ESTANoSwitch:
.24b4	38		sec				sec
.24b5	60		rts				rts
.24b6					_ESTAHighState:
.24b6	68		pla				pla 								; get value back
.24b7	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24b9	f0 05		beq $24c0			beq 	_ESTASwitchFloat
.24bb	20 16 25	jsr $2516			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24be	38		sec				sec
.24bf	60		rts				rts
.24c0					_ESTASwitchFloat:
.24c0	9c 39 06	stz $0639			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24c3	e8		inx				inx 								; zero the decimal additive.
.24c4	20 6e 26	jsr $266e			jsr 	FloatSetZero
.24c7	ca		dex				dex
.24c8	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24ca	80 ae		bra $247a			bra 	_ENExitChange
.24cc					_ESTADecimalState:
.24cc	68		pla				pla 								; digit.
.24cd	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24cf	f0 99		beq $246a			beq 	_ENFail
.24d1	e8		inx				inx 								; put digit into fractional part of X+1
.24d2	20 16 25	jsr $2516			jsr 	ESTAShiftDigitIntoMantissa
.24d5	ca		dex				dex
.24d6	ee 39 06	inc $0639			inc 	decimalCount 				; bump the count of decimals
.24d9	ad 39 06	lda $0639			lda 	decimalCount 				; too many decimal digits.
.24dc	c9 0b		cmp #$0b			cmp 	#11
.24de	f0 02		beq $24e2			beq 	_ESTADSFail
.24e0	38		sec				sec
.24e1	60		rts				rts
.24e2					_ESTADSFail:
.24e2	18		clc				clc
.24e3	60		rts				rts
.24e4					_ENConstructFinal:
.24e4	ad 39 06	lda $0639			lda 	decimalCount 				; get decimal count
.24e7	f0 2b		beq $2514			beq 	_ENCFExit 					; no decimals
.24e9	5a		phy				phy
.24ea	0a		asl a				asl 	a 							; x 4 and CLC
.24eb	0a		asl a				asl 	a
.24ec	6d 39 06	adc $0639			adc 	decimalCount
.24ef	a8		tay				tay
.24f0	b9 7b 21	lda $217b,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24f3	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24f5	b9 7c 21	lda $217c,y			lda 	FloatScalarTable-5+1,y
.24f8	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.24fa	b9 7d 21	lda $217d,y			lda 	FloatScalarTable-5+2,y
.24fd	95 58		sta $58,x			sta 	NSMantissa2+2,x
.24ff	b9 7e 21	lda $217e,y			lda 	FloatScalarTable-5+3,y
.2502	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2504	b9 7f 21	lda $217f,y			lda 	FloatScalarTable-5+4,y
.2507	95 70		sta $70,x			sta 	NSExponent+2,x
.2509	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.250b	e8		inx				inx 								; multiply decimal const by decimal scalar
.250c	e8		inx				inx
.250d	20 2e 23	jsr $232e			jsr 	FloatMultiply
.2510	20 92 20	jsr $2092			jsr 	FloatAdd 					; add to integer part.
.2513	7a		ply				ply
.2514					_ENCFExit:
.2514	18		clc				clc 								; reject the digit.
.2515	60		rts				rts
.2516					ESTAShiftDigitIntoMantissa:
.2516	29 0f		and #$0f			and 	#15 						; save digit
.2518	48		pha				pha
.2519	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.251b	48		pha				pha
.251c	b5 56		lda $56,x			lda 	NSMantissa2,x
.251e	48		pha				pha
.251f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2521	48		pha				pha
.2522	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2524	48		pha				pha
.2525	20 7d 26	jsr $267d			jsr 	FloatShiftLeft 				; x 2
.2528	20 7d 26	jsr $267d			jsr 	FloatShiftLeft 				; x 4
.252b	18		clc				clc 								; pop mantissa and add
.252c	68		pla				pla
.252d	75 3e		adc $3e,x			adc 	NSMantissa0,x
.252f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2531	68		pla				pla
.2532	75 4a		adc $4a,x			adc 	NSMantissa1,x
.2534	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2536	68		pla				pla
.2537	75 56		adc $56,x			adc 	NSMantissa2,x
.2539	95 56		sta $56,x			sta 	NSMantissa2,x
.253b	68		pla				pla
.253c	75 62		adc $62,x			adc 	NSMantissa3,x
.253e	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.2540	20 7d 26	jsr $267d			jsr 	FloatShiftLeft 				; x 10
.2543	68		pla				pla 								; add digit
.2544	18		clc				clc
.2545	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2547	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2549	90 0a		bcc $2555			bcc 	_ESTASDExit
.254b	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.254d	d0 06		bne $2555			bne 	_ESTASDExit
.254f	f6 56		inc $56,x			inc 	NSMantissa2,x
.2551	d0 02		bne $2555			bne 	_ESTASDExit
.2553	f6 62		inc $62,x			inc 	NSMantissa3,x
.2555					_ESTASDExit:
.2555	60		rts				rts
.0637					encodeState:
>0637							.fill 	1
.0638					digitTemp:
>0638							.fill 	1
.0639					decimalCount:
>0639							.fill 	1
.2556					FloatToString:
.2556	da		phx				phx
.2557	5a		phy				phy 								; save code position
.2558	8d 3a 06	sta $063a			sta 	decimalPlaces	 			; save number of DPs.
.255b	9c 3b 06	stz $063b			stz 	dbOffset 					; offset into decimal buffer = start.
.255e	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.2560	10 08		bpl $256a			bpl 	_CNTSNotNegative
.2562	29 7f		and #$7f			and 	#$7F 						; make +ve
.2564	95 32		sta $32,x			sta 	NSStatus,x
.2566	a9 2d		lda #$2d			lda 	#"-"
.2568	80 02		bra $256c			bra 	_CNTMain
.256a					_CNTSNotNegative:
.256a	a9 20		lda #$20			lda 	#" "
.256c					_CNTMain:
.256c	20 ce 25	jsr $25ce			jsr 	WriteDecimalBuffer
.256f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.2571	f0 0d		beq $2580			beq 	_CNTSNotFloat
.2573	e8		inx				inx 								; round up so we don't get too many 6.999999
.2574	a9 01		lda #$01			lda 	#1
.2576	20 70 26	jsr $2670			jsr 	FloatSetByte
.2579	b5 6d		lda $6d,x			lda		NSExponent-1,x
.257b	95 6e		sta $6e,x			sta 	NSExponent,x
.257d	20 92 20	jsr $2092			jsr 	FloatAdd
.2580					_CNTSNotFloat:
.2580	20 b0 25	jsr $25b0			jsr 	MakePlusTwoString 			; do the integer part.
.2583	20 4e 22	jsr $224e			jsr 	FloatFractionalPart 		; get the fractional part
.2586	20 c3 23	jsr $23c3			jsr 	FloatNormalise					; normalise , exit if zero
.2589	f0 22		beq $25ad			beq 	_CNTSExit
.258b	a9 2e		lda #$2e			lda 	#"."
.258d	20 ce 25	jsr $25ce			jsr 	WriteDecimalBuffer 			; write decimal place
.2590					_CNTSDecimal:
.2590	ce 3a 06	dec $063a			dec 	decimalPlaces 				; done all the decimals
.2593	30 18		bmi $25ad			bmi 	_CNTSExit
.2595	e8		inx				inx 								; x 10.0
.2596	a9 0a		lda #$0a			lda 	#10
.2598	20 70 26	jsr $2670			jsr 	FloatSetByte
.259b	20 2e 23	jsr $232e			jsr 	FloatMultiply
.259e	20 b0 25	jsr $25b0			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25a1	20 4e 22	jsr $224e			jsr 	FloatFractionalPart 		; get the fractional part
.25a4	20 c3 23	jsr $23c3			jsr 	FloatNormalise 				; normalise it.
.25a7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25a9	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25ab	b0 e3		bcs $2590			bcs 	_CNTSDecimal 				; keep going.
.25ad					_CNTSExit:
.25ad	7a		ply				ply
.25ae	fa		plx				plx
.25af	60		rts				rts
.25b0					MakePlusTwoString:
.25b0	da		phx				phx
.25b1	20 51 26	jsr $2651			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25b4	e8		inx				inx 								; access it
.25b5	e8		inx				inx
.25b6	20 a9 22	jsr $22a9			jsr 	FloatIntegerPart 			; make it an integer
.25b9	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25bb	20 ed 25	jsr $25ed			jsr 	ConvertInt32
.25be	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25c0					_MPTSCopy:
.25c0	bd 15 06	lda $0615,x			lda 	numberBuffer,x
.25c3	20 ce 25	jsr $25ce			jsr 	WriteDecimalBuffer
.25c6	e8		inx				inx
.25c7	bd 15 06	lda $0615,x			lda 	numberBuffer,x
.25ca	d0 f4		bne $25c0			bne 	_MPTSCopy
.25cc	fa		plx				plx
.25cd	60		rts				rts
.25ce					WriteDecimalBuffer:
.25ce	da		phx				phx
.25cf	ae 3b 06	ldx $063b			ldx 	dbOffset
.25d2	9d 3c 06	sta $063c,x			sta 	decimalBuffer,x
.25d5	9e 3d 06	stz $063d,x			stz 	decimalBuffer+1,x
.25d8	ee 3b 06	inc $063b			inc 	dbOffset
.25db	fa		plx				plx
.25dc	60		rts				rts
.063a					decimalPlaces:
>063a							.fill 	1
.063b					dbOffset:
>063b							.fill 	1
.063c					decimalBuffer:
>063c							.fill 	32
.25dd					ConvertInt16:
.25dd	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.25df	86 4a		stx $4a				stx 	NSMantissa1
.25e1	64 56		stz $56				stz 	NSMantissa2
.25e3	64 62		stz $62				stz 	NSMantissa3
.25e5	64 32		stz $32				stz 	NSStatus 					; positive integer
.25e7	a2 00		ldx #$00			ldx 	#0 							; stack level
.25e9	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25eb	80 00		bra $25ed			bra 	ConvertInt32
.25ed					ConvertInt32:
.25ed	5a		phy				phy
.25ee	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25f0	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25f2	10 08		bpl $25fc			bpl 	_CI32NotNeg
.25f4	48		pha				pha
.25f5	a9 2d		lda #$2d			lda 	#'-'
.25f7	99 15 06	sta $0615,y			sta 	numberBuffer,y
.25fa	c8		iny				iny
.25fb	68		pla				pla
.25fc					_CI32NotNeg:
.25fc	20 0a 26	jsr $260a			jsr 	_CI32DivideConvert 			; recursive conversion
.25ff	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2601	99 15 06	sta $0615,y			sta 	numberBuffer,y
.2604	7a		ply				ply
.2605	a2 06		ldx #$06			ldx 	#numberBuffer >> 8 			; return address in XA
.2607	a9 15		lda #$15			lda 	#numberBuffer & $FF
.2609	60		rts				rts
.260a					_CI32DivideConvert:
.260a	e8		inx				inx 								; write to next slot up
.260b	20 70 26	jsr $2670			jsr 	FloatSetByte 		 		; write the base out.
.260e	ca		dex				dex
.260f	20 04 22	jsr $2204			jsr 	Int32Divide 				; divide
.2612	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.2614	48		pha				pha
.2615	20 f3 21	jsr $21f3			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2618	20 90 26	jsr $2690			jsr 	FloatIsZero 				; is it zero ?
.261b	f0 05		beq $2622			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.261d	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.261f	20 0a 26	jsr $260a			jsr 	_CI32DivideConvert 			; and recusrively call.
.2622					_CI32NoRecurse:
.2622	68		pla				pla 								; remainder
.2623	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2625	90 02		bcc $2629			bcc 	_CI32NotHex
.2627	69 26		adc #$26			adc 	#6+32
.2629					_CI32NotHex:
.2629	69 30		adc #$30			adc 	#48
.262b	99 15 06	sta $0615,y			sta 	numberBuffer,y 				; write out and exit
.262e	c8		iny				iny
.262f	60		rts				rts
.2630					FloatNegate:
.2630	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2632	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2634	95 32		sta $32,x			sta 	NSStatus,x
.2636	60		rts				rts
.2637					FloatNegateMantissa:
.2637	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2638	a9 00		lda #$00			lda 	#0
.263a	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.263c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.263e	a9 00		lda #$00			lda 	#0
.2640	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.2642	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2644	a9 00		lda #$00			lda 	#0
.2646	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.2648	95 56		sta $56,x			sta 	NSMantissa2,x
.264a	a9 00		lda #$00			lda 	#0
.264c	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.264e	95 62		sta $62,x			sta 	NSMantissa3,x
.2650	60		rts				rts
.2651					FloatShiftUpTwo:
.2651	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2653	95 40		sta $40,x			sta 	NSMantissa0+2,x
.2655	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2657	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2659	b5 56		lda $56,x			lda 	NSMantissa2,x
.265b	95 58		sta $58,x			sta 	NSMantissa2+2,x
.265d	b5 62		lda $62,x			lda 	NSMantissa3,x
.265f	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2661	b5 6e		lda $6e,x			lda 	NSExponent,x
.2663	95 70		sta $70,x			sta 	NSExponent+2,x
.2665	b5 32		lda $32,x			lda 	NSStatus,x
.2667	95 34		sta $34,x			sta 	NSStatus+2,x
.2669	60		rts				rts
.266a					FloatSetZeroMantissaOnly:
.266a	74 3e		stz $3e,x			stz 	NSMantissa0,x
.266c	80 08		bra $2676			bra 	FloatZero13
.266e					FloatSetZero:
.266e	a9 00		lda #$00			lda 	#0
.2670					FloatSetByte:
.2670	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2672					FloatSetMantissa:
.2672	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.2674	74 32		stz $32,x			stz 	NSStatus,x
.2676					FloatZero13:
.2676	74 4a		stz $4a,x			stz 	NSMantissa1,x
.2678	74 56		stz $56,x			stz 	NSMantissa2,x
.267a	74 62		stz $62,x			stz 	NSMantissa3,x
.267c	60		rts				rts
.267d					FloatShiftLeft:
.267d	18		clc				clc
.267e					FloatRotateLeft:
.267e	36 3e		rol $3e,x			rol 	NSMantissa0,x
.2680	36 4a		rol $4a,x			rol		NSMantissa1,x
.2682	36 56		rol $56,x			rol		NSMantissa2,x
.2684	36 62		rol $62,x			rol		NSMantissa3,x
.2686	60		rts				rts
.2687					FloatShiftRight:
.2687	56 62		lsr $62,x			lsr 	NSMantissa3,x
.2689	76 56		ror $56,x			ror		NSMantissa2,x
.268b	76 4a		ror $4a,x			ror		NSMantissa1,x
.268d	76 3e		ror $3e,x			ror		NSMantissa0,x
.268f	60		rts				rts
.2690					FloatIsZero:
.2690	b5 62		lda $62,x			lda 	NSMantissa3,x
.2692	15 56		ora $56,x			ora		NSMantissa2,x
.2694	15 4a		ora $4a,x			ora		NSMantissa1,x
.2696	15 3e		ora $3e,x			ora		NSMantissa0,x
.2698	60		rts				rts

;******  Processing input file: testing/testend.asm

.2699					EndProgram:
>2699	01 08 0c 08 0a 00 4e 20				.binary "code/tokenised.dat"
>26a1	b2 20 34 30 00 15 08 14 00 ce 86 20 33 00 32 08
>26b1	3c 00 99 20 c7 28 31 34 37 29 3b 22 48 45 4c 4c
>26c1	4f 20 57 4f 52 4c 44 20 21 22 00 4e 08 46 00 86
>26d1	20 42 58 28 4e 29 3a 86 20 42 59 28 4e 29 3a 86
>26e1	20 42 43 28 4e 29 00 62 08 4b 00 86 20 44 58 28
>26f1	4e 29 3a 86 20 44 59 28 4e 29 00 70 08 50 00 81
>2701	20 42 b2 30 20 a4 20 4e 00 89 08 5a 00 42 58 28
>2711	42 29 b2 b5 28 bb 28 31 29 ac 34 30 29 ac 32 aa
>2721	31 00 a2 08 64 00 42 59 28 42 29 b2 b5 28 bb 28
>2731	31 29 ac 33 30 29 ac 32 35 36 00 b9 08 69 00 42
>2741	43 28 42 29 b2 b5 28 bb 28 31 29 ac 31 34 29 aa
>2751	31 00 cd 08 6a 00 44 58 28 42 29 b2 b5 28 bb 28
>2761	31 29 ac 32 29 00 e3 08 6c 00 8f 20 44 59 28 42
>2771	29 b2 b5 28 bb 28 31 29 ac 32 29 00 ef 08 6d 00
>2781	44 59 28 42 29 b2 31 00 f7 08 6e 00 82 20 42 00
>2791	fd 08 78 00 8f 00 11 09 82 00 81 59 b2 30 a4 32
>27a1	39 3a 81 58 b2 30 a4 33 39 00 27 09 8c 00 51 b2
>27b1	59 ac 32 35 36 aa 58 ac 32 aa 34 35 30 35 36 00
>27c1	3f 09 96 00 ce 84 20 31 2c 51 2c 38 31 3a ce 84
>27d1	31 2c 51 aa 31 2c 30 00 4a 09 a0 00 82 58 3a 82
>27e1	20 59 00 56 09 c8 00 81 20 42 b2 31 a4 4e 00 73
>27f1	09 d2 00 ce 84 20 31 2c 34 35 30 35 36 aa 42 59
>2801	28 42 29 aa 42 58 28 42 29 2c 30 00 81 09 e6 00
>2811	44 58 42 b2 44 58 28 42 29 00 92 09 f0 00 8b 44
>2821	58 42 b2 30 a7 8d 31 30 31 30 00 a3 09 fa 00 8b
>2831	44 58 42 b2 31 a7 8d 31 30 34 30 00 b1 09 ff 00
>2841	44 59 42 b2 44 59 28 42 29 00 c2 09 04 01 8b 44
>2851	59 42 b2 30 a7 8d 31 30 37 30 00 d3 09 0e 01 8b
>2861	44 59 42 b2 31 a7 8d 31 31 30 30 00 f4 09 18 01
>2871	ce 84 20 31 2c 34 35 30 35 36 aa 42 59 28 42 29
>2881	aa 42 58 28 42 29 2c 42 43 28 42 29 00 fb 09 22
>2891	01 82 42 00 05 0a 2c 01 89 20 32 30 30 00 0b 0a
>28a1	e8 03 8f 00 19 0a f2 03 42 58 42 b2 42 58 28 42
>28b1	29 00 2e 0a f3 03 8b 42 58 42 b2 31 a7 44 58 28
>28c1	42 29 b2 31 3a 8e 00 40 0a fc 03 42 58 28 42 29
>28d1	b2 42 58 42 ab 32 3a 8e 00 46 0a 06 04 8f 00 54
>28e1	0a 10 04 42 58 42 b2 42 58 28 42 29 00 74 0a 11
>28f1	04 8b 42 58 42 b2 37 39 a7 20 42 58 28 42 29 b2
>2901	37 37 3a 44 58 28 42 29 b2 30 3a 8e 00 86 0a 1a
>2911	04 42 58 28 42 29 b2 42 58 42 aa 32 3a 8e 00 8c
>2921	0a 24 04 8f 00 9a 0a 2e 04 42 59 42 b2 42 59 28
>2931	42 29 00 af 0a 2f 04 8b 42 59 42 b2 30 a7 44 59
>2941	28 42 29 b2 31 3a 8e 00 c3 0a 38 04 42 59 28 42
>2951	29 b2 42 59 42 ab 32 35 36 3a 8e 00 c9 0a 42 04
>2961	8f 00 d7 0a 4c 04 42 59 42 b2 42 59 28 42 29 00
>2971	fa 0a 4d 04 8b 42 59 42 b2 37 34 32 34 a7 42 59
>2981	28 42 29 b2 37 31 36 38 3a 44 59 28 42 29 b2 30
>2991	3a 8e 00 0e 0b 56 04 42 59 28 42 29 b2 42 59 42
>29a1	aa 32 35 36 3a 8e 00 00 00

;******  End of listing
