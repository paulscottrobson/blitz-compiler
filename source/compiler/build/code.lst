
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Sat Oct  7 08:22:43 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.1000					WrapperBoot:
.1000	a2 0a		ldx #$0a			ldx 	#APIDesc & $FF
.1002	a0 10		ldy #$10			ldy 	#APIDesc >> 8
.1004	20 43 11	jsr $1143			jsr 	StartCompiler
.1007	4c ff ff	jmp $ffff			jmp 	$FFFF
.100a					APIDesc:
>100a							.fill 	2
>100c	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>100d	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing file: testing/api/close.asm

.100e					APIOClose:
.100e	a9 40		lda #$40			lda 	#(PCodeStart >> 8)
.1010	a6 29		ldx $29				ldx 	objPtr
.1012	a4 2a		ldy $2a				ldy 	objPtr+1
.1014	20 7a 10	jsr $107a			jsr 	APISaveMemory
.1017	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/fromram.asm

.1018					APIIOpen:
.1018	a9 a3		lda #$a3			lda 	#((EndProgram+2) & $FF)
.101a	85 22		sta $22				sta 	0+srcInputPtr
.101c	a9 26		lda #$26			lda 	#((EndProgram+2) >> 8) & $FF
.101e	85 23		sta $23				sta 	1+srcInputPtr
.1020					APIIClose:
.1020	60		rts				rts
.1021					APIIGet:
.1021	b2 22		lda ($22)			lda 	(srcInputPtr)
.1023	e6 22		inc $22				inc 	srcInputPtr
.1025	d0 02		bne $1029			bne 	_IGSkip
.1027	e6 23		inc $23				inc 	srcInputPtr+1
.1029					_IGSkip:
.1029	60		rts				rts
.0022					srcInputPtr:
>0022							.fill 	2

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/line.asm

.102a					ReadNextLine:
.102a	20 21 10	jsr $1021			jsr 	APIIGet 					; check offset is not zero.
.102d	85 2c		sta $2c				sta 	zTemp0
.102f	20 21 10	jsr $1021			jsr 	APIIGet
.1032	05 2c		ora $2c				ora 	zTemp0
.1034	d0 02		bne $1038			bne 	_RNLBody
.1036	18		clc				clc
.1037	60		rts				rts						; end of file.
.1038					_RNLBody:
.1038	20 21 10	jsr $1021			jsr 	APIIGet 					; read and save line number
.103b	8d 00 05	sta $0500			sta 	currentLineNumber
.103e	20 21 10	jsr $1021			jsr 	APIIGet
.1041	8d 01 05	sta $0501			sta 	currentLineNumber+1
.1044	a2 00		ldx #$00			ldx 	#0 							; read line into buffer
.1046					_RNLRead:
.1046	20 21 10	jsr $1021			jsr 	APIIGet
.1049	9d 00 04	sta $0400,x			sta 	sourceBuffer,x
.104c	e8		inx				inx
.104d	c9 00		cmp #$00			cmp 	#0
.104f	d0 f5		bne $1046			bne 	_RNLRead
.1051	a9 00		lda #$00			lda 	#((sourceBuffer) & $FF)
.1053	85 24		sta $24				sta 	0+srcPtr
.1055	a9 04		lda #$04			lda 	#((sourceBuffer) >> 8) & $FF
.1057	85 25		sta $25				sta 	1+srcPtr
.1059	38		sec				sec
.105a	60		rts				rts
.105b					GetLineNumber:
.105b	ac 01 05	ldy $0501			ldy 	currentLineNumber+1
.105e	ad 00 05	lda $0500			lda 	currentLineNumber
.1061	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/open.asm

.1062					APIOOpen:
.1062					APIORewind:
.1062	64 2b		stz $2b				stz 	objPage
.1064	a9 00		lda #$00			lda 	#((PCodeStart) & $FF)
.1066	85 29		sta $29				sta 	0+objPtr
.1068	a9 40		lda #$40			lda 	#((PCodeStart) >> 8) & $FF
.106a	85 2a		sta $2a				sta 	1+objPtr
.106c	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/writebyte.asm

.106d					APIOWriteByte:
.106d	92 29		sta ($29)			sta 	(objPtr)
.106f	e6 29		inc $29				inc 	objPtr
.1071	d0 02		bne $1075			bne 	_HWOWBNoCarry
.1073	e6 2a		inc $2a				inc 	objPtr+1
.1075					_HWOWBNoCarry:
.1075	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_config.inc

=$4000					PCodeStart = $4000

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_printchar.asm

.1076					APIOPrintCharacter
.1076	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1079	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_save.asm

.107a					APISaveMemory:
.107a	da		phx				phx
.107b	5a		phy				phy
.107c	48		pha				pha
.107d	a9 00		lda #$00			lda 	#0 							; set LFS
.107f	a2 08		ldx #$08			ldx 	#8
.1081	a0 00		ldy #$00			ldy 	#0
.1083	20 ba ff	jsr $ffba			jsr 	$FFBA
.1086	a9 08		lda #$08			lda 	#8 							; set file name
.1088	a2 9c		ldx #$9c			ldx 	#SaveName & $FF
.108a	a0 10		ldy #$10			ldy 	#SaveName >> 8
.108c	20 bd ff	jsr $ffbd			jsr 	$FFBD
.108f	68		pla				pla 								; set up the start address.
.1090	85 2d		sta $2d				sta 	zTemp0+1
.1092	64 2c		stz $2c				stz 	zTemp0
.1094	a9 2c		lda #$2c			lda 	#zTemp0 					; from index.
.1096	7a		ply				ply 								; end in YX
.1097	fa		plx				plx
.1098	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.109b	60		rts				rts
.109c					SaveName:
>109c	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Return to file: testing/testing.asm


;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

.0024					srcPtr:
>0024							.fill 	2
.0400					sourceBuffer:
>0400							.fill 	256
.0500					currentLineNumber:
>0500							.fill 	2
.10a4					InlineNonDecimal:
.10a4	a2 02		ldx #$02			ldx 	#2 							; get size in X
.10a6	c9 25		cmp #$25			cmp 	#"%"
.10a8	f0 02		beq $10ac			beq 	_INDBinary
.10aa	a2 10		ldx #$10			ldx 	#16
.10ac					_INDBinary:
.10ac	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.10ae	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.10b0	64 2c		stz $2c				stz 	zTemp0 						; zero result
.10b2	64 2d		stz $2d				stz 	zTemp0+1
.10b4					_INDLoop:
.10b4	20 20 1a	jsr $1a20			jsr 	LookNext 					; check next character
.10b7	20 5c 1a	jsr $1a5c			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.10ba	90 1f		bcc $10db			bcc		_INDDone 					; didn't convert
.10bc	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.10be	b0 1b		bcs $10db			bcs 	_INDDone
.10c0	20 ea 10	jsr $10ea			jsr 	_INDShift 					; x 2 or x 16
.10c3	e0 02		cpx #$02			cpx 	#2
.10c5	f0 09		beq $10d0			beq 	_INDNotHex
.10c7	20 ea 10	jsr $10ea			jsr 	_INDShift
.10ca	20 ea 10	jsr $10ea			jsr 	_INDShift
.10cd	20 ea 10	jsr $10ea			jsr 	_INDShift
.10d0					_INDNotHex:
.10d0	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.10d2	85 2c		sta $2c				sta 	zTemp0
.10d4	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume
.10d7	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.10d9	80 d9		bra $10b4			bra 	_INDLoop
.10db					_INDDone:
.10db	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.10dd	f0 08		beq $10e7			beq 	_INDError
.10df	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.10e1	a5 2c		lda $2c				lda 	zTemp0
.10e3	20 cd 11	jsr $11cd			jsr 	PushIntegerYA
.10e6	60		rts				rts
.10e7					_INDError:
.10e7	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.10ea					_INDShift:
.10ea	06 2c		asl $2c				asl 	zTemp0
.10ec	26 2d		rol $2d				rol 	zTemp0+1
.10ee	60		rts				rts
.10ef					WriteCodeByte:
.10ef	48		pha				pha 								; save on stack
.10f0	da		phx				phx
.10f1	5a		phy				phy
.10f2	20 6d 10	jsr $106d			jsr 	APIOWriteByte
.10f5	7a		ply				ply 								; restore from stack
.10f6	fa		plx				plx
.10f7	68		pla				pla
.10f8	60		rts				rts
.10f9					PrintCharacter
.10f9	48		pha				pha
.10fa	da		phx				phx
.10fb	5a		phy				phy
.10fc	20 76 10	jsr $1076			jsr 	APIOPrintCharacter
.10ff	7a		ply				ply
.1100	fa		plx				plx
.1101	68		pla				pla
.1102	60		rts				rts
.1103					BufferClear:
.1103	9c 02 05	stz $0502			stz 	bufferSize
.1106	60		rts				rts
.1107					BufferWrite:
.1107	da		phx				phx
.1108	ae 02 05	ldx $0502			ldx 	bufferSize
.110b	9d 03 05	sta $0503,x			sta 	dataBuffer,x
.110e	ee 02 05	inc $0502			inc 	bufferSize
.1111	fa		plx				plx
.1112	60		rts				rts
.1113					BufferOutput:
.1113	ad 02 05	lda $0502			lda 	bufferSize
.1116	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1119	a2 00		ldx #$00			ldx 	#0
.111b					_BOLoop:
.111b	ec 02 05	cpx $0502			cpx 	bufferSize
.111e	f0 09		beq $1129			beq 	_BOExit
.1120	bd 03 05	lda $0503,x			lda 	dataBuffer,x
.1123	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1126	e8		inx				inx
.1127	80 f2		bra $111b			bra 	_BOLoop
.1129					_BOExit:
.1129	60		rts				rts
.0502					bufferSize:
>0502							.fill 	1
.0503					dataBuffer:
>0503							.fill 	256
.112a					CheckNextComma:
.112a	a9 2c		lda #$2c			lda	 	#","
.112c	80 06		bra $1134			bra 	CheckNextA
.112e					CheckNextRParen:
.112e	a9 29		lda #$29			lda	 	#")"
.1130	80 02		bra $1134			bra 	CheckNextA
.1132					CheckNextLParen:
.1132	a9 28		lda #$28			lda 	#"("
.1134					CheckNextA:
.1134	8d 03 06	sta $0603			sta 	checkCharacter 				; save test character
.1137					_CNALoop:
.1137	20 3c 1a	jsr $1a3c			jsr 	GetNextNonSpace 			; get next skipping spaces.
.113a	cd 03 06	cmp $0603			cmp 	checkCharacter 				; matches ?
.113d	f0 03		beq $1142			beq 	_CNAExit
.113f	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.1142					_CNAExit:
.1142	60		rts				rts
.0603					checkCharacter:
>0603							.fill 	1
.1143					StartCompiler:
.1143	86 2c		stx $2c				stx 	zTemp0 						; access API
.1145	84 2d		sty $2d				sty 	zTemp0+1
.1147	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.1149	b2 2c		lda ($2c)			lda 	(zTemp0)
.114b	8d 05 06	sta $0605			sta 	APIVector
.114e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1150	8d 06 06	sta $0606			sta 	APIVector+1
.1153	c8		iny				iny 								; copy data area range.
.1154	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1156	8d 07 06	sta $0607			sta 	compilerStartHigh
.1159	c8		iny				iny
.115a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.115c	8d 08 06	sta $0608			sta 	compilerEndHigh
.115f	ba		tsx				tsx 								; save stack pointer
.1160	8e 04 06	stx $0604			stx 	compilerSP
.1163	20 d5 1d	jsr $1dd5			jsr 	STRReset 					; reset storage (line#, variable)
.1166	20 18 10	jsr $1018			jsr 	APIIOpen 					; reset data input
.1169	20 62 10	jsr $1062			jsr 	APIOOpen 					; reset data output.
.116c	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.116e	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1171	a9 00		lda #$00			lda 	#0
.1173	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1176	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1179					MainCompileLoop:
.1179	20 2a 10	jsr $102a			jsr 	ReadNextLine 				; read next line into the buffer.
.117c	90 2e		bcc $11ac			bcc 	SaveCodeAndExit 			; end of source.
.117e	20 5b 10	jsr $105b			jsr 	GetLineNumber 				; get line #
.1181	20 b6 1b	jsr $1bb6			jsr 	STRMarkLine 				; remember the position and number of this line.
.1184	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.1186	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1189					_MCLSameLine:
.1189	20 3c 1a	jsr $1a3c			jsr 	GetNextNonSpace 			; get the first character.
.118c	f0 eb		beq $1179			beq 	MainCompileLoop 			; end of line, get next line.
.118e	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.1190	f0 f7		beq $1189			beq 	_MCLSameLine
.1192	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.1194	10 0c		bpl $11a2			bpl 	_MCLCheckAssignment
.1196	a2 fd		ldx #$fd			ldx 	#CommandTables & $FF 		; do command tables.
.1198	a0 15		ldy #$15			ldy 	#CommandTables >> 8
.119a	20 c5 18	jsr $18c5			jsr 	GeneratorProcess
.119d	b0 ea		bcs $1189			bcs 	_MCLSameLine 				; keep trying to compile the line.
.119f					_MCLSyntax:
.119f	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.11a2					_MCLCheckAssignment:
.11a2	20 52 1a	jsr $1a52			jsr 	CharIsAlpha 				; if not alpha then syntax error
.11a5	90 f8		bcc $119f			bcc 	_MCLSyntax
.11a7	20 84 1b	jsr $1b84			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.11aa	80 dd		bra $1189			bra		_MCLSameLine 				; loop back.
.11ac					SaveCodeAndExit:
.11ac	20 20 10	jsr $1020			jsr 	APIIClose 					; finish input.
.11af	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.11b1	a8		tay				tay
.11b2	20 b6 1b	jsr $1bb6			jsr 	STRMarkLine
.11b5	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.11b7	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.11ba	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.11bc	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.11bf	20 e9 14	jsr $14e9			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.11c2	20 0e 10	jsr $100e			jsr 	APIOClose
.11c5					ExitCompiler:
.11c5	ae 04 06	ldx $0604			ldx 	compilerSP 					; reload SP and exit.
.11c8	9a		txs				txs
.11c9	60		rts				rts
.11ca					CallAPIHandler:
.11ca	6c 05 06	jmp ($0605)			jmp 	(APIVector)
.0604					compilerSP:
>0604							.fill 	1
.0605					APIVector:
>0605							.fill 	2
.0607					compilerStartHigh:
>0607							.fill 	1
.0608					compilerEndHigh:
>0608							.fill 	1
.11cd					PushIntegerYA:
.11cd	c0 00		cpy #$00			cpy 	#0 							; 0-255
.11cf	f0 0f		beq $11e0			beq 	PushIntegerA
.11d1	48		pha				pha
.11d2	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.11d4	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.11d7	68		pla				pla 								; then LSB
.11d8	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.11db	98		tya				tya 								; then MSB
.11dc	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.11df	60		rts				rts
.11e0					PushIntegerA:
.11e0	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.11e2	90 07		bcc $11eb			bcc 	_PIWriteA
.11e4	48		pha				pha
.11e5	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.11e7	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.11ea	68		pla				pla
.11eb					_PIWriteA:
.11eb	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.11ee	60		rts				rts
.11ef					PushFloat:
.11ef	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.11f1	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.11f4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.11f6	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.11f9	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.11fb	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.11fe	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1200	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1203	b5 56		lda $56,x			lda 	NSMantissa2,x
.1205	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1208	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.120a	29 80		and #$80			and 	#$80
.120c	15 62		ora $62,x			ora 	NSMantissa3,x
.120e	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1211	60		rts				rts
.1212					CreateVariableRecord:
.1212	48		pha				pha
.1213	ad 13 06	lda $0613			lda 	freeVariableMemory 		; push current free address on stack.
.1216	48		pha				pha
.1217	ad 14 06	lda $0614			lda 	freeVariableMemory+1
.121a	48		pha				pha
.121b	ad 11 06	lda $0611			lda 	variableListEnd  		; copy end of list to zTemp0
.121e	85 2c		sta $2c				sta 	zTemp0
.1220	ad 12 06	lda $0612			lda 	variableListEnd+1
.1223	85 2d		sta $2d				sta 	zTemp0+1
.1225	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.1227	92 2c		sta ($2c)			sta 	(zTemp0)
.1229	98		tya				tya
.122a	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.122c	91 2c		sta ($2c),y			sta 	(zTemp0),y
.122e	88		dey				dey
.122f	8a		txa				txa
.1230	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1232	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.1234	ad 13 06	lda $0613			lda 	freeVariableMemory
.1237	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1239	c8		iny				iny
.123a	ad 14 06	lda $0614			lda 	freeVariableMemory+1
.123d	91 2c		sta ($2c),y			sta 	(zTemp0),y
.123f	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.1241	a9 00		lda #$00			lda 	#0
.1243	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1245	18		clc				clc
.1246	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.1248	6d 11 06	adc $0611			adc  	variableListEnd
.124b	8d 11 06	sta $0611			sta 	variableListEnd
.124e	90 03		bcc $1253			bcc 	_CVNoCarry2
.1250	ee 12 06	inc $0612			inc 	variableListEnd+1
.1253					_CVNoCarry2:
.1253	7a		ply				ply
.1254	fa		plx				plx
.1255	68		pla				pla
.1256	60		rts				rts
.1257					SetVariableRecordToCodePosition:
.1257	48		pha				pha
.1258	5a		phy				phy
.1259	a5 2b		lda $2b				lda 	objPage
.125b	a0 03		ldy #$03			ldy 	#3
.125d	91 2c		sta ($2c),y			sta 	(zTemp0),y
.125f	c8		iny				iny
.1260	a5 2a		lda $2a				lda 	objPtr+1
.1262	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1264	c8		iny				iny
.1265	a5 29		lda $29				lda 	objPtr
.1267	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1269	7a		ply				ply
.126a	68		pla				pla
.126b	60		rts				rts
.126c					AllocateBytesForType:
.126c	48		pha				pha
.126d	da		phx				phx
.126e	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.1270	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1272	c9 00		cmp #$00			cmp 	#NSSIFloat
.1274	d0 02		bne $1278			bne 	_CVNotFloat
.1276	a2 06		ldx #$06			ldx 	#6
.1278					_CVNotFloat:
.1278	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.1279	18		clc				clc
.127a	6d 13 06	adc $0613			adc 	freeVariableMemory
.127d	8d 13 06	sta $0613			sta 	freeVariableMemory
.1280	90 03		bcc $1285			bcc 	_CVNoCarry1
.1282	ee 14 06	inc $0614			inc 	freeVariableMemory+1
.1285					_CVNoCarry1:
.1285	fa		plx				plx
.1286	68		pla				pla
.1287	60		rts				rts
.1288					CommandDATA:
.1288	20 03 11	jsr $1103			jsr 	BufferClear 				; copy it to the buffer
.128b	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace
.128e					_CTDataLoop:
.128e	20 20 1a	jsr $1a20			jsr 	LookNext 					; reached EOL
.1291	f0 08		beq $129b			beq 	_CTDataDone
.1293	20 07 11	jsr $1107			jsr 	BufferWrite 				; write and consume
.1296	20 31 1a	jsr $1a31			jsr 	GetNext
.1299	80 f3		bra $128e			bra 	_CTDataLoop
.129b					_CTDataDone:
.129b	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.129d	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.12a0	20 13 11	jsr $1113			jsr 	BufferOutput
.12a3	60		rts				rts
.12a4					CommandDEF:
.12a4	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.12a6	20 e0 11	jsr $11e0			jsr 	PushIntegerA
.12a9	20 48 1b	jsr $1b48			jsr 	CompileGotoEOL 				; compile skip over DEF
.12ac	a9 a5		lda #$a5			lda 	#C64_FN
.12ae	20 34 11	jsr $1134			jsr 	CheckNextA
.12b1	20 3c 1a	jsr $1a3c			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.12b4	20 a1 1a	jsr $1aa1			jsr 	ExtractVariableName
.12b7	8a		txa				txa
.12b8	10 51		bpl $130b			bpl 	_CDError
.12ba	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.12bb	29 7f		and #$7f			and 	#$7F
.12bd	aa		tax				tax
.12be	98		tya				tya
.12bf	09 80		ora #$80			ora 	#$80
.12c1	a8		tay				tay
.12c2	20 8d 14	jsr $148d			jsr 	FindVariable				; does it already exist ?
.12c5	b0 44		bcs $130b			bcs 	_CDError 					; if so, that's an error.
.12c7	20 12 12	jsr $1212			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.12ca	20 57 12	jsr $1257			jsr 	SetVariableRecordToCodePosition
.12cd	20 3c 1a	jsr $1a3c			jsr 	GetNextNonSpace
.12d0	20 92 1d	jsr $1d92			jsr 	GetReferenceTerm 			; get var ref, not array
.12d3	c9 00		cmp #$00			cmp 	#0
.12d5	30 34		bmi $130b			bmi 	_CDError
.12d7	8d 09 06	sta $0609			sta 	defType 					; save type
.12da	8e 0a 06	stx $060a			stx 	defVariable 				; save var ref
.12dd	8c 0b 06	sty $060b			sty 	defVariable+1
.12e0	29 40		and #$40			and 	#NSSString 					; only numbers.
.12e2	d0 27		bne $130b			bne 	_CDError
.12e4	20 2e 11	jsr $112e			jsr 	CheckNextRParen 			; check )
.12e7	a9 b2		lda #$b2			lda 	#C64_EQUAL
.12e9	20 34 11	jsr $1134			jsr 	CheckNextA 					; check =
.12ec	18		clc				clc 								; if this is DEF FNxx(A), read A
.12ed	20 0e 13	jsr $130e			jsr 	CDReadWriteVariable
.12f0	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.12f2	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.12f5	38		sec				sec
.12f6	20 0e 13	jsr $130e			jsr 	CDReadWriteVariable 		; A is now updated
.12f9	20 d3 13	jsr $13d3			jsr 	CompileExpressionAt0 		; the actual body of the function.
.12fc	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.12fe	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1301	38		sec				sec
.1302	20 0e 13	jsr $130e			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.1305	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.1307	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.130a	60		rts				rts
.130b					_CDError:
.130b	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.130e					CDReadWriteVariable:
.130e	ac 0b 06	ldy $060b			ldy 	defVariable+1 				; set up YX
.1311	ae 0a 06	ldx $060a			ldx 	defVariable
.1314	ad 09 06	lda $0609			lda 	defType
.1317	20 44 1d	jsr $1d44			jsr 	GetSetVariable
.131a	60		rts				rts
.0609					defType:
>0609							.fill 	1
.060a					defVariable:
>060a							.fill 	2
.131b					CommandDIM:
.131b	20 3c 1a	jsr $1a3c			jsr 	GetNextNonSpace 			; get the first non space character
.131e	20 a1 1a	jsr $1aa1			jsr 	ExtractVariableName 		; variable name to XY
.1321	da		phx				phx 								; save name with type bits.
.1322	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.1324	10 37		bpl $135d			bpl 	_CDError
.1326	20 8d 14	jsr $148d			jsr 	FindVariable	 			; see if already exist
.1329	b0 35		bcs $1360			bcs 	_CDRedefine 				; it still exists.
.132b	20 12 12	jsr $1212			jsr 	CreateVariableRecord 		; create the basic variable
.132e	20 6c 12	jsr $126c			jsr 	AllocateBytesForType 		; allocate memory for it
.1331	68		pla				pla 								; restore type bits
.1332	5a		phy				phy 								; save the address of the basic storage
.1333	da		phx				phx
.1334	48		pha				pha
.1335	20 63 13	jsr $1363			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.1338	68		pla				pla
.1339	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.133b	20 e0 11	jsr $11e0			jsr 	PushIntegerA 				; push that type data out.
.133e	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.1340	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1343	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.1345	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1348	fa		plx				plx 								; restore address
.1349	7a		ply				ply
.134a	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.134c	38		sec				sec
.134d	20 44 1d	jsr $1d44			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.1350	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; , follows ?
.1353	c9 2c		cmp #$2c			cmp 	#","
.1355	d0 05		bne $135c			bne 	_CDExit
.1357	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume comma
.135a	80 bf		bra $131b			bra 	CommandDIM 					; do another DIM
.135c					_CDExit:
.135c	60		rts				rts
.135d					_CDError:
.135d	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.1360					_CDRedefine:
.1360	4c f8 1f	jmp $1ff8		jmp	ErrorV_redefine
.1363					OutputIndexGroup:
.1363	9c 0c 06	stz $060c			stz 	IndexCount 					; count of number of indices.
.1366					_OIGNext:
.1366	20 d3 13	jsr $13d3			jsr 	CompileExpressionAt0 		; get a dimension
.1369	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.136b	c9 00		cmp #$00			cmp 	#NSSIFloat
.136d	d0 19		bne $1388			bne 	_OIGType
.136f	ee 0c 06	inc $060c			inc 	IndexCount 					; bump the counter.
.1372	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; does a , follow ?
.1375	c9 2c		cmp #$2c			cmp 	#","
.1377	d0 05		bne $137e			bne 	_OIGCheckEnd
.1379	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume comma
.137c	80 e8		bra $1366			bra 	_OIGNext 					; get next dimension
.137e					_OIGCheckEnd:
.137e	20 2e 11	jsr $112e			jsr 	CheckNextRParen 			; check and consume )
.1381	ad 0c 06	lda $060c			lda 	IndexCount
.1384	20 e0 11	jsr $11e0			jsr 	PushIntegerA 				; compile the dimension count.
.1387	60		rts				rts
.1388					_OIGType:
.1388	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.060c					IndexCount:
>060c							.fill 	1
.138b					ErrorHandler:
.138b	68		pla				pla
.138c	7a		ply				ply
.138d	85 2c		sta $2c				sta 	zTemp0
.138f	84 2d		sty $2d				sty 	zTemp0+1
.1391	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.1393	a0 01		ldy #$01			ldy 	#1
.1395					_EHDisplayMsg:
.1395	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1397	20 f9 10	jsr $10f9			jsr 	PrintCharacter
.139a	c8		iny				iny
.139b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.139d	d0 f6		bne $1395			bne 	_EHDisplayMsg
.139f	a9 20		lda #$20			lda 	#32
.13a1	20 f9 10	jsr $10f9			jsr 	PrintCharacter
.13a4	a9 40		lda #$40			lda 	#64
.13a6	20 f9 10	jsr $10f9			jsr 	PrintCharacter
.13a9	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.13ab	20 78 26	jsr $2678			jsr 	FloatSetByte
.13ae	20 5b 10	jsr $105b			jsr 	GetLineNumber
.13b1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13b3	98		tya				tya
.13b4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13b6	20 5e 25	jsr $255e			jsr 	FloatToString
.13b9	a0 00		ldy #$00			ldy 	#0 							; display that string.
.13bb	a2 00		ldx #$00			ldx 	#0
.13bd					_EHDisplayLine:
.13bd	b9 3c 06	lda $063c,y			lda 	decimalBuffer,y
.13c0	20 f9 10	jsr $10f9			jsr 	PrintCharacter
.13c3	c8		iny				iny
.13c4	b9 3c 06	lda $063c,y			lda 	decimalBuffer,y
.13c7	d0 f4		bne $13bd			bne 	_EHDisplayLine
.13c9	a9 0d		lda #$0d			lda 	#13
.13cb	20 f9 10	jsr $10f9			jsr 	PrintCharacter
.13ce	80 fe		bra $13ce	_EHHalt:bra 	_EHHalt
.13d0	4c c5 11	jmp $11c5			jmp 	ExitCompiler
.13d3					CompileExpressionAt0:
.13d3	a9 00		lda #$00			lda 	#0
.13d5					CompileExpressionAtA:
.13d5	48		pha				pha  								; save level
.13d6	20 fd 1d	jsr $1dfd			jsr 	CompileTerm 				; compile a term.
.13d9	fa		plx				plx 								; get level back into X
.13da					_ECALoop:
.13da	48		pha				pha 								; save type on stack.
.13db	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; get the next character
.13de	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.13e0	90 04		bcc $13e6			bcc 	_ECAExit
.13e2	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.13e4	90 02		bcc $13e8			bcc 	_ECAHaveToken
.13e6					_ECAExit:
.13e6	68		pla				pla 								; throw type off stack
.13e7	60		rts				rts
.13e8					_ECAHaveToken:
.13e8	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.13ea	aa		tax				tax 								; X contains the operator token
.13eb	bd d6 13	lda $13d6,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.13ee	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.13f0	90 f4		bcc $13e6			bcc 	_ECAExit
.13f2	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.13f4	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume the token.
.13f7	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.13f9	f0 11		beq $140c			beq 	_ECAGreaterCheck
.13fb	e0 b3		cpx #$b3			cpx 	#C64_LESS
.13fd	d0 1a		bne $1419			bne 	_ECAHaveFullToken
.13ff	20 20 1a	jsr $1a20			jsr 	LookNext 					; checks for < (<= or <>)
.1402	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.1404	f0 0e		beq $1414			beq	 	_ECAToNotEqual
.1406	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.1408	d0 0f		bne $1419			bne 	_ECAHaveFullToken
.140a	80 07		bra $1413			bra 	_ECAAddEqual
.140c					_ECAGreaterCheck:
.140c	20 20 1a	jsr $1a20			jsr 	LookNext
.140f	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.1411	d0 06		bne $1419			bne 	_ECAHaveFullToken
.1413					_ECAAddEqual:
.1413	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.1414					_ECAToNotEqual:
.1414	e8		inx				inx
.1415	e8		inx				inx
.1416	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume the = or > in >= <= <>
.1419					_ECAHaveFullToken:
.1419	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.141b	d0 0a		bne $1427			bne 	_ECANotConcat
.141d	68		pla				pla 								; get type back
.141e	48		pha				pha
.141f	29 40		and #$40			and 	#NSSTypeMask
.1421	c9 40		cmp #$40			cmp 	#NSSString
.1423	d0 02		bne $1427			bne 	_ECANotConcat
.1425	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1427					_ECANotConcat:
.1427	da		phx				phx 								; save operator on the stack
.1428	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.142a	da		phx				phx
.142b	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.142d	1a		inc a				inc 	a
.142e	20 d5 13	jsr $13d5			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.1431	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.1433	fa		plx				plx 								; restore current precedence in X
.1434	68		pla				pla 								; restore operator
.1435	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.1437	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.1439	90 17		bcc $1452			bcc 	_ECANotCompare
.143b	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.143d	b0 13		bcs $1452			bcs 	_ECANotCompare
.143f	7a		ply				ply 								; get type into Y
.1440	5a		phy				phy
.1441	48		pha				pha 								; save operator
.1442	98		tya				tya 								; get type
.1443	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.1445	29 40		and #$40			and 	#NSSTypeMask
.1447	c9 40		cmp #$40			cmp 	#NSSString
.1449	f0 02		beq $144d			beq 	_ECANotString
.144b	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.144d					_ECANotString:
.144d	98		tya				tya									; output token Y
.144e	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1451	68		pla				pla 								; restore operator.
.1452					_ECANotCompare:
.1452	18		clc				clc 								; convert to P-Code and compile.
.1453	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.1455	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1458	68		pla				pla 								; type of current result
.1459	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.145b	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.145d	d0 19		bne $1478			bne		_ECAType
.145f	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.1461	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.1463	d0 18		bne $147d			bne 	_ECAGoLoop
.1465	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.1467	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1469	f0 10		beq $147b			beq 	_ECAOkayString 				; (this is post conversion)
.146b	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.146d	90 09		bcc $1478			bcc 	_ECAType
.146f	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.1471	b0 05		bcs $1478			bcs 	_ECAType
.1473	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.1475	4c da 13	jmp $13da			jmp 	_ECALoop
.1478					_ECAType:
.1478	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.147b					_ECAOkayString:
.147b	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.147d					_ECAGoLoop:
.147d	4c da 13	jmp $13da			jmp 	_ECALoop
.1480					PrecedenceTable:
>1480	03						.byte 	3 					; '+'
>1481	03						.byte 	3 					; '-'
>1482	04						.byte 	4 					; '*'
>1483	04						.byte 	4 					; '/'
>1484	05						.byte 	5 					; '^'
>1485	01						.byte 	1 					; 'and'
>1486	00						.byte 	0 					; 'or'
>1487	02						.byte 	2 					; '>'
>1488	02						.byte 	2 					; '='
>1489	02						.byte 	2 					; '<'
>148a	02						.byte 	2 					; '>='
>148b	02						.byte 	2 					; '<='
>148c	02						.byte 	2 					; '<>'
.148d					FindVariable:
.148d	86 2e		stx $2e				stx 	zTemp1 						; save name.
.148f	84 2f		sty $2f				sty 	zTemp1+1
.1491					_IVCheckSpecial:
.1491	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.1493	d0 18		bne $14ad			bne 	_IVStandard
.1495	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.1497	f0 0c		beq $14a5			beq 	_IVTIFloat
.1499	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.149b	d0 10		bne $14ad			bne 	_IVStandard
.149d	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.149f	a2 01		ldx #$01			ldx 	#$01
.14a1	a9 40		lda #$40			lda 	#NSSString
.14a3	38		sec				sec
.14a4	60		rts				rts
.14a5					_IVTIFloat:
.14a5	a0 80		ldy #$80			ldy 	#$80
.14a7	a2 00		ldx #$00			ldx 	#$00
.14a9	a9 00		lda #$00			lda 	#0
.14ab	38		sec				sec
.14ac	60		rts				rts
.14ad					_IVStandard:
.14ad	ad 07 06	lda $0607			lda 	compilerStartHigh			; start scanning from here.
.14b0	85 2d		sta $2d				sta 	zTemp0+1
.14b2	64 2c		stz $2c				stz 	zTemp0
.14b4					_IVCheckLoop:
.14b4	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.14b6	f0 2b		beq $14e3			beq  	_IVNotFound 				; if so, return with CC.
.14b8	a0 01		ldy #$01			ldy 	#1 							; match ?
.14ba	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14bc	c5 2e		cmp $2e				cmp 	zTemp1
.14be	d0 07		bne $14c7			bne	 	_IVNext
.14c0	c8		iny				iny
.14c1	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14c3	c5 2f		cmp $2f				cmp 	zTemp1+1
.14c5	f0 0d		beq $14d4			beq 	_IVFound
.14c7					_IVNext:
.14c7	18		clc				clc
.14c8	a5 2c		lda $2c				lda 	zTemp0
.14ca	72 2c		adc ($2c)			adc 	(zTemp0)
.14cc	85 2c		sta $2c				sta 	zTemp0
.14ce	90 e4		bcc $14b4			bcc 	_IVCheckLoop
.14d0	e6 2d		inc $2d				inc 	zTemp0+1
.14d2	80 e0		bra $14b4			bra 	_IVCheckLoop
.14d4					_IVFound:
.14d4	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.14d6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14d8	aa		tax				tax
.14d9	c8		iny				iny
.14da	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14dc	48		pha				pha
.14dd	c8		iny				iny
.14de	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14e0	7a		ply				ply
.14e1	38		sec				sec
.14e2	60		rts				rts
.14e3					_IVNotFound:
.14e3	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.14e5	a4 2f		ldy $2f				ldy 	zTemp1+1
.14e7	18		clc				clc
.14e8	60		rts				rts
.14e9					FixBranches:
.14e9	20 62 10	jsr $1062			jsr 	APIORewind 					; back to the start of the *object* code.
.14ec					_FBLoop:
.14ec	b2 29		lda ($29)			lda 	(objPtr) 					; get the next one.
.14ee	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.14f0	f0 16		beq $1508			beq 	_FBFixGotoGosub
.14f2	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.14f4	f0 12		beq $1508			beq 	_FBFixGotoGosub
.14f6	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.14f8	f0 0e		beq $1508			beq 	_FBFixGotoGosub
.14fa	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.14fc	f0 0a		beq $1508			beq 	_FBFixGotoGosub
.14fe	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.1500	f0 49		beq $154b			beq 	_FBFixVarSpace
.1502					_FBNext:
.1502	20 45 20	jsr $2045			jsr 	MoveObjectForward 			; move forward in object code.
.1505	90 e5		bcc $14ec			bcc 	_FBLoop 					; not finished
.1507					_FBExit:
.1507	60		rts				rts
.1508					_FBFixGotoGosub:
.1508	a0 01		ldy #$01			ldy 	#1 							; if page is currently $FF
.150a	b1 29		lda ($29),y			lda 	(objPtr),y 					; then patch else leave.
.150c	c9 ff		cmp #$ff			cmp 	#$FF
.150e	d0 f2		bne $1502			bne 	_FBNext
.1510	a0 02		ldy #$02			ldy 	#2							; line number in YA
.1512	b1 29		lda ($29),y			lda 	(objPtr),y
.1514	48		pha				pha
.1515	c8		iny				iny
.1516	b1 29		lda ($29),y			lda 	(objPtr),y
.1518	a8		tay				tay
.1519	68		pla				pla
.151a	20 e4 1b	jsr $1be4			jsr 	STRFindLine			 		; find where it is X:YA
.151d	90 08		bcc $1527			bcc 	_FBFFound 					; not found, so must be >
.151f	48		pha				pha
.1520	b2 29		lda ($29)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.1522	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1524	d0 15		bne $153b			bne 	_FBFFail
.1526	68		pla				pla
.1527					_FBFFound:
.1527	20 38 1c	jsr $1c38			jsr 	STRMakeOffset 				; make it an offset from X:YA
.152a	5a		phy				phy	 								; patch the GOTO/GOSUB
.152b	48		pha				pha
.152c	a0 01		ldy #$01			ldy 	#1
.152e	8a		txa				txa
.152f	91 29		sta ($29),y			sta 	(objPtr),y
.1531	c8		iny				iny
.1532	68		pla				pla
.1533	91 29		sta ($29),y			sta 	(objPtr),y
.1535	c8		iny				iny
.1536	68		pla				pla
.1537	91 29		sta ($29),y			sta 	(objPtr),y
.1539	80 c7		bra $1502			bra 	_FBNext
.153b					_FBFFail:
.153b	a0 02		ldy #$02			ldy 	#2
.153d	b1 29		lda ($29),y			lda 	(objPtr),y
.153f	8d 00 05	sta $0500			sta 	currentLineNumber
.1542	c8		iny				iny
.1543	b1 29		lda ($29),y			lda 	(objPtr),y
.1545	8d 01 05	sta $0501			sta 	currentLineNumber+1
.1548	4c 73 1f	jmp $1f73		jmp	ErrorV_line
.154b					_FBFixVarSpace:
.154b	a0 01		ldy #$01			ldy 	#1
.154d	ad 13 06	lda $0613			lda 	freeVariableMemory
.1550	91 29		sta ($29),y			sta 	(objPtr),y
.1552	c8		iny				iny
.1553	ad 14 06	lda $0614			lda 	freeVariableMemory+1
.1556	91 29		sta ($29),y			sta 	(objPtr),y
.1558	80 a8		bra $1502			bra 	_FBNext
.155a					CommandFOR:
.155a	20 3c 1a	jsr $1a3c			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.155d	20 52 1a	jsr $1a52			jsr 	CharIsAlpha 				; if not alpha , error
.1560	90 59		bcc $15bb			bcc 	_CFFail
.1562	20 92 1d	jsr $1d92			jsr 	GetReferenceTerm 			; figure out the reference.
.1565	48		pha				pha 								; save type
.1566	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1568	c9 00		cmp #$00			cmp 	#NSSIFloat
.156a	d0 4f		bne $15bb			bne 	_CFFail
.156c	5a		phy				phy 								; save reference on the stack
.156d	da		phx				phx
.156e	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.1570	20 34 11	jsr $1134			jsr 	CheckNextA
.1573	20 d3 13	jsr $13d3			jsr 	CompileExpressionAt0 		; initial value
.1576	fa		plx				plx 								; get reference back.
.1577	7a		ply				ply
.1578	5a		phy				phy
.1579	da		phx				phx
.157a	38		sec				sec 								; set initial value.
.157b	20 44 1d	jsr $1d44			jsr 	GetSetVariable
.157e	fa		plx				plx
.157f	7a		ply				ply
.1580	68		pla				pla
.1581	29 20		and #$20			and 	#NSSIInt16
.1583	f0 04		beq $1589			beq 	_CFNotInt16
.1585	98		tya				tya
.1586	09 80		ora #$80			ora 	#$80
.1588	a8		tay				tay
.1589					_CFNotInt16:
.1589	8a		txa				txa 								; reference in YA
.158a	20 cd 11	jsr $11cd			jsr 	PushIntegerYA
.158d	a9 a4		lda #$a4			lda 	#C64_TO
.158f	20 34 11	jsr $1134			jsr 	CheckNextA
.1592	20 d3 13	jsr $13d3			jsr 	CompileExpressionAt0 		; terminal value
.1595	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1597	c9 00		cmp #$00			cmp 	#NSSIFloat
.1599	d0 20		bne $15bb			bne 	_CFFail
.159b	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; followed by STEP
.159e	c9 a9		cmp #$a9			cmp 	#C64_STEP
.15a0	d0 0e		bne $15b0			bne 	_CFNoStep
.15a2	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume it.
.15a5	20 d3 13	jsr $13d3			jsr 	CompileExpressionAt0 		; terminal value
.15a8	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15aa	c9 00		cmp #$00			cmp 	#NSSIFloat
.15ac	d0 0d		bne $15bb			bne 	_CFFail
.15ae	80 05		bra $15b5			bra 	_CFParametersDone
.15b0					_CFNoStep:
.15b0	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.15b2	20 e0 11	jsr $11e0			jsr 	PushIntegerA
.15b5					_CFParametersDone:
.15b5	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.15b7	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.15ba	60		rts				rts
.15bb					_CFFail:
.15bb	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.15be					FNCompile:
.15be	20 3c 1a	jsr $1a3c			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.15c1	20 a1 1a	jsr $1aa1			jsr 	ExtractVariableName
.15c4	e0 00		cpx #$00			cpx 	#0
.15c6	10 32		bpl $15fa			bpl 	_FNError
.15c8	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.15c9	29 7f		and #$7f			and 	#$7F
.15cb	aa		tax				tax
.15cc	98		tya				tya
.15cd	09 80		ora #$80			ora 	#$80
.15cf	a8		tay				tay
.15d0	20 8d 14	jsr $148d			jsr 	FindVariable				; does it already exist ?
.15d3	90 25		bcc $15fa			bcc 	_FNError 					; no.
.15d5	20 38 1c	jsr $1c38			jsr 	STRMakeOffset 				; convert to a relative address.
.15d8	c9 00		cmp #$00			cmp 	#0 							; fix up.
.15da	d0 01		bne $15dd			bne 	_FNNoBorrow
.15dc	88		dey				dey
.15dd					_FNNoBorrow:
.15dd	3a		dec a				dec 	a
.15de	5a		phy				phy 								; save location of routine on stack.
.15df	48		pha				pha
.15e0	da		phx				phx
.15e1	20 d3 13	jsr $13d3			jsr 	CompileExpressionAt0
.15e4	20 2e 11	jsr $112e			jsr 	CheckNextRParen
.15e7	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.15e9	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.15ec	68		pla				pla
.15ed	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.15f0	68		pla				pla
.15f1	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.15f4	68		pla				pla
.15f5	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.15f8	18		clc				clc
.15f9	60		rts				rts
.15fa					_FNError:
.15fa	4c 23 1f	jmp $1f23		jmp	ErrorV_value
.15fd					CommandTables:
>15fd	07 cb 00 03 ff 1a 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>1604	07 89 00 03 06 1b 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>160b	07 8d 00 03 f9 1a 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>1612	07 88 00 03 81 1b 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>1619	07 85 00 03 61 1b 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>1620	07 84 00 04 75 1b 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>1627	07 99 00 03 bf 1c 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>162e	07 98 00 04 bf 1c 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1635	07 8f 00 03 ca 1d 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>163c	07 81 00 03 5a 15 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>1643	07 82 00 03 42 1c 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>164a	07 a1 00 03 72 1a 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>1651	07 83 00 03 88 12 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>1658	07 87 00 03 08 1d 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>165f	07 86 00 03 1b 13 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>1666	07 96 00 03 a4 12 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>166d	07 8b 00 e3 29 1b 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>1674	08 92 00 ea e3 96 1e 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>167c	09 91 00 e1 a9 03 6e 1c			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>1684	06
>1685	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>168c	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>1693	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>1699	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>16a0	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>16a7	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>16ae	07 9d 00 e3 bc 1e 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>16b5	0a 9f 00 ea e3 cf 1e 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>16bd	c6 06
>16bf	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>16c5	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>16cc	0a ce 92 e3 ef 19 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>16d4	ad 06
>16d6	0a ce 8d e3 ef 19 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>16de	ae 06
>16e0	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>16e6	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>16ee	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>16f5	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>16fc	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>1704	06
>1705	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>170d	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>1715	9a 06
>1717	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>171f	9b 06
>1721	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>1729	9c 06
>172b	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>1733	06
>1734	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>173b	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>1743	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>174b	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>1753	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>175b	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>1763	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>176b	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>1773	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>177b	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>1783	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>178b	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>1792	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>179a	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>17a2	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>17aa	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>17b2	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>17ba	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>17c2	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>17ca	00						.byte 	0
.17cb					UnaryTables:
>17cb	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>17d2	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>17da	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>17e1	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>17e8	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>17ef	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>17f6	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>17fe	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>1805	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>180d	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>1815	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>181d	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>1825	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>182d	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>1835	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>183c	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>1843	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>184a	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>1851	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>1858	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>185f	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>1867	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>186f	0b ca 00 8f ae 03 ef 19			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>1877	91 bd 07
>187a	07 a8 00 03 0e 1a 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>1881	07 a5 00 03 be 15 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>1888	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>188f	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>1896	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>189e	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>18a6	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>18ad	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>18b4	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>18bb	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>18c3	06
>18c4	00						.byte 	0
.18c5					GeneratorProcess:
.18c5	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.18c7	84 2d		sty $2d				sty 	zTemp0+1
.18c9	85 2e		sta $2e				sta 	zTemp1 						; first match token
.18cb	64 2f		stz $2f				stz 	zTemp1+1
.18cd	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.18cf	d0 05		bne $18d6			bne 	_GPNotShifted
.18d1	20 31 1a	jsr $1a31			jsr 	GetNext 					; get the shifted token
.18d4	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.18d6					_GPNotShifted:
.18d6					_GPSearch:
.18d6	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.18d8	18		clc				clc
.18d9	f0 2f		beq $190a			beq 	_GPExit
.18db	a0 01		ldy #$01			ldy 	#1 							; tokens match
.18dd	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.18df	c5 2e		cmp $2e				cmp 	zTemp1
.18e1	d0 09		bne $18ec			bne 	_GPNext
.18e3	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.18e5	f0 12		beq $18f9			beq 	_GPFound
.18e7	c8		iny				iny 								; check match.
.18e8	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.18ea	f0 0d		beq $18f9			beq 	_GPFound
.18ec					_GPNext:
.18ec	18		clc				clc 								; follow to next
.18ed	a5 2c		lda $2c				lda 	zTemp0
.18ef	72 2c		adc ($2c)			adc 	(zTemp0)
.18f1	85 2c		sta $2c				sta 	zTemp0
.18f3	90 e1		bcc $18d6			bcc 	_GPSearch
.18f5	e6 2d		inc $2d				inc 	zTemp0+1
.18f7	80 dd		bra $18d6			bra 	_GPSearch
.18f9					_GPFound:
.18f9	18		clc				clc 								; skip to action bytes
.18fa	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.18fc	69 03		adc #$03			adc 	#3
.18fe	85 2c		sta $2c				sta 	zTemp0
.1900	90 02		bcc $1904			bcc 	_GPNoCarry
.1902	e6 2d		inc $2d				inc 	zTemp0+1
.1904					_GPNoCarry:
.1904					_GPLoop:
.1904	20 0b 19	jsr $190b			jsr 	GeneratorExecute 			; execute one command
.1907	90 fb		bcc $1904			bcc 	_GPLoop 					; go back if not completed.
.1909	38		sec				sec 								; return with CS.
.190a					_GPExit:
.190a	60		rts				rts
.190b					GeneratorExecute:
.190b	20 b6 19	jsr $19b6			jsr 	_GEFetchZTemp0 				; get next.
.190e	48		pha				pha 								; split into 2 nibbles
.190f	4a		lsr a				lsr 	a
.1910	4a		lsr a				lsr 	a
.1911	4a		lsr a				lsr		a
.1912	4a		lsr a				lsr 	a
.1913	20 1d 19	jsr $191d			jsr 	_GEExecuteNibble 			; MSB first
.1916	68		pla				pla
.1917	b0 03		bcs $191c			bcs 	_GEHaveCompleted
.1919	20 1d 19	jsr $191d			jsr 	_GEExecuteNibble 			; LSB second
.191c					_GEHaveCompleted:
.191c	60		rts				rts
.191d					_GEExecuteNibble:
.191d	29 0f		and #$0f			and 	#$0F
.191f	0a		asl a				asl 	a
.1920	aa		tax				tax
.1921	7c 24 19	jmp ($1924,x)			jmp 	(_GEExecuteVectors,x)
.1924					_GEExecuteVectors:
>1924	44 19						.word 	_GEXNop 					; 0  (no operation)
>1926	4c 19						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>1928	46 19						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>192a	99 19						.word 	_GEXExecute 				; 3  (run arbitrary code)
>192c	8c 19						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>192e	44 19						.word 	_GEXNop 					; 5
>1930	53 19						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>1932	57 19						.word 	_GEXExitString 				; 7  exit return string type
>1934	5b 19						.word 	_GEXLParam 					; 8  check ( follows
>1936	5f 19						.word 	_GEXRParam 					; 9  check ) follows
>1938	63 19						.word 	_GEXComma					; A  check , follows
>193a	44 19						.word 	_GEXNop 					; B
>193c	44 19						.word 	_GEXNop 					; C
>193e	44 19						.word 	_GEXNop 					; D
>1940	73 19						.word 	_GEXNumber 					; E  compile get any number
>1942	7e 19						.word 	_GEXString 					; F  compile get any string
.1944					_GEXNop:
.1944	18		clc				clc
.1945	60		rts				rts
.1946					_GEXToken2:
.1946	20 b6 19	jsr $19b6			jsr 	_GEFetchZTemp0
.1949	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.194c					_GEXToken1:
.194c	20 b6 19	jsr $19b6			jsr 	_GEFetchZTemp0
.194f	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1952	60		rts				rts
.1953					_GEXExitNumber:
.1953	a9 00		lda #$00			lda 	#NSSIFloat
.1955	38		sec				sec
.1956	60		rts				rts
.1957					_GEXExitString:
.1957	a9 40		lda #$40			lda 	#NSSString
.1959	38		sec				sec
.195a	60		rts				rts
.195b					_GEXLParam:
.195b	a9 28		lda #$28			lda 	#"("
.195d	80 06		bra $1965			bra 	_GEXCheck
.195f					_GEXRParam:
.195f	a9 29		lda #$29			lda 	#")"
.1961	80 02		bra $1965			bra 	_GEXCheck
.1963					_GEXComma:
.1963	a9 2c		lda #$2c			lda 	#","
.1965					_GEXCheck:
.1965	85 30		sta $30				sta 	zTemp2 						; save match
.1967	20 3c 1a	jsr $1a3c			jsr 	GetNextNonSpace 			; get next skipping spaces
.196a	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.196c	d0 02		bne $1970			bne 	_GEXSyntax
.196e	18		clc				clc
.196f	60		rts				rts
.1970					_GEXSyntax:
.1970	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.1973					_GEXNumber:
.1973	20 bf 19	jsr $19bf			jsr 	GEXCompileExpression 		; compile expression
.1976	29 40		and #$40			and 	#NSSTypeMask
.1978	c9 00		cmp #$00			cmp  	#NSSIFloat
.197a	d0 0d		bne $1989			bne 	_GEXType
.197c	18		clc				clc
.197d	60		rts				rts
.197e					_GEXString:
.197e	20 bf 19	jsr $19bf			jsr 	GEXCompileExpression 		; compile expression
.1981	29 40		and #$40			and 	#NSSTypeMask
.1983	c9 40		cmp #$40			cmp  	#NSSString
.1985	d0 02		bne $1989			bne 	_GEXType
.1987	18		clc				clc
.1988	60		rts				rts
.1989					_GEXType:
.1989	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.198c					_GEXChannelExec:
.198c	20 cf 19	jsr $19cf			jsr 	ChannelPrefix 				; set up default
.198f	20 99 19	jsr $1999			jsr 	_GEXExecute
.1992	08		php				php
.1993	20 e9 19	jsr $19e9			jsr 	ChannelPostfix 				; replace default.
.1996	28		plp				plp
.1997	60		rts				rts
>1998	db						.byte 	$DB 						; causes a break in the emulator
.1999					_GEXExecute:
.1999	20 b6 19	jsr $19b6			jsr 	_GEFetchZTemp0 				; get vector
.199c	85 30		sta $30				sta 	zTemp2
.199e	20 b6 19	jsr $19b6			jsr 	_GEFetchZTemp0
.19a1	85 31		sta $31				sta 	zTemp2+1
.19a3	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19a5	da		phx				phx
.19a6	a6 2d		ldx $2d				ldx 	zTemp0+1
.19a8	da		phx				phx
.19a9	20 b3 19	jsr $19b3			jsr 	_GECallZTemp2 				; execute code
.19ac	fa		plx				plx 								; recover generation exec
.19ad	86 2d		stx $2d				stx 	zTemp0+1
.19af	fa		plx				plx
.19b0	86 2c		stx $2c				stx 	zTemp0
.19b2	60		rts				rts
.19b3					_GECallZTemp2:
.19b3	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.19b6					_GEFetchZTemp0:
.19b6	b2 2c		lda ($2c)			lda 	(zTemp0)
.19b8	e6 2c		inc $2c				inc 	zTemp0
.19ba	d0 02		bne $19be			bne 	_GEFZ0Skip
.19bc	e6 2d		inc $2d				inc 	zTemp0+1
.19be					_GEFZ0Skip:
.19be	60		rts				rts
.19bf					GEXCompileExpression:
.19bf	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19c1	da		phx				phx
.19c2	a6 2d		ldx $2d				ldx 	zTemp0+1
.19c4	da		phx				phx
.19c5	20 d3 13	jsr $13d3			jsr 	CompileExpressionAt0 		; compile expression.
.19c8	fa		plx				plx 								; recover generation exec
.19c9	86 2d		stx $2d				stx 	zTemp0+1
.19cb	fa		plx				plx
.19cc	86 2c		stx $2c				stx 	zTemp0
.19ce	60		rts				rts
.19cf					ChannelPrefix:
.19cf	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.19d1	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.19d4	20 bf 19	jsr $19bf			jsr 	GEXCompileExpression 		; channel #
.19d7	29 40		and #$40			and 	#NSSTypeMask
.19d9	c9 00		cmp #$00			cmp 	#NSSIFloat
.19db	d0 09		bne $19e6			bne 	_CPXType
.19dd	20 2a 11	jsr $112a			jsr 	CheckNextComma 				; check , follows.
.19e0	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.19e2	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.19e5	60		rts				rts
.19e6					_CPXType:
.19e6	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.19e9					ChannelPostfix:
.19e9	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.19eb	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.19ee	60		rts				rts
.19ef					OptionalParameterCompile:
.19ef	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; what follows.
.19f2	c9 2c		cmp #$2c			cmp 	#","
.19f4	d0 0e		bne $1a04			bne 	_MidDefault
.19f6	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume ,
.19f9	20 d3 13	jsr $13d3			jsr 	CompileExpressionAt0
.19fc	29 40		and #$40			and 	#NSSTypeMask
.19fe	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a00	d0 09		bne $1a0b			bne 	MidFailType
.1a02	80 05		bra $1a09			bra 	_MidComplete
.1a04					_MidDefault:
.1a04	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1a06	20 e0 11	jsr $11e0			jsr 	PushIntegerA
.1a09					_MidComplete:
.1a09	18		clc				clc
.1a0a	60		rts				rts
.1a0b					MidFailType:
.1a0b	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.1a0e					NotUnaryCompile:
.1a0e	ad 88 14	lda $1488			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1a11	20 d5 13	jsr $13d5			jsr 	CompileExpressionAtA 		; evaluate at that level
.1a14	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1a16	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a18	d0 f1		bne $1a0b			bne 	MidFailType
.1a1a	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1a1c	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1a1f	60		rts				rts
.1a20					LookNext:
.1a20	b2 24		lda ($24)			lda 	(srcPtr)
.1a22	60		rts				rts
.1a23					LookNextNonSpace:
.1a23	b2 24		lda ($24)			lda 	(srcPtr)
.1a25	c9 20		cmp #$20			cmp		#' '
.1a27	f0 03		beq $1a2c			beq 	_LNNSkip
.1a29	c9 00		cmp #$00			cmp 	#0
.1a2b	60		rts				rts
.1a2c					_LNNSkip:
.1a2c	20 31 1a	jsr $1a31			jsr 	GetNext
.1a2f	80 f2		bra $1a23			bra 	LookNextNonSpace
.1a31					GetNext:
.1a31	b2 24		lda ($24)			lda 	(srcPtr) 					; get next
.1a33	e6 24		inc $24				inc 	srcPtr
.1a35	d0 02		bne $1a39			bne 	_GNSkip
.1a37	e6 25		inc $25				inc 	srcPtr+1
.1a39					_GNSkip:
.1a39	c9 00		cmp #$00			cmp 	#0
.1a3b	60		rts				rts
.1a3c					GetNextNonSpace:
.1a3c	20 31 1a	jsr $1a31			jsr 	GetNext
.1a3f	c9 20		cmp #$20			cmp 	#' '
.1a41	f0 f9		beq $1a3c			beq 	GetNextNonSpace
.1a43	c9 00		cmp #$00			cmp 	#0
.1a45	60		rts				rts
.1a46					CharIsDigit:
.1a46	c9 30		cmp #$30			cmp 	#"0"
.1a48	90 06		bcc $1a50			bcc 	CCFalse
.1a4a	c9 3a		cmp #$3a			cmp 	#"9"+1
.1a4c	b0 02		bcs $1a50			bcs 	CCFalse
.1a4e					CCTrue:
.1a4e	38		sec				sec
.1a4f	60		rts				rts
.1a50					CCFalse:
.1a50	18		clc				clc
.1a51	60		rts				rts
.1a52					CharIsAlpha:
.1a52	c9 41		cmp #$41			cmp 	#"A"
.1a54	90 fa		bcc $1a50			bcc 	CCFalse
.1a56	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1a58	b0 f6		bcs $1a50			bcs 	CCFalse
.1a5a	80 f2		bra $1a4e			bra 	CCTrue
.1a5c					ConvertHexStyle:
.1a5c	38		sec				sec
.1a5d	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1a5f	90 ef		bcc $1a50			bcc 	CCFalse
.1a61	c9 0a		cmp #$0a			cmp 	#9+1
.1a63	90 e9		bcc $1a4e			bcc 	CCTrue
.1a65	38		sec				sec 								; shift into hex space A=>0 Z=>25
.1a66	e9 11		sbc #$11			sbc 	#"A"-"0"
.1a68	90 e6		bcc $1a50			bcc 	CCFalse
.1a6a	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.1a6c	b0 e2		bcs $1a50			bcs 	CCFalse
.1a6e	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.1a70	80 dc		bra $1a4e			bra 	CCTrue
.1a72					CommandGET:
.1a72	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; # follows ?
.1a75	c9 23		cmp #$23			cmp 	#"#"
.1a77	d0 0d		bne $1a86			bne 	CommandGetBody
.1a79	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume #
.1a7c	20 cf 19	jsr $19cf			jsr 	ChannelPrefix 				; do it as GET#
.1a7f	20 86 1a	jsr $1a86			jsr 	CommandGetBody
.1a82	20 e9 19	jsr $19e9			jsr 	ChannelPostfix
.1a85	60		rts				rts
.1a86					CommandGetBody:
.1a86	20 3c 1a	jsr $1a3c			jsr 	GetNextNonSpace 			; get the first character
.1a89	20 92 1d	jsr $1d92			jsr 	GetReferenceTerm 			; identify variable to assign to
.1a8c	48		pha				pha
.1a8d	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1a8f	c9 40		cmp #$40			cmp 	#NSSString
.1a91	d0 0b		bne $1a9e			bne 	_CGType
.1a93	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1a95	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1a98	38		sec				sec
.1a99	68		pla				pla
.1a9a	20 44 1d	jsr $1d44			jsr		GetSetVariable
.1a9d	60		rts				rts
.1a9e					_CGType:
.1a9e	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.1aa1					ExtractVariableName:
.1aa1	20 52 1a	jsr $1a52			jsr 	CharIsAlpha
.1aa4	90 50		bcc $1af6			bcc 	_IVSyntax
.1aa6	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.1aa8	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.1aaa	64 2f		stz $2f				stz 	zTemp1+1
.1aac	20 20 1a	jsr $1a20			jsr 	LookNext 					; is there a second character ?
.1aaf	20 52 1a	jsr $1a52			jsr 	CharIsAlpha  				; must be alphanumeric
.1ab2	b0 05		bcs $1ab9			bcs 	_IVHasSecond
.1ab4	20 46 1a	jsr $1a46			jsr 	CharIsDigit
.1ab7	90 07		bcc $1ac0			bcc 	_IVCheckType
.1ab9					_IVHasSecond:
.1ab9	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.1abb	85 2f		sta $2f				sta 	zTemp1+1
.1abd					_IVGetNextCheck:
.1abd	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume it
.1ac0					_IVCheckType:
.1ac0	20 20 1a	jsr $1a20			jsr 	LookNext					; check if string follows.
.1ac3	20 52 1a	jsr $1a52			jsr 	CharIsAlpha
.1ac6	b0 f5		bcs $1abd			bcs 	_IVGetNextCheck
.1ac8	20 46 1a	jsr $1a46			jsr 	CharIsDigit
.1acb	b0 f0		bcs $1abd			bcs 	_IVGetNextCheck
.1acd	a2 40		ldx #$40			ldx 	#NSSString
.1acf	c9 24		cmp #$24			cmp 	#"$"
.1ad1	f0 06		beq $1ad9			beq 	_IVHasType
.1ad3	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.1ad5	c9 25		cmp #$25			cmp 	#"%"
.1ad7	d0 08		bne $1ae1			bne 	_IVCheckArray
.1ad9					_IVHasType:
.1ad9	8a		txa				txa 								; Or X into zTemp1
.1ada	05 2e		ora $2e				ora 	zTemp1
.1adc	85 2e		sta $2e				sta 	zTemp1
.1ade	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume it
.1ae1					_IVCheckArray:
.1ae1	20 20 1a	jsr $1a20			jsr 	LookNext 					; check if array follows
.1ae4	c9 28		cmp #$28			cmp 	#"("
.1ae6	d0 09		bne $1af1			bne 	_IVNotArray
.1ae8	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.1aea	09 80		ora #$80			ora 	#NSSArray
.1aec	85 2e		sta $2e				sta 	zTemp1
.1aee	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume it
.1af1					_IVNotArray:
.1af1	a6 2e		ldx $2e				ldx 	zTemp1
.1af3	a4 2f		ldy $2f				ldy 	zTemp1+1
.1af5	60		rts				rts
.1af6					_IVSyntax:
.1af6	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.1af9					CommandGOSUB:
.1af9	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1afb	20 0c 1b	jsr $1b0c			jsr 	CompileBranchCommand
.1afe	60		rts				rts
.1aff					CommandGOAlt:
.1aff	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1b01	20 34 11	jsr $1134			jsr 	CheckNextA
.1b04	80 00		bra $1b06			bra 	CommandGOTO
.1b06					CommandGOTO:
.1b06	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1b08	20 0c 1b	jsr $1b0c			jsr 	CompileBranchCommand
.1b0b	60		rts				rts
.1b0c					CompileBranchCommand:
.1b0c	20 ef 10	jsr $10ef			jsr 	WriteCodeByte 				; write the command out.
.1b0f	20 3c 1a	jsr $1a3c			jsr 	GetNextNonSpace
.1b12	20 9a 1c	jsr $1c9a			jsr 	ParseConstant 				; get constant into YA
.1b15	90 0f		bcc $1b26			bcc 	_CBCSyntax
.1b17	48		pha				pha
.1b18	a9 ff		lda #$ff			lda 	#$FF 						; no address yet.
.1b1a	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1b1d	68		pla				pla 								; and compile the actual line number
.1b1e	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1b21	98		tya				tya
.1b22	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1b25	60		rts				rts
.1b26					_CBCSyntax:
.1b26	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.1b29					CommandIF:
.1b29	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; what follows the tests ?
.1b2c	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1b2e	f0 0f		beq $1b3f			beq 	_CIGoto
.1b30	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1b32	20 34 11	jsr $1134			jsr 	CheckNextA
.1b35	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; THEN <number>
.1b38	20 46 1a	jsr $1a46			jsr 	CharIsDigit
.1b3b	b0 05		bcs $1b42			bcs 	_CIGoto2
.1b3d	80 09		bra $1b48			bra 	CompileGotoEOL
.1b3f					_CIGoto:
.1b3f	20 31 1a	jsr $1a31			jsr 	GetNext
.1b42					_CIGoto2:
.1b42	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1b44	20 0c 1b	jsr $1b0c			jsr 	CompileBranchCommand
.1b47	60		rts				rts
.1b48					CompileGotoEOL:
.1b48	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.1b4a	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1b4d	a9 ff		lda #$ff			lda 	#$FF
.1b4f	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1b52	20 5b 10	jsr $105b			jsr 	GetLineNumber 				; Get the current line number => YA
.1b55	1a		inc a				inc 	a 							; and branch to +1
.1b56	d0 01		bne $1b59			bne 	_CGENoCarry
.1b58	c8		iny				iny
.1b59					_CGENoCarry:
.1b59	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1b5c	98		tya				tya
.1b5d	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1b60	60		rts				rts
.1b61					CommandINPUT:
.1b61	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; check for "
.1b64	c9 22		cmp #$22			cmp 	#'"'
.1b66	d0 0d		bne $1b75			bne 	CommandINPUTStream
.1b68	20 d3 13	jsr $13d3			jsr 	CompileExpressionAt0
.1b6b	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1b6d	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1b70	a9 2c		lda #$2c			lda 	#","
.1b72	20 2a 11	jsr $112a			jsr 	CheckNextComma
.1b75					CommandINPUTStream:
.1b75	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1b77	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1b7a	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.1b7c	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1b7e	4c 0c 1d	jmp $1d0c			jmp 	CommandReadInputCommon
.1b81					CommandLET:
.1b81	20 3c 1a	jsr $1a3c			jsr 	GetNextNonSpace 			; get the first character
.1b84					CommandLETHaveFirst:
.1b84	20 92 1d	jsr $1d92			jsr 	GetReferenceTerm 			; identify variable to assign to
.1b87	da		phx				phx 								; save target on the stack.
.1b88	5a		phy				phy
.1b89	48		pha				pha
.1b8a	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.1b8c	20 34 11	jsr $1134			jsr 	CheckNextA
.1b8f	20 d3 13	jsr $13d3			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1b92	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.1b94	68		pla				pla 								; get type of assignment
.1b95	48		pha				pha
.1b96	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.1b98	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.1b9a	d0 17		bne $1bb3			bne 	_CLType
.1b9c	68		pla				pla 								; restore and compile save code
.1b9d	7a		ply				ply
.1b9e	fa		plx				plx
.1b9f	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.1ba1	f0 05		beq $1ba8			beq 	_CLTIString
.1ba3	38		sec				sec
.1ba4	20 44 1d	jsr $1d44			jsr		GetSetVariable
.1ba7	60		rts				rts
.1ba8					_CLTIString:
.1ba8	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.1baa	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1bad	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.1baf	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1bb2	60		rts				rts
.1bb3					_CLType:
.1bb3	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.1bb6					STRMarkLine:
.1bb6	48		pha				pha
.1bb7	38		sec				sec 								; allocate 5 bytes (line #, page+address)
.1bb8	ad 0f 06	lda $060f			lda 	lineNumberTable 			; and copy to zTemp0
.1bbb	e9 05		sbc #$05			sbc 	#5
.1bbd	8d 0f 06	sta $060f			sta 	lineNumberTable
.1bc0	85 2c		sta $2c				sta 	zTemp0
.1bc2	ad 10 06	lda $0610			lda 	lineNumberTable+1
.1bc5	e9 00		sbc #$00			sbc 	#0
.1bc7	8d 10 06	sta $0610			sta 	lineNumberTable+1
.1bca	85 2d		sta $2d				sta 	zTemp0+1
.1bcc	68		pla				pla
.1bcd	92 2c		sta ($2c)			sta 	(zTemp0) 					; save it in +0,+1
.1bcf	98		tya				tya
.1bd0	a0 01		ldy #$01			ldy 	#1
.1bd2	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1bd4	a5 2b		lda $2b				lda 	objPage 					; and page# in +2
.1bd6	c8		iny				iny
.1bd7	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1bd9	a5 29		lda $29				lda 	objPtr 						; save current address in +3,+4
.1bdb	c8		iny				iny
.1bdc	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1bde	a5 2a		lda $2a				lda 	objPtr+1
.1be0	c8		iny				iny
.1be1	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1be3	60		rts				rts
.1be4					STRFindLine:
.1be4	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.1be6	84 2d		sty $2d				sty 	zTemp0+1
.1be8	ad 08 06	lda $0608			lda 	compilerEndHigh 			; work backwards through table
.1beb	85 2f		sta $2f				sta 	zTemp1+1
.1bed	64 2e		stz $2e				stz 	zTemp1
.1bef					_STRSearch:
.1bef	20 2a 1c	jsr $1c2a			jsr 	_STRPrevLine 				; look at previous record.
.1bf2	a0 01		ldy #$01			ldy 	#1
.1bf4	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.1bf6	c5 2c		cmp $2c				cmp 	zTemp0
.1bf8	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1bfa	e5 2d		sbc $2d				sbc 	zTemp0+1
.1bfc	b0 0b		bcs $1c09			bcs 	_STRFound 					; >=
.1bfe					_STRNext:
.1bfe	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1c00	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1c02	c9 ff		cmp #$ff			cmp 	#$FF
.1c04	d0 e9		bne $1bef			bne 	_STRSearch
.1c06	4c 8a 1f	jmp $1f8a		jmp	ErrorV_internal
.1c09					_STRFound:
.1c09	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1c0b	45 2c		eor $2c				eor 	zTemp0
.1c0d	d0 06		bne $1c15			bne 	_STRDifferent
.1c0f	b2 2e		lda ($2e)			lda 	(zTemp1)
.1c11	45 2c		eor $2c				eor 	zTemp0
.1c13	f0 02		beq $1c17			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1c15					_STRDifferent:
.1c15	a9 ff		lda #$ff			lda 	#$FF
.1c17					_STROut:
.1c17	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1c18	69 ff		adc #$ff			adc 	#255
.1c1a	08		php				php
.1c1b	c8		iny				iny 								; page into X
.1c1c	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1c1e	aa		tax				tax
.1c1f	c8		iny				iny 								; address into YA
.1c20	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1c22	48		pha				pha
.1c23	c8		iny				iny
.1c24	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1c26	a8		tay				tay
.1c27	68		pla				pla
.1c28	28		plp				plp
.1c29	60		rts				rts
.1c2a					_STRPrevLine:
.1c2a	38		sec				sec 								; move backwards one entry.
.1c2b	a5 2e		lda $2e				lda 	zTemp1
.1c2d	e9 05		sbc #$05			sbc 	#5
.1c2f	85 2e		sta $2e				sta 	zTemp1
.1c31	a5 2f		lda $2f				lda 	zTemp1+1
.1c33	e9 00		sbc #$00			sbc 	#0
.1c35	85 2f		sta $2f				sta 	zTemp1+1
.1c37	60		rts				rts
.1c38					STRMakeOffset:
.1c38	18		clc				clc 								; borrow 1
.1c39	e5 29		sbc $29				sbc 	objPtr
.1c3b	48		pha				pha
.1c3c	98		tya				tya
.1c3d	e5 2a		sbc $2a				sbc 	objPtr+1
.1c3f	a8		tay				tay
.1c40	68		pla				pla
.1c41	60		rts				rts
.1c42					CommandNEXT:
.1c42	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1c45	20 52 1a	jsr $1a52			jsr 	CharIsAlpha 				; if not alpha , error
.1c48	90 0c		bcc $1c56			bcc 	_CNNoReferenceGiven
.1c4a	20 31 1a	jsr $1a31			jsr 	GetNext
.1c4d	20 92 1d	jsr $1d92			jsr 	GetReferenceTerm 			; figure out the reference.
.1c50	8a		txa				txa 								; reference in YA
.1c51	20 cd 11	jsr $11cd			jsr 	PushIntegerYA 				; write it out.
.1c54	80 06		bra $1c5c			bra 	_CNParametersDone
.1c56					_CNNoReferenceGiven:
.1c56	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1c58	a8		tay				tay
.1c59	20 cd 11	jsr $11cd			jsr 	PushIntegerYA 				; write it out.
.1c5c					_CNParametersDone:
.1c5c	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1c5e	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1c61	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; look for ,
.1c64	c9 2c		cmp #$2c			cmp 	#","
.1c66	d0 05		bne $1c6d			bne 	_CNExit
.1c68	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume ,
.1c6b	80 d5		bra $1c42			bra 	CommandNEXT 				; and go round.
.1c6d					_CNExit:
.1c6d	60		rts				rts
.1c6e					CommandON:
.1c6e	20 3c 1a	jsr $1a3c			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1c71	48		pha				pha 								; save on stack
.1c72	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1c74	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1c76	f0 09		beq $1c81			beq 	_COCreateLoop
.1c78	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1c7a	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1c7c	f0 03		beq $1c81			beq 	_COCreateLoop
.1c7e	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.1c81					_COCreateLoop:
.1c81	8a		txa				txa 								; compile a goto/gosub somewhere
.1c82	da		phx				phx
.1c83	20 0c 1b	jsr $1b0c			jsr 	CompileBranchCommand
.1c86	fa		plx				plx
.1c87	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace			; ',' follows
.1c8a	c9 2c		cmp #$2c			cmp 	#","
.1c8c	d0 0a		bne $1c98			bne 	_COComplete 				; if so, more line numbers
.1c8e	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1c90	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1c93	20 31 1a	jsr $1a31			jsr 	GetNext
.1c96	80 e9		bra $1c81			bra 	_COCreateLoop
.1c98					_COComplete:
.1c98	68		pla				pla 								; throw GOTO/GOSUB
.1c99	60		rts				rts
.1c9a					ParseConstant:
.1c9a	a2 00		ldx #$00			ldx 	#0
.1c9c	20 56 24	jsr $2456			jsr 	FloatEncodeStart 			; send first
.1c9f					_ParseLoop:
.1c9f	20 20 1a	jsr $1a20			jsr 	LookNext 					; send subsequent
.1ca2	20 59 24	jsr $2459			jsr 	FloatEncodeContinue
.1ca5	90 05		bcc $1cac			bcc 	_ParseDone
.1ca7	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume it
.1caa	80 f3		bra $1c9f			bra 	_ParseLoop
.1cac					_ParseDone:
.1cac	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1cae	29 80		and #$80			and 	#$80
.1cb0	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.1cb2	15 56		ora $56,x			ora 	NSMantissa2,x
.1cb4	15 62		ora $62,x			ora 	NSMantissa3,x
.1cb6	18		clc				clc
.1cb7	d0 05		bne $1cbe			bne 	_ParseExit 					; exit with CC if need float to compile
.1cb9	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.1cbb	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.1cbd	38		sec				sec
.1cbe					_ParseExit:
.1cbe	60		rts				rts
.1cbf					CommandPRINT:
.1cbf	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace			; what follows ?
.1cc2	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1cc4	f0 1f		beq $1ce5			beq 	_CPCheckEnd
.1cc6	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1cc8	f0 16		beq $1ce0			beq 	_CPTabCheckEnd
.1cca	20 fc 1c	jsr $1cfc			jsr 	_CPAtEnd 					; check for : and EOL
.1ccd	b0 22		bcs $1cf1			bcs 	_CPExitCR 					; exit with CR
.1ccf	20 d3 13	jsr $13d3			jsr 	CompileExpressionAt0 		; so it is something to print
.1cd2	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1cd4	29 40		and #$40			and 	#NSSString 					; if string
.1cd6	d0 02		bne $1cda			bne 	_CPOut
.1cd8	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1cda					_CPOut:
.1cda	8a		txa				txa 								; print that thing
.1cdb	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1cde	80 df		bra $1cbf			bra 	CommandPRINT 				; and loop round/
.1ce0					_CPTabCheckEnd:
.1ce0	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1ce2	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1ce5					_CPCheckEnd:
.1ce5	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume it.
.1ce8	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; what follows ?
.1ceb	20 fc 1c	jsr $1cfc			jsr 	_CPAtEnd 					; reached end
.1cee	90 cf		bcc $1cbf			bcc 	CommandPRINT 				; no, loop back
.1cf0	60		rts				rts
.1cf1					_CPExitCR:
.1cf1	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1cf3	20 e0 11	jsr $11e0			jsr 	PushIntegerA
.1cf6	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1cf8	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1cfb	60		rts				rts
.1cfc					_CPAtEnd:
.1cfc	c9 00		cmp #$00			cmp 	#0
.1cfe	f0 06		beq $1d06			beq 	_CPIsEnd
.1d00	c9 3a		cmp #$3a			cmp 	#":"
.1d02	f0 02		beq $1d06			beq 	_CPIsEnd
.1d04	18		clc				clc
.1d05	60		rts				rts
.1d06					_CPIsEnd:
.1d06	38		sec				sec
.1d07	60		rts				rts
.1d08					CommandREAD:
.1d08	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1d0a	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1d0c					CommandReadInputCommon:
.1d0c	8e 0d 06	stx $060d			stx 	numberPCode
.1d0f	8c 0e 06	sty $060e			sty 	stringPCode
.1d12					_CRLoop:
.1d12	20 3c 1a	jsr $1a3c			jsr 	GetNextNonSpace 			; first char of identifier
.1d15	20 52 1a	jsr $1a52			jsr 	CharIsAlpha 				; check A-Z
.1d18	90 27		bcc $1d41			bcc 	_CRSyntax
.1d1a	20 92 1d	jsr $1d92			jsr 	GetReferenceTerm 			; get the variable.
.1d1d	48		pha				pha 								; save type.
.1d1e	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1d20	c9 40		cmp #$40			cmp 	#NSSString
.1d22	f0 05		beq $1d29			beq 	_CRString
.1d24	ad 0d 06	lda $060d			lda 	numberPCode 				; output read/input
.1d27	80 03		bra $1d2c			bra 	_CRHaveType
.1d29					_CRString:
.1d29	ad 0e 06	lda $060e			lda 	stringPCode					; output read$/input$
.1d2c					_CRHaveType:
.1d2c	20 ef 10	jsr $10ef			jsr 	WriteCodeByte 				; so we have one typed data item.
.1d2f	68		pla				pla 								; restore type
.1d30	38		sec				sec  								; write update code.
.1d31	20 44 1d	jsr $1d44			jsr 	GetSetVariable
.1d34	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; , follows ?
.1d37	c9 2c		cmp #$2c			cmp 	#","
.1d39	d0 05		bne $1d40			bne 	_CRExit 					; if not, end of READ.
.1d3b	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume comma
.1d3e	80 d2		bra $1d12			bra 	_CRLoop 					; keep going
.1d40					_CRExit:
.1d40	60		rts				rts
.1d41					_CRSyntax:
.1d41	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.060d					numberPCode:
>060d							.fill 	1
.060e					stringPCode:
>060e							.fill 	1
.1d44					GetSetVariable:
.1d44	08		php				php 								; save direction on stack
.1d45	c0 00		cpy #$00			cpy 	#$00
.1d47	30 21		bmi $1d6a			bmi 	_GSVReadWriteSpecial
.1d49	c9 00		cmp #$00			cmp 	#$00
.1d4b	30 33		bmi $1d80			bmi 	_GSVArray
.1d4d	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1d4f	4a		lsr a				lsr 	a 							; divide by 2
.1d50	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1d52	28		plp				plp
.1d53	90 02		bcc $1d57			bcc 	_GSVNotWrite
.1d55	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1d57					_GSVNotWrite:
.1d57	85 2c		sta $2c				sta 	zTemp0
.1d59	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1d5a	4a		lsr a				lsr 	a
.1d5b	a8		tay				tay
.1d5c	8a		txa				txa
.1d5d	6a		ror a				ror 	a
.1d5e	aa		tax				tax
.1d5f	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1d60	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.1d62	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1d65	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1d66	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1d69	60		rts				rts
.1d6a					_GSVReadWriteSpecial:
.1d6a	28		plp				plp
.1d6b	b0 10		bcs $1d7d			bcs 	_GSVSyntax
.1d6d	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1d6f	f0 06		beq $1d77			beq 	_GSVRWString
.1d71	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1d73	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1d76	60		rts				rts
.1d77					_GSVRWString:
.1d77	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1d79	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1d7c	60		rts				rts
.1d7d					_GSVSyntax:
.1d7d	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.1d80					_GSVArray:
.1d80	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1d82	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1d83	4a		lsr a				lsr 	a
.1d84	4a		lsr a				lsr 	a
.1d85	4a		lsr a				lsr 	a
.1d86	4a		lsr a				lsr 	a
.1d87	28		plp				plp 								; if writing array then set bit 2.
.1d88	90 02		bcc $1d8c			bcc 	_GSVANotWrite
.1d8a	09 04		ora #$04			ora 	#4
.1d8c					_GSVANotWrite:
.1d8c	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1d8e	20 ef 10	jsr $10ef			jsr 	WriteCodeByte 				; and write it out
.1d91	60		rts				rts
.1d92					GetReferenceTerm:
.1d92	20 a1 1a	jsr $1aa1			jsr 	ExtractVariableName 		; get name & type info
.1d95	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1d97	30 10		bmi $1da9			bmi 	_GRTArray
.1d99	da		phx				phx 								; save type on stack
.1d9a	20 8d 14	jsr $148d			jsr 	FindVariable 				; find it
.1d9d	b0 06		bcs $1da5			bcs 	_GRTNoCreate 				; create if required.
.1d9f	20 12 12	jsr $1212			jsr 	CreateVariableRecord 		; create a variable.
.1da2	20 6c 12	jsr $126c			jsr 	AllocateBytesForType 		; allocate memory for it
.1da5					_GRTNoCreate:
.1da5	68		pla				pla 								; get type back, strip out type information.
.1da6	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1da8	60		rts				rts
.1da9					_GRTArray:
.1da9	da		phx				phx 								; save type information
.1daa	20 8d 14	jsr $148d			jsr 	FindVariable 				; read its data, the base address in YX
.1dad	90 18		bcc $1dc7			bcc 	_GRTUndeclared 				; undeclared array.
.1daf	da		phx				phx 								; save base address
.1db0	5a		phy				phy
.1db1	20 63 13	jsr $1363			jsr 	OutputIndexGroup 			; create an index group and generate them
.1db4	7a		ply				ply 								; get the array base address into YX
.1db5	fa		plx				plx
.1db6	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1db8	18		clc				clc
.1db9	20 44 1d	jsr $1d44			jsr 	GetSetVariable 				; load the address of the array structure.
.1dbc	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1dbe	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1dc1	68		pla				pla 								; and the type data into A
.1dc2	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1dc4	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1dc6	60		rts				rts
.1dc7					_GRTUndeclared:
.1dc7	4c e7 1f	jmp $1fe7		jmp	ErrorV_undeclared
.1dca					CommandREM:
.1dca	20 20 1a	jsr $1a20			jsr 	LookNext
.1dcd	f0 05		beq $1dd4			beq 	_CRExit
.1dcf	20 31 1a	jsr $1a31			jsr 	GetNext
.1dd2	80 f6		bra $1dca			bra 	CommandREM
.1dd4					_CRExit:
.1dd4	60		rts				rts
.1dd5					STRReset:
.1dd5	ad 07 06	lda $0607			lda	 	compilerStartHigh 			; set up the two table pointers
.1dd8	8d 12 06	sta $0612			sta 	variableListEnd+1
.1ddb	9c 11 06	stz $0611			stz 	variableListEnd
.1dde	ad 08 06	lda $0608			lda 	compilerEndHigh
.1de1	8d 10 06	sta $0610			sta 	lineNumberTable+1
.1de4	9c 0f 06	stz $060f			stz 	lineNumberTable
.1de7	ad 11 06	lda $0611			lda 	variableListEnd
.1dea	85 2d		sta $2d				sta 	zTemp0+1
.1dec	64 2c		stz $2c				stz 	zTemp0
.1dee	a9 00		lda #$00			lda 	#0
.1df0	92 2c		sta ($2c)			sta 	(zTemp0)
.1df2	a9 00		lda #$00			lda 	#((0) & $FF)
.1df4	8d 13 06	sta $0613			sta 	0+freeVariableMemory
.1df7	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1df9	8d 14 06	sta $0614			sta 	1+freeVariableMemory
.1dfc	60		rts				rts
.060f					lineNumberTable:
>060f							.fill 	2
.0611					variableListEnd:
>0611							.fill 	2
.0613					freeVariableMemory:
>0613							.fill 	2
.1dfd					CompileTerm:
.1dfd	20 3c 1a	jsr $1a3c			jsr 	GetNextNonSpace 			; get first non space character.
.1e00	30 72		bmi $1e74			bmi 	_CTUnaryFunctions
.1e02	20 46 1a	jsr $1a46			jsr 	CharIsDigit 				; found a number
.1e05	b0 3a		bcs $1e41			bcs 	_CTDigit
.1e07	c9 2e		cmp #$2e			cmp 	#"."
.1e09	f0 36		beq $1e41			beq 	_CTDigit
.1e0b	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1e0d	f0 43		beq $1e52			beq 	_CTString
.1e0f	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1e11	f0 28		beq $1e3b			beq 	_CTOtherBase
.1e13	c9 24		cmp #$24			cmp 	#"$"
.1e15	f0 24		beq $1e3b			beq 	_CTOtherBase
.1e17	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1e19	f0 17		beq $1e32			beq 	_CTBrackets
.1e1b	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1e1d	90 10		bcc $1e2f			bcc 	_CTSyntax
.1e1f	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1e21	b0 0c		bcs $1e2f			bcs 	_CTSyntax
.1e23	20 92 1d	jsr $1d92			jsr 	GetReferenceTerm 			; figure out what it is.
.1e26	48		pha				pha 								; save type on stack
.1e27	18		clc				clc 								; read it
.1e28	20 44 1d	jsr $1d44			jsr 	GetSetVariable
.1e2b	68		pla				pla
.1e2c	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1e2e	60		rts				rts
.1e2f					_CTSyntax:
.1e2f	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.1e32					_CTBrackets:
.1e32	20 d3 13	jsr $13d3			jsr 	CompileExpressionAt0
.1e35	48		pha				pha
.1e36	20 2e 11	jsr $112e			jsr 	CheckNextRParen
.1e39	68		pla				pla
.1e3a	60		rts				rts
.1e3b					_CTOtherBase:
.1e3b	20 a4 10	jsr $10a4			jsr 	InlineNonDecimal 			; non decimal constant handler
.1e3e	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e40	60		rts				rts
.1e41					_CTDigit:
.1e41	20 9a 1c	jsr $1c9a			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1e44	90 06		bcc $1e4c			bcc	 	_CTFloat 					; have a float or long int.
.1e46	20 cd 11	jsr $11cd			jsr 	PushIntegerYA 				; code to push on stack
.1e49	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e4b	60		rts				rts
.1e4c					_CTFloat:
.1e4c	20 ef 11	jsr $11ef			jsr 	PushFloat  					; code to push float
.1e4f	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1e51	60		rts				rts
.1e52					_CTString:
.1e52	20 03 11	jsr $1103			jsr 	BufferClear 				; copy it to the buffer
.1e55					_CTStringLoop:
.1e55	20 20 1a	jsr $1a20			jsr 	LookNext 					; reached EOL/EOS
.1e58	f0 d5		beq $1e2f			beq 	_CTSyntax
.1e5a	c9 22		cmp #$22			cmp 	#'"'
.1e5c	f0 08		beq $1e66			beq 	_CTStringDone
.1e5e	20 07 11	jsr $1107			jsr 	BufferWrite 				; write and consume
.1e61	20 31 1a	jsr $1a31			jsr 	GetNext
.1e64	80 ef		bra $1e55			bra 	_CTStringLoop
.1e66					_CTStringDone:
.1e66	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume closing quote.
.1e69	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1e6b	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1e6e	20 13 11	jsr $1113			jsr 	BufferOutput
.1e71	a9 40		lda #$40			lda 	#NSSString 					; string type
.1e73	60		rts				rts
.1e74					_CTUnaryFunctions:
.1e74	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1e76	f0 0a		beq $1e82			beq 	_CTNegation
.1e78	a2 cb		ldx #$cb			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1e7a	a0 17		ldy #$17			ldy 	#UnaryTables >> 8
.1e7c	20 c5 18	jsr $18c5			jsr 	GeneratorProcess
.1e7f	90 ae		bcc $1e2f			bcc		_CTSyntax
.1e81	60		rts				rts
.1e82					_CTNegation:
.1e82	20 fd 1d	jsr $1dfd			jsr 	CompileTerm 				; compile a term.
.1e85	48		pha				pha
.1e86	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1e88	c9 00		cmp #$00			cmp 	#NSSIFloat
.1e8a	d0 07		bne $1e93			bne 	_CTType 					; error
.1e8c	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1e8e	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1e91	68		pla				pla 								; return original type.
.1e92	60		rts				rts
.1e93					_CTType:
.1e93	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.1e96					CommandWAIT:
.1e96	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace
.1e99	c9 2c		cmp #$2c			cmp 	#","
.1e9b	f0 10		beq $1ead			beq 	_CWThirdParameter
.1e9d	a9 00		lda #$00			lda 	#0
.1e9f	20 e0 11	jsr $11e0			jsr 	PushIntegerA
.1ea2					_CWExit:
.1ea2	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1ea4	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1ea7	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1ea9	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1eac	60		rts				rts
.1ead					_CWThirdParameter:
.1ead	20 31 1a	jsr $1a31			jsr 	GetNext
.1eb0	20 d5 13	jsr $13d5			jsr 	CompileExpressionAtA
.1eb3	29 40		and #$40			and 	#NSSTypeMask
.1eb5	c9 00		cmp #$00			cmp 	#NSSIFloat
.1eb7	f0 e9		beq $1ea2			beq 	_CWExit
.1eb9	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.1ebc					CommandCMD:
.1ebc	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.1ebe	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1ec1	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; followed by a , ?
.1ec4	c9 2c		cmp #$2c			cmp 	#","
.1ec6	d0 06		bne $1ece			bne 	_CCMDExit
.1ec8	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume comma.
.1ecb	20 bf 1c	jsr $1cbf			jsr 	CommandPRINT 				; do the print code
.1ece					_CCMDExit:
.1ece	60		rts				rts
.1ecf					CommandOPEN:
.1ecf	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; followed by a , ?
.1ed2	c9 2c		cmp #$2c			cmp 	#","
.1ed4	d0 15		bne $1eeb			bne 	_COTwoDefaults
.1ed6	20 31 1a	jsr $1a31			jsr 	GetNext 					; consume comma
.1ed9	20 d3 13	jsr $13d3			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1edc	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1ede	f0 1e		beq $1efe			beq 	_COThreeIntegers
.1ee0	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1ee2	20 e0 11	jsr $11e0			jsr 	PushIntegerA
.1ee5	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1ee7	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1eea	60		rts				rts
.1eeb					_COTwoDefaults:
.1eeb	a9 00		lda #$00			lda 	#0
.1eed	20 e0 11	jsr $11e0			jsr 	PushIntegerA
.1ef0					_COCompileNullString:
.1ef0	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1ef2	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1ef5	a9 00		lda #$00			lda 	#0
.1ef7	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1efa	20 ef 10	jsr $10ef			jsr 	WriteCodeByte
.1efd	60		rts				rts
.1efe					_COThreeIntegers:
.1efe	20 23 1a	jsr $1a23			jsr 	LookNextNonSpace 			; is there a ,
.1f01	c9 2c		cmp #$2c			cmp 	#","
.1f03	d0 eb		bne $1ef0			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1f05	20 31 1a	jsr $1a31			jsr 	GetNext
.1f08	20 d3 13	jsr $13d3			jsr 	CompileExpressionAt0 		; should be a filename
.1f0b	29 40		and #$40			and 	#NSSString
.1f0d	f0 01		beq $1f10			beq 	_COType
.1f0f	60		rts				rts
.1f10					_COType:
.1f10	4c 40 1f	jmp $1f40		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					codePage:
>0028							.fill 	1
.0029					objPtr:
>0029							.fill 	2
.002b					objPage:
>002b							.fill 	1
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1f13					ErrorV_range:
.1f13	20 8b 13	jsr $138b		jsr	ErrorHandler
>1f16	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f1e	41 4e 47 45 00
.1f23					ErrorV_value:
.1f23	20 8b 13	jsr $138b		jsr	ErrorHandler
>1f26	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f2e	45 00
.1f30					ErrorV_syntax:
.1f30	20 8b 13	jsr $138b		jsr	ErrorHandler
>1f33	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f3b	52 52 4f 52 00
.1f40					ErrorV_type:
.1f40	20 8b 13	jsr $138b		jsr	ErrorHandler
>1f43	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f4b	4d 41 54 43 48 00
.1f51					ErrorV_unimplemented:
.1f51	20 8b 13	jsr $138b		jsr	ErrorHandler
>1f54	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f5c	45 4d 45 4e 54 45 44 00
.1f64					ErrorV_assert:
.1f64	20 8b 13	jsr $138b		jsr	ErrorHandler
>1f67	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f6f	41 49 4c 00
.1f73					ErrorV_line:
.1f73	20 8b 13	jsr $138b		jsr	ErrorHandler
>1f76	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f7e	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f8a					ErrorV_internal:
.1f8a	20 8b 13	jsr $138b		jsr	ErrorHandler
>1f8d	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f95	20 45 52 52 4f 52 00
.1f9c					ErrorV_divzero:
.1f9c	20 8b 13	jsr $138b		jsr	ErrorHandler
>1f9f	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fa7	59 20 5a 45 52 4f 00
.1fae					ErrorV_structure:
.1fae	20 8b 13	jsr $138b		jsr	ErrorHandler
>1fb1	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fb9	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fc5					ErrorV_stop:
.1fc5	20 8b 13	jsr $138b		jsr	ErrorHandler
>1fc8	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fd0	53 54 4f 50 50 45 44 00
.1fd8					ErrorV_data:
.1fd8	20 8b 13	jsr $138b		jsr	ErrorHandler
>1fdb	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fe3	41 54 41 00
.1fe7					ErrorV_undeclared:
.1fe7	20 8b 13	jsr $138b		jsr	ErrorHandler
>1fea	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1ff2	41 52 52 41 59 00
.1ff8					ErrorV_redefine:
.1ff8	20 8b 13	jsr $138b		jsr	ErrorHandler
>1ffb	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>2003	44 45 46 49 4e 45 44 00
.200b					ErrorV_index:
.200b	20 8b 13	jsr $138b		jsr	ErrorHandler
>200e	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2016	59 20 49 4e 44 45 58 00
.201e					ErrorV_memory:
.201e	20 8b 13	jsr $138b		jsr	ErrorHandler
>2021	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2029	45 4d 4f 52 59 00
.202f					ErrorV_channel:
.202f	20 8b 13	jsr $138b		jsr	ErrorHandler
>2032	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>203a	54 50 55 54 20 45 52 52 4f 52 00
.2045					MoveObjectForward:
.2045	b2 29		lda ($29)			lda 	(objPtr) 					; get next
.2047	c9 ff		cmp #$ff			cmp 	#$FF
.2049	f0 36		beq $2081			beq 	_MOFEnd
.204b	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.204d	90 24		bcc $2073			bcc 	_MOFAdvance1 				; forward 1
.204f	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.2051	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2053	90 20		bcc $2075			bcc 	_MOFAdvanceY
.2055	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2057	90 1a		bcc $2073			bcc 	_MOFAdvance1 				; forward 1
.2059	a8		tay				tay 								; read the size.
.205a	b9 bf 1f	lda $1fbf,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.205d	a8		tay				tay
.205e	c8		iny				iny 								; add 1 for the system token.
.205f	d0 14		bne $2075			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2061	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2063	b1 29		lda ($29),y			lda 	(objPtr),y
.2065	a8		tay				tay 								; into Y.
.2066	18		clc				clc
.2067	a5 29		lda $29				lda 	objPtr						; add 2 to the object pointer
.2069	69 02		adc #$02			adc 	#2
.206b	85 29		sta $29				sta 	objPtr
.206d	90 02		bcc $2071			bcc 	_MOFNoCarry1
.206f	e6 2a		inc $2a				inc 	objPtr+1
.2071					_MOFNoCarry1:
.2071	80 02		bra $2075			bra 	_MOFAdvanceY
.2073					_MOFAdvance1:
.2073	a0 01		ldy #$01			ldy 	#1
.2075					_MOFAdvanceY:
.2075	98		tya				tya 								; add X to objPtr
.2076	18		clc				clc
.2077	65 29		adc $29				adc 	objPtr
.2079	85 29		sta $29				sta 	objPtr
.207b	90 02		bcc $207f			bcc 	_MOFNoCarry2
.207d	e6 2a		inc $2a				inc 	objPtr+1
.207f					_MOFNoCarry2:
.207f	18		clc				clc 								; not completed.
.2080	60		rts				rts
.2081					_MOFEnd:
.2081	e6 29		inc $29				inc 	objPtr
.2083	d0 02		bne $2087			bne 	_MOFENoCarry
.2085	e6 2a		inc $2a				inc 	objPtr+1
.2087					_MOFENoCarry:
.2087	38		sec				sec
.2088	60		rts				rts
.2089					MOFSizeTable:
>2089	01					.byte	1         	; $ca .shift
>208a	01					.byte	1         	; $cb .byte
>208b	02					.byte	2         	; $cc .word
>208c	05					.byte	5         	; $cd .float
>208d	ff					.byte	255       	; $ce .string
>208e	ff					.byte	255       	; $cf .data
>208f	03					.byte	3         	; $d0 .goto
>2090	03					.byte	3         	; $d1 .gosub
>2091	03					.byte	3         	; $d2 .goto.z
>2092	03					.byte	3         	; $d3 .goto.nz
>2093	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0615					numberBuffer:
>0615							.fill 	34
.2094					FloatSubtract:
.2094	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.2096	49 80		eor #$80			eor 	#$80
.2098	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.209a					FloatAdd:
.209a	ca		dex				dex
.209b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.209d	15 6f		ora $6f,x			ora 	NSExponent+1,x
.209f	15 62		ora $62,x			ora 	NSMantissa3,x
.20a1	15 63		ora $63,x			ora 	NSMantissa3+1,x
.20a3	d0 04		bne $20a9			bne 	_FAUseFloat
.20a5	20 36 24	jsr $2436			jsr 	FloatInt32Add 				; use the int32 one.
.20a8	60		rts				rts
.20a9					_FAUseFloat:
.20a9	20 cb 23	jsr $23cb			jsr 	FloatNormalise 				; normalise S[X]
.20ac	f0 51		beq $20ff			beq 	_FAReturn1
.20ae	e8		inx				inx 								; normalise S[X+1]
.20af	20 cb 23	jsr $23cb			jsr 	FloatNormalise
.20b2	ca		dex				dex
.20b3	c9 00		cmp #$00			cmp 	#0
.20b5	f0 60		beq $2117			beq 	_FAExit 					; if so, just return A
.20b7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20b9	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20bb	f0 18		beq $20d5			beq 	_FAExponentsEqual
.20bd	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20bf	a8		tay				tay
.20c0	38		sec				sec 								; do a signed comparison of the exponents.
.20c1	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20c3	50 02		bvc $20c7			bvc 	_FANoSignedChange
.20c5	49 80		eor #$80			eor 	#$80
.20c7					_FANoSignedChange:
.20c7	29 80		and #$80			and 	#$80
.20c9	10 02		bpl $20cd			bpl 	_FAHaveMax
.20cb	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.20cd					_FAHaveMax:
.20cd	20 18 21	jsr $2118			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20d0	e8		inx				inx
.20d1	20 18 21	jsr $2118			jsr 	_FAShiftToExponent
.20d4	ca		dex				dex
.20d5					_FAExponentsEqual:
.20d5	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.20d7	55 33		eor $33,x			eor 	NSStatus+1,x
.20d9	30 0e		bmi $20e9			bmi 	_FADifferentSigns
.20db	20 02 24	jsr $2402			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20de	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20e0	10 35		bpl $2117			bpl 	_FAExit 					; if no, we are done.
.20e2	20 8f 26	jsr $268f			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20e5	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.20e7	80 2e		bra $2117			bra 	_FAExit
.20e9					_FADifferentSigns:
.20e9	20 1c 24	jsr $241c			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20ec	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.20ee	10 06		bpl $20f6			bpl 	_FACheckZero 				; if no, check for -0
.20f0	20 38 26	jsr $2638			jsr 	FloatNegate 					; netate result
.20f3	20 3f 26	jsr $263f			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20f6					_FACheckZero:
.20f6	20 98 26	jsr $2698			jsr 	FloatIsZero	 				; check for -0
.20f9	d0 1c		bne $2117			bne 	_FAExit
.20fb	74 32		stz $32,x			stz 	NSStatus,x
.20fd	80 18		bra $2117			bra 	_FAExit
.20ff					_FAReturn1:
.20ff	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.2101	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2103	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2105	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2107	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.2109	95 56		sta $56,x			sta 	NSMantissa2,x
.210b	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.210d	95 62		sta $62,x			sta 	NSMantissa3,x
.210f	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.2111	95 6e		sta $6e,x			sta 	NSExponent,x
.2113	b5 33		lda $33,x			lda 	NSStatus+1,x
.2115	95 32		sta $32,x			sta 	NSStatus,x
.2117					_FAExit:
.2117	60		rts				rts
.2118					_FAShiftToExponent:
.2118					_FAShiftToExponent2:
.2118	98		tya				tya 								; compare Y to exponent
.2119	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.211b	f0 07		beq $2124			beq 	_FASEExit 					; exit if so.
.211d	20 8f 26	jsr $268f			jsr 	FloatShiftRight	 			; shift the mantissa right
.2120	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.2122	80 f4		bra $2118			bra 	_FAShiftToExponent2
.2124					_FASEExit:
.2124	60		rts				rts
.2125					CompareEqual:
.2125	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2127	d0 09		bne $2132			bne 	ReturnFalse
.2129					ReturnTrue:
.2129	a9 01		lda #$01			lda 	#1
.212b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.212d	a9 80		lda #$80			lda 	#$80
.212f	95 32		sta $32,x			sta 	NSStatus,x
.2131	60		rts				rts
.2132					ReturnFalse:
.2132	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2134	60		rts				rts
.2135					CompareNotEqual:
.2135	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2137	d0 f0		bne $2129			bne 	ReturnTrue
.2139	80 f7		bra $2132			bra 	ReturnFalse
.213b					CompareLess:
.213b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.213d	c9 ff		cmp #$ff			cmp 	#$FF
.213f	f0 e8		beq $2129			beq 	ReturnTrue
.2141	80 ef		bra $2132			bra 	ReturnFalse
.2143					CompareGreater:
.2143	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2145	c9 01		cmp #$01			cmp 	#$01
.2147	f0 e0		beq $2129			beq 	ReturnTrue
.2149	80 e7		bra $2132			bra 	ReturnFalse
.214b					CompareLessEqual:
.214b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.214d	c9 01		cmp #$01			cmp 	#$01
.214f	d0 d8		bne $2129			bne 	ReturnTrue
.2151	80 df		bra $2132			bra 	ReturnFalse
.2153					CompareGreaterEqual:
.2153	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2155	c9 ff		cmp #$ff			cmp 	#$FF
.2157	d0 d0		bne $2129			bne 	ReturnTrue
.2159	80 d7		bra $2132			bra 	ReturnFalse
.215b					FloatCompare:
.215b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.215d	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.215f	48		pha				pha
.2160	20 94 20	jsr $2094			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2163	68		pla				pla
.2164	d0 0c		bne $2172			bne 	_FCCompareFloat
.2166	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2168	15 4a		ora $4a,x			ora 	NSMantissa1,x
.216a	15 56		ora $56,x			ora 	NSMantissa2,x
.216c	15 62		ora $62,x			ora 	NSMantissa3,x
.216e	f0 14		beq $2184			beq 	_FCExit 					; if zero, return zero
.2170	80 0a		bra $217c			bra 	_FCSign
.2172					_FCCompareFloat:
.2172	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2174	29 f0		and #$f0			and 	#$F0
.2176	15 56		ora $56,x			ora 	NSMantissa2,x
.2178	15 62		ora $62,x			ora 	NSMantissa3,x
.217a	f0 08		beq $2184			beq 	_FCExit 					; zero, so approximately identical
.217c					_FCSign:
.217c	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.217e	34 32		bit $32,x			bit 	NSStatus,x
.2180	10 02		bpl $2184			bpl 	_FCExit
.2182					_FCNegative:
.2182	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2184					_FCExit:
.2184	20 78 26	jsr $2678			jsr 	FloatSetByte 				; set the result 255,0,1
.2187	60		rts				rts
.2188					FloatScalarTable:
>2188	66 66 66 66				.dword $66666666 ; 0.1
>218c	de					.byte $de
>218d	1f 85 eb 51				.dword $51eb851f ; 0.01
>2191	db					.byte $db
>2192	4c 37 89 41				.dword $4189374c ; 0.001
>2196	d8					.byte $d8
>2197	ac 8b db 68				.dword $68db8bac ; 0.0001
>219b	d4					.byte $d4
>219c	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>21a0	d1					.byte $d1
>21a1	83 de 1b 43				.dword $431bde83 ; 1e-06
>21a5	ce					.byte $ce
>21a6	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21aa	ca					.byte $ca
>21ab	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21af	c7					.byte $c7
>21b0	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21b4	c4					.byte $c4
>21b5	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21b9	c0					.byte $c0
>21ba	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21be	bd					.byte $bd
.21bf					FloatDivide:
.21bf	48		pha				pha
.21c0	20 cb 23	jsr $23cb			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21c3	ca		dex				dex
.21c4	c9 00		cmp #$00			cmp 	#0
.21c6	f0 1e		beq $21e6			beq 	_FDZero
.21c8	20 cb 23	jsr $23cb			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21cb	f0 16		beq $21e3			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21cd	20 2e 22	jsr $222e			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21d0	20 fb 21	jsr $21fb			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21d3	20 cb 23	jsr $23cb			jsr		FloatNormalise 				; renormalise
.21d6	20 c1 23	jsr $23c1			jsr 	FloatCalculateSign 			; calculate result sign
.21d9	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.21db	38		sec				sec
.21dc	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.21de	38		sec				sec
.21df	e9 1e		sbc #$1e			sbc 	#30
.21e1	95 6e		sta $6e,x			sta 	NSExponent,x
.21e3					_FDExit:
.21e3	68		pla				pla
.21e4	18		clc				clc
.21e5	60		rts				rts
.21e6					_FDZero:
.21e6	68		pla				pla
.21e7	38		sec				sec
.21e8	60		rts				rts
.21e9					DivideInt32:
.21e9	20 b1 22	jsr $22b1			jsr 	FloatIntegerPart 			; make both integers
.21ec	ca		dex				dex
.21ed	20 b1 22	jsr $22b1			jsr 	FloatIntegerPart
.21f0	20 0c 22	jsr $220c			jsr 	Int32Divide 				; divide
.21f3	20 fb 21	jsr $21fb			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21f6	20 c1 23	jsr $23c1			jsr 	FloatCalculateSign 			; calculate result sign
.21f9	18		clc				clc
.21fa	60		rts				rts
.21fb					NSMCopyPlusTwoToZero:
.21fb	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21fd	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21ff	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.2201	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2203	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.2205	95 56		sta $56,x			sta 	NSMantissa2,x
.2207	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.2209	95 62		sta $62,x			sta 	NSMantissa3,x
.220b	60		rts				rts
.220c					Int32Divide:
.220c	48		pha				pha 								; save AXY
.220d	5a		phy				phy
.220e	20 59 26	jsr $2659			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2211	20 72 26	jsr $2672			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2214	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2216					_I32DivideLoop:
.2216	e8		inx				inx
.2217	e8		inx				inx
.2218	20 85 26	jsr $2685			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.221b	ca		dex				dex
.221c	ca		dex				dex
.221d	20 86 26	jsr $2686			jsr 	FloatRotateLeft
.2220	20 4c 22	jsr $224c			jsr 	FloatDivideCheck 			; check if subtract possible
.2223	90 02		bcc $2227			bcc 	_I32DivideNoCarryIn
.2225	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2227					_I32DivideNoCarryIn:
.2227	88		dey				dey 								; loop round till division completed.
.2228	d0 ec		bne $2216			bne 	_I32DivideLoop
.222a	7a		ply				ply 								; restore AXY and exit
.222b	68		pla				pla
.222c	18		clc				clc
.222d	60		rts				rts
.222e					Int32ShiftDivide:
.222e	48		pha				pha 								; save AY
.222f	5a		phy				phy
.2230	e8		inx				inx 								; clear S[X+2]
.2231	e8		inx				inx
.2232	20 76 26	jsr $2676			jsr 	FloatSetZero
.2235	ca		dex				dex
.2236	ca		dex				dex
.2237	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2239					_I32SDLoop:
.2239	20 4c 22	jsr $224c			jsr 	FloatDivideCheck 			; check if subtract possible
.223c	e8		inx				inx
.223d	e8		inx				inx
.223e	20 86 26	jsr $2686			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.2241	ca		dex				dex
.2242	ca		dex				dex
.2243	20 86 26	jsr $2686			jsr 	FloatRotateLeft
.2246	88		dey				dey 	 							; do 31 times
.2247	d0 f0		bne $2239			bne 	_I32SDLoop
.2249	7a		ply				ply 								; restore AY and exit
.224a	68		pla				pla
.224b	60		rts				rts
.224c					FloatDivideCheck:
.224c	20 1c 24	jsr $241c			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.224f	b0 04		bcs $2255			bcs 	_DCSExit 					; if carry set, then could do, exit
.2251	20 02 24	jsr $2402			jsr 	FloatAddTopTwoStack 		; add it back in
.2254	18		clc				clc 								; and return False
.2255					_DCSExit:
.2255	60		rts				rts
.2256					FloatFractionalPart:
.2256	5a		phy				phy
.2257	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.2259	29 7f		and #$7f			and 	#$7F
.225b	95 32		sta $32,x			sta 	NSStatus,x
.225d	20 cb 23	jsr $23cb			jsr 	FloatNormalise
.2260	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2262	38		sec				sec
.2263	e9 e0		sbc #$e0			sbc 	#$E0
.2265	90 29		bcc $2290			bcc 	_FFPExit 					; already fractional
.2267	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2269	b0 22		bcs $228d			bcs 	_FFPZero
.226b	a8		tay				tay 								; put count to do in Y
.226c	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.226e	20 95 22	jsr $2295			jsr 	_FFPPartial
.2271	95 62		sta $62,x			sta 	NSMantissa3,x
.2273	b5 56		lda $56,x			lda 	NSMantissa2,x
.2275	20 95 22	jsr $2295			jsr 	_FFPPartial
.2278	95 56		sta $56,x			sta 	NSMantissa2,x
.227a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.227c	20 95 22	jsr $2295			jsr 	_FFPPartial
.227f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2281	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2283	20 95 22	jsr $2295			jsr 	_FFPPartial
.2286	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2288	20 98 26	jsr $2698			jsr 	FloatIsZero 					; zeroed check.
.228b	d0 03		bne $2290			bne 	_FFPExit
.228d					_FFPZero:
.228d	20 76 26	jsr $2676			jsr 	FloatSetZero
.2290					_FFPExit:
.2290	20 cb 23	jsr $23cb			jsr 	FloatNormalise
.2293	7a		ply				ply
.2294	60		rts				rts
.2295					_FFPPartial:
.2295	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2297	f0 17		beq $22b0			beq 	_FFFPPExit
.2299	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.229b	b0 0c		bcs $22a9			bcs 	_FFFPPWholeByte
.229d	5a		phy				phy
.229e					_FFFPPLeft:
.229e	0a		asl a				asl 	a
.229f	88		dey				dey
.22a0	d0 fc		bne $229e			bne 	_FFFPPLeft
.22a2	7a		ply				ply
.22a3					_FFFPPRight:
.22a3	4a		lsr a				lsr 	a
.22a4	88		dey				dey
.22a5	d0 fc		bne $22a3			bne 	_FFFPPRight
.22a7	80 07		bra $22b0			bra 	_FFFPPExit
.22a9					_FFFPPWholeByte:
.22a9	98		tya				tya 								; subtract 8 from count
.22aa	38		sec				sec
.22ab	e9 08		sbc #$08			sbc 	#8
.22ad	a8		tay				tay
.22ae	a9 00		lda #$00			lda 	#0 							; and clear all
.22b0					_FFFPPExit:
.22b0	60		rts				rts
.22b1					FloatIntegerPart:
.22b1	48		pha				pha
.22b2	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22b4	f0 1d		beq $22d3			beq 	_FIPExit 					; if so do nothing
.22b6	20 98 26	jsr $2698			jsr 	FloatIsZero 				; is it zero ?
.22b9	f0 15		beq $22d0			beq 	_FIPZero 					; if so return zero.
.22bb	20 cb 23	jsr $23cb			jsr 	FloatNormalise 				; normalise
.22be	f0 10		beq $22d0			beq 	_FIPZero 					; normalised to zero, exit zero
.22c0					_FIPShift:
.22c0	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22c2	10 07		bpl $22cb			bpl 	_FIPCheckZero
.22c4	20 8f 26	jsr $268f			jsr 	FloatShiftRight 			; shift mantissa right
.22c7	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22c9	80 f5		bra $22c0			bra 	_FIPShift
.22cb					_FIPCheckZero:
.22cb	20 98 26	jsr $2698			jsr 	FloatIsZero 				; avoid -0 problem
.22ce	d0 03		bne $22d3			bne 	_FIPExit 					; set to zero if mantissa zero.
.22d0					_FIPZero:
.22d0	20 76 26	jsr $2676			jsr 	FloatSetZero
.22d3					_FIPExit:
.22d3	68		pla				pla
.22d4	60		rts				rts
.22d5					FloatIntegerPartDown:
.22d5	48		pha				pha
.22d6	5a		phy				phy
.22d7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22d9	f0 36		beq $2311			beq 	_FIPExit 					; if so do nothing
.22db	20 98 26	jsr $2698			jsr 	FloatIsZero 				; is it zero ?
.22de	f0 2e		beq $230e			beq 	_FIPZero 					; if so return zero.
.22e0	20 cb 23	jsr $23cb			jsr 	FloatNormalise 				; normalise
.22e3	f0 29		beq $230e			beq 	_FIPZero 					; normalised to zero, exit zero
.22e5	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22e7					_FIPShift:
.22e7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22e9	10 0a		bpl $22f5			bpl 	_FIPCheckDown
.22eb	20 8f 26	jsr $268f			jsr 	FloatShiftRight 			; shift mantissa right
.22ee	90 01		bcc $22f1			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22f0	c8		iny				iny
.22f1					_FIPNoFrac:
.22f1	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22f3	80 f2		bra $22e7			bra 	_FIPShift
.22f5					_FIPCheckDown:
.22f5	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22f7	f0 10		beq $2309			beq 	_FIPCheckZero
.22f9	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22fb	10 0c		bpl $2309			bpl 	_FIPCheckZero
.22fd	e8		inx				inx 								; -ve so round *down*.
.22fe	a9 01		lda #$01			lda 	#1
.2300	20 78 26	jsr $2678			jsr 	FloatSetByte
.2303	20 38 26	jsr $2638			jsr 	FloatNegate
.2306	20 9a 20	jsr $209a			jsr 	FloatAdd
.2309					_FIPCheckZero:
.2309	20 98 26	jsr $2698			jsr 	FloatIsZero 				; avoid -0 problem
.230c	d0 03		bne $2311			bne 	_FIPExit 					; set to zero if mantissa zero.
.230e					_FIPZero:
.230e	20 76 26	jsr $2676			jsr 	FloatSetZero
.2311					_FIPExit:
.2311	7a		ply				ply
.2312	68		pla				pla
.2313	60		rts				rts
.2314					FloatInt8Multiply:
.2314	5a		phy				phy
.2315	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2317	a8		tay				tay
.2318	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.231a					_FI8MLoop:
.231a	98		tya				tya 								; shift right shifter right into carry
.231b	4a		lsr a				lsr 	a
.231c	a8		tay				tay
.231d	90 0d		bcc $232c			bcc 	_FI8MNoAdd
.231f	18		clc				clc
.2320	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2322	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.2324	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2326	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2328	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.232a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.232c					_FI8MNoAdd:
.232c	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.232e	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.2330	c0 00		cpy #$00			cpy 	#0
.2332	d0 e6		bne $231a			bne 	_FI8MLoop 					; until right shifter zero.
.2334	7a		ply				ply
.2335	60		rts				rts
.2336					FloatMultiply:
.2336	ca		dex				dex
.2337	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.2339	15 6f		ora $6f,x			ora 	NSExponent+1,x
.233b	15 62		ora $62,x			ora 	NSMantissa3,x
.233d	15 63		ora $63,x			ora 	NSMantissa3+1,x
.233f	d0 21		bne $2362			bne 	_FMUseFloat
.2341	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2343	15 33		ora $33,x			ora 	NSStatus+1,x
.2345	29 80		and #$80			and 	#$80
.2347	15 62		ora $62,x			ora 	NSMantissa3,x
.2349	15 56		ora $56,x			ora 	NSMantissa2,x
.234b	15 4a		ora $4a,x			ora 	NSMantissa1,x
.234d	15 63		ora $63,x			ora 	NSMantissa3+1,x
.234f	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2351	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2353	d0 04		bne $2359			bne 	_FMInt32
.2355	20 14 23	jsr $2314			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2358	60		rts				rts
.2359					_FMInt32:
.2359	20 83 23	jsr $2383			jsr 	FloatMultiplyShort			; use the int32 one.
.235c	18		clc				clc 								; fix it up if gone out of range
.235d	75 6e		adc $6e,x			adc 	NSExponent,x
.235f	95 6e		sta $6e,x			sta 	NSExponent,x
.2361	60		rts				rts
.2362					_FMUseFloat:
.2362	20 cb 23	jsr $23cb			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2365	f0 18		beq $237f			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2367	e8		inx				inx
.2368	20 cb 23	jsr $23cb			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.236b	ca		dex				dex
.236c	c9 00		cmp #$00			cmp 	#0
.236e	f0 0c		beq $237c			beq 	_FDSetZero
.2370	20 83 23	jsr $2383			jsr 	FloatMultiplyShort 			; calculate the result.
.2373	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2375	18		clc				clc
.2376	75 6f		adc $6f,x			adc 	NSExponent+1,x
.2378	95 6e		sta $6e,x			sta 	NSExponent,x
.237a	80 03		bra $237f			bra 	_FDExit
.237c					_FDSetZero:
.237c	20 76 26	jsr $2676			jsr 	FloatSetZero 				; return 0
.237f					_FDExit:
.237f	20 cb 23	jsr $23cb			jsr 	FloatNormalise 				; normalise the result
.2382	60		rts				rts
.2383					FloatMultiplyShort:
.2383	5a		phy				phy 								; save Y
.2384	20 59 26	jsr $2659			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2387	20 72 26	jsr $2672			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.238a	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.238c					_I32MLoop:
.238c	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.238e	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.2390	15 58		ora $58,x			ora 	NSMantissa2+2,x
.2392	15 64		ora $64,x			ora 	NSMantissa3+2,x
.2394	f0 25		beq $23bb			beq 	_I32MExit 					; exit if zero
.2396	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2398	29 01		and #$01			and 	#1
.239a	f0 0d		beq $23a9			beq 	_I32MNoAdd
.239c	20 02 24	jsr $2402			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.239f	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.23a1	10 06		bpl $23a9			bpl 	_I32MNoAdd
.23a3					_I32ShiftRight:
.23a3	20 8f 26	jsr $268f			jsr 	FloatShiftRight 			; shift S[X] right
.23a6	c8		iny				iny 								; increment shift count
.23a7	80 09		bra $23b2			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23a9					_I32MNoAdd:
.23a9	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23ab	70 f6		bvs $23a3			bvs 	_I32ShiftRight 				; instead.
.23ad	e8		inx				inx
.23ae	20 85 26	jsr $2685			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23b1	ca		dex				dex
.23b2					_I32MShiftUpper:
.23b2	e8		inx				inx 								; shift S[X+2] right
.23b3	e8		inx				inx
.23b4	20 8f 26	jsr $268f			jsr 	FloatShiftRight
.23b7	ca		dex				dex
.23b8	ca		dex				dex
.23b9	80 d1		bra $238c			bra 	_I32MLoop 					; try again.
.23bb					_I32MExit:
.23bb	20 c1 23	jsr $23c1			jsr 	FloatCalculateSign
.23be	98		tya				tya 								; shift in A
.23bf	7a		ply				ply 								; restore Y and exit
.23c0	60		rts				rts
.23c1					FloatCalculateSign:
.23c1	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23c3	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23c5	55 33		eor $33,x			eor 	NSStatus+1,x
.23c7	0a		asl a				asl 	a 							; shift bit 7 into carry
.23c8	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23ca	60		rts				rts
.23cb					FloatNormalise:
.23cb	20 98 26	jsr $2698			jsr 	FloatIsZero 				; if zero exit
.23ce	d0 07		bne $23d7			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23d0	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.23d2	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.23d4	a9 00		lda #$00			lda 	#0 							; set Z flag
.23d6	60		rts				rts
.23d7					_NSNormaliseOptimise:
.23d7	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23d9	d0 19		bne $23f4			bne 	_NSNormaliseLoop
.23db	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.23dd	30 15		bmi $23f4			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23df	95 62		sta $62,x			sta 	NSMantissa3,x
.23e1	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.23e3	95 56		sta $56,x			sta 	NSMantissa2,x
.23e5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.23e7	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23e9	74 3e		stz $3e,x			stz 	NSMantissa0,x
.23eb	b5 6e		lda $6e,x			lda 	NSExponent,x
.23ed	38		sec				sec
.23ee	e9 08		sbc #$08			sbc 	#8
.23f0	95 6e		sta $6e,x			sta 	NSExponent,x
.23f2	80 e3		bra $23d7			bra 	_NSNormaliseOptimise
.23f4					_NSNormaliseLoop:
.23f4	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23f6	70 07		bvs $23ff			bvs 	_NSNExit 					; exit if so with Z flag clear
.23f8	20 85 26	jsr $2685			jsr 	FloatShiftLeft 				; shift mantissa left
.23fb	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23fd	80 f5		bra $23f4			bra 	_NSNormaliseLoop
.23ff					_NSNExit:
.23ff	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.2401	60		rts				rts
.2402					FloatAddTopTwoStack:
.2402	18		clc				clc
.2403	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2405	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.2407	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2409	b5 4a		lda $4a,x			lda		NSMantissa1,x
.240b	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.240d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.240f	b5 56		lda $56,x			lda		NSMantissa2,x
.2411	75 57		adc $57,x			adc 		NSMantissa2+1,x
.2413	95 56		sta $56,x			sta 	NSMantissa2,x
.2415	b5 62		lda $62,x			lda		NSMantissa3,x
.2417	75 63		adc $63,x			adc 		NSMantissa3+1,x
.2419	95 62		sta $62,x			sta 	NSMantissa3,x
.241b	60		rts				rts
.241c					FloatSubTopTwoStack:
.241c	38		sec				sec
.241d	b5 3e		lda $3e,x			lda		NSMantissa0,x
.241f	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.2421	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2423	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2425	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.2427	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2429	b5 56		lda $56,x			lda		NSMantissa2,x
.242b	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.242d	95 56		sta $56,x			sta 	NSMantissa2,x
.242f	b5 62		lda $62,x			lda		NSMantissa3,x
.2431	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.2433	95 62		sta $62,x			sta 	NSMantissa3,x
.2435	60		rts				rts
.2436					FloatInt32Add:
.2436	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2438	55 33		eor $33,x			eor 	NSStatus+1,x
.243a	30 04		bmi $2440			bmi 	_DiffSigns
.243c	20 02 24	jsr $2402			jsr		FloatAddTopTwoStack
.243f	60		rts				rts
.2440					_DiffSigns:
.2440	20 1c 24	jsr $241c			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2443	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2445	10 07		bpl $244e			bpl 	_AddExit
.2447	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2449	95 32		sta $32,x			sta 	NSStatus,x
.244b	20 3f 26	jsr $263f			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.244e					_AddExit:
.244e	20 98 26	jsr $2698			jsr 	FloatIsZero 				; check for -0
.2451	d0 02		bne $2455			bne 	_AddNonZero
.2453	74 32		stz $32,x			stz 	NSStatus,x
.2455					_AddNonZero:
.2455	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2456					FloatEncodeStart:
.2456	38		sec				sec
.2457	80 01		bra $245a			bra 	FloatEncodeContinue+1
.2459					FloatEncodeContinue:
.2459	18		clc				clc
.245a					FloatEncode:
.245a	08		php				php 								; save reset flag.
.245b	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.245d	f0 15		beq $2474			beq 	_ENIsOkay
.245f	c9 30		cmp #$30			cmp 	#"0"
.2461	90 04		bcc $2467			bcc 	_ENBadNumber
.2463	c9 3a		cmp #$3a			cmp 	#"9"+1
.2465	90 0d		bcc $2474			bcc 	_ENIsOkay
.2467					_ENBadNumber:
.2467	28		plp				plp 								; throw saved reset
.2468	ad 37 06	lda $0637			lda 	encodeState 				; if in decimal mode, construct final number
.246b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.246d	d0 03		bne $2472			bne 	_ENFail
.246f	4c ec 24	jmp $24ec			jmp 	_ENConstructFinal
.2472					_ENFail:
.2472	18		clc				clc 								; not allowed
.2473	60		rts				rts
.2474					_ENIsOkay:
.2474	28		plp				plp 								; are we restarting
.2475	90 15		bcc $248c			bcc 	_ENNoRestart
.2477					_ENStartEncode:
.2477	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2479	f0 0c		beq $2487			beq 	_ENFirstDP
.247b	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.247d	20 78 26	jsr $2678			jsr 	FloatSetByte 				; in single byte mode.
.2480	a9 01		lda #$01			lda 	#ESTA_Low
.2482					_ENExitChange:
.2482	8d 37 06	sta $0637			sta 	encodeState 				; save new state
.2485	38		sec				sec
.2486	60		rts				rts
.2487					_ENFirstDP:
.2487	20 76 26	jsr $2676			jsr 	FloatSetZero 				; clear integer part
.248a	80 3c		bra $24c8			bra 	_ESTASwitchFloat			; go straight to float and exi
.248c					_ENNoRestart:
.248c	48		pha				pha 								; save digit or DP on stack.
.248d	ad 37 06	lda $0637			lda 	encodeState 				; get current state
.2490	c9 01		cmp #$01			cmp 	#ESTA_Low
.2492	f0 09		beq $249d			beq  	_ESTALowState
.2494	c9 02		cmp #$02			cmp 	#ESTA_High
.2496	f0 26		beq $24be			beq 	_ESTAHighState
.2498	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.249a	f0 38		beq $24d4			beq 	_ESTADecimalState
>249c	db						.byte 	$DB 						; causes a break in the emulator
.249d					_ESTALowState:
.249d	68		pla				pla 								; get value back
.249e	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.24a0	f0 26		beq $24c8			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24a2	29 0f		and #$0f			and 	#15 						; make digit
.24a4	8d 38 06	sta $0638			sta 	digitTemp 					; save it.
.24a7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24a9	0a		asl a				asl 	a
.24aa	0a		asl a				asl 	a
.24ab	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24ad	0a		asl a				asl 	a
.24ae	6d 38 06	adc $0638			adc 	digitTemp
.24b1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24b3	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24b5	90 05		bcc $24bc			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24b7	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24b9	8d 37 06	sta $0637			sta 	encodeState
.24bc					_ESTANoSwitch:
.24bc	38		sec				sec
.24bd	60		rts				rts
.24be					_ESTAHighState:
.24be	68		pla				pla 								; get value back
.24bf	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24c1	f0 05		beq $24c8			beq 	_ESTASwitchFloat
.24c3	20 1e 25	jsr $251e			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24c6	38		sec				sec
.24c7	60		rts				rts
.24c8					_ESTASwitchFloat:
.24c8	9c 39 06	stz $0639			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24cb	e8		inx				inx 								; zero the decimal additive.
.24cc	20 76 26	jsr $2676			jsr 	FloatSetZero
.24cf	ca		dex				dex
.24d0	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24d2	80 ae		bra $2482			bra 	_ENExitChange
.24d4					_ESTADecimalState:
.24d4	68		pla				pla 								; digit.
.24d5	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24d7	f0 99		beq $2472			beq 	_ENFail
.24d9	e8		inx				inx 								; put digit into fractional part of X+1
.24da	20 1e 25	jsr $251e			jsr 	ESTAShiftDigitIntoMantissa
.24dd	ca		dex				dex
.24de	ee 39 06	inc $0639			inc 	decimalCount 				; bump the count of decimals
.24e1	ad 39 06	lda $0639			lda 	decimalCount 				; too many decimal digits.
.24e4	c9 0b		cmp #$0b			cmp 	#11
.24e6	f0 02		beq $24ea			beq 	_ESTADSFail
.24e8	38		sec				sec
.24e9	60		rts				rts
.24ea					_ESTADSFail:
.24ea	18		clc				clc
.24eb	60		rts				rts
.24ec					_ENConstructFinal:
.24ec	ad 39 06	lda $0639			lda 	decimalCount 				; get decimal count
.24ef	f0 2b		beq $251c			beq 	_ENCFExit 					; no decimals
.24f1	5a		phy				phy
.24f2	0a		asl a				asl 	a 							; x 4 and CLC
.24f3	0a		asl a				asl 	a
.24f4	6d 39 06	adc $0639			adc 	decimalCount
.24f7	a8		tay				tay
.24f8	b9 83 21	lda $2183,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24fb	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24fd	b9 84 21	lda $2184,y			lda 	FloatScalarTable-5+1,y
.2500	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2502	b9 85 21	lda $2185,y			lda 	FloatScalarTable-5+2,y
.2505	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2507	b9 86 21	lda $2186,y			lda 	FloatScalarTable-5+3,y
.250a	95 64		sta $64,x			sta 	NSMantissa3+2,x
.250c	b9 87 21	lda $2187,y			lda 	FloatScalarTable-5+4,y
.250f	95 70		sta $70,x			sta 	NSExponent+2,x
.2511	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.2513	e8		inx				inx 								; multiply decimal const by decimal scalar
.2514	e8		inx				inx
.2515	20 36 23	jsr $2336			jsr 	FloatMultiply
.2518	20 9a 20	jsr $209a			jsr 	FloatAdd 					; add to integer part.
.251b	7a		ply				ply
.251c					_ENCFExit:
.251c	18		clc				clc 								; reject the digit.
.251d	60		rts				rts
.251e					ESTAShiftDigitIntoMantissa:
.251e	29 0f		and #$0f			and 	#15 						; save digit
.2520	48		pha				pha
.2521	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2523	48		pha				pha
.2524	b5 56		lda $56,x			lda 	NSMantissa2,x
.2526	48		pha				pha
.2527	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2529	48		pha				pha
.252a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.252c	48		pha				pha
.252d	20 85 26	jsr $2685			jsr 	FloatShiftLeft 				; x 2
.2530	20 85 26	jsr $2685			jsr 	FloatShiftLeft 				; x 4
.2533	18		clc				clc 								; pop mantissa and add
.2534	68		pla				pla
.2535	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2537	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2539	68		pla				pla
.253a	75 4a		adc $4a,x			adc 	NSMantissa1,x
.253c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.253e	68		pla				pla
.253f	75 56		adc $56,x			adc 	NSMantissa2,x
.2541	95 56		sta $56,x			sta 	NSMantissa2,x
.2543	68		pla				pla
.2544	75 62		adc $62,x			adc 	NSMantissa3,x
.2546	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.2548	20 85 26	jsr $2685			jsr 	FloatShiftLeft 				; x 10
.254b	68		pla				pla 								; add digit
.254c	18		clc				clc
.254d	75 3e		adc $3e,x			adc 	NSMantissa0,x
.254f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2551	90 0a		bcc $255d			bcc 	_ESTASDExit
.2553	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2555	d0 06		bne $255d			bne 	_ESTASDExit
.2557	f6 56		inc $56,x			inc 	NSMantissa2,x
.2559	d0 02		bne $255d			bne 	_ESTASDExit
.255b	f6 62		inc $62,x			inc 	NSMantissa3,x
.255d					_ESTASDExit:
.255d	60		rts				rts
.0637					encodeState:
>0637							.fill 	1
.0638					digitTemp:
>0638							.fill 	1
.0639					decimalCount:
>0639							.fill 	1
.255e					FloatToString:
.255e	da		phx				phx
.255f	5a		phy				phy 								; save code position
.2560	8d 3a 06	sta $063a			sta 	decimalPlaces	 			; save number of DPs.
.2563	9c 3b 06	stz $063b			stz 	dbOffset 					; offset into decimal buffer = start.
.2566	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.2568	10 08		bpl $2572			bpl 	_CNTSNotNegative
.256a	29 7f		and #$7f			and 	#$7F 						; make +ve
.256c	95 32		sta $32,x			sta 	NSStatus,x
.256e	a9 2d		lda #$2d			lda 	#"-"
.2570	80 02		bra $2574			bra 	_CNTMain
.2572					_CNTSNotNegative:
.2572	a9 20		lda #$20			lda 	#" "
.2574					_CNTMain:
.2574	20 d6 25	jsr $25d6			jsr 	WriteDecimalBuffer
.2577	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.2579	f0 0d		beq $2588			beq 	_CNTSNotFloat
.257b	e8		inx				inx 								; round up so we don't get too many 6.999999
.257c	a9 01		lda #$01			lda 	#1
.257e	20 78 26	jsr $2678			jsr 	FloatSetByte
.2581	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2583	95 6e		sta $6e,x			sta 	NSExponent,x
.2585	20 9a 20	jsr $209a			jsr 	FloatAdd
.2588					_CNTSNotFloat:
.2588	20 b8 25	jsr $25b8			jsr 	MakePlusTwoString 			; do the integer part.
.258b	20 56 22	jsr $2256			jsr 	FloatFractionalPart 		; get the fractional part
.258e	20 cb 23	jsr $23cb			jsr 	FloatNormalise					; normalise , exit if zero
.2591	f0 22		beq $25b5			beq 	_CNTSExit
.2593	a9 2e		lda #$2e			lda 	#"."
.2595	20 d6 25	jsr $25d6			jsr 	WriteDecimalBuffer 			; write decimal place
.2598					_CNTSDecimal:
.2598	ce 3a 06	dec $063a			dec 	decimalPlaces 				; done all the decimals
.259b	30 18		bmi $25b5			bmi 	_CNTSExit
.259d	e8		inx				inx 								; x 10.0
.259e	a9 0a		lda #$0a			lda 	#10
.25a0	20 78 26	jsr $2678			jsr 	FloatSetByte
.25a3	20 36 23	jsr $2336			jsr 	FloatMultiply
.25a6	20 b8 25	jsr $25b8			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25a9	20 56 22	jsr $2256			jsr 	FloatFractionalPart 		; get the fractional part
.25ac	20 cb 23	jsr $23cb			jsr 	FloatNormalise 				; normalise it.
.25af	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25b1	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25b3	b0 e3		bcs $2598			bcs 	_CNTSDecimal 				; keep going.
.25b5					_CNTSExit:
.25b5	7a		ply				ply
.25b6	fa		plx				plx
.25b7	60		rts				rts
.25b8					MakePlusTwoString:
.25b8	da		phx				phx
.25b9	20 59 26	jsr $2659			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25bc	e8		inx				inx 								; access it
.25bd	e8		inx				inx
.25be	20 b1 22	jsr $22b1			jsr 	FloatIntegerPart 			; make it an integer
.25c1	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25c3	20 f5 25	jsr $25f5			jsr 	ConvertInt32
.25c6	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25c8					_MPTSCopy:
.25c8	bd 15 06	lda $0615,x			lda 	numberBuffer,x
.25cb	20 d6 25	jsr $25d6			jsr 	WriteDecimalBuffer
.25ce	e8		inx				inx
.25cf	bd 15 06	lda $0615,x			lda 	numberBuffer,x
.25d2	d0 f4		bne $25c8			bne 	_MPTSCopy
.25d4	fa		plx				plx
.25d5	60		rts				rts
.25d6					WriteDecimalBuffer:
.25d6	da		phx				phx
.25d7	ae 3b 06	ldx $063b			ldx 	dbOffset
.25da	9d 3c 06	sta $063c,x			sta 	decimalBuffer,x
.25dd	9e 3d 06	stz $063d,x			stz 	decimalBuffer+1,x
.25e0	ee 3b 06	inc $063b			inc 	dbOffset
.25e3	fa		plx				plx
.25e4	60		rts				rts
.063a					decimalPlaces:
>063a							.fill 	1
.063b					dbOffset:
>063b							.fill 	1
.063c					decimalBuffer:
>063c							.fill 	32
.25e5					ConvertInt16:
.25e5	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.25e7	86 4a		stx $4a				stx 	NSMantissa1
.25e9	64 56		stz $56				stz 	NSMantissa2
.25eb	64 62		stz $62				stz 	NSMantissa3
.25ed	64 32		stz $32				stz 	NSStatus 					; positive integer
.25ef	a2 00		ldx #$00			ldx 	#0 							; stack level
.25f1	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25f3	80 00		bra $25f5			bra 	ConvertInt32
.25f5					ConvertInt32:
.25f5	5a		phy				phy
.25f6	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25f8	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25fa	10 08		bpl $2604			bpl 	_CI32NotNeg
.25fc	48		pha				pha
.25fd	a9 2d		lda #$2d			lda 	#'-'
.25ff	99 15 06	sta $0615,y			sta 	numberBuffer,y
.2602	c8		iny				iny
.2603	68		pla				pla
.2604					_CI32NotNeg:
.2604	20 12 26	jsr $2612			jsr 	_CI32DivideConvert 			; recursive conversion
.2607	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2609	99 15 06	sta $0615,y			sta 	numberBuffer,y
.260c	7a		ply				ply
.260d	a2 06		ldx #$06			ldx 	#numberBuffer >> 8 			; return address in XA
.260f	a9 15		lda #$15			lda 	#numberBuffer & $FF
.2611	60		rts				rts
.2612					_CI32DivideConvert:
.2612	e8		inx				inx 								; write to next slot up
.2613	20 78 26	jsr $2678			jsr 	FloatSetByte 		 		; write the base out.
.2616	ca		dex				dex
.2617	20 0c 22	jsr $220c			jsr 	Int32Divide 				; divide
.261a	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.261c	48		pha				pha
.261d	20 fb 21	jsr $21fb			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2620	20 98 26	jsr $2698			jsr 	FloatIsZero 				; is it zero ?
.2623	f0 05		beq $262a			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2625	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2627	20 12 26	jsr $2612			jsr 	_CI32DivideConvert 			; and recusrively call.
.262a					_CI32NoRecurse:
.262a	68		pla				pla 								; remainder
.262b	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.262d	90 02		bcc $2631			bcc 	_CI32NotHex
.262f	69 26		adc #$26			adc 	#6+32
.2631					_CI32NotHex:
.2631	69 30		adc #$30			adc 	#48
.2633	99 15 06	sta $0615,y			sta 	numberBuffer,y 				; write out and exit
.2636	c8		iny				iny
.2637	60		rts				rts
.2638					FloatNegate:
.2638	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.263a	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.263c	95 32		sta $32,x			sta 	NSStatus,x
.263e	60		rts				rts
.263f					FloatNegateMantissa:
.263f	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2640	a9 00		lda #$00			lda 	#0
.2642	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2644	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2646	a9 00		lda #$00			lda 	#0
.2648	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.264a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.264c	a9 00		lda #$00			lda 	#0
.264e	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.2650	95 56		sta $56,x			sta 	NSMantissa2,x
.2652	a9 00		lda #$00			lda 	#0
.2654	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2656	95 62		sta $62,x			sta 	NSMantissa3,x
.2658	60		rts				rts
.2659					FloatShiftUpTwo:
.2659	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.265b	95 40		sta $40,x			sta 	NSMantissa0+2,x
.265d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.265f	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2661	b5 56		lda $56,x			lda 	NSMantissa2,x
.2663	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2665	b5 62		lda $62,x			lda 	NSMantissa3,x
.2667	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2669	b5 6e		lda $6e,x			lda 	NSExponent,x
.266b	95 70		sta $70,x			sta 	NSExponent+2,x
.266d	b5 32		lda $32,x			lda 	NSStatus,x
.266f	95 34		sta $34,x			sta 	NSStatus+2,x
.2671	60		rts				rts
.2672					FloatSetZeroMantissaOnly:
.2672	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2674	80 08		bra $267e			bra 	FloatZero13
.2676					FloatSetZero:
.2676	a9 00		lda #$00			lda 	#0
.2678					FloatSetByte:
.2678	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.267a					FloatSetMantissa:
.267a	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.267c	74 32		stz $32,x			stz 	NSStatus,x
.267e					FloatZero13:
.267e	74 4a		stz $4a,x			stz 	NSMantissa1,x
.2680	74 56		stz $56,x			stz 	NSMantissa2,x
.2682	74 62		stz $62,x			stz 	NSMantissa3,x
.2684	60		rts				rts
.2685					FloatShiftLeft:
.2685	18		clc				clc
.2686					FloatRotateLeft:
.2686	36 3e		rol $3e,x			rol 	NSMantissa0,x
.2688	36 4a		rol $4a,x			rol		NSMantissa1,x
.268a	36 56		rol $56,x			rol		NSMantissa2,x
.268c	36 62		rol $62,x			rol		NSMantissa3,x
.268e	60		rts				rts
.268f					FloatShiftRight:
.268f	56 62		lsr $62,x			lsr 	NSMantissa3,x
.2691	76 56		ror $56,x			ror		NSMantissa2,x
.2693	76 4a		ror $4a,x			ror		NSMantissa1,x
.2695	76 3e		ror $3e,x			ror		NSMantissa0,x
.2697	60		rts				rts
.2698					FloatIsZero:
.2698	b5 62		lda $62,x			lda 	NSMantissa3,x
.269a	15 56		ora $56,x			ora		NSMantissa2,x
.269c	15 4a		ora $4a,x			ora		NSMantissa1,x
.269e	15 3e		ora $3e,x			ora		NSMantissa0,x
.26a0	60		rts				rts

;******  Processing input file: testing/testend.asm

.26a1					EndProgram:
>26a1	01 08 0c 08 0a 00 4e 20				.binary "code/tokenised.dat"
>26a9	b2 20 31 34 00 15 08 14 00 ce 86 20 33 00 32 08
>26b9	3c 00 99 20 c7 28 31 34 37 29 3b 22 48 45 4c 4c
>26c9	4f 20 57 4f 52 4c 44 20 21 22 00 4e 08 46 00 86
>26d9	20 42 58 28 4e 29 3a 86 20 42 59 28 4e 29 3a 86
>26e9	20 42 43 28 4e 29 00 62 08 4b 00 86 20 44 58 28
>26f9	4e 29 3a 86 20 44 59 28 4e 29 00 70 08 50 00 81
>2709	20 42 b2 30 20 a4 20 4e 00 89 08 5a 00 42 58 28
>2719	42 29 b2 b5 28 bb 28 31 29 ac 34 30 29 ac 32 aa
>2729	31 00 a2 08 64 00 42 59 28 42 29 b2 b5 28 bb 28
>2739	31 29 ac 33 30 29 ac 32 35 36 00 b9 08 69 00 42
>2749	43 28 42 29 b2 b5 28 bb 28 31 29 ac 31 34 29 aa
>2759	31 00 cd 08 6a 00 44 58 28 42 29 b2 b5 28 bb 28
>2769	31 29 ac 32 29 00 e3 08 6c 00 8f 20 44 59 28 42
>2779	29 b2 b5 28 bb 28 31 29 ac 32 29 00 ef 08 6d 00
>2789	44 59 28 42 29 b2 31 00 f7 08 6e 00 82 20 42 00
>2799	fd 08 78 00 8f 00 11 09 82 00 81 59 b2 30 a4 32
>27a9	39 3a 81 58 b2 30 a4 33 39 00 27 09 8c 00 51 b2
>27b9	59 ac 32 35 36 aa 58 ac 32 aa 34 35 30 35 36 00
>27c9	3f 09 96 00 ce 84 20 31 2c 51 2c 38 31 3a ce 84
>27d9	31 2c 51 aa 31 2c 30 00 48 09 a0 00 82 58 2c 59
>27e9	00 54 09 c8 00 81 20 42 b2 31 a4 4e 00 71 09 d2
>27f9	00 ce 84 20 31 2c 34 35 30 35 36 aa 42 59 28 42
>2809	29 aa 42 58 28 42 29 2c 30 00 7f 09 e6 00 44 58
>2819	42 b2 44 58 28 42 29 00 90 09 f0 00 8b 44 58 42
>2829	b2 30 a7 8d 31 30 31 30 00 a1 09 fa 00 8b 44 58
>2839	42 b2 31 a7 8d 31 30 34 30 00 af 09 ff 00 44 59
>2849	42 b2 44 59 28 42 29 00 c0 09 04 01 8b 44 59 42
>2859	b2 30 a7 8d 31 30 37 30 00 d1 09 0e 01 8b 44 59
>2869	42 b2 31 a7 8d 31 31 30 30 00 f2 09 18 01 ce 84
>2879	20 31 2c 34 35 30 35 36 aa 42 59 28 42 29 aa 42
>2889	58 28 42 29 2c 42 43 28 42 29 00 f9 09 22 01 82
>2899	42 00 03 0a 2c 01 89 20 32 30 30 00 09 0a e8 03
>28a9	8f 00 17 0a f2 03 42 58 42 b2 42 58 28 42 29 00
>28b9	2c 0a f3 03 8b 42 58 42 b2 31 a7 44 58 28 42 29
>28c9	b2 31 3a 8e 00 3e 0a fc 03 42 58 28 42 29 b2 42
>28d9	58 42 ab 32 3a 8e 00 44 0a 06 04 8f 00 52 0a 10
>28e9	04 42 58 42 b2 42 58 28 42 29 00 72 0a 11 04 8b
>28f9	42 58 42 b2 37 39 a7 20 42 58 28 42 29 b2 37 37
>2909	3a 44 58 28 42 29 b2 30 3a 8e 00 84 0a 1a 04 42
>2919	58 28 42 29 b2 42 58 42 aa 32 3a 8e 00 8a 0a 24
>2929	04 8f 00 98 0a 2e 04 42 59 42 b2 42 59 28 42 29
>2939	00 ad 0a 2f 04 8b 42 59 42 b2 30 a7 44 59 28 42
>2949	29 b2 31 3a 8e 00 c1 0a 38 04 42 59 28 42 29 b2
>2959	42 59 42 ab 32 35 36 3a 8e 00 c7 0a 42 04 8f 00
>2969	d5 0a 4c 04 42 59 42 b2 42 59 28 42 29 00 f8 0a
>2979	4d 04 8b 42 59 42 b2 37 34 32 34 a7 42 59 28 42
>2989	29 b2 37 31 36 38 3a 44 59 28 42 29 b2 30 3a 8e
>2999	00 0c 0b 56 04 42 59 28 42 29 b2 42 59 42 aa 32
>29a9	35 36 3a 8e 00 00 00

;******  End of listing
