
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Sat Oct  7 21:56:15 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.1000					WrapperBoot:
.1000	a2 0a		ldx #$0a			ldx 	#APIDesc & $FF
.1002	a0 10		ldy #$10			ldy 	#APIDesc >> 8
.1004	20 70 11	jsr $1170			jsr 	StartCompiler
.1007	4c ff ff	jmp $ffff			jmp 	$FFFF
.100a					APIDesc:
>100a	0e 10						.word 	TestAPI 					; the testing API.
>100c	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>100d	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing file: testing/api/api.asm

=$a000					PCodeMemory = $A000
.100e					TestAPI:
.100e	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.1010	f0 19		beq $102b			beq 	_TAOpenIn
.1012	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.1014	f0 1d		beq $1033			beq 	_TACloseIn
.1016	c9 02		cmp #$02			cmp 	#BLC_READIN
.1018	f0 1a		beq $1034			beq 	_TARead
.101a	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.101c	f0 19		beq $1037			beq 	_TAResetOut
.101e	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.1020	f0 1e		beq $1040			beq 	_TACloseOut
.1022	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.1024	f0 24		beq $104a			beq 	_TAWriteByte
.1026	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.1028	f0 2a		beq $1054			beq 	_TAPrintScreen
>102a	db						.byte 	$DB 						; causes a break in the emulator
.102b					_TAOpenIn:
.102b	a9 ba		lda #$ba			lda 	#((EndProgram+2) & $FF)
.102d	85 22		sta $22				sta 	0+srcInputPtr
.102f	a9 26		lda #$26			lda 	#((EndProgram+2) >> 8) & $FF
.1031	85 23		sta $23				sta 	1+srcInputPtr
.1033					_TACloseIn:
.1033	60		rts				rts
.1034					_TARead:
.1034	4c 58 10	jmp $1058			jmp 	ReadNextLine
.1037					_TAResetOut:
.1037	a9 00		lda #$00			lda 	#((PCodeMemory) & $FF)
.1039	85 28		sta $28				sta 	0+objPtr
.103b	a9 a0		lda #$a0			lda 	#((PCodeMemory) >> 8) & $FF
.103d	85 29		sta $29				sta 	1+objPtr
.103f	60		rts				rts
.1040					_TACloseOut:
.1040	a9 a0		lda #$a0			lda 	#PCodeMemory >> 8
.1042	a6 28		ldx $28				ldx 	objPtr
.1044	a4 29		ldy $29				ldy 	objPtr+1
.1046	20 7d 10	jsr $107d			jsr 	APISaveMemory
.1049	60		rts				rts
.104a					_TAWriteByte:
.104a	8a		txa				txa
.104b	92 28		sta ($28)			sta 	(objPtr)
.104d	e6 28		inc $28				inc 	objPtr
.104f	d0 02		bne $1053			bne 	_HWOWBNoCarry
.1051	e6 29		inc $29				inc 	objPtr+1
.1053					_HWOWBNoCarry:
.1053	60		rts				rts
.1054					_TAPrintScreen:
.1054	8a		txa				txa
.1055	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.0022					srcInputPtr:
>0022							.fill 	2

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/line.asm

.1058					ReadNextLine:
.1058	b2 22		lda ($22)			lda 	(srcInputPtr) 				; reached the end of the program (address link = $0000)
.105a	a0 01		ldy #$01			ldy 	#1
.105c	11 22		ora ($22),y			ora 	(srcInputPtr),y
.105e	d0 02		bne $1062			bne 	_RLAHaveData
.1060	18		clc				clc
.1061	60		rts				rts									; end of file.
.1062					_RLAHaveData:
.1062	a6 22		ldx $22				ldx 	srcInputPtr 				; remember the line start
.1064	a4 23		ldy $23				ldy 	srcInputPtr+1
.1066	5a		phy				phy
.1067	a0 04		ldy #$04			ldy 	#4 							; must be at least four bytes (address/line#)
.1069					_RNLRead:
.1069	b1 22		lda ($22),y			lda 	(srcInputPtr),y 			; find the end of the line.
.106b	c8		iny				iny
.106c	c9 00		cmp #$00			cmp 	#0
.106e	d0 f9		bne $1069			bne 	_RNLRead
.1070	98		tya				tya 								; advance src input pointer to next.
.1071	18		clc				clc
.1072	65 22		adc $22				adc 	srcInputPtr
.1074	85 22		sta $22				sta 	srcInputPtr
.1076	90 02		bcc $107a			bcc 	_RNLNoCarry
.1078	e6 23		inc $23				inc 	srcInputPtr+1
.107a					_RNLNoCarry:
.107a	7a		ply				ply 								; address of line now in YX.
.107b	38		sec				sec
.107c	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_save.asm

.107d					APISaveMemory:
.107d	da		phx				phx
.107e	5a		phy				phy
.107f	48		pha				pha
.1080	a9 00		lda #$00			lda 	#0 							; set LFS
.1082	a2 08		ldx #$08			ldx 	#8
.1084	a0 00		ldy #$00			ldy 	#0
.1086	20 ba ff	jsr $ffba			jsr 	$FFBA
.1089	a9 08		lda #$08			lda 	#8 							; set file name
.108b	a2 9f		ldx #$9f			ldx 	#SaveName & $FF
.108d	a0 10		ldy #$10			ldy 	#SaveName >> 8
.108f	20 bd ff	jsr $ffbd			jsr 	$FFBD
.1092	68		pla				pla 								; set up the start address.
.1093	85 2b		sta $2b				sta 	zTemp0+1
.1095	64 2a		stz $2a				stz 	zTemp0
.1097	a9 2a		lda #$2a			lda 	#zTemp0 					; from index.
.1099	7a		ply				ply 								; end in YX
.109a	fa		plx				plx
.109b	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.109e	60		rts				rts
.109f					SaveName:
>109f	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Return to file: testing/testing.asm


;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.0024					srcPtr:
>0024							.fill 	2
.0400					currentLineNumber:
>0400							.fill 	2
.10a7					InlineNonDecimal:
.10a7	a2 02		ldx #$02			ldx 	#2 							; get size in X
.10a9	c9 25		cmp #$25			cmp 	#"%"
.10ab	f0 02		beq $10af			beq 	_INDBinary
.10ad	a2 10		ldx #$10			ldx 	#16
.10af					_INDBinary:
.10af	85 2c		sta $2c				sta 	zTemp1 						; size => zTemp1
.10b1	64 2d		stz $2d				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.10b3	64 2a		stz $2a				stz 	zTemp0 						; zero result
.10b5	64 2b		stz $2b				stz 	zTemp0+1
.10b7					_INDLoop:
.10b7	20 4c 1a	jsr $1a4c			jsr 	LookNext 					; check next character
.10ba	20 88 1a	jsr $1a88			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.10bd	90 1f		bcc $10de			bcc		_INDDone 					; didn't convert
.10bf	c5 2c		cmp $2c				cmp 	zTemp1 						; size too large ?
.10c1	b0 1b		bcs $10de			bcs 	_INDDone
.10c3	20 ed 10	jsr $10ed			jsr 	_INDShift 					; x 2 or x 16
.10c6	e0 02		cpx #$02			cpx 	#2
.10c8	f0 09		beq $10d3			beq 	_INDNotHex
.10ca	20 ed 10	jsr $10ed			jsr 	_INDShift
.10cd	20 ed 10	jsr $10ed			jsr 	_INDShift
.10d0	20 ed 10	jsr $10ed			jsr 	_INDShift
.10d3					_INDNotHex:
.10d3	05 2a		ora $2a				ora 	zTemp0 						; or digit into result
.10d5	85 2a		sta $2a				sta 	zTemp0
.10d7	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume
.10da	e6 2d		inc $2d				inc 	zTemp1+1 					; bump count
.10dc	80 d9		bra $10b7			bra 	_INDLoop
.10de					_INDDone:
.10de	a5 2d		lda $2d				lda 	zTemp1+1 					; done at least 1 ?
.10e0	f0 08		beq $10ea			beq 	_INDError
.10e2	a4 2b		ldy $2b				ldy 	zTemp0+1 					; push constant
.10e4	a5 2a		lda $2a				lda 	zTemp0
.10e6	20 07 12	jsr $1207			jsr 	PushIntegerYA
.10e9	60		rts				rts
.10ea					_INDError:
.10ea	4c 47 1f	jmp $1f47		jmp	ErrorV_syntax
.10ed					_INDShift:
.10ed	06 2a		asl $2a				asl 	zTemp0
.10ef	26 2b		rol $2b				rol 	zTemp0+1
.10f1	60		rts				rts
.10f2					GetLineNumber:
.10f2	ac 01 04	ldy $0401			ldy 	currentLineNumber+1
.10f5	ad 00 04	lda $0400			lda 	currentLineNumber
.10f8	60		rts				rts
.10f9					WriteCodeByte:
.10f9	48		pha				pha 								; save on stack
.10fa	da		phx				phx
.10fb	5a		phy				phy
.10fc	aa		tax				tax
.10fd	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.10ff	20 04 12	jsr $1204			jsr 	CallAPIHandler
.1102	7a		ply				ply 								; restore from stack
.1103	fa		plx				plx
.1104	68		pla				pla
.1105	60		rts				rts
.1106					PrintCharacter
.1106	48		pha				pha
.1107	da		phx				phx
.1108	5a		phy				phy
.1109	aa		tax				tax
.110a	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.110c	20 04 12	jsr $1204			jsr 	CallAPIHandler
.110f	7a		ply				ply
.1110	fa		plx				plx
.1111	68		pla				pla
.1112	60		rts				rts
.1113					ProcessNewLine:
.1113	86 2a		stx $2a				stx 	zTemp0 						; save address in zTemp0
.1115	84 2b		sty $2b				sty 	zTemp0+1
.1117	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.1118	8a		txa				txa
.1119	69 04		adc #$04			adc 	#4
.111b	85 24		sta $24				sta 	srcPtr
.111d	98		tya				tya
.111e	69 00		adc #$00			adc 	#0
.1120	85 25		sta $25				sta 	srcPtr+1
.1122	a0 02		ldy #$02			ldy 	#2							; read and save line number
.1124	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1126	8d 00 04	sta $0400			sta 	currentLineNumber
.1129	c8		iny				iny
.112a	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.112c	8d 01 04	sta $0401			sta 	currentLineNumber+1
.112f	60		rts				rts
.1130					BufferClear:
.1130	9c 02 04	stz $0402			stz 	bufferSize
.1133	60		rts				rts
.1134					BufferWrite:
.1134	da		phx				phx
.1135	ae 02 04	ldx $0402			ldx 	bufferSize
.1138	9d 03 04	sta $0403,x			sta 	dataBuffer,x
.113b	ee 02 04	inc $0402			inc 	bufferSize
.113e	fa		plx				plx
.113f	60		rts				rts
.1140					BufferOutput:
.1140	ad 02 04	lda $0402			lda 	bufferSize
.1143	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1146	a2 00		ldx #$00			ldx 	#0
.1148					_BOLoop:
.1148	ec 02 04	cpx $0402			cpx 	bufferSize
.114b	f0 09		beq $1156			beq 	_BOExit
.114d	bd 03 04	lda $0403,x			lda 	dataBuffer,x
.1150	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1153	e8		inx				inx
.1154	80 f2		bra $1148			bra 	_BOLoop
.1156					_BOExit:
.1156	60		rts				rts
.0402					bufferSize:
>0402							.fill 	1
.0403					dataBuffer:
>0403							.fill 	256
.1157					CheckNextComma:
.1157	a9 2c		lda #$2c			lda	 	#","
.1159	80 06		bra $1161			bra 	CheckNextA
.115b					CheckNextRParen:
.115b	a9 29		lda #$29			lda	 	#")"
.115d	80 02		bra $1161			bra 	CheckNextA
.115f					CheckNextLParen:
.115f	a9 28		lda #$28			lda 	#"("
.1161					CheckNextA:
.1161	8d 03 05	sta $0503			sta 	checkCharacter 				; save test character
.1164					_CNALoop:
.1164	20 68 1a	jsr $1a68			jsr 	GetNextNonSpace 			; get next skipping spaces.
.1167	cd 03 05	cmp $0503			cmp 	checkCharacter 				; matches ?
.116a	f0 03		beq $116f			beq 	_CNAExit
.116c	4c 47 1f	jmp $1f47		jmp	ErrorV_syntax
.116f					_CNAExit:
.116f	60		rts				rts
.0503					checkCharacter:
>0503							.fill 	1
.1170					StartCompiler:
.1170	86 2a		stx $2a				stx 	zTemp0 						; access API
.1172	84 2b		sty $2b				sty 	zTemp0+1
.1174	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.1176	b2 2a		lda ($2a)			lda 	(zTemp0)
.1178	8d 05 05	sta $0505			sta 	APIVector
.117b	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.117d	8d 06 05	sta $0506			sta 	APIVector+1
.1180	c8		iny				iny 								; copy data area range.
.1181	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1183	8d 07 05	sta $0507			sta 	compilerStartHigh
.1186	c8		iny				iny
.1187	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1189	8d 08 05	sta $0508			sta 	compilerEndHigh
.118c	ba		tsx				tsx 								; save stack pointer
.118d	8e 04 05	stx $0504			stx 	compilerSP
.1190	20 ec 1d	jsr $1dec			jsr 	STRReset 					; reset storage (line#, variable)
.1193	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.1195	20 04 12	jsr $1204			jsr 	CallAPIHandler
.1198	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.119a	20 04 12	jsr $1204			jsr 	CallAPIHandler
.119d	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.119f	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.11a2	a9 00		lda #$00			lda 	#0
.11a4	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.11a7	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.11aa					MainCompileLoop:
.11aa	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.11ac	20 04 12	jsr $1204			jsr 	CallAPIHandler
.11af	90 31		bcc $11e2			bcc 	SaveCodeAndExit 			; end of source.
.11b1	20 13 11	jsr $1113			jsr 	ProcessNewLine 				; set up pointer and line number.
.11b4	20 f2 10	jsr $10f2			jsr 	GetLineNumber 				; get line #
.11b7	20 d6 1b	jsr $1bd6			jsr 	STRMarkLine 				; remember the code position and number of this line.
.11ba	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.11bc	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.11bf					_MCLSameLine:
.11bf	20 68 1a	jsr $1a68			jsr 	GetNextNonSpace 			; get the first character.
.11c2	f0 e6		beq $11aa			beq 	MainCompileLoop 			; end of line, get next line.
.11c4	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.11c6	f0 f7		beq $11bf			beq 	_MCLSameLine
.11c8	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.11ca	10 0c		bpl $11d8			bpl 	_MCLCheckAssignment
.11cc	a2 26		ldx #$26			ldx 	#CommandTables & $FF 		; do command tables.
.11ce	a0 16		ldy #$16			ldy 	#CommandTables >> 8
.11d0	20 ee 18	jsr $18ee			jsr 	GeneratorProcess
.11d3	b0 ea		bcs $11bf			bcs 	_MCLSameLine 				; keep trying to compile the line.
.11d5					_MCLSyntax:
.11d5	4c 47 1f	jmp $1f47		jmp	ErrorV_syntax
.11d8					_MCLCheckAssignment:
.11d8	20 7e 1a	jsr $1a7e			jsr 	CharIsAlpha 				; if not alpha then syntax error
.11db	90 f8		bcc $11d5			bcc 	_MCLSyntax
.11dd	20 a4 1b	jsr $1ba4			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.11e0	80 dd		bra $11bf			bra		_MCLSameLine 				; loop back.
.11e2					SaveCodeAndExit:
.11e2	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.11e4	20 04 12	jsr $1204			jsr 	CallAPIHandler
.11e7	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.11e9	a8		tay				tay
.11ea	20 d6 1b	jsr $1bd6			jsr 	STRMarkLine
.11ed	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.11ef	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.11f2	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.11f4	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.11f7	20 1e 15	jsr $151e			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.11fa	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.11fc	20 04 12	jsr $1204			jsr 	CallAPIHandler
.11ff					ExitCompiler:
.11ff	ae 04 05	ldx $0504			ldx 	compilerSP 					; reload SP and exit.
.1202	9a		txs				txs
.1203	60		rts				rts
.1204					CallAPIHandler:
.1204	6c 05 05	jmp ($0505)			jmp 	(APIVector)
.0504					compilerSP:
>0504							.fill 	1
.0505					APIVector:
>0505							.fill 	2
.0507					compilerStartHigh:
>0507							.fill 	1
.0508					compilerEndHigh:
>0508							.fill 	1
.1207					PushIntegerYA:
.1207	c0 00		cpy #$00			cpy 	#0 							; 0-255
.1209	f0 0f		beq $121a			beq 	PushIntegerA
.120b	48		pha				pha
.120c	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.120e	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1211	68		pla				pla 								; then LSB
.1212	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1215	98		tya				tya 								; then MSB
.1216	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1219	60		rts				rts
.121a					PushIntegerA:
.121a	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.121c	90 07		bcc $1225			bcc 	_PIWriteA
.121e	48		pha				pha
.121f	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.1221	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1224	68		pla				pla
.1225					_PIWriteA:
.1225	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1228	60		rts				rts
.1229					PushFloat:
.1229	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.122b	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.122e	b5 6c		lda $6c,x			lda 	NSExponent,x 				; and the data
.1230	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1233	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1235	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1238	b5 48		lda $48,x			lda 	NSMantissa1,x
.123a	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.123d	b5 54		lda $54,x			lda 	NSMantissa2,x
.123f	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1242	b5 30		lda $30,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.1244	29 80		and #$80			and 	#$80
.1246	15 60		ora $60,x			ora 	NSMantissa3,x
.1248	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.124b	60		rts				rts
.124c					CreateVariableRecord:
.124c	48		pha				pha
.124d	ad 13 05	lda $0513			lda 	freeVariableMemory 		; push current free address on stack.
.1250	48		pha				pha
.1251	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1254	48		pha				pha
.1255	ad 11 05	lda $0511			lda 	variableListEnd  		; copy end of list to zTemp0
.1258	85 2a		sta $2a				sta 	zTemp0
.125a	ad 12 05	lda $0512			lda 	variableListEnd+1
.125d	85 2b		sta $2b				sta 	zTemp0+1
.125f	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.1261	92 2a		sta ($2a)			sta 	(zTemp0)
.1263	98		tya				tya
.1264	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.1266	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1268	88		dey				dey
.1269	8a		txa				txa
.126a	91 2a		sta ($2a),y			sta 	(zTemp0),y
.126c	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.126e	ad 13 05	lda $0513			lda 	freeVariableMemory
.1271	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1273	c8		iny				iny
.1274	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1277	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1279	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.127b	a9 00		lda #$00			lda 	#0
.127d	91 2a		sta ($2a),y			sta 	(zTemp0),y
.127f	18		clc				clc
.1280	b2 2a		lda ($2a)			lda 	(zTemp0) 				; add offset to variableListEnd
.1282	6d 11 05	adc $0511			adc  	variableListEnd
.1285	8d 11 05	sta $0511			sta 	variableListEnd
.1288	90 03		bcc $128d			bcc 	_CVNoCarry2
.128a	ee 12 05	inc $0512			inc 	variableListEnd+1
.128d					_CVNoCarry2:
.128d	7a		ply				ply
.128e	fa		plx				plx
.128f	68		pla				pla
.1290	60		rts				rts
.1291					SetVariableRecordToCodePosition:
.1291	48		pha				pha
.1292	5a		phy				phy
.1293	a0 03		ldy #$03			ldy 	#3
.1295	a5 29		lda $29				lda 	objPtr+1
.1297	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1299	c8		iny				iny
.129a	a5 28		lda $28				lda 	objPtr
.129c	91 2a		sta ($2a),y			sta 	(zTemp0),y
.129e	7a		ply				ply
.129f	68		pla				pla
.12a0	60		rts				rts
.12a1					AllocateBytesForType:
.12a1	48		pha				pha
.12a2	da		phx				phx
.12a3	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.12a5	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.12a7	c9 00		cmp #$00			cmp 	#NSSIFloat
.12a9	d0 02		bne $12ad			bne 	_CVNotFloat
.12ab	a2 06		ldx #$06			ldx 	#6
.12ad					_CVNotFloat:
.12ad	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.12ae	18		clc				clc
.12af	6d 13 05	adc $0513			adc 	freeVariableMemory
.12b2	8d 13 05	sta $0513			sta 	freeVariableMemory
.12b5	90 03		bcc $12ba			bcc 	_CVNoCarry1
.12b7	ee 14 05	inc $0514			inc 	freeVariableMemory+1
.12ba					_CVNoCarry1:
.12ba	fa		plx				plx
.12bb	68		pla				pla
.12bc	60		rts				rts
.12bd					CommandDATA:
.12bd	20 30 11	jsr $1130			jsr 	BufferClear 				; copy it to the buffer
.12c0	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace
.12c3					_CTDataLoop:
.12c3	20 4c 1a	jsr $1a4c			jsr 	LookNext 					; reached EOL
.12c6	f0 08		beq $12d0			beq 	_CTDataDone
.12c8	20 34 11	jsr $1134			jsr 	BufferWrite 				; write and consume
.12cb	20 5d 1a	jsr $1a5d			jsr 	GetNext
.12ce	80 f3		bra $12c3			bra 	_CTDataLoop
.12d0					_CTDataDone:
.12d0	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.12d2	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.12d5	20 40 11	jsr $1140			jsr 	BufferOutput
.12d8	60		rts				rts
.12d9					CommandDEF:
.12d9	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.12db	20 1a 12	jsr $121a			jsr 	PushIntegerA
.12de	20 6d 1b	jsr $1b6d			jsr 	CompileGotoEOL 				; compile skip over DEF
.12e1	a9 a5		lda #$a5			lda 	#C64_FN
.12e3	20 61 11	jsr $1161			jsr 	CheckNextA
.12e6	20 68 1a	jsr $1a68			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.12e9	20 cd 1a	jsr $1acd			jsr 	ExtractVariableName
.12ec	8a		txa				txa
.12ed	10 51		bpl $1340			bpl 	_CDError
.12ef	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.12f0	29 7f		and #$7f			and 	#$7F
.12f2	aa		tax				tax
.12f3	98		tya				tya
.12f4	09 80		ora #$80			ora 	#$80
.12f6	a8		tay				tay
.12f7	20 c2 14	jsr $14c2			jsr 	FindVariable				; does it already exist ?
.12fa	b0 44		bcs $1340			bcs 	_CDError 					; if so, that's an error.
.12fc	20 4c 12	jsr $124c			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.12ff	20 91 12	jsr $1291			jsr 	SetVariableRecordToCodePosition
.1302	20 68 1a	jsr $1a68			jsr 	GetNextNonSpace
.1305	20 a9 1d	jsr $1da9			jsr 	GetReferenceTerm 			; get var ref, not array
.1308	c9 00		cmp #$00			cmp 	#0
.130a	30 34		bmi $1340			bmi 	_CDError
.130c	8d 09 05	sta $0509			sta 	defType 					; save type
.130f	8e 0a 05	stx $050a			stx 	defVariable 				; save var ref
.1312	8c 0b 05	sty $050b			sty 	defVariable+1
.1315	29 40		and #$40			and 	#NSSString 					; only numbers.
.1317	d0 27		bne $1340			bne 	_CDError
.1319	20 5b 11	jsr $115b			jsr 	CheckNextRParen 			; check )
.131c	a9 b2		lda #$b2			lda 	#C64_EQUAL
.131e	20 61 11	jsr $1161			jsr 	CheckNextA 					; check =
.1321	18		clc				clc 								; if this is DEF FNxx(A), read A
.1322	20 43 13	jsr $1343			jsr 	CDReadWriteVariable
.1325	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1327	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.132a	38		sec				sec
.132b	20 43 13	jsr $1343			jsr 	CDReadWriteVariable 		; A is now updated
.132e	20 08 14	jsr $1408			jsr 	CompileExpressionAt0 		; the actual body of the function.
.1331	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1333	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1336	38		sec				sec
.1337	20 43 13	jsr $1343			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.133a	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.133c	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.133f	60		rts				rts
.1340					_CDError:
.1340	4c 47 1f	jmp $1f47		jmp	ErrorV_syntax
.1343					CDReadWriteVariable:
.1343	ac 0b 05	ldy $050b			ldy 	defVariable+1 				; set up YX
.1346	ae 0a 05	ldx $050a			ldx 	defVariable
.1349	ad 09 05	lda $0509			lda 	defType
.134c	20 5b 1d	jsr $1d5b			jsr 	GetSetVariable
.134f	60		rts				rts
.0509					defType:
>0509							.fill 	1
.050a					defVariable:
>050a							.fill 	2
.1350					CommandDIM:
.1350	20 68 1a	jsr $1a68			jsr 	GetNextNonSpace 			; get the first non space character
.1353	20 cd 1a	jsr $1acd			jsr 	ExtractVariableName 		; variable name to XY
.1356	da		phx				phx 								; save name with type bits.
.1357	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.1359	10 37		bpl $1392			bpl 	_CDError
.135b	20 c2 14	jsr $14c2			jsr 	FindVariable	 			; see if already exist
.135e	b0 35		bcs $1395			bcs 	_CDRedefine 				; it still exists.
.1360	20 4c 12	jsr $124c			jsr 	CreateVariableRecord 		; create the basic variable
.1363	20 a1 12	jsr $12a1			jsr 	AllocateBytesForType 		; allocate memory for it
.1366	68		pla				pla 								; restore type bits
.1367	5a		phy				phy 								; save the address of the basic storage
.1368	da		phx				phx
.1369	48		pha				pha
.136a	20 98 13	jsr $1398			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.136d	68		pla				pla
.136e	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.1370	20 1a 12	jsr $121a			jsr 	PushIntegerA 				; push that type data out.
.1373	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.1375	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1378	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.137a	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.137d	fa		plx				plx 								; restore address
.137e	7a		ply				ply
.137f	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1381	38		sec				sec
.1382	20 5b 1d	jsr $1d5b			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.1385	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; , follows ?
.1388	c9 2c		cmp #$2c			cmp 	#","
.138a	d0 05		bne $1391			bne 	_CDExit
.138c	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume comma
.138f	80 bf		bra $1350			bra 	CommandDIM 					; do another DIM
.1391					_CDExit:
.1391	60		rts				rts
.1392					_CDError:
.1392	4c 47 1f	jmp $1f47		jmp	ErrorV_syntax
.1395					_CDRedefine:
.1395	4c 0f 20	jmp $200f		jmp	ErrorV_redefine
.1398					OutputIndexGroup:
.1398	9c 0c 05	stz $050c			stz 	IndexCount 					; count of number of indices.
.139b					_OIGNext:
.139b	20 08 14	jsr $1408			jsr 	CompileExpressionAt0 		; get a dimension
.139e	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.13a0	c9 00		cmp #$00			cmp 	#NSSIFloat
.13a2	d0 19		bne $13bd			bne 	_OIGType
.13a4	ee 0c 05	inc $050c			inc 	IndexCount 					; bump the counter.
.13a7	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; does a , follow ?
.13aa	c9 2c		cmp #$2c			cmp 	#","
.13ac	d0 05		bne $13b3			bne 	_OIGCheckEnd
.13ae	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume comma
.13b1	80 e8		bra $139b			bra 	_OIGNext 					; get next dimension
.13b3					_OIGCheckEnd:
.13b3	20 5b 11	jsr $115b			jsr 	CheckNextRParen 			; check and consume )
.13b6	ad 0c 05	lda $050c			lda 	IndexCount
.13b9	20 1a 12	jsr $121a			jsr 	PushIntegerA 				; compile the dimension count.
.13bc	60		rts				rts
.13bd					_OIGType:
.13bd	4c 57 1f	jmp $1f57		jmp	ErrorV_type
.050c					IndexCount:
>050c							.fill 	1
.13c0					ErrorHandler:
.13c0	68		pla				pla
.13c1	7a		ply				ply
.13c2	85 2a		sta $2a				sta 	zTemp0
.13c4	84 2b		sty $2b				sty 	zTemp0+1
.13c6	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.13c8	a0 01		ldy #$01			ldy 	#1
.13ca					_EHDisplayMsg:
.13ca	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.13cc	20 06 11	jsr $1106			jsr 	PrintCharacter
.13cf	c8		iny				iny
.13d0	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.13d2	d0 f6		bne $13ca			bne 	_EHDisplayMsg
.13d4	a9 20		lda #$20			lda 	#32
.13d6	20 06 11	jsr $1106			jsr 	PrintCharacter
.13d9	a9 40		lda #$40			lda 	#64
.13db	20 06 11	jsr $1106			jsr 	PrintCharacter
.13de	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.13e0	20 8f 26	jsr $268f			jsr 	FloatSetByte
.13e3	20 f2 10	jsr $10f2			jsr 	GetLineNumber
.13e6	95 3c		sta $3c,x			sta 	NSMantissa0,x
.13e8	98		tya				tya
.13e9	95 48		sta $48,x			sta 	NSMantissa1,x
.13eb	20 75 25	jsr $2575			jsr 	FloatToString
.13ee	a0 00		ldy #$00			ldy 	#0 							; display that string.
.13f0	a2 00		ldx #$00			ldx 	#0
.13f2					_EHDisplayLine:
.13f2	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13f5	20 06 11	jsr $1106			jsr 	PrintCharacter
.13f8	c8		iny				iny
.13f9	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13fc	d0 f4		bne $13f2			bne 	_EHDisplayLine
.13fe	a9 0d		lda #$0d			lda 	#13
.1400	20 06 11	jsr $1106			jsr 	PrintCharacter
.1403	80 fe		bra $1403	_EHHalt:bra 	_EHHalt
.1405	4c ff 11	jmp $11ff			jmp 	ExitCompiler
.1408					CompileExpressionAt0:
.1408	a9 00		lda #$00			lda 	#0
.140a					CompileExpressionAtA:
.140a	48		pha				pha  								; save level
.140b	20 14 1e	jsr $1e14			jsr 	CompileTerm 				; compile a term.
.140e	fa		plx				plx 								; get level back into X
.140f					_ECALoop:
.140f	48		pha				pha 								; save type on stack.
.1410	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; get the next character
.1413	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.1415	90 04		bcc $141b			bcc 	_ECAExit
.1417	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.1419	90 02		bcc $141d			bcc 	_ECAHaveToken
.141b					_ECAExit:
.141b	68		pla				pla 								; throw type off stack
.141c	60		rts				rts
.141d					_ECAHaveToken:
.141d	86 2a		stx $2a				stx 	zTemp0 						; save current precedence in zTemp0
.141f	aa		tax				tax 								; X contains the operator token
.1420	bd 0b 14	lda $140b,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.1423	c5 2a		cmp $2a				cmp 	zTemp0 						; if < then exit
.1425	90 f4		bcc $141b			bcc 	_ECAExit
.1427	85 2b		sta $2b				sta 	zTemp0+1 					; save the precedence of the operator.
.1429	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume the token.
.142c	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.142e	f0 11		beq $1441			beq 	_ECAGreaterCheck
.1430	e0 b3		cpx #$b3			cpx 	#C64_LESS
.1432	d0 1a		bne $144e			bne 	_ECAHaveFullToken
.1434	20 4c 1a	jsr $1a4c			jsr 	LookNext 					; checks for < (<= or <>)
.1437	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.1439	f0 0e		beq $1449			beq	 	_ECAToNotEqual
.143b	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.143d	d0 0f		bne $144e			bne 	_ECAHaveFullToken
.143f	80 07		bra $1448			bra 	_ECAAddEqual
.1441					_ECAGreaterCheck:
.1441	20 4c 1a	jsr $1a4c			jsr 	LookNext
.1444	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.1446	d0 06		bne $144e			bne 	_ECAHaveFullToken
.1448					_ECAAddEqual:
.1448	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.1449					_ECAToNotEqual:
.1449	e8		inx				inx
.144a	e8		inx				inx
.144b	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume the = or > in >= <= <>
.144e					_ECAHaveFullToken:
.144e	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.1450	d0 0a		bne $145c			bne 	_ECANotConcat
.1452	68		pla				pla 								; get type back
.1453	48		pha				pha
.1454	29 40		and #$40			and 	#NSSTypeMask
.1456	c9 40		cmp #$40			cmp 	#NSSString
.1458	d0 02		bne $145c			bne 	_ECANotConcat
.145a	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.145c					_ECANotConcat:
.145c	da		phx				phx 								; save operator on the stack
.145d	a6 2a		ldx $2a				ldx 	zTemp0 						; push current precedence on the stack
.145f	da		phx				phx
.1460	a5 2b		lda $2b				lda 	zTemp0+1 					; get precedence of operator
.1462	1a		inc a				inc 	a
.1463	20 0a 14	jsr $140a			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.1466	85 2a		sta $2a				sta 	zTemp0 						; save type in zTemp0
.1468	fa		plx				plx 								; restore current precedence in X
.1469	68		pla				pla 								; restore operator
.146a	85 2b		sta $2b				sta 	zTemp0+1 					; save it in zTemp0+1.
.146c	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.146e	90 17		bcc $1487			bcc 	_ECANotCompare
.1470	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.1472	b0 13		bcs $1487			bcs 	_ECANotCompare
.1474	7a		ply				ply 								; get type into Y
.1475	5a		phy				phy
.1476	48		pha				pha 								; save operator
.1477	98		tya				tya 								; get type
.1478	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.147a	29 40		and #$40			and 	#NSSTypeMask
.147c	c9 40		cmp #$40			cmp 	#NSSString
.147e	f0 02		beq $1482			beq 	_ECANotString
.1480	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.1482					_ECANotString:
.1482	98		tya				tya									; output token Y
.1483	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1486	68		pla				pla 								; restore operator.
.1487					_ECANotCompare:
.1487	18		clc				clc 								; convert to P-Code and compile.
.1488	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.148a	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.148d	68		pla				pla 								; type of current result
.148e	45 2a		eor $2a				eor 	zTemp0 						; check compatible with r-expr type
.1490	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.1492	d0 19		bne $14ad			bne		_ECAType
.1494	a5 2a		lda $2a				lda 	zTemp0 						; get type back
.1496	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.1498	d0 18		bne $14b2			bne 	_ECAGoLoop
.149a	a5 2b		lda $2b				lda 	zTemp0+1 					; check operator is + or comparator
.149c	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.149e	f0 10		beq $14b0			beq 	_ECAOkayString 				; (this is post conversion)
.14a0	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.14a2	90 09		bcc $14ad			bcc 	_ECAType
.14a4	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.14a6	b0 05		bcs $14ad			bcs 	_ECAType
.14a8	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.14aa	4c 0f 14	jmp $140f			jmp 	_ECALoop
.14ad					_ECAType:
.14ad	4c 57 1f	jmp $1f57		jmp	ErrorV_type
.14b0					_ECAOkayString:
.14b0	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.14b2					_ECAGoLoop:
.14b2	4c 0f 14	jmp $140f			jmp 	_ECALoop
.14b5					PrecedenceTable:
>14b5	03						.byte 	3 					; '+'
>14b6	03						.byte 	3 					; '-'
>14b7	04						.byte 	4 					; '*'
>14b8	04						.byte 	4 					; '/'
>14b9	05						.byte 	5 					; '^'
>14ba	01						.byte 	1 					; 'and'
>14bb	00						.byte 	0 					; 'or'
>14bc	02						.byte 	2 					; '>'
>14bd	02						.byte 	2 					; '='
>14be	02						.byte 	2 					; '<'
>14bf	02						.byte 	2 					; '>='
>14c0	02						.byte 	2 					; '<='
>14c1	02						.byte 	2 					; '<>'
.14c2					FindVariable:
.14c2	86 2c		stx $2c				stx 	zTemp1 						; save name.
.14c4	84 2d		sty $2d				sty 	zTemp1+1
.14c6					_IVCheckSpecial:
.14c6	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.14c8	d0 18		bne $14e2			bne 	_IVStandard
.14ca	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.14cc	f0 0c		beq $14da			beq 	_IVTIFloat
.14ce	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.14d0	d0 10		bne $14e2			bne 	_IVStandard
.14d2	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.14d4	a2 01		ldx #$01			ldx 	#$01
.14d6	a9 40		lda #$40			lda 	#NSSString
.14d8	38		sec				sec
.14d9	60		rts				rts
.14da					_IVTIFloat:
.14da	a0 80		ldy #$80			ldy 	#$80
.14dc	a2 00		ldx #$00			ldx 	#$00
.14de	a9 00		lda #$00			lda 	#0
.14e0	38		sec				sec
.14e1	60		rts				rts
.14e2					_IVStandard:
.14e2	ad 07 05	lda $0507			lda 	compilerStartHigh			; start scanning from here.
.14e5	85 2b		sta $2b				sta 	zTemp0+1
.14e7	64 2a		stz $2a				stz 	zTemp0
.14e9					_IVCheckLoop:
.14e9	b2 2a		lda ($2a)			lda 	(zTemp0) 					; finished ?
.14eb	f0 2b		beq $1518			beq  	_IVNotFound 				; if so, return with CC.
.14ed	a0 01		ldy #$01			ldy 	#1 							; match ?
.14ef	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14f1	c5 2c		cmp $2c				cmp 	zTemp1
.14f3	d0 07		bne $14fc			bne	 	_IVNext
.14f5	c8		iny				iny
.14f6	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14f8	c5 2d		cmp $2d				cmp 	zTemp1+1
.14fa	f0 0d		beq $1509			beq 	_IVFound
.14fc					_IVNext:
.14fc	18		clc				clc
.14fd	a5 2a		lda $2a				lda 	zTemp0
.14ff	72 2a		adc ($2a)			adc 	(zTemp0)
.1501	85 2a		sta $2a				sta 	zTemp0
.1503	90 e4		bcc $14e9			bcc 	_IVCheckLoop
.1505	e6 2b		inc $2b				inc 	zTemp0+1
.1507	80 e0		bra $14e9			bra 	_IVCheckLoop
.1509					_IVFound:
.1509	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.150b	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.150d	aa		tax				tax
.150e	c8		iny				iny
.150f	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1511	48		pha				pha
.1512	c8		iny				iny
.1513	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1515	7a		ply				ply
.1516	38		sec				sec
.1517	60		rts				rts
.1518					_IVNotFound:
.1518	a6 2c		ldx $2c				ldx 	zTemp1 						; get variable name back
.151a	a4 2d		ldy $2d				ldy 	zTemp1+1
.151c	18		clc				clc
.151d	60		rts				rts
.151e					FixBranches:
.151e	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.1520	20 04 12	jsr $1204			jsr 	CallAPIHandler
.1523					_FBLoop:
.1523	b2 28		lda ($28)			lda 	(objPtr) 					; get the next one.
.1525	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.1527	f0 16		beq $153f			beq 	_FBFixGotoGosub
.1529	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.152b	f0 12		beq $153f			beq 	_FBFixGotoGosub
.152d	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.152f	f0 0e		beq $153f			beq 	_FBFixGotoGosub
.1531	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1533	f0 0a		beq $153f			beq 	_FBFixGotoGosub
.1535	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.1537	f0 3b		beq $1574			beq 	_FBFixVarSpace
.1539					_FBNext:
.1539	20 5c 20	jsr $205c			jsr 	MoveObjectForward 			; move forward in object code.
.153c	90 e5		bcc $1523			bcc 	_FBLoop 					; not finished
.153e					_FBExit:
.153e	60		rts				rts
.153f					_FBFixGotoGosub:
.153f	a0 01		ldy #$01			ldy 	#1							; line number in YA
.1541	b1 28		lda ($28),y			lda 	(objPtr),y
.1543	48		pha				pha
.1544	c8		iny				iny
.1545	b1 28		lda ($28),y			lda 	(objPtr),y
.1547	a8		tay				tay
.1548	68		pla				pla
.1549	20 ff 1b	jsr $1bff			jsr 	STRFindLine			 		; find where it is YA
.154c	90 08		bcc $1556			bcc 	_FBFFound 					; not found, so must be >
.154e	48		pha				pha
.154f	b2 28		lda ($28)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.1551	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1553	d0 0f		bne $1564			bne 	_FBFFail
.1555	68		pla				pla
.1556					_FBFFound:
.1556	20 4f 1c	jsr $1c4f			jsr 	STRMakeOffset 				; make it an offset from X:YA
.1559	5a		phy				phy	 								; patch the GOTO/GOSUB
.155a	a0 01		ldy #$01			ldy 	#1
.155c	91 28		sta ($28),y			sta 	(objPtr),y
.155e	c8		iny				iny
.155f	68		pla				pla
.1560	91 28		sta ($28),y			sta 	(objPtr),y
.1562	80 d5		bra $1539			bra 	_FBNext
.1564					_FBFFail:
.1564	a0 02		ldy #$02			ldy 	#2
.1566	b1 28		lda ($28),y			lda 	(objPtr),y
.1568	8d 00 04	sta $0400			sta 	currentLineNumber
.156b	c8		iny				iny
.156c	b1 28		lda ($28),y			lda 	(objPtr),y
.156e	8d 01 04	sta $0401			sta 	currentLineNumber+1
.1571	4c 8a 1f	jmp $1f8a		jmp	ErrorV_line
.1574					_FBFixVarSpace:
.1574	a0 01		ldy #$01			ldy 	#1
.1576	ad 13 05	lda $0513			lda 	freeVariableMemory
.1579	91 28		sta ($28),y			sta 	(objPtr),y
.157b	c8		iny				iny
.157c	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.157f	91 28		sta ($28),y			sta 	(objPtr),y
.1581	80 b6		bra $1539			bra 	_FBNext
.1583					CommandFOR:
.1583	20 68 1a	jsr $1a68			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.1586	20 7e 1a	jsr $1a7e			jsr 	CharIsAlpha 				; if not alpha , error
.1589	90 59		bcc $15e4			bcc 	_CFFail
.158b	20 a9 1d	jsr $1da9			jsr 	GetReferenceTerm 			; figure out the reference.
.158e	48		pha				pha 								; save type
.158f	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1591	c9 00		cmp #$00			cmp 	#NSSIFloat
.1593	d0 4f		bne $15e4			bne 	_CFFail
.1595	5a		phy				phy 								; save reference on the stack
.1596	da		phx				phx
.1597	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.1599	20 61 11	jsr $1161			jsr 	CheckNextA
.159c	20 08 14	jsr $1408			jsr 	CompileExpressionAt0 		; initial value
.159f	fa		plx				plx 								; get reference back.
.15a0	7a		ply				ply
.15a1	5a		phy				phy
.15a2	da		phx				phx
.15a3	38		sec				sec 								; set initial value.
.15a4	20 5b 1d	jsr $1d5b			jsr 	GetSetVariable
.15a7	fa		plx				plx
.15a8	7a		ply				ply
.15a9	68		pla				pla
.15aa	29 20		and #$20			and 	#NSSIInt16
.15ac	f0 04		beq $15b2			beq 	_CFNotInt16
.15ae	98		tya				tya
.15af	09 80		ora #$80			ora 	#$80
.15b1	a8		tay				tay
.15b2					_CFNotInt16:
.15b2	8a		txa				txa 								; reference in YA
.15b3	20 07 12	jsr $1207			jsr 	PushIntegerYA
.15b6	a9 a4		lda #$a4			lda 	#C64_TO
.15b8	20 61 11	jsr $1161			jsr 	CheckNextA
.15bb	20 08 14	jsr $1408			jsr 	CompileExpressionAt0 		; terminal value
.15be	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15c0	c9 00		cmp #$00			cmp 	#NSSIFloat
.15c2	d0 20		bne $15e4			bne 	_CFFail
.15c4	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; followed by STEP
.15c7	c9 a9		cmp #$a9			cmp 	#C64_STEP
.15c9	d0 0e		bne $15d9			bne 	_CFNoStep
.15cb	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume it.
.15ce	20 08 14	jsr $1408			jsr 	CompileExpressionAt0 		; terminal value
.15d1	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15d3	c9 00		cmp #$00			cmp 	#NSSIFloat
.15d5	d0 0d		bne $15e4			bne 	_CFFail
.15d7	80 05		bra $15de			bra 	_CFParametersDone
.15d9					_CFNoStep:
.15d9	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.15db	20 1a 12	jsr $121a			jsr 	PushIntegerA
.15de					_CFParametersDone:
.15de	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.15e0	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.15e3	60		rts				rts
.15e4					_CFFail:
.15e4	4c 47 1f	jmp $1f47		jmp	ErrorV_syntax
.15e7					FNCompile:
.15e7	20 68 1a	jsr $1a68			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.15ea	20 cd 1a	jsr $1acd			jsr 	ExtractVariableName
.15ed	e0 00		cpx #$00			cpx 	#0
.15ef	10 32		bpl $1623			bpl 	_FNError
.15f1	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.15f2	29 7f		and #$7f			and 	#$7F
.15f4	aa		tax				tax
.15f5	98		tya				tya
.15f6	09 80		ora #$80			ora 	#$80
.15f8	a8		tay				tay
.15f9	20 c2 14	jsr $14c2			jsr 	FindVariable				; does it already exist ?
.15fc	90 25		bcc $1623			bcc 	_FNError 					; no.
.15fe	20 4f 1c	jsr $1c4f			jsr 	STRMakeOffset 				; convert to a relative address.
.1601	c9 00		cmp #$00			cmp 	#0 							; fix up.
.1603	d0 01		bne $1606			bne 	_FNNoBorrow
.1605	88		dey				dey
.1606					_FNNoBorrow:
.1606	3a		dec a				dec 	a
.1607	5a		phy				phy 								; save location of routine on stack.
.1608	48		pha				pha
.1609	da		phx				phx
.160a	20 08 14	jsr $1408			jsr 	CompileExpressionAt0
.160d	20 5b 11	jsr $115b			jsr 	CheckNextRParen
.1610	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1612	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1615	68		pla				pla
.1616	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1619	68		pla				pla
.161a	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.161d	68		pla				pla
.161e	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1621	18		clc				clc
.1622	60		rts				rts
.1623					_FNError:
.1623	4c 3a 1f	jmp $1f3a		jmp	ErrorV_value
.1626					CommandTables:
>1626	07 cb 00 03 2b 1b 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>162d	07 89 00 03 32 1b 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>1634	07 8d 00 03 25 1b 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>163b	07 88 00 03 a1 1b 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>1642	07 85 00 03 81 1b 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>1649	07 84 00 04 95 1b 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>1650	07 99 00 03 d6 1c 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1657	07 98 00 04 d6 1c 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>165e	07 8f 00 03 e1 1d 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>1665	07 81 00 03 83 15 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>166c	07 82 00 03 59 1c 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>1673	07 a1 00 03 9e 1a 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>167a	07 83 00 03 bd 12 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>1681	07 87 00 03 1f 1d 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>1688	07 86 00 03 50 13 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>168f	07 96 00 03 d9 12 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>1696	07 8b 00 e3 4e 1b 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>169d	08 92 00 ea e3 ad 1e 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>16a5	09 91 00 e1 a9 03 85 1c			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>16ad	06
>16ae	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>16b5	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>16bc	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>16c2	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>16c9	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>16d0	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>16d7	07 9d 00 e3 d3 1e 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>16de	0a 9f 00 ea e3 e6 1e 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>16e6	c6 06
>16e8	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>16ee	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>16f5	0a ce 92 e3 1b 1a 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>16fd	ad 06
>16ff	0a ce 8d e3 1b 1a 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>1707	ae 06
>1709	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>170f	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>1717	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>171e	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>1725	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>172d	06
>172e	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>1736	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>173e	9a 06
>1740	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>1748	9b 06
>174a	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>1752	9c 06
>1754	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>175c	06
>175d	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>1764	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>176c	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>1774	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>177c	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>1784	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>178c	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>1794	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>179c	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>17a4	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>17ac	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>17b4	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>17bb	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>17c3	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>17cb	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>17d3	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>17db	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>17e3	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>17eb	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>17f3	00						.byte 	0
.17f4					UnaryTables:
>17f4	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>17fb	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>1803	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>180a	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>1811	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>1818	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>181f	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>1827	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>182e	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>1836	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>183e	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>1846	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>184e	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>1856	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>185e	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>1865	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>186c	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>1873	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>187a	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>1881	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>1888	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>1890	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>1898	0b ca 00 8f ae 03 1b 1a			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>18a0	91 bd 07
>18a3	07 a8 00 03 3a 1a 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>18aa	07 a5 00 03 e7 15 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>18b1	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>18b8	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>18bf	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>18c7	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>18cf	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>18d6	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>18dd	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>18e4	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>18ec	06
>18ed	00						.byte 	0
.18ee					GeneratorProcess:
.18ee	86 2a		stx $2a				stx 	zTemp0 						; save generation pointer in zTemp0
.18f0	84 2b		sty $2b				sty 	zTemp0+1
.18f2	85 2c		sta $2c				sta 	zTemp1 						; first match token
.18f4	64 2d		stz $2d				stz 	zTemp1+1
.18f6	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.18f8	d0 05		bne $18ff			bne 	_GPNotShifted
.18fa	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; get the shifted token
.18fd	85 2d		sta $2d				sta 	zTemp1+1 					; match CE xx
.18ff					_GPNotShifted:
.18ff					_GPSearch:
.18ff	b2 2a		lda ($2a)			lda 	(zTemp0) 					; reached end ?
.1901	18		clc				clc
.1902	f0 2f		beq $1933			beq 	_GPExit
.1904	a0 01		ldy #$01			ldy 	#1 							; tokens match
.1906	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1908	c5 2c		cmp $2c				cmp 	zTemp1
.190a	d0 09		bne $1915			bne 	_GPNext
.190c	a5 2d		lda $2d				lda 	zTemp1+1 					; 2nd token ?
.190e	f0 12		beq $1922			beq 	_GPFound
.1910	c8		iny				iny 								; check match.
.1911	d1 2a		cmp ($2a),y			cmp 	(zTemp0),y
.1913	f0 0d		beq $1922			beq 	_GPFound
.1915					_GPNext:
.1915	18		clc				clc 								; follow to next
.1916	a5 2a		lda $2a				lda 	zTemp0
.1918	72 2a		adc ($2a)			adc 	(zTemp0)
.191a	85 2a		sta $2a				sta 	zTemp0
.191c	90 e1		bcc $18ff			bcc 	_GPSearch
.191e	e6 2b		inc $2b				inc 	zTemp0+1
.1920	80 dd		bra $18ff			bra 	_GPSearch
.1922					_GPFound:
.1922	18		clc				clc 								; skip to action bytes
.1923	a5 2a		lda $2a				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.1925	69 03		adc #$03			adc 	#3
.1927	85 2a		sta $2a				sta 	zTemp0
.1929	90 02		bcc $192d			bcc 	_GPNoCarry
.192b	e6 2b		inc $2b				inc 	zTemp0+1
.192d					_GPNoCarry:
.192d					_GPLoop:
.192d	20 34 19	jsr $1934			jsr 	GeneratorExecute 			; execute one command
.1930	90 fb		bcc $192d			bcc 	_GPLoop 					; go back if not completed.
.1932	38		sec				sec 								; return with CS.
.1933					_GPExit:
.1933	60		rts				rts
.1934					GeneratorExecute:
.1934	20 e0 19	jsr $19e0			jsr 	_GEFetchZTemp0 				; get next.
.1937	48		pha				pha 								; split into 2 nibbles
.1938	4a		lsr a				lsr 	a
.1939	4a		lsr a				lsr 	a
.193a	4a		lsr a				lsr		a
.193b	4a		lsr a				lsr 	a
.193c	20 46 19	jsr $1946			jsr 	_GEExecuteNibble 			; MSB first
.193f	68		pla				pla
.1940	b0 03		bcs $1945			bcs 	_GEHaveCompleted
.1942	20 46 19	jsr $1946			jsr 	_GEExecuteNibble 			; LSB second
.1945					_GEHaveCompleted:
.1945	60		rts				rts
.1946					_GEExecuteNibble:
.1946	29 0f		and #$0f			and 	#$0F
.1948	0a		asl a				asl 	a
.1949	aa		tax				tax
.194a	7c 4d 19	jmp ($194d,x)			jmp 	(_GEExecuteVectors,x)
.194d					_GEExecuteVectors:
>194d	6d 19						.word 	_GEXNop 					; 0  (no operation)
>194f	75 19						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>1951	6f 19						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>1953	c3 19						.word 	_GEXExecute 				; 3  (run arbitrary code)
>1955	b6 19						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>1957	6d 19						.word 	_GEXNop 					; 5
>1959	7d 19						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>195b	81 19						.word 	_GEXExitString 				; 7  exit return string type
>195d	85 19						.word 	_GEXLParam 					; 8  check ( follows
>195f	89 19						.word 	_GEXRParam 					; 9  check ) follows
>1961	8d 19						.word 	_GEXComma					; A  check , follows
>1963	6d 19						.word 	_GEXNop 					; B
>1965	6d 19						.word 	_GEXNop 					; C
>1967	6d 19						.word 	_GEXNop 					; D
>1969	9d 19						.word 	_GEXNumber 					; E  compile get any number
>196b	a8 19						.word 	_GEXString 					; F  compile get any string
.196d					_GEXNop:
.196d	18		clc				clc
.196e	60		rts				rts
.196f					_GEXToken2:
.196f	20 e0 19	jsr $19e0			jsr 	_GEFetchZTemp0
.1972	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1975					_GEXToken1:
.1975	20 e0 19	jsr $19e0			jsr 	_GEFetchZTemp0
.1978	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.197b	18		clc				clc
.197c	60		rts				rts
.197d					_GEXExitNumber:
.197d	a9 00		lda #$00			lda 	#NSSIFloat
.197f	38		sec				sec
.1980	60		rts				rts
.1981					_GEXExitString:
.1981	a9 40		lda #$40			lda 	#NSSString
.1983	38		sec				sec
.1984	60		rts				rts
.1985					_GEXLParam:
.1985	a9 28		lda #$28			lda 	#"("
.1987	80 06		bra $198f			bra 	_GEXCheck
.1989					_GEXRParam:
.1989	a9 29		lda #$29			lda 	#")"
.198b	80 02		bra $198f			bra 	_GEXCheck
.198d					_GEXComma:
.198d	a9 2c		lda #$2c			lda 	#","
.198f					_GEXCheck:
.198f	85 2e		sta $2e				sta 	zTemp2 						; save match
.1991	20 68 1a	jsr $1a68			jsr 	GetNextNonSpace 			; get next skipping spaces
.1994	c5 2e		cmp $2e				cmp 	zTemp2 						; check matches.
.1996	d0 02		bne $199a			bne 	_GEXSyntax
.1998	18		clc				clc
.1999	60		rts				rts
.199a					_GEXSyntax:
.199a	4c 47 1f	jmp $1f47		jmp	ErrorV_syntax
.199d					_GEXNumber:
.199d	20 e9 19	jsr $19e9			jsr 	GEXCompileExpression 		; compile expression
.19a0	29 40		and #$40			and 	#NSSTypeMask
.19a2	c9 00		cmp #$00			cmp  	#NSSIFloat
.19a4	d0 0d		bne $19b3			bne 	_GEXType
.19a6	18		clc				clc
.19a7	60		rts				rts
.19a8					_GEXString:
.19a8	20 e9 19	jsr $19e9			jsr 	GEXCompileExpression 		; compile expression
.19ab	29 40		and #$40			and 	#NSSTypeMask
.19ad	c9 40		cmp #$40			cmp  	#NSSString
.19af	d0 02		bne $19b3			bne 	_GEXType
.19b1	18		clc				clc
.19b2	60		rts				rts
.19b3					_GEXType:
.19b3	4c 57 1f	jmp $1f57		jmp	ErrorV_type
.19b6					_GEXChannelExec:
.19b6	20 f9 19	jsr $19f9			jsr 	ChannelPrefix 				; set up default
.19b9	20 c3 19	jsr $19c3			jsr 	_GEXExecute
.19bc	08		php				php
.19bd	20 14 1a	jsr $1a14			jsr 	ChannelPostfix 				; replace default.
.19c0	28		plp				plp
.19c1	60		rts				rts
>19c2	db						.byte 	$DB 						; causes a break in the emulator
.19c3					_GEXExecute:
.19c3	20 e0 19	jsr $19e0			jsr 	_GEFetchZTemp0 				; get vector
.19c6	85 2e		sta $2e				sta 	zTemp2
.19c8	20 e0 19	jsr $19e0			jsr 	_GEFetchZTemp0
.19cb	85 2f		sta $2f				sta 	zTemp2+1
.19cd	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19cf	da		phx				phx
.19d0	a6 2b		ldx $2b				ldx 	zTemp0+1
.19d2	da		phx				phx
.19d3	20 dd 19	jsr $19dd			jsr 	_GECallZTemp2 				; execute code
.19d6	fa		plx				plx 								; recover generation exec
.19d7	86 2b		stx $2b				stx 	zTemp0+1
.19d9	fa		plx				plx
.19da	86 2a		stx $2a				stx 	zTemp0
.19dc	60		rts				rts
.19dd					_GECallZTemp2:
.19dd	6c 2e 00	jmp ($002e)			jmp 	(zTemp2)
.19e0					_GEFetchZTemp0:
.19e0	b2 2a		lda ($2a)			lda 	(zTemp0)
.19e2	e6 2a		inc $2a				inc 	zTemp0
.19e4	d0 02		bne $19e8			bne 	_GEFZ0Skip
.19e6	e6 2b		inc $2b				inc 	zTemp0+1
.19e8					_GEFZ0Skip:
.19e8	60		rts				rts
.19e9					GEXCompileExpression:
.19e9	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19eb	da		phx				phx
.19ec	a6 2b		ldx $2b				ldx 	zTemp0+1
.19ee	da		phx				phx
.19ef	20 08 14	jsr $1408			jsr 	CompileExpressionAt0 		; compile expression.
.19f2	fa		plx				plx 								; recover generation exec
.19f3	86 2b		stx $2b				stx 	zTemp0+1
.19f5	fa		plx				plx
.19f6	86 2a		stx $2a				stx 	zTemp0
.19f8	60		rts				rts
.19f9					ChannelPrefix:
.19f9	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.19fb	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.19fe	20 e9 19	jsr $19e9			jsr 	GEXCompileExpression 		; channel #
.1a01	29 40		and #$40			and 	#NSSTypeMask
.1a03	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a05	d0 0a		bne $1a11			bne 	_CPXType
.1a07	20 57 11	jsr $1157			jsr 	CheckNextComma 				; check , follows.
.1a0a	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.1a0c	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1a0f	18		clc				clc
.1a10	60		rts				rts
.1a11					_CPXType:
.1a11	4c 57 1f	jmp $1f57		jmp	ErrorV_type
.1a14					ChannelPostfix:
.1a14	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.1a16	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1a19	18		clc				clc
.1a1a	60		rts				rts
.1a1b					OptionalParameterCompile:
.1a1b	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; what follows.
.1a1e	c9 2c		cmp #$2c			cmp 	#","
.1a20	d0 0e		bne $1a30			bne 	_MidDefault
.1a22	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume ,
.1a25	20 08 14	jsr $1408			jsr 	CompileExpressionAt0
.1a28	29 40		and #$40			and 	#NSSTypeMask
.1a2a	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a2c	d0 09		bne $1a37			bne 	MidFailType
.1a2e	80 05		bra $1a35			bra 	_MidComplete
.1a30					_MidDefault:
.1a30	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1a32	20 1a 12	jsr $121a			jsr 	PushIntegerA
.1a35					_MidComplete:
.1a35	18		clc				clc
.1a36	60		rts				rts
.1a37					MidFailType:
.1a37	4c 57 1f	jmp $1f57		jmp	ErrorV_type
.1a3a					NotUnaryCompile:
.1a3a	ad bd 14	lda $14bd			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1a3d	20 0a 14	jsr $140a			jsr 	CompileExpressionAtA 		; evaluate at that level
.1a40	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1a42	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a44	d0 f1		bne $1a37			bne 	MidFailType
.1a46	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1a48	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1a4b	60		rts				rts
.1a4c					LookNext:
.1a4c	b2 24		lda ($24)			lda 	(srcPtr)
.1a4e	60		rts				rts
.1a4f					LookNextNonSpace:
.1a4f	b2 24		lda ($24)			lda 	(srcPtr)
.1a51	c9 20		cmp #$20			cmp		#' '
.1a53	f0 03		beq $1a58			beq 	_LNNSkip
.1a55	c9 00		cmp #$00			cmp 	#0
.1a57	60		rts				rts
.1a58					_LNNSkip:
.1a58	20 5d 1a	jsr $1a5d			jsr 	GetNext
.1a5b	80 f2		bra $1a4f			bra 	LookNextNonSpace
.1a5d					GetNext:
.1a5d	b2 24		lda ($24)			lda 	(srcPtr) 					; get next
.1a5f	e6 24		inc $24				inc 	srcPtr
.1a61	d0 02		bne $1a65			bne 	_GNSkip
.1a63	e6 25		inc $25				inc 	srcPtr+1
.1a65					_GNSkip:
.1a65	c9 00		cmp #$00			cmp 	#0
.1a67	60		rts				rts
.1a68					GetNextNonSpace:
.1a68	20 5d 1a	jsr $1a5d			jsr 	GetNext
.1a6b	c9 20		cmp #$20			cmp 	#' '
.1a6d	f0 f9		beq $1a68			beq 	GetNextNonSpace
.1a6f	c9 00		cmp #$00			cmp 	#0
.1a71	60		rts				rts
.1a72					CharIsDigit:
.1a72	c9 30		cmp #$30			cmp 	#"0"
.1a74	90 06		bcc $1a7c			bcc 	CCFalse
.1a76	c9 3a		cmp #$3a			cmp 	#"9"+1
.1a78	b0 02		bcs $1a7c			bcs 	CCFalse
.1a7a					CCTrue:
.1a7a	38		sec				sec
.1a7b	60		rts				rts
.1a7c					CCFalse:
.1a7c	18		clc				clc
.1a7d	60		rts				rts
.1a7e					CharIsAlpha:
.1a7e	c9 41		cmp #$41			cmp 	#"A"
.1a80	90 fa		bcc $1a7c			bcc 	CCFalse
.1a82	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1a84	b0 f6		bcs $1a7c			bcs 	CCFalse
.1a86	80 f2		bra $1a7a			bra 	CCTrue
.1a88					ConvertHexStyle:
.1a88	38		sec				sec
.1a89	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1a8b	90 ef		bcc $1a7c			bcc 	CCFalse
.1a8d	c9 0a		cmp #$0a			cmp 	#9+1
.1a8f	90 e9		bcc $1a7a			bcc 	CCTrue
.1a91	38		sec				sec 								; shift into hex space A=>0 Z=>25
.1a92	e9 11		sbc #$11			sbc 	#"A"-"0"
.1a94	90 e6		bcc $1a7c			bcc 	CCFalse
.1a96	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.1a98	b0 e2		bcs $1a7c			bcs 	CCFalse
.1a9a	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.1a9c	80 dc		bra $1a7a			bra 	CCTrue
.1a9e					CommandGET:
.1a9e	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; # follows ?
.1aa1	c9 23		cmp #$23			cmp 	#"#"
.1aa3	d0 0d		bne $1ab2			bne 	CommandGetBody
.1aa5	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume #
.1aa8	20 f9 19	jsr $19f9			jsr 	ChannelPrefix 				; do it as GET#
.1aab	20 b2 1a	jsr $1ab2			jsr 	CommandGetBody
.1aae	20 14 1a	jsr $1a14			jsr 	ChannelPostfix
.1ab1	60		rts				rts
.1ab2					CommandGetBody:
.1ab2	20 68 1a	jsr $1a68			jsr 	GetNextNonSpace 			; get the first character
.1ab5	20 a9 1d	jsr $1da9			jsr 	GetReferenceTerm 			; identify variable to assign to
.1ab8	48		pha				pha
.1ab9	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1abb	c9 40		cmp #$40			cmp 	#NSSString
.1abd	d0 0b		bne $1aca			bne 	_CGType
.1abf	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1ac1	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1ac4	38		sec				sec
.1ac5	68		pla				pla
.1ac6	20 5b 1d	jsr $1d5b			jsr		GetSetVariable
.1ac9	60		rts				rts
.1aca					_CGType:
.1aca	4c 57 1f	jmp $1f57		jmp	ErrorV_type
.1acd					ExtractVariableName:
.1acd	20 7e 1a	jsr $1a7e			jsr 	CharIsAlpha
.1ad0	90 50		bcc $1b22			bcc 	_IVSyntax
.1ad2	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.1ad4	85 2c		sta $2c				sta 	zTemp1 						; we'll build it in zTemp1
.1ad6	64 2d		stz $2d				stz 	zTemp1+1
.1ad8	20 4c 1a	jsr $1a4c			jsr 	LookNext 					; is there a second character ?
.1adb	20 7e 1a	jsr $1a7e			jsr 	CharIsAlpha  				; must be alphanumeric
.1ade	b0 05		bcs $1ae5			bcs 	_IVHasSecond
.1ae0	20 72 1a	jsr $1a72			jsr 	CharIsDigit
.1ae3	90 07		bcc $1aec			bcc 	_IVCheckType
.1ae5					_IVHasSecond:
.1ae5	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.1ae7	85 2d		sta $2d				sta 	zTemp1+1
.1ae9					_IVGetNextCheck:
.1ae9	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume it
.1aec					_IVCheckType:
.1aec	20 4c 1a	jsr $1a4c			jsr 	LookNext					; check if string follows.
.1aef	20 7e 1a	jsr $1a7e			jsr 	CharIsAlpha
.1af2	b0 f5		bcs $1ae9			bcs 	_IVGetNextCheck
.1af4	20 72 1a	jsr $1a72			jsr 	CharIsDigit
.1af7	b0 f0		bcs $1ae9			bcs 	_IVGetNextCheck
.1af9	a2 40		ldx #$40			ldx 	#NSSString
.1afb	c9 24		cmp #$24			cmp 	#"$"
.1afd	f0 06		beq $1b05			beq 	_IVHasType
.1aff	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.1b01	c9 25		cmp #$25			cmp 	#"%"
.1b03	d0 08		bne $1b0d			bne 	_IVCheckArray
.1b05					_IVHasType:
.1b05	8a		txa				txa 								; Or X into zTemp1
.1b06	05 2c		ora $2c				ora 	zTemp1
.1b08	85 2c		sta $2c				sta 	zTemp1
.1b0a	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume it
.1b0d					_IVCheckArray:
.1b0d	20 4c 1a	jsr $1a4c			jsr 	LookNext 					; check if array follows
.1b10	c9 28		cmp #$28			cmp 	#"("
.1b12	d0 09		bne $1b1d			bne 	_IVNotArray
.1b14	a5 2c		lda $2c				lda 	zTemp1 						; set array bit
.1b16	09 80		ora #$80			ora 	#NSSArray
.1b18	85 2c		sta $2c				sta 	zTemp1
.1b1a	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume it
.1b1d					_IVNotArray:
.1b1d	a6 2c		ldx $2c				ldx 	zTemp1
.1b1f	a4 2d		ldy $2d				ldy 	zTemp1+1
.1b21	60		rts				rts
.1b22					_IVSyntax:
.1b22	4c 47 1f	jmp $1f47		jmp	ErrorV_syntax
.1b25					CommandGOSUB:
.1b25	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1b27	20 38 1b	jsr $1b38			jsr 	CompileBranchCommand
.1b2a	60		rts				rts
.1b2b					CommandGOAlt:
.1b2b	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1b2d	20 61 11	jsr $1161			jsr 	CheckNextA
.1b30	80 00		bra $1b32			bra 	CommandGOTO
.1b32					CommandGOTO:
.1b32	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1b34	20 38 1b	jsr $1b38			jsr 	CompileBranchCommand
.1b37	60		rts				rts
.1b38					CompileBranchCommand:
.1b38	20 f9 10	jsr $10f9			jsr 	WriteCodeByte 				; write the command out.
.1b3b	20 68 1a	jsr $1a68			jsr 	GetNextNonSpace
.1b3e	20 b1 1c	jsr $1cb1			jsr 	ParseConstant 				; get constant into YA
.1b41	90 08		bcc $1b4b			bcc 	_CBCSyntax
.1b43	20 f9 10	jsr $10f9			jsr 	WriteCodeByte				; and compile the actual line number
.1b46	98		tya				tya
.1b47	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1b4a	60		rts				rts
.1b4b					_CBCSyntax:
.1b4b	4c 47 1f	jmp $1f47		jmp	ErrorV_syntax
.1b4e					CommandIF:
.1b4e	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; what follows the tests ?
.1b51	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1b53	f0 0f		beq $1b64			beq 	_CIGoto
.1b55	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1b57	20 61 11	jsr $1161			jsr 	CheckNextA
.1b5a	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; THEN <number>
.1b5d	20 72 1a	jsr $1a72			jsr 	CharIsDigit
.1b60	b0 05		bcs $1b67			bcs 	_CIGoto2
.1b62	80 09		bra $1b6d			bra 	CompileGotoEOL
.1b64					_CIGoto:
.1b64	20 5d 1a	jsr $1a5d			jsr 	GetNext
.1b67					_CIGoto2:
.1b67	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1b69	20 38 1b	jsr $1b38			jsr 	CompileBranchCommand
.1b6c	60		rts				rts
.1b6d					CompileGotoEOL:
.1b6d	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.1b6f	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1b72	20 f2 10	jsr $10f2			jsr 	GetLineNumber 				; Get the current line number => YA
.1b75	1a		inc a				inc 	a 							; and branch to +1
.1b76	d0 01		bne $1b79			bne 	_CGENoCarry
.1b78	c8		iny				iny
.1b79					_CGENoCarry:
.1b79	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1b7c	98		tya				tya
.1b7d	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1b80	60		rts				rts
.1b81					CommandINPUT:
.1b81	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; check for "
.1b84	c9 22		cmp #$22			cmp 	#'"'
.1b86	d0 0d		bne $1b95			bne 	CommandINPUTStream
.1b88	20 08 14	jsr $1408			jsr 	CompileExpressionAt0
.1b8b	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1b8d	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1b90	a9 2c		lda #$2c			lda 	#","
.1b92	20 57 11	jsr $1157			jsr 	CheckNextComma
.1b95					CommandINPUTStream:
.1b95	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1b97	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1b9a	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.1b9c	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1b9e	4c 23 1d	jmp $1d23			jmp 	CommandReadInputCommon
.1ba1					CommandLET:
.1ba1	20 68 1a	jsr $1a68			jsr 	GetNextNonSpace 			; get the first character
.1ba4					CommandLETHaveFirst:
.1ba4	20 a9 1d	jsr $1da9			jsr 	GetReferenceTerm 			; identify variable to assign to
.1ba7	da		phx				phx 								; save target on the stack.
.1ba8	5a		phy				phy
.1ba9	48		pha				pha
.1baa	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.1bac	20 61 11	jsr $1161			jsr 	CheckNextA
.1baf	20 08 14	jsr $1408			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1bb2	85 2a		sta $2a				sta 	zTemp0 						; save type returned
.1bb4	68		pla				pla 								; get type of assignment
.1bb5	48		pha				pha
.1bb6	45 2a		eor $2a				eor 	zTemp0 						; compare using EOR
.1bb8	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.1bba	d0 17		bne $1bd3			bne 	_CLType
.1bbc	68		pla				pla 								; restore and compile save code
.1bbd	7a		ply				ply
.1bbe	fa		plx				plx
.1bbf	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.1bc1	f0 05		beq $1bc8			beq 	_CLTIString
.1bc3	38		sec				sec
.1bc4	20 5b 1d	jsr $1d5b			jsr		GetSetVariable
.1bc7	60		rts				rts
.1bc8					_CLTIString:
.1bc8	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.1bca	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1bcd	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.1bcf	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1bd2	60		rts				rts
.1bd3					_CLType:
.1bd3	4c 57 1f	jmp $1f57		jmp	ErrorV_type
.1bd6					STRMarkLine:
.1bd6	48		pha				pha
.1bd7	38		sec				sec 								; allocate 4 bytes (line #,address)
.1bd8	ad 0f 05	lda $050f			lda 	lineNumberTable 			; and copy to zTemp0
.1bdb	e9 04		sbc #$04			sbc 	#4
.1bdd	8d 0f 05	sta $050f			sta 	lineNumberTable
.1be0	85 2a		sta $2a				sta 	zTemp0
.1be2	ad 10 05	lda $0510			lda 	lineNumberTable+1
.1be5	e9 00		sbc #$00			sbc 	#0
.1be7	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1bea	85 2b		sta $2b				sta 	zTemp0+1
.1bec	68		pla				pla
.1bed	92 2a		sta ($2a)			sta 	(zTemp0) 					; line # save it in +0,+1
.1bef	98		tya				tya
.1bf0	a0 01		ldy #$01			ldy 	#1
.1bf2	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1bf4	a5 28		lda $28				lda 	objPtr 						; save current address in +2,+3
.1bf6	c8		iny				iny
.1bf7	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1bf9	a5 29		lda $29				lda 	objPtr+1
.1bfb	c8		iny				iny
.1bfc	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1bfe	60		rts				rts
.1bff					STRFindLine:
.1bff	85 2a		sta $2a				sta 	zTemp0 						; zTemp0 line number being searched
.1c01	84 2b		sty $2b				sty 	zTemp0+1
.1c03	ad 08 05	lda $0508			lda 	compilerEndHigh 			; work backwards through table
.1c06	85 2d		sta $2d				sta 	zTemp1+1
.1c08	64 2c		stz $2c				stz 	zTemp1
.1c0a					_STRSearch:
.1c0a	20 41 1c	jsr $1c41			jsr 	_STRPrevLine 				; look at previous record.
.1c0d	a0 01		ldy #$01			ldy 	#1
.1c0f	b2 2c		lda ($2c)			lda 	(zTemp1) 					; check table line # >= target
.1c11	c5 2a		cmp $2a				cmp 	zTemp0
.1c13	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c15	e5 2b		sbc $2b				sbc 	zTemp0+1
.1c17	b0 0b		bcs $1c24			bcs 	_STRFound 					; >=
.1c19					_STRNext:
.1c19	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1c1b	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c1d	c9 ff		cmp #$ff			cmp 	#$FF
.1c1f	d0 e9		bne $1c0a			bne 	_STRSearch
.1c21	4c a1 1f	jmp $1fa1		jmp	ErrorV_internal
.1c24					_STRFound:
.1c24	b2 2c		lda ($2c)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1c26	45 2a		eor $2a				eor 	zTemp0
.1c28	d0 06		bne $1c30			bne 	_STRDifferent
.1c2a	b2 2c		lda ($2c)			lda 	(zTemp1)
.1c2c	45 2a		eor $2a				eor 	zTemp0
.1c2e	f0 02		beq $1c32			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1c30					_STRDifferent:
.1c30	a9 ff		lda #$ff			lda 	#$FF
.1c32					_STROut:
.1c32	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1c33	69 ff		adc #$ff			adc 	#255
.1c35	08		php				php
.1c36	c8		iny				iny 								; address into YA
.1c37	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c39	48		pha				pha
.1c3a	c8		iny				iny
.1c3b	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c3d	a8		tay				tay
.1c3e	68		pla				pla
.1c3f	28		plp				plp
.1c40	60		rts				rts
.1c41					_STRPrevLine:
.1c41	38		sec				sec 								; move backwards one entry.
.1c42	a5 2c		lda $2c				lda 	zTemp1
.1c44	e9 04		sbc #$04			sbc 	#4
.1c46	85 2c		sta $2c				sta 	zTemp1
.1c48	a5 2d		lda $2d				lda 	zTemp1+1
.1c4a	e9 00		sbc #$00			sbc 	#0
.1c4c	85 2d		sta $2d				sta 	zTemp1+1
.1c4e	60		rts				rts
.1c4f					STRMakeOffset:
.1c4f	18		clc				clc 								; borrow 1
.1c50	e5 28		sbc $28				sbc 	objPtr
.1c52	48		pha				pha
.1c53	98		tya				tya
.1c54	e5 29		sbc $29				sbc 	objPtr+1
.1c56	a8		tay				tay
.1c57	68		pla				pla
.1c58	60		rts				rts
.1c59					CommandNEXT:
.1c59	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1c5c	20 7e 1a	jsr $1a7e			jsr 	CharIsAlpha 				; if not alpha , error
.1c5f	90 0c		bcc $1c6d			bcc 	_CNNoReferenceGiven
.1c61	20 5d 1a	jsr $1a5d			jsr 	GetNext
.1c64	20 a9 1d	jsr $1da9			jsr 	GetReferenceTerm 			; figure out the reference.
.1c67	8a		txa				txa 								; reference in YA
.1c68	20 07 12	jsr $1207			jsr 	PushIntegerYA 				; write it out.
.1c6b	80 06		bra $1c73			bra 	_CNParametersDone
.1c6d					_CNNoReferenceGiven:
.1c6d	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1c6f	a8		tay				tay
.1c70	20 07 12	jsr $1207			jsr 	PushIntegerYA 				; write it out.
.1c73					_CNParametersDone:
.1c73	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1c75	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1c78	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; look for ,
.1c7b	c9 2c		cmp #$2c			cmp 	#","
.1c7d	d0 05		bne $1c84			bne 	_CNExit
.1c7f	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume ,
.1c82	80 d5		bra $1c59			bra 	CommandNEXT 				; and go round.
.1c84					_CNExit:
.1c84	60		rts				rts
.1c85					CommandON:
.1c85	20 68 1a	jsr $1a68			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1c88	48		pha				pha 								; save on stack
.1c89	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1c8b	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1c8d	f0 09		beq $1c98			beq 	_COCreateLoop
.1c8f	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1c91	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1c93	f0 03		beq $1c98			beq 	_COCreateLoop
.1c95	4c 47 1f	jmp $1f47		jmp	ErrorV_syntax
.1c98					_COCreateLoop:
.1c98	8a		txa				txa 								; compile a goto/gosub somewhere
.1c99	da		phx				phx
.1c9a	20 38 1b	jsr $1b38			jsr 	CompileBranchCommand
.1c9d	fa		plx				plx
.1c9e	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace			; ',' follows
.1ca1	c9 2c		cmp #$2c			cmp 	#","
.1ca3	d0 0a		bne $1caf			bne 	_COComplete 				; if so, more line numbers
.1ca5	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1ca7	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1caa	20 5d 1a	jsr $1a5d			jsr 	GetNext
.1cad	80 e9		bra $1c98			bra 	_COCreateLoop
.1caf					_COComplete:
.1caf	68		pla				pla 								; throw GOTO/GOSUB
.1cb0	60		rts				rts
.1cb1					ParseConstant:
.1cb1	a2 00		ldx #$00			ldx 	#0
.1cb3	20 6d 24	jsr $246d			jsr 	FloatEncodeStart 			; send first
.1cb6					_ParseLoop:
.1cb6	20 4c 1a	jsr $1a4c			jsr 	LookNext 					; send subsequent
.1cb9	20 70 24	jsr $2470			jsr 	FloatEncodeContinue
.1cbc	90 05		bcc $1cc3			bcc 	_ParseDone
.1cbe	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume it
.1cc1	80 f3		bra $1cb6			bra 	_ParseLoop
.1cc3					_ParseDone:
.1cc3	b5 30		lda $30,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1cc5	29 80		and #$80			and 	#$80
.1cc7	15 6c		ora $6c,x			ora 	NSExponent,x 				; 16 bit int check
.1cc9	15 54		ora $54,x			ora 	NSMantissa2,x
.1ccb	15 60		ora $60,x			ora 	NSMantissa3,x
.1ccd	18		clc				clc
.1cce	d0 05		bne $1cd5			bne 	_ParseExit 					; exit with CC if need float to compile
.1cd0	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; read into YA.
.1cd2	b4 48		ldy $48,x			ldy		NSMantissa1,x
.1cd4	38		sec				sec
.1cd5					_ParseExit:
.1cd5	60		rts				rts
.1cd6					CommandPRINT:
.1cd6	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace			; what follows ?
.1cd9	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1cdb	f0 1f		beq $1cfc			beq 	_CPCheckEnd
.1cdd	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1cdf	f0 16		beq $1cf7			beq 	_CPTabCheckEnd
.1ce1	20 13 1d	jsr $1d13			jsr 	_CPAtEnd 					; check for : and EOL
.1ce4	b0 22		bcs $1d08			bcs 	_CPExitCR 					; exit with CR
.1ce6	20 08 14	jsr $1408			jsr 	CompileExpressionAt0 		; so it is something to print
.1ce9	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1ceb	29 40		and #$40			and 	#NSSString 					; if string
.1ced	d0 02		bne $1cf1			bne 	_CPOut
.1cef	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1cf1					_CPOut:
.1cf1	8a		txa				txa 								; print that thing
.1cf2	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1cf5	80 df		bra $1cd6			bra 	CommandPRINT 				; and loop round/
.1cf7					_CPTabCheckEnd:
.1cf7	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1cf9	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1cfc					_CPCheckEnd:
.1cfc	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume it.
.1cff	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; what follows ?
.1d02	20 13 1d	jsr $1d13			jsr 	_CPAtEnd 					; reached end
.1d05	90 cf		bcc $1cd6			bcc 	CommandPRINT 				; no, loop back
.1d07	60		rts				rts
.1d08					_CPExitCR:
.1d08	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1d0a	20 1a 12	jsr $121a			jsr 	PushIntegerA
.1d0d	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1d0f	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1d12	60		rts				rts
.1d13					_CPAtEnd:
.1d13	c9 00		cmp #$00			cmp 	#0
.1d15	f0 06		beq $1d1d			beq 	_CPIsEnd
.1d17	c9 3a		cmp #$3a			cmp 	#":"
.1d19	f0 02		beq $1d1d			beq 	_CPIsEnd
.1d1b	18		clc				clc
.1d1c	60		rts				rts
.1d1d					_CPIsEnd:
.1d1d	38		sec				sec
.1d1e	60		rts				rts
.1d1f					CommandREAD:
.1d1f	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1d21	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1d23					CommandReadInputCommon:
.1d23	8e 0d 05	stx $050d			stx 	numberPCode
.1d26	8c 0e 05	sty $050e			sty 	stringPCode
.1d29					_CRLoop:
.1d29	20 68 1a	jsr $1a68			jsr 	GetNextNonSpace 			; first char of identifier
.1d2c	20 7e 1a	jsr $1a7e			jsr 	CharIsAlpha 				; check A-Z
.1d2f	90 27		bcc $1d58			bcc 	_CRSyntax
.1d31	20 a9 1d	jsr $1da9			jsr 	GetReferenceTerm 			; get the variable.
.1d34	48		pha				pha 								; save type.
.1d35	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1d37	c9 40		cmp #$40			cmp 	#NSSString
.1d39	f0 05		beq $1d40			beq 	_CRString
.1d3b	ad 0d 05	lda $050d			lda 	numberPCode 				; output read/input
.1d3e	80 03		bra $1d43			bra 	_CRHaveType
.1d40					_CRString:
.1d40	ad 0e 05	lda $050e			lda 	stringPCode					; output read$/input$
.1d43					_CRHaveType:
.1d43	20 f9 10	jsr $10f9			jsr 	WriteCodeByte 				; so we have one typed data item.
.1d46	68		pla				pla 								; restore type
.1d47	38		sec				sec  								; write update code.
.1d48	20 5b 1d	jsr $1d5b			jsr 	GetSetVariable
.1d4b	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; , follows ?
.1d4e	c9 2c		cmp #$2c			cmp 	#","
.1d50	d0 05		bne $1d57			bne 	_CRExit 					; if not, end of READ.
.1d52	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume comma
.1d55	80 d2		bra $1d29			bra 	_CRLoop 					; keep going
.1d57					_CRExit:
.1d57	60		rts				rts
.1d58					_CRSyntax:
.1d58	4c 47 1f	jmp $1f47		jmp	ErrorV_syntax
.050d					numberPCode:
>050d							.fill 	1
.050e					stringPCode:
>050e							.fill 	1
.1d5b					GetSetVariable:
.1d5b	08		php				php 								; save direction on stack
.1d5c	c0 00		cpy #$00			cpy 	#$00
.1d5e	30 21		bmi $1d81			bmi 	_GSVReadWriteSpecial
.1d60	c9 00		cmp #$00			cmp 	#$00
.1d62	30 33		bmi $1d97			bmi 	_GSVArray
.1d64	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1d66	4a		lsr a				lsr 	a 							; divide by 2
.1d67	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1d69	28		plp				plp
.1d6a	90 02		bcc $1d6e			bcc 	_GSVNotWrite
.1d6c	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1d6e					_GSVNotWrite:
.1d6e	85 2a		sta $2a				sta 	zTemp0
.1d70	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1d71	4a		lsr a				lsr 	a
.1d72	a8		tay				tay
.1d73	8a		txa				txa
.1d74	6a		ror a				ror 	a
.1d75	aa		tax				tax
.1d76	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1d77	05 2a		ora $2a				ora 	zTemp0 						; which is the first byte of the opcode
.1d79	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1d7c	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1d7d	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1d80	60		rts				rts
.1d81					_GSVReadWriteSpecial:
.1d81	28		plp				plp
.1d82	b0 10		bcs $1d94			bcs 	_GSVSyntax
.1d84	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1d86	f0 06		beq $1d8e			beq 	_GSVRWString
.1d88	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1d8a	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1d8d	60		rts				rts
.1d8e					_GSVRWString:
.1d8e	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1d90	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1d93	60		rts				rts
.1d94					_GSVSyntax:
.1d94	4c 47 1f	jmp $1f47		jmp	ErrorV_syntax
.1d97					_GSVArray:
.1d97	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1d99	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1d9a	4a		lsr a				lsr 	a
.1d9b	4a		lsr a				lsr 	a
.1d9c	4a		lsr a				lsr 	a
.1d9d	4a		lsr a				lsr 	a
.1d9e	28		plp				plp 								; if writing array then set bit 2.
.1d9f	90 02		bcc $1da3			bcc 	_GSVANotWrite
.1da1	09 04		ora #$04			ora 	#4
.1da3					_GSVANotWrite:
.1da3	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1da5	20 f9 10	jsr $10f9			jsr 	WriteCodeByte 				; and write it out
.1da8	60		rts				rts
.1da9					GetReferenceTerm:
.1da9	20 cd 1a	jsr $1acd			jsr 	ExtractVariableName 		; get name & type info
.1dac	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1dae	30 10		bmi $1dc0			bmi 	_GRTArray
.1db0	da		phx				phx 								; save type on stack
.1db1	20 c2 14	jsr $14c2			jsr 	FindVariable 				; find it
.1db4	b0 06		bcs $1dbc			bcs 	_GRTNoCreate 				; create if required.
.1db6	20 4c 12	jsr $124c			jsr 	CreateVariableRecord 		; create a variable.
.1db9	20 a1 12	jsr $12a1			jsr 	AllocateBytesForType 		; allocate memory for it
.1dbc					_GRTNoCreate:
.1dbc	68		pla				pla 								; get type back, strip out type information.
.1dbd	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1dbf	60		rts				rts
.1dc0					_GRTArray:
.1dc0	da		phx				phx 								; save type information
.1dc1	20 c2 14	jsr $14c2			jsr 	FindVariable 				; read its data, the base address in YX
.1dc4	90 18		bcc $1dde			bcc 	_GRTUndeclared 				; undeclared array.
.1dc6	da		phx				phx 								; save base address
.1dc7	5a		phy				phy
.1dc8	20 98 13	jsr $1398			jsr 	OutputIndexGroup 			; create an index group and generate them
.1dcb	7a		ply				ply 								; get the array base address into YX
.1dcc	fa		plx				plx
.1dcd	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1dcf	18		clc				clc
.1dd0	20 5b 1d	jsr $1d5b			jsr 	GetSetVariable 				; load the address of the array structure.
.1dd3	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1dd5	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1dd8	68		pla				pla 								; and the type data into A
.1dd9	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1ddb	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1ddd	60		rts				rts
.1dde					_GRTUndeclared:
.1dde	4c fe 1f	jmp $1ffe		jmp	ErrorV_undeclared
.1de1					CommandREM:
.1de1	20 4c 1a	jsr $1a4c			jsr 	LookNext
.1de4	f0 05		beq $1deb			beq 	_CRExit
.1de6	20 5d 1a	jsr $1a5d			jsr 	GetNext
.1de9	80 f6		bra $1de1			bra 	CommandREM
.1deb					_CRExit:
.1deb	60		rts				rts
.1dec					STRReset:
.1dec	ad 07 05	lda $0507			lda	 	compilerStartHigh 			; set up the two table pointers
.1def	8d 12 05	sta $0512			sta 	variableListEnd+1
.1df2	9c 11 05	stz $0511			stz 	variableListEnd
.1df5	ad 08 05	lda $0508			lda 	compilerEndHigh
.1df8	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1dfb	9c 0f 05	stz $050f			stz 	lineNumberTable
.1dfe	ad 11 05	lda $0511			lda 	variableListEnd
.1e01	85 2b		sta $2b				sta 	zTemp0+1
.1e03	64 2a		stz $2a				stz 	zTemp0
.1e05	a9 00		lda #$00			lda 	#0
.1e07	92 2a		sta ($2a)			sta 	(zTemp0)
.1e09	a9 00		lda #$00			lda 	#((0) & $FF)
.1e0b	8d 13 05	sta $0513			sta 	0+freeVariableMemory
.1e0e	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1e10	8d 14 05	sta $0514			sta 	1+freeVariableMemory
.1e13	60		rts				rts
.050f					lineNumberTable:
>050f							.fill 	2
.0511					variableListEnd:
>0511							.fill 	2
.0513					freeVariableMemory:
>0513							.fill 	2
.1e14					CompileTerm:
.1e14	20 68 1a	jsr $1a68			jsr 	GetNextNonSpace 			; get first non space character.
.1e17	30 72		bmi $1e8b			bmi 	_CTUnaryFunctions
.1e19	20 72 1a	jsr $1a72			jsr 	CharIsDigit 				; found a number
.1e1c	b0 3a		bcs $1e58			bcs 	_CTDigit
.1e1e	c9 2e		cmp #$2e			cmp 	#"."
.1e20	f0 36		beq $1e58			beq 	_CTDigit
.1e22	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1e24	f0 43		beq $1e69			beq 	_CTString
.1e26	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1e28	f0 28		beq $1e52			beq 	_CTOtherBase
.1e2a	c9 24		cmp #$24			cmp 	#"$"
.1e2c	f0 24		beq $1e52			beq 	_CTOtherBase
.1e2e	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1e30	f0 17		beq $1e49			beq 	_CTBrackets
.1e32	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1e34	90 10		bcc $1e46			bcc 	_CTSyntax
.1e36	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1e38	b0 0c		bcs $1e46			bcs 	_CTSyntax
.1e3a	20 a9 1d	jsr $1da9			jsr 	GetReferenceTerm 			; figure out what it is.
.1e3d	48		pha				pha 								; save type on stack
.1e3e	18		clc				clc 								; read it
.1e3f	20 5b 1d	jsr $1d5b			jsr 	GetSetVariable
.1e42	68		pla				pla
.1e43	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1e45	60		rts				rts
.1e46					_CTSyntax:
.1e46	4c 47 1f	jmp $1f47		jmp	ErrorV_syntax
.1e49					_CTBrackets:
.1e49	20 08 14	jsr $1408			jsr 	CompileExpressionAt0
.1e4c	48		pha				pha
.1e4d	20 5b 11	jsr $115b			jsr 	CheckNextRParen
.1e50	68		pla				pla
.1e51	60		rts				rts
.1e52					_CTOtherBase:
.1e52	20 a7 10	jsr $10a7			jsr 	InlineNonDecimal 			; non decimal constant handler
.1e55	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e57	60		rts				rts
.1e58					_CTDigit:
.1e58	20 b1 1c	jsr $1cb1			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1e5b	90 06		bcc $1e63			bcc	 	_CTFloat 					; have a float or long int.
.1e5d	20 07 12	jsr $1207			jsr 	PushIntegerYA 				; code to push on stack
.1e60	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e62	60		rts				rts
.1e63					_CTFloat:
.1e63	20 29 12	jsr $1229			jsr 	PushFloat  					; code to push float
.1e66	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1e68	60		rts				rts
.1e69					_CTString:
.1e69	20 30 11	jsr $1130			jsr 	BufferClear 				; copy it to the buffer
.1e6c					_CTStringLoop:
.1e6c	20 4c 1a	jsr $1a4c			jsr 	LookNext 					; reached EOL/EOS
.1e6f	f0 d5		beq $1e46			beq 	_CTSyntax
.1e71	c9 22		cmp #$22			cmp 	#'"'
.1e73	f0 08		beq $1e7d			beq 	_CTStringDone
.1e75	20 34 11	jsr $1134			jsr 	BufferWrite 				; write and consume
.1e78	20 5d 1a	jsr $1a5d			jsr 	GetNext
.1e7b	80 ef		bra $1e6c			bra 	_CTStringLoop
.1e7d					_CTStringDone:
.1e7d	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume closing quote.
.1e80	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1e82	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1e85	20 40 11	jsr $1140			jsr 	BufferOutput
.1e88	a9 40		lda #$40			lda 	#NSSString 					; string type
.1e8a	60		rts				rts
.1e8b					_CTUnaryFunctions:
.1e8b	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1e8d	f0 0a		beq $1e99			beq 	_CTNegation
.1e8f	a2 f4		ldx #$f4			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1e91	a0 17		ldy #$17			ldy 	#UnaryTables >> 8
.1e93	20 ee 18	jsr $18ee			jsr 	GeneratorProcess
.1e96	90 ae		bcc $1e46			bcc		_CTSyntax
.1e98	60		rts				rts
.1e99					_CTNegation:
.1e99	20 14 1e	jsr $1e14			jsr 	CompileTerm 				; compile a term.
.1e9c	48		pha				pha
.1e9d	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1e9f	c9 00		cmp #$00			cmp 	#NSSIFloat
.1ea1	d0 07		bne $1eaa			bne 	_CTType 					; error
.1ea3	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1ea5	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1ea8	68		pla				pla 								; return original type.
.1ea9	60		rts				rts
.1eaa					_CTType:
.1eaa	4c 57 1f	jmp $1f57		jmp	ErrorV_type
.1ead					CommandWAIT:
.1ead	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace
.1eb0	c9 2c		cmp #$2c			cmp 	#","
.1eb2	f0 10		beq $1ec4			beq 	_CWThirdParameter
.1eb4	a9 00		lda #$00			lda 	#0
.1eb6	20 1a 12	jsr $121a			jsr 	PushIntegerA
.1eb9					_CWExit:
.1eb9	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1ebb	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1ebe	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1ec0	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1ec3	60		rts				rts
.1ec4					_CWThirdParameter:
.1ec4	20 5d 1a	jsr $1a5d			jsr 	GetNext
.1ec7	20 0a 14	jsr $140a			jsr 	CompileExpressionAtA
.1eca	29 40		and #$40			and 	#NSSTypeMask
.1ecc	c9 00		cmp #$00			cmp 	#NSSIFloat
.1ece	f0 e9		beq $1eb9			beq 	_CWExit
.1ed0	4c 57 1f	jmp $1f57		jmp	ErrorV_type
.1ed3					CommandCMD:
.1ed3	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.1ed5	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1ed8	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; followed by a , ?
.1edb	c9 2c		cmp #$2c			cmp 	#","
.1edd	d0 06		bne $1ee5			bne 	_CCMDExit
.1edf	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume comma.
.1ee2	20 d6 1c	jsr $1cd6			jsr 	CommandPRINT 				; do the print code
.1ee5					_CCMDExit:
.1ee5	60		rts				rts
.1ee6					CommandOPEN:
.1ee6	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; followed by a , ?
.1ee9	c9 2c		cmp #$2c			cmp 	#","
.1eeb	d0 15		bne $1f02			bne 	_COTwoDefaults
.1eed	20 5d 1a	jsr $1a5d			jsr 	GetNext 					; consume comma
.1ef0	20 08 14	jsr $1408			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1ef3	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1ef5	f0 1e		beq $1f15			beq 	_COThreeIntegers
.1ef7	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1ef9	20 1a 12	jsr $121a			jsr 	PushIntegerA
.1efc	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1efe	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1f01	60		rts				rts
.1f02					_COTwoDefaults:
.1f02	a9 00		lda #$00			lda 	#0
.1f04	20 1a 12	jsr $121a			jsr 	PushIntegerA
.1f07					_COCompileNullString:
.1f07	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1f09	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1f0c	a9 00		lda #$00			lda 	#0
.1f0e	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1f11	20 f9 10	jsr $10f9			jsr 	WriteCodeByte
.1f14	60		rts				rts
.1f15					_COThreeIntegers:
.1f15	20 4f 1a	jsr $1a4f			jsr 	LookNextNonSpace 			; is there a ,
.1f18	c9 2c		cmp #$2c			cmp 	#","
.1f1a	d0 eb		bne $1f07			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1f1c	20 5d 1a	jsr $1a5d			jsr 	GetNext
.1f1f	20 08 14	jsr $1408			jsr 	CompileExpressionAt0 		; should be a filename
.1f22	29 40		and #$40			and 	#NSSString
.1f24	f0 01		beq $1f27			beq 	_COType
.1f26	60		rts				rts
.1f27					_COType:
.1f27	4c 57 1f	jmp $1f57		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					objPtr:
>0028							.fill 	2
.002a					zTemp0:
>002a							.fill 	2
.002c					zTemp1:
>002c							.fill 	2
.002e					zTemp2:
>002e							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1f2a					ErrorV_range:
.1f2a	20 c0 13	jsr $13c0		jsr	ErrorHandler
>1f2d	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f35	41 4e 47 45 00
.1f3a					ErrorV_value:
.1f3a	20 c0 13	jsr $13c0		jsr	ErrorHandler
>1f3d	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f45	45 00
.1f47					ErrorV_syntax:
.1f47	20 c0 13	jsr $13c0		jsr	ErrorHandler
>1f4a	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f52	52 52 4f 52 00
.1f57					ErrorV_type:
.1f57	20 c0 13	jsr $13c0		jsr	ErrorHandler
>1f5a	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f62	4d 41 54 43 48 00
.1f68					ErrorV_unimplemented:
.1f68	20 c0 13	jsr $13c0		jsr	ErrorHandler
>1f6b	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f73	45 4d 45 4e 54 45 44 00
.1f7b					ErrorV_assert:
.1f7b	20 c0 13	jsr $13c0		jsr	ErrorHandler
>1f7e	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f86	41 49 4c 00
.1f8a					ErrorV_line:
.1f8a	20 c0 13	jsr $13c0		jsr	ErrorHandler
>1f8d	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f95	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1fa1					ErrorV_internal:
.1fa1	20 c0 13	jsr $13c0		jsr	ErrorHandler
>1fa4	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1fac	20 45 52 52 4f 52 00
.1fb3					ErrorV_divzero:
.1fb3	20 c0 13	jsr $13c0		jsr	ErrorHandler
>1fb6	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fbe	59 20 5a 45 52 4f 00
.1fc5					ErrorV_structure:
.1fc5	20 c0 13	jsr $13c0		jsr	ErrorHandler
>1fc8	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fd0	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fdc					ErrorV_stop:
.1fdc	20 c0 13	jsr $13c0		jsr	ErrorHandler
>1fdf	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fe7	53 54 4f 50 50 45 44 00
.1fef					ErrorV_data:
.1fef	20 c0 13	jsr $13c0		jsr	ErrorHandler
>1ff2	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1ffa	41 54 41 00
.1ffe					ErrorV_undeclared:
.1ffe	20 c0 13	jsr $13c0		jsr	ErrorHandler
>2001	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>2009	41 52 52 41 59 00
.200f					ErrorV_redefine:
.200f	20 c0 13	jsr $13c0		jsr	ErrorHandler
>2012	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>201a	44 45 46 49 4e 45 44 00
.2022					ErrorV_index:
.2022	20 c0 13	jsr $13c0		jsr	ErrorHandler
>2025	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>202d	59 20 49 4e 44 45 58 00
.2035					ErrorV_memory:
.2035	20 c0 13	jsr $13c0		jsr	ErrorHandler
>2038	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2040	45 4d 4f 52 59 00
.2046					ErrorV_channel:
.2046	20 c0 13	jsr $13c0		jsr	ErrorHandler
>2049	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2051	54 50 55 54 20 45 52 52 4f 52 00
.205c					MoveObjectForward:
.205c	b2 28		lda ($28)			lda 	(objPtr) 					; get next
.205e	c9 ff		cmp #$ff			cmp 	#$FF
.2060	f0 36		beq $2098			beq 	_MOFEnd
.2062	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.2064	90 24		bcc $208a			bcc 	_MOFAdvance1 				; forward 1
.2066	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.2068	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.206a	90 20		bcc $208c			bcc 	_MOFAdvanceY
.206c	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.206e	90 1a		bcc $208a			bcc 	_MOFAdvance1 				; forward 1
.2070	a8		tay				tay 								; read the size.
.2071	b9 d6 1f	lda $1fd6,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.2074	a8		tay				tay
.2075	c8		iny				iny 								; add 1 for the system token.
.2076	d0 14		bne $208c			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2078	a0 01		ldy #$01			ldy 	#1 							; get length byte
.207a	b1 28		lda ($28),y			lda 	(objPtr),y
.207c	a8		tay				tay 								; into Y.
.207d	18		clc				clc
.207e	a5 28		lda $28				lda 	objPtr						; add 2 to the object pointer
.2080	69 02		adc #$02			adc 	#2
.2082	85 28		sta $28				sta 	objPtr
.2084	90 02		bcc $2088			bcc 	_MOFNoCarry1
.2086	e6 29		inc $29				inc 	objPtr+1
.2088					_MOFNoCarry1:
.2088	80 02		bra $208c			bra 	_MOFAdvanceY
.208a					_MOFAdvance1:
.208a	a0 01		ldy #$01			ldy 	#1
.208c					_MOFAdvanceY:
.208c	98		tya				tya 								; add Y to objPtr
.208d	18		clc				clc
.208e	65 28		adc $28				adc 	objPtr
.2090	85 28		sta $28				sta 	objPtr
.2092	90 02		bcc $2096			bcc 	_MOFNoCarry2
.2094	e6 29		inc $29				inc 	objPtr+1
.2096					_MOFNoCarry2:
.2096	18		clc				clc 								; not completed.
.2097	60		rts				rts
.2098					_MOFEnd:
.2098	e6 28		inc $28				inc 	objPtr
.209a	d0 02		bne $209e			bne 	_MOFENoCarry
.209c	e6 29		inc $29				inc 	objPtr+1
.209e					_MOFENoCarry:
.209e	38		sec				sec
.209f	60		rts				rts
.20a0					MOFSizeTable:
>20a0	01					.byte	1         	; $ca .shift
>20a1	01					.byte	1         	; $cb .byte
>20a2	02					.byte	2         	; $cc .word
>20a3	05					.byte	5         	; $cd .float
>20a4	ff					.byte	255       	; $ce .string
>20a5	ff					.byte	255       	; $cf .data
>20a6	02					.byte	2         	; $d0 .goto
>20a7	02					.byte	2         	; $d1 .gosub
>20a8	02					.byte	2         	; $d2 .goto.z
>20a9	02					.byte	2         	; $d3 .goto.nz
>20aa	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0030					NSStatus:
>0030							.fill 	MathStackSize
.003c					NSMantissa0:
>003c							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0048					NSMantissa1:
>0048							.fill 	MathStackSize
.0054					NSMantissa2:
>0054							.fill 	MathStackSize
.0060					NSMantissa3:
>0060							.fill 	MathStackSize
.006c					NSExponent:
>006c							.fill 	MathStackSize
.0515					numberBuffer:
>0515							.fill 	34
.20ab					FloatSubtract:
.20ab	b5 30		lda $30,x			lda 	NSStatus,x 					; negate top of stack
.20ad	49 80		eor #$80			eor 	#$80
.20af	95 30		sta $30,x			sta 	NSStatus,x					; and fall through.
.20b1					FloatAdd:
.20b1	ca		dex				dex
.20b2	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised.
.20b4	15 6d		ora $6d,x			ora 	NSExponent+1,x
.20b6	15 60		ora $60,x			ora 	NSMantissa3,x
.20b8	15 61		ora $61,x			ora 	NSMantissa3+1,x
.20ba	d0 04		bne $20c0			bne 	_FAUseFloat
.20bc	20 4d 24	jsr $244d			jsr 	FloatInt32Add 				; use the int32 one.
.20bf	60		rts				rts
.20c0					_FAUseFloat:
.20c0	20 e2 23	jsr $23e2			jsr 	FloatNormalise 				; normalise S[X]
.20c3	f0 51		beq $2116			beq 	_FAReturn1
.20c5	e8		inx				inx 								; normalise S[X+1]
.20c6	20 e2 23	jsr $23e2			jsr 	FloatNormalise
.20c9	ca		dex				dex
.20ca	c9 00		cmp #$00			cmp 	#0
.20cc	f0 60		beq $212e			beq 	_FAExit 					; if so, just return A
.20ce	b5 6c		lda $6c,x			lda 	NSExponent,x 				; are the exponents the same ?
.20d0	d5 6d		cmp $6d,x			cmp 	NSExponent+1,x
.20d2	f0 18		beq $20ec			beq 	_FAExponentsEqual
.20d4	b5 6c		lda $6c,x			lda 	NSExponent,x 				; work out the larger exponent
.20d6	a8		tay				tay
.20d7	38		sec				sec 								; do a signed comparison of the exponents.
.20d8	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.20da	50 02		bvc $20de			bvc 	_FANoSignedChange
.20dc	49 80		eor #$80			eor 	#$80
.20de					_FANoSignedChange:
.20de	29 80		and #$80			and 	#$80
.20e0	10 02		bpl $20e4			bpl 	_FAHaveMax
.20e2	b4 6d		ldy $6d,x			ldy 	NSExponent+1,x
.20e4					_FAHaveMax:
.20e4	20 2f 21	jsr $212f			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20e7	e8		inx				inx
.20e8	20 2f 21	jsr $212f			jsr 	_FAShiftToExponent
.20eb	ca		dex				dex
.20ec					_FAExponentsEqual:
.20ec	b5 30		lda $30,x			lda 	NSStatus,x 					; are the signs the same
.20ee	55 31		eor $31,x			eor 	NSStatus+1,x
.20f0	30 0e		bmi $2100			bmi 	_FADifferentSigns
.20f2	20 19 24	jsr $2419			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20f5	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20f7	10 35		bpl $212e			bpl 	_FAExit 					; if no, we are done.
.20f9	20 a6 26	jsr $26a6			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20fc	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump the exponent and exit
.20fe	80 2e		bra $212e			bra 	_FAExit
.2100					_FADifferentSigns:
.2100	20 33 24	jsr $2433			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.2103	b5 60		lda $60,x			lda 	NSMantissa3,x 				; is the result negative ?
.2105	10 06		bpl $210d			bpl 	_FACheckZero 				; if no, check for -0
.2107	20 4f 26	jsr $264f			jsr 	FloatNegate 					; netate result
.210a	20 56 26	jsr $2656			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.210d					_FACheckZero:
.210d	20 af 26	jsr $26af			jsr 	FloatIsZero	 				; check for -0
.2110	d0 1c		bne $212e			bne 	_FAExit
.2112	74 30		stz $30,x			stz 	NSStatus,x
.2114	80 18		bra $212e			bra 	_FAExit
.2116					_FAReturn1:
.2116	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.2118	95 3c		sta $3c,x			sta 	NSMantissa0,x
.211a	b5 49		lda $49,x			lda 	NSMantissa1+1,x
.211c	95 48		sta $48,x			sta 	NSMantissa1,x
.211e	b5 55		lda $55,x			lda 	NSMantissa2+1,x
.2120	95 54		sta $54,x			sta 	NSMantissa2,x
.2122	b5 61		lda $61,x			lda 	NSMantissa3+1,x
.2124	95 60		sta $60,x			sta 	NSMantissa3,x
.2126	b5 6d		lda $6d,x			lda 	NSExponent+1,x
.2128	95 6c		sta $6c,x			sta 	NSExponent,x
.212a	b5 31		lda $31,x			lda 	NSStatus+1,x
.212c	95 30		sta $30,x			sta 	NSStatus,x
.212e					_FAExit:
.212e	60		rts				rts
.212f					_FAShiftToExponent:
.212f					_FAShiftToExponent2:
.212f	98		tya				tya 								; compare Y to exponent
.2130	d5 6c		cmp $6c,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2132	f0 07		beq $213b			beq 	_FASEExit 					; exit if so.
.2134	20 a6 26	jsr $26a6			jsr 	FloatShiftRight	 			; shift the mantissa right
.2137	f6 6c		inc $6c,x			inc 	NSExponent,x 				; increment exponent
.2139	80 f4		bra $212f			bra 	_FAShiftToExponent2
.213b					_FASEExit:
.213b	60		rts				rts
.213c					CompareEqual:
.213c	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.213e	d0 09		bne $2149			bne 	ReturnFalse
.2140					ReturnTrue:
.2140	a9 01		lda #$01			lda 	#1
.2142	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2144	a9 80		lda #$80			lda 	#$80
.2146	95 30		sta $30,x			sta 	NSStatus,x
.2148	60		rts				rts
.2149					ReturnFalse:
.2149	74 3c		stz $3c,x			stz 	NSMantissa0,x
.214b	60		rts				rts
.214c					CompareNotEqual:
.214c	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.214e	d0 f0		bne $2140			bne 	ReturnTrue
.2150	80 f7		bra $2149			bra 	ReturnFalse
.2152					CompareLess:
.2152	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2154	c9 ff		cmp #$ff			cmp 	#$FF
.2156	f0 e8		beq $2140			beq 	ReturnTrue
.2158	80 ef		bra $2149			bra 	ReturnFalse
.215a					CompareGreater:
.215a	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.215c	c9 01		cmp #$01			cmp 	#$01
.215e	f0 e0		beq $2140			beq 	ReturnTrue
.2160	80 e7		bra $2149			bra 	ReturnFalse
.2162					CompareLessEqual:
.2162	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2164	c9 01		cmp #$01			cmp 	#$01
.2166	d0 d8		bne $2140			bne 	ReturnTrue
.2168	80 df		bra $2149			bra 	ReturnFalse
.216a					CompareGreaterEqual:
.216a	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.216c	c9 ff		cmp #$ff			cmp 	#$FF
.216e	d0 d0		bne $2140			bne 	ReturnTrue
.2170	80 d7		bra $2149			bra 	ReturnFalse
.2172					FloatCompare:
.2172	b5 6c		lda $6c,x			lda 	NSExponent,x 				; float comparison.
.2174	15 6b		ora $6b,x			ora 	NSExponent-1,x 				; integer if both integer.
.2176	48		pha				pha
.2177	20 ab 20	jsr $20ab			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.217a	68		pla				pla
.217b	d0 0c		bne $2189			bne 	_FCCompareFloat
.217d	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.217f	15 48		ora $48,x			ora 	NSMantissa1,x
.2181	15 54		ora $54,x			ora 	NSMantissa2,x
.2183	15 60		ora $60,x			ora 	NSMantissa3,x
.2185	f0 14		beq $219b			beq 	_FCExit 					; if zero, return zero
.2187	80 0a		bra $2193			bra 	_FCSign
.2189					_FCCompareFloat:
.2189	b5 48		lda $48,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.218b	29 f0		and #$f0			and 	#$F0
.218d	15 54		ora $54,x			ora 	NSMantissa2,x
.218f	15 60		ora $60,x			ora 	NSMantissa3,x
.2191	f0 08		beq $219b			beq 	_FCExit 					; zero, so approximately identical
.2193					_FCSign:
.2193	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2195	34 30		bit $30,x			bit 	NSStatus,x
.2197	10 02		bpl $219b			bpl 	_FCExit
.2199					_FCNegative:
.2199	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.219b					_FCExit:
.219b	20 8f 26	jsr $268f			jsr 	FloatSetByte 				; set the result 255,0,1
.219e	60		rts				rts
.219f					FloatScalarTable:
>219f	66 66 66 66				.dword $66666666 ; 0.1
>21a3	de					.byte $de
>21a4	1f 85 eb 51				.dword $51eb851f ; 0.01
>21a8	db					.byte $db
>21a9	4c 37 89 41				.dword $4189374c ; 0.001
>21ad	d8					.byte $d8
>21ae	ac 8b db 68				.dword $68db8bac ; 0.0001
>21b2	d4					.byte $d4
>21b3	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>21b7	d1					.byte $d1
>21b8	83 de 1b 43				.dword $431bde83 ; 1e-06
>21bc	ce					.byte $ce
>21bd	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21c1	ca					.byte $ca
>21c2	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21c6	c7					.byte $c7
>21c7	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21cb	c4					.byte $c4
>21cc	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21d0	c0					.byte $c0
>21d1	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21d5	bd					.byte $bd
.21d6					FloatDivide:
.21d6	48		pha				pha
.21d7	20 e2 23	jsr $23e2			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21da	ca		dex				dex
.21db	c9 00		cmp #$00			cmp 	#0
.21dd	f0 1e		beq $21fd			beq 	_FDZero
.21df	20 e2 23	jsr $23e2			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21e2	f0 16		beq $21fa			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21e4	20 45 22	jsr $2245			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21e7	20 12 22	jsr $2212			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21ea	20 e2 23	jsr $23e2			jsr		FloatNormalise 				; renormalise
.21ed	20 d8 23	jsr $23d8			jsr 	FloatCalculateSign 			; calculate result sign
.21f0	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent
.21f2	38		sec				sec
.21f3	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.21f5	38		sec				sec
.21f6	e9 1e		sbc #$1e			sbc 	#30
.21f8	95 6c		sta $6c,x			sta 	NSExponent,x
.21fa					_FDExit:
.21fa	68		pla				pla
.21fb	18		clc				clc
.21fc	60		rts				rts
.21fd					_FDZero:
.21fd	68		pla				pla
.21fe	38		sec				sec
.21ff	60		rts				rts
.2200					DivideInt32:
.2200	20 c8 22	jsr $22c8			jsr 	FloatIntegerPart 			; make both integers
.2203	ca		dex				dex
.2204	20 c8 22	jsr $22c8			jsr 	FloatIntegerPart
.2207	20 23 22	jsr $2223			jsr 	Int32Divide 				; divide
.220a	20 12 22	jsr $2212			jsr 	NSMCopyPlusTwoToZero 		; copy result
.220d	20 d8 23	jsr $23d8			jsr 	FloatCalculateSign 			; calculate result sign
.2210	18		clc				clc
.2211	60		rts				rts
.2212					NSMCopyPlusTwoToZero:
.2212	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.2214	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2216	b5 4a		lda $4a,x			lda 	NSMantissa1+2,x
.2218	95 48		sta $48,x			sta 	NSMantissa1,x
.221a	b5 56		lda $56,x			lda 	NSMantissa2+2,x
.221c	95 54		sta $54,x			sta 	NSMantissa2,x
.221e	b5 62		lda $62,x			lda 	NSMantissa3+2,x
.2220	95 60		sta $60,x			sta 	NSMantissa3,x
.2222	60		rts				rts
.2223					Int32Divide:
.2223	48		pha				pha 								; save AXY
.2224	5a		phy				phy
.2225	20 70 26	jsr $2670			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2228	20 89 26	jsr $2689			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.222b	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.222d					_I32DivideLoop:
.222d	e8		inx				inx
.222e	e8		inx				inx
.222f	20 9c 26	jsr $269c			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2232	ca		dex				dex
.2233	ca		dex				dex
.2234	20 9d 26	jsr $269d			jsr 	FloatRotateLeft
.2237	20 63 22	jsr $2263			jsr 	FloatDivideCheck 			; check if subtract possible
.223a	90 02		bcc $223e			bcc 	_I32DivideNoCarryIn
.223c	f6 3e		inc $3e,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.223e					_I32DivideNoCarryIn:
.223e	88		dey				dey 								; loop round till division completed.
.223f	d0 ec		bne $222d			bne 	_I32DivideLoop
.2241	7a		ply				ply 								; restore AXY and exit
.2242	68		pla				pla
.2243	18		clc				clc
.2244	60		rts				rts
.2245					Int32ShiftDivide:
.2245	48		pha				pha 								; save AY
.2246	5a		phy				phy
.2247	e8		inx				inx 								; clear S[X+2]
.2248	e8		inx				inx
.2249	20 8d 26	jsr $268d			jsr 	FloatSetZero
.224c	ca		dex				dex
.224d	ca		dex				dex
.224e	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2250					_I32SDLoop:
.2250	20 63 22	jsr $2263			jsr 	FloatDivideCheck 			; check if subtract possible
.2253	e8		inx				inx
.2254	e8		inx				inx
.2255	20 9d 26	jsr $269d			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.2258	ca		dex				dex
.2259	ca		dex				dex
.225a	20 9d 26	jsr $269d			jsr 	FloatRotateLeft
.225d	88		dey				dey 	 							; do 31 times
.225e	d0 f0		bne $2250			bne 	_I32SDLoop
.2260	7a		ply				ply 								; restore AY and exit
.2261	68		pla				pla
.2262	60		rts				rts
.2263					FloatDivideCheck:
.2263	20 33 24	jsr $2433			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.2266	b0 04		bcs $226c			bcs 	_DCSExit 					; if carry set, then could do, exit
.2268	20 19 24	jsr $2419			jsr 	FloatAddTopTwoStack 		; add it back in
.226b	18		clc				clc 								; and return False
.226c					_DCSExit:
.226c	60		rts				rts
.226d					FloatFractionalPart:
.226d	5a		phy				phy
.226e	b5 30		lda $30,x			lda 	NSStatus,x 					; take absolute value
.2270	29 7f		and #$7f			and 	#$7F
.2272	95 30		sta $30,x			sta 	NSStatus,x
.2274	20 e2 23	jsr $23e2			jsr 	FloatNormalise
.2277	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2279	38		sec				sec
.227a	e9 e0		sbc #$e0			sbc 	#$E0
.227c	90 29		bcc $22a7			bcc 	_FFPExit 					; already fractional
.227e	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2280	b0 22		bcs $22a4			bcs 	_FFPZero
.2282	a8		tay				tay 								; put count to do in Y
.2283	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do each in turn.
.2285	20 ac 22	jsr $22ac			jsr 	_FFPPartial
.2288	95 60		sta $60,x			sta 	NSMantissa3,x
.228a	b5 54		lda $54,x			lda 	NSMantissa2,x
.228c	20 ac 22	jsr $22ac			jsr 	_FFPPartial
.228f	95 54		sta $54,x			sta 	NSMantissa2,x
.2291	b5 48		lda $48,x			lda 	NSMantissa1,x
.2293	20 ac 22	jsr $22ac			jsr 	_FFPPartial
.2296	95 48		sta $48,x			sta 	NSMantissa1,x
.2298	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.229a	20 ac 22	jsr $22ac			jsr 	_FFPPartial
.229d	95 3c		sta $3c,x			sta 	NSMantissa0,x
.229f	20 af 26	jsr $26af			jsr 	FloatIsZero 					; zeroed check.
.22a2	d0 03		bne $22a7			bne 	_FFPExit
.22a4					_FFPZero:
.22a4	20 8d 26	jsr $268d			jsr 	FloatSetZero
.22a7					_FFPExit:
.22a7	20 e2 23	jsr $23e2			jsr 	FloatNormalise
.22aa	7a		ply				ply
.22ab	60		rts				rts
.22ac					_FFPPartial:
.22ac	c0 00		cpy #$00			cpy 	#0 							; no more to do
.22ae	f0 17		beq $22c7			beq 	_FFFPPExit
.22b0	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.22b2	b0 0c		bcs $22c0			bcs 	_FFFPPWholeByte
.22b4	5a		phy				phy
.22b5					_FFFPPLeft:
.22b5	0a		asl a				asl 	a
.22b6	88		dey				dey
.22b7	d0 fc		bne $22b5			bne 	_FFFPPLeft
.22b9	7a		ply				ply
.22ba					_FFFPPRight:
.22ba	4a		lsr a				lsr 	a
.22bb	88		dey				dey
.22bc	d0 fc		bne $22ba			bne 	_FFFPPRight
.22be	80 07		bra $22c7			bra 	_FFFPPExit
.22c0					_FFFPPWholeByte:
.22c0	98		tya				tya 								; subtract 8 from count
.22c1	38		sec				sec
.22c2	e9 08		sbc #$08			sbc 	#8
.22c4	a8		tay				tay
.22c5	a9 00		lda #$00			lda 	#0 							; and clear all
.22c7					_FFFPPExit:
.22c7	60		rts				rts
.22c8					FloatIntegerPart:
.22c8	48		pha				pha
.22c9	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.22cb	f0 1d		beq $22ea			beq 	_FIPExit 					; if so do nothing
.22cd	20 af 26	jsr $26af			jsr 	FloatIsZero 				; is it zero ?
.22d0	f0 15		beq $22e7			beq 	_FIPZero 					; if so return zero.
.22d2	20 e2 23	jsr $23e2			jsr 	FloatNormalise 				; normalise
.22d5	f0 10		beq $22e7			beq 	_FIPZero 					; normalised to zero, exit zero
.22d7					_FIPShift:
.22d7	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22d9	10 07		bpl $22e2			bpl 	_FIPCheckZero
.22db	20 a6 26	jsr $26a6			jsr 	FloatShiftRight 			; shift mantissa right
.22de	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.22e0	80 f5		bra $22d7			bra 	_FIPShift
.22e2					_FIPCheckZero:
.22e2	20 af 26	jsr $26af			jsr 	FloatIsZero 				; avoid -0 problem
.22e5	d0 03		bne $22ea			bne 	_FIPExit 					; set to zero if mantissa zero.
.22e7					_FIPZero:
.22e7	20 8d 26	jsr $268d			jsr 	FloatSetZero
.22ea					_FIPExit:
.22ea	68		pla				pla
.22eb	60		rts				rts
.22ec					FloatIntegerPartDown:
.22ec	48		pha				pha
.22ed	5a		phy				phy
.22ee	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.22f0	f0 36		beq $2328			beq 	_FIPExit 					; if so do nothing
.22f2	20 af 26	jsr $26af			jsr 	FloatIsZero 				; is it zero ?
.22f5	f0 2e		beq $2325			beq 	_FIPZero 					; if so return zero.
.22f7	20 e2 23	jsr $23e2			jsr 	FloatNormalise 				; normalise
.22fa	f0 29		beq $2325			beq 	_FIPZero 					; normalised to zero, exit zero
.22fc	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22fe					_FIPShift:
.22fe	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2300	10 0a		bpl $230c			bpl 	_FIPCheckDown
.2302	20 a6 26	jsr $26a6			jsr 	FloatShiftRight 			; shift mantissa right
.2305	90 01		bcc $2308			bcc 	_FIPNoFrac 					; shifted a zero out ?
.2307	c8		iny				iny
.2308					_FIPNoFrac:
.2308	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.230a	80 f2		bra $22fe			bra 	_FIPShift
.230c					_FIPCheckDown:
.230c	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.230e	f0 10		beq $2320			beq 	_FIPCheckZero
.2310	34 30		bit $30,x			bit 	NSStatus,x 					; +ve
.2312	10 0c		bpl $2320			bpl 	_FIPCheckZero
.2314	e8		inx				inx 								; -ve so round *down*.
.2315	a9 01		lda #$01			lda 	#1
.2317	20 8f 26	jsr $268f			jsr 	FloatSetByte
.231a	20 4f 26	jsr $264f			jsr 	FloatNegate
.231d	20 b1 20	jsr $20b1			jsr 	FloatAdd
.2320					_FIPCheckZero:
.2320	20 af 26	jsr $26af			jsr 	FloatIsZero 				; avoid -0 problem
.2323	d0 03		bne $2328			bne 	_FIPExit 					; set to zero if mantissa zero.
.2325					_FIPZero:
.2325	20 8d 26	jsr $268d			jsr 	FloatSetZero
.2328					_FIPExit:
.2328	7a		ply				ply
.2329	68		pla				pla
.232a	60		rts				rts
.232b					FloatInt8Multiply:
.232b	5a		phy				phy
.232c	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.232e	a8		tay				tay
.232f	74 3c		stz $3c,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2331					_FI8MLoop:
.2331	98		tya				tya 								; shift right shifter right into carry
.2332	4a		lsr a				lsr 	a
.2333	a8		tay				tay
.2334	90 0d		bcc $2343			bcc 	_FI8MNoAdd
.2336	18		clc				clc
.2337	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2339	75 3d		adc $3d,x			adc 	NSMantissa0+1,x
.233b	95 3c		sta $3c,x			sta 	NSMantissa0,x
.233d	b5 48		lda $48,x			lda 	NSMantissa1,x
.233f	75 49		adc $49,x			adc 	NSMantissa1+1,x
.2341	95 48		sta $48,x			sta 	NSMantissa1,x
.2343					_FI8MNoAdd:
.2343	16 3d		asl $3d,x			asl 	NSMantissa0+1,x 			; shift adder left
.2345	36 49		rol $49,x			rol 	NSMantissa1+1,x
.2347	c0 00		cpy #$00			cpy 	#0
.2349	d0 e6		bne $2331			bne 	_FI8MLoop 					; until right shifter zero.
.234b	7a		ply				ply
.234c	60		rts				rts
.234d					FloatMultiply:
.234d	ca		dex				dex
.234e	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised ?
.2350	15 6d		ora $6d,x			ora 	NSExponent+1,x
.2352	15 60		ora $60,x			ora 	NSMantissa3,x
.2354	15 61		ora $61,x			ora 	NSMantissa3+1,x
.2356	d0 21		bne $2379			bne 	_FMUseFloat
.2358	b5 30		lda $30,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.235a	15 31		ora $31,x			ora 	NSStatus+1,x
.235c	29 80		and #$80			and 	#$80
.235e	15 60		ora $60,x			ora 	NSMantissa3,x
.2360	15 54		ora $54,x			ora 	NSMantissa2,x
.2362	15 48		ora $48,x			ora 	NSMantissa1,x
.2364	15 61		ora $61,x			ora 	NSMantissa3+1,x
.2366	15 55		ora $55,x			ora 	NSMantissa2+1,x
.2368	15 49		ora $49,x			ora 	NSMantissa1+1,x
.236a	d0 04		bne $2370			bne 	_FMInt32
.236c	20 2b 23	jsr $232b			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.236f	60		rts				rts
.2370					_FMInt32:
.2370	20 9a 23	jsr $239a			jsr 	FloatMultiplyShort			; use the int32 one.
.2373	18		clc				clc 								; fix it up if gone out of range
.2374	75 6c		adc $6c,x			adc 	NSExponent,x
.2376	95 6c		sta $6c,x			sta 	NSExponent,x
.2378	60		rts				rts
.2379					_FMUseFloat:
.2379	20 e2 23	jsr $23e2			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.237c	f0 18		beq $2396			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.237e	e8		inx				inx
.237f	20 e2 23	jsr $23e2			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2382	ca		dex				dex
.2383	c9 00		cmp #$00			cmp 	#0
.2385	f0 0c		beq $2393			beq 	_FDSetZero
.2387	20 9a 23	jsr $239a			jsr 	FloatMultiplyShort 			; calculate the result.
.238a	75 6c		adc $6c,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.238c	18		clc				clc
.238d	75 6d		adc $6d,x			adc 	NSExponent+1,x
.238f	95 6c		sta $6c,x			sta 	NSExponent,x
.2391	80 03		bra $2396			bra 	_FDExit
.2393					_FDSetZero:
.2393	20 8d 26	jsr $268d			jsr 	FloatSetZero 				; return 0
.2396					_FDExit:
.2396	20 e2 23	jsr $23e2			jsr 	FloatNormalise 				; normalise the result
.2399	60		rts				rts
.239a					FloatMultiplyShort:
.239a	5a		phy				phy 								; save Y
.239b	20 70 26	jsr $2670			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.239e	20 89 26	jsr $2689			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.23a1	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.23a3					_I32MLoop:
.23a3	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.23a5	15 4a		ora $4a,x			ora 	NSMantissa1+2,x
.23a7	15 56		ora $56,x			ora 	NSMantissa2+2,x
.23a9	15 62		ora $62,x			ora 	NSMantissa3+2,x
.23ab	f0 25		beq $23d2			beq 	_I32MExit 					; exit if zero
.23ad	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.23af	29 01		and #$01			and 	#1
.23b1	f0 0d		beq $23c0			beq 	_I32MNoAdd
.23b3	20 19 24	jsr $2419			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.23b6	b5 60		lda $60,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.23b8	10 06		bpl $23c0			bpl 	_I32MNoAdd
.23ba					_I32ShiftRight:
.23ba	20 a6 26	jsr $26a6			jsr 	FloatShiftRight 			; shift S[X] right
.23bd	c8		iny				iny 								; increment shift count
.23be	80 09		bra $23c9			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23c0					_I32MNoAdd:
.23c0	34 61		bit $61,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23c2	70 f6		bvs $23ba			bvs 	_I32ShiftRight 				; instead.
.23c4	e8		inx				inx
.23c5	20 9c 26	jsr $269c			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23c8	ca		dex				dex
.23c9					_I32MShiftUpper:
.23c9	e8		inx				inx 								; shift S[X+2] right
.23ca	e8		inx				inx
.23cb	20 a6 26	jsr $26a6			jsr 	FloatShiftRight
.23ce	ca		dex				dex
.23cf	ca		dex				dex
.23d0	80 d1		bra $23a3			bra 	_I32MLoop 					; try again.
.23d2					_I32MExit:
.23d2	20 d8 23	jsr $23d8			jsr 	FloatCalculateSign
.23d5	98		tya				tya 								; shift in A
.23d6	7a		ply				ply 								; restore Y and exit
.23d7	60		rts				rts
.23d8					FloatCalculateSign:
.23d8	b5 30		lda $30,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23da	16 30		asl $30,x			asl 	NSStatus,x 					; shift result left
.23dc	55 31		eor $31,x			eor 	NSStatus+1,x
.23de	0a		asl a				asl 	a 							; shift bit 7 into carry
.23df	76 30		ror $30,x			ror 	NSStatus,x 					; shift right into status byte.
.23e1	60		rts				rts
.23e2					FloatNormalise:
.23e2	20 af 26	jsr $26af			jsr 	FloatIsZero 				; if zero exit
.23e5	d0 07		bne $23ee			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23e7	16 30		asl $30,x			asl 	NSStatus,x 					; clear the sign bit.
.23e9	76 30		ror $30,x			ror 	NSStatus,x 					; (no -0)
.23eb	a9 00		lda #$00			lda 	#0 							; set Z flag
.23ed	60		rts				rts
.23ee					_NSNormaliseOptimise:
.23ee	b5 60		lda $60,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23f0	d0 19		bne $240b			bne 	_NSNormaliseLoop
.23f2	b5 54		lda $54,x			lda 	NSMantissa2,x 				; byte normalise
.23f4	30 15		bmi $240b			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23f6	95 60		sta $60,x			sta 	NSMantissa3,x
.23f8	b5 48		lda $48,x			lda 	NSMantissa1,x
.23fa	95 54		sta $54,x			sta 	NSMantissa2,x
.23fc	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.23fe	95 48		sta $48,x			sta 	NSMantissa1,x
.2400	74 3c		stz $3c,x			stz 	NSMantissa0,x
.2402	b5 6c		lda $6c,x			lda 	NSExponent,x
.2404	38		sec				sec
.2405	e9 08		sbc #$08			sbc 	#8
.2407	95 6c		sta $6c,x			sta 	NSExponent,x
.2409	80 e3		bra $23ee			bra 	_NSNormaliseOptimise
.240b					_NSNormaliseLoop:
.240b	34 60		bit $60,x			bit 	NSMantissa3,x 				; bit 30 set ?
.240d	70 07		bvs $2416			bvs 	_NSNExit 					; exit if so with Z flag clear
.240f	20 9c 26	jsr $269c			jsr 	FloatShiftLeft 				; shift mantissa left
.2412	d6 6c		dec $6c,x			dec 	NSExponent,x 				; adjust exponent
.2414	80 f5		bra $240b			bra 	_NSNormaliseLoop
.2416					_NSNExit:
.2416	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.2418	60		rts				rts
.2419					FloatAddTopTwoStack:
.2419	18		clc				clc
.241a	b5 3c		lda $3c,x			lda		NSMantissa0,x
.241c	75 3d		adc $3d,x			adc 		NSMantissa0+1,x
.241e	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2420	b5 48		lda $48,x			lda		NSMantissa1,x
.2422	75 49		adc $49,x			adc 		NSMantissa1+1,x
.2424	95 48		sta $48,x			sta 	NSMantissa1,x
.2426	b5 54		lda $54,x			lda		NSMantissa2,x
.2428	75 55		adc $55,x			adc 		NSMantissa2+1,x
.242a	95 54		sta $54,x			sta 	NSMantissa2,x
.242c	b5 60		lda $60,x			lda		NSMantissa3,x
.242e	75 61		adc $61,x			adc 		NSMantissa3+1,x
.2430	95 60		sta $60,x			sta 	NSMantissa3,x
.2432	60		rts				rts
.2433					FloatSubTopTwoStack:
.2433	38		sec				sec
.2434	b5 3c		lda $3c,x			lda		NSMantissa0,x
.2436	f5 3d		sbc $3d,x			sbc 		NSMantissa0+1,x
.2438	95 3c		sta $3c,x			sta 	NSMantissa0,x
.243a	b5 48		lda $48,x			lda		NSMantissa1,x
.243c	f5 49		sbc $49,x			sbc 		NSMantissa1+1,x
.243e	95 48		sta $48,x			sta 	NSMantissa1,x
.2440	b5 54		lda $54,x			lda		NSMantissa2,x
.2442	f5 55		sbc $55,x			sbc 		NSMantissa2+1,x
.2444	95 54		sta $54,x			sta 	NSMantissa2,x
.2446	b5 60		lda $60,x			lda		NSMantissa3,x
.2448	f5 61		sbc $61,x			sbc 		NSMantissa3+1,x
.244a	95 60		sta $60,x			sta 	NSMantissa3,x
.244c	60		rts				rts
.244d					FloatInt32Add:
.244d	b5 30		lda $30,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.244f	55 31		eor $31,x			eor 	NSStatus+1,x
.2451	30 04		bmi $2457			bmi 	_DiffSigns
.2453	20 19 24	jsr $2419			jsr		FloatAddTopTwoStack
.2456	60		rts				rts
.2457					_DiffSigns:
.2457	20 33 24	jsr $2433			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.245a	34 60		bit $60,x			bit 	NSMantissa3,x 				; result is +ve, okay
.245c	10 07		bpl $2465			bpl 	_AddExit
.245e	b5 31		lda $31,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2460	95 30		sta $30,x			sta 	NSStatus,x
.2462	20 56 26	jsr $2656			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2465					_AddExit:
.2465	20 af 26	jsr $26af			jsr 	FloatIsZero 				; check for -0
.2468	d0 02		bne $246c			bne 	_AddNonZero
.246a	74 30		stz $30,x			stz 	NSStatus,x
.246c					_AddNonZero:
.246c	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.246d					FloatEncodeStart:
.246d	38		sec				sec
.246e	80 01		bra $2471			bra 	FloatEncodeContinue+1
.2470					FloatEncodeContinue:
.2470	18		clc				clc
.2471					FloatEncode:
.2471	08		php				php 								; save reset flag.
.2472	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2474	f0 15		beq $248b			beq 	_ENIsOkay
.2476	c9 30		cmp #$30			cmp 	#"0"
.2478	90 04		bcc $247e			bcc 	_ENBadNumber
.247a	c9 3a		cmp #$3a			cmp 	#"9"+1
.247c	90 0d		bcc $248b			bcc 	_ENIsOkay
.247e					_ENBadNumber:
.247e	28		plp				plp 								; throw saved reset
.247f	ad 37 05	lda $0537			lda 	encodeState 				; if in decimal mode, construct final number
.2482	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2484	d0 03		bne $2489			bne 	_ENFail
.2486	4c 03 25	jmp $2503			jmp 	_ENConstructFinal
.2489					_ENFail:
.2489	18		clc				clc 								; not allowed
.248a	60		rts				rts
.248b					_ENIsOkay:
.248b	28		plp				plp 								; are we restarting
.248c	90 15		bcc $24a3			bcc 	_ENNoRestart
.248e					_ENStartEncode:
.248e	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2490	f0 0c		beq $249e			beq 	_ENFirstDP
.2492	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2494	20 8f 26	jsr $268f			jsr 	FloatSetByte 				; in single byte mode.
.2497	a9 01		lda #$01			lda 	#ESTA_Low
.2499					_ENExitChange:
.2499	8d 37 05	sta $0537			sta 	encodeState 				; save new state
.249c	38		sec				sec
.249d	60		rts				rts
.249e					_ENFirstDP:
.249e	20 8d 26	jsr $268d			jsr 	FloatSetZero 				; clear integer part
.24a1	80 3c		bra $24df			bra 	_ESTASwitchFloat			; go straight to float and exi
.24a3					_ENNoRestart:
.24a3	48		pha				pha 								; save digit or DP on stack.
.24a4	ad 37 05	lda $0537			lda 	encodeState 				; get current state
.24a7	c9 01		cmp #$01			cmp 	#ESTA_Low
.24a9	f0 09		beq $24b4			beq  	_ESTALowState
.24ab	c9 02		cmp #$02			cmp 	#ESTA_High
.24ad	f0 26		beq $24d5			beq 	_ESTAHighState
.24af	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.24b1	f0 38		beq $24eb			beq 	_ESTADecimalState
>24b3	db						.byte 	$DB 						; causes a break in the emulator
.24b4					_ESTALowState:
.24b4	68		pla				pla 								; get value back
.24b5	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.24b7	f0 26		beq $24df			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24b9	29 0f		and #$0f			and 	#15 						; make digit
.24bb	8d 38 05	sta $0538			sta 	digitTemp 					; save it.
.24be	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24c0	0a		asl a				asl 	a
.24c1	0a		asl a				asl 	a
.24c2	75 3c		adc $3c,x			adc 	NSMantissa0,x
.24c4	0a		asl a				asl 	a
.24c5	6d 38 05	adc $0538			adc 	digitTemp
.24c8	95 3c		sta $3c,x			sta 	NSMantissa0,x
.24ca	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24cc	90 05		bcc $24d3			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24ce	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24d0	8d 37 05	sta $0537			sta 	encodeState
.24d3					_ESTANoSwitch:
.24d3	38		sec				sec
.24d4	60		rts				rts
.24d5					_ESTAHighState:
.24d5	68		pla				pla 								; get value back
.24d6	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24d8	f0 05		beq $24df			beq 	_ESTASwitchFloat
.24da	20 35 25	jsr $2535			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24dd	38		sec				sec
.24de	60		rts				rts
.24df					_ESTASwitchFloat:
.24df	9c 39 05	stz $0539			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24e2	e8		inx				inx 								; zero the decimal additive.
.24e3	20 8d 26	jsr $268d			jsr 	FloatSetZero
.24e6	ca		dex				dex
.24e7	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24e9	80 ae		bra $2499			bra 	_ENExitChange
.24eb					_ESTADecimalState:
.24eb	68		pla				pla 								; digit.
.24ec	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24ee	f0 99		beq $2489			beq 	_ENFail
.24f0	e8		inx				inx 								; put digit into fractional part of X+1
.24f1	20 35 25	jsr $2535			jsr 	ESTAShiftDigitIntoMantissa
.24f4	ca		dex				dex
.24f5	ee 39 05	inc $0539			inc 	decimalCount 				; bump the count of decimals
.24f8	ad 39 05	lda $0539			lda 	decimalCount 				; too many decimal digits.
.24fb	c9 0b		cmp #$0b			cmp 	#11
.24fd	f0 02		beq $2501			beq 	_ESTADSFail
.24ff	38		sec				sec
.2500	60		rts				rts
.2501					_ESTADSFail:
.2501	18		clc				clc
.2502	60		rts				rts
.2503					_ENConstructFinal:
.2503	ad 39 05	lda $0539			lda 	decimalCount 				; get decimal count
.2506	f0 2b		beq $2533			beq 	_ENCFExit 					; no decimals
.2508	5a		phy				phy
.2509	0a		asl a				asl 	a 							; x 4 and CLC
.250a	0a		asl a				asl 	a
.250b	6d 39 05	adc $0539			adc 	decimalCount
.250e	a8		tay				tay
.250f	b9 9a 21	lda $219a,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.2512	95 3e		sta $3e,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.2514	b9 9b 21	lda $219b,y			lda 	FloatScalarTable-5+1,y
.2517	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.2519	b9 9c 21	lda $219c,y			lda 	FloatScalarTable-5+2,y
.251c	95 56		sta $56,x			sta 	NSMantissa2+2,x
.251e	b9 9d 21	lda $219d,y			lda 	FloatScalarTable-5+3,y
.2521	95 62		sta $62,x			sta 	NSMantissa3+2,x
.2523	b9 9e 21	lda $219e,y			lda 	FloatScalarTable-5+4,y
.2526	95 6e		sta $6e,x			sta 	NSExponent+2,x
.2528	74 32		stz $32,x			stz 	NSStatus+2,x 				; make +ve
.252a	e8		inx				inx 								; multiply decimal const by decimal scalar
.252b	e8		inx				inx
.252c	20 4d 23	jsr $234d			jsr 	FloatMultiply
.252f	20 b1 20	jsr $20b1			jsr 	FloatAdd 					; add to integer part.
.2532	7a		ply				ply
.2533					_ENCFExit:
.2533	18		clc				clc 								; reject the digit.
.2534	60		rts				rts
.2535					ESTAShiftDigitIntoMantissa:
.2535	29 0f		and #$0f			and 	#15 						; save digit
.2537	48		pha				pha
.2538	b5 60		lda $60,x			lda 	NSMantissa3,x 				; push mantissa on stack
.253a	48		pha				pha
.253b	b5 54		lda $54,x			lda 	NSMantissa2,x
.253d	48		pha				pha
.253e	b5 48		lda $48,x			lda 	NSMantissa1,x
.2540	48		pha				pha
.2541	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2543	48		pha				pha
.2544	20 9c 26	jsr $269c			jsr 	FloatShiftLeft 				; x 2
.2547	20 9c 26	jsr $269c			jsr 	FloatShiftLeft 				; x 4
.254a	18		clc				clc 								; pop mantissa and add
.254b	68		pla				pla
.254c	75 3c		adc $3c,x			adc 	NSMantissa0,x
.254e	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2550	68		pla				pla
.2551	75 48		adc $48,x			adc 	NSMantissa1,x
.2553	95 48		sta $48,x			sta 	NSMantissa1,x
.2555	68		pla				pla
.2556	75 54		adc $54,x			adc 	NSMantissa2,x
.2558	95 54		sta $54,x			sta 	NSMantissa2,x
.255a	68		pla				pla
.255b	75 60		adc $60,x			adc 	NSMantissa3,x
.255d	95 60		sta $60,x			sta 	NSMantissa3,x 				; x 5
.255f	20 9c 26	jsr $269c			jsr 	FloatShiftLeft 				; x 10
.2562	68		pla				pla 								; add digit
.2563	18		clc				clc
.2564	75 3c		adc $3c,x			adc 	NSMantissa0,x
.2566	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2568	90 0a		bcc $2574			bcc 	_ESTASDExit
.256a	f6 48		inc $48,x			inc 	NSMantissa1,x
.256c	d0 06		bne $2574			bne 	_ESTASDExit
.256e	f6 54		inc $54,x			inc 	NSMantissa2,x
.2570	d0 02		bne $2574			bne 	_ESTASDExit
.2572	f6 60		inc $60,x			inc 	NSMantissa3,x
.2574					_ESTASDExit:
.2574	60		rts				rts
.0537					encodeState:
>0537							.fill 	1
.0538					digitTemp:
>0538							.fill 	1
.0539					decimalCount:
>0539							.fill 	1
.2575					FloatToString:
.2575	da		phx				phx
.2576	5a		phy				phy 								; save code position
.2577	8d 3a 05	sta $053a			sta 	decimalPlaces	 			; save number of DPs.
.257a	9c 3b 05	stz $053b			stz 	dbOffset 					; offset into decimal buffer = start.
.257d	b5 30		lda $30,x			lda 	NSStatus,x  				; is it -ve.
.257f	10 08		bpl $2589			bpl 	_CNTSNotNegative
.2581	29 7f		and #$7f			and 	#$7F 						; make +ve
.2583	95 30		sta $30,x			sta 	NSStatus,x
.2585	a9 2d		lda #$2d			lda 	#"-"
.2587	80 02		bra $258b			bra 	_CNTMain
.2589					_CNTSNotNegative:
.2589	a9 20		lda #$20			lda 	#" "
.258b					_CNTMain:
.258b	20 ed 25	jsr $25ed			jsr 	WriteDecimalBuffer
.258e	b5 6c		lda $6c,x			lda 	NSExponent,x 				; check if decimal
.2590	f0 0d		beq $259f			beq 	_CNTSNotFloat
.2592	e8		inx				inx 								; round up so we don't get too many 6.999999
.2593	a9 01		lda #$01			lda 	#1
.2595	20 8f 26	jsr $268f			jsr 	FloatSetByte
.2598	b5 6b		lda $6b,x			lda		NSExponent-1,x
.259a	95 6c		sta $6c,x			sta 	NSExponent,x
.259c	20 b1 20	jsr $20b1			jsr 	FloatAdd
.259f					_CNTSNotFloat:
.259f	20 cf 25	jsr $25cf			jsr 	MakePlusTwoString 			; do the integer part.
.25a2	20 6d 22	jsr $226d			jsr 	FloatFractionalPart 		; get the fractional part
.25a5	20 e2 23	jsr $23e2			jsr 	FloatNormalise					; normalise , exit if zero
.25a8	f0 22		beq $25cc			beq 	_CNTSExit
.25aa	a9 2e		lda #$2e			lda 	#"."
.25ac	20 ed 25	jsr $25ed			jsr 	WriteDecimalBuffer 			; write decimal place
.25af					_CNTSDecimal:
.25af	ce 3a 05	dec $053a			dec 	decimalPlaces 				; done all the decimals
.25b2	30 18		bmi $25cc			bmi 	_CNTSExit
.25b4	e8		inx				inx 								; x 10.0
.25b5	a9 0a		lda #$0a			lda 	#10
.25b7	20 8f 26	jsr $268f			jsr 	FloatSetByte
.25ba	20 4d 23	jsr $234d			jsr 	FloatMultiply
.25bd	20 cf 25	jsr $25cf			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25c0	20 6d 22	jsr $226d			jsr 	FloatFractionalPart 		; get the fractional part
.25c3	20 e2 23	jsr $23e2			jsr 	FloatNormalise 				; normalise it.
.25c6	b5 6c		lda $6c,x			lda 	NSExponent,x 				; gone to zero, exit.
.25c8	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25ca	b0 e3		bcs $25af			bcs 	_CNTSDecimal 				; keep going.
.25cc					_CNTSExit:
.25cc	7a		ply				ply
.25cd	fa		plx				plx
.25ce	60		rts				rts
.25cf					MakePlusTwoString:
.25cf	da		phx				phx
.25d0	20 70 26	jsr $2670			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25d3	e8		inx				inx 								; access it
.25d4	e8		inx				inx
.25d5	20 c8 22	jsr $22c8			jsr 	FloatIntegerPart 			; make it an integer
.25d8	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25da	20 0c 26	jsr $260c			jsr 	ConvertInt32
.25dd	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25df					_MPTSCopy:
.25df	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25e2	20 ed 25	jsr $25ed			jsr 	WriteDecimalBuffer
.25e5	e8		inx				inx
.25e6	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25e9	d0 f4		bne $25df			bne 	_MPTSCopy
.25eb	fa		plx				plx
.25ec	60		rts				rts
.25ed					WriteDecimalBuffer:
.25ed	da		phx				phx
.25ee	ae 3b 05	ldx $053b			ldx 	dbOffset
.25f1	9d 3c 05	sta $053c,x			sta 	decimalBuffer,x
.25f4	9e 3d 05	stz $053d,x			stz 	decimalBuffer+1,x
.25f7	ee 3b 05	inc $053b			inc 	dbOffset
.25fa	fa		plx				plx
.25fb	60		rts				rts
.053a					decimalPlaces:
>053a							.fill 	1
.053b					dbOffset:
>053b							.fill 	1
.053c					decimalBuffer:
>053c							.fill 	32
.25fc					ConvertInt16:
.25fc	85 3c		sta $3c				sta 	NSMantissa0 				; set up as 32 bit conversion
.25fe	86 48		stx $48				stx 	NSMantissa1
.2600	64 54		stz $54				stz 	NSMantissa2
.2602	64 60		stz $60				stz 	NSMantissa3
.2604	64 30		stz $30				stz 	NSStatus 					; positive integer
.2606	a2 00		ldx #$00			ldx 	#0 							; stack level
.2608	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.260a	80 00		bra $260c			bra 	ConvertInt32
.260c					ConvertInt32:
.260c	5a		phy				phy
.260d	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.260f	24 30		bit $30				bit 	NSStatus 					; output a - if not negative.
.2611	10 08		bpl $261b			bpl 	_CI32NotNeg
.2613	48		pha				pha
.2614	a9 2d		lda #$2d			lda 	#'-'
.2616	99 15 05	sta $0515,y			sta 	numberBuffer,y
.2619	c8		iny				iny
.261a	68		pla				pla
.261b					_CI32NotNeg:
.261b	20 29 26	jsr $2629			jsr 	_CI32DivideConvert 			; recursive conversion
.261e	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2620	99 15 05	sta $0515,y			sta 	numberBuffer,y
.2623	7a		ply				ply
.2624	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.2626	a9 15		lda #$15			lda 	#numberBuffer & $FF
.2628	60		rts				rts
.2629					_CI32DivideConvert:
.2629	e8		inx				inx 								; write to next slot up
.262a	20 8f 26	jsr $268f			jsr 	FloatSetByte 		 		; write the base out.
.262d	ca		dex				dex
.262e	20 23 22	jsr $2223			jsr 	Int32Divide 				; divide
.2631	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; save remainder
.2633	48		pha				pha
.2634	20 12 22	jsr $2212			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2637	20 af 26	jsr $26af			jsr 	FloatIsZero 				; is it zero ?
.263a	f0 05		beq $2641			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.263c	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.263e	20 29 26	jsr $2629			jsr 	_CI32DivideConvert 			; and recusrively call.
.2641					_CI32NoRecurse:
.2641	68		pla				pla 								; remainder
.2642	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2644	90 02		bcc $2648			bcc 	_CI32NotHex
.2646	69 26		adc #$26			adc 	#6+32
.2648					_CI32NotHex:
.2648	69 30		adc #$30			adc 	#48
.264a	99 15 05	sta $0515,y			sta 	numberBuffer,y 				; write out and exit
.264d	c8		iny				iny
.264e	60		rts				rts
.264f					FloatNegate:
.264f	b5 30		lda $30,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2651	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2653	95 30		sta $30,x			sta 	NSStatus,x
.2655	60		rts				rts
.2656					FloatNegateMantissa:
.2656	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2657	a9 00		lda #$00			lda 	#0
.2659	f5 3c		sbc $3c,x			sbc 	NSMantissa0,x
.265b	95 3c		sta $3c,x			sta 	NSMantissa0,x
.265d	a9 00		lda #$00			lda 	#0
.265f	f5 48		sbc $48,x			sbc 	NSMantissa1,x
.2661	95 48		sta $48,x			sta 	NSMantissa1,x
.2663	a9 00		lda #$00			lda 	#0
.2665	f5 54		sbc $54,x			sbc 	NSMantissa2,x
.2667	95 54		sta $54,x			sta 	NSMantissa2,x
.2669	a9 00		lda #$00			lda 	#0
.266b	f5 60		sbc $60,x			sbc 	NSMantissa3,x
.266d	95 60		sta $60,x			sta 	NSMantissa3,x
.266f	60		rts				rts
.2670					FloatShiftUpTwo:
.2670	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2672	95 3e		sta $3e,x			sta 	NSMantissa0+2,x
.2674	b5 48		lda $48,x			lda 	NSMantissa1,x
.2676	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.2678	b5 54		lda $54,x			lda 	NSMantissa2,x
.267a	95 56		sta $56,x			sta 	NSMantissa2+2,x
.267c	b5 60		lda $60,x			lda 	NSMantissa3,x
.267e	95 62		sta $62,x			sta 	NSMantissa3+2,x
.2680	b5 6c		lda $6c,x			lda 	NSExponent,x
.2682	95 6e		sta $6e,x			sta 	NSExponent+2,x
.2684	b5 30		lda $30,x			lda 	NSStatus,x
.2686	95 32		sta $32,x			sta 	NSStatus+2,x
.2688	60		rts				rts
.2689					FloatSetZeroMantissaOnly:
.2689	74 3c		stz $3c,x			stz 	NSMantissa0,x
.268b	80 08		bra $2695			bra 	FloatZero13
.268d					FloatSetZero:
.268d	a9 00		lda #$00			lda 	#0
.268f					FloatSetByte:
.268f	74 6c		stz $6c,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2691					FloatSetMantissa:
.2691	95 3c		sta $3c,x			sta 	NSMantissa0,x 				; zero mantissa
.2693	74 30		stz $30,x			stz 	NSStatus,x
.2695					FloatZero13:
.2695	74 48		stz $48,x			stz 	NSMantissa1,x
.2697	74 54		stz $54,x			stz 	NSMantissa2,x
.2699	74 60		stz $60,x			stz 	NSMantissa3,x
.269b	60		rts				rts
.269c					FloatShiftLeft:
.269c	18		clc				clc
.269d					FloatRotateLeft:
.269d	36 3c		rol $3c,x			rol 	NSMantissa0,x
.269f	36 48		rol $48,x			rol		NSMantissa1,x
.26a1	36 54		rol $54,x			rol		NSMantissa2,x
.26a3	36 60		rol $60,x			rol		NSMantissa3,x
.26a5	60		rts				rts
.26a6					FloatShiftRight:
.26a6	56 60		lsr $60,x			lsr 	NSMantissa3,x
.26a8	76 54		ror $54,x			ror		NSMantissa2,x
.26aa	76 48		ror $48,x			ror		NSMantissa1,x
.26ac	76 3c		ror $3c,x			ror		NSMantissa0,x
.26ae	60		rts				rts
.26af					FloatIsZero:
.26af	b5 60		lda $60,x			lda 	NSMantissa3,x
.26b1	15 54		ora $54,x			ora		NSMantissa2,x
.26b3	15 48		ora $48,x			ora		NSMantissa1,x
.26b5	15 3c		ora $3c,x			ora		NSMantissa0,x
.26b7	60		rts				rts

;******  Processing input file: testing/testend.asm

.26b8					EndProgram:
>26b8	01 08 0a 08 01 00 43 52				.binary "code/tokenised.dat"
>26c0	b2 31 00 13 08 02 00 43 43 b2 31 00 1c 08 03 00
>26d0	46 52 b2 31 00 25 08 04 00 46 43 b2 31 00 30 08
>26e0	05 00 4b 31 b2 24 36 30 00 3a 08 06 00 52 5a b2
>26f0	43 52 00 44 08 07 00 43 5a b2 43 43 00 4e 08 08
>2700	00 52 59 b2 46 52 00 58 08 09 00 43 59 b2 46 43
>2710	00 86 08 0a 00 86 52 4f 28 36 30 29 3a 8f 20 52
>2720	4f 57 20 4f 46 46 53 45 54 20 81 20 54 48 45 20
>2730	56 49 44 45 4f 20 97 20 54 52 49 43 4b 53 00 97
>2740	08 0b 00 81 49 b2 24 42 30 a4 24 45 42 a9 31 00
>2750	ba 08 0c 00 52 4f 28 49 ab 24 41 46 29 b2 49 3a
>2760	8f 20 55 53 45 20 49 4e 44 45 58 20 31 20 a4 20
>2770	36 30 00 c1 08 0d 00 82 49 00 da 08 0e 00 ce 8d
>2780	31 2c 36 3a 8f 20 57 48 49 54 45 20 91 20 42 4c
>2790	55 45 00 f3 08 0f 00 ce 86 33 3a 8f 20 34 30 20
>27a0	43 4f 4c 2c 20 33 30 20 52 4f 57 00 fd 08 10 00
>27b0	ce 8d 30 2c 36 00 08 09 11 00 ce 92 31 2c 33 39
>27c0	00 13 09 12 00 99 22 56 2a 22 3b 00 1d 09 13 00
>27d0	ce 8d 34 2c 36 00 27 09 14 00 ce 92 31 2c 32 00
>27e0	3d 09 15 00 99 22 44 49 53 50 4c 41 59 2d 43 4f
>27f0	44 45 53 22 3b 00 48 09 16 00 ce 92 31 2c 32 34
>2800	00 5d 09 17 00 99 22 43 55 52 52 45 4e 54 2d 46
>2810	4f 4e 54 22 3b 00 68 09 18 00 ce 92 32 31 2c 31
>2820	00 84 09 19 00 99 22 50 52 49 4e 54 2d 43 4f 44
>2830	45 53 20 28 48 45 58 20 24 29 22 3b 00 8e 09 1a
>2840	00 ce 8d 31 2c 36 00 99 09 1b 00 90 3a 8d 32 34
>2850	39 00 a2 09 1c 00 8d 31 31 37 00 ab 09 1d 00 8d
>2860	31 33 36 00 b3 09 1e 00 8d 35 38 00 c6 09 1f 00
>2870	8f 20 a1 20 4b 45 59 42 4f 41 52 44 20 85 00 ce
>2880	09 20 00 a1 41 24 00 f4 09 21 00 41 b2 c6 28 41
>2890	24 29 3a 8f 20 43 91 56 45 52 54 20 53 54 52 49
>28a0	4e 47 20 a4 20 4e 55 4d 45 52 49 43 00 17 0a 22
>28b0	00 8f 20 ce 8b 41 43 54 45 52 20 4d 41 50 20 44
>28c0	49 53 50 4c 41 59 20 4d 4f 56 45 4d 45 4e 54 00
>28d0	33 0a 23 00 8b 41 b2 38 37 a7 52 5a b2 52 5a ab
>28e0	31 3a 8d 35 38 3a 8f 20 27 57 27 00 4f 0a 24 00
>28f0	8b 41 b2 38 33 a7 52 5a b2 52 5a aa 31 3a 8d 35
>2900	38 3a 8f 20 27 53 27 00 6b 0a 25 00 8b 41 b2 36
>2910	35 a7 43 5a b2 43 5a ab 31 3a 8d 35 38 3a 8f 20
>2920	27 41 27 00 87 0a 26 00 8b 41 b2 36 38 a7 43 5a
>2930	b2 43 5a aa 31 3a 8d 35 38 3a 8f 20 27 44 27 00
>2940	a2 0a 27 00 8f 20 46 91 54 20 44 49 53 50 4c 41
>2950	59 20 4d 4f 56 45 4d 45 4e 54 00 c4 0a 28 00 8b
>2960	41 b2 31 34 35 a7 52 59 b2 52 59 ab 31 3a 8d 35
>2970	38 3a 8f 20 55 50 20 41 52 52 4f 57 00 e7 0a 29
>2980	00 8b 41 b2 31 37 a7 52 59 b2 52 59 aa 31 3a 8d
>2990	35 38 3a 8f 20 44 4f 57 4e 20 41 52 52 4f 57 00
>29a0	0b 0b 2a 00 8b 41 b2 31 35 37 a7 43 59 b2 43 59
>29b0	ab 31 3a 8d 35 38 3a 8f 20 4c 45 46 54 20 41 52
>29c0	52 4f 57 00 2f 0b 2b 00 8b 41 b2 32 39 a7 43 59
>29d0	b2 43 59 aa 31 3a 8d 35 38 3a 8f 20 52 49 47 48
>29e0	54 20 41 52 52 4f 57 00 4d 0b 2c 00 8b 41 b2 33
>29f0	32 a7 8d 31 34 37 3a 8d 35 38 3a 8f 20 53 50 41
>2a00	43 45 42 41 52 00 6d 0b 2d 00 8b 41 b2 37 33 a7
>2a10	8d 33 30 31 3a 8d 35 38 3a 8f 20 49 20 81 20 49
>2a20	4e 56 45 52 54 00 90 0b 2e 00 8b 41 b2 36 37 a7
>2a30	8d 32 36 34 3a 8d 35 38 3a 8f 20 43 20 81 20 43
>2a40	4c 45 41 52 20 41 4c 4c 00 b1 0b 2f 00 8b 41 b2
>2a50	36 39 a7 8d 32 37 34 3a 8d 35 38 3a 8f 20 53 20
>2a60	81 20 53 45 54 20 41 4c 4c 00 cf 0b 30 00 8b 41
>2a70	b2 37 35 a7 8d 32 38 34 3a 8d 35 38 3a 8f 20 4b
>2a80	20 81 20 43 4f 50 59 00 e4 0b 31 00 8b 41 b2 38
>2a90	36 a7 8d 31 39 37 3a 8f 20 94 20 56 00 fd 0b 32
>2aa0	00 8b 41 b2 37 36 a7 8d 32 32 34 3a 8d 35 38 3a
>2ab0	8f 20 93 20 4c 00 1a 0c 33 00 8b 41 b2 38 38 a7
>2ac0	8d 31 35 38 3a 8f 20 58 20 bd b0 54 20 43 4f 4d
>2ad0	4d af 00 42 0c 34 00 5a 5a b2 30 3a 8f 20 44 91
>2ae0	27 54 20 55 50 44 41 54 45 20 54 48 45 20 44 49
>2af0	53 50 4c 41 59 ab 46 91 54 53 00 78 0c 35 00 8b
>2b00	41 b2 39 33 a7 4b 31 b2 4b 31 aa 38 3a 5a 5a b2
>2b10	31 3a 8b 28 4b 31 b1 31 39 32 29 a7 4b 31 b2 30
>2b20	3a 8f 20 4b 45 59 20 5d 20 49 4e 43 8f 45 4e 54
>2b30	00 ae 0c 36 00 8b 41 b2 39 31 a7 4b 31 b2 4b 31
>2b40	ab 38 3a 5a 5a b2 31 3a 8b 28 4b 31 b3 30 29 a7
>2b50	4b 31 b2 31 39 32 3a 8f 20 4b 45 59 20 5b 20 44
>2b60	45 43 8f 45 4e 54 00 bf 0c 37 00 8b 28 5a 5a b2
>2b70	31 29 a7 8d 31 31 37 00 d7 0c 38 00 8b 41 b2 32
>2b80	37 a7 89 33 35 35 3a 8f 20 45 53 43 41 50 45 00
>2b90	df 0c 39 00 89 33 31 00 ea 0c 3a 00 58 b2 43 43
>2ba0	aa 31 00 f5 0c 3b 00 59 b2 43 52 aa 31 00 ff 0c
>2bb0	3c 00 44 b2 24 36 31 00 08 0d 3d 00 8d 33 34 38
>2bc0	00 10 0d 3e 00 99 22 22 00 1b 0d 3f 00 ce 8d 31
>2bd0	33 2c 36 00 40 0d 40 00 8f 20 55 50 44 41 54 45
>2be0	20 ce 8b 41 43 54 45 52 20 44 49 53 50 4c 41 59
>2bf0	20 4d 41 52 4b 45 52 53 00 4e 0d 41 00 ce 92 43
>2c00	52 aa 31 2c 31 38 00 58 0d 42 00 99 22 20 22 3b
>2c10	00 6a 0d 43 00 8b 28 52 5a b1 31 36 29 a7 52 5a
>2c20	b2 31 00 7c 0d 44 00 8b 28 52 5a b3 31 29 a7 52
>2c30	5a b2 31 36 00 86 0d 45 00 43 52 b2 52 5a 00 94
>2c40	0d 46 00 ce 92 43 52 aa 31 2c 31 38 00 a1 0d 47
>2c50	00 99 c7 28 24 35 46 29 3b 00 af 0d 48 00 ce 92
>2c60	31 38 2c 43 43 aa 31 00 b9 0d 49 00 99 22 20 22
>2c70	3b 00 cb 0d 4a 00 8b 28 43 5a b1 31 36 29 a7 43
>2c80	5a b2 31 00 dd 0d 4b 00 8b 28 43 5a b3 31 29 a7
>2c90	43 5a b2 31 36 00 e7 0d 4c 00 43 43 b2 43 5a 00
>2ca0	f5 0d 4d 00 ce 92 31 38 2c 43 43 aa 31 00 ff 0d
>2cb0	4e 00 99 22 5e 22 3b 00 20 0e 4f 00 8f 20 55 50
>2cc0	44 41 54 45 20 46 91 54 20 44 49 53 50 4c 41 59
>2cd0	20 4d 41 52 4b 45 52 53 00 2e 0e 50 00 ce 92 46
>2ce0	52 aa 31 2c 33 38 00 38 0e 51 00 99 22 20 22 3b
>2cf0	00 49 0e 52 00 8b 28 52 59 b1 38 29 a7 52 59 b2
>2d00	31 00 5a 0e 53 00 8b 28 52 59 b3 31 29 a7 52 59
>2d10	b2 38 00 64 0e 54 00 46 52 b2 52 59 00 72 0e 55
>2d20	00 ce 92 46 52 aa 31 2c 33 38 00 7f 0e 56 00 99
>2d30	c7 28 24 35 46 29 3b 00 8e 0e 57 00 ce 92 31 30
>2d40	2c 46 43 aa 32 39 00 98 0e 58 00 99 22 20 22 3b
>2d50	00 a9 0e 59 00 8b 28 43 59 b1 38 29 a7 43 59 b2
>2d60	31 00 ba 0e 5a 00 8b 28 43 59 b3 31 29 a7 43 59
>2d70	b2 38 00 c4 0e 5b 00 46 43 b2 43 59 00 d3 0e 5c
>2d80	00 ce 92 31 30 2c 46 43 aa 32 39 00 dd 0e 5d 00
>2d90	99 22 5e 22 3b 00 02 0f 5e 00 44 b2 24 46 30 30
>2da0	30 aa 28 28 28 28 43 52 ab 31 29 ac 31 36 29 aa
>2db0	28 43 43 ab 31 29 29 ac 38 29 00 0c 0f 5f 00 ce
>2dc0	8d 33 2c 36 00 17 0f 60 00 81 49 b2 31 a4 38 00
>2dd0	24 0f 61 00 ce 92 31 aa 49 2c 32 34 00 34 0f 62
>2de0	00 99 22 24 22 3b ce d5 28 44 29 3b 00 42 0f 63
>2df0	00 56 b2 ce d0 28 31 2c 44 29 00 4f 0f 64 00 ce
>2e00	92 31 aa 49 2c 33 30 00 5b 0f 65 00 99 ce d6 28
>2e10	56 29 3b 00 65 0f 66 00 44 b2 44 aa 31 00 6c 0f
>2e20	67 00 82 49 00 77 0f 68 00 ce 92 31 2c 31 37 00
>2e30	84 0f 69 00 99 22 20 20 20 20 22 3b 00 8f 0f 6a
>2e40	00 ce 92 31 2c 31 37 00 a9 0f 6b 00 99 28 28 28
>2e50	43 52 ab 31 29 ac 31 36 29 aa 28 43 43 ab 31 29
>2e60	29 00 b4 0f 6c 00 58 b2 43 43 aa 31 00 bf 0f 6d
>2e70	00 59 b2 43 52 aa 31 00 c9 0f 6e 00 44 b2 24 45
>2e80	37 00 d2 0f 6f 00 8d 33 34 38 00 de 0f 70 00 58
>2e90	b2 46 43 aa 32 39 00 e9 0f 71 00 59 b2 46 52 aa
>2ea0	31 00 fd 0f 72 00 8f 20 28 55 53 45 20 53 41 4d
>2eb0	45 20 ce 8d 29 00 06 10 73 00 8d 33 34 38 00 0c
>2ec0	10 74 00 8e 00 14 10 75 00 58 b2 31 00 1d 10 76
>2ed0	00 59 b2 32 32 00 26 10 77 00 49 b2 4b 31 00 2f
>2ee0	10 78 00 49 32 b2 30 00 39 10 79 00 ce 8d 31 2c
>2ef0	36 00 42 10 7a 00 5a 5a b2 30 00 67 10 7b 00 8b
>2f00	28 28 49 b1 b2 33 32 29 af 28 49 b3 b2 31 32 37
>2f10	29 29 a7 5a 5a b2 31 3a 8f 20 99 41 42 4c 45 00
>2f20	8d 10 7c 00 8b 28 28 49 b1 b2 31 36 30 29 af 28
>2f30	49 b3 b2 32 35 35 29 29 a7 5a 5a b2 31 3a 8f 20
>2f40	99 41 42 4c 45 00 9f 10 7d 00 ce 92 59 2c 58 3a
>2f50	99 22 20 20 20 22 3b 00 b1 10 7e 00 ce 92 59 2c
>2f60	58 3a 99 ce d5 28 49 29 3b 00 bd 10 7f 00 ce 92
>2f70	59 2c 58 aa 33 00 da 10 80 00 8b 28 5a 5a b2 30
>2f80	29 a7 99 22 2e 22 3b 3a 8f 20 4e 91 ab 99 41 42
>2f90	4c 45 00 ee 10 81 00 8b 28 5a 5a b3 b1 30 29 a7
>2fa0	99 c7 28 49 29 3b 00 00 11 82 00 58 b2 58 aa 35
>2fb0	3a 49 32 b2 49 32 aa 31 00 16 11 83 00 8b 28 58
>2fc0	b1 34 30 29 a7 59 b2 59 aa 31 3a 58 b2 31 00 20
>2fd0	11 84 00 49 b2 49 aa 31 00 32 11 85 00 8b 28 49
>2fe0	32 b1 36 33 29 a7 89 31 33 35 00 3b 11 86 00 89
>2ff0	31 32 32 00 41 11 87 00 8e 00 49 11 88 00 58 b2
>3000	32 00 51 11 89 00 59 b2 32 00 59 11 8a 00 44 b2
>3010	30 00 6b 11 8b 00 8b 28 44 b1 32 35 35 29 a7 89
>3020	31 34 35 00 74 11 8c 00 8d 33 34 33 00 7e 11 8d
>3030	00 58 b2 58 aa 31 00 94 11 8e 00 8b 28 58 b1 31
>3040	37 29 a7 59 b2 59 aa 31 3a 58 b2 32 00 9e 11 8f
>3050	00 44 b2 44 aa 31 00 a7 11 90 00 89 31 33 39 00
>3060	b7 11 91 00 8f 20 44 49 53 50 4c 41 59 20 80 00
>3070	bd 11 92 00 8e 00 e2 11 93 00 44 b2 24 46 30 30
>3080	30 aa 28 28 28 28 43 52 ab 31 29 ac 31 36 29 aa
>3090	28 43 43 ab 31 29 29 ac 38 29 00 07 12 94 00 44
>30a0	b2 44 aa 28 46 52 ab 31 29 3a 8f 20 49 4e 43 8f
>30b0	45 4e 54 20 54 48 45 20 46 91 54 20 52 4f 57 00
>30c0	15 12 95 00 56 b2 ce d0 28 31 2c 44 29 00 1f 12
>30d0	96 00 54 b2 32 35 36 00 2e 12 97 00 81 49 b2 46
>30e0	43 a4 31 a9 ab 31 00 3b 12 98 00 54 b2 b5 28 54
>30f0	ad 32 29 00 42 12 99 00 82 49 00 56 12 9a 00 56
>3100	b2 28 56 aa 54 29 ab 32 ac 28 56 af 54 29 00 62
>3110	12 9b 00 ce 84 31 2c 44 2c 56 00 6b 12 9c 00 8d
>3120	33 35 33 00 71 12 9d 00 8e 00 7b 12 9e 00 ce 8d
>3130	37 2c 36 00 86 12 9f 00 ce 92 32 2c 31 39 00 93
>3140	12 a0 00 99 22 57 41 49 54 22 3b 00 9e 12 a1 00
>3150	ce 92 33 2c 31 39 00 aa 12 a2 00 99 22 45 58 50
>3160	22 3b 00 b7 12 a3 00 55 31 b2 24 46 30 30 30 00
>3170	c5 12 a4 00 55 32 b2 55 31 aa 31 32 37 00 ce 12
>3180	a5 00 49 4e b2 31 00 f6 12 a6 00 58 b2 32 38 30
>3190	30 30 aa 28 43 52 ac 32 30 30 30 29 3a 8f 20 42
>31a0	41 53 49 43 20 ce 88 20 4e 55 ce d3 45 52 00 ff
>31b0	12 a7 00 49 32 b2 30 00 08 13 a8 00 49 33 b2 31
>31c0	00 1a 13 a9 00 8b 28 49 4e b2 43 52 29 a7 89 31
>31d0	37 32 00 45 13 aa 00 49 32 b2 49 32 aa 31 32 38
>31e0	3a 8f 20 41 43 43 4f 55 4e 54 20 81 20 a8 20 4f
>31f0	55 54 50 55 54 49 4e 47 20 54 48 49 53 00 4e 13
>3200	ab 00 89 31 38 38 00 82 13 ac 00 46 24 b2 22 40
>3210	3a 46 4f 4e 54 22 aa c4 28 49 4e 29 aa 22 2e 42
>3220	41 53 2c 53 2c 57 22 3a 8f 20 53 45 51 55 45 4e
>3230	54 49 41 4c 20 57 52 49 54 45 00 90 13 ad 00 9f
>3240	31 2c 38 2c 32 2c 46 24 00 9b 13 ae 00 ce 92 31
>3250	39 2c 31 00 a8 13 af 00 99 22 20 20 20 20 20 22
>3260	00 b3 13 b0 00 ce 92 31 39 2c 31 00 bb 13 b1 00
>3270	99 53 54 00 c8 13 b2 00 81 49 b2 55 31 a4 55 32
>3280	00 f5 13 b3 00 8b 28 49 33 b2 31 29 a7 98 31 2c
>3290	58 3b 22 20 52 45 4d 20 46 4f 4e 54 20 22 3b b5
>32a0	28 49 32 ad 38 29 3a 58 b2 58 aa 31 30 00 03 14
>32b0	b4 00 56 b2 ce d0 28 31 2c 49 29 00 2a 14 b5 00
>32c0	98 31 2c 58 3b 22 20 56 50 4f 4b 45 20 31 2c 24
>32d0	22 3b ce d5 28 49 29 3b 22 2c 25 22 2c ce d6 28
>32e0	56 29 00 35 14 b6 00 58 b2 58 aa 31 30 00 41 14
>32f0	b7 00 49 33 b2 49 33 aa 31 00 52 14 b8 00 8b 28
>3300	49 33 b1 38 29 a7 49 33 b2 31 00 5e 14 b9 00 49
>3310	32 b2 49 32 aa 31 00 65 14 ba 00 82 49 00 6c 14
>3320	bb 00 a0 31 00 9a 14 bc 00 8b 28 49 4e b3 31 36
>3330	29 a7 49 4e b2 49 4e aa 31 3a 55 31 b2 55 31 aa
>3340	31 32 38 3a 55 32 b2 55 32 aa 31 32 38 3a 89 31
>3350	36 39 00 a4 14 bd 00 ce 8d 31 2c 36 00 af 14 be
>3360	00 ce 92 32 2c 31 39 00 bc 14 bf 00 99 22 20 20
>3370	20 20 22 3b 00 c7 14 c0 00 ce 92 33 2c 31 39 00
>3380	d4 14 c1 00 99 22 20 20 20 20 22 3b 00 df 14 c2
>3390	00 ce 92 34 2c 31 39 00 ec 14 c3 00 99 22 20 20
>33a0	20 20 22 3b 00 f2 14 c4 00 8e 00 fc 14 c5 00 ce
>33b0	8d 37 2c 36 00 07 15 c6 00 ce 92 32 2c 31 39 00
>33c0	14 15 c7 00 99 22 57 41 49 54 22 3b 00 1f 15 c8
>33d0	00 ce 92 33 2c 31 39 00 2c 15 c9 00 99 22 53 41
>33e0	56 45 22 3b 00 63 15 ca 00 46 24 b2 22 40 3a 58
>33f0	31 36 46 4f 4e 54 22 aa c4 28 43 52 29 aa 22 2e
>3400	44 41 54 2c 53 2c 57 22 3a 8f 20 53 45 51 55 45
>3410	4e 54 49 41 4c 20 57 52 49 54 45 00 71 15 cb 00
>3420	9f 31 2c 38 2c 32 2c 46 24 00 7c 15 cc 00 ce 92
>3430	31 39 2c 31 00 89 15 cd 00 99 22 20 20 20 20 20
>3440	22 00 94 15 ce 00 ce 92 31 39 2c 31 00 9c 15 cf
>3450	00 99 53 54 00 b7 15 d0 00 8b 28 53 54 b2 30 29
>3460	a7 ce 92 43 52 aa 31 2c 31 3a 99 22 20 22 3b 00
>3470	cf 15 d1 00 55 31 b2 24 46 30 30 30 aa 28 43 52
>3480	ab 31 29 ac 31 32 38 00 f0 15 d2 00 55 32 b2 55
>3490	31 aa 31 32 37 3a 8f 20 31 36 20 42 59 54 45 53
>34a0	20 50 45 52 20 52 4f 57 00 0d 16 d3 00 81 49 b2
>34b0	55 31 a4 55 32 3a 8f 20 24 46 30 30 30 20 a4 20
>34c0	24 46 37 46 46 00 1b 16 d4 00 56 b2 ce d0 28 31
>34d0	2c 49 29 00 24 16 d5 00 98 31 2c 56 00 2b 16 d6
>34e0	00 82 49 00 32 16 d7 00 a0 31 00 3c 16 d8 00 ce
>34f0	8d 31 2c 36 00 47 16 d9 00 ce 92 32 2c 31 39 00
>3500	54 16 da 00 99 22 20 20 20 20 22 3b 00 5f 16 db
>3510	00 ce 92 33 2c 31 39 00 6c 16 dc 00 99 22 20 20
>3520	20 20 22 3b 00 77 16 dd 00 ce 92 34 2c 31 39 00
>3530	84 16 de 00 99 22 20 20 20 20 22 3b 00 8a 16 df
>3540	00 8e 00 94 16 e0 00 ce 8d 37 2c 36 00 9f 16 e1
>3550	00 ce 92 32 2c 31 39 00 ac 16 e2 00 99 22 57 41
>3560	49 54 22 3b 00 b7 16 e3 00 ce 92 33 2c 31 39 00
>3570	c4 16 e4 00 99 22 4c 4f 41 44 22 3b 00 f5 16 e5
>3580	00 46 24 b2 22 58 31 36 46 4f 4e 54 22 aa c4 28
>3590	43 52 29 aa 22 2e 44 41 54 2c 53 2c 52 22 3a 8f
>35a0	20 53 45 51 55 45 4e 54 49 41 4c 20 87 00 03 17
>35b0	e6 00 9f 31 2c 38 2c 32 2c 46 24 00 0e 17 e7 00
>35c0	ce 92 31 39 2c 31 00 1b 17 e8 00 99 22 20 20 20
>35d0	20 20 22 00 26 17 e9 00 ce 92 31 39 2c 31 00 2e
>35e0	17 ea 00 99 53 54 00 49 17 eb 00 8b 28 53 54 b2
>35f0	30 29 a7 ce 92 43 52 aa 31 2c 31 3a 99 22 20 22
>3600	3b 00 61 17 ec 00 55 31 b2 24 46 30 30 30 aa 28
>3610	43 52 ab 31 29 ac 31 32 38 00 81 17 ed 00 55 32
>3620	b2 55 31 aa 31 32 37 3a 8f 20 38 20 42 59 54 45
>3630	53 20 50 45 52 20 46 91 54 00 9e 17 ee 00 81 49
>3640	b2 55 31 a4 55 32 3a 8f 20 24 46 30 30 30 20 a4
>3650	20 24 46 37 46 46 00 a7 17 ef 00 84 31 2c 56 00
>3660	b3 17 f0 00 ce 84 31 2c 49 2c 56 00 ba 17 f1 00
>3670	82 49 00 c1 17 f2 00 a0 31 00 cb 17 f3 00 ce 8d
>3680	31 2c 36 00 d6 17 f4 00 ce 92 32 2c 31 39 00 e3
>3690	17 f5 00 99 22 20 20 20 20 22 3b 00 ee 17 f6 00
>36a0	ce 92 33 2c 31 39 00 fb 17 f7 00 99 22 20 20 20
>36b0	20 22 3b 00 01 18 f8 00 8e 00 28 18 f9 00 ce 8d
>36c0	31 32 2c 36 3a 8f 20 20 20 20 31 32 33 34 35 36
>36d0	37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32
>36e0	00 4f 18 fa 00 ce 92 31 31 2c 31 39 3a 99 22 41
>36f0	52 52 4f 57 20 4b 45 59 53 20 20 20 4d 4f 56 45
>3700	20 46 4f 4e 54 22 3b 00 76 18 fb 00 ce 92 31 32
>3710	2c 31 39 3a 99 22 57 2d 41 2d 53 2d 44 20 20 20
>3720	4d 4f 56 45 20 44 49 53 50 4c 41 59 22 3b 00 9d
>3730	18 fc 00 ce 92 31 33 2c 31 39 3a 99 22 53 50 41
>3740	43 45 20 20 54 4f 47 47 4c 45 20 46 4f 4e 54 20
>3750	42 49 54 22 3b 00 c4 18 fd 00 ce 92 31 34 2c 31
>3760	39 3a 99 22 56 20 20 53 41 56 45 20 20 20 58 31
>3770	36 46 4f 4e 54 4e 2e 44 41 54 22 3b 00 eb 18 fe
>3780	00 ce 92 31 35 2c 31 39 3a 99 22 4c 20 20 4c 4f
>3790	41 44 20 20 20 58 31 36 46 4f 4e 54 4e 2e 44 41
>37a0	54 22 3b 00 12 19 ff 00 ce 92 31 36 2c 31 39 3a
>37b0	99 22 58 20 20 45 58 50 4f 52 54 20 20 20 20 46
>37c0	4f 4e 54 4e 2e 42 41 53 22 3b 00 39 19 00 01 ce
>37d0	92 31 37 2c 31 39 3a 99 22 49 20 20 49 4e 56 45
>37e0	52 54 20 52 4f 57 2d 43 4f 4c 2d 42 4f 54 48 22
>37f0	3b 00 60 19 01 01 ce 92 31 38 2c 31 39 3a 99 22
>3800	43 20 20 43 4c 45 41 52 20 41 4c 4c 2f 45 3d 53
>3810	45 54 20 41 4c 4c 22 3b 00 87 19 02 01 ce 92 31
>3820	39 2c 31 39 3a 99 22 5b 20 5d 20 20 44 45 43 20
>3830	2f 20 49 4e 43 20 44 49 53 50 4c 41 59 22 3b 00
>3840	ae 19 03 01 ce 92 32 30 2c 31 39 3a 99 22 4b 20
>3850	20 43 4f 50 59 20 20 20 20 20 2f 20 45 53 43 20
>3860	45 58 49 54 22 3b 00 ed 19 04 01 8f 20 20 20 20
>3870	20 20 20 20 20 20 20 20 20 20 20 20 20 31 32 33
>3880	34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39
>3890	30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35
>38a0	36 37 38 39 30 00 23 1a 05 01 ce 92 33 30 2c 31
>38b0	3a 99 22 55 53 45 20 53 48 49 46 54 2b 41 4c 54
>38c0	20 54 4f 20 52 45 53 54 4f 52 45 20 4f 52 49 47
>38d0	49 4e 41 4c 20 46 4f 4e 54 22 3b 00 2d 1a 06 01
>38e0	ce 8d 31 2c 36 00 33 1a 07 01 8e 00 58 1a 08 01
>38f0	44 b2 24 46 30 30 30 aa 28 28 28 28 43 52 ab 31
>3900	29 ac 31 36 29 aa 28 43 43 ab 31 29 29 ac 38 29
>3910	00 62 1a 09 01 43 41 b2 46 52 00 6e 1a 0a 01 81
>3920	46 52 b2 31 a4 38 00 7e 1a 0b 01 44 31 b2 44 aa
>3930	28 46 52 ab 31 29 00 88 1a 0c 01 56 b2 24 30 30
>3940	00 95 1a 0d 01 ce 84 31 2c 44 31 2c 56 00 9d 1a
>3950	0e 01 82 46 52 00 a7 1a 0f 01 46 52 b2 43 41 00
>3960	b0 1a 10 01 8d 33 35 33 00 b6 1a 11 01 8e 00 db
>3970	1a 12 01 44 b2 24 46 30 30 30 aa 28 28 28 28 43
>3980	52 ab 31 29 ac 31 36 29 aa 28 43 43 ab 31 29 29
>3990	ac 38 29 00 e5 1a 13 01 43 41 b2 46 52 00 f1 1a
>39a0	14 01 81 46 52 b2 31 a4 38 00 01 1b 15 01 44 31
>39b0	b2 44 aa 28 46 52 ab 31 29 00 0b 1b 16 01 56 b2
>39c0	24 46 46 00 18 1b 17 01 ce 84 31 2c 44 31 2c 56
>39d0	00 20 1b 18 01 82 46 52 00 2a 1b 19 01 46 52 b2
>39e0	43 41 00 33 1b 1a 01 8d 33 35 33 00 39 1b 1b 01
>39f0	8e 00 45 1b 1c 01 ce 92 32 31 2c 31 38 00 4f 1b
>3a00	1d 01 ce 8d 37 2c 36 00 65 1b 1e 01 99 22 57 48
>3a10	49 43 48 20 28 30 2d 32 35 35 29 22 3b 00 6c 1b
>3a20	1f 01 85 41 00 a7 1b 20 01 8b 28 41 b2 28 28 28
>3a30	43 52 ab 31 29 ac 31 36 29 aa 28 43 43 ab 31 29
>3a40	ac 38 29 29 a7 89 32 39 36 3a 8f 20 54 41 52 a1
>3a50	ad 53 4f 55 52 43 45 20 49 53 20 53 41 4d 45 00
>3a60	d3 1b 21 01 44 b2 24 46 30 30 30 aa 28 28 28 28
>3a70	43 52 ab 31 29 ac 31 36 29 aa 28 43 43 ab 31 29
>3a80	29 ac 38 29 3a 8f 20 54 41 52 a1 00 ef 1b 22 01
>3a90	44 31 b2 24 46 30 30 30 aa 28 41 ac 38 29 3a 8f
>3aa0	20 53 4f 55 52 43 45 00 fa 1b 23 01 81 49 b2 30
>3ab0	a4 37 00 0b 1c 24 01 56 b2 ce d0 28 31 2c 44 31
>3ac0	aa 49 29 00 19 1c 25 01 ce 84 31 2c 44 aa 49 2c
>3ad0	56 00 20 1c 26 01 82 49 00 29 1c 27 01 8d 33 35
>3ae0	33 00 35 1c 28 01 ce 92 32 31 2c 31 38 00 3f 1c
>3af0	29 01 ce 8d 31 2c 36 00 5e 1c 2a 01 99 22 20 20
>3b00	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
>3b10	20 20 20 20 22 3b 00 66 1c 2b 01 41 b2 30 00 6c
>3b20	1c 2c 01 8e 00 74 1c 2d 01 99 22 22 00 80 1c 2e
>3b30	01 ce 92 32 31 2c 31 38 00 8a 1c 2f 01 ce 8d 37
>3b40	2c 36 00 a9 1c 30 01 99 22 43 3d 43 4f 4c 2c 52
>3b50	2d 52 4f 57 2c 42 2d 42 4f 54 48 2f 45 53 43 22
>3b60	3b 00 b1 1c 31 01 41 b2 30 00 b9 1c 32 01 a1 41
>3b70	24 00 c5 1c 33 01 41 b2 c6 28 41 24 29 00 d3 1c
>3b80	34 01 8b 41 b2 30 a7 89 33 30 36 00 ec 1c 35 01
>3b90	8b 41 b2 36 37 a7 89 33 32 33 3a 8f 20 4f 50 54
>3ba0	49 91 20 43 00 05 1d 36 01 8b 41 b2 38 32 a7 89
>3bb0	33 33 30 3a 8f 20 4f 50 54 49 91 20 52 00 1d 1d
>3bc0	37 01 8b 41 b2 32 37 a7 89 33 33 37 3a 8f 20 45
>3bd0	53 43 41 50 45 00 27 1d 38 01 43 41 b2 46 43 00
>3be0	31 1d 39 01 43 42 b2 46 52 00 3d 1d 3a 01 81 46
>3bf0	43 b2 31 a4 38 00 49 1d 3b 01 81 46 52 b2 31 a4
>3c00	38 00 52 1d 3c 01 8d 31 34 37 00 5a 1d 3d 01 82
>3c10	46 52 00 62 1d 3e 01 82 46 43 00 6c 1d 3f 01 46
>3c20	43 b2 43 41 00 76 1d 40 01 46 52 b2 43 42 00 7f
>3c30	1d 41 01 8d 33 35 33 00 88 1d 42 01 89 33 33 37
>3c40	00 92 1d 43 01 43 41 b2 46 52 00 9e 1d 44 01 81
>3c50	46 52 b2 31 a4 38 00 a7 1d 45 01 8d 31 34 37 00
>3c60	af 1d 46 01 82 46 52 00 b9 1d 47 01 46 52 b2 43
>3c70	41 00 c2 1d 48 01 8d 33 35 33 00 cb 1d 49 01 89
>3c80	33 33 37 00 d5 1d 4a 01 43 41 b2 46 43 00 e1 1d
>3c90	4b 01 81 46 43 b2 31 a4 38 00 ea 1d 4c 01 8d 31
>3ca0	34 37 00 f2 1d 4d 01 82 46 43 00 fc 1d 4e 01 46
>3cb0	43 b2 43 41 00 05 1e 4f 01 8d 33 35 33 00 0e 1e
>3cc0	50 01 89 33 33 37 00 1a 1e 51 01 ce 92 32 31 2c
>3cd0	31 38 00 24 1e 52 01 ce 8d 31 2c 36 00 44 1e 53
>3ce0	01 8f 20 20 20 20 31 32 33 34 35 36 37 38 39 30
>3cf0	31 32 33 34 35 36 37 38 39 30 31 32 00 63 1e 54
>3d00	01 99 22 20 20 20 20 20 20 20 20 20 20 20 20 20
>3d10	20 20 20 20 20 20 20 20 20 22 3b 00 6b 1e 55 01
>3d20	41 b2 30 00 71 1e 56 01 8e 00 84 1e 57 01 97 24
>3d30	39 46 32 30 2c 28 58 ab 31 29 ac 32 00 95 1e 58
>3d40	01 97 24 39 46 32 31 2c 52 4f 28 59 29 00 a4 1e
>3d50	59 01 97 24 39 46 32 32 2c 24 32 31 00 b1 1e 5a
>3d60	01 97 24 39 46 32 33 2c 44 00 b7 1e 5b 01 8e 00
>3d70	ce 1e 5c 01 97 24 39 46 32 30 2c 28 28 58 ab 31
>3d80	29 ac 32 29 aa 31 00 df 1e 5d 01 97 24 39 46 32
>3d90	31 2c 52 4f 28 59 29 00 ee 1e 5e 01 97 24 39 46
>3da0	32 32 2c 24 32 31 00 fb 1e 5f 01 97 24 39 46 32
>3db0	33 2c 44 00 01 1f 60 01 8e 00 12 1f 61 01 ce 92
>3dc0	43 52 aa 31 3a 99 22 2a 22 3b 00 18 1f 62 01 8e
>3dd0	00 23 1f 63 01 ce 92 32 39 2c 31 00 29 1f 64 01
>3de0	80 00 00 00

;******  End of listing
