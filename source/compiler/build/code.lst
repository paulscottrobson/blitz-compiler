
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Mon Oct  9 02:17:48 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.0801					WrapperBoot:
.0801	a2 0b		ldx #$0b			ldx 	#APIDesc & $FF
.0803	a0 08		ldy #$08			ldy 	#APIDesc >> 8
.0805	20 75 09	jsr $0975			jsr 	StartCompiler
.0808	4c ff ff	jmp $ffff			jmp 	$FFFF
.080b					APIDesc:
>080b	0f 08						.word 	TestAPI 					; the testing API.
>080d	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>080e	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing file: testing/api/api.asm

=$a000					PCodeMemory = $A000
.080f					TestAPI:
.080f	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.0811	f0 19		beq $082c			beq 	_TAOpenIn
.0813	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.0815	f0 1d		beq $0834			beq 	_TACloseIn
.0817	c9 02		cmp #$02			cmp 	#BLC_READIN
.0819	f0 1a		beq $0835			beq 	_TARead
.081b	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.081d	f0 19		beq $0838			beq 	_TAResetOut
.081f	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.0821	f0 22		beq $0845			beq 	_TACloseOut
.0823	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.0825	f0 28		beq $084f			beq 	_TAWriteByte
.0827	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.0829	f0 2e		beq $0859			beq 	_TAPrintScreen
>082b	db						.byte 	$DB 						; causes a break in the emulator
.082c					_TAOpenIn:
.082c	a9 d0		lda #$d0			lda 	#((EndProgram+2) & $FF)
.082e	85 22		sta $22				sta 	0+srcInputPtr
.0830	a9 1e		lda #$1e			lda 	#((EndProgram+2) >> 8) & $FF
.0832	85 23		sta $23				sta 	1+srcInputPtr
.0834					_TACloseIn:
.0834	60		rts				rts
.0835					_TARead:
.0835	4c 5d 08	jmp $085d			jmp 	ReadNextLine
.0838					_TAResetOut:
.0838	a9 01		lda #$01			lda 	#1
.083a	85 00		sta $00				sta 	0
.083c	a9 00		lda #$00			lda 	#((PCodeMemory) & $FF)
.083e	85 28		sta $28				sta 	0+objPtr
.0840	a9 a0		lda #$a0			lda 	#((PCodeMemory) >> 8) & $FF
.0842	85 29		sta $29				sta 	1+objPtr
.0844	60		rts				rts
.0845					_TACloseOut:
.0845	a9 a0		lda #$a0			lda 	#PCodeMemory >> 8
.0847	a6 28		ldx $28				ldx 	objPtr
.0849	a4 29		ldy $29				ldy 	objPtr+1
.084b	20 82 08	jsr $0882			jsr 	APISaveMemory
.084e	60		rts				rts
.084f					_TAWriteByte:
.084f	8a		txa				txa
.0850	92 28		sta ($28)			sta 	(objPtr)
.0852	e6 28		inc $28				inc 	objPtr
.0854	d0 02		bne $0858			bne 	_HWOWBNoCarry
.0856	e6 29		inc $29				inc 	objPtr+1
.0858					_HWOWBNoCarry:
.0858	60		rts				rts
.0859					_TAPrintScreen:
.0859	8a		txa				txa
.085a	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.0022					srcInputPtr:
>0022							.fill 	2

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/line.asm

.085d					ReadNextLine:
.085d	b2 22		lda ($22)			lda 	(srcInputPtr) 				; reached the end of the program (address link = $0000)
.085f	a0 01		ldy #$01			ldy 	#1
.0861	11 22		ora ($22),y			ora 	(srcInputPtr),y
.0863	d0 02		bne $0867			bne 	_RLAHaveData
.0865	18		clc				clc
.0866	60		rts				rts									; end of file.
.0867					_RLAHaveData:
.0867	a6 22		ldx $22				ldx 	srcInputPtr 				; remember the line start
.0869	a4 23		ldy $23				ldy 	srcInputPtr+1
.086b	5a		phy				phy
.086c	a0 04		ldy #$04			ldy 	#4 							; must be at least four bytes (address/line#)
.086e					_RNLRead:
.086e	b1 22		lda ($22),y			lda 	(srcInputPtr),y 			; find the end of the line.
.0870	c8		iny				iny
.0871	c9 00		cmp #$00			cmp 	#0
.0873	d0 f9		bne $086e			bne 	_RNLRead
.0875	98		tya				tya 								; advance src input pointer to next.
.0876	18		clc				clc
.0877	65 22		adc $22				adc 	srcInputPtr
.0879	85 22		sta $22				sta 	srcInputPtr
.087b	90 02		bcc $087f			bcc 	_RNLNoCarry
.087d	e6 23		inc $23				inc 	srcInputPtr+1
.087f					_RNLNoCarry:
.087f	7a		ply				ply 								; address of line now in YX.
.0880	38		sec				sec
.0881	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/save.asm

.0882					APISaveMemory:
.0882	da		phx				phx
.0883	5a		phy				phy
.0884	48		pha				pha
.0885	a9 00		lda #$00			lda 	#0 							; set LFS
.0887	a2 08		ldx #$08			ldx 	#8
.0889	a0 00		ldy #$00			ldy 	#0
.088b	20 ba ff	jsr $ffba			jsr 	$FFBA
.088e	a9 08		lda #$08			lda 	#8 							; set file name
.0890	a2 a4		ldx #$a4			ldx 	#SaveName & $FF
.0892	a0 08		ldy #$08			ldy 	#SaveName >> 8
.0894	20 bd ff	jsr $ffbd			jsr 	$FFBD
.0897	68		pla				pla 								; set up the start address.
.0898	85 2b		sta $2b				sta 	zTemp0+1
.089a	64 2a		stz $2a				stz 	zTemp0
.089c	a9 2a		lda #$2a			lda 	#zTemp0 					; from index.
.089e	7a		ply				ply 								; end in YX
.089f	fa		plx				plx
.08a0	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.08a3	60		rts				rts
.08a4					SaveName:
>08a4	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Return to file: testing/testing.asm


;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.0024					srcPtr:
>0024							.fill 	2
.0400					currentLineNumber:
>0400							.fill 	2
.08ac					InlineNonDecimal:
.08ac	a2 02		ldx #$02			ldx 	#2 							; get size in X
.08ae	c9 25		cmp #$25			cmp 	#"%"
.08b0	f0 02		beq $08b4			beq 	_INDBinary
.08b2	a2 10		ldx #$10			ldx 	#16
.08b4					_INDBinary:
.08b4	85 2c		sta $2c				sta 	zTemp1 						; size => zTemp1
.08b6	64 2d		stz $2d				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.08b8	64 2a		stz $2a				stz 	zTemp0 						; zero result
.08ba	64 2b		stz $2b				stz 	zTemp0+1
.08bc					_INDLoop:
.08bc	20 58 12	jsr $1258			jsr 	LookNext 					; check next character
.08bf	20 94 12	jsr $1294			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.08c2	90 1f		bcc $08e3			bcc		_INDDone 					; didn't convert
.08c4	c5 2c		cmp $2c				cmp 	zTemp1 						; size too large ?
.08c6	b0 1b		bcs $08e3			bcs 	_INDDone
.08c8	20 f2 08	jsr $08f2			jsr 	_INDShift 					; x 2 or x 16
.08cb	e0 02		cpx #$02			cpx 	#2
.08cd	f0 09		beq $08d8			beq 	_INDNotHex
.08cf	20 f2 08	jsr $08f2			jsr 	_INDShift
.08d2	20 f2 08	jsr $08f2			jsr 	_INDShift
.08d5	20 f2 08	jsr $08f2			jsr 	_INDShift
.08d8					_INDNotHex:
.08d8	05 2a		ora $2a				ora 	zTemp0 						; or digit into result
.08da	85 2a		sta $2a				sta 	zTemp0
.08dc	20 69 12	jsr $1269			jsr 	GetNext 					; consume
.08df	e6 2d		inc $2d				inc 	zTemp1+1 					; bump count
.08e1	80 d9		bra $08bc			bra 	_INDLoop
.08e3					_INDDone:
.08e3	a5 2d		lda $2d				lda 	zTemp1+1 					; done at least 1 ?
.08e5	f0 08		beq $08ef			beq 	_INDError
.08e7	a4 2b		ldy $2b				ldy 	zTemp0+1 					; push constant
.08e9	a5 2a		lda $2a				lda 	zTemp0
.08eb	20 13 0a	jsr $0a13			jsr 	PushIntegerYA
.08ee	60		rts				rts
.08ef					_INDError:
.08ef	4c 5d 17	jmp $175d		jmp	ErrorV_syntax
.08f2					_INDShift:
.08f2	06 2a		asl $2a				asl 	zTemp0
.08f4	26 2b		rol $2b				rol 	zTemp0+1
.08f6	60		rts				rts
.08f7					GetLineNumber:
.08f7	ac 01 04	ldy $0401			ldy 	currentLineNumber+1
.08fa	ad 00 04	lda $0400			lda 	currentLineNumber
.08fd	60		rts				rts
.08fe					WriteCodeByte:
.08fe	48		pha				pha 								; save on stack
.08ff	da		phx				phx
.0900	5a		phy				phy
.0901	aa		tax				tax
.0902	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.0904	20 10 0a	jsr $0a10			jsr 	CallAPIHandler
.0907	7a		ply				ply 								; restore from stack
.0908	fa		plx				plx
.0909	68		pla				pla
.090a	60		rts				rts
.090b					PrintCharacter
.090b	48		pha				pha
.090c	da		phx				phx
.090d	5a		phy				phy
.090e	aa		tax				tax
.090f	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.0911	20 10 0a	jsr $0a10			jsr 	CallAPIHandler
.0914	7a		ply				ply
.0915	fa		plx				plx
.0916	68		pla				pla
.0917	60		rts				rts
.0918					ProcessNewLine:
.0918	86 2a		stx $2a				stx 	zTemp0 						; save address in zTemp0
.091a	84 2b		sty $2b				sty 	zTemp0+1
.091c	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.091d	8a		txa				txa
.091e	69 04		adc #$04			adc 	#4
.0920	85 24		sta $24				sta 	srcPtr
.0922	98		tya				tya
.0923	69 00		adc #$00			adc 	#0
.0925	85 25		sta $25				sta 	srcPtr+1
.0927	a0 02		ldy #$02			ldy 	#2							; read and save line number
.0929	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.092b	8d 00 04	sta $0400			sta 	currentLineNumber
.092e	c8		iny				iny
.092f	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0931	8d 01 04	sta $0401			sta 	currentLineNumber+1
.0934	60		rts				rts
.0935					BufferClear:
.0935	9c 02 04	stz $0402			stz 	bufferSize
.0938	60		rts				rts
.0939					BufferWrite:
.0939	da		phx				phx
.093a	ae 02 04	ldx $0402			ldx 	bufferSize
.093d	9d 03 04	sta $0403,x			sta 	dataBuffer,x
.0940	ee 02 04	inc $0402			inc 	bufferSize
.0943	fa		plx				plx
.0944	60		rts				rts
.0945					BufferOutput:
.0945	ad 02 04	lda $0402			lda 	bufferSize
.0948	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.094b	a2 00		ldx #$00			ldx 	#0
.094d					_BOLoop:
.094d	ec 02 04	cpx $0402			cpx 	bufferSize
.0950	f0 09		beq $095b			beq 	_BOExit
.0952	bd 03 04	lda $0403,x			lda 	dataBuffer,x
.0955	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0958	e8		inx				inx
.0959	80 f2		bra $094d			bra 	_BOLoop
.095b					_BOExit:
.095b	60		rts				rts
.0402					bufferSize:
>0402							.fill 	1
.0403					dataBuffer:
>0403							.fill 	256
.095c					CheckNextComma:
.095c	a9 2c		lda #$2c			lda	 	#","
.095e	80 06		bra $0966			bra 	CheckNextA
.0960					CheckNextRParen:
.0960	a9 29		lda #$29			lda	 	#")"
.0962	80 02		bra $0966			bra 	CheckNextA
.0964					CheckNextLParen:
.0964	a9 28		lda #$28			lda 	#"("
.0966					CheckNextA:
.0966	8d 03 05	sta $0503			sta 	checkCharacter 				; save test character
.0969					_CNALoop:
.0969	20 74 12	jsr $1274			jsr 	GetNextNonSpace 			; get next skipping spaces.
.096c	cd 03 05	cmp $0503			cmp 	checkCharacter 				; matches ?
.096f	f0 03		beq $0974			beq 	_CNAExit
.0971	4c 5d 17	jmp $175d		jmp	ErrorV_syntax
.0974					_CNAExit:
.0974	60		rts				rts
.0503					checkCharacter:
>0503							.fill 	1
.0975					StartCompiler:
.0975	86 2a		stx $2a				stx 	zTemp0 						; access API
.0977	84 2b		sty $2b				sty 	zTemp0+1
.0979	a0 0b		ldy #$0b			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.097b	a2 cc		ldx #$cc			ldx 	#CompilerErrorHandler & $FF
.097d	20 36 17	jsr $1736			jsr 	SetErrorHandler
.0980	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.0982	b2 2a		lda ($2a)			lda 	(zTemp0)
.0984	8d 05 05	sta $0505			sta 	APIVector
.0987	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0989	8d 06 05	sta $0506			sta 	APIVector+1
.098c	c8		iny				iny 								; copy data area range.
.098d	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.098f	8d 07 05	sta $0507			sta 	compilerStartHigh
.0992	c8		iny				iny
.0993	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0995	8d 08 05	sta $0508			sta 	compilerEndHigh
.0998	ba		tsx				tsx 								; save stack pointer
.0999	8e 04 05	stx $0504			stx 	compilerSP
.099c	20 f8 15	jsr $15f8			jsr 	STRReset 					; reset storage (line#, variable)
.099f	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.09a1	20 10 0a	jsr $0a10			jsr 	CallAPIHandler
.09a4	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.09a6	20 10 0a	jsr $0a10			jsr 	CallAPIHandler
.09a9	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.09ab	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.09ae	a9 00		lda #$00			lda 	#0
.09b0	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.09b3	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.09b6					MainCompileLoop:
.09b6	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.09b8	20 10 0a	jsr $0a10			jsr 	CallAPIHandler
.09bb	90 31		bcc $09ee			bcc 	SaveCodeAndExit 			; end of source.
.09bd	20 18 09	jsr $0918			jsr 	ProcessNewLine 				; set up pointer and line number.
.09c0	20 f7 08	jsr $08f7			jsr 	GetLineNumber 				; get line #
.09c3	20 e2 13	jsr $13e2			jsr 	STRMarkLine 				; remember the code position and number of this line.
.09c6	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.09c8	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.09cb					_MCLSameLine:
.09cb	20 74 12	jsr $1274			jsr 	GetNextNonSpace 			; get the first character.
.09ce	f0 e6		beq $09b6			beq 	MainCompileLoop 			; end of line, get next line.
.09d0	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.09d2	f0 f7		beq $09cb			beq 	_MCLSameLine
.09d4	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.09d6	10 0c		bpl $09e4			bpl 	_MCLCheckAssignment
.09d8	a2 32		ldx #$32			ldx 	#CommandTables & $FF 		; do command tables.
.09da	a0 0e		ldy #$0e			ldy 	#CommandTables >> 8
.09dc	20 fa 10	jsr $10fa			jsr 	GeneratorProcess
.09df	b0 ea		bcs $09cb			bcs 	_MCLSameLine 				; keep trying to compile the line.
.09e1					_MCLSyntax:
.09e1	4c 5d 17	jmp $175d		jmp	ErrorV_syntax
.09e4					_MCLCheckAssignment:
.09e4	20 8a 12	jsr $128a			jsr 	CharIsAlpha 				; if not alpha then syntax error
.09e7	90 f8		bcc $09e1			bcc 	_MCLSyntax
.09e9	20 b0 13	jsr $13b0			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.09ec	80 dd		bra $09cb			bra		_MCLSameLine 				; loop back.
.09ee					SaveCodeAndExit:
.09ee	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.09f0	20 10 0a	jsr $0a10			jsr 	CallAPIHandler
.09f3	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.09f5	a8		tay				tay
.09f6	20 e2 13	jsr $13e2			jsr 	STRMarkLine
.09f9	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.09fb	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.09fe	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.0a00	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0a03	20 2a 0d	jsr $0d2a			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.0a06	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.0a08	20 10 0a	jsr $0a10			jsr 	CallAPIHandler
.0a0b					ExitCompiler:
.0a0b	ae 04 05	ldx $0504			ldx 	compilerSP 					; reload SP and exit.
.0a0e	9a		txs				txs
.0a0f	60		rts				rts
.0a10					CallAPIHandler:
.0a10	6c 05 05	jmp ($0505)			jmp 	(APIVector)
.0504					compilerSP:
>0504							.fill 	1
.0505					APIVector:
>0505							.fill 	2
.0507					compilerStartHigh:
>0507							.fill 	1
.0508					compilerEndHigh:
>0508							.fill 	1
.0a13					PushIntegerYA:
.0a13	c0 00		cpy #$00			cpy 	#0 							; 0-255
.0a15	f0 0f		beq $0a26			beq 	PushIntegerA
.0a17	48		pha				pha
.0a18	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.0a1a	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0a1d	68		pla				pla 								; then LSB
.0a1e	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0a21	98		tya				tya 								; then MSB
.0a22	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0a25	60		rts				rts
.0a26					PushIntegerA:
.0a26	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.0a28	90 07		bcc $0a31			bcc 	_PIWriteA
.0a2a	48		pha				pha
.0a2b	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.0a2d	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0a30	68		pla				pla
.0a31					_PIWriteA:
.0a31	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0a34	60		rts				rts
.0a35					PushFloatCommand:
.0a35	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.0a37	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0a3a	b5 6c		lda $6c,x			lda 	NSExponent,x 				; and the data
.0a3c	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0a3f	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.0a41	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0a44	b5 48		lda $48,x			lda 	NSMantissa1,x
.0a46	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0a49	b5 54		lda $54,x			lda 	NSMantissa2,x
.0a4b	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0a4e	b5 30		lda $30,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.0a50	29 80		and #$80			and 	#$80
.0a52	15 60		ora $60,x			ora 	NSMantissa3,x
.0a54	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0a57	60		rts				rts
.0a58					CreateVariableRecord:
.0a58	48		pha				pha
.0a59	ad 13 05	lda $0513			lda 	freeVariableMemory 		; push current free address on stack.
.0a5c	48		pha				pha
.0a5d	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.0a60	48		pha				pha
.0a61	ad 11 05	lda $0511			lda 	variableListEnd  		; copy end of list to zTemp0
.0a64	85 2a		sta $2a				sta 	zTemp0
.0a66	ad 12 05	lda $0512			lda 	variableListEnd+1
.0a69	85 2b		sta $2b				sta 	zTemp0+1
.0a6b	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.0a6d	92 2a		sta ($2a)			sta 	(zTemp0)
.0a6f	98		tya				tya
.0a70	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.0a72	91 2a		sta ($2a),y			sta 	(zTemp0),y
.0a74	88		dey				dey
.0a75	8a		txa				txa
.0a76	91 2a		sta ($2a),y			sta 	(zTemp0),y
.0a78	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.0a7a	ad 13 05	lda $0513			lda 	freeVariableMemory
.0a7d	91 2a		sta ($2a),y			sta 	(zTemp0),y
.0a7f	c8		iny				iny
.0a80	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.0a83	91 2a		sta ($2a),y			sta 	(zTemp0),y
.0a85	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.0a87	a9 00		lda #$00			lda 	#0
.0a89	91 2a		sta ($2a),y			sta 	(zTemp0),y
.0a8b	18		clc				clc
.0a8c	b2 2a		lda ($2a)			lda 	(zTemp0) 				; add offset to variableListEnd
.0a8e	6d 11 05	adc $0511			adc  	variableListEnd
.0a91	8d 11 05	sta $0511			sta 	variableListEnd
.0a94	90 03		bcc $0a99			bcc 	_CVNoCarry2
.0a96	ee 12 05	inc $0512			inc 	variableListEnd+1
.0a99					_CVNoCarry2:
.0a99	7a		ply				ply
.0a9a	fa		plx				plx
.0a9b	68		pla				pla
.0a9c	60		rts				rts
.0a9d					SetVariableRecordToCodePosition:
.0a9d	48		pha				pha
.0a9e	5a		phy				phy
.0a9f	a0 03		ldy #$03			ldy 	#3
.0aa1	a5 29		lda $29				lda 	objPtr+1
.0aa3	91 2a		sta ($2a),y			sta 	(zTemp0),y
.0aa5	c8		iny				iny
.0aa6	a5 28		lda $28				lda 	objPtr
.0aa8	91 2a		sta ($2a),y			sta 	(zTemp0),y
.0aaa	7a		ply				ply
.0aab	68		pla				pla
.0aac	60		rts				rts
.0aad					AllocateBytesForType:
.0aad	48		pha				pha
.0aae	da		phx				phx
.0aaf	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.0ab1	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0ab3	c9 00		cmp #$00			cmp 	#NSSIFloat
.0ab5	d0 02		bne $0ab9			bne 	_CVNotFloat
.0ab7	a2 06		ldx #$06			ldx 	#6
.0ab9					_CVNotFloat:
.0ab9	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.0aba	18		clc				clc
.0abb	6d 13 05	adc $0513			adc 	freeVariableMemory
.0abe	8d 13 05	sta $0513			sta 	freeVariableMemory
.0ac1	90 03		bcc $0ac6			bcc 	_CVNoCarry1
.0ac3	ee 14 05	inc $0514			inc 	freeVariableMemory+1
.0ac6					_CVNoCarry1:
.0ac6	fa		plx				plx
.0ac7	68		pla				pla
.0ac8	60		rts				rts
.0ac9					CommandDATA:
.0ac9	20 35 09	jsr $0935			jsr 	BufferClear 				; copy it to the buffer
.0acc	20 5b 12	jsr $125b			jsr 	LookNextNonSpace
.0acf					_CTDataLoop:
.0acf	20 58 12	jsr $1258			jsr 	LookNext 					; reached EOL
.0ad2	f0 08		beq $0adc			beq 	_CTDataDone
.0ad4	20 39 09	jsr $0939			jsr 	BufferWrite 				; write and consume
.0ad7	20 69 12	jsr $1269			jsr 	GetNext
.0ada	80 f3		bra $0acf			bra 	_CTDataLoop
.0adc					_CTDataDone:
.0adc	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.0ade	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0ae1	20 45 09	jsr $0945			jsr 	BufferOutput
.0ae4	60		rts				rts
.0ae5					CommandDEF:
.0ae5	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.0ae7	20 26 0a	jsr $0a26			jsr 	PushIntegerA
.0aea	20 79 13	jsr $1379			jsr 	CompileGotoEOL 				; compile skip over DEF
.0aed	a9 a5		lda #$a5			lda 	#C64_FN
.0aef	20 66 09	jsr $0966			jsr 	CheckNextA
.0af2	20 74 12	jsr $1274			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.0af5	20 d9 12	jsr $12d9			jsr 	ExtractVariableName
.0af8	8a		txa				txa
.0af9	10 51		bpl $0b4c			bpl 	_CDError
.0afb	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.0afc	29 7f		and #$7f			and 	#$7F
.0afe	aa		tax				tax
.0aff	98		tya				tya
.0b00	09 80		ora #$80			ora 	#$80
.0b02	a8		tay				tay
.0b03	20 ce 0c	jsr $0cce			jsr 	FindVariable				; does it already exist ?
.0b06	b0 44		bcs $0b4c			bcs 	_CDError 					; if so, that's an error.
.0b08	20 58 0a	jsr $0a58			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.0b0b	20 9d 0a	jsr $0a9d			jsr 	SetVariableRecordToCodePosition
.0b0e	20 74 12	jsr $1274			jsr 	GetNextNonSpace
.0b11	20 b5 15	jsr $15b5			jsr 	GetReferenceTerm 			; get var ref, not array
.0b14	c9 00		cmp #$00			cmp 	#0
.0b16	30 34		bmi $0b4c			bmi 	_CDError
.0b18	8d 09 05	sta $0509			sta 	defType 					; save type
.0b1b	8e 0a 05	stx $050a			stx 	defVariable 				; save var ref
.0b1e	8c 0b 05	sty $050b			sty 	defVariable+1
.0b21	29 40		and #$40			and 	#NSSString 					; only numbers.
.0b23	d0 27		bne $0b4c			bne 	_CDError
.0b25	20 60 09	jsr $0960			jsr 	CheckNextRParen 			; check )
.0b28	a9 b2		lda #$b2			lda 	#C64_EQUAL
.0b2a	20 66 09	jsr $0966			jsr 	CheckNextA 					; check =
.0b2d	18		clc				clc 								; if this is DEF FNxx(A), read A
.0b2e	20 4f 0b	jsr $0b4f			jsr 	CDReadWriteVariable
.0b31	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.0b33	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0b36	38		sec				sec
.0b37	20 4f 0b	jsr $0b4f			jsr 	CDReadWriteVariable 		; A is now updated
.0b3a	20 14 0c	jsr $0c14			jsr 	CompileExpressionAt0 		; the actual body of the function.
.0b3d	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.0b3f	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0b42	38		sec				sec
.0b43	20 4f 0b	jsr $0b4f			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.0b46	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.0b48	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0b4b	60		rts				rts
.0b4c					_CDError:
.0b4c	4c 5d 17	jmp $175d		jmp	ErrorV_syntax
.0b4f					CDReadWriteVariable:
.0b4f	ac 0b 05	ldy $050b			ldy 	defVariable+1 				; set up YX
.0b52	ae 0a 05	ldx $050a			ldx 	defVariable
.0b55	ad 09 05	lda $0509			lda 	defType
.0b58	20 67 15	jsr $1567			jsr 	GetSetVariable
.0b5b	60		rts				rts
.0509					defType:
>0509							.fill 	1
.050a					defVariable:
>050a							.fill 	2
.0b5c					CommandDIM:
.0b5c	20 74 12	jsr $1274			jsr 	GetNextNonSpace 			; get the first non space character
.0b5f	20 d9 12	jsr $12d9			jsr 	ExtractVariableName 		; variable name to XY
.0b62	da		phx				phx 								; save name with type bits.
.0b63	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.0b65	10 37		bpl $0b9e			bpl 	_CDError
.0b67	20 ce 0c	jsr $0cce			jsr 	FindVariable	 			; see if already exist
.0b6a	b0 35		bcs $0ba1			bcs 	_CDRedefine 				; it still exists.
.0b6c	20 58 0a	jsr $0a58			jsr 	CreateVariableRecord 		; create the basic variable
.0b6f	20 ad 0a	jsr $0aad			jsr 	AllocateBytesForType 		; allocate memory for it
.0b72	68		pla				pla 								; restore type bits
.0b73	5a		phy				phy 								; save the address of the basic storage
.0b74	da		phx				phx
.0b75	48		pha				pha
.0b76	20 a4 0b	jsr $0ba4			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.0b79	68		pla				pla
.0b7a	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.0b7c	20 26 0a	jsr $0a26			jsr 	PushIntegerA 				; push that type data out.
.0b7f	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.0b81	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0b84	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.0b86	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0b89	fa		plx				plx 								; restore address
.0b8a	7a		ply				ply
.0b8b	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.0b8d	38		sec				sec
.0b8e	20 67 15	jsr $1567			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.0b91	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; , follows ?
.0b94	c9 2c		cmp #$2c			cmp 	#","
.0b96	d0 05		bne $0b9d			bne 	_CDExit
.0b98	20 69 12	jsr $1269			jsr 	GetNext 					; consume comma
.0b9b	80 bf		bra $0b5c			bra 	CommandDIM 					; do another DIM
.0b9d					_CDExit:
.0b9d	60		rts				rts
.0b9e					_CDError:
.0b9e	4c 5d 17	jmp $175d		jmp	ErrorV_syntax
.0ba1					_CDRedefine:
.0ba1	4c 25 18	jmp $1825		jmp	ErrorV_redefine
.0ba4					OutputIndexGroup:
.0ba4	9c 0c 05	stz $050c			stz 	IndexCount 					; count of number of indices.
.0ba7					_OIGNext:
.0ba7	20 14 0c	jsr $0c14			jsr 	CompileExpressionAt0 		; get a dimension
.0baa	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.0bac	c9 00		cmp #$00			cmp 	#NSSIFloat
.0bae	d0 19		bne $0bc9			bne 	_OIGType
.0bb0	ee 0c 05	inc $050c			inc 	IndexCount 					; bump the counter.
.0bb3	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; does a , follow ?
.0bb6	c9 2c		cmp #$2c			cmp 	#","
.0bb8	d0 05		bne $0bbf			bne 	_OIGCheckEnd
.0bba	20 69 12	jsr $1269			jsr 	GetNext 					; consume comma
.0bbd	80 e8		bra $0ba7			bra 	_OIGNext 					; get next dimension
.0bbf					_OIGCheckEnd:
.0bbf	20 60 09	jsr $0960			jsr 	CheckNextRParen 			; check and consume )
.0bc2	ad 0c 05	lda $050c			lda 	IndexCount
.0bc5	20 26 0a	jsr $0a26			jsr 	PushIntegerA 				; compile the dimension count.
.0bc8	60		rts				rts
.0bc9					_OIGType:
.0bc9	4c 6d 17	jmp $176d		jmp	ErrorV_type
.050c					IndexCount:
>050c							.fill 	1
.0bcc					CompilerErrorHandler:
.0bcc	68		pla				pla
.0bcd	7a		ply				ply
.0bce	85 2a		sta $2a				sta 	zTemp0
.0bd0	84 2b		sty $2b				sty 	zTemp0+1
.0bd2	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.0bd4	a0 01		ldy #$01			ldy 	#1
.0bd6					_EHDisplayMsg:
.0bd6	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0bd8	20 0b 09	jsr $090b			jsr 	PrintCharacter
.0bdb	c8		iny				iny
.0bdc	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0bde	d0 f6		bne $0bd6			bne 	_EHDisplayMsg
.0be0	a9 20		lda #$20			lda 	#32
.0be2	20 0b 09	jsr $090b			jsr 	PrintCharacter
.0be5	a9 40		lda #$40			lda 	#64
.0be7	20 0b 09	jsr $090b			jsr 	PrintCharacter
.0bea	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.0bec	20 a5 1e	jsr $1ea5			jsr 	FloatSetByte
.0bef	20 f7 08	jsr $08f7			jsr 	GetLineNumber
.0bf2	95 3c		sta $3c,x			sta 	NSMantissa0,x
.0bf4	98		tya				tya
.0bf5	95 48		sta $48,x			sta 	NSMantissa1,x
.0bf7	20 8b 1d	jsr $1d8b			jsr 	FloatToString
.0bfa	a0 00		ldy #$00			ldy 	#0 							; display that string.
.0bfc	a2 00		ldx #$00			ldx 	#0
.0bfe					_EHDisplayLine:
.0bfe	b9 3e 05	lda $053e,y			lda 	decimalBuffer,y
.0c01	20 0b 09	jsr $090b			jsr 	PrintCharacter
.0c04	c8		iny				iny
.0c05	b9 3e 05	lda $053e,y			lda 	decimalBuffer,y
.0c08	d0 f4		bne $0bfe			bne 	_EHDisplayLine
.0c0a	a9 0d		lda #$0d			lda 	#13
.0c0c	20 0b 09	jsr $090b			jsr 	PrintCharacter
.0c0f	80 fe		bra $0c0f	_EHHalt:bra 	_EHHalt
.0c11	4c 0b 0a	jmp $0a0b			jmp 	ExitCompiler
.0c14					CompileExpressionAt0:
.0c14	a9 00		lda #$00			lda 	#0
.0c16					CompileExpressionAtA:
.0c16	48		pha				pha  								; save level
.0c17	20 20 16	jsr $1620			jsr 	CompileTerm 				; compile a term.
.0c1a	fa		plx				plx 								; get level back into X
.0c1b					_ECALoop:
.0c1b	48		pha				pha 								; save type on stack.
.0c1c	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; get the next character
.0c1f	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.0c21	90 04		bcc $0c27			bcc 	_ECAExit
.0c23	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.0c25	90 02		bcc $0c29			bcc 	_ECAHaveToken
.0c27					_ECAExit:
.0c27	68		pla				pla 								; throw type off stack
.0c28	60		rts				rts
.0c29					_ECAHaveToken:
.0c29	86 2a		stx $2a				stx 	zTemp0 						; save current precedence in zTemp0
.0c2b	aa		tax				tax 								; X contains the operator token
.0c2c	bd 17 0c	lda $0c17,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.0c2f	c5 2a		cmp $2a				cmp 	zTemp0 						; if < then exit
.0c31	90 f4		bcc $0c27			bcc 	_ECAExit
.0c33	85 2b		sta $2b				sta 	zTemp0+1 					; save the precedence of the operator.
.0c35	20 69 12	jsr $1269			jsr 	GetNext 					; consume the token.
.0c38	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.0c3a	f0 11		beq $0c4d			beq 	_ECAGreaterCheck
.0c3c	e0 b3		cpx #$b3			cpx 	#C64_LESS
.0c3e	d0 1a		bne $0c5a			bne 	_ECAHaveFullToken
.0c40	20 58 12	jsr $1258			jsr 	LookNext 					; checks for < (<= or <>)
.0c43	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.0c45	f0 0e		beq $0c55			beq	 	_ECAToNotEqual
.0c47	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.0c49	d0 0f		bne $0c5a			bne 	_ECAHaveFullToken
.0c4b	80 07		bra $0c54			bra 	_ECAAddEqual
.0c4d					_ECAGreaterCheck:
.0c4d	20 58 12	jsr $1258			jsr 	LookNext
.0c50	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.0c52	d0 06		bne $0c5a			bne 	_ECAHaveFullToken
.0c54					_ECAAddEqual:
.0c54	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.0c55					_ECAToNotEqual:
.0c55	e8		inx				inx
.0c56	e8		inx				inx
.0c57	20 69 12	jsr $1269			jsr 	GetNext 					; consume the = or > in >= <= <>
.0c5a					_ECAHaveFullToken:
.0c5a	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.0c5c	d0 0a		bne $0c68			bne 	_ECANotConcat
.0c5e	68		pla				pla 								; get type back
.0c5f	48		pha				pha
.0c60	29 40		and #$40			and 	#NSSTypeMask
.0c62	c9 40		cmp #$40			cmp 	#NSSString
.0c64	d0 02		bne $0c68			bne 	_ECANotConcat
.0c66	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.0c68					_ECANotConcat:
.0c68	da		phx				phx 								; save operator on the stack
.0c69	a6 2a		ldx $2a				ldx 	zTemp0 						; push current precedence on the stack
.0c6b	da		phx				phx
.0c6c	a5 2b		lda $2b				lda 	zTemp0+1 					; get precedence of operator
.0c6e	1a		inc a				inc 	a
.0c6f	20 16 0c	jsr $0c16			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.0c72	85 2a		sta $2a				sta 	zTemp0 						; save type in zTemp0
.0c74	fa		plx				plx 								; restore current precedence in X
.0c75	68		pla				pla 								; restore operator
.0c76	85 2b		sta $2b				sta 	zTemp0+1 					; save it in zTemp0+1.
.0c78	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.0c7a	90 17		bcc $0c93			bcc 	_ECANotCompare
.0c7c	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.0c7e	b0 13		bcs $0c93			bcs 	_ECANotCompare
.0c80	7a		ply				ply 								; get type into Y
.0c81	5a		phy				phy
.0c82	48		pha				pha 								; save operator
.0c83	98		tya				tya 								; get type
.0c84	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.0c86	29 40		and #$40			and 	#NSSTypeMask
.0c88	c9 40		cmp #$40			cmp 	#NSSString
.0c8a	f0 02		beq $0c8e			beq 	_ECANotString
.0c8c	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.0c8e					_ECANotString:
.0c8e	98		tya				tya									; output token Y
.0c8f	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0c92	68		pla				pla 								; restore operator.
.0c93					_ECANotCompare:
.0c93	18		clc				clc 								; convert to P-Code and compile.
.0c94	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.0c96	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0c99	68		pla				pla 								; type of current result
.0c9a	45 2a		eor $2a				eor 	zTemp0 						; check compatible with r-expr type
.0c9c	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.0c9e	d0 19		bne $0cb9			bne		_ECAType
.0ca0	a5 2a		lda $2a				lda 	zTemp0 						; get type back
.0ca2	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.0ca4	d0 18		bne $0cbe			bne 	_ECAGoLoop
.0ca6	a5 2b		lda $2b				lda 	zTemp0+1 					; check operator is + or comparator
.0ca8	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.0caa	f0 10		beq $0cbc			beq 	_ECAOkayString 				; (this is post conversion)
.0cac	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.0cae	90 09		bcc $0cb9			bcc 	_ECAType
.0cb0	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.0cb2	b0 05		bcs $0cb9			bcs 	_ECAType
.0cb4	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.0cb6	4c 1b 0c	jmp $0c1b			jmp 	_ECALoop
.0cb9					_ECAType:
.0cb9	4c 6d 17	jmp $176d		jmp	ErrorV_type
.0cbc					_ECAOkayString:
.0cbc	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.0cbe					_ECAGoLoop:
.0cbe	4c 1b 0c	jmp $0c1b			jmp 	_ECALoop
.0cc1					PrecedenceTable:
>0cc1	03						.byte 	3 					; '+'
>0cc2	03						.byte 	3 					; '-'
>0cc3	04						.byte 	4 					; '*'
>0cc4	04						.byte 	4 					; '/'
>0cc5	05						.byte 	5 					; '^'
>0cc6	01						.byte 	1 					; 'and'
>0cc7	00						.byte 	0 					; 'or'
>0cc8	02						.byte 	2 					; '>'
>0cc9	02						.byte 	2 					; '='
>0cca	02						.byte 	2 					; '<'
>0ccb	02						.byte 	2 					; '>='
>0ccc	02						.byte 	2 					; '<='
>0ccd	02						.byte 	2 					; '<>'
.0cce					FindVariable:
.0cce	86 2c		stx $2c				stx 	zTemp1 						; save name.
.0cd0	84 2d		sty $2d				sty 	zTemp1+1
.0cd2					_IVCheckSpecial:
.0cd2	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.0cd4	d0 18		bne $0cee			bne 	_IVStandard
.0cd6	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.0cd8	f0 0c		beq $0ce6			beq 	_IVTIFloat
.0cda	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.0cdc	d0 10		bne $0cee			bne 	_IVStandard
.0cde	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.0ce0	a2 01		ldx #$01			ldx 	#$01
.0ce2	a9 40		lda #$40			lda 	#NSSString
.0ce4	38		sec				sec
.0ce5	60		rts				rts
.0ce6					_IVTIFloat:
.0ce6	a0 80		ldy #$80			ldy 	#$80
.0ce8	a2 00		ldx #$00			ldx 	#$00
.0cea	a9 00		lda #$00			lda 	#0
.0cec	38		sec				sec
.0ced	60		rts				rts
.0cee					_IVStandard:
.0cee	ad 07 05	lda $0507			lda 	compilerStartHigh			; start scanning from here.
.0cf1	85 2b		sta $2b				sta 	zTemp0+1
.0cf3	64 2a		stz $2a				stz 	zTemp0
.0cf5					_IVCheckLoop:
.0cf5	b2 2a		lda ($2a)			lda 	(zTemp0) 					; finished ?
.0cf7	f0 2b		beq $0d24			beq  	_IVNotFound 				; if so, return with CC.
.0cf9	a0 01		ldy #$01			ldy 	#1 							; match ?
.0cfb	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0cfd	c5 2c		cmp $2c				cmp 	zTemp1
.0cff	d0 07		bne $0d08			bne	 	_IVNext
.0d01	c8		iny				iny
.0d02	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0d04	c5 2d		cmp $2d				cmp 	zTemp1+1
.0d06	f0 0d		beq $0d15			beq 	_IVFound
.0d08					_IVNext:
.0d08	18		clc				clc
.0d09	a5 2a		lda $2a				lda 	zTemp0
.0d0b	72 2a		adc ($2a)			adc 	(zTemp0)
.0d0d	85 2a		sta $2a				sta 	zTemp0
.0d0f	90 e4		bcc $0cf5			bcc 	_IVCheckLoop
.0d11	e6 2b		inc $2b				inc 	zTemp0+1
.0d13	80 e0		bra $0cf5			bra 	_IVCheckLoop
.0d15					_IVFound:
.0d15	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.0d17	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0d19	aa		tax				tax
.0d1a	c8		iny				iny
.0d1b	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0d1d	48		pha				pha
.0d1e	c8		iny				iny
.0d1f	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0d21	7a		ply				ply
.0d22	38		sec				sec
.0d23	60		rts				rts
.0d24					_IVNotFound:
.0d24	a6 2c		ldx $2c				ldx 	zTemp1 						; get variable name back
.0d26	a4 2d		ldy $2d				ldy 	zTemp1+1
.0d28	18		clc				clc
.0d29	60		rts				rts
.0d2a					FixBranches:
.0d2a	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.0d2c	20 10 0a	jsr $0a10			jsr 	CallAPIHandler
.0d2f					_FBLoop:
.0d2f	b2 28		lda ($28)			lda 	(objPtr) 					; get the next one.
.0d31	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.0d33	f0 16		beq $0d4b			beq 	_FBFixGotoGosub
.0d35	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.0d37	f0 12		beq $0d4b			beq 	_FBFixGotoGosub
.0d39	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.0d3b	f0 0e		beq $0d4b			beq 	_FBFixGotoGosub
.0d3d	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.0d3f	f0 0a		beq $0d4b			beq 	_FBFixGotoGosub
.0d41	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.0d43	f0 3b		beq $0d80			beq 	_FBFixVarSpace
.0d45					_FBNext:
.0d45	20 72 18	jsr $1872			jsr 	MoveObjectForward 			; move forward in object code.
.0d48	90 e5		bcc $0d2f			bcc 	_FBLoop 					; not finished
.0d4a					_FBExit:
.0d4a	60		rts				rts
.0d4b					_FBFixGotoGosub:
.0d4b	a0 01		ldy #$01			ldy 	#1							; line number in YA
.0d4d	b1 28		lda ($28),y			lda 	(objPtr),y
.0d4f	48		pha				pha
.0d50	c8		iny				iny
.0d51	b1 28		lda ($28),y			lda 	(objPtr),y
.0d53	a8		tay				tay
.0d54	68		pla				pla
.0d55	20 0b 14	jsr $140b			jsr 	STRFindLine			 		; find where it is YA
.0d58	90 08		bcc $0d62			bcc 	_FBFFound 					; not found, so must be >
.0d5a	48		pha				pha
.0d5b	b2 28		lda ($28)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.0d5d	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.0d5f	d0 0f		bne $0d70			bne 	_FBFFail
.0d61	68		pla				pla
.0d62					_FBFFound:
.0d62	20 5b 14	jsr $145b			jsr 	STRMakeOffset 				; make it an offset from X:YA
.0d65	5a		phy				phy	 								; patch the GOTO/GOSUB
.0d66	a0 01		ldy #$01			ldy 	#1
.0d68	91 28		sta ($28),y			sta 	(objPtr),y
.0d6a	c8		iny				iny
.0d6b	68		pla				pla
.0d6c	91 28		sta ($28),y			sta 	(objPtr),y
.0d6e	80 d5		bra $0d45			bra 	_FBNext
.0d70					_FBFFail:
.0d70	a0 02		ldy #$02			ldy 	#2
.0d72	b1 28		lda ($28),y			lda 	(objPtr),y
.0d74	8d 00 04	sta $0400			sta 	currentLineNumber
.0d77	c8		iny				iny
.0d78	b1 28		lda ($28),y			lda 	(objPtr),y
.0d7a	8d 01 04	sta $0401			sta 	currentLineNumber+1
.0d7d	4c a0 17	jmp $17a0		jmp	ErrorV_line
.0d80					_FBFixVarSpace:
.0d80	a0 01		ldy #$01			ldy 	#1
.0d82	ad 13 05	lda $0513			lda 	freeVariableMemory
.0d85	91 28		sta ($28),y			sta 	(objPtr),y
.0d87	c8		iny				iny
.0d88	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.0d8b	91 28		sta ($28),y			sta 	(objPtr),y
.0d8d	80 b6		bra $0d45			bra 	_FBNext
.0d8f					CommandFOR:
.0d8f	20 74 12	jsr $1274			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.0d92	20 8a 12	jsr $128a			jsr 	CharIsAlpha 				; if not alpha , error
.0d95	90 59		bcc $0df0			bcc 	_CFFail
.0d97	20 b5 15	jsr $15b5			jsr 	GetReferenceTerm 			; figure out the reference.
.0d9a	48		pha				pha 								; save type
.0d9b	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.0d9d	c9 00		cmp #$00			cmp 	#NSSIFloat
.0d9f	d0 4f		bne $0df0			bne 	_CFFail
.0da1	5a		phy				phy 								; save reference on the stack
.0da2	da		phx				phx
.0da3	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.0da5	20 66 09	jsr $0966			jsr 	CheckNextA
.0da8	20 14 0c	jsr $0c14			jsr 	CompileExpressionAt0 		; initial value
.0dab	fa		plx				plx 								; get reference back.
.0dac	7a		ply				ply
.0dad	5a		phy				phy
.0dae	da		phx				phx
.0daf	38		sec				sec 								; set initial value.
.0db0	20 67 15	jsr $1567			jsr 	GetSetVariable
.0db3	fa		plx				plx
.0db4	7a		ply				ply
.0db5	68		pla				pla
.0db6	29 20		and #$20			and 	#NSSIInt16
.0db8	f0 04		beq $0dbe			beq 	_CFNotInt16
.0dba	98		tya				tya
.0dbb	09 80		ora #$80			ora 	#$80
.0dbd	a8		tay				tay
.0dbe					_CFNotInt16:
.0dbe	8a		txa				txa 								; reference in YA
.0dbf	20 13 0a	jsr $0a13			jsr 	PushIntegerYA
.0dc2	a9 a4		lda #$a4			lda 	#C64_TO
.0dc4	20 66 09	jsr $0966			jsr 	CheckNextA
.0dc7	20 14 0c	jsr $0c14			jsr 	CompileExpressionAt0 		; terminal value
.0dca	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.0dcc	c9 00		cmp #$00			cmp 	#NSSIFloat
.0dce	d0 20		bne $0df0			bne 	_CFFail
.0dd0	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; followed by STEP
.0dd3	c9 a9		cmp #$a9			cmp 	#C64_STEP
.0dd5	d0 0e		bne $0de5			bne 	_CFNoStep
.0dd7	20 69 12	jsr $1269			jsr 	GetNext 					; consume it.
.0dda	20 14 0c	jsr $0c14			jsr 	CompileExpressionAt0 		; terminal value
.0ddd	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.0ddf	c9 00		cmp #$00			cmp 	#NSSIFloat
.0de1	d0 0d		bne $0df0			bne 	_CFFail
.0de3	80 05		bra $0dea			bra 	_CFParametersDone
.0de5					_CFNoStep:
.0de5	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.0de7	20 26 0a	jsr $0a26			jsr 	PushIntegerA
.0dea					_CFParametersDone:
.0dea	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.0dec	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0def	60		rts				rts
.0df0					_CFFail:
.0df0	4c 5d 17	jmp $175d		jmp	ErrorV_syntax
.0df3					FNCompile:
.0df3	20 74 12	jsr $1274			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.0df6	20 d9 12	jsr $12d9			jsr 	ExtractVariableName
.0df9	e0 00		cpx #$00			cpx 	#0
.0dfb	10 32		bpl $0e2f			bpl 	_FNError
.0dfd	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.0dfe	29 7f		and #$7f			and 	#$7F
.0e00	aa		tax				tax
.0e01	98		tya				tya
.0e02	09 80		ora #$80			ora 	#$80
.0e04	a8		tay				tay
.0e05	20 ce 0c	jsr $0cce			jsr 	FindVariable				; does it already exist ?
.0e08	90 25		bcc $0e2f			bcc 	_FNError 					; no.
.0e0a	20 5b 14	jsr $145b			jsr 	STRMakeOffset 				; convert to a relative address.
.0e0d	c9 00		cmp #$00			cmp 	#0 							; fix up.
.0e0f	d0 01		bne $0e12			bne 	_FNNoBorrow
.0e11	88		dey				dey
.0e12					_FNNoBorrow:
.0e12	3a		dec a				dec 	a
.0e13	5a		phy				phy 								; save location of routine on stack.
.0e14	48		pha				pha
.0e15	da		phx				phx
.0e16	20 14 0c	jsr $0c14			jsr 	CompileExpressionAt0
.0e19	20 60 09	jsr $0960			jsr 	CheckNextRParen
.0e1c	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.0e1e	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0e21	68		pla				pla
.0e22	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0e25	68		pla				pla
.0e26	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0e29	68		pla				pla
.0e2a	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.0e2d	18		clc				clc
.0e2e	60		rts				rts
.0e2f					_FNError:
.0e2f	4c 50 17	jmp $1750		jmp	ErrorV_value
.0e32					CommandTables:
>0e32	07 cb 00 03 37 13 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>0e39	07 89 00 03 3e 13 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>0e40	07 8d 00 03 31 13 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>0e47	07 88 00 03 ad 13 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>0e4e	07 85 00 03 8d 13 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>0e55	07 84 00 04 a1 13 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>0e5c	07 99 00 03 e2 14 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>0e63	07 98 00 04 e2 14 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>0e6a	07 8f 00 03 ed 15 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>0e71	07 81 00 03 8f 0d 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>0e78	07 82 00 03 65 14 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>0e7f	07 a1 00 03 aa 12 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>0e86	07 83 00 03 c9 0a 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>0e8d	07 87 00 03 2b 15 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>0e94	07 86 00 03 5c 0b 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>0e9b	07 96 00 03 e5 0a 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>0ea2	07 8b 00 e3 5a 13 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>0ea9	08 92 00 ea e3 b9 16 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>0eb1	09 91 00 e1 a9 03 91 14			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>0eb9	06
>0eba	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>0ec1	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>0ec8	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>0ece	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>0ed5	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>0edc	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>0ee3	07 9d 00 e3 df 16 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>0eea	0a 9f 00 ea e3 f2 16 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>0ef2	c6 06
>0ef4	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>0efa	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>0f01	0a ce 92 e3 27 12 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>0f09	ad 06
>0f0b	0a ce 8d e3 27 12 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>0f13	ae 06
>0f15	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>0f1b	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>0f23	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>0f2a	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>0f31	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>0f39	06
>0f3a	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>0f42	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>0f4a	9a 06
>0f4c	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>0f54	9b 06
>0f56	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>0f5e	9c 06
>0f60	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>0f68	06
>0f69	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>0f70	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>0f78	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>0f80	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>0f88	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>0f90	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>0f98	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>0fa0	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>0fa8	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>0fb0	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>0fb8	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>0fc0	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>0fc7	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>0fcf	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>0fd7	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>0fdf	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>0fe7	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>0fef	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>0ff7	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>0fff	00						.byte 	0
.1000					UnaryTables:
>1000	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>1007	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>100f	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>1016	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>101d	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>1024	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>102b	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>1033	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>103a	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>1042	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>104a	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>1052	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>105a	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>1062	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>106a	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>1071	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>1078	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>107f	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>1086	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>108d	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>1094	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>109c	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>10a4	0b ca 00 8f ae 03 27 12			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>10ac	91 bd 07
>10af	07 a8 00 03 46 12 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>10b6	07 a5 00 03 f3 0d 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>10bd	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>10c4	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>10cb	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>10d3	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>10db	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>10e2	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>10e9	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>10f0	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>10f8	06
>10f9	00						.byte 	0
.10fa					GeneratorProcess:
.10fa	86 2a		stx $2a				stx 	zTemp0 						; save generation pointer in zTemp0
.10fc	84 2b		sty $2b				sty 	zTemp0+1
.10fe	85 2c		sta $2c				sta 	zTemp1 						; first match token
.1100	64 2d		stz $2d				stz 	zTemp1+1
.1102	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.1104	d0 05		bne $110b			bne 	_GPNotShifted
.1106	20 69 12	jsr $1269			jsr 	GetNext 					; get the shifted token
.1109	85 2d		sta $2d				sta 	zTemp1+1 					; match CE xx
.110b					_GPNotShifted:
.110b					_GPSearch:
.110b	b2 2a		lda ($2a)			lda 	(zTemp0) 					; reached end ?
.110d	18		clc				clc
.110e	f0 2f		beq $113f			beq 	_GPExit
.1110	a0 01		ldy #$01			ldy 	#1 							; tokens match
.1112	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1114	c5 2c		cmp $2c				cmp 	zTemp1
.1116	d0 09		bne $1121			bne 	_GPNext
.1118	a5 2d		lda $2d				lda 	zTemp1+1 					; 2nd token ?
.111a	f0 12		beq $112e			beq 	_GPFound
.111c	c8		iny				iny 								; check match.
.111d	d1 2a		cmp ($2a),y			cmp 	(zTemp0),y
.111f	f0 0d		beq $112e			beq 	_GPFound
.1121					_GPNext:
.1121	18		clc				clc 								; follow to next
.1122	a5 2a		lda $2a				lda 	zTemp0
.1124	72 2a		adc ($2a)			adc 	(zTemp0)
.1126	85 2a		sta $2a				sta 	zTemp0
.1128	90 e1		bcc $110b			bcc 	_GPSearch
.112a	e6 2b		inc $2b				inc 	zTemp0+1
.112c	80 dd		bra $110b			bra 	_GPSearch
.112e					_GPFound:
.112e	18		clc				clc 								; skip to action bytes
.112f	a5 2a		lda $2a				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.1131	69 03		adc #$03			adc 	#3
.1133	85 2a		sta $2a				sta 	zTemp0
.1135	90 02		bcc $1139			bcc 	_GPNoCarry
.1137	e6 2b		inc $2b				inc 	zTemp0+1
.1139					_GPNoCarry:
.1139					_GPLoop:
.1139	20 40 11	jsr $1140			jsr 	GeneratorExecute 			; execute one command
.113c	90 fb		bcc $1139			bcc 	_GPLoop 					; go back if not completed.
.113e	38		sec				sec 								; return with CS.
.113f					_GPExit:
.113f	60		rts				rts
.1140					GeneratorExecute:
.1140	20 ec 11	jsr $11ec			jsr 	_GEFetchZTemp0 				; get next.
.1143	48		pha				pha 								; split into 2 nibbles
.1144	4a		lsr a				lsr 	a
.1145	4a		lsr a				lsr 	a
.1146	4a		lsr a				lsr		a
.1147	4a		lsr a				lsr 	a
.1148	20 52 11	jsr $1152			jsr 	_GEExecuteNibble 			; MSB first
.114b	68		pla				pla
.114c	b0 03		bcs $1151			bcs 	_GEHaveCompleted
.114e	20 52 11	jsr $1152			jsr 	_GEExecuteNibble 			; LSB second
.1151					_GEHaveCompleted:
.1151	60		rts				rts
.1152					_GEExecuteNibble:
.1152	29 0f		and #$0f			and 	#$0F
.1154	0a		asl a				asl 	a
.1155	aa		tax				tax
.1156	7c 59 11	jmp ($1159,x)			jmp 	(_GEExecuteVectors,x)
.1159					_GEExecuteVectors:
>1159	79 11						.word 	_GEXNop 					; 0  (no operation)
>115b	81 11						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>115d	7b 11						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>115f	cf 11						.word 	_GEXExecute 				; 3  (run arbitrary code)
>1161	c2 11						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>1163	79 11						.word 	_GEXNop 					; 5
>1165	89 11						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>1167	8d 11						.word 	_GEXExitString 				; 7  exit return string type
>1169	91 11						.word 	_GEXLParam 					; 8  check ( follows
>116b	95 11						.word 	_GEXRParam 					; 9  check ) follows
>116d	99 11						.word 	_GEXComma					; A  check , follows
>116f	79 11						.word 	_GEXNop 					; B
>1171	79 11						.word 	_GEXNop 					; C
>1173	79 11						.word 	_GEXNop 					; D
>1175	a9 11						.word 	_GEXNumber 					; E  compile get any number
>1177	b4 11						.word 	_GEXString 					; F  compile get any string
.1179					_GEXNop:
.1179	18		clc				clc
.117a	60		rts				rts
.117b					_GEXToken2:
.117b	20 ec 11	jsr $11ec			jsr 	_GEFetchZTemp0
.117e	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.1181					_GEXToken1:
.1181	20 ec 11	jsr $11ec			jsr 	_GEFetchZTemp0
.1184	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.1187	18		clc				clc
.1188	60		rts				rts
.1189					_GEXExitNumber:
.1189	a9 00		lda #$00			lda 	#NSSIFloat
.118b	38		sec				sec
.118c	60		rts				rts
.118d					_GEXExitString:
.118d	a9 40		lda #$40			lda 	#NSSString
.118f	38		sec				sec
.1190	60		rts				rts
.1191					_GEXLParam:
.1191	a9 28		lda #$28			lda 	#"("
.1193	80 06		bra $119b			bra 	_GEXCheck
.1195					_GEXRParam:
.1195	a9 29		lda #$29			lda 	#")"
.1197	80 02		bra $119b			bra 	_GEXCheck
.1199					_GEXComma:
.1199	a9 2c		lda #$2c			lda 	#","
.119b					_GEXCheck:
.119b	85 2e		sta $2e				sta 	zTemp2 						; save match
.119d	20 74 12	jsr $1274			jsr 	GetNextNonSpace 			; get next skipping spaces
.11a0	c5 2e		cmp $2e				cmp 	zTemp2 						; check matches.
.11a2	d0 02		bne $11a6			bne 	_GEXSyntax
.11a4	18		clc				clc
.11a5	60		rts				rts
.11a6					_GEXSyntax:
.11a6	4c 5d 17	jmp $175d		jmp	ErrorV_syntax
.11a9					_GEXNumber:
.11a9	20 f5 11	jsr $11f5			jsr 	GEXCompileExpression 		; compile expression
.11ac	29 40		and #$40			and 	#NSSTypeMask
.11ae	c9 00		cmp #$00			cmp  	#NSSIFloat
.11b0	d0 0d		bne $11bf			bne 	_GEXType
.11b2	18		clc				clc
.11b3	60		rts				rts
.11b4					_GEXString:
.11b4	20 f5 11	jsr $11f5			jsr 	GEXCompileExpression 		; compile expression
.11b7	29 40		and #$40			and 	#NSSTypeMask
.11b9	c9 40		cmp #$40			cmp  	#NSSString
.11bb	d0 02		bne $11bf			bne 	_GEXType
.11bd	18		clc				clc
.11be	60		rts				rts
.11bf					_GEXType:
.11bf	4c 6d 17	jmp $176d		jmp	ErrorV_type
.11c2					_GEXChannelExec:
.11c2	20 05 12	jsr $1205			jsr 	ChannelPrefix 				; set up default
.11c5	20 cf 11	jsr $11cf			jsr 	_GEXExecute
.11c8	08		php				php
.11c9	20 20 12	jsr $1220			jsr 	ChannelPostfix 				; replace default.
.11cc	28		plp				plp
.11cd	60		rts				rts
>11ce	db						.byte 	$DB 						; causes a break in the emulator
.11cf					_GEXExecute:
.11cf	20 ec 11	jsr $11ec			jsr 	_GEFetchZTemp0 				; get vector
.11d2	85 2e		sta $2e				sta 	zTemp2
.11d4	20 ec 11	jsr $11ec			jsr 	_GEFetchZTemp0
.11d7	85 2f		sta $2f				sta 	zTemp2+1
.11d9	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.11db	da		phx				phx
.11dc	a6 2b		ldx $2b				ldx 	zTemp0+1
.11de	da		phx				phx
.11df	20 e9 11	jsr $11e9			jsr 	_GECallZTemp2 				; execute code
.11e2	fa		plx				plx 								; recover generation exec
.11e3	86 2b		stx $2b				stx 	zTemp0+1
.11e5	fa		plx				plx
.11e6	86 2a		stx $2a				stx 	zTemp0
.11e8	60		rts				rts
.11e9					_GECallZTemp2:
.11e9	6c 2e 00	jmp ($002e)			jmp 	(zTemp2)
.11ec					_GEFetchZTemp0:
.11ec	b2 2a		lda ($2a)			lda 	(zTemp0)
.11ee	e6 2a		inc $2a				inc 	zTemp0
.11f0	d0 02		bne $11f4			bne 	_GEFZ0Skip
.11f2	e6 2b		inc $2b				inc 	zTemp0+1
.11f4					_GEFZ0Skip:
.11f4	60		rts				rts
.11f5					GEXCompileExpression:
.11f5	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.11f7	da		phx				phx
.11f8	a6 2b		ldx $2b				ldx 	zTemp0+1
.11fa	da		phx				phx
.11fb	20 14 0c	jsr $0c14			jsr 	CompileExpressionAt0 		; compile expression.
.11fe	fa		plx				plx 								; recover generation exec
.11ff	86 2b		stx $2b				stx 	zTemp0+1
.1201	fa		plx				plx
.1202	86 2a		stx $2a				stx 	zTemp0
.1204	60		rts				rts
.1205					ChannelPrefix:
.1205	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.1207	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.120a	20 f5 11	jsr $11f5			jsr 	GEXCompileExpression 		; channel #
.120d	29 40		and #$40			and 	#NSSTypeMask
.120f	c9 00		cmp #$00			cmp 	#NSSIFloat
.1211	d0 0a		bne $121d			bne 	_CPXType
.1213	20 5c 09	jsr $095c			jsr 	CheckNextComma 				; check , follows.
.1216	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.1218	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.121b	18		clc				clc
.121c	60		rts				rts
.121d					_CPXType:
.121d	4c 6d 17	jmp $176d		jmp	ErrorV_type
.1220					ChannelPostfix:
.1220	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.1222	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.1225	18		clc				clc
.1226	60		rts				rts
.1227					OptionalParameterCompile:
.1227	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; what follows.
.122a	c9 2c		cmp #$2c			cmp 	#","
.122c	d0 0e		bne $123c			bne 	_MidDefault
.122e	20 69 12	jsr $1269			jsr 	GetNext 					; consume ,
.1231	20 14 0c	jsr $0c14			jsr 	CompileExpressionAt0
.1234	29 40		and #$40			and 	#NSSTypeMask
.1236	c9 00		cmp #$00			cmp 	#NSSIFloat
.1238	d0 09		bne $1243			bne 	MidFailType
.123a	80 05		bra $1241			bra 	_MidComplete
.123c					_MidDefault:
.123c	a9 ff		lda #$ff			lda 	#255 						; default of 255
.123e	20 26 0a	jsr $0a26			jsr 	PushIntegerA
.1241					_MidComplete:
.1241	18		clc				clc
.1242	60		rts				rts
.1243					MidFailType:
.1243	4c 6d 17	jmp $176d		jmp	ErrorV_type
.1246					NotUnaryCompile:
.1246	ad c9 0c	lda $0cc9			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1249	20 16 0c	jsr $0c16			jsr 	CompileExpressionAtA 		; evaluate at that level
.124c	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.124e	c9 00		cmp #$00			cmp 	#NSSIFloat
.1250	d0 f1		bne $1243			bne 	MidFailType
.1252	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1254	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.1257	60		rts				rts
.1258					LookNext:
.1258	b2 24		lda ($24)			lda 	(srcPtr)
.125a	60		rts				rts
.125b					LookNextNonSpace:
.125b	b2 24		lda ($24)			lda 	(srcPtr)
.125d	c9 20		cmp #$20			cmp		#' '
.125f	f0 03		beq $1264			beq 	_LNNSkip
.1261	c9 00		cmp #$00			cmp 	#0
.1263	60		rts				rts
.1264					_LNNSkip:
.1264	20 69 12	jsr $1269			jsr 	GetNext
.1267	80 f2		bra $125b			bra 	LookNextNonSpace
.1269					GetNext:
.1269	b2 24		lda ($24)			lda 	(srcPtr) 					; get next
.126b	e6 24		inc $24				inc 	srcPtr
.126d	d0 02		bne $1271			bne 	_GNSkip
.126f	e6 25		inc $25				inc 	srcPtr+1
.1271					_GNSkip:
.1271	c9 00		cmp #$00			cmp 	#0
.1273	60		rts				rts
.1274					GetNextNonSpace:
.1274	20 69 12	jsr $1269			jsr 	GetNext
.1277	c9 20		cmp #$20			cmp 	#' '
.1279	f0 f9		beq $1274			beq 	GetNextNonSpace
.127b	c9 00		cmp #$00			cmp 	#0
.127d	60		rts				rts
.127e					CharIsDigit:
.127e	c9 30		cmp #$30			cmp 	#"0"
.1280	90 06		bcc $1288			bcc 	CCFalse
.1282	c9 3a		cmp #$3a			cmp 	#"9"+1
.1284	b0 02		bcs $1288			bcs 	CCFalse
.1286					CCTrue:
.1286	38		sec				sec
.1287	60		rts				rts
.1288					CCFalse:
.1288	18		clc				clc
.1289	60		rts				rts
.128a					CharIsAlpha:
.128a	c9 41		cmp #$41			cmp 	#"A"
.128c	90 fa		bcc $1288			bcc 	CCFalse
.128e	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1290	b0 f6		bcs $1288			bcs 	CCFalse
.1292	80 f2		bra $1286			bra 	CCTrue
.1294					ConvertHexStyle:
.1294	38		sec				sec
.1295	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1297	90 ef		bcc $1288			bcc 	CCFalse
.1299	c9 0a		cmp #$0a			cmp 	#9+1
.129b	90 e9		bcc $1286			bcc 	CCTrue
.129d	38		sec				sec 								; shift into hex space A=>0 Z=>25
.129e	e9 11		sbc #$11			sbc 	#"A"-"0"
.12a0	90 e6		bcc $1288			bcc 	CCFalse
.12a2	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.12a4	b0 e2		bcs $1288			bcs 	CCFalse
.12a6	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.12a8	80 dc		bra $1286			bra 	CCTrue
.12aa					CommandGET:
.12aa	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; # follows ?
.12ad	c9 23		cmp #$23			cmp 	#"#"
.12af	d0 0d		bne $12be			bne 	CommandGetBody
.12b1	20 69 12	jsr $1269			jsr 	GetNext 					; consume #
.12b4	20 05 12	jsr $1205			jsr 	ChannelPrefix 				; do it as GET#
.12b7	20 be 12	jsr $12be			jsr 	CommandGetBody
.12ba	20 20 12	jsr $1220			jsr 	ChannelPostfix
.12bd	60		rts				rts
.12be					CommandGetBody:
.12be	20 74 12	jsr $1274			jsr 	GetNextNonSpace 			; get the first character
.12c1	20 b5 15	jsr $15b5			jsr 	GetReferenceTerm 			; identify variable to assign to
.12c4	48		pha				pha
.12c5	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.12c7	c9 40		cmp #$40			cmp 	#NSSString
.12c9	d0 0b		bne $12d6			bne 	_CGType
.12cb	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.12cd	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.12d0	38		sec				sec
.12d1	68		pla				pla
.12d2	20 67 15	jsr $1567			jsr		GetSetVariable
.12d5	60		rts				rts
.12d6					_CGType:
.12d6	4c 6d 17	jmp $176d		jmp	ErrorV_type
.12d9					ExtractVariableName:
.12d9	20 8a 12	jsr $128a			jsr 	CharIsAlpha
.12dc	90 50		bcc $132e			bcc 	_IVSyntax
.12de	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.12e0	85 2c		sta $2c				sta 	zTemp1 						; we'll build it in zTemp1
.12e2	64 2d		stz $2d				stz 	zTemp1+1
.12e4	20 58 12	jsr $1258			jsr 	LookNext 					; is there a second character ?
.12e7	20 8a 12	jsr $128a			jsr 	CharIsAlpha  				; must be alphanumeric
.12ea	b0 05		bcs $12f1			bcs 	_IVHasSecond
.12ec	20 7e 12	jsr $127e			jsr 	CharIsDigit
.12ef	90 07		bcc $12f8			bcc 	_IVCheckType
.12f1					_IVHasSecond:
.12f1	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.12f3	85 2d		sta $2d				sta 	zTemp1+1
.12f5					_IVGetNextCheck:
.12f5	20 69 12	jsr $1269			jsr 	GetNext 					; consume it
.12f8					_IVCheckType:
.12f8	20 58 12	jsr $1258			jsr 	LookNext					; check if string follows.
.12fb	20 8a 12	jsr $128a			jsr 	CharIsAlpha
.12fe	b0 f5		bcs $12f5			bcs 	_IVGetNextCheck
.1300	20 7e 12	jsr $127e			jsr 	CharIsDigit
.1303	b0 f0		bcs $12f5			bcs 	_IVGetNextCheck
.1305	a2 40		ldx #$40			ldx 	#NSSString
.1307	c9 24		cmp #$24			cmp 	#"$"
.1309	f0 06		beq $1311			beq 	_IVHasType
.130b	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.130d	c9 25		cmp #$25			cmp 	#"%"
.130f	d0 08		bne $1319			bne 	_IVCheckArray
.1311					_IVHasType:
.1311	8a		txa				txa 								; Or X into zTemp1
.1312	05 2c		ora $2c				ora 	zTemp1
.1314	85 2c		sta $2c				sta 	zTemp1
.1316	20 69 12	jsr $1269			jsr 	GetNext 					; consume it
.1319					_IVCheckArray:
.1319	20 58 12	jsr $1258			jsr 	LookNext 					; check if array follows
.131c	c9 28		cmp #$28			cmp 	#"("
.131e	d0 09		bne $1329			bne 	_IVNotArray
.1320	a5 2c		lda $2c				lda 	zTemp1 						; set array bit
.1322	09 80		ora #$80			ora 	#NSSArray
.1324	85 2c		sta $2c				sta 	zTemp1
.1326	20 69 12	jsr $1269			jsr 	GetNext 					; consume it
.1329					_IVNotArray:
.1329	a6 2c		ldx $2c				ldx 	zTemp1
.132b	a4 2d		ldy $2d				ldy 	zTemp1+1
.132d	60		rts				rts
.132e					_IVSyntax:
.132e	4c 5d 17	jmp $175d		jmp	ErrorV_syntax
.1331					CommandGOSUB:
.1331	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1333	20 44 13	jsr $1344			jsr 	CompileBranchCommand
.1336	60		rts				rts
.1337					CommandGOAlt:
.1337	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1339	20 66 09	jsr $0966			jsr 	CheckNextA
.133c	80 00		bra $133e			bra 	CommandGOTO
.133e					CommandGOTO:
.133e	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1340	20 44 13	jsr $1344			jsr 	CompileBranchCommand
.1343	60		rts				rts
.1344					CompileBranchCommand:
.1344	20 fe 08	jsr $08fe			jsr 	WriteCodeByte 				; write the command out.
.1347	20 74 12	jsr $1274			jsr 	GetNextNonSpace
.134a	20 bd 14	jsr $14bd			jsr 	ParseConstant 				; get constant into YA
.134d	90 08		bcc $1357			bcc 	_CBCSyntax
.134f	20 fe 08	jsr $08fe			jsr 	WriteCodeByte				; and compile the actual line number
.1352	98		tya				tya
.1353	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.1356	60		rts				rts
.1357					_CBCSyntax:
.1357	4c 5d 17	jmp $175d		jmp	ErrorV_syntax
.135a					CommandIF:
.135a	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; what follows the tests ?
.135d	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.135f	f0 0f		beq $1370			beq 	_CIGoto
.1361	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1363	20 66 09	jsr $0966			jsr 	CheckNextA
.1366	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; THEN <number>
.1369	20 7e 12	jsr $127e			jsr 	CharIsDigit
.136c	b0 05		bcs $1373			bcs 	_CIGoto2
.136e	80 09		bra $1379			bra 	CompileGotoEOL
.1370					_CIGoto:
.1370	20 69 12	jsr $1269			jsr 	GetNext
.1373					_CIGoto2:
.1373	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1375	20 44 13	jsr $1344			jsr 	CompileBranchCommand
.1378	60		rts				rts
.1379					CompileGotoEOL:
.1379	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.137b	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.137e	20 f7 08	jsr $08f7			jsr 	GetLineNumber 				; Get the current line number => YA
.1381	1a		inc a				inc 	a 							; and branch to +1
.1382	d0 01		bne $1385			bne 	_CGENoCarry
.1384	c8		iny				iny
.1385					_CGENoCarry:
.1385	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.1388	98		tya				tya
.1389	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.138c	60		rts				rts
.138d					CommandINPUT:
.138d	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; check for "
.1390	c9 22		cmp #$22			cmp 	#'"'
.1392	d0 0d		bne $13a1			bne 	CommandINPUTStream
.1394	20 14 0c	jsr $0c14			jsr 	CompileExpressionAt0
.1397	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1399	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.139c	a9 2c		lda #$2c			lda 	#","
.139e	20 5c 09	jsr $095c			jsr 	CheckNextComma
.13a1					CommandINPUTStream:
.13a1	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.13a3	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.13a6	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.13a8	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.13aa	4c 2f 15	jmp $152f			jmp 	CommandReadInputCommon
.13ad					CommandLET:
.13ad	20 74 12	jsr $1274			jsr 	GetNextNonSpace 			; get the first character
.13b0					CommandLETHaveFirst:
.13b0	20 b5 15	jsr $15b5			jsr 	GetReferenceTerm 			; identify variable to assign to
.13b3	da		phx				phx 								; save target on the stack.
.13b4	5a		phy				phy
.13b5	48		pha				pha
.13b6	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.13b8	20 66 09	jsr $0966			jsr 	CheckNextA
.13bb	20 14 0c	jsr $0c14			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.13be	85 2a		sta $2a				sta 	zTemp0 						; save type returned
.13c0	68		pla				pla 								; get type of assignment
.13c1	48		pha				pha
.13c2	45 2a		eor $2a				eor 	zTemp0 						; compare using EOR
.13c4	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.13c6	d0 17		bne $13df			bne 	_CLType
.13c8	68		pla				pla 								; restore and compile save code
.13c9	7a		ply				ply
.13ca	fa		plx				plx
.13cb	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.13cd	f0 05		beq $13d4			beq 	_CLTIString
.13cf	38		sec				sec
.13d0	20 67 15	jsr $1567			jsr		GetSetVariable
.13d3	60		rts				rts
.13d4					_CLTIString:
.13d4	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.13d6	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.13d9	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.13db	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.13de	60		rts				rts
.13df					_CLType:
.13df	4c 6d 17	jmp $176d		jmp	ErrorV_type
.13e2					STRMarkLine:
.13e2	48		pha				pha
.13e3	38		sec				sec 								; allocate 4 bytes (line #,address)
.13e4	ad 0f 05	lda $050f			lda 	lineNumberTable 			; and copy to zTemp0
.13e7	e9 04		sbc #$04			sbc 	#4
.13e9	8d 0f 05	sta $050f			sta 	lineNumberTable
.13ec	85 2a		sta $2a				sta 	zTemp0
.13ee	ad 10 05	lda $0510			lda 	lineNumberTable+1
.13f1	e9 00		sbc #$00			sbc 	#0
.13f3	8d 10 05	sta $0510			sta 	lineNumberTable+1
.13f6	85 2b		sta $2b				sta 	zTemp0+1
.13f8	68		pla				pla
.13f9	92 2a		sta ($2a)			sta 	(zTemp0) 					; line # save it in +0,+1
.13fb	98		tya				tya
.13fc	a0 01		ldy #$01			ldy 	#1
.13fe	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1400	a5 28		lda $28				lda 	objPtr 						; save current address in +2,+3
.1402	c8		iny				iny
.1403	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1405	a5 29		lda $29				lda 	objPtr+1
.1407	c8		iny				iny
.1408	91 2a		sta ($2a),y			sta 	(zTemp0),y
.140a	60		rts				rts
.140b					STRFindLine:
.140b	85 2a		sta $2a				sta 	zTemp0 						; zTemp0 line number being searched
.140d	84 2b		sty $2b				sty 	zTemp0+1
.140f	ad 08 05	lda $0508			lda 	compilerEndHigh 			; work backwards through table
.1412	85 2d		sta $2d				sta 	zTemp1+1
.1414	64 2c		stz $2c				stz 	zTemp1
.1416					_STRSearch:
.1416	20 4d 14	jsr $144d			jsr 	_STRPrevLine 				; look at previous record.
.1419	a0 01		ldy #$01			ldy 	#1
.141b	b2 2c		lda ($2c)			lda 	(zTemp1) 					; check table line # >= target
.141d	c5 2a		cmp $2a				cmp 	zTemp0
.141f	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1421	e5 2b		sbc $2b				sbc 	zTemp0+1
.1423	b0 0b		bcs $1430			bcs 	_STRFound 					; >=
.1425					_STRNext:
.1425	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1427	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1429	c9 ff		cmp #$ff			cmp 	#$FF
.142b	d0 e9		bne $1416			bne 	_STRSearch
.142d	4c b7 17	jmp $17b7		jmp	ErrorV_internal
.1430					_STRFound:
.1430	b2 2c		lda ($2c)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1432	45 2a		eor $2a				eor 	zTemp0
.1434	d0 06		bne $143c			bne 	_STRDifferent
.1436	b2 2c		lda ($2c)			lda 	(zTemp1)
.1438	45 2a		eor $2a				eor 	zTemp0
.143a	f0 02		beq $143e			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.143c					_STRDifferent:
.143c	a9 ff		lda #$ff			lda 	#$FF
.143e					_STROut:
.143e	18		clc				clc  								; set carry if different, e.g. > rather than >=
.143f	69 ff		adc #$ff			adc 	#255
.1441	08		php				php
.1442	c8		iny				iny 								; address into YA
.1443	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1445	48		pha				pha
.1446	c8		iny				iny
.1447	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1449	a8		tay				tay
.144a	68		pla				pla
.144b	28		plp				plp
.144c	60		rts				rts
.144d					_STRPrevLine:
.144d	38		sec				sec 								; move backwards one entry.
.144e	a5 2c		lda $2c				lda 	zTemp1
.1450	e9 04		sbc #$04			sbc 	#4
.1452	85 2c		sta $2c				sta 	zTemp1
.1454	a5 2d		lda $2d				lda 	zTemp1+1
.1456	e9 00		sbc #$00			sbc 	#0
.1458	85 2d		sta $2d				sta 	zTemp1+1
.145a	60		rts				rts
.145b					STRMakeOffset:
.145b	18		clc				clc 								; borrow 1
.145c	e5 28		sbc $28				sbc 	objPtr
.145e	48		pha				pha
.145f	98		tya				tya
.1460	e5 29		sbc $29				sbc 	objPtr+1
.1462	a8		tay				tay
.1463	68		pla				pla
.1464	60		rts				rts
.1465					CommandNEXT:
.1465	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1468	20 8a 12	jsr $128a			jsr 	CharIsAlpha 				; if not alpha , error
.146b	90 0c		bcc $1479			bcc 	_CNNoReferenceGiven
.146d	20 69 12	jsr $1269			jsr 	GetNext
.1470	20 b5 15	jsr $15b5			jsr 	GetReferenceTerm 			; figure out the reference.
.1473	8a		txa				txa 								; reference in YA
.1474	20 13 0a	jsr $0a13			jsr 	PushIntegerYA 				; write it out.
.1477	80 06		bra $147f			bra 	_CNParametersDone
.1479					_CNNoReferenceGiven:
.1479	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.147b	a8		tay				tay
.147c	20 13 0a	jsr $0a13			jsr 	PushIntegerYA 				; write it out.
.147f					_CNParametersDone:
.147f	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1481	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.1484	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; look for ,
.1487	c9 2c		cmp #$2c			cmp 	#","
.1489	d0 05		bne $1490			bne 	_CNExit
.148b	20 69 12	jsr $1269			jsr 	GetNext 					; consume ,
.148e	80 d5		bra $1465			bra 	CommandNEXT 				; and go round.
.1490					_CNExit:
.1490	60		rts				rts
.1491					CommandON:
.1491	20 74 12	jsr $1274			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1494	48		pha				pha 								; save on stack
.1495	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1497	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1499	f0 09		beq $14a4			beq 	_COCreateLoop
.149b	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.149d	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.149f	f0 03		beq $14a4			beq 	_COCreateLoop
.14a1	4c 5d 17	jmp $175d		jmp	ErrorV_syntax
.14a4					_COCreateLoop:
.14a4	8a		txa				txa 								; compile a goto/gosub somewhere
.14a5	da		phx				phx
.14a6	20 44 13	jsr $1344			jsr 	CompileBranchCommand
.14a9	fa		plx				plx
.14aa	20 5b 12	jsr $125b			jsr 	LookNextNonSpace			; ',' follows
.14ad	c9 2c		cmp #$2c			cmp 	#","
.14af	d0 0a		bne $14bb			bne 	_COComplete 				; if so, more line numbers
.14b1	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.14b3	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.14b6	20 69 12	jsr $1269			jsr 	GetNext
.14b9	80 e9		bra $14a4			bra 	_COCreateLoop
.14bb					_COComplete:
.14bb	68		pla				pla 								; throw GOTO/GOSUB
.14bc	60		rts				rts
.14bd					ParseConstant:
.14bd	a2 00		ldx #$00			ldx 	#0
.14bf	20 83 1c	jsr $1c83			jsr 	FloatEncodeStart 			; send first
.14c2					_ParseLoop:
.14c2	20 58 12	jsr $1258			jsr 	LookNext 					; send subsequent
.14c5	20 86 1c	jsr $1c86			jsr 	FloatEncodeContinue
.14c8	90 05		bcc $14cf			bcc 	_ParseDone
.14ca	20 69 12	jsr $1269			jsr 	GetNext 					; consume it
.14cd	80 f3		bra $14c2			bra 	_ParseLoop
.14cf					_ParseDone:
.14cf	b5 30		lda $30,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.14d1	29 80		and #$80			and 	#$80
.14d3	15 6c		ora $6c,x			ora 	NSExponent,x 				; 16 bit int check
.14d5	15 54		ora $54,x			ora 	NSMantissa2,x
.14d7	15 60		ora $60,x			ora 	NSMantissa3,x
.14d9	18		clc				clc
.14da	d0 05		bne $14e1			bne 	_ParseExit 					; exit with CC if need float to compile
.14dc	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; read into YA.
.14de	b4 48		ldy $48,x			ldy		NSMantissa1,x
.14e0	38		sec				sec
.14e1					_ParseExit:
.14e1	60		rts				rts
.14e2					CommandPRINT:
.14e2	20 5b 12	jsr $125b			jsr 	LookNextNonSpace			; what follows ?
.14e5	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.14e7	f0 1f		beq $1508			beq 	_CPCheckEnd
.14e9	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.14eb	f0 16		beq $1503			beq 	_CPTabCheckEnd
.14ed	20 1f 15	jsr $151f			jsr 	_CPAtEnd 					; check for : and EOL
.14f0	b0 22		bcs $1514			bcs 	_CPExitCR 					; exit with CR
.14f2	20 14 0c	jsr $0c14			jsr 	CompileExpressionAt0 		; so it is something to print
.14f5	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.14f7	29 40		and #$40			and 	#NSSString 					; if string
.14f9	d0 02		bne $14fd			bne 	_CPOut
.14fb	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.14fd					_CPOut:
.14fd	8a		txa				txa 								; print that thing
.14fe	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.1501	80 df		bra $14e2			bra 	CommandPRINT 				; and loop round/
.1503					_CPTabCheckEnd:
.1503	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1505	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.1508					_CPCheckEnd:
.1508	20 69 12	jsr $1269			jsr 	GetNext 					; consume it.
.150b	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; what follows ?
.150e	20 1f 15	jsr $151f			jsr 	_CPAtEnd 					; reached end
.1511	90 cf		bcc $14e2			bcc 	CommandPRINT 				; no, loop back
.1513	60		rts				rts
.1514					_CPExitCR:
.1514	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1516	20 26 0a	jsr $0a26			jsr 	PushIntegerA
.1519	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.151b	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.151e	60		rts				rts
.151f					_CPAtEnd:
.151f	c9 00		cmp #$00			cmp 	#0
.1521	f0 06		beq $1529			beq 	_CPIsEnd
.1523	c9 3a		cmp #$3a			cmp 	#":"
.1525	f0 02		beq $1529			beq 	_CPIsEnd
.1527	18		clc				clc
.1528	60		rts				rts
.1529					_CPIsEnd:
.1529	38		sec				sec
.152a	60		rts				rts
.152b					CommandREAD:
.152b	a2 b2		ldx #$b2			ldx 	#PCD_READ
.152d	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.152f					CommandReadInputCommon:
.152f	8e 0d 05	stx $050d			stx 	numberPCode
.1532	8c 0e 05	sty $050e			sty 	stringPCode
.1535					_CRLoop:
.1535	20 74 12	jsr $1274			jsr 	GetNextNonSpace 			; first char of identifier
.1538	20 8a 12	jsr $128a			jsr 	CharIsAlpha 				; check A-Z
.153b	90 27		bcc $1564			bcc 	_CRSyntax
.153d	20 b5 15	jsr $15b5			jsr 	GetReferenceTerm 			; get the variable.
.1540	48		pha				pha 								; save type.
.1541	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1543	c9 40		cmp #$40			cmp 	#NSSString
.1545	f0 05		beq $154c			beq 	_CRString
.1547	ad 0d 05	lda $050d			lda 	numberPCode 				; output read/input
.154a	80 03		bra $154f			bra 	_CRHaveType
.154c					_CRString:
.154c	ad 0e 05	lda $050e			lda 	stringPCode					; output read$/input$
.154f					_CRHaveType:
.154f	20 fe 08	jsr $08fe			jsr 	WriteCodeByte 				; so we have one typed data item.
.1552	68		pla				pla 								; restore type
.1553	38		sec				sec  								; write update code.
.1554	20 67 15	jsr $1567			jsr 	GetSetVariable
.1557	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; , follows ?
.155a	c9 2c		cmp #$2c			cmp 	#","
.155c	d0 05		bne $1563			bne 	_CRExit 					; if not, end of READ.
.155e	20 69 12	jsr $1269			jsr 	GetNext 					; consume comma
.1561	80 d2		bra $1535			bra 	_CRLoop 					; keep going
.1563					_CRExit:
.1563	60		rts				rts
.1564					_CRSyntax:
.1564	4c 5d 17	jmp $175d		jmp	ErrorV_syntax
.050d					numberPCode:
>050d							.fill 	1
.050e					stringPCode:
>050e							.fill 	1
.1567					GetSetVariable:
.1567	08		php				php 								; save direction on stack
.1568	c0 00		cpy #$00			cpy 	#$00
.156a	30 21		bmi $158d			bmi 	_GSVReadWriteSpecial
.156c	c9 00		cmp #$00			cmp 	#$00
.156e	30 33		bmi $15a3			bmi 	_GSVArray
.1570	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1572	4a		lsr a				lsr 	a 							; divide by 2
.1573	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1575	28		plp				plp
.1576	90 02		bcc $157a			bcc 	_GSVNotWrite
.1578	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.157a					_GSVNotWrite:
.157a	85 2a		sta $2a				sta 	zTemp0
.157c	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.157d	4a		lsr a				lsr 	a
.157e	a8		tay				tay
.157f	8a		txa				txa
.1580	6a		ror a				ror 	a
.1581	aa		tax				tax
.1582	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1583	05 2a		ora $2a				ora 	zTemp0 						; which is the first byte of the opcode
.1585	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.1588	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1589	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.158c	60		rts				rts
.158d					_GSVReadWriteSpecial:
.158d	28		plp				plp
.158e	b0 10		bcs $15a0			bcs 	_GSVSyntax
.1590	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1592	f0 06		beq $159a			beq 	_GSVRWString
.1594	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1596	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.1599	60		rts				rts
.159a					_GSVRWString:
.159a	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.159c	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.159f	60		rts				rts
.15a0					_GSVSyntax:
.15a0	4c 5d 17	jmp $175d		jmp	ErrorV_syntax
.15a3					_GSVArray:
.15a3	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.15a5	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.15a6	4a		lsr a				lsr 	a
.15a7	4a		lsr a				lsr 	a
.15a8	4a		lsr a				lsr 	a
.15a9	4a		lsr a				lsr 	a
.15aa	28		plp				plp 								; if writing array then set bit 2.
.15ab	90 02		bcc $15af			bcc 	_GSVANotWrite
.15ad	09 04		ora #$04			ora 	#4
.15af					_GSVANotWrite:
.15af	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.15b1	20 fe 08	jsr $08fe			jsr 	WriteCodeByte 				; and write it out
.15b4	60		rts				rts
.15b5					GetReferenceTerm:
.15b5	20 d9 12	jsr $12d9			jsr 	ExtractVariableName 		; get name & type info
.15b8	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.15ba	30 10		bmi $15cc			bmi 	_GRTArray
.15bc	da		phx				phx 								; save type on stack
.15bd	20 ce 0c	jsr $0cce			jsr 	FindVariable 				; find it
.15c0	b0 06		bcs $15c8			bcs 	_GRTNoCreate 				; create if required.
.15c2	20 58 0a	jsr $0a58			jsr 	CreateVariableRecord 		; create a variable.
.15c5	20 ad 0a	jsr $0aad			jsr 	AllocateBytesForType 		; allocate memory for it
.15c8					_GRTNoCreate:
.15c8	68		pla				pla 								; get type back, strip out type information.
.15c9	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.15cb	60		rts				rts
.15cc					_GRTArray:
.15cc	da		phx				phx 								; save type information
.15cd	20 ce 0c	jsr $0cce			jsr 	FindVariable 				; read its data, the base address in YX
.15d0	90 18		bcc $15ea			bcc 	_GRTUndeclared 				; undeclared array.
.15d2	da		phx				phx 								; save base address
.15d3	5a		phy				phy
.15d4	20 a4 0b	jsr $0ba4			jsr 	OutputIndexGroup 			; create an index group and generate them
.15d7	7a		ply				ply 								; get the array base address into YX
.15d8	fa		plx				plx
.15d9	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.15db	18		clc				clc
.15dc	20 67 15	jsr $1567			jsr 	GetSetVariable 				; load the address of the array structure.
.15df	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.15e1	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.15e4	68		pla				pla 								; and the type data into A
.15e5	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.15e7	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.15e9	60		rts				rts
.15ea					_GRTUndeclared:
.15ea	4c 14 18	jmp $1814		jmp	ErrorV_undeclared
.15ed					CommandREM:
.15ed	20 58 12	jsr $1258			jsr 	LookNext
.15f0	f0 05		beq $15f7			beq 	_CRExit
.15f2	20 69 12	jsr $1269			jsr 	GetNext
.15f5	80 f6		bra $15ed			bra 	CommandREM
.15f7					_CRExit:
.15f7	60		rts				rts
.15f8					STRReset:
.15f8	ad 07 05	lda $0507			lda	 	compilerStartHigh 			; set up the two table pointers
.15fb	8d 12 05	sta $0512			sta 	variableListEnd+1
.15fe	9c 11 05	stz $0511			stz 	variableListEnd
.1601	ad 08 05	lda $0508			lda 	compilerEndHigh
.1604	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1607	9c 0f 05	stz $050f			stz 	lineNumberTable
.160a	ad 11 05	lda $0511			lda 	variableListEnd
.160d	85 2b		sta $2b				sta 	zTemp0+1
.160f	64 2a		stz $2a				stz 	zTemp0
.1611	a9 00		lda #$00			lda 	#0
.1613	92 2a		sta ($2a)			sta 	(zTemp0)
.1615	a9 00		lda #$00			lda 	#((0) & $FF)
.1617	8d 13 05	sta $0513			sta 	0+freeVariableMemory
.161a	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.161c	8d 14 05	sta $0514			sta 	1+freeVariableMemory
.161f	60		rts				rts
.050f					lineNumberTable:
>050f							.fill 	2
.0511					variableListEnd:
>0511							.fill 	2
.0513					freeVariableMemory:
>0513							.fill 	2
.1620					CompileTerm:
.1620	20 74 12	jsr $1274			jsr 	GetNextNonSpace 			; get first non space character.
.1623	30 72		bmi $1697			bmi 	_CTUnaryFunctions
.1625	20 7e 12	jsr $127e			jsr 	CharIsDigit 				; found a number
.1628	b0 3a		bcs $1664			bcs 	_CTDigit
.162a	c9 2e		cmp #$2e			cmp 	#"."
.162c	f0 36		beq $1664			beq 	_CTDigit
.162e	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1630	f0 43		beq $1675			beq 	_CTString
.1632	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1634	f0 28		beq $165e			beq 	_CTOtherBase
.1636	c9 24		cmp #$24			cmp 	#"$"
.1638	f0 24		beq $165e			beq 	_CTOtherBase
.163a	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.163c	f0 17		beq $1655			beq 	_CTBrackets
.163e	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1640	90 10		bcc $1652			bcc 	_CTSyntax
.1642	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1644	b0 0c		bcs $1652			bcs 	_CTSyntax
.1646	20 b5 15	jsr $15b5			jsr 	GetReferenceTerm 			; figure out what it is.
.1649	48		pha				pha 								; save type on stack
.164a	18		clc				clc 								; read it
.164b	20 67 15	jsr $1567			jsr 	GetSetVariable
.164e	68		pla				pla
.164f	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1651	60		rts				rts
.1652					_CTSyntax:
.1652	4c 5d 17	jmp $175d		jmp	ErrorV_syntax
.1655					_CTBrackets:
.1655	20 14 0c	jsr $0c14			jsr 	CompileExpressionAt0
.1658	48		pha				pha
.1659	20 60 09	jsr $0960			jsr 	CheckNextRParen
.165c	68		pla				pla
.165d	60		rts				rts
.165e					_CTOtherBase:
.165e	20 ac 08	jsr $08ac			jsr 	InlineNonDecimal 			; non decimal constant handler
.1661	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1663	60		rts				rts
.1664					_CTDigit:
.1664	20 bd 14	jsr $14bd			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1667	90 06		bcc $166f			bcc	 	_CTFloat 					; have a float or long int.
.1669	20 13 0a	jsr $0a13			jsr 	PushIntegerYA 				; code to push on stack
.166c	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.166e	60		rts				rts
.166f					_CTFloat:
.166f	20 35 0a	jsr $0a35			jsr 	PushFloatCommand			; code to push float
.1672	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1674	60		rts				rts
.1675					_CTString:
.1675	20 35 09	jsr $0935			jsr 	BufferClear 				; copy it to the buffer
.1678					_CTStringLoop:
.1678	20 58 12	jsr $1258			jsr 	LookNext 					; reached EOL/EOS
.167b	f0 d5		beq $1652			beq 	_CTSyntax
.167d	c9 22		cmp #$22			cmp 	#'"'
.167f	f0 08		beq $1689			beq 	_CTStringDone
.1681	20 39 09	jsr $0939			jsr 	BufferWrite 				; write and consume
.1684	20 69 12	jsr $1269			jsr 	GetNext
.1687	80 ef		bra $1678			bra 	_CTStringLoop
.1689					_CTStringDone:
.1689	20 69 12	jsr $1269			jsr 	GetNext 					; consume closing quote.
.168c	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.168e	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.1691	20 45 09	jsr $0945			jsr 	BufferOutput
.1694	a9 40		lda #$40			lda 	#NSSString 					; string type
.1696	60		rts				rts
.1697					_CTUnaryFunctions:
.1697	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1699	f0 0a		beq $16a5			beq 	_CTNegation
.169b	a2 00		ldx #$00			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.169d	a0 10		ldy #$10			ldy 	#UnaryTables >> 8
.169f	20 fa 10	jsr $10fa			jsr 	GeneratorProcess
.16a2	90 ae		bcc $1652			bcc		_CTSyntax
.16a4	60		rts				rts
.16a5					_CTNegation:
.16a5	20 20 16	jsr $1620			jsr 	CompileTerm 				; compile a term.
.16a8	48		pha				pha
.16a9	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.16ab	c9 00		cmp #$00			cmp 	#NSSIFloat
.16ad	d0 07		bne $16b6			bne 	_CTType 					; error
.16af	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.16b1	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.16b4	68		pla				pla 								; return original type.
.16b5	60		rts				rts
.16b6					_CTType:
.16b6	4c 6d 17	jmp $176d		jmp	ErrorV_type
.16b9					CommandWAIT:
.16b9	20 5b 12	jsr $125b			jsr 	LookNextNonSpace
.16bc	c9 2c		cmp #$2c			cmp 	#","
.16be	f0 10		beq $16d0			beq 	_CWThirdParameter
.16c0	a9 00		lda #$00			lda 	#0
.16c2	20 26 0a	jsr $0a26			jsr 	PushIntegerA
.16c5					_CWExit:
.16c5	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.16c7	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.16ca	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.16cc	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.16cf	60		rts				rts
.16d0					_CWThirdParameter:
.16d0	20 69 12	jsr $1269			jsr 	GetNext
.16d3	20 16 0c	jsr $0c16			jsr 	CompileExpressionAtA
.16d6	29 40		and #$40			and 	#NSSTypeMask
.16d8	c9 00		cmp #$00			cmp 	#NSSIFloat
.16da	f0 e9		beq $16c5			beq 	_CWExit
.16dc	4c 6d 17	jmp $176d		jmp	ErrorV_type
.16df					CommandCMD:
.16df	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.16e1	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.16e4	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; followed by a , ?
.16e7	c9 2c		cmp #$2c			cmp 	#","
.16e9	d0 06		bne $16f1			bne 	_CCMDExit
.16eb	20 69 12	jsr $1269			jsr 	GetNext 					; consume comma.
.16ee	20 e2 14	jsr $14e2			jsr 	CommandPRINT 				; do the print code
.16f1					_CCMDExit:
.16f1	60		rts				rts
.16f2					CommandOPEN:
.16f2	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; followed by a , ?
.16f5	c9 2c		cmp #$2c			cmp 	#","
.16f7	d0 15		bne $170e			bne 	_COTwoDefaults
.16f9	20 69 12	jsr $1269			jsr 	GetNext 					; consume comma
.16fc	20 14 0c	jsr $0c14			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.16ff	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1701	f0 1e		beq $1721			beq 	_COThreeIntegers
.1703	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1705	20 26 0a	jsr $0a26			jsr 	PushIntegerA
.1708	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.170a	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.170d	60		rts				rts
.170e					_COTwoDefaults:
.170e	a9 00		lda #$00			lda 	#0
.1710	20 26 0a	jsr $0a26			jsr 	PushIntegerA
.1713					_COCompileNullString:
.1713	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1715	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.1718	a9 00		lda #$00			lda 	#0
.171a	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.171d	20 fe 08	jsr $08fe			jsr 	WriteCodeByte
.1720	60		rts				rts
.1721					_COThreeIntegers:
.1721	20 5b 12	jsr $125b			jsr 	LookNextNonSpace 			; is there a ,
.1724	c9 2c		cmp #$2c			cmp 	#","
.1726	d0 eb		bne $1713			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1728	20 69 12	jsr $1269			jsr 	GetNext
.172b	20 14 0c	jsr $0c14			jsr 	CompileExpressionAt0 		; should be a filename
.172e	29 40		and #$40			and 	#NSSString
.1730	f0 01		beq $1733			beq 	_COType
.1732	60		rts				rts
.1733					_COType:
.1733	4c 6d 17	jmp $176d		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					objPtr:
>0028							.fill 	2
.002a					zTemp0:
>002a							.fill 	2
.002c					zTemp1:
>002c							.fill 	2
.002e					zTemp2:
>002e							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1736					SetErrorHandler:
.1736	8c 16 05	sty $0516			sty 	ErrorHandlerVector+1
.1739	8e 15 05	stx $0515			stx 	ErrorHandlerVector
.173c	60		rts				rts
.173d					CallErrorHandler:
.173d	6c 15 05	jmp ($0515)			jmp 	(ErrorHandlerVector)
.0515					ErrorHandlerVector:
>0515							.fill 	2
.1740					ErrorV_range:
.1740	20 3d 17	jsr $173d		jsr	CallErrorHandler
>1743	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>174b	41 4e 47 45 00
.1750					ErrorV_value:
.1750	20 3d 17	jsr $173d		jsr	CallErrorHandler
>1753	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>175b	45 00
.175d					ErrorV_syntax:
.175d	20 3d 17	jsr $173d		jsr	CallErrorHandler
>1760	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1768	52 52 4f 52 00
.176d					ErrorV_type:
.176d	20 3d 17	jsr $173d		jsr	CallErrorHandler
>1770	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1778	4d 41 54 43 48 00
.177e					ErrorV_unimplemented:
.177e	20 3d 17	jsr $173d		jsr	CallErrorHandler
>1781	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1789	45 4d 45 4e 54 45 44 00
.1791					ErrorV_assert:
.1791	20 3d 17	jsr $173d		jsr	CallErrorHandler
>1794	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>179c	41 49 4c 00
.17a0					ErrorV_line:
.17a0	20 3d 17	jsr $173d		jsr	CallErrorHandler
>17a3	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>17ab	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.17b7					ErrorV_internal:
.17b7	20 3d 17	jsr $173d		jsr	CallErrorHandler
>17ba	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>17c2	20 45 52 52 4f 52 00
.17c9					ErrorV_divzero:
.17c9	20 3d 17	jsr $173d		jsr	CallErrorHandler
>17cc	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>17d4	59 20 5a 45 52 4f 00
.17db					ErrorV_structure:
.17db	20 3d 17	jsr $173d		jsr	CallErrorHandler
>17de	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>17e6	45 20 49 4d 42 41 4c 41 4e 43 45 00
.17f2					ErrorV_stop:
.17f2	20 3d 17	jsr $173d		jsr	CallErrorHandler
>17f5	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>17fd	53 54 4f 50 50 45 44 00
.1805					ErrorV_data:
.1805	20 3d 17	jsr $173d		jsr	CallErrorHandler
>1808	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1810	41 54 41 00
.1814					ErrorV_undeclared:
.1814	20 3d 17	jsr $173d		jsr	CallErrorHandler
>1817	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>181f	41 52 52 41 59 00
.1825					ErrorV_redefine:
.1825	20 3d 17	jsr $173d		jsr	CallErrorHandler
>1828	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1830	44 45 46 49 4e 45 44 00
.1838					ErrorV_index:
.1838	20 3d 17	jsr $173d		jsr	CallErrorHandler
>183b	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1843	59 20 49 4e 44 45 58 00
.184b					ErrorV_memory:
.184b	20 3d 17	jsr $173d		jsr	CallErrorHandler
>184e	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>1856	45 4d 4f 52 59 00
.185c					ErrorV_channel:
.185c	20 3d 17	jsr $173d		jsr	CallErrorHandler
>185f	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>1867	54 50 55 54 20 45 52 52 4f 52 00
.1872					MoveObjectForward:
.1872	b2 28		lda ($28)			lda 	(objPtr) 					; get next
.1874	c9 ff		cmp #$ff			cmp 	#$FF
.1876	f0 36		beq $18ae			beq 	_MOFEnd
.1878	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.187a	90 24		bcc $18a0			bcc 	_MOFAdvance1 				; forward 1
.187c	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.187e	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.1880	90 20		bcc $18a2			bcc 	_MOFAdvanceY
.1882	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.1884	90 1a		bcc $18a0			bcc 	_MOFAdvance1 				; forward 1
.1886	a8		tay				tay 								; read the size.
.1887	b9 ec 17	lda $17ec,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.188a	a8		tay				tay
.188b	c8		iny				iny 								; add 1 for the system token.
.188c	d0 14		bne $18a2			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.188e	a0 01		ldy #$01			ldy 	#1 							; get length byte
.1890	b1 28		lda ($28),y			lda 	(objPtr),y
.1892	a8		tay				tay 								; into Y.
.1893	18		clc				clc
.1894	a5 28		lda $28				lda 	objPtr						; add 2 to the object pointer
.1896	69 02		adc #$02			adc 	#2
.1898	85 28		sta $28				sta 	objPtr
.189a	90 02		bcc $189e			bcc 	_MOFNoCarry1
.189c	e6 29		inc $29				inc 	objPtr+1
.189e					_MOFNoCarry1:
.189e	80 02		bra $18a2			bra 	_MOFAdvanceY
.18a0					_MOFAdvance1:
.18a0	a0 01		ldy #$01			ldy 	#1
.18a2					_MOFAdvanceY:
.18a2	98		tya				tya 								; add Y to objPtr
.18a3	18		clc				clc
.18a4	65 28		adc $28				adc 	objPtr
.18a6	85 28		sta $28				sta 	objPtr
.18a8	90 02		bcc $18ac			bcc 	_MOFNoCarry2
.18aa	e6 29		inc $29				inc 	objPtr+1
.18ac					_MOFNoCarry2:
.18ac	18		clc				clc 								; not completed.
.18ad	60		rts				rts
.18ae					_MOFEnd:
.18ae	e6 28		inc $28				inc 	objPtr
.18b0	d0 02		bne $18b4			bne 	_MOFENoCarry
.18b2	e6 29		inc $29				inc 	objPtr+1
.18b4					_MOFENoCarry:
.18b4	38		sec				sec
.18b5	60		rts				rts
.18b6					MOFSizeTable:
>18b6	01					.byte	1         	; $ca .shift
>18b7	01					.byte	1         	; $cb .byte
>18b8	02					.byte	2         	; $cc .word
>18b9	05					.byte	5         	; $cd .float
>18ba	ff					.byte	255       	; $ce .string
>18bb	ff					.byte	255       	; $cf .data
>18bc	02					.byte	2         	; $d0 .goto
>18bd	02					.byte	2         	; $d1 .gosub
>18be	02					.byte	2         	; $d2 .goto.z
>18bf	02					.byte	2         	; $d3 .goto.nz
>18c0	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0030					NSStatus:
>0030							.fill 	MathStackSize
.003c					NSMantissa0:
>003c							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0048					NSMantissa1:
>0048							.fill 	MathStackSize
.0054					NSMantissa2:
>0054							.fill 	MathStackSize
.0060					NSMantissa3:
>0060							.fill 	MathStackSize
.006c					NSExponent:
>006c							.fill 	MathStackSize
.0517					numberBuffer:
>0517							.fill 	34
.18c1					FloatSubtract:
.18c1	b5 30		lda $30,x			lda 	NSStatus,x 					; negate top of stack
.18c3	49 80		eor #$80			eor 	#$80
.18c5	95 30		sta $30,x			sta 	NSStatus,x					; and fall through.
.18c7					FloatAdd:
.18c7	ca		dex				dex
.18c8	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised.
.18ca	15 6d		ora $6d,x			ora 	NSExponent+1,x
.18cc	15 60		ora $60,x			ora 	NSMantissa3,x
.18ce	15 61		ora $61,x			ora 	NSMantissa3+1,x
.18d0	d0 04		bne $18d6			bne 	_FAUseFloat
.18d2	20 63 1c	jsr $1c63			jsr 	FloatInt32Add 				; use the int32 one.
.18d5	60		rts				rts
.18d6					_FAUseFloat:
.18d6	20 f8 1b	jsr $1bf8			jsr 	FloatNormalise 				; normalise S[X]
.18d9	f0 51		beq $192c			beq 	_FAReturn1
.18db	e8		inx				inx 								; normalise S[X+1]
.18dc	20 f8 1b	jsr $1bf8			jsr 	FloatNormalise
.18df	ca		dex				dex
.18e0	c9 00		cmp #$00			cmp 	#0
.18e2	f0 60		beq $1944			beq 	_FAExit 					; if so, just return A
.18e4	b5 6c		lda $6c,x			lda 	NSExponent,x 				; are the exponents the same ?
.18e6	d5 6d		cmp $6d,x			cmp 	NSExponent+1,x
.18e8	f0 18		beq $1902			beq 	_FAExponentsEqual
.18ea	b5 6c		lda $6c,x			lda 	NSExponent,x 				; work out the larger exponent
.18ec	a8		tay				tay
.18ed	38		sec				sec 								; do a signed comparison of the exponents.
.18ee	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.18f0	50 02		bvc $18f4			bvc 	_FANoSignedChange
.18f2	49 80		eor #$80			eor 	#$80
.18f4					_FANoSignedChange:
.18f4	29 80		and #$80			and 	#$80
.18f6	10 02		bpl $18fa			bpl 	_FAHaveMax
.18f8	b4 6d		ldy $6d,x			ldy 	NSExponent+1,x
.18fa					_FAHaveMax:
.18fa	20 45 19	jsr $1945			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.18fd	e8		inx				inx
.18fe	20 45 19	jsr $1945			jsr 	_FAShiftToExponent
.1901	ca		dex				dex
.1902					_FAExponentsEqual:
.1902	b5 30		lda $30,x			lda 	NSStatus,x 					; are the signs the same
.1904	55 31		eor $31,x			eor 	NSStatus+1,x
.1906	30 0e		bmi $1916			bmi 	_FADifferentSigns
.1908	20 2f 1c	jsr $1c2f			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.190b	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.190d	10 35		bpl $1944			bpl 	_FAExit 					; if no, we are done.
.190f	20 bc 1e	jsr $1ebc			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.1912	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump the exponent and exit
.1914	80 2e		bra $1944			bra 	_FAExit
.1916					_FADifferentSigns:
.1916	20 49 1c	jsr $1c49			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.1919	b5 60		lda $60,x			lda 	NSMantissa3,x 				; is the result negative ?
.191b	10 06		bpl $1923			bpl 	_FACheckZero 				; if no, check for -0
.191d	20 65 1e	jsr $1e65			jsr 	FloatNegate 					; netate result
.1920	20 6c 1e	jsr $1e6c			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.1923					_FACheckZero:
.1923	20 c5 1e	jsr $1ec5			jsr 	FloatIsZero	 				; check for -0
.1926	d0 1c		bne $1944			bne 	_FAExit
.1928	74 30		stz $30,x			stz 	NSStatus,x
.192a	80 18		bra $1944			bra 	_FAExit
.192c					_FAReturn1:
.192c	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.192e	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1930	b5 49		lda $49,x			lda 	NSMantissa1+1,x
.1932	95 48		sta $48,x			sta 	NSMantissa1,x
.1934	b5 55		lda $55,x			lda 	NSMantissa2+1,x
.1936	95 54		sta $54,x			sta 	NSMantissa2,x
.1938	b5 61		lda $61,x			lda 	NSMantissa3+1,x
.193a	95 60		sta $60,x			sta 	NSMantissa3,x
.193c	b5 6d		lda $6d,x			lda 	NSExponent+1,x
.193e	95 6c		sta $6c,x			sta 	NSExponent,x
.1940	b5 31		lda $31,x			lda 	NSStatus+1,x
.1942	95 30		sta $30,x			sta 	NSStatus,x
.1944					_FAExit:
.1944	60		rts				rts
.1945					_FAShiftToExponent:
.1945					_FAShiftToExponent2:
.1945	98		tya				tya 								; compare Y to exponent
.1946	d5 6c		cmp $6c,x			cmp 	NSExponent,x 				; reached the exponent required ?
.1948	f0 07		beq $1951			beq 	_FASEExit 					; exit if so.
.194a	20 bc 1e	jsr $1ebc			jsr 	FloatShiftRight	 			; shift the mantissa right
.194d	f6 6c		inc $6c,x			inc 	NSExponent,x 				; increment exponent
.194f	80 f4		bra $1945			bra 	_FAShiftToExponent2
.1951					_FASEExit:
.1951	60		rts				rts
.1952					CompareEqual:
.1952	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1954	d0 09		bne $195f			bne 	ReturnFalse
.1956					ReturnTrue:
.1956	a9 01		lda #$01			lda 	#1
.1958	95 3c		sta $3c,x			sta 	NSMantissa0,x
.195a	a9 80		lda #$80			lda 	#$80
.195c	95 30		sta $30,x			sta 	NSStatus,x
.195e	60		rts				rts
.195f					ReturnFalse:
.195f	74 3c		stz $3c,x			stz 	NSMantissa0,x
.1961	60		rts				rts
.1962					CompareNotEqual:
.1962	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1964	d0 f0		bne $1956			bne 	ReturnTrue
.1966	80 f7		bra $195f			bra 	ReturnFalse
.1968					CompareLess:
.1968	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.196a	c9 ff		cmp #$ff			cmp 	#$FF
.196c	f0 e8		beq $1956			beq 	ReturnTrue
.196e	80 ef		bra $195f			bra 	ReturnFalse
.1970					CompareGreater:
.1970	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1972	c9 01		cmp #$01			cmp 	#$01
.1974	f0 e0		beq $1956			beq 	ReturnTrue
.1976	80 e7		bra $195f			bra 	ReturnFalse
.1978					CompareLessEqual:
.1978	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.197a	c9 01		cmp #$01			cmp 	#$01
.197c	d0 d8		bne $1956			bne 	ReturnTrue
.197e	80 df		bra $195f			bra 	ReturnFalse
.1980					CompareGreaterEqual:
.1980	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1982	c9 ff		cmp #$ff			cmp 	#$FF
.1984	d0 d0		bne $1956			bne 	ReturnTrue
.1986	80 d7		bra $195f			bra 	ReturnFalse
.1988					FloatCompare:
.1988	b5 6c		lda $6c,x			lda 	NSExponent,x 				; float comparison.
.198a	15 6b		ora $6b,x			ora 	NSExponent-1,x 				; integer if both integer.
.198c	48		pha				pha
.198d	20 c1 18	jsr $18c1			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.1990	68		pla				pla
.1991	d0 0c		bne $199f			bne 	_FCCompareFloat
.1993	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1995	15 48		ora $48,x			ora 	NSMantissa1,x
.1997	15 54		ora $54,x			ora 	NSMantissa2,x
.1999	15 60		ora $60,x			ora 	NSMantissa3,x
.199b	f0 14		beq $19b1			beq 	_FCExit 					; if zero, return zero
.199d	80 0a		bra $19a9			bra 	_FCSign
.199f					_FCCompareFloat:
.199f	b5 48		lda $48,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.19a1	29 f0		and #$f0			and 	#$F0
.19a3	15 54		ora $54,x			ora 	NSMantissa2,x
.19a5	15 60		ora $60,x			ora 	NSMantissa3,x
.19a7	f0 08		beq $19b1			beq 	_FCExit 					; zero, so approximately identical
.19a9					_FCSign:
.19a9	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.19ab	34 30		bit $30,x			bit 	NSStatus,x
.19ad	10 02		bpl $19b1			bpl 	_FCExit
.19af					_FCNegative:
.19af	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.19b1					_FCExit:
.19b1	20 a5 1e	jsr $1ea5			jsr 	FloatSetByte 				; set the result 255,0,1
.19b4	60		rts				rts
.19b5					FloatScalarTable:
>19b5	66 66 66 66				.dword $66666666 ; 0.1
>19b9	de					.byte $de
>19ba	1f 85 eb 51				.dword $51eb851f ; 0.01
>19be	db					.byte $db
>19bf	4c 37 89 41				.dword $4189374c ; 0.001
>19c3	d8					.byte $d8
>19c4	ac 8b db 68				.dword $68db8bac ; 0.0001
>19c8	d4					.byte $d4
>19c9	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>19cd	d1					.byte $d1
>19ce	83 de 1b 43				.dword $431bde83 ; 1e-06
>19d2	ce					.byte $ce
>19d3	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>19d7	ca					.byte $ca
>19d8	89 3b e6 55				.dword $55e63b89 ; 1e-08
>19dc	c7					.byte $c7
>19dd	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>19e1	c4					.byte $c4
>19e2	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>19e6	c0					.byte $c0
>19e7	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>19eb	bd					.byte $bd
.19ec					FloatDivide:
.19ec	48		pha				pha
.19ed	20 f8 1b	jsr $1bf8			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.19f0	ca		dex				dex
.19f1	c9 00		cmp #$00			cmp 	#0
.19f3	f0 1e		beq $1a13			beq 	_FDZero
.19f5	20 f8 1b	jsr $1bf8			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.19f8	f0 16		beq $1a10			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.19fa	20 5b 1a	jsr $1a5b			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.19fd	20 28 1a	jsr $1a28			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.1a00	20 f8 1b	jsr $1bf8			jsr		FloatNormalise 				; renormalise
.1a03	20 ee 1b	jsr $1bee			jsr 	FloatCalculateSign 			; calculate result sign
.1a06	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent
.1a08	38		sec				sec
.1a09	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.1a0b	38		sec				sec
.1a0c	e9 1e		sbc #$1e			sbc 	#30
.1a0e	95 6c		sta $6c,x			sta 	NSExponent,x
.1a10					_FDExit:
.1a10	68		pla				pla
.1a11	18		clc				clc
.1a12	60		rts				rts
.1a13					_FDZero:
.1a13	68		pla				pla
.1a14	38		sec				sec
.1a15	60		rts				rts
.1a16					DivideInt32:
.1a16	20 de 1a	jsr $1ade			jsr 	FloatIntegerPart 			; make both integers
.1a19	ca		dex				dex
.1a1a	20 de 1a	jsr $1ade			jsr 	FloatIntegerPart
.1a1d	20 39 1a	jsr $1a39			jsr 	Int32Divide 				; divide
.1a20	20 28 1a	jsr $1a28			jsr 	NSMCopyPlusTwoToZero 		; copy result
.1a23	20 ee 1b	jsr $1bee			jsr 	FloatCalculateSign 			; calculate result sign
.1a26	18		clc				clc
.1a27	60		rts				rts
.1a28					NSMCopyPlusTwoToZero:
.1a28	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.1a2a	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1a2c	b5 4a		lda $4a,x			lda 	NSMantissa1+2,x
.1a2e	95 48		sta $48,x			sta 	NSMantissa1,x
.1a30	b5 56		lda $56,x			lda 	NSMantissa2+2,x
.1a32	95 54		sta $54,x			sta 	NSMantissa2,x
.1a34	b5 62		lda $62,x			lda 	NSMantissa3+2,x
.1a36	95 60		sta $60,x			sta 	NSMantissa3,x
.1a38	60		rts				rts
.1a39					Int32Divide:
.1a39	48		pha				pha 								; save AXY
.1a3a	5a		phy				phy
.1a3b	20 86 1e	jsr $1e86			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.1a3e	20 9f 1e	jsr $1e9f			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.1a41	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.1a43					_I32DivideLoop:
.1a43	e8		inx				inx
.1a44	e8		inx				inx
.1a45	20 b2 1e	jsr $1eb2			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.1a48	ca		dex				dex
.1a49	ca		dex				dex
.1a4a	20 b3 1e	jsr $1eb3			jsr 	FloatRotateLeft
.1a4d	20 79 1a	jsr $1a79			jsr 	FloatDivideCheck 			; check if subtract possible
.1a50	90 02		bcc $1a54			bcc 	_I32DivideNoCarryIn
.1a52	f6 3e		inc $3e,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.1a54					_I32DivideNoCarryIn:
.1a54	88		dey				dey 								; loop round till division completed.
.1a55	d0 ec		bne $1a43			bne 	_I32DivideLoop
.1a57	7a		ply				ply 								; restore AXY and exit
.1a58	68		pla				pla
.1a59	18		clc				clc
.1a5a	60		rts				rts
.1a5b					Int32ShiftDivide:
.1a5b	48		pha				pha 								; save AY
.1a5c	5a		phy				phy
.1a5d	e8		inx				inx 								; clear S[X+2]
.1a5e	e8		inx				inx
.1a5f	20 a3 1e	jsr $1ea3			jsr 	FloatSetZero
.1a62	ca		dex				dex
.1a63	ca		dex				dex
.1a64	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.1a66					_I32SDLoop:
.1a66	20 79 1a	jsr $1a79			jsr 	FloatDivideCheck 			; check if subtract possible
.1a69	e8		inx				inx
.1a6a	e8		inx				inx
.1a6b	20 b3 1e	jsr $1eb3			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.1a6e	ca		dex				dex
.1a6f	ca		dex				dex
.1a70	20 b3 1e	jsr $1eb3			jsr 	FloatRotateLeft
.1a73	88		dey				dey 	 							; do 31 times
.1a74	d0 f0		bne $1a66			bne 	_I32SDLoop
.1a76	7a		ply				ply 								; restore AY and exit
.1a77	68		pla				pla
.1a78	60		rts				rts
.1a79					FloatDivideCheck:
.1a79	20 49 1c	jsr $1c49			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.1a7c	b0 04		bcs $1a82			bcs 	_DCSExit 					; if carry set, then could do, exit
.1a7e	20 2f 1c	jsr $1c2f			jsr 	FloatAddTopTwoStack 		; add it back in
.1a81	18		clc				clc 								; and return False
.1a82					_DCSExit:
.1a82	60		rts				rts
.1a83					FloatFractionalPart:
.1a83	5a		phy				phy
.1a84	b5 30		lda $30,x			lda 	NSStatus,x 					; take absolute value
.1a86	29 7f		and #$7f			and 	#$7F
.1a88	95 30		sta $30,x			sta 	NSStatus,x
.1a8a	20 f8 1b	jsr $1bf8			jsr 	FloatNormalise
.1a8d	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.1a8f	38		sec				sec
.1a90	e9 e0		sbc #$e0			sbc 	#$E0
.1a92	90 29		bcc $1abd			bcc 	_FFPExit 					; already fractional
.1a94	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.1a96	b0 22		bcs $1aba			bcs 	_FFPZero
.1a98	a8		tay				tay 								; put count to do in Y
.1a99	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do each in turn.
.1a9b	20 c2 1a	jsr $1ac2			jsr 	_FFPPartial
.1a9e	95 60		sta $60,x			sta 	NSMantissa3,x
.1aa0	b5 54		lda $54,x			lda 	NSMantissa2,x
.1aa2	20 c2 1a	jsr $1ac2			jsr 	_FFPPartial
.1aa5	95 54		sta $54,x			sta 	NSMantissa2,x
.1aa7	b5 48		lda $48,x			lda 	NSMantissa1,x
.1aa9	20 c2 1a	jsr $1ac2			jsr 	_FFPPartial
.1aac	95 48		sta $48,x			sta 	NSMantissa1,x
.1aae	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1ab0	20 c2 1a	jsr $1ac2			jsr 	_FFPPartial
.1ab3	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1ab5	20 c5 1e	jsr $1ec5			jsr 	FloatIsZero 					; zeroed check.
.1ab8	d0 03		bne $1abd			bne 	_FFPExit
.1aba					_FFPZero:
.1aba	20 a3 1e	jsr $1ea3			jsr 	FloatSetZero
.1abd					_FFPExit:
.1abd	20 f8 1b	jsr $1bf8			jsr 	FloatNormalise
.1ac0	7a		ply				ply
.1ac1	60		rts				rts
.1ac2					_FFPPartial:
.1ac2	c0 00		cpy #$00			cpy 	#0 							; no more to do
.1ac4	f0 17		beq $1add			beq 	_FFFPPExit
.1ac6	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.1ac8	b0 0c		bcs $1ad6			bcs 	_FFFPPWholeByte
.1aca	5a		phy				phy
.1acb					_FFFPPLeft:
.1acb	0a		asl a				asl 	a
.1acc	88		dey				dey
.1acd	d0 fc		bne $1acb			bne 	_FFFPPLeft
.1acf	7a		ply				ply
.1ad0					_FFFPPRight:
.1ad0	4a		lsr a				lsr 	a
.1ad1	88		dey				dey
.1ad2	d0 fc		bne $1ad0			bne 	_FFFPPRight
.1ad4	80 07		bra $1add			bra 	_FFFPPExit
.1ad6					_FFFPPWholeByte:
.1ad6	98		tya				tya 								; subtract 8 from count
.1ad7	38		sec				sec
.1ad8	e9 08		sbc #$08			sbc 	#8
.1ada	a8		tay				tay
.1adb	a9 00		lda #$00			lda 	#0 							; and clear all
.1add					_FFFPPExit:
.1add	60		rts				rts
.1ade					FloatIntegerPart:
.1ade	48		pha				pha
.1adf	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.1ae1	f0 1d		beq $1b00			beq 	_FIPExit 					; if so do nothing
.1ae3	20 c5 1e	jsr $1ec5			jsr 	FloatIsZero 				; is it zero ?
.1ae6	f0 15		beq $1afd			beq 	_FIPZero 					; if so return zero.
.1ae8	20 f8 1b	jsr $1bf8			jsr 	FloatNormalise 				; normalise
.1aeb	f0 10		beq $1afd			beq 	_FIPZero 					; normalised to zero, exit zero
.1aed					_FIPShift:
.1aed	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.1aef	10 07		bpl $1af8			bpl 	_FIPCheckZero
.1af1	20 bc 1e	jsr $1ebc			jsr 	FloatShiftRight 			; shift mantissa right
.1af4	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.1af6	80 f5		bra $1aed			bra 	_FIPShift
.1af8					_FIPCheckZero:
.1af8	20 c5 1e	jsr $1ec5			jsr 	FloatIsZero 				; avoid -0 problem
.1afb	d0 03		bne $1b00			bne 	_FIPExit 					; set to zero if mantissa zero.
.1afd					_FIPZero:
.1afd	20 a3 1e	jsr $1ea3			jsr 	FloatSetZero
.1b00					_FIPExit:
.1b00	68		pla				pla
.1b01	60		rts				rts
.1b02					FloatIntegerPartDown:
.1b02	48		pha				pha
.1b03	5a		phy				phy
.1b04	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.1b06	f0 36		beq $1b3e			beq 	_FIPExit 					; if so do nothing
.1b08	20 c5 1e	jsr $1ec5			jsr 	FloatIsZero 				; is it zero ?
.1b0b	f0 2e		beq $1b3b			beq 	_FIPZero 					; if so return zero.
.1b0d	20 f8 1b	jsr $1bf8			jsr 	FloatNormalise 				; normalise
.1b10	f0 29		beq $1b3b			beq 	_FIPZero 					; normalised to zero, exit zero
.1b12	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.1b14					_FIPShift:
.1b14	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.1b16	10 0a		bpl $1b22			bpl 	_FIPCheckDown
.1b18	20 bc 1e	jsr $1ebc			jsr 	FloatShiftRight 			; shift mantissa right
.1b1b	90 01		bcc $1b1e			bcc 	_FIPNoFrac 					; shifted a zero out ?
.1b1d	c8		iny				iny
.1b1e					_FIPNoFrac:
.1b1e	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.1b20	80 f2		bra $1b14			bra 	_FIPShift
.1b22					_FIPCheckDown:
.1b22	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.1b24	f0 10		beq $1b36			beq 	_FIPCheckZero
.1b26	34 30		bit $30,x			bit 	NSStatus,x 					; +ve
.1b28	10 0c		bpl $1b36			bpl 	_FIPCheckZero
.1b2a	e8		inx				inx 								; -ve so round *down*.
.1b2b	a9 01		lda #$01			lda 	#1
.1b2d	20 a5 1e	jsr $1ea5			jsr 	FloatSetByte
.1b30	20 65 1e	jsr $1e65			jsr 	FloatNegate
.1b33	20 c7 18	jsr $18c7			jsr 	FloatAdd
.1b36					_FIPCheckZero:
.1b36	20 c5 1e	jsr $1ec5			jsr 	FloatIsZero 				; avoid -0 problem
.1b39	d0 03		bne $1b3e			bne 	_FIPExit 					; set to zero if mantissa zero.
.1b3b					_FIPZero:
.1b3b	20 a3 1e	jsr $1ea3			jsr 	FloatSetZero
.1b3e					_FIPExit:
.1b3e	7a		ply				ply
.1b3f	68		pla				pla
.1b40	60		rts				rts
.1b41					FloatInt8Multiply:
.1b41	5a		phy				phy
.1b42	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.1b44	a8		tay				tay
.1b45	74 3c		stz $3c,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.1b47					_FI8MLoop:
.1b47	98		tya				tya 								; shift right shifter right into carry
.1b48	4a		lsr a				lsr 	a
.1b49	a8		tay				tay
.1b4a	90 0d		bcc $1b59			bcc 	_FI8MNoAdd
.1b4c	18		clc				clc
.1b4d	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1b4f	75 3d		adc $3d,x			adc 	NSMantissa0+1,x
.1b51	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1b53	b5 48		lda $48,x			lda 	NSMantissa1,x
.1b55	75 49		adc $49,x			adc 	NSMantissa1+1,x
.1b57	95 48		sta $48,x			sta 	NSMantissa1,x
.1b59					_FI8MNoAdd:
.1b59	16 3d		asl $3d,x			asl 	NSMantissa0+1,x 			; shift adder left
.1b5b	36 49		rol $49,x			rol 	NSMantissa1+1,x
.1b5d	c0 00		cpy #$00			cpy 	#0
.1b5f	d0 e6		bne $1b47			bne 	_FI8MLoop 					; until right shifter zero.
.1b61	7a		ply				ply
.1b62	60		rts				rts
.1b63					FloatMultiply:
.1b63	ca		dex				dex
.1b64	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised ?
.1b66	15 6d		ora $6d,x			ora 	NSExponent+1,x
.1b68	15 60		ora $60,x			ora 	NSMantissa3,x
.1b6a	15 61		ora $61,x			ora 	NSMantissa3+1,x
.1b6c	d0 21		bne $1b8f			bne 	_FMUseFloat
.1b6e	b5 30		lda $30,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.1b70	15 31		ora $31,x			ora 	NSStatus+1,x
.1b72	29 80		and #$80			and 	#$80
.1b74	15 60		ora $60,x			ora 	NSMantissa3,x
.1b76	15 54		ora $54,x			ora 	NSMantissa2,x
.1b78	15 48		ora $48,x			ora 	NSMantissa1,x
.1b7a	15 61		ora $61,x			ora 	NSMantissa3+1,x
.1b7c	15 55		ora $55,x			ora 	NSMantissa2+1,x
.1b7e	15 49		ora $49,x			ora 	NSMantissa1+1,x
.1b80	d0 04		bne $1b86			bne 	_FMInt32
.1b82	20 41 1b	jsr $1b41			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.1b85	60		rts				rts
.1b86					_FMInt32:
.1b86	20 b0 1b	jsr $1bb0			jsr 	FloatMultiplyShort			; use the int32 one.
.1b89	18		clc				clc 								; fix it up if gone out of range
.1b8a	75 6c		adc $6c,x			adc 	NSExponent,x
.1b8c	95 6c		sta $6c,x			sta 	NSExponent,x
.1b8e	60		rts				rts
.1b8f					_FMUseFloat:
.1b8f	20 f8 1b	jsr $1bf8			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.1b92	f0 18		beq $1bac			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.1b94	e8		inx				inx
.1b95	20 f8 1b	jsr $1bf8			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.1b98	ca		dex				dex
.1b99	c9 00		cmp #$00			cmp 	#0
.1b9b	f0 0c		beq $1ba9			beq 	_FDSetZero
.1b9d	20 b0 1b	jsr $1bb0			jsr 	FloatMultiplyShort 			; calculate the result.
.1ba0	75 6c		adc $6c,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.1ba2	18		clc				clc
.1ba3	75 6d		adc $6d,x			adc 	NSExponent+1,x
.1ba5	95 6c		sta $6c,x			sta 	NSExponent,x
.1ba7	80 03		bra $1bac			bra 	_FDExit
.1ba9					_FDSetZero:
.1ba9	20 a3 1e	jsr $1ea3			jsr 	FloatSetZero 				; return 0
.1bac					_FDExit:
.1bac	20 f8 1b	jsr $1bf8			jsr 	FloatNormalise 				; normalise the result
.1baf	60		rts				rts
.1bb0					FloatMultiplyShort:
.1bb0	5a		phy				phy 								; save Y
.1bb1	20 86 1e	jsr $1e86			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.1bb4	20 9f 1e	jsr $1e9f			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.1bb7	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.1bb9					_I32MLoop:
.1bb9	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.1bbb	15 4a		ora $4a,x			ora 	NSMantissa1+2,x
.1bbd	15 56		ora $56,x			ora 	NSMantissa2+2,x
.1bbf	15 62		ora $62,x			ora 	NSMantissa3+2,x
.1bc1	f0 25		beq $1be8			beq 	_I32MExit 					; exit if zero
.1bc3	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.1bc5	29 01		and #$01			and 	#1
.1bc7	f0 0d		beq $1bd6			beq 	_I32MNoAdd
.1bc9	20 2f 1c	jsr $1c2f			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.1bcc	b5 60		lda $60,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.1bce	10 06		bpl $1bd6			bpl 	_I32MNoAdd
.1bd0					_I32ShiftRight:
.1bd0	20 bc 1e	jsr $1ebc			jsr 	FloatShiftRight 			; shift S[X] right
.1bd3	c8		iny				iny 								; increment shift count
.1bd4	80 09		bra $1bdf			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.1bd6					_I32MNoAdd:
.1bd6	34 61		bit $61,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.1bd8	70 f6		bvs $1bd0			bvs 	_I32ShiftRight 				; instead.
.1bda	e8		inx				inx
.1bdb	20 b2 1e	jsr $1eb2			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.1bde	ca		dex				dex
.1bdf					_I32MShiftUpper:
.1bdf	e8		inx				inx 								; shift S[X+2] right
.1be0	e8		inx				inx
.1be1	20 bc 1e	jsr $1ebc			jsr 	FloatShiftRight
.1be4	ca		dex				dex
.1be5	ca		dex				dex
.1be6	80 d1		bra $1bb9			bra 	_I32MLoop 					; try again.
.1be8					_I32MExit:
.1be8	20 ee 1b	jsr $1bee			jsr 	FloatCalculateSign
.1beb	98		tya				tya 								; shift in A
.1bec	7a		ply				ply 								; restore Y and exit
.1bed	60		rts				rts
.1bee					FloatCalculateSign:
.1bee	b5 30		lda $30,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.1bf0	16 30		asl $30,x			asl 	NSStatus,x 					; shift result left
.1bf2	55 31		eor $31,x			eor 	NSStatus+1,x
.1bf4	0a		asl a				asl 	a 							; shift bit 7 into carry
.1bf5	76 30		ror $30,x			ror 	NSStatus,x 					; shift right into status byte.
.1bf7	60		rts				rts
.1bf8					FloatNormalise:
.1bf8	20 c5 1e	jsr $1ec5			jsr 	FloatIsZero 				; if zero exit
.1bfb	d0 07		bne $1c04			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.1bfd	16 30		asl $30,x			asl 	NSStatus,x 					; clear the sign bit.
.1bff	76 30		ror $30,x			ror 	NSStatus,x 					; (no -0)
.1c01	a9 00		lda #$00			lda 	#0 							; set Z flag
.1c03	60		rts				rts
.1c04					_NSNormaliseOptimise:
.1c04	b5 60		lda $60,x			lda 	NSMantissa3,x 				; upper byte zero ?
.1c06	d0 19		bne $1c21			bne 	_NSNormaliseLoop
.1c08	b5 54		lda $54,x			lda 	NSMantissa2,x 				; byte normalise
.1c0a	30 15		bmi $1c21			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.1c0c	95 60		sta $60,x			sta 	NSMantissa3,x
.1c0e	b5 48		lda $48,x			lda 	NSMantissa1,x
.1c10	95 54		sta $54,x			sta 	NSMantissa2,x
.1c12	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1c14	95 48		sta $48,x			sta 	NSMantissa1,x
.1c16	74 3c		stz $3c,x			stz 	NSMantissa0,x
.1c18	b5 6c		lda $6c,x			lda 	NSExponent,x
.1c1a	38		sec				sec
.1c1b	e9 08		sbc #$08			sbc 	#8
.1c1d	95 6c		sta $6c,x			sta 	NSExponent,x
.1c1f	80 e3		bra $1c04			bra 	_NSNormaliseOptimise
.1c21					_NSNormaliseLoop:
.1c21	34 60		bit $60,x			bit 	NSMantissa3,x 				; bit 30 set ?
.1c23	70 07		bvs $1c2c			bvs 	_NSNExit 					; exit if so with Z flag clear
.1c25	20 b2 1e	jsr $1eb2			jsr 	FloatShiftLeft 				; shift mantissa left
.1c28	d6 6c		dec $6c,x			dec 	NSExponent,x 				; adjust exponent
.1c2a	80 f5		bra $1c21			bra 	_NSNormaliseLoop
.1c2c					_NSNExit:
.1c2c	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.1c2e	60		rts				rts
.1c2f					FloatAddTopTwoStack:
.1c2f	18		clc				clc
.1c30	b5 3c		lda $3c,x			lda		NSMantissa0,x
.1c32	75 3d		adc $3d,x			adc 		NSMantissa0+1,x
.1c34	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1c36	b5 48		lda $48,x			lda		NSMantissa1,x
.1c38	75 49		adc $49,x			adc 		NSMantissa1+1,x
.1c3a	95 48		sta $48,x			sta 	NSMantissa1,x
.1c3c	b5 54		lda $54,x			lda		NSMantissa2,x
.1c3e	75 55		adc $55,x			adc 		NSMantissa2+1,x
.1c40	95 54		sta $54,x			sta 	NSMantissa2,x
.1c42	b5 60		lda $60,x			lda		NSMantissa3,x
.1c44	75 61		adc $61,x			adc 		NSMantissa3+1,x
.1c46	95 60		sta $60,x			sta 	NSMantissa3,x
.1c48	60		rts				rts
.1c49					FloatSubTopTwoStack:
.1c49	38		sec				sec
.1c4a	b5 3c		lda $3c,x			lda		NSMantissa0,x
.1c4c	f5 3d		sbc $3d,x			sbc 		NSMantissa0+1,x
.1c4e	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1c50	b5 48		lda $48,x			lda		NSMantissa1,x
.1c52	f5 49		sbc $49,x			sbc 		NSMantissa1+1,x
.1c54	95 48		sta $48,x			sta 	NSMantissa1,x
.1c56	b5 54		lda $54,x			lda		NSMantissa2,x
.1c58	f5 55		sbc $55,x			sbc 		NSMantissa2+1,x
.1c5a	95 54		sta $54,x			sta 	NSMantissa2,x
.1c5c	b5 60		lda $60,x			lda		NSMantissa3,x
.1c5e	f5 61		sbc $61,x			sbc 		NSMantissa3+1,x
.1c60	95 60		sta $60,x			sta 	NSMantissa3,x
.1c62	60		rts				rts
.1c63					FloatInt32Add:
.1c63	b5 30		lda $30,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.1c65	55 31		eor $31,x			eor 	NSStatus+1,x
.1c67	30 04		bmi $1c6d			bmi 	_DiffSigns
.1c69	20 2f 1c	jsr $1c2f			jsr		FloatAddTopTwoStack
.1c6c	60		rts				rts
.1c6d					_DiffSigns:
.1c6d	20 49 1c	jsr $1c49			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.1c70	34 60		bit $60,x			bit 	NSMantissa3,x 				; result is +ve, okay
.1c72	10 07		bpl $1c7b			bpl 	_AddExit
.1c74	b5 31		lda $31,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.1c76	95 30		sta $30,x			sta 	NSStatus,x
.1c78	20 6c 1e	jsr $1e6c			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.1c7b					_AddExit:
.1c7b	20 c5 1e	jsr $1ec5			jsr 	FloatIsZero 				; check for -0
.1c7e	d0 02		bne $1c82			bne 	_AddNonZero
.1c80	74 30		stz $30,x			stz 	NSStatus,x
.1c82					_AddNonZero:
.1c82	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.1c83					FloatEncodeStart:
.1c83	38		sec				sec
.1c84	80 01		bra $1c87			bra 	FloatEncodeContinue+1
.1c86					FloatEncodeContinue:
.1c86	18		clc				clc
.1c87					FloatEncode:
.1c87	08		php				php 								; save reset flag.
.1c88	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.1c8a	f0 15		beq $1ca1			beq 	_ENIsOkay
.1c8c	c9 30		cmp #$30			cmp 	#"0"
.1c8e	90 04		bcc $1c94			bcc 	_ENBadNumber
.1c90	c9 3a		cmp #$3a			cmp 	#"9"+1
.1c92	90 0d		bcc $1ca1			bcc 	_ENIsOkay
.1c94					_ENBadNumber:
.1c94	28		plp				plp 								; throw saved reset
.1c95	ad 39 05	lda $0539			lda 	encodeState 				; if in decimal mode, construct final number
.1c98	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.1c9a	d0 03		bne $1c9f			bne 	_ENFail
.1c9c	4c 19 1d	jmp $1d19			jmp 	_ENConstructFinal
.1c9f					_ENFail:
.1c9f	18		clc				clc 								; not allowed
.1ca0	60		rts				rts
.1ca1					_ENIsOkay:
.1ca1	28		plp				plp 								; are we restarting
.1ca2	90 15		bcc $1cb9			bcc 	_ENNoRestart
.1ca4					_ENStartEncode:
.1ca4	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.1ca6	f0 0c		beq $1cb4			beq 	_ENFirstDP
.1ca8	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.1caa	20 a5 1e	jsr $1ea5			jsr 	FloatSetByte 				; in single byte mode.
.1cad	a9 01		lda #$01			lda 	#ESTA_Low
.1caf					_ENExitChange:
.1caf	8d 39 05	sta $0539			sta 	encodeState 				; save new state
.1cb2	38		sec				sec
.1cb3	60		rts				rts
.1cb4					_ENFirstDP:
.1cb4	20 a3 1e	jsr $1ea3			jsr 	FloatSetZero 				; clear integer part
.1cb7	80 3c		bra $1cf5			bra 	_ESTASwitchFloat			; go straight to float and exi
.1cb9					_ENNoRestart:
.1cb9	48		pha				pha 								; save digit or DP on stack.
.1cba	ad 39 05	lda $0539			lda 	encodeState 				; get current state
.1cbd	c9 01		cmp #$01			cmp 	#ESTA_Low
.1cbf	f0 09		beq $1cca			beq  	_ESTALowState
.1cc1	c9 02		cmp #$02			cmp 	#ESTA_High
.1cc3	f0 26		beq $1ceb			beq 	_ESTAHighState
.1cc5	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.1cc7	f0 38		beq $1d01			beq 	_ESTADecimalState
>1cc9	db						.byte 	$DB 						; causes a break in the emulator
.1cca					_ESTALowState:
.1cca	68		pla				pla 								; get value back
.1ccb	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.1ccd	f0 26		beq $1cf5			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.1ccf	29 0f		and #$0f			and 	#15 						; make digit
.1cd1	8d 3a 05	sta $053a			sta 	digitTemp 					; save it.
.1cd4	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.1cd6	0a		asl a				asl 	a
.1cd7	0a		asl a				asl 	a
.1cd8	75 3c		adc $3c,x			adc 	NSMantissa0,x
.1cda	0a		asl a				asl 	a
.1cdb	6d 3a 05	adc $053a			adc 	digitTemp
.1cde	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1ce0	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.1ce2	90 05		bcc $1ce9			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.1ce4	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.1ce6	8d 39 05	sta $0539			sta 	encodeState
.1ce9					_ESTANoSwitch:
.1ce9	38		sec				sec
.1cea	60		rts				rts
.1ceb					_ESTAHighState:
.1ceb	68		pla				pla 								; get value back
.1cec	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.1cee	f0 05		beq $1cf5			beq 	_ESTASwitchFloat
.1cf0	20 4b 1d	jsr $1d4b			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.1cf3	38		sec				sec
.1cf4	60		rts				rts
.1cf5					_ESTASwitchFloat:
.1cf5	9c 3b 05	stz $053b			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.1cf8	e8		inx				inx 								; zero the decimal additive.
.1cf9	20 a3 1e	jsr $1ea3			jsr 	FloatSetZero
.1cfc	ca		dex				dex
.1cfd	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.1cff	80 ae		bra $1caf			bra 	_ENExitChange
.1d01					_ESTADecimalState:
.1d01	68		pla				pla 								; digit.
.1d02	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.1d04	f0 99		beq $1c9f			beq 	_ENFail
.1d06	e8		inx				inx 								; put digit into fractional part of X+1
.1d07	20 4b 1d	jsr $1d4b			jsr 	ESTAShiftDigitIntoMantissa
.1d0a	ca		dex				dex
.1d0b	ee 3b 05	inc $053b			inc 	decimalCount 				; bump the count of decimals
.1d0e	ad 3b 05	lda $053b			lda 	decimalCount 				; too many decimal digits.
.1d11	c9 0b		cmp #$0b			cmp 	#11
.1d13	f0 02		beq $1d17			beq 	_ESTADSFail
.1d15	38		sec				sec
.1d16	60		rts				rts
.1d17					_ESTADSFail:
.1d17	18		clc				clc
.1d18	60		rts				rts
.1d19					_ENConstructFinal:
.1d19	ad 3b 05	lda $053b			lda 	decimalCount 				; get decimal count
.1d1c	f0 2b		beq $1d49			beq 	_ENCFExit 					; no decimals
.1d1e	5a		phy				phy
.1d1f	0a		asl a				asl 	a 							; x 4 and CLC
.1d20	0a		asl a				asl 	a
.1d21	6d 3b 05	adc $053b			adc 	decimalCount
.1d24	a8		tay				tay
.1d25	b9 b0 19	lda $19b0,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.1d28	95 3e		sta $3e,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.1d2a	b9 b1 19	lda $19b1,y			lda 	FloatScalarTable-5+1,y
.1d2d	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.1d2f	b9 b2 19	lda $19b2,y			lda 	FloatScalarTable-5+2,y
.1d32	95 56		sta $56,x			sta 	NSMantissa2+2,x
.1d34	b9 b3 19	lda $19b3,y			lda 	FloatScalarTable-5+3,y
.1d37	95 62		sta $62,x			sta 	NSMantissa3+2,x
.1d39	b9 b4 19	lda $19b4,y			lda 	FloatScalarTable-5+4,y
.1d3c	95 6e		sta $6e,x			sta 	NSExponent+2,x
.1d3e	74 32		stz $32,x			stz 	NSStatus+2,x 				; make +ve
.1d40	e8		inx				inx 								; multiply decimal const by decimal scalar
.1d41	e8		inx				inx
.1d42	20 63 1b	jsr $1b63			jsr 	FloatMultiply
.1d45	20 c7 18	jsr $18c7			jsr 	FloatAdd 					; add to integer part.
.1d48	7a		ply				ply
.1d49					_ENCFExit:
.1d49	18		clc				clc 								; reject the digit.
.1d4a	60		rts				rts
.1d4b					ESTAShiftDigitIntoMantissa:
.1d4b	29 0f		and #$0f			and 	#15 						; save digit
.1d4d	48		pha				pha
.1d4e	b5 60		lda $60,x			lda 	NSMantissa3,x 				; push mantissa on stack
.1d50	48		pha				pha
.1d51	b5 54		lda $54,x			lda 	NSMantissa2,x
.1d53	48		pha				pha
.1d54	b5 48		lda $48,x			lda 	NSMantissa1,x
.1d56	48		pha				pha
.1d57	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1d59	48		pha				pha
.1d5a	20 b2 1e	jsr $1eb2			jsr 	FloatShiftLeft 				; x 2
.1d5d	20 b2 1e	jsr $1eb2			jsr 	FloatShiftLeft 				; x 4
.1d60	18		clc				clc 								; pop mantissa and add
.1d61	68		pla				pla
.1d62	75 3c		adc $3c,x			adc 	NSMantissa0,x
.1d64	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1d66	68		pla				pla
.1d67	75 48		adc $48,x			adc 	NSMantissa1,x
.1d69	95 48		sta $48,x			sta 	NSMantissa1,x
.1d6b	68		pla				pla
.1d6c	75 54		adc $54,x			adc 	NSMantissa2,x
.1d6e	95 54		sta $54,x			sta 	NSMantissa2,x
.1d70	68		pla				pla
.1d71	75 60		adc $60,x			adc 	NSMantissa3,x
.1d73	95 60		sta $60,x			sta 	NSMantissa3,x 				; x 5
.1d75	20 b2 1e	jsr $1eb2			jsr 	FloatShiftLeft 				; x 10
.1d78	68		pla				pla 								; add digit
.1d79	18		clc				clc
.1d7a	75 3c		adc $3c,x			adc 	NSMantissa0,x
.1d7c	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1d7e	90 0a		bcc $1d8a			bcc 	_ESTASDExit
.1d80	f6 48		inc $48,x			inc 	NSMantissa1,x
.1d82	d0 06		bne $1d8a			bne 	_ESTASDExit
.1d84	f6 54		inc $54,x			inc 	NSMantissa2,x
.1d86	d0 02		bne $1d8a			bne 	_ESTASDExit
.1d88	f6 60		inc $60,x			inc 	NSMantissa3,x
.1d8a					_ESTASDExit:
.1d8a	60		rts				rts
.0539					encodeState:
>0539							.fill 	1
.053a					digitTemp:
>053a							.fill 	1
.053b					decimalCount:
>053b							.fill 	1
.1d8b					FloatToString:
.1d8b	da		phx				phx
.1d8c	5a		phy				phy 								; save code position
.1d8d	8d 3c 05	sta $053c			sta 	decimalPlaces	 			; save number of DPs.
.1d90	9c 3d 05	stz $053d			stz 	dbOffset 					; offset into decimal buffer = start.
.1d93	b5 30		lda $30,x			lda 	NSStatus,x  				; is it -ve.
.1d95	10 08		bpl $1d9f			bpl 	_CNTSNotNegative
.1d97	29 7f		and #$7f			and 	#$7F 						; make +ve
.1d99	95 30		sta $30,x			sta 	NSStatus,x
.1d9b	a9 2d		lda #$2d			lda 	#"-"
.1d9d	80 02		bra $1da1			bra 	_CNTMain
.1d9f					_CNTSNotNegative:
.1d9f	a9 20		lda #$20			lda 	#" "
.1da1					_CNTMain:
.1da1	20 03 1e	jsr $1e03			jsr 	WriteDecimalBuffer
.1da4	b5 6c		lda $6c,x			lda 	NSExponent,x 				; check if decimal
.1da6	f0 0d		beq $1db5			beq 	_CNTSNotFloat
.1da8	e8		inx				inx 								; round up so we don't get too many 6.999999
.1da9	a9 01		lda #$01			lda 	#1
.1dab	20 a5 1e	jsr $1ea5			jsr 	FloatSetByte
.1dae	b5 6b		lda $6b,x			lda		NSExponent-1,x
.1db0	95 6c		sta $6c,x			sta 	NSExponent,x
.1db2	20 c7 18	jsr $18c7			jsr 	FloatAdd
.1db5					_CNTSNotFloat:
.1db5	20 e5 1d	jsr $1de5			jsr 	MakePlusTwoString 			; do the integer part.
.1db8	20 83 1a	jsr $1a83			jsr 	FloatFractionalPart 		; get the fractional part
.1dbb	20 f8 1b	jsr $1bf8			jsr 	FloatNormalise					; normalise , exit if zero
.1dbe	f0 22		beq $1de2			beq 	_CNTSExit
.1dc0	a9 2e		lda #$2e			lda 	#"."
.1dc2	20 03 1e	jsr $1e03			jsr 	WriteDecimalBuffer 			; write decimal place
.1dc5					_CNTSDecimal:
.1dc5	ce 3c 05	dec $053c			dec 	decimalPlaces 				; done all the decimals
.1dc8	30 18		bmi $1de2			bmi 	_CNTSExit
.1dca	e8		inx				inx 								; x 10.0
.1dcb	a9 0a		lda #$0a			lda 	#10
.1dcd	20 a5 1e	jsr $1ea5			jsr 	FloatSetByte
.1dd0	20 63 1b	jsr $1b63			jsr 	FloatMultiply
.1dd3	20 e5 1d	jsr $1de5			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.1dd6	20 83 1a	jsr $1a83			jsr 	FloatFractionalPart 		; get the fractional part
.1dd9	20 f8 1b	jsr $1bf8			jsr 	FloatNormalise 				; normalise it.
.1ddc	b5 6c		lda $6c,x			lda 	NSExponent,x 				; gone to zero, exit.
.1dde	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.1de0	b0 e3		bcs $1dc5			bcs 	_CNTSDecimal 				; keep going.
.1de2					_CNTSExit:
.1de2	7a		ply				ply
.1de3	fa		plx				plx
.1de4	60		rts				rts
.1de5					MakePlusTwoString:
.1de5	da		phx				phx
.1de6	20 86 1e	jsr $1e86			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.1de9	e8		inx				inx 								; access it
.1dea	e8		inx				inx
.1deb	20 de 1a	jsr $1ade			jsr 	FloatIntegerPart 			; make it an integer
.1dee	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.1df0	20 22 1e	jsr $1e22			jsr 	ConvertInt32
.1df3	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.1df5					_MPTSCopy:
.1df5	bd 17 05	lda $0517,x			lda 	numberBuffer,x
.1df8	20 03 1e	jsr $1e03			jsr 	WriteDecimalBuffer
.1dfb	e8		inx				inx
.1dfc	bd 17 05	lda $0517,x			lda 	numberBuffer,x
.1dff	d0 f4		bne $1df5			bne 	_MPTSCopy
.1e01	fa		plx				plx
.1e02	60		rts				rts
.1e03					WriteDecimalBuffer:
.1e03	da		phx				phx
.1e04	ae 3d 05	ldx $053d			ldx 	dbOffset
.1e07	9d 3e 05	sta $053e,x			sta 	decimalBuffer,x
.1e0a	9e 3f 05	stz $053f,x			stz 	decimalBuffer+1,x
.1e0d	ee 3d 05	inc $053d			inc 	dbOffset
.1e10	fa		plx				plx
.1e11	60		rts				rts
.053c					decimalPlaces:
>053c							.fill 	1
.053d					dbOffset:
>053d							.fill 	1
.053e					decimalBuffer:
>053e							.fill 	32
.1e12					ConvertInt16:
.1e12	85 3c		sta $3c				sta 	NSMantissa0 				; set up as 32 bit conversion
.1e14	86 48		stx $48				stx 	NSMantissa1
.1e16	64 54		stz $54				stz 	NSMantissa2
.1e18	64 60		stz $60				stz 	NSMantissa3
.1e1a	64 30		stz $30				stz 	NSStatus 					; positive integer
.1e1c	a2 00		ldx #$00			ldx 	#0 							; stack level
.1e1e	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.1e20	80 00		bra $1e22			bra 	ConvertInt32
.1e22					ConvertInt32:
.1e22	5a		phy				phy
.1e23	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.1e25	24 30		bit $30				bit 	NSStatus 					; output a - if not negative.
.1e27	10 08		bpl $1e31			bpl 	_CI32NotNeg
.1e29	48		pha				pha
.1e2a	a9 2d		lda #$2d			lda 	#'-'
.1e2c	99 17 05	sta $0517,y			sta 	numberBuffer,y
.1e2f	c8		iny				iny
.1e30	68		pla				pla
.1e31					_CI32NotNeg:
.1e31	20 3f 1e	jsr $1e3f			jsr 	_CI32DivideConvert 			; recursive conversion
.1e34	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.1e36	99 17 05	sta $0517,y			sta 	numberBuffer,y
.1e39	7a		ply				ply
.1e3a	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.1e3c	a9 17		lda #$17			lda 	#numberBuffer & $FF
.1e3e	60		rts				rts
.1e3f					_CI32DivideConvert:
.1e3f	e8		inx				inx 								; write to next slot up
.1e40	20 a5 1e	jsr $1ea5			jsr 	FloatSetByte 		 		; write the base out.
.1e43	ca		dex				dex
.1e44	20 39 1a	jsr $1a39			jsr 	Int32Divide 				; divide
.1e47	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; save remainder
.1e49	48		pha				pha
.1e4a	20 28 1a	jsr $1a28			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.1e4d	20 c5 1e	jsr $1ec5			jsr 	FloatIsZero 				; is it zero ?
.1e50	f0 05		beq $1e57			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.1e52	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.1e54	20 3f 1e	jsr $1e3f			jsr 	_CI32DivideConvert 			; and recusrively call.
.1e57					_CI32NoRecurse:
.1e57	68		pla				pla 								; remainder
.1e58	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.1e5a	90 02		bcc $1e5e			bcc 	_CI32NotHex
.1e5c	69 26		adc #$26			adc 	#6+32
.1e5e					_CI32NotHex:
.1e5e	69 30		adc #$30			adc 	#48
.1e60	99 17 05	sta $0517,y			sta 	numberBuffer,y 				; write out and exit
.1e63	c8		iny				iny
.1e64	60		rts				rts
.1e65					FloatNegate:
.1e65	b5 30		lda $30,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.1e67	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.1e69	95 30		sta $30,x			sta 	NSStatus,x
.1e6b	60		rts				rts
.1e6c					FloatNegateMantissa:
.1e6c	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.1e6d	a9 00		lda #$00			lda 	#0
.1e6f	f5 3c		sbc $3c,x			sbc 	NSMantissa0,x
.1e71	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1e73	a9 00		lda #$00			lda 	#0
.1e75	f5 48		sbc $48,x			sbc 	NSMantissa1,x
.1e77	95 48		sta $48,x			sta 	NSMantissa1,x
.1e79	a9 00		lda #$00			lda 	#0
.1e7b	f5 54		sbc $54,x			sbc 	NSMantissa2,x
.1e7d	95 54		sta $54,x			sta 	NSMantissa2,x
.1e7f	a9 00		lda #$00			lda 	#0
.1e81	f5 60		sbc $60,x			sbc 	NSMantissa3,x
.1e83	95 60		sta $60,x			sta 	NSMantissa3,x
.1e85	60		rts				rts
.1e86					FloatShiftUpTwo:
.1e86	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1e88	95 3e		sta $3e,x			sta 	NSMantissa0+2,x
.1e8a	b5 48		lda $48,x			lda 	NSMantissa1,x
.1e8c	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.1e8e	b5 54		lda $54,x			lda 	NSMantissa2,x
.1e90	95 56		sta $56,x			sta 	NSMantissa2+2,x
.1e92	b5 60		lda $60,x			lda 	NSMantissa3,x
.1e94	95 62		sta $62,x			sta 	NSMantissa3+2,x
.1e96	b5 6c		lda $6c,x			lda 	NSExponent,x
.1e98	95 6e		sta $6e,x			sta 	NSExponent+2,x
.1e9a	b5 30		lda $30,x			lda 	NSStatus,x
.1e9c	95 32		sta $32,x			sta 	NSStatus+2,x
.1e9e	60		rts				rts
.1e9f					FloatSetZeroMantissaOnly:
.1e9f	74 3c		stz $3c,x			stz 	NSMantissa0,x
.1ea1	80 08		bra $1eab			bra 	FloatZero13
.1ea3					FloatSetZero:
.1ea3	a9 00		lda #$00			lda 	#0
.1ea5					FloatSetByte:
.1ea5	74 6c		stz $6c,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.1ea7					FloatSetMantissa:
.1ea7	95 3c		sta $3c,x			sta 	NSMantissa0,x 				; zero mantissa
.1ea9	74 30		stz $30,x			stz 	NSStatus,x
.1eab					FloatZero13:
.1eab	74 48		stz $48,x			stz 	NSMantissa1,x
.1ead	74 54		stz $54,x			stz 	NSMantissa2,x
.1eaf	74 60		stz $60,x			stz 	NSMantissa3,x
.1eb1	60		rts				rts
.1eb2					FloatShiftLeft:
.1eb2	18		clc				clc
.1eb3					FloatRotateLeft:
.1eb3	36 3c		rol $3c,x			rol 	NSMantissa0,x
.1eb5	36 48		rol $48,x			rol		NSMantissa1,x
.1eb7	36 54		rol $54,x			rol		NSMantissa2,x
.1eb9	36 60		rol $60,x			rol		NSMantissa3,x
.1ebb	60		rts				rts
.1ebc					FloatShiftRight:
.1ebc	56 60		lsr $60,x			lsr 	NSMantissa3,x
.1ebe	76 54		ror $54,x			ror		NSMantissa2,x
.1ec0	76 48		ror $48,x			ror		NSMantissa1,x
.1ec2	76 3c		ror $3c,x			ror		NSMantissa0,x
.1ec4	60		rts				rts
.1ec5					FloatIsZero:
.1ec5	b5 60		lda $60,x			lda 	NSMantissa3,x
.1ec7	15 54		ora $54,x			ora		NSMantissa2,x
.1ec9	15 48		ora $48,x			ora		NSMantissa1,x
.1ecb	15 3c		ora $3c,x			ora		NSMantissa0,x
.1ecd	60		rts				rts

;******  Processing input file: testing/testend.asm

.1ece					EndProgram:
>1ece	01 08 18 08 64 00 99 20				.binary "code/tokenised.dat"
>1ed6	22 48 45 4c 4c 4f 2c 20 57 4f 52 4c 44 20 21 22
>1ee6	00 1e 08 6e 00 90 00 00 00

;******  End of listing
