
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Sun Oct  8 17:13:45 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.1000					WrapperBoot:
.1000	a2 0a		ldx #$0a			ldx 	#APIDesc & $FF
.1002	a0 10		ldy #$10			ldy 	#APIDesc >> 8
.1004	20 74 11	jsr $1174			jsr 	StartCompiler
.1007	4c ff ff	jmp $ffff			jmp 	$FFFF
.100a					APIDesc:
>100a	0e 10						.word 	TestAPI 					; the testing API.
>100c	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>100d	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing file: testing/api/api.asm

=$a000					PCodeMemory = $A000
.100e					TestAPI:
.100e	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.1010	f0 19		beq $102b			beq 	_TAOpenIn
.1012	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.1014	f0 1d		beq $1033			beq 	_TACloseIn
.1016	c9 02		cmp #$02			cmp 	#BLC_READIN
.1018	f0 1a		beq $1034			beq 	_TARead
.101a	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.101c	f0 19		beq $1037			beq 	_TAResetOut
.101e	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.1020	f0 22		beq $1044			beq 	_TACloseOut
.1022	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.1024	f0 28		beq $104e			beq 	_TAWriteByte
.1026	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.1028	f0 2e		beq $1058			beq 	_TAPrintScreen
>102a	db						.byte 	$DB 						; causes a break in the emulator
.102b					_TAOpenIn:
.102b	a9 cf		lda #$cf			lda 	#((EndProgram+2) & $FF)
.102d	85 22		sta $22				sta 	0+srcInputPtr
.102f	a9 26		lda #$26			lda 	#((EndProgram+2) >> 8) & $FF
.1031	85 23		sta $23				sta 	1+srcInputPtr
.1033					_TACloseIn:
.1033	60		rts				rts
.1034					_TARead:
.1034	4c 5c 10	jmp $105c			jmp 	ReadNextLine
.1037					_TAResetOut:
.1037	a9 01		lda #$01			lda 	#1
.1039	85 00		sta $00				sta 	0
.103b	a9 00		lda #$00			lda 	#((PCodeMemory) & $FF)
.103d	85 28		sta $28				sta 	0+objPtr
.103f	a9 a0		lda #$a0			lda 	#((PCodeMemory) >> 8) & $FF
.1041	85 29		sta $29				sta 	1+objPtr
.1043	60		rts				rts
.1044					_TACloseOut:
.1044	a9 a0		lda #$a0			lda 	#PCodeMemory >> 8
.1046	a6 28		ldx $28				ldx 	objPtr
.1048	a4 29		ldy $29				ldy 	objPtr+1
.104a	20 81 10	jsr $1081			jsr 	APISaveMemory
.104d	60		rts				rts
.104e					_TAWriteByte:
.104e	8a		txa				txa
.104f	92 28		sta ($28)			sta 	(objPtr)
.1051	e6 28		inc $28				inc 	objPtr
.1053	d0 02		bne $1057			bne 	_HWOWBNoCarry
.1055	e6 29		inc $29				inc 	objPtr+1
.1057					_HWOWBNoCarry:
.1057	60		rts				rts
.1058					_TAPrintScreen:
.1058	8a		txa				txa
.1059	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.0022					srcInputPtr:
>0022							.fill 	2

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/line.asm

.105c					ReadNextLine:
.105c	b2 22		lda ($22)			lda 	(srcInputPtr) 				; reached the end of the program (address link = $0000)
.105e	a0 01		ldy #$01			ldy 	#1
.1060	11 22		ora ($22),y			ora 	(srcInputPtr),y
.1062	d0 02		bne $1066			bne 	_RLAHaveData
.1064	18		clc				clc
.1065	60		rts				rts									; end of file.
.1066					_RLAHaveData:
.1066	a6 22		ldx $22				ldx 	srcInputPtr 				; remember the line start
.1068	a4 23		ldy $23				ldy 	srcInputPtr+1
.106a	5a		phy				phy
.106b	a0 04		ldy #$04			ldy 	#4 							; must be at least four bytes (address/line#)
.106d					_RNLRead:
.106d	b1 22		lda ($22),y			lda 	(srcInputPtr),y 			; find the end of the line.
.106f	c8		iny				iny
.1070	c9 00		cmp #$00			cmp 	#0
.1072	d0 f9		bne $106d			bne 	_RNLRead
.1074	98		tya				tya 								; advance src input pointer to next.
.1075	18		clc				clc
.1076	65 22		adc $22				adc 	srcInputPtr
.1078	85 22		sta $22				sta 	srcInputPtr
.107a	90 02		bcc $107e			bcc 	_RNLNoCarry
.107c	e6 23		inc $23				inc 	srcInputPtr+1
.107e					_RNLNoCarry:
.107e	7a		ply				ply 								; address of line now in YX.
.107f	38		sec				sec
.1080	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/save.asm

.1081					APISaveMemory:
.1081	da		phx				phx
.1082	5a		phy				phy
.1083	48		pha				pha
.1084	a9 00		lda #$00			lda 	#0 							; set LFS
.1086	a2 08		ldx #$08			ldx 	#8
.1088	a0 00		ldy #$00			ldy 	#0
.108a	20 ba ff	jsr $ffba			jsr 	$FFBA
.108d	a9 08		lda #$08			lda 	#8 							; set file name
.108f	a2 a3		ldx #$a3			ldx 	#SaveName & $FF
.1091	a0 10		ldy #$10			ldy 	#SaveName >> 8
.1093	20 bd ff	jsr $ffbd			jsr 	$FFBD
.1096	68		pla				pla 								; set up the start address.
.1097	85 2b		sta $2b				sta 	zTemp0+1
.1099	64 2a		stz $2a				stz 	zTemp0
.109b	a9 2a		lda #$2a			lda 	#zTemp0 					; from index.
.109d	7a		ply				ply 								; end in YX
.109e	fa		plx				plx
.109f	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.10a2	60		rts				rts
.10a3					SaveName:
>10a3	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Return to file: testing/testing.asm


;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.0024					srcPtr:
>0024							.fill 	2
.0400					currentLineNumber:
>0400							.fill 	2
.10ab					InlineNonDecimal:
.10ab	a2 02		ldx #$02			ldx 	#2 							; get size in X
.10ad	c9 25		cmp #$25			cmp 	#"%"
.10af	f0 02		beq $10b3			beq 	_INDBinary
.10b1	a2 10		ldx #$10			ldx 	#16
.10b3					_INDBinary:
.10b3	85 2c		sta $2c				sta 	zTemp1 						; size => zTemp1
.10b5	64 2d		stz $2d				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.10b7	64 2a		stz $2a				stz 	zTemp0 						; zero result
.10b9	64 2b		stz $2b				stz 	zTemp0+1
.10bb					_INDLoop:
.10bb	20 57 1a	jsr $1a57			jsr 	LookNext 					; check next character
.10be	20 93 1a	jsr $1a93			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.10c1	90 1f		bcc $10e2			bcc		_INDDone 					; didn't convert
.10c3	c5 2c		cmp $2c				cmp 	zTemp1 						; size too large ?
.10c5	b0 1b		bcs $10e2			bcs 	_INDDone
.10c7	20 f1 10	jsr $10f1			jsr 	_INDShift 					; x 2 or x 16
.10ca	e0 02		cpx #$02			cpx 	#2
.10cc	f0 09		beq $10d7			beq 	_INDNotHex
.10ce	20 f1 10	jsr $10f1			jsr 	_INDShift
.10d1	20 f1 10	jsr $10f1			jsr 	_INDShift
.10d4	20 f1 10	jsr $10f1			jsr 	_INDShift
.10d7					_INDNotHex:
.10d7	05 2a		ora $2a				ora 	zTemp0 						; or digit into result
.10d9	85 2a		sta $2a				sta 	zTemp0
.10db	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume
.10de	e6 2d		inc $2d				inc 	zTemp1+1 					; bump count
.10e0	80 d9		bra $10bb			bra 	_INDLoop
.10e2					_INDDone:
.10e2	a5 2d		lda $2d				lda 	zTemp1+1 					; done at least 1 ?
.10e4	f0 08		beq $10ee			beq 	_INDError
.10e6	a4 2b		ldy $2b				ldy 	zTemp0+1 					; push constant
.10e8	a5 2a		lda $2a				lda 	zTemp0
.10ea	20 12 12	jsr $1212			jsr 	PushIntegerYA
.10ed	60		rts				rts
.10ee					_INDError:
.10ee	4c 5c 1f	jmp $1f5c		jmp	ErrorV_syntax
.10f1					_INDShift:
.10f1	06 2a		asl $2a				asl 	zTemp0
.10f3	26 2b		rol $2b				rol 	zTemp0+1
.10f5	60		rts				rts
.10f6					GetLineNumber:
.10f6	ac 01 04	ldy $0401			ldy 	currentLineNumber+1
.10f9	ad 00 04	lda $0400			lda 	currentLineNumber
.10fc	60		rts				rts
.10fd					WriteCodeByte:
.10fd	48		pha				pha 								; save on stack
.10fe	da		phx				phx
.10ff	5a		phy				phy
.1100	aa		tax				tax
.1101	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.1103	20 0f 12	jsr $120f			jsr 	CallAPIHandler
.1106	7a		ply				ply 								; restore from stack
.1107	fa		plx				plx
.1108	68		pla				pla
.1109	60		rts				rts
.110a					PrintCharacter
.110a	48		pha				pha
.110b	da		phx				phx
.110c	5a		phy				phy
.110d	aa		tax				tax
.110e	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.1110	20 0f 12	jsr $120f			jsr 	CallAPIHandler
.1113	7a		ply				ply
.1114	fa		plx				plx
.1115	68		pla				pla
.1116	60		rts				rts
.1117					ProcessNewLine:
.1117	86 2a		stx $2a				stx 	zTemp0 						; save address in zTemp0
.1119	84 2b		sty $2b				sty 	zTemp0+1
.111b	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.111c	8a		txa				txa
.111d	69 04		adc #$04			adc 	#4
.111f	85 24		sta $24				sta 	srcPtr
.1121	98		tya				tya
.1122	69 00		adc #$00			adc 	#0
.1124	85 25		sta $25				sta 	srcPtr+1
.1126	a0 02		ldy #$02			ldy 	#2							; read and save line number
.1128	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.112a	8d 00 04	sta $0400			sta 	currentLineNumber
.112d	c8		iny				iny
.112e	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1130	8d 01 04	sta $0401			sta 	currentLineNumber+1
.1133	60		rts				rts
.1134					BufferClear:
.1134	9c 02 04	stz $0402			stz 	bufferSize
.1137	60		rts				rts
.1138					BufferWrite:
.1138	da		phx				phx
.1139	ae 02 04	ldx $0402			ldx 	bufferSize
.113c	9d 03 04	sta $0403,x			sta 	dataBuffer,x
.113f	ee 02 04	inc $0402			inc 	bufferSize
.1142	fa		plx				plx
.1143	60		rts				rts
.1144					BufferOutput:
.1144	ad 02 04	lda $0402			lda 	bufferSize
.1147	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.114a	a2 00		ldx #$00			ldx 	#0
.114c					_BOLoop:
.114c	ec 02 04	cpx $0402			cpx 	bufferSize
.114f	f0 09		beq $115a			beq 	_BOExit
.1151	bd 03 04	lda $0403,x			lda 	dataBuffer,x
.1154	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1157	e8		inx				inx
.1158	80 f2		bra $114c			bra 	_BOLoop
.115a					_BOExit:
.115a	60		rts				rts
.0402					bufferSize:
>0402							.fill 	1
.0403					dataBuffer:
>0403							.fill 	256
.115b					CheckNextComma:
.115b	a9 2c		lda #$2c			lda	 	#","
.115d	80 06		bra $1165			bra 	CheckNextA
.115f					CheckNextRParen:
.115f	a9 29		lda #$29			lda	 	#")"
.1161	80 02		bra $1165			bra 	CheckNextA
.1163					CheckNextLParen:
.1163	a9 28		lda #$28			lda 	#"("
.1165					CheckNextA:
.1165	8d 03 05	sta $0503			sta 	checkCharacter 				; save test character
.1168					_CNALoop:
.1168	20 73 1a	jsr $1a73			jsr 	GetNextNonSpace 			; get next skipping spaces.
.116b	cd 03 05	cmp $0503			cmp 	checkCharacter 				; matches ?
.116e	f0 03		beq $1173			beq 	_CNAExit
.1170	4c 5c 1f	jmp $1f5c		jmp	ErrorV_syntax
.1173					_CNAExit:
.1173	60		rts				rts
.0503					checkCharacter:
>0503							.fill 	1
.1174					StartCompiler:
.1174	86 2a		stx $2a				stx 	zTemp0 						; access API
.1176	84 2b		sty $2b				sty 	zTemp0+1
.1178	a0 13		ldy #$13			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.117a	a2 cb		ldx #$cb			ldx 	#CompilerErrorHandler & $FF
.117c	20 35 1f	jsr $1f35			jsr 	SetErrorHandler
.117f	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.1181	b2 2a		lda ($2a)			lda 	(zTemp0)
.1183	8d 05 05	sta $0505			sta 	APIVector
.1186	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1188	8d 06 05	sta $0506			sta 	APIVector+1
.118b	c8		iny				iny 								; copy data area range.
.118c	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.118e	8d 07 05	sta $0507			sta 	compilerStartHigh
.1191	c8		iny				iny
.1192	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1194	8d 08 05	sta $0508			sta 	compilerEndHigh
.1197	ba		tsx				tsx 								; save stack pointer
.1198	8e 04 05	stx $0504			stx 	compilerSP
.119b	20 f7 1d	jsr $1df7			jsr 	STRReset 					; reset storage (line#, variable)
.119e	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.11a0	20 0f 12	jsr $120f			jsr 	CallAPIHandler
.11a3	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.11a5	20 0f 12	jsr $120f			jsr 	CallAPIHandler
.11a8	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.11aa	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.11ad	a9 00		lda #$00			lda 	#0
.11af	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.11b2	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.11b5					MainCompileLoop:
.11b5	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.11b7	20 0f 12	jsr $120f			jsr 	CallAPIHandler
.11ba	90 31		bcc $11ed			bcc 	SaveCodeAndExit 			; end of source.
.11bc	20 17 11	jsr $1117			jsr 	ProcessNewLine 				; set up pointer and line number.
.11bf	20 f6 10	jsr $10f6			jsr 	GetLineNumber 				; get line #
.11c2	20 e1 1b	jsr $1be1			jsr 	STRMarkLine 				; remember the code position and number of this line.
.11c5	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.11c7	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.11ca					_MCLSameLine:
.11ca	20 73 1a	jsr $1a73			jsr 	GetNextNonSpace 			; get the first character.
.11cd	f0 e6		beq $11b5			beq 	MainCompileLoop 			; end of line, get next line.
.11cf	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.11d1	f0 f7		beq $11ca			beq 	_MCLSameLine
.11d3	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.11d5	10 0c		bpl $11e3			bpl 	_MCLCheckAssignment
.11d7	a2 31		ldx #$31			ldx 	#CommandTables & $FF 		; do command tables.
.11d9	a0 16		ldy #$16			ldy 	#CommandTables >> 8
.11db	20 f9 18	jsr $18f9			jsr 	GeneratorProcess
.11de	b0 ea		bcs $11ca			bcs 	_MCLSameLine 				; keep trying to compile the line.
.11e0					_MCLSyntax:
.11e0	4c 5c 1f	jmp $1f5c		jmp	ErrorV_syntax
.11e3					_MCLCheckAssignment:
.11e3	20 89 1a	jsr $1a89			jsr 	CharIsAlpha 				; if not alpha then syntax error
.11e6	90 f8		bcc $11e0			bcc 	_MCLSyntax
.11e8	20 af 1b	jsr $1baf			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.11eb	80 dd		bra $11ca			bra		_MCLSameLine 				; loop back.
.11ed					SaveCodeAndExit:
.11ed	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.11ef	20 0f 12	jsr $120f			jsr 	CallAPIHandler
.11f2	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.11f4	a8		tay				tay
.11f5	20 e1 1b	jsr $1be1			jsr 	STRMarkLine
.11f8	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.11fa	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.11fd	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.11ff	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1202	20 29 15	jsr $1529			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.1205	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.1207	20 0f 12	jsr $120f			jsr 	CallAPIHandler
.120a					ExitCompiler:
.120a	ae 04 05	ldx $0504			ldx 	compilerSP 					; reload SP and exit.
.120d	9a		txs				txs
.120e	60		rts				rts
.120f					CallAPIHandler:
.120f	6c 05 05	jmp ($0505)			jmp 	(APIVector)
.0504					compilerSP:
>0504							.fill 	1
.0505					APIVector:
>0505							.fill 	2
.0507					compilerStartHigh:
>0507							.fill 	1
.0508					compilerEndHigh:
>0508							.fill 	1
.1212					PushIntegerYA:
.1212	c0 00		cpy #$00			cpy 	#0 							; 0-255
.1214	f0 0f		beq $1225			beq 	PushIntegerA
.1216	48		pha				pha
.1217	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.1219	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.121c	68		pla				pla 								; then LSB
.121d	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1220	98		tya				tya 								; then MSB
.1221	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1224	60		rts				rts
.1225					PushIntegerA:
.1225	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.1227	90 07		bcc $1230			bcc 	_PIWriteA
.1229	48		pha				pha
.122a	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.122c	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.122f	68		pla				pla
.1230					_PIWriteA:
.1230	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1233	60		rts				rts
.1234					PushFloatCommand:
.1234	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.1236	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1239	b5 6c		lda $6c,x			lda 	NSExponent,x 				; and the data
.123b	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.123e	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1240	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1243	b5 48		lda $48,x			lda 	NSMantissa1,x
.1245	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1248	b5 54		lda $54,x			lda 	NSMantissa2,x
.124a	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.124d	b5 30		lda $30,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.124f	29 80		and #$80			and 	#$80
.1251	15 60		ora $60,x			ora 	NSMantissa3,x
.1253	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1256	60		rts				rts
.1257					CreateVariableRecord:
.1257	48		pha				pha
.1258	ad 13 05	lda $0513			lda 	freeVariableMemory 		; push current free address on stack.
.125b	48		pha				pha
.125c	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.125f	48		pha				pha
.1260	ad 11 05	lda $0511			lda 	variableListEnd  		; copy end of list to zTemp0
.1263	85 2a		sta $2a				sta 	zTemp0
.1265	ad 12 05	lda $0512			lda 	variableListEnd+1
.1268	85 2b		sta $2b				sta 	zTemp0+1
.126a	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.126c	92 2a		sta ($2a)			sta 	(zTemp0)
.126e	98		tya				tya
.126f	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.1271	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1273	88		dey				dey
.1274	8a		txa				txa
.1275	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1277	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.1279	ad 13 05	lda $0513			lda 	freeVariableMemory
.127c	91 2a		sta ($2a),y			sta 	(zTemp0),y
.127e	c8		iny				iny
.127f	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1282	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1284	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.1286	a9 00		lda #$00			lda 	#0
.1288	91 2a		sta ($2a),y			sta 	(zTemp0),y
.128a	18		clc				clc
.128b	b2 2a		lda ($2a)			lda 	(zTemp0) 				; add offset to variableListEnd
.128d	6d 11 05	adc $0511			adc  	variableListEnd
.1290	8d 11 05	sta $0511			sta 	variableListEnd
.1293	90 03		bcc $1298			bcc 	_CVNoCarry2
.1295	ee 12 05	inc $0512			inc 	variableListEnd+1
.1298					_CVNoCarry2:
.1298	7a		ply				ply
.1299	fa		plx				plx
.129a	68		pla				pla
.129b	60		rts				rts
.129c					SetVariableRecordToCodePosition:
.129c	48		pha				pha
.129d	5a		phy				phy
.129e	a0 03		ldy #$03			ldy 	#3
.12a0	a5 29		lda $29				lda 	objPtr+1
.12a2	91 2a		sta ($2a),y			sta 	(zTemp0),y
.12a4	c8		iny				iny
.12a5	a5 28		lda $28				lda 	objPtr
.12a7	91 2a		sta ($2a),y			sta 	(zTemp0),y
.12a9	7a		ply				ply
.12aa	68		pla				pla
.12ab	60		rts				rts
.12ac					AllocateBytesForType:
.12ac	48		pha				pha
.12ad	da		phx				phx
.12ae	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.12b0	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.12b2	c9 00		cmp #$00			cmp 	#NSSIFloat
.12b4	d0 02		bne $12b8			bne 	_CVNotFloat
.12b6	a2 06		ldx #$06			ldx 	#6
.12b8					_CVNotFloat:
.12b8	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.12b9	18		clc				clc
.12ba	6d 13 05	adc $0513			adc 	freeVariableMemory
.12bd	8d 13 05	sta $0513			sta 	freeVariableMemory
.12c0	90 03		bcc $12c5			bcc 	_CVNoCarry1
.12c2	ee 14 05	inc $0514			inc 	freeVariableMemory+1
.12c5					_CVNoCarry1:
.12c5	fa		plx				plx
.12c6	68		pla				pla
.12c7	60		rts				rts
.12c8					CommandDATA:
.12c8	20 34 11	jsr $1134			jsr 	BufferClear 				; copy it to the buffer
.12cb	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace
.12ce					_CTDataLoop:
.12ce	20 57 1a	jsr $1a57			jsr 	LookNext 					; reached EOL
.12d1	f0 08		beq $12db			beq 	_CTDataDone
.12d3	20 38 11	jsr $1138			jsr 	BufferWrite 				; write and consume
.12d6	20 68 1a	jsr $1a68			jsr 	GetNext
.12d9	80 f3		bra $12ce			bra 	_CTDataLoop
.12db					_CTDataDone:
.12db	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.12dd	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.12e0	20 44 11	jsr $1144			jsr 	BufferOutput
.12e3	60		rts				rts
.12e4					CommandDEF:
.12e4	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.12e6	20 25 12	jsr $1225			jsr 	PushIntegerA
.12e9	20 78 1b	jsr $1b78			jsr 	CompileGotoEOL 				; compile skip over DEF
.12ec	a9 a5		lda #$a5			lda 	#C64_FN
.12ee	20 65 11	jsr $1165			jsr 	CheckNextA
.12f1	20 73 1a	jsr $1a73			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.12f4	20 d8 1a	jsr $1ad8			jsr 	ExtractVariableName
.12f7	8a		txa				txa
.12f8	10 51		bpl $134b			bpl 	_CDError
.12fa	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.12fb	29 7f		and #$7f			and 	#$7F
.12fd	aa		tax				tax
.12fe	98		tya				tya
.12ff	09 80		ora #$80			ora 	#$80
.1301	a8		tay				tay
.1302	20 cd 14	jsr $14cd			jsr 	FindVariable				; does it already exist ?
.1305	b0 44		bcs $134b			bcs 	_CDError 					; if so, that's an error.
.1307	20 57 12	jsr $1257			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.130a	20 9c 12	jsr $129c			jsr 	SetVariableRecordToCodePosition
.130d	20 73 1a	jsr $1a73			jsr 	GetNextNonSpace
.1310	20 b4 1d	jsr $1db4			jsr 	GetReferenceTerm 			; get var ref, not array
.1313	c9 00		cmp #$00			cmp 	#0
.1315	30 34		bmi $134b			bmi 	_CDError
.1317	8d 09 05	sta $0509			sta 	defType 					; save type
.131a	8e 0a 05	stx $050a			stx 	defVariable 				; save var ref
.131d	8c 0b 05	sty $050b			sty 	defVariable+1
.1320	29 40		and #$40			and 	#NSSString 					; only numbers.
.1322	d0 27		bne $134b			bne 	_CDError
.1324	20 5f 11	jsr $115f			jsr 	CheckNextRParen 			; check )
.1327	a9 b2		lda #$b2			lda 	#C64_EQUAL
.1329	20 65 11	jsr $1165			jsr 	CheckNextA 					; check =
.132c	18		clc				clc 								; if this is DEF FNxx(A), read A
.132d	20 4e 13	jsr $134e			jsr 	CDReadWriteVariable
.1330	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1332	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1335	38		sec				sec
.1336	20 4e 13	jsr $134e			jsr 	CDReadWriteVariable 		; A is now updated
.1339	20 13 14	jsr $1413			jsr 	CompileExpressionAt0 		; the actual body of the function.
.133c	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.133e	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1341	38		sec				sec
.1342	20 4e 13	jsr $134e			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.1345	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.1347	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.134a	60		rts				rts
.134b					_CDError:
.134b	4c 5c 1f	jmp $1f5c		jmp	ErrorV_syntax
.134e					CDReadWriteVariable:
.134e	ac 0b 05	ldy $050b			ldy 	defVariable+1 				; set up YX
.1351	ae 0a 05	ldx $050a			ldx 	defVariable
.1354	ad 09 05	lda $0509			lda 	defType
.1357	20 66 1d	jsr $1d66			jsr 	GetSetVariable
.135a	60		rts				rts
.0509					defType:
>0509							.fill 	1
.050a					defVariable:
>050a							.fill 	2
.135b					CommandDIM:
.135b	20 73 1a	jsr $1a73			jsr 	GetNextNonSpace 			; get the first non space character
.135e	20 d8 1a	jsr $1ad8			jsr 	ExtractVariableName 		; variable name to XY
.1361	da		phx				phx 								; save name with type bits.
.1362	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.1364	10 37		bpl $139d			bpl 	_CDError
.1366	20 cd 14	jsr $14cd			jsr 	FindVariable	 			; see if already exist
.1369	b0 35		bcs $13a0			bcs 	_CDRedefine 				; it still exists.
.136b	20 57 12	jsr $1257			jsr 	CreateVariableRecord 		; create the basic variable
.136e	20 ac 12	jsr $12ac			jsr 	AllocateBytesForType 		; allocate memory for it
.1371	68		pla				pla 								; restore type bits
.1372	5a		phy				phy 								; save the address of the basic storage
.1373	da		phx				phx
.1374	48		pha				pha
.1375	20 a3 13	jsr $13a3			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.1378	68		pla				pla
.1379	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.137b	20 25 12	jsr $1225			jsr 	PushIntegerA 				; push that type data out.
.137e	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.1380	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1383	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.1385	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1388	fa		plx				plx 								; restore address
.1389	7a		ply				ply
.138a	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.138c	38		sec				sec
.138d	20 66 1d	jsr $1d66			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.1390	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; , follows ?
.1393	c9 2c		cmp #$2c			cmp 	#","
.1395	d0 05		bne $139c			bne 	_CDExit
.1397	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume comma
.139a	80 bf		bra $135b			bra 	CommandDIM 					; do another DIM
.139c					_CDExit:
.139c	60		rts				rts
.139d					_CDError:
.139d	4c 5c 1f	jmp $1f5c		jmp	ErrorV_syntax
.13a0					_CDRedefine:
.13a0	4c 24 20	jmp $2024		jmp	ErrorV_redefine
.13a3					OutputIndexGroup:
.13a3	9c 0c 05	stz $050c			stz 	IndexCount 					; count of number of indices.
.13a6					_OIGNext:
.13a6	20 13 14	jsr $1413			jsr 	CompileExpressionAt0 		; get a dimension
.13a9	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.13ab	c9 00		cmp #$00			cmp 	#NSSIFloat
.13ad	d0 19		bne $13c8			bne 	_OIGType
.13af	ee 0c 05	inc $050c			inc 	IndexCount 					; bump the counter.
.13b2	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; does a , follow ?
.13b5	c9 2c		cmp #$2c			cmp 	#","
.13b7	d0 05		bne $13be			bne 	_OIGCheckEnd
.13b9	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume comma
.13bc	80 e8		bra $13a6			bra 	_OIGNext 					; get next dimension
.13be					_OIGCheckEnd:
.13be	20 5f 11	jsr $115f			jsr 	CheckNextRParen 			; check and consume )
.13c1	ad 0c 05	lda $050c			lda 	IndexCount
.13c4	20 25 12	jsr $1225			jsr 	PushIntegerA 				; compile the dimension count.
.13c7	60		rts				rts
.13c8					_OIGType:
.13c8	4c 6c 1f	jmp $1f6c		jmp	ErrorV_type
.050c					IndexCount:
>050c							.fill 	1
.13cb					CompilerErrorHandler:
.13cb	68		pla				pla
.13cc	7a		ply				ply
.13cd	85 2a		sta $2a				sta 	zTemp0
.13cf	84 2b		sty $2b				sty 	zTemp0+1
.13d1	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.13d3	a0 01		ldy #$01			ldy 	#1
.13d5					_EHDisplayMsg:
.13d5	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.13d7	20 0a 11	jsr $110a			jsr 	PrintCharacter
.13da	c8		iny				iny
.13db	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.13dd	d0 f6		bne $13d5			bne 	_EHDisplayMsg
.13df	a9 20		lda #$20			lda 	#32
.13e1	20 0a 11	jsr $110a			jsr 	PrintCharacter
.13e4	a9 40		lda #$40			lda 	#64
.13e6	20 0a 11	jsr $110a			jsr 	PrintCharacter
.13e9	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.13eb	20 a4 26	jsr $26a4			jsr 	FloatSetByte
.13ee	20 f6 10	jsr $10f6			jsr 	GetLineNumber
.13f1	95 3c		sta $3c,x			sta 	NSMantissa0,x
.13f3	98		tya				tya
.13f4	95 48		sta $48,x			sta 	NSMantissa1,x
.13f6	20 8a 25	jsr $258a			jsr 	FloatToString
.13f9	a0 00		ldy #$00			ldy 	#0 							; display that string.
.13fb	a2 00		ldx #$00			ldx 	#0
.13fd					_EHDisplayLine:
.13fd	b9 3e 05	lda $053e,y			lda 	decimalBuffer,y
.1400	20 0a 11	jsr $110a			jsr 	PrintCharacter
.1403	c8		iny				iny
.1404	b9 3e 05	lda $053e,y			lda 	decimalBuffer,y
.1407	d0 f4		bne $13fd			bne 	_EHDisplayLine
.1409	a9 0d		lda #$0d			lda 	#13
.140b	20 0a 11	jsr $110a			jsr 	PrintCharacter
.140e	80 fe		bra $140e	_EHHalt:bra 	_EHHalt
.1410	4c 0a 12	jmp $120a			jmp 	ExitCompiler
.1413					CompileExpressionAt0:
.1413	a9 00		lda #$00			lda 	#0
.1415					CompileExpressionAtA:
.1415	48		pha				pha  								; save level
.1416	20 1f 1e	jsr $1e1f			jsr 	CompileTerm 				; compile a term.
.1419	fa		plx				plx 								; get level back into X
.141a					_ECALoop:
.141a	48		pha				pha 								; save type on stack.
.141b	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; get the next character
.141e	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.1420	90 04		bcc $1426			bcc 	_ECAExit
.1422	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.1424	90 02		bcc $1428			bcc 	_ECAHaveToken
.1426					_ECAExit:
.1426	68		pla				pla 								; throw type off stack
.1427	60		rts				rts
.1428					_ECAHaveToken:
.1428	86 2a		stx $2a				stx 	zTemp0 						; save current precedence in zTemp0
.142a	aa		tax				tax 								; X contains the operator token
.142b	bd 16 14	lda $1416,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.142e	c5 2a		cmp $2a				cmp 	zTemp0 						; if < then exit
.1430	90 f4		bcc $1426			bcc 	_ECAExit
.1432	85 2b		sta $2b				sta 	zTemp0+1 					; save the precedence of the operator.
.1434	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume the token.
.1437	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.1439	f0 11		beq $144c			beq 	_ECAGreaterCheck
.143b	e0 b3		cpx #$b3			cpx 	#C64_LESS
.143d	d0 1a		bne $1459			bne 	_ECAHaveFullToken
.143f	20 57 1a	jsr $1a57			jsr 	LookNext 					; checks for < (<= or <>)
.1442	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.1444	f0 0e		beq $1454			beq	 	_ECAToNotEqual
.1446	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.1448	d0 0f		bne $1459			bne 	_ECAHaveFullToken
.144a	80 07		bra $1453			bra 	_ECAAddEqual
.144c					_ECAGreaterCheck:
.144c	20 57 1a	jsr $1a57			jsr 	LookNext
.144f	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.1451	d0 06		bne $1459			bne 	_ECAHaveFullToken
.1453					_ECAAddEqual:
.1453	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.1454					_ECAToNotEqual:
.1454	e8		inx				inx
.1455	e8		inx				inx
.1456	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume the = or > in >= <= <>
.1459					_ECAHaveFullToken:
.1459	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.145b	d0 0a		bne $1467			bne 	_ECANotConcat
.145d	68		pla				pla 								; get type back
.145e	48		pha				pha
.145f	29 40		and #$40			and 	#NSSTypeMask
.1461	c9 40		cmp #$40			cmp 	#NSSString
.1463	d0 02		bne $1467			bne 	_ECANotConcat
.1465	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1467					_ECANotConcat:
.1467	da		phx				phx 								; save operator on the stack
.1468	a6 2a		ldx $2a				ldx 	zTemp0 						; push current precedence on the stack
.146a	da		phx				phx
.146b	a5 2b		lda $2b				lda 	zTemp0+1 					; get precedence of operator
.146d	1a		inc a				inc 	a
.146e	20 15 14	jsr $1415			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.1471	85 2a		sta $2a				sta 	zTemp0 						; save type in zTemp0
.1473	fa		plx				plx 								; restore current precedence in X
.1474	68		pla				pla 								; restore operator
.1475	85 2b		sta $2b				sta 	zTemp0+1 					; save it in zTemp0+1.
.1477	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.1479	90 17		bcc $1492			bcc 	_ECANotCompare
.147b	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.147d	b0 13		bcs $1492			bcs 	_ECANotCompare
.147f	7a		ply				ply 								; get type into Y
.1480	5a		phy				phy
.1481	48		pha				pha 								; save operator
.1482	98		tya				tya 								; get type
.1483	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.1485	29 40		and #$40			and 	#NSSTypeMask
.1487	c9 40		cmp #$40			cmp 	#NSSString
.1489	f0 02		beq $148d			beq 	_ECANotString
.148b	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.148d					_ECANotString:
.148d	98		tya				tya									; output token Y
.148e	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1491	68		pla				pla 								; restore operator.
.1492					_ECANotCompare:
.1492	18		clc				clc 								; convert to P-Code and compile.
.1493	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.1495	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1498	68		pla				pla 								; type of current result
.1499	45 2a		eor $2a				eor 	zTemp0 						; check compatible with r-expr type
.149b	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.149d	d0 19		bne $14b8			bne		_ECAType
.149f	a5 2a		lda $2a				lda 	zTemp0 						; get type back
.14a1	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.14a3	d0 18		bne $14bd			bne 	_ECAGoLoop
.14a5	a5 2b		lda $2b				lda 	zTemp0+1 					; check operator is + or comparator
.14a7	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.14a9	f0 10		beq $14bb			beq 	_ECAOkayString 				; (this is post conversion)
.14ab	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.14ad	90 09		bcc $14b8			bcc 	_ECAType
.14af	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.14b1	b0 05		bcs $14b8			bcs 	_ECAType
.14b3	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.14b5	4c 1a 14	jmp $141a			jmp 	_ECALoop
.14b8					_ECAType:
.14b8	4c 6c 1f	jmp $1f6c		jmp	ErrorV_type
.14bb					_ECAOkayString:
.14bb	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.14bd					_ECAGoLoop:
.14bd	4c 1a 14	jmp $141a			jmp 	_ECALoop
.14c0					PrecedenceTable:
>14c0	03						.byte 	3 					; '+'
>14c1	03						.byte 	3 					; '-'
>14c2	04						.byte 	4 					; '*'
>14c3	04						.byte 	4 					; '/'
>14c4	05						.byte 	5 					; '^'
>14c5	01						.byte 	1 					; 'and'
>14c6	00						.byte 	0 					; 'or'
>14c7	02						.byte 	2 					; '>'
>14c8	02						.byte 	2 					; '='
>14c9	02						.byte 	2 					; '<'
>14ca	02						.byte 	2 					; '>='
>14cb	02						.byte 	2 					; '<='
>14cc	02						.byte 	2 					; '<>'
.14cd					FindVariable:
.14cd	86 2c		stx $2c				stx 	zTemp1 						; save name.
.14cf	84 2d		sty $2d				sty 	zTemp1+1
.14d1					_IVCheckSpecial:
.14d1	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.14d3	d0 18		bne $14ed			bne 	_IVStandard
.14d5	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.14d7	f0 0c		beq $14e5			beq 	_IVTIFloat
.14d9	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.14db	d0 10		bne $14ed			bne 	_IVStandard
.14dd	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.14df	a2 01		ldx #$01			ldx 	#$01
.14e1	a9 40		lda #$40			lda 	#NSSString
.14e3	38		sec				sec
.14e4	60		rts				rts
.14e5					_IVTIFloat:
.14e5	a0 80		ldy #$80			ldy 	#$80
.14e7	a2 00		ldx #$00			ldx 	#$00
.14e9	a9 00		lda #$00			lda 	#0
.14eb	38		sec				sec
.14ec	60		rts				rts
.14ed					_IVStandard:
.14ed	ad 07 05	lda $0507			lda 	compilerStartHigh			; start scanning from here.
.14f0	85 2b		sta $2b				sta 	zTemp0+1
.14f2	64 2a		stz $2a				stz 	zTemp0
.14f4					_IVCheckLoop:
.14f4	b2 2a		lda ($2a)			lda 	(zTemp0) 					; finished ?
.14f6	f0 2b		beq $1523			beq  	_IVNotFound 				; if so, return with CC.
.14f8	a0 01		ldy #$01			ldy 	#1 							; match ?
.14fa	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14fc	c5 2c		cmp $2c				cmp 	zTemp1
.14fe	d0 07		bne $1507			bne	 	_IVNext
.1500	c8		iny				iny
.1501	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1503	c5 2d		cmp $2d				cmp 	zTemp1+1
.1505	f0 0d		beq $1514			beq 	_IVFound
.1507					_IVNext:
.1507	18		clc				clc
.1508	a5 2a		lda $2a				lda 	zTemp0
.150a	72 2a		adc ($2a)			adc 	(zTemp0)
.150c	85 2a		sta $2a				sta 	zTemp0
.150e	90 e4		bcc $14f4			bcc 	_IVCheckLoop
.1510	e6 2b		inc $2b				inc 	zTemp0+1
.1512	80 e0		bra $14f4			bra 	_IVCheckLoop
.1514					_IVFound:
.1514	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.1516	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1518	aa		tax				tax
.1519	c8		iny				iny
.151a	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.151c	48		pha				pha
.151d	c8		iny				iny
.151e	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1520	7a		ply				ply
.1521	38		sec				sec
.1522	60		rts				rts
.1523					_IVNotFound:
.1523	a6 2c		ldx $2c				ldx 	zTemp1 						; get variable name back
.1525	a4 2d		ldy $2d				ldy 	zTemp1+1
.1527	18		clc				clc
.1528	60		rts				rts
.1529					FixBranches:
.1529	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.152b	20 0f 12	jsr $120f			jsr 	CallAPIHandler
.152e					_FBLoop:
.152e	b2 28		lda ($28)			lda 	(objPtr) 					; get the next one.
.1530	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.1532	f0 16		beq $154a			beq 	_FBFixGotoGosub
.1534	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.1536	f0 12		beq $154a			beq 	_FBFixGotoGosub
.1538	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.153a	f0 0e		beq $154a			beq 	_FBFixGotoGosub
.153c	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.153e	f0 0a		beq $154a			beq 	_FBFixGotoGosub
.1540	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.1542	f0 3b		beq $157f			beq 	_FBFixVarSpace
.1544					_FBNext:
.1544	20 71 20	jsr $2071			jsr 	MoveObjectForward 			; move forward in object code.
.1547	90 e5		bcc $152e			bcc 	_FBLoop 					; not finished
.1549					_FBExit:
.1549	60		rts				rts
.154a					_FBFixGotoGosub:
.154a	a0 01		ldy #$01			ldy 	#1							; line number in YA
.154c	b1 28		lda ($28),y			lda 	(objPtr),y
.154e	48		pha				pha
.154f	c8		iny				iny
.1550	b1 28		lda ($28),y			lda 	(objPtr),y
.1552	a8		tay				tay
.1553	68		pla				pla
.1554	20 0a 1c	jsr $1c0a			jsr 	STRFindLine			 		; find where it is YA
.1557	90 08		bcc $1561			bcc 	_FBFFound 					; not found, so must be >
.1559	48		pha				pha
.155a	b2 28		lda ($28)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.155c	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.155e	d0 0f		bne $156f			bne 	_FBFFail
.1560	68		pla				pla
.1561					_FBFFound:
.1561	20 5a 1c	jsr $1c5a			jsr 	STRMakeOffset 				; make it an offset from X:YA
.1564	5a		phy				phy	 								; patch the GOTO/GOSUB
.1565	a0 01		ldy #$01			ldy 	#1
.1567	91 28		sta ($28),y			sta 	(objPtr),y
.1569	c8		iny				iny
.156a	68		pla				pla
.156b	91 28		sta ($28),y			sta 	(objPtr),y
.156d	80 d5		bra $1544			bra 	_FBNext
.156f					_FBFFail:
.156f	a0 02		ldy #$02			ldy 	#2
.1571	b1 28		lda ($28),y			lda 	(objPtr),y
.1573	8d 00 04	sta $0400			sta 	currentLineNumber
.1576	c8		iny				iny
.1577	b1 28		lda ($28),y			lda 	(objPtr),y
.1579	8d 01 04	sta $0401			sta 	currentLineNumber+1
.157c	4c 9f 1f	jmp $1f9f		jmp	ErrorV_line
.157f					_FBFixVarSpace:
.157f	a0 01		ldy #$01			ldy 	#1
.1581	ad 13 05	lda $0513			lda 	freeVariableMemory
.1584	91 28		sta ($28),y			sta 	(objPtr),y
.1586	c8		iny				iny
.1587	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.158a	91 28		sta ($28),y			sta 	(objPtr),y
.158c	80 b6		bra $1544			bra 	_FBNext
.158e					CommandFOR:
.158e	20 73 1a	jsr $1a73			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.1591	20 89 1a	jsr $1a89			jsr 	CharIsAlpha 				; if not alpha , error
.1594	90 59		bcc $15ef			bcc 	_CFFail
.1596	20 b4 1d	jsr $1db4			jsr 	GetReferenceTerm 			; figure out the reference.
.1599	48		pha				pha 								; save type
.159a	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.159c	c9 00		cmp #$00			cmp 	#NSSIFloat
.159e	d0 4f		bne $15ef			bne 	_CFFail
.15a0	5a		phy				phy 								; save reference on the stack
.15a1	da		phx				phx
.15a2	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.15a4	20 65 11	jsr $1165			jsr 	CheckNextA
.15a7	20 13 14	jsr $1413			jsr 	CompileExpressionAt0 		; initial value
.15aa	fa		plx				plx 								; get reference back.
.15ab	7a		ply				ply
.15ac	5a		phy				phy
.15ad	da		phx				phx
.15ae	38		sec				sec 								; set initial value.
.15af	20 66 1d	jsr $1d66			jsr 	GetSetVariable
.15b2	fa		plx				plx
.15b3	7a		ply				ply
.15b4	68		pla				pla
.15b5	29 20		and #$20			and 	#NSSIInt16
.15b7	f0 04		beq $15bd			beq 	_CFNotInt16
.15b9	98		tya				tya
.15ba	09 80		ora #$80			ora 	#$80
.15bc	a8		tay				tay
.15bd					_CFNotInt16:
.15bd	8a		txa				txa 								; reference in YA
.15be	20 12 12	jsr $1212			jsr 	PushIntegerYA
.15c1	a9 a4		lda #$a4			lda 	#C64_TO
.15c3	20 65 11	jsr $1165			jsr 	CheckNextA
.15c6	20 13 14	jsr $1413			jsr 	CompileExpressionAt0 		; terminal value
.15c9	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15cb	c9 00		cmp #$00			cmp 	#NSSIFloat
.15cd	d0 20		bne $15ef			bne 	_CFFail
.15cf	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; followed by STEP
.15d2	c9 a9		cmp #$a9			cmp 	#C64_STEP
.15d4	d0 0e		bne $15e4			bne 	_CFNoStep
.15d6	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume it.
.15d9	20 13 14	jsr $1413			jsr 	CompileExpressionAt0 		; terminal value
.15dc	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15de	c9 00		cmp #$00			cmp 	#NSSIFloat
.15e0	d0 0d		bne $15ef			bne 	_CFFail
.15e2	80 05		bra $15e9			bra 	_CFParametersDone
.15e4					_CFNoStep:
.15e4	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.15e6	20 25 12	jsr $1225			jsr 	PushIntegerA
.15e9					_CFParametersDone:
.15e9	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.15eb	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.15ee	60		rts				rts
.15ef					_CFFail:
.15ef	4c 5c 1f	jmp $1f5c		jmp	ErrorV_syntax
.15f2					FNCompile:
.15f2	20 73 1a	jsr $1a73			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.15f5	20 d8 1a	jsr $1ad8			jsr 	ExtractVariableName
.15f8	e0 00		cpx #$00			cpx 	#0
.15fa	10 32		bpl $162e			bpl 	_FNError
.15fc	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.15fd	29 7f		and #$7f			and 	#$7F
.15ff	aa		tax				tax
.1600	98		tya				tya
.1601	09 80		ora #$80			ora 	#$80
.1603	a8		tay				tay
.1604	20 cd 14	jsr $14cd			jsr 	FindVariable				; does it already exist ?
.1607	90 25		bcc $162e			bcc 	_FNError 					; no.
.1609	20 5a 1c	jsr $1c5a			jsr 	STRMakeOffset 				; convert to a relative address.
.160c	c9 00		cmp #$00			cmp 	#0 							; fix up.
.160e	d0 01		bne $1611			bne 	_FNNoBorrow
.1610	88		dey				dey
.1611					_FNNoBorrow:
.1611	3a		dec a				dec 	a
.1612	5a		phy				phy 								; save location of routine on stack.
.1613	48		pha				pha
.1614	da		phx				phx
.1615	20 13 14	jsr $1413			jsr 	CompileExpressionAt0
.1618	20 5f 11	jsr $115f			jsr 	CheckNextRParen
.161b	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.161d	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1620	68		pla				pla
.1621	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1624	68		pla				pla
.1625	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1628	68		pla				pla
.1629	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.162c	18		clc				clc
.162d	60		rts				rts
.162e					_FNError:
.162e	4c 4f 1f	jmp $1f4f		jmp	ErrorV_value
.1631					CommandTables:
>1631	07 cb 00 03 36 1b 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>1638	07 89 00 03 3d 1b 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>163f	07 8d 00 03 30 1b 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>1646	07 88 00 03 ac 1b 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>164d	07 85 00 03 8c 1b 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>1654	07 84 00 04 a0 1b 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>165b	07 99 00 03 e1 1c 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1662	07 98 00 04 e1 1c 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1669	07 8f 00 03 ec 1d 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>1670	07 81 00 03 8e 15 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>1677	07 82 00 03 64 1c 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>167e	07 a1 00 03 a9 1a 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>1685	07 83 00 03 c8 12 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>168c	07 87 00 03 2a 1d 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>1693	07 86 00 03 5b 13 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>169a	07 96 00 03 e4 12 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>16a1	07 8b 00 e3 59 1b 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>16a8	08 92 00 ea e3 b8 1e 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>16b0	09 91 00 e1 a9 03 90 1c			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>16b8	06
>16b9	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>16c0	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>16c7	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>16cd	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>16d4	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>16db	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>16e2	07 9d 00 e3 de 1e 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>16e9	0a 9f 00 ea e3 f1 1e 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>16f1	c6 06
>16f3	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>16f9	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>1700	0a ce 92 e3 26 1a 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>1708	ad 06
>170a	0a ce 8d e3 26 1a 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>1712	ae 06
>1714	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>171a	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>1722	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>1729	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>1730	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>1738	06
>1739	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>1741	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>1749	9a 06
>174b	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>1753	9b 06
>1755	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>175d	9c 06
>175f	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>1767	06
>1768	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>176f	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>1777	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>177f	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>1787	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>178f	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>1797	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>179f	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>17a7	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>17af	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>17b7	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>17bf	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>17c6	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>17ce	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>17d6	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>17de	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>17e6	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>17ee	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>17f6	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>17fe	00						.byte 	0
.17ff					UnaryTables:
>17ff	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>1806	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>180e	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>1815	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>181c	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>1823	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>182a	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>1832	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>1839	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>1841	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>1849	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>1851	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>1859	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>1861	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>1869	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>1870	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>1877	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>187e	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>1885	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>188c	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>1893	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>189b	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>18a3	0b ca 00 8f ae 03 26 1a			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>18ab	91 bd 07
>18ae	07 a8 00 03 45 1a 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>18b5	07 a5 00 03 f2 15 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>18bc	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>18c3	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>18ca	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>18d2	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>18da	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>18e1	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>18e8	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>18ef	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>18f7	06
>18f8	00						.byte 	0
.18f9					GeneratorProcess:
.18f9	86 2a		stx $2a				stx 	zTemp0 						; save generation pointer in zTemp0
.18fb	84 2b		sty $2b				sty 	zTemp0+1
.18fd	85 2c		sta $2c				sta 	zTemp1 						; first match token
.18ff	64 2d		stz $2d				stz 	zTemp1+1
.1901	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.1903	d0 05		bne $190a			bne 	_GPNotShifted
.1905	20 68 1a	jsr $1a68			jsr 	GetNext 					; get the shifted token
.1908	85 2d		sta $2d				sta 	zTemp1+1 					; match CE xx
.190a					_GPNotShifted:
.190a					_GPSearch:
.190a	b2 2a		lda ($2a)			lda 	(zTemp0) 					; reached end ?
.190c	18		clc				clc
.190d	f0 2f		beq $193e			beq 	_GPExit
.190f	a0 01		ldy #$01			ldy 	#1 							; tokens match
.1911	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1913	c5 2c		cmp $2c				cmp 	zTemp1
.1915	d0 09		bne $1920			bne 	_GPNext
.1917	a5 2d		lda $2d				lda 	zTemp1+1 					; 2nd token ?
.1919	f0 12		beq $192d			beq 	_GPFound
.191b	c8		iny				iny 								; check match.
.191c	d1 2a		cmp ($2a),y			cmp 	(zTemp0),y
.191e	f0 0d		beq $192d			beq 	_GPFound
.1920					_GPNext:
.1920	18		clc				clc 								; follow to next
.1921	a5 2a		lda $2a				lda 	zTemp0
.1923	72 2a		adc ($2a)			adc 	(zTemp0)
.1925	85 2a		sta $2a				sta 	zTemp0
.1927	90 e1		bcc $190a			bcc 	_GPSearch
.1929	e6 2b		inc $2b				inc 	zTemp0+1
.192b	80 dd		bra $190a			bra 	_GPSearch
.192d					_GPFound:
.192d	18		clc				clc 								; skip to action bytes
.192e	a5 2a		lda $2a				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.1930	69 03		adc #$03			adc 	#3
.1932	85 2a		sta $2a				sta 	zTemp0
.1934	90 02		bcc $1938			bcc 	_GPNoCarry
.1936	e6 2b		inc $2b				inc 	zTemp0+1
.1938					_GPNoCarry:
.1938					_GPLoop:
.1938	20 3f 19	jsr $193f			jsr 	GeneratorExecute 			; execute one command
.193b	90 fb		bcc $1938			bcc 	_GPLoop 					; go back if not completed.
.193d	38		sec				sec 								; return with CS.
.193e					_GPExit:
.193e	60		rts				rts
.193f					GeneratorExecute:
.193f	20 eb 19	jsr $19eb			jsr 	_GEFetchZTemp0 				; get next.
.1942	48		pha				pha 								; split into 2 nibbles
.1943	4a		lsr a				lsr 	a
.1944	4a		lsr a				lsr 	a
.1945	4a		lsr a				lsr		a
.1946	4a		lsr a				lsr 	a
.1947	20 51 19	jsr $1951			jsr 	_GEExecuteNibble 			; MSB first
.194a	68		pla				pla
.194b	b0 03		bcs $1950			bcs 	_GEHaveCompleted
.194d	20 51 19	jsr $1951			jsr 	_GEExecuteNibble 			; LSB second
.1950					_GEHaveCompleted:
.1950	60		rts				rts
.1951					_GEExecuteNibble:
.1951	29 0f		and #$0f			and 	#$0F
.1953	0a		asl a				asl 	a
.1954	aa		tax				tax
.1955	7c 58 19	jmp ($1958,x)			jmp 	(_GEExecuteVectors,x)
.1958					_GEExecuteVectors:
>1958	78 19						.word 	_GEXNop 					; 0  (no operation)
>195a	80 19						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>195c	7a 19						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>195e	ce 19						.word 	_GEXExecute 				; 3  (run arbitrary code)
>1960	c1 19						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>1962	78 19						.word 	_GEXNop 					; 5
>1964	88 19						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>1966	8c 19						.word 	_GEXExitString 				; 7  exit return string type
>1968	90 19						.word 	_GEXLParam 					; 8  check ( follows
>196a	94 19						.word 	_GEXRParam 					; 9  check ) follows
>196c	98 19						.word 	_GEXComma					; A  check , follows
>196e	78 19						.word 	_GEXNop 					; B
>1970	78 19						.word 	_GEXNop 					; C
>1972	78 19						.word 	_GEXNop 					; D
>1974	a8 19						.word 	_GEXNumber 					; E  compile get any number
>1976	b3 19						.word 	_GEXString 					; F  compile get any string
.1978					_GEXNop:
.1978	18		clc				clc
.1979	60		rts				rts
.197a					_GEXToken2:
.197a	20 eb 19	jsr $19eb			jsr 	_GEFetchZTemp0
.197d	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1980					_GEXToken1:
.1980	20 eb 19	jsr $19eb			jsr 	_GEFetchZTemp0
.1983	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1986	18		clc				clc
.1987	60		rts				rts
.1988					_GEXExitNumber:
.1988	a9 00		lda #$00			lda 	#NSSIFloat
.198a	38		sec				sec
.198b	60		rts				rts
.198c					_GEXExitString:
.198c	a9 40		lda #$40			lda 	#NSSString
.198e	38		sec				sec
.198f	60		rts				rts
.1990					_GEXLParam:
.1990	a9 28		lda #$28			lda 	#"("
.1992	80 06		bra $199a			bra 	_GEXCheck
.1994					_GEXRParam:
.1994	a9 29		lda #$29			lda 	#")"
.1996	80 02		bra $199a			bra 	_GEXCheck
.1998					_GEXComma:
.1998	a9 2c		lda #$2c			lda 	#","
.199a					_GEXCheck:
.199a	85 2e		sta $2e				sta 	zTemp2 						; save match
.199c	20 73 1a	jsr $1a73			jsr 	GetNextNonSpace 			; get next skipping spaces
.199f	c5 2e		cmp $2e				cmp 	zTemp2 						; check matches.
.19a1	d0 02		bne $19a5			bne 	_GEXSyntax
.19a3	18		clc				clc
.19a4	60		rts				rts
.19a5					_GEXSyntax:
.19a5	4c 5c 1f	jmp $1f5c		jmp	ErrorV_syntax
.19a8					_GEXNumber:
.19a8	20 f4 19	jsr $19f4			jsr 	GEXCompileExpression 		; compile expression
.19ab	29 40		and #$40			and 	#NSSTypeMask
.19ad	c9 00		cmp #$00			cmp  	#NSSIFloat
.19af	d0 0d		bne $19be			bne 	_GEXType
.19b1	18		clc				clc
.19b2	60		rts				rts
.19b3					_GEXString:
.19b3	20 f4 19	jsr $19f4			jsr 	GEXCompileExpression 		; compile expression
.19b6	29 40		and #$40			and 	#NSSTypeMask
.19b8	c9 40		cmp #$40			cmp  	#NSSString
.19ba	d0 02		bne $19be			bne 	_GEXType
.19bc	18		clc				clc
.19bd	60		rts				rts
.19be					_GEXType:
.19be	4c 6c 1f	jmp $1f6c		jmp	ErrorV_type
.19c1					_GEXChannelExec:
.19c1	20 04 1a	jsr $1a04			jsr 	ChannelPrefix 				; set up default
.19c4	20 ce 19	jsr $19ce			jsr 	_GEXExecute
.19c7	08		php				php
.19c8	20 1f 1a	jsr $1a1f			jsr 	ChannelPostfix 				; replace default.
.19cb	28		plp				plp
.19cc	60		rts				rts
>19cd	db						.byte 	$DB 						; causes a break in the emulator
.19ce					_GEXExecute:
.19ce	20 eb 19	jsr $19eb			jsr 	_GEFetchZTemp0 				; get vector
.19d1	85 2e		sta $2e				sta 	zTemp2
.19d3	20 eb 19	jsr $19eb			jsr 	_GEFetchZTemp0
.19d6	85 2f		sta $2f				sta 	zTemp2+1
.19d8	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19da	da		phx				phx
.19db	a6 2b		ldx $2b				ldx 	zTemp0+1
.19dd	da		phx				phx
.19de	20 e8 19	jsr $19e8			jsr 	_GECallZTemp2 				; execute code
.19e1	fa		plx				plx 								; recover generation exec
.19e2	86 2b		stx $2b				stx 	zTemp0+1
.19e4	fa		plx				plx
.19e5	86 2a		stx $2a				stx 	zTemp0
.19e7	60		rts				rts
.19e8					_GECallZTemp2:
.19e8	6c 2e 00	jmp ($002e)			jmp 	(zTemp2)
.19eb					_GEFetchZTemp0:
.19eb	b2 2a		lda ($2a)			lda 	(zTemp0)
.19ed	e6 2a		inc $2a				inc 	zTemp0
.19ef	d0 02		bne $19f3			bne 	_GEFZ0Skip
.19f1	e6 2b		inc $2b				inc 	zTemp0+1
.19f3					_GEFZ0Skip:
.19f3	60		rts				rts
.19f4					GEXCompileExpression:
.19f4	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19f6	da		phx				phx
.19f7	a6 2b		ldx $2b				ldx 	zTemp0+1
.19f9	da		phx				phx
.19fa	20 13 14	jsr $1413			jsr 	CompileExpressionAt0 		; compile expression.
.19fd	fa		plx				plx 								; recover generation exec
.19fe	86 2b		stx $2b				stx 	zTemp0+1
.1a00	fa		plx				plx
.1a01	86 2a		stx $2a				stx 	zTemp0
.1a03	60		rts				rts
.1a04					ChannelPrefix:
.1a04	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.1a06	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1a09	20 f4 19	jsr $19f4			jsr 	GEXCompileExpression 		; channel #
.1a0c	29 40		and #$40			and 	#NSSTypeMask
.1a0e	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a10	d0 0a		bne $1a1c			bne 	_CPXType
.1a12	20 5b 11	jsr $115b			jsr 	CheckNextComma 				; check , follows.
.1a15	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.1a17	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1a1a	18		clc				clc
.1a1b	60		rts				rts
.1a1c					_CPXType:
.1a1c	4c 6c 1f	jmp $1f6c		jmp	ErrorV_type
.1a1f					ChannelPostfix:
.1a1f	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.1a21	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1a24	18		clc				clc
.1a25	60		rts				rts
.1a26					OptionalParameterCompile:
.1a26	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; what follows.
.1a29	c9 2c		cmp #$2c			cmp 	#","
.1a2b	d0 0e		bne $1a3b			bne 	_MidDefault
.1a2d	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume ,
.1a30	20 13 14	jsr $1413			jsr 	CompileExpressionAt0
.1a33	29 40		and #$40			and 	#NSSTypeMask
.1a35	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a37	d0 09		bne $1a42			bne 	MidFailType
.1a39	80 05		bra $1a40			bra 	_MidComplete
.1a3b					_MidDefault:
.1a3b	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1a3d	20 25 12	jsr $1225			jsr 	PushIntegerA
.1a40					_MidComplete:
.1a40	18		clc				clc
.1a41	60		rts				rts
.1a42					MidFailType:
.1a42	4c 6c 1f	jmp $1f6c		jmp	ErrorV_type
.1a45					NotUnaryCompile:
.1a45	ad c8 14	lda $14c8			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1a48	20 15 14	jsr $1415			jsr 	CompileExpressionAtA 		; evaluate at that level
.1a4b	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1a4d	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a4f	d0 f1		bne $1a42			bne 	MidFailType
.1a51	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1a53	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1a56	60		rts				rts
.1a57					LookNext:
.1a57	b2 24		lda ($24)			lda 	(srcPtr)
.1a59	60		rts				rts
.1a5a					LookNextNonSpace:
.1a5a	b2 24		lda ($24)			lda 	(srcPtr)
.1a5c	c9 20		cmp #$20			cmp		#' '
.1a5e	f0 03		beq $1a63			beq 	_LNNSkip
.1a60	c9 00		cmp #$00			cmp 	#0
.1a62	60		rts				rts
.1a63					_LNNSkip:
.1a63	20 68 1a	jsr $1a68			jsr 	GetNext
.1a66	80 f2		bra $1a5a			bra 	LookNextNonSpace
.1a68					GetNext:
.1a68	b2 24		lda ($24)			lda 	(srcPtr) 					; get next
.1a6a	e6 24		inc $24				inc 	srcPtr
.1a6c	d0 02		bne $1a70			bne 	_GNSkip
.1a6e	e6 25		inc $25				inc 	srcPtr+1
.1a70					_GNSkip:
.1a70	c9 00		cmp #$00			cmp 	#0
.1a72	60		rts				rts
.1a73					GetNextNonSpace:
.1a73	20 68 1a	jsr $1a68			jsr 	GetNext
.1a76	c9 20		cmp #$20			cmp 	#' '
.1a78	f0 f9		beq $1a73			beq 	GetNextNonSpace
.1a7a	c9 00		cmp #$00			cmp 	#0
.1a7c	60		rts				rts
.1a7d					CharIsDigit:
.1a7d	c9 30		cmp #$30			cmp 	#"0"
.1a7f	90 06		bcc $1a87			bcc 	CCFalse
.1a81	c9 3a		cmp #$3a			cmp 	#"9"+1
.1a83	b0 02		bcs $1a87			bcs 	CCFalse
.1a85					CCTrue:
.1a85	38		sec				sec
.1a86	60		rts				rts
.1a87					CCFalse:
.1a87	18		clc				clc
.1a88	60		rts				rts
.1a89					CharIsAlpha:
.1a89	c9 41		cmp #$41			cmp 	#"A"
.1a8b	90 fa		bcc $1a87			bcc 	CCFalse
.1a8d	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1a8f	b0 f6		bcs $1a87			bcs 	CCFalse
.1a91	80 f2		bra $1a85			bra 	CCTrue
.1a93					ConvertHexStyle:
.1a93	38		sec				sec
.1a94	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1a96	90 ef		bcc $1a87			bcc 	CCFalse
.1a98	c9 0a		cmp #$0a			cmp 	#9+1
.1a9a	90 e9		bcc $1a85			bcc 	CCTrue
.1a9c	38		sec				sec 								; shift into hex space A=>0 Z=>25
.1a9d	e9 11		sbc #$11			sbc 	#"A"-"0"
.1a9f	90 e6		bcc $1a87			bcc 	CCFalse
.1aa1	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.1aa3	b0 e2		bcs $1a87			bcs 	CCFalse
.1aa5	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.1aa7	80 dc		bra $1a85			bra 	CCTrue
.1aa9					CommandGET:
.1aa9	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; # follows ?
.1aac	c9 23		cmp #$23			cmp 	#"#"
.1aae	d0 0d		bne $1abd			bne 	CommandGetBody
.1ab0	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume #
.1ab3	20 04 1a	jsr $1a04			jsr 	ChannelPrefix 				; do it as GET#
.1ab6	20 bd 1a	jsr $1abd			jsr 	CommandGetBody
.1ab9	20 1f 1a	jsr $1a1f			jsr 	ChannelPostfix
.1abc	60		rts				rts
.1abd					CommandGetBody:
.1abd	20 73 1a	jsr $1a73			jsr 	GetNextNonSpace 			; get the first character
.1ac0	20 b4 1d	jsr $1db4			jsr 	GetReferenceTerm 			; identify variable to assign to
.1ac3	48		pha				pha
.1ac4	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1ac6	c9 40		cmp #$40			cmp 	#NSSString
.1ac8	d0 0b		bne $1ad5			bne 	_CGType
.1aca	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1acc	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1acf	38		sec				sec
.1ad0	68		pla				pla
.1ad1	20 66 1d	jsr $1d66			jsr		GetSetVariable
.1ad4	60		rts				rts
.1ad5					_CGType:
.1ad5	4c 6c 1f	jmp $1f6c		jmp	ErrorV_type
.1ad8					ExtractVariableName:
.1ad8	20 89 1a	jsr $1a89			jsr 	CharIsAlpha
.1adb	90 50		bcc $1b2d			bcc 	_IVSyntax
.1add	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.1adf	85 2c		sta $2c				sta 	zTemp1 						; we'll build it in zTemp1
.1ae1	64 2d		stz $2d				stz 	zTemp1+1
.1ae3	20 57 1a	jsr $1a57			jsr 	LookNext 					; is there a second character ?
.1ae6	20 89 1a	jsr $1a89			jsr 	CharIsAlpha  				; must be alphanumeric
.1ae9	b0 05		bcs $1af0			bcs 	_IVHasSecond
.1aeb	20 7d 1a	jsr $1a7d			jsr 	CharIsDigit
.1aee	90 07		bcc $1af7			bcc 	_IVCheckType
.1af0					_IVHasSecond:
.1af0	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.1af2	85 2d		sta $2d				sta 	zTemp1+1
.1af4					_IVGetNextCheck:
.1af4	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume it
.1af7					_IVCheckType:
.1af7	20 57 1a	jsr $1a57			jsr 	LookNext					; check if string follows.
.1afa	20 89 1a	jsr $1a89			jsr 	CharIsAlpha
.1afd	b0 f5		bcs $1af4			bcs 	_IVGetNextCheck
.1aff	20 7d 1a	jsr $1a7d			jsr 	CharIsDigit
.1b02	b0 f0		bcs $1af4			bcs 	_IVGetNextCheck
.1b04	a2 40		ldx #$40			ldx 	#NSSString
.1b06	c9 24		cmp #$24			cmp 	#"$"
.1b08	f0 06		beq $1b10			beq 	_IVHasType
.1b0a	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.1b0c	c9 25		cmp #$25			cmp 	#"%"
.1b0e	d0 08		bne $1b18			bne 	_IVCheckArray
.1b10					_IVHasType:
.1b10	8a		txa				txa 								; Or X into zTemp1
.1b11	05 2c		ora $2c				ora 	zTemp1
.1b13	85 2c		sta $2c				sta 	zTemp1
.1b15	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume it
.1b18					_IVCheckArray:
.1b18	20 57 1a	jsr $1a57			jsr 	LookNext 					; check if array follows
.1b1b	c9 28		cmp #$28			cmp 	#"("
.1b1d	d0 09		bne $1b28			bne 	_IVNotArray
.1b1f	a5 2c		lda $2c				lda 	zTemp1 						; set array bit
.1b21	09 80		ora #$80			ora 	#NSSArray
.1b23	85 2c		sta $2c				sta 	zTemp1
.1b25	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume it
.1b28					_IVNotArray:
.1b28	a6 2c		ldx $2c				ldx 	zTemp1
.1b2a	a4 2d		ldy $2d				ldy 	zTemp1+1
.1b2c	60		rts				rts
.1b2d					_IVSyntax:
.1b2d	4c 5c 1f	jmp $1f5c		jmp	ErrorV_syntax
.1b30					CommandGOSUB:
.1b30	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1b32	20 43 1b	jsr $1b43			jsr 	CompileBranchCommand
.1b35	60		rts				rts
.1b36					CommandGOAlt:
.1b36	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1b38	20 65 11	jsr $1165			jsr 	CheckNextA
.1b3b	80 00		bra $1b3d			bra 	CommandGOTO
.1b3d					CommandGOTO:
.1b3d	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1b3f	20 43 1b	jsr $1b43			jsr 	CompileBranchCommand
.1b42	60		rts				rts
.1b43					CompileBranchCommand:
.1b43	20 fd 10	jsr $10fd			jsr 	WriteCodeByte 				; write the command out.
.1b46	20 73 1a	jsr $1a73			jsr 	GetNextNonSpace
.1b49	20 bc 1c	jsr $1cbc			jsr 	ParseConstant 				; get constant into YA
.1b4c	90 08		bcc $1b56			bcc 	_CBCSyntax
.1b4e	20 fd 10	jsr $10fd			jsr 	WriteCodeByte				; and compile the actual line number
.1b51	98		tya				tya
.1b52	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1b55	60		rts				rts
.1b56					_CBCSyntax:
.1b56	4c 5c 1f	jmp $1f5c		jmp	ErrorV_syntax
.1b59					CommandIF:
.1b59	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; what follows the tests ?
.1b5c	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1b5e	f0 0f		beq $1b6f			beq 	_CIGoto
.1b60	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1b62	20 65 11	jsr $1165			jsr 	CheckNextA
.1b65	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; THEN <number>
.1b68	20 7d 1a	jsr $1a7d			jsr 	CharIsDigit
.1b6b	b0 05		bcs $1b72			bcs 	_CIGoto2
.1b6d	80 09		bra $1b78			bra 	CompileGotoEOL
.1b6f					_CIGoto:
.1b6f	20 68 1a	jsr $1a68			jsr 	GetNext
.1b72					_CIGoto2:
.1b72	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1b74	20 43 1b	jsr $1b43			jsr 	CompileBranchCommand
.1b77	60		rts				rts
.1b78					CompileGotoEOL:
.1b78	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.1b7a	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1b7d	20 f6 10	jsr $10f6			jsr 	GetLineNumber 				; Get the current line number => YA
.1b80	1a		inc a				inc 	a 							; and branch to +1
.1b81	d0 01		bne $1b84			bne 	_CGENoCarry
.1b83	c8		iny				iny
.1b84					_CGENoCarry:
.1b84	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1b87	98		tya				tya
.1b88	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1b8b	60		rts				rts
.1b8c					CommandINPUT:
.1b8c	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; check for "
.1b8f	c9 22		cmp #$22			cmp 	#'"'
.1b91	d0 0d		bne $1ba0			bne 	CommandINPUTStream
.1b93	20 13 14	jsr $1413			jsr 	CompileExpressionAt0
.1b96	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1b98	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1b9b	a9 2c		lda #$2c			lda 	#","
.1b9d	20 5b 11	jsr $115b			jsr 	CheckNextComma
.1ba0					CommandINPUTStream:
.1ba0	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1ba2	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1ba5	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.1ba7	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1ba9	4c 2e 1d	jmp $1d2e			jmp 	CommandReadInputCommon
.1bac					CommandLET:
.1bac	20 73 1a	jsr $1a73			jsr 	GetNextNonSpace 			; get the first character
.1baf					CommandLETHaveFirst:
.1baf	20 b4 1d	jsr $1db4			jsr 	GetReferenceTerm 			; identify variable to assign to
.1bb2	da		phx				phx 								; save target on the stack.
.1bb3	5a		phy				phy
.1bb4	48		pha				pha
.1bb5	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.1bb7	20 65 11	jsr $1165			jsr 	CheckNextA
.1bba	20 13 14	jsr $1413			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1bbd	85 2a		sta $2a				sta 	zTemp0 						; save type returned
.1bbf	68		pla				pla 								; get type of assignment
.1bc0	48		pha				pha
.1bc1	45 2a		eor $2a				eor 	zTemp0 						; compare using EOR
.1bc3	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.1bc5	d0 17		bne $1bde			bne 	_CLType
.1bc7	68		pla				pla 								; restore and compile save code
.1bc8	7a		ply				ply
.1bc9	fa		plx				plx
.1bca	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.1bcc	f0 05		beq $1bd3			beq 	_CLTIString
.1bce	38		sec				sec
.1bcf	20 66 1d	jsr $1d66			jsr		GetSetVariable
.1bd2	60		rts				rts
.1bd3					_CLTIString:
.1bd3	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.1bd5	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1bd8	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.1bda	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1bdd	60		rts				rts
.1bde					_CLType:
.1bde	4c 6c 1f	jmp $1f6c		jmp	ErrorV_type
.1be1					STRMarkLine:
.1be1	48		pha				pha
.1be2	38		sec				sec 								; allocate 4 bytes (line #,address)
.1be3	ad 0f 05	lda $050f			lda 	lineNumberTable 			; and copy to zTemp0
.1be6	e9 04		sbc #$04			sbc 	#4
.1be8	8d 0f 05	sta $050f			sta 	lineNumberTable
.1beb	85 2a		sta $2a				sta 	zTemp0
.1bed	ad 10 05	lda $0510			lda 	lineNumberTable+1
.1bf0	e9 00		sbc #$00			sbc 	#0
.1bf2	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1bf5	85 2b		sta $2b				sta 	zTemp0+1
.1bf7	68		pla				pla
.1bf8	92 2a		sta ($2a)			sta 	(zTemp0) 					; line # save it in +0,+1
.1bfa	98		tya				tya
.1bfb	a0 01		ldy #$01			ldy 	#1
.1bfd	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1bff	a5 28		lda $28				lda 	objPtr 						; save current address in +2,+3
.1c01	c8		iny				iny
.1c02	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1c04	a5 29		lda $29				lda 	objPtr+1
.1c06	c8		iny				iny
.1c07	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1c09	60		rts				rts
.1c0a					STRFindLine:
.1c0a	85 2a		sta $2a				sta 	zTemp0 						; zTemp0 line number being searched
.1c0c	84 2b		sty $2b				sty 	zTemp0+1
.1c0e	ad 08 05	lda $0508			lda 	compilerEndHigh 			; work backwards through table
.1c11	85 2d		sta $2d				sta 	zTemp1+1
.1c13	64 2c		stz $2c				stz 	zTemp1
.1c15					_STRSearch:
.1c15	20 4c 1c	jsr $1c4c			jsr 	_STRPrevLine 				; look at previous record.
.1c18	a0 01		ldy #$01			ldy 	#1
.1c1a	b2 2c		lda ($2c)			lda 	(zTemp1) 					; check table line # >= target
.1c1c	c5 2a		cmp $2a				cmp 	zTemp0
.1c1e	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c20	e5 2b		sbc $2b				sbc 	zTemp0+1
.1c22	b0 0b		bcs $1c2f			bcs 	_STRFound 					; >=
.1c24					_STRNext:
.1c24	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1c26	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c28	c9 ff		cmp #$ff			cmp 	#$FF
.1c2a	d0 e9		bne $1c15			bne 	_STRSearch
.1c2c	4c b6 1f	jmp $1fb6		jmp	ErrorV_internal
.1c2f					_STRFound:
.1c2f	b2 2c		lda ($2c)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1c31	45 2a		eor $2a				eor 	zTemp0
.1c33	d0 06		bne $1c3b			bne 	_STRDifferent
.1c35	b2 2c		lda ($2c)			lda 	(zTemp1)
.1c37	45 2a		eor $2a				eor 	zTemp0
.1c39	f0 02		beq $1c3d			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1c3b					_STRDifferent:
.1c3b	a9 ff		lda #$ff			lda 	#$FF
.1c3d					_STROut:
.1c3d	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1c3e	69 ff		adc #$ff			adc 	#255
.1c40	08		php				php
.1c41	c8		iny				iny 								; address into YA
.1c42	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c44	48		pha				pha
.1c45	c8		iny				iny
.1c46	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c48	a8		tay				tay
.1c49	68		pla				pla
.1c4a	28		plp				plp
.1c4b	60		rts				rts
.1c4c					_STRPrevLine:
.1c4c	38		sec				sec 								; move backwards one entry.
.1c4d	a5 2c		lda $2c				lda 	zTemp1
.1c4f	e9 04		sbc #$04			sbc 	#4
.1c51	85 2c		sta $2c				sta 	zTemp1
.1c53	a5 2d		lda $2d				lda 	zTemp1+1
.1c55	e9 00		sbc #$00			sbc 	#0
.1c57	85 2d		sta $2d				sta 	zTemp1+1
.1c59	60		rts				rts
.1c5a					STRMakeOffset:
.1c5a	18		clc				clc 								; borrow 1
.1c5b	e5 28		sbc $28				sbc 	objPtr
.1c5d	48		pha				pha
.1c5e	98		tya				tya
.1c5f	e5 29		sbc $29				sbc 	objPtr+1
.1c61	a8		tay				tay
.1c62	68		pla				pla
.1c63	60		rts				rts
.1c64					CommandNEXT:
.1c64	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1c67	20 89 1a	jsr $1a89			jsr 	CharIsAlpha 				; if not alpha , error
.1c6a	90 0c		bcc $1c78			bcc 	_CNNoReferenceGiven
.1c6c	20 68 1a	jsr $1a68			jsr 	GetNext
.1c6f	20 b4 1d	jsr $1db4			jsr 	GetReferenceTerm 			; figure out the reference.
.1c72	8a		txa				txa 								; reference in YA
.1c73	20 12 12	jsr $1212			jsr 	PushIntegerYA 				; write it out.
.1c76	80 06		bra $1c7e			bra 	_CNParametersDone
.1c78					_CNNoReferenceGiven:
.1c78	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1c7a	a8		tay				tay
.1c7b	20 12 12	jsr $1212			jsr 	PushIntegerYA 				; write it out.
.1c7e					_CNParametersDone:
.1c7e	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1c80	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1c83	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; look for ,
.1c86	c9 2c		cmp #$2c			cmp 	#","
.1c88	d0 05		bne $1c8f			bne 	_CNExit
.1c8a	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume ,
.1c8d	80 d5		bra $1c64			bra 	CommandNEXT 				; and go round.
.1c8f					_CNExit:
.1c8f	60		rts				rts
.1c90					CommandON:
.1c90	20 73 1a	jsr $1a73			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1c93	48		pha				pha 								; save on stack
.1c94	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1c96	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1c98	f0 09		beq $1ca3			beq 	_COCreateLoop
.1c9a	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1c9c	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1c9e	f0 03		beq $1ca3			beq 	_COCreateLoop
.1ca0	4c 5c 1f	jmp $1f5c		jmp	ErrorV_syntax
.1ca3					_COCreateLoop:
.1ca3	8a		txa				txa 								; compile a goto/gosub somewhere
.1ca4	da		phx				phx
.1ca5	20 43 1b	jsr $1b43			jsr 	CompileBranchCommand
.1ca8	fa		plx				plx
.1ca9	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace			; ',' follows
.1cac	c9 2c		cmp #$2c			cmp 	#","
.1cae	d0 0a		bne $1cba			bne 	_COComplete 				; if so, more line numbers
.1cb0	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1cb2	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1cb5	20 68 1a	jsr $1a68			jsr 	GetNext
.1cb8	80 e9		bra $1ca3			bra 	_COCreateLoop
.1cba					_COComplete:
.1cba	68		pla				pla 								; throw GOTO/GOSUB
.1cbb	60		rts				rts
.1cbc					ParseConstant:
.1cbc	a2 00		ldx #$00			ldx 	#0
.1cbe	20 82 24	jsr $2482			jsr 	FloatEncodeStart 			; send first
.1cc1					_ParseLoop:
.1cc1	20 57 1a	jsr $1a57			jsr 	LookNext 					; send subsequent
.1cc4	20 85 24	jsr $2485			jsr 	FloatEncodeContinue
.1cc7	90 05		bcc $1cce			bcc 	_ParseDone
.1cc9	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume it
.1ccc	80 f3		bra $1cc1			bra 	_ParseLoop
.1cce					_ParseDone:
.1cce	b5 30		lda $30,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1cd0	29 80		and #$80			and 	#$80
.1cd2	15 6c		ora $6c,x			ora 	NSExponent,x 				; 16 bit int check
.1cd4	15 54		ora $54,x			ora 	NSMantissa2,x
.1cd6	15 60		ora $60,x			ora 	NSMantissa3,x
.1cd8	18		clc				clc
.1cd9	d0 05		bne $1ce0			bne 	_ParseExit 					; exit with CC if need float to compile
.1cdb	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; read into YA.
.1cdd	b4 48		ldy $48,x			ldy		NSMantissa1,x
.1cdf	38		sec				sec
.1ce0					_ParseExit:
.1ce0	60		rts				rts
.1ce1					CommandPRINT:
.1ce1	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace			; what follows ?
.1ce4	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1ce6	f0 1f		beq $1d07			beq 	_CPCheckEnd
.1ce8	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1cea	f0 16		beq $1d02			beq 	_CPTabCheckEnd
.1cec	20 1e 1d	jsr $1d1e			jsr 	_CPAtEnd 					; check for : and EOL
.1cef	b0 22		bcs $1d13			bcs 	_CPExitCR 					; exit with CR
.1cf1	20 13 14	jsr $1413			jsr 	CompileExpressionAt0 		; so it is something to print
.1cf4	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1cf6	29 40		and #$40			and 	#NSSString 					; if string
.1cf8	d0 02		bne $1cfc			bne 	_CPOut
.1cfa	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1cfc					_CPOut:
.1cfc	8a		txa				txa 								; print that thing
.1cfd	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1d00	80 df		bra $1ce1			bra 	CommandPRINT 				; and loop round/
.1d02					_CPTabCheckEnd:
.1d02	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1d04	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1d07					_CPCheckEnd:
.1d07	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume it.
.1d0a	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; what follows ?
.1d0d	20 1e 1d	jsr $1d1e			jsr 	_CPAtEnd 					; reached end
.1d10	90 cf		bcc $1ce1			bcc 	CommandPRINT 				; no, loop back
.1d12	60		rts				rts
.1d13					_CPExitCR:
.1d13	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1d15	20 25 12	jsr $1225			jsr 	PushIntegerA
.1d18	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1d1a	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1d1d	60		rts				rts
.1d1e					_CPAtEnd:
.1d1e	c9 00		cmp #$00			cmp 	#0
.1d20	f0 06		beq $1d28			beq 	_CPIsEnd
.1d22	c9 3a		cmp #$3a			cmp 	#":"
.1d24	f0 02		beq $1d28			beq 	_CPIsEnd
.1d26	18		clc				clc
.1d27	60		rts				rts
.1d28					_CPIsEnd:
.1d28	38		sec				sec
.1d29	60		rts				rts
.1d2a					CommandREAD:
.1d2a	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1d2c	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1d2e					CommandReadInputCommon:
.1d2e	8e 0d 05	stx $050d			stx 	numberPCode
.1d31	8c 0e 05	sty $050e			sty 	stringPCode
.1d34					_CRLoop:
.1d34	20 73 1a	jsr $1a73			jsr 	GetNextNonSpace 			; first char of identifier
.1d37	20 89 1a	jsr $1a89			jsr 	CharIsAlpha 				; check A-Z
.1d3a	90 27		bcc $1d63			bcc 	_CRSyntax
.1d3c	20 b4 1d	jsr $1db4			jsr 	GetReferenceTerm 			; get the variable.
.1d3f	48		pha				pha 								; save type.
.1d40	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1d42	c9 40		cmp #$40			cmp 	#NSSString
.1d44	f0 05		beq $1d4b			beq 	_CRString
.1d46	ad 0d 05	lda $050d			lda 	numberPCode 				; output read/input
.1d49	80 03		bra $1d4e			bra 	_CRHaveType
.1d4b					_CRString:
.1d4b	ad 0e 05	lda $050e			lda 	stringPCode					; output read$/input$
.1d4e					_CRHaveType:
.1d4e	20 fd 10	jsr $10fd			jsr 	WriteCodeByte 				; so we have one typed data item.
.1d51	68		pla				pla 								; restore type
.1d52	38		sec				sec  								; write update code.
.1d53	20 66 1d	jsr $1d66			jsr 	GetSetVariable
.1d56	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; , follows ?
.1d59	c9 2c		cmp #$2c			cmp 	#","
.1d5b	d0 05		bne $1d62			bne 	_CRExit 					; if not, end of READ.
.1d5d	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume comma
.1d60	80 d2		bra $1d34			bra 	_CRLoop 					; keep going
.1d62					_CRExit:
.1d62	60		rts				rts
.1d63					_CRSyntax:
.1d63	4c 5c 1f	jmp $1f5c		jmp	ErrorV_syntax
.050d					numberPCode:
>050d							.fill 	1
.050e					stringPCode:
>050e							.fill 	1
.1d66					GetSetVariable:
.1d66	08		php				php 								; save direction on stack
.1d67	c0 00		cpy #$00			cpy 	#$00
.1d69	30 21		bmi $1d8c			bmi 	_GSVReadWriteSpecial
.1d6b	c9 00		cmp #$00			cmp 	#$00
.1d6d	30 33		bmi $1da2			bmi 	_GSVArray
.1d6f	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1d71	4a		lsr a				lsr 	a 							; divide by 2
.1d72	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1d74	28		plp				plp
.1d75	90 02		bcc $1d79			bcc 	_GSVNotWrite
.1d77	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1d79					_GSVNotWrite:
.1d79	85 2a		sta $2a				sta 	zTemp0
.1d7b	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1d7c	4a		lsr a				lsr 	a
.1d7d	a8		tay				tay
.1d7e	8a		txa				txa
.1d7f	6a		ror a				ror 	a
.1d80	aa		tax				tax
.1d81	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1d82	05 2a		ora $2a				ora 	zTemp0 						; which is the first byte of the opcode
.1d84	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1d87	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1d88	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1d8b	60		rts				rts
.1d8c					_GSVReadWriteSpecial:
.1d8c	28		plp				plp
.1d8d	b0 10		bcs $1d9f			bcs 	_GSVSyntax
.1d8f	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1d91	f0 06		beq $1d99			beq 	_GSVRWString
.1d93	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1d95	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1d98	60		rts				rts
.1d99					_GSVRWString:
.1d99	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1d9b	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1d9e	60		rts				rts
.1d9f					_GSVSyntax:
.1d9f	4c 5c 1f	jmp $1f5c		jmp	ErrorV_syntax
.1da2					_GSVArray:
.1da2	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1da4	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1da5	4a		lsr a				lsr 	a
.1da6	4a		lsr a				lsr 	a
.1da7	4a		lsr a				lsr 	a
.1da8	4a		lsr a				lsr 	a
.1da9	28		plp				plp 								; if writing array then set bit 2.
.1daa	90 02		bcc $1dae			bcc 	_GSVANotWrite
.1dac	09 04		ora #$04			ora 	#4
.1dae					_GSVANotWrite:
.1dae	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1db0	20 fd 10	jsr $10fd			jsr 	WriteCodeByte 				; and write it out
.1db3	60		rts				rts
.1db4					GetReferenceTerm:
.1db4	20 d8 1a	jsr $1ad8			jsr 	ExtractVariableName 		; get name & type info
.1db7	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1db9	30 10		bmi $1dcb			bmi 	_GRTArray
.1dbb	da		phx				phx 								; save type on stack
.1dbc	20 cd 14	jsr $14cd			jsr 	FindVariable 				; find it
.1dbf	b0 06		bcs $1dc7			bcs 	_GRTNoCreate 				; create if required.
.1dc1	20 57 12	jsr $1257			jsr 	CreateVariableRecord 		; create a variable.
.1dc4	20 ac 12	jsr $12ac			jsr 	AllocateBytesForType 		; allocate memory for it
.1dc7					_GRTNoCreate:
.1dc7	68		pla				pla 								; get type back, strip out type information.
.1dc8	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1dca	60		rts				rts
.1dcb					_GRTArray:
.1dcb	da		phx				phx 								; save type information
.1dcc	20 cd 14	jsr $14cd			jsr 	FindVariable 				; read its data, the base address in YX
.1dcf	90 18		bcc $1de9			bcc 	_GRTUndeclared 				; undeclared array.
.1dd1	da		phx				phx 								; save base address
.1dd2	5a		phy				phy
.1dd3	20 a3 13	jsr $13a3			jsr 	OutputIndexGroup 			; create an index group and generate them
.1dd6	7a		ply				ply 								; get the array base address into YX
.1dd7	fa		plx				plx
.1dd8	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1dda	18		clc				clc
.1ddb	20 66 1d	jsr $1d66			jsr 	GetSetVariable 				; load the address of the array structure.
.1dde	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1de0	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1de3	68		pla				pla 								; and the type data into A
.1de4	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1de6	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1de8	60		rts				rts
.1de9					_GRTUndeclared:
.1de9	4c 13 20	jmp $2013		jmp	ErrorV_undeclared
.1dec					CommandREM:
.1dec	20 57 1a	jsr $1a57			jsr 	LookNext
.1def	f0 05		beq $1df6			beq 	_CRExit
.1df1	20 68 1a	jsr $1a68			jsr 	GetNext
.1df4	80 f6		bra $1dec			bra 	CommandREM
.1df6					_CRExit:
.1df6	60		rts				rts
.1df7					STRReset:
.1df7	ad 07 05	lda $0507			lda	 	compilerStartHigh 			; set up the two table pointers
.1dfa	8d 12 05	sta $0512			sta 	variableListEnd+1
.1dfd	9c 11 05	stz $0511			stz 	variableListEnd
.1e00	ad 08 05	lda $0508			lda 	compilerEndHigh
.1e03	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1e06	9c 0f 05	stz $050f			stz 	lineNumberTable
.1e09	ad 11 05	lda $0511			lda 	variableListEnd
.1e0c	85 2b		sta $2b				sta 	zTemp0+1
.1e0e	64 2a		stz $2a				stz 	zTemp0
.1e10	a9 00		lda #$00			lda 	#0
.1e12	92 2a		sta ($2a)			sta 	(zTemp0)
.1e14	a9 00		lda #$00			lda 	#((0) & $FF)
.1e16	8d 13 05	sta $0513			sta 	0+freeVariableMemory
.1e19	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1e1b	8d 14 05	sta $0514			sta 	1+freeVariableMemory
.1e1e	60		rts				rts
.050f					lineNumberTable:
>050f							.fill 	2
.0511					variableListEnd:
>0511							.fill 	2
.0513					freeVariableMemory:
>0513							.fill 	2
.1e1f					CompileTerm:
.1e1f	20 73 1a	jsr $1a73			jsr 	GetNextNonSpace 			; get first non space character.
.1e22	30 72		bmi $1e96			bmi 	_CTUnaryFunctions
.1e24	20 7d 1a	jsr $1a7d			jsr 	CharIsDigit 				; found a number
.1e27	b0 3a		bcs $1e63			bcs 	_CTDigit
.1e29	c9 2e		cmp #$2e			cmp 	#"."
.1e2b	f0 36		beq $1e63			beq 	_CTDigit
.1e2d	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1e2f	f0 43		beq $1e74			beq 	_CTString
.1e31	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1e33	f0 28		beq $1e5d			beq 	_CTOtherBase
.1e35	c9 24		cmp #$24			cmp 	#"$"
.1e37	f0 24		beq $1e5d			beq 	_CTOtherBase
.1e39	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1e3b	f0 17		beq $1e54			beq 	_CTBrackets
.1e3d	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1e3f	90 10		bcc $1e51			bcc 	_CTSyntax
.1e41	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1e43	b0 0c		bcs $1e51			bcs 	_CTSyntax
.1e45	20 b4 1d	jsr $1db4			jsr 	GetReferenceTerm 			; figure out what it is.
.1e48	48		pha				pha 								; save type on stack
.1e49	18		clc				clc 								; read it
.1e4a	20 66 1d	jsr $1d66			jsr 	GetSetVariable
.1e4d	68		pla				pla
.1e4e	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1e50	60		rts				rts
.1e51					_CTSyntax:
.1e51	4c 5c 1f	jmp $1f5c		jmp	ErrorV_syntax
.1e54					_CTBrackets:
.1e54	20 13 14	jsr $1413			jsr 	CompileExpressionAt0
.1e57	48		pha				pha
.1e58	20 5f 11	jsr $115f			jsr 	CheckNextRParen
.1e5b	68		pla				pla
.1e5c	60		rts				rts
.1e5d					_CTOtherBase:
.1e5d	20 ab 10	jsr $10ab			jsr 	InlineNonDecimal 			; non decimal constant handler
.1e60	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e62	60		rts				rts
.1e63					_CTDigit:
.1e63	20 bc 1c	jsr $1cbc			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1e66	90 06		bcc $1e6e			bcc	 	_CTFloat 					; have a float or long int.
.1e68	20 12 12	jsr $1212			jsr 	PushIntegerYA 				; code to push on stack
.1e6b	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e6d	60		rts				rts
.1e6e					_CTFloat:
.1e6e	20 34 12	jsr $1234			jsr 	PushFloatCommand			; code to push float
.1e71	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1e73	60		rts				rts
.1e74					_CTString:
.1e74	20 34 11	jsr $1134			jsr 	BufferClear 				; copy it to the buffer
.1e77					_CTStringLoop:
.1e77	20 57 1a	jsr $1a57			jsr 	LookNext 					; reached EOL/EOS
.1e7a	f0 d5		beq $1e51			beq 	_CTSyntax
.1e7c	c9 22		cmp #$22			cmp 	#'"'
.1e7e	f0 08		beq $1e88			beq 	_CTStringDone
.1e80	20 38 11	jsr $1138			jsr 	BufferWrite 				; write and consume
.1e83	20 68 1a	jsr $1a68			jsr 	GetNext
.1e86	80 ef		bra $1e77			bra 	_CTStringLoop
.1e88					_CTStringDone:
.1e88	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume closing quote.
.1e8b	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1e8d	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1e90	20 44 11	jsr $1144			jsr 	BufferOutput
.1e93	a9 40		lda #$40			lda 	#NSSString 					; string type
.1e95	60		rts				rts
.1e96					_CTUnaryFunctions:
.1e96	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1e98	f0 0a		beq $1ea4			beq 	_CTNegation
.1e9a	a2 ff		ldx #$ff			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1e9c	a0 17		ldy #$17			ldy 	#UnaryTables >> 8
.1e9e	20 f9 18	jsr $18f9			jsr 	GeneratorProcess
.1ea1	90 ae		bcc $1e51			bcc		_CTSyntax
.1ea3	60		rts				rts
.1ea4					_CTNegation:
.1ea4	20 1f 1e	jsr $1e1f			jsr 	CompileTerm 				; compile a term.
.1ea7	48		pha				pha
.1ea8	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1eaa	c9 00		cmp #$00			cmp 	#NSSIFloat
.1eac	d0 07		bne $1eb5			bne 	_CTType 					; error
.1eae	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1eb0	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1eb3	68		pla				pla 								; return original type.
.1eb4	60		rts				rts
.1eb5					_CTType:
.1eb5	4c 6c 1f	jmp $1f6c		jmp	ErrorV_type
.1eb8					CommandWAIT:
.1eb8	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace
.1ebb	c9 2c		cmp #$2c			cmp 	#","
.1ebd	f0 10		beq $1ecf			beq 	_CWThirdParameter
.1ebf	a9 00		lda #$00			lda 	#0
.1ec1	20 25 12	jsr $1225			jsr 	PushIntegerA
.1ec4					_CWExit:
.1ec4	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1ec6	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1ec9	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1ecb	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1ece	60		rts				rts
.1ecf					_CWThirdParameter:
.1ecf	20 68 1a	jsr $1a68			jsr 	GetNext
.1ed2	20 15 14	jsr $1415			jsr 	CompileExpressionAtA
.1ed5	29 40		and #$40			and 	#NSSTypeMask
.1ed7	c9 00		cmp #$00			cmp 	#NSSIFloat
.1ed9	f0 e9		beq $1ec4			beq 	_CWExit
.1edb	4c 6c 1f	jmp $1f6c		jmp	ErrorV_type
.1ede					CommandCMD:
.1ede	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.1ee0	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1ee3	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; followed by a , ?
.1ee6	c9 2c		cmp #$2c			cmp 	#","
.1ee8	d0 06		bne $1ef0			bne 	_CCMDExit
.1eea	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume comma.
.1eed	20 e1 1c	jsr $1ce1			jsr 	CommandPRINT 				; do the print code
.1ef0					_CCMDExit:
.1ef0	60		rts				rts
.1ef1					CommandOPEN:
.1ef1	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; followed by a , ?
.1ef4	c9 2c		cmp #$2c			cmp 	#","
.1ef6	d0 15		bne $1f0d			bne 	_COTwoDefaults
.1ef8	20 68 1a	jsr $1a68			jsr 	GetNext 					; consume comma
.1efb	20 13 14	jsr $1413			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1efe	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1f00	f0 1e		beq $1f20			beq 	_COThreeIntegers
.1f02	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1f04	20 25 12	jsr $1225			jsr 	PushIntegerA
.1f07	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1f09	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1f0c	60		rts				rts
.1f0d					_COTwoDefaults:
.1f0d	a9 00		lda #$00			lda 	#0
.1f0f	20 25 12	jsr $1225			jsr 	PushIntegerA
.1f12					_COCompileNullString:
.1f12	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1f14	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1f17	a9 00		lda #$00			lda 	#0
.1f19	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1f1c	20 fd 10	jsr $10fd			jsr 	WriteCodeByte
.1f1f	60		rts				rts
.1f20					_COThreeIntegers:
.1f20	20 5a 1a	jsr $1a5a			jsr 	LookNextNonSpace 			; is there a ,
.1f23	c9 2c		cmp #$2c			cmp 	#","
.1f25	d0 eb		bne $1f12			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1f27	20 68 1a	jsr $1a68			jsr 	GetNext
.1f2a	20 13 14	jsr $1413			jsr 	CompileExpressionAt0 		; should be a filename
.1f2d	29 40		and #$40			and 	#NSSString
.1f2f	f0 01		beq $1f32			beq 	_COType
.1f31	60		rts				rts
.1f32					_COType:
.1f32	4c 6c 1f	jmp $1f6c		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					objPtr:
>0028							.fill 	2
.002a					zTemp0:
>002a							.fill 	2
.002c					zTemp1:
>002c							.fill 	2
.002e					zTemp2:
>002e							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1f35					SetErrorHandler:
.1f35	8c 16 05	sty $0516			sty 	ErrorHandlerVector+1
.1f38	8e 15 05	stx $0515			stx 	ErrorHandlerVector
.1f3b	60		rts				rts
.1f3c					CallErrorHandler:
.1f3c	6c 15 05	jmp ($0515)			jmp 	(ErrorHandlerVector)
.0515					ErrorHandlerVector:
>0515							.fill 	2
.1f3f					ErrorV_range:
.1f3f	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>1f42	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f4a	41 4e 47 45 00
.1f4f					ErrorV_value:
.1f4f	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>1f52	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f5a	45 00
.1f5c					ErrorV_syntax:
.1f5c	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>1f5f	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f67	52 52 4f 52 00
.1f6c					ErrorV_type:
.1f6c	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>1f6f	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f77	4d 41 54 43 48 00
.1f7d					ErrorV_unimplemented:
.1f7d	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>1f80	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f88	45 4d 45 4e 54 45 44 00
.1f90					ErrorV_assert:
.1f90	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>1f93	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f9b	41 49 4c 00
.1f9f					ErrorV_line:
.1f9f	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>1fa2	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1faa	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1fb6					ErrorV_internal:
.1fb6	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>1fb9	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1fc1	20 45 52 52 4f 52 00
.1fc8					ErrorV_divzero:
.1fc8	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>1fcb	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fd3	59 20 5a 45 52 4f 00
.1fda					ErrorV_structure:
.1fda	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>1fdd	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fe5	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1ff1					ErrorV_stop:
.1ff1	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>1ff4	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1ffc	53 54 4f 50 50 45 44 00
.2004					ErrorV_data:
.2004	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>2007	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>200f	41 54 41 00
.2013					ErrorV_undeclared:
.2013	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>2016	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>201e	41 52 52 41 59 00
.2024					ErrorV_redefine:
.2024	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>2027	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>202f	44 45 46 49 4e 45 44 00
.2037					ErrorV_index:
.2037	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>203a	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2042	59 20 49 4e 44 45 58 00
.204a					ErrorV_memory:
.204a	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>204d	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2055	45 4d 4f 52 59 00
.205b					ErrorV_channel:
.205b	20 3c 1f	jsr $1f3c		jsr	CallErrorHandler
>205e	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2066	54 50 55 54 20 45 52 52 4f 52 00
.2071					MoveObjectForward:
.2071	b2 28		lda ($28)			lda 	(objPtr) 					; get next
.2073	c9 ff		cmp #$ff			cmp 	#$FF
.2075	f0 36		beq $20ad			beq 	_MOFEnd
.2077	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.2079	90 24		bcc $209f			bcc 	_MOFAdvance1 				; forward 1
.207b	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.207d	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.207f	90 20		bcc $20a1			bcc 	_MOFAdvanceY
.2081	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2083	90 1a		bcc $209f			bcc 	_MOFAdvance1 				; forward 1
.2085	a8		tay				tay 								; read the size.
.2086	b9 eb 1f	lda $1feb,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.2089	a8		tay				tay
.208a	c8		iny				iny 								; add 1 for the system token.
.208b	d0 14		bne $20a1			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.208d	a0 01		ldy #$01			ldy 	#1 							; get length byte
.208f	b1 28		lda ($28),y			lda 	(objPtr),y
.2091	a8		tay				tay 								; into Y.
.2092	18		clc				clc
.2093	a5 28		lda $28				lda 	objPtr						; add 2 to the object pointer
.2095	69 02		adc #$02			adc 	#2
.2097	85 28		sta $28				sta 	objPtr
.2099	90 02		bcc $209d			bcc 	_MOFNoCarry1
.209b	e6 29		inc $29				inc 	objPtr+1
.209d					_MOFNoCarry1:
.209d	80 02		bra $20a1			bra 	_MOFAdvanceY
.209f					_MOFAdvance1:
.209f	a0 01		ldy #$01			ldy 	#1
.20a1					_MOFAdvanceY:
.20a1	98		tya				tya 								; add Y to objPtr
.20a2	18		clc				clc
.20a3	65 28		adc $28				adc 	objPtr
.20a5	85 28		sta $28				sta 	objPtr
.20a7	90 02		bcc $20ab			bcc 	_MOFNoCarry2
.20a9	e6 29		inc $29				inc 	objPtr+1
.20ab					_MOFNoCarry2:
.20ab	18		clc				clc 								; not completed.
.20ac	60		rts				rts
.20ad					_MOFEnd:
.20ad	e6 28		inc $28				inc 	objPtr
.20af	d0 02		bne $20b3			bne 	_MOFENoCarry
.20b1	e6 29		inc $29				inc 	objPtr+1
.20b3					_MOFENoCarry:
.20b3	38		sec				sec
.20b4	60		rts				rts
.20b5					MOFSizeTable:
>20b5	01					.byte	1         	; $ca .shift
>20b6	01					.byte	1         	; $cb .byte
>20b7	02					.byte	2         	; $cc .word
>20b8	05					.byte	5         	; $cd .float
>20b9	ff					.byte	255       	; $ce .string
>20ba	ff					.byte	255       	; $cf .data
>20bb	02					.byte	2         	; $d0 .goto
>20bc	02					.byte	2         	; $d1 .gosub
>20bd	02					.byte	2         	; $d2 .goto.z
>20be	02					.byte	2         	; $d3 .goto.nz
>20bf	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0030					NSStatus:
>0030							.fill 	MathStackSize
.003c					NSMantissa0:
>003c							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0048					NSMantissa1:
>0048							.fill 	MathStackSize
.0054					NSMantissa2:
>0054							.fill 	MathStackSize
.0060					NSMantissa3:
>0060							.fill 	MathStackSize
.006c					NSExponent:
>006c							.fill 	MathStackSize
.0517					numberBuffer:
>0517							.fill 	34
.20c0					FloatSubtract:
.20c0	b5 30		lda $30,x			lda 	NSStatus,x 					; negate top of stack
.20c2	49 80		eor #$80			eor 	#$80
.20c4	95 30		sta $30,x			sta 	NSStatus,x					; and fall through.
.20c6					FloatAdd:
.20c6	ca		dex				dex
.20c7	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised.
.20c9	15 6d		ora $6d,x			ora 	NSExponent+1,x
.20cb	15 60		ora $60,x			ora 	NSMantissa3,x
.20cd	15 61		ora $61,x			ora 	NSMantissa3+1,x
.20cf	d0 04		bne $20d5			bne 	_FAUseFloat
.20d1	20 62 24	jsr $2462			jsr 	FloatInt32Add 				; use the int32 one.
.20d4	60		rts				rts
.20d5					_FAUseFloat:
.20d5	20 f7 23	jsr $23f7			jsr 	FloatNormalise 				; normalise S[X]
.20d8	f0 51		beq $212b			beq 	_FAReturn1
.20da	e8		inx				inx 								; normalise S[X+1]
.20db	20 f7 23	jsr $23f7			jsr 	FloatNormalise
.20de	ca		dex				dex
.20df	c9 00		cmp #$00			cmp 	#0
.20e1	f0 60		beq $2143			beq 	_FAExit 					; if so, just return A
.20e3	b5 6c		lda $6c,x			lda 	NSExponent,x 				; are the exponents the same ?
.20e5	d5 6d		cmp $6d,x			cmp 	NSExponent+1,x
.20e7	f0 18		beq $2101			beq 	_FAExponentsEqual
.20e9	b5 6c		lda $6c,x			lda 	NSExponent,x 				; work out the larger exponent
.20eb	a8		tay				tay
.20ec	38		sec				sec 								; do a signed comparison of the exponents.
.20ed	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.20ef	50 02		bvc $20f3			bvc 	_FANoSignedChange
.20f1	49 80		eor #$80			eor 	#$80
.20f3					_FANoSignedChange:
.20f3	29 80		and #$80			and 	#$80
.20f5	10 02		bpl $20f9			bpl 	_FAHaveMax
.20f7	b4 6d		ldy $6d,x			ldy 	NSExponent+1,x
.20f9					_FAHaveMax:
.20f9	20 44 21	jsr $2144			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20fc	e8		inx				inx
.20fd	20 44 21	jsr $2144			jsr 	_FAShiftToExponent
.2100	ca		dex				dex
.2101					_FAExponentsEqual:
.2101	b5 30		lda $30,x			lda 	NSStatus,x 					; are the signs the same
.2103	55 31		eor $31,x			eor 	NSStatus+1,x
.2105	30 0e		bmi $2115			bmi 	_FADifferentSigns
.2107	20 2e 24	jsr $242e			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.210a	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.210c	10 35		bpl $2143			bpl 	_FAExit 					; if no, we are done.
.210e	20 bb 26	jsr $26bb			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.2111	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump the exponent and exit
.2113	80 2e		bra $2143			bra 	_FAExit
.2115					_FADifferentSigns:
.2115	20 48 24	jsr $2448			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.2118	b5 60		lda $60,x			lda 	NSMantissa3,x 				; is the result negative ?
.211a	10 06		bpl $2122			bpl 	_FACheckZero 				; if no, check for -0
.211c	20 64 26	jsr $2664			jsr 	FloatNegate 					; netate result
.211f	20 6b 26	jsr $266b			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.2122					_FACheckZero:
.2122	20 c4 26	jsr $26c4			jsr 	FloatIsZero	 				; check for -0
.2125	d0 1c		bne $2143			bne 	_FAExit
.2127	74 30		stz $30,x			stz 	NSStatus,x
.2129	80 18		bra $2143			bra 	_FAExit
.212b					_FAReturn1:
.212b	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.212d	95 3c		sta $3c,x			sta 	NSMantissa0,x
.212f	b5 49		lda $49,x			lda 	NSMantissa1+1,x
.2131	95 48		sta $48,x			sta 	NSMantissa1,x
.2133	b5 55		lda $55,x			lda 	NSMantissa2+1,x
.2135	95 54		sta $54,x			sta 	NSMantissa2,x
.2137	b5 61		lda $61,x			lda 	NSMantissa3+1,x
.2139	95 60		sta $60,x			sta 	NSMantissa3,x
.213b	b5 6d		lda $6d,x			lda 	NSExponent+1,x
.213d	95 6c		sta $6c,x			sta 	NSExponent,x
.213f	b5 31		lda $31,x			lda 	NSStatus+1,x
.2141	95 30		sta $30,x			sta 	NSStatus,x
.2143					_FAExit:
.2143	60		rts				rts
.2144					_FAShiftToExponent:
.2144					_FAShiftToExponent2:
.2144	98		tya				tya 								; compare Y to exponent
.2145	d5 6c		cmp $6c,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2147	f0 07		beq $2150			beq 	_FASEExit 					; exit if so.
.2149	20 bb 26	jsr $26bb			jsr 	FloatShiftRight	 			; shift the mantissa right
.214c	f6 6c		inc $6c,x			inc 	NSExponent,x 				; increment exponent
.214e	80 f4		bra $2144			bra 	_FAShiftToExponent2
.2150					_FASEExit:
.2150	60		rts				rts
.2151					CompareEqual:
.2151	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2153	d0 09		bne $215e			bne 	ReturnFalse
.2155					ReturnTrue:
.2155	a9 01		lda #$01			lda 	#1
.2157	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2159	a9 80		lda #$80			lda 	#$80
.215b	95 30		sta $30,x			sta 	NSStatus,x
.215d	60		rts				rts
.215e					ReturnFalse:
.215e	74 3c		stz $3c,x			stz 	NSMantissa0,x
.2160	60		rts				rts
.2161					CompareNotEqual:
.2161	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2163	d0 f0		bne $2155			bne 	ReturnTrue
.2165	80 f7		bra $215e			bra 	ReturnFalse
.2167					CompareLess:
.2167	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2169	c9 ff		cmp #$ff			cmp 	#$FF
.216b	f0 e8		beq $2155			beq 	ReturnTrue
.216d	80 ef		bra $215e			bra 	ReturnFalse
.216f					CompareGreater:
.216f	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2171	c9 01		cmp #$01			cmp 	#$01
.2173	f0 e0		beq $2155			beq 	ReturnTrue
.2175	80 e7		bra $215e			bra 	ReturnFalse
.2177					CompareLessEqual:
.2177	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2179	c9 01		cmp #$01			cmp 	#$01
.217b	d0 d8		bne $2155			bne 	ReturnTrue
.217d	80 df		bra $215e			bra 	ReturnFalse
.217f					CompareGreaterEqual:
.217f	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2181	c9 ff		cmp #$ff			cmp 	#$FF
.2183	d0 d0		bne $2155			bne 	ReturnTrue
.2185	80 d7		bra $215e			bra 	ReturnFalse
.2187					FloatCompare:
.2187	b5 6c		lda $6c,x			lda 	NSExponent,x 				; float comparison.
.2189	15 6b		ora $6b,x			ora 	NSExponent-1,x 				; integer if both integer.
.218b	48		pha				pha
.218c	20 c0 20	jsr $20c0			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.218f	68		pla				pla
.2190	d0 0c		bne $219e			bne 	_FCCompareFloat
.2192	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2194	15 48		ora $48,x			ora 	NSMantissa1,x
.2196	15 54		ora $54,x			ora 	NSMantissa2,x
.2198	15 60		ora $60,x			ora 	NSMantissa3,x
.219a	f0 14		beq $21b0			beq 	_FCExit 					; if zero, return zero
.219c	80 0a		bra $21a8			bra 	_FCSign
.219e					_FCCompareFloat:
.219e	b5 48		lda $48,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.21a0	29 f0		and #$f0			and 	#$F0
.21a2	15 54		ora $54,x			ora 	NSMantissa2,x
.21a4	15 60		ora $60,x			ora 	NSMantissa3,x
.21a6	f0 08		beq $21b0			beq 	_FCExit 					; zero, so approximately identical
.21a8					_FCSign:
.21a8	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.21aa	34 30		bit $30,x			bit 	NSStatus,x
.21ac	10 02		bpl $21b0			bpl 	_FCExit
.21ae					_FCNegative:
.21ae	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.21b0					_FCExit:
.21b0	20 a4 26	jsr $26a4			jsr 	FloatSetByte 				; set the result 255,0,1
.21b3	60		rts				rts
.21b4					FloatScalarTable:
>21b4	66 66 66 66				.dword $66666666 ; 0.1
>21b8	de					.byte $de
>21b9	1f 85 eb 51				.dword $51eb851f ; 0.01
>21bd	db					.byte $db
>21be	4c 37 89 41				.dword $4189374c ; 0.001
>21c2	d8					.byte $d8
>21c3	ac 8b db 68				.dword $68db8bac ; 0.0001
>21c7	d4					.byte $d4
>21c8	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>21cc	d1					.byte $d1
>21cd	83 de 1b 43				.dword $431bde83 ; 1e-06
>21d1	ce					.byte $ce
>21d2	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21d6	ca					.byte $ca
>21d7	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21db	c7					.byte $c7
>21dc	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21e0	c4					.byte $c4
>21e1	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21e5	c0					.byte $c0
>21e6	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21ea	bd					.byte $bd
.21eb					FloatDivide:
.21eb	48		pha				pha
.21ec	20 f7 23	jsr $23f7			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21ef	ca		dex				dex
.21f0	c9 00		cmp #$00			cmp 	#0
.21f2	f0 1e		beq $2212			beq 	_FDZero
.21f4	20 f7 23	jsr $23f7			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21f7	f0 16		beq $220f			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21f9	20 5a 22	jsr $225a			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21fc	20 27 22	jsr $2227			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21ff	20 f7 23	jsr $23f7			jsr		FloatNormalise 				; renormalise
.2202	20 ed 23	jsr $23ed			jsr 	FloatCalculateSign 			; calculate result sign
.2205	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent
.2207	38		sec				sec
.2208	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.220a	38		sec				sec
.220b	e9 1e		sbc #$1e			sbc 	#30
.220d	95 6c		sta $6c,x			sta 	NSExponent,x
.220f					_FDExit:
.220f	68		pla				pla
.2210	18		clc				clc
.2211	60		rts				rts
.2212					_FDZero:
.2212	68		pla				pla
.2213	38		sec				sec
.2214	60		rts				rts
.2215					DivideInt32:
.2215	20 dd 22	jsr $22dd			jsr 	FloatIntegerPart 			; make both integers
.2218	ca		dex				dex
.2219	20 dd 22	jsr $22dd			jsr 	FloatIntegerPart
.221c	20 38 22	jsr $2238			jsr 	Int32Divide 				; divide
.221f	20 27 22	jsr $2227			jsr 	NSMCopyPlusTwoToZero 		; copy result
.2222	20 ed 23	jsr $23ed			jsr 	FloatCalculateSign 			; calculate result sign
.2225	18		clc				clc
.2226	60		rts				rts
.2227					NSMCopyPlusTwoToZero:
.2227	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.2229	95 3c		sta $3c,x			sta 	NSMantissa0,x
.222b	b5 4a		lda $4a,x			lda 	NSMantissa1+2,x
.222d	95 48		sta $48,x			sta 	NSMantissa1,x
.222f	b5 56		lda $56,x			lda 	NSMantissa2+2,x
.2231	95 54		sta $54,x			sta 	NSMantissa2,x
.2233	b5 62		lda $62,x			lda 	NSMantissa3+2,x
.2235	95 60		sta $60,x			sta 	NSMantissa3,x
.2237	60		rts				rts
.2238					Int32Divide:
.2238	48		pha				pha 								; save AXY
.2239	5a		phy				phy
.223a	20 85 26	jsr $2685			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.223d	20 9e 26	jsr $269e			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2240	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2242					_I32DivideLoop:
.2242	e8		inx				inx
.2243	e8		inx				inx
.2244	20 b1 26	jsr $26b1			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2247	ca		dex				dex
.2248	ca		dex				dex
.2249	20 b2 26	jsr $26b2			jsr 	FloatRotateLeft
.224c	20 78 22	jsr $2278			jsr 	FloatDivideCheck 			; check if subtract possible
.224f	90 02		bcc $2253			bcc 	_I32DivideNoCarryIn
.2251	f6 3e		inc $3e,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2253					_I32DivideNoCarryIn:
.2253	88		dey				dey 								; loop round till division completed.
.2254	d0 ec		bne $2242			bne 	_I32DivideLoop
.2256	7a		ply				ply 								; restore AXY and exit
.2257	68		pla				pla
.2258	18		clc				clc
.2259	60		rts				rts
.225a					Int32ShiftDivide:
.225a	48		pha				pha 								; save AY
.225b	5a		phy				phy
.225c	e8		inx				inx 								; clear S[X+2]
.225d	e8		inx				inx
.225e	20 a2 26	jsr $26a2			jsr 	FloatSetZero
.2261	ca		dex				dex
.2262	ca		dex				dex
.2263	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2265					_I32SDLoop:
.2265	20 78 22	jsr $2278			jsr 	FloatDivideCheck 			; check if subtract possible
.2268	e8		inx				inx
.2269	e8		inx				inx
.226a	20 b2 26	jsr $26b2			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.226d	ca		dex				dex
.226e	ca		dex				dex
.226f	20 b2 26	jsr $26b2			jsr 	FloatRotateLeft
.2272	88		dey				dey 	 							; do 31 times
.2273	d0 f0		bne $2265			bne 	_I32SDLoop
.2275	7a		ply				ply 								; restore AY and exit
.2276	68		pla				pla
.2277	60		rts				rts
.2278					FloatDivideCheck:
.2278	20 48 24	jsr $2448			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.227b	b0 04		bcs $2281			bcs 	_DCSExit 					; if carry set, then could do, exit
.227d	20 2e 24	jsr $242e			jsr 	FloatAddTopTwoStack 		; add it back in
.2280	18		clc				clc 								; and return False
.2281					_DCSExit:
.2281	60		rts				rts
.2282					FloatFractionalPart:
.2282	5a		phy				phy
.2283	b5 30		lda $30,x			lda 	NSStatus,x 					; take absolute value
.2285	29 7f		and #$7f			and 	#$7F
.2287	95 30		sta $30,x			sta 	NSStatus,x
.2289	20 f7 23	jsr $23f7			jsr 	FloatNormalise
.228c	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.228e	38		sec				sec
.228f	e9 e0		sbc #$e0			sbc 	#$E0
.2291	90 29		bcc $22bc			bcc 	_FFPExit 					; already fractional
.2293	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2295	b0 22		bcs $22b9			bcs 	_FFPZero
.2297	a8		tay				tay 								; put count to do in Y
.2298	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do each in turn.
.229a	20 c1 22	jsr $22c1			jsr 	_FFPPartial
.229d	95 60		sta $60,x			sta 	NSMantissa3,x
.229f	b5 54		lda $54,x			lda 	NSMantissa2,x
.22a1	20 c1 22	jsr $22c1			jsr 	_FFPPartial
.22a4	95 54		sta $54,x			sta 	NSMantissa2,x
.22a6	b5 48		lda $48,x			lda 	NSMantissa1,x
.22a8	20 c1 22	jsr $22c1			jsr 	_FFPPartial
.22ab	95 48		sta $48,x			sta 	NSMantissa1,x
.22ad	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.22af	20 c1 22	jsr $22c1			jsr 	_FFPPartial
.22b2	95 3c		sta $3c,x			sta 	NSMantissa0,x
.22b4	20 c4 26	jsr $26c4			jsr 	FloatIsZero 					; zeroed check.
.22b7	d0 03		bne $22bc			bne 	_FFPExit
.22b9					_FFPZero:
.22b9	20 a2 26	jsr $26a2			jsr 	FloatSetZero
.22bc					_FFPExit:
.22bc	20 f7 23	jsr $23f7			jsr 	FloatNormalise
.22bf	7a		ply				ply
.22c0	60		rts				rts
.22c1					_FFPPartial:
.22c1	c0 00		cpy #$00			cpy 	#0 							; no more to do
.22c3	f0 17		beq $22dc			beq 	_FFFPPExit
.22c5	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.22c7	b0 0c		bcs $22d5			bcs 	_FFFPPWholeByte
.22c9	5a		phy				phy
.22ca					_FFFPPLeft:
.22ca	0a		asl a				asl 	a
.22cb	88		dey				dey
.22cc	d0 fc		bne $22ca			bne 	_FFFPPLeft
.22ce	7a		ply				ply
.22cf					_FFFPPRight:
.22cf	4a		lsr a				lsr 	a
.22d0	88		dey				dey
.22d1	d0 fc		bne $22cf			bne 	_FFFPPRight
.22d3	80 07		bra $22dc			bra 	_FFFPPExit
.22d5					_FFFPPWholeByte:
.22d5	98		tya				tya 								; subtract 8 from count
.22d6	38		sec				sec
.22d7	e9 08		sbc #$08			sbc 	#8
.22d9	a8		tay				tay
.22da	a9 00		lda #$00			lda 	#0 							; and clear all
.22dc					_FFFPPExit:
.22dc	60		rts				rts
.22dd					FloatIntegerPart:
.22dd	48		pha				pha
.22de	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.22e0	f0 1d		beq $22ff			beq 	_FIPExit 					; if so do nothing
.22e2	20 c4 26	jsr $26c4			jsr 	FloatIsZero 				; is it zero ?
.22e5	f0 15		beq $22fc			beq 	_FIPZero 					; if so return zero.
.22e7	20 f7 23	jsr $23f7			jsr 	FloatNormalise 				; normalise
.22ea	f0 10		beq $22fc			beq 	_FIPZero 					; normalised to zero, exit zero
.22ec					_FIPShift:
.22ec	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22ee	10 07		bpl $22f7			bpl 	_FIPCheckZero
.22f0	20 bb 26	jsr $26bb			jsr 	FloatShiftRight 			; shift mantissa right
.22f3	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.22f5	80 f5		bra $22ec			bra 	_FIPShift
.22f7					_FIPCheckZero:
.22f7	20 c4 26	jsr $26c4			jsr 	FloatIsZero 				; avoid -0 problem
.22fa	d0 03		bne $22ff			bne 	_FIPExit 					; set to zero if mantissa zero.
.22fc					_FIPZero:
.22fc	20 a2 26	jsr $26a2			jsr 	FloatSetZero
.22ff					_FIPExit:
.22ff	68		pla				pla
.2300	60		rts				rts
.2301					FloatIntegerPartDown:
.2301	48		pha				pha
.2302	5a		phy				phy
.2303	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.2305	f0 36		beq $233d			beq 	_FIPExit 					; if so do nothing
.2307	20 c4 26	jsr $26c4			jsr 	FloatIsZero 				; is it zero ?
.230a	f0 2e		beq $233a			beq 	_FIPZero 					; if so return zero.
.230c	20 f7 23	jsr $23f7			jsr 	FloatNormalise 				; normalise
.230f	f0 29		beq $233a			beq 	_FIPZero 					; normalised to zero, exit zero
.2311	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.2313					_FIPShift:
.2313	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2315	10 0a		bpl $2321			bpl 	_FIPCheckDown
.2317	20 bb 26	jsr $26bb			jsr 	FloatShiftRight 			; shift mantissa right
.231a	90 01		bcc $231d			bcc 	_FIPNoFrac 					; shifted a zero out ?
.231c	c8		iny				iny
.231d					_FIPNoFrac:
.231d	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.231f	80 f2		bra $2313			bra 	_FIPShift
.2321					_FIPCheckDown:
.2321	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.2323	f0 10		beq $2335			beq 	_FIPCheckZero
.2325	34 30		bit $30,x			bit 	NSStatus,x 					; +ve
.2327	10 0c		bpl $2335			bpl 	_FIPCheckZero
.2329	e8		inx				inx 								; -ve so round *down*.
.232a	a9 01		lda #$01			lda 	#1
.232c	20 a4 26	jsr $26a4			jsr 	FloatSetByte
.232f	20 64 26	jsr $2664			jsr 	FloatNegate
.2332	20 c6 20	jsr $20c6			jsr 	FloatAdd
.2335					_FIPCheckZero:
.2335	20 c4 26	jsr $26c4			jsr 	FloatIsZero 				; avoid -0 problem
.2338	d0 03		bne $233d			bne 	_FIPExit 					; set to zero if mantissa zero.
.233a					_FIPZero:
.233a	20 a2 26	jsr $26a2			jsr 	FloatSetZero
.233d					_FIPExit:
.233d	7a		ply				ply
.233e	68		pla				pla
.233f	60		rts				rts
.2340					FloatInt8Multiply:
.2340	5a		phy				phy
.2341	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2343	a8		tay				tay
.2344	74 3c		stz $3c,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2346					_FI8MLoop:
.2346	98		tya				tya 								; shift right shifter right into carry
.2347	4a		lsr a				lsr 	a
.2348	a8		tay				tay
.2349	90 0d		bcc $2358			bcc 	_FI8MNoAdd
.234b	18		clc				clc
.234c	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.234e	75 3d		adc $3d,x			adc 	NSMantissa0+1,x
.2350	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2352	b5 48		lda $48,x			lda 	NSMantissa1,x
.2354	75 49		adc $49,x			adc 	NSMantissa1+1,x
.2356	95 48		sta $48,x			sta 	NSMantissa1,x
.2358					_FI8MNoAdd:
.2358	16 3d		asl $3d,x			asl 	NSMantissa0+1,x 			; shift adder left
.235a	36 49		rol $49,x			rol 	NSMantissa1+1,x
.235c	c0 00		cpy #$00			cpy 	#0
.235e	d0 e6		bne $2346			bne 	_FI8MLoop 					; until right shifter zero.
.2360	7a		ply				ply
.2361	60		rts				rts
.2362					FloatMultiply:
.2362	ca		dex				dex
.2363	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised ?
.2365	15 6d		ora $6d,x			ora 	NSExponent+1,x
.2367	15 60		ora $60,x			ora 	NSMantissa3,x
.2369	15 61		ora $61,x			ora 	NSMantissa3+1,x
.236b	d0 21		bne $238e			bne 	_FMUseFloat
.236d	b5 30		lda $30,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.236f	15 31		ora $31,x			ora 	NSStatus+1,x
.2371	29 80		and #$80			and 	#$80
.2373	15 60		ora $60,x			ora 	NSMantissa3,x
.2375	15 54		ora $54,x			ora 	NSMantissa2,x
.2377	15 48		ora $48,x			ora 	NSMantissa1,x
.2379	15 61		ora $61,x			ora 	NSMantissa3+1,x
.237b	15 55		ora $55,x			ora 	NSMantissa2+1,x
.237d	15 49		ora $49,x			ora 	NSMantissa1+1,x
.237f	d0 04		bne $2385			bne 	_FMInt32
.2381	20 40 23	jsr $2340			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2384	60		rts				rts
.2385					_FMInt32:
.2385	20 af 23	jsr $23af			jsr 	FloatMultiplyShort			; use the int32 one.
.2388	18		clc				clc 								; fix it up if gone out of range
.2389	75 6c		adc $6c,x			adc 	NSExponent,x
.238b	95 6c		sta $6c,x			sta 	NSExponent,x
.238d	60		rts				rts
.238e					_FMUseFloat:
.238e	20 f7 23	jsr $23f7			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2391	f0 18		beq $23ab			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2393	e8		inx				inx
.2394	20 f7 23	jsr $23f7			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2397	ca		dex				dex
.2398	c9 00		cmp #$00			cmp 	#0
.239a	f0 0c		beq $23a8			beq 	_FDSetZero
.239c	20 af 23	jsr $23af			jsr 	FloatMultiplyShort 			; calculate the result.
.239f	75 6c		adc $6c,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.23a1	18		clc				clc
.23a2	75 6d		adc $6d,x			adc 	NSExponent+1,x
.23a4	95 6c		sta $6c,x			sta 	NSExponent,x
.23a6	80 03		bra $23ab			bra 	_FDExit
.23a8					_FDSetZero:
.23a8	20 a2 26	jsr $26a2			jsr 	FloatSetZero 				; return 0
.23ab					_FDExit:
.23ab	20 f7 23	jsr $23f7			jsr 	FloatNormalise 				; normalise the result
.23ae	60		rts				rts
.23af					FloatMultiplyShort:
.23af	5a		phy				phy 								; save Y
.23b0	20 85 26	jsr $2685			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.23b3	20 9e 26	jsr $269e			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.23b6	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.23b8					_I32MLoop:
.23b8	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.23ba	15 4a		ora $4a,x			ora 	NSMantissa1+2,x
.23bc	15 56		ora $56,x			ora 	NSMantissa2+2,x
.23be	15 62		ora $62,x			ora 	NSMantissa3+2,x
.23c0	f0 25		beq $23e7			beq 	_I32MExit 					; exit if zero
.23c2	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.23c4	29 01		and #$01			and 	#1
.23c6	f0 0d		beq $23d5			beq 	_I32MNoAdd
.23c8	20 2e 24	jsr $242e			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.23cb	b5 60		lda $60,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.23cd	10 06		bpl $23d5			bpl 	_I32MNoAdd
.23cf					_I32ShiftRight:
.23cf	20 bb 26	jsr $26bb			jsr 	FloatShiftRight 			; shift S[X] right
.23d2	c8		iny				iny 								; increment shift count
.23d3	80 09		bra $23de			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23d5					_I32MNoAdd:
.23d5	34 61		bit $61,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23d7	70 f6		bvs $23cf			bvs 	_I32ShiftRight 				; instead.
.23d9	e8		inx				inx
.23da	20 b1 26	jsr $26b1			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23dd	ca		dex				dex
.23de					_I32MShiftUpper:
.23de	e8		inx				inx 								; shift S[X+2] right
.23df	e8		inx				inx
.23e0	20 bb 26	jsr $26bb			jsr 	FloatShiftRight
.23e3	ca		dex				dex
.23e4	ca		dex				dex
.23e5	80 d1		bra $23b8			bra 	_I32MLoop 					; try again.
.23e7					_I32MExit:
.23e7	20 ed 23	jsr $23ed			jsr 	FloatCalculateSign
.23ea	98		tya				tya 								; shift in A
.23eb	7a		ply				ply 								; restore Y and exit
.23ec	60		rts				rts
.23ed					FloatCalculateSign:
.23ed	b5 30		lda $30,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23ef	16 30		asl $30,x			asl 	NSStatus,x 					; shift result left
.23f1	55 31		eor $31,x			eor 	NSStatus+1,x
.23f3	0a		asl a				asl 	a 							; shift bit 7 into carry
.23f4	76 30		ror $30,x			ror 	NSStatus,x 					; shift right into status byte.
.23f6	60		rts				rts
.23f7					FloatNormalise:
.23f7	20 c4 26	jsr $26c4			jsr 	FloatIsZero 				; if zero exit
.23fa	d0 07		bne $2403			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23fc	16 30		asl $30,x			asl 	NSStatus,x 					; clear the sign bit.
.23fe	76 30		ror $30,x			ror 	NSStatus,x 					; (no -0)
.2400	a9 00		lda #$00			lda 	#0 							; set Z flag
.2402	60		rts				rts
.2403					_NSNormaliseOptimise:
.2403	b5 60		lda $60,x			lda 	NSMantissa3,x 				; upper byte zero ?
.2405	d0 19		bne $2420			bne 	_NSNormaliseLoop
.2407	b5 54		lda $54,x			lda 	NSMantissa2,x 				; byte normalise
.2409	30 15		bmi $2420			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.240b	95 60		sta $60,x			sta 	NSMantissa3,x
.240d	b5 48		lda $48,x			lda 	NSMantissa1,x
.240f	95 54		sta $54,x			sta 	NSMantissa2,x
.2411	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2413	95 48		sta $48,x			sta 	NSMantissa1,x
.2415	74 3c		stz $3c,x			stz 	NSMantissa0,x
.2417	b5 6c		lda $6c,x			lda 	NSExponent,x
.2419	38		sec				sec
.241a	e9 08		sbc #$08			sbc 	#8
.241c	95 6c		sta $6c,x			sta 	NSExponent,x
.241e	80 e3		bra $2403			bra 	_NSNormaliseOptimise
.2420					_NSNormaliseLoop:
.2420	34 60		bit $60,x			bit 	NSMantissa3,x 				; bit 30 set ?
.2422	70 07		bvs $242b			bvs 	_NSNExit 					; exit if so with Z flag clear
.2424	20 b1 26	jsr $26b1			jsr 	FloatShiftLeft 				; shift mantissa left
.2427	d6 6c		dec $6c,x			dec 	NSExponent,x 				; adjust exponent
.2429	80 f5		bra $2420			bra 	_NSNormaliseLoop
.242b					_NSNExit:
.242b	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.242d	60		rts				rts
.242e					FloatAddTopTwoStack:
.242e	18		clc				clc
.242f	b5 3c		lda $3c,x			lda		NSMantissa0,x
.2431	75 3d		adc $3d,x			adc 		NSMantissa0+1,x
.2433	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2435	b5 48		lda $48,x			lda		NSMantissa1,x
.2437	75 49		adc $49,x			adc 		NSMantissa1+1,x
.2439	95 48		sta $48,x			sta 	NSMantissa1,x
.243b	b5 54		lda $54,x			lda		NSMantissa2,x
.243d	75 55		adc $55,x			adc 		NSMantissa2+1,x
.243f	95 54		sta $54,x			sta 	NSMantissa2,x
.2441	b5 60		lda $60,x			lda		NSMantissa3,x
.2443	75 61		adc $61,x			adc 		NSMantissa3+1,x
.2445	95 60		sta $60,x			sta 	NSMantissa3,x
.2447	60		rts				rts
.2448					FloatSubTopTwoStack:
.2448	38		sec				sec
.2449	b5 3c		lda $3c,x			lda		NSMantissa0,x
.244b	f5 3d		sbc $3d,x			sbc 		NSMantissa0+1,x
.244d	95 3c		sta $3c,x			sta 	NSMantissa0,x
.244f	b5 48		lda $48,x			lda		NSMantissa1,x
.2451	f5 49		sbc $49,x			sbc 		NSMantissa1+1,x
.2453	95 48		sta $48,x			sta 	NSMantissa1,x
.2455	b5 54		lda $54,x			lda		NSMantissa2,x
.2457	f5 55		sbc $55,x			sbc 		NSMantissa2+1,x
.2459	95 54		sta $54,x			sta 	NSMantissa2,x
.245b	b5 60		lda $60,x			lda		NSMantissa3,x
.245d	f5 61		sbc $61,x			sbc 		NSMantissa3+1,x
.245f	95 60		sta $60,x			sta 	NSMantissa3,x
.2461	60		rts				rts
.2462					FloatInt32Add:
.2462	b5 30		lda $30,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2464	55 31		eor $31,x			eor 	NSStatus+1,x
.2466	30 04		bmi $246c			bmi 	_DiffSigns
.2468	20 2e 24	jsr $242e			jsr		FloatAddTopTwoStack
.246b	60		rts				rts
.246c					_DiffSigns:
.246c	20 48 24	jsr $2448			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.246f	34 60		bit $60,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2471	10 07		bpl $247a			bpl 	_AddExit
.2473	b5 31		lda $31,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2475	95 30		sta $30,x			sta 	NSStatus,x
.2477	20 6b 26	jsr $266b			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.247a					_AddExit:
.247a	20 c4 26	jsr $26c4			jsr 	FloatIsZero 				; check for -0
.247d	d0 02		bne $2481			bne 	_AddNonZero
.247f	74 30		stz $30,x			stz 	NSStatus,x
.2481					_AddNonZero:
.2481	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2482					FloatEncodeStart:
.2482	38		sec				sec
.2483	80 01		bra $2486			bra 	FloatEncodeContinue+1
.2485					FloatEncodeContinue:
.2485	18		clc				clc
.2486					FloatEncode:
.2486	08		php				php 								; save reset flag.
.2487	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2489	f0 15		beq $24a0			beq 	_ENIsOkay
.248b	c9 30		cmp #$30			cmp 	#"0"
.248d	90 04		bcc $2493			bcc 	_ENBadNumber
.248f	c9 3a		cmp #$3a			cmp 	#"9"+1
.2491	90 0d		bcc $24a0			bcc 	_ENIsOkay
.2493					_ENBadNumber:
.2493	28		plp				plp 								; throw saved reset
.2494	ad 39 05	lda $0539			lda 	encodeState 				; if in decimal mode, construct final number
.2497	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2499	d0 03		bne $249e			bne 	_ENFail
.249b	4c 18 25	jmp $2518			jmp 	_ENConstructFinal
.249e					_ENFail:
.249e	18		clc				clc 								; not allowed
.249f	60		rts				rts
.24a0					_ENIsOkay:
.24a0	28		plp				plp 								; are we restarting
.24a1	90 15		bcc $24b8			bcc 	_ENNoRestart
.24a3					_ENStartEncode:
.24a3	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.24a5	f0 0c		beq $24b3			beq 	_ENFirstDP
.24a7	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.24a9	20 a4 26	jsr $26a4			jsr 	FloatSetByte 				; in single byte mode.
.24ac	a9 01		lda #$01			lda 	#ESTA_Low
.24ae					_ENExitChange:
.24ae	8d 39 05	sta $0539			sta 	encodeState 				; save new state
.24b1	38		sec				sec
.24b2	60		rts				rts
.24b3					_ENFirstDP:
.24b3	20 a2 26	jsr $26a2			jsr 	FloatSetZero 				; clear integer part
.24b6	80 3c		bra $24f4			bra 	_ESTASwitchFloat			; go straight to float and exi
.24b8					_ENNoRestart:
.24b8	48		pha				pha 								; save digit or DP on stack.
.24b9	ad 39 05	lda $0539			lda 	encodeState 				; get current state
.24bc	c9 01		cmp #$01			cmp 	#ESTA_Low
.24be	f0 09		beq $24c9			beq  	_ESTALowState
.24c0	c9 02		cmp #$02			cmp 	#ESTA_High
.24c2	f0 26		beq $24ea			beq 	_ESTAHighState
.24c4	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.24c6	f0 38		beq $2500			beq 	_ESTADecimalState
>24c8	db						.byte 	$DB 						; causes a break in the emulator
.24c9					_ESTALowState:
.24c9	68		pla				pla 								; get value back
.24ca	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.24cc	f0 26		beq $24f4			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24ce	29 0f		and #$0f			and 	#15 						; make digit
.24d0	8d 3a 05	sta $053a			sta 	digitTemp 					; save it.
.24d3	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24d5	0a		asl a				asl 	a
.24d6	0a		asl a				asl 	a
.24d7	75 3c		adc $3c,x			adc 	NSMantissa0,x
.24d9	0a		asl a				asl 	a
.24da	6d 3a 05	adc $053a			adc 	digitTemp
.24dd	95 3c		sta $3c,x			sta 	NSMantissa0,x
.24df	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24e1	90 05		bcc $24e8			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24e3	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24e5	8d 39 05	sta $0539			sta 	encodeState
.24e8					_ESTANoSwitch:
.24e8	38		sec				sec
.24e9	60		rts				rts
.24ea					_ESTAHighState:
.24ea	68		pla				pla 								; get value back
.24eb	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24ed	f0 05		beq $24f4			beq 	_ESTASwitchFloat
.24ef	20 4a 25	jsr $254a			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24f2	38		sec				sec
.24f3	60		rts				rts
.24f4					_ESTASwitchFloat:
.24f4	9c 3b 05	stz $053b			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24f7	e8		inx				inx 								; zero the decimal additive.
.24f8	20 a2 26	jsr $26a2			jsr 	FloatSetZero
.24fb	ca		dex				dex
.24fc	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24fe	80 ae		bra $24ae			bra 	_ENExitChange
.2500					_ESTADecimalState:
.2500	68		pla				pla 								; digit.
.2501	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.2503	f0 99		beq $249e			beq 	_ENFail
.2505	e8		inx				inx 								; put digit into fractional part of X+1
.2506	20 4a 25	jsr $254a			jsr 	ESTAShiftDigitIntoMantissa
.2509	ca		dex				dex
.250a	ee 3b 05	inc $053b			inc 	decimalCount 				; bump the count of decimals
.250d	ad 3b 05	lda $053b			lda 	decimalCount 				; too many decimal digits.
.2510	c9 0b		cmp #$0b			cmp 	#11
.2512	f0 02		beq $2516			beq 	_ESTADSFail
.2514	38		sec				sec
.2515	60		rts				rts
.2516					_ESTADSFail:
.2516	18		clc				clc
.2517	60		rts				rts
.2518					_ENConstructFinal:
.2518	ad 3b 05	lda $053b			lda 	decimalCount 				; get decimal count
.251b	f0 2b		beq $2548			beq 	_ENCFExit 					; no decimals
.251d	5a		phy				phy
.251e	0a		asl a				asl 	a 							; x 4 and CLC
.251f	0a		asl a				asl 	a
.2520	6d 3b 05	adc $053b			adc 	decimalCount
.2523	a8		tay				tay
.2524	b9 af 21	lda $21af,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.2527	95 3e		sta $3e,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.2529	b9 b0 21	lda $21b0,y			lda 	FloatScalarTable-5+1,y
.252c	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.252e	b9 b1 21	lda $21b1,y			lda 	FloatScalarTable-5+2,y
.2531	95 56		sta $56,x			sta 	NSMantissa2+2,x
.2533	b9 b2 21	lda $21b2,y			lda 	FloatScalarTable-5+3,y
.2536	95 62		sta $62,x			sta 	NSMantissa3+2,x
.2538	b9 b3 21	lda $21b3,y			lda 	FloatScalarTable-5+4,y
.253b	95 6e		sta $6e,x			sta 	NSExponent+2,x
.253d	74 32		stz $32,x			stz 	NSStatus+2,x 				; make +ve
.253f	e8		inx				inx 								; multiply decimal const by decimal scalar
.2540	e8		inx				inx
.2541	20 62 23	jsr $2362			jsr 	FloatMultiply
.2544	20 c6 20	jsr $20c6			jsr 	FloatAdd 					; add to integer part.
.2547	7a		ply				ply
.2548					_ENCFExit:
.2548	18		clc				clc 								; reject the digit.
.2549	60		rts				rts
.254a					ESTAShiftDigitIntoMantissa:
.254a	29 0f		and #$0f			and 	#15 						; save digit
.254c	48		pha				pha
.254d	b5 60		lda $60,x			lda 	NSMantissa3,x 				; push mantissa on stack
.254f	48		pha				pha
.2550	b5 54		lda $54,x			lda 	NSMantissa2,x
.2552	48		pha				pha
.2553	b5 48		lda $48,x			lda 	NSMantissa1,x
.2555	48		pha				pha
.2556	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2558	48		pha				pha
.2559	20 b1 26	jsr $26b1			jsr 	FloatShiftLeft 				; x 2
.255c	20 b1 26	jsr $26b1			jsr 	FloatShiftLeft 				; x 4
.255f	18		clc				clc 								; pop mantissa and add
.2560	68		pla				pla
.2561	75 3c		adc $3c,x			adc 	NSMantissa0,x
.2563	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2565	68		pla				pla
.2566	75 48		adc $48,x			adc 	NSMantissa1,x
.2568	95 48		sta $48,x			sta 	NSMantissa1,x
.256a	68		pla				pla
.256b	75 54		adc $54,x			adc 	NSMantissa2,x
.256d	95 54		sta $54,x			sta 	NSMantissa2,x
.256f	68		pla				pla
.2570	75 60		adc $60,x			adc 	NSMantissa3,x
.2572	95 60		sta $60,x			sta 	NSMantissa3,x 				; x 5
.2574	20 b1 26	jsr $26b1			jsr 	FloatShiftLeft 				; x 10
.2577	68		pla				pla 								; add digit
.2578	18		clc				clc
.2579	75 3c		adc $3c,x			adc 	NSMantissa0,x
.257b	95 3c		sta $3c,x			sta 	NSMantissa0,x
.257d	90 0a		bcc $2589			bcc 	_ESTASDExit
.257f	f6 48		inc $48,x			inc 	NSMantissa1,x
.2581	d0 06		bne $2589			bne 	_ESTASDExit
.2583	f6 54		inc $54,x			inc 	NSMantissa2,x
.2585	d0 02		bne $2589			bne 	_ESTASDExit
.2587	f6 60		inc $60,x			inc 	NSMantissa3,x
.2589					_ESTASDExit:
.2589	60		rts				rts
.0539					encodeState:
>0539							.fill 	1
.053a					digitTemp:
>053a							.fill 	1
.053b					decimalCount:
>053b							.fill 	1
.258a					FloatToString:
.258a	da		phx				phx
.258b	5a		phy				phy 								; save code position
.258c	8d 3c 05	sta $053c			sta 	decimalPlaces	 			; save number of DPs.
.258f	9c 3d 05	stz $053d			stz 	dbOffset 					; offset into decimal buffer = start.
.2592	b5 30		lda $30,x			lda 	NSStatus,x  				; is it -ve.
.2594	10 08		bpl $259e			bpl 	_CNTSNotNegative
.2596	29 7f		and #$7f			and 	#$7F 						; make +ve
.2598	95 30		sta $30,x			sta 	NSStatus,x
.259a	a9 2d		lda #$2d			lda 	#"-"
.259c	80 02		bra $25a0			bra 	_CNTMain
.259e					_CNTSNotNegative:
.259e	a9 20		lda #$20			lda 	#" "
.25a0					_CNTMain:
.25a0	20 02 26	jsr $2602			jsr 	WriteDecimalBuffer
.25a3	b5 6c		lda $6c,x			lda 	NSExponent,x 				; check if decimal
.25a5	f0 0d		beq $25b4			beq 	_CNTSNotFloat
.25a7	e8		inx				inx 								; round up so we don't get too many 6.999999
.25a8	a9 01		lda #$01			lda 	#1
.25aa	20 a4 26	jsr $26a4			jsr 	FloatSetByte
.25ad	b5 6b		lda $6b,x			lda		NSExponent-1,x
.25af	95 6c		sta $6c,x			sta 	NSExponent,x
.25b1	20 c6 20	jsr $20c6			jsr 	FloatAdd
.25b4					_CNTSNotFloat:
.25b4	20 e4 25	jsr $25e4			jsr 	MakePlusTwoString 			; do the integer part.
.25b7	20 82 22	jsr $2282			jsr 	FloatFractionalPart 		; get the fractional part
.25ba	20 f7 23	jsr $23f7			jsr 	FloatNormalise					; normalise , exit if zero
.25bd	f0 22		beq $25e1			beq 	_CNTSExit
.25bf	a9 2e		lda #$2e			lda 	#"."
.25c1	20 02 26	jsr $2602			jsr 	WriteDecimalBuffer 			; write decimal place
.25c4					_CNTSDecimal:
.25c4	ce 3c 05	dec $053c			dec 	decimalPlaces 				; done all the decimals
.25c7	30 18		bmi $25e1			bmi 	_CNTSExit
.25c9	e8		inx				inx 								; x 10.0
.25ca	a9 0a		lda #$0a			lda 	#10
.25cc	20 a4 26	jsr $26a4			jsr 	FloatSetByte
.25cf	20 62 23	jsr $2362			jsr 	FloatMultiply
.25d2	20 e4 25	jsr $25e4			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25d5	20 82 22	jsr $2282			jsr 	FloatFractionalPart 		; get the fractional part
.25d8	20 f7 23	jsr $23f7			jsr 	FloatNormalise 				; normalise it.
.25db	b5 6c		lda $6c,x			lda 	NSExponent,x 				; gone to zero, exit.
.25dd	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25df	b0 e3		bcs $25c4			bcs 	_CNTSDecimal 				; keep going.
.25e1					_CNTSExit:
.25e1	7a		ply				ply
.25e2	fa		plx				plx
.25e3	60		rts				rts
.25e4					MakePlusTwoString:
.25e4	da		phx				phx
.25e5	20 85 26	jsr $2685			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25e8	e8		inx				inx 								; access it
.25e9	e8		inx				inx
.25ea	20 dd 22	jsr $22dd			jsr 	FloatIntegerPart 			; make it an integer
.25ed	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25ef	20 21 26	jsr $2621			jsr 	ConvertInt32
.25f2	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25f4					_MPTSCopy:
.25f4	bd 17 05	lda $0517,x			lda 	numberBuffer,x
.25f7	20 02 26	jsr $2602			jsr 	WriteDecimalBuffer
.25fa	e8		inx				inx
.25fb	bd 17 05	lda $0517,x			lda 	numberBuffer,x
.25fe	d0 f4		bne $25f4			bne 	_MPTSCopy
.2600	fa		plx				plx
.2601	60		rts				rts
.2602					WriteDecimalBuffer:
.2602	da		phx				phx
.2603	ae 3d 05	ldx $053d			ldx 	dbOffset
.2606	9d 3e 05	sta $053e,x			sta 	decimalBuffer,x
.2609	9e 3f 05	stz $053f,x			stz 	decimalBuffer+1,x
.260c	ee 3d 05	inc $053d			inc 	dbOffset
.260f	fa		plx				plx
.2610	60		rts				rts
.053c					decimalPlaces:
>053c							.fill 	1
.053d					dbOffset:
>053d							.fill 	1
.053e					decimalBuffer:
>053e							.fill 	32
.2611					ConvertInt16:
.2611	85 3c		sta $3c				sta 	NSMantissa0 				; set up as 32 bit conversion
.2613	86 48		stx $48				stx 	NSMantissa1
.2615	64 54		stz $54				stz 	NSMantissa2
.2617	64 60		stz $60				stz 	NSMantissa3
.2619	64 30		stz $30				stz 	NSStatus 					; positive integer
.261b	a2 00		ldx #$00			ldx 	#0 							; stack level
.261d	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.261f	80 00		bra $2621			bra 	ConvertInt32
.2621					ConvertInt32:
.2621	5a		phy				phy
.2622	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.2624	24 30		bit $30				bit 	NSStatus 					; output a - if not negative.
.2626	10 08		bpl $2630			bpl 	_CI32NotNeg
.2628	48		pha				pha
.2629	a9 2d		lda #$2d			lda 	#'-'
.262b	99 17 05	sta $0517,y			sta 	numberBuffer,y
.262e	c8		iny				iny
.262f	68		pla				pla
.2630					_CI32NotNeg:
.2630	20 3e 26	jsr $263e			jsr 	_CI32DivideConvert 			; recursive conversion
.2633	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2635	99 17 05	sta $0517,y			sta 	numberBuffer,y
.2638	7a		ply				ply
.2639	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.263b	a9 17		lda #$17			lda 	#numberBuffer & $FF
.263d	60		rts				rts
.263e					_CI32DivideConvert:
.263e	e8		inx				inx 								; write to next slot up
.263f	20 a4 26	jsr $26a4			jsr 	FloatSetByte 		 		; write the base out.
.2642	ca		dex				dex
.2643	20 38 22	jsr $2238			jsr 	Int32Divide 				; divide
.2646	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; save remainder
.2648	48		pha				pha
.2649	20 27 22	jsr $2227			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.264c	20 c4 26	jsr $26c4			jsr 	FloatIsZero 				; is it zero ?
.264f	f0 05		beq $2656			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2651	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2653	20 3e 26	jsr $263e			jsr 	_CI32DivideConvert 			; and recusrively call.
.2656					_CI32NoRecurse:
.2656	68		pla				pla 								; remainder
.2657	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2659	90 02		bcc $265d			bcc 	_CI32NotHex
.265b	69 26		adc #$26			adc 	#6+32
.265d					_CI32NotHex:
.265d	69 30		adc #$30			adc 	#48
.265f	99 17 05	sta $0517,y			sta 	numberBuffer,y 				; write out and exit
.2662	c8		iny				iny
.2663	60		rts				rts
.2664					FloatNegate:
.2664	b5 30		lda $30,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2666	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2668	95 30		sta $30,x			sta 	NSStatus,x
.266a	60		rts				rts
.266b					FloatNegateMantissa:
.266b	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.266c	a9 00		lda #$00			lda 	#0
.266e	f5 3c		sbc $3c,x			sbc 	NSMantissa0,x
.2670	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2672	a9 00		lda #$00			lda 	#0
.2674	f5 48		sbc $48,x			sbc 	NSMantissa1,x
.2676	95 48		sta $48,x			sta 	NSMantissa1,x
.2678	a9 00		lda #$00			lda 	#0
.267a	f5 54		sbc $54,x			sbc 	NSMantissa2,x
.267c	95 54		sta $54,x			sta 	NSMantissa2,x
.267e	a9 00		lda #$00			lda 	#0
.2680	f5 60		sbc $60,x			sbc 	NSMantissa3,x
.2682	95 60		sta $60,x			sta 	NSMantissa3,x
.2684	60		rts				rts
.2685					FloatShiftUpTwo:
.2685	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2687	95 3e		sta $3e,x			sta 	NSMantissa0+2,x
.2689	b5 48		lda $48,x			lda 	NSMantissa1,x
.268b	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.268d	b5 54		lda $54,x			lda 	NSMantissa2,x
.268f	95 56		sta $56,x			sta 	NSMantissa2+2,x
.2691	b5 60		lda $60,x			lda 	NSMantissa3,x
.2693	95 62		sta $62,x			sta 	NSMantissa3+2,x
.2695	b5 6c		lda $6c,x			lda 	NSExponent,x
.2697	95 6e		sta $6e,x			sta 	NSExponent+2,x
.2699	b5 30		lda $30,x			lda 	NSStatus,x
.269b	95 32		sta $32,x			sta 	NSStatus+2,x
.269d	60		rts				rts
.269e					FloatSetZeroMantissaOnly:
.269e	74 3c		stz $3c,x			stz 	NSMantissa0,x
.26a0	80 08		bra $26aa			bra 	FloatZero13
.26a2					FloatSetZero:
.26a2	a9 00		lda #$00			lda 	#0
.26a4					FloatSetByte:
.26a4	74 6c		stz $6c,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.26a6					FloatSetMantissa:
.26a6	95 3c		sta $3c,x			sta 	NSMantissa0,x 				; zero mantissa
.26a8	74 30		stz $30,x			stz 	NSStatus,x
.26aa					FloatZero13:
.26aa	74 48		stz $48,x			stz 	NSMantissa1,x
.26ac	74 54		stz $54,x			stz 	NSMantissa2,x
.26ae	74 60		stz $60,x			stz 	NSMantissa3,x
.26b0	60		rts				rts
.26b1					FloatShiftLeft:
.26b1	18		clc				clc
.26b2					FloatRotateLeft:
.26b2	36 3c		rol $3c,x			rol 	NSMantissa0,x
.26b4	36 48		rol $48,x			rol		NSMantissa1,x
.26b6	36 54		rol $54,x			rol		NSMantissa2,x
.26b8	36 60		rol $60,x			rol		NSMantissa3,x
.26ba	60		rts				rts
.26bb					FloatShiftRight:
.26bb	56 60		lsr $60,x			lsr 	NSMantissa3,x
.26bd	76 54		ror $54,x			ror		NSMantissa2,x
.26bf	76 48		ror $48,x			ror		NSMantissa1,x
.26c1	76 3c		ror $3c,x			ror		NSMantissa0,x
.26c3	60		rts				rts
.26c4					FloatIsZero:
.26c4	b5 60		lda $60,x			lda 	NSMantissa3,x
.26c6	15 54		ora $54,x			ora		NSMantissa2,x
.26c8	15 48		ora $48,x			ora		NSMantissa1,x
.26ca	15 3c		ora $3c,x			ora		NSMantissa0,x
.26cc	60		rts				rts

;******  Processing input file: testing/testend.asm

.26cd					EndProgram:
>26cd	01 08 0c 08 0a 00 4e 20				.binary "code/tokenised.dat"
>26d5	b2 20 31 34 00 15 08 14 00 ce 86 20 33 00 32 08
>26e5	3c 00 99 20 c7 28 31 34 37 29 3b 22 48 45 4c 4c
>26f5	4f 20 57 4f 52 4c 44 20 21 22 00 4e 08 46 00 86
>2705	20 42 58 28 4e 29 3a 86 20 42 59 28 4e 29 3a 86
>2715	20 42 43 28 4e 29 00 62 08 4b 00 86 20 44 58 28
>2725	4e 29 3a 86 20 44 59 28 4e 29 00 70 08 50 00 81
>2735	20 42 b2 30 20 a4 20 4e 00 89 08 5a 00 42 58 28
>2745	42 29 b2 b5 28 bb 28 31 29 ac 34 30 29 ac 32 aa
>2755	31 00 a2 08 64 00 42 59 28 42 29 b2 b5 28 bb 28
>2765	31 29 ac 33 30 29 ac 32 35 36 00 b9 08 69 00 42
>2775	43 28 42 29 b2 b5 28 bb 28 31 29 ac 31 34 29 aa
>2785	31 00 cd 08 6a 00 44 58 28 42 29 b2 b5 28 bb 28
>2795	31 29 ac 32 29 00 e3 08 6c 00 8f 20 44 59 28 42
>27a5	29 b2 b5 28 bb 28 31 29 ac 32 29 00 ef 08 6d 00
>27b5	44 59 28 42 29 b2 31 00 f7 08 6e 00 82 20 42 00
>27c5	fd 08 78 00 8f 00 11 09 82 00 81 59 b2 30 a4 32
>27d5	39 3a 81 58 b2 30 a4 33 39 00 27 09 8c 00 51 b2
>27e5	59 ac 32 35 36 aa 58 ac 32 aa 34 35 30 35 36 00
>27f5	3f 09 96 00 ce 84 20 31 2c 51 2c 38 31 3a ce 84
>2805	31 2c 51 aa 31 2c 30 00 48 09 a0 00 82 58 2c 59
>2815	00 54 09 c8 00 81 20 42 b2 31 a4 4e 00 71 09 d2
>2825	00 ce 84 20 31 2c 34 35 30 35 36 aa 42 59 28 42
>2835	29 aa 42 58 28 42 29 2c 30 00 7f 09 e6 00 44 58
>2845	42 b2 44 58 28 42 29 00 90 09 f0 00 8b 44 58 42
>2855	b2 30 a7 8d 31 30 31 30 00 a1 09 fa 00 8b 44 58
>2865	42 b2 31 a7 8d 31 30 34 30 00 af 09 ff 00 44 59
>2875	42 b2 44 59 28 42 29 00 c0 09 04 01 8b 44 59 42
>2885	b2 30 a7 8d 31 30 37 30 00 d1 09 0e 01 8b 44 59
>2895	42 b2 31 a7 8d 31 31 30 30 00 f2 09 18 01 ce 84
>28a5	20 31 2c 34 35 30 35 36 aa 42 59 28 42 29 aa 42
>28b5	58 28 42 29 2c 42 43 28 42 29 00 f9 09 22 01 82
>28c5	42 00 03 0a 2c 01 89 20 32 30 30 00 09 0a e8 03
>28d5	8f 00 17 0a f2 03 42 58 42 b2 42 58 28 42 29 00
>28e5	2c 0a f3 03 8b 42 58 42 b2 31 a7 44 58 28 42 29
>28f5	b2 31 3a 8e 00 3e 0a fc 03 42 58 28 42 29 b2 42
>2905	58 42 ab 32 3a 8e 00 44 0a 06 04 8f 00 52 0a 10
>2915	04 42 58 42 b2 42 58 28 42 29 00 72 0a 11 04 8b
>2925	42 58 42 b2 37 39 a7 20 42 58 28 42 29 b2 37 37
>2935	3a 44 58 28 42 29 b2 30 3a 8e 00 84 0a 1a 04 42
>2945	58 28 42 29 b2 42 58 42 aa 32 3a 8e 00 8a 0a 24
>2955	04 8f 00 98 0a 2e 04 42 59 42 b2 42 59 28 42 29
>2965	00 ad 0a 2f 04 8b 42 59 42 b2 30 a7 44 59 28 42
>2975	29 b2 31 3a 8e 00 c1 0a 38 04 42 59 28 42 29 b2
>2985	42 59 42 ab 32 35 36 3a 8e 00 c7 0a 42 04 8f 00
>2995	d5 0a 4c 04 42 59 42 b2 42 59 28 42 29 00 f8 0a
>29a5	4d 04 8b 42 59 42 b2 37 34 32 34 a7 42 59 28 42
>29b5	29 b2 37 31 36 38 3a 44 59 28 42 29 b2 30 3a 8e
>29c5	00 0c 0b 56 04 42 59 28 42 29 b2 42 59 42 aa 32
>29d5	35 36 3a 8e 00 00 00

;******  End of listing
