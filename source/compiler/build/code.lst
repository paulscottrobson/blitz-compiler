
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl /home/paulr/Projects/blitz-compiler/documents/../source/common-source/wrapper.asm testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Thu Oct  5 13:48:05 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../source/common-source/wrapper.asm

=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.1000	a2 ff		ldx #$ff			ldx 	#$FF
.1002	9a		txs				txs
.1003	4c 06 10	jmp $1006			jmp 	WrapperBoot
.0022					codePtr:
>0022							.fill 	2
.0024					codePage:
>0024							.fill 	1
.0025					objPtr:
>0025							.fill 	2
.0027					objPage:
>0027							.fill 	1
.0028					zTemp0:
>0028							.fill 	2
.002a					zTemp1:
>002a							.fill 	2
.002c					zTemp2:
>002c							.fill 	2

;******  Processing input file: testing/testing.asm

.1006					WrapperBoot:
.1006	4c a8 10	jmp $10a8			jmp 	StartCompiler

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
.002e					srcPtr:
>002e							.fill 	2
.0400					sourceBuffer:
>0400							.fill 	256
.0500					currentLineNumber:
>0500							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
=$4000					PCodeStart = $4000
=$8000					WorkArea = $8000
=$1f00					WorkAreaSize = $1F00
.1009					InlineNonDecimal:
.1009	a2 02		ldx #$02			ldx 	#2 							; get size in X
.100b	c9 25		cmp #$25			cmp 	#"%"
.100d	f0 02		beq $1011			beq 	_INDBinary
.100f	a2 10		ldx #$10			ldx 	#16
.1011					_INDBinary:
.1011	85 2a		sta $2a				sta 	zTemp1 						; size => zTemp1
.1013	64 2b		stz $2b				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.1015	64 28		stz $28				stz 	zTemp0 						; zero result
.1017	64 29		stz $29				stz 	zTemp0+1
.1019					_INDLoop:
.1019	20 22 18	jsr $1822			jsr 	LookNext 					; check next character
.101c	20 5e 18	jsr $185e			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.101f	90 1f		bcc $1040			bcc		_INDDone 					; didn't convert
.1021	c5 2a		cmp $2a				cmp 	zTemp1 						; size too large ?
.1023	b0 1b		bcs $1040			bcs 	_INDDone
.1025	20 4f 10	jsr $104f			jsr 	_INDShift 					; x 2 or x 16
.1028	e0 02		cpx #$02			cpx 	#2
.102a	f0 09		beq $1035			beq 	_INDNotHex
.102c	20 4f 10	jsr $104f			jsr 	_INDShift
.102f	20 4f 10	jsr $104f			jsr 	_INDShift
.1032	20 4f 10	jsr $104f			jsr 	_INDShift
.1035					_INDNotHex:
.1035	05 28		ora $28				ora 	zTemp0 						; or digit into result
.1037	85 28		sta $28				sta 	zTemp0
.1039	20 33 18	jsr $1833			jsr 	GetNext 					; consume
.103c	e6 2b		inc $2b				inc 	zTemp1+1 					; bump count
.103e	80 d9		bra $1019			bra 	_INDLoop
.1040					_INDDone:
.1040	a5 2b		lda $2b				lda 	zTemp1+1 					; done at least 1 ?
.1042	f0 08		beq $104c			beq 	_INDError
.1044	a4 29		ldy $29				ldy 	zTemp0+1 					; push constant
.1046	a5 28		lda $28				lda 	zTemp0
.1048	20 0e 11	jsr $110e			jsr 	PushIntegerYA
.104b	60		rts				rts
.104c					_INDError:
.104c	4c 2f 13	jmp $132f		jmp	ErrorV_syntax
.104f					_INDShift:
.104f	06 28		asl $28				asl 	zTemp0
.1051	26 29		rol $29				rol 	zTemp0+1
.1053	60		rts				rts
.1054					BufferClear:
.1054	9c 02 05	stz $0502			stz 	bufferSize
.1057	60		rts				rts
.1058					BufferWrite:
.1058	da		phx				phx
.1059	ae 02 05	ldx $0502			ldx 	bufferSize
.105c	9d 03 05	sta $0503,x			sta 	dataBuffer,x
.105f	ee 02 05	inc $0502			inc 	bufferSize
.1062	fa		plx				plx
.1063	60		rts				rts
.1064					BufferOutput:
.1064	ad 02 05	lda $0502			lda 	bufferSize
.1067	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.106a	a2 00		ldx #$00			ldx 	#0
.106c					_BOLoop:
.106c	ec 02 05	cpx $0502			cpx 	bufferSize
.106f	f0 09		beq $107a			beq 	_BOExit
.1071	bd 03 05	lda $0503,x			lda 	dataBuffer,x
.1074	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1077	e8		inx				inx
.1078	80 f2		bra $106c			bra 	_BOLoop
.107a					_BOExit:
.107a	60		rts				rts
.0502					bufferSize:
>0502							.fill 	1
.0503					dataBuffer:
>0503							.fill 	256
.107b					WriteCodeByte:
.107b	48		pha				pha 								; save on stack
.107c	da		phx				phx
.107d	5a		phy				phy
.107e	20 07 1d	jsr $1d07			jsr 	OUTPUTWriteByte
.1081	7a		ply				ply 								; restore from stack
.1082	fa		plx				plx
.1083	68		pla				pla
.1084	60		rts				rts
.1085					CheckNextComma:
.1085	a9 2c		lda #$2c			lda	 	#","
.1087	80 06		bra $108f			bra 	CheckNextA
.1089					CheckNextRParen:
.1089	a9 29		lda #$29			lda	 	#")"
.108b	80 02		bra $108f			bra 	CheckNextA
.108d					CheckNextLParen:
.108d	a9 28		lda #$28			lda 	#"("
.108f					CheckNextA:
.108f	8d 03 06	sta $0603			sta 	checkCharacter 				; save test character
.1092					_CNALoop:
.1092	20 3e 18	jsr $183e			jsr 	GetNextNonSpace 			; get next skipping spaces.
.1095	cd 03 06	cmp $0603			cmp 	checkCharacter 				; matches ?
.1098	f0 03		beq $109d			beq 	_CNAExit
.109a	4c 2f 13	jmp $132f		jmp	ErrorV_syntax
.109d					_CNAExit:
.109d	60		rts				rts
.0603					checkCharacter:
>0603							.fill 	1
.109e					OUTPUTClose:
.109e	a9 40		lda #$40			lda 	#(PCodeStart >> 8)
.10a0	a6 25		ldx $25				ldx 	objPtr
.10a2	a4 26		ldy $26				ldy 	objPtr+1
.10a4	20 71 1d	jsr $1d71			jsr 	XSaveMemory
.10a7	60		rts				rts
.10a8					StartCompiler:
.10a8	20 26 1c	jsr $1c26			jsr 	STRReset 					; reset storage (line#, variable)
.10ab	20 74 16	jsr $1674			jsr 	INPUTOpen 					; reset data input
.10ae	20 d5 1a	jsr $1ad5			jsr 	OUTPUTOpen 					; reset data output.
.10b1	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.10b3	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.10b6	a9 00		lda #$00			lda 	#0
.10b8	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.10bb	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.10be					MainCompileLoop:
.10be	20 b8 19	jsr $19b8			jsr 	ReadNextLine 				; read next line into the buffer.
.10c1	90 2e		bcc $10f1			bcc 	SaveCodeAndExit 			; end of source.
.10c3	20 e9 19	jsr $19e9			jsr 	GetLineNumber 				; get line #
.10c6	20 f0 19	jsr $19f0			jsr 	STRMarkLine 				; remember the position and number of this line.
.10c9	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.10cb	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.10ce					_MCLSameLine:
.10ce	20 3e 18	jsr $183e			jsr 	GetNextNonSpace 			; get the first character.
.10d1	f0 eb		beq $10be			beq 	MainCompileLoop 			; end of line, get next line.
.10d3	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.10d5	f0 f7		beq $10ce			beq 	_MCLSameLine
.10d7	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.10d9	10 0c		bpl $10e7			bpl 	_MCLCheckAssignment
.10db	a2 c5		ldx #$c5			ldx 	#CommandTables & $FF 		; do command tables.
.10dd	a0 16		ldy #$16			ldy 	#CommandTables >> 8
.10df	20 c7 16	jsr $16c7			jsr 	GeneratorProcess
.10e2	b0 ea		bcs $10ce			bcs 	_MCLSameLine 				; keep trying to compile the line.
.10e4					_MCLSyntax:
.10e4	4c 2f 13	jmp $132f		jmp	ErrorV_syntax
.10e7					_MCLCheckAssignment:
.10e7	20 54 18	jsr $1854			jsr 	CharIsAlpha 				; if not alpha then syntax error
.10ea	90 f8		bcc $10e4			bcc 	_MCLSyntax
.10ec	20 86 19	jsr $1986			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.10ef	80 dd		bra $10ce			bra		_MCLSameLine 				; loop back.
.10f1					SaveCodeAndExit:
.10f1	20 7c 16	jsr $167c			jsr 	INPUTClose 					; finish input.
.10f4	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.10f6	a8		tay				tay
.10f7	20 f0 19	jsr $19f0			jsr 	STRMarkLine
.10fa	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.10fc	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.10ff	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.1101	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1104	20 5b 15	jsr $155b			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.1107	20 9e 10	jsr $109e			jsr 	OUTPUTClose
.110a					ExitCompiler:
.110a	4c ff ff	jmp $ffff			jmp 	$FFFF
.110d	60		rts				rts
.110e					PushIntegerYA:
.110e	c0 00		cpy #$00			cpy 	#0 							; 0-255
.1110	f0 0f		beq $1121			beq 	PushIntegerA
.1112	48		pha				pha
.1113	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.1115	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1118	68		pla				pla 								; then LSB
.1119	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.111c	98		tya				tya 								; then MSB
.111d	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1120	60		rts				rts
.1121					PushIntegerA:
.1121	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.1123	90 07		bcc $112c			bcc 	_PIWriteA
.1125	48		pha				pha
.1126	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.1128	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.112b	68		pla				pla
.112c					_PIWriteA:
.112c	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.112f	60		rts				rts
.1130					PushFloat:
.1130	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.1132	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1135	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.1137	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.113a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.113c	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.113f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1141	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1144	b5 56		lda $56,x			lda 	NSMantissa2,x
.1146	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1149	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.114b	29 80		and #$80			and 	#$80
.114d	15 62		ora $62,x			ora 	NSMantissa3,x
.114f	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1152	60		rts				rts
.1153					CreateVariableRecord:
.1153	48		pha				pha
.1154	ad 0e 06	lda $060e			lda 	freeVariableMemory 		; push current free address on stack.
.1157	48		pha				pha
.1158	ad 0f 06	lda $060f			lda 	freeVariableMemory+1
.115b	48		pha				pha
.115c	ad 0c 06	lda $060c			lda 	variableListEnd  		; copy end of list to zTemp0
.115f	85 28		sta $28				sta 	zTemp0
.1161	ad 0d 06	lda $060d			lda 	variableListEnd+1
.1164	85 29		sta $29				sta 	zTemp0+1
.1166	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.1168	92 28		sta ($28)			sta 	(zTemp0)
.116a	98		tya				tya
.116b	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.116d	91 28		sta ($28),y			sta 	(zTemp0),y
.116f	88		dey				dey
.1170	8a		txa				txa
.1171	91 28		sta ($28),y			sta 	(zTemp0),y
.1173	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.1175	ad 0e 06	lda $060e			lda 	freeVariableMemory
.1178	91 28		sta ($28),y			sta 	(zTemp0),y
.117a	c8		iny				iny
.117b	ad 0f 06	lda $060f			lda 	freeVariableMemory+1
.117e	91 28		sta ($28),y			sta 	(zTemp0),y
.1180	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.1182	a9 00		lda #$00			lda 	#0
.1184	91 28		sta ($28),y			sta 	(zTemp0),y
.1186	18		clc				clc
.1187	b2 28		lda ($28)			lda 	(zTemp0) 				; add offset to variableListEnd
.1189	6d 0c 06	adc $060c			adc  	variableListEnd
.118c	8d 0c 06	sta $060c			sta 	variableListEnd
.118f	90 03		bcc $1194			bcc 	_CVNoCarry2
.1191	ee 0d 06	inc $060d			inc 	variableListEnd+1
.1194					_CVNoCarry2:
.1194	7a		ply				ply
.1195	fa		plx				plx
.1196	68		pla				pla
.1197	60		rts				rts
.1198					SetVariableRecordToCodePosition:
.1198	48		pha				pha
.1199	5a		phy				phy
.119a	a5 27		lda $27				lda 	objPage
.119c	a0 03		ldy #$03			ldy 	#3
.119e	91 28		sta ($28),y			sta 	(zTemp0),y
.11a0	c8		iny				iny
.11a1	a5 26		lda $26				lda 	objPtr+1
.11a3	91 28		sta ($28),y			sta 	(zTemp0),y
.11a5	c8		iny				iny
.11a6	a5 25		lda $25				lda 	objPtr
.11a8	91 28		sta ($28),y			sta 	(zTemp0),y
.11aa	7a		ply				ply
.11ab	68		pla				pla
.11ac	60		rts				rts
.11ad					AllocateBytesForType:
.11ad	48		pha				pha
.11ae	da		phx				phx
.11af	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.11b1	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.11b3	c9 00		cmp #$00			cmp 	#NSSIFloat
.11b5	d0 02		bne $11b9			bne 	_CVNotFloat
.11b7	a2 06		ldx #$06			ldx 	#6
.11b9					_CVNotFloat:
.11b9	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.11ba	18		clc				clc
.11bb	6d 0e 06	adc $060e			adc 	freeVariableMemory
.11be	8d 0e 06	sta $060e			sta 	freeVariableMemory
.11c1	90 03		bcc $11c6			bcc 	_CVNoCarry1
.11c3	ee 0f 06	inc $060f			inc 	freeVariableMemory+1
.11c6					_CVNoCarry1:
.11c6	fa		plx				plx
.11c7	68		pla				pla
.11c8	60		rts				rts
.11c9					CommandDATA:
.11c9	20 54 10	jsr $1054			jsr 	BufferClear 				; copy it to the buffer
.11cc	20 25 18	jsr $1825			jsr 	LookNextNonSpace
.11cf					_CTDataLoop:
.11cf	20 22 18	jsr $1822			jsr 	LookNext 					; reached EOL
.11d2	f0 08		beq $11dc			beq 	_CTDataDone
.11d4	20 58 10	jsr $1058			jsr 	BufferWrite 				; write and consume
.11d7	20 33 18	jsr $1833			jsr 	GetNext
.11da	80 f3		bra $11cf			bra 	_CTDataLoop
.11dc					_CTDataDone:
.11dc	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.11de	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.11e1	20 64 10	jsr $1064			jsr 	BufferOutput
.11e4	60		rts				rts
.11e5					CommandDEF:
.11e5	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.11e7	20 21 11	jsr $1121			jsr 	PushIntegerA
.11ea	20 4a 19	jsr $194a			jsr 	CompileGotoEOL 				; compile skip over DEF
.11ed	a9 a5		lda #$a5			lda 	#C64_FN
.11ef	20 8f 10	jsr $108f			jsr 	CheckNextA
.11f2	20 3e 18	jsr $183e			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.11f5	20 a3 18	jsr $18a3			jsr 	ExtractVariableName
.11f8	8a		txa				txa
.11f9	10 51		bpl $124c			bpl 	_CDError
.11fb	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.11fc	29 7f		and #$7f			and 	#$7F
.11fe	aa		tax				tax
.11ff	98		tya				tya
.1200	09 80		ora #$80			ora 	#$80
.1202	a8		tay				tay
.1203	20 fe 14	jsr $14fe			jsr 	FindVariable				; does it already exist ?
.1206	b0 44		bcs $124c			bcs 	_CDError 					; if so, that's an error.
.1208	20 53 11	jsr $1153			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.120b	20 98 11	jsr $1198			jsr 	SetVariableRecordToCodePosition
.120e	20 3e 18	jsr $183e			jsr 	GetNextNonSpace
.1211	20 e3 1b	jsr $1be3			jsr 	GetReferenceTerm 			; get var ref, not array
.1214	c9 00		cmp #$00			cmp 	#0
.1216	30 34		bmi $124c			bmi 	_CDError
.1218	8d 04 06	sta $0604			sta 	defType 					; save type
.121b	8e 05 06	stx $0605			stx 	defVariable 				; save var ref
.121e	8c 06 06	sty $0606			sty 	defVariable+1
.1221	29 40		and #$40			and 	#NSSString 					; only numbers.
.1223	d0 27		bne $124c			bne 	_CDError
.1225	20 89 10	jsr $1089			jsr 	CheckNextRParen 			; check )
.1228	a9 b2		lda #$b2			lda 	#C64_EQUAL
.122a	20 8f 10	jsr $108f			jsr 	CheckNextA 					; check =
.122d	18		clc				clc 								; if this is DEF FNxx(A), read A
.122e	20 4f 12	jsr $124f			jsr 	CDReadWriteVariable
.1231	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1233	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1236	38		sec				sec
.1237	20 4f 12	jsr $124f			jsr 	CDReadWriteVariable 		; A is now updated
.123a	20 44 14	jsr $1444			jsr 	CompileExpressionAt0 		; the actual body of the function.
.123d	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.123f	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1242	38		sec				sec
.1243	20 4f 12	jsr $124f			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.1246	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.1248	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.124b	60		rts				rts
.124c					_CDError:
.124c	4c 2f 13	jmp $132f		jmp	ErrorV_syntax
.124f					CDReadWriteVariable:
.124f	ac 06 06	ldy $0606			ldy 	defVariable+1 				; set up YX
.1252	ae 05 06	ldx $0605			ldx 	defVariable
.1255	ad 04 06	lda $0604			lda 	defType
.1258	20 95 1b	jsr $1b95			jsr 	GetSetVariable
.125b	60		rts				rts
.0604					defType:
>0604							.fill 	1
.0605					defVariable:
>0605							.fill 	2
.125c					CommandDIM:
.125c	20 3e 18	jsr $183e			jsr 	GetNextNonSpace 			; get the first non space character
.125f	20 a3 18	jsr $18a3			jsr 	ExtractVariableName 		; variable name to XY
.1262	da		phx				phx 								; save name with type bits.
.1263	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.1265	10 37		bpl $129e			bpl 	_CDError
.1267	20 fe 14	jsr $14fe			jsr 	FindVariable	 			; see if already exist
.126a	b0 35		bcs $12a1			bcs 	_CDRedefine 				; it still exists.
.126c	20 53 11	jsr $1153			jsr 	CreateVariableRecord 		; create the basic variable
.126f	20 ad 11	jsr $11ad			jsr 	AllocateBytesForType 		; allocate memory for it
.1272	68		pla				pla 								; restore type bits
.1273	5a		phy				phy 								; save the address of the basic storage
.1274	da		phx				phx
.1275	48		pha				pha
.1276	20 a4 12	jsr $12a4			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.1279	68		pla				pla
.127a	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.127c	20 21 11	jsr $1121			jsr 	PushIntegerA 				; push that type data out.
.127f	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.1281	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1284	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.1286	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1289	fa		plx				plx 								; restore address
.128a	7a		ply				ply
.128b	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.128d	38		sec				sec
.128e	20 95 1b	jsr $1b95			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.1291	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; , follows ?
.1294	c9 2c		cmp #$2c			cmp 	#","
.1296	d0 05		bne $129d			bne 	_CDExit
.1298	20 33 18	jsr $1833			jsr 	GetNext 					; consume comma
.129b	80 bf		bra $125c			bra 	CommandDIM 					; do another DIM
.129d					_CDExit:
.129d	60		rts				rts
.129e					_CDError:
.129e	4c 2f 13	jmp $132f		jmp	ErrorV_syntax
.12a1					_CDRedefine:
.12a1	4c f7 13	jmp $13f7		jmp	ErrorV_redefine
.12a4					OutputIndexGroup:
.12a4	9c 07 06	stz $0607			stz 	IndexCount 					; count of number of indices.
.12a7					_OIGNext:
.12a7	20 44 14	jsr $1444			jsr 	CompileExpressionAt0 		; get a dimension
.12aa	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.12ac	c9 00		cmp #$00			cmp 	#NSSIFloat
.12ae	d0 19		bne $12c9			bne 	_OIGType
.12b0	ee 07 06	inc $0607			inc 	IndexCount 					; bump the counter.
.12b3	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; does a , follow ?
.12b6	c9 2c		cmp #$2c			cmp 	#","
.12b8	d0 05		bne $12bf			bne 	_OIGCheckEnd
.12ba	20 33 18	jsr $1833			jsr 	GetNext 					; consume comma
.12bd	80 e8		bra $12a7			bra 	_OIGNext 					; get next dimension
.12bf					_OIGCheckEnd:
.12bf	20 89 10	jsr $1089			jsr 	CheckNextRParen 			; check and consume )
.12c2	ad 07 06	lda $0607			lda 	IndexCount
.12c5	20 21 11	jsr $1121			jsr 	PushIntegerA 				; compile the dimension count.
.12c8	60		rts				rts
.12c9					_OIGType:
.12c9	4c 3f 13	jmp $133f		jmp	ErrorV_type
.0607					IndexCount:
>0607							.fill 	1
.12cc					ErrorHandler:
.12cc	68		pla				pla
.12cd	7a		ply				ply
.12ce	85 28		sta $28				sta 	zTemp0
.12d0	84 29		sty $29				sty 	zTemp0+1
.12d2	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.12d4	a0 01		ldy #$01			ldy 	#1
.12d6					_EHDisplayMsg:
.12d6	b1 28		lda ($28),y			lda 	(zTemp0),y
.12d8	20 67 1d	jsr $1d67			jsr 	XPrintCharacter
.12db	c8		iny				iny
.12dc	b1 28		lda ($28),y			lda 	(zTemp0),y
.12de	d0 f6		bne $12d6			bne 	_EHDisplayMsg
.12e0	a9 20		lda #$20			lda 	#32
.12e2	20 67 1d	jsr $1d67			jsr 	XPrintCharacter
.12e5	a9 40		lda #$40			lda 	#64
.12e7	20 67 1d	jsr $1d67			jsr 	XPrintCharacter
.12ea	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.12ec	20 7f 23	jsr $237f			jsr 	FloatSetByte
.12ef	20 e9 19	jsr $19e9			jsr 	GetLineNumber
.12f2	95 3e		sta $3e,x			sta 	NSMantissa0,x
.12f4	98		tya				tya
.12f5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12f7	20 65 22	jsr $2265			jsr 	FloatToString
.12fa	a0 00		ldy #$00			ldy 	#0 							; display that string.
.12fc	a2 00		ldx #$00			ldx 	#0
.12fe					_EHDisplayLine:
.12fe	b9 37 06	lda $0637,y			lda 	decimalBuffer,y
.1301	20 67 1d	jsr $1d67			jsr 	XPrintCharacter
.1304	c8		iny				iny
.1305	b9 37 06	lda $0637,y			lda 	decimalBuffer,y
.1308	d0 f4		bne $12fe			bne 	_EHDisplayLine
.130a	a9 0d		lda #$0d			lda 	#13
.130c	20 67 1d	jsr $1d67			jsr 	XPrintCharacter
.130f	4c 0a 11	jmp $110a			jmp 	ExitCompiler
.1312					ErrorV_range:
.1312	20 cc 12	jsr $12cc		jsr	ErrorHandler
>1315	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>131d	41 4e 47 45 00
.1322					ErrorV_value:
.1322	20 cc 12	jsr $12cc		jsr	ErrorHandler
>1325	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>132d	45 00
.132f					ErrorV_syntax:
.132f	20 cc 12	jsr $12cc		jsr	ErrorHandler
>1332	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>133a	52 52 4f 52 00
.133f					ErrorV_type:
.133f	20 cc 12	jsr $12cc		jsr	ErrorHandler
>1342	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>134a	4d 41 54 43 48 00
.1350					ErrorV_unimplemented:
.1350	20 cc 12	jsr $12cc		jsr	ErrorHandler
>1353	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>135b	45 4d 45 4e 54 45 44 00
.1363					ErrorV_assert:
.1363	20 cc 12	jsr $12cc		jsr	ErrorHandler
>1366	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>136e	41 49 4c 00
.1372					ErrorV_line:
.1372	20 cc 12	jsr $12cc		jsr	ErrorHandler
>1375	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>137d	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1389					ErrorV_internal:
.1389	20 cc 12	jsr $12cc		jsr	ErrorHandler
>138c	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1394	20 45 52 52 4f 52 00
.139b					ErrorV_divzero:
.139b	20 cc 12	jsr $12cc		jsr	ErrorHandler
>139e	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>13a6	59 20 5a 45 52 4f 00
.13ad					ErrorV_structure:
.13ad	20 cc 12	jsr $12cc		jsr	ErrorHandler
>13b0	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>13b8	45 20 49 4d 42 41 4c 41 4e 43 45 00
.13c4					ErrorV_stop:
.13c4	20 cc 12	jsr $12cc		jsr	ErrorHandler
>13c7	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>13cf	53 54 4f 50 50 45 44 00
.13d7					ErrorV_data:
.13d7	20 cc 12	jsr $12cc		jsr	ErrorHandler
>13da	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>13e2	41 54 41 00
.13e6					ErrorV_undeclared:
.13e6	20 cc 12	jsr $12cc		jsr	ErrorHandler
>13e9	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>13f1	41 52 52 41 59 00
.13f7					ErrorV_redefine:
.13f7	20 cc 12	jsr $12cc		jsr	ErrorHandler
>13fa	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1402	44 45 46 49 4e 45 44 00
.140a					ErrorV_index:
.140a	20 cc 12	jsr $12cc		jsr	ErrorHandler
>140d	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1415	59 20 49 4e 44 45 58 00
.141d					ErrorV_memory:
.141d	20 cc 12	jsr $12cc		jsr	ErrorHandler
>1420	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>1428	45 4d 4f 52 59 00
.142e					ErrorV_channel:
.142e	20 cc 12	jsr $12cc		jsr	ErrorHandler
>1431	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>1439	54 50 55 54 20 45 52 52 4f 52 00
.1444					CompileExpressionAt0:
.1444	a9 00		lda #$00			lda 	#0
.1446					CompileExpressionAtA:
.1446	48		pha				pha  								; save level
.1447	20 48 1c	jsr $1c48			jsr 	CompileTerm 				; compile a term.
.144a	fa		plx				plx 								; get level back into X
.144b					_ECALoop:
.144b	48		pha				pha 								; save type on stack.
.144c	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; get the next character
.144f	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.1451	90 04		bcc $1457			bcc 	_ECAExit
.1453	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.1455	90 02		bcc $1459			bcc 	_ECAHaveToken
.1457					_ECAExit:
.1457	68		pla				pla 								; throw type off stack
.1458	60		rts				rts
.1459					_ECAHaveToken:
.1459	86 28		stx $28				stx 	zTemp0 						; save current precedence in zTemp0
.145b	aa		tax				tax 								; X contains the operator token
.145c	bd 47 14	lda $1447,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.145f	c5 28		cmp $28				cmp 	zTemp0 						; if < then exit
.1461	90 f4		bcc $1457			bcc 	_ECAExit
.1463	85 29		sta $29				sta 	zTemp0+1 					; save the precedence of the operator.
.1465	20 33 18	jsr $1833			jsr 	GetNext 					; consume the token.
.1468	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.146a	f0 11		beq $147d			beq 	_ECAGreaterCheck
.146c	e0 b3		cpx #$b3			cpx 	#C64_LESS
.146e	d0 1a		bne $148a			bne 	_ECAHaveFullToken
.1470	20 22 18	jsr $1822			jsr 	LookNext 					; checks for < (<= or <>)
.1473	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.1475	f0 0e		beq $1485			beq	 	_ECAToNotEqual
.1477	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.1479	d0 0f		bne $148a			bne 	_ECAHaveFullToken
.147b	80 07		bra $1484			bra 	_ECAAddEqual
.147d					_ECAGreaterCheck:
.147d	20 22 18	jsr $1822			jsr 	LookNext
.1480	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.1482	d0 06		bne $148a			bne 	_ECAHaveFullToken
.1484					_ECAAddEqual:
.1484	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.1485					_ECAToNotEqual:
.1485	e8		inx				inx
.1486	e8		inx				inx
.1487	20 33 18	jsr $1833			jsr 	GetNext 					; consume the = or > in >= <= <>
.148a					_ECAHaveFullToken:
.148a	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.148c	d0 0a		bne $1498			bne 	_ECANotConcat
.148e	68		pla				pla 								; get type back
.148f	48		pha				pha
.1490	29 40		and #$40			and 	#NSSTypeMask
.1492	c9 40		cmp #$40			cmp 	#NSSString
.1494	d0 02		bne $1498			bne 	_ECANotConcat
.1496	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1498					_ECANotConcat:
.1498	da		phx				phx 								; save operator on the stack
.1499	a6 28		ldx $28				ldx 	zTemp0 						; push current precedence on the stack
.149b	da		phx				phx
.149c	a5 29		lda $29				lda 	zTemp0+1 					; get precedence of operator
.149e	1a		inc a				inc 	a
.149f	20 46 14	jsr $1446			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.14a2	85 28		sta $28				sta 	zTemp0 						; save type in zTemp0
.14a4	fa		plx				plx 								; restore current precedence in X
.14a5	68		pla				pla 								; restore operator
.14a6	85 29		sta $29				sta 	zTemp0+1 					; save it in zTemp0+1.
.14a8	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.14aa	90 17		bcc $14c3			bcc 	_ECANotCompare
.14ac	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.14ae	b0 13		bcs $14c3			bcs 	_ECANotCompare
.14b0	7a		ply				ply 								; get type into Y
.14b1	5a		phy				phy
.14b2	48		pha				pha 								; save operator
.14b3	98		tya				tya 								; get type
.14b4	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.14b6	29 40		and #$40			and 	#NSSTypeMask
.14b8	c9 40		cmp #$40			cmp 	#NSSString
.14ba	f0 02		beq $14be			beq 	_ECANotString
.14bc	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.14be					_ECANotString:
.14be	98		tya				tya									; output token Y
.14bf	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.14c2	68		pla				pla 								; restore operator.
.14c3					_ECANotCompare:
.14c3	18		clc				clc 								; convert to P-Code and compile.
.14c4	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.14c6	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.14c9	68		pla				pla 								; type of current result
.14ca	45 28		eor $28				eor 	zTemp0 						; check compatible with r-expr type
.14cc	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.14ce	d0 19		bne $14e9			bne		_ECAType
.14d0	a5 28		lda $28				lda 	zTemp0 						; get type back
.14d2	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.14d4	d0 18		bne $14ee			bne 	_ECAGoLoop
.14d6	a5 29		lda $29				lda 	zTemp0+1 					; check operator is + or comparator
.14d8	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.14da	f0 10		beq $14ec			beq 	_ECAOkayString 				; (this is post conversion)
.14dc	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.14de	90 09		bcc $14e9			bcc 	_ECAType
.14e0	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.14e2	b0 05		bcs $14e9			bcs 	_ECAType
.14e4	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.14e6	4c 4b 14	jmp $144b			jmp 	_ECALoop
.14e9					_ECAType:
.14e9	4c 3f 13	jmp $133f		jmp	ErrorV_type
.14ec					_ECAOkayString:
.14ec	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.14ee					_ECAGoLoop:
.14ee	4c 4b 14	jmp $144b			jmp 	_ECALoop
.14f1					PrecedenceTable:
>14f1	03						.byte 	3 					; '+'
>14f2	03						.byte 	3 					; '-'
>14f3	04						.byte 	4 					; '*'
>14f4	04						.byte 	4 					; '/'
>14f5	05						.byte 	5 					; '^'
>14f6	01						.byte 	1 					; 'and'
>14f7	00						.byte 	0 					; 'or'
>14f8	02						.byte 	2 					; '>'
>14f9	02						.byte 	2 					; '='
>14fa	02						.byte 	2 					; '<'
>14fb	02						.byte 	2 					; '>='
>14fc	02						.byte 	2 					; '<='
>14fd	02						.byte 	2 					; '<>'
.14fe					FindVariable:
.14fe	86 2a		stx $2a				stx 	zTemp1 						; save name.
.1500	84 2b		sty $2b				sty 	zTemp1+1
.1502					_IVCheckSpecial:
.1502	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.1504	d0 18		bne $151e			bne 	_IVStandard
.1506	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.1508	f0 0c		beq $1516			beq 	_IVTIFloat
.150a	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.150c	d0 10		bne $151e			bne 	_IVStandard
.150e	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.1510	a2 01		ldx #$01			ldx 	#$01
.1512	a9 40		lda #$40			lda 	#NSSString
.1514	38		sec				sec
.1515	60		rts				rts
.1516					_IVTIFloat:
.1516	a0 80		ldy #$80			ldy 	#$80
.1518	a2 00		ldx #$00			ldx 	#$00
.151a	a9 00		lda #$00			lda 	#0
.151c	38		sec				sec
.151d	60		rts				rts
.151e					_IVStandard:
.151e	a9 00		lda #$00			lda 	#((WorkArea) & $FF)
.1520	85 28		sta $28				sta 	0+zTemp0
.1522	a9 80		lda #$80			lda 	#((WorkArea) >> 8) & $FF
.1524	85 29		sta $29				sta 	1+zTemp0
.1526					_IVCheckLoop:
.1526	b2 28		lda ($28)			lda 	(zTemp0) 					; finished ?
.1528	f0 2b		beq $1555			beq  	_IVNotFound 				; if so, return with CC.
.152a	a0 01		ldy #$01			ldy 	#1 							; match ?
.152c	b1 28		lda ($28),y			lda 	(zTemp0),y
.152e	c5 2a		cmp $2a				cmp 	zTemp1
.1530	d0 07		bne $1539			bne	 	_IVNext
.1532	c8		iny				iny
.1533	b1 28		lda ($28),y			lda 	(zTemp0),y
.1535	c5 2b		cmp $2b				cmp 	zTemp1+1
.1537	f0 0d		beq $1546			beq 	_IVFound
.1539					_IVNext:
.1539	18		clc				clc
.153a	a5 28		lda $28				lda 	zTemp0
.153c	72 28		adc ($28)			adc 	(zTemp0)
.153e	85 28		sta $28				sta 	zTemp0
.1540	90 e4		bcc $1526			bcc 	_IVCheckLoop
.1542	e6 29		inc $29				inc 	zTemp0+1
.1544	80 e0		bra $1526			bra 	_IVCheckLoop
.1546					_IVFound:
.1546	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.1548	b1 28		lda ($28),y			lda 	(zTemp0),y
.154a	aa		tax				tax
.154b	c8		iny				iny
.154c	b1 28		lda ($28),y			lda 	(zTemp0),y
.154e	48		pha				pha
.154f	c8		iny				iny
.1550	b1 28		lda ($28),y			lda 	(zTemp0),y
.1552	7a		ply				ply
.1553	38		sec				sec
.1554	60		rts				rts
.1555					_IVNotFound:
.1555	a6 2a		ldx $2a				ldx 	zTemp1 						; get variable name back
.1557	a4 2b		ldy $2b				ldy 	zTemp1+1
.1559	18		clc				clc
.155a	60		rts				rts
.155b					FixBranches:
.155b	20 d5 1a	jsr $1ad5			jsr 	OUTPUTRewind 				; back to the start of the *object* code.
.155e					_FBLoop:
.155e	b2 25		lda ($25)			lda 	(objPtr) 					; get the next one.
.1560	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.1562	f0 16		beq $157a			beq 	_FBFixGotoGosub
.1564	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.1566	f0 12		beq $157a			beq 	_FBFixGotoGosub
.1568	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.156a	f0 0e		beq $157a			beq 	_FBFixGotoGosub
.156c	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.156e	f0 0a		beq $157a			beq 	_FBFixGotoGosub
.1570	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.1572	f0 49		beq $15bd			beq 	_FBFixVarSpace
.1574					_FBNext:
.1574	20 30 16	jsr $1630			jsr 	MoveObjectForward 			; move forward in object code.
.1577	90 e5		bcc $155e			bcc 	_FBLoop 					; not finished
.1579					_FBExit:
.1579	60		rts				rts
.157a					_FBFixGotoGosub:
.157a	a0 01		ldy #$01			ldy 	#1 							; if page is currently $FF
.157c	b1 25		lda ($25),y			lda 	(objPtr),y 					; then patch else leave.
.157e	c9 ff		cmp #$ff			cmp 	#$FF
.1580	d0 f2		bne $1574			bne 	_FBNext
.1582	a0 02		ldy #$02			ldy 	#2							; line number in YA
.1584	b1 25		lda ($25),y			lda 	(objPtr),y
.1586	48		pha				pha
.1587	c8		iny				iny
.1588	b1 25		lda ($25),y			lda 	(objPtr),y
.158a	a8		tay				tay
.158b	68		pla				pla
.158c	20 1e 1a	jsr $1a1e			jsr 	STRFindLine			 		; find where it is X:YA
.158f	90 08		bcc $1599			bcc 	_FBFFound 					; not found, so must be >
.1591	48		pha				pha
.1592	b2 25		lda ($25)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.1594	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1596	d0 15		bne $15ad			bne 	_FBFFail
.1598	68		pla				pla
.1599					_FBFFound:
.1599	20 73 1a	jsr $1a73			jsr 	STRMakeOffset 				; make it an offset from X:YA
.159c	5a		phy				phy	 								; patch the GOTO/GOSUB
.159d	48		pha				pha
.159e	a0 01		ldy #$01			ldy 	#1
.15a0	8a		txa				txa
.15a1	91 25		sta ($25),y			sta 	(objPtr),y
.15a3	c8		iny				iny
.15a4	68		pla				pla
.15a5	91 25		sta ($25),y			sta 	(objPtr),y
.15a7	c8		iny				iny
.15a8	68		pla				pla
.15a9	91 25		sta ($25),y			sta 	(objPtr),y
.15ab	80 c7		bra $1574			bra 	_FBNext
.15ad					_FBFFail:
.15ad	a0 02		ldy #$02			ldy 	#2
.15af	b1 25		lda ($25),y			lda 	(objPtr),y
.15b1	8d 00 05	sta $0500			sta 	currentLineNumber
.15b4	c8		iny				iny
.15b5	b1 25		lda ($25),y			lda 	(objPtr),y
.15b7	8d 01 05	sta $0501			sta 	currentLineNumber+1
.15ba	4c 72 13	jmp $1372		jmp	ErrorV_line
.15bd					_FBFixVarSpace:
.15bd	a0 01		ldy #$01			ldy 	#1
.15bf	ad 0e 06	lda $060e			lda 	freeVariableMemory
.15c2	91 25		sta ($25),y			sta 	(objPtr),y
.15c4	c8		iny				iny
.15c5	ad 0f 06	lda $060f			lda 	freeVariableMemory+1
.15c8	91 25		sta ($25),y			sta 	(objPtr),y
.15ca	80 a8		bra $1574			bra 	_FBNext
.15cc					CommandFOR:
.15cc	20 3e 18	jsr $183e			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.15cf	20 54 18	jsr $1854			jsr 	CharIsAlpha 				; if not alpha , error
.15d2	90 59		bcc $162d			bcc 	_CFFail
.15d4	20 e3 1b	jsr $1be3			jsr 	GetReferenceTerm 			; figure out the reference.
.15d7	48		pha				pha 								; save type
.15d8	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15da	c9 00		cmp #$00			cmp 	#NSSIFloat
.15dc	d0 4f		bne $162d			bne 	_CFFail
.15de	5a		phy				phy 								; save reference on the stack
.15df	da		phx				phx
.15e0	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.15e2	20 8f 10	jsr $108f			jsr 	CheckNextA
.15e5	20 44 14	jsr $1444			jsr 	CompileExpressionAt0 		; initial value
.15e8	fa		plx				plx 								; get reference back.
.15e9	7a		ply				ply
.15ea	5a		phy				phy
.15eb	da		phx				phx
.15ec	38		sec				sec 								; set initial value.
.15ed	20 95 1b	jsr $1b95			jsr 	GetSetVariable
.15f0	fa		plx				plx
.15f1	7a		ply				ply
.15f2	68		pla				pla
.15f3	29 20		and #$20			and 	#NSSIInt16
.15f5	f0 04		beq $15fb			beq 	_CFNotInt16
.15f7	98		tya				tya
.15f8	09 80		ora #$80			ora 	#$80
.15fa	a8		tay				tay
.15fb					_CFNotInt16:
.15fb	8a		txa				txa 								; reference in YA
.15fc	20 0e 11	jsr $110e			jsr 	PushIntegerYA
.15ff	a9 a4		lda #$a4			lda 	#C64_TO
.1601	20 8f 10	jsr $108f			jsr 	CheckNextA
.1604	20 44 14	jsr $1444			jsr 	CompileExpressionAt0 		; terminal value
.1607	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1609	c9 00		cmp #$00			cmp 	#NSSIFloat
.160b	d0 20		bne $162d			bne 	_CFFail
.160d	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; followed by STEP
.1610	c9 a9		cmp #$a9			cmp 	#C64_STEP
.1612	d0 0e		bne $1622			bne 	_CFNoStep
.1614	20 33 18	jsr $1833			jsr 	GetNext 					; consume it.
.1617	20 44 14	jsr $1444			jsr 	CompileExpressionAt0 		; terminal value
.161a	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.161c	c9 00		cmp #$00			cmp 	#NSSIFloat
.161e	d0 0d		bne $162d			bne 	_CFFail
.1620	80 05		bra $1627			bra 	_CFParametersDone
.1622					_CFNoStep:
.1622	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.1624	20 21 11	jsr $1121			jsr 	PushIntegerA
.1627					_CFParametersDone:
.1627	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.1629	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.162c	60		rts				rts
.162d					_CFFail:
.162d	4c 2f 13	jmp $132f		jmp	ErrorV_syntax
.1630					MoveObjectForward:
.1630	b2 25		lda ($25)			lda 	(objPtr) 					; get next
.1632	c9 ff		cmp #$ff			cmp 	#$FF
.1634	f0 36		beq $166c			beq 	_MOFEnd
.1636	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.1638	90 24		bcc $165e			bcc 	_MOFAdvance1 				; forward 1
.163a	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.163c	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.163e	90 20		bcc $1660			bcc 	_MOFAdvanceY
.1640	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.1642	90 1a		bcc $165e			bcc 	_MOFAdvance1 				; forward 1
.1644	a8		tay				tay 								; read the size.
.1645	b9 3b 1a	lda $1a3b,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.1648	a8		tay				tay
.1649	c8		iny				iny 								; add 1 for the system token.
.164a	d0 14		bne $1660			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.164c	a0 01		ldy #$01			ldy 	#1 							; get length byte
.164e	b1 25		lda ($25),y			lda 	(objPtr),y
.1650	a8		tay				tay 								; into Y.
.1651	18		clc				clc
.1652	a5 25		lda $25				lda 	objPtr						; add 2 to the object pointer
.1654	69 02		adc #$02			adc 	#2
.1656	85 25		sta $25				sta 	objPtr
.1658	90 02		bcc $165c			bcc 	_MOFNoCarry1
.165a	e6 26		inc $26				inc 	objPtr+1
.165c					_MOFNoCarry1:
.165c	80 02		bra $1660			bra 	_MOFAdvanceY
.165e					_MOFAdvance1:
.165e	a0 01		ldy #$01			ldy 	#1
.1660					_MOFAdvanceY:
.1660	98		tya				tya 								; add X to objPtr
.1661	18		clc				clc
.1662	65 25		adc $25				adc 	objPtr
.1664	85 25		sta $25				sta 	objPtr
.1666	90 02		bcc $166a			bcc 	_MOFNoCarry2
.1668	e6 26		inc $26				inc 	objPtr+1
.166a					_MOFNoCarry2:
.166a	18		clc				clc 								; not completed.
.166b	60		rts				rts
.166c					_MOFEnd:
.166c	e6 25		inc $25				inc 	objPtr
.166e	d0 02		bne $1672			bne 	_MOFENoCarry
.1670	e6 26		inc $26				inc 	objPtr+1
.1672					_MOFENoCarry:
.1672	38		sec				sec
.1673	60		rts				rts
.1674					INPUTOpen:
.1674	a9 aa		lda #$aa			lda 	#((EndProgram+2) & $FF)
.1676	85 30		sta $30				sta 	0+srcInputPtr
.1678	a9 23		lda #$23			lda 	#((EndProgram+2) >> 8) & $FF
.167a	85 31		sta $31				sta 	1+srcInputPtr
.167c					INPUTClose:
.167c	60		rts				rts
.167d					INPUTGet:
.167d	b2 30		lda ($30)			lda 	(srcInputPtr)
.167f	e6 30		inc $30				inc 	srcInputPtr
.1681	d0 02		bne $1685			bne 	_IGSkip
.1683	e6 31		inc $31				inc 	srcInputPtr+1
.1685					_IGSkip:
.1685	60		rts				rts
.0030					srcInputPtr:
>0030							.fill 	2
.1686					FNCompile:
.1686	20 3e 18	jsr $183e			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.1689	20 a3 18	jsr $18a3			jsr 	ExtractVariableName
.168c	e0 00		cpx #$00			cpx 	#0
.168e	10 32		bpl $16c2			bpl 	_FNError
.1690	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.1691	29 7f		and #$7f			and 	#$7F
.1693	aa		tax				tax
.1694	98		tya				tya
.1695	09 80		ora #$80			ora 	#$80
.1697	a8		tay				tay
.1698	20 fe 14	jsr $14fe			jsr 	FindVariable				; does it already exist ?
.169b	90 25		bcc $16c2			bcc 	_FNError 					; no.
.169d	20 73 1a	jsr $1a73			jsr 	STRMakeOffset 				; convert to a relative address.
.16a0	c9 00		cmp #$00			cmp 	#0 							; fix up.
.16a2	d0 01		bne $16a5			bne 	_FNNoBorrow
.16a4	88		dey				dey
.16a5					_FNNoBorrow:
.16a5	3a		dec a				dec 	a
.16a6	5a		phy				phy 								; save location of routine on stack.
.16a7	48		pha				pha
.16a8	da		phx				phx
.16a9	20 44 14	jsr $1444			jsr 	CompileExpressionAt0
.16ac	20 89 10	jsr $1089			jsr 	CheckNextRParen
.16af	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.16b1	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.16b4	68		pla				pla
.16b5	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.16b8	68		pla				pla
.16b9	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.16bc	68		pla				pla
.16bd	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.16c0	18		clc				clc
.16c1	60		rts				rts
.16c2					_FNError:
.16c2	4c 22 13	jmp $1322		jmp	ErrorV_value
.16c5					CommandTables:
>16c5	00						.byte 	0
.16c6					UnaryTables:
>16c6	00						.byte 	0
.16c7					GeneratorProcess:
.16c7	86 28		stx $28				stx 	zTemp0 						; save generation pointer in zTemp0
.16c9	84 29		sty $29				sty 	zTemp0+1
.16cb	85 2a		sta $2a				sta 	zTemp1 						; first match token
.16cd	64 2b		stz $2b				stz 	zTemp1+1
.16cf	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.16d1	d0 05		bne $16d8			bne 	_GPNotShifted
.16d3	20 33 18	jsr $1833			jsr 	GetNext 					; get the shifted token
.16d6	85 2b		sta $2b				sta 	zTemp1+1 					; match CE xx
.16d8					_GPNotShifted:
.16d8					_GPSearch:
.16d8	b2 28		lda ($28)			lda 	(zTemp0) 					; reached end ?
.16da	18		clc				clc
.16db	f0 2f		beq $170c			beq 	_GPExit
.16dd	a0 01		ldy #$01			ldy 	#1 							; tokens match
.16df	b1 28		lda ($28),y			lda 	(zTemp0),y
.16e1	c5 2a		cmp $2a				cmp 	zTemp1
.16e3	d0 09		bne $16ee			bne 	_GPNext
.16e5	a5 2b		lda $2b				lda 	zTemp1+1 					; 2nd token ?
.16e7	f0 12		beq $16fb			beq 	_GPFound
.16e9	c8		iny				iny 								; check match.
.16ea	d1 28		cmp ($28),y			cmp 	(zTemp0),y
.16ec	f0 0d		beq $16fb			beq 	_GPFound
.16ee					_GPNext:
.16ee	18		clc				clc 								; follow to next
.16ef	a5 28		lda $28				lda 	zTemp0
.16f1	72 28		adc ($28)			adc 	(zTemp0)
.16f3	85 28		sta $28				sta 	zTemp0
.16f5	90 e1		bcc $16d8			bcc 	_GPSearch
.16f7	e6 29		inc $29				inc 	zTemp0+1
.16f9	80 dd		bra $16d8			bra 	_GPSearch
.16fb					_GPFound:
.16fb	18		clc				clc 								; skip to action bytes
.16fc	a5 28		lda $28				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.16fe	69 03		adc #$03			adc 	#3
.1700	85 28		sta $28				sta 	zTemp0
.1702	90 02		bcc $1706			bcc 	_GPNoCarry
.1704	e6 29		inc $29				inc 	zTemp0+1
.1706					_GPNoCarry:
.1706					_GPLoop:
.1706	20 0d 17	jsr $170d			jsr 	GeneratorExecute 			; execute one command
.1709	90 fb		bcc $1706			bcc 	_GPLoop 					; go back if not completed.
.170b	38		sec				sec 								; return with CS.
.170c					_GPExit:
.170c	60		rts				rts
.170d					GeneratorExecute:
.170d	20 b8 17	jsr $17b8			jsr 	_GEFetchZTemp0 				; get next.
.1710	48		pha				pha 								; split into 2 nibbles
.1711	4a		lsr a				lsr 	a
.1712	4a		lsr a				lsr 	a
.1713	4a		lsr a				lsr		a
.1714	4a		lsr a				lsr 	a
.1715	20 1f 17	jsr $171f			jsr 	_GEExecuteNibble 			; MSB first
.1718	68		pla				pla
.1719	b0 03		bcs $171e			bcs 	_GEHaveCompleted
.171b	20 1f 17	jsr $171f			jsr 	_GEExecuteNibble 			; LSB second
.171e					_GEHaveCompleted:
.171e	60		rts				rts
.171f					_GEExecuteNibble:
.171f	29 0f		and #$0f			and 	#$0F
.1721	0a		asl a				asl 	a
.1722	aa		tax				tax
.1723	7c 26 17	jmp ($1726,x)			jmp 	(_GEExecuteVectors,x)
.1726					_GEExecuteVectors:
>1726	46 17						.word 	_GEXNop 					; 0  (no operation)
>1728	4e 17						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>172a	48 17						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>172c	9b 17						.word 	_GEXExecute 				; 3  (run arbitrary code)
>172e	8e 17						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>1730	46 17						.word 	_GEXNop 					; 5
>1732	55 17						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>1734	59 17						.word 	_GEXExitString 				; 7  exit return string type
>1736	5d 17						.word 	_GEXLParam 					; 8  check ( follows
>1738	61 17						.word 	_GEXRParam 					; 9  check ) follows
>173a	65 17						.word 	_GEXComma					; A  check , follows
>173c	46 17						.word 	_GEXNop 					; B
>173e	46 17						.word 	_GEXNop 					; C
>1740	46 17						.word 	_GEXNop 					; D
>1742	75 17						.word 	_GEXNumber 					; E  compile get any number
>1744	80 17						.word 	_GEXString 					; F  compile get any string
.1746					_GEXNop:
.1746	18		clc				clc
.1747	60		rts				rts
.1748					_GEXToken2:
.1748	20 b8 17	jsr $17b8			jsr 	_GEFetchZTemp0
.174b	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.174e					_GEXToken1:
.174e	20 b8 17	jsr $17b8			jsr 	_GEFetchZTemp0
.1751	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1754	60		rts				rts
.1755					_GEXExitNumber:
.1755	a9 00		lda #$00			lda 	#NSSIFloat
.1757	38		sec				sec
.1758	60		rts				rts
.1759					_GEXExitString:
.1759	a9 40		lda #$40			lda 	#NSSString
.175b	38		sec				sec
.175c	60		rts				rts
.175d					_GEXLParam:
.175d	a9 28		lda #$28			lda 	#"("
.175f	80 06		bra $1767			bra 	_GEXCheck
.1761					_GEXRParam:
.1761	a9 29		lda #$29			lda 	#")"
.1763	80 02		bra $1767			bra 	_GEXCheck
.1765					_GEXComma:
.1765	a9 2c		lda #$2c			lda 	#","
.1767					_GEXCheck:
.1767	85 2c		sta $2c				sta 	zTemp2 						; save match
.1769	20 3e 18	jsr $183e			jsr 	GetNextNonSpace 			; get next skipping spaces
.176c	c5 2c		cmp $2c				cmp 	zTemp2 						; check matches.
.176e	d0 02		bne $1772			bne 	_GEXSyntax
.1770	18		clc				clc
.1771	60		rts				rts
.1772					_GEXSyntax:
.1772	4c 2f 13	jmp $132f		jmp	ErrorV_syntax
.1775					_GEXNumber:
.1775	20 c1 17	jsr $17c1			jsr 	GEXCompileExpression 		; compile expression
.1778	29 40		and #$40			and 	#NSSTypeMask
.177a	c9 00		cmp #$00			cmp  	#NSSIFloat
.177c	d0 0d		bne $178b			bne 	_GEXType
.177e	18		clc				clc
.177f	60		rts				rts
.1780					_GEXString:
.1780	20 c1 17	jsr $17c1			jsr 	GEXCompileExpression 		; compile expression
.1783	29 40		and #$40			and 	#NSSTypeMask
.1785	c9 40		cmp #$40			cmp  	#NSSString
.1787	d0 02		bne $178b			bne 	_GEXType
.1789	18		clc				clc
.178a	60		rts				rts
.178b					_GEXType:
.178b	4c 3f 13	jmp $133f		jmp	ErrorV_type
.178e					_GEXChannelExec:
.178e	20 d1 17	jsr $17d1			jsr 	ChannelPrefix 				; set up default
.1791	20 9b 17	jsr $179b			jsr 	_GEXExecute
.1794	08		php				php
.1795	20 eb 17	jsr $17eb			jsr 	ChannelPostfix 				; replace default.
.1798	28		plp				plp
.1799	60		rts				rts
>179a	db						.byte 	$DB 						; causes a break in the emulator
.179b					_GEXExecute:
.179b	20 b8 17	jsr $17b8			jsr 	_GEFetchZTemp0 				; get vector
.179e	85 2c		sta $2c				sta 	zTemp2
.17a0	20 b8 17	jsr $17b8			jsr 	_GEFetchZTemp0
.17a3	85 2d		sta $2d				sta 	zTemp2+1
.17a5	a6 28		ldx $28				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.17a7	da		phx				phx
.17a8	a6 29		ldx $29				ldx 	zTemp0+1
.17aa	da		phx				phx
.17ab	20 b5 17	jsr $17b5			jsr 	_GECallZTemp2 				; execute code
.17ae	fa		plx				plx 								; recover generation exec
.17af	86 29		stx $29				stx 	zTemp0+1
.17b1	fa		plx				plx
.17b2	86 28		stx $28				stx 	zTemp0
.17b4	60		rts				rts
.17b5					_GECallZTemp2:
.17b5	6c 2c 00	jmp ($002c)			jmp 	(zTemp2)
.17b8					_GEFetchZTemp0:
.17b8	b2 28		lda ($28)			lda 	(zTemp0)
.17ba	e6 28		inc $28				inc 	zTemp0
.17bc	d0 02		bne $17c0			bne 	_GEFZ0Skip
.17be	e6 29		inc $29				inc 	zTemp0+1
.17c0					_GEFZ0Skip:
.17c0	60		rts				rts
.17c1					GEXCompileExpression:
.17c1	a6 28		ldx $28				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.17c3	da		phx				phx
.17c4	a6 29		ldx $29				ldx 	zTemp0+1
.17c6	da		phx				phx
.17c7	20 44 14	jsr $1444			jsr 	CompileExpressionAt0 		; compile expression.
.17ca	fa		plx				plx 								; recover generation exec
.17cb	86 29		stx $29				stx 	zTemp0+1
.17cd	fa		plx				plx
.17ce	86 28		stx $28				stx 	zTemp0
.17d0	60		rts				rts
.17d1					ChannelPrefix:
.17d1	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.17d3	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.17d6	20 c1 17	jsr $17c1			jsr 	GEXCompileExpression 		; channel #
.17d9	29 40		and #$40			and 	#NSSTypeMask
.17db	c9 00		cmp #$00			cmp 	#NSSIFloat
.17dd	d0 09		bne $17e8			bne 	_CPXType
.17df	20 85 10	jsr $1085			jsr 	CheckNextComma 				; check , follows.
.17e2	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.17e4	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.17e7	60		rts				rts
.17e8					_CPXType:
.17e8	4c 3f 13	jmp $133f		jmp	ErrorV_type
.17eb					ChannelPostfix:
.17eb	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.17ed	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.17f0	60		rts				rts
.17f1					OptionalParameterCompile:
.17f1	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; what follows.
.17f4	c9 2c		cmp #$2c			cmp 	#","
.17f6	d0 0e		bne $1806			bne 	_MidDefault
.17f8	20 33 18	jsr $1833			jsr 	GetNext 					; consume ,
.17fb	20 44 14	jsr $1444			jsr 	CompileExpressionAt0
.17fe	29 40		and #$40			and 	#NSSTypeMask
.1800	c9 00		cmp #$00			cmp 	#NSSIFloat
.1802	d0 09		bne $180d			bne 	MidFailType
.1804	80 05		bra $180b			bra 	_MidComplete
.1806					_MidDefault:
.1806	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1808	20 21 11	jsr $1121			jsr 	PushIntegerA
.180b					_MidComplete:
.180b	18		clc				clc
.180c	60		rts				rts
.180d					MidFailType:
.180d	4c 3f 13	jmp $133f		jmp	ErrorV_type
.1810					NotUnaryCompile:
.1810	ad f9 14	lda $14f9			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1813	20 46 14	jsr $1446			jsr 	CompileExpressionAtA 		; evaluate at that level
.1816	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1818	c9 00		cmp #$00			cmp 	#NSSIFloat
.181a	d0 f1		bne $180d			bne 	MidFailType
.181c	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.181e	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1821	60		rts				rts
.1822					LookNext:
.1822	b2 2e		lda ($2e)			lda 	(srcPtr)
.1824	60		rts				rts
.1825					LookNextNonSpace:
.1825	b2 2e		lda ($2e)			lda 	(srcPtr)
.1827	c9 20		cmp #$20			cmp		#' '
.1829	f0 03		beq $182e			beq 	_LNNSkip
.182b	c9 00		cmp #$00			cmp 	#0
.182d	60		rts				rts
.182e					_LNNSkip:
.182e	20 33 18	jsr $1833			jsr 	GetNext
.1831	80 f2		bra $1825			bra 	LookNextNonSpace
.1833					GetNext:
.1833	b2 2e		lda ($2e)			lda 	(srcPtr) 					; get next
.1835	e6 2e		inc $2e				inc 	srcPtr
.1837	d0 02		bne $183b			bne 	_GNSkip
.1839	e6 2f		inc $2f				inc 	srcPtr+1
.183b					_GNSkip:
.183b	c9 00		cmp #$00			cmp 	#0
.183d	60		rts				rts
.183e					GetNextNonSpace:
.183e	20 33 18	jsr $1833			jsr 	GetNext
.1841	c9 20		cmp #$20			cmp 	#' '
.1843	f0 f9		beq $183e			beq 	GetNextNonSpace
.1845	c9 00		cmp #$00			cmp 	#0
.1847	60		rts				rts
.1848					CharIsDigit:
.1848	c9 30		cmp #$30			cmp 	#"0"
.184a	90 06		bcc $1852			bcc 	CCFalse
.184c	c9 3a		cmp #$3a			cmp 	#"9"+1
.184e	b0 02		bcs $1852			bcs 	CCFalse
.1850					CCTrue:
.1850	38		sec				sec
.1851	60		rts				rts
.1852					CCFalse:
.1852	18		clc				clc
.1853	60		rts				rts
.1854					CharIsAlpha:
.1854	c9 41		cmp #$41			cmp 	#"A"
.1856	90 fa		bcc $1852			bcc 	CCFalse
.1858	c9 5b		cmp #$5b			cmp 	#"Z"+1
.185a	b0 f6		bcs $1852			bcs 	CCFalse
.185c	80 f2		bra $1850			bra 	CCTrue
.185e					ConvertHexStyle:
.185e	38		sec				sec
.185f	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1861	90 ef		bcc $1852			bcc 	CCFalse
.1863	c9 0a		cmp #$0a			cmp 	#9+1
.1865	90 e9		bcc $1850			bcc 	CCTrue
.1867	38		sec				sec 								; shift into hex space A=>0 Z=>25
.1868	e9 11		sbc #$11			sbc 	#"A"-"0"
.186a	90 e6		bcc $1852			bcc 	CCFalse
.186c	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.186e	b0 e2		bcs $1852			bcs 	CCFalse
.1870	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.1872	80 dc		bra $1850			bra 	CCTrue
.1874					CommandGET:
.1874	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; # follows ?
.1877	c9 23		cmp #$23			cmp 	#"#"
.1879	d0 0d		bne $1888			bne 	CommandGetBody
.187b	20 33 18	jsr $1833			jsr 	GetNext 					; consume #
.187e	20 d1 17	jsr $17d1			jsr 	ChannelPrefix 				; do it as GET#
.1881	20 88 18	jsr $1888			jsr 	CommandGetBody
.1884	20 eb 17	jsr $17eb			jsr 	ChannelPostfix
.1887	60		rts				rts
.1888					CommandGetBody:
.1888	20 3e 18	jsr $183e			jsr 	GetNextNonSpace 			; get the first character
.188b	20 e3 1b	jsr $1be3			jsr 	GetReferenceTerm 			; identify variable to assign to
.188e	48		pha				pha
.188f	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1891	c9 40		cmp #$40			cmp 	#NSSString
.1893	d0 0b		bne $18a0			bne 	_CGType
.1895	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1897	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.189a	38		sec				sec
.189b	68		pla				pla
.189c	20 95 1b	jsr $1b95			jsr		GetSetVariable
.189f	60		rts				rts
.18a0					_CGType:
.18a0	4c 3f 13	jmp $133f		jmp	ErrorV_type
.18a3					ExtractVariableName:
.18a3	20 54 18	jsr $1854			jsr 	CharIsAlpha
.18a6	90 50		bcc $18f8			bcc 	_IVSyntax
.18a8	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.18aa	85 2a		sta $2a				sta 	zTemp1 						; we'll build it in zTemp1
.18ac	64 2b		stz $2b				stz 	zTemp1+1
.18ae	20 22 18	jsr $1822			jsr 	LookNext 					; is there a second character ?
.18b1	20 54 18	jsr $1854			jsr 	CharIsAlpha  				; must be alphanumeric
.18b4	b0 05		bcs $18bb			bcs 	_IVHasSecond
.18b6	20 48 18	jsr $1848			jsr 	CharIsDigit
.18b9	90 07		bcc $18c2			bcc 	_IVCheckType
.18bb					_IVHasSecond:
.18bb	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.18bd	85 2b		sta $2b				sta 	zTemp1+1
.18bf					_IVGetNextCheck:
.18bf	20 33 18	jsr $1833			jsr 	GetNext 					; consume it
.18c2					_IVCheckType:
.18c2	20 22 18	jsr $1822			jsr 	LookNext					; check if string follows.
.18c5	20 54 18	jsr $1854			jsr 	CharIsAlpha
.18c8	b0 f5		bcs $18bf			bcs 	_IVGetNextCheck
.18ca	20 48 18	jsr $1848			jsr 	CharIsDigit
.18cd	b0 f0		bcs $18bf			bcs 	_IVGetNextCheck
.18cf	a2 40		ldx #$40			ldx 	#NSSString
.18d1	c9 24		cmp #$24			cmp 	#"$"
.18d3	f0 06		beq $18db			beq 	_IVHasType
.18d5	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.18d7	c9 25		cmp #$25			cmp 	#"%"
.18d9	d0 08		bne $18e3			bne 	_IVCheckArray
.18db					_IVHasType:
.18db	8a		txa				txa 								; Or X into zTemp1
.18dc	05 2a		ora $2a				ora 	zTemp1
.18de	85 2a		sta $2a				sta 	zTemp1
.18e0	20 33 18	jsr $1833			jsr 	GetNext 					; consume it
.18e3					_IVCheckArray:
.18e3	20 22 18	jsr $1822			jsr 	LookNext 					; check if array follows
.18e6	c9 28		cmp #$28			cmp 	#"("
.18e8	d0 09		bne $18f3			bne 	_IVNotArray
.18ea	a5 2a		lda $2a				lda 	zTemp1 						; set array bit
.18ec	09 80		ora #$80			ora 	#NSSArray
.18ee	85 2a		sta $2a				sta 	zTemp1
.18f0	20 33 18	jsr $1833			jsr 	GetNext 					; consume it
.18f3					_IVNotArray:
.18f3	a6 2a		ldx $2a				ldx 	zTemp1
.18f5	a4 2b		ldy $2b				ldy 	zTemp1+1
.18f7	60		rts				rts
.18f8					_IVSyntax:
.18f8	4c 2f 13	jmp $132f		jmp	ErrorV_syntax
.18fb					CommandGOSUB:
.18fb	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.18fd	20 0e 19	jsr $190e			jsr 	CompileBranchCommand
.1900	60		rts				rts
.1901					CommandGOAlt:
.1901	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1903	20 8f 10	jsr $108f			jsr 	CheckNextA
.1906	80 00		bra $1908			bra 	CommandGOTO
.1908					CommandGOTO:
.1908	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.190a	20 0e 19	jsr $190e			jsr 	CompileBranchCommand
.190d	60		rts				rts
.190e					CompileBranchCommand:
.190e	20 7b 10	jsr $107b			jsr 	WriteCodeByte 				; write the command out.
.1911	20 3e 18	jsr $183e			jsr 	GetNextNonSpace
.1914	20 e0 1a	jsr $1ae0			jsr 	ParseConstant 				; get constant into YA
.1917	90 0f		bcc $1928			bcc 	_CBCSyntax
.1919	48		pha				pha
.191a	a9 ff		lda #$ff			lda 	#$FF 						; no address yet.
.191c	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.191f	68		pla				pla 								; and compile the actual line number
.1920	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1923	98		tya				tya
.1924	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1927	60		rts				rts
.1928					_CBCSyntax:
.1928	4c 2f 13	jmp $132f		jmp	ErrorV_syntax
.192b					CommandIF:
.192b	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; what follows the tests ?
.192e	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1930	f0 0f		beq $1941			beq 	_CIGoto
.1932	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1934	20 8f 10	jsr $108f			jsr 	CheckNextA
.1937	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; THEN <number>
.193a	20 48 18	jsr $1848			jsr 	CharIsDigit
.193d	b0 05		bcs $1944			bcs 	_CIGoto2
.193f	80 09		bra $194a			bra 	CompileGotoEOL
.1941					_CIGoto:
.1941	20 33 18	jsr $1833			jsr 	GetNext
.1944					_CIGoto2:
.1944	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1946	20 0e 19	jsr $190e			jsr 	CompileBranchCommand
.1949	60		rts				rts
.194a					CompileGotoEOL:
.194a	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.194c	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.194f	a9 ff		lda #$ff			lda 	#$FF
.1951	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1954	20 e9 19	jsr $19e9			jsr 	GetLineNumber 				; Get the current line number => YA
.1957	1a		inc a				inc 	a 							; and branch to +1
.1958	d0 01		bne $195b			bne 	_CGENoCarry
.195a	c8		iny				iny
.195b					_CGENoCarry:
.195b	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.195e	98		tya				tya
.195f	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1962	60		rts				rts
.1963					CommandINPUT:
.1963	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; check for "
.1966	c9 22		cmp #$22			cmp 	#'"'
.1968	d0 0d		bne $1977			bne 	CommandINPUTStream
.196a	20 44 14	jsr $1444			jsr 	CompileExpressionAt0
.196d	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.196f	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1972	a9 2c		lda #$2c			lda 	#","
.1974	20 85 10	jsr $1085			jsr 	CheckNextComma
.1977					CommandINPUTStream:
.1977	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1979	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.197c	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.197e	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1980	4c 5d 1b	jmp $1b5d			jmp 	CommandReadInputCommon
.1983					CommandLET:
.1983	20 3e 18	jsr $183e			jsr 	GetNextNonSpace 			; get the first character
.1986					CommandLETHaveFirst:
.1986	20 e3 1b	jsr $1be3			jsr 	GetReferenceTerm 			; identify variable to assign to
.1989	da		phx				phx 								; save target on the stack.
.198a	5a		phy				phy
.198b	48		pha				pha
.198c	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.198e	20 8f 10	jsr $108f			jsr 	CheckNextA
.1991	20 44 14	jsr $1444			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1994	85 28		sta $28				sta 	zTemp0 						; save type returned
.1996	68		pla				pla 								; get type of assignment
.1997	48		pha				pha
.1998	45 28		eor $28				eor 	zTemp0 						; compare using EOR
.199a	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.199c	d0 17		bne $19b5			bne 	_CLType
.199e	68		pla				pla 								; restore and compile save code
.199f	7a		ply				ply
.19a0	fa		plx				plx
.19a1	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.19a3	f0 05		beq $19aa			beq 	_CLTIString
.19a5	38		sec				sec
.19a6	20 95 1b	jsr $1b95			jsr		GetSetVariable
.19a9	60		rts				rts
.19aa					_CLTIString:
.19aa	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.19ac	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.19af	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.19b1	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.19b4	60		rts				rts
.19b5					_CLType:
.19b5	4c 3f 13	jmp $133f		jmp	ErrorV_type
.19b8					ReadNextLine:
.19b8	20 7d 16	jsr $167d			jsr 	INPUTGet 					; check offset is not zero.
.19bb	85 28		sta $28				sta 	zTemp0
.19bd	20 7d 16	jsr $167d			jsr 	INPUTGet
.19c0	05 28		ora $28				ora 	zTemp0
.19c2	d0 02		bne $19c6			bne 	_RNLBody
.19c4	18		clc				clc
.19c5	60		rts				rts						; end of file.
.19c6					_RNLBody:
.19c6	20 7d 16	jsr $167d			jsr 	INPUTGet 					; read and save line number
.19c9	8d 00 05	sta $0500			sta 	currentLineNumber
.19cc	20 7d 16	jsr $167d			jsr 	INPUTGet
.19cf	8d 01 05	sta $0501			sta 	currentLineNumber+1
.19d2	a2 00		ldx #$00			ldx 	#0 							; read line into buffer
.19d4					_RNLRead:
.19d4	20 7d 16	jsr $167d			jsr 	INPUTGet
.19d7	9d 00 04	sta $0400,x			sta 	sourceBuffer,x
.19da	e8		inx				inx
.19db	c9 00		cmp #$00			cmp 	#0
.19dd	d0 f5		bne $19d4			bne 	_RNLRead
.19df	a9 00		lda #$00			lda 	#((sourceBuffer) & $FF)
.19e1	85 2e		sta $2e				sta 	0+srcPtr
.19e3	a9 04		lda #$04			lda 	#((sourceBuffer) >> 8) & $FF
.19e5	85 2f		sta $2f				sta 	1+srcPtr
.19e7	38		sec				sec
.19e8	60		rts				rts
.19e9					GetLineNumber:
.19e9	ac 01 05	ldy $0501			ldy 	currentLineNumber+1
.19ec	ad 00 05	lda $0500			lda 	currentLineNumber
.19ef	60		rts				rts
.19f0					STRMarkLine:
.19f0	48		pha				pha
.19f1	38		sec				sec 								; allocate 5 bytes (line #, page+address)
.19f2	ad 0a 06	lda $060a			lda 	lineNumberTable 			; and copy to zTemp0
.19f5	e9 05		sbc #$05			sbc 	#5
.19f7	8d 0a 06	sta $060a			sta 	lineNumberTable
.19fa	85 28		sta $28				sta 	zTemp0
.19fc	ad 0b 06	lda $060b			lda 	lineNumberTable+1
.19ff	e9 00		sbc #$00			sbc 	#0
.1a01	8d 0b 06	sta $060b			sta 	lineNumberTable+1
.1a04	85 29		sta $29				sta 	zTemp0+1
.1a06	68		pla				pla
.1a07	92 28		sta ($28)			sta 	(zTemp0) 					; save it in +0,+1
.1a09	98		tya				tya
.1a0a	a0 01		ldy #$01			ldy 	#1
.1a0c	91 28		sta ($28),y			sta 	(zTemp0),y
.1a0e	a5 27		lda $27				lda 	objPage 					; and page# in +2
.1a10	c8		iny				iny
.1a11	91 28		sta ($28),y			sta 	(zTemp0),y
.1a13	a5 25		lda $25				lda 	objPtr 						; save current address in +3,+4
.1a15	c8		iny				iny
.1a16	91 28		sta ($28),y			sta 	(zTemp0),y
.1a18	a5 26		lda $26				lda 	objPtr+1
.1a1a	c8		iny				iny
.1a1b	91 28		sta ($28),y			sta 	(zTemp0),y
.1a1d	60		rts				rts
.1a1e					STRFindLine:
.1a1e	85 28		sta $28				sta 	zTemp0 						; zTemp0 line number being searched
.1a20	84 29		sty $29				sty 	zTemp0+1
.1a22	a9 00		lda #$00			lda 	#((WorkArea+WorkAreaSize) & $FF)
.1a24	85 2a		sta $2a				sta 	0+zTemp1
.1a26	a9 9f		lda #$9f			lda 	#((WorkArea+WorkAreaSize) >> 8) & $FF
.1a28	85 2b		sta $2b				sta 	1+zTemp1
.1a2a					_STRSearch:
.1a2a	20 65 1a	jsr $1a65			jsr 	_STRPrevLine 				; look at previous record.
.1a2d	a0 01		ldy #$01			ldy 	#1
.1a2f	b2 2a		lda ($2a)			lda 	(zTemp1) 					; check table line # >= target
.1a31	c5 28		cmp $28				cmp 	zTemp0
.1a33	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.1a35	e5 29		sbc $29				sbc 	zTemp0+1
.1a37	b0 0b		bcs $1a44			bcs 	_STRFound 					; >=
.1a39					_STRNext:
.1a39	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1a3b	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.1a3d	c9 ff		cmp #$ff			cmp 	#$FF
.1a3f	d0 e9		bne $1a2a			bne 	_STRSearch
.1a41	4c 89 13	jmp $1389		jmp	ErrorV_internal
.1a44					_STRFound:
.1a44	b2 2a		lda ($2a)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1a46	45 28		eor $28				eor 	zTemp0
.1a48	d0 06		bne $1a50			bne 	_STRDifferent
.1a4a	b2 2a		lda ($2a)			lda 	(zTemp1)
.1a4c	45 28		eor $28				eor 	zTemp0
.1a4e	f0 02		beq $1a52			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1a50					_STRDifferent:
.1a50	a9 ff		lda #$ff			lda 	#$FF
.1a52					_STROut:
.1a52	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1a53	69 ff		adc #$ff			adc 	#255
.1a55	08		php				php
.1a56	c8		iny				iny 								; page into X
.1a57	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.1a59	aa		tax				tax
.1a5a	c8		iny				iny 								; address into YA
.1a5b	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.1a5d	48		pha				pha
.1a5e	c8		iny				iny
.1a5f	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.1a61	a8		tay				tay
.1a62	68		pla				pla
.1a63	28		plp				plp
.1a64	60		rts				rts
.1a65					_STRPrevLine:
.1a65	38		sec				sec 								; move backwards one entry.
.1a66	a5 2a		lda $2a				lda 	zTemp1
.1a68	e9 05		sbc #$05			sbc 	#5
.1a6a	85 2a		sta $2a				sta 	zTemp1
.1a6c	a5 2b		lda $2b				lda 	zTemp1+1
.1a6e	e9 00		sbc #$00			sbc 	#0
.1a70	85 2b		sta $2b				sta 	zTemp1+1
.1a72	60		rts				rts
.1a73					STRMakeOffset:
.1a73	18		clc				clc 								; borrow 1
.1a74	e5 25		sbc $25				sbc 	objPtr
.1a76	48		pha				pha
.1a77	98		tya				tya
.1a78	e5 26		sbc $26				sbc 	objPtr+1
.1a7a	a8		tay				tay
.1a7b	68		pla				pla
.1a7c	60		rts				rts
.1a7d					CommandNEXT:
.1a7d	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1a80	20 54 18	jsr $1854			jsr 	CharIsAlpha 				; if not alpha , error
.1a83	90 0c		bcc $1a91			bcc 	_CNNoReferenceGiven
.1a85	20 33 18	jsr $1833			jsr 	GetNext
.1a88	20 e3 1b	jsr $1be3			jsr 	GetReferenceTerm 			; figure out the reference.
.1a8b	8a		txa				txa 								; reference in YA
.1a8c	20 0e 11	jsr $110e			jsr 	PushIntegerYA 				; write it out.
.1a8f	80 06		bra $1a97			bra 	_CNParametersDone
.1a91					_CNNoReferenceGiven:
.1a91	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1a93	a8		tay				tay
.1a94	20 0e 11	jsr $110e			jsr 	PushIntegerYA 				; write it out.
.1a97					_CNParametersDone:
.1a97	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1a99	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1a9c	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; look for ,
.1a9f	c9 2c		cmp #$2c			cmp 	#","
.1aa1	d0 05		bne $1aa8			bne 	_CNExit
.1aa3	20 33 18	jsr $1833			jsr 	GetNext 					; consume ,
.1aa6	80 d5		bra $1a7d			bra 	CommandNEXT 				; and go round.
.1aa8					_CNExit:
.1aa8	60		rts				rts
.1aa9					CommandON:
.1aa9	20 3e 18	jsr $183e			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1aac	48		pha				pha 								; save on stack
.1aad	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1aaf	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1ab1	f0 09		beq $1abc			beq 	_COCreateLoop
.1ab3	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1ab5	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1ab7	f0 03		beq $1abc			beq 	_COCreateLoop
.1ab9	4c 2f 13	jmp $132f		jmp	ErrorV_syntax
.1abc					_COCreateLoop:
.1abc	8a		txa				txa 								; compile a goto/gosub somewhere
.1abd	da		phx				phx
.1abe	20 0e 19	jsr $190e			jsr 	CompileBranchCommand
.1ac1	fa		plx				plx
.1ac2	20 25 18	jsr $1825			jsr 	LookNextNonSpace			; ',' follows
.1ac5	c9 2c		cmp #$2c			cmp 	#","
.1ac7	d0 0a		bne $1ad3			bne 	_COComplete 				; if so, more line numbers
.1ac9	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1acb	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1ace	20 33 18	jsr $1833			jsr 	GetNext
.1ad1	80 e9		bra $1abc			bra 	_COCreateLoop
.1ad3					_COComplete:
.1ad3	68		pla				pla 								; throw GOTO/GOSUB
.1ad4	60		rts				rts
.1ad5					OUTPUTOpen:
.1ad5					OUTPUTRewind:
.1ad5	64 27		stz $27				stz 	objPage
.1ad7	a9 00		lda #$00			lda 	#((PCodeStart) & $FF)
.1ad9	85 25		sta $25				sta 	0+objPtr
.1adb	a9 40		lda #$40			lda 	#((PCodeStart) >> 8) & $FF
.1add	85 26		sta $26				sta 	1+objPtr
.1adf	60		rts				rts
.1ae0					ParseConstant:
.1ae0	a2 00		ldx #$00			ldx 	#0
.1ae2	20 5d 21	jsr $215d			jsr 	FloatEncodeStart 			; send first
.1ae5					_ParseLoop:
.1ae5	20 22 18	jsr $1822			jsr 	LookNext 					; send subsequent
.1ae8	20 60 21	jsr $2160			jsr 	FloatEncodeContinue
.1aeb	90 05		bcc $1af2			bcc 	_ParseDone
.1aed	20 33 18	jsr $1833			jsr 	GetNext 					; consume it
.1af0	80 f3		bra $1ae5			bra 	_ParseLoop
.1af2					_ParseDone:
.1af2	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1af4	29 80		and #$80			and 	#$80
.1af6	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.1af8	15 56		ora $56,x			ora 	NSMantissa2,x
.1afa	15 62		ora $62,x			ora 	NSMantissa3,x
.1afc	18		clc				clc
.1afd	d0 05		bne $1b04			bne 	_ParseExit 					; exit with CC if need float to compile
.1aff	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.1b01	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.1b03	38		sec				sec
.1b04					_ParseExit:
.1b04	60		rts				rts
.1b05					MOFSizeTable:
>1b05	01					.byte	1         	; $ca .shift
>1b06	01					.byte	1         	; $cb .byte
>1b07	02					.byte	2         	; $cc .word
>1b08	05					.byte	5         	; $cd .float
>1b09	ff					.byte	255       	; $ce .string
>1b0a	ff					.byte	255       	; $cf .data
>1b0b	03					.byte	3         	; $d0 .goto
>1b0c	03					.byte	3         	; $d1 .gosub
>1b0d	03					.byte	3         	; $d2 .goto.z
>1b0e	03					.byte	3         	; $d3 .goto.nz
>1b0f	02					.byte	2         	; $d4 .varspace
.1b10					CommandPRINT:
.1b10	20 25 18	jsr $1825			jsr 	LookNextNonSpace			; what follows ?
.1b13	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1b15	f0 1f		beq $1b36			beq 	_CPCheckEnd
.1b17	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1b19	f0 16		beq $1b31			beq 	_CPTabCheckEnd
.1b1b	20 4d 1b	jsr $1b4d			jsr 	_CPAtEnd 					; check for : and EOL
.1b1e	b0 22		bcs $1b42			bcs 	_CPExitCR 					; exit with CR
.1b20	20 44 14	jsr $1444			jsr 	CompileExpressionAt0 		; so it is something to print
.1b23	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1b25	29 40		and #$40			and 	#NSSString 					; if string
.1b27	d0 02		bne $1b2b			bne 	_CPOut
.1b29	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1b2b					_CPOut:
.1b2b	8a		txa				txa 								; print that thing
.1b2c	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1b2f	80 df		bra $1b10			bra 	CommandPRINT 				; and loop round/
.1b31					_CPTabCheckEnd:
.1b31	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1b33	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1b36					_CPCheckEnd:
.1b36	20 33 18	jsr $1833			jsr 	GetNext 					; consume it.
.1b39	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; what follows ?
.1b3c	20 4d 1b	jsr $1b4d			jsr 	_CPAtEnd 					; reached end
.1b3f	90 cf		bcc $1b10			bcc 	CommandPRINT 				; no, loop back
.1b41	60		rts				rts
.1b42					_CPExitCR:
.1b42	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1b44	20 21 11	jsr $1121			jsr 	PushIntegerA
.1b47	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1b49	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1b4c	60		rts				rts
.1b4d					_CPAtEnd:
.1b4d	c9 00		cmp #$00			cmp 	#0
.1b4f	f0 06		beq $1b57			beq 	_CPIsEnd
.1b51	c9 3a		cmp #$3a			cmp 	#":"
.1b53	f0 02		beq $1b57			beq 	_CPIsEnd
.1b55	18		clc				clc
.1b56	60		rts				rts
.1b57					_CPIsEnd:
.1b57	38		sec				sec
.1b58	60		rts				rts
.1b59					CommandREAD:
.1b59	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1b5b	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1b5d					CommandReadInputCommon:
.1b5d	8e 08 06	stx $0608			stx 	numberPCode
.1b60	8c 09 06	sty $0609			sty 	stringPCode
.1b63					_CRLoop:
.1b63	20 3e 18	jsr $183e			jsr 	GetNextNonSpace 			; first char of identifier
.1b66	20 54 18	jsr $1854			jsr 	CharIsAlpha 				; check A-Z
.1b69	90 27		bcc $1b92			bcc 	_CRSyntax
.1b6b	20 e3 1b	jsr $1be3			jsr 	GetReferenceTerm 			; get the variable.
.1b6e	48		pha				pha 								; save type.
.1b6f	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1b71	c9 40		cmp #$40			cmp 	#NSSString
.1b73	f0 05		beq $1b7a			beq 	_CRString
.1b75	ad 08 06	lda $0608			lda 	numberPCode 				; output read/input
.1b78	80 03		bra $1b7d			bra 	_CRHaveType
.1b7a					_CRString:
.1b7a	ad 09 06	lda $0609			lda 	stringPCode					; output read$/input$
.1b7d					_CRHaveType:
.1b7d	20 7b 10	jsr $107b			jsr 	WriteCodeByte 				; so we have one typed data item.
.1b80	68		pla				pla 								; restore type
.1b81	38		sec				sec  								; write update code.
.1b82	20 95 1b	jsr $1b95			jsr 	GetSetVariable
.1b85	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; , follows ?
.1b88	c9 2c		cmp #$2c			cmp 	#","
.1b8a	d0 05		bne $1b91			bne 	_CRExit 					; if not, end of READ.
.1b8c	20 33 18	jsr $1833			jsr 	GetNext 					; consume comma
.1b8f	80 d2		bra $1b63			bra 	_CRLoop 					; keep going
.1b91					_CRExit:
.1b91	60		rts				rts
.1b92					_CRSyntax:
.1b92	4c 2f 13	jmp $132f		jmp	ErrorV_syntax
.0608					numberPCode:
>0608							.fill 	1
.0609					stringPCode:
>0609							.fill 	1
.1b95					GetSetVariable:
.1b95	08		php				php 								; save direction on stack
.1b96	c0 00		cpy #$00			cpy 	#$00
.1b98	30 21		bmi $1bbb			bmi 	_GSVReadWriteSpecial
.1b9a	c9 00		cmp #$00			cmp 	#$00
.1b9c	30 33		bmi $1bd1			bmi 	_GSVArray
.1b9e	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1ba0	4a		lsr a				lsr 	a 							; divide by 2
.1ba1	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1ba3	28		plp				plp
.1ba4	90 02		bcc $1ba8			bcc 	_GSVNotWrite
.1ba6	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1ba8					_GSVNotWrite:
.1ba8	85 28		sta $28				sta 	zTemp0
.1baa	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1bab	4a		lsr a				lsr 	a
.1bac	a8		tay				tay
.1bad	8a		txa				txa
.1bae	6a		ror a				ror 	a
.1baf	aa		tax				tax
.1bb0	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1bb1	05 28		ora $28				ora 	zTemp0 						; which is the first byte of the opcode
.1bb3	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1bb6	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1bb7	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1bba	60		rts				rts
.1bbb					_GSVReadWriteSpecial:
.1bbb	28		plp				plp
.1bbc	b0 10		bcs $1bce			bcs 	_GSVSyntax
.1bbe	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1bc0	f0 06		beq $1bc8			beq 	_GSVRWString
.1bc2	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1bc4	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1bc7	60		rts				rts
.1bc8					_GSVRWString:
.1bc8	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1bca	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1bcd	60		rts				rts
.1bce					_GSVSyntax:
.1bce	4c 2f 13	jmp $132f		jmp	ErrorV_syntax
.1bd1					_GSVArray:
.1bd1	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1bd3	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1bd4	4a		lsr a				lsr 	a
.1bd5	4a		lsr a				lsr 	a
.1bd6	4a		lsr a				lsr 	a
.1bd7	4a		lsr a				lsr 	a
.1bd8	28		plp				plp 								; if writing array then set bit 2.
.1bd9	90 02		bcc $1bdd			bcc 	_GSVANotWrite
.1bdb	09 04		ora #$04			ora 	#4
.1bdd					_GSVANotWrite:
.1bdd	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1bdf	20 7b 10	jsr $107b			jsr 	WriteCodeByte 				; and write it out
.1be2	60		rts				rts
.1be3					GetReferenceTerm:
.1be3	20 a3 18	jsr $18a3			jsr 	ExtractVariableName 		; get name & type info
.1be6	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1be8	30 10		bmi $1bfa			bmi 	_GRTArray
.1bea	da		phx				phx 								; save type on stack
.1beb	20 fe 14	jsr $14fe			jsr 	FindVariable 				; find it
.1bee	b0 06		bcs $1bf6			bcs 	_GRTNoCreate 				; create if required.
.1bf0	20 53 11	jsr $1153			jsr 	CreateVariableRecord 		; create a variable.
.1bf3	20 ad 11	jsr $11ad			jsr 	AllocateBytesForType 		; allocate memory for it
.1bf6					_GRTNoCreate:
.1bf6	68		pla				pla 								; get type back, strip out type information.
.1bf7	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1bf9	60		rts				rts
.1bfa					_GRTArray:
.1bfa	da		phx				phx 								; save type information
.1bfb	20 fe 14	jsr $14fe			jsr 	FindVariable 				; read its data, the base address in YX
.1bfe	90 18		bcc $1c18			bcc 	_GRTUndeclared 				; undeclared array.
.1c00	da		phx				phx 								; save base address
.1c01	5a		phy				phy
.1c02	20 a4 12	jsr $12a4			jsr 	OutputIndexGroup 			; create an index group and generate them
.1c05	7a		ply				ply 								; get the array base address into YX
.1c06	fa		plx				plx
.1c07	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1c09	18		clc				clc
.1c0a	20 95 1b	jsr $1b95			jsr 	GetSetVariable 				; load the address of the array structure.
.1c0d	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1c0f	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1c12	68		pla				pla 								; and the type data into A
.1c13	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1c15	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1c17	60		rts				rts
.1c18					_GRTUndeclared:
.1c18	4c e6 13	jmp $13e6		jmp	ErrorV_undeclared
.1c1b					CommandREM:
.1c1b	20 22 18	jsr $1822			jsr 	LookNext
.1c1e	f0 05		beq $1c25			beq 	_CRExit
.1c20	20 33 18	jsr $1833			jsr 	GetNext
.1c23	80 f6		bra $1c1b			bra 	CommandREM
.1c25					_CRExit:
.1c25	60		rts				rts
.1c26					STRReset:
.1c26	a9 00		lda #$00			lda 	#((WorkArea) & $FF)
.1c28	8d 0c 06	sta $060c			sta 	0+variableListEnd
.1c2b	a9 80		lda #$80			lda 	#((WorkArea) >> 8) & $FF
.1c2d	8d 0d 06	sta $060d			sta 	1+variableListEnd
.1c30	a9 00		lda #$00			lda 	#((WorkArea+WorkAreaSize) & $FF)
.1c32	8d 0a 06	sta $060a			sta 	0+lineNumberTable
.1c35	a9 9f		lda #$9f			lda 	#((WorkArea+WorkAreaSize) >> 8) & $FF
.1c37	8d 0b 06	sta $060b			sta 	1+lineNumberTable
.1c3a	9c 00 80	stz $8000			stz 	WorkArea
.1c3d	a9 00		lda #$00			lda 	#((0) & $FF)
.1c3f	8d 0e 06	sta $060e			sta 	0+freeVariableMemory
.1c42	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1c44	8d 0f 06	sta $060f			sta 	1+freeVariableMemory
.1c47	60		rts				rts
.060a					lineNumberTable:
>060a							.fill 	2
.060c					variableListEnd:
>060c							.fill 	2
.060e					freeVariableMemory:
>060e							.fill 	2
.1c48					CompileTerm:
.1c48	20 3e 18	jsr $183e			jsr 	GetNextNonSpace 			; get first non space character.
.1c4b	30 72		bmi $1cbf			bmi 	_CTUnaryFunctions
.1c4d	20 48 18	jsr $1848			jsr 	CharIsDigit 				; found a number
.1c50	b0 3a		bcs $1c8c			bcs 	_CTDigit
.1c52	c9 2e		cmp #$2e			cmp 	#"."
.1c54	f0 36		beq $1c8c			beq 	_CTDigit
.1c56	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1c58	f0 43		beq $1c9d			beq 	_CTString
.1c5a	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1c5c	f0 28		beq $1c86			beq 	_CTOtherBase
.1c5e	c9 24		cmp #$24			cmp 	#"$"
.1c60	f0 24		beq $1c86			beq 	_CTOtherBase
.1c62	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1c64	f0 17		beq $1c7d			beq 	_CTBrackets
.1c66	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1c68	90 10		bcc $1c7a			bcc 	_CTSyntax
.1c6a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1c6c	b0 0c		bcs $1c7a			bcs 	_CTSyntax
.1c6e	20 e3 1b	jsr $1be3			jsr 	GetReferenceTerm 			; figure out what it is.
.1c71	48		pha				pha 								; save type on stack
.1c72	18		clc				clc 								; read it
.1c73	20 95 1b	jsr $1b95			jsr 	GetSetVariable
.1c76	68		pla				pla
.1c77	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1c79	60		rts				rts
.1c7a					_CTSyntax:
.1c7a	4c 2f 13	jmp $132f		jmp	ErrorV_syntax
.1c7d					_CTBrackets:
.1c7d	20 44 14	jsr $1444			jsr 	CompileExpressionAt0
.1c80	48		pha				pha
.1c81	20 89 10	jsr $1089			jsr 	CheckNextRParen
.1c84	68		pla				pla
.1c85	60		rts				rts
.1c86					_CTOtherBase:
.1c86	20 09 10	jsr $1009			jsr 	InlineNonDecimal 			; non decimal constant handler
.1c89	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1c8b	60		rts				rts
.1c8c					_CTDigit:
.1c8c	20 e0 1a	jsr $1ae0			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1c8f	90 06		bcc $1c97			bcc	 	_CTFloat 					; have a float or long int.
.1c91	20 0e 11	jsr $110e			jsr 	PushIntegerYA 				; code to push on stack
.1c94	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1c96	60		rts				rts
.1c97					_CTFloat:
.1c97	20 30 11	jsr $1130			jsr 	PushFloat  					; code to push float
.1c9a	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1c9c	60		rts				rts
.1c9d					_CTString:
.1c9d	20 54 10	jsr $1054			jsr 	BufferClear 				; copy it to the buffer
.1ca0					_CTStringLoop:
.1ca0	20 22 18	jsr $1822			jsr 	LookNext 					; reached EOL/EOS
.1ca3	f0 d5		beq $1c7a			beq 	_CTSyntax
.1ca5	c9 22		cmp #$22			cmp 	#'"'
.1ca7	f0 08		beq $1cb1			beq 	_CTStringDone
.1ca9	20 58 10	jsr $1058			jsr 	BufferWrite 				; write and consume
.1cac	20 33 18	jsr $1833			jsr 	GetNext
.1caf	80 ef		bra $1ca0			bra 	_CTStringLoop
.1cb1					_CTStringDone:
.1cb1	20 33 18	jsr $1833			jsr 	GetNext 					; consume closing quote.
.1cb4	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1cb6	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1cb9	20 64 10	jsr $1064			jsr 	BufferOutput
.1cbc	a9 40		lda #$40			lda 	#NSSString 					; string type
.1cbe	60		rts				rts
.1cbf					_CTUnaryFunctions:
.1cbf	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1cc1	f0 0a		beq $1ccd			beq 	_CTNegation
.1cc3	a2 c6		ldx #$c6			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1cc5	a0 16		ldy #$16			ldy 	#UnaryTables >> 8
.1cc7	20 c7 16	jsr $16c7			jsr 	GeneratorProcess
.1cca	90 ae		bcc $1c7a			bcc		_CTSyntax
.1ccc	60		rts				rts
.1ccd					_CTNegation:
.1ccd	20 48 1c	jsr $1c48			jsr 	CompileTerm 				; compile a term.
.1cd0	48		pha				pha
.1cd1	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1cd3	c9 00		cmp #$00			cmp 	#NSSIFloat
.1cd5	d0 07		bne $1cde			bne 	_CTType 					; error
.1cd7	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1cd9	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1cdc	68		pla				pla 								; return original type.
.1cdd	60		rts				rts
.1cde					_CTType:
.1cde	4c 3f 13	jmp $133f		jmp	ErrorV_type
.1ce1					CommandWAIT:
.1ce1	20 25 18	jsr $1825			jsr 	LookNextNonSpace
.1ce4	c9 2c		cmp #$2c			cmp 	#","
.1ce6	f0 10		beq $1cf8			beq 	_CWThirdParameter
.1ce8	a9 00		lda #$00			lda 	#0
.1cea	20 21 11	jsr $1121			jsr 	PushIntegerA
.1ced					_CWExit:
.1ced	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1cef	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1cf2	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1cf4	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1cf7	60		rts				rts
.1cf8					_CWThirdParameter:
.1cf8	20 33 18	jsr $1833			jsr 	GetNext
.1cfb	20 46 14	jsr $1446			jsr 	CompileExpressionAtA
.1cfe	29 40		and #$40			and 	#NSSTypeMask
.1d00	c9 00		cmp #$00			cmp 	#NSSIFloat
.1d02	f0 e9		beq $1ced			beq 	_CWExit
.1d04	4c 3f 13	jmp $133f		jmp	ErrorV_type
.1d07					OUTPUTWriteByte:
.1d07	92 25		sta ($25)			sta 	(objPtr)
.1d09	e6 25		inc $25				inc 	objPtr
.1d0b	d0 02		bne $1d0f			bne 	_HWOWBNoCarry
.1d0d	e6 26		inc $26				inc 	objPtr+1
.1d0f					_HWOWBNoCarry:
.1d0f	60		rts				rts
.1d10					CommandCMD:
.1d10	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.1d12	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1d15	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; followed by a , ?
.1d18	c9 2c		cmp #$2c			cmp 	#","
.1d1a	d0 06		bne $1d22			bne 	_CCMDExit
.1d1c	20 33 18	jsr $1833			jsr 	GetNext 					; consume comma.
.1d1f	20 10 1b	jsr $1b10			jsr 	CommandPRINT 				; do the print code
.1d22					_CCMDExit:
.1d22	60		rts				rts
.1d23					CommandOPEN:
.1d23	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; followed by a , ?
.1d26	c9 2c		cmp #$2c			cmp 	#","
.1d28	d0 15		bne $1d3f			bne 	_COTwoDefaults
.1d2a	20 33 18	jsr $1833			jsr 	GetNext 					; consume comma
.1d2d	20 44 14	jsr $1444			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1d30	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1d32	f0 1e		beq $1d52			beq 	_COThreeIntegers
.1d34	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1d36	20 21 11	jsr $1121			jsr 	PushIntegerA
.1d39	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1d3b	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1d3e	60		rts				rts
.1d3f					_COTwoDefaults:
.1d3f	a9 00		lda #$00			lda 	#0
.1d41	20 21 11	jsr $1121			jsr 	PushIntegerA
.1d44					_COCompileNullString:
.1d44	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1d46	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1d49	a9 00		lda #$00			lda 	#0
.1d4b	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1d4e	20 7b 10	jsr $107b			jsr 	WriteCodeByte
.1d51	60		rts				rts
.1d52					_COThreeIntegers:
.1d52	20 25 18	jsr $1825			jsr 	LookNextNonSpace 			; is there a ,
.1d55	c9 2c		cmp #$2c			cmp 	#","
.1d57	d0 eb		bne $1d44			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1d59	20 33 18	jsr $1833			jsr 	GetNext
.1d5c	20 44 14	jsr $1444			jsr 	CompileExpressionAt0 		; should be a filename
.1d5f	29 40		and #$40			and 	#NSSString
.1d61	f0 01		beq $1d64			beq 	_COType
.1d63	60		rts				rts
.1d64					_COType:
.1d64	4c 3f 13	jmp $133f		jmp	ErrorV_type
.1d67					XPrintCharacter
.1d67	48		pha				pha
.1d68	da		phx				phx
.1d69	5a		phy				phy
.1d6a	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1d6d	7a		ply				ply
.1d6e	fa		plx				plx
.1d6f	68		pla				pla
.1d70	60		rts				rts
.1d71					XSaveMemory:
.1d71	da		phx				phx
.1d72	5a		phy				phy
.1d73	48		pha				pha
.1d74	a9 00		lda #$00			lda 	#0 							; set LFS
.1d76	a2 08		ldx #$08			ldx 	#8
.1d78	a0 00		ldy #$00			ldy 	#0
.1d7a	20 ba ff	jsr $ffba			jsr 	$FFBA
.1d7d	a9 08		lda #$08			lda 	#8 							; set file name
.1d7f	a2 93		ldx #$93			ldx 	#SaveName & $FF
.1d81	a0 1d		ldy #$1d			ldy 	#SaveName >> 8
.1d83	20 bd ff	jsr $ffbd			jsr 	$FFBD
.1d86	68		pla				pla 								; set up the start address.
.1d87	85 29		sta $29				sta 	zTemp0+1
.1d89	64 28		stz $28				stz 	zTemp0
.1d8b	a9 28		lda #$28			lda 	#zTemp0 					; from index.
.1d8d	7a		ply				ply 								; end in YX
.1d8e	fa		plx				plx
.1d8f	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.1d92	60		rts				rts
.1d93					SaveName:
>1d93	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0610					numberBuffer:
>0610							.fill 	34
.1d9b					FloatSubtract:
.1d9b	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.1d9d	49 80		eor #$80			eor 	#$80
.1d9f	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.1da1					FloatAdd:
.1da1	ca		dex				dex
.1da2	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.1da4	15 6f		ora $6f,x			ora 	NSExponent+1,x
.1da6	15 62		ora $62,x			ora 	NSMantissa3,x
.1da8	15 63		ora $63,x			ora 	NSMantissa3+1,x
.1daa	d0 04		bne $1db0			bne 	_FAUseFloat
.1dac	20 3d 21	jsr $213d			jsr 	FloatInt32Add 				; use the int32 one.
.1daf	60		rts				rts
.1db0					_FAUseFloat:
.1db0	20 d2 20	jsr $20d2			jsr 	FloatNormalise 				; normalise S[X]
.1db3	f0 51		beq $1e06			beq 	_FAReturn1
.1db5	e8		inx				inx 								; normalise S[X+1]
.1db6	20 d2 20	jsr $20d2			jsr 	FloatNormalise
.1db9	ca		dex				dex
.1dba	c9 00		cmp #$00			cmp 	#0
.1dbc	f0 60		beq $1e1e			beq 	_FAExit 					; if so, just return A
.1dbe	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.1dc0	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.1dc2	f0 18		beq $1ddc			beq 	_FAExponentsEqual
.1dc4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.1dc6	a8		tay				tay
.1dc7	38		sec				sec 								; do a signed comparison of the exponents.
.1dc8	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.1dca	50 02		bvc $1dce			bvc 	_FANoSignedChange
.1dcc	49 80		eor #$80			eor 	#$80
.1dce					_FANoSignedChange:
.1dce	29 80		and #$80			and 	#$80
.1dd0	10 02		bpl $1dd4			bpl 	_FAHaveMax
.1dd2	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.1dd4					_FAHaveMax:
.1dd4	20 1f 1e	jsr $1e1f			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.1dd7	e8		inx				inx
.1dd8	20 1f 1e	jsr $1e1f			jsr 	_FAShiftToExponent
.1ddb	ca		dex				dex
.1ddc					_FAExponentsEqual:
.1ddc	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.1dde	55 33		eor $33,x			eor 	NSStatus+1,x
.1de0	30 0e		bmi $1df0			bmi 	_FADifferentSigns
.1de2	20 09 21	jsr $2109			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.1de5	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.1de7	10 35		bpl $1e1e			bpl 	_FAExit 					; if no, we are done.
.1de9	20 96 23	jsr $2396			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.1dec	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.1dee	80 2e		bra $1e1e			bra 	_FAExit
.1df0					_FADifferentSigns:
.1df0	20 23 21	jsr $2123			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.1df3	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.1df5	10 06		bpl $1dfd			bpl 	_FACheckZero 				; if no, check for -0
.1df7	20 3f 23	jsr $233f			jsr 	FloatNegate 					; netate result
.1dfa	20 46 23	jsr $2346			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.1dfd					_FACheckZero:
.1dfd	20 9f 23	jsr $239f			jsr 	FloatIsZero	 				; check for -0
.1e00	d0 1c		bne $1e1e			bne 	_FAExit
.1e02	74 32		stz $32,x			stz 	NSStatus,x
.1e04	80 18		bra $1e1e			bra 	_FAExit
.1e06					_FAReturn1:
.1e06	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.1e08	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1e0a	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.1e0c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1e0e	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.1e10	95 56		sta $56,x			sta 	NSMantissa2,x
.1e12	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.1e14	95 62		sta $62,x			sta 	NSMantissa3,x
.1e16	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.1e18	95 6e		sta $6e,x			sta 	NSExponent,x
.1e1a	b5 33		lda $33,x			lda 	NSStatus+1,x
.1e1c	95 32		sta $32,x			sta 	NSStatus,x
.1e1e					_FAExit:
.1e1e	60		rts				rts
.1e1f					_FAShiftToExponent:
.1e1f					_FAShiftToExponent2:
.1e1f	98		tya				tya 								; compare Y to exponent
.1e20	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.1e22	f0 07		beq $1e2b			beq 	_FASEExit 					; exit if so.
.1e24	20 96 23	jsr $2396			jsr 	FloatShiftRight	 			; shift the mantissa right
.1e27	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.1e29	80 f4		bra $1e1f			bra 	_FAShiftToExponent2
.1e2b					_FASEExit:
.1e2b	60		rts				rts
.1e2c					CompareEqual:
.1e2c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e2e	d0 09		bne $1e39			bne 	ReturnFalse
.1e30					ReturnTrue:
.1e30	a9 01		lda #$01			lda 	#1
.1e32	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1e34	a9 80		lda #$80			lda 	#$80
.1e36	95 32		sta $32,x			sta 	NSStatus,x
.1e38	60		rts				rts
.1e39					ReturnFalse:
.1e39	74 3e		stz $3e,x			stz 	NSMantissa0,x
.1e3b	60		rts				rts
.1e3c					CompareNotEqual:
.1e3c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e3e	d0 f0		bne $1e30			bne 	ReturnTrue
.1e40	80 f7		bra $1e39			bra 	ReturnFalse
.1e42					CompareLess:
.1e42	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e44	c9 ff		cmp #$ff			cmp 	#$FF
.1e46	f0 e8		beq $1e30			beq 	ReturnTrue
.1e48	80 ef		bra $1e39			bra 	ReturnFalse
.1e4a					CompareGreater:
.1e4a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e4c	c9 01		cmp #$01			cmp 	#$01
.1e4e	f0 e0		beq $1e30			beq 	ReturnTrue
.1e50	80 e7		bra $1e39			bra 	ReturnFalse
.1e52					CompareLessEqual:
.1e52	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e54	c9 01		cmp #$01			cmp 	#$01
.1e56	d0 d8		bne $1e30			bne 	ReturnTrue
.1e58	80 df		bra $1e39			bra 	ReturnFalse
.1e5a					CompareGreaterEqual:
.1e5a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e5c	c9 ff		cmp #$ff			cmp 	#$FF
.1e5e	d0 d0		bne $1e30			bne 	ReturnTrue
.1e60	80 d7		bra $1e39			bra 	ReturnFalse
.1e62					FloatCompare:
.1e62	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.1e64	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.1e66	48		pha				pha
.1e67	20 9b 1d	jsr $1d9b			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.1e6a	68		pla				pla
.1e6b	d0 0c		bne $1e79			bne 	_FCCompareFloat
.1e6d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e6f	15 4a		ora $4a,x			ora 	NSMantissa1,x
.1e71	15 56		ora $56,x			ora 	NSMantissa2,x
.1e73	15 62		ora $62,x			ora 	NSMantissa3,x
.1e75	f0 14		beq $1e8b			beq 	_FCExit 					; if zero, return zero
.1e77	80 0a		bra $1e83			bra 	_FCSign
.1e79					_FCCompareFloat:
.1e79	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.1e7b	29 f0		and #$f0			and 	#$F0
.1e7d	15 56		ora $56,x			ora 	NSMantissa2,x
.1e7f	15 62		ora $62,x			ora 	NSMantissa3,x
.1e81	f0 08		beq $1e8b			beq 	_FCExit 					; zero, so approximately identical
.1e83					_FCSign:
.1e83	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.1e85	34 32		bit $32,x			bit 	NSStatus,x
.1e87	10 02		bpl $1e8b			bpl 	_FCExit
.1e89					_FCNegative:
.1e89	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.1e8b					_FCExit:
.1e8b	20 7f 23	jsr $237f			jsr 	FloatSetByte 				; set the result 255,0,1
.1e8e	60		rts				rts
.1e8f					FloatScalarTable:
>1e8f	66 66 66 66				.dword $66666666 ; 0.1
>1e93	de					.byte $de
>1e94	1f 85 eb 51				.dword $51eb851f ; 0.01
>1e98	db					.byte $db
>1e99	4c 37 89 41				.dword $4189374c ; 0.001
>1e9d	d8					.byte $d8
>1e9e	ac 8b db 68				.dword $68db8bac ; 0.0001
>1ea2	d4					.byte $d4
>1ea3	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>1ea7	d1					.byte $d1
>1ea8	83 de 1b 43				.dword $431bde83 ; 1e-06
>1eac	ce					.byte $ce
>1ead	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>1eb1	ca					.byte $ca
>1eb2	89 3b e6 55				.dword $55e63b89 ; 1e-08
>1eb6	c7					.byte $c7
>1eb7	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>1ebb	c4					.byte $c4
>1ebc	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>1ec0	c0					.byte $c0
>1ec1	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>1ec5	bd					.byte $bd
.1ec6					FloatDivide:
.1ec6	48		pha				pha
.1ec7	20 d2 20	jsr $20d2			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.1eca	ca		dex				dex
.1ecb	c9 00		cmp #$00			cmp 	#0
.1ecd	f0 1e		beq $1eed			beq 	_FDZero
.1ecf	20 d2 20	jsr $20d2			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.1ed2	f0 16		beq $1eea			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.1ed4	20 35 1f	jsr $1f35			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.1ed7	20 02 1f	jsr $1f02			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.1eda	20 d2 20	jsr $20d2			jsr		FloatNormalise 				; renormalise
.1edd	20 c8 20	jsr $20c8			jsr 	FloatCalculateSign 			; calculate result sign
.1ee0	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.1ee2	38		sec				sec
.1ee3	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.1ee5	38		sec				sec
.1ee6	e9 1e		sbc #$1e			sbc 	#30
.1ee8	95 6e		sta $6e,x			sta 	NSExponent,x
.1eea					_FDExit:
.1eea	68		pla				pla
.1eeb	18		clc				clc
.1eec	60		rts				rts
.1eed					_FDZero:
.1eed	68		pla				pla
.1eee	38		sec				sec
.1eef	60		rts				rts
.1ef0					DivideInt32:
.1ef0	20 b8 1f	jsr $1fb8			jsr 	FloatIntegerPart 			; make both integers
.1ef3	ca		dex				dex
.1ef4	20 b8 1f	jsr $1fb8			jsr 	FloatIntegerPart
.1ef7	20 13 1f	jsr $1f13			jsr 	Int32Divide 				; divide
.1efa	20 02 1f	jsr $1f02			jsr 	NSMCopyPlusTwoToZero 		; copy result
.1efd	20 c8 20	jsr $20c8			jsr 	FloatCalculateSign 			; calculate result sign
.1f00	18		clc				clc
.1f01	60		rts				rts
.1f02					NSMCopyPlusTwoToZero:
.1f02	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.1f04	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1f06	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.1f08	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1f0a	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.1f0c	95 56		sta $56,x			sta 	NSMantissa2,x
.1f0e	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.1f10	95 62		sta $62,x			sta 	NSMantissa3,x
.1f12	60		rts				rts
.1f13					Int32Divide:
.1f13	48		pha				pha 								; save AXY
.1f14	5a		phy				phy
.1f15	20 60 23	jsr $2360			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.1f18	20 79 23	jsr $2379			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.1f1b	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.1f1d					_I32DivideLoop:
.1f1d	e8		inx				inx
.1f1e	e8		inx				inx
.1f1f	20 8c 23	jsr $238c			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.1f22	ca		dex				dex
.1f23	ca		dex				dex
.1f24	20 8d 23	jsr $238d			jsr 	FloatRotateLeft
.1f27	20 53 1f	jsr $1f53			jsr 	FloatDivideCheck 			; check if subtract possible
.1f2a	90 02		bcc $1f2e			bcc 	_I32DivideNoCarryIn
.1f2c	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.1f2e					_I32DivideNoCarryIn:
.1f2e	88		dey				dey 								; loop round till division completed.
.1f2f	d0 ec		bne $1f1d			bne 	_I32DivideLoop
.1f31	7a		ply				ply 								; restore AXY and exit
.1f32	68		pla				pla
.1f33	18		clc				clc
.1f34	60		rts				rts
.1f35					Int32ShiftDivide:
.1f35	48		pha				pha 								; save AY
.1f36	5a		phy				phy
.1f37	e8		inx				inx 								; clear S[X+2]
.1f38	e8		inx				inx
.1f39	20 7d 23	jsr $237d			jsr 	FloatSetZero
.1f3c	ca		dex				dex
.1f3d	ca		dex				dex
.1f3e	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.1f40					_I32SDLoop:
.1f40	20 53 1f	jsr $1f53			jsr 	FloatDivideCheck 			; check if subtract possible
.1f43	e8		inx				inx
.1f44	e8		inx				inx
.1f45	20 8d 23	jsr $238d			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.1f48	ca		dex				dex
.1f49	ca		dex				dex
.1f4a	20 8d 23	jsr $238d			jsr 	FloatRotateLeft
.1f4d	88		dey				dey 	 							; do 31 times
.1f4e	d0 f0		bne $1f40			bne 	_I32SDLoop
.1f50	7a		ply				ply 								; restore AY and exit
.1f51	68		pla				pla
.1f52	60		rts				rts
.1f53					FloatDivideCheck:
.1f53	20 23 21	jsr $2123			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.1f56	b0 04		bcs $1f5c			bcs 	_DCSExit 					; if carry set, then could do, exit
.1f58	20 09 21	jsr $2109			jsr 	FloatAddTopTwoStack 		; add it back in
.1f5b	18		clc				clc 								; and return False
.1f5c					_DCSExit:
.1f5c	60		rts				rts
.1f5d					FloatFractionalPart:
.1f5d	5a		phy				phy
.1f5e	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.1f60	29 7f		and #$7f			and 	#$7F
.1f62	95 32		sta $32,x			sta 	NSStatus,x
.1f64	20 d2 20	jsr $20d2			jsr 	FloatNormalise
.1f67	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.1f69	38		sec				sec
.1f6a	e9 e0		sbc #$e0			sbc 	#$E0
.1f6c	90 29		bcc $1f97			bcc 	_FFPExit 					; already fractional
.1f6e	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.1f70	b0 22		bcs $1f94			bcs 	_FFPZero
.1f72	a8		tay				tay 								; put count to do in Y
.1f73	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.1f75	20 9c 1f	jsr $1f9c			jsr 	_FFPPartial
.1f78	95 62		sta $62,x			sta 	NSMantissa3,x
.1f7a	b5 56		lda $56,x			lda 	NSMantissa2,x
.1f7c	20 9c 1f	jsr $1f9c			jsr 	_FFPPartial
.1f7f	95 56		sta $56,x			sta 	NSMantissa2,x
.1f81	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1f83	20 9c 1f	jsr $1f9c			jsr 	_FFPPartial
.1f86	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1f88	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1f8a	20 9c 1f	jsr $1f9c			jsr 	_FFPPartial
.1f8d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1f8f	20 9f 23	jsr $239f			jsr 	FloatIsZero 					; zeroed check.
.1f92	d0 03		bne $1f97			bne 	_FFPExit
.1f94					_FFPZero:
.1f94	20 7d 23	jsr $237d			jsr 	FloatSetZero
.1f97					_FFPExit:
.1f97	20 d2 20	jsr $20d2			jsr 	FloatNormalise
.1f9a	7a		ply				ply
.1f9b	60		rts				rts
.1f9c					_FFPPartial:
.1f9c	c0 00		cpy #$00			cpy 	#0 							; no more to do
.1f9e	f0 17		beq $1fb7			beq 	_FFFPPExit
.1fa0	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.1fa2	b0 0c		bcs $1fb0			bcs 	_FFFPPWholeByte
.1fa4	5a		phy				phy
.1fa5					_FFFPPLeft:
.1fa5	0a		asl a				asl 	a
.1fa6	88		dey				dey
.1fa7	d0 fc		bne $1fa5			bne 	_FFFPPLeft
.1fa9	7a		ply				ply
.1faa					_FFFPPRight:
.1faa	4a		lsr a				lsr 	a
.1fab	88		dey				dey
.1fac	d0 fc		bne $1faa			bne 	_FFFPPRight
.1fae	80 07		bra $1fb7			bra 	_FFFPPExit
.1fb0					_FFFPPWholeByte:
.1fb0	98		tya				tya 								; subtract 8 from count
.1fb1	38		sec				sec
.1fb2	e9 08		sbc #$08			sbc 	#8
.1fb4	a8		tay				tay
.1fb5	a9 00		lda #$00			lda 	#0 							; and clear all
.1fb7					_FFFPPExit:
.1fb7	60		rts				rts
.1fb8					FloatIntegerPart:
.1fb8	48		pha				pha
.1fb9	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.1fbb	f0 1d		beq $1fda			beq 	_FIPExit 					; if so do nothing
.1fbd	20 9f 23	jsr $239f			jsr 	FloatIsZero 				; is it zero ?
.1fc0	f0 15		beq $1fd7			beq 	_FIPZero 					; if so return zero.
.1fc2	20 d2 20	jsr $20d2			jsr 	FloatNormalise 				; normalise
.1fc5	f0 10		beq $1fd7			beq 	_FIPZero 					; normalised to zero, exit zero
.1fc7					_FIPShift:
.1fc7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.1fc9	10 07		bpl $1fd2			bpl 	_FIPCheckZero
.1fcb	20 96 23	jsr $2396			jsr 	FloatShiftRight 			; shift mantissa right
.1fce	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.1fd0	80 f5		bra $1fc7			bra 	_FIPShift
.1fd2					_FIPCheckZero:
.1fd2	20 9f 23	jsr $239f			jsr 	FloatIsZero 				; avoid -0 problem
.1fd5	d0 03		bne $1fda			bne 	_FIPExit 					; set to zero if mantissa zero.
.1fd7					_FIPZero:
.1fd7	20 7d 23	jsr $237d			jsr 	FloatSetZero
.1fda					_FIPExit:
.1fda	68		pla				pla
.1fdb	60		rts				rts
.1fdc					FloatIntegerPartDown:
.1fdc	48		pha				pha
.1fdd	5a		phy				phy
.1fde	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.1fe0	f0 36		beq $2018			beq 	_FIPExit 					; if so do nothing
.1fe2	20 9f 23	jsr $239f			jsr 	FloatIsZero 				; is it zero ?
.1fe5	f0 2e		beq $2015			beq 	_FIPZero 					; if so return zero.
.1fe7	20 d2 20	jsr $20d2			jsr 	FloatNormalise 				; normalise
.1fea	f0 29		beq $2015			beq 	_FIPZero 					; normalised to zero, exit zero
.1fec	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.1fee					_FIPShift:
.1fee	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.1ff0	10 0a		bpl $1ffc			bpl 	_FIPCheckDown
.1ff2	20 96 23	jsr $2396			jsr 	FloatShiftRight 			; shift mantissa right
.1ff5	90 01		bcc $1ff8			bcc 	_FIPNoFrac 					; shifted a zero out ?
.1ff7	c8		iny				iny
.1ff8					_FIPNoFrac:
.1ff8	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.1ffa	80 f2		bra $1fee			bra 	_FIPShift
.1ffc					_FIPCheckDown:
.1ffc	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.1ffe	f0 10		beq $2010			beq 	_FIPCheckZero
.2000	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.2002	10 0c		bpl $2010			bpl 	_FIPCheckZero
.2004	e8		inx				inx 								; -ve so round *down*.
.2005	a9 01		lda #$01			lda 	#1
.2007	20 7f 23	jsr $237f			jsr 	FloatSetByte
.200a	20 3f 23	jsr $233f			jsr 	FloatNegate
.200d	20 a1 1d	jsr $1da1			jsr 	FloatAdd
.2010					_FIPCheckZero:
.2010	20 9f 23	jsr $239f			jsr 	FloatIsZero 				; avoid -0 problem
.2013	d0 03		bne $2018			bne 	_FIPExit 					; set to zero if mantissa zero.
.2015					_FIPZero:
.2015	20 7d 23	jsr $237d			jsr 	FloatSetZero
.2018					_FIPExit:
.2018	7a		ply				ply
.2019	68		pla				pla
.201a	60		rts				rts
.201b					FloatInt8Multiply:
.201b	5a		phy				phy
.201c	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.201e	a8		tay				tay
.201f	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2021					_FI8MLoop:
.2021	98		tya				tya 								; shift right shifter right into carry
.2022	4a		lsr a				lsr 	a
.2023	a8		tay				tay
.2024	90 0d		bcc $2033			bcc 	_FI8MNoAdd
.2026	18		clc				clc
.2027	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2029	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.202b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.202d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.202f	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.2031	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2033					_FI8MNoAdd:
.2033	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.2035	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.2037	c0 00		cpy #$00			cpy 	#0
.2039	d0 e6		bne $2021			bne 	_FI8MLoop 					; until right shifter zero.
.203b	7a		ply				ply
.203c	60		rts				rts
.203d					FloatMultiply:
.203d	ca		dex				dex
.203e	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.2040	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2042	15 62		ora $62,x			ora 	NSMantissa3,x
.2044	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2046	d0 21		bne $2069			bne 	_FMUseFloat
.2048	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.204a	15 33		ora $33,x			ora 	NSStatus+1,x
.204c	29 80		and #$80			and 	#$80
.204e	15 62		ora $62,x			ora 	NSMantissa3,x
.2050	15 56		ora $56,x			ora 	NSMantissa2,x
.2052	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2054	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2056	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2058	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.205a	d0 04		bne $2060			bne 	_FMInt32
.205c	20 1b 20	jsr $201b			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.205f	60		rts				rts
.2060					_FMInt32:
.2060	20 8a 20	jsr $208a			jsr 	FloatMultiplyShort			; use the int32 one.
.2063	18		clc				clc 								; fix it up if gone out of range
.2064	75 6e		adc $6e,x			adc 	NSExponent,x
.2066	95 6e		sta $6e,x			sta 	NSExponent,x
.2068	60		rts				rts
.2069					_FMUseFloat:
.2069	20 d2 20	jsr $20d2			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.206c	f0 18		beq $2086			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.206e	e8		inx				inx
.206f	20 d2 20	jsr $20d2			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2072	ca		dex				dex
.2073	c9 00		cmp #$00			cmp 	#0
.2075	f0 0c		beq $2083			beq 	_FDSetZero
.2077	20 8a 20	jsr $208a			jsr 	FloatMultiplyShort 			; calculate the result.
.207a	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.207c	18		clc				clc
.207d	75 6f		adc $6f,x			adc 	NSExponent+1,x
.207f	95 6e		sta $6e,x			sta 	NSExponent,x
.2081	80 03		bra $2086			bra 	_FDExit
.2083					_FDSetZero:
.2083	20 7d 23	jsr $237d			jsr 	FloatSetZero 				; return 0
.2086					_FDExit:
.2086	20 d2 20	jsr $20d2			jsr 	FloatNormalise 				; normalise the result
.2089	60		rts				rts
.208a					FloatMultiplyShort:
.208a	5a		phy				phy 								; save Y
.208b	20 60 23	jsr $2360			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.208e	20 79 23	jsr $2379			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2091	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2093					_I32MLoop:
.2093	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2095	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.2097	15 58		ora $58,x			ora 	NSMantissa2+2,x
.2099	15 64		ora $64,x			ora 	NSMantissa3+2,x
.209b	f0 25		beq $20c2			beq 	_I32MExit 					; exit if zero
.209d	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.209f	29 01		and #$01			and 	#1
.20a1	f0 0d		beq $20b0			beq 	_I32MNoAdd
.20a3	20 09 21	jsr $2109			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.20a6	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.20a8	10 06		bpl $20b0			bpl 	_I32MNoAdd
.20aa					_I32ShiftRight:
.20aa	20 96 23	jsr $2396			jsr 	FloatShiftRight 			; shift S[X] right
.20ad	c8		iny				iny 								; increment shift count
.20ae	80 09		bra $20b9			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.20b0					_I32MNoAdd:
.20b0	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.20b2	70 f6		bvs $20aa			bvs 	_I32ShiftRight 				; instead.
.20b4	e8		inx				inx
.20b5	20 8c 23	jsr $238c			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.20b8	ca		dex				dex
.20b9					_I32MShiftUpper:
.20b9	e8		inx				inx 								; shift S[X+2] right
.20ba	e8		inx				inx
.20bb	20 96 23	jsr $2396			jsr 	FloatShiftRight
.20be	ca		dex				dex
.20bf	ca		dex				dex
.20c0	80 d1		bra $2093			bra 	_I32MLoop 					; try again.
.20c2					_I32MExit:
.20c2	20 c8 20	jsr $20c8			jsr 	FloatCalculateSign
.20c5	98		tya				tya 								; shift in A
.20c6	7a		ply				ply 								; restore Y and exit
.20c7	60		rts				rts
.20c8					FloatCalculateSign:
.20c8	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.20ca	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.20cc	55 33		eor $33,x			eor 	NSStatus+1,x
.20ce	0a		asl a				asl 	a 							; shift bit 7 into carry
.20cf	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.20d1	60		rts				rts
.20d2					FloatNormalise:
.20d2	20 9f 23	jsr $239f			jsr 	FloatIsZero 				; if zero exit
.20d5	d0 07		bne $20de			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.20d7	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.20d9	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.20db	a9 00		lda #$00			lda 	#0 							; set Z flag
.20dd	60		rts				rts
.20de					_NSNormaliseOptimise:
.20de	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.20e0	d0 19		bne $20fb			bne 	_NSNormaliseLoop
.20e2	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.20e4	30 15		bmi $20fb			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.20e6	95 62		sta $62,x			sta 	NSMantissa3,x
.20e8	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.20ea	95 56		sta $56,x			sta 	NSMantissa2,x
.20ec	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20ee	95 4a		sta $4a,x			sta 	NSMantissa1,x
.20f0	74 3e		stz $3e,x			stz 	NSMantissa0,x
.20f2	b5 6e		lda $6e,x			lda 	NSExponent,x
.20f4	38		sec				sec
.20f5	e9 08		sbc #$08			sbc 	#8
.20f7	95 6e		sta $6e,x			sta 	NSExponent,x
.20f9	80 e3		bra $20de			bra 	_NSNormaliseOptimise
.20fb					_NSNormaliseLoop:
.20fb	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.20fd	70 07		bvs $2106			bvs 	_NSNExit 					; exit if so with Z flag clear
.20ff	20 8c 23	jsr $238c			jsr 	FloatShiftLeft 				; shift mantissa left
.2102	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.2104	80 f5		bra $20fb			bra 	_NSNormaliseLoop
.2106					_NSNExit:
.2106	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.2108	60		rts				rts
.2109					FloatAddTopTwoStack:
.2109	18		clc				clc
.210a	b5 3e		lda $3e,x			lda		NSMantissa0,x
.210c	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.210e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2110	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2112	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.2114	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2116	b5 56		lda $56,x			lda		NSMantissa2,x
.2118	75 57		adc $57,x			adc 		NSMantissa2+1,x
.211a	95 56		sta $56,x			sta 	NSMantissa2,x
.211c	b5 62		lda $62,x			lda		NSMantissa3,x
.211e	75 63		adc $63,x			adc 		NSMantissa3+1,x
.2120	95 62		sta $62,x			sta 	NSMantissa3,x
.2122	60		rts				rts
.2123					FloatSubTopTwoStack:
.2123	38		sec				sec
.2124	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2126	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.2128	95 3e		sta $3e,x			sta 	NSMantissa0,x
.212a	b5 4a		lda $4a,x			lda		NSMantissa1,x
.212c	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.212e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2130	b5 56		lda $56,x			lda		NSMantissa2,x
.2132	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.2134	95 56		sta $56,x			sta 	NSMantissa2,x
.2136	b5 62		lda $62,x			lda		NSMantissa3,x
.2138	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.213a	95 62		sta $62,x			sta 	NSMantissa3,x
.213c	60		rts				rts
.213d					FloatInt32Add:
.213d	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.213f	55 33		eor $33,x			eor 	NSStatus+1,x
.2141	30 04		bmi $2147			bmi 	_DiffSigns
.2143	20 09 21	jsr $2109			jsr		FloatAddTopTwoStack
.2146	60		rts				rts
.2147					_DiffSigns:
.2147	20 23 21	jsr $2123			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.214a	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.214c	10 07		bpl $2155			bpl 	_AddExit
.214e	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2150	95 32		sta $32,x			sta 	NSStatus,x
.2152	20 46 23	jsr $2346			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2155					_AddExit:
.2155	20 9f 23	jsr $239f			jsr 	FloatIsZero 				; check for -0
.2158	d0 02		bne $215c			bne 	_AddNonZero
.215a	74 32		stz $32,x			stz 	NSStatus,x
.215c					_AddNonZero:
.215c	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.215d					FloatEncodeStart:
.215d	38		sec				sec
.215e	80 01		bra $2161			bra 	FloatEncodeContinue+1
.2160					FloatEncodeContinue:
.2160	18		clc				clc
.2161					FloatEncode:
.2161	08		php				php 								; save reset flag.
.2162	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2164	f0 15		beq $217b			beq 	_ENIsOkay
.2166	c9 30		cmp #$30			cmp 	#"0"
.2168	90 04		bcc $216e			bcc 	_ENBadNumber
.216a	c9 3a		cmp #$3a			cmp 	#"9"+1
.216c	90 0d		bcc $217b			bcc 	_ENIsOkay
.216e					_ENBadNumber:
.216e	28		plp				plp 								; throw saved reset
.216f	ad 32 06	lda $0632			lda 	encodeState 				; if in decimal mode, construct final number
.2172	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2174	d0 03		bne $2179			bne 	_ENFail
.2176	4c f3 21	jmp $21f3			jmp 	_ENConstructFinal
.2179					_ENFail:
.2179	18		clc				clc 								; not allowed
.217a	60		rts				rts
.217b					_ENIsOkay:
.217b	28		plp				plp 								; are we restarting
.217c	90 15		bcc $2193			bcc 	_ENNoRestart
.217e					_ENStartEncode:
.217e	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2180	f0 0c		beq $218e			beq 	_ENFirstDP
.2182	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2184	20 7f 23	jsr $237f			jsr 	FloatSetByte 				; in single byte mode.
.2187	a9 01		lda #$01			lda 	#ESTA_Low
.2189					_ENExitChange:
.2189	8d 32 06	sta $0632			sta 	encodeState 				; save new state
.218c	38		sec				sec
.218d	60		rts				rts
.218e					_ENFirstDP:
.218e	20 7d 23	jsr $237d			jsr 	FloatSetZero 				; clear integer part
.2191	80 3c		bra $21cf			bra 	_ESTASwitchFloat			; go straight to float and exi
.2193					_ENNoRestart:
.2193	48		pha				pha 								; save digit or DP on stack.
.2194	ad 32 06	lda $0632			lda 	encodeState 				; get current state
.2197	c9 01		cmp #$01			cmp 	#ESTA_Low
.2199	f0 09		beq $21a4			beq  	_ESTALowState
.219b	c9 02		cmp #$02			cmp 	#ESTA_High
.219d	f0 26		beq $21c5			beq 	_ESTAHighState
.219f	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.21a1	f0 38		beq $21db			beq 	_ESTADecimalState
>21a3	db						.byte 	$DB 						; causes a break in the emulator
.21a4					_ESTALowState:
.21a4	68		pla				pla 								; get value back
.21a5	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.21a7	f0 26		beq $21cf			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.21a9	29 0f		and #$0f			and 	#15 						; make digit
.21ab	8d 33 06	sta $0633			sta 	digitTemp 					; save it.
.21ae	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.21b0	0a		asl a				asl 	a
.21b1	0a		asl a				asl 	a
.21b2	75 3e		adc $3e,x			adc 	NSMantissa0,x
.21b4	0a		asl a				asl 	a
.21b5	6d 33 06	adc $0633			adc 	digitTemp
.21b8	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21ba	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.21bc	90 05		bcc $21c3			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.21be	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.21c0	8d 32 06	sta $0632			sta 	encodeState
.21c3					_ESTANoSwitch:
.21c3	38		sec				sec
.21c4	60		rts				rts
.21c5					_ESTAHighState:
.21c5	68		pla				pla 								; get value back
.21c6	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.21c8	f0 05		beq $21cf			beq 	_ESTASwitchFloat
.21ca	20 25 22	jsr $2225			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.21cd	38		sec				sec
.21ce	60		rts				rts
.21cf					_ESTASwitchFloat:
.21cf	9c 34 06	stz $0634			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.21d2	e8		inx				inx 								; zero the decimal additive.
.21d3	20 7d 23	jsr $237d			jsr 	FloatSetZero
.21d6	ca		dex				dex
.21d7	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.21d9	80 ae		bra $2189			bra 	_ENExitChange
.21db					_ESTADecimalState:
.21db	68		pla				pla 								; digit.
.21dc	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.21de	f0 99		beq $2179			beq 	_ENFail
.21e0	e8		inx				inx 								; put digit into fractional part of X+1
.21e1	20 25 22	jsr $2225			jsr 	ESTAShiftDigitIntoMantissa
.21e4	ca		dex				dex
.21e5	ee 34 06	inc $0634			inc 	decimalCount 				; bump the count of decimals
.21e8	ad 34 06	lda $0634			lda 	decimalCount 				; too many decimal digits.
.21eb	c9 0b		cmp #$0b			cmp 	#11
.21ed	f0 02		beq $21f1			beq 	_ESTADSFail
.21ef	38		sec				sec
.21f0	60		rts				rts
.21f1					_ESTADSFail:
.21f1	18		clc				clc
.21f2	60		rts				rts
.21f3					_ENConstructFinal:
.21f3	ad 34 06	lda $0634			lda 	decimalCount 				; get decimal count
.21f6	f0 2b		beq $2223			beq 	_ENCFExit 					; no decimals
.21f8	5a		phy				phy
.21f9	0a		asl a				asl 	a 							; x 4 and CLC
.21fa	0a		asl a				asl 	a
.21fb	6d 34 06	adc $0634			adc 	decimalCount
.21fe	a8		tay				tay
.21ff	b9 8a 1e	lda $1e8a,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.2202	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.2204	b9 8b 1e	lda $1e8b,y			lda 	FloatScalarTable-5+1,y
.2207	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2209	b9 8c 1e	lda $1e8c,y			lda 	FloatScalarTable-5+2,y
.220c	95 58		sta $58,x			sta 	NSMantissa2+2,x
.220e	b9 8d 1e	lda $1e8d,y			lda 	FloatScalarTable-5+3,y
.2211	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2213	b9 8e 1e	lda $1e8e,y			lda 	FloatScalarTable-5+4,y
.2216	95 70		sta $70,x			sta 	NSExponent+2,x
.2218	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.221a	e8		inx				inx 								; multiply decimal const by decimal scalar
.221b	e8		inx				inx
.221c	20 3d 20	jsr $203d			jsr 	FloatMultiply
.221f	20 a1 1d	jsr $1da1			jsr 	FloatAdd 					; add to integer part.
.2222	7a		ply				ply
.2223					_ENCFExit:
.2223	18		clc				clc 								; reject the digit.
.2224	60		rts				rts
.2225					ESTAShiftDigitIntoMantissa:
.2225	29 0f		and #$0f			and 	#15 						; save digit
.2227	48		pha				pha
.2228	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.222a	48		pha				pha
.222b	b5 56		lda $56,x			lda 	NSMantissa2,x
.222d	48		pha				pha
.222e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2230	48		pha				pha
.2231	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2233	48		pha				pha
.2234	20 8c 23	jsr $238c			jsr 	FloatShiftLeft 				; x 2
.2237	20 8c 23	jsr $238c			jsr 	FloatShiftLeft 				; x 4
.223a	18		clc				clc 								; pop mantissa and add
.223b	68		pla				pla
.223c	75 3e		adc $3e,x			adc 	NSMantissa0,x
.223e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2240	68		pla				pla
.2241	75 4a		adc $4a,x			adc 	NSMantissa1,x
.2243	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2245	68		pla				pla
.2246	75 56		adc $56,x			adc 	NSMantissa2,x
.2248	95 56		sta $56,x			sta 	NSMantissa2,x
.224a	68		pla				pla
.224b	75 62		adc $62,x			adc 	NSMantissa3,x
.224d	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.224f	20 8c 23	jsr $238c			jsr 	FloatShiftLeft 				; x 10
.2252	68		pla				pla 								; add digit
.2253	18		clc				clc
.2254	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2256	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2258	90 0a		bcc $2264			bcc 	_ESTASDExit
.225a	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.225c	d0 06		bne $2264			bne 	_ESTASDExit
.225e	f6 56		inc $56,x			inc 	NSMantissa2,x
.2260	d0 02		bne $2264			bne 	_ESTASDExit
.2262	f6 62		inc $62,x			inc 	NSMantissa3,x
.2264					_ESTASDExit:
.2264	60		rts				rts
.0632					encodeState:
>0632							.fill 	1
.0633					digitTemp:
>0633							.fill 	1
.0634					decimalCount:
>0634							.fill 	1
.2265					FloatToString:
.2265	da		phx				phx
.2266	5a		phy				phy 								; save code position
.2267	8d 35 06	sta $0635			sta 	decimalPlaces	 			; save number of DPs.
.226a	9c 36 06	stz $0636			stz 	dbOffset 					; offset into decimal buffer = start.
.226d	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.226f	10 08		bpl $2279			bpl 	_CNTSNotNegative
.2271	29 7f		and #$7f			and 	#$7F 						; make +ve
.2273	95 32		sta $32,x			sta 	NSStatus,x
.2275	a9 2d		lda #$2d			lda 	#"-"
.2277	80 02		bra $227b			bra 	_CNTMain
.2279					_CNTSNotNegative:
.2279	a9 20		lda #$20			lda 	#" "
.227b					_CNTMain:
.227b	20 dd 22	jsr $22dd			jsr 	WriteDecimalBuffer
.227e	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.2280	f0 0d		beq $228f			beq 	_CNTSNotFloat
.2282	e8		inx				inx 								; round up so we don't get too many 6.999999
.2283	a9 01		lda #$01			lda 	#1
.2285	20 7f 23	jsr $237f			jsr 	FloatSetByte
.2288	b5 6d		lda $6d,x			lda		NSExponent-1,x
.228a	95 6e		sta $6e,x			sta 	NSExponent,x
.228c	20 a1 1d	jsr $1da1			jsr 	FloatAdd
.228f					_CNTSNotFloat:
.228f	20 bf 22	jsr $22bf			jsr 	MakePlusTwoString 			; do the integer part.
.2292	20 5d 1f	jsr $1f5d			jsr 	FloatFractionalPart 		; get the fractional part
.2295	20 d2 20	jsr $20d2			jsr 	FloatNormalise					; normalise , exit if zero
.2298	f0 22		beq $22bc			beq 	_CNTSExit
.229a	a9 2e		lda #$2e			lda 	#"."
.229c	20 dd 22	jsr $22dd			jsr 	WriteDecimalBuffer 			; write decimal place
.229f					_CNTSDecimal:
.229f	ce 35 06	dec $0635			dec 	decimalPlaces 				; done all the decimals
.22a2	30 18		bmi $22bc			bmi 	_CNTSExit
.22a4	e8		inx				inx 								; x 10.0
.22a5	a9 0a		lda #$0a			lda 	#10
.22a7	20 7f 23	jsr $237f			jsr 	FloatSetByte
.22aa	20 3d 20	jsr $203d			jsr 	FloatMultiply
.22ad	20 bf 22	jsr $22bf			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.22b0	20 5d 1f	jsr $1f5d			jsr 	FloatFractionalPart 		; get the fractional part
.22b3	20 d2 20	jsr $20d2			jsr 	FloatNormalise 				; normalise it.
.22b6	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.22b8	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.22ba	b0 e3		bcs $229f			bcs 	_CNTSDecimal 				; keep going.
.22bc					_CNTSExit:
.22bc	7a		ply				ply
.22bd	fa		plx				plx
.22be	60		rts				rts
.22bf					MakePlusTwoString:
.22bf	da		phx				phx
.22c0	20 60 23	jsr $2360			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.22c3	e8		inx				inx 								; access it
.22c4	e8		inx				inx
.22c5	20 b8 1f	jsr $1fb8			jsr 	FloatIntegerPart 			; make it an integer
.22c8	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.22ca	20 fc 22	jsr $22fc			jsr 	ConvertInt32
.22cd	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.22cf					_MPTSCopy:
.22cf	bd 10 06	lda $0610,x			lda 	numberBuffer,x
.22d2	20 dd 22	jsr $22dd			jsr 	WriteDecimalBuffer
.22d5	e8		inx				inx
.22d6	bd 10 06	lda $0610,x			lda 	numberBuffer,x
.22d9	d0 f4		bne $22cf			bne 	_MPTSCopy
.22db	fa		plx				plx
.22dc	60		rts				rts
.22dd					WriteDecimalBuffer:
.22dd	da		phx				phx
.22de	ae 36 06	ldx $0636			ldx 	dbOffset
.22e1	9d 37 06	sta $0637,x			sta 	decimalBuffer,x
.22e4	9e 38 06	stz $0638,x			stz 	decimalBuffer+1,x
.22e7	ee 36 06	inc $0636			inc 	dbOffset
.22ea	fa		plx				plx
.22eb	60		rts				rts
.0635					decimalPlaces:
>0635							.fill 	1
.0636					dbOffset:
>0636							.fill 	1
.0637					decimalBuffer:
>0637							.fill 	32
.22ec					ConvertInt16:
.22ec	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.22ee	86 4a		stx $4a				stx 	NSMantissa1
.22f0	64 56		stz $56				stz 	NSMantissa2
.22f2	64 62		stz $62				stz 	NSMantissa3
.22f4	64 32		stz $32				stz 	NSStatus 					; positive integer
.22f6	a2 00		ldx #$00			ldx 	#0 							; stack level
.22f8	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.22fa	80 00		bra $22fc			bra 	ConvertInt32
.22fc					ConvertInt32:
.22fc	5a		phy				phy
.22fd	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.22ff	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.2301	10 08		bpl $230b			bpl 	_CI32NotNeg
.2303	48		pha				pha
.2304	a9 2d		lda #$2d			lda 	#'-'
.2306	99 10 06	sta $0610,y			sta 	numberBuffer,y
.2309	c8		iny				iny
.230a	68		pla				pla
.230b					_CI32NotNeg:
.230b	20 19 23	jsr $2319			jsr 	_CI32DivideConvert 			; recursive conversion
.230e	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2310	99 10 06	sta $0610,y			sta 	numberBuffer,y
.2313	7a		ply				ply
.2314	a2 06		ldx #$06			ldx 	#numberBuffer >> 8 			; return address in XA
.2316	a9 10		lda #$10			lda 	#numberBuffer & $FF
.2318	60		rts				rts
.2319					_CI32DivideConvert:
.2319	e8		inx				inx 								; write to next slot up
.231a	20 7f 23	jsr $237f			jsr 	FloatSetByte 		 		; write the base out.
.231d	ca		dex				dex
.231e	20 13 1f	jsr $1f13			jsr 	Int32Divide 				; divide
.2321	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.2323	48		pha				pha
.2324	20 02 1f	jsr $1f02			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2327	20 9f 23	jsr $239f			jsr 	FloatIsZero 				; is it zero ?
.232a	f0 05		beq $2331			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.232c	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.232e	20 19 23	jsr $2319			jsr 	_CI32DivideConvert 			; and recusrively call.
.2331					_CI32NoRecurse:
.2331	68		pla				pla 								; remainder
.2332	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2334	90 02		bcc $2338			bcc 	_CI32NotHex
.2336	69 26		adc #$26			adc 	#6+32
.2338					_CI32NotHex:
.2338	69 30		adc #$30			adc 	#48
.233a	99 10 06	sta $0610,y			sta 	numberBuffer,y 				; write out and exit
.233d	c8		iny				iny
.233e	60		rts				rts
.233f					FloatNegate:
.233f	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2341	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2343	95 32		sta $32,x			sta 	NSStatus,x
.2345	60		rts				rts
.2346					FloatNegateMantissa:
.2346	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2347	a9 00		lda #$00			lda 	#0
.2349	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.234b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.234d	a9 00		lda #$00			lda 	#0
.234f	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.2351	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2353	a9 00		lda #$00			lda 	#0
.2355	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.2357	95 56		sta $56,x			sta 	NSMantissa2,x
.2359	a9 00		lda #$00			lda 	#0
.235b	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.235d	95 62		sta $62,x			sta 	NSMantissa3,x
.235f	60		rts				rts
.2360					FloatShiftUpTwo:
.2360	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2362	95 40		sta $40,x			sta 	NSMantissa0+2,x
.2364	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2366	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2368	b5 56		lda $56,x			lda 	NSMantissa2,x
.236a	95 58		sta $58,x			sta 	NSMantissa2+2,x
.236c	b5 62		lda $62,x			lda 	NSMantissa3,x
.236e	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2370	b5 6e		lda $6e,x			lda 	NSExponent,x
.2372	95 70		sta $70,x			sta 	NSExponent+2,x
.2374	b5 32		lda $32,x			lda 	NSStatus,x
.2376	95 34		sta $34,x			sta 	NSStatus+2,x
.2378	60		rts				rts
.2379					FloatSetZeroMantissaOnly:
.2379	74 3e		stz $3e,x			stz 	NSMantissa0,x
.237b	80 08		bra $2385			bra 	FloatZero13
.237d					FloatSetZero:
.237d	a9 00		lda #$00			lda 	#0
.237f					FloatSetByte:
.237f	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2381					FloatSetMantissa:
.2381	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.2383	74 32		stz $32,x			stz 	NSStatus,x
.2385					FloatZero13:
.2385	74 4a		stz $4a,x			stz 	NSMantissa1,x
.2387	74 56		stz $56,x			stz 	NSMantissa2,x
.2389	74 62		stz $62,x			stz 	NSMantissa3,x
.238b	60		rts				rts
.238c					FloatShiftLeft:
.238c	18		clc				clc
.238d					FloatRotateLeft:
.238d	36 3e		rol $3e,x			rol 	NSMantissa0,x
.238f	36 4a		rol $4a,x			rol		NSMantissa1,x
.2391	36 56		rol $56,x			rol		NSMantissa2,x
.2393	36 62		rol $62,x			rol		NSMantissa3,x
.2395	60		rts				rts
.2396					FloatShiftRight:
.2396	56 62		lsr $62,x			lsr 	NSMantissa3,x
.2398	76 56		ror $56,x			ror		NSMantissa2,x
.239a	76 4a		ror $4a,x			ror		NSMantissa1,x
.239c	76 3e		ror $3e,x			ror		NSMantissa0,x
.239e	60		rts				rts
.239f					FloatIsZero:
.239f	b5 62		lda $62,x			lda 	NSMantissa3,x
.23a1	15 56		ora $56,x			ora		NSMantissa2,x
.23a3	15 4a		ora $4a,x			ora		NSMantissa1,x
.23a5	15 3e		ora $3e,x			ora		NSMantissa0,x
.23a7	60		rts				rts

;******  Processing input file: testing/testend.asm

.23a8					EndProgram:
>23a8	00 40 d4 54 00 a6 04 48				.binary "code/balls.bin"
>23b0	00 a6 03 c7 a6 cb 93 93 b1 a6 40 00 01 00 ca 81
>23c0	58 03 40 00 01 00 ca 81 58 06 40 00 01 00 ca 81
>23d0	58 09 a6 40 00 01 00 ca 81 58 0c 40 00 01 00 ca
>23e0	81 58 0f a6 00 48 12 24 40 00 01 95 a6 40 12 01
>23f0	50 03 8e 01 b4 28 82 ca 84 02 82 01 80 7c a6 40
>2400	12 01 50 06 8e 01 b4 1e 82 ca 84 cc 00 01 82 7c
>2410	a6 40 12 01 50 09 8e 01 b4 0e 82 ca 84 01 80 7c
>2420	a6 40 12 01 50 0c 8e 01 b4 02 82 ca 84 7c a6 a6
>2430	40 12 01 50 0f 8e 01 7c a6 24 a7 a6 a6 00 48 15
>2440	2a 1d 01 95 00 48 18 30 27 01 95 a6 40 15 cc 00
>2450	01 82 40 18 02 82 80 cc 00 b0 80 48 1b a6 01 40
>2460	1b cb 51 c8 01 40 1b 01 80 00 c8 a6 30 a7 2a a7
>2470	a6 01 48 12 24 40 00 01 95 a6 01 cc 00 b0 40 12
>2480	01 50 06 8e 78 80 40 12 01 50 03 8e 78 80 00 c8
>2490	a6 40 12 01 50 0c 8e 78 48 1e a6 40 1e 00 a3 88
>24a0	d2 00 07 00 d1 00 5d 00 a6 40 1e 01 a3 88 d2 00
>24b0	07 00 d1 00 7a 00 a6 40 12 01 50 0f 8e 78 48 21
>24c0	a6 40 21 00 a3 88 d2 00 07 00 d1 00 97 00 a6 40
>24d0	21 01 a3 88 d2 00 07 00 d1 00 b6 00 a6 01 cc 00
>24e0	b0 40 12 01 50 06 8e 78 80 40 12 01 50 03 8e 78
>24f0	80 40 12 01 50 09 8e 78 c8 a6 24 a7 a6 d0 00 72
>2500	ff a6 a6 40 12 01 50 03 8e 78 48 24 a6 40 24 01
>2510	a3 88 d2 00 0c 00 40 12 01 50 0c 8e 01 7c 98 a6
>2520	40 12 01 50 03 8e 40 24 02 81 7c 98 a6 a6 40 12
>2530	01 50 03 8e 78 48 24 a6 40 24 cb 4f a3 88 d2 00
>2540	15 00 40 12 01 50 03 8e cb 4d 7c 40 12 01 50 0c
>2550	8e 00 7c 98 a6 40 12 01 50 03 8e 40 24 02 80 7c
>2560	98 a6 a6 40 12 01 50 06 8e 78 48 27 a6 40 27 00
>2570	a3 88 d2 00 0c 00 40 12 01 50 0f 8e 01 7c 98 a6
>2580	40 12 01 50 06 8e 40 27 cc 00 01 81 7c 98 a6 a6
>2590	40 12 01 50 06 8e 78 48 27 a6 40 27 cc 00 1d a3
>25a0	88 d2 00 16 00 40 12 01 50 06 8e cc 00 1c 7c 40
>25b0	12 01 50 0f 8e 00 7c 98 a6 40 12 01 50 06 8e 40
>25c0	27 cc 00 01 80 7c 98 c4 ff

;******  End of listing
