
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Sat Oct  7 12:22:26 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.1000					WrapperBoot:
.1000	a2 0a		ldx #$0a			ldx 	#APIDesc & $FF
.1002	a0 10		ldy #$10			ldy 	#APIDesc >> 8
.1004	20 4b 11	jsr $114b			jsr 	StartCompiler
.1007	4c ff ff	jmp $ffff			jmp 	$FFFF
.100a					APIDesc:
>100a							.fill 	2
>100c	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>100d	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing file: testing/api/close.asm

.100e					APIOClose:
.100e	a9 40		lda #$40			lda 	#(PCodeStart >> 8)
.1010	a6 29		ldx $29				ldx 	objPtr
.1012	a4 2a		ldy $2a				ldy 	objPtr+1
.1014	20 5e 10	jsr $105e			jsr 	APISaveMemory
.1017	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/fromram.asm

.1018					APIIOpen:
.1018	a9 94		lda #$94			lda 	#((EndProgram+2) & $FF)
.101a	85 22		sta $22				sta 	0+srcInputPtr
.101c	a9 26		lda #$26			lda 	#((EndProgram+2) >> 8) & $FF
.101e	85 23		sta $23				sta 	1+srcInputPtr
.1020					APIIClose:
.1020	60		rts				rts
.0022					srcInputPtr:
>0022							.fill 	2

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/line.asm

.1021					ReadNextLine:
.1021	b2 22		lda ($22)			lda 	(srcInputPtr) 				; reached the end of the program (address link = $0000)
.1023	a0 01		ldy #$01			ldy 	#1
.1025	11 22		ora ($22),y			ora 	(srcInputPtr),y
.1027	d0 02		bne $102b			bne 	_RLAHaveData
.1029	18		clc				clc
.102a	60		rts				rts									; end of file.
.102b					_RLAHaveData:
.102b	a6 22		ldx $22				ldx 	srcInputPtr 				; remember the line start
.102d	a4 23		ldy $23				ldy 	srcInputPtr+1
.102f	5a		phy				phy
.1030	a0 04		ldy #$04			ldy 	#4 							; must be at least four bytes (address/line#)
.1032					_RNLRead:
.1032	b1 22		lda ($22),y			lda 	(srcInputPtr),y 			; find the end of the line.
.1034	c8		iny				iny
.1035	c9 00		cmp #$00			cmp 	#0
.1037	d0 f9		bne $1032			bne 	_RNLRead
.1039	98		tya				tya 								; advance src input pointer to next.
.103a	18		clc				clc
.103b	65 22		adc $22				adc 	srcInputPtr
.103d	85 22		sta $22				sta 	srcInputPtr
.103f	90 02		bcc $1043			bcc 	_RNLNoCarry
.1041	e6 23		inc $23				inc 	srcInputPtr+1
.1043					_RNLNoCarry:
.1043	7a		ply				ply 								; address of line now in YX.
.1044	38		sec				sec
.1045	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/open.asm

.1046					APIOOpen:
.1046					APIORewind:
.1046	64 2b		stz $2b				stz 	objPage
.1048	a9 00		lda #$00			lda 	#((PCodeStart) & $FF)
.104a	85 29		sta $29				sta 	0+objPtr
.104c	a9 40		lda #$40			lda 	#((PCodeStart) >> 8) & $FF
.104e	85 2a		sta $2a				sta 	1+objPtr
.1050	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/writebyte.asm

.1051					APIOWriteByte:
.1051	92 29		sta ($29)			sta 	(objPtr)
.1053	e6 29		inc $29				inc 	objPtr
.1055	d0 02		bne $1059			bne 	_HWOWBNoCarry
.1057	e6 2a		inc $2a				inc 	objPtr+1
.1059					_HWOWBNoCarry:
.1059	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_config.inc

=$4000					PCodeStart = $4000

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_printchar.asm

.105a					APIOPrintCharacter
.105a	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.105d	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_save.asm

.105e					APISaveMemory:
.105e	da		phx				phx
.105f	5a		phy				phy
.1060	48		pha				pha
.1061	a9 00		lda #$00			lda 	#0 							; set LFS
.1063	a2 08		ldx #$08			ldx 	#8
.1065	a0 00		ldy #$00			ldy 	#0
.1067	20 ba ff	jsr $ffba			jsr 	$FFBA
.106a	a9 08		lda #$08			lda 	#8 							; set file name
.106c	a2 80		ldx #$80			ldx 	#SaveName & $FF
.106e	a0 10		ldy #$10			ldy 	#SaveName >> 8
.1070	20 bd ff	jsr $ffbd			jsr 	$FFBD
.1073	68		pla				pla 								; set up the start address.
.1074	85 2e		sta $2e				sta 	zTemp0+1
.1076	64 2d		stz $2d				stz 	zTemp0
.1078	a9 2d		lda #$2d			lda 	#zTemp0 					; from index.
.107a	7a		ply				ply 								; end in YX
.107b	fa		plx				plx
.107c	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.107f	60		rts				rts
.1080					SaveName:
>1080	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Return to file: testing/testing.asm


;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READ = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_ADJUSTOBJECT = 6
=7					BLC_PRINTCHAR = 7
.0024					srcPtr:
>0024							.fill 	2
.0400					currentLineNumber:
>0400							.fill 	2
.1088					InlineNonDecimal:
.1088	a2 02		ldx #$02			ldx 	#2 							; get size in X
.108a	c9 25		cmp #$25			cmp 	#"%"
.108c	f0 02		beq $1090			beq 	_INDBinary
.108e	a2 10		ldx #$10			ldx 	#16
.1090					_INDBinary:
.1090	85 2f		sta $2f				sta 	zTemp1 						; size => zTemp1
.1092	64 30		stz $30				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.1094	64 2d		stz $2d				stz 	zTemp0 						; zero result
.1096	64 2e		stz $2e				stz 	zTemp0+1
.1098					_INDLoop:
.1098	20 1d 1a	jsr $1a1d			jsr 	LookNext 					; check next character
.109b	20 59 1a	jsr $1a59			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.109e	90 1f		bcc $10bf			bcc		_INDDone 					; didn't convert
.10a0	c5 2f		cmp $2f				cmp 	zTemp1 						; size too large ?
.10a2	b0 1b		bcs $10bf			bcs 	_INDDone
.10a4	20 ce 10	jsr $10ce			jsr 	_INDShift 					; x 2 or x 16
.10a7	e0 02		cpx #$02			cpx 	#2
.10a9	f0 09		beq $10b4			beq 	_INDNotHex
.10ab	20 ce 10	jsr $10ce			jsr 	_INDShift
.10ae	20 ce 10	jsr $10ce			jsr 	_INDShift
.10b1	20 ce 10	jsr $10ce			jsr 	_INDShift
.10b4					_INDNotHex:
.10b4	05 2d		ora $2d				ora 	zTemp0 						; or digit into result
.10b6	85 2d		sta $2d				sta 	zTemp0
.10b8	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume
.10bb	e6 30		inc $30				inc 	zTemp1+1 					; bump count
.10bd	80 d9		bra $1098			bra 	_INDLoop
.10bf					_INDDone:
.10bf	a5 30		lda $30				lda 	zTemp1+1 					; done at least 1 ?
.10c1	f0 08		beq $10cb			beq 	_INDError
.10c3	a4 2e		ldy $2e				ldy 	zTemp0+1 					; push constant
.10c5	a5 2d		lda $2d				lda 	zTemp0
.10c7	20 d8 11	jsr $11d8			jsr 	PushIntegerYA
.10ca	60		rts				rts
.10cb					_INDError:
.10cb	4c 21 1f	jmp $1f21		jmp	ErrorV_syntax
.10ce					_INDShift:
.10ce	06 2d		asl $2d				asl 	zTemp0
.10d0	26 2e		rol $2e				rol 	zTemp0+1
.10d2	60		rts				rts
.10d3					GetLineNumber:
.10d3	ac 01 04	ldy $0401			ldy 	currentLineNumber+1
.10d6	ad 00 04	lda $0400			lda 	currentLineNumber
.10d9	60		rts				rts
.10da					WriteCodeByte:
.10da	48		pha				pha 								; save on stack
.10db	da		phx				phx
.10dc	5a		phy				phy
.10dd	20 51 10	jsr $1051			jsr 	APIOWriteByte
.10e0	7a		ply				ply 								; restore from stack
.10e1	fa		plx				plx
.10e2	68		pla				pla
.10e3	60		rts				rts
.10e4					PrintCharacter
.10e4	48		pha				pha
.10e5	da		phx				phx
.10e6	5a		phy				phy
.10e7	20 5a 10	jsr $105a			jsr 	APIOPrintCharacter
.10ea	7a		ply				ply
.10eb	fa		plx				plx
.10ec	68		pla				pla
.10ed	60		rts				rts
.10ee					ProcessNewLine:
.10ee	86 2d		stx $2d				stx 	zTemp0 						; save address in zTemp0
.10f0	84 2e		sty $2e				sty 	zTemp0+1
.10f2	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.10f3	8a		txa				txa
.10f4	69 04		adc #$04			adc 	#4
.10f6	85 24		sta $24				sta 	srcPtr
.10f8	98		tya				tya
.10f9	69 00		adc #$00			adc 	#0
.10fb	85 25		sta $25				sta 	srcPtr+1
.10fd	a0 02		ldy #$02			ldy 	#2							; read and save line number
.10ff	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.1101	8d 00 04	sta $0400			sta 	currentLineNumber
.1104	c8		iny				iny
.1105	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.1107	8d 01 04	sta $0401			sta 	currentLineNumber+1
.110a	60		rts				rts
.110b					BufferClear:
.110b	9c 02 04	stz $0402			stz 	bufferSize
.110e	60		rts				rts
.110f					BufferWrite:
.110f	da		phx				phx
.1110	ae 02 04	ldx $0402			ldx 	bufferSize
.1113	9d 03 04	sta $0403,x			sta 	dataBuffer,x
.1116	ee 02 04	inc $0402			inc 	bufferSize
.1119	fa		plx				plx
.111a	60		rts				rts
.111b					BufferOutput:
.111b	ad 02 04	lda $0402			lda 	bufferSize
.111e	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1121	a2 00		ldx #$00			ldx 	#0
.1123					_BOLoop:
.1123	ec 02 04	cpx $0402			cpx 	bufferSize
.1126	f0 09		beq $1131			beq 	_BOExit
.1128	bd 03 04	lda $0403,x			lda 	dataBuffer,x
.112b	20 da 10	jsr $10da			jsr 	WriteCodeByte
.112e	e8		inx				inx
.112f	80 f2		bra $1123			bra 	_BOLoop
.1131					_BOExit:
.1131	60		rts				rts
.0402					bufferSize:
>0402							.fill 	1
.0403					dataBuffer:
>0403							.fill 	256
.1132					CheckNextComma:
.1132	a9 2c		lda #$2c			lda	 	#","
.1134	80 06		bra $113c			bra 	CheckNextA
.1136					CheckNextRParen:
.1136	a9 29		lda #$29			lda	 	#")"
.1138	80 02		bra $113c			bra 	CheckNextA
.113a					CheckNextLParen:
.113a	a9 28		lda #$28			lda 	#"("
.113c					CheckNextA:
.113c	8d 03 05	sta $0503			sta 	checkCharacter 				; save test character
.113f					_CNALoop:
.113f	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; get next skipping spaces.
.1142	cd 03 05	cmp $0503			cmp 	checkCharacter 				; matches ?
.1145	f0 03		beq $114a			beq 	_CNAExit
.1147	4c 21 1f	jmp $1f21		jmp	ErrorV_syntax
.114a					_CNAExit:
.114a	60		rts				rts
.0503					checkCharacter:
>0503							.fill 	1
.114b					StartCompiler:
.114b	86 2d		stx $2d				stx 	zTemp0 						; access API
.114d	84 2e		sty $2e				sty 	zTemp0+1
.114f	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.1151	b2 2d		lda ($2d)			lda 	(zTemp0)
.1153	8d 05 05	sta $0505			sta 	APIVector
.1156	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.1158	8d 06 05	sta $0506			sta 	APIVector+1
.115b	c8		iny				iny 								; copy data area range.
.115c	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.115e	8d 07 05	sta $0507			sta 	compilerStartHigh
.1161	c8		iny				iny
.1162	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.1164	8d 08 05	sta $0508			sta 	compilerEndHigh
.1167	ba		tsx				tsx 								; save stack pointer
.1168	8e 04 05	stx $0504			stx 	compilerSP
.116b	20 c6 1d	jsr $1dc6			jsr 	STRReset 					; reset storage (line#, variable)
.116e	20 18 10	jsr $1018			jsr 	APIIOpen 					; reset data input
.1171	20 46 10	jsr $1046			jsr 	APIOOpen 					; reset data output.
.1174	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.1176	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1179	a9 00		lda #$00			lda 	#0
.117b	20 da 10	jsr $10da			jsr 	WriteCodeByte
.117e	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1181					MainCompileLoop:
.1181	20 21 10	jsr $1021			jsr 	ReadNextLine 				; read next line into the buffer.
.1184	90 31		bcc $11b7			bcc 	SaveCodeAndExit 			; end of source.
.1186	20 ee 10	jsr $10ee			jsr 	ProcessNewLine 				; set up pointer and line number.
.1189	20 d3 10	jsr $10d3			jsr 	GetLineNumber 				; get line #
.118c	20 a7 1b	jsr $1ba7			jsr 	STRMarkLine 				; remember the code position and number of this line.
.118f	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.1191	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1194					_MCLSameLine:
.1194	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; get the first character.
.1197	f0 e8		beq $1181			beq 	MainCompileLoop 			; end of line, get next line.
.1199	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.119b	f0 f7		beq $1194			beq 	_MCLSameLine
.119d	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.119f	10 0c		bpl $11ad			bpl 	_MCLCheckAssignment
.11a1	a2 fa		ldx #$fa			ldx 	#CommandTables & $FF 		; do command tables.
.11a3	a0 15		ldy #$15			ldy 	#CommandTables >> 8
.11a5	20 c2 18	jsr $18c2			jsr 	GeneratorProcess
.11a8	b0 ea		bcs $1194			bcs 	_MCLSameLine 				; keep trying to compile the line.
.11aa					_MCLSyntax:
.11aa	4c 21 1f	jmp $1f21		jmp	ErrorV_syntax
.11ad					_MCLCheckAssignment:
.11ad	20 4f 1a	jsr $1a4f			jsr 	CharIsAlpha 				; if not alpha then syntax error
.11b0	90 f8		bcc $11aa			bcc 	_MCLSyntax
.11b2	20 75 1b	jsr $1b75			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.11b5	80 dd		bra $1194			bra		_MCLSameLine 				; loop back.
.11b7					SaveCodeAndExit:
.11b7	20 20 10	jsr $1020			jsr 	APIIClose 					; finish input.
.11ba	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.11bc	a8		tay				tay
.11bd	20 a7 1b	jsr $1ba7			jsr 	STRMarkLine
.11c0	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.11c2	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11c5	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.11c7	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11ca	20 f4 14	jsr $14f4			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.11cd	20 0e 10	jsr $100e			jsr 	APIOClose
.11d0					ExitCompiler:
.11d0	ae 04 05	ldx $0504			ldx 	compilerSP 					; reload SP and exit.
.11d3	9a		txs				txs
.11d4	60		rts				rts
.11d5					CallAPIHandler:
.11d5	6c 05 05	jmp ($0505)			jmp 	(APIVector)
.0504					compilerSP:
>0504							.fill 	1
.0505					APIVector:
>0505							.fill 	2
.0507					compilerStartHigh:
>0507							.fill 	1
.0508					compilerEndHigh:
>0508							.fill 	1
.11d8					PushIntegerYA:
.11d8	c0 00		cpy #$00			cpy 	#0 							; 0-255
.11da	f0 0f		beq $11eb			beq 	PushIntegerA
.11dc	48		pha				pha
.11dd	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.11df	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11e2	68		pla				pla 								; then LSB
.11e3	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11e6	98		tya				tya 								; then MSB
.11e7	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11ea	60		rts				rts
.11eb					PushIntegerA:
.11eb	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.11ed	90 07		bcc $11f6			bcc 	_PIWriteA
.11ef	48		pha				pha
.11f0	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.11f2	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11f5	68		pla				pla
.11f6					_PIWriteA:
.11f6	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11f9	60		rts				rts
.11fa					PushFloat:
.11fa	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.11fc	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11ff	b5 6f		lda $6f,x			lda 	NSExponent,x 				; and the data
.1201	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1204	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.1206	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1209	b5 4b		lda $4b,x			lda 	NSMantissa1,x
.120b	20 da 10	jsr $10da			jsr 	WriteCodeByte
.120e	b5 57		lda $57,x			lda 	NSMantissa2,x
.1210	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1213	b5 33		lda $33,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.1215	29 80		and #$80			and 	#$80
.1217	15 63		ora $63,x			ora 	NSMantissa3,x
.1219	20 da 10	jsr $10da			jsr 	WriteCodeByte
.121c	60		rts				rts
.121d					CreateVariableRecord:
.121d	48		pha				pha
.121e	ad 13 05	lda $0513			lda 	freeVariableMemory 		; push current free address on stack.
.1221	48		pha				pha
.1222	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1225	48		pha				pha
.1226	ad 11 05	lda $0511			lda 	variableListEnd  		; copy end of list to zTemp0
.1229	85 2d		sta $2d				sta 	zTemp0
.122b	ad 12 05	lda $0512			lda 	variableListEnd+1
.122e	85 2e		sta $2e				sta 	zTemp0+1
.1230	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.1232	92 2d		sta ($2d)			sta 	(zTemp0)
.1234	98		tya				tya
.1235	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.1237	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1239	88		dey				dey
.123a	8a		txa				txa
.123b	91 2d		sta ($2d),y			sta 	(zTemp0),y
.123d	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.123f	ad 13 05	lda $0513			lda 	freeVariableMemory
.1242	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1244	c8		iny				iny
.1245	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1248	91 2d		sta ($2d),y			sta 	(zTemp0),y
.124a	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.124c	a9 00		lda #$00			lda 	#0
.124e	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1250	18		clc				clc
.1251	b2 2d		lda ($2d)			lda 	(zTemp0) 				; add offset to variableListEnd
.1253	6d 11 05	adc $0511			adc  	variableListEnd
.1256	8d 11 05	sta $0511			sta 	variableListEnd
.1259	90 03		bcc $125e			bcc 	_CVNoCarry2
.125b	ee 12 05	inc $0512			inc 	variableListEnd+1
.125e					_CVNoCarry2:
.125e	7a		ply				ply
.125f	fa		plx				plx
.1260	68		pla				pla
.1261	60		rts				rts
.1262					SetVariableRecordToCodePosition:
.1262	48		pha				pha
.1263	5a		phy				phy
.1264	a5 2b		lda $2b				lda 	objPage
.1266	a0 03		ldy #$03			ldy 	#3
.1268	91 2d		sta ($2d),y			sta 	(zTemp0),y
.126a	c8		iny				iny
.126b	a5 2a		lda $2a				lda 	objPtr+1
.126d	91 2d		sta ($2d),y			sta 	(zTemp0),y
.126f	c8		iny				iny
.1270	a5 29		lda $29				lda 	objPtr
.1272	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1274	7a		ply				ply
.1275	68		pla				pla
.1276	60		rts				rts
.1277					AllocateBytesForType:
.1277	48		pha				pha
.1278	da		phx				phx
.1279	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.127b	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.127d	c9 00		cmp #$00			cmp 	#NSSIFloat
.127f	d0 02		bne $1283			bne 	_CVNotFloat
.1281	a2 06		ldx #$06			ldx 	#6
.1283					_CVNotFloat:
.1283	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.1284	18		clc				clc
.1285	6d 13 05	adc $0513			adc 	freeVariableMemory
.1288	8d 13 05	sta $0513			sta 	freeVariableMemory
.128b	90 03		bcc $1290			bcc 	_CVNoCarry1
.128d	ee 14 05	inc $0514			inc 	freeVariableMemory+1
.1290					_CVNoCarry1:
.1290	fa		plx				plx
.1291	68		pla				pla
.1292	60		rts				rts
.1293					CommandDATA:
.1293	20 0b 11	jsr $110b			jsr 	BufferClear 				; copy it to the buffer
.1296	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace
.1299					_CTDataLoop:
.1299	20 1d 1a	jsr $1a1d			jsr 	LookNext 					; reached EOL
.129c	f0 08		beq $12a6			beq 	_CTDataDone
.129e	20 0f 11	jsr $110f			jsr 	BufferWrite 				; write and consume
.12a1	20 2e 1a	jsr $1a2e			jsr 	GetNext
.12a4	80 f3		bra $1299			bra 	_CTDataLoop
.12a6					_CTDataDone:
.12a6	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.12a8	20 da 10	jsr $10da			jsr 	WriteCodeByte
.12ab	20 1b 11	jsr $111b			jsr 	BufferOutput
.12ae	60		rts				rts
.12af					CommandDEF:
.12af	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.12b1	20 eb 11	jsr $11eb			jsr 	PushIntegerA
.12b4	20 3e 1b	jsr $1b3e			jsr 	CompileGotoEOL 				; compile skip over DEF
.12b7	a9 a5		lda #$a5			lda 	#C64_FN
.12b9	20 3c 11	jsr $113c			jsr 	CheckNextA
.12bc	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.12bf	20 9e 1a	jsr $1a9e			jsr 	ExtractVariableName
.12c2	8a		txa				txa
.12c3	10 51		bpl $1316			bpl 	_CDError
.12c5	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.12c6	29 7f		and #$7f			and 	#$7F
.12c8	aa		tax				tax
.12c9	98		tya				tya
.12ca	09 80		ora #$80			ora 	#$80
.12cc	a8		tay				tay
.12cd	20 98 14	jsr $1498			jsr 	FindVariable				; does it already exist ?
.12d0	b0 44		bcs $1316			bcs 	_CDError 					; if so, that's an error.
.12d2	20 1d 12	jsr $121d			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.12d5	20 62 12	jsr $1262			jsr 	SetVariableRecordToCodePosition
.12d8	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace
.12db	20 83 1d	jsr $1d83			jsr 	GetReferenceTerm 			; get var ref, not array
.12de	c9 00		cmp #$00			cmp 	#0
.12e0	30 34		bmi $1316			bmi 	_CDError
.12e2	8d 09 05	sta $0509			sta 	defType 					; save type
.12e5	8e 0a 05	stx $050a			stx 	defVariable 				; save var ref
.12e8	8c 0b 05	sty $050b			sty 	defVariable+1
.12eb	29 40		and #$40			and 	#NSSString 					; only numbers.
.12ed	d0 27		bne $1316			bne 	_CDError
.12ef	20 36 11	jsr $1136			jsr 	CheckNextRParen 			; check )
.12f2	a9 b2		lda #$b2			lda 	#C64_EQUAL
.12f4	20 3c 11	jsr $113c			jsr 	CheckNextA 					; check =
.12f7	18		clc				clc 								; if this is DEF FNxx(A), read A
.12f8	20 19 13	jsr $1319			jsr 	CDReadWriteVariable
.12fb	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.12fd	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1300	38		sec				sec
.1301	20 19 13	jsr $1319			jsr 	CDReadWriteVariable 		; A is now updated
.1304	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; the actual body of the function.
.1307	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1309	20 da 10	jsr $10da			jsr 	WriteCodeByte
.130c	38		sec				sec
.130d	20 19 13	jsr $1319			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.1310	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.1312	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1315	60		rts				rts
.1316					_CDError:
.1316	4c 21 1f	jmp $1f21		jmp	ErrorV_syntax
.1319					CDReadWriteVariable:
.1319	ac 0b 05	ldy $050b			ldy 	defVariable+1 				; set up YX
.131c	ae 0a 05	ldx $050a			ldx 	defVariable
.131f	ad 09 05	lda $0509			lda 	defType
.1322	20 35 1d	jsr $1d35			jsr 	GetSetVariable
.1325	60		rts				rts
.0509					defType:
>0509							.fill 	1
.050a					defVariable:
>050a							.fill 	2
.1326					CommandDIM:
.1326	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; get the first non space character
.1329	20 9e 1a	jsr $1a9e			jsr 	ExtractVariableName 		; variable name to XY
.132c	da		phx				phx 								; save name with type bits.
.132d	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.132f	10 37		bpl $1368			bpl 	_CDError
.1331	20 98 14	jsr $1498			jsr 	FindVariable	 			; see if already exist
.1334	b0 35		bcs $136b			bcs 	_CDRedefine 				; it still exists.
.1336	20 1d 12	jsr $121d			jsr 	CreateVariableRecord 		; create the basic variable
.1339	20 77 12	jsr $1277			jsr 	AllocateBytesForType 		; allocate memory for it
.133c	68		pla				pla 								; restore type bits
.133d	5a		phy				phy 								; save the address of the basic storage
.133e	da		phx				phx
.133f	48		pha				pha
.1340	20 6e 13	jsr $136e			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.1343	68		pla				pla
.1344	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.1346	20 eb 11	jsr $11eb			jsr 	PushIntegerA 				; push that type data out.
.1349	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.134b	20 da 10	jsr $10da			jsr 	WriteCodeByte
.134e	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.1350	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1353	fa		plx				plx 								; restore address
.1354	7a		ply				ply
.1355	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1357	38		sec				sec
.1358	20 35 1d	jsr $1d35			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.135b	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; , follows ?
.135e	c9 2c		cmp #$2c			cmp 	#","
.1360	d0 05		bne $1367			bne 	_CDExit
.1362	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume comma
.1365	80 bf		bra $1326			bra 	CommandDIM 					; do another DIM
.1367					_CDExit:
.1367	60		rts				rts
.1368					_CDError:
.1368	4c 21 1f	jmp $1f21		jmp	ErrorV_syntax
.136b					_CDRedefine:
.136b	4c e9 1f	jmp $1fe9		jmp	ErrorV_redefine
.136e					OutputIndexGroup:
.136e	9c 0c 05	stz $050c			stz 	IndexCount 					; count of number of indices.
.1371					_OIGNext:
.1371	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; get a dimension
.1374	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1376	c9 00		cmp #$00			cmp 	#NSSIFloat
.1378	d0 19		bne $1393			bne 	_OIGType
.137a	ee 0c 05	inc $050c			inc 	IndexCount 					; bump the counter.
.137d	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; does a , follow ?
.1380	c9 2c		cmp #$2c			cmp 	#","
.1382	d0 05		bne $1389			bne 	_OIGCheckEnd
.1384	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume comma
.1387	80 e8		bra $1371			bra 	_OIGNext 					; get next dimension
.1389					_OIGCheckEnd:
.1389	20 36 11	jsr $1136			jsr 	CheckNextRParen 			; check and consume )
.138c	ad 0c 05	lda $050c			lda 	IndexCount
.138f	20 eb 11	jsr $11eb			jsr 	PushIntegerA 				; compile the dimension count.
.1392	60		rts				rts
.1393					_OIGType:
.1393	4c 31 1f	jmp $1f31		jmp	ErrorV_type
.050c					IndexCount:
>050c							.fill 	1
.1396					ErrorHandler:
.1396	68		pla				pla
.1397	7a		ply				ply
.1398	85 2d		sta $2d				sta 	zTemp0
.139a	84 2e		sty $2e				sty 	zTemp0+1
.139c	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.139e	a0 01		ldy #$01			ldy 	#1
.13a0					_EHDisplayMsg:
.13a0	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.13a2	20 e4 10	jsr $10e4			jsr 	PrintCharacter
.13a5	c8		iny				iny
.13a6	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.13a8	d0 f6		bne $13a0			bne 	_EHDisplayMsg
.13aa	a9 20		lda #$20			lda 	#32
.13ac	20 e4 10	jsr $10e4			jsr 	PrintCharacter
.13af	a9 40		lda #$40			lda 	#64
.13b1	20 e4 10	jsr $10e4			jsr 	PrintCharacter
.13b4	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.13b6	20 69 26	jsr $2669			jsr 	FloatSetByte
.13b9	20 d3 10	jsr $10d3			jsr 	GetLineNumber
.13bc	95 3f		sta $3f,x			sta 	NSMantissa0,x
.13be	98		tya				tya
.13bf	95 4b		sta $4b,x			sta 	NSMantissa1,x
.13c1	20 4f 25	jsr $254f			jsr 	FloatToString
.13c4	a0 00		ldy #$00			ldy 	#0 							; display that string.
.13c6	a2 00		ldx #$00			ldx 	#0
.13c8					_EHDisplayLine:
.13c8	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13cb	20 e4 10	jsr $10e4			jsr 	PrintCharacter
.13ce	c8		iny				iny
.13cf	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13d2	d0 f4		bne $13c8			bne 	_EHDisplayLine
.13d4	a9 0d		lda #$0d			lda 	#13
.13d6	20 e4 10	jsr $10e4			jsr 	PrintCharacter
.13d9	80 fe		bra $13d9	_EHHalt:bra 	_EHHalt
.13db	4c d0 11	jmp $11d0			jmp 	ExitCompiler
.13de					CompileExpressionAt0:
.13de	a9 00		lda #$00			lda 	#0
.13e0					CompileExpressionAtA:
.13e0	48		pha				pha  								; save level
.13e1	20 ee 1d	jsr $1dee			jsr 	CompileTerm 				; compile a term.
.13e4	fa		plx				plx 								; get level back into X
.13e5					_ECALoop:
.13e5	48		pha				pha 								; save type on stack.
.13e6	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; get the next character
.13e9	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.13eb	90 04		bcc $13f1			bcc 	_ECAExit
.13ed	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.13ef	90 02		bcc $13f3			bcc 	_ECAHaveToken
.13f1					_ECAExit:
.13f1	68		pla				pla 								; throw type off stack
.13f2	60		rts				rts
.13f3					_ECAHaveToken:
.13f3	86 2d		stx $2d				stx 	zTemp0 						; save current precedence in zTemp0
.13f5	aa		tax				tax 								; X contains the operator token
.13f6	bd e1 13	lda $13e1,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.13f9	c5 2d		cmp $2d				cmp 	zTemp0 						; if < then exit
.13fb	90 f4		bcc $13f1			bcc 	_ECAExit
.13fd	85 2e		sta $2e				sta 	zTemp0+1 					; save the precedence of the operator.
.13ff	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume the token.
.1402	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.1404	f0 11		beq $1417			beq 	_ECAGreaterCheck
.1406	e0 b3		cpx #$b3			cpx 	#C64_LESS
.1408	d0 1a		bne $1424			bne 	_ECAHaveFullToken
.140a	20 1d 1a	jsr $1a1d			jsr 	LookNext 					; checks for < (<= or <>)
.140d	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.140f	f0 0e		beq $141f			beq	 	_ECAToNotEqual
.1411	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.1413	d0 0f		bne $1424			bne 	_ECAHaveFullToken
.1415	80 07		bra $141e			bra 	_ECAAddEqual
.1417					_ECAGreaterCheck:
.1417	20 1d 1a	jsr $1a1d			jsr 	LookNext
.141a	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.141c	d0 06		bne $1424			bne 	_ECAHaveFullToken
.141e					_ECAAddEqual:
.141e	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.141f					_ECAToNotEqual:
.141f	e8		inx				inx
.1420	e8		inx				inx
.1421	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume the = or > in >= <= <>
.1424					_ECAHaveFullToken:
.1424	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.1426	d0 0a		bne $1432			bne 	_ECANotConcat
.1428	68		pla				pla 								; get type back
.1429	48		pha				pha
.142a	29 40		and #$40			and 	#NSSTypeMask
.142c	c9 40		cmp #$40			cmp 	#NSSString
.142e	d0 02		bne $1432			bne 	_ECANotConcat
.1430	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1432					_ECANotConcat:
.1432	da		phx				phx 								; save operator on the stack
.1433	a6 2d		ldx $2d				ldx 	zTemp0 						; push current precedence on the stack
.1435	da		phx				phx
.1436	a5 2e		lda $2e				lda 	zTemp0+1 					; get precedence of operator
.1438	1a		inc a				inc 	a
.1439	20 e0 13	jsr $13e0			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.143c	85 2d		sta $2d				sta 	zTemp0 						; save type in zTemp0
.143e	fa		plx				plx 								; restore current precedence in X
.143f	68		pla				pla 								; restore operator
.1440	85 2e		sta $2e				sta 	zTemp0+1 					; save it in zTemp0+1.
.1442	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.1444	90 17		bcc $145d			bcc 	_ECANotCompare
.1446	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.1448	b0 13		bcs $145d			bcs 	_ECANotCompare
.144a	7a		ply				ply 								; get type into Y
.144b	5a		phy				phy
.144c	48		pha				pha 								; save operator
.144d	98		tya				tya 								; get type
.144e	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.1450	29 40		and #$40			and 	#NSSTypeMask
.1452	c9 40		cmp #$40			cmp 	#NSSString
.1454	f0 02		beq $1458			beq 	_ECANotString
.1456	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.1458					_ECANotString:
.1458	98		tya				tya									; output token Y
.1459	20 da 10	jsr $10da			jsr 	WriteCodeByte
.145c	68		pla				pla 								; restore operator.
.145d					_ECANotCompare:
.145d	18		clc				clc 								; convert to P-Code and compile.
.145e	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.1460	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1463	68		pla				pla 								; type of current result
.1464	45 2d		eor $2d				eor 	zTemp0 						; check compatible with r-expr type
.1466	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.1468	d0 19		bne $1483			bne		_ECAType
.146a	a5 2d		lda $2d				lda 	zTemp0 						; get type back
.146c	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.146e	d0 18		bne $1488			bne 	_ECAGoLoop
.1470	a5 2e		lda $2e				lda 	zTemp0+1 					; check operator is + or comparator
.1472	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1474	f0 10		beq $1486			beq 	_ECAOkayString 				; (this is post conversion)
.1476	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.1478	90 09		bcc $1483			bcc 	_ECAType
.147a	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.147c	b0 05		bcs $1483			bcs 	_ECAType
.147e	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.1480	4c e5 13	jmp $13e5			jmp 	_ECALoop
.1483					_ECAType:
.1483	4c 31 1f	jmp $1f31		jmp	ErrorV_type
.1486					_ECAOkayString:
.1486	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.1488					_ECAGoLoop:
.1488	4c e5 13	jmp $13e5			jmp 	_ECALoop
.148b					PrecedenceTable:
>148b	03						.byte 	3 					; '+'
>148c	03						.byte 	3 					; '-'
>148d	04						.byte 	4 					; '*'
>148e	04						.byte 	4 					; '/'
>148f	05						.byte 	5 					; '^'
>1490	01						.byte 	1 					; 'and'
>1491	00						.byte 	0 					; 'or'
>1492	02						.byte 	2 					; '>'
>1493	02						.byte 	2 					; '='
>1494	02						.byte 	2 					; '<'
>1495	02						.byte 	2 					; '>='
>1496	02						.byte 	2 					; '<='
>1497	02						.byte 	2 					; '<>'
.1498					FindVariable:
.1498	86 2f		stx $2f				stx 	zTemp1 						; save name.
.149a	84 30		sty $30				sty 	zTemp1+1
.149c					_IVCheckSpecial:
.149c	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.149e	d0 18		bne $14b8			bne 	_IVStandard
.14a0	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.14a2	f0 0c		beq $14b0			beq 	_IVTIFloat
.14a4	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.14a6	d0 10		bne $14b8			bne 	_IVStandard
.14a8	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.14aa	a2 01		ldx #$01			ldx 	#$01
.14ac	a9 40		lda #$40			lda 	#NSSString
.14ae	38		sec				sec
.14af	60		rts				rts
.14b0					_IVTIFloat:
.14b0	a0 80		ldy #$80			ldy 	#$80
.14b2	a2 00		ldx #$00			ldx 	#$00
.14b4	a9 00		lda #$00			lda 	#0
.14b6	38		sec				sec
.14b7	60		rts				rts
.14b8					_IVStandard:
.14b8	ad 07 05	lda $0507			lda 	compilerStartHigh			; start scanning from here.
.14bb	85 2e		sta $2e				sta 	zTemp0+1
.14bd	64 2d		stz $2d				stz 	zTemp0
.14bf					_IVCheckLoop:
.14bf	b2 2d		lda ($2d)			lda 	(zTemp0) 					; finished ?
.14c1	f0 2b		beq $14ee			beq  	_IVNotFound 				; if so, return with CC.
.14c3	a0 01		ldy #$01			ldy 	#1 							; match ?
.14c5	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.14c7	c5 2f		cmp $2f				cmp 	zTemp1
.14c9	d0 07		bne $14d2			bne	 	_IVNext
.14cb	c8		iny				iny
.14cc	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.14ce	c5 30		cmp $30				cmp 	zTemp1+1
.14d0	f0 0d		beq $14df			beq 	_IVFound
.14d2					_IVNext:
.14d2	18		clc				clc
.14d3	a5 2d		lda $2d				lda 	zTemp0
.14d5	72 2d		adc ($2d)			adc 	(zTemp0)
.14d7	85 2d		sta $2d				sta 	zTemp0
.14d9	90 e4		bcc $14bf			bcc 	_IVCheckLoop
.14db	e6 2e		inc $2e				inc 	zTemp0+1
.14dd	80 e0		bra $14bf			bra 	_IVCheckLoop
.14df					_IVFound:
.14df	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.14e1	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.14e3	aa		tax				tax
.14e4	c8		iny				iny
.14e5	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.14e7	48		pha				pha
.14e8	c8		iny				iny
.14e9	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.14eb	7a		ply				ply
.14ec	38		sec				sec
.14ed	60		rts				rts
.14ee					_IVNotFound:
.14ee	a6 2f		ldx $2f				ldx 	zTemp1 						; get variable name back
.14f0	a4 30		ldy $30				ldy 	zTemp1+1
.14f2	18		clc				clc
.14f3	60		rts				rts
.14f4					FixBranches:
.14f4	20 46 10	jsr $1046			jsr 	APIORewind 					; back to the start of the *object* code.
.14f7					_FBLoop:
.14f7	b2 29		lda ($29)			lda 	(objPtr) 					; get the next one.
.14f9	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.14fb	f0 16		beq $1513			beq 	_FBFixGotoGosub
.14fd	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.14ff	f0 12		beq $1513			beq 	_FBFixGotoGosub
.1501	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.1503	f0 0e		beq $1513			beq 	_FBFixGotoGosub
.1505	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1507	f0 0a		beq $1513			beq 	_FBFixGotoGosub
.1509	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.150b	f0 3b		beq $1548			beq 	_FBFixVarSpace
.150d					_FBNext:
.150d	20 36 20	jsr $2036			jsr 	MoveObjectForward 			; move forward in object code.
.1510	90 e5		bcc $14f7			bcc 	_FBLoop 					; not finished
.1512					_FBExit:
.1512	60		rts				rts
.1513					_FBFixGotoGosub:
.1513	a0 01		ldy #$01			ldy 	#1							; line number in YA
.1515	b1 29		lda ($29),y			lda 	(objPtr),y
.1517	48		pha				pha
.1518	c8		iny				iny
.1519	b1 29		lda ($29),y			lda 	(objPtr),y
.151b	a8		tay				tay
.151c	68		pla				pla
.151d	20 d5 1b	jsr $1bd5			jsr 	STRFindLine			 		; find where it is X:YA
.1520	90 08		bcc $152a			bcc 	_FBFFound 					; not found, so must be >
.1522	48		pha				pha
.1523	b2 29		lda ($29)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.1525	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1527	d0 0f		bne $1538			bne 	_FBFFail
.1529	68		pla				pla
.152a					_FBFFound:
.152a	20 29 1c	jsr $1c29			jsr 	STRMakeOffset 				; make it an offset from X:YA
.152d	5a		phy				phy	 								; patch the GOTO/GOSUB
.152e	a0 01		ldy #$01			ldy 	#1
.1530	91 29		sta ($29),y			sta 	(objPtr),y
.1532	c8		iny				iny
.1533	68		pla				pla
.1534	91 29		sta ($29),y			sta 	(objPtr),y
.1536	80 d5		bra $150d			bra 	_FBNext
.1538					_FBFFail:
.1538	a0 02		ldy #$02			ldy 	#2
.153a	b1 29		lda ($29),y			lda 	(objPtr),y
.153c	8d 00 04	sta $0400			sta 	currentLineNumber
.153f	c8		iny				iny
.1540	b1 29		lda ($29),y			lda 	(objPtr),y
.1542	8d 01 04	sta $0401			sta 	currentLineNumber+1
.1545	4c 64 1f	jmp $1f64		jmp	ErrorV_line
.1548					_FBFixVarSpace:
.1548	a0 01		ldy #$01			ldy 	#1
.154a	ad 13 05	lda $0513			lda 	freeVariableMemory
.154d	91 29		sta ($29),y			sta 	(objPtr),y
.154f	c8		iny				iny
.1550	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1553	91 29		sta ($29),y			sta 	(objPtr),y
.1555	80 b6		bra $150d			bra 	_FBNext
.1557					CommandFOR:
.1557	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.155a	20 4f 1a	jsr $1a4f			jsr 	CharIsAlpha 				; if not alpha , error
.155d	90 59		bcc $15b8			bcc 	_CFFail
.155f	20 83 1d	jsr $1d83			jsr 	GetReferenceTerm 			; figure out the reference.
.1562	48		pha				pha 								; save type
.1563	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1565	c9 00		cmp #$00			cmp 	#NSSIFloat
.1567	d0 4f		bne $15b8			bne 	_CFFail
.1569	5a		phy				phy 								; save reference on the stack
.156a	da		phx				phx
.156b	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.156d	20 3c 11	jsr $113c			jsr 	CheckNextA
.1570	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; initial value
.1573	fa		plx				plx 								; get reference back.
.1574	7a		ply				ply
.1575	5a		phy				phy
.1576	da		phx				phx
.1577	38		sec				sec 								; set initial value.
.1578	20 35 1d	jsr $1d35			jsr 	GetSetVariable
.157b	fa		plx				plx
.157c	7a		ply				ply
.157d	68		pla				pla
.157e	29 20		and #$20			and 	#NSSIInt16
.1580	f0 04		beq $1586			beq 	_CFNotInt16
.1582	98		tya				tya
.1583	09 80		ora #$80			ora 	#$80
.1585	a8		tay				tay
.1586					_CFNotInt16:
.1586	8a		txa				txa 								; reference in YA
.1587	20 d8 11	jsr $11d8			jsr 	PushIntegerYA
.158a	a9 a4		lda #$a4			lda 	#C64_TO
.158c	20 3c 11	jsr $113c			jsr 	CheckNextA
.158f	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; terminal value
.1592	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1594	c9 00		cmp #$00			cmp 	#NSSIFloat
.1596	d0 20		bne $15b8			bne 	_CFFail
.1598	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; followed by STEP
.159b	c9 a9		cmp #$a9			cmp 	#C64_STEP
.159d	d0 0e		bne $15ad			bne 	_CFNoStep
.159f	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume it.
.15a2	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; terminal value
.15a5	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15a7	c9 00		cmp #$00			cmp 	#NSSIFloat
.15a9	d0 0d		bne $15b8			bne 	_CFFail
.15ab	80 05		bra $15b2			bra 	_CFParametersDone
.15ad					_CFNoStep:
.15ad	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.15af	20 eb 11	jsr $11eb			jsr 	PushIntegerA
.15b2					_CFParametersDone:
.15b2	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.15b4	20 da 10	jsr $10da			jsr 	WriteCodeByte
.15b7	60		rts				rts
.15b8					_CFFail:
.15b8	4c 21 1f	jmp $1f21		jmp	ErrorV_syntax
.15bb					FNCompile:
.15bb	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.15be	20 9e 1a	jsr $1a9e			jsr 	ExtractVariableName
.15c1	e0 00		cpx #$00			cpx 	#0
.15c3	10 32		bpl $15f7			bpl 	_FNError
.15c5	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.15c6	29 7f		and #$7f			and 	#$7F
.15c8	aa		tax				tax
.15c9	98		tya				tya
.15ca	09 80		ora #$80			ora 	#$80
.15cc	a8		tay				tay
.15cd	20 98 14	jsr $1498			jsr 	FindVariable				; does it already exist ?
.15d0	90 25		bcc $15f7			bcc 	_FNError 					; no.
.15d2	20 29 1c	jsr $1c29			jsr 	STRMakeOffset 				; convert to a relative address.
.15d5	c9 00		cmp #$00			cmp 	#0 							; fix up.
.15d7	d0 01		bne $15da			bne 	_FNNoBorrow
.15d9	88		dey				dey
.15da					_FNNoBorrow:
.15da	3a		dec a				dec 	a
.15db	5a		phy				phy 								; save location of routine on stack.
.15dc	48		pha				pha
.15dd	da		phx				phx
.15de	20 de 13	jsr $13de			jsr 	CompileExpressionAt0
.15e1	20 36 11	jsr $1136			jsr 	CheckNextRParen
.15e4	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.15e6	20 da 10	jsr $10da			jsr 	WriteCodeByte
.15e9	68		pla				pla
.15ea	20 da 10	jsr $10da			jsr 	WriteCodeByte
.15ed	68		pla				pla
.15ee	20 da 10	jsr $10da			jsr 	WriteCodeByte
.15f1	68		pla				pla
.15f2	20 da 10	jsr $10da			jsr 	WriteCodeByte
.15f5	18		clc				clc
.15f6	60		rts				rts
.15f7					_FNError:
.15f7	4c 14 1f	jmp $1f14		jmp	ErrorV_value
.15fa					CommandTables:
>15fa	07 cb 00 03 fc 1a 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>1601	07 89 00 03 03 1b 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>1608	07 8d 00 03 f6 1a 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>160f	07 88 00 03 72 1b 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>1616	07 85 00 03 52 1b 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>161d	07 84 00 04 66 1b 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>1624	07 99 00 03 b0 1c 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>162b	07 98 00 04 b0 1c 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1632	07 8f 00 03 bb 1d 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>1639	07 81 00 03 57 15 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>1640	07 82 00 03 33 1c 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>1647	07 a1 00 03 6f 1a 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>164e	07 83 00 03 93 12 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>1655	07 87 00 03 f9 1c 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>165c	07 86 00 03 26 13 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>1663	07 96 00 03 af 12 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>166a	07 8b 00 e3 1f 1b 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>1671	08 92 00 ea e3 87 1e 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>1679	09 91 00 e1 a9 03 5f 1c			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>1681	06
>1682	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>1689	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>1690	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>1696	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>169d	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>16a4	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>16ab	07 9d 00 e3 ad 1e 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>16b2	0a 9f 00 ea e3 c0 1e 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>16ba	c6 06
>16bc	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>16c2	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>16c9	0a ce 92 e3 ec 19 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>16d1	ad 06
>16d3	0a ce 8d e3 ec 19 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>16db	ae 06
>16dd	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>16e3	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>16eb	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>16f2	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>16f9	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>1701	06
>1702	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>170a	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>1712	9a 06
>1714	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>171c	9b 06
>171e	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>1726	9c 06
>1728	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>1730	06
>1731	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>1738	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>1740	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>1748	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>1750	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>1758	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>1760	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>1768	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>1770	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>1778	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>1780	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>1788	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>178f	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>1797	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>179f	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>17a7	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>17af	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>17b7	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>17bf	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>17c7	00						.byte 	0
.17c8					UnaryTables:
>17c8	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>17cf	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>17d7	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>17de	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>17e5	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>17ec	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>17f3	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>17fb	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>1802	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>180a	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>1812	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>181a	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>1822	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>182a	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>1832	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>1839	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>1840	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>1847	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>184e	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>1855	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>185c	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>1864	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>186c	0b ca 00 8f ae 03 ec 19			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>1874	91 bd 07
>1877	07 a8 00 03 0b 1a 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>187e	07 a5 00 03 bb 15 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>1885	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>188c	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>1893	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>189b	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>18a3	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>18aa	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>18b1	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>18b8	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>18c0	06
>18c1	00						.byte 	0
.18c2					GeneratorProcess:
.18c2	86 2d		stx $2d				stx 	zTemp0 						; save generation pointer in zTemp0
.18c4	84 2e		sty $2e				sty 	zTemp0+1
.18c6	85 2f		sta $2f				sta 	zTemp1 						; first match token
.18c8	64 30		stz $30				stz 	zTemp1+1
.18ca	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.18cc	d0 05		bne $18d3			bne 	_GPNotShifted
.18ce	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; get the shifted token
.18d1	85 30		sta $30				sta 	zTemp1+1 					; match CE xx
.18d3					_GPNotShifted:
.18d3					_GPSearch:
.18d3	b2 2d		lda ($2d)			lda 	(zTemp0) 					; reached end ?
.18d5	18		clc				clc
.18d6	f0 2f		beq $1907			beq 	_GPExit
.18d8	a0 01		ldy #$01			ldy 	#1 							; tokens match
.18da	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.18dc	c5 2f		cmp $2f				cmp 	zTemp1
.18de	d0 09		bne $18e9			bne 	_GPNext
.18e0	a5 30		lda $30				lda 	zTemp1+1 					; 2nd token ?
.18e2	f0 12		beq $18f6			beq 	_GPFound
.18e4	c8		iny				iny 								; check match.
.18e5	d1 2d		cmp ($2d),y			cmp 	(zTemp0),y
.18e7	f0 0d		beq $18f6			beq 	_GPFound
.18e9					_GPNext:
.18e9	18		clc				clc 								; follow to next
.18ea	a5 2d		lda $2d				lda 	zTemp0
.18ec	72 2d		adc ($2d)			adc 	(zTemp0)
.18ee	85 2d		sta $2d				sta 	zTemp0
.18f0	90 e1		bcc $18d3			bcc 	_GPSearch
.18f2	e6 2e		inc $2e				inc 	zTemp0+1
.18f4	80 dd		bra $18d3			bra 	_GPSearch
.18f6					_GPFound:
.18f6	18		clc				clc 								; skip to action bytes
.18f7	a5 2d		lda $2d				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.18f9	69 03		adc #$03			adc 	#3
.18fb	85 2d		sta $2d				sta 	zTemp0
.18fd	90 02		bcc $1901			bcc 	_GPNoCarry
.18ff	e6 2e		inc $2e				inc 	zTemp0+1
.1901					_GPNoCarry:
.1901					_GPLoop:
.1901	20 08 19	jsr $1908			jsr 	GeneratorExecute 			; execute one command
.1904	90 fb		bcc $1901			bcc 	_GPLoop 					; go back if not completed.
.1906	38		sec				sec 								; return with CS.
.1907					_GPExit:
.1907	60		rts				rts
.1908					GeneratorExecute:
.1908	20 b3 19	jsr $19b3			jsr 	_GEFetchZTemp0 				; get next.
.190b	48		pha				pha 								; split into 2 nibbles
.190c	4a		lsr a				lsr 	a
.190d	4a		lsr a				lsr 	a
.190e	4a		lsr a				lsr		a
.190f	4a		lsr a				lsr 	a
.1910	20 1a 19	jsr $191a			jsr 	_GEExecuteNibble 			; MSB first
.1913	68		pla				pla
.1914	b0 03		bcs $1919			bcs 	_GEHaveCompleted
.1916	20 1a 19	jsr $191a			jsr 	_GEExecuteNibble 			; LSB second
.1919					_GEHaveCompleted:
.1919	60		rts				rts
.191a					_GEExecuteNibble:
.191a	29 0f		and #$0f			and 	#$0F
.191c	0a		asl a				asl 	a
.191d	aa		tax				tax
.191e	7c 21 19	jmp ($1921,x)			jmp 	(_GEExecuteVectors,x)
.1921					_GEExecuteVectors:
>1921	41 19						.word 	_GEXNop 					; 0  (no operation)
>1923	49 19						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>1925	43 19						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>1927	96 19						.word 	_GEXExecute 				; 3  (run arbitrary code)
>1929	89 19						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>192b	41 19						.word 	_GEXNop 					; 5
>192d	50 19						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>192f	54 19						.word 	_GEXExitString 				; 7  exit return string type
>1931	58 19						.word 	_GEXLParam 					; 8  check ( follows
>1933	5c 19						.word 	_GEXRParam 					; 9  check ) follows
>1935	60 19						.word 	_GEXComma					; A  check , follows
>1937	41 19						.word 	_GEXNop 					; B
>1939	41 19						.word 	_GEXNop 					; C
>193b	41 19						.word 	_GEXNop 					; D
>193d	70 19						.word 	_GEXNumber 					; E  compile get any number
>193f	7b 19						.word 	_GEXString 					; F  compile get any string
.1941					_GEXNop:
.1941	18		clc				clc
.1942	60		rts				rts
.1943					_GEXToken2:
.1943	20 b3 19	jsr $19b3			jsr 	_GEFetchZTemp0
.1946	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1949					_GEXToken1:
.1949	20 b3 19	jsr $19b3			jsr 	_GEFetchZTemp0
.194c	20 da 10	jsr $10da			jsr 	WriteCodeByte
.194f	60		rts				rts
.1950					_GEXExitNumber:
.1950	a9 00		lda #$00			lda 	#NSSIFloat
.1952	38		sec				sec
.1953	60		rts				rts
.1954					_GEXExitString:
.1954	a9 40		lda #$40			lda 	#NSSString
.1956	38		sec				sec
.1957	60		rts				rts
.1958					_GEXLParam:
.1958	a9 28		lda #$28			lda 	#"("
.195a	80 06		bra $1962			bra 	_GEXCheck
.195c					_GEXRParam:
.195c	a9 29		lda #$29			lda 	#")"
.195e	80 02		bra $1962			bra 	_GEXCheck
.1960					_GEXComma:
.1960	a9 2c		lda #$2c			lda 	#","
.1962					_GEXCheck:
.1962	85 31		sta $31				sta 	zTemp2 						; save match
.1964	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; get next skipping spaces
.1967	c5 31		cmp $31				cmp 	zTemp2 						; check matches.
.1969	d0 02		bne $196d			bne 	_GEXSyntax
.196b	18		clc				clc
.196c	60		rts				rts
.196d					_GEXSyntax:
.196d	4c 21 1f	jmp $1f21		jmp	ErrorV_syntax
.1970					_GEXNumber:
.1970	20 bc 19	jsr $19bc			jsr 	GEXCompileExpression 		; compile expression
.1973	29 40		and #$40			and 	#NSSTypeMask
.1975	c9 00		cmp #$00			cmp  	#NSSIFloat
.1977	d0 0d		bne $1986			bne 	_GEXType
.1979	18		clc				clc
.197a	60		rts				rts
.197b					_GEXString:
.197b	20 bc 19	jsr $19bc			jsr 	GEXCompileExpression 		; compile expression
.197e	29 40		and #$40			and 	#NSSTypeMask
.1980	c9 40		cmp #$40			cmp  	#NSSString
.1982	d0 02		bne $1986			bne 	_GEXType
.1984	18		clc				clc
.1985	60		rts				rts
.1986					_GEXType:
.1986	4c 31 1f	jmp $1f31		jmp	ErrorV_type
.1989					_GEXChannelExec:
.1989	20 cc 19	jsr $19cc			jsr 	ChannelPrefix 				; set up default
.198c	20 96 19	jsr $1996			jsr 	_GEXExecute
.198f	08		php				php
.1990	20 e6 19	jsr $19e6			jsr 	ChannelPostfix 				; replace default.
.1993	28		plp				plp
.1994	60		rts				rts
>1995	db						.byte 	$DB 						; causes a break in the emulator
.1996					_GEXExecute:
.1996	20 b3 19	jsr $19b3			jsr 	_GEFetchZTemp0 				; get vector
.1999	85 31		sta $31				sta 	zTemp2
.199b	20 b3 19	jsr $19b3			jsr 	_GEFetchZTemp0
.199e	85 32		sta $32				sta 	zTemp2+1
.19a0	a6 2d		ldx $2d				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19a2	da		phx				phx
.19a3	a6 2e		ldx $2e				ldx 	zTemp0+1
.19a5	da		phx				phx
.19a6	20 b0 19	jsr $19b0			jsr 	_GECallZTemp2 				; execute code
.19a9	fa		plx				plx 								; recover generation exec
.19aa	86 2e		stx $2e				stx 	zTemp0+1
.19ac	fa		plx				plx
.19ad	86 2d		stx $2d				stx 	zTemp0
.19af	60		rts				rts
.19b0					_GECallZTemp2:
.19b0	6c 31 00	jmp ($0031)			jmp 	(zTemp2)
.19b3					_GEFetchZTemp0:
.19b3	b2 2d		lda ($2d)			lda 	(zTemp0)
.19b5	e6 2d		inc $2d				inc 	zTemp0
.19b7	d0 02		bne $19bb			bne 	_GEFZ0Skip
.19b9	e6 2e		inc $2e				inc 	zTemp0+1
.19bb					_GEFZ0Skip:
.19bb	60		rts				rts
.19bc					GEXCompileExpression:
.19bc	a6 2d		ldx $2d				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19be	da		phx				phx
.19bf	a6 2e		ldx $2e				ldx 	zTemp0+1
.19c1	da		phx				phx
.19c2	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; compile expression.
.19c5	fa		plx				plx 								; recover generation exec
.19c6	86 2e		stx $2e				stx 	zTemp0+1
.19c8	fa		plx				plx
.19c9	86 2d		stx $2d				stx 	zTemp0
.19cb	60		rts				rts
.19cc					ChannelPrefix:
.19cc	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.19ce	20 da 10	jsr $10da			jsr 	WriteCodeByte
.19d1	20 bc 19	jsr $19bc			jsr 	GEXCompileExpression 		; channel #
.19d4	29 40		and #$40			and 	#NSSTypeMask
.19d6	c9 00		cmp #$00			cmp 	#NSSIFloat
.19d8	d0 09		bne $19e3			bne 	_CPXType
.19da	20 32 11	jsr $1132			jsr 	CheckNextComma 				; check , follows.
.19dd	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.19df	20 da 10	jsr $10da			jsr 	WriteCodeByte
.19e2	60		rts				rts
.19e3					_CPXType:
.19e3	4c 31 1f	jmp $1f31		jmp	ErrorV_type
.19e6					ChannelPostfix:
.19e6	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.19e8	20 da 10	jsr $10da			jsr 	WriteCodeByte
.19eb	60		rts				rts
.19ec					OptionalParameterCompile:
.19ec	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; what follows.
.19ef	c9 2c		cmp #$2c			cmp 	#","
.19f1	d0 0e		bne $1a01			bne 	_MidDefault
.19f3	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume ,
.19f6	20 de 13	jsr $13de			jsr 	CompileExpressionAt0
.19f9	29 40		and #$40			and 	#NSSTypeMask
.19fb	c9 00		cmp #$00			cmp 	#NSSIFloat
.19fd	d0 09		bne $1a08			bne 	MidFailType
.19ff	80 05		bra $1a06			bra 	_MidComplete
.1a01					_MidDefault:
.1a01	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1a03	20 eb 11	jsr $11eb			jsr 	PushIntegerA
.1a06					_MidComplete:
.1a06	18		clc				clc
.1a07	60		rts				rts
.1a08					MidFailType:
.1a08	4c 31 1f	jmp $1f31		jmp	ErrorV_type
.1a0b					NotUnaryCompile:
.1a0b	ad 93 14	lda $1493			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1a0e	20 e0 13	jsr $13e0			jsr 	CompileExpressionAtA 		; evaluate at that level
.1a11	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1a13	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a15	d0 f1		bne $1a08			bne 	MidFailType
.1a17	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1a19	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1a1c	60		rts				rts
.1a1d					LookNext:
.1a1d	b2 24		lda ($24)			lda 	(srcPtr)
.1a1f	60		rts				rts
.1a20					LookNextNonSpace:
.1a20	b2 24		lda ($24)			lda 	(srcPtr)
.1a22	c9 20		cmp #$20			cmp		#' '
.1a24	f0 03		beq $1a29			beq 	_LNNSkip
.1a26	c9 00		cmp #$00			cmp 	#0
.1a28	60		rts				rts
.1a29					_LNNSkip:
.1a29	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1a2c	80 f2		bra $1a20			bra 	LookNextNonSpace
.1a2e					GetNext:
.1a2e	b2 24		lda ($24)			lda 	(srcPtr) 					; get next
.1a30	e6 24		inc $24				inc 	srcPtr
.1a32	d0 02		bne $1a36			bne 	_GNSkip
.1a34	e6 25		inc $25				inc 	srcPtr+1
.1a36					_GNSkip:
.1a36	c9 00		cmp #$00			cmp 	#0
.1a38	60		rts				rts
.1a39					GetNextNonSpace:
.1a39	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1a3c	c9 20		cmp #$20			cmp 	#' '
.1a3e	f0 f9		beq $1a39			beq 	GetNextNonSpace
.1a40	c9 00		cmp #$00			cmp 	#0
.1a42	60		rts				rts
.1a43					CharIsDigit:
.1a43	c9 30		cmp #$30			cmp 	#"0"
.1a45	90 06		bcc $1a4d			bcc 	CCFalse
.1a47	c9 3a		cmp #$3a			cmp 	#"9"+1
.1a49	b0 02		bcs $1a4d			bcs 	CCFalse
.1a4b					CCTrue:
.1a4b	38		sec				sec
.1a4c	60		rts				rts
.1a4d					CCFalse:
.1a4d	18		clc				clc
.1a4e	60		rts				rts
.1a4f					CharIsAlpha:
.1a4f	c9 41		cmp #$41			cmp 	#"A"
.1a51	90 fa		bcc $1a4d			bcc 	CCFalse
.1a53	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1a55	b0 f6		bcs $1a4d			bcs 	CCFalse
.1a57	80 f2		bra $1a4b			bra 	CCTrue
.1a59					ConvertHexStyle:
.1a59	38		sec				sec
.1a5a	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1a5c	90 ef		bcc $1a4d			bcc 	CCFalse
.1a5e	c9 0a		cmp #$0a			cmp 	#9+1
.1a60	90 e9		bcc $1a4b			bcc 	CCTrue
.1a62	38		sec				sec 								; shift into hex space A=>0 Z=>25
.1a63	e9 11		sbc #$11			sbc 	#"A"-"0"
.1a65	90 e6		bcc $1a4d			bcc 	CCFalse
.1a67	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.1a69	b0 e2		bcs $1a4d			bcs 	CCFalse
.1a6b	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.1a6d	80 dc		bra $1a4b			bra 	CCTrue
.1a6f					CommandGET:
.1a6f	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; # follows ?
.1a72	c9 23		cmp #$23			cmp 	#"#"
.1a74	d0 0d		bne $1a83			bne 	CommandGetBody
.1a76	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume #
.1a79	20 cc 19	jsr $19cc			jsr 	ChannelPrefix 				; do it as GET#
.1a7c	20 83 1a	jsr $1a83			jsr 	CommandGetBody
.1a7f	20 e6 19	jsr $19e6			jsr 	ChannelPostfix
.1a82	60		rts				rts
.1a83					CommandGetBody:
.1a83	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; get the first character
.1a86	20 83 1d	jsr $1d83			jsr 	GetReferenceTerm 			; identify variable to assign to
.1a89	48		pha				pha
.1a8a	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1a8c	c9 40		cmp #$40			cmp 	#NSSString
.1a8e	d0 0b		bne $1a9b			bne 	_CGType
.1a90	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1a92	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1a95	38		sec				sec
.1a96	68		pla				pla
.1a97	20 35 1d	jsr $1d35			jsr		GetSetVariable
.1a9a	60		rts				rts
.1a9b					_CGType:
.1a9b	4c 31 1f	jmp $1f31		jmp	ErrorV_type
.1a9e					ExtractVariableName:
.1a9e	20 4f 1a	jsr $1a4f			jsr 	CharIsAlpha
.1aa1	90 50		bcc $1af3			bcc 	_IVSyntax
.1aa3	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.1aa5	85 2f		sta $2f				sta 	zTemp1 						; we'll build it in zTemp1
.1aa7	64 30		stz $30				stz 	zTemp1+1
.1aa9	20 1d 1a	jsr $1a1d			jsr 	LookNext 					; is there a second character ?
.1aac	20 4f 1a	jsr $1a4f			jsr 	CharIsAlpha  				; must be alphanumeric
.1aaf	b0 05		bcs $1ab6			bcs 	_IVHasSecond
.1ab1	20 43 1a	jsr $1a43			jsr 	CharIsDigit
.1ab4	90 07		bcc $1abd			bcc 	_IVCheckType
.1ab6					_IVHasSecond:
.1ab6	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.1ab8	85 30		sta $30				sta 	zTemp1+1
.1aba					_IVGetNextCheck:
.1aba	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume it
.1abd					_IVCheckType:
.1abd	20 1d 1a	jsr $1a1d			jsr 	LookNext					; check if string follows.
.1ac0	20 4f 1a	jsr $1a4f			jsr 	CharIsAlpha
.1ac3	b0 f5		bcs $1aba			bcs 	_IVGetNextCheck
.1ac5	20 43 1a	jsr $1a43			jsr 	CharIsDigit
.1ac8	b0 f0		bcs $1aba			bcs 	_IVGetNextCheck
.1aca	a2 40		ldx #$40			ldx 	#NSSString
.1acc	c9 24		cmp #$24			cmp 	#"$"
.1ace	f0 06		beq $1ad6			beq 	_IVHasType
.1ad0	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.1ad2	c9 25		cmp #$25			cmp 	#"%"
.1ad4	d0 08		bne $1ade			bne 	_IVCheckArray
.1ad6					_IVHasType:
.1ad6	8a		txa				txa 								; Or X into zTemp1
.1ad7	05 2f		ora $2f				ora 	zTemp1
.1ad9	85 2f		sta $2f				sta 	zTemp1
.1adb	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume it
.1ade					_IVCheckArray:
.1ade	20 1d 1a	jsr $1a1d			jsr 	LookNext 					; check if array follows
.1ae1	c9 28		cmp #$28			cmp 	#"("
.1ae3	d0 09		bne $1aee			bne 	_IVNotArray
.1ae5	a5 2f		lda $2f				lda 	zTemp1 						; set array bit
.1ae7	09 80		ora #$80			ora 	#NSSArray
.1ae9	85 2f		sta $2f				sta 	zTemp1
.1aeb	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume it
.1aee					_IVNotArray:
.1aee	a6 2f		ldx $2f				ldx 	zTemp1
.1af0	a4 30		ldy $30				ldy 	zTemp1+1
.1af2	60		rts				rts
.1af3					_IVSyntax:
.1af3	4c 21 1f	jmp $1f21		jmp	ErrorV_syntax
.1af6					CommandGOSUB:
.1af6	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1af8	20 09 1b	jsr $1b09			jsr 	CompileBranchCommand
.1afb	60		rts				rts
.1afc					CommandGOAlt:
.1afc	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1afe	20 3c 11	jsr $113c			jsr 	CheckNextA
.1b01	80 00		bra $1b03			bra 	CommandGOTO
.1b03					CommandGOTO:
.1b03	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1b05	20 09 1b	jsr $1b09			jsr 	CompileBranchCommand
.1b08	60		rts				rts
.1b09					CompileBranchCommand:
.1b09	20 da 10	jsr $10da			jsr 	WriteCodeByte 				; write the command out.
.1b0c	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace
.1b0f	20 8b 1c	jsr $1c8b			jsr 	ParseConstant 				; get constant into YA
.1b12	90 08		bcc $1b1c			bcc 	_CBCSyntax
.1b14	20 da 10	jsr $10da			jsr 	WriteCodeByte				; and compile the actual line number
.1b17	98		tya				tya
.1b18	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b1b	60		rts				rts
.1b1c					_CBCSyntax:
.1b1c	4c 21 1f	jmp $1f21		jmp	ErrorV_syntax
.1b1f					CommandIF:
.1b1f	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; what follows the tests ?
.1b22	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1b24	f0 0f		beq $1b35			beq 	_CIGoto
.1b26	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1b28	20 3c 11	jsr $113c			jsr 	CheckNextA
.1b2b	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; THEN <number>
.1b2e	20 43 1a	jsr $1a43			jsr 	CharIsDigit
.1b31	b0 05		bcs $1b38			bcs 	_CIGoto2
.1b33	80 09		bra $1b3e			bra 	CompileGotoEOL
.1b35					_CIGoto:
.1b35	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1b38					_CIGoto2:
.1b38	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1b3a	20 09 1b	jsr $1b09			jsr 	CompileBranchCommand
.1b3d	60		rts				rts
.1b3e					CompileGotoEOL:
.1b3e	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.1b40	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b43	20 d3 10	jsr $10d3			jsr 	GetLineNumber 				; Get the current line number => YA
.1b46	1a		inc a				inc 	a 							; and branch to +1
.1b47	d0 01		bne $1b4a			bne 	_CGENoCarry
.1b49	c8		iny				iny
.1b4a					_CGENoCarry:
.1b4a	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b4d	98		tya				tya
.1b4e	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b51	60		rts				rts
.1b52					CommandINPUT:
.1b52	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; check for "
.1b55	c9 22		cmp #$22			cmp 	#'"'
.1b57	d0 0d		bne $1b66			bne 	CommandINPUTStream
.1b59	20 de 13	jsr $13de			jsr 	CompileExpressionAt0
.1b5c	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1b5e	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b61	a9 2c		lda #$2c			lda 	#","
.1b63	20 32 11	jsr $1132			jsr 	CheckNextComma
.1b66					CommandINPUTStream:
.1b66	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1b68	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b6b	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.1b6d	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1b6f	4c fd 1c	jmp $1cfd			jmp 	CommandReadInputCommon
.1b72					CommandLET:
.1b72	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; get the first character
.1b75					CommandLETHaveFirst:
.1b75	20 83 1d	jsr $1d83			jsr 	GetReferenceTerm 			; identify variable to assign to
.1b78	da		phx				phx 								; save target on the stack.
.1b79	5a		phy				phy
.1b7a	48		pha				pha
.1b7b	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.1b7d	20 3c 11	jsr $113c			jsr 	CheckNextA
.1b80	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1b83	85 2d		sta $2d				sta 	zTemp0 						; save type returned
.1b85	68		pla				pla 								; get type of assignment
.1b86	48		pha				pha
.1b87	45 2d		eor $2d				eor 	zTemp0 						; compare using EOR
.1b89	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.1b8b	d0 17		bne $1ba4			bne 	_CLType
.1b8d	68		pla				pla 								; restore and compile save code
.1b8e	7a		ply				ply
.1b8f	fa		plx				plx
.1b90	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.1b92	f0 05		beq $1b99			beq 	_CLTIString
.1b94	38		sec				sec
.1b95	20 35 1d	jsr $1d35			jsr		GetSetVariable
.1b98	60		rts				rts
.1b99					_CLTIString:
.1b99	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.1b9b	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b9e	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.1ba0	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1ba3	60		rts				rts
.1ba4					_CLType:
.1ba4	4c 31 1f	jmp $1f31		jmp	ErrorV_type
.1ba7					STRMarkLine:
.1ba7	48		pha				pha
.1ba8	38		sec				sec 								; allocate 5 bytes (line #, page+address)
.1ba9	ad 0f 05	lda $050f			lda 	lineNumberTable 			; and copy to zTemp0
.1bac	e9 05		sbc #$05			sbc 	#5
.1bae	8d 0f 05	sta $050f			sta 	lineNumberTable
.1bb1	85 2d		sta $2d				sta 	zTemp0
.1bb3	ad 10 05	lda $0510			lda 	lineNumberTable+1
.1bb6	e9 00		sbc #$00			sbc 	#0
.1bb8	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1bbb	85 2e		sta $2e				sta 	zTemp0+1
.1bbd	68		pla				pla
.1bbe	92 2d		sta ($2d)			sta 	(zTemp0) 					; save it in +0,+1
.1bc0	98		tya				tya
.1bc1	a0 01		ldy #$01			ldy 	#1
.1bc3	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1bc5	a5 2b		lda $2b				lda 	objPage 					; and page# in +2
.1bc7	c8		iny				iny
.1bc8	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1bca	a5 29		lda $29				lda 	objPtr 						; save current address in +3,+4
.1bcc	c8		iny				iny
.1bcd	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1bcf	a5 2a		lda $2a				lda 	objPtr+1
.1bd1	c8		iny				iny
.1bd2	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1bd4	60		rts				rts
.1bd5					STRFindLine:
.1bd5	85 2d		sta $2d				sta 	zTemp0 						; zTemp0 line number being searched
.1bd7	84 2e		sty $2e				sty 	zTemp0+1
.1bd9	ad 08 05	lda $0508			lda 	compilerEndHigh 			; work backwards through table
.1bdc	85 30		sta $30				sta 	zTemp1+1
.1bde	64 2f		stz $2f				stz 	zTemp1
.1be0					_STRSearch:
.1be0	20 1b 1c	jsr $1c1b			jsr 	_STRPrevLine 				; look at previous record.
.1be3	a0 01		ldy #$01			ldy 	#1
.1be5	b2 2f		lda ($2f)			lda 	(zTemp1) 					; check table line # >= target
.1be7	c5 2d		cmp $2d				cmp 	zTemp0
.1be9	b1 2f		lda ($2f),y			lda 	(zTemp1),y
.1beb	e5 2e		sbc $2e				sbc 	zTemp0+1
.1bed	b0 0b		bcs $1bfa			bcs 	_STRFound 					; >=
.1bef					_STRNext:
.1bef	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1bf1	b1 2f		lda ($2f),y			lda 	(zTemp1),y
.1bf3	c9 ff		cmp #$ff			cmp 	#$FF
.1bf5	d0 e9		bne $1be0			bne 	_STRSearch
.1bf7	4c 7b 1f	jmp $1f7b		jmp	ErrorV_internal
.1bfa					_STRFound:
.1bfa	b2 2f		lda ($2f)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1bfc	45 2d		eor $2d				eor 	zTemp0
.1bfe	d0 06		bne $1c06			bne 	_STRDifferent
.1c00	b2 2f		lda ($2f)			lda 	(zTemp1)
.1c02	45 2d		eor $2d				eor 	zTemp0
.1c04	f0 02		beq $1c08			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1c06					_STRDifferent:
.1c06	a9 ff		lda #$ff			lda 	#$FF
.1c08					_STROut:
.1c08	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1c09	69 ff		adc #$ff			adc 	#255
.1c0b	08		php				php
.1c0c	c8		iny				iny 								; page into X
.1c0d	b1 2f		lda ($2f),y			lda 	(zTemp1),y
.1c0f	aa		tax				tax
.1c10	c8		iny				iny 								; address into YA
.1c11	b1 2f		lda ($2f),y			lda 	(zTemp1),y
.1c13	48		pha				pha
.1c14	c8		iny				iny
.1c15	b1 2f		lda ($2f),y			lda 	(zTemp1),y
.1c17	a8		tay				tay
.1c18	68		pla				pla
.1c19	28		plp				plp
.1c1a	60		rts				rts
.1c1b					_STRPrevLine:
.1c1b	38		sec				sec 								; move backwards one entry.
.1c1c	a5 2f		lda $2f				lda 	zTemp1
.1c1e	e9 05		sbc #$05			sbc 	#5
.1c20	85 2f		sta $2f				sta 	zTemp1
.1c22	a5 30		lda $30				lda 	zTemp1+1
.1c24	e9 00		sbc #$00			sbc 	#0
.1c26	85 30		sta $30				sta 	zTemp1+1
.1c28	60		rts				rts
.1c29					STRMakeOffset:
.1c29	18		clc				clc 								; borrow 1
.1c2a	e5 29		sbc $29				sbc 	objPtr
.1c2c	48		pha				pha
.1c2d	98		tya				tya
.1c2e	e5 2a		sbc $2a				sbc 	objPtr+1
.1c30	a8		tay				tay
.1c31	68		pla				pla
.1c32	60		rts				rts
.1c33					CommandNEXT:
.1c33	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1c36	20 4f 1a	jsr $1a4f			jsr 	CharIsAlpha 				; if not alpha , error
.1c39	90 0c		bcc $1c47			bcc 	_CNNoReferenceGiven
.1c3b	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1c3e	20 83 1d	jsr $1d83			jsr 	GetReferenceTerm 			; figure out the reference.
.1c41	8a		txa				txa 								; reference in YA
.1c42	20 d8 11	jsr $11d8			jsr 	PushIntegerYA 				; write it out.
.1c45	80 06		bra $1c4d			bra 	_CNParametersDone
.1c47					_CNNoReferenceGiven:
.1c47	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1c49	a8		tay				tay
.1c4a	20 d8 11	jsr $11d8			jsr 	PushIntegerYA 				; write it out.
.1c4d					_CNParametersDone:
.1c4d	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1c4f	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1c52	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; look for ,
.1c55	c9 2c		cmp #$2c			cmp 	#","
.1c57	d0 05		bne $1c5e			bne 	_CNExit
.1c59	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume ,
.1c5c	80 d5		bra $1c33			bra 	CommandNEXT 				; and go round.
.1c5e					_CNExit:
.1c5e	60		rts				rts
.1c5f					CommandON:
.1c5f	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1c62	48		pha				pha 								; save on stack
.1c63	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1c65	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1c67	f0 09		beq $1c72			beq 	_COCreateLoop
.1c69	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1c6b	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1c6d	f0 03		beq $1c72			beq 	_COCreateLoop
.1c6f	4c 21 1f	jmp $1f21		jmp	ErrorV_syntax
.1c72					_COCreateLoop:
.1c72	8a		txa				txa 								; compile a goto/gosub somewhere
.1c73	da		phx				phx
.1c74	20 09 1b	jsr $1b09			jsr 	CompileBranchCommand
.1c77	fa		plx				plx
.1c78	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace			; ',' follows
.1c7b	c9 2c		cmp #$2c			cmp 	#","
.1c7d	d0 0a		bne $1c89			bne 	_COComplete 				; if so, more line numbers
.1c7f	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1c81	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1c84	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1c87	80 e9		bra $1c72			bra 	_COCreateLoop
.1c89					_COComplete:
.1c89	68		pla				pla 								; throw GOTO/GOSUB
.1c8a	60		rts				rts
.1c8b					ParseConstant:
.1c8b	a2 00		ldx #$00			ldx 	#0
.1c8d	20 47 24	jsr $2447			jsr 	FloatEncodeStart 			; send first
.1c90					_ParseLoop:
.1c90	20 1d 1a	jsr $1a1d			jsr 	LookNext 					; send subsequent
.1c93	20 4a 24	jsr $244a			jsr 	FloatEncodeContinue
.1c96	90 05		bcc $1c9d			bcc 	_ParseDone
.1c98	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume it
.1c9b	80 f3		bra $1c90			bra 	_ParseLoop
.1c9d					_ParseDone:
.1c9d	b5 33		lda $33,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1c9f	29 80		and #$80			and 	#$80
.1ca1	15 6f		ora $6f,x			ora 	NSExponent,x 				; 16 bit int check
.1ca3	15 57		ora $57,x			ora 	NSMantissa2,x
.1ca5	15 63		ora $63,x			ora 	NSMantissa3,x
.1ca7	18		clc				clc
.1ca8	d0 05		bne $1caf			bne 	_ParseExit 					; exit with CC if need float to compile
.1caa	b5 3f		lda $3f,x			lda 	NSMantissa0,x 				; read into YA.
.1cac	b4 4b		ldy $4b,x			ldy		NSMantissa1,x
.1cae	38		sec				sec
.1caf					_ParseExit:
.1caf	60		rts				rts
.1cb0					CommandPRINT:
.1cb0	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace			; what follows ?
.1cb3	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1cb5	f0 1f		beq $1cd6			beq 	_CPCheckEnd
.1cb7	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1cb9	f0 16		beq $1cd1			beq 	_CPTabCheckEnd
.1cbb	20 ed 1c	jsr $1ced			jsr 	_CPAtEnd 					; check for : and EOL
.1cbe	b0 22		bcs $1ce2			bcs 	_CPExitCR 					; exit with CR
.1cc0	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; so it is something to print
.1cc3	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1cc5	29 40		and #$40			and 	#NSSString 					; if string
.1cc7	d0 02		bne $1ccb			bne 	_CPOut
.1cc9	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1ccb					_CPOut:
.1ccb	8a		txa				txa 								; print that thing
.1ccc	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1ccf	80 df		bra $1cb0			bra 	CommandPRINT 				; and loop round/
.1cd1					_CPTabCheckEnd:
.1cd1	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1cd3	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1cd6					_CPCheckEnd:
.1cd6	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume it.
.1cd9	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; what follows ?
.1cdc	20 ed 1c	jsr $1ced			jsr 	_CPAtEnd 					; reached end
.1cdf	90 cf		bcc $1cb0			bcc 	CommandPRINT 				; no, loop back
.1ce1	60		rts				rts
.1ce2					_CPExitCR:
.1ce2	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1ce4	20 eb 11	jsr $11eb			jsr 	PushIntegerA
.1ce7	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1ce9	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1cec	60		rts				rts
.1ced					_CPAtEnd:
.1ced	c9 00		cmp #$00			cmp 	#0
.1cef	f0 06		beq $1cf7			beq 	_CPIsEnd
.1cf1	c9 3a		cmp #$3a			cmp 	#":"
.1cf3	f0 02		beq $1cf7			beq 	_CPIsEnd
.1cf5	18		clc				clc
.1cf6	60		rts				rts
.1cf7					_CPIsEnd:
.1cf7	38		sec				sec
.1cf8	60		rts				rts
.1cf9					CommandREAD:
.1cf9	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1cfb	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1cfd					CommandReadInputCommon:
.1cfd	8e 0d 05	stx $050d			stx 	numberPCode
.1d00	8c 0e 05	sty $050e			sty 	stringPCode
.1d03					_CRLoop:
.1d03	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; first char of identifier
.1d06	20 4f 1a	jsr $1a4f			jsr 	CharIsAlpha 				; check A-Z
.1d09	90 27		bcc $1d32			bcc 	_CRSyntax
.1d0b	20 83 1d	jsr $1d83			jsr 	GetReferenceTerm 			; get the variable.
.1d0e	48		pha				pha 								; save type.
.1d0f	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1d11	c9 40		cmp #$40			cmp 	#NSSString
.1d13	f0 05		beq $1d1a			beq 	_CRString
.1d15	ad 0d 05	lda $050d			lda 	numberPCode 				; output read/input
.1d18	80 03		bra $1d1d			bra 	_CRHaveType
.1d1a					_CRString:
.1d1a	ad 0e 05	lda $050e			lda 	stringPCode					; output read$/input$
.1d1d					_CRHaveType:
.1d1d	20 da 10	jsr $10da			jsr 	WriteCodeByte 				; so we have one typed data item.
.1d20	68		pla				pla 								; restore type
.1d21	38		sec				sec  								; write update code.
.1d22	20 35 1d	jsr $1d35			jsr 	GetSetVariable
.1d25	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; , follows ?
.1d28	c9 2c		cmp #$2c			cmp 	#","
.1d2a	d0 05		bne $1d31			bne 	_CRExit 					; if not, end of READ.
.1d2c	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume comma
.1d2f	80 d2		bra $1d03			bra 	_CRLoop 					; keep going
.1d31					_CRExit:
.1d31	60		rts				rts
.1d32					_CRSyntax:
.1d32	4c 21 1f	jmp $1f21		jmp	ErrorV_syntax
.050d					numberPCode:
>050d							.fill 	1
.050e					stringPCode:
>050e							.fill 	1
.1d35					GetSetVariable:
.1d35	08		php				php 								; save direction on stack
.1d36	c0 00		cpy #$00			cpy 	#$00
.1d38	30 21		bmi $1d5b			bmi 	_GSVReadWriteSpecial
.1d3a	c9 00		cmp #$00			cmp 	#$00
.1d3c	30 33		bmi $1d71			bmi 	_GSVArray
.1d3e	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1d40	4a		lsr a				lsr 	a 							; divide by 2
.1d41	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1d43	28		plp				plp
.1d44	90 02		bcc $1d48			bcc 	_GSVNotWrite
.1d46	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1d48					_GSVNotWrite:
.1d48	85 2d		sta $2d				sta 	zTemp0
.1d4a	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1d4b	4a		lsr a				lsr 	a
.1d4c	a8		tay				tay
.1d4d	8a		txa				txa
.1d4e	6a		ror a				ror 	a
.1d4f	aa		tax				tax
.1d50	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1d51	05 2d		ora $2d				ora 	zTemp0 						; which is the first byte of the opcode
.1d53	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1d56	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1d57	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1d5a	60		rts				rts
.1d5b					_GSVReadWriteSpecial:
.1d5b	28		plp				plp
.1d5c	b0 10		bcs $1d6e			bcs 	_GSVSyntax
.1d5e	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1d60	f0 06		beq $1d68			beq 	_GSVRWString
.1d62	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1d64	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1d67	60		rts				rts
.1d68					_GSVRWString:
.1d68	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1d6a	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1d6d	60		rts				rts
.1d6e					_GSVSyntax:
.1d6e	4c 21 1f	jmp $1f21		jmp	ErrorV_syntax
.1d71					_GSVArray:
.1d71	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1d73	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1d74	4a		lsr a				lsr 	a
.1d75	4a		lsr a				lsr 	a
.1d76	4a		lsr a				lsr 	a
.1d77	4a		lsr a				lsr 	a
.1d78	28		plp				plp 								; if writing array then set bit 2.
.1d79	90 02		bcc $1d7d			bcc 	_GSVANotWrite
.1d7b	09 04		ora #$04			ora 	#4
.1d7d					_GSVANotWrite:
.1d7d	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1d7f	20 da 10	jsr $10da			jsr 	WriteCodeByte 				; and write it out
.1d82	60		rts				rts
.1d83					GetReferenceTerm:
.1d83	20 9e 1a	jsr $1a9e			jsr 	ExtractVariableName 		; get name & type info
.1d86	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1d88	30 10		bmi $1d9a			bmi 	_GRTArray
.1d8a	da		phx				phx 								; save type on stack
.1d8b	20 98 14	jsr $1498			jsr 	FindVariable 				; find it
.1d8e	b0 06		bcs $1d96			bcs 	_GRTNoCreate 				; create if required.
.1d90	20 1d 12	jsr $121d			jsr 	CreateVariableRecord 		; create a variable.
.1d93	20 77 12	jsr $1277			jsr 	AllocateBytesForType 		; allocate memory for it
.1d96					_GRTNoCreate:
.1d96	68		pla				pla 								; get type back, strip out type information.
.1d97	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1d99	60		rts				rts
.1d9a					_GRTArray:
.1d9a	da		phx				phx 								; save type information
.1d9b	20 98 14	jsr $1498			jsr 	FindVariable 				; read its data, the base address in YX
.1d9e	90 18		bcc $1db8			bcc 	_GRTUndeclared 				; undeclared array.
.1da0	da		phx				phx 								; save base address
.1da1	5a		phy				phy
.1da2	20 6e 13	jsr $136e			jsr 	OutputIndexGroup 			; create an index group and generate them
.1da5	7a		ply				ply 								; get the array base address into YX
.1da6	fa		plx				plx
.1da7	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1da9	18		clc				clc
.1daa	20 35 1d	jsr $1d35			jsr 	GetSetVariable 				; load the address of the array structure.
.1dad	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1daf	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1db2	68		pla				pla 								; and the type data into A
.1db3	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1db5	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1db7	60		rts				rts
.1db8					_GRTUndeclared:
.1db8	4c d8 1f	jmp $1fd8		jmp	ErrorV_undeclared
.1dbb					CommandREM:
.1dbb	20 1d 1a	jsr $1a1d			jsr 	LookNext
.1dbe	f0 05		beq $1dc5			beq 	_CRExit
.1dc0	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1dc3	80 f6		bra $1dbb			bra 	CommandREM
.1dc5					_CRExit:
.1dc5	60		rts				rts
.1dc6					STRReset:
.1dc6	ad 07 05	lda $0507			lda	 	compilerStartHigh 			; set up the two table pointers
.1dc9	8d 12 05	sta $0512			sta 	variableListEnd+1
.1dcc	9c 11 05	stz $0511			stz 	variableListEnd
.1dcf	ad 08 05	lda $0508			lda 	compilerEndHigh
.1dd2	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1dd5	9c 0f 05	stz $050f			stz 	lineNumberTable
.1dd8	ad 11 05	lda $0511			lda 	variableListEnd
.1ddb	85 2e		sta $2e				sta 	zTemp0+1
.1ddd	64 2d		stz $2d				stz 	zTemp0
.1ddf	a9 00		lda #$00			lda 	#0
.1de1	92 2d		sta ($2d)			sta 	(zTemp0)
.1de3	a9 00		lda #$00			lda 	#((0) & $FF)
.1de5	8d 13 05	sta $0513			sta 	0+freeVariableMemory
.1de8	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1dea	8d 14 05	sta $0514			sta 	1+freeVariableMemory
.1ded	60		rts				rts
.050f					lineNumberTable:
>050f							.fill 	2
.0511					variableListEnd:
>0511							.fill 	2
.0513					freeVariableMemory:
>0513							.fill 	2
.1dee					CompileTerm:
.1dee	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; get first non space character.
.1df1	30 72		bmi $1e65			bmi 	_CTUnaryFunctions
.1df3	20 43 1a	jsr $1a43			jsr 	CharIsDigit 				; found a number
.1df6	b0 3a		bcs $1e32			bcs 	_CTDigit
.1df8	c9 2e		cmp #$2e			cmp 	#"."
.1dfa	f0 36		beq $1e32			beq 	_CTDigit
.1dfc	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1dfe	f0 43		beq $1e43			beq 	_CTString
.1e00	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1e02	f0 28		beq $1e2c			beq 	_CTOtherBase
.1e04	c9 24		cmp #$24			cmp 	#"$"
.1e06	f0 24		beq $1e2c			beq 	_CTOtherBase
.1e08	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1e0a	f0 17		beq $1e23			beq 	_CTBrackets
.1e0c	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1e0e	90 10		bcc $1e20			bcc 	_CTSyntax
.1e10	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1e12	b0 0c		bcs $1e20			bcs 	_CTSyntax
.1e14	20 83 1d	jsr $1d83			jsr 	GetReferenceTerm 			; figure out what it is.
.1e17	48		pha				pha 								; save type on stack
.1e18	18		clc				clc 								; read it
.1e19	20 35 1d	jsr $1d35			jsr 	GetSetVariable
.1e1c	68		pla				pla
.1e1d	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1e1f	60		rts				rts
.1e20					_CTSyntax:
.1e20	4c 21 1f	jmp $1f21		jmp	ErrorV_syntax
.1e23					_CTBrackets:
.1e23	20 de 13	jsr $13de			jsr 	CompileExpressionAt0
.1e26	48		pha				pha
.1e27	20 36 11	jsr $1136			jsr 	CheckNextRParen
.1e2a	68		pla				pla
.1e2b	60		rts				rts
.1e2c					_CTOtherBase:
.1e2c	20 88 10	jsr $1088			jsr 	InlineNonDecimal 			; non decimal constant handler
.1e2f	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e31	60		rts				rts
.1e32					_CTDigit:
.1e32	20 8b 1c	jsr $1c8b			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1e35	90 06		bcc $1e3d			bcc	 	_CTFloat 					; have a float or long int.
.1e37	20 d8 11	jsr $11d8			jsr 	PushIntegerYA 				; code to push on stack
.1e3a	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e3c	60		rts				rts
.1e3d					_CTFloat:
.1e3d	20 fa 11	jsr $11fa			jsr 	PushFloat  					; code to push float
.1e40	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1e42	60		rts				rts
.1e43					_CTString:
.1e43	20 0b 11	jsr $110b			jsr 	BufferClear 				; copy it to the buffer
.1e46					_CTStringLoop:
.1e46	20 1d 1a	jsr $1a1d			jsr 	LookNext 					; reached EOL/EOS
.1e49	f0 d5		beq $1e20			beq 	_CTSyntax
.1e4b	c9 22		cmp #$22			cmp 	#'"'
.1e4d	f0 08		beq $1e57			beq 	_CTStringDone
.1e4f	20 0f 11	jsr $110f			jsr 	BufferWrite 				; write and consume
.1e52	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1e55	80 ef		bra $1e46			bra 	_CTStringLoop
.1e57					_CTStringDone:
.1e57	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume closing quote.
.1e5a	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1e5c	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1e5f	20 1b 11	jsr $111b			jsr 	BufferOutput
.1e62	a9 40		lda #$40			lda 	#NSSString 					; string type
.1e64	60		rts				rts
.1e65					_CTUnaryFunctions:
.1e65	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1e67	f0 0a		beq $1e73			beq 	_CTNegation
.1e69	a2 c8		ldx #$c8			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1e6b	a0 17		ldy #$17			ldy 	#UnaryTables >> 8
.1e6d	20 c2 18	jsr $18c2			jsr 	GeneratorProcess
.1e70	90 ae		bcc $1e20			bcc		_CTSyntax
.1e72	60		rts				rts
.1e73					_CTNegation:
.1e73	20 ee 1d	jsr $1dee			jsr 	CompileTerm 				; compile a term.
.1e76	48		pha				pha
.1e77	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1e79	c9 00		cmp #$00			cmp 	#NSSIFloat
.1e7b	d0 07		bne $1e84			bne 	_CTType 					; error
.1e7d	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1e7f	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1e82	68		pla				pla 								; return original type.
.1e83	60		rts				rts
.1e84					_CTType:
.1e84	4c 31 1f	jmp $1f31		jmp	ErrorV_type
.1e87					CommandWAIT:
.1e87	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace
.1e8a	c9 2c		cmp #$2c			cmp 	#","
.1e8c	f0 10		beq $1e9e			beq 	_CWThirdParameter
.1e8e	a9 00		lda #$00			lda 	#0
.1e90	20 eb 11	jsr $11eb			jsr 	PushIntegerA
.1e93					_CWExit:
.1e93	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1e95	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1e98	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1e9a	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1e9d	60		rts				rts
.1e9e					_CWThirdParameter:
.1e9e	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1ea1	20 e0 13	jsr $13e0			jsr 	CompileExpressionAtA
.1ea4	29 40		and #$40			and 	#NSSTypeMask
.1ea6	c9 00		cmp #$00			cmp 	#NSSIFloat
.1ea8	f0 e9		beq $1e93			beq 	_CWExit
.1eaa	4c 31 1f	jmp $1f31		jmp	ErrorV_type
.1ead					CommandCMD:
.1ead	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.1eaf	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1eb2	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; followed by a , ?
.1eb5	c9 2c		cmp #$2c			cmp 	#","
.1eb7	d0 06		bne $1ebf			bne 	_CCMDExit
.1eb9	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume comma.
.1ebc	20 b0 1c	jsr $1cb0			jsr 	CommandPRINT 				; do the print code
.1ebf					_CCMDExit:
.1ebf	60		rts				rts
.1ec0					CommandOPEN:
.1ec0	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; followed by a , ?
.1ec3	c9 2c		cmp #$2c			cmp 	#","
.1ec5	d0 15		bne $1edc			bne 	_COTwoDefaults
.1ec7	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume comma
.1eca	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1ecd	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1ecf	f0 1e		beq $1eef			beq 	_COThreeIntegers
.1ed1	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1ed3	20 eb 11	jsr $11eb			jsr 	PushIntegerA
.1ed6	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1ed8	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1edb	60		rts				rts
.1edc					_COTwoDefaults:
.1edc	a9 00		lda #$00			lda 	#0
.1ede	20 eb 11	jsr $11eb			jsr 	PushIntegerA
.1ee1					_COCompileNullString:
.1ee1	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1ee3	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1ee6	a9 00		lda #$00			lda 	#0
.1ee8	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1eeb	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1eee	60		rts				rts
.1eef					_COThreeIntegers:
.1eef	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; is there a ,
.1ef2	c9 2c		cmp #$2c			cmp 	#","
.1ef4	d0 eb		bne $1ee1			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1ef6	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1ef9	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; should be a filename
.1efc	29 40		and #$40			and 	#NSSString
.1efe	f0 01		beq $1f01			beq 	_COType
.1f00	60		rts				rts
.1f01					_COType:
.1f01	4c 31 1f	jmp $1f31		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					codePage:
>0028							.fill 	1
.0029					objPtr:
>0029							.fill 	2 							; bytes must not change (it could expand) as the
.002b					objPage:
>002b							.fill 	1
.002c					objIncrement:
>002c							.fill 	1
.002d					zTemp0:
>002d							.fill 	2
.002f					zTemp1:
>002f							.fill 	2
.0031					zTemp2:
>0031							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1f04					ErrorV_range:
.1f04	20 96 13	jsr $1396		jsr	ErrorHandler
>1f07	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f0f	41 4e 47 45 00
.1f14					ErrorV_value:
.1f14	20 96 13	jsr $1396		jsr	ErrorHandler
>1f17	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f1f	45 00
.1f21					ErrorV_syntax:
.1f21	20 96 13	jsr $1396		jsr	ErrorHandler
>1f24	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f2c	52 52 4f 52 00
.1f31					ErrorV_type:
.1f31	20 96 13	jsr $1396		jsr	ErrorHandler
>1f34	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f3c	4d 41 54 43 48 00
.1f42					ErrorV_unimplemented:
.1f42	20 96 13	jsr $1396		jsr	ErrorHandler
>1f45	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f4d	45 4d 45 4e 54 45 44 00
.1f55					ErrorV_assert:
.1f55	20 96 13	jsr $1396		jsr	ErrorHandler
>1f58	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f60	41 49 4c 00
.1f64					ErrorV_line:
.1f64	20 96 13	jsr $1396		jsr	ErrorHandler
>1f67	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f6f	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f7b					ErrorV_internal:
.1f7b	20 96 13	jsr $1396		jsr	ErrorHandler
>1f7e	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f86	20 45 52 52 4f 52 00
.1f8d					ErrorV_divzero:
.1f8d	20 96 13	jsr $1396		jsr	ErrorHandler
>1f90	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1f98	59 20 5a 45 52 4f 00
.1f9f					ErrorV_structure:
.1f9f	20 96 13	jsr $1396		jsr	ErrorHandler
>1fa2	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1faa	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fb6					ErrorV_stop:
.1fb6	20 96 13	jsr $1396		jsr	ErrorHandler
>1fb9	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fc1	53 54 4f 50 50 45 44 00
.1fc9					ErrorV_data:
.1fc9	20 96 13	jsr $1396		jsr	ErrorHandler
>1fcc	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fd4	41 54 41 00
.1fd8					ErrorV_undeclared:
.1fd8	20 96 13	jsr $1396		jsr	ErrorHandler
>1fdb	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1fe3	41 52 52 41 59 00
.1fe9					ErrorV_redefine:
.1fe9	20 96 13	jsr $1396		jsr	ErrorHandler
>1fec	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1ff4	44 45 46 49 4e 45 44 00
.1ffc					ErrorV_index:
.1ffc	20 96 13	jsr $1396		jsr	ErrorHandler
>1fff	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2007	59 20 49 4e 44 45 58 00
.200f					ErrorV_memory:
.200f	20 96 13	jsr $1396		jsr	ErrorHandler
>2012	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>201a	45 4d 4f 52 59 00
.2020					ErrorV_channel:
.2020	20 96 13	jsr $1396		jsr	ErrorHandler
>2023	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>202b	54 50 55 54 20 45 52 52 4f 52 00
.2036					MoveObjectForward:
.2036	b2 29		lda ($29)			lda 	(objPtr) 					; get next
.2038	c9 ff		cmp #$ff			cmp 	#$FF
.203a	f0 36		beq $2072			beq 	_MOFEnd
.203c	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.203e	90 24		bcc $2064			bcc 	_MOFAdvance1 				; forward 1
.2040	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.2042	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2044	90 20		bcc $2066			bcc 	_MOFAdvanceY
.2046	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2048	90 1a		bcc $2064			bcc 	_MOFAdvance1 				; forward 1
.204a	a8		tay				tay 								; read the size.
.204b	b9 b0 1f	lda $1fb0,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.204e	a8		tay				tay
.204f	c8		iny				iny 								; add 1 for the system token.
.2050	d0 14		bne $2066			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2052	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2054	b1 29		lda ($29),y			lda 	(objPtr),y
.2056	a8		tay				tay 								; into Y.
.2057	18		clc				clc
.2058	a5 29		lda $29				lda 	objPtr						; add 2 to the object pointer
.205a	69 02		adc #$02			adc 	#2
.205c	85 29		sta $29				sta 	objPtr
.205e	90 02		bcc $2062			bcc 	_MOFNoCarry1
.2060	e6 2a		inc $2a				inc 	objPtr+1
.2062					_MOFNoCarry1:
.2062	80 02		bra $2066			bra 	_MOFAdvanceY
.2064					_MOFAdvance1:
.2064	a0 01		ldy #$01			ldy 	#1
.2066					_MOFAdvanceY:
.2066	98		tya				tya 								; add Y to objPtr
.2067	18		clc				clc
.2068	65 29		adc $29				adc 	objPtr
.206a	85 29		sta $29				sta 	objPtr
.206c	90 02		bcc $2070			bcc 	_MOFNoCarry2
.206e	e6 2a		inc $2a				inc 	objPtr+1
.2070					_MOFNoCarry2:
.2070	18		clc				clc 								; not completed.
.2071	60		rts				rts
.2072					_MOFEnd:
.2072	e6 29		inc $29				inc 	objPtr
.2074	d0 02		bne $2078			bne 	_MOFENoCarry
.2076	e6 2a		inc $2a				inc 	objPtr+1
.2078					_MOFENoCarry:
.2078	38		sec				sec
.2079	60		rts				rts
.207a					MOFSizeTable:
>207a	01					.byte	1         	; $ca .shift
>207b	01					.byte	1         	; $cb .byte
>207c	02					.byte	2         	; $cc .word
>207d	05					.byte	5         	; $cd .float
>207e	ff					.byte	255       	; $ce .string
>207f	ff					.byte	255       	; $cf .data
>2080	02					.byte	2         	; $d0 .goto
>2081	02					.byte	2         	; $d1 .gosub
>2082	02					.byte	2         	; $d2 .goto.z
>2083	02					.byte	2         	; $d3 .goto.nz
>2084	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0033					NSStatus:
>0033							.fill 	MathStackSize
.003f					NSMantissa0:
>003f							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004b					NSMantissa1:
>004b							.fill 	MathStackSize
.0057					NSMantissa2:
>0057							.fill 	MathStackSize
.0063					NSMantissa3:
>0063							.fill 	MathStackSize
.006f					NSExponent:
>006f							.fill 	MathStackSize
.0515					numberBuffer:
>0515							.fill 	34
.2085					FloatSubtract:
.2085	b5 33		lda $33,x			lda 	NSStatus,x 					; negate top of stack
.2087	49 80		eor #$80			eor 	#$80
.2089	95 33		sta $33,x			sta 	NSStatus,x					; and fall through.
.208b					FloatAdd:
.208b	ca		dex				dex
.208c	b5 6f		lda $6f,x			lda 	NSExponent,x 				; can use optimised.
.208e	15 70		ora $70,x			ora 	NSExponent+1,x
.2090	15 63		ora $63,x			ora 	NSMantissa3,x
.2092	15 64		ora $64,x			ora 	NSMantissa3+1,x
.2094	d0 04		bne $209a			bne 	_FAUseFloat
.2096	20 27 24	jsr $2427			jsr 	FloatInt32Add 				; use the int32 one.
.2099	60		rts				rts
.209a					_FAUseFloat:
.209a	20 bc 23	jsr $23bc			jsr 	FloatNormalise 				; normalise S[X]
.209d	f0 51		beq $20f0			beq 	_FAReturn1
.209f	e8		inx				inx 								; normalise S[X+1]
.20a0	20 bc 23	jsr $23bc			jsr 	FloatNormalise
.20a3	ca		dex				dex
.20a4	c9 00		cmp #$00			cmp 	#0
.20a6	f0 60		beq $2108			beq 	_FAExit 					; if so, just return A
.20a8	b5 6f		lda $6f,x			lda 	NSExponent,x 				; are the exponents the same ?
.20aa	d5 70		cmp $70,x			cmp 	NSExponent+1,x
.20ac	f0 18		beq $20c6			beq 	_FAExponentsEqual
.20ae	b5 6f		lda $6f,x			lda 	NSExponent,x 				; work out the larger exponent
.20b0	a8		tay				tay
.20b1	38		sec				sec 								; do a signed comparison of the exponents.
.20b2	f5 70		sbc $70,x			sbc 	NSExponent+1,x
.20b4	50 02		bvc $20b8			bvc 	_FANoSignedChange
.20b6	49 80		eor #$80			eor 	#$80
.20b8					_FANoSignedChange:
.20b8	29 80		and #$80			and 	#$80
.20ba	10 02		bpl $20be			bpl 	_FAHaveMax
.20bc	b4 70		ldy $70,x			ldy 	NSExponent+1,x
.20be					_FAHaveMax:
.20be	20 09 21	jsr $2109			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20c1	e8		inx				inx
.20c2	20 09 21	jsr $2109			jsr 	_FAShiftToExponent
.20c5	ca		dex				dex
.20c6					_FAExponentsEqual:
.20c6	b5 33		lda $33,x			lda 	NSStatus,x 					; are the signs the same
.20c8	55 34		eor $34,x			eor 	NSStatus+1,x
.20ca	30 0e		bmi $20da			bmi 	_FADifferentSigns
.20cc	20 f3 23	jsr $23f3			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20cf	b5 63		lda $63,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20d1	10 35		bpl $2108			bpl 	_FAExit 					; if no, we are done.
.20d3	20 80 26	jsr $2680			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20d6	f6 6f		inc $6f,x			inc 	NSExponent,x 				; bump the exponent and exit
.20d8	80 2e		bra $2108			bra 	_FAExit
.20da					_FADifferentSigns:
.20da	20 0d 24	jsr $240d			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20dd	b5 63		lda $63,x			lda 	NSMantissa3,x 				; is the result negative ?
.20df	10 06		bpl $20e7			bpl 	_FACheckZero 				; if no, check for -0
.20e1	20 29 26	jsr $2629			jsr 	FloatNegate 					; netate result
.20e4	20 30 26	jsr $2630			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20e7					_FACheckZero:
.20e7	20 89 26	jsr $2689			jsr 	FloatIsZero	 				; check for -0
.20ea	d0 1c		bne $2108			bne 	_FAExit
.20ec	74 33		stz $33,x			stz 	NSStatus,x
.20ee	80 18		bra $2108			bra 	_FAExit
.20f0					_FAReturn1:
.20f0	b5 40		lda $40,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20f2	95 3f		sta $3f,x			sta 	NSMantissa0,x
.20f4	b5 4c		lda $4c,x			lda 	NSMantissa1+1,x
.20f6	95 4b		sta $4b,x			sta 	NSMantissa1,x
.20f8	b5 58		lda $58,x			lda 	NSMantissa2+1,x
.20fa	95 57		sta $57,x			sta 	NSMantissa2,x
.20fc	b5 64		lda $64,x			lda 	NSMantissa3+1,x
.20fe	95 63		sta $63,x			sta 	NSMantissa3,x
.2100	b5 70		lda $70,x			lda 	NSExponent+1,x
.2102	95 6f		sta $6f,x			sta 	NSExponent,x
.2104	b5 34		lda $34,x			lda 	NSStatus+1,x
.2106	95 33		sta $33,x			sta 	NSStatus,x
.2108					_FAExit:
.2108	60		rts				rts
.2109					_FAShiftToExponent:
.2109					_FAShiftToExponent2:
.2109	98		tya				tya 								; compare Y to exponent
.210a	d5 6f		cmp $6f,x			cmp 	NSExponent,x 				; reached the exponent required ?
.210c	f0 07		beq $2115			beq 	_FASEExit 					; exit if so.
.210e	20 80 26	jsr $2680			jsr 	FloatShiftRight	 			; shift the mantissa right
.2111	f6 6f		inc $6f,x			inc 	NSExponent,x 				; increment exponent
.2113	80 f4		bra $2109			bra 	_FAShiftToExponent2
.2115					_FASEExit:
.2115	60		rts				rts
.2116					CompareEqual:
.2116	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2118	d0 09		bne $2123			bne 	ReturnFalse
.211a					ReturnTrue:
.211a	a9 01		lda #$01			lda 	#1
.211c	95 3f		sta $3f,x			sta 	NSMantissa0,x
.211e	a9 80		lda #$80			lda 	#$80
.2120	95 33		sta $33,x			sta 	NSStatus,x
.2122	60		rts				rts
.2123					ReturnFalse:
.2123	74 3f		stz $3f,x			stz 	NSMantissa0,x
.2125	60		rts				rts
.2126					CompareNotEqual:
.2126	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2128	d0 f0		bne $211a			bne 	ReturnTrue
.212a	80 f7		bra $2123			bra 	ReturnFalse
.212c					CompareLess:
.212c	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.212e	c9 ff		cmp #$ff			cmp 	#$FF
.2130	f0 e8		beq $211a			beq 	ReturnTrue
.2132	80 ef		bra $2123			bra 	ReturnFalse
.2134					CompareGreater:
.2134	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2136	c9 01		cmp #$01			cmp 	#$01
.2138	f0 e0		beq $211a			beq 	ReturnTrue
.213a	80 e7		bra $2123			bra 	ReturnFalse
.213c					CompareLessEqual:
.213c	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.213e	c9 01		cmp #$01			cmp 	#$01
.2140	d0 d8		bne $211a			bne 	ReturnTrue
.2142	80 df		bra $2123			bra 	ReturnFalse
.2144					CompareGreaterEqual:
.2144	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2146	c9 ff		cmp #$ff			cmp 	#$FF
.2148	d0 d0		bne $211a			bne 	ReturnTrue
.214a	80 d7		bra $2123			bra 	ReturnFalse
.214c					FloatCompare:
.214c	b5 6f		lda $6f,x			lda 	NSExponent,x 				; float comparison.
.214e	15 6e		ora $6e,x			ora 	NSExponent-1,x 				; integer if both integer.
.2150	48		pha				pha
.2151	20 85 20	jsr $2085			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2154	68		pla				pla
.2155	d0 0c		bne $2163			bne 	_FCCompareFloat
.2157	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2159	15 4b		ora $4b,x			ora 	NSMantissa1,x
.215b	15 57		ora $57,x			ora 	NSMantissa2,x
.215d	15 63		ora $63,x			ora 	NSMantissa3,x
.215f	f0 14		beq $2175			beq 	_FCExit 					; if zero, return zero
.2161	80 0a		bra $216d			bra 	_FCSign
.2163					_FCCompareFloat:
.2163	b5 4b		lda $4b,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2165	29 f0		and #$f0			and 	#$F0
.2167	15 57		ora $57,x			ora 	NSMantissa2,x
.2169	15 63		ora $63,x			ora 	NSMantissa3,x
.216b	f0 08		beq $2175			beq 	_FCExit 					; zero, so approximately identical
.216d					_FCSign:
.216d	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.216f	34 33		bit $33,x			bit 	NSStatus,x
.2171	10 02		bpl $2175			bpl 	_FCExit
.2173					_FCNegative:
.2173	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2175					_FCExit:
.2175	20 69 26	jsr $2669			jsr 	FloatSetByte 				; set the result 255,0,1
.2178	60		rts				rts
.2179					FloatScalarTable:
>2179	66 66 66 66				.dword $66666666 ; 0.1
>217d	de					.byte $de
>217e	1f 85 eb 51				.dword $51eb851f ; 0.01
>2182	db					.byte $db
>2183	4c 37 89 41				.dword $4189374c ; 0.001
>2187	d8					.byte $d8
>2188	ac 8b db 68				.dword $68db8bac ; 0.0001
>218c	d4					.byte $d4
>218d	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>2191	d1					.byte $d1
>2192	83 de 1b 43				.dword $431bde83 ; 1e-06
>2196	ce					.byte $ce
>2197	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>219b	ca					.byte $ca
>219c	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21a0	c7					.byte $c7
>21a1	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21a5	c4					.byte $c4
>21a6	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21aa	c0					.byte $c0
>21ab	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21af	bd					.byte $bd
.21b0					FloatDivide:
.21b0	48		pha				pha
.21b1	20 bc 23	jsr $23bc			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21b4	ca		dex				dex
.21b5	c9 00		cmp #$00			cmp 	#0
.21b7	f0 1e		beq $21d7			beq 	_FDZero
.21b9	20 bc 23	jsr $23bc			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21bc	f0 16		beq $21d4			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21be	20 1f 22	jsr $221f			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21c1	20 ec 21	jsr $21ec			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21c4	20 bc 23	jsr $23bc			jsr		FloatNormalise 				; renormalise
.21c7	20 b2 23	jsr $23b2			jsr 	FloatCalculateSign 			; calculate result sign
.21ca	b5 6f		lda $6f,x			lda 	NSExponent,x 				; calculate exponent
.21cc	38		sec				sec
.21cd	f5 70		sbc $70,x			sbc 	NSExponent+1,x
.21cf	38		sec				sec
.21d0	e9 1e		sbc #$1e			sbc 	#30
.21d2	95 6f		sta $6f,x			sta 	NSExponent,x
.21d4					_FDExit:
.21d4	68		pla				pla
.21d5	18		clc				clc
.21d6	60		rts				rts
.21d7					_FDZero:
.21d7	68		pla				pla
.21d8	38		sec				sec
.21d9	60		rts				rts
.21da					DivideInt32:
.21da	20 a2 22	jsr $22a2			jsr 	FloatIntegerPart 			; make both integers
.21dd	ca		dex				dex
.21de	20 a2 22	jsr $22a2			jsr 	FloatIntegerPart
.21e1	20 fd 21	jsr $21fd			jsr 	Int32Divide 				; divide
.21e4	20 ec 21	jsr $21ec			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21e7	20 b2 23	jsr $23b2			jsr 	FloatCalculateSign 			; calculate result sign
.21ea	18		clc				clc
.21eb	60		rts				rts
.21ec					NSMCopyPlusTwoToZero:
.21ec	b5 41		lda $41,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21ee	95 3f		sta $3f,x			sta 	NSMantissa0,x
.21f0	b5 4d		lda $4d,x			lda 	NSMantissa1+2,x
.21f2	95 4b		sta $4b,x			sta 	NSMantissa1,x
.21f4	b5 59		lda $59,x			lda 	NSMantissa2+2,x
.21f6	95 57		sta $57,x			sta 	NSMantissa2,x
.21f8	b5 65		lda $65,x			lda 	NSMantissa3+2,x
.21fa	95 63		sta $63,x			sta 	NSMantissa3,x
.21fc	60		rts				rts
.21fd					Int32Divide:
.21fd	48		pha				pha 								; save AXY
.21fe	5a		phy				phy
.21ff	20 4a 26	jsr $264a			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2202	20 63 26	jsr $2663			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2205	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2207					_I32DivideLoop:
.2207	e8		inx				inx
.2208	e8		inx				inx
.2209	20 76 26	jsr $2676			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.220c	ca		dex				dex
.220d	ca		dex				dex
.220e	20 77 26	jsr $2677			jsr 	FloatRotateLeft
.2211	20 3d 22	jsr $223d			jsr 	FloatDivideCheck 			; check if subtract possible
.2214	90 02		bcc $2218			bcc 	_I32DivideNoCarryIn
.2216	f6 41		inc $41,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2218					_I32DivideNoCarryIn:
.2218	88		dey				dey 								; loop round till division completed.
.2219	d0 ec		bne $2207			bne 	_I32DivideLoop
.221b	7a		ply				ply 								; restore AXY and exit
.221c	68		pla				pla
.221d	18		clc				clc
.221e	60		rts				rts
.221f					Int32ShiftDivide:
.221f	48		pha				pha 								; save AY
.2220	5a		phy				phy
.2221	e8		inx				inx 								; clear S[X+2]
.2222	e8		inx				inx
.2223	20 67 26	jsr $2667			jsr 	FloatSetZero
.2226	ca		dex				dex
.2227	ca		dex				dex
.2228	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.222a					_I32SDLoop:
.222a	20 3d 22	jsr $223d			jsr 	FloatDivideCheck 			; check if subtract possible
.222d	e8		inx				inx
.222e	e8		inx				inx
.222f	20 77 26	jsr $2677			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.2232	ca		dex				dex
.2233	ca		dex				dex
.2234	20 77 26	jsr $2677			jsr 	FloatRotateLeft
.2237	88		dey				dey 	 							; do 31 times
.2238	d0 f0		bne $222a			bne 	_I32SDLoop
.223a	7a		ply				ply 								; restore AY and exit
.223b	68		pla				pla
.223c	60		rts				rts
.223d					FloatDivideCheck:
.223d	20 0d 24	jsr $240d			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.2240	b0 04		bcs $2246			bcs 	_DCSExit 					; if carry set, then could do, exit
.2242	20 f3 23	jsr $23f3			jsr 	FloatAddTopTwoStack 		; add it back in
.2245	18		clc				clc 								; and return False
.2246					_DCSExit:
.2246	60		rts				rts
.2247					FloatFractionalPart:
.2247	5a		phy				phy
.2248	b5 33		lda $33,x			lda 	NSStatus,x 					; take absolute value
.224a	29 7f		and #$7f			and 	#$7F
.224c	95 33		sta $33,x			sta 	NSStatus,x
.224e	20 bc 23	jsr $23bc			jsr 	FloatNormalise
.2251	b5 6f		lda $6f,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2253	38		sec				sec
.2254	e9 e0		sbc #$e0			sbc 	#$E0
.2256	90 29		bcc $2281			bcc 	_FFPExit 					; already fractional
.2258	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.225a	b0 22		bcs $227e			bcs 	_FFPZero
.225c	a8		tay				tay 								; put count to do in Y
.225d	b5 63		lda $63,x			lda 	NSMantissa3,x 				; do each in turn.
.225f	20 86 22	jsr $2286			jsr 	_FFPPartial
.2262	95 63		sta $63,x			sta 	NSMantissa3,x
.2264	b5 57		lda $57,x			lda 	NSMantissa2,x
.2266	20 86 22	jsr $2286			jsr 	_FFPPartial
.2269	95 57		sta $57,x			sta 	NSMantissa2,x
.226b	b5 4b		lda $4b,x			lda 	NSMantissa1,x
.226d	20 86 22	jsr $2286			jsr 	_FFPPartial
.2270	95 4b		sta $4b,x			sta 	NSMantissa1,x
.2272	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2274	20 86 22	jsr $2286			jsr 	_FFPPartial
.2277	95 3f		sta $3f,x			sta 	NSMantissa0,x
.2279	20 89 26	jsr $2689			jsr 	FloatIsZero 					; zeroed check.
.227c	d0 03		bne $2281			bne 	_FFPExit
.227e					_FFPZero:
.227e	20 67 26	jsr $2667			jsr 	FloatSetZero
.2281					_FFPExit:
.2281	20 bc 23	jsr $23bc			jsr 	FloatNormalise
.2284	7a		ply				ply
.2285	60		rts				rts
.2286					_FFPPartial:
.2286	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2288	f0 17		beq $22a1			beq 	_FFFPPExit
.228a	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.228c	b0 0c		bcs $229a			bcs 	_FFFPPWholeByte
.228e	5a		phy				phy
.228f					_FFFPPLeft:
.228f	0a		asl a				asl 	a
.2290	88		dey				dey
.2291	d0 fc		bne $228f			bne 	_FFFPPLeft
.2293	7a		ply				ply
.2294					_FFFPPRight:
.2294	4a		lsr a				lsr 	a
.2295	88		dey				dey
.2296	d0 fc		bne $2294			bne 	_FFFPPRight
.2298	80 07		bra $22a1			bra 	_FFFPPExit
.229a					_FFFPPWholeByte:
.229a	98		tya				tya 								; subtract 8 from count
.229b	38		sec				sec
.229c	e9 08		sbc #$08			sbc 	#8
.229e	a8		tay				tay
.229f	a9 00		lda #$00			lda 	#0 							; and clear all
.22a1					_FFFPPExit:
.22a1	60		rts				rts
.22a2					FloatIntegerPart:
.22a2	48		pha				pha
.22a3	b5 6f		lda $6f,x			lda 	NSExponent,x 				; is it integer already ?
.22a5	f0 1d		beq $22c4			beq 	_FIPExit 					; if so do nothing
.22a7	20 89 26	jsr $2689			jsr 	FloatIsZero 				; is it zero ?
.22aa	f0 15		beq $22c1			beq 	_FIPZero 					; if so return zero.
.22ac	20 bc 23	jsr $23bc			jsr 	FloatNormalise 				; normalise
.22af	f0 10		beq $22c1			beq 	_FIPZero 					; normalised to zero, exit zero
.22b1					_FIPShift:
.22b1	b5 6f		lda $6f,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22b3	10 07		bpl $22bc			bpl 	_FIPCheckZero
.22b5	20 80 26	jsr $2680			jsr 	FloatShiftRight 			; shift mantissa right
.22b8	f6 6f		inc $6f,x			inc 	NSExponent,x 				; bump exponent
.22ba	80 f5		bra $22b1			bra 	_FIPShift
.22bc					_FIPCheckZero:
.22bc	20 89 26	jsr $2689			jsr 	FloatIsZero 				; avoid -0 problem
.22bf	d0 03		bne $22c4			bne 	_FIPExit 					; set to zero if mantissa zero.
.22c1					_FIPZero:
.22c1	20 67 26	jsr $2667			jsr 	FloatSetZero
.22c4					_FIPExit:
.22c4	68		pla				pla
.22c5	60		rts				rts
.22c6					FloatIntegerPartDown:
.22c6	48		pha				pha
.22c7	5a		phy				phy
.22c8	b5 6f		lda $6f,x			lda 	NSExponent,x 				; is it integer already ?
.22ca	f0 36		beq $2302			beq 	_FIPExit 					; if so do nothing
.22cc	20 89 26	jsr $2689			jsr 	FloatIsZero 				; is it zero ?
.22cf	f0 2e		beq $22ff			beq 	_FIPZero 					; if so return zero.
.22d1	20 bc 23	jsr $23bc			jsr 	FloatNormalise 				; normalise
.22d4	f0 29		beq $22ff			beq 	_FIPZero 					; normalised to zero, exit zero
.22d6	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22d8					_FIPShift:
.22d8	b5 6f		lda $6f,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22da	10 0a		bpl $22e6			bpl 	_FIPCheckDown
.22dc	20 80 26	jsr $2680			jsr 	FloatShiftRight 			; shift mantissa right
.22df	90 01		bcc $22e2			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22e1	c8		iny				iny
.22e2					_FIPNoFrac:
.22e2	f6 6f		inc $6f,x			inc 	NSExponent,x 				; bump exponent
.22e4	80 f2		bra $22d8			bra 	_FIPShift
.22e6					_FIPCheckDown:
.22e6	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22e8	f0 10		beq $22fa			beq 	_FIPCheckZero
.22ea	34 33		bit $33,x			bit 	NSStatus,x 					; +ve
.22ec	10 0c		bpl $22fa			bpl 	_FIPCheckZero
.22ee	e8		inx				inx 								; -ve so round *down*.
.22ef	a9 01		lda #$01			lda 	#1
.22f1	20 69 26	jsr $2669			jsr 	FloatSetByte
.22f4	20 29 26	jsr $2629			jsr 	FloatNegate
.22f7	20 8b 20	jsr $208b			jsr 	FloatAdd
.22fa					_FIPCheckZero:
.22fa	20 89 26	jsr $2689			jsr 	FloatIsZero 				; avoid -0 problem
.22fd	d0 03		bne $2302			bne 	_FIPExit 					; set to zero if mantissa zero.
.22ff					_FIPZero:
.22ff	20 67 26	jsr $2667			jsr 	FloatSetZero
.2302					_FIPExit:
.2302	7a		ply				ply
.2303	68		pla				pla
.2304	60		rts				rts
.2305					FloatInt8Multiply:
.2305	5a		phy				phy
.2306	b5 3f		lda $3f,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2308	a8		tay				tay
.2309	74 3f		stz $3f,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.230b					_FI8MLoop:
.230b	98		tya				tya 								; shift right shifter right into carry
.230c	4a		lsr a				lsr 	a
.230d	a8		tay				tay
.230e	90 0d		bcc $231d			bcc 	_FI8MNoAdd
.2310	18		clc				clc
.2311	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2313	75 40		adc $40,x			adc 	NSMantissa0+1,x
.2315	95 3f		sta $3f,x			sta 	NSMantissa0,x
.2317	b5 4b		lda $4b,x			lda 	NSMantissa1,x
.2319	75 4c		adc $4c,x			adc 	NSMantissa1+1,x
.231b	95 4b		sta $4b,x			sta 	NSMantissa1,x
.231d					_FI8MNoAdd:
.231d	16 40		asl $40,x			asl 	NSMantissa0+1,x 			; shift adder left
.231f	36 4c		rol $4c,x			rol 	NSMantissa1+1,x
.2321	c0 00		cpy #$00			cpy 	#0
.2323	d0 e6		bne $230b			bne 	_FI8MLoop 					; until right shifter zero.
.2325	7a		ply				ply
.2326	60		rts				rts
.2327					FloatMultiply:
.2327	ca		dex				dex
.2328	b5 6f		lda $6f,x			lda 	NSExponent,x 				; can use optimised ?
.232a	15 70		ora $70,x			ora 	NSExponent+1,x
.232c	15 63		ora $63,x			ora 	NSMantissa3,x
.232e	15 64		ora $64,x			ora 	NSMantissa3+1,x
.2330	d0 21		bne $2353			bne 	_FMUseFloat
.2332	b5 33		lda $33,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2334	15 34		ora $34,x			ora 	NSStatus+1,x
.2336	29 80		and #$80			and 	#$80
.2338	15 63		ora $63,x			ora 	NSMantissa3,x
.233a	15 57		ora $57,x			ora 	NSMantissa2,x
.233c	15 4b		ora $4b,x			ora 	NSMantissa1,x
.233e	15 64		ora $64,x			ora 	NSMantissa3+1,x
.2340	15 58		ora $58,x			ora 	NSMantissa2+1,x
.2342	15 4c		ora $4c,x			ora 	NSMantissa1+1,x
.2344	d0 04		bne $234a			bne 	_FMInt32
.2346	20 05 23	jsr $2305			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2349	60		rts				rts
.234a					_FMInt32:
.234a	20 74 23	jsr $2374			jsr 	FloatMultiplyShort			; use the int32 one.
.234d	18		clc				clc 								; fix it up if gone out of range
.234e	75 6f		adc $6f,x			adc 	NSExponent,x
.2350	95 6f		sta $6f,x			sta 	NSExponent,x
.2352	60		rts				rts
.2353					_FMUseFloat:
.2353	20 bc 23	jsr $23bc			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2356	f0 18		beq $2370			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2358	e8		inx				inx
.2359	20 bc 23	jsr $23bc			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.235c	ca		dex				dex
.235d	c9 00		cmp #$00			cmp 	#0
.235f	f0 0c		beq $236d			beq 	_FDSetZero
.2361	20 74 23	jsr $2374			jsr 	FloatMultiplyShort 			; calculate the result.
.2364	75 6f		adc $6f,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2366	18		clc				clc
.2367	75 70		adc $70,x			adc 	NSExponent+1,x
.2369	95 6f		sta $6f,x			sta 	NSExponent,x
.236b	80 03		bra $2370			bra 	_FDExit
.236d					_FDSetZero:
.236d	20 67 26	jsr $2667			jsr 	FloatSetZero 				; return 0
.2370					_FDExit:
.2370	20 bc 23	jsr $23bc			jsr 	FloatNormalise 				; normalise the result
.2373	60		rts				rts
.2374					FloatMultiplyShort:
.2374	5a		phy				phy 								; save Y
.2375	20 4a 26	jsr $264a			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2378	20 63 26	jsr $2663			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.237b	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.237d					_I32MLoop:
.237d	b5 41		lda $41,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.237f	15 4d		ora $4d,x			ora 	NSMantissa1+2,x
.2381	15 59		ora $59,x			ora 	NSMantissa2+2,x
.2383	15 65		ora $65,x			ora 	NSMantissa3+2,x
.2385	f0 25		beq $23ac			beq 	_I32MExit 					; exit if zero
.2387	b5 41		lda $41,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2389	29 01		and #$01			and 	#1
.238b	f0 0d		beq $239a			beq 	_I32MNoAdd
.238d	20 f3 23	jsr $23f3			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.2390	b5 63		lda $63,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.2392	10 06		bpl $239a			bpl 	_I32MNoAdd
.2394					_I32ShiftRight:
.2394	20 80 26	jsr $2680			jsr 	FloatShiftRight 			; shift S[X] right
.2397	c8		iny				iny 								; increment shift count
.2398	80 09		bra $23a3			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.239a					_I32MNoAdd:
.239a	34 64		bit $64,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.239c	70 f6		bvs $2394			bvs 	_I32ShiftRight 				; instead.
.239e	e8		inx				inx
.239f	20 76 26	jsr $2676			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23a2	ca		dex				dex
.23a3					_I32MShiftUpper:
.23a3	e8		inx				inx 								; shift S[X+2] right
.23a4	e8		inx				inx
.23a5	20 80 26	jsr $2680			jsr 	FloatShiftRight
.23a8	ca		dex				dex
.23a9	ca		dex				dex
.23aa	80 d1		bra $237d			bra 	_I32MLoop 					; try again.
.23ac					_I32MExit:
.23ac	20 b2 23	jsr $23b2			jsr 	FloatCalculateSign
.23af	98		tya				tya 								; shift in A
.23b0	7a		ply				ply 								; restore Y and exit
.23b1	60		rts				rts
.23b2					FloatCalculateSign:
.23b2	b5 33		lda $33,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23b4	16 33		asl $33,x			asl 	NSStatus,x 					; shift result left
.23b6	55 34		eor $34,x			eor 	NSStatus+1,x
.23b8	0a		asl a				asl 	a 							; shift bit 7 into carry
.23b9	76 33		ror $33,x			ror 	NSStatus,x 					; shift right into status byte.
.23bb	60		rts				rts
.23bc					FloatNormalise:
.23bc	20 89 26	jsr $2689			jsr 	FloatIsZero 				; if zero exit
.23bf	d0 07		bne $23c8			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23c1	16 33		asl $33,x			asl 	NSStatus,x 					; clear the sign bit.
.23c3	76 33		ror $33,x			ror 	NSStatus,x 					; (no -0)
.23c5	a9 00		lda #$00			lda 	#0 							; set Z flag
.23c7	60		rts				rts
.23c8					_NSNormaliseOptimise:
.23c8	b5 63		lda $63,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23ca	d0 19		bne $23e5			bne 	_NSNormaliseLoop
.23cc	b5 57		lda $57,x			lda 	NSMantissa2,x 				; byte normalise
.23ce	30 15		bmi $23e5			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23d0	95 63		sta $63,x			sta 	NSMantissa3,x
.23d2	b5 4b		lda $4b,x			lda 	NSMantissa1,x
.23d4	95 57		sta $57,x			sta 	NSMantissa2,x
.23d6	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.23d8	95 4b		sta $4b,x			sta 	NSMantissa1,x
.23da	74 3f		stz $3f,x			stz 	NSMantissa0,x
.23dc	b5 6f		lda $6f,x			lda 	NSExponent,x
.23de	38		sec				sec
.23df	e9 08		sbc #$08			sbc 	#8
.23e1	95 6f		sta $6f,x			sta 	NSExponent,x
.23e3	80 e3		bra $23c8			bra 	_NSNormaliseOptimise
.23e5					_NSNormaliseLoop:
.23e5	34 63		bit $63,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23e7	70 07		bvs $23f0			bvs 	_NSNExit 					; exit if so with Z flag clear
.23e9	20 76 26	jsr $2676			jsr 	FloatShiftLeft 				; shift mantissa left
.23ec	d6 6f		dec $6f,x			dec 	NSExponent,x 				; adjust exponent
.23ee	80 f5		bra $23e5			bra 	_NSNormaliseLoop
.23f0					_NSNExit:
.23f0	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23f2	60		rts				rts
.23f3					FloatAddTopTwoStack:
.23f3	18		clc				clc
.23f4	b5 3f		lda $3f,x			lda		NSMantissa0,x
.23f6	75 40		adc $40,x			adc 		NSMantissa0+1,x
.23f8	95 3f		sta $3f,x			sta 	NSMantissa0,x
.23fa	b5 4b		lda $4b,x			lda		NSMantissa1,x
.23fc	75 4c		adc $4c,x			adc 		NSMantissa1+1,x
.23fe	95 4b		sta $4b,x			sta 	NSMantissa1,x
.2400	b5 57		lda $57,x			lda		NSMantissa2,x
.2402	75 58		adc $58,x			adc 		NSMantissa2+1,x
.2404	95 57		sta $57,x			sta 	NSMantissa2,x
.2406	b5 63		lda $63,x			lda		NSMantissa3,x
.2408	75 64		adc $64,x			adc 		NSMantissa3+1,x
.240a	95 63		sta $63,x			sta 	NSMantissa3,x
.240c	60		rts				rts
.240d					FloatSubTopTwoStack:
.240d	38		sec				sec
.240e	b5 3f		lda $3f,x			lda		NSMantissa0,x
.2410	f5 40		sbc $40,x			sbc 		NSMantissa0+1,x
.2412	95 3f		sta $3f,x			sta 	NSMantissa0,x
.2414	b5 4b		lda $4b,x			lda		NSMantissa1,x
.2416	f5 4c		sbc $4c,x			sbc 		NSMantissa1+1,x
.2418	95 4b		sta $4b,x			sta 	NSMantissa1,x
.241a	b5 57		lda $57,x			lda		NSMantissa2,x
.241c	f5 58		sbc $58,x			sbc 		NSMantissa2+1,x
.241e	95 57		sta $57,x			sta 	NSMantissa2,x
.2420	b5 63		lda $63,x			lda		NSMantissa3,x
.2422	f5 64		sbc $64,x			sbc 		NSMantissa3+1,x
.2424	95 63		sta $63,x			sta 	NSMantissa3,x
.2426	60		rts				rts
.2427					FloatInt32Add:
.2427	b5 33		lda $33,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2429	55 34		eor $34,x			eor 	NSStatus+1,x
.242b	30 04		bmi $2431			bmi 	_DiffSigns
.242d	20 f3 23	jsr $23f3			jsr		FloatAddTopTwoStack
.2430	60		rts				rts
.2431					_DiffSigns:
.2431	20 0d 24	jsr $240d			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2434	34 63		bit $63,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2436	10 07		bpl $243f			bpl 	_AddExit
.2438	b5 34		lda $34,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.243a	95 33		sta $33,x			sta 	NSStatus,x
.243c	20 30 26	jsr $2630			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.243f					_AddExit:
.243f	20 89 26	jsr $2689			jsr 	FloatIsZero 				; check for -0
.2442	d0 02		bne $2446			bne 	_AddNonZero
.2444	74 33		stz $33,x			stz 	NSStatus,x
.2446					_AddNonZero:
.2446	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2447					FloatEncodeStart:
.2447	38		sec				sec
.2448	80 01		bra $244b			bra 	FloatEncodeContinue+1
.244a					FloatEncodeContinue:
.244a	18		clc				clc
.244b					FloatEncode:
.244b	08		php				php 								; save reset flag.
.244c	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.244e	f0 15		beq $2465			beq 	_ENIsOkay
.2450	c9 30		cmp #$30			cmp 	#"0"
.2452	90 04		bcc $2458			bcc 	_ENBadNumber
.2454	c9 3a		cmp #$3a			cmp 	#"9"+1
.2456	90 0d		bcc $2465			bcc 	_ENIsOkay
.2458					_ENBadNumber:
.2458	28		plp				plp 								; throw saved reset
.2459	ad 37 05	lda $0537			lda 	encodeState 				; if in decimal mode, construct final number
.245c	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.245e	d0 03		bne $2463			bne 	_ENFail
.2460	4c dd 24	jmp $24dd			jmp 	_ENConstructFinal
.2463					_ENFail:
.2463	18		clc				clc 								; not allowed
.2464	60		rts				rts
.2465					_ENIsOkay:
.2465	28		plp				plp 								; are we restarting
.2466	90 15		bcc $247d			bcc 	_ENNoRestart
.2468					_ENStartEncode:
.2468	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.246a	f0 0c		beq $2478			beq 	_ENFirstDP
.246c	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.246e	20 69 26	jsr $2669			jsr 	FloatSetByte 				; in single byte mode.
.2471	a9 01		lda #$01			lda 	#ESTA_Low
.2473					_ENExitChange:
.2473	8d 37 05	sta $0537			sta 	encodeState 				; save new state
.2476	38		sec				sec
.2477	60		rts				rts
.2478					_ENFirstDP:
.2478	20 67 26	jsr $2667			jsr 	FloatSetZero 				; clear integer part
.247b	80 3c		bra $24b9			bra 	_ESTASwitchFloat			; go straight to float and exi
.247d					_ENNoRestart:
.247d	48		pha				pha 								; save digit or DP on stack.
.247e	ad 37 05	lda $0537			lda 	encodeState 				; get current state
.2481	c9 01		cmp #$01			cmp 	#ESTA_Low
.2483	f0 09		beq $248e			beq  	_ESTALowState
.2485	c9 02		cmp #$02			cmp 	#ESTA_High
.2487	f0 26		beq $24af			beq 	_ESTAHighState
.2489	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.248b	f0 38		beq $24c5			beq 	_ESTADecimalState
>248d	db						.byte 	$DB 						; causes a break in the emulator
.248e					_ESTALowState:
.248e	68		pla				pla 								; get value back
.248f	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.2491	f0 26		beq $24b9			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.2493	29 0f		and #$0f			and 	#15 						; make digit
.2495	8d 38 05	sta $0538			sta 	digitTemp 					; save it.
.2498	b5 3f		lda $3f,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.249a	0a		asl a				asl 	a
.249b	0a		asl a				asl 	a
.249c	75 3f		adc $3f,x			adc 	NSMantissa0,x
.249e	0a		asl a				asl 	a
.249f	6d 38 05	adc $0538			adc 	digitTemp
.24a2	95 3f		sta $3f,x			sta 	NSMantissa0,x
.24a4	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24a6	90 05		bcc $24ad			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24a8	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24aa	8d 37 05	sta $0537			sta 	encodeState
.24ad					_ESTANoSwitch:
.24ad	38		sec				sec
.24ae	60		rts				rts
.24af					_ESTAHighState:
.24af	68		pla				pla 								; get value back
.24b0	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24b2	f0 05		beq $24b9			beq 	_ESTASwitchFloat
.24b4	20 0f 25	jsr $250f			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24b7	38		sec				sec
.24b8	60		rts				rts
.24b9					_ESTASwitchFloat:
.24b9	9c 39 05	stz $0539			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24bc	e8		inx				inx 								; zero the decimal additive.
.24bd	20 67 26	jsr $2667			jsr 	FloatSetZero
.24c0	ca		dex				dex
.24c1	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24c3	80 ae		bra $2473			bra 	_ENExitChange
.24c5					_ESTADecimalState:
.24c5	68		pla				pla 								; digit.
.24c6	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24c8	f0 99		beq $2463			beq 	_ENFail
.24ca	e8		inx				inx 								; put digit into fractional part of X+1
.24cb	20 0f 25	jsr $250f			jsr 	ESTAShiftDigitIntoMantissa
.24ce	ca		dex				dex
.24cf	ee 39 05	inc $0539			inc 	decimalCount 				; bump the count of decimals
.24d2	ad 39 05	lda $0539			lda 	decimalCount 				; too many decimal digits.
.24d5	c9 0b		cmp #$0b			cmp 	#11
.24d7	f0 02		beq $24db			beq 	_ESTADSFail
.24d9	38		sec				sec
.24da	60		rts				rts
.24db					_ESTADSFail:
.24db	18		clc				clc
.24dc	60		rts				rts
.24dd					_ENConstructFinal:
.24dd	ad 39 05	lda $0539			lda 	decimalCount 				; get decimal count
.24e0	f0 2b		beq $250d			beq 	_ENCFExit 					; no decimals
.24e2	5a		phy				phy
.24e3	0a		asl a				asl 	a 							; x 4 and CLC
.24e4	0a		asl a				asl 	a
.24e5	6d 39 05	adc $0539			adc 	decimalCount
.24e8	a8		tay				tay
.24e9	b9 74 21	lda $2174,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24ec	95 41		sta $41,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24ee	b9 75 21	lda $2175,y			lda 	FloatScalarTable-5+1,y
.24f1	95 4d		sta $4d,x			sta 	NSMantissa1+2,x
.24f3	b9 76 21	lda $2176,y			lda 	FloatScalarTable-5+2,y
.24f6	95 59		sta $59,x			sta 	NSMantissa2+2,x
.24f8	b9 77 21	lda $2177,y			lda 	FloatScalarTable-5+3,y
.24fb	95 65		sta $65,x			sta 	NSMantissa3+2,x
.24fd	b9 78 21	lda $2178,y			lda 	FloatScalarTable-5+4,y
.2500	95 71		sta $71,x			sta 	NSExponent+2,x
.2502	74 35		stz $35,x			stz 	NSStatus+2,x 				; make +ve
.2504	e8		inx				inx 								; multiply decimal const by decimal scalar
.2505	e8		inx				inx
.2506	20 27 23	jsr $2327			jsr 	FloatMultiply
.2509	20 8b 20	jsr $208b			jsr 	FloatAdd 					; add to integer part.
.250c	7a		ply				ply
.250d					_ENCFExit:
.250d	18		clc				clc 								; reject the digit.
.250e	60		rts				rts
.250f					ESTAShiftDigitIntoMantissa:
.250f	29 0f		and #$0f			and 	#15 						; save digit
.2511	48		pha				pha
.2512	b5 63		lda $63,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2514	48		pha				pha
.2515	b5 57		lda $57,x			lda 	NSMantissa2,x
.2517	48		pha				pha
.2518	b5 4b		lda $4b,x			lda 	NSMantissa1,x
.251a	48		pha				pha
.251b	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.251d	48		pha				pha
.251e	20 76 26	jsr $2676			jsr 	FloatShiftLeft 				; x 2
.2521	20 76 26	jsr $2676			jsr 	FloatShiftLeft 				; x 4
.2524	18		clc				clc 								; pop mantissa and add
.2525	68		pla				pla
.2526	75 3f		adc $3f,x			adc 	NSMantissa0,x
.2528	95 3f		sta $3f,x			sta 	NSMantissa0,x
.252a	68		pla				pla
.252b	75 4b		adc $4b,x			adc 	NSMantissa1,x
.252d	95 4b		sta $4b,x			sta 	NSMantissa1,x
.252f	68		pla				pla
.2530	75 57		adc $57,x			adc 	NSMantissa2,x
.2532	95 57		sta $57,x			sta 	NSMantissa2,x
.2534	68		pla				pla
.2535	75 63		adc $63,x			adc 	NSMantissa3,x
.2537	95 63		sta $63,x			sta 	NSMantissa3,x 				; x 5
.2539	20 76 26	jsr $2676			jsr 	FloatShiftLeft 				; x 10
.253c	68		pla				pla 								; add digit
.253d	18		clc				clc
.253e	75 3f		adc $3f,x			adc 	NSMantissa0,x
.2540	95 3f		sta $3f,x			sta 	NSMantissa0,x
.2542	90 0a		bcc $254e			bcc 	_ESTASDExit
.2544	f6 4b		inc $4b,x			inc 	NSMantissa1,x
.2546	d0 06		bne $254e			bne 	_ESTASDExit
.2548	f6 57		inc $57,x			inc 	NSMantissa2,x
.254a	d0 02		bne $254e			bne 	_ESTASDExit
.254c	f6 63		inc $63,x			inc 	NSMantissa3,x
.254e					_ESTASDExit:
.254e	60		rts				rts
.0537					encodeState:
>0537							.fill 	1
.0538					digitTemp:
>0538							.fill 	1
.0539					decimalCount:
>0539							.fill 	1
.254f					FloatToString:
.254f	da		phx				phx
.2550	5a		phy				phy 								; save code position
.2551	8d 3a 05	sta $053a			sta 	decimalPlaces	 			; save number of DPs.
.2554	9c 3b 05	stz $053b			stz 	dbOffset 					; offset into decimal buffer = start.
.2557	b5 33		lda $33,x			lda 	NSStatus,x  				; is it -ve.
.2559	10 08		bpl $2563			bpl 	_CNTSNotNegative
.255b	29 7f		and #$7f			and 	#$7F 						; make +ve
.255d	95 33		sta $33,x			sta 	NSStatus,x
.255f	a9 2d		lda #$2d			lda 	#"-"
.2561	80 02		bra $2565			bra 	_CNTMain
.2563					_CNTSNotNegative:
.2563	a9 20		lda #$20			lda 	#" "
.2565					_CNTMain:
.2565	20 c7 25	jsr $25c7			jsr 	WriteDecimalBuffer
.2568	b5 6f		lda $6f,x			lda 	NSExponent,x 				; check if decimal
.256a	f0 0d		beq $2579			beq 	_CNTSNotFloat
.256c	e8		inx				inx 								; round up so we don't get too many 6.999999
.256d	a9 01		lda #$01			lda 	#1
.256f	20 69 26	jsr $2669			jsr 	FloatSetByte
.2572	b5 6e		lda $6e,x			lda		NSExponent-1,x
.2574	95 6f		sta $6f,x			sta 	NSExponent,x
.2576	20 8b 20	jsr $208b			jsr 	FloatAdd
.2579					_CNTSNotFloat:
.2579	20 a9 25	jsr $25a9			jsr 	MakePlusTwoString 			; do the integer part.
.257c	20 47 22	jsr $2247			jsr 	FloatFractionalPart 		; get the fractional part
.257f	20 bc 23	jsr $23bc			jsr 	FloatNormalise					; normalise , exit if zero
.2582	f0 22		beq $25a6			beq 	_CNTSExit
.2584	a9 2e		lda #$2e			lda 	#"."
.2586	20 c7 25	jsr $25c7			jsr 	WriteDecimalBuffer 			; write decimal place
.2589					_CNTSDecimal:
.2589	ce 3a 05	dec $053a			dec 	decimalPlaces 				; done all the decimals
.258c	30 18		bmi $25a6			bmi 	_CNTSExit
.258e	e8		inx				inx 								; x 10.0
.258f	a9 0a		lda #$0a			lda 	#10
.2591	20 69 26	jsr $2669			jsr 	FloatSetByte
.2594	20 27 23	jsr $2327			jsr 	FloatMultiply
.2597	20 a9 25	jsr $25a9			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.259a	20 47 22	jsr $2247			jsr 	FloatFractionalPart 		; get the fractional part
.259d	20 bc 23	jsr $23bc			jsr 	FloatNormalise 				; normalise it.
.25a0	b5 6f		lda $6f,x			lda 	NSExponent,x 				; gone to zero, exit.
.25a2	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25a4	b0 e3		bcs $2589			bcs 	_CNTSDecimal 				; keep going.
.25a6					_CNTSExit:
.25a6	7a		ply				ply
.25a7	fa		plx				plx
.25a8	60		rts				rts
.25a9					MakePlusTwoString:
.25a9	da		phx				phx
.25aa	20 4a 26	jsr $264a			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25ad	e8		inx				inx 								; access it
.25ae	e8		inx				inx
.25af	20 a2 22	jsr $22a2			jsr 	FloatIntegerPart 			; make it an integer
.25b2	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25b4	20 e6 25	jsr $25e6			jsr 	ConvertInt32
.25b7	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25b9					_MPTSCopy:
.25b9	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25bc	20 c7 25	jsr $25c7			jsr 	WriteDecimalBuffer
.25bf	e8		inx				inx
.25c0	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25c3	d0 f4		bne $25b9			bne 	_MPTSCopy
.25c5	fa		plx				plx
.25c6	60		rts				rts
.25c7					WriteDecimalBuffer:
.25c7	da		phx				phx
.25c8	ae 3b 05	ldx $053b			ldx 	dbOffset
.25cb	9d 3c 05	sta $053c,x			sta 	decimalBuffer,x
.25ce	9e 3d 05	stz $053d,x			stz 	decimalBuffer+1,x
.25d1	ee 3b 05	inc $053b			inc 	dbOffset
.25d4	fa		plx				plx
.25d5	60		rts				rts
.053a					decimalPlaces:
>053a							.fill 	1
.053b					dbOffset:
>053b							.fill 	1
.053c					decimalBuffer:
>053c							.fill 	32
.25d6					ConvertInt16:
.25d6	85 3f		sta $3f				sta 	NSMantissa0 				; set up as 32 bit conversion
.25d8	86 4b		stx $4b				stx 	NSMantissa1
.25da	64 57		stz $57				stz 	NSMantissa2
.25dc	64 63		stz $63				stz 	NSMantissa3
.25de	64 33		stz $33				stz 	NSStatus 					; positive integer
.25e0	a2 00		ldx #$00			ldx 	#0 							; stack level
.25e2	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25e4	80 00		bra $25e6			bra 	ConvertInt32
.25e6					ConvertInt32:
.25e6	5a		phy				phy
.25e7	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25e9	24 33		bit $33				bit 	NSStatus 					; output a - if not negative.
.25eb	10 08		bpl $25f5			bpl 	_CI32NotNeg
.25ed	48		pha				pha
.25ee	a9 2d		lda #$2d			lda 	#'-'
.25f0	99 15 05	sta $0515,y			sta 	numberBuffer,y
.25f3	c8		iny				iny
.25f4	68		pla				pla
.25f5					_CI32NotNeg:
.25f5	20 03 26	jsr $2603			jsr 	_CI32DivideConvert 			; recursive conversion
.25f8	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.25fa	99 15 05	sta $0515,y			sta 	numberBuffer,y
.25fd	7a		ply				ply
.25fe	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.2600	a9 15		lda #$15			lda 	#numberBuffer & $FF
.2602	60		rts				rts
.2603					_CI32DivideConvert:
.2603	e8		inx				inx 								; write to next slot up
.2604	20 69 26	jsr $2669			jsr 	FloatSetByte 		 		; write the base out.
.2607	ca		dex				dex
.2608	20 fd 21	jsr $21fd			jsr 	Int32Divide 				; divide
.260b	b5 3f		lda $3f,x			lda 	NSMantissa0,x 				; save remainder
.260d	48		pha				pha
.260e	20 ec 21	jsr $21ec			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2611	20 89 26	jsr $2689			jsr 	FloatIsZero 				; is it zero ?
.2614	f0 05		beq $261b			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2616	b5 40		lda $40,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2618	20 03 26	jsr $2603			jsr 	_CI32DivideConvert 			; and recusrively call.
.261b					_CI32NoRecurse:
.261b	68		pla				pla 								; remainder
.261c	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.261e	90 02		bcc $2622			bcc 	_CI32NotHex
.2620	69 26		adc #$26			adc 	#6+32
.2622					_CI32NotHex:
.2622	69 30		adc #$30			adc 	#48
.2624	99 15 05	sta $0515,y			sta 	numberBuffer,y 				; write out and exit
.2627	c8		iny				iny
.2628	60		rts				rts
.2629					FloatNegate:
.2629	b5 33		lda $33,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.262b	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.262d	95 33		sta $33,x			sta 	NSStatus,x
.262f	60		rts				rts
.2630					FloatNegateMantissa:
.2630	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2631	a9 00		lda #$00			lda 	#0
.2633	f5 3f		sbc $3f,x			sbc 	NSMantissa0,x
.2635	95 3f		sta $3f,x			sta 	NSMantissa0,x
.2637	a9 00		lda #$00			lda 	#0
.2639	f5 4b		sbc $4b,x			sbc 	NSMantissa1,x
.263b	95 4b		sta $4b,x			sta 	NSMantissa1,x
.263d	a9 00		lda #$00			lda 	#0
.263f	f5 57		sbc $57,x			sbc 	NSMantissa2,x
.2641	95 57		sta $57,x			sta 	NSMantissa2,x
.2643	a9 00		lda #$00			lda 	#0
.2645	f5 63		sbc $63,x			sbc 	NSMantissa3,x
.2647	95 63		sta $63,x			sta 	NSMantissa3,x
.2649	60		rts				rts
.264a					FloatShiftUpTwo:
.264a	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.264c	95 41		sta $41,x			sta 	NSMantissa0+2,x
.264e	b5 4b		lda $4b,x			lda 	NSMantissa1,x
.2650	95 4d		sta $4d,x			sta 	NSMantissa1+2,x
.2652	b5 57		lda $57,x			lda 	NSMantissa2,x
.2654	95 59		sta $59,x			sta 	NSMantissa2+2,x
.2656	b5 63		lda $63,x			lda 	NSMantissa3,x
.2658	95 65		sta $65,x			sta 	NSMantissa3+2,x
.265a	b5 6f		lda $6f,x			lda 	NSExponent,x
.265c	95 71		sta $71,x			sta 	NSExponent+2,x
.265e	b5 33		lda $33,x			lda 	NSStatus,x
.2660	95 35		sta $35,x			sta 	NSStatus+2,x
.2662	60		rts				rts
.2663					FloatSetZeroMantissaOnly:
.2663	74 3f		stz $3f,x			stz 	NSMantissa0,x
.2665	80 08		bra $266f			bra 	FloatZero13
.2667					FloatSetZero:
.2667	a9 00		lda #$00			lda 	#0
.2669					FloatSetByte:
.2669	74 6f		stz $6f,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.266b					FloatSetMantissa:
.266b	95 3f		sta $3f,x			sta 	NSMantissa0,x 				; zero mantissa
.266d	74 33		stz $33,x			stz 	NSStatus,x
.266f					FloatZero13:
.266f	74 4b		stz $4b,x			stz 	NSMantissa1,x
.2671	74 57		stz $57,x			stz 	NSMantissa2,x
.2673	74 63		stz $63,x			stz 	NSMantissa3,x
.2675	60		rts				rts
.2676					FloatShiftLeft:
.2676	18		clc				clc
.2677					FloatRotateLeft:
.2677	36 3f		rol $3f,x			rol 	NSMantissa0,x
.2679	36 4b		rol $4b,x			rol		NSMantissa1,x
.267b	36 57		rol $57,x			rol		NSMantissa2,x
.267d	36 63		rol $63,x			rol		NSMantissa3,x
.267f	60		rts				rts
.2680					FloatShiftRight:
.2680	56 63		lsr $63,x			lsr 	NSMantissa3,x
.2682	76 57		ror $57,x			ror		NSMantissa2,x
.2684	76 4b		ror $4b,x			ror		NSMantissa1,x
.2686	76 3f		ror $3f,x			ror		NSMantissa0,x
.2688	60		rts				rts
.2689					FloatIsZero:
.2689	b5 63		lda $63,x			lda 	NSMantissa3,x
.268b	15 57		ora $57,x			ora		NSMantissa2,x
.268d	15 4b		ora $4b,x			ora		NSMantissa1,x
.268f	15 3f		ora $3f,x			ora		NSMantissa0,x
.2691	60		rts				rts

;******  Processing input file: testing/testend.asm

.2692					EndProgram:
>2692	01 08 15 08 82 00 81 59				.binary "code/tokenised.dat"
>269a	b2 30 a4 32 39 3a 81 58 b2 30 a4 33 39 00 1e 08
>26aa	a0 00 82 58 2c 59 00 2a 08 c8 00 81 20 42 b2 31
>26ba	a4 4e 00 31 08 22 01 82 42 00 3b 08 2c 01 89 20
>26ca	32 30 30 00 00 00

;******  End of listing
