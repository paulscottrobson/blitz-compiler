
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Sat Oct  7 13:21:41 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.1000					WrapperBoot:
.1000	a2 0a		ldx #$0a			ldx 	#APIDesc & $FF
.1002	a0 10		ldy #$10			ldy 	#APIDesc >> 8
.1004	20 49 11	jsr $1149			jsr 	StartCompiler
.1007	4c ff ff	jmp $ffff			jmp 	$FFFF
.100a					APIDesc:
>100a							.fill 	2
>100c	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>100d	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing file: testing/api/close.asm

.100e					APIOClose:
.100e	a9 40		lda #$40			lda 	#(PCodeStart >> 8)
.1010	a6 28		ldx $28				ldx 	objPtr
.1012	a4 29		ldy $29				ldy 	objPtr+1
.1014	20 5c 10	jsr $105c			jsr 	APISaveMemory
.1017	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/fromram.asm

.1018					APIIOpen:
.1018	a9 84		lda #$84			lda 	#((EndProgram+2) & $FF)
.101a	85 22		sta $22				sta 	0+srcInputPtr
.101c	a9 26		lda #$26			lda 	#((EndProgram+2) >> 8) & $FF
.101e	85 23		sta $23				sta 	1+srcInputPtr
.1020					APIIClose:
.1020	60		rts				rts
.0022					srcInputPtr:
>0022							.fill 	2

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/line.asm

.1021					ReadNextLine:
.1021	b2 22		lda ($22)			lda 	(srcInputPtr) 				; reached the end of the program (address link = $0000)
.1023	a0 01		ldy #$01			ldy 	#1
.1025	11 22		ora ($22),y			ora 	(srcInputPtr),y
.1027	d0 02		bne $102b			bne 	_RLAHaveData
.1029	18		clc				clc
.102a	60		rts				rts									; end of file.
.102b					_RLAHaveData:
.102b	a6 22		ldx $22				ldx 	srcInputPtr 				; remember the line start
.102d	a4 23		ldy $23				ldy 	srcInputPtr+1
.102f	5a		phy				phy
.1030	a0 04		ldy #$04			ldy 	#4 							; must be at least four bytes (address/line#)
.1032					_RNLRead:
.1032	b1 22		lda ($22),y			lda 	(srcInputPtr),y 			; find the end of the line.
.1034	c8		iny				iny
.1035	c9 00		cmp #$00			cmp 	#0
.1037	d0 f9		bne $1032			bne 	_RNLRead
.1039	98		tya				tya 								; advance src input pointer to next.
.103a	18		clc				clc
.103b	65 22		adc $22				adc 	srcInputPtr
.103d	85 22		sta $22				sta 	srcInputPtr
.103f	90 02		bcc $1043			bcc 	_RNLNoCarry
.1041	e6 23		inc $23				inc 	srcInputPtr+1
.1043					_RNLNoCarry:
.1043	7a		ply				ply 								; address of line now in YX.
.1044	38		sec				sec
.1045	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/open.asm

.1046					APIOOpen:
.1046					APIORewind:
.1046	a9 00		lda #$00			lda 	#((PCodeStart) & $FF)
.1048	85 28		sta $28				sta 	0+objPtr
.104a	a9 40		lda #$40			lda 	#((PCodeStart) >> 8) & $FF
.104c	85 29		sta $29				sta 	1+objPtr
.104e	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/writebyte.asm

.104f					APIOWriteByte:
.104f	92 28		sta ($28)			sta 	(objPtr)
.1051	e6 28		inc $28				inc 	objPtr
.1053	d0 02		bne $1057			bne 	_HWOWBNoCarry
.1055	e6 29		inc $29				inc 	objPtr+1
.1057					_HWOWBNoCarry:
.1057	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_config.inc

=$4000					PCodeStart = $4000

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_printchar.asm

.1058					APIOPrintCharacter
.1058	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.105b	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_save.asm

.105c					APISaveMemory:
.105c	da		phx				phx
.105d	5a		phy				phy
.105e	48		pha				pha
.105f	a9 00		lda #$00			lda 	#0 							; set LFS
.1061	a2 08		ldx #$08			ldx 	#8
.1063	a0 00		ldy #$00			ldy 	#0
.1065	20 ba ff	jsr $ffba			jsr 	$FFBA
.1068	a9 08		lda #$08			lda 	#8 							; set file name
.106a	a2 7e		ldx #$7e			ldx 	#SaveName & $FF
.106c	a0 10		ldy #$10			ldy 	#SaveName >> 8
.106e	20 bd ff	jsr $ffbd			jsr 	$FFBD
.1071	68		pla				pla 								; set up the start address.
.1072	85 2b		sta $2b				sta 	zTemp0+1
.1074	64 2a		stz $2a				stz 	zTemp0
.1076	a9 2a		lda #$2a			lda 	#zTemp0 					; from index.
.1078	7a		ply				ply 								; end in YX
.1079	fa		plx				plx
.107a	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.107d	60		rts				rts
.107e					SaveName:
>107e	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Return to file: testing/testing.asm


;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READ = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.0024					srcPtr:
>0024							.fill 	2
.0400					currentLineNumber:
>0400							.fill 	2
.1086					InlineNonDecimal:
.1086	a2 02		ldx #$02			ldx 	#2 							; get size in X
.1088	c9 25		cmp #$25			cmp 	#"%"
.108a	f0 02		beq $108e			beq 	_INDBinary
.108c	a2 10		ldx #$10			ldx 	#16
.108e					_INDBinary:
.108e	85 2c		sta $2c				sta 	zTemp1 						; size => zTemp1
.1090	64 2d		stz $2d				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.1092	64 2a		stz $2a				stz 	zTemp0 						; zero result
.1094	64 2b		stz $2b				stz 	zTemp0+1
.1096					_INDLoop:
.1096	20 16 1a	jsr $1a16			jsr 	LookNext 					; check next character
.1099	20 52 1a	jsr $1a52			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.109c	90 1f		bcc $10bd			bcc		_INDDone 					; didn't convert
.109e	c5 2c		cmp $2c				cmp 	zTemp1 						; size too large ?
.10a0	b0 1b		bcs $10bd			bcs 	_INDDone
.10a2	20 cc 10	jsr $10cc			jsr 	_INDShift 					; x 2 or x 16
.10a5	e0 02		cpx #$02			cpx 	#2
.10a7	f0 09		beq $10b2			beq 	_INDNotHex
.10a9	20 cc 10	jsr $10cc			jsr 	_INDShift
.10ac	20 cc 10	jsr $10cc			jsr 	_INDShift
.10af	20 cc 10	jsr $10cc			jsr 	_INDShift
.10b2					_INDNotHex:
.10b2	05 2a		ora $2a				ora 	zTemp0 						; or digit into result
.10b4	85 2a		sta $2a				sta 	zTemp0
.10b6	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume
.10b9	e6 2d		inc $2d				inc 	zTemp1+1 					; bump count
.10bb	80 d9		bra $1096			bra 	_INDLoop
.10bd					_INDDone:
.10bd	a5 2d		lda $2d				lda 	zTemp1+1 					; done at least 1 ?
.10bf	f0 08		beq $10c9			beq 	_INDError
.10c1	a4 2b		ldy $2b				ldy 	zTemp0+1 					; push constant
.10c3	a5 2a		lda $2a				lda 	zTemp0
.10c5	20 d6 11	jsr $11d6			jsr 	PushIntegerYA
.10c8	60		rts				rts
.10c9					_INDError:
.10c9	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.10cc					_INDShift:
.10cc	06 2a		asl $2a				asl 	zTemp0
.10ce	26 2b		rol $2b				rol 	zTemp0+1
.10d0	60		rts				rts
.10d1					GetLineNumber:
.10d1	ac 01 04	ldy $0401			ldy 	currentLineNumber+1
.10d4	ad 00 04	lda $0400			lda 	currentLineNumber
.10d7	60		rts				rts
.10d8					WriteCodeByte:
.10d8	48		pha				pha 								; save on stack
.10d9	da		phx				phx
.10da	5a		phy				phy
.10db	20 4f 10	jsr $104f			jsr 	APIOWriteByte
.10de	7a		ply				ply 								; restore from stack
.10df	fa		plx				plx
.10e0	68		pla				pla
.10e1	60		rts				rts
.10e2					PrintCharacter
.10e2	48		pha				pha
.10e3	da		phx				phx
.10e4	5a		phy				phy
.10e5	20 58 10	jsr $1058			jsr 	APIOPrintCharacter
.10e8	7a		ply				ply
.10e9	fa		plx				plx
.10ea	68		pla				pla
.10eb	60		rts				rts
.10ec					ProcessNewLine:
.10ec	86 2a		stx $2a				stx 	zTemp0 						; save address in zTemp0
.10ee	84 2b		sty $2b				sty 	zTemp0+1
.10f0	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.10f1	8a		txa				txa
.10f2	69 04		adc #$04			adc 	#4
.10f4	85 24		sta $24				sta 	srcPtr
.10f6	98		tya				tya
.10f7	69 00		adc #$00			adc 	#0
.10f9	85 25		sta $25				sta 	srcPtr+1
.10fb	a0 02		ldy #$02			ldy 	#2							; read and save line number
.10fd	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.10ff	8d 00 04	sta $0400			sta 	currentLineNumber
.1102	c8		iny				iny
.1103	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1105	8d 01 04	sta $0401			sta 	currentLineNumber+1
.1108	60		rts				rts
.1109					BufferClear:
.1109	9c 02 04	stz $0402			stz 	bufferSize
.110c	60		rts				rts
.110d					BufferWrite:
.110d	da		phx				phx
.110e	ae 02 04	ldx $0402			ldx 	bufferSize
.1111	9d 03 04	sta $0403,x			sta 	dataBuffer,x
.1114	ee 02 04	inc $0402			inc 	bufferSize
.1117	fa		plx				plx
.1118	60		rts				rts
.1119					BufferOutput:
.1119	ad 02 04	lda $0402			lda 	bufferSize
.111c	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.111f	a2 00		ldx #$00			ldx 	#0
.1121					_BOLoop:
.1121	ec 02 04	cpx $0402			cpx 	bufferSize
.1124	f0 09		beq $112f			beq 	_BOExit
.1126	bd 03 04	lda $0403,x			lda 	dataBuffer,x
.1129	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.112c	e8		inx				inx
.112d	80 f2		bra $1121			bra 	_BOLoop
.112f					_BOExit:
.112f	60		rts				rts
.0402					bufferSize:
>0402							.fill 	1
.0403					dataBuffer:
>0403							.fill 	256
.1130					CheckNextComma:
.1130	a9 2c		lda #$2c			lda	 	#","
.1132	80 06		bra $113a			bra 	CheckNextA
.1134					CheckNextRParen:
.1134	a9 29		lda #$29			lda	 	#")"
.1136	80 02		bra $113a			bra 	CheckNextA
.1138					CheckNextLParen:
.1138	a9 28		lda #$28			lda 	#"("
.113a					CheckNextA:
.113a	8d 03 05	sta $0503			sta 	checkCharacter 				; save test character
.113d					_CNALoop:
.113d	20 32 1a	jsr $1a32			jsr 	GetNextNonSpace 			; get next skipping spaces.
.1140	cd 03 05	cmp $0503			cmp 	checkCharacter 				; matches ?
.1143	f0 03		beq $1148			beq 	_CNAExit
.1145	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.1148					_CNAExit:
.1148	60		rts				rts
.0503					checkCharacter:
>0503							.fill 	1
.1149					StartCompiler:
.1149	86 2a		stx $2a				stx 	zTemp0 						; access API
.114b	84 2b		sty $2b				sty 	zTemp0+1
.114d	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.114f	b2 2a		lda ($2a)			lda 	(zTemp0)
.1151	8d 05 05	sta $0505			sta 	APIVector
.1154	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1156	8d 06 05	sta $0506			sta 	APIVector+1
.1159	c8		iny				iny 								; copy data area range.
.115a	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.115c	8d 07 05	sta $0507			sta 	compilerStartHigh
.115f	c8		iny				iny
.1160	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1162	8d 08 05	sta $0508			sta 	compilerEndHigh
.1165	ba		tsx				tsx 								; save stack pointer
.1166	8e 04 05	stx $0504			stx 	compilerSP
.1169	20 b6 1d	jsr $1db6			jsr 	STRReset 					; reset storage (line#, variable)
.116c	20 18 10	jsr $1018			jsr 	APIIOpen 					; reset data input
.116f	20 46 10	jsr $1046			jsr 	APIOOpen 					; reset data output.
.1172	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.1174	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1177	a9 00		lda #$00			lda 	#0
.1179	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.117c	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.117f					MainCompileLoop:
.117f	20 21 10	jsr $1021			jsr 	ReadNextLine 				; read next line into the buffer.
.1182	90 31		bcc $11b5			bcc 	SaveCodeAndExit 			; end of source.
.1184	20 ec 10	jsr $10ec			jsr 	ProcessNewLine 				; set up pointer and line number.
.1187	20 d1 10	jsr $10d1			jsr 	GetLineNumber 				; get line #
.118a	20 a0 1b	jsr $1ba0			jsr 	STRMarkLine 				; remember the code position and number of this line.
.118d	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.118f	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1192					_MCLSameLine:
.1192	20 32 1a	jsr $1a32			jsr 	GetNextNonSpace 			; get the first character.
.1195	f0 e8		beq $117f			beq 	MainCompileLoop 			; end of line, get next line.
.1197	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.1199	f0 f7		beq $1192			beq 	_MCLSameLine
.119b	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.119d	10 0c		bpl $11ab			bpl 	_MCLCheckAssignment
.119f	a2 f3		ldx #$f3			ldx 	#CommandTables & $FF 		; do command tables.
.11a1	a0 15		ldy #$15			ldy 	#CommandTables >> 8
.11a3	20 bb 18	jsr $18bb			jsr 	GeneratorProcess
.11a6	b0 ea		bcs $1192			bcs 	_MCLSameLine 				; keep trying to compile the line.
.11a8					_MCLSyntax:
.11a8	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.11ab					_MCLCheckAssignment:
.11ab	20 48 1a	jsr $1a48			jsr 	CharIsAlpha 				; if not alpha then syntax error
.11ae	90 f8		bcc $11a8			bcc 	_MCLSyntax
.11b0	20 6e 1b	jsr $1b6e			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.11b3	80 dd		bra $1192			bra		_MCLSameLine 				; loop back.
.11b5					SaveCodeAndExit:
.11b5	20 20 10	jsr $1020			jsr 	APIIClose 					; finish input.
.11b8	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.11ba	a8		tay				tay
.11bb	20 a0 1b	jsr $1ba0			jsr 	STRMarkLine
.11be	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.11c0	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.11c3	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.11c5	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.11c8	20 ed 14	jsr $14ed			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.11cb	20 0e 10	jsr $100e			jsr 	APIOClose
.11ce					ExitCompiler:
.11ce	ae 04 05	ldx $0504			ldx 	compilerSP 					; reload SP and exit.
.11d1	9a		txs				txs
.11d2	60		rts				rts
.11d3					CallAPIHandler:
.11d3	6c 05 05	jmp ($0505)			jmp 	(APIVector)
.0504					compilerSP:
>0504							.fill 	1
.0505					APIVector:
>0505							.fill 	2
.0507					compilerStartHigh:
>0507							.fill 	1
.0508					compilerEndHigh:
>0508							.fill 	1
.11d6					PushIntegerYA:
.11d6	c0 00		cpy #$00			cpy 	#0 							; 0-255
.11d8	f0 0f		beq $11e9			beq 	PushIntegerA
.11da	48		pha				pha
.11db	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.11dd	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.11e0	68		pla				pla 								; then LSB
.11e1	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.11e4	98		tya				tya 								; then MSB
.11e5	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.11e8	60		rts				rts
.11e9					PushIntegerA:
.11e9	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.11eb	90 07		bcc $11f4			bcc 	_PIWriteA
.11ed	48		pha				pha
.11ee	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.11f0	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.11f3	68		pla				pla
.11f4					_PIWriteA:
.11f4	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.11f7	60		rts				rts
.11f8					PushFloat:
.11f8	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.11fa	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.11fd	b5 6c		lda $6c,x			lda 	NSExponent,x 				; and the data
.11ff	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1202	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1204	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1207	b5 48		lda $48,x			lda 	NSMantissa1,x
.1209	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.120c	b5 54		lda $54,x			lda 	NSMantissa2,x
.120e	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1211	b5 30		lda $30,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.1213	29 80		and #$80			and 	#$80
.1215	15 60		ora $60,x			ora 	NSMantissa3,x
.1217	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.121a	60		rts				rts
.121b					CreateVariableRecord:
.121b	48		pha				pha
.121c	ad 13 05	lda $0513			lda 	freeVariableMemory 		; push current free address on stack.
.121f	48		pha				pha
.1220	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1223	48		pha				pha
.1224	ad 11 05	lda $0511			lda 	variableListEnd  		; copy end of list to zTemp0
.1227	85 2a		sta $2a				sta 	zTemp0
.1229	ad 12 05	lda $0512			lda 	variableListEnd+1
.122c	85 2b		sta $2b				sta 	zTemp0+1
.122e	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.1230	92 2a		sta ($2a)			sta 	(zTemp0)
.1232	98		tya				tya
.1233	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.1235	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1237	88		dey				dey
.1238	8a		txa				txa
.1239	91 2a		sta ($2a),y			sta 	(zTemp0),y
.123b	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.123d	ad 13 05	lda $0513			lda 	freeVariableMemory
.1240	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1242	c8		iny				iny
.1243	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1246	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1248	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.124a	a9 00		lda #$00			lda 	#0
.124c	91 2a		sta ($2a),y			sta 	(zTemp0),y
.124e	18		clc				clc
.124f	b2 2a		lda ($2a)			lda 	(zTemp0) 				; add offset to variableListEnd
.1251	6d 11 05	adc $0511			adc  	variableListEnd
.1254	8d 11 05	sta $0511			sta 	variableListEnd
.1257	90 03		bcc $125c			bcc 	_CVNoCarry2
.1259	ee 12 05	inc $0512			inc 	variableListEnd+1
.125c					_CVNoCarry2:
.125c	7a		ply				ply
.125d	fa		plx				plx
.125e	68		pla				pla
.125f	60		rts				rts
.1260					SetVariableRecordToCodePosition:
.1260	48		pha				pha
.1261	5a		phy				phy
.1262	a0 03		ldy #$03			ldy 	#3
.1264	a5 29		lda $29				lda 	objPtr+1
.1266	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1268	c8		iny				iny
.1269	a5 28		lda $28				lda 	objPtr
.126b	91 2a		sta ($2a),y			sta 	(zTemp0),y
.126d	7a		ply				ply
.126e	68		pla				pla
.126f	60		rts				rts
.1270					AllocateBytesForType:
.1270	48		pha				pha
.1271	da		phx				phx
.1272	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.1274	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1276	c9 00		cmp #$00			cmp 	#NSSIFloat
.1278	d0 02		bne $127c			bne 	_CVNotFloat
.127a	a2 06		ldx #$06			ldx 	#6
.127c					_CVNotFloat:
.127c	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.127d	18		clc				clc
.127e	6d 13 05	adc $0513			adc 	freeVariableMemory
.1281	8d 13 05	sta $0513			sta 	freeVariableMemory
.1284	90 03		bcc $1289			bcc 	_CVNoCarry1
.1286	ee 14 05	inc $0514			inc 	freeVariableMemory+1
.1289					_CVNoCarry1:
.1289	fa		plx				plx
.128a	68		pla				pla
.128b	60		rts				rts
.128c					CommandDATA:
.128c	20 09 11	jsr $1109			jsr 	BufferClear 				; copy it to the buffer
.128f	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace
.1292					_CTDataLoop:
.1292	20 16 1a	jsr $1a16			jsr 	LookNext 					; reached EOL
.1295	f0 08		beq $129f			beq 	_CTDataDone
.1297	20 0d 11	jsr $110d			jsr 	BufferWrite 				; write and consume
.129a	20 27 1a	jsr $1a27			jsr 	GetNext
.129d	80 f3		bra $1292			bra 	_CTDataLoop
.129f					_CTDataDone:
.129f	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.12a1	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.12a4	20 19 11	jsr $1119			jsr 	BufferOutput
.12a7	60		rts				rts
.12a8					CommandDEF:
.12a8	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.12aa	20 e9 11	jsr $11e9			jsr 	PushIntegerA
.12ad	20 37 1b	jsr $1b37			jsr 	CompileGotoEOL 				; compile skip over DEF
.12b0	a9 a5		lda #$a5			lda 	#C64_FN
.12b2	20 3a 11	jsr $113a			jsr 	CheckNextA
.12b5	20 32 1a	jsr $1a32			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.12b8	20 97 1a	jsr $1a97			jsr 	ExtractVariableName
.12bb	8a		txa				txa
.12bc	10 51		bpl $130f			bpl 	_CDError
.12be	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.12bf	29 7f		and #$7f			and 	#$7F
.12c1	aa		tax				tax
.12c2	98		tya				tya
.12c3	09 80		ora #$80			ora 	#$80
.12c5	a8		tay				tay
.12c6	20 91 14	jsr $1491			jsr 	FindVariable				; does it already exist ?
.12c9	b0 44		bcs $130f			bcs 	_CDError 					; if so, that's an error.
.12cb	20 1b 12	jsr $121b			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.12ce	20 60 12	jsr $1260			jsr 	SetVariableRecordToCodePosition
.12d1	20 32 1a	jsr $1a32			jsr 	GetNextNonSpace
.12d4	20 73 1d	jsr $1d73			jsr 	GetReferenceTerm 			; get var ref, not array
.12d7	c9 00		cmp #$00			cmp 	#0
.12d9	30 34		bmi $130f			bmi 	_CDError
.12db	8d 09 05	sta $0509			sta 	defType 					; save type
.12de	8e 0a 05	stx $050a			stx 	defVariable 				; save var ref
.12e1	8c 0b 05	sty $050b			sty 	defVariable+1
.12e4	29 40		and #$40			and 	#NSSString 					; only numbers.
.12e6	d0 27		bne $130f			bne 	_CDError
.12e8	20 34 11	jsr $1134			jsr 	CheckNextRParen 			; check )
.12eb	a9 b2		lda #$b2			lda 	#C64_EQUAL
.12ed	20 3a 11	jsr $113a			jsr 	CheckNextA 					; check =
.12f0	18		clc				clc 								; if this is DEF FNxx(A), read A
.12f1	20 12 13	jsr $1312			jsr 	CDReadWriteVariable
.12f4	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.12f6	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.12f9	38		sec				sec
.12fa	20 12 13	jsr $1312			jsr 	CDReadWriteVariable 		; A is now updated
.12fd	20 d7 13	jsr $13d7			jsr 	CompileExpressionAt0 		; the actual body of the function.
.1300	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1302	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1305	38		sec				sec
.1306	20 12 13	jsr $1312			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.1309	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.130b	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.130e	60		rts				rts
.130f					_CDError:
.130f	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.1312					CDReadWriteVariable:
.1312	ac 0b 05	ldy $050b			ldy 	defVariable+1 				; set up YX
.1315	ae 0a 05	ldx $050a			ldx 	defVariable
.1318	ad 09 05	lda $0509			lda 	defType
.131b	20 25 1d	jsr $1d25			jsr 	GetSetVariable
.131e	60		rts				rts
.0509					defType:
>0509							.fill 	1
.050a					defVariable:
>050a							.fill 	2
.131f					CommandDIM:
.131f	20 32 1a	jsr $1a32			jsr 	GetNextNonSpace 			; get the first non space character
.1322	20 97 1a	jsr $1a97			jsr 	ExtractVariableName 		; variable name to XY
.1325	da		phx				phx 								; save name with type bits.
.1326	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.1328	10 37		bpl $1361			bpl 	_CDError
.132a	20 91 14	jsr $1491			jsr 	FindVariable	 			; see if already exist
.132d	b0 35		bcs $1364			bcs 	_CDRedefine 				; it still exists.
.132f	20 1b 12	jsr $121b			jsr 	CreateVariableRecord 		; create the basic variable
.1332	20 70 12	jsr $1270			jsr 	AllocateBytesForType 		; allocate memory for it
.1335	68		pla				pla 								; restore type bits
.1336	5a		phy				phy 								; save the address of the basic storage
.1337	da		phx				phx
.1338	48		pha				pha
.1339	20 67 13	jsr $1367			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.133c	68		pla				pla
.133d	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.133f	20 e9 11	jsr $11e9			jsr 	PushIntegerA 				; push that type data out.
.1342	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.1344	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1347	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.1349	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.134c	fa		plx				plx 								; restore address
.134d	7a		ply				ply
.134e	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1350	38		sec				sec
.1351	20 25 1d	jsr $1d25			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.1354	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; , follows ?
.1357	c9 2c		cmp #$2c			cmp 	#","
.1359	d0 05		bne $1360			bne 	_CDExit
.135b	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume comma
.135e	80 bf		bra $131f			bra 	CommandDIM 					; do another DIM
.1360					_CDExit:
.1360	60		rts				rts
.1361					_CDError:
.1361	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.1364					_CDRedefine:
.1364	4c d9 1f	jmp $1fd9		jmp	ErrorV_redefine
.1367					OutputIndexGroup:
.1367	9c 0c 05	stz $050c			stz 	IndexCount 					; count of number of indices.
.136a					_OIGNext:
.136a	20 d7 13	jsr $13d7			jsr 	CompileExpressionAt0 		; get a dimension
.136d	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.136f	c9 00		cmp #$00			cmp 	#NSSIFloat
.1371	d0 19		bne $138c			bne 	_OIGType
.1373	ee 0c 05	inc $050c			inc 	IndexCount 					; bump the counter.
.1376	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; does a , follow ?
.1379	c9 2c		cmp #$2c			cmp 	#","
.137b	d0 05		bne $1382			bne 	_OIGCheckEnd
.137d	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume comma
.1380	80 e8		bra $136a			bra 	_OIGNext 					; get next dimension
.1382					_OIGCheckEnd:
.1382	20 34 11	jsr $1134			jsr 	CheckNextRParen 			; check and consume )
.1385	ad 0c 05	lda $050c			lda 	IndexCount
.1388	20 e9 11	jsr $11e9			jsr 	PushIntegerA 				; compile the dimension count.
.138b	60		rts				rts
.138c					_OIGType:
.138c	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.050c					IndexCount:
>050c							.fill 	1
.138f					ErrorHandler:
.138f	68		pla				pla
.1390	7a		ply				ply
.1391	85 2a		sta $2a				sta 	zTemp0
.1393	84 2b		sty $2b				sty 	zTemp0+1
.1395	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.1397	a0 01		ldy #$01			ldy 	#1
.1399					_EHDisplayMsg:
.1399	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.139b	20 e2 10	jsr $10e2			jsr 	PrintCharacter
.139e	c8		iny				iny
.139f	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.13a1	d0 f6		bne $1399			bne 	_EHDisplayMsg
.13a3	a9 20		lda #$20			lda 	#32
.13a5	20 e2 10	jsr $10e2			jsr 	PrintCharacter
.13a8	a9 40		lda #$40			lda 	#64
.13aa	20 e2 10	jsr $10e2			jsr 	PrintCharacter
.13ad	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.13af	20 59 26	jsr $2659			jsr 	FloatSetByte
.13b2	20 d1 10	jsr $10d1			jsr 	GetLineNumber
.13b5	95 3c		sta $3c,x			sta 	NSMantissa0,x
.13b7	98		tya				tya
.13b8	95 48		sta $48,x			sta 	NSMantissa1,x
.13ba	20 3f 25	jsr $253f			jsr 	FloatToString
.13bd	a0 00		ldy #$00			ldy 	#0 							; display that string.
.13bf	a2 00		ldx #$00			ldx 	#0
.13c1					_EHDisplayLine:
.13c1	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13c4	20 e2 10	jsr $10e2			jsr 	PrintCharacter
.13c7	c8		iny				iny
.13c8	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13cb	d0 f4		bne $13c1			bne 	_EHDisplayLine
.13cd	a9 0d		lda #$0d			lda 	#13
.13cf	20 e2 10	jsr $10e2			jsr 	PrintCharacter
.13d2	80 fe		bra $13d2	_EHHalt:bra 	_EHHalt
.13d4	4c ce 11	jmp $11ce			jmp 	ExitCompiler
.13d7					CompileExpressionAt0:
.13d7	a9 00		lda #$00			lda 	#0
.13d9					CompileExpressionAtA:
.13d9	48		pha				pha  								; save level
.13da	20 de 1d	jsr $1dde			jsr 	CompileTerm 				; compile a term.
.13dd	fa		plx				plx 								; get level back into X
.13de					_ECALoop:
.13de	48		pha				pha 								; save type on stack.
.13df	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; get the next character
.13e2	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.13e4	90 04		bcc $13ea			bcc 	_ECAExit
.13e6	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.13e8	90 02		bcc $13ec			bcc 	_ECAHaveToken
.13ea					_ECAExit:
.13ea	68		pla				pla 								; throw type off stack
.13eb	60		rts				rts
.13ec					_ECAHaveToken:
.13ec	86 2a		stx $2a				stx 	zTemp0 						; save current precedence in zTemp0
.13ee	aa		tax				tax 								; X contains the operator token
.13ef	bd da 13	lda $13da,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.13f2	c5 2a		cmp $2a				cmp 	zTemp0 						; if < then exit
.13f4	90 f4		bcc $13ea			bcc 	_ECAExit
.13f6	85 2b		sta $2b				sta 	zTemp0+1 					; save the precedence of the operator.
.13f8	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume the token.
.13fb	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.13fd	f0 11		beq $1410			beq 	_ECAGreaterCheck
.13ff	e0 b3		cpx #$b3			cpx 	#C64_LESS
.1401	d0 1a		bne $141d			bne 	_ECAHaveFullToken
.1403	20 16 1a	jsr $1a16			jsr 	LookNext 					; checks for < (<= or <>)
.1406	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.1408	f0 0e		beq $1418			beq	 	_ECAToNotEqual
.140a	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.140c	d0 0f		bne $141d			bne 	_ECAHaveFullToken
.140e	80 07		bra $1417			bra 	_ECAAddEqual
.1410					_ECAGreaterCheck:
.1410	20 16 1a	jsr $1a16			jsr 	LookNext
.1413	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.1415	d0 06		bne $141d			bne 	_ECAHaveFullToken
.1417					_ECAAddEqual:
.1417	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.1418					_ECAToNotEqual:
.1418	e8		inx				inx
.1419	e8		inx				inx
.141a	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume the = or > in >= <= <>
.141d					_ECAHaveFullToken:
.141d	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.141f	d0 0a		bne $142b			bne 	_ECANotConcat
.1421	68		pla				pla 								; get type back
.1422	48		pha				pha
.1423	29 40		and #$40			and 	#NSSTypeMask
.1425	c9 40		cmp #$40			cmp 	#NSSString
.1427	d0 02		bne $142b			bne 	_ECANotConcat
.1429	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.142b					_ECANotConcat:
.142b	da		phx				phx 								; save operator on the stack
.142c	a6 2a		ldx $2a				ldx 	zTemp0 						; push current precedence on the stack
.142e	da		phx				phx
.142f	a5 2b		lda $2b				lda 	zTemp0+1 					; get precedence of operator
.1431	1a		inc a				inc 	a
.1432	20 d9 13	jsr $13d9			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.1435	85 2a		sta $2a				sta 	zTemp0 						; save type in zTemp0
.1437	fa		plx				plx 								; restore current precedence in X
.1438	68		pla				pla 								; restore operator
.1439	85 2b		sta $2b				sta 	zTemp0+1 					; save it in zTemp0+1.
.143b	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.143d	90 17		bcc $1456			bcc 	_ECANotCompare
.143f	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.1441	b0 13		bcs $1456			bcs 	_ECANotCompare
.1443	7a		ply				ply 								; get type into Y
.1444	5a		phy				phy
.1445	48		pha				pha 								; save operator
.1446	98		tya				tya 								; get type
.1447	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.1449	29 40		and #$40			and 	#NSSTypeMask
.144b	c9 40		cmp #$40			cmp 	#NSSString
.144d	f0 02		beq $1451			beq 	_ECANotString
.144f	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.1451					_ECANotString:
.1451	98		tya				tya									; output token Y
.1452	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1455	68		pla				pla 								; restore operator.
.1456					_ECANotCompare:
.1456	18		clc				clc 								; convert to P-Code and compile.
.1457	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.1459	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.145c	68		pla				pla 								; type of current result
.145d	45 2a		eor $2a				eor 	zTemp0 						; check compatible with r-expr type
.145f	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.1461	d0 19		bne $147c			bne		_ECAType
.1463	a5 2a		lda $2a				lda 	zTemp0 						; get type back
.1465	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.1467	d0 18		bne $1481			bne 	_ECAGoLoop
.1469	a5 2b		lda $2b				lda 	zTemp0+1 					; check operator is + or comparator
.146b	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.146d	f0 10		beq $147f			beq 	_ECAOkayString 				; (this is post conversion)
.146f	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.1471	90 09		bcc $147c			bcc 	_ECAType
.1473	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.1475	b0 05		bcs $147c			bcs 	_ECAType
.1477	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.1479	4c de 13	jmp $13de			jmp 	_ECALoop
.147c					_ECAType:
.147c	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.147f					_ECAOkayString:
.147f	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.1481					_ECAGoLoop:
.1481	4c de 13	jmp $13de			jmp 	_ECALoop
.1484					PrecedenceTable:
>1484	03						.byte 	3 					; '+'
>1485	03						.byte 	3 					; '-'
>1486	04						.byte 	4 					; '*'
>1487	04						.byte 	4 					; '/'
>1488	05						.byte 	5 					; '^'
>1489	01						.byte 	1 					; 'and'
>148a	00						.byte 	0 					; 'or'
>148b	02						.byte 	2 					; '>'
>148c	02						.byte 	2 					; '='
>148d	02						.byte 	2 					; '<'
>148e	02						.byte 	2 					; '>='
>148f	02						.byte 	2 					; '<='
>1490	02						.byte 	2 					; '<>'
.1491					FindVariable:
.1491	86 2c		stx $2c				stx 	zTemp1 						; save name.
.1493	84 2d		sty $2d				sty 	zTemp1+1
.1495					_IVCheckSpecial:
.1495	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.1497	d0 18		bne $14b1			bne 	_IVStandard
.1499	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.149b	f0 0c		beq $14a9			beq 	_IVTIFloat
.149d	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.149f	d0 10		bne $14b1			bne 	_IVStandard
.14a1	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.14a3	a2 01		ldx #$01			ldx 	#$01
.14a5	a9 40		lda #$40			lda 	#NSSString
.14a7	38		sec				sec
.14a8	60		rts				rts
.14a9					_IVTIFloat:
.14a9	a0 80		ldy #$80			ldy 	#$80
.14ab	a2 00		ldx #$00			ldx 	#$00
.14ad	a9 00		lda #$00			lda 	#0
.14af	38		sec				sec
.14b0	60		rts				rts
.14b1					_IVStandard:
.14b1	ad 07 05	lda $0507			lda 	compilerStartHigh			; start scanning from here.
.14b4	85 2b		sta $2b				sta 	zTemp0+1
.14b6	64 2a		stz $2a				stz 	zTemp0
.14b8					_IVCheckLoop:
.14b8	b2 2a		lda ($2a)			lda 	(zTemp0) 					; finished ?
.14ba	f0 2b		beq $14e7			beq  	_IVNotFound 				; if so, return with CC.
.14bc	a0 01		ldy #$01			ldy 	#1 							; match ?
.14be	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14c0	c5 2c		cmp $2c				cmp 	zTemp1
.14c2	d0 07		bne $14cb			bne	 	_IVNext
.14c4	c8		iny				iny
.14c5	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14c7	c5 2d		cmp $2d				cmp 	zTemp1+1
.14c9	f0 0d		beq $14d8			beq 	_IVFound
.14cb					_IVNext:
.14cb	18		clc				clc
.14cc	a5 2a		lda $2a				lda 	zTemp0
.14ce	72 2a		adc ($2a)			adc 	(zTemp0)
.14d0	85 2a		sta $2a				sta 	zTemp0
.14d2	90 e4		bcc $14b8			bcc 	_IVCheckLoop
.14d4	e6 2b		inc $2b				inc 	zTemp0+1
.14d6	80 e0		bra $14b8			bra 	_IVCheckLoop
.14d8					_IVFound:
.14d8	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.14da	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14dc	aa		tax				tax
.14dd	c8		iny				iny
.14de	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14e0	48		pha				pha
.14e1	c8		iny				iny
.14e2	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.14e4	7a		ply				ply
.14e5	38		sec				sec
.14e6	60		rts				rts
.14e7					_IVNotFound:
.14e7	a6 2c		ldx $2c				ldx 	zTemp1 						; get variable name back
.14e9	a4 2d		ldy $2d				ldy 	zTemp1+1
.14eb	18		clc				clc
.14ec	60		rts				rts
.14ed					FixBranches:
.14ed	20 46 10	jsr $1046			jsr 	APIORewind 					; back to the start of the *object* code.
.14f0					_FBLoop:
.14f0	b2 28		lda ($28)			lda 	(objPtr) 					; get the next one.
.14f2	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.14f4	f0 16		beq $150c			beq 	_FBFixGotoGosub
.14f6	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.14f8	f0 12		beq $150c			beq 	_FBFixGotoGosub
.14fa	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.14fc	f0 0e		beq $150c			beq 	_FBFixGotoGosub
.14fe	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1500	f0 0a		beq $150c			beq 	_FBFixGotoGosub
.1502	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.1504	f0 3b		beq $1541			beq 	_FBFixVarSpace
.1506					_FBNext:
.1506	20 26 20	jsr $2026			jsr 	MoveObjectForward 			; move forward in object code.
.1509	90 e5		bcc $14f0			bcc 	_FBLoop 					; not finished
.150b					_FBExit:
.150b	60		rts				rts
.150c					_FBFixGotoGosub:
.150c	a0 01		ldy #$01			ldy 	#1							; line number in YA
.150e	b1 28		lda ($28),y			lda 	(objPtr),y
.1510	48		pha				pha
.1511	c8		iny				iny
.1512	b1 28		lda ($28),y			lda 	(objPtr),y
.1514	a8		tay				tay
.1515	68		pla				pla
.1516	20 c9 1b	jsr $1bc9			jsr 	STRFindLine			 		; find where it is YA
.1519	90 08		bcc $1523			bcc 	_FBFFound 					; not found, so must be >
.151b	48		pha				pha
.151c	b2 28		lda ($28)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.151e	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1520	d0 0f		bne $1531			bne 	_FBFFail
.1522	68		pla				pla
.1523					_FBFFound:
.1523	20 19 1c	jsr $1c19			jsr 	STRMakeOffset 				; make it an offset from X:YA
.1526	5a		phy				phy	 								; patch the GOTO/GOSUB
.1527	a0 01		ldy #$01			ldy 	#1
.1529	91 28		sta ($28),y			sta 	(objPtr),y
.152b	c8		iny				iny
.152c	68		pla				pla
.152d	91 28		sta ($28),y			sta 	(objPtr),y
.152f	80 d5		bra $1506			bra 	_FBNext
.1531					_FBFFail:
.1531	a0 02		ldy #$02			ldy 	#2
.1533	b1 28		lda ($28),y			lda 	(objPtr),y
.1535	8d 00 04	sta $0400			sta 	currentLineNumber
.1538	c8		iny				iny
.1539	b1 28		lda ($28),y			lda 	(objPtr),y
.153b	8d 01 04	sta $0401			sta 	currentLineNumber+1
.153e	4c 54 1f	jmp $1f54		jmp	ErrorV_line
.1541					_FBFixVarSpace:
.1541	a0 01		ldy #$01			ldy 	#1
.1543	ad 13 05	lda $0513			lda 	freeVariableMemory
.1546	91 28		sta ($28),y			sta 	(objPtr),y
.1548	c8		iny				iny
.1549	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.154c	91 28		sta ($28),y			sta 	(objPtr),y
.154e	80 b6		bra $1506			bra 	_FBNext
.1550					CommandFOR:
.1550	20 32 1a	jsr $1a32			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.1553	20 48 1a	jsr $1a48			jsr 	CharIsAlpha 				; if not alpha , error
.1556	90 59		bcc $15b1			bcc 	_CFFail
.1558	20 73 1d	jsr $1d73			jsr 	GetReferenceTerm 			; figure out the reference.
.155b	48		pha				pha 								; save type
.155c	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.155e	c9 00		cmp #$00			cmp 	#NSSIFloat
.1560	d0 4f		bne $15b1			bne 	_CFFail
.1562	5a		phy				phy 								; save reference on the stack
.1563	da		phx				phx
.1564	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.1566	20 3a 11	jsr $113a			jsr 	CheckNextA
.1569	20 d7 13	jsr $13d7			jsr 	CompileExpressionAt0 		; initial value
.156c	fa		plx				plx 								; get reference back.
.156d	7a		ply				ply
.156e	5a		phy				phy
.156f	da		phx				phx
.1570	38		sec				sec 								; set initial value.
.1571	20 25 1d	jsr $1d25			jsr 	GetSetVariable
.1574	fa		plx				plx
.1575	7a		ply				ply
.1576	68		pla				pla
.1577	29 20		and #$20			and 	#NSSIInt16
.1579	f0 04		beq $157f			beq 	_CFNotInt16
.157b	98		tya				tya
.157c	09 80		ora #$80			ora 	#$80
.157e	a8		tay				tay
.157f					_CFNotInt16:
.157f	8a		txa				txa 								; reference in YA
.1580	20 d6 11	jsr $11d6			jsr 	PushIntegerYA
.1583	a9 a4		lda #$a4			lda 	#C64_TO
.1585	20 3a 11	jsr $113a			jsr 	CheckNextA
.1588	20 d7 13	jsr $13d7			jsr 	CompileExpressionAt0 		; terminal value
.158b	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.158d	c9 00		cmp #$00			cmp 	#NSSIFloat
.158f	d0 20		bne $15b1			bne 	_CFFail
.1591	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; followed by STEP
.1594	c9 a9		cmp #$a9			cmp 	#C64_STEP
.1596	d0 0e		bne $15a6			bne 	_CFNoStep
.1598	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume it.
.159b	20 d7 13	jsr $13d7			jsr 	CompileExpressionAt0 		; terminal value
.159e	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15a0	c9 00		cmp #$00			cmp 	#NSSIFloat
.15a2	d0 0d		bne $15b1			bne 	_CFFail
.15a4	80 05		bra $15ab			bra 	_CFParametersDone
.15a6					_CFNoStep:
.15a6	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.15a8	20 e9 11	jsr $11e9			jsr 	PushIntegerA
.15ab					_CFParametersDone:
.15ab	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.15ad	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.15b0	60		rts				rts
.15b1					_CFFail:
.15b1	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.15b4					FNCompile:
.15b4	20 32 1a	jsr $1a32			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.15b7	20 97 1a	jsr $1a97			jsr 	ExtractVariableName
.15ba	e0 00		cpx #$00			cpx 	#0
.15bc	10 32		bpl $15f0			bpl 	_FNError
.15be	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.15bf	29 7f		and #$7f			and 	#$7F
.15c1	aa		tax				tax
.15c2	98		tya				tya
.15c3	09 80		ora #$80			ora 	#$80
.15c5	a8		tay				tay
.15c6	20 91 14	jsr $1491			jsr 	FindVariable				; does it already exist ?
.15c9	90 25		bcc $15f0			bcc 	_FNError 					; no.
.15cb	20 19 1c	jsr $1c19			jsr 	STRMakeOffset 				; convert to a relative address.
.15ce	c9 00		cmp #$00			cmp 	#0 							; fix up.
.15d0	d0 01		bne $15d3			bne 	_FNNoBorrow
.15d2	88		dey				dey
.15d3					_FNNoBorrow:
.15d3	3a		dec a				dec 	a
.15d4	5a		phy				phy 								; save location of routine on stack.
.15d5	48		pha				pha
.15d6	da		phx				phx
.15d7	20 d7 13	jsr $13d7			jsr 	CompileExpressionAt0
.15da	20 34 11	jsr $1134			jsr 	CheckNextRParen
.15dd	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.15df	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.15e2	68		pla				pla
.15e3	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.15e6	68		pla				pla
.15e7	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.15ea	68		pla				pla
.15eb	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.15ee	18		clc				clc
.15ef	60		rts				rts
.15f0					_FNError:
.15f0	4c 04 1f	jmp $1f04		jmp	ErrorV_value
.15f3					CommandTables:
>15f3	07 cb 00 03 f5 1a 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>15fa	07 89 00 03 fc 1a 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>1601	07 8d 00 03 ef 1a 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>1608	07 88 00 03 6b 1b 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>160f	07 85 00 03 4b 1b 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>1616	07 84 00 04 5f 1b 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>161d	07 99 00 03 a0 1c 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1624	07 98 00 04 a0 1c 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>162b	07 8f 00 03 ab 1d 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>1632	07 81 00 03 50 15 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>1639	07 82 00 03 23 1c 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>1640	07 a1 00 03 68 1a 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>1647	07 83 00 03 8c 12 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>164e	07 87 00 03 e9 1c 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>1655	07 86 00 03 1f 13 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>165c	07 96 00 03 a8 12 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>1663	07 8b 00 e3 18 1b 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>166a	08 92 00 ea e3 77 1e 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>1672	09 91 00 e1 a9 03 4f 1c			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>167a	06
>167b	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>1682	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>1689	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>168f	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>1696	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>169d	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>16a4	07 9d 00 e3 9d 1e 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>16ab	0a 9f 00 ea e3 b0 1e 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>16b3	c6 06
>16b5	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>16bb	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>16c2	0a ce 92 e3 e5 19 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>16ca	ad 06
>16cc	0a ce 8d e3 e5 19 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>16d4	ae 06
>16d6	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>16dc	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>16e4	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>16eb	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>16f2	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>16fa	06
>16fb	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>1703	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>170b	9a 06
>170d	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>1715	9b 06
>1717	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>171f	9c 06
>1721	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>1729	06
>172a	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>1731	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>1739	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>1741	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>1749	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>1751	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>1759	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>1761	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>1769	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>1771	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>1779	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>1781	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>1788	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>1790	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>1798	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>17a0	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>17a8	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>17b0	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>17b8	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>17c0	00						.byte 	0
.17c1					UnaryTables:
>17c1	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>17c8	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>17d0	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>17d7	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>17de	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>17e5	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>17ec	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>17f4	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>17fb	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>1803	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>180b	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>1813	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>181b	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>1823	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>182b	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>1832	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>1839	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>1840	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>1847	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>184e	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>1855	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>185d	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>1865	0b ca 00 8f ae 03 e5 19			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>186d	91 bd 07
>1870	07 a8 00 03 04 1a 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>1877	07 a5 00 03 b4 15 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>187e	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>1885	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>188c	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>1894	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>189c	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>18a3	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>18aa	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>18b1	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>18b9	06
>18ba	00						.byte 	0
.18bb					GeneratorProcess:
.18bb	86 2a		stx $2a				stx 	zTemp0 						; save generation pointer in zTemp0
.18bd	84 2b		sty $2b				sty 	zTemp0+1
.18bf	85 2c		sta $2c				sta 	zTemp1 						; first match token
.18c1	64 2d		stz $2d				stz 	zTemp1+1
.18c3	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.18c5	d0 05		bne $18cc			bne 	_GPNotShifted
.18c7	20 27 1a	jsr $1a27			jsr 	GetNext 					; get the shifted token
.18ca	85 2d		sta $2d				sta 	zTemp1+1 					; match CE xx
.18cc					_GPNotShifted:
.18cc					_GPSearch:
.18cc	b2 2a		lda ($2a)			lda 	(zTemp0) 					; reached end ?
.18ce	18		clc				clc
.18cf	f0 2f		beq $1900			beq 	_GPExit
.18d1	a0 01		ldy #$01			ldy 	#1 							; tokens match
.18d3	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.18d5	c5 2c		cmp $2c				cmp 	zTemp1
.18d7	d0 09		bne $18e2			bne 	_GPNext
.18d9	a5 2d		lda $2d				lda 	zTemp1+1 					; 2nd token ?
.18db	f0 12		beq $18ef			beq 	_GPFound
.18dd	c8		iny				iny 								; check match.
.18de	d1 2a		cmp ($2a),y			cmp 	(zTemp0),y
.18e0	f0 0d		beq $18ef			beq 	_GPFound
.18e2					_GPNext:
.18e2	18		clc				clc 								; follow to next
.18e3	a5 2a		lda $2a				lda 	zTemp0
.18e5	72 2a		adc ($2a)			adc 	(zTemp0)
.18e7	85 2a		sta $2a				sta 	zTemp0
.18e9	90 e1		bcc $18cc			bcc 	_GPSearch
.18eb	e6 2b		inc $2b				inc 	zTemp0+1
.18ed	80 dd		bra $18cc			bra 	_GPSearch
.18ef					_GPFound:
.18ef	18		clc				clc 								; skip to action bytes
.18f0	a5 2a		lda $2a				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.18f2	69 03		adc #$03			adc 	#3
.18f4	85 2a		sta $2a				sta 	zTemp0
.18f6	90 02		bcc $18fa			bcc 	_GPNoCarry
.18f8	e6 2b		inc $2b				inc 	zTemp0+1
.18fa					_GPNoCarry:
.18fa					_GPLoop:
.18fa	20 01 19	jsr $1901			jsr 	GeneratorExecute 			; execute one command
.18fd	90 fb		bcc $18fa			bcc 	_GPLoop 					; go back if not completed.
.18ff	38		sec				sec 								; return with CS.
.1900					_GPExit:
.1900	60		rts				rts
.1901					GeneratorExecute:
.1901	20 ac 19	jsr $19ac			jsr 	_GEFetchZTemp0 				; get next.
.1904	48		pha				pha 								; split into 2 nibbles
.1905	4a		lsr a				lsr 	a
.1906	4a		lsr a				lsr 	a
.1907	4a		lsr a				lsr		a
.1908	4a		lsr a				lsr 	a
.1909	20 13 19	jsr $1913			jsr 	_GEExecuteNibble 			; MSB first
.190c	68		pla				pla
.190d	b0 03		bcs $1912			bcs 	_GEHaveCompleted
.190f	20 13 19	jsr $1913			jsr 	_GEExecuteNibble 			; LSB second
.1912					_GEHaveCompleted:
.1912	60		rts				rts
.1913					_GEExecuteNibble:
.1913	29 0f		and #$0f			and 	#$0F
.1915	0a		asl a				asl 	a
.1916	aa		tax				tax
.1917	7c 1a 19	jmp ($191a,x)			jmp 	(_GEExecuteVectors,x)
.191a					_GEExecuteVectors:
>191a	3a 19						.word 	_GEXNop 					; 0  (no operation)
>191c	42 19						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>191e	3c 19						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>1920	8f 19						.word 	_GEXExecute 				; 3  (run arbitrary code)
>1922	82 19						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>1924	3a 19						.word 	_GEXNop 					; 5
>1926	49 19						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>1928	4d 19						.word 	_GEXExitString 				; 7  exit return string type
>192a	51 19						.word 	_GEXLParam 					; 8  check ( follows
>192c	55 19						.word 	_GEXRParam 					; 9  check ) follows
>192e	59 19						.word 	_GEXComma					; A  check , follows
>1930	3a 19						.word 	_GEXNop 					; B
>1932	3a 19						.word 	_GEXNop 					; C
>1934	3a 19						.word 	_GEXNop 					; D
>1936	69 19						.word 	_GEXNumber 					; E  compile get any number
>1938	74 19						.word 	_GEXString 					; F  compile get any string
.193a					_GEXNop:
.193a	18		clc				clc
.193b	60		rts				rts
.193c					_GEXToken2:
.193c	20 ac 19	jsr $19ac			jsr 	_GEFetchZTemp0
.193f	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1942					_GEXToken1:
.1942	20 ac 19	jsr $19ac			jsr 	_GEFetchZTemp0
.1945	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1948	60		rts				rts
.1949					_GEXExitNumber:
.1949	a9 00		lda #$00			lda 	#NSSIFloat
.194b	38		sec				sec
.194c	60		rts				rts
.194d					_GEXExitString:
.194d	a9 40		lda #$40			lda 	#NSSString
.194f	38		sec				sec
.1950	60		rts				rts
.1951					_GEXLParam:
.1951	a9 28		lda #$28			lda 	#"("
.1953	80 06		bra $195b			bra 	_GEXCheck
.1955					_GEXRParam:
.1955	a9 29		lda #$29			lda 	#")"
.1957	80 02		bra $195b			bra 	_GEXCheck
.1959					_GEXComma:
.1959	a9 2c		lda #$2c			lda 	#","
.195b					_GEXCheck:
.195b	85 2e		sta $2e				sta 	zTemp2 						; save match
.195d	20 32 1a	jsr $1a32			jsr 	GetNextNonSpace 			; get next skipping spaces
.1960	c5 2e		cmp $2e				cmp 	zTemp2 						; check matches.
.1962	d0 02		bne $1966			bne 	_GEXSyntax
.1964	18		clc				clc
.1965	60		rts				rts
.1966					_GEXSyntax:
.1966	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.1969					_GEXNumber:
.1969	20 b5 19	jsr $19b5			jsr 	GEXCompileExpression 		; compile expression
.196c	29 40		and #$40			and 	#NSSTypeMask
.196e	c9 00		cmp #$00			cmp  	#NSSIFloat
.1970	d0 0d		bne $197f			bne 	_GEXType
.1972	18		clc				clc
.1973	60		rts				rts
.1974					_GEXString:
.1974	20 b5 19	jsr $19b5			jsr 	GEXCompileExpression 		; compile expression
.1977	29 40		and #$40			and 	#NSSTypeMask
.1979	c9 40		cmp #$40			cmp  	#NSSString
.197b	d0 02		bne $197f			bne 	_GEXType
.197d	18		clc				clc
.197e	60		rts				rts
.197f					_GEXType:
.197f	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.1982					_GEXChannelExec:
.1982	20 c5 19	jsr $19c5			jsr 	ChannelPrefix 				; set up default
.1985	20 8f 19	jsr $198f			jsr 	_GEXExecute
.1988	08		php				php
.1989	20 df 19	jsr $19df			jsr 	ChannelPostfix 				; replace default.
.198c	28		plp				plp
.198d	60		rts				rts
>198e	db						.byte 	$DB 						; causes a break in the emulator
.198f					_GEXExecute:
.198f	20 ac 19	jsr $19ac			jsr 	_GEFetchZTemp0 				; get vector
.1992	85 2e		sta $2e				sta 	zTemp2
.1994	20 ac 19	jsr $19ac			jsr 	_GEFetchZTemp0
.1997	85 2f		sta $2f				sta 	zTemp2+1
.1999	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.199b	da		phx				phx
.199c	a6 2b		ldx $2b				ldx 	zTemp0+1
.199e	da		phx				phx
.199f	20 a9 19	jsr $19a9			jsr 	_GECallZTemp2 				; execute code
.19a2	fa		plx				plx 								; recover generation exec
.19a3	86 2b		stx $2b				stx 	zTemp0+1
.19a5	fa		plx				plx
.19a6	86 2a		stx $2a				stx 	zTemp0
.19a8	60		rts				rts
.19a9					_GECallZTemp2:
.19a9	6c 2e 00	jmp ($002e)			jmp 	(zTemp2)
.19ac					_GEFetchZTemp0:
.19ac	b2 2a		lda ($2a)			lda 	(zTemp0)
.19ae	e6 2a		inc $2a				inc 	zTemp0
.19b0	d0 02		bne $19b4			bne 	_GEFZ0Skip
.19b2	e6 2b		inc $2b				inc 	zTemp0+1
.19b4					_GEFZ0Skip:
.19b4	60		rts				rts
.19b5					GEXCompileExpression:
.19b5	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19b7	da		phx				phx
.19b8	a6 2b		ldx $2b				ldx 	zTemp0+1
.19ba	da		phx				phx
.19bb	20 d7 13	jsr $13d7			jsr 	CompileExpressionAt0 		; compile expression.
.19be	fa		plx				plx 								; recover generation exec
.19bf	86 2b		stx $2b				stx 	zTemp0+1
.19c1	fa		plx				plx
.19c2	86 2a		stx $2a				stx 	zTemp0
.19c4	60		rts				rts
.19c5					ChannelPrefix:
.19c5	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.19c7	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.19ca	20 b5 19	jsr $19b5			jsr 	GEXCompileExpression 		; channel #
.19cd	29 40		and #$40			and 	#NSSTypeMask
.19cf	c9 00		cmp #$00			cmp 	#NSSIFloat
.19d1	d0 09		bne $19dc			bne 	_CPXType
.19d3	20 30 11	jsr $1130			jsr 	CheckNextComma 				; check , follows.
.19d6	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.19d8	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.19db	60		rts				rts
.19dc					_CPXType:
.19dc	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.19df					ChannelPostfix:
.19df	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.19e1	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.19e4	60		rts				rts
.19e5					OptionalParameterCompile:
.19e5	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; what follows.
.19e8	c9 2c		cmp #$2c			cmp 	#","
.19ea	d0 0e		bne $19fa			bne 	_MidDefault
.19ec	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume ,
.19ef	20 d7 13	jsr $13d7			jsr 	CompileExpressionAt0
.19f2	29 40		and #$40			and 	#NSSTypeMask
.19f4	c9 00		cmp #$00			cmp 	#NSSIFloat
.19f6	d0 09		bne $1a01			bne 	MidFailType
.19f8	80 05		bra $19ff			bra 	_MidComplete
.19fa					_MidDefault:
.19fa	a9 ff		lda #$ff			lda 	#255 						; default of 255
.19fc	20 e9 11	jsr $11e9			jsr 	PushIntegerA
.19ff					_MidComplete:
.19ff	18		clc				clc
.1a00	60		rts				rts
.1a01					MidFailType:
.1a01	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.1a04					NotUnaryCompile:
.1a04	ad 8c 14	lda $148c			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1a07	20 d9 13	jsr $13d9			jsr 	CompileExpressionAtA 		; evaluate at that level
.1a0a	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1a0c	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a0e	d0 f1		bne $1a01			bne 	MidFailType
.1a10	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1a12	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1a15	60		rts				rts
.1a16					LookNext:
.1a16	b2 24		lda ($24)			lda 	(srcPtr)
.1a18	60		rts				rts
.1a19					LookNextNonSpace:
.1a19	b2 24		lda ($24)			lda 	(srcPtr)
.1a1b	c9 20		cmp #$20			cmp		#' '
.1a1d	f0 03		beq $1a22			beq 	_LNNSkip
.1a1f	c9 00		cmp #$00			cmp 	#0
.1a21	60		rts				rts
.1a22					_LNNSkip:
.1a22	20 27 1a	jsr $1a27			jsr 	GetNext
.1a25	80 f2		bra $1a19			bra 	LookNextNonSpace
.1a27					GetNext:
.1a27	b2 24		lda ($24)			lda 	(srcPtr) 					; get next
.1a29	e6 24		inc $24				inc 	srcPtr
.1a2b	d0 02		bne $1a2f			bne 	_GNSkip
.1a2d	e6 25		inc $25				inc 	srcPtr+1
.1a2f					_GNSkip:
.1a2f	c9 00		cmp #$00			cmp 	#0
.1a31	60		rts				rts
.1a32					GetNextNonSpace:
.1a32	20 27 1a	jsr $1a27			jsr 	GetNext
.1a35	c9 20		cmp #$20			cmp 	#' '
.1a37	f0 f9		beq $1a32			beq 	GetNextNonSpace
.1a39	c9 00		cmp #$00			cmp 	#0
.1a3b	60		rts				rts
.1a3c					CharIsDigit:
.1a3c	c9 30		cmp #$30			cmp 	#"0"
.1a3e	90 06		bcc $1a46			bcc 	CCFalse
.1a40	c9 3a		cmp #$3a			cmp 	#"9"+1
.1a42	b0 02		bcs $1a46			bcs 	CCFalse
.1a44					CCTrue:
.1a44	38		sec				sec
.1a45	60		rts				rts
.1a46					CCFalse:
.1a46	18		clc				clc
.1a47	60		rts				rts
.1a48					CharIsAlpha:
.1a48	c9 41		cmp #$41			cmp 	#"A"
.1a4a	90 fa		bcc $1a46			bcc 	CCFalse
.1a4c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1a4e	b0 f6		bcs $1a46			bcs 	CCFalse
.1a50	80 f2		bra $1a44			bra 	CCTrue
.1a52					ConvertHexStyle:
.1a52	38		sec				sec
.1a53	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1a55	90 ef		bcc $1a46			bcc 	CCFalse
.1a57	c9 0a		cmp #$0a			cmp 	#9+1
.1a59	90 e9		bcc $1a44			bcc 	CCTrue
.1a5b	38		sec				sec 								; shift into hex space A=>0 Z=>25
.1a5c	e9 11		sbc #$11			sbc 	#"A"-"0"
.1a5e	90 e6		bcc $1a46			bcc 	CCFalse
.1a60	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.1a62	b0 e2		bcs $1a46			bcs 	CCFalse
.1a64	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.1a66	80 dc		bra $1a44			bra 	CCTrue
.1a68					CommandGET:
.1a68	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; # follows ?
.1a6b	c9 23		cmp #$23			cmp 	#"#"
.1a6d	d0 0d		bne $1a7c			bne 	CommandGetBody
.1a6f	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume #
.1a72	20 c5 19	jsr $19c5			jsr 	ChannelPrefix 				; do it as GET#
.1a75	20 7c 1a	jsr $1a7c			jsr 	CommandGetBody
.1a78	20 df 19	jsr $19df			jsr 	ChannelPostfix
.1a7b	60		rts				rts
.1a7c					CommandGetBody:
.1a7c	20 32 1a	jsr $1a32			jsr 	GetNextNonSpace 			; get the first character
.1a7f	20 73 1d	jsr $1d73			jsr 	GetReferenceTerm 			; identify variable to assign to
.1a82	48		pha				pha
.1a83	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1a85	c9 40		cmp #$40			cmp 	#NSSString
.1a87	d0 0b		bne $1a94			bne 	_CGType
.1a89	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1a8b	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1a8e	38		sec				sec
.1a8f	68		pla				pla
.1a90	20 25 1d	jsr $1d25			jsr		GetSetVariable
.1a93	60		rts				rts
.1a94					_CGType:
.1a94	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.1a97					ExtractVariableName:
.1a97	20 48 1a	jsr $1a48			jsr 	CharIsAlpha
.1a9a	90 50		bcc $1aec			bcc 	_IVSyntax
.1a9c	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.1a9e	85 2c		sta $2c				sta 	zTemp1 						; we'll build it in zTemp1
.1aa0	64 2d		stz $2d				stz 	zTemp1+1
.1aa2	20 16 1a	jsr $1a16			jsr 	LookNext 					; is there a second character ?
.1aa5	20 48 1a	jsr $1a48			jsr 	CharIsAlpha  				; must be alphanumeric
.1aa8	b0 05		bcs $1aaf			bcs 	_IVHasSecond
.1aaa	20 3c 1a	jsr $1a3c			jsr 	CharIsDigit
.1aad	90 07		bcc $1ab6			bcc 	_IVCheckType
.1aaf					_IVHasSecond:
.1aaf	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.1ab1	85 2d		sta $2d				sta 	zTemp1+1
.1ab3					_IVGetNextCheck:
.1ab3	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume it
.1ab6					_IVCheckType:
.1ab6	20 16 1a	jsr $1a16			jsr 	LookNext					; check if string follows.
.1ab9	20 48 1a	jsr $1a48			jsr 	CharIsAlpha
.1abc	b0 f5		bcs $1ab3			bcs 	_IVGetNextCheck
.1abe	20 3c 1a	jsr $1a3c			jsr 	CharIsDigit
.1ac1	b0 f0		bcs $1ab3			bcs 	_IVGetNextCheck
.1ac3	a2 40		ldx #$40			ldx 	#NSSString
.1ac5	c9 24		cmp #$24			cmp 	#"$"
.1ac7	f0 06		beq $1acf			beq 	_IVHasType
.1ac9	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.1acb	c9 25		cmp #$25			cmp 	#"%"
.1acd	d0 08		bne $1ad7			bne 	_IVCheckArray
.1acf					_IVHasType:
.1acf	8a		txa				txa 								; Or X into zTemp1
.1ad0	05 2c		ora $2c				ora 	zTemp1
.1ad2	85 2c		sta $2c				sta 	zTemp1
.1ad4	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume it
.1ad7					_IVCheckArray:
.1ad7	20 16 1a	jsr $1a16			jsr 	LookNext 					; check if array follows
.1ada	c9 28		cmp #$28			cmp 	#"("
.1adc	d0 09		bne $1ae7			bne 	_IVNotArray
.1ade	a5 2c		lda $2c				lda 	zTemp1 						; set array bit
.1ae0	09 80		ora #$80			ora 	#NSSArray
.1ae2	85 2c		sta $2c				sta 	zTemp1
.1ae4	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume it
.1ae7					_IVNotArray:
.1ae7	a6 2c		ldx $2c				ldx 	zTemp1
.1ae9	a4 2d		ldy $2d				ldy 	zTemp1+1
.1aeb	60		rts				rts
.1aec					_IVSyntax:
.1aec	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.1aef					CommandGOSUB:
.1aef	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1af1	20 02 1b	jsr $1b02			jsr 	CompileBranchCommand
.1af4	60		rts				rts
.1af5					CommandGOAlt:
.1af5	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1af7	20 3a 11	jsr $113a			jsr 	CheckNextA
.1afa	80 00		bra $1afc			bra 	CommandGOTO
.1afc					CommandGOTO:
.1afc	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1afe	20 02 1b	jsr $1b02			jsr 	CompileBranchCommand
.1b01	60		rts				rts
.1b02					CompileBranchCommand:
.1b02	20 d8 10	jsr $10d8			jsr 	WriteCodeByte 				; write the command out.
.1b05	20 32 1a	jsr $1a32			jsr 	GetNextNonSpace
.1b08	20 7b 1c	jsr $1c7b			jsr 	ParseConstant 				; get constant into YA
.1b0b	90 08		bcc $1b15			bcc 	_CBCSyntax
.1b0d	20 d8 10	jsr $10d8			jsr 	WriteCodeByte				; and compile the actual line number
.1b10	98		tya				tya
.1b11	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1b14	60		rts				rts
.1b15					_CBCSyntax:
.1b15	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.1b18					CommandIF:
.1b18	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; what follows the tests ?
.1b1b	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1b1d	f0 0f		beq $1b2e			beq 	_CIGoto
.1b1f	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1b21	20 3a 11	jsr $113a			jsr 	CheckNextA
.1b24	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; THEN <number>
.1b27	20 3c 1a	jsr $1a3c			jsr 	CharIsDigit
.1b2a	b0 05		bcs $1b31			bcs 	_CIGoto2
.1b2c	80 09		bra $1b37			bra 	CompileGotoEOL
.1b2e					_CIGoto:
.1b2e	20 27 1a	jsr $1a27			jsr 	GetNext
.1b31					_CIGoto2:
.1b31	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1b33	20 02 1b	jsr $1b02			jsr 	CompileBranchCommand
.1b36	60		rts				rts
.1b37					CompileGotoEOL:
.1b37	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.1b39	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1b3c	20 d1 10	jsr $10d1			jsr 	GetLineNumber 				; Get the current line number => YA
.1b3f	1a		inc a				inc 	a 							; and branch to +1
.1b40	d0 01		bne $1b43			bne 	_CGENoCarry
.1b42	c8		iny				iny
.1b43					_CGENoCarry:
.1b43	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1b46	98		tya				tya
.1b47	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1b4a	60		rts				rts
.1b4b					CommandINPUT:
.1b4b	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; check for "
.1b4e	c9 22		cmp #$22			cmp 	#'"'
.1b50	d0 0d		bne $1b5f			bne 	CommandINPUTStream
.1b52	20 d7 13	jsr $13d7			jsr 	CompileExpressionAt0
.1b55	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1b57	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1b5a	a9 2c		lda #$2c			lda 	#","
.1b5c	20 30 11	jsr $1130			jsr 	CheckNextComma
.1b5f					CommandINPUTStream:
.1b5f	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1b61	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1b64	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.1b66	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1b68	4c ed 1c	jmp $1ced			jmp 	CommandReadInputCommon
.1b6b					CommandLET:
.1b6b	20 32 1a	jsr $1a32			jsr 	GetNextNonSpace 			; get the first character
.1b6e					CommandLETHaveFirst:
.1b6e	20 73 1d	jsr $1d73			jsr 	GetReferenceTerm 			; identify variable to assign to
.1b71	da		phx				phx 								; save target on the stack.
.1b72	5a		phy				phy
.1b73	48		pha				pha
.1b74	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.1b76	20 3a 11	jsr $113a			jsr 	CheckNextA
.1b79	20 d7 13	jsr $13d7			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1b7c	85 2a		sta $2a				sta 	zTemp0 						; save type returned
.1b7e	68		pla				pla 								; get type of assignment
.1b7f	48		pha				pha
.1b80	45 2a		eor $2a				eor 	zTemp0 						; compare using EOR
.1b82	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.1b84	d0 17		bne $1b9d			bne 	_CLType
.1b86	68		pla				pla 								; restore and compile save code
.1b87	7a		ply				ply
.1b88	fa		plx				plx
.1b89	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.1b8b	f0 05		beq $1b92			beq 	_CLTIString
.1b8d	38		sec				sec
.1b8e	20 25 1d	jsr $1d25			jsr		GetSetVariable
.1b91	60		rts				rts
.1b92					_CLTIString:
.1b92	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.1b94	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1b97	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.1b99	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1b9c	60		rts				rts
.1b9d					_CLType:
.1b9d	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.1ba0					STRMarkLine:
.1ba0	48		pha				pha
.1ba1	38		sec				sec 								; allocate 4 bytes (line #,address)
.1ba2	ad 0f 05	lda $050f			lda 	lineNumberTable 			; and copy to zTemp0
.1ba5	e9 04		sbc #$04			sbc 	#4
.1ba7	8d 0f 05	sta $050f			sta 	lineNumberTable
.1baa	85 2a		sta $2a				sta 	zTemp0
.1bac	ad 10 05	lda $0510			lda 	lineNumberTable+1
.1baf	e9 00		sbc #$00			sbc 	#0
.1bb1	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1bb4	85 2b		sta $2b				sta 	zTemp0+1
.1bb6	68		pla				pla
.1bb7	92 2a		sta ($2a)			sta 	(zTemp0) 					; line # save it in +0,+1
.1bb9	98		tya				tya
.1bba	a0 01		ldy #$01			ldy 	#1
.1bbc	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1bbe	a5 28		lda $28				lda 	objPtr 						; save current address in +2,+3
.1bc0	c8		iny				iny
.1bc1	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1bc3	a5 29		lda $29				lda 	objPtr+1
.1bc5	c8		iny				iny
.1bc6	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1bc8	60		rts				rts
.1bc9					STRFindLine:
.1bc9	85 2a		sta $2a				sta 	zTemp0 						; zTemp0 line number being searched
.1bcb	84 2b		sty $2b				sty 	zTemp0+1
.1bcd	ad 08 05	lda $0508			lda 	compilerEndHigh 			; work backwards through table
.1bd0	85 2d		sta $2d				sta 	zTemp1+1
.1bd2	64 2c		stz $2c				stz 	zTemp1
.1bd4					_STRSearch:
.1bd4	20 0b 1c	jsr $1c0b			jsr 	_STRPrevLine 				; look at previous record.
.1bd7	a0 01		ldy #$01			ldy 	#1
.1bd9	b2 2c		lda ($2c)			lda 	(zTemp1) 					; check table line # >= target
.1bdb	c5 2a		cmp $2a				cmp 	zTemp0
.1bdd	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1bdf	e5 2b		sbc $2b				sbc 	zTemp0+1
.1be1	b0 0b		bcs $1bee			bcs 	_STRFound 					; >=
.1be3					_STRNext:
.1be3	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1be5	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1be7	c9 ff		cmp #$ff			cmp 	#$FF
.1be9	d0 e9		bne $1bd4			bne 	_STRSearch
.1beb	4c 6b 1f	jmp $1f6b		jmp	ErrorV_internal
.1bee					_STRFound:
.1bee	b2 2c		lda ($2c)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1bf0	45 2a		eor $2a				eor 	zTemp0
.1bf2	d0 06		bne $1bfa			bne 	_STRDifferent
.1bf4	b2 2c		lda ($2c)			lda 	(zTemp1)
.1bf6	45 2a		eor $2a				eor 	zTemp0
.1bf8	f0 02		beq $1bfc			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1bfa					_STRDifferent:
.1bfa	a9 ff		lda #$ff			lda 	#$FF
.1bfc					_STROut:
.1bfc	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1bfd	69 ff		adc #$ff			adc 	#255
.1bff	08		php				php
.1c00	c8		iny				iny 								; address into YA
.1c01	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c03	48		pha				pha
.1c04	c8		iny				iny
.1c05	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1c07	a8		tay				tay
.1c08	68		pla				pla
.1c09	28		plp				plp
.1c0a	60		rts				rts
.1c0b					_STRPrevLine:
.1c0b	38		sec				sec 								; move backwards one entry.
.1c0c	a5 2c		lda $2c				lda 	zTemp1
.1c0e	e9 04		sbc #$04			sbc 	#4
.1c10	85 2c		sta $2c				sta 	zTemp1
.1c12	a5 2d		lda $2d				lda 	zTemp1+1
.1c14	e9 00		sbc #$00			sbc 	#0
.1c16	85 2d		sta $2d				sta 	zTemp1+1
.1c18	60		rts				rts
.1c19					STRMakeOffset:
.1c19	18		clc				clc 								; borrow 1
.1c1a	e5 28		sbc $28				sbc 	objPtr
.1c1c	48		pha				pha
.1c1d	98		tya				tya
.1c1e	e5 29		sbc $29				sbc 	objPtr+1
.1c20	a8		tay				tay
.1c21	68		pla				pla
.1c22	60		rts				rts
.1c23					CommandNEXT:
.1c23	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1c26	20 48 1a	jsr $1a48			jsr 	CharIsAlpha 				; if not alpha , error
.1c29	90 0c		bcc $1c37			bcc 	_CNNoReferenceGiven
.1c2b	20 27 1a	jsr $1a27			jsr 	GetNext
.1c2e	20 73 1d	jsr $1d73			jsr 	GetReferenceTerm 			; figure out the reference.
.1c31	8a		txa				txa 								; reference in YA
.1c32	20 d6 11	jsr $11d6			jsr 	PushIntegerYA 				; write it out.
.1c35	80 06		bra $1c3d			bra 	_CNParametersDone
.1c37					_CNNoReferenceGiven:
.1c37	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1c39	a8		tay				tay
.1c3a	20 d6 11	jsr $11d6			jsr 	PushIntegerYA 				; write it out.
.1c3d					_CNParametersDone:
.1c3d	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1c3f	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1c42	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; look for ,
.1c45	c9 2c		cmp #$2c			cmp 	#","
.1c47	d0 05		bne $1c4e			bne 	_CNExit
.1c49	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume ,
.1c4c	80 d5		bra $1c23			bra 	CommandNEXT 				; and go round.
.1c4e					_CNExit:
.1c4e	60		rts				rts
.1c4f					CommandON:
.1c4f	20 32 1a	jsr $1a32			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1c52	48		pha				pha 								; save on stack
.1c53	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1c55	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1c57	f0 09		beq $1c62			beq 	_COCreateLoop
.1c59	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1c5b	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1c5d	f0 03		beq $1c62			beq 	_COCreateLoop
.1c5f	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.1c62					_COCreateLoop:
.1c62	8a		txa				txa 								; compile a goto/gosub somewhere
.1c63	da		phx				phx
.1c64	20 02 1b	jsr $1b02			jsr 	CompileBranchCommand
.1c67	fa		plx				plx
.1c68	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace			; ',' follows
.1c6b	c9 2c		cmp #$2c			cmp 	#","
.1c6d	d0 0a		bne $1c79			bne 	_COComplete 				; if so, more line numbers
.1c6f	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1c71	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1c74	20 27 1a	jsr $1a27			jsr 	GetNext
.1c77	80 e9		bra $1c62			bra 	_COCreateLoop
.1c79					_COComplete:
.1c79	68		pla				pla 								; throw GOTO/GOSUB
.1c7a	60		rts				rts
.1c7b					ParseConstant:
.1c7b	a2 00		ldx #$00			ldx 	#0
.1c7d	20 37 24	jsr $2437			jsr 	FloatEncodeStart 			; send first
.1c80					_ParseLoop:
.1c80	20 16 1a	jsr $1a16			jsr 	LookNext 					; send subsequent
.1c83	20 3a 24	jsr $243a			jsr 	FloatEncodeContinue
.1c86	90 05		bcc $1c8d			bcc 	_ParseDone
.1c88	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume it
.1c8b	80 f3		bra $1c80			bra 	_ParseLoop
.1c8d					_ParseDone:
.1c8d	b5 30		lda $30,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1c8f	29 80		and #$80			and 	#$80
.1c91	15 6c		ora $6c,x			ora 	NSExponent,x 				; 16 bit int check
.1c93	15 54		ora $54,x			ora 	NSMantissa2,x
.1c95	15 60		ora $60,x			ora 	NSMantissa3,x
.1c97	18		clc				clc
.1c98	d0 05		bne $1c9f			bne 	_ParseExit 					; exit with CC if need float to compile
.1c9a	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; read into YA.
.1c9c	b4 48		ldy $48,x			ldy		NSMantissa1,x
.1c9e	38		sec				sec
.1c9f					_ParseExit:
.1c9f	60		rts				rts
.1ca0					CommandPRINT:
.1ca0	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace			; what follows ?
.1ca3	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1ca5	f0 1f		beq $1cc6			beq 	_CPCheckEnd
.1ca7	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1ca9	f0 16		beq $1cc1			beq 	_CPTabCheckEnd
.1cab	20 dd 1c	jsr $1cdd			jsr 	_CPAtEnd 					; check for : and EOL
.1cae	b0 22		bcs $1cd2			bcs 	_CPExitCR 					; exit with CR
.1cb0	20 d7 13	jsr $13d7			jsr 	CompileExpressionAt0 		; so it is something to print
.1cb3	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1cb5	29 40		and #$40			and 	#NSSString 					; if string
.1cb7	d0 02		bne $1cbb			bne 	_CPOut
.1cb9	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1cbb					_CPOut:
.1cbb	8a		txa				txa 								; print that thing
.1cbc	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1cbf	80 df		bra $1ca0			bra 	CommandPRINT 				; and loop round/
.1cc1					_CPTabCheckEnd:
.1cc1	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1cc3	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1cc6					_CPCheckEnd:
.1cc6	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume it.
.1cc9	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; what follows ?
.1ccc	20 dd 1c	jsr $1cdd			jsr 	_CPAtEnd 					; reached end
.1ccf	90 cf		bcc $1ca0			bcc 	CommandPRINT 				; no, loop back
.1cd1	60		rts				rts
.1cd2					_CPExitCR:
.1cd2	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1cd4	20 e9 11	jsr $11e9			jsr 	PushIntegerA
.1cd7	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1cd9	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1cdc	60		rts				rts
.1cdd					_CPAtEnd:
.1cdd	c9 00		cmp #$00			cmp 	#0
.1cdf	f0 06		beq $1ce7			beq 	_CPIsEnd
.1ce1	c9 3a		cmp #$3a			cmp 	#":"
.1ce3	f0 02		beq $1ce7			beq 	_CPIsEnd
.1ce5	18		clc				clc
.1ce6	60		rts				rts
.1ce7					_CPIsEnd:
.1ce7	38		sec				sec
.1ce8	60		rts				rts
.1ce9					CommandREAD:
.1ce9	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1ceb	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1ced					CommandReadInputCommon:
.1ced	8e 0d 05	stx $050d			stx 	numberPCode
.1cf0	8c 0e 05	sty $050e			sty 	stringPCode
.1cf3					_CRLoop:
.1cf3	20 32 1a	jsr $1a32			jsr 	GetNextNonSpace 			; first char of identifier
.1cf6	20 48 1a	jsr $1a48			jsr 	CharIsAlpha 				; check A-Z
.1cf9	90 27		bcc $1d22			bcc 	_CRSyntax
.1cfb	20 73 1d	jsr $1d73			jsr 	GetReferenceTerm 			; get the variable.
.1cfe	48		pha				pha 								; save type.
.1cff	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1d01	c9 40		cmp #$40			cmp 	#NSSString
.1d03	f0 05		beq $1d0a			beq 	_CRString
.1d05	ad 0d 05	lda $050d			lda 	numberPCode 				; output read/input
.1d08	80 03		bra $1d0d			bra 	_CRHaveType
.1d0a					_CRString:
.1d0a	ad 0e 05	lda $050e			lda 	stringPCode					; output read$/input$
.1d0d					_CRHaveType:
.1d0d	20 d8 10	jsr $10d8			jsr 	WriteCodeByte 				; so we have one typed data item.
.1d10	68		pla				pla 								; restore type
.1d11	38		sec				sec  								; write update code.
.1d12	20 25 1d	jsr $1d25			jsr 	GetSetVariable
.1d15	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; , follows ?
.1d18	c9 2c		cmp #$2c			cmp 	#","
.1d1a	d0 05		bne $1d21			bne 	_CRExit 					; if not, end of READ.
.1d1c	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume comma
.1d1f	80 d2		bra $1cf3			bra 	_CRLoop 					; keep going
.1d21					_CRExit:
.1d21	60		rts				rts
.1d22					_CRSyntax:
.1d22	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.050d					numberPCode:
>050d							.fill 	1
.050e					stringPCode:
>050e							.fill 	1
.1d25					GetSetVariable:
.1d25	08		php				php 								; save direction on stack
.1d26	c0 00		cpy #$00			cpy 	#$00
.1d28	30 21		bmi $1d4b			bmi 	_GSVReadWriteSpecial
.1d2a	c9 00		cmp #$00			cmp 	#$00
.1d2c	30 33		bmi $1d61			bmi 	_GSVArray
.1d2e	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1d30	4a		lsr a				lsr 	a 							; divide by 2
.1d31	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1d33	28		plp				plp
.1d34	90 02		bcc $1d38			bcc 	_GSVNotWrite
.1d36	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1d38					_GSVNotWrite:
.1d38	85 2a		sta $2a				sta 	zTemp0
.1d3a	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1d3b	4a		lsr a				lsr 	a
.1d3c	a8		tay				tay
.1d3d	8a		txa				txa
.1d3e	6a		ror a				ror 	a
.1d3f	aa		tax				tax
.1d40	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1d41	05 2a		ora $2a				ora 	zTemp0 						; which is the first byte of the opcode
.1d43	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1d46	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1d47	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1d4a	60		rts				rts
.1d4b					_GSVReadWriteSpecial:
.1d4b	28		plp				plp
.1d4c	b0 10		bcs $1d5e			bcs 	_GSVSyntax
.1d4e	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1d50	f0 06		beq $1d58			beq 	_GSVRWString
.1d52	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1d54	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1d57	60		rts				rts
.1d58					_GSVRWString:
.1d58	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1d5a	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1d5d	60		rts				rts
.1d5e					_GSVSyntax:
.1d5e	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.1d61					_GSVArray:
.1d61	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1d63	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1d64	4a		lsr a				lsr 	a
.1d65	4a		lsr a				lsr 	a
.1d66	4a		lsr a				lsr 	a
.1d67	4a		lsr a				lsr 	a
.1d68	28		plp				plp 								; if writing array then set bit 2.
.1d69	90 02		bcc $1d6d			bcc 	_GSVANotWrite
.1d6b	09 04		ora #$04			ora 	#4
.1d6d					_GSVANotWrite:
.1d6d	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1d6f	20 d8 10	jsr $10d8			jsr 	WriteCodeByte 				; and write it out
.1d72	60		rts				rts
.1d73					GetReferenceTerm:
.1d73	20 97 1a	jsr $1a97			jsr 	ExtractVariableName 		; get name & type info
.1d76	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1d78	30 10		bmi $1d8a			bmi 	_GRTArray
.1d7a	da		phx				phx 								; save type on stack
.1d7b	20 91 14	jsr $1491			jsr 	FindVariable 				; find it
.1d7e	b0 06		bcs $1d86			bcs 	_GRTNoCreate 				; create if required.
.1d80	20 1b 12	jsr $121b			jsr 	CreateVariableRecord 		; create a variable.
.1d83	20 70 12	jsr $1270			jsr 	AllocateBytesForType 		; allocate memory for it
.1d86					_GRTNoCreate:
.1d86	68		pla				pla 								; get type back, strip out type information.
.1d87	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1d89	60		rts				rts
.1d8a					_GRTArray:
.1d8a	da		phx				phx 								; save type information
.1d8b	20 91 14	jsr $1491			jsr 	FindVariable 				; read its data, the base address in YX
.1d8e	90 18		bcc $1da8			bcc 	_GRTUndeclared 				; undeclared array.
.1d90	da		phx				phx 								; save base address
.1d91	5a		phy				phy
.1d92	20 67 13	jsr $1367			jsr 	OutputIndexGroup 			; create an index group and generate them
.1d95	7a		ply				ply 								; get the array base address into YX
.1d96	fa		plx				plx
.1d97	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1d99	18		clc				clc
.1d9a	20 25 1d	jsr $1d25			jsr 	GetSetVariable 				; load the address of the array structure.
.1d9d	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1d9f	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1da2	68		pla				pla 								; and the type data into A
.1da3	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1da5	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1da7	60		rts				rts
.1da8					_GRTUndeclared:
.1da8	4c c8 1f	jmp $1fc8		jmp	ErrorV_undeclared
.1dab					CommandREM:
.1dab	20 16 1a	jsr $1a16			jsr 	LookNext
.1dae	f0 05		beq $1db5			beq 	_CRExit
.1db0	20 27 1a	jsr $1a27			jsr 	GetNext
.1db3	80 f6		bra $1dab			bra 	CommandREM
.1db5					_CRExit:
.1db5	60		rts				rts
.1db6					STRReset:
.1db6	ad 07 05	lda $0507			lda	 	compilerStartHigh 			; set up the two table pointers
.1db9	8d 12 05	sta $0512			sta 	variableListEnd+1
.1dbc	9c 11 05	stz $0511			stz 	variableListEnd
.1dbf	ad 08 05	lda $0508			lda 	compilerEndHigh
.1dc2	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1dc5	9c 0f 05	stz $050f			stz 	lineNumberTable
.1dc8	ad 11 05	lda $0511			lda 	variableListEnd
.1dcb	85 2b		sta $2b				sta 	zTemp0+1
.1dcd	64 2a		stz $2a				stz 	zTemp0
.1dcf	a9 00		lda #$00			lda 	#0
.1dd1	92 2a		sta ($2a)			sta 	(zTemp0)
.1dd3	a9 00		lda #$00			lda 	#((0) & $FF)
.1dd5	8d 13 05	sta $0513			sta 	0+freeVariableMemory
.1dd8	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1dda	8d 14 05	sta $0514			sta 	1+freeVariableMemory
.1ddd	60		rts				rts
.050f					lineNumberTable:
>050f							.fill 	2
.0511					variableListEnd:
>0511							.fill 	2
.0513					freeVariableMemory:
>0513							.fill 	2
.1dde					CompileTerm:
.1dde	20 32 1a	jsr $1a32			jsr 	GetNextNonSpace 			; get first non space character.
.1de1	30 72		bmi $1e55			bmi 	_CTUnaryFunctions
.1de3	20 3c 1a	jsr $1a3c			jsr 	CharIsDigit 				; found a number
.1de6	b0 3a		bcs $1e22			bcs 	_CTDigit
.1de8	c9 2e		cmp #$2e			cmp 	#"."
.1dea	f0 36		beq $1e22			beq 	_CTDigit
.1dec	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1dee	f0 43		beq $1e33			beq 	_CTString
.1df0	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1df2	f0 28		beq $1e1c			beq 	_CTOtherBase
.1df4	c9 24		cmp #$24			cmp 	#"$"
.1df6	f0 24		beq $1e1c			beq 	_CTOtherBase
.1df8	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1dfa	f0 17		beq $1e13			beq 	_CTBrackets
.1dfc	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1dfe	90 10		bcc $1e10			bcc 	_CTSyntax
.1e00	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1e02	b0 0c		bcs $1e10			bcs 	_CTSyntax
.1e04	20 73 1d	jsr $1d73			jsr 	GetReferenceTerm 			; figure out what it is.
.1e07	48		pha				pha 								; save type on stack
.1e08	18		clc				clc 								; read it
.1e09	20 25 1d	jsr $1d25			jsr 	GetSetVariable
.1e0c	68		pla				pla
.1e0d	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1e0f	60		rts				rts
.1e10					_CTSyntax:
.1e10	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.1e13					_CTBrackets:
.1e13	20 d7 13	jsr $13d7			jsr 	CompileExpressionAt0
.1e16	48		pha				pha
.1e17	20 34 11	jsr $1134			jsr 	CheckNextRParen
.1e1a	68		pla				pla
.1e1b	60		rts				rts
.1e1c					_CTOtherBase:
.1e1c	20 86 10	jsr $1086			jsr 	InlineNonDecimal 			; non decimal constant handler
.1e1f	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e21	60		rts				rts
.1e22					_CTDigit:
.1e22	20 7b 1c	jsr $1c7b			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1e25	90 06		bcc $1e2d			bcc	 	_CTFloat 					; have a float or long int.
.1e27	20 d6 11	jsr $11d6			jsr 	PushIntegerYA 				; code to push on stack
.1e2a	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e2c	60		rts				rts
.1e2d					_CTFloat:
.1e2d	20 f8 11	jsr $11f8			jsr 	PushFloat  					; code to push float
.1e30	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1e32	60		rts				rts
.1e33					_CTString:
.1e33	20 09 11	jsr $1109			jsr 	BufferClear 				; copy it to the buffer
.1e36					_CTStringLoop:
.1e36	20 16 1a	jsr $1a16			jsr 	LookNext 					; reached EOL/EOS
.1e39	f0 d5		beq $1e10			beq 	_CTSyntax
.1e3b	c9 22		cmp #$22			cmp 	#'"'
.1e3d	f0 08		beq $1e47			beq 	_CTStringDone
.1e3f	20 0d 11	jsr $110d			jsr 	BufferWrite 				; write and consume
.1e42	20 27 1a	jsr $1a27			jsr 	GetNext
.1e45	80 ef		bra $1e36			bra 	_CTStringLoop
.1e47					_CTStringDone:
.1e47	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume closing quote.
.1e4a	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1e4c	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1e4f	20 19 11	jsr $1119			jsr 	BufferOutput
.1e52	a9 40		lda #$40			lda 	#NSSString 					; string type
.1e54	60		rts				rts
.1e55					_CTUnaryFunctions:
.1e55	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1e57	f0 0a		beq $1e63			beq 	_CTNegation
.1e59	a2 c1		ldx #$c1			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1e5b	a0 17		ldy #$17			ldy 	#UnaryTables >> 8
.1e5d	20 bb 18	jsr $18bb			jsr 	GeneratorProcess
.1e60	90 ae		bcc $1e10			bcc		_CTSyntax
.1e62	60		rts				rts
.1e63					_CTNegation:
.1e63	20 de 1d	jsr $1dde			jsr 	CompileTerm 				; compile a term.
.1e66	48		pha				pha
.1e67	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1e69	c9 00		cmp #$00			cmp 	#NSSIFloat
.1e6b	d0 07		bne $1e74			bne 	_CTType 					; error
.1e6d	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1e6f	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1e72	68		pla				pla 								; return original type.
.1e73	60		rts				rts
.1e74					_CTType:
.1e74	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.1e77					CommandWAIT:
.1e77	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace
.1e7a	c9 2c		cmp #$2c			cmp 	#","
.1e7c	f0 10		beq $1e8e			beq 	_CWThirdParameter
.1e7e	a9 00		lda #$00			lda 	#0
.1e80	20 e9 11	jsr $11e9			jsr 	PushIntegerA
.1e83					_CWExit:
.1e83	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1e85	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1e88	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1e8a	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1e8d	60		rts				rts
.1e8e					_CWThirdParameter:
.1e8e	20 27 1a	jsr $1a27			jsr 	GetNext
.1e91	20 d9 13	jsr $13d9			jsr 	CompileExpressionAtA
.1e94	29 40		and #$40			and 	#NSSTypeMask
.1e96	c9 00		cmp #$00			cmp 	#NSSIFloat
.1e98	f0 e9		beq $1e83			beq 	_CWExit
.1e9a	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.1e9d					CommandCMD:
.1e9d	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.1e9f	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1ea2	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; followed by a , ?
.1ea5	c9 2c		cmp #$2c			cmp 	#","
.1ea7	d0 06		bne $1eaf			bne 	_CCMDExit
.1ea9	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume comma.
.1eac	20 a0 1c	jsr $1ca0			jsr 	CommandPRINT 				; do the print code
.1eaf					_CCMDExit:
.1eaf	60		rts				rts
.1eb0					CommandOPEN:
.1eb0	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; followed by a , ?
.1eb3	c9 2c		cmp #$2c			cmp 	#","
.1eb5	d0 15		bne $1ecc			bne 	_COTwoDefaults
.1eb7	20 27 1a	jsr $1a27			jsr 	GetNext 					; consume comma
.1eba	20 d7 13	jsr $13d7			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1ebd	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1ebf	f0 1e		beq $1edf			beq 	_COThreeIntegers
.1ec1	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1ec3	20 e9 11	jsr $11e9			jsr 	PushIntegerA
.1ec6	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1ec8	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1ecb	60		rts				rts
.1ecc					_COTwoDefaults:
.1ecc	a9 00		lda #$00			lda 	#0
.1ece	20 e9 11	jsr $11e9			jsr 	PushIntegerA
.1ed1					_COCompileNullString:
.1ed1	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1ed3	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1ed6	a9 00		lda #$00			lda 	#0
.1ed8	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1edb	20 d8 10	jsr $10d8			jsr 	WriteCodeByte
.1ede	60		rts				rts
.1edf					_COThreeIntegers:
.1edf	20 19 1a	jsr $1a19			jsr 	LookNextNonSpace 			; is there a ,
.1ee2	c9 2c		cmp #$2c			cmp 	#","
.1ee4	d0 eb		bne $1ed1			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1ee6	20 27 1a	jsr $1a27			jsr 	GetNext
.1ee9	20 d7 13	jsr $13d7			jsr 	CompileExpressionAt0 		; should be a filename
.1eec	29 40		and #$40			and 	#NSSString
.1eee	f0 01		beq $1ef1			beq 	_COType
.1ef0	60		rts				rts
.1ef1					_COType:
.1ef1	4c 21 1f	jmp $1f21		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					objPtr:
>0028							.fill 	2
.002a					zTemp0:
>002a							.fill 	2
.002c					zTemp1:
>002c							.fill 	2
.002e					zTemp2:
>002e							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1ef4					ErrorV_range:
.1ef4	20 8f 13	jsr $138f		jsr	ErrorHandler
>1ef7	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1eff	41 4e 47 45 00
.1f04					ErrorV_value:
.1f04	20 8f 13	jsr $138f		jsr	ErrorHandler
>1f07	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f0f	45 00
.1f11					ErrorV_syntax:
.1f11	20 8f 13	jsr $138f		jsr	ErrorHandler
>1f14	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f1c	52 52 4f 52 00
.1f21					ErrorV_type:
.1f21	20 8f 13	jsr $138f		jsr	ErrorHandler
>1f24	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f2c	4d 41 54 43 48 00
.1f32					ErrorV_unimplemented:
.1f32	20 8f 13	jsr $138f		jsr	ErrorHandler
>1f35	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f3d	45 4d 45 4e 54 45 44 00
.1f45					ErrorV_assert:
.1f45	20 8f 13	jsr $138f		jsr	ErrorHandler
>1f48	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f50	41 49 4c 00
.1f54					ErrorV_line:
.1f54	20 8f 13	jsr $138f		jsr	ErrorHandler
>1f57	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f5f	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f6b					ErrorV_internal:
.1f6b	20 8f 13	jsr $138f		jsr	ErrorHandler
>1f6e	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f76	20 45 52 52 4f 52 00
.1f7d					ErrorV_divzero:
.1f7d	20 8f 13	jsr $138f		jsr	ErrorHandler
>1f80	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1f88	59 20 5a 45 52 4f 00
.1f8f					ErrorV_structure:
.1f8f	20 8f 13	jsr $138f		jsr	ErrorHandler
>1f92	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1f9a	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fa6					ErrorV_stop:
.1fa6	20 8f 13	jsr $138f		jsr	ErrorHandler
>1fa9	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fb1	53 54 4f 50 50 45 44 00
.1fb9					ErrorV_data:
.1fb9	20 8f 13	jsr $138f		jsr	ErrorHandler
>1fbc	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fc4	41 54 41 00
.1fc8					ErrorV_undeclared:
.1fc8	20 8f 13	jsr $138f		jsr	ErrorHandler
>1fcb	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1fd3	41 52 52 41 59 00
.1fd9					ErrorV_redefine:
.1fd9	20 8f 13	jsr $138f		jsr	ErrorHandler
>1fdc	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1fe4	44 45 46 49 4e 45 44 00
.1fec					ErrorV_index:
.1fec	20 8f 13	jsr $138f		jsr	ErrorHandler
>1fef	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1ff7	59 20 49 4e 44 45 58 00
.1fff					ErrorV_memory:
.1fff	20 8f 13	jsr $138f		jsr	ErrorHandler
>2002	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>200a	45 4d 4f 52 59 00
.2010					ErrorV_channel:
.2010	20 8f 13	jsr $138f		jsr	ErrorHandler
>2013	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>201b	54 50 55 54 20 45 52 52 4f 52 00
.2026					MoveObjectForward:
.2026	b2 28		lda ($28)			lda 	(objPtr) 					; get next
.2028	c9 ff		cmp #$ff			cmp 	#$FF
.202a	f0 36		beq $2062			beq 	_MOFEnd
.202c	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.202e	90 24		bcc $2054			bcc 	_MOFAdvance1 				; forward 1
.2030	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.2032	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2034	90 20		bcc $2056			bcc 	_MOFAdvanceY
.2036	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2038	90 1a		bcc $2054			bcc 	_MOFAdvance1 				; forward 1
.203a	a8		tay				tay 								; read the size.
.203b	b9 a0 1f	lda $1fa0,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.203e	a8		tay				tay
.203f	c8		iny				iny 								; add 1 for the system token.
.2040	d0 14		bne $2056			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2042	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2044	b1 28		lda ($28),y			lda 	(objPtr),y
.2046	a8		tay				tay 								; into Y.
.2047	18		clc				clc
.2048	a5 28		lda $28				lda 	objPtr						; add 2 to the object pointer
.204a	69 02		adc #$02			adc 	#2
.204c	85 28		sta $28				sta 	objPtr
.204e	90 02		bcc $2052			bcc 	_MOFNoCarry1
.2050	e6 29		inc $29				inc 	objPtr+1
.2052					_MOFNoCarry1:
.2052	80 02		bra $2056			bra 	_MOFAdvanceY
.2054					_MOFAdvance1:
.2054	a0 01		ldy #$01			ldy 	#1
.2056					_MOFAdvanceY:
.2056	98		tya				tya 								; add Y to objPtr
.2057	18		clc				clc
.2058	65 28		adc $28				adc 	objPtr
.205a	85 28		sta $28				sta 	objPtr
.205c	90 02		bcc $2060			bcc 	_MOFNoCarry2
.205e	e6 29		inc $29				inc 	objPtr+1
.2060					_MOFNoCarry2:
.2060	18		clc				clc 								; not completed.
.2061	60		rts				rts
.2062					_MOFEnd:
.2062	e6 28		inc $28				inc 	objPtr
.2064	d0 02		bne $2068			bne 	_MOFENoCarry
.2066	e6 29		inc $29				inc 	objPtr+1
.2068					_MOFENoCarry:
.2068	38		sec				sec
.2069	60		rts				rts
.206a					MOFSizeTable:
>206a	01					.byte	1         	; $ca .shift
>206b	01					.byte	1         	; $cb .byte
>206c	02					.byte	2         	; $cc .word
>206d	05					.byte	5         	; $cd .float
>206e	ff					.byte	255       	; $ce .string
>206f	ff					.byte	255       	; $cf .data
>2070	02					.byte	2         	; $d0 .goto
>2071	02					.byte	2         	; $d1 .gosub
>2072	02					.byte	2         	; $d2 .goto.z
>2073	02					.byte	2         	; $d3 .goto.nz
>2074	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0030					NSStatus:
>0030							.fill 	MathStackSize
.003c					NSMantissa0:
>003c							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0048					NSMantissa1:
>0048							.fill 	MathStackSize
.0054					NSMantissa2:
>0054							.fill 	MathStackSize
.0060					NSMantissa3:
>0060							.fill 	MathStackSize
.006c					NSExponent:
>006c							.fill 	MathStackSize
.0515					numberBuffer:
>0515							.fill 	34
.2075					FloatSubtract:
.2075	b5 30		lda $30,x			lda 	NSStatus,x 					; negate top of stack
.2077	49 80		eor #$80			eor 	#$80
.2079	95 30		sta $30,x			sta 	NSStatus,x					; and fall through.
.207b					FloatAdd:
.207b	ca		dex				dex
.207c	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised.
.207e	15 6d		ora $6d,x			ora 	NSExponent+1,x
.2080	15 60		ora $60,x			ora 	NSMantissa3,x
.2082	15 61		ora $61,x			ora 	NSMantissa3+1,x
.2084	d0 04		bne $208a			bne 	_FAUseFloat
.2086	20 17 24	jsr $2417			jsr 	FloatInt32Add 				; use the int32 one.
.2089	60		rts				rts
.208a					_FAUseFloat:
.208a	20 ac 23	jsr $23ac			jsr 	FloatNormalise 				; normalise S[X]
.208d	f0 51		beq $20e0			beq 	_FAReturn1
.208f	e8		inx				inx 								; normalise S[X+1]
.2090	20 ac 23	jsr $23ac			jsr 	FloatNormalise
.2093	ca		dex				dex
.2094	c9 00		cmp #$00			cmp 	#0
.2096	f0 60		beq $20f8			beq 	_FAExit 					; if so, just return A
.2098	b5 6c		lda $6c,x			lda 	NSExponent,x 				; are the exponents the same ?
.209a	d5 6d		cmp $6d,x			cmp 	NSExponent+1,x
.209c	f0 18		beq $20b6			beq 	_FAExponentsEqual
.209e	b5 6c		lda $6c,x			lda 	NSExponent,x 				; work out the larger exponent
.20a0	a8		tay				tay
.20a1	38		sec				sec 								; do a signed comparison of the exponents.
.20a2	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.20a4	50 02		bvc $20a8			bvc 	_FANoSignedChange
.20a6	49 80		eor #$80			eor 	#$80
.20a8					_FANoSignedChange:
.20a8	29 80		and #$80			and 	#$80
.20aa	10 02		bpl $20ae			bpl 	_FAHaveMax
.20ac	b4 6d		ldy $6d,x			ldy 	NSExponent+1,x
.20ae					_FAHaveMax:
.20ae	20 f9 20	jsr $20f9			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20b1	e8		inx				inx
.20b2	20 f9 20	jsr $20f9			jsr 	_FAShiftToExponent
.20b5	ca		dex				dex
.20b6					_FAExponentsEqual:
.20b6	b5 30		lda $30,x			lda 	NSStatus,x 					; are the signs the same
.20b8	55 31		eor $31,x			eor 	NSStatus+1,x
.20ba	30 0e		bmi $20ca			bmi 	_FADifferentSigns
.20bc	20 e3 23	jsr $23e3			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20bf	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20c1	10 35		bpl $20f8			bpl 	_FAExit 					; if no, we are done.
.20c3	20 70 26	jsr $2670			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20c6	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump the exponent and exit
.20c8	80 2e		bra $20f8			bra 	_FAExit
.20ca					_FADifferentSigns:
.20ca	20 fd 23	jsr $23fd			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20cd	b5 60		lda $60,x			lda 	NSMantissa3,x 				; is the result negative ?
.20cf	10 06		bpl $20d7			bpl 	_FACheckZero 				; if no, check for -0
.20d1	20 19 26	jsr $2619			jsr 	FloatNegate 					; netate result
.20d4	20 20 26	jsr $2620			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20d7					_FACheckZero:
.20d7	20 79 26	jsr $2679			jsr 	FloatIsZero	 				; check for -0
.20da	d0 1c		bne $20f8			bne 	_FAExit
.20dc	74 30		stz $30,x			stz 	NSStatus,x
.20de	80 18		bra $20f8			bra 	_FAExit
.20e0					_FAReturn1:
.20e0	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20e2	95 3c		sta $3c,x			sta 	NSMantissa0,x
.20e4	b5 49		lda $49,x			lda 	NSMantissa1+1,x
.20e6	95 48		sta $48,x			sta 	NSMantissa1,x
.20e8	b5 55		lda $55,x			lda 	NSMantissa2+1,x
.20ea	95 54		sta $54,x			sta 	NSMantissa2,x
.20ec	b5 61		lda $61,x			lda 	NSMantissa3+1,x
.20ee	95 60		sta $60,x			sta 	NSMantissa3,x
.20f0	b5 6d		lda $6d,x			lda 	NSExponent+1,x
.20f2	95 6c		sta $6c,x			sta 	NSExponent,x
.20f4	b5 31		lda $31,x			lda 	NSStatus+1,x
.20f6	95 30		sta $30,x			sta 	NSStatus,x
.20f8					_FAExit:
.20f8	60		rts				rts
.20f9					_FAShiftToExponent:
.20f9					_FAShiftToExponent2:
.20f9	98		tya				tya 								; compare Y to exponent
.20fa	d5 6c		cmp $6c,x			cmp 	NSExponent,x 				; reached the exponent required ?
.20fc	f0 07		beq $2105			beq 	_FASEExit 					; exit if so.
.20fe	20 70 26	jsr $2670			jsr 	FloatShiftRight	 			; shift the mantissa right
.2101	f6 6c		inc $6c,x			inc 	NSExponent,x 				; increment exponent
.2103	80 f4		bra $20f9			bra 	_FAShiftToExponent2
.2105					_FASEExit:
.2105	60		rts				rts
.2106					CompareEqual:
.2106	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2108	d0 09		bne $2113			bne 	ReturnFalse
.210a					ReturnTrue:
.210a	a9 01		lda #$01			lda 	#1
.210c	95 3c		sta $3c,x			sta 	NSMantissa0,x
.210e	a9 80		lda #$80			lda 	#$80
.2110	95 30		sta $30,x			sta 	NSStatus,x
.2112	60		rts				rts
.2113					ReturnFalse:
.2113	74 3c		stz $3c,x			stz 	NSMantissa0,x
.2115	60		rts				rts
.2116					CompareNotEqual:
.2116	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2118	d0 f0		bne $210a			bne 	ReturnTrue
.211a	80 f7		bra $2113			bra 	ReturnFalse
.211c					CompareLess:
.211c	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.211e	c9 ff		cmp #$ff			cmp 	#$FF
.2120	f0 e8		beq $210a			beq 	ReturnTrue
.2122	80 ef		bra $2113			bra 	ReturnFalse
.2124					CompareGreater:
.2124	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2126	c9 01		cmp #$01			cmp 	#$01
.2128	f0 e0		beq $210a			beq 	ReturnTrue
.212a	80 e7		bra $2113			bra 	ReturnFalse
.212c					CompareLessEqual:
.212c	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.212e	c9 01		cmp #$01			cmp 	#$01
.2130	d0 d8		bne $210a			bne 	ReturnTrue
.2132	80 df		bra $2113			bra 	ReturnFalse
.2134					CompareGreaterEqual:
.2134	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2136	c9 ff		cmp #$ff			cmp 	#$FF
.2138	d0 d0		bne $210a			bne 	ReturnTrue
.213a	80 d7		bra $2113			bra 	ReturnFalse
.213c					FloatCompare:
.213c	b5 6c		lda $6c,x			lda 	NSExponent,x 				; float comparison.
.213e	15 6b		ora $6b,x			ora 	NSExponent-1,x 				; integer if both integer.
.2140	48		pha				pha
.2141	20 75 20	jsr $2075			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2144	68		pla				pla
.2145	d0 0c		bne $2153			bne 	_FCCompareFloat
.2147	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2149	15 48		ora $48,x			ora 	NSMantissa1,x
.214b	15 54		ora $54,x			ora 	NSMantissa2,x
.214d	15 60		ora $60,x			ora 	NSMantissa3,x
.214f	f0 14		beq $2165			beq 	_FCExit 					; if zero, return zero
.2151	80 0a		bra $215d			bra 	_FCSign
.2153					_FCCompareFloat:
.2153	b5 48		lda $48,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2155	29 f0		and #$f0			and 	#$F0
.2157	15 54		ora $54,x			ora 	NSMantissa2,x
.2159	15 60		ora $60,x			ora 	NSMantissa3,x
.215b	f0 08		beq $2165			beq 	_FCExit 					; zero, so approximately identical
.215d					_FCSign:
.215d	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.215f	34 30		bit $30,x			bit 	NSStatus,x
.2161	10 02		bpl $2165			bpl 	_FCExit
.2163					_FCNegative:
.2163	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2165					_FCExit:
.2165	20 59 26	jsr $2659			jsr 	FloatSetByte 				; set the result 255,0,1
.2168	60		rts				rts
.2169					FloatScalarTable:
>2169	66 66 66 66				.dword $66666666 ; 0.1
>216d	de					.byte $de
>216e	1f 85 eb 51				.dword $51eb851f ; 0.01
>2172	db					.byte $db
>2173	4c 37 89 41				.dword $4189374c ; 0.001
>2177	d8					.byte $d8
>2178	ac 8b db 68				.dword $68db8bac ; 0.0001
>217c	d4					.byte $d4
>217d	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>2181	d1					.byte $d1
>2182	83 de 1b 43				.dword $431bde83 ; 1e-06
>2186	ce					.byte $ce
>2187	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>218b	ca					.byte $ca
>218c	89 3b e6 55				.dword $55e63b89 ; 1e-08
>2190	c7					.byte $c7
>2191	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>2195	c4					.byte $c4
>2196	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>219a	c0					.byte $c0
>219b	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>219f	bd					.byte $bd
.21a0					FloatDivide:
.21a0	48		pha				pha
.21a1	20 ac 23	jsr $23ac			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21a4	ca		dex				dex
.21a5	c9 00		cmp #$00			cmp 	#0
.21a7	f0 1e		beq $21c7			beq 	_FDZero
.21a9	20 ac 23	jsr $23ac			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21ac	f0 16		beq $21c4			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21ae	20 0f 22	jsr $220f			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21b1	20 dc 21	jsr $21dc			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21b4	20 ac 23	jsr $23ac			jsr		FloatNormalise 				; renormalise
.21b7	20 a2 23	jsr $23a2			jsr 	FloatCalculateSign 			; calculate result sign
.21ba	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent
.21bc	38		sec				sec
.21bd	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.21bf	38		sec				sec
.21c0	e9 1e		sbc #$1e			sbc 	#30
.21c2	95 6c		sta $6c,x			sta 	NSExponent,x
.21c4					_FDExit:
.21c4	68		pla				pla
.21c5	18		clc				clc
.21c6	60		rts				rts
.21c7					_FDZero:
.21c7	68		pla				pla
.21c8	38		sec				sec
.21c9	60		rts				rts
.21ca					DivideInt32:
.21ca	20 92 22	jsr $2292			jsr 	FloatIntegerPart 			; make both integers
.21cd	ca		dex				dex
.21ce	20 92 22	jsr $2292			jsr 	FloatIntegerPart
.21d1	20 ed 21	jsr $21ed			jsr 	Int32Divide 				; divide
.21d4	20 dc 21	jsr $21dc			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21d7	20 a2 23	jsr $23a2			jsr 	FloatCalculateSign 			; calculate result sign
.21da	18		clc				clc
.21db	60		rts				rts
.21dc					NSMCopyPlusTwoToZero:
.21dc	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21de	95 3c		sta $3c,x			sta 	NSMantissa0,x
.21e0	b5 4a		lda $4a,x			lda 	NSMantissa1+2,x
.21e2	95 48		sta $48,x			sta 	NSMantissa1,x
.21e4	b5 56		lda $56,x			lda 	NSMantissa2+2,x
.21e6	95 54		sta $54,x			sta 	NSMantissa2,x
.21e8	b5 62		lda $62,x			lda 	NSMantissa3+2,x
.21ea	95 60		sta $60,x			sta 	NSMantissa3,x
.21ec	60		rts				rts
.21ed					Int32Divide:
.21ed	48		pha				pha 								; save AXY
.21ee	5a		phy				phy
.21ef	20 3a 26	jsr $263a			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.21f2	20 53 26	jsr $2653			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.21f5	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.21f7					_I32DivideLoop:
.21f7	e8		inx				inx
.21f8	e8		inx				inx
.21f9	20 66 26	jsr $2666			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.21fc	ca		dex				dex
.21fd	ca		dex				dex
.21fe	20 67 26	jsr $2667			jsr 	FloatRotateLeft
.2201	20 2d 22	jsr $222d			jsr 	FloatDivideCheck 			; check if subtract possible
.2204	90 02		bcc $2208			bcc 	_I32DivideNoCarryIn
.2206	f6 3e		inc $3e,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2208					_I32DivideNoCarryIn:
.2208	88		dey				dey 								; loop round till division completed.
.2209	d0 ec		bne $21f7			bne 	_I32DivideLoop
.220b	7a		ply				ply 								; restore AXY and exit
.220c	68		pla				pla
.220d	18		clc				clc
.220e	60		rts				rts
.220f					Int32ShiftDivide:
.220f	48		pha				pha 								; save AY
.2210	5a		phy				phy
.2211	e8		inx				inx 								; clear S[X+2]
.2212	e8		inx				inx
.2213	20 57 26	jsr $2657			jsr 	FloatSetZero
.2216	ca		dex				dex
.2217	ca		dex				dex
.2218	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.221a					_I32SDLoop:
.221a	20 2d 22	jsr $222d			jsr 	FloatDivideCheck 			; check if subtract possible
.221d	e8		inx				inx
.221e	e8		inx				inx
.221f	20 67 26	jsr $2667			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.2222	ca		dex				dex
.2223	ca		dex				dex
.2224	20 67 26	jsr $2667			jsr 	FloatRotateLeft
.2227	88		dey				dey 	 							; do 31 times
.2228	d0 f0		bne $221a			bne 	_I32SDLoop
.222a	7a		ply				ply 								; restore AY and exit
.222b	68		pla				pla
.222c	60		rts				rts
.222d					FloatDivideCheck:
.222d	20 fd 23	jsr $23fd			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.2230	b0 04		bcs $2236			bcs 	_DCSExit 					; if carry set, then could do, exit
.2232	20 e3 23	jsr $23e3			jsr 	FloatAddTopTwoStack 		; add it back in
.2235	18		clc				clc 								; and return False
.2236					_DCSExit:
.2236	60		rts				rts
.2237					FloatFractionalPart:
.2237	5a		phy				phy
.2238	b5 30		lda $30,x			lda 	NSStatus,x 					; take absolute value
.223a	29 7f		and #$7f			and 	#$7F
.223c	95 30		sta $30,x			sta 	NSStatus,x
.223e	20 ac 23	jsr $23ac			jsr 	FloatNormalise
.2241	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2243	38		sec				sec
.2244	e9 e0		sbc #$e0			sbc 	#$E0
.2246	90 29		bcc $2271			bcc 	_FFPExit 					; already fractional
.2248	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.224a	b0 22		bcs $226e			bcs 	_FFPZero
.224c	a8		tay				tay 								; put count to do in Y
.224d	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do each in turn.
.224f	20 76 22	jsr $2276			jsr 	_FFPPartial
.2252	95 60		sta $60,x			sta 	NSMantissa3,x
.2254	b5 54		lda $54,x			lda 	NSMantissa2,x
.2256	20 76 22	jsr $2276			jsr 	_FFPPartial
.2259	95 54		sta $54,x			sta 	NSMantissa2,x
.225b	b5 48		lda $48,x			lda 	NSMantissa1,x
.225d	20 76 22	jsr $2276			jsr 	_FFPPartial
.2260	95 48		sta $48,x			sta 	NSMantissa1,x
.2262	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2264	20 76 22	jsr $2276			jsr 	_FFPPartial
.2267	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2269	20 79 26	jsr $2679			jsr 	FloatIsZero 					; zeroed check.
.226c	d0 03		bne $2271			bne 	_FFPExit
.226e					_FFPZero:
.226e	20 57 26	jsr $2657			jsr 	FloatSetZero
.2271					_FFPExit:
.2271	20 ac 23	jsr $23ac			jsr 	FloatNormalise
.2274	7a		ply				ply
.2275	60		rts				rts
.2276					_FFPPartial:
.2276	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2278	f0 17		beq $2291			beq 	_FFFPPExit
.227a	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.227c	b0 0c		bcs $228a			bcs 	_FFFPPWholeByte
.227e	5a		phy				phy
.227f					_FFFPPLeft:
.227f	0a		asl a				asl 	a
.2280	88		dey				dey
.2281	d0 fc		bne $227f			bne 	_FFFPPLeft
.2283	7a		ply				ply
.2284					_FFFPPRight:
.2284	4a		lsr a				lsr 	a
.2285	88		dey				dey
.2286	d0 fc		bne $2284			bne 	_FFFPPRight
.2288	80 07		bra $2291			bra 	_FFFPPExit
.228a					_FFFPPWholeByte:
.228a	98		tya				tya 								; subtract 8 from count
.228b	38		sec				sec
.228c	e9 08		sbc #$08			sbc 	#8
.228e	a8		tay				tay
.228f	a9 00		lda #$00			lda 	#0 							; and clear all
.2291					_FFFPPExit:
.2291	60		rts				rts
.2292					FloatIntegerPart:
.2292	48		pha				pha
.2293	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.2295	f0 1d		beq $22b4			beq 	_FIPExit 					; if so do nothing
.2297	20 79 26	jsr $2679			jsr 	FloatIsZero 				; is it zero ?
.229a	f0 15		beq $22b1			beq 	_FIPZero 					; if so return zero.
.229c	20 ac 23	jsr $23ac			jsr 	FloatNormalise 				; normalise
.229f	f0 10		beq $22b1			beq 	_FIPZero 					; normalised to zero, exit zero
.22a1					_FIPShift:
.22a1	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22a3	10 07		bpl $22ac			bpl 	_FIPCheckZero
.22a5	20 70 26	jsr $2670			jsr 	FloatShiftRight 			; shift mantissa right
.22a8	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.22aa	80 f5		bra $22a1			bra 	_FIPShift
.22ac					_FIPCheckZero:
.22ac	20 79 26	jsr $2679			jsr 	FloatIsZero 				; avoid -0 problem
.22af	d0 03		bne $22b4			bne 	_FIPExit 					; set to zero if mantissa zero.
.22b1					_FIPZero:
.22b1	20 57 26	jsr $2657			jsr 	FloatSetZero
.22b4					_FIPExit:
.22b4	68		pla				pla
.22b5	60		rts				rts
.22b6					FloatIntegerPartDown:
.22b6	48		pha				pha
.22b7	5a		phy				phy
.22b8	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.22ba	f0 36		beq $22f2			beq 	_FIPExit 					; if so do nothing
.22bc	20 79 26	jsr $2679			jsr 	FloatIsZero 				; is it zero ?
.22bf	f0 2e		beq $22ef			beq 	_FIPZero 					; if so return zero.
.22c1	20 ac 23	jsr $23ac			jsr 	FloatNormalise 				; normalise
.22c4	f0 29		beq $22ef			beq 	_FIPZero 					; normalised to zero, exit zero
.22c6	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22c8					_FIPShift:
.22c8	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22ca	10 0a		bpl $22d6			bpl 	_FIPCheckDown
.22cc	20 70 26	jsr $2670			jsr 	FloatShiftRight 			; shift mantissa right
.22cf	90 01		bcc $22d2			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22d1	c8		iny				iny
.22d2					_FIPNoFrac:
.22d2	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.22d4	80 f2		bra $22c8			bra 	_FIPShift
.22d6					_FIPCheckDown:
.22d6	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22d8	f0 10		beq $22ea			beq 	_FIPCheckZero
.22da	34 30		bit $30,x			bit 	NSStatus,x 					; +ve
.22dc	10 0c		bpl $22ea			bpl 	_FIPCheckZero
.22de	e8		inx				inx 								; -ve so round *down*.
.22df	a9 01		lda #$01			lda 	#1
.22e1	20 59 26	jsr $2659			jsr 	FloatSetByte
.22e4	20 19 26	jsr $2619			jsr 	FloatNegate
.22e7	20 7b 20	jsr $207b			jsr 	FloatAdd
.22ea					_FIPCheckZero:
.22ea	20 79 26	jsr $2679			jsr 	FloatIsZero 				; avoid -0 problem
.22ed	d0 03		bne $22f2			bne 	_FIPExit 					; set to zero if mantissa zero.
.22ef					_FIPZero:
.22ef	20 57 26	jsr $2657			jsr 	FloatSetZero
.22f2					_FIPExit:
.22f2	7a		ply				ply
.22f3	68		pla				pla
.22f4	60		rts				rts
.22f5					FloatInt8Multiply:
.22f5	5a		phy				phy
.22f6	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.22f8	a8		tay				tay
.22f9	74 3c		stz $3c,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.22fb					_FI8MLoop:
.22fb	98		tya				tya 								; shift right shifter right into carry
.22fc	4a		lsr a				lsr 	a
.22fd	a8		tay				tay
.22fe	90 0d		bcc $230d			bcc 	_FI8MNoAdd
.2300	18		clc				clc
.2301	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.2303	75 3d		adc $3d,x			adc 	NSMantissa0+1,x
.2305	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2307	b5 48		lda $48,x			lda 	NSMantissa1,x
.2309	75 49		adc $49,x			adc 	NSMantissa1+1,x
.230b	95 48		sta $48,x			sta 	NSMantissa1,x
.230d					_FI8MNoAdd:
.230d	16 3d		asl $3d,x			asl 	NSMantissa0+1,x 			; shift adder left
.230f	36 49		rol $49,x			rol 	NSMantissa1+1,x
.2311	c0 00		cpy #$00			cpy 	#0
.2313	d0 e6		bne $22fb			bne 	_FI8MLoop 					; until right shifter zero.
.2315	7a		ply				ply
.2316	60		rts				rts
.2317					FloatMultiply:
.2317	ca		dex				dex
.2318	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised ?
.231a	15 6d		ora $6d,x			ora 	NSExponent+1,x
.231c	15 60		ora $60,x			ora 	NSMantissa3,x
.231e	15 61		ora $61,x			ora 	NSMantissa3+1,x
.2320	d0 21		bne $2343			bne 	_FMUseFloat
.2322	b5 30		lda $30,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2324	15 31		ora $31,x			ora 	NSStatus+1,x
.2326	29 80		and #$80			and 	#$80
.2328	15 60		ora $60,x			ora 	NSMantissa3,x
.232a	15 54		ora $54,x			ora 	NSMantissa2,x
.232c	15 48		ora $48,x			ora 	NSMantissa1,x
.232e	15 61		ora $61,x			ora 	NSMantissa3+1,x
.2330	15 55		ora $55,x			ora 	NSMantissa2+1,x
.2332	15 49		ora $49,x			ora 	NSMantissa1+1,x
.2334	d0 04		bne $233a			bne 	_FMInt32
.2336	20 f5 22	jsr $22f5			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2339	60		rts				rts
.233a					_FMInt32:
.233a	20 64 23	jsr $2364			jsr 	FloatMultiplyShort			; use the int32 one.
.233d	18		clc				clc 								; fix it up if gone out of range
.233e	75 6c		adc $6c,x			adc 	NSExponent,x
.2340	95 6c		sta $6c,x			sta 	NSExponent,x
.2342	60		rts				rts
.2343					_FMUseFloat:
.2343	20 ac 23	jsr $23ac			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2346	f0 18		beq $2360			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2348	e8		inx				inx
.2349	20 ac 23	jsr $23ac			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.234c	ca		dex				dex
.234d	c9 00		cmp #$00			cmp 	#0
.234f	f0 0c		beq $235d			beq 	_FDSetZero
.2351	20 64 23	jsr $2364			jsr 	FloatMultiplyShort 			; calculate the result.
.2354	75 6c		adc $6c,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2356	18		clc				clc
.2357	75 6d		adc $6d,x			adc 	NSExponent+1,x
.2359	95 6c		sta $6c,x			sta 	NSExponent,x
.235b	80 03		bra $2360			bra 	_FDExit
.235d					_FDSetZero:
.235d	20 57 26	jsr $2657			jsr 	FloatSetZero 				; return 0
.2360					_FDExit:
.2360	20 ac 23	jsr $23ac			jsr 	FloatNormalise 				; normalise the result
.2363	60		rts				rts
.2364					FloatMultiplyShort:
.2364	5a		phy				phy 								; save Y
.2365	20 3a 26	jsr $263a			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2368	20 53 26	jsr $2653			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.236b	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.236d					_I32MLoop:
.236d	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.236f	15 4a		ora $4a,x			ora 	NSMantissa1+2,x
.2371	15 56		ora $56,x			ora 	NSMantissa2+2,x
.2373	15 62		ora $62,x			ora 	NSMantissa3+2,x
.2375	f0 25		beq $239c			beq 	_I32MExit 					; exit if zero
.2377	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2379	29 01		and #$01			and 	#1
.237b	f0 0d		beq $238a			beq 	_I32MNoAdd
.237d	20 e3 23	jsr $23e3			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.2380	b5 60		lda $60,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.2382	10 06		bpl $238a			bpl 	_I32MNoAdd
.2384					_I32ShiftRight:
.2384	20 70 26	jsr $2670			jsr 	FloatShiftRight 			; shift S[X] right
.2387	c8		iny				iny 								; increment shift count
.2388	80 09		bra $2393			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.238a					_I32MNoAdd:
.238a	34 61		bit $61,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.238c	70 f6		bvs $2384			bvs 	_I32ShiftRight 				; instead.
.238e	e8		inx				inx
.238f	20 66 26	jsr $2666			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.2392	ca		dex				dex
.2393					_I32MShiftUpper:
.2393	e8		inx				inx 								; shift S[X+2] right
.2394	e8		inx				inx
.2395	20 70 26	jsr $2670			jsr 	FloatShiftRight
.2398	ca		dex				dex
.2399	ca		dex				dex
.239a	80 d1		bra $236d			bra 	_I32MLoop 					; try again.
.239c					_I32MExit:
.239c	20 a2 23	jsr $23a2			jsr 	FloatCalculateSign
.239f	98		tya				tya 								; shift in A
.23a0	7a		ply				ply 								; restore Y and exit
.23a1	60		rts				rts
.23a2					FloatCalculateSign:
.23a2	b5 30		lda $30,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23a4	16 30		asl $30,x			asl 	NSStatus,x 					; shift result left
.23a6	55 31		eor $31,x			eor 	NSStatus+1,x
.23a8	0a		asl a				asl 	a 							; shift bit 7 into carry
.23a9	76 30		ror $30,x			ror 	NSStatus,x 					; shift right into status byte.
.23ab	60		rts				rts
.23ac					FloatNormalise:
.23ac	20 79 26	jsr $2679			jsr 	FloatIsZero 				; if zero exit
.23af	d0 07		bne $23b8			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23b1	16 30		asl $30,x			asl 	NSStatus,x 					; clear the sign bit.
.23b3	76 30		ror $30,x			ror 	NSStatus,x 					; (no -0)
.23b5	a9 00		lda #$00			lda 	#0 							; set Z flag
.23b7	60		rts				rts
.23b8					_NSNormaliseOptimise:
.23b8	b5 60		lda $60,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23ba	d0 19		bne $23d5			bne 	_NSNormaliseLoop
.23bc	b5 54		lda $54,x			lda 	NSMantissa2,x 				; byte normalise
.23be	30 15		bmi $23d5			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23c0	95 60		sta $60,x			sta 	NSMantissa3,x
.23c2	b5 48		lda $48,x			lda 	NSMantissa1,x
.23c4	95 54		sta $54,x			sta 	NSMantissa2,x
.23c6	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.23c8	95 48		sta $48,x			sta 	NSMantissa1,x
.23ca	74 3c		stz $3c,x			stz 	NSMantissa0,x
.23cc	b5 6c		lda $6c,x			lda 	NSExponent,x
.23ce	38		sec				sec
.23cf	e9 08		sbc #$08			sbc 	#8
.23d1	95 6c		sta $6c,x			sta 	NSExponent,x
.23d3	80 e3		bra $23b8			bra 	_NSNormaliseOptimise
.23d5					_NSNormaliseLoop:
.23d5	34 60		bit $60,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23d7	70 07		bvs $23e0			bvs 	_NSNExit 					; exit if so with Z flag clear
.23d9	20 66 26	jsr $2666			jsr 	FloatShiftLeft 				; shift mantissa left
.23dc	d6 6c		dec $6c,x			dec 	NSExponent,x 				; adjust exponent
.23de	80 f5		bra $23d5			bra 	_NSNormaliseLoop
.23e0					_NSNExit:
.23e0	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23e2	60		rts				rts
.23e3					FloatAddTopTwoStack:
.23e3	18		clc				clc
.23e4	b5 3c		lda $3c,x			lda		NSMantissa0,x
.23e6	75 3d		adc $3d,x			adc 		NSMantissa0+1,x
.23e8	95 3c		sta $3c,x			sta 	NSMantissa0,x
.23ea	b5 48		lda $48,x			lda		NSMantissa1,x
.23ec	75 49		adc $49,x			adc 		NSMantissa1+1,x
.23ee	95 48		sta $48,x			sta 	NSMantissa1,x
.23f0	b5 54		lda $54,x			lda		NSMantissa2,x
.23f2	75 55		adc $55,x			adc 		NSMantissa2+1,x
.23f4	95 54		sta $54,x			sta 	NSMantissa2,x
.23f6	b5 60		lda $60,x			lda		NSMantissa3,x
.23f8	75 61		adc $61,x			adc 		NSMantissa3+1,x
.23fa	95 60		sta $60,x			sta 	NSMantissa3,x
.23fc	60		rts				rts
.23fd					FloatSubTopTwoStack:
.23fd	38		sec				sec
.23fe	b5 3c		lda $3c,x			lda		NSMantissa0,x
.2400	f5 3d		sbc $3d,x			sbc 		NSMantissa0+1,x
.2402	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2404	b5 48		lda $48,x			lda		NSMantissa1,x
.2406	f5 49		sbc $49,x			sbc 		NSMantissa1+1,x
.2408	95 48		sta $48,x			sta 	NSMantissa1,x
.240a	b5 54		lda $54,x			lda		NSMantissa2,x
.240c	f5 55		sbc $55,x			sbc 		NSMantissa2+1,x
.240e	95 54		sta $54,x			sta 	NSMantissa2,x
.2410	b5 60		lda $60,x			lda		NSMantissa3,x
.2412	f5 61		sbc $61,x			sbc 		NSMantissa3+1,x
.2414	95 60		sta $60,x			sta 	NSMantissa3,x
.2416	60		rts				rts
.2417					FloatInt32Add:
.2417	b5 30		lda $30,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2419	55 31		eor $31,x			eor 	NSStatus+1,x
.241b	30 04		bmi $2421			bmi 	_DiffSigns
.241d	20 e3 23	jsr $23e3			jsr		FloatAddTopTwoStack
.2420	60		rts				rts
.2421					_DiffSigns:
.2421	20 fd 23	jsr $23fd			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2424	34 60		bit $60,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2426	10 07		bpl $242f			bpl 	_AddExit
.2428	b5 31		lda $31,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.242a	95 30		sta $30,x			sta 	NSStatus,x
.242c	20 20 26	jsr $2620			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.242f					_AddExit:
.242f	20 79 26	jsr $2679			jsr 	FloatIsZero 				; check for -0
.2432	d0 02		bne $2436			bne 	_AddNonZero
.2434	74 30		stz $30,x			stz 	NSStatus,x
.2436					_AddNonZero:
.2436	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2437					FloatEncodeStart:
.2437	38		sec				sec
.2438	80 01		bra $243b			bra 	FloatEncodeContinue+1
.243a					FloatEncodeContinue:
.243a	18		clc				clc
.243b					FloatEncode:
.243b	08		php				php 								; save reset flag.
.243c	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.243e	f0 15		beq $2455			beq 	_ENIsOkay
.2440	c9 30		cmp #$30			cmp 	#"0"
.2442	90 04		bcc $2448			bcc 	_ENBadNumber
.2444	c9 3a		cmp #$3a			cmp 	#"9"+1
.2446	90 0d		bcc $2455			bcc 	_ENIsOkay
.2448					_ENBadNumber:
.2448	28		plp				plp 								; throw saved reset
.2449	ad 37 05	lda $0537			lda 	encodeState 				; if in decimal mode, construct final number
.244c	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.244e	d0 03		bne $2453			bne 	_ENFail
.2450	4c cd 24	jmp $24cd			jmp 	_ENConstructFinal
.2453					_ENFail:
.2453	18		clc				clc 								; not allowed
.2454	60		rts				rts
.2455					_ENIsOkay:
.2455	28		plp				plp 								; are we restarting
.2456	90 15		bcc $246d			bcc 	_ENNoRestart
.2458					_ENStartEncode:
.2458	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.245a	f0 0c		beq $2468			beq 	_ENFirstDP
.245c	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.245e	20 59 26	jsr $2659			jsr 	FloatSetByte 				; in single byte mode.
.2461	a9 01		lda #$01			lda 	#ESTA_Low
.2463					_ENExitChange:
.2463	8d 37 05	sta $0537			sta 	encodeState 				; save new state
.2466	38		sec				sec
.2467	60		rts				rts
.2468					_ENFirstDP:
.2468	20 57 26	jsr $2657			jsr 	FloatSetZero 				; clear integer part
.246b	80 3c		bra $24a9			bra 	_ESTASwitchFloat			; go straight to float and exi
.246d					_ENNoRestart:
.246d	48		pha				pha 								; save digit or DP on stack.
.246e	ad 37 05	lda $0537			lda 	encodeState 				; get current state
.2471	c9 01		cmp #$01			cmp 	#ESTA_Low
.2473	f0 09		beq $247e			beq  	_ESTALowState
.2475	c9 02		cmp #$02			cmp 	#ESTA_High
.2477	f0 26		beq $249f			beq 	_ESTAHighState
.2479	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.247b	f0 38		beq $24b5			beq 	_ESTADecimalState
>247d	db						.byte 	$DB 						; causes a break in the emulator
.247e					_ESTALowState:
.247e	68		pla				pla 								; get value back
.247f	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.2481	f0 26		beq $24a9			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.2483	29 0f		and #$0f			and 	#15 						; make digit
.2485	8d 38 05	sta $0538			sta 	digitTemp 					; save it.
.2488	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.248a	0a		asl a				asl 	a
.248b	0a		asl a				asl 	a
.248c	75 3c		adc $3c,x			adc 	NSMantissa0,x
.248e	0a		asl a				asl 	a
.248f	6d 38 05	adc $0538			adc 	digitTemp
.2492	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2494	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.2496	90 05		bcc $249d			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.2498	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.249a	8d 37 05	sta $0537			sta 	encodeState
.249d					_ESTANoSwitch:
.249d	38		sec				sec
.249e	60		rts				rts
.249f					_ESTAHighState:
.249f	68		pla				pla 								; get value back
.24a0	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24a2	f0 05		beq $24a9			beq 	_ESTASwitchFloat
.24a4	20 ff 24	jsr $24ff			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24a7	38		sec				sec
.24a8	60		rts				rts
.24a9					_ESTASwitchFloat:
.24a9	9c 39 05	stz $0539			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24ac	e8		inx				inx 								; zero the decimal additive.
.24ad	20 57 26	jsr $2657			jsr 	FloatSetZero
.24b0	ca		dex				dex
.24b1	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24b3	80 ae		bra $2463			bra 	_ENExitChange
.24b5					_ESTADecimalState:
.24b5	68		pla				pla 								; digit.
.24b6	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24b8	f0 99		beq $2453			beq 	_ENFail
.24ba	e8		inx				inx 								; put digit into fractional part of X+1
.24bb	20 ff 24	jsr $24ff			jsr 	ESTAShiftDigitIntoMantissa
.24be	ca		dex				dex
.24bf	ee 39 05	inc $0539			inc 	decimalCount 				; bump the count of decimals
.24c2	ad 39 05	lda $0539			lda 	decimalCount 				; too many decimal digits.
.24c5	c9 0b		cmp #$0b			cmp 	#11
.24c7	f0 02		beq $24cb			beq 	_ESTADSFail
.24c9	38		sec				sec
.24ca	60		rts				rts
.24cb					_ESTADSFail:
.24cb	18		clc				clc
.24cc	60		rts				rts
.24cd					_ENConstructFinal:
.24cd	ad 39 05	lda $0539			lda 	decimalCount 				; get decimal count
.24d0	f0 2b		beq $24fd			beq 	_ENCFExit 					; no decimals
.24d2	5a		phy				phy
.24d3	0a		asl a				asl 	a 							; x 4 and CLC
.24d4	0a		asl a				asl 	a
.24d5	6d 39 05	adc $0539			adc 	decimalCount
.24d8	a8		tay				tay
.24d9	b9 64 21	lda $2164,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24dc	95 3e		sta $3e,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24de	b9 65 21	lda $2165,y			lda 	FloatScalarTable-5+1,y
.24e1	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.24e3	b9 66 21	lda $2166,y			lda 	FloatScalarTable-5+2,y
.24e6	95 56		sta $56,x			sta 	NSMantissa2+2,x
.24e8	b9 67 21	lda $2167,y			lda 	FloatScalarTable-5+3,y
.24eb	95 62		sta $62,x			sta 	NSMantissa3+2,x
.24ed	b9 68 21	lda $2168,y			lda 	FloatScalarTable-5+4,y
.24f0	95 6e		sta $6e,x			sta 	NSExponent+2,x
.24f2	74 32		stz $32,x			stz 	NSStatus+2,x 				; make +ve
.24f4	e8		inx				inx 								; multiply decimal const by decimal scalar
.24f5	e8		inx				inx
.24f6	20 17 23	jsr $2317			jsr 	FloatMultiply
.24f9	20 7b 20	jsr $207b			jsr 	FloatAdd 					; add to integer part.
.24fc	7a		ply				ply
.24fd					_ENCFExit:
.24fd	18		clc				clc 								; reject the digit.
.24fe	60		rts				rts
.24ff					ESTAShiftDigitIntoMantissa:
.24ff	29 0f		and #$0f			and 	#15 						; save digit
.2501	48		pha				pha
.2502	b5 60		lda $60,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2504	48		pha				pha
.2505	b5 54		lda $54,x			lda 	NSMantissa2,x
.2507	48		pha				pha
.2508	b5 48		lda $48,x			lda 	NSMantissa1,x
.250a	48		pha				pha
.250b	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.250d	48		pha				pha
.250e	20 66 26	jsr $2666			jsr 	FloatShiftLeft 				; x 2
.2511	20 66 26	jsr $2666			jsr 	FloatShiftLeft 				; x 4
.2514	18		clc				clc 								; pop mantissa and add
.2515	68		pla				pla
.2516	75 3c		adc $3c,x			adc 	NSMantissa0,x
.2518	95 3c		sta $3c,x			sta 	NSMantissa0,x
.251a	68		pla				pla
.251b	75 48		adc $48,x			adc 	NSMantissa1,x
.251d	95 48		sta $48,x			sta 	NSMantissa1,x
.251f	68		pla				pla
.2520	75 54		adc $54,x			adc 	NSMantissa2,x
.2522	95 54		sta $54,x			sta 	NSMantissa2,x
.2524	68		pla				pla
.2525	75 60		adc $60,x			adc 	NSMantissa3,x
.2527	95 60		sta $60,x			sta 	NSMantissa3,x 				; x 5
.2529	20 66 26	jsr $2666			jsr 	FloatShiftLeft 				; x 10
.252c	68		pla				pla 								; add digit
.252d	18		clc				clc
.252e	75 3c		adc $3c,x			adc 	NSMantissa0,x
.2530	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2532	90 0a		bcc $253e			bcc 	_ESTASDExit
.2534	f6 48		inc $48,x			inc 	NSMantissa1,x
.2536	d0 06		bne $253e			bne 	_ESTASDExit
.2538	f6 54		inc $54,x			inc 	NSMantissa2,x
.253a	d0 02		bne $253e			bne 	_ESTASDExit
.253c	f6 60		inc $60,x			inc 	NSMantissa3,x
.253e					_ESTASDExit:
.253e	60		rts				rts
.0537					encodeState:
>0537							.fill 	1
.0538					digitTemp:
>0538							.fill 	1
.0539					decimalCount:
>0539							.fill 	1
.253f					FloatToString:
.253f	da		phx				phx
.2540	5a		phy				phy 								; save code position
.2541	8d 3a 05	sta $053a			sta 	decimalPlaces	 			; save number of DPs.
.2544	9c 3b 05	stz $053b			stz 	dbOffset 					; offset into decimal buffer = start.
.2547	b5 30		lda $30,x			lda 	NSStatus,x  				; is it -ve.
.2549	10 08		bpl $2553			bpl 	_CNTSNotNegative
.254b	29 7f		and #$7f			and 	#$7F 						; make +ve
.254d	95 30		sta $30,x			sta 	NSStatus,x
.254f	a9 2d		lda #$2d			lda 	#"-"
.2551	80 02		bra $2555			bra 	_CNTMain
.2553					_CNTSNotNegative:
.2553	a9 20		lda #$20			lda 	#" "
.2555					_CNTMain:
.2555	20 b7 25	jsr $25b7			jsr 	WriteDecimalBuffer
.2558	b5 6c		lda $6c,x			lda 	NSExponent,x 				; check if decimal
.255a	f0 0d		beq $2569			beq 	_CNTSNotFloat
.255c	e8		inx				inx 								; round up so we don't get too many 6.999999
.255d	a9 01		lda #$01			lda 	#1
.255f	20 59 26	jsr $2659			jsr 	FloatSetByte
.2562	b5 6b		lda $6b,x			lda		NSExponent-1,x
.2564	95 6c		sta $6c,x			sta 	NSExponent,x
.2566	20 7b 20	jsr $207b			jsr 	FloatAdd
.2569					_CNTSNotFloat:
.2569	20 99 25	jsr $2599			jsr 	MakePlusTwoString 			; do the integer part.
.256c	20 37 22	jsr $2237			jsr 	FloatFractionalPart 		; get the fractional part
.256f	20 ac 23	jsr $23ac			jsr 	FloatNormalise					; normalise , exit if zero
.2572	f0 22		beq $2596			beq 	_CNTSExit
.2574	a9 2e		lda #$2e			lda 	#"."
.2576	20 b7 25	jsr $25b7			jsr 	WriteDecimalBuffer 			; write decimal place
.2579					_CNTSDecimal:
.2579	ce 3a 05	dec $053a			dec 	decimalPlaces 				; done all the decimals
.257c	30 18		bmi $2596			bmi 	_CNTSExit
.257e	e8		inx				inx 								; x 10.0
.257f	a9 0a		lda #$0a			lda 	#10
.2581	20 59 26	jsr $2659			jsr 	FloatSetByte
.2584	20 17 23	jsr $2317			jsr 	FloatMultiply
.2587	20 99 25	jsr $2599			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.258a	20 37 22	jsr $2237			jsr 	FloatFractionalPart 		; get the fractional part
.258d	20 ac 23	jsr $23ac			jsr 	FloatNormalise 				; normalise it.
.2590	b5 6c		lda $6c,x			lda 	NSExponent,x 				; gone to zero, exit.
.2592	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.2594	b0 e3		bcs $2579			bcs 	_CNTSDecimal 				; keep going.
.2596					_CNTSExit:
.2596	7a		ply				ply
.2597	fa		plx				plx
.2598	60		rts				rts
.2599					MakePlusTwoString:
.2599	da		phx				phx
.259a	20 3a 26	jsr $263a			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.259d	e8		inx				inx 								; access it
.259e	e8		inx				inx
.259f	20 92 22	jsr $2292			jsr 	FloatIntegerPart 			; make it an integer
.25a2	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25a4	20 d6 25	jsr $25d6			jsr 	ConvertInt32
.25a7	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25a9					_MPTSCopy:
.25a9	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25ac	20 b7 25	jsr $25b7			jsr 	WriteDecimalBuffer
.25af	e8		inx				inx
.25b0	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25b3	d0 f4		bne $25a9			bne 	_MPTSCopy
.25b5	fa		plx				plx
.25b6	60		rts				rts
.25b7					WriteDecimalBuffer:
.25b7	da		phx				phx
.25b8	ae 3b 05	ldx $053b			ldx 	dbOffset
.25bb	9d 3c 05	sta $053c,x			sta 	decimalBuffer,x
.25be	9e 3d 05	stz $053d,x			stz 	decimalBuffer+1,x
.25c1	ee 3b 05	inc $053b			inc 	dbOffset
.25c4	fa		plx				plx
.25c5	60		rts				rts
.053a					decimalPlaces:
>053a							.fill 	1
.053b					dbOffset:
>053b							.fill 	1
.053c					decimalBuffer:
>053c							.fill 	32
.25c6					ConvertInt16:
.25c6	85 3c		sta $3c				sta 	NSMantissa0 				; set up as 32 bit conversion
.25c8	86 48		stx $48				stx 	NSMantissa1
.25ca	64 54		stz $54				stz 	NSMantissa2
.25cc	64 60		stz $60				stz 	NSMantissa3
.25ce	64 30		stz $30				stz 	NSStatus 					; positive integer
.25d0	a2 00		ldx #$00			ldx 	#0 							; stack level
.25d2	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25d4	80 00		bra $25d6			bra 	ConvertInt32
.25d6					ConvertInt32:
.25d6	5a		phy				phy
.25d7	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25d9	24 30		bit $30				bit 	NSStatus 					; output a - if not negative.
.25db	10 08		bpl $25e5			bpl 	_CI32NotNeg
.25dd	48		pha				pha
.25de	a9 2d		lda #$2d			lda 	#'-'
.25e0	99 15 05	sta $0515,y			sta 	numberBuffer,y
.25e3	c8		iny				iny
.25e4	68		pla				pla
.25e5					_CI32NotNeg:
.25e5	20 f3 25	jsr $25f3			jsr 	_CI32DivideConvert 			; recursive conversion
.25e8	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.25ea	99 15 05	sta $0515,y			sta 	numberBuffer,y
.25ed	7a		ply				ply
.25ee	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.25f0	a9 15		lda #$15			lda 	#numberBuffer & $FF
.25f2	60		rts				rts
.25f3					_CI32DivideConvert:
.25f3	e8		inx				inx 								; write to next slot up
.25f4	20 59 26	jsr $2659			jsr 	FloatSetByte 		 		; write the base out.
.25f7	ca		dex				dex
.25f8	20 ed 21	jsr $21ed			jsr 	Int32Divide 				; divide
.25fb	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; save remainder
.25fd	48		pha				pha
.25fe	20 dc 21	jsr $21dc			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2601	20 79 26	jsr $2679			jsr 	FloatIsZero 				; is it zero ?
.2604	f0 05		beq $260b			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2606	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2608	20 f3 25	jsr $25f3			jsr 	_CI32DivideConvert 			; and recusrively call.
.260b					_CI32NoRecurse:
.260b	68		pla				pla 								; remainder
.260c	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.260e	90 02		bcc $2612			bcc 	_CI32NotHex
.2610	69 26		adc #$26			adc 	#6+32
.2612					_CI32NotHex:
.2612	69 30		adc #$30			adc 	#48
.2614	99 15 05	sta $0515,y			sta 	numberBuffer,y 				; write out and exit
.2617	c8		iny				iny
.2618	60		rts				rts
.2619					FloatNegate:
.2619	b5 30		lda $30,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.261b	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.261d	95 30		sta $30,x			sta 	NSStatus,x
.261f	60		rts				rts
.2620					FloatNegateMantissa:
.2620	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2621	a9 00		lda #$00			lda 	#0
.2623	f5 3c		sbc $3c,x			sbc 	NSMantissa0,x
.2625	95 3c		sta $3c,x			sta 	NSMantissa0,x
.2627	a9 00		lda #$00			lda 	#0
.2629	f5 48		sbc $48,x			sbc 	NSMantissa1,x
.262b	95 48		sta $48,x			sta 	NSMantissa1,x
.262d	a9 00		lda #$00			lda 	#0
.262f	f5 54		sbc $54,x			sbc 	NSMantissa2,x
.2631	95 54		sta $54,x			sta 	NSMantissa2,x
.2633	a9 00		lda #$00			lda 	#0
.2635	f5 60		sbc $60,x			sbc 	NSMantissa3,x
.2637	95 60		sta $60,x			sta 	NSMantissa3,x
.2639	60		rts				rts
.263a					FloatShiftUpTwo:
.263a	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.263c	95 3e		sta $3e,x			sta 	NSMantissa0+2,x
.263e	b5 48		lda $48,x			lda 	NSMantissa1,x
.2640	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.2642	b5 54		lda $54,x			lda 	NSMantissa2,x
.2644	95 56		sta $56,x			sta 	NSMantissa2+2,x
.2646	b5 60		lda $60,x			lda 	NSMantissa3,x
.2648	95 62		sta $62,x			sta 	NSMantissa3+2,x
.264a	b5 6c		lda $6c,x			lda 	NSExponent,x
.264c	95 6e		sta $6e,x			sta 	NSExponent+2,x
.264e	b5 30		lda $30,x			lda 	NSStatus,x
.2650	95 32		sta $32,x			sta 	NSStatus+2,x
.2652	60		rts				rts
.2653					FloatSetZeroMantissaOnly:
.2653	74 3c		stz $3c,x			stz 	NSMantissa0,x
.2655	80 08		bra $265f			bra 	FloatZero13
.2657					FloatSetZero:
.2657	a9 00		lda #$00			lda 	#0
.2659					FloatSetByte:
.2659	74 6c		stz $6c,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.265b					FloatSetMantissa:
.265b	95 3c		sta $3c,x			sta 	NSMantissa0,x 				; zero mantissa
.265d	74 30		stz $30,x			stz 	NSStatus,x
.265f					FloatZero13:
.265f	74 48		stz $48,x			stz 	NSMantissa1,x
.2661	74 54		stz $54,x			stz 	NSMantissa2,x
.2663	74 60		stz $60,x			stz 	NSMantissa3,x
.2665	60		rts				rts
.2666					FloatShiftLeft:
.2666	18		clc				clc
.2667					FloatRotateLeft:
.2667	36 3c		rol $3c,x			rol 	NSMantissa0,x
.2669	36 48		rol $48,x			rol		NSMantissa1,x
.266b	36 54		rol $54,x			rol		NSMantissa2,x
.266d	36 60		rol $60,x			rol		NSMantissa3,x
.266f	60		rts				rts
.2670					FloatShiftRight:
.2670	56 60		lsr $60,x			lsr 	NSMantissa3,x
.2672	76 54		ror $54,x			ror		NSMantissa2,x
.2674	76 48		ror $48,x			ror		NSMantissa1,x
.2676	76 3c		ror $3c,x			ror		NSMantissa0,x
.2678	60		rts				rts
.2679					FloatIsZero:
.2679	b5 60		lda $60,x			lda 	NSMantissa3,x
.267b	15 54		ora $54,x			ora		NSMantissa2,x
.267d	15 48		ora $48,x			ora		NSMantissa1,x
.267f	15 3c		ora $3c,x			ora		NSMantissa0,x
.2681	60		rts				rts

;******  Processing input file: testing/testend.asm

.2682					EndProgram:
>2682	01 08 11 08 0a 00 85 20				.binary "code/tokenised.dat"
>268a	22 43 4f 55 4e 54 22 2c 4e 00 1a 08 14 00 ce 86
>269a	20 33 00 37 08 3c 00 99 20 c7 28 31 34 37 29 3b
>26aa	22 48 45 4c 4c 4f 20 57 4f 52 4c 44 20 21 22 00
>26ba	53 08 46 00 86 20 42 58 28 4e 29 3a 86 20 42 59
>26ca	28 4e 29 3a 86 20 42 43 28 4e 29 00 67 08 4b 00
>26da	86 20 44 58 28 4e 29 3a 86 20 44 59 28 4e 29 00
>26ea	75 08 50 00 81 20 42 b2 30 20 a4 20 4e 00 8e 08
>26fa	5a 00 42 58 28 42 29 b2 b5 28 bb 28 31 29 ac 34
>270a	30 29 ac 32 aa 31 00 a7 08 64 00 42 59 28 42 29
>271a	b2 b5 28 bb 28 31 29 ac 33 30 29 ac 32 35 36 00
>272a	be 08 69 00 42 43 28 42 29 b2 b5 28 bb 28 31 29
>273a	ac 31 34 29 aa 31 00 d2 08 6a 00 44 58 28 42 29
>274a	b2 b5 28 bb 28 31 29 ac 32 29 00 e8 08 6c 00 8f
>275a	20 44 59 28 42 29 b2 b5 28 bb 28 31 29 ac 32 29
>276a	00 f4 08 6d 00 44 59 28 42 29 b2 31 00 fc 08 6e
>277a	00 82 20 42 00 02 09 78 00 8f 00 16 09 82 00 81
>278a	59 b2 30 a4 32 39 3a 81 58 b2 30 a4 33 39 00 2c
>279a	09 8c 00 51 b2 59 ac 32 35 36 aa 58 ac 32 aa 34
>27aa	35 30 35 36 00 44 09 96 00 ce 84 20 31 2c 51 2c
>27ba	38 31 3a ce 84 31 2c 51 aa 31 2c 30 00 4d 09 a0
>27ca	00 82 58 2c 59 00 59 09 c8 00 81 20 42 b2 31 a4
>27da	4e 00 76 09 d2 00 ce 84 20 31 2c 34 35 30 35 36
>27ea	aa 42 59 28 42 29 aa 42 58 28 42 29 2c 30 00 84
>27fa	09 e6 00 44 58 42 b2 44 58 28 42 29 00 95 09 f0
>280a	00 8b 44 58 42 b2 30 a7 8d 31 30 31 30 00 a6 09
>281a	fa 00 8b 44 58 42 b2 31 a7 8d 31 30 34 30 00 b4
>282a	09 ff 00 44 59 42 b2 44 59 28 42 29 00 c5 09 04
>283a	01 8b 44 59 42 b2 30 a7 8d 31 30 37 30 00 d6 09
>284a	0e 01 8b 44 59 42 b2 31 a7 8d 31 31 30 30 00 f7
>285a	09 18 01 ce 84 20 31 2c 34 35 30 35 36 aa 42 59
>286a	28 42 29 aa 42 58 28 42 29 2c 42 43 28 42 29 00
>287a	fe 09 22 01 82 42 00 08 0a 2c 01 89 20 32 30 30
>288a	00 0e 0a e8 03 8f 00 1c 0a f2 03 42 58 42 b2 42
>289a	58 28 42 29 00 31 0a f3 03 8b 42 58 42 b2 31 a7
>28aa	44 58 28 42 29 b2 31 3a 8e 00 43 0a fc 03 42 58
>28ba	28 42 29 b2 42 58 42 ab 32 3a 8e 00 49 0a 06 04
>28ca	8f 00 57 0a 10 04 42 58 42 b2 42 58 28 42 29 00
>28da	77 0a 11 04 8b 42 58 42 b2 37 39 a7 20 42 58 28
>28ea	42 29 b2 37 37 3a 44 58 28 42 29 b2 30 3a 8e 00
>28fa	89 0a 1a 04 42 58 28 42 29 b2 42 58 42 aa 32 3a
>290a	8e 00 8f 0a 24 04 8f 00 9d 0a 2e 04 42 59 42 b2
>291a	42 59 28 42 29 00 b2 0a 2f 04 8b 42 59 42 b2 30
>292a	a7 44 59 28 42 29 b2 31 3a 8e 00 c6 0a 38 04 42
>293a	59 28 42 29 b2 42 59 42 ab 32 35 36 3a 8e 00 cc
>294a	0a 42 04 8f 00 da 0a 4c 04 42 59 42 b2 42 59 28
>295a	42 29 00 fd 0a 4d 04 8b 42 59 42 b2 37 34 32 34
>296a	a7 42 59 28 42 29 b2 37 31 36 38 3a 44 59 28 42
>297a	29 b2 30 3a 8e 00 11 0b 56 04 42 59 28 42 29 b2
>298a	42 59 42 aa 32 35 36 3a 8e 00 00 00

;******  End of listing
