
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Sat Oct  7 09:52:31 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.1000					WrapperBoot:
.1000	a2 0a		ldx #$0a			ldx 	#APIDesc & $FF
.1002	a0 10		ldy #$10			ldy 	#APIDesc >> 8
.1004	20 4b 11	jsr $114b			jsr 	StartCompiler
.1007	4c ff ff	jmp $ffff			jmp 	$FFFF
.100a					APIDesc:
>100a							.fill 	2
>100c	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>100d	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing file: testing/api/close.asm

.100e					APIOClose:
.100e	a9 40		lda #$40			lda 	#(PCodeStart >> 8)
.1010	a6 29		ldx $29				ldx 	objPtr
.1012	a4 2a		ldy $2a				ldy 	objPtr+1
.1014	20 5e 10	jsr $105e			jsr 	APISaveMemory
.1017	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/fromram.asm

.1018					APIIOpen:
.1018	a9 ae		lda #$ae			lda 	#((EndProgram+2) & $FF)
.101a	85 22		sta $22				sta 	0+srcInputPtr
.101c	a9 26		lda #$26			lda 	#((EndProgram+2) >> 8) & $FF
.101e	85 23		sta $23				sta 	1+srcInputPtr
.1020					APIIClose:
.1020	60		rts				rts
.0022					srcInputPtr:
>0022							.fill 	2

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/line.asm

.1021					ReadNextLine:
.1021	b2 22		lda ($22)			lda 	(srcInputPtr) 				; reached the end of the program (address link = $0000)
.1023	a0 01		ldy #$01			ldy 	#1
.1025	11 22		ora ($22),y			ora 	(srcInputPtr),y
.1027	d0 02		bne $102b			bne 	_RLAHaveData
.1029	18		clc				clc
.102a	60		rts				rts									; end of file.
.102b					_RLAHaveData:
.102b	a6 22		ldx $22				ldx 	srcInputPtr 				; remember the line start
.102d	a4 23		ldy $23				ldy 	srcInputPtr+1
.102f	5a		phy				phy
.1030	a0 04		ldy #$04			ldy 	#4 							; must be at least four bytes (address/line#)
.1032					_RNLRead:
.1032	b1 22		lda ($22),y			lda 	(srcInputPtr),y 			; find the end of the line.
.1034	c8		iny				iny
.1035	c9 00		cmp #$00			cmp 	#0
.1037	d0 f9		bne $1032			bne 	_RNLRead
.1039	98		tya				tya 								; advance src input pointer to next.
.103a	18		clc				clc
.103b	65 22		adc $22				adc 	srcInputPtr
.103d	85 22		sta $22				sta 	srcInputPtr
.103f	90 02		bcc $1043			bcc 	_RNLNoCarry
.1041	e6 23		inc $23				inc 	srcInputPtr+1
.1043					_RNLNoCarry:
.1043	7a		ply				ply 								; address of line now in YX.
.1044	38		sec				sec
.1045	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/open.asm

.1046					APIOOpen:
.1046					APIORewind:
.1046	64 2b		stz $2b				stz 	objPage
.1048	a9 00		lda #$00			lda 	#((PCodeStart) & $FF)
.104a	85 29		sta $29				sta 	0+objPtr
.104c	a9 40		lda #$40			lda 	#((PCodeStart) >> 8) & $FF
.104e	85 2a		sta $2a				sta 	1+objPtr
.1050	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/writebyte.asm

.1051					APIOWriteByte:
.1051	92 29		sta ($29)			sta 	(objPtr)
.1053	e6 29		inc $29				inc 	objPtr
.1055	d0 02		bne $1059			bne 	_HWOWBNoCarry
.1057	e6 2a		inc $2a				inc 	objPtr+1
.1059					_HWOWBNoCarry:
.1059	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_config.inc

=$4000					PCodeStart = $4000

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_printchar.asm

.105a					APIOPrintCharacter
.105a	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.105d	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_save.asm

.105e					APISaveMemory:
.105e	da		phx				phx
.105f	5a		phy				phy
.1060	48		pha				pha
.1061	a9 00		lda #$00			lda 	#0 							; set LFS
.1063	a2 08		ldx #$08			ldx 	#8
.1065	a0 00		ldy #$00			ldy 	#0
.1067	20 ba ff	jsr $ffba			jsr 	$FFBA
.106a	a9 08		lda #$08			lda 	#8 							; set file name
.106c	a2 80		ldx #$80			ldx 	#SaveName & $FF
.106e	a0 10		ldy #$10			ldy 	#SaveName >> 8
.1070	20 bd ff	jsr $ffbd			jsr 	$FFBD
.1073	68		pla				pla 								; set up the start address.
.1074	85 2e		sta $2e				sta 	zTemp0+1
.1076	64 2d		stz $2d				stz 	zTemp0
.1078	a9 2d		lda #$2d			lda 	#zTemp0 					; from index.
.107a	7a		ply				ply 								; end in YX
.107b	fa		plx				plx
.107c	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.107f	60		rts				rts
.1080					SaveName:
>1080	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Return to file: testing/testing.asm


;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READ = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_ADJUSTOBJECT = 6
=7					BLC_PRINTCHAR = 7
.0024					srcPtr:
>0024							.fill 	2
.0400					currentLineNumber:
>0400							.fill 	2
.1088					InlineNonDecimal:
.1088	a2 02		ldx #$02			ldx 	#2 							; get size in X
.108a	c9 25		cmp #$25			cmp 	#"%"
.108c	f0 02		beq $1090			beq 	_INDBinary
.108e	a2 10		ldx #$10			ldx 	#16
.1090					_INDBinary:
.1090	85 2f		sta $2f				sta 	zTemp1 						; size => zTemp1
.1092	64 30		stz $30				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.1094	64 2d		stz $2d				stz 	zTemp0 						; zero result
.1096	64 2e		stz $2e				stz 	zTemp0+1
.1098					_INDLoop:
.1098	20 2b 1a	jsr $1a2b			jsr 	LookNext 					; check next character
.109b	20 67 1a	jsr $1a67			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.109e	90 1f		bcc $10bf			bcc		_INDDone 					; didn't convert
.10a0	c5 2f		cmp $2f				cmp 	zTemp1 						; size too large ?
.10a2	b0 1b		bcs $10bf			bcs 	_INDDone
.10a4	20 ce 10	jsr $10ce			jsr 	_INDShift 					; x 2 or x 16
.10a7	e0 02		cpx #$02			cpx 	#2
.10a9	f0 09		beq $10b4			beq 	_INDNotHex
.10ab	20 ce 10	jsr $10ce			jsr 	_INDShift
.10ae	20 ce 10	jsr $10ce			jsr 	_INDShift
.10b1	20 ce 10	jsr $10ce			jsr 	_INDShift
.10b4					_INDNotHex:
.10b4	05 2d		ora $2d				ora 	zTemp0 						; or digit into result
.10b6	85 2d		sta $2d				sta 	zTemp0
.10b8	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume
.10bb	e6 30		inc $30				inc 	zTemp1+1 					; bump count
.10bd	80 d9		bra $1098			bra 	_INDLoop
.10bf					_INDDone:
.10bf	a5 30		lda $30				lda 	zTemp1+1 					; done at least 1 ?
.10c1	f0 08		beq $10cb			beq 	_INDError
.10c3	a4 2e		ldy $2e				ldy 	zTemp0+1 					; push constant
.10c5	a5 2d		lda $2d				lda 	zTemp0
.10c7	20 d8 11	jsr $11d8			jsr 	PushIntegerYA
.10ca	60		rts				rts
.10cb					_INDError:
.10cb	4c 3b 1f	jmp $1f3b		jmp	ErrorV_syntax
.10ce					_INDShift:
.10ce	06 2d		asl $2d				asl 	zTemp0
.10d0	26 2e		rol $2e				rol 	zTemp0+1
.10d2	60		rts				rts
.10d3					GetLineNumber:
.10d3	ac 01 04	ldy $0401			ldy 	currentLineNumber+1
.10d6	ad 00 04	lda $0400			lda 	currentLineNumber
.10d9	60		rts				rts
.10da					WriteCodeByte:
.10da	48		pha				pha 								; save on stack
.10db	da		phx				phx
.10dc	5a		phy				phy
.10dd	20 51 10	jsr $1051			jsr 	APIOWriteByte
.10e0	7a		ply				ply 								; restore from stack
.10e1	fa		plx				plx
.10e2	68		pla				pla
.10e3	60		rts				rts
.10e4					PrintCharacter
.10e4	48		pha				pha
.10e5	da		phx				phx
.10e6	5a		phy				phy
.10e7	20 5a 10	jsr $105a			jsr 	APIOPrintCharacter
.10ea	7a		ply				ply
.10eb	fa		plx				plx
.10ec	68		pla				pla
.10ed	60		rts				rts
.10ee					ProcessNewLine:
.10ee	86 2d		stx $2d				stx 	zTemp0 						; save address in zTemp0
.10f0	84 2e		sty $2e				sty 	zTemp0+1
.10f2	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.10f3	8a		txa				txa
.10f4	69 04		adc #$04			adc 	#4
.10f6	85 24		sta $24				sta 	srcPtr
.10f8	98		tya				tya
.10f9	69 00		adc #$00			adc 	#0
.10fb	85 25		sta $25				sta 	srcPtr+1
.10fd	a0 02		ldy #$02			ldy 	#2							; read and save line number
.10ff	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.1101	8d 00 04	sta $0400			sta 	currentLineNumber
.1104	c8		iny				iny
.1105	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.1107	8d 01 04	sta $0401			sta 	currentLineNumber+1
.110a	60		rts				rts
.110b					BufferClear:
.110b	9c 02 04	stz $0402			stz 	bufferSize
.110e	60		rts				rts
.110f					BufferWrite:
.110f	da		phx				phx
.1110	ae 02 04	ldx $0402			ldx 	bufferSize
.1113	9d 03 04	sta $0403,x			sta 	dataBuffer,x
.1116	ee 02 04	inc $0402			inc 	bufferSize
.1119	fa		plx				plx
.111a	60		rts				rts
.111b					BufferOutput:
.111b	ad 02 04	lda $0402			lda 	bufferSize
.111e	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1121	a2 00		ldx #$00			ldx 	#0
.1123					_BOLoop:
.1123	ec 02 04	cpx $0402			cpx 	bufferSize
.1126	f0 09		beq $1131			beq 	_BOExit
.1128	bd 03 04	lda $0403,x			lda 	dataBuffer,x
.112b	20 da 10	jsr $10da			jsr 	WriteCodeByte
.112e	e8		inx				inx
.112f	80 f2		bra $1123			bra 	_BOLoop
.1131					_BOExit:
.1131	60		rts				rts
.0402					bufferSize:
>0402							.fill 	1
.0403					dataBuffer:
>0403							.fill 	256
.1132					CheckNextComma:
.1132	a9 2c		lda #$2c			lda	 	#","
.1134	80 06		bra $113c			bra 	CheckNextA
.1136					CheckNextRParen:
.1136	a9 29		lda #$29			lda	 	#")"
.1138	80 02		bra $113c			bra 	CheckNextA
.113a					CheckNextLParen:
.113a	a9 28		lda #$28			lda 	#"("
.113c					CheckNextA:
.113c	8d 03 05	sta $0503			sta 	checkCharacter 				; save test character
.113f					_CNALoop:
.113f	20 47 1a	jsr $1a47			jsr 	GetNextNonSpace 			; get next skipping spaces.
.1142	cd 03 05	cmp $0503			cmp 	checkCharacter 				; matches ?
.1145	f0 03		beq $114a			beq 	_CNAExit
.1147	4c 3b 1f	jmp $1f3b		jmp	ErrorV_syntax
.114a					_CNAExit:
.114a	60		rts				rts
.0503					checkCharacter:
>0503							.fill 	1
.114b					StartCompiler:
.114b	86 2d		stx $2d				stx 	zTemp0 						; access API
.114d	84 2e		sty $2e				sty 	zTemp0+1
.114f	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.1151	b2 2d		lda ($2d)			lda 	(zTemp0)
.1153	8d 05 05	sta $0505			sta 	APIVector
.1156	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.1158	8d 06 05	sta $0506			sta 	APIVector+1
.115b	c8		iny				iny 								; copy data area range.
.115c	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.115e	8d 07 05	sta $0507			sta 	compilerStartHigh
.1161	c8		iny				iny
.1162	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.1164	8d 08 05	sta $0508			sta 	compilerEndHigh
.1167	ba		tsx				tsx 								; save stack pointer
.1168	8e 04 05	stx $0504			stx 	compilerSP
.116b	20 e0 1d	jsr $1de0			jsr 	STRReset 					; reset storage (line#, variable)
.116e	20 18 10	jsr $1018			jsr 	APIIOpen 					; reset data input
.1171	20 46 10	jsr $1046			jsr 	APIOOpen 					; reset data output.
.1174	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.1176	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1179	a9 00		lda #$00			lda 	#0
.117b	20 da 10	jsr $10da			jsr 	WriteCodeByte
.117e	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1181					MainCompileLoop:
.1181	20 21 10	jsr $1021			jsr 	ReadNextLine 				; read next line into the buffer.
.1184	90 31		bcc $11b7			bcc 	SaveCodeAndExit 			; end of source.
.1186	20 ee 10	jsr $10ee			jsr 	ProcessNewLine 				; set up pointer and line number.
.1189	20 d3 10	jsr $10d3			jsr 	GetLineNumber 				; get line #
.118c	20 c1 1b	jsr $1bc1			jsr 	STRMarkLine 				; remember the code position and number of this line.
.118f	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.1191	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1194					_MCLSameLine:
.1194	20 47 1a	jsr $1a47			jsr 	GetNextNonSpace 			; get the first character.
.1197	f0 e8		beq $1181			beq 	MainCompileLoop 			; end of line, get next line.
.1199	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.119b	f0 f7		beq $1194			beq 	_MCLSameLine
.119d	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.119f	10 0c		bpl $11ad			bpl 	_MCLCheckAssignment
.11a1	a2 08		ldx #$08			ldx 	#CommandTables & $FF 		; do command tables.
.11a3	a0 16		ldy #$16			ldy 	#CommandTables >> 8
.11a5	20 d0 18	jsr $18d0			jsr 	GeneratorProcess
.11a8	b0 ea		bcs $1194			bcs 	_MCLSameLine 				; keep trying to compile the line.
.11aa					_MCLSyntax:
.11aa	4c 3b 1f	jmp $1f3b		jmp	ErrorV_syntax
.11ad					_MCLCheckAssignment:
.11ad	20 5d 1a	jsr $1a5d			jsr 	CharIsAlpha 				; if not alpha then syntax error
.11b0	90 f8		bcc $11aa			bcc 	_MCLSyntax
.11b2	20 8f 1b	jsr $1b8f			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.11b5	80 dd		bra $1194			bra		_MCLSameLine 				; loop back.
.11b7					SaveCodeAndExit:
.11b7	20 20 10	jsr $1020			jsr 	APIIClose 					; finish input.
.11ba	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.11bc	a8		tay				tay
.11bd	20 c1 1b	jsr $1bc1			jsr 	STRMarkLine
.11c0	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.11c2	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11c5	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.11c7	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11ca	20 f4 14	jsr $14f4			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.11cd	20 0e 10	jsr $100e			jsr 	APIOClose
.11d0					ExitCompiler:
.11d0	ae 04 05	ldx $0504			ldx 	compilerSP 					; reload SP and exit.
.11d3	9a		txs				txs
.11d4	60		rts				rts
.11d5					CallAPIHandler:
.11d5	6c 05 05	jmp ($0505)			jmp 	(APIVector)
.0504					compilerSP:
>0504							.fill 	1
.0505					APIVector:
>0505							.fill 	2
.0507					compilerStartHigh:
>0507							.fill 	1
.0508					compilerEndHigh:
>0508							.fill 	1
.11d8					PushIntegerYA:
.11d8	c0 00		cpy #$00			cpy 	#0 							; 0-255
.11da	f0 0f		beq $11eb			beq 	PushIntegerA
.11dc	48		pha				pha
.11dd	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.11df	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11e2	68		pla				pla 								; then LSB
.11e3	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11e6	98		tya				tya 								; then MSB
.11e7	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11ea	60		rts				rts
.11eb					PushIntegerA:
.11eb	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.11ed	90 07		bcc $11f6			bcc 	_PIWriteA
.11ef	48		pha				pha
.11f0	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.11f2	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11f5	68		pla				pla
.11f6					_PIWriteA:
.11f6	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11f9	60		rts				rts
.11fa					PushFloat:
.11fa	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.11fc	20 da 10	jsr $10da			jsr 	WriteCodeByte
.11ff	b5 6f		lda $6f,x			lda 	NSExponent,x 				; and the data
.1201	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1204	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.1206	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1209	b5 4b		lda $4b,x			lda 	NSMantissa1,x
.120b	20 da 10	jsr $10da			jsr 	WriteCodeByte
.120e	b5 57		lda $57,x			lda 	NSMantissa2,x
.1210	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1213	b5 33		lda $33,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.1215	29 80		and #$80			and 	#$80
.1217	15 63		ora $63,x			ora 	NSMantissa3,x
.1219	20 da 10	jsr $10da			jsr 	WriteCodeByte
.121c	60		rts				rts
.121d					CreateVariableRecord:
.121d	48		pha				pha
.121e	ad 13 05	lda $0513			lda 	freeVariableMemory 		; push current free address on stack.
.1221	48		pha				pha
.1222	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1225	48		pha				pha
.1226	ad 11 05	lda $0511			lda 	variableListEnd  		; copy end of list to zTemp0
.1229	85 2d		sta $2d				sta 	zTemp0
.122b	ad 12 05	lda $0512			lda 	variableListEnd+1
.122e	85 2e		sta $2e				sta 	zTemp0+1
.1230	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.1232	92 2d		sta ($2d)			sta 	(zTemp0)
.1234	98		tya				tya
.1235	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.1237	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1239	88		dey				dey
.123a	8a		txa				txa
.123b	91 2d		sta ($2d),y			sta 	(zTemp0),y
.123d	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.123f	ad 13 05	lda $0513			lda 	freeVariableMemory
.1242	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1244	c8		iny				iny
.1245	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1248	91 2d		sta ($2d),y			sta 	(zTemp0),y
.124a	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.124c	a9 00		lda #$00			lda 	#0
.124e	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1250	18		clc				clc
.1251	b2 2d		lda ($2d)			lda 	(zTemp0) 				; add offset to variableListEnd
.1253	6d 11 05	adc $0511			adc  	variableListEnd
.1256	8d 11 05	sta $0511			sta 	variableListEnd
.1259	90 03		bcc $125e			bcc 	_CVNoCarry2
.125b	ee 12 05	inc $0512			inc 	variableListEnd+1
.125e					_CVNoCarry2:
.125e	7a		ply				ply
.125f	fa		plx				plx
.1260	68		pla				pla
.1261	60		rts				rts
.1262					SetVariableRecordToCodePosition:
.1262	48		pha				pha
.1263	5a		phy				phy
.1264	a5 2b		lda $2b				lda 	objPage
.1266	a0 03		ldy #$03			ldy 	#3
.1268	91 2d		sta ($2d),y			sta 	(zTemp0),y
.126a	c8		iny				iny
.126b	a5 2a		lda $2a				lda 	objPtr+1
.126d	91 2d		sta ($2d),y			sta 	(zTemp0),y
.126f	c8		iny				iny
.1270	a5 29		lda $29				lda 	objPtr
.1272	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1274	7a		ply				ply
.1275	68		pla				pla
.1276	60		rts				rts
.1277					AllocateBytesForType:
.1277	48		pha				pha
.1278	da		phx				phx
.1279	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.127b	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.127d	c9 00		cmp #$00			cmp 	#NSSIFloat
.127f	d0 02		bne $1283			bne 	_CVNotFloat
.1281	a2 06		ldx #$06			ldx 	#6
.1283					_CVNotFloat:
.1283	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.1284	18		clc				clc
.1285	6d 13 05	adc $0513			adc 	freeVariableMemory
.1288	8d 13 05	sta $0513			sta 	freeVariableMemory
.128b	90 03		bcc $1290			bcc 	_CVNoCarry1
.128d	ee 14 05	inc $0514			inc 	freeVariableMemory+1
.1290					_CVNoCarry1:
.1290	fa		plx				plx
.1291	68		pla				pla
.1292	60		rts				rts
.1293					CommandDATA:
.1293	20 0b 11	jsr $110b			jsr 	BufferClear 				; copy it to the buffer
.1296	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace
.1299					_CTDataLoop:
.1299	20 2b 1a	jsr $1a2b			jsr 	LookNext 					; reached EOL
.129c	f0 08		beq $12a6			beq 	_CTDataDone
.129e	20 0f 11	jsr $110f			jsr 	BufferWrite 				; write and consume
.12a1	20 3c 1a	jsr $1a3c			jsr 	GetNext
.12a4	80 f3		bra $1299			bra 	_CTDataLoop
.12a6					_CTDataDone:
.12a6	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.12a8	20 da 10	jsr $10da			jsr 	WriteCodeByte
.12ab	20 1b 11	jsr $111b			jsr 	BufferOutput
.12ae	60		rts				rts
.12af					CommandDEF:
.12af	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.12b1	20 eb 11	jsr $11eb			jsr 	PushIntegerA
.12b4	20 53 1b	jsr $1b53			jsr 	CompileGotoEOL 				; compile skip over DEF
.12b7	a9 a5		lda #$a5			lda 	#C64_FN
.12b9	20 3c 11	jsr $113c			jsr 	CheckNextA
.12bc	20 47 1a	jsr $1a47			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.12bf	20 ac 1a	jsr $1aac			jsr 	ExtractVariableName
.12c2	8a		txa				txa
.12c3	10 51		bpl $1316			bpl 	_CDError
.12c5	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.12c6	29 7f		and #$7f			and 	#$7F
.12c8	aa		tax				tax
.12c9	98		tya				tya
.12ca	09 80		ora #$80			ora 	#$80
.12cc	a8		tay				tay
.12cd	20 98 14	jsr $1498			jsr 	FindVariable				; does it already exist ?
.12d0	b0 44		bcs $1316			bcs 	_CDError 					; if so, that's an error.
.12d2	20 1d 12	jsr $121d			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.12d5	20 62 12	jsr $1262			jsr 	SetVariableRecordToCodePosition
.12d8	20 47 1a	jsr $1a47			jsr 	GetNextNonSpace
.12db	20 9d 1d	jsr $1d9d			jsr 	GetReferenceTerm 			; get var ref, not array
.12de	c9 00		cmp #$00			cmp 	#0
.12e0	30 34		bmi $1316			bmi 	_CDError
.12e2	8d 09 05	sta $0509			sta 	defType 					; save type
.12e5	8e 0a 05	stx $050a			stx 	defVariable 				; save var ref
.12e8	8c 0b 05	sty $050b			sty 	defVariable+1
.12eb	29 40		and #$40			and 	#NSSString 					; only numbers.
.12ed	d0 27		bne $1316			bne 	_CDError
.12ef	20 36 11	jsr $1136			jsr 	CheckNextRParen 			; check )
.12f2	a9 b2		lda #$b2			lda 	#C64_EQUAL
.12f4	20 3c 11	jsr $113c			jsr 	CheckNextA 					; check =
.12f7	18		clc				clc 								; if this is DEF FNxx(A), read A
.12f8	20 19 13	jsr $1319			jsr 	CDReadWriteVariable
.12fb	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.12fd	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1300	38		sec				sec
.1301	20 19 13	jsr $1319			jsr 	CDReadWriteVariable 		; A is now updated
.1304	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; the actual body of the function.
.1307	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1309	20 da 10	jsr $10da			jsr 	WriteCodeByte
.130c	38		sec				sec
.130d	20 19 13	jsr $1319			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.1310	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.1312	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1315	60		rts				rts
.1316					_CDError:
.1316	4c 3b 1f	jmp $1f3b		jmp	ErrorV_syntax
.1319					CDReadWriteVariable:
.1319	ac 0b 05	ldy $050b			ldy 	defVariable+1 				; set up YX
.131c	ae 0a 05	ldx $050a			ldx 	defVariable
.131f	ad 09 05	lda $0509			lda 	defType
.1322	20 4f 1d	jsr $1d4f			jsr 	GetSetVariable
.1325	60		rts				rts
.0509					defType:
>0509							.fill 	1
.050a					defVariable:
>050a							.fill 	2
.1326					CommandDIM:
.1326	20 47 1a	jsr $1a47			jsr 	GetNextNonSpace 			; get the first non space character
.1329	20 ac 1a	jsr $1aac			jsr 	ExtractVariableName 		; variable name to XY
.132c	da		phx				phx 								; save name with type bits.
.132d	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.132f	10 37		bpl $1368			bpl 	_CDError
.1331	20 98 14	jsr $1498			jsr 	FindVariable	 			; see if already exist
.1334	b0 35		bcs $136b			bcs 	_CDRedefine 				; it still exists.
.1336	20 1d 12	jsr $121d			jsr 	CreateVariableRecord 		; create the basic variable
.1339	20 77 12	jsr $1277			jsr 	AllocateBytesForType 		; allocate memory for it
.133c	68		pla				pla 								; restore type bits
.133d	5a		phy				phy 								; save the address of the basic storage
.133e	da		phx				phx
.133f	48		pha				pha
.1340	20 6e 13	jsr $136e			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.1343	68		pla				pla
.1344	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.1346	20 eb 11	jsr $11eb			jsr 	PushIntegerA 				; push that type data out.
.1349	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.134b	20 da 10	jsr $10da			jsr 	WriteCodeByte
.134e	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.1350	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1353	fa		plx				plx 								; restore address
.1354	7a		ply				ply
.1355	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1357	38		sec				sec
.1358	20 4f 1d	jsr $1d4f			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.135b	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; , follows ?
.135e	c9 2c		cmp #$2c			cmp 	#","
.1360	d0 05		bne $1367			bne 	_CDExit
.1362	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume comma
.1365	80 bf		bra $1326			bra 	CommandDIM 					; do another DIM
.1367					_CDExit:
.1367	60		rts				rts
.1368					_CDError:
.1368	4c 3b 1f	jmp $1f3b		jmp	ErrorV_syntax
.136b					_CDRedefine:
.136b	4c 03 20	jmp $2003		jmp	ErrorV_redefine
.136e					OutputIndexGroup:
.136e	9c 0c 05	stz $050c			stz 	IndexCount 					; count of number of indices.
.1371					_OIGNext:
.1371	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; get a dimension
.1374	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1376	c9 00		cmp #$00			cmp 	#NSSIFloat
.1378	d0 19		bne $1393			bne 	_OIGType
.137a	ee 0c 05	inc $050c			inc 	IndexCount 					; bump the counter.
.137d	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; does a , follow ?
.1380	c9 2c		cmp #$2c			cmp 	#","
.1382	d0 05		bne $1389			bne 	_OIGCheckEnd
.1384	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume comma
.1387	80 e8		bra $1371			bra 	_OIGNext 					; get next dimension
.1389					_OIGCheckEnd:
.1389	20 36 11	jsr $1136			jsr 	CheckNextRParen 			; check and consume )
.138c	ad 0c 05	lda $050c			lda 	IndexCount
.138f	20 eb 11	jsr $11eb			jsr 	PushIntegerA 				; compile the dimension count.
.1392	60		rts				rts
.1393					_OIGType:
.1393	4c 4b 1f	jmp $1f4b		jmp	ErrorV_type
.050c					IndexCount:
>050c							.fill 	1
.1396					ErrorHandler:
.1396	68		pla				pla
.1397	7a		ply				ply
.1398	85 2d		sta $2d				sta 	zTemp0
.139a	84 2e		sty $2e				sty 	zTemp0+1
.139c	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.139e	a0 01		ldy #$01			ldy 	#1
.13a0					_EHDisplayMsg:
.13a0	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.13a2	20 e4 10	jsr $10e4			jsr 	PrintCharacter
.13a5	c8		iny				iny
.13a6	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.13a8	d0 f6		bne $13a0			bne 	_EHDisplayMsg
.13aa	a9 20		lda #$20			lda 	#32
.13ac	20 e4 10	jsr $10e4			jsr 	PrintCharacter
.13af	a9 40		lda #$40			lda 	#64
.13b1	20 e4 10	jsr $10e4			jsr 	PrintCharacter
.13b4	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.13b6	20 83 26	jsr $2683			jsr 	FloatSetByte
.13b9	20 d3 10	jsr $10d3			jsr 	GetLineNumber
.13bc	95 3f		sta $3f,x			sta 	NSMantissa0,x
.13be	98		tya				tya
.13bf	95 4b		sta $4b,x			sta 	NSMantissa1,x
.13c1	20 69 25	jsr $2569			jsr 	FloatToString
.13c4	a0 00		ldy #$00			ldy 	#0 							; display that string.
.13c6	a2 00		ldx #$00			ldx 	#0
.13c8					_EHDisplayLine:
.13c8	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13cb	20 e4 10	jsr $10e4			jsr 	PrintCharacter
.13ce	c8		iny				iny
.13cf	b9 3c 05	lda $053c,y			lda 	decimalBuffer,y
.13d2	d0 f4		bne $13c8			bne 	_EHDisplayLine
.13d4	a9 0d		lda #$0d			lda 	#13
.13d6	20 e4 10	jsr $10e4			jsr 	PrintCharacter
.13d9	80 fe		bra $13d9	_EHHalt:bra 	_EHHalt
.13db	4c d0 11	jmp $11d0			jmp 	ExitCompiler
.13de					CompileExpressionAt0:
.13de	a9 00		lda #$00			lda 	#0
.13e0					CompileExpressionAtA:
.13e0	48		pha				pha  								; save level
.13e1	20 08 1e	jsr $1e08			jsr 	CompileTerm 				; compile a term.
.13e4	fa		plx				plx 								; get level back into X
.13e5					_ECALoop:
.13e5	48		pha				pha 								; save type on stack.
.13e6	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; get the next character
.13e9	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.13eb	90 04		bcc $13f1			bcc 	_ECAExit
.13ed	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.13ef	90 02		bcc $13f3			bcc 	_ECAHaveToken
.13f1					_ECAExit:
.13f1	68		pla				pla 								; throw type off stack
.13f2	60		rts				rts
.13f3					_ECAHaveToken:
.13f3	86 2d		stx $2d				stx 	zTemp0 						; save current precedence in zTemp0
.13f5	aa		tax				tax 								; X contains the operator token
.13f6	bd e1 13	lda $13e1,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.13f9	c5 2d		cmp $2d				cmp 	zTemp0 						; if < then exit
.13fb	90 f4		bcc $13f1			bcc 	_ECAExit
.13fd	85 2e		sta $2e				sta 	zTemp0+1 					; save the precedence of the operator.
.13ff	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume the token.
.1402	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.1404	f0 11		beq $1417			beq 	_ECAGreaterCheck
.1406	e0 b3		cpx #$b3			cpx 	#C64_LESS
.1408	d0 1a		bne $1424			bne 	_ECAHaveFullToken
.140a	20 2b 1a	jsr $1a2b			jsr 	LookNext 					; checks for < (<= or <>)
.140d	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.140f	f0 0e		beq $141f			beq	 	_ECAToNotEqual
.1411	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.1413	d0 0f		bne $1424			bne 	_ECAHaveFullToken
.1415	80 07		bra $141e			bra 	_ECAAddEqual
.1417					_ECAGreaterCheck:
.1417	20 2b 1a	jsr $1a2b			jsr 	LookNext
.141a	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.141c	d0 06		bne $1424			bne 	_ECAHaveFullToken
.141e					_ECAAddEqual:
.141e	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.141f					_ECAToNotEqual:
.141f	e8		inx				inx
.1420	e8		inx				inx
.1421	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume the = or > in >= <= <>
.1424					_ECAHaveFullToken:
.1424	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.1426	d0 0a		bne $1432			bne 	_ECANotConcat
.1428	68		pla				pla 								; get type back
.1429	48		pha				pha
.142a	29 40		and #$40			and 	#NSSTypeMask
.142c	c9 40		cmp #$40			cmp 	#NSSString
.142e	d0 02		bne $1432			bne 	_ECANotConcat
.1430	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1432					_ECANotConcat:
.1432	da		phx				phx 								; save operator on the stack
.1433	a6 2d		ldx $2d				ldx 	zTemp0 						; push current precedence on the stack
.1435	da		phx				phx
.1436	a5 2e		lda $2e				lda 	zTemp0+1 					; get precedence of operator
.1438	1a		inc a				inc 	a
.1439	20 e0 13	jsr $13e0			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.143c	85 2d		sta $2d				sta 	zTemp0 						; save type in zTemp0
.143e	fa		plx				plx 								; restore current precedence in X
.143f	68		pla				pla 								; restore operator
.1440	85 2e		sta $2e				sta 	zTemp0+1 					; save it in zTemp0+1.
.1442	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.1444	90 17		bcc $145d			bcc 	_ECANotCompare
.1446	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.1448	b0 13		bcs $145d			bcs 	_ECANotCompare
.144a	7a		ply				ply 								; get type into Y
.144b	5a		phy				phy
.144c	48		pha				pha 								; save operator
.144d	98		tya				tya 								; get type
.144e	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.1450	29 40		and #$40			and 	#NSSTypeMask
.1452	c9 40		cmp #$40			cmp 	#NSSString
.1454	f0 02		beq $1458			beq 	_ECANotString
.1456	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.1458					_ECANotString:
.1458	98		tya				tya									; output token Y
.1459	20 da 10	jsr $10da			jsr 	WriteCodeByte
.145c	68		pla				pla 								; restore operator.
.145d					_ECANotCompare:
.145d	18		clc				clc 								; convert to P-Code and compile.
.145e	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.1460	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1463	68		pla				pla 								; type of current result
.1464	45 2d		eor $2d				eor 	zTemp0 						; check compatible with r-expr type
.1466	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.1468	d0 19		bne $1483			bne		_ECAType
.146a	a5 2d		lda $2d				lda 	zTemp0 						; get type back
.146c	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.146e	d0 18		bne $1488			bne 	_ECAGoLoop
.1470	a5 2e		lda $2e				lda 	zTemp0+1 					; check operator is + or comparator
.1472	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1474	f0 10		beq $1486			beq 	_ECAOkayString 				; (this is post conversion)
.1476	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.1478	90 09		bcc $1483			bcc 	_ECAType
.147a	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.147c	b0 05		bcs $1483			bcs 	_ECAType
.147e	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.1480	4c e5 13	jmp $13e5			jmp 	_ECALoop
.1483					_ECAType:
.1483	4c 4b 1f	jmp $1f4b		jmp	ErrorV_type
.1486					_ECAOkayString:
.1486	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.1488					_ECAGoLoop:
.1488	4c e5 13	jmp $13e5			jmp 	_ECALoop
.148b					PrecedenceTable:
>148b	03						.byte 	3 					; '+'
>148c	03						.byte 	3 					; '-'
>148d	04						.byte 	4 					; '*'
>148e	04						.byte 	4 					; '/'
>148f	05						.byte 	5 					; '^'
>1490	01						.byte 	1 					; 'and'
>1491	00						.byte 	0 					; 'or'
>1492	02						.byte 	2 					; '>'
>1493	02						.byte 	2 					; '='
>1494	02						.byte 	2 					; '<'
>1495	02						.byte 	2 					; '>='
>1496	02						.byte 	2 					; '<='
>1497	02						.byte 	2 					; '<>'
.1498					FindVariable:
.1498	86 2f		stx $2f				stx 	zTemp1 						; save name.
.149a	84 30		sty $30				sty 	zTemp1+1
.149c					_IVCheckSpecial:
.149c	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.149e	d0 18		bne $14b8			bne 	_IVStandard
.14a0	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.14a2	f0 0c		beq $14b0			beq 	_IVTIFloat
.14a4	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.14a6	d0 10		bne $14b8			bne 	_IVStandard
.14a8	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.14aa	a2 01		ldx #$01			ldx 	#$01
.14ac	a9 40		lda #$40			lda 	#NSSString
.14ae	38		sec				sec
.14af	60		rts				rts
.14b0					_IVTIFloat:
.14b0	a0 80		ldy #$80			ldy 	#$80
.14b2	a2 00		ldx #$00			ldx 	#$00
.14b4	a9 00		lda #$00			lda 	#0
.14b6	38		sec				sec
.14b7	60		rts				rts
.14b8					_IVStandard:
.14b8	ad 07 05	lda $0507			lda 	compilerStartHigh			; start scanning from here.
.14bb	85 2e		sta $2e				sta 	zTemp0+1
.14bd	64 2d		stz $2d				stz 	zTemp0
.14bf					_IVCheckLoop:
.14bf	b2 2d		lda ($2d)			lda 	(zTemp0) 					; finished ?
.14c1	f0 2b		beq $14ee			beq  	_IVNotFound 				; if so, return with CC.
.14c3	a0 01		ldy #$01			ldy 	#1 							; match ?
.14c5	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.14c7	c5 2f		cmp $2f				cmp 	zTemp1
.14c9	d0 07		bne $14d2			bne	 	_IVNext
.14cb	c8		iny				iny
.14cc	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.14ce	c5 30		cmp $30				cmp 	zTemp1+1
.14d0	f0 0d		beq $14df			beq 	_IVFound
.14d2					_IVNext:
.14d2	18		clc				clc
.14d3	a5 2d		lda $2d				lda 	zTemp0
.14d5	72 2d		adc ($2d)			adc 	(zTemp0)
.14d7	85 2d		sta $2d				sta 	zTemp0
.14d9	90 e4		bcc $14bf			bcc 	_IVCheckLoop
.14db	e6 2e		inc $2e				inc 	zTemp0+1
.14dd	80 e0		bra $14bf			bra 	_IVCheckLoop
.14df					_IVFound:
.14df	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.14e1	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.14e3	aa		tax				tax
.14e4	c8		iny				iny
.14e5	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.14e7	48		pha				pha
.14e8	c8		iny				iny
.14e9	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.14eb	7a		ply				ply
.14ec	38		sec				sec
.14ed	60		rts				rts
.14ee					_IVNotFound:
.14ee	a6 2f		ldx $2f				ldx 	zTemp1 						; get variable name back
.14f0	a4 30		ldy $30				ldy 	zTemp1+1
.14f2	18		clc				clc
.14f3	60		rts				rts
.14f4					FixBranches:
.14f4	20 46 10	jsr $1046			jsr 	APIORewind 					; back to the start of the *object* code.
.14f7					_FBLoop:
.14f7	b2 29		lda ($29)			lda 	(objPtr) 					; get the next one.
.14f9	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.14fb	f0 16		beq $1513			beq 	_FBFixGotoGosub
.14fd	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.14ff	f0 12		beq $1513			beq 	_FBFixGotoGosub
.1501	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.1503	f0 0e		beq $1513			beq 	_FBFixGotoGosub
.1505	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1507	f0 0a		beq $1513			beq 	_FBFixGotoGosub
.1509	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.150b	f0 49		beq $1556			beq 	_FBFixVarSpace
.150d					_FBNext:
.150d	20 50 20	jsr $2050			jsr 	MoveObjectForward 			; move forward in object code.
.1510	90 e5		bcc $14f7			bcc 	_FBLoop 					; not finished
.1512					_FBExit:
.1512	60		rts				rts
.1513					_FBFixGotoGosub:
.1513	a0 01		ldy #$01			ldy 	#1 							; if page is currently $FF
.1515	b1 29		lda ($29),y			lda 	(objPtr),y 					; then patch else leave.
.1517	c9 ff		cmp #$ff			cmp 	#$FF
.1519	d0 f2		bne $150d			bne 	_FBNext
.151b	a0 02		ldy #$02			ldy 	#2							; line number in YA
.151d	b1 29		lda ($29),y			lda 	(objPtr),y
.151f	48		pha				pha
.1520	c8		iny				iny
.1521	b1 29		lda ($29),y			lda 	(objPtr),y
.1523	a8		tay				tay
.1524	68		pla				pla
.1525	20 ef 1b	jsr $1bef			jsr 	STRFindLine			 		; find where it is X:YA
.1528	90 08		bcc $1532			bcc 	_FBFFound 					; not found, so must be >
.152a	48		pha				pha
.152b	b2 29		lda ($29)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.152d	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.152f	d0 15		bne $1546			bne 	_FBFFail
.1531	68		pla				pla
.1532					_FBFFound:
.1532	20 43 1c	jsr $1c43			jsr 	STRMakeOffset 				; make it an offset from X:YA
.1535	5a		phy				phy	 								; patch the GOTO/GOSUB
.1536	48		pha				pha
.1537	a0 01		ldy #$01			ldy 	#1
.1539	8a		txa				txa
.153a	91 29		sta ($29),y			sta 	(objPtr),y
.153c	c8		iny				iny
.153d	68		pla				pla
.153e	91 29		sta ($29),y			sta 	(objPtr),y
.1540	c8		iny				iny
.1541	68		pla				pla
.1542	91 29		sta ($29),y			sta 	(objPtr),y
.1544	80 c7		bra $150d			bra 	_FBNext
.1546					_FBFFail:
.1546	a0 02		ldy #$02			ldy 	#2
.1548	b1 29		lda ($29),y			lda 	(objPtr),y
.154a	8d 00 04	sta $0400			sta 	currentLineNumber
.154d	c8		iny				iny
.154e	b1 29		lda ($29),y			lda 	(objPtr),y
.1550	8d 01 04	sta $0401			sta 	currentLineNumber+1
.1553	4c 7e 1f	jmp $1f7e		jmp	ErrorV_line
.1556					_FBFixVarSpace:
.1556	a0 01		ldy #$01			ldy 	#1
.1558	ad 13 05	lda $0513			lda 	freeVariableMemory
.155b	91 29		sta ($29),y			sta 	(objPtr),y
.155d	c8		iny				iny
.155e	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.1561	91 29		sta ($29),y			sta 	(objPtr),y
.1563	80 a8		bra $150d			bra 	_FBNext
.1565					CommandFOR:
.1565	20 47 1a	jsr $1a47			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.1568	20 5d 1a	jsr $1a5d			jsr 	CharIsAlpha 				; if not alpha , error
.156b	90 59		bcc $15c6			bcc 	_CFFail
.156d	20 9d 1d	jsr $1d9d			jsr 	GetReferenceTerm 			; figure out the reference.
.1570	48		pha				pha 								; save type
.1571	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1573	c9 00		cmp #$00			cmp 	#NSSIFloat
.1575	d0 4f		bne $15c6			bne 	_CFFail
.1577	5a		phy				phy 								; save reference on the stack
.1578	da		phx				phx
.1579	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.157b	20 3c 11	jsr $113c			jsr 	CheckNextA
.157e	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; initial value
.1581	fa		plx				plx 								; get reference back.
.1582	7a		ply				ply
.1583	5a		phy				phy
.1584	da		phx				phx
.1585	38		sec				sec 								; set initial value.
.1586	20 4f 1d	jsr $1d4f			jsr 	GetSetVariable
.1589	fa		plx				plx
.158a	7a		ply				ply
.158b	68		pla				pla
.158c	29 20		and #$20			and 	#NSSIInt16
.158e	f0 04		beq $1594			beq 	_CFNotInt16
.1590	98		tya				tya
.1591	09 80		ora #$80			ora 	#$80
.1593	a8		tay				tay
.1594					_CFNotInt16:
.1594	8a		txa				txa 								; reference in YA
.1595	20 d8 11	jsr $11d8			jsr 	PushIntegerYA
.1598	a9 a4		lda #$a4			lda 	#C64_TO
.159a	20 3c 11	jsr $113c			jsr 	CheckNextA
.159d	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; terminal value
.15a0	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15a2	c9 00		cmp #$00			cmp 	#NSSIFloat
.15a4	d0 20		bne $15c6			bne 	_CFFail
.15a6	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; followed by STEP
.15a9	c9 a9		cmp #$a9			cmp 	#C64_STEP
.15ab	d0 0e		bne $15bb			bne 	_CFNoStep
.15ad	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume it.
.15b0	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; terminal value
.15b3	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15b5	c9 00		cmp #$00			cmp 	#NSSIFloat
.15b7	d0 0d		bne $15c6			bne 	_CFFail
.15b9	80 05		bra $15c0			bra 	_CFParametersDone
.15bb					_CFNoStep:
.15bb	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.15bd	20 eb 11	jsr $11eb			jsr 	PushIntegerA
.15c0					_CFParametersDone:
.15c0	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.15c2	20 da 10	jsr $10da			jsr 	WriteCodeByte
.15c5	60		rts				rts
.15c6					_CFFail:
.15c6	4c 3b 1f	jmp $1f3b		jmp	ErrorV_syntax
.15c9					FNCompile:
.15c9	20 47 1a	jsr $1a47			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.15cc	20 ac 1a	jsr $1aac			jsr 	ExtractVariableName
.15cf	e0 00		cpx #$00			cpx 	#0
.15d1	10 32		bpl $1605			bpl 	_FNError
.15d3	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.15d4	29 7f		and #$7f			and 	#$7F
.15d6	aa		tax				tax
.15d7	98		tya				tya
.15d8	09 80		ora #$80			ora 	#$80
.15da	a8		tay				tay
.15db	20 98 14	jsr $1498			jsr 	FindVariable				; does it already exist ?
.15de	90 25		bcc $1605			bcc 	_FNError 					; no.
.15e0	20 43 1c	jsr $1c43			jsr 	STRMakeOffset 				; convert to a relative address.
.15e3	c9 00		cmp #$00			cmp 	#0 							; fix up.
.15e5	d0 01		bne $15e8			bne 	_FNNoBorrow
.15e7	88		dey				dey
.15e8					_FNNoBorrow:
.15e8	3a		dec a				dec 	a
.15e9	5a		phy				phy 								; save location of routine on stack.
.15ea	48		pha				pha
.15eb	da		phx				phx
.15ec	20 de 13	jsr $13de			jsr 	CompileExpressionAt0
.15ef	20 36 11	jsr $1136			jsr 	CheckNextRParen
.15f2	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.15f4	20 da 10	jsr $10da			jsr 	WriteCodeByte
.15f7	68		pla				pla
.15f8	20 da 10	jsr $10da			jsr 	WriteCodeByte
.15fb	68		pla				pla
.15fc	20 da 10	jsr $10da			jsr 	WriteCodeByte
.15ff	68		pla				pla
.1600	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1603	18		clc				clc
.1604	60		rts				rts
.1605					_FNError:
.1605	4c 2e 1f	jmp $1f2e		jmp	ErrorV_value
.1608					CommandTables:
>1608	07 cb 00 03 0a 1b 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>160f	07 89 00 03 11 1b 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>1616	07 8d 00 03 04 1b 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>161d	07 88 00 03 8c 1b 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>1624	07 85 00 03 6c 1b 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>162b	07 84 00 04 80 1b 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>1632	07 99 00 03 ca 1c 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1639	07 98 00 04 ca 1c 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1640	07 8f 00 03 d5 1d 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>1647	07 81 00 03 65 15 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>164e	07 82 00 03 4d 1c 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>1655	07 a1 00 03 7d 1a 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>165c	07 83 00 03 93 12 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>1663	07 87 00 03 13 1d 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>166a	07 86 00 03 26 13 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>1671	07 96 00 03 af 12 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>1678	07 8b 00 e3 34 1b 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>167f	08 92 00 ea e3 a1 1e 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>1687	09 91 00 e1 a9 03 79 1c			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>168f	06
>1690	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>1697	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>169e	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>16a4	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>16ab	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>16b2	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>16b9	07 9d 00 e3 c7 1e 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>16c0	0a 9f 00 ea e3 da 1e 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>16c8	c6 06
>16ca	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>16d0	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>16d7	0a ce 92 e3 fa 19 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>16df	ad 06
>16e1	0a ce 8d e3 fa 19 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>16e9	ae 06
>16eb	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>16f1	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>16f9	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>1700	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>1707	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>170f	06
>1710	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>1718	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>1720	9a 06
>1722	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>172a	9b 06
>172c	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>1734	9c 06
>1736	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>173e	06
>173f	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>1746	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>174e	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>1756	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>175e	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>1766	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>176e	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>1776	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>177e	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>1786	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>178e	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>1796	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>179d	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>17a5	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>17ad	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>17b5	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>17bd	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>17c5	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>17cd	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>17d5	00						.byte 	0
.17d6					UnaryTables:
>17d6	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>17dd	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>17e5	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>17ec	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>17f3	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>17fa	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>1801	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>1809	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>1810	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>1818	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>1820	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>1828	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>1830	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>1838	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>1840	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>1847	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>184e	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>1855	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>185c	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>1863	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>186a	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>1872	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>187a	0b ca 00 8f ae 03 fa 19			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>1882	91 bd 07
>1885	07 a8 00 03 19 1a 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>188c	07 a5 00 03 c9 15 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>1893	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>189a	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>18a1	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>18a9	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>18b1	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>18b8	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>18bf	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>18c6	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>18ce	06
>18cf	00						.byte 	0
.18d0					GeneratorProcess:
.18d0	86 2d		stx $2d				stx 	zTemp0 						; save generation pointer in zTemp0
.18d2	84 2e		sty $2e				sty 	zTemp0+1
.18d4	85 2f		sta $2f				sta 	zTemp1 						; first match token
.18d6	64 30		stz $30				stz 	zTemp1+1
.18d8	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.18da	d0 05		bne $18e1			bne 	_GPNotShifted
.18dc	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; get the shifted token
.18df	85 30		sta $30				sta 	zTemp1+1 					; match CE xx
.18e1					_GPNotShifted:
.18e1					_GPSearch:
.18e1	b2 2d		lda ($2d)			lda 	(zTemp0) 					; reached end ?
.18e3	18		clc				clc
.18e4	f0 2f		beq $1915			beq 	_GPExit
.18e6	a0 01		ldy #$01			ldy 	#1 							; tokens match
.18e8	b1 2d		lda ($2d),y			lda 	(zTemp0),y
.18ea	c5 2f		cmp $2f				cmp 	zTemp1
.18ec	d0 09		bne $18f7			bne 	_GPNext
.18ee	a5 30		lda $30				lda 	zTemp1+1 					; 2nd token ?
.18f0	f0 12		beq $1904			beq 	_GPFound
.18f2	c8		iny				iny 								; check match.
.18f3	d1 2d		cmp ($2d),y			cmp 	(zTemp0),y
.18f5	f0 0d		beq $1904			beq 	_GPFound
.18f7					_GPNext:
.18f7	18		clc				clc 								; follow to next
.18f8	a5 2d		lda $2d				lda 	zTemp0
.18fa	72 2d		adc ($2d)			adc 	(zTemp0)
.18fc	85 2d		sta $2d				sta 	zTemp0
.18fe	90 e1		bcc $18e1			bcc 	_GPSearch
.1900	e6 2e		inc $2e				inc 	zTemp0+1
.1902	80 dd		bra $18e1			bra 	_GPSearch
.1904					_GPFound:
.1904	18		clc				clc 								; skip to action bytes
.1905	a5 2d		lda $2d				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.1907	69 03		adc #$03			adc 	#3
.1909	85 2d		sta $2d				sta 	zTemp0
.190b	90 02		bcc $190f			bcc 	_GPNoCarry
.190d	e6 2e		inc $2e				inc 	zTemp0+1
.190f					_GPNoCarry:
.190f					_GPLoop:
.190f	20 16 19	jsr $1916			jsr 	GeneratorExecute 			; execute one command
.1912	90 fb		bcc $190f			bcc 	_GPLoop 					; go back if not completed.
.1914	38		sec				sec 								; return with CS.
.1915					_GPExit:
.1915	60		rts				rts
.1916					GeneratorExecute:
.1916	20 c1 19	jsr $19c1			jsr 	_GEFetchZTemp0 				; get next.
.1919	48		pha				pha 								; split into 2 nibbles
.191a	4a		lsr a				lsr 	a
.191b	4a		lsr a				lsr 	a
.191c	4a		lsr a				lsr		a
.191d	4a		lsr a				lsr 	a
.191e	20 28 19	jsr $1928			jsr 	_GEExecuteNibble 			; MSB first
.1921	68		pla				pla
.1922	b0 03		bcs $1927			bcs 	_GEHaveCompleted
.1924	20 28 19	jsr $1928			jsr 	_GEExecuteNibble 			; LSB second
.1927					_GEHaveCompleted:
.1927	60		rts				rts
.1928					_GEExecuteNibble:
.1928	29 0f		and #$0f			and 	#$0F
.192a	0a		asl a				asl 	a
.192b	aa		tax				tax
.192c	7c 2f 19	jmp ($192f,x)			jmp 	(_GEExecuteVectors,x)
.192f					_GEExecuteVectors:
>192f	4f 19						.word 	_GEXNop 					; 0  (no operation)
>1931	57 19						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>1933	51 19						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>1935	a4 19						.word 	_GEXExecute 				; 3  (run arbitrary code)
>1937	97 19						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>1939	4f 19						.word 	_GEXNop 					; 5
>193b	5e 19						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>193d	62 19						.word 	_GEXExitString 				; 7  exit return string type
>193f	66 19						.word 	_GEXLParam 					; 8  check ( follows
>1941	6a 19						.word 	_GEXRParam 					; 9  check ) follows
>1943	6e 19						.word 	_GEXComma					; A  check , follows
>1945	4f 19						.word 	_GEXNop 					; B
>1947	4f 19						.word 	_GEXNop 					; C
>1949	4f 19						.word 	_GEXNop 					; D
>194b	7e 19						.word 	_GEXNumber 					; E  compile get any number
>194d	89 19						.word 	_GEXString 					; F  compile get any string
.194f					_GEXNop:
.194f	18		clc				clc
.1950	60		rts				rts
.1951					_GEXToken2:
.1951	20 c1 19	jsr $19c1			jsr 	_GEFetchZTemp0
.1954	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1957					_GEXToken1:
.1957	20 c1 19	jsr $19c1			jsr 	_GEFetchZTemp0
.195a	20 da 10	jsr $10da			jsr 	WriteCodeByte
.195d	60		rts				rts
.195e					_GEXExitNumber:
.195e	a9 00		lda #$00			lda 	#NSSIFloat
.1960	38		sec				sec
.1961	60		rts				rts
.1962					_GEXExitString:
.1962	a9 40		lda #$40			lda 	#NSSString
.1964	38		sec				sec
.1965	60		rts				rts
.1966					_GEXLParam:
.1966	a9 28		lda #$28			lda 	#"("
.1968	80 06		bra $1970			bra 	_GEXCheck
.196a					_GEXRParam:
.196a	a9 29		lda #$29			lda 	#")"
.196c	80 02		bra $1970			bra 	_GEXCheck
.196e					_GEXComma:
.196e	a9 2c		lda #$2c			lda 	#","
.1970					_GEXCheck:
.1970	85 31		sta $31				sta 	zTemp2 						; save match
.1972	20 47 1a	jsr $1a47			jsr 	GetNextNonSpace 			; get next skipping spaces
.1975	c5 31		cmp $31				cmp 	zTemp2 						; check matches.
.1977	d0 02		bne $197b			bne 	_GEXSyntax
.1979	18		clc				clc
.197a	60		rts				rts
.197b					_GEXSyntax:
.197b	4c 3b 1f	jmp $1f3b		jmp	ErrorV_syntax
.197e					_GEXNumber:
.197e	20 ca 19	jsr $19ca			jsr 	GEXCompileExpression 		; compile expression
.1981	29 40		and #$40			and 	#NSSTypeMask
.1983	c9 00		cmp #$00			cmp  	#NSSIFloat
.1985	d0 0d		bne $1994			bne 	_GEXType
.1987	18		clc				clc
.1988	60		rts				rts
.1989					_GEXString:
.1989	20 ca 19	jsr $19ca			jsr 	GEXCompileExpression 		; compile expression
.198c	29 40		and #$40			and 	#NSSTypeMask
.198e	c9 40		cmp #$40			cmp  	#NSSString
.1990	d0 02		bne $1994			bne 	_GEXType
.1992	18		clc				clc
.1993	60		rts				rts
.1994					_GEXType:
.1994	4c 4b 1f	jmp $1f4b		jmp	ErrorV_type
.1997					_GEXChannelExec:
.1997	20 da 19	jsr $19da			jsr 	ChannelPrefix 				; set up default
.199a	20 a4 19	jsr $19a4			jsr 	_GEXExecute
.199d	08		php				php
.199e	20 f4 19	jsr $19f4			jsr 	ChannelPostfix 				; replace default.
.19a1	28		plp				plp
.19a2	60		rts				rts
>19a3	db						.byte 	$DB 						; causes a break in the emulator
.19a4					_GEXExecute:
.19a4	20 c1 19	jsr $19c1			jsr 	_GEFetchZTemp0 				; get vector
.19a7	85 31		sta $31				sta 	zTemp2
.19a9	20 c1 19	jsr $19c1			jsr 	_GEFetchZTemp0
.19ac	85 32		sta $32				sta 	zTemp2+1
.19ae	a6 2d		ldx $2d				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19b0	da		phx				phx
.19b1	a6 2e		ldx $2e				ldx 	zTemp0+1
.19b3	da		phx				phx
.19b4	20 be 19	jsr $19be			jsr 	_GECallZTemp2 				; execute code
.19b7	fa		plx				plx 								; recover generation exec
.19b8	86 2e		stx $2e				stx 	zTemp0+1
.19ba	fa		plx				plx
.19bb	86 2d		stx $2d				stx 	zTemp0
.19bd	60		rts				rts
.19be					_GECallZTemp2:
.19be	6c 31 00	jmp ($0031)			jmp 	(zTemp2)
.19c1					_GEFetchZTemp0:
.19c1	b2 2d		lda ($2d)			lda 	(zTemp0)
.19c3	e6 2d		inc $2d				inc 	zTemp0
.19c5	d0 02		bne $19c9			bne 	_GEFZ0Skip
.19c7	e6 2e		inc $2e				inc 	zTemp0+1
.19c9					_GEFZ0Skip:
.19c9	60		rts				rts
.19ca					GEXCompileExpression:
.19ca	a6 2d		ldx $2d				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19cc	da		phx				phx
.19cd	a6 2e		ldx $2e				ldx 	zTemp0+1
.19cf	da		phx				phx
.19d0	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; compile expression.
.19d3	fa		plx				plx 								; recover generation exec
.19d4	86 2e		stx $2e				stx 	zTemp0+1
.19d6	fa		plx				plx
.19d7	86 2d		stx $2d				stx 	zTemp0
.19d9	60		rts				rts
.19da					ChannelPrefix:
.19da	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.19dc	20 da 10	jsr $10da			jsr 	WriteCodeByte
.19df	20 ca 19	jsr $19ca			jsr 	GEXCompileExpression 		; channel #
.19e2	29 40		and #$40			and 	#NSSTypeMask
.19e4	c9 00		cmp #$00			cmp 	#NSSIFloat
.19e6	d0 09		bne $19f1			bne 	_CPXType
.19e8	20 32 11	jsr $1132			jsr 	CheckNextComma 				; check , follows.
.19eb	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.19ed	20 da 10	jsr $10da			jsr 	WriteCodeByte
.19f0	60		rts				rts
.19f1					_CPXType:
.19f1	4c 4b 1f	jmp $1f4b		jmp	ErrorV_type
.19f4					ChannelPostfix:
.19f4	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.19f6	20 da 10	jsr $10da			jsr 	WriteCodeByte
.19f9	60		rts				rts
.19fa					OptionalParameterCompile:
.19fa	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; what follows.
.19fd	c9 2c		cmp #$2c			cmp 	#","
.19ff	d0 0e		bne $1a0f			bne 	_MidDefault
.1a01	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume ,
.1a04	20 de 13	jsr $13de			jsr 	CompileExpressionAt0
.1a07	29 40		and #$40			and 	#NSSTypeMask
.1a09	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a0b	d0 09		bne $1a16			bne 	MidFailType
.1a0d	80 05		bra $1a14			bra 	_MidComplete
.1a0f					_MidDefault:
.1a0f	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1a11	20 eb 11	jsr $11eb			jsr 	PushIntegerA
.1a14					_MidComplete:
.1a14	18		clc				clc
.1a15	60		rts				rts
.1a16					MidFailType:
.1a16	4c 4b 1f	jmp $1f4b		jmp	ErrorV_type
.1a19					NotUnaryCompile:
.1a19	ad 93 14	lda $1493			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1a1c	20 e0 13	jsr $13e0			jsr 	CompileExpressionAtA 		; evaluate at that level
.1a1f	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1a21	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a23	d0 f1		bne $1a16			bne 	MidFailType
.1a25	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1a27	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1a2a	60		rts				rts
.1a2b					LookNext:
.1a2b	b2 24		lda ($24)			lda 	(srcPtr)
.1a2d	60		rts				rts
.1a2e					LookNextNonSpace:
.1a2e	b2 24		lda ($24)			lda 	(srcPtr)
.1a30	c9 20		cmp #$20			cmp		#' '
.1a32	f0 03		beq $1a37			beq 	_LNNSkip
.1a34	c9 00		cmp #$00			cmp 	#0
.1a36	60		rts				rts
.1a37					_LNNSkip:
.1a37	20 3c 1a	jsr $1a3c			jsr 	GetNext
.1a3a	80 f2		bra $1a2e			bra 	LookNextNonSpace
.1a3c					GetNext:
.1a3c	b2 24		lda ($24)			lda 	(srcPtr) 					; get next
.1a3e	e6 24		inc $24				inc 	srcPtr
.1a40	d0 02		bne $1a44			bne 	_GNSkip
.1a42	e6 25		inc $25				inc 	srcPtr+1
.1a44					_GNSkip:
.1a44	c9 00		cmp #$00			cmp 	#0
.1a46	60		rts				rts
.1a47					GetNextNonSpace:
.1a47	20 3c 1a	jsr $1a3c			jsr 	GetNext
.1a4a	c9 20		cmp #$20			cmp 	#' '
.1a4c	f0 f9		beq $1a47			beq 	GetNextNonSpace
.1a4e	c9 00		cmp #$00			cmp 	#0
.1a50	60		rts				rts
.1a51					CharIsDigit:
.1a51	c9 30		cmp #$30			cmp 	#"0"
.1a53	90 06		bcc $1a5b			bcc 	CCFalse
.1a55	c9 3a		cmp #$3a			cmp 	#"9"+1
.1a57	b0 02		bcs $1a5b			bcs 	CCFalse
.1a59					CCTrue:
.1a59	38		sec				sec
.1a5a	60		rts				rts
.1a5b					CCFalse:
.1a5b	18		clc				clc
.1a5c	60		rts				rts
.1a5d					CharIsAlpha:
.1a5d	c9 41		cmp #$41			cmp 	#"A"
.1a5f	90 fa		bcc $1a5b			bcc 	CCFalse
.1a61	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1a63	b0 f6		bcs $1a5b			bcs 	CCFalse
.1a65	80 f2		bra $1a59			bra 	CCTrue
.1a67					ConvertHexStyle:
.1a67	38		sec				sec
.1a68	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1a6a	90 ef		bcc $1a5b			bcc 	CCFalse
.1a6c	c9 0a		cmp #$0a			cmp 	#9+1
.1a6e	90 e9		bcc $1a59			bcc 	CCTrue
.1a70	38		sec				sec 								; shift into hex space A=>0 Z=>25
.1a71	e9 11		sbc #$11			sbc 	#"A"-"0"
.1a73	90 e6		bcc $1a5b			bcc 	CCFalse
.1a75	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.1a77	b0 e2		bcs $1a5b			bcs 	CCFalse
.1a79	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.1a7b	80 dc		bra $1a59			bra 	CCTrue
.1a7d					CommandGET:
.1a7d	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; # follows ?
.1a80	c9 23		cmp #$23			cmp 	#"#"
.1a82	d0 0d		bne $1a91			bne 	CommandGetBody
.1a84	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume #
.1a87	20 da 19	jsr $19da			jsr 	ChannelPrefix 				; do it as GET#
.1a8a	20 91 1a	jsr $1a91			jsr 	CommandGetBody
.1a8d	20 f4 19	jsr $19f4			jsr 	ChannelPostfix
.1a90	60		rts				rts
.1a91					CommandGetBody:
.1a91	20 47 1a	jsr $1a47			jsr 	GetNextNonSpace 			; get the first character
.1a94	20 9d 1d	jsr $1d9d			jsr 	GetReferenceTerm 			; identify variable to assign to
.1a97	48		pha				pha
.1a98	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1a9a	c9 40		cmp #$40			cmp 	#NSSString
.1a9c	d0 0b		bne $1aa9			bne 	_CGType
.1a9e	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1aa0	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1aa3	38		sec				sec
.1aa4	68		pla				pla
.1aa5	20 4f 1d	jsr $1d4f			jsr		GetSetVariable
.1aa8	60		rts				rts
.1aa9					_CGType:
.1aa9	4c 4b 1f	jmp $1f4b		jmp	ErrorV_type
.1aac					ExtractVariableName:
.1aac	20 5d 1a	jsr $1a5d			jsr 	CharIsAlpha
.1aaf	90 50		bcc $1b01			bcc 	_IVSyntax
.1ab1	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.1ab3	85 2f		sta $2f				sta 	zTemp1 						; we'll build it in zTemp1
.1ab5	64 30		stz $30				stz 	zTemp1+1
.1ab7	20 2b 1a	jsr $1a2b			jsr 	LookNext 					; is there a second character ?
.1aba	20 5d 1a	jsr $1a5d			jsr 	CharIsAlpha  				; must be alphanumeric
.1abd	b0 05		bcs $1ac4			bcs 	_IVHasSecond
.1abf	20 51 1a	jsr $1a51			jsr 	CharIsDigit
.1ac2	90 07		bcc $1acb			bcc 	_IVCheckType
.1ac4					_IVHasSecond:
.1ac4	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.1ac6	85 30		sta $30				sta 	zTemp1+1
.1ac8					_IVGetNextCheck:
.1ac8	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume it
.1acb					_IVCheckType:
.1acb	20 2b 1a	jsr $1a2b			jsr 	LookNext					; check if string follows.
.1ace	20 5d 1a	jsr $1a5d			jsr 	CharIsAlpha
.1ad1	b0 f5		bcs $1ac8			bcs 	_IVGetNextCheck
.1ad3	20 51 1a	jsr $1a51			jsr 	CharIsDigit
.1ad6	b0 f0		bcs $1ac8			bcs 	_IVGetNextCheck
.1ad8	a2 40		ldx #$40			ldx 	#NSSString
.1ada	c9 24		cmp #$24			cmp 	#"$"
.1adc	f0 06		beq $1ae4			beq 	_IVHasType
.1ade	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.1ae0	c9 25		cmp #$25			cmp 	#"%"
.1ae2	d0 08		bne $1aec			bne 	_IVCheckArray
.1ae4					_IVHasType:
.1ae4	8a		txa				txa 								; Or X into zTemp1
.1ae5	05 2f		ora $2f				ora 	zTemp1
.1ae7	85 2f		sta $2f				sta 	zTemp1
.1ae9	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume it
.1aec					_IVCheckArray:
.1aec	20 2b 1a	jsr $1a2b			jsr 	LookNext 					; check if array follows
.1aef	c9 28		cmp #$28			cmp 	#"("
.1af1	d0 09		bne $1afc			bne 	_IVNotArray
.1af3	a5 2f		lda $2f				lda 	zTemp1 						; set array bit
.1af5	09 80		ora #$80			ora 	#NSSArray
.1af7	85 2f		sta $2f				sta 	zTemp1
.1af9	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume it
.1afc					_IVNotArray:
.1afc	a6 2f		ldx $2f				ldx 	zTemp1
.1afe	a4 30		ldy $30				ldy 	zTemp1+1
.1b00	60		rts				rts
.1b01					_IVSyntax:
.1b01	4c 3b 1f	jmp $1f3b		jmp	ErrorV_syntax
.1b04					CommandGOSUB:
.1b04	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1b06	20 17 1b	jsr $1b17			jsr 	CompileBranchCommand
.1b09	60		rts				rts
.1b0a					CommandGOAlt:
.1b0a	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1b0c	20 3c 11	jsr $113c			jsr 	CheckNextA
.1b0f	80 00		bra $1b11			bra 	CommandGOTO
.1b11					CommandGOTO:
.1b11	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1b13	20 17 1b	jsr $1b17			jsr 	CompileBranchCommand
.1b16	60		rts				rts
.1b17					CompileBranchCommand:
.1b17	20 da 10	jsr $10da			jsr 	WriteCodeByte 				; write the command out.
.1b1a	20 47 1a	jsr $1a47			jsr 	GetNextNonSpace
.1b1d	20 a5 1c	jsr $1ca5			jsr 	ParseConstant 				; get constant into YA
.1b20	90 0f		bcc $1b31			bcc 	_CBCSyntax
.1b22	48		pha				pha
.1b23	a9 ff		lda #$ff			lda 	#$FF 						; no address yet.
.1b25	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b28	68		pla				pla 								; and compile the actual line number
.1b29	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b2c	98		tya				tya
.1b2d	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b30	60		rts				rts
.1b31					_CBCSyntax:
.1b31	4c 3b 1f	jmp $1f3b		jmp	ErrorV_syntax
.1b34					CommandIF:
.1b34	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; what follows the tests ?
.1b37	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1b39	f0 0f		beq $1b4a			beq 	_CIGoto
.1b3b	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1b3d	20 3c 11	jsr $113c			jsr 	CheckNextA
.1b40	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; THEN <number>
.1b43	20 51 1a	jsr $1a51			jsr 	CharIsDigit
.1b46	b0 05		bcs $1b4d			bcs 	_CIGoto2
.1b48	80 09		bra $1b53			bra 	CompileGotoEOL
.1b4a					_CIGoto:
.1b4a	20 3c 1a	jsr $1a3c			jsr 	GetNext
.1b4d					_CIGoto2:
.1b4d	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1b4f	20 17 1b	jsr $1b17			jsr 	CompileBranchCommand
.1b52	60		rts				rts
.1b53					CompileGotoEOL:
.1b53	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.1b55	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b58	a9 ff		lda #$ff			lda 	#$FF
.1b5a	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b5d	20 d3 10	jsr $10d3			jsr 	GetLineNumber 				; Get the current line number => YA
.1b60	1a		inc a				inc 	a 							; and branch to +1
.1b61	d0 01		bne $1b64			bne 	_CGENoCarry
.1b63	c8		iny				iny
.1b64					_CGENoCarry:
.1b64	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b67	98		tya				tya
.1b68	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b6b	60		rts				rts
.1b6c					CommandINPUT:
.1b6c	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; check for "
.1b6f	c9 22		cmp #$22			cmp 	#'"'
.1b71	d0 0d		bne $1b80			bne 	CommandINPUTStream
.1b73	20 de 13	jsr $13de			jsr 	CompileExpressionAt0
.1b76	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1b78	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b7b	a9 2c		lda #$2c			lda 	#","
.1b7d	20 32 11	jsr $1132			jsr 	CheckNextComma
.1b80					CommandINPUTStream:
.1b80	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1b82	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1b85	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.1b87	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1b89	4c 17 1d	jmp $1d17			jmp 	CommandReadInputCommon
.1b8c					CommandLET:
.1b8c	20 47 1a	jsr $1a47			jsr 	GetNextNonSpace 			; get the first character
.1b8f					CommandLETHaveFirst:
.1b8f	20 9d 1d	jsr $1d9d			jsr 	GetReferenceTerm 			; identify variable to assign to
.1b92	da		phx				phx 								; save target on the stack.
.1b93	5a		phy				phy
.1b94	48		pha				pha
.1b95	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.1b97	20 3c 11	jsr $113c			jsr 	CheckNextA
.1b9a	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1b9d	85 2d		sta $2d				sta 	zTemp0 						; save type returned
.1b9f	68		pla				pla 								; get type of assignment
.1ba0	48		pha				pha
.1ba1	45 2d		eor $2d				eor 	zTemp0 						; compare using EOR
.1ba3	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.1ba5	d0 17		bne $1bbe			bne 	_CLType
.1ba7	68		pla				pla 								; restore and compile save code
.1ba8	7a		ply				ply
.1ba9	fa		plx				plx
.1baa	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.1bac	f0 05		beq $1bb3			beq 	_CLTIString
.1bae	38		sec				sec
.1baf	20 4f 1d	jsr $1d4f			jsr		GetSetVariable
.1bb2	60		rts				rts
.1bb3					_CLTIString:
.1bb3	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.1bb5	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1bb8	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.1bba	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1bbd	60		rts				rts
.1bbe					_CLType:
.1bbe	4c 4b 1f	jmp $1f4b		jmp	ErrorV_type
.1bc1					STRMarkLine:
.1bc1	48		pha				pha
.1bc2	38		sec				sec 								; allocate 5 bytes (line #, page+address)
.1bc3	ad 0f 05	lda $050f			lda 	lineNumberTable 			; and copy to zTemp0
.1bc6	e9 05		sbc #$05			sbc 	#5
.1bc8	8d 0f 05	sta $050f			sta 	lineNumberTable
.1bcb	85 2d		sta $2d				sta 	zTemp0
.1bcd	ad 10 05	lda $0510			lda 	lineNumberTable+1
.1bd0	e9 00		sbc #$00			sbc 	#0
.1bd2	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1bd5	85 2e		sta $2e				sta 	zTemp0+1
.1bd7	68		pla				pla
.1bd8	92 2d		sta ($2d)			sta 	(zTemp0) 					; save it in +0,+1
.1bda	98		tya				tya
.1bdb	a0 01		ldy #$01			ldy 	#1
.1bdd	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1bdf	a5 2b		lda $2b				lda 	objPage 					; and page# in +2
.1be1	c8		iny				iny
.1be2	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1be4	a5 29		lda $29				lda 	objPtr 						; save current address in +3,+4
.1be6	c8		iny				iny
.1be7	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1be9	a5 2a		lda $2a				lda 	objPtr+1
.1beb	c8		iny				iny
.1bec	91 2d		sta ($2d),y			sta 	(zTemp0),y
.1bee	60		rts				rts
.1bef					STRFindLine:
.1bef	85 2d		sta $2d				sta 	zTemp0 						; zTemp0 line number being searched
.1bf1	84 2e		sty $2e				sty 	zTemp0+1
.1bf3	ad 08 05	lda $0508			lda 	compilerEndHigh 			; work backwards through table
.1bf6	85 30		sta $30				sta 	zTemp1+1
.1bf8	64 2f		stz $2f				stz 	zTemp1
.1bfa					_STRSearch:
.1bfa	20 35 1c	jsr $1c35			jsr 	_STRPrevLine 				; look at previous record.
.1bfd	a0 01		ldy #$01			ldy 	#1
.1bff	b2 2f		lda ($2f)			lda 	(zTemp1) 					; check table line # >= target
.1c01	c5 2d		cmp $2d				cmp 	zTemp0
.1c03	b1 2f		lda ($2f),y			lda 	(zTemp1),y
.1c05	e5 2e		sbc $2e				sbc 	zTemp0+1
.1c07	b0 0b		bcs $1c14			bcs 	_STRFound 					; >=
.1c09					_STRNext:
.1c09	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1c0b	b1 2f		lda ($2f),y			lda 	(zTemp1),y
.1c0d	c9 ff		cmp #$ff			cmp 	#$FF
.1c0f	d0 e9		bne $1bfa			bne 	_STRSearch
.1c11	4c 95 1f	jmp $1f95		jmp	ErrorV_internal
.1c14					_STRFound:
.1c14	b2 2f		lda ($2f)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1c16	45 2d		eor $2d				eor 	zTemp0
.1c18	d0 06		bne $1c20			bne 	_STRDifferent
.1c1a	b2 2f		lda ($2f)			lda 	(zTemp1)
.1c1c	45 2d		eor $2d				eor 	zTemp0
.1c1e	f0 02		beq $1c22			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1c20					_STRDifferent:
.1c20	a9 ff		lda #$ff			lda 	#$FF
.1c22					_STROut:
.1c22	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1c23	69 ff		adc #$ff			adc 	#255
.1c25	08		php				php
.1c26	c8		iny				iny 								; page into X
.1c27	b1 2f		lda ($2f),y			lda 	(zTemp1),y
.1c29	aa		tax				tax
.1c2a	c8		iny				iny 								; address into YA
.1c2b	b1 2f		lda ($2f),y			lda 	(zTemp1),y
.1c2d	48		pha				pha
.1c2e	c8		iny				iny
.1c2f	b1 2f		lda ($2f),y			lda 	(zTemp1),y
.1c31	a8		tay				tay
.1c32	68		pla				pla
.1c33	28		plp				plp
.1c34	60		rts				rts
.1c35					_STRPrevLine:
.1c35	38		sec				sec 								; move backwards one entry.
.1c36	a5 2f		lda $2f				lda 	zTemp1
.1c38	e9 05		sbc #$05			sbc 	#5
.1c3a	85 2f		sta $2f				sta 	zTemp1
.1c3c	a5 30		lda $30				lda 	zTemp1+1
.1c3e	e9 00		sbc #$00			sbc 	#0
.1c40	85 30		sta $30				sta 	zTemp1+1
.1c42	60		rts				rts
.1c43					STRMakeOffset:
.1c43	18		clc				clc 								; borrow 1
.1c44	e5 29		sbc $29				sbc 	objPtr
.1c46	48		pha				pha
.1c47	98		tya				tya
.1c48	e5 2a		sbc $2a				sbc 	objPtr+1
.1c4a	a8		tay				tay
.1c4b	68		pla				pla
.1c4c	60		rts				rts
.1c4d					CommandNEXT:
.1c4d	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1c50	20 5d 1a	jsr $1a5d			jsr 	CharIsAlpha 				; if not alpha , error
.1c53	90 0c		bcc $1c61			bcc 	_CNNoReferenceGiven
.1c55	20 3c 1a	jsr $1a3c			jsr 	GetNext
.1c58	20 9d 1d	jsr $1d9d			jsr 	GetReferenceTerm 			; figure out the reference.
.1c5b	8a		txa				txa 								; reference in YA
.1c5c	20 d8 11	jsr $11d8			jsr 	PushIntegerYA 				; write it out.
.1c5f	80 06		bra $1c67			bra 	_CNParametersDone
.1c61					_CNNoReferenceGiven:
.1c61	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1c63	a8		tay				tay
.1c64	20 d8 11	jsr $11d8			jsr 	PushIntegerYA 				; write it out.
.1c67					_CNParametersDone:
.1c67	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1c69	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1c6c	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; look for ,
.1c6f	c9 2c		cmp #$2c			cmp 	#","
.1c71	d0 05		bne $1c78			bne 	_CNExit
.1c73	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume ,
.1c76	80 d5		bra $1c4d			bra 	CommandNEXT 				; and go round.
.1c78					_CNExit:
.1c78	60		rts				rts
.1c79					CommandON:
.1c79	20 47 1a	jsr $1a47			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1c7c	48		pha				pha 								; save on stack
.1c7d	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1c7f	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1c81	f0 09		beq $1c8c			beq 	_COCreateLoop
.1c83	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1c85	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1c87	f0 03		beq $1c8c			beq 	_COCreateLoop
.1c89	4c 3b 1f	jmp $1f3b		jmp	ErrorV_syntax
.1c8c					_COCreateLoop:
.1c8c	8a		txa				txa 								; compile a goto/gosub somewhere
.1c8d	da		phx				phx
.1c8e	20 17 1b	jsr $1b17			jsr 	CompileBranchCommand
.1c91	fa		plx				plx
.1c92	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace			; ',' follows
.1c95	c9 2c		cmp #$2c			cmp 	#","
.1c97	d0 0a		bne $1ca3			bne 	_COComplete 				; if so, more line numbers
.1c99	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1c9b	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1c9e	20 3c 1a	jsr $1a3c			jsr 	GetNext
.1ca1	80 e9		bra $1c8c			bra 	_COCreateLoop
.1ca3					_COComplete:
.1ca3	68		pla				pla 								; throw GOTO/GOSUB
.1ca4	60		rts				rts
.1ca5					ParseConstant:
.1ca5	a2 00		ldx #$00			ldx 	#0
.1ca7	20 61 24	jsr $2461			jsr 	FloatEncodeStart 			; send first
.1caa					_ParseLoop:
.1caa	20 2b 1a	jsr $1a2b			jsr 	LookNext 					; send subsequent
.1cad	20 64 24	jsr $2464			jsr 	FloatEncodeContinue
.1cb0	90 05		bcc $1cb7			bcc 	_ParseDone
.1cb2	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume it
.1cb5	80 f3		bra $1caa			bra 	_ParseLoop
.1cb7					_ParseDone:
.1cb7	b5 33		lda $33,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1cb9	29 80		and #$80			and 	#$80
.1cbb	15 6f		ora $6f,x			ora 	NSExponent,x 				; 16 bit int check
.1cbd	15 57		ora $57,x			ora 	NSMantissa2,x
.1cbf	15 63		ora $63,x			ora 	NSMantissa3,x
.1cc1	18		clc				clc
.1cc2	d0 05		bne $1cc9			bne 	_ParseExit 					; exit with CC if need float to compile
.1cc4	b5 3f		lda $3f,x			lda 	NSMantissa0,x 				; read into YA.
.1cc6	b4 4b		ldy $4b,x			ldy		NSMantissa1,x
.1cc8	38		sec				sec
.1cc9					_ParseExit:
.1cc9	60		rts				rts
.1cca					CommandPRINT:
.1cca	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace			; what follows ?
.1ccd	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1ccf	f0 1f		beq $1cf0			beq 	_CPCheckEnd
.1cd1	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1cd3	f0 16		beq $1ceb			beq 	_CPTabCheckEnd
.1cd5	20 07 1d	jsr $1d07			jsr 	_CPAtEnd 					; check for : and EOL
.1cd8	b0 22		bcs $1cfc			bcs 	_CPExitCR 					; exit with CR
.1cda	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; so it is something to print
.1cdd	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1cdf	29 40		and #$40			and 	#NSSString 					; if string
.1ce1	d0 02		bne $1ce5			bne 	_CPOut
.1ce3	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1ce5					_CPOut:
.1ce5	8a		txa				txa 								; print that thing
.1ce6	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1ce9	80 df		bra $1cca			bra 	CommandPRINT 				; and loop round/
.1ceb					_CPTabCheckEnd:
.1ceb	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1ced	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1cf0					_CPCheckEnd:
.1cf0	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume it.
.1cf3	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; what follows ?
.1cf6	20 07 1d	jsr $1d07			jsr 	_CPAtEnd 					; reached end
.1cf9	90 cf		bcc $1cca			bcc 	CommandPRINT 				; no, loop back
.1cfb	60		rts				rts
.1cfc					_CPExitCR:
.1cfc	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1cfe	20 eb 11	jsr $11eb			jsr 	PushIntegerA
.1d01	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1d03	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1d06	60		rts				rts
.1d07					_CPAtEnd:
.1d07	c9 00		cmp #$00			cmp 	#0
.1d09	f0 06		beq $1d11			beq 	_CPIsEnd
.1d0b	c9 3a		cmp #$3a			cmp 	#":"
.1d0d	f0 02		beq $1d11			beq 	_CPIsEnd
.1d0f	18		clc				clc
.1d10	60		rts				rts
.1d11					_CPIsEnd:
.1d11	38		sec				sec
.1d12	60		rts				rts
.1d13					CommandREAD:
.1d13	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1d15	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1d17					CommandReadInputCommon:
.1d17	8e 0d 05	stx $050d			stx 	numberPCode
.1d1a	8c 0e 05	sty $050e			sty 	stringPCode
.1d1d					_CRLoop:
.1d1d	20 47 1a	jsr $1a47			jsr 	GetNextNonSpace 			; first char of identifier
.1d20	20 5d 1a	jsr $1a5d			jsr 	CharIsAlpha 				; check A-Z
.1d23	90 27		bcc $1d4c			bcc 	_CRSyntax
.1d25	20 9d 1d	jsr $1d9d			jsr 	GetReferenceTerm 			; get the variable.
.1d28	48		pha				pha 								; save type.
.1d29	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1d2b	c9 40		cmp #$40			cmp 	#NSSString
.1d2d	f0 05		beq $1d34			beq 	_CRString
.1d2f	ad 0d 05	lda $050d			lda 	numberPCode 				; output read/input
.1d32	80 03		bra $1d37			bra 	_CRHaveType
.1d34					_CRString:
.1d34	ad 0e 05	lda $050e			lda 	stringPCode					; output read$/input$
.1d37					_CRHaveType:
.1d37	20 da 10	jsr $10da			jsr 	WriteCodeByte 				; so we have one typed data item.
.1d3a	68		pla				pla 								; restore type
.1d3b	38		sec				sec  								; write update code.
.1d3c	20 4f 1d	jsr $1d4f			jsr 	GetSetVariable
.1d3f	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; , follows ?
.1d42	c9 2c		cmp #$2c			cmp 	#","
.1d44	d0 05		bne $1d4b			bne 	_CRExit 					; if not, end of READ.
.1d46	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume comma
.1d49	80 d2		bra $1d1d			bra 	_CRLoop 					; keep going
.1d4b					_CRExit:
.1d4b	60		rts				rts
.1d4c					_CRSyntax:
.1d4c	4c 3b 1f	jmp $1f3b		jmp	ErrorV_syntax
.050d					numberPCode:
>050d							.fill 	1
.050e					stringPCode:
>050e							.fill 	1
.1d4f					GetSetVariable:
.1d4f	08		php				php 								; save direction on stack
.1d50	c0 00		cpy #$00			cpy 	#$00
.1d52	30 21		bmi $1d75			bmi 	_GSVReadWriteSpecial
.1d54	c9 00		cmp #$00			cmp 	#$00
.1d56	30 33		bmi $1d8b			bmi 	_GSVArray
.1d58	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1d5a	4a		lsr a				lsr 	a 							; divide by 2
.1d5b	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1d5d	28		plp				plp
.1d5e	90 02		bcc $1d62			bcc 	_GSVNotWrite
.1d60	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1d62					_GSVNotWrite:
.1d62	85 2d		sta $2d				sta 	zTemp0
.1d64	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1d65	4a		lsr a				lsr 	a
.1d66	a8		tay				tay
.1d67	8a		txa				txa
.1d68	6a		ror a				ror 	a
.1d69	aa		tax				tax
.1d6a	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1d6b	05 2d		ora $2d				ora 	zTemp0 						; which is the first byte of the opcode
.1d6d	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1d70	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1d71	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1d74	60		rts				rts
.1d75					_GSVReadWriteSpecial:
.1d75	28		plp				plp
.1d76	b0 10		bcs $1d88			bcs 	_GSVSyntax
.1d78	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1d7a	f0 06		beq $1d82			beq 	_GSVRWString
.1d7c	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1d7e	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1d81	60		rts				rts
.1d82					_GSVRWString:
.1d82	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1d84	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1d87	60		rts				rts
.1d88					_GSVSyntax:
.1d88	4c 3b 1f	jmp $1f3b		jmp	ErrorV_syntax
.1d8b					_GSVArray:
.1d8b	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1d8d	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1d8e	4a		lsr a				lsr 	a
.1d8f	4a		lsr a				lsr 	a
.1d90	4a		lsr a				lsr 	a
.1d91	4a		lsr a				lsr 	a
.1d92	28		plp				plp 								; if writing array then set bit 2.
.1d93	90 02		bcc $1d97			bcc 	_GSVANotWrite
.1d95	09 04		ora #$04			ora 	#4
.1d97					_GSVANotWrite:
.1d97	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1d99	20 da 10	jsr $10da			jsr 	WriteCodeByte 				; and write it out
.1d9c	60		rts				rts
.1d9d					GetReferenceTerm:
.1d9d	20 ac 1a	jsr $1aac			jsr 	ExtractVariableName 		; get name & type info
.1da0	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1da2	30 10		bmi $1db4			bmi 	_GRTArray
.1da4	da		phx				phx 								; save type on stack
.1da5	20 98 14	jsr $1498			jsr 	FindVariable 				; find it
.1da8	b0 06		bcs $1db0			bcs 	_GRTNoCreate 				; create if required.
.1daa	20 1d 12	jsr $121d			jsr 	CreateVariableRecord 		; create a variable.
.1dad	20 77 12	jsr $1277			jsr 	AllocateBytesForType 		; allocate memory for it
.1db0					_GRTNoCreate:
.1db0	68		pla				pla 								; get type back, strip out type information.
.1db1	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1db3	60		rts				rts
.1db4					_GRTArray:
.1db4	da		phx				phx 								; save type information
.1db5	20 98 14	jsr $1498			jsr 	FindVariable 				; read its data, the base address in YX
.1db8	90 18		bcc $1dd2			bcc 	_GRTUndeclared 				; undeclared array.
.1dba	da		phx				phx 								; save base address
.1dbb	5a		phy				phy
.1dbc	20 6e 13	jsr $136e			jsr 	OutputIndexGroup 			; create an index group and generate them
.1dbf	7a		ply				ply 								; get the array base address into YX
.1dc0	fa		plx				plx
.1dc1	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1dc3	18		clc				clc
.1dc4	20 4f 1d	jsr $1d4f			jsr 	GetSetVariable 				; load the address of the array structure.
.1dc7	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1dc9	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1dcc	68		pla				pla 								; and the type data into A
.1dcd	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1dcf	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1dd1	60		rts				rts
.1dd2					_GRTUndeclared:
.1dd2	4c f2 1f	jmp $1ff2		jmp	ErrorV_undeclared
.1dd5					CommandREM:
.1dd5	20 2b 1a	jsr $1a2b			jsr 	LookNext
.1dd8	f0 05		beq $1ddf			beq 	_CRExit
.1dda	20 3c 1a	jsr $1a3c			jsr 	GetNext
.1ddd	80 f6		bra $1dd5			bra 	CommandREM
.1ddf					_CRExit:
.1ddf	60		rts				rts
.1de0					STRReset:
.1de0	ad 07 05	lda $0507			lda	 	compilerStartHigh 			; set up the two table pointers
.1de3	8d 12 05	sta $0512			sta 	variableListEnd+1
.1de6	9c 11 05	stz $0511			stz 	variableListEnd
.1de9	ad 08 05	lda $0508			lda 	compilerEndHigh
.1dec	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1def	9c 0f 05	stz $050f			stz 	lineNumberTable
.1df2	ad 11 05	lda $0511			lda 	variableListEnd
.1df5	85 2e		sta $2e				sta 	zTemp0+1
.1df7	64 2d		stz $2d				stz 	zTemp0
.1df9	a9 00		lda #$00			lda 	#0
.1dfb	92 2d		sta ($2d)			sta 	(zTemp0)
.1dfd	a9 00		lda #$00			lda 	#((0) & $FF)
.1dff	8d 13 05	sta $0513			sta 	0+freeVariableMemory
.1e02	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1e04	8d 14 05	sta $0514			sta 	1+freeVariableMemory
.1e07	60		rts				rts
.050f					lineNumberTable:
>050f							.fill 	2
.0511					variableListEnd:
>0511							.fill 	2
.0513					freeVariableMemory:
>0513							.fill 	2
.1e08					CompileTerm:
.1e08	20 47 1a	jsr $1a47			jsr 	GetNextNonSpace 			; get first non space character.
.1e0b	30 72		bmi $1e7f			bmi 	_CTUnaryFunctions
.1e0d	20 51 1a	jsr $1a51			jsr 	CharIsDigit 				; found a number
.1e10	b0 3a		bcs $1e4c			bcs 	_CTDigit
.1e12	c9 2e		cmp #$2e			cmp 	#"."
.1e14	f0 36		beq $1e4c			beq 	_CTDigit
.1e16	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1e18	f0 43		beq $1e5d			beq 	_CTString
.1e1a	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1e1c	f0 28		beq $1e46			beq 	_CTOtherBase
.1e1e	c9 24		cmp #$24			cmp 	#"$"
.1e20	f0 24		beq $1e46			beq 	_CTOtherBase
.1e22	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1e24	f0 17		beq $1e3d			beq 	_CTBrackets
.1e26	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1e28	90 10		bcc $1e3a			bcc 	_CTSyntax
.1e2a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1e2c	b0 0c		bcs $1e3a			bcs 	_CTSyntax
.1e2e	20 9d 1d	jsr $1d9d			jsr 	GetReferenceTerm 			; figure out what it is.
.1e31	48		pha				pha 								; save type on stack
.1e32	18		clc				clc 								; read it
.1e33	20 4f 1d	jsr $1d4f			jsr 	GetSetVariable
.1e36	68		pla				pla
.1e37	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1e39	60		rts				rts
.1e3a					_CTSyntax:
.1e3a	4c 3b 1f	jmp $1f3b		jmp	ErrorV_syntax
.1e3d					_CTBrackets:
.1e3d	20 de 13	jsr $13de			jsr 	CompileExpressionAt0
.1e40	48		pha				pha
.1e41	20 36 11	jsr $1136			jsr 	CheckNextRParen
.1e44	68		pla				pla
.1e45	60		rts				rts
.1e46					_CTOtherBase:
.1e46	20 88 10	jsr $1088			jsr 	InlineNonDecimal 			; non decimal constant handler
.1e49	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e4b	60		rts				rts
.1e4c					_CTDigit:
.1e4c	20 a5 1c	jsr $1ca5			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1e4f	90 06		bcc $1e57			bcc	 	_CTFloat 					; have a float or long int.
.1e51	20 d8 11	jsr $11d8			jsr 	PushIntegerYA 				; code to push on stack
.1e54	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e56	60		rts				rts
.1e57					_CTFloat:
.1e57	20 fa 11	jsr $11fa			jsr 	PushFloat  					; code to push float
.1e5a	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1e5c	60		rts				rts
.1e5d					_CTString:
.1e5d	20 0b 11	jsr $110b			jsr 	BufferClear 				; copy it to the buffer
.1e60					_CTStringLoop:
.1e60	20 2b 1a	jsr $1a2b			jsr 	LookNext 					; reached EOL/EOS
.1e63	f0 d5		beq $1e3a			beq 	_CTSyntax
.1e65	c9 22		cmp #$22			cmp 	#'"'
.1e67	f0 08		beq $1e71			beq 	_CTStringDone
.1e69	20 0f 11	jsr $110f			jsr 	BufferWrite 				; write and consume
.1e6c	20 3c 1a	jsr $1a3c			jsr 	GetNext
.1e6f	80 ef		bra $1e60			bra 	_CTStringLoop
.1e71					_CTStringDone:
.1e71	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume closing quote.
.1e74	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1e76	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1e79	20 1b 11	jsr $111b			jsr 	BufferOutput
.1e7c	a9 40		lda #$40			lda 	#NSSString 					; string type
.1e7e	60		rts				rts
.1e7f					_CTUnaryFunctions:
.1e7f	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1e81	f0 0a		beq $1e8d			beq 	_CTNegation
.1e83	a2 d6		ldx #$d6			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1e85	a0 17		ldy #$17			ldy 	#UnaryTables >> 8
.1e87	20 d0 18	jsr $18d0			jsr 	GeneratorProcess
.1e8a	90 ae		bcc $1e3a			bcc		_CTSyntax
.1e8c	60		rts				rts
.1e8d					_CTNegation:
.1e8d	20 08 1e	jsr $1e08			jsr 	CompileTerm 				; compile a term.
.1e90	48		pha				pha
.1e91	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1e93	c9 00		cmp #$00			cmp 	#NSSIFloat
.1e95	d0 07		bne $1e9e			bne 	_CTType 					; error
.1e97	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1e99	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1e9c	68		pla				pla 								; return original type.
.1e9d	60		rts				rts
.1e9e					_CTType:
.1e9e	4c 4b 1f	jmp $1f4b		jmp	ErrorV_type
.1ea1					CommandWAIT:
.1ea1	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace
.1ea4	c9 2c		cmp #$2c			cmp 	#","
.1ea6	f0 10		beq $1eb8			beq 	_CWThirdParameter
.1ea8	a9 00		lda #$00			lda 	#0
.1eaa	20 eb 11	jsr $11eb			jsr 	PushIntegerA
.1ead					_CWExit:
.1ead	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1eaf	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1eb2	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1eb4	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1eb7	60		rts				rts
.1eb8					_CWThirdParameter:
.1eb8	20 3c 1a	jsr $1a3c			jsr 	GetNext
.1ebb	20 e0 13	jsr $13e0			jsr 	CompileExpressionAtA
.1ebe	29 40		and #$40			and 	#NSSTypeMask
.1ec0	c9 00		cmp #$00			cmp 	#NSSIFloat
.1ec2	f0 e9		beq $1ead			beq 	_CWExit
.1ec4	4c 4b 1f	jmp $1f4b		jmp	ErrorV_type
.1ec7					CommandCMD:
.1ec7	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.1ec9	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1ecc	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; followed by a , ?
.1ecf	c9 2c		cmp #$2c			cmp 	#","
.1ed1	d0 06		bne $1ed9			bne 	_CCMDExit
.1ed3	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume comma.
.1ed6	20 ca 1c	jsr $1cca			jsr 	CommandPRINT 				; do the print code
.1ed9					_CCMDExit:
.1ed9	60		rts				rts
.1eda					CommandOPEN:
.1eda	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; followed by a , ?
.1edd	c9 2c		cmp #$2c			cmp 	#","
.1edf	d0 15		bne $1ef6			bne 	_COTwoDefaults
.1ee1	20 3c 1a	jsr $1a3c			jsr 	GetNext 					; consume comma
.1ee4	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1ee7	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1ee9	f0 1e		beq $1f09			beq 	_COThreeIntegers
.1eeb	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1eed	20 eb 11	jsr $11eb			jsr 	PushIntegerA
.1ef0	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1ef2	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1ef5	60		rts				rts
.1ef6					_COTwoDefaults:
.1ef6	a9 00		lda #$00			lda 	#0
.1ef8	20 eb 11	jsr $11eb			jsr 	PushIntegerA
.1efb					_COCompileNullString:
.1efb	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1efd	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1f00	a9 00		lda #$00			lda 	#0
.1f02	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1f05	20 da 10	jsr $10da			jsr 	WriteCodeByte
.1f08	60		rts				rts
.1f09					_COThreeIntegers:
.1f09	20 2e 1a	jsr $1a2e			jsr 	LookNextNonSpace 			; is there a ,
.1f0c	c9 2c		cmp #$2c			cmp 	#","
.1f0e	d0 eb		bne $1efb			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1f10	20 3c 1a	jsr $1a3c			jsr 	GetNext
.1f13	20 de 13	jsr $13de			jsr 	CompileExpressionAt0 		; should be a filename
.1f16	29 40		and #$40			and 	#NSSString
.1f18	f0 01		beq $1f1b			beq 	_COType
.1f1a	60		rts				rts
.1f1b					_COType:
.1f1b	4c 4b 1f	jmp $1f4b		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					codePage:
>0028							.fill 	1
.0029					objPtr:
>0029							.fill 	2 							; bytes must not change (it could expand) as the
.002b					objPage:
>002b							.fill 	1
.002c					objIncrement:
>002c							.fill 	1
.002d					zTemp0:
>002d							.fill 	2
.002f					zTemp1:
>002f							.fill 	2
.0031					zTemp2:
>0031							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1f1e					ErrorV_range:
.1f1e	20 96 13	jsr $1396		jsr	ErrorHandler
>1f21	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f29	41 4e 47 45 00
.1f2e					ErrorV_value:
.1f2e	20 96 13	jsr $1396		jsr	ErrorHandler
>1f31	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f39	45 00
.1f3b					ErrorV_syntax:
.1f3b	20 96 13	jsr $1396		jsr	ErrorHandler
>1f3e	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f46	52 52 4f 52 00
.1f4b					ErrorV_type:
.1f4b	20 96 13	jsr $1396		jsr	ErrorHandler
>1f4e	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f56	4d 41 54 43 48 00
.1f5c					ErrorV_unimplemented:
.1f5c	20 96 13	jsr $1396		jsr	ErrorHandler
>1f5f	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f67	45 4d 45 4e 54 45 44 00
.1f6f					ErrorV_assert:
.1f6f	20 96 13	jsr $1396		jsr	ErrorHandler
>1f72	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f7a	41 49 4c 00
.1f7e					ErrorV_line:
.1f7e	20 96 13	jsr $1396		jsr	ErrorHandler
>1f81	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f89	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f95					ErrorV_internal:
.1f95	20 96 13	jsr $1396		jsr	ErrorHandler
>1f98	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1fa0	20 45 52 52 4f 52 00
.1fa7					ErrorV_divzero:
.1fa7	20 96 13	jsr $1396		jsr	ErrorHandler
>1faa	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fb2	59 20 5a 45 52 4f 00
.1fb9					ErrorV_structure:
.1fb9	20 96 13	jsr $1396		jsr	ErrorHandler
>1fbc	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fc4	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fd0					ErrorV_stop:
.1fd0	20 96 13	jsr $1396		jsr	ErrorHandler
>1fd3	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fdb	53 54 4f 50 50 45 44 00
.1fe3					ErrorV_data:
.1fe3	20 96 13	jsr $1396		jsr	ErrorHandler
>1fe6	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fee	41 54 41 00
.1ff2					ErrorV_undeclared:
.1ff2	20 96 13	jsr $1396		jsr	ErrorHandler
>1ff5	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1ffd	41 52 52 41 59 00
.2003					ErrorV_redefine:
.2003	20 96 13	jsr $1396		jsr	ErrorHandler
>2006	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>200e	44 45 46 49 4e 45 44 00
.2016					ErrorV_index:
.2016	20 96 13	jsr $1396		jsr	ErrorHandler
>2019	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2021	59 20 49 4e 44 45 58 00
.2029					ErrorV_memory:
.2029	20 96 13	jsr $1396		jsr	ErrorHandler
>202c	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2034	45 4d 4f 52 59 00
.203a					ErrorV_channel:
.203a	20 96 13	jsr $1396		jsr	ErrorHandler
>203d	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2045	54 50 55 54 20 45 52 52 4f 52 00
.2050					MoveObjectForward:
.2050	b2 29		lda ($29)			lda 	(objPtr) 					; get next
.2052	c9 ff		cmp #$ff			cmp 	#$FF
.2054	f0 36		beq $208c			beq 	_MOFEnd
.2056	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.2058	90 24		bcc $207e			bcc 	_MOFAdvance1 				; forward 1
.205a	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.205c	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.205e	90 20		bcc $2080			bcc 	_MOFAdvanceY
.2060	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2062	90 1a		bcc $207e			bcc 	_MOFAdvance1 				; forward 1
.2064	a8		tay				tay 								; read the size.
.2065	b9 ca 1f	lda $1fca,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.2068	a8		tay				tay
.2069	c8		iny				iny 								; add 1 for the system token.
.206a	d0 14		bne $2080			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.206c	a0 01		ldy #$01			ldy 	#1 							; get length byte
.206e	b1 29		lda ($29),y			lda 	(objPtr),y
.2070	a8		tay				tay 								; into Y.
.2071	18		clc				clc
.2072	a5 29		lda $29				lda 	objPtr						; add 2 to the object pointer
.2074	69 02		adc #$02			adc 	#2
.2076	85 29		sta $29				sta 	objPtr
.2078	90 02		bcc $207c			bcc 	_MOFNoCarry1
.207a	e6 2a		inc $2a				inc 	objPtr+1
.207c					_MOFNoCarry1:
.207c	80 02		bra $2080			bra 	_MOFAdvanceY
.207e					_MOFAdvance1:
.207e	a0 01		ldy #$01			ldy 	#1
.2080					_MOFAdvanceY:
.2080	98		tya				tya 								; add Y to objPtr
.2081	18		clc				clc
.2082	65 29		adc $29				adc 	objPtr
.2084	85 29		sta $29				sta 	objPtr
.2086	90 02		bcc $208a			bcc 	_MOFNoCarry2
.2088	e6 2a		inc $2a				inc 	objPtr+1
.208a					_MOFNoCarry2:
.208a	18		clc				clc 								; not completed.
.208b	60		rts				rts
.208c					_MOFEnd:
.208c	e6 29		inc $29				inc 	objPtr
.208e	d0 02		bne $2092			bne 	_MOFENoCarry
.2090	e6 2a		inc $2a				inc 	objPtr+1
.2092					_MOFENoCarry:
.2092	38		sec				sec
.2093	60		rts				rts
.2094					MOFSizeTable:
>2094	01					.byte	1         	; $ca .shift
>2095	01					.byte	1         	; $cb .byte
>2096	02					.byte	2         	; $cc .word
>2097	05					.byte	5         	; $cd .float
>2098	ff					.byte	255       	; $ce .string
>2099	ff					.byte	255       	; $cf .data
>209a	03					.byte	3         	; $d0 .goto
>209b	03					.byte	3         	; $d1 .gosub
>209c	03					.byte	3         	; $d2 .goto.z
>209d	03					.byte	3         	; $d3 .goto.nz
>209e	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0033					NSStatus:
>0033							.fill 	MathStackSize
.003f					NSMantissa0:
>003f							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004b					NSMantissa1:
>004b							.fill 	MathStackSize
.0057					NSMantissa2:
>0057							.fill 	MathStackSize
.0063					NSMantissa3:
>0063							.fill 	MathStackSize
.006f					NSExponent:
>006f							.fill 	MathStackSize
.0515					numberBuffer:
>0515							.fill 	34
.209f					FloatSubtract:
.209f	b5 33		lda $33,x			lda 	NSStatus,x 					; negate top of stack
.20a1	49 80		eor #$80			eor 	#$80
.20a3	95 33		sta $33,x			sta 	NSStatus,x					; and fall through.
.20a5					FloatAdd:
.20a5	ca		dex				dex
.20a6	b5 6f		lda $6f,x			lda 	NSExponent,x 				; can use optimised.
.20a8	15 70		ora $70,x			ora 	NSExponent+1,x
.20aa	15 63		ora $63,x			ora 	NSMantissa3,x
.20ac	15 64		ora $64,x			ora 	NSMantissa3+1,x
.20ae	d0 04		bne $20b4			bne 	_FAUseFloat
.20b0	20 41 24	jsr $2441			jsr 	FloatInt32Add 				; use the int32 one.
.20b3	60		rts				rts
.20b4					_FAUseFloat:
.20b4	20 d6 23	jsr $23d6			jsr 	FloatNormalise 				; normalise S[X]
.20b7	f0 51		beq $210a			beq 	_FAReturn1
.20b9	e8		inx				inx 								; normalise S[X+1]
.20ba	20 d6 23	jsr $23d6			jsr 	FloatNormalise
.20bd	ca		dex				dex
.20be	c9 00		cmp #$00			cmp 	#0
.20c0	f0 60		beq $2122			beq 	_FAExit 					; if so, just return A
.20c2	b5 6f		lda $6f,x			lda 	NSExponent,x 				; are the exponents the same ?
.20c4	d5 70		cmp $70,x			cmp 	NSExponent+1,x
.20c6	f0 18		beq $20e0			beq 	_FAExponentsEqual
.20c8	b5 6f		lda $6f,x			lda 	NSExponent,x 				; work out the larger exponent
.20ca	a8		tay				tay
.20cb	38		sec				sec 								; do a signed comparison of the exponents.
.20cc	f5 70		sbc $70,x			sbc 	NSExponent+1,x
.20ce	50 02		bvc $20d2			bvc 	_FANoSignedChange
.20d0	49 80		eor #$80			eor 	#$80
.20d2					_FANoSignedChange:
.20d2	29 80		and #$80			and 	#$80
.20d4	10 02		bpl $20d8			bpl 	_FAHaveMax
.20d6	b4 70		ldy $70,x			ldy 	NSExponent+1,x
.20d8					_FAHaveMax:
.20d8	20 23 21	jsr $2123			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20db	e8		inx				inx
.20dc	20 23 21	jsr $2123			jsr 	_FAShiftToExponent
.20df	ca		dex				dex
.20e0					_FAExponentsEqual:
.20e0	b5 33		lda $33,x			lda 	NSStatus,x 					; are the signs the same
.20e2	55 34		eor $34,x			eor 	NSStatus+1,x
.20e4	30 0e		bmi $20f4			bmi 	_FADifferentSigns
.20e6	20 0d 24	jsr $240d			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20e9	b5 63		lda $63,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20eb	10 35		bpl $2122			bpl 	_FAExit 					; if no, we are done.
.20ed	20 9a 26	jsr $269a			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20f0	f6 6f		inc $6f,x			inc 	NSExponent,x 				; bump the exponent and exit
.20f2	80 2e		bra $2122			bra 	_FAExit
.20f4					_FADifferentSigns:
.20f4	20 27 24	jsr $2427			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20f7	b5 63		lda $63,x			lda 	NSMantissa3,x 				; is the result negative ?
.20f9	10 06		bpl $2101			bpl 	_FACheckZero 				; if no, check for -0
.20fb	20 43 26	jsr $2643			jsr 	FloatNegate 					; netate result
.20fe	20 4a 26	jsr $264a			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.2101					_FACheckZero:
.2101	20 a3 26	jsr $26a3			jsr 	FloatIsZero	 				; check for -0
.2104	d0 1c		bne $2122			bne 	_FAExit
.2106	74 33		stz $33,x			stz 	NSStatus,x
.2108	80 18		bra $2122			bra 	_FAExit
.210a					_FAReturn1:
.210a	b5 40		lda $40,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.210c	95 3f		sta $3f,x			sta 	NSMantissa0,x
.210e	b5 4c		lda $4c,x			lda 	NSMantissa1+1,x
.2110	95 4b		sta $4b,x			sta 	NSMantissa1,x
.2112	b5 58		lda $58,x			lda 	NSMantissa2+1,x
.2114	95 57		sta $57,x			sta 	NSMantissa2,x
.2116	b5 64		lda $64,x			lda 	NSMantissa3+1,x
.2118	95 63		sta $63,x			sta 	NSMantissa3,x
.211a	b5 70		lda $70,x			lda 	NSExponent+1,x
.211c	95 6f		sta $6f,x			sta 	NSExponent,x
.211e	b5 34		lda $34,x			lda 	NSStatus+1,x
.2120	95 33		sta $33,x			sta 	NSStatus,x
.2122					_FAExit:
.2122	60		rts				rts
.2123					_FAShiftToExponent:
.2123					_FAShiftToExponent2:
.2123	98		tya				tya 								; compare Y to exponent
.2124	d5 6f		cmp $6f,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2126	f0 07		beq $212f			beq 	_FASEExit 					; exit if so.
.2128	20 9a 26	jsr $269a			jsr 	FloatShiftRight	 			; shift the mantissa right
.212b	f6 6f		inc $6f,x			inc 	NSExponent,x 				; increment exponent
.212d	80 f4		bra $2123			bra 	_FAShiftToExponent2
.212f					_FASEExit:
.212f	60		rts				rts
.2130					CompareEqual:
.2130	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2132	d0 09		bne $213d			bne 	ReturnFalse
.2134					ReturnTrue:
.2134	a9 01		lda #$01			lda 	#1
.2136	95 3f		sta $3f,x			sta 	NSMantissa0,x
.2138	a9 80		lda #$80			lda 	#$80
.213a	95 33		sta $33,x			sta 	NSStatus,x
.213c	60		rts				rts
.213d					ReturnFalse:
.213d	74 3f		stz $3f,x			stz 	NSMantissa0,x
.213f	60		rts				rts
.2140					CompareNotEqual:
.2140	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2142	d0 f0		bne $2134			bne 	ReturnTrue
.2144	80 f7		bra $213d			bra 	ReturnFalse
.2146					CompareLess:
.2146	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2148	c9 ff		cmp #$ff			cmp 	#$FF
.214a	f0 e8		beq $2134			beq 	ReturnTrue
.214c	80 ef		bra $213d			bra 	ReturnFalse
.214e					CompareGreater:
.214e	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2150	c9 01		cmp #$01			cmp 	#$01
.2152	f0 e0		beq $2134			beq 	ReturnTrue
.2154	80 e7		bra $213d			bra 	ReturnFalse
.2156					CompareLessEqual:
.2156	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2158	c9 01		cmp #$01			cmp 	#$01
.215a	d0 d8		bne $2134			bne 	ReturnTrue
.215c	80 df		bra $213d			bra 	ReturnFalse
.215e					CompareGreaterEqual:
.215e	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2160	c9 ff		cmp #$ff			cmp 	#$FF
.2162	d0 d0		bne $2134			bne 	ReturnTrue
.2164	80 d7		bra $213d			bra 	ReturnFalse
.2166					FloatCompare:
.2166	b5 6f		lda $6f,x			lda 	NSExponent,x 				; float comparison.
.2168	15 6e		ora $6e,x			ora 	NSExponent-1,x 				; integer if both integer.
.216a	48		pha				pha
.216b	20 9f 20	jsr $209f			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.216e	68		pla				pla
.216f	d0 0c		bne $217d			bne 	_FCCompareFloat
.2171	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2173	15 4b		ora $4b,x			ora 	NSMantissa1,x
.2175	15 57		ora $57,x			ora 	NSMantissa2,x
.2177	15 63		ora $63,x			ora 	NSMantissa3,x
.2179	f0 14		beq $218f			beq 	_FCExit 					; if zero, return zero
.217b	80 0a		bra $2187			bra 	_FCSign
.217d					_FCCompareFloat:
.217d	b5 4b		lda $4b,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.217f	29 f0		and #$f0			and 	#$F0
.2181	15 57		ora $57,x			ora 	NSMantissa2,x
.2183	15 63		ora $63,x			ora 	NSMantissa3,x
.2185	f0 08		beq $218f			beq 	_FCExit 					; zero, so approximately identical
.2187					_FCSign:
.2187	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2189	34 33		bit $33,x			bit 	NSStatus,x
.218b	10 02		bpl $218f			bpl 	_FCExit
.218d					_FCNegative:
.218d	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.218f					_FCExit:
.218f	20 83 26	jsr $2683			jsr 	FloatSetByte 				; set the result 255,0,1
.2192	60		rts				rts
.2193					FloatScalarTable:
>2193	66 66 66 66				.dword $66666666 ; 0.1
>2197	de					.byte $de
>2198	1f 85 eb 51				.dword $51eb851f ; 0.01
>219c	db					.byte $db
>219d	4c 37 89 41				.dword $4189374c ; 0.001
>21a1	d8					.byte $d8
>21a2	ac 8b db 68				.dword $68db8bac ; 0.0001
>21a6	d4					.byte $d4
>21a7	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>21ab	d1					.byte $d1
>21ac	83 de 1b 43				.dword $431bde83 ; 1e-06
>21b0	ce					.byte $ce
>21b1	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21b5	ca					.byte $ca
>21b6	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21ba	c7					.byte $c7
>21bb	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21bf	c4					.byte $c4
>21c0	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21c4	c0					.byte $c0
>21c5	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21c9	bd					.byte $bd
.21ca					FloatDivide:
.21ca	48		pha				pha
.21cb	20 d6 23	jsr $23d6			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21ce	ca		dex				dex
.21cf	c9 00		cmp #$00			cmp 	#0
.21d1	f0 1e		beq $21f1			beq 	_FDZero
.21d3	20 d6 23	jsr $23d6			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21d6	f0 16		beq $21ee			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21d8	20 39 22	jsr $2239			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21db	20 06 22	jsr $2206			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21de	20 d6 23	jsr $23d6			jsr		FloatNormalise 				; renormalise
.21e1	20 cc 23	jsr $23cc			jsr 	FloatCalculateSign 			; calculate result sign
.21e4	b5 6f		lda $6f,x			lda 	NSExponent,x 				; calculate exponent
.21e6	38		sec				sec
.21e7	f5 70		sbc $70,x			sbc 	NSExponent+1,x
.21e9	38		sec				sec
.21ea	e9 1e		sbc #$1e			sbc 	#30
.21ec	95 6f		sta $6f,x			sta 	NSExponent,x
.21ee					_FDExit:
.21ee	68		pla				pla
.21ef	18		clc				clc
.21f0	60		rts				rts
.21f1					_FDZero:
.21f1	68		pla				pla
.21f2	38		sec				sec
.21f3	60		rts				rts
.21f4					DivideInt32:
.21f4	20 bc 22	jsr $22bc			jsr 	FloatIntegerPart 			; make both integers
.21f7	ca		dex				dex
.21f8	20 bc 22	jsr $22bc			jsr 	FloatIntegerPart
.21fb	20 17 22	jsr $2217			jsr 	Int32Divide 				; divide
.21fe	20 06 22	jsr $2206			jsr 	NSMCopyPlusTwoToZero 		; copy result
.2201	20 cc 23	jsr $23cc			jsr 	FloatCalculateSign 			; calculate result sign
.2204	18		clc				clc
.2205	60		rts				rts
.2206					NSMCopyPlusTwoToZero:
.2206	b5 41		lda $41,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.2208	95 3f		sta $3f,x			sta 	NSMantissa0,x
.220a	b5 4d		lda $4d,x			lda 	NSMantissa1+2,x
.220c	95 4b		sta $4b,x			sta 	NSMantissa1,x
.220e	b5 59		lda $59,x			lda 	NSMantissa2+2,x
.2210	95 57		sta $57,x			sta 	NSMantissa2,x
.2212	b5 65		lda $65,x			lda 	NSMantissa3+2,x
.2214	95 63		sta $63,x			sta 	NSMantissa3,x
.2216	60		rts				rts
.2217					Int32Divide:
.2217	48		pha				pha 								; save AXY
.2218	5a		phy				phy
.2219	20 64 26	jsr $2664			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.221c	20 7d 26	jsr $267d			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.221f	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2221					_I32DivideLoop:
.2221	e8		inx				inx
.2222	e8		inx				inx
.2223	20 90 26	jsr $2690			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2226	ca		dex				dex
.2227	ca		dex				dex
.2228	20 91 26	jsr $2691			jsr 	FloatRotateLeft
.222b	20 57 22	jsr $2257			jsr 	FloatDivideCheck 			; check if subtract possible
.222e	90 02		bcc $2232			bcc 	_I32DivideNoCarryIn
.2230	f6 41		inc $41,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2232					_I32DivideNoCarryIn:
.2232	88		dey				dey 								; loop round till division completed.
.2233	d0 ec		bne $2221			bne 	_I32DivideLoop
.2235	7a		ply				ply 								; restore AXY and exit
.2236	68		pla				pla
.2237	18		clc				clc
.2238	60		rts				rts
.2239					Int32ShiftDivide:
.2239	48		pha				pha 								; save AY
.223a	5a		phy				phy
.223b	e8		inx				inx 								; clear S[X+2]
.223c	e8		inx				inx
.223d	20 81 26	jsr $2681			jsr 	FloatSetZero
.2240	ca		dex				dex
.2241	ca		dex				dex
.2242	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2244					_I32SDLoop:
.2244	20 57 22	jsr $2257			jsr 	FloatDivideCheck 			; check if subtract possible
.2247	e8		inx				inx
.2248	e8		inx				inx
.2249	20 91 26	jsr $2691			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.224c	ca		dex				dex
.224d	ca		dex				dex
.224e	20 91 26	jsr $2691			jsr 	FloatRotateLeft
.2251	88		dey				dey 	 							; do 31 times
.2252	d0 f0		bne $2244			bne 	_I32SDLoop
.2254	7a		ply				ply 								; restore AY and exit
.2255	68		pla				pla
.2256	60		rts				rts
.2257					FloatDivideCheck:
.2257	20 27 24	jsr $2427			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.225a	b0 04		bcs $2260			bcs 	_DCSExit 					; if carry set, then could do, exit
.225c	20 0d 24	jsr $240d			jsr 	FloatAddTopTwoStack 		; add it back in
.225f	18		clc				clc 								; and return False
.2260					_DCSExit:
.2260	60		rts				rts
.2261					FloatFractionalPart:
.2261	5a		phy				phy
.2262	b5 33		lda $33,x			lda 	NSStatus,x 					; take absolute value
.2264	29 7f		and #$7f			and 	#$7F
.2266	95 33		sta $33,x			sta 	NSStatus,x
.2268	20 d6 23	jsr $23d6			jsr 	FloatNormalise
.226b	b5 6f		lda $6f,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.226d	38		sec				sec
.226e	e9 e0		sbc #$e0			sbc 	#$E0
.2270	90 29		bcc $229b			bcc 	_FFPExit 					; already fractional
.2272	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2274	b0 22		bcs $2298			bcs 	_FFPZero
.2276	a8		tay				tay 								; put count to do in Y
.2277	b5 63		lda $63,x			lda 	NSMantissa3,x 				; do each in turn.
.2279	20 a0 22	jsr $22a0			jsr 	_FFPPartial
.227c	95 63		sta $63,x			sta 	NSMantissa3,x
.227e	b5 57		lda $57,x			lda 	NSMantissa2,x
.2280	20 a0 22	jsr $22a0			jsr 	_FFPPartial
.2283	95 57		sta $57,x			sta 	NSMantissa2,x
.2285	b5 4b		lda $4b,x			lda 	NSMantissa1,x
.2287	20 a0 22	jsr $22a0			jsr 	_FFPPartial
.228a	95 4b		sta $4b,x			sta 	NSMantissa1,x
.228c	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.228e	20 a0 22	jsr $22a0			jsr 	_FFPPartial
.2291	95 3f		sta $3f,x			sta 	NSMantissa0,x
.2293	20 a3 26	jsr $26a3			jsr 	FloatIsZero 					; zeroed check.
.2296	d0 03		bne $229b			bne 	_FFPExit
.2298					_FFPZero:
.2298	20 81 26	jsr $2681			jsr 	FloatSetZero
.229b					_FFPExit:
.229b	20 d6 23	jsr $23d6			jsr 	FloatNormalise
.229e	7a		ply				ply
.229f	60		rts				rts
.22a0					_FFPPartial:
.22a0	c0 00		cpy #$00			cpy 	#0 							; no more to do
.22a2	f0 17		beq $22bb			beq 	_FFFPPExit
.22a4	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.22a6	b0 0c		bcs $22b4			bcs 	_FFFPPWholeByte
.22a8	5a		phy				phy
.22a9					_FFFPPLeft:
.22a9	0a		asl a				asl 	a
.22aa	88		dey				dey
.22ab	d0 fc		bne $22a9			bne 	_FFFPPLeft
.22ad	7a		ply				ply
.22ae					_FFFPPRight:
.22ae	4a		lsr a				lsr 	a
.22af	88		dey				dey
.22b0	d0 fc		bne $22ae			bne 	_FFFPPRight
.22b2	80 07		bra $22bb			bra 	_FFFPPExit
.22b4					_FFFPPWholeByte:
.22b4	98		tya				tya 								; subtract 8 from count
.22b5	38		sec				sec
.22b6	e9 08		sbc #$08			sbc 	#8
.22b8	a8		tay				tay
.22b9	a9 00		lda #$00			lda 	#0 							; and clear all
.22bb					_FFFPPExit:
.22bb	60		rts				rts
.22bc					FloatIntegerPart:
.22bc	48		pha				pha
.22bd	b5 6f		lda $6f,x			lda 	NSExponent,x 				; is it integer already ?
.22bf	f0 1d		beq $22de			beq 	_FIPExit 					; if so do nothing
.22c1	20 a3 26	jsr $26a3			jsr 	FloatIsZero 				; is it zero ?
.22c4	f0 15		beq $22db			beq 	_FIPZero 					; if so return zero.
.22c6	20 d6 23	jsr $23d6			jsr 	FloatNormalise 				; normalise
.22c9	f0 10		beq $22db			beq 	_FIPZero 					; normalised to zero, exit zero
.22cb					_FIPShift:
.22cb	b5 6f		lda $6f,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22cd	10 07		bpl $22d6			bpl 	_FIPCheckZero
.22cf	20 9a 26	jsr $269a			jsr 	FloatShiftRight 			; shift mantissa right
.22d2	f6 6f		inc $6f,x			inc 	NSExponent,x 				; bump exponent
.22d4	80 f5		bra $22cb			bra 	_FIPShift
.22d6					_FIPCheckZero:
.22d6	20 a3 26	jsr $26a3			jsr 	FloatIsZero 				; avoid -0 problem
.22d9	d0 03		bne $22de			bne 	_FIPExit 					; set to zero if mantissa zero.
.22db					_FIPZero:
.22db	20 81 26	jsr $2681			jsr 	FloatSetZero
.22de					_FIPExit:
.22de	68		pla				pla
.22df	60		rts				rts
.22e0					FloatIntegerPartDown:
.22e0	48		pha				pha
.22e1	5a		phy				phy
.22e2	b5 6f		lda $6f,x			lda 	NSExponent,x 				; is it integer already ?
.22e4	f0 36		beq $231c			beq 	_FIPExit 					; if so do nothing
.22e6	20 a3 26	jsr $26a3			jsr 	FloatIsZero 				; is it zero ?
.22e9	f0 2e		beq $2319			beq 	_FIPZero 					; if so return zero.
.22eb	20 d6 23	jsr $23d6			jsr 	FloatNormalise 				; normalise
.22ee	f0 29		beq $2319			beq 	_FIPZero 					; normalised to zero, exit zero
.22f0	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22f2					_FIPShift:
.22f2	b5 6f		lda $6f,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22f4	10 0a		bpl $2300			bpl 	_FIPCheckDown
.22f6	20 9a 26	jsr $269a			jsr 	FloatShiftRight 			; shift mantissa right
.22f9	90 01		bcc $22fc			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22fb	c8		iny				iny
.22fc					_FIPNoFrac:
.22fc	f6 6f		inc $6f,x			inc 	NSExponent,x 				; bump exponent
.22fe	80 f2		bra $22f2			bra 	_FIPShift
.2300					_FIPCheckDown:
.2300	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.2302	f0 10		beq $2314			beq 	_FIPCheckZero
.2304	34 33		bit $33,x			bit 	NSStatus,x 					; +ve
.2306	10 0c		bpl $2314			bpl 	_FIPCheckZero
.2308	e8		inx				inx 								; -ve so round *down*.
.2309	a9 01		lda #$01			lda 	#1
.230b	20 83 26	jsr $2683			jsr 	FloatSetByte
.230e	20 43 26	jsr $2643			jsr 	FloatNegate
.2311	20 a5 20	jsr $20a5			jsr 	FloatAdd
.2314					_FIPCheckZero:
.2314	20 a3 26	jsr $26a3			jsr 	FloatIsZero 				; avoid -0 problem
.2317	d0 03		bne $231c			bne 	_FIPExit 					; set to zero if mantissa zero.
.2319					_FIPZero:
.2319	20 81 26	jsr $2681			jsr 	FloatSetZero
.231c					_FIPExit:
.231c	7a		ply				ply
.231d	68		pla				pla
.231e	60		rts				rts
.231f					FloatInt8Multiply:
.231f	5a		phy				phy
.2320	b5 3f		lda $3f,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2322	a8		tay				tay
.2323	74 3f		stz $3f,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2325					_FI8MLoop:
.2325	98		tya				tya 								; shift right shifter right into carry
.2326	4a		lsr a				lsr 	a
.2327	a8		tay				tay
.2328	90 0d		bcc $2337			bcc 	_FI8MNoAdd
.232a	18		clc				clc
.232b	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.232d	75 40		adc $40,x			adc 	NSMantissa0+1,x
.232f	95 3f		sta $3f,x			sta 	NSMantissa0,x
.2331	b5 4b		lda $4b,x			lda 	NSMantissa1,x
.2333	75 4c		adc $4c,x			adc 	NSMantissa1+1,x
.2335	95 4b		sta $4b,x			sta 	NSMantissa1,x
.2337					_FI8MNoAdd:
.2337	16 40		asl $40,x			asl 	NSMantissa0+1,x 			; shift adder left
.2339	36 4c		rol $4c,x			rol 	NSMantissa1+1,x
.233b	c0 00		cpy #$00			cpy 	#0
.233d	d0 e6		bne $2325			bne 	_FI8MLoop 					; until right shifter zero.
.233f	7a		ply				ply
.2340	60		rts				rts
.2341					FloatMultiply:
.2341	ca		dex				dex
.2342	b5 6f		lda $6f,x			lda 	NSExponent,x 				; can use optimised ?
.2344	15 70		ora $70,x			ora 	NSExponent+1,x
.2346	15 63		ora $63,x			ora 	NSMantissa3,x
.2348	15 64		ora $64,x			ora 	NSMantissa3+1,x
.234a	d0 21		bne $236d			bne 	_FMUseFloat
.234c	b5 33		lda $33,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.234e	15 34		ora $34,x			ora 	NSStatus+1,x
.2350	29 80		and #$80			and 	#$80
.2352	15 63		ora $63,x			ora 	NSMantissa3,x
.2354	15 57		ora $57,x			ora 	NSMantissa2,x
.2356	15 4b		ora $4b,x			ora 	NSMantissa1,x
.2358	15 64		ora $64,x			ora 	NSMantissa3+1,x
.235a	15 58		ora $58,x			ora 	NSMantissa2+1,x
.235c	15 4c		ora $4c,x			ora 	NSMantissa1+1,x
.235e	d0 04		bne $2364			bne 	_FMInt32
.2360	20 1f 23	jsr $231f			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2363	60		rts				rts
.2364					_FMInt32:
.2364	20 8e 23	jsr $238e			jsr 	FloatMultiplyShort			; use the int32 one.
.2367	18		clc				clc 								; fix it up if gone out of range
.2368	75 6f		adc $6f,x			adc 	NSExponent,x
.236a	95 6f		sta $6f,x			sta 	NSExponent,x
.236c	60		rts				rts
.236d					_FMUseFloat:
.236d	20 d6 23	jsr $23d6			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2370	f0 18		beq $238a			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2372	e8		inx				inx
.2373	20 d6 23	jsr $23d6			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2376	ca		dex				dex
.2377	c9 00		cmp #$00			cmp 	#0
.2379	f0 0c		beq $2387			beq 	_FDSetZero
.237b	20 8e 23	jsr $238e			jsr 	FloatMultiplyShort 			; calculate the result.
.237e	75 6f		adc $6f,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2380	18		clc				clc
.2381	75 70		adc $70,x			adc 	NSExponent+1,x
.2383	95 6f		sta $6f,x			sta 	NSExponent,x
.2385	80 03		bra $238a			bra 	_FDExit
.2387					_FDSetZero:
.2387	20 81 26	jsr $2681			jsr 	FloatSetZero 				; return 0
.238a					_FDExit:
.238a	20 d6 23	jsr $23d6			jsr 	FloatNormalise 				; normalise the result
.238d	60		rts				rts
.238e					FloatMultiplyShort:
.238e	5a		phy				phy 								; save Y
.238f	20 64 26	jsr $2664			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2392	20 7d 26	jsr $267d			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2395	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2397					_I32MLoop:
.2397	b5 41		lda $41,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2399	15 4d		ora $4d,x			ora 	NSMantissa1+2,x
.239b	15 59		ora $59,x			ora 	NSMantissa2+2,x
.239d	15 65		ora $65,x			ora 	NSMantissa3+2,x
.239f	f0 25		beq $23c6			beq 	_I32MExit 					; exit if zero
.23a1	b5 41		lda $41,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.23a3	29 01		and #$01			and 	#1
.23a5	f0 0d		beq $23b4			beq 	_I32MNoAdd
.23a7	20 0d 24	jsr $240d			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.23aa	b5 63		lda $63,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.23ac	10 06		bpl $23b4			bpl 	_I32MNoAdd
.23ae					_I32ShiftRight:
.23ae	20 9a 26	jsr $269a			jsr 	FloatShiftRight 			; shift S[X] right
.23b1	c8		iny				iny 								; increment shift count
.23b2	80 09		bra $23bd			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23b4					_I32MNoAdd:
.23b4	34 64		bit $64,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23b6	70 f6		bvs $23ae			bvs 	_I32ShiftRight 				; instead.
.23b8	e8		inx				inx
.23b9	20 90 26	jsr $2690			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23bc	ca		dex				dex
.23bd					_I32MShiftUpper:
.23bd	e8		inx				inx 								; shift S[X+2] right
.23be	e8		inx				inx
.23bf	20 9a 26	jsr $269a			jsr 	FloatShiftRight
.23c2	ca		dex				dex
.23c3	ca		dex				dex
.23c4	80 d1		bra $2397			bra 	_I32MLoop 					; try again.
.23c6					_I32MExit:
.23c6	20 cc 23	jsr $23cc			jsr 	FloatCalculateSign
.23c9	98		tya				tya 								; shift in A
.23ca	7a		ply				ply 								; restore Y and exit
.23cb	60		rts				rts
.23cc					FloatCalculateSign:
.23cc	b5 33		lda $33,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23ce	16 33		asl $33,x			asl 	NSStatus,x 					; shift result left
.23d0	55 34		eor $34,x			eor 	NSStatus+1,x
.23d2	0a		asl a				asl 	a 							; shift bit 7 into carry
.23d3	76 33		ror $33,x			ror 	NSStatus,x 					; shift right into status byte.
.23d5	60		rts				rts
.23d6					FloatNormalise:
.23d6	20 a3 26	jsr $26a3			jsr 	FloatIsZero 				; if zero exit
.23d9	d0 07		bne $23e2			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23db	16 33		asl $33,x			asl 	NSStatus,x 					; clear the sign bit.
.23dd	76 33		ror $33,x			ror 	NSStatus,x 					; (no -0)
.23df	a9 00		lda #$00			lda 	#0 							; set Z flag
.23e1	60		rts				rts
.23e2					_NSNormaliseOptimise:
.23e2	b5 63		lda $63,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23e4	d0 19		bne $23ff			bne 	_NSNormaliseLoop
.23e6	b5 57		lda $57,x			lda 	NSMantissa2,x 				; byte normalise
.23e8	30 15		bmi $23ff			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23ea	95 63		sta $63,x			sta 	NSMantissa3,x
.23ec	b5 4b		lda $4b,x			lda 	NSMantissa1,x
.23ee	95 57		sta $57,x			sta 	NSMantissa2,x
.23f0	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.23f2	95 4b		sta $4b,x			sta 	NSMantissa1,x
.23f4	74 3f		stz $3f,x			stz 	NSMantissa0,x
.23f6	b5 6f		lda $6f,x			lda 	NSExponent,x
.23f8	38		sec				sec
.23f9	e9 08		sbc #$08			sbc 	#8
.23fb	95 6f		sta $6f,x			sta 	NSExponent,x
.23fd	80 e3		bra $23e2			bra 	_NSNormaliseOptimise
.23ff					_NSNormaliseLoop:
.23ff	34 63		bit $63,x			bit 	NSMantissa3,x 				; bit 30 set ?
.2401	70 07		bvs $240a			bvs 	_NSNExit 					; exit if so with Z flag clear
.2403	20 90 26	jsr $2690			jsr 	FloatShiftLeft 				; shift mantissa left
.2406	d6 6f		dec $6f,x			dec 	NSExponent,x 				; adjust exponent
.2408	80 f5		bra $23ff			bra 	_NSNormaliseLoop
.240a					_NSNExit:
.240a	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.240c	60		rts				rts
.240d					FloatAddTopTwoStack:
.240d	18		clc				clc
.240e	b5 3f		lda $3f,x			lda		NSMantissa0,x
.2410	75 40		adc $40,x			adc 		NSMantissa0+1,x
.2412	95 3f		sta $3f,x			sta 	NSMantissa0,x
.2414	b5 4b		lda $4b,x			lda		NSMantissa1,x
.2416	75 4c		adc $4c,x			adc 		NSMantissa1+1,x
.2418	95 4b		sta $4b,x			sta 	NSMantissa1,x
.241a	b5 57		lda $57,x			lda		NSMantissa2,x
.241c	75 58		adc $58,x			adc 		NSMantissa2+1,x
.241e	95 57		sta $57,x			sta 	NSMantissa2,x
.2420	b5 63		lda $63,x			lda		NSMantissa3,x
.2422	75 64		adc $64,x			adc 		NSMantissa3+1,x
.2424	95 63		sta $63,x			sta 	NSMantissa3,x
.2426	60		rts				rts
.2427					FloatSubTopTwoStack:
.2427	38		sec				sec
.2428	b5 3f		lda $3f,x			lda		NSMantissa0,x
.242a	f5 40		sbc $40,x			sbc 		NSMantissa0+1,x
.242c	95 3f		sta $3f,x			sta 	NSMantissa0,x
.242e	b5 4b		lda $4b,x			lda		NSMantissa1,x
.2430	f5 4c		sbc $4c,x			sbc 		NSMantissa1+1,x
.2432	95 4b		sta $4b,x			sta 	NSMantissa1,x
.2434	b5 57		lda $57,x			lda		NSMantissa2,x
.2436	f5 58		sbc $58,x			sbc 		NSMantissa2+1,x
.2438	95 57		sta $57,x			sta 	NSMantissa2,x
.243a	b5 63		lda $63,x			lda		NSMantissa3,x
.243c	f5 64		sbc $64,x			sbc 		NSMantissa3+1,x
.243e	95 63		sta $63,x			sta 	NSMantissa3,x
.2440	60		rts				rts
.2441					FloatInt32Add:
.2441	b5 33		lda $33,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2443	55 34		eor $34,x			eor 	NSStatus+1,x
.2445	30 04		bmi $244b			bmi 	_DiffSigns
.2447	20 0d 24	jsr $240d			jsr		FloatAddTopTwoStack
.244a	60		rts				rts
.244b					_DiffSigns:
.244b	20 27 24	jsr $2427			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.244e	34 63		bit $63,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2450	10 07		bpl $2459			bpl 	_AddExit
.2452	b5 34		lda $34,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2454	95 33		sta $33,x			sta 	NSStatus,x
.2456	20 4a 26	jsr $264a			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2459					_AddExit:
.2459	20 a3 26	jsr $26a3			jsr 	FloatIsZero 				; check for -0
.245c	d0 02		bne $2460			bne 	_AddNonZero
.245e	74 33		stz $33,x			stz 	NSStatus,x
.2460					_AddNonZero:
.2460	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2461					FloatEncodeStart:
.2461	38		sec				sec
.2462	80 01		bra $2465			bra 	FloatEncodeContinue+1
.2464					FloatEncodeContinue:
.2464	18		clc				clc
.2465					FloatEncode:
.2465	08		php				php 								; save reset flag.
.2466	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2468	f0 15		beq $247f			beq 	_ENIsOkay
.246a	c9 30		cmp #$30			cmp 	#"0"
.246c	90 04		bcc $2472			bcc 	_ENBadNumber
.246e	c9 3a		cmp #$3a			cmp 	#"9"+1
.2470	90 0d		bcc $247f			bcc 	_ENIsOkay
.2472					_ENBadNumber:
.2472	28		plp				plp 								; throw saved reset
.2473	ad 37 05	lda $0537			lda 	encodeState 				; if in decimal mode, construct final number
.2476	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2478	d0 03		bne $247d			bne 	_ENFail
.247a	4c f7 24	jmp $24f7			jmp 	_ENConstructFinal
.247d					_ENFail:
.247d	18		clc				clc 								; not allowed
.247e	60		rts				rts
.247f					_ENIsOkay:
.247f	28		plp				plp 								; are we restarting
.2480	90 15		bcc $2497			bcc 	_ENNoRestart
.2482					_ENStartEncode:
.2482	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2484	f0 0c		beq $2492			beq 	_ENFirstDP
.2486	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2488	20 83 26	jsr $2683			jsr 	FloatSetByte 				; in single byte mode.
.248b	a9 01		lda #$01			lda 	#ESTA_Low
.248d					_ENExitChange:
.248d	8d 37 05	sta $0537			sta 	encodeState 				; save new state
.2490	38		sec				sec
.2491	60		rts				rts
.2492					_ENFirstDP:
.2492	20 81 26	jsr $2681			jsr 	FloatSetZero 				; clear integer part
.2495	80 3c		bra $24d3			bra 	_ESTASwitchFloat			; go straight to float and exi
.2497					_ENNoRestart:
.2497	48		pha				pha 								; save digit or DP on stack.
.2498	ad 37 05	lda $0537			lda 	encodeState 				; get current state
.249b	c9 01		cmp #$01			cmp 	#ESTA_Low
.249d	f0 09		beq $24a8			beq  	_ESTALowState
.249f	c9 02		cmp #$02			cmp 	#ESTA_High
.24a1	f0 26		beq $24c9			beq 	_ESTAHighState
.24a3	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.24a5	f0 38		beq $24df			beq 	_ESTADecimalState
>24a7	db						.byte 	$DB 						; causes a break in the emulator
.24a8					_ESTALowState:
.24a8	68		pla				pla 								; get value back
.24a9	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.24ab	f0 26		beq $24d3			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24ad	29 0f		and #$0f			and 	#15 						; make digit
.24af	8d 38 05	sta $0538			sta 	digitTemp 					; save it.
.24b2	b5 3f		lda $3f,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24b4	0a		asl a				asl 	a
.24b5	0a		asl a				asl 	a
.24b6	75 3f		adc $3f,x			adc 	NSMantissa0,x
.24b8	0a		asl a				asl 	a
.24b9	6d 38 05	adc $0538			adc 	digitTemp
.24bc	95 3f		sta $3f,x			sta 	NSMantissa0,x
.24be	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24c0	90 05		bcc $24c7			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24c2	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24c4	8d 37 05	sta $0537			sta 	encodeState
.24c7					_ESTANoSwitch:
.24c7	38		sec				sec
.24c8	60		rts				rts
.24c9					_ESTAHighState:
.24c9	68		pla				pla 								; get value back
.24ca	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24cc	f0 05		beq $24d3			beq 	_ESTASwitchFloat
.24ce	20 29 25	jsr $2529			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24d1	38		sec				sec
.24d2	60		rts				rts
.24d3					_ESTASwitchFloat:
.24d3	9c 39 05	stz $0539			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24d6	e8		inx				inx 								; zero the decimal additive.
.24d7	20 81 26	jsr $2681			jsr 	FloatSetZero
.24da	ca		dex				dex
.24db	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24dd	80 ae		bra $248d			bra 	_ENExitChange
.24df					_ESTADecimalState:
.24df	68		pla				pla 								; digit.
.24e0	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24e2	f0 99		beq $247d			beq 	_ENFail
.24e4	e8		inx				inx 								; put digit into fractional part of X+1
.24e5	20 29 25	jsr $2529			jsr 	ESTAShiftDigitIntoMantissa
.24e8	ca		dex				dex
.24e9	ee 39 05	inc $0539			inc 	decimalCount 				; bump the count of decimals
.24ec	ad 39 05	lda $0539			lda 	decimalCount 				; too many decimal digits.
.24ef	c9 0b		cmp #$0b			cmp 	#11
.24f1	f0 02		beq $24f5			beq 	_ESTADSFail
.24f3	38		sec				sec
.24f4	60		rts				rts
.24f5					_ESTADSFail:
.24f5	18		clc				clc
.24f6	60		rts				rts
.24f7					_ENConstructFinal:
.24f7	ad 39 05	lda $0539			lda 	decimalCount 				; get decimal count
.24fa	f0 2b		beq $2527			beq 	_ENCFExit 					; no decimals
.24fc	5a		phy				phy
.24fd	0a		asl a				asl 	a 							; x 4 and CLC
.24fe	0a		asl a				asl 	a
.24ff	6d 39 05	adc $0539			adc 	decimalCount
.2502	a8		tay				tay
.2503	b9 8e 21	lda $218e,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.2506	95 41		sta $41,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.2508	b9 8f 21	lda $218f,y			lda 	FloatScalarTable-5+1,y
.250b	95 4d		sta $4d,x			sta 	NSMantissa1+2,x
.250d	b9 90 21	lda $2190,y			lda 	FloatScalarTable-5+2,y
.2510	95 59		sta $59,x			sta 	NSMantissa2+2,x
.2512	b9 91 21	lda $2191,y			lda 	FloatScalarTable-5+3,y
.2515	95 65		sta $65,x			sta 	NSMantissa3+2,x
.2517	b9 92 21	lda $2192,y			lda 	FloatScalarTable-5+4,y
.251a	95 71		sta $71,x			sta 	NSExponent+2,x
.251c	74 35		stz $35,x			stz 	NSStatus+2,x 				; make +ve
.251e	e8		inx				inx 								; multiply decimal const by decimal scalar
.251f	e8		inx				inx
.2520	20 41 23	jsr $2341			jsr 	FloatMultiply
.2523	20 a5 20	jsr $20a5			jsr 	FloatAdd 					; add to integer part.
.2526	7a		ply				ply
.2527					_ENCFExit:
.2527	18		clc				clc 								; reject the digit.
.2528	60		rts				rts
.2529					ESTAShiftDigitIntoMantissa:
.2529	29 0f		and #$0f			and 	#15 						; save digit
.252b	48		pha				pha
.252c	b5 63		lda $63,x			lda 	NSMantissa3,x 				; push mantissa on stack
.252e	48		pha				pha
.252f	b5 57		lda $57,x			lda 	NSMantissa2,x
.2531	48		pha				pha
.2532	b5 4b		lda $4b,x			lda 	NSMantissa1,x
.2534	48		pha				pha
.2535	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2537	48		pha				pha
.2538	20 90 26	jsr $2690			jsr 	FloatShiftLeft 				; x 2
.253b	20 90 26	jsr $2690			jsr 	FloatShiftLeft 				; x 4
.253e	18		clc				clc 								; pop mantissa and add
.253f	68		pla				pla
.2540	75 3f		adc $3f,x			adc 	NSMantissa0,x
.2542	95 3f		sta $3f,x			sta 	NSMantissa0,x
.2544	68		pla				pla
.2545	75 4b		adc $4b,x			adc 	NSMantissa1,x
.2547	95 4b		sta $4b,x			sta 	NSMantissa1,x
.2549	68		pla				pla
.254a	75 57		adc $57,x			adc 	NSMantissa2,x
.254c	95 57		sta $57,x			sta 	NSMantissa2,x
.254e	68		pla				pla
.254f	75 63		adc $63,x			adc 	NSMantissa3,x
.2551	95 63		sta $63,x			sta 	NSMantissa3,x 				; x 5
.2553	20 90 26	jsr $2690			jsr 	FloatShiftLeft 				; x 10
.2556	68		pla				pla 								; add digit
.2557	18		clc				clc
.2558	75 3f		adc $3f,x			adc 	NSMantissa0,x
.255a	95 3f		sta $3f,x			sta 	NSMantissa0,x
.255c	90 0a		bcc $2568			bcc 	_ESTASDExit
.255e	f6 4b		inc $4b,x			inc 	NSMantissa1,x
.2560	d0 06		bne $2568			bne 	_ESTASDExit
.2562	f6 57		inc $57,x			inc 	NSMantissa2,x
.2564	d0 02		bne $2568			bne 	_ESTASDExit
.2566	f6 63		inc $63,x			inc 	NSMantissa3,x
.2568					_ESTASDExit:
.2568	60		rts				rts
.0537					encodeState:
>0537							.fill 	1
.0538					digitTemp:
>0538							.fill 	1
.0539					decimalCount:
>0539							.fill 	1
.2569					FloatToString:
.2569	da		phx				phx
.256a	5a		phy				phy 								; save code position
.256b	8d 3a 05	sta $053a			sta 	decimalPlaces	 			; save number of DPs.
.256e	9c 3b 05	stz $053b			stz 	dbOffset 					; offset into decimal buffer = start.
.2571	b5 33		lda $33,x			lda 	NSStatus,x  				; is it -ve.
.2573	10 08		bpl $257d			bpl 	_CNTSNotNegative
.2575	29 7f		and #$7f			and 	#$7F 						; make +ve
.2577	95 33		sta $33,x			sta 	NSStatus,x
.2579	a9 2d		lda #$2d			lda 	#"-"
.257b	80 02		bra $257f			bra 	_CNTMain
.257d					_CNTSNotNegative:
.257d	a9 20		lda #$20			lda 	#" "
.257f					_CNTMain:
.257f	20 e1 25	jsr $25e1			jsr 	WriteDecimalBuffer
.2582	b5 6f		lda $6f,x			lda 	NSExponent,x 				; check if decimal
.2584	f0 0d		beq $2593			beq 	_CNTSNotFloat
.2586	e8		inx				inx 								; round up so we don't get too many 6.999999
.2587	a9 01		lda #$01			lda 	#1
.2589	20 83 26	jsr $2683			jsr 	FloatSetByte
.258c	b5 6e		lda $6e,x			lda		NSExponent-1,x
.258e	95 6f		sta $6f,x			sta 	NSExponent,x
.2590	20 a5 20	jsr $20a5			jsr 	FloatAdd
.2593					_CNTSNotFloat:
.2593	20 c3 25	jsr $25c3			jsr 	MakePlusTwoString 			; do the integer part.
.2596	20 61 22	jsr $2261			jsr 	FloatFractionalPart 		; get the fractional part
.2599	20 d6 23	jsr $23d6			jsr 	FloatNormalise					; normalise , exit if zero
.259c	f0 22		beq $25c0			beq 	_CNTSExit
.259e	a9 2e		lda #$2e			lda 	#"."
.25a0	20 e1 25	jsr $25e1			jsr 	WriteDecimalBuffer 			; write decimal place
.25a3					_CNTSDecimal:
.25a3	ce 3a 05	dec $053a			dec 	decimalPlaces 				; done all the decimals
.25a6	30 18		bmi $25c0			bmi 	_CNTSExit
.25a8	e8		inx				inx 								; x 10.0
.25a9	a9 0a		lda #$0a			lda 	#10
.25ab	20 83 26	jsr $2683			jsr 	FloatSetByte
.25ae	20 41 23	jsr $2341			jsr 	FloatMultiply
.25b1	20 c3 25	jsr $25c3			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25b4	20 61 22	jsr $2261			jsr 	FloatFractionalPart 		; get the fractional part
.25b7	20 d6 23	jsr $23d6			jsr 	FloatNormalise 				; normalise it.
.25ba	b5 6f		lda $6f,x			lda 	NSExponent,x 				; gone to zero, exit.
.25bc	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25be	b0 e3		bcs $25a3			bcs 	_CNTSDecimal 				; keep going.
.25c0					_CNTSExit:
.25c0	7a		ply				ply
.25c1	fa		plx				plx
.25c2	60		rts				rts
.25c3					MakePlusTwoString:
.25c3	da		phx				phx
.25c4	20 64 26	jsr $2664			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25c7	e8		inx				inx 								; access it
.25c8	e8		inx				inx
.25c9	20 bc 22	jsr $22bc			jsr 	FloatIntegerPart 			; make it an integer
.25cc	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25ce	20 00 26	jsr $2600			jsr 	ConvertInt32
.25d1	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25d3					_MPTSCopy:
.25d3	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25d6	20 e1 25	jsr $25e1			jsr 	WriteDecimalBuffer
.25d9	e8		inx				inx
.25da	bd 15 05	lda $0515,x			lda 	numberBuffer,x
.25dd	d0 f4		bne $25d3			bne 	_MPTSCopy
.25df	fa		plx				plx
.25e0	60		rts				rts
.25e1					WriteDecimalBuffer:
.25e1	da		phx				phx
.25e2	ae 3b 05	ldx $053b			ldx 	dbOffset
.25e5	9d 3c 05	sta $053c,x			sta 	decimalBuffer,x
.25e8	9e 3d 05	stz $053d,x			stz 	decimalBuffer+1,x
.25eb	ee 3b 05	inc $053b			inc 	dbOffset
.25ee	fa		plx				plx
.25ef	60		rts				rts
.053a					decimalPlaces:
>053a							.fill 	1
.053b					dbOffset:
>053b							.fill 	1
.053c					decimalBuffer:
>053c							.fill 	32
.25f0					ConvertInt16:
.25f0	85 3f		sta $3f				sta 	NSMantissa0 				; set up as 32 bit conversion
.25f2	86 4b		stx $4b				stx 	NSMantissa1
.25f4	64 57		stz $57				stz 	NSMantissa2
.25f6	64 63		stz $63				stz 	NSMantissa3
.25f8	64 33		stz $33				stz 	NSStatus 					; positive integer
.25fa	a2 00		ldx #$00			ldx 	#0 							; stack level
.25fc	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25fe	80 00		bra $2600			bra 	ConvertInt32
.2600					ConvertInt32:
.2600	5a		phy				phy
.2601	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.2603	24 33		bit $33				bit 	NSStatus 					; output a - if not negative.
.2605	10 08		bpl $260f			bpl 	_CI32NotNeg
.2607	48		pha				pha
.2608	a9 2d		lda #$2d			lda 	#'-'
.260a	99 15 05	sta $0515,y			sta 	numberBuffer,y
.260d	c8		iny				iny
.260e	68		pla				pla
.260f					_CI32NotNeg:
.260f	20 1d 26	jsr $261d			jsr 	_CI32DivideConvert 			; recursive conversion
.2612	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2614	99 15 05	sta $0515,y			sta 	numberBuffer,y
.2617	7a		ply				ply
.2618	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.261a	a9 15		lda #$15			lda 	#numberBuffer & $FF
.261c	60		rts				rts
.261d					_CI32DivideConvert:
.261d	e8		inx				inx 								; write to next slot up
.261e	20 83 26	jsr $2683			jsr 	FloatSetByte 		 		; write the base out.
.2621	ca		dex				dex
.2622	20 17 22	jsr $2217			jsr 	Int32Divide 				; divide
.2625	b5 3f		lda $3f,x			lda 	NSMantissa0,x 				; save remainder
.2627	48		pha				pha
.2628	20 06 22	jsr $2206			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.262b	20 a3 26	jsr $26a3			jsr 	FloatIsZero 				; is it zero ?
.262e	f0 05		beq $2635			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2630	b5 40		lda $40,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2632	20 1d 26	jsr $261d			jsr 	_CI32DivideConvert 			; and recusrively call.
.2635					_CI32NoRecurse:
.2635	68		pla				pla 								; remainder
.2636	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2638	90 02		bcc $263c			bcc 	_CI32NotHex
.263a	69 26		adc #$26			adc 	#6+32
.263c					_CI32NotHex:
.263c	69 30		adc #$30			adc 	#48
.263e	99 15 05	sta $0515,y			sta 	numberBuffer,y 				; write out and exit
.2641	c8		iny				iny
.2642	60		rts				rts
.2643					FloatNegate:
.2643	b5 33		lda $33,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2645	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2647	95 33		sta $33,x			sta 	NSStatus,x
.2649	60		rts				rts
.264a					FloatNegateMantissa:
.264a	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.264b	a9 00		lda #$00			lda 	#0
.264d	f5 3f		sbc $3f,x			sbc 	NSMantissa0,x
.264f	95 3f		sta $3f,x			sta 	NSMantissa0,x
.2651	a9 00		lda #$00			lda 	#0
.2653	f5 4b		sbc $4b,x			sbc 	NSMantissa1,x
.2655	95 4b		sta $4b,x			sta 	NSMantissa1,x
.2657	a9 00		lda #$00			lda 	#0
.2659	f5 57		sbc $57,x			sbc 	NSMantissa2,x
.265b	95 57		sta $57,x			sta 	NSMantissa2,x
.265d	a9 00		lda #$00			lda 	#0
.265f	f5 63		sbc $63,x			sbc 	NSMantissa3,x
.2661	95 63		sta $63,x			sta 	NSMantissa3,x
.2663	60		rts				rts
.2664					FloatShiftUpTwo:
.2664	b5 3f		lda $3f,x			lda 	NSMantissa0,x
.2666	95 41		sta $41,x			sta 	NSMantissa0+2,x
.2668	b5 4b		lda $4b,x			lda 	NSMantissa1,x
.266a	95 4d		sta $4d,x			sta 	NSMantissa1+2,x
.266c	b5 57		lda $57,x			lda 	NSMantissa2,x
.266e	95 59		sta $59,x			sta 	NSMantissa2+2,x
.2670	b5 63		lda $63,x			lda 	NSMantissa3,x
.2672	95 65		sta $65,x			sta 	NSMantissa3+2,x
.2674	b5 6f		lda $6f,x			lda 	NSExponent,x
.2676	95 71		sta $71,x			sta 	NSExponent+2,x
.2678	b5 33		lda $33,x			lda 	NSStatus,x
.267a	95 35		sta $35,x			sta 	NSStatus+2,x
.267c	60		rts				rts
.267d					FloatSetZeroMantissaOnly:
.267d	74 3f		stz $3f,x			stz 	NSMantissa0,x
.267f	80 08		bra $2689			bra 	FloatZero13
.2681					FloatSetZero:
.2681	a9 00		lda #$00			lda 	#0
.2683					FloatSetByte:
.2683	74 6f		stz $6f,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2685					FloatSetMantissa:
.2685	95 3f		sta $3f,x			sta 	NSMantissa0,x 				; zero mantissa
.2687	74 33		stz $33,x			stz 	NSStatus,x
.2689					FloatZero13:
.2689	74 4b		stz $4b,x			stz 	NSMantissa1,x
.268b	74 57		stz $57,x			stz 	NSMantissa2,x
.268d	74 63		stz $63,x			stz 	NSMantissa3,x
.268f	60		rts				rts
.2690					FloatShiftLeft:
.2690	18		clc				clc
.2691					FloatRotateLeft:
.2691	36 3f		rol $3f,x			rol 	NSMantissa0,x
.2693	36 4b		rol $4b,x			rol		NSMantissa1,x
.2695	36 57		rol $57,x			rol		NSMantissa2,x
.2697	36 63		rol $63,x			rol		NSMantissa3,x
.2699	60		rts				rts
.269a					FloatShiftRight:
.269a	56 63		lsr $63,x			lsr 	NSMantissa3,x
.269c	76 57		ror $57,x			ror		NSMantissa2,x
.269e	76 4b		ror $4b,x			ror		NSMantissa1,x
.26a0	76 3f		ror $3f,x			ror		NSMantissa0,x
.26a2	60		rts				rts
.26a3					FloatIsZero:
.26a3	b5 63		lda $63,x			lda 	NSMantissa3,x
.26a5	15 57		ora $57,x			ora		NSMantissa2,x
.26a7	15 4b		ora $4b,x			ora		NSMantissa1,x
.26a9	15 3f		ora $3f,x			ora		NSMantissa0,x
.26ab	60		rts				rts

;******  Processing input file: testing/testend.asm

.26ac					EndProgram:
>26ac	01 08 0c 08 0a 00 4e 20				.binary "code/tokenised.dat"
>26b4	b2 20 31 34 00 15 08 14 00 ce 86 20 33 00 32 08
>26c4	3c 00 99 20 c7 28 31 34 37 29 3b 22 48 45 4c 4c
>26d4	4f 20 57 4f 52 4c 44 20 21 22 00 4e 08 46 00 86
>26e4	20 42 58 28 4e 29 3a 86 20 42 59 28 4e 29 3a 86
>26f4	20 42 43 28 4e 29 00 62 08 4b 00 86 20 44 58 28
>2704	4e 29 3a 86 20 44 59 28 4e 29 00 70 08 50 00 81
>2714	20 42 b2 30 20 a4 20 4e 00 89 08 5a 00 42 58 28
>2724	42 29 b2 b5 28 bb 28 31 29 ac 34 30 29 ac 32 aa
>2734	31 00 a2 08 64 00 42 59 28 42 29 b2 b5 28 bb 28
>2744	31 29 ac 33 30 29 ac 32 35 36 00 b9 08 69 00 42
>2754	43 28 42 29 b2 b5 28 bb 28 31 29 ac 31 34 29 aa
>2764	31 00 cd 08 6a 00 44 58 28 42 29 b2 b5 28 bb 28
>2774	31 29 ac 32 29 00 e3 08 6c 00 8f 20 44 59 28 42
>2784	29 b2 b5 28 bb 28 31 29 ac 32 29 00 ef 08 6d 00
>2794	44 59 28 42 29 b2 31 00 f7 08 6e 00 82 20 42 00
>27a4	fd 08 78 00 8f 00 11 09 82 00 81 59 b2 30 a4 32
>27b4	39 3a 81 58 b2 30 a4 33 39 00 27 09 8c 00 51 b2
>27c4	59 ac 32 35 36 aa 58 ac 32 aa 34 35 30 35 36 00
>27d4	3f 09 96 00 ce 84 20 31 2c 51 2c 38 31 3a ce 84
>27e4	31 2c 51 aa 31 2c 30 00 48 09 a0 00 82 58 2c 59
>27f4	00 54 09 c8 00 81 20 42 b2 31 a4 4e 00 71 09 d2
>2804	00 ce 84 20 31 2c 34 35 30 35 36 aa 42 59 28 42
>2814	29 aa 42 58 28 42 29 2c 30 00 7f 09 e6 00 44 58
>2824	42 b2 44 58 28 42 29 00 90 09 f0 00 8b 44 58 42
>2834	b2 30 a7 8d 31 30 31 30 00 a1 09 fa 00 8b 44 58
>2844	42 b2 31 a7 8d 31 30 34 30 00 af 09 ff 00 44 59
>2854	42 b2 44 59 28 42 29 00 c0 09 04 01 8b 44 59 42
>2864	b2 30 a7 8d 31 30 37 30 00 d1 09 0e 01 8b 44 59
>2874	42 b2 31 a7 8d 31 31 30 30 00 f2 09 18 01 ce 84
>2884	20 31 2c 34 35 30 35 36 aa 42 59 28 42 29 aa 42
>2894	58 28 42 29 2c 42 43 28 42 29 00 f9 09 22 01 82
>28a4	42 00 03 0a 2c 01 89 20 32 30 30 00 09 0a e8 03
>28b4	8f 00 17 0a f2 03 42 58 42 b2 42 58 28 42 29 00
>28c4	2c 0a f3 03 8b 42 58 42 b2 31 a7 44 58 28 42 29
>28d4	b2 31 3a 8e 00 3e 0a fc 03 42 58 28 42 29 b2 42
>28e4	58 42 ab 32 3a 8e 00 44 0a 06 04 8f 00 52 0a 10
>28f4	04 42 58 42 b2 42 58 28 42 29 00 72 0a 11 04 8b
>2904	42 58 42 b2 37 39 a7 20 42 58 28 42 29 b2 37 37
>2914	3a 44 58 28 42 29 b2 30 3a 8e 00 84 0a 1a 04 42
>2924	58 28 42 29 b2 42 58 42 aa 32 3a 8e 00 8a 0a 24
>2934	04 8f 00 98 0a 2e 04 42 59 42 b2 42 59 28 42 29
>2944	00 ad 0a 2f 04 8b 42 59 42 b2 30 a7 44 59 28 42
>2954	29 b2 31 3a 8e 00 c1 0a 38 04 42 59 28 42 29 b2
>2964	42 59 42 ab 32 35 36 3a 8e 00 c7 0a 42 04 8f 00
>2974	d5 0a 4c 04 42 59 42 b2 42 59 28 42 29 00 f8 0a
>2984	4d 04 8b 42 59 42 b2 37 34 32 34 a7 42 59 28 42
>2994	29 b2 37 31 36 38 3a 44 59 28 42 29 b2 30 3a 8e
>29a4	00 0c 0b 56 04 42 59 28 42 29 b2 42 59 42 aa 32
>29b4	35 36 3a 8e 00 00 00

;******  End of listing
