
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Sat Oct  7 08:09:46 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.1000					WrapperBoot:
.1000	a2 0a		ldx #$0a			ldx 	#APIDesc & $FF
.1002	a0 10		ldy #$10			ldy 	#APIDesc >> 8
.1004	20 b7 10	jsr $10b7			jsr 	StartCompiler
.1007	4c ff ff	jmp $ffff			jmp 	$FFFF
.100a					APIDesc:
>100a							.fill 	2
>100c	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>100d	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

.0022					srcPtr:
>0022							.fill 	2
.0400					sourceBuffer:
>0400							.fill 	256
.0500					currentLineNumber:
>0500							.fill 	2
=$4000					PCodeStart = $4000
.100e					InlineNonDecimal:
.100e	a2 02		ldx #$02			ldx 	#2 							; get size in X
.1010	c9 25		cmp #$25			cmp 	#"%"
.1012	f0 02		beq $1016			beq 	_INDBinary
.1014	a2 10		ldx #$10			ldx 	#16
.1016					_INDBinary:
.1016	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.1018	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.101a	64 2c		stz $2c				stz 	zTemp0 						; zero result
.101c	64 2d		stz $2d				stz 	zTemp0+1
.101e					_INDLoop:
.101e	20 a3 19	jsr $19a3			jsr 	LookNext 					; check next character
.1021	20 df 19	jsr $19df			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.1024	90 1f		bcc $1045			bcc		_INDDone 					; didn't convert
.1026	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.1028	b0 1b		bcs $1045			bcs 	_INDDone
.102a	20 54 10	jsr $1054			jsr 	_INDShift 					; x 2 or x 16
.102d	e0 02		cpx #$02			cpx 	#2
.102f	f0 09		beq $103a			beq 	_INDNotHex
.1031	20 54 10	jsr $1054			jsr 	_INDShift
.1034	20 54 10	jsr $1054			jsr 	_INDShift
.1037	20 54 10	jsr $1054			jsr 	_INDShift
.103a					_INDNotHex:
.103a	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.103c	85 2c		sta $2c				sta 	zTemp0
.103e	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume
.1041	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.1043	80 d9		bra $101e			bra 	_INDLoop
.1045					_INDDone:
.1045	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.1047	f0 08		beq $1051			beq 	_INDError
.1049	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.104b	a5 2c		lda $2c				lda 	zTemp0
.104d	20 3e 11	jsr $113e			jsr 	PushIntegerYA
.1050	60		rts				rts
.1051					_INDError:
.1051	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.1054					_INDShift:
.1054	06 2c		asl $2c				asl 	zTemp0
.1056	26 2d		rol $2d				rol 	zTemp0+1
.1058	60		rts				rts
.1059					WriteCodeByte:
.1059	48		pha				pha 								; save on stack
.105a	da		phx				phx
.105b	5a		phy				phy
.105c	20 82 1e	jsr $1e82			jsr 	APIOWriteByte
.105f	7a		ply				ply 								; restore from stack
.1060	fa		plx				plx
.1061	68		pla				pla
.1062	60		rts				rts
.1063					PrintCharacter
.1063	48		pha				pha
.1064	da		phx				phx
.1065	5a		phy				phy
.1066	20 e2 1e	jsr $1ee2			jsr 	APIOPrintCharacter
.1069	7a		ply				ply
.106a	fa		plx				plx
.106b	68		pla				pla
.106c	60		rts				rts
.106d					BufferClear:
.106d	9c 02 05	stz $0502			stz 	bufferSize
.1070	60		rts				rts
.1071					BufferWrite:
.1071	da		phx				phx
.1072	ae 02 05	ldx $0502			ldx 	bufferSize
.1075	9d 03 05	sta $0503,x			sta 	dataBuffer,x
.1078	ee 02 05	inc $0502			inc 	bufferSize
.107b	fa		plx				plx
.107c	60		rts				rts
.107d					BufferOutput:
.107d	ad 02 05	lda $0502			lda 	bufferSize
.1080	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1083	a2 00		ldx #$00			ldx 	#0
.1085					_BOLoop:
.1085	ec 02 05	cpx $0502			cpx 	bufferSize
.1088	f0 09		beq $1093			beq 	_BOExit
.108a	bd 03 05	lda $0503,x			lda 	dataBuffer,x
.108d	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1090	e8		inx				inx
.1091	80 f2		bra $1085			bra 	_BOLoop
.1093					_BOExit:
.1093	60		rts				rts
.0502					bufferSize:
>0502							.fill 	1
.0503					dataBuffer:
>0503							.fill 	256
.1094					CheckNextComma:
.1094	a9 2c		lda #$2c			lda	 	#","
.1096	80 06		bra $109e			bra 	CheckNextA
.1098					CheckNextRParen:
.1098	a9 29		lda #$29			lda	 	#")"
.109a	80 02		bra $109e			bra 	CheckNextA
.109c					CheckNextLParen:
.109c	a9 28		lda #$28			lda 	#"("
.109e					CheckNextA:
.109e	8d 03 06	sta $0603			sta 	checkCharacter 				; save test character
.10a1					_CNALoop:
.10a1	20 bf 19	jsr $19bf			jsr 	GetNextNonSpace 			; get next skipping spaces.
.10a4	cd 03 06	cmp $0603			cmp 	checkCharacter 				; matches ?
.10a7	f0 03		beq $10ac			beq 	_CNAExit
.10a9	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.10ac					_CNAExit:
.10ac	60		rts				rts
.0603					checkCharacter:
>0603							.fill 	1
.10ad					APIOClose:
.10ad	a9 40		lda #$40			lda 	#(PCodeStart >> 8)
.10af	a6 29		ldx $29				ldx 	objPtr
.10b1	a4 2a		ldy $2a				ldy 	objPtr+1
.10b3	20 e6 1e	jsr $1ee6			jsr 	APISaveMemory
.10b6	60		rts				rts
.10b7					StartCompiler:
.10b7	86 2c		stx $2c				stx 	zTemp0 						; access API
.10b9	84 2d		sty $2d				sty 	zTemp0+1
.10bb	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.10bd	b2 2c		lda ($2c)			lda 	(zTemp0)
.10bf	8d 05 06	sta $0605			sta 	APIVector
.10c2	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.10c4	8d 06 06	sta $0606			sta 	APIVector+1
.10c7	c8		iny				iny 								; copy data area range.
.10c8	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.10ca	8d 07 06	sta $0607			sta 	compilerStartHigh
.10cd	c8		iny				iny
.10ce	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.10d0	8d 08 06	sta $0608			sta 	compilerEndHigh
.10d3	ba		tsx				tsx 								; save stack pointer
.10d4	8e 04 06	stx $0604			stx 	compilerSP
.10d7	20 9b 1d	jsr $1d9b			jsr 	STRReset 					; reset storage (line#, variable)
.10da	20 2f 15	jsr $152f			jsr 	APIIOpen 					; reset data input
.10dd	20 55 1c	jsr $1c55			jsr 	APIOOpen 					; reset data output.
.10e0	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.10e2	20 59 10	jsr $1059			jsr 	WriteCodeByte
.10e5	a9 00		lda #$00			lda 	#0
.10e7	20 59 10	jsr $1059			jsr 	WriteCodeByte
.10ea	20 59 10	jsr $1059			jsr 	WriteCodeByte
.10ed					MainCompileLoop:
.10ed	20 39 1b	jsr $1b39			jsr 	ReadNextLine 				; read next line into the buffer.
.10f0	90 2e		bcc $1120			bcc 	SaveCodeAndExit 			; end of source.
.10f2	20 6a 1b	jsr $1b6a			jsr 	GetLineNumber 				; get line #
.10f5	20 71 1b	jsr $1b71			jsr 	STRMarkLine 				; remember the position and number of this line.
.10f8	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.10fa	20 59 10	jsr $1059			jsr 	WriteCodeByte
.10fd					_MCLSameLine:
.10fd	20 bf 19	jsr $19bf			jsr 	GetNextNonSpace 			; get the first character.
.1100	f0 eb		beq $10ed			beq 	MainCompileLoop 			; end of line, get next line.
.1102	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.1104	f0 f7		beq $10fd			beq 	_MCLSameLine
.1106	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.1108	10 0c		bpl $1116			bpl 	_MCLCheckAssignment
.110a	a2 80		ldx #$80			ldx 	#CommandTables & $FF 		; do command tables.
.110c	a0 15		ldy #$15			ldy 	#CommandTables >> 8
.110e	20 48 18	jsr $1848			jsr 	GeneratorProcess
.1111	b0 ea		bcs $10fd			bcs 	_MCLSameLine 				; keep trying to compile the line.
.1113					_MCLSyntax:
.1113	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.1116					_MCLCheckAssignment:
.1116	20 d5 19	jsr $19d5			jsr 	CharIsAlpha 				; if not alpha then syntax error
.1119	90 f8		bcc $1113			bcc 	_MCLSyntax
.111b	20 07 1b	jsr $1b07			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.111e	80 dd		bra $10fd			bra		_MCLSameLine 				; loop back.
.1120					SaveCodeAndExit:
.1120	20 37 15	jsr $1537			jsr 	APIIClose 					; finish input.
.1123	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.1125	a8		tay				tay
.1126	20 71 1b	jsr $1b71			jsr 	STRMarkLine
.1129	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.112b	20 59 10	jsr $1059			jsr 	WriteCodeByte
.112e	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.1130	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1133	20 5a 14	jsr $145a			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.1136	20 ad 10	jsr $10ad			jsr 	APIOClose
.1139					ExitCompiler:
.1139	ae 04 06	ldx $0604			ldx 	compilerSP 					; reload SP and exit.
.113c	9a		txs				txs
.113d	60		rts				rts
.0604					compilerSP:
>0604							.fill 	1
.0605					APIVector:
>0605							.fill 	2
.0607					compilerStartHigh:
>0607							.fill 	1
.0608					compilerEndHigh:
>0608							.fill 	1
.113e					PushIntegerYA:
.113e	c0 00		cpy #$00			cpy 	#0 							; 0-255
.1140	f0 0f		beq $1151			beq 	PushIntegerA
.1142	48		pha				pha
.1143	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.1145	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1148	68		pla				pla 								; then LSB
.1149	20 59 10	jsr $1059			jsr 	WriteCodeByte
.114c	98		tya				tya 								; then MSB
.114d	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1150	60		rts				rts
.1151					PushIntegerA:
.1151	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.1153	90 07		bcc $115c			bcc 	_PIWriteA
.1155	48		pha				pha
.1156	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.1158	20 59 10	jsr $1059			jsr 	WriteCodeByte
.115b	68		pla				pla
.115c					_PIWriteA:
.115c	20 59 10	jsr $1059			jsr 	WriteCodeByte
.115f	60		rts				rts
.1160					PushFloat:
.1160	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.1162	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1165	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.1167	20 59 10	jsr $1059			jsr 	WriteCodeByte
.116a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.116c	20 59 10	jsr $1059			jsr 	WriteCodeByte
.116f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1171	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1174	b5 56		lda $56,x			lda 	NSMantissa2,x
.1176	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1179	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.117b	29 80		and #$80			and 	#$80
.117d	15 62		ora $62,x			ora 	NSMantissa3,x
.117f	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1182	60		rts				rts
.1183					CreateVariableRecord:
.1183	48		pha				pha
.1184	ad 13 06	lda $0613			lda 	freeVariableMemory 		; push current free address on stack.
.1187	48		pha				pha
.1188	ad 14 06	lda $0614			lda 	freeVariableMemory+1
.118b	48		pha				pha
.118c	ad 11 06	lda $0611			lda 	variableListEnd  		; copy end of list to zTemp0
.118f	85 2c		sta $2c				sta 	zTemp0
.1191	ad 12 06	lda $0612			lda 	variableListEnd+1
.1194	85 2d		sta $2d				sta 	zTemp0+1
.1196	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.1198	92 2c		sta ($2c)			sta 	(zTemp0)
.119a	98		tya				tya
.119b	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.119d	91 2c		sta ($2c),y			sta 	(zTemp0),y
.119f	88		dey				dey
.11a0	8a		txa				txa
.11a1	91 2c		sta ($2c),y			sta 	(zTemp0),y
.11a3	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.11a5	ad 13 06	lda $0613			lda 	freeVariableMemory
.11a8	91 2c		sta ($2c),y			sta 	(zTemp0),y
.11aa	c8		iny				iny
.11ab	ad 14 06	lda $0614			lda 	freeVariableMemory+1
.11ae	91 2c		sta ($2c),y			sta 	(zTemp0),y
.11b0	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.11b2	a9 00		lda #$00			lda 	#0
.11b4	91 2c		sta ($2c),y			sta 	(zTemp0),y
.11b6	18		clc				clc
.11b7	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.11b9	6d 11 06	adc $0611			adc  	variableListEnd
.11bc	8d 11 06	sta $0611			sta 	variableListEnd
.11bf	90 03		bcc $11c4			bcc 	_CVNoCarry2
.11c1	ee 12 06	inc $0612			inc 	variableListEnd+1
.11c4					_CVNoCarry2:
.11c4	7a		ply				ply
.11c5	fa		plx				plx
.11c6	68		pla				pla
.11c7	60		rts				rts
.11c8					SetVariableRecordToCodePosition:
.11c8	48		pha				pha
.11c9	5a		phy				phy
.11ca	a5 2b		lda $2b				lda 	objPage
.11cc	a0 03		ldy #$03			ldy 	#3
.11ce	91 2c		sta ($2c),y			sta 	(zTemp0),y
.11d0	c8		iny				iny
.11d1	a5 2a		lda $2a				lda 	objPtr+1
.11d3	91 2c		sta ($2c),y			sta 	(zTemp0),y
.11d5	c8		iny				iny
.11d6	a5 29		lda $29				lda 	objPtr
.11d8	91 2c		sta ($2c),y			sta 	(zTemp0),y
.11da	7a		ply				ply
.11db	68		pla				pla
.11dc	60		rts				rts
.11dd					AllocateBytesForType:
.11dd	48		pha				pha
.11de	da		phx				phx
.11df	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.11e1	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.11e3	c9 00		cmp #$00			cmp 	#NSSIFloat
.11e5	d0 02		bne $11e9			bne 	_CVNotFloat
.11e7	a2 06		ldx #$06			ldx 	#6
.11e9					_CVNotFloat:
.11e9	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.11ea	18		clc				clc
.11eb	6d 13 06	adc $0613			adc 	freeVariableMemory
.11ee	8d 13 06	sta $0613			sta 	freeVariableMemory
.11f1	90 03		bcc $11f6			bcc 	_CVNoCarry1
.11f3	ee 14 06	inc $0614			inc 	freeVariableMemory+1
.11f6					_CVNoCarry1:
.11f6	fa		plx				plx
.11f7	68		pla				pla
.11f8	60		rts				rts
.11f9					CommandDATA:
.11f9	20 6d 10	jsr $106d			jsr 	BufferClear 				; copy it to the buffer
.11fc	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace
.11ff					_CTDataLoop:
.11ff	20 a3 19	jsr $19a3			jsr 	LookNext 					; reached EOL
.1202	f0 08		beq $120c			beq 	_CTDataDone
.1204	20 71 10	jsr $1071			jsr 	BufferWrite 				; write and consume
.1207	20 b4 19	jsr $19b4			jsr 	GetNext
.120a	80 f3		bra $11ff			bra 	_CTDataLoop
.120c					_CTDataDone:
.120c	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.120e	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1211	20 7d 10	jsr $107d			jsr 	BufferOutput
.1214	60		rts				rts
.1215					CommandDEF:
.1215	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.1217	20 51 11	jsr $1151			jsr 	PushIntegerA
.121a	20 cb 1a	jsr $1acb			jsr 	CompileGotoEOL 				; compile skip over DEF
.121d	a9 a5		lda #$a5			lda 	#C64_FN
.121f	20 9e 10	jsr $109e			jsr 	CheckNextA
.1222	20 bf 19	jsr $19bf			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.1225	20 24 1a	jsr $1a24			jsr 	ExtractVariableName
.1228	8a		txa				txa
.1229	10 51		bpl $127c			bpl 	_CDError
.122b	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.122c	29 7f		and #$7f			and 	#$7F
.122e	aa		tax				tax
.122f	98		tya				tya
.1230	09 80		ora #$80			ora 	#$80
.1232	a8		tay				tay
.1233	20 fe 13	jsr $13fe			jsr 	FindVariable				; does it already exist ?
.1236	b0 44		bcs $127c			bcs 	_CDError 					; if so, that's an error.
.1238	20 83 11	jsr $1183			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.123b	20 c8 11	jsr $11c8			jsr 	SetVariableRecordToCodePosition
.123e	20 bf 19	jsr $19bf			jsr 	GetNextNonSpace
.1241	20 58 1d	jsr $1d58			jsr 	GetReferenceTerm 			; get var ref, not array
.1244	c9 00		cmp #$00			cmp 	#0
.1246	30 34		bmi $127c			bmi 	_CDError
.1248	8d 09 06	sta $0609			sta 	defType 					; save type
.124b	8e 0a 06	stx $060a			stx 	defVariable 				; save var ref
.124e	8c 0b 06	sty $060b			sty 	defVariable+1
.1251	29 40		and #$40			and 	#NSSString 					; only numbers.
.1253	d0 27		bne $127c			bne 	_CDError
.1255	20 98 10	jsr $1098			jsr 	CheckNextRParen 			; check )
.1258	a9 b2		lda #$b2			lda 	#C64_EQUAL
.125a	20 9e 10	jsr $109e			jsr 	CheckNextA 					; check =
.125d	18		clc				clc 								; if this is DEF FNxx(A), read A
.125e	20 7f 12	jsr $127f			jsr 	CDReadWriteVariable
.1261	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1263	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1266	38		sec				sec
.1267	20 7f 12	jsr $127f			jsr 	CDReadWriteVariable 		; A is now updated
.126a	20 44 13	jsr $1344			jsr 	CompileExpressionAt0 		; the actual body of the function.
.126d	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.126f	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1272	38		sec				sec
.1273	20 7f 12	jsr $127f			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.1276	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.1278	20 59 10	jsr $1059			jsr 	WriteCodeByte
.127b	60		rts				rts
.127c					_CDError:
.127c	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.127f					CDReadWriteVariable:
.127f	ac 0b 06	ldy $060b			ldy 	defVariable+1 				; set up YX
.1282	ae 0a 06	ldx $060a			ldx 	defVariable
.1285	ad 09 06	lda $0609			lda 	defType
.1288	20 0a 1d	jsr $1d0a			jsr 	GetSetVariable
.128b	60		rts				rts
.0609					defType:
>0609							.fill 	1
.060a					defVariable:
>060a							.fill 	2
.128c					CommandDIM:
.128c	20 bf 19	jsr $19bf			jsr 	GetNextNonSpace 			; get the first non space character
.128f	20 24 1a	jsr $1a24			jsr 	ExtractVariableName 		; variable name to XY
.1292	da		phx				phx 								; save name with type bits.
.1293	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.1295	10 37		bpl $12ce			bpl 	_CDError
.1297	20 fe 13	jsr $13fe			jsr 	FindVariable	 			; see if already exist
.129a	b0 35		bcs $12d1			bcs 	_CDRedefine 				; it still exists.
.129c	20 83 11	jsr $1183			jsr 	CreateVariableRecord 		; create the basic variable
.129f	20 dd 11	jsr $11dd			jsr 	AllocateBytesForType 		; allocate memory for it
.12a2	68		pla				pla 								; restore type bits
.12a3	5a		phy				phy 								; save the address of the basic storage
.12a4	da		phx				phx
.12a5	48		pha				pha
.12a6	20 d4 12	jsr $12d4			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.12a9	68		pla				pla
.12aa	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.12ac	20 51 11	jsr $1151			jsr 	PushIntegerA 				; push that type data out.
.12af	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.12b1	20 59 10	jsr $1059			jsr 	WriteCodeByte
.12b4	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.12b6	20 59 10	jsr $1059			jsr 	WriteCodeByte
.12b9	fa		plx				plx 								; restore address
.12ba	7a		ply				ply
.12bb	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.12bd	38		sec				sec
.12be	20 0a 1d	jsr $1d0a			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.12c1	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; , follows ?
.12c4	c9 2c		cmp #$2c			cmp 	#","
.12c6	d0 05		bne $12cd			bne 	_CDExit
.12c8	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume comma
.12cb	80 bf		bra $128c			bra 	CommandDIM 					; do another DIM
.12cd					_CDExit:
.12cd	60		rts				rts
.12ce					_CDError:
.12ce	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.12d1					_CDRedefine:
.12d1	4c f5 1f	jmp $1ff5		jmp	ErrorV_redefine
.12d4					OutputIndexGroup:
.12d4	9c 0c 06	stz $060c			stz 	IndexCount 					; count of number of indices.
.12d7					_OIGNext:
.12d7	20 44 13	jsr $1344			jsr 	CompileExpressionAt0 		; get a dimension
.12da	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.12dc	c9 00		cmp #$00			cmp 	#NSSIFloat
.12de	d0 19		bne $12f9			bne 	_OIGType
.12e0	ee 0c 06	inc $060c			inc 	IndexCount 					; bump the counter.
.12e3	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; does a , follow ?
.12e6	c9 2c		cmp #$2c			cmp 	#","
.12e8	d0 05		bne $12ef			bne 	_OIGCheckEnd
.12ea	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume comma
.12ed	80 e8		bra $12d7			bra 	_OIGNext 					; get next dimension
.12ef					_OIGCheckEnd:
.12ef	20 98 10	jsr $1098			jsr 	CheckNextRParen 			; check and consume )
.12f2	ad 0c 06	lda $060c			lda 	IndexCount
.12f5	20 51 11	jsr $1151			jsr 	PushIntegerA 				; compile the dimension count.
.12f8	60		rts				rts
.12f9					_OIGType:
.12f9	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.060c					IndexCount:
>060c							.fill 	1
.12fc					ErrorHandler:
.12fc	68		pla				pla
.12fd	7a		ply				ply
.12fe	85 2c		sta $2c				sta 	zTemp0
.1300	84 2d		sty $2d				sty 	zTemp0+1
.1302	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.1304	a0 01		ldy #$01			ldy 	#1
.1306					_EHDisplayMsg:
.1306	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1308	20 63 10	jsr $1063			jsr 	PrintCharacter
.130b	c8		iny				iny
.130c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.130e	d0 f6		bne $1306			bne 	_EHDisplayMsg
.1310	a9 20		lda #$20			lda 	#32
.1312	20 63 10	jsr $1063			jsr 	PrintCharacter
.1315	a9 40		lda #$40			lda 	#64
.1317	20 63 10	jsr $1063			jsr 	PrintCharacter
.131a	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.131c	20 75 26	jsr $2675			jsr 	FloatSetByte
.131f	20 6a 1b	jsr $1b6a			jsr 	GetLineNumber
.1322	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1324	98		tya				tya
.1325	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1327	20 5b 25	jsr $255b			jsr 	FloatToString
.132a	a0 00		ldy #$00			ldy 	#0 							; display that string.
.132c	a2 00		ldx #$00			ldx 	#0
.132e					_EHDisplayLine:
.132e	b9 3c 06	lda $063c,y			lda 	decimalBuffer,y
.1331	20 63 10	jsr $1063			jsr 	PrintCharacter
.1334	c8		iny				iny
.1335	b9 3c 06	lda $063c,y			lda 	decimalBuffer,y
.1338	d0 f4		bne $132e			bne 	_EHDisplayLine
.133a	a9 0d		lda #$0d			lda 	#13
.133c	20 63 10	jsr $1063			jsr 	PrintCharacter
.133f	80 fe		bra $133f	_EHHalt:bra 	_EHHalt
.1341	4c 39 11	jmp $1139			jmp 	ExitCompiler
.1344					CompileExpressionAt0:
.1344	a9 00		lda #$00			lda 	#0
.1346					CompileExpressionAtA:
.1346	48		pha				pha  								; save level
.1347	20 c3 1d	jsr $1dc3			jsr 	CompileTerm 				; compile a term.
.134a	fa		plx				plx 								; get level back into X
.134b					_ECALoop:
.134b	48		pha				pha 								; save type on stack.
.134c	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; get the next character
.134f	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.1351	90 04		bcc $1357			bcc 	_ECAExit
.1353	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.1355	90 02		bcc $1359			bcc 	_ECAHaveToken
.1357					_ECAExit:
.1357	68		pla				pla 								; throw type off stack
.1358	60		rts				rts
.1359					_ECAHaveToken:
.1359	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.135b	aa		tax				tax 								; X contains the operator token
.135c	bd 47 13	lda $1347,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.135f	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.1361	90 f4		bcc $1357			bcc 	_ECAExit
.1363	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.1365	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume the token.
.1368	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.136a	f0 11		beq $137d			beq 	_ECAGreaterCheck
.136c	e0 b3		cpx #$b3			cpx 	#C64_LESS
.136e	d0 1a		bne $138a			bne 	_ECAHaveFullToken
.1370	20 a3 19	jsr $19a3			jsr 	LookNext 					; checks for < (<= or <>)
.1373	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.1375	f0 0e		beq $1385			beq	 	_ECAToNotEqual
.1377	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.1379	d0 0f		bne $138a			bne 	_ECAHaveFullToken
.137b	80 07		bra $1384			bra 	_ECAAddEqual
.137d					_ECAGreaterCheck:
.137d	20 a3 19	jsr $19a3			jsr 	LookNext
.1380	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.1382	d0 06		bne $138a			bne 	_ECAHaveFullToken
.1384					_ECAAddEqual:
.1384	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.1385					_ECAToNotEqual:
.1385	e8		inx				inx
.1386	e8		inx				inx
.1387	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume the = or > in >= <= <>
.138a					_ECAHaveFullToken:
.138a	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.138c	d0 0a		bne $1398			bne 	_ECANotConcat
.138e	68		pla				pla 								; get type back
.138f	48		pha				pha
.1390	29 40		and #$40			and 	#NSSTypeMask
.1392	c9 40		cmp #$40			cmp 	#NSSString
.1394	d0 02		bne $1398			bne 	_ECANotConcat
.1396	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1398					_ECANotConcat:
.1398	da		phx				phx 								; save operator on the stack
.1399	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.139b	da		phx				phx
.139c	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.139e	1a		inc a				inc 	a
.139f	20 46 13	jsr $1346			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.13a2	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.13a4	fa		plx				plx 								; restore current precedence in X
.13a5	68		pla				pla 								; restore operator
.13a6	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.13a8	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.13aa	90 17		bcc $13c3			bcc 	_ECANotCompare
.13ac	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.13ae	b0 13		bcs $13c3			bcs 	_ECANotCompare
.13b0	7a		ply				ply 								; get type into Y
.13b1	5a		phy				phy
.13b2	48		pha				pha 								; save operator
.13b3	98		tya				tya 								; get type
.13b4	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.13b6	29 40		and #$40			and 	#NSSTypeMask
.13b8	c9 40		cmp #$40			cmp 	#NSSString
.13ba	f0 02		beq $13be			beq 	_ECANotString
.13bc	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.13be					_ECANotString:
.13be	98		tya				tya									; output token Y
.13bf	20 59 10	jsr $1059			jsr 	WriteCodeByte
.13c2	68		pla				pla 								; restore operator.
.13c3					_ECANotCompare:
.13c3	18		clc				clc 								; convert to P-Code and compile.
.13c4	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.13c6	20 59 10	jsr $1059			jsr 	WriteCodeByte
.13c9	68		pla				pla 								; type of current result
.13ca	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.13cc	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.13ce	d0 19		bne $13e9			bne		_ECAType
.13d0	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.13d2	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.13d4	d0 18		bne $13ee			bne 	_ECAGoLoop
.13d6	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.13d8	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.13da	f0 10		beq $13ec			beq 	_ECAOkayString 				; (this is post conversion)
.13dc	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.13de	90 09		bcc $13e9			bcc 	_ECAType
.13e0	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.13e2	b0 05		bcs $13e9			bcs 	_ECAType
.13e4	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.13e6	4c 4b 13	jmp $134b			jmp 	_ECALoop
.13e9					_ECAType:
.13e9	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.13ec					_ECAOkayString:
.13ec	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.13ee					_ECAGoLoop:
.13ee	4c 4b 13	jmp $134b			jmp 	_ECALoop
.13f1					PrecedenceTable:
>13f1	03						.byte 	3 					; '+'
>13f2	03						.byte 	3 					; '-'
>13f3	04						.byte 	4 					; '*'
>13f4	04						.byte 	4 					; '/'
>13f5	05						.byte 	5 					; '^'
>13f6	01						.byte 	1 					; 'and'
>13f7	00						.byte 	0 					; 'or'
>13f8	02						.byte 	2 					; '>'
>13f9	02						.byte 	2 					; '='
>13fa	02						.byte 	2 					; '<'
>13fb	02						.byte 	2 					; '>='
>13fc	02						.byte 	2 					; '<='
>13fd	02						.byte 	2 					; '<>'
.13fe					FindVariable:
.13fe	86 2e		stx $2e				stx 	zTemp1 						; save name.
.1400	84 2f		sty $2f				sty 	zTemp1+1
.1402					_IVCheckSpecial:
.1402	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.1404	d0 18		bne $141e			bne 	_IVStandard
.1406	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.1408	f0 0c		beq $1416			beq 	_IVTIFloat
.140a	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.140c	d0 10		bne $141e			bne 	_IVStandard
.140e	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.1410	a2 01		ldx #$01			ldx 	#$01
.1412	a9 40		lda #$40			lda 	#NSSString
.1414	38		sec				sec
.1415	60		rts				rts
.1416					_IVTIFloat:
.1416	a0 80		ldy #$80			ldy 	#$80
.1418	a2 00		ldx #$00			ldx 	#$00
.141a	a9 00		lda #$00			lda 	#0
.141c	38		sec				sec
.141d	60		rts				rts
.141e					_IVStandard:
.141e	ad 07 06	lda $0607			lda 	compilerStartHigh			; start scanning from here.
.1421	85 2d		sta $2d				sta 	zTemp0+1
.1423	64 2c		stz $2c				stz 	zTemp0
.1425					_IVCheckLoop:
.1425	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.1427	f0 2b		beq $1454			beq  	_IVNotFound 				; if so, return with CC.
.1429	a0 01		ldy #$01			ldy 	#1 							; match ?
.142b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.142d	c5 2e		cmp $2e				cmp 	zTemp1
.142f	d0 07		bne $1438			bne	 	_IVNext
.1431	c8		iny				iny
.1432	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1434	c5 2f		cmp $2f				cmp 	zTemp1+1
.1436	f0 0d		beq $1445			beq 	_IVFound
.1438					_IVNext:
.1438	18		clc				clc
.1439	a5 2c		lda $2c				lda 	zTemp0
.143b	72 2c		adc ($2c)			adc 	(zTemp0)
.143d	85 2c		sta $2c				sta 	zTemp0
.143f	90 e4		bcc $1425			bcc 	_IVCheckLoop
.1441	e6 2d		inc $2d				inc 	zTemp0+1
.1443	80 e0		bra $1425			bra 	_IVCheckLoop
.1445					_IVFound:
.1445	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.1447	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1449	aa		tax				tax
.144a	c8		iny				iny
.144b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.144d	48		pha				pha
.144e	c8		iny				iny
.144f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1451	7a		ply				ply
.1452	38		sec				sec
.1453	60		rts				rts
.1454					_IVNotFound:
.1454	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.1456	a4 2f		ldy $2f				ldy 	zTemp1+1
.1458	18		clc				clc
.1459	60		rts				rts
.145a					FixBranches:
.145a	20 55 1c	jsr $1c55			jsr 	APIORewind 					; back to the start of the *object* code.
.145d					_FBLoop:
.145d	b2 29		lda ($29)			lda 	(objPtr) 					; get the next one.
.145f	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.1461	f0 16		beq $1479			beq 	_FBFixGotoGosub
.1463	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.1465	f0 12		beq $1479			beq 	_FBFixGotoGosub
.1467	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.1469	f0 0e		beq $1479			beq 	_FBFixGotoGosub
.146b	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.146d	f0 0a		beq $1479			beq 	_FBFixGotoGosub
.146f	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.1471	f0 49		beq $14bc			beq 	_FBFixVarSpace
.1473					_FBNext:
.1473	20 42 20	jsr $2042			jsr 	MoveObjectForward 			; move forward in object code.
.1476	90 e5		bcc $145d			bcc 	_FBLoop 					; not finished
.1478					_FBExit:
.1478	60		rts				rts
.1479					_FBFixGotoGosub:
.1479	a0 01		ldy #$01			ldy 	#1 							; if page is currently $FF
.147b	b1 29		lda ($29),y			lda 	(objPtr),y 					; then patch else leave.
.147d	c9 ff		cmp #$ff			cmp 	#$FF
.147f	d0 f2		bne $1473			bne 	_FBNext
.1481	a0 02		ldy #$02			ldy 	#2							; line number in YA
.1483	b1 29		lda ($29),y			lda 	(objPtr),y
.1485	48		pha				pha
.1486	c8		iny				iny
.1487	b1 29		lda ($29),y			lda 	(objPtr),y
.1489	a8		tay				tay
.148a	68		pla				pla
.148b	20 9f 1b	jsr $1b9f			jsr 	STRFindLine			 		; find where it is X:YA
.148e	90 08		bcc $1498			bcc 	_FBFFound 					; not found, so must be >
.1490	48		pha				pha
.1491	b2 29		lda ($29)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.1493	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1495	d0 15		bne $14ac			bne 	_FBFFail
.1497	68		pla				pla
.1498					_FBFFound:
.1498	20 f3 1b	jsr $1bf3			jsr 	STRMakeOffset 				; make it an offset from X:YA
.149b	5a		phy				phy	 								; patch the GOTO/GOSUB
.149c	48		pha				pha
.149d	a0 01		ldy #$01			ldy 	#1
.149f	8a		txa				txa
.14a0	91 29		sta ($29),y			sta 	(objPtr),y
.14a2	c8		iny				iny
.14a3	68		pla				pla
.14a4	91 29		sta ($29),y			sta 	(objPtr),y
.14a6	c8		iny				iny
.14a7	68		pla				pla
.14a8	91 29		sta ($29),y			sta 	(objPtr),y
.14aa	80 c7		bra $1473			bra 	_FBNext
.14ac					_FBFFail:
.14ac	a0 02		ldy #$02			ldy 	#2
.14ae	b1 29		lda ($29),y			lda 	(objPtr),y
.14b0	8d 00 05	sta $0500			sta 	currentLineNumber
.14b3	c8		iny				iny
.14b4	b1 29		lda ($29),y			lda 	(objPtr),y
.14b6	8d 01 05	sta $0501			sta 	currentLineNumber+1
.14b9	4c 70 1f	jmp $1f70		jmp	ErrorV_line
.14bc					_FBFixVarSpace:
.14bc	a0 01		ldy #$01			ldy 	#1
.14be	ad 13 06	lda $0613			lda 	freeVariableMemory
.14c1	91 29		sta ($29),y			sta 	(objPtr),y
.14c3	c8		iny				iny
.14c4	ad 14 06	lda $0614			lda 	freeVariableMemory+1
.14c7	91 29		sta ($29),y			sta 	(objPtr),y
.14c9	80 a8		bra $1473			bra 	_FBNext
.14cb					CommandFOR:
.14cb	20 bf 19	jsr $19bf			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.14ce	20 d5 19	jsr $19d5			jsr 	CharIsAlpha 				; if not alpha , error
.14d1	90 59		bcc $152c			bcc 	_CFFail
.14d3	20 58 1d	jsr $1d58			jsr 	GetReferenceTerm 			; figure out the reference.
.14d6	48		pha				pha 								; save type
.14d7	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.14d9	c9 00		cmp #$00			cmp 	#NSSIFloat
.14db	d0 4f		bne $152c			bne 	_CFFail
.14dd	5a		phy				phy 								; save reference on the stack
.14de	da		phx				phx
.14df	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.14e1	20 9e 10	jsr $109e			jsr 	CheckNextA
.14e4	20 44 13	jsr $1344			jsr 	CompileExpressionAt0 		; initial value
.14e7	fa		plx				plx 								; get reference back.
.14e8	7a		ply				ply
.14e9	5a		phy				phy
.14ea	da		phx				phx
.14eb	38		sec				sec 								; set initial value.
.14ec	20 0a 1d	jsr $1d0a			jsr 	GetSetVariable
.14ef	fa		plx				plx
.14f0	7a		ply				ply
.14f1	68		pla				pla
.14f2	29 20		and #$20			and 	#NSSIInt16
.14f4	f0 04		beq $14fa			beq 	_CFNotInt16
.14f6	98		tya				tya
.14f7	09 80		ora #$80			ora 	#$80
.14f9	a8		tay				tay
.14fa					_CFNotInt16:
.14fa	8a		txa				txa 								; reference in YA
.14fb	20 3e 11	jsr $113e			jsr 	PushIntegerYA
.14fe	a9 a4		lda #$a4			lda 	#C64_TO
.1500	20 9e 10	jsr $109e			jsr 	CheckNextA
.1503	20 44 13	jsr $1344			jsr 	CompileExpressionAt0 		; terminal value
.1506	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1508	c9 00		cmp #$00			cmp 	#NSSIFloat
.150a	d0 20		bne $152c			bne 	_CFFail
.150c	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; followed by STEP
.150f	c9 a9		cmp #$a9			cmp 	#C64_STEP
.1511	d0 0e		bne $1521			bne 	_CFNoStep
.1513	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume it.
.1516	20 44 13	jsr $1344			jsr 	CompileExpressionAt0 		; terminal value
.1519	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.151b	c9 00		cmp #$00			cmp 	#NSSIFloat
.151d	d0 0d		bne $152c			bne 	_CFFail
.151f	80 05		bra $1526			bra 	_CFParametersDone
.1521					_CFNoStep:
.1521	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.1523	20 51 11	jsr $1151			jsr 	PushIntegerA
.1526					_CFParametersDone:
.1526	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.1528	20 59 10	jsr $1059			jsr 	WriteCodeByte
.152b	60		rts				rts
.152c					_CFFail:
.152c	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.152f					APIIOpen:
.152f	a9 a0		lda #$a0			lda 	#((EndProgram+2) & $FF)
.1531	85 24		sta $24				sta 	0+srcInputPtr
.1533	a9 26		lda #$26			lda 	#((EndProgram+2) >> 8) & $FF
.1535	85 25		sta $25				sta 	1+srcInputPtr
.1537					APIIClose:
.1537	60		rts				rts
.1538					APIIGet:
.1538	b2 24		lda ($24)			lda 	(srcInputPtr)
.153a	e6 24		inc $24				inc 	srcInputPtr
.153c	d0 02		bne $1540			bne 	_IGSkip
.153e	e6 25		inc $25				inc 	srcInputPtr+1
.1540					_IGSkip:
.1540	60		rts				rts
.0024					srcInputPtr:
>0024							.fill 	2
.1541					FNCompile:
.1541	20 bf 19	jsr $19bf			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.1544	20 24 1a	jsr $1a24			jsr 	ExtractVariableName
.1547	e0 00		cpx #$00			cpx 	#0
.1549	10 32		bpl $157d			bpl 	_FNError
.154b	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.154c	29 7f		and #$7f			and 	#$7F
.154e	aa		tax				tax
.154f	98		tya				tya
.1550	09 80		ora #$80			ora 	#$80
.1552	a8		tay				tay
.1553	20 fe 13	jsr $13fe			jsr 	FindVariable				; does it already exist ?
.1556	90 25		bcc $157d			bcc 	_FNError 					; no.
.1558	20 f3 1b	jsr $1bf3			jsr 	STRMakeOffset 				; convert to a relative address.
.155b	c9 00		cmp #$00			cmp 	#0 							; fix up.
.155d	d0 01		bne $1560			bne 	_FNNoBorrow
.155f	88		dey				dey
.1560					_FNNoBorrow:
.1560	3a		dec a				dec 	a
.1561	5a		phy				phy 								; save location of routine on stack.
.1562	48		pha				pha
.1563	da		phx				phx
.1564	20 44 13	jsr $1344			jsr 	CompileExpressionAt0
.1567	20 98 10	jsr $1098			jsr 	CheckNextRParen
.156a	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.156c	20 59 10	jsr $1059			jsr 	WriteCodeByte
.156f	68		pla				pla
.1570	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1573	68		pla				pla
.1574	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1577	68		pla				pla
.1578	20 59 10	jsr $1059			jsr 	WriteCodeByte
.157b	18		clc				clc
.157c	60		rts				rts
.157d					_FNError:
.157d	4c 20 1f	jmp $1f20		jmp	ErrorV_value
.1580					CommandTables:
>1580	07 cb 00 03 82 1a 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>1587	07 89 00 03 89 1a 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>158e	07 8d 00 03 7c 1a 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>1595	07 88 00 03 04 1b 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>159c	07 85 00 03 e4 1a 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>15a3	07 84 00 04 f8 1a 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>15aa	07 99 00 03 85 1c 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>15b1	07 98 00 04 85 1c 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>15b8	07 8f 00 03 90 1d 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>15bf	07 81 00 03 cb 14 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>15c6	07 82 00 03 fd 1b 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>15cd	07 a1 00 03 f5 19 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>15d4	07 83 00 03 f9 11 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>15db	07 87 00 03 ce 1c 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>15e2	07 86 00 03 8c 12 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>15e9	07 96 00 03 15 12 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>15f0	07 8b 00 e3 ac 1a 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>15f7	08 92 00 ea e3 5c 1e 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>15ff	09 91 00 e1 a9 03 29 1c			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>1607	06
>1608	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>160f	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>1616	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>161c	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>1623	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>162a	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>1631	07 9d 00 e3 8b 1e 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>1638	0a 9f 00 ea e3 9e 1e 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>1640	c6 06
>1642	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>1648	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>164f	0a ce 92 e3 72 19 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>1657	ad 06
>1659	0a ce 8d e3 72 19 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>1661	ae 06
>1663	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>1669	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>1671	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>1678	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>167f	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>1687	06
>1688	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>1690	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>1698	9a 06
>169a	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>16a2	9b 06
>16a4	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>16ac	9c 06
>16ae	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>16b6	06
>16b7	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>16be	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>16c6	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>16ce	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>16d6	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>16de	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>16e6	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>16ee	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>16f6	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>16fe	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>1706	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>170e	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>1715	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>171d	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>1725	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>172d	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>1735	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>173d	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>1745	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>174d	00						.byte 	0
.174e					UnaryTables:
>174e	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>1755	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>175d	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>1764	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>176b	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>1772	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>1779	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>1781	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>1788	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>1790	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>1798	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>17a0	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>17a8	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>17b0	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>17b8	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>17bf	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>17c6	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>17cd	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>17d4	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>17db	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>17e2	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>17ea	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>17f2	0b ca 00 8f ae 03 72 19			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>17fa	91 bd 07
>17fd	07 a8 00 03 91 19 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>1804	07 a5 00 03 41 15 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>180b	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>1812	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>1819	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>1821	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>1829	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>1830	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>1837	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>183e	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>1846	06
>1847	00						.byte 	0
.1848					GeneratorProcess:
.1848	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.184a	84 2d		sty $2d				sty 	zTemp0+1
.184c	85 2e		sta $2e				sta 	zTemp1 						; first match token
.184e	64 2f		stz $2f				stz 	zTemp1+1
.1850	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.1852	d0 05		bne $1859			bne 	_GPNotShifted
.1854	20 b4 19	jsr $19b4			jsr 	GetNext 					; get the shifted token
.1857	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.1859					_GPNotShifted:
.1859					_GPSearch:
.1859	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.185b	18		clc				clc
.185c	f0 2f		beq $188d			beq 	_GPExit
.185e	a0 01		ldy #$01			ldy 	#1 							; tokens match
.1860	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1862	c5 2e		cmp $2e				cmp 	zTemp1
.1864	d0 09		bne $186f			bne 	_GPNext
.1866	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.1868	f0 12		beq $187c			beq 	_GPFound
.186a	c8		iny				iny 								; check match.
.186b	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.186d	f0 0d		beq $187c			beq 	_GPFound
.186f					_GPNext:
.186f	18		clc				clc 								; follow to next
.1870	a5 2c		lda $2c				lda 	zTemp0
.1872	72 2c		adc ($2c)			adc 	(zTemp0)
.1874	85 2c		sta $2c				sta 	zTemp0
.1876	90 e1		bcc $1859			bcc 	_GPSearch
.1878	e6 2d		inc $2d				inc 	zTemp0+1
.187a	80 dd		bra $1859			bra 	_GPSearch
.187c					_GPFound:
.187c	18		clc				clc 								; skip to action bytes
.187d	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.187f	69 03		adc #$03			adc 	#3
.1881	85 2c		sta $2c				sta 	zTemp0
.1883	90 02		bcc $1887			bcc 	_GPNoCarry
.1885	e6 2d		inc $2d				inc 	zTemp0+1
.1887					_GPNoCarry:
.1887					_GPLoop:
.1887	20 8e 18	jsr $188e			jsr 	GeneratorExecute 			; execute one command
.188a	90 fb		bcc $1887			bcc 	_GPLoop 					; go back if not completed.
.188c	38		sec				sec 								; return with CS.
.188d					_GPExit:
.188d	60		rts				rts
.188e					GeneratorExecute:
.188e	20 39 19	jsr $1939			jsr 	_GEFetchZTemp0 				; get next.
.1891	48		pha				pha 								; split into 2 nibbles
.1892	4a		lsr a				lsr 	a
.1893	4a		lsr a				lsr 	a
.1894	4a		lsr a				lsr		a
.1895	4a		lsr a				lsr 	a
.1896	20 a0 18	jsr $18a0			jsr 	_GEExecuteNibble 			; MSB first
.1899	68		pla				pla
.189a	b0 03		bcs $189f			bcs 	_GEHaveCompleted
.189c	20 a0 18	jsr $18a0			jsr 	_GEExecuteNibble 			; LSB second
.189f					_GEHaveCompleted:
.189f	60		rts				rts
.18a0					_GEExecuteNibble:
.18a0	29 0f		and #$0f			and 	#$0F
.18a2	0a		asl a				asl 	a
.18a3	aa		tax				tax
.18a4	7c a7 18	jmp ($18a7,x)			jmp 	(_GEExecuteVectors,x)
.18a7					_GEExecuteVectors:
>18a7	c7 18						.word 	_GEXNop 					; 0  (no operation)
>18a9	cf 18						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>18ab	c9 18						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>18ad	1c 19						.word 	_GEXExecute 				; 3  (run arbitrary code)
>18af	0f 19						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>18b1	c7 18						.word 	_GEXNop 					; 5
>18b3	d6 18						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>18b5	da 18						.word 	_GEXExitString 				; 7  exit return string type
>18b7	de 18						.word 	_GEXLParam 					; 8  check ( follows
>18b9	e2 18						.word 	_GEXRParam 					; 9  check ) follows
>18bb	e6 18						.word 	_GEXComma					; A  check , follows
>18bd	c7 18						.word 	_GEXNop 					; B
>18bf	c7 18						.word 	_GEXNop 					; C
>18c1	c7 18						.word 	_GEXNop 					; D
>18c3	f6 18						.word 	_GEXNumber 					; E  compile get any number
>18c5	01 19						.word 	_GEXString 					; F  compile get any string
.18c7					_GEXNop:
.18c7	18		clc				clc
.18c8	60		rts				rts
.18c9					_GEXToken2:
.18c9	20 39 19	jsr $1939			jsr 	_GEFetchZTemp0
.18cc	20 59 10	jsr $1059			jsr 	WriteCodeByte
.18cf					_GEXToken1:
.18cf	20 39 19	jsr $1939			jsr 	_GEFetchZTemp0
.18d2	20 59 10	jsr $1059			jsr 	WriteCodeByte
.18d5	60		rts				rts
.18d6					_GEXExitNumber:
.18d6	a9 00		lda #$00			lda 	#NSSIFloat
.18d8	38		sec				sec
.18d9	60		rts				rts
.18da					_GEXExitString:
.18da	a9 40		lda #$40			lda 	#NSSString
.18dc	38		sec				sec
.18dd	60		rts				rts
.18de					_GEXLParam:
.18de	a9 28		lda #$28			lda 	#"("
.18e0	80 06		bra $18e8			bra 	_GEXCheck
.18e2					_GEXRParam:
.18e2	a9 29		lda #$29			lda 	#")"
.18e4	80 02		bra $18e8			bra 	_GEXCheck
.18e6					_GEXComma:
.18e6	a9 2c		lda #$2c			lda 	#","
.18e8					_GEXCheck:
.18e8	85 30		sta $30				sta 	zTemp2 						; save match
.18ea	20 bf 19	jsr $19bf			jsr 	GetNextNonSpace 			; get next skipping spaces
.18ed	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.18ef	d0 02		bne $18f3			bne 	_GEXSyntax
.18f1	18		clc				clc
.18f2	60		rts				rts
.18f3					_GEXSyntax:
.18f3	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.18f6					_GEXNumber:
.18f6	20 42 19	jsr $1942			jsr 	GEXCompileExpression 		; compile expression
.18f9	29 40		and #$40			and 	#NSSTypeMask
.18fb	c9 00		cmp #$00			cmp  	#NSSIFloat
.18fd	d0 0d		bne $190c			bne 	_GEXType
.18ff	18		clc				clc
.1900	60		rts				rts
.1901					_GEXString:
.1901	20 42 19	jsr $1942			jsr 	GEXCompileExpression 		; compile expression
.1904	29 40		and #$40			and 	#NSSTypeMask
.1906	c9 40		cmp #$40			cmp  	#NSSString
.1908	d0 02		bne $190c			bne 	_GEXType
.190a	18		clc				clc
.190b	60		rts				rts
.190c					_GEXType:
.190c	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.190f					_GEXChannelExec:
.190f	20 52 19	jsr $1952			jsr 	ChannelPrefix 				; set up default
.1912	20 1c 19	jsr $191c			jsr 	_GEXExecute
.1915	08		php				php
.1916	20 6c 19	jsr $196c			jsr 	ChannelPostfix 				; replace default.
.1919	28		plp				plp
.191a	60		rts				rts
>191b	db						.byte 	$DB 						; causes a break in the emulator
.191c					_GEXExecute:
.191c	20 39 19	jsr $1939			jsr 	_GEFetchZTemp0 				; get vector
.191f	85 30		sta $30				sta 	zTemp2
.1921	20 39 19	jsr $1939			jsr 	_GEFetchZTemp0
.1924	85 31		sta $31				sta 	zTemp2+1
.1926	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.1928	da		phx				phx
.1929	a6 2d		ldx $2d				ldx 	zTemp0+1
.192b	da		phx				phx
.192c	20 36 19	jsr $1936			jsr 	_GECallZTemp2 				; execute code
.192f	fa		plx				plx 								; recover generation exec
.1930	86 2d		stx $2d				stx 	zTemp0+1
.1932	fa		plx				plx
.1933	86 2c		stx $2c				stx 	zTemp0
.1935	60		rts				rts
.1936					_GECallZTemp2:
.1936	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.1939					_GEFetchZTemp0:
.1939	b2 2c		lda ($2c)			lda 	(zTemp0)
.193b	e6 2c		inc $2c				inc 	zTemp0
.193d	d0 02		bne $1941			bne 	_GEFZ0Skip
.193f	e6 2d		inc $2d				inc 	zTemp0+1
.1941					_GEFZ0Skip:
.1941	60		rts				rts
.1942					GEXCompileExpression:
.1942	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.1944	da		phx				phx
.1945	a6 2d		ldx $2d				ldx 	zTemp0+1
.1947	da		phx				phx
.1948	20 44 13	jsr $1344			jsr 	CompileExpressionAt0 		; compile expression.
.194b	fa		plx				plx 								; recover generation exec
.194c	86 2d		stx $2d				stx 	zTemp0+1
.194e	fa		plx				plx
.194f	86 2c		stx $2c				stx 	zTemp0
.1951	60		rts				rts
.1952					ChannelPrefix:
.1952	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.1954	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1957	20 42 19	jsr $1942			jsr 	GEXCompileExpression 		; channel #
.195a	29 40		and #$40			and 	#NSSTypeMask
.195c	c9 00		cmp #$00			cmp 	#NSSIFloat
.195e	d0 09		bne $1969			bne 	_CPXType
.1960	20 94 10	jsr $1094			jsr 	CheckNextComma 				; check , follows.
.1963	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.1965	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1968	60		rts				rts
.1969					_CPXType:
.1969	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.196c					ChannelPostfix:
.196c	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.196e	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1971	60		rts				rts
.1972					OptionalParameterCompile:
.1972	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; what follows.
.1975	c9 2c		cmp #$2c			cmp 	#","
.1977	d0 0e		bne $1987			bne 	_MidDefault
.1979	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume ,
.197c	20 44 13	jsr $1344			jsr 	CompileExpressionAt0
.197f	29 40		and #$40			and 	#NSSTypeMask
.1981	c9 00		cmp #$00			cmp 	#NSSIFloat
.1983	d0 09		bne $198e			bne 	MidFailType
.1985	80 05		bra $198c			bra 	_MidComplete
.1987					_MidDefault:
.1987	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1989	20 51 11	jsr $1151			jsr 	PushIntegerA
.198c					_MidComplete:
.198c	18		clc				clc
.198d	60		rts				rts
.198e					MidFailType:
.198e	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.1991					NotUnaryCompile:
.1991	ad f9 13	lda $13f9			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1994	20 46 13	jsr $1346			jsr 	CompileExpressionAtA 		; evaluate at that level
.1997	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1999	c9 00		cmp #$00			cmp 	#NSSIFloat
.199b	d0 f1		bne $198e			bne 	MidFailType
.199d	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.199f	20 59 10	jsr $1059			jsr 	WriteCodeByte
.19a2	60		rts				rts
.19a3					LookNext:
.19a3	b2 22		lda ($22)			lda 	(srcPtr)
.19a5	60		rts				rts
.19a6					LookNextNonSpace:
.19a6	b2 22		lda ($22)			lda 	(srcPtr)
.19a8	c9 20		cmp #$20			cmp		#' '
.19aa	f0 03		beq $19af			beq 	_LNNSkip
.19ac	c9 00		cmp #$00			cmp 	#0
.19ae	60		rts				rts
.19af					_LNNSkip:
.19af	20 b4 19	jsr $19b4			jsr 	GetNext
.19b2	80 f2		bra $19a6			bra 	LookNextNonSpace
.19b4					GetNext:
.19b4	b2 22		lda ($22)			lda 	(srcPtr) 					; get next
.19b6	e6 22		inc $22				inc 	srcPtr
.19b8	d0 02		bne $19bc			bne 	_GNSkip
.19ba	e6 23		inc $23				inc 	srcPtr+1
.19bc					_GNSkip:
.19bc	c9 00		cmp #$00			cmp 	#0
.19be	60		rts				rts
.19bf					GetNextNonSpace:
.19bf	20 b4 19	jsr $19b4			jsr 	GetNext
.19c2	c9 20		cmp #$20			cmp 	#' '
.19c4	f0 f9		beq $19bf			beq 	GetNextNonSpace
.19c6	c9 00		cmp #$00			cmp 	#0
.19c8	60		rts				rts
.19c9					CharIsDigit:
.19c9	c9 30		cmp #$30			cmp 	#"0"
.19cb	90 06		bcc $19d3			bcc 	CCFalse
.19cd	c9 3a		cmp #$3a			cmp 	#"9"+1
.19cf	b0 02		bcs $19d3			bcs 	CCFalse
.19d1					CCTrue:
.19d1	38		sec				sec
.19d2	60		rts				rts
.19d3					CCFalse:
.19d3	18		clc				clc
.19d4	60		rts				rts
.19d5					CharIsAlpha:
.19d5	c9 41		cmp #$41			cmp 	#"A"
.19d7	90 fa		bcc $19d3			bcc 	CCFalse
.19d9	c9 5b		cmp #$5b			cmp 	#"Z"+1
.19db	b0 f6		bcs $19d3			bcs 	CCFalse
.19dd	80 f2		bra $19d1			bra 	CCTrue
.19df					ConvertHexStyle:
.19df	38		sec				sec
.19e0	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.19e2	90 ef		bcc $19d3			bcc 	CCFalse
.19e4	c9 0a		cmp #$0a			cmp 	#9+1
.19e6	90 e9		bcc $19d1			bcc 	CCTrue
.19e8	38		sec				sec 								; shift into hex space A=>0 Z=>25
.19e9	e9 11		sbc #$11			sbc 	#"A"-"0"
.19eb	90 e6		bcc $19d3			bcc 	CCFalse
.19ed	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.19ef	b0 e2		bcs $19d3			bcs 	CCFalse
.19f1	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.19f3	80 dc		bra $19d1			bra 	CCTrue
.19f5					CommandGET:
.19f5	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; # follows ?
.19f8	c9 23		cmp #$23			cmp 	#"#"
.19fa	d0 0d		bne $1a09			bne 	CommandGetBody
.19fc	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume #
.19ff	20 52 19	jsr $1952			jsr 	ChannelPrefix 				; do it as GET#
.1a02	20 09 1a	jsr $1a09			jsr 	CommandGetBody
.1a05	20 6c 19	jsr $196c			jsr 	ChannelPostfix
.1a08	60		rts				rts
.1a09					CommandGetBody:
.1a09	20 bf 19	jsr $19bf			jsr 	GetNextNonSpace 			; get the first character
.1a0c	20 58 1d	jsr $1d58			jsr 	GetReferenceTerm 			; identify variable to assign to
.1a0f	48		pha				pha
.1a10	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1a12	c9 40		cmp #$40			cmp 	#NSSString
.1a14	d0 0b		bne $1a21			bne 	_CGType
.1a16	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1a18	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1a1b	38		sec				sec
.1a1c	68		pla				pla
.1a1d	20 0a 1d	jsr $1d0a			jsr		GetSetVariable
.1a20	60		rts				rts
.1a21					_CGType:
.1a21	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.1a24					ExtractVariableName:
.1a24	20 d5 19	jsr $19d5			jsr 	CharIsAlpha
.1a27	90 50		bcc $1a79			bcc 	_IVSyntax
.1a29	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.1a2b	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.1a2d	64 2f		stz $2f				stz 	zTemp1+1
.1a2f	20 a3 19	jsr $19a3			jsr 	LookNext 					; is there a second character ?
.1a32	20 d5 19	jsr $19d5			jsr 	CharIsAlpha  				; must be alphanumeric
.1a35	b0 05		bcs $1a3c			bcs 	_IVHasSecond
.1a37	20 c9 19	jsr $19c9			jsr 	CharIsDigit
.1a3a	90 07		bcc $1a43			bcc 	_IVCheckType
.1a3c					_IVHasSecond:
.1a3c	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.1a3e	85 2f		sta $2f				sta 	zTemp1+1
.1a40					_IVGetNextCheck:
.1a40	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume it
.1a43					_IVCheckType:
.1a43	20 a3 19	jsr $19a3			jsr 	LookNext					; check if string follows.
.1a46	20 d5 19	jsr $19d5			jsr 	CharIsAlpha
.1a49	b0 f5		bcs $1a40			bcs 	_IVGetNextCheck
.1a4b	20 c9 19	jsr $19c9			jsr 	CharIsDigit
.1a4e	b0 f0		bcs $1a40			bcs 	_IVGetNextCheck
.1a50	a2 40		ldx #$40			ldx 	#NSSString
.1a52	c9 24		cmp #$24			cmp 	#"$"
.1a54	f0 06		beq $1a5c			beq 	_IVHasType
.1a56	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.1a58	c9 25		cmp #$25			cmp 	#"%"
.1a5a	d0 08		bne $1a64			bne 	_IVCheckArray
.1a5c					_IVHasType:
.1a5c	8a		txa				txa 								; Or X into zTemp1
.1a5d	05 2e		ora $2e				ora 	zTemp1
.1a5f	85 2e		sta $2e				sta 	zTemp1
.1a61	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume it
.1a64					_IVCheckArray:
.1a64	20 a3 19	jsr $19a3			jsr 	LookNext 					; check if array follows
.1a67	c9 28		cmp #$28			cmp 	#"("
.1a69	d0 09		bne $1a74			bne 	_IVNotArray
.1a6b	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.1a6d	09 80		ora #$80			ora 	#NSSArray
.1a6f	85 2e		sta $2e				sta 	zTemp1
.1a71	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume it
.1a74					_IVNotArray:
.1a74	a6 2e		ldx $2e				ldx 	zTemp1
.1a76	a4 2f		ldy $2f				ldy 	zTemp1+1
.1a78	60		rts				rts
.1a79					_IVSyntax:
.1a79	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.1a7c					CommandGOSUB:
.1a7c	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1a7e	20 8f 1a	jsr $1a8f			jsr 	CompileBranchCommand
.1a81	60		rts				rts
.1a82					CommandGOAlt:
.1a82	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1a84	20 9e 10	jsr $109e			jsr 	CheckNextA
.1a87	80 00		bra $1a89			bra 	CommandGOTO
.1a89					CommandGOTO:
.1a89	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1a8b	20 8f 1a	jsr $1a8f			jsr 	CompileBranchCommand
.1a8e	60		rts				rts
.1a8f					CompileBranchCommand:
.1a8f	20 59 10	jsr $1059			jsr 	WriteCodeByte 				; write the command out.
.1a92	20 bf 19	jsr $19bf			jsr 	GetNextNonSpace
.1a95	20 60 1c	jsr $1c60			jsr 	ParseConstant 				; get constant into YA
.1a98	90 0f		bcc $1aa9			bcc 	_CBCSyntax
.1a9a	48		pha				pha
.1a9b	a9 ff		lda #$ff			lda 	#$FF 						; no address yet.
.1a9d	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1aa0	68		pla				pla 								; and compile the actual line number
.1aa1	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1aa4	98		tya				tya
.1aa5	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1aa8	60		rts				rts
.1aa9					_CBCSyntax:
.1aa9	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.1aac					CommandIF:
.1aac	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; what follows the tests ?
.1aaf	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1ab1	f0 0f		beq $1ac2			beq 	_CIGoto
.1ab3	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1ab5	20 9e 10	jsr $109e			jsr 	CheckNextA
.1ab8	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; THEN <number>
.1abb	20 c9 19	jsr $19c9			jsr 	CharIsDigit
.1abe	b0 05		bcs $1ac5			bcs 	_CIGoto2
.1ac0	80 09		bra $1acb			bra 	CompileGotoEOL
.1ac2					_CIGoto:
.1ac2	20 b4 19	jsr $19b4			jsr 	GetNext
.1ac5					_CIGoto2:
.1ac5	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1ac7	20 8f 1a	jsr $1a8f			jsr 	CompileBranchCommand
.1aca	60		rts				rts
.1acb					CompileGotoEOL:
.1acb	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.1acd	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1ad0	a9 ff		lda #$ff			lda 	#$FF
.1ad2	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1ad5	20 6a 1b	jsr $1b6a			jsr 	GetLineNumber 				; Get the current line number => YA
.1ad8	1a		inc a				inc 	a 							; and branch to +1
.1ad9	d0 01		bne $1adc			bne 	_CGENoCarry
.1adb	c8		iny				iny
.1adc					_CGENoCarry:
.1adc	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1adf	98		tya				tya
.1ae0	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1ae3	60		rts				rts
.1ae4					CommandINPUT:
.1ae4	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; check for "
.1ae7	c9 22		cmp #$22			cmp 	#'"'
.1ae9	d0 0d		bne $1af8			bne 	CommandINPUTStream
.1aeb	20 44 13	jsr $1344			jsr 	CompileExpressionAt0
.1aee	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1af0	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1af3	a9 2c		lda #$2c			lda 	#","
.1af5	20 94 10	jsr $1094			jsr 	CheckNextComma
.1af8					CommandINPUTStream:
.1af8	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1afa	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1afd	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.1aff	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1b01	4c d2 1c	jmp $1cd2			jmp 	CommandReadInputCommon
.1b04					CommandLET:
.1b04	20 bf 19	jsr $19bf			jsr 	GetNextNonSpace 			; get the first character
.1b07					CommandLETHaveFirst:
.1b07	20 58 1d	jsr $1d58			jsr 	GetReferenceTerm 			; identify variable to assign to
.1b0a	da		phx				phx 								; save target on the stack.
.1b0b	5a		phy				phy
.1b0c	48		pha				pha
.1b0d	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.1b0f	20 9e 10	jsr $109e			jsr 	CheckNextA
.1b12	20 44 13	jsr $1344			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1b15	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.1b17	68		pla				pla 								; get type of assignment
.1b18	48		pha				pha
.1b19	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.1b1b	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.1b1d	d0 17		bne $1b36			bne 	_CLType
.1b1f	68		pla				pla 								; restore and compile save code
.1b20	7a		ply				ply
.1b21	fa		plx				plx
.1b22	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.1b24	f0 05		beq $1b2b			beq 	_CLTIString
.1b26	38		sec				sec
.1b27	20 0a 1d	jsr $1d0a			jsr		GetSetVariable
.1b2a	60		rts				rts
.1b2b					_CLTIString:
.1b2b	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.1b2d	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1b30	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.1b32	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1b35	60		rts				rts
.1b36					_CLType:
.1b36	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.1b39					ReadNextLine:
.1b39	20 38 15	jsr $1538			jsr 	APIIGet 					; check offset is not zero.
.1b3c	85 2c		sta $2c				sta 	zTemp0
.1b3e	20 38 15	jsr $1538			jsr 	APIIGet
.1b41	05 2c		ora $2c				ora 	zTemp0
.1b43	d0 02		bne $1b47			bne 	_RNLBody
.1b45	18		clc				clc
.1b46	60		rts				rts						; end of file.
.1b47					_RNLBody:
.1b47	20 38 15	jsr $1538			jsr 	APIIGet 					; read and save line number
.1b4a	8d 00 05	sta $0500			sta 	currentLineNumber
.1b4d	20 38 15	jsr $1538			jsr 	APIIGet
.1b50	8d 01 05	sta $0501			sta 	currentLineNumber+1
.1b53	a2 00		ldx #$00			ldx 	#0 							; read line into buffer
.1b55					_RNLRead:
.1b55	20 38 15	jsr $1538			jsr 	APIIGet
.1b58	9d 00 04	sta $0400,x			sta 	sourceBuffer,x
.1b5b	e8		inx				inx
.1b5c	c9 00		cmp #$00			cmp 	#0
.1b5e	d0 f5		bne $1b55			bne 	_RNLRead
.1b60	a9 00		lda #$00			lda 	#((sourceBuffer) & $FF)
.1b62	85 22		sta $22				sta 	0+srcPtr
.1b64	a9 04		lda #$04			lda 	#((sourceBuffer) >> 8) & $FF
.1b66	85 23		sta $23				sta 	1+srcPtr
.1b68	38		sec				sec
.1b69	60		rts				rts
.1b6a					GetLineNumber:
.1b6a	ac 01 05	ldy $0501			ldy 	currentLineNumber+1
.1b6d	ad 00 05	lda $0500			lda 	currentLineNumber
.1b70	60		rts				rts
.1b71					STRMarkLine:
.1b71	48		pha				pha
.1b72	38		sec				sec 								; allocate 5 bytes (line #, page+address)
.1b73	ad 0f 06	lda $060f			lda 	lineNumberTable 			; and copy to zTemp0
.1b76	e9 05		sbc #$05			sbc 	#5
.1b78	8d 0f 06	sta $060f			sta 	lineNumberTable
.1b7b	85 2c		sta $2c				sta 	zTemp0
.1b7d	ad 10 06	lda $0610			lda 	lineNumberTable+1
.1b80	e9 00		sbc #$00			sbc 	#0
.1b82	8d 10 06	sta $0610			sta 	lineNumberTable+1
.1b85	85 2d		sta $2d				sta 	zTemp0+1
.1b87	68		pla				pla
.1b88	92 2c		sta ($2c)			sta 	(zTemp0) 					; save it in +0,+1
.1b8a	98		tya				tya
.1b8b	a0 01		ldy #$01			ldy 	#1
.1b8d	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b8f	a5 2b		lda $2b				lda 	objPage 					; and page# in +2
.1b91	c8		iny				iny
.1b92	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b94	a5 29		lda $29				lda 	objPtr 						; save current address in +3,+4
.1b96	c8		iny				iny
.1b97	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b99	a5 2a		lda $2a				lda 	objPtr+1
.1b9b	c8		iny				iny
.1b9c	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b9e	60		rts				rts
.1b9f					STRFindLine:
.1b9f	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.1ba1	84 2d		sty $2d				sty 	zTemp0+1
.1ba3	ad 08 06	lda $0608			lda 	compilerEndHigh 			; work backwards through table
.1ba6	85 2f		sta $2f				sta 	zTemp1+1
.1ba8	64 2e		stz $2e				stz 	zTemp1
.1baa					_STRSearch:
.1baa	20 e5 1b	jsr $1be5			jsr 	_STRPrevLine 				; look at previous record.
.1bad	a0 01		ldy #$01			ldy 	#1
.1baf	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.1bb1	c5 2c		cmp $2c				cmp 	zTemp0
.1bb3	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1bb5	e5 2d		sbc $2d				sbc 	zTemp0+1
.1bb7	b0 0b		bcs $1bc4			bcs 	_STRFound 					; >=
.1bb9					_STRNext:
.1bb9	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1bbb	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1bbd	c9 ff		cmp #$ff			cmp 	#$FF
.1bbf	d0 e9		bne $1baa			bne 	_STRSearch
.1bc1	4c 87 1f	jmp $1f87		jmp	ErrorV_internal
.1bc4					_STRFound:
.1bc4	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1bc6	45 2c		eor $2c				eor 	zTemp0
.1bc8	d0 06		bne $1bd0			bne 	_STRDifferent
.1bca	b2 2e		lda ($2e)			lda 	(zTemp1)
.1bcc	45 2c		eor $2c				eor 	zTemp0
.1bce	f0 02		beq $1bd2			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1bd0					_STRDifferent:
.1bd0	a9 ff		lda #$ff			lda 	#$FF
.1bd2					_STROut:
.1bd2	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1bd3	69 ff		adc #$ff			adc 	#255
.1bd5	08		php				php
.1bd6	c8		iny				iny 								; page into X
.1bd7	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1bd9	aa		tax				tax
.1bda	c8		iny				iny 								; address into YA
.1bdb	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1bdd	48		pha				pha
.1bde	c8		iny				iny
.1bdf	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1be1	a8		tay				tay
.1be2	68		pla				pla
.1be3	28		plp				plp
.1be4	60		rts				rts
.1be5					_STRPrevLine:
.1be5	38		sec				sec 								; move backwards one entry.
.1be6	a5 2e		lda $2e				lda 	zTemp1
.1be8	e9 05		sbc #$05			sbc 	#5
.1bea	85 2e		sta $2e				sta 	zTemp1
.1bec	a5 2f		lda $2f				lda 	zTemp1+1
.1bee	e9 00		sbc #$00			sbc 	#0
.1bf0	85 2f		sta $2f				sta 	zTemp1+1
.1bf2	60		rts				rts
.1bf3					STRMakeOffset:
.1bf3	18		clc				clc 								; borrow 1
.1bf4	e5 29		sbc $29				sbc 	objPtr
.1bf6	48		pha				pha
.1bf7	98		tya				tya
.1bf8	e5 2a		sbc $2a				sbc 	objPtr+1
.1bfa	a8		tay				tay
.1bfb	68		pla				pla
.1bfc	60		rts				rts
.1bfd					CommandNEXT:
.1bfd	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1c00	20 d5 19	jsr $19d5			jsr 	CharIsAlpha 				; if not alpha , error
.1c03	90 0c		bcc $1c11			bcc 	_CNNoReferenceGiven
.1c05	20 b4 19	jsr $19b4			jsr 	GetNext
.1c08	20 58 1d	jsr $1d58			jsr 	GetReferenceTerm 			; figure out the reference.
.1c0b	8a		txa				txa 								; reference in YA
.1c0c	20 3e 11	jsr $113e			jsr 	PushIntegerYA 				; write it out.
.1c0f	80 06		bra $1c17			bra 	_CNParametersDone
.1c11					_CNNoReferenceGiven:
.1c11	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1c13	a8		tay				tay
.1c14	20 3e 11	jsr $113e			jsr 	PushIntegerYA 				; write it out.
.1c17					_CNParametersDone:
.1c17	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1c19	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1c1c	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; look for ,
.1c1f	c9 2c		cmp #$2c			cmp 	#","
.1c21	d0 05		bne $1c28			bne 	_CNExit
.1c23	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume ,
.1c26	80 d5		bra $1bfd			bra 	CommandNEXT 				; and go round.
.1c28					_CNExit:
.1c28	60		rts				rts
.1c29					CommandON:
.1c29	20 bf 19	jsr $19bf			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1c2c	48		pha				pha 								; save on stack
.1c2d	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1c2f	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1c31	f0 09		beq $1c3c			beq 	_COCreateLoop
.1c33	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1c35	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1c37	f0 03		beq $1c3c			beq 	_COCreateLoop
.1c39	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.1c3c					_COCreateLoop:
.1c3c	8a		txa				txa 								; compile a goto/gosub somewhere
.1c3d	da		phx				phx
.1c3e	20 8f 1a	jsr $1a8f			jsr 	CompileBranchCommand
.1c41	fa		plx				plx
.1c42	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace			; ',' follows
.1c45	c9 2c		cmp #$2c			cmp 	#","
.1c47	d0 0a		bne $1c53			bne 	_COComplete 				; if so, more line numbers
.1c49	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1c4b	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1c4e	20 b4 19	jsr $19b4			jsr 	GetNext
.1c51	80 e9		bra $1c3c			bra 	_COCreateLoop
.1c53					_COComplete:
.1c53	68		pla				pla 								; throw GOTO/GOSUB
.1c54	60		rts				rts
.1c55					APIOOpen:
.1c55					APIORewind:
.1c55	64 2b		stz $2b				stz 	objPage
.1c57	a9 00		lda #$00			lda 	#((PCodeStart) & $FF)
.1c59	85 29		sta $29				sta 	0+objPtr
.1c5b	a9 40		lda #$40			lda 	#((PCodeStart) >> 8) & $FF
.1c5d	85 2a		sta $2a				sta 	1+objPtr
.1c5f	60		rts				rts
.1c60					ParseConstant:
.1c60	a2 00		ldx #$00			ldx 	#0
.1c62	20 53 24	jsr $2453			jsr 	FloatEncodeStart 			; send first
.1c65					_ParseLoop:
.1c65	20 a3 19	jsr $19a3			jsr 	LookNext 					; send subsequent
.1c68	20 56 24	jsr $2456			jsr 	FloatEncodeContinue
.1c6b	90 05		bcc $1c72			bcc 	_ParseDone
.1c6d	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume it
.1c70	80 f3		bra $1c65			bra 	_ParseLoop
.1c72					_ParseDone:
.1c72	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1c74	29 80		and #$80			and 	#$80
.1c76	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.1c78	15 56		ora $56,x			ora 	NSMantissa2,x
.1c7a	15 62		ora $62,x			ora 	NSMantissa3,x
.1c7c	18		clc				clc
.1c7d	d0 05		bne $1c84			bne 	_ParseExit 					; exit with CC if need float to compile
.1c7f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.1c81	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.1c83	38		sec				sec
.1c84					_ParseExit:
.1c84	60		rts				rts
.1c85					CommandPRINT:
.1c85	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace			; what follows ?
.1c88	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1c8a	f0 1f		beq $1cab			beq 	_CPCheckEnd
.1c8c	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1c8e	f0 16		beq $1ca6			beq 	_CPTabCheckEnd
.1c90	20 c2 1c	jsr $1cc2			jsr 	_CPAtEnd 					; check for : and EOL
.1c93	b0 22		bcs $1cb7			bcs 	_CPExitCR 					; exit with CR
.1c95	20 44 13	jsr $1344			jsr 	CompileExpressionAt0 		; so it is something to print
.1c98	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1c9a	29 40		and #$40			and 	#NSSString 					; if string
.1c9c	d0 02		bne $1ca0			bne 	_CPOut
.1c9e	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1ca0					_CPOut:
.1ca0	8a		txa				txa 								; print that thing
.1ca1	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1ca4	80 df		bra $1c85			bra 	CommandPRINT 				; and loop round/
.1ca6					_CPTabCheckEnd:
.1ca6	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1ca8	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1cab					_CPCheckEnd:
.1cab	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume it.
.1cae	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; what follows ?
.1cb1	20 c2 1c	jsr $1cc2			jsr 	_CPAtEnd 					; reached end
.1cb4	90 cf		bcc $1c85			bcc 	CommandPRINT 				; no, loop back
.1cb6	60		rts				rts
.1cb7					_CPExitCR:
.1cb7	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1cb9	20 51 11	jsr $1151			jsr 	PushIntegerA
.1cbc	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1cbe	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1cc1	60		rts				rts
.1cc2					_CPAtEnd:
.1cc2	c9 00		cmp #$00			cmp 	#0
.1cc4	f0 06		beq $1ccc			beq 	_CPIsEnd
.1cc6	c9 3a		cmp #$3a			cmp 	#":"
.1cc8	f0 02		beq $1ccc			beq 	_CPIsEnd
.1cca	18		clc				clc
.1ccb	60		rts				rts
.1ccc					_CPIsEnd:
.1ccc	38		sec				sec
.1ccd	60		rts				rts
.1cce					CommandREAD:
.1cce	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1cd0	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1cd2					CommandReadInputCommon:
.1cd2	8e 0d 06	stx $060d			stx 	numberPCode
.1cd5	8c 0e 06	sty $060e			sty 	stringPCode
.1cd8					_CRLoop:
.1cd8	20 bf 19	jsr $19bf			jsr 	GetNextNonSpace 			; first char of identifier
.1cdb	20 d5 19	jsr $19d5			jsr 	CharIsAlpha 				; check A-Z
.1cde	90 27		bcc $1d07			bcc 	_CRSyntax
.1ce0	20 58 1d	jsr $1d58			jsr 	GetReferenceTerm 			; get the variable.
.1ce3	48		pha				pha 								; save type.
.1ce4	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1ce6	c9 40		cmp #$40			cmp 	#NSSString
.1ce8	f0 05		beq $1cef			beq 	_CRString
.1cea	ad 0d 06	lda $060d			lda 	numberPCode 				; output read/input
.1ced	80 03		bra $1cf2			bra 	_CRHaveType
.1cef					_CRString:
.1cef	ad 0e 06	lda $060e			lda 	stringPCode					; output read$/input$
.1cf2					_CRHaveType:
.1cf2	20 59 10	jsr $1059			jsr 	WriteCodeByte 				; so we have one typed data item.
.1cf5	68		pla				pla 								; restore type
.1cf6	38		sec				sec  								; write update code.
.1cf7	20 0a 1d	jsr $1d0a			jsr 	GetSetVariable
.1cfa	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; , follows ?
.1cfd	c9 2c		cmp #$2c			cmp 	#","
.1cff	d0 05		bne $1d06			bne 	_CRExit 					; if not, end of READ.
.1d01	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume comma
.1d04	80 d2		bra $1cd8			bra 	_CRLoop 					; keep going
.1d06					_CRExit:
.1d06	60		rts				rts
.1d07					_CRSyntax:
.1d07	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.060d					numberPCode:
>060d							.fill 	1
.060e					stringPCode:
>060e							.fill 	1
.1d0a					GetSetVariable:
.1d0a	08		php				php 								; save direction on stack
.1d0b	c0 00		cpy #$00			cpy 	#$00
.1d0d	30 21		bmi $1d30			bmi 	_GSVReadWriteSpecial
.1d0f	c9 00		cmp #$00			cmp 	#$00
.1d11	30 33		bmi $1d46			bmi 	_GSVArray
.1d13	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1d15	4a		lsr a				lsr 	a 							; divide by 2
.1d16	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1d18	28		plp				plp
.1d19	90 02		bcc $1d1d			bcc 	_GSVNotWrite
.1d1b	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1d1d					_GSVNotWrite:
.1d1d	85 2c		sta $2c				sta 	zTemp0
.1d1f	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1d20	4a		lsr a				lsr 	a
.1d21	a8		tay				tay
.1d22	8a		txa				txa
.1d23	6a		ror a				ror 	a
.1d24	aa		tax				tax
.1d25	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1d26	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.1d28	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1d2b	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1d2c	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1d2f	60		rts				rts
.1d30					_GSVReadWriteSpecial:
.1d30	28		plp				plp
.1d31	b0 10		bcs $1d43			bcs 	_GSVSyntax
.1d33	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1d35	f0 06		beq $1d3d			beq 	_GSVRWString
.1d37	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1d39	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1d3c	60		rts				rts
.1d3d					_GSVRWString:
.1d3d	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1d3f	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1d42	60		rts				rts
.1d43					_GSVSyntax:
.1d43	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.1d46					_GSVArray:
.1d46	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1d48	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1d49	4a		lsr a				lsr 	a
.1d4a	4a		lsr a				lsr 	a
.1d4b	4a		lsr a				lsr 	a
.1d4c	4a		lsr a				lsr 	a
.1d4d	28		plp				plp 								; if writing array then set bit 2.
.1d4e	90 02		bcc $1d52			bcc 	_GSVANotWrite
.1d50	09 04		ora #$04			ora 	#4
.1d52					_GSVANotWrite:
.1d52	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1d54	20 59 10	jsr $1059			jsr 	WriteCodeByte 				; and write it out
.1d57	60		rts				rts
.1d58					GetReferenceTerm:
.1d58	20 24 1a	jsr $1a24			jsr 	ExtractVariableName 		; get name & type info
.1d5b	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1d5d	30 10		bmi $1d6f			bmi 	_GRTArray
.1d5f	da		phx				phx 								; save type on stack
.1d60	20 fe 13	jsr $13fe			jsr 	FindVariable 				; find it
.1d63	b0 06		bcs $1d6b			bcs 	_GRTNoCreate 				; create if required.
.1d65	20 83 11	jsr $1183			jsr 	CreateVariableRecord 		; create a variable.
.1d68	20 dd 11	jsr $11dd			jsr 	AllocateBytesForType 		; allocate memory for it
.1d6b					_GRTNoCreate:
.1d6b	68		pla				pla 								; get type back, strip out type information.
.1d6c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1d6e	60		rts				rts
.1d6f					_GRTArray:
.1d6f	da		phx				phx 								; save type information
.1d70	20 fe 13	jsr $13fe			jsr 	FindVariable 				; read its data, the base address in YX
.1d73	90 18		bcc $1d8d			bcc 	_GRTUndeclared 				; undeclared array.
.1d75	da		phx				phx 								; save base address
.1d76	5a		phy				phy
.1d77	20 d4 12	jsr $12d4			jsr 	OutputIndexGroup 			; create an index group and generate them
.1d7a	7a		ply				ply 								; get the array base address into YX
.1d7b	fa		plx				plx
.1d7c	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1d7e	18		clc				clc
.1d7f	20 0a 1d	jsr $1d0a			jsr 	GetSetVariable 				; load the address of the array structure.
.1d82	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1d84	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1d87	68		pla				pla 								; and the type data into A
.1d88	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1d8a	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1d8c	60		rts				rts
.1d8d					_GRTUndeclared:
.1d8d	4c e4 1f	jmp $1fe4		jmp	ErrorV_undeclared
.1d90					CommandREM:
.1d90	20 a3 19	jsr $19a3			jsr 	LookNext
.1d93	f0 05		beq $1d9a			beq 	_CRExit
.1d95	20 b4 19	jsr $19b4			jsr 	GetNext
.1d98	80 f6		bra $1d90			bra 	CommandREM
.1d9a					_CRExit:
.1d9a	60		rts				rts
.1d9b					STRReset:
.1d9b	ad 07 06	lda $0607			lda	 	compilerStartHigh 			; set up the two table pointers
.1d9e	8d 12 06	sta $0612			sta 	variableListEnd+1
.1da1	9c 11 06	stz $0611			stz 	variableListEnd
.1da4	ad 08 06	lda $0608			lda 	compilerEndHigh
.1da7	8d 10 06	sta $0610			sta 	lineNumberTable+1
.1daa	9c 0f 06	stz $060f			stz 	lineNumberTable
.1dad	ad 11 06	lda $0611			lda 	variableListEnd
.1db0	85 2d		sta $2d				sta 	zTemp0+1
.1db2	64 2c		stz $2c				stz 	zTemp0
.1db4	a9 00		lda #$00			lda 	#0
.1db6	92 2c		sta ($2c)			sta 	(zTemp0)
.1db8	a9 00		lda #$00			lda 	#((0) & $FF)
.1dba	8d 13 06	sta $0613			sta 	0+freeVariableMemory
.1dbd	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1dbf	8d 14 06	sta $0614			sta 	1+freeVariableMemory
.1dc2	60		rts				rts
.060f					lineNumberTable:
>060f							.fill 	2
.0611					variableListEnd:
>0611							.fill 	2
.0613					freeVariableMemory:
>0613							.fill 	2
.1dc3					CompileTerm:
.1dc3	20 bf 19	jsr $19bf			jsr 	GetNextNonSpace 			; get first non space character.
.1dc6	30 72		bmi $1e3a			bmi 	_CTUnaryFunctions
.1dc8	20 c9 19	jsr $19c9			jsr 	CharIsDigit 				; found a number
.1dcb	b0 3a		bcs $1e07			bcs 	_CTDigit
.1dcd	c9 2e		cmp #$2e			cmp 	#"."
.1dcf	f0 36		beq $1e07			beq 	_CTDigit
.1dd1	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1dd3	f0 43		beq $1e18			beq 	_CTString
.1dd5	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1dd7	f0 28		beq $1e01			beq 	_CTOtherBase
.1dd9	c9 24		cmp #$24			cmp 	#"$"
.1ddb	f0 24		beq $1e01			beq 	_CTOtherBase
.1ddd	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1ddf	f0 17		beq $1df8			beq 	_CTBrackets
.1de1	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1de3	90 10		bcc $1df5			bcc 	_CTSyntax
.1de5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1de7	b0 0c		bcs $1df5			bcs 	_CTSyntax
.1de9	20 58 1d	jsr $1d58			jsr 	GetReferenceTerm 			; figure out what it is.
.1dec	48		pha				pha 								; save type on stack
.1ded	18		clc				clc 								; read it
.1dee	20 0a 1d	jsr $1d0a			jsr 	GetSetVariable
.1df1	68		pla				pla
.1df2	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1df4	60		rts				rts
.1df5					_CTSyntax:
.1df5	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.1df8					_CTBrackets:
.1df8	20 44 13	jsr $1344			jsr 	CompileExpressionAt0
.1dfb	48		pha				pha
.1dfc	20 98 10	jsr $1098			jsr 	CheckNextRParen
.1dff	68		pla				pla
.1e00	60		rts				rts
.1e01					_CTOtherBase:
.1e01	20 0e 10	jsr $100e			jsr 	InlineNonDecimal 			; non decimal constant handler
.1e04	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e06	60		rts				rts
.1e07					_CTDigit:
.1e07	20 60 1c	jsr $1c60			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1e0a	90 06		bcc $1e12			bcc	 	_CTFloat 					; have a float or long int.
.1e0c	20 3e 11	jsr $113e			jsr 	PushIntegerYA 				; code to push on stack
.1e0f	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e11	60		rts				rts
.1e12					_CTFloat:
.1e12	20 60 11	jsr $1160			jsr 	PushFloat  					; code to push float
.1e15	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1e17	60		rts				rts
.1e18					_CTString:
.1e18	20 6d 10	jsr $106d			jsr 	BufferClear 				; copy it to the buffer
.1e1b					_CTStringLoop:
.1e1b	20 a3 19	jsr $19a3			jsr 	LookNext 					; reached EOL/EOS
.1e1e	f0 d5		beq $1df5			beq 	_CTSyntax
.1e20	c9 22		cmp #$22			cmp 	#'"'
.1e22	f0 08		beq $1e2c			beq 	_CTStringDone
.1e24	20 71 10	jsr $1071			jsr 	BufferWrite 				; write and consume
.1e27	20 b4 19	jsr $19b4			jsr 	GetNext
.1e2a	80 ef		bra $1e1b			bra 	_CTStringLoop
.1e2c					_CTStringDone:
.1e2c	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume closing quote.
.1e2f	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1e31	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1e34	20 7d 10	jsr $107d			jsr 	BufferOutput
.1e37	a9 40		lda #$40			lda 	#NSSString 					; string type
.1e39	60		rts				rts
.1e3a					_CTUnaryFunctions:
.1e3a	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1e3c	f0 0a		beq $1e48			beq 	_CTNegation
.1e3e	a2 4e		ldx #$4e			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1e40	a0 17		ldy #$17			ldy 	#UnaryTables >> 8
.1e42	20 48 18	jsr $1848			jsr 	GeneratorProcess
.1e45	90 ae		bcc $1df5			bcc		_CTSyntax
.1e47	60		rts				rts
.1e48					_CTNegation:
.1e48	20 c3 1d	jsr $1dc3			jsr 	CompileTerm 				; compile a term.
.1e4b	48		pha				pha
.1e4c	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1e4e	c9 00		cmp #$00			cmp 	#NSSIFloat
.1e50	d0 07		bne $1e59			bne 	_CTType 					; error
.1e52	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1e54	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1e57	68		pla				pla 								; return original type.
.1e58	60		rts				rts
.1e59					_CTType:
.1e59	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.1e5c					CommandWAIT:
.1e5c	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace
.1e5f	c9 2c		cmp #$2c			cmp 	#","
.1e61	f0 10		beq $1e73			beq 	_CWThirdParameter
.1e63	a9 00		lda #$00			lda 	#0
.1e65	20 51 11	jsr $1151			jsr 	PushIntegerA
.1e68					_CWExit:
.1e68	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1e6a	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1e6d	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1e6f	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1e72	60		rts				rts
.1e73					_CWThirdParameter:
.1e73	20 b4 19	jsr $19b4			jsr 	GetNext
.1e76	20 46 13	jsr $1346			jsr 	CompileExpressionAtA
.1e79	29 40		and #$40			and 	#NSSTypeMask
.1e7b	c9 00		cmp #$00			cmp 	#NSSIFloat
.1e7d	f0 e9		beq $1e68			beq 	_CWExit
.1e7f	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.1e82					APIOWriteByte:
.1e82	92 29		sta ($29)			sta 	(objPtr)
.1e84	e6 29		inc $29				inc 	objPtr
.1e86	d0 02		bne $1e8a			bne 	_HWOWBNoCarry
.1e88	e6 2a		inc $2a				inc 	objPtr+1
.1e8a					_HWOWBNoCarry:
.1e8a	60		rts				rts
.1e8b					CommandCMD:
.1e8b	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.1e8d	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1e90	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; followed by a , ?
.1e93	c9 2c		cmp #$2c			cmp 	#","
.1e95	d0 06		bne $1e9d			bne 	_CCMDExit
.1e97	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume comma.
.1e9a	20 85 1c	jsr $1c85			jsr 	CommandPRINT 				; do the print code
.1e9d					_CCMDExit:
.1e9d	60		rts				rts
.1e9e					CommandOPEN:
.1e9e	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; followed by a , ?
.1ea1	c9 2c		cmp #$2c			cmp 	#","
.1ea3	d0 15		bne $1eba			bne 	_COTwoDefaults
.1ea5	20 b4 19	jsr $19b4			jsr 	GetNext 					; consume comma
.1ea8	20 44 13	jsr $1344			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1eab	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1ead	f0 1e		beq $1ecd			beq 	_COThreeIntegers
.1eaf	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1eb1	20 51 11	jsr $1151			jsr 	PushIntegerA
.1eb4	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1eb6	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1eb9	60		rts				rts
.1eba					_COTwoDefaults:
.1eba	a9 00		lda #$00			lda 	#0
.1ebc	20 51 11	jsr $1151			jsr 	PushIntegerA
.1ebf					_COCompileNullString:
.1ebf	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1ec1	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1ec4	a9 00		lda #$00			lda 	#0
.1ec6	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1ec9	20 59 10	jsr $1059			jsr 	WriteCodeByte
.1ecc	60		rts				rts
.1ecd					_COThreeIntegers:
.1ecd	20 a6 19	jsr $19a6			jsr 	LookNextNonSpace 			; is there a ,
.1ed0	c9 2c		cmp #$2c			cmp 	#","
.1ed2	d0 eb		bne $1ebf			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1ed4	20 b4 19	jsr $19b4			jsr 	GetNext
.1ed7	20 44 13	jsr $1344			jsr 	CompileExpressionAt0 		; should be a filename
.1eda	29 40		and #$40			and 	#NSSString
.1edc	f0 01		beq $1edf			beq 	_COType
.1ede	60		rts				rts
.1edf					_COType:
.1edf	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.1ee2					APIOPrintCharacter
.1ee2	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1ee5	60		rts				rts
.1ee6					APISaveMemory:
.1ee6	da		phx				phx
.1ee7	5a		phy				phy
.1ee8	48		pha				pha
.1ee9	a9 00		lda #$00			lda 	#0 							; set LFS
.1eeb	a2 08		ldx #$08			ldx 	#8
.1eed	a0 00		ldy #$00			ldy 	#0
.1eef	20 ba ff	jsr $ffba			jsr 	$FFBA
.1ef2	a9 08		lda #$08			lda 	#8 							; set file name
.1ef4	a2 08		ldx #$08			ldx 	#SaveName & $FF
.1ef6	a0 1f		ldy #$1f			ldy 	#SaveName >> 8
.1ef8	20 bd ff	jsr $ffbd			jsr 	$FFBD
.1efb	68		pla				pla 								; set up the start address.
.1efc	85 2d		sta $2d				sta 	zTemp0+1
.1efe	64 2c		stz $2c				stz 	zTemp0
.1f00	a9 2c		lda #$2c			lda 	#zTemp0 					; from index.
.1f02	7a		ply				ply 								; end in YX
.1f03	fa		plx				plx
.1f04	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.1f07	60		rts				rts
.1f08					SaveName:
>1f08	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					codePage:
>0028							.fill 	1
.0029					objPtr:
>0029							.fill 	2
.002b					objPage:
>002b							.fill 	1
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1f10					ErrorV_range:
.1f10	20 fc 12	jsr $12fc		jsr	ErrorHandler
>1f13	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f1b	41 4e 47 45 00
.1f20					ErrorV_value:
.1f20	20 fc 12	jsr $12fc		jsr	ErrorHandler
>1f23	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f2b	45 00
.1f2d					ErrorV_syntax:
.1f2d	20 fc 12	jsr $12fc		jsr	ErrorHandler
>1f30	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f38	52 52 4f 52 00
.1f3d					ErrorV_type:
.1f3d	20 fc 12	jsr $12fc		jsr	ErrorHandler
>1f40	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f48	4d 41 54 43 48 00
.1f4e					ErrorV_unimplemented:
.1f4e	20 fc 12	jsr $12fc		jsr	ErrorHandler
>1f51	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f59	45 4d 45 4e 54 45 44 00
.1f61					ErrorV_assert:
.1f61	20 fc 12	jsr $12fc		jsr	ErrorHandler
>1f64	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f6c	41 49 4c 00
.1f70					ErrorV_line:
.1f70	20 fc 12	jsr $12fc		jsr	ErrorHandler
>1f73	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f7b	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f87					ErrorV_internal:
.1f87	20 fc 12	jsr $12fc		jsr	ErrorHandler
>1f8a	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f92	20 45 52 52 4f 52 00
.1f99					ErrorV_divzero:
.1f99	20 fc 12	jsr $12fc		jsr	ErrorHandler
>1f9c	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fa4	59 20 5a 45 52 4f 00
.1fab					ErrorV_structure:
.1fab	20 fc 12	jsr $12fc		jsr	ErrorHandler
>1fae	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fb6	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fc2					ErrorV_stop:
.1fc2	20 fc 12	jsr $12fc		jsr	ErrorHandler
>1fc5	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fcd	53 54 4f 50 50 45 44 00
.1fd5					ErrorV_data:
.1fd5	20 fc 12	jsr $12fc		jsr	ErrorHandler
>1fd8	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fe0	41 54 41 00
.1fe4					ErrorV_undeclared:
.1fe4	20 fc 12	jsr $12fc		jsr	ErrorHandler
>1fe7	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1fef	41 52 52 41 59 00
.1ff5					ErrorV_redefine:
.1ff5	20 fc 12	jsr $12fc		jsr	ErrorHandler
>1ff8	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>2000	44 45 46 49 4e 45 44 00
.2008					ErrorV_index:
.2008	20 fc 12	jsr $12fc		jsr	ErrorHandler
>200b	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2013	59 20 49 4e 44 45 58 00
.201b					ErrorV_memory:
.201b	20 fc 12	jsr $12fc		jsr	ErrorHandler
>201e	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2026	45 4d 4f 52 59 00
.202c					ErrorV_channel:
.202c	20 fc 12	jsr $12fc		jsr	ErrorHandler
>202f	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2037	54 50 55 54 20 45 52 52 4f 52 00
.2042					MoveObjectForward:
.2042	b2 29		lda ($29)			lda 	(objPtr) 					; get next
.2044	c9 ff		cmp #$ff			cmp 	#$FF
.2046	f0 36		beq $207e			beq 	_MOFEnd
.2048	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.204a	90 24		bcc $2070			bcc 	_MOFAdvance1 				; forward 1
.204c	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.204e	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2050	90 20		bcc $2072			bcc 	_MOFAdvanceY
.2052	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2054	90 1a		bcc $2070			bcc 	_MOFAdvance1 				; forward 1
.2056	a8		tay				tay 								; read the size.
.2057	b9 bc 1f	lda $1fbc,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.205a	a8		tay				tay
.205b	c8		iny				iny 								; add 1 for the system token.
.205c	d0 14		bne $2072			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.205e	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2060	b1 29		lda ($29),y			lda 	(objPtr),y
.2062	a8		tay				tay 								; into Y.
.2063	18		clc				clc
.2064	a5 29		lda $29				lda 	objPtr						; add 2 to the object pointer
.2066	69 02		adc #$02			adc 	#2
.2068	85 29		sta $29				sta 	objPtr
.206a	90 02		bcc $206e			bcc 	_MOFNoCarry1
.206c	e6 2a		inc $2a				inc 	objPtr+1
.206e					_MOFNoCarry1:
.206e	80 02		bra $2072			bra 	_MOFAdvanceY
.2070					_MOFAdvance1:
.2070	a0 01		ldy #$01			ldy 	#1
.2072					_MOFAdvanceY:
.2072	98		tya				tya 								; add X to objPtr
.2073	18		clc				clc
.2074	65 29		adc $29				adc 	objPtr
.2076	85 29		sta $29				sta 	objPtr
.2078	90 02		bcc $207c			bcc 	_MOFNoCarry2
.207a	e6 2a		inc $2a				inc 	objPtr+1
.207c					_MOFNoCarry2:
.207c	18		clc				clc 								; not completed.
.207d	60		rts				rts
.207e					_MOFEnd:
.207e	e6 29		inc $29				inc 	objPtr
.2080	d0 02		bne $2084			bne 	_MOFENoCarry
.2082	e6 2a		inc $2a				inc 	objPtr+1
.2084					_MOFENoCarry:
.2084	38		sec				sec
.2085	60		rts				rts
.2086					MOFSizeTable:
>2086	01					.byte	1         	; $ca .shift
>2087	01					.byte	1         	; $cb .byte
>2088	02					.byte	2         	; $cc .word
>2089	05					.byte	5         	; $cd .float
>208a	ff					.byte	255       	; $ce .string
>208b	ff					.byte	255       	; $cf .data
>208c	03					.byte	3         	; $d0 .goto
>208d	03					.byte	3         	; $d1 .gosub
>208e	03					.byte	3         	; $d2 .goto.z
>208f	03					.byte	3         	; $d3 .goto.nz
>2090	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0615					numberBuffer:
>0615							.fill 	34
.2091					FloatSubtract:
.2091	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.2093	49 80		eor #$80			eor 	#$80
.2095	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.2097					FloatAdd:
.2097	ca		dex				dex
.2098	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.209a	15 6f		ora $6f,x			ora 	NSExponent+1,x
.209c	15 62		ora $62,x			ora 	NSMantissa3,x
.209e	15 63		ora $63,x			ora 	NSMantissa3+1,x
.20a0	d0 04		bne $20a6			bne 	_FAUseFloat
.20a2	20 33 24	jsr $2433			jsr 	FloatInt32Add 				; use the int32 one.
.20a5	60		rts				rts
.20a6					_FAUseFloat:
.20a6	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise S[X]
.20a9	f0 51		beq $20fc			beq 	_FAReturn1
.20ab	e8		inx				inx 								; normalise S[X+1]
.20ac	20 c8 23	jsr $23c8			jsr 	FloatNormalise
.20af	ca		dex				dex
.20b0	c9 00		cmp #$00			cmp 	#0
.20b2	f0 60		beq $2114			beq 	_FAExit 					; if so, just return A
.20b4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20b6	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20b8	f0 18		beq $20d2			beq 	_FAExponentsEqual
.20ba	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20bc	a8		tay				tay
.20bd	38		sec				sec 								; do a signed comparison of the exponents.
.20be	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20c0	50 02		bvc $20c4			bvc 	_FANoSignedChange
.20c2	49 80		eor #$80			eor 	#$80
.20c4					_FANoSignedChange:
.20c4	29 80		and #$80			and 	#$80
.20c6	10 02		bpl $20ca			bpl 	_FAHaveMax
.20c8	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.20ca					_FAHaveMax:
.20ca	20 15 21	jsr $2115			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20cd	e8		inx				inx
.20ce	20 15 21	jsr $2115			jsr 	_FAShiftToExponent
.20d1	ca		dex				dex
.20d2					_FAExponentsEqual:
.20d2	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.20d4	55 33		eor $33,x			eor 	NSStatus+1,x
.20d6	30 0e		bmi $20e6			bmi 	_FADifferentSigns
.20d8	20 ff 23	jsr $23ff			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20db	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20dd	10 35		bpl $2114			bpl 	_FAExit 					; if no, we are done.
.20df	20 8c 26	jsr $268c			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20e2	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.20e4	80 2e		bra $2114			bra 	_FAExit
.20e6					_FADifferentSigns:
.20e6	20 19 24	jsr $2419			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20e9	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.20eb	10 06		bpl $20f3			bpl 	_FACheckZero 				; if no, check for -0
.20ed	20 35 26	jsr $2635			jsr 	FloatNegate 					; netate result
.20f0	20 3c 26	jsr $263c			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20f3					_FACheckZero:
.20f3	20 95 26	jsr $2695			jsr 	FloatIsZero	 				; check for -0
.20f6	d0 1c		bne $2114			bne 	_FAExit
.20f8	74 32		stz $32,x			stz 	NSStatus,x
.20fa	80 18		bra $2114			bra 	_FAExit
.20fc					_FAReturn1:
.20fc	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20fe	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2100	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2102	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2104	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.2106	95 56		sta $56,x			sta 	NSMantissa2,x
.2108	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.210a	95 62		sta $62,x			sta 	NSMantissa3,x
.210c	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.210e	95 6e		sta $6e,x			sta 	NSExponent,x
.2110	b5 33		lda $33,x			lda 	NSStatus+1,x
.2112	95 32		sta $32,x			sta 	NSStatus,x
.2114					_FAExit:
.2114	60		rts				rts
.2115					_FAShiftToExponent:
.2115					_FAShiftToExponent2:
.2115	98		tya				tya 								; compare Y to exponent
.2116	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2118	f0 07		beq $2121			beq 	_FASEExit 					; exit if so.
.211a	20 8c 26	jsr $268c			jsr 	FloatShiftRight	 			; shift the mantissa right
.211d	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.211f	80 f4		bra $2115			bra 	_FAShiftToExponent2
.2121					_FASEExit:
.2121	60		rts				rts
.2122					CompareEqual:
.2122	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2124	d0 09		bne $212f			bne 	ReturnFalse
.2126					ReturnTrue:
.2126	a9 01		lda #$01			lda 	#1
.2128	95 3e		sta $3e,x			sta 	NSMantissa0,x
.212a	a9 80		lda #$80			lda 	#$80
.212c	95 32		sta $32,x			sta 	NSStatus,x
.212e	60		rts				rts
.212f					ReturnFalse:
.212f	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2131	60		rts				rts
.2132					CompareNotEqual:
.2132	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2134	d0 f0		bne $2126			bne 	ReturnTrue
.2136	80 f7		bra $212f			bra 	ReturnFalse
.2138					CompareLess:
.2138	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.213a	c9 ff		cmp #$ff			cmp 	#$FF
.213c	f0 e8		beq $2126			beq 	ReturnTrue
.213e	80 ef		bra $212f			bra 	ReturnFalse
.2140					CompareGreater:
.2140	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2142	c9 01		cmp #$01			cmp 	#$01
.2144	f0 e0		beq $2126			beq 	ReturnTrue
.2146	80 e7		bra $212f			bra 	ReturnFalse
.2148					CompareLessEqual:
.2148	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.214a	c9 01		cmp #$01			cmp 	#$01
.214c	d0 d8		bne $2126			bne 	ReturnTrue
.214e	80 df		bra $212f			bra 	ReturnFalse
.2150					CompareGreaterEqual:
.2150	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2152	c9 ff		cmp #$ff			cmp 	#$FF
.2154	d0 d0		bne $2126			bne 	ReturnTrue
.2156	80 d7		bra $212f			bra 	ReturnFalse
.2158					FloatCompare:
.2158	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.215a	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.215c	48		pha				pha
.215d	20 91 20	jsr $2091			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2160	68		pla				pla
.2161	d0 0c		bne $216f			bne 	_FCCompareFloat
.2163	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2165	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2167	15 56		ora $56,x			ora 	NSMantissa2,x
.2169	15 62		ora $62,x			ora 	NSMantissa3,x
.216b	f0 14		beq $2181			beq 	_FCExit 					; if zero, return zero
.216d	80 0a		bra $2179			bra 	_FCSign
.216f					_FCCompareFloat:
.216f	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2171	29 f0		and #$f0			and 	#$F0
.2173	15 56		ora $56,x			ora 	NSMantissa2,x
.2175	15 62		ora $62,x			ora 	NSMantissa3,x
.2177	f0 08		beq $2181			beq 	_FCExit 					; zero, so approximately identical
.2179					_FCSign:
.2179	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.217b	34 32		bit $32,x			bit 	NSStatus,x
.217d	10 02		bpl $2181			bpl 	_FCExit
.217f					_FCNegative:
.217f	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2181					_FCExit:
.2181	20 75 26	jsr $2675			jsr 	FloatSetByte 				; set the result 255,0,1
.2184	60		rts				rts
.2185					FloatScalarTable:
>2185	66 66 66 66				.dword $66666666 ; 0.1
>2189	de					.byte $de
>218a	1f 85 eb 51				.dword $51eb851f ; 0.01
>218e	db					.byte $db
>218f	4c 37 89 41				.dword $4189374c ; 0.001
>2193	d8					.byte $d8
>2194	ac 8b db 68				.dword $68db8bac ; 0.0001
>2198	d4					.byte $d4
>2199	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>219d	d1					.byte $d1
>219e	83 de 1b 43				.dword $431bde83 ; 1e-06
>21a2	ce					.byte $ce
>21a3	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21a7	ca					.byte $ca
>21a8	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21ac	c7					.byte $c7
>21ad	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21b1	c4					.byte $c4
>21b2	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21b6	c0					.byte $c0
>21b7	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21bb	bd					.byte $bd
.21bc					FloatDivide:
.21bc	48		pha				pha
.21bd	20 c8 23	jsr $23c8			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21c0	ca		dex				dex
.21c1	c9 00		cmp #$00			cmp 	#0
.21c3	f0 1e		beq $21e3			beq 	_FDZero
.21c5	20 c8 23	jsr $23c8			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21c8	f0 16		beq $21e0			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21ca	20 2b 22	jsr $222b			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21cd	20 f8 21	jsr $21f8			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21d0	20 c8 23	jsr $23c8			jsr		FloatNormalise 				; renormalise
.21d3	20 be 23	jsr $23be			jsr 	FloatCalculateSign 			; calculate result sign
.21d6	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.21d8	38		sec				sec
.21d9	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.21db	38		sec				sec
.21dc	e9 1e		sbc #$1e			sbc 	#30
.21de	95 6e		sta $6e,x			sta 	NSExponent,x
.21e0					_FDExit:
.21e0	68		pla				pla
.21e1	18		clc				clc
.21e2	60		rts				rts
.21e3					_FDZero:
.21e3	68		pla				pla
.21e4	38		sec				sec
.21e5	60		rts				rts
.21e6					DivideInt32:
.21e6	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart 			; make both integers
.21e9	ca		dex				dex
.21ea	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.21ed	20 09 22	jsr $2209			jsr 	Int32Divide 				; divide
.21f0	20 f8 21	jsr $21f8			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21f3	20 be 23	jsr $23be			jsr 	FloatCalculateSign 			; calculate result sign
.21f6	18		clc				clc
.21f7	60		rts				rts
.21f8					NSMCopyPlusTwoToZero:
.21f8	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21fa	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21fc	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21fe	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2200	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.2202	95 56		sta $56,x			sta 	NSMantissa2,x
.2204	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.2206	95 62		sta $62,x			sta 	NSMantissa3,x
.2208	60		rts				rts
.2209					Int32Divide:
.2209	48		pha				pha 								; save AXY
.220a	5a		phy				phy
.220b	20 56 26	jsr $2656			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.220e	20 6f 26	jsr $266f			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2211	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2213					_I32DivideLoop:
.2213	e8		inx				inx
.2214	e8		inx				inx
.2215	20 82 26	jsr $2682			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2218	ca		dex				dex
.2219	ca		dex				dex
.221a	20 83 26	jsr $2683			jsr 	FloatRotateLeft
.221d	20 49 22	jsr $2249			jsr 	FloatDivideCheck 			; check if subtract possible
.2220	90 02		bcc $2224			bcc 	_I32DivideNoCarryIn
.2222	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2224					_I32DivideNoCarryIn:
.2224	88		dey				dey 								; loop round till division completed.
.2225	d0 ec		bne $2213			bne 	_I32DivideLoop
.2227	7a		ply				ply 								; restore AXY and exit
.2228	68		pla				pla
.2229	18		clc				clc
.222a	60		rts				rts
.222b					Int32ShiftDivide:
.222b	48		pha				pha 								; save AY
.222c	5a		phy				phy
.222d	e8		inx				inx 								; clear S[X+2]
.222e	e8		inx				inx
.222f	20 73 26	jsr $2673			jsr 	FloatSetZero
.2232	ca		dex				dex
.2233	ca		dex				dex
.2234	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2236					_I32SDLoop:
.2236	20 49 22	jsr $2249			jsr 	FloatDivideCheck 			; check if subtract possible
.2239	e8		inx				inx
.223a	e8		inx				inx
.223b	20 83 26	jsr $2683			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.223e	ca		dex				dex
.223f	ca		dex				dex
.2240	20 83 26	jsr $2683			jsr 	FloatRotateLeft
.2243	88		dey				dey 	 							; do 31 times
.2244	d0 f0		bne $2236			bne 	_I32SDLoop
.2246	7a		ply				ply 								; restore AY and exit
.2247	68		pla				pla
.2248	60		rts				rts
.2249					FloatDivideCheck:
.2249	20 19 24	jsr $2419			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.224c	b0 04		bcs $2252			bcs 	_DCSExit 					; if carry set, then could do, exit
.224e	20 ff 23	jsr $23ff			jsr 	FloatAddTopTwoStack 		; add it back in
.2251	18		clc				clc 								; and return False
.2252					_DCSExit:
.2252	60		rts				rts
.2253					FloatFractionalPart:
.2253	5a		phy				phy
.2254	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.2256	29 7f		and #$7f			and 	#$7F
.2258	95 32		sta $32,x			sta 	NSStatus,x
.225a	20 c8 23	jsr $23c8			jsr 	FloatNormalise
.225d	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.225f	38		sec				sec
.2260	e9 e0		sbc #$e0			sbc 	#$E0
.2262	90 29		bcc $228d			bcc 	_FFPExit 					; already fractional
.2264	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2266	b0 22		bcs $228a			bcs 	_FFPZero
.2268	a8		tay				tay 								; put count to do in Y
.2269	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.226b	20 92 22	jsr $2292			jsr 	_FFPPartial
.226e	95 62		sta $62,x			sta 	NSMantissa3,x
.2270	b5 56		lda $56,x			lda 	NSMantissa2,x
.2272	20 92 22	jsr $2292			jsr 	_FFPPartial
.2275	95 56		sta $56,x			sta 	NSMantissa2,x
.2277	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2279	20 92 22	jsr $2292			jsr 	_FFPPartial
.227c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.227e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2280	20 92 22	jsr $2292			jsr 	_FFPPartial
.2283	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2285	20 95 26	jsr $2695			jsr 	FloatIsZero 					; zeroed check.
.2288	d0 03		bne $228d			bne 	_FFPExit
.228a					_FFPZero:
.228a	20 73 26	jsr $2673			jsr 	FloatSetZero
.228d					_FFPExit:
.228d	20 c8 23	jsr $23c8			jsr 	FloatNormalise
.2290	7a		ply				ply
.2291	60		rts				rts
.2292					_FFPPartial:
.2292	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2294	f0 17		beq $22ad			beq 	_FFFPPExit
.2296	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.2298	b0 0c		bcs $22a6			bcs 	_FFFPPWholeByte
.229a	5a		phy				phy
.229b					_FFFPPLeft:
.229b	0a		asl a				asl 	a
.229c	88		dey				dey
.229d	d0 fc		bne $229b			bne 	_FFFPPLeft
.229f	7a		ply				ply
.22a0					_FFFPPRight:
.22a0	4a		lsr a				lsr 	a
.22a1	88		dey				dey
.22a2	d0 fc		bne $22a0			bne 	_FFFPPRight
.22a4	80 07		bra $22ad			bra 	_FFFPPExit
.22a6					_FFFPPWholeByte:
.22a6	98		tya				tya 								; subtract 8 from count
.22a7	38		sec				sec
.22a8	e9 08		sbc #$08			sbc 	#8
.22aa	a8		tay				tay
.22ab	a9 00		lda #$00			lda 	#0 							; and clear all
.22ad					_FFFPPExit:
.22ad	60		rts				rts
.22ae					FloatIntegerPart:
.22ae	48		pha				pha
.22af	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22b1	f0 1d		beq $22d0			beq 	_FIPExit 					; if so do nothing
.22b3	20 95 26	jsr $2695			jsr 	FloatIsZero 				; is it zero ?
.22b6	f0 15		beq $22cd			beq 	_FIPZero 					; if so return zero.
.22b8	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise
.22bb	f0 10		beq $22cd			beq 	_FIPZero 					; normalised to zero, exit zero
.22bd					_FIPShift:
.22bd	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22bf	10 07		bpl $22c8			bpl 	_FIPCheckZero
.22c1	20 8c 26	jsr $268c			jsr 	FloatShiftRight 			; shift mantissa right
.22c4	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22c6	80 f5		bra $22bd			bra 	_FIPShift
.22c8					_FIPCheckZero:
.22c8	20 95 26	jsr $2695			jsr 	FloatIsZero 				; avoid -0 problem
.22cb	d0 03		bne $22d0			bne 	_FIPExit 					; set to zero if mantissa zero.
.22cd					_FIPZero:
.22cd	20 73 26	jsr $2673			jsr 	FloatSetZero
.22d0					_FIPExit:
.22d0	68		pla				pla
.22d1	60		rts				rts
.22d2					FloatIntegerPartDown:
.22d2	48		pha				pha
.22d3	5a		phy				phy
.22d4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22d6	f0 36		beq $230e			beq 	_FIPExit 					; if so do nothing
.22d8	20 95 26	jsr $2695			jsr 	FloatIsZero 				; is it zero ?
.22db	f0 2e		beq $230b			beq 	_FIPZero 					; if so return zero.
.22dd	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise
.22e0	f0 29		beq $230b			beq 	_FIPZero 					; normalised to zero, exit zero
.22e2	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22e4					_FIPShift:
.22e4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22e6	10 0a		bpl $22f2			bpl 	_FIPCheckDown
.22e8	20 8c 26	jsr $268c			jsr 	FloatShiftRight 			; shift mantissa right
.22eb	90 01		bcc $22ee			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22ed	c8		iny				iny
.22ee					_FIPNoFrac:
.22ee	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22f0	80 f2		bra $22e4			bra 	_FIPShift
.22f2					_FIPCheckDown:
.22f2	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22f4	f0 10		beq $2306			beq 	_FIPCheckZero
.22f6	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22f8	10 0c		bpl $2306			bpl 	_FIPCheckZero
.22fa	e8		inx				inx 								; -ve so round *down*.
.22fb	a9 01		lda #$01			lda 	#1
.22fd	20 75 26	jsr $2675			jsr 	FloatSetByte
.2300	20 35 26	jsr $2635			jsr 	FloatNegate
.2303	20 97 20	jsr $2097			jsr 	FloatAdd
.2306					_FIPCheckZero:
.2306	20 95 26	jsr $2695			jsr 	FloatIsZero 				; avoid -0 problem
.2309	d0 03		bne $230e			bne 	_FIPExit 					; set to zero if mantissa zero.
.230b					_FIPZero:
.230b	20 73 26	jsr $2673			jsr 	FloatSetZero
.230e					_FIPExit:
.230e	7a		ply				ply
.230f	68		pla				pla
.2310	60		rts				rts
.2311					FloatInt8Multiply:
.2311	5a		phy				phy
.2312	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2314	a8		tay				tay
.2315	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2317					_FI8MLoop:
.2317	98		tya				tya 								; shift right shifter right into carry
.2318	4a		lsr a				lsr 	a
.2319	a8		tay				tay
.231a	90 0d		bcc $2329			bcc 	_FI8MNoAdd
.231c	18		clc				clc
.231d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.231f	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.2321	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2323	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2325	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.2327	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2329					_FI8MNoAdd:
.2329	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.232b	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.232d	c0 00		cpy #$00			cpy 	#0
.232f	d0 e6		bne $2317			bne 	_FI8MLoop 					; until right shifter zero.
.2331	7a		ply				ply
.2332	60		rts				rts
.2333					FloatMultiply:
.2333	ca		dex				dex
.2334	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.2336	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2338	15 62		ora $62,x			ora 	NSMantissa3,x
.233a	15 63		ora $63,x			ora 	NSMantissa3+1,x
.233c	d0 21		bne $235f			bne 	_FMUseFloat
.233e	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2340	15 33		ora $33,x			ora 	NSStatus+1,x
.2342	29 80		and #$80			and 	#$80
.2344	15 62		ora $62,x			ora 	NSMantissa3,x
.2346	15 56		ora $56,x			ora 	NSMantissa2,x
.2348	15 4a		ora $4a,x			ora 	NSMantissa1,x
.234a	15 63		ora $63,x			ora 	NSMantissa3+1,x
.234c	15 57		ora $57,x			ora 	NSMantissa2+1,x
.234e	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2350	d0 04		bne $2356			bne 	_FMInt32
.2352	20 11 23	jsr $2311			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2355	60		rts				rts
.2356					_FMInt32:
.2356	20 80 23	jsr $2380			jsr 	FloatMultiplyShort			; use the int32 one.
.2359	18		clc				clc 								; fix it up if gone out of range
.235a	75 6e		adc $6e,x			adc 	NSExponent,x
.235c	95 6e		sta $6e,x			sta 	NSExponent,x
.235e	60		rts				rts
.235f					_FMUseFloat:
.235f	20 c8 23	jsr $23c8			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2362	f0 18		beq $237c			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2364	e8		inx				inx
.2365	20 c8 23	jsr $23c8			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2368	ca		dex				dex
.2369	c9 00		cmp #$00			cmp 	#0
.236b	f0 0c		beq $2379			beq 	_FDSetZero
.236d	20 80 23	jsr $2380			jsr 	FloatMultiplyShort 			; calculate the result.
.2370	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2372	18		clc				clc
.2373	75 6f		adc $6f,x			adc 	NSExponent+1,x
.2375	95 6e		sta $6e,x			sta 	NSExponent,x
.2377	80 03		bra $237c			bra 	_FDExit
.2379					_FDSetZero:
.2379	20 73 26	jsr $2673			jsr 	FloatSetZero 				; return 0
.237c					_FDExit:
.237c	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise the result
.237f	60		rts				rts
.2380					FloatMultiplyShort:
.2380	5a		phy				phy 								; save Y
.2381	20 56 26	jsr $2656			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2384	20 6f 26	jsr $266f			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2387	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2389					_I32MLoop:
.2389	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.238b	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.238d	15 58		ora $58,x			ora 	NSMantissa2+2,x
.238f	15 64		ora $64,x			ora 	NSMantissa3+2,x
.2391	f0 25		beq $23b8			beq 	_I32MExit 					; exit if zero
.2393	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2395	29 01		and #$01			and 	#1
.2397	f0 0d		beq $23a6			beq 	_I32MNoAdd
.2399	20 ff 23	jsr $23ff			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.239c	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.239e	10 06		bpl $23a6			bpl 	_I32MNoAdd
.23a0					_I32ShiftRight:
.23a0	20 8c 26	jsr $268c			jsr 	FloatShiftRight 			; shift S[X] right
.23a3	c8		iny				iny 								; increment shift count
.23a4	80 09		bra $23af			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23a6					_I32MNoAdd:
.23a6	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23a8	70 f6		bvs $23a0			bvs 	_I32ShiftRight 				; instead.
.23aa	e8		inx				inx
.23ab	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23ae	ca		dex				dex
.23af					_I32MShiftUpper:
.23af	e8		inx				inx 								; shift S[X+2] right
.23b0	e8		inx				inx
.23b1	20 8c 26	jsr $268c			jsr 	FloatShiftRight
.23b4	ca		dex				dex
.23b5	ca		dex				dex
.23b6	80 d1		bra $2389			bra 	_I32MLoop 					; try again.
.23b8					_I32MExit:
.23b8	20 be 23	jsr $23be			jsr 	FloatCalculateSign
.23bb	98		tya				tya 								; shift in A
.23bc	7a		ply				ply 								; restore Y and exit
.23bd	60		rts				rts
.23be					FloatCalculateSign:
.23be	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23c0	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23c2	55 33		eor $33,x			eor 	NSStatus+1,x
.23c4	0a		asl a				asl 	a 							; shift bit 7 into carry
.23c5	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23c7	60		rts				rts
.23c8					FloatNormalise:
.23c8	20 95 26	jsr $2695			jsr 	FloatIsZero 				; if zero exit
.23cb	d0 07		bne $23d4			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23cd	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.23cf	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.23d1	a9 00		lda #$00			lda 	#0 							; set Z flag
.23d3	60		rts				rts
.23d4					_NSNormaliseOptimise:
.23d4	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23d6	d0 19		bne $23f1			bne 	_NSNormaliseLoop
.23d8	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.23da	30 15		bmi $23f1			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23dc	95 62		sta $62,x			sta 	NSMantissa3,x
.23de	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.23e0	95 56		sta $56,x			sta 	NSMantissa2,x
.23e2	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.23e4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23e6	74 3e		stz $3e,x			stz 	NSMantissa0,x
.23e8	b5 6e		lda $6e,x			lda 	NSExponent,x
.23ea	38		sec				sec
.23eb	e9 08		sbc #$08			sbc 	#8
.23ed	95 6e		sta $6e,x			sta 	NSExponent,x
.23ef	80 e3		bra $23d4			bra 	_NSNormaliseOptimise
.23f1					_NSNormaliseLoop:
.23f1	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23f3	70 07		bvs $23fc			bvs 	_NSNExit 					; exit if so with Z flag clear
.23f5	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; shift mantissa left
.23f8	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23fa	80 f5		bra $23f1			bra 	_NSNormaliseLoop
.23fc					_NSNExit:
.23fc	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23fe	60		rts				rts
.23ff					FloatAddTopTwoStack:
.23ff	18		clc				clc
.2400	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2402	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.2404	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2406	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2408	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.240a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.240c	b5 56		lda $56,x			lda		NSMantissa2,x
.240e	75 57		adc $57,x			adc 		NSMantissa2+1,x
.2410	95 56		sta $56,x			sta 	NSMantissa2,x
.2412	b5 62		lda $62,x			lda		NSMantissa3,x
.2414	75 63		adc $63,x			adc 		NSMantissa3+1,x
.2416	95 62		sta $62,x			sta 	NSMantissa3,x
.2418	60		rts				rts
.2419					FloatSubTopTwoStack:
.2419	38		sec				sec
.241a	b5 3e		lda $3e,x			lda		NSMantissa0,x
.241c	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.241e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2420	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2422	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.2424	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2426	b5 56		lda $56,x			lda		NSMantissa2,x
.2428	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.242a	95 56		sta $56,x			sta 	NSMantissa2,x
.242c	b5 62		lda $62,x			lda		NSMantissa3,x
.242e	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.2430	95 62		sta $62,x			sta 	NSMantissa3,x
.2432	60		rts				rts
.2433					FloatInt32Add:
.2433	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2435	55 33		eor $33,x			eor 	NSStatus+1,x
.2437	30 04		bmi $243d			bmi 	_DiffSigns
.2439	20 ff 23	jsr $23ff			jsr		FloatAddTopTwoStack
.243c	60		rts				rts
.243d					_DiffSigns:
.243d	20 19 24	jsr $2419			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2440	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2442	10 07		bpl $244b			bpl 	_AddExit
.2444	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2446	95 32		sta $32,x			sta 	NSStatus,x
.2448	20 3c 26	jsr $263c			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.244b					_AddExit:
.244b	20 95 26	jsr $2695			jsr 	FloatIsZero 				; check for -0
.244e	d0 02		bne $2452			bne 	_AddNonZero
.2450	74 32		stz $32,x			stz 	NSStatus,x
.2452					_AddNonZero:
.2452	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2453					FloatEncodeStart:
.2453	38		sec				sec
.2454	80 01		bra $2457			bra 	FloatEncodeContinue+1
.2456					FloatEncodeContinue:
.2456	18		clc				clc
.2457					FloatEncode:
.2457	08		php				php 								; save reset flag.
.2458	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.245a	f0 15		beq $2471			beq 	_ENIsOkay
.245c	c9 30		cmp #$30			cmp 	#"0"
.245e	90 04		bcc $2464			bcc 	_ENBadNumber
.2460	c9 3a		cmp #$3a			cmp 	#"9"+1
.2462	90 0d		bcc $2471			bcc 	_ENIsOkay
.2464					_ENBadNumber:
.2464	28		plp				plp 								; throw saved reset
.2465	ad 37 06	lda $0637			lda 	encodeState 				; if in decimal mode, construct final number
.2468	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.246a	d0 03		bne $246f			bne 	_ENFail
.246c	4c e9 24	jmp $24e9			jmp 	_ENConstructFinal
.246f					_ENFail:
.246f	18		clc				clc 								; not allowed
.2470	60		rts				rts
.2471					_ENIsOkay:
.2471	28		plp				plp 								; are we restarting
.2472	90 15		bcc $2489			bcc 	_ENNoRestart
.2474					_ENStartEncode:
.2474	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2476	f0 0c		beq $2484			beq 	_ENFirstDP
.2478	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.247a	20 75 26	jsr $2675			jsr 	FloatSetByte 				; in single byte mode.
.247d	a9 01		lda #$01			lda 	#ESTA_Low
.247f					_ENExitChange:
.247f	8d 37 06	sta $0637			sta 	encodeState 				; save new state
.2482	38		sec				sec
.2483	60		rts				rts
.2484					_ENFirstDP:
.2484	20 73 26	jsr $2673			jsr 	FloatSetZero 				; clear integer part
.2487	80 3c		bra $24c5			bra 	_ESTASwitchFloat			; go straight to float and exi
.2489					_ENNoRestart:
.2489	48		pha				pha 								; save digit or DP on stack.
.248a	ad 37 06	lda $0637			lda 	encodeState 				; get current state
.248d	c9 01		cmp #$01			cmp 	#ESTA_Low
.248f	f0 09		beq $249a			beq  	_ESTALowState
.2491	c9 02		cmp #$02			cmp 	#ESTA_High
.2493	f0 26		beq $24bb			beq 	_ESTAHighState
.2495	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2497	f0 38		beq $24d1			beq 	_ESTADecimalState
>2499	db						.byte 	$DB 						; causes a break in the emulator
.249a					_ESTALowState:
.249a	68		pla				pla 								; get value back
.249b	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.249d	f0 26		beq $24c5			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.249f	29 0f		and #$0f			and 	#15 						; make digit
.24a1	8d 38 06	sta $0638			sta 	digitTemp 					; save it.
.24a4	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24a6	0a		asl a				asl 	a
.24a7	0a		asl a				asl 	a
.24a8	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24aa	0a		asl a				asl 	a
.24ab	6d 38 06	adc $0638			adc 	digitTemp
.24ae	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24b0	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24b2	90 05		bcc $24b9			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24b4	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24b6	8d 37 06	sta $0637			sta 	encodeState
.24b9					_ESTANoSwitch:
.24b9	38		sec				sec
.24ba	60		rts				rts
.24bb					_ESTAHighState:
.24bb	68		pla				pla 								; get value back
.24bc	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24be	f0 05		beq $24c5			beq 	_ESTASwitchFloat
.24c0	20 1b 25	jsr $251b			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24c3	38		sec				sec
.24c4	60		rts				rts
.24c5					_ESTASwitchFloat:
.24c5	9c 39 06	stz $0639			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24c8	e8		inx				inx 								; zero the decimal additive.
.24c9	20 73 26	jsr $2673			jsr 	FloatSetZero
.24cc	ca		dex				dex
.24cd	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24cf	80 ae		bra $247f			bra 	_ENExitChange
.24d1					_ESTADecimalState:
.24d1	68		pla				pla 								; digit.
.24d2	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24d4	f0 99		beq $246f			beq 	_ENFail
.24d6	e8		inx				inx 								; put digit into fractional part of X+1
.24d7	20 1b 25	jsr $251b			jsr 	ESTAShiftDigitIntoMantissa
.24da	ca		dex				dex
.24db	ee 39 06	inc $0639			inc 	decimalCount 				; bump the count of decimals
.24de	ad 39 06	lda $0639			lda 	decimalCount 				; too many decimal digits.
.24e1	c9 0b		cmp #$0b			cmp 	#11
.24e3	f0 02		beq $24e7			beq 	_ESTADSFail
.24e5	38		sec				sec
.24e6	60		rts				rts
.24e7					_ESTADSFail:
.24e7	18		clc				clc
.24e8	60		rts				rts
.24e9					_ENConstructFinal:
.24e9	ad 39 06	lda $0639			lda 	decimalCount 				; get decimal count
.24ec	f0 2b		beq $2519			beq 	_ENCFExit 					; no decimals
.24ee	5a		phy				phy
.24ef	0a		asl a				asl 	a 							; x 4 and CLC
.24f0	0a		asl a				asl 	a
.24f1	6d 39 06	adc $0639			adc 	decimalCount
.24f4	a8		tay				tay
.24f5	b9 80 21	lda $2180,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24f8	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24fa	b9 81 21	lda $2181,y			lda 	FloatScalarTable-5+1,y
.24fd	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.24ff	b9 82 21	lda $2182,y			lda 	FloatScalarTable-5+2,y
.2502	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2504	b9 83 21	lda $2183,y			lda 	FloatScalarTable-5+3,y
.2507	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2509	b9 84 21	lda $2184,y			lda 	FloatScalarTable-5+4,y
.250c	95 70		sta $70,x			sta 	NSExponent+2,x
.250e	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.2510	e8		inx				inx 								; multiply decimal const by decimal scalar
.2511	e8		inx				inx
.2512	20 33 23	jsr $2333			jsr 	FloatMultiply
.2515	20 97 20	jsr $2097			jsr 	FloatAdd 					; add to integer part.
.2518	7a		ply				ply
.2519					_ENCFExit:
.2519	18		clc				clc 								; reject the digit.
.251a	60		rts				rts
.251b					ESTAShiftDigitIntoMantissa:
.251b	29 0f		and #$0f			and 	#15 						; save digit
.251d	48		pha				pha
.251e	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2520	48		pha				pha
.2521	b5 56		lda $56,x			lda 	NSMantissa2,x
.2523	48		pha				pha
.2524	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2526	48		pha				pha
.2527	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2529	48		pha				pha
.252a	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; x 2
.252d	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; x 4
.2530	18		clc				clc 								; pop mantissa and add
.2531	68		pla				pla
.2532	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2534	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2536	68		pla				pla
.2537	75 4a		adc $4a,x			adc 	NSMantissa1,x
.2539	95 4a		sta $4a,x			sta 	NSMantissa1,x
.253b	68		pla				pla
.253c	75 56		adc $56,x			adc 	NSMantissa2,x
.253e	95 56		sta $56,x			sta 	NSMantissa2,x
.2540	68		pla				pla
.2541	75 62		adc $62,x			adc 	NSMantissa3,x
.2543	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.2545	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; x 10
.2548	68		pla				pla 								; add digit
.2549	18		clc				clc
.254a	75 3e		adc $3e,x			adc 	NSMantissa0,x
.254c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.254e	90 0a		bcc $255a			bcc 	_ESTASDExit
.2550	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2552	d0 06		bne $255a			bne 	_ESTASDExit
.2554	f6 56		inc $56,x			inc 	NSMantissa2,x
.2556	d0 02		bne $255a			bne 	_ESTASDExit
.2558	f6 62		inc $62,x			inc 	NSMantissa3,x
.255a					_ESTASDExit:
.255a	60		rts				rts
.0637					encodeState:
>0637							.fill 	1
.0638					digitTemp:
>0638							.fill 	1
.0639					decimalCount:
>0639							.fill 	1
.255b					FloatToString:
.255b	da		phx				phx
.255c	5a		phy				phy 								; save code position
.255d	8d 3a 06	sta $063a			sta 	decimalPlaces	 			; save number of DPs.
.2560	9c 3b 06	stz $063b			stz 	dbOffset 					; offset into decimal buffer = start.
.2563	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.2565	10 08		bpl $256f			bpl 	_CNTSNotNegative
.2567	29 7f		and #$7f			and 	#$7F 						; make +ve
.2569	95 32		sta $32,x			sta 	NSStatus,x
.256b	a9 2d		lda #$2d			lda 	#"-"
.256d	80 02		bra $2571			bra 	_CNTMain
.256f					_CNTSNotNegative:
.256f	a9 20		lda #$20			lda 	#" "
.2571					_CNTMain:
.2571	20 d3 25	jsr $25d3			jsr 	WriteDecimalBuffer
.2574	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.2576	f0 0d		beq $2585			beq 	_CNTSNotFloat
.2578	e8		inx				inx 								; round up so we don't get too many 6.999999
.2579	a9 01		lda #$01			lda 	#1
.257b	20 75 26	jsr $2675			jsr 	FloatSetByte
.257e	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2580	95 6e		sta $6e,x			sta 	NSExponent,x
.2582	20 97 20	jsr $2097			jsr 	FloatAdd
.2585					_CNTSNotFloat:
.2585	20 b5 25	jsr $25b5			jsr 	MakePlusTwoString 			; do the integer part.
.2588	20 53 22	jsr $2253			jsr 	FloatFractionalPart 		; get the fractional part
.258b	20 c8 23	jsr $23c8			jsr 	FloatNormalise					; normalise , exit if zero
.258e	f0 22		beq $25b2			beq 	_CNTSExit
.2590	a9 2e		lda #$2e			lda 	#"."
.2592	20 d3 25	jsr $25d3			jsr 	WriteDecimalBuffer 			; write decimal place
.2595					_CNTSDecimal:
.2595	ce 3a 06	dec $063a			dec 	decimalPlaces 				; done all the decimals
.2598	30 18		bmi $25b2			bmi 	_CNTSExit
.259a	e8		inx				inx 								; x 10.0
.259b	a9 0a		lda #$0a			lda 	#10
.259d	20 75 26	jsr $2675			jsr 	FloatSetByte
.25a0	20 33 23	jsr $2333			jsr 	FloatMultiply
.25a3	20 b5 25	jsr $25b5			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25a6	20 53 22	jsr $2253			jsr 	FloatFractionalPart 		; get the fractional part
.25a9	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise it.
.25ac	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25ae	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25b0	b0 e3		bcs $2595			bcs 	_CNTSDecimal 				; keep going.
.25b2					_CNTSExit:
.25b2	7a		ply				ply
.25b3	fa		plx				plx
.25b4	60		rts				rts
.25b5					MakePlusTwoString:
.25b5	da		phx				phx
.25b6	20 56 26	jsr $2656			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25b9	e8		inx				inx 								; access it
.25ba	e8		inx				inx
.25bb	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart 			; make it an integer
.25be	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25c0	20 f2 25	jsr $25f2			jsr 	ConvertInt32
.25c3	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25c5					_MPTSCopy:
.25c5	bd 15 06	lda $0615,x			lda 	numberBuffer,x
.25c8	20 d3 25	jsr $25d3			jsr 	WriteDecimalBuffer
.25cb	e8		inx				inx
.25cc	bd 15 06	lda $0615,x			lda 	numberBuffer,x
.25cf	d0 f4		bne $25c5			bne 	_MPTSCopy
.25d1	fa		plx				plx
.25d2	60		rts				rts
.25d3					WriteDecimalBuffer:
.25d3	da		phx				phx
.25d4	ae 3b 06	ldx $063b			ldx 	dbOffset
.25d7	9d 3c 06	sta $063c,x			sta 	decimalBuffer,x
.25da	9e 3d 06	stz $063d,x			stz 	decimalBuffer+1,x
.25dd	ee 3b 06	inc $063b			inc 	dbOffset
.25e0	fa		plx				plx
.25e1	60		rts				rts
.063a					decimalPlaces:
>063a							.fill 	1
.063b					dbOffset:
>063b							.fill 	1
.063c					decimalBuffer:
>063c							.fill 	32
.25e2					ConvertInt16:
.25e2	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.25e4	86 4a		stx $4a				stx 	NSMantissa1
.25e6	64 56		stz $56				stz 	NSMantissa2
.25e8	64 62		stz $62				stz 	NSMantissa3
.25ea	64 32		stz $32				stz 	NSStatus 					; positive integer
.25ec	a2 00		ldx #$00			ldx 	#0 							; stack level
.25ee	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25f0	80 00		bra $25f2			bra 	ConvertInt32
.25f2					ConvertInt32:
.25f2	5a		phy				phy
.25f3	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25f5	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25f7	10 08		bpl $2601			bpl 	_CI32NotNeg
.25f9	48		pha				pha
.25fa	a9 2d		lda #$2d			lda 	#'-'
.25fc	99 15 06	sta $0615,y			sta 	numberBuffer,y
.25ff	c8		iny				iny
.2600	68		pla				pla
.2601					_CI32NotNeg:
.2601	20 0f 26	jsr $260f			jsr 	_CI32DivideConvert 			; recursive conversion
.2604	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2606	99 15 06	sta $0615,y			sta 	numberBuffer,y
.2609	7a		ply				ply
.260a	a2 06		ldx #$06			ldx 	#numberBuffer >> 8 			; return address in XA
.260c	a9 15		lda #$15			lda 	#numberBuffer & $FF
.260e	60		rts				rts
.260f					_CI32DivideConvert:
.260f	e8		inx				inx 								; write to next slot up
.2610	20 75 26	jsr $2675			jsr 	FloatSetByte 		 		; write the base out.
.2613	ca		dex				dex
.2614	20 09 22	jsr $2209			jsr 	Int32Divide 				; divide
.2617	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.2619	48		pha				pha
.261a	20 f8 21	jsr $21f8			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.261d	20 95 26	jsr $2695			jsr 	FloatIsZero 				; is it zero ?
.2620	f0 05		beq $2627			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2622	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2624	20 0f 26	jsr $260f			jsr 	_CI32DivideConvert 			; and recusrively call.
.2627					_CI32NoRecurse:
.2627	68		pla				pla 								; remainder
.2628	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.262a	90 02		bcc $262e			bcc 	_CI32NotHex
.262c	69 26		adc #$26			adc 	#6+32
.262e					_CI32NotHex:
.262e	69 30		adc #$30			adc 	#48
.2630	99 15 06	sta $0615,y			sta 	numberBuffer,y 				; write out and exit
.2633	c8		iny				iny
.2634	60		rts				rts
.2635					FloatNegate:
.2635	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2637	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2639	95 32		sta $32,x			sta 	NSStatus,x
.263b	60		rts				rts
.263c					FloatNegateMantissa:
.263c	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.263d	a9 00		lda #$00			lda 	#0
.263f	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2641	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2643	a9 00		lda #$00			lda 	#0
.2645	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.2647	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2649	a9 00		lda #$00			lda 	#0
.264b	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.264d	95 56		sta $56,x			sta 	NSMantissa2,x
.264f	a9 00		lda #$00			lda 	#0
.2651	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2653	95 62		sta $62,x			sta 	NSMantissa3,x
.2655	60		rts				rts
.2656					FloatShiftUpTwo:
.2656	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2658	95 40		sta $40,x			sta 	NSMantissa0+2,x
.265a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.265c	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.265e	b5 56		lda $56,x			lda 	NSMantissa2,x
.2660	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2662	b5 62		lda $62,x			lda 	NSMantissa3,x
.2664	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2666	b5 6e		lda $6e,x			lda 	NSExponent,x
.2668	95 70		sta $70,x			sta 	NSExponent+2,x
.266a	b5 32		lda $32,x			lda 	NSStatus,x
.266c	95 34		sta $34,x			sta 	NSStatus+2,x
.266e	60		rts				rts
.266f					FloatSetZeroMantissaOnly:
.266f	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2671	80 08		bra $267b			bra 	FloatZero13
.2673					FloatSetZero:
.2673	a9 00		lda #$00			lda 	#0
.2675					FloatSetByte:
.2675	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2677					FloatSetMantissa:
.2677	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.2679	74 32		stz $32,x			stz 	NSStatus,x
.267b					FloatZero13:
.267b	74 4a		stz $4a,x			stz 	NSMantissa1,x
.267d	74 56		stz $56,x			stz 	NSMantissa2,x
.267f	74 62		stz $62,x			stz 	NSMantissa3,x
.2681	60		rts				rts
.2682					FloatShiftLeft:
.2682	18		clc				clc
.2683					FloatRotateLeft:
.2683	36 3e		rol $3e,x			rol 	NSMantissa0,x
.2685	36 4a		rol $4a,x			rol		NSMantissa1,x
.2687	36 56		rol $56,x			rol		NSMantissa2,x
.2689	36 62		rol $62,x			rol		NSMantissa3,x
.268b	60		rts				rts
.268c					FloatShiftRight:
.268c	56 62		lsr $62,x			lsr 	NSMantissa3,x
.268e	76 56		ror $56,x			ror		NSMantissa2,x
.2690	76 4a		ror $4a,x			ror		NSMantissa1,x
.2692	76 3e		ror $3e,x			ror		NSMantissa0,x
.2694	60		rts				rts
.2695					FloatIsZero:
.2695	b5 62		lda $62,x			lda 	NSMantissa3,x
.2697	15 56		ora $56,x			ora		NSMantissa2,x
.2699	15 4a		ora $4a,x			ora		NSMantissa1,x
.269b	15 3e		ora $3e,x			ora		NSMantissa0,x
.269d	60		rts				rts

;******  Processing input file: testing/testend.asm

.269e					EndProgram:
>269e	01 08 0c 08 0a 00 4e 20				.binary "code/tokenised.dat"
>26a6	b2 20 31 34 00 16 08 14 00 ce 86 20 33 58 00 33
>26b6	08 3c 00 99 20 c7 28 31 34 37 29 3b 22 48 45 4c
>26c6	4c 4f 20 57 4f 52 4c 44 20 21 22 00 4f 08 46 00
>26d6	86 20 42 58 28 4e 29 3a 86 20 42 59 28 4e 29 3a
>26e6	86 20 42 43 28 4e 29 00 63 08 4b 00 86 20 44 58
>26f6	28 4e 29 3a 86 20 44 59 28 4e 29 00 71 08 50 00
>2706	81 20 42 b2 30 20 a4 20 4e 00 8a 08 5a 00 42 58
>2716	28 42 29 b2 b5 28 bb 28 31 29 ac 34 30 29 ac 32
>2726	aa 31 00 a3 08 64 00 42 59 28 42 29 b2 b5 28 bb
>2736	28 31 29 ac 33 30 29 ac 32 35 36 00 ba 08 69 00
>2746	42 43 28 42 29 b2 b5 28 bb 28 31 29 ac 31 34 29
>2756	aa 31 00 ce 08 6a 00 44 58 28 42 29 b2 b5 28 bb
>2766	28 31 29 ac 32 29 00 e4 08 6c 00 8f 20 44 59 28
>2776	42 29 b2 b5 28 bb 28 31 29 ac 32 29 00 f0 08 6d
>2786	00 44 59 28 42 29 b2 31 00 f8 08 6e 00 82 20 42
>2796	00 fe 08 78 00 8f 00 12 09 82 00 81 59 b2 30 a4
>27a6	32 39 3a 81 58 b2 30 a4 33 39 00 28 09 8c 00 51
>27b6	b2 59 ac 32 35 36 aa 58 ac 32 aa 34 35 30 35 36
>27c6	00 40 09 96 00 ce 84 20 31 2c 51 2c 38 31 3a ce
>27d6	84 31 2c 51 aa 31 2c 30 00 49 09 a0 00 82 58 2c
>27e6	59 00 55 09 c8 00 81 20 42 b2 31 a4 4e 00 72 09
>27f6	d2 00 ce 84 20 31 2c 34 35 30 35 36 aa 42 59 28
>2806	42 29 aa 42 58 28 42 29 2c 30 00 80 09 e6 00 44
>2816	58 42 b2 44 58 28 42 29 00 91 09 f0 00 8b 44 58
>2826	42 b2 30 a7 8d 31 30 31 30 00 a2 09 fa 00 8b 44
>2836	58 42 b2 31 a7 8d 31 30 34 30 00 b0 09 ff 00 44
>2846	59 42 b2 44 59 28 42 29 00 c1 09 04 01 8b 44 59
>2856	42 b2 30 a7 8d 31 30 37 30 00 d2 09 0e 01 8b 44
>2866	59 42 b2 31 a7 8d 31 31 30 30 00 f3 09 18 01 ce
>2876	84 20 31 2c 34 35 30 35 36 aa 42 59 28 42 29 aa
>2886	42 58 28 42 29 2c 42 43 28 42 29 00 fa 09 22 01
>2896	82 42 00 04 0a 2c 01 89 20 32 30 30 00 0a 0a e8
>28a6	03 8f 00 18 0a f2 03 42 58 42 b2 42 58 28 42 29
>28b6	00 2d 0a f3 03 8b 42 58 42 b2 31 a7 44 58 28 42
>28c6	29 b2 31 3a 8e 00 3f 0a fc 03 42 58 28 42 29 b2
>28d6	42 58 42 ab 32 3a 8e 00 45 0a 06 04 8f 00 53 0a
>28e6	10 04 42 58 42 b2 42 58 28 42 29 00 73 0a 11 04
>28f6	8b 42 58 42 b2 37 39 a7 20 42 58 28 42 29 b2 37
>2906	37 3a 44 58 28 42 29 b2 30 3a 8e 00 85 0a 1a 04
>2916	42 58 28 42 29 b2 42 58 42 aa 32 3a 8e 00 8b 0a
>2926	24 04 8f 00 99 0a 2e 04 42 59 42 b2 42 59 28 42
>2936	29 00 ae 0a 2f 04 8b 42 59 42 b2 30 a7 44 59 28
>2946	42 29 b2 31 3a 8e 00 c2 0a 38 04 42 59 28 42 29
>2956	b2 42 59 42 ab 32 35 36 3a 8e 00 c8 0a 42 04 8f
>2966	00 d6 0a 4c 04 42 59 42 b2 42 59 28 42 29 00 f9
>2976	0a 4d 04 8b 42 59 42 b2 37 34 32 34 a7 42 59 28
>2986	42 29 b2 37 31 36 38 3a 44 59 28 42 29 b2 30 3a
>2996	8e 00 0d 0b 56 04 42 59 28 42 29 b2 42 59 42 aa
>29a6	32 35 36 3a 8e 00 00 00

;******  End of listing
