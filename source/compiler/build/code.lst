
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Wed Oct 11 11:04:39 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.0801					WrapperBoot:
.0801	a2 0d		ldx #$0d			ldx 	#APIDesc & $FF
.0803	a0 08		ldy #$08			ldy 	#APIDesc >> 8
.0805	20 77 09	jsr $0977			jsr 	StartCompiler
.0808					_WBError:
.0808	b0 fe		bcs $0808			bcs 	_WBError
.080a	4c ff ff	jmp $ffff			jmp 	$FFFF
.080d					APIDesc:
>080d	11 08						.word 	TestAPI 					; the testing API.
>080f	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>0810	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing file: testing/api/api.asm

=$a000					PCodeMemory = $A000
.0811					TestAPI:
.0811	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.0813	f0 19		beq $082e			beq 	_TAOpenIn
.0815	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.0817	f0 1d		beq $0836			beq 	_TACloseIn
.0819	c9 02		cmp #$02			cmp 	#BLC_READIN
.081b	f0 1a		beq $0837			beq 	_TARead
.081d	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.081f	f0 19		beq $083a			beq 	_TAResetOut
.0821	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.0823	f0 22		beq $0847			beq 	_TACloseOut
.0825	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.0827	f0 28		beq $0851			beq 	_TAWriteByte
.0829	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.082b	f0 2e		beq $085b			beq 	_TAPrintScreen
>082d	db						.byte 	$DB 						; causes a break in the emulator
.082e					_TAOpenIn:
.082e	a9 e3		lda #$e3			lda 	#((EndProgram+2) & $FF)
.0830	85 22		sta $22				sta 	0+srcInputPtr
.0832	a9 1e		lda #$1e			lda 	#((EndProgram+2) >> 8) & $FF
.0834	85 23		sta $23				sta 	1+srcInputPtr
.0836					_TACloseIn:
.0836	60		rts				rts
.0837					_TARead:
.0837	4c 5f 08	jmp $085f			jmp 	ReadNextLine
.083a					_TAResetOut:
.083a	a9 01		lda #$01			lda 	#1
.083c	85 00		sta $00				sta 	0
.083e	a9 00		lda #$00			lda 	#((PCodeMemory) & $FF)
.0840	85 28		sta $28				sta 	0+objPtr
.0842	a9 a0		lda #$a0			lda 	#((PCodeMemory) >> 8) & $FF
.0844	85 29		sta $29				sta 	1+objPtr
.0846	60		rts				rts
.0847					_TACloseOut:
.0847	a9 a0		lda #$a0			lda 	#PCodeMemory >> 8
.0849	a6 28		ldx $28				ldx 	objPtr
.084b	a4 29		ldy $29				ldy 	objPtr+1
.084d	20 84 08	jsr $0884			jsr 	APISaveMemory
.0850	60		rts				rts
.0851					_TAWriteByte:
.0851	8a		txa				txa
.0852	92 28		sta ($28)			sta 	(objPtr)
.0854	e6 28		inc $28				inc 	objPtr
.0856	d0 02		bne $085a			bne 	_HWOWBNoCarry
.0858	e6 29		inc $29				inc 	objPtr+1
.085a					_HWOWBNoCarry:
.085a	60		rts				rts
.085b					_TAPrintScreen:
.085b	8a		txa				txa
.085c	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.0022					srcInputPtr:
>0022							.fill 	2

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/line.asm

.085f					ReadNextLine:
.085f	b2 22		lda ($22)			lda 	(srcInputPtr) 				; reached the end of the program (address link = $0000)
.0861	a0 01		ldy #$01			ldy 	#1
.0863	11 22		ora ($22),y			ora 	(srcInputPtr),y
.0865	d0 02		bne $0869			bne 	_RLAHaveData
.0867	18		clc				clc
.0868	60		rts				rts									; end of file.
.0869					_RLAHaveData:
.0869	a6 22		ldx $22				ldx 	srcInputPtr 				; remember the line start
.086b	a4 23		ldy $23				ldy 	srcInputPtr+1
.086d	5a		phy				phy
.086e	a0 04		ldy #$04			ldy 	#4 							; must be at least four bytes (address/line#)
.0870					_RNLRead:
.0870	b1 22		lda ($22),y			lda 	(srcInputPtr),y 			; find the end of the line.
.0872	c8		iny				iny
.0873	c9 00		cmp #$00			cmp 	#0
.0875	d0 f9		bne $0870			bne 	_RNLRead
.0877	98		tya				tya 								; advance src input pointer to next.
.0878	18		clc				clc
.0879	65 22		adc $22				adc 	srcInputPtr
.087b	85 22		sta $22				sta 	srcInputPtr
.087d	90 02		bcc $0881			bcc 	_RNLNoCarry
.087f	e6 23		inc $23				inc 	srcInputPtr+1
.0881					_RNLNoCarry:
.0881	7a		ply				ply 								; address of line now in YX.
.0882	38		sec				sec
.0883	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/save.asm

.0884					APISaveMemory:
.0884	da		phx				phx
.0885	5a		phy				phy
.0886	48		pha				pha
.0887	a9 00		lda #$00			lda 	#0 							; set LFS
.0889	a2 08		ldx #$08			ldx 	#8
.088b	a0 00		ldy #$00			ldy 	#0
.088d	20 ba ff	jsr $ffba			jsr 	$FFBA
.0890	a9 08		lda #$08			lda 	#8 							; set file name
.0892	a2 a6		ldx #$a6			ldx 	#SaveName & $FF
.0894	a0 08		ldy #$08			ldy 	#SaveName >> 8
.0896	20 bd ff	jsr $ffbd			jsr 	$FFBD
.0899	68		pla				pla 								; set up the start address.
.089a	85 2b		sta $2b				sta 	zTemp0+1
.089c	64 2a		stz $2a				stz 	zTemp0
.089e	a9 2a		lda #$2a			lda 	#zTemp0 					; from index.
.08a0	7a		ply				ply 								; end in YX
.08a1	fa		plx				plx
.08a2	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.08a5	60		rts				rts
.08a6					SaveName:
>08a6	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Return to file: testing/testing.asm


;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.0024					srcPtr:
>0024							.fill 	2
.0400					currentLineNumber:
>0400							.fill 	2
.08ae					InlineNonDecimal:
.08ae	a2 02		ldx #$02			ldx 	#2 							; get size in X
.08b0	c9 25		cmp #$25			cmp 	#"%"
.08b2	f0 02		beq $08b6			beq 	_INDBinary
.08b4	a2 10		ldx #$10			ldx 	#16
.08b6					_INDBinary:
.08b6	85 2c		sta $2c				sta 	zTemp1 						; size => zTemp1
.08b8	64 2d		stz $2d				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.08ba	64 2a		stz $2a				stz 	zTemp0 						; zero result
.08bc	64 2b		stz $2b				stz 	zTemp0+1
.08be					_INDLoop:
.08be	20 5a 12	jsr $125a			jsr 	LookNext 					; check next character
.08c1	20 96 12	jsr $1296			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.08c4	90 1f		bcc $08e5			bcc		_INDDone 					; didn't convert
.08c6	c5 2c		cmp $2c				cmp 	zTemp1 						; size too large ?
.08c8	b0 1b		bcs $08e5			bcs 	_INDDone
.08ca	20 f4 08	jsr $08f4			jsr 	_INDShift 					; x 2 or x 16
.08cd	e0 02		cpx #$02			cpx 	#2
.08cf	f0 09		beq $08da			beq 	_INDNotHex
.08d1	20 f4 08	jsr $08f4			jsr 	_INDShift
.08d4	20 f4 08	jsr $08f4			jsr 	_INDShift
.08d7	20 f4 08	jsr $08f4			jsr 	_INDShift
.08da					_INDNotHex:
.08da	05 2a		ora $2a				ora 	zTemp0 						; or digit into result
.08dc	85 2a		sta $2a				sta 	zTemp0
.08de	20 6b 12	jsr $126b			jsr 	GetNext 					; consume
.08e1	e6 2d		inc $2d				inc 	zTemp1+1 					; bump count
.08e3	80 d9		bra $08be			bra 	_INDLoop
.08e5					_INDDone:
.08e5	a5 2d		lda $2d				lda 	zTemp1+1 					; done at least 1 ?
.08e7	f0 08		beq $08f1			beq 	_INDError
.08e9	a4 2b		ldy $2b				ldy 	zTemp0+1 					; push constant
.08eb	a5 2a		lda $2a				lda 	zTemp0
.08ed	20 16 0a	jsr $0a16			jsr 	PushIntegerYA
.08f0	60		rts				rts
.08f1					_INDError:
.08f1	4c 5f 17	jmp $175f		jmp	ErrorV_syntax
.08f4					_INDShift:
.08f4	06 2a		asl $2a				asl 	zTemp0
.08f6	26 2b		rol $2b				rol 	zTemp0+1
.08f8	60		rts				rts
.08f9					GetLineNumber:
.08f9	ac 01 04	ldy $0401			ldy 	currentLineNumber+1
.08fc	ad 00 04	lda $0400			lda 	currentLineNumber
.08ff	60		rts				rts
.0900					WriteCodeByte:
.0900	48		pha				pha 								; save on stack
.0901	da		phx				phx
.0902	5a		phy				phy
.0903	aa		tax				tax
.0904	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.0906	20 13 0a	jsr $0a13			jsr 	CallAPIHandler
.0909	7a		ply				ply 								; restore from stack
.090a	fa		plx				plx
.090b	68		pla				pla
.090c	60		rts				rts
.090d					PrintCharacter
.090d	48		pha				pha
.090e	da		phx				phx
.090f	5a		phy				phy
.0910	aa		tax				tax
.0911	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.0913	20 13 0a	jsr $0a13			jsr 	CallAPIHandler
.0916	7a		ply				ply
.0917	fa		plx				plx
.0918	68		pla				pla
.0919	60		rts				rts
.091a					ProcessNewLine:
.091a	86 2a		stx $2a				stx 	zTemp0 						; save address in zTemp0
.091c	84 2b		sty $2b				sty 	zTemp0+1
.091e	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.091f	8a		txa				txa
.0920	69 04		adc #$04			adc 	#4
.0922	85 24		sta $24				sta 	srcPtr
.0924	98		tya				tya
.0925	69 00		adc #$00			adc 	#0
.0927	85 25		sta $25				sta 	srcPtr+1
.0929	a0 02		ldy #$02			ldy 	#2							; read and save line number
.092b	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.092d	8d 00 04	sta $0400			sta 	currentLineNumber
.0930	c8		iny				iny
.0931	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0933	8d 01 04	sta $0401			sta 	currentLineNumber+1
.0936	60		rts				rts
.0937					BufferClear:
.0937	9c 02 04	stz $0402			stz 	bufferSize
.093a	60		rts				rts
.093b					BufferWrite:
.093b	da		phx				phx
.093c	ae 02 04	ldx $0402			ldx 	bufferSize
.093f	9d 03 04	sta $0403,x			sta 	dataBuffer,x
.0942	ee 02 04	inc $0402			inc 	bufferSize
.0945	fa		plx				plx
.0946	60		rts				rts
.0947					BufferOutput:
.0947	ad 02 04	lda $0402			lda 	bufferSize
.094a	20 00 09	jsr $0900			jsr 	WriteCodeByte
.094d	a2 00		ldx #$00			ldx 	#0
.094f					_BOLoop:
.094f	ec 02 04	cpx $0402			cpx 	bufferSize
.0952	f0 09		beq $095d			beq 	_BOExit
.0954	bd 03 04	lda $0403,x			lda 	dataBuffer,x
.0957	20 00 09	jsr $0900			jsr 	WriteCodeByte
.095a	e8		inx				inx
.095b	80 f2		bra $094f			bra 	_BOLoop
.095d					_BOExit:
.095d	60		rts				rts
.0402					bufferSize:
>0402							.fill 	1
.0403					dataBuffer:
>0403							.fill 	256
.095e					CheckNextComma:
.095e	a9 2c		lda #$2c			lda	 	#","
.0960	80 06		bra $0968			bra 	CheckNextA
.0962					CheckNextRParen:
.0962	a9 29		lda #$29			lda	 	#")"
.0964	80 02		bra $0968			bra 	CheckNextA
.0966					CheckNextLParen:
.0966	a9 28		lda #$28			lda 	#"("
.0968					CheckNextA:
.0968	8d 03 05	sta $0503			sta 	checkCharacter 				; save test character
.096b					_CNALoop:
.096b	20 76 12	jsr $1276			jsr 	GetNextNonSpace 			; get next skipping spaces.
.096e	cd 03 05	cmp $0503			cmp 	checkCharacter 				; matches ?
.0971	f0 03		beq $0976			beq 	_CNAExit
.0973	4c 5f 17	jmp $175f		jmp	ErrorV_syntax
.0976					_CNAExit:
.0976	60		rts				rts
.0503					checkCharacter:
>0503							.fill 	1
.0977					StartCompiler:
.0977	86 2a		stx $2a				stx 	zTemp0 						; access API
.0979	84 2b		sty $2b				sty 	zTemp0+1
.097b	a0 0b		ldy #$0b			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.097d	a2 cf		ldx #$cf			ldx 	#CompilerErrorHandler & $FF
.097f	20 38 17	jsr $1738			jsr 	SetErrorHandler
.0982	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.0984	b2 2a		lda ($2a)			lda 	(zTemp0)
.0986	8d 05 05	sta $0505			sta 	APIVector
.0989	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.098b	8d 06 05	sta $0506			sta 	APIVector+1
.098e	c8		iny				iny 								; copy data area range.
.098f	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0991	8d 07 05	sta $0507			sta 	compilerStartHigh
.0994	c8		iny				iny
.0995	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0997	8d 08 05	sta $0508			sta 	compilerEndHigh
.099a	ba		tsx				tsx 								; save stack pointer
.099b	8e 04 05	stx $0504			stx 	compilerSP
.099e	20 fa 15	jsr $15fa			jsr 	STRReset 					; reset storage (line#, variable)
.09a1	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.09a3	20 13 0a	jsr $0a13			jsr 	CallAPIHandler
.09a6	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.09a8	20 13 0a	jsr $0a13			jsr 	CallAPIHandler
.09ab	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.09ad	20 00 09	jsr $0900			jsr 	WriteCodeByte
.09b0	a9 00		lda #$00			lda 	#0
.09b2	20 00 09	jsr $0900			jsr 	WriteCodeByte
.09b5	20 00 09	jsr $0900			jsr 	WriteCodeByte
.09b8					MainCompileLoop:
.09b8	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.09ba	20 13 0a	jsr $0a13			jsr 	CallAPIHandler
.09bd	90 31		bcc $09f0			bcc 	SaveCodeAndExit 			; end of source.
.09bf	20 1a 09	jsr $091a			jsr 	ProcessNewLine 				; set up pointer and line number.
.09c2	20 f9 08	jsr $08f9			jsr 	GetLineNumber 				; get line #
.09c5	20 e4 13	jsr $13e4			jsr 	STRMarkLine 				; remember the code position and number of this line.
.09c8	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.09ca	20 00 09	jsr $0900			jsr 	WriteCodeByte
.09cd					_MCLSameLine:
.09cd	20 76 12	jsr $1276			jsr 	GetNextNonSpace 			; get the first character.
.09d0	f0 e6		beq $09b8			beq 	MainCompileLoop 			; end of line, get next line.
.09d2	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.09d4	f0 f7		beq $09cd			beq 	_MCLSameLine
.09d6	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.09d8	10 0c		bpl $09e6			bpl 	_MCLCheckAssignment
.09da	a2 34		ldx #$34			ldx 	#CommandTables & $FF 		; do command tables.
.09dc	a0 0e		ldy #$0e			ldy 	#CommandTables >> 8
.09de	20 fc 10	jsr $10fc			jsr 	GeneratorProcess
.09e1	b0 ea		bcs $09cd			bcs 	_MCLSameLine 				; keep trying to compile the line.
.09e3					_MCLSyntax:
.09e3	4c 5f 17	jmp $175f		jmp	ErrorV_syntax
.09e6					_MCLCheckAssignment:
.09e6	20 8c 12	jsr $128c			jsr 	CharIsAlpha 				; if not alpha then syntax error
.09e9	90 f8		bcc $09e3			bcc 	_MCLSyntax
.09eb	20 b2 13	jsr $13b2			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.09ee	80 dd		bra $09cd			bra		_MCLSameLine 				; loop back.
.09f0					SaveCodeAndExit:
.09f0	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.09f2	20 13 0a	jsr $0a13			jsr 	CallAPIHandler
.09f5	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.09f7	a8		tay				tay
.09f8	20 e4 13	jsr $13e4			jsr 	STRMarkLine
.09fb	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.09fd	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0a00	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.0a02	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0a05	20 2c 0d	jsr $0d2c			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.0a08	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.0a0a	20 13 0a	jsr $0a13			jsr 	CallAPIHandler
.0a0d	18		clc				clc 								; CC = success
.0a0e					ExitCompiler:
.0a0e	ae 04 05	ldx $0504			ldx 	compilerSP 					; reload SP and exit.
.0a11	9a		txs				txs
.0a12	60		rts				rts
.0a13					CallAPIHandler:
.0a13	6c 05 05	jmp ($0505)			jmp 	(APIVector)
.0504					compilerSP:
>0504							.fill 	1
.0505					APIVector:
>0505							.fill 	2
.0507					compilerStartHigh:
>0507							.fill 	1
.0508					compilerEndHigh:
>0508							.fill 	1
.0a16					PushIntegerYA:
.0a16	c0 00		cpy #$00			cpy 	#0 							; 0-255
.0a18	f0 0f		beq $0a29			beq 	PushIntegerA
.0a1a	48		pha				pha
.0a1b	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.0a1d	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0a20	68		pla				pla 								; then LSB
.0a21	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0a24	98		tya				tya 								; then MSB
.0a25	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0a28	60		rts				rts
.0a29					PushIntegerA:
.0a29	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.0a2b	90 07		bcc $0a34			bcc 	_PIWriteA
.0a2d	48		pha				pha
.0a2e	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.0a30	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0a33	68		pla				pla
.0a34					_PIWriteA:
.0a34	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0a37	60		rts				rts
.0a38					PushFloatCommand:
.0a38	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.0a3a	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0a3d	b5 6c		lda $6c,x			lda 	NSExponent,x 				; and the data
.0a3f	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0a42	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.0a44	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0a47	b5 48		lda $48,x			lda 	NSMantissa1,x
.0a49	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0a4c	b5 54		lda $54,x			lda 	NSMantissa2,x
.0a4e	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0a51	b5 30		lda $30,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.0a53	29 80		and #$80			and 	#$80
.0a55	15 60		ora $60,x			ora 	NSMantissa3,x
.0a57	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0a5a	60		rts				rts
.0a5b					CreateVariableRecord:
.0a5b	48		pha				pha
.0a5c	ad 13 05	lda $0513			lda 	freeVariableMemory 		; push current free address on stack.
.0a5f	48		pha				pha
.0a60	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.0a63	48		pha				pha
.0a64	ad 11 05	lda $0511			lda 	variableListEnd  		; copy end of list to zTemp0
.0a67	85 2a		sta $2a				sta 	zTemp0
.0a69	ad 12 05	lda $0512			lda 	variableListEnd+1
.0a6c	85 2b		sta $2b				sta 	zTemp0+1
.0a6e	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.0a70	92 2a		sta ($2a)			sta 	(zTemp0)
.0a72	98		tya				tya
.0a73	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.0a75	91 2a		sta ($2a),y			sta 	(zTemp0),y
.0a77	88		dey				dey
.0a78	8a		txa				txa
.0a79	91 2a		sta ($2a),y			sta 	(zTemp0),y
.0a7b	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.0a7d	ad 13 05	lda $0513			lda 	freeVariableMemory
.0a80	91 2a		sta ($2a),y			sta 	(zTemp0),y
.0a82	c8		iny				iny
.0a83	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.0a86	91 2a		sta ($2a),y			sta 	(zTemp0),y
.0a88	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.0a8a	a9 00		lda #$00			lda 	#0
.0a8c	91 2a		sta ($2a),y			sta 	(zTemp0),y
.0a8e	18		clc				clc
.0a8f	b2 2a		lda ($2a)			lda 	(zTemp0) 				; add offset to variableListEnd
.0a91	6d 11 05	adc $0511			adc  	variableListEnd
.0a94	8d 11 05	sta $0511			sta 	variableListEnd
.0a97	90 03		bcc $0a9c			bcc 	_CVNoCarry2
.0a99	ee 12 05	inc $0512			inc 	variableListEnd+1
.0a9c					_CVNoCarry2:
.0a9c	7a		ply				ply
.0a9d	fa		plx				plx
.0a9e	68		pla				pla
.0a9f	60		rts				rts
.0aa0					SetVariableRecordToCodePosition:
.0aa0	48		pha				pha
.0aa1	5a		phy				phy
.0aa2	a0 03		ldy #$03			ldy 	#3
.0aa4	a5 29		lda $29				lda 	objPtr+1
.0aa6	91 2a		sta ($2a),y			sta 	(zTemp0),y
.0aa8	c8		iny				iny
.0aa9	a5 28		lda $28				lda 	objPtr
.0aab	91 2a		sta ($2a),y			sta 	(zTemp0),y
.0aad	7a		ply				ply
.0aae	68		pla				pla
.0aaf	60		rts				rts
.0ab0					AllocateBytesForType:
.0ab0	48		pha				pha
.0ab1	da		phx				phx
.0ab2	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.0ab4	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0ab6	c9 00		cmp #$00			cmp 	#NSSIFloat
.0ab8	d0 02		bne $0abc			bne 	_CVNotFloat
.0aba	a2 06		ldx #$06			ldx 	#6
.0abc					_CVNotFloat:
.0abc	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.0abd	18		clc				clc
.0abe	6d 13 05	adc $0513			adc 	freeVariableMemory
.0ac1	8d 13 05	sta $0513			sta 	freeVariableMemory
.0ac4	90 03		bcc $0ac9			bcc 	_CVNoCarry1
.0ac6	ee 14 05	inc $0514			inc 	freeVariableMemory+1
.0ac9					_CVNoCarry1:
.0ac9	fa		plx				plx
.0aca	68		pla				pla
.0acb	60		rts				rts
.0acc					CommandDATA:
.0acc	20 37 09	jsr $0937			jsr 	BufferClear 				; copy it to the buffer
.0acf	20 5d 12	jsr $125d			jsr 	LookNextNonSpace
.0ad2					_CTDataLoop:
.0ad2	20 5a 12	jsr $125a			jsr 	LookNext 					; reached EOL
.0ad5	f0 08		beq $0adf			beq 	_CTDataDone
.0ad7	20 3b 09	jsr $093b			jsr 	BufferWrite 				; write and consume
.0ada	20 6b 12	jsr $126b			jsr 	GetNext
.0add	80 f3		bra $0ad2			bra 	_CTDataLoop
.0adf					_CTDataDone:
.0adf	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.0ae1	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0ae4	20 47 09	jsr $0947			jsr 	BufferOutput
.0ae7	60		rts				rts
.0ae8					CommandDEF:
.0ae8	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.0aea	20 29 0a	jsr $0a29			jsr 	PushIntegerA
.0aed	20 7b 13	jsr $137b			jsr 	CompileGotoEOL 				; compile skip over DEF
.0af0	a9 a5		lda #$a5			lda 	#C64_FN
.0af2	20 68 09	jsr $0968			jsr 	CheckNextA
.0af5	20 76 12	jsr $1276			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.0af8	20 db 12	jsr $12db			jsr 	ExtractVariableName
.0afb	8a		txa				txa
.0afc	10 51		bpl $0b4f			bpl 	_CDError
.0afe	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.0aff	29 7f		and #$7f			and 	#$7F
.0b01	aa		tax				tax
.0b02	98		tya				tya
.0b03	09 80		ora #$80			ora 	#$80
.0b05	a8		tay				tay
.0b06	20 d0 0c	jsr $0cd0			jsr 	FindVariable				; does it already exist ?
.0b09	b0 44		bcs $0b4f			bcs 	_CDError 					; if so, that's an error.
.0b0b	20 5b 0a	jsr $0a5b			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.0b0e	20 a0 0a	jsr $0aa0			jsr 	SetVariableRecordToCodePosition
.0b11	20 76 12	jsr $1276			jsr 	GetNextNonSpace
.0b14	20 b7 15	jsr $15b7			jsr 	GetReferenceTerm 			; get var ref, not array
.0b17	c9 00		cmp #$00			cmp 	#0
.0b19	30 34		bmi $0b4f			bmi 	_CDError
.0b1b	8d 09 05	sta $0509			sta 	defType 					; save type
.0b1e	8e 0a 05	stx $050a			stx 	defVariable 				; save var ref
.0b21	8c 0b 05	sty $050b			sty 	defVariable+1
.0b24	29 40		and #$40			and 	#NSSString 					; only numbers.
.0b26	d0 27		bne $0b4f			bne 	_CDError
.0b28	20 62 09	jsr $0962			jsr 	CheckNextRParen 			; check )
.0b2b	a9 b2		lda #$b2			lda 	#C64_EQUAL
.0b2d	20 68 09	jsr $0968			jsr 	CheckNextA 					; check =
.0b30	18		clc				clc 								; if this is DEF FNxx(A), read A
.0b31	20 52 0b	jsr $0b52			jsr 	CDReadWriteVariable
.0b34	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.0b36	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0b39	38		sec				sec
.0b3a	20 52 0b	jsr $0b52			jsr 	CDReadWriteVariable 		; A is now updated
.0b3d	20 16 0c	jsr $0c16			jsr 	CompileExpressionAt0 		; the actual body of the function.
.0b40	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.0b42	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0b45	38		sec				sec
.0b46	20 52 0b	jsr $0b52			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.0b49	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.0b4b	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0b4e	60		rts				rts
.0b4f					_CDError:
.0b4f	4c 5f 17	jmp $175f		jmp	ErrorV_syntax
.0b52					CDReadWriteVariable:
.0b52	ac 0b 05	ldy $050b			ldy 	defVariable+1 				; set up YX
.0b55	ae 0a 05	ldx $050a			ldx 	defVariable
.0b58	ad 09 05	lda $0509			lda 	defType
.0b5b	20 69 15	jsr $1569			jsr 	GetSetVariable
.0b5e	60		rts				rts
.0509					defType:
>0509							.fill 	1
.050a					defVariable:
>050a							.fill 	2
.0b5f					CommandDIM:
.0b5f	20 76 12	jsr $1276			jsr 	GetNextNonSpace 			; get the first non space character
.0b62	20 db 12	jsr $12db			jsr 	ExtractVariableName 		; variable name to XY
.0b65	da		phx				phx 								; save name with type bits.
.0b66	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.0b68	10 37		bpl $0ba1			bpl 	_CDError
.0b6a	20 d0 0c	jsr $0cd0			jsr 	FindVariable	 			; see if already exist
.0b6d	b0 35		bcs $0ba4			bcs 	_CDRedefine 				; it still exists.
.0b6f	20 5b 0a	jsr $0a5b			jsr 	CreateVariableRecord 		; create the basic variable
.0b72	20 b0 0a	jsr $0ab0			jsr 	AllocateBytesForType 		; allocate memory for it
.0b75	68		pla				pla 								; restore type bits
.0b76	5a		phy				phy 								; save the address of the basic storage
.0b77	da		phx				phx
.0b78	48		pha				pha
.0b79	20 a7 0b	jsr $0ba7			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.0b7c	68		pla				pla
.0b7d	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.0b7f	20 29 0a	jsr $0a29			jsr 	PushIntegerA 				; push that type data out.
.0b82	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.0b84	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0b87	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.0b89	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0b8c	fa		plx				plx 								; restore address
.0b8d	7a		ply				ply
.0b8e	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.0b90	38		sec				sec
.0b91	20 69 15	jsr $1569			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.0b94	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; , follows ?
.0b97	c9 2c		cmp #$2c			cmp 	#","
.0b99	d0 05		bne $0ba0			bne 	_CDExit
.0b9b	20 6b 12	jsr $126b			jsr 	GetNext 					; consume comma
.0b9e	80 bf		bra $0b5f			bra 	CommandDIM 					; do another DIM
.0ba0					_CDExit:
.0ba0	60		rts				rts
.0ba1					_CDError:
.0ba1	4c 5f 17	jmp $175f		jmp	ErrorV_syntax
.0ba4					_CDRedefine:
.0ba4	4c 27 18	jmp $1827		jmp	ErrorV_redefine
.0ba7					OutputIndexGroup:
.0ba7	9c 0c 05	stz $050c			stz 	IndexCount 					; count of number of indices.
.0baa					_OIGNext:
.0baa	20 16 0c	jsr $0c16			jsr 	CompileExpressionAt0 		; get a dimension
.0bad	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.0baf	c9 00		cmp #$00			cmp 	#NSSIFloat
.0bb1	d0 19		bne $0bcc			bne 	_OIGType
.0bb3	ee 0c 05	inc $050c			inc 	IndexCount 					; bump the counter.
.0bb6	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; does a , follow ?
.0bb9	c9 2c		cmp #$2c			cmp 	#","
.0bbb	d0 05		bne $0bc2			bne 	_OIGCheckEnd
.0bbd	20 6b 12	jsr $126b			jsr 	GetNext 					; consume comma
.0bc0	80 e8		bra $0baa			bra 	_OIGNext 					; get next dimension
.0bc2					_OIGCheckEnd:
.0bc2	20 62 09	jsr $0962			jsr 	CheckNextRParen 			; check and consume )
.0bc5	ad 0c 05	lda $050c			lda 	IndexCount
.0bc8	20 29 0a	jsr $0a29			jsr 	PushIntegerA 				; compile the dimension count.
.0bcb	60		rts				rts
.0bcc					_OIGType:
.0bcc	4c 6f 17	jmp $176f		jmp	ErrorV_type
.050c					IndexCount:
>050c							.fill 	1
.0bcf					CompilerErrorHandler:
.0bcf	68		pla				pla
.0bd0	7a		ply				ply
.0bd1	85 2a		sta $2a				sta 	zTemp0
.0bd3	84 2b		sty $2b				sty 	zTemp0+1
.0bd5	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.0bd7	a0 01		ldy #$01			ldy 	#1
.0bd9					_EHDisplayMsg:
.0bd9	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0bdb	20 0d 09	jsr $090d			jsr 	PrintCharacter
.0bde	c8		iny				iny
.0bdf	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0be1	d0 f6		bne $0bd9			bne 	_EHDisplayMsg
.0be3	a9 20		lda #$20			lda 	#32
.0be5	20 0d 09	jsr $090d			jsr 	PrintCharacter
.0be8	a9 40		lda #$40			lda 	#64
.0bea	20 0d 09	jsr $090d			jsr 	PrintCharacter
.0bed	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.0bef	20 b8 1e	jsr $1eb8			jsr 	FloatSetByte
.0bf2	20 f9 08	jsr $08f9			jsr 	GetLineNumber
.0bf5	95 3c		sta $3c,x			sta 	NSMantissa0,x
.0bf7	98		tya				tya
.0bf8	95 48		sta $48,x			sta 	NSMantissa1,x
.0bfa	20 9e 1d	jsr $1d9e			jsr 	FloatToString
.0bfd	a0 00		ldy #$00			ldy 	#0 							; display that string.
.0bff	a2 00		ldx #$00			ldx 	#0
.0c01					_EHDisplayLine:
.0c01	b9 3e 05	lda $053e,y			lda 	decimalBuffer,y
.0c04	20 0d 09	jsr $090d			jsr 	PrintCharacter
.0c07	c8		iny				iny
.0c08	b9 3e 05	lda $053e,y			lda 	decimalBuffer,y
.0c0b	d0 f4		bne $0c01			bne 	_EHDisplayLine
.0c0d	a9 0d		lda #$0d			lda 	#13
.0c0f	20 0d 09	jsr $090d			jsr 	PrintCharacter
.0c12	38		sec				sec 								; CS = error
.0c13	4c 0e 0a	jmp $0a0e			jmp 	ExitCompiler
.0c16					CompileExpressionAt0:
.0c16	a9 00		lda #$00			lda 	#0
.0c18					CompileExpressionAtA:
.0c18	48		pha				pha  								; save level
.0c19	20 22 16	jsr $1622			jsr 	CompileTerm 				; compile a term.
.0c1c	fa		plx				plx 								; get level back into X
.0c1d					_ECALoop:
.0c1d	48		pha				pha 								; save type on stack.
.0c1e	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; get the next character
.0c21	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.0c23	90 04		bcc $0c29			bcc 	_ECAExit
.0c25	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.0c27	90 02		bcc $0c2b			bcc 	_ECAHaveToken
.0c29					_ECAExit:
.0c29	68		pla				pla 								; throw type off stack
.0c2a	60		rts				rts
.0c2b					_ECAHaveToken:
.0c2b	86 2a		stx $2a				stx 	zTemp0 						; save current precedence in zTemp0
.0c2d	aa		tax				tax 								; X contains the operator token
.0c2e	bd 19 0c	lda $0c19,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.0c31	c5 2a		cmp $2a				cmp 	zTemp0 						; if < then exit
.0c33	90 f4		bcc $0c29			bcc 	_ECAExit
.0c35	85 2b		sta $2b				sta 	zTemp0+1 					; save the precedence of the operator.
.0c37	20 6b 12	jsr $126b			jsr 	GetNext 					; consume the token.
.0c3a	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.0c3c	f0 11		beq $0c4f			beq 	_ECAGreaterCheck
.0c3e	e0 b3		cpx #$b3			cpx 	#C64_LESS
.0c40	d0 1a		bne $0c5c			bne 	_ECAHaveFullToken
.0c42	20 5a 12	jsr $125a			jsr 	LookNext 					; checks for < (<= or <>)
.0c45	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.0c47	f0 0e		beq $0c57			beq	 	_ECAToNotEqual
.0c49	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.0c4b	d0 0f		bne $0c5c			bne 	_ECAHaveFullToken
.0c4d	80 07		bra $0c56			bra 	_ECAAddEqual
.0c4f					_ECAGreaterCheck:
.0c4f	20 5a 12	jsr $125a			jsr 	LookNext
.0c52	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.0c54	d0 06		bne $0c5c			bne 	_ECAHaveFullToken
.0c56					_ECAAddEqual:
.0c56	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.0c57					_ECAToNotEqual:
.0c57	e8		inx				inx
.0c58	e8		inx				inx
.0c59	20 6b 12	jsr $126b			jsr 	GetNext 					; consume the = or > in >= <= <>
.0c5c					_ECAHaveFullToken:
.0c5c	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.0c5e	d0 0a		bne $0c6a			bne 	_ECANotConcat
.0c60	68		pla				pla 								; get type back
.0c61	48		pha				pha
.0c62	29 40		and #$40			and 	#NSSTypeMask
.0c64	c9 40		cmp #$40			cmp 	#NSSString
.0c66	d0 02		bne $0c6a			bne 	_ECANotConcat
.0c68	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.0c6a					_ECANotConcat:
.0c6a	da		phx				phx 								; save operator on the stack
.0c6b	a6 2a		ldx $2a				ldx 	zTemp0 						; push current precedence on the stack
.0c6d	da		phx				phx
.0c6e	a5 2b		lda $2b				lda 	zTemp0+1 					; get precedence of operator
.0c70	1a		inc a				inc 	a
.0c71	20 18 0c	jsr $0c18			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.0c74	85 2a		sta $2a				sta 	zTemp0 						; save type in zTemp0
.0c76	fa		plx				plx 								; restore current precedence in X
.0c77	68		pla				pla 								; restore operator
.0c78	85 2b		sta $2b				sta 	zTemp0+1 					; save it in zTemp0+1.
.0c7a	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.0c7c	90 17		bcc $0c95			bcc 	_ECANotCompare
.0c7e	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.0c80	b0 13		bcs $0c95			bcs 	_ECANotCompare
.0c82	7a		ply				ply 								; get type into Y
.0c83	5a		phy				phy
.0c84	48		pha				pha 								; save operator
.0c85	98		tya				tya 								; get type
.0c86	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.0c88	29 40		and #$40			and 	#NSSTypeMask
.0c8a	c9 40		cmp #$40			cmp 	#NSSString
.0c8c	f0 02		beq $0c90			beq 	_ECANotString
.0c8e	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.0c90					_ECANotString:
.0c90	98		tya				tya									; output token Y
.0c91	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0c94	68		pla				pla 								; restore operator.
.0c95					_ECANotCompare:
.0c95	18		clc				clc 								; convert to P-Code and compile.
.0c96	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.0c98	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0c9b	68		pla				pla 								; type of current result
.0c9c	45 2a		eor $2a				eor 	zTemp0 						; check compatible with r-expr type
.0c9e	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.0ca0	d0 19		bne $0cbb			bne		_ECAType
.0ca2	a5 2a		lda $2a				lda 	zTemp0 						; get type back
.0ca4	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.0ca6	d0 18		bne $0cc0			bne 	_ECAGoLoop
.0ca8	a5 2b		lda $2b				lda 	zTemp0+1 					; check operator is + or comparator
.0caa	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.0cac	f0 10		beq $0cbe			beq 	_ECAOkayString 				; (this is post conversion)
.0cae	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.0cb0	90 09		bcc $0cbb			bcc 	_ECAType
.0cb2	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.0cb4	b0 05		bcs $0cbb			bcs 	_ECAType
.0cb6	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.0cb8	4c 1d 0c	jmp $0c1d			jmp 	_ECALoop
.0cbb					_ECAType:
.0cbb	4c 6f 17	jmp $176f		jmp	ErrorV_type
.0cbe					_ECAOkayString:
.0cbe	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.0cc0					_ECAGoLoop:
.0cc0	4c 1d 0c	jmp $0c1d			jmp 	_ECALoop
.0cc3					PrecedenceTable:
>0cc3	03						.byte 	3 					; '+'
>0cc4	03						.byte 	3 					; '-'
>0cc5	04						.byte 	4 					; '*'
>0cc6	04						.byte 	4 					; '/'
>0cc7	05						.byte 	5 					; '^'
>0cc8	01						.byte 	1 					; 'and'
>0cc9	00						.byte 	0 					; 'or'
>0cca	02						.byte 	2 					; '>'
>0ccb	02						.byte 	2 					; '='
>0ccc	02						.byte 	2 					; '<'
>0ccd	02						.byte 	2 					; '>='
>0cce	02						.byte 	2 					; '<='
>0ccf	02						.byte 	2 					; '<>'
.0cd0					FindVariable:
.0cd0	86 2c		stx $2c				stx 	zTemp1 						; save name.
.0cd2	84 2d		sty $2d				sty 	zTemp1+1
.0cd4					_IVCheckSpecial:
.0cd4	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.0cd6	d0 18		bne $0cf0			bne 	_IVStandard
.0cd8	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.0cda	f0 0c		beq $0ce8			beq 	_IVTIFloat
.0cdc	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.0cde	d0 10		bne $0cf0			bne 	_IVStandard
.0ce0	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.0ce2	a2 01		ldx #$01			ldx 	#$01
.0ce4	a9 40		lda #$40			lda 	#NSSString
.0ce6	38		sec				sec
.0ce7	60		rts				rts
.0ce8					_IVTIFloat:
.0ce8	a0 80		ldy #$80			ldy 	#$80
.0cea	a2 00		ldx #$00			ldx 	#$00
.0cec	a9 00		lda #$00			lda 	#0
.0cee	38		sec				sec
.0cef	60		rts				rts
.0cf0					_IVStandard:
.0cf0	ad 07 05	lda $0507			lda 	compilerStartHigh			; start scanning from here.
.0cf3	85 2b		sta $2b				sta 	zTemp0+1
.0cf5	64 2a		stz $2a				stz 	zTemp0
.0cf7					_IVCheckLoop:
.0cf7	b2 2a		lda ($2a)			lda 	(zTemp0) 					; finished ?
.0cf9	f0 2b		beq $0d26			beq  	_IVNotFound 				; if so, return with CC.
.0cfb	a0 01		ldy #$01			ldy 	#1 							; match ?
.0cfd	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0cff	c5 2c		cmp $2c				cmp 	zTemp1
.0d01	d0 07		bne $0d0a			bne	 	_IVNext
.0d03	c8		iny				iny
.0d04	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0d06	c5 2d		cmp $2d				cmp 	zTemp1+1
.0d08	f0 0d		beq $0d17			beq 	_IVFound
.0d0a					_IVNext:
.0d0a	18		clc				clc
.0d0b	a5 2a		lda $2a				lda 	zTemp0
.0d0d	72 2a		adc ($2a)			adc 	(zTemp0)
.0d0f	85 2a		sta $2a				sta 	zTemp0
.0d11	90 e4		bcc $0cf7			bcc 	_IVCheckLoop
.0d13	e6 2b		inc $2b				inc 	zTemp0+1
.0d15	80 e0		bra $0cf7			bra 	_IVCheckLoop
.0d17					_IVFound:
.0d17	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.0d19	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0d1b	aa		tax				tax
.0d1c	c8		iny				iny
.0d1d	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0d1f	48		pha				pha
.0d20	c8		iny				iny
.0d21	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.0d23	7a		ply				ply
.0d24	38		sec				sec
.0d25	60		rts				rts
.0d26					_IVNotFound:
.0d26	a6 2c		ldx $2c				ldx 	zTemp1 						; get variable name back
.0d28	a4 2d		ldy $2d				ldy 	zTemp1+1
.0d2a	18		clc				clc
.0d2b	60		rts				rts
.0d2c					FixBranches:
.0d2c	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.0d2e	20 13 0a	jsr $0a13			jsr 	CallAPIHandler
.0d31					_FBLoop:
.0d31	b2 28		lda ($28)			lda 	(objPtr) 					; get the next one.
.0d33	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.0d35	f0 16		beq $0d4d			beq 	_FBFixGotoGosub
.0d37	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.0d39	f0 12		beq $0d4d			beq 	_FBFixGotoGosub
.0d3b	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.0d3d	f0 0e		beq $0d4d			beq 	_FBFixGotoGosub
.0d3f	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.0d41	f0 0a		beq $0d4d			beq 	_FBFixGotoGosub
.0d43	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.0d45	f0 3b		beq $0d82			beq 	_FBFixVarSpace
.0d47					_FBNext:
.0d47	20 85 18	jsr $1885			jsr 	MoveObjectForward 			; move forward in object code.
.0d4a	90 e5		bcc $0d31			bcc 	_FBLoop 					; not finished
.0d4c					_FBExit:
.0d4c	60		rts				rts
.0d4d					_FBFixGotoGosub:
.0d4d	a0 01		ldy #$01			ldy 	#1							; line number in YA
.0d4f	b1 28		lda ($28),y			lda 	(objPtr),y
.0d51	48		pha				pha
.0d52	c8		iny				iny
.0d53	b1 28		lda ($28),y			lda 	(objPtr),y
.0d55	a8		tay				tay
.0d56	68		pla				pla
.0d57	20 0d 14	jsr $140d			jsr 	STRFindLine			 		; find where it is YA
.0d5a	90 08		bcc $0d64			bcc 	_FBFFound 					; not found, so must be >
.0d5c	48		pha				pha
.0d5d	b2 28		lda ($28)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.0d5f	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.0d61	d0 0f		bne $0d72			bne 	_FBFFail
.0d63	68		pla				pla
.0d64					_FBFFound:
.0d64	20 5d 14	jsr $145d			jsr 	STRMakeOffset 				; make it an offset from X:YA
.0d67	5a		phy				phy	 								; patch the GOTO/GOSUB
.0d68	a0 01		ldy #$01			ldy 	#1
.0d6a	91 28		sta ($28),y			sta 	(objPtr),y
.0d6c	c8		iny				iny
.0d6d	68		pla				pla
.0d6e	91 28		sta ($28),y			sta 	(objPtr),y
.0d70	80 d5		bra $0d47			bra 	_FBNext
.0d72					_FBFFail:
.0d72	a0 02		ldy #$02			ldy 	#2
.0d74	b1 28		lda ($28),y			lda 	(objPtr),y
.0d76	8d 00 04	sta $0400			sta 	currentLineNumber
.0d79	c8		iny				iny
.0d7a	b1 28		lda ($28),y			lda 	(objPtr),y
.0d7c	8d 01 04	sta $0401			sta 	currentLineNumber+1
.0d7f	4c a2 17	jmp $17a2		jmp	ErrorV_line
.0d82					_FBFixVarSpace:
.0d82	a0 01		ldy #$01			ldy 	#1
.0d84	ad 13 05	lda $0513			lda 	freeVariableMemory
.0d87	91 28		sta ($28),y			sta 	(objPtr),y
.0d89	c8		iny				iny
.0d8a	ad 14 05	lda $0514			lda 	freeVariableMemory+1
.0d8d	91 28		sta ($28),y			sta 	(objPtr),y
.0d8f	80 b6		bra $0d47			bra 	_FBNext
.0d91					CommandFOR:
.0d91	20 76 12	jsr $1276			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.0d94	20 8c 12	jsr $128c			jsr 	CharIsAlpha 				; if not alpha , error
.0d97	90 59		bcc $0df2			bcc 	_CFFail
.0d99	20 b7 15	jsr $15b7			jsr 	GetReferenceTerm 			; figure out the reference.
.0d9c	48		pha				pha 								; save type
.0d9d	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.0d9f	c9 00		cmp #$00			cmp 	#NSSIFloat
.0da1	d0 4f		bne $0df2			bne 	_CFFail
.0da3	5a		phy				phy 								; save reference on the stack
.0da4	da		phx				phx
.0da5	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.0da7	20 68 09	jsr $0968			jsr 	CheckNextA
.0daa	20 16 0c	jsr $0c16			jsr 	CompileExpressionAt0 		; initial value
.0dad	fa		plx				plx 								; get reference back.
.0dae	7a		ply				ply
.0daf	5a		phy				phy
.0db0	da		phx				phx
.0db1	38		sec				sec 								; set initial value.
.0db2	20 69 15	jsr $1569			jsr 	GetSetVariable
.0db5	fa		plx				plx
.0db6	7a		ply				ply
.0db7	68		pla				pla
.0db8	29 20		and #$20			and 	#NSSIInt16
.0dba	f0 04		beq $0dc0			beq 	_CFNotInt16
.0dbc	98		tya				tya
.0dbd	09 80		ora #$80			ora 	#$80
.0dbf	a8		tay				tay
.0dc0					_CFNotInt16:
.0dc0	8a		txa				txa 								; reference in YA
.0dc1	20 16 0a	jsr $0a16			jsr 	PushIntegerYA
.0dc4	a9 a4		lda #$a4			lda 	#C64_TO
.0dc6	20 68 09	jsr $0968			jsr 	CheckNextA
.0dc9	20 16 0c	jsr $0c16			jsr 	CompileExpressionAt0 		; terminal value
.0dcc	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.0dce	c9 00		cmp #$00			cmp 	#NSSIFloat
.0dd0	d0 20		bne $0df2			bne 	_CFFail
.0dd2	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; followed by STEP
.0dd5	c9 a9		cmp #$a9			cmp 	#C64_STEP
.0dd7	d0 0e		bne $0de7			bne 	_CFNoStep
.0dd9	20 6b 12	jsr $126b			jsr 	GetNext 					; consume it.
.0ddc	20 16 0c	jsr $0c16			jsr 	CompileExpressionAt0 		; terminal value
.0ddf	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.0de1	c9 00		cmp #$00			cmp 	#NSSIFloat
.0de3	d0 0d		bne $0df2			bne 	_CFFail
.0de5	80 05		bra $0dec			bra 	_CFParametersDone
.0de7					_CFNoStep:
.0de7	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.0de9	20 29 0a	jsr $0a29			jsr 	PushIntegerA
.0dec					_CFParametersDone:
.0dec	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.0dee	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0df1	60		rts				rts
.0df2					_CFFail:
.0df2	4c 5f 17	jmp $175f		jmp	ErrorV_syntax
.0df5					FNCompile:
.0df5	20 76 12	jsr $1276			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.0df8	20 db 12	jsr $12db			jsr 	ExtractVariableName
.0dfb	e0 00		cpx #$00			cpx 	#0
.0dfd	10 32		bpl $0e31			bpl 	_FNError
.0dff	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.0e00	29 7f		and #$7f			and 	#$7F
.0e02	aa		tax				tax
.0e03	98		tya				tya
.0e04	09 80		ora #$80			ora 	#$80
.0e06	a8		tay				tay
.0e07	20 d0 0c	jsr $0cd0			jsr 	FindVariable				; does it already exist ?
.0e0a	90 25		bcc $0e31			bcc 	_FNError 					; no.
.0e0c	20 5d 14	jsr $145d			jsr 	STRMakeOffset 				; convert to a relative address.
.0e0f	c9 00		cmp #$00			cmp 	#0 							; fix up.
.0e11	d0 01		bne $0e14			bne 	_FNNoBorrow
.0e13	88		dey				dey
.0e14					_FNNoBorrow:
.0e14	3a		dec a				dec 	a
.0e15	5a		phy				phy 								; save location of routine on stack.
.0e16	48		pha				pha
.0e17	da		phx				phx
.0e18	20 16 0c	jsr $0c16			jsr 	CompileExpressionAt0
.0e1b	20 62 09	jsr $0962			jsr 	CheckNextRParen
.0e1e	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.0e20	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0e23	68		pla				pla
.0e24	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0e27	68		pla				pla
.0e28	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0e2b	68		pla				pla
.0e2c	20 00 09	jsr $0900			jsr 	WriteCodeByte
.0e2f	18		clc				clc
.0e30	60		rts				rts
.0e31					_FNError:
.0e31	4c 52 17	jmp $1752		jmp	ErrorV_value
.0e34					CommandTables:
>0e34	07 cb 00 03 39 13 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>0e3b	07 89 00 03 40 13 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>0e42	07 8d 00 03 33 13 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>0e49	07 88 00 03 af 13 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>0e50	07 85 00 03 8f 13 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>0e57	07 84 00 04 a3 13 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>0e5e	07 99 00 03 e4 14 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>0e65	07 98 00 04 e4 14 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>0e6c	07 8f 00 03 ef 15 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>0e73	07 81 00 03 91 0d 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>0e7a	07 82 00 03 67 14 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>0e81	07 a1 00 03 ac 12 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>0e88	07 83 00 03 cc 0a 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>0e8f	07 87 00 03 2d 15 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>0e96	07 86 00 03 5f 0b 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>0e9d	07 96 00 03 e8 0a 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>0ea4	07 8b 00 e3 5c 13 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>0eab	08 92 00 ea e3 bb 16 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>0eb3	09 91 00 e1 a9 03 93 14			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>0ebb	06
>0ebc	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>0ec3	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>0eca	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>0ed0	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>0ed7	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>0ede	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>0ee5	07 9d 00 e3 e1 16 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>0eec	0a 9f 00 ea e3 f4 16 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>0ef4	c6 06
>0ef6	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>0efc	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>0f03	0a ce 92 e3 29 12 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>0f0b	ad 06
>0f0d	0a ce 8d e3 29 12 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>0f15	ae 06
>0f17	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>0f1d	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>0f25	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>0f2c	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>0f33	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>0f3b	06
>0f3c	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>0f44	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>0f4c	9a 06
>0f4e	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>0f56	9b 06
>0f58	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>0f60	9c 06
>0f62	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>0f6a	06
>0f6b	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>0f72	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>0f7a	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>0f82	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>0f8a	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>0f92	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>0f9a	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>0fa2	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>0faa	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>0fb2	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>0fba	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>0fc2	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>0fc9	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>0fd1	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>0fd9	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>0fe1	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>0fe9	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>0ff1	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>0ff9	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>1001	00						.byte 	0
.1002					UnaryTables:
>1002	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>1009	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>1011	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>1018	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>101f	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>1026	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>102d	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>1035	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>103c	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>1044	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>104c	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>1054	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>105c	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>1064	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>106c	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>1073	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>107a	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>1081	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>1088	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>108f	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>1096	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>109e	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>10a6	0b ca 00 8f ae 03 29 12			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>10ae	91 bd 07
>10b1	07 a8 00 03 48 12 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>10b8	07 a5 00 03 f5 0d 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>10bf	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>10c6	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>10cd	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>10d5	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>10dd	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>10e4	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>10eb	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>10f2	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>10fa	06
>10fb	00						.byte 	0
.10fc					GeneratorProcess:
.10fc	86 2a		stx $2a				stx 	zTemp0 						; save generation pointer in zTemp0
.10fe	84 2b		sty $2b				sty 	zTemp0+1
.1100	85 2c		sta $2c				sta 	zTemp1 						; first match token
.1102	64 2d		stz $2d				stz 	zTemp1+1
.1104	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.1106	d0 05		bne $110d			bne 	_GPNotShifted
.1108	20 6b 12	jsr $126b			jsr 	GetNext 					; get the shifted token
.110b	85 2d		sta $2d				sta 	zTemp1+1 					; match CE xx
.110d					_GPNotShifted:
.110d					_GPSearch:
.110d	b2 2a		lda ($2a)			lda 	(zTemp0) 					; reached end ?
.110f	18		clc				clc
.1110	f0 2f		beq $1141			beq 	_GPExit
.1112	a0 01		ldy #$01			ldy 	#1 							; tokens match
.1114	b1 2a		lda ($2a),y			lda 	(zTemp0),y
.1116	c5 2c		cmp $2c				cmp 	zTemp1
.1118	d0 09		bne $1123			bne 	_GPNext
.111a	a5 2d		lda $2d				lda 	zTemp1+1 					; 2nd token ?
.111c	f0 12		beq $1130			beq 	_GPFound
.111e	c8		iny				iny 								; check match.
.111f	d1 2a		cmp ($2a),y			cmp 	(zTemp0),y
.1121	f0 0d		beq $1130			beq 	_GPFound
.1123					_GPNext:
.1123	18		clc				clc 								; follow to next
.1124	a5 2a		lda $2a				lda 	zTemp0
.1126	72 2a		adc ($2a)			adc 	(zTemp0)
.1128	85 2a		sta $2a				sta 	zTemp0
.112a	90 e1		bcc $110d			bcc 	_GPSearch
.112c	e6 2b		inc $2b				inc 	zTemp0+1
.112e	80 dd		bra $110d			bra 	_GPSearch
.1130					_GPFound:
.1130	18		clc				clc 								; skip to action bytes
.1131	a5 2a		lda $2a				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.1133	69 03		adc #$03			adc 	#3
.1135	85 2a		sta $2a				sta 	zTemp0
.1137	90 02		bcc $113b			bcc 	_GPNoCarry
.1139	e6 2b		inc $2b				inc 	zTemp0+1
.113b					_GPNoCarry:
.113b					_GPLoop:
.113b	20 42 11	jsr $1142			jsr 	GeneratorExecute 			; execute one command
.113e	90 fb		bcc $113b			bcc 	_GPLoop 					; go back if not completed.
.1140	38		sec				sec 								; return with CS.
.1141					_GPExit:
.1141	60		rts				rts
.1142					GeneratorExecute:
.1142	20 ee 11	jsr $11ee			jsr 	_GEFetchZTemp0 				; get next.
.1145	48		pha				pha 								; split into 2 nibbles
.1146	4a		lsr a				lsr 	a
.1147	4a		lsr a				lsr 	a
.1148	4a		lsr a				lsr		a
.1149	4a		lsr a				lsr 	a
.114a	20 54 11	jsr $1154			jsr 	_GEExecuteNibble 			; MSB first
.114d	68		pla				pla
.114e	b0 03		bcs $1153			bcs 	_GEHaveCompleted
.1150	20 54 11	jsr $1154			jsr 	_GEExecuteNibble 			; LSB second
.1153					_GEHaveCompleted:
.1153	60		rts				rts
.1154					_GEExecuteNibble:
.1154	29 0f		and #$0f			and 	#$0F
.1156	0a		asl a				asl 	a
.1157	aa		tax				tax
.1158	7c 5b 11	jmp ($115b,x)			jmp 	(_GEExecuteVectors,x)
.115b					_GEExecuteVectors:
>115b	7b 11						.word 	_GEXNop 					; 0  (no operation)
>115d	83 11						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>115f	7d 11						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>1161	d1 11						.word 	_GEXExecute 				; 3  (run arbitrary code)
>1163	c4 11						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>1165	7b 11						.word 	_GEXNop 					; 5
>1167	8b 11						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>1169	8f 11						.word 	_GEXExitString 				; 7  exit return string type
>116b	93 11						.word 	_GEXLParam 					; 8  check ( follows
>116d	97 11						.word 	_GEXRParam 					; 9  check ) follows
>116f	9b 11						.word 	_GEXComma					; A  check , follows
>1171	7b 11						.word 	_GEXNop 					; B
>1173	7b 11						.word 	_GEXNop 					; C
>1175	7b 11						.word 	_GEXNop 					; D
>1177	ab 11						.word 	_GEXNumber 					; E  compile get any number
>1179	b6 11						.word 	_GEXString 					; F  compile get any string
.117b					_GEXNop:
.117b	18		clc				clc
.117c	60		rts				rts
.117d					_GEXToken2:
.117d	20 ee 11	jsr $11ee			jsr 	_GEFetchZTemp0
.1180	20 00 09	jsr $0900			jsr 	WriteCodeByte
.1183					_GEXToken1:
.1183	20 ee 11	jsr $11ee			jsr 	_GEFetchZTemp0
.1186	20 00 09	jsr $0900			jsr 	WriteCodeByte
.1189	18		clc				clc
.118a	60		rts				rts
.118b					_GEXExitNumber:
.118b	a9 00		lda #$00			lda 	#NSSIFloat
.118d	38		sec				sec
.118e	60		rts				rts
.118f					_GEXExitString:
.118f	a9 40		lda #$40			lda 	#NSSString
.1191	38		sec				sec
.1192	60		rts				rts
.1193					_GEXLParam:
.1193	a9 28		lda #$28			lda 	#"("
.1195	80 06		bra $119d			bra 	_GEXCheck
.1197					_GEXRParam:
.1197	a9 29		lda #$29			lda 	#")"
.1199	80 02		bra $119d			bra 	_GEXCheck
.119b					_GEXComma:
.119b	a9 2c		lda #$2c			lda 	#","
.119d					_GEXCheck:
.119d	85 2e		sta $2e				sta 	zTemp2 						; save match
.119f	20 76 12	jsr $1276			jsr 	GetNextNonSpace 			; get next skipping spaces
.11a2	c5 2e		cmp $2e				cmp 	zTemp2 						; check matches.
.11a4	d0 02		bne $11a8			bne 	_GEXSyntax
.11a6	18		clc				clc
.11a7	60		rts				rts
.11a8					_GEXSyntax:
.11a8	4c 5f 17	jmp $175f		jmp	ErrorV_syntax
.11ab					_GEXNumber:
.11ab	20 f7 11	jsr $11f7			jsr 	GEXCompileExpression 		; compile expression
.11ae	29 40		and #$40			and 	#NSSTypeMask
.11b0	c9 00		cmp #$00			cmp  	#NSSIFloat
.11b2	d0 0d		bne $11c1			bne 	_GEXType
.11b4	18		clc				clc
.11b5	60		rts				rts
.11b6					_GEXString:
.11b6	20 f7 11	jsr $11f7			jsr 	GEXCompileExpression 		; compile expression
.11b9	29 40		and #$40			and 	#NSSTypeMask
.11bb	c9 40		cmp #$40			cmp  	#NSSString
.11bd	d0 02		bne $11c1			bne 	_GEXType
.11bf	18		clc				clc
.11c0	60		rts				rts
.11c1					_GEXType:
.11c1	4c 6f 17	jmp $176f		jmp	ErrorV_type
.11c4					_GEXChannelExec:
.11c4	20 07 12	jsr $1207			jsr 	ChannelPrefix 				; set up default
.11c7	20 d1 11	jsr $11d1			jsr 	_GEXExecute
.11ca	08		php				php
.11cb	20 22 12	jsr $1222			jsr 	ChannelPostfix 				; replace default.
.11ce	28		plp				plp
.11cf	60		rts				rts
>11d0	db						.byte 	$DB 						; causes a break in the emulator
.11d1					_GEXExecute:
.11d1	20 ee 11	jsr $11ee			jsr 	_GEFetchZTemp0 				; get vector
.11d4	85 2e		sta $2e				sta 	zTemp2
.11d6	20 ee 11	jsr $11ee			jsr 	_GEFetchZTemp0
.11d9	85 2f		sta $2f				sta 	zTemp2+1
.11db	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.11dd	da		phx				phx
.11de	a6 2b		ldx $2b				ldx 	zTemp0+1
.11e0	da		phx				phx
.11e1	20 eb 11	jsr $11eb			jsr 	_GECallZTemp2 				; execute code
.11e4	fa		plx				plx 								; recover generation exec
.11e5	86 2b		stx $2b				stx 	zTemp0+1
.11e7	fa		plx				plx
.11e8	86 2a		stx $2a				stx 	zTemp0
.11ea	60		rts				rts
.11eb					_GECallZTemp2:
.11eb	6c 2e 00	jmp ($002e)			jmp 	(zTemp2)
.11ee					_GEFetchZTemp0:
.11ee	b2 2a		lda ($2a)			lda 	(zTemp0)
.11f0	e6 2a		inc $2a				inc 	zTemp0
.11f2	d0 02		bne $11f6			bne 	_GEFZ0Skip
.11f4	e6 2b		inc $2b				inc 	zTemp0+1
.11f6					_GEFZ0Skip:
.11f6	60		rts				rts
.11f7					GEXCompileExpression:
.11f7	a6 2a		ldx $2a				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.11f9	da		phx				phx
.11fa	a6 2b		ldx $2b				ldx 	zTemp0+1
.11fc	da		phx				phx
.11fd	20 16 0c	jsr $0c16			jsr 	CompileExpressionAt0 		; compile expression.
.1200	fa		plx				plx 								; recover generation exec
.1201	86 2b		stx $2b				stx 	zTemp0+1
.1203	fa		plx				plx
.1204	86 2a		stx $2a				stx 	zTemp0
.1206	60		rts				rts
.1207					ChannelPrefix:
.1207	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.1209	20 00 09	jsr $0900			jsr 	WriteCodeByte
.120c	20 f7 11	jsr $11f7			jsr 	GEXCompileExpression 		; channel #
.120f	29 40		and #$40			and 	#NSSTypeMask
.1211	c9 00		cmp #$00			cmp 	#NSSIFloat
.1213	d0 0a		bne $121f			bne 	_CPXType
.1215	20 5e 09	jsr $095e			jsr 	CheckNextComma 				; check , follows.
.1218	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.121a	20 00 09	jsr $0900			jsr 	WriteCodeByte
.121d	18		clc				clc
.121e	60		rts				rts
.121f					_CPXType:
.121f	4c 6f 17	jmp $176f		jmp	ErrorV_type
.1222					ChannelPostfix:
.1222	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.1224	20 00 09	jsr $0900			jsr 	WriteCodeByte
.1227	18		clc				clc
.1228	60		rts				rts
.1229					OptionalParameterCompile:
.1229	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; what follows.
.122c	c9 2c		cmp #$2c			cmp 	#","
.122e	d0 0e		bne $123e			bne 	_MidDefault
.1230	20 6b 12	jsr $126b			jsr 	GetNext 					; consume ,
.1233	20 16 0c	jsr $0c16			jsr 	CompileExpressionAt0
.1236	29 40		and #$40			and 	#NSSTypeMask
.1238	c9 00		cmp #$00			cmp 	#NSSIFloat
.123a	d0 09		bne $1245			bne 	MidFailType
.123c	80 05		bra $1243			bra 	_MidComplete
.123e					_MidDefault:
.123e	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1240	20 29 0a	jsr $0a29			jsr 	PushIntegerA
.1243					_MidComplete:
.1243	18		clc				clc
.1244	60		rts				rts
.1245					MidFailType:
.1245	4c 6f 17	jmp $176f		jmp	ErrorV_type
.1248					NotUnaryCompile:
.1248	ad cb 0c	lda $0ccb			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.124b	20 18 0c	jsr $0c18			jsr 	CompileExpressionAtA 		; evaluate at that level
.124e	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1250	c9 00		cmp #$00			cmp 	#NSSIFloat
.1252	d0 f1		bne $1245			bne 	MidFailType
.1254	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1256	20 00 09	jsr $0900			jsr 	WriteCodeByte
.1259	60		rts				rts
.125a					LookNext:
.125a	b2 24		lda ($24)			lda 	(srcPtr)
.125c	60		rts				rts
.125d					LookNextNonSpace:
.125d	b2 24		lda ($24)			lda 	(srcPtr)
.125f	c9 20		cmp #$20			cmp		#' '
.1261	f0 03		beq $1266			beq 	_LNNSkip
.1263	c9 00		cmp #$00			cmp 	#0
.1265	60		rts				rts
.1266					_LNNSkip:
.1266	20 6b 12	jsr $126b			jsr 	GetNext
.1269	80 f2		bra $125d			bra 	LookNextNonSpace
.126b					GetNext:
.126b	b2 24		lda ($24)			lda 	(srcPtr) 					; get next
.126d	e6 24		inc $24				inc 	srcPtr
.126f	d0 02		bne $1273			bne 	_GNSkip
.1271	e6 25		inc $25				inc 	srcPtr+1
.1273					_GNSkip:
.1273	c9 00		cmp #$00			cmp 	#0
.1275	60		rts				rts
.1276					GetNextNonSpace:
.1276	20 6b 12	jsr $126b			jsr 	GetNext
.1279	c9 20		cmp #$20			cmp 	#' '
.127b	f0 f9		beq $1276			beq 	GetNextNonSpace
.127d	c9 00		cmp #$00			cmp 	#0
.127f	60		rts				rts
.1280					CharIsDigit:
.1280	c9 30		cmp #$30			cmp 	#"0"
.1282	90 06		bcc $128a			bcc 	CCFalse
.1284	c9 3a		cmp #$3a			cmp 	#"9"+1
.1286	b0 02		bcs $128a			bcs 	CCFalse
.1288					CCTrue:
.1288	38		sec				sec
.1289	60		rts				rts
.128a					CCFalse:
.128a	18		clc				clc
.128b	60		rts				rts
.128c					CharIsAlpha:
.128c	c9 41		cmp #$41			cmp 	#"A"
.128e	90 fa		bcc $128a			bcc 	CCFalse
.1290	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1292	b0 f6		bcs $128a			bcs 	CCFalse
.1294	80 f2		bra $1288			bra 	CCTrue
.1296					ConvertHexStyle:
.1296	38		sec				sec
.1297	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1299	90 ef		bcc $128a			bcc 	CCFalse
.129b	c9 0a		cmp #$0a			cmp 	#9+1
.129d	90 e9		bcc $1288			bcc 	CCTrue
.129f	38		sec				sec 								; shift into hex space A=>0 Z=>25
.12a0	e9 11		sbc #$11			sbc 	#"A"-"0"
.12a2	90 e6		bcc $128a			bcc 	CCFalse
.12a4	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.12a6	b0 e2		bcs $128a			bcs 	CCFalse
.12a8	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.12aa	80 dc		bra $1288			bra 	CCTrue
.12ac					CommandGET:
.12ac	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; # follows ?
.12af	c9 23		cmp #$23			cmp 	#"#"
.12b1	d0 0d		bne $12c0			bne 	CommandGetBody
.12b3	20 6b 12	jsr $126b			jsr 	GetNext 					; consume #
.12b6	20 07 12	jsr $1207			jsr 	ChannelPrefix 				; do it as GET#
.12b9	20 c0 12	jsr $12c0			jsr 	CommandGetBody
.12bc	20 22 12	jsr $1222			jsr 	ChannelPostfix
.12bf	60		rts				rts
.12c0					CommandGetBody:
.12c0	20 76 12	jsr $1276			jsr 	GetNextNonSpace 			; get the first character
.12c3	20 b7 15	jsr $15b7			jsr 	GetReferenceTerm 			; identify variable to assign to
.12c6	48		pha				pha
.12c7	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.12c9	c9 40		cmp #$40			cmp 	#NSSString
.12cb	d0 0b		bne $12d8			bne 	_CGType
.12cd	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.12cf	20 00 09	jsr $0900			jsr 	WriteCodeByte
.12d2	38		sec				sec
.12d3	68		pla				pla
.12d4	20 69 15	jsr $1569			jsr		GetSetVariable
.12d7	60		rts				rts
.12d8					_CGType:
.12d8	4c 6f 17	jmp $176f		jmp	ErrorV_type
.12db					ExtractVariableName:
.12db	20 8c 12	jsr $128c			jsr 	CharIsAlpha
.12de	90 50		bcc $1330			bcc 	_IVSyntax
.12e0	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.12e2	85 2c		sta $2c				sta 	zTemp1 						; we'll build it in zTemp1
.12e4	64 2d		stz $2d				stz 	zTemp1+1
.12e6	20 5a 12	jsr $125a			jsr 	LookNext 					; is there a second character ?
.12e9	20 8c 12	jsr $128c			jsr 	CharIsAlpha  				; must be alphanumeric
.12ec	b0 05		bcs $12f3			bcs 	_IVHasSecond
.12ee	20 80 12	jsr $1280			jsr 	CharIsDigit
.12f1	90 07		bcc $12fa			bcc 	_IVCheckType
.12f3					_IVHasSecond:
.12f3	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.12f5	85 2d		sta $2d				sta 	zTemp1+1
.12f7					_IVGetNextCheck:
.12f7	20 6b 12	jsr $126b			jsr 	GetNext 					; consume it
.12fa					_IVCheckType:
.12fa	20 5a 12	jsr $125a			jsr 	LookNext					; check if string follows.
.12fd	20 8c 12	jsr $128c			jsr 	CharIsAlpha
.1300	b0 f5		bcs $12f7			bcs 	_IVGetNextCheck
.1302	20 80 12	jsr $1280			jsr 	CharIsDigit
.1305	b0 f0		bcs $12f7			bcs 	_IVGetNextCheck
.1307	a2 40		ldx #$40			ldx 	#NSSString
.1309	c9 24		cmp #$24			cmp 	#"$"
.130b	f0 06		beq $1313			beq 	_IVHasType
.130d	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.130f	c9 25		cmp #$25			cmp 	#"%"
.1311	d0 08		bne $131b			bne 	_IVCheckArray
.1313					_IVHasType:
.1313	8a		txa				txa 								; Or X into zTemp1
.1314	05 2c		ora $2c				ora 	zTemp1
.1316	85 2c		sta $2c				sta 	zTemp1
.1318	20 6b 12	jsr $126b			jsr 	GetNext 					; consume it
.131b					_IVCheckArray:
.131b	20 5a 12	jsr $125a			jsr 	LookNext 					; check if array follows
.131e	c9 28		cmp #$28			cmp 	#"("
.1320	d0 09		bne $132b			bne 	_IVNotArray
.1322	a5 2c		lda $2c				lda 	zTemp1 						; set array bit
.1324	09 80		ora #$80			ora 	#NSSArray
.1326	85 2c		sta $2c				sta 	zTemp1
.1328	20 6b 12	jsr $126b			jsr 	GetNext 					; consume it
.132b					_IVNotArray:
.132b	a6 2c		ldx $2c				ldx 	zTemp1
.132d	a4 2d		ldy $2d				ldy 	zTemp1+1
.132f	60		rts				rts
.1330					_IVSyntax:
.1330	4c 5f 17	jmp $175f		jmp	ErrorV_syntax
.1333					CommandGOSUB:
.1333	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1335	20 46 13	jsr $1346			jsr 	CompileBranchCommand
.1338	60		rts				rts
.1339					CommandGOAlt:
.1339	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.133b	20 68 09	jsr $0968			jsr 	CheckNextA
.133e	80 00		bra $1340			bra 	CommandGOTO
.1340					CommandGOTO:
.1340	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1342	20 46 13	jsr $1346			jsr 	CompileBranchCommand
.1345	60		rts				rts
.1346					CompileBranchCommand:
.1346	20 00 09	jsr $0900			jsr 	WriteCodeByte 				; write the command out.
.1349	20 76 12	jsr $1276			jsr 	GetNextNonSpace
.134c	20 bf 14	jsr $14bf			jsr 	ParseConstant 				; get constant into YA
.134f	90 08		bcc $1359			bcc 	_CBCSyntax
.1351	20 00 09	jsr $0900			jsr 	WriteCodeByte				; and compile the actual line number
.1354	98		tya				tya
.1355	20 00 09	jsr $0900			jsr 	WriteCodeByte
.1358	60		rts				rts
.1359					_CBCSyntax:
.1359	4c 5f 17	jmp $175f		jmp	ErrorV_syntax
.135c					CommandIF:
.135c	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; what follows the tests ?
.135f	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1361	f0 0f		beq $1372			beq 	_CIGoto
.1363	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1365	20 68 09	jsr $0968			jsr 	CheckNextA
.1368	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; THEN <number>
.136b	20 80 12	jsr $1280			jsr 	CharIsDigit
.136e	b0 05		bcs $1375			bcs 	_CIGoto2
.1370	80 09		bra $137b			bra 	CompileGotoEOL
.1372					_CIGoto:
.1372	20 6b 12	jsr $126b			jsr 	GetNext
.1375					_CIGoto2:
.1375	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1377	20 46 13	jsr $1346			jsr 	CompileBranchCommand
.137a	60		rts				rts
.137b					CompileGotoEOL:
.137b	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.137d	20 00 09	jsr $0900			jsr 	WriteCodeByte
.1380	20 f9 08	jsr $08f9			jsr 	GetLineNumber 				; Get the current line number => YA
.1383	1a		inc a				inc 	a 							; and branch to +1
.1384	d0 01		bne $1387			bne 	_CGENoCarry
.1386	c8		iny				iny
.1387					_CGENoCarry:
.1387	20 00 09	jsr $0900			jsr 	WriteCodeByte
.138a	98		tya				tya
.138b	20 00 09	jsr $0900			jsr 	WriteCodeByte
.138e	60		rts				rts
.138f					CommandINPUT:
.138f	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; check for "
.1392	c9 22		cmp #$22			cmp 	#'"'
.1394	d0 0d		bne $13a3			bne 	CommandINPUTStream
.1396	20 16 0c	jsr $0c16			jsr 	CompileExpressionAt0
.1399	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.139b	20 00 09	jsr $0900			jsr 	WriteCodeByte
.139e	a9 2c		lda #$2c			lda 	#","
.13a0	20 5e 09	jsr $095e			jsr 	CheckNextComma
.13a3					CommandINPUTStream:
.13a3	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.13a5	20 00 09	jsr $0900			jsr 	WriteCodeByte
.13a8	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.13aa	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.13ac	4c 31 15	jmp $1531			jmp 	CommandReadInputCommon
.13af					CommandLET:
.13af	20 76 12	jsr $1276			jsr 	GetNextNonSpace 			; get the first character
.13b2					CommandLETHaveFirst:
.13b2	20 b7 15	jsr $15b7			jsr 	GetReferenceTerm 			; identify variable to assign to
.13b5	da		phx				phx 								; save target on the stack.
.13b6	5a		phy				phy
.13b7	48		pha				pha
.13b8	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.13ba	20 68 09	jsr $0968			jsr 	CheckNextA
.13bd	20 16 0c	jsr $0c16			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.13c0	85 2a		sta $2a				sta 	zTemp0 						; save type returned
.13c2	68		pla				pla 								; get type of assignment
.13c3	48		pha				pha
.13c4	45 2a		eor $2a				eor 	zTemp0 						; compare using EOR
.13c6	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.13c8	d0 17		bne $13e1			bne 	_CLType
.13ca	68		pla				pla 								; restore and compile save code
.13cb	7a		ply				ply
.13cc	fa		plx				plx
.13cd	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.13cf	f0 05		beq $13d6			beq 	_CLTIString
.13d1	38		sec				sec
.13d2	20 69 15	jsr $1569			jsr		GetSetVariable
.13d5	60		rts				rts
.13d6					_CLTIString:
.13d6	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.13d8	20 00 09	jsr $0900			jsr 	WriteCodeByte
.13db	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.13dd	20 00 09	jsr $0900			jsr 	WriteCodeByte
.13e0	60		rts				rts
.13e1					_CLType:
.13e1	4c 6f 17	jmp $176f		jmp	ErrorV_type
.13e4					STRMarkLine:
.13e4	48		pha				pha
.13e5	38		sec				sec 								; allocate 4 bytes (line #,address)
.13e6	ad 0f 05	lda $050f			lda 	lineNumberTable 			; and copy to zTemp0
.13e9	e9 04		sbc #$04			sbc 	#4
.13eb	8d 0f 05	sta $050f			sta 	lineNumberTable
.13ee	85 2a		sta $2a				sta 	zTemp0
.13f0	ad 10 05	lda $0510			lda 	lineNumberTable+1
.13f3	e9 00		sbc #$00			sbc 	#0
.13f5	8d 10 05	sta $0510			sta 	lineNumberTable+1
.13f8	85 2b		sta $2b				sta 	zTemp0+1
.13fa	68		pla				pla
.13fb	92 2a		sta ($2a)			sta 	(zTemp0) 					; line # save it in +0,+1
.13fd	98		tya				tya
.13fe	a0 01		ldy #$01			ldy 	#1
.1400	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1402	a5 28		lda $28				lda 	objPtr 						; save current address in +2,+3
.1404	c8		iny				iny
.1405	91 2a		sta ($2a),y			sta 	(zTemp0),y
.1407	a5 29		lda $29				lda 	objPtr+1
.1409	c8		iny				iny
.140a	91 2a		sta ($2a),y			sta 	(zTemp0),y
.140c	60		rts				rts
.140d					STRFindLine:
.140d	85 2a		sta $2a				sta 	zTemp0 						; zTemp0 line number being searched
.140f	84 2b		sty $2b				sty 	zTemp0+1
.1411	ad 08 05	lda $0508			lda 	compilerEndHigh 			; work backwards through table
.1414	85 2d		sta $2d				sta 	zTemp1+1
.1416	64 2c		stz $2c				stz 	zTemp1
.1418					_STRSearch:
.1418	20 4f 14	jsr $144f			jsr 	_STRPrevLine 				; look at previous record.
.141b	a0 01		ldy #$01			ldy 	#1
.141d	b2 2c		lda ($2c)			lda 	(zTemp1) 					; check table line # >= target
.141f	c5 2a		cmp $2a				cmp 	zTemp0
.1421	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1423	e5 2b		sbc $2b				sbc 	zTemp0+1
.1425	b0 0b		bcs $1432			bcs 	_STRFound 					; >=
.1427					_STRNext:
.1427	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1429	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.142b	c9 ff		cmp #$ff			cmp 	#$FF
.142d	d0 e9		bne $1418			bne 	_STRSearch
.142f	4c b9 17	jmp $17b9		jmp	ErrorV_internal
.1432					_STRFound:
.1432	b2 2c		lda ($2c)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1434	45 2a		eor $2a				eor 	zTemp0
.1436	d0 06		bne $143e			bne 	_STRDifferent
.1438	b2 2c		lda ($2c)			lda 	(zTemp1)
.143a	45 2a		eor $2a				eor 	zTemp0
.143c	f0 02		beq $1440			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.143e					_STRDifferent:
.143e	a9 ff		lda #$ff			lda 	#$FF
.1440					_STROut:
.1440	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1441	69 ff		adc #$ff			adc 	#255
.1443	08		php				php
.1444	c8		iny				iny 								; address into YA
.1445	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.1447	48		pha				pha
.1448	c8		iny				iny
.1449	b1 2c		lda ($2c),y			lda 	(zTemp1),y
.144b	a8		tay				tay
.144c	68		pla				pla
.144d	28		plp				plp
.144e	60		rts				rts
.144f					_STRPrevLine:
.144f	38		sec				sec 								; move backwards one entry.
.1450	a5 2c		lda $2c				lda 	zTemp1
.1452	e9 04		sbc #$04			sbc 	#4
.1454	85 2c		sta $2c				sta 	zTemp1
.1456	a5 2d		lda $2d				lda 	zTemp1+1
.1458	e9 00		sbc #$00			sbc 	#0
.145a	85 2d		sta $2d				sta 	zTemp1+1
.145c	60		rts				rts
.145d					STRMakeOffset:
.145d	18		clc				clc 								; borrow 1
.145e	e5 28		sbc $28				sbc 	objPtr
.1460	48		pha				pha
.1461	98		tya				tya
.1462	e5 29		sbc $29				sbc 	objPtr+1
.1464	a8		tay				tay
.1465	68		pla				pla
.1466	60		rts				rts
.1467					CommandNEXT:
.1467	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.146a	20 8c 12	jsr $128c			jsr 	CharIsAlpha 				; if not alpha , error
.146d	90 0c		bcc $147b			bcc 	_CNNoReferenceGiven
.146f	20 6b 12	jsr $126b			jsr 	GetNext
.1472	20 b7 15	jsr $15b7			jsr 	GetReferenceTerm 			; figure out the reference.
.1475	8a		txa				txa 								; reference in YA
.1476	20 16 0a	jsr $0a16			jsr 	PushIntegerYA 				; write it out.
.1479	80 06		bra $1481			bra 	_CNParametersDone
.147b					_CNNoReferenceGiven:
.147b	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.147d	a8		tay				tay
.147e	20 16 0a	jsr $0a16			jsr 	PushIntegerYA 				; write it out.
.1481					_CNParametersDone:
.1481	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1483	20 00 09	jsr $0900			jsr 	WriteCodeByte
.1486	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; look for ,
.1489	c9 2c		cmp #$2c			cmp 	#","
.148b	d0 05		bne $1492			bne 	_CNExit
.148d	20 6b 12	jsr $126b			jsr 	GetNext 					; consume ,
.1490	80 d5		bra $1467			bra 	CommandNEXT 				; and go round.
.1492					_CNExit:
.1492	60		rts				rts
.1493					CommandON:
.1493	20 76 12	jsr $1276			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1496	48		pha				pha 								; save on stack
.1497	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1499	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.149b	f0 09		beq $14a6			beq 	_COCreateLoop
.149d	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.149f	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.14a1	f0 03		beq $14a6			beq 	_COCreateLoop
.14a3	4c 5f 17	jmp $175f		jmp	ErrorV_syntax
.14a6					_COCreateLoop:
.14a6	8a		txa				txa 								; compile a goto/gosub somewhere
.14a7	da		phx				phx
.14a8	20 46 13	jsr $1346			jsr 	CompileBranchCommand
.14ab	fa		plx				plx
.14ac	20 5d 12	jsr $125d			jsr 	LookNextNonSpace			; ',' follows
.14af	c9 2c		cmp #$2c			cmp 	#","
.14b1	d0 0a		bne $14bd			bne 	_COComplete 				; if so, more line numbers
.14b3	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.14b5	20 00 09	jsr $0900			jsr 	WriteCodeByte
.14b8	20 6b 12	jsr $126b			jsr 	GetNext
.14bb	80 e9		bra $14a6			bra 	_COCreateLoop
.14bd					_COComplete:
.14bd	68		pla				pla 								; throw GOTO/GOSUB
.14be	60		rts				rts
.14bf					ParseConstant:
.14bf	a2 00		ldx #$00			ldx 	#0
.14c1	20 96 1c	jsr $1c96			jsr 	FloatEncodeStart 			; send first
.14c4					_ParseLoop:
.14c4	20 5a 12	jsr $125a			jsr 	LookNext 					; send subsequent
.14c7	20 99 1c	jsr $1c99			jsr 	FloatEncodeContinue
.14ca	90 05		bcc $14d1			bcc 	_ParseDone
.14cc	20 6b 12	jsr $126b			jsr 	GetNext 					; consume it
.14cf	80 f3		bra $14c4			bra 	_ParseLoop
.14d1					_ParseDone:
.14d1	b5 30		lda $30,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.14d3	29 80		and #$80			and 	#$80
.14d5	15 6c		ora $6c,x			ora 	NSExponent,x 				; 16 bit int check
.14d7	15 54		ora $54,x			ora 	NSMantissa2,x
.14d9	15 60		ora $60,x			ora 	NSMantissa3,x
.14db	18		clc				clc
.14dc	d0 05		bne $14e3			bne 	_ParseExit 					; exit with CC if need float to compile
.14de	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; read into YA.
.14e0	b4 48		ldy $48,x			ldy		NSMantissa1,x
.14e2	38		sec				sec
.14e3					_ParseExit:
.14e3	60		rts				rts
.14e4					CommandPRINT:
.14e4	20 5d 12	jsr $125d			jsr 	LookNextNonSpace			; what follows ?
.14e7	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.14e9	f0 1f		beq $150a			beq 	_CPCheckEnd
.14eb	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.14ed	f0 16		beq $1505			beq 	_CPTabCheckEnd
.14ef	20 21 15	jsr $1521			jsr 	_CPAtEnd 					; check for : and EOL
.14f2	b0 22		bcs $1516			bcs 	_CPExitCR 					; exit with CR
.14f4	20 16 0c	jsr $0c16			jsr 	CompileExpressionAt0 		; so it is something to print
.14f7	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.14f9	29 40		and #$40			and 	#NSSString 					; if string
.14fb	d0 02		bne $14ff			bne 	_CPOut
.14fd	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.14ff					_CPOut:
.14ff	8a		txa				txa 								; print that thing
.1500	20 00 09	jsr $0900			jsr 	WriteCodeByte
.1503	80 df		bra $14e4			bra 	CommandPRINT 				; and loop round/
.1505					_CPTabCheckEnd:
.1505	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1507	20 00 09	jsr $0900			jsr 	WriteCodeByte
.150a					_CPCheckEnd:
.150a	20 6b 12	jsr $126b			jsr 	GetNext 					; consume it.
.150d	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; what follows ?
.1510	20 21 15	jsr $1521			jsr 	_CPAtEnd 					; reached end
.1513	90 cf		bcc $14e4			bcc 	CommandPRINT 				; no, loop back
.1515	60		rts				rts
.1516					_CPExitCR:
.1516	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1518	20 29 0a	jsr $0a29			jsr 	PushIntegerA
.151b	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.151d	20 00 09	jsr $0900			jsr 	WriteCodeByte
.1520	60		rts				rts
.1521					_CPAtEnd:
.1521	c9 00		cmp #$00			cmp 	#0
.1523	f0 06		beq $152b			beq 	_CPIsEnd
.1525	c9 3a		cmp #$3a			cmp 	#":"
.1527	f0 02		beq $152b			beq 	_CPIsEnd
.1529	18		clc				clc
.152a	60		rts				rts
.152b					_CPIsEnd:
.152b	38		sec				sec
.152c	60		rts				rts
.152d					CommandREAD:
.152d	a2 b2		ldx #$b2			ldx 	#PCD_READ
.152f	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1531					CommandReadInputCommon:
.1531	8e 0d 05	stx $050d			stx 	numberPCode
.1534	8c 0e 05	sty $050e			sty 	stringPCode
.1537					_CRLoop:
.1537	20 76 12	jsr $1276			jsr 	GetNextNonSpace 			; first char of identifier
.153a	20 8c 12	jsr $128c			jsr 	CharIsAlpha 				; check A-Z
.153d	90 27		bcc $1566			bcc 	_CRSyntax
.153f	20 b7 15	jsr $15b7			jsr 	GetReferenceTerm 			; get the variable.
.1542	48		pha				pha 								; save type.
.1543	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1545	c9 40		cmp #$40			cmp 	#NSSString
.1547	f0 05		beq $154e			beq 	_CRString
.1549	ad 0d 05	lda $050d			lda 	numberPCode 				; output read/input
.154c	80 03		bra $1551			bra 	_CRHaveType
.154e					_CRString:
.154e	ad 0e 05	lda $050e			lda 	stringPCode					; output read$/input$
.1551					_CRHaveType:
.1551	20 00 09	jsr $0900			jsr 	WriteCodeByte 				; so we have one typed data item.
.1554	68		pla				pla 								; restore type
.1555	38		sec				sec  								; write update code.
.1556	20 69 15	jsr $1569			jsr 	GetSetVariable
.1559	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; , follows ?
.155c	c9 2c		cmp #$2c			cmp 	#","
.155e	d0 05		bne $1565			bne 	_CRExit 					; if not, end of READ.
.1560	20 6b 12	jsr $126b			jsr 	GetNext 					; consume comma
.1563	80 d2		bra $1537			bra 	_CRLoop 					; keep going
.1565					_CRExit:
.1565	60		rts				rts
.1566					_CRSyntax:
.1566	4c 5f 17	jmp $175f		jmp	ErrorV_syntax
.050d					numberPCode:
>050d							.fill 	1
.050e					stringPCode:
>050e							.fill 	1
.1569					GetSetVariable:
.1569	08		php				php 								; save direction on stack
.156a	c0 00		cpy #$00			cpy 	#$00
.156c	30 21		bmi $158f			bmi 	_GSVReadWriteSpecial
.156e	c9 00		cmp #$00			cmp 	#$00
.1570	30 33		bmi $15a5			bmi 	_GSVArray
.1572	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1574	4a		lsr a				lsr 	a 							; divide by 2
.1575	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1577	28		plp				plp
.1578	90 02		bcc $157c			bcc 	_GSVNotWrite
.157a	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.157c					_GSVNotWrite:
.157c	85 2a		sta $2a				sta 	zTemp0
.157e	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.157f	4a		lsr a				lsr 	a
.1580	a8		tay				tay
.1581	8a		txa				txa
.1582	6a		ror a				ror 	a
.1583	aa		tax				tax
.1584	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1585	05 2a		ora $2a				ora 	zTemp0 						; which is the first byte of the opcode
.1587	20 00 09	jsr $0900			jsr 	WriteCodeByte
.158a	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.158b	20 00 09	jsr $0900			jsr 	WriteCodeByte
.158e	60		rts				rts
.158f					_GSVReadWriteSpecial:
.158f	28		plp				plp
.1590	b0 10		bcs $15a2			bcs 	_GSVSyntax
.1592	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1594	f0 06		beq $159c			beq 	_GSVRWString
.1596	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1598	20 00 09	jsr $0900			jsr 	WriteCodeByte
.159b	60		rts				rts
.159c					_GSVRWString:
.159c	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.159e	20 00 09	jsr $0900			jsr 	WriteCodeByte
.15a1	60		rts				rts
.15a2					_GSVSyntax:
.15a2	4c 5f 17	jmp $175f		jmp	ErrorV_syntax
.15a5					_GSVArray:
.15a5	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.15a7	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.15a8	4a		lsr a				lsr 	a
.15a9	4a		lsr a				lsr 	a
.15aa	4a		lsr a				lsr 	a
.15ab	4a		lsr a				lsr 	a
.15ac	28		plp				plp 								; if writing array then set bit 2.
.15ad	90 02		bcc $15b1			bcc 	_GSVANotWrite
.15af	09 04		ora #$04			ora 	#4
.15b1					_GSVANotWrite:
.15b1	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.15b3	20 00 09	jsr $0900			jsr 	WriteCodeByte 				; and write it out
.15b6	60		rts				rts
.15b7					GetReferenceTerm:
.15b7	20 db 12	jsr $12db			jsr 	ExtractVariableName 		; get name & type info
.15ba	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.15bc	30 10		bmi $15ce			bmi 	_GRTArray
.15be	da		phx				phx 								; save type on stack
.15bf	20 d0 0c	jsr $0cd0			jsr 	FindVariable 				; find it
.15c2	b0 06		bcs $15ca			bcs 	_GRTNoCreate 				; create if required.
.15c4	20 5b 0a	jsr $0a5b			jsr 	CreateVariableRecord 		; create a variable.
.15c7	20 b0 0a	jsr $0ab0			jsr 	AllocateBytesForType 		; allocate memory for it
.15ca					_GRTNoCreate:
.15ca	68		pla				pla 								; get type back, strip out type information.
.15cb	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.15cd	60		rts				rts
.15ce					_GRTArray:
.15ce	da		phx				phx 								; save type information
.15cf	20 d0 0c	jsr $0cd0			jsr 	FindVariable 				; read its data, the base address in YX
.15d2	90 18		bcc $15ec			bcc 	_GRTUndeclared 				; undeclared array.
.15d4	da		phx				phx 								; save base address
.15d5	5a		phy				phy
.15d6	20 a7 0b	jsr $0ba7			jsr 	OutputIndexGroup 			; create an index group and generate them
.15d9	7a		ply				ply 								; get the array base address into YX
.15da	fa		plx				plx
.15db	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.15dd	18		clc				clc
.15de	20 69 15	jsr $1569			jsr 	GetSetVariable 				; load the address of the array structure.
.15e1	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.15e3	20 00 09	jsr $0900			jsr 	WriteCodeByte
.15e6	68		pla				pla 								; and the type data into A
.15e7	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.15e9	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.15eb	60		rts				rts
.15ec					_GRTUndeclared:
.15ec	4c 16 18	jmp $1816		jmp	ErrorV_undeclared
.15ef					CommandREM:
.15ef	20 5a 12	jsr $125a			jsr 	LookNext
.15f2	f0 05		beq $15f9			beq 	_CRExit
.15f4	20 6b 12	jsr $126b			jsr 	GetNext
.15f7	80 f6		bra $15ef			bra 	CommandREM
.15f9					_CRExit:
.15f9	60		rts				rts
.15fa					STRReset:
.15fa	ad 07 05	lda $0507			lda	 	compilerStartHigh 			; set up the two table pointers
.15fd	8d 12 05	sta $0512			sta 	variableListEnd+1
.1600	9c 11 05	stz $0511			stz 	variableListEnd
.1603	ad 08 05	lda $0508			lda 	compilerEndHigh
.1606	8d 10 05	sta $0510			sta 	lineNumberTable+1
.1609	9c 0f 05	stz $050f			stz 	lineNumberTable
.160c	ad 11 05	lda $0511			lda 	variableListEnd
.160f	85 2b		sta $2b				sta 	zTemp0+1
.1611	64 2a		stz $2a				stz 	zTemp0
.1613	a9 00		lda #$00			lda 	#0
.1615	92 2a		sta ($2a)			sta 	(zTemp0)
.1617	a9 00		lda #$00			lda 	#((0) & $FF)
.1619	8d 13 05	sta $0513			sta 	0+freeVariableMemory
.161c	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.161e	8d 14 05	sta $0514			sta 	1+freeVariableMemory
.1621	60		rts				rts
.050f					lineNumberTable:
>050f							.fill 	2
.0511					variableListEnd:
>0511							.fill 	2
.0513					freeVariableMemory:
>0513							.fill 	2
.1622					CompileTerm:
.1622	20 76 12	jsr $1276			jsr 	GetNextNonSpace 			; get first non space character.
.1625	30 72		bmi $1699			bmi 	_CTUnaryFunctions
.1627	20 80 12	jsr $1280			jsr 	CharIsDigit 				; found a number
.162a	b0 3a		bcs $1666			bcs 	_CTDigit
.162c	c9 2e		cmp #$2e			cmp 	#"."
.162e	f0 36		beq $1666			beq 	_CTDigit
.1630	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1632	f0 43		beq $1677			beq 	_CTString
.1634	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1636	f0 28		beq $1660			beq 	_CTOtherBase
.1638	c9 24		cmp #$24			cmp 	#"$"
.163a	f0 24		beq $1660			beq 	_CTOtherBase
.163c	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.163e	f0 17		beq $1657			beq 	_CTBrackets
.1640	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1642	90 10		bcc $1654			bcc 	_CTSyntax
.1644	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1646	b0 0c		bcs $1654			bcs 	_CTSyntax
.1648	20 b7 15	jsr $15b7			jsr 	GetReferenceTerm 			; figure out what it is.
.164b	48		pha				pha 								; save type on stack
.164c	18		clc				clc 								; read it
.164d	20 69 15	jsr $1569			jsr 	GetSetVariable
.1650	68		pla				pla
.1651	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1653	60		rts				rts
.1654					_CTSyntax:
.1654	4c 5f 17	jmp $175f		jmp	ErrorV_syntax
.1657					_CTBrackets:
.1657	20 16 0c	jsr $0c16			jsr 	CompileExpressionAt0
.165a	48		pha				pha
.165b	20 62 09	jsr $0962			jsr 	CheckNextRParen
.165e	68		pla				pla
.165f	60		rts				rts
.1660					_CTOtherBase:
.1660	20 ae 08	jsr $08ae			jsr 	InlineNonDecimal 			; non decimal constant handler
.1663	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1665	60		rts				rts
.1666					_CTDigit:
.1666	20 bf 14	jsr $14bf			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1669	90 06		bcc $1671			bcc	 	_CTFloat 					; have a float or long int.
.166b	20 16 0a	jsr $0a16			jsr 	PushIntegerYA 				; code to push on stack
.166e	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1670	60		rts				rts
.1671					_CTFloat:
.1671	20 38 0a	jsr $0a38			jsr 	PushFloatCommand			; code to push float
.1674	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1676	60		rts				rts
.1677					_CTString:
.1677	20 37 09	jsr $0937			jsr 	BufferClear 				; copy it to the buffer
.167a					_CTStringLoop:
.167a	20 5a 12	jsr $125a			jsr 	LookNext 					; reached EOL/EOS
.167d	f0 d5		beq $1654			beq 	_CTSyntax
.167f	c9 22		cmp #$22			cmp 	#'"'
.1681	f0 08		beq $168b			beq 	_CTStringDone
.1683	20 3b 09	jsr $093b			jsr 	BufferWrite 				; write and consume
.1686	20 6b 12	jsr $126b			jsr 	GetNext
.1689	80 ef		bra $167a			bra 	_CTStringLoop
.168b					_CTStringDone:
.168b	20 6b 12	jsr $126b			jsr 	GetNext 					; consume closing quote.
.168e	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1690	20 00 09	jsr $0900			jsr 	WriteCodeByte
.1693	20 47 09	jsr $0947			jsr 	BufferOutput
.1696	a9 40		lda #$40			lda 	#NSSString 					; string type
.1698	60		rts				rts
.1699					_CTUnaryFunctions:
.1699	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.169b	f0 0a		beq $16a7			beq 	_CTNegation
.169d	a2 02		ldx #$02			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.169f	a0 10		ldy #$10			ldy 	#UnaryTables >> 8
.16a1	20 fc 10	jsr $10fc			jsr 	GeneratorProcess
.16a4	90 ae		bcc $1654			bcc		_CTSyntax
.16a6	60		rts				rts
.16a7					_CTNegation:
.16a7	20 22 16	jsr $1622			jsr 	CompileTerm 				; compile a term.
.16aa	48		pha				pha
.16ab	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.16ad	c9 00		cmp #$00			cmp 	#NSSIFloat
.16af	d0 07		bne $16b8			bne 	_CTType 					; error
.16b1	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.16b3	20 00 09	jsr $0900			jsr 	WriteCodeByte
.16b6	68		pla				pla 								; return original type.
.16b7	60		rts				rts
.16b8					_CTType:
.16b8	4c 6f 17	jmp $176f		jmp	ErrorV_type
.16bb					CommandWAIT:
.16bb	20 5d 12	jsr $125d			jsr 	LookNextNonSpace
.16be	c9 2c		cmp #$2c			cmp 	#","
.16c0	f0 10		beq $16d2			beq 	_CWThirdParameter
.16c2	a9 00		lda #$00			lda 	#0
.16c4	20 29 0a	jsr $0a29			jsr 	PushIntegerA
.16c7					_CWExit:
.16c7	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.16c9	20 00 09	jsr $0900			jsr 	WriteCodeByte
.16cc	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.16ce	20 00 09	jsr $0900			jsr 	WriteCodeByte
.16d1	60		rts				rts
.16d2					_CWThirdParameter:
.16d2	20 6b 12	jsr $126b			jsr 	GetNext
.16d5	20 18 0c	jsr $0c18			jsr 	CompileExpressionAtA
.16d8	29 40		and #$40			and 	#NSSTypeMask
.16da	c9 00		cmp #$00			cmp 	#NSSIFloat
.16dc	f0 e9		beq $16c7			beq 	_CWExit
.16de	4c 6f 17	jmp $176f		jmp	ErrorV_type
.16e1					CommandCMD:
.16e1	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.16e3	20 00 09	jsr $0900			jsr 	WriteCodeByte
.16e6	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; followed by a , ?
.16e9	c9 2c		cmp #$2c			cmp 	#","
.16eb	d0 06		bne $16f3			bne 	_CCMDExit
.16ed	20 6b 12	jsr $126b			jsr 	GetNext 					; consume comma.
.16f0	20 e4 14	jsr $14e4			jsr 	CommandPRINT 				; do the print code
.16f3					_CCMDExit:
.16f3	60		rts				rts
.16f4					CommandOPEN:
.16f4	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; followed by a , ?
.16f7	c9 2c		cmp #$2c			cmp 	#","
.16f9	d0 15		bne $1710			bne 	_COTwoDefaults
.16fb	20 6b 12	jsr $126b			jsr 	GetNext 					; consume comma
.16fe	20 16 0c	jsr $0c16			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1701	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1703	f0 1e		beq $1723			beq 	_COThreeIntegers
.1705	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1707	20 29 0a	jsr $0a29			jsr 	PushIntegerA
.170a	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.170c	20 00 09	jsr $0900			jsr 	WriteCodeByte
.170f	60		rts				rts
.1710					_COTwoDefaults:
.1710	a9 00		lda #$00			lda 	#0
.1712	20 29 0a	jsr $0a29			jsr 	PushIntegerA
.1715					_COCompileNullString:
.1715	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1717	20 00 09	jsr $0900			jsr 	WriteCodeByte
.171a	a9 00		lda #$00			lda 	#0
.171c	20 00 09	jsr $0900			jsr 	WriteCodeByte
.171f	20 00 09	jsr $0900			jsr 	WriteCodeByte
.1722	60		rts				rts
.1723					_COThreeIntegers:
.1723	20 5d 12	jsr $125d			jsr 	LookNextNonSpace 			; is there a ,
.1726	c9 2c		cmp #$2c			cmp 	#","
.1728	d0 eb		bne $1715			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.172a	20 6b 12	jsr $126b			jsr 	GetNext
.172d	20 16 0c	jsr $0c16			jsr 	CompileExpressionAt0 		; should be a filename
.1730	29 40		and #$40			and 	#NSSString
.1732	f0 01		beq $1735			beq 	_COType
.1734	60		rts				rts
.1735					_COType:
.1735	4c 6f 17	jmp $176f		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ff					C64_PI                   = $ff ; $ff pi
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ceb7					C64_BANNER               = $ceb7 ; $ceb7 banner
=$ceb8					C64_EXEC                 = $ceb8 ; $ceb8 exec
=$ceb9					C64_TILE                 = $ceb9 ; $ceb9 tile
=$ceba					C64_EDIT                 = $ceba ; $ceba edit
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$cedb					C64_MWHEEL               = $cedb ; $cedb mwheel
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					objPtr:
>0028							.fill 	2
.002a					zTemp0:
>002a							.fill 	2
.002c					zTemp1:
>002c							.fill 	2
.002e					zTemp2:
>002e							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1738					SetErrorHandler:
.1738	8c 16 05	sty $0516			sty 	ErrorHandlerVector+1
.173b	8e 15 05	stx $0515			stx 	ErrorHandlerVector
.173e	60		rts				rts
.173f					CallErrorHandler:
.173f	6c 15 05	jmp ($0515)			jmp 	(ErrorHandlerVector)
.0515					ErrorHandlerVector:
>0515							.fill 	2
.1742					ErrorV_range:
.1742	20 3f 17	jsr $173f		jsr	CallErrorHandler
>1745	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>174d	41 4e 47 45 00
.1752					ErrorV_value:
.1752	20 3f 17	jsr $173f		jsr	CallErrorHandler
>1755	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>175d	45 00
.175f					ErrorV_syntax:
.175f	20 3f 17	jsr $173f		jsr	CallErrorHandler
>1762	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>176a	52 52 4f 52 00
.176f					ErrorV_type:
.176f	20 3f 17	jsr $173f		jsr	CallErrorHandler
>1772	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>177a	4d 41 54 43 48 00
.1780					ErrorV_unimplemented:
.1780	20 3f 17	jsr $173f		jsr	CallErrorHandler
>1783	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>178b	45 4d 45 4e 54 45 44 00
.1793					ErrorV_assert:
.1793	20 3f 17	jsr $173f		jsr	CallErrorHandler
>1796	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>179e	41 49 4c 00
.17a2					ErrorV_line:
.17a2	20 3f 17	jsr $173f		jsr	CallErrorHandler
>17a5	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>17ad	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.17b9					ErrorV_internal:
.17b9	20 3f 17	jsr $173f		jsr	CallErrorHandler
>17bc	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>17c4	20 45 52 52 4f 52 00
.17cb					ErrorV_divzero:
.17cb	20 3f 17	jsr $173f		jsr	CallErrorHandler
>17ce	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>17d6	59 20 5a 45 52 4f 00
.17dd					ErrorV_structure:
.17dd	20 3f 17	jsr $173f		jsr	CallErrorHandler
>17e0	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>17e8	45 20 49 4d 42 41 4c 41 4e 43 45 00
.17f4					ErrorV_stop:
.17f4	20 3f 17	jsr $173f		jsr	CallErrorHandler
>17f7	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>17ff	53 54 4f 50 50 45 44 00
.1807					ErrorV_data:
.1807	20 3f 17	jsr $173f		jsr	CallErrorHandler
>180a	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1812	41 54 41 00
.1816					ErrorV_undeclared:
.1816	20 3f 17	jsr $173f		jsr	CallErrorHandler
>1819	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1821	41 52 52 41 59 00
.1827					ErrorV_redefine:
.1827	20 3f 17	jsr $173f		jsr	CallErrorHandler
>182a	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1832	44 45 46 49 4e 45 44 00
.183a					ErrorV_index:
.183a	20 3f 17	jsr $173f		jsr	CallErrorHandler
>183d	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1845	59 20 49 4e 44 45 58 00
.184d					ErrorV_memory:
.184d	20 3f 17	jsr $173f		jsr	CallErrorHandler
>1850	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>1858	45 4d 4f 52 59 00
.185e					ErrorV_channel:
.185e	20 3f 17	jsr $173f		jsr	CallErrorHandler
>1861	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>1869	54 50 55 54 20 45 52 52 4f 52 00
.1874					ErrorV_break:
.1874	20 3f 17	jsr $173f		jsr	CallErrorHandler
>1877	42 52 45 41 4b 20 50 52			.text	"BREAK PRESSED",0
>187f	45 53 53 45 44 00
.1885					MoveObjectForward:
.1885	b2 28		lda ($28)			lda 	(objPtr) 					; get next
.1887	c9 ff		cmp #$ff			cmp 	#$FF
.1889	f0 36		beq $18c1			beq 	_MOFEnd
.188b	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.188d	90 24		bcc $18b3			bcc 	_MOFAdvance1 				; forward 1
.188f	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.1891	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.1893	90 20		bcc $18b5			bcc 	_MOFAdvanceY
.1895	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.1897	90 1a		bcc $18b3			bcc 	_MOFAdvance1 				; forward 1
.1899	a8		tay				tay 								; read the size.
.189a	b9 ff 17	lda $17ff,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.189d	a8		tay				tay
.189e	c8		iny				iny 								; add 1 for the system token.
.189f	d0 14		bne $18b5			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.18a1	a0 01		ldy #$01			ldy 	#1 							; get length byte
.18a3	b1 28		lda ($28),y			lda 	(objPtr),y
.18a5	a8		tay				tay 								; into Y.
.18a6	18		clc				clc
.18a7	a5 28		lda $28				lda 	objPtr						; add 2 to the object pointer
.18a9	69 02		adc #$02			adc 	#2
.18ab	85 28		sta $28				sta 	objPtr
.18ad	90 02		bcc $18b1			bcc 	_MOFNoCarry1
.18af	e6 29		inc $29				inc 	objPtr+1
.18b1					_MOFNoCarry1:
.18b1	80 02		bra $18b5			bra 	_MOFAdvanceY
.18b3					_MOFAdvance1:
.18b3	a0 01		ldy #$01			ldy 	#1
.18b5					_MOFAdvanceY:
.18b5	98		tya				tya 								; add Y to objPtr
.18b6	18		clc				clc
.18b7	65 28		adc $28				adc 	objPtr
.18b9	85 28		sta $28				sta 	objPtr
.18bb	90 02		bcc $18bf			bcc 	_MOFNoCarry2
.18bd	e6 29		inc $29				inc 	objPtr+1
.18bf					_MOFNoCarry2:
.18bf	18		clc				clc 								; not completed.
.18c0	60		rts				rts
.18c1					_MOFEnd:
.18c1	e6 28		inc $28				inc 	objPtr
.18c3	d0 02		bne $18c7			bne 	_MOFENoCarry
.18c5	e6 29		inc $29				inc 	objPtr+1
.18c7					_MOFENoCarry:
.18c7	38		sec				sec
.18c8	60		rts				rts
.18c9					MOFSizeTable:
>18c9	01					.byte	1         	; $ca .shift
>18ca	01					.byte	1         	; $cb .byte
>18cb	02					.byte	2         	; $cc .word
>18cc	05					.byte	5         	; $cd .float
>18cd	ff					.byte	255       	; $ce .string
>18ce	ff					.byte	255       	; $cf .data
>18cf	02					.byte	2         	; $d0 .goto
>18d0	02					.byte	2         	; $d1 .gosub
>18d1	02					.byte	2         	; $d2 .goto.z
>18d2	02					.byte	2         	; $d3 .goto.nz
>18d3	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0030					NSStatus:
>0030							.fill 	MathStackSize
.003c					NSMantissa0:
>003c							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0048					NSMantissa1:
>0048							.fill 	MathStackSize
.0054					NSMantissa2:
>0054							.fill 	MathStackSize
.0060					NSMantissa3:
>0060							.fill 	MathStackSize
.006c					NSExponent:
>006c							.fill 	MathStackSize
.0517					numberBuffer:
>0517							.fill 	34
.18d4					FloatSubtract:
.18d4	b5 30		lda $30,x			lda 	NSStatus,x 					; negate top of stack
.18d6	49 80		eor #$80			eor 	#$80
.18d8	95 30		sta $30,x			sta 	NSStatus,x					; and fall through.
.18da					FloatAdd:
.18da	ca		dex				dex
.18db	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised.
.18dd	15 6d		ora $6d,x			ora 	NSExponent+1,x
.18df	15 60		ora $60,x			ora 	NSMantissa3,x
.18e1	15 61		ora $61,x			ora 	NSMantissa3+1,x
.18e3	d0 04		bne $18e9			bne 	_FAUseFloat
.18e5	20 76 1c	jsr $1c76			jsr 	FloatInt32Add 				; use the int32 one.
.18e8	60		rts				rts
.18e9					_FAUseFloat:
.18e9	20 0b 1c	jsr $1c0b			jsr 	FloatNormalise 				; normalise S[X]
.18ec	f0 51		beq $193f			beq 	_FAReturn1
.18ee	e8		inx				inx 								; normalise S[X+1]
.18ef	20 0b 1c	jsr $1c0b			jsr 	FloatNormalise
.18f2	ca		dex				dex
.18f3	c9 00		cmp #$00			cmp 	#0
.18f5	f0 60		beq $1957			beq 	_FAExit 					; if so, just return A
.18f7	b5 6c		lda $6c,x			lda 	NSExponent,x 				; are the exponents the same ?
.18f9	d5 6d		cmp $6d,x			cmp 	NSExponent+1,x
.18fb	f0 18		beq $1915			beq 	_FAExponentsEqual
.18fd	b5 6c		lda $6c,x			lda 	NSExponent,x 				; work out the larger exponent
.18ff	a8		tay				tay
.1900	38		sec				sec 								; do a signed comparison of the exponents.
.1901	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.1903	50 02		bvc $1907			bvc 	_FANoSignedChange
.1905	49 80		eor #$80			eor 	#$80
.1907					_FANoSignedChange:
.1907	29 80		and #$80			and 	#$80
.1909	10 02		bpl $190d			bpl 	_FAHaveMax
.190b	b4 6d		ldy $6d,x			ldy 	NSExponent+1,x
.190d					_FAHaveMax:
.190d	20 58 19	jsr $1958			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.1910	e8		inx				inx
.1911	20 58 19	jsr $1958			jsr 	_FAShiftToExponent
.1914	ca		dex				dex
.1915					_FAExponentsEqual:
.1915	b5 30		lda $30,x			lda 	NSStatus,x 					; are the signs the same
.1917	55 31		eor $31,x			eor 	NSStatus+1,x
.1919	30 0e		bmi $1929			bmi 	_FADifferentSigns
.191b	20 42 1c	jsr $1c42			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.191e	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.1920	10 35		bpl $1957			bpl 	_FAExit 					; if no, we are done.
.1922	20 cf 1e	jsr $1ecf			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.1925	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump the exponent and exit
.1927	80 2e		bra $1957			bra 	_FAExit
.1929					_FADifferentSigns:
.1929	20 5c 1c	jsr $1c5c			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.192c	b5 60		lda $60,x			lda 	NSMantissa3,x 				; is the result negative ?
.192e	10 06		bpl $1936			bpl 	_FACheckZero 				; if no, check for -0
.1930	20 78 1e	jsr $1e78			jsr 	FloatNegate 					; netate result
.1933	20 7f 1e	jsr $1e7f			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.1936					_FACheckZero:
.1936	20 d8 1e	jsr $1ed8			jsr 	FloatIsZero	 				; check for -0
.1939	d0 1c		bne $1957			bne 	_FAExit
.193b	74 30		stz $30,x			stz 	NSStatus,x
.193d	80 18		bra $1957			bra 	_FAExit
.193f					_FAReturn1:
.193f	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.1941	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1943	b5 49		lda $49,x			lda 	NSMantissa1+1,x
.1945	95 48		sta $48,x			sta 	NSMantissa1,x
.1947	b5 55		lda $55,x			lda 	NSMantissa2+1,x
.1949	95 54		sta $54,x			sta 	NSMantissa2,x
.194b	b5 61		lda $61,x			lda 	NSMantissa3+1,x
.194d	95 60		sta $60,x			sta 	NSMantissa3,x
.194f	b5 6d		lda $6d,x			lda 	NSExponent+1,x
.1951	95 6c		sta $6c,x			sta 	NSExponent,x
.1953	b5 31		lda $31,x			lda 	NSStatus+1,x
.1955	95 30		sta $30,x			sta 	NSStatus,x
.1957					_FAExit:
.1957	60		rts				rts
.1958					_FAShiftToExponent:
.1958					_FAShiftToExponent2:
.1958	98		tya				tya 								; compare Y to exponent
.1959	d5 6c		cmp $6c,x			cmp 	NSExponent,x 				; reached the exponent required ?
.195b	f0 07		beq $1964			beq 	_FASEExit 					; exit if so.
.195d	20 cf 1e	jsr $1ecf			jsr 	FloatShiftRight	 			; shift the mantissa right
.1960	f6 6c		inc $6c,x			inc 	NSExponent,x 				; increment exponent
.1962	80 f4		bra $1958			bra 	_FAShiftToExponent2
.1964					_FASEExit:
.1964	60		rts				rts
.1965					CompareEqual:
.1965	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1967	d0 09		bne $1972			bne 	ReturnFalse
.1969					ReturnTrue:
.1969	a9 01		lda #$01			lda 	#1
.196b	95 3c		sta $3c,x			sta 	NSMantissa0,x
.196d	a9 80		lda #$80			lda 	#$80
.196f	95 30		sta $30,x			sta 	NSStatus,x
.1971	60		rts				rts
.1972					ReturnFalse:
.1972	74 3c		stz $3c,x			stz 	NSMantissa0,x
.1974	60		rts				rts
.1975					CompareNotEqual:
.1975	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1977	d0 f0		bne $1969			bne 	ReturnTrue
.1979	80 f7		bra $1972			bra 	ReturnFalse
.197b					CompareLess:
.197b	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.197d	c9 ff		cmp #$ff			cmp 	#$FF
.197f	f0 e8		beq $1969			beq 	ReturnTrue
.1981	80 ef		bra $1972			bra 	ReturnFalse
.1983					CompareGreater:
.1983	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1985	c9 01		cmp #$01			cmp 	#$01
.1987	f0 e0		beq $1969			beq 	ReturnTrue
.1989	80 e7		bra $1972			bra 	ReturnFalse
.198b					CompareLessEqual:
.198b	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.198d	c9 01		cmp #$01			cmp 	#$01
.198f	d0 d8		bne $1969			bne 	ReturnTrue
.1991	80 df		bra $1972			bra 	ReturnFalse
.1993					CompareGreaterEqual:
.1993	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1995	c9 ff		cmp #$ff			cmp 	#$FF
.1997	d0 d0		bne $1969			bne 	ReturnTrue
.1999	80 d7		bra $1972			bra 	ReturnFalse
.199b					FloatCompare:
.199b	b5 6c		lda $6c,x			lda 	NSExponent,x 				; float comparison.
.199d	15 6b		ora $6b,x			ora 	NSExponent-1,x 				; integer if both integer.
.199f	48		pha				pha
.19a0	20 d4 18	jsr $18d4			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.19a3	68		pla				pla
.19a4	d0 0c		bne $19b2			bne 	_FCCompareFloat
.19a6	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.19a8	15 48		ora $48,x			ora 	NSMantissa1,x
.19aa	15 54		ora $54,x			ora 	NSMantissa2,x
.19ac	15 60		ora $60,x			ora 	NSMantissa3,x
.19ae	f0 14		beq $19c4			beq 	_FCExit 					; if zero, return zero
.19b0	80 0a		bra $19bc			bra 	_FCSign
.19b2					_FCCompareFloat:
.19b2	b5 48		lda $48,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.19b4	29 f0		and #$f0			and 	#$F0
.19b6	15 54		ora $54,x			ora 	NSMantissa2,x
.19b8	15 60		ora $60,x			ora 	NSMantissa3,x
.19ba	f0 08		beq $19c4			beq 	_FCExit 					; zero, so approximately identical
.19bc					_FCSign:
.19bc	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.19be	34 30		bit $30,x			bit 	NSStatus,x
.19c0	10 02		bpl $19c4			bpl 	_FCExit
.19c2					_FCNegative:
.19c2	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.19c4					_FCExit:
.19c4	20 b8 1e	jsr $1eb8			jsr 	FloatSetByte 				; set the result 255,0,1
.19c7	60		rts				rts
.19c8					FloatScalarTable:
>19c8	66 66 66 66				.dword $66666666 ; 0.1
>19cc	de					.byte $de
>19cd	1f 85 eb 51				.dword $51eb851f ; 0.01
>19d1	db					.byte $db
>19d2	4c 37 89 41				.dword $4189374c ; 0.001
>19d6	d8					.byte $d8
>19d7	ac 8b db 68				.dword $68db8bac ; 0.0001
>19db	d4					.byte $d4
>19dc	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>19e0	d1					.byte $d1
>19e1	83 de 1b 43				.dword $431bde83 ; 1e-06
>19e5	ce					.byte $ce
>19e6	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>19ea	ca					.byte $ca
>19eb	89 3b e6 55				.dword $55e63b89 ; 1e-08
>19ef	c7					.byte $c7
>19f0	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>19f4	c4					.byte $c4
>19f5	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>19f9	c0					.byte $c0
>19fa	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>19fe	bd					.byte $bd
.19ff					FloatDivide:
.19ff	48		pha				pha
.1a00	20 0b 1c	jsr $1c0b			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.1a03	ca		dex				dex
.1a04	c9 00		cmp #$00			cmp 	#0
.1a06	f0 1e		beq $1a26			beq 	_FDZero
.1a08	20 0b 1c	jsr $1c0b			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.1a0b	f0 16		beq $1a23			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.1a0d	20 6e 1a	jsr $1a6e			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.1a10	20 3b 1a	jsr $1a3b			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.1a13	20 0b 1c	jsr $1c0b			jsr		FloatNormalise 				; renormalise
.1a16	20 01 1c	jsr $1c01			jsr 	FloatCalculateSign 			; calculate result sign
.1a19	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent
.1a1b	38		sec				sec
.1a1c	f5 6d		sbc $6d,x			sbc 	NSExponent+1,x
.1a1e	38		sec				sec
.1a1f	e9 1e		sbc #$1e			sbc 	#30
.1a21	95 6c		sta $6c,x			sta 	NSExponent,x
.1a23					_FDExit:
.1a23	68		pla				pla
.1a24	18		clc				clc
.1a25	60		rts				rts
.1a26					_FDZero:
.1a26	68		pla				pla
.1a27	38		sec				sec
.1a28	60		rts				rts
.1a29					DivideInt32:
.1a29	20 f1 1a	jsr $1af1			jsr 	FloatIntegerPart 			; make both integers
.1a2c	ca		dex				dex
.1a2d	20 f1 1a	jsr $1af1			jsr 	FloatIntegerPart
.1a30	20 4c 1a	jsr $1a4c			jsr 	Int32Divide 				; divide
.1a33	20 3b 1a	jsr $1a3b			jsr 	NSMCopyPlusTwoToZero 		; copy result
.1a36	20 01 1c	jsr $1c01			jsr 	FloatCalculateSign 			; calculate result sign
.1a39	18		clc				clc
.1a3a	60		rts				rts
.1a3b					NSMCopyPlusTwoToZero:
.1a3b	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.1a3d	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1a3f	b5 4a		lda $4a,x			lda 	NSMantissa1+2,x
.1a41	95 48		sta $48,x			sta 	NSMantissa1,x
.1a43	b5 56		lda $56,x			lda 	NSMantissa2+2,x
.1a45	95 54		sta $54,x			sta 	NSMantissa2,x
.1a47	b5 62		lda $62,x			lda 	NSMantissa3+2,x
.1a49	95 60		sta $60,x			sta 	NSMantissa3,x
.1a4b	60		rts				rts
.1a4c					Int32Divide:
.1a4c	48		pha				pha 								; save AXY
.1a4d	5a		phy				phy
.1a4e	20 99 1e	jsr $1e99			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.1a51	20 b2 1e	jsr $1eb2			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.1a54	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.1a56					_I32DivideLoop:
.1a56	e8		inx				inx
.1a57	e8		inx				inx
.1a58	20 c5 1e	jsr $1ec5			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.1a5b	ca		dex				dex
.1a5c	ca		dex				dex
.1a5d	20 c6 1e	jsr $1ec6			jsr 	FloatRotateLeft
.1a60	20 8c 1a	jsr $1a8c			jsr 	FloatDivideCheck 			; check if subtract possible
.1a63	90 02		bcc $1a67			bcc 	_I32DivideNoCarryIn
.1a65	f6 3e		inc $3e,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.1a67					_I32DivideNoCarryIn:
.1a67	88		dey				dey 								; loop round till division completed.
.1a68	d0 ec		bne $1a56			bne 	_I32DivideLoop
.1a6a	7a		ply				ply 								; restore AXY and exit
.1a6b	68		pla				pla
.1a6c	18		clc				clc
.1a6d	60		rts				rts
.1a6e					Int32ShiftDivide:
.1a6e	48		pha				pha 								; save AY
.1a6f	5a		phy				phy
.1a70	e8		inx				inx 								; clear S[X+2]
.1a71	e8		inx				inx
.1a72	20 b6 1e	jsr $1eb6			jsr 	FloatSetZero
.1a75	ca		dex				dex
.1a76	ca		dex				dex
.1a77	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.1a79					_I32SDLoop:
.1a79	20 8c 1a	jsr $1a8c			jsr 	FloatDivideCheck 			; check if subtract possible
.1a7c	e8		inx				inx
.1a7d	e8		inx				inx
.1a7e	20 c6 1e	jsr $1ec6			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.1a81	ca		dex				dex
.1a82	ca		dex				dex
.1a83	20 c6 1e	jsr $1ec6			jsr 	FloatRotateLeft
.1a86	88		dey				dey 	 							; do 31 times
.1a87	d0 f0		bne $1a79			bne 	_I32SDLoop
.1a89	7a		ply				ply 								; restore AY and exit
.1a8a	68		pla				pla
.1a8b	60		rts				rts
.1a8c					FloatDivideCheck:
.1a8c	20 5c 1c	jsr $1c5c			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.1a8f	b0 04		bcs $1a95			bcs 	_DCSExit 					; if carry set, then could do, exit
.1a91	20 42 1c	jsr $1c42			jsr 	FloatAddTopTwoStack 		; add it back in
.1a94	18		clc				clc 								; and return False
.1a95					_DCSExit:
.1a95	60		rts				rts
.1a96					FloatFractionalPart:
.1a96	5a		phy				phy
.1a97	b5 30		lda $30,x			lda 	NSStatus,x 					; take absolute value
.1a99	29 7f		and #$7f			and 	#$7F
.1a9b	95 30		sta $30,x			sta 	NSStatus,x
.1a9d	20 0b 1c	jsr $1c0b			jsr 	FloatNormalise
.1aa0	b5 6c		lda $6c,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.1aa2	38		sec				sec
.1aa3	e9 e0		sbc #$e0			sbc 	#$E0
.1aa5	90 29		bcc $1ad0			bcc 	_FFPExit 					; already fractional
.1aa7	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.1aa9	b0 22		bcs $1acd			bcs 	_FFPZero
.1aab	a8		tay				tay 								; put count to do in Y
.1aac	b5 60		lda $60,x			lda 	NSMantissa3,x 				; do each in turn.
.1aae	20 d5 1a	jsr $1ad5			jsr 	_FFPPartial
.1ab1	95 60		sta $60,x			sta 	NSMantissa3,x
.1ab3	b5 54		lda $54,x			lda 	NSMantissa2,x
.1ab5	20 d5 1a	jsr $1ad5			jsr 	_FFPPartial
.1ab8	95 54		sta $54,x			sta 	NSMantissa2,x
.1aba	b5 48		lda $48,x			lda 	NSMantissa1,x
.1abc	20 d5 1a	jsr $1ad5			jsr 	_FFPPartial
.1abf	95 48		sta $48,x			sta 	NSMantissa1,x
.1ac1	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1ac3	20 d5 1a	jsr $1ad5			jsr 	_FFPPartial
.1ac6	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1ac8	20 d8 1e	jsr $1ed8			jsr 	FloatIsZero 					; zeroed check.
.1acb	d0 03		bne $1ad0			bne 	_FFPExit
.1acd					_FFPZero:
.1acd	20 b6 1e	jsr $1eb6			jsr 	FloatSetZero
.1ad0					_FFPExit:
.1ad0	20 0b 1c	jsr $1c0b			jsr 	FloatNormalise
.1ad3	7a		ply				ply
.1ad4	60		rts				rts
.1ad5					_FFPPartial:
.1ad5	c0 00		cpy #$00			cpy 	#0 							; no more to do
.1ad7	f0 17		beq $1af0			beq 	_FFFPPExit
.1ad9	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.1adb	b0 0c		bcs $1ae9			bcs 	_FFFPPWholeByte
.1add	5a		phy				phy
.1ade					_FFFPPLeft:
.1ade	0a		asl a				asl 	a
.1adf	88		dey				dey
.1ae0	d0 fc		bne $1ade			bne 	_FFFPPLeft
.1ae2	7a		ply				ply
.1ae3					_FFFPPRight:
.1ae3	4a		lsr a				lsr 	a
.1ae4	88		dey				dey
.1ae5	d0 fc		bne $1ae3			bne 	_FFFPPRight
.1ae7	80 07		bra $1af0			bra 	_FFFPPExit
.1ae9					_FFFPPWholeByte:
.1ae9	98		tya				tya 								; subtract 8 from count
.1aea	38		sec				sec
.1aeb	e9 08		sbc #$08			sbc 	#8
.1aed	a8		tay				tay
.1aee	a9 00		lda #$00			lda 	#0 							; and clear all
.1af0					_FFFPPExit:
.1af0	60		rts				rts
.1af1					FloatIntegerPart:
.1af1	48		pha				pha
.1af2	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.1af4	f0 1d		beq $1b13			beq 	_FIPExit 					; if so do nothing
.1af6	20 d8 1e	jsr $1ed8			jsr 	FloatIsZero 				; is it zero ?
.1af9	f0 15		beq $1b10			beq 	_FIPZero 					; if so return zero.
.1afb	20 0b 1c	jsr $1c0b			jsr 	FloatNormalise 				; normalise
.1afe	f0 10		beq $1b10			beq 	_FIPZero 					; normalised to zero, exit zero
.1b00					_FIPShift:
.1b00	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.1b02	10 07		bpl $1b0b			bpl 	_FIPCheckZero
.1b04	20 cf 1e	jsr $1ecf			jsr 	FloatShiftRight 			; shift mantissa right
.1b07	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.1b09	80 f5		bra $1b00			bra 	_FIPShift
.1b0b					_FIPCheckZero:
.1b0b	20 d8 1e	jsr $1ed8			jsr 	FloatIsZero 				; avoid -0 problem
.1b0e	d0 03		bne $1b13			bne 	_FIPExit 					; set to zero if mantissa zero.
.1b10					_FIPZero:
.1b10	20 b6 1e	jsr $1eb6			jsr 	FloatSetZero
.1b13					_FIPExit:
.1b13	68		pla				pla
.1b14	60		rts				rts
.1b15					FloatIntegerPartDown:
.1b15	48		pha				pha
.1b16	5a		phy				phy
.1b17	b5 6c		lda $6c,x			lda 	NSExponent,x 				; is it integer already ?
.1b19	f0 36		beq $1b51			beq 	_FIPExit 					; if so do nothing
.1b1b	20 d8 1e	jsr $1ed8			jsr 	FloatIsZero 				; is it zero ?
.1b1e	f0 2e		beq $1b4e			beq 	_FIPZero 					; if so return zero.
.1b20	20 0b 1c	jsr $1c0b			jsr 	FloatNormalise 				; normalise
.1b23	f0 29		beq $1b4e			beq 	_FIPZero 					; normalised to zero, exit zero
.1b25	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.1b27					_FIPShift:
.1b27	b5 6c		lda $6c,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.1b29	10 0a		bpl $1b35			bpl 	_FIPCheckDown
.1b2b	20 cf 1e	jsr $1ecf			jsr 	FloatShiftRight 			; shift mantissa right
.1b2e	90 01		bcc $1b31			bcc 	_FIPNoFrac 					; shifted a zero out ?
.1b30	c8		iny				iny
.1b31					_FIPNoFrac:
.1b31	f6 6c		inc $6c,x			inc 	NSExponent,x 				; bump exponent
.1b33	80 f2		bra $1b27			bra 	_FIPShift
.1b35					_FIPCheckDown:
.1b35	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.1b37	f0 10		beq $1b49			beq 	_FIPCheckZero
.1b39	34 30		bit $30,x			bit 	NSStatus,x 					; +ve
.1b3b	10 0c		bpl $1b49			bpl 	_FIPCheckZero
.1b3d	e8		inx				inx 								; -ve so round *down*.
.1b3e	a9 01		lda #$01			lda 	#1
.1b40	20 b8 1e	jsr $1eb8			jsr 	FloatSetByte
.1b43	20 78 1e	jsr $1e78			jsr 	FloatNegate
.1b46	20 da 18	jsr $18da			jsr 	FloatAdd
.1b49					_FIPCheckZero:
.1b49	20 d8 1e	jsr $1ed8			jsr 	FloatIsZero 				; avoid -0 problem
.1b4c	d0 03		bne $1b51			bne 	_FIPExit 					; set to zero if mantissa zero.
.1b4e					_FIPZero:
.1b4e	20 b6 1e	jsr $1eb6			jsr 	FloatSetZero
.1b51					_FIPExit:
.1b51	7a		ply				ply
.1b52	68		pla				pla
.1b53	60		rts				rts
.1b54					FloatInt8Multiply:
.1b54	5a		phy				phy
.1b55	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.1b57	a8		tay				tay
.1b58	74 3c		stz $3c,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.1b5a					_FI8MLoop:
.1b5a	98		tya				tya 								; shift right shifter right into carry
.1b5b	4a		lsr a				lsr 	a
.1b5c	a8		tay				tay
.1b5d	90 0d		bcc $1b6c			bcc 	_FI8MNoAdd
.1b5f	18		clc				clc
.1b60	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1b62	75 3d		adc $3d,x			adc 	NSMantissa0+1,x
.1b64	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1b66	b5 48		lda $48,x			lda 	NSMantissa1,x
.1b68	75 49		adc $49,x			adc 	NSMantissa1+1,x
.1b6a	95 48		sta $48,x			sta 	NSMantissa1,x
.1b6c					_FI8MNoAdd:
.1b6c	16 3d		asl $3d,x			asl 	NSMantissa0+1,x 			; shift adder left
.1b6e	36 49		rol $49,x			rol 	NSMantissa1+1,x
.1b70	c0 00		cpy #$00			cpy 	#0
.1b72	d0 e6		bne $1b5a			bne 	_FI8MLoop 					; until right shifter zero.
.1b74	7a		ply				ply
.1b75	60		rts				rts
.1b76					FloatMultiply:
.1b76	ca		dex				dex
.1b77	b5 6c		lda $6c,x			lda 	NSExponent,x 				; can use optimised ?
.1b79	15 6d		ora $6d,x			ora 	NSExponent+1,x
.1b7b	15 60		ora $60,x			ora 	NSMantissa3,x
.1b7d	15 61		ora $61,x			ora 	NSMantissa3+1,x
.1b7f	d0 21		bne $1ba2			bne 	_FMUseFloat
.1b81	b5 30		lda $30,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.1b83	15 31		ora $31,x			ora 	NSStatus+1,x
.1b85	29 80		and #$80			and 	#$80
.1b87	15 60		ora $60,x			ora 	NSMantissa3,x
.1b89	15 54		ora $54,x			ora 	NSMantissa2,x
.1b8b	15 48		ora $48,x			ora 	NSMantissa1,x
.1b8d	15 61		ora $61,x			ora 	NSMantissa3+1,x
.1b8f	15 55		ora $55,x			ora 	NSMantissa2+1,x
.1b91	15 49		ora $49,x			ora 	NSMantissa1+1,x
.1b93	d0 04		bne $1b99			bne 	_FMInt32
.1b95	20 54 1b	jsr $1b54			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.1b98	60		rts				rts
.1b99					_FMInt32:
.1b99	20 c3 1b	jsr $1bc3			jsr 	FloatMultiplyShort			; use the int32 one.
.1b9c	18		clc				clc 								; fix it up if gone out of range
.1b9d	75 6c		adc $6c,x			adc 	NSExponent,x
.1b9f	95 6c		sta $6c,x			sta 	NSExponent,x
.1ba1	60		rts				rts
.1ba2					_FMUseFloat:
.1ba2	20 0b 1c	jsr $1c0b			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.1ba5	f0 18		beq $1bbf			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.1ba7	e8		inx				inx
.1ba8	20 0b 1c	jsr $1c0b			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.1bab	ca		dex				dex
.1bac	c9 00		cmp #$00			cmp 	#0
.1bae	f0 0c		beq $1bbc			beq 	_FDSetZero
.1bb0	20 c3 1b	jsr $1bc3			jsr 	FloatMultiplyShort 			; calculate the result.
.1bb3	75 6c		adc $6c,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.1bb5	18		clc				clc
.1bb6	75 6d		adc $6d,x			adc 	NSExponent+1,x
.1bb8	95 6c		sta $6c,x			sta 	NSExponent,x
.1bba	80 03		bra $1bbf			bra 	_FDExit
.1bbc					_FDSetZero:
.1bbc	20 b6 1e	jsr $1eb6			jsr 	FloatSetZero 				; return 0
.1bbf					_FDExit:
.1bbf	20 0b 1c	jsr $1c0b			jsr 	FloatNormalise 				; normalise the result
.1bc2	60		rts				rts
.1bc3					FloatMultiplyShort:
.1bc3	5a		phy				phy 								; save Y
.1bc4	20 99 1e	jsr $1e99			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.1bc7	20 b2 1e	jsr $1eb2			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.1bca	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.1bcc					_I32MLoop:
.1bcc	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.1bce	15 4a		ora $4a,x			ora 	NSMantissa1+2,x
.1bd0	15 56		ora $56,x			ora 	NSMantissa2+2,x
.1bd2	15 62		ora $62,x			ora 	NSMantissa3+2,x
.1bd4	f0 25		beq $1bfb			beq 	_I32MExit 					; exit if zero
.1bd6	b5 3e		lda $3e,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.1bd8	29 01		and #$01			and 	#1
.1bda	f0 0d		beq $1be9			beq 	_I32MNoAdd
.1bdc	20 42 1c	jsr $1c42			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.1bdf	b5 60		lda $60,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.1be1	10 06		bpl $1be9			bpl 	_I32MNoAdd
.1be3					_I32ShiftRight:
.1be3	20 cf 1e	jsr $1ecf			jsr 	FloatShiftRight 			; shift S[X] right
.1be6	c8		iny				iny 								; increment shift count
.1be7	80 09		bra $1bf2			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.1be9					_I32MNoAdd:
.1be9	34 61		bit $61,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.1beb	70 f6		bvs $1be3			bvs 	_I32ShiftRight 				; instead.
.1bed	e8		inx				inx
.1bee	20 c5 1e	jsr $1ec5			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.1bf1	ca		dex				dex
.1bf2					_I32MShiftUpper:
.1bf2	e8		inx				inx 								; shift S[X+2] right
.1bf3	e8		inx				inx
.1bf4	20 cf 1e	jsr $1ecf			jsr 	FloatShiftRight
.1bf7	ca		dex				dex
.1bf8	ca		dex				dex
.1bf9	80 d1		bra $1bcc			bra 	_I32MLoop 					; try again.
.1bfb					_I32MExit:
.1bfb	20 01 1c	jsr $1c01			jsr 	FloatCalculateSign
.1bfe	98		tya				tya 								; shift in A
.1bff	7a		ply				ply 								; restore Y and exit
.1c00	60		rts				rts
.1c01					FloatCalculateSign:
.1c01	b5 30		lda $30,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.1c03	16 30		asl $30,x			asl 	NSStatus,x 					; shift result left
.1c05	55 31		eor $31,x			eor 	NSStatus+1,x
.1c07	0a		asl a				asl 	a 							; shift bit 7 into carry
.1c08	76 30		ror $30,x			ror 	NSStatus,x 					; shift right into status byte.
.1c0a	60		rts				rts
.1c0b					FloatNormalise:
.1c0b	20 d8 1e	jsr $1ed8			jsr 	FloatIsZero 				; if zero exit
.1c0e	d0 07		bne $1c17			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.1c10	16 30		asl $30,x			asl 	NSStatus,x 					; clear the sign bit.
.1c12	76 30		ror $30,x			ror 	NSStatus,x 					; (no -0)
.1c14	a9 00		lda #$00			lda 	#0 							; set Z flag
.1c16	60		rts				rts
.1c17					_NSNormaliseOptimise:
.1c17	b5 60		lda $60,x			lda 	NSMantissa3,x 				; upper byte zero ?
.1c19	d0 19		bne $1c34			bne 	_NSNormaliseLoop
.1c1b	b5 54		lda $54,x			lda 	NSMantissa2,x 				; byte normalise
.1c1d	30 15		bmi $1c34			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.1c1f	95 60		sta $60,x			sta 	NSMantissa3,x
.1c21	b5 48		lda $48,x			lda 	NSMantissa1,x
.1c23	95 54		sta $54,x			sta 	NSMantissa2,x
.1c25	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1c27	95 48		sta $48,x			sta 	NSMantissa1,x
.1c29	74 3c		stz $3c,x			stz 	NSMantissa0,x
.1c2b	b5 6c		lda $6c,x			lda 	NSExponent,x
.1c2d	38		sec				sec
.1c2e	e9 08		sbc #$08			sbc 	#8
.1c30	95 6c		sta $6c,x			sta 	NSExponent,x
.1c32	80 e3		bra $1c17			bra 	_NSNormaliseOptimise
.1c34					_NSNormaliseLoop:
.1c34	34 60		bit $60,x			bit 	NSMantissa3,x 				; bit 30 set ?
.1c36	70 07		bvs $1c3f			bvs 	_NSNExit 					; exit if so with Z flag clear
.1c38	20 c5 1e	jsr $1ec5			jsr 	FloatShiftLeft 				; shift mantissa left
.1c3b	d6 6c		dec $6c,x			dec 	NSExponent,x 				; adjust exponent
.1c3d	80 f5		bra $1c34			bra 	_NSNormaliseLoop
.1c3f					_NSNExit:
.1c3f	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.1c41	60		rts				rts
.1c42					FloatAddTopTwoStack:
.1c42	18		clc				clc
.1c43	b5 3c		lda $3c,x			lda		NSMantissa0,x
.1c45	75 3d		adc $3d,x			adc 		NSMantissa0+1,x
.1c47	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1c49	b5 48		lda $48,x			lda		NSMantissa1,x
.1c4b	75 49		adc $49,x			adc 		NSMantissa1+1,x
.1c4d	95 48		sta $48,x			sta 	NSMantissa1,x
.1c4f	b5 54		lda $54,x			lda		NSMantissa2,x
.1c51	75 55		adc $55,x			adc 		NSMantissa2+1,x
.1c53	95 54		sta $54,x			sta 	NSMantissa2,x
.1c55	b5 60		lda $60,x			lda		NSMantissa3,x
.1c57	75 61		adc $61,x			adc 		NSMantissa3+1,x
.1c59	95 60		sta $60,x			sta 	NSMantissa3,x
.1c5b	60		rts				rts
.1c5c					FloatSubTopTwoStack:
.1c5c	38		sec				sec
.1c5d	b5 3c		lda $3c,x			lda		NSMantissa0,x
.1c5f	f5 3d		sbc $3d,x			sbc 		NSMantissa0+1,x
.1c61	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1c63	b5 48		lda $48,x			lda		NSMantissa1,x
.1c65	f5 49		sbc $49,x			sbc 		NSMantissa1+1,x
.1c67	95 48		sta $48,x			sta 	NSMantissa1,x
.1c69	b5 54		lda $54,x			lda		NSMantissa2,x
.1c6b	f5 55		sbc $55,x			sbc 		NSMantissa2+1,x
.1c6d	95 54		sta $54,x			sta 	NSMantissa2,x
.1c6f	b5 60		lda $60,x			lda		NSMantissa3,x
.1c71	f5 61		sbc $61,x			sbc 		NSMantissa3+1,x
.1c73	95 60		sta $60,x			sta 	NSMantissa3,x
.1c75	60		rts				rts
.1c76					FloatInt32Add:
.1c76	b5 30		lda $30,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.1c78	55 31		eor $31,x			eor 	NSStatus+1,x
.1c7a	30 04		bmi $1c80			bmi 	_DiffSigns
.1c7c	20 42 1c	jsr $1c42			jsr		FloatAddTopTwoStack
.1c7f	60		rts				rts
.1c80					_DiffSigns:
.1c80	20 5c 1c	jsr $1c5c			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.1c83	34 60		bit $60,x			bit 	NSMantissa3,x 				; result is +ve, okay
.1c85	10 07		bpl $1c8e			bpl 	_AddExit
.1c87	b5 31		lda $31,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.1c89	95 30		sta $30,x			sta 	NSStatus,x
.1c8b	20 7f 1e	jsr $1e7f			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.1c8e					_AddExit:
.1c8e	20 d8 1e	jsr $1ed8			jsr 	FloatIsZero 				; check for -0
.1c91	d0 02		bne $1c95			bne 	_AddNonZero
.1c93	74 30		stz $30,x			stz 	NSStatus,x
.1c95					_AddNonZero:
.1c95	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.1c96					FloatEncodeStart:
.1c96	38		sec				sec
.1c97	80 01		bra $1c9a			bra 	FloatEncodeContinue+1
.1c99					FloatEncodeContinue:
.1c99	18		clc				clc
.1c9a					FloatEncode:
.1c9a	08		php				php 								; save reset flag.
.1c9b	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.1c9d	f0 15		beq $1cb4			beq 	_ENIsOkay
.1c9f	c9 30		cmp #$30			cmp 	#"0"
.1ca1	90 04		bcc $1ca7			bcc 	_ENBadNumber
.1ca3	c9 3a		cmp #$3a			cmp 	#"9"+1
.1ca5	90 0d		bcc $1cb4			bcc 	_ENIsOkay
.1ca7					_ENBadNumber:
.1ca7	28		plp				plp 								; throw saved reset
.1ca8	ad 39 05	lda $0539			lda 	encodeState 				; if in decimal mode, construct final number
.1cab	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.1cad	d0 03		bne $1cb2			bne 	_ENFail
.1caf	4c 2c 1d	jmp $1d2c			jmp 	_ENConstructFinal
.1cb2					_ENFail:
.1cb2	18		clc				clc 								; not allowed
.1cb3	60		rts				rts
.1cb4					_ENIsOkay:
.1cb4	28		plp				plp 								; are we restarting
.1cb5	90 15		bcc $1ccc			bcc 	_ENNoRestart
.1cb7					_ENStartEncode:
.1cb7	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.1cb9	f0 0c		beq $1cc7			beq 	_ENFirstDP
.1cbb	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.1cbd	20 b8 1e	jsr $1eb8			jsr 	FloatSetByte 				; in single byte mode.
.1cc0	a9 01		lda #$01			lda 	#ESTA_Low
.1cc2					_ENExitChange:
.1cc2	8d 39 05	sta $0539			sta 	encodeState 				; save new state
.1cc5	38		sec				sec
.1cc6	60		rts				rts
.1cc7					_ENFirstDP:
.1cc7	20 b6 1e	jsr $1eb6			jsr 	FloatSetZero 				; clear integer part
.1cca	80 3c		bra $1d08			bra 	_ESTASwitchFloat			; go straight to float and exi
.1ccc					_ENNoRestart:
.1ccc	48		pha				pha 								; save digit or DP on stack.
.1ccd	ad 39 05	lda $0539			lda 	encodeState 				; get current state
.1cd0	c9 01		cmp #$01			cmp 	#ESTA_Low
.1cd2	f0 09		beq $1cdd			beq  	_ESTALowState
.1cd4	c9 02		cmp #$02			cmp 	#ESTA_High
.1cd6	f0 26		beq $1cfe			beq 	_ESTAHighState
.1cd8	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.1cda	f0 38		beq $1d14			beq 	_ESTADecimalState
>1cdc	db						.byte 	$DB 						; causes a break in the emulator
.1cdd					_ESTALowState:
.1cdd	68		pla				pla 								; get value back
.1cde	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.1ce0	f0 26		beq $1d08			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.1ce2	29 0f		and #$0f			and 	#15 						; make digit
.1ce4	8d 3a 05	sta $053a			sta 	digitTemp 					; save it.
.1ce7	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.1ce9	0a		asl a				asl 	a
.1cea	0a		asl a				asl 	a
.1ceb	75 3c		adc $3c,x			adc 	NSMantissa0,x
.1ced	0a		asl a				asl 	a
.1cee	6d 3a 05	adc $053a			adc 	digitTemp
.1cf1	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1cf3	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.1cf5	90 05		bcc $1cfc			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.1cf7	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.1cf9	8d 39 05	sta $0539			sta 	encodeState
.1cfc					_ESTANoSwitch:
.1cfc	38		sec				sec
.1cfd	60		rts				rts
.1cfe					_ESTAHighState:
.1cfe	68		pla				pla 								; get value back
.1cff	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.1d01	f0 05		beq $1d08			beq 	_ESTASwitchFloat
.1d03	20 5e 1d	jsr $1d5e			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.1d06	38		sec				sec
.1d07	60		rts				rts
.1d08					_ESTASwitchFloat:
.1d08	9c 3b 05	stz $053b			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.1d0b	e8		inx				inx 								; zero the decimal additive.
.1d0c	20 b6 1e	jsr $1eb6			jsr 	FloatSetZero
.1d0f	ca		dex				dex
.1d10	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.1d12	80 ae		bra $1cc2			bra 	_ENExitChange
.1d14					_ESTADecimalState:
.1d14	68		pla				pla 								; digit.
.1d15	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.1d17	f0 99		beq $1cb2			beq 	_ENFail
.1d19	e8		inx				inx 								; put digit into fractional part of X+1
.1d1a	20 5e 1d	jsr $1d5e			jsr 	ESTAShiftDigitIntoMantissa
.1d1d	ca		dex				dex
.1d1e	ee 3b 05	inc $053b			inc 	decimalCount 				; bump the count of decimals
.1d21	ad 3b 05	lda $053b			lda 	decimalCount 				; too many decimal digits.
.1d24	c9 0b		cmp #$0b			cmp 	#11
.1d26	f0 02		beq $1d2a			beq 	_ESTADSFail
.1d28	38		sec				sec
.1d29	60		rts				rts
.1d2a					_ESTADSFail:
.1d2a	18		clc				clc
.1d2b	60		rts				rts
.1d2c					_ENConstructFinal:
.1d2c	ad 3b 05	lda $053b			lda 	decimalCount 				; get decimal count
.1d2f	f0 2b		beq $1d5c			beq 	_ENCFExit 					; no decimals
.1d31	5a		phy				phy
.1d32	0a		asl a				asl 	a 							; x 4 and CLC
.1d33	0a		asl a				asl 	a
.1d34	6d 3b 05	adc $053b			adc 	decimalCount
.1d37	a8		tay				tay
.1d38	b9 c3 19	lda $19c3,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.1d3b	95 3e		sta $3e,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.1d3d	b9 c4 19	lda $19c4,y			lda 	FloatScalarTable-5+1,y
.1d40	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.1d42	b9 c5 19	lda $19c5,y			lda 	FloatScalarTable-5+2,y
.1d45	95 56		sta $56,x			sta 	NSMantissa2+2,x
.1d47	b9 c6 19	lda $19c6,y			lda 	FloatScalarTable-5+3,y
.1d4a	95 62		sta $62,x			sta 	NSMantissa3+2,x
.1d4c	b9 c7 19	lda $19c7,y			lda 	FloatScalarTable-5+4,y
.1d4f	95 6e		sta $6e,x			sta 	NSExponent+2,x
.1d51	74 32		stz $32,x			stz 	NSStatus+2,x 				; make +ve
.1d53	e8		inx				inx 								; multiply decimal const by decimal scalar
.1d54	e8		inx				inx
.1d55	20 76 1b	jsr $1b76			jsr 	FloatMultiply
.1d58	20 da 18	jsr $18da			jsr 	FloatAdd 					; add to integer part.
.1d5b	7a		ply				ply
.1d5c					_ENCFExit:
.1d5c	18		clc				clc 								; reject the digit.
.1d5d	60		rts				rts
.1d5e					ESTAShiftDigitIntoMantissa:
.1d5e	29 0f		and #$0f			and 	#15 						; save digit
.1d60	48		pha				pha
.1d61	b5 60		lda $60,x			lda 	NSMantissa3,x 				; push mantissa on stack
.1d63	48		pha				pha
.1d64	b5 54		lda $54,x			lda 	NSMantissa2,x
.1d66	48		pha				pha
.1d67	b5 48		lda $48,x			lda 	NSMantissa1,x
.1d69	48		pha				pha
.1d6a	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1d6c	48		pha				pha
.1d6d	20 c5 1e	jsr $1ec5			jsr 	FloatShiftLeft 				; x 2
.1d70	20 c5 1e	jsr $1ec5			jsr 	FloatShiftLeft 				; x 4
.1d73	18		clc				clc 								; pop mantissa and add
.1d74	68		pla				pla
.1d75	75 3c		adc $3c,x			adc 	NSMantissa0,x
.1d77	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1d79	68		pla				pla
.1d7a	75 48		adc $48,x			adc 	NSMantissa1,x
.1d7c	95 48		sta $48,x			sta 	NSMantissa1,x
.1d7e	68		pla				pla
.1d7f	75 54		adc $54,x			adc 	NSMantissa2,x
.1d81	95 54		sta $54,x			sta 	NSMantissa2,x
.1d83	68		pla				pla
.1d84	75 60		adc $60,x			adc 	NSMantissa3,x
.1d86	95 60		sta $60,x			sta 	NSMantissa3,x 				; x 5
.1d88	20 c5 1e	jsr $1ec5			jsr 	FloatShiftLeft 				; x 10
.1d8b	68		pla				pla 								; add digit
.1d8c	18		clc				clc
.1d8d	75 3c		adc $3c,x			adc 	NSMantissa0,x
.1d8f	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1d91	90 0a		bcc $1d9d			bcc 	_ESTASDExit
.1d93	f6 48		inc $48,x			inc 	NSMantissa1,x
.1d95	d0 06		bne $1d9d			bne 	_ESTASDExit
.1d97	f6 54		inc $54,x			inc 	NSMantissa2,x
.1d99	d0 02		bne $1d9d			bne 	_ESTASDExit
.1d9b	f6 60		inc $60,x			inc 	NSMantissa3,x
.1d9d					_ESTASDExit:
.1d9d	60		rts				rts
.0539					encodeState:
>0539							.fill 	1
.053a					digitTemp:
>053a							.fill 	1
.053b					decimalCount:
>053b							.fill 	1
.1d9e					FloatToString:
.1d9e	da		phx				phx
.1d9f	5a		phy				phy 								; save code position
.1da0	8d 3c 05	sta $053c			sta 	decimalPlaces	 			; save number of DPs.
.1da3	9c 3d 05	stz $053d			stz 	dbOffset 					; offset into decimal buffer = start.
.1da6	b5 30		lda $30,x			lda 	NSStatus,x  				; is it -ve.
.1da8	10 08		bpl $1db2			bpl 	_CNTSNotNegative
.1daa	29 7f		and #$7f			and 	#$7F 						; make +ve
.1dac	95 30		sta $30,x			sta 	NSStatus,x
.1dae	a9 2d		lda #$2d			lda 	#"-"
.1db0	80 02		bra $1db4			bra 	_CNTMain
.1db2					_CNTSNotNegative:
.1db2	a9 20		lda #$20			lda 	#" "
.1db4					_CNTMain:
.1db4	20 16 1e	jsr $1e16			jsr 	WriteDecimalBuffer
.1db7	b5 6c		lda $6c,x			lda 	NSExponent,x 				; check if decimal
.1db9	f0 0d		beq $1dc8			beq 	_CNTSNotFloat
.1dbb	e8		inx				inx 								; round up so we don't get too many 6.999999
.1dbc	a9 01		lda #$01			lda 	#1
.1dbe	20 b8 1e	jsr $1eb8			jsr 	FloatSetByte
.1dc1	b5 6b		lda $6b,x			lda		NSExponent-1,x
.1dc3	95 6c		sta $6c,x			sta 	NSExponent,x
.1dc5	20 da 18	jsr $18da			jsr 	FloatAdd
.1dc8					_CNTSNotFloat:
.1dc8	20 f8 1d	jsr $1df8			jsr 	MakePlusTwoString 			; do the integer part.
.1dcb	20 96 1a	jsr $1a96			jsr 	FloatFractionalPart 		; get the fractional part
.1dce	20 0b 1c	jsr $1c0b			jsr 	FloatNormalise					; normalise , exit if zero
.1dd1	f0 22		beq $1df5			beq 	_CNTSExit
.1dd3	a9 2e		lda #$2e			lda 	#"."
.1dd5	20 16 1e	jsr $1e16			jsr 	WriteDecimalBuffer 			; write decimal place
.1dd8					_CNTSDecimal:
.1dd8	ce 3c 05	dec $053c			dec 	decimalPlaces 				; done all the decimals
.1ddb	30 18		bmi $1df5			bmi 	_CNTSExit
.1ddd	e8		inx				inx 								; x 10.0
.1dde	a9 0a		lda #$0a			lda 	#10
.1de0	20 b8 1e	jsr $1eb8			jsr 	FloatSetByte
.1de3	20 76 1b	jsr $1b76			jsr 	FloatMultiply
.1de6	20 f8 1d	jsr $1df8			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.1de9	20 96 1a	jsr $1a96			jsr 	FloatFractionalPart 		; get the fractional part
.1dec	20 0b 1c	jsr $1c0b			jsr 	FloatNormalise 				; normalise it.
.1def	b5 6c		lda $6c,x			lda 	NSExponent,x 				; gone to zero, exit.
.1df1	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.1df3	b0 e3		bcs $1dd8			bcs 	_CNTSDecimal 				; keep going.
.1df5					_CNTSExit:
.1df5	7a		ply				ply
.1df6	fa		plx				plx
.1df7	60		rts				rts
.1df8					MakePlusTwoString:
.1df8	da		phx				phx
.1df9	20 99 1e	jsr $1e99			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.1dfc	e8		inx				inx 								; access it
.1dfd	e8		inx				inx
.1dfe	20 f1 1a	jsr $1af1			jsr 	FloatIntegerPart 			; make it an integer
.1e01	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.1e03	20 35 1e	jsr $1e35			jsr 	ConvertInt32
.1e06	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.1e08					_MPTSCopy:
.1e08	bd 17 05	lda $0517,x			lda 	numberBuffer,x
.1e0b	20 16 1e	jsr $1e16			jsr 	WriteDecimalBuffer
.1e0e	e8		inx				inx
.1e0f	bd 17 05	lda $0517,x			lda 	numberBuffer,x
.1e12	d0 f4		bne $1e08			bne 	_MPTSCopy
.1e14	fa		plx				plx
.1e15	60		rts				rts
.1e16					WriteDecimalBuffer:
.1e16	da		phx				phx
.1e17	ae 3d 05	ldx $053d			ldx 	dbOffset
.1e1a	9d 3e 05	sta $053e,x			sta 	decimalBuffer,x
.1e1d	9e 3f 05	stz $053f,x			stz 	decimalBuffer+1,x
.1e20	ee 3d 05	inc $053d			inc 	dbOffset
.1e23	fa		plx				plx
.1e24	60		rts				rts
.053c					decimalPlaces:
>053c							.fill 	1
.053d					dbOffset:
>053d							.fill 	1
.053e					decimalBuffer:
>053e							.fill 	32
.1e25					ConvertInt16:
.1e25	85 3c		sta $3c				sta 	NSMantissa0 				; set up as 32 bit conversion
.1e27	86 48		stx $48				stx 	NSMantissa1
.1e29	64 54		stz $54				stz 	NSMantissa2
.1e2b	64 60		stz $60				stz 	NSMantissa3
.1e2d	64 30		stz $30				stz 	NSStatus 					; positive integer
.1e2f	a2 00		ldx #$00			ldx 	#0 							; stack level
.1e31	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.1e33	80 00		bra $1e35			bra 	ConvertInt32
.1e35					ConvertInt32:
.1e35	5a		phy				phy
.1e36	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.1e38	24 30		bit $30				bit 	NSStatus 					; output a - if not negative.
.1e3a	10 08		bpl $1e44			bpl 	_CI32NotNeg
.1e3c	48		pha				pha
.1e3d	a9 2d		lda #$2d			lda 	#'-'
.1e3f	99 17 05	sta $0517,y			sta 	numberBuffer,y
.1e42	c8		iny				iny
.1e43	68		pla				pla
.1e44					_CI32NotNeg:
.1e44	20 52 1e	jsr $1e52			jsr 	_CI32DivideConvert 			; recursive conversion
.1e47	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.1e49	99 17 05	sta $0517,y			sta 	numberBuffer,y
.1e4c	7a		ply				ply
.1e4d	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.1e4f	a9 17		lda #$17			lda 	#numberBuffer & $FF
.1e51	60		rts				rts
.1e52					_CI32DivideConvert:
.1e52	e8		inx				inx 								; write to next slot up
.1e53	20 b8 1e	jsr $1eb8			jsr 	FloatSetByte 		 		; write the base out.
.1e56	ca		dex				dex
.1e57	20 4c 1a	jsr $1a4c			jsr 	Int32Divide 				; divide
.1e5a	b5 3c		lda $3c,x			lda 	NSMantissa0,x 				; save remainder
.1e5c	48		pha				pha
.1e5d	20 3b 1a	jsr $1a3b			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.1e60	20 d8 1e	jsr $1ed8			jsr 	FloatIsZero 				; is it zero ?
.1e63	f0 05		beq $1e6a			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.1e65	b5 3d		lda $3d,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.1e67	20 52 1e	jsr $1e52			jsr 	_CI32DivideConvert 			; and recusrively call.
.1e6a					_CI32NoRecurse:
.1e6a	68		pla				pla 								; remainder
.1e6b	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.1e6d	90 02		bcc $1e71			bcc 	_CI32NotHex
.1e6f	69 26		adc #$26			adc 	#6+32
.1e71					_CI32NotHex:
.1e71	69 30		adc #$30			adc 	#48
.1e73	99 17 05	sta $0517,y			sta 	numberBuffer,y 				; write out and exit
.1e76	c8		iny				iny
.1e77	60		rts				rts
.1e78					FloatNegate:
.1e78	b5 30		lda $30,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.1e7a	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.1e7c	95 30		sta $30,x			sta 	NSStatus,x
.1e7e	60		rts				rts
.1e7f					FloatNegateMantissa:
.1e7f	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.1e80	a9 00		lda #$00			lda 	#0
.1e82	f5 3c		sbc $3c,x			sbc 	NSMantissa0,x
.1e84	95 3c		sta $3c,x			sta 	NSMantissa0,x
.1e86	a9 00		lda #$00			lda 	#0
.1e88	f5 48		sbc $48,x			sbc 	NSMantissa1,x
.1e8a	95 48		sta $48,x			sta 	NSMantissa1,x
.1e8c	a9 00		lda #$00			lda 	#0
.1e8e	f5 54		sbc $54,x			sbc 	NSMantissa2,x
.1e90	95 54		sta $54,x			sta 	NSMantissa2,x
.1e92	a9 00		lda #$00			lda 	#0
.1e94	f5 60		sbc $60,x			sbc 	NSMantissa3,x
.1e96	95 60		sta $60,x			sta 	NSMantissa3,x
.1e98	60		rts				rts
.1e99					FloatShiftUpTwo:
.1e99	b5 3c		lda $3c,x			lda 	NSMantissa0,x
.1e9b	95 3e		sta $3e,x			sta 	NSMantissa0+2,x
.1e9d	b5 48		lda $48,x			lda 	NSMantissa1,x
.1e9f	95 4a		sta $4a,x			sta 	NSMantissa1+2,x
.1ea1	b5 54		lda $54,x			lda 	NSMantissa2,x
.1ea3	95 56		sta $56,x			sta 	NSMantissa2+2,x
.1ea5	b5 60		lda $60,x			lda 	NSMantissa3,x
.1ea7	95 62		sta $62,x			sta 	NSMantissa3+2,x
.1ea9	b5 6c		lda $6c,x			lda 	NSExponent,x
.1eab	95 6e		sta $6e,x			sta 	NSExponent+2,x
.1ead	b5 30		lda $30,x			lda 	NSStatus,x
.1eaf	95 32		sta $32,x			sta 	NSStatus+2,x
.1eb1	60		rts				rts
.1eb2					FloatSetZeroMantissaOnly:
.1eb2	74 3c		stz $3c,x			stz 	NSMantissa0,x
.1eb4	80 08		bra $1ebe			bra 	FloatZero13
.1eb6					FloatSetZero:
.1eb6	a9 00		lda #$00			lda 	#0
.1eb8					FloatSetByte:
.1eb8	74 6c		stz $6c,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.1eba					FloatSetMantissa:
.1eba	95 3c		sta $3c,x			sta 	NSMantissa0,x 				; zero mantissa
.1ebc	74 30		stz $30,x			stz 	NSStatus,x
.1ebe					FloatZero13:
.1ebe	74 48		stz $48,x			stz 	NSMantissa1,x
.1ec0	74 54		stz $54,x			stz 	NSMantissa2,x
.1ec2	74 60		stz $60,x			stz 	NSMantissa3,x
.1ec4	60		rts				rts
.1ec5					FloatShiftLeft:
.1ec5	18		clc				clc
.1ec6					FloatRotateLeft:
.1ec6	36 3c		rol $3c,x			rol 	NSMantissa0,x
.1ec8	36 48		rol $48,x			rol		NSMantissa1,x
.1eca	36 54		rol $54,x			rol		NSMantissa2,x
.1ecc	36 60		rol $60,x			rol		NSMantissa3,x
.1ece	60		rts				rts
.1ecf					FloatShiftRight:
.1ecf	56 60		lsr $60,x			lsr 	NSMantissa3,x
.1ed1	76 54		ror $54,x			ror		NSMantissa2,x
.1ed3	76 48		ror $48,x			ror		NSMantissa1,x
.1ed5	76 3c		ror $3c,x			ror		NSMantissa0,x
.1ed7	60		rts				rts
.1ed8					FloatIsZero:
.1ed8	b5 60		lda $60,x			lda 	NSMantissa3,x
.1eda	15 54		ora $54,x			ora		NSMantissa2,x
.1edc	15 48		ora $48,x			ora		NSMantissa1,x
.1ede	15 3c		ora $3c,x			ora		NSMantissa0,x
.1ee0	60		rts				rts

;******  Processing input file: testing/testend.asm

.1ee1					EndProgram:
>1ee1	01 08 18 08 64 00 99 20				.binary "code/tokenised.dat"
>1ee9	22 48 45 4c 4c 4f 2c 20 57 4f 52 4c 44 20 21 22
>1ef9	00 1e 08 6e 00 90 00 00 00

;******  End of listing
