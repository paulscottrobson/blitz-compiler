
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library testing/testend.asm
; Sat Oct  7 09:25:59 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

=$8000					StartWorkSpace = $8000
=$9f00					EndWorkspace = $9F00
.1000					WrapperBoot:
.1000	a2 0a		ldx #$0a			ldx 	#APIDesc & $FF
.1002	a0 10		ldy #$10			ldy 	#APIDesc >> 8
.1004	20 40 11	jsr $1140			jsr 	StartCompiler
.1007	4c ff ff	jmp $ffff			jmp 	$FFFF
.100a					APIDesc:
>100a							.fill 	2
>100c	80						.byte 	StartWorkSpace >> 8 		; start of workspace for compiler
>100d	9f						.byte 	EndWorkspace >> 8 			; end of workspace for compiler

;******  Processing file: testing/api/close.asm

.100e					APIOClose:
.100e	a9 40		lda #$40			lda 	#(PCodeStart >> 8)
.1010	a6 29		ldx $29				ldx 	objPtr
.1012	a4 2a		ldy $2a				ldy 	objPtr+1
.1014	20 70 10	jsr $1070			jsr 	APISaveMemory
.1017	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/fromram.asm

.1018					APIIOpen:
.1018	a9 a0		lda #$a0			lda 	#((EndProgram+2) & $FF)
.101a	85 22		sta $22				sta 	0+srcInputPtr
.101c	a9 26		lda #$26			lda 	#((EndProgram+2) >> 8) & $FF
.101e	85 23		sta $23				sta 	1+srcInputPtr
.1020					APIIClose:
.1020	60		rts				rts
.0022					srcInputPtr:
>0022							.fill 	2

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/line.asm

.1021					ReadNextLine:
.1021	b2 22		lda ($22)			lda 	(srcInputPtr) 				; reached the end of the program (address link = $0000)
.1023	a0 01		ldy #$01			ldy 	#1
.1025	11 22		ora ($22),y			ora 	(srcInputPtr),y
.1027	d0 02		bne $102b			bne 	_RNLBody
.1029	18		clc				clc
.102a	60		rts				rts									; end of file.
.102b					_RNLBody:
.102b	c8		iny				iny 								; read and save line number
.102c	b1 22		lda ($22),y			lda 	(srcInputPtr),y
.102e	8d 00 05	sta $0500			sta 	currentLineNumber
.1031	c8		iny				iny
.1032	b1 22		lda ($22),y			lda 	(srcInputPtr),y
.1034	8d 01 05	sta $0501			sta 	currentLineNumber+1
.1037	c8		iny				iny 								; first character of line.
.1038	18		clc				clc 								; point srcPtr to the start of the line.
.1039	a5 22		lda $22				lda 	srcInputPtr
.103b	69 04		adc #$04			adc 	#4
.103d	85 24		sta $24				sta 	srcPtr
.103f	a5 23		lda $23				lda 	srcInputPtr+1
.1041	69 00		adc #$00			adc 	#0
.1043	85 25		sta $25				sta 	srcPtr+1
.1045					_RNLRead:
.1045	b1 22		lda ($22),y			lda 	(srcInputPtr),y 			; copy into buffer.
.1047	c8		iny				iny
.1048	c9 00		cmp #$00			cmp 	#0
.104a	d0 f9		bne $1045			bne 	_RNLRead
.104c	98		tya				tya 								; advance src input pointer to next.
.104d	18		clc				clc
.104e	65 22		adc $22				adc 	srcInputPtr
.1050	85 22		sta $22				sta 	srcInputPtr
.1052	90 02		bcc $1056			bcc 	_RNLNoCarry
.1054	e6 23		inc $23				inc 	srcInputPtr+1
.1056					_RNLNoCarry:
.1056	38		sec				sec
.1057	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/open.asm

.1058					APIOOpen:
.1058					APIORewind:
.1058	64 2b		stz $2b				stz 	objPage
.105a	a9 00		lda #$00			lda 	#((PCodeStart) & $FF)
.105c	85 29		sta $29				sta 	0+objPtr
.105e	a9 40		lda #$40			lda 	#((PCodeStart) >> 8) & $FF
.1060	85 2a		sta $2a				sta 	1+objPtr
.1062	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/writebyte.asm

.1063					APIOWriteByte:
.1063	92 29		sta ($29)			sta 	(objPtr)
.1065	e6 29		inc $29				inc 	objPtr
.1067	d0 02		bne $106b			bne 	_HWOWBNoCarry
.1069	e6 2a		inc $2a				inc 	objPtr+1
.106b					_HWOWBNoCarry:
.106b	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_config.inc

=$4000					PCodeStart = $4000

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_printchar.asm

.106c					APIOPrintCharacter
.106c	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.106f	60		rts				rts

;******  Return to file: testing/testing.asm


;******  Processing file: testing/api/x16_save.asm

.1070					APISaveMemory:
.1070	da		phx				phx
.1071	5a		phy				phy
.1072	48		pha				pha
.1073	a9 00		lda #$00			lda 	#0 							; set LFS
.1075	a2 08		ldx #$08			ldx 	#8
.1077	a0 00		ldy #$00			ldy 	#0
.1079	20 ba ff	jsr $ffba			jsr 	$FFBA
.107c	a9 08		lda #$08			lda 	#8 							; set file name
.107e	a2 92		ldx #$92			ldx 	#SaveName & $FF
.1080	a0 10		ldy #$10			ldy 	#SaveName >> 8
.1082	20 bd ff	jsr $ffbd			jsr 	$FFBD
.1085	68		pla				pla 								; set up the start address.
.1086	85 2d		sta $2d				sta 	zTemp0+1
.1088	64 2c		stz $2c				stz 	zTemp0
.108a	a9 2c		lda #$2c			lda 	#zTemp0 					; from index.
.108c	7a		ply				ply 								; end in YX
.108d	fa		plx				plx
.108e	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; write out.
.1091	60		rts				rts
.1092					SaveName:
>1092	43 4f 44 45 2e 42 49 4e				.text 	"CODE.BIN"

;******  Return to file: testing/testing.asm


;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
.0024					srcPtr:
>0024							.fill 	2
.0400					sourceBuffer:
>0400							.fill 	256
.0500					currentLineNumber:
>0500							.fill 	2
.109a					InlineNonDecimal:
.109a	a2 02		ldx #$02			ldx 	#2 							; get size in X
.109c	c9 25		cmp #$25			cmp 	#"%"
.109e	f0 02		beq $10a2			beq 	_INDBinary
.10a0	a2 10		ldx #$10			ldx 	#16
.10a2					_INDBinary:
.10a2	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.10a4	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.10a6	64 2c		stz $2c				stz 	zTemp0 						; zero result
.10a8	64 2d		stz $2d				stz 	zTemp0+1
.10aa					_INDLoop:
.10aa	20 1d 1a	jsr $1a1d			jsr 	LookNext 					; check next character
.10ad	20 59 1a	jsr $1a59			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.10b0	90 1f		bcc $10d1			bcc		_INDDone 					; didn't convert
.10b2	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.10b4	b0 1b		bcs $10d1			bcs 	_INDDone
.10b6	20 e0 10	jsr $10e0			jsr 	_INDShift 					; x 2 or x 16
.10b9	e0 02		cpx #$02			cpx 	#2
.10bb	f0 09		beq $10c6			beq 	_INDNotHex
.10bd	20 e0 10	jsr $10e0			jsr 	_INDShift
.10c0	20 e0 10	jsr $10e0			jsr 	_INDShift
.10c3	20 e0 10	jsr $10e0			jsr 	_INDShift
.10c6					_INDNotHex:
.10c6	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.10c8	85 2c		sta $2c				sta 	zTemp0
.10ca	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume
.10cd	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.10cf	80 d9		bra $10aa			bra 	_INDLoop
.10d1					_INDDone:
.10d1	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.10d3	f0 08		beq $10dd			beq 	_INDError
.10d5	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.10d7	a5 2c		lda $2c				lda 	zTemp0
.10d9	20 ca 11	jsr $11ca			jsr 	PushIntegerYA
.10dc	60		rts				rts
.10dd					_INDError:
.10dd	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.10e0					_INDShift:
.10e0	06 2c		asl $2c				asl 	zTemp0
.10e2	26 2d		rol $2d				rol 	zTemp0+1
.10e4	60		rts				rts
.10e5					GetLineNumber:
.10e5	ac 01 05	ldy $0501			ldy 	currentLineNumber+1
.10e8	ad 00 05	lda $0500			lda 	currentLineNumber
.10eb	60		rts				rts
.10ec					WriteCodeByte:
.10ec	48		pha				pha 								; save on stack
.10ed	da		phx				phx
.10ee	5a		phy				phy
.10ef	20 63 10	jsr $1063			jsr 	APIOWriteByte
.10f2	7a		ply				ply 								; restore from stack
.10f3	fa		plx				plx
.10f4	68		pla				pla
.10f5	60		rts				rts
.10f6					PrintCharacter
.10f6	48		pha				pha
.10f7	da		phx				phx
.10f8	5a		phy				phy
.10f9	20 6c 10	jsr $106c			jsr 	APIOPrintCharacter
.10fc	7a		ply				ply
.10fd	fa		plx				plx
.10fe	68		pla				pla
.10ff	60		rts				rts
.1100					BufferClear:
.1100	9c 02 05	stz $0502			stz 	bufferSize
.1103	60		rts				rts
.1104					BufferWrite:
.1104	da		phx				phx
.1105	ae 02 05	ldx $0502			ldx 	bufferSize
.1108	9d 03 05	sta $0503,x			sta 	dataBuffer,x
.110b	ee 02 05	inc $0502			inc 	bufferSize
.110e	fa		plx				plx
.110f	60		rts				rts
.1110					BufferOutput:
.1110	ad 02 05	lda $0502			lda 	bufferSize
.1113	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1116	a2 00		ldx #$00			ldx 	#0
.1118					_BOLoop:
.1118	ec 02 05	cpx $0502			cpx 	bufferSize
.111b	f0 09		beq $1126			beq 	_BOExit
.111d	bd 03 05	lda $0503,x			lda 	dataBuffer,x
.1120	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1123	e8		inx				inx
.1124	80 f2		bra $1118			bra 	_BOLoop
.1126					_BOExit:
.1126	60		rts				rts
.0502					bufferSize:
>0502							.fill 	1
.0503					dataBuffer:
>0503							.fill 	256
.1127					CheckNextComma:
.1127	a9 2c		lda #$2c			lda	 	#","
.1129	80 06		bra $1131			bra 	CheckNextA
.112b					CheckNextRParen:
.112b	a9 29		lda #$29			lda	 	#")"
.112d	80 02		bra $1131			bra 	CheckNextA
.112f					CheckNextLParen:
.112f	a9 28		lda #$28			lda 	#"("
.1131					CheckNextA:
.1131	8d 03 06	sta $0603			sta 	checkCharacter 				; save test character
.1134					_CNALoop:
.1134	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; get next skipping spaces.
.1137	cd 03 06	cmp $0603			cmp 	checkCharacter 				; matches ?
.113a	f0 03		beq $113f			beq 	_CNAExit
.113c	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.113f					_CNAExit:
.113f	60		rts				rts
.0603					checkCharacter:
>0603							.fill 	1
.1140					StartCompiler:
.1140	86 2c		stx $2c				stx 	zTemp0 						; access API
.1142	84 2d		sty $2d				sty 	zTemp0+1
.1144	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.1146	b2 2c		lda ($2c)			lda 	(zTemp0)
.1148	8d 05 06	sta $0605			sta 	APIVector
.114b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.114d	8d 06 06	sta $0606			sta 	APIVector+1
.1150	c8		iny				iny 								; copy data area range.
.1151	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1153	8d 07 06	sta $0607			sta 	compilerStartHigh
.1156	c8		iny				iny
.1157	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1159	8d 08 06	sta $0608			sta 	compilerEndHigh
.115c	ba		tsx				tsx 								; save stack pointer
.115d	8e 04 06	stx $0604			stx 	compilerSP
.1160	20 d2 1d	jsr $1dd2			jsr 	STRReset 					; reset storage (line#, variable)
.1163	20 18 10	jsr $1018			jsr 	APIIOpen 					; reset data input
.1166	20 58 10	jsr $1058			jsr 	APIOOpen 					; reset data output.
.1169	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.116b	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.116e	a9 00		lda #$00			lda 	#0
.1170	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1173	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1176					MainCompileLoop:
.1176	20 21 10	jsr $1021			jsr 	ReadNextLine 				; read next line into the buffer.
.1179	90 2e		bcc $11a9			bcc 	SaveCodeAndExit 			; end of source.
.117b	20 e5 10	jsr $10e5			jsr 	GetLineNumber 				; get line #
.117e	20 b3 1b	jsr $1bb3			jsr 	STRMarkLine 				; remember the position and number of this line.
.1181	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.1183	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1186					_MCLSameLine:
.1186	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; get the first character.
.1189	f0 eb		beq $1176			beq 	MainCompileLoop 			; end of line, get next line.
.118b	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.118d	f0 f7		beq $1186			beq 	_MCLSameLine
.118f	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.1191	10 0c		bpl $119f			bpl 	_MCLCheckAssignment
.1193	a2 fa		ldx #$fa			ldx 	#CommandTables & $FF 		; do command tables.
.1195	a0 15		ldy #$15			ldy 	#CommandTables >> 8
.1197	20 c2 18	jsr $18c2			jsr 	GeneratorProcess
.119a	b0 ea		bcs $1186			bcs 	_MCLSameLine 				; keep trying to compile the line.
.119c					_MCLSyntax:
.119c	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.119f					_MCLCheckAssignment:
.119f	20 4f 1a	jsr $1a4f			jsr 	CharIsAlpha 				; if not alpha then syntax error
.11a2	90 f8		bcc $119c			bcc 	_MCLSyntax
.11a4	20 81 1b	jsr $1b81			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.11a7	80 dd		bra $1186			bra		_MCLSameLine 				; loop back.
.11a9					SaveCodeAndExit:
.11a9	20 20 10	jsr $1020			jsr 	APIIClose 					; finish input.
.11ac	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.11ae	a8		tay				tay
.11af	20 b3 1b	jsr $1bb3			jsr 	STRMarkLine
.11b2	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.11b4	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.11b7	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.11b9	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.11bc	20 e6 14	jsr $14e6			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.11bf	20 0e 10	jsr $100e			jsr 	APIOClose
.11c2					ExitCompiler:
.11c2	ae 04 06	ldx $0604			ldx 	compilerSP 					; reload SP and exit.
.11c5	9a		txs				txs
.11c6	60		rts				rts
.11c7					CallAPIHandler:
.11c7	6c 05 06	jmp ($0605)			jmp 	(APIVector)
.0604					compilerSP:
>0604							.fill 	1
.0605					APIVector:
>0605							.fill 	2
.0607					compilerStartHigh:
>0607							.fill 	1
.0608					compilerEndHigh:
>0608							.fill 	1
.11ca					PushIntegerYA:
.11ca	c0 00		cpy #$00			cpy 	#0 							; 0-255
.11cc	f0 0f		beq $11dd			beq 	PushIntegerA
.11ce	48		pha				pha
.11cf	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.11d1	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.11d4	68		pla				pla 								; then LSB
.11d5	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.11d8	98		tya				tya 								; then MSB
.11d9	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.11dc	60		rts				rts
.11dd					PushIntegerA:
.11dd	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.11df	90 07		bcc $11e8			bcc 	_PIWriteA
.11e1	48		pha				pha
.11e2	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.11e4	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.11e7	68		pla				pla
.11e8					_PIWriteA:
.11e8	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.11eb	60		rts				rts
.11ec					PushFloat:
.11ec	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.11ee	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.11f1	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.11f3	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.11f6	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.11f8	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.11fb	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.11fd	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1200	b5 56		lda $56,x			lda 	NSMantissa2,x
.1202	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1205	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.1207	29 80		and #$80			and 	#$80
.1209	15 62		ora $62,x			ora 	NSMantissa3,x
.120b	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.120e	60		rts				rts
.120f					CreateVariableRecord:
.120f	48		pha				pha
.1210	ad 13 06	lda $0613			lda 	freeVariableMemory 		; push current free address on stack.
.1213	48		pha				pha
.1214	ad 14 06	lda $0614			lda 	freeVariableMemory+1
.1217	48		pha				pha
.1218	ad 11 06	lda $0611			lda 	variableListEnd  		; copy end of list to zTemp0
.121b	85 2c		sta $2c				sta 	zTemp0
.121d	ad 12 06	lda $0612			lda 	variableListEnd+1
.1220	85 2d		sta $2d				sta 	zTemp0+1
.1222	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.1224	92 2c		sta ($2c)			sta 	(zTemp0)
.1226	98		tya				tya
.1227	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.1229	91 2c		sta ($2c),y			sta 	(zTemp0),y
.122b	88		dey				dey
.122c	8a		txa				txa
.122d	91 2c		sta ($2c),y			sta 	(zTemp0),y
.122f	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.1231	ad 13 06	lda $0613			lda 	freeVariableMemory
.1234	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1236	c8		iny				iny
.1237	ad 14 06	lda $0614			lda 	freeVariableMemory+1
.123a	91 2c		sta ($2c),y			sta 	(zTemp0),y
.123c	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.123e	a9 00		lda #$00			lda 	#0
.1240	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1242	18		clc				clc
.1243	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.1245	6d 11 06	adc $0611			adc  	variableListEnd
.1248	8d 11 06	sta $0611			sta 	variableListEnd
.124b	90 03		bcc $1250			bcc 	_CVNoCarry2
.124d	ee 12 06	inc $0612			inc 	variableListEnd+1
.1250					_CVNoCarry2:
.1250	7a		ply				ply
.1251	fa		plx				plx
.1252	68		pla				pla
.1253	60		rts				rts
.1254					SetVariableRecordToCodePosition:
.1254	48		pha				pha
.1255	5a		phy				phy
.1256	a5 2b		lda $2b				lda 	objPage
.1258	a0 03		ldy #$03			ldy 	#3
.125a	91 2c		sta ($2c),y			sta 	(zTemp0),y
.125c	c8		iny				iny
.125d	a5 2a		lda $2a				lda 	objPtr+1
.125f	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1261	c8		iny				iny
.1262	a5 29		lda $29				lda 	objPtr
.1264	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1266	7a		ply				ply
.1267	68		pla				pla
.1268	60		rts				rts
.1269					AllocateBytesForType:
.1269	48		pha				pha
.126a	da		phx				phx
.126b	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.126d	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.126f	c9 00		cmp #$00			cmp 	#NSSIFloat
.1271	d0 02		bne $1275			bne 	_CVNotFloat
.1273	a2 06		ldx #$06			ldx 	#6
.1275					_CVNotFloat:
.1275	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.1276	18		clc				clc
.1277	6d 13 06	adc $0613			adc 	freeVariableMemory
.127a	8d 13 06	sta $0613			sta 	freeVariableMemory
.127d	90 03		bcc $1282			bcc 	_CVNoCarry1
.127f	ee 14 06	inc $0614			inc 	freeVariableMemory+1
.1282					_CVNoCarry1:
.1282	fa		plx				plx
.1283	68		pla				pla
.1284	60		rts				rts
.1285					CommandDATA:
.1285	20 00 11	jsr $1100			jsr 	BufferClear 				; copy it to the buffer
.1288	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace
.128b					_CTDataLoop:
.128b	20 1d 1a	jsr $1a1d			jsr 	LookNext 					; reached EOL
.128e	f0 08		beq $1298			beq 	_CTDataDone
.1290	20 04 11	jsr $1104			jsr 	BufferWrite 				; write and consume
.1293	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1296	80 f3		bra $128b			bra 	_CTDataLoop
.1298					_CTDataDone:
.1298	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.129a	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.129d	20 10 11	jsr $1110			jsr 	BufferOutput
.12a0	60		rts				rts
.12a1					CommandDEF:
.12a1	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.12a3	20 dd 11	jsr $11dd			jsr 	PushIntegerA
.12a6	20 45 1b	jsr $1b45			jsr 	CompileGotoEOL 				; compile skip over DEF
.12a9	a9 a5		lda #$a5			lda 	#C64_FN
.12ab	20 31 11	jsr $1131			jsr 	CheckNextA
.12ae	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.12b1	20 9e 1a	jsr $1a9e			jsr 	ExtractVariableName
.12b4	8a		txa				txa
.12b5	10 51		bpl $1308			bpl 	_CDError
.12b7	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.12b8	29 7f		and #$7f			and 	#$7F
.12ba	aa		tax				tax
.12bb	98		tya				tya
.12bc	09 80		ora #$80			ora 	#$80
.12be	a8		tay				tay
.12bf	20 8a 14	jsr $148a			jsr 	FindVariable				; does it already exist ?
.12c2	b0 44		bcs $1308			bcs 	_CDError 					; if so, that's an error.
.12c4	20 0f 12	jsr $120f			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.12c7	20 54 12	jsr $1254			jsr 	SetVariableRecordToCodePosition
.12ca	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace
.12cd	20 8f 1d	jsr $1d8f			jsr 	GetReferenceTerm 			; get var ref, not array
.12d0	c9 00		cmp #$00			cmp 	#0
.12d2	30 34		bmi $1308			bmi 	_CDError
.12d4	8d 09 06	sta $0609			sta 	defType 					; save type
.12d7	8e 0a 06	stx $060a			stx 	defVariable 				; save var ref
.12da	8c 0b 06	sty $060b			sty 	defVariable+1
.12dd	29 40		and #$40			and 	#NSSString 					; only numbers.
.12df	d0 27		bne $1308			bne 	_CDError
.12e1	20 2b 11	jsr $112b			jsr 	CheckNextRParen 			; check )
.12e4	a9 b2		lda #$b2			lda 	#C64_EQUAL
.12e6	20 31 11	jsr $1131			jsr 	CheckNextA 					; check =
.12e9	18		clc				clc 								; if this is DEF FNxx(A), read A
.12ea	20 0b 13	jsr $130b			jsr 	CDReadWriteVariable
.12ed	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.12ef	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.12f2	38		sec				sec
.12f3	20 0b 13	jsr $130b			jsr 	CDReadWriteVariable 		; A is now updated
.12f6	20 d0 13	jsr $13d0			jsr 	CompileExpressionAt0 		; the actual body of the function.
.12f9	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.12fb	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.12fe	38		sec				sec
.12ff	20 0b 13	jsr $130b			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.1302	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.1304	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1307	60		rts				rts
.1308					_CDError:
.1308	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.130b					CDReadWriteVariable:
.130b	ac 0b 06	ldy $060b			ldy 	defVariable+1 				; set up YX
.130e	ae 0a 06	ldx $060a			ldx 	defVariable
.1311	ad 09 06	lda $0609			lda 	defType
.1314	20 41 1d	jsr $1d41			jsr 	GetSetVariable
.1317	60		rts				rts
.0609					defType:
>0609							.fill 	1
.060a					defVariable:
>060a							.fill 	2
.1318					CommandDIM:
.1318	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; get the first non space character
.131b	20 9e 1a	jsr $1a9e			jsr 	ExtractVariableName 		; variable name to XY
.131e	da		phx				phx 								; save name with type bits.
.131f	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.1321	10 37		bpl $135a			bpl 	_CDError
.1323	20 8a 14	jsr $148a			jsr 	FindVariable	 			; see if already exist
.1326	b0 35		bcs $135d			bcs 	_CDRedefine 				; it still exists.
.1328	20 0f 12	jsr $120f			jsr 	CreateVariableRecord 		; create the basic variable
.132b	20 69 12	jsr $1269			jsr 	AllocateBytesForType 		; allocate memory for it
.132e	68		pla				pla 								; restore type bits
.132f	5a		phy				phy 								; save the address of the basic storage
.1330	da		phx				phx
.1331	48		pha				pha
.1332	20 60 13	jsr $1360			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.1335	68		pla				pla
.1336	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.1338	20 dd 11	jsr $11dd			jsr 	PushIntegerA 				; push that type data out.
.133b	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.133d	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1340	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.1342	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1345	fa		plx				plx 								; restore address
.1346	7a		ply				ply
.1347	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1349	38		sec				sec
.134a	20 41 1d	jsr $1d41			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.134d	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; , follows ?
.1350	c9 2c		cmp #$2c			cmp 	#","
.1352	d0 05		bne $1359			bne 	_CDExit
.1354	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume comma
.1357	80 bf		bra $1318			bra 	CommandDIM 					; do another DIM
.1359					_CDExit:
.1359	60		rts				rts
.135a					_CDError:
.135a	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.135d					_CDRedefine:
.135d	4c f5 1f	jmp $1ff5		jmp	ErrorV_redefine
.1360					OutputIndexGroup:
.1360	9c 0c 06	stz $060c			stz 	IndexCount 					; count of number of indices.
.1363					_OIGNext:
.1363	20 d0 13	jsr $13d0			jsr 	CompileExpressionAt0 		; get a dimension
.1366	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1368	c9 00		cmp #$00			cmp 	#NSSIFloat
.136a	d0 19		bne $1385			bne 	_OIGType
.136c	ee 0c 06	inc $060c			inc 	IndexCount 					; bump the counter.
.136f	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; does a , follow ?
.1372	c9 2c		cmp #$2c			cmp 	#","
.1374	d0 05		bne $137b			bne 	_OIGCheckEnd
.1376	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume comma
.1379	80 e8		bra $1363			bra 	_OIGNext 					; get next dimension
.137b					_OIGCheckEnd:
.137b	20 2b 11	jsr $112b			jsr 	CheckNextRParen 			; check and consume )
.137e	ad 0c 06	lda $060c			lda 	IndexCount
.1381	20 dd 11	jsr $11dd			jsr 	PushIntegerA 				; compile the dimension count.
.1384	60		rts				rts
.1385					_OIGType:
.1385	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.060c					IndexCount:
>060c							.fill 	1
.1388					ErrorHandler:
.1388	68		pla				pla
.1389	7a		ply				ply
.138a	85 2c		sta $2c				sta 	zTemp0
.138c	84 2d		sty $2d				sty 	zTemp0+1
.138e	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.1390	a0 01		ldy #$01			ldy 	#1
.1392					_EHDisplayMsg:
.1392	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1394	20 f6 10	jsr $10f6			jsr 	PrintCharacter
.1397	c8		iny				iny
.1398	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.139a	d0 f6		bne $1392			bne 	_EHDisplayMsg
.139c	a9 20		lda #$20			lda 	#32
.139e	20 f6 10	jsr $10f6			jsr 	PrintCharacter
.13a1	a9 40		lda #$40			lda 	#64
.13a3	20 f6 10	jsr $10f6			jsr 	PrintCharacter
.13a6	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.13a8	20 75 26	jsr $2675			jsr 	FloatSetByte
.13ab	20 e5 10	jsr $10e5			jsr 	GetLineNumber
.13ae	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13b0	98		tya				tya
.13b1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13b3	20 5b 25	jsr $255b			jsr 	FloatToString
.13b6	a0 00		ldy #$00			ldy 	#0 							; display that string.
.13b8	a2 00		ldx #$00			ldx 	#0
.13ba					_EHDisplayLine:
.13ba	b9 3c 06	lda $063c,y			lda 	decimalBuffer,y
.13bd	20 f6 10	jsr $10f6			jsr 	PrintCharacter
.13c0	c8		iny				iny
.13c1	b9 3c 06	lda $063c,y			lda 	decimalBuffer,y
.13c4	d0 f4		bne $13ba			bne 	_EHDisplayLine
.13c6	a9 0d		lda #$0d			lda 	#13
.13c8	20 f6 10	jsr $10f6			jsr 	PrintCharacter
.13cb	80 fe		bra $13cb	_EHHalt:bra 	_EHHalt
.13cd	4c c2 11	jmp $11c2			jmp 	ExitCompiler
.13d0					CompileExpressionAt0:
.13d0	a9 00		lda #$00			lda 	#0
.13d2					CompileExpressionAtA:
.13d2	48		pha				pha  								; save level
.13d3	20 fa 1d	jsr $1dfa			jsr 	CompileTerm 				; compile a term.
.13d6	fa		plx				plx 								; get level back into X
.13d7					_ECALoop:
.13d7	48		pha				pha 								; save type on stack.
.13d8	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; get the next character
.13db	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.13dd	90 04		bcc $13e3			bcc 	_ECAExit
.13df	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.13e1	90 02		bcc $13e5			bcc 	_ECAHaveToken
.13e3					_ECAExit:
.13e3	68		pla				pla 								; throw type off stack
.13e4	60		rts				rts
.13e5					_ECAHaveToken:
.13e5	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.13e7	aa		tax				tax 								; X contains the operator token
.13e8	bd d3 13	lda $13d3,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.13eb	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.13ed	90 f4		bcc $13e3			bcc 	_ECAExit
.13ef	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.13f1	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume the token.
.13f4	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.13f6	f0 11		beq $1409			beq 	_ECAGreaterCheck
.13f8	e0 b3		cpx #$b3			cpx 	#C64_LESS
.13fa	d0 1a		bne $1416			bne 	_ECAHaveFullToken
.13fc	20 1d 1a	jsr $1a1d			jsr 	LookNext 					; checks for < (<= or <>)
.13ff	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.1401	f0 0e		beq $1411			beq	 	_ECAToNotEqual
.1403	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.1405	d0 0f		bne $1416			bne 	_ECAHaveFullToken
.1407	80 07		bra $1410			bra 	_ECAAddEqual
.1409					_ECAGreaterCheck:
.1409	20 1d 1a	jsr $1a1d			jsr 	LookNext
.140c	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.140e	d0 06		bne $1416			bne 	_ECAHaveFullToken
.1410					_ECAAddEqual:
.1410	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.1411					_ECAToNotEqual:
.1411	e8		inx				inx
.1412	e8		inx				inx
.1413	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume the = or > in >= <= <>
.1416					_ECAHaveFullToken:
.1416	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.1418	d0 0a		bne $1424			bne 	_ECANotConcat
.141a	68		pla				pla 								; get type back
.141b	48		pha				pha
.141c	29 40		and #$40			and 	#NSSTypeMask
.141e	c9 40		cmp #$40			cmp 	#NSSString
.1420	d0 02		bne $1424			bne 	_ECANotConcat
.1422	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1424					_ECANotConcat:
.1424	da		phx				phx 								; save operator on the stack
.1425	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.1427	da		phx				phx
.1428	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.142a	1a		inc a				inc 	a
.142b	20 d2 13	jsr $13d2			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.142e	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.1430	fa		plx				plx 								; restore current precedence in X
.1431	68		pla				pla 								; restore operator
.1432	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.1434	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.1436	90 17		bcc $144f			bcc 	_ECANotCompare
.1438	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.143a	b0 13		bcs $144f			bcs 	_ECANotCompare
.143c	7a		ply				ply 								; get type into Y
.143d	5a		phy				phy
.143e	48		pha				pha 								; save operator
.143f	98		tya				tya 								; get type
.1440	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.1442	29 40		and #$40			and 	#NSSTypeMask
.1444	c9 40		cmp #$40			cmp 	#NSSString
.1446	f0 02		beq $144a			beq 	_ECANotString
.1448	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.144a					_ECANotString:
.144a	98		tya				tya									; output token Y
.144b	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.144e	68		pla				pla 								; restore operator.
.144f					_ECANotCompare:
.144f	18		clc				clc 								; convert to P-Code and compile.
.1450	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.1452	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1455	68		pla				pla 								; type of current result
.1456	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.1458	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.145a	d0 19		bne $1475			bne		_ECAType
.145c	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.145e	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.1460	d0 18		bne $147a			bne 	_ECAGoLoop
.1462	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.1464	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1466	f0 10		beq $1478			beq 	_ECAOkayString 				; (this is post conversion)
.1468	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.146a	90 09		bcc $1475			bcc 	_ECAType
.146c	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.146e	b0 05		bcs $1475			bcs 	_ECAType
.1470	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.1472	4c d7 13	jmp $13d7			jmp 	_ECALoop
.1475					_ECAType:
.1475	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.1478					_ECAOkayString:
.1478	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.147a					_ECAGoLoop:
.147a	4c d7 13	jmp $13d7			jmp 	_ECALoop
.147d					PrecedenceTable:
>147d	03						.byte 	3 					; '+'
>147e	03						.byte 	3 					; '-'
>147f	04						.byte 	4 					; '*'
>1480	04						.byte 	4 					; '/'
>1481	05						.byte 	5 					; '^'
>1482	01						.byte 	1 					; 'and'
>1483	00						.byte 	0 					; 'or'
>1484	02						.byte 	2 					; '>'
>1485	02						.byte 	2 					; '='
>1486	02						.byte 	2 					; '<'
>1487	02						.byte 	2 					; '>='
>1488	02						.byte 	2 					; '<='
>1489	02						.byte 	2 					; '<>'
.148a					FindVariable:
.148a	86 2e		stx $2e				stx 	zTemp1 						; save name.
.148c	84 2f		sty $2f				sty 	zTemp1+1
.148e					_IVCheckSpecial:
.148e	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.1490	d0 18		bne $14aa			bne 	_IVStandard
.1492	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.1494	f0 0c		beq $14a2			beq 	_IVTIFloat
.1496	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.1498	d0 10		bne $14aa			bne 	_IVStandard
.149a	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.149c	a2 01		ldx #$01			ldx 	#$01
.149e	a9 40		lda #$40			lda 	#NSSString
.14a0	38		sec				sec
.14a1	60		rts				rts
.14a2					_IVTIFloat:
.14a2	a0 80		ldy #$80			ldy 	#$80
.14a4	a2 00		ldx #$00			ldx 	#$00
.14a6	a9 00		lda #$00			lda 	#0
.14a8	38		sec				sec
.14a9	60		rts				rts
.14aa					_IVStandard:
.14aa	ad 07 06	lda $0607			lda 	compilerStartHigh			; start scanning from here.
.14ad	85 2d		sta $2d				sta 	zTemp0+1
.14af	64 2c		stz $2c				stz 	zTemp0
.14b1					_IVCheckLoop:
.14b1	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.14b3	f0 2b		beq $14e0			beq  	_IVNotFound 				; if so, return with CC.
.14b5	a0 01		ldy #$01			ldy 	#1 							; match ?
.14b7	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14b9	c5 2e		cmp $2e				cmp 	zTemp1
.14bb	d0 07		bne $14c4			bne	 	_IVNext
.14bd	c8		iny				iny
.14be	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14c0	c5 2f		cmp $2f				cmp 	zTemp1+1
.14c2	f0 0d		beq $14d1			beq 	_IVFound
.14c4					_IVNext:
.14c4	18		clc				clc
.14c5	a5 2c		lda $2c				lda 	zTemp0
.14c7	72 2c		adc ($2c)			adc 	(zTemp0)
.14c9	85 2c		sta $2c				sta 	zTemp0
.14cb	90 e4		bcc $14b1			bcc 	_IVCheckLoop
.14cd	e6 2d		inc $2d				inc 	zTemp0+1
.14cf	80 e0		bra $14b1			bra 	_IVCheckLoop
.14d1					_IVFound:
.14d1	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.14d3	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14d5	aa		tax				tax
.14d6	c8		iny				iny
.14d7	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14d9	48		pha				pha
.14da	c8		iny				iny
.14db	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14dd	7a		ply				ply
.14de	38		sec				sec
.14df	60		rts				rts
.14e0					_IVNotFound:
.14e0	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.14e2	a4 2f		ldy $2f				ldy 	zTemp1+1
.14e4	18		clc				clc
.14e5	60		rts				rts
.14e6					FixBranches:
.14e6	20 58 10	jsr $1058			jsr 	APIORewind 					; back to the start of the *object* code.
.14e9					_FBLoop:
.14e9	b2 29		lda ($29)			lda 	(objPtr) 					; get the next one.
.14eb	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.14ed	f0 16		beq $1505			beq 	_FBFixGotoGosub
.14ef	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.14f1	f0 12		beq $1505			beq 	_FBFixGotoGosub
.14f3	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.14f5	f0 0e		beq $1505			beq 	_FBFixGotoGosub
.14f7	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.14f9	f0 0a		beq $1505			beq 	_FBFixGotoGosub
.14fb	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.14fd	f0 49		beq $1548			beq 	_FBFixVarSpace
.14ff					_FBNext:
.14ff	20 42 20	jsr $2042			jsr 	MoveObjectForward 			; move forward in object code.
.1502	90 e5		bcc $14e9			bcc 	_FBLoop 					; not finished
.1504					_FBExit:
.1504	60		rts				rts
.1505					_FBFixGotoGosub:
.1505	a0 01		ldy #$01			ldy 	#1 							; if page is currently $FF
.1507	b1 29		lda ($29),y			lda 	(objPtr),y 					; then patch else leave.
.1509	c9 ff		cmp #$ff			cmp 	#$FF
.150b	d0 f2		bne $14ff			bne 	_FBNext
.150d	a0 02		ldy #$02			ldy 	#2							; line number in YA
.150f	b1 29		lda ($29),y			lda 	(objPtr),y
.1511	48		pha				pha
.1512	c8		iny				iny
.1513	b1 29		lda ($29),y			lda 	(objPtr),y
.1515	a8		tay				tay
.1516	68		pla				pla
.1517	20 e1 1b	jsr $1be1			jsr 	STRFindLine			 		; find where it is X:YA
.151a	90 08		bcc $1524			bcc 	_FBFFound 					; not found, so must be >
.151c	48		pha				pha
.151d	b2 29		lda ($29)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.151f	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1521	d0 15		bne $1538			bne 	_FBFFail
.1523	68		pla				pla
.1524					_FBFFound:
.1524	20 35 1c	jsr $1c35			jsr 	STRMakeOffset 				; make it an offset from X:YA
.1527	5a		phy				phy	 								; patch the GOTO/GOSUB
.1528	48		pha				pha
.1529	a0 01		ldy #$01			ldy 	#1
.152b	8a		txa				txa
.152c	91 29		sta ($29),y			sta 	(objPtr),y
.152e	c8		iny				iny
.152f	68		pla				pla
.1530	91 29		sta ($29),y			sta 	(objPtr),y
.1532	c8		iny				iny
.1533	68		pla				pla
.1534	91 29		sta ($29),y			sta 	(objPtr),y
.1536	80 c7		bra $14ff			bra 	_FBNext
.1538					_FBFFail:
.1538	a0 02		ldy #$02			ldy 	#2
.153a	b1 29		lda ($29),y			lda 	(objPtr),y
.153c	8d 00 05	sta $0500			sta 	currentLineNumber
.153f	c8		iny				iny
.1540	b1 29		lda ($29),y			lda 	(objPtr),y
.1542	8d 01 05	sta $0501			sta 	currentLineNumber+1
.1545	4c 70 1f	jmp $1f70		jmp	ErrorV_line
.1548					_FBFixVarSpace:
.1548	a0 01		ldy #$01			ldy 	#1
.154a	ad 13 06	lda $0613			lda 	freeVariableMemory
.154d	91 29		sta ($29),y			sta 	(objPtr),y
.154f	c8		iny				iny
.1550	ad 14 06	lda $0614			lda 	freeVariableMemory+1
.1553	91 29		sta ($29),y			sta 	(objPtr),y
.1555	80 a8		bra $14ff			bra 	_FBNext
.1557					CommandFOR:
.1557	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.155a	20 4f 1a	jsr $1a4f			jsr 	CharIsAlpha 				; if not alpha , error
.155d	90 59		bcc $15b8			bcc 	_CFFail
.155f	20 8f 1d	jsr $1d8f			jsr 	GetReferenceTerm 			; figure out the reference.
.1562	48		pha				pha 								; save type
.1563	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1565	c9 00		cmp #$00			cmp 	#NSSIFloat
.1567	d0 4f		bne $15b8			bne 	_CFFail
.1569	5a		phy				phy 								; save reference on the stack
.156a	da		phx				phx
.156b	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.156d	20 31 11	jsr $1131			jsr 	CheckNextA
.1570	20 d0 13	jsr $13d0			jsr 	CompileExpressionAt0 		; initial value
.1573	fa		plx				plx 								; get reference back.
.1574	7a		ply				ply
.1575	5a		phy				phy
.1576	da		phx				phx
.1577	38		sec				sec 								; set initial value.
.1578	20 41 1d	jsr $1d41			jsr 	GetSetVariable
.157b	fa		plx				plx
.157c	7a		ply				ply
.157d	68		pla				pla
.157e	29 20		and #$20			and 	#NSSIInt16
.1580	f0 04		beq $1586			beq 	_CFNotInt16
.1582	98		tya				tya
.1583	09 80		ora #$80			ora 	#$80
.1585	a8		tay				tay
.1586					_CFNotInt16:
.1586	8a		txa				txa 								; reference in YA
.1587	20 ca 11	jsr $11ca			jsr 	PushIntegerYA
.158a	a9 a4		lda #$a4			lda 	#C64_TO
.158c	20 31 11	jsr $1131			jsr 	CheckNextA
.158f	20 d0 13	jsr $13d0			jsr 	CompileExpressionAt0 		; terminal value
.1592	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1594	c9 00		cmp #$00			cmp 	#NSSIFloat
.1596	d0 20		bne $15b8			bne 	_CFFail
.1598	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; followed by STEP
.159b	c9 a9		cmp #$a9			cmp 	#C64_STEP
.159d	d0 0e		bne $15ad			bne 	_CFNoStep
.159f	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume it.
.15a2	20 d0 13	jsr $13d0			jsr 	CompileExpressionAt0 		; terminal value
.15a5	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.15a7	c9 00		cmp #$00			cmp 	#NSSIFloat
.15a9	d0 0d		bne $15b8			bne 	_CFFail
.15ab	80 05		bra $15b2			bra 	_CFParametersDone
.15ad					_CFNoStep:
.15ad	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.15af	20 dd 11	jsr $11dd			jsr 	PushIntegerA
.15b2					_CFParametersDone:
.15b2	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.15b4	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.15b7	60		rts				rts
.15b8					_CFFail:
.15b8	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.15bb					FNCompile:
.15bb	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.15be	20 9e 1a	jsr $1a9e			jsr 	ExtractVariableName
.15c1	e0 00		cpx #$00			cpx 	#0
.15c3	10 32		bpl $15f7			bpl 	_FNError
.15c5	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.15c6	29 7f		and #$7f			and 	#$7F
.15c8	aa		tax				tax
.15c9	98		tya				tya
.15ca	09 80		ora #$80			ora 	#$80
.15cc	a8		tay				tay
.15cd	20 8a 14	jsr $148a			jsr 	FindVariable				; does it already exist ?
.15d0	90 25		bcc $15f7			bcc 	_FNError 					; no.
.15d2	20 35 1c	jsr $1c35			jsr 	STRMakeOffset 				; convert to a relative address.
.15d5	c9 00		cmp #$00			cmp 	#0 							; fix up.
.15d7	d0 01		bne $15da			bne 	_FNNoBorrow
.15d9	88		dey				dey
.15da					_FNNoBorrow:
.15da	3a		dec a				dec 	a
.15db	5a		phy				phy 								; save location of routine on stack.
.15dc	48		pha				pha
.15dd	da		phx				phx
.15de	20 d0 13	jsr $13d0			jsr 	CompileExpressionAt0
.15e1	20 2b 11	jsr $112b			jsr 	CheckNextRParen
.15e4	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.15e6	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.15e9	68		pla				pla
.15ea	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.15ed	68		pla				pla
.15ee	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.15f1	68		pla				pla
.15f2	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.15f5	18		clc				clc
.15f6	60		rts				rts
.15f7					_FNError:
.15f7	4c 20 1f	jmp $1f20		jmp	ErrorV_value
.15fa					CommandTables:
>15fa	07 cb 00 03 fc 1a 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>1601	07 89 00 03 03 1b 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>1608	07 8d 00 03 f6 1a 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>160f	07 88 00 03 7e 1b 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>1616	07 85 00 03 5e 1b 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>161d	07 84 00 04 72 1b 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>1624	07 99 00 03 bc 1c 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>162b	07 98 00 04 bc 1c 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>1632	07 8f 00 03 c7 1d 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>1639	07 81 00 03 57 15 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>1640	07 82 00 03 3f 1c 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>1647	07 a1 00 03 6f 1a 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>164e	07 83 00 03 85 12 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>1655	07 87 00 03 05 1d 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>165c	07 86 00 03 18 13 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>1663	07 96 00 03 a1 12 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>166a	07 8b 00 e3 26 1b 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>1671	08 92 00 ea e3 93 1e 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>1679	09 91 00 e1 a9 03 6b 1c			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>1681	06
>1682	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>1689	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>1690	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>1696	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>169d	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>16a4	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>16ab	07 9d 00 e3 b9 1e 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>16b2	0a 9f 00 ea e3 cc 1e 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>16ba	c6 06
>16bc	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>16c2	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>16c9	0a ce 92 e3 ec 19 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>16d1	ad 06
>16d3	0a ce 8d e3 ec 19 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>16db	ae 06
>16dd	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>16e3	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>16eb	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>16f2	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>16f9	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>1701	06
>1702	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>170a	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>1712	9a 06
>1714	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>171c	9b 06
>171e	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>1726	9c 06
>1728	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>1730	06
>1731	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>1738	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>1740	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>1748	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>1750	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>1758	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>1760	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>1768	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>1770	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>1778	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>1780	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>1788	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>178f	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>1797	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>179f	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>17a7	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>17af	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>17b7	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>17bf	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>17c7	00						.byte 	0
.17c8					UnaryTables:
>17c8	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>17cf	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>17d7	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>17de	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>17e5	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>17ec	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>17f3	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>17fb	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>1802	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>180a	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>1812	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>181a	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>1822	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>182a	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>1832	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>1839	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>1840	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>1847	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>184e	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>1855	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>185c	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>1864	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>186c	0b ca 00 8f ae 03 ec 19			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>1874	91 bd 07
>1877	07 a8 00 03 0b 1a 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>187e	07 a5 00 03 bb 15 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>1885	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>188c	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>1893	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>189b	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>18a3	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>18aa	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>18b1	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>18b8	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>18c0	06
>18c1	00						.byte 	0
.18c2					GeneratorProcess:
.18c2	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.18c4	84 2d		sty $2d				sty 	zTemp0+1
.18c6	85 2e		sta $2e				sta 	zTemp1 						; first match token
.18c8	64 2f		stz $2f				stz 	zTemp1+1
.18ca	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.18cc	d0 05		bne $18d3			bne 	_GPNotShifted
.18ce	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; get the shifted token
.18d1	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.18d3					_GPNotShifted:
.18d3					_GPSearch:
.18d3	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.18d5	18		clc				clc
.18d6	f0 2f		beq $1907			beq 	_GPExit
.18d8	a0 01		ldy #$01			ldy 	#1 							; tokens match
.18da	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.18dc	c5 2e		cmp $2e				cmp 	zTemp1
.18de	d0 09		bne $18e9			bne 	_GPNext
.18e0	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.18e2	f0 12		beq $18f6			beq 	_GPFound
.18e4	c8		iny				iny 								; check match.
.18e5	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.18e7	f0 0d		beq $18f6			beq 	_GPFound
.18e9					_GPNext:
.18e9	18		clc				clc 								; follow to next
.18ea	a5 2c		lda $2c				lda 	zTemp0
.18ec	72 2c		adc ($2c)			adc 	(zTemp0)
.18ee	85 2c		sta $2c				sta 	zTemp0
.18f0	90 e1		bcc $18d3			bcc 	_GPSearch
.18f2	e6 2d		inc $2d				inc 	zTemp0+1
.18f4	80 dd		bra $18d3			bra 	_GPSearch
.18f6					_GPFound:
.18f6	18		clc				clc 								; skip to action bytes
.18f7	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.18f9	69 03		adc #$03			adc 	#3
.18fb	85 2c		sta $2c				sta 	zTemp0
.18fd	90 02		bcc $1901			bcc 	_GPNoCarry
.18ff	e6 2d		inc $2d				inc 	zTemp0+1
.1901					_GPNoCarry:
.1901					_GPLoop:
.1901	20 08 19	jsr $1908			jsr 	GeneratorExecute 			; execute one command
.1904	90 fb		bcc $1901			bcc 	_GPLoop 					; go back if not completed.
.1906	38		sec				sec 								; return with CS.
.1907					_GPExit:
.1907	60		rts				rts
.1908					GeneratorExecute:
.1908	20 b3 19	jsr $19b3			jsr 	_GEFetchZTemp0 				; get next.
.190b	48		pha				pha 								; split into 2 nibbles
.190c	4a		lsr a				lsr 	a
.190d	4a		lsr a				lsr 	a
.190e	4a		lsr a				lsr		a
.190f	4a		lsr a				lsr 	a
.1910	20 1a 19	jsr $191a			jsr 	_GEExecuteNibble 			; MSB first
.1913	68		pla				pla
.1914	b0 03		bcs $1919			bcs 	_GEHaveCompleted
.1916	20 1a 19	jsr $191a			jsr 	_GEExecuteNibble 			; LSB second
.1919					_GEHaveCompleted:
.1919	60		rts				rts
.191a					_GEExecuteNibble:
.191a	29 0f		and #$0f			and 	#$0F
.191c	0a		asl a				asl 	a
.191d	aa		tax				tax
.191e	7c 21 19	jmp ($1921,x)			jmp 	(_GEExecuteVectors,x)
.1921					_GEExecuteVectors:
>1921	41 19						.word 	_GEXNop 					; 0  (no operation)
>1923	49 19						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>1925	43 19						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>1927	96 19						.word 	_GEXExecute 				; 3  (run arbitrary code)
>1929	89 19						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>192b	41 19						.word 	_GEXNop 					; 5
>192d	50 19						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>192f	54 19						.word 	_GEXExitString 				; 7  exit return string type
>1931	58 19						.word 	_GEXLParam 					; 8  check ( follows
>1933	5c 19						.word 	_GEXRParam 					; 9  check ) follows
>1935	60 19						.word 	_GEXComma					; A  check , follows
>1937	41 19						.word 	_GEXNop 					; B
>1939	41 19						.word 	_GEXNop 					; C
>193b	41 19						.word 	_GEXNop 					; D
>193d	70 19						.word 	_GEXNumber 					; E  compile get any number
>193f	7b 19						.word 	_GEXString 					; F  compile get any string
.1941					_GEXNop:
.1941	18		clc				clc
.1942	60		rts				rts
.1943					_GEXToken2:
.1943	20 b3 19	jsr $19b3			jsr 	_GEFetchZTemp0
.1946	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1949					_GEXToken1:
.1949	20 b3 19	jsr $19b3			jsr 	_GEFetchZTemp0
.194c	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.194f	60		rts				rts
.1950					_GEXExitNumber:
.1950	a9 00		lda #$00			lda 	#NSSIFloat
.1952	38		sec				sec
.1953	60		rts				rts
.1954					_GEXExitString:
.1954	a9 40		lda #$40			lda 	#NSSString
.1956	38		sec				sec
.1957	60		rts				rts
.1958					_GEXLParam:
.1958	a9 28		lda #$28			lda 	#"("
.195a	80 06		bra $1962			bra 	_GEXCheck
.195c					_GEXRParam:
.195c	a9 29		lda #$29			lda 	#")"
.195e	80 02		bra $1962			bra 	_GEXCheck
.1960					_GEXComma:
.1960	a9 2c		lda #$2c			lda 	#","
.1962					_GEXCheck:
.1962	85 30		sta $30				sta 	zTemp2 						; save match
.1964	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; get next skipping spaces
.1967	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.1969	d0 02		bne $196d			bne 	_GEXSyntax
.196b	18		clc				clc
.196c	60		rts				rts
.196d					_GEXSyntax:
.196d	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.1970					_GEXNumber:
.1970	20 bc 19	jsr $19bc			jsr 	GEXCompileExpression 		; compile expression
.1973	29 40		and #$40			and 	#NSSTypeMask
.1975	c9 00		cmp #$00			cmp  	#NSSIFloat
.1977	d0 0d		bne $1986			bne 	_GEXType
.1979	18		clc				clc
.197a	60		rts				rts
.197b					_GEXString:
.197b	20 bc 19	jsr $19bc			jsr 	GEXCompileExpression 		; compile expression
.197e	29 40		and #$40			and 	#NSSTypeMask
.1980	c9 40		cmp #$40			cmp  	#NSSString
.1982	d0 02		bne $1986			bne 	_GEXType
.1984	18		clc				clc
.1985	60		rts				rts
.1986					_GEXType:
.1986	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.1989					_GEXChannelExec:
.1989	20 cc 19	jsr $19cc			jsr 	ChannelPrefix 				; set up default
.198c	20 96 19	jsr $1996			jsr 	_GEXExecute
.198f	08		php				php
.1990	20 e6 19	jsr $19e6			jsr 	ChannelPostfix 				; replace default.
.1993	28		plp				plp
.1994	60		rts				rts
>1995	db						.byte 	$DB 						; causes a break in the emulator
.1996					_GEXExecute:
.1996	20 b3 19	jsr $19b3			jsr 	_GEFetchZTemp0 				; get vector
.1999	85 30		sta $30				sta 	zTemp2
.199b	20 b3 19	jsr $19b3			jsr 	_GEFetchZTemp0
.199e	85 31		sta $31				sta 	zTemp2+1
.19a0	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19a2	da		phx				phx
.19a3	a6 2d		ldx $2d				ldx 	zTemp0+1
.19a5	da		phx				phx
.19a6	20 b0 19	jsr $19b0			jsr 	_GECallZTemp2 				; execute code
.19a9	fa		plx				plx 								; recover generation exec
.19aa	86 2d		stx $2d				stx 	zTemp0+1
.19ac	fa		plx				plx
.19ad	86 2c		stx $2c				stx 	zTemp0
.19af	60		rts				rts
.19b0					_GECallZTemp2:
.19b0	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.19b3					_GEFetchZTemp0:
.19b3	b2 2c		lda ($2c)			lda 	(zTemp0)
.19b5	e6 2c		inc $2c				inc 	zTemp0
.19b7	d0 02		bne $19bb			bne 	_GEFZ0Skip
.19b9	e6 2d		inc $2d				inc 	zTemp0+1
.19bb					_GEFZ0Skip:
.19bb	60		rts				rts
.19bc					GEXCompileExpression:
.19bc	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.19be	da		phx				phx
.19bf	a6 2d		ldx $2d				ldx 	zTemp0+1
.19c1	da		phx				phx
.19c2	20 d0 13	jsr $13d0			jsr 	CompileExpressionAt0 		; compile expression.
.19c5	fa		plx				plx 								; recover generation exec
.19c6	86 2d		stx $2d				stx 	zTemp0+1
.19c8	fa		plx				plx
.19c9	86 2c		stx $2c				stx 	zTemp0
.19cb	60		rts				rts
.19cc					ChannelPrefix:
.19cc	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.19ce	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.19d1	20 bc 19	jsr $19bc			jsr 	GEXCompileExpression 		; channel #
.19d4	29 40		and #$40			and 	#NSSTypeMask
.19d6	c9 00		cmp #$00			cmp 	#NSSIFloat
.19d8	d0 09		bne $19e3			bne 	_CPXType
.19da	20 27 11	jsr $1127			jsr 	CheckNextComma 				; check , follows.
.19dd	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.19df	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.19e2	60		rts				rts
.19e3					_CPXType:
.19e3	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.19e6					ChannelPostfix:
.19e6	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.19e8	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.19eb	60		rts				rts
.19ec					OptionalParameterCompile:
.19ec	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; what follows.
.19ef	c9 2c		cmp #$2c			cmp 	#","
.19f1	d0 0e		bne $1a01			bne 	_MidDefault
.19f3	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume ,
.19f6	20 d0 13	jsr $13d0			jsr 	CompileExpressionAt0
.19f9	29 40		and #$40			and 	#NSSTypeMask
.19fb	c9 00		cmp #$00			cmp 	#NSSIFloat
.19fd	d0 09		bne $1a08			bne 	MidFailType
.19ff	80 05		bra $1a06			bra 	_MidComplete
.1a01					_MidDefault:
.1a01	a9 ff		lda #$ff			lda 	#255 						; default of 255
.1a03	20 dd 11	jsr $11dd			jsr 	PushIntegerA
.1a06					_MidComplete:
.1a06	18		clc				clc
.1a07	60		rts				rts
.1a08					MidFailType:
.1a08	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.1a0b					NotUnaryCompile:
.1a0b	ad 85 14	lda $1485			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.1a0e	20 d2 13	jsr $13d2			jsr 	CompileExpressionAtA 		; evaluate at that level
.1a11	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.1a13	c9 00		cmp #$00			cmp 	#NSSIFloat
.1a15	d0 f1		bne $1a08			bne 	MidFailType
.1a17	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.1a19	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1a1c	60		rts				rts
.1a1d					LookNext:
.1a1d	b2 24		lda ($24)			lda 	(srcPtr)
.1a1f	60		rts				rts
.1a20					LookNextNonSpace:
.1a20	b2 24		lda ($24)			lda 	(srcPtr)
.1a22	c9 20		cmp #$20			cmp		#' '
.1a24	f0 03		beq $1a29			beq 	_LNNSkip
.1a26	c9 00		cmp #$00			cmp 	#0
.1a28	60		rts				rts
.1a29					_LNNSkip:
.1a29	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1a2c	80 f2		bra $1a20			bra 	LookNextNonSpace
.1a2e					GetNext:
.1a2e	b2 24		lda ($24)			lda 	(srcPtr) 					; get next
.1a30	e6 24		inc $24				inc 	srcPtr
.1a32	d0 02		bne $1a36			bne 	_GNSkip
.1a34	e6 25		inc $25				inc 	srcPtr+1
.1a36					_GNSkip:
.1a36	c9 00		cmp #$00			cmp 	#0
.1a38	60		rts				rts
.1a39					GetNextNonSpace:
.1a39	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1a3c	c9 20		cmp #$20			cmp 	#' '
.1a3e	f0 f9		beq $1a39			beq 	GetNextNonSpace
.1a40	c9 00		cmp #$00			cmp 	#0
.1a42	60		rts				rts
.1a43					CharIsDigit:
.1a43	c9 30		cmp #$30			cmp 	#"0"
.1a45	90 06		bcc $1a4d			bcc 	CCFalse
.1a47	c9 3a		cmp #$3a			cmp 	#"9"+1
.1a49	b0 02		bcs $1a4d			bcs 	CCFalse
.1a4b					CCTrue:
.1a4b	38		sec				sec
.1a4c	60		rts				rts
.1a4d					CCFalse:
.1a4d	18		clc				clc
.1a4e	60		rts				rts
.1a4f					CharIsAlpha:
.1a4f	c9 41		cmp #$41			cmp 	#"A"
.1a51	90 fa		bcc $1a4d			bcc 	CCFalse
.1a53	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1a55	b0 f6		bcs $1a4d			bcs 	CCFalse
.1a57	80 f2		bra $1a4b			bra 	CCTrue
.1a59					ConvertHexStyle:
.1a59	38		sec				sec
.1a5a	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.1a5c	90 ef		bcc $1a4d			bcc 	CCFalse
.1a5e	c9 0a		cmp #$0a			cmp 	#9+1
.1a60	90 e9		bcc $1a4b			bcc 	CCTrue
.1a62	38		sec				sec 								; shift into hex space A=>0 Z=>25
.1a63	e9 11		sbc #$11			sbc 	#"A"-"0"
.1a65	90 e6		bcc $1a4d			bcc 	CCFalse
.1a67	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.1a69	b0 e2		bcs $1a4d			bcs 	CCFalse
.1a6b	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.1a6d	80 dc		bra $1a4b			bra 	CCTrue
.1a6f					CommandGET:
.1a6f	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; # follows ?
.1a72	c9 23		cmp #$23			cmp 	#"#"
.1a74	d0 0d		bne $1a83			bne 	CommandGetBody
.1a76	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume #
.1a79	20 cc 19	jsr $19cc			jsr 	ChannelPrefix 				; do it as GET#
.1a7c	20 83 1a	jsr $1a83			jsr 	CommandGetBody
.1a7f	20 e6 19	jsr $19e6			jsr 	ChannelPostfix
.1a82	60		rts				rts
.1a83					CommandGetBody:
.1a83	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; get the first character
.1a86	20 8f 1d	jsr $1d8f			jsr 	GetReferenceTerm 			; identify variable to assign to
.1a89	48		pha				pha
.1a8a	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.1a8c	c9 40		cmp #$40			cmp 	#NSSString
.1a8e	d0 0b		bne $1a9b			bne 	_CGType
.1a90	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.1a92	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1a95	38		sec				sec
.1a96	68		pla				pla
.1a97	20 41 1d	jsr $1d41			jsr		GetSetVariable
.1a9a	60		rts				rts
.1a9b					_CGType:
.1a9b	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.1a9e					ExtractVariableName:
.1a9e	20 4f 1a	jsr $1a4f			jsr 	CharIsAlpha
.1aa1	90 50		bcc $1af3			bcc 	_IVSyntax
.1aa3	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.1aa5	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.1aa7	64 2f		stz $2f				stz 	zTemp1+1
.1aa9	20 1d 1a	jsr $1a1d			jsr 	LookNext 					; is there a second character ?
.1aac	20 4f 1a	jsr $1a4f			jsr 	CharIsAlpha  				; must be alphanumeric
.1aaf	b0 05		bcs $1ab6			bcs 	_IVHasSecond
.1ab1	20 43 1a	jsr $1a43			jsr 	CharIsDigit
.1ab4	90 07		bcc $1abd			bcc 	_IVCheckType
.1ab6					_IVHasSecond:
.1ab6	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.1ab8	85 2f		sta $2f				sta 	zTemp1+1
.1aba					_IVGetNextCheck:
.1aba	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume it
.1abd					_IVCheckType:
.1abd	20 1d 1a	jsr $1a1d			jsr 	LookNext					; check if string follows.
.1ac0	20 4f 1a	jsr $1a4f			jsr 	CharIsAlpha
.1ac3	b0 f5		bcs $1aba			bcs 	_IVGetNextCheck
.1ac5	20 43 1a	jsr $1a43			jsr 	CharIsDigit
.1ac8	b0 f0		bcs $1aba			bcs 	_IVGetNextCheck
.1aca	a2 40		ldx #$40			ldx 	#NSSString
.1acc	c9 24		cmp #$24			cmp 	#"$"
.1ace	f0 06		beq $1ad6			beq 	_IVHasType
.1ad0	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.1ad2	c9 25		cmp #$25			cmp 	#"%"
.1ad4	d0 08		bne $1ade			bne 	_IVCheckArray
.1ad6					_IVHasType:
.1ad6	8a		txa				txa 								; Or X into zTemp1
.1ad7	05 2e		ora $2e				ora 	zTemp1
.1ad9	85 2e		sta $2e				sta 	zTemp1
.1adb	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume it
.1ade					_IVCheckArray:
.1ade	20 1d 1a	jsr $1a1d			jsr 	LookNext 					; check if array follows
.1ae1	c9 28		cmp #$28			cmp 	#"("
.1ae3	d0 09		bne $1aee			bne 	_IVNotArray
.1ae5	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.1ae7	09 80		ora #$80			ora 	#NSSArray
.1ae9	85 2e		sta $2e				sta 	zTemp1
.1aeb	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume it
.1aee					_IVNotArray:
.1aee	a6 2e		ldx $2e				ldx 	zTemp1
.1af0	a4 2f		ldy $2f				ldy 	zTemp1+1
.1af2	60		rts				rts
.1af3					_IVSyntax:
.1af3	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.1af6					CommandGOSUB:
.1af6	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.1af8	20 09 1b	jsr $1b09			jsr 	CompileBranchCommand
.1afb	60		rts				rts
.1afc					CommandGOAlt:
.1afc	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.1afe	20 31 11	jsr $1131			jsr 	CheckNextA
.1b01	80 00		bra $1b03			bra 	CommandGOTO
.1b03					CommandGOTO:
.1b03	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.1b05	20 09 1b	jsr $1b09			jsr 	CompileBranchCommand
.1b08	60		rts				rts
.1b09					CompileBranchCommand:
.1b09	20 ec 10	jsr $10ec			jsr 	WriteCodeByte 				; write the command out.
.1b0c	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace
.1b0f	20 97 1c	jsr $1c97			jsr 	ParseConstant 				; get constant into YA
.1b12	90 0f		bcc $1b23			bcc 	_CBCSyntax
.1b14	48		pha				pha
.1b15	a9 ff		lda #$ff			lda 	#$FF 						; no address yet.
.1b17	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b1a	68		pla				pla 								; and compile the actual line number
.1b1b	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b1e	98		tya				tya
.1b1f	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b22	60		rts				rts
.1b23					_CBCSyntax:
.1b23	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.1b26					CommandIF:
.1b26	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; what follows the tests ?
.1b29	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.1b2b	f0 0f		beq $1b3c			beq 	_CIGoto
.1b2d	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.1b2f	20 31 11	jsr $1131			jsr 	CheckNextA
.1b32	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; THEN <number>
.1b35	20 43 1a	jsr $1a43			jsr 	CharIsDigit
.1b38	b0 05		bcs $1b3f			bcs 	_CIGoto2
.1b3a	80 09		bra $1b45			bra 	CompileGotoEOL
.1b3c					_CIGoto:
.1b3c	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1b3f					_CIGoto2:
.1b3f	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.1b41	20 09 1b	jsr $1b09			jsr 	CompileBranchCommand
.1b44	60		rts				rts
.1b45					CompileGotoEOL:
.1b45	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.1b47	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b4a	a9 ff		lda #$ff			lda 	#$FF
.1b4c	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b4f	20 e5 10	jsr $10e5			jsr 	GetLineNumber 				; Get the current line number => YA
.1b52	1a		inc a				inc 	a 							; and branch to +1
.1b53	d0 01		bne $1b56			bne 	_CGENoCarry
.1b55	c8		iny				iny
.1b56					_CGENoCarry:
.1b56	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b59	98		tya				tya
.1b5a	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b5d	60		rts				rts
.1b5e					CommandINPUT:
.1b5e	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; check for "
.1b61	c9 22		cmp #$22			cmp 	#'"'
.1b63	d0 0d		bne $1b72			bne 	CommandINPUTStream
.1b65	20 d0 13	jsr $13d0			jsr 	CompileExpressionAt0
.1b68	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.1b6a	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b6d	a9 2c		lda #$2c			lda 	#","
.1b6f	20 27 11	jsr $1127			jsr 	CheckNextComma
.1b72					CommandINPUTStream:
.1b72	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.1b74	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1b77	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.1b79	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.1b7b	4c 09 1d	jmp $1d09			jmp 	CommandReadInputCommon
.1b7e					CommandLET:
.1b7e	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; get the first character
.1b81					CommandLETHaveFirst:
.1b81	20 8f 1d	jsr $1d8f			jsr 	GetReferenceTerm 			; identify variable to assign to
.1b84	da		phx				phx 								; save target on the stack.
.1b85	5a		phy				phy
.1b86	48		pha				pha
.1b87	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.1b89	20 31 11	jsr $1131			jsr 	CheckNextA
.1b8c	20 d0 13	jsr $13d0			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.1b8f	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.1b91	68		pla				pla 								; get type of assignment
.1b92	48		pha				pha
.1b93	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.1b95	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.1b97	d0 17		bne $1bb0			bne 	_CLType
.1b99	68		pla				pla 								; restore and compile save code
.1b9a	7a		ply				ply
.1b9b	fa		plx				plx
.1b9c	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.1b9e	f0 05		beq $1ba5			beq 	_CLTIString
.1ba0	38		sec				sec
.1ba1	20 41 1d	jsr $1d41			jsr		GetSetVariable
.1ba4	60		rts				rts
.1ba5					_CLTIString:
.1ba5	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.1ba7	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1baa	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.1bac	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1baf	60		rts				rts
.1bb0					_CLType:
.1bb0	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.1bb3					STRMarkLine:
.1bb3	48		pha				pha
.1bb4	38		sec				sec 								; allocate 5 bytes (line #, page+address)
.1bb5	ad 0f 06	lda $060f			lda 	lineNumberTable 			; and copy to zTemp0
.1bb8	e9 05		sbc #$05			sbc 	#5
.1bba	8d 0f 06	sta $060f			sta 	lineNumberTable
.1bbd	85 2c		sta $2c				sta 	zTemp0
.1bbf	ad 10 06	lda $0610			lda 	lineNumberTable+1
.1bc2	e9 00		sbc #$00			sbc 	#0
.1bc4	8d 10 06	sta $0610			sta 	lineNumberTable+1
.1bc7	85 2d		sta $2d				sta 	zTemp0+1
.1bc9	68		pla				pla
.1bca	92 2c		sta ($2c)			sta 	(zTemp0) 					; save it in +0,+1
.1bcc	98		tya				tya
.1bcd	a0 01		ldy #$01			ldy 	#1
.1bcf	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1bd1	a5 2b		lda $2b				lda 	objPage 					; and page# in +2
.1bd3	c8		iny				iny
.1bd4	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1bd6	a5 29		lda $29				lda 	objPtr 						; save current address in +3,+4
.1bd8	c8		iny				iny
.1bd9	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1bdb	a5 2a		lda $2a				lda 	objPtr+1
.1bdd	c8		iny				iny
.1bde	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1be0	60		rts				rts
.1be1					STRFindLine:
.1be1	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.1be3	84 2d		sty $2d				sty 	zTemp0+1
.1be5	ad 08 06	lda $0608			lda 	compilerEndHigh 			; work backwards through table
.1be8	85 2f		sta $2f				sta 	zTemp1+1
.1bea	64 2e		stz $2e				stz 	zTemp1
.1bec					_STRSearch:
.1bec	20 27 1c	jsr $1c27			jsr 	_STRPrevLine 				; look at previous record.
.1bef	a0 01		ldy #$01			ldy 	#1
.1bf1	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.1bf3	c5 2c		cmp $2c				cmp 	zTemp0
.1bf5	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1bf7	e5 2d		sbc $2d				sbc 	zTemp0+1
.1bf9	b0 0b		bcs $1c06			bcs 	_STRFound 					; >=
.1bfb					_STRNext:
.1bfb	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.1bfd	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1bff	c9 ff		cmp #$ff			cmp 	#$FF
.1c01	d0 e9		bne $1bec			bne 	_STRSearch
.1c03	4c 87 1f	jmp $1f87		jmp	ErrorV_internal
.1c06					_STRFound:
.1c06	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.1c08	45 2c		eor $2c				eor 	zTemp0
.1c0a	d0 06		bne $1c12			bne 	_STRDifferent
.1c0c	b2 2e		lda ($2e)			lda 	(zTemp1)
.1c0e	45 2c		eor $2c				eor 	zTemp0
.1c10	f0 02		beq $1c14			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.1c12					_STRDifferent:
.1c12	a9 ff		lda #$ff			lda 	#$FF
.1c14					_STROut:
.1c14	18		clc				clc  								; set carry if different, e.g. > rather than >=
.1c15	69 ff		adc #$ff			adc 	#255
.1c17	08		php				php
.1c18	c8		iny				iny 								; page into X
.1c19	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1c1b	aa		tax				tax
.1c1c	c8		iny				iny 								; address into YA
.1c1d	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1c1f	48		pha				pha
.1c20	c8		iny				iny
.1c21	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1c23	a8		tay				tay
.1c24	68		pla				pla
.1c25	28		plp				plp
.1c26	60		rts				rts
.1c27					_STRPrevLine:
.1c27	38		sec				sec 								; move backwards one entry.
.1c28	a5 2e		lda $2e				lda 	zTemp1
.1c2a	e9 05		sbc #$05			sbc 	#5
.1c2c	85 2e		sta $2e				sta 	zTemp1
.1c2e	a5 2f		lda $2f				lda 	zTemp1+1
.1c30	e9 00		sbc #$00			sbc 	#0
.1c32	85 2f		sta $2f				sta 	zTemp1+1
.1c34	60		rts				rts
.1c35					STRMakeOffset:
.1c35	18		clc				clc 								; borrow 1
.1c36	e5 29		sbc $29				sbc 	objPtr
.1c38	48		pha				pha
.1c39	98		tya				tya
.1c3a	e5 2a		sbc $2a				sbc 	objPtr+1
.1c3c	a8		tay				tay
.1c3d	68		pla				pla
.1c3e	60		rts				rts
.1c3f					CommandNEXT:
.1c3f	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.1c42	20 4f 1a	jsr $1a4f			jsr 	CharIsAlpha 				; if not alpha , error
.1c45	90 0c		bcc $1c53			bcc 	_CNNoReferenceGiven
.1c47	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1c4a	20 8f 1d	jsr $1d8f			jsr 	GetReferenceTerm 			; figure out the reference.
.1c4d	8a		txa				txa 								; reference in YA
.1c4e	20 ca 11	jsr $11ca			jsr 	PushIntegerYA 				; write it out.
.1c51	80 06		bra $1c59			bra 	_CNParametersDone
.1c53					_CNNoReferenceGiven:
.1c53	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.1c55	a8		tay				tay
.1c56	20 ca 11	jsr $11ca			jsr 	PushIntegerYA 				; write it out.
.1c59					_CNParametersDone:
.1c59	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.1c5b	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1c5e	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; look for ,
.1c61	c9 2c		cmp #$2c			cmp 	#","
.1c63	d0 05		bne $1c6a			bne 	_CNExit
.1c65	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume ,
.1c68	80 d5		bra $1c3f			bra 	CommandNEXT 				; and go round.
.1c6a					_CNExit:
.1c6a	60		rts				rts
.1c6b					CommandON:
.1c6b	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.1c6e	48		pha				pha 								; save on stack
.1c6f	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.1c71	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.1c73	f0 09		beq $1c7e			beq 	_COCreateLoop
.1c75	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.1c77	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.1c79	f0 03		beq $1c7e			beq 	_COCreateLoop
.1c7b	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.1c7e					_COCreateLoop:
.1c7e	8a		txa				txa 								; compile a goto/gosub somewhere
.1c7f	da		phx				phx
.1c80	20 09 1b	jsr $1b09			jsr 	CompileBranchCommand
.1c83	fa		plx				plx
.1c84	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace			; ',' follows
.1c87	c9 2c		cmp #$2c			cmp 	#","
.1c89	d0 0a		bne $1c95			bne 	_COComplete 				; if so, more line numbers
.1c8b	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.1c8d	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1c90	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1c93	80 e9		bra $1c7e			bra 	_COCreateLoop
.1c95					_COComplete:
.1c95	68		pla				pla 								; throw GOTO/GOSUB
.1c96	60		rts				rts
.1c97					ParseConstant:
.1c97	a2 00		ldx #$00			ldx 	#0
.1c99	20 53 24	jsr $2453			jsr 	FloatEncodeStart 			; send first
.1c9c					_ParseLoop:
.1c9c	20 1d 1a	jsr $1a1d			jsr 	LookNext 					; send subsequent
.1c9f	20 56 24	jsr $2456			jsr 	FloatEncodeContinue
.1ca2	90 05		bcc $1ca9			bcc 	_ParseDone
.1ca4	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume it
.1ca7	80 f3		bra $1c9c			bra 	_ParseLoop
.1ca9					_ParseDone:
.1ca9	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.1cab	29 80		and #$80			and 	#$80
.1cad	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.1caf	15 56		ora $56,x			ora 	NSMantissa2,x
.1cb1	15 62		ora $62,x			ora 	NSMantissa3,x
.1cb3	18		clc				clc
.1cb4	d0 05		bne $1cbb			bne 	_ParseExit 					; exit with CC if need float to compile
.1cb6	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.1cb8	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.1cba	38		sec				sec
.1cbb					_ParseExit:
.1cbb	60		rts				rts
.1cbc					CommandPRINT:
.1cbc	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace			; what follows ?
.1cbf	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.1cc1	f0 1f		beq $1ce2			beq 	_CPCheckEnd
.1cc3	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.1cc5	f0 16		beq $1cdd			beq 	_CPTabCheckEnd
.1cc7	20 f9 1c	jsr $1cf9			jsr 	_CPAtEnd 					; check for : and EOL
.1cca	b0 22		bcs $1cee			bcs 	_CPExitCR 					; exit with CR
.1ccc	20 d0 13	jsr $13d0			jsr 	CompileExpressionAt0 		; so it is something to print
.1ccf	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.1cd1	29 40		and #$40			and 	#NSSString 					; if string
.1cd3	d0 02		bne $1cd7			bne 	_CPOut
.1cd5	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.1cd7					_CPOut:
.1cd7	8a		txa				txa 								; print that thing
.1cd8	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1cdb	80 df		bra $1cbc			bra 	CommandPRINT 				; and loop round/
.1cdd					_CPTabCheckEnd:
.1cdd	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.1cdf	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1ce2					_CPCheckEnd:
.1ce2	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume it.
.1ce5	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; what follows ?
.1ce8	20 f9 1c	jsr $1cf9			jsr 	_CPAtEnd 					; reached end
.1ceb	90 cf		bcc $1cbc			bcc 	CommandPRINT 				; no, loop back
.1ced	60		rts				rts
.1cee					_CPExitCR:
.1cee	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.1cf0	20 dd 11	jsr $11dd			jsr 	PushIntegerA
.1cf3	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.1cf5	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1cf8	60		rts				rts
.1cf9					_CPAtEnd:
.1cf9	c9 00		cmp #$00			cmp 	#0
.1cfb	f0 06		beq $1d03			beq 	_CPIsEnd
.1cfd	c9 3a		cmp #$3a			cmp 	#":"
.1cff	f0 02		beq $1d03			beq 	_CPIsEnd
.1d01	18		clc				clc
.1d02	60		rts				rts
.1d03					_CPIsEnd:
.1d03	38		sec				sec
.1d04	60		rts				rts
.1d05					CommandREAD:
.1d05	a2 b2		ldx #$b2			ldx 	#PCD_READ
.1d07	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.1d09					CommandReadInputCommon:
.1d09	8e 0d 06	stx $060d			stx 	numberPCode
.1d0c	8c 0e 06	sty $060e			sty 	stringPCode
.1d0f					_CRLoop:
.1d0f	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; first char of identifier
.1d12	20 4f 1a	jsr $1a4f			jsr 	CharIsAlpha 				; check A-Z
.1d15	90 27		bcc $1d3e			bcc 	_CRSyntax
.1d17	20 8f 1d	jsr $1d8f			jsr 	GetReferenceTerm 			; get the variable.
.1d1a	48		pha				pha 								; save type.
.1d1b	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.1d1d	c9 40		cmp #$40			cmp 	#NSSString
.1d1f	f0 05		beq $1d26			beq 	_CRString
.1d21	ad 0d 06	lda $060d			lda 	numberPCode 				; output read/input
.1d24	80 03		bra $1d29			bra 	_CRHaveType
.1d26					_CRString:
.1d26	ad 0e 06	lda $060e			lda 	stringPCode					; output read$/input$
.1d29					_CRHaveType:
.1d29	20 ec 10	jsr $10ec			jsr 	WriteCodeByte 				; so we have one typed data item.
.1d2c	68		pla				pla 								; restore type
.1d2d	38		sec				sec  								; write update code.
.1d2e	20 41 1d	jsr $1d41			jsr 	GetSetVariable
.1d31	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; , follows ?
.1d34	c9 2c		cmp #$2c			cmp 	#","
.1d36	d0 05		bne $1d3d			bne 	_CRExit 					; if not, end of READ.
.1d38	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume comma
.1d3b	80 d2		bra $1d0f			bra 	_CRLoop 					; keep going
.1d3d					_CRExit:
.1d3d	60		rts				rts
.1d3e					_CRSyntax:
.1d3e	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.060d					numberPCode:
>060d							.fill 	1
.060e					stringPCode:
>060e							.fill 	1
.1d41					GetSetVariable:
.1d41	08		php				php 								; save direction on stack
.1d42	c0 00		cpy #$00			cpy 	#$00
.1d44	30 21		bmi $1d67			bmi 	_GSVReadWriteSpecial
.1d46	c9 00		cmp #$00			cmp 	#$00
.1d48	30 33		bmi $1d7d			bmi 	_GSVArray
.1d4a	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.1d4c	4a		lsr a				lsr 	a 							; divide by 2
.1d4d	09 40		ora #$40			ora 	#64 						; and set bit 6.
.1d4f	28		plp				plp
.1d50	90 02		bcc $1d54			bcc 	_GSVNotWrite
.1d52	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.1d54					_GSVNotWrite:
.1d54	85 2c		sta $2c				sta 	zTemp0
.1d56	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.1d57	4a		lsr a				lsr 	a
.1d58	a8		tay				tay
.1d59	8a		txa				txa
.1d5a	6a		ror a				ror 	a
.1d5b	aa		tax				tax
.1d5c	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.1d5d	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.1d5f	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1d62	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.1d63	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1d66	60		rts				rts
.1d67					_GSVReadWriteSpecial:
.1d67	28		plp				plp
.1d68	b0 10		bcs $1d7a			bcs 	_GSVSyntax
.1d6a	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.1d6c	f0 06		beq $1d74			beq 	_GSVRWString
.1d6e	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.1d70	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1d73	60		rts				rts
.1d74					_GSVRWString:
.1d74	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.1d76	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1d79	60		rts				rts
.1d7a					_GSVSyntax:
.1d7a	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.1d7d					_GSVArray:
.1d7d	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.1d7f	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.1d80	4a		lsr a				lsr 	a
.1d81	4a		lsr a				lsr 	a
.1d82	4a		lsr a				lsr 	a
.1d83	4a		lsr a				lsr 	a
.1d84	28		plp				plp 								; if writing array then set bit 2.
.1d85	90 02		bcc $1d89			bcc 	_GSVANotWrite
.1d87	09 04		ora #$04			ora 	#4
.1d89					_GSVANotWrite:
.1d89	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.1d8b	20 ec 10	jsr $10ec			jsr 	WriteCodeByte 				; and write it out
.1d8e	60		rts				rts
.1d8f					GetReferenceTerm:
.1d8f	20 9e 1a	jsr $1a9e			jsr 	ExtractVariableName 		; get name & type info
.1d92	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.1d94	30 10		bmi $1da6			bmi 	_GRTArray
.1d96	da		phx				phx 								; save type on stack
.1d97	20 8a 14	jsr $148a			jsr 	FindVariable 				; find it
.1d9a	b0 06		bcs $1da2			bcs 	_GRTNoCreate 				; create if required.
.1d9c	20 0f 12	jsr $120f			jsr 	CreateVariableRecord 		; create a variable.
.1d9f	20 69 12	jsr $1269			jsr 	AllocateBytesForType 		; allocate memory for it
.1da2					_GRTNoCreate:
.1da2	68		pla				pla 								; get type back, strip out type information.
.1da3	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1da5	60		rts				rts
.1da6					_GRTArray:
.1da6	da		phx				phx 								; save type information
.1da7	20 8a 14	jsr $148a			jsr 	FindVariable 				; read its data, the base address in YX
.1daa	90 18		bcc $1dc4			bcc 	_GRTUndeclared 				; undeclared array.
.1dac	da		phx				phx 								; save base address
.1dad	5a		phy				phy
.1dae	20 60 13	jsr $1360			jsr 	OutputIndexGroup 			; create an index group and generate them
.1db1	7a		ply				ply 								; get the array base address into YX
.1db2	fa		plx				plx
.1db3	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1db5	18		clc				clc
.1db6	20 41 1d	jsr $1d41			jsr 	GetSetVariable 				; load the address of the array structure.
.1db9	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.1dbb	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1dbe	68		pla				pla 								; and the type data into A
.1dbf	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1dc1	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.1dc3	60		rts				rts
.1dc4					_GRTUndeclared:
.1dc4	4c e4 1f	jmp $1fe4		jmp	ErrorV_undeclared
.1dc7					CommandREM:
.1dc7	20 1d 1a	jsr $1a1d			jsr 	LookNext
.1dca	f0 05		beq $1dd1			beq 	_CRExit
.1dcc	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1dcf	80 f6		bra $1dc7			bra 	CommandREM
.1dd1					_CRExit:
.1dd1	60		rts				rts
.1dd2					STRReset:
.1dd2	ad 07 06	lda $0607			lda	 	compilerStartHigh 			; set up the two table pointers
.1dd5	8d 12 06	sta $0612			sta 	variableListEnd+1
.1dd8	9c 11 06	stz $0611			stz 	variableListEnd
.1ddb	ad 08 06	lda $0608			lda 	compilerEndHigh
.1dde	8d 10 06	sta $0610			sta 	lineNumberTable+1
.1de1	9c 0f 06	stz $060f			stz 	lineNumberTable
.1de4	ad 11 06	lda $0611			lda 	variableListEnd
.1de7	85 2d		sta $2d				sta 	zTemp0+1
.1de9	64 2c		stz $2c				stz 	zTemp0
.1deb	a9 00		lda #$00			lda 	#0
.1ded	92 2c		sta ($2c)			sta 	(zTemp0)
.1def	a9 00		lda #$00			lda 	#((0) & $FF)
.1df1	8d 13 06	sta $0613			sta 	0+freeVariableMemory
.1df4	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.1df6	8d 14 06	sta $0614			sta 	1+freeVariableMemory
.1df9	60		rts				rts
.060f					lineNumberTable:
>060f							.fill 	2
.0611					variableListEnd:
>0611							.fill 	2
.0613					freeVariableMemory:
>0613							.fill 	2
.1dfa					CompileTerm:
.1dfa	20 39 1a	jsr $1a39			jsr 	GetNextNonSpace 			; get first non space character.
.1dfd	30 72		bmi $1e71			bmi 	_CTUnaryFunctions
.1dff	20 43 1a	jsr $1a43			jsr 	CharIsDigit 				; found a number
.1e02	b0 3a		bcs $1e3e			bcs 	_CTDigit
.1e04	c9 2e		cmp #$2e			cmp 	#"."
.1e06	f0 36		beq $1e3e			beq 	_CTDigit
.1e08	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.1e0a	f0 43		beq $1e4f			beq 	_CTString
.1e0c	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.1e0e	f0 28		beq $1e38			beq 	_CTOtherBase
.1e10	c9 24		cmp #$24			cmp 	#"$"
.1e12	f0 24		beq $1e38			beq 	_CTOtherBase
.1e14	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.1e16	f0 17		beq $1e2f			beq 	_CTBrackets
.1e18	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.1e1a	90 10		bcc $1e2c			bcc 	_CTSyntax
.1e1c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1e1e	b0 0c		bcs $1e2c			bcs 	_CTSyntax
.1e20	20 8f 1d	jsr $1d8f			jsr 	GetReferenceTerm 			; figure out what it is.
.1e23	48		pha				pha 								; save type on stack
.1e24	18		clc				clc 								; read it
.1e25	20 41 1d	jsr $1d41			jsr 	GetSetVariable
.1e28	68		pla				pla
.1e29	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.1e2b	60		rts				rts
.1e2c					_CTSyntax:
.1e2c	4c 2d 1f	jmp $1f2d		jmp	ErrorV_syntax
.1e2f					_CTBrackets:
.1e2f	20 d0 13	jsr $13d0			jsr 	CompileExpressionAt0
.1e32	48		pha				pha
.1e33	20 2b 11	jsr $112b			jsr 	CheckNextRParen
.1e36	68		pla				pla
.1e37	60		rts				rts
.1e38					_CTOtherBase:
.1e38	20 9a 10	jsr $109a			jsr 	InlineNonDecimal 			; non decimal constant handler
.1e3b	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e3d	60		rts				rts
.1e3e					_CTDigit:
.1e3e	20 97 1c	jsr $1c97			jsr 	ParseConstant 				; parse out an number, first is in A already.
.1e41	90 06		bcc $1e49			bcc	 	_CTFloat 					; have a float or long int.
.1e43	20 ca 11	jsr $11ca			jsr 	PushIntegerYA 				; code to push on stack
.1e46	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.1e48	60		rts				rts
.1e49					_CTFloat:
.1e49	20 ec 11	jsr $11ec			jsr 	PushFloat  					; code to push float
.1e4c	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.1e4e	60		rts				rts
.1e4f					_CTString:
.1e4f	20 00 11	jsr $1100			jsr 	BufferClear 				; copy it to the buffer
.1e52					_CTStringLoop:
.1e52	20 1d 1a	jsr $1a1d			jsr 	LookNext 					; reached EOL/EOS
.1e55	f0 d5		beq $1e2c			beq 	_CTSyntax
.1e57	c9 22		cmp #$22			cmp 	#'"'
.1e59	f0 08		beq $1e63			beq 	_CTStringDone
.1e5b	20 04 11	jsr $1104			jsr 	BufferWrite 				; write and consume
.1e5e	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1e61	80 ef		bra $1e52			bra 	_CTStringLoop
.1e63					_CTStringDone:
.1e63	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume closing quote.
.1e66	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.1e68	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1e6b	20 10 11	jsr $1110			jsr 	BufferOutput
.1e6e	a9 40		lda #$40			lda 	#NSSString 					; string type
.1e70	60		rts				rts
.1e71					_CTUnaryFunctions:
.1e71	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.1e73	f0 0a		beq $1e7f			beq 	_CTNegation
.1e75	a2 c8		ldx #$c8			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.1e77	a0 17		ldy #$17			ldy 	#UnaryTables >> 8
.1e79	20 c2 18	jsr $18c2			jsr 	GeneratorProcess
.1e7c	90 ae		bcc $1e2c			bcc		_CTSyntax
.1e7e	60		rts				rts
.1e7f					_CTNegation:
.1e7f	20 fa 1d	jsr $1dfa			jsr 	CompileTerm 				; compile a term.
.1e82	48		pha				pha
.1e83	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.1e85	c9 00		cmp #$00			cmp 	#NSSIFloat
.1e87	d0 07		bne $1e90			bne 	_CTType 					; error
.1e89	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.1e8b	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1e8e	68		pla				pla 								; return original type.
.1e8f	60		rts				rts
.1e90					_CTType:
.1e90	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.1e93					CommandWAIT:
.1e93	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace
.1e96	c9 2c		cmp #$2c			cmp 	#","
.1e98	f0 10		beq $1eaa			beq 	_CWThirdParameter
.1e9a	a9 00		lda #$00			lda 	#0
.1e9c	20 dd 11	jsr $11dd			jsr 	PushIntegerA
.1e9f					_CWExit:
.1e9f	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.1ea1	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1ea4	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.1ea6	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1ea9	60		rts				rts
.1eaa					_CWThirdParameter:
.1eaa	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1ead	20 d2 13	jsr $13d2			jsr 	CompileExpressionAtA
.1eb0	29 40		and #$40			and 	#NSSTypeMask
.1eb2	c9 00		cmp #$00			cmp 	#NSSIFloat
.1eb4	f0 e9		beq $1e9f			beq 	_CWExit
.1eb6	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type
.1eb9					CommandCMD:
.1eb9	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.1ebb	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1ebe	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; followed by a , ?
.1ec1	c9 2c		cmp #$2c			cmp 	#","
.1ec3	d0 06		bne $1ecb			bne 	_CCMDExit
.1ec5	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume comma.
.1ec8	20 bc 1c	jsr $1cbc			jsr 	CommandPRINT 				; do the print code
.1ecb					_CCMDExit:
.1ecb	60		rts				rts
.1ecc					CommandOPEN:
.1ecc	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; followed by a , ?
.1ecf	c9 2c		cmp #$2c			cmp 	#","
.1ed1	d0 15		bne $1ee8			bne 	_COTwoDefaults
.1ed3	20 2e 1a	jsr $1a2e			jsr 	GetNext 					; consume comma
.1ed6	20 d0 13	jsr $13d0			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.1ed9	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.1edb	f0 1e		beq $1efb			beq 	_COThreeIntegers
.1edd	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.1edf	20 dd 11	jsr $11dd			jsr 	PushIntegerA
.1ee2	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1ee4	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1ee7	60		rts				rts
.1ee8					_COTwoDefaults:
.1ee8	a9 00		lda #$00			lda 	#0
.1eea	20 dd 11	jsr $11dd			jsr 	PushIntegerA
.1eed					_COCompileNullString:
.1eed	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.1eef	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1ef2	a9 00		lda #$00			lda 	#0
.1ef4	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1ef7	20 ec 10	jsr $10ec			jsr 	WriteCodeByte
.1efa	60		rts				rts
.1efb					_COThreeIntegers:
.1efb	20 20 1a	jsr $1a20			jsr 	LookNextNonSpace 			; is there a ,
.1efe	c9 2c		cmp #$2c			cmp 	#","
.1f00	d0 eb		bne $1eed			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.1f02	20 2e 1a	jsr $1a2e			jsr 	GetNext
.1f05	20 d0 13	jsr $13d0			jsr 	CompileExpressionAt0 		; should be a filename
.1f08	29 40		and #$40			and 	#NSSString
.1f0a	f0 01		beq $1f0d			beq 	_COType
.1f0c	60		rts				rts
.1f0d					_COType:
.1f0d	4c 3d 1f	jmp $1f3d		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0026					codePtr:
>0026							.fill 	2
.0028					codePage:
>0028							.fill 	1
.0029					objPtr:
>0029							.fill 	2
.002b					objPage:
>002b							.fill 	1
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1f10					ErrorV_range:
.1f10	20 88 13	jsr $1388		jsr	ErrorHandler
>1f13	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f1b	41 4e 47 45 00
.1f20					ErrorV_value:
.1f20	20 88 13	jsr $1388		jsr	ErrorHandler
>1f23	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f2b	45 00
.1f2d					ErrorV_syntax:
.1f2d	20 88 13	jsr $1388		jsr	ErrorHandler
>1f30	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f38	52 52 4f 52 00
.1f3d					ErrorV_type:
.1f3d	20 88 13	jsr $1388		jsr	ErrorHandler
>1f40	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f48	4d 41 54 43 48 00
.1f4e					ErrorV_unimplemented:
.1f4e	20 88 13	jsr $1388		jsr	ErrorHandler
>1f51	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f59	45 4d 45 4e 54 45 44 00
.1f61					ErrorV_assert:
.1f61	20 88 13	jsr $1388		jsr	ErrorHandler
>1f64	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f6c	41 49 4c 00
.1f70					ErrorV_line:
.1f70	20 88 13	jsr $1388		jsr	ErrorHandler
>1f73	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f7b	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f87					ErrorV_internal:
.1f87	20 88 13	jsr $1388		jsr	ErrorHandler
>1f8a	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f92	20 45 52 52 4f 52 00
.1f99					ErrorV_divzero:
.1f99	20 88 13	jsr $1388		jsr	ErrorHandler
>1f9c	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fa4	59 20 5a 45 52 4f 00
.1fab					ErrorV_structure:
.1fab	20 88 13	jsr $1388		jsr	ErrorHandler
>1fae	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fb6	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fc2					ErrorV_stop:
.1fc2	20 88 13	jsr $1388		jsr	ErrorHandler
>1fc5	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fcd	53 54 4f 50 50 45 44 00
.1fd5					ErrorV_data:
.1fd5	20 88 13	jsr $1388		jsr	ErrorHandler
>1fd8	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fe0	41 54 41 00
.1fe4					ErrorV_undeclared:
.1fe4	20 88 13	jsr $1388		jsr	ErrorHandler
>1fe7	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1fef	41 52 52 41 59 00
.1ff5					ErrorV_redefine:
.1ff5	20 88 13	jsr $1388		jsr	ErrorHandler
>1ff8	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>2000	44 45 46 49 4e 45 44 00
.2008					ErrorV_index:
.2008	20 88 13	jsr $1388		jsr	ErrorHandler
>200b	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2013	59 20 49 4e 44 45 58 00
.201b					ErrorV_memory:
.201b	20 88 13	jsr $1388		jsr	ErrorHandler
>201e	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2026	45 4d 4f 52 59 00
.202c					ErrorV_channel:
.202c	20 88 13	jsr $1388		jsr	ErrorHandler
>202f	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2037	54 50 55 54 20 45 52 52 4f 52 00
.2042					MoveObjectForward:
.2042	b2 29		lda ($29)			lda 	(objPtr) 					; get next
.2044	c9 ff		cmp #$ff			cmp 	#$FF
.2046	f0 36		beq $207e			beq 	_MOFEnd
.2048	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.204a	90 24		bcc $2070			bcc 	_MOFAdvance1 				; forward 1
.204c	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.204e	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2050	90 20		bcc $2072			bcc 	_MOFAdvanceY
.2052	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2054	90 1a		bcc $2070			bcc 	_MOFAdvance1 				; forward 1
.2056	a8		tay				tay 								; read the size.
.2057	b9 bc 1f	lda $1fbc,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.205a	a8		tay				tay
.205b	c8		iny				iny 								; add 1 for the system token.
.205c	d0 14		bne $2072			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.205e	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2060	b1 29		lda ($29),y			lda 	(objPtr),y
.2062	a8		tay				tay 								; into Y.
.2063	18		clc				clc
.2064	a5 29		lda $29				lda 	objPtr						; add 2 to the object pointer
.2066	69 02		adc #$02			adc 	#2
.2068	85 29		sta $29				sta 	objPtr
.206a	90 02		bcc $206e			bcc 	_MOFNoCarry1
.206c	e6 2a		inc $2a				inc 	objPtr+1
.206e					_MOFNoCarry1:
.206e	80 02		bra $2072			bra 	_MOFAdvanceY
.2070					_MOFAdvance1:
.2070	a0 01		ldy #$01			ldy 	#1
.2072					_MOFAdvanceY:
.2072	98		tya				tya 								; add X to objPtr
.2073	18		clc				clc
.2074	65 29		adc $29				adc 	objPtr
.2076	85 29		sta $29				sta 	objPtr
.2078	90 02		bcc $207c			bcc 	_MOFNoCarry2
.207a	e6 2a		inc $2a				inc 	objPtr+1
.207c					_MOFNoCarry2:
.207c	18		clc				clc 								; not completed.
.207d	60		rts				rts
.207e					_MOFEnd:
.207e	e6 29		inc $29				inc 	objPtr
.2080	d0 02		bne $2084			bne 	_MOFENoCarry
.2082	e6 2a		inc $2a				inc 	objPtr+1
.2084					_MOFENoCarry:
.2084	38		sec				sec
.2085	60		rts				rts
.2086					MOFSizeTable:
>2086	01					.byte	1         	; $ca .shift
>2087	01					.byte	1         	; $cb .byte
>2088	02					.byte	2         	; $cc .word
>2089	05					.byte	5         	; $cd .float
>208a	ff					.byte	255       	; $ce .string
>208b	ff					.byte	255       	; $cf .data
>208c	03					.byte	3         	; $d0 .goto
>208d	03					.byte	3         	; $d1 .gosub
>208e	03					.byte	3         	; $d2 .goto.z
>208f	03					.byte	3         	; $d3 .goto.nz
>2090	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0615					numberBuffer:
>0615							.fill 	34
.2091					FloatSubtract:
.2091	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.2093	49 80		eor #$80			eor 	#$80
.2095	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.2097					FloatAdd:
.2097	ca		dex				dex
.2098	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.209a	15 6f		ora $6f,x			ora 	NSExponent+1,x
.209c	15 62		ora $62,x			ora 	NSMantissa3,x
.209e	15 63		ora $63,x			ora 	NSMantissa3+1,x
.20a0	d0 04		bne $20a6			bne 	_FAUseFloat
.20a2	20 33 24	jsr $2433			jsr 	FloatInt32Add 				; use the int32 one.
.20a5	60		rts				rts
.20a6					_FAUseFloat:
.20a6	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise S[X]
.20a9	f0 51		beq $20fc			beq 	_FAReturn1
.20ab	e8		inx				inx 								; normalise S[X+1]
.20ac	20 c8 23	jsr $23c8			jsr 	FloatNormalise
.20af	ca		dex				dex
.20b0	c9 00		cmp #$00			cmp 	#0
.20b2	f0 60		beq $2114			beq 	_FAExit 					; if so, just return A
.20b4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20b6	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20b8	f0 18		beq $20d2			beq 	_FAExponentsEqual
.20ba	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20bc	a8		tay				tay
.20bd	38		sec				sec 								; do a signed comparison of the exponents.
.20be	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20c0	50 02		bvc $20c4			bvc 	_FANoSignedChange
.20c2	49 80		eor #$80			eor 	#$80
.20c4					_FANoSignedChange:
.20c4	29 80		and #$80			and 	#$80
.20c6	10 02		bpl $20ca			bpl 	_FAHaveMax
.20c8	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.20ca					_FAHaveMax:
.20ca	20 15 21	jsr $2115			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20cd	e8		inx				inx
.20ce	20 15 21	jsr $2115			jsr 	_FAShiftToExponent
.20d1	ca		dex				dex
.20d2					_FAExponentsEqual:
.20d2	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.20d4	55 33		eor $33,x			eor 	NSStatus+1,x
.20d6	30 0e		bmi $20e6			bmi 	_FADifferentSigns
.20d8	20 ff 23	jsr $23ff			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20db	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20dd	10 35		bpl $2114			bpl 	_FAExit 					; if no, we are done.
.20df	20 8c 26	jsr $268c			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20e2	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.20e4	80 2e		bra $2114			bra 	_FAExit
.20e6					_FADifferentSigns:
.20e6	20 19 24	jsr $2419			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20e9	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.20eb	10 06		bpl $20f3			bpl 	_FACheckZero 				; if no, check for -0
.20ed	20 35 26	jsr $2635			jsr 	FloatNegate 					; netate result
.20f0	20 3c 26	jsr $263c			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20f3					_FACheckZero:
.20f3	20 95 26	jsr $2695			jsr 	FloatIsZero	 				; check for -0
.20f6	d0 1c		bne $2114			bne 	_FAExit
.20f8	74 32		stz $32,x			stz 	NSStatus,x
.20fa	80 18		bra $2114			bra 	_FAExit
.20fc					_FAReturn1:
.20fc	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20fe	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2100	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2102	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2104	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.2106	95 56		sta $56,x			sta 	NSMantissa2,x
.2108	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.210a	95 62		sta $62,x			sta 	NSMantissa3,x
.210c	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.210e	95 6e		sta $6e,x			sta 	NSExponent,x
.2110	b5 33		lda $33,x			lda 	NSStatus+1,x
.2112	95 32		sta $32,x			sta 	NSStatus,x
.2114					_FAExit:
.2114	60		rts				rts
.2115					_FAShiftToExponent:
.2115					_FAShiftToExponent2:
.2115	98		tya				tya 								; compare Y to exponent
.2116	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2118	f0 07		beq $2121			beq 	_FASEExit 					; exit if so.
.211a	20 8c 26	jsr $268c			jsr 	FloatShiftRight	 			; shift the mantissa right
.211d	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.211f	80 f4		bra $2115			bra 	_FAShiftToExponent2
.2121					_FASEExit:
.2121	60		rts				rts
.2122					CompareEqual:
.2122	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2124	d0 09		bne $212f			bne 	ReturnFalse
.2126					ReturnTrue:
.2126	a9 01		lda #$01			lda 	#1
.2128	95 3e		sta $3e,x			sta 	NSMantissa0,x
.212a	a9 80		lda #$80			lda 	#$80
.212c	95 32		sta $32,x			sta 	NSStatus,x
.212e	60		rts				rts
.212f					ReturnFalse:
.212f	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2131	60		rts				rts
.2132					CompareNotEqual:
.2132	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2134	d0 f0		bne $2126			bne 	ReturnTrue
.2136	80 f7		bra $212f			bra 	ReturnFalse
.2138					CompareLess:
.2138	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.213a	c9 ff		cmp #$ff			cmp 	#$FF
.213c	f0 e8		beq $2126			beq 	ReturnTrue
.213e	80 ef		bra $212f			bra 	ReturnFalse
.2140					CompareGreater:
.2140	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2142	c9 01		cmp #$01			cmp 	#$01
.2144	f0 e0		beq $2126			beq 	ReturnTrue
.2146	80 e7		bra $212f			bra 	ReturnFalse
.2148					CompareLessEqual:
.2148	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.214a	c9 01		cmp #$01			cmp 	#$01
.214c	d0 d8		bne $2126			bne 	ReturnTrue
.214e	80 df		bra $212f			bra 	ReturnFalse
.2150					CompareGreaterEqual:
.2150	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2152	c9 ff		cmp #$ff			cmp 	#$FF
.2154	d0 d0		bne $2126			bne 	ReturnTrue
.2156	80 d7		bra $212f			bra 	ReturnFalse
.2158					FloatCompare:
.2158	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.215a	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.215c	48		pha				pha
.215d	20 91 20	jsr $2091			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2160	68		pla				pla
.2161	d0 0c		bne $216f			bne 	_FCCompareFloat
.2163	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2165	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2167	15 56		ora $56,x			ora 	NSMantissa2,x
.2169	15 62		ora $62,x			ora 	NSMantissa3,x
.216b	f0 14		beq $2181			beq 	_FCExit 					; if zero, return zero
.216d	80 0a		bra $2179			bra 	_FCSign
.216f					_FCCompareFloat:
.216f	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2171	29 f0		and #$f0			and 	#$F0
.2173	15 56		ora $56,x			ora 	NSMantissa2,x
.2175	15 62		ora $62,x			ora 	NSMantissa3,x
.2177	f0 08		beq $2181			beq 	_FCExit 					; zero, so approximately identical
.2179					_FCSign:
.2179	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.217b	34 32		bit $32,x			bit 	NSStatus,x
.217d	10 02		bpl $2181			bpl 	_FCExit
.217f					_FCNegative:
.217f	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2181					_FCExit:
.2181	20 75 26	jsr $2675			jsr 	FloatSetByte 				; set the result 255,0,1
.2184	60		rts				rts
.2185					FloatScalarTable:
>2185	66 66 66 66				.dword $66666666 ; 0.1
>2189	de					.byte $de
>218a	1f 85 eb 51				.dword $51eb851f ; 0.01
>218e	db					.byte $db
>218f	4c 37 89 41				.dword $4189374c ; 0.001
>2193	d8					.byte $d8
>2194	ac 8b db 68				.dword $68db8bac ; 0.0001
>2198	d4					.byte $d4
>2199	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>219d	d1					.byte $d1
>219e	83 de 1b 43				.dword $431bde83 ; 1e-06
>21a2	ce					.byte $ce
>21a3	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21a7	ca					.byte $ca
>21a8	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21ac	c7					.byte $c7
>21ad	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21b1	c4					.byte $c4
>21b2	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21b6	c0					.byte $c0
>21b7	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21bb	bd					.byte $bd
.21bc					FloatDivide:
.21bc	48		pha				pha
.21bd	20 c8 23	jsr $23c8			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21c0	ca		dex				dex
.21c1	c9 00		cmp #$00			cmp 	#0
.21c3	f0 1e		beq $21e3			beq 	_FDZero
.21c5	20 c8 23	jsr $23c8			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21c8	f0 16		beq $21e0			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21ca	20 2b 22	jsr $222b			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21cd	20 f8 21	jsr $21f8			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21d0	20 c8 23	jsr $23c8			jsr		FloatNormalise 				; renormalise
.21d3	20 be 23	jsr $23be			jsr 	FloatCalculateSign 			; calculate result sign
.21d6	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.21d8	38		sec				sec
.21d9	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.21db	38		sec				sec
.21dc	e9 1e		sbc #$1e			sbc 	#30
.21de	95 6e		sta $6e,x			sta 	NSExponent,x
.21e0					_FDExit:
.21e0	68		pla				pla
.21e1	18		clc				clc
.21e2	60		rts				rts
.21e3					_FDZero:
.21e3	68		pla				pla
.21e4	38		sec				sec
.21e5	60		rts				rts
.21e6					DivideInt32:
.21e6	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart 			; make both integers
.21e9	ca		dex				dex
.21ea	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.21ed	20 09 22	jsr $2209			jsr 	Int32Divide 				; divide
.21f0	20 f8 21	jsr $21f8			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21f3	20 be 23	jsr $23be			jsr 	FloatCalculateSign 			; calculate result sign
.21f6	18		clc				clc
.21f7	60		rts				rts
.21f8					NSMCopyPlusTwoToZero:
.21f8	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21fa	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21fc	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21fe	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2200	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.2202	95 56		sta $56,x			sta 	NSMantissa2,x
.2204	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.2206	95 62		sta $62,x			sta 	NSMantissa3,x
.2208	60		rts				rts
.2209					Int32Divide:
.2209	48		pha				pha 								; save AXY
.220a	5a		phy				phy
.220b	20 56 26	jsr $2656			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.220e	20 6f 26	jsr $266f			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2211	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2213					_I32DivideLoop:
.2213	e8		inx				inx
.2214	e8		inx				inx
.2215	20 82 26	jsr $2682			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2218	ca		dex				dex
.2219	ca		dex				dex
.221a	20 83 26	jsr $2683			jsr 	FloatRotateLeft
.221d	20 49 22	jsr $2249			jsr 	FloatDivideCheck 			; check if subtract possible
.2220	90 02		bcc $2224			bcc 	_I32DivideNoCarryIn
.2222	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2224					_I32DivideNoCarryIn:
.2224	88		dey				dey 								; loop round till division completed.
.2225	d0 ec		bne $2213			bne 	_I32DivideLoop
.2227	7a		ply				ply 								; restore AXY and exit
.2228	68		pla				pla
.2229	18		clc				clc
.222a	60		rts				rts
.222b					Int32ShiftDivide:
.222b	48		pha				pha 								; save AY
.222c	5a		phy				phy
.222d	e8		inx				inx 								; clear S[X+2]
.222e	e8		inx				inx
.222f	20 73 26	jsr $2673			jsr 	FloatSetZero
.2232	ca		dex				dex
.2233	ca		dex				dex
.2234	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2236					_I32SDLoop:
.2236	20 49 22	jsr $2249			jsr 	FloatDivideCheck 			; check if subtract possible
.2239	e8		inx				inx
.223a	e8		inx				inx
.223b	20 83 26	jsr $2683			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.223e	ca		dex				dex
.223f	ca		dex				dex
.2240	20 83 26	jsr $2683			jsr 	FloatRotateLeft
.2243	88		dey				dey 	 							; do 31 times
.2244	d0 f0		bne $2236			bne 	_I32SDLoop
.2246	7a		ply				ply 								; restore AY and exit
.2247	68		pla				pla
.2248	60		rts				rts
.2249					FloatDivideCheck:
.2249	20 19 24	jsr $2419			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.224c	b0 04		bcs $2252			bcs 	_DCSExit 					; if carry set, then could do, exit
.224e	20 ff 23	jsr $23ff			jsr 	FloatAddTopTwoStack 		; add it back in
.2251	18		clc				clc 								; and return False
.2252					_DCSExit:
.2252	60		rts				rts
.2253					FloatFractionalPart:
.2253	5a		phy				phy
.2254	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.2256	29 7f		and #$7f			and 	#$7F
.2258	95 32		sta $32,x			sta 	NSStatus,x
.225a	20 c8 23	jsr $23c8			jsr 	FloatNormalise
.225d	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.225f	38		sec				sec
.2260	e9 e0		sbc #$e0			sbc 	#$E0
.2262	90 29		bcc $228d			bcc 	_FFPExit 					; already fractional
.2264	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2266	b0 22		bcs $228a			bcs 	_FFPZero
.2268	a8		tay				tay 								; put count to do in Y
.2269	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.226b	20 92 22	jsr $2292			jsr 	_FFPPartial
.226e	95 62		sta $62,x			sta 	NSMantissa3,x
.2270	b5 56		lda $56,x			lda 	NSMantissa2,x
.2272	20 92 22	jsr $2292			jsr 	_FFPPartial
.2275	95 56		sta $56,x			sta 	NSMantissa2,x
.2277	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2279	20 92 22	jsr $2292			jsr 	_FFPPartial
.227c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.227e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2280	20 92 22	jsr $2292			jsr 	_FFPPartial
.2283	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2285	20 95 26	jsr $2695			jsr 	FloatIsZero 					; zeroed check.
.2288	d0 03		bne $228d			bne 	_FFPExit
.228a					_FFPZero:
.228a	20 73 26	jsr $2673			jsr 	FloatSetZero
.228d					_FFPExit:
.228d	20 c8 23	jsr $23c8			jsr 	FloatNormalise
.2290	7a		ply				ply
.2291	60		rts				rts
.2292					_FFPPartial:
.2292	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2294	f0 17		beq $22ad			beq 	_FFFPPExit
.2296	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.2298	b0 0c		bcs $22a6			bcs 	_FFFPPWholeByte
.229a	5a		phy				phy
.229b					_FFFPPLeft:
.229b	0a		asl a				asl 	a
.229c	88		dey				dey
.229d	d0 fc		bne $229b			bne 	_FFFPPLeft
.229f	7a		ply				ply
.22a0					_FFFPPRight:
.22a0	4a		lsr a				lsr 	a
.22a1	88		dey				dey
.22a2	d0 fc		bne $22a0			bne 	_FFFPPRight
.22a4	80 07		bra $22ad			bra 	_FFFPPExit
.22a6					_FFFPPWholeByte:
.22a6	98		tya				tya 								; subtract 8 from count
.22a7	38		sec				sec
.22a8	e9 08		sbc #$08			sbc 	#8
.22aa	a8		tay				tay
.22ab	a9 00		lda #$00			lda 	#0 							; and clear all
.22ad					_FFFPPExit:
.22ad	60		rts				rts
.22ae					FloatIntegerPart:
.22ae	48		pha				pha
.22af	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22b1	f0 1d		beq $22d0			beq 	_FIPExit 					; if so do nothing
.22b3	20 95 26	jsr $2695			jsr 	FloatIsZero 				; is it zero ?
.22b6	f0 15		beq $22cd			beq 	_FIPZero 					; if so return zero.
.22b8	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise
.22bb	f0 10		beq $22cd			beq 	_FIPZero 					; normalised to zero, exit zero
.22bd					_FIPShift:
.22bd	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22bf	10 07		bpl $22c8			bpl 	_FIPCheckZero
.22c1	20 8c 26	jsr $268c			jsr 	FloatShiftRight 			; shift mantissa right
.22c4	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22c6	80 f5		bra $22bd			bra 	_FIPShift
.22c8					_FIPCheckZero:
.22c8	20 95 26	jsr $2695			jsr 	FloatIsZero 				; avoid -0 problem
.22cb	d0 03		bne $22d0			bne 	_FIPExit 					; set to zero if mantissa zero.
.22cd					_FIPZero:
.22cd	20 73 26	jsr $2673			jsr 	FloatSetZero
.22d0					_FIPExit:
.22d0	68		pla				pla
.22d1	60		rts				rts
.22d2					FloatIntegerPartDown:
.22d2	48		pha				pha
.22d3	5a		phy				phy
.22d4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22d6	f0 36		beq $230e			beq 	_FIPExit 					; if so do nothing
.22d8	20 95 26	jsr $2695			jsr 	FloatIsZero 				; is it zero ?
.22db	f0 2e		beq $230b			beq 	_FIPZero 					; if so return zero.
.22dd	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise
.22e0	f0 29		beq $230b			beq 	_FIPZero 					; normalised to zero, exit zero
.22e2	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22e4					_FIPShift:
.22e4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22e6	10 0a		bpl $22f2			bpl 	_FIPCheckDown
.22e8	20 8c 26	jsr $268c			jsr 	FloatShiftRight 			; shift mantissa right
.22eb	90 01		bcc $22ee			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22ed	c8		iny				iny
.22ee					_FIPNoFrac:
.22ee	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22f0	80 f2		bra $22e4			bra 	_FIPShift
.22f2					_FIPCheckDown:
.22f2	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22f4	f0 10		beq $2306			beq 	_FIPCheckZero
.22f6	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22f8	10 0c		bpl $2306			bpl 	_FIPCheckZero
.22fa	e8		inx				inx 								; -ve so round *down*.
.22fb	a9 01		lda #$01			lda 	#1
.22fd	20 75 26	jsr $2675			jsr 	FloatSetByte
.2300	20 35 26	jsr $2635			jsr 	FloatNegate
.2303	20 97 20	jsr $2097			jsr 	FloatAdd
.2306					_FIPCheckZero:
.2306	20 95 26	jsr $2695			jsr 	FloatIsZero 				; avoid -0 problem
.2309	d0 03		bne $230e			bne 	_FIPExit 					; set to zero if mantissa zero.
.230b					_FIPZero:
.230b	20 73 26	jsr $2673			jsr 	FloatSetZero
.230e					_FIPExit:
.230e	7a		ply				ply
.230f	68		pla				pla
.2310	60		rts				rts
.2311					FloatInt8Multiply:
.2311	5a		phy				phy
.2312	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2314	a8		tay				tay
.2315	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2317					_FI8MLoop:
.2317	98		tya				tya 								; shift right shifter right into carry
.2318	4a		lsr a				lsr 	a
.2319	a8		tay				tay
.231a	90 0d		bcc $2329			bcc 	_FI8MNoAdd
.231c	18		clc				clc
.231d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.231f	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.2321	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2323	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2325	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.2327	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2329					_FI8MNoAdd:
.2329	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.232b	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.232d	c0 00		cpy #$00			cpy 	#0
.232f	d0 e6		bne $2317			bne 	_FI8MLoop 					; until right shifter zero.
.2331	7a		ply				ply
.2332	60		rts				rts
.2333					FloatMultiply:
.2333	ca		dex				dex
.2334	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.2336	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2338	15 62		ora $62,x			ora 	NSMantissa3,x
.233a	15 63		ora $63,x			ora 	NSMantissa3+1,x
.233c	d0 21		bne $235f			bne 	_FMUseFloat
.233e	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2340	15 33		ora $33,x			ora 	NSStatus+1,x
.2342	29 80		and #$80			and 	#$80
.2344	15 62		ora $62,x			ora 	NSMantissa3,x
.2346	15 56		ora $56,x			ora 	NSMantissa2,x
.2348	15 4a		ora $4a,x			ora 	NSMantissa1,x
.234a	15 63		ora $63,x			ora 	NSMantissa3+1,x
.234c	15 57		ora $57,x			ora 	NSMantissa2+1,x
.234e	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2350	d0 04		bne $2356			bne 	_FMInt32
.2352	20 11 23	jsr $2311			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2355	60		rts				rts
.2356					_FMInt32:
.2356	20 80 23	jsr $2380			jsr 	FloatMultiplyShort			; use the int32 one.
.2359	18		clc				clc 								; fix it up if gone out of range
.235a	75 6e		adc $6e,x			adc 	NSExponent,x
.235c	95 6e		sta $6e,x			sta 	NSExponent,x
.235e	60		rts				rts
.235f					_FMUseFloat:
.235f	20 c8 23	jsr $23c8			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2362	f0 18		beq $237c			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2364	e8		inx				inx
.2365	20 c8 23	jsr $23c8			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2368	ca		dex				dex
.2369	c9 00		cmp #$00			cmp 	#0
.236b	f0 0c		beq $2379			beq 	_FDSetZero
.236d	20 80 23	jsr $2380			jsr 	FloatMultiplyShort 			; calculate the result.
.2370	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2372	18		clc				clc
.2373	75 6f		adc $6f,x			adc 	NSExponent+1,x
.2375	95 6e		sta $6e,x			sta 	NSExponent,x
.2377	80 03		bra $237c			bra 	_FDExit
.2379					_FDSetZero:
.2379	20 73 26	jsr $2673			jsr 	FloatSetZero 				; return 0
.237c					_FDExit:
.237c	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise the result
.237f	60		rts				rts
.2380					FloatMultiplyShort:
.2380	5a		phy				phy 								; save Y
.2381	20 56 26	jsr $2656			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2384	20 6f 26	jsr $266f			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2387	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2389					_I32MLoop:
.2389	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.238b	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.238d	15 58		ora $58,x			ora 	NSMantissa2+2,x
.238f	15 64		ora $64,x			ora 	NSMantissa3+2,x
.2391	f0 25		beq $23b8			beq 	_I32MExit 					; exit if zero
.2393	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2395	29 01		and #$01			and 	#1
.2397	f0 0d		beq $23a6			beq 	_I32MNoAdd
.2399	20 ff 23	jsr $23ff			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.239c	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.239e	10 06		bpl $23a6			bpl 	_I32MNoAdd
.23a0					_I32ShiftRight:
.23a0	20 8c 26	jsr $268c			jsr 	FloatShiftRight 			; shift S[X] right
.23a3	c8		iny				iny 								; increment shift count
.23a4	80 09		bra $23af			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23a6					_I32MNoAdd:
.23a6	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23a8	70 f6		bvs $23a0			bvs 	_I32ShiftRight 				; instead.
.23aa	e8		inx				inx
.23ab	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23ae	ca		dex				dex
.23af					_I32MShiftUpper:
.23af	e8		inx				inx 								; shift S[X+2] right
.23b0	e8		inx				inx
.23b1	20 8c 26	jsr $268c			jsr 	FloatShiftRight
.23b4	ca		dex				dex
.23b5	ca		dex				dex
.23b6	80 d1		bra $2389			bra 	_I32MLoop 					; try again.
.23b8					_I32MExit:
.23b8	20 be 23	jsr $23be			jsr 	FloatCalculateSign
.23bb	98		tya				tya 								; shift in A
.23bc	7a		ply				ply 								; restore Y and exit
.23bd	60		rts				rts
.23be					FloatCalculateSign:
.23be	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23c0	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23c2	55 33		eor $33,x			eor 	NSStatus+1,x
.23c4	0a		asl a				asl 	a 							; shift bit 7 into carry
.23c5	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23c7	60		rts				rts
.23c8					FloatNormalise:
.23c8	20 95 26	jsr $2695			jsr 	FloatIsZero 				; if zero exit
.23cb	d0 07		bne $23d4			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23cd	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.23cf	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.23d1	a9 00		lda #$00			lda 	#0 							; set Z flag
.23d3	60		rts				rts
.23d4					_NSNormaliseOptimise:
.23d4	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23d6	d0 19		bne $23f1			bne 	_NSNormaliseLoop
.23d8	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.23da	30 15		bmi $23f1			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23dc	95 62		sta $62,x			sta 	NSMantissa3,x
.23de	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.23e0	95 56		sta $56,x			sta 	NSMantissa2,x
.23e2	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.23e4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23e6	74 3e		stz $3e,x			stz 	NSMantissa0,x
.23e8	b5 6e		lda $6e,x			lda 	NSExponent,x
.23ea	38		sec				sec
.23eb	e9 08		sbc #$08			sbc 	#8
.23ed	95 6e		sta $6e,x			sta 	NSExponent,x
.23ef	80 e3		bra $23d4			bra 	_NSNormaliseOptimise
.23f1					_NSNormaliseLoop:
.23f1	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23f3	70 07		bvs $23fc			bvs 	_NSNExit 					; exit if so with Z flag clear
.23f5	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; shift mantissa left
.23f8	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23fa	80 f5		bra $23f1			bra 	_NSNormaliseLoop
.23fc					_NSNExit:
.23fc	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23fe	60		rts				rts
.23ff					FloatAddTopTwoStack:
.23ff	18		clc				clc
.2400	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2402	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.2404	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2406	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2408	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.240a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.240c	b5 56		lda $56,x			lda		NSMantissa2,x
.240e	75 57		adc $57,x			adc 		NSMantissa2+1,x
.2410	95 56		sta $56,x			sta 	NSMantissa2,x
.2412	b5 62		lda $62,x			lda		NSMantissa3,x
.2414	75 63		adc $63,x			adc 		NSMantissa3+1,x
.2416	95 62		sta $62,x			sta 	NSMantissa3,x
.2418	60		rts				rts
.2419					FloatSubTopTwoStack:
.2419	38		sec				sec
.241a	b5 3e		lda $3e,x			lda		NSMantissa0,x
.241c	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.241e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2420	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2422	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.2424	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2426	b5 56		lda $56,x			lda		NSMantissa2,x
.2428	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.242a	95 56		sta $56,x			sta 	NSMantissa2,x
.242c	b5 62		lda $62,x			lda		NSMantissa3,x
.242e	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.2430	95 62		sta $62,x			sta 	NSMantissa3,x
.2432	60		rts				rts
.2433					FloatInt32Add:
.2433	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2435	55 33		eor $33,x			eor 	NSStatus+1,x
.2437	30 04		bmi $243d			bmi 	_DiffSigns
.2439	20 ff 23	jsr $23ff			jsr		FloatAddTopTwoStack
.243c	60		rts				rts
.243d					_DiffSigns:
.243d	20 19 24	jsr $2419			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2440	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2442	10 07		bpl $244b			bpl 	_AddExit
.2444	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2446	95 32		sta $32,x			sta 	NSStatus,x
.2448	20 3c 26	jsr $263c			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.244b					_AddExit:
.244b	20 95 26	jsr $2695			jsr 	FloatIsZero 				; check for -0
.244e	d0 02		bne $2452			bne 	_AddNonZero
.2450	74 32		stz $32,x			stz 	NSStatus,x
.2452					_AddNonZero:
.2452	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2453					FloatEncodeStart:
.2453	38		sec				sec
.2454	80 01		bra $2457			bra 	FloatEncodeContinue+1
.2456					FloatEncodeContinue:
.2456	18		clc				clc
.2457					FloatEncode:
.2457	08		php				php 								; save reset flag.
.2458	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.245a	f0 15		beq $2471			beq 	_ENIsOkay
.245c	c9 30		cmp #$30			cmp 	#"0"
.245e	90 04		bcc $2464			bcc 	_ENBadNumber
.2460	c9 3a		cmp #$3a			cmp 	#"9"+1
.2462	90 0d		bcc $2471			bcc 	_ENIsOkay
.2464					_ENBadNumber:
.2464	28		plp				plp 								; throw saved reset
.2465	ad 37 06	lda $0637			lda 	encodeState 				; if in decimal mode, construct final number
.2468	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.246a	d0 03		bne $246f			bne 	_ENFail
.246c	4c e9 24	jmp $24e9			jmp 	_ENConstructFinal
.246f					_ENFail:
.246f	18		clc				clc 								; not allowed
.2470	60		rts				rts
.2471					_ENIsOkay:
.2471	28		plp				plp 								; are we restarting
.2472	90 15		bcc $2489			bcc 	_ENNoRestart
.2474					_ENStartEncode:
.2474	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2476	f0 0c		beq $2484			beq 	_ENFirstDP
.2478	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.247a	20 75 26	jsr $2675			jsr 	FloatSetByte 				; in single byte mode.
.247d	a9 01		lda #$01			lda 	#ESTA_Low
.247f					_ENExitChange:
.247f	8d 37 06	sta $0637			sta 	encodeState 				; save new state
.2482	38		sec				sec
.2483	60		rts				rts
.2484					_ENFirstDP:
.2484	20 73 26	jsr $2673			jsr 	FloatSetZero 				; clear integer part
.2487	80 3c		bra $24c5			bra 	_ESTASwitchFloat			; go straight to float and exi
.2489					_ENNoRestart:
.2489	48		pha				pha 								; save digit or DP on stack.
.248a	ad 37 06	lda $0637			lda 	encodeState 				; get current state
.248d	c9 01		cmp #$01			cmp 	#ESTA_Low
.248f	f0 09		beq $249a			beq  	_ESTALowState
.2491	c9 02		cmp #$02			cmp 	#ESTA_High
.2493	f0 26		beq $24bb			beq 	_ESTAHighState
.2495	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2497	f0 38		beq $24d1			beq 	_ESTADecimalState
>2499	db						.byte 	$DB 						; causes a break in the emulator
.249a					_ESTALowState:
.249a	68		pla				pla 								; get value back
.249b	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.249d	f0 26		beq $24c5			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.249f	29 0f		and #$0f			and 	#15 						; make digit
.24a1	8d 38 06	sta $0638			sta 	digitTemp 					; save it.
.24a4	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24a6	0a		asl a				asl 	a
.24a7	0a		asl a				asl 	a
.24a8	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24aa	0a		asl a				asl 	a
.24ab	6d 38 06	adc $0638			adc 	digitTemp
.24ae	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24b0	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24b2	90 05		bcc $24b9			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24b4	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24b6	8d 37 06	sta $0637			sta 	encodeState
.24b9					_ESTANoSwitch:
.24b9	38		sec				sec
.24ba	60		rts				rts
.24bb					_ESTAHighState:
.24bb	68		pla				pla 								; get value back
.24bc	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24be	f0 05		beq $24c5			beq 	_ESTASwitchFloat
.24c0	20 1b 25	jsr $251b			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24c3	38		sec				sec
.24c4	60		rts				rts
.24c5					_ESTASwitchFloat:
.24c5	9c 39 06	stz $0639			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24c8	e8		inx				inx 								; zero the decimal additive.
.24c9	20 73 26	jsr $2673			jsr 	FloatSetZero
.24cc	ca		dex				dex
.24cd	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24cf	80 ae		bra $247f			bra 	_ENExitChange
.24d1					_ESTADecimalState:
.24d1	68		pla				pla 								; digit.
.24d2	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24d4	f0 99		beq $246f			beq 	_ENFail
.24d6	e8		inx				inx 								; put digit into fractional part of X+1
.24d7	20 1b 25	jsr $251b			jsr 	ESTAShiftDigitIntoMantissa
.24da	ca		dex				dex
.24db	ee 39 06	inc $0639			inc 	decimalCount 				; bump the count of decimals
.24de	ad 39 06	lda $0639			lda 	decimalCount 				; too many decimal digits.
.24e1	c9 0b		cmp #$0b			cmp 	#11
.24e3	f0 02		beq $24e7			beq 	_ESTADSFail
.24e5	38		sec				sec
.24e6	60		rts				rts
.24e7					_ESTADSFail:
.24e7	18		clc				clc
.24e8	60		rts				rts
.24e9					_ENConstructFinal:
.24e9	ad 39 06	lda $0639			lda 	decimalCount 				; get decimal count
.24ec	f0 2b		beq $2519			beq 	_ENCFExit 					; no decimals
.24ee	5a		phy				phy
.24ef	0a		asl a				asl 	a 							; x 4 and CLC
.24f0	0a		asl a				asl 	a
.24f1	6d 39 06	adc $0639			adc 	decimalCount
.24f4	a8		tay				tay
.24f5	b9 80 21	lda $2180,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24f8	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24fa	b9 81 21	lda $2181,y			lda 	FloatScalarTable-5+1,y
.24fd	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.24ff	b9 82 21	lda $2182,y			lda 	FloatScalarTable-5+2,y
.2502	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2504	b9 83 21	lda $2183,y			lda 	FloatScalarTable-5+3,y
.2507	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2509	b9 84 21	lda $2184,y			lda 	FloatScalarTable-5+4,y
.250c	95 70		sta $70,x			sta 	NSExponent+2,x
.250e	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.2510	e8		inx				inx 								; multiply decimal const by decimal scalar
.2511	e8		inx				inx
.2512	20 33 23	jsr $2333			jsr 	FloatMultiply
.2515	20 97 20	jsr $2097			jsr 	FloatAdd 					; add to integer part.
.2518	7a		ply				ply
.2519					_ENCFExit:
.2519	18		clc				clc 								; reject the digit.
.251a	60		rts				rts
.251b					ESTAShiftDigitIntoMantissa:
.251b	29 0f		and #$0f			and 	#15 						; save digit
.251d	48		pha				pha
.251e	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2520	48		pha				pha
.2521	b5 56		lda $56,x			lda 	NSMantissa2,x
.2523	48		pha				pha
.2524	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2526	48		pha				pha
.2527	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2529	48		pha				pha
.252a	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; x 2
.252d	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; x 4
.2530	18		clc				clc 								; pop mantissa and add
.2531	68		pla				pla
.2532	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2534	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2536	68		pla				pla
.2537	75 4a		adc $4a,x			adc 	NSMantissa1,x
.2539	95 4a		sta $4a,x			sta 	NSMantissa1,x
.253b	68		pla				pla
.253c	75 56		adc $56,x			adc 	NSMantissa2,x
.253e	95 56		sta $56,x			sta 	NSMantissa2,x
.2540	68		pla				pla
.2541	75 62		adc $62,x			adc 	NSMantissa3,x
.2543	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.2545	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; x 10
.2548	68		pla				pla 								; add digit
.2549	18		clc				clc
.254a	75 3e		adc $3e,x			adc 	NSMantissa0,x
.254c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.254e	90 0a		bcc $255a			bcc 	_ESTASDExit
.2550	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2552	d0 06		bne $255a			bne 	_ESTASDExit
.2554	f6 56		inc $56,x			inc 	NSMantissa2,x
.2556	d0 02		bne $255a			bne 	_ESTASDExit
.2558	f6 62		inc $62,x			inc 	NSMantissa3,x
.255a					_ESTASDExit:
.255a	60		rts				rts
.0637					encodeState:
>0637							.fill 	1
.0638					digitTemp:
>0638							.fill 	1
.0639					decimalCount:
>0639							.fill 	1
.255b					FloatToString:
.255b	da		phx				phx
.255c	5a		phy				phy 								; save code position
.255d	8d 3a 06	sta $063a			sta 	decimalPlaces	 			; save number of DPs.
.2560	9c 3b 06	stz $063b			stz 	dbOffset 					; offset into decimal buffer = start.
.2563	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.2565	10 08		bpl $256f			bpl 	_CNTSNotNegative
.2567	29 7f		and #$7f			and 	#$7F 						; make +ve
.2569	95 32		sta $32,x			sta 	NSStatus,x
.256b	a9 2d		lda #$2d			lda 	#"-"
.256d	80 02		bra $2571			bra 	_CNTMain
.256f					_CNTSNotNegative:
.256f	a9 20		lda #$20			lda 	#" "
.2571					_CNTMain:
.2571	20 d3 25	jsr $25d3			jsr 	WriteDecimalBuffer
.2574	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.2576	f0 0d		beq $2585			beq 	_CNTSNotFloat
.2578	e8		inx				inx 								; round up so we don't get too many 6.999999
.2579	a9 01		lda #$01			lda 	#1
.257b	20 75 26	jsr $2675			jsr 	FloatSetByte
.257e	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2580	95 6e		sta $6e,x			sta 	NSExponent,x
.2582	20 97 20	jsr $2097			jsr 	FloatAdd
.2585					_CNTSNotFloat:
.2585	20 b5 25	jsr $25b5			jsr 	MakePlusTwoString 			; do the integer part.
.2588	20 53 22	jsr $2253			jsr 	FloatFractionalPart 		; get the fractional part
.258b	20 c8 23	jsr $23c8			jsr 	FloatNormalise					; normalise , exit if zero
.258e	f0 22		beq $25b2			beq 	_CNTSExit
.2590	a9 2e		lda #$2e			lda 	#"."
.2592	20 d3 25	jsr $25d3			jsr 	WriteDecimalBuffer 			; write decimal place
.2595					_CNTSDecimal:
.2595	ce 3a 06	dec $063a			dec 	decimalPlaces 				; done all the decimals
.2598	30 18		bmi $25b2			bmi 	_CNTSExit
.259a	e8		inx				inx 								; x 10.0
.259b	a9 0a		lda #$0a			lda 	#10
.259d	20 75 26	jsr $2675			jsr 	FloatSetByte
.25a0	20 33 23	jsr $2333			jsr 	FloatMultiply
.25a3	20 b5 25	jsr $25b5			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25a6	20 53 22	jsr $2253			jsr 	FloatFractionalPart 		; get the fractional part
.25a9	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise it.
.25ac	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25ae	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25b0	b0 e3		bcs $2595			bcs 	_CNTSDecimal 				; keep going.
.25b2					_CNTSExit:
.25b2	7a		ply				ply
.25b3	fa		plx				plx
.25b4	60		rts				rts
.25b5					MakePlusTwoString:
.25b5	da		phx				phx
.25b6	20 56 26	jsr $2656			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25b9	e8		inx				inx 								; access it
.25ba	e8		inx				inx
.25bb	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart 			; make it an integer
.25be	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25c0	20 f2 25	jsr $25f2			jsr 	ConvertInt32
.25c3	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25c5					_MPTSCopy:
.25c5	bd 15 06	lda $0615,x			lda 	numberBuffer,x
.25c8	20 d3 25	jsr $25d3			jsr 	WriteDecimalBuffer
.25cb	e8		inx				inx
.25cc	bd 15 06	lda $0615,x			lda 	numberBuffer,x
.25cf	d0 f4		bne $25c5			bne 	_MPTSCopy
.25d1	fa		plx				plx
.25d2	60		rts				rts
.25d3					WriteDecimalBuffer:
.25d3	da		phx				phx
.25d4	ae 3b 06	ldx $063b			ldx 	dbOffset
.25d7	9d 3c 06	sta $063c,x			sta 	decimalBuffer,x
.25da	9e 3d 06	stz $063d,x			stz 	decimalBuffer+1,x
.25dd	ee 3b 06	inc $063b			inc 	dbOffset
.25e0	fa		plx				plx
.25e1	60		rts				rts
.063a					decimalPlaces:
>063a							.fill 	1
.063b					dbOffset:
>063b							.fill 	1
.063c					decimalBuffer:
>063c							.fill 	32
.25e2					ConvertInt16:
.25e2	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.25e4	86 4a		stx $4a				stx 	NSMantissa1
.25e6	64 56		stz $56				stz 	NSMantissa2
.25e8	64 62		stz $62				stz 	NSMantissa3
.25ea	64 32		stz $32				stz 	NSStatus 					; positive integer
.25ec	a2 00		ldx #$00			ldx 	#0 							; stack level
.25ee	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25f0	80 00		bra $25f2			bra 	ConvertInt32
.25f2					ConvertInt32:
.25f2	5a		phy				phy
.25f3	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25f5	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25f7	10 08		bpl $2601			bpl 	_CI32NotNeg
.25f9	48		pha				pha
.25fa	a9 2d		lda #$2d			lda 	#'-'
.25fc	99 15 06	sta $0615,y			sta 	numberBuffer,y
.25ff	c8		iny				iny
.2600	68		pla				pla
.2601					_CI32NotNeg:
.2601	20 0f 26	jsr $260f			jsr 	_CI32DivideConvert 			; recursive conversion
.2604	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2606	99 15 06	sta $0615,y			sta 	numberBuffer,y
.2609	7a		ply				ply
.260a	a2 06		ldx #$06			ldx 	#numberBuffer >> 8 			; return address in XA
.260c	a9 15		lda #$15			lda 	#numberBuffer & $FF
.260e	60		rts				rts
.260f					_CI32DivideConvert:
.260f	e8		inx				inx 								; write to next slot up
.2610	20 75 26	jsr $2675			jsr 	FloatSetByte 		 		; write the base out.
.2613	ca		dex				dex
.2614	20 09 22	jsr $2209			jsr 	Int32Divide 				; divide
.2617	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.2619	48		pha				pha
.261a	20 f8 21	jsr $21f8			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.261d	20 95 26	jsr $2695			jsr 	FloatIsZero 				; is it zero ?
.2620	f0 05		beq $2627			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2622	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2624	20 0f 26	jsr $260f			jsr 	_CI32DivideConvert 			; and recusrively call.
.2627					_CI32NoRecurse:
.2627	68		pla				pla 								; remainder
.2628	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.262a	90 02		bcc $262e			bcc 	_CI32NotHex
.262c	69 26		adc #$26			adc 	#6+32
.262e					_CI32NotHex:
.262e	69 30		adc #$30			adc 	#48
.2630	99 15 06	sta $0615,y			sta 	numberBuffer,y 				; write out and exit
.2633	c8		iny				iny
.2634	60		rts				rts
.2635					FloatNegate:
.2635	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2637	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2639	95 32		sta $32,x			sta 	NSStatus,x
.263b	60		rts				rts
.263c					FloatNegateMantissa:
.263c	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.263d	a9 00		lda #$00			lda 	#0
.263f	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2641	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2643	a9 00		lda #$00			lda 	#0
.2645	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.2647	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2649	a9 00		lda #$00			lda 	#0
.264b	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.264d	95 56		sta $56,x			sta 	NSMantissa2,x
.264f	a9 00		lda #$00			lda 	#0
.2651	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2653	95 62		sta $62,x			sta 	NSMantissa3,x
.2655	60		rts				rts
.2656					FloatShiftUpTwo:
.2656	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2658	95 40		sta $40,x			sta 	NSMantissa0+2,x
.265a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.265c	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.265e	b5 56		lda $56,x			lda 	NSMantissa2,x
.2660	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2662	b5 62		lda $62,x			lda 	NSMantissa3,x
.2664	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2666	b5 6e		lda $6e,x			lda 	NSExponent,x
.2668	95 70		sta $70,x			sta 	NSExponent+2,x
.266a	b5 32		lda $32,x			lda 	NSStatus,x
.266c	95 34		sta $34,x			sta 	NSStatus+2,x
.266e	60		rts				rts
.266f					FloatSetZeroMantissaOnly:
.266f	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2671	80 08		bra $267b			bra 	FloatZero13
.2673					FloatSetZero:
.2673	a9 00		lda #$00			lda 	#0
.2675					FloatSetByte:
.2675	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2677					FloatSetMantissa:
.2677	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.2679	74 32		stz $32,x			stz 	NSStatus,x
.267b					FloatZero13:
.267b	74 4a		stz $4a,x			stz 	NSMantissa1,x
.267d	74 56		stz $56,x			stz 	NSMantissa2,x
.267f	74 62		stz $62,x			stz 	NSMantissa3,x
.2681	60		rts				rts
.2682					FloatShiftLeft:
.2682	18		clc				clc
.2683					FloatRotateLeft:
.2683	36 3e		rol $3e,x			rol 	NSMantissa0,x
.2685	36 4a		rol $4a,x			rol		NSMantissa1,x
.2687	36 56		rol $56,x			rol		NSMantissa2,x
.2689	36 62		rol $62,x			rol		NSMantissa3,x
.268b	60		rts				rts
.268c					FloatShiftRight:
.268c	56 62		lsr $62,x			lsr 	NSMantissa3,x
.268e	76 56		ror $56,x			ror		NSMantissa2,x
.2690	76 4a		ror $4a,x			ror		NSMantissa1,x
.2692	76 3e		ror $3e,x			ror		NSMantissa0,x
.2694	60		rts				rts
.2695					FloatIsZero:
.2695	b5 62		lda $62,x			lda 	NSMantissa3,x
.2697	15 56		ora $56,x			ora		NSMantissa2,x
.2699	15 4a		ora $4a,x			ora		NSMantissa1,x
.269b	15 3e		ora $3e,x			ora		NSMantissa0,x
.269d	60		rts				rts

;******  Processing input file: testing/testend.asm

.269e					EndProgram:
>269e	01 08 0c 08 0a 00 4e 20				.binary "code/tokenised.dat"
>26a6	b2 20 31 34 00 15 08 14 00 ce 86 20 33 00 32 08
>26b6	3c 00 99 20 c7 28 31 34 37 29 3b 22 48 45 4c 4c
>26c6	4f 20 57 4f 52 4c 44 20 21 22 00 4e 08 46 00 86
>26d6	20 42 58 28 4e 29 3a 86 20 42 59 28 4e 29 3a 86
>26e6	20 42 43 28 4e 29 00 62 08 4b 00 86 20 44 58 28
>26f6	4e 29 3a 86 20 44 59 28 4e 29 00 70 08 50 00 81
>2706	20 42 b2 30 20 a4 20 4e 00 89 08 5a 00 42 58 28
>2716	42 29 b2 b5 28 bb 28 31 29 ac 34 30 29 ac 32 aa
>2726	31 00 a2 08 64 00 42 59 28 42 29 b2 b5 28 bb 28
>2736	31 29 ac 33 30 29 ac 32 35 36 00 b9 08 69 00 42
>2746	43 28 42 29 b2 b5 28 bb 28 31 29 ac 31 34 29 aa
>2756	31 00 cd 08 6a 00 44 58 28 42 29 b2 b5 28 bb 28
>2766	31 29 ac 32 29 00 e3 08 6c 00 8f 20 44 59 28 42
>2776	29 b2 b5 28 bb 28 31 29 ac 32 29 00 ef 08 6d 00
>2786	44 59 28 42 29 b2 31 00 f7 08 6e 00 82 20 42 00
>2796	fd 08 78 00 8f 00 11 09 82 00 81 59 b2 30 a4 32
>27a6	39 3a 81 58 b2 30 a4 33 39 00 27 09 8c 00 51 b2
>27b6	59 ac 32 35 36 aa 58 ac 32 aa 34 35 30 35 36 00
>27c6	3f 09 96 00 ce 84 20 31 2c 51 2c 38 31 3a ce 84
>27d6	31 2c 51 aa 31 2c 30 00 48 09 a0 00 82 58 2c 59
>27e6	00 54 09 c8 00 81 20 42 b2 31 a4 4e 00 71 09 d2
>27f6	00 ce 84 20 31 2c 34 35 30 35 36 aa 42 59 28 42
>2806	29 aa 42 58 28 42 29 2c 30 00 7f 09 e6 00 44 58
>2816	42 b2 44 58 28 42 29 00 90 09 f0 00 8b 44 58 42
>2826	b2 30 a7 8d 31 30 31 30 00 a1 09 fa 00 8b 44 58
>2836	42 b2 31 a7 8d 31 30 34 30 00 af 09 ff 00 44 59
>2846	42 b2 44 59 28 42 29 00 c0 09 04 01 8b 44 59 42
>2856	b2 30 a7 8d 31 30 37 30 00 d1 09 0e 01 8b 44 59
>2866	42 b2 31 a7 8d 31 31 30 30 00 f2 09 18 01 ce 84
>2876	20 31 2c 34 35 30 35 36 aa 42 59 28 42 29 aa 42
>2886	58 28 42 29 2c 42 43 28 42 29 00 f9 09 22 01 82
>2896	42 00 03 0a 2c 01 89 20 32 30 30 00 09 0a e8 03
>28a6	8f 00 17 0a f2 03 42 58 42 b2 42 58 28 42 29 00
>28b6	2c 0a f3 03 8b 42 58 42 b2 31 a7 44 58 28 42 29
>28c6	b2 31 3a 8e 00 3e 0a fc 03 42 58 28 42 29 b2 42
>28d6	58 42 ab 32 3a 8e 00 44 0a 06 04 8f 00 52 0a 10
>28e6	04 42 58 42 b2 42 58 28 42 29 00 72 0a 11 04 8b
>28f6	42 58 42 b2 37 39 a7 20 42 58 28 42 29 b2 37 37
>2906	3a 44 58 28 42 29 b2 30 3a 8e 00 84 0a 1a 04 42
>2916	58 28 42 29 b2 42 58 42 aa 32 3a 8e 00 8a 0a 24
>2926	04 8f 00 98 0a 2e 04 42 59 42 b2 42 59 28 42 29
>2936	00 ad 0a 2f 04 8b 42 59 42 b2 30 a7 44 59 28 42
>2946	29 b2 31 3a 8e 00 c1 0a 38 04 42 59 28 42 29 b2
>2956	42 59 42 ab 32 35 36 3a 8e 00 c7 0a 42 04 8f 00
>2966	d5 0a 4c 04 42 59 42 b2 42 59 28 42 29 00 f8 0a
>2976	4d 04 8b 42 59 42 b2 37 34 32 34 a7 42 59 28 42
>2986	29 b2 37 31 36 38 3a 44 59 28 42 29 b2 30 3a 8e
>2996	00 0c 0b 56 04 42 59 28 42 29 b2 42 59 42 aa 32
>29a6	35 36 3a 8e 00 00 00

;******  End of listing
