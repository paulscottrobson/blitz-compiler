;
;	This file is automatically generated
;
;
;	This file is automatically generated.
;
C64_END                  = $80 ; $80 end
C64_FOR                  = $81 ; $81 for
C64_NEXT                 = $82 ; $82 next
C64_DATA                 = $83 ; $83 data
C64_INPUTHASH            = $84 ; $84 input#
C64_INPUT                = $85 ; $85 input
C64_DIM                  = $86 ; $86 dim
C64_READ                 = $87 ; $87 read
C64_LET                  = $88 ; $88 let
C64_GOTO                 = $89 ; $89 goto
C64_RUN                  = $8a ; $8a run
C64_IF                   = $8b ; $8b if
C64_RESTORE              = $8c ; $8c restore
C64_GOSUB                = $8d ; $8d gosub
C64_RETURN               = $8e ; $8e return
C64_REM                  = $8f ; $8f rem
C64_STOP                 = $90 ; $90 stop
C64_ON                   = $91 ; $91 on
C64_WAIT                 = $92 ; $92 wait
C64_LOAD                 = $93 ; $93 load
C64_SAVE                 = $94 ; $94 save
C64_VERIFY               = $95 ; $95 verify
C64_DEF                  = $96 ; $96 def
C64_POKE                 = $97 ; $97 poke
C64_PRINTHASH            = $98 ; $98 print#
C64_PRINT                = $99 ; $99 print
C64_CONT                 = $9a ; $9a cont
C64_LIST                 = $9b ; $9b list
C64_CLR                  = $9c ; $9c clr
C64_CMD                  = $9d ; $9d cmd
C64_SYS                  = $9e ; $9e sys
C64_OPEN                 = $9f ; $9f open
C64_CLOSE                = $a0 ; $a0 close
C64_GET                  = $a1 ; $a1 get
C64_NEW                  = $a2 ; $a2 new
C64_TABLB                = $a3 ; $a3 tab(
C64_TO                   = $a4 ; $a4 to
C64_FN                   = $a5 ; $a5 fn
C64_SPCLB                = $a6 ; $a6 spc(
C64_THEN                 = $a7 ; $a7 then
C64_NOT                  = $a8 ; $a8 not
C64_STEP                 = $a9 ; $a9 step
C64_PLUS                 = $aa ; $aa +
C64_MINUS                = $ab ; $ab -
C64_TIMES                = $ac ; $ac *
C64_DIVIDE               = $ad ; $ad /
C64_POWER                = $ae ; $ae ^
C64_AND                  = $af ; $af and
C64_OR                   = $b0 ; $b0 or
C64_GREATER              = $b1 ; $b1 >
C64_EQUAL                = $b2 ; $b2 =
C64_LESS                 = $b3 ; $b3 <
C64_SGN                  = $b4 ; $b4 sgn
C64_INT                  = $b5 ; $b5 int
C64_ABS                  = $b6 ; $b6 abs
C64_USR                  = $b7 ; $b7 usr
C64_FRE                  = $b8 ; $b8 fre
C64_POS                  = $b9 ; $b9 pos
C64_SQR                  = $ba ; $ba sqr
C64_RND                  = $bb ; $bb rnd
C64_LOG                  = $bc ; $bc log
C64_EXP                  = $bd ; $bd exp
C64_COS                  = $be ; $be cos
C64_SIN                  = $bf ; $bf sin
C64_TAN                  = $c0 ; $c0 tan
C64_ATN                  = $c1 ; $c1 atn
C64_PEEK                 = $c2 ; $c2 peek
C64_LEN                  = $c3 ; $c3 len
C64_STRDOLLAR            = $c4 ; $c4 str$
C64_VAL                  = $c5 ; $c5 val
C64_ASC                  = $c6 ; $c6 asc
C64_CHRDOLLAR            = $c7 ; $c7 chr$
C64_LEFTDOLLAR           = $c8 ; $c8 left$
C64_RIGHTDOLLAR          = $c9 ; $c9 right$
C64_MIDDOLLAR            = $ca ; $ca mid$
C64_GO                   = $cb ; $cb go
C64_MON                  = $ce80 ; $ce80 mon
C64_DOS                  = $ce81 ; $ce81 dos
C64_OLD                  = $ce82 ; $ce82 old
C64_GEOS                 = $ce83 ; $ce83 geos
C64_VPOKE                = $ce84 ; $ce84 vpoke
C64_VLOAD                = $ce85 ; $ce85 vload
C64_SCREEN               = $ce86 ; $ce86 screen
C64_PSET                 = $ce87 ; $ce87 pset
C64_LINE                 = $ce88 ; $ce88 line
C64_FRAME                = $ce89 ; $ce89 frame
C64_RECT                 = $ce8a ; $ce8a rect
C64_CHAR                 = $ce8b ; $ce8b char
C64_MOUSE                = $ce8c ; $ce8c mouse
C64_COLOR                = $ce8d ; $ce8d color
C64_TEST                 = $ce8e ; $ce8e test
C64_RESET                = $ce8f ; $ce8f reset
C64_CLS                  = $ce90 ; $ce90 cls
C64_CODEX                = $ce91 ; $ce91 codex
C64_LOCATE               = $ce92 ; $ce92 locate
C64_BOOT                 = $ce93 ; $ce93 boot
C64_KEYMAP               = $ce94 ; $ce94 keymap
C64_BLOAD                = $ce95 ; $ce95 bload
C64_BVLOAD               = $ce96 ; $ce96 bvload
C64_BVERIFY              = $ce97 ; $ce97 bverify
C64_BANK                 = $ce98 ; $ce98 bank
C64_FMINIT               = $ce99 ; $ce99 fminit
C64_FMNOTE               = $ce9a ; $ce9a fmnote
C64_FMDRUM               = $ce9b ; $ce9b fmdrum
C64_FMINST               = $ce9c ; $ce9c fminst
C64_FMVIB                = $ce9d ; $ce9d fmvib
C64_FMFREQ               = $ce9e ; $ce9e fmfreq
C64_FMVOL                = $ce9f ; $ce9f fmvol
C64_FMPAN                = $cea0 ; $cea0 fmpan
C64_FMPLAY               = $cea1 ; $cea1 fmplay
C64_FMCHORD              = $cea2 ; $cea2 fmchord
C64_FMPOKE               = $cea3 ; $cea3 fmpoke
C64_PSGINIT              = $cea4 ; $cea4 psginit
C64_PSGNOTE              = $cea5 ; $cea5 psgnote
C64_PSGVOL               = $cea6 ; $cea6 psgvol
C64_PSGWAV               = $cea7 ; $cea7 psgwav
C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
C64_PSGPAN               = $cea9 ; $cea9 psgpan
C64_PSGPLAY              = $ceaa ; $ceaa psgplay
C64_PSGCHORD             = $ceab ; $ceab psgchord
C64_REBOOT               = $ceac ; $ceac reboot
C64_POWEROFF             = $cead ; $cead poweroff
C64_I2CPOKE              = $ceae ; $ceae i2cpoke
C64_SLEEP                = $ceaf ; $ceaf sleep
C64_BSAVE                = $ceb0 ; $ceb0 bsave
C64_MENU                 = $ceb1 ; $ceb1 menu
C64_REN                  = $ceb2 ; $ceb2 ren
C64_LINPUT               = $ceb3 ; $ceb3 linput
C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
C64_HELP                 = $ceb6 ; $ceb6 help
C64_VPEEK                = $ced0 ; $ced0 vpeek
C64_MX                   = $ced1 ; $ced1 mx
C64_MY                   = $ced2 ; $ced2 my
C64_MB                   = $ced3 ; $ced3 mb
C64_JOY                  = $ced4 ; $ced4 joy
C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
C64_BINDOLLAR            = $ced6 ; $ced6 bin$
C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
C64_POINTER              = $ced8 ; $ced8 pointer
C64_STRPTR               = $ced9 ; $ced9 strptr
C64_RPTDOLLAR            = $ceda ; $ceda rpt$
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		data.inc
;		Purpose:	Common Data
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Mandatory Zero page code
;
; ************************************************************************************************

		.section zeropage
srcPtr: 									; pointer in source buffer
		.fill 	2		
		.send zeropage


; ************************************************************************************************
;
;										Non Zero Page Data
;
; ************************************************************************************************

		.section storage
sourceBuffer: 								; current input line.
		.fill 	256		
currentLineNumber:							; current line number.
		.fill 	2		
		.send 	storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

;
;	This file is automatically generated.
;
error_range .macro
	jmp	ErrorV_range
	.endm
error_value .macro
	jmp	ErrorV_value
	.endm
error_syntax .macro
	jmp	ErrorV_syntax
	.endm
error_type .macro
	jmp	ErrorV_type
	.endm
error_unimplemented .macro
	jmp	ErrorV_unimplemented
	.endm
error_assert .macro
	jmp	ErrorV_assert
	.endm
error_line .macro
	jmp	ErrorV_line
	.endm
error_internal .macro
	jmp	ErrorV_internal
	.endm
error_divzero .macro
	jmp	ErrorV_divzero
	.endm
error_structure .macro
	jmp	ErrorV_structure
	.endm
error_stop .macro
	jmp	ErrorV_stop
	.endm
error_data .macro
	jmp	ErrorV_data
	.endm
error_undeclared .macro
	jmp	ErrorV_undeclared
	.endm
error_redefine .macro
	jmp	ErrorV_redefine
	.endm
error_index .macro
	jmp	ErrorV_index
	.endm
error_memory .macro
	jmp	ErrorV_memory
	.endm
error_channel .macro
	jmp	ErrorV_channel
	.endm
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		macros.inc
;		Purpose:	Command macros
;		Created:	25th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							Size independent write keyword as constant
;
; ************************************************************************************************

keyword .macro
		.if (\1) > 255
		lda 	#(\1) >> 8
		jsr 	WriteCodeByte
		.endif
		lda 	#(\1) & $FF
		jsr 	WriteCodeByte
		.endm


		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
;
;	This file is automatically generated
;
PCD_STARTBINARY = $80
PCD_ENDBINARY = $8d
PCD_STARTCOMMAND = $8d
PCD_ENDCOMMAND = $ca
PCD_STARTSYSTEM = $ca
PCD_ENDSYSTEM = $d5

PCD_PLUS             = $80 ; +
PCD_MINUS            = $81 ; -
PCD_TIMES            = $82 ; *
PCD_DIVIDE           = $83 ; /
PCD_POWER            = $84 ; ^
PCD_AND              = $85 ; and
PCD_OR               = $86 ; or
PCD_GREATER          = $87 ; >
PCD_EQUAL            = $88 ; =
PCD_LESS             = $89 ; <
PCD_GREATEREQUAL     = $8a ; >=
PCD_LESSGREATER      = $8b ; <>
PCD_LESSEQUAL        = $8c ; <=
PCD_ABS              = $8d ; abs
PCD_ARRAY            = $8e ; array
PCD_ASC              = $8f ; asc
PCD_ASSERT           = $90 ; assert
PCD_BINDOLLAR        = $91 ; bin$
PCD_PRINTCMD_CHR     = $92 ; print.chr
PCD_CHRDOLLAR        = $93 ; chr$
PCD_SCMD_CMP         = $94 ; s.cmp
PCD_FOR              = $95 ; for
PCD_FRE              = $96 ; fre
PCD_GET              = $97 ; get
PCD_RETURN           = $98 ; return
PCD_PSET             = $99 ; pset
PCD_LINE             = $9a ; line
PCD_RECT             = $9b ; rect
PCD_FRAME            = $9c ; frame
PCD_CHAR             = $9d ; char
PCD_HEXDOLLAR        = $9e ; hex$
PCD_INPUT            = $9f ; input
PCD_INPUTDOLLAR      = $a0 ; input$
PCD_INPUTCMD_START   = $a1 ; input.start
PCD_LEN              = $a2 ; len
PCD_FCMD_CMP         = $a3 ; f.cmp
PCD_INTCMD_DIV       = $a4 ; int.div
PCD_NEGATE           = $a5 ; negate
PCD_NEWCMD_LINE      = $a6 ; new.line
PCD_NEXT             = $a7 ; next
PCD_NOT              = $a8 ; not
PCD_ON               = $a9 ; on
PCD_MOREON           = $aa ; moreon
PCD_PEEK             = $ab ; peek
PCD_POKE             = $ac ; poke
PCD_POS              = $ad ; pos
PCD_GETCHANNEL       = $ae ; getchannel
PCD_SETCHANNEL       = $af ; setchannel
PCD_PRINTCMD_N       = $b0 ; print.n
PCD_PRINTCMD_S       = $b1 ; print.s
PCD_READ             = $b2 ; read
PCD_READDOLLAR       = $b3 ; read$
PCD_RND              = $b4 ; rnd
PCD_CONCAT           = $b5 ; concat
PCD_SGN              = $b6 ; sgn
PCD_PRINTCMD_TAB     = $b7 ; print.tab
PCD_PRINTCMD_POS     = $b8 ; print.pos
PCD_PRINTCMD_SPC     = $b9 ; print.spc
PCD_STRDOLLAR        = $ba ; str$
PCD_LEFTDOLLAR       = $bb ; left$
PCD_RIGHTDOLLAR      = $bc ; right$
PCD_MIDDOLLAR        = $bd ; mid$
PCD_SWAP             = $be ; swap
PCD_TI               = $bf ; ti
PCD_TIDOLLAR         = $c0 ; ti$
PCD_USR              = $c1 ; usr
PCD_VAL              = $c2 ; val
PCD_CLOSE            = $c3 ; close
PCD_EXIT             = $c4 ; exit
PCD_DEBUG            = $c5 ; debug
PCD_OPEN             = $c6 ; open
PCD_SCREEN           = $c7 ; screen
PCD_VPOKE            = $c8 ; vpoke
PCD_VPEEK            = $c9 ; vpeek
PCD_CMD_SHIFT        = $ca ; .shift
PCD_CMD_BYTE         = $cb ; .byte
PCD_CMD_WORD         = $cc ; .word
PCD_CMD_FLOAT        = $cd ; .float
PCD_CMD_STRING       = $ce ; .string
PCD_CMD_DATA         = $cf ; .data
PCD_CMD_GOTO         = $d0 ; .goto
PCD_CMD_GOSUB        = $d1 ; .gosub
PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
PCD_CMD_VARSPACE     = $d4 ; .varspace
PCD_CLR              = $ca80 ; clr
PCD_DIM              = $ca81 ; dim
PCD_END              = $ca82 ; end
PCD_JOY              = $ca83 ; joy
PCD_INT              = $ca84 ; int
PCD_SQR              = $ca85 ; sqr
PCD_LOG              = $ca86 ; log
PCD_EXP              = $ca87 ; exp
PCD_COS              = $ca88 ; cos
PCD_SIN              = $ca89 ; sin
PCD_TAN              = $ca8a ; tan
PCD_ATN              = $ca8b ; atn
PCD_MOUSE            = $ca8c ; mouse
PCD_MB               = $ca8d ; mb
PCD_MX               = $ca8e ; mx
PCD_MY               = $ca8f ; my
PCD_RESTORE          = $ca90 ; restore
PCD_STOP             = $ca91 ; stop
PCD_SYS              = $ca92 ; sys
PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
PCD_WAIT             = $ca94 ; wait
PCD_I2CPOKE          = $ca95 ; i2cpoke
PCD_I2CPEEK          = $ca96 ; i2cpeek
PCD_BANK             = $ca97 ; bank
PCD_SLEEP            = $ca98 ; sleep
PCD_FMINIT           = $ca99 ; fminit
PCD_FMNOTE           = $ca9a ; fmnote
PCD_FMDRUM           = $ca9b ; fmdrum
PCD_FMINST           = $ca9c ; fminst
PCD_FMVIB            = $ca9d ; fmvib
PCD_FMFREQ           = $ca9e ; fmfreq
PCD_FMVOL            = $ca9f ; fmvol
PCD_FMPAN            = $caa0 ; fmpan
PCD_FMPLAY           = $caa1 ; fmplay
PCD_FMCHORD          = $caa2 ; fmchord
PCD_FMPOKE           = $caa3 ; fmpoke
PCD_PSGINIT          = $caa4 ; psginit
PCD_PSGNOTE          = $caa5 ; psgnote
PCD_PSGVOL           = $caa6 ; psgvol
PCD_PSGWAV           = $caa7 ; psgwav
PCD_PSGFREQ          = $caa8 ; psgfreq
PCD_PSGPAN           = $caa9 ; psgpan
PCD_PSGPLAY          = $caaa ; psgplay
PCD_PSGCHORD         = $caab ; psgchord
PCD_CLS              = $caac ; cls
PCD_LOCATE           = $caad ; locate
PCD_COLOR            = $caae ; color
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_config.inc
;		Purpose:	Configuration for compiler
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************
;
;		Runtime p-code goes here. Needs to be on a page boundary.
;
PCodeStart = $4000
;
;		Work area space and size. Upwards is variables, Downwards is line number positions.
;
WorkArea = $8000
WorkAreaSize = $1F00

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		x16_storage.inc
;		Purpose:	Storage access macros
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

storage_access .macro
		.endm

storage_release .macro
		.endm

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		altbase.asm
;		Purpose:	Handle other bases
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						Compile a 16 bit other base constant. Type marker in A
;
; ************************************************************************************************

InlineNonDecimal:
		ldx 	#2 							; get size in X
		cmp 	#"%" 						
		beq 	_INDBinary
		ldx 	#16
_INDBinary:									
		sta 	zTemp1 						; size => zTemp1
		stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
		stz 	zTemp0 						; zero result
		stz 	zTemp0+1
_INDLoop:
		jsr 	LookNext 					; check next character
		jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
		bcc		_INDDone 					; didn't convert
		cmp 	zTemp1 						; size too large ?
		bcs 	_INDDone
		;
		jsr 	_INDShift 					; x 2 or x 16
		cpx 	#2
		beq 	_INDNotHex
		jsr 	_INDShift
		jsr 	_INDShift
		jsr 	_INDShift
_INDNotHex:
		ora 	zTemp0 						; or digit into result
		sta 	zTemp0 		
		jsr 	GetNext 					; consume
		inc 	zTemp1+1 					; bump count
		bra 	_INDLoop
		;
_INDDone:
		lda 	zTemp1+1 					; done at least 1 ?
		beq 	_INDError
		ldy 	zTemp0+1 					; push constant
		lda 	zTemp0	
		jsr 	PushIntegerYA
		rts

_INDError:
		.error_syntax
		
_INDShift:
		asl 	zTemp0
		rol 	zTemp0+1
		rts		
		.send code

		.section storage
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		buffer.asm
;		Purpose:	Buffer for inline data, strings etc.
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Clear the buffer
;
; ************************************************************************************************

BufferClear:
		stz 	bufferSize
		rts		

; ************************************************************************************************
;
;									 Write A to the buffer
;
; ************************************************************************************************

BufferWrite:
		phx
		ldx 	bufferSize
		sta 	dataBuffer,x
		inc 	bufferSize
		plx
		rts

; ************************************************************************************************
;
;								Output buffer as data block
;
; ************************************************************************************************

BufferOutput:
		lda 	bufferSize
		jsr 	WriteCodeByte
		ldx 	#0
_BOLoop:
		cpx 	bufferSize
		beq 	_BOExit
		lda 	dataBuffer,x
		jsr 	WriteCodeByte
		inx
		bra 	_BOLoop
_BOExit:
		rts		
		.send code

		.section storage
bufferSize:
		.fill 	1
dataBuffer:
		.fill 	256
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		byte.asm
;		Purpose:	Wrapper for HWOWriteByte
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Write A with to output
;
; ************************************************************************************************

WriteCodeByte:
		pha 								; save on stack
		phx
		phy
		jsr 	OUTPUTWriteByte
		ply 								; restore from stack
		plx
		pla
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		check.asm
;		Purpose:	Token presence check
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

	
; ************************************************************************************************
;
;									Check Next char various
;
; ************************************************************************************************

CheckNextComma:
		lda	 	#","
		bra 	CheckNextA
CheckNextRParen:
		lda	 	#")"
		bra 	CheckNextA
CheckNextLParen:
		lda 	#"("
CheckNextA:
		sta 	checkCharacter 				; save test character
_CNALoop:		
		jsr 	GetNextNonSpace 			; get next skipping spaces.
		cmp 	checkCharacter 				; matches ?
		beq 	_CNAExit
		.error_syntax
_CNAExit:		
		rts
		.send code

		.section storage
checkCharacter:
		.fill 	1
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		close.asm
;		Purpose:	Close, perhaps Save the object code out
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Save the object code out
;
; ************************************************************************************************

OUTPUTClose:
		lda 	#(PCodeStart >> 8)
		ldx 	objPtr
		ldy 	objPtr+1
		jsr 	XSaveMemory
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
make; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		00compiler.asm
;		Purpose:	Compiler main
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

StartCompiler:	
		jsr 	STRReset 					; reset storage (line#, variable)
		jsr 	INPUTOpen 					; reset data input
		jsr 	OUTPUTOpen 					; reset data output.
		;
		;		Compile _variable.space, filled in on pass 2.
		;
		lda 	#PCD_CMD_VARSPACE
		jsr 	WriteCodeByte
		lda 	#0
		jsr 	WriteCodeByte
		jsr 	WriteCodeByte
		;
		;		Main compilation loop
		;
MainCompileLoop:
		jsr 	ReadNextLine 				; read next line into the buffer.		
		bcc 	SaveCodeAndExit 			; end of source.
		;
		jsr 	GetLineNumber 				; get line #
		jsr 	STRMarkLine 				; remember the position and number of this line.
		lda 	#PCD_NEWCMD_LINE 			; generate new command line
		jsr 	WriteCodeByte

_MCLSameLine:
		jsr 	GetNextNonSpace 			; get the first character.
		beq 	MainCompileLoop 			; end of line, get next line.
		cmp 	#":"						; if : then loop back.
		beq 	_MCLSameLine

		cmp 	#0 							; if ASCII then check for implied LET.		
		bpl 	_MCLCheckAssignment 

		ldx 	#CommandTables & $FF 		; do command tables.
		ldy 	#CommandTables >> 8
		jsr 	GeneratorProcess
		bcs 	_MCLSameLine 				; keep trying to compile the line.

_MCLSyntax: 								; syntax error.
		.error_syntax
		;
		;		Implied assignment ?
		;
_MCLCheckAssignment:
		jsr 	CharIsAlpha 				; if not alpha then syntax error
		bcc 	_MCLSyntax
		jsr 	CommandLETHaveFirst  		; LET first character, do assign
		bra		_MCLSameLine 				; loop back.
		;
		;		End of compile, fix up GOTO/GOSUB etc., save it and exit.
		;
SaveCodeAndExit:
		jsr 	INPUTClose 					; finish input.
		lda 	#$FF 						; fake line number $FFFF for forward THEN.
		tay
		jsr 	STRMarkLine
		lda 	#PCD_EXIT 					; add an END
		jsr 	WriteCodeByte
		lda 	#$FF 						; add end marker
		jsr 	WriteCodeByte
		jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
		jsr 	OUTPUTClose
ExitCompiler:		
		jmp 	$FFFF
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		constant.asm
;		Purpose:	Output integer constants
;		Created:	15th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Output code to push integer YA / A
;
; ************************************************************************************************

PushIntegerYA:
		cpy 	#0 							; 0-255
		beq 	PushIntegerA
		pha
		lda 	#PCD_CMD_WORD 				; send .word
		jsr 	WriteCodeByte 	
		pla 								; then LSB
		jsr 	WriteCodeByte 	
		tya 								; then MSB
		jsr 	WriteCodeByte 	
		rts

PushIntegerA:
		cmp 	#64 						; if > 64 send byte as is
		bcc 	_PIWriteA
		pha 								
		lda 	#PCD_CMD_BYTE 				; send .byte
		jsr 	WriteCodeByte 	
		pla
_PIWriteA:		
		jsr 	WriteCodeByte
		rts

; ************************************************************************************************
;
;										Push TOS Float
;
; ************************************************************************************************

PushFloat:
		lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
		jsr 	WriteCodeByte
		lda 	NSExponent,x 				; and the data
		jsr 	WriteCodeByte
		lda 	NSMantissa0,x
		jsr 	WriteCodeByte
		lda 	NSMantissa1,x
		jsr 	WriteCodeByte
		lda 	NSMantissa2,x
		jsr 	WriteCodeByte
		lda 	NSStatus,x 					; with sign packed in byte 3 MSB
		and 	#$80
		ora 	NSMantissa3,x
		jsr 	WriteCodeByte
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		create.asm
;		Purpose:	Create variable.
;		Created:	25th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;		  		   XYmake  contains a variable name. Allocate space for it and create it. 
;										Return variable address in YX
;
; ************************************************************************************************

		.section code

CreateVariableRecord:
		pha

		.storage_access

		lda 	freeVariableMemory 		; push current free address on stack.
		pha
		lda 	freeVariableMemory+1
		pha

		lda 	variableListEnd  		; copy end of list to zTemp0
		sta 	zTemp0	
		lda 	variableListEnd+1
		sta 	zTemp0+1

		lda 	#6 						; default size if 6 (offset link 3 bytes)
		sta 	(zTemp0)

		tya
		ldy 	#2 						; write out the name.
		sta 	(zTemp0),y
		dey
		txa
		sta 	(zTemp0),y

		ldy 	#3 						; write out the address.
		lda 	freeVariableMemory
		sta 	(zTemp0),y
		iny
		lda 	freeVariableMemory+1
		sta 	(zTemp0),y

		ldy 	#6 						; write EOL marker next record.
		lda 	#0
		sta 	(zTemp0),y

		clc
		lda 	(zTemp0) 				; add offset to variableListEnd
		adc  	variableListEnd
		sta 	variableListEnd
		bcc 	_CVNoCarry2
		inc 	variableListEnd+1
_CVNoCarry2:		
		.storage_release
		ply 							
		plx
		pla
		rts

; ************************************************************************************************
;
;			Set the last defined variable record to the current code position.
;
; ************************************************************************************************

SetVariableRecordToCodePosition:
		.storage_access
		pha
		phy
		lda 	objPage
		ldy 	#3
		sta 	(zTemp0),y
		iny
		lda 	objPtr+1
		sta 	(zTemp0),y
		iny 	
		lda 	objPtr
		sta 	(zTemp0),y
		ply
		pla
		.storage_release
		rts

; ************************************************************************************************
;
;									Allocate bytes for type A
;
; ************************************************************************************************

AllocateBytesForType:
		pha
		phx
		ldx 	#2 						; bytes to allocate
		and 	#NSSTypeMask+NSSIInt16
		cmp 	#NSSIFloat
		bne 	_CVNotFloat
		ldx 	#6
_CVNotFloat:
		txa 							; add 6 or 2 to the free memory pointer.
		clc
		adc 	freeVariableMemory
		sta 	freeVariableMemory
		bcc 	_CVNoCarry1
		inc 	freeVariableMemory+1
_CVNoCarry1:				
		plx
		pla
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		data.asm
;		Purpose:	Compile DATA Statements
;		Created:	21st April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Compile a Data Block
;
; ************************************************************************************************

CommandDATA:
		jsr 	BufferClear 				; copy it to the buffer
		jsr 	LookNextNonSpace
_CTDataLoop:
		jsr 	LookNext 					; reached EOL
		beq 	_CTDataDone
		;
		jsr 	BufferWrite 				; write and consume
		jsr 	GetNext
		bra 	_CTDataLoop
_CTDataDone:
		lda 	#PCD_CMD_DATA 				; output command and buffer
		jsr 	WriteCodeByte
		jsr 	BufferOutput
		rts		

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		deffn.asm
;		Purpose:	Def Fn command
;		Created:	29th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										DEF FN
;
; ************************************************************************************************

CommandDEF: 		
		;
		;		Skip to EOL.
		;
		lda 	#0 							; constant 0 (for GOTOZ)
		jsr 	PushIntegerA
		jsr 	CompileGotoEOL 				; compile skip over DEF
		;
		;	 	Check FN keyword
		;
		lda 	#C64_FN
		jsr 	CheckNextA
		;
		;		Identify FNxx(
		;
		jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
		jsr 	ExtractVariableName 
		txa
		bpl 	_CDError
		;
		txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
		and 	#$7F
		tax
		tya
		ora 	#$80
		tay
		;
		;		Create the FNxx( record and give it the address.
		;
		jsr 	FindVariable				; does it already exist ?
		bcs 	_CDError 					; if so, that's an error.
		jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
		jsr 	SetVariableRecordToCodePosition
		;
		;		Get the address to update.
		;
		jsr 	GetNextNonSpace
		jsr 	GetReferenceTerm 			; get var ref, not array
		cmp 	#0
		bmi 	_CDError 	
		sta 	defType 					; save type		
		stx 	defVariable 				; save var ref 
		sty 	defVariable+1
		and 	#NSSString 					; only numbers.
		bne 	_CDError
		jsr 	CheckNextRParen 			; check )
		lda 	#C64_EQUAL
		jsr 	CheckNextA 					; check =
		;	
		;		Now generate the code.
		;
		clc 								; if this is DEF FNxx(A), read A
		jsr 	CDReadWriteVariable
		.keyword PCD_SWAP 					; old A 2nd, new A 1st
		sec
		jsr 	CDReadWriteVariable 		; A is now updated
		jsr 	CompileExpressionAt0 		; the actual body of the function.
		.keyword PCD_SWAP 					; result 2nd, old A 1st
		sec
		jsr 	CDReadWriteVariable 		; A is now reset to its old value
		.keyword PCD_RETURN 				; return as we'll call it from a subroutine
		rts


_CDError:
		.error_syntax

CDReadWriteVariable:
		ldy 	defVariable+1 				; set up YX
		ldx 	defVariable
		lda 	defType
		jsr 	GetSetVariable
		rts
		.send code

		.section storage
defType:
		.fill 	1
defVariable:
		.fill 	2
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		dim.asm
;		Purpose:	DIM command
;		Created:	26th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											DIM command
;
; ************************************************************************************************

CommandDIM:
		jsr 	GetNextNonSpace 			; get the first non space character
		jsr 	ExtractVariableName 		; variable name to XY
		phx 								; save name with type bits.
		cpx 	#0 							; check it is an array.
		bpl 	_CDError
		jsr 	FindVariable	 			; see if already exist
		bcs 	_CDRedefine 				; it still exists.
		jsr 	CreateVariableRecord 		; create the basic variable 
		jsr 	AllocateBytesForType 		; allocate memory for it

		pla 								; restore type bits
		phy 								; save the address of the basic storage
		phx
		pha
		jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
		pla
		and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
		jsr 	PushIntegerA 				; push that type data out.

		.keyword PCD_DIM 					; call the keyword to dimension the array with this information.
		
		plx 								; restore address
		ply
		lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
		sec
		jsr 	GetSetVariable 				; store the address in the reference to the array structure.
		;
		jsr 	LookNextNonSpace 			; , follows ?
		cmp 	#","
		bne 	_CDExit
		jsr 	GetNext 					; consume comma
		bra 	CommandDIM 					; do another DIM
_CDExit:		
		rts		

_CDError:
		.error_syntax
_CDRedefine:
		.error_redefine

; ************************************************************************************************
;
;									Consume an index group
;
; ************************************************************************************************

OutputIndexGroup:
		stz 	IndexCount 					; count of number of indices.
_OIGNext:
		jsr 	CompileExpressionAt0 		; get a dimension
		and 	#NSSTypeMask 				; check it is numeric
		cmp 	#NSSIFloat
		bne 	_OIGType
		inc 	IndexCount 					; bump the counter.
		jsr 	LookNextNonSpace 			; does a , follow ?
		cmp 	#","
		bne 	_OIGCheckEnd
		jsr 	GetNext 					; consume comma
		bra 	_OIGNext 					; get next dimension
_OIGCheckEnd:
		jsr 	CheckNextRParen 			; check and consume )
		lda 	IndexCount
		jsr 	PushIntegerA 				; compile the dimension count.
		rts

_OIGType:
		.error_type
		
		.send code

		.section storage
IndexCount:
		.fill 	1
		.send storage		

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		errorhandler.asm
;		Purpose:	Error handler
;		Created:	1st May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code
	
ErrorHandler:
		pla
		ply
		sta 	zTemp0
		sty 	zTemp0+1
		ldx 	#0 							; output msg to channel #0 
		ldy 	#1
_EHDisplayMsg:
		lda 	(zTemp0),y
		jsr 	XPrintCharacter
		iny
		lda 	(zTemp0),y
		bne 	_EHDisplayMsg
		lda 	#32
		jsr 	XPrintCharacter
		lda 	#64
		jsr 	XPrintCharacter
		;
		ldx 	#0 							; convert line# to string
		jsr 	FloatSetByte
		jsr 	GetLineNumber
		sta 	NSMantissa0,x
		tya
		sta 	NSMantissa1,x
		jsr 	FloatToString
		ldy 	#0 							; display that string.
		ldx 	#0
_EHDisplayLine:
		lda 	decimalBuffer,y
		jsr 	XPrintCharacter
		iny
		lda 	decimalBuffer,y
		bne 	_EHDisplayLine
		lda 	#13
		jsr 	XPrintCharacter
		jmp 	ExitCompiler
						
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
;
;	This file is automatically generated.
;
	.section code
ErrorV_range:
	jsr	ErrorHandler
	.text	"OUT OF RANGE",0
ErrorV_value:
	jsr	ErrorHandler
	.text	"BAD VALUE",0
ErrorV_syntax:
	jsr	ErrorHandler
	.text	"SYNTAX ERROR",0
ErrorV_type:
	jsr	ErrorHandler
	.text	"TYPE MISMATCH",0
ErrorV_unimplemented:
	jsr	ErrorHandler
	.text	"NOT IMPLEMENTED",0
ErrorV_assert:
	jsr	ErrorHandler
	.text	"ASSERT FAIL",0
ErrorV_line:
	jsr	ErrorHandler
	.text	"UNKNOWN LINE NUMBER",0
ErrorV_internal:
	jsr	ErrorHandler
	.text	"INTERNAL ERROR",0
ErrorV_divzero:
	jsr	ErrorHandler
	.text	"DIVIDE BY ZERO",0
ErrorV_structure:
	jsr	ErrorHandler
	.text	"STRUCTURE IMBALANCE",0
ErrorV_stop:
	jsr	ErrorHandler
	.text	"PROGRAM STOPPED",0
ErrorV_data:
	jsr	ErrorHandler
	.text	"OUT OF DATA",0
ErrorV_undeclared:
	jsr	ErrorHandler
	.text	"UNKNOWN ARRAY",0
ErrorV_redefine:
	jsr	ErrorHandler
	.text	"ARRAY REDEFINED",0
ErrorV_index:
	jsr	ErrorHandler
	.text	"BAD ARRAY INDEX",0
ErrorV_memory:
	jsr	ErrorHandler
	.text	"OUT OF MEMORY",0
ErrorV_channel:
	jsr	ErrorHandler
	.text	"INPUT/OUTPUT ERROR",0
	.send code
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		expression.asm
;		Purpose:	Expression evaluator
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Compile expression precedence A/0
;
; ************************************************************************************************

CompileExpressionAt0:
		lda 	#0
CompileExpressionAtA:
		pha  								; save level
		jsr 	CompileTerm 				; compile a term.
		plx 								; get level back into X
		;
		;		Expression main loop - X is the precedence level, A the type.
		;
_ECALoop:				
		pha 								; save type on stack.
		jsr 	LookNextNonSpace 			; get the next character
		cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
		bcc 	_ECAExit
		cmp 	#C64_LESS+1
		bcc 	_ECAHaveToken
_ECAExit:
		pla 								; throw type off stack
		rts
		;
		;		Have a partial token - check precedence (because the >= <= <> precedence is the same as < and >)
		;
_ECAHaveToken:		
		stx 	zTemp0 						; save current precedence in zTemp0
		tax 								; X contains the operator token

		lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
		cmp 	zTemp0 						; if < then exit
		bcc 	_ECAExit
		sta 	zTemp0+1 					; save the precedence of the operator.
		jsr 	GetNext 					; consume the token.
		;
		;		Now check for >= <= <>
		;
		cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
		beq 	_ECAGreaterCheck
		cpx 	#C64_LESS
		bne 	_ECAHaveFullToken
		;
		jsr 	LookNext 					; checks for < (<= or <>)
		cmp 	#C64_GREATER 				; <> is 2 on from <
		beq	 	_ECAToNotEqual
		cmp 	#C64_EQUAL 					; <= is 3 on from <
		bne 	_ECAHaveFullToken
		bra 	_ECAAddEqual

_ECAGreaterCheck: 							; checks for > (>=)		
		jsr 	LookNext
		cmp 	#C64_EQUAL
		bne 	_ECAHaveFullToken
_ECAAddEqual:
		inx 								; > => >= and < to <= is three tokens on.
_ECAToNotEqual:		
		inx
		inx
		jsr 	GetNext 					; consume the = or > in >= <= <>		
_ECAHaveFullToken:		
		;
		;		Check for + string => concat
		;
		cpx 	#C64_PLUS
		bne 	_ECANotConcat
		pla 								; get type back
		pha
		and 	#NSSTypeMask
		cmp 	#NSSString
		bne 	_ECANotConcat
		ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
_ECANotConcat:		
		;
		;		Now have the correct token in X.
		;
		phx 								; save operator on the stack
		ldx 	zTemp0 						; push current precedence on the stack
		phx
		;
		;		Evaluate the RHS
		;
		lda 	zTemp0+1 					; get precedence of operator
		inc 	a
		jsr 	CompileExpressionAtA 		; and compile at the next level up.
		sta 	zTemp0 						; save type in zTemp0
		;
		plx 								; restore current precedence in X

		pla 								; restore operator
		sta 	zTemp0+1 					; save it in zTemp0+1.
		;
		;		Check if we need f.cmp or s.cmp
		;
		cmp 	#C64_GREATER 				; check for not compare
		bcc 	_ECANotCompare
		cmp 	#C64_GREATER+6
		bcs 	_ECANotCompare
		ply 								; get type into Y
		phy 
		pha 								; save operator

		tya 								; get type
		ldy 	#PCD_SCMD_CMP 				; Y is the token to use
		and 	#NSSTypeMask 				
		cmp 	#NSSString
		beq 	_ECANotString
		ldy 	#PCD_FCMD_CMP
_ECANotString:		
		tya									; output token Y
		jsr 	WriteCodeByte
		pla 								; restore operator.
_ECANotCompare:		
		;
		;		Compile the operator, which may be wrong (e.g. multiplying strings)
		;
		clc 								; convert to P-Code and compile.
		adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
		jsr 	WriteCodeByte
		;
		;		Check the types match
		;
		pla 								; type of current result
		eor 	zTemp0 						; check compatible with r-expr type
		and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
		bne		_ECAType
		;
		lda 	zTemp0 						; get type back
		cmp 	#NSSString 					; if it is a number, then all operators work.
		bne 	_ECAGoLoop 			
		;
		;		For strings only, check the command is valid (e.g. only + and comparators)
		;
		lda 	zTemp0+1 					; check operator is + or comparator
		cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
		beq 	_ECAOkayString 				; (this is post conversion)

		cmp 	#C64_GREATER 				; must be a comparison then.
		bcc 	_ECAType
		cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
		bcs 	_ECAType
		lda 	#NSSIFloat 					; compare returns number.
		jmp 	_ECALoop

_ECAType: 									; types mixed ?
		.error_type

_ECAOkayString:		
		lda 	#NSSString 					; current is string, go round again.
_ECAGoLoop:		
		jmp 	_ECALoop

; ************************************************************************************************
;
;										Operator precedence table
;
; ************************************************************************************************

PrecedenceTable:
		.byte 	3 					; '+'
		.byte 	3 					; '-'
		.byte 	4 					; '*'
		.byte 	4 					; '/'
		.byte 	5 					; '^'
		.byte 	1 					; 'and'
		.byte 	0 					; 'or'
		.byte 	2 					; '>'
		.byte 	2 					; '='
		.byte 	2 					; '<'
		.byte 	2 					; '>='
		.byte 	2 					; '<='
		.byte 	2 					; '<>'

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		findvar.asm
;		Purpose:	Find variable.
;		Created:	25th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;		  XY contains a variable name. Find it, returning address in YXA and CS if found
;		
;					  Returns $8000 > for special variables TI ($8000) TI$($C001)
;
; ************************************************************************************************

		.section code

FindVariable:
		stx 	zTemp1 						; save name.
		sty 	zTemp1+1
		;
		;		Check for TI $1409 and TI$ $5409 which return 6 and 8 as addresses.
		;
_IVCheckSpecial:		
		cpy 	#$09	 					; both end $09 e.g. I
		bne 	_IVStandard
		cpx 	#$14 						; TI is $14
		beq 	_IVTIFloat
		cpx 	#$54 						; TI$ is $54
		bne 	_IVStandard
		ldy 	#$C0 						; TI$ returns string $C001
		ldx 	#$01
		lda 	#NSSString
		sec
		rts
_IVTIFloat: 								; TI returns ifloat at $8000
		ldy 	#$80
		ldx 	#$00
		lda 	#0
		sec
		rts
		;
		;		Not TI or TI$
		;
_IVStandard:
		.set16 	zTemp0,WorkArea 			; start scanning from here.
		.storage_access
_IVCheckLoop:
		lda 	(zTemp0) 					; finished ?
		beq  	_IVNotFound 				; if so, return with CC.
		;
		ldy 	#1 							; match ?
		lda 	(zTemp0),y
		cmp 	zTemp1
		bne	 	_IVNext
		iny
		lda 	(zTemp0),y
		cmp 	zTemp1+1
		beq 	_IVFound
_IVNext: 									; go to next
		clc
		lda 	zTemp0
		adc 	(zTemp0)
		sta 	zTemp0
		bcc 	_IVCheckLoop
		inc 	zTemp0+1
		bra 	_IVCheckLoop
		;
_IVFound:		
		ldy 	#3 							; get address into YX
		lda 	(zTemp0),y
		tax
		iny
		lda 	(zTemp0),y
		pha
		iny
		lda 	(zTemp0),y
		ply
		.storage_release
		sec
		rts

_IVNotFound:
		.storage_release
		ldx 	zTemp1 						; get variable name back
		ldy 	zTemp1+1
		clc
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		fixbranches.asm
;		Purpose:	Fix up GOTO and GOSUB commands
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Fix up GOTO and GOSUB, and VARSPACE
;
; ************************************************************************************************

FixBranches:
		jsr 	OUTPUTRewind 				; back to the start of the *object* code.
_FBLoop:
		lda 	(objPtr) 					; get the next one.
		cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
		beq 	_FBFixGotoGosub
		cmp 	#PCD_CMD_GOSUB
		beq 	_FBFixGotoGosub
		cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
		beq 	_FBFixGotoGosub
		cmp 	#PCD_CMD_GOTOCMD_Z 
		beq 	_FBFixGotoGosub
		cmp 	#PCD_CMD_VARSPACE
		beq 	_FBFixVarSpace
_FBNext:		
		jsr 	MoveObjectForward 			; move forward in object code.
		bcc 	_FBLoop 					; not finished
_FBExit:		
		rts
;
;		Found GOTO/GOSUB - look it up in the line# table and fix it up.
;
_FBFixGotoGosub:
		ldy 	#1 							; if page is currently $FF
		lda 	(objPtr),y 					; then patch else leave.
		cmp 	#$FF
		bne 	_FBNext

		ldy 	#2							; line number in YA
		lda 	(objPtr),y
		pha
		iny
		lda 	(objPtr),y
		tay
		pla
		jsr 	STRFindLine			 		; find where it is X:YA
		bcc 	_FBFFound 					; not found, so must be >
		pha
		lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
		cmp 	#PCD_CMD_GOTOCMD_Z
		bne 	_FBFFail
		pla

_FBFFound:		
		jsr 	STRMakeOffset 				; make it an offset from X:YA
		
		phy	 								; patch the GOTO/GOSUB
		pha

		ldy 	#1
		txa
		sta 	(objPtr),y

		iny
		pla
		sta 	(objPtr),y

		iny
		pla
		sta 	(objPtr),y
		bra 	_FBNext

_FBFFail:
		ldy 	#2
		lda 	(objPtr),y
		sta 	currentLineNumber
		iny
		lda 	(objPtr),y
		sta 	currentLineNumber+1
		.error_line

;
;		Found VarSpace, fix up with free space after variables
;
_FBFixVarSpace:
		ldy 	#1
		lda 	freeVariableMemory
		sta 	(objPtr),y
		iny
		lda 	freeVariableMemory+1
		sta 	(objPtr),y
		bra 	_FBNext

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		for.asm
;		Purpose:	FOR compile
;		Created:	20th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Compile FOR command
;
;				Creates [Initial] Index! [Reference|Type] [Terminal] [Step] FOR
;
; ************************************************************************************************

CommandFOR: 
		;
		;		FOR [variable]
		;
		jsr 	GetNextNonSpace 			; first letter of index variable, should be.
		jsr 	CharIsAlpha 				; if not alpha , error
		bcc 	_CFFail
		jsr 	GetReferenceTerm 			; figure out the reference.

		pha 								; save type
		and 	#NSSTypeMask 				; check it is numeric
		cmp 	#NSSIFloat 					
		bne 	_CFFail
		;
		; 		= [Start]
		;
		phy 								; save reference on the stack
		phx
		lda 	#C64_EQUAL 					; check for equal.
		jsr 	CheckNextA
		jsr 	CompileExpressionAt0 		; initial value
		plx 								; get reference back.
		ply
		phy
		phx
		sec 								; set initial value.
		jsr 	GetSetVariable
		;
		;		Push reference on the stack, Int16 flag in Bit15
		;
		plx
		ply
		pla
		and 	#NSSIInt16 	
		beq 	_CFNotInt16
		tya
		ora 	#$80
		tay
_CFNotInt16:
		txa 								; reference in YA
		jsr 	PushIntegerYA
		;
		;		TO [End]
		;
		lda 	#C64_TO
		jsr 	CheckNextA
		jsr 	CompileExpressionAt0 		; terminal value
		and 	#NSSTypeMask 				; check it is numeric
		cmp 	#NSSIFloat 					
		bne 	_CFFail
		;
		;		Optional STEP [n]
		;
		jsr 	LookNextNonSpace 			; followed by STEP
		cmp 	#C64_STEP
		bne 	_CFNoStep
		;
		jsr 	GetNext 					; consume it.
		jsr 	CompileExpressionAt0 		; terminal value
		and 	#NSSTypeMask 				; check it is numeric
		cmp 	#NSSIFloat 					
		bne 	_CFFail
		bra 	_CFParametersDone
		;
_CFNoStep:
		lda 	#1 							; default STEP e.g. 1
		jsr 	PushIntegerA
_CFParametersDone:		
		lda 	#PCD_FOR  					; compile FOR word.
		jsr 	WriteCodeByte
		rts



_CFFail:
		.error_syntax

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		forward.asm
;		Purpose:	Move object pointer forward
;		Created:	18th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Move objPtr forwards. CS if end
;
; ************************************************************************************************

MoveObjectForward:

		lda 	(objPtr) 					; get next
		
		cmp 	#$FF  						
		beq 	_MOFEnd

		cmp 	#$40 						; 00-3F
		bcc 	_MOFAdvance1 				; forward 1

		ldy 	#2 							; 40-6F
		cmp 	#$70 						; forward 2
		bcc 	_MOFAdvanceY 				

		cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
		bcc 	_MOFAdvance1 				; forward 1

		tay 								; read the size.
		lda 	MOFSizeTable-PCD_STARTSYSTEM,y
		tay
		iny 								; add 1 for the system token.
		bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.

		ldy 	#1 							; get length byte
		lda 	(objPtr),y
		tay 								; into Y.

		clc
		lda 	objPtr						; add 2 to the object pointer
		adc 	#2
		sta 	objPtr
		bcc 	_MOFNoCarry1
		inc 	objPtr+1
_MOFNoCarry1:		
		bra 	_MOFAdvanceY

_MOFAdvance1:
		ldy 	#1
_MOFAdvanceY:				
		tya 								; add X to objPtr
		clc
		adc 	objPtr
		sta 	objPtr
		bcc 	_MOFNoCarry2
		inc 	objPtr+1
_MOFNoCarry2:		
		clc 								; not completed.
		rts
		;
		;		At the end so advance past $FF end marker and return CS.
		;
_MOFEnd:
		inc 	objPtr
		bne 	_MOFENoCarry
		inc 	objPtr+1
_MOFENoCarry:
		sec
		rts		

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		fromram.asm
;		Purpose:	Read input data from RAM appended to end of compiler.
;		Created:	8th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Open/Close the input system
;
; ************************************************************************************************

INPUTOpen:
		.set16 	srcInputPtr,EndProgram+2 	; the current read point.		
INPUTClose:
		rts
		
; ************************************************************************************************
;
;								Get the next character.
;
; ************************************************************************************************

INPUTGet:
		lda 	(srcInputPtr)
		inc 	srcInputPtr
		bne 	_IGSkip
		inc 	srcInputPtr+1
_IGSkip:
		rts

		.send code

		.section zeropage
srcInputPtr: 								; data from here
		.fill 	2
		.send zeropage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		functions.asm
;		Purpose:	FNx code
;		Created:	1st May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										FN handler
;
; ************************************************************************************************

FNCompile:
		;
		;		Identify FNxx(
		;
		jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
		jsr 	ExtractVariableName 
		cpx 	#0
		bpl 	_FNError
		;
		txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
		and 	#$7F
		tax
		tya
		ora 	#$80
		tay
		;
		;		Check to see if it is defined.
		;
		jsr 	FindVariable				; does it already exist ?
		bcc 	_FNError 					; no.
		jsr 	STRMakeOffset 				; convert to a relative address.

		cmp 	#0 							; fix up.
		bne 	_FNNoBorrow
		dey
_FNNoBorrow:
		dec 	a

		phy 								; save location of routine on stack.
		pha
		phx
		;
		;		Handle <expression>)
		;
		jsr 	CompileExpressionAt0
		jsr 	CheckNextRParen
		;
		;		Compile routine call
		;
		lda 	#PCD_CMD_GOSUB
		jsr 	WriteCodeByte
		pla
		jsr 	WriteCodeByte
		pla
		jsr 	WriteCodeByte
		pla
		jsr 	WriteCodeByte

		clc
		rts

_FNError:
		.error_value
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		gendata.asm
;		Purpose:	Generation data files
;		Created:	16th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

	
; ************************************************************************************************
;
;			Generator tables. Apologies for messy way of including those for alt systems
;
; ************************************************************************************************

CommandTables:
