;
;	This file is automatically generated
;
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		data.inc
;		Purpose:	iFloat32 data.
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;										Stack Workspace
;
; ************************************************************************************************
;
;										   Status Bits
;
; 	bit 7 	: sign of mantissa (if float,0 otherwise)
; 	bit 6,5 : 00 (float, 5/6 byte if reference) type 01 (integer, 2 byte if reference) 
;			  type 1x (string) 0x (32 bit iFloat)
;
; ************************************************************************************************
;
;							The number stack (works up from zero)
;
; ************************************************************************************************

		.section zeropage

;
;		Size of stack
;
MathStackSize = 12

;
;		Constants used.
;
NSSString = $40 							; string vs typemask
NSSIFloat = $00 							; ifloat vs typemask
NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
NSSTypeMask = $40 					
NSSArray = $80  							; array (in variable code)

;
;		Stack data.
;
NSStatus: 									; Status bits of stack.
		.fill 	MathStackSize
NSMantissa0: 								; Mantissa on stack (address in 0,1 for string)
		.fill 	MathStackSize 				; (this is my integer mantissa system)
NSMantissa1: 								; the order of the mantissa elements is required.
		.fill 	MathStackSize
NSMantissa2:
		.fill 	MathStackSize
NSMantissa3:
		.fill 	MathStackSize
NSExponent: 								; Exponent , 0 = Mantissa is integer
		.fill 	MathStackSize

		.send zeropage


; ************************************************************************************************
;
;										Non Zero Page Data
;
; ************************************************************************************************

		.section storage
numberBuffer:
		.fill 	34
		.send 	storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		addsub.asm
;		Purpose:	Add/Subtract S[X+1] to S[X]
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									 Subtract FPB from FPA
;
; ************************************************************************************************

FloatSubtract:
		lda 	NSStatus,x 					; negate top of stack
		eor 	#$80
		sta 	NSStatus,x					; and fall through.

; ************************************************************************************************
;
;							Add FPB to FPA, result not normalised
;									    (see binary.py)
;
; ************************************************************************************************

FloatAdd:
		dex
		lda 	NSExponent,x 				; can use optimised.
		ora 	NSExponent+1,x
		ora 	NSMantissa3,x
		ora 	NSMantissa3+1,x		
		bne 	_FAUseFloat
		jsr 	FloatInt32Add 				; use the int32 one.
		rts

_FAUseFloat:	
		jsr 	FloatNormalise 				; normalise S[X]
		beq 	_FAReturn1

		inx 								; normalise S[X+1]
		jsr 	FloatNormalise
		dex
		cmp 	#0
		beq 	_FAExit 					; if so, just return A

		lda 	NSExponent,x 				; are the exponents the same ?
		cmp 	NSExponent+1,x
		beq 	_FAExponentsEqual

		;
		;		Work out the larger exponent, both at this level as normalised
		; 		use signed compare, result in Y
		;
		lda 	NSExponent,x 				; work out the larger exponent
		tay
		sec 								; do a signed comparison of the exponents.
		sbc 	NSExponent+1,x
		bvc 	_FANoSignedChange
		eor 	#$80
_FANoSignedChange:							; if bit 7 set then Exp[X] < Exp[X+1]
		and 	#$80
		bpl 	_FAHaveMax		 			
		ldy 	NSExponent+1,x 				
_FAHaveMax:			
		jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
		inx
		jsr 	_FAShiftToExponent 
		dex
		;
		;		Exponents are now equal, so we can add or subtract the mantissae
		;
_FAExponentsEqual:		
		lda 	NSStatus,x 					; are the signs the same
		eor 	NSStatus+1,x
		bmi 	_FADifferentSigns
		;
		;		"Add" code, e.g. both have same sign
		;
		jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
		lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
		bpl 	_FAExit 					; if no, we are done.
		jsr 	FloatShiftRight 				; shift A right, renormalising it.
		inc 	NSExponent,x 				; bump the exponent and exit
		bra 	_FAExit
		;
		;		"Subtract" code, e.g. both have different sign.
		;
_FADifferentSigns:
		jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
		lda 	NSMantissa3,x 				; is the result negative ?
		bpl 	_FACheckZero 				; if no, check for -0
		jsr 	FloatNegate 					; netate result
		jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
_FACheckZero:		
		jsr 	FloatIsZero	 				; check for -0
		bne 	_FAExit
		stz 	NSStatus,x
		bra 	_FAExit

_FAReturn1:									; copy slot X+1 into slot X
		lda 	NSMantissa0+1,x 			; called when S(X) is zero.
		sta 	NSMantissa0,x
		lda 	NSMantissa1+1,x
		sta 	NSMantissa1,x
		lda 	NSMantissa2+1,x
		sta 	NSMantissa2,x
		lda 	NSMantissa3+1,x
		sta 	NSMantissa3,x
		lda 	NSExponent+1,x 				
		sta 	NSExponent,x
		lda 	NSStatus+1,x
		sta 	NSStatus,x 			
_FAExit:
		rts

; ************************************************************************************************
;
;										Helper : Shift X to Exponent Y.
;
; ************************************************************************************************

_FAShiftToExponent:
		;
		; 	Possible byte shift optimise here, but is it worth it ?
		;
_FAShiftToExponent2:
		tya 								; compare Y to exponent  								
		cmp 	NSExponent,x 				; reached the exponent required ?
		beq 	_FASEExit 					; exit if so.
		jsr 	FloatShiftRight	 			; shift the mantissa right
		inc 	NSExponent,x 				; increment exponent
		bra 	_FAShiftToExponent2
_FASEExit:
		rts		

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		compare.asm
;		Purpose:	X[S] to X[S+1]
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;										Compare checks
;
; ************************************************************************************************

CompareEqual:
		lda 	NSMantissa0,x
		bne 	ReturnFalse

ReturnTrue:
		lda 	#1
		sta 	NSMantissa0,x
		lda 	#$80
		sta 	NSStatus,x
		rts
ReturnFalse:
		stz 	NSMantissa0,x
		rts				
		
CompareNotEqual:
		lda 	NSMantissa0,x
		bne 	ReturnTrue
		bra 	ReturnFalse

CompareLess:
		lda 	NSMantissa0,x
		cmp 	#$FF
		beq 	ReturnTrue
		bra 	ReturnFalse

CompareGreater:
		lda 	NSMantissa0,x
		cmp 	#$01
		beq 	ReturnTrue
		bra 	ReturnFalse

CompareLessEqual:
		lda 	NSMantissa0,x
		cmp 	#$01
		bne 	ReturnTrue
		bra 	ReturnFalse

CompareGreaterEqual:
		lda 	NSMantissa0,x
		cmp 	#$FF
		bne 	ReturnTrue
		bra 	ReturnFalse
		
; ************************************************************************************************
;
;						Compare Stack vs 11th. Return 255,0 or 1 in A
;
; ************************************************************************************************

FloatCompare:	
		lda 	NSExponent,x 				; float comparison.
		ora 	NSExponent-1,x 				; integer if both integer.
		pha

		jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
		;
		pla
		bne 	_FCCompareFloat 			
		;
		;		Integer comparison, check for *exactly* 0.
		;
		lda 	NSMantissa0,x
		ora 	NSMantissa1,x
		ora 	NSMantissa2,x
		ora 	NSMantissa3,x
		beq 	_FCExit 					; if zero, return zero
		bra 	_FCSign

_FCCompareFloat:	
		;
		;		At this point the mantissae are equal. If we were comparing integers
		; 		then this should be zero - if float we ignore the lowest 12 bits, which gives
		;		an approximation for equality of 1 part in 2^18
		; 		This is about 1 part in 500,000 - so it is "almost equal".
		;			
		lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
		and 	#$F0
		ora 	NSMantissa2,x
		ora 	NSMantissa3,x
		beq 	_FCExit 					; zero, so approximately identical
		;
		;		Not equal, so get result from sign.
		;
_FCSign:		
		lda 	#1 							; return +1 if result>0
		bit 	NSStatus,x
		bpl 	_FCExit
_FCNegative:		
		lda 	#$FF 						; and return -1 if result<0
_FCExit:
		jsr 	FloatSetByte 				; set the result 255,0,1
		rts


		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
;
;	This file is automatically generated.
;
.section code
FloatScalarTable:
	.dword $66666666 ; 0.1
	.byte $de
	.dword $51eb851f ; 0.01
	.byte $db
	.dword $4189374c ; 0.001
	.byte $d8
	.dword $68db8bac ; 0.0001
	.byte $d4
	.dword $53e2d624 ; 1e-05
	.byte $d1
	.dword $431bde83 ; 1e-06
	.byte $ce
	.dword $6b5fca6b ; 1e-07
	.byte $ca
	.dword $55e63b89 ; 1e-08
	.byte $c7
	.dword $44b82fa1 ; 1e-09
	.byte $c4
	.dword $6df37f67 ; 1e-10
	.byte $c0
	.dword $57f5ff86 ; 1e-11
	.byte $bd
.send code
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		divide.asm
;		Purpose:	Divide Stack[x] by Stack[x+1] floating point
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;							Floating point division (CS if Div Zero)
;
; ************************************************************************************************

FloatDivide:	
		pha
		jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
		dex
		cmp 	#0
		beq 	_FDZero 					

		jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
		beq 	_FDExit 					; return zero if zero (e.g. zero/something)

		jsr 	Int32ShiftDivide 			; do the shift division for dividing.
		jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
		jsr		FloatNormalise 				; renormalise
		jsr 	FloatCalculateSign 			; calculate result sign

		lda 	NSExponent,x 				; calculate exponent
		sec
		sbc 	NSExponent+1,x
		sec
		sbc 	#30
		sta 	NSExponent,x
_FDExit:
		pla
		clc
		rts
_FDZero:
		pla
		sec
		rts

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		divide.asm
;		Purpose:	32x32 bit integer division (2 variants)
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									Integer Division
;
; ************************************************************************************************

DivideInt32:
		jsr 	FloatIntegerPart 			; make both integers	
		dex
		jsr 	FloatIntegerPart
		jsr 	Int32Divide 				; divide
		jsr 	NSMCopyPlusTwoToZero 		; copy result
		jsr 	FloatCalculateSign 			; calculate result sign
		clc
		rts

NSMCopyPlusTwoToZero:		
		lda 	NSMantissa0+2,x 			; copy result down from +2
		sta 	NSMantissa0,x
		lda 	NSMantissa1+2,x
		sta 	NSMantissa1,x
		lda 	NSMantissa2+2,x
		sta 	NSMantissa2,x
		lda 	NSMantissa3+2,x
		sta 	NSMantissa3,x
		rts
		
; ************************************************************************************************
;
;		32 bit unsigned division of FPA Mantissa A by FPA Mantissa B, 32 bit result.
;									(see divide.py)
;
; ************************************************************************************************

Int32Divide:
		pha 								; save AXY
		phy
		jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
		jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero

		ldy 	#32 						; loop 32 times
_I32DivideLoop:
		inx
		inx
		jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
		dex
		dex
		jsr 	FloatRotateLeft
		;		
		jsr 	FloatDivideCheck 			; check if subtract possible
		bcc 	_I32DivideNoCarryIn
		inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
_I32DivideNoCarryIn:
		dey 								; loop round till division completed.
		bne 	_I32DivideLoop

		ply 								; restore AXY and exit
		pla
		clc
		rts

; ************************************************************************************************
;
;		Shifted Division used in Floating Point Divide - does (a << 30) // b
;									(see divide.py)
;
; ************************************************************************************************

Int32ShiftDivide:
		pha 								; save AY
		phy

		inx 								; clear S[X+2]
		inx
		jsr 	FloatSetZero
		dex
		dex

		ldy 	#31 						; loop 31 times.
_I32SDLoop:
		jsr 	FloatDivideCheck 			; check if subtract possible
		inx
		inx
		jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
		dex
		dex
		jsr 	FloatRotateLeft
		dey 	 							; do 31 times
		bne 	_I32SDLoop
		ply 								; restore AY and exit
		pla
		rts

; ************************************************************************************************
;
;							Do the division - check subtraction code
;
;			If can subtract FPB from FPA.Upper, do so, return carry set if was subtracted
;			Common code to both divisions.
;
; ************************************************************************************************

FloatDivideCheck:
		jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
		bcs 	_DCSExit 					; if carry set, then could do, exit
		jsr 	FloatAddTopTwoStack 		; add it back in
		clc 								; and return False
_DCSExit:
		rts		

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		fractional.asm
;		Purpose:	Extract fractional part 
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									Get fractional part of Stack,X
;
; ************************************************************************************************

FloatFractionalPart:
		phy

		lda 	NSStatus,x 					; take absolute value 
		and 	#$7F
		sta 	NSStatus,x
		jsr 	FloatNormalise

		lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
		sec
		sbc 	#$E0
		bcc 	_FFPExit 					; already fractional

		cmp 	#32 						; will be zero as blanking 32+ digits.
		bcs 	_FFPZero
		;
		tay 								; put count to do in Y
		;
		lda 	NSMantissa3,x 				; do each in turn.
		jsr 	_FFPPartial
		sta 	NSMantissa3,x

		lda 	NSMantissa2,x
		jsr 	_FFPPartial
		sta 	NSMantissa2,x

		lda 	NSMantissa1,x
		jsr 	_FFPPartial
		sta 	NSMantissa1,x

		lda 	NSMantissa0,x
		jsr 	_FFPPartial
		sta 	NSMantissa0,x
		
		jsr 	FloatIsZero 					; zeroed check.
		bne 	_FFPExit

_FFPZero:
		jsr 	FloatSetZero
_FFPExit:	
		jsr 	FloatNormalise
		ply	
		rts		
;
;		Clear up to 8 bits from A from the left, subtract from the count remaining in Y
;
_FFPPartial:
		cpy 	#0 							; no more to do
		beq 	_FFFPPExit
		cpy 	#8 							; whole byte to do ?
		bcs 	_FFFPPWholeByte 
		;
		phy
_FFFPPLeft:
		asl 	a
		dey 	
		bne 	_FFFPPLeft		
		ply
_FFFPPRight:
		lsr 	a
		dey 	
		bne 	_FFFPPRight
		bra 	_FFFPPExit

_FFFPPWholeByte:
		tya 								; subtract 8 from count
		sec
		sbc 	#8
		tay
		lda 	#0 							; and clear all
_FFFPPExit:		
		rts

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		integer.asm
;		Purpose:	Make FPA Denormalised integer
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									Make FPA into an integer
;
; ************************************************************************************************

FloatIntegerPart:
		pha
		;
		lda 	NSExponent,x 				; is it integer already ?
		beq 	_FIPExit 					; if so do nothing
		jsr 	FloatIsZero 				; is it zero ?
		beq 	_FIPZero 					; if so return zero.
		;
		jsr 	FloatNormalise 				; normalise
		beq 	_FIPZero 					; normalised to zero, exit zero
		;
_FIPShift:
		lda 	NSExponent,x 				; if Exponent >= 0 exit.
		bpl 	_FIPCheckZero		 		

		jsr 	FloatShiftRight 			; shift mantissa right
		inc 	NSExponent,x 				; bump exponent 
		bra 	_FIPShift

_FIPCheckZero:
		jsr 	FloatIsZero 				; avoid -0 problem
		bne 	_FIPExit 					; set to zero if mantissa zero.		
_FIPZero:
		jsr 	FloatSetZero
_FIPExit:
		pla
		rts		

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		integerdown.asm
;		Purpose:	Make FPA Denormalised integer, rounded down.
;		Created:	14th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;							Make FPA into an integer, rounded down
;
; ************************************************************************************************

FloatIntegerPartDown:
		pha
		phy
		;
		lda 	NSExponent,x 				; is it integer already ?
		beq 	_FIPExit 					; if so do nothing
		jsr 	FloatIsZero 				; is it zero ?
		beq 	_FIPZero 					; if so return zero.
		;
		jsr 	FloatNormalise 				; normalise
		beq 	_FIPZero 					; normalised to zero, exit zero
		ldy 	#0 							; reset the count of bits.
		;
_FIPShift:
		lda 	NSExponent,x 				; if Exponent >= 0 exit.
		bpl 	_FIPCheckDown

		jsr 	FloatShiftRight 			; shift mantissa right
		bcc 	_FIPNoFrac 					; shifted a zero out ?
		iny
_FIPNoFrac:		
		inc 	NSExponent,x 				; bump exponent 
		bra 	_FIPShift

_FIPCheckDown:
		cpy 	#0 							; were there any fractional bits.
		beq 	_FIPCheckZero
		bit 	NSStatus,x 					; +ve
		bpl 	_FIPCheckZero 
		inx 								; -ve so round *down*.
		lda 	#1
		jsr 	FloatSetByte
		jsr 	FloatNegate
		jsr 	FloatAdd
_FIPCheckZero:
		jsr 	FloatIsZero 				; avoid -0 problem
		bne 	_FIPExit 					; set to zero if mantissa zero.		
_FIPZero:
		jsr 	FloatSetZero
_FIPExit:
		ply
		pla
		rts		

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		mult8x8.asm
;		Purpose:	8x8 integer multiplication
;		Created:	20th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							S[X] * S[X+1] where 8x8 unsigned
;
; ************************************************************************************************

FloatInt8Multiply:	
		phy
		lda 	NSMantissa0,x 				; right shifted multiplier in Y
		tay
		stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
_FI8MLoop:
		tya 								; shift right shifter right into carry
		lsr 	a
		tay		
		bcc 	_FI8MNoAdd

		clc
		lda 	NSMantissa0,x
		adc 	NSMantissa0+1,x
		sta 	NSMantissa0,x
		lda 	NSMantissa1,x
		adc 	NSMantissa1+1,x
		sta 	NSMantissa1,x
_FI8MNoAdd:
		asl 	NSMantissa0+1,x 			; shift adder left
		rol 	NSMantissa1+1,x
		cpy 	#0
		bne 	_FI8MLoop 					; until right shifter zero.
		ply
		rts
		
		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		multiply.asm
;		Purpose:	Multiply Stack[x] by Stack[x+1] floating point
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									Floating point multiplication
;
; ************************************************************************************************

FloatMultiply:	
		dex
		lda 	NSExponent,x 				; can use optimised ?
		ora 	NSExponent+1,x
		ora 	NSMantissa3,x
		ora 	NSMantissa3+1,x		
		bne 	_FMUseFloat

		lda 	NSStatus,x 					; check if it is 8 bit unsigned
		ora 	NSStatus+1,x		
		and 	#$80
		ora 	NSMantissa3,x
		ora 	NSMantissa2,x
		ora 	NSMantissa1,x
		ora 	NSMantissa3+1,x
		ora 	NSMantissa2+1,x
		ora 	NSMantissa1+1,x
		bne 	_FMInt32

		jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
		rts

_FMInt32:
		jsr 	FloatMultiplyShort			; use the int32 one.
		clc 								; fix it up if gone out of range
		adc 	NSExponent,x
		sta 	NSExponent,x
		rts

_FMUseFloat:
		jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
		beq 	_FDExit 					; return zero if zero (e.g. zero*something)
		inx 
		jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
		dex
		cmp 	#0
		beq 	_FDSetZero 					

		jsr 	FloatMultiplyShort 			; calculate the result.		
		adc 	NSExponent,x 				; calculate exponent including the shift.
		clc
		adc 	NSExponent+1,x
		sta 	NSExponent,x
		bra 	_FDExit

_FDSetZero:
		jsr 	FloatSetZero 				; return 0
_FDExit:
		jsr 	FloatNormalise 				; normalise the result
		rts

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		multiply.asm
;		Purpose:	32x32 bit integer multiplication, 32 bit result with rounding and shift
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;		Multiply stack entry X by stack entry X+1. If necessary right shifts. Returns on 
;		exit the number of left shifts required to fix it up. Calculates sign of result.
;
;		Does not change exponent.
;
; ************************************************************************************************

FloatMultiplyShort:
		phy 								; save Y
		jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
		jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
		ldy 	#0 							; Y is the shift count.
		;
		;		Main multiply loop.
		;				
_I32MLoop:
		lda 	NSMantissa0+2,x 			; check S[X+2] is zero
		ora 	NSMantissa1+2,x
		ora 	NSMantissa2+2,x
		ora 	NSMantissa3+2,x
		beq 	_I32MExit 					; exit if zero

		lda 	NSMantissa0+2,x 			; check LSB of n1 
		and 	#1
		beq 	_I32MNoAdd
		;
		jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
		;
		lda 	NSMantissa3,x 				; has MantissaA overflowed ?
		bpl 	_I32MNoAdd
		;
		;		Overflow. Shift result right, increment the shift count, keeping the
		; 		result in 31 bits - now we lose some precision though.
		;
_I32ShiftRight:		
		jsr 	FloatShiftRight 			; shift S[X] right
		iny 								; increment shift count
		bra 	_I32MShiftUpper 			; n2 is doubled by default.
		;
_I32MNoAdd:
		bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
		bvs 	_I32ShiftRight 				; instead.

		inx
		jsr 	FloatShiftLeft 				; shift additive S[X+1] left
		dex

_I32MShiftUpper:
		inx 								; shift S[X+2] right
		inx
		jsr 	FloatShiftRight
		dex
		dex

		bra 	_I32MLoop 					; try again.

_I32MExit:
		jsr 	FloatCalculateSign
		tya 								; shift in A
		ply 								; restore Y and exit
		rts

; ************************************************************************************************
;
;								Calculate sign from the two signs
;
; ************************************************************************************************

FloatCalculateSign:
		lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
		asl 	NSStatus,x 					; shift result left
		eor 	NSStatus+1,x
		asl 	a 							; shift bit 7 into carry
		ror 	NSStatus,x 					; shift right into status byte.
		rts

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		normalise.asm
;		Purpose:	Normalise FP value
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									  Normalise Stack[X]
;
; ************************************************************************************************

FloatNormalise:
		jsr 	FloatIsZero 				; if zero exit 
		bne 	_NSNormaliseOptimise 		; if so, normalise it.
		asl 	NSStatus,x 					; clear the sign bit.
		ror 	NSStatus,x 					; (no -0)
		lda 	#0 							; set Z flag
		rts
		;
		;		Normalise by byte if the MSB is zero we can normalise it
		;		(providing bit 7 of 11th byte is not set)
		;
_NSNormaliseOptimise:						
		lda 	NSMantissa3,x 				; upper byte zero ?
		bne 	_NSNormaliseLoop
		lda 	NSMantissa2,x 				; byte normalise
		bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2

		sta 	NSMantissa3,x
		lda 	NSMantissa1,x
		sta 	NSMantissa2,x
		lda 	NSMantissa0,x
		sta 	NSMantissa1,x
		stz 	NSMantissa0,x
		;
		lda 	NSExponent,x
		sec
		sbc 	#8
		sta 	NSExponent,x
		bra 	_NSNormaliseOptimise
		;
		;		Normalise by bit
		;
_NSNormaliseLoop:		
		bit 	NSMantissa3,x 				; bit 30 set ?
		bvs 	_NSNExit 					; exit if so with Z flag clear
		jsr 	FloatShiftLeft 				; shift mantissa left
		dec 	NSExponent,x 				; adjust exponent
		bra 	_NSNormaliseLoop
_NSNExit:
		lda 	#$FF 						; clear Z flag
		rts

		.send 	code
		
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		simple.asm
;		Purpose:	Simple binary operations add/subtract
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Macro to simplify simple handlers
;
; ************************************************************************************************

simple32 .macro
		lda		NSMantissa0,x
		\1 		NSMantissa0+1,x 	
		sta 	NSMantissa0,x
		lda		NSMantissa1,x
		\1 		NSMantissa1+1,x 	
		sta 	NSMantissa1,x
		lda		NSMantissa2,x
		\1 		NSMantissa2+1,x 	
		sta 	NSMantissa2,x
		lda		NSMantissa3,x
		\1 		NSMantissa3+1,x 	
		sta 	NSMantissa3,x
		.endm

; ************************************************************************************************
;
;								Two's complement math operators
;
; ************************************************************************************************

FloatAddTopTwoStack:		
		clc
		.simple32 adc
		rts

FloatSubTopTwoStack:		
		sec
		.simple32 sbc
		rts

; ************************************************************************************************
;
;					Optimised Binary Operators for add and subtract when integer
;
; ************************************************************************************************

FloatInt32Add:
		lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
		eor 	NSStatus+1,x
		bmi 	_DiffSigns
		jsr		FloatAddTopTwoStack
		rts
		;
_DiffSigns:		
		jsr 	FloatSubTopTwoStack 		; do a physical subtraction
		bit 	NSMantissa3,x 				; result is +ve, okay
		bpl 	_AddExit 	
		lda 	NSStatus+1,x 				; sign is that of 11th value
		sta 	NSStatus,x
		jsr 	FloatNegateMantissa 		; negate the mantissa and exit
_AddExit:
		jsr 	FloatIsZero 				; check for -0
		bne 	_AddNonZero
		stz 	NSStatus,x
_AddNonZero:		
		rts
	
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		tofloat.asm
;		Purpose:	State machine number encoding
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
ESTA_Decimal = 3 							; fractional part.

; ************************************************************************************************
;
;		Encode Number. If CS, then start a new number. Returns CS if the number is okay,
;		CC if not.
;
;		A simple state machine.
;
;		State 1 is taking in integers up to 255 - this is very quick.
; 		State 2 is taking in integers up to 4 bytes
; 		State 3 is taking in numbers after the decimal place.
;
;		Do we need a state between 1 & 2 ?
;
; ************************************************************************************************

FloatEncodeStart: 							; come here to reset the FSM.
		sec
		bra 	FloatEncodeContinue+1

FloatEncodeContinue: 						; come here to continue it.
		clc
FloatEncode:		
		php 								; save reset flag.
		cmp 	#"." 						; only accept 0-9 and .
		beq 	_ENIsOkay
		cmp 	#"0"
		bcc 	_ENBadNumber
		cmp 	#"9"+1
		bcc 	_ENIsOkay
_ENBadNumber:		
		plp 								; throw saved reset
		lda 	encodeState 				; if in decimal mode, construct final number
		cmp 	#ESTA_Decimal
		bne 	_ENFail
		jmp 	_ENConstructFinal
_ENFail:
		clc 								; not allowed
		rts
;
_ENIsOkay:		
		plp 								; are we restarting
		bcc 	_ENNoRestart

		; --------------------------------------------------------------------
		;
		;		First initialise
		;
		; --------------------------------------------------------------------

_ENStartEncode:
		cmp 	#'.'						; first is decimal place, go straight to that.
		beq 	_ENFirstDP
		and 	#15 						; put digit in mantissa, initially a single digit constant
		jsr 	FloatSetByte 				; in single byte mode.
		lda 	#ESTA_Low
		;
		;		Come here to successfully change state.
		;
_ENExitChange:
		sta 	encodeState 				; save new state		
		sec
		rts

_ENFirstDP:
		jsr 	FloatSetZero 				; clear integer part
		bra 	_ESTASwitchFloat			; go straight to float and exi

		; --------------------------------------------------------------------
		;
		;		Not restarting. Figure out what to do next
		;
		; --------------------------------------------------------------------
_ENNoRestart:		
		pha 								; save digit or DP on stack.
		lda 	encodeState 				; get current state
		cmp 	#ESTA_Low
		beq  	_ESTALowState	
		cmp 	#ESTA_High
		beq 	_ESTAHighState
		cmp 	#ESTA_Decimal
		beq 	_ESTADecimalState
		.debug 								; should not happen !
		
		; --------------------------------------------------------------------
		;
		;		Inputting to a single byte.
		;
		; --------------------------------------------------------------------

_ESTALowState:
		pla 								; get value back
		cmp 	#"."						; decimal point
		beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
		and 	#15 						; make digit
		sta 	digitTemp 					; save it.
		;
		lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
		asl 	a
		asl 	a
		adc 	NSMantissa0,x
		asl 	a
		adc 	digitTemp
		sta 	NSMantissa0,x
		cmp 	#25 						; if >= 25 cannot guarantee next will be okay
		bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
		lda 	#ESTA_High 					; so if so, switch to the high encoding state
		sta 	encodeState
_ESTANoSwitch:
		sec
		rts		

		; --------------------------------------------------------------------
		;
		;		Inputting to a the whole 4 byte mantissa
		;
		; --------------------------------------------------------------------

_ESTAHighState:
		pla 								; get value back
		cmp 	#"." 						; if DP switch to dloat
		beq 	_ESTASwitchFloat
		jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
		sec
		rts

		; --------------------------------------------------------------------
		;
		;		Entering decimal mode - still have then input digit on the stack
		;
		; --------------------------------------------------------------------

_ESTASwitchFloat:
		stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
		inx 								; zero the decimal additive.
		jsr 	FloatSetZero
		dex
		lda 	#ESTA_Decimal 				; switch to decimal mode
		bra 	_ENExitChange

		; --------------------------------------------------------------------
		;
		;		Decimal Mode
		;
		; --------------------------------------------------------------------

_ESTADecimalState:
		pla 								; digit.
		cmp 	#"." 						; fail on 11th decimal point.
		beq 	_ENFail
		;
		inx 								; put digit into fractional part of X+1
		jsr 	ESTAShiftDigitIntoMantissa
		dex
		;
		inc 	decimalCount 				; bump the count of decimals
		;
		lda 	decimalCount 				; too many decimal digits.
		cmp 	#11
		beq 	_ESTADSFail
		sec
		rts
_ESTADSFail:
		clc
		rts
		
		; --------------------------------------------------------------------
		;
		;		Build final number from components
		;
		; --------------------------------------------------------------------

_ENConstructFinal:
		lda 	decimalCount 				; get decimal count
		beq 	_ENCFExit 					; no decimals
		phy
		asl 	a 							; x 4 and CLC
		asl 	a
		adc 	decimalCount
		tay 
		;
		lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
		sta 	NSMantissa0+2,x  			; this is 10^-n
		lda 	FloatScalarTable-5+1,y
		sta 	NSMantissa1+2,x
		lda 	FloatScalarTable-5+2,y
		sta 	NSMantissa2+2,x
		lda 	FloatScalarTable-5+3,y
		sta 	NSMantissa3+2,x
		lda 	FloatScalarTable-5+4,y
		sta 	NSExponent+2,x
		stz 	NSStatus+2,x 				; make +ve
		;
		;
		inx 								; multiply decimal const by decimal scalar
		inx
		jsr 	FloatMultiply
		jsr 	FloatAdd 					; add to integer part.
		ply
_ENCFExit:
		clc 								; reject the digit.
		rts

; ************************************************************************************************
;
;			Put digit A into the mantissa at X, e.g. mantissa = mantissa x 10 + digit
;
; ************************************************************************************************

ESTAShiftDigitIntoMantissa:
		and 	#15 						; save digit
		pha

		lda 	NSMantissa3,x 				; push mantissa on stack
		pha
		lda 	NSMantissa2,x 
		pha
		lda 	NSMantissa1,x 
		pha
		lda 	NSMantissa0,x 
		pha
		jsr 	FloatShiftLeft 				; x 2
		jsr 	FloatShiftLeft 				; x 4

		clc 								; pop mantissa and add
		pla 
		adc 	NSMantissa0,x
		sta 	NSMantissa0,x
		pla
		adc 	NSMantissa1,x
		sta 	NSMantissa1,x
		pla
		adc 	NSMantissa2,x
		sta 	NSMantissa2,x
		pla
		adc 	NSMantissa3,x
		sta 	NSMantissa3,x 				; x 5
		jsr 	FloatShiftLeft 				; x 10
		;
		pla 								; add digit
		clc
		adc 	NSMantissa0,x
		sta 	NSMantissa0,x
		bcc 	_ESTASDExit
		inc 	NSMantissa1,x
		bne 	_ESTASDExit
		inc 	NSMantissa2,x
		bne 	_ESTASDExit
		inc 	NSMantissa3,x
_ESTASDExit:
		rts

		.send code

		.section storage
encodeState:	 							; which state is it in ?
		.fill 	1		
digitTemp:	 								; temp for current digit
		.fill 	1		
decimalCount:								; how many decimal places to date
		.fill 	1		
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		tostring.asm
;		Purpose:	Convert number to string
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						Convert FPA to String in ConversionBuffer
;
; ************************************************************************************************

FloatToString:
		phx
		phy 								; save code position
		sta 	decimalPlaces	 			; save number of DPs.
		stz 	dbOffset 					; offset into decimal buffer = start.

		lda 	NSStatus,x  				; is it -ve.
		bpl 	_CNTSNotNegative
		and 	#$7F 						; make +ve
		sta 	NSStatus,x
		lda 	#"-"
		bra 	_CNTMain
_CNTSNotNegative:
		lda 	#" "
_CNTMain:
		jsr 	WriteDecimalBuffer
		lda 	NSExponent,x 				; check if decimal
		beq 	_CNTSNotFloat

		inx 								; round up so we don't get too many 6.999999
		lda 	#1
		jsr 	FloatSetByte		
		lda		NSExponent-1,x
		sta 	NSExponent,x
		jsr 	FloatAdd
_CNTSNotFloat:

		jsr 	MakePlusTwoString 			; do the integer part.
		jsr 	FloatFractionalPart 		; get the fractional part
		jsr 	FloatNormalise					; normalise , exit if zero
		beq 	_CNTSExit
		lda 	#"."
		jsr 	WriteDecimalBuffer 			; write decimal place
_CNTSDecimal:
		dec 	decimalPlaces 				; done all the decimals
		bmi 	_CNTSExit
		inx 								; x 10.0
		lda 	#10
		jsr 	FloatSetByte
		jsr 	FloatMultiply
		jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
		jsr 	FloatFractionalPart 		; get the fractional part
		jsr 	FloatNormalise 				; normalise it.
		;
		lda 	NSExponent,x 				; gone to zero, exit.
		cmp 	#$D0 						; very small remainder, so don't bother.
		bcs 	_CNTSDecimal 				; keep going.
_CNTSExit:
		ply
		plx
		rts

; ************************************************************************************************
;
;		Make S[X] and integer, convert it to a string, and copy it to the decimal buffer
;		
; ************************************************************************************************

MakePlusTwoString:
		phx
		jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.		
		inx 								; access it
		inx
		jsr 	FloatIntegerPart 			; make it an integer
		lda 	#10 						; convert it in base 10
		jsr 	ConvertInt32 
		ldx	 	#0 							; write that to the decimal buffer.
_MPTSCopy:
		lda 	numberBuffer,x
		jsr 	WriteDecimalBuffer
		inx		
		lda 	numberBuffer,x
		bne 	_MPTSCopy
		plx
		rts

; ************************************************************************************************
;
;									Write A to Decimal Buffer
;		
; ************************************************************************************************

WriteDecimalBuffer:
		phx
		ldx 	dbOffset
		sta 	decimalBuffer,x
		stz 	decimalBuffer+1,x
		inc 	dbOffset
		plx
		rts

		.send 	code
		
		.section storage

decimalPlaces:
		.fill 	1
dbOffset:
		.fill 	1				
decimalBuffer:
		.fill 	32
		
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ***************************************************************************************
; ***************************************************************************************
;
;		Name : 		tostring.asm
;		Author :	Paul Robson (paul@robsons.org.uk)
;		Created : 	11th April 2023
;		Reviewed :	No
;		Purpose :	Convert Integer to String
;
; ***************************************************************************************
; ***************************************************************************************

		.section 	code

; ***************************************************************************************
;
;							Convert XA to string return in XA
;
; ***************************************************************************************

ConvertInt16:
		sta 	NSMantissa0 				; set up as 32 bit conversion
		stx 	NSMantissa1
		stz 	NSMantissa2
		stz 	NSMantissa3		
		stz 	NSStatus 					; positive integer
		ldx 	#0 							; stack level
		lda 	#10 						; base 10 decimal.
		bra 	ConvertInt32

; ***************************************************************************************
;
;						Convert string at Level X Base A
;
; ***************************************************************************************

ConvertInt32:
		phy
		ldy  	#0 							; index into buffer.
		bit 	NSStatus 					; output a - if not negative.
		bpl 	_CI32NotNeg
		pha
		lda 	#'-'
		sta 	numberBuffer,y
		iny
		pla
_CI32NotNeg:
		jsr 	_CI32DivideConvert 			; recursive conversion
		lda 	#0 							; make ASCIIZ
		sta 	numberBuffer,y
		ply
		ldx 	#numberBuffer >> 8 			; return address in XA
		lda 	#numberBuffer & $FF
		rts

_CI32DivideConvert:
		inx 								; write to next slot up
		jsr 	FloatSetByte 		 		; write the base out.
		dex
		jsr 	Int32Divide 				; divide
		;
		lda 	NSMantissa0,x 				; save remainder
		pha 

		jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
		;
		jsr 	FloatIsZero 				; is it zero ?
		beq 	_CI32NoRecurse 				; if so, don't recursively call.
		;
		lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
		jsr 	_CI32DivideConvert 			; and recusrively call.
_CI32NoRecurse:
		pla 								; remainder
		cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
		bcc 	_CI32NotHex
		adc 	#6+32
_CI32NotHex:
		adc 	#48		
		sta 	numberBuffer,y 				; write out and exit		
		iny
		rts

		.send 	code
		
; ***************************************************************************************
;
;									Changes and Updates
;
; ***************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ***************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		number.asm
;		Purpose:	Number utilities
;		Created:	11th April 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							 Negate mantissa/status/exponent value
;
; ************************************************************************************************

FloatNegate:							
		lda 	NSStatus,x 					; everything is sign/magnitude usually so just
		eor 	#$80  						; toggle the negative flag
		sta 	NSStatus,x
		rts

; ************************************************************************************************
;
;							  Negate mantissa only 2's complements
;
; ************************************************************************************************

FloatNegateMantissa:								
		sec 								; when we want an actual 32 bit 2's complement value.
		lda 	#0
		sbc 	NSMantissa0,x
		sta 	NSMantissa0,x
		lda 	#0
		sbc 	NSMantissa1,x
		sta 	NSMantissa1,x
		lda 	#0
		sbc 	NSMantissa2,x
		sta 	NSMantissa2,x
		lda 	#0
		sbc 	NSMantissa3,x
		sta 	NSMantissa3,x
		rts

; ************************************************************************************************
;
;							  Shift entry X to entry X+2
;
; ************************************************************************************************

FloatShiftUpTwo:
		lda 	NSMantissa0,x
		sta 	NSMantissa0+2,x
		lda 	NSMantissa1,x
		sta 	NSMantissa1+2,x
		lda 	NSMantissa2,x
		sta 	NSMantissa2+2,x
		lda 	NSMantissa3,x
		sta 	NSMantissa3+2,x
		lda 	NSExponent,x 				
		sta 	NSExponent+2,x
		lda 	NSStatus,x
		sta 	NSStatus+2,x 	
		rts
		
; ************************************************************************************************
;
;							  Set mantissa to a 1 byte integer, various
;
; ************************************************************************************************

FloatSetZeroMantissaOnly: 					; clear *only* the mantissa
		stz 	NSMantissa0,x
		bra 	FloatZero13
FloatSetZero: 								; set the whole lot to zero, exponent, mantissa
		lda 	#0
FloatSetByte:
		stz 	NSExponent,x 				; zero exponent, as +ve integer value.
FloatSetMantissa:		
		sta 	NSMantissa0,x 				; zero mantissa
		stz 	NSStatus,x
FloatZero13:		
		stz 	NSMantissa1,x
		stz 	NSMantissa2,x
		stz 	NSMantissa3,x
		rts
				
; ************************************************************************************************
;
;									Rotate/Shift the mantissa left
;
; ************************************************************************************************

FloatShiftLeft:		
		clc
FloatRotateLeft:
		rol 	NSMantissa0,x
		rol		NSMantissa1,x
		rol		NSMantissa2,x
		rol		NSMantissa3,x
		rts

; ************************************************************************************************
;
;									Shift the mantissa right
;
; ************************************************************************************************

FloatShiftRight:		
		lsr 	NSMantissa3,x
		ror		NSMantissa2,x
		ror		NSMantissa1,x
		ror		NSMantissa0,x
		rts

; ************************************************************************************************
;
;									   Check zero mantissa
;
; ************************************************************************************************

FloatIsZero:
		lda 	NSMantissa3,x
		ora		NSMantissa2,x
		ora		NSMantissa1,x
		ora		NSMantissa0,x
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
