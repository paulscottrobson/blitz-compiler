
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl /home/paulr/Projects/blitz-compiler/documents/../source/common-source/wrapper.asm testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library testing/testend.asm
; Thu Oct  5 09:45:46 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../source/common-source/wrapper.asm

=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.1000	a2 ff		ldx #$ff			ldx 	#$FF
.1002	9a		txs				txs
.1003	4c 06 10	jmp $1006			jmp 	WrapperBoot
.0022					codePtr:
>0022							.fill 	2
.0024					codePage:
>0024							.fill 	1
.0025					objPtr:
>0025							.fill 	2
.0027					objPage:
>0027							.fill 	1
.0028					zTemp0:
>0028							.fill 	2
.002a					zTemp1:
>002a							.fill 	2
.002c					zTemp2:
>002c							.fill 	2

;******  Processing input file: testing/testing.asm

.1006					WrapperBoot:
.1006	4c 09 10	jmp $1009			jmp 	StartRuntime

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$8000					WorkArea = $8000
=$1f00					WorkAreaSize = $1F00
=40192					StringTopAddress = WorkArea + WorkAreaSize - (1 + (WorkAreaSize >> 12)) * 256
=40704					StackTopAddress = WorkArea + WorkAreaSize
=$8000					VariableStart = WorkArea
.002e					zsTemp:
>002e							.fill 	2
.0030					runtimeStackPtr:
>0030							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.1009					StartRuntime:
.1009	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack.
.100b	9a		txs				txs
.100c	20 44 12	jsr $1244			jsr 	ClearMemory 				; clear memory.
.100f	20 9d 1f	jsr $1f9d			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.1012	20 9f 1c	jsr $1c9f		 	jsr		SetDefaultChannel			; set default input/output channel.
.1015	a9 74		lda #$74			lda 	#((EndProgram+2) & $FF)
.1017	85 22		sta $22				sta 	0+codePtr
.1019	a9 31		lda #$31			lda 	#((EndProgram+2) >> 8) & $FF
.101b	85 23		sta $23				sta 	1+codePtr
.101d	64 24		stz $24				stz 	codePage
.101f	20 d2 1e	jsr $1ed2			jsr 	RestoreCode 				; which we now call
.1022	a0 00		ldy #$00			ldy 	#0
.1024					NextCommand:
.1024	b1 22		lda ($22),y			lda 	(codePtr),y 				; get next
.1026	30 5b		bmi $1083			bmi 	NXCommand 					; -if -ve command
.1028	c8		iny				iny
.1029	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.102b	90 39		bcc $1066			bcc 	PushByteA 					; 0..63 is short constants.
.102d					NXLoadStore:
.102d	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.102f	b0 19		bcs $104a			bcs 	NXIndirectLoadStore
.1031	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.1032	4a		lsr a				lsr 	a
.1033	29 0e		and #$0e			and 	#$0E
.1035	da		phx				phx 								; get ready to jump
.1036	aa		tax				tax
.1037	7c 3a 10	jmp ($103a,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.103a					ReadWriteVectors:
>103a	0b 1e						.word 	ReadFloatCommand			; read float
>103c	e6 23						.word 	WriteFloatCommand 			; write float
>103e	46 1e						.word 	ReadIntegerCommand 			; read integer
>1040	21 24						.word 	WriteIntegerCommand 		; write integer
>1042	8a 1e						.word 	ReadStringCommand 			; read string
>1044	5f 24						.word 	WriteStringCommand 			; write string
>1046	00 14						.word 	Unimplemented
>1048	00 14						.word 	Unimplemented
.104a					NXIndirectLoadStore:
.104a	29 07		and #$07			and 	#7
.104c	0a		asl a				asl 	a
.104d	da		phx				phx
.104e	aa		tax				tax
.104f	7c 52 10	jmp ($1052,x)			jmp 	(IndirectVectors,x)
.1052					IndirectVectors:
>1052	32 18						.word 	IndFloatRead 				; float read
>1054	45 18						.word 	IndInt16Read 				; int16 read
>1056	58 18						.word 	IndStringRead 				; string read
>1058	00 14						.word 	Unimplemented
>105a	6b 18						.word 	IndFloatWrite				; float write
>105c	7e 18						.word 	IndInt16Write 				; int16 write
>105e	91 18						.word 	IndStringWrite 				; string write
>1060	00 14						.word 	Unimplemented
.1062					PushByteCommand:
.1062	fa		plx				plx
.1063	b1 22		lda ($22),y			lda 	(codePtr),y 				; get byte to write.
.1065	c8		iny				iny
.1066					PushByteA:
.1066	e8		inx				inx 								; push constant on stack
.1067	95 40		sta $40,x			sta 	NSMantissa0,x 				; save byte
.1069	74 4c		stz $4c,x			stz 	NSMantissa1,x 				; clear MSB
.106b					ClearRestWord:
.106b	74 58		stz $58,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.106d	74 64		stz $64,x			stz 	NSMantissa3,x
.106f	74 70		stz $70,x			stz 	NSExponent,x
.1071	74 34		stz $34,x			stz 	NSStatus,x
.1073	80 af		bra $1024			bra 	NextCommand
.1075					PushWordCommand:
.1075	fa		plx				plx
.1076	e8		inx				inx
.1077	b1 22		lda ($22),y			lda 	(codePtr),y 				; word to stack
.1079	c8		iny				iny
.107a	95 40		sta $40,x			sta 	NSMantissa0,x
.107c	b1 22		lda ($22),y			lda 	(codePtr),y
.107e	c8		iny				iny
.107f	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1081	80 e8		bra $106b			bra 	ClearRestWord 				; handle everything else.
.1083					NXCommand:
.1083	c8		iny				iny 								; consume command.
.1084	10 03		bpl $1089			bpl 	_NXCommandNoFixUp
.1086	20 8f 10	jsr $108f			jsr 	FixUpY
.1089					_NXCommandNoFixUp:
.1089	0a		asl a				asl 	a 							; shift left
.108a	da		phx				phx 								; save SP on stack
.108b	aa		tax				tax				 					; and jump indirect
.108c	7c c7 22	jmp ($22c7,x)			jmp 	(VectorTable,x)
.108f					FixUpY:
.108f	48		pha				pha
.1090	98		tya				tya
.1091	18		clc				clc
.1092	65 22		adc $22				adc 	codePtr
.1094	85 22		sta $22				sta 	codePtr
.1096	90 02		bcc $109a			bcc 	_NoCPCarry
.1098	e6 23		inc $23				inc 	codePtr+1
.109a					_NoCPCarry:
.109a	a0 00		ldy #$00			ldy 	#0
.109c	68		pla				pla
.109d	60		rts				rts
.109e					AbsoluteTOS:
.109e	fa		plx				plx
.109f	74 34		stz $34,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.10a1	4c 24 10	jmp $1024			jmp 	NextCommand
.10a4					CommandVarSpace:
.10a4	fa		plx				plx
.10a5	b1 22		lda ($22),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.10a7	85 32		sta $32				sta 	availableMemory
.10a9	c8		iny				iny
.10aa	b1 22		lda ($22),y			lda 	(codePtr),y
.10ac	18		clc				clc
.10ad	69 80		adc #$80			adc 	#WorkArea >> 8 				; offset to actual address.
.10af	85 33		sta $33				sta 	availableMemory+1
.10b1	c8		iny				iny
.10b2	4c 24 10	jmp $1024			jmp 	NextCommand
.0032					availableMemory:
>0032							.fill 	2
.10b5					BinaryAnd:
.10b5	fa		plx				plx
.10b6	38		sec				sec
.10b7	80 02		bra $10bb			bra 	AndOrCommon
.10b9					BinaryOr:
.10b9	fa		plx				plx
.10ba	18		clc				clc
.10bb					AndOrCommon:
.10bb	08		php				php 								; save AND/OR flag
.10bc	20 67 19	jsr $1967			jsr 	GetInteger16Bit
.10bf	ca		dex				dex
.10c0	20 67 19	jsr $1967			jsr 	GetInteger16Bit
.10c3	28		plp				plp
.10c4	90 0e		bcc $10d4			bcc 	_AOCOrCode
.10c6	b5 40		lda $40,x			lda 	NSMantissa0,x 				; AND code
.10c8	35 41		and $41,x			and		NSMantissa0+1,x
.10ca	95 40		sta $40,x			sta 	NSMantissa0,x
.10cc	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.10ce	35 4d		and $4d,x			and		NSMantissa1+1,x
.10d0	95 4c		sta $4c,x			sta 	NSMantissa1,x
.10d2	80 0c		bra $10e0			bra 	_AOCComplete
.10d4					_AOCOrCode:
.10d4	b5 40		lda $40,x			lda 	NSMantissa0,x 				; OR code
.10d6	15 41		ora $41,x			ora		NSMantissa0+1,x
.10d8	95 40		sta $40,x			sta 	NSMantissa0,x
.10da	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.10dc	15 4d		ora $4d,x			ora		NSMantissa1+1,x
.10de	95 4c		sta $4c,x			sta 	NSMantissa1,x
.10e0					_AOCComplete:
.10e0	74 34		stz $34,x			stz 	NSStatus,x 					; make integer ?
.10e2	34 4c		bit $4c,x			bit 	NSMantissa1,x 				; result is -ve
.10e4	10 07		bpl $10ed			bpl 	_AOCExit
.10e6	20 77 19	jsr $1977			jsr 	Negate16Bit 				; 2's complement
.10e9	a9 80		lda #$80			lda 	#$80 						; make it -ve
.10eb	95 34		sta $34,x			sta 	NSStatus,x
.10ed					_AOCExit:
.10ed	4c 24 10	jmp $1024			jmp 	NextCommand
.10f0					ArrayConvert:
.10f0	fa		plx				plx
.10f1	5a		phy				phy
.10f2	b5 40		lda $40,x			lda 	NSMantissa0,x
.10f4	85 2a		sta $2a				sta 	zTemp1
.10f6	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.10f8	18		clc				clc
.10f9	69 80		adc #$80			adc 	#(WorkArea >> 8)
.10fb	85 2b		sta $2b				sta 	zTemp1+1
.10fd	ca		dex				dex 								; count of indices to follow -> zTemp2
.10fe	20 61 19	jsr $1961			jsr 	GetInteger8Bit
.1101	85 2c		sta $2c				sta 	zTemp2 						; subtract from stack.
.1103	8a		txa				txa
.1104	38		sec				sec
.1105	e5 2c		sbc $2c				sbc 	zTemp2
.1107	aa		tax				tax
.1108	da		phx				phx 								; stack points at the first index, which will be replaced.
.1109					_ACIndexLoop:
.1109	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart 			; integer array index
.110c	20 67 19	jsr $1967			jsr 	GetInteger16Bit 			; get the index => zTemp0
.110f	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.1111	a5 28		lda $28				lda 	zTemp0
.1113	d2 2a		cmp ($2a)			cmp 	(zTemp1)
.1115	a5 29		lda $29				lda 	zTemp0+1
.1117	f1 2a		sbc ($2a),y			sbc 	(zTemp1),y
.1119	b0 77		bcs $1192			bcs 	_ACBadIndex 				; index error.
.111b	c6 2c		dec $2c				dec 	zTemp2 						; decrement count, if zero, then innermost level
.111d	f0 28		beq $1147			beq 	_ACInnerLevel
.111f	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.1121	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.1123	10 6d		bpl $1192			bpl 	_ACBadIndex
.1125	06 28		asl $28				asl 	zTemp0 						; double the index and add it to the base address
.1127	26 29		rol $29				rol 	zTemp0+1
.1129	18		clc				clc
.112a	a5 28		lda $28				lda		zTemp0
.112c	65 2a		adc $2a				adc 	zTemp1
.112e	85 28		sta $28				sta 	zTemp0
.1130	a5 29		lda $29				lda		zTemp0+1
.1132	65 2b		adc $2b				adc 	zTemp1+1
.1134	85 29		sta $29				sta 	zTemp0+1
.1136	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.1138	b1 28		lda ($28),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.113a	85 2a		sta $2a				sta 	zTemp1
.113c	c8		iny				iny
.113d	b1 28		lda ($28),y			lda 	(zTemp0),y
.113f	18		clc				clc
.1140	69 80		adc #$80			adc 	#(WorkArea >> 8)
.1142	85 2b		sta $2b				sta 	zTemp1+1
.1144	e8		inx				inx 								; next index
.1145	80 c2		bra $1109			bra 	_ACIndexLoop
.1147					_ACInnerLevel:
.1147	a0 02		ldy #$02			ldy 	#2
.1149	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.114b	30 45		bmi $1192			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.114d	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.114f	c9 00		cmp #$00			cmp 	#NSSIFloat
.1151	d0 13		bne $1166			bne 	_ACNotFloat
.1153	a5 29		lda $29				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.1155	48		pha				pha
.1156	a5 28		lda $28				lda 	zTemp0
.1158	06 28		asl $28				asl 	zTemp0 						; x 2
.115a	26 29		rol $29				rol 	zTemp0+1
.115c	18		clc				clc 								; add back x 3
.115d	65 28		adc $28				adc 	zTemp0
.115f	85 28		sta $28				sta 	zTemp0
.1161	68		pla				pla
.1162	65 29		adc $29				adc 	zTemp0+1
.1164	85 29		sta $29				sta 	zTemp0+1
.1166					_ACNotFloat:
.1166	06 28		asl $28				asl 	zTemp0 						; x 2 or x 6 depending.
.1168	26 29		rol $29				rol 	zTemp0+1
.116a	18		clc				clc
.116b	a5 28		lda $28				lda 	zTemp0
.116d	69 03		adc #$03			adc 	#3
.116f	85 28		sta $28				sta 	zTemp0
.1171	90 02		bcc $1175			bcc 	_ACNoCarry
.1173	e6 29		inc $29				inc 	zTemp0+1
.1175					_ACNoCarry:
.1175	fa		plx				plx 								; X points to first slot of array parameters
.1176	18		clc				clc
.1177	a5 28		lda $28				lda 	zTemp0
.1179	65 2a		adc $2a				adc 	zTemp1
.117b	95 40		sta $40,x			sta 	NSMantissa0,x
.117d	a5 29		lda $29				lda 	zTemp0+1
.117f	65 2b		adc $2b				adc 	zTemp1+1
.1181	38		sec				sec
.1182	e9 80		sbc #$80			sbc 	#(WorkArea >> 8)
.1184	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1186	74 58		stz $58,x			stz 	NSMantissa2,x
.1188	74 64		stz $64,x			stz 	NSMantissa3,x
.118a	74 34		stz $34,x			stz 	NSStatus,x
.118c	74 70		stz $70,x			stz 	NSExponent,x
.118e	7a		ply				ply 	 							; restore code pointer
.118f	4c 24 10	jmp $1024			jmp 	NextCommand
.1192					_ACBadIndex:
.1192	4c 5a 15	jmp $155a		jmp	ErrorV_index
.1195					UnaryAsc:
.1195	fa		plx				plx
.1196	5a		phy				phy
.1197	b5 40		lda $40,x			lda 	NSMantissa0,x 				; string address.
.1199	85 28		sta $28				sta 	zTemp0
.119b	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.119d	85 29		sta $29				sta 	zTemp0+1
.119f	b2 28		lda ($28)			lda 	(zTemp0) 					; if empty string return zero
.11a1	f0 06		beq $11a9			beq 	_UAExit
.11a3	5a		phy				phy 								; otherwise first character
.11a4	a0 01		ldy #$01			ldy 	#1
.11a6	b1 28		lda ($28),y			lda 	(zTemp0),y
.11a8	7a		ply				ply
.11a9					_UAExit:
.11a9	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.11ac	7a		ply				ply
.11ad	4c 24 10	jmp $1024			jmp 	NextCommand
.11b0					CommandAssert:
.11b0	fa		plx				plx
.11b1	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.11b3	d0 09		bne $11be			bne 	_CAFail
.11b5	20 17 2e	jsr $2e17			jsr 	FloatIsZero 				; is it zero ?
.11b8	f0 04		beq $11be			beq 	_CAFail
.11ba	ca		dex				dex
.11bb	4c 24 10	jmp $1024			jmp 	NextCommand
.11be					_CAFail:
.11be	4c b3 14	jmp $14b3		jmp	ErrorV_assert
.11c1					X16_Audio_Parameters8_16:
.11c1	20 c7 11	jsr $11c7			jsr 	X16_Audio_Parameters8_8
.11c4	a4 4d		ldy $4d				ldy 	NSMantissa1+1
.11c6	60		rts				rts
.11c7					X16_Audio_Parameters8_8:
.11c7	a2 01		ldx #$01			ldx 	#1
.11c9	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.11cc	ca		dex				dex
.11cd	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.11d0	20 61 19	jsr $1961			jsr 	GetInteger8Bit
.11d3	a6 41		ldx $41				ldx 	NSMantissa0+1
.11d5	a0 00		ldy #$00			ldy 	#0
.11d7	60		rts				rts
.11d8					X16_Audio_Parameters8_String:
.11d8	20 c1 11	jsr $11c1			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.11db	da		phx				phx 								; set the voice
.11dc	5a		phy				phy
.11dd	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.11e0	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>11e3	0a						.byte 	X16_AudioCodeBank
.11e4	7a		ply				ply
.11e5	fa		plx				plx
.11e6	86 28		stx $28				stx 	zTemp0
.11e8	84 29		sty $29				sty 	zTemp0+1
.11ea	b2 28		lda ($28)			lda 	(zTemp0) 					; read length
.11ec	e8		inx				inx 								; point YX to first character.
.11ed	d0 01		bne $11f0			bne 	_X16APSSkip
.11ef	c8		iny				iny
.11f0					_X16APSSkip:
.11f0	60		rts				rts
.11f1					Unary16Bin:
.11f1	fa		plx				plx
.11f2	20 67 19	jsr $1967			jsr 	GetInteger16Bit				; 16 bit int
.11f5	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.11f7	20 46 20	jsr $2046			jsr 	StringAllocTemp
.11fa	a5 29		lda $29				lda 	zTemp0+1
.11fc	f0 03		beq $1201			beq 	_UBNoHigh
.11fe	20 09 12	jsr $1209			jsr 	_UBWriteBinary
.1201					_UBNoHigh:
.1201	a5 28		lda $28				lda 	zTemp0
.1203	20 09 12	jsr $1209			jsr 	_UBWriteBinary
.1206	4c 24 10	jmp $1024			jmp 	NextCommand
.1209					_UBWriteBinary:
.1209	5a		phy				phy
.120a	a0 08		ldy #$08			ldy 	#8
.120c					_UBWLoop:
.120c	0a		asl a				asl 	a
.120d	48		pha				pha
.120e	a9 00		lda #$00			lda  	#0
.1210	69 30		adc #$30			adc 	#48
.1212	20 6f 20	jsr $206f			jsr 	StringWriteChar
.1215	68		pla				pla
.1216	88		dey				dey
.1217	d0 f3		bne $120c			bne 	_UBWLoop
.1219	7a		ply				ply
.121a	60		rts				rts
.121b					PrintCharacter:
.121b	fa		plx				plx
.121c	b5 40		lda $40,x			lda 	NSMantissa0,x
.121e	ca		dex				dex
.121f	20 a3 1c	jsr $1ca3			jsr 	VectorPrintCharacter
.1222	4c 24 10	jmp $1024			jmp 	NextCommand
.1225					UnaryChr:
.1225	fa		plx				plx
.1226	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; get integer to convert.
.1229	48		pha				pha 								; save it and allocate for it
.122a	a9 01		lda #$01			lda 	#1 							; 1 character
.122c	20 46 20	jsr $2046			jsr 	StringAllocTemp
.122f	a9 01		lda #$01			lda 	#1 							; length 1.
.1231	92 2e		sta ($2e)			sta 	(zsTemp)
.1233	68		pla				pla 								; character code makes string.
.1234	5a		phy				phy
.1235	a0 01		ldy #$01			ldy 	#1
.1237	91 2e		sta ($2e),y			sta 	(zsTemp),y
.1239	7a		ply				ply
.123a	4c 24 10	jmp $1024			jmp 	NextCommand
.123d					CommandClr:
.123d	fa		plx				plx
.123e	20 44 12	jsr $1244			jsr 	ClearMemory
.1241	4c 24 10	jmp $1024			jmp 	NextCommand
.1244					ClearMemory:
.1244	a9 00		lda #$00			lda 	#((WorkArea) & $FF)
.1246	85 28		sta $28				sta 	0+zTemp0
.1248	a9 80		lda #$80			lda 	#((WorkArea) >> 8) & $FF
.124a	85 29		sta $29				sta 	1+zTemp0
.124c	5a		phy				phy
.124d	a0 00		ldy #$00			ldy 	#0
.124f					_ClearLoop1:
.124f	a9 00		lda #$00			lda 	#0
.1251	91 28		sta ($28),y			sta 	(zTemp0),y
.1253	c8		iny				iny
.1254	d0 f9		bne $124f			bne 	_ClearLoop1
.1256	e6 29		inc $29				inc 	zTemp0+1
.1258	a5 29		lda $29				lda 	zTemp0+1
.125a	c9 9f		cmp #$9f			cmp 	#(WorkArea+WorkAreaSize) >> 8
.125c	d0 f1		bne $124f			bne 	_ClearLoop1
.125e	a9 00		lda #$00			lda 	#((StringTopAddress) & $FF)
.1260	8d 02 04	sta $0402			sta 	0+stringHighMemory
.1263	a9 9d		lda #$9d			lda 	#((StringTopAddress) >> 8) & $FF
.1265	8d 03 04	sta $0403			sta 	1+stringHighMemory
.1268	9c 64 05	stz $0564			stz 	stringInitialised 						; string system not initialised
.126b	a9 ff		lda #$ff			lda 	#((StackTopAddress-1) & $FF)
.126d	85 30		sta $30				sta 	0+runtimeStackPtr
.126f	a9 9e		lda #$9e			lda 	#((StackTopAddress-1) >> 8) & $FF
.1271	85 31		sta $31				sta 	1+runtimeStackPtr
.1273	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.1275	92 30		sta ($30)			sta 	(runtimeStackPtr)
.1277	7a		ply				ply
.1278	60		rts				rts
.1279					CompareStrings:
.1279	fa		plx				plx
.127a	ca		dex				dex
.127b	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.127d	85 28		sta $28				sta 	zTemp0
.127f	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.1281	85 29		sta $29				sta 	zTemp0+1
.1283	b5 41		lda $41,x			lda 	NSMantissa0+1,x
.1285	85 2a		sta $2a				sta 	zTemp1
.1287	b5 4d		lda $4d,x			lda 	NSMantissa1+1,x
.1289	85 2b		sta $2b				sta 	zTemp1+1
.128b	da		phx				phx
.128c	5a		phy				phy
.128d	b2 28		lda ($28)			lda 	(zTemp0)					; work out number to compare
.128f	d2 2a		cmp ($2a)			cmp 	(zTemp1)
.1291	90 02		bcc $1295			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.1293	b2 2a		lda ($2a)			lda 	(zTemp1)
.1295					_CSNIsSmallest:
.1295	aa		tax				tax 								; count in X
.1296	f0 0c		beq $12a4			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.1298	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.129a					_CSNCompareString:
.129a	c8		iny				iny 								; pre increment
.129b	b1 28		lda ($28),y			lda 	(zTemp0),y
.129d	d1 2a		cmp ($2a),y			cmp 	(zTemp1),y
.129f	d0 0a		bne $12ab			bne 	_CSNDifferent 				; numbers are different.
.12a1	ca		dex				dex
.12a2	d0 f6		bne $129a			bne 	_CSNCompareString 			; compare common characters in two strings.
.12a4					_CSNMatches:
.12a4	38		sec				sec
.12a5	b2 28		lda ($28)			lda 	(zTemp0)					; compare lengths
.12a7	f2 2a		sbc ($2a)			sbc 	(zTemp1)
.12a9	f0 06		beq $12b1			beq 	_CSNSExit 					; if zero, then strings match and exit.
.12ab					_CSNDifferent:
.12ab	a9 ff		lda #$ff			lda 	#$FF
.12ad	90 02		bcc $12b1			bcc 	_CSNSExit
.12af	a9 01		lda #$01			lda 	#$01
.12b1					_CSNSExit:
.12b1	7a		ply				ply
.12b2	fa		plx				plx
.12b3	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.12b5	20 f7 2d	jsr $2df7			jsr 	FloatSetByte 				; output the byte
.12b8	4c 24 10	jmp $1024			jmp 	NextCommand
.12bb					StringConcrete:
.12bb	9c 64 05	stz $0564			stz 	stringInitialised	 		; initialise next usage
.12be	84 2d		sty $2d				sty 	zTemp2+1 					; save pointer to new string
.12c0	85 2c		sta $2c				sta 	zTemp2
.12c2	b2 2c		lda ($2c)			lda 	(zTemp2) 					; length required
.12c4	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.12c5	18		clc				clc
.12c6	72 2c		adc ($2c)			adc 	(zTemp2)
.12c8	90 02		bcc $12cc			bcc 	_SCNoOverflow
.12ca	a9 ff		lda #$ff			lda 	#255
.12cc					_SCNoOverflow:
.12cc	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.12ce	b0 02		bcs $12d2			bcs 	_SCNoMinimum
.12d0	a9 0a		lda #$0a			lda 	#10
.12d2					_SCNoMinimum:
.12d2	85 2a		sta $2a				sta 	zTemp1 						; save max length.
.12d4	38		sec				sec
.12d5	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.12d8	e5 2a		sbc $2a				sbc 	zTemp1
.12da	a8		tay				tay
.12db	ad 03 04	lda $0403			lda 	stringHighMemory+1
.12de	e9 00		sbc #$00			sbc 	#0
.12e0	48		pha				pha
.12e1	38		sec				sec 								; subtract 3 more
.12e2	98		tya				tya
.12e3	e9 03		sbc #$03			sbc 	#3
.12e5	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.12e8	85 2e		sta $2e				sta 	zsTemp
.12ea	68		pla				pla
.12eb	e9 00		sbc #$00			sbc 	#0
.12ed	8d 03 04	sta $0403			sta 	stringHighMemory+1
.12f0	85 2f		sta $2f				sta 	zsTemp+1
.12f2	a5 2a		lda $2a				lda 	zTemp1 						; set max length.
.12f4	92 2e		sta ($2e)			sta 	(zsTemp)
.12f6	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.12f8	a9 00		lda #$00			lda 	#0
.12fa	91 2e		sta ($2e),y			sta 	(zsTemp),y
.12fc	a5 2e		lda $2e				lda 	zsTemp 						; new empty string in YA.
.12fe	a4 2f		ldy $2f				ldy 	zsTemp+1
.1300	60		rts				rts
.1301					CommandData:
.1301	fa		plx				plx
.1302	98		tya				tya 								; data length +1 added to Y
.1303	38		sec				sec
.1304	71 22		adc ($22),y			adc 	(codePtr),y 				; next instruction
.1306	a8		tay				tay
.1307	4c 24 10	jmp $1024			jmp 	NextCommand
.130a					CommandDIM:
.130a	fa		plx				plx
.130b	5a		phy				phy
.130c	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.130f	8d 04 04	sta $0404			sta 	dimType
.1312	ca		dex				dex 								; this is the number of indices
.1313	20 61 19	jsr $1961			jsr 	GetInteger8Bit
.1316	85 2a		sta $2a				sta 	zTemp1 						; subtract n from X so X points at the *first*
.1318	8a		txa				txa 								; dimension.
.1319	38		sec				sec
.131a	e5 2a		sbc $2a				sbc 	zTemp1
.131c	aa		tax				tax
.131d	a5 2a		lda $2a				lda 	zTemp1 						; number of indices.
.131f	20 33 13	jsr $1333			jsr 	DIMCreateOneLevel 			; create one at this level
.1322	95 40		sta $40,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.1324	98		tya				tya
.1325	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1327	74 58		stz $58,x			stz 	NSMantissa2,x
.1329	74 64		stz $64,x			stz 	NSMantissa3,x
.132b	74 34		stz $34,x			stz 	NSStatus,x
.132d	74 70		stz $70,x			stz 	NSExponent,x
.132f	7a		ply				ply
.1330	4c 24 10	jmp $1024			jmp 	NextCommand
.1333					DIMCreateOneLevel:
.1333	a4 32		ldy $32				ldy 	availableMemory 			; push the start of this block on the stack.
.1335	5a		phy				phy
.1336	a4 33		ldy $33				ldy 	availableMemory+1
.1338	5a		phy				phy
.1339	a8		tay				tay 			 					; save current level into Y
.133a	20 67 19	jsr $1967			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.133d	e6 28		inc $28				inc 	zTemp0 						; bump the size of the dimension as we need one more
.133f	d0 02		bne $1343			bne 	_DCOLNoCarry
.1341	e6 29		inc $29				inc 	zTemp0+1
.1343					_DCOLNoCarry:
.1343	a5 28		lda $28				lda 	zTemp0 						; write out the +1 size of the dimension
.1345	20 e5 13	jsr $13e5			jsr 	DIMWriteByte
.1348	a5 29		lda $29				lda 	zTemp0+1
.134a	20 e5 13	jsr $13e5			jsr 	DIMWriteByte
.134d	ad 04 04	lda $0404			lda 	dimType 					; get type information
.1350	29 7f		and #$7f			and 	#$7F
.1352	c0 01		cpy #$01			cpy 	#1
.1354	f0 02		beq $1358			beq 	_DCOLNoSubLevel
.1356	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.1358					_DCOLNoSubLevel:
.1358	20 e5 13	jsr $13e5			jsr 	DIMWriteByte
.135b	a5 32		lda $32				lda 	availableMemory
.135d	85 2a		sta $2a				sta 	zTemp1
.135f	a5 33		lda $33				lda 	availableMemory+1
.1361	85 2b		sta $2b				sta 	zTemp1+1
.1363	a5 28		lda $28				lda 	zTemp0
.1365	85 2c		sta $2c				sta 	zTemp2
.1367	a5 29		lda $29				lda 	zTemp0+1
.1369	85 2d		sta $2d				sta 	zTemp2+1
.136b					_DCOLFillArray:
.136b	20 c9 13	jsr $13c9			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.136e	a5 28		lda $28				lda 	zTemp0 						; decrement one from count.
.1370	d0 02		bne $1374			bne 	_DCOLNoBorrow
.1372	c6 29		dec $29				dec 	zTemp0+1
.1374					_DCOLNoBorrow:
.1374	c6 28		dec $28				dec 	zTemp0
.1376	a5 28		lda $28				lda 	zTemp0 						; until completed.
.1378	05 29		ora $29				ora 	zTemp0+1
.137a	d0 ef		bne $136b			bne 	_DCOLFillArray
.137c	c0 01		cpy #$01			cpy 	#1
.137e	f0 42		beq $13c2			beq 	_DCOLExit
.1380					_DCOLRecursionLoop:
.1380	da		phx				phx 								; save XY
.1381	5a		phy				phy
.1382	a5 2a		lda $2a				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.1384	48		pha				pha
.1385	a5 2b		lda $2b				lda 	zTemp1+1
.1387	48		pha				pha
.1388	a5 2c		lda $2c				lda 	zTemp2
.138a	48		pha				pha
.138b	a5 2d		lda $2d				lda 	zTemp2+1
.138d	48		pha				pha
.138e	88		dey				dey  								; lower level -> A
.138f	98		tya				tya
.1390	e8		inx				inx 								; next index size
.1391	20 33 13	jsr $1333			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.1394	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.1395	86 2d		stx $2d				stx 	zTemp2+1
.1397	fa		plx				plx
.1398	86 2c		stx $2c				stx 	zTemp2
.139a	fa		plx				plx
.139b	86 2b		stx $2b				stx 	zTemp1+1
.139d	fa		plx				plx
.139e	86 2a		stx $2a				stx 	zTemp1
.13a0	92 2a		sta ($2a)			sta 	(zTemp1) 					; write out position
.13a2	98		tya				tya
.13a3	a0 01		ldy #$01			ldy 	#1
.13a5	91 2a		sta ($2a),y			sta 	(zTemp1),y
.13a7	7a		ply				ply 								; restore XY
.13a8	fa		plx				plx
.13a9	18		clc				clc
.13aa	a5 2a		lda $2a				lda 	zTemp1 						; add 2 to zTemp1
.13ac	69 02		adc #$02			adc 	#2
.13ae	85 2a		sta $2a				sta 	zTemp1
.13b0	90 02		bcc $13b4			bcc 	_DCOLRNoCarry
.13b2	e6 2b		inc $2b				inc 	zTemp1+1
.13b4					_DCOLRNoCarry:
.13b4	a5 2c		lda $2c				lda 	zTemp2 						; decrement one from count in zTemp2
.13b6	d0 02		bne $13ba			bne 	_DCOLRNoBorrow
.13b8	c6 2d		dec $2d				dec 	zTemp2+1
.13ba					_DCOLRNoBorrow:
.13ba	c6 2c		dec $2c				dec 	zTemp2
.13bc	a5 2c		lda $2c				lda 	zTemp2 						; until completed.
.13be	05 2d		ora $2d				ora 	zTemp2+1
.13c0	d0 be		bne $1380			bne 	_DCOLRecursionLoop
.13c2					_DCOLExit:
.13c2	68		pla				pla 								; get MSB, make offset again
.13c3	38		sec				sec
.13c4	e9 80		sbc #$80			sbc 	#WorkArea >> 8
.13c6	a8		tay				tay
.13c7	68		pla				pla 								; YA now contains offset address.
.13c8	60		rts				rts
.13c9					DIMWriteElement:
.13c9	da		phx				phx
.13ca	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.13cc	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.13ce	d0 0b		bne $13db			bne 	_DIMWENotFloat
.13d0	ad 04 04	lda $0404			lda 	dimType
.13d3	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.13d5	c9 00		cmp #$00			cmp 	#NSSIFloat
.13d7	d0 02		bne $13db			bne 	_DIMWENotFloat
.13d9	a2 06		ldx #$06			ldx 	#6
.13db					_DIMWENotFloat:
.13db	a9 00		lda #$00			lda 	#0
.13dd	20 e5 13	jsr $13e5			jsr 	DIMWriteByte
.13e0	ca		dex				dex
.13e1	d0 f8		bne $13db			bne 	_DIMWENotFloat
.13e3	fa		plx				plx
.13e4	60		rts				rts
.13e5					DIMWriteByte:
.13e5	92 32		sta ($32)			sta 	(availableMemory)
.13e7	e6 32		inc $32				inc 	availableMemory
.13e9	d0 0b		bne $13f6			bne 	_DIMWBSkip
.13eb	e6 33		inc $33				inc 	availableMemory+1
.13ed	48		pha				pha
.13ee	a5 33		lda $33				lda 	availableMemory+1 			; check out of memory
.13f0	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.13f3	b0 02		bcs $13f7			bcs 	_DIMWBMemory
.13f5	68		pla				pla
.13f6					_DIMWBSkip:
.13f6	60		rts				rts
.13f7					_DIMWBMemory:
.13f7	4c 6d 15	jmp $156d		jmp	ErrorV_memory
.0404					dimType:
>0404							.fill 	1
.13fa					CommandEnd:
.13fa	fa		plx				plx
.13fb	86 28		stx $28				stx 	zTemp0
.13fd	4c ff ff	jmp $ffff			jmp 	$FFFF
.1400					Unimplemented:
.1400	4c a0 14	jmp $14a0			jmp 	ErrorV_unimplemented
.1403					ErrorHandler:
.1403	98		tya				tya
.1404	18		clc				clc
.1405	65 22		adc $22				adc 	codePtr
.1407	85 22		sta $22				sta 	codePtr
.1409	90 02		bcc $140d			bcc 	_EHNoCarry
.140b	e6 23		inc $23				inc 	codePtr+1
.140d					_EHNoCarry:
.140d	68		pla				pla
.140e	7a		ply				ply
.140f	85 28		sta $28				sta 	zTemp0
.1411	84 29		sty $29				sty 	zTemp0+1
.1413	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.1415	a0 01		ldy #$01			ldy 	#1
.1417					_EHDisplayMsg:
.1417	b1 28		lda ($28),y			lda 	(zTemp0),y
.1419	20 b8 25	jsr $25b8			jsr 	XPrintCharacterToChannel
.141c	c8		iny				iny
.141d	b1 28		lda ($28),y			lda 	(zTemp0),y
.141f	d0 f6		bne $1417			bne 	_EHDisplayMsg
.1421	a9 20		lda #$20			lda 	#32
.1423	20 b8 25	jsr $25b8			jsr 	XPrintCharacterToChannel
.1426	a9 40		lda #$40			lda 	#64
.1428	20 b8 25	jsr $25b8			jsr 	XPrintCharacterToChannel
.142b	a9 20		lda #$20			lda 	#32
.142d	20 b8 25	jsr $25b8			jsr 	XPrintCharacterToChannel
.1430	20 35 14	jsr $1435			jsr 	EHDisplayCodePtr
.1433	80 fe		bra $1433	_EHStop:bra 	_EHStop
.1435					EHDisplayCodePtr:
.1435	a9 20		lda #$20			lda 	#32
.1437	20 b8 25	jsr $25b8			jsr 	XPrintCharacterToChannel
.143a	38		sec				sec
.143b	a5 22		lda $22				lda 	codePtr
.143d	e9 74		sbc #$74			sbc 	#(EndProgram+2) & $FF
.143f	48		pha				pha
.1440	a5 23		lda $23				lda 	codePtr+1
.1442	e9 31		sbc #$31			sbc 	#(EndProgram+2) >> 8
.1444	20 4c 14	jsr $144c			jsr 	_EHDisplayHex
.1447	68		pla				pla
.1448	20 4c 14	jsr $144c			jsr 	_EHDisplayHex
.144b	60		rts				rts
.144c					_EHDisplayHex:
.144c	48		pha				pha
.144d	4a		lsr a				lsr 	a
.144e	4a		lsr a				lsr 	a
.144f	4a		lsr a				lsr 	a
.1450	4a		lsr a				lsr 	a
.1451	20 55 14	jsr $1455			jsr 	_EHDisplayNibble
.1454	68		pla				pla
.1455					_EHDisplayNibble:
.1455	29 0f		and #$0f			and 	#15
.1457	c9 0a		cmp #$0a			cmp 	#10
.1459	90 02		bcc $145d			bcc 	_EHNotHex
.145b	69 06		adc #$06			adc 	#6
.145d					_EHNotHex:
.145d	69 30		adc #$30			adc 	#48
.145f	4c b8 25	jmp $25b8			jmp 	XPrintCharacterToChannel
.1462					ErrorV_range:
.1462	20 03 14	jsr $1403		jsr	ErrorHandler
>1465	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>146d	41 4e 47 45 00
.1472					ErrorV_value:
.1472	20 03 14	jsr $1403		jsr	ErrorHandler
>1475	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>147d	45 00
.147f					ErrorV_syntax:
.147f	20 03 14	jsr $1403		jsr	ErrorHandler
>1482	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>148a	52 52 4f 52 00
.148f					ErrorV_type:
.148f	20 03 14	jsr $1403		jsr	ErrorHandler
>1492	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>149a	4d 41 54 43 48 00
.14a0					ErrorV_unimplemented:
.14a0	20 03 14	jsr $1403		jsr	ErrorHandler
>14a3	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>14ab	45 4d 45 4e 54 45 44 00
.14b3					ErrorV_assert:
.14b3	20 03 14	jsr $1403		jsr	ErrorHandler
>14b6	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>14be	41 49 4c 00
.14c2					ErrorV_line:
.14c2	20 03 14	jsr $1403		jsr	ErrorHandler
>14c5	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>14cd	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.14d9					ErrorV_internal:
.14d9	20 03 14	jsr $1403		jsr	ErrorHandler
>14dc	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>14e4	20 45 52 52 4f 52 00
.14eb					ErrorV_divzero:
.14eb	20 03 14	jsr $1403		jsr	ErrorHandler
>14ee	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>14f6	59 20 5a 45 52 4f 00
.14fd					ErrorV_structure:
.14fd	20 03 14	jsr $1403		jsr	ErrorHandler
>1500	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1508	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1514					ErrorV_stop:
.1514	20 03 14	jsr $1403		jsr	ErrorHandler
>1517	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>151f	53 54 4f 50 50 45 44 00
.1527					ErrorV_data:
.1527	20 03 14	jsr $1403		jsr	ErrorHandler
>152a	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1532	41 54 41 00
.1536					ErrorV_undeclared:
.1536	20 03 14	jsr $1403		jsr	ErrorHandler
>1539	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1541	41 52 52 41 59 00
.1547					ErrorV_redefine:
.1547	20 03 14	jsr $1403		jsr	ErrorHandler
>154a	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1552	44 45 46 49 4e 45 44 00
.155a					ErrorV_index:
.155a	20 03 14	jsr $1403		jsr	ErrorHandler
>155d	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1565	59 20 49 4e 44 45 58 00
.156d					ErrorV_memory:
.156d	20 03 14	jsr $1403		jsr	ErrorHandler
>1570	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>1578	45 4d 4f 52 59 00
.157e					ErrorV_channel:
.157e	20 03 14	jsr $1403		jsr	ErrorHandler
>1581	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>1589	54 50 55 54 20 45 52 52 4f 52 00
.1594					CommandFor:
.1594	fa		plx				plx
.1595	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.1597	20 5a 16	jsr $165a			jsr 	StackOpenFrame
.159a	20 98 1a	jsr $1a98			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.159d	a0 07		ldy #$07			ldy 	#7 							; copy step out
.159f	20 f8 15	jsr $15f8			jsr 	CopyTOSToOffsetY
.15a2	ca		dex				dex
.15a3	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.15a5	20 f8 15	jsr $15f8			jsr 	CopyTOSToOffsetY
.15a8	ca		dex				dex
.15a9	b5 4c		lda $4c,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.15ab	29 80		and #$80			and 	#$80
.15ad	a0 04		ldy #$04			ldy 	#4
.15af	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.15b1	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy the reference address
.15b3	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.15b5	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.15b7	85 28		sta $28				sta 	zTemp0 						; also to zTemp0
.15b9	c8		iny				iny
.15ba	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.15bc	18		clc				clc
.15bd	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.15bf	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.15c1	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.15c3	85 29		sta $29				sta 	zTemp0+1
.15c5	ca		dex				dex 								; throw reference.
.15c6	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.15c8	b1 28		lda ($28),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.15ca	a0 0c		ldy #$0c			ldy 	#12
.15cc	11 30		ora ($30),y			ora 	(runtimeStackPtr),y
.15ce	a0 12		ldy #$12			ldy 	#18
.15d0	11 30		ora ($30),y			ora 	(runtimeStackPtr),y
.15d2	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.15d4	88		dey				dey 								; now the exponents.
.15d5	11 28		ora ($28),y			ora 	(zTemp0),y
.15d7	a0 0b		ldy #$0b			ldy 	#11
.15d9	11 30		ora ($30),y			ora 	(runtimeStackPtr),y
.15db	a0 11		ldy #$11			ldy 	#17
.15dd	11 30		ora ($30),y			ora 	(runtimeStackPtr),y
.15df	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.15e1	11 30		ora ($30),y			ora 	(runtimeStackPtr),y
.15e3	c8		iny				iny
.15e4	11 30		ora ($30),y			ora 	(runtimeStackPtr),y
.15e6	c8		iny				iny
.15e7	11 30		ora ($30),y			ora 	(runtimeStackPtr),y
.15e9	d0 08		bne $15f3			bne 	_CFNoOptimise
.15eb	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.15ed	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.15ef	09 40		ora #$40			ora 	#$40
.15f1	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.15f3					_CFNoOptimise:
.15f3	a0 00		ldy #$00			ldy 	#0
.15f5	4c 24 10	jmp $1024			jmp 	NextCommand
.15f8					CopyTOSToOffsetY:
.15f8	b5 40		lda $40,x			lda 	NSMantissa0,x
.15fa	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.15fc	c8		iny				iny
.15fd	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.15ff	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.1601	c8		iny				iny
.1602	b5 58		lda $58,x			lda 	NSMantissa2,x
.1604	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.1606	c8		iny				iny
.1607	b5 64		lda $64,x			lda 	NSMantissa3,x
.1609	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.160b	c8		iny				iny
.160c	b5 70		lda $70,x			lda 	NSExponent,x
.160e	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.1610	c8		iny				iny
.1611	b5 34		lda $34,x			lda 	NSStatus,x
.1613	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.1615	60		rts				rts
.1616					MoveObjectForward:
.1616	b2 25		lda ($25)			lda 	(objPtr) 					; get next
.1618	c9 ff		cmp #$ff			cmp 	#$FF
.161a	f0 36		beq $1652			beq 	_MOFEnd
.161c	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.161e	90 24		bcc $1644			bcc 	_MOFAdvance1 				; forward 1
.1620	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.1622	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.1624	90 20		bcc $1646			bcc 	_MOFAdvanceY
.1626	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.1628	90 1a		bcc $1644			bcc 	_MOFAdvance1 				; forward 1
.162a	a8		tay				tay 								; read the size.
.162b	b9 7b 1b	lda $1b7b,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.162e	a8		tay				tay
.162f	c8		iny				iny 								; add 1 for the system token.
.1630	d0 14		bne $1646			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.1632	a0 01		ldy #$01			ldy 	#1 							; get length byte
.1634	b1 25		lda ($25),y			lda 	(objPtr),y
.1636	a8		tay				tay 								; into Y.
.1637	18		clc				clc
.1638	a5 25		lda $25				lda 	objPtr						; add 2 to the object pointer
.163a	69 02		adc #$02			adc 	#2
.163c	85 25		sta $25				sta 	objPtr
.163e	90 02		bcc $1642			bcc 	_MOFNoCarry1
.1640	e6 26		inc $26				inc 	objPtr+1
.1642					_MOFNoCarry1:
.1642	80 02		bra $1646			bra 	_MOFAdvanceY
.1644					_MOFAdvance1:
.1644	a0 01		ldy #$01			ldy 	#1
.1646					_MOFAdvanceY:
.1646	98		tya				tya 								; add X to objPtr
.1647	18		clc				clc
.1648	65 25		adc $25				adc 	objPtr
.164a	85 25		sta $25				sta 	objPtr
.164c	90 02		bcc $1650			bcc 	_MOFNoCarry2
.164e	e6 26		inc $26				inc 	objPtr+1
.1650					_MOFNoCarry2:
.1650	18		clc				clc 								; not completed.
.1651	60		rts				rts
.1652					_MOFEnd:
.1652	e6 25		inc $25				inc 	objPtr
.1654	d0 02		bne $1658			bne 	_MOFENoCarry
.1656	e6 26		inc $26				inc 	objPtr+1
.1658					_MOFENoCarry:
.1658	38		sec				sec
.1659	60		rts				rts
.165a					StackOpenFrame:
.165a	48		pha				pha 								; save frame marker
.165b	29 1f		and #$1f			and 	#$1F 						; bytes required.
.165d	85 28		sta $28				sta 	zTemp0
.165f	38		sec				sec 								; subtract from runtime stack pointer.
.1660	a5 30		lda $30				lda		runtimeStackPtr
.1662	e5 28		sbc $28				sbc 	zTemp0
.1664	85 30		sta $30				sta 	runtimeStackPtr
.1666	a5 31		lda $31				lda		runtimeStackPtr+1
.1668	e9 00		sbc #$00			sbc 	#0
.166a	85 31		sta $31				sta 	runtimeStackPtr+1
.166c	68		pla				pla 								; put frame marker at +0
.166d	92 30		sta ($30)			sta 	(runtimeStackPtr)
.166f	60		rts				rts
.1670					StackCloseFrame:
.1670	b2 30		lda ($30)			lda 	(runtimeStackPtr)			; get frame marker
.1672	29 1f		and #$1f			and 	#$1F 						; size
.1674	18		clc				clc
.1675	65 30		adc $30				adc 	runtimeStackPtr
.1677	85 30		sta $30				sta 	runtimeStackPtr
.1679	90 02		bcc $167d			bcc 	_SCFNoCarry
.167b	e6 31		inc $31				inc 	runtimeStackPtr+1
.167d					_SCFNoCarry:
.167d	60		rts				rts
.167e					StackFindFrame:
.167e	8d 05 04	sta $0405			sta 	requiredFrame
.1681					_SFFLoop:
.1681	b2 30		lda ($30)			lda 	(runtimeStackPtr) 			; get TOS
.1683	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.1685	f0 10		beq $1697			beq 	SCFFail
.1687	cd 05 04	cmp $0405			cmp 	requiredFrame 				; found this type ?
.168a	f0 05		beq $1691			beq 	_SFFFound
.168c	20 70 16	jsr $1670			jsr 	StackCloseFrame 			; close the top frame
.168f	80 f0		bra $1681			bra 	_SFFLoop 					; and try te next.
.1691					_SFFFound:
.1691	60		rts				rts
.1692					StackCheckFrame:
.1692	d2 30		cmp ($30)			cmp 	(runtimeStackPtr) 			; matches current frame
.1694	d0 01		bne $1697			bne 	SCFFail
.1696	60		rts				rts
.1697					SCFFail:
.1697	4c fd 14	jmp $14fd		jmp	ErrorV_structure
.0405					requiredFrame:
>0405							.fill 	1
.169a					UnaryFre:
.169a	fa		plx				plx
.169b	20 f5 2d	jsr $2df5			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.169e	38		sec				sec
.169f	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.16a2	ed 00 04	sbc $0400			sbc 	stringLowMemory
.16a5	95 40		sta $40,x			sta		NSMantissa0,x
.16a7	ad 03 04	lda $0403			lda 	stringHighMemory+1
.16aa	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.16ad	95 4c		sta $4c,x			sta		NSMantissa1,x
.16af	4c 24 10	jmp $1024			jmp 	NextCommand
.16b2					CommandGet:
.16b2	fa		plx				plx
.16b3	e8		inx				inx
.16b4	a9 01		lda #$01			lda 	#1 							; 1 character space
.16b6	20 46 20	jsr $2046			jsr 	StringAllocTemp
.16b9	20 ac 1c	jsr $1cac			jsr 	VectorGetCharacter 			; get a character
.16bc	c9 00		cmp #$00			cmp 	#0
.16be	f0 09		beq $16c9			beq 	_CGNone
.16c0	5a		phy				phy
.16c1	a0 01		ldy #$01			ldy 	#1 							; store char
.16c3	91 2e		sta ($2e),y			sta 	(zsTemp),y
.16c5	98		tya				tya 								; store length.
.16c6	92 2e		sta ($2e)			sta 	(zsTemp)
.16c8	7a		ply				ply
.16c9					_CGNone:
.16c9	4c 24 10	jmp $1024			jmp 	NextCommand
.16cc					CommandGosub:
.16cc	fa		plx				plx
.16cd	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.16cf	20 5a 16	jsr $165a			jsr 	StackOpenFrame
.16d2	20 98 1a	jsr $1a98			jsr 	StackSaveCurrentPosition
.16d5	4c eb 16	jmp $16eb			jmp 	PerformGOTO
.16d8					CommandReturn:
.16d8	fa		plx				plx
.16d9	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.16db	20 7e 16	jsr $167e			jsr 	StackFindFrame
.16de	20 ae 1a	jsr $1aae			jsr 	StackLoadCurrentPosition
.16e1	c8		iny				iny
.16e2	c8		iny				iny
.16e3	c8		iny				iny
.16e4	20 70 16	jsr $1670			jsr 	StackCloseFrame
.16e7	4c 24 10	jmp $1024			jmp 	NextCommand
.16ea					CommandGoto:
.16ea	fa		plx				plx
.16eb					PerformGOTO:
.16eb	c8		iny				iny
.16ec	c8		iny				iny 								; push MSB of offset on stack
.16ed	b1 22		lda ($22),y			lda 	(codePtr),y
.16ef	48		pha				pha
.16f0	88		dey				dey 								; point LSB of offset
.16f1	18		clc				clc 								; add LSB
.16f2	b1 22		lda ($22),y			lda 	(codePtr),y
.16f4	65 22		adc $22				adc 	codePtr
.16f6	85 22		sta $22				sta 	codePtr
.16f8	68		pla				pla 								; restore offset MSB and add
.16f9	65 23		adc $23				adc 	codePtr+1
.16fb	85 23		sta $23				sta 	codePtr+1
.16fd	88		dey				dey 								; fix up.
.16fe	4c 24 10	jmp $1024			jmp 	NextCommand
.1701					CommandGotoZ:
.1701	fa		plx				plx
.1702	20 17 2e	jsr $2e17			jsr 	FloatIsZero
.1705	ca		dex				dex
.1706	c9 00		cmp #$00			cmp 	#0
.1708	f0 e1		beq $16eb			beq 	PerformGOTO
.170a	c8		iny				iny
.170b	c8		iny				iny
.170c	c8		iny				iny
.170d	4c 24 10	jmp $1024			jmp 	NextCommand
.1710					CommandGotoNZ:
.1710	fa		plx				plx
.1711	20 17 2e	jsr $2e17			jsr 	FloatIsZero
.1714	ca		dex				dex
.1715	c9 00		cmp #$00			cmp 	#0
.1717	d0 d2		bne $16eb			bne 	PerformGOTO
.1719	c8		iny				iny
.171a	c8		iny				iny
.171b	c8		iny				iny
.171c	4c 24 10	jmp $1024			jmp 	NextCommand
.171f					Command_PSET:
.171f	fa		plx				plx
.1720	5a		phy				phy
.1721	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; get the colour
.1724	48		pha				pha
.1725	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.1727	a0 02		ldy #$02			ldy 	#X16_r0
.1729	20 ab 17	jsr $17ab			jsr 	GraphicsCopy2
.172c	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.172f	68		pla				pla 								; set pixel.
.1730	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.1733	7a		ply				ply
.1734	a2 ff		ldx #$ff			ldx 	#$FF
.1736	4c 24 10	jmp $1024			jmp 	NextCommand
.1739					Command_LINE:
.1739	fa		plx				plx
.173a	5a		phy				phy
.173b	20 9e 17	jsr $179e			jsr 	GraphicsColour
.173e	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.1740	a0 02		ldy #$02			ldy 	#X16_r0
.1742	20 a8 17	jsr $17a8			jsr 	GraphicsCopy4
.1745	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.1748	7a		ply				ply
.1749	a2 ff		ldx #$ff			ldx 	#$FF
.174b	4c 24 10	jmp $1024			jmp 	NextCommand
.174e					Command_RECT:
.174e	fa		plx				plx
.174f	5a		phy				phy
.1750	20 bf 17	jsr $17bf			jsr 	GraphicsRectCoords
.1753	38		sec				sec
.1754	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.1757	7a		ply				ply
.1758	a2 ff		ldx #$ff			ldx 	#$FF
.175a	4c 24 10	jmp $1024			jmp 	NextCommand
.175d					Command_FRAME:
.175d	fa		plx				plx
.175e	5a		phy				phy
.175f	20 bf 17	jsr $17bf			jsr 	GraphicsRectCoords
.1762	18		clc				clc
.1763	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.1766	7a		ply				ply
.1767	a2 ff		ldx #$ff			ldx 	#$FF
.1769	4c 24 10	jmp $1024			jmp 	NextCommand
.176c					Command_CHAR:
.176c	fa		plx				plx
.176d	5a		phy				phy
.176e	ca		dex				dex  								; set the draw colour
.176f	20 9e 17	jsr $179e			jsr 	GraphicsColour
.1772	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.1774	a0 02		ldy #$02			ldy 	#X16_r0
.1776	20 ab 17	jsr $17ab			jsr 	GraphicsCopy2
.1779	a5 43		lda $43				lda 	NSMantissa0+3 				; copy string address to zTemp0
.177b	85 28		sta $28				sta 	zTemp0
.177d	a5 4f		lda $4f				lda 	NSMantissa1+3
.177f	85 29		sta $29				sta 	zTemp0+1
.1781	b2 28		lda ($28)			lda 	(zTemp0) 					; count of chars to zTemp1
.1783	85 2a		sta $2a				sta 	zTemp1
.1785					_CCLoop:
.1785	a5 2a		lda $2a				lda 	zTemp1 						; done all chars ?
.1787	f0 0f		beq $1798			beq 	_CCExit
.1789	c6 2a		dec $2a				dec 	zTemp1 						; dec counter
.178b	e6 28		inc $28				inc 	zTemp0 						; pre-bump pointer
.178d	d0 02		bne $1791			bne 	_CCNoCarry
.178f	e6 29		inc $29				inc 	zTemp0+1
.1791					_CCNoCarry:
.1791	b2 28		lda ($28)			lda 	(zTemp0) 					; get character
.1793	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.1796	80 ed		bra $1785			bra 	_CCLoop						; go round.
.1798					_CCExit:
.1798	7a		ply				ply
.1799	a2 ff		ldx #$ff			ldx 	#$FF
.179b	4c 24 10	jmp $1024			jmp 	NextCommand
.179e					GraphicsColour:
.179e	20 61 19	jsr $1961			jsr 	GetInteger8Bit
.17a1	aa		tax				tax
.17a2	a0 00		ldy #$00			ldy 	#0
.17a4	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.17a7	60		rts				rts
.17a8					GraphicsCopy4:
.17a8	20 ab 17	jsr $17ab			jsr 	GraphicsCopy2
.17ab					GraphicsCopy2:
.17ab	20 ae 17	jsr $17ae			jsr 	GraphicsCopy1
.17ae					GraphicsCopy1:
.17ae	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.17b1	b5 40		lda $40,x			lda 	NSMantissa0,x
.17b3	99 00 00	sta $0000,y			sta 	0,y
.17b6	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.17b8	99 01 00	sta $0001,y			sta 	1,y
.17bb	e8		inx				inx
.17bc	c8		iny				iny
.17bd	c8		iny				iny
.17be	60		rts				rts
.17bf					GraphicsRectCoords:
.17bf	20 9e 17	jsr $179e			jsr 	GraphicsColour 				; set colour
.17c2	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.17c4	a0 02		ldy #$02			ldy 	#X16_r0
.17c6	20 a8 17	jsr $17a8			jsr 	GraphicsCopy4
.17c9	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.17cb	20 d8 17	jsr $17d8			jsr 	_GRCSortSubtract
.17ce	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.17d0	20 d8 17	jsr $17d8			jsr 	_GRCSortSubtract
.17d3	74 08		stz $08,x			stz 	8,x 						; zero rounding
.17d5	74 09		stz $09,x			stz 	9,x
.17d7	60		rts				rts
.17d8					_GRCSortSubtract:
.17d8	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.17da	d5 00		cmp $00,x			cmp 	0,x
.17dc	b5 05		lda $05,x			lda 	5,x
.17de	f5 01		sbc $01,x			sbc 	1,x
.17e0	b0 08		bcs $17ea			bcs 	_GRCNoSwap 					; >= swap.
.17e2	20 f8 17	jsr $17f8			jsr 	_GRCSwapByte 				; swap 0/2
.17e5	e8		inx				inx
.17e6	20 f8 17	jsr $17f8			jsr 	_GRCSwapByte 				; swap 1/3
.17e9	ca		dex				dex
.17ea					_GRCNoSwap:
.17ea	38		sec				sec 								; calculate width/height into 4,5
.17eb	b5 04		lda $04,x			lda 	4,x
.17ed	f5 00		sbc $00,x			sbc 	0,x
.17ef	95 04		sta $04,x			sta 	4,x
.17f1	b5 05		lda $05,x			lda 	5,x
.17f3	f5 01		sbc $01,x			sbc 	1,x
.17f5	95 05		sta $05,x			sta 	5,x
.17f7	60		rts				rts
.17f8					_GRCSwapByte:
.17f8	b5 04		lda $04,x			lda 	4,x
.17fa	48		pha				pha
.17fb	b5 00		lda $00,x			lda 	0,x
.17fd	95 04		sta $04,x			sta 	4,x
.17ff	68		pla				pla
.1800	95 00		sta $00,x			sta 	0,x
.1802	60		rts				rts
.1803					Unary16Hex:
.1803	fa		plx				plx
.1804	20 67 19	jsr $1967			jsr 	GetInteger16Bit
.1807	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.1809	20 46 20	jsr $2046			jsr 	StringAllocTemp
.180c	a5 29		lda $29				lda 	zTemp0+1
.180e	f0 03		beq $1813			beq 	_UHNoHigh
.1810	20 1b 18	jsr $181b			jsr 	_UHWriteHex
.1813					_UHNoHigh:
.1813	a5 28		lda $28				lda 	zTemp0
.1815	20 1b 18	jsr $181b			jsr 	_UHWriteHex
.1818	4c 24 10	jmp $1024			jmp 	NextCommand
.181b					_UHWriteHex:
.181b	48		pha				pha
.181c	4a		lsr a				lsr 	a
.181d	4a		lsr a				lsr 	a
.181e	4a		lsr a				lsr 	a
.181f	4a		lsr a				lsr 	a
.1820	20 24 18	jsr $1824			jsr 	_UHWriteNibl
.1823	68		pla				pla
.1824					_UHWriteNibl:
.1824	29 0f		and #$0f			and 	#15
.1826	c9 0a		cmp #$0a			cmp 	#10
.1828	90 02		bcc $182c			bcc 	_UHDigit
.182a	69 06		adc #$06			adc 	#6
.182c					_UHDigit:
.182c	69 30		adc #$30			adc 	#48
.182e	20 6f 20	jsr $206f			jsr 	StringWriteChar
.1831	60		rts				rts
.1832					IndFloatRead:
.1832	fa		plx				plx
.1833	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy address
.1835	85 28		sta $28				sta 	zTemp0
.1837	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.1839	18		clc				clc
.183a	69 80		adc #$80			adc 	#(WorkArea >> 8)
.183c	85 29		sta $29				sta 	zTemp0+1
.183e	ca		dex				dex 								; throw the address
.183f	20 24 1e	jsr $1e24			jsr 	ReadFloatZTemp0Sub 							; call read routine
.1842	4c 24 10	jmp $1024			jmp 	NextCommand
.1845					IndInt16Read:
.1845	fa		plx				plx
.1846	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy address
.1848	85 28		sta $28				sta 	zTemp0
.184a	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.184c	18		clc				clc
.184d	69 80		adc #$80			adc 	#(WorkArea >> 8)
.184f	85 29		sta $29				sta 	zTemp0+1
.1851	ca		dex				dex 								; throw the address
.1852	20 5f 1e	jsr $1e5f			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.1855	4c 24 10	jmp $1024			jmp 	NextCommand
.1858					IndStringRead:
.1858	fa		plx				plx
.1859	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy address
.185b	85 28		sta $28				sta 	zTemp0
.185d	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.185f	18		clc				clc
.1860	69 80		adc #$80			adc 	#(WorkArea >> 8)
.1862	85 29		sta $29				sta 	zTemp0+1
.1864	ca		dex				dex 								; throw the address
.1865	20 a3 1e	jsr $1ea3			jsr 	ReadStringZTemp0Sub 							; call read routine
.1868	4c 24 10	jmp $1024			jmp 	NextCommand
.186b					IndFloatWrite:
.186b	fa		plx				plx
.186c	b5 3f		lda $3f,x			lda 	NSMantissa0-1,x 			; copy address
.186e	85 28		sta $28				sta 	zTemp0
.1870	b5 4b		lda $4b,x			lda 	NSMantissa1-1,x
.1872	18		clc				clc
.1873	69 80		adc #$80			adc 	#(WorkArea >> 8)
.1875	85 29		sta $29				sta 	zTemp0+1
.1877	20 ff 23	jsr $23ff			jsr 	WriteFloatZTemp0Sub 							; call write routine
.187a	ca		dex				dex 								; throw the address as well.
.187b	4c 24 10	jmp $1024			jmp 	NextCommand
.187e					IndInt16Write:
.187e	fa		plx				plx
.187f	b5 3f		lda $3f,x			lda 	NSMantissa0-1,x 			; copy address
.1881	85 28		sta $28				sta 	zTemp0
.1883	b5 4b		lda $4b,x			lda 	NSMantissa1-1,x
.1885	18		clc				clc
.1886	69 80		adc #$80			adc 	#(WorkArea >> 8)
.1888	85 29		sta $29				sta 	zTemp0+1
.188a	20 3a 24	jsr $243a			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.188d	ca		dex				dex 								; throw the address as well.
.188e	4c 24 10	jmp $1024			jmp 	NextCommand
.1891					IndStringWrite:
.1891	fa		plx				plx
.1892	b5 3f		lda $3f,x			lda 	NSMantissa0-1,x 			; copy address
.1894	85 28		sta $28				sta 	zTemp0
.1896	b5 4b		lda $4b,x			lda 	NSMantissa1-1,x
.1898	18		clc				clc
.1899	69 80		adc #$80			adc 	#(WorkArea >> 8)
.189b	85 29		sta $29				sta 	zTemp0+1
.189d	20 78 24	jsr $2478			jsr 	WriteStringZTemp0Sub 							; call write routine
.18a0	ca		dex				dex 								; throw the address as well.
.18a1	4c 24 10	jmp $1024			jmp 	NextCommand
.18a4					CommandInput:
.18a4	fa		plx				plx
.18a5	5a		phy				phy 								; save Y
.18a6	e8		inx				inx									; space on stack
.18a7					_INError:
.18a7	20 db 18	jsr $18db			jsr 	InputStringToBuffer 		; input from keyboard
.18aa	a9 5b		lda #$5b			lda 	#((ReadBufferSize) & $FF)
.18ac	85 28		sta $28				sta 	0+zTemp0
.18ae	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.18b0	85 29		sta $29				sta 	1+zTemp0
.18b2	20 8d 22	jsr $228d			jsr 	ValEvaluateZTemp0
.18b5	b0 f0		bcs $18a7			bcs 	_INError 					; failed, try again.
.18b7	7a		ply				ply 								; restore Y
.18b8	4c 24 10	jmp $1024			jmp 	NextCommand
.18bb					CommandInputString:
.18bb	fa		plx				plx
.18bc	5a		phy				phy 								; save Y
.18bd	20 db 18	jsr $18db			jsr 	InputStringToBuffer 		; input from keyboard
.18c0	e8		inx				inx 								; make space on stack
.18c1	20 f5 2d	jsr $2df5			jsr 	FloatSetZero 				; store as string on stack
.18c4	a9 5b		lda #$5b			lda 	#ReadBufferSize & $FF
.18c6	95 40		sta $40,x			sta 	NSMantissa0,x
.18c8	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.18ca	95 4c		sta $4c,x			sta 	NSMantissa1,x
.18cc	a9 40		lda #$40			lda 	#NSSString
.18ce	95 34		sta $34,x			sta 	NSStatus,x
.18d0	7a		ply				ply 								; restore Y
.18d1	4c 24 10	jmp $1024			jmp 	NextCommand
.18d4					CommandInputReset:
.18d4	fa		plx				plx
.18d5	9c 06 04	stz $0406			stz 	InputBuffer
.18d8	4c 24 10	jmp $1024			jmp 	NextCommand
.18db					InputStringToBuffer:
.18db	a9 15		lda #$15			lda 	#((InputBumpNext) & $FF)
.18dd	8d 5b 05	sta $055b			sta 	0+ReadBumpNextVec
.18e0	a9 19		lda #$19			lda 	#((InputBumpNext) >> 8) & $FF
.18e2	8d 5c 05	sta $055c			sta 	1+ReadBumpNextVec
.18e5	a9 f2		lda #$f2			lda 	#((InputLookNext) & $FF)
.18e7	8d 5d 05	sta $055d			sta 	0+ReadLookNextVec
.18ea	a9 18		lda #$18			lda 	#((InputLookNext) >> 8) & $FF
.18ec	8d 5e 05	sta $055e			sta 	1+ReadLookNextVec
.18ef	4c 82 1d	jmp $1d82			jmp 	GetStringToBuffer
.18f2					InputLookNext:
.18f2	da		phx				phx
.18f3					_ILNRetry:
.18f3	ad 06 04	lda $0406			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.18f6	d0 08		bne $1900			bne 	_ILNNotEmpty
.18f8	20 19 19	jsr $1919			jsr 	InputGetNewLine 			; get a new line
.18fb	9c 57 04	stz $0457			stz 	InputBufferPos 				; reset read position.
.18fe	80 f3		bra $18f3			bra 	_ILNRetry
.1900					_ILNNotEmpty:
.1900	ae 57 04	ldx $0457			ldx 	InputBufferPos 				; get head available character
.1903	bd 06 04	lda $0406,x			lda 	InputBuffer,x
.1906	d0 08		bne $1910			bne 	_ILNExit 					; if not EOS return it with CC.
.1908					_ILNNextLine:
.1908	9c 06 04	stz $0406			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.190b	38		sec				sec 								; return CS,Zero
.190c	fa		plx				plx
.190d	a9 0d		lda #$0d			lda 	#13
.190f	60		rts				rts
.1910					_ILNExit:
.1910	fa		plx				plx
.1911	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.1913	18		clc				clc
.1914	60		rts				rts
.1915					InputBumpNext:
.1915	ee 57 04	inc $0457			inc 	InputBufferPos
.1918	60		rts				rts
.1919					InputGetNewLine:
.1919	48		pha				pha
.191a	da		phx				phx
.191b	5a		phy				phy
.191c	a9 3f		lda #$3f			lda 	#"?"
.191e	20 58 19	jsr $1958			jsr 	IGNLEchoIfScreen
.1921	a0 00		ldy #$00			ldy 	#0 							; line position.
.1923					_IGNLLoop:
.1923	20 ac 1c	jsr $1cac			jsr 	VectorGetCharacter 			; get a character
.1926	c9 00		cmp #$00			cmp 	#0
.1928	f0 f9		beq $1923			beq 	_IGNLLoop
.192a	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.192c	f0 11		beq $193f			beq 	_IGNBackspace
.192e	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.1930	f0 17		beq $1949			beq 	_IGNExit
.1932	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.1934	f0 ed		beq $1923			beq 	_IGNLLoop
.1936	99 06 04	sta $0406,y			sta 	InputBuffer,y
.1939	c8		iny				iny
.193a	20 58 19	jsr $1958			jsr 	IGNLEchoIfScreen
.193d	80 e4		bra $1923			bra 	_IGNLLoop
.193f					_IGNBackspace:
.193f	c0 00		cpy #$00			cpy 	#0
.1941	f0 e0		beq $1923			beq 	_IGNLLoop
.1943	20 58 19	jsr $1958			jsr 	IGNLEchoIfScreen
.1946	88		dey				dey
.1947	80 da		bra $1923			bra 	_IGNLLoop
.1949					_IGNExit:
.1949	20 58 19	jsr $1958			jsr 	IGNLEchoIfScreen
.194c	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.194e	99 06 04	sta $0406,y			sta 	InputBuffer,y
.1951	9c 57 04	stz $0457			stz 	InputBufferPos 				; reset position to start of input buffer.
.1954	7a		ply				ply
.1955	fa		plx				plx
.1956	68		pla				pla
.1957	60		rts				rts
.1958					IGNLEchoIfScreen:
.1958	ae 59 04	ldx $0459			ldx 	currentChannel
.195b	d0 03		bne $1960			bne 	_IGNLEExit
.195d	20 a3 1c	jsr $1ca3			jsr 	VectorPrintCharacter
.1960					_IGNLEExit:
.1960	60		rts				rts
.0406					InputBuffer:
>0406							.fill 	81
.0457					InputBufferPos:
>0457							.fill 	1
.1961					GetInteger8Bit:
.1961	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.1964	b5 40		lda $40,x			lda 	NSMantissa0,x
.1966	60		rts				rts
.1967					GetInteger16Bit:
.1967	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.196a	34 34		bit $34,x			bit 	NSStatus,x
.196c	30 09		bmi $1977			bmi 	Negate16Bit
.196e	b5 40		lda $40,x			lda 	NSMantissa0,x
.1970	85 28		sta $28				sta 	zTemp0
.1972	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.1974	85 29		sta $29				sta 	zTemp0+1
.1976	60		rts				rts
.1977					Negate16Bit:
.1977	38		sec				sec
.1978	a9 00		lda #$00			lda 	#0
.197a	f5 40		sbc $40,x			sbc 	NSMantissa0,x
.197c	95 40		sta $40,x			sta 	NSMantissa0,x
.197e	85 28		sta $28				sta 	zTemp0
.1980	a9 00		lda #$00			lda 	#0
.1982	f5 4c		sbc $4c,x			sbc 	NSMantissa1,x
.1984	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1986	85 29		sta $29				sta 	zTemp0+1
.1988	60		rts				rts
.1989					UnaryJoy:
.1989	fa		plx				plx
.198a	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; port #
.198d	48		pha				pha 								; zero the result.
.198e	20 f5 2d	jsr $2df5			jsr 	FloatSetZero
.1991	68		pla				pla
.1992	5a		phy				phy
.1993	da		phx				phx
.1994	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1997	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1999	d0 10		bne $19ab			bne 	_UJNoHardware
.199b	a8		tay				tay 								; move XA -> AY
.199c	8a		txa				txa
.199d	fa		plx				plx 								; we can update it now.
.199e	49 ff		eor #$ff			eor 	#$FF
.19a0	95 4c		sta $4c,x			sta 	NSMantissa1,x
.19a2	98		tya				tya
.19a3	49 ff		eor #$ff			eor 	#$FF
.19a5	95 40		sta $40,x			sta 	NSMantissa0,x
.19a7	7a		ply				ply 								; restore Y
.19a8	4c 24 10	jmp $1024			jmp 	NextCommand
.19ab					_UJNoHardware:
.19ab	fa		plx				plx
.19ac	7a		ply				ply
.19ad	a9 01		lda #$01			lda 	#1 							; set result to -1
.19af	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.19b2	20 b7 2d	jsr $2db7			jsr 	FloatNegate
.19b5	4c 24 10	jmp $1024			jmp 	NextCommand
.19b8					UnaryLen:
.19b8	fa		plx				plx
.19b9	b5 40		lda $40,x			lda 	NSMantissa0,x 				; string address.
.19bb	85 28		sta $28				sta 	zTemp0
.19bd	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.19bf	85 29		sta $29				sta 	zTemp0+1
.19c1	b2 28		lda ($28)			lda 	(zTemp0) 					; get length
.19c3	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.19c6	4c 24 10	jmp $1024			jmp 	NextCommand
.19c9					LinkFloatAdd:
.19c9	fa		plx				plx
.19ca	5a		phy			phy
.19cb	20 19 28	jsr $2819		jsr	FloatAdd
.19ce	7a		ply			ply
.19cf	4c 24 10	jmp $1024			jmp 	NextCommand
.19d2					LinkFloatSubtract:
.19d2	fa		plx				plx
.19d3	5a		phy			phy
.19d4	20 13 28	jsr $2813		jsr	FloatSubtract
.19d7	7a		ply			ply
.19d8	4c 24 10	jmp $1024			jmp 	NextCommand
.19db					LinkFloatMultiply:
.19db	fa		plx				plx
.19dc	5a		phy			phy
.19dd	20 b5 2a	jsr $2ab5		jsr	FloatMultiply
.19e0	7a		ply			ply
.19e1	4c 24 10	jmp $1024			jmp 	NextCommand
.19e4					LinkFloatDivide:
.19e4	fa		plx				plx
.19e5	5a		phy			phy
.19e6	20 3e 29	jsr $293e		jsr	FloatDivide
.19e9	b0 5c		bcs $1a47		bcs	DivZeroError
.19eb	7a		ply			ply
.19ec	4c 24 10	jmp $1024			jmp 	NextCommand
.19ef					LinkFloatPower:
.19ef	fa		plx				plx
.19f0	5a		phy			phy
.19f1	20 be 30	jsr $30be		jsr	FloatPower
.19f4	b0 4e		bcs $1a44		bcs	MapRangeError
.19f6	7a		ply			ply
.19f7	4c 24 10	jmp $1024			jmp 	NextCommand
.19fa					LinkCompareGreater:
.19fa	fa		plx				plx
.19fb	5a		phy			phy
.19fc	20 c2 28	jsr $28c2		jsr	CompareGreater
.19ff	7a		ply			ply
.1a00	4c 24 10	jmp $1024			jmp 	NextCommand
.1a03					LinkCompareEqual:
.1a03	fa		plx				plx
.1a04	5a		phy			phy
.1a05	20 a4 28	jsr $28a4		jsr	CompareEqual
.1a08	7a		ply			ply
.1a09	4c 24 10	jmp $1024			jmp 	NextCommand
.1a0c					LinkCompareLess:
.1a0c	fa		plx				plx
.1a0d	5a		phy			phy
.1a0e	20 ba 28	jsr $28ba		jsr	CompareLess
.1a11	7a		ply			ply
.1a12	4c 24 10	jmp $1024			jmp 	NextCommand
.1a15					LinkCompareGreaterEqual:
.1a15	fa		plx				plx
.1a16	5a		phy			phy
.1a17	20 d2 28	jsr $28d2		jsr	CompareGreaterEqual
.1a1a	7a		ply			ply
.1a1b	4c 24 10	jmp $1024			jmp 	NextCommand
.1a1e					LinkCompareNotEqual:
.1a1e	fa		plx				plx
.1a1f	5a		phy			phy
.1a20	20 b4 28	jsr $28b4		jsr	CompareNotEqual
.1a23	7a		ply			ply
.1a24	4c 24 10	jmp $1024			jmp 	NextCommand
.1a27					LinkCompareLessEqual:
.1a27	fa		plx				plx
.1a28	5a		phy			phy
.1a29	20 ca 28	jsr $28ca		jsr	CompareLessEqual
.1a2c	7a		ply			ply
.1a2d	4c 24 10	jmp $1024			jmp 	NextCommand
.1a30					LinkFloatIntegerPartDown:
.1a30	fa		plx				plx
.1a31	5a		phy			phy
.1a32	20 54 2a	jsr $2a54		jsr	FloatIntegerPartDown
.1a35	7a		ply			ply
.1a36	4c 24 10	jmp $1024			jmp 	NextCommand
.1a39					LinkFloatSquareRoot:
.1a39	fa		plx				plx
.1a3a	5a		phy			phy
.1a3b	20 40 31	jsr $3140		jsr	FloatSquareRoot
.1a3e	b0 04		bcs $1a44		bcs	MapRangeError
.1a40	7a		ply			ply
.1a41	4c 24 10	jmp $1024			jmp 	NextCommand
.1a44					MapRangeError:
.1a44	4c 62 14	jmp $1462		jmp	ErrorV_range
.1a47					DivZeroError:
.1a47	4c eb 14	jmp $14eb		jmp	ErrorV_divzero
.1a4a					LinkFloatLogarithm:
.1a4a	fa		plx				plx
.1a4b	5a		phy			phy
.1a4c	20 4a 30	jsr $304a		jsr	FloatLogarithm
.1a4f	b0 f3		bcs $1a44		bcs	MapRangeError
.1a51	7a		ply			ply
.1a52	4c 24 10	jmp $1024			jmp 	NextCommand
.1a55					LinkFloatExponent:
.1a55	fa		plx				plx
.1a56	5a		phy			phy
.1a57	20 47 2f	jsr $2f47		jsr	FloatExponent
.1a5a	7a		ply			ply
.1a5b	4c 24 10	jmp $1024			jmp 	NextCommand
.1a5e					LinkFloatCosine:
.1a5e	fa		plx				plx
.1a5f	5a		phy			phy
.1a60	20 3b 2f	jsr $2f3b		jsr	FloatCosine
.1a63	7a		ply			ply
.1a64	4c 24 10	jmp $1024			jmp 	NextCommand
.1a67					LinkFloatSine:
.1a67	fa		plx				plx
.1a68	5a		phy			phy
.1a69	20 db 30	jsr $30db		jsr	FloatSine
.1a6c	7a		ply			ply
.1a6d	4c 24 10	jmp $1024			jmp 	NextCommand
.1a70					LinkFloatTangent:
.1a70	fa		plx				plx
.1a71	5a		phy			phy
.1a72	20 4c 31	jsr $314c		jsr	FloatTangent
.1a75	7a		ply			ply
.1a76	4c 24 10	jmp $1024			jmp 	NextCommand
.1a79					LinkFloatArcTan:
.1a79	fa		plx				plx
.1a7a	5a		phy			phy
.1a7b	20 20 2e	jsr $2e20		jsr	FloatArcTan
.1a7e	b0 c4		bcs $1a44		bcs	MapRangeError
.1a80	7a		ply			ply
.1a81	4c 24 10	jmp $1024			jmp 	NextCommand
.1a84					LinkFloatCompare:
.1a84	fa		plx				plx
.1a85	5a		phy			phy
.1a86	20 da 28	jsr $28da		jsr	FloatCompare
.1a89	7a		ply			ply
.1a8a	4c 24 10	jmp $1024			jmp 	NextCommand
.1a8d					LinkDivideInt32:
.1a8d	fa		plx				plx
.1a8e	5a		phy			phy
.1a8f	20 68 29	jsr $2968		jsr	DivideInt32
.1a92	b0 b0		bcs $1a44		bcs	MapRangeError
.1a94	7a		ply			ply
.1a95	4c 24 10	jmp $1024			jmp 	NextCommand
.1a98					StackSaveCurrentPosition:
.1a98	20 8f 10	jsr $108f			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.1a9b	5a		phy				phy
.1a9c	a0 01		ldy #$01			ldy 	#1
.1a9e	a5 24		lda $24				lda 	codePage
.1aa0	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.1aa2	c8		iny				iny
.1aa3	a5 22		lda $22				lda 	codePtr
.1aa5	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.1aa7	c8		iny				iny
.1aa8	a5 23		lda $23				lda 	codePtr+1
.1aaa	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.1aac	7a		ply				ply
.1aad	60		rts				rts
.1aae					StackLoadCurrentPosition:
.1aae	a0 01		ldy #$01			ldy 	#1
.1ab0	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1ab2	85 24		sta $24				sta 	codePage
.1ab4	c8		iny				iny
.1ab5	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1ab7	85 22		sta $22				sta 	codePtr
.1ab9	c8		iny				iny
.1aba	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1abc	85 23		sta $23				sta 	codePtr+1
.1abe	a0 00		ldy #$00			ldy 	#0
.1ac0	60		rts				rts
.1ac1					XCommandMouse:
.1ac1	fa		plx				plx
.1ac2	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; mouse control.
.1ac5	ca		dex				dex
.1ac6	da		phx				phx
.1ac7	5a		phy				phy
.1ac8	48		pha				pha
.1ac9	38		sec				sec 								; get screen resolution
.1aca	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1acd	68		pla				pla
.1ace	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.1ad1	7a		ply				ply
.1ad2	fa		plx				plx
.1ad3	4c 24 10	jmp $1024			jmp 	NextCommand
.1ad6					XUnaryMB:
.1ad6	fa		plx				plx
.1ad7	20 05 1b	jsr $1b05			jsr 	XUnaryMouseCommon
.1ada	a5 2c		lda $2c				lda 	zTemp2
.1adc	e8		inx				inx
.1add	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.1ae0	4c 24 10	jmp $1024			jmp 	NextCommand
.1ae3					XUnaryMX:
.1ae3	fa		plx				plx
.1ae4	20 05 1b	jsr $1b05			jsr 	XUnaryMouseCommon
.1ae7	a5 28		lda $28				lda 	zTemp0
.1ae9	e8		inx				inx
.1aea	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.1aed	a5 29		lda $29				lda 	zTemp0+1
.1aef	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1af1	4c 24 10	jmp $1024			jmp 	NextCommand
.1af4					XUnaryMY:
.1af4	fa		plx				plx
.1af5	20 05 1b	jsr $1b05			jsr 	XUnaryMouseCommon
.1af8	a5 2a		lda $2a				lda 	zTemp1
.1afa	e8		inx				inx
.1afb	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.1afe	a5 2b		lda $2b				lda 	zTemp1+1
.1b00	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1b02	4c 24 10	jmp $1024			jmp 	NextCommand
.1b05					XUnaryMouseCommon:
.1b05	da		phx				phx
.1b06	5a		phy				phy
.1b07	a2 28		ldx #$28			ldx 	#zTemp0
.1b09	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.1b0c	85 2c		sta $2c				sta 	zTemp2
.1b0e	7a		ply				ply
.1b0f	fa		plx				plx
.1b10	60		rts				rts
.1b11					NegateTOS:
.1b11	fa		plx				plx
.1b12	20 b7 2d	jsr $2db7			jsr 	FloatNegate
.1b15	4c 24 10	jmp $1024			jmp 	NextCommand
.1b18					CommandNewLine:
.1b18	fa		plx				plx
.1b19	9c 64 05	stz $0564			stz 	stringInitialised
.1b1c	a2 ff		ldx #$ff			ldx 	#$FF
.1b1e	4c 24 10	jmp $1024			jmp 	NextCommand
.1b21					CommandNext:
.1b21	fa		plx				plx
.1b22					_CNRetry:
.1b22	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.1b24	20 7e 16	jsr $167e			jsr 	StackFindFrame
.1b27	20 8f 10	jsr $108f			jsr 	FixUpY 						; so we can use Y
.1b2a	b5 40		lda $40,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.1b2c	35 4c		and $4c,x			and 	NSMantissa1,x
.1b2e	c9 ff		cmp #$ff			cmp 	#$FF
.1b30	f0 16		beq $1b48			beq 	_CNNoIndexVariable
.1b32	b5 40		lda $40,x			lda 	NSMantissa0,x
.1b34	a0 05		ldy #$05			ldy 	#5
.1b36	d1 30		cmp ($30),y			cmp 	(runtimeStackPtr),y
.1b38	d0 07		bne $1b41			bne 	_CNNIndexFail
.1b3a	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.1b3c	c8		iny				iny
.1b3d	d1 30		cmp ($30),y			cmp 	(runtimeStackPtr),y
.1b3f	f0 07		beq $1b48			beq 	_CNNoIndexVariable
.1b41					_CNNIndexFail:
.1b41	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.1b43	20 70 16	jsr $1670			jsr 	StackCloseFrame 			; close this frame
.1b46	80 da		bra $1b22			bra 	_CNRetry
.1b48					_CNNoIndexVariable:
.1b48	ca		dex				dex
.1b49	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.1b4b	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1b4d	29 40		and #$40			and 	#$40	 					; bit 6
.1b4f	d0 54		bne $1ba5			bne 	_CNOptimisedNext
.1b51	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1b53	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1b55	48		pha				pha
.1b56	85 28		sta $28				sta 	zTemp0
.1b58	c8		iny				iny
.1b59	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1b5b	18		clc				clc
.1b5c	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.1b5e	48		pha				pha
.1b5f	85 29		sta $29				sta 	zTemp0+1
.1b61	20 24 1e	jsr $1e24			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.1b64	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.1b66	e8		inx				inx
.1b67	20 e7 1b	jsr $1be7			jsr 	CopyOffsetYToTOS
.1b6a	20 19 28	jsr $2819			jsr 	FloatAdd
.1b6d	68		pla				pla 								; restore address
.1b6e	85 29		sta $29				sta 	zTemp0+1
.1b70	68		pla				pla
.1b71	85 28		sta $28				sta 	zTemp0
.1b73	20 ff 23	jsr $23ff			jsr 	WriteFloatZTemp0Sub			; write float.
.1b76	e8		inx				inx  								; recover written
.1b77	e8		inx				inx 								; load offset
.1b78	a0 0d		ldy #$0d			ldy 	#13
.1b7a	20 e7 1b	jsr $1be7			jsr 	CopyOffsetYToTOS
.1b7d	20 da 28	jsr $28da			jsr 	FloatCompare 				; and compare the floats.
.1b80	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1b81	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.1b83	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1b85	30 08		bmi $1b8f			bmi 	_CNDownStep
.1b87	b5 41		lda $41,x			lda 	NSMantissa0+1,x 			; get comparator
.1b89	c9 01		cmp #$01			cmp 	#1 							; gone higher
.1b8b	f0 10		beq $1b9d			beq 	_CNExitFor 					; if so exit the loop
.1b8d	80 06		bra $1b95			bra 	_CNLoopBack
.1b8f					_CNDownStep:
.1b8f	b5 41		lda $41,x			lda 	NSMantissa0+1,x 			; get comparator
.1b91	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.1b93	f0 08		beq $1b9d			beq 	_CNExitFor
.1b95					_CNLoopBack:
.1b95	20 ae 1a	jsr $1aae			jsr 	StackLoadCurrentPosition 	; loop back
.1b98	a0 00		ldy #$00			ldy 	#0
.1b9a	4c 24 10	jmp $1024			jmp 	NextCommand
.1b9d					_CNExitFor:
.1b9d	20 70 16	jsr $1670			jsr 	StackCloseFrame 			; remove the frame and exit
.1ba0	a0 00		ldy #$00			ldy 	#0
.1ba2	4c 24 10	jmp $1024			jmp 	NextCommand
.1ba5					_CNOptimisedNext:
.1ba5	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1ba7	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1ba9	85 28		sta $28				sta 	zTemp0
.1bab	c8		iny				iny
.1bac	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1bae	18		clc				clc
.1baf	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.1bb1	85 29		sta $29				sta 	zTemp0+1
.1bb3	a0 07		ldy #$07			ldy 	#7 							; STEP value
.1bb5	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1bb7	a0 ff		ldy #$ff			ldy 	#$FF
.1bb9	18		clc				clc
.1bba					_CNOIncrement:
.1bba	c8		iny				iny
.1bbb	71 28		adc ($28),y			adc 	(zTemp0),y
.1bbd	91 28		sta ($28),y			sta 	(zTemp0),y
.1bbf	f0 f9		beq $1bba			beq 	_CNOIncrement
.1bc1	18		clc				clc
.1bc2	a5 30		lda $30				lda 	runtimeStackPtr
.1bc4	69 0d		adc #$0d			adc 	#13
.1bc6	85 2a		sta $2a				sta 	zTemp1
.1bc8	a5 31		lda $31				lda 	runtimeStackPtr+1
.1bca	69 00		adc #$00			adc 	#0
.1bcc	85 2b		sta $2b				sta 	zTemp1+1
.1bce	a0 00		ldy #$00			ldy 	#0
.1bd0	b1 2a		lda ($2a),y			lda 	(zTemp1),y 					; byte 0
.1bd2	d1 28		cmp ($28),y			cmp 	(zTemp0),y
.1bd4	c8		iny				iny
.1bd5	b1 2a		lda ($2a),y			lda 	(zTemp1),y 					; byte 1
.1bd7	f1 28		sbc ($28),y			sbc 	(zTemp0),y
.1bd9	c8		iny				iny
.1bda	b1 2a		lda ($2a),y			lda 	(zTemp1),y 					; byte 2
.1bdc	f1 28		sbc ($28),y			sbc 	(zTemp0),y
.1bde	c8		iny				iny
.1bdf	b1 2a		lda ($2a),y			lda 	(zTemp1),y 					; byte 3
.1be1	f1 28		sbc ($28),y			sbc 	(zTemp0),y
.1be3	90 b8		bcc $1b9d			bcc	 	_CNExitFor
.1be5	80 ae		bra $1b95			bra 	_CNLoopBack
.1be7					CopyOffsetYToTOS:
.1be7	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1be9	95 40		sta $40,x			sta 	NSMantissa0,x
.1beb	c8		iny				iny
.1bec	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1bee	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1bf0	c8		iny				iny
.1bf1	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1bf3	95 58		sta $58,x			sta 	NSMantissa2,x
.1bf5	c8		iny				iny
.1bf6	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1bf8	95 64		sta $64,x			sta 	NSMantissa3,x
.1bfa	c8		iny				iny
.1bfb	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1bfd	95 70		sta $70,x			sta 	NSExponent,x
.1bff	c8		iny				iny
.1c00	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1c02	95 34		sta $34,x			sta 	NSStatus,x
.1c04	60		rts				rts
.1c05	4c 24 10	jmp $1024			jmp 	NextCommand
.1c08					NotTOS:
.1c08	fa		plx				plx
.1c09	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.1c0c	74 58		stz $58,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.1c0e	74 64		stz $64,x			stz 	NSMantissa3,x
.1c10	20 b7 2d	jsr $2db7			jsr 	FloatNegate		 			; negate
.1c13	e8		inx				inx 								; and subtract 1.
.1c14	a9 01		lda #$01			lda 	#1
.1c16	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.1c19	20 13 28	jsr $2813			jsr 	FloatSubtract
.1c1c					_NotTOSSkip:
.1c1c	4c 24 10	jmp $1024			jmp 	NextCommand
.1c1f					CommandOn:
.1c1f	fa		plx				plx
.1c20	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.1c23	8d 58 04	sta $0458			sta 	onCount 					; save it.
.1c26	20 8f 10	jsr $108f			jsr 	FixUpY 						; Y = 0
.1c29					_CONFind:
.1c29	ce 58 04	dec $0458			dec 	onCount 					; reached zero, do this one
.1c2c	f0 0c		beq $1c3a			beq 	_CONFound
.1c2e	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1c2f	c8		iny				iny
.1c30	c8		iny				iny
.1c31	c8		iny				iny
.1c32	b1 22		lda ($22),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.1c34	c8		iny				iny
.1c35	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.1c37	f0 f0		beq $1c29			beq 	_CONFind
.1c39	88		dey				dey 								; point to character after last GOTO/GOSUB
.1c3a					_CONFound:
.1c3a	4c 24 10	jmp $1024			jmp 	NextCommand
.1c3d					CommandMoreOn:
.1c3d	fa		plx				plx
.1c3e	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1c3f	c8		iny				iny
.1c40	c8		iny				iny
.1c41	c8		iny				iny
.1c42	4c 24 10	jmp $1024			jmp 	NextCommand
.0458					onCount:
>0458							.fill 	1
.1c45					MOFSizeTable:
>1c45	01					.byte	1         	; $ca .shift
>1c46	01					.byte	1         	; $cb .byte
>1c47	02					.byte	2         	; $cc .word
>1c48	05					.byte	5         	; $cd .float
>1c49	ff					.byte	255       	; $ce .string
>1c4a	ff					.byte	255       	; $cf .data
>1c4b	03					.byte	3         	; $d0 .goto
>1c4c	03					.byte	3         	; $d1 .gosub
>1c4d	03					.byte	3         	; $d2 .goto.z
>1c4e	03					.byte	3         	; $d3 .goto.nz
>1c4f	02					.byte	2         	; $d4 .varspace
.1c50					UnaryPeek:
.1c50	fa		plx				plx
.1c51	20 67 19	jsr $1967			jsr 	GetInteger16Bit
.1c54	da		phx				phx
.1c55	5a		phy				phy
.1c56	a6 28		ldx $28				ldx 	zTemp0
.1c58	a4 29		ldy $29				ldy 	zTemp0+1
.1c5a	20 8e 25	jsr $258e			jsr 	XPeekMemory
.1c5d	7a		ply				ply
.1c5e	fa		plx				plx
.1c5f	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.1c62	4c 24 10	jmp $1024			jmp 	NextCommand
.1c65					CommandPOKE:
.1c65	fa		plx				plx
.1c66	da		phx				phx 								; save XY
.1c67	5a		phy				phy
.1c68	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1c6b	48		pha				pha
.1c6c	b5 4b		lda $4b,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1c6e	a8		tay				tay
.1c6f	b5 3f		lda $3f,x			lda 	NSMantissa0-1,x
.1c71	aa		tax				tax
.1c72	68		pla				pla
.1c73	20 7a 25	jsr $257a			jsr 	XPokeMemory
.1c76	7a		ply				ply 								; restore YX and drop 2
.1c77	fa		plx				plx
.1c78	ca		dex				dex
.1c79	ca		dex				dex
.1c7a	4c 24 10	jmp $1024			jmp 	NextCommand
.1c7d					UnaryPos:
.1c7d	fa		plx				plx
.1c7e	20 0d 25	jsr $250d			jsr 	XGetHPos
.1c81	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.1c84	4c 24 10	jmp $1024			jmp 	NextCommand
.1c87					GetChannel:
.1c87	fa		plx				plx
.1c88	ad 59 04	lda $0459			lda 	currentChannel
.1c8b	e8		inx				inx
.1c8c	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.1c8f	4c 24 10	jmp $1024			jmp 	NextCommand
.1c92					SetChannel:
.1c92	fa		plx				plx
.1c93	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.1c96	b5 40		lda $40,x			lda 	NSMantissa0,x
.1c98	8d 59 04	sta $0459			sta 	currentChannel
.1c9b	ca		dex				dex
.1c9c	4c 24 10	jmp $1024			jmp 	NextCommand
.1c9f					SetDefaultChannel:
.1c9f	9c 59 04	stz $0459			stz 	currentChannel
.1ca2	60		rts				rts
.1ca3					VectorPrintCharacter:
.1ca3	da		phx				phx
.1ca4	ae 59 04	ldx $0459			ldx 	currentChannel
.1ca7	20 b8 25	jsr $25b8			jsr 	XPrintCharacterToChannel
.1caa	fa		plx				plx
.1cab	60		rts				rts
.1cac					VectorGetCharacter:
.1cac	da		phx				phx
.1cad	ae 59 04	ldx $0459			ldx 	currentChannel
.1cb0	20 f1 24	jsr $24f1			jsr 	XGetCharacterFromChannel
.1cb3	fa		plx				plx
.1cb4	60		rts				rts
.0459					currentChannel:
>0459							.fill 	1
.1cb5					PrintNumber:
.1cb5	fa		plx				plx
.1cb6	a9 07		lda #$07			lda 	#7
.1cb8	20 dd 2c	jsr $2cdd			jsr 	FloatToString 				; to number in decimal buffer
.1cbb	ca		dex				dex 								; drop
.1cbc	da		phx				phx
.1cbd	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1cbf					_PNLoop:
.1cbf	bd 90 05	lda $0590,x			lda 	decimalBuffer,x
.1cc2	20 a3 1c	jsr $1ca3			jsr 	VectorPrintCharacter
.1cc5	e8		inx				inx
.1cc6	bd 90 05	lda $0590,x			lda	 	decimalBuffer,x
.1cc9	d0 f4		bne $1cbf			bne 	_PNLoop
.1ccb	a9 20		lda #$20			lda 	#32 						; trailing space
.1ccd	20 a3 1c	jsr $1ca3			jsr 	VectorPrintCharacter
.1cd0	fa		plx				plx
.1cd1	4c 24 10	jmp $1024			jmp 	NextCommand
.1cd4					PrintString:
.1cd4	fa		plx				plx
.1cd5	b5 40		lda $40,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.1cd7	85 28		sta $28				sta 	zTemp0
.1cd9	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.1cdb	85 29		sta $29				sta 	zTemp0+1
.1cdd	ca		dex				dex 								; drop
.1cde	da		phx				phx
.1cdf	5a		phy				phy
.1ce0	b2 28		lda ($28)			lda 	(zTemp0) 					; X = count
.1ce2	aa		tax				tax
.1ce3	a0 01		ldy #$01			ldy 	#1 							; Y = position
.1ce5					_PSLoop:
.1ce5	e0 00		cpx #$00			cpx 	#0 							; complete ?
.1ce7	f0 09		beq $1cf2			beq 	_PSExit
.1ce9	ca		dex				dex 								; dec count
.1cea	b1 28		lda ($28),y			lda 	(zTemp0),y 					; print char and bump
.1cec	20 a3 1c	jsr $1ca3			jsr 	VectorPrintCharacter
.1cef	c8		iny				iny
.1cf0	80 f3		bra $1ce5			bra 	_PSLoop
.1cf2					_PSExit:
.1cf2	7a		ply				ply
.1cf3	fa		plx				plx
.1cf4	4c 24 10	jmp $1024			jmp 	NextCommand
.1cf7					CommandPushN:
.1cf7	fa		plx				plx
.1cf8	e8		inx				inx 								; next slot on stack
.1cf9	b1 22		lda ($22),y			lda 	(codePtr),y 				; exponent
.1cfb	95 70		sta $70,x			sta 	NSExponent,x
.1cfd	c8		iny				iny
.1cfe	b1 22		lda ($22),y			lda 	(codePtr),y 				; mantissa
.1d00	95 40		sta $40,x			sta 	NSMantissa0,x
.1d02	c8		iny				iny
.1d03	b1 22		lda ($22),y			lda 	(codePtr),y
.1d05	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1d07	c8		iny				iny
.1d08	b1 22		lda ($22),y			lda 	(codePtr),y
.1d0a	95 58		sta $58,x			sta 	NSMantissa2,x
.1d0c	c8		iny				iny
.1d0d	b1 22		lda ($22),y			lda 	(codePtr),y
.1d0f	48		pha				pha
.1d10	29 7f		and #$7f			and 	#$7F
.1d12	95 64		sta $64,x			sta 	NSMantissa3,x
.1d14	68		pla				pla 								; sign in mantissa3:7
.1d15	29 80		and #$80			and 	#$80
.1d17	95 34		sta $34,x			sta 	NSStatus,x
.1d19	c8		iny				iny
.1d1a	4c 24 10	jmp $1024			jmp 	NextCommand
.1d1d					CommandPushS:
.1d1d	fa		plx				plx
.1d1e	e8		inx				inx 								; next slot on stack
.1d1f	18		clc				clc
.1d20	98		tya				tya
.1d21	65 22		adc $22				adc 	codePtr 					; the string is inline
.1d23	95 40		sta $40,x			sta 	NSMantissa0,x
.1d25	a5 23		lda $23				lda 	codePtr+1
.1d27	69 00		adc #$00			adc 	#0
.1d29	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1d2b	74 58		stz $58,x			stz 	NSMantissa2,x
.1d2d	74 64		stz $64,x			stz 	NSMantissa3,x
.1d2f	a9 40		lda #$40			lda 	#NSSString
.1d31	95 34		sta $34,x			sta 	NSStatus,x
.1d33	98		tya				tya 								; string length +1 added to Y
.1d34	38		sec				sec
.1d35	71 22		adc ($22),y			adc 	(codePtr),y 				; next instruction
.1d37	a8		tay				tay
.1d38	4c 24 10	jmp $1024			jmp 	NextCommand
.1d3b					CommandRead:
.1d3b	fa		plx				plx
.1d3c	5a		phy				phy 								; save Y
.1d3d	20 6e 1d	jsr $1d6e			jsr 	ReadStringToBuffer 			; read element into buffer
.1d40	e8		inx				inx									; space on stack
.1d41	a9 5b		lda #$5b			lda 	#((ReadBufferSize) & $FF)
.1d43	85 28		sta $28				sta 	0+zTemp0
.1d45	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.1d47	85 29		sta $29				sta 	1+zTemp0
.1d49	20 8d 22	jsr $228d			jsr 	ValEvaluateZTemp0
.1d4c	b0 04		bcs $1d52			bcs 	_CRError 					; failed
.1d4e	7a		ply				ply 								; restore Y
.1d4f	4c 24 10	jmp $1024			jmp 	NextCommand
.1d52					_CRError:
.1d52	4c 72 14	jmp $1472		jmp	ErrorV_value
.1d55					CommandReadString:
.1d55	fa		plx				plx
.1d56	5a		phy				phy 								; save Y
.1d57	20 6e 1d	jsr $1d6e			jsr 	ReadStringToBuffer 			; read text
.1d5a	e8		inx				inx 								; make space on stack
.1d5b	20 f5 2d	jsr $2df5			jsr 	FloatSetZero 				; store as string on stack
.1d5e	a9 5b		lda #$5b			lda 	#ReadBufferSize & $FF
.1d60	95 40		sta $40,x			sta 	NSMantissa0,x
.1d62	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.1d64	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1d66	a9 40		lda #$40			lda 	#NSSString
.1d68	95 34		sta $34,x			sta 	NSStatus,x
.1d6a	7a		ply				ply 								; restore Y
.1d6b	4c 24 10	jmp $1024			jmp 	NextCommand
.1d6e					ReadStringToBuffer:
.1d6e	a9 01		lda #$01			lda 	#((ReadBumpNext) & $FF)
.1d70	8d 5b 05	sta $055b			sta 	0+ReadBumpNextVec
.1d73	a9 1e		lda #$1e			lda 	#((ReadBumpNext) >> 8) & $FF
.1d75	8d 5c 05	sta $055c			sta 	1+ReadBumpNextVec
.1d78	a9 d4		lda #$d4			lda 	#((ReadLookNext) & $FF)
.1d7a	8d 5d 05	sta $055d			sta 	0+ReadLookNextVec
.1d7d	a9 1d		lda #$1d			lda 	#((ReadLookNext) >> 8) & $FF
.1d7f	8d 5e 05	sta $055e			sta 	1+ReadLookNextVec
.1d82					GetStringToBuffer:
.1d82	20 d1 1d	jsr $1dd1			jsr		GetLookNext 				; skip all leading spaces.
.1d85	f0 44		beq $1dcb			beq 	_RBError 					; end of data
.1d87	b0 f9		bcs $1d82			bcs 	GetStringToBuffer 			; switched to new data line.
.1d89	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1d8b	b0 05		bcs $1d92			bcs 	_RBNoSpace
.1d8d	20 ce 1d	jsr $1dce			jsr 	GetBumpNext 				; consume space and loop round.
.1d90	80 f0		bra $1d82			bra 	GetStringToBuffer
.1d92					_RBNoSpace:
.1d92	9c 5b 04	stz $045b			stz 	ReadBufferSize 				; empty the buffer.
.1d95	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.1d97	d0 08		bne $1da1			bne 	_RBCommaSep
.1d99	8d 5a 04	sta $045a			sta 	ReadSep 					; use as a seperator
.1d9c	20 ce 1d	jsr $1dce			jsr 	GetBumpNext 				; consume the '"'
.1d9f	80 05		bra $1da6			bra 	_RBGetText
.1da1					_RBCommaSep:
.1da1	a9 2c		lda #$2c			lda 	#","						; get till comma
.1da3	8d 5a 04	sta $045a			sta 	ReadSep
.1da6					_RBGetText:
.1da6	20 d1 1d	jsr $1dd1			jsr 	GetLookNext 				; what follows
.1da9	b0 18		bcs $1dc3			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.1dab	20 ce 1d	jsr $1dce			jsr 	GetBumpNext 				; consume it whatever
.1dae	cd 5a 04	cmp $045a			cmp 	ReadSep 					; if found the seperator.
.1db1	f0 10		beq $1dc3			beq 	_RBEndGet 					; exit after consumption
.1db3	da		phx				phx
.1db4	ae 5b 04	ldx $045b			ldx 	ReadBufferSize 				; copy into buffer.
.1db7	ee 5b 04	inc $045b			inc 	ReadBufferSize
.1dba	9d 5c 04	sta $045c,x			sta 	ReadBuffer,x
.1dbd	9e 5d 04	stz $045d,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.1dc0	fa		plx				plx
.1dc1	80 e3		bra $1da6			bra 	_RBGetText
.1dc3					_RBEndGet:
.1dc3	c9 22		cmp #$22			cmp 	#'"'
.1dc5	d0 03		bne $1dca			bne 	_RBNotQuote
.1dc7	20 ce 1d	jsr $1dce			jsr 	GetBumpNext
.1dca					_RBNotQuote:
.1dca	60		rts				rts
.1dcb					_RBError:
.1dcb	4c 27 15	jmp $1527		jmp	ErrorV_data
.1dce					GetBumpNext:
.1dce	6c 5b 05	jmp ($055b)			jmp 	(ReadBumpNextVec)
.1dd1					GetLookNext:
.1dd1	6c 5d 05	jmp ($055d)			jmp 	(ReadLookNextVec)
.1dd4					ReadLookNext:
.1dd4	ad 5f 05	lda $055f			lda 	dataRemaining 				; any data remaining
.1dd7	f0 04		beq $1ddd			beq 	_RLNFindData
.1dd9	b2 25		lda ($25)			lda 	(objPtr) 					; return that object.
.1ddb	18		clc				clc
.1ddc	60		rts				rts
.1ddd					_RLNFindData:
.1ddd	b2 25		lda ($25)			lda 	(objPtr) 					; see where we are
.1ddf	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.1de1	f0 1a		beq $1dfd			beq 	_RLNNoData
.1de3	c9 cf		cmp #$cf			cmp 	#PCD_CMD_DATA 				; Found DATA
.1de5	f0 05		beq $1dec			beq 	_RLNHaveData
.1de7					_RLNNext:
.1de7	20 16 16	jsr $1616			jsr 	MoveObjectForward			; else scan forward.
.1dea	80 f1		bra $1ddd			bra 	_RLNFindData
.1dec					_RLNHaveData:
.1dec	a0 01		ldy #$01			ldy 	#1 							; get length
.1dee	b1 25		lda ($25),y			lda 	(objPtr),y
.1df0	f0 f5		beq $1de7			beq 	_RLNNext 					; skip if DATA alone
.1df2	20 01 1e	jsr $1e01			jsr 	ReadBumpNext 				; advance by two
.1df5	20 01 1e	jsr $1e01			jsr 	ReadBumpNext
.1df8	8d 5f 05	sta $055f			sta 	dataRemaining 				; set data left count.
.1dfb	38		sec				sec
.1dfc	60		rts				rts
.1dfd					_RLNNoData:
.1dfd	a9 00		lda #$00			lda 	#0
.1dff	38		sec				sec
.1e00	60		rts				rts
.1e01					ReadBumpNext:
.1e01	e6 25		inc $25				inc 	objPtr
.1e03	d0 02		bne $1e07			bne 	_RBNSkip
.1e05	e6 26		inc $26				inc 	objPtr+1
.1e07					_RBNSkip:
.1e07	ce 5f 05	dec $055f			dec 	dataRemaining
.1e0a	60		rts				rts
.045a					ReadSep:
>045a							.fill 	1
.045b					ReadBufferSize:
>045b							.fill 	1
.045c					ReadBuffer:
>045c							.fill 	255
.055b					ReadBumpNextVec:
>055b							.fill 	2
.055d					ReadLookNextVec:
>055d							.fill 	2
.1e0b					ReadFloatCommand:
.1e0b	fa		plx				plx
.1e0c	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1e0e	85 28		sta $28				sta 	zTemp0 						; save in MSB
.1e10	88		dey				dey 								; get the upper 3 bits
.1e11	b1 22		lda ($22),y			lda 	(codePtr),y
.1e13	29 07		and #$07			and 	#7
.1e15	c8		iny				iny
.1e16	c8		iny				iny
.1e17	06 28		asl $28				asl 	zTemp0 						; shift zTemp0:A left
.1e19	2a		rol a				rol 	a 							; carry will be clear.
.1e1a	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.1e1c	85 29		sta $29				sta 	zTemp0+1
.1e1e	20 24 1e	jsr $1e24			jsr 	ReadFloatZTemp0Sub
.1e21	4c 24 10	jmp $1024			jmp 	NextCommand
.1e24					ReadFloatZTemp0Sub:
.1e24	5a		phy				phy 								; start write
.1e25	a0 01		ldy #$01			ldy 	#1
.1e27	e8		inx				inx
.1e28	b2 28		lda ($28)			lda 	(zTemp0)
.1e2a	95 40		sta $40,x			sta 	NSMantissa0,x
.1e2c	b1 28		lda ($28),y			lda 	(zTemp0),y
.1e2e	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1e30	c8		iny				iny
.1e31	b1 28		lda ($28),y			lda 	(zTemp0),y
.1e33	95 58		sta $58,x			sta 	NSMantissa2,x
.1e35	c8		iny				iny
.1e36	b1 28		lda ($28),y			lda 	(zTemp0),y
.1e38	95 64		sta $64,x			sta 	NSMantissa3,x
.1e3a	c8		iny				iny
.1e3b	b1 28		lda ($28),y			lda 	(zTemp0),y
.1e3d	95 70		sta $70,x			sta 	NSExponent,x
.1e3f	c8		iny				iny
.1e40	b1 28		lda ($28),y			lda 	(zTemp0),y
.1e42	95 34		sta $34,x			sta 	NSStatus,x
.1e44	7a		ply				ply
.1e45	60		rts				rts
.1e46					ReadIntegerCommand:
.1e46	fa		plx				plx
.1e47	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1e49	85 28		sta $28				sta 	zTemp0 						; save in MSB
.1e4b	88		dey				dey 								; get the upper 3 bits
.1e4c	b1 22		lda ($22),y			lda 	(codePtr),y
.1e4e	29 07		and #$07			and 	#7
.1e50	c8		iny				iny
.1e51	c8		iny				iny
.1e52	06 28		asl $28				asl 	zTemp0 						; shift zTemp0:A left
.1e54	2a		rol a				rol 	a 							; carry will be clear.
.1e55	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.1e57	85 29		sta $29				sta 	zTemp0+1
.1e59	20 5f 1e	jsr $1e5f			jsr 	ReadIntegerZTemp0Sub
.1e5c	4c 24 10	jmp $1024			jmp 	NextCommand
.1e5f					ReadIntegerZTemp0Sub:
.1e5f	5a		phy				phy 								; start write
.1e60	a0 01		ldy #$01			ldy 	#1
.1e62	e8		inx				inx 								; prepare
.1e63	74 58		stz $58,x			stz 	NSMantissa2,x
.1e65	74 64		stz $64,x			stz 	NSMantissa3,x
.1e67	74 70		stz $70,x			stz 	NSExponent,x
.1e69	74 34		stz $34,x			stz 	NSStatus,x
.1e6b	b1 28		lda ($28),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1e6d	30 08		bmi $1e77			bmi 	_RIZNegative
.1e6f	95 4c		sta $4c,x			sta 	NSMantissa1,x 				; +ve read
.1e71	b2 28		lda ($28)			lda 	(zTemp0)
.1e73	95 40		sta $40,x			sta 	NSMantissa0,x
.1e75	7a		ply				ply
.1e76	60		rts				rts
.1e77					_RIZNegative:
.1e77	38		sec				sec 								; -ve read
.1e78	a9 00		lda #$00			lda 	#0
.1e7a	f2 28		sbc ($28)			sbc 	(zTemp0)
.1e7c	95 40		sta $40,x			sta 	NSMantissa0,x
.1e7e	a9 00		lda #$00			lda 	#0
.1e80	f1 28		sbc ($28),y			sbc 	(zTemp0),y
.1e82	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1e84	a9 80		lda #$80			lda 	#$80
.1e86	95 34		sta $34,x			sta 	NSStatus,x
.1e88	7a		ply				ply
.1e89	60		rts				rts
.1e8a					ReadStringCommand:
.1e8a	fa		plx				plx
.1e8b	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1e8d	85 28		sta $28				sta 	zTemp0 						; save in MSB
.1e8f	88		dey				dey 								; get the upper 3 bits
.1e90	b1 22		lda ($22),y			lda 	(codePtr),y
.1e92	29 07		and #$07			and 	#7
.1e94	c8		iny				iny
.1e95	c8		iny				iny
.1e96	06 28		asl $28				asl 	zTemp0 						; shift zTemp0:A left
.1e98	2a		rol a				rol 	a 							; carry will be clear.
.1e99	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.1e9b	85 29		sta $29				sta 	zTemp0+1
.1e9d	20 a3 1e	jsr $1ea3			jsr 	ReadStringZTemp0Sub
.1ea0	4c 24 10	jmp $1024			jmp 	NextCommand
.1ea3					ReadStringZTemp0Sub:
.1ea3	5a		phy				phy 								; start write
.1ea4	e8		inx				inx 								; prepare
.1ea5	74 58		stz $58,x			stz 	NSMantissa2,x
.1ea7	74 64		stz $64,x			stz 	NSMantissa3,x
.1ea9	74 70		stz $70,x			stz 	NSExponent,x
.1eab	a9 40		lda #$40			lda 	#NSSString
.1ead	74 34		stz $34,x			stz 	NSStatus,x
.1eaf	18		clc				clc
.1eb0	b2 28		lda ($28)			lda 	(zTemp0)					; read address of block add 2.
.1eb2	69 02		adc #$02			adc 	#2 							; this points to actual data
.1eb4	95 40		sta $40,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.1eb6	a0 01		ldy #$01			ldy 	#1
.1eb8	b1 28		lda ($28),y			lda 	(zTemp0),y
.1eba	69 00		adc #$00			adc 	#0
.1ebc	95 4c		sta $4c,x			sta 	NSMantissa1,x 				; +ve read
.1ebe	d0 08		bne $1ec8			bne 	_RSZNoDefault 				; if read $00 use a default value.
.1ec0	a9 ca		lda #$ca			lda 	#_RSZNull & $FF
.1ec2	95 40		sta $40,x			sta 	NSMantissa0,x
.1ec4	a9 1e		lda #$1e			lda 	#_RSZNull >> 8
.1ec6	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1ec8					_RSZNoDefault:
.1ec8	7a		ply				ply
.1ec9	60		rts				rts
.1eca					_RSZNull:
>1eca	00						.byte 	0
.1ecb					CommandRestore:
.1ecb	fa		plx				plx
.1ecc	20 d2 1e	jsr $1ed2			jsr 	RestoreCode
.1ecf	4c 24 10	jmp $1024			jmp 	NextCommand
.1ed2					RestoreCode:
.1ed2	a9 74		lda #$74			lda 	#((EndProgram+2) & $FF)
.1ed4	85 25		sta $25				sta 	0+objPtr
.1ed6	a9 31		lda #$31			lda 	#((EndProgram+2) >> 8) & $FF
.1ed8	85 26		sta $26				sta 	1+objPtr
.1eda	64 27		stz $27				stz  	objPage
.1edc	9c 5f 05	stz $055f			stz 	dataRemaining 				; no data remaining.
.1edf	60		rts				rts
.055f					dataRemaining:
>055f							.fill 	1		 					; 0 if not in data statement
.1ee0					UnaryRND:
.1ee0	fa		plx				plx
.1ee1	34 34		bit $34,x			bit 	NSStatus,x 					; -ve then set seed from operand
.1ee3	10 17		bpl $1efc			bpl 	_URNoSeed
.1ee5	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise 				; some float value
.1ee8	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy to Mantissa
.1eea	8d 60 05	sta $0560			sta 	randomSeed+0
.1eed	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.1eef	8d 61 05	sta $0561			sta 	randomSeed+1
.1ef2	b5 58		lda $58,x			lda 	NSMantissa2,x
.1ef4	8d 62 05	sta $0562			sta 	randomSeed+2
.1ef7	b5 64		lda $64,x			lda 	NSMantissa3,x
.1ef9	8d 63 05	sta $0563			sta 	randomSeed+3
.1efc					_URNoSeed:
.1efc	20 1e 1f	jsr $1f1e			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.1eff	ad 60 05	lda $0560			lda 	randomSeed+0
.1f02	95 40		sta $40,x			sta 	NSMantissa0,x
.1f04	ad 61 05	lda $0561			lda 	randomSeed+1
.1f07	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1f09	ad 62 05	lda $0562			lda 	randomSeed+2
.1f0c	95 58		sta $58,x			sta 	NSMantissa2,x
.1f0e	ad 63 05	lda $0563			lda 	randomSeed+3
.1f11	29 7f		and #$7f			and 	#$7F
.1f13	95 64		sta $64,x			sta 	NSMantissa3,x
.1f15	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.1f17	95 70		sta $70,x			sta 	NSExponent,x
.1f19	74 34		stz $34,x			stz 	NSStatus,x
.1f1b	4c 24 10	jmp $1024			jmp 	NextCommand
.1f1e					RandomNumberGenerator:
.1f1e	5a		phy				phy
.1f1f	ad 60 05	lda $0560			lda 	randomSeed+0 				; check if zero
.1f22	0d 61 05	ora $0561			ora 	randomSeed+1
.1f25	0d 62 05	ora $0562			ora 	randomSeed+2
.1f28	0d 63 05	ora $0563			ora 	randomSeed+3
.1f2b	d0 07		bne $1f34			bne 	_RNGNoSeed
.1f2d	ce 63 05	dec $0563			dec 	randomSeed+3 				; if so tweak and flog
.1f30	a0 64		ldy #$64			ldy 	#100
.1f32	80 05		bra $1f39			bra 	_RNGLoop
.1f34					_RNGNoSeed:
.1f34	a0 08		ldy #$08			ldy 	#8
.1f36	ad 60 05	lda $0560			lda 	randomSeed+0
.1f39					_RNGLoop:
.1f39	0a		asl a				asl		a
.1f3a	2e 61 05	rol $0561			rol 	randomSeed+1
.1f3d	2e 62 05	rol $0562			rol 	randomSeed+2
.1f40	2e 63 05	rol $0563			rol 	randomSeed+3
.1f43	90 02		bcc $1f47			bcc		_RNGSkip
.1f45	49 c5		eor #$c5			eor 	#$C5
.1f47					_RNGSkip:
.1f47	88		dey				dey
.1f48	d0 ef		bne $1f39			bne		_RNGLoop
.1f4a	8d 60 05	sta $0560			sta 	randomSeed+0
.1f4d	7a		ply				ply
.1f4e	60		rts				rts
.0560					randomSeed:
>0560							.fill 	4
.1f4f					StringConcatenate:
.1f4f	fa		plx				plx
.1f50	ca		dex				dex
.1f51	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.1f53	85 2a		sta $2a				sta 	zTemp1
.1f55	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.1f57	85 2b		sta $2b				sta 	zTemp1+1
.1f59	b5 41		lda $41,x			lda 	NSMantissa0+1,x
.1f5b	85 2c		sta $2c				sta 	zTemp2
.1f5d	b5 4d		lda $4d,x			lda 	NSMantissa1+1,x
.1f5f	85 2d		sta $2d				sta 	zTemp2+1
.1f61	18		clc				clc 								; work out total length
.1f62	b2 2a		lda ($2a)			lda 	(zTemp1)
.1f64	72 2c		adc ($2c)			adc 	(zTemp2)
.1f66	b0 18		bcs $1f80			bcs 	_BCLength 					; more than 255 characters.
.1f68	48		pha				pha 								; save total
.1f69	20 46 20	jsr $2046			jsr 	StringAllocTemp 			; space for result.
.1f6c	68		pla				pla 								; write total as first.
.1f6d	92 2e		sta ($2e)			sta 	(zsTemp)
.1f6f	20 83 1f	jsr $1f83			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.1f72	a5 2c		lda $2c				lda 	zTemp2 						; copy address zTemp2->1
.1f74	85 2a		sta $2a				sta 	zTemp1
.1f76	a5 2d		lda $2d				lda 	zTemp2+1
.1f78	85 2b		sta $2b				sta 	zTemp1+1
.1f7a	20 83 1f	jsr $1f83			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1f7d	4c 24 10	jmp $1024			jmp 	NextCommand
.1f80					_BCLength:
.1f80	4c 62 14	jmp $1462		jmp	ErrorV_range
.1f83					_BCCopyZTemp1:
.1f83	b2 2a		lda ($2a)			lda 	(zTemp1) 					; bytes to copy
.1f85	f0 15		beq $1f9c			beq 	_BCCExit 					; none.
.1f87	da		phx				phx 								; save XY
.1f88	5a		phy				phy
.1f89	aa		tax				tax 								; count in X.
.1f8a	a0 01		ldy #$01			ldy 	#1
.1f8c					_BCCLoop:
.1f8c	e6 2e		inc $2e				inc 	zsTemp 						; bump pointer, pre-increment
.1f8e	d0 02		bne $1f92			bne 	_BCCNoCarry
.1f90	e6 2f		inc $2f				inc 	zsTemp+1
.1f92					_BCCNoCarry:
.1f92	b1 2a		lda ($2a),y			lda 	(zTemp1),y				 	; copy bytes
.1f94	92 2e		sta ($2e)			sta 	(zsTemp)
.1f96	c8		iny				iny
.1f97	ca		dex				dex 								; X times
.1f98	d0 f2		bne $1f8c			bne 	_BCCLoop
.1f9a	7a		ply				ply 								; restore YX
.1f9b	fa		plx				plx
.1f9c					_BCCExit:
.1f9c	60		rts				rts
.1f9d					XRuntimeSetup:
.1f9d	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1f9f	8d 67 05	sta $0567	 		sta 	ramBank
.1fa2	8d 68 05	sta $0568	 		sta 	romBank
.1fa5	60		rts				rts
.1fa6					SignTOS:
.1fa6	fa		plx				plx
.1fa7	20 17 2e	jsr $2e17			jsr 	FloatIsZero 				; if zero
.1faa	f0 0f		beq $1fbb			beq 	_SGZero  					; return Int Zero
.1fac	b5 34		lda $34,x			lda 	NSStatus,x 					; get status w/sign
.1fae	48		pha				pha
.1faf	a9 01		lda #$01			lda 	#1 							; set result to 1
.1fb1	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.1fb4	68		pla				pla
.1fb5	29 80		and #$80			and		#$80 						; copy the sign byte out
.1fb7	95 34		sta $34,x			sta 	NSStatus,x  				; so it will be -1 or 1
.1fb9	80 03		bra $1fbe			bra 	_SGExit
.1fbb					_SGZero:
.1fbb	20 f5 2d	jsr $2df5			jsr 	FloatSetZero
.1fbe					_SGExit:
.1fbe	4c 24 10	jmp $1024			jmp 	NextCommand
.1fc1					CommandShift:
.1fc1	b1 22		lda ($22),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.1fc3	c8		iny				iny
.1fc4	0a		asl a				asl 	a 							; double into X
.1fc5	aa		tax				tax
.1fc6	7c 71 23	jmp ($2371,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.1fc9					PrintTab:
.1fc9	fa		plx				plx
.1fca	20 0d 25	jsr $250d			jsr 	XGetHPos
.1fcd					_PTMod10:
.1fcd	38		sec				sec
.1fce	e9 0a		sbc #$0a			sbc 	#10
.1fd0	b0 fb		bcs $1fcd			bcs 	_PTMod10
.1fd2	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.1fd4	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.1fd5	80 15		bra $1fec			bra 	PrintSpaceLoop
.1fd7					PrintPos:
.1fd7	fa		plx				plx
.1fd8	20 0d 25	jsr $250d			jsr		XGetHPos 					; get current position
.1fdb	85 28		sta $28				sta 	zTemp0
.1fdd	38		sec				sec 								; calculate spaces required
.1fde	b5 40		lda $40,x			lda 	NSMantissa0,x
.1fe0	ca		dex				dex
.1fe1	e5 28		sbc $28				sbc 	zTemp0
.1fe3	b0 07		bcs $1fec			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.1fe5	4c 24 10	jmp $1024			jmp 	NextCommand
.1fe8					PrintSpace:
.1fe8	fa		plx				plx
.1fe9	b5 40		lda $40,x			lda 	NSMantissa0,x
.1feb	ca		dex				dex
.1fec					PrintSpaceLoop:
.1fec	c9 00		cmp #$00			cmp 	#0
.1fee	f0 0a		beq $1ffa			beq 	_PSExit
.1ff0	48		pha				pha
.1ff1	a9 20		lda #$20			lda 	#" "
.1ff3	20 a3 1c	jsr $1ca3			jsr 	VectorPrintCharacter
.1ff6	68		pla				pla
.1ff7	3a		dec a				dec 	a
.1ff8	80 f2		bra $1fec			bra 	PrintSpaceLoop
.1ffa					_PSExit:
.1ffa	4c 24 10	jmp $1024			jmp 	NextCommand
.1ffd					CommandStop:
.1ffd	fa		plx				plx
.1ffe	4c 14 15	jmp $1514		jmp	ErrorV_stop
.2001					Unary_Str:
.2001	fa		plx				plx
.2002	5a		phy				phy
.2003	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.2005	20 dd 2c	jsr $2cdd			jsr 	FloatToString 				; do the conversion.
.2008	a9 21		lda #$21			lda		#33 						; create buffer
.200a	20 46 20	jsr $2046			jsr 	StringAllocTemp 			; allocate memory
.200d	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.200f					_USCopy:
.200f	b9 8f 05	lda $058f,y			lda 	decimalBuffer-1,y
.2012	f0 05		beq $2019			beq 	_USExit
.2014	91 2e		sta ($2e),y			sta 	(zsTemp),y
.2016	c8		iny				iny
.2017	80 f6		bra $200f			bra 	_USCopy
.2019					_USExit:
.2019	98		tya				tya
.201a	3a		dec a				dec 	a
.201b	92 2e		sta ($2e)			sta 	(zsTemp)
.201d	7a		ply				ply
.201e	4c 24 10	jmp $1024			jmp 	NextCommand
.2021					StringInitialise:
.2021	48		pha				pha
.2022	ad 64 05	lda $0564			lda 	stringInitialised 			; already done
.2025	d0 11		bne $2038			bne 	_SIExit
.2027	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.202a	8d 65 05	sta $0565			sta 	stringTempPointer
.202d	ad 03 04	lda $0403			lda 	stringHighMemory+1
.2030	3a		dec a				dec 	a
.2031	3a		dec a				dec 	a
.2032	8d 66 05	sta $0566			sta 	stringTempPointer+1
.2035	ce 64 05	dec $0564			dec 	stringInitialised 			; set the initialised flag.
.2038					_SIExit:
.2038	a5 33		lda $33				lda 	availableMemory+1 			; check out of memory
.203a	1a		inc a				inc 	a
.203b	1a		inc a				inc 	a
.203c	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.203f	b0 02		bcs $2043			bcs 	_SIMemory
.2041	68		pla				pla
.2042	60		rts				rts
.2043					_SIMemory:
.2043	4c 6d 15	jmp $156d		jmp	ErrorV_memory
.2046					StringAllocTemp:
.2046	20 21 20	jsr $2021			jsr 	StringInitialise 			; check it is initialised.
.2049	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.204b	18		clc				clc
.204c	6d 65 05	adc $0565			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.204f	8d 65 05	sta $0565			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.2052	85 2e		sta $2e				sta 	zsTemp
.2054	95 40		sta $40,x			sta 	NSMantissa0,x
.2056	ad 66 05	lda $0566			lda 	stringTempPointer+1
.2059	69 ff		adc #$ff			adc 	#$FF
.205b	8d 66 05	sta $0566			sta 	stringTempPointer+1
.205e	85 2f		sta $2f				sta 	zsTemp+1
.2060	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2062	74 58		stz $58,x			stz 	NSMantissa2,x
.2064	74 64		stz $64,x			stz 	NSMantissa3,x
.2066	a9 00		lda #$00			lda 	#0 							; clear string.
.2068	92 2e		sta ($2e)			sta 	(zsTemp)
.206a	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.206c	95 34		sta $34,x			sta 	NSStatus,x
.206e	60		rts				rts
.206f					StringWriteChar:
.206f	5a		phy				phy
.2070	48		pha				pha
.2071	b2 2e		lda ($2e)			lda 	(zsTemp)
.2073	1a		inc a				inc 	a
.2074	92 2e		sta ($2e)			sta 	(zsTemp)
.2076	a8		tay				tay
.2077	68		pla				pla
.2078	91 2e		sta ($2e),y			sta 	(zsTemp),y
.207a	7a		ply				ply
.207b	60		rts				rts
.0564					stringInitialised:
>0564							.fill 	1
.0565					stringTempPointer:
>0565							.fill 	2
.207c					Unary_Left:
.207c	fa		plx				plx
.207d	5a		phy				phy
.207e	18		clc				clc 								; only one parameter
.207f	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; push the length of the string.
.2082	48		pha				pha
.2083	ca		dex				dex
.2084	a9 00		lda #$00			lda 	#0 							; push the start position.
.2086	48		pha				pha
.2087	20 bf 20	jsr $20bf			jsr 	UnarySStringToZTemp0
.208a	80 3c		bra $20c8			bra 	SubstringMain 				; stack now points to the string to slice.
.208c					Unary_Right:
.208c	fa		plx				plx
.208d	5a		phy				phy
.208e	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.2090	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; push the right length of the string.
.2093	48		pha				pha
.2094	ca		dex				dex
.2095	20 bf 20	jsr $20bf			jsr 	UnarySStringToZTemp0
.2098	68		pla				pla 								; this is the right requirement
.2099	38		sec				sec
.209a	49 ff		eor #$ff			eor 	#$FF
.209c	72 28		adc ($28)			adc 	(zTemp0)
.209e	b0 02		bcs $20a2			bcs 	_URHaveCount
.20a0	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.20a2					_URHaveCount:
.20a2	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.20a4	5a		phy				phy
.20a5	48		pha				pha 								; start position
.20a6	80 20		bra $20c8			bra 	SubstringMain
.20a8					Unary_Mid:
.20a8	fa		plx				plx
.20a9	5a		phy				phy
.20aa	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; push the length of the string required.
.20ad	48		pha				pha
.20ae	ca		dex				dex
.20af	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; put the start position.
.20b2	f0 08		beq $20bc			beq 	_UMError
.20b4	3a		dec a				dec 	a
.20b5	48		pha				pha
.20b6	ca		dex				dex
.20b7	20 bf 20	jsr $20bf			jsr 	UnarySStringToZTemp0
.20ba	80 0c		bra $20c8			bra 	SubstringMain 				; stack now points to the string to slice.
.20bc					_UMError:
.20bc	4c 62 14	jmp $1462		jmp	ErrorV_range
.20bf					UnarySStringToZTemp0:
.20bf	b5 40		lda $40,x			lda 	NSMantissa0,x
.20c1	85 28		sta $28				sta 	zTemp0
.20c3	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.20c5	85 29		sta $29				sta 	zTemp0+1
.20c7	60		rts				rts
.20c8					SubstringMain:
.20c8	68		pla				pla 								; get the start offset
.20c9	7a		ply				ply 								; get the count to do.
.20ca	d2 28		cmp ($28)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.20cc	b0 38		bcs $2106			bcs 	_SSReturnNull
.20ce	85 2a		sta $2a				sta 	zTemp1 						; save start position.
.20d0	84 2b		sty $2b				sty 	zTemp1+1 					; save count
.20d2	18		clc				clc
.20d3	65 2b		adc $2b				adc 	zTemp1+1 					; this is the end position.
.20d5	b0 06		bcs $20dd			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.20d7	d2 28		cmp ($28)			cmp 	(zTemp0) 					; ok if limit is <= length.
.20d9	f0 04		beq $20df			beq 	_SMIsOkay
.20db	90 02		bcc $20df			bcc 	_SMIsOkay
.20dd					_SMTruncateToEnd:
.20dd	b2 28		lda ($28)			lda 	(zTemp0) 					; end position is length.
.20df					_SMIsOkay:
.20df	85 2b		sta $2b				sta 	zTemp1+1
.20e1	38		sec				sec		 							; work out size
.20e2	a5 2b		lda $2b				lda 	zTemp1+1
.20e4	e5 2a		sbc $2a				sbc 	zTemp1
.20e6	f0 1e		beq $2106			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.20e8	20 46 20	jsr $2046			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.20eb	a4 2a		ldy $2a				ldy 	zTemp1 						; start
.20ed					_SMCopy:
.20ed	c4 2b		cpy $2b				cpy 	zTemp1+1 					; exit if reached end
.20ef	f0 11		beq $2102			beq 	_SMExit
.20f1	c8		iny				iny 								; bump and
.20f2	b1 28		lda ($28),y			lda 	(zTemp0),y 					; get character (prefix)
.20f4	5a		phy				phy
.20f5	48		pha				pha
.20f6	b2 2e		lda ($2e)			lda 	(zsTemp) 					; bump length => Y
.20f8	1a		inc a				inc 	a
.20f9	a8		tay				tay
.20fa	92 2e		sta ($2e)			sta 	(zsTemp)
.20fc	68		pla				pla 								; write character out
.20fd	91 2e		sta ($2e),y			sta 	(zsTemp),y
.20ff	7a		ply				ply 								; restore Y
.2100	80 eb		bra $20ed			bra 	_SMCopy
.2102					_SMExit:
.2102	7a		ply				ply
.2103	4c 24 10	jmp $1024			jmp 	NextCommand
.2106					_SSReturnNull:
.2106	a9 18		lda #$18			lda 	#SSRNull & $FF 				; set up mantissa
.2108	95 40		sta $40,x			sta 	NSMantissa0,x
.210a	a9 21		lda #$21			lda 	#SSRNull >> 8
.210c	95 4c		sta $4c,x			sta 	NSMantissa1,x
.210e	74 58		stz $58,x			stz 	NSMantissa2,x
.2110	74 64		stz $64,x			stz 	NSMantissa3,x
.2112	a9 40		lda #$40			lda 	#NSSString
.2114	95 34		sta $34,x			sta 	NSStatus,x
.2116	80 ea		bra $2102			bra 	_SMExit
.2118					SSRNull:
>2118	00 00						.word 	0
.211a					CommandSwap:
.211a	fa		plx				plx
.211b	b5 40		lda $40,x			lda 	NSMantissa0,x
.211d	48		pha				pha
.211e	b5 3f		lda $3f,x			lda 	NSMantissa0-1,x
.2120	95 40		sta $40,x			sta 	NSMantissa0,x
.2122	68		pla				pla
.2123	95 3f		sta $3f,x			sta 	NSMantissa0-1,x
.2125	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2127	48		pha				pha
.2128	b5 4b		lda $4b,x			lda 	NSMantissa1-1,x
.212a	95 4c		sta $4c,x			sta 	NSMantissa1,x
.212c	68		pla				pla
.212d	95 4b		sta $4b,x			sta 	NSMantissa1-1,x
.212f	b5 58		lda $58,x			lda 	NSMantissa2,x
.2131	48		pha				pha
.2132	b5 57		lda $57,x			lda 	NSMantissa2-1,x
.2134	95 58		sta $58,x			sta 	NSMantissa2,x
.2136	68		pla				pla
.2137	95 57		sta $57,x			sta 	NSMantissa2-1,x
.2139	b5 64		lda $64,x			lda 	NSMantissa3,x
.213b	48		pha				pha
.213c	b5 63		lda $63,x			lda 	NSMantissa3-1,x
.213e	95 64		sta $64,x			sta 	NSMantissa3,x
.2140	68		pla				pla
.2141	95 63		sta $63,x			sta 	NSMantissa3-1,x
.2143	b5 70		lda $70,x			lda 	NSExponent,x
.2145	48		pha				pha
.2146	b5 6f		lda $6f,x			lda 	NSExponent-1,x
.2148	95 70		sta $70,x			sta 	NSExponent,x
.214a	68		pla				pla
.214b	95 6f		sta $6f,x			sta 	NSExponent-1,x
.214d	b5 34		lda $34,x			lda 	NSStatus,x
.214f	48		pha				pha
.2150	b5 33		lda $33,x			lda 	NSStatus-1,x
.2152	95 34		sta $34,x			sta 	NSStatus,x
.2154	68		pla				pla
.2155	95 33		sta $33,x			sta 	NSStatus-1,x
.2157	4c 24 10	jmp $1024			jmp 	NextCommand
.215a					CommandSYS:
.215a	fa		plx				plx
.215b	da		phx				phx 								; save XY
.215c	5a		phy				phy
.215d	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.2160	b5 4c		lda $4c,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.2162	85 29		sta $29				sta 	zTemp0+1
.2164	b5 40		lda $40,x			lda 	NSMantissa0,x
.2166	85 28		sta $28				sta 	zTemp0
.2168	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.216b	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.216e	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.2171	48		pha				pha
.2172	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.2175	28		plp				plp
.2176	20 8d 21	jsr $218d			jsr 	_CSZTemp0
.2179	08		php				php
.217a	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.217d	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.2180	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.2183	68		pla				pla
.2184	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.2187	7a		ply				ply 								; restore YX and drop 2
.2188	fa		plx				plx
.2189	ca		dex				dex
.218a	4c 24 10	jmp $1024			jmp 	NextCommand
.218d					_CSZTemp0:
.218d	6c 28 00	jmp ($0028)			jmp 	(zTemp0)
.2190					TimeTOS:
.2190	fa		plx				plx
.2191	20 eb 21	jsr $21eb			jsr 	TIPushClock 				; push clock to TOS
.2194	4c 24 10	jmp $1024			jmp 	NextCommand
.2197					TimeString:
.2197	fa		plx				plx
.2198	20 eb 21	jsr $21eb			jsr 	TIPushClock 				; push clock to TOS
.219b	20 c0 21	jsr $21c0			jsr 	_TSDivMod60 				; result in seconds
.219e	20 c0 21	jsr $21c0			jsr 	_TSDivMod60 				; seconds
.21a1	48		pha				pha
.21a2	20 c0 21	jsr $21c0			jsr 	_TSDivMod60 				; minutes
.21a5	48		pha				pha
.21a6	a9 18		lda #$18			lda 	#24 						; hours
.21a8	20 c2 21	jsr $21c2			jsr 	_TSDivModA
.21ab	48		pha				pha
.21ac	a9 06		lda #$06			lda 	#6
.21ae	20 46 20	jsr $2046			jsr 	StringAllocTemp
.21b1	68		pla				pla
.21b2	20 d2 21	jsr $21d2			jsr 	_TSWriteDecimal
.21b5	68		pla				pla
.21b6	20 d2 21	jsr $21d2			jsr 	_TSWriteDecimal
.21b9	68		pla				pla
.21ba	20 d2 21	jsr $21d2			jsr 	_TSWriteDecimal
.21bd	4c 24 10	jmp $1024			jmp 	NextCommand
.21c0					_TSDivMod60:
.21c0	a9 3c		lda #$3c			lda 	#60
.21c2					_TSDivModA:
.21c2	e8		inx				inx
.21c3	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.21c6	ca		dex				dex
.21c7	20 8b 29	jsr $298b			jsr 	Int32Divide
.21ca	b5 40		lda $40,x			lda 	NSMantissa0,x 				; get modulus
.21cc	48		pha				pha
.21cd	20 7a 29	jsr $297a			jsr 	NSMCopyPlusTwoToZero
.21d0	68		pla				pla
.21d1	60		rts				rts
.21d2					_TSWriteDecimal:
.21d2	da		phx				phx
.21d3	a2 30		ldx #$30			ldx 	#'0'
.21d5					_TSWDLoop:
.21d5	c9 0a		cmp #$0a			cmp 	#10
.21d7	90 05		bcc $21de			bcc 	_TSWDEnd
.21d9	e9 0a		sbc #$0a			sbc 	#10
.21db	e8		inx				inx
.21dc	80 f7		bra $21d5			bra 	_TSWDLoop
.21de					_TSWDEnd:
.21de	48		pha				pha
.21df	8a		txa				txa
.21e0	20 6f 20	jsr $206f			jsr 	StringWriteChar
.21e3	68		pla				pla
.21e4	09 30		ora #$30			ora 	#'0'
.21e6	20 6f 20	jsr $206f			jsr 	StringWriteChar
.21e9	fa		plx				plx
.21ea	60		rts				rts
.21eb					TIPushClock:
.21eb	5a		phy				phy
.21ec	e8		inx				inx 								; push 0 on the stack
.21ed	20 f5 2d	jsr $2df5			jsr 	FloatSetZero
.21f0	da		phx				phx
.21f1	20 d8 25	jsr $25d8			jsr 	XReadClock 					; read time into YXA
.21f4	86 28		stx $28				stx 	zTemp0
.21f6	fa		plx				plx
.21f7	95 40		sta $40,x			sta 	NSMantissa0,x
.21f9	a5 28		lda $28				lda 	zTemp0
.21fb	95 4c		sta $4c,x			sta 	NSMantissa1,x
.21fd	98		tya				tya
.21fe	95 58		sta $58,x			sta 	NSMantissa2,x
.2200	7a		ply				ply
.2201	60		rts				rts
.2202					CommandTIWrite:
.2202	fa		plx				plx
.2203	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.2205	85 2e		sta $2e				sta 	zsTemp
.2207	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2209	85 2f		sta $2f				sta 	zsTemp+1
.220b	b2 2e		lda ($2e)			lda 	(zsTemp) 					; check if it is six
.220d	c9 06		cmp #$06			cmp 	#6
.220f	d0 59		bne $226a			bne 	_CTIWError
.2211	20 f5 2d	jsr $2df5			jsr 	FloatSetZero
.2214	20 36 22	jsr $2236			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.2217	20 36 22	jsr $2236			jsr 	_CTIWDigitPair
.221a	20 36 22	jsr $2236			jsr 	_CTIWDigitPair
.221d	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.221f	20 61 22	jsr $2261			jsr 	_CTIWMultiply
.2222	da		phx				phx
.2223	5a		phy				phy
.2224	b5 4c		lda $4c,x			lda 	NSMantissa1,x 				; get time into YXA
.2226	48		pha				pha
.2227	b5 58		lda $58,x			lda 	NSMantissa2,x
.2229	a8		tay				tay
.222a	b5 40		lda $40,x			lda 	NSMantissa0,x
.222c	fa		plx				plx
.222d	20 dc 25	jsr $25dc			jsr 	XWriteClock 				; update the clock.
.2230	7a		ply				ply
.2231	fa		plx				plx
.2232	ca		dex				dex 								; throw result.
.2233	4c 24 10	jmp $1024			jmp 	NextCommand
.2236					_CTIWDigitPair:
.2236	a9 06		lda #$06			lda 	#6 							; x 6
.2238	20 61 22	jsr $2261			jsr 	_CTIWMultiply
.223b	20 47 22	jsr $2247			jsr 	_CTIWAddDigit 				; add digit
.223e	a9 0a		lda #$0a			lda 	#10 						; x 10
.2240	20 61 22	jsr $2261			jsr 	_CTIWMultiply
.2243	20 47 22	jsr $2247			jsr 	_CTIWAddDigit 				; add digit
.2246	60		rts				rts
.2247					_CTIWAddDigit:
.2247	e6 2e		inc $2e				inc 	zsTemp 						; pre-increment
.2249	d0 02		bne $224d			bne 	_CTIWASkip
.224b	e6 2f		inc $2f				inc 	zsTemp+1
.224d					_CTIWASkip:
.224d	b2 2e		lda ($2e)			lda 	(zsTemp) 					; read and validate it
.224f	38		sec				sec
.2250	e9 30		sbc #$30			sbc 	#"0"
.2252	90 16		bcc $226a			bcc 	_CTIWError
.2254	c9 0a		cmp #$0a			cmp 	#9+1
.2256	b0 12		bcs $226a			bcs 	_CTIWError
.2258	e8		inx				inx 								; store at +1
.2259	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.225c	ca		dex				dex
.225d	20 81 2b	jsr $2b81			jsr 	FloatAddTopTwoStack
.2260	60		rts				rts
.2261					_CTIWMultiply:
.2261	e8		inx				inx
.2262	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.2265	ca		dex				dex
.2266	20 02 2b	jsr $2b02			jsr 	FloatMultiplyShort
.2269	60		rts				rts
.226a					_CTIWError:
.226a	4c 72 14	jmp $1472		jmp	ErrorV_value
.226d					UnaryUsr:
.226d	fa		plx				plx
.226e	5a		phy				phy
.226f	20 76 22	jsr $2276			jsr 	_UUCallVector
.2272	7a		ply				ply
.2273	4c 24 10	jmp $1024			jmp 	NextCommand
.2276					_UUCallVector:
.2276	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.2279					ValUnary:
.2279	fa		plx				plx
.227a	b5 40		lda $40,x			lda 	NSMantissa0,x
.227c	85 28		sta $28				sta 	zTemp0
.227e	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2280	85 29		sta $29				sta 	zTemp0+1
.2282	20 8d 22	jsr $228d			jsr 	ValEvaluateZTemp0
.2285	b0 03		bcs $228a			bcs 	_VUError 					; couldn't convert
.2287	4c 24 10	jmp $1024			jmp 	NextCommand
.228a					_VUError:
.228a	4c 72 14	jmp $1472		jmp	ErrorV_value
.228d					ValEvaluateZTemp0:
.228d	5a		phy				phy
.228e	b2 28		lda ($28)			lda 	(zTemp0) 					; check not empty string
.2290	f0 22		beq $22b4			beq 	_VMCFail2
.2292	a0 00		ldy #$00			ldy 	#0 							; start position
.2294					_VMCSpaces:
.2294	c8		iny				iny 								; skip leading spaces
.2295	b1 28		lda ($28),y			lda 	(zTemp0),y
.2297	c9 20		cmp #$20			cmp 	#" "
.2299	f0 f9		beq $2294			beq 	_VMCSpaces
.229b	48		pha				pha 								; save first character
.229c	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.229e	d0 01		bne $22a1			bne 	_VMCStart
.22a0	c8		iny				iny 								; skip over - if so.
.22a1					_VMCStart:
.22a1	38		sec				sec 								; initialise first time round.
.22a2					_VMCNext:
.22a2	98		tya				tya 								; reached end of string
.22a3	3a		dec a				dec 	a
.22a4	52 28		eor ($28)			eor 	(zTemp0) 					; compare length preserve carry.
.22a6	f0 0f		beq $22b7			beq 	_VMCSuccess 				; successful.
.22a8	b1 28		lda ($28),y			lda 	(zTemp0),y 					; encode a number.
.22aa	c8		iny				iny
.22ab	20 d9 2b	jsr $2bd9			jsr 	FloatEncode 				; send it to the number-builder
.22ae	90 03		bcc $22b3			bcc 	_VMCFail 					; if failed, give up.
.22b0	18		clc				clc 								; next time round, countinue
.22b1	80 ef		bra $22a2			bra 	_VMCNext
.22b3					_VMCFail:
.22b3	68		pla				pla
.22b4					_VMCFail2:
.22b4	7a		ply				ply
.22b5	38		sec				sec
.22b6	60		rts				rts
.22b7					_VMCSuccess:
.22b7	a9 00		lda #$00			lda 	#0 							; construct final
.22b9	20 d9 2b	jsr $2bd9			jsr 	FloatEncode 				; by sending a duff value.
.22bc	68		pla				pla 								; if it was -ve
.22bd	c9 2d		cmp #$2d			cmp 	#"-"
.22bf	d0 03		bne $22c4			bne 	_VMCNotNegative
.22c1	20 b7 2d	jsr $2db7			jsr		FloatNegate 				; negate it.
.22c4					_VMCNotNegative:
.22c4	7a		ply				ply
.22c5	18		clc				clc
.22c6	60		rts				rts
.22c7					VectorTable:
>22c7	c9 19					.word	LinkFloatAdd             ; $80 +
>22c9	d2 19					.word	LinkFloatSubtract        ; $81 -
>22cb	db 19					.word	LinkFloatMultiply        ; $82 *
>22cd	e4 19					.word	LinkFloatDivide          ; $83 /
>22cf	ef 19					.word	LinkFloatPower           ; $84 ^
>22d1	b5 10					.word	BinaryAnd                ; $85 and
>22d3	b9 10					.word	BinaryOr                 ; $86 or
>22d5	fa 19					.word	LinkCompareGreater       ; $87 >
>22d7	03 1a					.word	LinkCompareEqual         ; $88 =
>22d9	0c 1a					.word	LinkCompareLess          ; $89 <
>22db	15 1a					.word	LinkCompareGreaterEqual  ; $8a >=
>22dd	1e 1a					.word	LinkCompareNotEqual      ; $8b <>
>22df	27 1a					.word	LinkCompareLessEqual     ; $8c <=
>22e1	9e 10					.word	AbsoluteTOS              ; $8d abs
>22e3	f0 10					.word	ArrayConvert             ; $8e array
>22e5	95 11					.word	UnaryAsc                 ; $8f asc
>22e7	b0 11					.word	CommandAssert            ; $90 assert
>22e9	f1 11					.word	Unary16Bin               ; $91 bin$
>22eb	1b 12					.word	PrintCharacter           ; $92 print.chr
>22ed	25 12					.word	UnaryChr                 ; $93 chr$
>22ef	79 12					.word	CompareStrings           ; $94 s.cmp
>22f1	94 15					.word	CommandFor               ; $95 for
>22f3	9a 16					.word	UnaryFre                 ; $96 fre
>22f5	b2 16					.word	CommandGet               ; $97 get
>22f7	d8 16					.word	CommandReturn            ; $98 return
>22f9	1f 17					.word	Command_PSET             ; $99 pset
>22fb	39 17					.word	Command_LINE             ; $9a line
>22fd	4e 17					.word	Command_RECT             ; $9b rect
>22ff	5d 17					.word	Command_FRAME            ; $9c frame
>2301	6c 17					.word	Command_CHAR             ; $9d char
>2303	03 18					.word	Unary16Hex               ; $9e hex$
>2305	a4 18					.word	CommandInput             ; $9f input
>2307	bb 18					.word	CommandInputString       ; $a0 input$
>2309	d4 18					.word	CommandInputReset        ; $a1 input.start
>230b	b8 19					.word	UnaryLen                 ; $a2 len
>230d	84 1a					.word	LinkFloatCompare         ; $a3 f.cmp
>230f	8d 1a					.word	LinkDivideInt32          ; $a4 int.div
>2311	11 1b					.word	NegateTOS                ; $a5 negate
>2313	18 1b					.word	CommandNewLine           ; $a6 new.line
>2315	21 1b					.word	CommandNext              ; $a7 next
>2317	08 1c					.word	NotTOS                   ; $a8 not
>2319	1f 1c					.word	CommandOn                ; $a9 on
>231b	3d 1c					.word	CommandMoreOn            ; $aa moreon
>231d	50 1c					.word	UnaryPeek                ; $ab peek
>231f	65 1c					.word	CommandPOKE              ; $ac poke
>2321	7d 1c					.word	UnaryPos                 ; $ad pos
>2323	87 1c					.word	GetChannel               ; $ae getchannel
>2325	92 1c					.word	SetChannel               ; $af setchannel
>2327	b5 1c					.word	PrintNumber              ; $b0 print.n
>2329	d4 1c					.word	PrintString              ; $b1 print.s
>232b	3b 1d					.word	CommandRead              ; $b2 read
>232d	55 1d					.word	CommandReadString        ; $b3 read$
>232f	e0 1e					.word	UnaryRND                 ; $b4 rnd
>2331	4f 1f					.word	StringConcatenate        ; $b5 concat
>2333	a6 1f					.word	SignTOS                  ; $b6 sgn
>2335	c9 1f					.word	PrintTab                 ; $b7 print.tab
>2337	d7 1f					.word	PrintPos                 ; $b8 print.pos
>2339	e8 1f					.word	PrintSpace               ; $b9 print.spc
>233b	01 20					.word	Unary_Str                ; $ba str$
>233d	7c 20					.word	Unary_Left               ; $bb left$
>233f	8c 20					.word	Unary_Right              ; $bc right$
>2341	a8 20					.word	Unary_Mid                ; $bd mid$
>2343	1a 21					.word	CommandSwap              ; $be swap
>2345	90 21					.word	TimeTOS                  ; $bf ti
>2347	97 21					.word	TimeString               ; $c0 ti$
>2349	6d 22					.word	UnaryUsr                 ; $c1 usr
>234b	79 22					.word	ValUnary                 ; $c2 val
>234d	d4 24					.word	CommandClose             ; $c3 close
>234f	e6 24					.word	CommandExit              ; $c4 exit
>2351	ec 24					.word	CommandDebug             ; $c5 debug
>2353	52 25					.word	CommandOpen              ; $c6 open
>2355	e6 25					.word	CommandScreen            ; $c7 screen
>2357	cd 27					.word	CommandVPOKE             ; $c8 vpoke
>2359	f2 27					.word	CommandVPEEK             ; $c9 vpeek
>235b	c1 1f					.word	CommandShift             ; $ca .shift
>235d	62 10					.word	PushByteCommand          ; $cb .byte
>235f	75 10					.word	PushWordCommand          ; $cc .word
>2361	f7 1c					.word	CommandPushN             ; $cd .float
>2363	1d 1d					.word	CommandPushS             ; $ce .string
>2365	01 13					.word	CommandData              ; $cf .data
>2367	ea 16					.word	CommandGoto              ; $d0 .goto
>2369	cc 16					.word	CommandGosub             ; $d1 .gosub
>236b	01 17					.word	CommandGotoZ             ; $d2 .goto.z
>236d	10 17					.word	CommandGotoNZ            ; $d3 .goto.nz
>236f	a4 10					.word	CommandVarSpace          ; $d4 .varspace
.2371					ShiftVectorTable:
>2371	3d 12					.word	CommandClr               ; $ca80 clr
>2373	0a 13					.word	CommandDIM               ; $ca81 dim
>2375	fa 13					.word	CommandEnd               ; $ca82 end
>2377	89 19					.word	UnaryJoy                 ; $ca83 joy
>2379	30 1a					.word	LinkFloatIntegerPartDown ; $ca84 int
>237b	39 1a					.word	LinkFloatSquareRoot      ; $ca85 sqr
>237d	4a 1a					.word	LinkFloatLogarithm       ; $ca86 log
>237f	55 1a					.word	LinkFloatExponent        ; $ca87 exp
>2381	5e 1a					.word	LinkFloatCosine          ; $ca88 cos
>2383	67 1a					.word	LinkFloatSine            ; $ca89 sin
>2385	70 1a					.word	LinkFloatTangent         ; $ca8a tan
>2387	79 1a					.word	LinkFloatArcTan          ; $ca8b atn
>2389	c1 1a					.word	XCommandMouse            ; $ca8c mouse
>238b	d6 1a					.word	XUnaryMB                 ; $ca8d mb
>238d	e3 1a					.word	XUnaryMX                 ; $ca8e mx
>238f	f4 1a					.word	XUnaryMY                 ; $ca8f my
>2391	cb 1e					.word	CommandRestore           ; $ca90 restore
>2393	fd 1f					.word	CommandStop              ; $ca91 stop
>2395	5a 21					.word	CommandSYS               ; $ca92 sys
>2397	02 22					.word	CommandTIWrite           ; $ca93 ti$.write
>2399	cf 23					.word	CommandWAIT              ; $ca94 wait
>239b	17 25					.word	X16I2CPoke               ; $ca95 i2cpoke
>239d	37 25					.word	X16I2CPeek               ; $ca96 i2cpeek
>239f	a2 25					.word	CommandBank              ; $ca97 bank
>23a1	f5 25					.word	XCommandSleep            ; $ca98 sleep
>23a3	19 26					.word	X16_Audio_FMINIT         ; $ca99 fminit
>23a5	27 26					.word	X16_Audio_FMNOTE         ; $ca9a fmnote
>23a7	39 26					.word	X16_Audio_FMDRUM         ; $ca9b fmdrum
>23a9	4b 26					.word	X16_Audio_FMINST         ; $ca9c fminst
>23ab	5d 26					.word	X16_Audio_FMVIB          ; $ca9d fmvib
>23ad	6f 26					.word	X16_Audio_FMFREQ         ; $ca9e fmfreq
>23af	80 26					.word	X16_Audio_FMVOL          ; $ca9f fmvol
>23b1	92 26					.word	X16_Audio_FMPAN          ; $caa0 fmpan
>23b3	a4 26					.word	X16_Audio_FMPLAY         ; $caa1 fmplay
>23b5	b5 26					.word	X16_Audio_FMCHORD        ; $caa2 fmchord
>23b7	c6 26					.word	X16_Audio_FMPOKE         ; $caa3 fmpoke
>23b9	d8 26					.word	X16_Audio_PSGINIT        ; $caa4 psginit
>23bb	e6 26					.word	X16_Audio_PSGNOTE        ; $caa5 psgnote
>23bd	f8 26					.word	X16_Audio_PSGVOL         ; $caa6 psgvol
>23bf	0a 27					.word	X16_Audio_PSGWAV         ; $caa7 psgwav
>23c1	1c 27					.word	X16_Audio_PSGFREQ        ; $caa8 psgfreq
>23c3	2d 27					.word	X16_Audio_PSGPAN         ; $caa9 psgpan
>23c5	3f 27					.word	X16_Audio_PSGPLAY        ; $caaa psgplay
>23c7	50 27					.word	X16_Audio_PSGCHORD       ; $caab psgchord
>23c9	61 27					.word	CommandCls               ; $caac cls
>23cb	6a 27					.word	CommandLocate            ; $caad locate
>23cd	94 27					.word	CommandColor             ; $caae color
.23cf					CommandWAIT:
.23cf	fa		plx				plx
.23d0	b5 3e		lda $3e,x			lda 	NSMantissa0-2,x 			; get wait address
.23d2	85 28		sta $28				sta 	zTemp0
.23d4	b5 4a		lda $4a,x			lda 	NSMantissa1-2,x
.23d6	85 29		sta $29				sta 	zTemp0+1
.23d8					_WaitLoop:
.23d8	b2 28		lda ($28)			lda 	(zTemp0) 					; read it
.23da	35 3f		and $3f,x			and 	NSMantissa0-1,x		 		; and with mask
.23dc	55 40		eor $40,x			eor 	NSMantissa0-0,x 			; toggle
.23de	f0 f8		beq $23d8			beq 	_WaitLoop 					; keep going if zero
.23e0	ca		dex				dex 								; drop 3.
.23e1	ca		dex				dex
.23e2	ca		dex				dex
.23e3	4c 24 10	jmp $1024			jmp 	NextCommand
.23e6					WriteFloatCommand:
.23e6	fa		plx				plx
.23e7	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.23e9	85 28		sta $28				sta 	zTemp0 						; save in MSB
.23eb	88		dey				dey 								; get the upper 3 bits
.23ec	b1 22		lda ($22),y			lda 	(codePtr),y
.23ee	29 07		and #$07			and 	#7
.23f0	c8		iny				iny
.23f1	c8		iny				iny
.23f2	06 28		asl $28				asl 	zTemp0 						; shift zTemp0:A left
.23f4	2a		rol a				rol 	a 							; carry will be clear.
.23f5	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.23f7	85 29		sta $29				sta 	zTemp0+1
.23f9	20 ff 23	jsr $23ff			jsr 	WriteFloatZTemp0Sub
.23fc	4c 24 10	jmp $1024			jmp 	NextCommand
.23ff					WriteFloatZTemp0Sub:
.23ff	5a		phy				phy 								; ldart write
.2400	a0 01		ldy #$01			ldy 	#1
.2402	b5 40		lda $40,x			lda 	NSMantissa0,x
.2404	92 28		sta ($28)			sta 	(zTemp0)
.2406	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2408	91 28		sta ($28),y			sta 	(zTemp0),y
.240a	c8		iny				iny
.240b	b5 58		lda $58,x			lda 	NSMantissa2,x
.240d	91 28		sta ($28),y			sta 	(zTemp0),y
.240f	c8		iny				iny
.2410	b5 64		lda $64,x			lda 	NSMantissa3,x
.2412	91 28		sta ($28),y			sta 	(zTemp0),y
.2414	c8		iny				iny
.2415	b5 70		lda $70,x			lda 	NSExponent,x
.2417	91 28		sta ($28),y			sta 	(zTemp0),y
.2419	c8		iny				iny
.241a	b5 34		lda $34,x			lda 	NSStatus,x
.241c	91 28		sta ($28),y			sta 	(zTemp0),y
.241e	ca		dex				dex
.241f	7a		ply				ply
.2420	60		rts				rts
.2421					WriteIntegerCommand:
.2421	fa		plx				plx
.2422	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.2424	85 28		sta $28				sta 	zTemp0 						; save in MSB
.2426	88		dey				dey 								; get the upper 3 bits
.2427	b1 22		lda ($22),y			lda 	(codePtr),y
.2429	29 07		and #$07			and 	#7
.242b	c8		iny				iny
.242c	c8		iny				iny
.242d	06 28		asl $28				asl 	zTemp0 						; shift zTemp0:A left
.242f	2a		rol a				rol 	a 							; carry will be clear.
.2430	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.2432	85 29		sta $29				sta 	zTemp0+1
.2434	20 3a 24	jsr $243a			jsr 	WriteIntegerZTemp0Sub
.2437	4c 24 10	jmp $1024			jmp 	NextCommand
.243a					WriteIntegerZTemp0Sub:
.243a	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.243d	5a		phy				phy 								; start write
.243e	a0 01		ldy #$01			ldy 	#1
.2440	b5 34		lda $34,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.2442	30 0b		bmi $244f			bmi 	_WIZNegative
.2444	b5 40		lda $40,x			lda 	NSMantissa0,x 				; +ve write
.2446	92 28		sta ($28)			sta 	(zTemp0)
.2448	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.244a	91 28		sta ($28),y			sta 	(zTemp0),y
.244c	7a		ply				ply
.244d	ca		dex				dex
.244e	60		rts				rts
.244f					_WIZNegative:
.244f	38		sec				sec 								; -ve read
.2450	a9 00		lda #$00			lda 	#0
.2452	f5 40		sbc $40,x			sbc 	NSMantissa0,x
.2454	92 28		sta ($28)			sta 	(zTemp0)
.2456	a9 00		lda #$00			lda 	#0
.2458	f5 4c		sbc $4c,x			sbc 	NSMantissa1,x
.245a	91 28		sta ($28),y			sta 	(zTemp0),y
.245c	7a		ply				ply
.245d	ca		dex				dex
.245e	60		rts				rts
.245f					WriteStringCommand:
.245f	fa		plx				plx
.2460	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.2462	85 28		sta $28				sta 	zTemp0 						; save in MSB
.2464	88		dey				dey 								; get the upper 3 bits
.2465	b1 22		lda ($22),y			lda 	(codePtr),y
.2467	29 07		and #$07			and 	#7
.2469	c8		iny				iny
.246a	c8		iny				iny
.246b	06 28		asl $28				asl 	zTemp0 						; shift zTemp0:A left
.246d	2a		rol a				rol 	a 							; carry will be clear.
.246e	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.2470	85 29		sta $29				sta 	zTemp0+1
.2472	20 78 24	jsr $2478			jsr 	WriteStringZTemp0Sub
.2475	4c 24 10	jmp $1024			jmp 	NextCommand
.2478					WriteStringZTemp0Sub:
.2478	5a		phy				phy
.2479	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.247b	b2 28		lda ($28)			lda 	(zTemp0)
.247d	11 28		ora ($28),y			ora 	(zTemp0),y
.247f	f0 1e		beq $249f			beq 	_WSConcrete
.2481	b2 28		lda ($28)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.2483	85 2a		sta $2a				sta 	zTemp1
.2485	b1 28		lda ($28),y			lda 	(zTemp0),y
.2487	85 2b		sta $2b				sta 	zTemp1+1
.2489	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.248b	85 2c		sta $2c				sta 	zTemp2
.248d	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.248f	85 2d		sta $2d				sta 	zTemp2+1
.2491	b2 2a		lda ($2a)			lda 	(zTemp1) 					; space available
.2493	d2 2c		cmp ($2c)			cmp 	(zTemp2) 					; if >= required length then copy
.2495	b0 17		bcs $24ae			bcs 	_WSCopy
.2497	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.2499	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.249b	09 80		ora #$80			ora 	#$80
.249d	91 2a		sta ($2a),y			sta 	(zTemp1),y
.249f					_WSConcrete:
.249f	b5 4c		lda $4c,x			lda 	NSMantissa1,x 				; string in YA
.24a1	a8		tay				tay
.24a2	b5 40		lda $40,x			lda 	NSMantissa0,x
.24a4	20 bb 12	jsr $12bb			jsr 	StringConcrete
.24a7	92 28		sta ($28)			sta 	(zTemp0) 					; save returned address
.24a9	98		tya				tya
.24aa	a0 01		ldy #$01			ldy 	#1
.24ac	91 28		sta ($28),y			sta 	(zTemp0),y
.24ae					_WSCopy
.24ae	18		clc				clc  								; copy target+2 to zTemp2
.24af	b2 28		lda ($28)			lda 	(zTemp0)
.24b1	69 02		adc #$02			adc 	#2
.24b3	85 2c		sta $2c				sta 	zTemp2
.24b5	a0 01		ldy #$01			ldy 	#1
.24b7	b1 28		lda ($28),y			lda 	(zTemp0),y
.24b9	69 00		adc #$00			adc 	#0
.24bb	85 2d		sta $2d				sta 	zTemp2+1
.24bd	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.24bf	85 2a		sta $2a				sta 	zTemp1
.24c1	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.24c3	85 2b		sta $2b				sta 	zTemp1+1
.24c5	b2 2a		lda ($2a)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.24c7	a8		tay				tay
.24c8					_WSCopyLoop:
.24c8	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.24ca	91 2c		sta ($2c),y			sta 	(zTemp2),y
.24cc	88		dey				dey
.24cd	c0 ff		cpy #$ff			cpy 	#$FF
.24cf	d0 f7		bne $24c8			bne 	_WSCopyLoop
.24d1	ca		dex				dex
.24d2	7a		ply				ply
.24d3	60		rts				rts
.24d4					CommandClose:
.24d4	fa		plx				plx
.24d5	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; channel to close
.24d8	cd 59 04	cmp $0459			cmp 	currentChannel 				; is it the current channel
.24db	d0 03		bne $24e0			bne 	_CCNotCurrent
.24dd	9c 59 04	stz $0459			stz 	currentChannel 				; effectively disables CMD
.24e0					_CCNotCurrent:
.24e0	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.24e3	4c 24 10	jmp $1024			jmp 	NextCommand
.24e6					CommandExit:
.24e6	fa		plx				plx
.24e7	86 28		stx $28				stx 	zTemp0 						; stack position.
.24e9	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.24ec					CommandDebug:
.24ec	fa		plx				plx
>24ed	db						.byte 	$DB 						; causes a break in the emulator
.24ee	4c 24 10	jmp $1024			jmp 	NextCommand
.24f1					XGetCharacterFromChannel:
.24f1	da		phx				phx
.24f2	5a		phy				phy
.24f3	e0 00		cpx #$00			cpx 	#0 							; is it default
.24f5	d0 05		bne $24fc			bne 	_XGetChannel
.24f7	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.24fa	80 08		bra $2504			bra 	_XGetChar
.24fc					_XGetChannel:
.24fc	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.24ff	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.2502	d0 06		bne $250a			bne 	_XGCError
.2504					_XGetChar:
.2504	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.2507	7a		ply				ply
.2508	fa		plx				plx
.2509	60		rts				rts
.250a					_XGCError:
.250a	4c 7e 15	jmp $157e		jmp	ErrorV_channel
.250d					XGetHPos:
.250d	da		phx				phx
.250e	5a		phy				phy
.250f	38		sec				sec
.2510	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.2513	98		tya				tya
.2514	7a		ply				ply
.2515	fa		plx				plx
.2516	60		rts				rts
.2517					X16I2CPoke:
.2517	fa		plx				plx
.2518	5a		phy				phy
.2519	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; value
.251c	48		pha				pha
.251d	ca		dex				dex
.251e	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; register
.2521	48		pha				pha
.2522	ca		dex				dex
.2523	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; device
.2526	aa		tax				tax
.2527	7a		ply				ply
.2528	68		pla				pla
.2529	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.252c	b0 06		bcs $2534			bcs 	X16I2CError
.252e	7a		ply				ply
.252f	a2 ff		ldx #$ff			ldx 	#$FF
.2531	4c 24 10	jmp $1024			jmp 	NextCommand
.2534					X16I2CError:
.2534	4c 7e 15	jmp $157e		jmp	ErrorV_channel
.2537					X16I2CPeek:
.2537	fa		plx				plx
.2538	da		phx				phx
.2539	5a		phy				phy
.253a	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; register
.253d	48		pha				pha
.253e	ca		dex				dex
.253f	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; device
.2542	aa		tax				tax 								; X device
.2543	7a		ply				ply 								; Y register
.2544	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.2547	b0 eb		bcs $2534			bcs 	X16I2CError
.2549	7a		ply				ply 								; restore Y/X
.254a	fa		plx				plx
.254b	ca		dex				dex 								; drop TOS (register)
.254c	20 f7 2d	jsr $2df7			jsr 	FloatSetByte 				; write read value to TOS.
.254f	4c 24 10	jmp $1024			jmp 	NextCommand
.2552					CommandOpen:
.2552	fa		plx				plx
.2553	a5 43		lda $43				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.2555	85 28		sta $28				sta 	zTemp0
.2557	aa		tax				tax
.2558	a5 4f		lda $4f				lda 	NSMantissa1+3
.255a	85 29		sta $29				sta 	zTemp0+1
.255c	a8		tay				tay
.255d	e8		inx				inx 								; XY points to first character
.255e	d0 01		bne $2561			bne 	_CONoCarry
.2560	c8		iny				iny
.2561					_CONoCarry:
.2561	b2 28		lda ($28)			lda 	(zTemp0) 					; get length of filename
.2563	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.2566	a5 40		lda $40				lda 	NSMantissa0+0
.2568	a6 41		ldx $41				ldx 	NSMantissa0+1
.256a	a4 42		ldy $42				ldy 	NSMantissa0+2
.256c	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.256f	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.2572	b0 03		bcs $2577			bcs 	_COError
.2574	4c 24 10	jmp $1024			jmp 	NextCommand
.2577					_COError:
.2577	4c 7e 15	jmp $157e		jmp	ErrorV_channel
.257a					XPokeMemory:
.257a	86 28		stx $28				stx 	zTemp0
.257c	84 29		sty $29				sty 	zTemp0+1
.257e	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.2580	ae 67 05	ldx $0567			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.2583	e0 ff		cpx #$ff			cpx 	#$FF
.2585	f0 02		beq $2589			beq 	_XPMNoSwitch
.2587	86 00		stx $00				stx 	SelectRAMBank
.2589					_XPMNoSwitch:
.2589	92 28		sta ($28)			sta 	(zTemp0) 					; do the POKE
.258b	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.258d					_XPMExit:
.258d	60		rts				rts
.258e					XPeekMemory:
.258e	86 28		stx $28				stx 	zTemp0
.2590	84 29		sty $29				sty 	zTemp0+1
.2592	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.2594	ae 67 05	ldx $0567			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.2597	e0 ff		cpx #$ff			cpx 	#$FF
.2599	f0 02		beq $259d			beq 	_XPMNoSwitch
.259b	86 00		stx $00				stx 	SelectRAMBank
.259d					_XPMNoSwitch:
.259d	b2 28		lda ($28)			lda 	(zTemp0) 					; do the PEEK
.259f	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.25a1	60		rts				rts
.25a2					CommandBank:
.25a2	fa		plx				plx
.25a3	a5 40		lda $40				lda 	NSMantissa0 				; RAM bank
.25a5	8d 67 05	sta $0567			sta 	ramBank 					; store & make current
.25a8	85 00		sta $00				sta 	SelectRAMBank
.25aa	a5 41		lda $41				lda 	NSMantissa0+1 		 		; ROM specified
.25ac	c9 ff		cmp #$ff			cmp 	#$FF
.25ae	f0 03		beq $25b3			beq 	_CBNoUpdate
.25b0	8d 68 05	sta $0568			sta 	romBank 					; this doesn't set the hardware page.
.25b3					_CBNoUpdate:
.25b3	a2 ff		ldx #$ff			ldx 	#$FF
.25b5	4c 24 10	jmp $1024			jmp 	NextCommand
.0567					ramBank:
>0567							.fill 	1
.0568					romBank:
>0568							.fill 	1
.25b8					XPrintCharacterToChannel:
.25b8	48		pha				pha
.25b9	da		phx				phx
.25ba	5a		phy				phy
.25bb	48		pha				pha  								; save char
.25bc	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.25be	d0 05		bne $25c5			bne 	_XPCNotDefault
.25c0	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.25c3	80 08		bra $25cd			bra 	_XPCSend
.25c5					_XPCNotDefault:
.25c5	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.25c8	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.25cb	d0 08		bne $25d5			bne 	_XPCError
.25cd					_XPCSend:
.25cd	68		pla				pla 								; restore character
.25ce	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.25d1	7a		ply				ply
.25d2	fa		plx				plx
.25d3	68		pla				pla
.25d4	60		rts				rts
.25d5					_XPCError:
.25d5	4c 7e 15	jmp $157e		jmp	ErrorV_channel
.25d8					XReadClock:
.25d8	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.25db	60		rts				rts
.25dc					XWriteClock:
.25dc	48		pha				pha
.25dd	da		phx				phx
.25de	5a		phy				phy
.25df	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.25e2	7a		ply				ply
.25e3	fa		plx				plx
.25e4	68		pla				pla
.25e5	60		rts				rts
.25e6					CommandScreen:
.25e6	fa		plx				plx
.25e7	da		phx				phx
.25e8	5a		phy				phy
.25e9	20 61 19	jsr $1961			jsr 	GetInteger8Bit
.25ec	18		clc				clc
.25ed	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.25f0	7a		ply				ply
.25f1	fa		plx				plx
.25f2	4c 24 10	jmp $1024			jmp 	NextCommand
.25f5					XCommandSleep:
.25f5	fa		plx				plx
.25f6	5a		phy				phy
.25f7	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.25fa	ca		dex				dex
.25fb	20 d8 25	jsr $25d8			jsr 	XReadClock 					; read clock to YXA
.25fe	18		clc				clc 								; calculate end time in zTemp0
.25ff	65 40		adc $40				adc 	NSMantissa0
.2601	85 28		sta $28				sta 	zTemp0
.2603	8a		txa				txa
.2604	65 4c		adc $4c				adc 	NSMantissa1
.2606	85 29		sta $29				sta 	zTemp0+1
.2608					_XCWait:
.2608	20 d8 25	jsr $25d8			jsr 	XReadClock 					; and wait for it.
.260b	c5 28		cmp $28				cmp 	zTemp0
.260d	d0 f9		bne $2608			bne 	_XCWait
.260f	e4 29		cpx $29				cpx 	zTemp0+1
.2611	d0 f5		bne $2608			bne 	_XCWait
.2613	a2 ff		ldx #$ff			ldx 	#$FF
.2615	7a		ply				ply
.2616	4c 24 10	jmp $1024			jmp 	NextCommand
.2619					X16_Audio_FMINIT:
.2619	fa		plx				plx
.261a	5a		phy			phy
.261b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>261e	63 c0					.word	X16A_ym_init
>2620	0a					.byte	X16_AudioCodeBank
.2621	a2 ff		ldx #$ff		ldx	#$FF
.2623	7a		ply			ply
.2624	4c 24 10	jmp $1024			jmp 	NextCommand
.2627					X16_Audio_FMNOTE:
.2627	fa		plx				plx
.2628	5a		phy			phy
.2629	20 c7 11	jsr $11c7		jsr		X16_Audio_Parameters8_8
.262c	18		clc			clc
.262d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2630	03 c0					.word	X16A_bas_fmnote
>2632	0a					.byte	X16_AudioCodeBank
.2633	a2 ff		ldx #$ff		ldx	#$FF
.2635	7a		ply			ply
.2636	4c 24 10	jmp $1024			jmp 	NextCommand
.2639					X16_Audio_FMDRUM:
.2639	fa		plx				plx
.263a	5a		phy			phy
.263b	20 c7 11	jsr $11c7		jsr		X16_Audio_Parameters8_8
.263e	18		clc			clc
.263f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2642	6f c0					.word	X16A_ym_playdrum
>2644	0a					.byte	X16_AudioCodeBank
.2645	a2 ff		ldx #$ff		ldx	#$FF
.2647	7a		ply			ply
.2648	4c 24 10	jmp $1024			jmp 	NextCommand
.264b					X16_Audio_FMINST:
.264b	fa		plx				plx
.264c	5a		phy			phy
.264d	20 c7 11	jsr $11c7		jsr		X16_Audio_Parameters8_8
.2650	38		sec			sec
.2651	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2654	69 c0					.word	X16A_ym_loadpatch
>2656	0a					.byte	X16_AudioCodeBank
.2657	a2 ff		ldx #$ff		ldx	#$FF
.2659	7a		ply			ply
.265a	4c 24 10	jmp $1024			jmp 	NextCommand
.265d					X16_Audio_FMVIB:
.265d	fa		plx				plx
.265e	5a		phy			phy
.265f	20 c7 11	jsr $11c7		jsr		X16_Audio_Parameters8_8
.2662	18		clc			clc
.2663	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2666	09 c0					.word	X16A_bas_fmvib
>2668	0a					.byte	X16_AudioCodeBank
.2669	a2 ff		ldx #$ff		ldx	#$FF
.266b	7a		ply			ply
.266c	4c 24 10	jmp $1024			jmp 	NextCommand
.266f					X16_Audio_FMFREQ:
.266f	fa		plx				plx
.2670	5a		phy			phy
.2671	20 c1 11	jsr $11c1		jsr		X16_Audio_Parameters8_16
.2674	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2677	00 c0					.word	X16A_bas_fmfreq
>2679	0a					.byte	X16_AudioCodeBank
.267a	a2 ff		ldx #$ff		ldx	#$FF
.267c	7a		ply			ply
.267d	4c 24 10	jmp $1024			jmp 	NextCommand
.2680					X16_Audio_FMVOL:
.2680	fa		plx				plx
.2681	5a		phy			phy
.2682	20 c7 11	jsr $11c7		jsr		X16_Audio_Parameters8_8
.2685	18		clc			clc
.2686	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2689	75 c0					.word	X16A_ym_setatten
>268b	0a					.byte	X16_AudioCodeBank
.268c	a2 ff		ldx #$ff		ldx	#$FF
.268e	7a		ply			ply
.268f	4c 24 10	jmp $1024			jmp 	NextCommand
.2692					X16_Audio_FMPAN:
.2692	fa		plx				plx
.2693	5a		phy			phy
.2694	20 c7 11	jsr $11c7		jsr		X16_Audio_Parameters8_8
.2697	18		clc			clc
.2698	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>269b	7e c0					.word	X16A_ym_setpan
>269d	0a					.byte	X16_AudioCodeBank
.269e	a2 ff		ldx #$ff		ldx	#$FF
.26a0	7a		ply			ply
.26a1	4c 24 10	jmp $1024			jmp 	NextCommand
.26a4					X16_Audio_FMPLAY:
.26a4	fa		plx				plx
.26a5	5a		phy			phy
.26a6	20 d8 11	jsr $11d8		jsr		X16_Audio_Parameters8_String
.26a9	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>26ac	06 c0					.word	X16A_bas_fmplaystring
>26ae	0a					.byte	X16_AudioCodeBank
.26af	a2 ff		ldx #$ff		ldx	#$FF
.26b1	7a		ply			ply
.26b2	4c 24 10	jmp $1024			jmp 	NextCommand
.26b5					X16_Audio_FMCHORD:
.26b5	fa		plx				plx
.26b6	5a		phy			phy
.26b7	20 d8 11	jsr $11d8		jsr		X16_Audio_Parameters8_String
.26ba	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>26bd	8d c0					.word	X16A_bas_fmchordstring
>26bf	0a					.byte	X16_AudioCodeBank
.26c0	a2 ff		ldx #$ff		ldx	#$FF
.26c2	7a		ply			ply
.26c3	4c 24 10	jmp $1024			jmp 	NextCommand
.26c6					X16_Audio_FMPOKE:
.26c6	fa		plx				plx
.26c7	5a		phy			phy
.26c8	20 c7 11	jsr $11c7		jsr		X16_Audio_Parameters8_8
.26cb	18		clc			clc
.26cc	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>26cf	8a c0					.word	X16A_ym_write
>26d1	0a					.byte	X16_AudioCodeBank
.26d2	a2 ff		ldx #$ff		ldx	#$FF
.26d4	7a		ply			ply
.26d5	4c 24 10	jmp $1024			jmp 	NextCommand
.26d8					X16_Audio_PSGINIT:
.26d8	fa		plx				plx
.26d9	5a		phy			phy
.26da	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>26dd	4b c0					.word	X16A_psg_init
>26df	0a					.byte	X16_AudioCodeBank
.26e0	a2 ff		ldx #$ff		ldx	#$FF
.26e2	7a		ply			ply
.26e3	4c 24 10	jmp $1024			jmp 	NextCommand
.26e6					X16_Audio_PSGNOTE:
.26e6	fa		plx				plx
.26e7	5a		phy			phy
.26e8	20 c7 11	jsr $11c7		jsr		X16_Audio_Parameters8_8
.26eb	18		clc			clc
.26ec	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>26ef	12 c0					.word	X16A_bas_psgnote
>26f1	0a					.byte	X16_AudioCodeBank
.26f2	a2 ff		ldx #$ff		ldx	#$FF
.26f4	7a		ply			ply
.26f5	4c 24 10	jmp $1024			jmp 	NextCommand
.26f8					X16_Audio_PSGVOL:
.26f8	fa		plx				plx
.26f9	5a		phy			phy
.26fa	20 c7 11	jsr $11c7		jsr		X16_Audio_Parameters8_8
.26fd	18		clc			clc
.26fe	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2701	54 c0					.word	X16A_psg_setatten
>2703	0a					.byte	X16_AudioCodeBank
.2704	a2 ff		ldx #$ff		ldx	#$FF
.2706	7a		ply			ply
.2707	4c 24 10	jmp $1024			jmp 	NextCommand
.270a					X16_Audio_PSGWAV:
.270a	fa		plx				plx
.270b	5a		phy			phy
.270c	20 c7 11	jsr $11c7		jsr		X16_Audio_Parameters8_8
.270f	18		clc			clc
.2710	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2713	15 c0					.word	X16A_bas_psgwav
>2715	0a					.byte	X16_AudioCodeBank
.2716	a2 ff		ldx #$ff		ldx	#$FF
.2718	7a		ply			ply
.2719	4c 24 10	jmp $1024			jmp 	NextCommand
.271c					X16_Audio_PSGFREQ:
.271c	fa		plx				plx
.271d	5a		phy			phy
.271e	20 c1 11	jsr $11c1		jsr		X16_Audio_Parameters8_16
.2721	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2724	0f c0					.word	X16A_bas_psgfreq
>2726	0a					.byte	X16_AudioCodeBank
.2727	a2 ff		ldx #$ff		ldx	#$FF
.2729	7a		ply			ply
.272a	4c 24 10	jmp $1024			jmp 	NextCommand
.272d					X16_Audio_PSGPAN:
.272d	fa		plx				plx
.272e	5a		phy			phy
.272f	20 c7 11	jsr $11c7		jsr		X16_Audio_Parameters8_8
.2732	18		clc			clc
.2733	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2736	5a c0					.word	X16A_psg_setpan
>2738	0a					.byte	X16_AudioCodeBank
.2739	a2 ff		ldx #$ff		ldx	#$FF
.273b	7a		ply			ply
.273c	4c 24 10	jmp $1024			jmp 	NextCommand
.273f					X16_Audio_PSGPLAY:
.273f	fa		plx				plx
.2740	5a		phy			phy
.2741	20 d8 11	jsr $11d8		jsr		X16_Audio_Parameters8_String
.2744	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2747	18 c0					.word	X16A_bas_psgplaystring
>2749	0a					.byte	X16_AudioCodeBank
.274a	a2 ff		ldx #$ff		ldx	#$FF
.274c	7a		ply			ply
.274d	4c 24 10	jmp $1024			jmp 	NextCommand
.2750					X16_Audio_PSGCHORD:
.2750	fa		plx				plx
.2751	5a		phy			phy
.2752	20 d8 11	jsr $11d8		jsr		X16_Audio_Parameters8_String
.2755	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2758	90 c0					.word	X16A_bas_psgchordstring
>275a	0a					.byte	X16_AudioCodeBank
.275b	a2 ff		ldx #$ff		ldx	#$FF
.275d	7a		ply			ply
.275e	4c 24 10	jmp $1024			jmp 	NextCommand
.2761					CommandCls:
.2761	fa		plx				plx
.2762	a9 93		lda #$93			lda 	#147
.2764	20 b8 25	jsr $25b8			jsr 	XPrintCharacterToChannel
.2767	4c 24 10	jmp $1024			jmp 	NextCommand
.276a					CommandLocate:
.276a	fa		plx				plx
.276b	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.276e	ca		dex				dex
.276f	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.2772	ca		dex				dex
.2773	a9 13		lda #$13			lda 	#$13 						; home.
.2775	20 b8 25	jsr $25b8			jsr 	XPrintCharacterToChannel
.2778	a9 1d		lda #$1d			lda 	#$1D 						; do cursor rights
.277a	a6 40		ldx $40				ldx 	NSMantissa0
.277c	20 89 27	jsr $2789			jsr 	_CLOutputXA
.277f	a9 11		lda #$11			lda 	#$11 						; do cursor downs.
.2781	a6 41		ldx $41				ldx 	NSMantissa0+1
.2783	20 89 27	jsr $2789			jsr 	_CLOutputXA
.2786	4c 24 10	jmp $1024			jmp 	NextCommand
.2789					_CLOutputXA:
.2789	ca		dex				dex
.278a	f0 07		beq $2793			beq 	_CLOExit
.278c	30 05		bmi $2793			bmi 	_CLOExit
.278e	20 b8 25	jsr $25b8			jsr 	XPrintCharacterToChannel
.2791	80 f6		bra $2789			bra 	_CLOutputXA
.2793					_CLOExit:
.2793	60		rts				rts
.2794					CommandColor:
.2794	fa		plx				plx
.2795	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.2798	ca		dex				dex
.2799	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.279c	ca		dex				dex
.279d	a5 41		lda $41				lda 	NSMantissa0+1 				; bgr specified
.279f	c9 ff		cmp #$ff			cmp 	#$FF
.27a1	f0 08		beq $27ab			beq 	_CCNoBGR 					; if so, change background
.27a3	20 b3 27	jsr $27b3			jsr 	_CCSetColour
.27a6	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.27a8	20 b8 25	jsr $25b8			jsr 	XPrintCharacterToChannel
.27ab					_CCNoBGR:
.27ab	a5 40		lda $40				lda 	NSMantissa0
.27ad	20 b3 27	jsr $27b3			jsr 	_CCSetColour
.27b0	4c 24 10	jmp $1024			jmp 	NextCommand
.27b3					_CCSetColour:
.27b3	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.27b5	aa		tax				tax
.27b6	bd bd 27	lda $27bd,x			lda 	_CCCommandTable,x
.27b9	20 b8 25	jsr $25b8			jsr 	XPrintCharacterToChannel
.27bc	60		rts				rts
.27bd					_CCCommandTable:
>27bd	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>27c5	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.27cd					CommandVPOKE:
.27cd	fa		plx				plx
.27ce	20 61 19	jsr $1961			jsr 	GetInteger8Bit 				; poke value
.27d1	48		pha				pha
.27d2	ca		dex				dex
.27d3	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.27d6	b5 40		lda $40,x			lda 	NSMantissa0,x
.27d8	8d 20 9f	sta $9f20			sta 	VRAMLow0
.27db	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.27dd	8d 21 9f	sta $9f21			sta 	VRAMMed0
.27e0	ca		dex				dex
.27e1	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.27e4	20 61 19	jsr $1961			jsr 	GetInteger8Bit
.27e7	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.27ea	ca		dex				dex
.27eb	68		pla				pla 								; poke value back
.27ec	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.27ef	4c 24 10	jmp $1024			jmp 	NextCommand
.27f2					CommandVPEEK:
.27f2	fa		plx				plx
.27f3	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.27f6	b5 40		lda $40,x			lda 	NSMantissa0,x
.27f8	8d 20 9f	sta $9f20			sta 	VRAMLow0
.27fb	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.27fd	8d 21 9f	sta $9f21			sta 	VRAMMed0
.2800	ca		dex				dex
.2801	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.2804	20 61 19	jsr $1961			jsr 	GetInteger8Bit
.2807	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.280a	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.280d	20 f7 2d	jsr $2df7			jsr 	FloatSetByte 				; return as byte
.2810	4c 24 10	jmp $1024			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0034					NSStatus:
>0034							.fill 	MathStackSize
.0040					NSMantissa0:
>0040							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004c					NSMantissa1:
>004c							.fill 	MathStackSize
.0058					NSMantissa2:
>0058							.fill 	MathStackSize
.0064					NSMantissa3:
>0064							.fill 	MathStackSize
.0070					NSExponent:
>0070							.fill 	MathStackSize
.0569					numberBuffer:
>0569							.fill 	34
.2813					FloatSubtract:
.2813	b5 34		lda $34,x			lda 	NSStatus,x 					; negate top of stack
.2815	49 80		eor #$80			eor 	#$80
.2817	95 34		sta $34,x			sta 	NSStatus,x					; and fall through.
.2819					FloatAdd:
.2819	ca		dex				dex
.281a	b5 70		lda $70,x			lda 	NSExponent,x 				; can use optimised.
.281c	15 71		ora $71,x			ora 	NSExponent+1,x
.281e	15 64		ora $64,x			ora 	NSMantissa3,x
.2820	15 65		ora $65,x			ora 	NSMantissa3+1,x
.2822	d0 04		bne $2828			bne 	_FAUseFloat
.2824	20 b5 2b	jsr $2bb5			jsr 	FloatInt32Add 				; use the int32 one.
.2827	60		rts				rts
.2828					_FAUseFloat:
.2828	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise 				; normalise S[X]
.282b	f0 51		beq $287e			beq 	_FAReturn1
.282d	e8		inx				inx 								; normalise S[X+1]
.282e	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise
.2831	ca		dex				dex
.2832	c9 00		cmp #$00			cmp 	#0
.2834	f0 60		beq $2896			beq 	_FAExit 					; if so, just return A
.2836	b5 70		lda $70,x			lda 	NSExponent,x 				; are the exponents the same ?
.2838	d5 71		cmp $71,x			cmp 	NSExponent+1,x
.283a	f0 18		beq $2854			beq 	_FAExponentsEqual
.283c	b5 70		lda $70,x			lda 	NSExponent,x 				; work out the larger exponent
.283e	a8		tay				tay
.283f	38		sec				sec 								; do a signed comparison of the exponents.
.2840	f5 71		sbc $71,x			sbc 	NSExponent+1,x
.2842	50 02		bvc $2846			bvc 	_FANoSignedChange
.2844	49 80		eor #$80			eor 	#$80
.2846					_FANoSignedChange:
.2846	29 80		and #$80			and 	#$80
.2848	10 02		bpl $284c			bpl 	_FAHaveMax
.284a	b4 71		ldy $71,x			ldy 	NSExponent+1,x
.284c					_FAHaveMax:
.284c	20 97 28	jsr $2897			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.284f	e8		inx				inx
.2850	20 97 28	jsr $2897			jsr 	_FAShiftToExponent
.2853	ca		dex				dex
.2854					_FAExponentsEqual:
.2854	b5 34		lda $34,x			lda 	NSStatus,x 					; are the signs the same
.2856	55 35		eor $35,x			eor 	NSStatus+1,x
.2858	30 0e		bmi $2868			bmi 	_FADifferentSigns
.285a	20 81 2b	jsr $2b81			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.285d	b5 64		lda $64,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.285f	10 35		bpl $2896			bpl 	_FAExit 					; if no, we are done.
.2861	20 0e 2e	jsr $2e0e			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.2864	f6 70		inc $70,x			inc 	NSExponent,x 				; bump the exponent and exit
.2866	80 2e		bra $2896			bra 	_FAExit
.2868					_FADifferentSigns:
.2868	20 9b 2b	jsr $2b9b			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.286b	b5 64		lda $64,x			lda 	NSMantissa3,x 				; is the result negative ?
.286d	10 06		bpl $2875			bpl 	_FACheckZero 				; if no, check for -0
.286f	20 b7 2d	jsr $2db7			jsr 	FloatNegate 					; netate result
.2872	20 be 2d	jsr $2dbe			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.2875					_FACheckZero:
.2875	20 17 2e	jsr $2e17			jsr 	FloatIsZero	 				; check for -0
.2878	d0 1c		bne $2896			bne 	_FAExit
.287a	74 34		stz $34,x			stz 	NSStatus,x
.287c	80 18		bra $2896			bra 	_FAExit
.287e					_FAReturn1:
.287e	b5 41		lda $41,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.2880	95 40		sta $40,x			sta 	NSMantissa0,x
.2882	b5 4d		lda $4d,x			lda 	NSMantissa1+1,x
.2884	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2886	b5 59		lda $59,x			lda 	NSMantissa2+1,x
.2888	95 58		sta $58,x			sta 	NSMantissa2,x
.288a	b5 65		lda $65,x			lda 	NSMantissa3+1,x
.288c	95 64		sta $64,x			sta 	NSMantissa3,x
.288e	b5 71		lda $71,x			lda 	NSExponent+1,x
.2890	95 70		sta $70,x			sta 	NSExponent,x
.2892	b5 35		lda $35,x			lda 	NSStatus+1,x
.2894	95 34		sta $34,x			sta 	NSStatus,x
.2896					_FAExit:
.2896	60		rts				rts
.2897					_FAShiftToExponent:
.2897					_FAShiftToExponent2:
.2897	98		tya				tya 								; compare Y to exponent
.2898	d5 70		cmp $70,x			cmp 	NSExponent,x 				; reached the exponent required ?
.289a	f0 07		beq $28a3			beq 	_FASEExit 					; exit if so.
.289c	20 0e 2e	jsr $2e0e			jsr 	FloatShiftRight	 			; shift the mantissa right
.289f	f6 70		inc $70,x			inc 	NSExponent,x 				; increment exponent
.28a1	80 f4		bra $2897			bra 	_FAShiftToExponent2
.28a3					_FASEExit:
.28a3	60		rts				rts
.28a4					CompareEqual:
.28a4	b5 40		lda $40,x			lda 	NSMantissa0,x
.28a6	d0 09		bne $28b1			bne 	ReturnFalse
.28a8					ReturnTrue:
.28a8	a9 01		lda #$01			lda 	#1
.28aa	95 40		sta $40,x			sta 	NSMantissa0,x
.28ac	a9 80		lda #$80			lda 	#$80
.28ae	95 34		sta $34,x			sta 	NSStatus,x
.28b0	60		rts				rts
.28b1					ReturnFalse:
.28b1	74 40		stz $40,x			stz 	NSMantissa0,x
.28b3	60		rts				rts
.28b4					CompareNotEqual:
.28b4	b5 40		lda $40,x			lda 	NSMantissa0,x
.28b6	d0 f0		bne $28a8			bne 	ReturnTrue
.28b8	80 f7		bra $28b1			bra 	ReturnFalse
.28ba					CompareLess:
.28ba	b5 40		lda $40,x			lda 	NSMantissa0,x
.28bc	c9 ff		cmp #$ff			cmp 	#$FF
.28be	f0 e8		beq $28a8			beq 	ReturnTrue
.28c0	80 ef		bra $28b1			bra 	ReturnFalse
.28c2					CompareGreater:
.28c2	b5 40		lda $40,x			lda 	NSMantissa0,x
.28c4	c9 01		cmp #$01			cmp 	#$01
.28c6	f0 e0		beq $28a8			beq 	ReturnTrue
.28c8	80 e7		bra $28b1			bra 	ReturnFalse
.28ca					CompareLessEqual:
.28ca	b5 40		lda $40,x			lda 	NSMantissa0,x
.28cc	c9 01		cmp #$01			cmp 	#$01
.28ce	d0 d8		bne $28a8			bne 	ReturnTrue
.28d0	80 df		bra $28b1			bra 	ReturnFalse
.28d2					CompareGreaterEqual:
.28d2	b5 40		lda $40,x			lda 	NSMantissa0,x
.28d4	c9 ff		cmp #$ff			cmp 	#$FF
.28d6	d0 d0		bne $28a8			bne 	ReturnTrue
.28d8	80 d7		bra $28b1			bra 	ReturnFalse
.28da					FloatCompare:
.28da	b5 70		lda $70,x			lda 	NSExponent,x 				; float comparison.
.28dc	15 6f		ora $6f,x			ora 	NSExponent-1,x 				; integer if both integer.
.28de	48		pha				pha
.28df	20 13 28	jsr $2813			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.28e2	68		pla				pla
.28e3	d0 0c		bne $28f1			bne 	_FCCompareFloat
.28e5	b5 40		lda $40,x			lda 	NSMantissa0,x
.28e7	15 4c		ora $4c,x			ora 	NSMantissa1,x
.28e9	15 58		ora $58,x			ora 	NSMantissa2,x
.28eb	15 64		ora $64,x			ora 	NSMantissa3,x
.28ed	f0 14		beq $2903			beq 	_FCExit 					; if zero, return zero
.28ef	80 0a		bra $28fb			bra 	_FCSign
.28f1					_FCCompareFloat:
.28f1	b5 4c		lda $4c,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.28f3	29 f0		and #$f0			and 	#$F0
.28f5	15 58		ora $58,x			ora 	NSMantissa2,x
.28f7	15 64		ora $64,x			ora 	NSMantissa3,x
.28f9	f0 08		beq $2903			beq 	_FCExit 					; zero, so approximately identical
.28fb					_FCSign:
.28fb	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.28fd	34 34		bit $34,x			bit 	NSStatus,x
.28ff	10 02		bpl $2903			bpl 	_FCExit
.2901					_FCNegative:
.2901	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2903					_FCExit:
.2903	20 f7 2d	jsr $2df7			jsr 	FloatSetByte 				; set the result 255,0,1
.2906	60		rts				rts
.2907					FloatScalarTable:
>2907	66 66 66 66				.dword $66666666 ; 0.1
>290b	de					.byte $de
>290c	1f 85 eb 51				.dword $51eb851f ; 0.01
>2910	db					.byte $db
>2911	4c 37 89 41				.dword $4189374c ; 0.001
>2915	d8					.byte $d8
>2916	ac 8b db 68				.dword $68db8bac ; 0.0001
>291a	d4					.byte $d4
>291b	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>291f	d1					.byte $d1
>2920	83 de 1b 43				.dword $431bde83 ; 1e-06
>2924	ce					.byte $ce
>2925	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>2929	ca					.byte $ca
>292a	89 3b e6 55				.dword $55e63b89 ; 1e-08
>292e	c7					.byte $c7
>292f	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>2933	c4					.byte $c4
>2934	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>2938	c0					.byte $c0
>2939	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>293d	bd					.byte $bd
.293e					FloatDivide:
.293e	48		pha				pha
.293f	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2942	ca		dex				dex
.2943	c9 00		cmp #$00			cmp 	#0
.2945	f0 1e		beq $2965			beq 	_FDZero
.2947	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.294a	f0 16		beq $2962			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.294c	20 ad 29	jsr $29ad			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.294f	20 7a 29	jsr $297a			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.2952	20 4a 2b	jsr $2b4a			jsr		FloatNormalise 				; renormalise
.2955	20 40 2b	jsr $2b40			jsr 	FloatCalculateSign 			; calculate result sign
.2958	b5 70		lda $70,x			lda 	NSExponent,x 				; calculate exponent
.295a	38		sec				sec
.295b	f5 71		sbc $71,x			sbc 	NSExponent+1,x
.295d	38		sec				sec
.295e	e9 1e		sbc #$1e			sbc 	#30
.2960	95 70		sta $70,x			sta 	NSExponent,x
.2962					_FDExit:
.2962	68		pla				pla
.2963	18		clc				clc
.2964	60		rts				rts
.2965					_FDZero:
.2965	68		pla				pla
.2966	38		sec				sec
.2967	60		rts				rts
.2968					DivideInt32:
.2968	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart 			; make both integers
.296b	ca		dex				dex
.296c	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.296f	20 8b 29	jsr $298b			jsr 	Int32Divide 				; divide
.2972	20 7a 29	jsr $297a			jsr 	NSMCopyPlusTwoToZero 		; copy result
.2975	20 40 2b	jsr $2b40			jsr 	FloatCalculateSign 			; calculate result sign
.2978	18		clc				clc
.2979	60		rts				rts
.297a					NSMCopyPlusTwoToZero:
.297a	b5 42		lda $42,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.297c	95 40		sta $40,x			sta 	NSMantissa0,x
.297e	b5 4e		lda $4e,x			lda 	NSMantissa1+2,x
.2980	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2982	b5 5a		lda $5a,x			lda 	NSMantissa2+2,x
.2984	95 58		sta $58,x			sta 	NSMantissa2,x
.2986	b5 66		lda $66,x			lda 	NSMantissa3+2,x
.2988	95 64		sta $64,x			sta 	NSMantissa3,x
.298a	60		rts				rts
.298b					Int32Divide:
.298b	48		pha				pha 								; save AXY
.298c	5a		phy				phy
.298d	20 d8 2d	jsr $2dd8			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2990	20 f1 2d	jsr $2df1			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2993	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2995					_I32DivideLoop:
.2995	e8		inx				inx
.2996	e8		inx				inx
.2997	20 04 2e	jsr $2e04			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.299a	ca		dex				dex
.299b	ca		dex				dex
.299c	20 05 2e	jsr $2e05			jsr 	FloatRotateLeft
.299f	20 cb 29	jsr $29cb			jsr 	FloatDivideCheck 			; check if subtract possible
.29a2	90 02		bcc $29a6			bcc 	_I32DivideNoCarryIn
.29a4	f6 42		inc $42,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.29a6					_I32DivideNoCarryIn:
.29a6	88		dey				dey 								; loop round till division completed.
.29a7	d0 ec		bne $2995			bne 	_I32DivideLoop
.29a9	7a		ply				ply 								; restore AXY and exit
.29aa	68		pla				pla
.29ab	18		clc				clc
.29ac	60		rts				rts
.29ad					Int32ShiftDivide:
.29ad	48		pha				pha 								; save AY
.29ae	5a		phy				phy
.29af	e8		inx				inx 								; clear S[X+2]
.29b0	e8		inx				inx
.29b1	20 f5 2d	jsr $2df5			jsr 	FloatSetZero
.29b4	ca		dex				dex
.29b5	ca		dex				dex
.29b6	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.29b8					_I32SDLoop:
.29b8	20 cb 29	jsr $29cb			jsr 	FloatDivideCheck 			; check if subtract possible
.29bb	e8		inx				inx
.29bc	e8		inx				inx
.29bd	20 05 2e	jsr $2e05			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.29c0	ca		dex				dex
.29c1	ca		dex				dex
.29c2	20 05 2e	jsr $2e05			jsr 	FloatRotateLeft
.29c5	88		dey				dey 	 							; do 31 times
.29c6	d0 f0		bne $29b8			bne 	_I32SDLoop
.29c8	7a		ply				ply 								; restore AY and exit
.29c9	68		pla				pla
.29ca	60		rts				rts
.29cb					FloatDivideCheck:
.29cb	20 9b 2b	jsr $2b9b			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.29ce	b0 04		bcs $29d4			bcs 	_DCSExit 					; if carry set, then could do, exit
.29d0	20 81 2b	jsr $2b81			jsr 	FloatAddTopTwoStack 		; add it back in
.29d3	18		clc				clc 								; and return False
.29d4					_DCSExit:
.29d4	60		rts				rts
.29d5					FloatFractionalPart:
.29d5	5a		phy				phy
.29d6	b5 34		lda $34,x			lda 	NSStatus,x 					; take absolute value
.29d8	29 7f		and #$7f			and 	#$7F
.29da	95 34		sta $34,x			sta 	NSStatus,x
.29dc	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise
.29df	b5 70		lda $70,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.29e1	38		sec				sec
.29e2	e9 e0		sbc #$e0			sbc 	#$E0
.29e4	90 29		bcc $2a0f			bcc 	_FFPExit 					; already fractional
.29e6	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.29e8	b0 22		bcs $2a0c			bcs 	_FFPZero
.29ea	a8		tay				tay 								; put count to do in Y
.29eb	b5 64		lda $64,x			lda 	NSMantissa3,x 				; do each in turn.
.29ed	20 14 2a	jsr $2a14			jsr 	_FFPPartial
.29f0	95 64		sta $64,x			sta 	NSMantissa3,x
.29f2	b5 58		lda $58,x			lda 	NSMantissa2,x
.29f4	20 14 2a	jsr $2a14			jsr 	_FFPPartial
.29f7	95 58		sta $58,x			sta 	NSMantissa2,x
.29f9	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.29fb	20 14 2a	jsr $2a14			jsr 	_FFPPartial
.29fe	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2a00	b5 40		lda $40,x			lda 	NSMantissa0,x
.2a02	20 14 2a	jsr $2a14			jsr 	_FFPPartial
.2a05	95 40		sta $40,x			sta 	NSMantissa0,x
.2a07	20 17 2e	jsr $2e17			jsr 	FloatIsZero 					; zeroed check.
.2a0a	d0 03		bne $2a0f			bne 	_FFPExit
.2a0c					_FFPZero:
.2a0c	20 f5 2d	jsr $2df5			jsr 	FloatSetZero
.2a0f					_FFPExit:
.2a0f	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise
.2a12	7a		ply				ply
.2a13	60		rts				rts
.2a14					_FFPPartial:
.2a14	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2a16	f0 17		beq $2a2f			beq 	_FFFPPExit
.2a18	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.2a1a	b0 0c		bcs $2a28			bcs 	_FFFPPWholeByte
.2a1c	5a		phy				phy
.2a1d					_FFFPPLeft:
.2a1d	0a		asl a				asl 	a
.2a1e	88		dey				dey
.2a1f	d0 fc		bne $2a1d			bne 	_FFFPPLeft
.2a21	7a		ply				ply
.2a22					_FFFPPRight:
.2a22	4a		lsr a				lsr 	a
.2a23	88		dey				dey
.2a24	d0 fc		bne $2a22			bne 	_FFFPPRight
.2a26	80 07		bra $2a2f			bra 	_FFFPPExit
.2a28					_FFFPPWholeByte:
.2a28	98		tya				tya 								; subtract 8 from count
.2a29	38		sec				sec
.2a2a	e9 08		sbc #$08			sbc 	#8
.2a2c	a8		tay				tay
.2a2d	a9 00		lda #$00			lda 	#0 							; and clear all
.2a2f					_FFFPPExit:
.2a2f	60		rts				rts
.2a30					FloatIntegerPart:
.2a30	48		pha				pha
.2a31	b5 70		lda $70,x			lda 	NSExponent,x 				; is it integer already ?
.2a33	f0 1d		beq $2a52			beq 	_FIPExit 					; if so do nothing
.2a35	20 17 2e	jsr $2e17			jsr 	FloatIsZero 				; is it zero ?
.2a38	f0 15		beq $2a4f			beq 	_FIPZero 					; if so return zero.
.2a3a	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise 				; normalise
.2a3d	f0 10		beq $2a4f			beq 	_FIPZero 					; normalised to zero, exit zero
.2a3f					_FIPShift:
.2a3f	b5 70		lda $70,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2a41	10 07		bpl $2a4a			bpl 	_FIPCheckZero
.2a43	20 0e 2e	jsr $2e0e			jsr 	FloatShiftRight 			; shift mantissa right
.2a46	f6 70		inc $70,x			inc 	NSExponent,x 				; bump exponent
.2a48	80 f5		bra $2a3f			bra 	_FIPShift
.2a4a					_FIPCheckZero:
.2a4a	20 17 2e	jsr $2e17			jsr 	FloatIsZero 				; avoid -0 problem
.2a4d	d0 03		bne $2a52			bne 	_FIPExit 					; set to zero if mantissa zero.
.2a4f					_FIPZero:
.2a4f	20 f5 2d	jsr $2df5			jsr 	FloatSetZero
.2a52					_FIPExit:
.2a52	68		pla				pla
.2a53	60		rts				rts
.2a54					FloatIntegerPartDown:
.2a54	48		pha				pha
.2a55	5a		phy				phy
.2a56	b5 70		lda $70,x			lda 	NSExponent,x 				; is it integer already ?
.2a58	f0 36		beq $2a90			beq 	_FIPExit 					; if so do nothing
.2a5a	20 17 2e	jsr $2e17			jsr 	FloatIsZero 				; is it zero ?
.2a5d	f0 2e		beq $2a8d			beq 	_FIPZero 					; if so return zero.
.2a5f	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise 				; normalise
.2a62	f0 29		beq $2a8d			beq 	_FIPZero 					; normalised to zero, exit zero
.2a64	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.2a66					_FIPShift:
.2a66	b5 70		lda $70,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2a68	10 0a		bpl $2a74			bpl 	_FIPCheckDown
.2a6a	20 0e 2e	jsr $2e0e			jsr 	FloatShiftRight 			; shift mantissa right
.2a6d	90 01		bcc $2a70			bcc 	_FIPNoFrac 					; shifted a zero out ?
.2a6f	c8		iny				iny
.2a70					_FIPNoFrac:
.2a70	f6 70		inc $70,x			inc 	NSExponent,x 				; bump exponent
.2a72	80 f2		bra $2a66			bra 	_FIPShift
.2a74					_FIPCheckDown:
.2a74	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.2a76	f0 10		beq $2a88			beq 	_FIPCheckZero
.2a78	34 34		bit $34,x			bit 	NSStatus,x 					; +ve
.2a7a	10 0c		bpl $2a88			bpl 	_FIPCheckZero
.2a7c	e8		inx				inx 								; -ve so round *down*.
.2a7d	a9 01		lda #$01			lda 	#1
.2a7f	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.2a82	20 b7 2d	jsr $2db7			jsr 	FloatNegate
.2a85	20 19 28	jsr $2819			jsr 	FloatAdd
.2a88					_FIPCheckZero:
.2a88	20 17 2e	jsr $2e17			jsr 	FloatIsZero 				; avoid -0 problem
.2a8b	d0 03		bne $2a90			bne 	_FIPExit 					; set to zero if mantissa zero.
.2a8d					_FIPZero:
.2a8d	20 f5 2d	jsr $2df5			jsr 	FloatSetZero
.2a90					_FIPExit:
.2a90	7a		ply				ply
.2a91	68		pla				pla
.2a92	60		rts				rts
.2a93					FloatInt8Multiply:
.2a93	5a		phy				phy
.2a94	b5 40		lda $40,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2a96	a8		tay				tay
.2a97	74 40		stz $40,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2a99					_FI8MLoop:
.2a99	98		tya				tya 								; shift right shifter right into carry
.2a9a	4a		lsr a				lsr 	a
.2a9b	a8		tay				tay
.2a9c	90 0d		bcc $2aab			bcc 	_FI8MNoAdd
.2a9e	18		clc				clc
.2a9f	b5 40		lda $40,x			lda 	NSMantissa0,x
.2aa1	75 41		adc $41,x			adc 	NSMantissa0+1,x
.2aa3	95 40		sta $40,x			sta 	NSMantissa0,x
.2aa5	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2aa7	75 4d		adc $4d,x			adc 	NSMantissa1+1,x
.2aa9	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2aab					_FI8MNoAdd:
.2aab	16 41		asl $41,x			asl 	NSMantissa0+1,x 			; shift adder left
.2aad	36 4d		rol $4d,x			rol 	NSMantissa1+1,x
.2aaf	c0 00		cpy #$00			cpy 	#0
.2ab1	d0 e6		bne $2a99			bne 	_FI8MLoop 					; until right shifter zero.
.2ab3	7a		ply				ply
.2ab4	60		rts				rts
.2ab5					FloatMultiply:
.2ab5	ca		dex				dex
.2ab6	b5 70		lda $70,x			lda 	NSExponent,x 				; can use optimised ?
.2ab8	15 71		ora $71,x			ora 	NSExponent+1,x
.2aba	15 64		ora $64,x			ora 	NSMantissa3,x
.2abc	15 65		ora $65,x			ora 	NSMantissa3+1,x
.2abe	d0 21		bne $2ae1			bne 	_FMUseFloat
.2ac0	b5 34		lda $34,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2ac2	15 35		ora $35,x			ora 	NSStatus+1,x
.2ac4	29 80		and #$80			and 	#$80
.2ac6	15 64		ora $64,x			ora 	NSMantissa3,x
.2ac8	15 58		ora $58,x			ora 	NSMantissa2,x
.2aca	15 4c		ora $4c,x			ora 	NSMantissa1,x
.2acc	15 65		ora $65,x			ora 	NSMantissa3+1,x
.2ace	15 59		ora $59,x			ora 	NSMantissa2+1,x
.2ad0	15 4d		ora $4d,x			ora 	NSMantissa1+1,x
.2ad2	d0 04		bne $2ad8			bne 	_FMInt32
.2ad4	20 93 2a	jsr $2a93			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2ad7	60		rts				rts
.2ad8					_FMInt32:
.2ad8	20 02 2b	jsr $2b02			jsr 	FloatMultiplyShort			; use the int32 one.
.2adb	18		clc				clc 								; fix it up if gone out of range
.2adc	75 70		adc $70,x			adc 	NSExponent,x
.2ade	95 70		sta $70,x			sta 	NSExponent,x
.2ae0	60		rts				rts
.2ae1					_FMUseFloat:
.2ae1	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2ae4	f0 18		beq $2afe			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2ae6	e8		inx				inx
.2ae7	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2aea	ca		dex				dex
.2aeb	c9 00		cmp #$00			cmp 	#0
.2aed	f0 0c		beq $2afb			beq 	_FDSetZero
.2aef	20 02 2b	jsr $2b02			jsr 	FloatMultiplyShort 			; calculate the result.
.2af2	75 70		adc $70,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2af4	18		clc				clc
.2af5	75 71		adc $71,x			adc 	NSExponent+1,x
.2af7	95 70		sta $70,x			sta 	NSExponent,x
.2af9	80 03		bra $2afe			bra 	_FDExit
.2afb					_FDSetZero:
.2afb	20 f5 2d	jsr $2df5			jsr 	FloatSetZero 				; return 0
.2afe					_FDExit:
.2afe	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise 				; normalise the result
.2b01	60		rts				rts
.2b02					FloatMultiplyShort:
.2b02	5a		phy				phy 								; save Y
.2b03	20 d8 2d	jsr $2dd8			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2b06	20 f1 2d	jsr $2df1			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2b09	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2b0b					_I32MLoop:
.2b0b	b5 42		lda $42,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2b0d	15 4e		ora $4e,x			ora 	NSMantissa1+2,x
.2b0f	15 5a		ora $5a,x			ora 	NSMantissa2+2,x
.2b11	15 66		ora $66,x			ora 	NSMantissa3+2,x
.2b13	f0 25		beq $2b3a			beq 	_I32MExit 					; exit if zero
.2b15	b5 42		lda $42,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2b17	29 01		and #$01			and 	#1
.2b19	f0 0d		beq $2b28			beq 	_I32MNoAdd
.2b1b	20 81 2b	jsr $2b81			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.2b1e	b5 64		lda $64,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.2b20	10 06		bpl $2b28			bpl 	_I32MNoAdd
.2b22					_I32ShiftRight:
.2b22	20 0e 2e	jsr $2e0e			jsr 	FloatShiftRight 			; shift S[X] right
.2b25	c8		iny				iny 								; increment shift count
.2b26	80 09		bra $2b31			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.2b28					_I32MNoAdd:
.2b28	34 65		bit $65,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.2b2a	70 f6		bvs $2b22			bvs 	_I32ShiftRight 				; instead.
.2b2c	e8		inx				inx
.2b2d	20 04 2e	jsr $2e04			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.2b30	ca		dex				dex
.2b31					_I32MShiftUpper:
.2b31	e8		inx				inx 								; shift S[X+2] right
.2b32	e8		inx				inx
.2b33	20 0e 2e	jsr $2e0e			jsr 	FloatShiftRight
.2b36	ca		dex				dex
.2b37	ca		dex				dex
.2b38	80 d1		bra $2b0b			bra 	_I32MLoop 					; try again.
.2b3a					_I32MExit:
.2b3a	20 40 2b	jsr $2b40			jsr 	FloatCalculateSign
.2b3d	98		tya				tya 								; shift in A
.2b3e	7a		ply				ply 								; restore Y and exit
.2b3f	60		rts				rts
.2b40					FloatCalculateSign:
.2b40	b5 34		lda $34,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.2b42	16 34		asl $34,x			asl 	NSStatus,x 					; shift result left
.2b44	55 35		eor $35,x			eor 	NSStatus+1,x
.2b46	0a		asl a				asl 	a 							; shift bit 7 into carry
.2b47	76 34		ror $34,x			ror 	NSStatus,x 					; shift right into status byte.
.2b49	60		rts				rts
.2b4a					FloatNormalise:
.2b4a	20 17 2e	jsr $2e17			jsr 	FloatIsZero 				; if zero exit
.2b4d	d0 07		bne $2b56			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.2b4f	16 34		asl $34,x			asl 	NSStatus,x 					; clear the sign bit.
.2b51	76 34		ror $34,x			ror 	NSStatus,x 					; (no -0)
.2b53	a9 00		lda #$00			lda 	#0 							; set Z flag
.2b55	60		rts				rts
.2b56					_NSNormaliseOptimise:
.2b56	b5 64		lda $64,x			lda 	NSMantissa3,x 				; upper byte zero ?
.2b58	d0 19		bne $2b73			bne 	_NSNormaliseLoop
.2b5a	b5 58		lda $58,x			lda 	NSMantissa2,x 				; byte normalise
.2b5c	30 15		bmi $2b73			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.2b5e	95 64		sta $64,x			sta 	NSMantissa3,x
.2b60	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2b62	95 58		sta $58,x			sta 	NSMantissa2,x
.2b64	b5 40		lda $40,x			lda 	NSMantissa0,x
.2b66	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2b68	74 40		stz $40,x			stz 	NSMantissa0,x
.2b6a	b5 70		lda $70,x			lda 	NSExponent,x
.2b6c	38		sec				sec
.2b6d	e9 08		sbc #$08			sbc 	#8
.2b6f	95 70		sta $70,x			sta 	NSExponent,x
.2b71	80 e3		bra $2b56			bra 	_NSNormaliseOptimise
.2b73					_NSNormaliseLoop:
.2b73	34 64		bit $64,x			bit 	NSMantissa3,x 				; bit 30 set ?
.2b75	70 07		bvs $2b7e			bvs 	_NSNExit 					; exit if so with Z flag clear
.2b77	20 04 2e	jsr $2e04			jsr 	FloatShiftLeft 				; shift mantissa left
.2b7a	d6 70		dec $70,x			dec 	NSExponent,x 				; adjust exponent
.2b7c	80 f5		bra $2b73			bra 	_NSNormaliseLoop
.2b7e					_NSNExit:
.2b7e	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.2b80	60		rts				rts
.2b81					FloatAddTopTwoStack:
.2b81	18		clc				clc
.2b82	b5 40		lda $40,x			lda		NSMantissa0,x
.2b84	75 41		adc $41,x			adc 		NSMantissa0+1,x
.2b86	95 40		sta $40,x			sta 	NSMantissa0,x
.2b88	b5 4c		lda $4c,x			lda		NSMantissa1,x
.2b8a	75 4d		adc $4d,x			adc 		NSMantissa1+1,x
.2b8c	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2b8e	b5 58		lda $58,x			lda		NSMantissa2,x
.2b90	75 59		adc $59,x			adc 		NSMantissa2+1,x
.2b92	95 58		sta $58,x			sta 	NSMantissa2,x
.2b94	b5 64		lda $64,x			lda		NSMantissa3,x
.2b96	75 65		adc $65,x			adc 		NSMantissa3+1,x
.2b98	95 64		sta $64,x			sta 	NSMantissa3,x
.2b9a	60		rts				rts
.2b9b					FloatSubTopTwoStack:
.2b9b	38		sec				sec
.2b9c	b5 40		lda $40,x			lda		NSMantissa0,x
.2b9e	f5 41		sbc $41,x			sbc 		NSMantissa0+1,x
.2ba0	95 40		sta $40,x			sta 	NSMantissa0,x
.2ba2	b5 4c		lda $4c,x			lda		NSMantissa1,x
.2ba4	f5 4d		sbc $4d,x			sbc 		NSMantissa1+1,x
.2ba6	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2ba8	b5 58		lda $58,x			lda		NSMantissa2,x
.2baa	f5 59		sbc $59,x			sbc 		NSMantissa2+1,x
.2bac	95 58		sta $58,x			sta 	NSMantissa2,x
.2bae	b5 64		lda $64,x			lda		NSMantissa3,x
.2bb0	f5 65		sbc $65,x			sbc 		NSMantissa3+1,x
.2bb2	95 64		sta $64,x			sta 	NSMantissa3,x
.2bb4	60		rts				rts
.2bb5					FloatInt32Add:
.2bb5	b5 34		lda $34,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2bb7	55 35		eor $35,x			eor 	NSStatus+1,x
.2bb9	30 04		bmi $2bbf			bmi 	_DiffSigns
.2bbb	20 81 2b	jsr $2b81			jsr		FloatAddTopTwoStack
.2bbe	60		rts				rts
.2bbf					_DiffSigns:
.2bbf	20 9b 2b	jsr $2b9b			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2bc2	34 64		bit $64,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2bc4	10 07		bpl $2bcd			bpl 	_AddExit
.2bc6	b5 35		lda $35,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2bc8	95 34		sta $34,x			sta 	NSStatus,x
.2bca	20 be 2d	jsr $2dbe			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2bcd					_AddExit:
.2bcd	20 17 2e	jsr $2e17			jsr 	FloatIsZero 				; check for -0
.2bd0	d0 02		bne $2bd4			bne 	_AddNonZero
.2bd2	74 34		stz $34,x			stz 	NSStatus,x
.2bd4					_AddNonZero:
.2bd4	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2bd5					FloatEncodeStart:
.2bd5	38		sec				sec
.2bd6	80 01		bra $2bd9			bra 	FloatEncodeContinue+1
.2bd8					FloatEncodeContinue:
.2bd8	18		clc				clc
.2bd9					FloatEncode:
.2bd9	08		php				php 								; save reset flag.
.2bda	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2bdc	f0 15		beq $2bf3			beq 	_ENIsOkay
.2bde	c9 30		cmp #$30			cmp 	#"0"
.2be0	90 04		bcc $2be6			bcc 	_ENBadNumber
.2be2	c9 3a		cmp #$3a			cmp 	#"9"+1
.2be4	90 0d		bcc $2bf3			bcc 	_ENIsOkay
.2be6					_ENBadNumber:
.2be6	28		plp				plp 								; throw saved reset
.2be7	ad 8b 05	lda $058b			lda 	encodeState 				; if in decimal mode, construct final number
.2bea	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2bec	d0 03		bne $2bf1			bne 	_ENFail
.2bee	4c 6b 2c	jmp $2c6b			jmp 	_ENConstructFinal
.2bf1					_ENFail:
.2bf1	18		clc				clc 								; not allowed
.2bf2	60		rts				rts
.2bf3					_ENIsOkay:
.2bf3	28		plp				plp 								; are we restarting
.2bf4	90 15		bcc $2c0b			bcc 	_ENNoRestart
.2bf6					_ENStartEncode:
.2bf6	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2bf8	f0 0c		beq $2c06			beq 	_ENFirstDP
.2bfa	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2bfc	20 f7 2d	jsr $2df7			jsr 	FloatSetByte 				; in single byte mode.
.2bff	a9 01		lda #$01			lda 	#ESTA_Low
.2c01					_ENExitChange:
.2c01	8d 8b 05	sta $058b			sta 	encodeState 				; save new state
.2c04	38		sec				sec
.2c05	60		rts				rts
.2c06					_ENFirstDP:
.2c06	20 f5 2d	jsr $2df5			jsr 	FloatSetZero 				; clear integer part
.2c09	80 3c		bra $2c47			bra 	_ESTASwitchFloat			; go straight to float and exi
.2c0b					_ENNoRestart:
.2c0b	48		pha				pha 								; save digit or DP on stack.
.2c0c	ad 8b 05	lda $058b			lda 	encodeState 				; get current state
.2c0f	c9 01		cmp #$01			cmp 	#ESTA_Low
.2c11	f0 09		beq $2c1c			beq  	_ESTALowState
.2c13	c9 02		cmp #$02			cmp 	#ESTA_High
.2c15	f0 26		beq $2c3d			beq 	_ESTAHighState
.2c17	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2c19	f0 38		beq $2c53			beq 	_ESTADecimalState
>2c1b	db						.byte 	$DB 						; causes a break in the emulator
.2c1c					_ESTALowState:
.2c1c	68		pla				pla 								; get value back
.2c1d	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.2c1f	f0 26		beq $2c47			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.2c21	29 0f		and #$0f			and 	#15 						; make digit
.2c23	8d 8c 05	sta $058c			sta 	digitTemp 					; save it.
.2c26	b5 40		lda $40,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.2c28	0a		asl a				asl 	a
.2c29	0a		asl a				asl 	a
.2c2a	75 40		adc $40,x			adc 	NSMantissa0,x
.2c2c	0a		asl a				asl 	a
.2c2d	6d 8c 05	adc $058c			adc 	digitTemp
.2c30	95 40		sta $40,x			sta 	NSMantissa0,x
.2c32	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.2c34	90 05		bcc $2c3b			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.2c36	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.2c38	8d 8b 05	sta $058b			sta 	encodeState
.2c3b					_ESTANoSwitch:
.2c3b	38		sec				sec
.2c3c	60		rts				rts
.2c3d					_ESTAHighState:
.2c3d	68		pla				pla 								; get value back
.2c3e	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.2c40	f0 05		beq $2c47			beq 	_ESTASwitchFloat
.2c42	20 9d 2c	jsr $2c9d			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.2c45	38		sec				sec
.2c46	60		rts				rts
.2c47					_ESTASwitchFloat:
.2c47	9c 8d 05	stz $058d			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.2c4a	e8		inx				inx 								; zero the decimal additive.
.2c4b	20 f5 2d	jsr $2df5			jsr 	FloatSetZero
.2c4e	ca		dex				dex
.2c4f	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.2c51	80 ae		bra $2c01			bra 	_ENExitChange
.2c53					_ESTADecimalState:
.2c53	68		pla				pla 								; digit.
.2c54	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.2c56	f0 99		beq $2bf1			beq 	_ENFail
.2c58	e8		inx				inx 								; put digit into fractional part of X+1
.2c59	20 9d 2c	jsr $2c9d			jsr 	ESTAShiftDigitIntoMantissa
.2c5c	ca		dex				dex
.2c5d	ee 8d 05	inc $058d			inc 	decimalCount 				; bump the count of decimals
.2c60	ad 8d 05	lda $058d			lda 	decimalCount 				; too many decimal digits.
.2c63	c9 0b		cmp #$0b			cmp 	#11
.2c65	f0 02		beq $2c69			beq 	_ESTADSFail
.2c67	38		sec				sec
.2c68	60		rts				rts
.2c69					_ESTADSFail:
.2c69	18		clc				clc
.2c6a	60		rts				rts
.2c6b					_ENConstructFinal:
.2c6b	ad 8d 05	lda $058d			lda 	decimalCount 				; get decimal count
.2c6e	f0 2b		beq $2c9b			beq 	_ENCFExit 					; no decimals
.2c70	5a		phy				phy
.2c71	0a		asl a				asl 	a 							; x 4 and CLC
.2c72	0a		asl a				asl 	a
.2c73	6d 8d 05	adc $058d			adc 	decimalCount
.2c76	a8		tay				tay
.2c77	b9 02 29	lda $2902,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.2c7a	95 42		sta $42,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.2c7c	b9 03 29	lda $2903,y			lda 	FloatScalarTable-5+1,y
.2c7f	95 4e		sta $4e,x			sta 	NSMantissa1+2,x
.2c81	b9 04 29	lda $2904,y			lda 	FloatScalarTable-5+2,y
.2c84	95 5a		sta $5a,x			sta 	NSMantissa2+2,x
.2c86	b9 05 29	lda $2905,y			lda 	FloatScalarTable-5+3,y
.2c89	95 66		sta $66,x			sta 	NSMantissa3+2,x
.2c8b	b9 06 29	lda $2906,y			lda 	FloatScalarTable-5+4,y
.2c8e	95 72		sta $72,x			sta 	NSExponent+2,x
.2c90	74 36		stz $36,x			stz 	NSStatus+2,x 				; make +ve
.2c92	e8		inx				inx 								; multiply decimal const by decimal scalar
.2c93	e8		inx				inx
.2c94	20 b5 2a	jsr $2ab5			jsr 	FloatMultiply
.2c97	20 19 28	jsr $2819			jsr 	FloatAdd 					; add to integer part.
.2c9a	7a		ply				ply
.2c9b					_ENCFExit:
.2c9b	18		clc				clc 								; reject the digit.
.2c9c	60		rts				rts
.2c9d					ESTAShiftDigitIntoMantissa:
.2c9d	29 0f		and #$0f			and 	#15 						; save digit
.2c9f	48		pha				pha
.2ca0	b5 64		lda $64,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2ca2	48		pha				pha
.2ca3	b5 58		lda $58,x			lda 	NSMantissa2,x
.2ca5	48		pha				pha
.2ca6	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2ca8	48		pha				pha
.2ca9	b5 40		lda $40,x			lda 	NSMantissa0,x
.2cab	48		pha				pha
.2cac	20 04 2e	jsr $2e04			jsr 	FloatShiftLeft 				; x 2
.2caf	20 04 2e	jsr $2e04			jsr 	FloatShiftLeft 				; x 4
.2cb2	18		clc				clc 								; pop mantissa and add
.2cb3	68		pla				pla
.2cb4	75 40		adc $40,x			adc 	NSMantissa0,x
.2cb6	95 40		sta $40,x			sta 	NSMantissa0,x
.2cb8	68		pla				pla
.2cb9	75 4c		adc $4c,x			adc 	NSMantissa1,x
.2cbb	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2cbd	68		pla				pla
.2cbe	75 58		adc $58,x			adc 	NSMantissa2,x
.2cc0	95 58		sta $58,x			sta 	NSMantissa2,x
.2cc2	68		pla				pla
.2cc3	75 64		adc $64,x			adc 	NSMantissa3,x
.2cc5	95 64		sta $64,x			sta 	NSMantissa3,x 				; x 5
.2cc7	20 04 2e	jsr $2e04			jsr 	FloatShiftLeft 				; x 10
.2cca	68		pla				pla 								; add digit
.2ccb	18		clc				clc
.2ccc	75 40		adc $40,x			adc 	NSMantissa0,x
.2cce	95 40		sta $40,x			sta 	NSMantissa0,x
.2cd0	90 0a		bcc $2cdc			bcc 	_ESTASDExit
.2cd2	f6 4c		inc $4c,x			inc 	NSMantissa1,x
.2cd4	d0 06		bne $2cdc			bne 	_ESTASDExit
.2cd6	f6 58		inc $58,x			inc 	NSMantissa2,x
.2cd8	d0 02		bne $2cdc			bne 	_ESTASDExit
.2cda	f6 64		inc $64,x			inc 	NSMantissa3,x
.2cdc					_ESTASDExit:
.2cdc	60		rts				rts
.058b					encodeState:
>058b							.fill 	1
.058c					digitTemp:
>058c							.fill 	1
.058d					decimalCount:
>058d							.fill 	1
.2cdd					FloatToString:
.2cdd	da		phx				phx
.2cde	5a		phy				phy 								; save code position
.2cdf	8d 8e 05	sta $058e			sta 	decimalPlaces	 			; save number of DPs.
.2ce2	9c 8f 05	stz $058f			stz 	dbOffset 					; offset into decimal buffer = start.
.2ce5	b5 34		lda $34,x			lda 	NSStatus,x  				; is it -ve.
.2ce7	10 08		bpl $2cf1			bpl 	_CNTSNotNegative
.2ce9	29 7f		and #$7f			and 	#$7F 						; make +ve
.2ceb	95 34		sta $34,x			sta 	NSStatus,x
.2ced	a9 2d		lda #$2d			lda 	#"-"
.2cef	80 02		bra $2cf3			bra 	_CNTMain
.2cf1					_CNTSNotNegative:
.2cf1	a9 20		lda #$20			lda 	#" "
.2cf3					_CNTMain:
.2cf3	20 55 2d	jsr $2d55			jsr 	WriteDecimalBuffer
.2cf6	b5 70		lda $70,x			lda 	NSExponent,x 				; check if decimal
.2cf8	f0 0d		beq $2d07			beq 	_CNTSNotFloat
.2cfa	e8		inx				inx 								; round up so we don't get too many 6.999999
.2cfb	a9 01		lda #$01			lda 	#1
.2cfd	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.2d00	b5 6f		lda $6f,x			lda		NSExponent-1,x
.2d02	95 70		sta $70,x			sta 	NSExponent,x
.2d04	20 19 28	jsr $2819			jsr 	FloatAdd
.2d07					_CNTSNotFloat:
.2d07	20 37 2d	jsr $2d37			jsr 	MakePlusTwoString 			; do the integer part.
.2d0a	20 d5 29	jsr $29d5			jsr 	FloatFractionalPart 		; get the fractional part
.2d0d	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise					; normalise , exit if zero
.2d10	f0 22		beq $2d34			beq 	_CNTSExit
.2d12	a9 2e		lda #$2e			lda 	#"."
.2d14	20 55 2d	jsr $2d55			jsr 	WriteDecimalBuffer 			; write decimal place
.2d17					_CNTSDecimal:
.2d17	ce 8e 05	dec $058e			dec 	decimalPlaces 				; done all the decimals
.2d1a	30 18		bmi $2d34			bmi 	_CNTSExit
.2d1c	e8		inx				inx 								; x 10.0
.2d1d	a9 0a		lda #$0a			lda 	#10
.2d1f	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.2d22	20 b5 2a	jsr $2ab5			jsr 	FloatMultiply
.2d25	20 37 2d	jsr $2d37			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.2d28	20 d5 29	jsr $29d5			jsr 	FloatFractionalPart 		; get the fractional part
.2d2b	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise 				; normalise it.
.2d2e	b5 70		lda $70,x			lda 	NSExponent,x 				; gone to zero, exit.
.2d30	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.2d32	b0 e3		bcs $2d17			bcs 	_CNTSDecimal 				; keep going.
.2d34					_CNTSExit:
.2d34	7a		ply				ply
.2d35	fa		plx				plx
.2d36	60		rts				rts
.2d37					MakePlusTwoString:
.2d37	da		phx				phx
.2d38	20 d8 2d	jsr $2dd8			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.2d3b	e8		inx				inx 								; access it
.2d3c	e8		inx				inx
.2d3d	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart 			; make it an integer
.2d40	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.2d42	20 74 2d	jsr $2d74			jsr 	ConvertInt32
.2d45	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.2d47					_MPTSCopy:
.2d47	bd 69 05	lda $0569,x			lda 	numberBuffer,x
.2d4a	20 55 2d	jsr $2d55			jsr 	WriteDecimalBuffer
.2d4d	e8		inx				inx
.2d4e	bd 69 05	lda $0569,x			lda 	numberBuffer,x
.2d51	d0 f4		bne $2d47			bne 	_MPTSCopy
.2d53	fa		plx				plx
.2d54	60		rts				rts
.2d55					WriteDecimalBuffer:
.2d55	da		phx				phx
.2d56	ae 8f 05	ldx $058f			ldx 	dbOffset
.2d59	9d 90 05	sta $0590,x			sta 	decimalBuffer,x
.2d5c	9e 91 05	stz $0591,x			stz 	decimalBuffer+1,x
.2d5f	ee 8f 05	inc $058f			inc 	dbOffset
.2d62	fa		plx				plx
.2d63	60		rts				rts
.058e					decimalPlaces:
>058e							.fill 	1
.058f					dbOffset:
>058f							.fill 	1
.0590					decimalBuffer:
>0590							.fill 	32
.2d64					ConvertInt16:
.2d64	85 40		sta $40				sta 	NSMantissa0 				; set up as 32 bit conversion
.2d66	86 4c		stx $4c				stx 	NSMantissa1
.2d68	64 58		stz $58				stz 	NSMantissa2
.2d6a	64 64		stz $64				stz 	NSMantissa3
.2d6c	64 34		stz $34				stz 	NSStatus 					; positive integer
.2d6e	a2 00		ldx #$00			ldx 	#0 							; stack level
.2d70	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.2d72	80 00		bra $2d74			bra 	ConvertInt32
.2d74					ConvertInt32:
.2d74	5a		phy				phy
.2d75	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.2d77	24 34		bit $34				bit 	NSStatus 					; output a - if not negative.
.2d79	10 08		bpl $2d83			bpl 	_CI32NotNeg
.2d7b	48		pha				pha
.2d7c	a9 2d		lda #$2d			lda 	#'-'
.2d7e	99 69 05	sta $0569,y			sta 	numberBuffer,y
.2d81	c8		iny				iny
.2d82	68		pla				pla
.2d83					_CI32NotNeg:
.2d83	20 91 2d	jsr $2d91			jsr 	_CI32DivideConvert 			; recursive conversion
.2d86	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2d88	99 69 05	sta $0569,y			sta 	numberBuffer,y
.2d8b	7a		ply				ply
.2d8c	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.2d8e	a9 69		lda #$69			lda 	#numberBuffer & $FF
.2d90	60		rts				rts
.2d91					_CI32DivideConvert:
.2d91	e8		inx				inx 								; write to next slot up
.2d92	20 f7 2d	jsr $2df7			jsr 	FloatSetByte 		 		; write the base out.
.2d95	ca		dex				dex
.2d96	20 8b 29	jsr $298b			jsr 	Int32Divide 				; divide
.2d99	b5 40		lda $40,x			lda 	NSMantissa0,x 				; save remainder
.2d9b	48		pha				pha
.2d9c	20 7a 29	jsr $297a			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2d9f	20 17 2e	jsr $2e17			jsr 	FloatIsZero 				; is it zero ?
.2da2	f0 05		beq $2da9			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2da4	b5 41		lda $41,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2da6	20 91 2d	jsr $2d91			jsr 	_CI32DivideConvert 			; and recusrively call.
.2da9					_CI32NoRecurse:
.2da9	68		pla				pla 								; remainder
.2daa	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2dac	90 02		bcc $2db0			bcc 	_CI32NotHex
.2dae	69 26		adc #$26			adc 	#6+32
.2db0					_CI32NotHex:
.2db0	69 30		adc #$30			adc 	#48
.2db2	99 69 05	sta $0569,y			sta 	numberBuffer,y 				; write out and exit
.2db5	c8		iny				iny
.2db6	60		rts				rts
.2db7					FloatNegate:
.2db7	b5 34		lda $34,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2db9	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2dbb	95 34		sta $34,x			sta 	NSStatus,x
.2dbd	60		rts				rts
.2dbe					FloatNegateMantissa:
.2dbe	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2dbf	a9 00		lda #$00			lda 	#0
.2dc1	f5 40		sbc $40,x			sbc 	NSMantissa0,x
.2dc3	95 40		sta $40,x			sta 	NSMantissa0,x
.2dc5	a9 00		lda #$00			lda 	#0
.2dc7	f5 4c		sbc $4c,x			sbc 	NSMantissa1,x
.2dc9	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2dcb	a9 00		lda #$00			lda 	#0
.2dcd	f5 58		sbc $58,x			sbc 	NSMantissa2,x
.2dcf	95 58		sta $58,x			sta 	NSMantissa2,x
.2dd1	a9 00		lda #$00			lda 	#0
.2dd3	f5 64		sbc $64,x			sbc 	NSMantissa3,x
.2dd5	95 64		sta $64,x			sta 	NSMantissa3,x
.2dd7	60		rts				rts
.2dd8					FloatShiftUpTwo:
.2dd8	b5 40		lda $40,x			lda 	NSMantissa0,x
.2dda	95 42		sta $42,x			sta 	NSMantissa0+2,x
.2ddc	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2dde	95 4e		sta $4e,x			sta 	NSMantissa1+2,x
.2de0	b5 58		lda $58,x			lda 	NSMantissa2,x
.2de2	95 5a		sta $5a,x			sta 	NSMantissa2+2,x
.2de4	b5 64		lda $64,x			lda 	NSMantissa3,x
.2de6	95 66		sta $66,x			sta 	NSMantissa3+2,x
.2de8	b5 70		lda $70,x			lda 	NSExponent,x
.2dea	95 72		sta $72,x			sta 	NSExponent+2,x
.2dec	b5 34		lda $34,x			lda 	NSStatus,x
.2dee	95 36		sta $36,x			sta 	NSStatus+2,x
.2df0	60		rts				rts
.2df1					FloatSetZeroMantissaOnly:
.2df1	74 40		stz $40,x			stz 	NSMantissa0,x
.2df3	80 08		bra $2dfd			bra 	FloatZero13
.2df5					FloatSetZero:
.2df5	a9 00		lda #$00			lda 	#0
.2df7					FloatSetByte:
.2df7	74 70		stz $70,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2df9					FloatSetMantissa:
.2df9	95 40		sta $40,x			sta 	NSMantissa0,x 				; zero mantissa
.2dfb	74 34		stz $34,x			stz 	NSStatus,x
.2dfd					FloatZero13:
.2dfd	74 4c		stz $4c,x			stz 	NSMantissa1,x
.2dff	74 58		stz $58,x			stz 	NSMantissa2,x
.2e01	74 64		stz $64,x			stz 	NSMantissa3,x
.2e03	60		rts				rts
.2e04					FloatShiftLeft:
.2e04	18		clc				clc
.2e05					FloatRotateLeft:
.2e05	36 40		rol $40,x			rol 	NSMantissa0,x
.2e07	36 4c		rol $4c,x			rol		NSMantissa1,x
.2e09	36 58		rol $58,x			rol		NSMantissa2,x
.2e0b	36 64		rol $64,x			rol		NSMantissa3,x
.2e0d	60		rts				rts
.2e0e					FloatShiftRight:
.2e0e	56 64		lsr $64,x			lsr 	NSMantissa3,x
.2e10	76 58		ror $58,x			ror		NSMantissa2,x
.2e12	76 4c		ror $4c,x			ror		NSMantissa1,x
.2e14	76 40		ror $40,x			ror		NSMantissa0,x
.2e16	60		rts				rts
.2e17					FloatIsZero:
.2e17	b5 64		lda $64,x			lda 	NSMantissa3,x
.2e19	15 58		ora $58,x			ora		NSMantissa2,x
.2e1b	15 4c		ora $4c,x			ora		NSMantissa1,x
.2e1d	15 40		ora $40,x			ora		NSMantissa0,x
.2e1f	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.2e20					FloatArcTan:
.2e20	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise 					; normalise x
.2e23	b5 34		lda $34,x			lda 	NSStatus,x 						; save sign, make absolute
.2e25	48		pha				pha
.2e26	74 34		stz $34,x			stz 	NSStatus,x
.2e28	b5 70		lda $70,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.2e2a	c9 e2		cmp #$e2			cmp 	#$E2
.2e2c	90 25		bcc $2e53			bcc 	_UANoFixup
.2e2e	8a		txa				txa 									; value in +1
.2e2f	a8		tay				tay
.2e30	c8		iny				iny
.2e31	20 d9 2f	jsr $2fd9			jsr 	CopyFloatXY
.2e34	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.2e36	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.2e39	e8		inx				inx
.2e3a	20 3e 29	jsr $293e			jsr 	FloatDivide
.2e3d	b0 21		bcs $2e60			bcs 	_FATError
.2e3f	20 63 2e	jsr $2e63			jsr 	CoreAtn 						; calculate the root
.2e42	20 ce 2f	jsr $2fce			jsr 	CompletePolynomial
.2e45	20 b7 2d	jsr $2db7			jsr 	FloatNegate 					; make -ve
.2e48	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2e4a	20 25 30	jsr $3025			jsr 	LoadConstant
.2e4d	e8		inx				inx
.2e4e	20 19 28	jsr $2819			jsr 	FloatAdd
.2e51	80 06		bra $2e59			bra 	_UAComplete
.2e53					_UANoFixup:
.2e53	20 63 2e	jsr $2e63			jsr 	CoreAtn
.2e56	20 ce 2f	jsr $2fce			jsr 	CompletePolynomial
.2e59					_UAComplete:
.2e59	68		pla				pla 									; apply the result.
.2e5a	55 34		eor $34,x			eor 	NSStatus,x
.2e5c	95 34		sta $34,x			sta 	NSStatus,x
.2e5e	18		clc				clc
.2e5f	60		rts				rts
.2e60					_FATError:
.2e60	68		pla				pla
.2e61	38		sec				sec
.2e62	60		rts				rts
.2e63					CoreAtn:
.2e63	a9 d1		lda #$d1			lda 	#AtnCoefficients & $FF
.2e65	a0 2e		ldy #$2e			ldy 	#AtnCoefficients >> 8
.2e67	4c 22 31	jmp $3122			jmp 	CorePolySquared
.2e6a					ExpCoefficients:
>2e6a	07					.byte	7
>2e6b	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>2e6f	d2					.byte	$d2
>2e70	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>2e74	d5					.byte	$d5
>2e75	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>2e79	d8					.byte	$d8
>2e7a	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>2e7e	db					.byte	$db
>2e7f	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>2e83	dd					.byte	$dd
>2e84	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>2e88	df					.byte	$df
>2e89	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>2e8d	e1					.byte	$e1
>2e8e	00 00 00 40				.dword	$40000000 ; 1.0
>2e92	e2					.byte	$e2
.2e93					SinCoefficients:
>2e93	06					.byte	6
>2e94	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>2e98	e5					.byte	$e5
>2e99	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>2e9d	e7					.byte	$e7
>2e9e	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>2ea2	e8					.byte	$e8
>2ea3	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>2ea7	e8					.byte	$e8
>2ea8	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>2eac	e7					.byte	$e7
>2ead	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>2eb1	e4					.byte	$e4
>2eb2	00 00 00 00				.dword	$00000000 ; 0.0
>2eb6	00					.byte	$00
.2eb7					LogCoefficients:
>2eb7	04					.byte	4
>2eb8	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>2ebc	e0					.byte	$e0
>2ebd	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>2ec1	e1					.byte	$e1
>2ec2	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>2ec6	e1					.byte	$e1
>2ec7	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>2ecb	e3					.byte	$e3
>2ecc	00 00 00 c0				.dword	$c0000000 ; -0.5
>2ed0	e1					.byte	$e1
.2ed1					AtnCoefficients:
>2ed1	0c					.byte	12
>2ed2	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2ed6	d7					.byte	$d7
>2ed7	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>2edb	da					.byte	$da
>2edc	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>2ee0	dc					.byte	$dc
>2ee1	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2ee5	dd					.byte	$dd
>2ee6	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>2eea	dd					.byte	$dd
>2eeb	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>2eef	de					.byte	$de
>2ef0	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2ef4	de					.byte	$de
>2ef5	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>2ef9	de					.byte	$de
>2efa	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>2efe	df					.byte	$df
>2eff	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>2f03	df					.byte	$df
>2f04	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>2f08	e0					.byte	$e0
>2f09	00 00 00 40				.dword	$40000000 ; 1.0
>2f0d	e2					.byte	$e2
>2f0e	00 00 00 00				.dword	$00000000 ; 0.0
>2f12	00					.byte	$00
.2f13					Const_Base:
.2f13					Const_1Div2Pi:
>2f13	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>2f17	df					.byte	$df
.2f18					Const_PiDiv2:
>2f18	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>2f1c	e2					.byte	$e2
.2f1d					Const_Log2_e:
>2f1d	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>2f21	e2					.byte	$e2
.2f22					Const_sqrt_2:
>2f22	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>2f26	e2					.byte	$e2
.2f27					Const_sqrt_half:
>2f27	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>2f2b	e1					.byte	$e1
.2f2c					Const_pi:
>2f2c	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>2f30	e3					.byte	$e3
.2f31					Const_half:
>2f31	00 00 00 40				.dword	$40000000 ; 0.50000000
>2f35	e1					.byte	$e1
.2f36					Const_ln_e:
>2f36	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>2f3a	e1					.byte	$e1
.2f3b					FloatCosine:
.2f3b	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2f3d	20 25 30	jsr $3025			jsr 	LoadConstant
.2f40	e8		inx				inx
.2f41	20 19 28	jsr $2819			jsr 	FloatAdd
.2f44	4c db 30	jmp $30db			jmp 	FloatSine
.2f47					FloatExponent:
.2f47	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.2f49	20 25 30	jsr $3025			jsr 	LoadConstant
.2f4c	e8		inx				inx
.2f4d	20 b5 2a	jsr $2ab5			jsr 	FloatMultiply
.2f50	20 92 2f	jsr $2f92			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.2f53	e8		inx				inx
.2f54	20 30 2a	jsr $2a30			jsr 	FloatIntegerPart
.2f57	ca		dex				dex
.2f58	b5 4d		lda $4d,x			lda 	NSMantissa1+1,x
.2f5a	15 59		ora $59,x			ora 	NSMantissa2+1,x
.2f5c	15 65		ora $65,x			ora 	NSMantissa3+1,x
.2f5e	d0 38		bne $2f98			bne 	_UERangeError
.2f60	b5 41		lda $41,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.2f62	c9 40		cmp #$40			cmp 	#64
.2f64	b0 32		bcs $2f98			bcs 	_UERangeError
.2f66	48		pha				pha
.2f67	b5 34		lda $34,x			lda 	NSStatus,x 				; push sign
.2f69	48		pha				pha
.2f6a	20 d5 29	jsr $29d5			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.2f6d	68		pla				pla
.2f6e	10 14		bpl $2f84			bpl 	_UEPositive
.2f70	e8		inx				inx 							; 1-x
.2f71	a9 01		lda #$01			lda 	#1
.2f73	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.2f76	ca		dex				dex
.2f77	20 b7 2d	jsr $2db7			jsr 	FloatNegate
.2f7a	e8		inx				inx
.2f7b	20 19 28	jsr $2819			jsr 	FloatAdd
.2f7e	68		pla				pla 							; integer part +1 and negated.
.2f7f	1a		inc a				inc 	a
.2f80	49 ff		eor #$ff			eor 	#$FF
.2f82	1a		inc a				inc 	a
.2f83	48		pha				pha
.2f84					_UEPositive:
.2f84	20 9a 2f	jsr $2f9a			jsr 	CoreExponent
.2f87	20 ce 2f	jsr $2fce			jsr 	CompletePolynomial
.2f8a	68		pla				pla
.2f8b	18		clc				clc
.2f8c	75 70		adc $70,x			adc 	NSExponent,x
.2f8e	95 70		sta $70,x			sta 	NSExponent,x
.2f90	18		clc				clc
.2f91	60		rts				rts
.2f92					_UECopy01:
.2f92	8a		txa				txa
.2f93	a8		tay				tay
.2f94	c8		iny				iny
.2f95	4c d9 2f	jmp $2fd9			jmp 	CopyFloatXY
.2f98					_UERangeError:
.2f98	38		sec				sec
.2f99	60		rts				rts
.2f9a					CoreExponent:
.2f9a	a9 6a		lda #$6a			lda 	#ExpCoefficients & $FF
.2f9c	a0 2e		ldy #$2e			ldy 	#ExpCoefficients >> 8
.2f9e	20 a2 2f	jsr $2fa2			jsr 	CalculateHornerPolynomial
.2fa1	60		rts				rts
.2fa2					CalculateHornerPolynomial:
.2fa2	85 28		sta $28				sta 	zTemp0 						; save poly data from YA
.2fa4	84 29		sty $29				sty 	zTemp0+1
.2fa6	9c b0 05	stz $05b0			stz 	coefficientCount 			; zero the count.
.2fa9	8e b1 05	stx $05b1			stx 	xValueSlot 					; save xValue slot.
.2fac	e8		inx				inx 								; set the count to zero.
.2fad	20 f5 2d	jsr $2df5			jsr 	FloatSetZero
.2fb0					_CHPLoop:
.2fb0	8a		txa				txa 								; copy X-1 to X+1
.2fb1	a8		tay				tay
.2fb2	ca		dex				dex
.2fb3	c8		iny				iny
.2fb4	20 d9 2f	jsr $2fd9			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.2fb7	e8		inx				inx
.2fb8	e8		inx				inx
.2fb9	20 b5 2a	jsr $2ab5			jsr 	FloatMultiply 				; times current by X
.2fbc	e8		inx				inx
.2fbd	20 f8 2f	jsr $2ff8			jsr 	GetCoefficient 				; coefficient into X+1
.2fc0	20 19 28	jsr $2819			jsr 	FloatAdd 					; and add
.2fc3	ee b0 05	inc $05b0			inc 	coefficientCount
.2fc6	ad b0 05	lda $05b0			lda 	coefficientCount
.2fc9	d2 28		cmp ($28)			cmp 	(zTemp0)
.2fcb	d0 e3		bne $2fb0			bne 	_CHPLoop
.2fcd	60		rts				rts
.2fce					CompletePolynomial:
.2fce	20 b5 2a	jsr $2ab5			jsr 	FloatMultiply
.2fd1	e8		inx				inx 								; get the last value
.2fd2	20 f8 2f	jsr $2ff8			jsr 	GetCoefficient
.2fd5	20 19 28	jsr $2819			jsr 	FloatAdd 					; and add it
.2fd8	60		rts				rts
.2fd9					CopyFloatXY:
.2fd9	b5 70		lda $70,x			lda 	NSExponent,x
.2fdb	99 70 00	sta $0070,y			sta 	NSExponent,y
.2fde	b5 34		lda $34,x			lda 	NSStatus,x
.2fe0	99 34 00	sta $0034,y			sta 	NSStatus,y
.2fe3	b5 40		lda $40,x			lda 	NSMantissa0,x
.2fe5	99 40 00	sta $0040,y			sta 	NSMantissa0,y
.2fe8	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2fea	99 4c 00	sta $004c,y			sta 	NSMantissa1,y
.2fed	b5 58		lda $58,x			lda 	NSMantissa2,x
.2fef	99 58 00	sta $0058,y			sta 	NSMantissa2,y
.2ff2	b5 64		lda $64,x			lda 	NSMantissa3,x
.2ff4	99 64 00	sta $0064,y			sta 	NSMantissa3,y
.2ff7	60		rts				rts
.2ff8					GetCoefficient:
.2ff8	5a		phy				phy
.2ff9	ad b0 05	lda $05b0			lda 	coefficientCount 			; 5 per block
.2ffc	0a		asl a				asl 	a
.2ffd	0a		asl a				asl 	a
.2ffe	38		sec				sec 								; +1 for count
.2fff	6d b0 05	adc $05b0			adc 	coefficientCount
.3002	a8		tay				tay
.3003	b1 28		lda ($28),y			lda 	(zTemp0),y 					; copy mantissa
.3005	95 40		sta $40,x			sta 	NSMantissa0,x
.3007	c8		iny				iny
.3008	b1 28		lda ($28),y			lda 	(zTemp0),y
.300a	95 4c		sta $4c,x			sta 	NSMantissa1,x
.300c	c8		iny				iny
.300d	b1 28		lda ($28),y			lda 	(zTemp0),y
.300f	95 58		sta $58,x			sta 	NSMantissa2,x
.3011	c8		iny				iny
.3012	b1 28		lda ($28),y			lda 	(zTemp0),y
.3014	48		pha				pha
.3015	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.3017	95 64		sta $64,x			sta 	NSMantissa3,x
.3019	c8		iny				iny
.301a	68		pla				pla
.301b	29 80		and #$80			and 	#$80
.301d	95 34		sta $34,x			sta 	NSStatus,x 					; put in status
.301f	b1 28		lda ($28),y			lda 	(zTemp0),y
.3021	95 70		sta $70,x			sta 	NSExponent,x
.3023	7a		ply				ply
.3024	60		rts				rts
.05b0					coefficientCount:
>05b0							.fill 	1
.05b1					xValueSlot:
>05b1							.fill 	1
.3025					LoadConstant:
.3025	5a		phy				phy
.3026	a8		tay				tay
.3027	b9 13 2f	lda $2f13,y			lda 	Const_Base+0,y
.302a	95 41		sta $41,x			sta 	NSMantissa0+1,x
.302c	b9 14 2f	lda $2f14,y			lda 	Const_Base+1,y
.302f	95 4d		sta $4d,x			sta 	NSMantissa1+1,x
.3031	b9 15 2f	lda $2f15,y			lda 	Const_Base+2,y
.3034	95 59		sta $59,x			sta 	NSMantissa2+1,x
.3036	b9 16 2f	lda $2f16,y			lda 	Const_Base+3,y
.3039	48		pha				pha
.303a	29 7f		and #$7f			and 	#$7F
.303c	95 65		sta $65,x			sta 	NSMantissa3+1,x
.303e	68		pla				pla
.303f	29 80		and #$80			and 	#$80
.3041	95 35		sta $35,x			sta 	NSStatus+1,x
.3043	b9 17 2f	lda $2f17,y			lda 	Const_Base+4,y
.3046	95 71		sta $71,x			sta 	NSExponent+1,x
.3048	7a		ply				ply
.3049	60		rts				rts
.304a					FloatLogarithm:
.304a	b5 34		lda $34,x			lda 	NSStatus,x 					; check > 0
.304c	30 5f		bmi $30ad			bmi 	_ULRange
.304e	20 17 2e	jsr $2e17			jsr 	FloatIsZero
.3051	f0 5a		beq $30ad			beq 	_ULRange
.3053	20 4a 2b	jsr $2b4a			jsr 	FloatNormalise 				; put into FP mode.
.3056	b5 70		lda $70,x			lda 	NSExponent,x 				; get power
.3058	48		pha				pha
.3059	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.305b	95 70		sta $70,x			sta 	NSExponent,x
.305d	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.305f	20 25 30	jsr $3025			jsr 	LoadConstant
.3062	e8		inx				inx
.3063	20 19 28	jsr $2819			jsr 	FloatAdd
.3066	8a		txa				txa 								; divide into sqrt 2.0
.3067	a8		tay				tay
.3068	c8		iny				iny
.3069	20 d9 2f	jsr $2fd9			jsr 	CopyFloatXY
.306c	ca		dex				dex
.306d	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.306f	20 25 30	jsr $3025			jsr 	LoadConstant
.3072	e8		inx				inx
.3073	e8		inx				inx
.3074	20 3e 29	jsr $293e			jsr 	FloatDivide 				; if zero, error.
.3077	b0 33		bcs $30ac			bcs 	_ULRangePla
.3079	20 b7 2d	jsr $2db7			jsr 	FloatNegate 				; subtract from 1
.307c	e8		inx				inx
.307d	a9 01		lda #$01			lda 	#1
.307f	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.3082	20 19 28	jsr $2819			jsr 	FloatAdd
.3085	20 af 30	jsr $30af			jsr 	CoreLog
.3088	20 ce 2f	jsr $2fce			jsr 	CompletePolynomial
.308b	68		pla				pla 								; add exponent
.308c	18		clc				clc
.308d	69 1f		adc #$1f			adc 	#31 						; fix up
.308f	48		pha				pha
.3090	10 03		bpl $3095			bpl 	_LogNotNeg
.3092	49 ff		eor #$ff			eor 	#$FF
.3094	1a		inc a				inc 	a
.3095					_LogNotNeg:
.3095	e8		inx				inx 								; set byte and sign.
.3096	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.3099	68		pla				pla
.309a	29 80		and #$80			and 	#$80
.309c	95 34		sta $34,x			sta 	NSStatus,x
.309e	20 19 28	jsr $2819			jsr 	FloatAdd
.30a1	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.30a3	20 25 30	jsr $3025			jsr 	LoadConstant
.30a6	e8		inx				inx
.30a7	20 b5 2a	jsr $2ab5			jsr 	FloatMultiply
.30aa	18		clc				clc
.30ab	60		rts				rts
.30ac					_ULRangePla:
.30ac	68		pla				pla
.30ad					_ULRange:
.30ad	38		sec				sec
.30ae	60		rts				rts
.30af					CoreLog:
.30af	a9 b7		lda #$b7			lda 	#LogCoefficients & $FF
.30b1	a0 2e		ldy #$2e			ldy 	#LogCoefficients >> 8
.30b3	4c 22 31	jmp $3122			jmp 	CorePolySquared
.30b6					FloatPI:
.30b6	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.30b8	20 25 30	jsr $3025			jsr 	LoadConstant
.30bb	e8		inx				inx
.30bc	18		clc				clc
.30bd	60		rts				rts
.30be					FloatPower:
.30be	ca		dex				dex
.30bf	8a		txa				txa 							; copy 0 to 2, so we can process it
.30c0	a8		tay				tay
.30c1	c8		iny				iny
.30c2	c8		iny				iny
.30c3	20 d9 2f	jsr $2fd9			jsr 	CopyFloatXY
.30c6	e8		inx				inx 							; 2 = Log(0)
.30c7	e8		inx				inx
.30c8	20 4a 30	jsr $304a			jsr 	FloatLogarithm
.30cb	b0 0d		bcs $30da			bcs 	_FPWExit
.30cd	20 b5 2a	jsr $2ab5			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.30d0	8a		txa				txa 							; copy to slot 0
.30d1	a8		tay				tay
.30d2	88		dey				dey
.30d3	20 d9 2f	jsr $2fd9			jsr 	CopyFloatXY
.30d6	ca		dex				dex  							; Exponent code.
.30d7	20 47 2f	jsr $2f47			jsr 	FloatExponent
.30da					_FPWExit:
.30da	60		rts				rts
.30db					FloatSine:
.30db	b5 34		lda $34,x			lda 	NSStatus,x 					; save sign
.30dd	48		pha				pha
.30de	74 34		stz $34,x			stz 	NSStatus,x 					; make +ve
.30e0	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.30e2	20 25 30	jsr $3025			jsr 	LoadConstant
.30e5	e8		inx				inx
.30e6	20 b5 2a	jsr $2ab5			jsr 	FloatMultiply
.30e9	20 d5 29	jsr $29d5			jsr 	FloatFractionalPart 		; take the fractional part
.30ec	b5 70		lda $70,x			lda 	NSExponent,x 				; check exponent
.30ee	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.30f0	90 1f		bcc $3111			bcc 	_USProcessExit
.30f2	f0 06		beq $30fa			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.30f4	b5 64		lda $64,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.30f6	c9 60		cmp #$60			cmp 	#$60
.30f8	b0 0e		bcs $3108			bcs 	_USSubtractOne
.30fa					_USSubtractFromHalf:
.30fa	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.30fc	20 25 30	jsr $3025			jsr 	LoadConstant
.30ff	e8		inx				inx
.3100	20 13 28	jsr $2813			jsr 	FloatSubtract
.3103	20 b7 2d	jsr $2db7			jsr 	FloatNegate 				; then negate it
.3106	80 09		bra $3111			bra 	_USProcessExit 				; and exit
.3108					_USSubtractOne:
.3108	e8		inx				inx
.3109	a9 01		lda #$01			lda 	#1
.310b	20 f7 2d	jsr $2df7			jsr 	FloatSetByte
.310e	20 13 28	jsr $2813			jsr 	FloatSubtract
.3111					_USProcessExit:
.3111	20 1e 31	jsr $311e			jsr 	CoreSine
.3114	20 ce 2f	jsr $2fce			jsr 	CompletePolynomial
.3117	68		pla				pla 								; restore sign and apply
.3118	55 34		eor $34,x			eor 	NSStatus,x
.311a	95 34		sta $34,x			sta 	NSStatus,x
.311c	18		clc				clc
.311d	60		rts				rts
.311e					CoreSine:
.311e	a9 93		lda #$93			lda 	#SinCoefficients & $FF
.3120	a0 2e		ldy #$2e			ldy 	#SinCoefficients >> 8
.3122					CorePolySquared:
.3122	48		pha				pha 								; save coefficient table
.3123	5a		phy				phy
.3124	8a		txa				txa 								; copy X to +1, +2
.3125	a8		tay				tay
.3126	c8		iny				iny
.3127	20 d9 2f	jsr $2fd9			jsr 	CopyFloatXY
.312a	c8		iny				iny
.312b	20 d9 2f	jsr $2fd9			jsr 	CopyFloatXY
.312e	e8		inx				inx 								; point to the pair and put x^2 on stack
.312f	e8		inx				inx
.3130	20 b5 2a	jsr $2ab5			jsr 	FloatMultiply
.3133	7a		ply				ply 								; coefficient table back.
.3134	68		pla				pla
.3135	20 a2 2f	jsr $2fa2			jsr 	CalculateHornerPolynomial
.3138	8a		txa				txa 								; copy back to slot #1
.3139	a8		tay				tay
.313a	88		dey				dey
.313b	20 d9 2f	jsr $2fd9			jsr	 	CopyFloatXY
.313e	ca		dex				dex 								; point at result
.313f	60		rts				rts
.3140					FloatSquareRoot:
.3140	20 4a 30	jsr $304a			jsr 	FloatLogarithm
.3143	b0 06		bcs $314b			bcs 	_FSQExit
.3145	d6 70		dec $70,x			dec 	NSExponent,x
.3147	20 47 2f	jsr $2f47			jsr 	FloatExponent
.314a	18		clc				clc
.314b					_FSQExit:
.314b	60		rts				rts
.314c					FloatTangent:
.314c	da		phx				phx
.314d	8a		txa				txa 								; sin -> +1
.314e	a8		tay				tay
.314f	c8		iny				iny
.3150	20 d9 2f	jsr $2fd9			jsr 	CopyFloatXY
.3153	e8		inx				inx
.3154	20 db 30	jsr $30db			jsr 	FloatSine
.3157	ca		dex				dex
.3158	8a		txa				txa 								; cos -> +2
.3159	a8		tay				tay
.315a	c8		iny				iny
.315b	c8		iny				iny
.315c	20 d9 2f	jsr $2fd9			jsr 	CopyFloatXY
.315f	e8		inx				inx
.3160	e8		inx				inx
.3161	20 3b 2f	jsr $2f3b			jsr 	FloatCosine
.3164	20 3e 29	jsr $293e			jsr 	FloatDivide 				; calculate sin/cos
.3167	b0 07		bcs $3170			bcs 	_FTExit 					; divide by zero
.3169	8a		txa				txa 								; copy result down.
.316a	a8		tay				tay
.316b	88		dey				dey
.316c	20 d9 2f	jsr $2fd9			jsr 	CopyFloatXY
.316f	18		clc				clc
.3170					_FTExit:
.3170	fa		plx				plx
.3171	60		rts				rts

;******  Processing input file: testing/testend.asm

.3172					EndProgram:
>3172	00 40 d4 54 00 a6 04 48				.binary "code/balls.bin"
>317a	00 a6 03 c7 a6 cb 93 93 b1 a6 40 00 01 00 ca 81
>318a	58 03 40 00 01 00 ca 81 58 06 40 00 01 00 ca 81
>319a	58 09 a6 40 00 01 00 ca 81 58 0c 40 00 01 00 ca
>31aa	81 58 0f a6 00 48 12 24 40 00 01 95 a6 40 12 01
>31ba	50 03 8e 01 b4 28 82 ca 84 02 82 01 80 7c a6 40
>31ca	12 01 50 06 8e 01 b4 1e 82 ca 84 cc 00 01 82 7c
>31da	a6 40 12 01 50 09 8e 01 b4 0e 82 ca 84 01 80 7c
>31ea	a6 40 12 01 50 0c 8e 01 b4 02 82 ca 84 7c a6 a6
>31fa	40 12 01 50 0f 8e 01 7c a6 24 a7 a6 a6 00 48 15
>320a	2a 1d 01 95 00 48 18 30 27 01 95 a6 40 15 cc 00
>321a	01 82 40 18 02 82 80 cc 00 b0 80 48 1b a6 01 40
>322a	1b cb 51 c8 01 40 1b 01 80 00 c8 a6 30 a7 2a a7
>323a	a6 01 48 12 24 40 00 01 95 a6 01 cc 00 b0 40 12
>324a	01 50 06 8e 78 80 40 12 01 50 03 8e 78 80 00 c8
>325a	a6 40 12 01 50 0c 8e 78 48 1e a6 40 1e 00 a3 88
>326a	d2 00 07 00 d1 00 5d 00 a6 40 1e 01 a3 88 d2 00
>327a	07 00 d1 00 7a 00 a6 40 12 01 50 0f 8e 78 48 21
>328a	a6 40 21 00 a3 88 d2 00 07 00 d1 00 97 00 a6 40
>329a	21 01 a3 88 d2 00 07 00 d1 00 b6 00 a6 01 cc 00
>32aa	b0 40 12 01 50 06 8e 78 80 40 12 01 50 03 8e 78
>32ba	80 40 12 01 50 09 8e 78 c8 a6 24 a7 a6 d0 00 72
>32ca	ff a6 a6 40 12 01 50 03 8e 78 48 24 a6 40 24 01
>32da	a3 88 d2 00 0c 00 40 12 01 50 0c 8e 01 7c 98 a6
>32ea	40 12 01 50 03 8e 40 24 02 81 7c 98 a6 a6 40 12
>32fa	01 50 03 8e 78 48 24 a6 40 24 cb 4f a3 88 d2 00
>330a	15 00 40 12 01 50 03 8e cb 4d 7c 40 12 01 50 0c
>331a	8e 00 7c 98 a6 40 12 01 50 03 8e 40 24 02 80 7c
>332a	98 a6 a6 40 12 01 50 06 8e 78 48 27 a6 40 27 00
>333a	a3 88 d2 00 0c 00 40 12 01 50 0f 8e 01 7c 98 a6
>334a	40 12 01 50 06 8e 40 27 cc 00 01 81 7c 98 a6 a6
>335a	40 12 01 50 06 8e 78 48 27 a6 40 27 cc 00 1d a3
>336a	88 d2 00 16 00 40 12 01 50 06 8e cc 00 1c 7c 40
>337a	12 01 50 0f 8e 00 7c 98 a6 40 12 01 50 06 8e 40
>338a	27 cc 00 01 80 7c 98 c4 ff

;******  End of listing
