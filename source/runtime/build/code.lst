
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library testing/testend.asm
; Mon Oct  9 06:43:16 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

.0801					WrapperBoot:
.0801	a9 2a		lda #$2a			lda 	#ObjectCode >> 8 			; address of object code to run.
.0803	a2 81		ldx #$81			ldx 	#$81 						; first page of allocatable memory
.0805	a0 9f		ldy #$9f			ldy 	#$9F 						; byte after end of last page.
.0807	4c 0a 08	jmp $080a			jmp 	StartRuntime

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.080a					StartRuntime:
.080a	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.080d	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.080f	64 28		stz $28				stz 	codePtr
.0811	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0814	8c 06 04	sty $0406			sty 	storeEndHigh
.0817	8e 07 04	stx $0407			stx 	variableStartPage
.081a	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.081c	a2 24		ldx #$24			ldx 	#RuntimeErrorHandler & $FF
.081e	20 ab 1e	jsr $1eab			jsr 	SetErrorHandler
.0821	20 53 0a	jsr $0a53			jsr 	ClearMemory 				; clear memory.
.0824	20 32 16	jsr $1632			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0827	20 34 13	jsr $1334		 	jsr		SetDefaultChannel			; set default input/output channel.
.082a	20 6a 15	jsr $156a			jsr 	RestoreCode 				; which we now call
.082d	a0 00		ldy #$00			ldy 	#0
.082f					NextCommand:
.082f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.0831	30 5b		bmi $088e			bmi 	NXCommand 					; -if -ve command
.0833	c8		iny				iny
.0834	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0836	90 39		bcc $0871			bcc 	PushByteA 					; 0..63 is short constants.
.0838					NXLoadStore:
.0838	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.083a	b0 19		bcs $0855			bcs 	NXIndirectLoadStore
.083c	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.083d	4a		lsr a				lsr 	a
.083e	29 0e		and #$0e			and 	#$0E
.0840	da		phx				phx 								; get ready to jump
.0841	aa		tax				tax
.0842	7c 45 08	jmp ($0845,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.0845					ReadWriteVectors:
>0845	a0 14						.word 	ReadFloatCommand			; read float
>0847	7b 1a						.word 	WriteFloatCommand 			; write float
>0849	dc 14						.word 	ReadIntegerCommand 			; read integer
>084b	b7 1a						.word 	WriteIntegerCommand 		; write integer
>084d	21 15						.word 	ReadStringCommand 			; read string
>084f	f6 1a						.word 	WriteStringCommand 			; write string
>0851	21 0c						.word 	Unimplemented
>0853	21 0c						.word 	Unimplemented
.0855					NXIndirectLoadStore:
.0855	29 07		and #$07			and 	#7
.0857	0a		asl a				asl 	a
.0858	da		phx				phx
.0859	aa		tax				tax
.085a	7c 5d 08	jmp ($085d,x)			jmp 	(IndirectVectors,x)
.085d					IndirectVectors:
>085d	d6 0e						.word 	IndFloatRead 				; float read
>085f	ea 0e						.word 	IndInt16Read 				; int16 read
>0861	fe 0e						.word 	IndStringRead 				; string read
>0863	21 0c						.word 	Unimplemented
>0865	12 0f						.word 	IndFloatWrite				; float write
>0867	26 0f						.word 	IndInt16Write 				; int16 write
>0869	3a 0f						.word 	IndStringWrite 				; string write
>086b	21 0c						.word 	Unimplemented
.086d					PushByteCommand:
.086d	fa		plx				plx
.086e	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.0870	c8		iny				iny
.0871					PushByteA:
.0871	e8		inx				inx 								; push constant on stack
.0872	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.0874	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.0876					ClearRestWord:
.0876	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.0878	74 62		stz $62,x			stz 	NSMantissa3,x
.087a	74 6e		stz $6e,x			stz 	NSExponent,x
.087c	74 32		stz $32,x			stz 	NSStatus,x
.087e	80 af		bra $082f			bra 	NextCommand
.0880					PushWordCommand:
.0880	fa		plx				plx
.0881	e8		inx				inx
.0882	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.0884	c8		iny				iny
.0885	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0887	b1 28		lda ($28),y			lda 	(codePtr),y
.0889	c8		iny				iny
.088a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.088c	80 e8		bra $0876			bra 	ClearRestWord 				; handle everything else.
.088e					NXCommand:
.088e	c8		iny				iny 								; consume command.
.088f	10 03		bpl $0894			bpl 	_NXCommandNoFixUp
.0891	20 9a 08	jsr $089a			jsr 	FixUpY
.0894					_NXCommandNoFixUp:
.0894	0a		asl a				asl 	a 							; shift left
.0895	da		phx				phx 								; save SP on stack
.0896	aa		tax				tax				 					; and jump indirect
.0897	7c 5c 19	jmp ($195c,x)			jmp 	(VectorTable,x)
.089a					FixUpY:
.089a	48		pha				pha
.089b	98		tya				tya
.089c	18		clc				clc
.089d	65 28		adc $28				adc 	codePtr
.089f	85 28		sta $28				sta 	codePtr
.08a1	90 02		bcc $08a5			bcc 	_NoCPCarry
.08a3	e6 29		inc $29				inc 	codePtr+1
.08a5					_NoCPCarry:
.08a5	a0 00		ldy #$00			ldy 	#0
.08a7	68		pla				pla
.08a8	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.08a9					AbsoluteTOS:
.08a9	fa		plx				plx
.08aa	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08ac	4c 2f 08	jmp $082f			jmp 	NextCommand
.08af					CommandVarSpace:
.08af	fa		plx				plx
.08b0	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08b2	85 26		sta $26				sta 	availableMemory
.08b4	c8		iny				iny
.08b5	b1 28		lda ($28),y			lda 	(codePtr),y
.08b7	18		clc				clc
.08b8	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08bb	85 27		sta $27				sta 	availableMemory+1
.08bd	c8		iny				iny
.08be	4c 2f 08	jmp $082f			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08c1					BinaryAnd:
.08c1	fa		plx				plx
.08c2	38		sec				sec
.08c3	80 02		bra $08c7			bra 	AndOrCommon
.08c5					BinaryOr:
.08c5	fa		plx				plx
.08c6	18		clc				clc
.08c7					AndOrCommon:
.08c7	08		php				php 								; save AND/OR flag
.08c8	20 11 10	jsr $1011			jsr 	GetInteger16Bit
.08cb	ca		dex				dex
.08cc	20 11 10	jsr $1011			jsr 	GetInteger16Bit
.08cf	28		plp				plp
.08d0	90 0e		bcc $08e0			bcc 	_AOCOrCode
.08d2	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.08d4	35 3f		and $3f,x			and		NSMantissa0+1,x
.08d6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08d8	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.08da	35 4b		and $4b,x			and		NSMantissa1+1,x
.08dc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08de	80 0c		bra $08ec			bra 	_AOCComplete
.08e0					_AOCOrCode:
.08e0	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.08e2	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.08e4	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08e6	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.08e8	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.08ea	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08ec					_AOCComplete:
.08ec	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.08ee	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.08f0	10 07		bpl $08f9			bpl 	_AOCExit
.08f2	20 21 10	jsr $1021			jsr 	Negate16Bit 				; 2's complement
.08f5	a9 80		lda #$80			lda 	#$80 						; make it -ve
.08f7	95 32		sta $32,x			sta 	NSStatus,x
.08f9					_AOCExit:
.08f9	4c 2f 08	jmp $082f			jmp 	NextCommand
.08fc					ArrayConvert:
.08fc	fa		plx				plx
.08fd	5a		phy				phy
.08fe	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0900	85 2e		sta $2e				sta 	zTemp1
.0902	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0904	18		clc				clc
.0905	6d 07 04	adc $0407			adc 	variableStartPage
.0908	85 2f		sta $2f				sta 	zTemp1+1
.090a	ca		dex				dex 								; count of indices to follow -> zTemp2
.090b	20 0b 10	jsr $100b			jsr 	GetInteger8Bit
.090e	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.0910	8a		txa				txa
.0911	38		sec				sec
.0912	e5 30		sbc $30				sbc 	zTemp2
.0914	aa		tax				tax
.0915	da		phx				phx 								; stack points at the first index, which will be replaced.
.0916					_ACIndexLoop:
.0916	20 53 22	jsr $2253			jsr 	FloatIntegerPart 			; integer array index
.0919	20 11 10	jsr $1011			jsr 	GetInteger16Bit 			; get the index => zTemp0
.091c	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.091e	a5 2c		lda $2c				lda 	zTemp0
.0920	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0922	a5 2d		lda $2d				lda 	zTemp0+1
.0924	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0926	b0 79		bcs $09a1			bcs 	_ACBadIndex 				; index error.
.0928	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.092a	f0 29		beq $0955			beq 	_ACInnerLevel
.092c	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.092e	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0930	10 6f		bpl $09a1			bpl 	_ACBadIndex
.0932	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0934	26 2d		rol $2d				rol 	zTemp0+1
.0936	18		clc				clc
.0937	a5 2c		lda $2c				lda		zTemp0
.0939	65 2e		adc $2e				adc 	zTemp1
.093b	85 2c		sta $2c				sta 	zTemp0
.093d	a5 2d		lda $2d				lda		zTemp0+1
.093f	65 2f		adc $2f				adc 	zTemp1+1
.0941	85 2d		sta $2d				sta 	zTemp0+1
.0943	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.0945	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0947	85 2e		sta $2e				sta 	zTemp1
.0949	c8		iny				iny
.094a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.094c	18		clc				clc
.094d	6d 07 04	adc $0407			adc 	variableStartPage
.0950	85 2f		sta $2f				sta 	zTemp1+1
.0952	e8		inx				inx 								; next index
.0953	80 c1		bra $0916			bra 	_ACIndexLoop
.0955					_ACInnerLevel:
.0955	a0 02		ldy #$02			ldy 	#2
.0957	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0959	30 46		bmi $09a1			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.095b	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.095d	c9 00		cmp #$00			cmp 	#NSSIFloat
.095f	d0 13		bne $0974			bne 	_ACNotFloat
.0961	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.0963	48		pha				pha
.0964	a5 2c		lda $2c				lda 	zTemp0
.0966	06 2c		asl $2c				asl 	zTemp0 						; x 2
.0968	26 2d		rol $2d				rol 	zTemp0+1
.096a	18		clc				clc 								; add back x 3
.096b	65 2c		adc $2c				adc 	zTemp0
.096d	85 2c		sta $2c				sta 	zTemp0
.096f	68		pla				pla
.0970	65 2d		adc $2d				adc 	zTemp0+1
.0972	85 2d		sta $2d				sta 	zTemp0+1
.0974					_ACNotFloat:
.0974	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.0976	26 2d		rol $2d				rol 	zTemp0+1
.0978	18		clc				clc
.0979	a5 2c		lda $2c				lda 	zTemp0
.097b	69 03		adc #$03			adc 	#3
.097d	85 2c		sta $2c				sta 	zTemp0
.097f	90 02		bcc $0983			bcc 	_ACNoCarry
.0981	e6 2d		inc $2d				inc 	zTemp0+1
.0983					_ACNoCarry:
.0983	fa		plx				plx 								; X points to first slot of array parameters
.0984	18		clc				clc
.0985	a5 2c		lda $2c				lda 	zTemp0
.0987	65 2e		adc $2e				adc 	zTemp1
.0989	95 3e		sta $3e,x			sta 	NSMantissa0,x
.098b	a5 2d		lda $2d				lda 	zTemp0+1
.098d	65 2f		adc $2f				adc 	zTemp1+1
.098f	38		sec				sec
.0990	ed 07 04	sbc $0407			sbc 	variableStartPage
.0993	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0995	74 56		stz $56,x			stz 	NSMantissa2,x
.0997	74 62		stz $62,x			stz 	NSMantissa3,x
.0999	74 32		stz $32,x			stz 	NSStatus,x
.099b	74 6e		stz $6e,x			stz 	NSExponent,x
.099d	7a		ply				ply 	 							; restore code pointer
.099e	4c 2f 08	jmp $082f			jmp 	NextCommand
.09a1					_ACBadIndex:
.09a1	4c ad 1f	jmp $1fad		jmp	ErrorV_index
.09a4					UnaryAsc:
.09a4	fa		plx				plx
.09a5	5a		phy				phy
.09a6	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09a8	85 2c		sta $2c				sta 	zTemp0
.09aa	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09ac	85 2d		sta $2d				sta 	zTemp0+1
.09ae	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09b0	f0 06		beq $09b8			beq 	_UAExit
.09b2	5a		phy				phy 								; otherwise first character
.09b3	a0 01		ldy #$01			ldy 	#1
.09b5	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09b7	7a		ply				ply
.09b8					_UAExit:
.09b8	20 1a 26	jsr $261a			jsr 	FloatSetByte
.09bb	7a		ply				ply
.09bc	4c 2f 08	jmp $082f			jmp 	NextCommand
.09bf					CommandAssert:
.09bf	fa		plx				plx
.09c0	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09c2	d0 09		bne $09cd			bne 	_CAFail
.09c4	20 3a 26	jsr $263a			jsr 	FloatIsZero 				; is it zero ?
.09c7	f0 04		beq $09cd			beq 	_CAFail
.09c9	ca		dex				dex
.09ca	4c 2f 08	jmp $082f			jmp 	NextCommand
.09cd					_CAFail:
.09cd	4c 06 1f	jmp $1f06		jmp	ErrorV_assert
.09d0					X16_Audio_Parameters8_16:
.09d0	20 d6 09	jsr $09d6			jsr 	X16_Audio_Parameters8_8
.09d3	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.09d5	60		rts				rts
.09d6					X16_Audio_Parameters8_8:
.09d6	a2 01		ldx #$01			ldx 	#1
.09d8	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.09db	ca		dex				dex
.09dc	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.09df	20 0b 10	jsr $100b			jsr 	GetInteger8Bit
.09e2	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.09e4	a0 00		ldy #$00			ldy 	#0
.09e6	60		rts				rts
.09e7					X16_Audio_Parameters8_String:
.09e7	20 d0 09	jsr $09d0			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.09ea	da		phx				phx 								; set the voice
.09eb	5a		phy				phy
.09ec	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.09ef	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>09f2	0a						.byte 	X16_AudioCodeBank
.09f3	7a		ply				ply
.09f4	fa		plx				plx
.09f5	86 2c		stx $2c				stx 	zTemp0
.09f7	84 2d		sty $2d				sty 	zTemp0+1
.09f9	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.09fb	e8		inx				inx 								; point YX to first character.
.09fc	d0 01		bne $09ff			bne 	_X16APSSkip
.09fe	c8		iny				iny
.09ff					_X16APSSkip:
.09ff	60		rts				rts
.0a00					Unary16Bin:
.0a00	fa		plx				plx
.0a01	20 11 10	jsr $1011			jsr 	GetInteger16Bit				; 16 bit int
.0a04	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a06	20 db 16	jsr $16db			jsr 	StringAllocTemp
.0a09	a5 2d		lda $2d				lda 	zTemp0+1
.0a0b	f0 03		beq $0a10			beq 	_UBNoHigh
.0a0d	20 18 0a	jsr $0a18			jsr 	_UBWriteBinary
.0a10					_UBNoHigh:
.0a10	a5 2c		lda $2c				lda 	zTemp0
.0a12	20 18 0a	jsr $0a18			jsr 	_UBWriteBinary
.0a15	4c 2f 08	jmp $082f			jmp 	NextCommand
.0a18					_UBWriteBinary:
.0a18	5a		phy				phy
.0a19	a0 08		ldy #$08			ldy 	#8
.0a1b					_UBWLoop:
.0a1b	0a		asl a				asl 	a
.0a1c	48		pha				pha
.0a1d	a9 00		lda #$00			lda  	#0
.0a1f	69 30		adc #$30			adc 	#48
.0a21	20 04 17	jsr $1704			jsr 	StringWriteChar
.0a24	68		pla				pla
.0a25	88		dey				dey
.0a26	d0 f3		bne $0a1b			bne 	_UBWLoop
.0a28	7a		ply				ply
.0a29	60		rts				rts
.0a2a					PrintCharacterX:
.0a2a	fa		plx				plx
.0a2b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a2d	ca		dex				dex
.0a2e	20 38 13	jsr $1338			jsr 	VectorPrintCharacter
.0a31	4c 2f 08	jmp $082f			jmp 	NextCommand
.0a34					UnaryChr:
.0a34	fa		plx				plx
.0a35	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; get integer to convert.
.0a38	48		pha				pha 								; save it and allocate for it
.0a39	a9 01		lda #$01			lda 	#1 							; 1 character
.0a3b	20 db 16	jsr $16db			jsr 	StringAllocTemp
.0a3e	a9 01		lda #$01			lda 	#1 							; length 1.
.0a40	92 22		sta ($22)			sta 	(zsTemp)
.0a42	68		pla				pla 								; character code makes string.
.0a43	5a		phy				phy
.0a44	a0 01		ldy #$01			ldy 	#1
.0a46	91 22		sta ($22),y			sta 	(zsTemp),y
.0a48	7a		ply				ply
.0a49	4c 2f 08	jmp $082f			jmp 	NextCommand
.0a4c					CommandClr:
.0a4c	fa		plx				plx
.0a4d	20 53 0a	jsr $0a53			jsr 	ClearMemory
.0a50	4c 2f 08	jmp $082f			jmp 	NextCommand
.0a53					ClearMemory:
.0a53	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a56	85 2d		sta $2d				sta 	zTemp0+1
.0a58	64 2c		stz $2c				stz 	zTemp0
.0a5a	5a		phy				phy
.0a5b	a0 00		ldy #$00			ldy 	#0
.0a5d					_ClearLoop1:
.0a5d	a9 00		lda #$00			lda 	#0
.0a5f	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a61	c8		iny				iny
.0a62	d0 f9		bne $0a5d			bne 	_ClearLoop1
.0a64	e6 2d		inc $2d				inc 	zTemp0+1
.0a66	a5 2d		lda $2d				lda 	zTemp0+1
.0a68	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a6b	d0 f0		bne $0a5d			bne 	_ClearLoop1
.0a6d	38		sec				sec 											; stack space = number of pages in total / 4
.0a6e	ad 06 04	lda $0406			lda 	storeEndHigh
.0a71	ed 05 04	sbc $0405			sbc		storeStartHigh
.0a74	4a		lsr a				lsr 	a
.0a75	4a		lsr a				lsr 	a
.0a76	d0 02		bne $0a7a			bne 	_NotEmpty 								; at least 1 !
.0a78	a9 01		lda #$01			lda 	#1
.0a7a					_NotEmpty:
.0a7a	38		sec				sec 											; subtract from high to give string high memory
.0a7b	49 ff		eor #$ff			eor 	#$FF
.0a7d	6d 06 04	adc $0406			adc 	storeEndHigh
.0a80	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0a83	9c 02 04	stz $0402			stz 	stringHighMemory
.0a86	9c 68 05	stz $0568			stz 	stringInitialised 						; string system not initialised
.0a89	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0a8c	3a		dec a				dec 	a
.0a8d	85 25		sta $25				sta 	runtimeStackPtr+1
.0a8f	a9 ff		lda #$ff			lda 	#$FF
.0a91	85 24		sta $24				sta 	runtimeStackPtr
.0a93	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0a95	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0a97	7a		ply				ply
.0a98	60		rts				rts
.0a99					CompareStrings:
.0a99	fa		plx				plx
.0a9a	ca		dex				dex
.0a9b	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0a9d	85 2c		sta $2c				sta 	zTemp0
.0a9f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0aa1	85 2d		sta $2d				sta 	zTemp0+1
.0aa3	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0aa5	85 2e		sta $2e				sta 	zTemp1
.0aa7	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0aa9	85 2f		sta $2f				sta 	zTemp1+1
.0aab	da		phx				phx
.0aac	5a		phy				phy
.0aad	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0aaf	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0ab1	90 02		bcc $0ab5			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0ab3	b2 2e		lda ($2e)			lda 	(zTemp1)
.0ab5					_CSNIsSmallest:
.0ab5	aa		tax				tax 								; count in X
.0ab6	f0 0c		beq $0ac4			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0ab8	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0aba					_CSNCompareString:
.0aba	c8		iny				iny 								; pre increment
.0abb	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0abd	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0abf	d0 0a		bne $0acb			bne 	_CSNDifferent 				; numbers are different.
.0ac1	ca		dex				dex
.0ac2	d0 f6		bne $0aba			bne 	_CSNCompareString 			; compare common characters in two strings.
.0ac4					_CSNMatches:
.0ac4	38		sec				sec
.0ac5	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0ac7	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0ac9	f0 06		beq $0ad1			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0acb					_CSNDifferent:
.0acb	a9 ff		lda #$ff			lda 	#$FF
.0acd	90 02		bcc $0ad1			bcc 	_CSNSExit
.0acf	a9 01		lda #$01			lda 	#$01
.0ad1					_CSNSExit:
.0ad1	7a		ply				ply
.0ad2	fa		plx				plx
.0ad3	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0ad5	20 1a 26	jsr $261a			jsr 	FloatSetByte 				; output the byte
.0ad8	4c 2f 08	jmp $082f			jmp 	NextCommand
.0adb					StringConcrete:
.0adb	9c 68 05	stz $0568			stz 	stringInitialised	 		; initialise next usage
.0ade	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0ae0	85 30		sta $30				sta 	zTemp2
.0ae2	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0ae4	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0ae5	18		clc				clc
.0ae6	72 30		adc ($30)			adc 	(zTemp2)
.0ae8	90 02		bcc $0aec			bcc 	_SCNoOverflow
.0aea	a9 ff		lda #$ff			lda 	#255
.0aec					_SCNoOverflow:
.0aec	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0aee	b0 02		bcs $0af2			bcs 	_SCNoMinimum
.0af0	a9 0a		lda #$0a			lda 	#10
.0af2					_SCNoMinimum:
.0af2	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0af4	38		sec				sec
.0af5	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0af8	e5 2e		sbc $2e				sbc 	zTemp1
.0afa	a8		tay				tay
.0afb	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0afe	e9 00		sbc #$00			sbc 	#0
.0b00	48		pha				pha
.0b01	38		sec				sec 								; subtract 3 more
.0b02	98		tya				tya
.0b03	e9 03		sbc #$03			sbc 	#3
.0b05	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b08	85 22		sta $22				sta 	zsTemp
.0b0a	68		pla				pla
.0b0b	e9 00		sbc #$00			sbc 	#0
.0b0d	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b10	85 23		sta $23				sta 	zsTemp+1
.0b12	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b14	92 22		sta ($22)			sta 	(zsTemp)
.0b16	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b18	a9 00		lda #$00			lda 	#0
.0b1a	91 22		sta ($22),y			sta 	(zsTemp),y
.0b1c	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b1e	a4 23		ldy $23				ldy 	zsTemp+1
.0b20	60		rts				rts
.0b21					CommandXData:
.0b21	fa		plx				plx
.0b22	98		tya				tya 								; data length +1 added to Y
.0b23	38		sec				sec
.0b24	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b26	a8		tay				tay
.0b27	4c 2f 08	jmp $082f			jmp 	NextCommand
.0b2a					CommandXDIM:
.0b2a	fa		plx				plx
.0b2b	5a		phy				phy
.0b2c	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b2f	8d 08 04	sta $0408			sta 	dimType
.0b32	ca		dex				dex 								; this is the number of indices
.0b33	20 0b 10	jsr $100b			jsr 	GetInteger8Bit
.0b36	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b38	8a		txa				txa 								; dimension.
.0b39	38		sec				sec
.0b3a	e5 2e		sbc $2e				sbc 	zTemp1
.0b3c	aa		tax				tax
.0b3d	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b3f	20 53 0b	jsr $0b53			jsr 	DIMCreateOneLevel 			; create one at this level
.0b42	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b44	98		tya				tya
.0b45	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b47	74 56		stz $56,x			stz 	NSMantissa2,x
.0b49	74 62		stz $62,x			stz 	NSMantissa3,x
.0b4b	74 32		stz $32,x			stz 	NSStatus,x
.0b4d	74 6e		stz $6e,x			stz 	NSExponent,x
.0b4f	7a		ply				ply
.0b50	4c 2f 08	jmp $082f			jmp 	NextCommand
.0b53					DIMCreateOneLevel:
.0b53	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b55	5a		phy				phy
.0b56	a4 27		ldy $27				ldy 	availableMemory+1
.0b58	5a		phy				phy
.0b59	a8		tay				tay 			 					; save current level into Y
.0b5a	20 11 10	jsr $1011			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b5d	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b5f	d0 02		bne $0b63			bne 	_DCOLNoCarry
.0b61	e6 2d		inc $2d				inc 	zTemp0+1
.0b63					_DCOLNoCarry:
.0b63	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b65	20 06 0c	jsr $0c06			jsr 	DIMWriteByte
.0b68	a5 2d		lda $2d				lda 	zTemp0+1
.0b6a	20 06 0c	jsr $0c06			jsr 	DIMWriteByte
.0b6d	ad 08 04	lda $0408			lda 	dimType 					; get type information
.0b70	29 7f		and #$7f			and 	#$7F
.0b72	c0 01		cpy #$01			cpy 	#1
.0b74	f0 02		beq $0b78			beq 	_DCOLNoSubLevel
.0b76	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0b78					_DCOLNoSubLevel:
.0b78	20 06 0c	jsr $0c06			jsr 	DIMWriteByte
.0b7b	a5 26		lda $26				lda 	availableMemory
.0b7d	85 2e		sta $2e				sta 	zTemp1
.0b7f	a5 27		lda $27				lda 	availableMemory+1
.0b81	85 2f		sta $2f				sta 	zTemp1+1
.0b83	a5 2c		lda $2c				lda 	zTemp0
.0b85	85 30		sta $30				sta 	zTemp2
.0b87	a5 2d		lda $2d				lda 	zTemp0+1
.0b89	85 31		sta $31				sta 	zTemp2+1
.0b8b					_DCOLFillArray:
.0b8b	20 ea 0b	jsr $0bea			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0b8e	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0b90	d0 02		bne $0b94			bne 	_DCOLNoBorrow
.0b92	c6 2d		dec $2d				dec 	zTemp0+1
.0b94					_DCOLNoBorrow:
.0b94	c6 2c		dec $2c				dec 	zTemp0
.0b96	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0b98	05 2d		ora $2d				ora 	zTemp0+1
.0b9a	d0 ef		bne $0b8b			bne 	_DCOLFillArray
.0b9c	c0 01		cpy #$01			cpy 	#1
.0b9e	f0 42		beq $0be2			beq 	_DCOLExit
.0ba0					_DCOLRecursionLoop:
.0ba0	da		phx				phx 								; save XY
.0ba1	5a		phy				phy
.0ba2	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0ba4	48		pha				pha
.0ba5	a5 2f		lda $2f				lda 	zTemp1+1
.0ba7	48		pha				pha
.0ba8	a5 30		lda $30				lda 	zTemp2
.0baa	48		pha				pha
.0bab	a5 31		lda $31				lda 	zTemp2+1
.0bad	48		pha				pha
.0bae	88		dey				dey  								; lower level -> A
.0baf	98		tya				tya
.0bb0	e8		inx				inx 								; next index size
.0bb1	20 53 0b	jsr $0b53			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0bb4	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0bb5	86 31		stx $31				stx 	zTemp2+1
.0bb7	fa		plx				plx
.0bb8	86 30		stx $30				stx 	zTemp2
.0bba	fa		plx				plx
.0bbb	86 2f		stx $2f				stx 	zTemp1+1
.0bbd	fa		plx				plx
.0bbe	86 2e		stx $2e				stx 	zTemp1
.0bc0	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0bc2	98		tya				tya
.0bc3	a0 01		ldy #$01			ldy 	#1
.0bc5	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0bc7	7a		ply				ply 								; restore XY
.0bc8	fa		plx				plx
.0bc9	18		clc				clc
.0bca	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0bcc	69 02		adc #$02			adc 	#2
.0bce	85 2e		sta $2e				sta 	zTemp1
.0bd0	90 02		bcc $0bd4			bcc 	_DCOLRNoCarry
.0bd2	e6 2f		inc $2f				inc 	zTemp1+1
.0bd4					_DCOLRNoCarry:
.0bd4	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0bd6	d0 02		bne $0bda			bne 	_DCOLRNoBorrow
.0bd8	c6 31		dec $31				dec 	zTemp2+1
.0bda					_DCOLRNoBorrow:
.0bda	c6 30		dec $30				dec 	zTemp2
.0bdc	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0bde	05 31		ora $31				ora 	zTemp2+1
.0be0	d0 be		bne $0ba0			bne 	_DCOLRecursionLoop
.0be2					_DCOLExit:
.0be2	68		pla				pla 								; get MSB, make offset again
.0be3	38		sec				sec
.0be4	ed 07 04	sbc $0407			sbc 	variableStartPage
.0be7	a8		tay				tay
.0be8	68		pla				pla 								; YA now contains offset address.
.0be9	60		rts				rts
.0bea					DIMWriteElement:
.0bea	da		phx				phx
.0beb	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0bed	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0bef	d0 0b		bne $0bfc			bne 	_DIMWENotFloat
.0bf1	ad 08 04	lda $0408			lda 	dimType
.0bf4	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0bf6	c9 00		cmp #$00			cmp 	#NSSIFloat
.0bf8	d0 02		bne $0bfc			bne 	_DIMWENotFloat
.0bfa	a2 06		ldx #$06			ldx 	#6
.0bfc					_DIMWENotFloat:
.0bfc	a9 00		lda #$00			lda 	#0
.0bfe	20 06 0c	jsr $0c06			jsr 	DIMWriteByte
.0c01	ca		dex				dex
.0c02	d0 f8		bne $0bfc			bne 	_DIMWENotFloat
.0c04	fa		plx				plx
.0c05	60		rts				rts
.0c06					DIMWriteByte:
.0c06	92 26		sta ($26)			sta 	(availableMemory)
.0c08	e6 26		inc $26				inc 	availableMemory
.0c0a	d0 0b		bne $0c17			bne 	_DIMWBSkip
.0c0c	e6 27		inc $27				inc 	availableMemory+1
.0c0e	48		pha				pha
.0c0f	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c11	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c14	b0 02		bcs $0c18			bcs 	_DIMWBMemory
.0c16	68		pla				pla
.0c17					_DIMWBSkip:
.0c17	60		rts				rts
.0c18					_DIMWBMemory:
.0c18	4c c0 1f	jmp $1fc0		jmp	ErrorV_memory
.0408					dimType:
>0408							.fill 	1
.0c1b					CommandEnd:
.0c1b	fa		plx				plx
.0c1c	86 2c		stx $2c				stx 	zTemp0
.0c1e	4c ff ff	jmp $ffff			jmp 	$FFFF
.0c21					Unimplemented:
.0c21	4c f3 1e	jmp $1ef3			jmp 	ErrorV_unimplemented
.0c24					RuntimeErrorHandler:
.0c24	98		tya				tya
.0c25	18		clc				clc
.0c26	65 28		adc $28				adc 	codePtr
.0c28	85 28		sta $28				sta 	codePtr
.0c2a	90 02		bcc $0c2e			bcc 	_EHNoCarry
.0c2c	e6 29		inc $29				inc 	codePtr+1
.0c2e					_EHNoCarry:
.0c2e	68		pla				pla
.0c2f	7a		ply				ply
.0c30	85 2c		sta $2c				sta 	zTemp0
.0c32	84 2d		sty $2d				sty 	zTemp0+1
.0c34	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c36	a0 01		ldy #$01			ldy 	#1
.0c38					_EHDisplayMsg:
.0c38	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c3a	20 50 1c	jsr $1c50			jsr 	XPrintCharacterToChannel
.0c3d	c8		iny				iny
.0c3e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c40	d0 f6		bne $0c38			bne 	_EHDisplayMsg
.0c42	a9 20		lda #$20			lda 	#32
.0c44	20 50 1c	jsr $1c50			jsr 	XPrintCharacterToChannel
.0c47	a9 40		lda #$40			lda 	#64
.0c49	20 50 1c	jsr $1c50			jsr 	XPrintCharacterToChannel
.0c4c	a9 20		lda #$20			lda 	#32
.0c4e	20 50 1c	jsr $1c50			jsr 	XPrintCharacterToChannel
.0c51	20 56 0c	jsr $0c56			jsr 	EHDisplayCodePtr
.0c54	80 fe		bra $0c54	_EHStop:bra 	_EHStop
.0c56					EHDisplayCodePtr:
.0c56	a9 24		lda #$24			lda 	#'$'
.0c58	20 50 1c	jsr $1c50			jsr 	XPrintCharacterToChannel
.0c5b	38		sec				sec
.0c5c	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c5e	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c61	20 6a 0c	jsr $0c6a			jsr 	_EHDisplayHex
.0c64	a5 28		lda $28				lda 	codePtr
.0c66	20 6a 0c	jsr $0c6a			jsr 	_EHDisplayHex
.0c69	60		rts				rts
.0c6a					_EHDisplayHex:
.0c6a	48		pha				pha
.0c6b	4a		lsr a				lsr 	a
.0c6c	4a		lsr a				lsr 	a
.0c6d	4a		lsr a				lsr 	a
.0c6e	4a		lsr a				lsr 	a
.0c6f	20 73 0c	jsr $0c73			jsr 	_EHDisplayNibble
.0c72	68		pla				pla
.0c73					_EHDisplayNibble:
.0c73	29 0f		and #$0f			and 	#15
.0c75	c9 0a		cmp #$0a			cmp 	#10
.0c77	90 02		bcc $0c7b			bcc 	_EHNotHex
.0c79	69 06		adc #$06			adc 	#6
.0c7b					_EHNotHex:
.0c7b	69 30		adc #$30			adc 	#48
.0c7d	4c 50 1c	jmp $1c50			jmp 	XPrintCharacterToChannel
.0c80					CommandXFor:
.0c80	fa		plx				plx
.0c81	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0c83	20 03 0d	jsr $0d03			jsr 	StackOpenFrame
.0c86	20 42 11	jsr $1142			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0c89	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0c8b	20 e5 0c	jsr $0ce5			jsr 	CopyTOSToOffsetY
.0c8e	ca		dex				dex
.0c8f	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0c91	20 e5 0c	jsr $0ce5			jsr 	CopyTOSToOffsetY
.0c94	ca		dex				dex
.0c95	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0c97	29 80		and #$80			and 	#$80
.0c99	a0 04		ldy #$04			ldy 	#4
.0c9b	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0c9d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0c9f	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0ca1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ca3	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0ca5	c8		iny				iny
.0ca6	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ca8	18		clc				clc
.0ca9	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0cab	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cad	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0cb0	85 2d		sta $2d				sta 	zTemp0+1
.0cb2	ca		dex				dex 								; throw reference.
.0cb3	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0cb5	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0cb7	a0 0c		ldy #$0c			ldy 	#12
.0cb9	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cbb	a0 12		ldy #$12			ldy 	#18
.0cbd	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cbf	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0cc1	88		dey				dey 								; now the exponents.
.0cc2	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0cc4	a0 0b		ldy #$0b			ldy 	#11
.0cc6	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cc8	a0 11		ldy #$11			ldy 	#17
.0cca	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0ccc	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0cce	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cd0	c8		iny				iny
.0cd1	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cd3	c8		iny				iny
.0cd4	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cd6	d0 08		bne $0ce0			bne 	_CFNoOptimise
.0cd8	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0cda	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0cdc	09 40		ora #$40			ora 	#$40
.0cde	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ce0					_CFNoOptimise:
.0ce0	a0 00		ldy #$00			ldy 	#0
.0ce2	4c 2f 08	jmp $082f			jmp 	NextCommand
.0ce5					CopyTOSToOffsetY:
.0ce5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0ce7	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ce9	c8		iny				iny
.0cea	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cec	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cee	c8		iny				iny
.0cef	b5 56		lda $56,x			lda 	NSMantissa2,x
.0cf1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cf3	c8		iny				iny
.0cf4	b5 62		lda $62,x			lda 	NSMantissa3,x
.0cf6	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cf8	c8		iny				iny
.0cf9	b5 6e		lda $6e,x			lda 	NSExponent,x
.0cfb	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cfd	c8		iny				iny
.0cfe	b5 32		lda $32,x			lda 	NSStatus,x
.0d00	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d02	60		rts				rts
.0d03					StackOpenFrame:
.0d03	48		pha				pha 								; save frame marker
.0d04	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d06	85 2c		sta $2c				sta 	zTemp0
.0d08	38		sec				sec 								; subtract from runtime stack pointer.
.0d09	a5 24		lda $24				lda		runtimeStackPtr
.0d0b	e5 2c		sbc $2c				sbc 	zTemp0
.0d0d	85 24		sta $24				sta 	runtimeStackPtr
.0d0f	a5 25		lda $25				lda		runtimeStackPtr+1
.0d11	e9 00		sbc #$00			sbc 	#0
.0d13	85 25		sta $25				sta 	runtimeStackPtr+1
.0d15	68		pla				pla 								; put frame marker at +0
.0d16	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d18	60		rts				rts
.0d19					StackCloseFrame:
.0d19	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d1b	29 1f		and #$1f			and 	#$1F 						; size
.0d1d	18		clc				clc
.0d1e	65 24		adc $24				adc 	runtimeStackPtr
.0d20	85 24		sta $24				sta 	runtimeStackPtr
.0d22	90 02		bcc $0d26			bcc 	_SCFNoCarry
.0d24	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d26					_SCFNoCarry:
.0d26	60		rts				rts
.0d27					StackFindFrame:
.0d27	8d 09 04	sta $0409			sta 	requiredFrame
.0d2a					_SFFLoop:
.0d2a	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d2c	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d2e	f0 10		beq $0d40			beq 	SCFFail
.0d30	cd 09 04	cmp $0409			cmp 	requiredFrame 				; found this type ?
.0d33	f0 05		beq $0d3a			beq 	_SFFFound
.0d35	20 19 0d	jsr $0d19			jsr 	StackCloseFrame 			; close the top frame
.0d38	80 f0		bra $0d2a			bra 	_SFFLoop 					; and try te next.
.0d3a					_SFFFound:
.0d3a	60		rts				rts
.0d3b					StackCheckFrame:
.0d3b	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d3d	d0 01		bne $0d40			bne 	SCFFail
.0d3f	60		rts				rts
.0d40					SCFFail:
.0d40	4c 50 1f	jmp $1f50		jmp	ErrorV_structure
.0409					requiredFrame:
>0409							.fill 	1
.0d43					UnaryFre:
.0d43	fa		plx				plx
.0d44	20 18 26	jsr $2618			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d47	38		sec				sec
.0d48	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d4b	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d4e	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d50	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d53	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d56	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d58	4c 2f 08	jmp $082f			jmp 	NextCommand
.0d5b					CommandXGet:
.0d5b	fa		plx				plx
.0d5c	e8		inx				inx
.0d5d	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d5f	20 db 16	jsr $16db			jsr 	StringAllocTemp
.0d62	20 41 13	jsr $1341			jsr 	VectorGetCharacter 			; get a character
.0d65	c9 00		cmp #$00			cmp 	#0
.0d67	f0 09		beq $0d72			beq 	_CGNone
.0d69	5a		phy				phy
.0d6a	a0 01		ldy #$01			ldy 	#1 							; store char
.0d6c	91 22		sta ($22),y			sta 	(zsTemp),y
.0d6e	98		tya				tya 								; store length.
.0d6f	92 22		sta ($22)			sta 	(zsTemp)
.0d71	7a		ply				ply
.0d72					_CGNone:
.0d72	4c 2f 08	jmp $082f			jmp 	NextCommand
.0d75					CommandXGosub:
.0d75	fa		plx				plx
.0d76	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0d78	20 03 0d	jsr $0d03			jsr 	StackOpenFrame
.0d7b	20 42 11	jsr $1142			jsr 	StackSaveCurrentPosition
.0d7e	4c 93 0d	jmp $0d93			jmp 	PerformGOTO
.0d81					CommandReturn:
.0d81	fa		plx				plx
.0d82	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0d84	20 27 0d	jsr $0d27			jsr 	StackFindFrame
.0d87	20 53 11	jsr $1153			jsr 	StackLoadCurrentPosition
.0d8a	c8		iny				iny
.0d8b	c8		iny				iny
.0d8c	20 19 0d	jsr $0d19			jsr 	StackCloseFrame
.0d8f	4c 2f 08	jmp $082f			jmp 	NextCommand
.0d92					CommandXGoto:
.0d92	fa		plx				plx
.0d93					PerformGOTO:
.0d93	c8		iny				iny 								; push MSB of offset on stack
.0d94	b1 28		lda ($28),y			lda 	(codePtr),y
.0d96	48		pha				pha
.0d97	88		dey				dey 								; point LSB of offset
.0d98	18		clc				clc 								; add LSB
.0d99	b1 28		lda ($28),y			lda 	(codePtr),y
.0d9b	65 28		adc $28				adc 	codePtr
.0d9d	85 28		sta $28				sta 	codePtr
.0d9f	68		pla				pla 								; restore offset MSB and add
.0da0	65 29		adc $29				adc 	codePtr+1
.0da2	85 29		sta $29				sta 	codePtr+1
.0da4	4c 2f 08	jmp $082f			jmp 	NextCommand
.0da7					CommandGotoZ:
.0da7	fa		plx				plx
.0da8	20 3a 26	jsr $263a			jsr 	FloatIsZero
.0dab	ca		dex				dex
.0dac	c9 00		cmp #$00			cmp 	#0
.0dae	f0 e3		beq $0d93			beq 	PerformGOTO
.0db0	c8		iny				iny
.0db1	c8		iny				iny
.0db2	4c 2f 08	jmp $082f			jmp 	NextCommand
.0db5					CommandGotoNZ:
.0db5	fa		plx				plx
.0db6	20 3a 26	jsr $263a			jsr 	FloatIsZero
.0db9	ca		dex				dex
.0dba	c9 00		cmp #$00			cmp 	#0
.0dbc	d0 d5		bne $0d93			bne 	PerformGOTO
.0dbe	c8		iny				iny
.0dbf	c8		iny				iny
.0dc0	4c 2f 08	jmp $082f			jmp 	NextCommand
.0dc3					Command_PSET:
.0dc3	fa		plx				plx
.0dc4	5a		phy				phy
.0dc5	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; get the colour
.0dc8	48		pha				pha
.0dc9	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0dcb	a0 02		ldy #$02			ldy 	#X16_r0
.0dcd	20 4f 0e	jsr $0e4f			jsr 	GraphicsCopy2
.0dd0	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0dd3	68		pla				pla 								; set pixel.
.0dd4	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0dd7	7a		ply				ply
.0dd8	a2 ff		ldx #$ff			ldx 	#$FF
.0dda	4c 2f 08	jmp $082f			jmp 	NextCommand
.0ddd					Command_LINE:
.0ddd	fa		plx				plx
.0dde	5a		phy				phy
.0ddf	20 42 0e	jsr $0e42			jsr 	GraphicsColour
.0de2	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0de4	a0 02		ldy #$02			ldy 	#X16_r0
.0de6	20 4c 0e	jsr $0e4c			jsr 	GraphicsCopy4
.0de9	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0dec	7a		ply				ply
.0ded	a2 ff		ldx #$ff			ldx 	#$FF
.0def	4c 2f 08	jmp $082f			jmp 	NextCommand
.0df2					Command_RECT:
.0df2	fa		plx				plx
.0df3	5a		phy				phy
.0df4	20 63 0e	jsr $0e63			jsr 	GraphicsRectCoords
.0df7	38		sec				sec
.0df8	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0dfb	7a		ply				ply
.0dfc	a2 ff		ldx #$ff			ldx 	#$FF
.0dfe	4c 2f 08	jmp $082f			jmp 	NextCommand
.0e01					Command_FRAME:
.0e01	fa		plx				plx
.0e02	5a		phy				phy
.0e03	20 63 0e	jsr $0e63			jsr 	GraphicsRectCoords
.0e06	18		clc				clc
.0e07	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e0a	7a		ply				ply
.0e0b	a2 ff		ldx #$ff			ldx 	#$FF
.0e0d	4c 2f 08	jmp $082f			jmp 	NextCommand
.0e10					Command_CHAR:
.0e10	fa		plx				plx
.0e11	5a		phy				phy
.0e12	ca		dex				dex  								; set the draw colour
.0e13	20 42 0e	jsr $0e42			jsr 	GraphicsColour
.0e16	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e18	a0 02		ldy #$02			ldy 	#X16_r0
.0e1a	20 4f 0e	jsr $0e4f			jsr 	GraphicsCopy2
.0e1d	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e1f	85 2c		sta $2c				sta 	zTemp0
.0e21	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e23	85 2d		sta $2d				sta 	zTemp0+1
.0e25	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e27	85 2e		sta $2e				sta 	zTemp1
.0e29					_CCLoop:
.0e29	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e2b	f0 0f		beq $0e3c			beq 	_CCExit
.0e2d	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e2f	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e31	d0 02		bne $0e35			bne 	_CCNoCarry
.0e33	e6 2d		inc $2d				inc 	zTemp0+1
.0e35					_CCNoCarry:
.0e35	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e37	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e3a	80 ed		bra $0e29			bra 	_CCLoop						; go round.
.0e3c					_CCExit:
.0e3c	7a		ply				ply
.0e3d	a2 ff		ldx #$ff			ldx 	#$FF
.0e3f	4c 2f 08	jmp $082f			jmp 	NextCommand
.0e42					GraphicsColour:
.0e42	20 0b 10	jsr $100b			jsr 	GetInteger8Bit
.0e45	aa		tax				tax
.0e46	a0 00		ldy #$00			ldy 	#0
.0e48	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e4b	60		rts				rts
.0e4c					GraphicsCopy4:
.0e4c	20 4f 0e	jsr $0e4f			jsr 	GraphicsCopy2
.0e4f					GraphicsCopy2:
.0e4f	20 52 0e	jsr $0e52			jsr 	GraphicsCopy1
.0e52					GraphicsCopy1:
.0e52	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.0e55	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e57	99 00 00	sta $0000,y			sta 	0,y
.0e5a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e5c	99 01 00	sta $0001,y			sta 	1,y
.0e5f	e8		inx				inx
.0e60	c8		iny				iny
.0e61	c8		iny				iny
.0e62	60		rts				rts
.0e63					GraphicsRectCoords:
.0e63	20 42 0e	jsr $0e42			jsr 	GraphicsColour 				; set colour
.0e66	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e68	a0 02		ldy #$02			ldy 	#X16_r0
.0e6a	20 4c 0e	jsr $0e4c			jsr 	GraphicsCopy4
.0e6d	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0e6f	20 7c 0e	jsr $0e7c			jsr 	_GRCSortSubtract
.0e72	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0e74	20 7c 0e	jsr $0e7c			jsr 	_GRCSortSubtract
.0e77	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0e79	74 09		stz $09,x			stz 	9,x
.0e7b	60		rts				rts
.0e7c					_GRCSortSubtract:
.0e7c	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0e7e	d5 00		cmp $00,x			cmp 	0,x
.0e80	b5 05		lda $05,x			lda 	5,x
.0e82	f5 01		sbc $01,x			sbc 	1,x
.0e84	b0 08		bcs $0e8e			bcs 	_GRCNoSwap 					; >= swap.
.0e86	20 9c 0e	jsr $0e9c			jsr 	_GRCSwapByte 				; swap 0/2
.0e89	e8		inx				inx
.0e8a	20 9c 0e	jsr $0e9c			jsr 	_GRCSwapByte 				; swap 1/3
.0e8d	ca		dex				dex
.0e8e					_GRCNoSwap:
.0e8e	38		sec				sec 								; calculate width/height into 4,5
.0e8f	b5 04		lda $04,x			lda 	4,x
.0e91	f5 00		sbc $00,x			sbc 	0,x
.0e93	95 04		sta $04,x			sta 	4,x
.0e95	b5 05		lda $05,x			lda 	5,x
.0e97	f5 01		sbc $01,x			sbc 	1,x
.0e99	95 05		sta $05,x			sta 	5,x
.0e9b	60		rts				rts
.0e9c					_GRCSwapByte:
.0e9c	b5 04		lda $04,x			lda 	4,x
.0e9e	48		pha				pha
.0e9f	b5 00		lda $00,x			lda 	0,x
.0ea1	95 04		sta $04,x			sta 	4,x
.0ea3	68		pla				pla
.0ea4	95 00		sta $00,x			sta 	0,x
.0ea6	60		rts				rts
.0ea7					Unary16Hex:
.0ea7	fa		plx				plx
.0ea8	20 11 10	jsr $1011			jsr 	GetInteger16Bit
.0eab	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0ead	20 db 16	jsr $16db			jsr 	StringAllocTemp
.0eb0	a5 2d		lda $2d				lda 	zTemp0+1
.0eb2	f0 03		beq $0eb7			beq 	_UHNoHigh
.0eb4	20 bf 0e	jsr $0ebf			jsr 	_UHWriteHex
.0eb7					_UHNoHigh:
.0eb7	a5 2c		lda $2c				lda 	zTemp0
.0eb9	20 bf 0e	jsr $0ebf			jsr 	_UHWriteHex
.0ebc	4c 2f 08	jmp $082f			jmp 	NextCommand
.0ebf					_UHWriteHex:
.0ebf	48		pha				pha
.0ec0	4a		lsr a				lsr 	a
.0ec1	4a		lsr a				lsr 	a
.0ec2	4a		lsr a				lsr 	a
.0ec3	4a		lsr a				lsr 	a
.0ec4	20 c8 0e	jsr $0ec8			jsr 	_UHWriteNibl
.0ec7	68		pla				pla
.0ec8					_UHWriteNibl:
.0ec8	29 0f		and #$0f			and 	#15
.0eca	c9 0a		cmp #$0a			cmp 	#10
.0ecc	90 02		bcc $0ed0			bcc 	_UHDigit
.0ece	69 06		adc #$06			adc 	#6
.0ed0					_UHDigit:
.0ed0	69 30		adc #$30			adc 	#48
.0ed2	20 04 17	jsr $1704			jsr 	StringWriteChar
.0ed5	60		rts				rts
.0ed6					IndFloatRead:
.0ed6	fa		plx				plx
.0ed7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0ed9	85 2c		sta $2c				sta 	zTemp0
.0edb	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0edd	18		clc				clc
.0ede	6d 07 04	adc $0407			adc 	variableStartPage
.0ee1	85 2d		sta $2d				sta 	zTemp0+1
.0ee3	ca		dex				dex 								; throw the address
.0ee4	20 ba 14	jsr $14ba			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0ee7	4c 2f 08	jmp $082f			jmp 	NextCommand
.0eea					IndInt16Read:
.0eea	fa		plx				plx
.0eeb	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0eed	85 2c		sta $2c				sta 	zTemp0
.0eef	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ef1	18		clc				clc
.0ef2	6d 07 04	adc $0407			adc 	variableStartPage
.0ef5	85 2d		sta $2d				sta 	zTemp0+1
.0ef7	ca		dex				dex 								; throw the address
.0ef8	20 f6 14	jsr $14f6			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0efb	4c 2f 08	jmp $082f			jmp 	NextCommand
.0efe					IndStringRead:
.0efe	fa		plx				plx
.0eff	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f01	85 2c		sta $2c				sta 	zTemp0
.0f03	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f05	18		clc				clc
.0f06	6d 07 04	adc $0407			adc 	variableStartPage
.0f09	85 2d		sta $2d				sta 	zTemp0+1
.0f0b	ca		dex				dex 								; throw the address
.0f0c	20 3b 15	jsr $153b			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f0f	4c 2f 08	jmp $082f			jmp 	NextCommand
.0f12					IndFloatWrite:
.0f12	fa		plx				plx
.0f13	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f15	85 2c		sta $2c				sta 	zTemp0
.0f17	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f19	18		clc				clc
.0f1a	6d 07 04	adc $0407			adc 	variableStartPage
.0f1d	85 2d		sta $2d				sta 	zTemp0+1
.0f1f	20 95 1a	jsr $1a95			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f22	ca		dex				dex 								; throw the address as well.
.0f23	4c 2f 08	jmp $082f			jmp 	NextCommand
.0f26					IndInt16Write:
.0f26	fa		plx				plx
.0f27	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f29	85 2c		sta $2c				sta 	zTemp0
.0f2b	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f2d	18		clc				clc
.0f2e	6d 07 04	adc $0407			adc 	variableStartPage
.0f31	85 2d		sta $2d				sta 	zTemp0+1
.0f33	20 d1 1a	jsr $1ad1			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f36	ca		dex				dex 								; throw the address as well.
.0f37	4c 2f 08	jmp $082f			jmp 	NextCommand
.0f3a					IndStringWrite:
.0f3a	fa		plx				plx
.0f3b	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f3d	85 2c		sta $2c				sta 	zTemp0
.0f3f	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f41	18		clc				clc
.0f42	6d 07 04	adc $0407			adc 	variableStartPage
.0f45	85 2d		sta $2d				sta 	zTemp0+1
.0f47	20 10 1b	jsr $1b10			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f4a	ca		dex				dex 								; throw the address as well.
.0f4b	4c 2f 08	jmp $082f			jmp 	NextCommand
.0f4e					CommandXInput:
.0f4e	fa		plx				plx
.0f4f	5a		phy				phy 								; save Y
.0f50	e8		inx				inx									; space on stack
.0f51					_INError:
.0f51	20 85 0f	jsr $0f85			jsr 	InputStringToBuffer 		; input from keyboard
.0f54	a9 5f		lda #$5f			lda 	#((ReadBufferSize) & $FF)
.0f56	85 2c		sta $2c				sta 	0+zTemp0
.0f58	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f5a	85 2d		sta $2d				sta 	1+zTemp0
.0f5c	20 22 19	jsr $1922			jsr 	ValEvaluateZTemp0
.0f5f	b0 f0		bcs $0f51			bcs 	_INError 					; failed, try again.
.0f61	7a		ply				ply 								; restore Y
.0f62	4c 2f 08	jmp $082f			jmp 	NextCommand
.0f65					CommandInputString:
.0f65	fa		plx				plx
.0f66	5a		phy				phy 								; save Y
.0f67	20 85 0f	jsr $0f85			jsr 	InputStringToBuffer 		; input from keyboard
.0f6a	e8		inx				inx 								; make space on stack
.0f6b	20 18 26	jsr $2618			jsr 	FloatSetZero 				; store as string on stack
.0f6e	a9 5f		lda #$5f			lda 	#ReadBufferSize & $FF
.0f70	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0f72	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0f74	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0f76	a9 40		lda #$40			lda 	#NSSString
.0f78	95 32		sta $32,x			sta 	NSStatus,x
.0f7a	7a		ply				ply 								; restore Y
.0f7b	4c 2f 08	jmp $082f			jmp 	NextCommand
.0f7e					CommandInputReset:
.0f7e	fa		plx				plx
.0f7f	9c 0a 04	stz $040a			stz 	InputBuffer
.0f82	4c 2f 08	jmp $082f			jmp 	NextCommand
.0f85					InputStringToBuffer:
.0f85	a9 bf		lda #$bf			lda 	#((InputBumpNext) & $FF)
.0f87	8d 5f 05	sta $055f			sta 	0+ReadBumpNextVec
.0f8a	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0f8c	8d 60 05	sta $0560			sta 	1+ReadBumpNextVec
.0f8f	a9 9c		lda #$9c			lda 	#((InputLookNext) & $FF)
.0f91	8d 61 05	sta $0561			sta 	0+ReadLookNextVec
.0f94	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0f96	8d 62 05	sta $0562			sta 	1+ReadLookNextVec
.0f99	4c 17 14	jmp $1417			jmp 	GetStringToBuffer
.0f9c					InputLookNext:
.0f9c	da		phx				phx
.0f9d					_ILNRetry:
.0f9d	ad 0a 04	lda $040a			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fa0	d0 08		bne $0faa			bne 	_ILNNotEmpty
.0fa2	20 c3 0f	jsr $0fc3			jsr 	InputGetNewLine 			; get a new line
.0fa5	9c 5b 04	stz $045b			stz 	InputBufferPos 				; reset read position.
.0fa8	80 f3		bra $0f9d			bra 	_ILNRetry
.0faa					_ILNNotEmpty:
.0faa	ae 5b 04	ldx $045b			ldx 	InputBufferPos 				; get head available character
.0fad	bd 0a 04	lda $040a,x			lda 	InputBuffer,x
.0fb0	d0 08		bne $0fba			bne 	_ILNExit 					; if not EOS return it with CC.
.0fb2					_ILNNextLine:
.0fb2	9c 0a 04	stz $040a			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0fb5	38		sec				sec 								; return CS,Zero
.0fb6	fa		plx				plx
.0fb7	a9 0d		lda #$0d			lda 	#13
.0fb9	60		rts				rts
.0fba					_ILNExit:
.0fba	fa		plx				plx
.0fbb	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0fbd	18		clc				clc
.0fbe	60		rts				rts
.0fbf					InputBumpNext:
.0fbf	ee 5b 04	inc $045b			inc 	InputBufferPos
.0fc2	60		rts				rts
.0fc3					InputGetNewLine:
.0fc3	48		pha				pha
.0fc4	da		phx				phx
.0fc5	5a		phy				phy
.0fc6	a9 3f		lda #$3f			lda 	#"?"
.0fc8	20 02 10	jsr $1002			jsr 	IGNLEchoIfScreen
.0fcb	a0 00		ldy #$00			ldy 	#0 							; line position.
.0fcd					_IGNLLoop:
.0fcd	20 41 13	jsr $1341			jsr 	VectorGetCharacter 			; get a character
.0fd0	c9 00		cmp #$00			cmp 	#0
.0fd2	f0 f9		beq $0fcd			beq 	_IGNLLoop
.0fd4	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.0fd6	f0 11		beq $0fe9			beq 	_IGNBackspace
.0fd8	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.0fda	f0 17		beq $0ff3			beq 	_IGNExit
.0fdc	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.0fde	f0 ed		beq $0fcd			beq 	_IGNLLoop
.0fe0	99 0a 04	sta $040a,y			sta 	InputBuffer,y
.0fe3	c8		iny				iny
.0fe4	20 02 10	jsr $1002			jsr 	IGNLEchoIfScreen
.0fe7	80 e4		bra $0fcd			bra 	_IGNLLoop
.0fe9					_IGNBackspace:
.0fe9	c0 00		cpy #$00			cpy 	#0
.0feb	f0 e0		beq $0fcd			beq 	_IGNLLoop
.0fed	20 02 10	jsr $1002			jsr 	IGNLEchoIfScreen
.0ff0	88		dey				dey
.0ff1	80 da		bra $0fcd			bra 	_IGNLLoop
.0ff3					_IGNExit:
.0ff3	20 02 10	jsr $1002			jsr 	IGNLEchoIfScreen
.0ff6	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.0ff8	99 0a 04	sta $040a,y			sta 	InputBuffer,y
.0ffb	9c 5b 04	stz $045b			stz 	InputBufferPos 				; reset position to start of input buffer.
.0ffe	7a		ply				ply
.0fff	fa		plx				plx
.1000	68		pla				pla
.1001	60		rts				rts
.1002					IGNLEchoIfScreen:
.1002	ae 5d 04	ldx $045d			ldx 	currentChannel
.1005	d0 03		bne $100a			bne 	_IGNLEExit
.1007	20 38 13	jsr $1338			jsr 	VectorPrintCharacter
.100a					_IGNLEExit:
.100a	60		rts				rts
.040a					InputBuffer:
>040a							.fill 	81
.045b					InputBufferPos:
>045b							.fill 	1
.100b					GetInteger8Bit:
.100b	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.100e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1010	60		rts				rts
.1011					GetInteger16Bit:
.1011	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.1014	34 32		bit $32,x			bit 	NSStatus,x
.1016	30 09		bmi $1021			bmi 	Negate16Bit
.1018	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.101a	85 2c		sta $2c				sta 	zTemp0
.101c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.101e	85 2d		sta $2d				sta 	zTemp0+1
.1020	60		rts				rts
.1021					Negate16Bit:
.1021	38		sec				sec
.1022	a9 00		lda #$00			lda 	#0
.1024	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1026	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1028	85 2c		sta $2c				sta 	zTemp0
.102a	a9 00		lda #$00			lda 	#0
.102c	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.102e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1030	85 2d		sta $2d				sta 	zTemp0+1
.1032	60		rts				rts
.1033					UnaryJoy:
.1033	fa		plx				plx
.1034	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; port #
.1037	48		pha				pha 								; zero the result.
.1038	20 18 26	jsr $2618			jsr 	FloatSetZero
.103b	68		pla				pla
.103c	5a		phy				phy
.103d	da		phx				phx
.103e	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1041	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1043	d0 10		bne $1055			bne 	_UJNoHardware
.1045	a8		tay				tay 								; move XA -> AY
.1046	8a		txa				txa
.1047	fa		plx				plx 								; we can update it now.
.1048	49 ff		eor #$ff			eor 	#$FF
.104a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.104c	98		tya				tya
.104d	49 ff		eor #$ff			eor 	#$FF
.104f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1051	7a		ply				ply 								; restore Y
.1052	4c 2f 08	jmp $082f			jmp 	NextCommand
.1055					_UJNoHardware:
.1055	fa		plx				plx
.1056	7a		ply				ply
.1057	a9 01		lda #$01			lda 	#1 							; set result to -1
.1059	20 1a 26	jsr $261a			jsr 	FloatSetByte
.105c	20 da 25	jsr $25da			jsr 	FloatNegate
.105f	4c 2f 08	jmp $082f			jmp 	NextCommand
.1062					UnaryLen:
.1062	fa		plx				plx
.1063	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.1065	85 2c		sta $2c				sta 	zTemp0
.1067	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1069	85 2d		sta $2d				sta 	zTemp0+1
.106b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.106d	20 1a 26	jsr $261a			jsr 	FloatSetByte
.1070	4c 2f 08	jmp $082f			jmp 	NextCommand
.1073					LinkFloatAdd:
.1073	fa		plx				plx
.1074	5a		phy			phy
.1075	20 3c 20	jsr $203c		jsr	FloatAdd
.1078	7a		ply			ply
.1079	4c 2f 08	jmp $082f			jmp 	NextCommand
.107c					LinkFloatSubtract:
.107c	fa		plx				plx
.107d	5a		phy			phy
.107e	20 36 20	jsr $2036		jsr	FloatSubtract
.1081	7a		ply			ply
.1082	4c 2f 08	jmp $082f			jmp 	NextCommand
.1085					LinkFloatMultiply:
.1085	fa		plx				plx
.1086	5a		phy			phy
.1087	20 d8 22	jsr $22d8		jsr	FloatMultiply
.108a	7a		ply			ply
.108b	4c 2f 08	jmp $082f			jmp 	NextCommand
.108e					LinkFloatDivide:
.108e	fa		plx				plx
.108f	5a		phy			phy
.1090	20 61 21	jsr $2161		jsr	FloatDivide
.1093	b0 5c		bcs $10f1		bcs	DivZeroError
.1095	7a		ply			ply
.1096	4c 2f 08	jmp $082f			jmp 	NextCommand
.1099					LinkFloatPower:
.1099	fa		plx				plx
.109a	5a		phy			phy
.109b	20 e1 28	jsr $28e1		jsr	FloatPower
.109e	b0 4e		bcs $10ee		bcs	MapRangeError
.10a0	7a		ply			ply
.10a1	4c 2f 08	jmp $082f			jmp 	NextCommand
.10a4					LinkCompareGreater:
.10a4	fa		plx				plx
.10a5	5a		phy			phy
.10a6	20 e5 20	jsr $20e5		jsr	CompareGreater
.10a9	7a		ply			ply
.10aa	4c 2f 08	jmp $082f			jmp 	NextCommand
.10ad					LinkCompareEqual:
.10ad	fa		plx				plx
.10ae	5a		phy			phy
.10af	20 c7 20	jsr $20c7		jsr	CompareEqual
.10b2	7a		ply			ply
.10b3	4c 2f 08	jmp $082f			jmp 	NextCommand
.10b6					LinkCompareLess:
.10b6	fa		plx				plx
.10b7	5a		phy			phy
.10b8	20 dd 20	jsr $20dd		jsr	CompareLess
.10bb	7a		ply			ply
.10bc	4c 2f 08	jmp $082f			jmp 	NextCommand
.10bf					LinkCompareGreaterEqual:
.10bf	fa		plx				plx
.10c0	5a		phy			phy
.10c1	20 f5 20	jsr $20f5		jsr	CompareGreaterEqual
.10c4	7a		ply			ply
.10c5	4c 2f 08	jmp $082f			jmp 	NextCommand
.10c8					LinkCompareNotEqual:
.10c8	fa		plx				plx
.10c9	5a		phy			phy
.10ca	20 d7 20	jsr $20d7		jsr	CompareNotEqual
.10cd	7a		ply			ply
.10ce	4c 2f 08	jmp $082f			jmp 	NextCommand
.10d1					LinkCompareLessEqual:
.10d1	fa		plx				plx
.10d2	5a		phy			phy
.10d3	20 ed 20	jsr $20ed		jsr	CompareLessEqual
.10d6	7a		ply			ply
.10d7	4c 2f 08	jmp $082f			jmp 	NextCommand
.10da					LinkFloatIntegerPartDown:
.10da	fa		plx				plx
.10db	5a		phy			phy
.10dc	20 77 22	jsr $2277		jsr	FloatIntegerPartDown
.10df	7a		ply			ply
.10e0	4c 2f 08	jmp $082f			jmp 	NextCommand
.10e3					LinkFloatSquareRoot:
.10e3	fa		plx				plx
.10e4	5a		phy			phy
.10e5	20 63 29	jsr $2963		jsr	FloatSquareRoot
.10e8	b0 04		bcs $10ee		bcs	MapRangeError
.10ea	7a		ply			ply
.10eb	4c 2f 08	jmp $082f			jmp 	NextCommand
.10ee					MapRangeError:
.10ee	4c b5 1e	jmp $1eb5		jmp	ErrorV_range
.10f1					DivZeroError:
.10f1	4c 3e 1f	jmp $1f3e		jmp	ErrorV_divzero
.10f4					LinkFloatLogarithm:
.10f4	fa		plx				plx
.10f5	5a		phy			phy
.10f6	20 6d 28	jsr $286d		jsr	FloatLogarithm
.10f9	b0 f3		bcs $10ee		bcs	MapRangeError
.10fb	7a		ply			ply
.10fc	4c 2f 08	jmp $082f			jmp 	NextCommand
.10ff					LinkFloatExponent:
.10ff	fa		plx				plx
.1100	5a		phy			phy
.1101	20 6a 27	jsr $276a		jsr	FloatExponent
.1104	7a		ply			ply
.1105	4c 2f 08	jmp $082f			jmp 	NextCommand
.1108					LinkFloatCosine:
.1108	fa		plx				plx
.1109	5a		phy			phy
.110a	20 5e 27	jsr $275e		jsr	FloatCosine
.110d	7a		ply			ply
.110e	4c 2f 08	jmp $082f			jmp 	NextCommand
.1111					LinkFloatSine:
.1111	fa		plx				plx
.1112	5a		phy			phy
.1113	20 fe 28	jsr $28fe		jsr	FloatSine
.1116	7a		ply			ply
.1117	4c 2f 08	jmp $082f			jmp 	NextCommand
.111a					LinkFloatTangent:
.111a	fa		plx				plx
.111b	5a		phy			phy
.111c	20 6f 29	jsr $296f		jsr	FloatTangent
.111f	7a		ply			ply
.1120	4c 2f 08	jmp $082f			jmp 	NextCommand
.1123					LinkFloatArcTan:
.1123	fa		plx				plx
.1124	5a		phy			phy
.1125	20 43 26	jsr $2643		jsr	FloatArcTan
.1128	b0 c4		bcs $10ee		bcs	MapRangeError
.112a	7a		ply			ply
.112b	4c 2f 08	jmp $082f			jmp 	NextCommand
.112e					LinkFloatCompare:
.112e	fa		plx				plx
.112f	5a		phy			phy
.1130	20 fd 20	jsr $20fd		jsr	FloatCompare
.1133	7a		ply			ply
.1134	4c 2f 08	jmp $082f			jmp 	NextCommand
.1137					LinkDivideInt32:
.1137	fa		plx				plx
.1138	5a		phy			phy
.1139	20 8b 21	jsr $218b		jsr	DivideInt32
.113c	b0 b0		bcs $10ee		bcs	MapRangeError
.113e	7a		ply			ply
.113f	4c 2f 08	jmp $082f			jmp 	NextCommand
.1142					StackSaveCurrentPosition:
.1142	20 9a 08	jsr $089a			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.1145	5a		phy				phy
.1146	a0 02		ldy #$02			ldy 	#2
.1148	a5 28		lda $28				lda 	codePtr
.114a	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.114c	c8		iny				iny
.114d	a5 29		lda $29				lda 	codePtr+1
.114f	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1151	7a		ply				ply
.1152	60		rts				rts
.1153					StackLoadCurrentPosition:
.1153	a0 02		ldy #$02			ldy 	#2
.1155	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1157	85 28		sta $28				sta 	codePtr
.1159	c8		iny				iny
.115a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.115c	85 29		sta $29				sta 	codePtr+1
.115e	a0 00		ldy #$00			ldy 	#0
.1160	60		rts				rts
.1161					XCommandMouse:
.1161	fa		plx				plx
.1162	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; mouse control.
.1165	ca		dex				dex
.1166	da		phx				phx
.1167	5a		phy				phy
.1168	48		pha				pha
.1169	38		sec				sec 								; get screen resolution
.116a	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.116d	68		pla				pla
.116e	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.1171	7a		ply				ply
.1172	fa		plx				plx
.1173	4c 2f 08	jmp $082f			jmp 	NextCommand
.1176					XUnaryMB:
.1176	fa		plx				plx
.1177	20 a5 11	jsr $11a5			jsr 	XUnaryMouseCommon
.117a	a5 30		lda $30				lda 	zTemp2
.117c	e8		inx				inx
.117d	20 1a 26	jsr $261a			jsr 	FloatSetByte
.1180	4c 2f 08	jmp $082f			jmp 	NextCommand
.1183					XUnaryMX:
.1183	fa		plx				plx
.1184	20 a5 11	jsr $11a5			jsr 	XUnaryMouseCommon
.1187	a5 2c		lda $2c				lda 	zTemp0
.1189	e8		inx				inx
.118a	20 1a 26	jsr $261a			jsr 	FloatSetByte
.118d	a5 2d		lda $2d				lda 	zTemp0+1
.118f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1191	4c 2f 08	jmp $082f			jmp 	NextCommand
.1194					XUnaryMY:
.1194	fa		plx				plx
.1195	20 a5 11	jsr $11a5			jsr 	XUnaryMouseCommon
.1198	a5 2e		lda $2e				lda 	zTemp1
.119a	e8		inx				inx
.119b	20 1a 26	jsr $261a			jsr 	FloatSetByte
.119e	a5 2f		lda $2f				lda 	zTemp1+1
.11a0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11a2	4c 2f 08	jmp $082f			jmp 	NextCommand
.11a5					XUnaryMouseCommon:
.11a5	da		phx				phx
.11a6	5a		phy				phy
.11a7	a2 2c		ldx #$2c			ldx 	#zTemp0
.11a9	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.11ac	85 30		sta $30				sta 	zTemp2
.11ae	7a		ply				ply
.11af	fa		plx				plx
.11b0	60		rts				rts
.11b1					NegateTOS:
.11b1	fa		plx				plx
.11b2	20 da 25	jsr $25da			jsr 	FloatNegate
.11b5	4c 2f 08	jmp $082f			jmp 	NextCommand
.11b8					CommandNewLine:
.11b8	fa		plx				plx
.11b9	9c 68 05	stz $0568			stz 	stringInitialised
.11bc	a2 ff		ldx #$ff			ldx 	#$FF
.11be	4c 2f 08	jmp $082f			jmp 	NextCommand
.11c1					CommandXNext:
.11c1	fa		plx				plx
.11c2					_CNRetry:
.11c2	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.11c4	20 27 0d	jsr $0d27			jsr 	StackFindFrame
.11c7	20 9a 08	jsr $089a			jsr 	FixUpY 						; so we can use Y
.11ca	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.11cc	35 4a		and $4a,x			and 	NSMantissa1,x
.11ce	c9 ff		cmp #$ff			cmp 	#$FF
.11d0	f0 16		beq $11e8			beq 	_CNNoIndexVariable
.11d2	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.11d4	a0 05		ldy #$05			ldy 	#5
.11d6	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.11d8	d0 07		bne $11e1			bne 	_CNNIndexFail
.11da	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.11dc	c8		iny				iny
.11dd	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.11df	f0 07		beq $11e8			beq 	_CNNoIndexVariable
.11e1					_CNNIndexFail:
.11e1	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.11e3	20 19 0d	jsr $0d19			jsr 	StackCloseFrame 			; close this frame
.11e6	80 da		bra $11c2			bra 	_CNRetry
.11e8					_CNNoIndexVariable:
.11e8	ca		dex				dex
.11e9	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.11eb	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.11ed	29 40		and #$40			and 	#$40	 					; bit 6
.11ef	d0 55		bne $1246			bne 	_CNOptimisedNext
.11f1	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.11f3	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.11f5	48		pha				pha
.11f6	85 2c		sta $2c				sta 	zTemp0
.11f8	c8		iny				iny
.11f9	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.11fb	18		clc				clc
.11fc	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.11ff	48		pha				pha
.1200	85 2d		sta $2d				sta 	zTemp0+1
.1202	20 ba 14	jsr $14ba			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.1205	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.1207	e8		inx				inx
.1208	20 89 12	jsr $1289			jsr 	CopyOffsetYToTOS
.120b	20 3c 20	jsr $203c			jsr 	FloatAdd
.120e	68		pla				pla 								; restore address
.120f	85 2d		sta $2d				sta 	zTemp0+1
.1211	68		pla				pla
.1212	85 2c		sta $2c				sta 	zTemp0
.1214	20 95 1a	jsr $1a95			jsr 	WriteFloatZTemp0Sub			; write float.
.1217	e8		inx				inx  								; recover written
.1218	e8		inx				inx 								; load offset
.1219	a0 0d		ldy #$0d			ldy 	#13
.121b	20 89 12	jsr $1289			jsr 	CopyOffsetYToTOS
.121e	20 fd 20	jsr $20fd			jsr 	FloatCompare 				; and compare the floats.
.1221	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1222	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.1224	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1226	30 08		bmi $1230			bmi 	_CNDownStep
.1228	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.122a	c9 01		cmp #$01			cmp 	#1 							; gone higher
.122c	f0 10		beq $123e			beq 	_CNExitFor 					; if so exit the loop
.122e	80 06		bra $1236			bra 	_CNLoopBack
.1230					_CNDownStep:
.1230	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1232	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.1234	f0 08		beq $123e			beq 	_CNExitFor
.1236					_CNLoopBack:
.1236	20 53 11	jsr $1153			jsr 	StackLoadCurrentPosition 	; loop back
.1239	a0 00		ldy #$00			ldy 	#0
.123b	4c 2f 08	jmp $082f			jmp 	NextCommand
.123e					_CNExitFor:
.123e	20 19 0d	jsr $0d19			jsr 	StackCloseFrame 			; remove the frame and exit
.1241	a0 00		ldy #$00			ldy 	#0
.1243	4c 2f 08	jmp $082f			jmp 	NextCommand
.1246					_CNOptimisedNext:
.1246	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1248	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.124a	85 2c		sta $2c				sta 	zTemp0
.124c	c8		iny				iny
.124d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.124f	18		clc				clc
.1250	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1253	85 2d		sta $2d				sta 	zTemp0+1
.1255	a0 07		ldy #$07			ldy 	#7 							; STEP value
.1257	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1259	a0 ff		ldy #$ff			ldy 	#$FF
.125b	18		clc				clc
.125c					_CNOIncrement:
.125c	c8		iny				iny
.125d	71 2c		adc ($2c),y			adc 	(zTemp0),y
.125f	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1261	f0 f9		beq $125c			beq 	_CNOIncrement
.1263	18		clc				clc
.1264	a5 24		lda $24				lda 	runtimeStackPtr
.1266	69 0d		adc #$0d			adc 	#13
.1268	85 2e		sta $2e				sta 	zTemp1
.126a	a5 25		lda $25				lda 	runtimeStackPtr+1
.126c	69 00		adc #$00			adc 	#0
.126e	85 2f		sta $2f				sta 	zTemp1+1
.1270	a0 00		ldy #$00			ldy 	#0
.1272	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.1274	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.1276	c8		iny				iny
.1277	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.1279	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.127b	c8		iny				iny
.127c	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.127e	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1280	c8		iny				iny
.1281	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.1283	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1285	90 b7		bcc $123e			bcc	 	_CNExitFor
.1287	80 ad		bra $1236			bra 	_CNLoopBack
.1289					CopyOffsetYToTOS:
.1289	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.128b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.128d	c8		iny				iny
.128e	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1290	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1292	c8		iny				iny
.1293	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1295	95 56		sta $56,x			sta 	NSMantissa2,x
.1297	c8		iny				iny
.1298	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.129a	95 62		sta $62,x			sta 	NSMantissa3,x
.129c	c8		iny				iny
.129d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.129f	95 6e		sta $6e,x			sta 	NSExponent,x
.12a1	c8		iny				iny
.12a2	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12a4	95 32		sta $32,x			sta 	NSStatus,x
.12a6	60		rts				rts
.12a7	4c 2f 08	jmp $082f			jmp 	NextCommand
.12aa					NotTOS:
.12aa	fa		plx				plx
.12ab	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.12ae	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.12b0	74 62		stz $62,x			stz 	NSMantissa3,x
.12b2	20 da 25	jsr $25da			jsr 	FloatNegate		 			; negate
.12b5	e8		inx				inx 								; and subtract 1.
.12b6	a9 01		lda #$01			lda 	#1
.12b8	20 1a 26	jsr $261a			jsr 	FloatSetByte
.12bb	20 36 20	jsr $2036			jsr 	FloatSubtract
.12be					_NotTOSSkip:
.12be	4c 2f 08	jmp $082f			jmp 	NextCommand
.12c1					CommandXOn:
.12c1	fa		plx				plx
.12c2	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.12c5	8d 5c 04	sta $045c			sta 	onCount 					; save it.
.12c8	20 9a 08	jsr $089a			jsr 	FixUpY 						; Y = 0
.12cb					_CONFind:
.12cb	ce 5c 04	dec $045c			dec 	onCount 					; reached zero, do this one
.12ce	f0 0b		beq $12db			beq 	_CONFound
.12d0	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.12d1	c8		iny				iny
.12d2	c8		iny				iny
.12d3	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.12d5	c8		iny				iny
.12d6	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.12d8	f0 f1		beq $12cb			beq 	_CONFind
.12da	88		dey				dey 								; point to character after last GOTO/GOSUB
.12db					_CONFound:
.12db	4c 2f 08	jmp $082f			jmp 	NextCommand
.12de					CommandMoreOn:
.12de	fa		plx				plx
.12df	c8		iny				iny 								; so it goes to the first non-goto/gosub
.12e0	c8		iny				iny
.12e1	c8		iny				iny
.12e2	4c 2f 08	jmp $082f			jmp 	NextCommand
.045c					onCount:
>045c							.fill 	1
.12e5					UnaryPeek:
.12e5	fa		plx				plx
.12e6	20 11 10	jsr $1011			jsr 	GetInteger16Bit
.12e9	da		phx				phx
.12ea	5a		phy				phy
.12eb	a6 2c		ldx $2c				ldx 	zTemp0
.12ed	a4 2d		ldy $2d				ldy 	zTemp0+1
.12ef	20 26 1c	jsr $1c26			jsr 	XPeekMemory
.12f2	7a		ply				ply
.12f3	fa		plx				plx
.12f4	20 1a 26	jsr $261a			jsr 	FloatSetByte
.12f7	4c 2f 08	jmp $082f			jmp 	NextCommand
.12fa					CommandPOKE:
.12fa	fa		plx				plx
.12fb	da		phx				phx 								; save XY
.12fc	5a		phy				phy
.12fd	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1300	48		pha				pha
.1301	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1303	a8		tay				tay
.1304	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1306	aa		tax				tax
.1307	68		pla				pla
.1308	20 12 1c	jsr $1c12			jsr 	XPokeMemory
.130b	7a		ply				ply 								; restore YX and drop 2
.130c	fa		plx				plx
.130d	ca		dex				dex
.130e	ca		dex				dex
.130f	4c 2f 08	jmp $082f			jmp 	NextCommand
.1312					UnaryPos:
.1312	fa		plx				plx
.1313	20 a5 1b	jsr $1ba5			jsr 	XGetHPos
.1316	20 1a 26	jsr $261a			jsr 	FloatSetByte
.1319	4c 2f 08	jmp $082f			jmp 	NextCommand
.131c					GetChannel:
.131c	fa		plx				plx
.131d	ad 5d 04	lda $045d			lda 	currentChannel
.1320	e8		inx				inx
.1321	20 1a 26	jsr $261a			jsr 	FloatSetByte
.1324	4c 2f 08	jmp $082f			jmp 	NextCommand
.1327					SetChannel:
.1327	fa		plx				plx
.1328	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.132b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.132d	8d 5d 04	sta $045d			sta 	currentChannel
.1330	ca		dex				dex
.1331	4c 2f 08	jmp $082f			jmp 	NextCommand
.1334					SetDefaultChannel:
.1334	9c 5d 04	stz $045d			stz 	currentChannel
.1337	60		rts				rts
.1338					VectorPrintCharacter:
.1338	da		phx				phx
.1339	ae 5d 04	ldx $045d			ldx 	currentChannel
.133c	20 50 1c	jsr $1c50			jsr 	XPrintCharacterToChannel
.133f	fa		plx				plx
.1340	60		rts				rts
.1341					VectorGetCharacter:
.1341	da		phx				phx
.1342	ae 5d 04	ldx $045d			ldx 	currentChannel
.1345	20 89 1b	jsr $1b89			jsr 	XGetCharacterFromChannel
.1348	fa		plx				plx
.1349	60		rts				rts
.045d					currentChannel:
>045d							.fill 	1
.134a					PrintNumber:
.134a	fa		plx				plx
.134b	a9 07		lda #$07			lda 	#7
.134d	20 00 25	jsr $2500			jsr 	FloatToString 				; to number in decimal buffer
.1350	ca		dex				dex 								; drop
.1351	da		phx				phx
.1352	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1354					_PNLoop:
.1354	bd 96 05	lda $0596,x			lda 	decimalBuffer,x
.1357	20 38 13	jsr $1338			jsr 	VectorPrintCharacter
.135a	e8		inx				inx
.135b	bd 96 05	lda $0596,x			lda	 	decimalBuffer,x
.135e	d0 f4		bne $1354			bne 	_PNLoop
.1360	a9 20		lda #$20			lda 	#32 						; trailing space
.1362	20 38 13	jsr $1338			jsr 	VectorPrintCharacter
.1365	fa		plx				plx
.1366	4c 2f 08	jmp $082f			jmp 	NextCommand
.1369					PrintString:
.1369	fa		plx				plx
.136a	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.136c	85 2c		sta $2c				sta 	zTemp0
.136e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1370	85 2d		sta $2d				sta 	zTemp0+1
.1372	ca		dex				dex 								; drop
.1373	da		phx				phx
.1374	5a		phy				phy
.1375	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.1377	aa		tax				tax
.1378	a0 01		ldy #$01			ldy 	#1 							; Y = position
.137a					_PSLoop:
.137a	e0 00		cpx #$00			cpx 	#0 							; complete ?
.137c	f0 09		beq $1387			beq 	_PSExit
.137e	ca		dex				dex 								; dec count
.137f	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.1381	20 38 13	jsr $1338			jsr 	VectorPrintCharacter
.1384	c8		iny				iny
.1385	80 f3		bra $137a			bra 	_PSLoop
.1387					_PSExit:
.1387	7a		ply				ply
.1388	fa		plx				plx
.1389	4c 2f 08	jmp $082f			jmp 	NextCommand
.138c					CommandPushN:
.138c	fa		plx				plx
.138d	e8		inx				inx 								; next slot on stack
.138e	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.1390	95 6e		sta $6e,x			sta 	NSExponent,x
.1392	c8		iny				iny
.1393	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.1395	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1397	c8		iny				iny
.1398	b1 28		lda ($28),y			lda 	(codePtr),y
.139a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.139c	c8		iny				iny
.139d	b1 28		lda ($28),y			lda 	(codePtr),y
.139f	95 56		sta $56,x			sta 	NSMantissa2,x
.13a1	c8		iny				iny
.13a2	b1 28		lda ($28),y			lda 	(codePtr),y
.13a4	48		pha				pha
.13a5	29 7f		and #$7f			and 	#$7F
.13a7	95 62		sta $62,x			sta 	NSMantissa3,x
.13a9	68		pla				pla 								; sign in mantissa3:7
.13aa	29 80		and #$80			and 	#$80
.13ac	95 32		sta $32,x			sta 	NSStatus,x
.13ae	c8		iny				iny
.13af	4c 2f 08	jmp $082f			jmp 	NextCommand
.13b2					CommandPushS:
.13b2	fa		plx				plx
.13b3	e8		inx				inx 								; next slot on stack
.13b4	18		clc				clc
.13b5	98		tya				tya
.13b6	65 28		adc $28				adc 	codePtr 					; the string is inline
.13b8	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13ba	a5 29		lda $29				lda 	codePtr+1
.13bc	69 00		adc #$00			adc 	#0
.13be	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13c0	74 56		stz $56,x			stz 	NSMantissa2,x
.13c2	74 62		stz $62,x			stz 	NSMantissa3,x
.13c4	a9 40		lda #$40			lda 	#NSSString
.13c6	95 32		sta $32,x			sta 	NSStatus,x
.13c8	98		tya				tya 								; string length +1 added to Y
.13c9	38		sec				sec
.13ca	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.13cc	a8		tay				tay
.13cd	4c 2f 08	jmp $082f			jmp 	NextCommand
.13d0					CommandXRead:
.13d0	fa		plx				plx
.13d1	5a		phy				phy 								; save Y
.13d2	20 03 14	jsr $1403			jsr 	ReadStringToBuffer 			; read element into buffer
.13d5	e8		inx				inx									; space on stack
.13d6	a9 5f		lda #$5f			lda 	#((ReadBufferSize) & $FF)
.13d8	85 2c		sta $2c				sta 	0+zTemp0
.13da	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.13dc	85 2d		sta $2d				sta 	1+zTemp0
.13de	20 22 19	jsr $1922			jsr 	ValEvaluateZTemp0
.13e1	b0 04		bcs $13e7			bcs 	_CRError 					; failed
.13e3	7a		ply				ply 								; restore Y
.13e4	4c 2f 08	jmp $082f			jmp 	NextCommand
.13e7					_CRError:
.13e7	4c c5 1e	jmp $1ec5		jmp	ErrorV_value
.13ea					CommandReadString:
.13ea	fa		plx				plx
.13eb	5a		phy				phy 								; save Y
.13ec	20 03 14	jsr $1403			jsr 	ReadStringToBuffer 			; read text
.13ef	e8		inx				inx 								; make space on stack
.13f0	20 18 26	jsr $2618			jsr 	FloatSetZero 				; store as string on stack
.13f3	a9 5f		lda #$5f			lda 	#ReadBufferSize & $FF
.13f5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13f7	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.13f9	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13fb	a9 40		lda #$40			lda 	#NSSString
.13fd	95 32		sta $32,x			sta 	NSStatus,x
.13ff	7a		ply				ply 								; restore Y
.1400	4c 2f 08	jmp $082f			jmp 	NextCommand
.1403					ReadStringToBuffer:
.1403	a9 96		lda #$96			lda 	#((ReadBumpNext) & $FF)
.1405	8d 5f 05	sta $055f			sta 	0+ReadBumpNextVec
.1408	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.140a	8d 60 05	sta $0560			sta 	1+ReadBumpNextVec
.140d	a9 69		lda #$69			lda 	#((ReadLookNext) & $FF)
.140f	8d 61 05	sta $0561			sta 	0+ReadLookNextVec
.1412	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.1414	8d 62 05	sta $0562			sta 	1+ReadLookNextVec
.1417					GetStringToBuffer:
.1417	20 66 14	jsr $1466			jsr		GetLookNext 				; skip all leading spaces.
.141a	f0 44		beq $1460			beq 	_RBError 					; end of data
.141c	b0 f9		bcs $1417			bcs 	GetStringToBuffer 			; switched to new data line.
.141e	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1420	b0 05		bcs $1427			bcs 	_RBNoSpace
.1422	20 63 14	jsr $1463			jsr 	GetBumpNext 				; consume space and loop round.
.1425	80 f0		bra $1417			bra 	GetStringToBuffer
.1427					_RBNoSpace:
.1427	9c 5f 04	stz $045f			stz 	ReadBufferSize 				; empty the buffer.
.142a	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.142c	d0 08		bne $1436			bne 	_RBCommaSep
.142e	8d 5e 04	sta $045e			sta 	ReadSep 					; use as a seperator
.1431	20 63 14	jsr $1463			jsr 	GetBumpNext 				; consume the '"'
.1434	80 05		bra $143b			bra 	_RBGetText
.1436					_RBCommaSep:
.1436	a9 2c		lda #$2c			lda 	#","						; get till comma
.1438	8d 5e 04	sta $045e			sta 	ReadSep
.143b					_RBGetText:
.143b	20 66 14	jsr $1466			jsr 	GetLookNext 				; what follows
.143e	b0 18		bcs $1458			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.1440	20 63 14	jsr $1463			jsr 	GetBumpNext 				; consume it whatever
.1443	cd 5e 04	cmp $045e			cmp 	ReadSep 					; if found the seperator.
.1446	f0 10		beq $1458			beq 	_RBEndGet 					; exit after consumption
.1448	da		phx				phx
.1449	ae 5f 04	ldx $045f			ldx 	ReadBufferSize 				; copy into buffer.
.144c	ee 5f 04	inc $045f			inc 	ReadBufferSize
.144f	9d 60 04	sta $0460,x			sta 	ReadBuffer,x
.1452	9e 61 04	stz $0461,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.1455	fa		plx				plx
.1456	80 e3		bra $143b			bra 	_RBGetText
.1458					_RBEndGet:
.1458	c9 22		cmp #$22			cmp 	#'"'
.145a	d0 03		bne $145f			bne 	_RBNotQuote
.145c	20 63 14	jsr $1463			jsr 	GetBumpNext
.145f					_RBNotQuote:
.145f	60		rts				rts
.1460					_RBError:
.1460	4c 7a 1f	jmp $1f7a		jmp	ErrorV_data
.1463					GetBumpNext:
.1463	6c 5f 05	jmp ($055f)			jmp 	(ReadBumpNextVec)
.1466					GetLookNext:
.1466	6c 61 05	jmp ($0561)			jmp 	(ReadLookNextVec)
.1469					ReadLookNext:
.1469	ad 63 05	lda $0563			lda 	dataRemaining 				; any data remaining
.146c	f0 04		beq $1472			beq 	_RLNFindData
.146e	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.1470	18		clc				clc
.1471	60		rts				rts
.1472					_RLNFindData:
.1472	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.1474	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.1476	f0 1a		beq $1492			beq 	_RLNNoData
.1478	c9 cf		cmp #$cf			cmp 	#PCD_CMD_DATA 				; Found DATA
.147a	f0 05		beq $1481			beq 	_RLNHaveData
.147c					_RLNNext:
.147c	20 e7 1f	jsr $1fe7			jsr 	MoveObjectForward			; else scan forward.
.147f	80 f1		bra $1472			bra 	_RLNFindData
.1481					_RLNHaveData:
.1481	a0 01		ldy #$01			ldy 	#1 							; get length
.1483	b1 2a		lda ($2a),y			lda 	(objPtr),y
.1485	f0 f5		beq $147c			beq 	_RLNNext 					; skip if DATA alone
.1487	20 96 14	jsr $1496			jsr 	ReadBumpNext 				; advance by two
.148a	20 96 14	jsr $1496			jsr 	ReadBumpNext
.148d	8d 63 05	sta $0563			sta 	dataRemaining 				; set data left count.
.1490	38		sec				sec
.1491	60		rts				rts
.1492					_RLNNoData:
.1492	a9 00		lda #$00			lda 	#0
.1494	38		sec				sec
.1495	60		rts				rts
.1496					ReadBumpNext:
.1496	e6 2a		inc $2a				inc 	objPtr
.1498	d0 02		bne $149c			bne 	_RBNSkip
.149a	e6 2b		inc $2b				inc 	objPtr+1
.149c					_RBNSkip:
.149c	ce 63 05	dec $0563			dec 	dataRemaining
.149f	60		rts				rts
.045e					ReadSep:
>045e							.fill 	1
.045f					ReadBufferSize:
>045f							.fill 	1
.0460					ReadBuffer:
>0460							.fill 	255
.055f					ReadBumpNextVec:
>055f							.fill 	2
.0561					ReadLookNextVec:
>0561							.fill 	2
.14a0					ReadFloatCommand:
.14a0	fa		plx				plx
.14a1	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14a3	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14a5	88		dey				dey 								; get the upper 3 bits
.14a6	b1 28		lda ($28),y			lda 	(codePtr),y
.14a8	29 07		and #$07			and 	#7
.14aa	c8		iny				iny
.14ab	c8		iny				iny
.14ac	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14ae	2a		rol a				rol 	a 							; carry will be clear.
.14af	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14b2	85 2d		sta $2d				sta 	zTemp0+1
.14b4	20 ba 14	jsr $14ba			jsr 	ReadFloatZTemp0Sub
.14b7	4c 2f 08	jmp $082f			jmp 	NextCommand
.14ba					ReadFloatZTemp0Sub:
.14ba	5a		phy				phy 								; start write
.14bb	a0 01		ldy #$01			ldy 	#1
.14bd	e8		inx				inx
.14be	b2 2c		lda ($2c)			lda 	(zTemp0)
.14c0	95 3e		sta $3e,x			sta 	NSMantissa0,x
.14c2	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14c4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.14c6	c8		iny				iny
.14c7	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14c9	95 56		sta $56,x			sta 	NSMantissa2,x
.14cb	c8		iny				iny
.14cc	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14ce	95 62		sta $62,x			sta 	NSMantissa3,x
.14d0	c8		iny				iny
.14d1	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14d3	95 6e		sta $6e,x			sta 	NSExponent,x
.14d5	c8		iny				iny
.14d6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14d8	95 32		sta $32,x			sta 	NSStatus,x
.14da	7a		ply				ply
.14db	60		rts				rts
.14dc					ReadIntegerCommand:
.14dc	fa		plx				plx
.14dd	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14df	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14e1	88		dey				dey 								; get the upper 3 bits
.14e2	b1 28		lda ($28),y			lda 	(codePtr),y
.14e4	29 07		and #$07			and 	#7
.14e6	c8		iny				iny
.14e7	c8		iny				iny
.14e8	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14ea	2a		rol a				rol 	a 							; carry will be clear.
.14eb	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14ee	85 2d		sta $2d				sta 	zTemp0+1
.14f0	20 f6 14	jsr $14f6			jsr 	ReadIntegerZTemp0Sub
.14f3	4c 2f 08	jmp $082f			jmp 	NextCommand
.14f6					ReadIntegerZTemp0Sub:
.14f6	5a		phy				phy 								; start write
.14f7	a0 01		ldy #$01			ldy 	#1
.14f9	e8		inx				inx 								; prepare
.14fa	74 56		stz $56,x			stz 	NSMantissa2,x
.14fc	74 62		stz $62,x			stz 	NSMantissa3,x
.14fe	74 6e		stz $6e,x			stz 	NSExponent,x
.1500	74 32		stz $32,x			stz 	NSStatus,x
.1502	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1504	30 08		bmi $150e			bmi 	_RIZNegative
.1506	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1508	b2 2c		lda ($2c)			lda 	(zTemp0)
.150a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.150c	7a		ply				ply
.150d	60		rts				rts
.150e					_RIZNegative:
.150e	38		sec				sec 								; -ve read
.150f	a9 00		lda #$00			lda 	#0
.1511	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.1513	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1515	a9 00		lda #$00			lda 	#0
.1517	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1519	95 4a		sta $4a,x			sta 	NSMantissa1,x
.151b	a9 80		lda #$80			lda 	#$80
.151d	95 32		sta $32,x			sta 	NSStatus,x
.151f	7a		ply				ply
.1520	60		rts				rts
.1521					ReadStringCommand:
.1521	fa		plx				plx
.1522	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1524	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1526	88		dey				dey 								; get the upper 3 bits
.1527	b1 28		lda ($28),y			lda 	(codePtr),y
.1529	29 07		and #$07			and 	#7
.152b	c8		iny				iny
.152c	c8		iny				iny
.152d	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.152f	2a		rol a				rol 	a 							; carry will be clear.
.1530	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1533	85 2d		sta $2d				sta 	zTemp0+1
.1535	20 3b 15	jsr $153b			jsr 	ReadStringZTemp0Sub
.1538	4c 2f 08	jmp $082f			jmp 	NextCommand
.153b					ReadStringZTemp0Sub:
.153b	5a		phy				phy 								; start write
.153c	e8		inx				inx 								; prepare
.153d	74 56		stz $56,x			stz 	NSMantissa2,x
.153f	74 62		stz $62,x			stz 	NSMantissa3,x
.1541	74 6e		stz $6e,x			stz 	NSExponent,x
.1543	a9 40		lda #$40			lda 	#NSSString
.1545	74 32		stz $32,x			stz 	NSStatus,x
.1547	18		clc				clc
.1548	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.154a	69 02		adc #$02			adc 	#2 							; this points to actual data
.154c	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.154e	a0 01		ldy #$01			ldy 	#1
.1550	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1552	69 00		adc #$00			adc 	#0
.1554	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1556	d0 08		bne $1560			bne 	_RSZNoDefault 				; if read $00 use a default value.
.1558	a9 62		lda #$62			lda 	#_RSZNull & $FF
.155a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.155c	a9 15		lda #$15			lda 	#_RSZNull >> 8
.155e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1560					_RSZNoDefault:
.1560	7a		ply				ply
.1561	60		rts				rts
.1562					_RSZNull:
>1562	00						.byte 	0
.1563					CommandRestore:
.1563	fa		plx				plx
.1564	20 6a 15	jsr $156a			jsr 	RestoreCode
.1567	4c 2f 08	jmp $082f			jmp 	NextCommand
.156a					RestoreCode:
.156a	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.156d	85 2b		sta $2b				sta 	objPtr+1
.156f	64 2a		stz $2a				stz 	objPtr
.1571	9c 63 05	stz $0563			stz 	dataRemaining 				; no data remaining.
.1574	60		rts				rts
.0563					dataRemaining:
>0563							.fill 	1		 					; 0 if not in data statement
.1575					UnaryRND:
.1575	fa		plx				plx
.1576	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.1578	10 17		bpl $1591			bpl 	_URNoSeed
.157a	20 6d 23	jsr $236d			jsr 	FloatNormalise 				; some float value
.157d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.157f	8d 64 05	sta $0564			sta 	randomSeed+0
.1582	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1584	8d 65 05	sta $0565			sta 	randomSeed+1
.1587	b5 56		lda $56,x			lda 	NSMantissa2,x
.1589	8d 66 05	sta $0566			sta 	randomSeed+2
.158c	b5 62		lda $62,x			lda 	NSMantissa3,x
.158e	8d 67 05	sta $0567			sta 	randomSeed+3
.1591					_URNoSeed:
.1591	20 b3 15	jsr $15b3			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.1594	ad 64 05	lda $0564			lda 	randomSeed+0
.1597	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1599	ad 65 05	lda $0565			lda 	randomSeed+1
.159c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.159e	ad 66 05	lda $0566			lda 	randomSeed+2
.15a1	95 56		sta $56,x			sta 	NSMantissa2,x
.15a3	ad 67 05	lda $0567			lda 	randomSeed+3
.15a6	29 7f		and #$7f			and 	#$7F
.15a8	95 62		sta $62,x			sta 	NSMantissa3,x
.15aa	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.15ac	95 6e		sta $6e,x			sta 	NSExponent,x
.15ae	74 32		stz $32,x			stz 	NSStatus,x
.15b0	4c 2f 08	jmp $082f			jmp 	NextCommand
.15b3					RandomNumberGenerator:
.15b3	5a		phy				phy
.15b4	ad 64 05	lda $0564			lda 	randomSeed+0 				; check if zero
.15b7	0d 65 05	ora $0565			ora 	randomSeed+1
.15ba	0d 66 05	ora $0566			ora 	randomSeed+2
.15bd	0d 67 05	ora $0567			ora 	randomSeed+3
.15c0	d0 07		bne $15c9			bne 	_RNGNoSeed
.15c2	ce 67 05	dec $0567			dec 	randomSeed+3 				; if so tweak and flog
.15c5	a0 64		ldy #$64			ldy 	#100
.15c7	80 05		bra $15ce			bra 	_RNGLoop
.15c9					_RNGNoSeed:
.15c9	a0 08		ldy #$08			ldy 	#8
.15cb	ad 64 05	lda $0564			lda 	randomSeed+0
.15ce					_RNGLoop:
.15ce	0a		asl a				asl		a
.15cf	2e 65 05	rol $0565			rol 	randomSeed+1
.15d2	2e 66 05	rol $0566			rol 	randomSeed+2
.15d5	2e 67 05	rol $0567			rol 	randomSeed+3
.15d8	90 02		bcc $15dc			bcc		_RNGSkip
.15da	49 c5		eor #$c5			eor 	#$C5
.15dc					_RNGSkip:
.15dc	88		dey				dey
.15dd	d0 ef		bne $15ce			bne		_RNGLoop
.15df	8d 64 05	sta $0564			sta 	randomSeed+0
.15e2	7a		ply				ply
.15e3	60		rts				rts
.0564					randomSeed:
>0564							.fill 	4
.15e4					StringConcatenate:
.15e4	fa		plx				plx
.15e5	ca		dex				dex
.15e6	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.15e8	85 2e		sta $2e				sta 	zTemp1
.15ea	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15ec	85 2f		sta $2f				sta 	zTemp1+1
.15ee	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.15f0	85 30		sta $30				sta 	zTemp2
.15f2	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.15f4	85 31		sta $31				sta 	zTemp2+1
.15f6	18		clc				clc 								; work out total length
.15f7	b2 2e		lda ($2e)			lda 	(zTemp1)
.15f9	72 30		adc ($30)			adc 	(zTemp2)
.15fb	b0 18		bcs $1615			bcs 	_BCLength 					; more than 255 characters.
.15fd	48		pha				pha 								; save total
.15fe	20 db 16	jsr $16db			jsr 	StringAllocTemp 			; space for result.
.1601	68		pla				pla 								; write total as first.
.1602	92 22		sta ($22)			sta 	(zsTemp)
.1604	20 18 16	jsr $1618			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.1607	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.1609	85 2e		sta $2e				sta 	zTemp1
.160b	a5 31		lda $31				lda 	zTemp2+1
.160d	85 2f		sta $2f				sta 	zTemp1+1
.160f	20 18 16	jsr $1618			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1612	4c 2f 08	jmp $082f			jmp 	NextCommand
.1615					_BCLength:
.1615	4c b5 1e	jmp $1eb5		jmp	ErrorV_range
.1618					_BCCopyZTemp1:
.1618	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.161a	f0 15		beq $1631			beq 	_BCCExit 					; none.
.161c	da		phx				phx 								; save XY
.161d	5a		phy				phy
.161e	aa		tax				tax 								; count in X.
.161f	a0 01		ldy #$01			ldy 	#1
.1621					_BCCLoop:
.1621	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1623	d0 02		bne $1627			bne 	_BCCNoCarry
.1625	e6 23		inc $23				inc 	zsTemp+1
.1627					_BCCNoCarry:
.1627	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.1629	92 22		sta ($22)			sta 	(zsTemp)
.162b	c8		iny				iny
.162c	ca		dex				dex 								; X times
.162d	d0 f2		bne $1621			bne 	_BCCLoop
.162f	7a		ply				ply 								; restore YX
.1630	fa		plx				plx
.1631					_BCCExit:
.1631	60		rts				rts
.1632					XRuntimeSetup:
.1632	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1634	8d 6b 05	sta $056b	 		sta 	ramBank
.1637	8d 6c 05	sta $056c	 		sta 	romBank
.163a	60		rts				rts
.163b					SignTOS:
.163b	fa		plx				plx
.163c	20 3a 26	jsr $263a			jsr 	FloatIsZero 				; if zero
.163f	f0 0f		beq $1650			beq 	_SGZero  					; return Int Zero
.1641	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.1643	48		pha				pha
.1644	a9 01		lda #$01			lda 	#1 							; set result to 1
.1646	20 1a 26	jsr $261a			jsr 	FloatSetByte
.1649	68		pla				pla
.164a	29 80		and #$80			and		#$80 						; copy the sign byte out
.164c	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.164e	80 03		bra $1653			bra 	_SGExit
.1650					_SGZero:
.1650	20 18 26	jsr $2618			jsr 	FloatSetZero
.1653					_SGExit:
.1653	4c 2f 08	jmp $082f			jmp 	NextCommand
.1656					CommandShift:
.1656	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.1658	c8		iny				iny
.1659	0a		asl a				asl 	a 							; double into X
.165a	aa		tax				tax
.165b	7c 06 1a	jmp ($1a06,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.165e					PrintTab:
.165e	fa		plx				plx
.165f	20 a5 1b	jsr $1ba5			jsr 	XGetHPos
.1662					_PTMod10:
.1662	38		sec				sec
.1663	e9 0a		sbc #$0a			sbc 	#10
.1665	b0 fb		bcs $1662			bcs 	_PTMod10
.1667	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.1669	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.166a	80 15		bra $1681			bra 	PrintSpaceLoop
.166c					PrintPos:
.166c	fa		plx				plx
.166d	20 a5 1b	jsr $1ba5			jsr		XGetHPos 					; get current position
.1670	85 2c		sta $2c				sta 	zTemp0
.1672	38		sec				sec 								; calculate spaces required
.1673	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1675	ca		dex				dex
.1676	e5 2c		sbc $2c				sbc 	zTemp0
.1678	b0 07		bcs $1681			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.167a	4c 2f 08	jmp $082f			jmp 	NextCommand
.167d					PrintSpace:
.167d	fa		plx				plx
.167e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1680	ca		dex				dex
.1681					PrintSpaceLoop:
.1681	c9 00		cmp #$00			cmp 	#0
.1683	f0 0a		beq $168f			beq 	_PSExit
.1685	48		pha				pha
.1686	a9 20		lda #$20			lda 	#" "
.1688	20 38 13	jsr $1338			jsr 	VectorPrintCharacter
.168b	68		pla				pla
.168c	3a		dec a				dec 	a
.168d	80 f2		bra $1681			bra 	PrintSpaceLoop
.168f					_PSExit:
.168f	4c 2f 08	jmp $082f			jmp 	NextCommand
.1692					CommandStop:
.1692	fa		plx				plx
.1693	4c 67 1f	jmp $1f67		jmp	ErrorV_stop
.1696					Unary_Str:
.1696	fa		plx				plx
.1697	5a		phy				phy
.1698	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.169a	20 00 25	jsr $2500			jsr 	FloatToString 				; do the conversion.
.169d	a9 21		lda #$21			lda		#33 						; create buffer
.169f	20 db 16	jsr $16db			jsr 	StringAllocTemp 			; allocate memory
.16a2	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.16a4					_USCopy:
.16a4	b9 95 05	lda $0595,y			lda 	decimalBuffer-1,y
.16a7	f0 05		beq $16ae			beq 	_USExit
.16a9	91 22		sta ($22),y			sta 	(zsTemp),y
.16ab	c8		iny				iny
.16ac	80 f6		bra $16a4			bra 	_USCopy
.16ae					_USExit:
.16ae	98		tya				tya
.16af	3a		dec a				dec 	a
.16b0	92 22		sta ($22)			sta 	(zsTemp)
.16b2	7a		ply				ply
.16b3	4c 2f 08	jmp $082f			jmp 	NextCommand
.16b6					StringInitialise:
.16b6	48		pha				pha
.16b7	ad 68 05	lda $0568			lda 	stringInitialised 			; already done
.16ba	d0 11		bne $16cd			bne 	_SIExit
.16bc	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.16bf	8d 69 05	sta $0569			sta 	stringTempPointer
.16c2	ad 03 04	lda $0403			lda 	stringHighMemory+1
.16c5	3a		dec a				dec 	a
.16c6	3a		dec a				dec 	a
.16c7	8d 6a 05	sta $056a			sta 	stringTempPointer+1
.16ca	ce 68 05	dec $0568			dec 	stringInitialised 			; set the initialised flag.
.16cd					_SIExit:
.16cd	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.16cf	1a		inc a				inc 	a
.16d0	1a		inc a				inc 	a
.16d1	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.16d4	b0 02		bcs $16d8			bcs 	_SIMemory
.16d6	68		pla				pla
.16d7	60		rts				rts
.16d8					_SIMemory:
.16d8	4c c0 1f	jmp $1fc0		jmp	ErrorV_memory
.16db					StringAllocTemp:
.16db	20 b6 16	jsr $16b6			jsr 	StringInitialise 			; check it is initialised.
.16de	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.16e0	18		clc				clc
.16e1	6d 69 05	adc $0569			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.16e4	8d 69 05	sta $0569			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.16e7	85 22		sta $22				sta 	zsTemp
.16e9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.16eb	ad 6a 05	lda $056a			lda 	stringTempPointer+1
.16ee	69 ff		adc #$ff			adc 	#$FF
.16f0	8d 6a 05	sta $056a			sta 	stringTempPointer+1
.16f3	85 23		sta $23				sta 	zsTemp+1
.16f5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.16f7	74 56		stz $56,x			stz 	NSMantissa2,x
.16f9	74 62		stz $62,x			stz 	NSMantissa3,x
.16fb	a9 00		lda #$00			lda 	#0 							; clear string.
.16fd	92 22		sta ($22)			sta 	(zsTemp)
.16ff	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1701	95 32		sta $32,x			sta 	NSStatus,x
.1703	60		rts				rts
.1704					StringWriteChar:
.1704	5a		phy				phy
.1705	48		pha				pha
.1706	b2 22		lda ($22)			lda 	(zsTemp)
.1708	1a		inc a				inc 	a
.1709	92 22		sta ($22)			sta 	(zsTemp)
.170b	a8		tay				tay
.170c	68		pla				pla
.170d	91 22		sta ($22),y			sta 	(zsTemp),y
.170f	7a		ply				ply
.1710	60		rts				rts
.0568					stringInitialised:
>0568							.fill 	1
.0569					stringTempPointer:
>0569							.fill 	2
.1711					Unary_Left:
.1711	fa		plx				plx
.1712	5a		phy				phy
.1713	18		clc				clc 								; only one parameter
.1714	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; push the length of the string.
.1717	48		pha				pha
.1718	ca		dex				dex
.1719	a9 00		lda #$00			lda 	#0 							; push the start position.
.171b	48		pha				pha
.171c	20 54 17	jsr $1754			jsr 	UnarySStringToZTemp0
.171f	80 3c		bra $175d			bra 	SubstringMain 				; stack now points to the string to slice.
.1721					Unary_Right:
.1721	fa		plx				plx
.1722	5a		phy				phy
.1723	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.1725	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; push the right length of the string.
.1728	48		pha				pha
.1729	ca		dex				dex
.172a	20 54 17	jsr $1754			jsr 	UnarySStringToZTemp0
.172d	68		pla				pla 								; this is the right requirement
.172e	38		sec				sec
.172f	49 ff		eor #$ff			eor 	#$FF
.1731	72 2c		adc ($2c)			adc 	(zTemp0)
.1733	b0 02		bcs $1737			bcs 	_URHaveCount
.1735	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.1737					_URHaveCount:
.1737	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.1739	5a		phy				phy
.173a	48		pha				pha 								; start position
.173b	80 20		bra $175d			bra 	SubstringMain
.173d					Unary_Mid:
.173d	fa		plx				plx
.173e	5a		phy				phy
.173f	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; push the length of the string required.
.1742	48		pha				pha
.1743	ca		dex				dex
.1744	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; put the start position.
.1747	f0 08		beq $1751			beq 	_UMError
.1749	3a		dec a				dec 	a
.174a	48		pha				pha
.174b	ca		dex				dex
.174c	20 54 17	jsr $1754			jsr 	UnarySStringToZTemp0
.174f	80 0c		bra $175d			bra 	SubstringMain 				; stack now points to the string to slice.
.1751					_UMError:
.1751	4c b5 1e	jmp $1eb5		jmp	ErrorV_range
.1754					UnarySStringToZTemp0:
.1754	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1756	85 2c		sta $2c				sta 	zTemp0
.1758	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.175a	85 2d		sta $2d				sta 	zTemp0+1
.175c	60		rts				rts
.175d					SubstringMain:
.175d	68		pla				pla 								; get the start offset
.175e	7a		ply				ply 								; get the count to do.
.175f	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.1761	b0 38		bcs $179b			bcs 	_SSReturnNull
.1763	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.1765	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.1767	18		clc				clc
.1768	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.176a	b0 06		bcs $1772			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.176c	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.176e	f0 04		beq $1774			beq 	_SMIsOkay
.1770	90 02		bcc $1774			bcc 	_SMIsOkay
.1772					_SMTruncateToEnd:
.1772	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.1774					_SMIsOkay:
.1774	85 2f		sta $2f				sta 	zTemp1+1
.1776	38		sec				sec		 							; work out size
.1777	a5 2f		lda $2f				lda 	zTemp1+1
.1779	e5 2e		sbc $2e				sbc 	zTemp1
.177b	f0 1e		beq $179b			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.177d	20 db 16	jsr $16db			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.1780	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.1782					_SMCopy:
.1782	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.1784	f0 11		beq $1797			beq 	_SMExit
.1786	c8		iny				iny 								; bump and
.1787	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.1789	5a		phy				phy
.178a	48		pha				pha
.178b	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.178d	1a		inc a				inc 	a
.178e	a8		tay				tay
.178f	92 22		sta ($22)			sta 	(zsTemp)
.1791	68		pla				pla 								; write character out
.1792	91 22		sta ($22),y			sta 	(zsTemp),y
.1794	7a		ply				ply 								; restore Y
.1795	80 eb		bra $1782			bra 	_SMCopy
.1797					_SMExit:
.1797	7a		ply				ply
.1798	4c 2f 08	jmp $082f			jmp 	NextCommand
.179b					_SSReturnNull:
.179b	a9 ad		lda #$ad			lda 	#SSRNull & $FF 				; set up mantissa
.179d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.179f	a9 17		lda #$17			lda 	#SSRNull >> 8
.17a1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17a3	74 56		stz $56,x			stz 	NSMantissa2,x
.17a5	74 62		stz $62,x			stz 	NSMantissa3,x
.17a7	a9 40		lda #$40			lda 	#NSSString
.17a9	95 32		sta $32,x			sta 	NSStatus,x
.17ab	80 ea		bra $1797			bra 	_SMExit
.17ad					SSRNull:
>17ad	00 00						.word 	0
.17af					CommandSwap:
.17af	fa		plx				plx
.17b0	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17b2	48		pha				pha
.17b3	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.17b5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17b7	68		pla				pla
.17b8	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.17ba	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17bc	48		pha				pha
.17bd	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.17bf	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17c1	68		pla				pla
.17c2	95 49		sta $49,x			sta 	NSMantissa1-1,x
.17c4	b5 56		lda $56,x			lda 	NSMantissa2,x
.17c6	48		pha				pha
.17c7	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.17c9	95 56		sta $56,x			sta 	NSMantissa2,x
.17cb	68		pla				pla
.17cc	95 55		sta $55,x			sta 	NSMantissa2-1,x
.17ce	b5 62		lda $62,x			lda 	NSMantissa3,x
.17d0	48		pha				pha
.17d1	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.17d3	95 62		sta $62,x			sta 	NSMantissa3,x
.17d5	68		pla				pla
.17d6	95 61		sta $61,x			sta 	NSMantissa3-1,x
.17d8	b5 6e		lda $6e,x			lda 	NSExponent,x
.17da	48		pha				pha
.17db	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.17dd	95 6e		sta $6e,x			sta 	NSExponent,x
.17df	68		pla				pla
.17e0	95 6d		sta $6d,x			sta 	NSExponent-1,x
.17e2	b5 32		lda $32,x			lda 	NSStatus,x
.17e4	48		pha				pha
.17e5	b5 31		lda $31,x			lda 	NSStatus-1,x
.17e7	95 32		sta $32,x			sta 	NSStatus,x
.17e9	68		pla				pla
.17ea	95 31		sta $31,x			sta 	NSStatus-1,x
.17ec	4c 2f 08	jmp $082f			jmp 	NextCommand
.17ef					CommandSYS:
.17ef	fa		plx				plx
.17f0	da		phx				phx 								; save XY
.17f1	5a		phy				phy
.17f2	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.17f5	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.17f7	85 2d		sta $2d				sta 	zTemp0+1
.17f9	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17fb	85 2c		sta $2c				sta 	zTemp0
.17fd	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1800	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.1803	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.1806	48		pha				pha
.1807	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.180a	28		plp				plp
.180b	20 22 18	jsr $1822			jsr 	_CSZTemp0
.180e	08		php				php
.180f	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1812	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.1815	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.1818	68		pla				pla
.1819	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.181c	7a		ply				ply 								; restore YX and drop 2
.181d	fa		plx				plx
.181e	ca		dex				dex
.181f	4c 2f 08	jmp $082f			jmp 	NextCommand
.1822					_CSZTemp0:
.1822	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.1825					TimeTOS:
.1825	fa		plx				plx
.1826	20 80 18	jsr $1880			jsr 	TIPushClock 				; push clock to TOS
.1829	4c 2f 08	jmp $082f			jmp 	NextCommand
.182c					TimeString:
.182c	fa		plx				plx
.182d	20 80 18	jsr $1880			jsr 	TIPushClock 				; push clock to TOS
.1830	20 55 18	jsr $1855			jsr 	_TSDivMod60 				; result in seconds
.1833	20 55 18	jsr $1855			jsr 	_TSDivMod60 				; seconds
.1836	48		pha				pha
.1837	20 55 18	jsr $1855			jsr 	_TSDivMod60 				; minutes
.183a	48		pha				pha
.183b	a9 18		lda #$18			lda 	#24 						; hours
.183d	20 57 18	jsr $1857			jsr 	_TSDivModA
.1840	48		pha				pha
.1841	a9 06		lda #$06			lda 	#6
.1843	20 db 16	jsr $16db			jsr 	StringAllocTemp
.1846	68		pla				pla
.1847	20 67 18	jsr $1867			jsr 	_TSWriteDecimal
.184a	68		pla				pla
.184b	20 67 18	jsr $1867			jsr 	_TSWriteDecimal
.184e	68		pla				pla
.184f	20 67 18	jsr $1867			jsr 	_TSWriteDecimal
.1852	4c 2f 08	jmp $082f			jmp 	NextCommand
.1855					_TSDivMod60:
.1855	a9 3c		lda #$3c			lda 	#60
.1857					_TSDivModA:
.1857	e8		inx				inx
.1858	20 1a 26	jsr $261a			jsr 	FloatSetByte
.185b	ca		dex				dex
.185c	20 ae 21	jsr $21ae			jsr 	Int32Divide
.185f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.1861	48		pha				pha
.1862	20 9d 21	jsr $219d			jsr 	NSMCopyPlusTwoToZero
.1865	68		pla				pla
.1866	60		rts				rts
.1867					_TSWriteDecimal:
.1867	da		phx				phx
.1868	a2 30		ldx #$30			ldx 	#'0'
.186a					_TSWDLoop:
.186a	c9 0a		cmp #$0a			cmp 	#10
.186c	90 05		bcc $1873			bcc 	_TSWDEnd
.186e	e9 0a		sbc #$0a			sbc 	#10
.1870	e8		inx				inx
.1871	80 f7		bra $186a			bra 	_TSWDLoop
.1873					_TSWDEnd:
.1873	48		pha				pha
.1874	8a		txa				txa
.1875	20 04 17	jsr $1704			jsr 	StringWriteChar
.1878	68		pla				pla
.1879	09 30		ora #$30			ora 	#'0'
.187b	20 04 17	jsr $1704			jsr 	StringWriteChar
.187e	fa		plx				plx
.187f	60		rts				rts
.1880					TIPushClock:
.1880	5a		phy				phy
.1881	e8		inx				inx 								; push 0 on the stack
.1882	20 18 26	jsr $2618			jsr 	FloatSetZero
.1885	da		phx				phx
.1886	20 70 1c	jsr $1c70			jsr 	XReadClock 					; read time into YXA
.1889	86 2c		stx $2c				stx 	zTemp0
.188b	fa		plx				plx
.188c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.188e	a5 2c		lda $2c				lda 	zTemp0
.1890	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1892	98		tya				tya
.1893	95 56		sta $56,x			sta 	NSMantissa2,x
.1895	7a		ply				ply
.1896	60		rts				rts
.1897					CommandTIWrite:
.1897	fa		plx				plx
.1898	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.189a	85 22		sta $22				sta 	zsTemp
.189c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.189e	85 23		sta $23				sta 	zsTemp+1
.18a0	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.18a2	c9 06		cmp #$06			cmp 	#6
.18a4	d0 59		bne $18ff			bne 	_CTIWError
.18a6	20 18 26	jsr $2618			jsr 	FloatSetZero
.18a9	20 cb 18	jsr $18cb			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.18ac	20 cb 18	jsr $18cb			jsr 	_CTIWDigitPair
.18af	20 cb 18	jsr $18cb			jsr 	_CTIWDigitPair
.18b2	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.18b4	20 f6 18	jsr $18f6			jsr 	_CTIWMultiply
.18b7	da		phx				phx
.18b8	5a		phy				phy
.18b9	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.18bb	48		pha				pha
.18bc	b5 56		lda $56,x			lda 	NSMantissa2,x
.18be	a8		tay				tay
.18bf	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.18c1	fa		plx				plx
.18c2	20 74 1c	jsr $1c74			jsr 	XWriteClock 				; update the clock.
.18c5	7a		ply				ply
.18c6	fa		plx				plx
.18c7	ca		dex				dex 								; throw result.
.18c8	4c 2f 08	jmp $082f			jmp 	NextCommand
.18cb					_CTIWDigitPair:
.18cb	a9 06		lda #$06			lda 	#6 							; x 6
.18cd	20 f6 18	jsr $18f6			jsr 	_CTIWMultiply
.18d0	20 dc 18	jsr $18dc			jsr 	_CTIWAddDigit 				; add digit
.18d3	a9 0a		lda #$0a			lda 	#10 						; x 10
.18d5	20 f6 18	jsr $18f6			jsr 	_CTIWMultiply
.18d8	20 dc 18	jsr $18dc			jsr 	_CTIWAddDigit 				; add digit
.18db	60		rts				rts
.18dc					_CTIWAddDigit:
.18dc	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.18de	d0 02		bne $18e2			bne 	_CTIWASkip
.18e0	e6 23		inc $23				inc 	zsTemp+1
.18e2					_CTIWASkip:
.18e2	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.18e4	38		sec				sec
.18e5	e9 30		sbc #$30			sbc 	#"0"
.18e7	90 16		bcc $18ff			bcc 	_CTIWError
.18e9	c9 0a		cmp #$0a			cmp 	#9+1
.18eb	b0 12		bcs $18ff			bcs 	_CTIWError
.18ed	e8		inx				inx 								; store at +1
.18ee	20 1a 26	jsr $261a			jsr 	FloatSetByte
.18f1	ca		dex				dex
.18f2	20 a4 23	jsr $23a4			jsr 	FloatAddTopTwoStack
.18f5	60		rts				rts
.18f6					_CTIWMultiply:
.18f6	e8		inx				inx
.18f7	20 1a 26	jsr $261a			jsr 	FloatSetByte
.18fa	ca		dex				dex
.18fb	20 25 23	jsr $2325			jsr 	FloatMultiplyShort
.18fe	60		rts				rts
.18ff					_CTIWError:
.18ff	4c c5 1e	jmp $1ec5		jmp	ErrorV_value
.1902					UnaryUsr:
.1902	fa		plx				plx
.1903	5a		phy				phy
.1904	20 0b 19	jsr $190b			jsr 	_UUCallVector
.1907	7a		ply				ply
.1908	4c 2f 08	jmp $082f			jmp 	NextCommand
.190b					_UUCallVector:
.190b	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.190e					ValUnary:
.190e	fa		plx				plx
.190f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1911	85 2c		sta $2c				sta 	zTemp0
.1913	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1915	85 2d		sta $2d				sta 	zTemp0+1
.1917	20 22 19	jsr $1922			jsr 	ValEvaluateZTemp0
.191a	b0 03		bcs $191f			bcs 	_VUError 					; couldn't convert
.191c	4c 2f 08	jmp $082f			jmp 	NextCommand
.191f					_VUError:
.191f	4c c5 1e	jmp $1ec5		jmp	ErrorV_value
.1922					ValEvaluateZTemp0:
.1922	5a		phy				phy
.1923	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.1925	f0 22		beq $1949			beq 	_VMCFail2
.1927	a0 00		ldy #$00			ldy 	#0 							; start position
.1929					_VMCSpaces:
.1929	c8		iny				iny 								; skip leading spaces
.192a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.192c	c9 20		cmp #$20			cmp 	#" "
.192e	f0 f9		beq $1929			beq 	_VMCSpaces
.1930	48		pha				pha 								; save first character
.1931	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.1933	d0 01		bne $1936			bne 	_VMCStart
.1935	c8		iny				iny 								; skip over - if so.
.1936					_VMCStart:
.1936	38		sec				sec 								; initialise first time round.
.1937					_VMCNext:
.1937	98		tya				tya 								; reached end of string
.1938	3a		dec a				dec 	a
.1939	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.193b	f0 0f		beq $194c			beq 	_VMCSuccess 				; successful.
.193d	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.193f	c8		iny				iny
.1940	20 fc 23	jsr $23fc			jsr 	FloatEncode 				; send it to the number-builder
.1943	90 03		bcc $1948			bcc 	_VMCFail 					; if failed, give up.
.1945	18		clc				clc 								; next time round, countinue
.1946	80 ef		bra $1937			bra 	_VMCNext
.1948					_VMCFail:
.1948	68		pla				pla
.1949					_VMCFail2:
.1949	7a		ply				ply
.194a	38		sec				sec
.194b	60		rts				rts
.194c					_VMCSuccess:
.194c	a9 00		lda #$00			lda 	#0 							; construct final
.194e	20 fc 23	jsr $23fc			jsr 	FloatEncode 				; by sending a duff value.
.1951	68		pla				pla 								; if it was -ve
.1952	c9 2d		cmp #$2d			cmp 	#"-"
.1954	d0 03		bne $1959			bne 	_VMCNotNegative
.1956	20 da 25	jsr $25da			jsr		FloatNegate 				; negate it.
.1959					_VMCNotNegative:
.1959	7a		ply				ply
.195a	18		clc				clc
.195b	60		rts				rts
.195c					VectorTable:
>195c	73 10					.word	LinkFloatAdd             ; $80 +
>195e	7c 10					.word	LinkFloatSubtract        ; $81 -
>1960	85 10					.word	LinkFloatMultiply        ; $82 *
>1962	8e 10					.word	LinkFloatDivide          ; $83 /
>1964	99 10					.word	LinkFloatPower           ; $84 ^
>1966	c1 08					.word	BinaryAnd                ; $85 and
>1968	c5 08					.word	BinaryOr                 ; $86 or
>196a	a4 10					.word	LinkCompareGreater       ; $87 >
>196c	ad 10					.word	LinkCompareEqual         ; $88 =
>196e	b6 10					.word	LinkCompareLess          ; $89 <
>1970	bf 10					.word	LinkCompareGreaterEqual  ; $8a >=
>1972	c8 10					.word	LinkCompareNotEqual      ; $8b <>
>1974	d1 10					.word	LinkCompareLessEqual     ; $8c <=
>1976	a9 08					.word	AbsoluteTOS              ; $8d abs
>1978	fc 08					.word	ArrayConvert             ; $8e array
>197a	a4 09					.word	UnaryAsc                 ; $8f asc
>197c	bf 09					.word	CommandAssert            ; $90 assert
>197e	00 0a					.word	Unary16Bin               ; $91 bin$
>1980	2a 0a					.word	PrintCharacterX          ; $92 print.chr
>1982	34 0a					.word	UnaryChr                 ; $93 chr$
>1984	99 0a					.word	CompareStrings           ; $94 s.cmp
>1986	80 0c					.word	CommandXFor              ; $95 for
>1988	43 0d					.word	UnaryFre                 ; $96 fre
>198a	5b 0d					.word	CommandXGet              ; $97 get
>198c	81 0d					.word	CommandReturn            ; $98 return
>198e	c3 0d					.word	Command_PSET             ; $99 pset
>1990	dd 0d					.word	Command_LINE             ; $9a line
>1992	f2 0d					.word	Command_RECT             ; $9b rect
>1994	01 0e					.word	Command_FRAME            ; $9c frame
>1996	10 0e					.word	Command_CHAR             ; $9d char
>1998	a7 0e					.word	Unary16Hex               ; $9e hex$
>199a	4e 0f					.word	CommandXInput            ; $9f input
>199c	65 0f					.word	CommandInputString       ; $a0 input$
>199e	7e 0f					.word	CommandInputReset        ; $a1 input.start
>19a0	62 10					.word	UnaryLen                 ; $a2 len
>19a2	2e 11					.word	LinkFloatCompare         ; $a3 f.cmp
>19a4	37 11					.word	LinkDivideInt32          ; $a4 int.div
>19a6	b1 11					.word	NegateTOS                ; $a5 negate
>19a8	b8 11					.word	CommandNewLine           ; $a6 new.line
>19aa	c1 11					.word	CommandXNext             ; $a7 next
>19ac	aa 12					.word	NotTOS                   ; $a8 not
>19ae	c1 12					.word	CommandXOn               ; $a9 on
>19b0	de 12					.word	CommandMoreOn            ; $aa moreon
>19b2	e5 12					.word	UnaryPeek                ; $ab peek
>19b4	fa 12					.word	CommandPOKE              ; $ac poke
>19b6	12 13					.word	UnaryPos                 ; $ad pos
>19b8	1c 13					.word	GetChannel               ; $ae getchannel
>19ba	27 13					.word	SetChannel               ; $af setchannel
>19bc	4a 13					.word	PrintNumber              ; $b0 print.n
>19be	69 13					.word	PrintString              ; $b1 print.s
>19c0	d0 13					.word	CommandXRead             ; $b2 read
>19c2	ea 13					.word	CommandReadString        ; $b3 read$
>19c4	75 15					.word	UnaryRND                 ; $b4 rnd
>19c6	e4 15					.word	StringConcatenate        ; $b5 concat
>19c8	3b 16					.word	SignTOS                  ; $b6 sgn
>19ca	5e 16					.word	PrintTab                 ; $b7 print.tab
>19cc	6c 16					.word	PrintPos                 ; $b8 print.pos
>19ce	7d 16					.word	PrintSpace               ; $b9 print.spc
>19d0	96 16					.word	Unary_Str                ; $ba str$
>19d2	11 17					.word	Unary_Left               ; $bb left$
>19d4	21 17					.word	Unary_Right              ; $bc right$
>19d6	3d 17					.word	Unary_Mid                ; $bd mid$
>19d8	af 17					.word	CommandSwap              ; $be swap
>19da	25 18					.word	TimeTOS                  ; $bf ti
>19dc	2c 18					.word	TimeString               ; $c0 ti$
>19de	02 19					.word	UnaryUsr                 ; $c1 usr
>19e0	0e 19					.word	ValUnary                 ; $c2 val
>19e2	6c 1b					.word	CommandClose             ; $c3 close
>19e4	7e 1b					.word	CommandExit              ; $c4 exit
>19e6	84 1b					.word	CommandDebug             ; $c5 debug
>19e8	ea 1b					.word	CommandXOpen             ; $c6 open
>19ea	7e 1c					.word	CommandScreen            ; $c7 screen
>19ec	65 1e					.word	CommandVPOKE             ; $c8 vpoke
>19ee	8a 1e					.word	CommandVPEEK             ; $c9 vpeek
>19f0	56 16					.word	CommandShift             ; $ca .shift
>19f2	6d 08					.word	PushByteCommand          ; $cb .byte
>19f4	80 08					.word	PushWordCommand          ; $cc .word
>19f6	8c 13					.word	CommandPushN             ; $cd .float
>19f8	b2 13					.word	CommandPushS             ; $ce .string
>19fa	21 0b					.word	CommandXData             ; $cf .data
>19fc	92 0d					.word	CommandXGoto             ; $d0 .goto
>19fe	75 0d					.word	CommandXGosub            ; $d1 .gosub
>1a00	a7 0d					.word	CommandGotoZ             ; $d2 .goto.z
>1a02	b5 0d					.word	CommandGotoNZ            ; $d3 .goto.nz
>1a04	af 08					.word	CommandVarSpace          ; $d4 .varspace
.1a06					ShiftVectorTable:
>1a06	4c 0a					.word	CommandClr               ; $ca80 clr
>1a08	2a 0b					.word	CommandXDIM              ; $ca81 dim
>1a0a	1b 0c					.word	CommandEnd               ; $ca82 end
>1a0c	33 10					.word	UnaryJoy                 ; $ca83 joy
>1a0e	da 10					.word	LinkFloatIntegerPartDown ; $ca84 int
>1a10	e3 10					.word	LinkFloatSquareRoot      ; $ca85 sqr
>1a12	f4 10					.word	LinkFloatLogarithm       ; $ca86 log
>1a14	ff 10					.word	LinkFloatExponent        ; $ca87 exp
>1a16	08 11					.word	LinkFloatCosine          ; $ca88 cos
>1a18	11 11					.word	LinkFloatSine            ; $ca89 sin
>1a1a	1a 11					.word	LinkFloatTangent         ; $ca8a tan
>1a1c	23 11					.word	LinkFloatArcTan          ; $ca8b atn
>1a1e	61 11					.word	XCommandMouse            ; $ca8c mouse
>1a20	76 11					.word	XUnaryMB                 ; $ca8d mb
>1a22	83 11					.word	XUnaryMX                 ; $ca8e mx
>1a24	94 11					.word	XUnaryMY                 ; $ca8f my
>1a26	63 15					.word	CommandRestore           ; $ca90 restore
>1a28	92 16					.word	CommandStop              ; $ca91 stop
>1a2a	ef 17					.word	CommandSYS               ; $ca92 sys
>1a2c	97 18					.word	CommandTIWrite           ; $ca93 ti$.write
>1a2e	64 1a					.word	CommandXWAIT             ; $ca94 wait
>1a30	af 1b					.word	X16I2CPoke               ; $ca95 i2cpoke
>1a32	cf 1b					.word	X16I2CPeek               ; $ca96 i2cpeek
>1a34	3a 1c					.word	CommandBank              ; $ca97 bank
>1a36	8d 1c					.word	XCommandSleep            ; $ca98 sleep
>1a38	b1 1c					.word	X16_Audio_FMINIT         ; $ca99 fminit
>1a3a	bf 1c					.word	X16_Audio_FMNOTE         ; $ca9a fmnote
>1a3c	d1 1c					.word	X16_Audio_FMDRUM         ; $ca9b fmdrum
>1a3e	e3 1c					.word	X16_Audio_FMINST         ; $ca9c fminst
>1a40	f5 1c					.word	X16_Audio_FMVIB          ; $ca9d fmvib
>1a42	07 1d					.word	X16_Audio_FMFREQ         ; $ca9e fmfreq
>1a44	18 1d					.word	X16_Audio_FMVOL          ; $ca9f fmvol
>1a46	2a 1d					.word	X16_Audio_FMPAN          ; $caa0 fmpan
>1a48	3c 1d					.word	X16_Audio_FMPLAY         ; $caa1 fmplay
>1a4a	4d 1d					.word	X16_Audio_FMCHORD        ; $caa2 fmchord
>1a4c	5e 1d					.word	X16_Audio_FMPOKE         ; $caa3 fmpoke
>1a4e	70 1d					.word	X16_Audio_PSGINIT        ; $caa4 psginit
>1a50	7e 1d					.word	X16_Audio_PSGNOTE        ; $caa5 psgnote
>1a52	90 1d					.word	X16_Audio_PSGVOL         ; $caa6 psgvol
>1a54	a2 1d					.word	X16_Audio_PSGWAV         ; $caa7 psgwav
>1a56	b4 1d					.word	X16_Audio_PSGFREQ        ; $caa8 psgfreq
>1a58	c5 1d					.word	X16_Audio_PSGPAN         ; $caa9 psgpan
>1a5a	d7 1d					.word	X16_Audio_PSGPLAY        ; $caaa psgplay
>1a5c	e8 1d					.word	X16_Audio_PSGCHORD       ; $caab psgchord
>1a5e	f9 1d					.word	CommandCls               ; $caac cls
>1a60	02 1e					.word	CommandLocate            ; $caad locate
>1a62	2c 1e					.word	CommandColor             ; $caae color
.1a64					CommandXWAIT:
.1a64	fa		plx				plx
.1a65	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1a67	85 2c		sta $2c				sta 	zTemp0
.1a69	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1a6b	85 2d		sta $2d				sta 	zTemp0+1
.1a6d					_WaitLoop:
.1a6d	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1a6f	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1a71	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1a73	f0 f8		beq $1a6d			beq 	_WaitLoop 					; keep going if zero
.1a75	ca		dex				dex 								; drop 3.
.1a76	ca		dex				dex
.1a77	ca		dex				dex
.1a78	4c 2f 08	jmp $082f			jmp 	NextCommand
.1a7b					WriteFloatCommand:
.1a7b	fa		plx				plx
.1a7c	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1a7e	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1a80	88		dey				dey 								; get the upper 3 bits
.1a81	b1 28		lda ($28),y			lda 	(codePtr),y
.1a83	29 07		and #$07			and 	#7
.1a85	c8		iny				iny
.1a86	c8		iny				iny
.1a87	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1a89	2a		rol a				rol 	a 							; carry will be clear.
.1a8a	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1a8d	85 2d		sta $2d				sta 	zTemp0+1
.1a8f	20 95 1a	jsr $1a95			jsr 	WriteFloatZTemp0Sub
.1a92	4c 2f 08	jmp $082f			jmp 	NextCommand
.1a95					WriteFloatZTemp0Sub:
.1a95	5a		phy				phy 								; ldart write
.1a96	a0 01		ldy #$01			ldy 	#1
.1a98	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1a9a	92 2c		sta ($2c)			sta 	(zTemp0)
.1a9c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1a9e	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1aa0	c8		iny				iny
.1aa1	b5 56		lda $56,x			lda 	NSMantissa2,x
.1aa3	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1aa5	c8		iny				iny
.1aa6	b5 62		lda $62,x			lda 	NSMantissa3,x
.1aa8	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1aaa	c8		iny				iny
.1aab	b5 6e		lda $6e,x			lda 	NSExponent,x
.1aad	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1aaf	c8		iny				iny
.1ab0	b5 32		lda $32,x			lda 	NSStatus,x
.1ab2	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ab4	ca		dex				dex
.1ab5	7a		ply				ply
.1ab6	60		rts				rts
.1ab7					WriteIntegerCommand:
.1ab7	fa		plx				plx
.1ab8	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1aba	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1abc	88		dey				dey 								; get the upper 3 bits
.1abd	b1 28		lda ($28),y			lda 	(codePtr),y
.1abf	29 07		and #$07			and 	#7
.1ac1	c8		iny				iny
.1ac2	c8		iny				iny
.1ac3	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1ac5	2a		rol a				rol 	a 							; carry will be clear.
.1ac6	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1ac9	85 2d		sta $2d				sta 	zTemp0+1
.1acb	20 d1 1a	jsr $1ad1			jsr 	WriteIntegerZTemp0Sub
.1ace	4c 2f 08	jmp $082f			jmp 	NextCommand
.1ad1					WriteIntegerZTemp0Sub:
.1ad1	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.1ad4	5a		phy				phy 								; start write
.1ad5	a0 01		ldy #$01			ldy 	#1
.1ad7	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1ad9	30 0b		bmi $1ae6			bmi 	_WIZNegative
.1adb	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1add	92 2c		sta ($2c)			sta 	(zTemp0)
.1adf	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ae1	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ae3	7a		ply				ply
.1ae4	ca		dex				dex
.1ae5	60		rts				rts
.1ae6					_WIZNegative:
.1ae6	38		sec				sec 								; -ve read
.1ae7	a9 00		lda #$00			lda 	#0
.1ae9	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1aeb	92 2c		sta ($2c)			sta 	(zTemp0)
.1aed	a9 00		lda #$00			lda 	#0
.1aef	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1af1	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1af3	7a		ply				ply
.1af4	ca		dex				dex
.1af5	60		rts				rts
.1af6					WriteStringCommand:
.1af6	fa		plx				plx
.1af7	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1af9	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1afb	88		dey				dey 								; get the upper 3 bits
.1afc	b1 28		lda ($28),y			lda 	(codePtr),y
.1afe	29 07		and #$07			and 	#7
.1b00	c8		iny				iny
.1b01	c8		iny				iny
.1b02	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b04	2a		rol a				rol 	a 							; carry will be clear.
.1b05	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b08	85 2d		sta $2d				sta 	zTemp0+1
.1b0a	20 10 1b	jsr $1b10			jsr 	WriteStringZTemp0Sub
.1b0d	4c 2f 08	jmp $082f			jmp 	NextCommand
.1b10					WriteStringZTemp0Sub:
.1b10	5a		phy				phy
.1b11	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b13	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b15	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b17	f0 1e		beq $1b37			beq 	_WSConcrete
.1b19	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b1b	85 2e		sta $2e				sta 	zTemp1
.1b1d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b1f	85 2f		sta $2f				sta 	zTemp1+1
.1b21	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b23	85 30		sta $30				sta 	zTemp2
.1b25	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b27	85 31		sta $31				sta 	zTemp2+1
.1b29	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1b2b	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1b2d	b0 17		bcs $1b46			bcs 	_WSCopy
.1b2f	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1b31	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b33	09 80		ora #$80			ora 	#$80
.1b35	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1b37					_WSConcrete:
.1b37	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1b39	a8		tay				tay
.1b3a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b3c	20 db 0a	jsr $0adb			jsr 	StringConcrete
.1b3f	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1b41	98		tya				tya
.1b42	a0 01		ldy #$01			ldy 	#1
.1b44	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b46					_WSCopy
.1b46	18		clc				clc  								; copy target+2 to zTemp2
.1b47	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b49	69 02		adc #$02			adc 	#2
.1b4b	85 30		sta $30				sta 	zTemp2
.1b4d	a0 01		ldy #$01			ldy 	#1
.1b4f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b51	69 00		adc #$00			adc 	#0
.1b53	85 31		sta $31				sta 	zTemp2+1
.1b55	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1b57	85 2e		sta $2e				sta 	zTemp1
.1b59	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b5b	85 2f		sta $2f				sta 	zTemp1+1
.1b5d	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1b5f	a8		tay				tay
.1b60					_WSCopyLoop:
.1b60	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b62	91 30		sta ($30),y			sta 	(zTemp2),y
.1b64	88		dey				dey
.1b65	c0 ff		cpy #$ff			cpy 	#$FF
.1b67	d0 f7		bne $1b60			bne 	_WSCopyLoop
.1b69	ca		dex				dex
.1b6a	7a		ply				ply
.1b6b	60		rts				rts
.1b6c					CommandClose:
.1b6c	fa		plx				plx
.1b6d	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; channel to close
.1b70	cd 5d 04	cmp $045d			cmp 	currentChannel 				; is it the current channel
.1b73	d0 03		bne $1b78			bne 	_CCNotCurrent
.1b75	9c 5d 04	stz $045d			stz 	currentChannel 				; effectively disables CMD
.1b78					_CCNotCurrent:
.1b78	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1b7b	4c 2f 08	jmp $082f			jmp 	NextCommand
.1b7e					CommandExit:
.1b7e	fa		plx				plx
.1b7f	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1b81	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1b84					CommandDebug:
.1b84	fa		plx				plx
>1b85	db						.byte 	$DB 						; causes a break in the emulator
.1b86	4c 2f 08	jmp $082f			jmp 	NextCommand
.1b89					XGetCharacterFromChannel:
.1b89	da		phx				phx
.1b8a	5a		phy				phy
.1b8b	e0 00		cpx #$00			cpx 	#0 							; is it default
.1b8d	d0 05		bne $1b94			bne 	_XGetChannel
.1b8f	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1b92	80 08		bra $1b9c			bra 	_XGetChar
.1b94					_XGetChannel:
.1b94	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1b97	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1b9a	d0 06		bne $1ba2			bne 	_XGCError
.1b9c					_XGetChar:
.1b9c	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1b9f	7a		ply				ply
.1ba0	fa		plx				plx
.1ba1	60		rts				rts
.1ba2					_XGCError:
.1ba2	4c d1 1f	jmp $1fd1		jmp	ErrorV_channel
.1ba5					XGetHPos:
.1ba5	da		phx				phx
.1ba6	5a		phy				phy
.1ba7	38		sec				sec
.1ba8	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1bab	98		tya				tya
.1bac	7a		ply				ply
.1bad	fa		plx				plx
.1bae	60		rts				rts
.1baf					X16I2CPoke:
.1baf	fa		plx				plx
.1bb0	5a		phy				phy
.1bb1	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; value
.1bb4	48		pha				pha
.1bb5	ca		dex				dex
.1bb6	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; register
.1bb9	48		pha				pha
.1bba	ca		dex				dex
.1bbb	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; device
.1bbe	aa		tax				tax
.1bbf	7a		ply				ply
.1bc0	68		pla				pla
.1bc1	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1bc4	b0 06		bcs $1bcc			bcs 	X16I2CError
.1bc6	7a		ply				ply
.1bc7	a2 ff		ldx #$ff			ldx 	#$FF
.1bc9	4c 2f 08	jmp $082f			jmp 	NextCommand
.1bcc					X16I2CError:
.1bcc	4c d1 1f	jmp $1fd1		jmp	ErrorV_channel
.1bcf					X16I2CPeek:
.1bcf	fa		plx				plx
.1bd0	da		phx				phx
.1bd1	5a		phy				phy
.1bd2	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; register
.1bd5	48		pha				pha
.1bd6	ca		dex				dex
.1bd7	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; device
.1bda	aa		tax				tax 								; X device
.1bdb	7a		ply				ply 								; Y register
.1bdc	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1bdf	b0 eb		bcs $1bcc			bcs 	X16I2CError
.1be1	7a		ply				ply 								; restore Y/X
.1be2	fa		plx				plx
.1be3	ca		dex				dex 								; drop TOS (register)
.1be4	20 1a 26	jsr $261a			jsr 	FloatSetByte 				; write read value to TOS.
.1be7	4c 2f 08	jmp $082f			jmp 	NextCommand
.1bea					CommandXOpen:
.1bea	fa		plx				plx
.1beb	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1bed	85 2c		sta $2c				sta 	zTemp0
.1bef	aa		tax				tax
.1bf0	a5 4d		lda $4d				lda 	NSMantissa1+3
.1bf2	85 2d		sta $2d				sta 	zTemp0+1
.1bf4	a8		tay				tay
.1bf5	e8		inx				inx 								; XY points to first character
.1bf6	d0 01		bne $1bf9			bne 	_CONoCarry
.1bf8	c8		iny				iny
.1bf9					_CONoCarry:
.1bf9	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1bfb	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1bfe	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c00	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c02	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c04	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c07	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c0a	b0 03		bcs $1c0f			bcs 	_COError
.1c0c	4c 2f 08	jmp $082f			jmp 	NextCommand
.1c0f					_COError:
.1c0f	4c d1 1f	jmp $1fd1		jmp	ErrorV_channel
.1c12					XPokeMemory:
.1c12	86 2c		stx $2c				stx 	zTemp0
.1c14	84 2d		sty $2d				sty 	zTemp0+1
.1c16	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c18	ae 6b 05	ldx $056b			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c1b	e0 ff		cpx #$ff			cpx 	#$FF
.1c1d	f0 02		beq $1c21			beq 	_XPMNoSwitch
.1c1f	86 00		stx $00				stx 	SelectRAMBank
.1c21					_XPMNoSwitch:
.1c21	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1c23	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1c25					_XPMExit:
.1c25	60		rts				rts
.1c26					XPeekMemory:
.1c26	86 2c		stx $2c				stx 	zTemp0
.1c28	84 2d		sty $2d				sty 	zTemp0+1
.1c2a	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c2c	ae 6b 05	ldx $056b			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c2f	e0 ff		cpx #$ff			cpx 	#$FF
.1c31	f0 02		beq $1c35			beq 	_XPMNoSwitch
.1c33	86 00		stx $00				stx 	SelectRAMBank
.1c35					_XPMNoSwitch:
.1c35	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1c37	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1c39	60		rts				rts
.1c3a					CommandBank:
.1c3a	fa		plx				plx
.1c3b	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1c3d	8d 6b 05	sta $056b			sta 	ramBank 					; store & make current
.1c40	85 00		sta $00				sta 	SelectRAMBank
.1c42	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1c44	c9 ff		cmp #$ff			cmp 	#$FF
.1c46	f0 03		beq $1c4b			beq 	_CBNoUpdate
.1c48	8d 6c 05	sta $056c			sta 	romBank 					; this doesn't set the hardware page.
.1c4b					_CBNoUpdate:
.1c4b	a2 ff		ldx #$ff			ldx 	#$FF
.1c4d	4c 2f 08	jmp $082f			jmp 	NextCommand
.056b					ramBank:
>056b							.fill 	1
.056c					romBank:
>056c							.fill 	1
.1c50					XPrintCharacterToChannel:
.1c50	48		pha				pha
.1c51	da		phx				phx
.1c52	5a		phy				phy
.1c53	48		pha				pha  								; save char
.1c54	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1c56	d0 05		bne $1c5d			bne 	_XPCNotDefault
.1c58	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1c5b	80 08		bra $1c65			bra 	_XPCSend
.1c5d					_XPCNotDefault:
.1c5d	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1c60	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1c63	d0 08		bne $1c6d			bne 	_XPCError
.1c65					_XPCSend:
.1c65	68		pla				pla 								; restore character
.1c66	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1c69	7a		ply				ply
.1c6a	fa		plx				plx
.1c6b	68		pla				pla
.1c6c	60		rts				rts
.1c6d					_XPCError:
.1c6d	4c d1 1f	jmp $1fd1		jmp	ErrorV_channel
.1c70					XReadClock:
.1c70	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1c73	60		rts				rts
.1c74					XWriteClock:
.1c74	48		pha				pha
.1c75	da		phx				phx
.1c76	5a		phy				phy
.1c77	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1c7a	7a		ply				ply
.1c7b	fa		plx				plx
.1c7c	68		pla				pla
.1c7d	60		rts				rts
.1c7e					CommandScreen:
.1c7e	fa		plx				plx
.1c7f	da		phx				phx
.1c80	5a		phy				phy
.1c81	20 0b 10	jsr $100b			jsr 	GetInteger8Bit
.1c84	18		clc				clc
.1c85	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1c88	7a		ply				ply
.1c89	fa		plx				plx
.1c8a	4c 2f 08	jmp $082f			jmp 	NextCommand
.1c8d					XCommandSleep:
.1c8d	fa		plx				plx
.1c8e	5a		phy				phy
.1c8f	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.1c92	ca		dex				dex
.1c93	20 70 1c	jsr $1c70			jsr 	XReadClock 					; read clock to YXA
.1c96	18		clc				clc 								; calculate end time in zTemp0
.1c97	65 3e		adc $3e				adc 	NSMantissa0
.1c99	85 2c		sta $2c				sta 	zTemp0
.1c9b	8a		txa				txa
.1c9c	65 4a		adc $4a				adc 	NSMantissa1
.1c9e	85 2d		sta $2d				sta 	zTemp0+1
.1ca0					_XCWait:
.1ca0	20 70 1c	jsr $1c70			jsr 	XReadClock 					; and wait for it.
.1ca3	c5 2c		cmp $2c				cmp 	zTemp0
.1ca5	d0 f9		bne $1ca0			bne 	_XCWait
.1ca7	e4 2d		cpx $2d				cpx 	zTemp0+1
.1ca9	d0 f5		bne $1ca0			bne 	_XCWait
.1cab	a2 ff		ldx #$ff			ldx 	#$FF
.1cad	7a		ply				ply
.1cae	4c 2f 08	jmp $082f			jmp 	NextCommand
.1cb1					X16_Audio_FMINIT:
.1cb1	fa		plx				plx
.1cb2	5a		phy			phy
.1cb3	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cb6	63 c0					.word	X16A_ym_init
>1cb8	0a					.byte	X16_AudioCodeBank
.1cb9	a2 ff		ldx #$ff		ldx	#$FF
.1cbb	7a		ply			ply
.1cbc	4c 2f 08	jmp $082f			jmp 	NextCommand
.1cbf					X16_Audio_FMNOTE:
.1cbf	fa		plx				plx
.1cc0	5a		phy			phy
.1cc1	20 d6 09	jsr $09d6		jsr		X16_Audio_Parameters8_8
.1cc4	18		clc			clc
.1cc5	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cc8	03 c0					.word	X16A_bas_fmnote
>1cca	0a					.byte	X16_AudioCodeBank
.1ccb	a2 ff		ldx #$ff		ldx	#$FF
.1ccd	7a		ply			ply
.1cce	4c 2f 08	jmp $082f			jmp 	NextCommand
.1cd1					X16_Audio_FMDRUM:
.1cd1	fa		plx				plx
.1cd2	5a		phy			phy
.1cd3	20 d6 09	jsr $09d6		jsr		X16_Audio_Parameters8_8
.1cd6	18		clc			clc
.1cd7	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cda	6f c0					.word	X16A_ym_playdrum
>1cdc	0a					.byte	X16_AudioCodeBank
.1cdd	a2 ff		ldx #$ff		ldx	#$FF
.1cdf	7a		ply			ply
.1ce0	4c 2f 08	jmp $082f			jmp 	NextCommand
.1ce3					X16_Audio_FMINST:
.1ce3	fa		plx				plx
.1ce4	5a		phy			phy
.1ce5	20 d6 09	jsr $09d6		jsr		X16_Audio_Parameters8_8
.1ce8	38		sec			sec
.1ce9	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cec	69 c0					.word	X16A_ym_loadpatch
>1cee	0a					.byte	X16_AudioCodeBank
.1cef	a2 ff		ldx #$ff		ldx	#$FF
.1cf1	7a		ply			ply
.1cf2	4c 2f 08	jmp $082f			jmp 	NextCommand
.1cf5					X16_Audio_FMVIB:
.1cf5	fa		plx				plx
.1cf6	5a		phy			phy
.1cf7	20 d6 09	jsr $09d6		jsr		X16_Audio_Parameters8_8
.1cfa	18		clc			clc
.1cfb	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cfe	09 c0					.word	X16A_bas_fmvib
>1d00	0a					.byte	X16_AudioCodeBank
.1d01	a2 ff		ldx #$ff		ldx	#$FF
.1d03	7a		ply			ply
.1d04	4c 2f 08	jmp $082f			jmp 	NextCommand
.1d07					X16_Audio_FMFREQ:
.1d07	fa		plx				plx
.1d08	5a		phy			phy
.1d09	20 d0 09	jsr $09d0		jsr		X16_Audio_Parameters8_16
.1d0c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d0f	00 c0					.word	X16A_bas_fmfreq
>1d11	0a					.byte	X16_AudioCodeBank
.1d12	a2 ff		ldx #$ff		ldx	#$FF
.1d14	7a		ply			ply
.1d15	4c 2f 08	jmp $082f			jmp 	NextCommand
.1d18					X16_Audio_FMVOL:
.1d18	fa		plx				plx
.1d19	5a		phy			phy
.1d1a	20 d6 09	jsr $09d6		jsr		X16_Audio_Parameters8_8
.1d1d	18		clc			clc
.1d1e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d21	75 c0					.word	X16A_ym_setatten
>1d23	0a					.byte	X16_AudioCodeBank
.1d24	a2 ff		ldx #$ff		ldx	#$FF
.1d26	7a		ply			ply
.1d27	4c 2f 08	jmp $082f			jmp 	NextCommand
.1d2a					X16_Audio_FMPAN:
.1d2a	fa		plx				plx
.1d2b	5a		phy			phy
.1d2c	20 d6 09	jsr $09d6		jsr		X16_Audio_Parameters8_8
.1d2f	18		clc			clc
.1d30	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d33	7e c0					.word	X16A_ym_setpan
>1d35	0a					.byte	X16_AudioCodeBank
.1d36	a2 ff		ldx #$ff		ldx	#$FF
.1d38	7a		ply			ply
.1d39	4c 2f 08	jmp $082f			jmp 	NextCommand
.1d3c					X16_Audio_FMPLAY:
.1d3c	fa		plx				plx
.1d3d	5a		phy			phy
.1d3e	20 e7 09	jsr $09e7		jsr		X16_Audio_Parameters8_String
.1d41	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d44	06 c0					.word	X16A_bas_fmplaystring
>1d46	0a					.byte	X16_AudioCodeBank
.1d47	a2 ff		ldx #$ff		ldx	#$FF
.1d49	7a		ply			ply
.1d4a	4c 2f 08	jmp $082f			jmp 	NextCommand
.1d4d					X16_Audio_FMCHORD:
.1d4d	fa		plx				plx
.1d4e	5a		phy			phy
.1d4f	20 e7 09	jsr $09e7		jsr		X16_Audio_Parameters8_String
.1d52	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d55	8d c0					.word	X16A_bas_fmchordstring
>1d57	0a					.byte	X16_AudioCodeBank
.1d58	a2 ff		ldx #$ff		ldx	#$FF
.1d5a	7a		ply			ply
.1d5b	4c 2f 08	jmp $082f			jmp 	NextCommand
.1d5e					X16_Audio_FMPOKE:
.1d5e	fa		plx				plx
.1d5f	5a		phy			phy
.1d60	20 d6 09	jsr $09d6		jsr		X16_Audio_Parameters8_8
.1d63	18		clc			clc
.1d64	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d67	8a c0					.word	X16A_ym_write
>1d69	0a					.byte	X16_AudioCodeBank
.1d6a	a2 ff		ldx #$ff		ldx	#$FF
.1d6c	7a		ply			ply
.1d6d	4c 2f 08	jmp $082f			jmp 	NextCommand
.1d70					X16_Audio_PSGINIT:
.1d70	fa		plx				plx
.1d71	5a		phy			phy
.1d72	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d75	4b c0					.word	X16A_psg_init
>1d77	0a					.byte	X16_AudioCodeBank
.1d78	a2 ff		ldx #$ff		ldx	#$FF
.1d7a	7a		ply			ply
.1d7b	4c 2f 08	jmp $082f			jmp 	NextCommand
.1d7e					X16_Audio_PSGNOTE:
.1d7e	fa		plx				plx
.1d7f	5a		phy			phy
.1d80	20 d6 09	jsr $09d6		jsr		X16_Audio_Parameters8_8
.1d83	18		clc			clc
.1d84	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d87	12 c0					.word	X16A_bas_psgnote
>1d89	0a					.byte	X16_AudioCodeBank
.1d8a	a2 ff		ldx #$ff		ldx	#$FF
.1d8c	7a		ply			ply
.1d8d	4c 2f 08	jmp $082f			jmp 	NextCommand
.1d90					X16_Audio_PSGVOL:
.1d90	fa		plx				plx
.1d91	5a		phy			phy
.1d92	20 d6 09	jsr $09d6		jsr		X16_Audio_Parameters8_8
.1d95	18		clc			clc
.1d96	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d99	54 c0					.word	X16A_psg_setatten
>1d9b	0a					.byte	X16_AudioCodeBank
.1d9c	a2 ff		ldx #$ff		ldx	#$FF
.1d9e	7a		ply			ply
.1d9f	4c 2f 08	jmp $082f			jmp 	NextCommand
.1da2					X16_Audio_PSGWAV:
.1da2	fa		plx				plx
.1da3	5a		phy			phy
.1da4	20 d6 09	jsr $09d6		jsr		X16_Audio_Parameters8_8
.1da7	18		clc			clc
.1da8	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dab	15 c0					.word	X16A_bas_psgwav
>1dad	0a					.byte	X16_AudioCodeBank
.1dae	a2 ff		ldx #$ff		ldx	#$FF
.1db0	7a		ply			ply
.1db1	4c 2f 08	jmp $082f			jmp 	NextCommand
.1db4					X16_Audio_PSGFREQ:
.1db4	fa		plx				plx
.1db5	5a		phy			phy
.1db6	20 d0 09	jsr $09d0		jsr		X16_Audio_Parameters8_16
.1db9	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dbc	0f c0					.word	X16A_bas_psgfreq
>1dbe	0a					.byte	X16_AudioCodeBank
.1dbf	a2 ff		ldx #$ff		ldx	#$FF
.1dc1	7a		ply			ply
.1dc2	4c 2f 08	jmp $082f			jmp 	NextCommand
.1dc5					X16_Audio_PSGPAN:
.1dc5	fa		plx				plx
.1dc6	5a		phy			phy
.1dc7	20 d6 09	jsr $09d6		jsr		X16_Audio_Parameters8_8
.1dca	18		clc			clc
.1dcb	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dce	5a c0					.word	X16A_psg_setpan
>1dd0	0a					.byte	X16_AudioCodeBank
.1dd1	a2 ff		ldx #$ff		ldx	#$FF
.1dd3	7a		ply			ply
.1dd4	4c 2f 08	jmp $082f			jmp 	NextCommand
.1dd7					X16_Audio_PSGPLAY:
.1dd7	fa		plx				plx
.1dd8	5a		phy			phy
.1dd9	20 e7 09	jsr $09e7		jsr		X16_Audio_Parameters8_String
.1ddc	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1ddf	18 c0					.word	X16A_bas_psgplaystring
>1de1	0a					.byte	X16_AudioCodeBank
.1de2	a2 ff		ldx #$ff		ldx	#$FF
.1de4	7a		ply			ply
.1de5	4c 2f 08	jmp $082f			jmp 	NextCommand
.1de8					X16_Audio_PSGCHORD:
.1de8	fa		plx				plx
.1de9	5a		phy			phy
.1dea	20 e7 09	jsr $09e7		jsr		X16_Audio_Parameters8_String
.1ded	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1df0	90 c0					.word	X16A_bas_psgchordstring
>1df2	0a					.byte	X16_AudioCodeBank
.1df3	a2 ff		ldx #$ff		ldx	#$FF
.1df5	7a		ply			ply
.1df6	4c 2f 08	jmp $082f			jmp 	NextCommand
.1df9					CommandCls:
.1df9	fa		plx				plx
.1dfa	a9 93		lda #$93			lda 	#147
.1dfc	20 50 1c	jsr $1c50			jsr 	XPrintCharacterToChannel
.1dff	4c 2f 08	jmp $082f			jmp 	NextCommand
.1e02					CommandLocate:
.1e02	fa		plx				plx
.1e03	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.1e06	ca		dex				dex
.1e07	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.1e0a	ca		dex				dex
.1e0b	a9 13		lda #$13			lda 	#$13 						; home.
.1e0d	20 50 1c	jsr $1c50			jsr 	XPrintCharacterToChannel
.1e10	a9 1d		lda #$1d			lda 	#$1D 						; do cursor rights
.1e12	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1e14	20 21 1e	jsr $1e21			jsr 	_CLOutputXA
.1e17	a9 11		lda #$11			lda 	#$11 						; do cursor downs.
.1e19	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e1b	20 21 1e	jsr $1e21			jsr 	_CLOutputXA
.1e1e	4c 2f 08	jmp $082f			jmp 	NextCommand
.1e21					_CLOutputXA:
.1e21	ca		dex				dex
.1e22	f0 07		beq $1e2b			beq 	_CLOExit
.1e24	30 05		bmi $1e2b			bmi 	_CLOExit
.1e26	20 50 1c	jsr $1c50			jsr 	XPrintCharacterToChannel
.1e29	80 f6		bra $1e21			bra 	_CLOutputXA
.1e2b					_CLOExit:
.1e2b	60		rts				rts
.1e2c					CommandColor:
.1e2c	fa		plx				plx
.1e2d	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.1e30	ca		dex				dex
.1e31	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.1e34	ca		dex				dex
.1e35	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1e37	c9 ff		cmp #$ff			cmp 	#$FF
.1e39	f0 08		beq $1e43			beq 	_CCNoBGR 					; if so, change background
.1e3b	20 4b 1e	jsr $1e4b			jsr 	_CCSetColour
.1e3e	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1e40	20 50 1c	jsr $1c50			jsr 	XPrintCharacterToChannel
.1e43					_CCNoBGR:
.1e43	a5 3e		lda $3e				lda 	NSMantissa0
.1e45	20 4b 1e	jsr $1e4b			jsr 	_CCSetColour
.1e48	4c 2f 08	jmp $082f			jmp 	NextCommand
.1e4b					_CCSetColour:
.1e4b	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1e4d	aa		tax				tax
.1e4e	bd 55 1e	lda $1e55,x			lda 	_CCCommandTable,x
.1e51	20 50 1c	jsr $1c50			jsr 	XPrintCharacterToChannel
.1e54	60		rts				rts
.1e55					_CCCommandTable:
>1e55	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1e5d	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1e65					CommandVPOKE:
.1e65	fa		plx				plx
.1e66	20 0b 10	jsr $100b			jsr 	GetInteger8Bit 				; poke value
.1e69	48		pha				pha
.1e6a	ca		dex				dex
.1e6b	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.1e6e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e70	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1e73	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1e75	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1e78	ca		dex				dex
.1e79	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.1e7c	20 0b 10	jsr $100b			jsr 	GetInteger8Bit
.1e7f	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1e82	ca		dex				dex
.1e83	68		pla				pla 								; poke value back
.1e84	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1e87	4c 2f 08	jmp $082f			jmp 	NextCommand
.1e8a					CommandVPEEK:
.1e8a	fa		plx				plx
.1e8b	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.1e8e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e90	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1e93	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1e95	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1e98	ca		dex				dex
.1e99	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.1e9c	20 0b 10	jsr $100b			jsr 	GetInteger8Bit
.1e9f	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1ea2	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1ea5	20 1a 26	jsr $261a			jsr 	FloatSetByte 				; return as byte
.1ea8	4c 2f 08	jmp $082f			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1eab					SetErrorHandler:
.1eab	8c 6e 05	sty $056e			sty 	ErrorHandlerVector+1
.1eae	8e 6d 05	stx $056d			stx 	ErrorHandlerVector
.1eb1	60		rts				rts
.1eb2					CallErrorHandler:
.1eb2	6c 6d 05	jmp ($056d)			jmp 	(ErrorHandlerVector)
.056d					ErrorHandlerVector:
>056d							.fill 	2
.1eb5					ErrorV_range:
.1eb5	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1eb8	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1ec0	41 4e 47 45 00
.1ec5					ErrorV_value:
.1ec5	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1ec8	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1ed0	45 00
.1ed2					ErrorV_syntax:
.1ed2	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1ed5	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1edd	52 52 4f 52 00
.1ee2					ErrorV_type:
.1ee2	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1ee5	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1eed	4d 41 54 43 48 00
.1ef3					ErrorV_unimplemented:
.1ef3	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1ef6	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1efe	45 4d 45 4e 54 45 44 00
.1f06					ErrorV_assert:
.1f06	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1f09	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f11	41 49 4c 00
.1f15					ErrorV_line:
.1f15	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1f18	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f20	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f2c					ErrorV_internal:
.1f2c	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1f2f	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f37	20 45 52 52 4f 52 00
.1f3e					ErrorV_divzero:
.1f3e	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1f41	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1f49	59 20 5a 45 52 4f 00
.1f50					ErrorV_structure:
.1f50	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1f53	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1f5b	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1f67					ErrorV_stop:
.1f67	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1f6a	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1f72	53 54 4f 50 50 45 44 00
.1f7a					ErrorV_data:
.1f7a	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1f7d	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1f85	41 54 41 00
.1f89					ErrorV_undeclared:
.1f89	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1f8c	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1f94	41 52 52 41 59 00
.1f9a					ErrorV_redefine:
.1f9a	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1f9d	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1fa5	44 45 46 49 4e 45 44 00
.1fad					ErrorV_index:
.1fad	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1fb0	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1fb8	59 20 49 4e 44 45 58 00
.1fc0					ErrorV_memory:
.1fc0	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1fc3	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>1fcb	45 4d 4f 52 59 00
.1fd1					ErrorV_channel:
.1fd1	20 b2 1e	jsr $1eb2		jsr	CallErrorHandler
>1fd4	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>1fdc	54 50 55 54 20 45 52 52 4f 52 00
.1fe7					MoveObjectForward:
.1fe7	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.1fe9	c9 ff		cmp #$ff			cmp 	#$FF
.1feb	f0 36		beq $2023			beq 	_MOFEnd
.1fed	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.1fef	90 24		bcc $2015			bcc 	_MOFAdvance1 				; forward 1
.1ff1	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.1ff3	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.1ff5	90 20		bcc $2017			bcc 	_MOFAdvanceY
.1ff7	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.1ff9	90 1a		bcc $2015			bcc 	_MOFAdvance1 				; forward 1
.1ffb	a8		tay				tay 								; read the size.
.1ffc	b9 61 1f	lda $1f61,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.1fff	a8		tay				tay
.2000	c8		iny				iny 								; add 1 for the system token.
.2001	d0 14		bne $2017			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2003	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2005	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2007	a8		tay				tay 								; into Y.
.2008	18		clc				clc
.2009	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.200b	69 02		adc #$02			adc 	#2
.200d	85 2a		sta $2a				sta 	objPtr
.200f	90 02		bcc $2013			bcc 	_MOFNoCarry1
.2011	e6 2b		inc $2b				inc 	objPtr+1
.2013					_MOFNoCarry1:
.2013	80 02		bra $2017			bra 	_MOFAdvanceY
.2015					_MOFAdvance1:
.2015	a0 01		ldy #$01			ldy 	#1
.2017					_MOFAdvanceY:
.2017	98		tya				tya 								; add Y to objPtr
.2018	18		clc				clc
.2019	65 2a		adc $2a				adc 	objPtr
.201b	85 2a		sta $2a				sta 	objPtr
.201d	90 02		bcc $2021			bcc 	_MOFNoCarry2
.201f	e6 2b		inc $2b				inc 	objPtr+1
.2021					_MOFNoCarry2:
.2021	18		clc				clc 								; not completed.
.2022	60		rts				rts
.2023					_MOFEnd:
.2023	e6 2a		inc $2a				inc 	objPtr
.2025	d0 02		bne $2029			bne 	_MOFENoCarry
.2027	e6 2b		inc $2b				inc 	objPtr+1
.2029					_MOFENoCarry:
.2029	38		sec				sec
.202a	60		rts				rts
.202b					MOFSizeTable:
>202b	01					.byte	1         	; $ca .shift
>202c	01					.byte	1         	; $cb .byte
>202d	02					.byte	2         	; $cc .word
>202e	05					.byte	5         	; $cd .float
>202f	ff					.byte	255       	; $ce .string
>2030	ff					.byte	255       	; $cf .data
>2031	02					.byte	2         	; $d0 .goto
>2032	02					.byte	2         	; $d1 .gosub
>2033	02					.byte	2         	; $d2 .goto.z
>2034	02					.byte	2         	; $d3 .goto.nz
>2035	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.056f					numberBuffer:
>056f							.fill 	34
.2036					FloatSubtract:
.2036	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.2038	49 80		eor #$80			eor 	#$80
.203a	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.203c					FloatAdd:
.203c	ca		dex				dex
.203d	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.203f	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2041	15 62		ora $62,x			ora 	NSMantissa3,x
.2043	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2045	d0 04		bne $204b			bne 	_FAUseFloat
.2047	20 d8 23	jsr $23d8			jsr 	FloatInt32Add 				; use the int32 one.
.204a	60		rts				rts
.204b					_FAUseFloat:
.204b	20 6d 23	jsr $236d			jsr 	FloatNormalise 				; normalise S[X]
.204e	f0 51		beq $20a1			beq 	_FAReturn1
.2050	e8		inx				inx 								; normalise S[X+1]
.2051	20 6d 23	jsr $236d			jsr 	FloatNormalise
.2054	ca		dex				dex
.2055	c9 00		cmp #$00			cmp 	#0
.2057	f0 60		beq $20b9			beq 	_FAExit 					; if so, just return A
.2059	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.205b	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.205d	f0 18		beq $2077			beq 	_FAExponentsEqual
.205f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.2061	a8		tay				tay
.2062	38		sec				sec 								; do a signed comparison of the exponents.
.2063	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.2065	50 02		bvc $2069			bvc 	_FANoSignedChange
.2067	49 80		eor #$80			eor 	#$80
.2069					_FANoSignedChange:
.2069	29 80		and #$80			and 	#$80
.206b	10 02		bpl $206f			bpl 	_FAHaveMax
.206d	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.206f					_FAHaveMax:
.206f	20 ba 20	jsr $20ba			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.2072	e8		inx				inx
.2073	20 ba 20	jsr $20ba			jsr 	_FAShiftToExponent
.2076	ca		dex				dex
.2077					_FAExponentsEqual:
.2077	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.2079	55 33		eor $33,x			eor 	NSStatus+1,x
.207b	30 0e		bmi $208b			bmi 	_FADifferentSigns
.207d	20 a4 23	jsr $23a4			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.2080	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.2082	10 35		bpl $20b9			bpl 	_FAExit 					; if no, we are done.
.2084	20 31 26	jsr $2631			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.2087	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.2089	80 2e		bra $20b9			bra 	_FAExit
.208b					_FADifferentSigns:
.208b	20 be 23	jsr $23be			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.208e	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.2090	10 06		bpl $2098			bpl 	_FACheckZero 				; if no, check for -0
.2092	20 da 25	jsr $25da			jsr 	FloatNegate 					; netate result
.2095	20 e1 25	jsr $25e1			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.2098					_FACheckZero:
.2098	20 3a 26	jsr $263a			jsr 	FloatIsZero	 				; check for -0
.209b	d0 1c		bne $20b9			bne 	_FAExit
.209d	74 32		stz $32,x			stz 	NSStatus,x
.209f	80 18		bra $20b9			bra 	_FAExit
.20a1					_FAReturn1:
.20a1	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20a3	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20a5	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.20a7	95 4a		sta $4a,x			sta 	NSMantissa1,x
.20a9	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.20ab	95 56		sta $56,x			sta 	NSMantissa2,x
.20ad	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.20af	95 62		sta $62,x			sta 	NSMantissa3,x
.20b1	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.20b3	95 6e		sta $6e,x			sta 	NSExponent,x
.20b5	b5 33		lda $33,x			lda 	NSStatus+1,x
.20b7	95 32		sta $32,x			sta 	NSStatus,x
.20b9					_FAExit:
.20b9	60		rts				rts
.20ba					_FAShiftToExponent:
.20ba					_FAShiftToExponent2:
.20ba	98		tya				tya 								; compare Y to exponent
.20bb	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.20bd	f0 07		beq $20c6			beq 	_FASEExit 					; exit if so.
.20bf	20 31 26	jsr $2631			jsr 	FloatShiftRight	 			; shift the mantissa right
.20c2	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.20c4	80 f4		bra $20ba			bra 	_FAShiftToExponent2
.20c6					_FASEExit:
.20c6	60		rts				rts
.20c7					CompareEqual:
.20c7	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20c9	d0 09		bne $20d4			bne 	ReturnFalse
.20cb					ReturnTrue:
.20cb	a9 01		lda #$01			lda 	#1
.20cd	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20cf	a9 80		lda #$80			lda 	#$80
.20d1	95 32		sta $32,x			sta 	NSStatus,x
.20d3	60		rts				rts
.20d4					ReturnFalse:
.20d4	74 3e		stz $3e,x			stz 	NSMantissa0,x
.20d6	60		rts				rts
.20d7					CompareNotEqual:
.20d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20d9	d0 f0		bne $20cb			bne 	ReturnTrue
.20db	80 f7		bra $20d4			bra 	ReturnFalse
.20dd					CompareLess:
.20dd	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20df	c9 ff		cmp #$ff			cmp 	#$FF
.20e1	f0 e8		beq $20cb			beq 	ReturnTrue
.20e3	80 ef		bra $20d4			bra 	ReturnFalse
.20e5					CompareGreater:
.20e5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20e7	c9 01		cmp #$01			cmp 	#$01
.20e9	f0 e0		beq $20cb			beq 	ReturnTrue
.20eb	80 e7		bra $20d4			bra 	ReturnFalse
.20ed					CompareLessEqual:
.20ed	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20ef	c9 01		cmp #$01			cmp 	#$01
.20f1	d0 d8		bne $20cb			bne 	ReturnTrue
.20f3	80 df		bra $20d4			bra 	ReturnFalse
.20f5					CompareGreaterEqual:
.20f5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20f7	c9 ff		cmp #$ff			cmp 	#$FF
.20f9	d0 d0		bne $20cb			bne 	ReturnTrue
.20fb	80 d7		bra $20d4			bra 	ReturnFalse
.20fd					FloatCompare:
.20fd	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.20ff	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.2101	48		pha				pha
.2102	20 36 20	jsr $2036			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2105	68		pla				pla
.2106	d0 0c		bne $2114			bne 	_FCCompareFloat
.2108	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.210a	15 4a		ora $4a,x			ora 	NSMantissa1,x
.210c	15 56		ora $56,x			ora 	NSMantissa2,x
.210e	15 62		ora $62,x			ora 	NSMantissa3,x
.2110	f0 14		beq $2126			beq 	_FCExit 					; if zero, return zero
.2112	80 0a		bra $211e			bra 	_FCSign
.2114					_FCCompareFloat:
.2114	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2116	29 f0		and #$f0			and 	#$F0
.2118	15 56		ora $56,x			ora 	NSMantissa2,x
.211a	15 62		ora $62,x			ora 	NSMantissa3,x
.211c	f0 08		beq $2126			beq 	_FCExit 					; zero, so approximately identical
.211e					_FCSign:
.211e	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2120	34 32		bit $32,x			bit 	NSStatus,x
.2122	10 02		bpl $2126			bpl 	_FCExit
.2124					_FCNegative:
.2124	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2126					_FCExit:
.2126	20 1a 26	jsr $261a			jsr 	FloatSetByte 				; set the result 255,0,1
.2129	60		rts				rts
.212a					FloatScalarTable:
>212a	66 66 66 66				.dword $66666666 ; 0.1
>212e	de					.byte $de
>212f	1f 85 eb 51				.dword $51eb851f ; 0.01
>2133	db					.byte $db
>2134	4c 37 89 41				.dword $4189374c ; 0.001
>2138	d8					.byte $d8
>2139	ac 8b db 68				.dword $68db8bac ; 0.0001
>213d	d4					.byte $d4
>213e	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>2142	d1					.byte $d1
>2143	83 de 1b 43				.dword $431bde83 ; 1e-06
>2147	ce					.byte $ce
>2148	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>214c	ca					.byte $ca
>214d	89 3b e6 55				.dword $55e63b89 ; 1e-08
>2151	c7					.byte $c7
>2152	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>2156	c4					.byte $c4
>2157	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>215b	c0					.byte $c0
>215c	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>2160	bd					.byte $bd
.2161					FloatDivide:
.2161	48		pha				pha
.2162	20 6d 23	jsr $236d			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2165	ca		dex				dex
.2166	c9 00		cmp #$00			cmp 	#0
.2168	f0 1e		beq $2188			beq 	_FDZero
.216a	20 6d 23	jsr $236d			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.216d	f0 16		beq $2185			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.216f	20 d0 21	jsr $21d0			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.2172	20 9d 21	jsr $219d			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.2175	20 6d 23	jsr $236d			jsr		FloatNormalise 				; renormalise
.2178	20 63 23	jsr $2363			jsr 	FloatCalculateSign 			; calculate result sign
.217b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.217d	38		sec				sec
.217e	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.2180	38		sec				sec
.2181	e9 1e		sbc #$1e			sbc 	#30
.2183	95 6e		sta $6e,x			sta 	NSExponent,x
.2185					_FDExit:
.2185	68		pla				pla
.2186	18		clc				clc
.2187	60		rts				rts
.2188					_FDZero:
.2188	68		pla				pla
.2189	38		sec				sec
.218a	60		rts				rts
.218b					DivideInt32:
.218b	20 53 22	jsr $2253			jsr 	FloatIntegerPart 			; make both integers
.218e	ca		dex				dex
.218f	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.2192	20 ae 21	jsr $21ae			jsr 	Int32Divide 				; divide
.2195	20 9d 21	jsr $219d			jsr 	NSMCopyPlusTwoToZero 		; copy result
.2198	20 63 23	jsr $2363			jsr 	FloatCalculateSign 			; calculate result sign
.219b	18		clc				clc
.219c	60		rts				rts
.219d					NSMCopyPlusTwoToZero:
.219d	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.219f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21a1	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21a3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.21a5	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.21a7	95 56		sta $56,x			sta 	NSMantissa2,x
.21a9	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.21ab	95 62		sta $62,x			sta 	NSMantissa3,x
.21ad	60		rts				rts
.21ae					Int32Divide:
.21ae	48		pha				pha 								; save AXY
.21af	5a		phy				phy
.21b0	20 fb 25	jsr $25fb			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.21b3	20 14 26	jsr $2614			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.21b6	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.21b8					_I32DivideLoop:
.21b8	e8		inx				inx
.21b9	e8		inx				inx
.21ba	20 27 26	jsr $2627			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.21bd	ca		dex				dex
.21be	ca		dex				dex
.21bf	20 28 26	jsr $2628			jsr 	FloatRotateLeft
.21c2	20 ee 21	jsr $21ee			jsr 	FloatDivideCheck 			; check if subtract possible
.21c5	90 02		bcc $21c9			bcc 	_I32DivideNoCarryIn
.21c7	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.21c9					_I32DivideNoCarryIn:
.21c9	88		dey				dey 								; loop round till division completed.
.21ca	d0 ec		bne $21b8			bne 	_I32DivideLoop
.21cc	7a		ply				ply 								; restore AXY and exit
.21cd	68		pla				pla
.21ce	18		clc				clc
.21cf	60		rts				rts
.21d0					Int32ShiftDivide:
.21d0	48		pha				pha 								; save AY
.21d1	5a		phy				phy
.21d2	e8		inx				inx 								; clear S[X+2]
.21d3	e8		inx				inx
.21d4	20 18 26	jsr $2618			jsr 	FloatSetZero
.21d7	ca		dex				dex
.21d8	ca		dex				dex
.21d9	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.21db					_I32SDLoop:
.21db	20 ee 21	jsr $21ee			jsr 	FloatDivideCheck 			; check if subtract possible
.21de	e8		inx				inx
.21df	e8		inx				inx
.21e0	20 28 26	jsr $2628			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.21e3	ca		dex				dex
.21e4	ca		dex				dex
.21e5	20 28 26	jsr $2628			jsr 	FloatRotateLeft
.21e8	88		dey				dey 	 							; do 31 times
.21e9	d0 f0		bne $21db			bne 	_I32SDLoop
.21eb	7a		ply				ply 								; restore AY and exit
.21ec	68		pla				pla
.21ed	60		rts				rts
.21ee					FloatDivideCheck:
.21ee	20 be 23	jsr $23be			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.21f1	b0 04		bcs $21f7			bcs 	_DCSExit 					; if carry set, then could do, exit
.21f3	20 a4 23	jsr $23a4			jsr 	FloatAddTopTwoStack 		; add it back in
.21f6	18		clc				clc 								; and return False
.21f7					_DCSExit:
.21f7	60		rts				rts
.21f8					FloatFractionalPart:
.21f8	5a		phy				phy
.21f9	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.21fb	29 7f		and #$7f			and 	#$7F
.21fd	95 32		sta $32,x			sta 	NSStatus,x
.21ff	20 6d 23	jsr $236d			jsr 	FloatNormalise
.2202	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2204	38		sec				sec
.2205	e9 e0		sbc #$e0			sbc 	#$E0
.2207	90 29		bcc $2232			bcc 	_FFPExit 					; already fractional
.2209	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.220b	b0 22		bcs $222f			bcs 	_FFPZero
.220d	a8		tay				tay 								; put count to do in Y
.220e	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.2210	20 37 22	jsr $2237			jsr 	_FFPPartial
.2213	95 62		sta $62,x			sta 	NSMantissa3,x
.2215	b5 56		lda $56,x			lda 	NSMantissa2,x
.2217	20 37 22	jsr $2237			jsr 	_FFPPartial
.221a	95 56		sta $56,x			sta 	NSMantissa2,x
.221c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.221e	20 37 22	jsr $2237			jsr 	_FFPPartial
.2221	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2223	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2225	20 37 22	jsr $2237			jsr 	_FFPPartial
.2228	95 3e		sta $3e,x			sta 	NSMantissa0,x
.222a	20 3a 26	jsr $263a			jsr 	FloatIsZero 					; zeroed check.
.222d	d0 03		bne $2232			bne 	_FFPExit
.222f					_FFPZero:
.222f	20 18 26	jsr $2618			jsr 	FloatSetZero
.2232					_FFPExit:
.2232	20 6d 23	jsr $236d			jsr 	FloatNormalise
.2235	7a		ply				ply
.2236	60		rts				rts
.2237					_FFPPartial:
.2237	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2239	f0 17		beq $2252			beq 	_FFFPPExit
.223b	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.223d	b0 0c		bcs $224b			bcs 	_FFFPPWholeByte
.223f	5a		phy				phy
.2240					_FFFPPLeft:
.2240	0a		asl a				asl 	a
.2241	88		dey				dey
.2242	d0 fc		bne $2240			bne 	_FFFPPLeft
.2244	7a		ply				ply
.2245					_FFFPPRight:
.2245	4a		lsr a				lsr 	a
.2246	88		dey				dey
.2247	d0 fc		bne $2245			bne 	_FFFPPRight
.2249	80 07		bra $2252			bra 	_FFFPPExit
.224b					_FFFPPWholeByte:
.224b	98		tya				tya 								; subtract 8 from count
.224c	38		sec				sec
.224d	e9 08		sbc #$08			sbc 	#8
.224f	a8		tay				tay
.2250	a9 00		lda #$00			lda 	#0 							; and clear all
.2252					_FFFPPExit:
.2252	60		rts				rts
.2253					FloatIntegerPart:
.2253	48		pha				pha
.2254	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.2256	f0 1d		beq $2275			beq 	_FIPExit 					; if so do nothing
.2258	20 3a 26	jsr $263a			jsr 	FloatIsZero 				; is it zero ?
.225b	f0 15		beq $2272			beq 	_FIPZero 					; if so return zero.
.225d	20 6d 23	jsr $236d			jsr 	FloatNormalise 				; normalise
.2260	f0 10		beq $2272			beq 	_FIPZero 					; normalised to zero, exit zero
.2262					_FIPShift:
.2262	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2264	10 07		bpl $226d			bpl 	_FIPCheckZero
.2266	20 31 26	jsr $2631			jsr 	FloatShiftRight 			; shift mantissa right
.2269	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.226b	80 f5		bra $2262			bra 	_FIPShift
.226d					_FIPCheckZero:
.226d	20 3a 26	jsr $263a			jsr 	FloatIsZero 				; avoid -0 problem
.2270	d0 03		bne $2275			bne 	_FIPExit 					; set to zero if mantissa zero.
.2272					_FIPZero:
.2272	20 18 26	jsr $2618			jsr 	FloatSetZero
.2275					_FIPExit:
.2275	68		pla				pla
.2276	60		rts				rts
.2277					FloatIntegerPartDown:
.2277	48		pha				pha
.2278	5a		phy				phy
.2279	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.227b	f0 36		beq $22b3			beq 	_FIPExit 					; if so do nothing
.227d	20 3a 26	jsr $263a			jsr 	FloatIsZero 				; is it zero ?
.2280	f0 2e		beq $22b0			beq 	_FIPZero 					; if so return zero.
.2282	20 6d 23	jsr $236d			jsr 	FloatNormalise 				; normalise
.2285	f0 29		beq $22b0			beq 	_FIPZero 					; normalised to zero, exit zero
.2287	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.2289					_FIPShift:
.2289	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.228b	10 0a		bpl $2297			bpl 	_FIPCheckDown
.228d	20 31 26	jsr $2631			jsr 	FloatShiftRight 			; shift mantissa right
.2290	90 01		bcc $2293			bcc 	_FIPNoFrac 					; shifted a zero out ?
.2292	c8		iny				iny
.2293					_FIPNoFrac:
.2293	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.2295	80 f2		bra $2289			bra 	_FIPShift
.2297					_FIPCheckDown:
.2297	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.2299	f0 10		beq $22ab			beq 	_FIPCheckZero
.229b	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.229d	10 0c		bpl $22ab			bpl 	_FIPCheckZero
.229f	e8		inx				inx 								; -ve so round *down*.
.22a0	a9 01		lda #$01			lda 	#1
.22a2	20 1a 26	jsr $261a			jsr 	FloatSetByte
.22a5	20 da 25	jsr $25da			jsr 	FloatNegate
.22a8	20 3c 20	jsr $203c			jsr 	FloatAdd
.22ab					_FIPCheckZero:
.22ab	20 3a 26	jsr $263a			jsr 	FloatIsZero 				; avoid -0 problem
.22ae	d0 03		bne $22b3			bne 	_FIPExit 					; set to zero if mantissa zero.
.22b0					_FIPZero:
.22b0	20 18 26	jsr $2618			jsr 	FloatSetZero
.22b3					_FIPExit:
.22b3	7a		ply				ply
.22b4	68		pla				pla
.22b5	60		rts				rts
.22b6					FloatInt8Multiply:
.22b6	5a		phy				phy
.22b7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.22b9	a8		tay				tay
.22ba	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.22bc					_FI8MLoop:
.22bc	98		tya				tya 								; shift right shifter right into carry
.22bd	4a		lsr a				lsr 	a
.22be	a8		tay				tay
.22bf	90 0d		bcc $22ce			bcc 	_FI8MNoAdd
.22c1	18		clc				clc
.22c2	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.22c4	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.22c6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.22c8	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.22ca	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.22cc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.22ce					_FI8MNoAdd:
.22ce	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.22d0	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.22d2	c0 00		cpy #$00			cpy 	#0
.22d4	d0 e6		bne $22bc			bne 	_FI8MLoop 					; until right shifter zero.
.22d6	7a		ply				ply
.22d7	60		rts				rts
.22d8					FloatMultiply:
.22d8	ca		dex				dex
.22d9	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.22db	15 6f		ora $6f,x			ora 	NSExponent+1,x
.22dd	15 62		ora $62,x			ora 	NSMantissa3,x
.22df	15 63		ora $63,x			ora 	NSMantissa3+1,x
.22e1	d0 21		bne $2304			bne 	_FMUseFloat
.22e3	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.22e5	15 33		ora $33,x			ora 	NSStatus+1,x
.22e7	29 80		and #$80			and 	#$80
.22e9	15 62		ora $62,x			ora 	NSMantissa3,x
.22eb	15 56		ora $56,x			ora 	NSMantissa2,x
.22ed	15 4a		ora $4a,x			ora 	NSMantissa1,x
.22ef	15 63		ora $63,x			ora 	NSMantissa3+1,x
.22f1	15 57		ora $57,x			ora 	NSMantissa2+1,x
.22f3	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.22f5	d0 04		bne $22fb			bne 	_FMInt32
.22f7	20 b6 22	jsr $22b6			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.22fa	60		rts				rts
.22fb					_FMInt32:
.22fb	20 25 23	jsr $2325			jsr 	FloatMultiplyShort			; use the int32 one.
.22fe	18		clc				clc 								; fix it up if gone out of range
.22ff	75 6e		adc $6e,x			adc 	NSExponent,x
.2301	95 6e		sta $6e,x			sta 	NSExponent,x
.2303	60		rts				rts
.2304					_FMUseFloat:
.2304	20 6d 23	jsr $236d			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2307	f0 18		beq $2321			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2309	e8		inx				inx
.230a	20 6d 23	jsr $236d			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.230d	ca		dex				dex
.230e	c9 00		cmp #$00			cmp 	#0
.2310	f0 0c		beq $231e			beq 	_FDSetZero
.2312	20 25 23	jsr $2325			jsr 	FloatMultiplyShort 			; calculate the result.
.2315	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2317	18		clc				clc
.2318	75 6f		adc $6f,x			adc 	NSExponent+1,x
.231a	95 6e		sta $6e,x			sta 	NSExponent,x
.231c	80 03		bra $2321			bra 	_FDExit
.231e					_FDSetZero:
.231e	20 18 26	jsr $2618			jsr 	FloatSetZero 				; return 0
.2321					_FDExit:
.2321	20 6d 23	jsr $236d			jsr 	FloatNormalise 				; normalise the result
.2324	60		rts				rts
.2325					FloatMultiplyShort:
.2325	5a		phy				phy 								; save Y
.2326	20 fb 25	jsr $25fb			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2329	20 14 26	jsr $2614			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.232c	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.232e					_I32MLoop:
.232e	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2330	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.2332	15 58		ora $58,x			ora 	NSMantissa2+2,x
.2334	15 64		ora $64,x			ora 	NSMantissa3+2,x
.2336	f0 25		beq $235d			beq 	_I32MExit 					; exit if zero
.2338	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.233a	29 01		and #$01			and 	#1
.233c	f0 0d		beq $234b			beq 	_I32MNoAdd
.233e	20 a4 23	jsr $23a4			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.2341	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.2343	10 06		bpl $234b			bpl 	_I32MNoAdd
.2345					_I32ShiftRight:
.2345	20 31 26	jsr $2631			jsr 	FloatShiftRight 			; shift S[X] right
.2348	c8		iny				iny 								; increment shift count
.2349	80 09		bra $2354			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.234b					_I32MNoAdd:
.234b	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.234d	70 f6		bvs $2345			bvs 	_I32ShiftRight 				; instead.
.234f	e8		inx				inx
.2350	20 27 26	jsr $2627			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.2353	ca		dex				dex
.2354					_I32MShiftUpper:
.2354	e8		inx				inx 								; shift S[X+2] right
.2355	e8		inx				inx
.2356	20 31 26	jsr $2631			jsr 	FloatShiftRight
.2359	ca		dex				dex
.235a	ca		dex				dex
.235b	80 d1		bra $232e			bra 	_I32MLoop 					; try again.
.235d					_I32MExit:
.235d	20 63 23	jsr $2363			jsr 	FloatCalculateSign
.2360	98		tya				tya 								; shift in A
.2361	7a		ply				ply 								; restore Y and exit
.2362	60		rts				rts
.2363					FloatCalculateSign:
.2363	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.2365	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.2367	55 33		eor $33,x			eor 	NSStatus+1,x
.2369	0a		asl a				asl 	a 							; shift bit 7 into carry
.236a	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.236c	60		rts				rts
.236d					FloatNormalise:
.236d	20 3a 26	jsr $263a			jsr 	FloatIsZero 				; if zero exit
.2370	d0 07		bne $2379			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.2372	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.2374	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.2376	a9 00		lda #$00			lda 	#0 							; set Z flag
.2378	60		rts				rts
.2379					_NSNormaliseOptimise:
.2379	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.237b	d0 19		bne $2396			bne 	_NSNormaliseLoop
.237d	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.237f	30 15		bmi $2396			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.2381	95 62		sta $62,x			sta 	NSMantissa3,x
.2383	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2385	95 56		sta $56,x			sta 	NSMantissa2,x
.2387	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2389	95 4a		sta $4a,x			sta 	NSMantissa1,x
.238b	74 3e		stz $3e,x			stz 	NSMantissa0,x
.238d	b5 6e		lda $6e,x			lda 	NSExponent,x
.238f	38		sec				sec
.2390	e9 08		sbc #$08			sbc 	#8
.2392	95 6e		sta $6e,x			sta 	NSExponent,x
.2394	80 e3		bra $2379			bra 	_NSNormaliseOptimise
.2396					_NSNormaliseLoop:
.2396	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.2398	70 07		bvs $23a1			bvs 	_NSNExit 					; exit if so with Z flag clear
.239a	20 27 26	jsr $2627			jsr 	FloatShiftLeft 				; shift mantissa left
.239d	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.239f	80 f5		bra $2396			bra 	_NSNormaliseLoop
.23a1					_NSNExit:
.23a1	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23a3	60		rts				rts
.23a4					FloatAddTopTwoStack:
.23a4	18		clc				clc
.23a5	b5 3e		lda $3e,x			lda		NSMantissa0,x
.23a7	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.23a9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.23ab	b5 4a		lda $4a,x			lda		NSMantissa1,x
.23ad	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.23af	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23b1	b5 56		lda $56,x			lda		NSMantissa2,x
.23b3	75 57		adc $57,x			adc 		NSMantissa2+1,x
.23b5	95 56		sta $56,x			sta 	NSMantissa2,x
.23b7	b5 62		lda $62,x			lda		NSMantissa3,x
.23b9	75 63		adc $63,x			adc 		NSMantissa3+1,x
.23bb	95 62		sta $62,x			sta 	NSMantissa3,x
.23bd	60		rts				rts
.23be					FloatSubTopTwoStack:
.23be	38		sec				sec
.23bf	b5 3e		lda $3e,x			lda		NSMantissa0,x
.23c1	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.23c3	95 3e		sta $3e,x			sta 	NSMantissa0,x
.23c5	b5 4a		lda $4a,x			lda		NSMantissa1,x
.23c7	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.23c9	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23cb	b5 56		lda $56,x			lda		NSMantissa2,x
.23cd	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.23cf	95 56		sta $56,x			sta 	NSMantissa2,x
.23d1	b5 62		lda $62,x			lda		NSMantissa3,x
.23d3	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.23d5	95 62		sta $62,x			sta 	NSMantissa3,x
.23d7	60		rts				rts
.23d8					FloatInt32Add:
.23d8	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.23da	55 33		eor $33,x			eor 	NSStatus+1,x
.23dc	30 04		bmi $23e2			bmi 	_DiffSigns
.23de	20 a4 23	jsr $23a4			jsr		FloatAddTopTwoStack
.23e1	60		rts				rts
.23e2					_DiffSigns:
.23e2	20 be 23	jsr $23be			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.23e5	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.23e7	10 07		bpl $23f0			bpl 	_AddExit
.23e9	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.23eb	95 32		sta $32,x			sta 	NSStatus,x
.23ed	20 e1 25	jsr $25e1			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.23f0					_AddExit:
.23f0	20 3a 26	jsr $263a			jsr 	FloatIsZero 				; check for -0
.23f3	d0 02		bne $23f7			bne 	_AddNonZero
.23f5	74 32		stz $32,x			stz 	NSStatus,x
.23f7					_AddNonZero:
.23f7	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.23f8					FloatEncodeStart:
.23f8	38		sec				sec
.23f9	80 01		bra $23fc			bra 	FloatEncodeContinue+1
.23fb					FloatEncodeContinue:
.23fb	18		clc				clc
.23fc					FloatEncode:
.23fc	08		php				php 								; save reset flag.
.23fd	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.23ff	f0 15		beq $2416			beq 	_ENIsOkay
.2401	c9 30		cmp #$30			cmp 	#"0"
.2403	90 04		bcc $2409			bcc 	_ENBadNumber
.2405	c9 3a		cmp #$3a			cmp 	#"9"+1
.2407	90 0d		bcc $2416			bcc 	_ENIsOkay
.2409					_ENBadNumber:
.2409	28		plp				plp 								; throw saved reset
.240a	ad 91 05	lda $0591			lda 	encodeState 				; if in decimal mode, construct final number
.240d	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.240f	d0 03		bne $2414			bne 	_ENFail
.2411	4c 8e 24	jmp $248e			jmp 	_ENConstructFinal
.2414					_ENFail:
.2414	18		clc				clc 								; not allowed
.2415	60		rts				rts
.2416					_ENIsOkay:
.2416	28		plp				plp 								; are we restarting
.2417	90 15		bcc $242e			bcc 	_ENNoRestart
.2419					_ENStartEncode:
.2419	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.241b	f0 0c		beq $2429			beq 	_ENFirstDP
.241d	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.241f	20 1a 26	jsr $261a			jsr 	FloatSetByte 				; in single byte mode.
.2422	a9 01		lda #$01			lda 	#ESTA_Low
.2424					_ENExitChange:
.2424	8d 91 05	sta $0591			sta 	encodeState 				; save new state
.2427	38		sec				sec
.2428	60		rts				rts
.2429					_ENFirstDP:
.2429	20 18 26	jsr $2618			jsr 	FloatSetZero 				; clear integer part
.242c	80 3c		bra $246a			bra 	_ESTASwitchFloat			; go straight to float and exi
.242e					_ENNoRestart:
.242e	48		pha				pha 								; save digit or DP on stack.
.242f	ad 91 05	lda $0591			lda 	encodeState 				; get current state
.2432	c9 01		cmp #$01			cmp 	#ESTA_Low
.2434	f0 09		beq $243f			beq  	_ESTALowState
.2436	c9 02		cmp #$02			cmp 	#ESTA_High
.2438	f0 26		beq $2460			beq 	_ESTAHighState
.243a	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.243c	f0 38		beq $2476			beq 	_ESTADecimalState
>243e	db						.byte 	$DB 						; causes a break in the emulator
.243f					_ESTALowState:
.243f	68		pla				pla 								; get value back
.2440	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.2442	f0 26		beq $246a			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.2444	29 0f		and #$0f			and 	#15 						; make digit
.2446	8d 92 05	sta $0592			sta 	digitTemp 					; save it.
.2449	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.244b	0a		asl a				asl 	a
.244c	0a		asl a				asl 	a
.244d	75 3e		adc $3e,x			adc 	NSMantissa0,x
.244f	0a		asl a				asl 	a
.2450	6d 92 05	adc $0592			adc 	digitTemp
.2453	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2455	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.2457	90 05		bcc $245e			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.2459	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.245b	8d 91 05	sta $0591			sta 	encodeState
.245e					_ESTANoSwitch:
.245e	38		sec				sec
.245f	60		rts				rts
.2460					_ESTAHighState:
.2460	68		pla				pla 								; get value back
.2461	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.2463	f0 05		beq $246a			beq 	_ESTASwitchFloat
.2465	20 c0 24	jsr $24c0			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.2468	38		sec				sec
.2469	60		rts				rts
.246a					_ESTASwitchFloat:
.246a	9c 93 05	stz $0593			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.246d	e8		inx				inx 								; zero the decimal additive.
.246e	20 18 26	jsr $2618			jsr 	FloatSetZero
.2471	ca		dex				dex
.2472	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.2474	80 ae		bra $2424			bra 	_ENExitChange
.2476					_ESTADecimalState:
.2476	68		pla				pla 								; digit.
.2477	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.2479	f0 99		beq $2414			beq 	_ENFail
.247b	e8		inx				inx 								; put digit into fractional part of X+1
.247c	20 c0 24	jsr $24c0			jsr 	ESTAShiftDigitIntoMantissa
.247f	ca		dex				dex
.2480	ee 93 05	inc $0593			inc 	decimalCount 				; bump the count of decimals
.2483	ad 93 05	lda $0593			lda 	decimalCount 				; too many decimal digits.
.2486	c9 0b		cmp #$0b			cmp 	#11
.2488	f0 02		beq $248c			beq 	_ESTADSFail
.248a	38		sec				sec
.248b	60		rts				rts
.248c					_ESTADSFail:
.248c	18		clc				clc
.248d	60		rts				rts
.248e					_ENConstructFinal:
.248e	ad 93 05	lda $0593			lda 	decimalCount 				; get decimal count
.2491	f0 2b		beq $24be			beq 	_ENCFExit 					; no decimals
.2493	5a		phy				phy
.2494	0a		asl a				asl 	a 							; x 4 and CLC
.2495	0a		asl a				asl 	a
.2496	6d 93 05	adc $0593			adc 	decimalCount
.2499	a8		tay				tay
.249a	b9 25 21	lda $2125,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.249d	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.249f	b9 26 21	lda $2126,y			lda 	FloatScalarTable-5+1,y
.24a2	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.24a4	b9 27 21	lda $2127,y			lda 	FloatScalarTable-5+2,y
.24a7	95 58		sta $58,x			sta 	NSMantissa2+2,x
.24a9	b9 28 21	lda $2128,y			lda 	FloatScalarTable-5+3,y
.24ac	95 64		sta $64,x			sta 	NSMantissa3+2,x
.24ae	b9 29 21	lda $2129,y			lda 	FloatScalarTable-5+4,y
.24b1	95 70		sta $70,x			sta 	NSExponent+2,x
.24b3	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.24b5	e8		inx				inx 								; multiply decimal const by decimal scalar
.24b6	e8		inx				inx
.24b7	20 d8 22	jsr $22d8			jsr 	FloatMultiply
.24ba	20 3c 20	jsr $203c			jsr 	FloatAdd 					; add to integer part.
.24bd	7a		ply				ply
.24be					_ENCFExit:
.24be	18		clc				clc 								; reject the digit.
.24bf	60		rts				rts
.24c0					ESTAShiftDigitIntoMantissa:
.24c0	29 0f		and #$0f			and 	#15 						; save digit
.24c2	48		pha				pha
.24c3	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.24c5	48		pha				pha
.24c6	b5 56		lda $56,x			lda 	NSMantissa2,x
.24c8	48		pha				pha
.24c9	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.24cb	48		pha				pha
.24cc	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.24ce	48		pha				pha
.24cf	20 27 26	jsr $2627			jsr 	FloatShiftLeft 				; x 2
.24d2	20 27 26	jsr $2627			jsr 	FloatShiftLeft 				; x 4
.24d5	18		clc				clc 								; pop mantissa and add
.24d6	68		pla				pla
.24d7	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24d9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24db	68		pla				pla
.24dc	75 4a		adc $4a,x			adc 	NSMantissa1,x
.24de	95 4a		sta $4a,x			sta 	NSMantissa1,x
.24e0	68		pla				pla
.24e1	75 56		adc $56,x			adc 	NSMantissa2,x
.24e3	95 56		sta $56,x			sta 	NSMantissa2,x
.24e5	68		pla				pla
.24e6	75 62		adc $62,x			adc 	NSMantissa3,x
.24e8	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.24ea	20 27 26	jsr $2627			jsr 	FloatShiftLeft 				; x 10
.24ed	68		pla				pla 								; add digit
.24ee	18		clc				clc
.24ef	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24f1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24f3	90 0a		bcc $24ff			bcc 	_ESTASDExit
.24f5	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.24f7	d0 06		bne $24ff			bne 	_ESTASDExit
.24f9	f6 56		inc $56,x			inc 	NSMantissa2,x
.24fb	d0 02		bne $24ff			bne 	_ESTASDExit
.24fd	f6 62		inc $62,x			inc 	NSMantissa3,x
.24ff					_ESTASDExit:
.24ff	60		rts				rts
.0591					encodeState:
>0591							.fill 	1
.0592					digitTemp:
>0592							.fill 	1
.0593					decimalCount:
>0593							.fill 	1
.2500					FloatToString:
.2500	da		phx				phx
.2501	5a		phy				phy 								; save code position
.2502	8d 94 05	sta $0594			sta 	decimalPlaces	 			; save number of DPs.
.2505	9c 95 05	stz $0595			stz 	dbOffset 					; offset into decimal buffer = start.
.2508	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.250a	10 08		bpl $2514			bpl 	_CNTSNotNegative
.250c	29 7f		and #$7f			and 	#$7F 						; make +ve
.250e	95 32		sta $32,x			sta 	NSStatus,x
.2510	a9 2d		lda #$2d			lda 	#"-"
.2512	80 02		bra $2516			bra 	_CNTMain
.2514					_CNTSNotNegative:
.2514	a9 20		lda #$20			lda 	#" "
.2516					_CNTMain:
.2516	20 78 25	jsr $2578			jsr 	WriteDecimalBuffer
.2519	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.251b	f0 0d		beq $252a			beq 	_CNTSNotFloat
.251d	e8		inx				inx 								; round up so we don't get too many 6.999999
.251e	a9 01		lda #$01			lda 	#1
.2520	20 1a 26	jsr $261a			jsr 	FloatSetByte
.2523	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2525	95 6e		sta $6e,x			sta 	NSExponent,x
.2527	20 3c 20	jsr $203c			jsr 	FloatAdd
.252a					_CNTSNotFloat:
.252a	20 5a 25	jsr $255a			jsr 	MakePlusTwoString 			; do the integer part.
.252d	20 f8 21	jsr $21f8			jsr 	FloatFractionalPart 		; get the fractional part
.2530	20 6d 23	jsr $236d			jsr 	FloatNormalise					; normalise , exit if zero
.2533	f0 22		beq $2557			beq 	_CNTSExit
.2535	a9 2e		lda #$2e			lda 	#"."
.2537	20 78 25	jsr $2578			jsr 	WriteDecimalBuffer 			; write decimal place
.253a					_CNTSDecimal:
.253a	ce 94 05	dec $0594			dec 	decimalPlaces 				; done all the decimals
.253d	30 18		bmi $2557			bmi 	_CNTSExit
.253f	e8		inx				inx 								; x 10.0
.2540	a9 0a		lda #$0a			lda 	#10
.2542	20 1a 26	jsr $261a			jsr 	FloatSetByte
.2545	20 d8 22	jsr $22d8			jsr 	FloatMultiply
.2548	20 5a 25	jsr $255a			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.254b	20 f8 21	jsr $21f8			jsr 	FloatFractionalPart 		; get the fractional part
.254e	20 6d 23	jsr $236d			jsr 	FloatNormalise 				; normalise it.
.2551	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.2553	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.2555	b0 e3		bcs $253a			bcs 	_CNTSDecimal 				; keep going.
.2557					_CNTSExit:
.2557	7a		ply				ply
.2558	fa		plx				plx
.2559	60		rts				rts
.255a					MakePlusTwoString:
.255a	da		phx				phx
.255b	20 fb 25	jsr $25fb			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.255e	e8		inx				inx 								; access it
.255f	e8		inx				inx
.2560	20 53 22	jsr $2253			jsr 	FloatIntegerPart 			; make it an integer
.2563	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.2565	20 97 25	jsr $2597			jsr 	ConvertInt32
.2568	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.256a					_MPTSCopy:
.256a	bd 6f 05	lda $056f,x			lda 	numberBuffer,x
.256d	20 78 25	jsr $2578			jsr 	WriteDecimalBuffer
.2570	e8		inx				inx
.2571	bd 6f 05	lda $056f,x			lda 	numberBuffer,x
.2574	d0 f4		bne $256a			bne 	_MPTSCopy
.2576	fa		plx				plx
.2577	60		rts				rts
.2578					WriteDecimalBuffer:
.2578	da		phx				phx
.2579	ae 95 05	ldx $0595			ldx 	dbOffset
.257c	9d 96 05	sta $0596,x			sta 	decimalBuffer,x
.257f	9e 97 05	stz $0597,x			stz 	decimalBuffer+1,x
.2582	ee 95 05	inc $0595			inc 	dbOffset
.2585	fa		plx				plx
.2586	60		rts				rts
.0594					decimalPlaces:
>0594							.fill 	1
.0595					dbOffset:
>0595							.fill 	1
.0596					decimalBuffer:
>0596							.fill 	32
.2587					ConvertInt16:
.2587	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.2589	86 4a		stx $4a				stx 	NSMantissa1
.258b	64 56		stz $56				stz 	NSMantissa2
.258d	64 62		stz $62				stz 	NSMantissa3
.258f	64 32		stz $32				stz 	NSStatus 					; positive integer
.2591	a2 00		ldx #$00			ldx 	#0 							; stack level
.2593	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.2595	80 00		bra $2597			bra 	ConvertInt32
.2597					ConvertInt32:
.2597	5a		phy				phy
.2598	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.259a	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.259c	10 08		bpl $25a6			bpl 	_CI32NotNeg
.259e	48		pha				pha
.259f	a9 2d		lda #$2d			lda 	#'-'
.25a1	99 6f 05	sta $056f,y			sta 	numberBuffer,y
.25a4	c8		iny				iny
.25a5	68		pla				pla
.25a6					_CI32NotNeg:
.25a6	20 b4 25	jsr $25b4			jsr 	_CI32DivideConvert 			; recursive conversion
.25a9	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.25ab	99 6f 05	sta $056f,y			sta 	numberBuffer,y
.25ae	7a		ply				ply
.25af	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.25b1	a9 6f		lda #$6f			lda 	#numberBuffer & $FF
.25b3	60		rts				rts
.25b4					_CI32DivideConvert:
.25b4	e8		inx				inx 								; write to next slot up
.25b5	20 1a 26	jsr $261a			jsr 	FloatSetByte 		 		; write the base out.
.25b8	ca		dex				dex
.25b9	20 ae 21	jsr $21ae			jsr 	Int32Divide 				; divide
.25bc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.25be	48		pha				pha
.25bf	20 9d 21	jsr $219d			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.25c2	20 3a 26	jsr $263a			jsr 	FloatIsZero 				; is it zero ?
.25c5	f0 05		beq $25cc			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.25c7	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.25c9	20 b4 25	jsr $25b4			jsr 	_CI32DivideConvert 			; and recusrively call.
.25cc					_CI32NoRecurse:
.25cc	68		pla				pla 								; remainder
.25cd	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.25cf	90 02		bcc $25d3			bcc 	_CI32NotHex
.25d1	69 26		adc #$26			adc 	#6+32
.25d3					_CI32NotHex:
.25d3	69 30		adc #$30			adc 	#48
.25d5	99 6f 05	sta $056f,y			sta 	numberBuffer,y 				; write out and exit
.25d8	c8		iny				iny
.25d9	60		rts				rts
.25da					FloatNegate:
.25da	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.25dc	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.25de	95 32		sta $32,x			sta 	NSStatus,x
.25e0	60		rts				rts
.25e1					FloatNegateMantissa:
.25e1	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.25e2	a9 00		lda #$00			lda 	#0
.25e4	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.25e6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.25e8	a9 00		lda #$00			lda 	#0
.25ea	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.25ec	95 4a		sta $4a,x			sta 	NSMantissa1,x
.25ee	a9 00		lda #$00			lda 	#0
.25f0	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.25f2	95 56		sta $56,x			sta 	NSMantissa2,x
.25f4	a9 00		lda #$00			lda 	#0
.25f6	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.25f8	95 62		sta $62,x			sta 	NSMantissa3,x
.25fa	60		rts				rts
.25fb					FloatShiftUpTwo:
.25fb	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.25fd	95 40		sta $40,x			sta 	NSMantissa0+2,x
.25ff	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2601	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2603	b5 56		lda $56,x			lda 	NSMantissa2,x
.2605	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2607	b5 62		lda $62,x			lda 	NSMantissa3,x
.2609	95 64		sta $64,x			sta 	NSMantissa3+2,x
.260b	b5 6e		lda $6e,x			lda 	NSExponent,x
.260d	95 70		sta $70,x			sta 	NSExponent+2,x
.260f	b5 32		lda $32,x			lda 	NSStatus,x
.2611	95 34		sta $34,x			sta 	NSStatus+2,x
.2613	60		rts				rts
.2614					FloatSetZeroMantissaOnly:
.2614	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2616	80 08		bra $2620			bra 	FloatZero13
.2618					FloatSetZero:
.2618	a9 00		lda #$00			lda 	#0
.261a					FloatSetByte:
.261a	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.261c					FloatSetMantissa:
.261c	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.261e	74 32		stz $32,x			stz 	NSStatus,x
.2620					FloatZero13:
.2620	74 4a		stz $4a,x			stz 	NSMantissa1,x
.2622	74 56		stz $56,x			stz 	NSMantissa2,x
.2624	74 62		stz $62,x			stz 	NSMantissa3,x
.2626	60		rts				rts
.2627					FloatShiftLeft:
.2627	18		clc				clc
.2628					FloatRotateLeft:
.2628	36 3e		rol $3e,x			rol 	NSMantissa0,x
.262a	36 4a		rol $4a,x			rol		NSMantissa1,x
.262c	36 56		rol $56,x			rol		NSMantissa2,x
.262e	36 62		rol $62,x			rol		NSMantissa3,x
.2630	60		rts				rts
.2631					FloatShiftRight:
.2631	56 62		lsr $62,x			lsr 	NSMantissa3,x
.2633	76 56		ror $56,x			ror		NSMantissa2,x
.2635	76 4a		ror $4a,x			ror		NSMantissa1,x
.2637	76 3e		ror $3e,x			ror		NSMantissa0,x
.2639	60		rts				rts
.263a					FloatIsZero:
.263a	b5 62		lda $62,x			lda 	NSMantissa3,x
.263c	15 56		ora $56,x			ora		NSMantissa2,x
.263e	15 4a		ora $4a,x			ora		NSMantissa1,x
.2640	15 3e		ora $3e,x			ora		NSMantissa0,x
.2642	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.2643					FloatArcTan:
.2643	20 6d 23	jsr $236d			jsr 	FloatNormalise 					; normalise x
.2646	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.2648	48		pha				pha
.2649	74 32		stz $32,x			stz 	NSStatus,x
.264b	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.264d	c9 e2		cmp #$e2			cmp 	#$E2
.264f	90 25		bcc $2676			bcc 	_UANoFixup
.2651	8a		txa				txa 									; value in +1
.2652	a8		tay				tay
.2653	c8		iny				iny
.2654	20 fc 27	jsr $27fc			jsr 	CopyFloatXY
.2657	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.2659	20 1a 26	jsr $261a			jsr 	FloatSetByte
.265c	e8		inx				inx
.265d	20 61 21	jsr $2161			jsr 	FloatDivide
.2660	b0 21		bcs $2683			bcs 	_FATError
.2662	20 86 26	jsr $2686			jsr 	CoreAtn 						; calculate the root
.2665	20 f1 27	jsr $27f1			jsr 	CompletePolynomial
.2668	20 da 25	jsr $25da			jsr 	FloatNegate 					; make -ve
.266b	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.266d	20 48 28	jsr $2848			jsr 	LoadConstant
.2670	e8		inx				inx
.2671	20 3c 20	jsr $203c			jsr 	FloatAdd
.2674	80 06		bra $267c			bra 	_UAComplete
.2676					_UANoFixup:
.2676	20 86 26	jsr $2686			jsr 	CoreAtn
.2679	20 f1 27	jsr $27f1			jsr 	CompletePolynomial
.267c					_UAComplete:
.267c	68		pla				pla 									; apply the result.
.267d	55 32		eor $32,x			eor 	NSStatus,x
.267f	95 32		sta $32,x			sta 	NSStatus,x
.2681	18		clc				clc
.2682	60		rts				rts
.2683					_FATError:
.2683	68		pla				pla
.2684	38		sec				sec
.2685	60		rts				rts
.2686					CoreAtn:
.2686	a9 f4		lda #$f4			lda 	#AtnCoefficients & $FF
.2688	a0 26		ldy #$26			ldy 	#AtnCoefficients >> 8
.268a	4c 45 29	jmp $2945			jmp 	CorePolySquared
.268d					ExpCoefficients:
>268d	07					.byte	7
>268e	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>2692	d2					.byte	$d2
>2693	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>2697	d5					.byte	$d5
>2698	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>269c	d8					.byte	$d8
>269d	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>26a1	db					.byte	$db
>26a2	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>26a6	dd					.byte	$dd
>26a7	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>26ab	df					.byte	$df
>26ac	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>26b0	e1					.byte	$e1
>26b1	00 00 00 40				.dword	$40000000 ; 1.0
>26b5	e2					.byte	$e2
.26b6					SinCoefficients:
>26b6	06					.byte	6
>26b7	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>26bb	e5					.byte	$e5
>26bc	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>26c0	e7					.byte	$e7
>26c1	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>26c5	e8					.byte	$e8
>26c6	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>26ca	e8					.byte	$e8
>26cb	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>26cf	e7					.byte	$e7
>26d0	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>26d4	e4					.byte	$e4
>26d5	00 00 00 00				.dword	$00000000 ; 0.0
>26d9	00					.byte	$00
.26da					LogCoefficients:
>26da	04					.byte	4
>26db	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>26df	e0					.byte	$e0
>26e0	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>26e4	e1					.byte	$e1
>26e5	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>26e9	e1					.byte	$e1
>26ea	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>26ee	e3					.byte	$e3
>26ef	00 00 00 c0				.dword	$c0000000 ; -0.5
>26f3	e1					.byte	$e1
.26f4					AtnCoefficients:
>26f4	0c					.byte	12
>26f5	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>26f9	d7					.byte	$d7
>26fa	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>26fe	da					.byte	$da
>26ff	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>2703	dc					.byte	$dc
>2704	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2708	dd					.byte	$dd
>2709	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>270d	dd					.byte	$dd
>270e	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>2712	de					.byte	$de
>2713	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2717	de					.byte	$de
>2718	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>271c	de					.byte	$de
>271d	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>2721	df					.byte	$df
>2722	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>2726	df					.byte	$df
>2727	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>272b	e0					.byte	$e0
>272c	00 00 00 40				.dword	$40000000 ; 1.0
>2730	e2					.byte	$e2
>2731	00 00 00 00				.dword	$00000000 ; 0.0
>2735	00					.byte	$00
.2736					Const_Base:
.2736					Const_1Div2Pi:
>2736	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>273a	df					.byte	$df
.273b					Const_PiDiv2:
>273b	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>273f	e2					.byte	$e2
.2740					Const_Log2_e:
>2740	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>2744	e2					.byte	$e2
.2745					Const_sqrt_2:
>2745	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>2749	e2					.byte	$e2
.274a					Const_sqrt_half:
>274a	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>274e	e1					.byte	$e1
.274f					Const_pi:
>274f	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>2753	e3					.byte	$e3
.2754					Const_half:
>2754	00 00 00 40				.dword	$40000000 ; 0.50000000
>2758	e1					.byte	$e1
.2759					Const_ln_e:
>2759	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>275d	e1					.byte	$e1
.275e					FloatCosine:
.275e	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2760	20 48 28	jsr $2848			jsr 	LoadConstant
.2763	e8		inx				inx
.2764	20 3c 20	jsr $203c			jsr 	FloatAdd
.2767	4c fe 28	jmp $28fe			jmp 	FloatSine
.276a					FloatExponent:
.276a	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.276c	20 48 28	jsr $2848			jsr 	LoadConstant
.276f	e8		inx				inx
.2770	20 d8 22	jsr $22d8			jsr 	FloatMultiply
.2773	20 b5 27	jsr $27b5			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.2776	e8		inx				inx
.2777	20 53 22	jsr $2253			jsr 	FloatIntegerPart
.277a	ca		dex				dex
.277b	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.277d	15 57		ora $57,x			ora 	NSMantissa2+1,x
.277f	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2781	d0 38		bne $27bb			bne 	_UERangeError
.2783	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.2785	c9 40		cmp #$40			cmp 	#64
.2787	b0 32		bcs $27bb			bcs 	_UERangeError
.2789	48		pha				pha
.278a	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.278c	48		pha				pha
.278d	20 f8 21	jsr $21f8			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.2790	68		pla				pla
.2791	10 14		bpl $27a7			bpl 	_UEPositive
.2793	e8		inx				inx 							; 1-x
.2794	a9 01		lda #$01			lda 	#1
.2796	20 1a 26	jsr $261a			jsr 	FloatSetByte
.2799	ca		dex				dex
.279a	20 da 25	jsr $25da			jsr 	FloatNegate
.279d	e8		inx				inx
.279e	20 3c 20	jsr $203c			jsr 	FloatAdd
.27a1	68		pla				pla 							; integer part +1 and negated.
.27a2	1a		inc a				inc 	a
.27a3	49 ff		eor #$ff			eor 	#$FF
.27a5	1a		inc a				inc 	a
.27a6	48		pha				pha
.27a7					_UEPositive:
.27a7	20 bd 27	jsr $27bd			jsr 	CoreExponent
.27aa	20 f1 27	jsr $27f1			jsr 	CompletePolynomial
.27ad	68		pla				pla
.27ae	18		clc				clc
.27af	75 6e		adc $6e,x			adc 	NSExponent,x
.27b1	95 6e		sta $6e,x			sta 	NSExponent,x
.27b3	18		clc				clc
.27b4	60		rts				rts
.27b5					_UECopy01:
.27b5	8a		txa				txa
.27b6	a8		tay				tay
.27b7	c8		iny				iny
.27b8	4c fc 27	jmp $27fc			jmp 	CopyFloatXY
.27bb					_UERangeError:
.27bb	38		sec				sec
.27bc	60		rts				rts
.27bd					CoreExponent:
.27bd	a9 8d		lda #$8d			lda 	#ExpCoefficients & $FF
.27bf	a0 26		ldy #$26			ldy 	#ExpCoefficients >> 8
.27c1	20 c5 27	jsr $27c5			jsr 	CalculateHornerPolynomial
.27c4	60		rts				rts
.27c5					CalculateHornerPolynomial:
.27c5	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.27c7	84 2d		sty $2d				sty 	zTemp0+1
.27c9	9c b6 05	stz $05b6			stz 	coefficientCount 			; zero the count.
.27cc	8e b7 05	stx $05b7			stx 	xValueSlot 					; save xValue slot.
.27cf	e8		inx				inx 								; set the count to zero.
.27d0	20 18 26	jsr $2618			jsr 	FloatSetZero
.27d3					_CHPLoop:
.27d3	8a		txa				txa 								; copy X-1 to X+1
.27d4	a8		tay				tay
.27d5	ca		dex				dex
.27d6	c8		iny				iny
.27d7	20 fc 27	jsr $27fc			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.27da	e8		inx				inx
.27db	e8		inx				inx
.27dc	20 d8 22	jsr $22d8			jsr 	FloatMultiply 				; times current by X
.27df	e8		inx				inx
.27e0	20 1b 28	jsr $281b			jsr 	GetCoefficient 				; coefficient into X+1
.27e3	20 3c 20	jsr $203c			jsr 	FloatAdd 					; and add
.27e6	ee b6 05	inc $05b6			inc 	coefficientCount
.27e9	ad b6 05	lda $05b6			lda 	coefficientCount
.27ec	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.27ee	d0 e3		bne $27d3			bne 	_CHPLoop
.27f0	60		rts				rts
.27f1					CompletePolynomial:
.27f1	20 d8 22	jsr $22d8			jsr 	FloatMultiply
.27f4	e8		inx				inx 								; get the last value
.27f5	20 1b 28	jsr $281b			jsr 	GetCoefficient
.27f8	20 3c 20	jsr $203c			jsr 	FloatAdd 					; and add it
.27fb	60		rts				rts
.27fc					CopyFloatXY:
.27fc	b5 6e		lda $6e,x			lda 	NSExponent,x
.27fe	99 6e 00	sta $006e,y			sta 	NSExponent,y
.2801	b5 32		lda $32,x			lda 	NSStatus,x
.2803	99 32 00	sta $0032,y			sta 	NSStatus,y
.2806	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2808	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.280b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.280d	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.2810	b5 56		lda $56,x			lda 	NSMantissa2,x
.2812	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.2815	b5 62		lda $62,x			lda 	NSMantissa3,x
.2817	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.281a	60		rts				rts
.281b					GetCoefficient:
.281b	5a		phy				phy
.281c	ad b6 05	lda $05b6			lda 	coefficientCount 			; 5 per block
.281f	0a		asl a				asl 	a
.2820	0a		asl a				asl 	a
.2821	38		sec				sec 								; +1 for count
.2822	6d b6 05	adc $05b6			adc 	coefficientCount
.2825	a8		tay				tay
.2826	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.2828	95 3e		sta $3e,x			sta 	NSMantissa0,x
.282a	c8		iny				iny
.282b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.282d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.282f	c8		iny				iny
.2830	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2832	95 56		sta $56,x			sta 	NSMantissa2,x
.2834	c8		iny				iny
.2835	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2837	48		pha				pha
.2838	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.283a	95 62		sta $62,x			sta 	NSMantissa3,x
.283c	c8		iny				iny
.283d	68		pla				pla
.283e	29 80		and #$80			and 	#$80
.2840	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.2842	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2844	95 6e		sta $6e,x			sta 	NSExponent,x
.2846	7a		ply				ply
.2847	60		rts				rts
.05b6					coefficientCount:
>05b6							.fill 	1
.05b7					xValueSlot:
>05b7							.fill 	1
.2848					LoadConstant:
.2848	5a		phy				phy
.2849	a8		tay				tay
.284a	b9 36 27	lda $2736,y			lda 	Const_Base+0,y
.284d	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.284f	b9 37 27	lda $2737,y			lda 	Const_Base+1,y
.2852	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.2854	b9 38 27	lda $2738,y			lda 	Const_Base+2,y
.2857	95 57		sta $57,x			sta 	NSMantissa2+1,x
.2859	b9 39 27	lda $2739,y			lda 	Const_Base+3,y
.285c	48		pha				pha
.285d	29 7f		and #$7f			and 	#$7F
.285f	95 63		sta $63,x			sta 	NSMantissa3+1,x
.2861	68		pla				pla
.2862	29 80		and #$80			and 	#$80
.2864	95 33		sta $33,x			sta 	NSStatus+1,x
.2866	b9 3a 27	lda $273a,y			lda 	Const_Base+4,y
.2869	95 6f		sta $6f,x			sta 	NSExponent+1,x
.286b	7a		ply				ply
.286c	60		rts				rts
.286d					FloatLogarithm:
.286d	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.286f	30 5f		bmi $28d0			bmi 	_ULRange
.2871	20 3a 26	jsr $263a			jsr 	FloatIsZero
.2874	f0 5a		beq $28d0			beq 	_ULRange
.2876	20 6d 23	jsr $236d			jsr 	FloatNormalise 				; put into FP mode.
.2879	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.287b	48		pha				pha
.287c	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.287e	95 6e		sta $6e,x			sta 	NSExponent,x
.2880	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.2882	20 48 28	jsr $2848			jsr 	LoadConstant
.2885	e8		inx				inx
.2886	20 3c 20	jsr $203c			jsr 	FloatAdd
.2889	8a		txa				txa 								; divide into sqrt 2.0
.288a	a8		tay				tay
.288b	c8		iny				iny
.288c	20 fc 27	jsr $27fc			jsr 	CopyFloatXY
.288f	ca		dex				dex
.2890	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.2892	20 48 28	jsr $2848			jsr 	LoadConstant
.2895	e8		inx				inx
.2896	e8		inx				inx
.2897	20 61 21	jsr $2161			jsr 	FloatDivide 				; if zero, error.
.289a	b0 33		bcs $28cf			bcs 	_ULRangePla
.289c	20 da 25	jsr $25da			jsr 	FloatNegate 				; subtract from 1
.289f	e8		inx				inx
.28a0	a9 01		lda #$01			lda 	#1
.28a2	20 1a 26	jsr $261a			jsr 	FloatSetByte
.28a5	20 3c 20	jsr $203c			jsr 	FloatAdd
.28a8	20 d2 28	jsr $28d2			jsr 	CoreLog
.28ab	20 f1 27	jsr $27f1			jsr 	CompletePolynomial
.28ae	68		pla				pla 								; add exponent
.28af	18		clc				clc
.28b0	69 1f		adc #$1f			adc 	#31 						; fix up
.28b2	48		pha				pha
.28b3	10 03		bpl $28b8			bpl 	_LogNotNeg
.28b5	49 ff		eor #$ff			eor 	#$FF
.28b7	1a		inc a				inc 	a
.28b8					_LogNotNeg:
.28b8	e8		inx				inx 								; set byte and sign.
.28b9	20 1a 26	jsr $261a			jsr 	FloatSetByte
.28bc	68		pla				pla
.28bd	29 80		and #$80			and 	#$80
.28bf	95 32		sta $32,x			sta 	NSStatus,x
.28c1	20 3c 20	jsr $203c			jsr 	FloatAdd
.28c4	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.28c6	20 48 28	jsr $2848			jsr 	LoadConstant
.28c9	e8		inx				inx
.28ca	20 d8 22	jsr $22d8			jsr 	FloatMultiply
.28cd	18		clc				clc
.28ce	60		rts				rts
.28cf					_ULRangePla:
.28cf	68		pla				pla
.28d0					_ULRange:
.28d0	38		sec				sec
.28d1	60		rts				rts
.28d2					CoreLog:
.28d2	a9 da		lda #$da			lda 	#LogCoefficients & $FF
.28d4	a0 26		ldy #$26			ldy 	#LogCoefficients >> 8
.28d6	4c 45 29	jmp $2945			jmp 	CorePolySquared
.28d9					FloatPI:
.28d9	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.28db	20 48 28	jsr $2848			jsr 	LoadConstant
.28de	e8		inx				inx
.28df	18		clc				clc
.28e0	60		rts				rts
.28e1					FloatPower:
.28e1	ca		dex				dex
.28e2	8a		txa				txa 							; copy 0 to 2, so we can process it
.28e3	a8		tay				tay
.28e4	c8		iny				iny
.28e5	c8		iny				iny
.28e6	20 fc 27	jsr $27fc			jsr 	CopyFloatXY
.28e9	e8		inx				inx 							; 2 = Log(0)
.28ea	e8		inx				inx
.28eb	20 6d 28	jsr $286d			jsr 	FloatLogarithm
.28ee	b0 0d		bcs $28fd			bcs 	_FPWExit
.28f0	20 d8 22	jsr $22d8			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.28f3	8a		txa				txa 							; copy to slot 0
.28f4	a8		tay				tay
.28f5	88		dey				dey
.28f6	20 fc 27	jsr $27fc			jsr 	CopyFloatXY
.28f9	ca		dex				dex  							; Exponent code.
.28fa	20 6a 27	jsr $276a			jsr 	FloatExponent
.28fd					_FPWExit:
.28fd	60		rts				rts
.28fe					FloatSine:
.28fe	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.2900	48		pha				pha
.2901	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.2903	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.2905	20 48 28	jsr $2848			jsr 	LoadConstant
.2908	e8		inx				inx
.2909	20 d8 22	jsr $22d8			jsr 	FloatMultiply
.290c	20 f8 21	jsr $21f8			jsr 	FloatFractionalPart 		; take the fractional part
.290f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.2911	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.2913	90 1f		bcc $2934			bcc 	_USProcessExit
.2915	f0 06		beq $291d			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.2917	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.2919	c9 60		cmp #$60			cmp 	#$60
.291b	b0 0e		bcs $292b			bcs 	_USSubtractOne
.291d					_USSubtractFromHalf:
.291d	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.291f	20 48 28	jsr $2848			jsr 	LoadConstant
.2922	e8		inx				inx
.2923	20 36 20	jsr $2036			jsr 	FloatSubtract
.2926	20 da 25	jsr $25da			jsr 	FloatNegate 				; then negate it
.2929	80 09		bra $2934			bra 	_USProcessExit 				; and exit
.292b					_USSubtractOne:
.292b	e8		inx				inx
.292c	a9 01		lda #$01			lda 	#1
.292e	20 1a 26	jsr $261a			jsr 	FloatSetByte
.2931	20 36 20	jsr $2036			jsr 	FloatSubtract
.2934					_USProcessExit:
.2934	20 41 29	jsr $2941			jsr 	CoreSine
.2937	20 f1 27	jsr $27f1			jsr 	CompletePolynomial
.293a	68		pla				pla 								; restore sign and apply
.293b	55 32		eor $32,x			eor 	NSStatus,x
.293d	95 32		sta $32,x			sta 	NSStatus,x
.293f	18		clc				clc
.2940	60		rts				rts
.2941					CoreSine:
.2941	a9 b6		lda #$b6			lda 	#SinCoefficients & $FF
.2943	a0 26		ldy #$26			ldy 	#SinCoefficients >> 8
.2945					CorePolySquared:
.2945	48		pha				pha 								; save coefficient table
.2946	5a		phy				phy
.2947	8a		txa				txa 								; copy X to +1, +2
.2948	a8		tay				tay
.2949	c8		iny				iny
.294a	20 fc 27	jsr $27fc			jsr 	CopyFloatXY
.294d	c8		iny				iny
.294e	20 fc 27	jsr $27fc			jsr 	CopyFloatXY
.2951	e8		inx				inx 								; point to the pair and put x^2 on stack
.2952	e8		inx				inx
.2953	20 d8 22	jsr $22d8			jsr 	FloatMultiply
.2956	7a		ply				ply 								; coefficient table back.
.2957	68		pla				pla
.2958	20 c5 27	jsr $27c5			jsr 	CalculateHornerPolynomial
.295b	8a		txa				txa 								; copy back to slot #1
.295c	a8		tay				tay
.295d	88		dey				dey
.295e	20 fc 27	jsr $27fc			jsr	 	CopyFloatXY
.2961	ca		dex				dex 								; point at result
.2962	60		rts				rts
.2963					FloatSquareRoot:
.2963	20 6d 28	jsr $286d			jsr 	FloatLogarithm
.2966	b0 06		bcs $296e			bcs 	_FSQExit
.2968	d6 6e		dec $6e,x			dec 	NSExponent,x
.296a	20 6a 27	jsr $276a			jsr 	FloatExponent
.296d	18		clc				clc
.296e					_FSQExit:
.296e	60		rts				rts
.296f					FloatTangent:
.296f	da		phx				phx
.2970	8a		txa				txa 								; sin -> +1
.2971	a8		tay				tay
.2972	c8		iny				iny
.2973	20 fc 27	jsr $27fc			jsr 	CopyFloatXY
.2976	e8		inx				inx
.2977	20 fe 28	jsr $28fe			jsr 	FloatSine
.297a	ca		dex				dex
.297b	8a		txa				txa 								; cos -> +2
.297c	a8		tay				tay
.297d	c8		iny				iny
.297e	c8		iny				iny
.297f	20 fc 27	jsr $27fc			jsr 	CopyFloatXY
.2982	e8		inx				inx
.2983	e8		inx				inx
.2984	20 5e 27	jsr $275e			jsr 	FloatCosine
.2987	20 61 21	jsr $2161			jsr 	FloatDivide 				; calculate sin/cos
.298a	b0 07		bcs $2993			bcs 	_FTExit 					; divide by zero
.298c	8a		txa				txa 								; copy result down.
.298d	a8		tay				tay
.298e	88		dey				dey
.298f	20 fc 27	jsr $27fc			jsr 	CopyFloatXY
.2992	18		clc				clc
.2993					_FTExit:
.2993	fa		plx				plx
.2994	60		rts				rts

;******  Processing input file: testing/testend.asm

=$2a00							nextPage = (* + $FF) & $FF00 		; so I can include with that f*****g header.
.29fe					ObjectCodePreHeader:
>29fe	00 a0 d4 00 00 a6 ce 0e				.binary "code/code.bin"
>2a06	48 45 4c 4c 4f 2c 20 57 4f 52 4c 44 20 21 b1 0d
>2a16	92 a6 ca 91 c4 ff
=10752					ObjectCode = ObjectCodePreHeader+2 			; so the code is at XX00

;******  End of listing
