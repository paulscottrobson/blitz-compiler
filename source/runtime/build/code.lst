
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library testing/testend.asm
; Sat Oct  7 09:52:30 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

.1000					WrapperBoot:
.1000	a9 32		lda #$32			lda 	#ObjectCode >> 8 			; address of object code to run.
.1002	a2 81		ldx #$81			ldx 	#$81 						; first page of allocatable memory
.1004	a0 9f		ldy #$9f			ldy 	#$9F 						; byte after end of last page.
.1006	4c 09 10	jmp $1009			jmp 	StartRuntime

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.1009					StartRuntime:
.1009	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.100c	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.100e	64 28		stz $28				stz 	codePtr
.1010	64 2a		stz $2a				stz 	codePage 					; zero current page.
.1012	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.1015	8c 06 04	sty $0406			sty 	storeEndHigh
.1018	8e 07 04	stx $0407			stx 	variableStartPage
.101b	20 4d 12	jsr $124d			jsr 	ClearMemory 				; clear memory.
.101e	20 3d 1e	jsr $1e3d			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.1021	20 3f 1b	jsr $1b3f		 	jsr		SetDefaultChannel			; set default input/output channel.
.1024	20 75 1d	jsr $1d75			jsr 	RestoreCode 				; which we now call
.1027	a0 00		ldy #$00			ldy 	#0
.1029					NextCommand:
.1029	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.102b	30 5b		bmi $1088			bmi 	NXCommand 					; -if -ve command
.102d	c8		iny				iny
.102e	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.1030	90 39		bcc $106b			bcc 	PushByteA 					; 0..63 is short constants.
.1032					NXLoadStore:
.1032	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.1034	b0 19		bcs $104f			bcs 	NXIndirectLoadStore
.1036	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.1037	4a		lsr a				lsr 	a
.1038	29 0e		and #$0e			and 	#$0E
.103a	da		phx				phx 								; get ready to jump
.103b	aa		tax				tax
.103c	7c 3f 10	jmp ($103f,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.103f					ReadWriteVectors:
>103f	ab 1c						.word 	ReadFloatCommand			; read float
>1041	86 22						.word 	WriteFloatCommand 			; write float
>1043	e7 1c						.word 	ReadIntegerCommand 			; read integer
>1045	c2 22						.word 	WriteIntegerCommand 		; write integer
>1047	2c 1d						.word 	ReadStringCommand 			; read string
>1049	01 23						.word 	WriteStringCommand 			; write string
>104b	1b 14						.word 	Unimplemented
>104d	1b 14						.word 	Unimplemented
.104f					NXIndirectLoadStore:
.104f	29 07		and #$07			and 	#7
.1051	0a		asl a				asl 	a
.1052	da		phx				phx
.1053	aa		tax				tax
.1054	7c 57 10	jmp ($1057,x)			jmp 	(IndirectVectors,x)
.1057					IndirectVectors:
>1057	d5 16						.word 	IndFloatRead 				; float read
>1059	e9 16						.word 	IndInt16Read 				; int16 read
>105b	fd 16						.word 	IndStringRead 				; string read
>105d	1b 14						.word 	Unimplemented
>105f	11 17						.word 	IndFloatWrite				; float write
>1061	25 17						.word 	IndInt16Write 				; int16 write
>1063	39 17						.word 	IndStringWrite 				; string write
>1065	1b 14						.word 	Unimplemented
.1067					PushByteCommand:
.1067	fa		plx				plx
.1068	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.106a	c8		iny				iny
.106b					PushByteA:
.106b	e8		inx				inx 								; push constant on stack
.106c	95 41		sta $41,x			sta 	NSMantissa0,x 				; save byte
.106e	74 4d		stz $4d,x			stz 	NSMantissa1,x 				; clear MSB
.1070					ClearRestWord:
.1070	74 59		stz $59,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.1072	74 65		stz $65,x			stz 	NSMantissa3,x
.1074	74 71		stz $71,x			stz 	NSExponent,x
.1076	74 35		stz $35,x			stz 	NSStatus,x
.1078	80 af		bra $1029			bra 	NextCommand
.107a					PushWordCommand:
.107a	fa		plx				plx
.107b	e8		inx				inx
.107c	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.107e	c8		iny				iny
.107f	95 41		sta $41,x			sta 	NSMantissa0,x
.1081	b1 28		lda ($28),y			lda 	(codePtr),y
.1083	c8		iny				iny
.1084	95 4d		sta $4d,x			sta 	NSMantissa1,x
.1086	80 e8		bra $1070			bra 	ClearRestWord 				; handle everything else.
.1088					NXCommand:
.1088	c8		iny				iny 								; consume command.
.1089	10 03		bpl $108e			bpl 	_NXCommandNoFixUp
.108b	20 94 10	jsr $1094			jsr 	FixUpY
.108e					_NXCommandNoFixUp:
.108e	0a		asl a				asl 	a 							; shift left
.108f	da		phx				phx 								; save SP on stack
.1090	aa		tax				tax				 					; and jump indirect
.1091	7c 67 21	jmp ($2167,x)			jmp 	(VectorTable,x)
.1094					FixUpY:
.1094	48		pha				pha
.1095	98		tya				tya
.1096	18		clc				clc
.1097	65 28		adc $28				adc 	codePtr
.1099	85 28		sta $28				sta 	codePtr
.109b	90 02		bcc $109f			bcc 	_NoCPCarry
.109d	e6 29		inc $29				inc 	codePtr+1
.109f					_NoCPCarry:
.109f	a0 00		ldy #$00			ldy 	#0
.10a1	68		pla				pla
.10a2	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.10a3					AbsoluteTOS:
.10a3	fa		plx				plx
.10a4	74 35		stz $35,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.10a6	4c 29 10	jmp $1029			jmp 	NextCommand
.10a9					CommandVarSpace:
.10a9	fa		plx				plx
.10aa	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.10ac	85 26		sta $26				sta 	availableMemory
.10ae	c8		iny				iny
.10af	b1 28		lda ($28),y			lda 	(codePtr),y
.10b1	18		clc				clc
.10b2	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.10b5	85 27		sta $27				sta 	availableMemory+1
.10b7	c8		iny				iny
.10b8	4c 29 10	jmp $1029			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.10bb					BinaryAnd:
.10bb	fa		plx				plx
.10bc	38		sec				sec
.10bd	80 02		bra $10c1			bra 	AndOrCommon
.10bf					BinaryOr:
.10bf	fa		plx				plx
.10c0	18		clc				clc
.10c1					AndOrCommon:
.10c1	08		php				php 								; save AND/OR flag
.10c2	20 10 18	jsr $1810			jsr 	GetInteger16Bit
.10c5	ca		dex				dex
.10c6	20 10 18	jsr $1810			jsr 	GetInteger16Bit
.10c9	28		plp				plp
.10ca	90 0e		bcc $10da			bcc 	_AOCOrCode
.10cc	b5 41		lda $41,x			lda 	NSMantissa0,x 				; AND code
.10ce	35 42		and $42,x			and		NSMantissa0+1,x
.10d0	95 41		sta $41,x			sta 	NSMantissa0,x
.10d2	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.10d4	35 4e		and $4e,x			and		NSMantissa1+1,x
.10d6	95 4d		sta $4d,x			sta 	NSMantissa1,x
.10d8	80 0c		bra $10e6			bra 	_AOCComplete
.10da					_AOCOrCode:
.10da	b5 41		lda $41,x			lda 	NSMantissa0,x 				; OR code
.10dc	15 42		ora $42,x			ora		NSMantissa0+1,x
.10de	95 41		sta $41,x			sta 	NSMantissa0,x
.10e0	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.10e2	15 4e		ora $4e,x			ora		NSMantissa1+1,x
.10e4	95 4d		sta $4d,x			sta 	NSMantissa1,x
.10e6					_AOCComplete:
.10e6	74 35		stz $35,x			stz 	NSStatus,x 					; make integer ?
.10e8	34 4d		bit $4d,x			bit 	NSMantissa1,x 				; result is -ve
.10ea	10 07		bpl $10f3			bpl 	_AOCExit
.10ec	20 20 18	jsr $1820			jsr 	Negate16Bit 				; 2's complement
.10ef	a9 80		lda #$80			lda 	#$80 						; make it -ve
.10f1	95 35		sta $35,x			sta 	NSStatus,x
.10f3					_AOCExit:
.10f3	4c 29 10	jmp $1029			jmp 	NextCommand
.10f6					ArrayConvert:
.10f6	fa		plx				plx
.10f7	5a		phy				phy
.10f8	b5 41		lda $41,x			lda 	NSMantissa0,x
.10fa	85 31		sta $31				sta 	zTemp1
.10fc	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.10fe	18		clc				clc
.10ff	6d 07 04	adc $0407			adc 	variableStartPage
.1102	85 32		sta $32				sta 	zTemp1+1
.1104	ca		dex				dex 								; count of indices to follow -> zTemp2
.1105	20 0a 18	jsr $180a			jsr 	GetInteger8Bit
.1108	85 33		sta $33				sta 	zTemp2 						; subtract from stack.
.110a	8a		txa				txa
.110b	38		sec				sec
.110c	e5 33		sbc $33				sbc 	zTemp2
.110e	aa		tax				tax
.110f	da		phx				phx 								; stack points at the first index, which will be replaced.
.1110					_ACIndexLoop:
.1110	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart 			; integer array index
.1113	20 10 18	jsr $1810			jsr 	GetInteger16Bit 			; get the index => zTemp0
.1116	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.1118	a5 2f		lda $2f				lda 	zTemp0
.111a	d2 31		cmp ($31)			cmp 	(zTemp1)
.111c	a5 30		lda $30				lda 	zTemp0+1
.111e	f1 31		sbc ($31),y			sbc 	(zTemp1),y
.1120	b0 79		bcs $119b			bcs 	_ACBadIndex 				; index error.
.1122	c6 33		dec $33				dec 	zTemp2 						; decrement count, if zero, then innermost level
.1124	f0 29		beq $114f			beq 	_ACInnerLevel
.1126	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.1128	b1 31		lda ($31),y			lda 	(zTemp1),y
.112a	10 6f		bpl $119b			bpl 	_ACBadIndex
.112c	06 2f		asl $2f				asl 	zTemp0 						; double the index and add it to the base address
.112e	26 30		rol $30				rol 	zTemp0+1
.1130	18		clc				clc
.1131	a5 2f		lda $2f				lda		zTemp0
.1133	65 31		adc $31				adc 	zTemp1
.1135	85 2f		sta $2f				sta 	zTemp0
.1137	a5 30		lda $30				lda		zTemp0+1
.1139	65 32		adc $32				adc 	zTemp1+1
.113b	85 30		sta $30				sta 	zTemp0+1
.113d	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.113f	b1 2f		lda ($2f),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.1141	85 31		sta $31				sta 	zTemp1
.1143	c8		iny				iny
.1144	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.1146	18		clc				clc
.1147	6d 07 04	adc $0407			adc 	variableStartPage
.114a	85 32		sta $32				sta 	zTemp1+1
.114c	e8		inx				inx 								; next index
.114d	80 c1		bra $1110			bra 	_ACIndexLoop
.114f					_ACInnerLevel:
.114f	a0 02		ldy #$02			ldy 	#2
.1151	b1 31		lda ($31),y			lda 	(zTemp1),y
.1153	30 46		bmi $119b			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.1155	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.1157	c9 00		cmp #$00			cmp 	#NSSIFloat
.1159	d0 13		bne $116e			bne 	_ACNotFloat
.115b	a5 30		lda $30				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.115d	48		pha				pha
.115e	a5 2f		lda $2f				lda 	zTemp0
.1160	06 2f		asl $2f				asl 	zTemp0 						; x 2
.1162	26 30		rol $30				rol 	zTemp0+1
.1164	18		clc				clc 								; add back x 3
.1165	65 2f		adc $2f				adc 	zTemp0
.1167	85 2f		sta $2f				sta 	zTemp0
.1169	68		pla				pla
.116a	65 30		adc $30				adc 	zTemp0+1
.116c	85 30		sta $30				sta 	zTemp0+1
.116e					_ACNotFloat:
.116e	06 2f		asl $2f				asl 	zTemp0 						; x 2 or x 6 depending.
.1170	26 30		rol $30				rol 	zTemp0+1
.1172	18		clc				clc
.1173	a5 2f		lda $2f				lda 	zTemp0
.1175	69 03		adc #$03			adc 	#3
.1177	85 2f		sta $2f				sta 	zTemp0
.1179	90 02		bcc $117d			bcc 	_ACNoCarry
.117b	e6 30		inc $30				inc 	zTemp0+1
.117d					_ACNoCarry:
.117d	fa		plx				plx 								; X points to first slot of array parameters
.117e	18		clc				clc
.117f	a5 2f		lda $2f				lda 	zTemp0
.1181	65 31		adc $31				adc 	zTemp1
.1183	95 41		sta $41,x			sta 	NSMantissa0,x
.1185	a5 30		lda $30				lda 	zTemp0+1
.1187	65 32		adc $32				adc 	zTemp1+1
.1189	38		sec				sec
.118a	ed 07 04	sbc $0407			sbc 	variableStartPage
.118d	95 4d		sta $4d,x			sta 	NSMantissa1,x
.118f	74 59		stz $59,x			stz 	NSMantissa2,x
.1191	74 65		stz $65,x			stz 	NSMantissa3,x
.1193	74 35		stz $35,x			stz 	NSStatus,x
.1195	74 71		stz $71,x			stz 	NSExponent,x
.1197	7a		ply				ply 	 							; restore code pointer
.1198	4c 29 10	jmp $1029			jmp 	NextCommand
.119b					_ACBadIndex:
.119b	4c ae 27	jmp $27ae		jmp	ErrorV_index
.119e					UnaryAsc:
.119e	fa		plx				plx
.119f	5a		phy				phy
.11a0	b5 41		lda $41,x			lda 	NSMantissa0,x 				; string address.
.11a2	85 2f		sta $2f				sta 	zTemp0
.11a4	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.11a6	85 30		sta $30				sta 	zTemp0+1
.11a8	b2 2f		lda ($2f)			lda 	(zTemp0) 					; if empty string return zero
.11aa	f0 06		beq $11b2			beq 	_UAExit
.11ac	5a		phy				phy 								; otherwise first character
.11ad	a0 01		ldy #$01			ldy 	#1
.11af	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.11b1	7a		ply				ply
.11b2					_UAExit:
.11b2	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.11b5	7a		ply				ply
.11b6	4c 29 10	jmp $1029			jmp 	NextCommand
.11b9					CommandAssert:
.11b9	fa		plx				plx
.11ba	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.11bc	d0 09		bne $11c7			bne 	_CAFail
.11be	20 3b 2e	jsr $2e3b			jsr 	FloatIsZero 				; is it zero ?
.11c1	f0 04		beq $11c7			beq 	_CAFail
.11c3	ca		dex				dex
.11c4	4c 29 10	jmp $1029			jmp 	NextCommand
.11c7					_CAFail:
.11c7	4c 07 27	jmp $2707		jmp	ErrorV_assert
.11ca					X16_Audio_Parameters8_16:
.11ca	20 d0 11	jsr $11d0			jsr 	X16_Audio_Parameters8_8
.11cd	a4 4e		ldy $4e				ldy 	NSMantissa1+1
.11cf	60		rts				rts
.11d0					X16_Audio_Parameters8_8:
.11d0	a2 01		ldx #$01			ldx 	#1
.11d2	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.11d5	ca		dex				dex
.11d6	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.11d9	20 0a 18	jsr $180a			jsr 	GetInteger8Bit
.11dc	a6 42		ldx $42				ldx 	NSMantissa0+1
.11de	a0 00		ldy #$00			ldy 	#0
.11e0	60		rts				rts
.11e1					X16_Audio_Parameters8_String:
.11e1	20 ca 11	jsr $11ca			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.11e4	da		phx				phx 								; set the voice
.11e5	5a		phy				phy
.11e6	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.11e9	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>11ec	0a						.byte 	X16_AudioCodeBank
.11ed	7a		ply				ply
.11ee	fa		plx				plx
.11ef	86 2f		stx $2f				stx 	zTemp0
.11f1	84 30		sty $30				sty 	zTemp0+1
.11f3	b2 2f		lda ($2f)			lda 	(zTemp0) 					; read length
.11f5	e8		inx				inx 								; point YX to first character.
.11f6	d0 01		bne $11f9			bne 	_X16APSSkip
.11f8	c8		iny				iny
.11f9					_X16APSSkip:
.11f9	60		rts				rts
.11fa					Unary16Bin:
.11fa	fa		plx				plx
.11fb	20 10 18	jsr $1810			jsr 	GetInteger16Bit				; 16 bit int
.11fe	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.1200	20 e6 1e	jsr $1ee6			jsr 	StringAllocTemp
.1203	a5 30		lda $30				lda 	zTemp0+1
.1205	f0 03		beq $120a			beq 	_UBNoHigh
.1207	20 12 12	jsr $1212			jsr 	_UBWriteBinary
.120a					_UBNoHigh:
.120a	a5 2f		lda $2f				lda 	zTemp0
.120c	20 12 12	jsr $1212			jsr 	_UBWriteBinary
.120f	4c 29 10	jmp $1029			jmp 	NextCommand
.1212					_UBWriteBinary:
.1212	5a		phy				phy
.1213	a0 08		ldy #$08			ldy 	#8
.1215					_UBWLoop:
.1215	0a		asl a				asl 	a
.1216	48		pha				pha
.1217	a9 00		lda #$00			lda  	#0
.1219	69 30		adc #$30			adc 	#48
.121b	20 0f 1f	jsr $1f0f			jsr 	StringWriteChar
.121e	68		pla				pla
.121f	88		dey				dey
.1220	d0 f3		bne $1215			bne 	_UBWLoop
.1222	7a		ply				ply
.1223	60		rts				rts
.1224					PrintCharacter:
.1224	fa		plx				plx
.1225	b5 41		lda $41,x			lda 	NSMantissa0,x
.1227	ca		dex				dex
.1228	20 43 1b	jsr $1b43			jsr 	VectorPrintCharacter
.122b	4c 29 10	jmp $1029			jmp 	NextCommand
.122e					UnaryChr:
.122e	fa		plx				plx
.122f	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; get integer to convert.
.1232	48		pha				pha 								; save it and allocate for it
.1233	a9 01		lda #$01			lda 	#1 							; 1 character
.1235	20 e6 1e	jsr $1ee6			jsr 	StringAllocTemp
.1238	a9 01		lda #$01			lda 	#1 							; length 1.
.123a	92 22		sta ($22)			sta 	(zsTemp)
.123c	68		pla				pla 								; character code makes string.
.123d	5a		phy				phy
.123e	a0 01		ldy #$01			ldy 	#1
.1240	91 22		sta ($22),y			sta 	(zsTemp),y
.1242	7a		ply				ply
.1243	4c 29 10	jmp $1029			jmp 	NextCommand
.1246					CommandClr:
.1246	fa		plx				plx
.1247	20 4d 12	jsr $124d			jsr 	ClearMemory
.124a	4c 29 10	jmp $1029			jmp 	NextCommand
.124d					ClearMemory:
.124d	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.1250	85 30		sta $30				sta 	zTemp0+1
.1252	64 2f		stz $2f				stz 	zTemp0
.1254	5a		phy				phy
.1255	a0 00		ldy #$00			ldy 	#0
.1257					_ClearLoop1:
.1257	a9 00		lda #$00			lda 	#0
.1259	91 2f		sta ($2f),y			sta 	(zTemp0),y
.125b	c8		iny				iny
.125c	d0 f9		bne $1257			bne 	_ClearLoop1
.125e	e6 30		inc $30				inc 	zTemp0+1
.1260	a5 30		lda $30				lda 	zTemp0+1
.1262	cd 06 04	cmp $0406			cmp 	storeEndHigh
.1265	d0 f0		bne $1257			bne 	_ClearLoop1
.1267	38		sec				sec 											; stack space = number of pages in total / 4
.1268	ad 06 04	lda $0406			lda 	storeEndHigh
.126b	ed 05 04	sbc $0405			sbc		storeStartHigh
.126e	4a		lsr a				lsr 	a
.126f	4a		lsr a				lsr 	a
.1270	d0 02		bne $1274			bne 	_NotEmpty 								; at least 1 !
.1272	a9 01		lda #$01			lda 	#1
.1274					_NotEmpty:
.1274	38		sec				sec 											; subtract from high to give string high memory
.1275	49 ff		eor #$ff			eor 	#$FF
.1277	6d 06 04	adc $0406			adc 	storeEndHigh
.127a	8d 03 04	sta $0403			sta 	stringHighMemory+1
.127d	9c 02 04	stz $0402			stz 	stringHighMemory
.1280	9c 68 05	stz $0568			stz 	stringInitialised 						; string system not initialised
.1283	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.1286	3a		dec a				dec 	a
.1287	85 25		sta $25				sta 	runtimeStackPtr+1
.1289	a9 ff		lda #$ff			lda 	#$FF
.128b	85 24		sta $24				sta 	runtimeStackPtr
.128d	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.128f	92 24		sta ($24)			sta 	(runtimeStackPtr)
.1291	7a		ply				ply
.1292	60		rts				rts
.1293					CompareStrings:
.1293	fa		plx				plx
.1294	ca		dex				dex
.1295	b5 41		lda $41,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.1297	85 2f		sta $2f				sta 	zTemp0
.1299	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.129b	85 30		sta $30				sta 	zTemp0+1
.129d	b5 42		lda $42,x			lda 	NSMantissa0+1,x
.129f	85 31		sta $31				sta 	zTemp1
.12a1	b5 4e		lda $4e,x			lda 	NSMantissa1+1,x
.12a3	85 32		sta $32				sta 	zTemp1+1
.12a5	da		phx				phx
.12a6	5a		phy				phy
.12a7	b2 2f		lda ($2f)			lda 	(zTemp0)					; work out number to compare
.12a9	d2 31		cmp ($31)			cmp 	(zTemp1)
.12ab	90 02		bcc $12af			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.12ad	b2 31		lda ($31)			lda 	(zTemp1)
.12af					_CSNIsSmallest:
.12af	aa		tax				tax 								; count in X
.12b0	f0 0c		beq $12be			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.12b2	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.12b4					_CSNCompareString:
.12b4	c8		iny				iny 								; pre increment
.12b5	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.12b7	d1 31		cmp ($31),y			cmp 	(zTemp1),y
.12b9	d0 0a		bne $12c5			bne 	_CSNDifferent 				; numbers are different.
.12bb	ca		dex				dex
.12bc	d0 f6		bne $12b4			bne 	_CSNCompareString 			; compare common characters in two strings.
.12be					_CSNMatches:
.12be	38		sec				sec
.12bf	b2 2f		lda ($2f)			lda 	(zTemp0)					; compare lengths
.12c1	f2 31		sbc ($31)			sbc 	(zTemp1)
.12c3	f0 06		beq $12cb			beq 	_CSNSExit 					; if zero, then strings match and exit.
.12c5					_CSNDifferent:
.12c5	a9 ff		lda #$ff			lda 	#$FF
.12c7	90 02		bcc $12cb			bcc 	_CSNSExit
.12c9	a9 01		lda #$01			lda 	#$01
.12cb					_CSNSExit:
.12cb	7a		ply				ply
.12cc	fa		plx				plx
.12cd	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.12cf	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte 				; output the byte
.12d2	4c 29 10	jmp $1029			jmp 	NextCommand
.12d5					StringConcrete:
.12d5	9c 68 05	stz $0568			stz 	stringInitialised	 		; initialise next usage
.12d8	84 34		sty $34				sty 	zTemp2+1 					; save pointer to new string
.12da	85 33		sta $33				sta 	zTemp2
.12dc	b2 33		lda ($33)			lda 	(zTemp2) 					; length required
.12de	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.12df	18		clc				clc
.12e0	72 33		adc ($33)			adc 	(zTemp2)
.12e2	90 02		bcc $12e6			bcc 	_SCNoOverflow
.12e4	a9 ff		lda #$ff			lda 	#255
.12e6					_SCNoOverflow:
.12e6	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.12e8	b0 02		bcs $12ec			bcs 	_SCNoMinimum
.12ea	a9 0a		lda #$0a			lda 	#10
.12ec					_SCNoMinimum:
.12ec	85 31		sta $31				sta 	zTemp1 						; save max length.
.12ee	38		sec				sec
.12ef	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.12f2	e5 31		sbc $31				sbc 	zTemp1
.12f4	a8		tay				tay
.12f5	ad 03 04	lda $0403			lda 	stringHighMemory+1
.12f8	e9 00		sbc #$00			sbc 	#0
.12fa	48		pha				pha
.12fb	38		sec				sec 								; subtract 3 more
.12fc	98		tya				tya
.12fd	e9 03		sbc #$03			sbc 	#3
.12ff	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.1302	85 22		sta $22				sta 	zsTemp
.1304	68		pla				pla
.1305	e9 00		sbc #$00			sbc 	#0
.1307	8d 03 04	sta $0403			sta 	stringHighMemory+1
.130a	85 23		sta $23				sta 	zsTemp+1
.130c	a5 31		lda $31				lda 	zTemp1 						; set max length.
.130e	92 22		sta ($22)			sta 	(zsTemp)
.1310	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.1312	a9 00		lda #$00			lda 	#0
.1314	91 22		sta ($22),y			sta 	(zsTemp),y
.1316	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.1318	a4 23		ldy $23				ldy 	zsTemp+1
.131a	60		rts				rts
.131b					CommandData:
.131b	fa		plx				plx
.131c	98		tya				tya 								; data length +1 added to Y
.131d	38		sec				sec
.131e	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.1320	a8		tay				tay
.1321	4c 29 10	jmp $1029			jmp 	NextCommand
.1324					CommandDIM:
.1324	fa		plx				plx
.1325	5a		phy				phy
.1326	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.1329	8d 08 04	sta $0408			sta 	dimType
.132c	ca		dex				dex 								; this is the number of indices
.132d	20 0a 18	jsr $180a			jsr 	GetInteger8Bit
.1330	85 31		sta $31				sta 	zTemp1 						; subtract n from X so X points at the *first*
.1332	8a		txa				txa 								; dimension.
.1333	38		sec				sec
.1334	e5 31		sbc $31				sbc 	zTemp1
.1336	aa		tax				tax
.1337	a5 31		lda $31				lda 	zTemp1 						; number of indices.
.1339	20 4d 13	jsr $134d			jsr 	DIMCreateOneLevel 			; create one at this level
.133c	95 41		sta $41,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.133e	98		tya				tya
.133f	95 4d		sta $4d,x			sta 	NSMantissa1,x
.1341	74 59		stz $59,x			stz 	NSMantissa2,x
.1343	74 65		stz $65,x			stz 	NSMantissa3,x
.1345	74 35		stz $35,x			stz 	NSStatus,x
.1347	74 71		stz $71,x			stz 	NSExponent,x
.1349	7a		ply				ply
.134a	4c 29 10	jmp $1029			jmp 	NextCommand
.134d					DIMCreateOneLevel:
.134d	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.134f	5a		phy				phy
.1350	a4 27		ldy $27				ldy 	availableMemory+1
.1352	5a		phy				phy
.1353	a8		tay				tay 			 					; save current level into Y
.1354	20 10 18	jsr $1810			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.1357	e6 2f		inc $2f				inc 	zTemp0 						; bump the size of the dimension as we need one more
.1359	d0 02		bne $135d			bne 	_DCOLNoCarry
.135b	e6 30		inc $30				inc 	zTemp0+1
.135d					_DCOLNoCarry:
.135d	a5 2f		lda $2f				lda 	zTemp0 						; write out the +1 size of the dimension
.135f	20 00 14	jsr $1400			jsr 	DIMWriteByte
.1362	a5 30		lda $30				lda 	zTemp0+1
.1364	20 00 14	jsr $1400			jsr 	DIMWriteByte
.1367	ad 08 04	lda $0408			lda 	dimType 					; get type information
.136a	29 7f		and #$7f			and 	#$7F
.136c	c0 01		cpy #$01			cpy 	#1
.136e	f0 02		beq $1372			beq 	_DCOLNoSubLevel
.1370	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.1372					_DCOLNoSubLevel:
.1372	20 00 14	jsr $1400			jsr 	DIMWriteByte
.1375	a5 26		lda $26				lda 	availableMemory
.1377	85 31		sta $31				sta 	zTemp1
.1379	a5 27		lda $27				lda 	availableMemory+1
.137b	85 32		sta $32				sta 	zTemp1+1
.137d	a5 2f		lda $2f				lda 	zTemp0
.137f	85 33		sta $33				sta 	zTemp2
.1381	a5 30		lda $30				lda 	zTemp0+1
.1383	85 34		sta $34				sta 	zTemp2+1
.1385					_DCOLFillArray:
.1385	20 e4 13	jsr $13e4			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.1388	a5 2f		lda $2f				lda 	zTemp0 						; decrement one from count.
.138a	d0 02		bne $138e			bne 	_DCOLNoBorrow
.138c	c6 30		dec $30				dec 	zTemp0+1
.138e					_DCOLNoBorrow:
.138e	c6 2f		dec $2f				dec 	zTemp0
.1390	a5 2f		lda $2f				lda 	zTemp0 						; until completed.
.1392	05 30		ora $30				ora 	zTemp0+1
.1394	d0 ef		bne $1385			bne 	_DCOLFillArray
.1396	c0 01		cpy #$01			cpy 	#1
.1398	f0 42		beq $13dc			beq 	_DCOLExit
.139a					_DCOLRecursionLoop:
.139a	da		phx				phx 								; save XY
.139b	5a		phy				phy
.139c	a5 31		lda $31				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.139e	48		pha				pha
.139f	a5 32		lda $32				lda 	zTemp1+1
.13a1	48		pha				pha
.13a2	a5 33		lda $33				lda 	zTemp2
.13a4	48		pha				pha
.13a5	a5 34		lda $34				lda 	zTemp2+1
.13a7	48		pha				pha
.13a8	88		dey				dey  								; lower level -> A
.13a9	98		tya				tya
.13aa	e8		inx				inx 								; next index size
.13ab	20 4d 13	jsr $134d			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.13ae	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.13af	86 34		stx $34				stx 	zTemp2+1
.13b1	fa		plx				plx
.13b2	86 33		stx $33				stx 	zTemp2
.13b4	fa		plx				plx
.13b5	86 32		stx $32				stx 	zTemp1+1
.13b7	fa		plx				plx
.13b8	86 31		stx $31				stx 	zTemp1
.13ba	92 31		sta ($31)			sta 	(zTemp1) 					; write out position
.13bc	98		tya				tya
.13bd	a0 01		ldy #$01			ldy 	#1
.13bf	91 31		sta ($31),y			sta 	(zTemp1),y
.13c1	7a		ply				ply 								; restore XY
.13c2	fa		plx				plx
.13c3	18		clc				clc
.13c4	a5 31		lda $31				lda 	zTemp1 						; add 2 to zTemp1
.13c6	69 02		adc #$02			adc 	#2
.13c8	85 31		sta $31				sta 	zTemp1
.13ca	90 02		bcc $13ce			bcc 	_DCOLRNoCarry
.13cc	e6 32		inc $32				inc 	zTemp1+1
.13ce					_DCOLRNoCarry:
.13ce	a5 33		lda $33				lda 	zTemp2 						; decrement one from count in zTemp2
.13d0	d0 02		bne $13d4			bne 	_DCOLRNoBorrow
.13d2	c6 34		dec $34				dec 	zTemp2+1
.13d4					_DCOLRNoBorrow:
.13d4	c6 33		dec $33				dec 	zTemp2
.13d6	a5 33		lda $33				lda 	zTemp2 						; until completed.
.13d8	05 34		ora $34				ora 	zTemp2+1
.13da	d0 be		bne $139a			bne 	_DCOLRecursionLoop
.13dc					_DCOLExit:
.13dc	68		pla				pla 								; get MSB, make offset again
.13dd	38		sec				sec
.13de	ed 07 04	sbc $0407			sbc 	variableStartPage
.13e1	a8		tay				tay
.13e2	68		pla				pla 								; YA now contains offset address.
.13e3	60		rts				rts
.13e4					DIMWriteElement:
.13e4	da		phx				phx
.13e5	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.13e7	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.13e9	d0 0b		bne $13f6			bne 	_DIMWENotFloat
.13eb	ad 08 04	lda $0408			lda 	dimType
.13ee	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.13f0	c9 00		cmp #$00			cmp 	#NSSIFloat
.13f2	d0 02		bne $13f6			bne 	_DIMWENotFloat
.13f4	a2 06		ldx #$06			ldx 	#6
.13f6					_DIMWENotFloat:
.13f6	a9 00		lda #$00			lda 	#0
.13f8	20 00 14	jsr $1400			jsr 	DIMWriteByte
.13fb	ca		dex				dex
.13fc	d0 f8		bne $13f6			bne 	_DIMWENotFloat
.13fe	fa		plx				plx
.13ff	60		rts				rts
.1400					DIMWriteByte:
.1400	92 26		sta ($26)			sta 	(availableMemory)
.1402	e6 26		inc $26				inc 	availableMemory
.1404	d0 0b		bne $1411			bne 	_DIMWBSkip
.1406	e6 27		inc $27				inc 	availableMemory+1
.1408	48		pha				pha
.1409	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.140b	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.140e	b0 02		bcs $1412			bcs 	_DIMWBMemory
.1410	68		pla				pla
.1411					_DIMWBSkip:
.1411	60		rts				rts
.1412					_DIMWBMemory:
.1412	4c c1 27	jmp $27c1		jmp	ErrorV_memory
.0408					dimType:
>0408							.fill 	1
.1415					CommandEnd:
.1415	fa		plx				plx
.1416	86 2f		stx $2f				stx 	zTemp0
.1418	4c ff ff	jmp $ffff			jmp 	$FFFF
.141b					Unimplemented:
.141b	4c f4 26	jmp $26f4			jmp 	ErrorV_unimplemented
.141e					ErrorHandler:
.141e	98		tya				tya
.141f	18		clc				clc
.1420	65 28		adc $28				adc 	codePtr
.1422	85 28		sta $28				sta 	codePtr
.1424	90 02		bcc $1428			bcc 	_EHNoCarry
.1426	e6 29		inc $29				inc 	codePtr+1
.1428					_EHNoCarry:
.1428	68		pla				pla
.1429	7a		ply				ply
.142a	85 2f		sta $2f				sta 	zTemp0
.142c	84 30		sty $30				sty 	zTemp0+1
.142e	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.1430	a0 01		ldy #$01			ldy 	#1
.1432					_EHDisplayMsg:
.1432	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.1434	20 5b 24	jsr $245b			jsr 	XPrintCharacterToChannel
.1437	c8		iny				iny
.1438	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.143a	d0 f6		bne $1432			bne 	_EHDisplayMsg
.143c	a9 20		lda #$20			lda 	#32
.143e	20 5b 24	jsr $245b			jsr 	XPrintCharacterToChannel
.1441	a9 40		lda #$40			lda 	#64
.1443	20 5b 24	jsr $245b			jsr 	XPrintCharacterToChannel
.1446	a9 20		lda #$20			lda 	#32
.1448	20 5b 24	jsr $245b			jsr 	XPrintCharacterToChannel
.144b	20 50 14	jsr $1450			jsr 	EHDisplayCodePtr
.144e	80 fe		bra $144e	_EHStop:bra 	_EHStop
.1450					EHDisplayCodePtr:
.1450	a9 20		lda #$20			lda 	#32
.1452	20 5b 24	jsr $245b			jsr 	XPrintCharacterToChannel
.1455	38		sec				sec
.1456	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.1458	ed 04 04	sbc $0404			sbc 	runtimeHigh
.145b	20 64 14	jsr $1464			jsr 	_EHDisplayHex
.145e	a5 28		lda $28				lda 	codePtr
.1460	20 64 14	jsr $1464			jsr 	_EHDisplayHex
.1463	60		rts				rts
.1464					_EHDisplayHex:
.1464	48		pha				pha
.1465	4a		lsr a				lsr 	a
.1466	4a		lsr a				lsr 	a
.1467	4a		lsr a				lsr 	a
.1468	4a		lsr a				lsr 	a
.1469	20 6d 14	jsr $146d			jsr 	_EHDisplayNibble
.146c	68		pla				pla
.146d					_EHDisplayNibble:
.146d	29 0f		and #$0f			and 	#15
.146f	c9 0a		cmp #$0a			cmp 	#10
.1471	90 02		bcc $1475			bcc 	_EHNotHex
.1473	69 06		adc #$06			adc 	#6
.1475					_EHNotHex:
.1475	69 30		adc #$30			adc 	#48
.1477	4c 5b 24	jmp $245b			jmp 	XPrintCharacterToChannel
.147a					CommandFor:
.147a	fa		plx				plx
.147b	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.147d	20 fd 14	jsr $14fd			jsr 	StackOpenFrame
.1480	20 41 19	jsr $1941			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.1483	a0 07		ldy #$07			ldy 	#7 							; copy step out
.1485	20 df 14	jsr $14df			jsr 	CopyTOSToOffsetY
.1488	ca		dex				dex
.1489	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.148b	20 df 14	jsr $14df			jsr 	CopyTOSToOffsetY
.148e	ca		dex				dex
.148f	b5 4d		lda $4d,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.1491	29 80		and #$80			and 	#$80
.1493	a0 04		ldy #$04			ldy 	#4
.1495	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1497	b5 41		lda $41,x			lda 	NSMantissa0,x 				; copy the reference address
.1499	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.149b	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.149d	85 2f		sta $2f				sta 	zTemp0 						; also to zTemp0
.149f	c8		iny				iny
.14a0	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.14a2	18		clc				clc
.14a3	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.14a5	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14a7	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.14aa	85 30		sta $30				sta 	zTemp0+1
.14ac	ca		dex				dex 								; throw reference.
.14ad	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.14af	b1 2f		lda ($2f),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.14b1	a0 0c		ldy #$0c			ldy 	#12
.14b3	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.14b5	a0 12		ldy #$12			ldy 	#18
.14b7	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.14b9	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.14bb	88		dey				dey 								; now the exponents.
.14bc	11 2f		ora ($2f),y			ora 	(zTemp0),y
.14be	a0 0b		ldy #$0b			ldy 	#11
.14c0	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.14c2	a0 11		ldy #$11			ldy 	#17
.14c4	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.14c6	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.14c8	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.14ca	c8		iny				iny
.14cb	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.14cd	c8		iny				iny
.14ce	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.14d0	d0 08		bne $14da			bne 	_CFNoOptimise
.14d2	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.14d4	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.14d6	09 40		ora #$40			ora 	#$40
.14d8	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14da					_CFNoOptimise:
.14da	a0 00		ldy #$00			ldy 	#0
.14dc	4c 29 10	jmp $1029			jmp 	NextCommand
.14df					CopyTOSToOffsetY:
.14df	b5 41		lda $41,x			lda 	NSMantissa0,x
.14e1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14e3	c8		iny				iny
.14e4	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.14e6	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14e8	c8		iny				iny
.14e9	b5 59		lda $59,x			lda 	NSMantissa2,x
.14eb	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14ed	c8		iny				iny
.14ee	b5 65		lda $65,x			lda 	NSMantissa3,x
.14f0	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14f2	c8		iny				iny
.14f3	b5 71		lda $71,x			lda 	NSExponent,x
.14f5	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14f7	c8		iny				iny
.14f8	b5 35		lda $35,x			lda 	NSStatus,x
.14fa	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14fc	60		rts				rts
.14fd					StackOpenFrame:
.14fd	48		pha				pha 								; save frame marker
.14fe	29 1f		and #$1f			and 	#$1F 						; bytes required.
.1500	85 2f		sta $2f				sta 	zTemp0
.1502	38		sec				sec 								; subtract from runtime stack pointer.
.1503	a5 24		lda $24				lda		runtimeStackPtr
.1505	e5 2f		sbc $2f				sbc 	zTemp0
.1507	85 24		sta $24				sta 	runtimeStackPtr
.1509	a5 25		lda $25				lda		runtimeStackPtr+1
.150b	e9 00		sbc #$00			sbc 	#0
.150d	85 25		sta $25				sta 	runtimeStackPtr+1
.150f	68		pla				pla 								; put frame marker at +0
.1510	92 24		sta ($24)			sta 	(runtimeStackPtr)
.1512	60		rts				rts
.1513					StackCloseFrame:
.1513	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.1515	29 1f		and #$1f			and 	#$1F 						; size
.1517	18		clc				clc
.1518	65 24		adc $24				adc 	runtimeStackPtr
.151a	85 24		sta $24				sta 	runtimeStackPtr
.151c	90 02		bcc $1520			bcc 	_SCFNoCarry
.151e	e6 25		inc $25				inc 	runtimeStackPtr+1
.1520					_SCFNoCarry:
.1520	60		rts				rts
.1521					StackFindFrame:
.1521	8d 09 04	sta $0409			sta 	requiredFrame
.1524					_SFFLoop:
.1524	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.1526	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.1528	f0 10		beq $153a			beq 	SCFFail
.152a	cd 09 04	cmp $0409			cmp 	requiredFrame 				; found this type ?
.152d	f0 05		beq $1534			beq 	_SFFFound
.152f	20 13 15	jsr $1513			jsr 	StackCloseFrame 			; close the top frame
.1532	80 f0		bra $1524			bra 	_SFFLoop 					; and try te next.
.1534					_SFFFound:
.1534	60		rts				rts
.1535					StackCheckFrame:
.1535	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.1537	d0 01		bne $153a			bne 	SCFFail
.1539	60		rts				rts
.153a					SCFFail:
.153a	4c 51 27	jmp $2751		jmp	ErrorV_structure
.0409					requiredFrame:
>0409							.fill 	1
.153d					UnaryFre:
.153d	fa		plx				plx
.153e	20 19 2e	jsr $2e19			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.1541	38		sec				sec
.1542	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.1545	ed 00 04	sbc $0400			sbc 	stringLowMemory
.1548	95 41		sta $41,x			sta		NSMantissa0,x
.154a	ad 03 04	lda $0403			lda 	stringHighMemory+1
.154d	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.1550	95 4d		sta $4d,x			sta		NSMantissa1,x
.1552	4c 29 10	jmp $1029			jmp 	NextCommand
.1555					CommandGet:
.1555	fa		plx				plx
.1556	e8		inx				inx
.1557	a9 01		lda #$01			lda 	#1 							; 1 character space
.1559	20 e6 1e	jsr $1ee6			jsr 	StringAllocTemp
.155c	20 4c 1b	jsr $1b4c			jsr 	VectorGetCharacter 			; get a character
.155f	c9 00		cmp #$00			cmp 	#0
.1561	f0 09		beq $156c			beq 	_CGNone
.1563	5a		phy				phy
.1564	a0 01		ldy #$01			ldy 	#1 							; store char
.1566	91 22		sta ($22),y			sta 	(zsTemp),y
.1568	98		tya				tya 								; store length.
.1569	92 22		sta ($22)			sta 	(zsTemp)
.156b	7a		ply				ply
.156c					_CGNone:
.156c	4c 29 10	jmp $1029			jmp 	NextCommand
.156f					CommandGosub:
.156f	fa		plx				plx
.1570	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.1572	20 fd 14	jsr $14fd			jsr 	StackOpenFrame
.1575	20 41 19	jsr $1941			jsr 	StackSaveCurrentPosition
.1578	4c 8e 15	jmp $158e			jmp 	PerformGOTO
.157b					CommandReturn:
.157b	fa		plx				plx
.157c	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.157e	20 21 15	jsr $1521			jsr 	StackFindFrame
.1581	20 57 19	jsr $1957			jsr 	StackLoadCurrentPosition
.1584	c8		iny				iny
.1585	c8		iny				iny
.1586	c8		iny				iny
.1587	20 13 15	jsr $1513			jsr 	StackCloseFrame
.158a	4c 29 10	jmp $1029			jmp 	NextCommand
.158d					CommandGoto:
.158d	fa		plx				plx
.158e					PerformGOTO:
.158e	c8		iny				iny
.158f	c8		iny				iny 								; push MSB of offset on stack
.1590	b1 28		lda ($28),y			lda 	(codePtr),y
.1592	48		pha				pha
.1593	88		dey				dey 								; point LSB of offset
.1594	18		clc				clc 								; add LSB
.1595	b1 28		lda ($28),y			lda 	(codePtr),y
.1597	65 28		adc $28				adc 	codePtr
.1599	85 28		sta $28				sta 	codePtr
.159b	68		pla				pla 								; restore offset MSB and add
.159c	65 29		adc $29				adc 	codePtr+1
.159e	85 29		sta $29				sta 	codePtr+1
.15a0	88		dey				dey 								; fix up.
.15a1	4c 29 10	jmp $1029			jmp 	NextCommand
.15a4					CommandGotoZ:
.15a4	fa		plx				plx
.15a5	20 3b 2e	jsr $2e3b			jsr 	FloatIsZero
.15a8	ca		dex				dex
.15a9	c9 00		cmp #$00			cmp 	#0
.15ab	f0 e1		beq $158e			beq 	PerformGOTO
.15ad	c8		iny				iny
.15ae	c8		iny				iny
.15af	c8		iny				iny
.15b0	4c 29 10	jmp $1029			jmp 	NextCommand
.15b3					CommandGotoNZ:
.15b3	fa		plx				plx
.15b4	20 3b 2e	jsr $2e3b			jsr 	FloatIsZero
.15b7	ca		dex				dex
.15b8	c9 00		cmp #$00			cmp 	#0
.15ba	d0 d2		bne $158e			bne 	PerformGOTO
.15bc	c8		iny				iny
.15bd	c8		iny				iny
.15be	c8		iny				iny
.15bf	4c 29 10	jmp $1029			jmp 	NextCommand
.15c2					Command_PSET:
.15c2	fa		plx				plx
.15c3	5a		phy				phy
.15c4	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; get the colour
.15c7	48		pha				pha
.15c8	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.15ca	a0 02		ldy #$02			ldy 	#X16_r0
.15cc	20 4e 16	jsr $164e			jsr 	GraphicsCopy2
.15cf	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.15d2	68		pla				pla 								; set pixel.
.15d3	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.15d6	7a		ply				ply
.15d7	a2 ff		ldx #$ff			ldx 	#$FF
.15d9	4c 29 10	jmp $1029			jmp 	NextCommand
.15dc					Command_LINE:
.15dc	fa		plx				plx
.15dd	5a		phy				phy
.15de	20 41 16	jsr $1641			jsr 	GraphicsColour
.15e1	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.15e3	a0 02		ldy #$02			ldy 	#X16_r0
.15e5	20 4b 16	jsr $164b			jsr 	GraphicsCopy4
.15e8	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.15eb	7a		ply				ply
.15ec	a2 ff		ldx #$ff			ldx 	#$FF
.15ee	4c 29 10	jmp $1029			jmp 	NextCommand
.15f1					Command_RECT:
.15f1	fa		plx				plx
.15f2	5a		phy				phy
.15f3	20 62 16	jsr $1662			jsr 	GraphicsRectCoords
.15f6	38		sec				sec
.15f7	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.15fa	7a		ply				ply
.15fb	a2 ff		ldx #$ff			ldx 	#$FF
.15fd	4c 29 10	jmp $1029			jmp 	NextCommand
.1600					Command_FRAME:
.1600	fa		plx				plx
.1601	5a		phy				phy
.1602	20 62 16	jsr $1662			jsr 	GraphicsRectCoords
.1605	18		clc				clc
.1606	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.1609	7a		ply				ply
.160a	a2 ff		ldx #$ff			ldx 	#$FF
.160c	4c 29 10	jmp $1029			jmp 	NextCommand
.160f					Command_CHAR:
.160f	fa		plx				plx
.1610	5a		phy				phy
.1611	ca		dex				dex  								; set the draw colour
.1612	20 41 16	jsr $1641			jsr 	GraphicsColour
.1615	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.1617	a0 02		ldy #$02			ldy 	#X16_r0
.1619	20 4e 16	jsr $164e			jsr 	GraphicsCopy2
.161c	a5 44		lda $44				lda 	NSMantissa0+3 				; copy string address to zTemp0
.161e	85 2f		sta $2f				sta 	zTemp0
.1620	a5 50		lda $50				lda 	NSMantissa1+3
.1622	85 30		sta $30				sta 	zTemp0+1
.1624	b2 2f		lda ($2f)			lda 	(zTemp0) 					; count of chars to zTemp1
.1626	85 31		sta $31				sta 	zTemp1
.1628					_CCLoop:
.1628	a5 31		lda $31				lda 	zTemp1 						; done all chars ?
.162a	f0 0f		beq $163b			beq 	_CCExit
.162c	c6 31		dec $31				dec 	zTemp1 						; dec counter
.162e	e6 2f		inc $2f				inc 	zTemp0 						; pre-bump pointer
.1630	d0 02		bne $1634			bne 	_CCNoCarry
.1632	e6 30		inc $30				inc 	zTemp0+1
.1634					_CCNoCarry:
.1634	b2 2f		lda ($2f)			lda 	(zTemp0) 					; get character
.1636	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.1639	80 ed		bra $1628			bra 	_CCLoop						; go round.
.163b					_CCExit:
.163b	7a		ply				ply
.163c	a2 ff		ldx #$ff			ldx 	#$FF
.163e	4c 29 10	jmp $1029			jmp 	NextCommand
.1641					GraphicsColour:
.1641	20 0a 18	jsr $180a			jsr 	GetInteger8Bit
.1644	aa		tax				tax
.1645	a0 00		ldy #$00			ldy 	#0
.1647	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.164a	60		rts				rts
.164b					GraphicsCopy4:
.164b	20 4e 16	jsr $164e			jsr 	GraphicsCopy2
.164e					GraphicsCopy2:
.164e	20 51 16	jsr $1651			jsr 	GraphicsCopy1
.1651					GraphicsCopy1:
.1651	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.1654	b5 41		lda $41,x			lda 	NSMantissa0,x
.1656	99 00 00	sta $0000,y			sta 	0,y
.1659	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.165b	99 01 00	sta $0001,y			sta 	1,y
.165e	e8		inx				inx
.165f	c8		iny				iny
.1660	c8		iny				iny
.1661	60		rts				rts
.1662					GraphicsRectCoords:
.1662	20 41 16	jsr $1641			jsr 	GraphicsColour 				; set colour
.1665	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.1667	a0 02		ldy #$02			ldy 	#X16_r0
.1669	20 4b 16	jsr $164b			jsr 	GraphicsCopy4
.166c	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.166e	20 7b 16	jsr $167b			jsr 	_GRCSortSubtract
.1671	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.1673	20 7b 16	jsr $167b			jsr 	_GRCSortSubtract
.1676	74 08		stz $08,x			stz 	8,x 						; zero rounding
.1678	74 09		stz $09,x			stz 	9,x
.167a	60		rts				rts
.167b					_GRCSortSubtract:
.167b	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.167d	d5 00		cmp $00,x			cmp 	0,x
.167f	b5 05		lda $05,x			lda 	5,x
.1681	f5 01		sbc $01,x			sbc 	1,x
.1683	b0 08		bcs $168d			bcs 	_GRCNoSwap 					; >= swap.
.1685	20 9b 16	jsr $169b			jsr 	_GRCSwapByte 				; swap 0/2
.1688	e8		inx				inx
.1689	20 9b 16	jsr $169b			jsr 	_GRCSwapByte 				; swap 1/3
.168c	ca		dex				dex
.168d					_GRCNoSwap:
.168d	38		sec				sec 								; calculate width/height into 4,5
.168e	b5 04		lda $04,x			lda 	4,x
.1690	f5 00		sbc $00,x			sbc 	0,x
.1692	95 04		sta $04,x			sta 	4,x
.1694	b5 05		lda $05,x			lda 	5,x
.1696	f5 01		sbc $01,x			sbc 	1,x
.1698	95 05		sta $05,x			sta 	5,x
.169a	60		rts				rts
.169b					_GRCSwapByte:
.169b	b5 04		lda $04,x			lda 	4,x
.169d	48		pha				pha
.169e	b5 00		lda $00,x			lda 	0,x
.16a0	95 04		sta $04,x			sta 	4,x
.16a2	68		pla				pla
.16a3	95 00		sta $00,x			sta 	0,x
.16a5	60		rts				rts
.16a6					Unary16Hex:
.16a6	fa		plx				plx
.16a7	20 10 18	jsr $1810			jsr 	GetInteger16Bit
.16aa	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.16ac	20 e6 1e	jsr $1ee6			jsr 	StringAllocTemp
.16af	a5 30		lda $30				lda 	zTemp0+1
.16b1	f0 03		beq $16b6			beq 	_UHNoHigh
.16b3	20 be 16	jsr $16be			jsr 	_UHWriteHex
.16b6					_UHNoHigh:
.16b6	a5 2f		lda $2f				lda 	zTemp0
.16b8	20 be 16	jsr $16be			jsr 	_UHWriteHex
.16bb	4c 29 10	jmp $1029			jmp 	NextCommand
.16be					_UHWriteHex:
.16be	48		pha				pha
.16bf	4a		lsr a				lsr 	a
.16c0	4a		lsr a				lsr 	a
.16c1	4a		lsr a				lsr 	a
.16c2	4a		lsr a				lsr 	a
.16c3	20 c7 16	jsr $16c7			jsr 	_UHWriteNibl
.16c6	68		pla				pla
.16c7					_UHWriteNibl:
.16c7	29 0f		and #$0f			and 	#15
.16c9	c9 0a		cmp #$0a			cmp 	#10
.16cb	90 02		bcc $16cf			bcc 	_UHDigit
.16cd	69 06		adc #$06			adc 	#6
.16cf					_UHDigit:
.16cf	69 30		adc #$30			adc 	#48
.16d1	20 0f 1f	jsr $1f0f			jsr 	StringWriteChar
.16d4	60		rts				rts
.16d5					IndFloatRead:
.16d5	fa		plx				plx
.16d6	b5 41		lda $41,x			lda 	NSMantissa0,x 				; copy address
.16d8	85 2f		sta $2f				sta 	zTemp0
.16da	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.16dc	18		clc				clc
.16dd	6d 07 04	adc $0407			adc 	variableStartPage
.16e0	85 30		sta $30				sta 	zTemp0+1
.16e2	ca		dex				dex 								; throw the address
.16e3	20 c5 1c	jsr $1cc5			jsr 	ReadFloatZTemp0Sub 							; call read routine
.16e6	4c 29 10	jmp $1029			jmp 	NextCommand
.16e9					IndInt16Read:
.16e9	fa		plx				plx
.16ea	b5 41		lda $41,x			lda 	NSMantissa0,x 				; copy address
.16ec	85 2f		sta $2f				sta 	zTemp0
.16ee	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.16f0	18		clc				clc
.16f1	6d 07 04	adc $0407			adc 	variableStartPage
.16f4	85 30		sta $30				sta 	zTemp0+1
.16f6	ca		dex				dex 								; throw the address
.16f7	20 01 1d	jsr $1d01			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.16fa	4c 29 10	jmp $1029			jmp 	NextCommand
.16fd					IndStringRead:
.16fd	fa		plx				plx
.16fe	b5 41		lda $41,x			lda 	NSMantissa0,x 				; copy address
.1700	85 2f		sta $2f				sta 	zTemp0
.1702	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.1704	18		clc				clc
.1705	6d 07 04	adc $0407			adc 	variableStartPage
.1708	85 30		sta $30				sta 	zTemp0+1
.170a	ca		dex				dex 								; throw the address
.170b	20 46 1d	jsr $1d46			jsr 	ReadStringZTemp0Sub 							; call read routine
.170e	4c 29 10	jmp $1029			jmp 	NextCommand
.1711					IndFloatWrite:
.1711	fa		plx				plx
.1712	b5 40		lda $40,x			lda 	NSMantissa0-1,x 			; copy address
.1714	85 2f		sta $2f				sta 	zTemp0
.1716	b5 4c		lda $4c,x			lda 	NSMantissa1-1,x
.1718	18		clc				clc
.1719	6d 07 04	adc $0407			adc 	variableStartPage
.171c	85 30		sta $30				sta 	zTemp0+1
.171e	20 a0 22	jsr $22a0			jsr 	WriteFloatZTemp0Sub 							; call write routine
.1721	ca		dex				dex 								; throw the address as well.
.1722	4c 29 10	jmp $1029			jmp 	NextCommand
.1725					IndInt16Write:
.1725	fa		plx				plx
.1726	b5 40		lda $40,x			lda 	NSMantissa0-1,x 			; copy address
.1728	85 2f		sta $2f				sta 	zTemp0
.172a	b5 4c		lda $4c,x			lda 	NSMantissa1-1,x
.172c	18		clc				clc
.172d	6d 07 04	adc $0407			adc 	variableStartPage
.1730	85 30		sta $30				sta 	zTemp0+1
.1732	20 dc 22	jsr $22dc			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.1735	ca		dex				dex 								; throw the address as well.
.1736	4c 29 10	jmp $1029			jmp 	NextCommand
.1739					IndStringWrite:
.1739	fa		plx				plx
.173a	b5 40		lda $40,x			lda 	NSMantissa0-1,x 			; copy address
.173c	85 2f		sta $2f				sta 	zTemp0
.173e	b5 4c		lda $4c,x			lda 	NSMantissa1-1,x
.1740	18		clc				clc
.1741	6d 07 04	adc $0407			adc 	variableStartPage
.1744	85 30		sta $30				sta 	zTemp0+1
.1746	20 1b 23	jsr $231b			jsr 	WriteStringZTemp0Sub 							; call write routine
.1749	ca		dex				dex 								; throw the address as well.
.174a	4c 29 10	jmp $1029			jmp 	NextCommand
.174d					CommandInput:
.174d	fa		plx				plx
.174e	5a		phy				phy 								; save Y
.174f	e8		inx				inx									; space on stack
.1750					_INError:
.1750	20 84 17	jsr $1784			jsr 	InputStringToBuffer 		; input from keyboard
.1753	a9 5f		lda #$5f			lda 	#((ReadBufferSize) & $FF)
.1755	85 2f		sta $2f				sta 	0+zTemp0
.1757	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.1759	85 30		sta $30				sta 	1+zTemp0
.175b	20 2d 21	jsr $212d			jsr 	ValEvaluateZTemp0
.175e	b0 f0		bcs $1750			bcs 	_INError 					; failed, try again.
.1760	7a		ply				ply 								; restore Y
.1761	4c 29 10	jmp $1029			jmp 	NextCommand
.1764					CommandInputString:
.1764	fa		plx				plx
.1765	5a		phy				phy 								; save Y
.1766	20 84 17	jsr $1784			jsr 	InputStringToBuffer 		; input from keyboard
.1769	e8		inx				inx 								; make space on stack
.176a	20 19 2e	jsr $2e19			jsr 	FloatSetZero 				; store as string on stack
.176d	a9 5f		lda #$5f			lda 	#ReadBufferSize & $FF
.176f	95 41		sta $41,x			sta 	NSMantissa0,x
.1771	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.1773	95 4d		sta $4d,x			sta 	NSMantissa1,x
.1775	a9 40		lda #$40			lda 	#NSSString
.1777	95 35		sta $35,x			sta 	NSStatus,x
.1779	7a		ply				ply 								; restore Y
.177a	4c 29 10	jmp $1029			jmp 	NextCommand
.177d					CommandInputReset:
.177d	fa		plx				plx
.177e	9c 0a 04	stz $040a			stz 	InputBuffer
.1781	4c 29 10	jmp $1029			jmp 	NextCommand
.1784					InputStringToBuffer:
.1784	a9 be		lda #$be			lda 	#((InputBumpNext) & $FF)
.1786	8d 5f 05	sta $055f			sta 	0+ReadBumpNextVec
.1789	a9 17		lda #$17			lda 	#((InputBumpNext) >> 8) & $FF
.178b	8d 60 05	sta $0560			sta 	1+ReadBumpNextVec
.178e	a9 9b		lda #$9b			lda 	#((InputLookNext) & $FF)
.1790	8d 61 05	sta $0561			sta 	0+ReadLookNextVec
.1793	a9 17		lda #$17			lda 	#((InputLookNext) >> 8) & $FF
.1795	8d 62 05	sta $0562			sta 	1+ReadLookNextVec
.1798	4c 22 1c	jmp $1c22			jmp 	GetStringToBuffer
.179b					InputLookNext:
.179b	da		phx				phx
.179c					_ILNRetry:
.179c	ad 0a 04	lda $040a			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.179f	d0 08		bne $17a9			bne 	_ILNNotEmpty
.17a1	20 c2 17	jsr $17c2			jsr 	InputGetNewLine 			; get a new line
.17a4	9c 5b 04	stz $045b			stz 	InputBufferPos 				; reset read position.
.17a7	80 f3		bra $179c			bra 	_ILNRetry
.17a9					_ILNNotEmpty:
.17a9	ae 5b 04	ldx $045b			ldx 	InputBufferPos 				; get head available character
.17ac	bd 0a 04	lda $040a,x			lda 	InputBuffer,x
.17af	d0 08		bne $17b9			bne 	_ILNExit 					; if not EOS return it with CC.
.17b1					_ILNNextLine:
.17b1	9c 0a 04	stz $040a			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.17b4	38		sec				sec 								; return CS,Zero
.17b5	fa		plx				plx
.17b6	a9 0d		lda #$0d			lda 	#13
.17b8	60		rts				rts
.17b9					_ILNExit:
.17b9	fa		plx				plx
.17ba	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.17bc	18		clc				clc
.17bd	60		rts				rts
.17be					InputBumpNext:
.17be	ee 5b 04	inc $045b			inc 	InputBufferPos
.17c1	60		rts				rts
.17c2					InputGetNewLine:
.17c2	48		pha				pha
.17c3	da		phx				phx
.17c4	5a		phy				phy
.17c5	a9 3f		lda #$3f			lda 	#"?"
.17c7	20 01 18	jsr $1801			jsr 	IGNLEchoIfScreen
.17ca	a0 00		ldy #$00			ldy 	#0 							; line position.
.17cc					_IGNLLoop:
.17cc	20 4c 1b	jsr $1b4c			jsr 	VectorGetCharacter 			; get a character
.17cf	c9 00		cmp #$00			cmp 	#0
.17d1	f0 f9		beq $17cc			beq 	_IGNLLoop
.17d3	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.17d5	f0 11		beq $17e8			beq 	_IGNBackspace
.17d7	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.17d9	f0 17		beq $17f2			beq 	_IGNExit
.17db	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.17dd	f0 ed		beq $17cc			beq 	_IGNLLoop
.17df	99 0a 04	sta $040a,y			sta 	InputBuffer,y
.17e2	c8		iny				iny
.17e3	20 01 18	jsr $1801			jsr 	IGNLEchoIfScreen
.17e6	80 e4		bra $17cc			bra 	_IGNLLoop
.17e8					_IGNBackspace:
.17e8	c0 00		cpy #$00			cpy 	#0
.17ea	f0 e0		beq $17cc			beq 	_IGNLLoop
.17ec	20 01 18	jsr $1801			jsr 	IGNLEchoIfScreen
.17ef	88		dey				dey
.17f0	80 da		bra $17cc			bra 	_IGNLLoop
.17f2					_IGNExit:
.17f2	20 01 18	jsr $1801			jsr 	IGNLEchoIfScreen
.17f5	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.17f7	99 0a 04	sta $040a,y			sta 	InputBuffer,y
.17fa	9c 5b 04	stz $045b			stz 	InputBufferPos 				; reset position to start of input buffer.
.17fd	7a		ply				ply
.17fe	fa		plx				plx
.17ff	68		pla				pla
.1800	60		rts				rts
.1801					IGNLEchoIfScreen:
.1801	ae 5d 04	ldx $045d			ldx 	currentChannel
.1804	d0 03		bne $1809			bne 	_IGNLEExit
.1806	20 43 1b	jsr $1b43			jsr 	VectorPrintCharacter
.1809					_IGNLEExit:
.1809	60		rts				rts
.040a					InputBuffer:
>040a							.fill 	81
.045b					InputBufferPos:
>045b							.fill 	1
.180a					GetInteger8Bit:
.180a	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.180d	b5 41		lda $41,x			lda 	NSMantissa0,x
.180f	60		rts				rts
.1810					GetInteger16Bit:
.1810	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.1813	34 35		bit $35,x			bit 	NSStatus,x
.1815	30 09		bmi $1820			bmi 	Negate16Bit
.1817	b5 41		lda $41,x			lda 	NSMantissa0,x
.1819	85 2f		sta $2f				sta 	zTemp0
.181b	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.181d	85 30		sta $30				sta 	zTemp0+1
.181f	60		rts				rts
.1820					Negate16Bit:
.1820	38		sec				sec
.1821	a9 00		lda #$00			lda 	#0
.1823	f5 41		sbc $41,x			sbc 	NSMantissa0,x
.1825	95 41		sta $41,x			sta 	NSMantissa0,x
.1827	85 2f		sta $2f				sta 	zTemp0
.1829	a9 00		lda #$00			lda 	#0
.182b	f5 4d		sbc $4d,x			sbc 	NSMantissa1,x
.182d	95 4d		sta $4d,x			sta 	NSMantissa1,x
.182f	85 30		sta $30				sta 	zTemp0+1
.1831	60		rts				rts
.1832					UnaryJoy:
.1832	fa		plx				plx
.1833	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; port #
.1836	48		pha				pha 								; zero the result.
.1837	20 19 2e	jsr $2e19			jsr 	FloatSetZero
.183a	68		pla				pla
.183b	5a		phy				phy
.183c	da		phx				phx
.183d	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1840	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1842	d0 10		bne $1854			bne 	_UJNoHardware
.1844	a8		tay				tay 								; move XA -> AY
.1845	8a		txa				txa
.1846	fa		plx				plx 								; we can update it now.
.1847	49 ff		eor #$ff			eor 	#$FF
.1849	95 4d		sta $4d,x			sta 	NSMantissa1,x
.184b	98		tya				tya
.184c	49 ff		eor #$ff			eor 	#$FF
.184e	95 41		sta $41,x			sta 	NSMantissa0,x
.1850	7a		ply				ply 								; restore Y
.1851	4c 29 10	jmp $1029			jmp 	NextCommand
.1854					_UJNoHardware:
.1854	fa		plx				plx
.1855	7a		ply				ply
.1856	a9 01		lda #$01			lda 	#1 							; set result to -1
.1858	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.185b	20 db 2d	jsr $2ddb			jsr 	FloatNegate
.185e	4c 29 10	jmp $1029			jmp 	NextCommand
.1861					UnaryLen:
.1861	fa		plx				plx
.1862	b5 41		lda $41,x			lda 	NSMantissa0,x 				; string address.
.1864	85 2f		sta $2f				sta 	zTemp0
.1866	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.1868	85 30		sta $30				sta 	zTemp0+1
.186a	b2 2f		lda ($2f)			lda 	(zTemp0) 					; get length
.186c	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.186f	4c 29 10	jmp $1029			jmp 	NextCommand
.1872					LinkFloatAdd:
.1872	fa		plx				plx
.1873	5a		phy			phy
.1874	20 3d 28	jsr $283d		jsr	FloatAdd
.1877	7a		ply			ply
.1878	4c 29 10	jmp $1029			jmp 	NextCommand
.187b					LinkFloatSubtract:
.187b	fa		plx				plx
.187c	5a		phy			phy
.187d	20 37 28	jsr $2837		jsr	FloatSubtract
.1880	7a		ply			ply
.1881	4c 29 10	jmp $1029			jmp 	NextCommand
.1884					LinkFloatMultiply:
.1884	fa		plx				plx
.1885	5a		phy			phy
.1886	20 d9 2a	jsr $2ad9		jsr	FloatMultiply
.1889	7a		ply			ply
.188a	4c 29 10	jmp $1029			jmp 	NextCommand
.188d					LinkFloatDivide:
.188d	fa		plx				plx
.188e	5a		phy			phy
.188f	20 62 29	jsr $2962		jsr	FloatDivide
.1892	b0 5c		bcs $18f0		bcs	DivZeroError
.1894	7a		ply			ply
.1895	4c 29 10	jmp $1029			jmp 	NextCommand
.1898					LinkFloatPower:
.1898	fa		plx				plx
.1899	5a		phy			phy
.189a	20 e2 30	jsr $30e2		jsr	FloatPower
.189d	b0 4e		bcs $18ed		bcs	MapRangeError
.189f	7a		ply			ply
.18a0	4c 29 10	jmp $1029			jmp 	NextCommand
.18a3					LinkCompareGreater:
.18a3	fa		plx				plx
.18a4	5a		phy			phy
.18a5	20 e6 28	jsr $28e6		jsr	CompareGreater
.18a8	7a		ply			ply
.18a9	4c 29 10	jmp $1029			jmp 	NextCommand
.18ac					LinkCompareEqual:
.18ac	fa		plx				plx
.18ad	5a		phy			phy
.18ae	20 c8 28	jsr $28c8		jsr	CompareEqual
.18b1	7a		ply			ply
.18b2	4c 29 10	jmp $1029			jmp 	NextCommand
.18b5					LinkCompareLess:
.18b5	fa		plx				plx
.18b6	5a		phy			phy
.18b7	20 de 28	jsr $28de		jsr	CompareLess
.18ba	7a		ply			ply
.18bb	4c 29 10	jmp $1029			jmp 	NextCommand
.18be					LinkCompareGreaterEqual:
.18be	fa		plx				plx
.18bf	5a		phy			phy
.18c0	20 f6 28	jsr $28f6		jsr	CompareGreaterEqual
.18c3	7a		ply			ply
.18c4	4c 29 10	jmp $1029			jmp 	NextCommand
.18c7					LinkCompareNotEqual:
.18c7	fa		plx				plx
.18c8	5a		phy			phy
.18c9	20 d8 28	jsr $28d8		jsr	CompareNotEqual
.18cc	7a		ply			ply
.18cd	4c 29 10	jmp $1029			jmp 	NextCommand
.18d0					LinkCompareLessEqual:
.18d0	fa		plx				plx
.18d1	5a		phy			phy
.18d2	20 ee 28	jsr $28ee		jsr	CompareLessEqual
.18d5	7a		ply			ply
.18d6	4c 29 10	jmp $1029			jmp 	NextCommand
.18d9					LinkFloatIntegerPartDown:
.18d9	fa		plx				plx
.18da	5a		phy			phy
.18db	20 78 2a	jsr $2a78		jsr	FloatIntegerPartDown
.18de	7a		ply			ply
.18df	4c 29 10	jmp $1029			jmp 	NextCommand
.18e2					LinkFloatSquareRoot:
.18e2	fa		plx				plx
.18e3	5a		phy			phy
.18e4	20 64 31	jsr $3164		jsr	FloatSquareRoot
.18e7	b0 04		bcs $18ed		bcs	MapRangeError
.18e9	7a		ply			ply
.18ea	4c 29 10	jmp $1029			jmp 	NextCommand
.18ed					MapRangeError:
.18ed	4c b6 26	jmp $26b6		jmp	ErrorV_range
.18f0					DivZeroError:
.18f0	4c 3f 27	jmp $273f		jmp	ErrorV_divzero
.18f3					LinkFloatLogarithm:
.18f3	fa		plx				plx
.18f4	5a		phy			phy
.18f5	20 6e 30	jsr $306e		jsr	FloatLogarithm
.18f8	b0 f3		bcs $18ed		bcs	MapRangeError
.18fa	7a		ply			ply
.18fb	4c 29 10	jmp $1029			jmp 	NextCommand
.18fe					LinkFloatExponent:
.18fe	fa		plx				plx
.18ff	5a		phy			phy
.1900	20 6b 2f	jsr $2f6b		jsr	FloatExponent
.1903	7a		ply			ply
.1904	4c 29 10	jmp $1029			jmp 	NextCommand
.1907					LinkFloatCosine:
.1907	fa		plx				plx
.1908	5a		phy			phy
.1909	20 5f 2f	jsr $2f5f		jsr	FloatCosine
.190c	7a		ply			ply
.190d	4c 29 10	jmp $1029			jmp 	NextCommand
.1910					LinkFloatSine:
.1910	fa		plx				plx
.1911	5a		phy			phy
.1912	20 ff 30	jsr $30ff		jsr	FloatSine
.1915	7a		ply			ply
.1916	4c 29 10	jmp $1029			jmp 	NextCommand
.1919					LinkFloatTangent:
.1919	fa		plx				plx
.191a	5a		phy			phy
.191b	20 70 31	jsr $3170		jsr	FloatTangent
.191e	7a		ply			ply
.191f	4c 29 10	jmp $1029			jmp 	NextCommand
.1922					LinkFloatArcTan:
.1922	fa		plx				plx
.1923	5a		phy			phy
.1924	20 44 2e	jsr $2e44		jsr	FloatArcTan
.1927	b0 c4		bcs $18ed		bcs	MapRangeError
.1929	7a		ply			ply
.192a	4c 29 10	jmp $1029			jmp 	NextCommand
.192d					LinkFloatCompare:
.192d	fa		plx				plx
.192e	5a		phy			phy
.192f	20 fe 28	jsr $28fe		jsr	FloatCompare
.1932	7a		ply			ply
.1933	4c 29 10	jmp $1029			jmp 	NextCommand
.1936					LinkDivideInt32:
.1936	fa		plx				plx
.1937	5a		phy			phy
.1938	20 8c 29	jsr $298c		jsr	DivideInt32
.193b	b0 b0		bcs $18ed		bcs	MapRangeError
.193d	7a		ply			ply
.193e	4c 29 10	jmp $1029			jmp 	NextCommand
.1941					StackSaveCurrentPosition:
.1941	20 94 10	jsr $1094			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.1944	5a		phy				phy
.1945	a0 01		ldy #$01			ldy 	#1
.1947	a5 2a		lda $2a				lda 	codePage
.1949	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.194b	c8		iny				iny
.194c	a5 28		lda $28				lda 	codePtr
.194e	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1950	c8		iny				iny
.1951	a5 29		lda $29				lda 	codePtr+1
.1953	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1955	7a		ply				ply
.1956	60		rts				rts
.1957					StackLoadCurrentPosition:
.1957	a0 01		ldy #$01			ldy 	#1
.1959	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.195b	85 2a		sta $2a				sta 	codePage
.195d	c8		iny				iny
.195e	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1960	85 28		sta $28				sta 	codePtr
.1962	c8		iny				iny
.1963	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1965	85 29		sta $29				sta 	codePtr+1
.1967	a0 00		ldy #$00			ldy 	#0
.1969	60		rts				rts
.196a					XCommandMouse:
.196a	fa		plx				plx
.196b	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; mouse control.
.196e	ca		dex				dex
.196f	da		phx				phx
.1970	5a		phy				phy
.1971	48		pha				pha
.1972	38		sec				sec 								; get screen resolution
.1973	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1976	68		pla				pla
.1977	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.197a	7a		ply				ply
.197b	fa		plx				plx
.197c	4c 29 10	jmp $1029			jmp 	NextCommand
.197f					XUnaryMB:
.197f	fa		plx				plx
.1980	20 ae 19	jsr $19ae			jsr 	XUnaryMouseCommon
.1983	a5 33		lda $33				lda 	zTemp2
.1985	e8		inx				inx
.1986	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.1989	4c 29 10	jmp $1029			jmp 	NextCommand
.198c					XUnaryMX:
.198c	fa		plx				plx
.198d	20 ae 19	jsr $19ae			jsr 	XUnaryMouseCommon
.1990	a5 2f		lda $2f				lda 	zTemp0
.1992	e8		inx				inx
.1993	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.1996	a5 30		lda $30				lda 	zTemp0+1
.1998	95 4d		sta $4d,x			sta 	NSMantissa1,x
.199a	4c 29 10	jmp $1029			jmp 	NextCommand
.199d					XUnaryMY:
.199d	fa		plx				plx
.199e	20 ae 19	jsr $19ae			jsr 	XUnaryMouseCommon
.19a1	a5 31		lda $31				lda 	zTemp1
.19a3	e8		inx				inx
.19a4	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.19a7	a5 32		lda $32				lda 	zTemp1+1
.19a9	95 4d		sta $4d,x			sta 	NSMantissa1,x
.19ab	4c 29 10	jmp $1029			jmp 	NextCommand
.19ae					XUnaryMouseCommon:
.19ae	da		phx				phx
.19af	5a		phy				phy
.19b0	a2 2f		ldx #$2f			ldx 	#zTemp0
.19b2	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.19b5	85 33		sta $33				sta 	zTemp2
.19b7	7a		ply				ply
.19b8	fa		plx				plx
.19b9	60		rts				rts
.19ba					NegateTOS:
.19ba	fa		plx				plx
.19bb	20 db 2d	jsr $2ddb			jsr 	FloatNegate
.19be	4c 29 10	jmp $1029			jmp 	NextCommand
.19c1					CommandNewLine:
.19c1	fa		plx				plx
.19c2	9c 68 05	stz $0568			stz 	stringInitialised
.19c5	a2 ff		ldx #$ff			ldx 	#$FF
.19c7	4c 29 10	jmp $1029			jmp 	NextCommand
.19ca					CommandNext:
.19ca	fa		plx				plx
.19cb					_CNRetry:
.19cb	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.19cd	20 21 15	jsr $1521			jsr 	StackFindFrame
.19d0	20 94 10	jsr $1094			jsr 	FixUpY 						; so we can use Y
.19d3	b5 41		lda $41,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.19d5	35 4d		and $4d,x			and 	NSMantissa1,x
.19d7	c9 ff		cmp #$ff			cmp 	#$FF
.19d9	f0 16		beq $19f1			beq 	_CNNoIndexVariable
.19db	b5 41		lda $41,x			lda 	NSMantissa0,x
.19dd	a0 05		ldy #$05			ldy 	#5
.19df	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.19e1	d0 07		bne $19ea			bne 	_CNNIndexFail
.19e3	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.19e5	c8		iny				iny
.19e6	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.19e8	f0 07		beq $19f1			beq 	_CNNoIndexVariable
.19ea					_CNNIndexFail:
.19ea	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.19ec	20 13 15	jsr $1513			jsr 	StackCloseFrame 			; close this frame
.19ef	80 da		bra $19cb			bra 	_CNRetry
.19f1					_CNNoIndexVariable:
.19f1	ca		dex				dex
.19f2	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.19f4	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.19f6	29 40		and #$40			and 	#$40	 					; bit 6
.19f8	d0 55		bne $1a4f			bne 	_CNOptimisedNext
.19fa	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.19fc	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.19fe	48		pha				pha
.19ff	85 2f		sta $2f				sta 	zTemp0
.1a01	c8		iny				iny
.1a02	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a04	18		clc				clc
.1a05	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1a08	48		pha				pha
.1a09	85 30		sta $30				sta 	zTemp0+1
.1a0b	20 c5 1c	jsr $1cc5			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.1a0e	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.1a10	e8		inx				inx
.1a11	20 92 1a	jsr $1a92			jsr 	CopyOffsetYToTOS
.1a14	20 3d 28	jsr $283d			jsr 	FloatAdd
.1a17	68		pla				pla 								; restore address
.1a18	85 30		sta $30				sta 	zTemp0+1
.1a1a	68		pla				pla
.1a1b	85 2f		sta $2f				sta 	zTemp0
.1a1d	20 a0 22	jsr $22a0			jsr 	WriteFloatZTemp0Sub			; write float.
.1a20	e8		inx				inx  								; recover written
.1a21	e8		inx				inx 								; load offset
.1a22	a0 0d		ldy #$0d			ldy 	#13
.1a24	20 92 1a	jsr $1a92			jsr 	CopyOffsetYToTOS
.1a27	20 fe 28	jsr $28fe			jsr 	FloatCompare 				; and compare the floats.
.1a2a	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1a2b	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.1a2d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a2f	30 08		bmi $1a39			bmi 	_CNDownStep
.1a31	b5 42		lda $42,x			lda 	NSMantissa0+1,x 			; get comparator
.1a33	c9 01		cmp #$01			cmp 	#1 							; gone higher
.1a35	f0 10		beq $1a47			beq 	_CNExitFor 					; if so exit the loop
.1a37	80 06		bra $1a3f			bra 	_CNLoopBack
.1a39					_CNDownStep:
.1a39	b5 42		lda $42,x			lda 	NSMantissa0+1,x 			; get comparator
.1a3b	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.1a3d	f0 08		beq $1a47			beq 	_CNExitFor
.1a3f					_CNLoopBack:
.1a3f	20 57 19	jsr $1957			jsr 	StackLoadCurrentPosition 	; loop back
.1a42	a0 00		ldy #$00			ldy 	#0
.1a44	4c 29 10	jmp $1029			jmp 	NextCommand
.1a47					_CNExitFor:
.1a47	20 13 15	jsr $1513			jsr 	StackCloseFrame 			; remove the frame and exit
.1a4a	a0 00		ldy #$00			ldy 	#0
.1a4c	4c 29 10	jmp $1029			jmp 	NextCommand
.1a4f					_CNOptimisedNext:
.1a4f	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1a51	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a53	85 2f		sta $2f				sta 	zTemp0
.1a55	c8		iny				iny
.1a56	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a58	18		clc				clc
.1a59	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1a5c	85 30		sta $30				sta 	zTemp0+1
.1a5e	a0 07		ldy #$07			ldy 	#7 							; STEP value
.1a60	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a62	a0 ff		ldy #$ff			ldy 	#$FF
.1a64	18		clc				clc
.1a65					_CNOIncrement:
.1a65	c8		iny				iny
.1a66	71 2f		adc ($2f),y			adc 	(zTemp0),y
.1a68	91 2f		sta ($2f),y			sta 	(zTemp0),y
.1a6a	f0 f9		beq $1a65			beq 	_CNOIncrement
.1a6c	18		clc				clc
.1a6d	a5 24		lda $24				lda 	runtimeStackPtr
.1a6f	69 0d		adc #$0d			adc 	#13
.1a71	85 31		sta $31				sta 	zTemp1
.1a73	a5 25		lda $25				lda 	runtimeStackPtr+1
.1a75	69 00		adc #$00			adc 	#0
.1a77	85 32		sta $32				sta 	zTemp1+1
.1a79	a0 00		ldy #$00			ldy 	#0
.1a7b	b1 31		lda ($31),y			lda 	(zTemp1),y 					; byte 0
.1a7d	d1 2f		cmp ($2f),y			cmp 	(zTemp0),y
.1a7f	c8		iny				iny
.1a80	b1 31		lda ($31),y			lda 	(zTemp1),y 					; byte 1
.1a82	f1 2f		sbc ($2f),y			sbc 	(zTemp0),y
.1a84	c8		iny				iny
.1a85	b1 31		lda ($31),y			lda 	(zTemp1),y 					; byte 2
.1a87	f1 2f		sbc ($2f),y			sbc 	(zTemp0),y
.1a89	c8		iny				iny
.1a8a	b1 31		lda ($31),y			lda 	(zTemp1),y 					; byte 3
.1a8c	f1 2f		sbc ($2f),y			sbc 	(zTemp0),y
.1a8e	90 b7		bcc $1a47			bcc	 	_CNExitFor
.1a90	80 ad		bra $1a3f			bra 	_CNLoopBack
.1a92					CopyOffsetYToTOS:
.1a92	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a94	95 41		sta $41,x			sta 	NSMantissa0,x
.1a96	c8		iny				iny
.1a97	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a99	95 4d		sta $4d,x			sta 	NSMantissa1,x
.1a9b	c8		iny				iny
.1a9c	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a9e	95 59		sta $59,x			sta 	NSMantissa2,x
.1aa0	c8		iny				iny
.1aa1	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1aa3	95 65		sta $65,x			sta 	NSMantissa3,x
.1aa5	c8		iny				iny
.1aa6	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1aa8	95 71		sta $71,x			sta 	NSExponent,x
.1aaa	c8		iny				iny
.1aab	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1aad	95 35		sta $35,x			sta 	NSStatus,x
.1aaf	60		rts				rts
.1ab0	4c 29 10	jmp $1029			jmp 	NextCommand
.1ab3					NotTOS:
.1ab3	fa		plx				plx
.1ab4	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.1ab7	74 59		stz $59,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.1ab9	74 65		stz $65,x			stz 	NSMantissa3,x
.1abb	20 db 2d	jsr $2ddb			jsr 	FloatNegate		 			; negate
.1abe	e8		inx				inx 								; and subtract 1.
.1abf	a9 01		lda #$01			lda 	#1
.1ac1	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.1ac4	20 37 28	jsr $2837			jsr 	FloatSubtract
.1ac7					_NotTOSSkip:
.1ac7	4c 29 10	jmp $1029			jmp 	NextCommand
.1aca					CommandOn:
.1aca	fa		plx				plx
.1acb	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.1ace	8d 5c 04	sta $045c			sta 	onCount 					; save it.
.1ad1	20 94 10	jsr $1094			jsr 	FixUpY 						; Y = 0
.1ad4					_CONFind:
.1ad4	ce 5c 04	dec $045c			dec 	onCount 					; reached zero, do this one
.1ad7	f0 0c		beq $1ae5			beq 	_CONFound
.1ad9	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1ada	c8		iny				iny
.1adb	c8		iny				iny
.1adc	c8		iny				iny
.1add	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.1adf	c8		iny				iny
.1ae0	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.1ae2	f0 f0		beq $1ad4			beq 	_CONFind
.1ae4	88		dey				dey 								; point to character after last GOTO/GOSUB
.1ae5					_CONFound:
.1ae5	4c 29 10	jmp $1029			jmp 	NextCommand
.1ae8					CommandMoreOn:
.1ae8	fa		plx				plx
.1ae9	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1aea	c8		iny				iny
.1aeb	c8		iny				iny
.1aec	c8		iny				iny
.1aed	4c 29 10	jmp $1029			jmp 	NextCommand
.045c					onCount:
>045c							.fill 	1
.1af0					UnaryPeek:
.1af0	fa		plx				plx
.1af1	20 10 18	jsr $1810			jsr 	GetInteger16Bit
.1af4	da		phx				phx
.1af5	5a		phy				phy
.1af6	a6 2f		ldx $2f				ldx 	zTemp0
.1af8	a4 30		ldy $30				ldy 	zTemp0+1
.1afa	20 31 24	jsr $2431			jsr 	XPeekMemory
.1afd	7a		ply				ply
.1afe	fa		plx				plx
.1aff	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.1b02	4c 29 10	jmp $1029			jmp 	NextCommand
.1b05					CommandPOKE:
.1b05	fa		plx				plx
.1b06	da		phx				phx 								; save XY
.1b07	5a		phy				phy
.1b08	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1b0b	48		pha				pha
.1b0c	b5 4c		lda $4c,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1b0e	a8		tay				tay
.1b0f	b5 40		lda $40,x			lda 	NSMantissa0-1,x
.1b11	aa		tax				tax
.1b12	68		pla				pla
.1b13	20 1d 24	jsr $241d			jsr 	XPokeMemory
.1b16	7a		ply				ply 								; restore YX and drop 2
.1b17	fa		plx				plx
.1b18	ca		dex				dex
.1b19	ca		dex				dex
.1b1a	4c 29 10	jmp $1029			jmp 	NextCommand
.1b1d					UnaryPos:
.1b1d	fa		plx				plx
.1b1e	20 b0 23	jsr $23b0			jsr 	XGetHPos
.1b21	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.1b24	4c 29 10	jmp $1029			jmp 	NextCommand
.1b27					GetChannel:
.1b27	fa		plx				plx
.1b28	ad 5d 04	lda $045d			lda 	currentChannel
.1b2b	e8		inx				inx
.1b2c	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.1b2f	4c 29 10	jmp $1029			jmp 	NextCommand
.1b32					SetChannel:
.1b32	fa		plx				plx
.1b33	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.1b36	b5 41		lda $41,x			lda 	NSMantissa0,x
.1b38	8d 5d 04	sta $045d			sta 	currentChannel
.1b3b	ca		dex				dex
.1b3c	4c 29 10	jmp $1029			jmp 	NextCommand
.1b3f					SetDefaultChannel:
.1b3f	9c 5d 04	stz $045d			stz 	currentChannel
.1b42	60		rts				rts
.1b43					VectorPrintCharacter:
.1b43	da		phx				phx
.1b44	ae 5d 04	ldx $045d			ldx 	currentChannel
.1b47	20 5b 24	jsr $245b			jsr 	XPrintCharacterToChannel
.1b4a	fa		plx				plx
.1b4b	60		rts				rts
.1b4c					VectorGetCharacter:
.1b4c	da		phx				phx
.1b4d	ae 5d 04	ldx $045d			ldx 	currentChannel
.1b50	20 94 23	jsr $2394			jsr 	XGetCharacterFromChannel
.1b53	fa		plx				plx
.1b54	60		rts				rts
.045d					currentChannel:
>045d							.fill 	1
.1b55					PrintNumber:
.1b55	fa		plx				plx
.1b56	a9 07		lda #$07			lda 	#7
.1b58	20 01 2d	jsr $2d01			jsr 	FloatToString 				; to number in decimal buffer
.1b5b	ca		dex				dex 								; drop
.1b5c	da		phx				phx
.1b5d	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1b5f					_PNLoop:
.1b5f	bd 94 05	lda $0594,x			lda 	decimalBuffer,x
.1b62	20 43 1b	jsr $1b43			jsr 	VectorPrintCharacter
.1b65	e8		inx				inx
.1b66	bd 94 05	lda $0594,x			lda	 	decimalBuffer,x
.1b69	d0 f4		bne $1b5f			bne 	_PNLoop
.1b6b	a9 20		lda #$20			lda 	#32 						; trailing space
.1b6d	20 43 1b	jsr $1b43			jsr 	VectorPrintCharacter
.1b70	fa		plx				plx
.1b71	4c 29 10	jmp $1029			jmp 	NextCommand
.1b74					PrintString:
.1b74	fa		plx				plx
.1b75	b5 41		lda $41,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.1b77	85 2f		sta $2f				sta 	zTemp0
.1b79	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.1b7b	85 30		sta $30				sta 	zTemp0+1
.1b7d	ca		dex				dex 								; drop
.1b7e	da		phx				phx
.1b7f	5a		phy				phy
.1b80	b2 2f		lda ($2f)			lda 	(zTemp0) 					; X = count
.1b82	aa		tax				tax
.1b83	a0 01		ldy #$01			ldy 	#1 							; Y = position
.1b85					_PSLoop:
.1b85	e0 00		cpx #$00			cpx 	#0 							; complete ?
.1b87	f0 09		beq $1b92			beq 	_PSExit
.1b89	ca		dex				dex 								; dec count
.1b8a	b1 2f		lda ($2f),y			lda 	(zTemp0),y 					; print char and bump
.1b8c	20 43 1b	jsr $1b43			jsr 	VectorPrintCharacter
.1b8f	c8		iny				iny
.1b90	80 f3		bra $1b85			bra 	_PSLoop
.1b92					_PSExit:
.1b92	7a		ply				ply
.1b93	fa		plx				plx
.1b94	4c 29 10	jmp $1029			jmp 	NextCommand
.1b97					CommandPushN:
.1b97	fa		plx				plx
.1b98	e8		inx				inx 								; next slot on stack
.1b99	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.1b9b	95 71		sta $71,x			sta 	NSExponent,x
.1b9d	c8		iny				iny
.1b9e	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.1ba0	95 41		sta $41,x			sta 	NSMantissa0,x
.1ba2	c8		iny				iny
.1ba3	b1 28		lda ($28),y			lda 	(codePtr),y
.1ba5	95 4d		sta $4d,x			sta 	NSMantissa1,x
.1ba7	c8		iny				iny
.1ba8	b1 28		lda ($28),y			lda 	(codePtr),y
.1baa	95 59		sta $59,x			sta 	NSMantissa2,x
.1bac	c8		iny				iny
.1bad	b1 28		lda ($28),y			lda 	(codePtr),y
.1baf	48		pha				pha
.1bb0	29 7f		and #$7f			and 	#$7F
.1bb2	95 65		sta $65,x			sta 	NSMantissa3,x
.1bb4	68		pla				pla 								; sign in mantissa3:7
.1bb5	29 80		and #$80			and 	#$80
.1bb7	95 35		sta $35,x			sta 	NSStatus,x
.1bb9	c8		iny				iny
.1bba	4c 29 10	jmp $1029			jmp 	NextCommand
.1bbd					CommandPushS:
.1bbd	fa		plx				plx
.1bbe	e8		inx				inx 								; next slot on stack
.1bbf	18		clc				clc
.1bc0	98		tya				tya
.1bc1	65 28		adc $28				adc 	codePtr 					; the string is inline
.1bc3	95 41		sta $41,x			sta 	NSMantissa0,x
.1bc5	a5 29		lda $29				lda 	codePtr+1
.1bc7	69 00		adc #$00			adc 	#0
.1bc9	95 4d		sta $4d,x			sta 	NSMantissa1,x
.1bcb	74 59		stz $59,x			stz 	NSMantissa2,x
.1bcd	74 65		stz $65,x			stz 	NSMantissa3,x
.1bcf	a9 40		lda #$40			lda 	#NSSString
.1bd1	95 35		sta $35,x			sta 	NSStatus,x
.1bd3	98		tya				tya 								; string length +1 added to Y
.1bd4	38		sec				sec
.1bd5	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.1bd7	a8		tay				tay
.1bd8	4c 29 10	jmp $1029			jmp 	NextCommand
.1bdb					CommandRead:
.1bdb	fa		plx				plx
.1bdc	5a		phy				phy 								; save Y
.1bdd	20 0e 1c	jsr $1c0e			jsr 	ReadStringToBuffer 			; read element into buffer
.1be0	e8		inx				inx									; space on stack
.1be1	a9 5f		lda #$5f			lda 	#((ReadBufferSize) & $FF)
.1be3	85 2f		sta $2f				sta 	0+zTemp0
.1be5	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.1be7	85 30		sta $30				sta 	1+zTemp0
.1be9	20 2d 21	jsr $212d			jsr 	ValEvaluateZTemp0
.1bec	b0 04		bcs $1bf2			bcs 	_CRError 					; failed
.1bee	7a		ply				ply 								; restore Y
.1bef	4c 29 10	jmp $1029			jmp 	NextCommand
.1bf2					_CRError:
.1bf2	4c c6 26	jmp $26c6		jmp	ErrorV_value
.1bf5					CommandReadString:
.1bf5	fa		plx				plx
.1bf6	5a		phy				phy 								; save Y
.1bf7	20 0e 1c	jsr $1c0e			jsr 	ReadStringToBuffer 			; read text
.1bfa	e8		inx				inx 								; make space on stack
.1bfb	20 19 2e	jsr $2e19			jsr 	FloatSetZero 				; store as string on stack
.1bfe	a9 5f		lda #$5f			lda 	#ReadBufferSize & $FF
.1c00	95 41		sta $41,x			sta 	NSMantissa0,x
.1c02	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.1c04	95 4d		sta $4d,x			sta 	NSMantissa1,x
.1c06	a9 40		lda #$40			lda 	#NSSString
.1c08	95 35		sta $35,x			sta 	NSStatus,x
.1c0a	7a		ply				ply 								; restore Y
.1c0b	4c 29 10	jmp $1029			jmp 	NextCommand
.1c0e					ReadStringToBuffer:
.1c0e	a9 a1		lda #$a1			lda 	#((ReadBumpNext) & $FF)
.1c10	8d 5f 05	sta $055f			sta 	0+ReadBumpNextVec
.1c13	a9 1c		lda #$1c			lda 	#((ReadBumpNext) >> 8) & $FF
.1c15	8d 60 05	sta $0560			sta 	1+ReadBumpNextVec
.1c18	a9 74		lda #$74			lda 	#((ReadLookNext) & $FF)
.1c1a	8d 61 05	sta $0561			sta 	0+ReadLookNextVec
.1c1d	a9 1c		lda #$1c			lda 	#((ReadLookNext) >> 8) & $FF
.1c1f	8d 62 05	sta $0562			sta 	1+ReadLookNextVec
.1c22					GetStringToBuffer:
.1c22	20 71 1c	jsr $1c71			jsr		GetLookNext 				; skip all leading spaces.
.1c25	f0 44		beq $1c6b			beq 	_RBError 					; end of data
.1c27	b0 f9		bcs $1c22			bcs 	GetStringToBuffer 			; switched to new data line.
.1c29	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1c2b	b0 05		bcs $1c32			bcs 	_RBNoSpace
.1c2d	20 6e 1c	jsr $1c6e			jsr 	GetBumpNext 				; consume space and loop round.
.1c30	80 f0		bra $1c22			bra 	GetStringToBuffer
.1c32					_RBNoSpace:
.1c32	9c 5f 04	stz $045f			stz 	ReadBufferSize 				; empty the buffer.
.1c35	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.1c37	d0 08		bne $1c41			bne 	_RBCommaSep
.1c39	8d 5e 04	sta $045e			sta 	ReadSep 					; use as a seperator
.1c3c	20 6e 1c	jsr $1c6e			jsr 	GetBumpNext 				; consume the '"'
.1c3f	80 05		bra $1c46			bra 	_RBGetText
.1c41					_RBCommaSep:
.1c41	a9 2c		lda #$2c			lda 	#","						; get till comma
.1c43	8d 5e 04	sta $045e			sta 	ReadSep
.1c46					_RBGetText:
.1c46	20 71 1c	jsr $1c71			jsr 	GetLookNext 				; what follows
.1c49	b0 18		bcs $1c63			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.1c4b	20 6e 1c	jsr $1c6e			jsr 	GetBumpNext 				; consume it whatever
.1c4e	cd 5e 04	cmp $045e			cmp 	ReadSep 					; if found the seperator.
.1c51	f0 10		beq $1c63			beq 	_RBEndGet 					; exit after consumption
.1c53	da		phx				phx
.1c54	ae 5f 04	ldx $045f			ldx 	ReadBufferSize 				; copy into buffer.
.1c57	ee 5f 04	inc $045f			inc 	ReadBufferSize
.1c5a	9d 60 04	sta $0460,x			sta 	ReadBuffer,x
.1c5d	9e 61 04	stz $0461,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.1c60	fa		plx				plx
.1c61	80 e3		bra $1c46			bra 	_RBGetText
.1c63					_RBEndGet:
.1c63	c9 22		cmp #$22			cmp 	#'"'
.1c65	d0 03		bne $1c6a			bne 	_RBNotQuote
.1c67	20 6e 1c	jsr $1c6e			jsr 	GetBumpNext
.1c6a					_RBNotQuote:
.1c6a	60		rts				rts
.1c6b					_RBError:
.1c6b	4c 7b 27	jmp $277b		jmp	ErrorV_data
.1c6e					GetBumpNext:
.1c6e	6c 5f 05	jmp ($055f)			jmp 	(ReadBumpNextVec)
.1c71					GetLookNext:
.1c71	6c 61 05	jmp ($0561)			jmp 	(ReadLookNextVec)
.1c74					ReadLookNext:
.1c74	ad 63 05	lda $0563			lda 	dataRemaining 				; any data remaining
.1c77	f0 04		beq $1c7d			beq 	_RLNFindData
.1c79	b2 2b		lda ($2b)			lda 	(objPtr) 					; return that object.
.1c7b	18		clc				clc
.1c7c	60		rts				rts
.1c7d					_RLNFindData:
.1c7d	b2 2b		lda ($2b)			lda 	(objPtr) 					; see where we are
.1c7f	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.1c81	f0 1a		beq $1c9d			beq 	_RLNNoData
.1c83	c9 cf		cmp #$cf			cmp 	#PCD_CMD_DATA 				; Found DATA
.1c85	f0 05		beq $1c8c			beq 	_RLNHaveData
.1c87					_RLNNext:
.1c87	20 e8 27	jsr $27e8			jsr 	MoveObjectForward			; else scan forward.
.1c8a	80 f1		bra $1c7d			bra 	_RLNFindData
.1c8c					_RLNHaveData:
.1c8c	a0 01		ldy #$01			ldy 	#1 							; get length
.1c8e	b1 2b		lda ($2b),y			lda 	(objPtr),y
.1c90	f0 f5		beq $1c87			beq 	_RLNNext 					; skip if DATA alone
.1c92	20 a1 1c	jsr $1ca1			jsr 	ReadBumpNext 				; advance by two
.1c95	20 a1 1c	jsr $1ca1			jsr 	ReadBumpNext
.1c98	8d 63 05	sta $0563			sta 	dataRemaining 				; set data left count.
.1c9b	38		sec				sec
.1c9c	60		rts				rts
.1c9d					_RLNNoData:
.1c9d	a9 00		lda #$00			lda 	#0
.1c9f	38		sec				sec
.1ca0	60		rts				rts
.1ca1					ReadBumpNext:
.1ca1	e6 2b		inc $2b				inc 	objPtr
.1ca3	d0 02		bne $1ca7			bne 	_RBNSkip
.1ca5	e6 2c		inc $2c				inc 	objPtr+1
.1ca7					_RBNSkip:
.1ca7	ce 63 05	dec $0563			dec 	dataRemaining
.1caa	60		rts				rts
.045e					ReadSep:
>045e							.fill 	1
.045f					ReadBufferSize:
>045f							.fill 	1
.0460					ReadBuffer:
>0460							.fill 	255
.055f					ReadBumpNextVec:
>055f							.fill 	2
.0561					ReadLookNextVec:
>0561							.fill 	2
.1cab					ReadFloatCommand:
.1cab	fa		plx				plx
.1cac	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1cae	85 2f		sta $2f				sta 	zTemp0 						; save in MSB
.1cb0	88		dey				dey 								; get the upper 3 bits
.1cb1	b1 28		lda ($28),y			lda 	(codePtr),y
.1cb3	29 07		and #$07			and 	#7
.1cb5	c8		iny				iny
.1cb6	c8		iny				iny
.1cb7	06 2f		asl $2f				asl 	zTemp0 						; shift zTemp0:A left
.1cb9	2a		rol a				rol 	a 							; carry will be clear.
.1cba	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1cbd	85 30		sta $30				sta 	zTemp0+1
.1cbf	20 c5 1c	jsr $1cc5			jsr 	ReadFloatZTemp0Sub
.1cc2	4c 29 10	jmp $1029			jmp 	NextCommand
.1cc5					ReadFloatZTemp0Sub:
.1cc5	5a		phy				phy 								; start write
.1cc6	a0 01		ldy #$01			ldy 	#1
.1cc8	e8		inx				inx
.1cc9	b2 2f		lda ($2f)			lda 	(zTemp0)
.1ccb	95 41		sta $41,x			sta 	NSMantissa0,x
.1ccd	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.1ccf	95 4d		sta $4d,x			sta 	NSMantissa1,x
.1cd1	c8		iny				iny
.1cd2	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.1cd4	95 59		sta $59,x			sta 	NSMantissa2,x
.1cd6	c8		iny				iny
.1cd7	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.1cd9	95 65		sta $65,x			sta 	NSMantissa3,x
.1cdb	c8		iny				iny
.1cdc	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.1cde	95 71		sta $71,x			sta 	NSExponent,x
.1ce0	c8		iny				iny
.1ce1	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.1ce3	95 35		sta $35,x			sta 	NSStatus,x
.1ce5	7a		ply				ply
.1ce6	60		rts				rts
.1ce7					ReadIntegerCommand:
.1ce7	fa		plx				plx
.1ce8	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1cea	85 2f		sta $2f				sta 	zTemp0 						; save in MSB
.1cec	88		dey				dey 								; get the upper 3 bits
.1ced	b1 28		lda ($28),y			lda 	(codePtr),y
.1cef	29 07		and #$07			and 	#7
.1cf1	c8		iny				iny
.1cf2	c8		iny				iny
.1cf3	06 2f		asl $2f				asl 	zTemp0 						; shift zTemp0:A left
.1cf5	2a		rol a				rol 	a 							; carry will be clear.
.1cf6	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1cf9	85 30		sta $30				sta 	zTemp0+1
.1cfb	20 01 1d	jsr $1d01			jsr 	ReadIntegerZTemp0Sub
.1cfe	4c 29 10	jmp $1029			jmp 	NextCommand
.1d01					ReadIntegerZTemp0Sub:
.1d01	5a		phy				phy 								; start write
.1d02	a0 01		ldy #$01			ldy 	#1
.1d04	e8		inx				inx 								; prepare
.1d05	74 59		stz $59,x			stz 	NSMantissa2,x
.1d07	74 65		stz $65,x			stz 	NSMantissa3,x
.1d09	74 71		stz $71,x			stz 	NSExponent,x
.1d0b	74 35		stz $35,x			stz 	NSStatus,x
.1d0d	b1 2f		lda ($2f),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1d0f	30 08		bmi $1d19			bmi 	_RIZNegative
.1d11	95 4d		sta $4d,x			sta 	NSMantissa1,x 				; +ve read
.1d13	b2 2f		lda ($2f)			lda 	(zTemp0)
.1d15	95 41		sta $41,x			sta 	NSMantissa0,x
.1d17	7a		ply				ply
.1d18	60		rts				rts
.1d19					_RIZNegative:
.1d19	38		sec				sec 								; -ve read
.1d1a	a9 00		lda #$00			lda 	#0
.1d1c	f2 2f		sbc ($2f)			sbc 	(zTemp0)
.1d1e	95 41		sta $41,x			sta 	NSMantissa0,x
.1d20	a9 00		lda #$00			lda 	#0
.1d22	f1 2f		sbc ($2f),y			sbc 	(zTemp0),y
.1d24	95 4d		sta $4d,x			sta 	NSMantissa1,x
.1d26	a9 80		lda #$80			lda 	#$80
.1d28	95 35		sta $35,x			sta 	NSStatus,x
.1d2a	7a		ply				ply
.1d2b	60		rts				rts
.1d2c					ReadStringCommand:
.1d2c	fa		plx				plx
.1d2d	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1d2f	85 2f		sta $2f				sta 	zTemp0 						; save in MSB
.1d31	88		dey				dey 								; get the upper 3 bits
.1d32	b1 28		lda ($28),y			lda 	(codePtr),y
.1d34	29 07		and #$07			and 	#7
.1d36	c8		iny				iny
.1d37	c8		iny				iny
.1d38	06 2f		asl $2f				asl 	zTemp0 						; shift zTemp0:A left
.1d3a	2a		rol a				rol 	a 							; carry will be clear.
.1d3b	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1d3e	85 30		sta $30				sta 	zTemp0+1
.1d40	20 46 1d	jsr $1d46			jsr 	ReadStringZTemp0Sub
.1d43	4c 29 10	jmp $1029			jmp 	NextCommand
.1d46					ReadStringZTemp0Sub:
.1d46	5a		phy				phy 								; start write
.1d47	e8		inx				inx 								; prepare
.1d48	74 59		stz $59,x			stz 	NSMantissa2,x
.1d4a	74 65		stz $65,x			stz 	NSMantissa3,x
.1d4c	74 71		stz $71,x			stz 	NSExponent,x
.1d4e	a9 40		lda #$40			lda 	#NSSString
.1d50	74 35		stz $35,x			stz 	NSStatus,x
.1d52	18		clc				clc
.1d53	b2 2f		lda ($2f)			lda 	(zTemp0)					; read address of block add 2.
.1d55	69 02		adc #$02			adc 	#2 							; this points to actual data
.1d57	95 41		sta $41,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.1d59	a0 01		ldy #$01			ldy 	#1
.1d5b	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.1d5d	69 00		adc #$00			adc 	#0
.1d5f	95 4d		sta $4d,x			sta 	NSMantissa1,x 				; +ve read
.1d61	d0 08		bne $1d6b			bne 	_RSZNoDefault 				; if read $00 use a default value.
.1d63	a9 6d		lda #$6d			lda 	#_RSZNull & $FF
.1d65	95 41		sta $41,x			sta 	NSMantissa0,x
.1d67	a9 1d		lda #$1d			lda 	#_RSZNull >> 8
.1d69	95 4d		sta $4d,x			sta 	NSMantissa1,x
.1d6b					_RSZNoDefault:
.1d6b	7a		ply				ply
.1d6c	60		rts				rts
.1d6d					_RSZNull:
>1d6d	00						.byte 	0
.1d6e					CommandRestore:
.1d6e	fa		plx				plx
.1d6f	20 75 1d	jsr $1d75			jsr 	RestoreCode
.1d72	4c 29 10	jmp $1029			jmp 	NextCommand
.1d75					RestoreCode:
.1d75	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer and page
.1d78	85 2e		sta $2e				sta 	objPage+1
.1d7a	64 2d		stz $2d				stz  	objPage
.1d7c	9c 63 05	stz $0563			stz 	dataRemaining 				; no data remaining.
.1d7f	60		rts				rts
.0563					dataRemaining:
>0563							.fill 	1		 					; 0 if not in data statement
.1d80					UnaryRND:
.1d80	fa		plx				plx
.1d81	34 35		bit $35,x			bit 	NSStatus,x 					; -ve then set seed from operand
.1d83	10 17		bpl $1d9c			bpl 	_URNoSeed
.1d85	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise 				; some float value
.1d88	b5 41		lda $41,x			lda 	NSMantissa0,x 				; copy to Mantissa
.1d8a	8d 64 05	sta $0564			sta 	randomSeed+0
.1d8d	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.1d8f	8d 65 05	sta $0565			sta 	randomSeed+1
.1d92	b5 59		lda $59,x			lda 	NSMantissa2,x
.1d94	8d 66 05	sta $0566			sta 	randomSeed+2
.1d97	b5 65		lda $65,x			lda 	NSMantissa3,x
.1d99	8d 67 05	sta $0567			sta 	randomSeed+3
.1d9c					_URNoSeed:
.1d9c	20 be 1d	jsr $1dbe			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.1d9f	ad 64 05	lda $0564			lda 	randomSeed+0
.1da2	95 41		sta $41,x			sta 	NSMantissa0,x
.1da4	ad 65 05	lda $0565			lda 	randomSeed+1
.1da7	95 4d		sta $4d,x			sta 	NSMantissa1,x
.1da9	ad 66 05	lda $0566			lda 	randomSeed+2
.1dac	95 59		sta $59,x			sta 	NSMantissa2,x
.1dae	ad 67 05	lda $0567			lda 	randomSeed+3
.1db1	29 7f		and #$7f			and 	#$7F
.1db3	95 65		sta $65,x			sta 	NSMantissa3,x
.1db5	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.1db7	95 71		sta $71,x			sta 	NSExponent,x
.1db9	74 35		stz $35,x			stz 	NSStatus,x
.1dbb	4c 29 10	jmp $1029			jmp 	NextCommand
.1dbe					RandomNumberGenerator:
.1dbe	5a		phy				phy
.1dbf	ad 64 05	lda $0564			lda 	randomSeed+0 				; check if zero
.1dc2	0d 65 05	ora $0565			ora 	randomSeed+1
.1dc5	0d 66 05	ora $0566			ora 	randomSeed+2
.1dc8	0d 67 05	ora $0567			ora 	randomSeed+3
.1dcb	d0 07		bne $1dd4			bne 	_RNGNoSeed
.1dcd	ce 67 05	dec $0567			dec 	randomSeed+3 				; if so tweak and flog
.1dd0	a0 64		ldy #$64			ldy 	#100
.1dd2	80 05		bra $1dd9			bra 	_RNGLoop
.1dd4					_RNGNoSeed:
.1dd4	a0 08		ldy #$08			ldy 	#8
.1dd6	ad 64 05	lda $0564			lda 	randomSeed+0
.1dd9					_RNGLoop:
.1dd9	0a		asl a				asl		a
.1dda	2e 65 05	rol $0565			rol 	randomSeed+1
.1ddd	2e 66 05	rol $0566			rol 	randomSeed+2
.1de0	2e 67 05	rol $0567			rol 	randomSeed+3
.1de3	90 02		bcc $1de7			bcc		_RNGSkip
.1de5	49 c5		eor #$c5			eor 	#$C5
.1de7					_RNGSkip:
.1de7	88		dey				dey
.1de8	d0 ef		bne $1dd9			bne		_RNGLoop
.1dea	8d 64 05	sta $0564			sta 	randomSeed+0
.1ded	7a		ply				ply
.1dee	60		rts				rts
.0564					randomSeed:
>0564							.fill 	4
.1def					StringConcatenate:
.1def	fa		plx				plx
.1df0	ca		dex				dex
.1df1	b5 41		lda $41,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.1df3	85 31		sta $31				sta 	zTemp1
.1df5	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.1df7	85 32		sta $32				sta 	zTemp1+1
.1df9	b5 42		lda $42,x			lda 	NSMantissa0+1,x
.1dfb	85 33		sta $33				sta 	zTemp2
.1dfd	b5 4e		lda $4e,x			lda 	NSMantissa1+1,x
.1dff	85 34		sta $34				sta 	zTemp2+1
.1e01	18		clc				clc 								; work out total length
.1e02	b2 31		lda ($31)			lda 	(zTemp1)
.1e04	72 33		adc ($33)			adc 	(zTemp2)
.1e06	b0 18		bcs $1e20			bcs 	_BCLength 					; more than 255 characters.
.1e08	48		pha				pha 								; save total
.1e09	20 e6 1e	jsr $1ee6			jsr 	StringAllocTemp 			; space for result.
.1e0c	68		pla				pla 								; write total as first.
.1e0d	92 22		sta ($22)			sta 	(zsTemp)
.1e0f	20 23 1e	jsr $1e23			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.1e12	a5 33		lda $33				lda 	zTemp2 						; copy address zTemp2->1
.1e14	85 31		sta $31				sta 	zTemp1
.1e16	a5 34		lda $34				lda 	zTemp2+1
.1e18	85 32		sta $32				sta 	zTemp1+1
.1e1a	20 23 1e	jsr $1e23			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1e1d	4c 29 10	jmp $1029			jmp 	NextCommand
.1e20					_BCLength:
.1e20	4c b6 26	jmp $26b6		jmp	ErrorV_range
.1e23					_BCCopyZTemp1:
.1e23	b2 31		lda ($31)			lda 	(zTemp1) 					; bytes to copy
.1e25	f0 15		beq $1e3c			beq 	_BCCExit 					; none.
.1e27	da		phx				phx 								; save XY
.1e28	5a		phy				phy
.1e29	aa		tax				tax 								; count in X.
.1e2a	a0 01		ldy #$01			ldy 	#1
.1e2c					_BCCLoop:
.1e2c	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1e2e	d0 02		bne $1e32			bne 	_BCCNoCarry
.1e30	e6 23		inc $23				inc 	zsTemp+1
.1e32					_BCCNoCarry:
.1e32	b1 31		lda ($31),y			lda 	(zTemp1),y				 	; copy bytes
.1e34	92 22		sta ($22)			sta 	(zsTemp)
.1e36	c8		iny				iny
.1e37	ca		dex				dex 								; X times
.1e38	d0 f2		bne $1e2c			bne 	_BCCLoop
.1e3a	7a		ply				ply 								; restore YX
.1e3b	fa		plx				plx
.1e3c					_BCCExit:
.1e3c	60		rts				rts
.1e3d					XRuntimeSetup:
.1e3d	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1e3f	8d 6b 05	sta $056b	 		sta 	ramBank
.1e42	8d 6c 05	sta $056c	 		sta 	romBank
.1e45	60		rts				rts
.1e46					SignTOS:
.1e46	fa		plx				plx
.1e47	20 3b 2e	jsr $2e3b			jsr 	FloatIsZero 				; if zero
.1e4a	f0 0f		beq $1e5b			beq 	_SGZero  					; return Int Zero
.1e4c	b5 35		lda $35,x			lda 	NSStatus,x 					; get status w/sign
.1e4e	48		pha				pha
.1e4f	a9 01		lda #$01			lda 	#1 							; set result to 1
.1e51	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.1e54	68		pla				pla
.1e55	29 80		and #$80			and		#$80 						; copy the sign byte out
.1e57	95 35		sta $35,x			sta 	NSStatus,x  				; so it will be -1 or 1
.1e59	80 03		bra $1e5e			bra 	_SGExit
.1e5b					_SGZero:
.1e5b	20 19 2e	jsr $2e19			jsr 	FloatSetZero
.1e5e					_SGExit:
.1e5e	4c 29 10	jmp $1029			jmp 	NextCommand
.1e61					CommandShift:
.1e61	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.1e63	c8		iny				iny
.1e64	0a		asl a				asl 	a 							; double into X
.1e65	aa		tax				tax
.1e66	7c 11 22	jmp ($2211,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.1e69					PrintTab:
.1e69	fa		plx				plx
.1e6a	20 b0 23	jsr $23b0			jsr 	XGetHPos
.1e6d					_PTMod10:
.1e6d	38		sec				sec
.1e6e	e9 0a		sbc #$0a			sbc 	#10
.1e70	b0 fb		bcs $1e6d			bcs 	_PTMod10
.1e72	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.1e74	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.1e75	80 15		bra $1e8c			bra 	PrintSpaceLoop
.1e77					PrintPos:
.1e77	fa		plx				plx
.1e78	20 b0 23	jsr $23b0			jsr		XGetHPos 					; get current position
.1e7b	85 2f		sta $2f				sta 	zTemp0
.1e7d	38		sec				sec 								; calculate spaces required
.1e7e	b5 41		lda $41,x			lda 	NSMantissa0,x
.1e80	ca		dex				dex
.1e81	e5 2f		sbc $2f				sbc 	zTemp0
.1e83	b0 07		bcs $1e8c			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.1e85	4c 29 10	jmp $1029			jmp 	NextCommand
.1e88					PrintSpace:
.1e88	fa		plx				plx
.1e89	b5 41		lda $41,x			lda 	NSMantissa0,x
.1e8b	ca		dex				dex
.1e8c					PrintSpaceLoop:
.1e8c	c9 00		cmp #$00			cmp 	#0
.1e8e	f0 0a		beq $1e9a			beq 	_PSExit
.1e90	48		pha				pha
.1e91	a9 20		lda #$20			lda 	#" "
.1e93	20 43 1b	jsr $1b43			jsr 	VectorPrintCharacter
.1e96	68		pla				pla
.1e97	3a		dec a				dec 	a
.1e98	80 f2		bra $1e8c			bra 	PrintSpaceLoop
.1e9a					_PSExit:
.1e9a	4c 29 10	jmp $1029			jmp 	NextCommand
.1e9d					CommandStop:
.1e9d	fa		plx				plx
.1e9e	4c 68 27	jmp $2768		jmp	ErrorV_stop
.1ea1					Unary_Str:
.1ea1	fa		plx				plx
.1ea2	5a		phy				phy
.1ea3	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.1ea5	20 01 2d	jsr $2d01			jsr 	FloatToString 				; do the conversion.
.1ea8	a9 21		lda #$21			lda		#33 						; create buffer
.1eaa	20 e6 1e	jsr $1ee6			jsr 	StringAllocTemp 			; allocate memory
.1ead	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.1eaf					_USCopy:
.1eaf	b9 93 05	lda $0593,y			lda 	decimalBuffer-1,y
.1eb2	f0 05		beq $1eb9			beq 	_USExit
.1eb4	91 22		sta ($22),y			sta 	(zsTemp),y
.1eb6	c8		iny				iny
.1eb7	80 f6		bra $1eaf			bra 	_USCopy
.1eb9					_USExit:
.1eb9	98		tya				tya
.1eba	3a		dec a				dec 	a
.1ebb	92 22		sta ($22)			sta 	(zsTemp)
.1ebd	7a		ply				ply
.1ebe	4c 29 10	jmp $1029			jmp 	NextCommand
.1ec1					StringInitialise:
.1ec1	48		pha				pha
.1ec2	ad 68 05	lda $0568			lda 	stringInitialised 			; already done
.1ec5	d0 11		bne $1ed8			bne 	_SIExit
.1ec7	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.1eca	8d 69 05	sta $0569			sta 	stringTempPointer
.1ecd	ad 03 04	lda $0403			lda 	stringHighMemory+1
.1ed0	3a		dec a				dec 	a
.1ed1	3a		dec a				dec 	a
.1ed2	8d 6a 05	sta $056a			sta 	stringTempPointer+1
.1ed5	ce 68 05	dec $0568			dec 	stringInitialised 			; set the initialised flag.
.1ed8					_SIExit:
.1ed8	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.1eda	1a		inc a				inc 	a
.1edb	1a		inc a				inc 	a
.1edc	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.1edf	b0 02		bcs $1ee3			bcs 	_SIMemory
.1ee1	68		pla				pla
.1ee2	60		rts				rts
.1ee3					_SIMemory:
.1ee3	4c c1 27	jmp $27c1		jmp	ErrorV_memory
.1ee6					StringAllocTemp:
.1ee6	20 c1 1e	jsr $1ec1			jsr 	StringInitialise 			; check it is initialised.
.1ee9	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.1eeb	18		clc				clc
.1eec	6d 69 05	adc $0569			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.1eef	8d 69 05	sta $0569			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.1ef2	85 22		sta $22				sta 	zsTemp
.1ef4	95 41		sta $41,x			sta 	NSMantissa0,x
.1ef6	ad 6a 05	lda $056a			lda 	stringTempPointer+1
.1ef9	69 ff		adc #$ff			adc 	#$FF
.1efb	8d 6a 05	sta $056a			sta 	stringTempPointer+1
.1efe	85 23		sta $23				sta 	zsTemp+1
.1f00	95 4d		sta $4d,x			sta 	NSMantissa1,x
.1f02	74 59		stz $59,x			stz 	NSMantissa2,x
.1f04	74 65		stz $65,x			stz 	NSMantissa3,x
.1f06	a9 00		lda #$00			lda 	#0 							; clear string.
.1f08	92 22		sta ($22)			sta 	(zsTemp)
.1f0a	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1f0c	95 35		sta $35,x			sta 	NSStatus,x
.1f0e	60		rts				rts
.1f0f					StringWriteChar:
.1f0f	5a		phy				phy
.1f10	48		pha				pha
.1f11	b2 22		lda ($22)			lda 	(zsTemp)
.1f13	1a		inc a				inc 	a
.1f14	92 22		sta ($22)			sta 	(zsTemp)
.1f16	a8		tay				tay
.1f17	68		pla				pla
.1f18	91 22		sta ($22),y			sta 	(zsTemp),y
.1f1a	7a		ply				ply
.1f1b	60		rts				rts
.0568					stringInitialised:
>0568							.fill 	1
.0569					stringTempPointer:
>0569							.fill 	2
.1f1c					Unary_Left:
.1f1c	fa		plx				plx
.1f1d	5a		phy				phy
.1f1e	18		clc				clc 								; only one parameter
.1f1f	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; push the length of the string.
.1f22	48		pha				pha
.1f23	ca		dex				dex
.1f24	a9 00		lda #$00			lda 	#0 							; push the start position.
.1f26	48		pha				pha
.1f27	20 5f 1f	jsr $1f5f			jsr 	UnarySStringToZTemp0
.1f2a	80 3c		bra $1f68			bra 	SubstringMain 				; stack now points to the string to slice.
.1f2c					Unary_Right:
.1f2c	fa		plx				plx
.1f2d	5a		phy				phy
.1f2e	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.1f30	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; push the right length of the string.
.1f33	48		pha				pha
.1f34	ca		dex				dex
.1f35	20 5f 1f	jsr $1f5f			jsr 	UnarySStringToZTemp0
.1f38	68		pla				pla 								; this is the right requirement
.1f39	38		sec				sec
.1f3a	49 ff		eor #$ff			eor 	#$FF
.1f3c	72 2f		adc ($2f)			adc 	(zTemp0)
.1f3e	b0 02		bcs $1f42			bcs 	_URHaveCount
.1f40	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.1f42					_URHaveCount:
.1f42	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.1f44	5a		phy				phy
.1f45	48		pha				pha 								; start position
.1f46	80 20		bra $1f68			bra 	SubstringMain
.1f48					Unary_Mid:
.1f48	fa		plx				plx
.1f49	5a		phy				phy
.1f4a	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; push the length of the string required.
.1f4d	48		pha				pha
.1f4e	ca		dex				dex
.1f4f	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; put the start position.
.1f52	f0 08		beq $1f5c			beq 	_UMError
.1f54	3a		dec a				dec 	a
.1f55	48		pha				pha
.1f56	ca		dex				dex
.1f57	20 5f 1f	jsr $1f5f			jsr 	UnarySStringToZTemp0
.1f5a	80 0c		bra $1f68			bra 	SubstringMain 				; stack now points to the string to slice.
.1f5c					_UMError:
.1f5c	4c b6 26	jmp $26b6		jmp	ErrorV_range
.1f5f					UnarySStringToZTemp0:
.1f5f	b5 41		lda $41,x			lda 	NSMantissa0,x
.1f61	85 2f		sta $2f				sta 	zTemp0
.1f63	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.1f65	85 30		sta $30				sta 	zTemp0+1
.1f67	60		rts				rts
.1f68					SubstringMain:
.1f68	68		pla				pla 								; get the start offset
.1f69	7a		ply				ply 								; get the count to do.
.1f6a	d2 2f		cmp ($2f)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.1f6c	b0 38		bcs $1fa6			bcs 	_SSReturnNull
.1f6e	85 31		sta $31				sta 	zTemp1 						; save start position.
.1f70	84 32		sty $32				sty 	zTemp1+1 					; save count
.1f72	18		clc				clc
.1f73	65 32		adc $32				adc 	zTemp1+1 					; this is the end position.
.1f75	b0 06		bcs $1f7d			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.1f77	d2 2f		cmp ($2f)			cmp 	(zTemp0) 					; ok if limit is <= length.
.1f79	f0 04		beq $1f7f			beq 	_SMIsOkay
.1f7b	90 02		bcc $1f7f			bcc 	_SMIsOkay
.1f7d					_SMTruncateToEnd:
.1f7d	b2 2f		lda ($2f)			lda 	(zTemp0) 					; end position is length.
.1f7f					_SMIsOkay:
.1f7f	85 32		sta $32				sta 	zTemp1+1
.1f81	38		sec				sec		 							; work out size
.1f82	a5 32		lda $32				lda 	zTemp1+1
.1f84	e5 31		sbc $31				sbc 	zTemp1
.1f86	f0 1e		beq $1fa6			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.1f88	20 e6 1e	jsr $1ee6			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.1f8b	a4 31		ldy $31				ldy 	zTemp1 						; start
.1f8d					_SMCopy:
.1f8d	c4 32		cpy $32				cpy 	zTemp1+1 					; exit if reached end
.1f8f	f0 11		beq $1fa2			beq 	_SMExit
.1f91	c8		iny				iny 								; bump and
.1f92	b1 2f		lda ($2f),y			lda 	(zTemp0),y 					; get character (prefix)
.1f94	5a		phy				phy
.1f95	48		pha				pha
.1f96	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.1f98	1a		inc a				inc 	a
.1f99	a8		tay				tay
.1f9a	92 22		sta ($22)			sta 	(zsTemp)
.1f9c	68		pla				pla 								; write character out
.1f9d	91 22		sta ($22),y			sta 	(zsTemp),y
.1f9f	7a		ply				ply 								; restore Y
.1fa0	80 eb		bra $1f8d			bra 	_SMCopy
.1fa2					_SMExit:
.1fa2	7a		ply				ply
.1fa3	4c 29 10	jmp $1029			jmp 	NextCommand
.1fa6					_SSReturnNull:
.1fa6	a9 b8		lda #$b8			lda 	#SSRNull & $FF 				; set up mantissa
.1fa8	95 41		sta $41,x			sta 	NSMantissa0,x
.1faa	a9 1f		lda #$1f			lda 	#SSRNull >> 8
.1fac	95 4d		sta $4d,x			sta 	NSMantissa1,x
.1fae	74 59		stz $59,x			stz 	NSMantissa2,x
.1fb0	74 65		stz $65,x			stz 	NSMantissa3,x
.1fb2	a9 40		lda #$40			lda 	#NSSString
.1fb4	95 35		sta $35,x			sta 	NSStatus,x
.1fb6	80 ea		bra $1fa2			bra 	_SMExit
.1fb8					SSRNull:
>1fb8	00 00						.word 	0
.1fba					CommandSwap:
.1fba	fa		plx				plx
.1fbb	b5 41		lda $41,x			lda 	NSMantissa0,x
.1fbd	48		pha				pha
.1fbe	b5 40		lda $40,x			lda 	NSMantissa0-1,x
.1fc0	95 41		sta $41,x			sta 	NSMantissa0,x
.1fc2	68		pla				pla
.1fc3	95 40		sta $40,x			sta 	NSMantissa0-1,x
.1fc5	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.1fc7	48		pha				pha
.1fc8	b5 4c		lda $4c,x			lda 	NSMantissa1-1,x
.1fca	95 4d		sta $4d,x			sta 	NSMantissa1,x
.1fcc	68		pla				pla
.1fcd	95 4c		sta $4c,x			sta 	NSMantissa1-1,x
.1fcf	b5 59		lda $59,x			lda 	NSMantissa2,x
.1fd1	48		pha				pha
.1fd2	b5 58		lda $58,x			lda 	NSMantissa2-1,x
.1fd4	95 59		sta $59,x			sta 	NSMantissa2,x
.1fd6	68		pla				pla
.1fd7	95 58		sta $58,x			sta 	NSMantissa2-1,x
.1fd9	b5 65		lda $65,x			lda 	NSMantissa3,x
.1fdb	48		pha				pha
.1fdc	b5 64		lda $64,x			lda 	NSMantissa3-1,x
.1fde	95 65		sta $65,x			sta 	NSMantissa3,x
.1fe0	68		pla				pla
.1fe1	95 64		sta $64,x			sta 	NSMantissa3-1,x
.1fe3	b5 71		lda $71,x			lda 	NSExponent,x
.1fe5	48		pha				pha
.1fe6	b5 70		lda $70,x			lda 	NSExponent-1,x
.1fe8	95 71		sta $71,x			sta 	NSExponent,x
.1fea	68		pla				pla
.1feb	95 70		sta $70,x			sta 	NSExponent-1,x
.1fed	b5 35		lda $35,x			lda 	NSStatus,x
.1fef	48		pha				pha
.1ff0	b5 34		lda $34,x			lda 	NSStatus-1,x
.1ff2	95 35		sta $35,x			sta 	NSStatus,x
.1ff4	68		pla				pla
.1ff5	95 34		sta $34,x			sta 	NSStatus-1,x
.1ff7	4c 29 10	jmp $1029			jmp 	NextCommand
.1ffa					CommandSYS:
.1ffa	fa		plx				plx
.1ffb	da		phx				phx 								; save XY
.1ffc	5a		phy				phy
.1ffd	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.2000	b5 4d		lda $4d,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.2002	85 30		sta $30				sta 	zTemp0+1
.2004	b5 41		lda $41,x			lda 	NSMantissa0,x
.2006	85 2f		sta $2f				sta 	zTemp0
.2008	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.200b	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.200e	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.2011	48		pha				pha
.2012	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.2015	28		plp				plp
.2016	20 2d 20	jsr $202d			jsr 	_CSZTemp0
.2019	08		php				php
.201a	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.201d	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.2020	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.2023	68		pla				pla
.2024	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.2027	7a		ply				ply 								; restore YX and drop 2
.2028	fa		plx				plx
.2029	ca		dex				dex
.202a	4c 29 10	jmp $1029			jmp 	NextCommand
.202d					_CSZTemp0:
.202d	6c 2f 00	jmp ($002f)			jmp 	(zTemp0)
.2030					TimeTOS:
.2030	fa		plx				plx
.2031	20 8b 20	jsr $208b			jsr 	TIPushClock 				; push clock to TOS
.2034	4c 29 10	jmp $1029			jmp 	NextCommand
.2037					TimeString:
.2037	fa		plx				plx
.2038	20 8b 20	jsr $208b			jsr 	TIPushClock 				; push clock to TOS
.203b	20 60 20	jsr $2060			jsr 	_TSDivMod60 				; result in seconds
.203e	20 60 20	jsr $2060			jsr 	_TSDivMod60 				; seconds
.2041	48		pha				pha
.2042	20 60 20	jsr $2060			jsr 	_TSDivMod60 				; minutes
.2045	48		pha				pha
.2046	a9 18		lda #$18			lda 	#24 						; hours
.2048	20 62 20	jsr $2062			jsr 	_TSDivModA
.204b	48		pha				pha
.204c	a9 06		lda #$06			lda 	#6
.204e	20 e6 1e	jsr $1ee6			jsr 	StringAllocTemp
.2051	68		pla				pla
.2052	20 72 20	jsr $2072			jsr 	_TSWriteDecimal
.2055	68		pla				pla
.2056	20 72 20	jsr $2072			jsr 	_TSWriteDecimal
.2059	68		pla				pla
.205a	20 72 20	jsr $2072			jsr 	_TSWriteDecimal
.205d	4c 29 10	jmp $1029			jmp 	NextCommand
.2060					_TSDivMod60:
.2060	a9 3c		lda #$3c			lda 	#60
.2062					_TSDivModA:
.2062	e8		inx				inx
.2063	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.2066	ca		dex				dex
.2067	20 af 29	jsr $29af			jsr 	Int32Divide
.206a	b5 41		lda $41,x			lda 	NSMantissa0,x 				; get modulus
.206c	48		pha				pha
.206d	20 9e 29	jsr $299e			jsr 	NSMCopyPlusTwoToZero
.2070	68		pla				pla
.2071	60		rts				rts
.2072					_TSWriteDecimal:
.2072	da		phx				phx
.2073	a2 30		ldx #$30			ldx 	#'0'
.2075					_TSWDLoop:
.2075	c9 0a		cmp #$0a			cmp 	#10
.2077	90 05		bcc $207e			bcc 	_TSWDEnd
.2079	e9 0a		sbc #$0a			sbc 	#10
.207b	e8		inx				inx
.207c	80 f7		bra $2075			bra 	_TSWDLoop
.207e					_TSWDEnd:
.207e	48		pha				pha
.207f	8a		txa				txa
.2080	20 0f 1f	jsr $1f0f			jsr 	StringWriteChar
.2083	68		pla				pla
.2084	09 30		ora #$30			ora 	#'0'
.2086	20 0f 1f	jsr $1f0f			jsr 	StringWriteChar
.2089	fa		plx				plx
.208a	60		rts				rts
.208b					TIPushClock:
.208b	5a		phy				phy
.208c	e8		inx				inx 								; push 0 on the stack
.208d	20 19 2e	jsr $2e19			jsr 	FloatSetZero
.2090	da		phx				phx
.2091	20 7b 24	jsr $247b			jsr 	XReadClock 					; read time into YXA
.2094	86 2f		stx $2f				stx 	zTemp0
.2096	fa		plx				plx
.2097	95 41		sta $41,x			sta 	NSMantissa0,x
.2099	a5 2f		lda $2f				lda 	zTemp0
.209b	95 4d		sta $4d,x			sta 	NSMantissa1,x
.209d	98		tya				tya
.209e	95 59		sta $59,x			sta 	NSMantissa2,x
.20a0	7a		ply				ply
.20a1	60		rts				rts
.20a2					CommandTIWrite:
.20a2	fa		plx				plx
.20a3	b5 41		lda $41,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.20a5	85 22		sta $22				sta 	zsTemp
.20a7	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.20a9	85 23		sta $23				sta 	zsTemp+1
.20ab	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.20ad	c9 06		cmp #$06			cmp 	#6
.20af	d0 59		bne $210a			bne 	_CTIWError
.20b1	20 19 2e	jsr $2e19			jsr 	FloatSetZero
.20b4	20 d6 20	jsr $20d6			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.20b7	20 d6 20	jsr $20d6			jsr 	_CTIWDigitPair
.20ba	20 d6 20	jsr $20d6			jsr 	_CTIWDigitPair
.20bd	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.20bf	20 01 21	jsr $2101			jsr 	_CTIWMultiply
.20c2	da		phx				phx
.20c3	5a		phy				phy
.20c4	b5 4d		lda $4d,x			lda 	NSMantissa1,x 				; get time into YXA
.20c6	48		pha				pha
.20c7	b5 59		lda $59,x			lda 	NSMantissa2,x
.20c9	a8		tay				tay
.20ca	b5 41		lda $41,x			lda 	NSMantissa0,x
.20cc	fa		plx				plx
.20cd	20 7f 24	jsr $247f			jsr 	XWriteClock 				; update the clock.
.20d0	7a		ply				ply
.20d1	fa		plx				plx
.20d2	ca		dex				dex 								; throw result.
.20d3	4c 29 10	jmp $1029			jmp 	NextCommand
.20d6					_CTIWDigitPair:
.20d6	a9 06		lda #$06			lda 	#6 							; x 6
.20d8	20 01 21	jsr $2101			jsr 	_CTIWMultiply
.20db	20 e7 20	jsr $20e7			jsr 	_CTIWAddDigit 				; add digit
.20de	a9 0a		lda #$0a			lda 	#10 						; x 10
.20e0	20 01 21	jsr $2101			jsr 	_CTIWMultiply
.20e3	20 e7 20	jsr $20e7			jsr 	_CTIWAddDigit 				; add digit
.20e6	60		rts				rts
.20e7					_CTIWAddDigit:
.20e7	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.20e9	d0 02		bne $20ed			bne 	_CTIWASkip
.20eb	e6 23		inc $23				inc 	zsTemp+1
.20ed					_CTIWASkip:
.20ed	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.20ef	38		sec				sec
.20f0	e9 30		sbc #$30			sbc 	#"0"
.20f2	90 16		bcc $210a			bcc 	_CTIWError
.20f4	c9 0a		cmp #$0a			cmp 	#9+1
.20f6	b0 12		bcs $210a			bcs 	_CTIWError
.20f8	e8		inx				inx 								; store at +1
.20f9	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.20fc	ca		dex				dex
.20fd	20 a5 2b	jsr $2ba5			jsr 	FloatAddTopTwoStack
.2100	60		rts				rts
.2101					_CTIWMultiply:
.2101	e8		inx				inx
.2102	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.2105	ca		dex				dex
.2106	20 26 2b	jsr $2b26			jsr 	FloatMultiplyShort
.2109	60		rts				rts
.210a					_CTIWError:
.210a	4c c6 26	jmp $26c6		jmp	ErrorV_value
.210d					UnaryUsr:
.210d	fa		plx				plx
.210e	5a		phy				phy
.210f	20 16 21	jsr $2116			jsr 	_UUCallVector
.2112	7a		ply				ply
.2113	4c 29 10	jmp $1029			jmp 	NextCommand
.2116					_UUCallVector:
.2116	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.2119					ValUnary:
.2119	fa		plx				plx
.211a	b5 41		lda $41,x			lda 	NSMantissa0,x
.211c	85 2f		sta $2f				sta 	zTemp0
.211e	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.2120	85 30		sta $30				sta 	zTemp0+1
.2122	20 2d 21	jsr $212d			jsr 	ValEvaluateZTemp0
.2125	b0 03		bcs $212a			bcs 	_VUError 					; couldn't convert
.2127	4c 29 10	jmp $1029			jmp 	NextCommand
.212a					_VUError:
.212a	4c c6 26	jmp $26c6		jmp	ErrorV_value
.212d					ValEvaluateZTemp0:
.212d	5a		phy				phy
.212e	b2 2f		lda ($2f)			lda 	(zTemp0) 					; check not empty string
.2130	f0 22		beq $2154			beq 	_VMCFail2
.2132	a0 00		ldy #$00			ldy 	#0 							; start position
.2134					_VMCSpaces:
.2134	c8		iny				iny 								; skip leading spaces
.2135	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.2137	c9 20		cmp #$20			cmp 	#" "
.2139	f0 f9		beq $2134			beq 	_VMCSpaces
.213b	48		pha				pha 								; save first character
.213c	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.213e	d0 01		bne $2141			bne 	_VMCStart
.2140	c8		iny				iny 								; skip over - if so.
.2141					_VMCStart:
.2141	38		sec				sec 								; initialise first time round.
.2142					_VMCNext:
.2142	98		tya				tya 								; reached end of string
.2143	3a		dec a				dec 	a
.2144	52 2f		eor ($2f)			eor 	(zTemp0) 					; compare length preserve carry.
.2146	f0 0f		beq $2157			beq 	_VMCSuccess 				; successful.
.2148	b1 2f		lda ($2f),y			lda 	(zTemp0),y 					; encode a number.
.214a	c8		iny				iny
.214b	20 fd 2b	jsr $2bfd			jsr 	FloatEncode 				; send it to the number-builder
.214e	90 03		bcc $2153			bcc 	_VMCFail 					; if failed, give up.
.2150	18		clc				clc 								; next time round, countinue
.2151	80 ef		bra $2142			bra 	_VMCNext
.2153					_VMCFail:
.2153	68		pla				pla
.2154					_VMCFail2:
.2154	7a		ply				ply
.2155	38		sec				sec
.2156	60		rts				rts
.2157					_VMCSuccess:
.2157	a9 00		lda #$00			lda 	#0 							; construct final
.2159	20 fd 2b	jsr $2bfd			jsr 	FloatEncode 				; by sending a duff value.
.215c	68		pla				pla 								; if it was -ve
.215d	c9 2d		cmp #$2d			cmp 	#"-"
.215f	d0 03		bne $2164			bne 	_VMCNotNegative
.2161	20 db 2d	jsr $2ddb			jsr		FloatNegate 				; negate it.
.2164					_VMCNotNegative:
.2164	7a		ply				ply
.2165	18		clc				clc
.2166	60		rts				rts
.2167					VectorTable:
>2167	72 18					.word	LinkFloatAdd             ; $80 +
>2169	7b 18					.word	LinkFloatSubtract        ; $81 -
>216b	84 18					.word	LinkFloatMultiply        ; $82 *
>216d	8d 18					.word	LinkFloatDivide          ; $83 /
>216f	98 18					.word	LinkFloatPower           ; $84 ^
>2171	bb 10					.word	BinaryAnd                ; $85 and
>2173	bf 10					.word	BinaryOr                 ; $86 or
>2175	a3 18					.word	LinkCompareGreater       ; $87 >
>2177	ac 18					.word	LinkCompareEqual         ; $88 =
>2179	b5 18					.word	LinkCompareLess          ; $89 <
>217b	be 18					.word	LinkCompareGreaterEqual  ; $8a >=
>217d	c7 18					.word	LinkCompareNotEqual      ; $8b <>
>217f	d0 18					.word	LinkCompareLessEqual     ; $8c <=
>2181	a3 10					.word	AbsoluteTOS              ; $8d abs
>2183	f6 10					.word	ArrayConvert             ; $8e array
>2185	9e 11					.word	UnaryAsc                 ; $8f asc
>2187	b9 11					.word	CommandAssert            ; $90 assert
>2189	fa 11					.word	Unary16Bin               ; $91 bin$
>218b	24 12					.word	PrintCharacter           ; $92 print.chr
>218d	2e 12					.word	UnaryChr                 ; $93 chr$
>218f	93 12					.word	CompareStrings           ; $94 s.cmp
>2191	7a 14					.word	CommandFor               ; $95 for
>2193	3d 15					.word	UnaryFre                 ; $96 fre
>2195	55 15					.word	CommandGet               ; $97 get
>2197	7b 15					.word	CommandReturn            ; $98 return
>2199	c2 15					.word	Command_PSET             ; $99 pset
>219b	dc 15					.word	Command_LINE             ; $9a line
>219d	f1 15					.word	Command_RECT             ; $9b rect
>219f	00 16					.word	Command_FRAME            ; $9c frame
>21a1	0f 16					.word	Command_CHAR             ; $9d char
>21a3	a6 16					.word	Unary16Hex               ; $9e hex$
>21a5	4d 17					.word	CommandInput             ; $9f input
>21a7	64 17					.word	CommandInputString       ; $a0 input$
>21a9	7d 17					.word	CommandInputReset        ; $a1 input.start
>21ab	61 18					.word	UnaryLen                 ; $a2 len
>21ad	2d 19					.word	LinkFloatCompare         ; $a3 f.cmp
>21af	36 19					.word	LinkDivideInt32          ; $a4 int.div
>21b1	ba 19					.word	NegateTOS                ; $a5 negate
>21b3	c1 19					.word	CommandNewLine           ; $a6 new.line
>21b5	ca 19					.word	CommandNext              ; $a7 next
>21b7	b3 1a					.word	NotTOS                   ; $a8 not
>21b9	ca 1a					.word	CommandOn                ; $a9 on
>21bb	e8 1a					.word	CommandMoreOn            ; $aa moreon
>21bd	f0 1a					.word	UnaryPeek                ; $ab peek
>21bf	05 1b					.word	CommandPOKE              ; $ac poke
>21c1	1d 1b					.word	UnaryPos                 ; $ad pos
>21c3	27 1b					.word	GetChannel               ; $ae getchannel
>21c5	32 1b					.word	SetChannel               ; $af setchannel
>21c7	55 1b					.word	PrintNumber              ; $b0 print.n
>21c9	74 1b					.word	PrintString              ; $b1 print.s
>21cb	db 1b					.word	CommandRead              ; $b2 read
>21cd	f5 1b					.word	CommandReadString        ; $b3 read$
>21cf	80 1d					.word	UnaryRND                 ; $b4 rnd
>21d1	ef 1d					.word	StringConcatenate        ; $b5 concat
>21d3	46 1e					.word	SignTOS                  ; $b6 sgn
>21d5	69 1e					.word	PrintTab                 ; $b7 print.tab
>21d7	77 1e					.word	PrintPos                 ; $b8 print.pos
>21d9	88 1e					.word	PrintSpace               ; $b9 print.spc
>21db	a1 1e					.word	Unary_Str                ; $ba str$
>21dd	1c 1f					.word	Unary_Left               ; $bb left$
>21df	2c 1f					.word	Unary_Right              ; $bc right$
>21e1	48 1f					.word	Unary_Mid                ; $bd mid$
>21e3	ba 1f					.word	CommandSwap              ; $be swap
>21e5	30 20					.word	TimeTOS                  ; $bf ti
>21e7	37 20					.word	TimeString               ; $c0 ti$
>21e9	0d 21					.word	UnaryUsr                 ; $c1 usr
>21eb	19 21					.word	ValUnary                 ; $c2 val
>21ed	77 23					.word	CommandClose             ; $c3 close
>21ef	89 23					.word	CommandExit              ; $c4 exit
>21f1	8f 23					.word	CommandDebug             ; $c5 debug
>21f3	f5 23					.word	CommandOpen              ; $c6 open
>21f5	89 24					.word	CommandScreen            ; $c7 screen
>21f7	70 26					.word	CommandVPOKE             ; $c8 vpoke
>21f9	95 26					.word	CommandVPEEK             ; $c9 vpeek
>21fb	61 1e					.word	CommandShift             ; $ca .shift
>21fd	67 10					.word	PushByteCommand          ; $cb .byte
>21ff	7a 10					.word	PushWordCommand          ; $cc .word
>2201	97 1b					.word	CommandPushN             ; $cd .float
>2203	bd 1b					.word	CommandPushS             ; $ce .string
>2205	1b 13					.word	CommandData              ; $cf .data
>2207	8d 15					.word	CommandGoto              ; $d0 .goto
>2209	6f 15					.word	CommandGosub             ; $d1 .gosub
>220b	a4 15					.word	CommandGotoZ             ; $d2 .goto.z
>220d	b3 15					.word	CommandGotoNZ            ; $d3 .goto.nz
>220f	a9 10					.word	CommandVarSpace          ; $d4 .varspace
.2211					ShiftVectorTable:
>2211	46 12					.word	CommandClr               ; $ca80 clr
>2213	24 13					.word	CommandDIM               ; $ca81 dim
>2215	15 14					.word	CommandEnd               ; $ca82 end
>2217	32 18					.word	UnaryJoy                 ; $ca83 joy
>2219	d9 18					.word	LinkFloatIntegerPartDown ; $ca84 int
>221b	e2 18					.word	LinkFloatSquareRoot      ; $ca85 sqr
>221d	f3 18					.word	LinkFloatLogarithm       ; $ca86 log
>221f	fe 18					.word	LinkFloatExponent        ; $ca87 exp
>2221	07 19					.word	LinkFloatCosine          ; $ca88 cos
>2223	10 19					.word	LinkFloatSine            ; $ca89 sin
>2225	19 19					.word	LinkFloatTangent         ; $ca8a tan
>2227	22 19					.word	LinkFloatArcTan          ; $ca8b atn
>2229	6a 19					.word	XCommandMouse            ; $ca8c mouse
>222b	7f 19					.word	XUnaryMB                 ; $ca8d mb
>222d	8c 19					.word	XUnaryMX                 ; $ca8e mx
>222f	9d 19					.word	XUnaryMY                 ; $ca8f my
>2231	6e 1d					.word	CommandRestore           ; $ca90 restore
>2233	9d 1e					.word	CommandStop              ; $ca91 stop
>2235	fa 1f					.word	CommandSYS               ; $ca92 sys
>2237	a2 20					.word	CommandTIWrite           ; $ca93 ti$.write
>2239	6f 22					.word	CommandWAIT              ; $ca94 wait
>223b	ba 23					.word	X16I2CPoke               ; $ca95 i2cpoke
>223d	da 23					.word	X16I2CPeek               ; $ca96 i2cpeek
>223f	45 24					.word	CommandBank              ; $ca97 bank
>2241	98 24					.word	XCommandSleep            ; $ca98 sleep
>2243	bc 24					.word	X16_Audio_FMINIT         ; $ca99 fminit
>2245	ca 24					.word	X16_Audio_FMNOTE         ; $ca9a fmnote
>2247	dc 24					.word	X16_Audio_FMDRUM         ; $ca9b fmdrum
>2249	ee 24					.word	X16_Audio_FMINST         ; $ca9c fminst
>224b	00 25					.word	X16_Audio_FMVIB          ; $ca9d fmvib
>224d	12 25					.word	X16_Audio_FMFREQ         ; $ca9e fmfreq
>224f	23 25					.word	X16_Audio_FMVOL          ; $ca9f fmvol
>2251	35 25					.word	X16_Audio_FMPAN          ; $caa0 fmpan
>2253	47 25					.word	X16_Audio_FMPLAY         ; $caa1 fmplay
>2255	58 25					.word	X16_Audio_FMCHORD        ; $caa2 fmchord
>2257	69 25					.word	X16_Audio_FMPOKE         ; $caa3 fmpoke
>2259	7b 25					.word	X16_Audio_PSGINIT        ; $caa4 psginit
>225b	89 25					.word	X16_Audio_PSGNOTE        ; $caa5 psgnote
>225d	9b 25					.word	X16_Audio_PSGVOL         ; $caa6 psgvol
>225f	ad 25					.word	X16_Audio_PSGWAV         ; $caa7 psgwav
>2261	bf 25					.word	X16_Audio_PSGFREQ        ; $caa8 psgfreq
>2263	d0 25					.word	X16_Audio_PSGPAN         ; $caa9 psgpan
>2265	e2 25					.word	X16_Audio_PSGPLAY        ; $caaa psgplay
>2267	f3 25					.word	X16_Audio_PSGCHORD       ; $caab psgchord
>2269	04 26					.word	CommandCls               ; $caac cls
>226b	0d 26					.word	CommandLocate            ; $caad locate
>226d	37 26					.word	CommandColor             ; $caae color
.226f					CommandWAIT:
.226f	fa		plx				plx
.2270	b5 3f		lda $3f,x			lda 	NSMantissa0-2,x 			; get wait address
.2272	85 2f		sta $2f				sta 	zTemp0
.2274	b5 4b		lda $4b,x			lda 	NSMantissa1-2,x
.2276	85 30		sta $30				sta 	zTemp0+1
.2278					_WaitLoop:
.2278	b2 2f		lda ($2f)			lda 	(zTemp0) 					; read it
.227a	35 40		and $40,x			and 	NSMantissa0-1,x		 		; and with mask
.227c	55 41		eor $41,x			eor 	NSMantissa0-0,x 			; toggle
.227e	f0 f8		beq $2278			beq 	_WaitLoop 					; keep going if zero
.2280	ca		dex				dex 								; drop 3.
.2281	ca		dex				dex
.2282	ca		dex				dex
.2283	4c 29 10	jmp $1029			jmp 	NextCommand
.2286					WriteFloatCommand:
.2286	fa		plx				plx
.2287	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.2289	85 2f		sta $2f				sta 	zTemp0 						; save in MSB
.228b	88		dey				dey 								; get the upper 3 bits
.228c	b1 28		lda ($28),y			lda 	(codePtr),y
.228e	29 07		and #$07			and 	#7
.2290	c8		iny				iny
.2291	c8		iny				iny
.2292	06 2f		asl $2f				asl 	zTemp0 						; shift zTemp0:A left
.2294	2a		rol a				rol 	a 							; carry will be clear.
.2295	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.2298	85 30		sta $30				sta 	zTemp0+1
.229a	20 a0 22	jsr $22a0			jsr 	WriteFloatZTemp0Sub
.229d	4c 29 10	jmp $1029			jmp 	NextCommand
.22a0					WriteFloatZTemp0Sub:
.22a0	5a		phy				phy 								; ldart write
.22a1	a0 01		ldy #$01			ldy 	#1
.22a3	b5 41		lda $41,x			lda 	NSMantissa0,x
.22a5	92 2f		sta ($2f)			sta 	(zTemp0)
.22a7	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.22a9	91 2f		sta ($2f),y			sta 	(zTemp0),y
.22ab	c8		iny				iny
.22ac	b5 59		lda $59,x			lda 	NSMantissa2,x
.22ae	91 2f		sta ($2f),y			sta 	(zTemp0),y
.22b0	c8		iny				iny
.22b1	b5 65		lda $65,x			lda 	NSMantissa3,x
.22b3	91 2f		sta ($2f),y			sta 	(zTemp0),y
.22b5	c8		iny				iny
.22b6	b5 71		lda $71,x			lda 	NSExponent,x
.22b8	91 2f		sta ($2f),y			sta 	(zTemp0),y
.22ba	c8		iny				iny
.22bb	b5 35		lda $35,x			lda 	NSStatus,x
.22bd	91 2f		sta ($2f),y			sta 	(zTemp0),y
.22bf	ca		dex				dex
.22c0	7a		ply				ply
.22c1	60		rts				rts
.22c2					WriteIntegerCommand:
.22c2	fa		plx				plx
.22c3	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.22c5	85 2f		sta $2f				sta 	zTemp0 						; save in MSB
.22c7	88		dey				dey 								; get the upper 3 bits
.22c8	b1 28		lda ($28),y			lda 	(codePtr),y
.22ca	29 07		and #$07			and 	#7
.22cc	c8		iny				iny
.22cd	c8		iny				iny
.22ce	06 2f		asl $2f				asl 	zTemp0 						; shift zTemp0:A left
.22d0	2a		rol a				rol 	a 							; carry will be clear.
.22d1	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.22d4	85 30		sta $30				sta 	zTemp0+1
.22d6	20 dc 22	jsr $22dc			jsr 	WriteIntegerZTemp0Sub
.22d9	4c 29 10	jmp $1029			jmp 	NextCommand
.22dc					WriteIntegerZTemp0Sub:
.22dc	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.22df	5a		phy				phy 								; start write
.22e0	a0 01		ldy #$01			ldy 	#1
.22e2	b5 35		lda $35,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.22e4	30 0b		bmi $22f1			bmi 	_WIZNegative
.22e6	b5 41		lda $41,x			lda 	NSMantissa0,x 				; +ve write
.22e8	92 2f		sta ($2f)			sta 	(zTemp0)
.22ea	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.22ec	91 2f		sta ($2f),y			sta 	(zTemp0),y
.22ee	7a		ply				ply
.22ef	ca		dex				dex
.22f0	60		rts				rts
.22f1					_WIZNegative:
.22f1	38		sec				sec 								; -ve read
.22f2	a9 00		lda #$00			lda 	#0
.22f4	f5 41		sbc $41,x			sbc 	NSMantissa0,x
.22f6	92 2f		sta ($2f)			sta 	(zTemp0)
.22f8	a9 00		lda #$00			lda 	#0
.22fa	f5 4d		sbc $4d,x			sbc 	NSMantissa1,x
.22fc	91 2f		sta ($2f),y			sta 	(zTemp0),y
.22fe	7a		ply				ply
.22ff	ca		dex				dex
.2300	60		rts				rts
.2301					WriteStringCommand:
.2301	fa		plx				plx
.2302	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.2304	85 2f		sta $2f				sta 	zTemp0 						; save in MSB
.2306	88		dey				dey 								; get the upper 3 bits
.2307	b1 28		lda ($28),y			lda 	(codePtr),y
.2309	29 07		and #$07			and 	#7
.230b	c8		iny				iny
.230c	c8		iny				iny
.230d	06 2f		asl $2f				asl 	zTemp0 						; shift zTemp0:A left
.230f	2a		rol a				rol 	a 							; carry will be clear.
.2310	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.2313	85 30		sta $30				sta 	zTemp0+1
.2315	20 1b 23	jsr $231b			jsr 	WriteStringZTemp0Sub
.2318	4c 29 10	jmp $1029			jmp 	NextCommand
.231b					WriteStringZTemp0Sub:
.231b	5a		phy				phy
.231c	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.231e	b2 2f		lda ($2f)			lda 	(zTemp0)
.2320	11 2f		ora ($2f),y			ora 	(zTemp0),y
.2322	f0 1e		beq $2342			beq 	_WSConcrete
.2324	b2 2f		lda ($2f)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.2326	85 31		sta $31				sta 	zTemp1
.2328	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.232a	85 32		sta $32				sta 	zTemp1+1
.232c	b5 41		lda $41,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.232e	85 33		sta $33				sta 	zTemp2
.2330	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.2332	85 34		sta $34				sta 	zTemp2+1
.2334	b2 31		lda ($31)			lda 	(zTemp1) 					; space available
.2336	d2 33		cmp ($33)			cmp 	(zTemp2) 					; if >= required length then copy
.2338	b0 17		bcs $2351			bcs 	_WSCopy
.233a	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.233c	b1 31		lda ($31),y			lda 	(zTemp1),y
.233e	09 80		ora #$80			ora 	#$80
.2340	91 31		sta ($31),y			sta 	(zTemp1),y
.2342					_WSConcrete:
.2342	b5 4d		lda $4d,x			lda 	NSMantissa1,x 				; string in YA
.2344	a8		tay				tay
.2345	b5 41		lda $41,x			lda 	NSMantissa0,x
.2347	20 d5 12	jsr $12d5			jsr 	StringConcrete
.234a	92 2f		sta ($2f)			sta 	(zTemp0) 					; save returned address
.234c	98		tya				tya
.234d	a0 01		ldy #$01			ldy 	#1
.234f	91 2f		sta ($2f),y			sta 	(zTemp0),y
.2351					_WSCopy
.2351	18		clc				clc  								; copy target+2 to zTemp2
.2352	b2 2f		lda ($2f)			lda 	(zTemp0)
.2354	69 02		adc #$02			adc 	#2
.2356	85 33		sta $33				sta 	zTemp2
.2358	a0 01		ldy #$01			ldy 	#1
.235a	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.235c	69 00		adc #$00			adc 	#0
.235e	85 34		sta $34				sta 	zTemp2+1
.2360	b5 41		lda $41,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.2362	85 31		sta $31				sta 	zTemp1
.2364	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.2366	85 32		sta $32				sta 	zTemp1+1
.2368	b2 31		lda ($31)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.236a	a8		tay				tay
.236b					_WSCopyLoop:
.236b	b1 31		lda ($31),y			lda 	(zTemp1),y
.236d	91 33		sta ($33),y			sta 	(zTemp2),y
.236f	88		dey				dey
.2370	c0 ff		cpy #$ff			cpy 	#$FF
.2372	d0 f7		bne $236b			bne 	_WSCopyLoop
.2374	ca		dex				dex
.2375	7a		ply				ply
.2376	60		rts				rts
.2377					CommandClose:
.2377	fa		plx				plx
.2378	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; channel to close
.237b	cd 5d 04	cmp $045d			cmp 	currentChannel 				; is it the current channel
.237e	d0 03		bne $2383			bne 	_CCNotCurrent
.2380	9c 5d 04	stz $045d			stz 	currentChannel 				; effectively disables CMD
.2383					_CCNotCurrent:
.2383	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.2386	4c 29 10	jmp $1029			jmp 	NextCommand
.2389					CommandExit:
.2389	fa		plx				plx
.238a	86 2f		stx $2f				stx 	zTemp0 						; stack position.
.238c	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.238f					CommandDebug:
.238f	fa		plx				plx
>2390	db						.byte 	$DB 						; causes a break in the emulator
.2391	4c 29 10	jmp $1029			jmp 	NextCommand
.2394					XGetCharacterFromChannel:
.2394	da		phx				phx
.2395	5a		phy				phy
.2396	e0 00		cpx #$00			cpx 	#0 							; is it default
.2398	d0 05		bne $239f			bne 	_XGetChannel
.239a	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.239d	80 08		bra $23a7			bra 	_XGetChar
.239f					_XGetChannel:
.239f	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.23a2	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.23a5	d0 06		bne $23ad			bne 	_XGCError
.23a7					_XGetChar:
.23a7	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.23aa	7a		ply				ply
.23ab	fa		plx				plx
.23ac	60		rts				rts
.23ad					_XGCError:
.23ad	4c d2 27	jmp $27d2		jmp	ErrorV_channel
.23b0					XGetHPos:
.23b0	da		phx				phx
.23b1	5a		phy				phy
.23b2	38		sec				sec
.23b3	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.23b6	98		tya				tya
.23b7	7a		ply				ply
.23b8	fa		plx				plx
.23b9	60		rts				rts
.23ba					X16I2CPoke:
.23ba	fa		plx				plx
.23bb	5a		phy				phy
.23bc	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; value
.23bf	48		pha				pha
.23c0	ca		dex				dex
.23c1	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; register
.23c4	48		pha				pha
.23c5	ca		dex				dex
.23c6	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; device
.23c9	aa		tax				tax
.23ca	7a		ply				ply
.23cb	68		pla				pla
.23cc	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.23cf	b0 06		bcs $23d7			bcs 	X16I2CError
.23d1	7a		ply				ply
.23d2	a2 ff		ldx #$ff			ldx 	#$FF
.23d4	4c 29 10	jmp $1029			jmp 	NextCommand
.23d7					X16I2CError:
.23d7	4c d2 27	jmp $27d2		jmp	ErrorV_channel
.23da					X16I2CPeek:
.23da	fa		plx				plx
.23db	da		phx				phx
.23dc	5a		phy				phy
.23dd	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; register
.23e0	48		pha				pha
.23e1	ca		dex				dex
.23e2	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; device
.23e5	aa		tax				tax 								; X device
.23e6	7a		ply				ply 								; Y register
.23e7	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.23ea	b0 eb		bcs $23d7			bcs 	X16I2CError
.23ec	7a		ply				ply 								; restore Y/X
.23ed	fa		plx				plx
.23ee	ca		dex				dex 								; drop TOS (register)
.23ef	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte 				; write read value to TOS.
.23f2	4c 29 10	jmp $1029			jmp 	NextCommand
.23f5					CommandOpen:
.23f5	fa		plx				plx
.23f6	a5 44		lda $44				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.23f8	85 2f		sta $2f				sta 	zTemp0
.23fa	aa		tax				tax
.23fb	a5 50		lda $50				lda 	NSMantissa1+3
.23fd	85 30		sta $30				sta 	zTemp0+1
.23ff	a8		tay				tay
.2400	e8		inx				inx 								; XY points to first character
.2401	d0 01		bne $2404			bne 	_CONoCarry
.2403	c8		iny				iny
.2404					_CONoCarry:
.2404	b2 2f		lda ($2f)			lda 	(zTemp0) 					; get length of filename
.2406	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.2409	a5 41		lda $41				lda 	NSMantissa0+0
.240b	a6 42		ldx $42				ldx 	NSMantissa0+1
.240d	a4 43		ldy $43				ldy 	NSMantissa0+2
.240f	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.2412	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.2415	b0 03		bcs $241a			bcs 	_COError
.2417	4c 29 10	jmp $1029			jmp 	NextCommand
.241a					_COError:
.241a	4c d2 27	jmp $27d2		jmp	ErrorV_channel
.241d					XPokeMemory:
.241d	86 2f		stx $2f				stx 	zTemp0
.241f	84 30		sty $30				sty 	zTemp0+1
.2421	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.2423	ae 6b 05	ldx $056b			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.2426	e0 ff		cpx #$ff			cpx 	#$FF
.2428	f0 02		beq $242c			beq 	_XPMNoSwitch
.242a	86 00		stx $00				stx 	SelectRAMBank
.242c					_XPMNoSwitch:
.242c	92 2f		sta ($2f)			sta 	(zTemp0) 					; do the POKE
.242e	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.2430					_XPMExit:
.2430	60		rts				rts
.2431					XPeekMemory:
.2431	86 2f		stx $2f				stx 	zTemp0
.2433	84 30		sty $30				sty 	zTemp0+1
.2435	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.2437	ae 6b 05	ldx $056b			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.243a	e0 ff		cpx #$ff			cpx 	#$FF
.243c	f0 02		beq $2440			beq 	_XPMNoSwitch
.243e	86 00		stx $00				stx 	SelectRAMBank
.2440					_XPMNoSwitch:
.2440	b2 2f		lda ($2f)			lda 	(zTemp0) 					; do the PEEK
.2442	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.2444	60		rts				rts
.2445					CommandBank:
.2445	fa		plx				plx
.2446	a5 41		lda $41				lda 	NSMantissa0 				; RAM bank
.2448	8d 6b 05	sta $056b			sta 	ramBank 					; store & make current
.244b	85 00		sta $00				sta 	SelectRAMBank
.244d	a5 42		lda $42				lda 	NSMantissa0+1 		 		; ROM specified
.244f	c9 ff		cmp #$ff			cmp 	#$FF
.2451	f0 03		beq $2456			beq 	_CBNoUpdate
.2453	8d 6c 05	sta $056c			sta 	romBank 					; this doesn't set the hardware page.
.2456					_CBNoUpdate:
.2456	a2 ff		ldx #$ff			ldx 	#$FF
.2458	4c 29 10	jmp $1029			jmp 	NextCommand
.056b					ramBank:
>056b							.fill 	1
.056c					romBank:
>056c							.fill 	1
.245b					XPrintCharacterToChannel:
.245b	48		pha				pha
.245c	da		phx				phx
.245d	5a		phy				phy
.245e	48		pha				pha  								; save char
.245f	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.2461	d0 05		bne $2468			bne 	_XPCNotDefault
.2463	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.2466	80 08		bra $2470			bra 	_XPCSend
.2468					_XPCNotDefault:
.2468	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.246b	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.246e	d0 08		bne $2478			bne 	_XPCError
.2470					_XPCSend:
.2470	68		pla				pla 								; restore character
.2471	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.2474	7a		ply				ply
.2475	fa		plx				plx
.2476	68		pla				pla
.2477	60		rts				rts
.2478					_XPCError:
.2478	4c d2 27	jmp $27d2		jmp	ErrorV_channel
.247b					XReadClock:
.247b	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.247e	60		rts				rts
.247f					XWriteClock:
.247f	48		pha				pha
.2480	da		phx				phx
.2481	5a		phy				phy
.2482	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.2485	7a		ply				ply
.2486	fa		plx				plx
.2487	68		pla				pla
.2488	60		rts				rts
.2489					CommandScreen:
.2489	fa		plx				plx
.248a	da		phx				phx
.248b	5a		phy				phy
.248c	20 0a 18	jsr $180a			jsr 	GetInteger8Bit
.248f	18		clc				clc
.2490	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.2493	7a		ply				ply
.2494	fa		plx				plx
.2495	4c 29 10	jmp $1029			jmp 	NextCommand
.2498					XCommandSleep:
.2498	fa		plx				plx
.2499	5a		phy				phy
.249a	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.249d	ca		dex				dex
.249e	20 7b 24	jsr $247b			jsr 	XReadClock 					; read clock to YXA
.24a1	18		clc				clc 								; calculate end time in zTemp0
.24a2	65 41		adc $41				adc 	NSMantissa0
.24a4	85 2f		sta $2f				sta 	zTemp0
.24a6	8a		txa				txa
.24a7	65 4d		adc $4d				adc 	NSMantissa1
.24a9	85 30		sta $30				sta 	zTemp0+1
.24ab					_XCWait:
.24ab	20 7b 24	jsr $247b			jsr 	XReadClock 					; and wait for it.
.24ae	c5 2f		cmp $2f				cmp 	zTemp0
.24b0	d0 f9		bne $24ab			bne 	_XCWait
.24b2	e4 30		cpx $30				cpx 	zTemp0+1
.24b4	d0 f5		bne $24ab			bne 	_XCWait
.24b6	a2 ff		ldx #$ff			ldx 	#$FF
.24b8	7a		ply				ply
.24b9	4c 29 10	jmp $1029			jmp 	NextCommand
.24bc					X16_Audio_FMINIT:
.24bc	fa		plx				plx
.24bd	5a		phy			phy
.24be	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>24c1	63 c0					.word	X16A_ym_init
>24c3	0a					.byte	X16_AudioCodeBank
.24c4	a2 ff		ldx #$ff		ldx	#$FF
.24c6	7a		ply			ply
.24c7	4c 29 10	jmp $1029			jmp 	NextCommand
.24ca					X16_Audio_FMNOTE:
.24ca	fa		plx				plx
.24cb	5a		phy			phy
.24cc	20 d0 11	jsr $11d0		jsr		X16_Audio_Parameters8_8
.24cf	18		clc			clc
.24d0	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>24d3	03 c0					.word	X16A_bas_fmnote
>24d5	0a					.byte	X16_AudioCodeBank
.24d6	a2 ff		ldx #$ff		ldx	#$FF
.24d8	7a		ply			ply
.24d9	4c 29 10	jmp $1029			jmp 	NextCommand
.24dc					X16_Audio_FMDRUM:
.24dc	fa		plx				plx
.24dd	5a		phy			phy
.24de	20 d0 11	jsr $11d0		jsr		X16_Audio_Parameters8_8
.24e1	18		clc			clc
.24e2	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>24e5	6f c0					.word	X16A_ym_playdrum
>24e7	0a					.byte	X16_AudioCodeBank
.24e8	a2 ff		ldx #$ff		ldx	#$FF
.24ea	7a		ply			ply
.24eb	4c 29 10	jmp $1029			jmp 	NextCommand
.24ee					X16_Audio_FMINST:
.24ee	fa		plx				plx
.24ef	5a		phy			phy
.24f0	20 d0 11	jsr $11d0		jsr		X16_Audio_Parameters8_8
.24f3	38		sec			sec
.24f4	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>24f7	69 c0					.word	X16A_ym_loadpatch
>24f9	0a					.byte	X16_AudioCodeBank
.24fa	a2 ff		ldx #$ff		ldx	#$FF
.24fc	7a		ply			ply
.24fd	4c 29 10	jmp $1029			jmp 	NextCommand
.2500					X16_Audio_FMVIB:
.2500	fa		plx				plx
.2501	5a		phy			phy
.2502	20 d0 11	jsr $11d0		jsr		X16_Audio_Parameters8_8
.2505	18		clc			clc
.2506	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2509	09 c0					.word	X16A_bas_fmvib
>250b	0a					.byte	X16_AudioCodeBank
.250c	a2 ff		ldx #$ff		ldx	#$FF
.250e	7a		ply			ply
.250f	4c 29 10	jmp $1029			jmp 	NextCommand
.2512					X16_Audio_FMFREQ:
.2512	fa		plx				plx
.2513	5a		phy			phy
.2514	20 ca 11	jsr $11ca		jsr		X16_Audio_Parameters8_16
.2517	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>251a	00 c0					.word	X16A_bas_fmfreq
>251c	0a					.byte	X16_AudioCodeBank
.251d	a2 ff		ldx #$ff		ldx	#$FF
.251f	7a		ply			ply
.2520	4c 29 10	jmp $1029			jmp 	NextCommand
.2523					X16_Audio_FMVOL:
.2523	fa		plx				plx
.2524	5a		phy			phy
.2525	20 d0 11	jsr $11d0		jsr		X16_Audio_Parameters8_8
.2528	18		clc			clc
.2529	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>252c	75 c0					.word	X16A_ym_setatten
>252e	0a					.byte	X16_AudioCodeBank
.252f	a2 ff		ldx #$ff		ldx	#$FF
.2531	7a		ply			ply
.2532	4c 29 10	jmp $1029			jmp 	NextCommand
.2535					X16_Audio_FMPAN:
.2535	fa		plx				plx
.2536	5a		phy			phy
.2537	20 d0 11	jsr $11d0		jsr		X16_Audio_Parameters8_8
.253a	18		clc			clc
.253b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>253e	7e c0					.word	X16A_ym_setpan
>2540	0a					.byte	X16_AudioCodeBank
.2541	a2 ff		ldx #$ff		ldx	#$FF
.2543	7a		ply			ply
.2544	4c 29 10	jmp $1029			jmp 	NextCommand
.2547					X16_Audio_FMPLAY:
.2547	fa		plx				plx
.2548	5a		phy			phy
.2549	20 e1 11	jsr $11e1		jsr		X16_Audio_Parameters8_String
.254c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>254f	06 c0					.word	X16A_bas_fmplaystring
>2551	0a					.byte	X16_AudioCodeBank
.2552	a2 ff		ldx #$ff		ldx	#$FF
.2554	7a		ply			ply
.2555	4c 29 10	jmp $1029			jmp 	NextCommand
.2558					X16_Audio_FMCHORD:
.2558	fa		plx				plx
.2559	5a		phy			phy
.255a	20 e1 11	jsr $11e1		jsr		X16_Audio_Parameters8_String
.255d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2560	8d c0					.word	X16A_bas_fmchordstring
>2562	0a					.byte	X16_AudioCodeBank
.2563	a2 ff		ldx #$ff		ldx	#$FF
.2565	7a		ply			ply
.2566	4c 29 10	jmp $1029			jmp 	NextCommand
.2569					X16_Audio_FMPOKE:
.2569	fa		plx				plx
.256a	5a		phy			phy
.256b	20 d0 11	jsr $11d0		jsr		X16_Audio_Parameters8_8
.256e	18		clc			clc
.256f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2572	8a c0					.word	X16A_ym_write
>2574	0a					.byte	X16_AudioCodeBank
.2575	a2 ff		ldx #$ff		ldx	#$FF
.2577	7a		ply			ply
.2578	4c 29 10	jmp $1029			jmp 	NextCommand
.257b					X16_Audio_PSGINIT:
.257b	fa		plx				plx
.257c	5a		phy			phy
.257d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2580	4b c0					.word	X16A_psg_init
>2582	0a					.byte	X16_AudioCodeBank
.2583	a2 ff		ldx #$ff		ldx	#$FF
.2585	7a		ply			ply
.2586	4c 29 10	jmp $1029			jmp 	NextCommand
.2589					X16_Audio_PSGNOTE:
.2589	fa		plx				plx
.258a	5a		phy			phy
.258b	20 d0 11	jsr $11d0		jsr		X16_Audio_Parameters8_8
.258e	18		clc			clc
.258f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2592	12 c0					.word	X16A_bas_psgnote
>2594	0a					.byte	X16_AudioCodeBank
.2595	a2 ff		ldx #$ff		ldx	#$FF
.2597	7a		ply			ply
.2598	4c 29 10	jmp $1029			jmp 	NextCommand
.259b					X16_Audio_PSGVOL:
.259b	fa		plx				plx
.259c	5a		phy			phy
.259d	20 d0 11	jsr $11d0		jsr		X16_Audio_Parameters8_8
.25a0	18		clc			clc
.25a1	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>25a4	54 c0					.word	X16A_psg_setatten
>25a6	0a					.byte	X16_AudioCodeBank
.25a7	a2 ff		ldx #$ff		ldx	#$FF
.25a9	7a		ply			ply
.25aa	4c 29 10	jmp $1029			jmp 	NextCommand
.25ad					X16_Audio_PSGWAV:
.25ad	fa		plx				plx
.25ae	5a		phy			phy
.25af	20 d0 11	jsr $11d0		jsr		X16_Audio_Parameters8_8
.25b2	18		clc			clc
.25b3	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>25b6	15 c0					.word	X16A_bas_psgwav
>25b8	0a					.byte	X16_AudioCodeBank
.25b9	a2 ff		ldx #$ff		ldx	#$FF
.25bb	7a		ply			ply
.25bc	4c 29 10	jmp $1029			jmp 	NextCommand
.25bf					X16_Audio_PSGFREQ:
.25bf	fa		plx				plx
.25c0	5a		phy			phy
.25c1	20 ca 11	jsr $11ca		jsr		X16_Audio_Parameters8_16
.25c4	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>25c7	0f c0					.word	X16A_bas_psgfreq
>25c9	0a					.byte	X16_AudioCodeBank
.25ca	a2 ff		ldx #$ff		ldx	#$FF
.25cc	7a		ply			ply
.25cd	4c 29 10	jmp $1029			jmp 	NextCommand
.25d0					X16_Audio_PSGPAN:
.25d0	fa		plx				plx
.25d1	5a		phy			phy
.25d2	20 d0 11	jsr $11d0		jsr		X16_Audio_Parameters8_8
.25d5	18		clc			clc
.25d6	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>25d9	5a c0					.word	X16A_psg_setpan
>25db	0a					.byte	X16_AudioCodeBank
.25dc	a2 ff		ldx #$ff		ldx	#$FF
.25de	7a		ply			ply
.25df	4c 29 10	jmp $1029			jmp 	NextCommand
.25e2					X16_Audio_PSGPLAY:
.25e2	fa		plx				plx
.25e3	5a		phy			phy
.25e4	20 e1 11	jsr $11e1		jsr		X16_Audio_Parameters8_String
.25e7	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>25ea	18 c0					.word	X16A_bas_psgplaystring
>25ec	0a					.byte	X16_AudioCodeBank
.25ed	a2 ff		ldx #$ff		ldx	#$FF
.25ef	7a		ply			ply
.25f0	4c 29 10	jmp $1029			jmp 	NextCommand
.25f3					X16_Audio_PSGCHORD:
.25f3	fa		plx				plx
.25f4	5a		phy			phy
.25f5	20 e1 11	jsr $11e1		jsr		X16_Audio_Parameters8_String
.25f8	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>25fb	90 c0					.word	X16A_bas_psgchordstring
>25fd	0a					.byte	X16_AudioCodeBank
.25fe	a2 ff		ldx #$ff		ldx	#$FF
.2600	7a		ply			ply
.2601	4c 29 10	jmp $1029			jmp 	NextCommand
.2604					CommandCls:
.2604	fa		plx				plx
.2605	a9 93		lda #$93			lda 	#147
.2607	20 5b 24	jsr $245b			jsr 	XPrintCharacterToChannel
.260a	4c 29 10	jmp $1029			jmp 	NextCommand
.260d					CommandLocate:
.260d	fa		plx				plx
.260e	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.2611	ca		dex				dex
.2612	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.2615	ca		dex				dex
.2616	a9 13		lda #$13			lda 	#$13 						; home.
.2618	20 5b 24	jsr $245b			jsr 	XPrintCharacterToChannel
.261b	a9 1d		lda #$1d			lda 	#$1D 						; do cursor rights
.261d	a6 41		ldx $41				ldx 	NSMantissa0
.261f	20 2c 26	jsr $262c			jsr 	_CLOutputXA
.2622	a9 11		lda #$11			lda 	#$11 						; do cursor downs.
.2624	a6 42		ldx $42				ldx 	NSMantissa0+1
.2626	20 2c 26	jsr $262c			jsr 	_CLOutputXA
.2629	4c 29 10	jmp $1029			jmp 	NextCommand
.262c					_CLOutputXA:
.262c	ca		dex				dex
.262d	f0 07		beq $2636			beq 	_CLOExit
.262f	30 05		bmi $2636			bmi 	_CLOExit
.2631	20 5b 24	jsr $245b			jsr 	XPrintCharacterToChannel
.2634	80 f6		bra $262c			bra 	_CLOutputXA
.2636					_CLOExit:
.2636	60		rts				rts
.2637					CommandColor:
.2637	fa		plx				plx
.2638	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.263b	ca		dex				dex
.263c	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.263f	ca		dex				dex
.2640	a5 42		lda $42				lda 	NSMantissa0+1 				; bgr specified
.2642	c9 ff		cmp #$ff			cmp 	#$FF
.2644	f0 08		beq $264e			beq 	_CCNoBGR 					; if so, change background
.2646	20 56 26	jsr $2656			jsr 	_CCSetColour
.2649	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.264b	20 5b 24	jsr $245b			jsr 	XPrintCharacterToChannel
.264e					_CCNoBGR:
.264e	a5 41		lda $41				lda 	NSMantissa0
.2650	20 56 26	jsr $2656			jsr 	_CCSetColour
.2653	4c 29 10	jmp $1029			jmp 	NextCommand
.2656					_CCSetColour:
.2656	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.2658	aa		tax				tax
.2659	bd 60 26	lda $2660,x			lda 	_CCCommandTable,x
.265c	20 5b 24	jsr $245b			jsr 	XPrintCharacterToChannel
.265f	60		rts				rts
.2660					_CCCommandTable:
>2660	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>2668	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.2670					CommandVPOKE:
.2670	fa		plx				plx
.2671	20 0a 18	jsr $180a			jsr 	GetInteger8Bit 				; poke value
.2674	48		pha				pha
.2675	ca		dex				dex
.2676	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.2679	b5 41		lda $41,x			lda 	NSMantissa0,x
.267b	8d 20 9f	sta $9f20			sta 	VRAMLow0
.267e	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.2680	8d 21 9f	sta $9f21			sta 	VRAMMed0
.2683	ca		dex				dex
.2684	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.2687	20 0a 18	jsr $180a			jsr 	GetInteger8Bit
.268a	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.268d	ca		dex				dex
.268e	68		pla				pla 								; poke value back
.268f	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.2692	4c 29 10	jmp $1029			jmp 	NextCommand
.2695					CommandVPEEK:
.2695	fa		plx				plx
.2696	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.2699	b5 41		lda $41,x			lda 	NSMantissa0,x
.269b	8d 20 9f	sta $9f20			sta 	VRAMLow0
.269e	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.26a0	8d 21 9f	sta $9f21			sta 	VRAMMed0
.26a3	ca		dex				dex
.26a4	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.26a7	20 0a 18	jsr $180a			jsr 	GetInteger8Bit
.26aa	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.26ad	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.26b0	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte 				; return as byte
.26b3	4c 29 10	jmp $1029			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					codePage:
>002a							.fill 	1
.002b					objPtr:
>002b							.fill 	2 							; bytes must not change (it could expand) as the
.002d					objPage:
>002d							.fill 	1
.002e					objIncrement:
>002e							.fill 	1
.002f					zTemp0:
>002f							.fill 	2
.0031					zTemp1:
>0031							.fill 	2
.0033					zTemp2:
>0033							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.26b6					ErrorV_range:
.26b6	20 1e 14	jsr $141e		jsr	ErrorHandler
>26b9	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>26c1	41 4e 47 45 00
.26c6					ErrorV_value:
.26c6	20 1e 14	jsr $141e		jsr	ErrorHandler
>26c9	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>26d1	45 00
.26d3					ErrorV_syntax:
.26d3	20 1e 14	jsr $141e		jsr	ErrorHandler
>26d6	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>26de	52 52 4f 52 00
.26e3					ErrorV_type:
.26e3	20 1e 14	jsr $141e		jsr	ErrorHandler
>26e6	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>26ee	4d 41 54 43 48 00
.26f4					ErrorV_unimplemented:
.26f4	20 1e 14	jsr $141e		jsr	ErrorHandler
>26f7	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>26ff	45 4d 45 4e 54 45 44 00
.2707					ErrorV_assert:
.2707	20 1e 14	jsr $141e		jsr	ErrorHandler
>270a	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>2712	41 49 4c 00
.2716					ErrorV_line:
.2716	20 1e 14	jsr $141e		jsr	ErrorHandler
>2719	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>2721	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.272d					ErrorV_internal:
.272d	20 1e 14	jsr $141e		jsr	ErrorHandler
>2730	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>2738	20 45 52 52 4f 52 00
.273f					ErrorV_divzero:
.273f	20 1e 14	jsr $141e		jsr	ErrorHandler
>2742	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>274a	59 20 5a 45 52 4f 00
.2751					ErrorV_structure:
.2751	20 1e 14	jsr $141e		jsr	ErrorHandler
>2754	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>275c	45 20 49 4d 42 41 4c 41 4e 43 45 00
.2768					ErrorV_stop:
.2768	20 1e 14	jsr $141e		jsr	ErrorHandler
>276b	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>2773	53 54 4f 50 50 45 44 00
.277b					ErrorV_data:
.277b	20 1e 14	jsr $141e		jsr	ErrorHandler
>277e	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>2786	41 54 41 00
.278a					ErrorV_undeclared:
.278a	20 1e 14	jsr $141e		jsr	ErrorHandler
>278d	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>2795	41 52 52 41 59 00
.279b					ErrorV_redefine:
.279b	20 1e 14	jsr $141e		jsr	ErrorHandler
>279e	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>27a6	44 45 46 49 4e 45 44 00
.27ae					ErrorV_index:
.27ae	20 1e 14	jsr $141e		jsr	ErrorHandler
>27b1	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>27b9	59 20 49 4e 44 45 58 00
.27c1					ErrorV_memory:
.27c1	20 1e 14	jsr $141e		jsr	ErrorHandler
>27c4	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>27cc	45 4d 4f 52 59 00
.27d2					ErrorV_channel:
.27d2	20 1e 14	jsr $141e		jsr	ErrorHandler
>27d5	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>27dd	54 50 55 54 20 45 52 52 4f 52 00
.27e8					MoveObjectForward:
.27e8	b2 2b		lda ($2b)			lda 	(objPtr) 					; get next
.27ea	c9 ff		cmp #$ff			cmp 	#$FF
.27ec	f0 36		beq $2824			beq 	_MOFEnd
.27ee	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.27f0	90 24		bcc $2816			bcc 	_MOFAdvance1 				; forward 1
.27f2	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.27f4	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.27f6	90 20		bcc $2818			bcc 	_MOFAdvanceY
.27f8	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.27fa	90 1a		bcc $2816			bcc 	_MOFAdvance1 				; forward 1
.27fc	a8		tay				tay 								; read the size.
.27fd	b9 62 27	lda $2762,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.2800	a8		tay				tay
.2801	c8		iny				iny 								; add 1 for the system token.
.2802	d0 14		bne $2818			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2804	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2806	b1 2b		lda ($2b),y			lda 	(objPtr),y
.2808	a8		tay				tay 								; into Y.
.2809	18		clc				clc
.280a	a5 2b		lda $2b				lda 	objPtr						; add 2 to the object pointer
.280c	69 02		adc #$02			adc 	#2
.280e	85 2b		sta $2b				sta 	objPtr
.2810	90 02		bcc $2814			bcc 	_MOFNoCarry1
.2812	e6 2c		inc $2c				inc 	objPtr+1
.2814					_MOFNoCarry1:
.2814	80 02		bra $2818			bra 	_MOFAdvanceY
.2816					_MOFAdvance1:
.2816	a0 01		ldy #$01			ldy 	#1
.2818					_MOFAdvanceY:
.2818	98		tya				tya 								; add Y to objPtr
.2819	18		clc				clc
.281a	65 2b		adc $2b				adc 	objPtr
.281c	85 2b		sta $2b				sta 	objPtr
.281e	90 02		bcc $2822			bcc 	_MOFNoCarry2
.2820	e6 2c		inc $2c				inc 	objPtr+1
.2822					_MOFNoCarry2:
.2822	18		clc				clc 								; not completed.
.2823	60		rts				rts
.2824					_MOFEnd:
.2824	e6 2b		inc $2b				inc 	objPtr
.2826	d0 02		bne $282a			bne 	_MOFENoCarry
.2828	e6 2c		inc $2c				inc 	objPtr+1
.282a					_MOFENoCarry:
.282a	38		sec				sec
.282b	60		rts				rts
.282c					MOFSizeTable:
>282c	01					.byte	1         	; $ca .shift
>282d	01					.byte	1         	; $cb .byte
>282e	02					.byte	2         	; $cc .word
>282f	05					.byte	5         	; $cd .float
>2830	ff					.byte	255       	; $ce .string
>2831	ff					.byte	255       	; $cf .data
>2832	03					.byte	3         	; $d0 .goto
>2833	03					.byte	3         	; $d1 .gosub
>2834	03					.byte	3         	; $d2 .goto.z
>2835	03					.byte	3         	; $d3 .goto.nz
>2836	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0035					NSStatus:
>0035							.fill 	MathStackSize
.0041					NSMantissa0:
>0041							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004d					NSMantissa1:
>004d							.fill 	MathStackSize
.0059					NSMantissa2:
>0059							.fill 	MathStackSize
.0065					NSMantissa3:
>0065							.fill 	MathStackSize
.0071					NSExponent:
>0071							.fill 	MathStackSize
.056d					numberBuffer:
>056d							.fill 	34
.2837					FloatSubtract:
.2837	b5 35		lda $35,x			lda 	NSStatus,x 					; negate top of stack
.2839	49 80		eor #$80			eor 	#$80
.283b	95 35		sta $35,x			sta 	NSStatus,x					; and fall through.
.283d					FloatAdd:
.283d	ca		dex				dex
.283e	b5 71		lda $71,x			lda 	NSExponent,x 				; can use optimised.
.2840	15 72		ora $72,x			ora 	NSExponent+1,x
.2842	15 65		ora $65,x			ora 	NSMantissa3,x
.2844	15 66		ora $66,x			ora 	NSMantissa3+1,x
.2846	d0 04		bne $284c			bne 	_FAUseFloat
.2848	20 d9 2b	jsr $2bd9			jsr 	FloatInt32Add 				; use the int32 one.
.284b	60		rts				rts
.284c					_FAUseFloat:
.284c	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise 				; normalise S[X]
.284f	f0 51		beq $28a2			beq 	_FAReturn1
.2851	e8		inx				inx 								; normalise S[X+1]
.2852	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise
.2855	ca		dex				dex
.2856	c9 00		cmp #$00			cmp 	#0
.2858	f0 60		beq $28ba			beq 	_FAExit 					; if so, just return A
.285a	b5 71		lda $71,x			lda 	NSExponent,x 				; are the exponents the same ?
.285c	d5 72		cmp $72,x			cmp 	NSExponent+1,x
.285e	f0 18		beq $2878			beq 	_FAExponentsEqual
.2860	b5 71		lda $71,x			lda 	NSExponent,x 				; work out the larger exponent
.2862	a8		tay				tay
.2863	38		sec				sec 								; do a signed comparison of the exponents.
.2864	f5 72		sbc $72,x			sbc 	NSExponent+1,x
.2866	50 02		bvc $286a			bvc 	_FANoSignedChange
.2868	49 80		eor #$80			eor 	#$80
.286a					_FANoSignedChange:
.286a	29 80		and #$80			and 	#$80
.286c	10 02		bpl $2870			bpl 	_FAHaveMax
.286e	b4 72		ldy $72,x			ldy 	NSExponent+1,x
.2870					_FAHaveMax:
.2870	20 bb 28	jsr $28bb			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.2873	e8		inx				inx
.2874	20 bb 28	jsr $28bb			jsr 	_FAShiftToExponent
.2877	ca		dex				dex
.2878					_FAExponentsEqual:
.2878	b5 35		lda $35,x			lda 	NSStatus,x 					; are the signs the same
.287a	55 36		eor $36,x			eor 	NSStatus+1,x
.287c	30 0e		bmi $288c			bmi 	_FADifferentSigns
.287e	20 a5 2b	jsr $2ba5			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.2881	b5 65		lda $65,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.2883	10 35		bpl $28ba			bpl 	_FAExit 					; if no, we are done.
.2885	20 32 2e	jsr $2e32			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.2888	f6 71		inc $71,x			inc 	NSExponent,x 				; bump the exponent and exit
.288a	80 2e		bra $28ba			bra 	_FAExit
.288c					_FADifferentSigns:
.288c	20 bf 2b	jsr $2bbf			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.288f	b5 65		lda $65,x			lda 	NSMantissa3,x 				; is the result negative ?
.2891	10 06		bpl $2899			bpl 	_FACheckZero 				; if no, check for -0
.2893	20 db 2d	jsr $2ddb			jsr 	FloatNegate 					; netate result
.2896	20 e2 2d	jsr $2de2			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.2899					_FACheckZero:
.2899	20 3b 2e	jsr $2e3b			jsr 	FloatIsZero	 				; check for -0
.289c	d0 1c		bne $28ba			bne 	_FAExit
.289e	74 35		stz $35,x			stz 	NSStatus,x
.28a0	80 18		bra $28ba			bra 	_FAExit
.28a2					_FAReturn1:
.28a2	b5 42		lda $42,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.28a4	95 41		sta $41,x			sta 	NSMantissa0,x
.28a6	b5 4e		lda $4e,x			lda 	NSMantissa1+1,x
.28a8	95 4d		sta $4d,x			sta 	NSMantissa1,x
.28aa	b5 5a		lda $5a,x			lda 	NSMantissa2+1,x
.28ac	95 59		sta $59,x			sta 	NSMantissa2,x
.28ae	b5 66		lda $66,x			lda 	NSMantissa3+1,x
.28b0	95 65		sta $65,x			sta 	NSMantissa3,x
.28b2	b5 72		lda $72,x			lda 	NSExponent+1,x
.28b4	95 71		sta $71,x			sta 	NSExponent,x
.28b6	b5 36		lda $36,x			lda 	NSStatus+1,x
.28b8	95 35		sta $35,x			sta 	NSStatus,x
.28ba					_FAExit:
.28ba	60		rts				rts
.28bb					_FAShiftToExponent:
.28bb					_FAShiftToExponent2:
.28bb	98		tya				tya 								; compare Y to exponent
.28bc	d5 71		cmp $71,x			cmp 	NSExponent,x 				; reached the exponent required ?
.28be	f0 07		beq $28c7			beq 	_FASEExit 					; exit if so.
.28c0	20 32 2e	jsr $2e32			jsr 	FloatShiftRight	 			; shift the mantissa right
.28c3	f6 71		inc $71,x			inc 	NSExponent,x 				; increment exponent
.28c5	80 f4		bra $28bb			bra 	_FAShiftToExponent2
.28c7					_FASEExit:
.28c7	60		rts				rts
.28c8					CompareEqual:
.28c8	b5 41		lda $41,x			lda 	NSMantissa0,x
.28ca	d0 09		bne $28d5			bne 	ReturnFalse
.28cc					ReturnTrue:
.28cc	a9 01		lda #$01			lda 	#1
.28ce	95 41		sta $41,x			sta 	NSMantissa0,x
.28d0	a9 80		lda #$80			lda 	#$80
.28d2	95 35		sta $35,x			sta 	NSStatus,x
.28d4	60		rts				rts
.28d5					ReturnFalse:
.28d5	74 41		stz $41,x			stz 	NSMantissa0,x
.28d7	60		rts				rts
.28d8					CompareNotEqual:
.28d8	b5 41		lda $41,x			lda 	NSMantissa0,x
.28da	d0 f0		bne $28cc			bne 	ReturnTrue
.28dc	80 f7		bra $28d5			bra 	ReturnFalse
.28de					CompareLess:
.28de	b5 41		lda $41,x			lda 	NSMantissa0,x
.28e0	c9 ff		cmp #$ff			cmp 	#$FF
.28e2	f0 e8		beq $28cc			beq 	ReturnTrue
.28e4	80 ef		bra $28d5			bra 	ReturnFalse
.28e6					CompareGreater:
.28e6	b5 41		lda $41,x			lda 	NSMantissa0,x
.28e8	c9 01		cmp #$01			cmp 	#$01
.28ea	f0 e0		beq $28cc			beq 	ReturnTrue
.28ec	80 e7		bra $28d5			bra 	ReturnFalse
.28ee					CompareLessEqual:
.28ee	b5 41		lda $41,x			lda 	NSMantissa0,x
.28f0	c9 01		cmp #$01			cmp 	#$01
.28f2	d0 d8		bne $28cc			bne 	ReturnTrue
.28f4	80 df		bra $28d5			bra 	ReturnFalse
.28f6					CompareGreaterEqual:
.28f6	b5 41		lda $41,x			lda 	NSMantissa0,x
.28f8	c9 ff		cmp #$ff			cmp 	#$FF
.28fa	d0 d0		bne $28cc			bne 	ReturnTrue
.28fc	80 d7		bra $28d5			bra 	ReturnFalse
.28fe					FloatCompare:
.28fe	b5 71		lda $71,x			lda 	NSExponent,x 				; float comparison.
.2900	15 70		ora $70,x			ora 	NSExponent-1,x 				; integer if both integer.
.2902	48		pha				pha
.2903	20 37 28	jsr $2837			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2906	68		pla				pla
.2907	d0 0c		bne $2915			bne 	_FCCompareFloat
.2909	b5 41		lda $41,x			lda 	NSMantissa0,x
.290b	15 4d		ora $4d,x			ora 	NSMantissa1,x
.290d	15 59		ora $59,x			ora 	NSMantissa2,x
.290f	15 65		ora $65,x			ora 	NSMantissa3,x
.2911	f0 14		beq $2927			beq 	_FCExit 					; if zero, return zero
.2913	80 0a		bra $291f			bra 	_FCSign
.2915					_FCCompareFloat:
.2915	b5 4d		lda $4d,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2917	29 f0		and #$f0			and 	#$F0
.2919	15 59		ora $59,x			ora 	NSMantissa2,x
.291b	15 65		ora $65,x			ora 	NSMantissa3,x
.291d	f0 08		beq $2927			beq 	_FCExit 					; zero, so approximately identical
.291f					_FCSign:
.291f	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2921	34 35		bit $35,x			bit 	NSStatus,x
.2923	10 02		bpl $2927			bpl 	_FCExit
.2925					_FCNegative:
.2925	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2927					_FCExit:
.2927	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte 				; set the result 255,0,1
.292a	60		rts				rts
.292b					FloatScalarTable:
>292b	66 66 66 66				.dword $66666666 ; 0.1
>292f	de					.byte $de
>2930	1f 85 eb 51				.dword $51eb851f ; 0.01
>2934	db					.byte $db
>2935	4c 37 89 41				.dword $4189374c ; 0.001
>2939	d8					.byte $d8
>293a	ac 8b db 68				.dword $68db8bac ; 0.0001
>293e	d4					.byte $d4
>293f	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>2943	d1					.byte $d1
>2944	83 de 1b 43				.dword $431bde83 ; 1e-06
>2948	ce					.byte $ce
>2949	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>294d	ca					.byte $ca
>294e	89 3b e6 55				.dword $55e63b89 ; 1e-08
>2952	c7					.byte $c7
>2953	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>2957	c4					.byte $c4
>2958	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>295c	c0					.byte $c0
>295d	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>2961	bd					.byte $bd
.2962					FloatDivide:
.2962	48		pha				pha
.2963	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2966	ca		dex				dex
.2967	c9 00		cmp #$00			cmp 	#0
.2969	f0 1e		beq $2989			beq 	_FDZero
.296b	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.296e	f0 16		beq $2986			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.2970	20 d1 29	jsr $29d1			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.2973	20 9e 29	jsr $299e			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.2976	20 6e 2b	jsr $2b6e			jsr		FloatNormalise 				; renormalise
.2979	20 64 2b	jsr $2b64			jsr 	FloatCalculateSign 			; calculate result sign
.297c	b5 71		lda $71,x			lda 	NSExponent,x 				; calculate exponent
.297e	38		sec				sec
.297f	f5 72		sbc $72,x			sbc 	NSExponent+1,x
.2981	38		sec				sec
.2982	e9 1e		sbc #$1e			sbc 	#30
.2984	95 71		sta $71,x			sta 	NSExponent,x
.2986					_FDExit:
.2986	68		pla				pla
.2987	18		clc				clc
.2988	60		rts				rts
.2989					_FDZero:
.2989	68		pla				pla
.298a	38		sec				sec
.298b	60		rts				rts
.298c					DivideInt32:
.298c	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart 			; make both integers
.298f	ca		dex				dex
.2990	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.2993	20 af 29	jsr $29af			jsr 	Int32Divide 				; divide
.2996	20 9e 29	jsr $299e			jsr 	NSMCopyPlusTwoToZero 		; copy result
.2999	20 64 2b	jsr $2b64			jsr 	FloatCalculateSign 			; calculate result sign
.299c	18		clc				clc
.299d	60		rts				rts
.299e					NSMCopyPlusTwoToZero:
.299e	b5 43		lda $43,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.29a0	95 41		sta $41,x			sta 	NSMantissa0,x
.29a2	b5 4f		lda $4f,x			lda 	NSMantissa1+2,x
.29a4	95 4d		sta $4d,x			sta 	NSMantissa1,x
.29a6	b5 5b		lda $5b,x			lda 	NSMantissa2+2,x
.29a8	95 59		sta $59,x			sta 	NSMantissa2,x
.29aa	b5 67		lda $67,x			lda 	NSMantissa3+2,x
.29ac	95 65		sta $65,x			sta 	NSMantissa3,x
.29ae	60		rts				rts
.29af					Int32Divide:
.29af	48		pha				pha 								; save AXY
.29b0	5a		phy				phy
.29b1	20 fc 2d	jsr $2dfc			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.29b4	20 15 2e	jsr $2e15			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.29b7	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.29b9					_I32DivideLoop:
.29b9	e8		inx				inx
.29ba	e8		inx				inx
.29bb	20 28 2e	jsr $2e28			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.29be	ca		dex				dex
.29bf	ca		dex				dex
.29c0	20 29 2e	jsr $2e29			jsr 	FloatRotateLeft
.29c3	20 ef 29	jsr $29ef			jsr 	FloatDivideCheck 			; check if subtract possible
.29c6	90 02		bcc $29ca			bcc 	_I32DivideNoCarryIn
.29c8	f6 43		inc $43,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.29ca					_I32DivideNoCarryIn:
.29ca	88		dey				dey 								; loop round till division completed.
.29cb	d0 ec		bne $29b9			bne 	_I32DivideLoop
.29cd	7a		ply				ply 								; restore AXY and exit
.29ce	68		pla				pla
.29cf	18		clc				clc
.29d0	60		rts				rts
.29d1					Int32ShiftDivide:
.29d1	48		pha				pha 								; save AY
.29d2	5a		phy				phy
.29d3	e8		inx				inx 								; clear S[X+2]
.29d4	e8		inx				inx
.29d5	20 19 2e	jsr $2e19			jsr 	FloatSetZero
.29d8	ca		dex				dex
.29d9	ca		dex				dex
.29da	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.29dc					_I32SDLoop:
.29dc	20 ef 29	jsr $29ef			jsr 	FloatDivideCheck 			; check if subtract possible
.29df	e8		inx				inx
.29e0	e8		inx				inx
.29e1	20 29 2e	jsr $2e29			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.29e4	ca		dex				dex
.29e5	ca		dex				dex
.29e6	20 29 2e	jsr $2e29			jsr 	FloatRotateLeft
.29e9	88		dey				dey 	 							; do 31 times
.29ea	d0 f0		bne $29dc			bne 	_I32SDLoop
.29ec	7a		ply				ply 								; restore AY and exit
.29ed	68		pla				pla
.29ee	60		rts				rts
.29ef					FloatDivideCheck:
.29ef	20 bf 2b	jsr $2bbf			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.29f2	b0 04		bcs $29f8			bcs 	_DCSExit 					; if carry set, then could do, exit
.29f4	20 a5 2b	jsr $2ba5			jsr 	FloatAddTopTwoStack 		; add it back in
.29f7	18		clc				clc 								; and return False
.29f8					_DCSExit:
.29f8	60		rts				rts
.29f9					FloatFractionalPart:
.29f9	5a		phy				phy
.29fa	b5 35		lda $35,x			lda 	NSStatus,x 					; take absolute value
.29fc	29 7f		and #$7f			and 	#$7F
.29fe	95 35		sta $35,x			sta 	NSStatus,x
.2a00	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise
.2a03	b5 71		lda $71,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2a05	38		sec				sec
.2a06	e9 e0		sbc #$e0			sbc 	#$E0
.2a08	90 29		bcc $2a33			bcc 	_FFPExit 					; already fractional
.2a0a	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2a0c	b0 22		bcs $2a30			bcs 	_FFPZero
.2a0e	a8		tay				tay 								; put count to do in Y
.2a0f	b5 65		lda $65,x			lda 	NSMantissa3,x 				; do each in turn.
.2a11	20 38 2a	jsr $2a38			jsr 	_FFPPartial
.2a14	95 65		sta $65,x			sta 	NSMantissa3,x
.2a16	b5 59		lda $59,x			lda 	NSMantissa2,x
.2a18	20 38 2a	jsr $2a38			jsr 	_FFPPartial
.2a1b	95 59		sta $59,x			sta 	NSMantissa2,x
.2a1d	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.2a1f	20 38 2a	jsr $2a38			jsr 	_FFPPartial
.2a22	95 4d		sta $4d,x			sta 	NSMantissa1,x
.2a24	b5 41		lda $41,x			lda 	NSMantissa0,x
.2a26	20 38 2a	jsr $2a38			jsr 	_FFPPartial
.2a29	95 41		sta $41,x			sta 	NSMantissa0,x
.2a2b	20 3b 2e	jsr $2e3b			jsr 	FloatIsZero 					; zeroed check.
.2a2e	d0 03		bne $2a33			bne 	_FFPExit
.2a30					_FFPZero:
.2a30	20 19 2e	jsr $2e19			jsr 	FloatSetZero
.2a33					_FFPExit:
.2a33	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise
.2a36	7a		ply				ply
.2a37	60		rts				rts
.2a38					_FFPPartial:
.2a38	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2a3a	f0 17		beq $2a53			beq 	_FFFPPExit
.2a3c	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.2a3e	b0 0c		bcs $2a4c			bcs 	_FFFPPWholeByte
.2a40	5a		phy				phy
.2a41					_FFFPPLeft:
.2a41	0a		asl a				asl 	a
.2a42	88		dey				dey
.2a43	d0 fc		bne $2a41			bne 	_FFFPPLeft
.2a45	7a		ply				ply
.2a46					_FFFPPRight:
.2a46	4a		lsr a				lsr 	a
.2a47	88		dey				dey
.2a48	d0 fc		bne $2a46			bne 	_FFFPPRight
.2a4a	80 07		bra $2a53			bra 	_FFFPPExit
.2a4c					_FFFPPWholeByte:
.2a4c	98		tya				tya 								; subtract 8 from count
.2a4d	38		sec				sec
.2a4e	e9 08		sbc #$08			sbc 	#8
.2a50	a8		tay				tay
.2a51	a9 00		lda #$00			lda 	#0 							; and clear all
.2a53					_FFFPPExit:
.2a53	60		rts				rts
.2a54					FloatIntegerPart:
.2a54	48		pha				pha
.2a55	b5 71		lda $71,x			lda 	NSExponent,x 				; is it integer already ?
.2a57	f0 1d		beq $2a76			beq 	_FIPExit 					; if so do nothing
.2a59	20 3b 2e	jsr $2e3b			jsr 	FloatIsZero 				; is it zero ?
.2a5c	f0 15		beq $2a73			beq 	_FIPZero 					; if so return zero.
.2a5e	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise 				; normalise
.2a61	f0 10		beq $2a73			beq 	_FIPZero 					; normalised to zero, exit zero
.2a63					_FIPShift:
.2a63	b5 71		lda $71,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2a65	10 07		bpl $2a6e			bpl 	_FIPCheckZero
.2a67	20 32 2e	jsr $2e32			jsr 	FloatShiftRight 			; shift mantissa right
.2a6a	f6 71		inc $71,x			inc 	NSExponent,x 				; bump exponent
.2a6c	80 f5		bra $2a63			bra 	_FIPShift
.2a6e					_FIPCheckZero:
.2a6e	20 3b 2e	jsr $2e3b			jsr 	FloatIsZero 				; avoid -0 problem
.2a71	d0 03		bne $2a76			bne 	_FIPExit 					; set to zero if mantissa zero.
.2a73					_FIPZero:
.2a73	20 19 2e	jsr $2e19			jsr 	FloatSetZero
.2a76					_FIPExit:
.2a76	68		pla				pla
.2a77	60		rts				rts
.2a78					FloatIntegerPartDown:
.2a78	48		pha				pha
.2a79	5a		phy				phy
.2a7a	b5 71		lda $71,x			lda 	NSExponent,x 				; is it integer already ?
.2a7c	f0 36		beq $2ab4			beq 	_FIPExit 					; if so do nothing
.2a7e	20 3b 2e	jsr $2e3b			jsr 	FloatIsZero 				; is it zero ?
.2a81	f0 2e		beq $2ab1			beq 	_FIPZero 					; if so return zero.
.2a83	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise 				; normalise
.2a86	f0 29		beq $2ab1			beq 	_FIPZero 					; normalised to zero, exit zero
.2a88	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.2a8a					_FIPShift:
.2a8a	b5 71		lda $71,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2a8c	10 0a		bpl $2a98			bpl 	_FIPCheckDown
.2a8e	20 32 2e	jsr $2e32			jsr 	FloatShiftRight 			; shift mantissa right
.2a91	90 01		bcc $2a94			bcc 	_FIPNoFrac 					; shifted a zero out ?
.2a93	c8		iny				iny
.2a94					_FIPNoFrac:
.2a94	f6 71		inc $71,x			inc 	NSExponent,x 				; bump exponent
.2a96	80 f2		bra $2a8a			bra 	_FIPShift
.2a98					_FIPCheckDown:
.2a98	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.2a9a	f0 10		beq $2aac			beq 	_FIPCheckZero
.2a9c	34 35		bit $35,x			bit 	NSStatus,x 					; +ve
.2a9e	10 0c		bpl $2aac			bpl 	_FIPCheckZero
.2aa0	e8		inx				inx 								; -ve so round *down*.
.2aa1	a9 01		lda #$01			lda 	#1
.2aa3	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.2aa6	20 db 2d	jsr $2ddb			jsr 	FloatNegate
.2aa9	20 3d 28	jsr $283d			jsr 	FloatAdd
.2aac					_FIPCheckZero:
.2aac	20 3b 2e	jsr $2e3b			jsr 	FloatIsZero 				; avoid -0 problem
.2aaf	d0 03		bne $2ab4			bne 	_FIPExit 					; set to zero if mantissa zero.
.2ab1					_FIPZero:
.2ab1	20 19 2e	jsr $2e19			jsr 	FloatSetZero
.2ab4					_FIPExit:
.2ab4	7a		ply				ply
.2ab5	68		pla				pla
.2ab6	60		rts				rts
.2ab7					FloatInt8Multiply:
.2ab7	5a		phy				phy
.2ab8	b5 41		lda $41,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2aba	a8		tay				tay
.2abb	74 41		stz $41,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2abd					_FI8MLoop:
.2abd	98		tya				tya 								; shift right shifter right into carry
.2abe	4a		lsr a				lsr 	a
.2abf	a8		tay				tay
.2ac0	90 0d		bcc $2acf			bcc 	_FI8MNoAdd
.2ac2	18		clc				clc
.2ac3	b5 41		lda $41,x			lda 	NSMantissa0,x
.2ac5	75 42		adc $42,x			adc 	NSMantissa0+1,x
.2ac7	95 41		sta $41,x			sta 	NSMantissa0,x
.2ac9	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.2acb	75 4e		adc $4e,x			adc 	NSMantissa1+1,x
.2acd	95 4d		sta $4d,x			sta 	NSMantissa1,x
.2acf					_FI8MNoAdd:
.2acf	16 42		asl $42,x			asl 	NSMantissa0+1,x 			; shift adder left
.2ad1	36 4e		rol $4e,x			rol 	NSMantissa1+1,x
.2ad3	c0 00		cpy #$00			cpy 	#0
.2ad5	d0 e6		bne $2abd			bne 	_FI8MLoop 					; until right shifter zero.
.2ad7	7a		ply				ply
.2ad8	60		rts				rts
.2ad9					FloatMultiply:
.2ad9	ca		dex				dex
.2ada	b5 71		lda $71,x			lda 	NSExponent,x 				; can use optimised ?
.2adc	15 72		ora $72,x			ora 	NSExponent+1,x
.2ade	15 65		ora $65,x			ora 	NSMantissa3,x
.2ae0	15 66		ora $66,x			ora 	NSMantissa3+1,x
.2ae2	d0 21		bne $2b05			bne 	_FMUseFloat
.2ae4	b5 35		lda $35,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2ae6	15 36		ora $36,x			ora 	NSStatus+1,x
.2ae8	29 80		and #$80			and 	#$80
.2aea	15 65		ora $65,x			ora 	NSMantissa3,x
.2aec	15 59		ora $59,x			ora 	NSMantissa2,x
.2aee	15 4d		ora $4d,x			ora 	NSMantissa1,x
.2af0	15 66		ora $66,x			ora 	NSMantissa3+1,x
.2af2	15 5a		ora $5a,x			ora 	NSMantissa2+1,x
.2af4	15 4e		ora $4e,x			ora 	NSMantissa1+1,x
.2af6	d0 04		bne $2afc			bne 	_FMInt32
.2af8	20 b7 2a	jsr $2ab7			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2afb	60		rts				rts
.2afc					_FMInt32:
.2afc	20 26 2b	jsr $2b26			jsr 	FloatMultiplyShort			; use the int32 one.
.2aff	18		clc				clc 								; fix it up if gone out of range
.2b00	75 71		adc $71,x			adc 	NSExponent,x
.2b02	95 71		sta $71,x			sta 	NSExponent,x
.2b04	60		rts				rts
.2b05					_FMUseFloat:
.2b05	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2b08	f0 18		beq $2b22			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2b0a	e8		inx				inx
.2b0b	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2b0e	ca		dex				dex
.2b0f	c9 00		cmp #$00			cmp 	#0
.2b11	f0 0c		beq $2b1f			beq 	_FDSetZero
.2b13	20 26 2b	jsr $2b26			jsr 	FloatMultiplyShort 			; calculate the result.
.2b16	75 71		adc $71,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2b18	18		clc				clc
.2b19	75 72		adc $72,x			adc 	NSExponent+1,x
.2b1b	95 71		sta $71,x			sta 	NSExponent,x
.2b1d	80 03		bra $2b22			bra 	_FDExit
.2b1f					_FDSetZero:
.2b1f	20 19 2e	jsr $2e19			jsr 	FloatSetZero 				; return 0
.2b22					_FDExit:
.2b22	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise 				; normalise the result
.2b25	60		rts				rts
.2b26					FloatMultiplyShort:
.2b26	5a		phy				phy 								; save Y
.2b27	20 fc 2d	jsr $2dfc			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2b2a	20 15 2e	jsr $2e15			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2b2d	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2b2f					_I32MLoop:
.2b2f	b5 43		lda $43,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2b31	15 4f		ora $4f,x			ora 	NSMantissa1+2,x
.2b33	15 5b		ora $5b,x			ora 	NSMantissa2+2,x
.2b35	15 67		ora $67,x			ora 	NSMantissa3+2,x
.2b37	f0 25		beq $2b5e			beq 	_I32MExit 					; exit if zero
.2b39	b5 43		lda $43,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2b3b	29 01		and #$01			and 	#1
.2b3d	f0 0d		beq $2b4c			beq 	_I32MNoAdd
.2b3f	20 a5 2b	jsr $2ba5			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.2b42	b5 65		lda $65,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.2b44	10 06		bpl $2b4c			bpl 	_I32MNoAdd
.2b46					_I32ShiftRight:
.2b46	20 32 2e	jsr $2e32			jsr 	FloatShiftRight 			; shift S[X] right
.2b49	c8		iny				iny 								; increment shift count
.2b4a	80 09		bra $2b55			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.2b4c					_I32MNoAdd:
.2b4c	34 66		bit $66,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.2b4e	70 f6		bvs $2b46			bvs 	_I32ShiftRight 				; instead.
.2b50	e8		inx				inx
.2b51	20 28 2e	jsr $2e28			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.2b54	ca		dex				dex
.2b55					_I32MShiftUpper:
.2b55	e8		inx				inx 								; shift S[X+2] right
.2b56	e8		inx				inx
.2b57	20 32 2e	jsr $2e32			jsr 	FloatShiftRight
.2b5a	ca		dex				dex
.2b5b	ca		dex				dex
.2b5c	80 d1		bra $2b2f			bra 	_I32MLoop 					; try again.
.2b5e					_I32MExit:
.2b5e	20 64 2b	jsr $2b64			jsr 	FloatCalculateSign
.2b61	98		tya				tya 								; shift in A
.2b62	7a		ply				ply 								; restore Y and exit
.2b63	60		rts				rts
.2b64					FloatCalculateSign:
.2b64	b5 35		lda $35,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.2b66	16 35		asl $35,x			asl 	NSStatus,x 					; shift result left
.2b68	55 36		eor $36,x			eor 	NSStatus+1,x
.2b6a	0a		asl a				asl 	a 							; shift bit 7 into carry
.2b6b	76 35		ror $35,x			ror 	NSStatus,x 					; shift right into status byte.
.2b6d	60		rts				rts
.2b6e					FloatNormalise:
.2b6e	20 3b 2e	jsr $2e3b			jsr 	FloatIsZero 				; if zero exit
.2b71	d0 07		bne $2b7a			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.2b73	16 35		asl $35,x			asl 	NSStatus,x 					; clear the sign bit.
.2b75	76 35		ror $35,x			ror 	NSStatus,x 					; (no -0)
.2b77	a9 00		lda #$00			lda 	#0 							; set Z flag
.2b79	60		rts				rts
.2b7a					_NSNormaliseOptimise:
.2b7a	b5 65		lda $65,x			lda 	NSMantissa3,x 				; upper byte zero ?
.2b7c	d0 19		bne $2b97			bne 	_NSNormaliseLoop
.2b7e	b5 59		lda $59,x			lda 	NSMantissa2,x 				; byte normalise
.2b80	30 15		bmi $2b97			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.2b82	95 65		sta $65,x			sta 	NSMantissa3,x
.2b84	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.2b86	95 59		sta $59,x			sta 	NSMantissa2,x
.2b88	b5 41		lda $41,x			lda 	NSMantissa0,x
.2b8a	95 4d		sta $4d,x			sta 	NSMantissa1,x
.2b8c	74 41		stz $41,x			stz 	NSMantissa0,x
.2b8e	b5 71		lda $71,x			lda 	NSExponent,x
.2b90	38		sec				sec
.2b91	e9 08		sbc #$08			sbc 	#8
.2b93	95 71		sta $71,x			sta 	NSExponent,x
.2b95	80 e3		bra $2b7a			bra 	_NSNormaliseOptimise
.2b97					_NSNormaliseLoop:
.2b97	34 65		bit $65,x			bit 	NSMantissa3,x 				; bit 30 set ?
.2b99	70 07		bvs $2ba2			bvs 	_NSNExit 					; exit if so with Z flag clear
.2b9b	20 28 2e	jsr $2e28			jsr 	FloatShiftLeft 				; shift mantissa left
.2b9e	d6 71		dec $71,x			dec 	NSExponent,x 				; adjust exponent
.2ba0	80 f5		bra $2b97			bra 	_NSNormaliseLoop
.2ba2					_NSNExit:
.2ba2	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.2ba4	60		rts				rts
.2ba5					FloatAddTopTwoStack:
.2ba5	18		clc				clc
.2ba6	b5 41		lda $41,x			lda		NSMantissa0,x
.2ba8	75 42		adc $42,x			adc 		NSMantissa0+1,x
.2baa	95 41		sta $41,x			sta 	NSMantissa0,x
.2bac	b5 4d		lda $4d,x			lda		NSMantissa1,x
.2bae	75 4e		adc $4e,x			adc 		NSMantissa1+1,x
.2bb0	95 4d		sta $4d,x			sta 	NSMantissa1,x
.2bb2	b5 59		lda $59,x			lda		NSMantissa2,x
.2bb4	75 5a		adc $5a,x			adc 		NSMantissa2+1,x
.2bb6	95 59		sta $59,x			sta 	NSMantissa2,x
.2bb8	b5 65		lda $65,x			lda		NSMantissa3,x
.2bba	75 66		adc $66,x			adc 		NSMantissa3+1,x
.2bbc	95 65		sta $65,x			sta 	NSMantissa3,x
.2bbe	60		rts				rts
.2bbf					FloatSubTopTwoStack:
.2bbf	38		sec				sec
.2bc0	b5 41		lda $41,x			lda		NSMantissa0,x
.2bc2	f5 42		sbc $42,x			sbc 		NSMantissa0+1,x
.2bc4	95 41		sta $41,x			sta 	NSMantissa0,x
.2bc6	b5 4d		lda $4d,x			lda		NSMantissa1,x
.2bc8	f5 4e		sbc $4e,x			sbc 		NSMantissa1+1,x
.2bca	95 4d		sta $4d,x			sta 	NSMantissa1,x
.2bcc	b5 59		lda $59,x			lda		NSMantissa2,x
.2bce	f5 5a		sbc $5a,x			sbc 		NSMantissa2+1,x
.2bd0	95 59		sta $59,x			sta 	NSMantissa2,x
.2bd2	b5 65		lda $65,x			lda		NSMantissa3,x
.2bd4	f5 66		sbc $66,x			sbc 		NSMantissa3+1,x
.2bd6	95 65		sta $65,x			sta 	NSMantissa3,x
.2bd8	60		rts				rts
.2bd9					FloatInt32Add:
.2bd9	b5 35		lda $35,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2bdb	55 36		eor $36,x			eor 	NSStatus+1,x
.2bdd	30 04		bmi $2be3			bmi 	_DiffSigns
.2bdf	20 a5 2b	jsr $2ba5			jsr		FloatAddTopTwoStack
.2be2	60		rts				rts
.2be3					_DiffSigns:
.2be3	20 bf 2b	jsr $2bbf			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2be6	34 65		bit $65,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2be8	10 07		bpl $2bf1			bpl 	_AddExit
.2bea	b5 36		lda $36,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2bec	95 35		sta $35,x			sta 	NSStatus,x
.2bee	20 e2 2d	jsr $2de2			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2bf1					_AddExit:
.2bf1	20 3b 2e	jsr $2e3b			jsr 	FloatIsZero 				; check for -0
.2bf4	d0 02		bne $2bf8			bne 	_AddNonZero
.2bf6	74 35		stz $35,x			stz 	NSStatus,x
.2bf8					_AddNonZero:
.2bf8	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2bf9					FloatEncodeStart:
.2bf9	38		sec				sec
.2bfa	80 01		bra $2bfd			bra 	FloatEncodeContinue+1
.2bfc					FloatEncodeContinue:
.2bfc	18		clc				clc
.2bfd					FloatEncode:
.2bfd	08		php				php 								; save reset flag.
.2bfe	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2c00	f0 15		beq $2c17			beq 	_ENIsOkay
.2c02	c9 30		cmp #$30			cmp 	#"0"
.2c04	90 04		bcc $2c0a			bcc 	_ENBadNumber
.2c06	c9 3a		cmp #$3a			cmp 	#"9"+1
.2c08	90 0d		bcc $2c17			bcc 	_ENIsOkay
.2c0a					_ENBadNumber:
.2c0a	28		plp				plp 								; throw saved reset
.2c0b	ad 8f 05	lda $058f			lda 	encodeState 				; if in decimal mode, construct final number
.2c0e	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2c10	d0 03		bne $2c15			bne 	_ENFail
.2c12	4c 8f 2c	jmp $2c8f			jmp 	_ENConstructFinal
.2c15					_ENFail:
.2c15	18		clc				clc 								; not allowed
.2c16	60		rts				rts
.2c17					_ENIsOkay:
.2c17	28		plp				plp 								; are we restarting
.2c18	90 15		bcc $2c2f			bcc 	_ENNoRestart
.2c1a					_ENStartEncode:
.2c1a	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2c1c	f0 0c		beq $2c2a			beq 	_ENFirstDP
.2c1e	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2c20	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte 				; in single byte mode.
.2c23	a9 01		lda #$01			lda 	#ESTA_Low
.2c25					_ENExitChange:
.2c25	8d 8f 05	sta $058f			sta 	encodeState 				; save new state
.2c28	38		sec				sec
.2c29	60		rts				rts
.2c2a					_ENFirstDP:
.2c2a	20 19 2e	jsr $2e19			jsr 	FloatSetZero 				; clear integer part
.2c2d	80 3c		bra $2c6b			bra 	_ESTASwitchFloat			; go straight to float and exi
.2c2f					_ENNoRestart:
.2c2f	48		pha				pha 								; save digit or DP on stack.
.2c30	ad 8f 05	lda $058f			lda 	encodeState 				; get current state
.2c33	c9 01		cmp #$01			cmp 	#ESTA_Low
.2c35	f0 09		beq $2c40			beq  	_ESTALowState
.2c37	c9 02		cmp #$02			cmp 	#ESTA_High
.2c39	f0 26		beq $2c61			beq 	_ESTAHighState
.2c3b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2c3d	f0 38		beq $2c77			beq 	_ESTADecimalState
>2c3f	db						.byte 	$DB 						; causes a break in the emulator
.2c40					_ESTALowState:
.2c40	68		pla				pla 								; get value back
.2c41	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.2c43	f0 26		beq $2c6b			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.2c45	29 0f		and #$0f			and 	#15 						; make digit
.2c47	8d 90 05	sta $0590			sta 	digitTemp 					; save it.
.2c4a	b5 41		lda $41,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.2c4c	0a		asl a				asl 	a
.2c4d	0a		asl a				asl 	a
.2c4e	75 41		adc $41,x			adc 	NSMantissa0,x
.2c50	0a		asl a				asl 	a
.2c51	6d 90 05	adc $0590			adc 	digitTemp
.2c54	95 41		sta $41,x			sta 	NSMantissa0,x
.2c56	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.2c58	90 05		bcc $2c5f			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.2c5a	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.2c5c	8d 8f 05	sta $058f			sta 	encodeState
.2c5f					_ESTANoSwitch:
.2c5f	38		sec				sec
.2c60	60		rts				rts
.2c61					_ESTAHighState:
.2c61	68		pla				pla 								; get value back
.2c62	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.2c64	f0 05		beq $2c6b			beq 	_ESTASwitchFloat
.2c66	20 c1 2c	jsr $2cc1			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.2c69	38		sec				sec
.2c6a	60		rts				rts
.2c6b					_ESTASwitchFloat:
.2c6b	9c 91 05	stz $0591			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.2c6e	e8		inx				inx 								; zero the decimal additive.
.2c6f	20 19 2e	jsr $2e19			jsr 	FloatSetZero
.2c72	ca		dex				dex
.2c73	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.2c75	80 ae		bra $2c25			bra 	_ENExitChange
.2c77					_ESTADecimalState:
.2c77	68		pla				pla 								; digit.
.2c78	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.2c7a	f0 99		beq $2c15			beq 	_ENFail
.2c7c	e8		inx				inx 								; put digit into fractional part of X+1
.2c7d	20 c1 2c	jsr $2cc1			jsr 	ESTAShiftDigitIntoMantissa
.2c80	ca		dex				dex
.2c81	ee 91 05	inc $0591			inc 	decimalCount 				; bump the count of decimals
.2c84	ad 91 05	lda $0591			lda 	decimalCount 				; too many decimal digits.
.2c87	c9 0b		cmp #$0b			cmp 	#11
.2c89	f0 02		beq $2c8d			beq 	_ESTADSFail
.2c8b	38		sec				sec
.2c8c	60		rts				rts
.2c8d					_ESTADSFail:
.2c8d	18		clc				clc
.2c8e	60		rts				rts
.2c8f					_ENConstructFinal:
.2c8f	ad 91 05	lda $0591			lda 	decimalCount 				; get decimal count
.2c92	f0 2b		beq $2cbf			beq 	_ENCFExit 					; no decimals
.2c94	5a		phy				phy
.2c95	0a		asl a				asl 	a 							; x 4 and CLC
.2c96	0a		asl a				asl 	a
.2c97	6d 91 05	adc $0591			adc 	decimalCount
.2c9a	a8		tay				tay
.2c9b	b9 26 29	lda $2926,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.2c9e	95 43		sta $43,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.2ca0	b9 27 29	lda $2927,y			lda 	FloatScalarTable-5+1,y
.2ca3	95 4f		sta $4f,x			sta 	NSMantissa1+2,x
.2ca5	b9 28 29	lda $2928,y			lda 	FloatScalarTable-5+2,y
.2ca8	95 5b		sta $5b,x			sta 	NSMantissa2+2,x
.2caa	b9 29 29	lda $2929,y			lda 	FloatScalarTable-5+3,y
.2cad	95 67		sta $67,x			sta 	NSMantissa3+2,x
.2caf	b9 2a 29	lda $292a,y			lda 	FloatScalarTable-5+4,y
.2cb2	95 73		sta $73,x			sta 	NSExponent+2,x
.2cb4	74 37		stz $37,x			stz 	NSStatus+2,x 				; make +ve
.2cb6	e8		inx				inx 								; multiply decimal const by decimal scalar
.2cb7	e8		inx				inx
.2cb8	20 d9 2a	jsr $2ad9			jsr 	FloatMultiply
.2cbb	20 3d 28	jsr $283d			jsr 	FloatAdd 					; add to integer part.
.2cbe	7a		ply				ply
.2cbf					_ENCFExit:
.2cbf	18		clc				clc 								; reject the digit.
.2cc0	60		rts				rts
.2cc1					ESTAShiftDigitIntoMantissa:
.2cc1	29 0f		and #$0f			and 	#15 						; save digit
.2cc3	48		pha				pha
.2cc4	b5 65		lda $65,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2cc6	48		pha				pha
.2cc7	b5 59		lda $59,x			lda 	NSMantissa2,x
.2cc9	48		pha				pha
.2cca	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.2ccc	48		pha				pha
.2ccd	b5 41		lda $41,x			lda 	NSMantissa0,x
.2ccf	48		pha				pha
.2cd0	20 28 2e	jsr $2e28			jsr 	FloatShiftLeft 				; x 2
.2cd3	20 28 2e	jsr $2e28			jsr 	FloatShiftLeft 				; x 4
.2cd6	18		clc				clc 								; pop mantissa and add
.2cd7	68		pla				pla
.2cd8	75 41		adc $41,x			adc 	NSMantissa0,x
.2cda	95 41		sta $41,x			sta 	NSMantissa0,x
.2cdc	68		pla				pla
.2cdd	75 4d		adc $4d,x			adc 	NSMantissa1,x
.2cdf	95 4d		sta $4d,x			sta 	NSMantissa1,x
.2ce1	68		pla				pla
.2ce2	75 59		adc $59,x			adc 	NSMantissa2,x
.2ce4	95 59		sta $59,x			sta 	NSMantissa2,x
.2ce6	68		pla				pla
.2ce7	75 65		adc $65,x			adc 	NSMantissa3,x
.2ce9	95 65		sta $65,x			sta 	NSMantissa3,x 				; x 5
.2ceb	20 28 2e	jsr $2e28			jsr 	FloatShiftLeft 				; x 10
.2cee	68		pla				pla 								; add digit
.2cef	18		clc				clc
.2cf0	75 41		adc $41,x			adc 	NSMantissa0,x
.2cf2	95 41		sta $41,x			sta 	NSMantissa0,x
.2cf4	90 0a		bcc $2d00			bcc 	_ESTASDExit
.2cf6	f6 4d		inc $4d,x			inc 	NSMantissa1,x
.2cf8	d0 06		bne $2d00			bne 	_ESTASDExit
.2cfa	f6 59		inc $59,x			inc 	NSMantissa2,x
.2cfc	d0 02		bne $2d00			bne 	_ESTASDExit
.2cfe	f6 65		inc $65,x			inc 	NSMantissa3,x
.2d00					_ESTASDExit:
.2d00	60		rts				rts
.058f					encodeState:
>058f							.fill 	1
.0590					digitTemp:
>0590							.fill 	1
.0591					decimalCount:
>0591							.fill 	1
.2d01					FloatToString:
.2d01	da		phx				phx
.2d02	5a		phy				phy 								; save code position
.2d03	8d 92 05	sta $0592			sta 	decimalPlaces	 			; save number of DPs.
.2d06	9c 93 05	stz $0593			stz 	dbOffset 					; offset into decimal buffer = start.
.2d09	b5 35		lda $35,x			lda 	NSStatus,x  				; is it -ve.
.2d0b	10 08		bpl $2d15			bpl 	_CNTSNotNegative
.2d0d	29 7f		and #$7f			and 	#$7F 						; make +ve
.2d0f	95 35		sta $35,x			sta 	NSStatus,x
.2d11	a9 2d		lda #$2d			lda 	#"-"
.2d13	80 02		bra $2d17			bra 	_CNTMain
.2d15					_CNTSNotNegative:
.2d15	a9 20		lda #$20			lda 	#" "
.2d17					_CNTMain:
.2d17	20 79 2d	jsr $2d79			jsr 	WriteDecimalBuffer
.2d1a	b5 71		lda $71,x			lda 	NSExponent,x 				; check if decimal
.2d1c	f0 0d		beq $2d2b			beq 	_CNTSNotFloat
.2d1e	e8		inx				inx 								; round up so we don't get too many 6.999999
.2d1f	a9 01		lda #$01			lda 	#1
.2d21	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.2d24	b5 70		lda $70,x			lda		NSExponent-1,x
.2d26	95 71		sta $71,x			sta 	NSExponent,x
.2d28	20 3d 28	jsr $283d			jsr 	FloatAdd
.2d2b					_CNTSNotFloat:
.2d2b	20 5b 2d	jsr $2d5b			jsr 	MakePlusTwoString 			; do the integer part.
.2d2e	20 f9 29	jsr $29f9			jsr 	FloatFractionalPart 		; get the fractional part
.2d31	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise					; normalise , exit if zero
.2d34	f0 22		beq $2d58			beq 	_CNTSExit
.2d36	a9 2e		lda #$2e			lda 	#"."
.2d38	20 79 2d	jsr $2d79			jsr 	WriteDecimalBuffer 			; write decimal place
.2d3b					_CNTSDecimal:
.2d3b	ce 92 05	dec $0592			dec 	decimalPlaces 				; done all the decimals
.2d3e	30 18		bmi $2d58			bmi 	_CNTSExit
.2d40	e8		inx				inx 								; x 10.0
.2d41	a9 0a		lda #$0a			lda 	#10
.2d43	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.2d46	20 d9 2a	jsr $2ad9			jsr 	FloatMultiply
.2d49	20 5b 2d	jsr $2d5b			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.2d4c	20 f9 29	jsr $29f9			jsr 	FloatFractionalPart 		; get the fractional part
.2d4f	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise 				; normalise it.
.2d52	b5 71		lda $71,x			lda 	NSExponent,x 				; gone to zero, exit.
.2d54	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.2d56	b0 e3		bcs $2d3b			bcs 	_CNTSDecimal 				; keep going.
.2d58					_CNTSExit:
.2d58	7a		ply				ply
.2d59	fa		plx				plx
.2d5a	60		rts				rts
.2d5b					MakePlusTwoString:
.2d5b	da		phx				phx
.2d5c	20 fc 2d	jsr $2dfc			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.2d5f	e8		inx				inx 								; access it
.2d60	e8		inx				inx
.2d61	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart 			; make it an integer
.2d64	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.2d66	20 98 2d	jsr $2d98			jsr 	ConvertInt32
.2d69	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.2d6b					_MPTSCopy:
.2d6b	bd 6d 05	lda $056d,x			lda 	numberBuffer,x
.2d6e	20 79 2d	jsr $2d79			jsr 	WriteDecimalBuffer
.2d71	e8		inx				inx
.2d72	bd 6d 05	lda $056d,x			lda 	numberBuffer,x
.2d75	d0 f4		bne $2d6b			bne 	_MPTSCopy
.2d77	fa		plx				plx
.2d78	60		rts				rts
.2d79					WriteDecimalBuffer:
.2d79	da		phx				phx
.2d7a	ae 93 05	ldx $0593			ldx 	dbOffset
.2d7d	9d 94 05	sta $0594,x			sta 	decimalBuffer,x
.2d80	9e 95 05	stz $0595,x			stz 	decimalBuffer+1,x
.2d83	ee 93 05	inc $0593			inc 	dbOffset
.2d86	fa		plx				plx
.2d87	60		rts				rts
.0592					decimalPlaces:
>0592							.fill 	1
.0593					dbOffset:
>0593							.fill 	1
.0594					decimalBuffer:
>0594							.fill 	32
.2d88					ConvertInt16:
.2d88	85 41		sta $41				sta 	NSMantissa0 				; set up as 32 bit conversion
.2d8a	86 4d		stx $4d				stx 	NSMantissa1
.2d8c	64 59		stz $59				stz 	NSMantissa2
.2d8e	64 65		stz $65				stz 	NSMantissa3
.2d90	64 35		stz $35				stz 	NSStatus 					; positive integer
.2d92	a2 00		ldx #$00			ldx 	#0 							; stack level
.2d94	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.2d96	80 00		bra $2d98			bra 	ConvertInt32
.2d98					ConvertInt32:
.2d98	5a		phy				phy
.2d99	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.2d9b	24 35		bit $35				bit 	NSStatus 					; output a - if not negative.
.2d9d	10 08		bpl $2da7			bpl 	_CI32NotNeg
.2d9f	48		pha				pha
.2da0	a9 2d		lda #$2d			lda 	#'-'
.2da2	99 6d 05	sta $056d,y			sta 	numberBuffer,y
.2da5	c8		iny				iny
.2da6	68		pla				pla
.2da7					_CI32NotNeg:
.2da7	20 b5 2d	jsr $2db5			jsr 	_CI32DivideConvert 			; recursive conversion
.2daa	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2dac	99 6d 05	sta $056d,y			sta 	numberBuffer,y
.2daf	7a		ply				ply
.2db0	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.2db2	a9 6d		lda #$6d			lda 	#numberBuffer & $FF
.2db4	60		rts				rts
.2db5					_CI32DivideConvert:
.2db5	e8		inx				inx 								; write to next slot up
.2db6	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte 		 		; write the base out.
.2db9	ca		dex				dex
.2dba	20 af 29	jsr $29af			jsr 	Int32Divide 				; divide
.2dbd	b5 41		lda $41,x			lda 	NSMantissa0,x 				; save remainder
.2dbf	48		pha				pha
.2dc0	20 9e 29	jsr $299e			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2dc3	20 3b 2e	jsr $2e3b			jsr 	FloatIsZero 				; is it zero ?
.2dc6	f0 05		beq $2dcd			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2dc8	b5 42		lda $42,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2dca	20 b5 2d	jsr $2db5			jsr 	_CI32DivideConvert 			; and recusrively call.
.2dcd					_CI32NoRecurse:
.2dcd	68		pla				pla 								; remainder
.2dce	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2dd0	90 02		bcc $2dd4			bcc 	_CI32NotHex
.2dd2	69 26		adc #$26			adc 	#6+32
.2dd4					_CI32NotHex:
.2dd4	69 30		adc #$30			adc 	#48
.2dd6	99 6d 05	sta $056d,y			sta 	numberBuffer,y 				; write out and exit
.2dd9	c8		iny				iny
.2dda	60		rts				rts
.2ddb					FloatNegate:
.2ddb	b5 35		lda $35,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2ddd	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2ddf	95 35		sta $35,x			sta 	NSStatus,x
.2de1	60		rts				rts
.2de2					FloatNegateMantissa:
.2de2	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2de3	a9 00		lda #$00			lda 	#0
.2de5	f5 41		sbc $41,x			sbc 	NSMantissa0,x
.2de7	95 41		sta $41,x			sta 	NSMantissa0,x
.2de9	a9 00		lda #$00			lda 	#0
.2deb	f5 4d		sbc $4d,x			sbc 	NSMantissa1,x
.2ded	95 4d		sta $4d,x			sta 	NSMantissa1,x
.2def	a9 00		lda #$00			lda 	#0
.2df1	f5 59		sbc $59,x			sbc 	NSMantissa2,x
.2df3	95 59		sta $59,x			sta 	NSMantissa2,x
.2df5	a9 00		lda #$00			lda 	#0
.2df7	f5 65		sbc $65,x			sbc 	NSMantissa3,x
.2df9	95 65		sta $65,x			sta 	NSMantissa3,x
.2dfb	60		rts				rts
.2dfc					FloatShiftUpTwo:
.2dfc	b5 41		lda $41,x			lda 	NSMantissa0,x
.2dfe	95 43		sta $43,x			sta 	NSMantissa0+2,x
.2e00	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.2e02	95 4f		sta $4f,x			sta 	NSMantissa1+2,x
.2e04	b5 59		lda $59,x			lda 	NSMantissa2,x
.2e06	95 5b		sta $5b,x			sta 	NSMantissa2+2,x
.2e08	b5 65		lda $65,x			lda 	NSMantissa3,x
.2e0a	95 67		sta $67,x			sta 	NSMantissa3+2,x
.2e0c	b5 71		lda $71,x			lda 	NSExponent,x
.2e0e	95 73		sta $73,x			sta 	NSExponent+2,x
.2e10	b5 35		lda $35,x			lda 	NSStatus,x
.2e12	95 37		sta $37,x			sta 	NSStatus+2,x
.2e14	60		rts				rts
.2e15					FloatSetZeroMantissaOnly:
.2e15	74 41		stz $41,x			stz 	NSMantissa0,x
.2e17	80 08		bra $2e21			bra 	FloatZero13
.2e19					FloatSetZero:
.2e19	a9 00		lda #$00			lda 	#0
.2e1b					FloatSetByte:
.2e1b	74 71		stz $71,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2e1d					FloatSetMantissa:
.2e1d	95 41		sta $41,x			sta 	NSMantissa0,x 				; zero mantissa
.2e1f	74 35		stz $35,x			stz 	NSStatus,x
.2e21					FloatZero13:
.2e21	74 4d		stz $4d,x			stz 	NSMantissa1,x
.2e23	74 59		stz $59,x			stz 	NSMantissa2,x
.2e25	74 65		stz $65,x			stz 	NSMantissa3,x
.2e27	60		rts				rts
.2e28					FloatShiftLeft:
.2e28	18		clc				clc
.2e29					FloatRotateLeft:
.2e29	36 41		rol $41,x			rol 	NSMantissa0,x
.2e2b	36 4d		rol $4d,x			rol		NSMantissa1,x
.2e2d	36 59		rol $59,x			rol		NSMantissa2,x
.2e2f	36 65		rol $65,x			rol		NSMantissa3,x
.2e31	60		rts				rts
.2e32					FloatShiftRight:
.2e32	56 65		lsr $65,x			lsr 	NSMantissa3,x
.2e34	76 59		ror $59,x			ror		NSMantissa2,x
.2e36	76 4d		ror $4d,x			ror		NSMantissa1,x
.2e38	76 41		ror $41,x			ror		NSMantissa0,x
.2e3a	60		rts				rts
.2e3b					FloatIsZero:
.2e3b	b5 65		lda $65,x			lda 	NSMantissa3,x
.2e3d	15 59		ora $59,x			ora		NSMantissa2,x
.2e3f	15 4d		ora $4d,x			ora		NSMantissa1,x
.2e41	15 41		ora $41,x			ora		NSMantissa0,x
.2e43	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.2e44					FloatArcTan:
.2e44	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise 					; normalise x
.2e47	b5 35		lda $35,x			lda 	NSStatus,x 						; save sign, make absolute
.2e49	48		pha				pha
.2e4a	74 35		stz $35,x			stz 	NSStatus,x
.2e4c	b5 71		lda $71,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.2e4e	c9 e2		cmp #$e2			cmp 	#$E2
.2e50	90 25		bcc $2e77			bcc 	_UANoFixup
.2e52	8a		txa				txa 									; value in +1
.2e53	a8		tay				tay
.2e54	c8		iny				iny
.2e55	20 fd 2f	jsr $2ffd			jsr 	CopyFloatXY
.2e58	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.2e5a	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.2e5d	e8		inx				inx
.2e5e	20 62 29	jsr $2962			jsr 	FloatDivide
.2e61	b0 21		bcs $2e84			bcs 	_FATError
.2e63	20 87 2e	jsr $2e87			jsr 	CoreAtn 						; calculate the root
.2e66	20 f2 2f	jsr $2ff2			jsr 	CompletePolynomial
.2e69	20 db 2d	jsr $2ddb			jsr 	FloatNegate 					; make -ve
.2e6c	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2e6e	20 49 30	jsr $3049			jsr 	LoadConstant
.2e71	e8		inx				inx
.2e72	20 3d 28	jsr $283d			jsr 	FloatAdd
.2e75	80 06		bra $2e7d			bra 	_UAComplete
.2e77					_UANoFixup:
.2e77	20 87 2e	jsr $2e87			jsr 	CoreAtn
.2e7a	20 f2 2f	jsr $2ff2			jsr 	CompletePolynomial
.2e7d					_UAComplete:
.2e7d	68		pla				pla 									; apply the result.
.2e7e	55 35		eor $35,x			eor 	NSStatus,x
.2e80	95 35		sta $35,x			sta 	NSStatus,x
.2e82	18		clc				clc
.2e83	60		rts				rts
.2e84					_FATError:
.2e84	68		pla				pla
.2e85	38		sec				sec
.2e86	60		rts				rts
.2e87					CoreAtn:
.2e87	a9 f5		lda #$f5			lda 	#AtnCoefficients & $FF
.2e89	a0 2e		ldy #$2e			ldy 	#AtnCoefficients >> 8
.2e8b	4c 46 31	jmp $3146			jmp 	CorePolySquared
.2e8e					ExpCoefficients:
>2e8e	07					.byte	7
>2e8f	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>2e93	d2					.byte	$d2
>2e94	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>2e98	d5					.byte	$d5
>2e99	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>2e9d	d8					.byte	$d8
>2e9e	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>2ea2	db					.byte	$db
>2ea3	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>2ea7	dd					.byte	$dd
>2ea8	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>2eac	df					.byte	$df
>2ead	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>2eb1	e1					.byte	$e1
>2eb2	00 00 00 40				.dword	$40000000 ; 1.0
>2eb6	e2					.byte	$e2
.2eb7					SinCoefficients:
>2eb7	06					.byte	6
>2eb8	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>2ebc	e5					.byte	$e5
>2ebd	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>2ec1	e7					.byte	$e7
>2ec2	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>2ec6	e8					.byte	$e8
>2ec7	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>2ecb	e8					.byte	$e8
>2ecc	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>2ed0	e7					.byte	$e7
>2ed1	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>2ed5	e4					.byte	$e4
>2ed6	00 00 00 00				.dword	$00000000 ; 0.0
>2eda	00					.byte	$00
.2edb					LogCoefficients:
>2edb	04					.byte	4
>2edc	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>2ee0	e0					.byte	$e0
>2ee1	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>2ee5	e1					.byte	$e1
>2ee6	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>2eea	e1					.byte	$e1
>2eeb	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>2eef	e3					.byte	$e3
>2ef0	00 00 00 c0				.dword	$c0000000 ; -0.5
>2ef4	e1					.byte	$e1
.2ef5					AtnCoefficients:
>2ef5	0c					.byte	12
>2ef6	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2efa	d7					.byte	$d7
>2efb	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>2eff	da					.byte	$da
>2f00	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>2f04	dc					.byte	$dc
>2f05	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2f09	dd					.byte	$dd
>2f0a	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>2f0e	dd					.byte	$dd
>2f0f	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>2f13	de					.byte	$de
>2f14	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2f18	de					.byte	$de
>2f19	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>2f1d	de					.byte	$de
>2f1e	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>2f22	df					.byte	$df
>2f23	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>2f27	df					.byte	$df
>2f28	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>2f2c	e0					.byte	$e0
>2f2d	00 00 00 40				.dword	$40000000 ; 1.0
>2f31	e2					.byte	$e2
>2f32	00 00 00 00				.dword	$00000000 ; 0.0
>2f36	00					.byte	$00
.2f37					Const_Base:
.2f37					Const_1Div2Pi:
>2f37	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>2f3b	df					.byte	$df
.2f3c					Const_PiDiv2:
>2f3c	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>2f40	e2					.byte	$e2
.2f41					Const_Log2_e:
>2f41	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>2f45	e2					.byte	$e2
.2f46					Const_sqrt_2:
>2f46	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>2f4a	e2					.byte	$e2
.2f4b					Const_sqrt_half:
>2f4b	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>2f4f	e1					.byte	$e1
.2f50					Const_pi:
>2f50	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>2f54	e3					.byte	$e3
.2f55					Const_half:
>2f55	00 00 00 40				.dword	$40000000 ; 0.50000000
>2f59	e1					.byte	$e1
.2f5a					Const_ln_e:
>2f5a	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>2f5e	e1					.byte	$e1
.2f5f					FloatCosine:
.2f5f	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2f61	20 49 30	jsr $3049			jsr 	LoadConstant
.2f64	e8		inx				inx
.2f65	20 3d 28	jsr $283d			jsr 	FloatAdd
.2f68	4c ff 30	jmp $30ff			jmp 	FloatSine
.2f6b					FloatExponent:
.2f6b	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.2f6d	20 49 30	jsr $3049			jsr 	LoadConstant
.2f70	e8		inx				inx
.2f71	20 d9 2a	jsr $2ad9			jsr 	FloatMultiply
.2f74	20 b6 2f	jsr $2fb6			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.2f77	e8		inx				inx
.2f78	20 54 2a	jsr $2a54			jsr 	FloatIntegerPart
.2f7b	ca		dex				dex
.2f7c	b5 4e		lda $4e,x			lda 	NSMantissa1+1,x
.2f7e	15 5a		ora $5a,x			ora 	NSMantissa2+1,x
.2f80	15 66		ora $66,x			ora 	NSMantissa3+1,x
.2f82	d0 38		bne $2fbc			bne 	_UERangeError
.2f84	b5 42		lda $42,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.2f86	c9 40		cmp #$40			cmp 	#64
.2f88	b0 32		bcs $2fbc			bcs 	_UERangeError
.2f8a	48		pha				pha
.2f8b	b5 35		lda $35,x			lda 	NSStatus,x 				; push sign
.2f8d	48		pha				pha
.2f8e	20 f9 29	jsr $29f9			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.2f91	68		pla				pla
.2f92	10 14		bpl $2fa8			bpl 	_UEPositive
.2f94	e8		inx				inx 							; 1-x
.2f95	a9 01		lda #$01			lda 	#1
.2f97	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.2f9a	ca		dex				dex
.2f9b	20 db 2d	jsr $2ddb			jsr 	FloatNegate
.2f9e	e8		inx				inx
.2f9f	20 3d 28	jsr $283d			jsr 	FloatAdd
.2fa2	68		pla				pla 							; integer part +1 and negated.
.2fa3	1a		inc a				inc 	a
.2fa4	49 ff		eor #$ff			eor 	#$FF
.2fa6	1a		inc a				inc 	a
.2fa7	48		pha				pha
.2fa8					_UEPositive:
.2fa8	20 be 2f	jsr $2fbe			jsr 	CoreExponent
.2fab	20 f2 2f	jsr $2ff2			jsr 	CompletePolynomial
.2fae	68		pla				pla
.2faf	18		clc				clc
.2fb0	75 71		adc $71,x			adc 	NSExponent,x
.2fb2	95 71		sta $71,x			sta 	NSExponent,x
.2fb4	18		clc				clc
.2fb5	60		rts				rts
.2fb6					_UECopy01:
.2fb6	8a		txa				txa
.2fb7	a8		tay				tay
.2fb8	c8		iny				iny
.2fb9	4c fd 2f	jmp $2ffd			jmp 	CopyFloatXY
.2fbc					_UERangeError:
.2fbc	38		sec				sec
.2fbd	60		rts				rts
.2fbe					CoreExponent:
.2fbe	a9 8e		lda #$8e			lda 	#ExpCoefficients & $FF
.2fc0	a0 2e		ldy #$2e			ldy 	#ExpCoefficients >> 8
.2fc2	20 c6 2f	jsr $2fc6			jsr 	CalculateHornerPolynomial
.2fc5	60		rts				rts
.2fc6					CalculateHornerPolynomial:
.2fc6	85 2f		sta $2f				sta 	zTemp0 						; save poly data from YA
.2fc8	84 30		sty $30				sty 	zTemp0+1
.2fca	9c b4 05	stz $05b4			stz 	coefficientCount 			; zero the count.
.2fcd	8e b5 05	stx $05b5			stx 	xValueSlot 					; save xValue slot.
.2fd0	e8		inx				inx 								; set the count to zero.
.2fd1	20 19 2e	jsr $2e19			jsr 	FloatSetZero
.2fd4					_CHPLoop:
.2fd4	8a		txa				txa 								; copy X-1 to X+1
.2fd5	a8		tay				tay
.2fd6	ca		dex				dex
.2fd7	c8		iny				iny
.2fd8	20 fd 2f	jsr $2ffd			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.2fdb	e8		inx				inx
.2fdc	e8		inx				inx
.2fdd	20 d9 2a	jsr $2ad9			jsr 	FloatMultiply 				; times current by X
.2fe0	e8		inx				inx
.2fe1	20 1c 30	jsr $301c			jsr 	GetCoefficient 				; coefficient into X+1
.2fe4	20 3d 28	jsr $283d			jsr 	FloatAdd 					; and add
.2fe7	ee b4 05	inc $05b4			inc 	coefficientCount
.2fea	ad b4 05	lda $05b4			lda 	coefficientCount
.2fed	d2 2f		cmp ($2f)			cmp 	(zTemp0)
.2fef	d0 e3		bne $2fd4			bne 	_CHPLoop
.2ff1	60		rts				rts
.2ff2					CompletePolynomial:
.2ff2	20 d9 2a	jsr $2ad9			jsr 	FloatMultiply
.2ff5	e8		inx				inx 								; get the last value
.2ff6	20 1c 30	jsr $301c			jsr 	GetCoefficient
.2ff9	20 3d 28	jsr $283d			jsr 	FloatAdd 					; and add it
.2ffc	60		rts				rts
.2ffd					CopyFloatXY:
.2ffd	b5 71		lda $71,x			lda 	NSExponent,x
.2fff	99 71 00	sta $0071,y			sta 	NSExponent,y
.3002	b5 35		lda $35,x			lda 	NSStatus,x
.3004	99 35 00	sta $0035,y			sta 	NSStatus,y
.3007	b5 41		lda $41,x			lda 	NSMantissa0,x
.3009	99 41 00	sta $0041,y			sta 	NSMantissa0,y
.300c	b5 4d		lda $4d,x			lda 	NSMantissa1,x
.300e	99 4d 00	sta $004d,y			sta 	NSMantissa1,y
.3011	b5 59		lda $59,x			lda 	NSMantissa2,x
.3013	99 59 00	sta $0059,y			sta 	NSMantissa2,y
.3016	b5 65		lda $65,x			lda 	NSMantissa3,x
.3018	99 65 00	sta $0065,y			sta 	NSMantissa3,y
.301b	60		rts				rts
.301c					GetCoefficient:
.301c	5a		phy				phy
.301d	ad b4 05	lda $05b4			lda 	coefficientCount 			; 5 per block
.3020	0a		asl a				asl 	a
.3021	0a		asl a				asl 	a
.3022	38		sec				sec 								; +1 for count
.3023	6d b4 05	adc $05b4			adc 	coefficientCount
.3026	a8		tay				tay
.3027	b1 2f		lda ($2f),y			lda 	(zTemp0),y 					; copy mantissa
.3029	95 41		sta $41,x			sta 	NSMantissa0,x
.302b	c8		iny				iny
.302c	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.302e	95 4d		sta $4d,x			sta 	NSMantissa1,x
.3030	c8		iny				iny
.3031	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.3033	95 59		sta $59,x			sta 	NSMantissa2,x
.3035	c8		iny				iny
.3036	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.3038	48		pha				pha
.3039	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.303b	95 65		sta $65,x			sta 	NSMantissa3,x
.303d	c8		iny				iny
.303e	68		pla				pla
.303f	29 80		and #$80			and 	#$80
.3041	95 35		sta $35,x			sta 	NSStatus,x 					; put in status
.3043	b1 2f		lda ($2f),y			lda 	(zTemp0),y
.3045	95 71		sta $71,x			sta 	NSExponent,x
.3047	7a		ply				ply
.3048	60		rts				rts
.05b4					coefficientCount:
>05b4							.fill 	1
.05b5					xValueSlot:
>05b5							.fill 	1
.3049					LoadConstant:
.3049	5a		phy				phy
.304a	a8		tay				tay
.304b	b9 37 2f	lda $2f37,y			lda 	Const_Base+0,y
.304e	95 42		sta $42,x			sta 	NSMantissa0+1,x
.3050	b9 38 2f	lda $2f38,y			lda 	Const_Base+1,y
.3053	95 4e		sta $4e,x			sta 	NSMantissa1+1,x
.3055	b9 39 2f	lda $2f39,y			lda 	Const_Base+2,y
.3058	95 5a		sta $5a,x			sta 	NSMantissa2+1,x
.305a	b9 3a 2f	lda $2f3a,y			lda 	Const_Base+3,y
.305d	48		pha				pha
.305e	29 7f		and #$7f			and 	#$7F
.3060	95 66		sta $66,x			sta 	NSMantissa3+1,x
.3062	68		pla				pla
.3063	29 80		and #$80			and 	#$80
.3065	95 36		sta $36,x			sta 	NSStatus+1,x
.3067	b9 3b 2f	lda $2f3b,y			lda 	Const_Base+4,y
.306a	95 72		sta $72,x			sta 	NSExponent+1,x
.306c	7a		ply				ply
.306d	60		rts				rts
.306e					FloatLogarithm:
.306e	b5 35		lda $35,x			lda 	NSStatus,x 					; check > 0
.3070	30 5f		bmi $30d1			bmi 	_ULRange
.3072	20 3b 2e	jsr $2e3b			jsr 	FloatIsZero
.3075	f0 5a		beq $30d1			beq 	_ULRange
.3077	20 6e 2b	jsr $2b6e			jsr 	FloatNormalise 				; put into FP mode.
.307a	b5 71		lda $71,x			lda 	NSExponent,x 				; get power
.307c	48		pha				pha
.307d	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.307f	95 71		sta $71,x			sta 	NSExponent,x
.3081	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.3083	20 49 30	jsr $3049			jsr 	LoadConstant
.3086	e8		inx				inx
.3087	20 3d 28	jsr $283d			jsr 	FloatAdd
.308a	8a		txa				txa 								; divide into sqrt 2.0
.308b	a8		tay				tay
.308c	c8		iny				iny
.308d	20 fd 2f	jsr $2ffd			jsr 	CopyFloatXY
.3090	ca		dex				dex
.3091	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.3093	20 49 30	jsr $3049			jsr 	LoadConstant
.3096	e8		inx				inx
.3097	e8		inx				inx
.3098	20 62 29	jsr $2962			jsr 	FloatDivide 				; if zero, error.
.309b	b0 33		bcs $30d0			bcs 	_ULRangePla
.309d	20 db 2d	jsr $2ddb			jsr 	FloatNegate 				; subtract from 1
.30a0	e8		inx				inx
.30a1	a9 01		lda #$01			lda 	#1
.30a3	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.30a6	20 3d 28	jsr $283d			jsr 	FloatAdd
.30a9	20 d3 30	jsr $30d3			jsr 	CoreLog
.30ac	20 f2 2f	jsr $2ff2			jsr 	CompletePolynomial
.30af	68		pla				pla 								; add exponent
.30b0	18		clc				clc
.30b1	69 1f		adc #$1f			adc 	#31 						; fix up
.30b3	48		pha				pha
.30b4	10 03		bpl $30b9			bpl 	_LogNotNeg
.30b6	49 ff		eor #$ff			eor 	#$FF
.30b8	1a		inc a				inc 	a
.30b9					_LogNotNeg:
.30b9	e8		inx				inx 								; set byte and sign.
.30ba	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.30bd	68		pla				pla
.30be	29 80		and #$80			and 	#$80
.30c0	95 35		sta $35,x			sta 	NSStatus,x
.30c2	20 3d 28	jsr $283d			jsr 	FloatAdd
.30c5	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.30c7	20 49 30	jsr $3049			jsr 	LoadConstant
.30ca	e8		inx				inx
.30cb	20 d9 2a	jsr $2ad9			jsr 	FloatMultiply
.30ce	18		clc				clc
.30cf	60		rts				rts
.30d0					_ULRangePla:
.30d0	68		pla				pla
.30d1					_ULRange:
.30d1	38		sec				sec
.30d2	60		rts				rts
.30d3					CoreLog:
.30d3	a9 db		lda #$db			lda 	#LogCoefficients & $FF
.30d5	a0 2e		ldy #$2e			ldy 	#LogCoefficients >> 8
.30d7	4c 46 31	jmp $3146			jmp 	CorePolySquared
.30da					FloatPI:
.30da	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.30dc	20 49 30	jsr $3049			jsr 	LoadConstant
.30df	e8		inx				inx
.30e0	18		clc				clc
.30e1	60		rts				rts
.30e2					FloatPower:
.30e2	ca		dex				dex
.30e3	8a		txa				txa 							; copy 0 to 2, so we can process it
.30e4	a8		tay				tay
.30e5	c8		iny				iny
.30e6	c8		iny				iny
.30e7	20 fd 2f	jsr $2ffd			jsr 	CopyFloatXY
.30ea	e8		inx				inx 							; 2 = Log(0)
.30eb	e8		inx				inx
.30ec	20 6e 30	jsr $306e			jsr 	FloatLogarithm
.30ef	b0 0d		bcs $30fe			bcs 	_FPWExit
.30f1	20 d9 2a	jsr $2ad9			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.30f4	8a		txa				txa 							; copy to slot 0
.30f5	a8		tay				tay
.30f6	88		dey				dey
.30f7	20 fd 2f	jsr $2ffd			jsr 	CopyFloatXY
.30fa	ca		dex				dex  							; Exponent code.
.30fb	20 6b 2f	jsr $2f6b			jsr 	FloatExponent
.30fe					_FPWExit:
.30fe	60		rts				rts
.30ff					FloatSine:
.30ff	b5 35		lda $35,x			lda 	NSStatus,x 					; save sign
.3101	48		pha				pha
.3102	74 35		stz $35,x			stz 	NSStatus,x 					; make +ve
.3104	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.3106	20 49 30	jsr $3049			jsr 	LoadConstant
.3109	e8		inx				inx
.310a	20 d9 2a	jsr $2ad9			jsr 	FloatMultiply
.310d	20 f9 29	jsr $29f9			jsr 	FloatFractionalPart 		; take the fractional part
.3110	b5 71		lda $71,x			lda 	NSExponent,x 				; check exponent
.3112	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.3114	90 1f		bcc $3135			bcc 	_USProcessExit
.3116	f0 06		beq $311e			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.3118	b5 65		lda $65,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.311a	c9 60		cmp #$60			cmp 	#$60
.311c	b0 0e		bcs $312c			bcs 	_USSubtractOne
.311e					_USSubtractFromHalf:
.311e	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.3120	20 49 30	jsr $3049			jsr 	LoadConstant
.3123	e8		inx				inx
.3124	20 37 28	jsr $2837			jsr 	FloatSubtract
.3127	20 db 2d	jsr $2ddb			jsr 	FloatNegate 				; then negate it
.312a	80 09		bra $3135			bra 	_USProcessExit 				; and exit
.312c					_USSubtractOne:
.312c	e8		inx				inx
.312d	a9 01		lda #$01			lda 	#1
.312f	20 1b 2e	jsr $2e1b			jsr 	FloatSetByte
.3132	20 37 28	jsr $2837			jsr 	FloatSubtract
.3135					_USProcessExit:
.3135	20 42 31	jsr $3142			jsr 	CoreSine
.3138	20 f2 2f	jsr $2ff2			jsr 	CompletePolynomial
.313b	68		pla				pla 								; restore sign and apply
.313c	55 35		eor $35,x			eor 	NSStatus,x
.313e	95 35		sta $35,x			sta 	NSStatus,x
.3140	18		clc				clc
.3141	60		rts				rts
.3142					CoreSine:
.3142	a9 b7		lda #$b7			lda 	#SinCoefficients & $FF
.3144	a0 2e		ldy #$2e			ldy 	#SinCoefficients >> 8
.3146					CorePolySquared:
.3146	48		pha				pha 								; save coefficient table
.3147	5a		phy				phy
.3148	8a		txa				txa 								; copy X to +1, +2
.3149	a8		tay				tay
.314a	c8		iny				iny
.314b	20 fd 2f	jsr $2ffd			jsr 	CopyFloatXY
.314e	c8		iny				iny
.314f	20 fd 2f	jsr $2ffd			jsr 	CopyFloatXY
.3152	e8		inx				inx 								; point to the pair and put x^2 on stack
.3153	e8		inx				inx
.3154	20 d9 2a	jsr $2ad9			jsr 	FloatMultiply
.3157	7a		ply				ply 								; coefficient table back.
.3158	68		pla				pla
.3159	20 c6 2f	jsr $2fc6			jsr 	CalculateHornerPolynomial
.315c	8a		txa				txa 								; copy back to slot #1
.315d	a8		tay				tay
.315e	88		dey				dey
.315f	20 fd 2f	jsr $2ffd			jsr	 	CopyFloatXY
.3162	ca		dex				dex 								; point at result
.3163	60		rts				rts
.3164					FloatSquareRoot:
.3164	20 6e 30	jsr $306e			jsr 	FloatLogarithm
.3167	b0 06		bcs $316f			bcs 	_FSQExit
.3169	d6 71		dec $71,x			dec 	NSExponent,x
.316b	20 6b 2f	jsr $2f6b			jsr 	FloatExponent
.316e	18		clc				clc
.316f					_FSQExit:
.316f	60		rts				rts
.3170					FloatTangent:
.3170	da		phx				phx
.3171	8a		txa				txa 								; sin -> +1
.3172	a8		tay				tay
.3173	c8		iny				iny
.3174	20 fd 2f	jsr $2ffd			jsr 	CopyFloatXY
.3177	e8		inx				inx
.3178	20 ff 30	jsr $30ff			jsr 	FloatSine
.317b	ca		dex				dex
.317c	8a		txa				txa 								; cos -> +2
.317d	a8		tay				tay
.317e	c8		iny				iny
.317f	c8		iny				iny
.3180	20 fd 2f	jsr $2ffd			jsr 	CopyFloatXY
.3183	e8		inx				inx
.3184	e8		inx				inx
.3185	20 5f 2f	jsr $2f5f			jsr 	FloatCosine
.3188	20 62 29	jsr $2962			jsr 	FloatDivide 				; calculate sin/cos
.318b	b0 07		bcs $3194			bcs 	_FTExit 					; divide by zero
.318d	8a		txa				txa 								; copy result down.
.318e	a8		tay				tay
.318f	88		dey				dey
.3190	20 fd 2f	jsr $2ffd			jsr 	CopyFloatXY
.3193	18		clc				clc
.3194					_FTExit:
.3194	fa		plx				plx
.3195	60		rts				rts

;******  Processing input file: testing/testend.asm

=$3200							nextPage = (* + $FF) & $FF00 		; so I can include with that f*****g header.
.31fe					ObjectCodePreHeader:
>31fe	00 40 d4 54 00 a6 0e 48				.binary "code/code.bin"
>3206	00 a6 03 c7 a6 cb 93 93 b1 ce 0d 48 45 4c 4c 4f
>3216	20 57 4f 52 4c 44 20 21 b1 0d 92 a6 40 00 01 00
>3226	ca 81 58 03 40 00 01 00 ca 81 58 06 40 00 01 00
>3236	ca 81 58 09 a6 40 00 01 00 ca 81 58 0c 40 00 01
>3246	00 ca 81 58 0f a6 00 48 12 24 40 00 01 95 a6 40
>3256	12 01 50 03 8e 01 b4 28 82 ca 84 02 82 01 80 7c
>3266	a6 40 12 01 50 06 8e 01 b4 1e 82 ca 84 cc 00 01
>3276	82 7c a6 40 12 01 50 09 8e 01 b4 0e 82 ca 84 01
>3286	80 7c a6 40 12 01 50 0c 8e 01 b4 02 82 ca 84 7c
>3296	a6 a6 40 12 01 50 0f 8e 01 7c a6 24 a7 a6 a6 00
>32a6	48 15 2a 1d 01 95 00 48 18 30 27 01 95 a6 40 15
>32b6	cc 00 01 82 40 18 02 82 80 cc 00 b0 80 48 1b a6
>32c6	01 40 1b cb 51 c8 01 40 1b 01 80 00 c8 a6 30 a7
>32d6	2a a7 a6 01 48 12 24 40 00 01 95 a6 01 cc 00 b0
>32e6	40 12 01 50 06 8e 78 80 40 12 01 50 03 8e 78 80
>32f6	00 c8 a6 40 12 01 50 0c 8e 78 48 1e a6 40 1e 00
>3306	a3 88 d2 00 07 00 d1 00 5d 00 a6 40 1e 01 a3 88
>3316	d2 00 07 00 d1 00 7a 00 a6 40 12 01 50 0f 8e 78
>3326	48 21 a6 40 21 00 a3 88 d2 00 07 00 d1 00 97 00
>3336	a6 40 21 01 a3 88 d2 00 07 00 d1 00 b6 00 a6 01
>3346	cc 00 b0 40 12 01 50 06 8e 78 80 40 12 01 50 03
>3356	8e 78 80 40 12 01 50 09 8e 78 c8 a6 24 a7 a6 d0
>3366	00 72 ff a6 a6 40 12 01 50 03 8e 78 48 24 a6 40
>3376	24 01 a3 88 d2 00 0c 00 40 12 01 50 0c 8e 01 7c
>3386	98 a6 40 12 01 50 03 8e 40 24 02 81 7c 98 a6 a6
>3396	40 12 01 50 03 8e 78 48 24 a6 40 24 cb 4f a3 88
>33a6	d2 00 15 00 40 12 01 50 03 8e cb 4d 7c 40 12 01
>33b6	50 0c 8e 00 7c 98 a6 40 12 01 50 03 8e 40 24 02
>33c6	80 7c 98 a6 a6 40 12 01 50 06 8e 78 48 27 a6 40
>33d6	27 00 a3 88 d2 00 0c 00 40 12 01 50 0f 8e 01 7c
>33e6	98 a6 40 12 01 50 06 8e 40 27 cc 00 01 81 7c 98
>33f6	a6 a6 40 12 01 50 06 8e 78 48 27 a6 40 27 cc 00
>3406	1d a3 88 d2 00 16 00 40 12 01 50 06 8e cc 00 1c
>3416	7c 40 12 01 50 0f 8e 00 7c 98 a6 40 12 01 50 06
>3426	8e 40 27 cc 00 01 80 7c 98 c4 ff
=12800					ObjectCode = ObjectCodePreHeader+2 			; so the code is at XX00

;******  End of listing
