
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl /home/paulr/Projects/blitz-compiler/documents/../source/common-source/wrapper.asm testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library testing/testend.asm
; Fri Oct  6 02:13:53 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../source/common-source/wrapper.asm

=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.1000	a2 ff		ldx #$ff			ldx 	#$FF
.1002	9a		txs				txs
.1003	4c 06 10	jmp $1006			jmp 	WrapperBoot
.0022					codePtr:
>0022							.fill 	2
.0024					codePage:
>0024							.fill 	1
.0025					objPtr:
>0025							.fill 	2
.0027					objPage:
>0027							.fill 	1
.0028					zTemp0:
>0028							.fill 	2
.002a					zTemp1:
>002a							.fill 	2
.002c					zTemp2:
>002c							.fill 	2

;******  Processing input file: testing/testing.asm

.1006					WrapperBoot:
.1006	a9 32		lda #$32			lda 	#ObjectCode >> 8 			; address of object code to run.
.1008	4c 0b 10	jmp $100b			jmp 	StartRuntime

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$8000					WorkArea = $8000
=$1f00					WorkAreaSize = $1F00
=40192					StringTopAddress = WorkArea + WorkAreaSize - (1 + (WorkAreaSize >> 12)) * 256
=40704					StackTopAddress = WorkArea + WorkAreaSize
=$8000					VariableStart = WorkArea
.002e					zsTemp:
>002e							.fill 	2
.0030					runtimeStackPtr:
>0030							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.100b					StartRuntime:
.100b	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.100e	85 23		sta $23				sta 	codePtr+1 					; set pointer to code.
.1010	64 22		stz $22				stz 	codePtr
.1012	64 24		stz $24				stz 	codePage 					; zero current page.
.1014	20 42 12	jsr $1242			jsr 	ClearMemory 				; clear memory.
.1017	20 95 1f	jsr $1f95			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.101a	20 9a 1c	jsr $1c9a		 	jsr		SetDefaultChannel			; set default input/output channel.
.101d	20 cd 1e	jsr $1ecd			jsr 	RestoreCode 				; which we now call
.1020	a0 00		ldy #$00			ldy 	#0
.1022					NextCommand:
.1022	b1 22		lda ($22),y			lda 	(codePtr),y 				; get next
.1024	30 5b		bmi $1081			bmi 	NXCommand 					; -if -ve command
.1026	c8		iny				iny
.1027	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.1029	90 39		bcc $1064			bcc 	PushByteA 					; 0..63 is short constants.
.102b					NXLoadStore:
.102b	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.102d	b0 19		bcs $1048			bcs 	NXIndirectLoadStore
.102f	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.1030	4a		lsr a				lsr 	a
.1031	29 0e		and #$0e			and 	#$0E
.1033	da		phx				phx 								; get ready to jump
.1034	aa		tax				tax
.1035	7c 38 10	jmp ($1038,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.1038					ReadWriteVectors:
>1038	06 1e						.word 	ReadFloatCommand			; read float
>103a	de 23						.word 	WriteFloatCommand 			; write float
>103c	41 1e						.word 	ReadIntegerCommand 			; read integer
>103e	19 24						.word 	WriteIntegerCommand 		; write integer
>1040	85 1e						.word 	ReadStringCommand 			; read string
>1042	57 24						.word 	WriteStringCommand 			; write string
>1044	fe 13						.word 	Unimplemented
>1046	fe 13						.word 	Unimplemented
.1048					NXIndirectLoadStore:
.1048	29 07		and #$07			and 	#7
.104a	0a		asl a				asl 	a
.104b	da		phx				phx
.104c	aa		tax				tax
.104d	7c 50 10	jmp ($1050,x)			jmp 	(IndirectVectors,x)
.1050					IndirectVectors:
>1050	2d 18						.word 	IndFloatRead 				; float read
>1052	40 18						.word 	IndInt16Read 				; int16 read
>1054	53 18						.word 	IndStringRead 				; string read
>1056	fe 13						.word 	Unimplemented
>1058	66 18						.word 	IndFloatWrite				; float write
>105a	79 18						.word 	IndInt16Write 				; int16 write
>105c	8c 18						.word 	IndStringWrite 				; string write
>105e	fe 13						.word 	Unimplemented
.1060					PushByteCommand:
.1060	fa		plx				plx
.1061	b1 22		lda ($22),y			lda 	(codePtr),y 				; get byte to write.
.1063	c8		iny				iny
.1064					PushByteA:
.1064	e8		inx				inx 								; push constant on stack
.1065	95 40		sta $40,x			sta 	NSMantissa0,x 				; save byte
.1067	74 4c		stz $4c,x			stz 	NSMantissa1,x 				; clear MSB
.1069					ClearRestWord:
.1069	74 58		stz $58,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.106b	74 64		stz $64,x			stz 	NSMantissa3,x
.106d	74 70		stz $70,x			stz 	NSExponent,x
.106f	74 34		stz $34,x			stz 	NSStatus,x
.1071	80 af		bra $1022			bra 	NextCommand
.1073					PushWordCommand:
.1073	fa		plx				plx
.1074	e8		inx				inx
.1075	b1 22		lda ($22),y			lda 	(codePtr),y 				; word to stack
.1077	c8		iny				iny
.1078	95 40		sta $40,x			sta 	NSMantissa0,x
.107a	b1 22		lda ($22),y			lda 	(codePtr),y
.107c	c8		iny				iny
.107d	95 4c		sta $4c,x			sta 	NSMantissa1,x
.107f	80 e8		bra $1069			bra 	ClearRestWord 				; handle everything else.
.1081					NXCommand:
.1081	c8		iny				iny 								; consume command.
.1082	10 03		bpl $1087			bpl 	_NXCommandNoFixUp
.1084	20 8d 10	jsr $108d			jsr 	FixUpY
.1087					_NXCommandNoFixUp:
.1087	0a		asl a				asl 	a 							; shift left
.1088	da		phx				phx 								; save SP on stack
.1089	aa		tax				tax				 					; and jump indirect
.108a	7c bf 22	jmp ($22bf,x)			jmp 	(VectorTable,x)
.108d					FixUpY:
.108d	48		pha				pha
.108e	98		tya				tya
.108f	18		clc				clc
.1090	65 22		adc $22				adc 	codePtr
.1092	85 22		sta $22				sta 	codePtr
.1094	90 02		bcc $1098			bcc 	_NoCPCarry
.1096	e6 23		inc $23				inc 	codePtr+1
.1098					_NoCPCarry:
.1098	a0 00		ldy #$00			ldy 	#0
.109a	68		pla				pla
.109b	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.109c					AbsoluteTOS:
.109c	fa		plx				plx
.109d	74 34		stz $34,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.109f	4c 22 10	jmp $1022			jmp 	NextCommand
.10a2					CommandVarSpace:
.10a2	fa		plx				plx
.10a3	b1 22		lda ($22),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.10a5	85 32		sta $32				sta 	availableMemory
.10a7	c8		iny				iny
.10a8	b1 22		lda ($22),y			lda 	(codePtr),y
.10aa	18		clc				clc
.10ab	69 80		adc #$80			adc 	#WorkArea >> 8 				; offset to actual address.
.10ad	85 33		sta $33				sta 	availableMemory+1
.10af	c8		iny				iny
.10b0	4c 22 10	jmp $1022			jmp 	NextCommand
.0032					availableMemory:
>0032							.fill 	2
.10b3					BinaryAnd:
.10b3	fa		plx				plx
.10b4	38		sec				sec
.10b5	80 02		bra $10b9			bra 	AndOrCommon
.10b7					BinaryOr:
.10b7	fa		plx				plx
.10b8	18		clc				clc
.10b9					AndOrCommon:
.10b9	08		php				php 								; save AND/OR flag
.10ba	20 62 19	jsr $1962			jsr 	GetInteger16Bit
.10bd	ca		dex				dex
.10be	20 62 19	jsr $1962			jsr 	GetInteger16Bit
.10c1	28		plp				plp
.10c2	90 0e		bcc $10d2			bcc 	_AOCOrCode
.10c4	b5 40		lda $40,x			lda 	NSMantissa0,x 				; AND code
.10c6	35 41		and $41,x			and		NSMantissa0+1,x
.10c8	95 40		sta $40,x			sta 	NSMantissa0,x
.10ca	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.10cc	35 4d		and $4d,x			and		NSMantissa1+1,x
.10ce	95 4c		sta $4c,x			sta 	NSMantissa1,x
.10d0	80 0c		bra $10de			bra 	_AOCComplete
.10d2					_AOCOrCode:
.10d2	b5 40		lda $40,x			lda 	NSMantissa0,x 				; OR code
.10d4	15 41		ora $41,x			ora		NSMantissa0+1,x
.10d6	95 40		sta $40,x			sta 	NSMantissa0,x
.10d8	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.10da	15 4d		ora $4d,x			ora		NSMantissa1+1,x
.10dc	95 4c		sta $4c,x			sta 	NSMantissa1,x
.10de					_AOCComplete:
.10de	74 34		stz $34,x			stz 	NSStatus,x 					; make integer ?
.10e0	34 4c		bit $4c,x			bit 	NSMantissa1,x 				; result is -ve
.10e2	10 07		bpl $10eb			bpl 	_AOCExit
.10e4	20 72 19	jsr $1972			jsr 	Negate16Bit 				; 2's complement
.10e7	a9 80		lda #$80			lda 	#$80 						; make it -ve
.10e9	95 34		sta $34,x			sta 	NSStatus,x
.10eb					_AOCExit:
.10eb	4c 22 10	jmp $1022			jmp 	NextCommand
.10ee					ArrayConvert:
.10ee	fa		plx				plx
.10ef	5a		phy				phy
.10f0	b5 40		lda $40,x			lda 	NSMantissa0,x
.10f2	85 2a		sta $2a				sta 	zTemp1
.10f4	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.10f6	18		clc				clc
.10f7	69 80		adc #$80			adc 	#(WorkArea >> 8)
.10f9	85 2b		sta $2b				sta 	zTemp1+1
.10fb	ca		dex				dex 								; count of indices to follow -> zTemp2
.10fc	20 5c 19	jsr $195c			jsr 	GetInteger8Bit
.10ff	85 2c		sta $2c				sta 	zTemp2 						; subtract from stack.
.1101	8a		txa				txa
.1102	38		sec				sec
.1103	e5 2c		sbc $2c				sbc 	zTemp2
.1105	aa		tax				tax
.1106	da		phx				phx 								; stack points at the first index, which will be replaced.
.1107					_ACIndexLoop:
.1107	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart 			; integer array index
.110a	20 62 19	jsr $1962			jsr 	GetInteger16Bit 			; get the index => zTemp0
.110d	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.110f	a5 28		lda $28				lda 	zTemp0
.1111	d2 2a		cmp ($2a)			cmp 	(zTemp1)
.1113	a5 29		lda $29				lda 	zTemp0+1
.1115	f1 2a		sbc ($2a),y			sbc 	(zTemp1),y
.1117	b0 77		bcs $1190			bcs 	_ACBadIndex 				; index error.
.1119	c6 2c		dec $2c				dec 	zTemp2 						; decrement count, if zero, then innermost level
.111b	f0 28		beq $1145			beq 	_ACInnerLevel
.111d	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.111f	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.1121	10 6d		bpl $1190			bpl 	_ACBadIndex
.1123	06 28		asl $28				asl 	zTemp0 						; double the index and add it to the base address
.1125	26 29		rol $29				rol 	zTemp0+1
.1127	18		clc				clc
.1128	a5 28		lda $28				lda		zTemp0
.112a	65 2a		adc $2a				adc 	zTemp1
.112c	85 28		sta $28				sta 	zTemp0
.112e	a5 29		lda $29				lda		zTemp0+1
.1130	65 2b		adc $2b				adc 	zTemp1+1
.1132	85 29		sta $29				sta 	zTemp0+1
.1134	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.1136	b1 28		lda ($28),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.1138	85 2a		sta $2a				sta 	zTemp1
.113a	c8		iny				iny
.113b	b1 28		lda ($28),y			lda 	(zTemp0),y
.113d	18		clc				clc
.113e	69 80		adc #$80			adc 	#(WorkArea >> 8)
.1140	85 2b		sta $2b				sta 	zTemp1+1
.1142	e8		inx				inx 								; next index
.1143	80 c2		bra $1107			bra 	_ACIndexLoop
.1145					_ACInnerLevel:
.1145	a0 02		ldy #$02			ldy 	#2
.1147	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.1149	30 45		bmi $1190			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.114b	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.114d	c9 00		cmp #$00			cmp 	#NSSIFloat
.114f	d0 13		bne $1164			bne 	_ACNotFloat
.1151	a5 29		lda $29				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.1153	48		pha				pha
.1154	a5 28		lda $28				lda 	zTemp0
.1156	06 28		asl $28				asl 	zTemp0 						; x 2
.1158	26 29		rol $29				rol 	zTemp0+1
.115a	18		clc				clc 								; add back x 3
.115b	65 28		adc $28				adc 	zTemp0
.115d	85 28		sta $28				sta 	zTemp0
.115f	68		pla				pla
.1160	65 29		adc $29				adc 	zTemp0+1
.1162	85 29		sta $29				sta 	zTemp0+1
.1164					_ACNotFloat:
.1164	06 28		asl $28				asl 	zTemp0 						; x 2 or x 6 depending.
.1166	26 29		rol $29				rol 	zTemp0+1
.1168	18		clc				clc
.1169	a5 28		lda $28				lda 	zTemp0
.116b	69 03		adc #$03			adc 	#3
.116d	85 28		sta $28				sta 	zTemp0
.116f	90 02		bcc $1173			bcc 	_ACNoCarry
.1171	e6 29		inc $29				inc 	zTemp0+1
.1173					_ACNoCarry:
.1173	fa		plx				plx 								; X points to first slot of array parameters
.1174	18		clc				clc
.1175	a5 28		lda $28				lda 	zTemp0
.1177	65 2a		adc $2a				adc 	zTemp1
.1179	95 40		sta $40,x			sta 	NSMantissa0,x
.117b	a5 29		lda $29				lda 	zTemp0+1
.117d	65 2b		adc $2b				adc 	zTemp1+1
.117f	38		sec				sec
.1180	e9 80		sbc #$80			sbc 	#(WorkArea >> 8)
.1182	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1184	74 58		stz $58,x			stz 	NSMantissa2,x
.1186	74 64		stz $64,x			stz 	NSMantissa3,x
.1188	74 34		stz $34,x			stz 	NSStatus,x
.118a	74 70		stz $70,x			stz 	NSExponent,x
.118c	7a		ply				ply 	 							; restore code pointer
.118d	4c 22 10	jmp $1022			jmp 	NextCommand
.1190					_ACBadIndex:
.1190	4c 55 15	jmp $1555		jmp	ErrorV_index
.1193					UnaryAsc:
.1193	fa		plx				plx
.1194	5a		phy				phy
.1195	b5 40		lda $40,x			lda 	NSMantissa0,x 				; string address.
.1197	85 28		sta $28				sta 	zTemp0
.1199	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.119b	85 29		sta $29				sta 	zTemp0+1
.119d	b2 28		lda ($28)			lda 	(zTemp0) 					; if empty string return zero
.119f	f0 06		beq $11a7			beq 	_UAExit
.11a1	5a		phy				phy 								; otherwise first character
.11a2	a0 01		ldy #$01			ldy 	#1
.11a4	b1 28		lda ($28),y			lda 	(zTemp0),y
.11a6	7a		ply				ply
.11a7					_UAExit:
.11a7	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.11aa	7a		ply				ply
.11ab	4c 22 10	jmp $1022			jmp 	NextCommand
.11ae					CommandAssert:
.11ae	fa		plx				plx
.11af	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.11b1	d0 09		bne $11bc			bne 	_CAFail
.11b3	20 0f 2e	jsr $2e0f			jsr 	FloatIsZero 				; is it zero ?
.11b6	f0 04		beq $11bc			beq 	_CAFail
.11b8	ca		dex				dex
.11b9	4c 22 10	jmp $1022			jmp 	NextCommand
.11bc					_CAFail:
.11bc	4c ae 14	jmp $14ae		jmp	ErrorV_assert
.11bf					X16_Audio_Parameters8_16:
.11bf	20 c5 11	jsr $11c5			jsr 	X16_Audio_Parameters8_8
.11c2	a4 4d		ldy $4d				ldy 	NSMantissa1+1
.11c4	60		rts				rts
.11c5					X16_Audio_Parameters8_8:
.11c5	a2 01		ldx #$01			ldx 	#1
.11c7	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.11ca	ca		dex				dex
.11cb	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.11ce	20 5c 19	jsr $195c			jsr 	GetInteger8Bit
.11d1	a6 41		ldx $41				ldx 	NSMantissa0+1
.11d3	a0 00		ldy #$00			ldy 	#0
.11d5	60		rts				rts
.11d6					X16_Audio_Parameters8_String:
.11d6	20 bf 11	jsr $11bf			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.11d9	da		phx				phx 								; set the voice
.11da	5a		phy				phy
.11db	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.11de	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>11e1	0a						.byte 	X16_AudioCodeBank
.11e2	7a		ply				ply
.11e3	fa		plx				plx
.11e4	86 28		stx $28				stx 	zTemp0
.11e6	84 29		sty $29				sty 	zTemp0+1
.11e8	b2 28		lda ($28)			lda 	(zTemp0) 					; read length
.11ea	e8		inx				inx 								; point YX to first character.
.11eb	d0 01		bne $11ee			bne 	_X16APSSkip
.11ed	c8		iny				iny
.11ee					_X16APSSkip:
.11ee	60		rts				rts
.11ef					Unary16Bin:
.11ef	fa		plx				plx
.11f0	20 62 19	jsr $1962			jsr 	GetInteger16Bit				; 16 bit int
.11f3	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.11f5	20 3e 20	jsr $203e			jsr 	StringAllocTemp
.11f8	a5 29		lda $29				lda 	zTemp0+1
.11fa	f0 03		beq $11ff			beq 	_UBNoHigh
.11fc	20 07 12	jsr $1207			jsr 	_UBWriteBinary
.11ff					_UBNoHigh:
.11ff	a5 28		lda $28				lda 	zTemp0
.1201	20 07 12	jsr $1207			jsr 	_UBWriteBinary
.1204	4c 22 10	jmp $1022			jmp 	NextCommand
.1207					_UBWriteBinary:
.1207	5a		phy				phy
.1208	a0 08		ldy #$08			ldy 	#8
.120a					_UBWLoop:
.120a	0a		asl a				asl 	a
.120b	48		pha				pha
.120c	a9 00		lda #$00			lda  	#0
.120e	69 30		adc #$30			adc 	#48
.1210	20 67 20	jsr $2067			jsr 	StringWriteChar
.1213	68		pla				pla
.1214	88		dey				dey
.1215	d0 f3		bne $120a			bne 	_UBWLoop
.1217	7a		ply				ply
.1218	60		rts				rts
.1219					PrintCharacter:
.1219	fa		plx				plx
.121a	b5 40		lda $40,x			lda 	NSMantissa0,x
.121c	ca		dex				dex
.121d	20 9e 1c	jsr $1c9e			jsr 	VectorPrintCharacter
.1220	4c 22 10	jmp $1022			jmp 	NextCommand
.1223					UnaryChr:
.1223	fa		plx				plx
.1224	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; get integer to convert.
.1227	48		pha				pha 								; save it and allocate for it
.1228	a9 01		lda #$01			lda 	#1 							; 1 character
.122a	20 3e 20	jsr $203e			jsr 	StringAllocTemp
.122d	a9 01		lda #$01			lda 	#1 							; length 1.
.122f	92 2e		sta ($2e)			sta 	(zsTemp)
.1231	68		pla				pla 								; character code makes string.
.1232	5a		phy				phy
.1233	a0 01		ldy #$01			ldy 	#1
.1235	91 2e		sta ($2e),y			sta 	(zsTemp),y
.1237	7a		ply				ply
.1238	4c 22 10	jmp $1022			jmp 	NextCommand
.123b					CommandClr:
.123b	fa		plx				plx
.123c	20 42 12	jsr $1242			jsr 	ClearMemory
.123f	4c 22 10	jmp $1022			jmp 	NextCommand
.1242					ClearMemory:
.1242	a9 00		lda #$00			lda 	#((WorkArea) & $FF)
.1244	85 28		sta $28				sta 	0+zTemp0
.1246	a9 80		lda #$80			lda 	#((WorkArea) >> 8) & $FF
.1248	85 29		sta $29				sta 	1+zTemp0
.124a	5a		phy				phy
.124b	a0 00		ldy #$00			ldy 	#0
.124d					_ClearLoop1:
.124d	a9 00		lda #$00			lda 	#0
.124f	91 28		sta ($28),y			sta 	(zTemp0),y
.1251	c8		iny				iny
.1252	d0 f9		bne $124d			bne 	_ClearLoop1
.1254	e6 29		inc $29				inc 	zTemp0+1
.1256	a5 29		lda $29				lda 	zTemp0+1
.1258	c9 9f		cmp #$9f			cmp 	#(WorkArea+WorkAreaSize) >> 8
.125a	d0 f1		bne $124d			bne 	_ClearLoop1
.125c	a9 00		lda #$00			lda 	#((StringTopAddress) & $FF)
.125e	8d 02 04	sta $0402			sta 	0+stringHighMemory
.1261	a9 9d		lda #$9d			lda 	#((StringTopAddress) >> 8) & $FF
.1263	8d 03 04	sta $0403			sta 	1+stringHighMemory
.1266	9c 65 05	stz $0565			stz 	stringInitialised 						; string system not initialised
.1269	a9 ff		lda #$ff			lda 	#((StackTopAddress-1) & $FF)
.126b	85 30		sta $30				sta 	0+runtimeStackPtr
.126d	a9 9e		lda #$9e			lda 	#((StackTopAddress-1) >> 8) & $FF
.126f	85 31		sta $31				sta 	1+runtimeStackPtr
.1271	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.1273	92 30		sta ($30)			sta 	(runtimeStackPtr)
.1275	7a		ply				ply
.1276	60		rts				rts
.1277					CompareStrings:
.1277	fa		plx				plx
.1278	ca		dex				dex
.1279	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.127b	85 28		sta $28				sta 	zTemp0
.127d	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.127f	85 29		sta $29				sta 	zTemp0+1
.1281	b5 41		lda $41,x			lda 	NSMantissa0+1,x
.1283	85 2a		sta $2a				sta 	zTemp1
.1285	b5 4d		lda $4d,x			lda 	NSMantissa1+1,x
.1287	85 2b		sta $2b				sta 	zTemp1+1
.1289	da		phx				phx
.128a	5a		phy				phy
.128b	b2 28		lda ($28)			lda 	(zTemp0)					; work out number to compare
.128d	d2 2a		cmp ($2a)			cmp 	(zTemp1)
.128f	90 02		bcc $1293			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.1291	b2 2a		lda ($2a)			lda 	(zTemp1)
.1293					_CSNIsSmallest:
.1293	aa		tax				tax 								; count in X
.1294	f0 0c		beq $12a2			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.1296	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.1298					_CSNCompareString:
.1298	c8		iny				iny 								; pre increment
.1299	b1 28		lda ($28),y			lda 	(zTemp0),y
.129b	d1 2a		cmp ($2a),y			cmp 	(zTemp1),y
.129d	d0 0a		bne $12a9			bne 	_CSNDifferent 				; numbers are different.
.129f	ca		dex				dex
.12a0	d0 f6		bne $1298			bne 	_CSNCompareString 			; compare common characters in two strings.
.12a2					_CSNMatches:
.12a2	38		sec				sec
.12a3	b2 28		lda ($28)			lda 	(zTemp0)					; compare lengths
.12a5	f2 2a		sbc ($2a)			sbc 	(zTemp1)
.12a7	f0 06		beq $12af			beq 	_CSNSExit 					; if zero, then strings match and exit.
.12a9					_CSNDifferent:
.12a9	a9 ff		lda #$ff			lda 	#$FF
.12ab	90 02		bcc $12af			bcc 	_CSNSExit
.12ad	a9 01		lda #$01			lda 	#$01
.12af					_CSNSExit:
.12af	7a		ply				ply
.12b0	fa		plx				plx
.12b1	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.12b3	20 ef 2d	jsr $2def			jsr 	FloatSetByte 				; output the byte
.12b6	4c 22 10	jmp $1022			jmp 	NextCommand
.12b9					StringConcrete:
.12b9	9c 65 05	stz $0565			stz 	stringInitialised	 		; initialise next usage
.12bc	84 2d		sty $2d				sty 	zTemp2+1 					; save pointer to new string
.12be	85 2c		sta $2c				sta 	zTemp2
.12c0	b2 2c		lda ($2c)			lda 	(zTemp2) 					; length required
.12c2	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.12c3	18		clc				clc
.12c4	72 2c		adc ($2c)			adc 	(zTemp2)
.12c6	90 02		bcc $12ca			bcc 	_SCNoOverflow
.12c8	a9 ff		lda #$ff			lda 	#255
.12ca					_SCNoOverflow:
.12ca	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.12cc	b0 02		bcs $12d0			bcs 	_SCNoMinimum
.12ce	a9 0a		lda #$0a			lda 	#10
.12d0					_SCNoMinimum:
.12d0	85 2a		sta $2a				sta 	zTemp1 						; save max length.
.12d2	38		sec				sec
.12d3	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.12d6	e5 2a		sbc $2a				sbc 	zTemp1
.12d8	a8		tay				tay
.12d9	ad 03 04	lda $0403			lda 	stringHighMemory+1
.12dc	e9 00		sbc #$00			sbc 	#0
.12de	48		pha				pha
.12df	38		sec				sec 								; subtract 3 more
.12e0	98		tya				tya
.12e1	e9 03		sbc #$03			sbc 	#3
.12e3	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.12e6	85 2e		sta $2e				sta 	zsTemp
.12e8	68		pla				pla
.12e9	e9 00		sbc #$00			sbc 	#0
.12eb	8d 03 04	sta $0403			sta 	stringHighMemory+1
.12ee	85 2f		sta $2f				sta 	zsTemp+1
.12f0	a5 2a		lda $2a				lda 	zTemp1 						; set max length.
.12f2	92 2e		sta ($2e)			sta 	(zsTemp)
.12f4	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.12f6	a9 00		lda #$00			lda 	#0
.12f8	91 2e		sta ($2e),y			sta 	(zsTemp),y
.12fa	a5 2e		lda $2e				lda 	zsTemp 						; new empty string in YA.
.12fc	a4 2f		ldy $2f				ldy 	zsTemp+1
.12fe	60		rts				rts
.12ff					CommandData:
.12ff	fa		plx				plx
.1300	98		tya				tya 								; data length +1 added to Y
.1301	38		sec				sec
.1302	71 22		adc ($22),y			adc 	(codePtr),y 				; next instruction
.1304	a8		tay				tay
.1305	4c 22 10	jmp $1022			jmp 	NextCommand
.1308					CommandDIM:
.1308	fa		plx				plx
.1309	5a		phy				phy
.130a	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.130d	8d 05 04	sta $0405			sta 	dimType
.1310	ca		dex				dex 								; this is the number of indices
.1311	20 5c 19	jsr $195c			jsr 	GetInteger8Bit
.1314	85 2a		sta $2a				sta 	zTemp1 						; subtract n from X so X points at the *first*
.1316	8a		txa				txa 								; dimension.
.1317	38		sec				sec
.1318	e5 2a		sbc $2a				sbc 	zTemp1
.131a	aa		tax				tax
.131b	a5 2a		lda $2a				lda 	zTemp1 						; number of indices.
.131d	20 31 13	jsr $1331			jsr 	DIMCreateOneLevel 			; create one at this level
.1320	95 40		sta $40,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.1322	98		tya				tya
.1323	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1325	74 58		stz $58,x			stz 	NSMantissa2,x
.1327	74 64		stz $64,x			stz 	NSMantissa3,x
.1329	74 34		stz $34,x			stz 	NSStatus,x
.132b	74 70		stz $70,x			stz 	NSExponent,x
.132d	7a		ply				ply
.132e	4c 22 10	jmp $1022			jmp 	NextCommand
.1331					DIMCreateOneLevel:
.1331	a4 32		ldy $32				ldy 	availableMemory 			; push the start of this block on the stack.
.1333	5a		phy				phy
.1334	a4 33		ldy $33				ldy 	availableMemory+1
.1336	5a		phy				phy
.1337	a8		tay				tay 			 					; save current level into Y
.1338	20 62 19	jsr $1962			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.133b	e6 28		inc $28				inc 	zTemp0 						; bump the size of the dimension as we need one more
.133d	d0 02		bne $1341			bne 	_DCOLNoCarry
.133f	e6 29		inc $29				inc 	zTemp0+1
.1341					_DCOLNoCarry:
.1341	a5 28		lda $28				lda 	zTemp0 						; write out the +1 size of the dimension
.1343	20 e3 13	jsr $13e3			jsr 	DIMWriteByte
.1346	a5 29		lda $29				lda 	zTemp0+1
.1348	20 e3 13	jsr $13e3			jsr 	DIMWriteByte
.134b	ad 05 04	lda $0405			lda 	dimType 					; get type information
.134e	29 7f		and #$7f			and 	#$7F
.1350	c0 01		cpy #$01			cpy 	#1
.1352	f0 02		beq $1356			beq 	_DCOLNoSubLevel
.1354	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.1356					_DCOLNoSubLevel:
.1356	20 e3 13	jsr $13e3			jsr 	DIMWriteByte
.1359	a5 32		lda $32				lda 	availableMemory
.135b	85 2a		sta $2a				sta 	zTemp1
.135d	a5 33		lda $33				lda 	availableMemory+1
.135f	85 2b		sta $2b				sta 	zTemp1+1
.1361	a5 28		lda $28				lda 	zTemp0
.1363	85 2c		sta $2c				sta 	zTemp2
.1365	a5 29		lda $29				lda 	zTemp0+1
.1367	85 2d		sta $2d				sta 	zTemp2+1
.1369					_DCOLFillArray:
.1369	20 c7 13	jsr $13c7			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.136c	a5 28		lda $28				lda 	zTemp0 						; decrement one from count.
.136e	d0 02		bne $1372			bne 	_DCOLNoBorrow
.1370	c6 29		dec $29				dec 	zTemp0+1
.1372					_DCOLNoBorrow:
.1372	c6 28		dec $28				dec 	zTemp0
.1374	a5 28		lda $28				lda 	zTemp0 						; until completed.
.1376	05 29		ora $29				ora 	zTemp0+1
.1378	d0 ef		bne $1369			bne 	_DCOLFillArray
.137a	c0 01		cpy #$01			cpy 	#1
.137c	f0 42		beq $13c0			beq 	_DCOLExit
.137e					_DCOLRecursionLoop:
.137e	da		phx				phx 								; save XY
.137f	5a		phy				phy
.1380	a5 2a		lda $2a				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.1382	48		pha				pha
.1383	a5 2b		lda $2b				lda 	zTemp1+1
.1385	48		pha				pha
.1386	a5 2c		lda $2c				lda 	zTemp2
.1388	48		pha				pha
.1389	a5 2d		lda $2d				lda 	zTemp2+1
.138b	48		pha				pha
.138c	88		dey				dey  								; lower level -> A
.138d	98		tya				tya
.138e	e8		inx				inx 								; next index size
.138f	20 31 13	jsr $1331			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.1392	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.1393	86 2d		stx $2d				stx 	zTemp2+1
.1395	fa		plx				plx
.1396	86 2c		stx $2c				stx 	zTemp2
.1398	fa		plx				plx
.1399	86 2b		stx $2b				stx 	zTemp1+1
.139b	fa		plx				plx
.139c	86 2a		stx $2a				stx 	zTemp1
.139e	92 2a		sta ($2a)			sta 	(zTemp1) 					; write out position
.13a0	98		tya				tya
.13a1	a0 01		ldy #$01			ldy 	#1
.13a3	91 2a		sta ($2a),y			sta 	(zTemp1),y
.13a5	7a		ply				ply 								; restore XY
.13a6	fa		plx				plx
.13a7	18		clc				clc
.13a8	a5 2a		lda $2a				lda 	zTemp1 						; add 2 to zTemp1
.13aa	69 02		adc #$02			adc 	#2
.13ac	85 2a		sta $2a				sta 	zTemp1
.13ae	90 02		bcc $13b2			bcc 	_DCOLRNoCarry
.13b0	e6 2b		inc $2b				inc 	zTemp1+1
.13b2					_DCOLRNoCarry:
.13b2	a5 2c		lda $2c				lda 	zTemp2 						; decrement one from count in zTemp2
.13b4	d0 02		bne $13b8			bne 	_DCOLRNoBorrow
.13b6	c6 2d		dec $2d				dec 	zTemp2+1
.13b8					_DCOLRNoBorrow:
.13b8	c6 2c		dec $2c				dec 	zTemp2
.13ba	a5 2c		lda $2c				lda 	zTemp2 						; until completed.
.13bc	05 2d		ora $2d				ora 	zTemp2+1
.13be	d0 be		bne $137e			bne 	_DCOLRecursionLoop
.13c0					_DCOLExit:
.13c0	68		pla				pla 								; get MSB, make offset again
.13c1	38		sec				sec
.13c2	e9 80		sbc #$80			sbc 	#WorkArea >> 8
.13c4	a8		tay				tay
.13c5	68		pla				pla 								; YA now contains offset address.
.13c6	60		rts				rts
.13c7					DIMWriteElement:
.13c7	da		phx				phx
.13c8	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.13ca	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.13cc	d0 0b		bne $13d9			bne 	_DIMWENotFloat
.13ce	ad 05 04	lda $0405			lda 	dimType
.13d1	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.13d3	c9 00		cmp #$00			cmp 	#NSSIFloat
.13d5	d0 02		bne $13d9			bne 	_DIMWENotFloat
.13d7	a2 06		ldx #$06			ldx 	#6
.13d9					_DIMWENotFloat:
.13d9	a9 00		lda #$00			lda 	#0
.13db	20 e3 13	jsr $13e3			jsr 	DIMWriteByte
.13de	ca		dex				dex
.13df	d0 f8		bne $13d9			bne 	_DIMWENotFloat
.13e1	fa		plx				plx
.13e2	60		rts				rts
.13e3					DIMWriteByte:
.13e3	92 32		sta ($32)			sta 	(availableMemory)
.13e5	e6 32		inc $32				inc 	availableMemory
.13e7	d0 0b		bne $13f4			bne 	_DIMWBSkip
.13e9	e6 33		inc $33				inc 	availableMemory+1
.13eb	48		pha				pha
.13ec	a5 33		lda $33				lda 	availableMemory+1 			; check out of memory
.13ee	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.13f1	b0 02		bcs $13f5			bcs 	_DIMWBMemory
.13f3	68		pla				pla
.13f4					_DIMWBSkip:
.13f4	60		rts				rts
.13f5					_DIMWBMemory:
.13f5	4c 68 15	jmp $1568		jmp	ErrorV_memory
.0405					dimType:
>0405							.fill 	1
.13f8					CommandEnd:
.13f8	fa		plx				plx
.13f9	86 28		stx $28				stx 	zTemp0
.13fb	4c ff ff	jmp $ffff			jmp 	$FFFF
.13fe					Unimplemented:
.13fe	4c 9b 14	jmp $149b			jmp 	ErrorV_unimplemented
.1401					ErrorHandler:
.1401	98		tya				tya
.1402	18		clc				clc
.1403	65 22		adc $22				adc 	codePtr
.1405	85 22		sta $22				sta 	codePtr
.1407	90 02		bcc $140b			bcc 	_EHNoCarry
.1409	e6 23		inc $23				inc 	codePtr+1
.140b					_EHNoCarry:
.140b	68		pla				pla
.140c	7a		ply				ply
.140d	85 28		sta $28				sta 	zTemp0
.140f	84 29		sty $29				sty 	zTemp0+1
.1411	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.1413	a0 01		ldy #$01			ldy 	#1
.1415					_EHDisplayMsg:
.1415	b1 28		lda ($28),y			lda 	(zTemp0),y
.1417	20 b0 25	jsr $25b0			jsr 	XPrintCharacterToChannel
.141a	c8		iny				iny
.141b	b1 28		lda ($28),y			lda 	(zTemp0),y
.141d	d0 f6		bne $1415			bne 	_EHDisplayMsg
.141f	a9 20		lda #$20			lda 	#32
.1421	20 b0 25	jsr $25b0			jsr 	XPrintCharacterToChannel
.1424	a9 40		lda #$40			lda 	#64
.1426	20 b0 25	jsr $25b0			jsr 	XPrintCharacterToChannel
.1429	a9 20		lda #$20			lda 	#32
.142b	20 b0 25	jsr $25b0			jsr 	XPrintCharacterToChannel
.142e	20 33 14	jsr $1433			jsr 	EHDisplayCodePtr
.1431	80 fe		bra $1431	_EHStop:bra 	_EHStop
.1433					EHDisplayCodePtr:
.1433	a9 20		lda #$20			lda 	#32
.1435	20 b0 25	jsr $25b0			jsr 	XPrintCharacterToChannel
.1438	38		sec				sec
.1439	a5 23		lda $23				lda 	codePtr+1 					; display the p-code address of the error.
.143b	ed 04 04	sbc $0404			sbc 	runtimeHigh
.143e	20 47 14	jsr $1447			jsr 	_EHDisplayHex
.1441	a5 22		lda $22				lda 	codePtr
.1443	20 47 14	jsr $1447			jsr 	_EHDisplayHex
.1446	60		rts				rts
.1447					_EHDisplayHex:
.1447	48		pha				pha
.1448	4a		lsr a				lsr 	a
.1449	4a		lsr a				lsr 	a
.144a	4a		lsr a				lsr 	a
.144b	4a		lsr a				lsr 	a
.144c	20 50 14	jsr $1450			jsr 	_EHDisplayNibble
.144f	68		pla				pla
.1450					_EHDisplayNibble:
.1450	29 0f		and #$0f			and 	#15
.1452	c9 0a		cmp #$0a			cmp 	#10
.1454	90 02		bcc $1458			bcc 	_EHNotHex
.1456	69 06		adc #$06			adc 	#6
.1458					_EHNotHex:
.1458	69 30		adc #$30			adc 	#48
.145a	4c b0 25	jmp $25b0			jmp 	XPrintCharacterToChannel
.145d					ErrorV_range:
.145d	20 01 14	jsr $1401		jsr	ErrorHandler
>1460	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1468	41 4e 47 45 00
.146d					ErrorV_value:
.146d	20 01 14	jsr $1401		jsr	ErrorHandler
>1470	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1478	45 00
.147a					ErrorV_syntax:
.147a	20 01 14	jsr $1401		jsr	ErrorHandler
>147d	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1485	52 52 4f 52 00
.148a					ErrorV_type:
.148a	20 01 14	jsr $1401		jsr	ErrorHandler
>148d	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1495	4d 41 54 43 48 00
.149b					ErrorV_unimplemented:
.149b	20 01 14	jsr $1401		jsr	ErrorHandler
>149e	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>14a6	45 4d 45 4e 54 45 44 00
.14ae					ErrorV_assert:
.14ae	20 01 14	jsr $1401		jsr	ErrorHandler
>14b1	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>14b9	41 49 4c 00
.14bd					ErrorV_line:
.14bd	20 01 14	jsr $1401		jsr	ErrorHandler
>14c0	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>14c8	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.14d4					ErrorV_internal:
.14d4	20 01 14	jsr $1401		jsr	ErrorHandler
>14d7	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>14df	20 45 52 52 4f 52 00
.14e6					ErrorV_divzero:
.14e6	20 01 14	jsr $1401		jsr	ErrorHandler
>14e9	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>14f1	59 20 5a 45 52 4f 00
.14f8					ErrorV_structure:
.14f8	20 01 14	jsr $1401		jsr	ErrorHandler
>14fb	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1503	45 20 49 4d 42 41 4c 41 4e 43 45 00
.150f					ErrorV_stop:
.150f	20 01 14	jsr $1401		jsr	ErrorHandler
>1512	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>151a	53 54 4f 50 50 45 44 00
.1522					ErrorV_data:
.1522	20 01 14	jsr $1401		jsr	ErrorHandler
>1525	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>152d	41 54 41 00
.1531					ErrorV_undeclared:
.1531	20 01 14	jsr $1401		jsr	ErrorHandler
>1534	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>153c	41 52 52 41 59 00
.1542					ErrorV_redefine:
.1542	20 01 14	jsr $1401		jsr	ErrorHandler
>1545	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>154d	44 45 46 49 4e 45 44 00
.1555					ErrorV_index:
.1555	20 01 14	jsr $1401		jsr	ErrorHandler
>1558	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1560	59 20 49 4e 44 45 58 00
.1568					ErrorV_memory:
.1568	20 01 14	jsr $1401		jsr	ErrorHandler
>156b	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>1573	45 4d 4f 52 59 00
.1579					ErrorV_channel:
.1579	20 01 14	jsr $1401		jsr	ErrorHandler
>157c	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>1584	54 50 55 54 20 45 52 52 4f 52 00
.158f					CommandFor:
.158f	fa		plx				plx
.1590	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.1592	20 55 16	jsr $1655			jsr 	StackOpenFrame
.1595	20 93 1a	jsr $1a93			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.1598	a0 07		ldy #$07			ldy 	#7 							; copy step out
.159a	20 f3 15	jsr $15f3			jsr 	CopyTOSToOffsetY
.159d	ca		dex				dex
.159e	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.15a0	20 f3 15	jsr $15f3			jsr 	CopyTOSToOffsetY
.15a3	ca		dex				dex
.15a4	b5 4c		lda $4c,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.15a6	29 80		and #$80			and 	#$80
.15a8	a0 04		ldy #$04			ldy 	#4
.15aa	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.15ac	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy the reference address
.15ae	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.15b0	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.15b2	85 28		sta $28				sta 	zTemp0 						; also to zTemp0
.15b4	c8		iny				iny
.15b5	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.15b7	18		clc				clc
.15b8	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.15ba	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.15bc	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.15be	85 29		sta $29				sta 	zTemp0+1
.15c0	ca		dex				dex 								; throw reference.
.15c1	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.15c3	b1 28		lda ($28),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.15c5	a0 0c		ldy #$0c			ldy 	#12
.15c7	11 30		ora ($30),y			ora 	(runtimeStackPtr),y
.15c9	a0 12		ldy #$12			ldy 	#18
.15cb	11 30		ora ($30),y			ora 	(runtimeStackPtr),y
.15cd	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.15cf	88		dey				dey 								; now the exponents.
.15d0	11 28		ora ($28),y			ora 	(zTemp0),y
.15d2	a0 0b		ldy #$0b			ldy 	#11
.15d4	11 30		ora ($30),y			ora 	(runtimeStackPtr),y
.15d6	a0 11		ldy #$11			ldy 	#17
.15d8	11 30		ora ($30),y			ora 	(runtimeStackPtr),y
.15da	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.15dc	11 30		ora ($30),y			ora 	(runtimeStackPtr),y
.15de	c8		iny				iny
.15df	11 30		ora ($30),y			ora 	(runtimeStackPtr),y
.15e1	c8		iny				iny
.15e2	11 30		ora ($30),y			ora 	(runtimeStackPtr),y
.15e4	d0 08		bne $15ee			bne 	_CFNoOptimise
.15e6	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.15e8	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.15ea	09 40		ora #$40			ora 	#$40
.15ec	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.15ee					_CFNoOptimise:
.15ee	a0 00		ldy #$00			ldy 	#0
.15f0	4c 22 10	jmp $1022			jmp 	NextCommand
.15f3					CopyTOSToOffsetY:
.15f3	b5 40		lda $40,x			lda 	NSMantissa0,x
.15f5	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.15f7	c8		iny				iny
.15f8	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.15fa	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.15fc	c8		iny				iny
.15fd	b5 58		lda $58,x			lda 	NSMantissa2,x
.15ff	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.1601	c8		iny				iny
.1602	b5 64		lda $64,x			lda 	NSMantissa3,x
.1604	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.1606	c8		iny				iny
.1607	b5 70		lda $70,x			lda 	NSExponent,x
.1609	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.160b	c8		iny				iny
.160c	b5 34		lda $34,x			lda 	NSStatus,x
.160e	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.1610	60		rts				rts
.1611					MoveObjectForward:
.1611	b2 25		lda ($25)			lda 	(objPtr) 					; get next
.1613	c9 ff		cmp #$ff			cmp 	#$FF
.1615	f0 36		beq $164d			beq 	_MOFEnd
.1617	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.1619	90 24		bcc $163f			bcc 	_MOFAdvance1 				; forward 1
.161b	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.161d	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.161f	90 20		bcc $1641			bcc 	_MOFAdvanceY
.1621	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.1623	90 1a		bcc $163f			bcc 	_MOFAdvance1 				; forward 1
.1625	a8		tay				tay 								; read the size.
.1626	b9 76 1b	lda $1b76,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.1629	a8		tay				tay
.162a	c8		iny				iny 								; add 1 for the system token.
.162b	d0 14		bne $1641			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.162d	a0 01		ldy #$01			ldy 	#1 							; get length byte
.162f	b1 25		lda ($25),y			lda 	(objPtr),y
.1631	a8		tay				tay 								; into Y.
.1632	18		clc				clc
.1633	a5 25		lda $25				lda 	objPtr						; add 2 to the object pointer
.1635	69 02		adc #$02			adc 	#2
.1637	85 25		sta $25				sta 	objPtr
.1639	90 02		bcc $163d			bcc 	_MOFNoCarry1
.163b	e6 26		inc $26				inc 	objPtr+1
.163d					_MOFNoCarry1:
.163d	80 02		bra $1641			bra 	_MOFAdvanceY
.163f					_MOFAdvance1:
.163f	a0 01		ldy #$01			ldy 	#1
.1641					_MOFAdvanceY:
.1641	98		tya				tya 								; add X to objPtr
.1642	18		clc				clc
.1643	65 25		adc $25				adc 	objPtr
.1645	85 25		sta $25				sta 	objPtr
.1647	90 02		bcc $164b			bcc 	_MOFNoCarry2
.1649	e6 26		inc $26				inc 	objPtr+1
.164b					_MOFNoCarry2:
.164b	18		clc				clc 								; not completed.
.164c	60		rts				rts
.164d					_MOFEnd:
.164d	e6 25		inc $25				inc 	objPtr
.164f	d0 02		bne $1653			bne 	_MOFENoCarry
.1651	e6 26		inc $26				inc 	objPtr+1
.1653					_MOFENoCarry:
.1653	38		sec				sec
.1654	60		rts				rts
.1655					StackOpenFrame:
.1655	48		pha				pha 								; save frame marker
.1656	29 1f		and #$1f			and 	#$1F 						; bytes required.
.1658	85 28		sta $28				sta 	zTemp0
.165a	38		sec				sec 								; subtract from runtime stack pointer.
.165b	a5 30		lda $30				lda		runtimeStackPtr
.165d	e5 28		sbc $28				sbc 	zTemp0
.165f	85 30		sta $30				sta 	runtimeStackPtr
.1661	a5 31		lda $31				lda		runtimeStackPtr+1
.1663	e9 00		sbc #$00			sbc 	#0
.1665	85 31		sta $31				sta 	runtimeStackPtr+1
.1667	68		pla				pla 								; put frame marker at +0
.1668	92 30		sta ($30)			sta 	(runtimeStackPtr)
.166a	60		rts				rts
.166b					StackCloseFrame:
.166b	b2 30		lda ($30)			lda 	(runtimeStackPtr)			; get frame marker
.166d	29 1f		and #$1f			and 	#$1F 						; size
.166f	18		clc				clc
.1670	65 30		adc $30				adc 	runtimeStackPtr
.1672	85 30		sta $30				sta 	runtimeStackPtr
.1674	90 02		bcc $1678			bcc 	_SCFNoCarry
.1676	e6 31		inc $31				inc 	runtimeStackPtr+1
.1678					_SCFNoCarry:
.1678	60		rts				rts
.1679					StackFindFrame:
.1679	8d 06 04	sta $0406			sta 	requiredFrame
.167c					_SFFLoop:
.167c	b2 30		lda ($30)			lda 	(runtimeStackPtr) 			; get TOS
.167e	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.1680	f0 10		beq $1692			beq 	SCFFail
.1682	cd 06 04	cmp $0406			cmp 	requiredFrame 				; found this type ?
.1685	f0 05		beq $168c			beq 	_SFFFound
.1687	20 6b 16	jsr $166b			jsr 	StackCloseFrame 			; close the top frame
.168a	80 f0		bra $167c			bra 	_SFFLoop 					; and try te next.
.168c					_SFFFound:
.168c	60		rts				rts
.168d					StackCheckFrame:
.168d	d2 30		cmp ($30)			cmp 	(runtimeStackPtr) 			; matches current frame
.168f	d0 01		bne $1692			bne 	SCFFail
.1691	60		rts				rts
.1692					SCFFail:
.1692	4c f8 14	jmp $14f8		jmp	ErrorV_structure
.0406					requiredFrame:
>0406							.fill 	1
.1695					UnaryFre:
.1695	fa		plx				plx
.1696	20 ed 2d	jsr $2ded			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.1699	38		sec				sec
.169a	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.169d	ed 00 04	sbc $0400			sbc 	stringLowMemory
.16a0	95 40		sta $40,x			sta		NSMantissa0,x
.16a2	ad 03 04	lda $0403			lda 	stringHighMemory+1
.16a5	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.16a8	95 4c		sta $4c,x			sta		NSMantissa1,x
.16aa	4c 22 10	jmp $1022			jmp 	NextCommand
.16ad					CommandGet:
.16ad	fa		plx				plx
.16ae	e8		inx				inx
.16af	a9 01		lda #$01			lda 	#1 							; 1 character space
.16b1	20 3e 20	jsr $203e			jsr 	StringAllocTemp
.16b4	20 a7 1c	jsr $1ca7			jsr 	VectorGetCharacter 			; get a character
.16b7	c9 00		cmp #$00			cmp 	#0
.16b9	f0 09		beq $16c4			beq 	_CGNone
.16bb	5a		phy				phy
.16bc	a0 01		ldy #$01			ldy 	#1 							; store char
.16be	91 2e		sta ($2e),y			sta 	(zsTemp),y
.16c0	98		tya				tya 								; store length.
.16c1	92 2e		sta ($2e)			sta 	(zsTemp)
.16c3	7a		ply				ply
.16c4					_CGNone:
.16c4	4c 22 10	jmp $1022			jmp 	NextCommand
.16c7					CommandGosub:
.16c7	fa		plx				plx
.16c8	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.16ca	20 55 16	jsr $1655			jsr 	StackOpenFrame
.16cd	20 93 1a	jsr $1a93			jsr 	StackSaveCurrentPosition
.16d0	4c e6 16	jmp $16e6			jmp 	PerformGOTO
.16d3					CommandReturn:
.16d3	fa		plx				plx
.16d4	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.16d6	20 79 16	jsr $1679			jsr 	StackFindFrame
.16d9	20 a9 1a	jsr $1aa9			jsr 	StackLoadCurrentPosition
.16dc	c8		iny				iny
.16dd	c8		iny				iny
.16de	c8		iny				iny
.16df	20 6b 16	jsr $166b			jsr 	StackCloseFrame
.16e2	4c 22 10	jmp $1022			jmp 	NextCommand
.16e5					CommandGoto:
.16e5	fa		plx				plx
.16e6					PerformGOTO:
.16e6	c8		iny				iny
.16e7	c8		iny				iny 								; push MSB of offset on stack
.16e8	b1 22		lda ($22),y			lda 	(codePtr),y
.16ea	48		pha				pha
.16eb	88		dey				dey 								; point LSB of offset
.16ec	18		clc				clc 								; add LSB
.16ed	b1 22		lda ($22),y			lda 	(codePtr),y
.16ef	65 22		adc $22				adc 	codePtr
.16f1	85 22		sta $22				sta 	codePtr
.16f3	68		pla				pla 								; restore offset MSB and add
.16f4	65 23		adc $23				adc 	codePtr+1
.16f6	85 23		sta $23				sta 	codePtr+1
.16f8	88		dey				dey 								; fix up.
.16f9	4c 22 10	jmp $1022			jmp 	NextCommand
.16fc					CommandGotoZ:
.16fc	fa		plx				plx
.16fd	20 0f 2e	jsr $2e0f			jsr 	FloatIsZero
.1700	ca		dex				dex
.1701	c9 00		cmp #$00			cmp 	#0
.1703	f0 e1		beq $16e6			beq 	PerformGOTO
.1705	c8		iny				iny
.1706	c8		iny				iny
.1707	c8		iny				iny
.1708	4c 22 10	jmp $1022			jmp 	NextCommand
.170b					CommandGotoNZ:
.170b	fa		plx				plx
.170c	20 0f 2e	jsr $2e0f			jsr 	FloatIsZero
.170f	ca		dex				dex
.1710	c9 00		cmp #$00			cmp 	#0
.1712	d0 d2		bne $16e6			bne 	PerformGOTO
.1714	c8		iny				iny
.1715	c8		iny				iny
.1716	c8		iny				iny
.1717	4c 22 10	jmp $1022			jmp 	NextCommand
.171a					Command_PSET:
.171a	fa		plx				plx
.171b	5a		phy				phy
.171c	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; get the colour
.171f	48		pha				pha
.1720	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.1722	a0 02		ldy #$02			ldy 	#X16_r0
.1724	20 a6 17	jsr $17a6			jsr 	GraphicsCopy2
.1727	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.172a	68		pla				pla 								; set pixel.
.172b	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.172e	7a		ply				ply
.172f	a2 ff		ldx #$ff			ldx 	#$FF
.1731	4c 22 10	jmp $1022			jmp 	NextCommand
.1734					Command_LINE:
.1734	fa		plx				plx
.1735	5a		phy				phy
.1736	20 99 17	jsr $1799			jsr 	GraphicsColour
.1739	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.173b	a0 02		ldy #$02			ldy 	#X16_r0
.173d	20 a3 17	jsr $17a3			jsr 	GraphicsCopy4
.1740	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.1743	7a		ply				ply
.1744	a2 ff		ldx #$ff			ldx 	#$FF
.1746	4c 22 10	jmp $1022			jmp 	NextCommand
.1749					Command_RECT:
.1749	fa		plx				plx
.174a	5a		phy				phy
.174b	20 ba 17	jsr $17ba			jsr 	GraphicsRectCoords
.174e	38		sec				sec
.174f	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.1752	7a		ply				ply
.1753	a2 ff		ldx #$ff			ldx 	#$FF
.1755	4c 22 10	jmp $1022			jmp 	NextCommand
.1758					Command_FRAME:
.1758	fa		plx				plx
.1759	5a		phy				phy
.175a	20 ba 17	jsr $17ba			jsr 	GraphicsRectCoords
.175d	18		clc				clc
.175e	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.1761	7a		ply				ply
.1762	a2 ff		ldx #$ff			ldx 	#$FF
.1764	4c 22 10	jmp $1022			jmp 	NextCommand
.1767					Command_CHAR:
.1767	fa		plx				plx
.1768	5a		phy				phy
.1769	ca		dex				dex  								; set the draw colour
.176a	20 99 17	jsr $1799			jsr 	GraphicsColour
.176d	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.176f	a0 02		ldy #$02			ldy 	#X16_r0
.1771	20 a6 17	jsr $17a6			jsr 	GraphicsCopy2
.1774	a5 43		lda $43				lda 	NSMantissa0+3 				; copy string address to zTemp0
.1776	85 28		sta $28				sta 	zTemp0
.1778	a5 4f		lda $4f				lda 	NSMantissa1+3
.177a	85 29		sta $29				sta 	zTemp0+1
.177c	b2 28		lda ($28)			lda 	(zTemp0) 					; count of chars to zTemp1
.177e	85 2a		sta $2a				sta 	zTemp1
.1780					_CCLoop:
.1780	a5 2a		lda $2a				lda 	zTemp1 						; done all chars ?
.1782	f0 0f		beq $1793			beq 	_CCExit
.1784	c6 2a		dec $2a				dec 	zTemp1 						; dec counter
.1786	e6 28		inc $28				inc 	zTemp0 						; pre-bump pointer
.1788	d0 02		bne $178c			bne 	_CCNoCarry
.178a	e6 29		inc $29				inc 	zTemp0+1
.178c					_CCNoCarry:
.178c	b2 28		lda ($28)			lda 	(zTemp0) 					; get character
.178e	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.1791	80 ed		bra $1780			bra 	_CCLoop						; go round.
.1793					_CCExit:
.1793	7a		ply				ply
.1794	a2 ff		ldx #$ff			ldx 	#$FF
.1796	4c 22 10	jmp $1022			jmp 	NextCommand
.1799					GraphicsColour:
.1799	20 5c 19	jsr $195c			jsr 	GetInteger8Bit
.179c	aa		tax				tax
.179d	a0 00		ldy #$00			ldy 	#0
.179f	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.17a2	60		rts				rts
.17a3					GraphicsCopy4:
.17a3	20 a6 17	jsr $17a6			jsr 	GraphicsCopy2
.17a6					GraphicsCopy2:
.17a6	20 a9 17	jsr $17a9			jsr 	GraphicsCopy1
.17a9					GraphicsCopy1:
.17a9	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.17ac	b5 40		lda $40,x			lda 	NSMantissa0,x
.17ae	99 00 00	sta $0000,y			sta 	0,y
.17b1	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.17b3	99 01 00	sta $0001,y			sta 	1,y
.17b6	e8		inx				inx
.17b7	c8		iny				iny
.17b8	c8		iny				iny
.17b9	60		rts				rts
.17ba					GraphicsRectCoords:
.17ba	20 99 17	jsr $1799			jsr 	GraphicsColour 				; set colour
.17bd	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.17bf	a0 02		ldy #$02			ldy 	#X16_r0
.17c1	20 a3 17	jsr $17a3			jsr 	GraphicsCopy4
.17c4	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.17c6	20 d3 17	jsr $17d3			jsr 	_GRCSortSubtract
.17c9	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.17cb	20 d3 17	jsr $17d3			jsr 	_GRCSortSubtract
.17ce	74 08		stz $08,x			stz 	8,x 						; zero rounding
.17d0	74 09		stz $09,x			stz 	9,x
.17d2	60		rts				rts
.17d3					_GRCSortSubtract:
.17d3	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.17d5	d5 00		cmp $00,x			cmp 	0,x
.17d7	b5 05		lda $05,x			lda 	5,x
.17d9	f5 01		sbc $01,x			sbc 	1,x
.17db	b0 08		bcs $17e5			bcs 	_GRCNoSwap 					; >= swap.
.17dd	20 f3 17	jsr $17f3			jsr 	_GRCSwapByte 				; swap 0/2
.17e0	e8		inx				inx
.17e1	20 f3 17	jsr $17f3			jsr 	_GRCSwapByte 				; swap 1/3
.17e4	ca		dex				dex
.17e5					_GRCNoSwap:
.17e5	38		sec				sec 								; calculate width/height into 4,5
.17e6	b5 04		lda $04,x			lda 	4,x
.17e8	f5 00		sbc $00,x			sbc 	0,x
.17ea	95 04		sta $04,x			sta 	4,x
.17ec	b5 05		lda $05,x			lda 	5,x
.17ee	f5 01		sbc $01,x			sbc 	1,x
.17f0	95 05		sta $05,x			sta 	5,x
.17f2	60		rts				rts
.17f3					_GRCSwapByte:
.17f3	b5 04		lda $04,x			lda 	4,x
.17f5	48		pha				pha
.17f6	b5 00		lda $00,x			lda 	0,x
.17f8	95 04		sta $04,x			sta 	4,x
.17fa	68		pla				pla
.17fb	95 00		sta $00,x			sta 	0,x
.17fd	60		rts				rts
.17fe					Unary16Hex:
.17fe	fa		plx				plx
.17ff	20 62 19	jsr $1962			jsr 	GetInteger16Bit
.1802	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.1804	20 3e 20	jsr $203e			jsr 	StringAllocTemp
.1807	a5 29		lda $29				lda 	zTemp0+1
.1809	f0 03		beq $180e			beq 	_UHNoHigh
.180b	20 16 18	jsr $1816			jsr 	_UHWriteHex
.180e					_UHNoHigh:
.180e	a5 28		lda $28				lda 	zTemp0
.1810	20 16 18	jsr $1816			jsr 	_UHWriteHex
.1813	4c 22 10	jmp $1022			jmp 	NextCommand
.1816					_UHWriteHex:
.1816	48		pha				pha
.1817	4a		lsr a				lsr 	a
.1818	4a		lsr a				lsr 	a
.1819	4a		lsr a				lsr 	a
.181a	4a		lsr a				lsr 	a
.181b	20 1f 18	jsr $181f			jsr 	_UHWriteNibl
.181e	68		pla				pla
.181f					_UHWriteNibl:
.181f	29 0f		and #$0f			and 	#15
.1821	c9 0a		cmp #$0a			cmp 	#10
.1823	90 02		bcc $1827			bcc 	_UHDigit
.1825	69 06		adc #$06			adc 	#6
.1827					_UHDigit:
.1827	69 30		adc #$30			adc 	#48
.1829	20 67 20	jsr $2067			jsr 	StringWriteChar
.182c	60		rts				rts
.182d					IndFloatRead:
.182d	fa		plx				plx
.182e	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy address
.1830	85 28		sta $28				sta 	zTemp0
.1832	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.1834	18		clc				clc
.1835	69 80		adc #$80			adc 	#(WorkArea >> 8)
.1837	85 29		sta $29				sta 	zTemp0+1
.1839	ca		dex				dex 								; throw the address
.183a	20 1f 1e	jsr $1e1f			jsr 	ReadFloatZTemp0Sub 							; call read routine
.183d	4c 22 10	jmp $1022			jmp 	NextCommand
.1840					IndInt16Read:
.1840	fa		plx				plx
.1841	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy address
.1843	85 28		sta $28				sta 	zTemp0
.1845	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.1847	18		clc				clc
.1848	69 80		adc #$80			adc 	#(WorkArea >> 8)
.184a	85 29		sta $29				sta 	zTemp0+1
.184c	ca		dex				dex 								; throw the address
.184d	20 5a 1e	jsr $1e5a			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.1850	4c 22 10	jmp $1022			jmp 	NextCommand
.1853					IndStringRead:
.1853	fa		plx				plx
.1854	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy address
.1856	85 28		sta $28				sta 	zTemp0
.1858	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.185a	18		clc				clc
.185b	69 80		adc #$80			adc 	#(WorkArea >> 8)
.185d	85 29		sta $29				sta 	zTemp0+1
.185f	ca		dex				dex 								; throw the address
.1860	20 9e 1e	jsr $1e9e			jsr 	ReadStringZTemp0Sub 							; call read routine
.1863	4c 22 10	jmp $1022			jmp 	NextCommand
.1866					IndFloatWrite:
.1866	fa		plx				plx
.1867	b5 3f		lda $3f,x			lda 	NSMantissa0-1,x 			; copy address
.1869	85 28		sta $28				sta 	zTemp0
.186b	b5 4b		lda $4b,x			lda 	NSMantissa1-1,x
.186d	18		clc				clc
.186e	69 80		adc #$80			adc 	#(WorkArea >> 8)
.1870	85 29		sta $29				sta 	zTemp0+1
.1872	20 f7 23	jsr $23f7			jsr 	WriteFloatZTemp0Sub 							; call write routine
.1875	ca		dex				dex 								; throw the address as well.
.1876	4c 22 10	jmp $1022			jmp 	NextCommand
.1879					IndInt16Write:
.1879	fa		plx				plx
.187a	b5 3f		lda $3f,x			lda 	NSMantissa0-1,x 			; copy address
.187c	85 28		sta $28				sta 	zTemp0
.187e	b5 4b		lda $4b,x			lda 	NSMantissa1-1,x
.1880	18		clc				clc
.1881	69 80		adc #$80			adc 	#(WorkArea >> 8)
.1883	85 29		sta $29				sta 	zTemp0+1
.1885	20 32 24	jsr $2432			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.1888	ca		dex				dex 								; throw the address as well.
.1889	4c 22 10	jmp $1022			jmp 	NextCommand
.188c					IndStringWrite:
.188c	fa		plx				plx
.188d	b5 3f		lda $3f,x			lda 	NSMantissa0-1,x 			; copy address
.188f	85 28		sta $28				sta 	zTemp0
.1891	b5 4b		lda $4b,x			lda 	NSMantissa1-1,x
.1893	18		clc				clc
.1894	69 80		adc #$80			adc 	#(WorkArea >> 8)
.1896	85 29		sta $29				sta 	zTemp0+1
.1898	20 70 24	jsr $2470			jsr 	WriteStringZTemp0Sub 							; call write routine
.189b	ca		dex				dex 								; throw the address as well.
.189c	4c 22 10	jmp $1022			jmp 	NextCommand
.189f					CommandInput:
.189f	fa		plx				plx
.18a0	5a		phy				phy 								; save Y
.18a1	e8		inx				inx									; space on stack
.18a2					_INError:
.18a2	20 d6 18	jsr $18d6			jsr 	InputStringToBuffer 		; input from keyboard
.18a5	a9 5c		lda #$5c			lda 	#((ReadBufferSize) & $FF)
.18a7	85 28		sta $28				sta 	0+zTemp0
.18a9	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.18ab	85 29		sta $29				sta 	1+zTemp0
.18ad	20 85 22	jsr $2285			jsr 	ValEvaluateZTemp0
.18b0	b0 f0		bcs $18a2			bcs 	_INError 					; failed, try again.
.18b2	7a		ply				ply 								; restore Y
.18b3	4c 22 10	jmp $1022			jmp 	NextCommand
.18b6					CommandInputString:
.18b6	fa		plx				plx
.18b7	5a		phy				phy 								; save Y
.18b8	20 d6 18	jsr $18d6			jsr 	InputStringToBuffer 		; input from keyboard
.18bb	e8		inx				inx 								; make space on stack
.18bc	20 ed 2d	jsr $2ded			jsr 	FloatSetZero 				; store as string on stack
.18bf	a9 5c		lda #$5c			lda 	#ReadBufferSize & $FF
.18c1	95 40		sta $40,x			sta 	NSMantissa0,x
.18c3	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.18c5	95 4c		sta $4c,x			sta 	NSMantissa1,x
.18c7	a9 40		lda #$40			lda 	#NSSString
.18c9	95 34		sta $34,x			sta 	NSStatus,x
.18cb	7a		ply				ply 								; restore Y
.18cc	4c 22 10	jmp $1022			jmp 	NextCommand
.18cf					CommandInputReset:
.18cf	fa		plx				plx
.18d0	9c 07 04	stz $0407			stz 	InputBuffer
.18d3	4c 22 10	jmp $1022			jmp 	NextCommand
.18d6					InputStringToBuffer:
.18d6	a9 10		lda #$10			lda 	#((InputBumpNext) & $FF)
.18d8	8d 5c 05	sta $055c			sta 	0+ReadBumpNextVec
.18db	a9 19		lda #$19			lda 	#((InputBumpNext) >> 8) & $FF
.18dd	8d 5d 05	sta $055d			sta 	1+ReadBumpNextVec
.18e0	a9 ed		lda #$ed			lda 	#((InputLookNext) & $FF)
.18e2	8d 5e 05	sta $055e			sta 	0+ReadLookNextVec
.18e5	a9 18		lda #$18			lda 	#((InputLookNext) >> 8) & $FF
.18e7	8d 5f 05	sta $055f			sta 	1+ReadLookNextVec
.18ea	4c 7d 1d	jmp $1d7d			jmp 	GetStringToBuffer
.18ed					InputLookNext:
.18ed	da		phx				phx
.18ee					_ILNRetry:
.18ee	ad 07 04	lda $0407			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.18f1	d0 08		bne $18fb			bne 	_ILNNotEmpty
.18f3	20 14 19	jsr $1914			jsr 	InputGetNewLine 			; get a new line
.18f6	9c 58 04	stz $0458			stz 	InputBufferPos 				; reset read position.
.18f9	80 f3		bra $18ee			bra 	_ILNRetry
.18fb					_ILNNotEmpty:
.18fb	ae 58 04	ldx $0458			ldx 	InputBufferPos 				; get head available character
.18fe	bd 07 04	lda $0407,x			lda 	InputBuffer,x
.1901	d0 08		bne $190b			bne 	_ILNExit 					; if not EOS return it with CC.
.1903					_ILNNextLine:
.1903	9c 07 04	stz $0407			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.1906	38		sec				sec 								; return CS,Zero
.1907	fa		plx				plx
.1908	a9 0d		lda #$0d			lda 	#13
.190a	60		rts				rts
.190b					_ILNExit:
.190b	fa		plx				plx
.190c	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.190e	18		clc				clc
.190f	60		rts				rts
.1910					InputBumpNext:
.1910	ee 58 04	inc $0458			inc 	InputBufferPos
.1913	60		rts				rts
.1914					InputGetNewLine:
.1914	48		pha				pha
.1915	da		phx				phx
.1916	5a		phy				phy
.1917	a9 3f		lda #$3f			lda 	#"?"
.1919	20 53 19	jsr $1953			jsr 	IGNLEchoIfScreen
.191c	a0 00		ldy #$00			ldy 	#0 							; line position.
.191e					_IGNLLoop:
.191e	20 a7 1c	jsr $1ca7			jsr 	VectorGetCharacter 			; get a character
.1921	c9 00		cmp #$00			cmp 	#0
.1923	f0 f9		beq $191e			beq 	_IGNLLoop
.1925	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.1927	f0 11		beq $193a			beq 	_IGNBackspace
.1929	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.192b	f0 17		beq $1944			beq 	_IGNExit
.192d	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.192f	f0 ed		beq $191e			beq 	_IGNLLoop
.1931	99 07 04	sta $0407,y			sta 	InputBuffer,y
.1934	c8		iny				iny
.1935	20 53 19	jsr $1953			jsr 	IGNLEchoIfScreen
.1938	80 e4		bra $191e			bra 	_IGNLLoop
.193a					_IGNBackspace:
.193a	c0 00		cpy #$00			cpy 	#0
.193c	f0 e0		beq $191e			beq 	_IGNLLoop
.193e	20 53 19	jsr $1953			jsr 	IGNLEchoIfScreen
.1941	88		dey				dey
.1942	80 da		bra $191e			bra 	_IGNLLoop
.1944					_IGNExit:
.1944	20 53 19	jsr $1953			jsr 	IGNLEchoIfScreen
.1947	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.1949	99 07 04	sta $0407,y			sta 	InputBuffer,y
.194c	9c 58 04	stz $0458			stz 	InputBufferPos 				; reset position to start of input buffer.
.194f	7a		ply				ply
.1950	fa		plx				plx
.1951	68		pla				pla
.1952	60		rts				rts
.1953					IGNLEchoIfScreen:
.1953	ae 5a 04	ldx $045a			ldx 	currentChannel
.1956	d0 03		bne $195b			bne 	_IGNLEExit
.1958	20 9e 1c	jsr $1c9e			jsr 	VectorPrintCharacter
.195b					_IGNLEExit:
.195b	60		rts				rts
.0407					InputBuffer:
>0407							.fill 	81
.0458					InputBufferPos:
>0458							.fill 	1
.195c					GetInteger8Bit:
.195c	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.195f	b5 40		lda $40,x			lda 	NSMantissa0,x
.1961	60		rts				rts
.1962					GetInteger16Bit:
.1962	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.1965	34 34		bit $34,x			bit 	NSStatus,x
.1967	30 09		bmi $1972			bmi 	Negate16Bit
.1969	b5 40		lda $40,x			lda 	NSMantissa0,x
.196b	85 28		sta $28				sta 	zTemp0
.196d	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.196f	85 29		sta $29				sta 	zTemp0+1
.1971	60		rts				rts
.1972					Negate16Bit:
.1972	38		sec				sec
.1973	a9 00		lda #$00			lda 	#0
.1975	f5 40		sbc $40,x			sbc 	NSMantissa0,x
.1977	95 40		sta $40,x			sta 	NSMantissa0,x
.1979	85 28		sta $28				sta 	zTemp0
.197b	a9 00		lda #$00			lda 	#0
.197d	f5 4c		sbc $4c,x			sbc 	NSMantissa1,x
.197f	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1981	85 29		sta $29				sta 	zTemp0+1
.1983	60		rts				rts
.1984					UnaryJoy:
.1984	fa		plx				plx
.1985	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; port #
.1988	48		pha				pha 								; zero the result.
.1989	20 ed 2d	jsr $2ded			jsr 	FloatSetZero
.198c	68		pla				pla
.198d	5a		phy				phy
.198e	da		phx				phx
.198f	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1992	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1994	d0 10		bne $19a6			bne 	_UJNoHardware
.1996	a8		tay				tay 								; move XA -> AY
.1997	8a		txa				txa
.1998	fa		plx				plx 								; we can update it now.
.1999	49 ff		eor #$ff			eor 	#$FF
.199b	95 4c		sta $4c,x			sta 	NSMantissa1,x
.199d	98		tya				tya
.199e	49 ff		eor #$ff			eor 	#$FF
.19a0	95 40		sta $40,x			sta 	NSMantissa0,x
.19a2	7a		ply				ply 								; restore Y
.19a3	4c 22 10	jmp $1022			jmp 	NextCommand
.19a6					_UJNoHardware:
.19a6	fa		plx				plx
.19a7	7a		ply				ply
.19a8	a9 01		lda #$01			lda 	#1 							; set result to -1
.19aa	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.19ad	20 af 2d	jsr $2daf			jsr 	FloatNegate
.19b0	4c 22 10	jmp $1022			jmp 	NextCommand
.19b3					UnaryLen:
.19b3	fa		plx				plx
.19b4	b5 40		lda $40,x			lda 	NSMantissa0,x 				; string address.
.19b6	85 28		sta $28				sta 	zTemp0
.19b8	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.19ba	85 29		sta $29				sta 	zTemp0+1
.19bc	b2 28		lda ($28)			lda 	(zTemp0) 					; get length
.19be	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.19c1	4c 22 10	jmp $1022			jmp 	NextCommand
.19c4					LinkFloatAdd:
.19c4	fa		plx				plx
.19c5	5a		phy			phy
.19c6	20 11 28	jsr $2811		jsr	FloatAdd
.19c9	7a		ply			ply
.19ca	4c 22 10	jmp $1022			jmp 	NextCommand
.19cd					LinkFloatSubtract:
.19cd	fa		plx				plx
.19ce	5a		phy			phy
.19cf	20 0b 28	jsr $280b		jsr	FloatSubtract
.19d2	7a		ply			ply
.19d3	4c 22 10	jmp $1022			jmp 	NextCommand
.19d6					LinkFloatMultiply:
.19d6	fa		plx				plx
.19d7	5a		phy			phy
.19d8	20 ad 2a	jsr $2aad		jsr	FloatMultiply
.19db	7a		ply			ply
.19dc	4c 22 10	jmp $1022			jmp 	NextCommand
.19df					LinkFloatDivide:
.19df	fa		plx				plx
.19e0	5a		phy			phy
.19e1	20 36 29	jsr $2936		jsr	FloatDivide
.19e4	b0 5c		bcs $1a42		bcs	DivZeroError
.19e6	7a		ply			ply
.19e7	4c 22 10	jmp $1022			jmp 	NextCommand
.19ea					LinkFloatPower:
.19ea	fa		plx				plx
.19eb	5a		phy			phy
.19ec	20 b6 30	jsr $30b6		jsr	FloatPower
.19ef	b0 4e		bcs $1a3f		bcs	MapRangeError
.19f1	7a		ply			ply
.19f2	4c 22 10	jmp $1022			jmp 	NextCommand
.19f5					LinkCompareGreater:
.19f5	fa		plx				plx
.19f6	5a		phy			phy
.19f7	20 ba 28	jsr $28ba		jsr	CompareGreater
.19fa	7a		ply			ply
.19fb	4c 22 10	jmp $1022			jmp 	NextCommand
.19fe					LinkCompareEqual:
.19fe	fa		plx				plx
.19ff	5a		phy			phy
.1a00	20 9c 28	jsr $289c		jsr	CompareEqual
.1a03	7a		ply			ply
.1a04	4c 22 10	jmp $1022			jmp 	NextCommand
.1a07					LinkCompareLess:
.1a07	fa		plx				plx
.1a08	5a		phy			phy
.1a09	20 b2 28	jsr $28b2		jsr	CompareLess
.1a0c	7a		ply			ply
.1a0d	4c 22 10	jmp $1022			jmp 	NextCommand
.1a10					LinkCompareGreaterEqual:
.1a10	fa		plx				plx
.1a11	5a		phy			phy
.1a12	20 ca 28	jsr $28ca		jsr	CompareGreaterEqual
.1a15	7a		ply			ply
.1a16	4c 22 10	jmp $1022			jmp 	NextCommand
.1a19					LinkCompareNotEqual:
.1a19	fa		plx				plx
.1a1a	5a		phy			phy
.1a1b	20 ac 28	jsr $28ac		jsr	CompareNotEqual
.1a1e	7a		ply			ply
.1a1f	4c 22 10	jmp $1022			jmp 	NextCommand
.1a22					LinkCompareLessEqual:
.1a22	fa		plx				plx
.1a23	5a		phy			phy
.1a24	20 c2 28	jsr $28c2		jsr	CompareLessEqual
.1a27	7a		ply			ply
.1a28	4c 22 10	jmp $1022			jmp 	NextCommand
.1a2b					LinkFloatIntegerPartDown:
.1a2b	fa		plx				plx
.1a2c	5a		phy			phy
.1a2d	20 4c 2a	jsr $2a4c		jsr	FloatIntegerPartDown
.1a30	7a		ply			ply
.1a31	4c 22 10	jmp $1022			jmp 	NextCommand
.1a34					LinkFloatSquareRoot:
.1a34	fa		plx				plx
.1a35	5a		phy			phy
.1a36	20 38 31	jsr $3138		jsr	FloatSquareRoot
.1a39	b0 04		bcs $1a3f		bcs	MapRangeError
.1a3b	7a		ply			ply
.1a3c	4c 22 10	jmp $1022			jmp 	NextCommand
.1a3f					MapRangeError:
.1a3f	4c 5d 14	jmp $145d		jmp	ErrorV_range
.1a42					DivZeroError:
.1a42	4c e6 14	jmp $14e6		jmp	ErrorV_divzero
.1a45					LinkFloatLogarithm:
.1a45	fa		plx				plx
.1a46	5a		phy			phy
.1a47	20 42 30	jsr $3042		jsr	FloatLogarithm
.1a4a	b0 f3		bcs $1a3f		bcs	MapRangeError
.1a4c	7a		ply			ply
.1a4d	4c 22 10	jmp $1022			jmp 	NextCommand
.1a50					LinkFloatExponent:
.1a50	fa		plx				plx
.1a51	5a		phy			phy
.1a52	20 3f 2f	jsr $2f3f		jsr	FloatExponent
.1a55	7a		ply			ply
.1a56	4c 22 10	jmp $1022			jmp 	NextCommand
.1a59					LinkFloatCosine:
.1a59	fa		plx				plx
.1a5a	5a		phy			phy
.1a5b	20 33 2f	jsr $2f33		jsr	FloatCosine
.1a5e	7a		ply			ply
.1a5f	4c 22 10	jmp $1022			jmp 	NextCommand
.1a62					LinkFloatSine:
.1a62	fa		plx				plx
.1a63	5a		phy			phy
.1a64	20 d3 30	jsr $30d3		jsr	FloatSine
.1a67	7a		ply			ply
.1a68	4c 22 10	jmp $1022			jmp 	NextCommand
.1a6b					LinkFloatTangent:
.1a6b	fa		plx				plx
.1a6c	5a		phy			phy
.1a6d	20 44 31	jsr $3144		jsr	FloatTangent
.1a70	7a		ply			ply
.1a71	4c 22 10	jmp $1022			jmp 	NextCommand
.1a74					LinkFloatArcTan:
.1a74	fa		plx				plx
.1a75	5a		phy			phy
.1a76	20 18 2e	jsr $2e18		jsr	FloatArcTan
.1a79	b0 c4		bcs $1a3f		bcs	MapRangeError
.1a7b	7a		ply			ply
.1a7c	4c 22 10	jmp $1022			jmp 	NextCommand
.1a7f					LinkFloatCompare:
.1a7f	fa		plx				plx
.1a80	5a		phy			phy
.1a81	20 d2 28	jsr $28d2		jsr	FloatCompare
.1a84	7a		ply			ply
.1a85	4c 22 10	jmp $1022			jmp 	NextCommand
.1a88					LinkDivideInt32:
.1a88	fa		plx				plx
.1a89	5a		phy			phy
.1a8a	20 60 29	jsr $2960		jsr	DivideInt32
.1a8d	b0 b0		bcs $1a3f		bcs	MapRangeError
.1a8f	7a		ply			ply
.1a90	4c 22 10	jmp $1022			jmp 	NextCommand
.1a93					StackSaveCurrentPosition:
.1a93	20 8d 10	jsr $108d			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.1a96	5a		phy				phy
.1a97	a0 01		ldy #$01			ldy 	#1
.1a99	a5 24		lda $24				lda 	codePage
.1a9b	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.1a9d	c8		iny				iny
.1a9e	a5 22		lda $22				lda 	codePtr
.1aa0	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.1aa2	c8		iny				iny
.1aa3	a5 23		lda $23				lda 	codePtr+1
.1aa5	91 30		sta ($30),y			sta 	(runtimeStackPtr),y
.1aa7	7a		ply				ply
.1aa8	60		rts				rts
.1aa9					StackLoadCurrentPosition:
.1aa9	a0 01		ldy #$01			ldy 	#1
.1aab	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1aad	85 24		sta $24				sta 	codePage
.1aaf	c8		iny				iny
.1ab0	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1ab2	85 22		sta $22				sta 	codePtr
.1ab4	c8		iny				iny
.1ab5	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1ab7	85 23		sta $23				sta 	codePtr+1
.1ab9	a0 00		ldy #$00			ldy 	#0
.1abb	60		rts				rts
.1abc					XCommandMouse:
.1abc	fa		plx				plx
.1abd	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; mouse control.
.1ac0	ca		dex				dex
.1ac1	da		phx				phx
.1ac2	5a		phy				phy
.1ac3	48		pha				pha
.1ac4	38		sec				sec 								; get screen resolution
.1ac5	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1ac8	68		pla				pla
.1ac9	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.1acc	7a		ply				ply
.1acd	fa		plx				plx
.1ace	4c 22 10	jmp $1022			jmp 	NextCommand
.1ad1					XUnaryMB:
.1ad1	fa		plx				plx
.1ad2	20 00 1b	jsr $1b00			jsr 	XUnaryMouseCommon
.1ad5	a5 2c		lda $2c				lda 	zTemp2
.1ad7	e8		inx				inx
.1ad8	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.1adb	4c 22 10	jmp $1022			jmp 	NextCommand
.1ade					XUnaryMX:
.1ade	fa		plx				plx
.1adf	20 00 1b	jsr $1b00			jsr 	XUnaryMouseCommon
.1ae2	a5 28		lda $28				lda 	zTemp0
.1ae4	e8		inx				inx
.1ae5	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.1ae8	a5 29		lda $29				lda 	zTemp0+1
.1aea	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1aec	4c 22 10	jmp $1022			jmp 	NextCommand
.1aef					XUnaryMY:
.1aef	fa		plx				plx
.1af0	20 00 1b	jsr $1b00			jsr 	XUnaryMouseCommon
.1af3	a5 2a		lda $2a				lda 	zTemp1
.1af5	e8		inx				inx
.1af6	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.1af9	a5 2b		lda $2b				lda 	zTemp1+1
.1afb	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1afd	4c 22 10	jmp $1022			jmp 	NextCommand
.1b00					XUnaryMouseCommon:
.1b00	da		phx				phx
.1b01	5a		phy				phy
.1b02	a2 28		ldx #$28			ldx 	#zTemp0
.1b04	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.1b07	85 2c		sta $2c				sta 	zTemp2
.1b09	7a		ply				ply
.1b0a	fa		plx				plx
.1b0b	60		rts				rts
.1b0c					NegateTOS:
.1b0c	fa		plx				plx
.1b0d	20 af 2d	jsr $2daf			jsr 	FloatNegate
.1b10	4c 22 10	jmp $1022			jmp 	NextCommand
.1b13					CommandNewLine:
.1b13	fa		plx				plx
.1b14	9c 65 05	stz $0565			stz 	stringInitialised
.1b17	a2 ff		ldx #$ff			ldx 	#$FF
.1b19	4c 22 10	jmp $1022			jmp 	NextCommand
.1b1c					CommandNext:
.1b1c	fa		plx				plx
.1b1d					_CNRetry:
.1b1d	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.1b1f	20 79 16	jsr $1679			jsr 	StackFindFrame
.1b22	20 8d 10	jsr $108d			jsr 	FixUpY 						; so we can use Y
.1b25	b5 40		lda $40,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.1b27	35 4c		and $4c,x			and 	NSMantissa1,x
.1b29	c9 ff		cmp #$ff			cmp 	#$FF
.1b2b	f0 16		beq $1b43			beq 	_CNNoIndexVariable
.1b2d	b5 40		lda $40,x			lda 	NSMantissa0,x
.1b2f	a0 05		ldy #$05			ldy 	#5
.1b31	d1 30		cmp ($30),y			cmp 	(runtimeStackPtr),y
.1b33	d0 07		bne $1b3c			bne 	_CNNIndexFail
.1b35	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.1b37	c8		iny				iny
.1b38	d1 30		cmp ($30),y			cmp 	(runtimeStackPtr),y
.1b3a	f0 07		beq $1b43			beq 	_CNNoIndexVariable
.1b3c					_CNNIndexFail:
.1b3c	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.1b3e	20 6b 16	jsr $166b			jsr 	StackCloseFrame 			; close this frame
.1b41	80 da		bra $1b1d			bra 	_CNRetry
.1b43					_CNNoIndexVariable:
.1b43	ca		dex				dex
.1b44	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.1b46	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1b48	29 40		and #$40			and 	#$40	 					; bit 6
.1b4a	d0 54		bne $1ba0			bne 	_CNOptimisedNext
.1b4c	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1b4e	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1b50	48		pha				pha
.1b51	85 28		sta $28				sta 	zTemp0
.1b53	c8		iny				iny
.1b54	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1b56	18		clc				clc
.1b57	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.1b59	48		pha				pha
.1b5a	85 29		sta $29				sta 	zTemp0+1
.1b5c	20 1f 1e	jsr $1e1f			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.1b5f	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.1b61	e8		inx				inx
.1b62	20 e2 1b	jsr $1be2			jsr 	CopyOffsetYToTOS
.1b65	20 11 28	jsr $2811			jsr 	FloatAdd
.1b68	68		pla				pla 								; restore address
.1b69	85 29		sta $29				sta 	zTemp0+1
.1b6b	68		pla				pla
.1b6c	85 28		sta $28				sta 	zTemp0
.1b6e	20 f7 23	jsr $23f7			jsr 	WriteFloatZTemp0Sub			; write float.
.1b71	e8		inx				inx  								; recover written
.1b72	e8		inx				inx 								; load offset
.1b73	a0 0d		ldy #$0d			ldy 	#13
.1b75	20 e2 1b	jsr $1be2			jsr 	CopyOffsetYToTOS
.1b78	20 d2 28	jsr $28d2			jsr 	FloatCompare 				; and compare the floats.
.1b7b	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1b7c	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.1b7e	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1b80	30 08		bmi $1b8a			bmi 	_CNDownStep
.1b82	b5 41		lda $41,x			lda 	NSMantissa0+1,x 			; get comparator
.1b84	c9 01		cmp #$01			cmp 	#1 							; gone higher
.1b86	f0 10		beq $1b98			beq 	_CNExitFor 					; if so exit the loop
.1b88	80 06		bra $1b90			bra 	_CNLoopBack
.1b8a					_CNDownStep:
.1b8a	b5 41		lda $41,x			lda 	NSMantissa0+1,x 			; get comparator
.1b8c	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.1b8e	f0 08		beq $1b98			beq 	_CNExitFor
.1b90					_CNLoopBack:
.1b90	20 a9 1a	jsr $1aa9			jsr 	StackLoadCurrentPosition 	; loop back
.1b93	a0 00		ldy #$00			ldy 	#0
.1b95	4c 22 10	jmp $1022			jmp 	NextCommand
.1b98					_CNExitFor:
.1b98	20 6b 16	jsr $166b			jsr 	StackCloseFrame 			; remove the frame and exit
.1b9b	a0 00		ldy #$00			ldy 	#0
.1b9d	4c 22 10	jmp $1022			jmp 	NextCommand
.1ba0					_CNOptimisedNext:
.1ba0	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1ba2	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1ba4	85 28		sta $28				sta 	zTemp0
.1ba6	c8		iny				iny
.1ba7	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1ba9	18		clc				clc
.1baa	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.1bac	85 29		sta $29				sta 	zTemp0+1
.1bae	a0 07		ldy #$07			ldy 	#7 							; STEP value
.1bb0	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1bb2	a0 ff		ldy #$ff			ldy 	#$FF
.1bb4	18		clc				clc
.1bb5					_CNOIncrement:
.1bb5	c8		iny				iny
.1bb6	71 28		adc ($28),y			adc 	(zTemp0),y
.1bb8	91 28		sta ($28),y			sta 	(zTemp0),y
.1bba	f0 f9		beq $1bb5			beq 	_CNOIncrement
.1bbc	18		clc				clc
.1bbd	a5 30		lda $30				lda 	runtimeStackPtr
.1bbf	69 0d		adc #$0d			adc 	#13
.1bc1	85 2a		sta $2a				sta 	zTemp1
.1bc3	a5 31		lda $31				lda 	runtimeStackPtr+1
.1bc5	69 00		adc #$00			adc 	#0
.1bc7	85 2b		sta $2b				sta 	zTemp1+1
.1bc9	a0 00		ldy #$00			ldy 	#0
.1bcb	b1 2a		lda ($2a),y			lda 	(zTemp1),y 					; byte 0
.1bcd	d1 28		cmp ($28),y			cmp 	(zTemp0),y
.1bcf	c8		iny				iny
.1bd0	b1 2a		lda ($2a),y			lda 	(zTemp1),y 					; byte 1
.1bd2	f1 28		sbc ($28),y			sbc 	(zTemp0),y
.1bd4	c8		iny				iny
.1bd5	b1 2a		lda ($2a),y			lda 	(zTemp1),y 					; byte 2
.1bd7	f1 28		sbc ($28),y			sbc 	(zTemp0),y
.1bd9	c8		iny				iny
.1bda	b1 2a		lda ($2a),y			lda 	(zTemp1),y 					; byte 3
.1bdc	f1 28		sbc ($28),y			sbc 	(zTemp0),y
.1bde	90 b8		bcc $1b98			bcc	 	_CNExitFor
.1be0	80 ae		bra $1b90			bra 	_CNLoopBack
.1be2					CopyOffsetYToTOS:
.1be2	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1be4	95 40		sta $40,x			sta 	NSMantissa0,x
.1be6	c8		iny				iny
.1be7	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1be9	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1beb	c8		iny				iny
.1bec	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1bee	95 58		sta $58,x			sta 	NSMantissa2,x
.1bf0	c8		iny				iny
.1bf1	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1bf3	95 64		sta $64,x			sta 	NSMantissa3,x
.1bf5	c8		iny				iny
.1bf6	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1bf8	95 70		sta $70,x			sta 	NSExponent,x
.1bfa	c8		iny				iny
.1bfb	b1 30		lda ($30),y			lda 	(runtimeStackPtr),y
.1bfd	95 34		sta $34,x			sta 	NSStatus,x
.1bff	60		rts				rts
.1c00	4c 22 10	jmp $1022			jmp 	NextCommand
.1c03					NotTOS:
.1c03	fa		plx				plx
.1c04	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.1c07	74 58		stz $58,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.1c09	74 64		stz $64,x			stz 	NSMantissa3,x
.1c0b	20 af 2d	jsr $2daf			jsr 	FloatNegate		 			; negate
.1c0e	e8		inx				inx 								; and subtract 1.
.1c0f	a9 01		lda #$01			lda 	#1
.1c11	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.1c14	20 0b 28	jsr $280b			jsr 	FloatSubtract
.1c17					_NotTOSSkip:
.1c17	4c 22 10	jmp $1022			jmp 	NextCommand
.1c1a					CommandOn:
.1c1a	fa		plx				plx
.1c1b	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.1c1e	8d 59 04	sta $0459			sta 	onCount 					; save it.
.1c21	20 8d 10	jsr $108d			jsr 	FixUpY 						; Y = 0
.1c24					_CONFind:
.1c24	ce 59 04	dec $0459			dec 	onCount 					; reached zero, do this one
.1c27	f0 0c		beq $1c35			beq 	_CONFound
.1c29	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1c2a	c8		iny				iny
.1c2b	c8		iny				iny
.1c2c	c8		iny				iny
.1c2d	b1 22		lda ($22),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.1c2f	c8		iny				iny
.1c30	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.1c32	f0 f0		beq $1c24			beq 	_CONFind
.1c34	88		dey				dey 								; point to character after last GOTO/GOSUB
.1c35					_CONFound:
.1c35	4c 22 10	jmp $1022			jmp 	NextCommand
.1c38					CommandMoreOn:
.1c38	fa		plx				plx
.1c39	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1c3a	c8		iny				iny
.1c3b	c8		iny				iny
.1c3c	c8		iny				iny
.1c3d	4c 22 10	jmp $1022			jmp 	NextCommand
.0459					onCount:
>0459							.fill 	1
.1c40					MOFSizeTable:
>1c40	01					.byte	1         	; $ca .shift
>1c41	01					.byte	1         	; $cb .byte
>1c42	02					.byte	2         	; $cc .word
>1c43	05					.byte	5         	; $cd .float
>1c44	ff					.byte	255       	; $ce .string
>1c45	ff					.byte	255       	; $cf .data
>1c46	03					.byte	3         	; $d0 .goto
>1c47	03					.byte	3         	; $d1 .gosub
>1c48	03					.byte	3         	; $d2 .goto.z
>1c49	03					.byte	3         	; $d3 .goto.nz
>1c4a	02					.byte	2         	; $d4 .varspace
.1c4b					UnaryPeek:
.1c4b	fa		plx				plx
.1c4c	20 62 19	jsr $1962			jsr 	GetInteger16Bit
.1c4f	da		phx				phx
.1c50	5a		phy				phy
.1c51	a6 28		ldx $28				ldx 	zTemp0
.1c53	a4 29		ldy $29				ldy 	zTemp0+1
.1c55	20 86 25	jsr $2586			jsr 	XPeekMemory
.1c58	7a		ply				ply
.1c59	fa		plx				plx
.1c5a	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.1c5d	4c 22 10	jmp $1022			jmp 	NextCommand
.1c60					CommandPOKE:
.1c60	fa		plx				plx
.1c61	da		phx				phx 								; save XY
.1c62	5a		phy				phy
.1c63	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1c66	48		pha				pha
.1c67	b5 4b		lda $4b,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1c69	a8		tay				tay
.1c6a	b5 3f		lda $3f,x			lda 	NSMantissa0-1,x
.1c6c	aa		tax				tax
.1c6d	68		pla				pla
.1c6e	20 72 25	jsr $2572			jsr 	XPokeMemory
.1c71	7a		ply				ply 								; restore YX and drop 2
.1c72	fa		plx				plx
.1c73	ca		dex				dex
.1c74	ca		dex				dex
.1c75	4c 22 10	jmp $1022			jmp 	NextCommand
.1c78					UnaryPos:
.1c78	fa		plx				plx
.1c79	20 05 25	jsr $2505			jsr 	XGetHPos
.1c7c	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.1c7f	4c 22 10	jmp $1022			jmp 	NextCommand
.1c82					GetChannel:
.1c82	fa		plx				plx
.1c83	ad 5a 04	lda $045a			lda 	currentChannel
.1c86	e8		inx				inx
.1c87	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.1c8a	4c 22 10	jmp $1022			jmp 	NextCommand
.1c8d					SetChannel:
.1c8d	fa		plx				plx
.1c8e	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.1c91	b5 40		lda $40,x			lda 	NSMantissa0,x
.1c93	8d 5a 04	sta $045a			sta 	currentChannel
.1c96	ca		dex				dex
.1c97	4c 22 10	jmp $1022			jmp 	NextCommand
.1c9a					SetDefaultChannel:
.1c9a	9c 5a 04	stz $045a			stz 	currentChannel
.1c9d	60		rts				rts
.1c9e					VectorPrintCharacter:
.1c9e	da		phx				phx
.1c9f	ae 5a 04	ldx $045a			ldx 	currentChannel
.1ca2	20 b0 25	jsr $25b0			jsr 	XPrintCharacterToChannel
.1ca5	fa		plx				plx
.1ca6	60		rts				rts
.1ca7					VectorGetCharacter:
.1ca7	da		phx				phx
.1ca8	ae 5a 04	ldx $045a			ldx 	currentChannel
.1cab	20 e9 24	jsr $24e9			jsr 	XGetCharacterFromChannel
.1cae	fa		plx				plx
.1caf	60		rts				rts
.045a					currentChannel:
>045a							.fill 	1
.1cb0					PrintNumber:
.1cb0	fa		plx				plx
.1cb1	a9 07		lda #$07			lda 	#7
.1cb3	20 d5 2c	jsr $2cd5			jsr 	FloatToString 				; to number in decimal buffer
.1cb6	ca		dex				dex 								; drop
.1cb7	da		phx				phx
.1cb8	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1cba					_PNLoop:
.1cba	bd 91 05	lda $0591,x			lda 	decimalBuffer,x
.1cbd	20 9e 1c	jsr $1c9e			jsr 	VectorPrintCharacter
.1cc0	e8		inx				inx
.1cc1	bd 91 05	lda $0591,x			lda	 	decimalBuffer,x
.1cc4	d0 f4		bne $1cba			bne 	_PNLoop
.1cc6	a9 20		lda #$20			lda 	#32 						; trailing space
.1cc8	20 9e 1c	jsr $1c9e			jsr 	VectorPrintCharacter
.1ccb	fa		plx				plx
.1ccc	4c 22 10	jmp $1022			jmp 	NextCommand
.1ccf					PrintString:
.1ccf	fa		plx				plx
.1cd0	b5 40		lda $40,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.1cd2	85 28		sta $28				sta 	zTemp0
.1cd4	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.1cd6	85 29		sta $29				sta 	zTemp0+1
.1cd8	ca		dex				dex 								; drop
.1cd9	da		phx				phx
.1cda	5a		phy				phy
.1cdb	b2 28		lda ($28)			lda 	(zTemp0) 					; X = count
.1cdd	aa		tax				tax
.1cde	a0 01		ldy #$01			ldy 	#1 							; Y = position
.1ce0					_PSLoop:
.1ce0	e0 00		cpx #$00			cpx 	#0 							; complete ?
.1ce2	f0 09		beq $1ced			beq 	_PSExit
.1ce4	ca		dex				dex 								; dec count
.1ce5	b1 28		lda ($28),y			lda 	(zTemp0),y 					; print char and bump
.1ce7	20 9e 1c	jsr $1c9e			jsr 	VectorPrintCharacter
.1cea	c8		iny				iny
.1ceb	80 f3		bra $1ce0			bra 	_PSLoop
.1ced					_PSExit:
.1ced	7a		ply				ply
.1cee	fa		plx				plx
.1cef	4c 22 10	jmp $1022			jmp 	NextCommand
.1cf2					CommandPushN:
.1cf2	fa		plx				plx
.1cf3	e8		inx				inx 								; next slot on stack
.1cf4	b1 22		lda ($22),y			lda 	(codePtr),y 				; exponent
.1cf6	95 70		sta $70,x			sta 	NSExponent,x
.1cf8	c8		iny				iny
.1cf9	b1 22		lda ($22),y			lda 	(codePtr),y 				; mantissa
.1cfb	95 40		sta $40,x			sta 	NSMantissa0,x
.1cfd	c8		iny				iny
.1cfe	b1 22		lda ($22),y			lda 	(codePtr),y
.1d00	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1d02	c8		iny				iny
.1d03	b1 22		lda ($22),y			lda 	(codePtr),y
.1d05	95 58		sta $58,x			sta 	NSMantissa2,x
.1d07	c8		iny				iny
.1d08	b1 22		lda ($22),y			lda 	(codePtr),y
.1d0a	48		pha				pha
.1d0b	29 7f		and #$7f			and 	#$7F
.1d0d	95 64		sta $64,x			sta 	NSMantissa3,x
.1d0f	68		pla				pla 								; sign in mantissa3:7
.1d10	29 80		and #$80			and 	#$80
.1d12	95 34		sta $34,x			sta 	NSStatus,x
.1d14	c8		iny				iny
.1d15	4c 22 10	jmp $1022			jmp 	NextCommand
.1d18					CommandPushS:
.1d18	fa		plx				plx
.1d19	e8		inx				inx 								; next slot on stack
.1d1a	18		clc				clc
.1d1b	98		tya				tya
.1d1c	65 22		adc $22				adc 	codePtr 					; the string is inline
.1d1e	95 40		sta $40,x			sta 	NSMantissa0,x
.1d20	a5 23		lda $23				lda 	codePtr+1
.1d22	69 00		adc #$00			adc 	#0
.1d24	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1d26	74 58		stz $58,x			stz 	NSMantissa2,x
.1d28	74 64		stz $64,x			stz 	NSMantissa3,x
.1d2a	a9 40		lda #$40			lda 	#NSSString
.1d2c	95 34		sta $34,x			sta 	NSStatus,x
.1d2e	98		tya				tya 								; string length +1 added to Y
.1d2f	38		sec				sec
.1d30	71 22		adc ($22),y			adc 	(codePtr),y 				; next instruction
.1d32	a8		tay				tay
.1d33	4c 22 10	jmp $1022			jmp 	NextCommand
.1d36					CommandRead:
.1d36	fa		plx				plx
.1d37	5a		phy				phy 								; save Y
.1d38	20 69 1d	jsr $1d69			jsr 	ReadStringToBuffer 			; read element into buffer
.1d3b	e8		inx				inx									; space on stack
.1d3c	a9 5c		lda #$5c			lda 	#((ReadBufferSize) & $FF)
.1d3e	85 28		sta $28				sta 	0+zTemp0
.1d40	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.1d42	85 29		sta $29				sta 	1+zTemp0
.1d44	20 85 22	jsr $2285			jsr 	ValEvaluateZTemp0
.1d47	b0 04		bcs $1d4d			bcs 	_CRError 					; failed
.1d49	7a		ply				ply 								; restore Y
.1d4a	4c 22 10	jmp $1022			jmp 	NextCommand
.1d4d					_CRError:
.1d4d	4c 6d 14	jmp $146d		jmp	ErrorV_value
.1d50					CommandReadString:
.1d50	fa		plx				plx
.1d51	5a		phy				phy 								; save Y
.1d52	20 69 1d	jsr $1d69			jsr 	ReadStringToBuffer 			; read text
.1d55	e8		inx				inx 								; make space on stack
.1d56	20 ed 2d	jsr $2ded			jsr 	FloatSetZero 				; store as string on stack
.1d59	a9 5c		lda #$5c			lda 	#ReadBufferSize & $FF
.1d5b	95 40		sta $40,x			sta 	NSMantissa0,x
.1d5d	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.1d5f	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1d61	a9 40		lda #$40			lda 	#NSSString
.1d63	95 34		sta $34,x			sta 	NSStatus,x
.1d65	7a		ply				ply 								; restore Y
.1d66	4c 22 10	jmp $1022			jmp 	NextCommand
.1d69					ReadStringToBuffer:
.1d69	a9 fc		lda #$fc			lda 	#((ReadBumpNext) & $FF)
.1d6b	8d 5c 05	sta $055c			sta 	0+ReadBumpNextVec
.1d6e	a9 1d		lda #$1d			lda 	#((ReadBumpNext) >> 8) & $FF
.1d70	8d 5d 05	sta $055d			sta 	1+ReadBumpNextVec
.1d73	a9 cf		lda #$cf			lda 	#((ReadLookNext) & $FF)
.1d75	8d 5e 05	sta $055e			sta 	0+ReadLookNextVec
.1d78	a9 1d		lda #$1d			lda 	#((ReadLookNext) >> 8) & $FF
.1d7a	8d 5f 05	sta $055f			sta 	1+ReadLookNextVec
.1d7d					GetStringToBuffer:
.1d7d	20 cc 1d	jsr $1dcc			jsr		GetLookNext 				; skip all leading spaces.
.1d80	f0 44		beq $1dc6			beq 	_RBError 					; end of data
.1d82	b0 f9		bcs $1d7d			bcs 	GetStringToBuffer 			; switched to new data line.
.1d84	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1d86	b0 05		bcs $1d8d			bcs 	_RBNoSpace
.1d88	20 c9 1d	jsr $1dc9			jsr 	GetBumpNext 				; consume space and loop round.
.1d8b	80 f0		bra $1d7d			bra 	GetStringToBuffer
.1d8d					_RBNoSpace:
.1d8d	9c 5c 04	stz $045c			stz 	ReadBufferSize 				; empty the buffer.
.1d90	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.1d92	d0 08		bne $1d9c			bne 	_RBCommaSep
.1d94	8d 5b 04	sta $045b			sta 	ReadSep 					; use as a seperator
.1d97	20 c9 1d	jsr $1dc9			jsr 	GetBumpNext 				; consume the '"'
.1d9a	80 05		bra $1da1			bra 	_RBGetText
.1d9c					_RBCommaSep:
.1d9c	a9 2c		lda #$2c			lda 	#","						; get till comma
.1d9e	8d 5b 04	sta $045b			sta 	ReadSep
.1da1					_RBGetText:
.1da1	20 cc 1d	jsr $1dcc			jsr 	GetLookNext 				; what follows
.1da4	b0 18		bcs $1dbe			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.1da6	20 c9 1d	jsr $1dc9			jsr 	GetBumpNext 				; consume it whatever
.1da9	cd 5b 04	cmp $045b			cmp 	ReadSep 					; if found the seperator.
.1dac	f0 10		beq $1dbe			beq 	_RBEndGet 					; exit after consumption
.1dae	da		phx				phx
.1daf	ae 5c 04	ldx $045c			ldx 	ReadBufferSize 				; copy into buffer.
.1db2	ee 5c 04	inc $045c			inc 	ReadBufferSize
.1db5	9d 5d 04	sta $045d,x			sta 	ReadBuffer,x
.1db8	9e 5e 04	stz $045e,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.1dbb	fa		plx				plx
.1dbc	80 e3		bra $1da1			bra 	_RBGetText
.1dbe					_RBEndGet:
.1dbe	c9 22		cmp #$22			cmp 	#'"'
.1dc0	d0 03		bne $1dc5			bne 	_RBNotQuote
.1dc2	20 c9 1d	jsr $1dc9			jsr 	GetBumpNext
.1dc5					_RBNotQuote:
.1dc5	60		rts				rts
.1dc6					_RBError:
.1dc6	4c 22 15	jmp $1522		jmp	ErrorV_data
.1dc9					GetBumpNext:
.1dc9	6c 5c 05	jmp ($055c)			jmp 	(ReadBumpNextVec)
.1dcc					GetLookNext:
.1dcc	6c 5e 05	jmp ($055e)			jmp 	(ReadLookNextVec)
.1dcf					ReadLookNext:
.1dcf	ad 60 05	lda $0560			lda 	dataRemaining 				; any data remaining
.1dd2	f0 04		beq $1dd8			beq 	_RLNFindData
.1dd4	b2 25		lda ($25)			lda 	(objPtr) 					; return that object.
.1dd6	18		clc				clc
.1dd7	60		rts				rts
.1dd8					_RLNFindData:
.1dd8	b2 25		lda ($25)			lda 	(objPtr) 					; see where we are
.1dda	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.1ddc	f0 1a		beq $1df8			beq 	_RLNNoData
.1dde	c9 cf		cmp #$cf			cmp 	#PCD_CMD_DATA 				; Found DATA
.1de0	f0 05		beq $1de7			beq 	_RLNHaveData
.1de2					_RLNNext:
.1de2	20 11 16	jsr $1611			jsr 	MoveObjectForward			; else scan forward.
.1de5	80 f1		bra $1dd8			bra 	_RLNFindData
.1de7					_RLNHaveData:
.1de7	a0 01		ldy #$01			ldy 	#1 							; get length
.1de9	b1 25		lda ($25),y			lda 	(objPtr),y
.1deb	f0 f5		beq $1de2			beq 	_RLNNext 					; skip if DATA alone
.1ded	20 fc 1d	jsr $1dfc			jsr 	ReadBumpNext 				; advance by two
.1df0	20 fc 1d	jsr $1dfc			jsr 	ReadBumpNext
.1df3	8d 60 05	sta $0560			sta 	dataRemaining 				; set data left count.
.1df6	38		sec				sec
.1df7	60		rts				rts
.1df8					_RLNNoData:
.1df8	a9 00		lda #$00			lda 	#0
.1dfa	38		sec				sec
.1dfb	60		rts				rts
.1dfc					ReadBumpNext:
.1dfc	e6 25		inc $25				inc 	objPtr
.1dfe	d0 02		bne $1e02			bne 	_RBNSkip
.1e00	e6 26		inc $26				inc 	objPtr+1
.1e02					_RBNSkip:
.1e02	ce 60 05	dec $0560			dec 	dataRemaining
.1e05	60		rts				rts
.045b					ReadSep:
>045b							.fill 	1
.045c					ReadBufferSize:
>045c							.fill 	1
.045d					ReadBuffer:
>045d							.fill 	255
.055c					ReadBumpNextVec:
>055c							.fill 	2
.055e					ReadLookNextVec:
>055e							.fill 	2
.1e06					ReadFloatCommand:
.1e06	fa		plx				plx
.1e07	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1e09	85 28		sta $28				sta 	zTemp0 						; save in MSB
.1e0b	88		dey				dey 								; get the upper 3 bits
.1e0c	b1 22		lda ($22),y			lda 	(codePtr),y
.1e0e	29 07		and #$07			and 	#7
.1e10	c8		iny				iny
.1e11	c8		iny				iny
.1e12	06 28		asl $28				asl 	zTemp0 						; shift zTemp0:A left
.1e14	2a		rol a				rol 	a 							; carry will be clear.
.1e15	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.1e17	85 29		sta $29				sta 	zTemp0+1
.1e19	20 1f 1e	jsr $1e1f			jsr 	ReadFloatZTemp0Sub
.1e1c	4c 22 10	jmp $1022			jmp 	NextCommand
.1e1f					ReadFloatZTemp0Sub:
.1e1f	5a		phy				phy 								; start write
.1e20	a0 01		ldy #$01			ldy 	#1
.1e22	e8		inx				inx
.1e23	b2 28		lda ($28)			lda 	(zTemp0)
.1e25	95 40		sta $40,x			sta 	NSMantissa0,x
.1e27	b1 28		lda ($28),y			lda 	(zTemp0),y
.1e29	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1e2b	c8		iny				iny
.1e2c	b1 28		lda ($28),y			lda 	(zTemp0),y
.1e2e	95 58		sta $58,x			sta 	NSMantissa2,x
.1e30	c8		iny				iny
.1e31	b1 28		lda ($28),y			lda 	(zTemp0),y
.1e33	95 64		sta $64,x			sta 	NSMantissa3,x
.1e35	c8		iny				iny
.1e36	b1 28		lda ($28),y			lda 	(zTemp0),y
.1e38	95 70		sta $70,x			sta 	NSExponent,x
.1e3a	c8		iny				iny
.1e3b	b1 28		lda ($28),y			lda 	(zTemp0),y
.1e3d	95 34		sta $34,x			sta 	NSStatus,x
.1e3f	7a		ply				ply
.1e40	60		rts				rts
.1e41					ReadIntegerCommand:
.1e41	fa		plx				plx
.1e42	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1e44	85 28		sta $28				sta 	zTemp0 						; save in MSB
.1e46	88		dey				dey 								; get the upper 3 bits
.1e47	b1 22		lda ($22),y			lda 	(codePtr),y
.1e49	29 07		and #$07			and 	#7
.1e4b	c8		iny				iny
.1e4c	c8		iny				iny
.1e4d	06 28		asl $28				asl 	zTemp0 						; shift zTemp0:A left
.1e4f	2a		rol a				rol 	a 							; carry will be clear.
.1e50	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.1e52	85 29		sta $29				sta 	zTemp0+1
.1e54	20 5a 1e	jsr $1e5a			jsr 	ReadIntegerZTemp0Sub
.1e57	4c 22 10	jmp $1022			jmp 	NextCommand
.1e5a					ReadIntegerZTemp0Sub:
.1e5a	5a		phy				phy 								; start write
.1e5b	a0 01		ldy #$01			ldy 	#1
.1e5d	e8		inx				inx 								; prepare
.1e5e	74 58		stz $58,x			stz 	NSMantissa2,x
.1e60	74 64		stz $64,x			stz 	NSMantissa3,x
.1e62	74 70		stz $70,x			stz 	NSExponent,x
.1e64	74 34		stz $34,x			stz 	NSStatus,x
.1e66	b1 28		lda ($28),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1e68	30 08		bmi $1e72			bmi 	_RIZNegative
.1e6a	95 4c		sta $4c,x			sta 	NSMantissa1,x 				; +ve read
.1e6c	b2 28		lda ($28)			lda 	(zTemp0)
.1e6e	95 40		sta $40,x			sta 	NSMantissa0,x
.1e70	7a		ply				ply
.1e71	60		rts				rts
.1e72					_RIZNegative:
.1e72	38		sec				sec 								; -ve read
.1e73	a9 00		lda #$00			lda 	#0
.1e75	f2 28		sbc ($28)			sbc 	(zTemp0)
.1e77	95 40		sta $40,x			sta 	NSMantissa0,x
.1e79	a9 00		lda #$00			lda 	#0
.1e7b	f1 28		sbc ($28),y			sbc 	(zTemp0),y
.1e7d	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1e7f	a9 80		lda #$80			lda 	#$80
.1e81	95 34		sta $34,x			sta 	NSStatus,x
.1e83	7a		ply				ply
.1e84	60		rts				rts
.1e85					ReadStringCommand:
.1e85	fa		plx				plx
.1e86	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1e88	85 28		sta $28				sta 	zTemp0 						; save in MSB
.1e8a	88		dey				dey 								; get the upper 3 bits
.1e8b	b1 22		lda ($22),y			lda 	(codePtr),y
.1e8d	29 07		and #$07			and 	#7
.1e8f	c8		iny				iny
.1e90	c8		iny				iny
.1e91	06 28		asl $28				asl 	zTemp0 						; shift zTemp0:A left
.1e93	2a		rol a				rol 	a 							; carry will be clear.
.1e94	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.1e96	85 29		sta $29				sta 	zTemp0+1
.1e98	20 9e 1e	jsr $1e9e			jsr 	ReadStringZTemp0Sub
.1e9b	4c 22 10	jmp $1022			jmp 	NextCommand
.1e9e					ReadStringZTemp0Sub:
.1e9e	5a		phy				phy 								; start write
.1e9f	e8		inx				inx 								; prepare
.1ea0	74 58		stz $58,x			stz 	NSMantissa2,x
.1ea2	74 64		stz $64,x			stz 	NSMantissa3,x
.1ea4	74 70		stz $70,x			stz 	NSExponent,x
.1ea6	a9 40		lda #$40			lda 	#NSSString
.1ea8	74 34		stz $34,x			stz 	NSStatus,x
.1eaa	18		clc				clc
.1eab	b2 28		lda ($28)			lda 	(zTemp0)					; read address of block add 2.
.1ead	69 02		adc #$02			adc 	#2 							; this points to actual data
.1eaf	95 40		sta $40,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.1eb1	a0 01		ldy #$01			ldy 	#1
.1eb3	b1 28		lda ($28),y			lda 	(zTemp0),y
.1eb5	69 00		adc #$00			adc 	#0
.1eb7	95 4c		sta $4c,x			sta 	NSMantissa1,x 				; +ve read
.1eb9	d0 08		bne $1ec3			bne 	_RSZNoDefault 				; if read $00 use a default value.
.1ebb	a9 c5		lda #$c5			lda 	#_RSZNull & $FF
.1ebd	95 40		sta $40,x			sta 	NSMantissa0,x
.1ebf	a9 1e		lda #$1e			lda 	#_RSZNull >> 8
.1ec1	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1ec3					_RSZNoDefault:
.1ec3	7a		ply				ply
.1ec4	60		rts				rts
.1ec5					_RSZNull:
>1ec5	00						.byte 	0
.1ec6					CommandRestore:
.1ec6	fa		plx				plx
.1ec7	20 cd 1e	jsr $1ecd			jsr 	RestoreCode
.1eca	4c 22 10	jmp $1022			jmp 	NextCommand
.1ecd					RestoreCode:
.1ecd	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer and page
.1ed0	85 28		sta $28				sta 	objPage+1
.1ed2	64 27		stz $27				stz  	objPage
.1ed4	9c 60 05	stz $0560			stz 	dataRemaining 				; no data remaining.
.1ed7	60		rts				rts
.0560					dataRemaining:
>0560							.fill 	1		 					; 0 if not in data statement
.1ed8					UnaryRND:
.1ed8	fa		plx				plx
.1ed9	34 34		bit $34,x			bit 	NSStatus,x 					; -ve then set seed from operand
.1edb	10 17		bpl $1ef4			bpl 	_URNoSeed
.1edd	20 42 2b	jsr $2b42			jsr 	FloatNormalise 				; some float value
.1ee0	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy to Mantissa
.1ee2	8d 61 05	sta $0561			sta 	randomSeed+0
.1ee5	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.1ee7	8d 62 05	sta $0562			sta 	randomSeed+1
.1eea	b5 58		lda $58,x			lda 	NSMantissa2,x
.1eec	8d 63 05	sta $0563			sta 	randomSeed+2
.1eef	b5 64		lda $64,x			lda 	NSMantissa3,x
.1ef1	8d 64 05	sta $0564			sta 	randomSeed+3
.1ef4					_URNoSeed:
.1ef4	20 16 1f	jsr $1f16			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.1ef7	ad 61 05	lda $0561			lda 	randomSeed+0
.1efa	95 40		sta $40,x			sta 	NSMantissa0,x
.1efc	ad 62 05	lda $0562			lda 	randomSeed+1
.1eff	95 4c		sta $4c,x			sta 	NSMantissa1,x
.1f01	ad 63 05	lda $0563			lda 	randomSeed+2
.1f04	95 58		sta $58,x			sta 	NSMantissa2,x
.1f06	ad 64 05	lda $0564			lda 	randomSeed+3
.1f09	29 7f		and #$7f			and 	#$7F
.1f0b	95 64		sta $64,x			sta 	NSMantissa3,x
.1f0d	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.1f0f	95 70		sta $70,x			sta 	NSExponent,x
.1f11	74 34		stz $34,x			stz 	NSStatus,x
.1f13	4c 22 10	jmp $1022			jmp 	NextCommand
.1f16					RandomNumberGenerator:
.1f16	5a		phy				phy
.1f17	ad 61 05	lda $0561			lda 	randomSeed+0 				; check if zero
.1f1a	0d 62 05	ora $0562			ora 	randomSeed+1
.1f1d	0d 63 05	ora $0563			ora 	randomSeed+2
.1f20	0d 64 05	ora $0564			ora 	randomSeed+3
.1f23	d0 07		bne $1f2c			bne 	_RNGNoSeed
.1f25	ce 64 05	dec $0564			dec 	randomSeed+3 				; if so tweak and flog
.1f28	a0 64		ldy #$64			ldy 	#100
.1f2a	80 05		bra $1f31			bra 	_RNGLoop
.1f2c					_RNGNoSeed:
.1f2c	a0 08		ldy #$08			ldy 	#8
.1f2e	ad 61 05	lda $0561			lda 	randomSeed+0
.1f31					_RNGLoop:
.1f31	0a		asl a				asl		a
.1f32	2e 62 05	rol $0562			rol 	randomSeed+1
.1f35	2e 63 05	rol $0563			rol 	randomSeed+2
.1f38	2e 64 05	rol $0564			rol 	randomSeed+3
.1f3b	90 02		bcc $1f3f			bcc		_RNGSkip
.1f3d	49 c5		eor #$c5			eor 	#$C5
.1f3f					_RNGSkip:
.1f3f	88		dey				dey
.1f40	d0 ef		bne $1f31			bne		_RNGLoop
.1f42	8d 61 05	sta $0561			sta 	randomSeed+0
.1f45	7a		ply				ply
.1f46	60		rts				rts
.0561					randomSeed:
>0561							.fill 	4
.1f47					StringConcatenate:
.1f47	fa		plx				plx
.1f48	ca		dex				dex
.1f49	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.1f4b	85 2a		sta $2a				sta 	zTemp1
.1f4d	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.1f4f	85 2b		sta $2b				sta 	zTemp1+1
.1f51	b5 41		lda $41,x			lda 	NSMantissa0+1,x
.1f53	85 2c		sta $2c				sta 	zTemp2
.1f55	b5 4d		lda $4d,x			lda 	NSMantissa1+1,x
.1f57	85 2d		sta $2d				sta 	zTemp2+1
.1f59	18		clc				clc 								; work out total length
.1f5a	b2 2a		lda ($2a)			lda 	(zTemp1)
.1f5c	72 2c		adc ($2c)			adc 	(zTemp2)
.1f5e	b0 18		bcs $1f78			bcs 	_BCLength 					; more than 255 characters.
.1f60	48		pha				pha 								; save total
.1f61	20 3e 20	jsr $203e			jsr 	StringAllocTemp 			; space for result.
.1f64	68		pla				pla 								; write total as first.
.1f65	92 2e		sta ($2e)			sta 	(zsTemp)
.1f67	20 7b 1f	jsr $1f7b			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.1f6a	a5 2c		lda $2c				lda 	zTemp2 						; copy address zTemp2->1
.1f6c	85 2a		sta $2a				sta 	zTemp1
.1f6e	a5 2d		lda $2d				lda 	zTemp2+1
.1f70	85 2b		sta $2b				sta 	zTemp1+1
.1f72	20 7b 1f	jsr $1f7b			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1f75	4c 22 10	jmp $1022			jmp 	NextCommand
.1f78					_BCLength:
.1f78	4c 5d 14	jmp $145d		jmp	ErrorV_range
.1f7b					_BCCopyZTemp1:
.1f7b	b2 2a		lda ($2a)			lda 	(zTemp1) 					; bytes to copy
.1f7d	f0 15		beq $1f94			beq 	_BCCExit 					; none.
.1f7f	da		phx				phx 								; save XY
.1f80	5a		phy				phy
.1f81	aa		tax				tax 								; count in X.
.1f82	a0 01		ldy #$01			ldy 	#1
.1f84					_BCCLoop:
.1f84	e6 2e		inc $2e				inc 	zsTemp 						; bump pointer, pre-increment
.1f86	d0 02		bne $1f8a			bne 	_BCCNoCarry
.1f88	e6 2f		inc $2f				inc 	zsTemp+1
.1f8a					_BCCNoCarry:
.1f8a	b1 2a		lda ($2a),y			lda 	(zTemp1),y				 	; copy bytes
.1f8c	92 2e		sta ($2e)			sta 	(zsTemp)
.1f8e	c8		iny				iny
.1f8f	ca		dex				dex 								; X times
.1f90	d0 f2		bne $1f84			bne 	_BCCLoop
.1f92	7a		ply				ply 								; restore YX
.1f93	fa		plx				plx
.1f94					_BCCExit:
.1f94	60		rts				rts
.1f95					XRuntimeSetup:
.1f95	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1f97	8d 68 05	sta $0568	 		sta 	ramBank
.1f9a	8d 69 05	sta $0569	 		sta 	romBank
.1f9d	60		rts				rts
.1f9e					SignTOS:
.1f9e	fa		plx				plx
.1f9f	20 0f 2e	jsr $2e0f			jsr 	FloatIsZero 				; if zero
.1fa2	f0 0f		beq $1fb3			beq 	_SGZero  					; return Int Zero
.1fa4	b5 34		lda $34,x			lda 	NSStatus,x 					; get status w/sign
.1fa6	48		pha				pha
.1fa7	a9 01		lda #$01			lda 	#1 							; set result to 1
.1fa9	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.1fac	68		pla				pla
.1fad	29 80		and #$80			and		#$80 						; copy the sign byte out
.1faf	95 34		sta $34,x			sta 	NSStatus,x  				; so it will be -1 or 1
.1fb1	80 03		bra $1fb6			bra 	_SGExit
.1fb3					_SGZero:
.1fb3	20 ed 2d	jsr $2ded			jsr 	FloatSetZero
.1fb6					_SGExit:
.1fb6	4c 22 10	jmp $1022			jmp 	NextCommand
.1fb9					CommandShift:
.1fb9	b1 22		lda ($22),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.1fbb	c8		iny				iny
.1fbc	0a		asl a				asl 	a 							; double into X
.1fbd	aa		tax				tax
.1fbe	7c 69 23	jmp ($2369,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.1fc1					PrintTab:
.1fc1	fa		plx				plx
.1fc2	20 05 25	jsr $2505			jsr 	XGetHPos
.1fc5					_PTMod10:
.1fc5	38		sec				sec
.1fc6	e9 0a		sbc #$0a			sbc 	#10
.1fc8	b0 fb		bcs $1fc5			bcs 	_PTMod10
.1fca	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.1fcc	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.1fcd	80 15		bra $1fe4			bra 	PrintSpaceLoop
.1fcf					PrintPos:
.1fcf	fa		plx				plx
.1fd0	20 05 25	jsr $2505			jsr		XGetHPos 					; get current position
.1fd3	85 28		sta $28				sta 	zTemp0
.1fd5	38		sec				sec 								; calculate spaces required
.1fd6	b5 40		lda $40,x			lda 	NSMantissa0,x
.1fd8	ca		dex				dex
.1fd9	e5 28		sbc $28				sbc 	zTemp0
.1fdb	b0 07		bcs $1fe4			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.1fdd	4c 22 10	jmp $1022			jmp 	NextCommand
.1fe0					PrintSpace:
.1fe0	fa		plx				plx
.1fe1	b5 40		lda $40,x			lda 	NSMantissa0,x
.1fe3	ca		dex				dex
.1fe4					PrintSpaceLoop:
.1fe4	c9 00		cmp #$00			cmp 	#0
.1fe6	f0 0a		beq $1ff2			beq 	_PSExit
.1fe8	48		pha				pha
.1fe9	a9 20		lda #$20			lda 	#" "
.1feb	20 9e 1c	jsr $1c9e			jsr 	VectorPrintCharacter
.1fee	68		pla				pla
.1fef	3a		dec a				dec 	a
.1ff0	80 f2		bra $1fe4			bra 	PrintSpaceLoop
.1ff2					_PSExit:
.1ff2	4c 22 10	jmp $1022			jmp 	NextCommand
.1ff5					CommandStop:
.1ff5	fa		plx				plx
.1ff6	4c 0f 15	jmp $150f		jmp	ErrorV_stop
.1ff9					Unary_Str:
.1ff9	fa		plx				plx
.1ffa	5a		phy				phy
.1ffb	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.1ffd	20 d5 2c	jsr $2cd5			jsr 	FloatToString 				; do the conversion.
.2000	a9 21		lda #$21			lda		#33 						; create buffer
.2002	20 3e 20	jsr $203e			jsr 	StringAllocTemp 			; allocate memory
.2005	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.2007					_USCopy:
.2007	b9 90 05	lda $0590,y			lda 	decimalBuffer-1,y
.200a	f0 05		beq $2011			beq 	_USExit
.200c	91 2e		sta ($2e),y			sta 	(zsTemp),y
.200e	c8		iny				iny
.200f	80 f6		bra $2007			bra 	_USCopy
.2011					_USExit:
.2011	98		tya				tya
.2012	3a		dec a				dec 	a
.2013	92 2e		sta ($2e)			sta 	(zsTemp)
.2015	7a		ply				ply
.2016	4c 22 10	jmp $1022			jmp 	NextCommand
.2019					StringInitialise:
.2019	48		pha				pha
.201a	ad 65 05	lda $0565			lda 	stringInitialised 			; already done
.201d	d0 11		bne $2030			bne 	_SIExit
.201f	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.2022	8d 66 05	sta $0566			sta 	stringTempPointer
.2025	ad 03 04	lda $0403			lda 	stringHighMemory+1
.2028	3a		dec a				dec 	a
.2029	3a		dec a				dec 	a
.202a	8d 67 05	sta $0567			sta 	stringTempPointer+1
.202d	ce 65 05	dec $0565			dec 	stringInitialised 			; set the initialised flag.
.2030					_SIExit:
.2030	a5 33		lda $33				lda 	availableMemory+1 			; check out of memory
.2032	1a		inc a				inc 	a
.2033	1a		inc a				inc 	a
.2034	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.2037	b0 02		bcs $203b			bcs 	_SIMemory
.2039	68		pla				pla
.203a	60		rts				rts
.203b					_SIMemory:
.203b	4c 68 15	jmp $1568		jmp	ErrorV_memory
.203e					StringAllocTemp:
.203e	20 19 20	jsr $2019			jsr 	StringInitialise 			; check it is initialised.
.2041	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.2043	18		clc				clc
.2044	6d 66 05	adc $0566			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.2047	8d 66 05	sta $0566			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.204a	85 2e		sta $2e				sta 	zsTemp
.204c	95 40		sta $40,x			sta 	NSMantissa0,x
.204e	ad 67 05	lda $0567			lda 	stringTempPointer+1
.2051	69 ff		adc #$ff			adc 	#$FF
.2053	8d 67 05	sta $0567			sta 	stringTempPointer+1
.2056	85 2f		sta $2f				sta 	zsTemp+1
.2058	95 4c		sta $4c,x			sta 	NSMantissa1,x
.205a	74 58		stz $58,x			stz 	NSMantissa2,x
.205c	74 64		stz $64,x			stz 	NSMantissa3,x
.205e	a9 00		lda #$00			lda 	#0 							; clear string.
.2060	92 2e		sta ($2e)			sta 	(zsTemp)
.2062	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.2064	95 34		sta $34,x			sta 	NSStatus,x
.2066	60		rts				rts
.2067					StringWriteChar:
.2067	5a		phy				phy
.2068	48		pha				pha
.2069	b2 2e		lda ($2e)			lda 	(zsTemp)
.206b	1a		inc a				inc 	a
.206c	92 2e		sta ($2e)			sta 	(zsTemp)
.206e	a8		tay				tay
.206f	68		pla				pla
.2070	91 2e		sta ($2e),y			sta 	(zsTemp),y
.2072	7a		ply				ply
.2073	60		rts				rts
.0565					stringInitialised:
>0565							.fill 	1
.0566					stringTempPointer:
>0566							.fill 	2
.2074					Unary_Left:
.2074	fa		plx				plx
.2075	5a		phy				phy
.2076	18		clc				clc 								; only one parameter
.2077	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; push the length of the string.
.207a	48		pha				pha
.207b	ca		dex				dex
.207c	a9 00		lda #$00			lda 	#0 							; push the start position.
.207e	48		pha				pha
.207f	20 b7 20	jsr $20b7			jsr 	UnarySStringToZTemp0
.2082	80 3c		bra $20c0			bra 	SubstringMain 				; stack now points to the string to slice.
.2084					Unary_Right:
.2084	fa		plx				plx
.2085	5a		phy				phy
.2086	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.2088	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; push the right length of the string.
.208b	48		pha				pha
.208c	ca		dex				dex
.208d	20 b7 20	jsr $20b7			jsr 	UnarySStringToZTemp0
.2090	68		pla				pla 								; this is the right requirement
.2091	38		sec				sec
.2092	49 ff		eor #$ff			eor 	#$FF
.2094	72 28		adc ($28)			adc 	(zTemp0)
.2096	b0 02		bcs $209a			bcs 	_URHaveCount
.2098	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.209a					_URHaveCount:
.209a	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.209c	5a		phy				phy
.209d	48		pha				pha 								; start position
.209e	80 20		bra $20c0			bra 	SubstringMain
.20a0					Unary_Mid:
.20a0	fa		plx				plx
.20a1	5a		phy				phy
.20a2	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; push the length of the string required.
.20a5	48		pha				pha
.20a6	ca		dex				dex
.20a7	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; put the start position.
.20aa	f0 08		beq $20b4			beq 	_UMError
.20ac	3a		dec a				dec 	a
.20ad	48		pha				pha
.20ae	ca		dex				dex
.20af	20 b7 20	jsr $20b7			jsr 	UnarySStringToZTemp0
.20b2	80 0c		bra $20c0			bra 	SubstringMain 				; stack now points to the string to slice.
.20b4					_UMError:
.20b4	4c 5d 14	jmp $145d		jmp	ErrorV_range
.20b7					UnarySStringToZTemp0:
.20b7	b5 40		lda $40,x			lda 	NSMantissa0,x
.20b9	85 28		sta $28				sta 	zTemp0
.20bb	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.20bd	85 29		sta $29				sta 	zTemp0+1
.20bf	60		rts				rts
.20c0					SubstringMain:
.20c0	68		pla				pla 								; get the start offset
.20c1	7a		ply				ply 								; get the count to do.
.20c2	d2 28		cmp ($28)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.20c4	b0 38		bcs $20fe			bcs 	_SSReturnNull
.20c6	85 2a		sta $2a				sta 	zTemp1 						; save start position.
.20c8	84 2b		sty $2b				sty 	zTemp1+1 					; save count
.20ca	18		clc				clc
.20cb	65 2b		adc $2b				adc 	zTemp1+1 					; this is the end position.
.20cd	b0 06		bcs $20d5			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.20cf	d2 28		cmp ($28)			cmp 	(zTemp0) 					; ok if limit is <= length.
.20d1	f0 04		beq $20d7			beq 	_SMIsOkay
.20d3	90 02		bcc $20d7			bcc 	_SMIsOkay
.20d5					_SMTruncateToEnd:
.20d5	b2 28		lda ($28)			lda 	(zTemp0) 					; end position is length.
.20d7					_SMIsOkay:
.20d7	85 2b		sta $2b				sta 	zTemp1+1
.20d9	38		sec				sec		 							; work out size
.20da	a5 2b		lda $2b				lda 	zTemp1+1
.20dc	e5 2a		sbc $2a				sbc 	zTemp1
.20de	f0 1e		beq $20fe			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.20e0	20 3e 20	jsr $203e			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.20e3	a4 2a		ldy $2a				ldy 	zTemp1 						; start
.20e5					_SMCopy:
.20e5	c4 2b		cpy $2b				cpy 	zTemp1+1 					; exit if reached end
.20e7	f0 11		beq $20fa			beq 	_SMExit
.20e9	c8		iny				iny 								; bump and
.20ea	b1 28		lda ($28),y			lda 	(zTemp0),y 					; get character (prefix)
.20ec	5a		phy				phy
.20ed	48		pha				pha
.20ee	b2 2e		lda ($2e)			lda 	(zsTemp) 					; bump length => Y
.20f0	1a		inc a				inc 	a
.20f1	a8		tay				tay
.20f2	92 2e		sta ($2e)			sta 	(zsTemp)
.20f4	68		pla				pla 								; write character out
.20f5	91 2e		sta ($2e),y			sta 	(zsTemp),y
.20f7	7a		ply				ply 								; restore Y
.20f8	80 eb		bra $20e5			bra 	_SMCopy
.20fa					_SMExit:
.20fa	7a		ply				ply
.20fb	4c 22 10	jmp $1022			jmp 	NextCommand
.20fe					_SSReturnNull:
.20fe	a9 10		lda #$10			lda 	#SSRNull & $FF 				; set up mantissa
.2100	95 40		sta $40,x			sta 	NSMantissa0,x
.2102	a9 21		lda #$21			lda 	#SSRNull >> 8
.2104	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2106	74 58		stz $58,x			stz 	NSMantissa2,x
.2108	74 64		stz $64,x			stz 	NSMantissa3,x
.210a	a9 40		lda #$40			lda 	#NSSString
.210c	95 34		sta $34,x			sta 	NSStatus,x
.210e	80 ea		bra $20fa			bra 	_SMExit
.2110					SSRNull:
>2110	00 00						.word 	0
.2112					CommandSwap:
.2112	fa		plx				plx
.2113	b5 40		lda $40,x			lda 	NSMantissa0,x
.2115	48		pha				pha
.2116	b5 3f		lda $3f,x			lda 	NSMantissa0-1,x
.2118	95 40		sta $40,x			sta 	NSMantissa0,x
.211a	68		pla				pla
.211b	95 3f		sta $3f,x			sta 	NSMantissa0-1,x
.211d	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.211f	48		pha				pha
.2120	b5 4b		lda $4b,x			lda 	NSMantissa1-1,x
.2122	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2124	68		pla				pla
.2125	95 4b		sta $4b,x			sta 	NSMantissa1-1,x
.2127	b5 58		lda $58,x			lda 	NSMantissa2,x
.2129	48		pha				pha
.212a	b5 57		lda $57,x			lda 	NSMantissa2-1,x
.212c	95 58		sta $58,x			sta 	NSMantissa2,x
.212e	68		pla				pla
.212f	95 57		sta $57,x			sta 	NSMantissa2-1,x
.2131	b5 64		lda $64,x			lda 	NSMantissa3,x
.2133	48		pha				pha
.2134	b5 63		lda $63,x			lda 	NSMantissa3-1,x
.2136	95 64		sta $64,x			sta 	NSMantissa3,x
.2138	68		pla				pla
.2139	95 63		sta $63,x			sta 	NSMantissa3-1,x
.213b	b5 70		lda $70,x			lda 	NSExponent,x
.213d	48		pha				pha
.213e	b5 6f		lda $6f,x			lda 	NSExponent-1,x
.2140	95 70		sta $70,x			sta 	NSExponent,x
.2142	68		pla				pla
.2143	95 6f		sta $6f,x			sta 	NSExponent-1,x
.2145	b5 34		lda $34,x			lda 	NSStatus,x
.2147	48		pha				pha
.2148	b5 33		lda $33,x			lda 	NSStatus-1,x
.214a	95 34		sta $34,x			sta 	NSStatus,x
.214c	68		pla				pla
.214d	95 33		sta $33,x			sta 	NSStatus-1,x
.214f	4c 22 10	jmp $1022			jmp 	NextCommand
.2152					CommandSYS:
.2152	fa		plx				plx
.2153	da		phx				phx 								; save XY
.2154	5a		phy				phy
.2155	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.2158	b5 4c		lda $4c,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.215a	85 29		sta $29				sta 	zTemp0+1
.215c	b5 40		lda $40,x			lda 	NSMantissa0,x
.215e	85 28		sta $28				sta 	zTemp0
.2160	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.2163	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.2166	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.2169	48		pha				pha
.216a	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.216d	28		plp				plp
.216e	20 85 21	jsr $2185			jsr 	_CSZTemp0
.2171	08		php				php
.2172	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.2175	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.2178	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.217b	68		pla				pla
.217c	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.217f	7a		ply				ply 								; restore YX and drop 2
.2180	fa		plx				plx
.2181	ca		dex				dex
.2182	4c 22 10	jmp $1022			jmp 	NextCommand
.2185					_CSZTemp0:
.2185	6c 28 00	jmp ($0028)			jmp 	(zTemp0)
.2188					TimeTOS:
.2188	fa		plx				plx
.2189	20 e3 21	jsr $21e3			jsr 	TIPushClock 				; push clock to TOS
.218c	4c 22 10	jmp $1022			jmp 	NextCommand
.218f					TimeString:
.218f	fa		plx				plx
.2190	20 e3 21	jsr $21e3			jsr 	TIPushClock 				; push clock to TOS
.2193	20 b8 21	jsr $21b8			jsr 	_TSDivMod60 				; result in seconds
.2196	20 b8 21	jsr $21b8			jsr 	_TSDivMod60 				; seconds
.2199	48		pha				pha
.219a	20 b8 21	jsr $21b8			jsr 	_TSDivMod60 				; minutes
.219d	48		pha				pha
.219e	a9 18		lda #$18			lda 	#24 						; hours
.21a0	20 ba 21	jsr $21ba			jsr 	_TSDivModA
.21a3	48		pha				pha
.21a4	a9 06		lda #$06			lda 	#6
.21a6	20 3e 20	jsr $203e			jsr 	StringAllocTemp
.21a9	68		pla				pla
.21aa	20 ca 21	jsr $21ca			jsr 	_TSWriteDecimal
.21ad	68		pla				pla
.21ae	20 ca 21	jsr $21ca			jsr 	_TSWriteDecimal
.21b1	68		pla				pla
.21b2	20 ca 21	jsr $21ca			jsr 	_TSWriteDecimal
.21b5	4c 22 10	jmp $1022			jmp 	NextCommand
.21b8					_TSDivMod60:
.21b8	a9 3c		lda #$3c			lda 	#60
.21ba					_TSDivModA:
.21ba	e8		inx				inx
.21bb	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.21be	ca		dex				dex
.21bf	20 83 29	jsr $2983			jsr 	Int32Divide
.21c2	b5 40		lda $40,x			lda 	NSMantissa0,x 				; get modulus
.21c4	48		pha				pha
.21c5	20 72 29	jsr $2972			jsr 	NSMCopyPlusTwoToZero
.21c8	68		pla				pla
.21c9	60		rts				rts
.21ca					_TSWriteDecimal:
.21ca	da		phx				phx
.21cb	a2 30		ldx #$30			ldx 	#'0'
.21cd					_TSWDLoop:
.21cd	c9 0a		cmp #$0a			cmp 	#10
.21cf	90 05		bcc $21d6			bcc 	_TSWDEnd
.21d1	e9 0a		sbc #$0a			sbc 	#10
.21d3	e8		inx				inx
.21d4	80 f7		bra $21cd			bra 	_TSWDLoop
.21d6					_TSWDEnd:
.21d6	48		pha				pha
.21d7	8a		txa				txa
.21d8	20 67 20	jsr $2067			jsr 	StringWriteChar
.21db	68		pla				pla
.21dc	09 30		ora #$30			ora 	#'0'
.21de	20 67 20	jsr $2067			jsr 	StringWriteChar
.21e1	fa		plx				plx
.21e2	60		rts				rts
.21e3					TIPushClock:
.21e3	5a		phy				phy
.21e4	e8		inx				inx 								; push 0 on the stack
.21e5	20 ed 2d	jsr $2ded			jsr 	FloatSetZero
.21e8	da		phx				phx
.21e9	20 d0 25	jsr $25d0			jsr 	XReadClock 					; read time into YXA
.21ec	86 28		stx $28				stx 	zTemp0
.21ee	fa		plx				plx
.21ef	95 40		sta $40,x			sta 	NSMantissa0,x
.21f1	a5 28		lda $28				lda 	zTemp0
.21f3	95 4c		sta $4c,x			sta 	NSMantissa1,x
.21f5	98		tya				tya
.21f6	95 58		sta $58,x			sta 	NSMantissa2,x
.21f8	7a		ply				ply
.21f9	60		rts				rts
.21fa					CommandTIWrite:
.21fa	fa		plx				plx
.21fb	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.21fd	85 2e		sta $2e				sta 	zsTemp
.21ff	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2201	85 2f		sta $2f				sta 	zsTemp+1
.2203	b2 2e		lda ($2e)			lda 	(zsTemp) 					; check if it is six
.2205	c9 06		cmp #$06			cmp 	#6
.2207	d0 59		bne $2262			bne 	_CTIWError
.2209	20 ed 2d	jsr $2ded			jsr 	FloatSetZero
.220c	20 2e 22	jsr $222e			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.220f	20 2e 22	jsr $222e			jsr 	_CTIWDigitPair
.2212	20 2e 22	jsr $222e			jsr 	_CTIWDigitPair
.2215	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.2217	20 59 22	jsr $2259			jsr 	_CTIWMultiply
.221a	da		phx				phx
.221b	5a		phy				phy
.221c	b5 4c		lda $4c,x			lda 	NSMantissa1,x 				; get time into YXA
.221e	48		pha				pha
.221f	b5 58		lda $58,x			lda 	NSMantissa2,x
.2221	a8		tay				tay
.2222	b5 40		lda $40,x			lda 	NSMantissa0,x
.2224	fa		plx				plx
.2225	20 d4 25	jsr $25d4			jsr 	XWriteClock 				; update the clock.
.2228	7a		ply				ply
.2229	fa		plx				plx
.222a	ca		dex				dex 								; throw result.
.222b	4c 22 10	jmp $1022			jmp 	NextCommand
.222e					_CTIWDigitPair:
.222e	a9 06		lda #$06			lda 	#6 							; x 6
.2230	20 59 22	jsr $2259			jsr 	_CTIWMultiply
.2233	20 3f 22	jsr $223f			jsr 	_CTIWAddDigit 				; add digit
.2236	a9 0a		lda #$0a			lda 	#10 						; x 10
.2238	20 59 22	jsr $2259			jsr 	_CTIWMultiply
.223b	20 3f 22	jsr $223f			jsr 	_CTIWAddDigit 				; add digit
.223e	60		rts				rts
.223f					_CTIWAddDigit:
.223f	e6 2e		inc $2e				inc 	zsTemp 						; pre-increment
.2241	d0 02		bne $2245			bne 	_CTIWASkip
.2243	e6 2f		inc $2f				inc 	zsTemp+1
.2245					_CTIWASkip:
.2245	b2 2e		lda ($2e)			lda 	(zsTemp) 					; read and validate it
.2247	38		sec				sec
.2248	e9 30		sbc #$30			sbc 	#"0"
.224a	90 16		bcc $2262			bcc 	_CTIWError
.224c	c9 0a		cmp #$0a			cmp 	#9+1
.224e	b0 12		bcs $2262			bcs 	_CTIWError
.2250	e8		inx				inx 								; store at +1
.2251	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.2254	ca		dex				dex
.2255	20 79 2b	jsr $2b79			jsr 	FloatAddTopTwoStack
.2258	60		rts				rts
.2259					_CTIWMultiply:
.2259	e8		inx				inx
.225a	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.225d	ca		dex				dex
.225e	20 fa 2a	jsr $2afa			jsr 	FloatMultiplyShort
.2261	60		rts				rts
.2262					_CTIWError:
.2262	4c 6d 14	jmp $146d		jmp	ErrorV_value
.2265					UnaryUsr:
.2265	fa		plx				plx
.2266	5a		phy				phy
.2267	20 6e 22	jsr $226e			jsr 	_UUCallVector
.226a	7a		ply				ply
.226b	4c 22 10	jmp $1022			jmp 	NextCommand
.226e					_UUCallVector:
.226e	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.2271					ValUnary:
.2271	fa		plx				plx
.2272	b5 40		lda $40,x			lda 	NSMantissa0,x
.2274	85 28		sta $28				sta 	zTemp0
.2276	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2278	85 29		sta $29				sta 	zTemp0+1
.227a	20 85 22	jsr $2285			jsr 	ValEvaluateZTemp0
.227d	b0 03		bcs $2282			bcs 	_VUError 					; couldn't convert
.227f	4c 22 10	jmp $1022			jmp 	NextCommand
.2282					_VUError:
.2282	4c 6d 14	jmp $146d		jmp	ErrorV_value
.2285					ValEvaluateZTemp0:
.2285	5a		phy				phy
.2286	b2 28		lda ($28)			lda 	(zTemp0) 					; check not empty string
.2288	f0 22		beq $22ac			beq 	_VMCFail2
.228a	a0 00		ldy #$00			ldy 	#0 							; start position
.228c					_VMCSpaces:
.228c	c8		iny				iny 								; skip leading spaces
.228d	b1 28		lda ($28),y			lda 	(zTemp0),y
.228f	c9 20		cmp #$20			cmp 	#" "
.2291	f0 f9		beq $228c			beq 	_VMCSpaces
.2293	48		pha				pha 								; save first character
.2294	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.2296	d0 01		bne $2299			bne 	_VMCStart
.2298	c8		iny				iny 								; skip over - if so.
.2299					_VMCStart:
.2299	38		sec				sec 								; initialise first time round.
.229a					_VMCNext:
.229a	98		tya				tya 								; reached end of string
.229b	3a		dec a				dec 	a
.229c	52 28		eor ($28)			eor 	(zTemp0) 					; compare length preserve carry.
.229e	f0 0f		beq $22af			beq 	_VMCSuccess 				; successful.
.22a0	b1 28		lda ($28),y			lda 	(zTemp0),y 					; encode a number.
.22a2	c8		iny				iny
.22a3	20 d1 2b	jsr $2bd1			jsr 	FloatEncode 				; send it to the number-builder
.22a6	90 03		bcc $22ab			bcc 	_VMCFail 					; if failed, give up.
.22a8	18		clc				clc 								; next time round, countinue
.22a9	80 ef		bra $229a			bra 	_VMCNext
.22ab					_VMCFail:
.22ab	68		pla				pla
.22ac					_VMCFail2:
.22ac	7a		ply				ply
.22ad	38		sec				sec
.22ae	60		rts				rts
.22af					_VMCSuccess:
.22af	a9 00		lda #$00			lda 	#0 							; construct final
.22b1	20 d1 2b	jsr $2bd1			jsr 	FloatEncode 				; by sending a duff value.
.22b4	68		pla				pla 								; if it was -ve
.22b5	c9 2d		cmp #$2d			cmp 	#"-"
.22b7	d0 03		bne $22bc			bne 	_VMCNotNegative
.22b9	20 af 2d	jsr $2daf			jsr		FloatNegate 				; negate it.
.22bc					_VMCNotNegative:
.22bc	7a		ply				ply
.22bd	18		clc				clc
.22be	60		rts				rts
.22bf					VectorTable:
>22bf	c4 19					.word	LinkFloatAdd             ; $80 +
>22c1	cd 19					.word	LinkFloatSubtract        ; $81 -
>22c3	d6 19					.word	LinkFloatMultiply        ; $82 *
>22c5	df 19					.word	LinkFloatDivide          ; $83 /
>22c7	ea 19					.word	LinkFloatPower           ; $84 ^
>22c9	b3 10					.word	BinaryAnd                ; $85 and
>22cb	b7 10					.word	BinaryOr                 ; $86 or
>22cd	f5 19					.word	LinkCompareGreater       ; $87 >
>22cf	fe 19					.word	LinkCompareEqual         ; $88 =
>22d1	07 1a					.word	LinkCompareLess          ; $89 <
>22d3	10 1a					.word	LinkCompareGreaterEqual  ; $8a >=
>22d5	19 1a					.word	LinkCompareNotEqual      ; $8b <>
>22d7	22 1a					.word	LinkCompareLessEqual     ; $8c <=
>22d9	9c 10					.word	AbsoluteTOS              ; $8d abs
>22db	ee 10					.word	ArrayConvert             ; $8e array
>22dd	93 11					.word	UnaryAsc                 ; $8f asc
>22df	ae 11					.word	CommandAssert            ; $90 assert
>22e1	ef 11					.word	Unary16Bin               ; $91 bin$
>22e3	19 12					.word	PrintCharacter           ; $92 print.chr
>22e5	23 12					.word	UnaryChr                 ; $93 chr$
>22e7	77 12					.word	CompareStrings           ; $94 s.cmp
>22e9	8f 15					.word	CommandFor               ; $95 for
>22eb	95 16					.word	UnaryFre                 ; $96 fre
>22ed	ad 16					.word	CommandGet               ; $97 get
>22ef	d3 16					.word	CommandReturn            ; $98 return
>22f1	1a 17					.word	Command_PSET             ; $99 pset
>22f3	34 17					.word	Command_LINE             ; $9a line
>22f5	49 17					.word	Command_RECT             ; $9b rect
>22f7	58 17					.word	Command_FRAME            ; $9c frame
>22f9	67 17					.word	Command_CHAR             ; $9d char
>22fb	fe 17					.word	Unary16Hex               ; $9e hex$
>22fd	9f 18					.word	CommandInput             ; $9f input
>22ff	b6 18					.word	CommandInputString       ; $a0 input$
>2301	cf 18					.word	CommandInputReset        ; $a1 input.start
>2303	b3 19					.word	UnaryLen                 ; $a2 len
>2305	7f 1a					.word	LinkFloatCompare         ; $a3 f.cmp
>2307	88 1a					.word	LinkDivideInt32          ; $a4 int.div
>2309	0c 1b					.word	NegateTOS                ; $a5 negate
>230b	13 1b					.word	CommandNewLine           ; $a6 new.line
>230d	1c 1b					.word	CommandNext              ; $a7 next
>230f	03 1c					.word	NotTOS                   ; $a8 not
>2311	1a 1c					.word	CommandOn                ; $a9 on
>2313	38 1c					.word	CommandMoreOn            ; $aa moreon
>2315	4b 1c					.word	UnaryPeek                ; $ab peek
>2317	60 1c					.word	CommandPOKE              ; $ac poke
>2319	78 1c					.word	UnaryPos                 ; $ad pos
>231b	82 1c					.word	GetChannel               ; $ae getchannel
>231d	8d 1c					.word	SetChannel               ; $af setchannel
>231f	b0 1c					.word	PrintNumber              ; $b0 print.n
>2321	cf 1c					.word	PrintString              ; $b1 print.s
>2323	36 1d					.word	CommandRead              ; $b2 read
>2325	50 1d					.word	CommandReadString        ; $b3 read$
>2327	d8 1e					.word	UnaryRND                 ; $b4 rnd
>2329	47 1f					.word	StringConcatenate        ; $b5 concat
>232b	9e 1f					.word	SignTOS                  ; $b6 sgn
>232d	c1 1f					.word	PrintTab                 ; $b7 print.tab
>232f	cf 1f					.word	PrintPos                 ; $b8 print.pos
>2331	e0 1f					.word	PrintSpace               ; $b9 print.spc
>2333	f9 1f					.word	Unary_Str                ; $ba str$
>2335	74 20					.word	Unary_Left               ; $bb left$
>2337	84 20					.word	Unary_Right              ; $bc right$
>2339	a0 20					.word	Unary_Mid                ; $bd mid$
>233b	12 21					.word	CommandSwap              ; $be swap
>233d	88 21					.word	TimeTOS                  ; $bf ti
>233f	8f 21					.word	TimeString               ; $c0 ti$
>2341	65 22					.word	UnaryUsr                 ; $c1 usr
>2343	71 22					.word	ValUnary                 ; $c2 val
>2345	cc 24					.word	CommandClose             ; $c3 close
>2347	de 24					.word	CommandExit              ; $c4 exit
>2349	e4 24					.word	CommandDebug             ; $c5 debug
>234b	4a 25					.word	CommandOpen              ; $c6 open
>234d	de 25					.word	CommandScreen            ; $c7 screen
>234f	c5 27					.word	CommandVPOKE             ; $c8 vpoke
>2351	ea 27					.word	CommandVPEEK             ; $c9 vpeek
>2353	b9 1f					.word	CommandShift             ; $ca .shift
>2355	60 10					.word	PushByteCommand          ; $cb .byte
>2357	73 10					.word	PushWordCommand          ; $cc .word
>2359	f2 1c					.word	CommandPushN             ; $cd .float
>235b	18 1d					.word	CommandPushS             ; $ce .string
>235d	ff 12					.word	CommandData              ; $cf .data
>235f	e5 16					.word	CommandGoto              ; $d0 .goto
>2361	c7 16					.word	CommandGosub             ; $d1 .gosub
>2363	fc 16					.word	CommandGotoZ             ; $d2 .goto.z
>2365	0b 17					.word	CommandGotoNZ            ; $d3 .goto.nz
>2367	a2 10					.word	CommandVarSpace          ; $d4 .varspace
.2369					ShiftVectorTable:
>2369	3b 12					.word	CommandClr               ; $ca80 clr
>236b	08 13					.word	CommandDIM               ; $ca81 dim
>236d	f8 13					.word	CommandEnd               ; $ca82 end
>236f	84 19					.word	UnaryJoy                 ; $ca83 joy
>2371	2b 1a					.word	LinkFloatIntegerPartDown ; $ca84 int
>2373	34 1a					.word	LinkFloatSquareRoot      ; $ca85 sqr
>2375	45 1a					.word	LinkFloatLogarithm       ; $ca86 log
>2377	50 1a					.word	LinkFloatExponent        ; $ca87 exp
>2379	59 1a					.word	LinkFloatCosine          ; $ca88 cos
>237b	62 1a					.word	LinkFloatSine            ; $ca89 sin
>237d	6b 1a					.word	LinkFloatTangent         ; $ca8a tan
>237f	74 1a					.word	LinkFloatArcTan          ; $ca8b atn
>2381	bc 1a					.word	XCommandMouse            ; $ca8c mouse
>2383	d1 1a					.word	XUnaryMB                 ; $ca8d mb
>2385	de 1a					.word	XUnaryMX                 ; $ca8e mx
>2387	ef 1a					.word	XUnaryMY                 ; $ca8f my
>2389	c6 1e					.word	CommandRestore           ; $ca90 restore
>238b	f5 1f					.word	CommandStop              ; $ca91 stop
>238d	52 21					.word	CommandSYS               ; $ca92 sys
>238f	fa 21					.word	CommandTIWrite           ; $ca93 ti$.write
>2391	c7 23					.word	CommandWAIT              ; $ca94 wait
>2393	0f 25					.word	X16I2CPoke               ; $ca95 i2cpoke
>2395	2f 25					.word	X16I2CPeek               ; $ca96 i2cpeek
>2397	9a 25					.word	CommandBank              ; $ca97 bank
>2399	ed 25					.word	XCommandSleep            ; $ca98 sleep
>239b	11 26					.word	X16_Audio_FMINIT         ; $ca99 fminit
>239d	1f 26					.word	X16_Audio_FMNOTE         ; $ca9a fmnote
>239f	31 26					.word	X16_Audio_FMDRUM         ; $ca9b fmdrum
>23a1	43 26					.word	X16_Audio_FMINST         ; $ca9c fminst
>23a3	55 26					.word	X16_Audio_FMVIB          ; $ca9d fmvib
>23a5	67 26					.word	X16_Audio_FMFREQ         ; $ca9e fmfreq
>23a7	78 26					.word	X16_Audio_FMVOL          ; $ca9f fmvol
>23a9	8a 26					.word	X16_Audio_FMPAN          ; $caa0 fmpan
>23ab	9c 26					.word	X16_Audio_FMPLAY         ; $caa1 fmplay
>23ad	ad 26					.word	X16_Audio_FMCHORD        ; $caa2 fmchord
>23af	be 26					.word	X16_Audio_FMPOKE         ; $caa3 fmpoke
>23b1	d0 26					.word	X16_Audio_PSGINIT        ; $caa4 psginit
>23b3	de 26					.word	X16_Audio_PSGNOTE        ; $caa5 psgnote
>23b5	f0 26					.word	X16_Audio_PSGVOL         ; $caa6 psgvol
>23b7	02 27					.word	X16_Audio_PSGWAV         ; $caa7 psgwav
>23b9	14 27					.word	X16_Audio_PSGFREQ        ; $caa8 psgfreq
>23bb	25 27					.word	X16_Audio_PSGPAN         ; $caa9 psgpan
>23bd	37 27					.word	X16_Audio_PSGPLAY        ; $caaa psgplay
>23bf	48 27					.word	X16_Audio_PSGCHORD       ; $caab psgchord
>23c1	59 27					.word	CommandCls               ; $caac cls
>23c3	62 27					.word	CommandLocate            ; $caad locate
>23c5	8c 27					.word	CommandColor             ; $caae color
.23c7					CommandWAIT:
.23c7	fa		plx				plx
.23c8	b5 3e		lda $3e,x			lda 	NSMantissa0-2,x 			; get wait address
.23ca	85 28		sta $28				sta 	zTemp0
.23cc	b5 4a		lda $4a,x			lda 	NSMantissa1-2,x
.23ce	85 29		sta $29				sta 	zTemp0+1
.23d0					_WaitLoop:
.23d0	b2 28		lda ($28)			lda 	(zTemp0) 					; read it
.23d2	35 3f		and $3f,x			and 	NSMantissa0-1,x		 		; and with mask
.23d4	55 40		eor $40,x			eor 	NSMantissa0-0,x 			; toggle
.23d6	f0 f8		beq $23d0			beq 	_WaitLoop 					; keep going if zero
.23d8	ca		dex				dex 								; drop 3.
.23d9	ca		dex				dex
.23da	ca		dex				dex
.23db	4c 22 10	jmp $1022			jmp 	NextCommand
.23de					WriteFloatCommand:
.23de	fa		plx				plx
.23df	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.23e1	85 28		sta $28				sta 	zTemp0 						; save in MSB
.23e3	88		dey				dey 								; get the upper 3 bits
.23e4	b1 22		lda ($22),y			lda 	(codePtr),y
.23e6	29 07		and #$07			and 	#7
.23e8	c8		iny				iny
.23e9	c8		iny				iny
.23ea	06 28		asl $28				asl 	zTemp0 						; shift zTemp0:A left
.23ec	2a		rol a				rol 	a 							; carry will be clear.
.23ed	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.23ef	85 29		sta $29				sta 	zTemp0+1
.23f1	20 f7 23	jsr $23f7			jsr 	WriteFloatZTemp0Sub
.23f4	4c 22 10	jmp $1022			jmp 	NextCommand
.23f7					WriteFloatZTemp0Sub:
.23f7	5a		phy				phy 								; ldart write
.23f8	a0 01		ldy #$01			ldy 	#1
.23fa	b5 40		lda $40,x			lda 	NSMantissa0,x
.23fc	92 28		sta ($28)			sta 	(zTemp0)
.23fe	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2400	91 28		sta ($28),y			sta 	(zTemp0),y
.2402	c8		iny				iny
.2403	b5 58		lda $58,x			lda 	NSMantissa2,x
.2405	91 28		sta ($28),y			sta 	(zTemp0),y
.2407	c8		iny				iny
.2408	b5 64		lda $64,x			lda 	NSMantissa3,x
.240a	91 28		sta ($28),y			sta 	(zTemp0),y
.240c	c8		iny				iny
.240d	b5 70		lda $70,x			lda 	NSExponent,x
.240f	91 28		sta ($28),y			sta 	(zTemp0),y
.2411	c8		iny				iny
.2412	b5 34		lda $34,x			lda 	NSStatus,x
.2414	91 28		sta ($28),y			sta 	(zTemp0),y
.2416	ca		dex				dex
.2417	7a		ply				ply
.2418	60		rts				rts
.2419					WriteIntegerCommand:
.2419	fa		plx				plx
.241a	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.241c	85 28		sta $28				sta 	zTemp0 						; save in MSB
.241e	88		dey				dey 								; get the upper 3 bits
.241f	b1 22		lda ($22),y			lda 	(codePtr),y
.2421	29 07		and #$07			and 	#7
.2423	c8		iny				iny
.2424	c8		iny				iny
.2425	06 28		asl $28				asl 	zTemp0 						; shift zTemp0:A left
.2427	2a		rol a				rol 	a 							; carry will be clear.
.2428	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.242a	85 29		sta $29				sta 	zTemp0+1
.242c	20 32 24	jsr $2432			jsr 	WriteIntegerZTemp0Sub
.242f	4c 22 10	jmp $1022			jmp 	NextCommand
.2432					WriteIntegerZTemp0Sub:
.2432	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.2435	5a		phy				phy 								; start write
.2436	a0 01		ldy #$01			ldy 	#1
.2438	b5 34		lda $34,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.243a	30 0b		bmi $2447			bmi 	_WIZNegative
.243c	b5 40		lda $40,x			lda 	NSMantissa0,x 				; +ve write
.243e	92 28		sta ($28)			sta 	(zTemp0)
.2440	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2442	91 28		sta ($28),y			sta 	(zTemp0),y
.2444	7a		ply				ply
.2445	ca		dex				dex
.2446	60		rts				rts
.2447					_WIZNegative:
.2447	38		sec				sec 								; -ve read
.2448	a9 00		lda #$00			lda 	#0
.244a	f5 40		sbc $40,x			sbc 	NSMantissa0,x
.244c	92 28		sta ($28)			sta 	(zTemp0)
.244e	a9 00		lda #$00			lda 	#0
.2450	f5 4c		sbc $4c,x			sbc 	NSMantissa1,x
.2452	91 28		sta ($28),y			sta 	(zTemp0),y
.2454	7a		ply				ply
.2455	ca		dex				dex
.2456	60		rts				rts
.2457					WriteStringCommand:
.2457	fa		plx				plx
.2458	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.245a	85 28		sta $28				sta 	zTemp0 						; save in MSB
.245c	88		dey				dey 								; get the upper 3 bits
.245d	b1 22		lda ($22),y			lda 	(codePtr),y
.245f	29 07		and #$07			and 	#7
.2461	c8		iny				iny
.2462	c8		iny				iny
.2463	06 28		asl $28				asl 	zTemp0 						; shift zTemp0:A left
.2465	2a		rol a				rol 	a 							; carry will be clear.
.2466	69 80		adc #$80			adc 	#VariableStart >> 8 		; point to variable page.
.2468	85 29		sta $29				sta 	zTemp0+1
.246a	20 70 24	jsr $2470			jsr 	WriteStringZTemp0Sub
.246d	4c 22 10	jmp $1022			jmp 	NextCommand
.2470					WriteStringZTemp0Sub:
.2470	5a		phy				phy
.2471	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.2473	b2 28		lda ($28)			lda 	(zTemp0)
.2475	11 28		ora ($28),y			ora 	(zTemp0),y
.2477	f0 1e		beq $2497			beq 	_WSConcrete
.2479	b2 28		lda ($28)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.247b	85 2a		sta $2a				sta 	zTemp1
.247d	b1 28		lda ($28),y			lda 	(zTemp0),y
.247f	85 2b		sta $2b				sta 	zTemp1+1
.2481	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.2483	85 2c		sta $2c				sta 	zTemp2
.2485	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2487	85 2d		sta $2d				sta 	zTemp2+1
.2489	b2 2a		lda ($2a)			lda 	(zTemp1) 					; space available
.248b	d2 2c		cmp ($2c)			cmp 	(zTemp2) 					; if >= required length then copy
.248d	b0 17		bcs $24a6			bcs 	_WSCopy
.248f	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.2491	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.2493	09 80		ora #$80			ora 	#$80
.2495	91 2a		sta ($2a),y			sta 	(zTemp1),y
.2497					_WSConcrete:
.2497	b5 4c		lda $4c,x			lda 	NSMantissa1,x 				; string in YA
.2499	a8		tay				tay
.249a	b5 40		lda $40,x			lda 	NSMantissa0,x
.249c	20 b9 12	jsr $12b9			jsr 	StringConcrete
.249f	92 28		sta ($28)			sta 	(zTemp0) 					; save returned address
.24a1	98		tya				tya
.24a2	a0 01		ldy #$01			ldy 	#1
.24a4	91 28		sta ($28),y			sta 	(zTemp0),y
.24a6					_WSCopy
.24a6	18		clc				clc  								; copy target+2 to zTemp2
.24a7	b2 28		lda ($28)			lda 	(zTemp0)
.24a9	69 02		adc #$02			adc 	#2
.24ab	85 2c		sta $2c				sta 	zTemp2
.24ad	a0 01		ldy #$01			ldy 	#1
.24af	b1 28		lda ($28),y			lda 	(zTemp0),y
.24b1	69 00		adc #$00			adc 	#0
.24b3	85 2d		sta $2d				sta 	zTemp2+1
.24b5	b5 40		lda $40,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.24b7	85 2a		sta $2a				sta 	zTemp1
.24b9	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.24bb	85 2b		sta $2b				sta 	zTemp1+1
.24bd	b2 2a		lda ($2a)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.24bf	a8		tay				tay
.24c0					_WSCopyLoop:
.24c0	b1 2a		lda ($2a),y			lda 	(zTemp1),y
.24c2	91 2c		sta ($2c),y			sta 	(zTemp2),y
.24c4	88		dey				dey
.24c5	c0 ff		cpy #$ff			cpy 	#$FF
.24c7	d0 f7		bne $24c0			bne 	_WSCopyLoop
.24c9	ca		dex				dex
.24ca	7a		ply				ply
.24cb	60		rts				rts
.24cc					CommandClose:
.24cc	fa		plx				plx
.24cd	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; channel to close
.24d0	cd 5a 04	cmp $045a			cmp 	currentChannel 				; is it the current channel
.24d3	d0 03		bne $24d8			bne 	_CCNotCurrent
.24d5	9c 5a 04	stz $045a			stz 	currentChannel 				; effectively disables CMD
.24d8					_CCNotCurrent:
.24d8	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.24db	4c 22 10	jmp $1022			jmp 	NextCommand
.24de					CommandExit:
.24de	fa		plx				plx
.24df	86 28		stx $28				stx 	zTemp0 						; stack position.
.24e1	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.24e4					CommandDebug:
.24e4	fa		plx				plx
>24e5	db						.byte 	$DB 						; causes a break in the emulator
.24e6	4c 22 10	jmp $1022			jmp 	NextCommand
.24e9					XGetCharacterFromChannel:
.24e9	da		phx				phx
.24ea	5a		phy				phy
.24eb	e0 00		cpx #$00			cpx 	#0 							; is it default
.24ed	d0 05		bne $24f4			bne 	_XGetChannel
.24ef	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.24f2	80 08		bra $24fc			bra 	_XGetChar
.24f4					_XGetChannel:
.24f4	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.24f7	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.24fa	d0 06		bne $2502			bne 	_XGCError
.24fc					_XGetChar:
.24fc	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.24ff	7a		ply				ply
.2500	fa		plx				plx
.2501	60		rts				rts
.2502					_XGCError:
.2502	4c 79 15	jmp $1579		jmp	ErrorV_channel
.2505					XGetHPos:
.2505	da		phx				phx
.2506	5a		phy				phy
.2507	38		sec				sec
.2508	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.250b	98		tya				tya
.250c	7a		ply				ply
.250d	fa		plx				plx
.250e	60		rts				rts
.250f					X16I2CPoke:
.250f	fa		plx				plx
.2510	5a		phy				phy
.2511	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; value
.2514	48		pha				pha
.2515	ca		dex				dex
.2516	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; register
.2519	48		pha				pha
.251a	ca		dex				dex
.251b	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; device
.251e	aa		tax				tax
.251f	7a		ply				ply
.2520	68		pla				pla
.2521	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.2524	b0 06		bcs $252c			bcs 	X16I2CError
.2526	7a		ply				ply
.2527	a2 ff		ldx #$ff			ldx 	#$FF
.2529	4c 22 10	jmp $1022			jmp 	NextCommand
.252c					X16I2CError:
.252c	4c 79 15	jmp $1579		jmp	ErrorV_channel
.252f					X16I2CPeek:
.252f	fa		plx				plx
.2530	da		phx				phx
.2531	5a		phy				phy
.2532	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; register
.2535	48		pha				pha
.2536	ca		dex				dex
.2537	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; device
.253a	aa		tax				tax 								; X device
.253b	7a		ply				ply 								; Y register
.253c	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.253f	b0 eb		bcs $252c			bcs 	X16I2CError
.2541	7a		ply				ply 								; restore Y/X
.2542	fa		plx				plx
.2543	ca		dex				dex 								; drop TOS (register)
.2544	20 ef 2d	jsr $2def			jsr 	FloatSetByte 				; write read value to TOS.
.2547	4c 22 10	jmp $1022			jmp 	NextCommand
.254a					CommandOpen:
.254a	fa		plx				plx
.254b	a5 43		lda $43				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.254d	85 28		sta $28				sta 	zTemp0
.254f	aa		tax				tax
.2550	a5 4f		lda $4f				lda 	NSMantissa1+3
.2552	85 29		sta $29				sta 	zTemp0+1
.2554	a8		tay				tay
.2555	e8		inx				inx 								; XY points to first character
.2556	d0 01		bne $2559			bne 	_CONoCarry
.2558	c8		iny				iny
.2559					_CONoCarry:
.2559	b2 28		lda ($28)			lda 	(zTemp0) 					; get length of filename
.255b	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.255e	a5 40		lda $40				lda 	NSMantissa0+0
.2560	a6 41		ldx $41				ldx 	NSMantissa0+1
.2562	a4 42		ldy $42				ldy 	NSMantissa0+2
.2564	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.2567	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.256a	b0 03		bcs $256f			bcs 	_COError
.256c	4c 22 10	jmp $1022			jmp 	NextCommand
.256f					_COError:
.256f	4c 79 15	jmp $1579		jmp	ErrorV_channel
.2572					XPokeMemory:
.2572	86 28		stx $28				stx 	zTemp0
.2574	84 29		sty $29				sty 	zTemp0+1
.2576	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.2578	ae 68 05	ldx $0568			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.257b	e0 ff		cpx #$ff			cpx 	#$FF
.257d	f0 02		beq $2581			beq 	_XPMNoSwitch
.257f	86 00		stx $00				stx 	SelectRAMBank
.2581					_XPMNoSwitch:
.2581	92 28		sta ($28)			sta 	(zTemp0) 					; do the POKE
.2583	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.2585					_XPMExit:
.2585	60		rts				rts
.2586					XPeekMemory:
.2586	86 28		stx $28				stx 	zTemp0
.2588	84 29		sty $29				sty 	zTemp0+1
.258a	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.258c	ae 68 05	ldx $0568			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.258f	e0 ff		cpx #$ff			cpx 	#$FF
.2591	f0 02		beq $2595			beq 	_XPMNoSwitch
.2593	86 00		stx $00				stx 	SelectRAMBank
.2595					_XPMNoSwitch:
.2595	b2 28		lda ($28)			lda 	(zTemp0) 					; do the PEEK
.2597	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.2599	60		rts				rts
.259a					CommandBank:
.259a	fa		plx				plx
.259b	a5 40		lda $40				lda 	NSMantissa0 				; RAM bank
.259d	8d 68 05	sta $0568			sta 	ramBank 					; store & make current
.25a0	85 00		sta $00				sta 	SelectRAMBank
.25a2	a5 41		lda $41				lda 	NSMantissa0+1 		 		; ROM specified
.25a4	c9 ff		cmp #$ff			cmp 	#$FF
.25a6	f0 03		beq $25ab			beq 	_CBNoUpdate
.25a8	8d 69 05	sta $0569			sta 	romBank 					; this doesn't set the hardware page.
.25ab					_CBNoUpdate:
.25ab	a2 ff		ldx #$ff			ldx 	#$FF
.25ad	4c 22 10	jmp $1022			jmp 	NextCommand
.0568					ramBank:
>0568							.fill 	1
.0569					romBank:
>0569							.fill 	1
.25b0					XPrintCharacterToChannel:
.25b0	48		pha				pha
.25b1	da		phx				phx
.25b2	5a		phy				phy
.25b3	48		pha				pha  								; save char
.25b4	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.25b6	d0 05		bne $25bd			bne 	_XPCNotDefault
.25b8	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.25bb	80 08		bra $25c5			bra 	_XPCSend
.25bd					_XPCNotDefault:
.25bd	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.25c0	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.25c3	d0 08		bne $25cd			bne 	_XPCError
.25c5					_XPCSend:
.25c5	68		pla				pla 								; restore character
.25c6	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.25c9	7a		ply				ply
.25ca	fa		plx				plx
.25cb	68		pla				pla
.25cc	60		rts				rts
.25cd					_XPCError:
.25cd	4c 79 15	jmp $1579		jmp	ErrorV_channel
.25d0					XReadClock:
.25d0	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.25d3	60		rts				rts
.25d4					XWriteClock:
.25d4	48		pha				pha
.25d5	da		phx				phx
.25d6	5a		phy				phy
.25d7	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.25da	7a		ply				ply
.25db	fa		plx				plx
.25dc	68		pla				pla
.25dd	60		rts				rts
.25de					CommandScreen:
.25de	fa		plx				plx
.25df	da		phx				phx
.25e0	5a		phy				phy
.25e1	20 5c 19	jsr $195c			jsr 	GetInteger8Bit
.25e4	18		clc				clc
.25e5	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.25e8	7a		ply				ply
.25e9	fa		plx				plx
.25ea	4c 22 10	jmp $1022			jmp 	NextCommand
.25ed					XCommandSleep:
.25ed	fa		plx				plx
.25ee	5a		phy				phy
.25ef	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.25f2	ca		dex				dex
.25f3	20 d0 25	jsr $25d0			jsr 	XReadClock 					; read clock to YXA
.25f6	18		clc				clc 								; calculate end time in zTemp0
.25f7	65 40		adc $40				adc 	NSMantissa0
.25f9	85 28		sta $28				sta 	zTemp0
.25fb	8a		txa				txa
.25fc	65 4c		adc $4c				adc 	NSMantissa1
.25fe	85 29		sta $29				sta 	zTemp0+1
.2600					_XCWait:
.2600	20 d0 25	jsr $25d0			jsr 	XReadClock 					; and wait for it.
.2603	c5 28		cmp $28				cmp 	zTemp0
.2605	d0 f9		bne $2600			bne 	_XCWait
.2607	e4 29		cpx $29				cpx 	zTemp0+1
.2609	d0 f5		bne $2600			bne 	_XCWait
.260b	a2 ff		ldx #$ff			ldx 	#$FF
.260d	7a		ply				ply
.260e	4c 22 10	jmp $1022			jmp 	NextCommand
.2611					X16_Audio_FMINIT:
.2611	fa		plx				plx
.2612	5a		phy			phy
.2613	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2616	63 c0					.word	X16A_ym_init
>2618	0a					.byte	X16_AudioCodeBank
.2619	a2 ff		ldx #$ff		ldx	#$FF
.261b	7a		ply			ply
.261c	4c 22 10	jmp $1022			jmp 	NextCommand
.261f					X16_Audio_FMNOTE:
.261f	fa		plx				plx
.2620	5a		phy			phy
.2621	20 c5 11	jsr $11c5		jsr		X16_Audio_Parameters8_8
.2624	18		clc			clc
.2625	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2628	03 c0					.word	X16A_bas_fmnote
>262a	0a					.byte	X16_AudioCodeBank
.262b	a2 ff		ldx #$ff		ldx	#$FF
.262d	7a		ply			ply
.262e	4c 22 10	jmp $1022			jmp 	NextCommand
.2631					X16_Audio_FMDRUM:
.2631	fa		plx				plx
.2632	5a		phy			phy
.2633	20 c5 11	jsr $11c5		jsr		X16_Audio_Parameters8_8
.2636	18		clc			clc
.2637	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>263a	6f c0					.word	X16A_ym_playdrum
>263c	0a					.byte	X16_AudioCodeBank
.263d	a2 ff		ldx #$ff		ldx	#$FF
.263f	7a		ply			ply
.2640	4c 22 10	jmp $1022			jmp 	NextCommand
.2643					X16_Audio_FMINST:
.2643	fa		plx				plx
.2644	5a		phy			phy
.2645	20 c5 11	jsr $11c5		jsr		X16_Audio_Parameters8_8
.2648	38		sec			sec
.2649	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>264c	69 c0					.word	X16A_ym_loadpatch
>264e	0a					.byte	X16_AudioCodeBank
.264f	a2 ff		ldx #$ff		ldx	#$FF
.2651	7a		ply			ply
.2652	4c 22 10	jmp $1022			jmp 	NextCommand
.2655					X16_Audio_FMVIB:
.2655	fa		plx				plx
.2656	5a		phy			phy
.2657	20 c5 11	jsr $11c5		jsr		X16_Audio_Parameters8_8
.265a	18		clc			clc
.265b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>265e	09 c0					.word	X16A_bas_fmvib
>2660	0a					.byte	X16_AudioCodeBank
.2661	a2 ff		ldx #$ff		ldx	#$FF
.2663	7a		ply			ply
.2664	4c 22 10	jmp $1022			jmp 	NextCommand
.2667					X16_Audio_FMFREQ:
.2667	fa		plx				plx
.2668	5a		phy			phy
.2669	20 bf 11	jsr $11bf		jsr		X16_Audio_Parameters8_16
.266c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>266f	00 c0					.word	X16A_bas_fmfreq
>2671	0a					.byte	X16_AudioCodeBank
.2672	a2 ff		ldx #$ff		ldx	#$FF
.2674	7a		ply			ply
.2675	4c 22 10	jmp $1022			jmp 	NextCommand
.2678					X16_Audio_FMVOL:
.2678	fa		plx				plx
.2679	5a		phy			phy
.267a	20 c5 11	jsr $11c5		jsr		X16_Audio_Parameters8_8
.267d	18		clc			clc
.267e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2681	75 c0					.word	X16A_ym_setatten
>2683	0a					.byte	X16_AudioCodeBank
.2684	a2 ff		ldx #$ff		ldx	#$FF
.2686	7a		ply			ply
.2687	4c 22 10	jmp $1022			jmp 	NextCommand
.268a					X16_Audio_FMPAN:
.268a	fa		plx				plx
.268b	5a		phy			phy
.268c	20 c5 11	jsr $11c5		jsr		X16_Audio_Parameters8_8
.268f	18		clc			clc
.2690	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2693	7e c0					.word	X16A_ym_setpan
>2695	0a					.byte	X16_AudioCodeBank
.2696	a2 ff		ldx #$ff		ldx	#$FF
.2698	7a		ply			ply
.2699	4c 22 10	jmp $1022			jmp 	NextCommand
.269c					X16_Audio_FMPLAY:
.269c	fa		plx				plx
.269d	5a		phy			phy
.269e	20 d6 11	jsr $11d6		jsr		X16_Audio_Parameters8_String
.26a1	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>26a4	06 c0					.word	X16A_bas_fmplaystring
>26a6	0a					.byte	X16_AudioCodeBank
.26a7	a2 ff		ldx #$ff		ldx	#$FF
.26a9	7a		ply			ply
.26aa	4c 22 10	jmp $1022			jmp 	NextCommand
.26ad					X16_Audio_FMCHORD:
.26ad	fa		plx				plx
.26ae	5a		phy			phy
.26af	20 d6 11	jsr $11d6		jsr		X16_Audio_Parameters8_String
.26b2	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>26b5	8d c0					.word	X16A_bas_fmchordstring
>26b7	0a					.byte	X16_AudioCodeBank
.26b8	a2 ff		ldx #$ff		ldx	#$FF
.26ba	7a		ply			ply
.26bb	4c 22 10	jmp $1022			jmp 	NextCommand
.26be					X16_Audio_FMPOKE:
.26be	fa		plx				plx
.26bf	5a		phy			phy
.26c0	20 c5 11	jsr $11c5		jsr		X16_Audio_Parameters8_8
.26c3	18		clc			clc
.26c4	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>26c7	8a c0					.word	X16A_ym_write
>26c9	0a					.byte	X16_AudioCodeBank
.26ca	a2 ff		ldx #$ff		ldx	#$FF
.26cc	7a		ply			ply
.26cd	4c 22 10	jmp $1022			jmp 	NextCommand
.26d0					X16_Audio_PSGINIT:
.26d0	fa		plx				plx
.26d1	5a		phy			phy
.26d2	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>26d5	4b c0					.word	X16A_psg_init
>26d7	0a					.byte	X16_AudioCodeBank
.26d8	a2 ff		ldx #$ff		ldx	#$FF
.26da	7a		ply			ply
.26db	4c 22 10	jmp $1022			jmp 	NextCommand
.26de					X16_Audio_PSGNOTE:
.26de	fa		plx				plx
.26df	5a		phy			phy
.26e0	20 c5 11	jsr $11c5		jsr		X16_Audio_Parameters8_8
.26e3	18		clc			clc
.26e4	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>26e7	12 c0					.word	X16A_bas_psgnote
>26e9	0a					.byte	X16_AudioCodeBank
.26ea	a2 ff		ldx #$ff		ldx	#$FF
.26ec	7a		ply			ply
.26ed	4c 22 10	jmp $1022			jmp 	NextCommand
.26f0					X16_Audio_PSGVOL:
.26f0	fa		plx				plx
.26f1	5a		phy			phy
.26f2	20 c5 11	jsr $11c5		jsr		X16_Audio_Parameters8_8
.26f5	18		clc			clc
.26f6	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>26f9	54 c0					.word	X16A_psg_setatten
>26fb	0a					.byte	X16_AudioCodeBank
.26fc	a2 ff		ldx #$ff		ldx	#$FF
.26fe	7a		ply			ply
.26ff	4c 22 10	jmp $1022			jmp 	NextCommand
.2702					X16_Audio_PSGWAV:
.2702	fa		plx				plx
.2703	5a		phy			phy
.2704	20 c5 11	jsr $11c5		jsr		X16_Audio_Parameters8_8
.2707	18		clc			clc
.2708	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>270b	15 c0					.word	X16A_bas_psgwav
>270d	0a					.byte	X16_AudioCodeBank
.270e	a2 ff		ldx #$ff		ldx	#$FF
.2710	7a		ply			ply
.2711	4c 22 10	jmp $1022			jmp 	NextCommand
.2714					X16_Audio_PSGFREQ:
.2714	fa		plx				plx
.2715	5a		phy			phy
.2716	20 bf 11	jsr $11bf		jsr		X16_Audio_Parameters8_16
.2719	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>271c	0f c0					.word	X16A_bas_psgfreq
>271e	0a					.byte	X16_AudioCodeBank
.271f	a2 ff		ldx #$ff		ldx	#$FF
.2721	7a		ply			ply
.2722	4c 22 10	jmp $1022			jmp 	NextCommand
.2725					X16_Audio_PSGPAN:
.2725	fa		plx				plx
.2726	5a		phy			phy
.2727	20 c5 11	jsr $11c5		jsr		X16_Audio_Parameters8_8
.272a	18		clc			clc
.272b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>272e	5a c0					.word	X16A_psg_setpan
>2730	0a					.byte	X16_AudioCodeBank
.2731	a2 ff		ldx #$ff		ldx	#$FF
.2733	7a		ply			ply
.2734	4c 22 10	jmp $1022			jmp 	NextCommand
.2737					X16_Audio_PSGPLAY:
.2737	fa		plx				plx
.2738	5a		phy			phy
.2739	20 d6 11	jsr $11d6		jsr		X16_Audio_Parameters8_String
.273c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>273f	18 c0					.word	X16A_bas_psgplaystring
>2741	0a					.byte	X16_AudioCodeBank
.2742	a2 ff		ldx #$ff		ldx	#$FF
.2744	7a		ply			ply
.2745	4c 22 10	jmp $1022			jmp 	NextCommand
.2748					X16_Audio_PSGCHORD:
.2748	fa		plx				plx
.2749	5a		phy			phy
.274a	20 d6 11	jsr $11d6		jsr		X16_Audio_Parameters8_String
.274d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2750	90 c0					.word	X16A_bas_psgchordstring
>2752	0a					.byte	X16_AudioCodeBank
.2753	a2 ff		ldx #$ff		ldx	#$FF
.2755	7a		ply			ply
.2756	4c 22 10	jmp $1022			jmp 	NextCommand
.2759					CommandCls:
.2759	fa		plx				plx
.275a	a9 93		lda #$93			lda 	#147
.275c	20 b0 25	jsr $25b0			jsr 	XPrintCharacterToChannel
.275f	4c 22 10	jmp $1022			jmp 	NextCommand
.2762					CommandLocate:
.2762	fa		plx				plx
.2763	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.2766	ca		dex				dex
.2767	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.276a	ca		dex				dex
.276b	a9 13		lda #$13			lda 	#$13 						; home.
.276d	20 b0 25	jsr $25b0			jsr 	XPrintCharacterToChannel
.2770	a9 1d		lda #$1d			lda 	#$1D 						; do cursor rights
.2772	a6 40		ldx $40				ldx 	NSMantissa0
.2774	20 81 27	jsr $2781			jsr 	_CLOutputXA
.2777	a9 11		lda #$11			lda 	#$11 						; do cursor downs.
.2779	a6 41		ldx $41				ldx 	NSMantissa0+1
.277b	20 81 27	jsr $2781			jsr 	_CLOutputXA
.277e	4c 22 10	jmp $1022			jmp 	NextCommand
.2781					_CLOutputXA:
.2781	ca		dex				dex
.2782	f0 07		beq $278b			beq 	_CLOExit
.2784	30 05		bmi $278b			bmi 	_CLOExit
.2786	20 b0 25	jsr $25b0			jsr 	XPrintCharacterToChannel
.2789	80 f6		bra $2781			bra 	_CLOutputXA
.278b					_CLOExit:
.278b	60		rts				rts
.278c					CommandColor:
.278c	fa		plx				plx
.278d	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.2790	ca		dex				dex
.2791	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.2794	ca		dex				dex
.2795	a5 41		lda $41				lda 	NSMantissa0+1 				; bgr specified
.2797	c9 ff		cmp #$ff			cmp 	#$FF
.2799	f0 08		beq $27a3			beq 	_CCNoBGR 					; if so, change background
.279b	20 ab 27	jsr $27ab			jsr 	_CCSetColour
.279e	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.27a0	20 b0 25	jsr $25b0			jsr 	XPrintCharacterToChannel
.27a3					_CCNoBGR:
.27a3	a5 40		lda $40				lda 	NSMantissa0
.27a5	20 ab 27	jsr $27ab			jsr 	_CCSetColour
.27a8	4c 22 10	jmp $1022			jmp 	NextCommand
.27ab					_CCSetColour:
.27ab	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.27ad	aa		tax				tax
.27ae	bd b5 27	lda $27b5,x			lda 	_CCCommandTable,x
.27b1	20 b0 25	jsr $25b0			jsr 	XPrintCharacterToChannel
.27b4	60		rts				rts
.27b5					_CCCommandTable:
>27b5	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>27bd	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.27c5					CommandVPOKE:
.27c5	fa		plx				plx
.27c6	20 5c 19	jsr $195c			jsr 	GetInteger8Bit 				; poke value
.27c9	48		pha				pha
.27ca	ca		dex				dex
.27cb	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.27ce	b5 40		lda $40,x			lda 	NSMantissa0,x
.27d0	8d 20 9f	sta $9f20			sta 	VRAMLow0
.27d3	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.27d5	8d 21 9f	sta $9f21			sta 	VRAMMed0
.27d8	ca		dex				dex
.27d9	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.27dc	20 5c 19	jsr $195c			jsr 	GetInteger8Bit
.27df	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.27e2	ca		dex				dex
.27e3	68		pla				pla 								; poke value back
.27e4	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.27e7	4c 22 10	jmp $1022			jmp 	NextCommand
.27ea					CommandVPEEK:
.27ea	fa		plx				plx
.27eb	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.27ee	b5 40		lda $40,x			lda 	NSMantissa0,x
.27f0	8d 20 9f	sta $9f20			sta 	VRAMLow0
.27f3	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.27f5	8d 21 9f	sta $9f21			sta 	VRAMMed0
.27f8	ca		dex				dex
.27f9	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.27fc	20 5c 19	jsr $195c			jsr 	GetInteger8Bit
.27ff	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.2802	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.2805	20 ef 2d	jsr $2def			jsr 	FloatSetByte 				; return as byte
.2808	4c 22 10	jmp $1022			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0034					NSStatus:
>0034							.fill 	MathStackSize
.0040					NSMantissa0:
>0040							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004c					NSMantissa1:
>004c							.fill 	MathStackSize
.0058					NSMantissa2:
>0058							.fill 	MathStackSize
.0064					NSMantissa3:
>0064							.fill 	MathStackSize
.0070					NSExponent:
>0070							.fill 	MathStackSize
.056a					numberBuffer:
>056a							.fill 	34
.280b					FloatSubtract:
.280b	b5 34		lda $34,x			lda 	NSStatus,x 					; negate top of stack
.280d	49 80		eor #$80			eor 	#$80
.280f	95 34		sta $34,x			sta 	NSStatus,x					; and fall through.
.2811					FloatAdd:
.2811	ca		dex				dex
.2812	b5 70		lda $70,x			lda 	NSExponent,x 				; can use optimised.
.2814	15 71		ora $71,x			ora 	NSExponent+1,x
.2816	15 64		ora $64,x			ora 	NSMantissa3,x
.2818	15 65		ora $65,x			ora 	NSMantissa3+1,x
.281a	d0 04		bne $2820			bne 	_FAUseFloat
.281c	20 ad 2b	jsr $2bad			jsr 	FloatInt32Add 				; use the int32 one.
.281f	60		rts				rts
.2820					_FAUseFloat:
.2820	20 42 2b	jsr $2b42			jsr 	FloatNormalise 				; normalise S[X]
.2823	f0 51		beq $2876			beq 	_FAReturn1
.2825	e8		inx				inx 								; normalise S[X+1]
.2826	20 42 2b	jsr $2b42			jsr 	FloatNormalise
.2829	ca		dex				dex
.282a	c9 00		cmp #$00			cmp 	#0
.282c	f0 60		beq $288e			beq 	_FAExit 					; if so, just return A
.282e	b5 70		lda $70,x			lda 	NSExponent,x 				; are the exponents the same ?
.2830	d5 71		cmp $71,x			cmp 	NSExponent+1,x
.2832	f0 18		beq $284c			beq 	_FAExponentsEqual
.2834	b5 70		lda $70,x			lda 	NSExponent,x 				; work out the larger exponent
.2836	a8		tay				tay
.2837	38		sec				sec 								; do a signed comparison of the exponents.
.2838	f5 71		sbc $71,x			sbc 	NSExponent+1,x
.283a	50 02		bvc $283e			bvc 	_FANoSignedChange
.283c	49 80		eor #$80			eor 	#$80
.283e					_FANoSignedChange:
.283e	29 80		and #$80			and 	#$80
.2840	10 02		bpl $2844			bpl 	_FAHaveMax
.2842	b4 71		ldy $71,x			ldy 	NSExponent+1,x
.2844					_FAHaveMax:
.2844	20 8f 28	jsr $288f			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.2847	e8		inx				inx
.2848	20 8f 28	jsr $288f			jsr 	_FAShiftToExponent
.284b	ca		dex				dex
.284c					_FAExponentsEqual:
.284c	b5 34		lda $34,x			lda 	NSStatus,x 					; are the signs the same
.284e	55 35		eor $35,x			eor 	NSStatus+1,x
.2850	30 0e		bmi $2860			bmi 	_FADifferentSigns
.2852	20 79 2b	jsr $2b79			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.2855	b5 64		lda $64,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.2857	10 35		bpl $288e			bpl 	_FAExit 					; if no, we are done.
.2859	20 06 2e	jsr $2e06			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.285c	f6 70		inc $70,x			inc 	NSExponent,x 				; bump the exponent and exit
.285e	80 2e		bra $288e			bra 	_FAExit
.2860					_FADifferentSigns:
.2860	20 93 2b	jsr $2b93			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.2863	b5 64		lda $64,x			lda 	NSMantissa3,x 				; is the result negative ?
.2865	10 06		bpl $286d			bpl 	_FACheckZero 				; if no, check for -0
.2867	20 af 2d	jsr $2daf			jsr 	FloatNegate 					; netate result
.286a	20 b6 2d	jsr $2db6			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.286d					_FACheckZero:
.286d	20 0f 2e	jsr $2e0f			jsr 	FloatIsZero	 				; check for -0
.2870	d0 1c		bne $288e			bne 	_FAExit
.2872	74 34		stz $34,x			stz 	NSStatus,x
.2874	80 18		bra $288e			bra 	_FAExit
.2876					_FAReturn1:
.2876	b5 41		lda $41,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.2878	95 40		sta $40,x			sta 	NSMantissa0,x
.287a	b5 4d		lda $4d,x			lda 	NSMantissa1+1,x
.287c	95 4c		sta $4c,x			sta 	NSMantissa1,x
.287e	b5 59		lda $59,x			lda 	NSMantissa2+1,x
.2880	95 58		sta $58,x			sta 	NSMantissa2,x
.2882	b5 65		lda $65,x			lda 	NSMantissa3+1,x
.2884	95 64		sta $64,x			sta 	NSMantissa3,x
.2886	b5 71		lda $71,x			lda 	NSExponent+1,x
.2888	95 70		sta $70,x			sta 	NSExponent,x
.288a	b5 35		lda $35,x			lda 	NSStatus+1,x
.288c	95 34		sta $34,x			sta 	NSStatus,x
.288e					_FAExit:
.288e	60		rts				rts
.288f					_FAShiftToExponent:
.288f					_FAShiftToExponent2:
.288f	98		tya				tya 								; compare Y to exponent
.2890	d5 70		cmp $70,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2892	f0 07		beq $289b			beq 	_FASEExit 					; exit if so.
.2894	20 06 2e	jsr $2e06			jsr 	FloatShiftRight	 			; shift the mantissa right
.2897	f6 70		inc $70,x			inc 	NSExponent,x 				; increment exponent
.2899	80 f4		bra $288f			bra 	_FAShiftToExponent2
.289b					_FASEExit:
.289b	60		rts				rts
.289c					CompareEqual:
.289c	b5 40		lda $40,x			lda 	NSMantissa0,x
.289e	d0 09		bne $28a9			bne 	ReturnFalse
.28a0					ReturnTrue:
.28a0	a9 01		lda #$01			lda 	#1
.28a2	95 40		sta $40,x			sta 	NSMantissa0,x
.28a4	a9 80		lda #$80			lda 	#$80
.28a6	95 34		sta $34,x			sta 	NSStatus,x
.28a8	60		rts				rts
.28a9					ReturnFalse:
.28a9	74 40		stz $40,x			stz 	NSMantissa0,x
.28ab	60		rts				rts
.28ac					CompareNotEqual:
.28ac	b5 40		lda $40,x			lda 	NSMantissa0,x
.28ae	d0 f0		bne $28a0			bne 	ReturnTrue
.28b0	80 f7		bra $28a9			bra 	ReturnFalse
.28b2					CompareLess:
.28b2	b5 40		lda $40,x			lda 	NSMantissa0,x
.28b4	c9 ff		cmp #$ff			cmp 	#$FF
.28b6	f0 e8		beq $28a0			beq 	ReturnTrue
.28b8	80 ef		bra $28a9			bra 	ReturnFalse
.28ba					CompareGreater:
.28ba	b5 40		lda $40,x			lda 	NSMantissa0,x
.28bc	c9 01		cmp #$01			cmp 	#$01
.28be	f0 e0		beq $28a0			beq 	ReturnTrue
.28c0	80 e7		bra $28a9			bra 	ReturnFalse
.28c2					CompareLessEqual:
.28c2	b5 40		lda $40,x			lda 	NSMantissa0,x
.28c4	c9 01		cmp #$01			cmp 	#$01
.28c6	d0 d8		bne $28a0			bne 	ReturnTrue
.28c8	80 df		bra $28a9			bra 	ReturnFalse
.28ca					CompareGreaterEqual:
.28ca	b5 40		lda $40,x			lda 	NSMantissa0,x
.28cc	c9 ff		cmp #$ff			cmp 	#$FF
.28ce	d0 d0		bne $28a0			bne 	ReturnTrue
.28d0	80 d7		bra $28a9			bra 	ReturnFalse
.28d2					FloatCompare:
.28d2	b5 70		lda $70,x			lda 	NSExponent,x 				; float comparison.
.28d4	15 6f		ora $6f,x			ora 	NSExponent-1,x 				; integer if both integer.
.28d6	48		pha				pha
.28d7	20 0b 28	jsr $280b			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.28da	68		pla				pla
.28db	d0 0c		bne $28e9			bne 	_FCCompareFloat
.28dd	b5 40		lda $40,x			lda 	NSMantissa0,x
.28df	15 4c		ora $4c,x			ora 	NSMantissa1,x
.28e1	15 58		ora $58,x			ora 	NSMantissa2,x
.28e3	15 64		ora $64,x			ora 	NSMantissa3,x
.28e5	f0 14		beq $28fb			beq 	_FCExit 					; if zero, return zero
.28e7	80 0a		bra $28f3			bra 	_FCSign
.28e9					_FCCompareFloat:
.28e9	b5 4c		lda $4c,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.28eb	29 f0		and #$f0			and 	#$F0
.28ed	15 58		ora $58,x			ora 	NSMantissa2,x
.28ef	15 64		ora $64,x			ora 	NSMantissa3,x
.28f1	f0 08		beq $28fb			beq 	_FCExit 					; zero, so approximately identical
.28f3					_FCSign:
.28f3	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.28f5	34 34		bit $34,x			bit 	NSStatus,x
.28f7	10 02		bpl $28fb			bpl 	_FCExit
.28f9					_FCNegative:
.28f9	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.28fb					_FCExit:
.28fb	20 ef 2d	jsr $2def			jsr 	FloatSetByte 				; set the result 255,0,1
.28fe	60		rts				rts
.28ff					FloatScalarTable:
>28ff	66 66 66 66				.dword $66666666 ; 0.1
>2903	de					.byte $de
>2904	1f 85 eb 51				.dword $51eb851f ; 0.01
>2908	db					.byte $db
>2909	4c 37 89 41				.dword $4189374c ; 0.001
>290d	d8					.byte $d8
>290e	ac 8b db 68				.dword $68db8bac ; 0.0001
>2912	d4					.byte $d4
>2913	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>2917	d1					.byte $d1
>2918	83 de 1b 43				.dword $431bde83 ; 1e-06
>291c	ce					.byte $ce
>291d	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>2921	ca					.byte $ca
>2922	89 3b e6 55				.dword $55e63b89 ; 1e-08
>2926	c7					.byte $c7
>2927	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>292b	c4					.byte $c4
>292c	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>2930	c0					.byte $c0
>2931	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>2935	bd					.byte $bd
.2936					FloatDivide:
.2936	48		pha				pha
.2937	20 42 2b	jsr $2b42			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.293a	ca		dex				dex
.293b	c9 00		cmp #$00			cmp 	#0
.293d	f0 1e		beq $295d			beq 	_FDZero
.293f	20 42 2b	jsr $2b42			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2942	f0 16		beq $295a			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.2944	20 a5 29	jsr $29a5			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.2947	20 72 29	jsr $2972			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.294a	20 42 2b	jsr $2b42			jsr		FloatNormalise 				; renormalise
.294d	20 38 2b	jsr $2b38			jsr 	FloatCalculateSign 			; calculate result sign
.2950	b5 70		lda $70,x			lda 	NSExponent,x 				; calculate exponent
.2952	38		sec				sec
.2953	f5 71		sbc $71,x			sbc 	NSExponent+1,x
.2955	38		sec				sec
.2956	e9 1e		sbc #$1e			sbc 	#30
.2958	95 70		sta $70,x			sta 	NSExponent,x
.295a					_FDExit:
.295a	68		pla				pla
.295b	18		clc				clc
.295c	60		rts				rts
.295d					_FDZero:
.295d	68		pla				pla
.295e	38		sec				sec
.295f	60		rts				rts
.2960					DivideInt32:
.2960	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart 			; make both integers
.2963	ca		dex				dex
.2964	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.2967	20 83 29	jsr $2983			jsr 	Int32Divide 				; divide
.296a	20 72 29	jsr $2972			jsr 	NSMCopyPlusTwoToZero 		; copy result
.296d	20 38 2b	jsr $2b38			jsr 	FloatCalculateSign 			; calculate result sign
.2970	18		clc				clc
.2971	60		rts				rts
.2972					NSMCopyPlusTwoToZero:
.2972	b5 42		lda $42,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.2974	95 40		sta $40,x			sta 	NSMantissa0,x
.2976	b5 4e		lda $4e,x			lda 	NSMantissa1+2,x
.2978	95 4c		sta $4c,x			sta 	NSMantissa1,x
.297a	b5 5a		lda $5a,x			lda 	NSMantissa2+2,x
.297c	95 58		sta $58,x			sta 	NSMantissa2,x
.297e	b5 66		lda $66,x			lda 	NSMantissa3+2,x
.2980	95 64		sta $64,x			sta 	NSMantissa3,x
.2982	60		rts				rts
.2983					Int32Divide:
.2983	48		pha				pha 								; save AXY
.2984	5a		phy				phy
.2985	20 d0 2d	jsr $2dd0			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2988	20 e9 2d	jsr $2de9			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.298b	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.298d					_I32DivideLoop:
.298d	e8		inx				inx
.298e	e8		inx				inx
.298f	20 fc 2d	jsr $2dfc			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2992	ca		dex				dex
.2993	ca		dex				dex
.2994	20 fd 2d	jsr $2dfd			jsr 	FloatRotateLeft
.2997	20 c3 29	jsr $29c3			jsr 	FloatDivideCheck 			; check if subtract possible
.299a	90 02		bcc $299e			bcc 	_I32DivideNoCarryIn
.299c	f6 42		inc $42,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.299e					_I32DivideNoCarryIn:
.299e	88		dey				dey 								; loop round till division completed.
.299f	d0 ec		bne $298d			bne 	_I32DivideLoop
.29a1	7a		ply				ply 								; restore AXY and exit
.29a2	68		pla				pla
.29a3	18		clc				clc
.29a4	60		rts				rts
.29a5					Int32ShiftDivide:
.29a5	48		pha				pha 								; save AY
.29a6	5a		phy				phy
.29a7	e8		inx				inx 								; clear S[X+2]
.29a8	e8		inx				inx
.29a9	20 ed 2d	jsr $2ded			jsr 	FloatSetZero
.29ac	ca		dex				dex
.29ad	ca		dex				dex
.29ae	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.29b0					_I32SDLoop:
.29b0	20 c3 29	jsr $29c3			jsr 	FloatDivideCheck 			; check if subtract possible
.29b3	e8		inx				inx
.29b4	e8		inx				inx
.29b5	20 fd 2d	jsr $2dfd			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.29b8	ca		dex				dex
.29b9	ca		dex				dex
.29ba	20 fd 2d	jsr $2dfd			jsr 	FloatRotateLeft
.29bd	88		dey				dey 	 							; do 31 times
.29be	d0 f0		bne $29b0			bne 	_I32SDLoop
.29c0	7a		ply				ply 								; restore AY and exit
.29c1	68		pla				pla
.29c2	60		rts				rts
.29c3					FloatDivideCheck:
.29c3	20 93 2b	jsr $2b93			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.29c6	b0 04		bcs $29cc			bcs 	_DCSExit 					; if carry set, then could do, exit
.29c8	20 79 2b	jsr $2b79			jsr 	FloatAddTopTwoStack 		; add it back in
.29cb	18		clc				clc 								; and return False
.29cc					_DCSExit:
.29cc	60		rts				rts
.29cd					FloatFractionalPart:
.29cd	5a		phy				phy
.29ce	b5 34		lda $34,x			lda 	NSStatus,x 					; take absolute value
.29d0	29 7f		and #$7f			and 	#$7F
.29d2	95 34		sta $34,x			sta 	NSStatus,x
.29d4	20 42 2b	jsr $2b42			jsr 	FloatNormalise
.29d7	b5 70		lda $70,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.29d9	38		sec				sec
.29da	e9 e0		sbc #$e0			sbc 	#$E0
.29dc	90 29		bcc $2a07			bcc 	_FFPExit 					; already fractional
.29de	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.29e0	b0 22		bcs $2a04			bcs 	_FFPZero
.29e2	a8		tay				tay 								; put count to do in Y
.29e3	b5 64		lda $64,x			lda 	NSMantissa3,x 				; do each in turn.
.29e5	20 0c 2a	jsr $2a0c			jsr 	_FFPPartial
.29e8	95 64		sta $64,x			sta 	NSMantissa3,x
.29ea	b5 58		lda $58,x			lda 	NSMantissa2,x
.29ec	20 0c 2a	jsr $2a0c			jsr 	_FFPPartial
.29ef	95 58		sta $58,x			sta 	NSMantissa2,x
.29f1	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.29f3	20 0c 2a	jsr $2a0c			jsr 	_FFPPartial
.29f6	95 4c		sta $4c,x			sta 	NSMantissa1,x
.29f8	b5 40		lda $40,x			lda 	NSMantissa0,x
.29fa	20 0c 2a	jsr $2a0c			jsr 	_FFPPartial
.29fd	95 40		sta $40,x			sta 	NSMantissa0,x
.29ff	20 0f 2e	jsr $2e0f			jsr 	FloatIsZero 					; zeroed check.
.2a02	d0 03		bne $2a07			bne 	_FFPExit
.2a04					_FFPZero:
.2a04	20 ed 2d	jsr $2ded			jsr 	FloatSetZero
.2a07					_FFPExit:
.2a07	20 42 2b	jsr $2b42			jsr 	FloatNormalise
.2a0a	7a		ply				ply
.2a0b	60		rts				rts
.2a0c					_FFPPartial:
.2a0c	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2a0e	f0 17		beq $2a27			beq 	_FFFPPExit
.2a10	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.2a12	b0 0c		bcs $2a20			bcs 	_FFFPPWholeByte
.2a14	5a		phy				phy
.2a15					_FFFPPLeft:
.2a15	0a		asl a				asl 	a
.2a16	88		dey				dey
.2a17	d0 fc		bne $2a15			bne 	_FFFPPLeft
.2a19	7a		ply				ply
.2a1a					_FFFPPRight:
.2a1a	4a		lsr a				lsr 	a
.2a1b	88		dey				dey
.2a1c	d0 fc		bne $2a1a			bne 	_FFFPPRight
.2a1e	80 07		bra $2a27			bra 	_FFFPPExit
.2a20					_FFFPPWholeByte:
.2a20	98		tya				tya 								; subtract 8 from count
.2a21	38		sec				sec
.2a22	e9 08		sbc #$08			sbc 	#8
.2a24	a8		tay				tay
.2a25	a9 00		lda #$00			lda 	#0 							; and clear all
.2a27					_FFFPPExit:
.2a27	60		rts				rts
.2a28					FloatIntegerPart:
.2a28	48		pha				pha
.2a29	b5 70		lda $70,x			lda 	NSExponent,x 				; is it integer already ?
.2a2b	f0 1d		beq $2a4a			beq 	_FIPExit 					; if so do nothing
.2a2d	20 0f 2e	jsr $2e0f			jsr 	FloatIsZero 				; is it zero ?
.2a30	f0 15		beq $2a47			beq 	_FIPZero 					; if so return zero.
.2a32	20 42 2b	jsr $2b42			jsr 	FloatNormalise 				; normalise
.2a35	f0 10		beq $2a47			beq 	_FIPZero 					; normalised to zero, exit zero
.2a37					_FIPShift:
.2a37	b5 70		lda $70,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2a39	10 07		bpl $2a42			bpl 	_FIPCheckZero
.2a3b	20 06 2e	jsr $2e06			jsr 	FloatShiftRight 			; shift mantissa right
.2a3e	f6 70		inc $70,x			inc 	NSExponent,x 				; bump exponent
.2a40	80 f5		bra $2a37			bra 	_FIPShift
.2a42					_FIPCheckZero:
.2a42	20 0f 2e	jsr $2e0f			jsr 	FloatIsZero 				; avoid -0 problem
.2a45	d0 03		bne $2a4a			bne 	_FIPExit 					; set to zero if mantissa zero.
.2a47					_FIPZero:
.2a47	20 ed 2d	jsr $2ded			jsr 	FloatSetZero
.2a4a					_FIPExit:
.2a4a	68		pla				pla
.2a4b	60		rts				rts
.2a4c					FloatIntegerPartDown:
.2a4c	48		pha				pha
.2a4d	5a		phy				phy
.2a4e	b5 70		lda $70,x			lda 	NSExponent,x 				; is it integer already ?
.2a50	f0 36		beq $2a88			beq 	_FIPExit 					; if so do nothing
.2a52	20 0f 2e	jsr $2e0f			jsr 	FloatIsZero 				; is it zero ?
.2a55	f0 2e		beq $2a85			beq 	_FIPZero 					; if so return zero.
.2a57	20 42 2b	jsr $2b42			jsr 	FloatNormalise 				; normalise
.2a5a	f0 29		beq $2a85			beq 	_FIPZero 					; normalised to zero, exit zero
.2a5c	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.2a5e					_FIPShift:
.2a5e	b5 70		lda $70,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2a60	10 0a		bpl $2a6c			bpl 	_FIPCheckDown
.2a62	20 06 2e	jsr $2e06			jsr 	FloatShiftRight 			; shift mantissa right
.2a65	90 01		bcc $2a68			bcc 	_FIPNoFrac 					; shifted a zero out ?
.2a67	c8		iny				iny
.2a68					_FIPNoFrac:
.2a68	f6 70		inc $70,x			inc 	NSExponent,x 				; bump exponent
.2a6a	80 f2		bra $2a5e			bra 	_FIPShift
.2a6c					_FIPCheckDown:
.2a6c	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.2a6e	f0 10		beq $2a80			beq 	_FIPCheckZero
.2a70	34 34		bit $34,x			bit 	NSStatus,x 					; +ve
.2a72	10 0c		bpl $2a80			bpl 	_FIPCheckZero
.2a74	e8		inx				inx 								; -ve so round *down*.
.2a75	a9 01		lda #$01			lda 	#1
.2a77	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.2a7a	20 af 2d	jsr $2daf			jsr 	FloatNegate
.2a7d	20 11 28	jsr $2811			jsr 	FloatAdd
.2a80					_FIPCheckZero:
.2a80	20 0f 2e	jsr $2e0f			jsr 	FloatIsZero 				; avoid -0 problem
.2a83	d0 03		bne $2a88			bne 	_FIPExit 					; set to zero if mantissa zero.
.2a85					_FIPZero:
.2a85	20 ed 2d	jsr $2ded			jsr 	FloatSetZero
.2a88					_FIPExit:
.2a88	7a		ply				ply
.2a89	68		pla				pla
.2a8a	60		rts				rts
.2a8b					FloatInt8Multiply:
.2a8b	5a		phy				phy
.2a8c	b5 40		lda $40,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2a8e	a8		tay				tay
.2a8f	74 40		stz $40,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2a91					_FI8MLoop:
.2a91	98		tya				tya 								; shift right shifter right into carry
.2a92	4a		lsr a				lsr 	a
.2a93	a8		tay				tay
.2a94	90 0d		bcc $2aa3			bcc 	_FI8MNoAdd
.2a96	18		clc				clc
.2a97	b5 40		lda $40,x			lda 	NSMantissa0,x
.2a99	75 41		adc $41,x			adc 	NSMantissa0+1,x
.2a9b	95 40		sta $40,x			sta 	NSMantissa0,x
.2a9d	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2a9f	75 4d		adc $4d,x			adc 	NSMantissa1+1,x
.2aa1	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2aa3					_FI8MNoAdd:
.2aa3	16 41		asl $41,x			asl 	NSMantissa0+1,x 			; shift adder left
.2aa5	36 4d		rol $4d,x			rol 	NSMantissa1+1,x
.2aa7	c0 00		cpy #$00			cpy 	#0
.2aa9	d0 e6		bne $2a91			bne 	_FI8MLoop 					; until right shifter zero.
.2aab	7a		ply				ply
.2aac	60		rts				rts
.2aad					FloatMultiply:
.2aad	ca		dex				dex
.2aae	b5 70		lda $70,x			lda 	NSExponent,x 				; can use optimised ?
.2ab0	15 71		ora $71,x			ora 	NSExponent+1,x
.2ab2	15 64		ora $64,x			ora 	NSMantissa3,x
.2ab4	15 65		ora $65,x			ora 	NSMantissa3+1,x
.2ab6	d0 21		bne $2ad9			bne 	_FMUseFloat
.2ab8	b5 34		lda $34,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2aba	15 35		ora $35,x			ora 	NSStatus+1,x
.2abc	29 80		and #$80			and 	#$80
.2abe	15 64		ora $64,x			ora 	NSMantissa3,x
.2ac0	15 58		ora $58,x			ora 	NSMantissa2,x
.2ac2	15 4c		ora $4c,x			ora 	NSMantissa1,x
.2ac4	15 65		ora $65,x			ora 	NSMantissa3+1,x
.2ac6	15 59		ora $59,x			ora 	NSMantissa2+1,x
.2ac8	15 4d		ora $4d,x			ora 	NSMantissa1+1,x
.2aca	d0 04		bne $2ad0			bne 	_FMInt32
.2acc	20 8b 2a	jsr $2a8b			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2acf	60		rts				rts
.2ad0					_FMInt32:
.2ad0	20 fa 2a	jsr $2afa			jsr 	FloatMultiplyShort			; use the int32 one.
.2ad3	18		clc				clc 								; fix it up if gone out of range
.2ad4	75 70		adc $70,x			adc 	NSExponent,x
.2ad6	95 70		sta $70,x			sta 	NSExponent,x
.2ad8	60		rts				rts
.2ad9					_FMUseFloat:
.2ad9	20 42 2b	jsr $2b42			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2adc	f0 18		beq $2af6			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2ade	e8		inx				inx
.2adf	20 42 2b	jsr $2b42			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2ae2	ca		dex				dex
.2ae3	c9 00		cmp #$00			cmp 	#0
.2ae5	f0 0c		beq $2af3			beq 	_FDSetZero
.2ae7	20 fa 2a	jsr $2afa			jsr 	FloatMultiplyShort 			; calculate the result.
.2aea	75 70		adc $70,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2aec	18		clc				clc
.2aed	75 71		adc $71,x			adc 	NSExponent+1,x
.2aef	95 70		sta $70,x			sta 	NSExponent,x
.2af1	80 03		bra $2af6			bra 	_FDExit
.2af3					_FDSetZero:
.2af3	20 ed 2d	jsr $2ded			jsr 	FloatSetZero 				; return 0
.2af6					_FDExit:
.2af6	20 42 2b	jsr $2b42			jsr 	FloatNormalise 				; normalise the result
.2af9	60		rts				rts
.2afa					FloatMultiplyShort:
.2afa	5a		phy				phy 								; save Y
.2afb	20 d0 2d	jsr $2dd0			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2afe	20 e9 2d	jsr $2de9			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2b01	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2b03					_I32MLoop:
.2b03	b5 42		lda $42,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2b05	15 4e		ora $4e,x			ora 	NSMantissa1+2,x
.2b07	15 5a		ora $5a,x			ora 	NSMantissa2+2,x
.2b09	15 66		ora $66,x			ora 	NSMantissa3+2,x
.2b0b	f0 25		beq $2b32			beq 	_I32MExit 					; exit if zero
.2b0d	b5 42		lda $42,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2b0f	29 01		and #$01			and 	#1
.2b11	f0 0d		beq $2b20			beq 	_I32MNoAdd
.2b13	20 79 2b	jsr $2b79			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.2b16	b5 64		lda $64,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.2b18	10 06		bpl $2b20			bpl 	_I32MNoAdd
.2b1a					_I32ShiftRight:
.2b1a	20 06 2e	jsr $2e06			jsr 	FloatShiftRight 			; shift S[X] right
.2b1d	c8		iny				iny 								; increment shift count
.2b1e	80 09		bra $2b29			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.2b20					_I32MNoAdd:
.2b20	34 65		bit $65,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.2b22	70 f6		bvs $2b1a			bvs 	_I32ShiftRight 				; instead.
.2b24	e8		inx				inx
.2b25	20 fc 2d	jsr $2dfc			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.2b28	ca		dex				dex
.2b29					_I32MShiftUpper:
.2b29	e8		inx				inx 								; shift S[X+2] right
.2b2a	e8		inx				inx
.2b2b	20 06 2e	jsr $2e06			jsr 	FloatShiftRight
.2b2e	ca		dex				dex
.2b2f	ca		dex				dex
.2b30	80 d1		bra $2b03			bra 	_I32MLoop 					; try again.
.2b32					_I32MExit:
.2b32	20 38 2b	jsr $2b38			jsr 	FloatCalculateSign
.2b35	98		tya				tya 								; shift in A
.2b36	7a		ply				ply 								; restore Y and exit
.2b37	60		rts				rts
.2b38					FloatCalculateSign:
.2b38	b5 34		lda $34,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.2b3a	16 34		asl $34,x			asl 	NSStatus,x 					; shift result left
.2b3c	55 35		eor $35,x			eor 	NSStatus+1,x
.2b3e	0a		asl a				asl 	a 							; shift bit 7 into carry
.2b3f	76 34		ror $34,x			ror 	NSStatus,x 					; shift right into status byte.
.2b41	60		rts				rts
.2b42					FloatNormalise:
.2b42	20 0f 2e	jsr $2e0f			jsr 	FloatIsZero 				; if zero exit
.2b45	d0 07		bne $2b4e			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.2b47	16 34		asl $34,x			asl 	NSStatus,x 					; clear the sign bit.
.2b49	76 34		ror $34,x			ror 	NSStatus,x 					; (no -0)
.2b4b	a9 00		lda #$00			lda 	#0 							; set Z flag
.2b4d	60		rts				rts
.2b4e					_NSNormaliseOptimise:
.2b4e	b5 64		lda $64,x			lda 	NSMantissa3,x 				; upper byte zero ?
.2b50	d0 19		bne $2b6b			bne 	_NSNormaliseLoop
.2b52	b5 58		lda $58,x			lda 	NSMantissa2,x 				; byte normalise
.2b54	30 15		bmi $2b6b			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.2b56	95 64		sta $64,x			sta 	NSMantissa3,x
.2b58	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2b5a	95 58		sta $58,x			sta 	NSMantissa2,x
.2b5c	b5 40		lda $40,x			lda 	NSMantissa0,x
.2b5e	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2b60	74 40		stz $40,x			stz 	NSMantissa0,x
.2b62	b5 70		lda $70,x			lda 	NSExponent,x
.2b64	38		sec				sec
.2b65	e9 08		sbc #$08			sbc 	#8
.2b67	95 70		sta $70,x			sta 	NSExponent,x
.2b69	80 e3		bra $2b4e			bra 	_NSNormaliseOptimise
.2b6b					_NSNormaliseLoop:
.2b6b	34 64		bit $64,x			bit 	NSMantissa3,x 				; bit 30 set ?
.2b6d	70 07		bvs $2b76			bvs 	_NSNExit 					; exit if so with Z flag clear
.2b6f	20 fc 2d	jsr $2dfc			jsr 	FloatShiftLeft 				; shift mantissa left
.2b72	d6 70		dec $70,x			dec 	NSExponent,x 				; adjust exponent
.2b74	80 f5		bra $2b6b			bra 	_NSNormaliseLoop
.2b76					_NSNExit:
.2b76	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.2b78	60		rts				rts
.2b79					FloatAddTopTwoStack:
.2b79	18		clc				clc
.2b7a	b5 40		lda $40,x			lda		NSMantissa0,x
.2b7c	75 41		adc $41,x			adc 		NSMantissa0+1,x
.2b7e	95 40		sta $40,x			sta 	NSMantissa0,x
.2b80	b5 4c		lda $4c,x			lda		NSMantissa1,x
.2b82	75 4d		adc $4d,x			adc 		NSMantissa1+1,x
.2b84	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2b86	b5 58		lda $58,x			lda		NSMantissa2,x
.2b88	75 59		adc $59,x			adc 		NSMantissa2+1,x
.2b8a	95 58		sta $58,x			sta 	NSMantissa2,x
.2b8c	b5 64		lda $64,x			lda		NSMantissa3,x
.2b8e	75 65		adc $65,x			adc 		NSMantissa3+1,x
.2b90	95 64		sta $64,x			sta 	NSMantissa3,x
.2b92	60		rts				rts
.2b93					FloatSubTopTwoStack:
.2b93	38		sec				sec
.2b94	b5 40		lda $40,x			lda		NSMantissa0,x
.2b96	f5 41		sbc $41,x			sbc 		NSMantissa0+1,x
.2b98	95 40		sta $40,x			sta 	NSMantissa0,x
.2b9a	b5 4c		lda $4c,x			lda		NSMantissa1,x
.2b9c	f5 4d		sbc $4d,x			sbc 		NSMantissa1+1,x
.2b9e	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2ba0	b5 58		lda $58,x			lda		NSMantissa2,x
.2ba2	f5 59		sbc $59,x			sbc 		NSMantissa2+1,x
.2ba4	95 58		sta $58,x			sta 	NSMantissa2,x
.2ba6	b5 64		lda $64,x			lda		NSMantissa3,x
.2ba8	f5 65		sbc $65,x			sbc 		NSMantissa3+1,x
.2baa	95 64		sta $64,x			sta 	NSMantissa3,x
.2bac	60		rts				rts
.2bad					FloatInt32Add:
.2bad	b5 34		lda $34,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2baf	55 35		eor $35,x			eor 	NSStatus+1,x
.2bb1	30 04		bmi $2bb7			bmi 	_DiffSigns
.2bb3	20 79 2b	jsr $2b79			jsr		FloatAddTopTwoStack
.2bb6	60		rts				rts
.2bb7					_DiffSigns:
.2bb7	20 93 2b	jsr $2b93			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2bba	34 64		bit $64,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2bbc	10 07		bpl $2bc5			bpl 	_AddExit
.2bbe	b5 35		lda $35,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2bc0	95 34		sta $34,x			sta 	NSStatus,x
.2bc2	20 b6 2d	jsr $2db6			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2bc5					_AddExit:
.2bc5	20 0f 2e	jsr $2e0f			jsr 	FloatIsZero 				; check for -0
.2bc8	d0 02		bne $2bcc			bne 	_AddNonZero
.2bca	74 34		stz $34,x			stz 	NSStatus,x
.2bcc					_AddNonZero:
.2bcc	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2bcd					FloatEncodeStart:
.2bcd	38		sec				sec
.2bce	80 01		bra $2bd1			bra 	FloatEncodeContinue+1
.2bd0					FloatEncodeContinue:
.2bd0	18		clc				clc
.2bd1					FloatEncode:
.2bd1	08		php				php 								; save reset flag.
.2bd2	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2bd4	f0 15		beq $2beb			beq 	_ENIsOkay
.2bd6	c9 30		cmp #$30			cmp 	#"0"
.2bd8	90 04		bcc $2bde			bcc 	_ENBadNumber
.2bda	c9 3a		cmp #$3a			cmp 	#"9"+1
.2bdc	90 0d		bcc $2beb			bcc 	_ENIsOkay
.2bde					_ENBadNumber:
.2bde	28		plp				plp 								; throw saved reset
.2bdf	ad 8c 05	lda $058c			lda 	encodeState 				; if in decimal mode, construct final number
.2be2	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2be4	d0 03		bne $2be9			bne 	_ENFail
.2be6	4c 63 2c	jmp $2c63			jmp 	_ENConstructFinal
.2be9					_ENFail:
.2be9	18		clc				clc 								; not allowed
.2bea	60		rts				rts
.2beb					_ENIsOkay:
.2beb	28		plp				plp 								; are we restarting
.2bec	90 15		bcc $2c03			bcc 	_ENNoRestart
.2bee					_ENStartEncode:
.2bee	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2bf0	f0 0c		beq $2bfe			beq 	_ENFirstDP
.2bf2	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2bf4	20 ef 2d	jsr $2def			jsr 	FloatSetByte 				; in single byte mode.
.2bf7	a9 01		lda #$01			lda 	#ESTA_Low
.2bf9					_ENExitChange:
.2bf9	8d 8c 05	sta $058c			sta 	encodeState 				; save new state
.2bfc	38		sec				sec
.2bfd	60		rts				rts
.2bfe					_ENFirstDP:
.2bfe	20 ed 2d	jsr $2ded			jsr 	FloatSetZero 				; clear integer part
.2c01	80 3c		bra $2c3f			bra 	_ESTASwitchFloat			; go straight to float and exi
.2c03					_ENNoRestart:
.2c03	48		pha				pha 								; save digit or DP on stack.
.2c04	ad 8c 05	lda $058c			lda 	encodeState 				; get current state
.2c07	c9 01		cmp #$01			cmp 	#ESTA_Low
.2c09	f0 09		beq $2c14			beq  	_ESTALowState
.2c0b	c9 02		cmp #$02			cmp 	#ESTA_High
.2c0d	f0 26		beq $2c35			beq 	_ESTAHighState
.2c0f	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2c11	f0 38		beq $2c4b			beq 	_ESTADecimalState
>2c13	db						.byte 	$DB 						; causes a break in the emulator
.2c14					_ESTALowState:
.2c14	68		pla				pla 								; get value back
.2c15	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.2c17	f0 26		beq $2c3f			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.2c19	29 0f		and #$0f			and 	#15 						; make digit
.2c1b	8d 8d 05	sta $058d			sta 	digitTemp 					; save it.
.2c1e	b5 40		lda $40,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.2c20	0a		asl a				asl 	a
.2c21	0a		asl a				asl 	a
.2c22	75 40		adc $40,x			adc 	NSMantissa0,x
.2c24	0a		asl a				asl 	a
.2c25	6d 8d 05	adc $058d			adc 	digitTemp
.2c28	95 40		sta $40,x			sta 	NSMantissa0,x
.2c2a	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.2c2c	90 05		bcc $2c33			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.2c2e	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.2c30	8d 8c 05	sta $058c			sta 	encodeState
.2c33					_ESTANoSwitch:
.2c33	38		sec				sec
.2c34	60		rts				rts
.2c35					_ESTAHighState:
.2c35	68		pla				pla 								; get value back
.2c36	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.2c38	f0 05		beq $2c3f			beq 	_ESTASwitchFloat
.2c3a	20 95 2c	jsr $2c95			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.2c3d	38		sec				sec
.2c3e	60		rts				rts
.2c3f					_ESTASwitchFloat:
.2c3f	9c 8e 05	stz $058e			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.2c42	e8		inx				inx 								; zero the decimal additive.
.2c43	20 ed 2d	jsr $2ded			jsr 	FloatSetZero
.2c46	ca		dex				dex
.2c47	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.2c49	80 ae		bra $2bf9			bra 	_ENExitChange
.2c4b					_ESTADecimalState:
.2c4b	68		pla				pla 								; digit.
.2c4c	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.2c4e	f0 99		beq $2be9			beq 	_ENFail
.2c50	e8		inx				inx 								; put digit into fractional part of X+1
.2c51	20 95 2c	jsr $2c95			jsr 	ESTAShiftDigitIntoMantissa
.2c54	ca		dex				dex
.2c55	ee 8e 05	inc $058e			inc 	decimalCount 				; bump the count of decimals
.2c58	ad 8e 05	lda $058e			lda 	decimalCount 				; too many decimal digits.
.2c5b	c9 0b		cmp #$0b			cmp 	#11
.2c5d	f0 02		beq $2c61			beq 	_ESTADSFail
.2c5f	38		sec				sec
.2c60	60		rts				rts
.2c61					_ESTADSFail:
.2c61	18		clc				clc
.2c62	60		rts				rts
.2c63					_ENConstructFinal:
.2c63	ad 8e 05	lda $058e			lda 	decimalCount 				; get decimal count
.2c66	f0 2b		beq $2c93			beq 	_ENCFExit 					; no decimals
.2c68	5a		phy				phy
.2c69	0a		asl a				asl 	a 							; x 4 and CLC
.2c6a	0a		asl a				asl 	a
.2c6b	6d 8e 05	adc $058e			adc 	decimalCount
.2c6e	a8		tay				tay
.2c6f	b9 fa 28	lda $28fa,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.2c72	95 42		sta $42,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.2c74	b9 fb 28	lda $28fb,y			lda 	FloatScalarTable-5+1,y
.2c77	95 4e		sta $4e,x			sta 	NSMantissa1+2,x
.2c79	b9 fc 28	lda $28fc,y			lda 	FloatScalarTable-5+2,y
.2c7c	95 5a		sta $5a,x			sta 	NSMantissa2+2,x
.2c7e	b9 fd 28	lda $28fd,y			lda 	FloatScalarTable-5+3,y
.2c81	95 66		sta $66,x			sta 	NSMantissa3+2,x
.2c83	b9 fe 28	lda $28fe,y			lda 	FloatScalarTable-5+4,y
.2c86	95 72		sta $72,x			sta 	NSExponent+2,x
.2c88	74 36		stz $36,x			stz 	NSStatus+2,x 				; make +ve
.2c8a	e8		inx				inx 								; multiply decimal const by decimal scalar
.2c8b	e8		inx				inx
.2c8c	20 ad 2a	jsr $2aad			jsr 	FloatMultiply
.2c8f	20 11 28	jsr $2811			jsr 	FloatAdd 					; add to integer part.
.2c92	7a		ply				ply
.2c93					_ENCFExit:
.2c93	18		clc				clc 								; reject the digit.
.2c94	60		rts				rts
.2c95					ESTAShiftDigitIntoMantissa:
.2c95	29 0f		and #$0f			and 	#15 						; save digit
.2c97	48		pha				pha
.2c98	b5 64		lda $64,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2c9a	48		pha				pha
.2c9b	b5 58		lda $58,x			lda 	NSMantissa2,x
.2c9d	48		pha				pha
.2c9e	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2ca0	48		pha				pha
.2ca1	b5 40		lda $40,x			lda 	NSMantissa0,x
.2ca3	48		pha				pha
.2ca4	20 fc 2d	jsr $2dfc			jsr 	FloatShiftLeft 				; x 2
.2ca7	20 fc 2d	jsr $2dfc			jsr 	FloatShiftLeft 				; x 4
.2caa	18		clc				clc 								; pop mantissa and add
.2cab	68		pla				pla
.2cac	75 40		adc $40,x			adc 	NSMantissa0,x
.2cae	95 40		sta $40,x			sta 	NSMantissa0,x
.2cb0	68		pla				pla
.2cb1	75 4c		adc $4c,x			adc 	NSMantissa1,x
.2cb3	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2cb5	68		pla				pla
.2cb6	75 58		adc $58,x			adc 	NSMantissa2,x
.2cb8	95 58		sta $58,x			sta 	NSMantissa2,x
.2cba	68		pla				pla
.2cbb	75 64		adc $64,x			adc 	NSMantissa3,x
.2cbd	95 64		sta $64,x			sta 	NSMantissa3,x 				; x 5
.2cbf	20 fc 2d	jsr $2dfc			jsr 	FloatShiftLeft 				; x 10
.2cc2	68		pla				pla 								; add digit
.2cc3	18		clc				clc
.2cc4	75 40		adc $40,x			adc 	NSMantissa0,x
.2cc6	95 40		sta $40,x			sta 	NSMantissa0,x
.2cc8	90 0a		bcc $2cd4			bcc 	_ESTASDExit
.2cca	f6 4c		inc $4c,x			inc 	NSMantissa1,x
.2ccc	d0 06		bne $2cd4			bne 	_ESTASDExit
.2cce	f6 58		inc $58,x			inc 	NSMantissa2,x
.2cd0	d0 02		bne $2cd4			bne 	_ESTASDExit
.2cd2	f6 64		inc $64,x			inc 	NSMantissa3,x
.2cd4					_ESTASDExit:
.2cd4	60		rts				rts
.058c					encodeState:
>058c							.fill 	1
.058d					digitTemp:
>058d							.fill 	1
.058e					decimalCount:
>058e							.fill 	1
.2cd5					FloatToString:
.2cd5	da		phx				phx
.2cd6	5a		phy				phy 								; save code position
.2cd7	8d 8f 05	sta $058f			sta 	decimalPlaces	 			; save number of DPs.
.2cda	9c 90 05	stz $0590			stz 	dbOffset 					; offset into decimal buffer = start.
.2cdd	b5 34		lda $34,x			lda 	NSStatus,x  				; is it -ve.
.2cdf	10 08		bpl $2ce9			bpl 	_CNTSNotNegative
.2ce1	29 7f		and #$7f			and 	#$7F 						; make +ve
.2ce3	95 34		sta $34,x			sta 	NSStatus,x
.2ce5	a9 2d		lda #$2d			lda 	#"-"
.2ce7	80 02		bra $2ceb			bra 	_CNTMain
.2ce9					_CNTSNotNegative:
.2ce9	a9 20		lda #$20			lda 	#" "
.2ceb					_CNTMain:
.2ceb	20 4d 2d	jsr $2d4d			jsr 	WriteDecimalBuffer
.2cee	b5 70		lda $70,x			lda 	NSExponent,x 				; check if decimal
.2cf0	f0 0d		beq $2cff			beq 	_CNTSNotFloat
.2cf2	e8		inx				inx 								; round up so we don't get too many 6.999999
.2cf3	a9 01		lda #$01			lda 	#1
.2cf5	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.2cf8	b5 6f		lda $6f,x			lda		NSExponent-1,x
.2cfa	95 70		sta $70,x			sta 	NSExponent,x
.2cfc	20 11 28	jsr $2811			jsr 	FloatAdd
.2cff					_CNTSNotFloat:
.2cff	20 2f 2d	jsr $2d2f			jsr 	MakePlusTwoString 			; do the integer part.
.2d02	20 cd 29	jsr $29cd			jsr 	FloatFractionalPart 		; get the fractional part
.2d05	20 42 2b	jsr $2b42			jsr 	FloatNormalise					; normalise , exit if zero
.2d08	f0 22		beq $2d2c			beq 	_CNTSExit
.2d0a	a9 2e		lda #$2e			lda 	#"."
.2d0c	20 4d 2d	jsr $2d4d			jsr 	WriteDecimalBuffer 			; write decimal place
.2d0f					_CNTSDecimal:
.2d0f	ce 8f 05	dec $058f			dec 	decimalPlaces 				; done all the decimals
.2d12	30 18		bmi $2d2c			bmi 	_CNTSExit
.2d14	e8		inx				inx 								; x 10.0
.2d15	a9 0a		lda #$0a			lda 	#10
.2d17	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.2d1a	20 ad 2a	jsr $2aad			jsr 	FloatMultiply
.2d1d	20 2f 2d	jsr $2d2f			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.2d20	20 cd 29	jsr $29cd			jsr 	FloatFractionalPart 		; get the fractional part
.2d23	20 42 2b	jsr $2b42			jsr 	FloatNormalise 				; normalise it.
.2d26	b5 70		lda $70,x			lda 	NSExponent,x 				; gone to zero, exit.
.2d28	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.2d2a	b0 e3		bcs $2d0f			bcs 	_CNTSDecimal 				; keep going.
.2d2c					_CNTSExit:
.2d2c	7a		ply				ply
.2d2d	fa		plx				plx
.2d2e	60		rts				rts
.2d2f					MakePlusTwoString:
.2d2f	da		phx				phx
.2d30	20 d0 2d	jsr $2dd0			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.2d33	e8		inx				inx 								; access it
.2d34	e8		inx				inx
.2d35	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart 			; make it an integer
.2d38	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.2d3a	20 6c 2d	jsr $2d6c			jsr 	ConvertInt32
.2d3d	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.2d3f					_MPTSCopy:
.2d3f	bd 6a 05	lda $056a,x			lda 	numberBuffer,x
.2d42	20 4d 2d	jsr $2d4d			jsr 	WriteDecimalBuffer
.2d45	e8		inx				inx
.2d46	bd 6a 05	lda $056a,x			lda 	numberBuffer,x
.2d49	d0 f4		bne $2d3f			bne 	_MPTSCopy
.2d4b	fa		plx				plx
.2d4c	60		rts				rts
.2d4d					WriteDecimalBuffer:
.2d4d	da		phx				phx
.2d4e	ae 90 05	ldx $0590			ldx 	dbOffset
.2d51	9d 91 05	sta $0591,x			sta 	decimalBuffer,x
.2d54	9e 92 05	stz $0592,x			stz 	decimalBuffer+1,x
.2d57	ee 90 05	inc $0590			inc 	dbOffset
.2d5a	fa		plx				plx
.2d5b	60		rts				rts
.058f					decimalPlaces:
>058f							.fill 	1
.0590					dbOffset:
>0590							.fill 	1
.0591					decimalBuffer:
>0591							.fill 	32
.2d5c					ConvertInt16:
.2d5c	85 40		sta $40				sta 	NSMantissa0 				; set up as 32 bit conversion
.2d5e	86 4c		stx $4c				stx 	NSMantissa1
.2d60	64 58		stz $58				stz 	NSMantissa2
.2d62	64 64		stz $64				stz 	NSMantissa3
.2d64	64 34		stz $34				stz 	NSStatus 					; positive integer
.2d66	a2 00		ldx #$00			ldx 	#0 							; stack level
.2d68	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.2d6a	80 00		bra $2d6c			bra 	ConvertInt32
.2d6c					ConvertInt32:
.2d6c	5a		phy				phy
.2d6d	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.2d6f	24 34		bit $34				bit 	NSStatus 					; output a - if not negative.
.2d71	10 08		bpl $2d7b			bpl 	_CI32NotNeg
.2d73	48		pha				pha
.2d74	a9 2d		lda #$2d			lda 	#'-'
.2d76	99 6a 05	sta $056a,y			sta 	numberBuffer,y
.2d79	c8		iny				iny
.2d7a	68		pla				pla
.2d7b					_CI32NotNeg:
.2d7b	20 89 2d	jsr $2d89			jsr 	_CI32DivideConvert 			; recursive conversion
.2d7e	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2d80	99 6a 05	sta $056a,y			sta 	numberBuffer,y
.2d83	7a		ply				ply
.2d84	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.2d86	a9 6a		lda #$6a			lda 	#numberBuffer & $FF
.2d88	60		rts				rts
.2d89					_CI32DivideConvert:
.2d89	e8		inx				inx 								; write to next slot up
.2d8a	20 ef 2d	jsr $2def			jsr 	FloatSetByte 		 		; write the base out.
.2d8d	ca		dex				dex
.2d8e	20 83 29	jsr $2983			jsr 	Int32Divide 				; divide
.2d91	b5 40		lda $40,x			lda 	NSMantissa0,x 				; save remainder
.2d93	48		pha				pha
.2d94	20 72 29	jsr $2972			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2d97	20 0f 2e	jsr $2e0f			jsr 	FloatIsZero 				; is it zero ?
.2d9a	f0 05		beq $2da1			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2d9c	b5 41		lda $41,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2d9e	20 89 2d	jsr $2d89			jsr 	_CI32DivideConvert 			; and recusrively call.
.2da1					_CI32NoRecurse:
.2da1	68		pla				pla 								; remainder
.2da2	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2da4	90 02		bcc $2da8			bcc 	_CI32NotHex
.2da6	69 26		adc #$26			adc 	#6+32
.2da8					_CI32NotHex:
.2da8	69 30		adc #$30			adc 	#48
.2daa	99 6a 05	sta $056a,y			sta 	numberBuffer,y 				; write out and exit
.2dad	c8		iny				iny
.2dae	60		rts				rts
.2daf					FloatNegate:
.2daf	b5 34		lda $34,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2db1	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2db3	95 34		sta $34,x			sta 	NSStatus,x
.2db5	60		rts				rts
.2db6					FloatNegateMantissa:
.2db6	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2db7	a9 00		lda #$00			lda 	#0
.2db9	f5 40		sbc $40,x			sbc 	NSMantissa0,x
.2dbb	95 40		sta $40,x			sta 	NSMantissa0,x
.2dbd	a9 00		lda #$00			lda 	#0
.2dbf	f5 4c		sbc $4c,x			sbc 	NSMantissa1,x
.2dc1	95 4c		sta $4c,x			sta 	NSMantissa1,x
.2dc3	a9 00		lda #$00			lda 	#0
.2dc5	f5 58		sbc $58,x			sbc 	NSMantissa2,x
.2dc7	95 58		sta $58,x			sta 	NSMantissa2,x
.2dc9	a9 00		lda #$00			lda 	#0
.2dcb	f5 64		sbc $64,x			sbc 	NSMantissa3,x
.2dcd	95 64		sta $64,x			sta 	NSMantissa3,x
.2dcf	60		rts				rts
.2dd0					FloatShiftUpTwo:
.2dd0	b5 40		lda $40,x			lda 	NSMantissa0,x
.2dd2	95 42		sta $42,x			sta 	NSMantissa0+2,x
.2dd4	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2dd6	95 4e		sta $4e,x			sta 	NSMantissa1+2,x
.2dd8	b5 58		lda $58,x			lda 	NSMantissa2,x
.2dda	95 5a		sta $5a,x			sta 	NSMantissa2+2,x
.2ddc	b5 64		lda $64,x			lda 	NSMantissa3,x
.2dde	95 66		sta $66,x			sta 	NSMantissa3+2,x
.2de0	b5 70		lda $70,x			lda 	NSExponent,x
.2de2	95 72		sta $72,x			sta 	NSExponent+2,x
.2de4	b5 34		lda $34,x			lda 	NSStatus,x
.2de6	95 36		sta $36,x			sta 	NSStatus+2,x
.2de8	60		rts				rts
.2de9					FloatSetZeroMantissaOnly:
.2de9	74 40		stz $40,x			stz 	NSMantissa0,x
.2deb	80 08		bra $2df5			bra 	FloatZero13
.2ded					FloatSetZero:
.2ded	a9 00		lda #$00			lda 	#0
.2def					FloatSetByte:
.2def	74 70		stz $70,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2df1					FloatSetMantissa:
.2df1	95 40		sta $40,x			sta 	NSMantissa0,x 				; zero mantissa
.2df3	74 34		stz $34,x			stz 	NSStatus,x
.2df5					FloatZero13:
.2df5	74 4c		stz $4c,x			stz 	NSMantissa1,x
.2df7	74 58		stz $58,x			stz 	NSMantissa2,x
.2df9	74 64		stz $64,x			stz 	NSMantissa3,x
.2dfb	60		rts				rts
.2dfc					FloatShiftLeft:
.2dfc	18		clc				clc
.2dfd					FloatRotateLeft:
.2dfd	36 40		rol $40,x			rol 	NSMantissa0,x
.2dff	36 4c		rol $4c,x			rol		NSMantissa1,x
.2e01	36 58		rol $58,x			rol		NSMantissa2,x
.2e03	36 64		rol $64,x			rol		NSMantissa3,x
.2e05	60		rts				rts
.2e06					FloatShiftRight:
.2e06	56 64		lsr $64,x			lsr 	NSMantissa3,x
.2e08	76 58		ror $58,x			ror		NSMantissa2,x
.2e0a	76 4c		ror $4c,x			ror		NSMantissa1,x
.2e0c	76 40		ror $40,x			ror		NSMantissa0,x
.2e0e	60		rts				rts
.2e0f					FloatIsZero:
.2e0f	b5 64		lda $64,x			lda 	NSMantissa3,x
.2e11	15 58		ora $58,x			ora		NSMantissa2,x
.2e13	15 4c		ora $4c,x			ora		NSMantissa1,x
.2e15	15 40		ora $40,x			ora		NSMantissa0,x
.2e17	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.2e18					FloatArcTan:
.2e18	20 42 2b	jsr $2b42			jsr 	FloatNormalise 					; normalise x
.2e1b	b5 34		lda $34,x			lda 	NSStatus,x 						; save sign, make absolute
.2e1d	48		pha				pha
.2e1e	74 34		stz $34,x			stz 	NSStatus,x
.2e20	b5 70		lda $70,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.2e22	c9 e2		cmp #$e2			cmp 	#$E2
.2e24	90 25		bcc $2e4b			bcc 	_UANoFixup
.2e26	8a		txa				txa 									; value in +1
.2e27	a8		tay				tay
.2e28	c8		iny				iny
.2e29	20 d1 2f	jsr $2fd1			jsr 	CopyFloatXY
.2e2c	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.2e2e	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.2e31	e8		inx				inx
.2e32	20 36 29	jsr $2936			jsr 	FloatDivide
.2e35	b0 21		bcs $2e58			bcs 	_FATError
.2e37	20 5b 2e	jsr $2e5b			jsr 	CoreAtn 						; calculate the root
.2e3a	20 c6 2f	jsr $2fc6			jsr 	CompletePolynomial
.2e3d	20 af 2d	jsr $2daf			jsr 	FloatNegate 					; make -ve
.2e40	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2e42	20 1d 30	jsr $301d			jsr 	LoadConstant
.2e45	e8		inx				inx
.2e46	20 11 28	jsr $2811			jsr 	FloatAdd
.2e49	80 06		bra $2e51			bra 	_UAComplete
.2e4b					_UANoFixup:
.2e4b	20 5b 2e	jsr $2e5b			jsr 	CoreAtn
.2e4e	20 c6 2f	jsr $2fc6			jsr 	CompletePolynomial
.2e51					_UAComplete:
.2e51	68		pla				pla 									; apply the result.
.2e52	55 34		eor $34,x			eor 	NSStatus,x
.2e54	95 34		sta $34,x			sta 	NSStatus,x
.2e56	18		clc				clc
.2e57	60		rts				rts
.2e58					_FATError:
.2e58	68		pla				pla
.2e59	38		sec				sec
.2e5a	60		rts				rts
.2e5b					CoreAtn:
.2e5b	a9 c9		lda #$c9			lda 	#AtnCoefficients & $FF
.2e5d	a0 2e		ldy #$2e			ldy 	#AtnCoefficients >> 8
.2e5f	4c 1a 31	jmp $311a			jmp 	CorePolySquared
.2e62					ExpCoefficients:
>2e62	07					.byte	7
>2e63	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>2e67	d2					.byte	$d2
>2e68	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>2e6c	d5					.byte	$d5
>2e6d	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>2e71	d8					.byte	$d8
>2e72	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>2e76	db					.byte	$db
>2e77	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>2e7b	dd					.byte	$dd
>2e7c	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>2e80	df					.byte	$df
>2e81	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>2e85	e1					.byte	$e1
>2e86	00 00 00 40				.dword	$40000000 ; 1.0
>2e8a	e2					.byte	$e2
.2e8b					SinCoefficients:
>2e8b	06					.byte	6
>2e8c	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>2e90	e5					.byte	$e5
>2e91	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>2e95	e7					.byte	$e7
>2e96	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>2e9a	e8					.byte	$e8
>2e9b	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>2e9f	e8					.byte	$e8
>2ea0	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>2ea4	e7					.byte	$e7
>2ea5	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>2ea9	e4					.byte	$e4
>2eaa	00 00 00 00				.dword	$00000000 ; 0.0
>2eae	00					.byte	$00
.2eaf					LogCoefficients:
>2eaf	04					.byte	4
>2eb0	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>2eb4	e0					.byte	$e0
>2eb5	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>2eb9	e1					.byte	$e1
>2eba	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>2ebe	e1					.byte	$e1
>2ebf	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>2ec3	e3					.byte	$e3
>2ec4	00 00 00 c0				.dword	$c0000000 ; -0.5
>2ec8	e1					.byte	$e1
.2ec9					AtnCoefficients:
>2ec9	0c					.byte	12
>2eca	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2ece	d7					.byte	$d7
>2ecf	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>2ed3	da					.byte	$da
>2ed4	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>2ed8	dc					.byte	$dc
>2ed9	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2edd	dd					.byte	$dd
>2ede	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>2ee2	dd					.byte	$dd
>2ee3	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>2ee7	de					.byte	$de
>2ee8	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2eec	de					.byte	$de
>2eed	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>2ef1	de					.byte	$de
>2ef2	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>2ef6	df					.byte	$df
>2ef7	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>2efb	df					.byte	$df
>2efc	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>2f00	e0					.byte	$e0
>2f01	00 00 00 40				.dword	$40000000 ; 1.0
>2f05	e2					.byte	$e2
>2f06	00 00 00 00				.dword	$00000000 ; 0.0
>2f0a	00					.byte	$00
.2f0b					Const_Base:
.2f0b					Const_1Div2Pi:
>2f0b	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>2f0f	df					.byte	$df
.2f10					Const_PiDiv2:
>2f10	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>2f14	e2					.byte	$e2
.2f15					Const_Log2_e:
>2f15	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>2f19	e2					.byte	$e2
.2f1a					Const_sqrt_2:
>2f1a	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>2f1e	e2					.byte	$e2
.2f1f					Const_sqrt_half:
>2f1f	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>2f23	e1					.byte	$e1
.2f24					Const_pi:
>2f24	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>2f28	e3					.byte	$e3
.2f29					Const_half:
>2f29	00 00 00 40				.dword	$40000000 ; 0.50000000
>2f2d	e1					.byte	$e1
.2f2e					Const_ln_e:
>2f2e	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>2f32	e1					.byte	$e1
.2f33					FloatCosine:
.2f33	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2f35	20 1d 30	jsr $301d			jsr 	LoadConstant
.2f38	e8		inx				inx
.2f39	20 11 28	jsr $2811			jsr 	FloatAdd
.2f3c	4c d3 30	jmp $30d3			jmp 	FloatSine
.2f3f					FloatExponent:
.2f3f	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.2f41	20 1d 30	jsr $301d			jsr 	LoadConstant
.2f44	e8		inx				inx
.2f45	20 ad 2a	jsr $2aad			jsr 	FloatMultiply
.2f48	20 8a 2f	jsr $2f8a			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.2f4b	e8		inx				inx
.2f4c	20 28 2a	jsr $2a28			jsr 	FloatIntegerPart
.2f4f	ca		dex				dex
.2f50	b5 4d		lda $4d,x			lda 	NSMantissa1+1,x
.2f52	15 59		ora $59,x			ora 	NSMantissa2+1,x
.2f54	15 65		ora $65,x			ora 	NSMantissa3+1,x
.2f56	d0 38		bne $2f90			bne 	_UERangeError
.2f58	b5 41		lda $41,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.2f5a	c9 40		cmp #$40			cmp 	#64
.2f5c	b0 32		bcs $2f90			bcs 	_UERangeError
.2f5e	48		pha				pha
.2f5f	b5 34		lda $34,x			lda 	NSStatus,x 				; push sign
.2f61	48		pha				pha
.2f62	20 cd 29	jsr $29cd			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.2f65	68		pla				pla
.2f66	10 14		bpl $2f7c			bpl 	_UEPositive
.2f68	e8		inx				inx 							; 1-x
.2f69	a9 01		lda #$01			lda 	#1
.2f6b	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.2f6e	ca		dex				dex
.2f6f	20 af 2d	jsr $2daf			jsr 	FloatNegate
.2f72	e8		inx				inx
.2f73	20 11 28	jsr $2811			jsr 	FloatAdd
.2f76	68		pla				pla 							; integer part +1 and negated.
.2f77	1a		inc a				inc 	a
.2f78	49 ff		eor #$ff			eor 	#$FF
.2f7a	1a		inc a				inc 	a
.2f7b	48		pha				pha
.2f7c					_UEPositive:
.2f7c	20 92 2f	jsr $2f92			jsr 	CoreExponent
.2f7f	20 c6 2f	jsr $2fc6			jsr 	CompletePolynomial
.2f82	68		pla				pla
.2f83	18		clc				clc
.2f84	75 70		adc $70,x			adc 	NSExponent,x
.2f86	95 70		sta $70,x			sta 	NSExponent,x
.2f88	18		clc				clc
.2f89	60		rts				rts
.2f8a					_UECopy01:
.2f8a	8a		txa				txa
.2f8b	a8		tay				tay
.2f8c	c8		iny				iny
.2f8d	4c d1 2f	jmp $2fd1			jmp 	CopyFloatXY
.2f90					_UERangeError:
.2f90	38		sec				sec
.2f91	60		rts				rts
.2f92					CoreExponent:
.2f92	a9 62		lda #$62			lda 	#ExpCoefficients & $FF
.2f94	a0 2e		ldy #$2e			ldy 	#ExpCoefficients >> 8
.2f96	20 9a 2f	jsr $2f9a			jsr 	CalculateHornerPolynomial
.2f99	60		rts				rts
.2f9a					CalculateHornerPolynomial:
.2f9a	85 28		sta $28				sta 	zTemp0 						; save poly data from YA
.2f9c	84 29		sty $29				sty 	zTemp0+1
.2f9e	9c b1 05	stz $05b1			stz 	coefficientCount 			; zero the count.
.2fa1	8e b2 05	stx $05b2			stx 	xValueSlot 					; save xValue slot.
.2fa4	e8		inx				inx 								; set the count to zero.
.2fa5	20 ed 2d	jsr $2ded			jsr 	FloatSetZero
.2fa8					_CHPLoop:
.2fa8	8a		txa				txa 								; copy X-1 to X+1
.2fa9	a8		tay				tay
.2faa	ca		dex				dex
.2fab	c8		iny				iny
.2fac	20 d1 2f	jsr $2fd1			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.2faf	e8		inx				inx
.2fb0	e8		inx				inx
.2fb1	20 ad 2a	jsr $2aad			jsr 	FloatMultiply 				; times current by X
.2fb4	e8		inx				inx
.2fb5	20 f0 2f	jsr $2ff0			jsr 	GetCoefficient 				; coefficient into X+1
.2fb8	20 11 28	jsr $2811			jsr 	FloatAdd 					; and add
.2fbb	ee b1 05	inc $05b1			inc 	coefficientCount
.2fbe	ad b1 05	lda $05b1			lda 	coefficientCount
.2fc1	d2 28		cmp ($28)			cmp 	(zTemp0)
.2fc3	d0 e3		bne $2fa8			bne 	_CHPLoop
.2fc5	60		rts				rts
.2fc6					CompletePolynomial:
.2fc6	20 ad 2a	jsr $2aad			jsr 	FloatMultiply
.2fc9	e8		inx				inx 								; get the last value
.2fca	20 f0 2f	jsr $2ff0			jsr 	GetCoefficient
.2fcd	20 11 28	jsr $2811			jsr 	FloatAdd 					; and add it
.2fd0	60		rts				rts
.2fd1					CopyFloatXY:
.2fd1	b5 70		lda $70,x			lda 	NSExponent,x
.2fd3	99 70 00	sta $0070,y			sta 	NSExponent,y
.2fd6	b5 34		lda $34,x			lda 	NSStatus,x
.2fd8	99 34 00	sta $0034,y			sta 	NSStatus,y
.2fdb	b5 40		lda $40,x			lda 	NSMantissa0,x
.2fdd	99 40 00	sta $0040,y			sta 	NSMantissa0,y
.2fe0	b5 4c		lda $4c,x			lda 	NSMantissa1,x
.2fe2	99 4c 00	sta $004c,y			sta 	NSMantissa1,y
.2fe5	b5 58		lda $58,x			lda 	NSMantissa2,x
.2fe7	99 58 00	sta $0058,y			sta 	NSMantissa2,y
.2fea	b5 64		lda $64,x			lda 	NSMantissa3,x
.2fec	99 64 00	sta $0064,y			sta 	NSMantissa3,y
.2fef	60		rts				rts
.2ff0					GetCoefficient:
.2ff0	5a		phy				phy
.2ff1	ad b1 05	lda $05b1			lda 	coefficientCount 			; 5 per block
.2ff4	0a		asl a				asl 	a
.2ff5	0a		asl a				asl 	a
.2ff6	38		sec				sec 								; +1 for count
.2ff7	6d b1 05	adc $05b1			adc 	coefficientCount
.2ffa	a8		tay				tay
.2ffb	b1 28		lda ($28),y			lda 	(zTemp0),y 					; copy mantissa
.2ffd	95 40		sta $40,x			sta 	NSMantissa0,x
.2fff	c8		iny				iny
.3000	b1 28		lda ($28),y			lda 	(zTemp0),y
.3002	95 4c		sta $4c,x			sta 	NSMantissa1,x
.3004	c8		iny				iny
.3005	b1 28		lda ($28),y			lda 	(zTemp0),y
.3007	95 58		sta $58,x			sta 	NSMantissa2,x
.3009	c8		iny				iny
.300a	b1 28		lda ($28),y			lda 	(zTemp0),y
.300c	48		pha				pha
.300d	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.300f	95 64		sta $64,x			sta 	NSMantissa3,x
.3011	c8		iny				iny
.3012	68		pla				pla
.3013	29 80		and #$80			and 	#$80
.3015	95 34		sta $34,x			sta 	NSStatus,x 					; put in status
.3017	b1 28		lda ($28),y			lda 	(zTemp0),y
.3019	95 70		sta $70,x			sta 	NSExponent,x
.301b	7a		ply				ply
.301c	60		rts				rts
.05b1					coefficientCount:
>05b1							.fill 	1
.05b2					xValueSlot:
>05b2							.fill 	1
.301d					LoadConstant:
.301d	5a		phy				phy
.301e	a8		tay				tay
.301f	b9 0b 2f	lda $2f0b,y			lda 	Const_Base+0,y
.3022	95 41		sta $41,x			sta 	NSMantissa0+1,x
.3024	b9 0c 2f	lda $2f0c,y			lda 	Const_Base+1,y
.3027	95 4d		sta $4d,x			sta 	NSMantissa1+1,x
.3029	b9 0d 2f	lda $2f0d,y			lda 	Const_Base+2,y
.302c	95 59		sta $59,x			sta 	NSMantissa2+1,x
.302e	b9 0e 2f	lda $2f0e,y			lda 	Const_Base+3,y
.3031	48		pha				pha
.3032	29 7f		and #$7f			and 	#$7F
.3034	95 65		sta $65,x			sta 	NSMantissa3+1,x
.3036	68		pla				pla
.3037	29 80		and #$80			and 	#$80
.3039	95 35		sta $35,x			sta 	NSStatus+1,x
.303b	b9 0f 2f	lda $2f0f,y			lda 	Const_Base+4,y
.303e	95 71		sta $71,x			sta 	NSExponent+1,x
.3040	7a		ply				ply
.3041	60		rts				rts
.3042					FloatLogarithm:
.3042	b5 34		lda $34,x			lda 	NSStatus,x 					; check > 0
.3044	30 5f		bmi $30a5			bmi 	_ULRange
.3046	20 0f 2e	jsr $2e0f			jsr 	FloatIsZero
.3049	f0 5a		beq $30a5			beq 	_ULRange
.304b	20 42 2b	jsr $2b42			jsr 	FloatNormalise 				; put into FP mode.
.304e	b5 70		lda $70,x			lda 	NSExponent,x 				; get power
.3050	48		pha				pha
.3051	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.3053	95 70		sta $70,x			sta 	NSExponent,x
.3055	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.3057	20 1d 30	jsr $301d			jsr 	LoadConstant
.305a	e8		inx				inx
.305b	20 11 28	jsr $2811			jsr 	FloatAdd
.305e	8a		txa				txa 								; divide into sqrt 2.0
.305f	a8		tay				tay
.3060	c8		iny				iny
.3061	20 d1 2f	jsr $2fd1			jsr 	CopyFloatXY
.3064	ca		dex				dex
.3065	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.3067	20 1d 30	jsr $301d			jsr 	LoadConstant
.306a	e8		inx				inx
.306b	e8		inx				inx
.306c	20 36 29	jsr $2936			jsr 	FloatDivide 				; if zero, error.
.306f	b0 33		bcs $30a4			bcs 	_ULRangePla
.3071	20 af 2d	jsr $2daf			jsr 	FloatNegate 				; subtract from 1
.3074	e8		inx				inx
.3075	a9 01		lda #$01			lda 	#1
.3077	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.307a	20 11 28	jsr $2811			jsr 	FloatAdd
.307d	20 a7 30	jsr $30a7			jsr 	CoreLog
.3080	20 c6 2f	jsr $2fc6			jsr 	CompletePolynomial
.3083	68		pla				pla 								; add exponent
.3084	18		clc				clc
.3085	69 1f		adc #$1f			adc 	#31 						; fix up
.3087	48		pha				pha
.3088	10 03		bpl $308d			bpl 	_LogNotNeg
.308a	49 ff		eor #$ff			eor 	#$FF
.308c	1a		inc a				inc 	a
.308d					_LogNotNeg:
.308d	e8		inx				inx 								; set byte and sign.
.308e	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.3091	68		pla				pla
.3092	29 80		and #$80			and 	#$80
.3094	95 34		sta $34,x			sta 	NSStatus,x
.3096	20 11 28	jsr $2811			jsr 	FloatAdd
.3099	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.309b	20 1d 30	jsr $301d			jsr 	LoadConstant
.309e	e8		inx				inx
.309f	20 ad 2a	jsr $2aad			jsr 	FloatMultiply
.30a2	18		clc				clc
.30a3	60		rts				rts
.30a4					_ULRangePla:
.30a4	68		pla				pla
.30a5					_ULRange:
.30a5	38		sec				sec
.30a6	60		rts				rts
.30a7					CoreLog:
.30a7	a9 af		lda #$af			lda 	#LogCoefficients & $FF
.30a9	a0 2e		ldy #$2e			ldy 	#LogCoefficients >> 8
.30ab	4c 1a 31	jmp $311a			jmp 	CorePolySquared
.30ae					FloatPI:
.30ae	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.30b0	20 1d 30	jsr $301d			jsr 	LoadConstant
.30b3	e8		inx				inx
.30b4	18		clc				clc
.30b5	60		rts				rts
.30b6					FloatPower:
.30b6	ca		dex				dex
.30b7	8a		txa				txa 							; copy 0 to 2, so we can process it
.30b8	a8		tay				tay
.30b9	c8		iny				iny
.30ba	c8		iny				iny
.30bb	20 d1 2f	jsr $2fd1			jsr 	CopyFloatXY
.30be	e8		inx				inx 							; 2 = Log(0)
.30bf	e8		inx				inx
.30c0	20 42 30	jsr $3042			jsr 	FloatLogarithm
.30c3	b0 0d		bcs $30d2			bcs 	_FPWExit
.30c5	20 ad 2a	jsr $2aad			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.30c8	8a		txa				txa 							; copy to slot 0
.30c9	a8		tay				tay
.30ca	88		dey				dey
.30cb	20 d1 2f	jsr $2fd1			jsr 	CopyFloatXY
.30ce	ca		dex				dex  							; Exponent code.
.30cf	20 3f 2f	jsr $2f3f			jsr 	FloatExponent
.30d2					_FPWExit:
.30d2	60		rts				rts
.30d3					FloatSine:
.30d3	b5 34		lda $34,x			lda 	NSStatus,x 					; save sign
.30d5	48		pha				pha
.30d6	74 34		stz $34,x			stz 	NSStatus,x 					; make +ve
.30d8	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.30da	20 1d 30	jsr $301d			jsr 	LoadConstant
.30dd	e8		inx				inx
.30de	20 ad 2a	jsr $2aad			jsr 	FloatMultiply
.30e1	20 cd 29	jsr $29cd			jsr 	FloatFractionalPart 		; take the fractional part
.30e4	b5 70		lda $70,x			lda 	NSExponent,x 				; check exponent
.30e6	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.30e8	90 1f		bcc $3109			bcc 	_USProcessExit
.30ea	f0 06		beq $30f2			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.30ec	b5 64		lda $64,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.30ee	c9 60		cmp #$60			cmp 	#$60
.30f0	b0 0e		bcs $3100			bcs 	_USSubtractOne
.30f2					_USSubtractFromHalf:
.30f2	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.30f4	20 1d 30	jsr $301d			jsr 	LoadConstant
.30f7	e8		inx				inx
.30f8	20 0b 28	jsr $280b			jsr 	FloatSubtract
.30fb	20 af 2d	jsr $2daf			jsr 	FloatNegate 				; then negate it
.30fe	80 09		bra $3109			bra 	_USProcessExit 				; and exit
.3100					_USSubtractOne:
.3100	e8		inx				inx
.3101	a9 01		lda #$01			lda 	#1
.3103	20 ef 2d	jsr $2def			jsr 	FloatSetByte
.3106	20 0b 28	jsr $280b			jsr 	FloatSubtract
.3109					_USProcessExit:
.3109	20 16 31	jsr $3116			jsr 	CoreSine
.310c	20 c6 2f	jsr $2fc6			jsr 	CompletePolynomial
.310f	68		pla				pla 								; restore sign and apply
.3110	55 34		eor $34,x			eor 	NSStatus,x
.3112	95 34		sta $34,x			sta 	NSStatus,x
.3114	18		clc				clc
.3115	60		rts				rts
.3116					CoreSine:
.3116	a9 8b		lda #$8b			lda 	#SinCoefficients & $FF
.3118	a0 2e		ldy #$2e			ldy 	#SinCoefficients >> 8
.311a					CorePolySquared:
.311a	48		pha				pha 								; save coefficient table
.311b	5a		phy				phy
.311c	8a		txa				txa 								; copy X to +1, +2
.311d	a8		tay				tay
.311e	c8		iny				iny
.311f	20 d1 2f	jsr $2fd1			jsr 	CopyFloatXY
.3122	c8		iny				iny
.3123	20 d1 2f	jsr $2fd1			jsr 	CopyFloatXY
.3126	e8		inx				inx 								; point to the pair and put x^2 on stack
.3127	e8		inx				inx
.3128	20 ad 2a	jsr $2aad			jsr 	FloatMultiply
.312b	7a		ply				ply 								; coefficient table back.
.312c	68		pla				pla
.312d	20 9a 2f	jsr $2f9a			jsr 	CalculateHornerPolynomial
.3130	8a		txa				txa 								; copy back to slot #1
.3131	a8		tay				tay
.3132	88		dey				dey
.3133	20 d1 2f	jsr $2fd1			jsr	 	CopyFloatXY
.3136	ca		dex				dex 								; point at result
.3137	60		rts				rts
.3138					FloatSquareRoot:
.3138	20 42 30	jsr $3042			jsr 	FloatLogarithm
.313b	b0 06		bcs $3143			bcs 	_FSQExit
.313d	d6 70		dec $70,x			dec 	NSExponent,x
.313f	20 3f 2f	jsr $2f3f			jsr 	FloatExponent
.3142	18		clc				clc
.3143					_FSQExit:
.3143	60		rts				rts
.3144					FloatTangent:
.3144	da		phx				phx
.3145	8a		txa				txa 								; sin -> +1
.3146	a8		tay				tay
.3147	c8		iny				iny
.3148	20 d1 2f	jsr $2fd1			jsr 	CopyFloatXY
.314b	e8		inx				inx
.314c	20 d3 30	jsr $30d3			jsr 	FloatSine
.314f	ca		dex				dex
.3150	8a		txa				txa 								; cos -> +2
.3151	a8		tay				tay
.3152	c8		iny				iny
.3153	c8		iny				iny
.3154	20 d1 2f	jsr $2fd1			jsr 	CopyFloatXY
.3157	e8		inx				inx
.3158	e8		inx				inx
.3159	20 33 2f	jsr $2f33			jsr 	FloatCosine
.315c	20 36 29	jsr $2936			jsr 	FloatDivide 				; calculate sin/cos
.315f	b0 07		bcs $3168			bcs 	_FTExit 					; divide by zero
.3161	8a		txa				txa 								; copy result down.
.3162	a8		tay				tay
.3163	88		dey				dey
.3164	20 d1 2f	jsr $2fd1			jsr 	CopyFloatXY
.3167	18		clc				clc
.3168					_FTExit:
.3168	fa		plx				plx
.3169	60		rts				rts

;******  Processing input file: testing/testend.asm

=$3200							nextPage = (* + $FF) & $FF00 		; so I can include with that f*****g header.
.31fe					ObjectCodePreHeader:
>31fe	00 40 d4 54 00 a6 22 48				.binary "code/code.bin"
>3206	00 a6 03 c7 a6 cb 93 93 b1 a6 40 00 01 00 ca 81
>3216	58 03 40 00 01 00 ca 81 58 06 40 00 01 00 ca 81
>3226	58 09 a6 40 00 01 00 ca 81 58 0c 40 00 01 00 ca
>3236	81 58 0f a6 00 48 12 24 40 00 01 95 a6 40 12 01
>3246	50 03 8e 01 b4 28 82 ca 84 02 82 01 80 7c a6 40
>3256	12 01 50 06 8e 01 b4 1e 82 ca 84 cc 00 01 82 7c
>3266	a6 40 12 01 50 09 8e 01 b4 0e 82 ca 84 01 80 7c
>3276	a6 40 12 01 50 0c 8e 01 b4 02 82 ca 84 7c a6 a6
>3286	40 12 01 50 0f 8e 01 7c a6 24 a7 a6 a6 00 48 15
>3296	2a 1d 01 95 00 48 18 30 27 01 95 a6 40 15 cc 00
>32a6	01 82 40 18 02 82 80 cc 00 b0 80 48 1b a6 01 40
>32b6	1b cb 51 c8 01 40 1b 01 80 00 c8 a6 30 a7 2a a7
>32c6	a6 01 48 12 24 40 00 01 95 a6 01 cc 00 b0 40 12
>32d6	01 50 06 8e 78 80 40 12 01 50 03 8e 78 80 00 c8
>32e6	a6 40 12 01 50 0c 8e 78 48 1e a6 40 1e 00 a3 88
>32f6	d2 00 07 00 d1 00 5d 00 a6 40 1e 01 a3 88 d2 00
>3306	07 00 d1 00 7a 00 a6 40 12 01 50 0f 8e 78 48 21
>3316	a6 40 21 00 a3 88 d2 00 07 00 d1 00 97 00 a6 40
>3326	21 01 a3 88 d2 00 07 00 d1 00 b6 00 a6 01 cc 00
>3336	b0 40 12 01 50 06 8e 78 80 40 12 01 50 03 8e 78
>3346	80 40 12 01 50 09 8e 78 c8 a6 24 a7 a6 d0 00 72
>3356	ff a6 a6 40 12 01 50 03 8e 78 48 24 a6 40 24 01
>3366	a3 88 d2 00 0c 00 40 12 01 50 0c 8e 01 7c 98 a6
>3376	40 12 01 50 03 8e 40 24 02 81 7c 98 a6 a6 40 12
>3386	01 50 03 8e 78 48 24 a6 40 24 cb 4f a3 88 d2 00
>3396	15 00 40 12 01 50 03 8e cb 4d 7c 40 12 01 50 0c
>33a6	8e 00 7c 98 a6 40 12 01 50 03 8e 40 24 02 80 7c
>33b6	98 a6 a6 40 12 01 50 06 8e 78 48 27 a6 40 27 00
>33c6	a3 88 d2 00 0c 00 40 12 01 50 0f 8e 01 7c 98 a6
>33d6	40 12 01 50 06 8e 40 27 cc 00 01 81 7c 98 a6 a6
>33e6	40 12 01 50 06 8e 78 48 27 a6 40 27 cc 00 1d a3
>33f6	88 d2 00 16 00 40 12 01 50 06 8e cc 00 1c 7c 40
>3406	12 01 50 0f 8e 00 7c 98 a6 40 12 01 50 06 8e 40
>3416	27 cc 00 01 80 7c 98 c4 ff
=12800					ObjectCode = ObjectCodePreHeader+2 			; so the code is at XX00

;******  End of listing
