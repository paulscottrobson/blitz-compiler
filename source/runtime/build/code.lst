
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library testing/testend.asm
; Sun Oct  8 17:14:12 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

.1000					WrapperBoot:
.1000	a9 41		lda #$41			lda 	#ObjectCode >> 8 			; address of object code to run.
.1002	a2 81		ldx #$81			ldx 	#$81 						; first page of allocatable memory
.1004	a0 9f		ldy #$9f			ldy 	#$9F 						; byte after end of last page.
.1006	4c 7d 29	jmp $297d			jmp 	StartRuntime

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0022					codePtr:
>0022							.fill 	2
.0024					objPtr:
>0024							.fill 	2
.0026					zTemp0:
>0026							.fill 	2
.0028					zTemp1:
>0028							.fill 	2
.002a					zTemp2:
>002a							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1009					SetErrorHandler:
.1009	8c 01 04	sty $0401			sty 	ErrorHandlerVector+1
.100c	8e 00 04	stx $0400			stx 	ErrorHandlerVector
.100f	60		rts				rts
.1010					CallErrorHandler:
.1010	6c 00 04	jmp ($0400)			jmp 	(ErrorHandlerVector)
.0400					ErrorHandlerVector:
>0400							.fill 	2
.1013					ErrorV_range:
.1013	20 10 10	jsr $1010		jsr	CallErrorHandler
>1016	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>101e	41 4e 47 45 00
.1023					ErrorV_value:
.1023	20 10 10	jsr $1010		jsr	CallErrorHandler
>1026	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>102e	45 00
.1030					ErrorV_syntax:
.1030	20 10 10	jsr $1010		jsr	CallErrorHandler
>1033	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>103b	52 52 4f 52 00
.1040					ErrorV_type:
.1040	20 10 10	jsr $1010		jsr	CallErrorHandler
>1043	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>104b	4d 41 54 43 48 00
.1051					ErrorV_unimplemented:
.1051	20 10 10	jsr $1010		jsr	CallErrorHandler
>1054	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>105c	45 4d 45 4e 54 45 44 00
.1064					ErrorV_assert:
.1064	20 10 10	jsr $1010		jsr	CallErrorHandler
>1067	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>106f	41 49 4c 00
.1073					ErrorV_line:
.1073	20 10 10	jsr $1010		jsr	CallErrorHandler
>1076	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>107e	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.108a					ErrorV_internal:
.108a	20 10 10	jsr $1010		jsr	CallErrorHandler
>108d	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1095	20 45 52 52 4f 52 00
.109c					ErrorV_divzero:
.109c	20 10 10	jsr $1010		jsr	CallErrorHandler
>109f	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>10a7	59 20 5a 45 52 4f 00
.10ae					ErrorV_structure:
.10ae	20 10 10	jsr $1010		jsr	CallErrorHandler
>10b1	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>10b9	45 20 49 4d 42 41 4c 41 4e 43 45 00
.10c5					ErrorV_stop:
.10c5	20 10 10	jsr $1010		jsr	CallErrorHandler
>10c8	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>10d0	53 54 4f 50 50 45 44 00
.10d8					ErrorV_data:
.10d8	20 10 10	jsr $1010		jsr	CallErrorHandler
>10db	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>10e3	41 54 41 00
.10e7					ErrorV_undeclared:
.10e7	20 10 10	jsr $1010		jsr	CallErrorHandler
>10ea	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>10f2	41 52 52 41 59 00
.10f8					ErrorV_redefine:
.10f8	20 10 10	jsr $1010		jsr	CallErrorHandler
>10fb	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1103	44 45 46 49 4e 45 44 00
.110b					ErrorV_index:
.110b	20 10 10	jsr $1010		jsr	CallErrorHandler
>110e	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1116	59 20 49 4e 44 45 58 00
.111e					ErrorV_memory:
.111e	20 10 10	jsr $1010		jsr	CallErrorHandler
>1121	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>1129	45 4d 4f 52 59 00
.112f					ErrorV_channel:
.112f	20 10 10	jsr $1010		jsr	CallErrorHandler
>1132	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>113a	54 50 55 54 20 45 52 52 4f 52 00
.1145					MoveObjectForward:
.1145	b2 24		lda ($24)			lda 	(objPtr) 					; get next
.1147	c9 ff		cmp #$ff			cmp 	#$FF
.1149	f0 36		beq $1181			beq 	_MOFEnd
.114b	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.114d	90 24		bcc $1173			bcc 	_MOFAdvance1 				; forward 1
.114f	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.1151	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.1153	90 20		bcc $1175			bcc 	_MOFAdvanceY
.1155	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.1157	90 1a		bcc $1173			bcc 	_MOFAdvance1 				; forward 1
.1159	a8		tay				tay 								; read the size.
.115a	b9 bf 10	lda $10bf,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.115d	a8		tay				tay
.115e	c8		iny				iny 								; add 1 for the system token.
.115f	d0 14		bne $1175			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.1161	a0 01		ldy #$01			ldy 	#1 							; get length byte
.1163	b1 24		lda ($24),y			lda 	(objPtr),y
.1165	a8		tay				tay 								; into Y.
.1166	18		clc				clc
.1167	a5 24		lda $24				lda 	objPtr						; add 2 to the object pointer
.1169	69 02		adc #$02			adc 	#2
.116b	85 24		sta $24				sta 	objPtr
.116d	90 02		bcc $1171			bcc 	_MOFNoCarry1
.116f	e6 25		inc $25				inc 	objPtr+1
.1171					_MOFNoCarry1:
.1171	80 02		bra $1175			bra 	_MOFAdvanceY
.1173					_MOFAdvance1:
.1173	a0 01		ldy #$01			ldy 	#1
.1175					_MOFAdvanceY:
.1175	98		tya				tya 								; add Y to objPtr
.1176	18		clc				clc
.1177	65 24		adc $24				adc 	objPtr
.1179	85 24		sta $24				sta 	objPtr
.117b	90 02		bcc $117f			bcc 	_MOFNoCarry2
.117d	e6 25		inc $25				inc 	objPtr+1
.117f					_MOFNoCarry2:
.117f	18		clc				clc 								; not completed.
.1180	60		rts				rts
.1181					_MOFEnd:
.1181	e6 24		inc $24				inc 	objPtr
.1183	d0 02		bne $1187			bne 	_MOFENoCarry
.1185	e6 25		inc $25				inc 	objPtr+1
.1187					_MOFENoCarry:
.1187	38		sec				sec
.1188	60		rts				rts
.1189					MOFSizeTable:
>1189	01					.byte	1         	; $ca .shift
>118a	01					.byte	1         	; $cb .byte
>118b	02					.byte	2         	; $cc .word
>118c	05					.byte	5         	; $cd .float
>118d	ff					.byte	255       	; $ce .string
>118e	ff					.byte	255       	; $cf .data
>118f	02					.byte	2         	; $d0 .goto
>1190	02					.byte	2         	; $d1 .gosub
>1191	02					.byte	2         	; $d2 .goto.z
>1192	02					.byte	2         	; $d3 .goto.nz
>1193	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.002c					NSStatus:
>002c							.fill 	MathStackSize
.0038					NSMantissa0:
>0038							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0044					NSMantissa1:
>0044							.fill 	MathStackSize
.0050					NSMantissa2:
>0050							.fill 	MathStackSize
.005c					NSMantissa3:
>005c							.fill 	MathStackSize
.0068					NSExponent:
>0068							.fill 	MathStackSize
.0402					numberBuffer:
>0402							.fill 	34
.1194					FloatSubtract:
.1194	b5 2c		lda $2c,x			lda 	NSStatus,x 					; negate top of stack
.1196	49 80		eor #$80			eor 	#$80
.1198	95 2c		sta $2c,x			sta 	NSStatus,x					; and fall through.
.119a					FloatAdd:
.119a	ca		dex				dex
.119b	b5 68		lda $68,x			lda 	NSExponent,x 				; can use optimised.
.119d	15 69		ora $69,x			ora 	NSExponent+1,x
.119f	15 5c		ora $5c,x			ora 	NSMantissa3,x
.11a1	15 5d		ora $5d,x			ora 	NSMantissa3+1,x
.11a3	d0 04		bne $11a9			bne 	_FAUseFloat
.11a5	20 36 15	jsr $1536			jsr 	FloatInt32Add 				; use the int32 one.
.11a8	60		rts				rts
.11a9					_FAUseFloat:
.11a9	20 cb 14	jsr $14cb			jsr 	FloatNormalise 				; normalise S[X]
.11ac	f0 51		beq $11ff			beq 	_FAReturn1
.11ae	e8		inx				inx 								; normalise S[X+1]
.11af	20 cb 14	jsr $14cb			jsr 	FloatNormalise
.11b2	ca		dex				dex
.11b3	c9 00		cmp #$00			cmp 	#0
.11b5	f0 60		beq $1217			beq 	_FAExit 					; if so, just return A
.11b7	b5 68		lda $68,x			lda 	NSExponent,x 				; are the exponents the same ?
.11b9	d5 69		cmp $69,x			cmp 	NSExponent+1,x
.11bb	f0 18		beq $11d5			beq 	_FAExponentsEqual
.11bd	b5 68		lda $68,x			lda 	NSExponent,x 				; work out the larger exponent
.11bf	a8		tay				tay
.11c0	38		sec				sec 								; do a signed comparison of the exponents.
.11c1	f5 69		sbc $69,x			sbc 	NSExponent+1,x
.11c3	50 02		bvc $11c7			bvc 	_FANoSignedChange
.11c5	49 80		eor #$80			eor 	#$80
.11c7					_FANoSignedChange:
.11c7	29 80		and #$80			and 	#$80
.11c9	10 02		bpl $11cd			bpl 	_FAHaveMax
.11cb	b4 69		ldy $69,x			ldy 	NSExponent+1,x
.11cd					_FAHaveMax:
.11cd	20 18 12	jsr $1218			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.11d0	e8		inx				inx
.11d1	20 18 12	jsr $1218			jsr 	_FAShiftToExponent
.11d4	ca		dex				dex
.11d5					_FAExponentsEqual:
.11d5	b5 2c		lda $2c,x			lda 	NSStatus,x 					; are the signs the same
.11d7	55 2d		eor $2d,x			eor 	NSStatus+1,x
.11d9	30 0e		bmi $11e9			bmi 	_FADifferentSigns
.11db	20 02 15	jsr $1502			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.11de	b5 5c		lda $5c,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.11e0	10 35		bpl $1217			bpl 	_FAExit 					; if no, we are done.
.11e2	20 8f 17	jsr $178f			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.11e5	f6 68		inc $68,x			inc 	NSExponent,x 				; bump the exponent and exit
.11e7	80 2e		bra $1217			bra 	_FAExit
.11e9					_FADifferentSigns:
.11e9	20 1c 15	jsr $151c			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.11ec	b5 5c		lda $5c,x			lda 	NSMantissa3,x 				; is the result negative ?
.11ee	10 06		bpl $11f6			bpl 	_FACheckZero 				; if no, check for -0
.11f0	20 38 17	jsr $1738			jsr 	FloatNegate 					; netate result
.11f3	20 3f 17	jsr $173f			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.11f6					_FACheckZero:
.11f6	20 98 17	jsr $1798			jsr 	FloatIsZero	 				; check for -0
.11f9	d0 1c		bne $1217			bne 	_FAExit
.11fb	74 2c		stz $2c,x			stz 	NSStatus,x
.11fd	80 18		bra $1217			bra 	_FAExit
.11ff					_FAReturn1:
.11ff	b5 39		lda $39,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.1201	95 38		sta $38,x			sta 	NSMantissa0,x
.1203	b5 45		lda $45,x			lda 	NSMantissa1+1,x
.1205	95 44		sta $44,x			sta 	NSMantissa1,x
.1207	b5 51		lda $51,x			lda 	NSMantissa2+1,x
.1209	95 50		sta $50,x			sta 	NSMantissa2,x
.120b	b5 5d		lda $5d,x			lda 	NSMantissa3+1,x
.120d	95 5c		sta $5c,x			sta 	NSMantissa3,x
.120f	b5 69		lda $69,x			lda 	NSExponent+1,x
.1211	95 68		sta $68,x			sta 	NSExponent,x
.1213	b5 2d		lda $2d,x			lda 	NSStatus+1,x
.1215	95 2c		sta $2c,x			sta 	NSStatus,x
.1217					_FAExit:
.1217	60		rts				rts
.1218					_FAShiftToExponent:
.1218					_FAShiftToExponent2:
.1218	98		tya				tya 								; compare Y to exponent
.1219	d5 68		cmp $68,x			cmp 	NSExponent,x 				; reached the exponent required ?
.121b	f0 07		beq $1224			beq 	_FASEExit 					; exit if so.
.121d	20 8f 17	jsr $178f			jsr 	FloatShiftRight	 			; shift the mantissa right
.1220	f6 68		inc $68,x			inc 	NSExponent,x 				; increment exponent
.1222	80 f4		bra $1218			bra 	_FAShiftToExponent2
.1224					_FASEExit:
.1224	60		rts				rts
.1225					CompareEqual:
.1225	b5 38		lda $38,x			lda 	NSMantissa0,x
.1227	d0 09		bne $1232			bne 	ReturnFalse
.1229					ReturnTrue:
.1229	a9 01		lda #$01			lda 	#1
.122b	95 38		sta $38,x			sta 	NSMantissa0,x
.122d	a9 80		lda #$80			lda 	#$80
.122f	95 2c		sta $2c,x			sta 	NSStatus,x
.1231	60		rts				rts
.1232					ReturnFalse:
.1232	74 38		stz $38,x			stz 	NSMantissa0,x
.1234	60		rts				rts
.1235					CompareNotEqual:
.1235	b5 38		lda $38,x			lda 	NSMantissa0,x
.1237	d0 f0		bne $1229			bne 	ReturnTrue
.1239	80 f7		bra $1232			bra 	ReturnFalse
.123b					CompareLess:
.123b	b5 38		lda $38,x			lda 	NSMantissa0,x
.123d	c9 ff		cmp #$ff			cmp 	#$FF
.123f	f0 e8		beq $1229			beq 	ReturnTrue
.1241	80 ef		bra $1232			bra 	ReturnFalse
.1243					CompareGreater:
.1243	b5 38		lda $38,x			lda 	NSMantissa0,x
.1245	c9 01		cmp #$01			cmp 	#$01
.1247	f0 e0		beq $1229			beq 	ReturnTrue
.1249	80 e7		bra $1232			bra 	ReturnFalse
.124b					CompareLessEqual:
.124b	b5 38		lda $38,x			lda 	NSMantissa0,x
.124d	c9 01		cmp #$01			cmp 	#$01
.124f	d0 d8		bne $1229			bne 	ReturnTrue
.1251	80 df		bra $1232			bra 	ReturnFalse
.1253					CompareGreaterEqual:
.1253	b5 38		lda $38,x			lda 	NSMantissa0,x
.1255	c9 ff		cmp #$ff			cmp 	#$FF
.1257	d0 d0		bne $1229			bne 	ReturnTrue
.1259	80 d7		bra $1232			bra 	ReturnFalse
.125b					FloatCompare:
.125b	b5 68		lda $68,x			lda 	NSExponent,x 				; float comparison.
.125d	15 67		ora $67,x			ora 	NSExponent-1,x 				; integer if both integer.
.125f	48		pha				pha
.1260	20 94 11	jsr $1194			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.1263	68		pla				pla
.1264	d0 0c		bne $1272			bne 	_FCCompareFloat
.1266	b5 38		lda $38,x			lda 	NSMantissa0,x
.1268	15 44		ora $44,x			ora 	NSMantissa1,x
.126a	15 50		ora $50,x			ora 	NSMantissa2,x
.126c	15 5c		ora $5c,x			ora 	NSMantissa3,x
.126e	f0 14		beq $1284			beq 	_FCExit 					; if zero, return zero
.1270	80 0a		bra $127c			bra 	_FCSign
.1272					_FCCompareFloat:
.1272	b5 44		lda $44,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.1274	29 f0		and #$f0			and 	#$F0
.1276	15 50		ora $50,x			ora 	NSMantissa2,x
.1278	15 5c		ora $5c,x			ora 	NSMantissa3,x
.127a	f0 08		beq $1284			beq 	_FCExit 					; zero, so approximately identical
.127c					_FCSign:
.127c	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.127e	34 2c		bit $2c,x			bit 	NSStatus,x
.1280	10 02		bpl $1284			bpl 	_FCExit
.1282					_FCNegative:
.1282	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.1284					_FCExit:
.1284	20 78 17	jsr $1778			jsr 	FloatSetByte 				; set the result 255,0,1
.1287	60		rts				rts
.1288					FloatScalarTable:
>1288	66 66 66 66				.dword $66666666 ; 0.1
>128c	de					.byte $de
>128d	1f 85 eb 51				.dword $51eb851f ; 0.01
>1291	db					.byte $db
>1292	4c 37 89 41				.dword $4189374c ; 0.001
>1296	d8					.byte $d8
>1297	ac 8b db 68				.dword $68db8bac ; 0.0001
>129b	d4					.byte $d4
>129c	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>12a0	d1					.byte $d1
>12a1	83 de 1b 43				.dword $431bde83 ; 1e-06
>12a5	ce					.byte $ce
>12a6	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>12aa	ca					.byte $ca
>12ab	89 3b e6 55				.dword $55e63b89 ; 1e-08
>12af	c7					.byte $c7
>12b0	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>12b4	c4					.byte $c4
>12b5	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>12b9	c0					.byte $c0
>12ba	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>12be	bd					.byte $bd
.12bf					FloatDivide:
.12bf	48		pha				pha
.12c0	20 cb 14	jsr $14cb			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.12c3	ca		dex				dex
.12c4	c9 00		cmp #$00			cmp 	#0
.12c6	f0 1e		beq $12e6			beq 	_FDZero
.12c8	20 cb 14	jsr $14cb			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.12cb	f0 16		beq $12e3			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.12cd	20 2e 13	jsr $132e			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.12d0	20 fb 12	jsr $12fb			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.12d3	20 cb 14	jsr $14cb			jsr		FloatNormalise 				; renormalise
.12d6	20 c1 14	jsr $14c1			jsr 	FloatCalculateSign 			; calculate result sign
.12d9	b5 68		lda $68,x			lda 	NSExponent,x 				; calculate exponent
.12db	38		sec				sec
.12dc	f5 69		sbc $69,x			sbc 	NSExponent+1,x
.12de	38		sec				sec
.12df	e9 1e		sbc #$1e			sbc 	#30
.12e1	95 68		sta $68,x			sta 	NSExponent,x
.12e3					_FDExit:
.12e3	68		pla				pla
.12e4	18		clc				clc
.12e5	60		rts				rts
.12e6					_FDZero:
.12e6	68		pla				pla
.12e7	38		sec				sec
.12e8	60		rts				rts
.12e9					DivideInt32:
.12e9	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart 			; make both integers
.12ec	ca		dex				dex
.12ed	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.12f0	20 0c 13	jsr $130c			jsr 	Int32Divide 				; divide
.12f3	20 fb 12	jsr $12fb			jsr 	NSMCopyPlusTwoToZero 		; copy result
.12f6	20 c1 14	jsr $14c1			jsr 	FloatCalculateSign 			; calculate result sign
.12f9	18		clc				clc
.12fa	60		rts				rts
.12fb					NSMCopyPlusTwoToZero:
.12fb	b5 3a		lda $3a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.12fd	95 38		sta $38,x			sta 	NSMantissa0,x
.12ff	b5 46		lda $46,x			lda 	NSMantissa1+2,x
.1301	95 44		sta $44,x			sta 	NSMantissa1,x
.1303	b5 52		lda $52,x			lda 	NSMantissa2+2,x
.1305	95 50		sta $50,x			sta 	NSMantissa2,x
.1307	b5 5e		lda $5e,x			lda 	NSMantissa3+2,x
.1309	95 5c		sta $5c,x			sta 	NSMantissa3,x
.130b	60		rts				rts
.130c					Int32Divide:
.130c	48		pha				pha 								; save AXY
.130d	5a		phy				phy
.130e	20 59 17	jsr $1759			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.1311	20 72 17	jsr $1772			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.1314	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.1316					_I32DivideLoop:
.1316	e8		inx				inx
.1317	e8		inx				inx
.1318	20 85 17	jsr $1785			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.131b	ca		dex				dex
.131c	ca		dex				dex
.131d	20 86 17	jsr $1786			jsr 	FloatRotateLeft
.1320	20 4c 13	jsr $134c			jsr 	FloatDivideCheck 			; check if subtract possible
.1323	90 02		bcc $1327			bcc 	_I32DivideNoCarryIn
.1325	f6 3a		inc $3a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.1327					_I32DivideNoCarryIn:
.1327	88		dey				dey 								; loop round till division completed.
.1328	d0 ec		bne $1316			bne 	_I32DivideLoop
.132a	7a		ply				ply 								; restore AXY and exit
.132b	68		pla				pla
.132c	18		clc				clc
.132d	60		rts				rts
.132e					Int32ShiftDivide:
.132e	48		pha				pha 								; save AY
.132f	5a		phy				phy
.1330	e8		inx				inx 								; clear S[X+2]
.1331	e8		inx				inx
.1332	20 76 17	jsr $1776			jsr 	FloatSetZero
.1335	ca		dex				dex
.1336	ca		dex				dex
.1337	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.1339					_I32SDLoop:
.1339	20 4c 13	jsr $134c			jsr 	FloatDivideCheck 			; check if subtract possible
.133c	e8		inx				inx
.133d	e8		inx				inx
.133e	20 86 17	jsr $1786			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.1341	ca		dex				dex
.1342	ca		dex				dex
.1343	20 86 17	jsr $1786			jsr 	FloatRotateLeft
.1346	88		dey				dey 	 							; do 31 times
.1347	d0 f0		bne $1339			bne 	_I32SDLoop
.1349	7a		ply				ply 								; restore AY and exit
.134a	68		pla				pla
.134b	60		rts				rts
.134c					FloatDivideCheck:
.134c	20 1c 15	jsr $151c			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.134f	b0 04		bcs $1355			bcs 	_DCSExit 					; if carry set, then could do, exit
.1351	20 02 15	jsr $1502			jsr 	FloatAddTopTwoStack 		; add it back in
.1354	18		clc				clc 								; and return False
.1355					_DCSExit:
.1355	60		rts				rts
.1356					FloatFractionalPart:
.1356	5a		phy				phy
.1357	b5 2c		lda $2c,x			lda 	NSStatus,x 					; take absolute value
.1359	29 7f		and #$7f			and 	#$7F
.135b	95 2c		sta $2c,x			sta 	NSStatus,x
.135d	20 cb 14	jsr $14cb			jsr 	FloatNormalise
.1360	b5 68		lda $68,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.1362	38		sec				sec
.1363	e9 e0		sbc #$e0			sbc 	#$E0
.1365	90 29		bcc $1390			bcc 	_FFPExit 					; already fractional
.1367	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.1369	b0 22		bcs $138d			bcs 	_FFPZero
.136b	a8		tay				tay 								; put count to do in Y
.136c	b5 5c		lda $5c,x			lda 	NSMantissa3,x 				; do each in turn.
.136e	20 95 13	jsr $1395			jsr 	_FFPPartial
.1371	95 5c		sta $5c,x			sta 	NSMantissa3,x
.1373	b5 50		lda $50,x			lda 	NSMantissa2,x
.1375	20 95 13	jsr $1395			jsr 	_FFPPartial
.1378	95 50		sta $50,x			sta 	NSMantissa2,x
.137a	b5 44		lda $44,x			lda 	NSMantissa1,x
.137c	20 95 13	jsr $1395			jsr 	_FFPPartial
.137f	95 44		sta $44,x			sta 	NSMantissa1,x
.1381	b5 38		lda $38,x			lda 	NSMantissa0,x
.1383	20 95 13	jsr $1395			jsr 	_FFPPartial
.1386	95 38		sta $38,x			sta 	NSMantissa0,x
.1388	20 98 17	jsr $1798			jsr 	FloatIsZero 					; zeroed check.
.138b	d0 03		bne $1390			bne 	_FFPExit
.138d					_FFPZero:
.138d	20 76 17	jsr $1776			jsr 	FloatSetZero
.1390					_FFPExit:
.1390	20 cb 14	jsr $14cb			jsr 	FloatNormalise
.1393	7a		ply				ply
.1394	60		rts				rts
.1395					_FFPPartial:
.1395	c0 00		cpy #$00			cpy 	#0 							; no more to do
.1397	f0 17		beq $13b0			beq 	_FFFPPExit
.1399	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.139b	b0 0c		bcs $13a9			bcs 	_FFFPPWholeByte
.139d	5a		phy				phy
.139e					_FFFPPLeft:
.139e	0a		asl a				asl 	a
.139f	88		dey				dey
.13a0	d0 fc		bne $139e			bne 	_FFFPPLeft
.13a2	7a		ply				ply
.13a3					_FFFPPRight:
.13a3	4a		lsr a				lsr 	a
.13a4	88		dey				dey
.13a5	d0 fc		bne $13a3			bne 	_FFFPPRight
.13a7	80 07		bra $13b0			bra 	_FFFPPExit
.13a9					_FFFPPWholeByte:
.13a9	98		tya				tya 								; subtract 8 from count
.13aa	38		sec				sec
.13ab	e9 08		sbc #$08			sbc 	#8
.13ad	a8		tay				tay
.13ae	a9 00		lda #$00			lda 	#0 							; and clear all
.13b0					_FFFPPExit:
.13b0	60		rts				rts
.13b1					FloatIntegerPart:
.13b1	48		pha				pha
.13b2	b5 68		lda $68,x			lda 	NSExponent,x 				; is it integer already ?
.13b4	f0 1d		beq $13d3			beq 	_FIPExit 					; if so do nothing
.13b6	20 98 17	jsr $1798			jsr 	FloatIsZero 				; is it zero ?
.13b9	f0 15		beq $13d0			beq 	_FIPZero 					; if so return zero.
.13bb	20 cb 14	jsr $14cb			jsr 	FloatNormalise 				; normalise
.13be	f0 10		beq $13d0			beq 	_FIPZero 					; normalised to zero, exit zero
.13c0					_FIPShift:
.13c0	b5 68		lda $68,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.13c2	10 07		bpl $13cb			bpl 	_FIPCheckZero
.13c4	20 8f 17	jsr $178f			jsr 	FloatShiftRight 			; shift mantissa right
.13c7	f6 68		inc $68,x			inc 	NSExponent,x 				; bump exponent
.13c9	80 f5		bra $13c0			bra 	_FIPShift
.13cb					_FIPCheckZero:
.13cb	20 98 17	jsr $1798			jsr 	FloatIsZero 				; avoid -0 problem
.13ce	d0 03		bne $13d3			bne 	_FIPExit 					; set to zero if mantissa zero.
.13d0					_FIPZero:
.13d0	20 76 17	jsr $1776			jsr 	FloatSetZero
.13d3					_FIPExit:
.13d3	68		pla				pla
.13d4	60		rts				rts
.13d5					FloatIntegerPartDown:
.13d5	48		pha				pha
.13d6	5a		phy				phy
.13d7	b5 68		lda $68,x			lda 	NSExponent,x 				; is it integer already ?
.13d9	f0 36		beq $1411			beq 	_FIPExit 					; if so do nothing
.13db	20 98 17	jsr $1798			jsr 	FloatIsZero 				; is it zero ?
.13de	f0 2e		beq $140e			beq 	_FIPZero 					; if so return zero.
.13e0	20 cb 14	jsr $14cb			jsr 	FloatNormalise 				; normalise
.13e3	f0 29		beq $140e			beq 	_FIPZero 					; normalised to zero, exit zero
.13e5	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.13e7					_FIPShift:
.13e7	b5 68		lda $68,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.13e9	10 0a		bpl $13f5			bpl 	_FIPCheckDown
.13eb	20 8f 17	jsr $178f			jsr 	FloatShiftRight 			; shift mantissa right
.13ee	90 01		bcc $13f1			bcc 	_FIPNoFrac 					; shifted a zero out ?
.13f0	c8		iny				iny
.13f1					_FIPNoFrac:
.13f1	f6 68		inc $68,x			inc 	NSExponent,x 				; bump exponent
.13f3	80 f2		bra $13e7			bra 	_FIPShift
.13f5					_FIPCheckDown:
.13f5	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.13f7	f0 10		beq $1409			beq 	_FIPCheckZero
.13f9	34 2c		bit $2c,x			bit 	NSStatus,x 					; +ve
.13fb	10 0c		bpl $1409			bpl 	_FIPCheckZero
.13fd	e8		inx				inx 								; -ve so round *down*.
.13fe	a9 01		lda #$01			lda 	#1
.1400	20 78 17	jsr $1778			jsr 	FloatSetByte
.1403	20 38 17	jsr $1738			jsr 	FloatNegate
.1406	20 9a 11	jsr $119a			jsr 	FloatAdd
.1409					_FIPCheckZero:
.1409	20 98 17	jsr $1798			jsr 	FloatIsZero 				; avoid -0 problem
.140c	d0 03		bne $1411			bne 	_FIPExit 					; set to zero if mantissa zero.
.140e					_FIPZero:
.140e	20 76 17	jsr $1776			jsr 	FloatSetZero
.1411					_FIPExit:
.1411	7a		ply				ply
.1412	68		pla				pla
.1413	60		rts				rts
.1414					FloatInt8Multiply:
.1414	5a		phy				phy
.1415	b5 38		lda $38,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.1417	a8		tay				tay
.1418	74 38		stz $38,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.141a					_FI8MLoop:
.141a	98		tya				tya 								; shift right shifter right into carry
.141b	4a		lsr a				lsr 	a
.141c	a8		tay				tay
.141d	90 0d		bcc $142c			bcc 	_FI8MNoAdd
.141f	18		clc				clc
.1420	b5 38		lda $38,x			lda 	NSMantissa0,x
.1422	75 39		adc $39,x			adc 	NSMantissa0+1,x
.1424	95 38		sta $38,x			sta 	NSMantissa0,x
.1426	b5 44		lda $44,x			lda 	NSMantissa1,x
.1428	75 45		adc $45,x			adc 	NSMantissa1+1,x
.142a	95 44		sta $44,x			sta 	NSMantissa1,x
.142c					_FI8MNoAdd:
.142c	16 39		asl $39,x			asl 	NSMantissa0+1,x 			; shift adder left
.142e	36 45		rol $45,x			rol 	NSMantissa1+1,x
.1430	c0 00		cpy #$00			cpy 	#0
.1432	d0 e6		bne $141a			bne 	_FI8MLoop 					; until right shifter zero.
.1434	7a		ply				ply
.1435	60		rts				rts
.1436					FloatMultiply:
.1436	ca		dex				dex
.1437	b5 68		lda $68,x			lda 	NSExponent,x 				; can use optimised ?
.1439	15 69		ora $69,x			ora 	NSExponent+1,x
.143b	15 5c		ora $5c,x			ora 	NSMantissa3,x
.143d	15 5d		ora $5d,x			ora 	NSMantissa3+1,x
.143f	d0 21		bne $1462			bne 	_FMUseFloat
.1441	b5 2c		lda $2c,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.1443	15 2d		ora $2d,x			ora 	NSStatus+1,x
.1445	29 80		and #$80			and 	#$80
.1447	15 5c		ora $5c,x			ora 	NSMantissa3,x
.1449	15 50		ora $50,x			ora 	NSMantissa2,x
.144b	15 44		ora $44,x			ora 	NSMantissa1,x
.144d	15 5d		ora $5d,x			ora 	NSMantissa3+1,x
.144f	15 51		ora $51,x			ora 	NSMantissa2+1,x
.1451	15 45		ora $45,x			ora 	NSMantissa1+1,x
.1453	d0 04		bne $1459			bne 	_FMInt32
.1455	20 14 14	jsr $1414			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.1458	60		rts				rts
.1459					_FMInt32:
.1459	20 83 14	jsr $1483			jsr 	FloatMultiplyShort			; use the int32 one.
.145c	18		clc				clc 								; fix it up if gone out of range
.145d	75 68		adc $68,x			adc 	NSExponent,x
.145f	95 68		sta $68,x			sta 	NSExponent,x
.1461	60		rts				rts
.1462					_FMUseFloat:
.1462	20 cb 14	jsr $14cb			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.1465	f0 18		beq $147f			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.1467	e8		inx				inx
.1468	20 cb 14	jsr $14cb			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.146b	ca		dex				dex
.146c	c9 00		cmp #$00			cmp 	#0
.146e	f0 0c		beq $147c			beq 	_FDSetZero
.1470	20 83 14	jsr $1483			jsr 	FloatMultiplyShort 			; calculate the result.
.1473	75 68		adc $68,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.1475	18		clc				clc
.1476	75 69		adc $69,x			adc 	NSExponent+1,x
.1478	95 68		sta $68,x			sta 	NSExponent,x
.147a	80 03		bra $147f			bra 	_FDExit
.147c					_FDSetZero:
.147c	20 76 17	jsr $1776			jsr 	FloatSetZero 				; return 0
.147f					_FDExit:
.147f	20 cb 14	jsr $14cb			jsr 	FloatNormalise 				; normalise the result
.1482	60		rts				rts
.1483					FloatMultiplyShort:
.1483	5a		phy				phy 								; save Y
.1484	20 59 17	jsr $1759			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.1487	20 72 17	jsr $1772			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.148a	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.148c					_I32MLoop:
.148c	b5 3a		lda $3a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.148e	15 46		ora $46,x			ora 	NSMantissa1+2,x
.1490	15 52		ora $52,x			ora 	NSMantissa2+2,x
.1492	15 5e		ora $5e,x			ora 	NSMantissa3+2,x
.1494	f0 25		beq $14bb			beq 	_I32MExit 					; exit if zero
.1496	b5 3a		lda $3a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.1498	29 01		and #$01			and 	#1
.149a	f0 0d		beq $14a9			beq 	_I32MNoAdd
.149c	20 02 15	jsr $1502			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.149f	b5 5c		lda $5c,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.14a1	10 06		bpl $14a9			bpl 	_I32MNoAdd
.14a3					_I32ShiftRight:
.14a3	20 8f 17	jsr $178f			jsr 	FloatShiftRight 			; shift S[X] right
.14a6	c8		iny				iny 								; increment shift count
.14a7	80 09		bra $14b2			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.14a9					_I32MNoAdd:
.14a9	34 5d		bit $5d,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.14ab	70 f6		bvs $14a3			bvs 	_I32ShiftRight 				; instead.
.14ad	e8		inx				inx
.14ae	20 85 17	jsr $1785			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.14b1	ca		dex				dex
.14b2					_I32MShiftUpper:
.14b2	e8		inx				inx 								; shift S[X+2] right
.14b3	e8		inx				inx
.14b4	20 8f 17	jsr $178f			jsr 	FloatShiftRight
.14b7	ca		dex				dex
.14b8	ca		dex				dex
.14b9	80 d1		bra $148c			bra 	_I32MLoop 					; try again.
.14bb					_I32MExit:
.14bb	20 c1 14	jsr $14c1			jsr 	FloatCalculateSign
.14be	98		tya				tya 								; shift in A
.14bf	7a		ply				ply 								; restore Y and exit
.14c0	60		rts				rts
.14c1					FloatCalculateSign:
.14c1	b5 2c		lda $2c,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.14c3	16 2c		asl $2c,x			asl 	NSStatus,x 					; shift result left
.14c5	55 2d		eor $2d,x			eor 	NSStatus+1,x
.14c7	0a		asl a				asl 	a 							; shift bit 7 into carry
.14c8	76 2c		ror $2c,x			ror 	NSStatus,x 					; shift right into status byte.
.14ca	60		rts				rts
.14cb					FloatNormalise:
.14cb	20 98 17	jsr $1798			jsr 	FloatIsZero 				; if zero exit
.14ce	d0 07		bne $14d7			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.14d0	16 2c		asl $2c,x			asl 	NSStatus,x 					; clear the sign bit.
.14d2	76 2c		ror $2c,x			ror 	NSStatus,x 					; (no -0)
.14d4	a9 00		lda #$00			lda 	#0 							; set Z flag
.14d6	60		rts				rts
.14d7					_NSNormaliseOptimise:
.14d7	b5 5c		lda $5c,x			lda 	NSMantissa3,x 				; upper byte zero ?
.14d9	d0 19		bne $14f4			bne 	_NSNormaliseLoop
.14db	b5 50		lda $50,x			lda 	NSMantissa2,x 				; byte normalise
.14dd	30 15		bmi $14f4			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.14df	95 5c		sta $5c,x			sta 	NSMantissa3,x
.14e1	b5 44		lda $44,x			lda 	NSMantissa1,x
.14e3	95 50		sta $50,x			sta 	NSMantissa2,x
.14e5	b5 38		lda $38,x			lda 	NSMantissa0,x
.14e7	95 44		sta $44,x			sta 	NSMantissa1,x
.14e9	74 38		stz $38,x			stz 	NSMantissa0,x
.14eb	b5 68		lda $68,x			lda 	NSExponent,x
.14ed	38		sec				sec
.14ee	e9 08		sbc #$08			sbc 	#8
.14f0	95 68		sta $68,x			sta 	NSExponent,x
.14f2	80 e3		bra $14d7			bra 	_NSNormaliseOptimise
.14f4					_NSNormaliseLoop:
.14f4	34 5c		bit $5c,x			bit 	NSMantissa3,x 				; bit 30 set ?
.14f6	70 07		bvs $14ff			bvs 	_NSNExit 					; exit if so with Z flag clear
.14f8	20 85 17	jsr $1785			jsr 	FloatShiftLeft 				; shift mantissa left
.14fb	d6 68		dec $68,x			dec 	NSExponent,x 				; adjust exponent
.14fd	80 f5		bra $14f4			bra 	_NSNormaliseLoop
.14ff					_NSNExit:
.14ff	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.1501	60		rts				rts
.1502					FloatAddTopTwoStack:
.1502	18		clc				clc
.1503	b5 38		lda $38,x			lda		NSMantissa0,x
.1505	75 39		adc $39,x			adc 		NSMantissa0+1,x
.1507	95 38		sta $38,x			sta 	NSMantissa0,x
.1509	b5 44		lda $44,x			lda		NSMantissa1,x
.150b	75 45		adc $45,x			adc 		NSMantissa1+1,x
.150d	95 44		sta $44,x			sta 	NSMantissa1,x
.150f	b5 50		lda $50,x			lda		NSMantissa2,x
.1511	75 51		adc $51,x			adc 		NSMantissa2+1,x
.1513	95 50		sta $50,x			sta 	NSMantissa2,x
.1515	b5 5c		lda $5c,x			lda		NSMantissa3,x
.1517	75 5d		adc $5d,x			adc 		NSMantissa3+1,x
.1519	95 5c		sta $5c,x			sta 	NSMantissa3,x
.151b	60		rts				rts
.151c					FloatSubTopTwoStack:
.151c	38		sec				sec
.151d	b5 38		lda $38,x			lda		NSMantissa0,x
.151f	f5 39		sbc $39,x			sbc 		NSMantissa0+1,x
.1521	95 38		sta $38,x			sta 	NSMantissa0,x
.1523	b5 44		lda $44,x			lda		NSMantissa1,x
.1525	f5 45		sbc $45,x			sbc 		NSMantissa1+1,x
.1527	95 44		sta $44,x			sta 	NSMantissa1,x
.1529	b5 50		lda $50,x			lda		NSMantissa2,x
.152b	f5 51		sbc $51,x			sbc 		NSMantissa2+1,x
.152d	95 50		sta $50,x			sta 	NSMantissa2,x
.152f	b5 5c		lda $5c,x			lda		NSMantissa3,x
.1531	f5 5d		sbc $5d,x			sbc 		NSMantissa3+1,x
.1533	95 5c		sta $5c,x			sta 	NSMantissa3,x
.1535	60		rts				rts
.1536					FloatInt32Add:
.1536	b5 2c		lda $2c,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.1538	55 2d		eor $2d,x			eor 	NSStatus+1,x
.153a	30 04		bmi $1540			bmi 	_DiffSigns
.153c	20 02 15	jsr $1502			jsr		FloatAddTopTwoStack
.153f	60		rts				rts
.1540					_DiffSigns:
.1540	20 1c 15	jsr $151c			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.1543	34 5c		bit $5c,x			bit 	NSMantissa3,x 				; result is +ve, okay
.1545	10 07		bpl $154e			bpl 	_AddExit
.1547	b5 2d		lda $2d,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.1549	95 2c		sta $2c,x			sta 	NSStatus,x
.154b	20 3f 17	jsr $173f			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.154e					_AddExit:
.154e	20 98 17	jsr $1798			jsr 	FloatIsZero 				; check for -0
.1551	d0 02		bne $1555			bne 	_AddNonZero
.1553	74 2c		stz $2c,x			stz 	NSStatus,x
.1555					_AddNonZero:
.1555	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.1556					FloatEncodeStart:
.1556	38		sec				sec
.1557	80 01		bra $155a			bra 	FloatEncodeContinue+1
.1559					FloatEncodeContinue:
.1559	18		clc				clc
.155a					FloatEncode:
.155a	08		php				php 								; save reset flag.
.155b	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.155d	f0 15		beq $1574			beq 	_ENIsOkay
.155f	c9 30		cmp #$30			cmp 	#"0"
.1561	90 04		bcc $1567			bcc 	_ENBadNumber
.1563	c9 3a		cmp #$3a			cmp 	#"9"+1
.1565	90 0d		bcc $1574			bcc 	_ENIsOkay
.1567					_ENBadNumber:
.1567	28		plp				plp 								; throw saved reset
.1568	ad 24 04	lda $0424			lda 	encodeState 				; if in decimal mode, construct final number
.156b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.156d	d0 03		bne $1572			bne 	_ENFail
.156f	4c ec 15	jmp $15ec			jmp 	_ENConstructFinal
.1572					_ENFail:
.1572	18		clc				clc 								; not allowed
.1573	60		rts				rts
.1574					_ENIsOkay:
.1574	28		plp				plp 								; are we restarting
.1575	90 15		bcc $158c			bcc 	_ENNoRestart
.1577					_ENStartEncode:
.1577	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.1579	f0 0c		beq $1587			beq 	_ENFirstDP
.157b	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.157d	20 78 17	jsr $1778			jsr 	FloatSetByte 				; in single byte mode.
.1580	a9 01		lda #$01			lda 	#ESTA_Low
.1582					_ENExitChange:
.1582	8d 24 04	sta $0424			sta 	encodeState 				; save new state
.1585	38		sec				sec
.1586	60		rts				rts
.1587					_ENFirstDP:
.1587	20 76 17	jsr $1776			jsr 	FloatSetZero 				; clear integer part
.158a	80 3c		bra $15c8			bra 	_ESTASwitchFloat			; go straight to float and exi
.158c					_ENNoRestart:
.158c	48		pha				pha 								; save digit or DP on stack.
.158d	ad 24 04	lda $0424			lda 	encodeState 				; get current state
.1590	c9 01		cmp #$01			cmp 	#ESTA_Low
.1592	f0 09		beq $159d			beq  	_ESTALowState
.1594	c9 02		cmp #$02			cmp 	#ESTA_High
.1596	f0 26		beq $15be			beq 	_ESTAHighState
.1598	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.159a	f0 38		beq $15d4			beq 	_ESTADecimalState
>159c	db						.byte 	$DB 						; causes a break in the emulator
.159d					_ESTALowState:
.159d	68		pla				pla 								; get value back
.159e	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.15a0	f0 26		beq $15c8			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.15a2	29 0f		and #$0f			and 	#15 						; make digit
.15a4	8d 25 04	sta $0425			sta 	digitTemp 					; save it.
.15a7	b5 38		lda $38,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.15a9	0a		asl a				asl 	a
.15aa	0a		asl a				asl 	a
.15ab	75 38		adc $38,x			adc 	NSMantissa0,x
.15ad	0a		asl a				asl 	a
.15ae	6d 25 04	adc $0425			adc 	digitTemp
.15b1	95 38		sta $38,x			sta 	NSMantissa0,x
.15b3	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.15b5	90 05		bcc $15bc			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.15b7	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.15b9	8d 24 04	sta $0424			sta 	encodeState
.15bc					_ESTANoSwitch:
.15bc	38		sec				sec
.15bd	60		rts				rts
.15be					_ESTAHighState:
.15be	68		pla				pla 								; get value back
.15bf	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.15c1	f0 05		beq $15c8			beq 	_ESTASwitchFloat
.15c3	20 1e 16	jsr $161e			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.15c6	38		sec				sec
.15c7	60		rts				rts
.15c8					_ESTASwitchFloat:
.15c8	9c 26 04	stz $0426			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.15cb	e8		inx				inx 								; zero the decimal additive.
.15cc	20 76 17	jsr $1776			jsr 	FloatSetZero
.15cf	ca		dex				dex
.15d0	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.15d2	80 ae		bra $1582			bra 	_ENExitChange
.15d4					_ESTADecimalState:
.15d4	68		pla				pla 								; digit.
.15d5	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.15d7	f0 99		beq $1572			beq 	_ENFail
.15d9	e8		inx				inx 								; put digit into fractional part of X+1
.15da	20 1e 16	jsr $161e			jsr 	ESTAShiftDigitIntoMantissa
.15dd	ca		dex				dex
.15de	ee 26 04	inc $0426			inc 	decimalCount 				; bump the count of decimals
.15e1	ad 26 04	lda $0426			lda 	decimalCount 				; too many decimal digits.
.15e4	c9 0b		cmp #$0b			cmp 	#11
.15e6	f0 02		beq $15ea			beq 	_ESTADSFail
.15e8	38		sec				sec
.15e9	60		rts				rts
.15ea					_ESTADSFail:
.15ea	18		clc				clc
.15eb	60		rts				rts
.15ec					_ENConstructFinal:
.15ec	ad 26 04	lda $0426			lda 	decimalCount 				; get decimal count
.15ef	f0 2b		beq $161c			beq 	_ENCFExit 					; no decimals
.15f1	5a		phy				phy
.15f2	0a		asl a				asl 	a 							; x 4 and CLC
.15f3	0a		asl a				asl 	a
.15f4	6d 26 04	adc $0426			adc 	decimalCount
.15f7	a8		tay				tay
.15f8	b9 83 12	lda $1283,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.15fb	95 3a		sta $3a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.15fd	b9 84 12	lda $1284,y			lda 	FloatScalarTable-5+1,y
.1600	95 46		sta $46,x			sta 	NSMantissa1+2,x
.1602	b9 85 12	lda $1285,y			lda 	FloatScalarTable-5+2,y
.1605	95 52		sta $52,x			sta 	NSMantissa2+2,x
.1607	b9 86 12	lda $1286,y			lda 	FloatScalarTable-5+3,y
.160a	95 5e		sta $5e,x			sta 	NSMantissa3+2,x
.160c	b9 87 12	lda $1287,y			lda 	FloatScalarTable-5+4,y
.160f	95 6a		sta $6a,x			sta 	NSExponent+2,x
.1611	74 2e		stz $2e,x			stz 	NSStatus+2,x 				; make +ve
.1613	e8		inx				inx 								; multiply decimal const by decimal scalar
.1614	e8		inx				inx
.1615	20 36 14	jsr $1436			jsr 	FloatMultiply
.1618	20 9a 11	jsr $119a			jsr 	FloatAdd 					; add to integer part.
.161b	7a		ply				ply
.161c					_ENCFExit:
.161c	18		clc				clc 								; reject the digit.
.161d	60		rts				rts
.161e					ESTAShiftDigitIntoMantissa:
.161e	29 0f		and #$0f			and 	#15 						; save digit
.1620	48		pha				pha
.1621	b5 5c		lda $5c,x			lda 	NSMantissa3,x 				; push mantissa on stack
.1623	48		pha				pha
.1624	b5 50		lda $50,x			lda 	NSMantissa2,x
.1626	48		pha				pha
.1627	b5 44		lda $44,x			lda 	NSMantissa1,x
.1629	48		pha				pha
.162a	b5 38		lda $38,x			lda 	NSMantissa0,x
.162c	48		pha				pha
.162d	20 85 17	jsr $1785			jsr 	FloatShiftLeft 				; x 2
.1630	20 85 17	jsr $1785			jsr 	FloatShiftLeft 				; x 4
.1633	18		clc				clc 								; pop mantissa and add
.1634	68		pla				pla
.1635	75 38		adc $38,x			adc 	NSMantissa0,x
.1637	95 38		sta $38,x			sta 	NSMantissa0,x
.1639	68		pla				pla
.163a	75 44		adc $44,x			adc 	NSMantissa1,x
.163c	95 44		sta $44,x			sta 	NSMantissa1,x
.163e	68		pla				pla
.163f	75 50		adc $50,x			adc 	NSMantissa2,x
.1641	95 50		sta $50,x			sta 	NSMantissa2,x
.1643	68		pla				pla
.1644	75 5c		adc $5c,x			adc 	NSMantissa3,x
.1646	95 5c		sta $5c,x			sta 	NSMantissa3,x 				; x 5
.1648	20 85 17	jsr $1785			jsr 	FloatShiftLeft 				; x 10
.164b	68		pla				pla 								; add digit
.164c	18		clc				clc
.164d	75 38		adc $38,x			adc 	NSMantissa0,x
.164f	95 38		sta $38,x			sta 	NSMantissa0,x
.1651	90 0a		bcc $165d			bcc 	_ESTASDExit
.1653	f6 44		inc $44,x			inc 	NSMantissa1,x
.1655	d0 06		bne $165d			bne 	_ESTASDExit
.1657	f6 50		inc $50,x			inc 	NSMantissa2,x
.1659	d0 02		bne $165d			bne 	_ESTASDExit
.165b	f6 5c		inc $5c,x			inc 	NSMantissa3,x
.165d					_ESTASDExit:
.165d	60		rts				rts
.0424					encodeState:
>0424							.fill 	1
.0425					digitTemp:
>0425							.fill 	1
.0426					decimalCount:
>0426							.fill 	1
.165e					FloatToString:
.165e	da		phx				phx
.165f	5a		phy				phy 								; save code position
.1660	8d 27 04	sta $0427			sta 	decimalPlaces	 			; save number of DPs.
.1663	9c 28 04	stz $0428			stz 	dbOffset 					; offset into decimal buffer = start.
.1666	b5 2c		lda $2c,x			lda 	NSStatus,x  				; is it -ve.
.1668	10 08		bpl $1672			bpl 	_CNTSNotNegative
.166a	29 7f		and #$7f			and 	#$7F 						; make +ve
.166c	95 2c		sta $2c,x			sta 	NSStatus,x
.166e	a9 2d		lda #$2d			lda 	#"-"
.1670	80 02		bra $1674			bra 	_CNTMain
.1672					_CNTSNotNegative:
.1672	a9 20		lda #$20			lda 	#" "
.1674					_CNTMain:
.1674	20 d6 16	jsr $16d6			jsr 	WriteDecimalBuffer
.1677	b5 68		lda $68,x			lda 	NSExponent,x 				; check if decimal
.1679	f0 0d		beq $1688			beq 	_CNTSNotFloat
.167b	e8		inx				inx 								; round up so we don't get too many 6.999999
.167c	a9 01		lda #$01			lda 	#1
.167e	20 78 17	jsr $1778			jsr 	FloatSetByte
.1681	b5 67		lda $67,x			lda		NSExponent-1,x
.1683	95 68		sta $68,x			sta 	NSExponent,x
.1685	20 9a 11	jsr $119a			jsr 	FloatAdd
.1688					_CNTSNotFloat:
.1688	20 b8 16	jsr $16b8			jsr 	MakePlusTwoString 			; do the integer part.
.168b	20 56 13	jsr $1356			jsr 	FloatFractionalPart 		; get the fractional part
.168e	20 cb 14	jsr $14cb			jsr 	FloatNormalise					; normalise , exit if zero
.1691	f0 22		beq $16b5			beq 	_CNTSExit
.1693	a9 2e		lda #$2e			lda 	#"."
.1695	20 d6 16	jsr $16d6			jsr 	WriteDecimalBuffer 			; write decimal place
.1698					_CNTSDecimal:
.1698	ce 27 04	dec $0427			dec 	decimalPlaces 				; done all the decimals
.169b	30 18		bmi $16b5			bmi 	_CNTSExit
.169d	e8		inx				inx 								; x 10.0
.169e	a9 0a		lda #$0a			lda 	#10
.16a0	20 78 17	jsr $1778			jsr 	FloatSetByte
.16a3	20 36 14	jsr $1436			jsr 	FloatMultiply
.16a6	20 b8 16	jsr $16b8			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.16a9	20 56 13	jsr $1356			jsr 	FloatFractionalPart 		; get the fractional part
.16ac	20 cb 14	jsr $14cb			jsr 	FloatNormalise 				; normalise it.
.16af	b5 68		lda $68,x			lda 	NSExponent,x 				; gone to zero, exit.
.16b1	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.16b3	b0 e3		bcs $1698			bcs 	_CNTSDecimal 				; keep going.
.16b5					_CNTSExit:
.16b5	7a		ply				ply
.16b6	fa		plx				plx
.16b7	60		rts				rts
.16b8					MakePlusTwoString:
.16b8	da		phx				phx
.16b9	20 59 17	jsr $1759			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.16bc	e8		inx				inx 								; access it
.16bd	e8		inx				inx
.16be	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart 			; make it an integer
.16c1	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.16c3	20 f5 16	jsr $16f5			jsr 	ConvertInt32
.16c6	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.16c8					_MPTSCopy:
.16c8	bd 02 04	lda $0402,x			lda 	numberBuffer,x
.16cb	20 d6 16	jsr $16d6			jsr 	WriteDecimalBuffer
.16ce	e8		inx				inx
.16cf	bd 02 04	lda $0402,x			lda 	numberBuffer,x
.16d2	d0 f4		bne $16c8			bne 	_MPTSCopy
.16d4	fa		plx				plx
.16d5	60		rts				rts
.16d6					WriteDecimalBuffer:
.16d6	da		phx				phx
.16d7	ae 28 04	ldx $0428			ldx 	dbOffset
.16da	9d 29 04	sta $0429,x			sta 	decimalBuffer,x
.16dd	9e 2a 04	stz $042a,x			stz 	decimalBuffer+1,x
.16e0	ee 28 04	inc $0428			inc 	dbOffset
.16e3	fa		plx				plx
.16e4	60		rts				rts
.0427					decimalPlaces:
>0427							.fill 	1
.0428					dbOffset:
>0428							.fill 	1
.0429					decimalBuffer:
>0429							.fill 	32
.16e5					ConvertInt16:
.16e5	85 38		sta $38				sta 	NSMantissa0 				; set up as 32 bit conversion
.16e7	86 44		stx $44				stx 	NSMantissa1
.16e9	64 50		stz $50				stz 	NSMantissa2
.16eb	64 5c		stz $5c				stz 	NSMantissa3
.16ed	64 2c		stz $2c				stz 	NSStatus 					; positive integer
.16ef	a2 00		ldx #$00			ldx 	#0 							; stack level
.16f1	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.16f3	80 00		bra $16f5			bra 	ConvertInt32
.16f5					ConvertInt32:
.16f5	5a		phy				phy
.16f6	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.16f8	24 2c		bit $2c				bit 	NSStatus 					; output a - if not negative.
.16fa	10 08		bpl $1704			bpl 	_CI32NotNeg
.16fc	48		pha				pha
.16fd	a9 2d		lda #$2d			lda 	#'-'
.16ff	99 02 04	sta $0402,y			sta 	numberBuffer,y
.1702	c8		iny				iny
.1703	68		pla				pla
.1704					_CI32NotNeg:
.1704	20 12 17	jsr $1712			jsr 	_CI32DivideConvert 			; recursive conversion
.1707	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.1709	99 02 04	sta $0402,y			sta 	numberBuffer,y
.170c	7a		ply				ply
.170d	a2 04		ldx #$04			ldx 	#numberBuffer >> 8 			; return address in XA
.170f	a9 02		lda #$02			lda 	#numberBuffer & $FF
.1711	60		rts				rts
.1712					_CI32DivideConvert:
.1712	e8		inx				inx 								; write to next slot up
.1713	20 78 17	jsr $1778			jsr 	FloatSetByte 		 		; write the base out.
.1716	ca		dex				dex
.1717	20 0c 13	jsr $130c			jsr 	Int32Divide 				; divide
.171a	b5 38		lda $38,x			lda 	NSMantissa0,x 				; save remainder
.171c	48		pha				pha
.171d	20 fb 12	jsr $12fb			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.1720	20 98 17	jsr $1798			jsr 	FloatIsZero 				; is it zero ?
.1723	f0 05		beq $172a			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.1725	b5 39		lda $39,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.1727	20 12 17	jsr $1712			jsr 	_CI32DivideConvert 			; and recusrively call.
.172a					_CI32NoRecurse:
.172a	68		pla				pla 								; remainder
.172b	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.172d	90 02		bcc $1731			bcc 	_CI32NotHex
.172f	69 26		adc #$26			adc 	#6+32
.1731					_CI32NotHex:
.1731	69 30		adc #$30			adc 	#48
.1733	99 02 04	sta $0402,y			sta 	numberBuffer,y 				; write out and exit
.1736	c8		iny				iny
.1737	60		rts				rts
.1738					FloatNegate:
.1738	b5 2c		lda $2c,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.173a	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.173c	95 2c		sta $2c,x			sta 	NSStatus,x
.173e	60		rts				rts
.173f					FloatNegateMantissa:
.173f	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.1740	a9 00		lda #$00			lda 	#0
.1742	f5 38		sbc $38,x			sbc 	NSMantissa0,x
.1744	95 38		sta $38,x			sta 	NSMantissa0,x
.1746	a9 00		lda #$00			lda 	#0
.1748	f5 44		sbc $44,x			sbc 	NSMantissa1,x
.174a	95 44		sta $44,x			sta 	NSMantissa1,x
.174c	a9 00		lda #$00			lda 	#0
.174e	f5 50		sbc $50,x			sbc 	NSMantissa2,x
.1750	95 50		sta $50,x			sta 	NSMantissa2,x
.1752	a9 00		lda #$00			lda 	#0
.1754	f5 5c		sbc $5c,x			sbc 	NSMantissa3,x
.1756	95 5c		sta $5c,x			sta 	NSMantissa3,x
.1758	60		rts				rts
.1759					FloatShiftUpTwo:
.1759	b5 38		lda $38,x			lda 	NSMantissa0,x
.175b	95 3a		sta $3a,x			sta 	NSMantissa0+2,x
.175d	b5 44		lda $44,x			lda 	NSMantissa1,x
.175f	95 46		sta $46,x			sta 	NSMantissa1+2,x
.1761	b5 50		lda $50,x			lda 	NSMantissa2,x
.1763	95 52		sta $52,x			sta 	NSMantissa2+2,x
.1765	b5 5c		lda $5c,x			lda 	NSMantissa3,x
.1767	95 5e		sta $5e,x			sta 	NSMantissa3+2,x
.1769	b5 68		lda $68,x			lda 	NSExponent,x
.176b	95 6a		sta $6a,x			sta 	NSExponent+2,x
.176d	b5 2c		lda $2c,x			lda 	NSStatus,x
.176f	95 2e		sta $2e,x			sta 	NSStatus+2,x
.1771	60		rts				rts
.1772					FloatSetZeroMantissaOnly:
.1772	74 38		stz $38,x			stz 	NSMantissa0,x
.1774	80 08		bra $177e			bra 	FloatZero13
.1776					FloatSetZero:
.1776	a9 00		lda #$00			lda 	#0
.1778					FloatSetByte:
.1778	74 68		stz $68,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.177a					FloatSetMantissa:
.177a	95 38		sta $38,x			sta 	NSMantissa0,x 				; zero mantissa
.177c	74 2c		stz $2c,x			stz 	NSStatus,x
.177e					FloatZero13:
.177e	74 44		stz $44,x			stz 	NSMantissa1,x
.1780	74 50		stz $50,x			stz 	NSMantissa2,x
.1782	74 5c		stz $5c,x			stz 	NSMantissa3,x
.1784	60		rts				rts
.1785					FloatShiftLeft:
.1785	18		clc				clc
.1786					FloatRotateLeft:
.1786	36 38		rol $38,x			rol 	NSMantissa0,x
.1788	36 44		rol $44,x			rol		NSMantissa1,x
.178a	36 50		rol $50,x			rol		NSMantissa2,x
.178c	36 5c		rol $5c,x			rol		NSMantissa3,x
.178e	60		rts				rts
.178f					FloatShiftRight:
.178f	56 5c		lsr $5c,x			lsr 	NSMantissa3,x
.1791	76 50		ror $50,x			ror		NSMantissa2,x
.1793	76 44		ror $44,x			ror		NSMantissa1,x
.1795	76 38		ror $38,x			ror		NSMantissa0,x
.1797	60		rts				rts
.1798					FloatIsZero:
.1798	b5 5c		lda $5c,x			lda 	NSMantissa3,x
.179a	15 50		ora $50,x			ora		NSMantissa2,x
.179c	15 44		ora $44,x			ora		NSMantissa1,x
.179e	15 38		ora $38,x			ora		NSMantissa0,x
.17a0	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.17a1					FloatArcTan:
.17a1	20 cb 14	jsr $14cb			jsr 	FloatNormalise 					; normalise x
.17a4	b5 2c		lda $2c,x			lda 	NSStatus,x 						; save sign, make absolute
.17a6	48		pha				pha
.17a7	74 2c		stz $2c,x			stz 	NSStatus,x
.17a9	b5 68		lda $68,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.17ab	c9 e2		cmp #$e2			cmp 	#$E2
.17ad	90 25		bcc $17d4			bcc 	_UANoFixup
.17af	8a		txa				txa 									; value in +1
.17b0	a8		tay				tay
.17b1	c8		iny				iny
.17b2	20 5a 19	jsr $195a			jsr 	CopyFloatXY
.17b5	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.17b7	20 78 17	jsr $1778			jsr 	FloatSetByte
.17ba	e8		inx				inx
.17bb	20 bf 12	jsr $12bf			jsr 	FloatDivide
.17be	b0 21		bcs $17e1			bcs 	_FATError
.17c0	20 e4 17	jsr $17e4			jsr 	CoreAtn 						; calculate the root
.17c3	20 4f 19	jsr $194f			jsr 	CompletePolynomial
.17c6	20 38 17	jsr $1738			jsr 	FloatNegate 					; make -ve
.17c9	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.17cb	20 a6 19	jsr $19a6			jsr 	LoadConstant
.17ce	e8		inx				inx
.17cf	20 9a 11	jsr $119a			jsr 	FloatAdd
.17d2	80 06		bra $17da			bra 	_UAComplete
.17d4					_UANoFixup:
.17d4	20 e4 17	jsr $17e4			jsr 	CoreAtn
.17d7	20 4f 19	jsr $194f			jsr 	CompletePolynomial
.17da					_UAComplete:
.17da	68		pla				pla 									; apply the result.
.17db	55 2c		eor $2c,x			eor 	NSStatus,x
.17dd	95 2c		sta $2c,x			sta 	NSStatus,x
.17df	18		clc				clc
.17e0	60		rts				rts
.17e1					_FATError:
.17e1	68		pla				pla
.17e2	38		sec				sec
.17e3	60		rts				rts
.17e4					CoreAtn:
.17e4	a9 52		lda #$52			lda 	#AtnCoefficients & $FF
.17e6	a0 18		ldy #$18			ldy 	#AtnCoefficients >> 8
.17e8	4c a3 1a	jmp $1aa3			jmp 	CorePolySquared
.17eb					ExpCoefficients:
>17eb	07					.byte	7
>17ec	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>17f0	d2					.byte	$d2
>17f1	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>17f5	d5					.byte	$d5
>17f6	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>17fa	d8					.byte	$d8
>17fb	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>17ff	db					.byte	$db
>1800	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>1804	dd					.byte	$dd
>1805	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>1809	df					.byte	$df
>180a	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>180e	e1					.byte	$e1
>180f	00 00 00 40				.dword	$40000000 ; 1.0
>1813	e2					.byte	$e2
.1814					SinCoefficients:
>1814	06					.byte	6
>1815	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>1819	e5					.byte	$e5
>181a	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>181e	e7					.byte	$e7
>181f	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>1823	e8					.byte	$e8
>1824	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>1828	e8					.byte	$e8
>1829	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>182d	e7					.byte	$e7
>182e	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>1832	e4					.byte	$e4
>1833	00 00 00 00				.dword	$00000000 ; 0.0
>1837	00					.byte	$00
.1838					LogCoefficients:
>1838	04					.byte	4
>1839	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>183d	e0					.byte	$e0
>183e	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>1842	e1					.byte	$e1
>1843	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>1847	e1					.byte	$e1
>1848	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>184c	e3					.byte	$e3
>184d	00 00 00 c0				.dword	$c0000000 ; -0.5
>1851	e1					.byte	$e1
.1852					AtnCoefficients:
>1852	0c					.byte	12
>1853	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>1857	d7					.byte	$d7
>1858	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>185c	da					.byte	$da
>185d	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>1861	dc					.byte	$dc
>1862	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>1866	dd					.byte	$dd
>1867	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>186b	dd					.byte	$dd
>186c	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>1870	de					.byte	$de
>1871	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>1875	de					.byte	$de
>1876	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>187a	de					.byte	$de
>187b	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>187f	df					.byte	$df
>1880	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>1884	df					.byte	$df
>1885	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>1889	e0					.byte	$e0
>188a	00 00 00 40				.dword	$40000000 ; 1.0
>188e	e2					.byte	$e2
>188f	00 00 00 00				.dword	$00000000 ; 0.0
>1893	00					.byte	$00
.1894					Const_Base:
.1894					Const_1Div2Pi:
>1894	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>1898	df					.byte	$df
.1899					Const_PiDiv2:
>1899	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>189d	e2					.byte	$e2
.189e					Const_Log2_e:
>189e	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>18a2	e2					.byte	$e2
.18a3					Const_sqrt_2:
>18a3	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>18a7	e2					.byte	$e2
.18a8					Const_sqrt_half:
>18a8	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>18ac	e1					.byte	$e1
.18ad					Const_pi:
>18ad	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>18b1	e3					.byte	$e3
.18b2					Const_half:
>18b2	00 00 00 40				.dword	$40000000 ; 0.50000000
>18b6	e1					.byte	$e1
.18b7					Const_ln_e:
>18b7	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>18bb	e1					.byte	$e1
.18bc					FloatCosine:
.18bc	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.18be	20 a6 19	jsr $19a6			jsr 	LoadConstant
.18c1	e8		inx				inx
.18c2	20 9a 11	jsr $119a			jsr 	FloatAdd
.18c5	4c 5c 1a	jmp $1a5c			jmp 	FloatSine
.18c8					FloatExponent:
.18c8	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.18ca	20 a6 19	jsr $19a6			jsr 	LoadConstant
.18cd	e8		inx				inx
.18ce	20 36 14	jsr $1436			jsr 	FloatMultiply
.18d1	20 13 19	jsr $1913			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.18d4	e8		inx				inx
.18d5	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.18d8	ca		dex				dex
.18d9	b5 45		lda $45,x			lda 	NSMantissa1+1,x
.18db	15 51		ora $51,x			ora 	NSMantissa2+1,x
.18dd	15 5d		ora $5d,x			ora 	NSMantissa3+1,x
.18df	d0 38		bne $1919			bne 	_UERangeError
.18e1	b5 39		lda $39,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.18e3	c9 40		cmp #$40			cmp 	#64
.18e5	b0 32		bcs $1919			bcs 	_UERangeError
.18e7	48		pha				pha
.18e8	b5 2c		lda $2c,x			lda 	NSStatus,x 				; push sign
.18ea	48		pha				pha
.18eb	20 56 13	jsr $1356			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.18ee	68		pla				pla
.18ef	10 14		bpl $1905			bpl 	_UEPositive
.18f1	e8		inx				inx 							; 1-x
.18f2	a9 01		lda #$01			lda 	#1
.18f4	20 78 17	jsr $1778			jsr 	FloatSetByte
.18f7	ca		dex				dex
.18f8	20 38 17	jsr $1738			jsr 	FloatNegate
.18fb	e8		inx				inx
.18fc	20 9a 11	jsr $119a			jsr 	FloatAdd
.18ff	68		pla				pla 							; integer part +1 and negated.
.1900	1a		inc a				inc 	a
.1901	49 ff		eor #$ff			eor 	#$FF
.1903	1a		inc a				inc 	a
.1904	48		pha				pha
.1905					_UEPositive:
.1905	20 1b 19	jsr $191b			jsr 	CoreExponent
.1908	20 4f 19	jsr $194f			jsr 	CompletePolynomial
.190b	68		pla				pla
.190c	18		clc				clc
.190d	75 68		adc $68,x			adc 	NSExponent,x
.190f	95 68		sta $68,x			sta 	NSExponent,x
.1911	18		clc				clc
.1912	60		rts				rts
.1913					_UECopy01:
.1913	8a		txa				txa
.1914	a8		tay				tay
.1915	c8		iny				iny
.1916	4c 5a 19	jmp $195a			jmp 	CopyFloatXY
.1919					_UERangeError:
.1919	38		sec				sec
.191a	60		rts				rts
.191b					CoreExponent:
.191b	a9 eb		lda #$eb			lda 	#ExpCoefficients & $FF
.191d	a0 17		ldy #$17			ldy 	#ExpCoefficients >> 8
.191f	20 23 19	jsr $1923			jsr 	CalculateHornerPolynomial
.1922	60		rts				rts
.1923					CalculateHornerPolynomial:
.1923	85 26		sta $26				sta 	zTemp0 						; save poly data from YA
.1925	84 27		sty $27				sty 	zTemp0+1
.1927	9c 49 04	stz $0449			stz 	coefficientCount 			; zero the count.
.192a	8e 4a 04	stx $044a			stx 	xValueSlot 					; save xValue slot.
.192d	e8		inx				inx 								; set the count to zero.
.192e	20 76 17	jsr $1776			jsr 	FloatSetZero
.1931					_CHPLoop:
.1931	8a		txa				txa 								; copy X-1 to X+1
.1932	a8		tay				tay
.1933	ca		dex				dex
.1934	c8		iny				iny
.1935	20 5a 19	jsr $195a			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.1938	e8		inx				inx
.1939	e8		inx				inx
.193a	20 36 14	jsr $1436			jsr 	FloatMultiply 				; times current by X
.193d	e8		inx				inx
.193e	20 79 19	jsr $1979			jsr 	GetCoefficient 				; coefficient into X+1
.1941	20 9a 11	jsr $119a			jsr 	FloatAdd 					; and add
.1944	ee 49 04	inc $0449			inc 	coefficientCount
.1947	ad 49 04	lda $0449			lda 	coefficientCount
.194a	d2 26		cmp ($26)			cmp 	(zTemp0)
.194c	d0 e3		bne $1931			bne 	_CHPLoop
.194e	60		rts				rts
.194f					CompletePolynomial:
.194f	20 36 14	jsr $1436			jsr 	FloatMultiply
.1952	e8		inx				inx 								; get the last value
.1953	20 79 19	jsr $1979			jsr 	GetCoefficient
.1956	20 9a 11	jsr $119a			jsr 	FloatAdd 					; and add it
.1959	60		rts				rts
.195a					CopyFloatXY:
.195a	b5 68		lda $68,x			lda 	NSExponent,x
.195c	99 68 00	sta $0068,y			sta 	NSExponent,y
.195f	b5 2c		lda $2c,x			lda 	NSStatus,x
.1961	99 2c 00	sta $002c,y			sta 	NSStatus,y
.1964	b5 38		lda $38,x			lda 	NSMantissa0,x
.1966	99 38 00	sta $0038,y			sta 	NSMantissa0,y
.1969	b5 44		lda $44,x			lda 	NSMantissa1,x
.196b	99 44 00	sta $0044,y			sta 	NSMantissa1,y
.196e	b5 50		lda $50,x			lda 	NSMantissa2,x
.1970	99 50 00	sta $0050,y			sta 	NSMantissa2,y
.1973	b5 5c		lda $5c,x			lda 	NSMantissa3,x
.1975	99 5c 00	sta $005c,y			sta 	NSMantissa3,y
.1978	60		rts				rts
.1979					GetCoefficient:
.1979	5a		phy				phy
.197a	ad 49 04	lda $0449			lda 	coefficientCount 			; 5 per block
.197d	0a		asl a				asl 	a
.197e	0a		asl a				asl 	a
.197f	38		sec				sec 								; +1 for count
.1980	6d 49 04	adc $0449			adc 	coefficientCount
.1983	a8		tay				tay
.1984	b1 26		lda ($26),y			lda 	(zTemp0),y 					; copy mantissa
.1986	95 38		sta $38,x			sta 	NSMantissa0,x
.1988	c8		iny				iny
.1989	b1 26		lda ($26),y			lda 	(zTemp0),y
.198b	95 44		sta $44,x			sta 	NSMantissa1,x
.198d	c8		iny				iny
.198e	b1 26		lda ($26),y			lda 	(zTemp0),y
.1990	95 50		sta $50,x			sta 	NSMantissa2,x
.1992	c8		iny				iny
.1993	b1 26		lda ($26),y			lda 	(zTemp0),y
.1995	48		pha				pha
.1996	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.1998	95 5c		sta $5c,x			sta 	NSMantissa3,x
.199a	c8		iny				iny
.199b	68		pla				pla
.199c	29 80		and #$80			and 	#$80
.199e	95 2c		sta $2c,x			sta 	NSStatus,x 					; put in status
.19a0	b1 26		lda ($26),y			lda 	(zTemp0),y
.19a2	95 68		sta $68,x			sta 	NSExponent,x
.19a4	7a		ply				ply
.19a5	60		rts				rts
.0449					coefficientCount:
>0449							.fill 	1
.044a					xValueSlot:
>044a							.fill 	1
.19a6					LoadConstant:
.19a6	5a		phy				phy
.19a7	a8		tay				tay
.19a8	b9 94 18	lda $1894,y			lda 	Const_Base+0,y
.19ab	95 39		sta $39,x			sta 	NSMantissa0+1,x
.19ad	b9 95 18	lda $1895,y			lda 	Const_Base+1,y
.19b0	95 45		sta $45,x			sta 	NSMantissa1+1,x
.19b2	b9 96 18	lda $1896,y			lda 	Const_Base+2,y
.19b5	95 51		sta $51,x			sta 	NSMantissa2+1,x
.19b7	b9 97 18	lda $1897,y			lda 	Const_Base+3,y
.19ba	48		pha				pha
.19bb	29 7f		and #$7f			and 	#$7F
.19bd	95 5d		sta $5d,x			sta 	NSMantissa3+1,x
.19bf	68		pla				pla
.19c0	29 80		and #$80			and 	#$80
.19c2	95 2d		sta $2d,x			sta 	NSStatus+1,x
.19c4	b9 98 18	lda $1898,y			lda 	Const_Base+4,y
.19c7	95 69		sta $69,x			sta 	NSExponent+1,x
.19c9	7a		ply				ply
.19ca	60		rts				rts
.19cb					FloatLogarithm:
.19cb	b5 2c		lda $2c,x			lda 	NSStatus,x 					; check > 0
.19cd	30 5f		bmi $1a2e			bmi 	_ULRange
.19cf	20 98 17	jsr $1798			jsr 	FloatIsZero
.19d2	f0 5a		beq $1a2e			beq 	_ULRange
.19d4	20 cb 14	jsr $14cb			jsr 	FloatNormalise 				; put into FP mode.
.19d7	b5 68		lda $68,x			lda 	NSExponent,x 				; get power
.19d9	48		pha				pha
.19da	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.19dc	95 68		sta $68,x			sta 	NSExponent,x
.19de	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.19e0	20 a6 19	jsr $19a6			jsr 	LoadConstant
.19e3	e8		inx				inx
.19e4	20 9a 11	jsr $119a			jsr 	FloatAdd
.19e7	8a		txa				txa 								; divide into sqrt 2.0
.19e8	a8		tay				tay
.19e9	c8		iny				iny
.19ea	20 5a 19	jsr $195a			jsr 	CopyFloatXY
.19ed	ca		dex				dex
.19ee	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.19f0	20 a6 19	jsr $19a6			jsr 	LoadConstant
.19f3	e8		inx				inx
.19f4	e8		inx				inx
.19f5	20 bf 12	jsr $12bf			jsr 	FloatDivide 				; if zero, error.
.19f8	b0 33		bcs $1a2d			bcs 	_ULRangePla
.19fa	20 38 17	jsr $1738			jsr 	FloatNegate 				; subtract from 1
.19fd	e8		inx				inx
.19fe	a9 01		lda #$01			lda 	#1
.1a00	20 78 17	jsr $1778			jsr 	FloatSetByte
.1a03	20 9a 11	jsr $119a			jsr 	FloatAdd
.1a06	20 30 1a	jsr $1a30			jsr 	CoreLog
.1a09	20 4f 19	jsr $194f			jsr 	CompletePolynomial
.1a0c	68		pla				pla 								; add exponent
.1a0d	18		clc				clc
.1a0e	69 1f		adc #$1f			adc 	#31 						; fix up
.1a10	48		pha				pha
.1a11	10 03		bpl $1a16			bpl 	_LogNotNeg
.1a13	49 ff		eor #$ff			eor 	#$FF
.1a15	1a		inc a				inc 	a
.1a16					_LogNotNeg:
.1a16	e8		inx				inx 								; set byte and sign.
.1a17	20 78 17	jsr $1778			jsr 	FloatSetByte
.1a1a	68		pla				pla
.1a1b	29 80		and #$80			and 	#$80
.1a1d	95 2c		sta $2c,x			sta 	NSStatus,x
.1a1f	20 9a 11	jsr $119a			jsr 	FloatAdd
.1a22	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.1a24	20 a6 19	jsr $19a6			jsr 	LoadConstant
.1a27	e8		inx				inx
.1a28	20 36 14	jsr $1436			jsr 	FloatMultiply
.1a2b	18		clc				clc
.1a2c	60		rts				rts
.1a2d					_ULRangePla:
.1a2d	68		pla				pla
.1a2e					_ULRange:
.1a2e	38		sec				sec
.1a2f	60		rts				rts
.1a30					CoreLog:
.1a30	a9 38		lda #$38			lda 	#LogCoefficients & $FF
.1a32	a0 18		ldy #$18			ldy 	#LogCoefficients >> 8
.1a34	4c a3 1a	jmp $1aa3			jmp 	CorePolySquared
.1a37					FloatPI:
.1a37	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.1a39	20 a6 19	jsr $19a6			jsr 	LoadConstant
.1a3c	e8		inx				inx
.1a3d	18		clc				clc
.1a3e	60		rts				rts
.1a3f					FloatPower:
.1a3f	ca		dex				dex
.1a40	8a		txa				txa 							; copy 0 to 2, so we can process it
.1a41	a8		tay				tay
.1a42	c8		iny				iny
.1a43	c8		iny				iny
.1a44	20 5a 19	jsr $195a			jsr 	CopyFloatXY
.1a47	e8		inx				inx 							; 2 = Log(0)
.1a48	e8		inx				inx
.1a49	20 cb 19	jsr $19cb			jsr 	FloatLogarithm
.1a4c	b0 0d		bcs $1a5b			bcs 	_FPWExit
.1a4e	20 36 14	jsr $1436			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.1a51	8a		txa				txa 							; copy to slot 0
.1a52	a8		tay				tay
.1a53	88		dey				dey
.1a54	20 5a 19	jsr $195a			jsr 	CopyFloatXY
.1a57	ca		dex				dex  							; Exponent code.
.1a58	20 c8 18	jsr $18c8			jsr 	FloatExponent
.1a5b					_FPWExit:
.1a5b	60		rts				rts
.1a5c					FloatSine:
.1a5c	b5 2c		lda $2c,x			lda 	NSStatus,x 					; save sign
.1a5e	48		pha				pha
.1a5f	74 2c		stz $2c,x			stz 	NSStatus,x 					; make +ve
.1a61	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.1a63	20 a6 19	jsr $19a6			jsr 	LoadConstant
.1a66	e8		inx				inx
.1a67	20 36 14	jsr $1436			jsr 	FloatMultiply
.1a6a	20 56 13	jsr $1356			jsr 	FloatFractionalPart 		; take the fractional part
.1a6d	b5 68		lda $68,x			lda 	NSExponent,x 				; check exponent
.1a6f	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.1a71	90 1f		bcc $1a92			bcc 	_USProcessExit
.1a73	f0 06		beq $1a7b			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.1a75	b5 5c		lda $5c,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.1a77	c9 60		cmp #$60			cmp 	#$60
.1a79	b0 0e		bcs $1a89			bcs 	_USSubtractOne
.1a7b					_USSubtractFromHalf:
.1a7b	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.1a7d	20 a6 19	jsr $19a6			jsr 	LoadConstant
.1a80	e8		inx				inx
.1a81	20 94 11	jsr $1194			jsr 	FloatSubtract
.1a84	20 38 17	jsr $1738			jsr 	FloatNegate 				; then negate it
.1a87	80 09		bra $1a92			bra 	_USProcessExit 				; and exit
.1a89					_USSubtractOne:
.1a89	e8		inx				inx
.1a8a	a9 01		lda #$01			lda 	#1
.1a8c	20 78 17	jsr $1778			jsr 	FloatSetByte
.1a8f	20 94 11	jsr $1194			jsr 	FloatSubtract
.1a92					_USProcessExit:
.1a92	20 9f 1a	jsr $1a9f			jsr 	CoreSine
.1a95	20 4f 19	jsr $194f			jsr 	CompletePolynomial
.1a98	68		pla				pla 								; restore sign and apply
.1a99	55 2c		eor $2c,x			eor 	NSStatus,x
.1a9b	95 2c		sta $2c,x			sta 	NSStatus,x
.1a9d	18		clc				clc
.1a9e	60		rts				rts
.1a9f					CoreSine:
.1a9f	a9 14		lda #$14			lda 	#SinCoefficients & $FF
.1aa1	a0 18		ldy #$18			ldy 	#SinCoefficients >> 8
.1aa3					CorePolySquared:
.1aa3	48		pha				pha 								; save coefficient table
.1aa4	5a		phy				phy
.1aa5	8a		txa				txa 								; copy X to +1, +2
.1aa6	a8		tay				tay
.1aa7	c8		iny				iny
.1aa8	20 5a 19	jsr $195a			jsr 	CopyFloatXY
.1aab	c8		iny				iny
.1aac	20 5a 19	jsr $195a			jsr 	CopyFloatXY
.1aaf	e8		inx				inx 								; point to the pair and put x^2 on stack
.1ab0	e8		inx				inx
.1ab1	20 36 14	jsr $1436			jsr 	FloatMultiply
.1ab4	7a		ply				ply 								; coefficient table back.
.1ab5	68		pla				pla
.1ab6	20 23 19	jsr $1923			jsr 	CalculateHornerPolynomial
.1ab9	8a		txa				txa 								; copy back to slot #1
.1aba	a8		tay				tay
.1abb	88		dey				dey
.1abc	20 5a 19	jsr $195a			jsr	 	CopyFloatXY
.1abf	ca		dex				dex 								; point at result
.1ac0	60		rts				rts
.1ac1					FloatSquareRoot:
.1ac1	20 cb 19	jsr $19cb			jsr 	FloatLogarithm
.1ac4	b0 06		bcs $1acc			bcs 	_FSQExit
.1ac6	d6 68		dec $68,x			dec 	NSExponent,x
.1ac8	20 c8 18	jsr $18c8			jsr 	FloatExponent
.1acb	18		clc				clc
.1acc					_FSQExit:
.1acc	60		rts				rts
.1acd					FloatTangent:
.1acd	da		phx				phx
.1ace	8a		txa				txa 								; sin -> +1
.1acf	a8		tay				tay
.1ad0	c8		iny				iny
.1ad1	20 5a 19	jsr $195a			jsr 	CopyFloatXY
.1ad4	e8		inx				inx
.1ad5	20 5c 1a	jsr $1a5c			jsr 	FloatSine
.1ad8	ca		dex				dex
.1ad9	8a		txa				txa 								; cos -> +2
.1ada	a8		tay				tay
.1adb	c8		iny				iny
.1adc	c8		iny				iny
.1add	20 5a 19	jsr $195a			jsr 	CopyFloatXY
.1ae0	e8		inx				inx
.1ae1	e8		inx				inx
.1ae2	20 bc 18	jsr $18bc			jsr 	FloatCosine
.1ae5	20 bf 12	jsr $12bf			jsr 	FloatDivide 				; calculate sin/cos
.1ae8	b0 07		bcs $1af1			bcs 	_FTExit 					; divide by zero
.1aea	8a		txa				txa 								; copy result down.
.1aeb	a8		tay				tay
.1aec	88		dey				dey
.1aed	20 5a 19	jsr $195a			jsr 	CopyFloatXY
.1af0	18		clc				clc
.1af1					_FTExit:
.1af1	fa		plx				plx
.1af2	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.0074					srcPtr:
>0074							.fill 	2
.044b					currentLineNumber:
>044b							.fill 	2
.1af3					InlineNonDecimal:
.1af3	a2 02		ldx #$02			ldx 	#2 							; get size in X
.1af5	c9 25		cmp #$25			cmp 	#"%"
.1af7	f0 02		beq $1afb			beq 	_INDBinary
.1af9	a2 10		ldx #$10			ldx 	#16
.1afb					_INDBinary:
.1afb	85 28		sta $28				sta 	zTemp1 						; size => zTemp1
.1afd	64 29		stz $29				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.1aff	64 26		stz $26				stz 	zTemp0 						; zero result
.1b01	64 27		stz $27				stz 	zTemp0+1
.1b03					_INDLoop:
.1b03	20 9f 24	jsr $249f			jsr 	LookNext 					; check next character
.1b06	20 db 24	jsr $24db			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.1b09	90 1f		bcc $1b2a			bcc		_INDDone 					; didn't convert
.1b0b	c5 28		cmp $28				cmp 	zTemp1 						; size too large ?
.1b0d	b0 1b		bcs $1b2a			bcs 	_INDDone
.1b0f	20 39 1b	jsr $1b39			jsr 	_INDShift 					; x 2 or x 16
.1b12	e0 02		cpx #$02			cpx 	#2
.1b14	f0 09		beq $1b1f			beq 	_INDNotHex
.1b16	20 39 1b	jsr $1b39			jsr 	_INDShift
.1b19	20 39 1b	jsr $1b39			jsr 	_INDShift
.1b1c	20 39 1b	jsr $1b39			jsr 	_INDShift
.1b1f					_INDNotHex:
.1b1f	05 26		ora $26				ora 	zTemp0 						; or digit into result
.1b21	85 26		sta $26				sta 	zTemp0
.1b23	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume
.1b26	e6 29		inc $29				inc 	zTemp1+1 					; bump count
.1b28	80 d9		bra $1b03			bra 	_INDLoop
.1b2a					_INDDone:
.1b2a	a5 29		lda $29				lda 	zTemp1+1 					; done at least 1 ?
.1b2c	f0 08		beq $1b36			beq 	_INDError
.1b2e	a4 27		ldy $27				ldy 	zTemp0+1 					; push constant
.1b30	a5 26		lda $26				lda 	zTemp0
.1b32	20 5a 1c	jsr $1c5a			jsr 	PushIntegerYA
.1b35	60		rts				rts
.1b36					_INDError:
.1b36	4c 30 10	jmp $1030		jmp	ErrorV_syntax
.1b39					_INDShift:
.1b39	06 26		asl $26				asl 	zTemp0
.1b3b	26 27		rol $27				rol 	zTemp0+1
.1b3d	60		rts				rts
.1b3e					GetLineNumber:
.1b3e	ac 4c 04	ldy $044c			ldy 	currentLineNumber+1
.1b41	ad 4b 04	lda $044b			lda 	currentLineNumber
.1b44	60		rts				rts
.1b45					WriteCodeByte:
.1b45	48		pha				pha 								; save on stack
.1b46	da		phx				phx
.1b47	5a		phy				phy
.1b48	aa		tax				tax
.1b49	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.1b4b	20 57 1c	jsr $1c57			jsr 	CallAPIHandler
.1b4e	7a		ply				ply 								; restore from stack
.1b4f	fa		plx				plx
.1b50	68		pla				pla
.1b51	60		rts				rts
.1b52					PrintCharacter
.1b52	48		pha				pha
.1b53	da		phx				phx
.1b54	5a		phy				phy
.1b55	aa		tax				tax
.1b56	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.1b58	20 57 1c	jsr $1c57			jsr 	CallAPIHandler
.1b5b	7a		ply				ply
.1b5c	fa		plx				plx
.1b5d	68		pla				pla
.1b5e	60		rts				rts
.1b5f					ProcessNewLine:
.1b5f	86 26		stx $26				stx 	zTemp0 						; save address in zTemp0
.1b61	84 27		sty $27				sty 	zTemp0+1
.1b63	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.1b64	8a		txa				txa
.1b65	69 04		adc #$04			adc 	#4
.1b67	85 74		sta $74				sta 	srcPtr
.1b69	98		tya				tya
.1b6a	69 00		adc #$00			adc 	#0
.1b6c	85 75		sta $75				sta 	srcPtr+1
.1b6e	a0 02		ldy #$02			ldy 	#2							; read and save line number
.1b70	b1 26		lda ($26),y			lda 	(zTemp0),y
.1b72	8d 4b 04	sta $044b			sta 	currentLineNumber
.1b75	c8		iny				iny
.1b76	b1 26		lda ($26),y			lda 	(zTemp0),y
.1b78	8d 4c 04	sta $044c			sta 	currentLineNumber+1
.1b7b	60		rts				rts
.1b7c					BufferClear:
.1b7c	9c 4d 04	stz $044d			stz 	bufferSize
.1b7f	60		rts				rts
.1b80					BufferWrite:
.1b80	da		phx				phx
.1b81	ae 4d 04	ldx $044d			ldx 	bufferSize
.1b84	9d 4e 04	sta $044e,x			sta 	dataBuffer,x
.1b87	ee 4d 04	inc $044d			inc 	bufferSize
.1b8a	fa		plx				plx
.1b8b	60		rts				rts
.1b8c					BufferOutput:
.1b8c	ad 4d 04	lda $044d			lda 	bufferSize
.1b8f	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1b92	a2 00		ldx #$00			ldx 	#0
.1b94					_BOLoop:
.1b94	ec 4d 04	cpx $044d			cpx 	bufferSize
.1b97	f0 09		beq $1ba2			beq 	_BOExit
.1b99	bd 4e 04	lda $044e,x			lda 	dataBuffer,x
.1b9c	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1b9f	e8		inx				inx
.1ba0	80 f2		bra $1b94			bra 	_BOLoop
.1ba2					_BOExit:
.1ba2	60		rts				rts
.044d					bufferSize:
>044d							.fill 	1
.044e					dataBuffer:
>044e							.fill 	256
.1ba3					CheckNextComma:
.1ba3	a9 2c		lda #$2c			lda	 	#","
.1ba5	80 06		bra $1bad			bra 	CheckNextA
.1ba7					CheckNextRParen:
.1ba7	a9 29		lda #$29			lda	 	#")"
.1ba9	80 02		bra $1bad			bra 	CheckNextA
.1bab					CheckNextLParen:
.1bab	a9 28		lda #$28			lda 	#"("
.1bad					CheckNextA:
.1bad	8d 4e 05	sta $054e			sta 	checkCharacter 				; save test character
.1bb0					_CNALoop:
.1bb0	20 bb 24	jsr $24bb			jsr 	GetNextNonSpace 			; get next skipping spaces.
.1bb3	cd 4e 05	cmp $054e			cmp 	checkCharacter 				; matches ?
.1bb6	f0 03		beq $1bbb			beq 	_CNAExit
.1bb8	4c 30 10	jmp $1030		jmp	ErrorV_syntax
.1bbb					_CNAExit:
.1bbb	60		rts				rts
.054e					checkCharacter:
>054e							.fill 	1
.1bbc					StartCompiler:
.1bbc	86 26		stx $26				stx 	zTemp0 						; access API
.1bbe	84 27		sty $27				sty 	zTemp0+1
.1bc0	a0 1e		ldy #$1e			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.1bc2	a2 13		ldx #$13			ldx 	#CompilerErrorHandler & $FF
.1bc4	20 09 10	jsr $1009			jsr 	SetErrorHandler
.1bc7	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.1bc9	b2 26		lda ($26)			lda 	(zTemp0)
.1bcb	8d 50 05	sta $0550			sta 	APIVector
.1bce	b1 26		lda ($26),y			lda 	(zTemp0),y
.1bd0	8d 51 05	sta $0551			sta 	APIVector+1
.1bd3	c8		iny				iny 								; copy data area range.
.1bd4	b1 26		lda ($26),y			lda 	(zTemp0),y
.1bd6	8d 52 05	sta $0552			sta 	compilerStartHigh
.1bd9	c8		iny				iny
.1bda	b1 26		lda ($26),y			lda 	(zTemp0),y
.1bdc	8d 53 05	sta $0553			sta 	compilerEndHigh
.1bdf	ba		tsx				tsx 								; save stack pointer
.1be0	8e 4f 05	stx $054f			stx 	compilerSP
.1be3	20 3f 28	jsr $283f			jsr 	STRReset 					; reset storage (line#, variable)
.1be6	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.1be8	20 57 1c	jsr $1c57			jsr 	CallAPIHandler
.1beb	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.1bed	20 57 1c	jsr $1c57			jsr 	CallAPIHandler
.1bf0	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.1bf2	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1bf5	a9 00		lda #$00			lda 	#0
.1bf7	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1bfa	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1bfd					MainCompileLoop:
.1bfd	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.1bff	20 57 1c	jsr $1c57			jsr 	CallAPIHandler
.1c02	90 31		bcc $1c35			bcc 	SaveCodeAndExit 			; end of source.
.1c04	20 5f 1b	jsr $1b5f			jsr 	ProcessNewLine 				; set up pointer and line number.
.1c07	20 3e 1b	jsr $1b3e			jsr 	GetLineNumber 				; get line #
.1c0a	20 29 26	jsr $2629			jsr 	STRMarkLine 				; remember the code position and number of this line.
.1c0d	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.1c0f	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1c12					_MCLSameLine:
.1c12	20 bb 24	jsr $24bb			jsr 	GetNextNonSpace 			; get the first character.
.1c15	f0 e6		beq $1bfd			beq 	MainCompileLoop 			; end of line, get next line.
.1c17	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.1c19	f0 f7		beq $1c12			beq 	_MCLSameLine
.1c1b	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.1c1d	10 0c		bpl $1c2b			bpl 	_MCLCheckAssignment
.1c1f	a2 79		ldx #$79			ldx 	#CommandTables & $FF 		; do command tables.
.1c21	a0 20		ldy #$20			ldy 	#CommandTables >> 8
.1c23	20 41 23	jsr $2341			jsr 	GeneratorProcess
.1c26	b0 ea		bcs $1c12			bcs 	_MCLSameLine 				; keep trying to compile the line.
.1c28					_MCLSyntax:
.1c28	4c 30 10	jmp $1030		jmp	ErrorV_syntax
.1c2b					_MCLCheckAssignment:
.1c2b	20 d1 24	jsr $24d1			jsr 	CharIsAlpha 				; if not alpha then syntax error
.1c2e	90 f8		bcc $1c28			bcc 	_MCLSyntax
.1c30	20 f7 25	jsr $25f7			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.1c33	80 dd		bra $1c12			bra		_MCLSameLine 				; loop back.
.1c35					SaveCodeAndExit:
.1c35	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.1c37	20 57 1c	jsr $1c57			jsr 	CallAPIHandler
.1c3a	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.1c3c	a8		tay				tay
.1c3d	20 29 26	jsr $2629			jsr 	STRMarkLine
.1c40	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.1c42	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1c45	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.1c47	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1c4a	20 71 1f	jsr $1f71			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.1c4d	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.1c4f	20 57 1c	jsr $1c57			jsr 	CallAPIHandler
.1c52					ExitCompiler:
.1c52	ae 4f 05	ldx $054f			ldx 	compilerSP 					; reload SP and exit.
.1c55	9a		txs				txs
.1c56	60		rts				rts
.1c57					CallAPIHandler:
.1c57	6c 50 05	jmp ($0550)			jmp 	(APIVector)
.054f					compilerSP:
>054f							.fill 	1
.0550					APIVector:
>0550							.fill 	2
.0552					compilerStartHigh:
>0552							.fill 	1
.0553					compilerEndHigh:
>0553							.fill 	1
.1c5a					PushIntegerYA:
.1c5a	c0 00		cpy #$00			cpy 	#0 							; 0-255
.1c5c	f0 0f		beq $1c6d			beq 	PushIntegerA
.1c5e	48		pha				pha
.1c5f	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.1c61	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1c64	68		pla				pla 								; then LSB
.1c65	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1c68	98		tya				tya 								; then MSB
.1c69	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1c6c	60		rts				rts
.1c6d					PushIntegerA:
.1c6d	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.1c6f	90 07		bcc $1c78			bcc 	_PIWriteA
.1c71	48		pha				pha
.1c72	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.1c74	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1c77	68		pla				pla
.1c78					_PIWriteA:
.1c78	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1c7b	60		rts				rts
.1c7c					PushFloatCommand:
.1c7c	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.1c7e	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1c81	b5 68		lda $68,x			lda 	NSExponent,x 				; and the data
.1c83	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1c86	b5 38		lda $38,x			lda 	NSMantissa0,x
.1c88	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1c8b	b5 44		lda $44,x			lda 	NSMantissa1,x
.1c8d	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1c90	b5 50		lda $50,x			lda 	NSMantissa2,x
.1c92	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1c95	b5 2c		lda $2c,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.1c97	29 80		and #$80			and 	#$80
.1c99	15 5c		ora $5c,x			ora 	NSMantissa3,x
.1c9b	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1c9e	60		rts				rts
.1c9f					CreateVariableRecord:
.1c9f	48		pha				pha
.1ca0	ad 5e 05	lda $055e			lda 	freeVariableMemory 		; push current free address on stack.
.1ca3	48		pha				pha
.1ca4	ad 5f 05	lda $055f			lda 	freeVariableMemory+1
.1ca7	48		pha				pha
.1ca8	ad 5c 05	lda $055c			lda 	variableListEnd  		; copy end of list to zTemp0
.1cab	85 26		sta $26				sta 	zTemp0
.1cad	ad 5d 05	lda $055d			lda 	variableListEnd+1
.1cb0	85 27		sta $27				sta 	zTemp0+1
.1cb2	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.1cb4	92 26		sta ($26)			sta 	(zTemp0)
.1cb6	98		tya				tya
.1cb7	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.1cb9	91 26		sta ($26),y			sta 	(zTemp0),y
.1cbb	88		dey				dey
.1cbc	8a		txa				txa
.1cbd	91 26		sta ($26),y			sta 	(zTemp0),y
.1cbf	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.1cc1	ad 5e 05	lda $055e			lda 	freeVariableMemory
.1cc4	91 26		sta ($26),y			sta 	(zTemp0),y
.1cc6	c8		iny				iny
.1cc7	ad 5f 05	lda $055f			lda 	freeVariableMemory+1
.1cca	91 26		sta ($26),y			sta 	(zTemp0),y
.1ccc	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.1cce	a9 00		lda #$00			lda 	#0
.1cd0	91 26		sta ($26),y			sta 	(zTemp0),y
.1cd2	18		clc				clc
.1cd3	b2 26		lda ($26)			lda 	(zTemp0) 				; add offset to variableListEnd
.1cd5	6d 5c 05	adc $055c			adc  	variableListEnd
.1cd8	8d 5c 05	sta $055c			sta 	variableListEnd
.1cdb	90 03		bcc $1ce0			bcc 	_CVNoCarry2
.1cdd	ee 5d 05	inc $055d			inc 	variableListEnd+1
.1ce0					_CVNoCarry2:
.1ce0	7a		ply				ply
.1ce1	fa		plx				plx
.1ce2	68		pla				pla
.1ce3	60		rts				rts
.1ce4					SetVariableRecordToCodePosition:
.1ce4	48		pha				pha
.1ce5	5a		phy				phy
.1ce6	a0 03		ldy #$03			ldy 	#3
.1ce8	a5 25		lda $25				lda 	objPtr+1
.1cea	91 26		sta ($26),y			sta 	(zTemp0),y
.1cec	c8		iny				iny
.1ced	a5 24		lda $24				lda 	objPtr
.1cef	91 26		sta ($26),y			sta 	(zTemp0),y
.1cf1	7a		ply				ply
.1cf2	68		pla				pla
.1cf3	60		rts				rts
.1cf4					AllocateBytesForType:
.1cf4	48		pha				pha
.1cf5	da		phx				phx
.1cf6	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.1cf8	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.1cfa	c9 00		cmp #$00			cmp 	#NSSIFloat
.1cfc	d0 02		bne $1d00			bne 	_CVNotFloat
.1cfe	a2 06		ldx #$06			ldx 	#6
.1d00					_CVNotFloat:
.1d00	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.1d01	18		clc				clc
.1d02	6d 5e 05	adc $055e			adc 	freeVariableMemory
.1d05	8d 5e 05	sta $055e			sta 	freeVariableMemory
.1d08	90 03		bcc $1d0d			bcc 	_CVNoCarry1
.1d0a	ee 5f 05	inc $055f			inc 	freeVariableMemory+1
.1d0d					_CVNoCarry1:
.1d0d	fa		plx				plx
.1d0e	68		pla				pla
.1d0f	60		rts				rts
.1d10					CommandDATA:
.1d10	20 7c 1b	jsr $1b7c			jsr 	BufferClear 				; copy it to the buffer
.1d13	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace
.1d16					_CTDataLoop:
.1d16	20 9f 24	jsr $249f			jsr 	LookNext 					; reached EOL
.1d19	f0 08		beq $1d23			beq 	_CTDataDone
.1d1b	20 80 1b	jsr $1b80			jsr 	BufferWrite 				; write and consume
.1d1e	20 b0 24	jsr $24b0			jsr 	GetNext
.1d21	80 f3		bra $1d16			bra 	_CTDataLoop
.1d23					_CTDataDone:
.1d23	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.1d25	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1d28	20 8c 1b	jsr $1b8c			jsr 	BufferOutput
.1d2b	60		rts				rts
.1d2c					CommandDEF:
.1d2c	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.1d2e	20 6d 1c	jsr $1c6d			jsr 	PushIntegerA
.1d31	20 c0 25	jsr $25c0			jsr 	CompileGotoEOL 				; compile skip over DEF
.1d34	a9 a5		lda #$a5			lda 	#C64_FN
.1d36	20 ad 1b	jsr $1bad			jsr 	CheckNextA
.1d39	20 bb 24	jsr $24bb			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.1d3c	20 20 25	jsr $2520			jsr 	ExtractVariableName
.1d3f	8a		txa				txa
.1d40	10 51		bpl $1d93			bpl 	_CDError
.1d42	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.1d43	29 7f		and #$7f			and 	#$7F
.1d45	aa		tax				tax
.1d46	98		tya				tya
.1d47	09 80		ora #$80			ora 	#$80
.1d49	a8		tay				tay
.1d4a	20 15 1f	jsr $1f15			jsr 	FindVariable				; does it already exist ?
.1d4d	b0 44		bcs $1d93			bcs 	_CDError 					; if so, that's an error.
.1d4f	20 9f 1c	jsr $1c9f			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.1d52	20 e4 1c	jsr $1ce4			jsr 	SetVariableRecordToCodePosition
.1d55	20 bb 24	jsr $24bb			jsr 	GetNextNonSpace
.1d58	20 fc 27	jsr $27fc			jsr 	GetReferenceTerm 			; get var ref, not array
.1d5b	c9 00		cmp #$00			cmp 	#0
.1d5d	30 34		bmi $1d93			bmi 	_CDError
.1d5f	8d 54 05	sta $0554			sta 	defType 					; save type
.1d62	8e 55 05	stx $0555			stx 	defVariable 				; save var ref
.1d65	8c 56 05	sty $0556			sty 	defVariable+1
.1d68	29 40		and #$40			and 	#NSSString 					; only numbers.
.1d6a	d0 27		bne $1d93			bne 	_CDError
.1d6c	20 a7 1b	jsr $1ba7			jsr 	CheckNextRParen 			; check )
.1d6f	a9 b2		lda #$b2			lda 	#C64_EQUAL
.1d71	20 ad 1b	jsr $1bad			jsr 	CheckNextA 					; check =
.1d74	18		clc				clc 								; if this is DEF FNxx(A), read A
.1d75	20 96 1d	jsr $1d96			jsr 	CDReadWriteVariable
.1d78	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1d7a	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1d7d	38		sec				sec
.1d7e	20 96 1d	jsr $1d96			jsr 	CDReadWriteVariable 		; A is now updated
.1d81	20 5b 1e	jsr $1e5b			jsr 	CompileExpressionAt0 		; the actual body of the function.
.1d84	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.1d86	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1d89	38		sec				sec
.1d8a	20 96 1d	jsr $1d96			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.1d8d	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.1d8f	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1d92	60		rts				rts
.1d93					_CDError:
.1d93	4c 30 10	jmp $1030		jmp	ErrorV_syntax
.1d96					CDReadWriteVariable:
.1d96	ac 56 05	ldy $0556			ldy 	defVariable+1 				; set up YX
.1d99	ae 55 05	ldx $0555			ldx 	defVariable
.1d9c	ad 54 05	lda $0554			lda 	defType
.1d9f	20 ae 27	jsr $27ae			jsr 	GetSetVariable
.1da2	60		rts				rts
.0554					defType:
>0554							.fill 	1
.0555					defVariable:
>0555							.fill 	2
.1da3					CommandDIM:
.1da3	20 bb 24	jsr $24bb			jsr 	GetNextNonSpace 			; get the first non space character
.1da6	20 20 25	jsr $2520			jsr 	ExtractVariableName 		; variable name to XY
.1da9	da		phx				phx 								; save name with type bits.
.1daa	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.1dac	10 37		bpl $1de5			bpl 	_CDError
.1dae	20 15 1f	jsr $1f15			jsr 	FindVariable	 			; see if already exist
.1db1	b0 35		bcs $1de8			bcs 	_CDRedefine 				; it still exists.
.1db3	20 9f 1c	jsr $1c9f			jsr 	CreateVariableRecord 		; create the basic variable
.1db6	20 f4 1c	jsr $1cf4			jsr 	AllocateBytesForType 		; allocate memory for it
.1db9	68		pla				pla 								; restore type bits
.1dba	5a		phy				phy 								; save the address of the basic storage
.1dbb	da		phx				phx
.1dbc	48		pha				pha
.1dbd	20 eb 1d	jsr $1deb			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.1dc0	68		pla				pla
.1dc1	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.1dc3	20 6d 1c	jsr $1c6d			jsr 	PushIntegerA 				; push that type data out.
.1dc6	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.1dc8	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1dcb	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.1dcd	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1dd0	fa		plx				plx 								; restore address
.1dd1	7a		ply				ply
.1dd2	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.1dd4	38		sec				sec
.1dd5	20 ae 27	jsr $27ae			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.1dd8	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; , follows ?
.1ddb	c9 2c		cmp #$2c			cmp 	#","
.1ddd	d0 05		bne $1de4			bne 	_CDExit
.1ddf	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume comma
.1de2	80 bf		bra $1da3			bra 	CommandDIM 					; do another DIM
.1de4					_CDExit:
.1de4	60		rts				rts
.1de5					_CDError:
.1de5	4c 30 10	jmp $1030		jmp	ErrorV_syntax
.1de8					_CDRedefine:
.1de8	4c f8 10	jmp $10f8		jmp	ErrorV_redefine
.1deb					OutputIndexGroup:
.1deb	9c 57 05	stz $0557			stz 	IndexCount 					; count of number of indices.
.1dee					_OIGNext:
.1dee	20 5b 1e	jsr $1e5b			jsr 	CompileExpressionAt0 		; get a dimension
.1df1	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1df3	c9 00		cmp #$00			cmp 	#NSSIFloat
.1df5	d0 19		bne $1e10			bne 	_OIGType
.1df7	ee 57 05	inc $0557			inc 	IndexCount 					; bump the counter.
.1dfa	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; does a , follow ?
.1dfd	c9 2c		cmp #$2c			cmp 	#","
.1dff	d0 05		bne $1e06			bne 	_OIGCheckEnd
.1e01	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume comma
.1e04	80 e8		bra $1dee			bra 	_OIGNext 					; get next dimension
.1e06					_OIGCheckEnd:
.1e06	20 a7 1b	jsr $1ba7			jsr 	CheckNextRParen 			; check and consume )
.1e09	ad 57 05	lda $0557			lda 	IndexCount
.1e0c	20 6d 1c	jsr $1c6d			jsr 	PushIntegerA 				; compile the dimension count.
.1e0f	60		rts				rts
.1e10					_OIGType:
.1e10	4c 40 10	jmp $1040		jmp	ErrorV_type
.0557					IndexCount:
>0557							.fill 	1
.1e13					CompilerErrorHandler:
.1e13	68		pla				pla
.1e14	7a		ply				ply
.1e15	85 26		sta $26				sta 	zTemp0
.1e17	84 27		sty $27				sty 	zTemp0+1
.1e19	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.1e1b	a0 01		ldy #$01			ldy 	#1
.1e1d					_EHDisplayMsg:
.1e1d	b1 26		lda ($26),y			lda 	(zTemp0),y
.1e1f	20 52 1b	jsr $1b52			jsr 	PrintCharacter
.1e22	c8		iny				iny
.1e23	b1 26		lda ($26),y			lda 	(zTemp0),y
.1e25	d0 f6		bne $1e1d			bne 	_EHDisplayMsg
.1e27	a9 20		lda #$20			lda 	#32
.1e29	20 52 1b	jsr $1b52			jsr 	PrintCharacter
.1e2c	a9 40		lda #$40			lda 	#64
.1e2e	20 52 1b	jsr $1b52			jsr 	PrintCharacter
.1e31	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.1e33	20 78 17	jsr $1778			jsr 	FloatSetByte
.1e36	20 3e 1b	jsr $1b3e			jsr 	GetLineNumber
.1e39	95 38		sta $38,x			sta 	NSMantissa0,x
.1e3b	98		tya				tya
.1e3c	95 44		sta $44,x			sta 	NSMantissa1,x
.1e3e	20 5e 16	jsr $165e			jsr 	FloatToString
.1e41	a0 00		ldy #$00			ldy 	#0 							; display that string.
.1e43	a2 00		ldx #$00			ldx 	#0
.1e45					_EHDisplayLine:
.1e45	b9 29 04	lda $0429,y			lda 	decimalBuffer,y
.1e48	20 52 1b	jsr $1b52			jsr 	PrintCharacter
.1e4b	c8		iny				iny
.1e4c	b9 29 04	lda $0429,y			lda 	decimalBuffer,y
.1e4f	d0 f4		bne $1e45			bne 	_EHDisplayLine
.1e51	a9 0d		lda #$0d			lda 	#13
.1e53	20 52 1b	jsr $1b52			jsr 	PrintCharacter
.1e56	80 fe		bra $1e56	_EHHalt:bra 	_EHHalt
.1e58	4c 52 1c	jmp $1c52			jmp 	ExitCompiler
.1e5b					CompileExpressionAt0:
.1e5b	a9 00		lda #$00			lda 	#0
.1e5d					CompileExpressionAtA:
.1e5d	48		pha				pha  								; save level
.1e5e	20 67 28	jsr $2867			jsr 	CompileTerm 				; compile a term.
.1e61	fa		plx				plx 								; get level back into X
.1e62					_ECALoop:
.1e62	48		pha				pha 								; save type on stack.
.1e63	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; get the next character
.1e66	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.1e68	90 04		bcc $1e6e			bcc 	_ECAExit
.1e6a	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.1e6c	90 02		bcc $1e70			bcc 	_ECAHaveToken
.1e6e					_ECAExit:
.1e6e	68		pla				pla 								; throw type off stack
.1e6f	60		rts				rts
.1e70					_ECAHaveToken:
.1e70	86 26		stx $26				stx 	zTemp0 						; save current precedence in zTemp0
.1e72	aa		tax				tax 								; X contains the operator token
.1e73	bd 5e 1e	lda $1e5e,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.1e76	c5 26		cmp $26				cmp 	zTemp0 						; if < then exit
.1e78	90 f4		bcc $1e6e			bcc 	_ECAExit
.1e7a	85 27		sta $27				sta 	zTemp0+1 					; save the precedence of the operator.
.1e7c	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume the token.
.1e7f	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.1e81	f0 11		beq $1e94			beq 	_ECAGreaterCheck
.1e83	e0 b3		cpx #$b3			cpx 	#C64_LESS
.1e85	d0 1a		bne $1ea1			bne 	_ECAHaveFullToken
.1e87	20 9f 24	jsr $249f			jsr 	LookNext 					; checks for < (<= or <>)
.1e8a	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.1e8c	f0 0e		beq $1e9c			beq	 	_ECAToNotEqual
.1e8e	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.1e90	d0 0f		bne $1ea1			bne 	_ECAHaveFullToken
.1e92	80 07		bra $1e9b			bra 	_ECAAddEqual
.1e94					_ECAGreaterCheck:
.1e94	20 9f 24	jsr $249f			jsr 	LookNext
.1e97	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.1e99	d0 06		bne $1ea1			bne 	_ECAHaveFullToken
.1e9b					_ECAAddEqual:
.1e9b	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.1e9c					_ECAToNotEqual:
.1e9c	e8		inx				inx
.1e9d	e8		inx				inx
.1e9e	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume the = or > in >= <= <>
.1ea1					_ECAHaveFullToken:
.1ea1	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.1ea3	d0 0a		bne $1eaf			bne 	_ECANotConcat
.1ea5	68		pla				pla 								; get type back
.1ea6	48		pha				pha
.1ea7	29 40		and #$40			and 	#NSSTypeMask
.1ea9	c9 40		cmp #$40			cmp 	#NSSString
.1eab	d0 02		bne $1eaf			bne 	_ECANotConcat
.1ead	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1eaf					_ECANotConcat:
.1eaf	da		phx				phx 								; save operator on the stack
.1eb0	a6 26		ldx $26				ldx 	zTemp0 						; push current precedence on the stack
.1eb2	da		phx				phx
.1eb3	a5 27		lda $27				lda 	zTemp0+1 					; get precedence of operator
.1eb5	1a		inc a				inc 	a
.1eb6	20 5d 1e	jsr $1e5d			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.1eb9	85 26		sta $26				sta 	zTemp0 						; save type in zTemp0
.1ebb	fa		plx				plx 								; restore current precedence in X
.1ebc	68		pla				pla 								; restore operator
.1ebd	85 27		sta $27				sta 	zTemp0+1 					; save it in zTemp0+1.
.1ebf	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.1ec1	90 17		bcc $1eda			bcc 	_ECANotCompare
.1ec3	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.1ec5	b0 13		bcs $1eda			bcs 	_ECANotCompare
.1ec7	7a		ply				ply 								; get type into Y
.1ec8	5a		phy				phy
.1ec9	48		pha				pha 								; save operator
.1eca	98		tya				tya 								; get type
.1ecb	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.1ecd	29 40		and #$40			and 	#NSSTypeMask
.1ecf	c9 40		cmp #$40			cmp 	#NSSString
.1ed1	f0 02		beq $1ed5			beq 	_ECANotString
.1ed3	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.1ed5					_ECANotString:
.1ed5	98		tya				tya									; output token Y
.1ed6	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1ed9	68		pla				pla 								; restore operator.
.1eda					_ECANotCompare:
.1eda	18		clc				clc 								; convert to P-Code and compile.
.1edb	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.1edd	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.1ee0	68		pla				pla 								; type of current result
.1ee1	45 26		eor $26				eor 	zTemp0 						; check compatible with r-expr type
.1ee3	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.1ee5	d0 19		bne $1f00			bne		_ECAType
.1ee7	a5 26		lda $26				lda 	zTemp0 						; get type back
.1ee9	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.1eeb	d0 18		bne $1f05			bne 	_ECAGoLoop
.1eed	a5 27		lda $27				lda 	zTemp0+1 					; check operator is + or comparator
.1eef	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.1ef1	f0 10		beq $1f03			beq 	_ECAOkayString 				; (this is post conversion)
.1ef3	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.1ef5	90 09		bcc $1f00			bcc 	_ECAType
.1ef7	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.1ef9	b0 05		bcs $1f00			bcs 	_ECAType
.1efb	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.1efd	4c 62 1e	jmp $1e62			jmp 	_ECALoop
.1f00					_ECAType:
.1f00	4c 40 10	jmp $1040		jmp	ErrorV_type
.1f03					_ECAOkayString:
.1f03	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.1f05					_ECAGoLoop:
.1f05	4c 62 1e	jmp $1e62			jmp 	_ECALoop
.1f08					PrecedenceTable:
>1f08	03						.byte 	3 					; '+'
>1f09	03						.byte 	3 					; '-'
>1f0a	04						.byte 	4 					; '*'
>1f0b	04						.byte 	4 					; '/'
>1f0c	05						.byte 	5 					; '^'
>1f0d	01						.byte 	1 					; 'and'
>1f0e	00						.byte 	0 					; 'or'
>1f0f	02						.byte 	2 					; '>'
>1f10	02						.byte 	2 					; '='
>1f11	02						.byte 	2 					; '<'
>1f12	02						.byte 	2 					; '>='
>1f13	02						.byte 	2 					; '<='
>1f14	02						.byte 	2 					; '<>'
.1f15					FindVariable:
.1f15	86 28		stx $28				stx 	zTemp1 						; save name.
.1f17	84 29		sty $29				sty 	zTemp1+1
.1f19					_IVCheckSpecial:
.1f19	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.1f1b	d0 18		bne $1f35			bne 	_IVStandard
.1f1d	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.1f1f	f0 0c		beq $1f2d			beq 	_IVTIFloat
.1f21	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.1f23	d0 10		bne $1f35			bne 	_IVStandard
.1f25	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.1f27	a2 01		ldx #$01			ldx 	#$01
.1f29	a9 40		lda #$40			lda 	#NSSString
.1f2b	38		sec				sec
.1f2c	60		rts				rts
.1f2d					_IVTIFloat:
.1f2d	a0 80		ldy #$80			ldy 	#$80
.1f2f	a2 00		ldx #$00			ldx 	#$00
.1f31	a9 00		lda #$00			lda 	#0
.1f33	38		sec				sec
.1f34	60		rts				rts
.1f35					_IVStandard:
.1f35	ad 52 05	lda $0552			lda 	compilerStartHigh			; start scanning from here.
.1f38	85 27		sta $27				sta 	zTemp0+1
.1f3a	64 26		stz $26				stz 	zTemp0
.1f3c					_IVCheckLoop:
.1f3c	b2 26		lda ($26)			lda 	(zTemp0) 					; finished ?
.1f3e	f0 2b		beq $1f6b			beq  	_IVNotFound 				; if so, return with CC.
.1f40	a0 01		ldy #$01			ldy 	#1 							; match ?
.1f42	b1 26		lda ($26),y			lda 	(zTemp0),y
.1f44	c5 28		cmp $28				cmp 	zTemp1
.1f46	d0 07		bne $1f4f			bne	 	_IVNext
.1f48	c8		iny				iny
.1f49	b1 26		lda ($26),y			lda 	(zTemp0),y
.1f4b	c5 29		cmp $29				cmp 	zTemp1+1
.1f4d	f0 0d		beq $1f5c			beq 	_IVFound
.1f4f					_IVNext:
.1f4f	18		clc				clc
.1f50	a5 26		lda $26				lda 	zTemp0
.1f52	72 26		adc ($26)			adc 	(zTemp0)
.1f54	85 26		sta $26				sta 	zTemp0
.1f56	90 e4		bcc $1f3c			bcc 	_IVCheckLoop
.1f58	e6 27		inc $27				inc 	zTemp0+1
.1f5a	80 e0		bra $1f3c			bra 	_IVCheckLoop
.1f5c					_IVFound:
.1f5c	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.1f5e	b1 26		lda ($26),y			lda 	(zTemp0),y
.1f60	aa		tax				tax
.1f61	c8		iny				iny
.1f62	b1 26		lda ($26),y			lda 	(zTemp0),y
.1f64	48		pha				pha
.1f65	c8		iny				iny
.1f66	b1 26		lda ($26),y			lda 	(zTemp0),y
.1f68	7a		ply				ply
.1f69	38		sec				sec
.1f6a	60		rts				rts
.1f6b					_IVNotFound:
.1f6b	a6 28		ldx $28				ldx 	zTemp1 						; get variable name back
.1f6d	a4 29		ldy $29				ldy 	zTemp1+1
.1f6f	18		clc				clc
.1f70	60		rts				rts
.1f71					FixBranches:
.1f71	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.1f73	20 57 1c	jsr $1c57			jsr 	CallAPIHandler
.1f76					_FBLoop:
.1f76	b2 24		lda ($24)			lda 	(objPtr) 					; get the next one.
.1f78	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.1f7a	f0 16		beq $1f92			beq 	_FBFixGotoGosub
.1f7c	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.1f7e	f0 12		beq $1f92			beq 	_FBFixGotoGosub
.1f80	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.1f82	f0 0e		beq $1f92			beq 	_FBFixGotoGosub
.1f84	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1f86	f0 0a		beq $1f92			beq 	_FBFixGotoGosub
.1f88	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.1f8a	f0 3b		beq $1fc7			beq 	_FBFixVarSpace
.1f8c					_FBNext:
.1f8c	20 45 11	jsr $1145			jsr 	MoveObjectForward 			; move forward in object code.
.1f8f	90 e5		bcc $1f76			bcc 	_FBLoop 					; not finished
.1f91					_FBExit:
.1f91	60		rts				rts
.1f92					_FBFixGotoGosub:
.1f92	a0 01		ldy #$01			ldy 	#1							; line number in YA
.1f94	b1 24		lda ($24),y			lda 	(objPtr),y
.1f96	48		pha				pha
.1f97	c8		iny				iny
.1f98	b1 24		lda ($24),y			lda 	(objPtr),y
.1f9a	a8		tay				tay
.1f9b	68		pla				pla
.1f9c	20 52 26	jsr $2652			jsr 	STRFindLine			 		; find where it is YA
.1f9f	90 08		bcc $1fa9			bcc 	_FBFFound 					; not found, so must be >
.1fa1	48		pha				pha
.1fa2	b2 24		lda ($24)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.1fa4	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.1fa6	d0 0f		bne $1fb7			bne 	_FBFFail
.1fa8	68		pla				pla
.1fa9					_FBFFound:
.1fa9	20 a2 26	jsr $26a2			jsr 	STRMakeOffset 				; make it an offset from X:YA
.1fac	5a		phy				phy	 								; patch the GOTO/GOSUB
.1fad	a0 01		ldy #$01			ldy 	#1
.1faf	91 24		sta ($24),y			sta 	(objPtr),y
.1fb1	c8		iny				iny
.1fb2	68		pla				pla
.1fb3	91 24		sta ($24),y			sta 	(objPtr),y
.1fb5	80 d5		bra $1f8c			bra 	_FBNext
.1fb7					_FBFFail:
.1fb7	a0 02		ldy #$02			ldy 	#2
.1fb9	b1 24		lda ($24),y			lda 	(objPtr),y
.1fbb	8d 4b 04	sta $044b			sta 	currentLineNumber
.1fbe	c8		iny				iny
.1fbf	b1 24		lda ($24),y			lda 	(objPtr),y
.1fc1	8d 4c 04	sta $044c			sta 	currentLineNumber+1
.1fc4	4c 73 10	jmp $1073		jmp	ErrorV_line
.1fc7					_FBFixVarSpace:
.1fc7	a0 01		ldy #$01			ldy 	#1
.1fc9	ad 5e 05	lda $055e			lda 	freeVariableMemory
.1fcc	91 24		sta ($24),y			sta 	(objPtr),y
.1fce	c8		iny				iny
.1fcf	ad 5f 05	lda $055f			lda 	freeVariableMemory+1
.1fd2	91 24		sta ($24),y			sta 	(objPtr),y
.1fd4	80 b6		bra $1f8c			bra 	_FBNext
.1fd6					CommandFOR:
.1fd6	20 bb 24	jsr $24bb			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.1fd9	20 d1 24	jsr $24d1			jsr 	CharIsAlpha 				; if not alpha , error
.1fdc	90 59		bcc $2037			bcc 	_CFFail
.1fde	20 fc 27	jsr $27fc			jsr 	GetReferenceTerm 			; figure out the reference.
.1fe1	48		pha				pha 								; save type
.1fe2	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.1fe4	c9 00		cmp #$00			cmp 	#NSSIFloat
.1fe6	d0 4f		bne $2037			bne 	_CFFail
.1fe8	5a		phy				phy 								; save reference on the stack
.1fe9	da		phx				phx
.1fea	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.1fec	20 ad 1b	jsr $1bad			jsr 	CheckNextA
.1fef	20 5b 1e	jsr $1e5b			jsr 	CompileExpressionAt0 		; initial value
.1ff2	fa		plx				plx 								; get reference back.
.1ff3	7a		ply				ply
.1ff4	5a		phy				phy
.1ff5	da		phx				phx
.1ff6	38		sec				sec 								; set initial value.
.1ff7	20 ae 27	jsr $27ae			jsr 	GetSetVariable
.1ffa	fa		plx				plx
.1ffb	7a		ply				ply
.1ffc	68		pla				pla
.1ffd	29 20		and #$20			and 	#NSSIInt16
.1fff	f0 04		beq $2005			beq 	_CFNotInt16
.2001	98		tya				tya
.2002	09 80		ora #$80			ora 	#$80
.2004	a8		tay				tay
.2005					_CFNotInt16:
.2005	8a		txa				txa 								; reference in YA
.2006	20 5a 1c	jsr $1c5a			jsr 	PushIntegerYA
.2009	a9 a4		lda #$a4			lda 	#C64_TO
.200b	20 ad 1b	jsr $1bad			jsr 	CheckNextA
.200e	20 5b 1e	jsr $1e5b			jsr 	CompileExpressionAt0 		; terminal value
.2011	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2013	c9 00		cmp #$00			cmp 	#NSSIFloat
.2015	d0 20		bne $2037			bne 	_CFFail
.2017	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; followed by STEP
.201a	c9 a9		cmp #$a9			cmp 	#C64_STEP
.201c	d0 0e		bne $202c			bne 	_CFNoStep
.201e	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume it.
.2021	20 5b 1e	jsr $1e5b			jsr 	CompileExpressionAt0 		; terminal value
.2024	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2026	c9 00		cmp #$00			cmp 	#NSSIFloat
.2028	d0 0d		bne $2037			bne 	_CFFail
.202a	80 05		bra $2031			bra 	_CFParametersDone
.202c					_CFNoStep:
.202c	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.202e	20 6d 1c	jsr $1c6d			jsr 	PushIntegerA
.2031					_CFParametersDone:
.2031	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2033	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2036	60		rts				rts
.2037					_CFFail:
.2037	4c 30 10	jmp $1030		jmp	ErrorV_syntax
.203a					FNCompile:
.203a	20 bb 24	jsr $24bb			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.203d	20 20 25	jsr $2520			jsr 	ExtractVariableName
.2040	e0 00		cpx #$00			cpx 	#0
.2042	10 32		bpl $2076			bpl 	_FNError
.2044	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2045	29 7f		and #$7f			and 	#$7F
.2047	aa		tax				tax
.2048	98		tya				tya
.2049	09 80		ora #$80			ora 	#$80
.204b	a8		tay				tay
.204c	20 15 1f	jsr $1f15			jsr 	FindVariable				; does it already exist ?
.204f	90 25		bcc $2076			bcc 	_FNError 					; no.
.2051	20 a2 26	jsr $26a2			jsr 	STRMakeOffset 				; convert to a relative address.
.2054	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2056	d0 01		bne $2059			bne 	_FNNoBorrow
.2058	88		dey				dey
.2059					_FNNoBorrow:
.2059	3a		dec a				dec 	a
.205a	5a		phy				phy 								; save location of routine on stack.
.205b	48		pha				pha
.205c	da		phx				phx
.205d	20 5b 1e	jsr $1e5b			jsr 	CompileExpressionAt0
.2060	20 a7 1b	jsr $1ba7			jsr 	CheckNextRParen
.2063	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.2065	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2068	68		pla				pla
.2069	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.206c	68		pla				pla
.206d	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2070	68		pla				pla
.2071	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2074	18		clc				clc
.2075	60		rts				rts
.2076					_FNError:
.2076	4c 23 10	jmp $1023		jmp	ErrorV_value
.2079					CommandTables:
>2079	07 cb 00 03 7e 25 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2080	07 89 00 03 85 25 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2087	07 8d 00 03 78 25 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>208e	07 88 00 03 f4 25 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2095	07 85 00 03 d4 25 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>209c	07 84 00 04 e8 25 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>20a3	07 99 00 03 29 27 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>20aa	07 98 00 04 29 27 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>20b1	07 8f 00 03 34 28 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>20b8	07 81 00 03 d6 1f 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>20bf	07 82 00 03 ac 26 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>20c6	07 a1 00 03 f1 24 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>20cd	07 83 00 03 10 1d 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>20d4	07 87 00 03 72 27 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>20db	07 86 00 03 a3 1d 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>20e2	07 96 00 03 2c 1d 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>20e9	07 8b 00 e3 a1 25 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>20f0	08 92 00 ea e3 00 29 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>20f8	09 91 00 e1 a9 03 d8 26			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>2100	06
>2101	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>2108	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>210f	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>2115	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>211c	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>2123	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>212a	07 9d 00 e3 26 29 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>2131	0a 9f 00 ea e3 39 29 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>2139	c6 06
>213b	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>2141	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>2148	0a ce 92 e3 6e 24 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>2150	ad 06
>2152	0a ce 8d e3 6e 24 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>215a	ae 06
>215c	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>2162	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>216a	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>2171	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>2178	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>2180	06
>2181	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>2189	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>2191	9a 06
>2193	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>219b	9b 06
>219d	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>21a5	9c 06
>21a7	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>21af	06
>21b0	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>21b7	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>21bf	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>21c7	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>21cf	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>21d7	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>21df	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>21e7	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>21ef	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>21f7	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>21ff	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>2207	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>220e	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>2216	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>221e	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>2226	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>222e	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>2236	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>223e	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>2246	00						.byte 	0
.2247					UnaryTables:
>2247	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>224e	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>2256	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>225d	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>2264	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>226b	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>2272	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>227a	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>2281	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>2289	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>2291	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>2299	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>22a1	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>22a9	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>22b1	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>22b8	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>22bf	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>22c6	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>22cd	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>22d4	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>22db	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>22e3	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>22eb	0b ca 00 8f ae 03 6e 24			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>22f3	91 bd 07
>22f6	07 a8 00 03 8d 24 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>22fd	07 a5 00 03 3a 20 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>2304	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>230b	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>2312	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>231a	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>2322	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>2329	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>2330	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>2337	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>233f	06
>2340	00						.byte 	0
.2341					GeneratorProcess:
.2341	86 26		stx $26				stx 	zTemp0 						; save generation pointer in zTemp0
.2343	84 27		sty $27				sty 	zTemp0+1
.2345	85 28		sta $28				sta 	zTemp1 						; first match token
.2347	64 29		stz $29				stz 	zTemp1+1
.2349	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.234b	d0 05		bne $2352			bne 	_GPNotShifted
.234d	20 b0 24	jsr $24b0			jsr 	GetNext 					; get the shifted token
.2350	85 29		sta $29				sta 	zTemp1+1 					; match CE xx
.2352					_GPNotShifted:
.2352					_GPSearch:
.2352	b2 26		lda ($26)			lda 	(zTemp0) 					; reached end ?
.2354	18		clc				clc
.2355	f0 2f		beq $2386			beq 	_GPExit
.2357	a0 01		ldy #$01			ldy 	#1 							; tokens match
.2359	b1 26		lda ($26),y			lda 	(zTemp0),y
.235b	c5 28		cmp $28				cmp 	zTemp1
.235d	d0 09		bne $2368			bne 	_GPNext
.235f	a5 29		lda $29				lda 	zTemp1+1 					; 2nd token ?
.2361	f0 12		beq $2375			beq 	_GPFound
.2363	c8		iny				iny 								; check match.
.2364	d1 26		cmp ($26),y			cmp 	(zTemp0),y
.2366	f0 0d		beq $2375			beq 	_GPFound
.2368					_GPNext:
.2368	18		clc				clc 								; follow to next
.2369	a5 26		lda $26				lda 	zTemp0
.236b	72 26		adc ($26)			adc 	(zTemp0)
.236d	85 26		sta $26				sta 	zTemp0
.236f	90 e1		bcc $2352			bcc 	_GPSearch
.2371	e6 27		inc $27				inc 	zTemp0+1
.2373	80 dd		bra $2352			bra 	_GPSearch
.2375					_GPFound:
.2375	18		clc				clc 								; skip to action bytes
.2376	a5 26		lda $26				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.2378	69 03		adc #$03			adc 	#3
.237a	85 26		sta $26				sta 	zTemp0
.237c	90 02		bcc $2380			bcc 	_GPNoCarry
.237e	e6 27		inc $27				inc 	zTemp0+1
.2380					_GPNoCarry:
.2380					_GPLoop:
.2380	20 87 23	jsr $2387			jsr 	GeneratorExecute 			; execute one command
.2383	90 fb		bcc $2380			bcc 	_GPLoop 					; go back if not completed.
.2385	38		sec				sec 								; return with CS.
.2386					_GPExit:
.2386	60		rts				rts
.2387					GeneratorExecute:
.2387	20 33 24	jsr $2433			jsr 	_GEFetchZTemp0 				; get next.
.238a	48		pha				pha 								; split into 2 nibbles
.238b	4a		lsr a				lsr 	a
.238c	4a		lsr a				lsr 	a
.238d	4a		lsr a				lsr		a
.238e	4a		lsr a				lsr 	a
.238f	20 99 23	jsr $2399			jsr 	_GEExecuteNibble 			; MSB first
.2392	68		pla				pla
.2393	b0 03		bcs $2398			bcs 	_GEHaveCompleted
.2395	20 99 23	jsr $2399			jsr 	_GEExecuteNibble 			; LSB second
.2398					_GEHaveCompleted:
.2398	60		rts				rts
.2399					_GEExecuteNibble:
.2399	29 0f		and #$0f			and 	#$0F
.239b	0a		asl a				asl 	a
.239c	aa		tax				tax
.239d	7c a0 23	jmp ($23a0,x)			jmp 	(_GEExecuteVectors,x)
.23a0					_GEExecuteVectors:
>23a0	c0 23						.word 	_GEXNop 					; 0  (no operation)
>23a2	c8 23						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>23a4	c2 23						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>23a6	16 24						.word 	_GEXExecute 				; 3  (run arbitrary code)
>23a8	09 24						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>23aa	c0 23						.word 	_GEXNop 					; 5
>23ac	d0 23						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>23ae	d4 23						.word 	_GEXExitString 				; 7  exit return string type
>23b0	d8 23						.word 	_GEXLParam 					; 8  check ( follows
>23b2	dc 23						.word 	_GEXRParam 					; 9  check ) follows
>23b4	e0 23						.word 	_GEXComma					; A  check , follows
>23b6	c0 23						.word 	_GEXNop 					; B
>23b8	c0 23						.word 	_GEXNop 					; C
>23ba	c0 23						.word 	_GEXNop 					; D
>23bc	f0 23						.word 	_GEXNumber 					; E  compile get any number
>23be	fb 23						.word 	_GEXString 					; F  compile get any string
.23c0					_GEXNop:
.23c0	18		clc				clc
.23c1	60		rts				rts
.23c2					_GEXToken2:
.23c2	20 33 24	jsr $2433			jsr 	_GEFetchZTemp0
.23c5	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.23c8					_GEXToken1:
.23c8	20 33 24	jsr $2433			jsr 	_GEFetchZTemp0
.23cb	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.23ce	18		clc				clc
.23cf	60		rts				rts
.23d0					_GEXExitNumber:
.23d0	a9 00		lda #$00			lda 	#NSSIFloat
.23d2	38		sec				sec
.23d3	60		rts				rts
.23d4					_GEXExitString:
.23d4	a9 40		lda #$40			lda 	#NSSString
.23d6	38		sec				sec
.23d7	60		rts				rts
.23d8					_GEXLParam:
.23d8	a9 28		lda #$28			lda 	#"("
.23da	80 06		bra $23e2			bra 	_GEXCheck
.23dc					_GEXRParam:
.23dc	a9 29		lda #$29			lda 	#")"
.23de	80 02		bra $23e2			bra 	_GEXCheck
.23e0					_GEXComma:
.23e0	a9 2c		lda #$2c			lda 	#","
.23e2					_GEXCheck:
.23e2	85 2a		sta $2a				sta 	zTemp2 						; save match
.23e4	20 bb 24	jsr $24bb			jsr 	GetNextNonSpace 			; get next skipping spaces
.23e7	c5 2a		cmp $2a				cmp 	zTemp2 						; check matches.
.23e9	d0 02		bne $23ed			bne 	_GEXSyntax
.23eb	18		clc				clc
.23ec	60		rts				rts
.23ed					_GEXSyntax:
.23ed	4c 30 10	jmp $1030		jmp	ErrorV_syntax
.23f0					_GEXNumber:
.23f0	20 3c 24	jsr $243c			jsr 	GEXCompileExpression 		; compile expression
.23f3	29 40		and #$40			and 	#NSSTypeMask
.23f5	c9 00		cmp #$00			cmp  	#NSSIFloat
.23f7	d0 0d		bne $2406			bne 	_GEXType
.23f9	18		clc				clc
.23fa	60		rts				rts
.23fb					_GEXString:
.23fb	20 3c 24	jsr $243c			jsr 	GEXCompileExpression 		; compile expression
.23fe	29 40		and #$40			and 	#NSSTypeMask
.2400	c9 40		cmp #$40			cmp  	#NSSString
.2402	d0 02		bne $2406			bne 	_GEXType
.2404	18		clc				clc
.2405	60		rts				rts
.2406					_GEXType:
.2406	4c 40 10	jmp $1040		jmp	ErrorV_type
.2409					_GEXChannelExec:
.2409	20 4c 24	jsr $244c			jsr 	ChannelPrefix 				; set up default
.240c	20 16 24	jsr $2416			jsr 	_GEXExecute
.240f	08		php				php
.2410	20 67 24	jsr $2467			jsr 	ChannelPostfix 				; replace default.
.2413	28		plp				plp
.2414	60		rts				rts
>2415	db						.byte 	$DB 						; causes a break in the emulator
.2416					_GEXExecute:
.2416	20 33 24	jsr $2433			jsr 	_GEFetchZTemp0 				; get vector
.2419	85 2a		sta $2a				sta 	zTemp2
.241b	20 33 24	jsr $2433			jsr 	_GEFetchZTemp0
.241e	85 2b		sta $2b				sta 	zTemp2+1
.2420	a6 26		ldx $26				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.2422	da		phx				phx
.2423	a6 27		ldx $27				ldx 	zTemp0+1
.2425	da		phx				phx
.2426	20 30 24	jsr $2430			jsr 	_GECallZTemp2 				; execute code
.2429	fa		plx				plx 								; recover generation exec
.242a	86 27		stx $27				stx 	zTemp0+1
.242c	fa		plx				plx
.242d	86 26		stx $26				stx 	zTemp0
.242f	60		rts				rts
.2430					_GECallZTemp2:
.2430	6c 2a 00	jmp ($002a)			jmp 	(zTemp2)
.2433					_GEFetchZTemp0:
.2433	b2 26		lda ($26)			lda 	(zTemp0)
.2435	e6 26		inc $26				inc 	zTemp0
.2437	d0 02		bne $243b			bne 	_GEFZ0Skip
.2439	e6 27		inc $27				inc 	zTemp0+1
.243b					_GEFZ0Skip:
.243b	60		rts				rts
.243c					GEXCompileExpression:
.243c	a6 26		ldx $26				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.243e	da		phx				phx
.243f	a6 27		ldx $27				ldx 	zTemp0+1
.2441	da		phx				phx
.2442	20 5b 1e	jsr $1e5b			jsr 	CompileExpressionAt0 		; compile expression.
.2445	fa		plx				plx 								; recover generation exec
.2446	86 27		stx $27				stx 	zTemp0+1
.2448	fa		plx				plx
.2449	86 26		stx $26				stx 	zTemp0
.244b	60		rts				rts
.244c					ChannelPrefix:
.244c	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.244e	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2451	20 3c 24	jsr $243c			jsr 	GEXCompileExpression 		; channel #
.2454	29 40		and #$40			and 	#NSSTypeMask
.2456	c9 00		cmp #$00			cmp 	#NSSIFloat
.2458	d0 0a		bne $2464			bne 	_CPXType
.245a	20 a3 1b	jsr $1ba3			jsr 	CheckNextComma 				; check , follows.
.245d	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.245f	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2462	18		clc				clc
.2463	60		rts				rts
.2464					_CPXType:
.2464	4c 40 10	jmp $1040		jmp	ErrorV_type
.2467					ChannelPostfix:
.2467	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.2469	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.246c	18		clc				clc
.246d	60		rts				rts
.246e					OptionalParameterCompile:
.246e	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; what follows.
.2471	c9 2c		cmp #$2c			cmp 	#","
.2473	d0 0e		bne $2483			bne 	_MidDefault
.2475	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume ,
.2478	20 5b 1e	jsr $1e5b			jsr 	CompileExpressionAt0
.247b	29 40		and #$40			and 	#NSSTypeMask
.247d	c9 00		cmp #$00			cmp 	#NSSIFloat
.247f	d0 09		bne $248a			bne 	MidFailType
.2481	80 05		bra $2488			bra 	_MidComplete
.2483					_MidDefault:
.2483	a9 ff		lda #$ff			lda 	#255 						; default of 255
.2485	20 6d 1c	jsr $1c6d			jsr 	PushIntegerA
.2488					_MidComplete:
.2488	18		clc				clc
.2489	60		rts				rts
.248a					MidFailType:
.248a	4c 40 10	jmp $1040		jmp	ErrorV_type
.248d					NotUnaryCompile:
.248d	ad 10 1f	lda $1f10			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.2490	20 5d 1e	jsr $1e5d			jsr 	CompileExpressionAtA 		; evaluate at that level
.2493	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.2495	c9 00		cmp #$00			cmp 	#NSSIFloat
.2497	d0 f1		bne $248a			bne 	MidFailType
.2499	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.249b	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.249e	60		rts				rts
.249f					LookNext:
.249f	b2 74		lda ($74)			lda 	(srcPtr)
.24a1	60		rts				rts
.24a2					LookNextNonSpace:
.24a2	b2 74		lda ($74)			lda 	(srcPtr)
.24a4	c9 20		cmp #$20			cmp		#' '
.24a6	f0 03		beq $24ab			beq 	_LNNSkip
.24a8	c9 00		cmp #$00			cmp 	#0
.24aa	60		rts				rts
.24ab					_LNNSkip:
.24ab	20 b0 24	jsr $24b0			jsr 	GetNext
.24ae	80 f2		bra $24a2			bra 	LookNextNonSpace
.24b0					GetNext:
.24b0	b2 74		lda ($74)			lda 	(srcPtr) 					; get next
.24b2	e6 74		inc $74				inc 	srcPtr
.24b4	d0 02		bne $24b8			bne 	_GNSkip
.24b6	e6 75		inc $75				inc 	srcPtr+1
.24b8					_GNSkip:
.24b8	c9 00		cmp #$00			cmp 	#0
.24ba	60		rts				rts
.24bb					GetNextNonSpace:
.24bb	20 b0 24	jsr $24b0			jsr 	GetNext
.24be	c9 20		cmp #$20			cmp 	#' '
.24c0	f0 f9		beq $24bb			beq 	GetNextNonSpace
.24c2	c9 00		cmp #$00			cmp 	#0
.24c4	60		rts				rts
.24c5					CharIsDigit:
.24c5	c9 30		cmp #$30			cmp 	#"0"
.24c7	90 06		bcc $24cf			bcc 	CCFalse
.24c9	c9 3a		cmp #$3a			cmp 	#"9"+1
.24cb	b0 02		bcs $24cf			bcs 	CCFalse
.24cd					CCTrue:
.24cd	38		sec				sec
.24ce	60		rts				rts
.24cf					CCFalse:
.24cf	18		clc				clc
.24d0	60		rts				rts
.24d1					CharIsAlpha:
.24d1	c9 41		cmp #$41			cmp 	#"A"
.24d3	90 fa		bcc $24cf			bcc 	CCFalse
.24d5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.24d7	b0 f6		bcs $24cf			bcs 	CCFalse
.24d9	80 f2		bra $24cd			bra 	CCTrue
.24db					ConvertHexStyle:
.24db	38		sec				sec
.24dc	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.24de	90 ef		bcc $24cf			bcc 	CCFalse
.24e0	c9 0a		cmp #$0a			cmp 	#9+1
.24e2	90 e9		bcc $24cd			bcc 	CCTrue
.24e4	38		sec				sec 								; shift into hex space A=>0 Z=>25
.24e5	e9 11		sbc #$11			sbc 	#"A"-"0"
.24e7	90 e6		bcc $24cf			bcc 	CCFalse
.24e9	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.24eb	b0 e2		bcs $24cf			bcs 	CCFalse
.24ed	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.24ef	80 dc		bra $24cd			bra 	CCTrue
.24f1					CommandGET:
.24f1	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; # follows ?
.24f4	c9 23		cmp #$23			cmp 	#"#"
.24f6	d0 0d		bne $2505			bne 	CommandGetBody
.24f8	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume #
.24fb	20 4c 24	jsr $244c			jsr 	ChannelPrefix 				; do it as GET#
.24fe	20 05 25	jsr $2505			jsr 	CommandGetBody
.2501	20 67 24	jsr $2467			jsr 	ChannelPostfix
.2504	60		rts				rts
.2505					CommandGetBody:
.2505	20 bb 24	jsr $24bb			jsr 	GetNextNonSpace 			; get the first character
.2508	20 fc 27	jsr $27fc			jsr 	GetReferenceTerm 			; identify variable to assign to
.250b	48		pha				pha
.250c	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.250e	c9 40		cmp #$40			cmp 	#NSSString
.2510	d0 0b		bne $251d			bne 	_CGType
.2512	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.2514	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2517	38		sec				sec
.2518	68		pla				pla
.2519	20 ae 27	jsr $27ae			jsr		GetSetVariable
.251c	60		rts				rts
.251d					_CGType:
.251d	4c 40 10	jmp $1040		jmp	ErrorV_type
.2520					ExtractVariableName:
.2520	20 d1 24	jsr $24d1			jsr 	CharIsAlpha
.2523	90 50		bcc $2575			bcc 	_IVSyntax
.2525	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.2527	85 28		sta $28				sta 	zTemp1 						; we'll build it in zTemp1
.2529	64 29		stz $29				stz 	zTemp1+1
.252b	20 9f 24	jsr $249f			jsr 	LookNext 					; is there a second character ?
.252e	20 d1 24	jsr $24d1			jsr 	CharIsAlpha  				; must be alphanumeric
.2531	b0 05		bcs $2538			bcs 	_IVHasSecond
.2533	20 c5 24	jsr $24c5			jsr 	CharIsDigit
.2536	90 07		bcc $253f			bcc 	_IVCheckType
.2538					_IVHasSecond:
.2538	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.253a	85 29		sta $29				sta 	zTemp1+1
.253c					_IVGetNextCheck:
.253c	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume it
.253f					_IVCheckType:
.253f	20 9f 24	jsr $249f			jsr 	LookNext					; check if string follows.
.2542	20 d1 24	jsr $24d1			jsr 	CharIsAlpha
.2545	b0 f5		bcs $253c			bcs 	_IVGetNextCheck
.2547	20 c5 24	jsr $24c5			jsr 	CharIsDigit
.254a	b0 f0		bcs $253c			bcs 	_IVGetNextCheck
.254c	a2 40		ldx #$40			ldx 	#NSSString
.254e	c9 24		cmp #$24			cmp 	#"$"
.2550	f0 06		beq $2558			beq 	_IVHasType
.2552	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.2554	c9 25		cmp #$25			cmp 	#"%"
.2556	d0 08		bne $2560			bne 	_IVCheckArray
.2558					_IVHasType:
.2558	8a		txa				txa 								; Or X into zTemp1
.2559	05 28		ora $28				ora 	zTemp1
.255b	85 28		sta $28				sta 	zTemp1
.255d	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume it
.2560					_IVCheckArray:
.2560	20 9f 24	jsr $249f			jsr 	LookNext 					; check if array follows
.2563	c9 28		cmp #$28			cmp 	#"("
.2565	d0 09		bne $2570			bne 	_IVNotArray
.2567	a5 28		lda $28				lda 	zTemp1 						; set array bit
.2569	09 80		ora #$80			ora 	#NSSArray
.256b	85 28		sta $28				sta 	zTemp1
.256d	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume it
.2570					_IVNotArray:
.2570	a6 28		ldx $28				ldx 	zTemp1
.2572	a4 29		ldy $29				ldy 	zTemp1+1
.2574	60		rts				rts
.2575					_IVSyntax:
.2575	4c 30 10	jmp $1030		jmp	ErrorV_syntax
.2578					CommandGOSUB:
.2578	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.257a	20 8b 25	jsr $258b			jsr 	CompileBranchCommand
.257d	60		rts				rts
.257e					CommandGOAlt:
.257e	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.2580	20 ad 1b	jsr $1bad			jsr 	CheckNextA
.2583	80 00		bra $2585			bra 	CommandGOTO
.2585					CommandGOTO:
.2585	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.2587	20 8b 25	jsr $258b			jsr 	CompileBranchCommand
.258a	60		rts				rts
.258b					CompileBranchCommand:
.258b	20 45 1b	jsr $1b45			jsr 	WriteCodeByte 				; write the command out.
.258e	20 bb 24	jsr $24bb			jsr 	GetNextNonSpace
.2591	20 04 27	jsr $2704			jsr 	ParseConstant 				; get constant into YA
.2594	90 08		bcc $259e			bcc 	_CBCSyntax
.2596	20 45 1b	jsr $1b45			jsr 	WriteCodeByte				; and compile the actual line number
.2599	98		tya				tya
.259a	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.259d	60		rts				rts
.259e					_CBCSyntax:
.259e	4c 30 10	jmp $1030		jmp	ErrorV_syntax
.25a1					CommandIF:
.25a1	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; what follows the tests ?
.25a4	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.25a6	f0 0f		beq $25b7			beq 	_CIGoto
.25a8	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.25aa	20 ad 1b	jsr $1bad			jsr 	CheckNextA
.25ad	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; THEN <number>
.25b0	20 c5 24	jsr $24c5			jsr 	CharIsDigit
.25b3	b0 05		bcs $25ba			bcs 	_CIGoto2
.25b5	80 09		bra $25c0			bra 	CompileGotoEOL
.25b7					_CIGoto:
.25b7	20 b0 24	jsr $24b0			jsr 	GetNext
.25ba					_CIGoto2:
.25ba	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.25bc	20 8b 25	jsr $258b			jsr 	CompileBranchCommand
.25bf	60		rts				rts
.25c0					CompileGotoEOL:
.25c0	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.25c2	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.25c5	20 3e 1b	jsr $1b3e			jsr 	GetLineNumber 				; Get the current line number => YA
.25c8	1a		inc a				inc 	a 							; and branch to +1
.25c9	d0 01		bne $25cc			bne 	_CGENoCarry
.25cb	c8		iny				iny
.25cc					_CGENoCarry:
.25cc	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.25cf	98		tya				tya
.25d0	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.25d3	60		rts				rts
.25d4					CommandINPUT:
.25d4	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; check for "
.25d7	c9 22		cmp #$22			cmp 	#'"'
.25d9	d0 0d		bne $25e8			bne 	CommandINPUTStream
.25db	20 5b 1e	jsr $1e5b			jsr 	CompileExpressionAt0
.25de	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.25e0	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.25e3	a9 2c		lda #$2c			lda 	#","
.25e5	20 a3 1b	jsr $1ba3			jsr 	CheckNextComma
.25e8					CommandINPUTStream:
.25e8	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.25ea	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.25ed	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.25ef	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.25f1	4c 76 27	jmp $2776			jmp 	CommandReadInputCommon
.25f4					CommandLET:
.25f4	20 bb 24	jsr $24bb			jsr 	GetNextNonSpace 			; get the first character
.25f7					CommandLETHaveFirst:
.25f7	20 fc 27	jsr $27fc			jsr 	GetReferenceTerm 			; identify variable to assign to
.25fa	da		phx				phx 								; save target on the stack.
.25fb	5a		phy				phy
.25fc	48		pha				pha
.25fd	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.25ff	20 ad 1b	jsr $1bad			jsr 	CheckNextA
.2602	20 5b 1e	jsr $1e5b			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.2605	85 26		sta $26				sta 	zTemp0 						; save type returned
.2607	68		pla				pla 								; get type of assignment
.2608	48		pha				pha
.2609	45 26		eor $26				eor 	zTemp0 						; compare using EOR
.260b	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.260d	d0 17		bne $2626			bne 	_CLType
.260f	68		pla				pla 								; restore and compile save code
.2610	7a		ply				ply
.2611	fa		plx				plx
.2612	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.2614	f0 05		beq $261b			beq 	_CLTIString
.2616	38		sec				sec
.2617	20 ae 27	jsr $27ae			jsr		GetSetVariable
.261a	60		rts				rts
.261b					_CLTIString:
.261b	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.261d	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2620	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.2622	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2625	60		rts				rts
.2626					_CLType:
.2626	4c 40 10	jmp $1040		jmp	ErrorV_type
.2629					STRMarkLine:
.2629	48		pha				pha
.262a	38		sec				sec 								; allocate 4 bytes (line #,address)
.262b	ad 5a 05	lda $055a			lda 	lineNumberTable 			; and copy to zTemp0
.262e	e9 04		sbc #$04			sbc 	#4
.2630	8d 5a 05	sta $055a			sta 	lineNumberTable
.2633	85 26		sta $26				sta 	zTemp0
.2635	ad 5b 05	lda $055b			lda 	lineNumberTable+1
.2638	e9 00		sbc #$00			sbc 	#0
.263a	8d 5b 05	sta $055b			sta 	lineNumberTable+1
.263d	85 27		sta $27				sta 	zTemp0+1
.263f	68		pla				pla
.2640	92 26		sta ($26)			sta 	(zTemp0) 					; line # save it in +0,+1
.2642	98		tya				tya
.2643	a0 01		ldy #$01			ldy 	#1
.2645	91 26		sta ($26),y			sta 	(zTemp0),y
.2647	a5 24		lda $24				lda 	objPtr 						; save current address in +2,+3
.2649	c8		iny				iny
.264a	91 26		sta ($26),y			sta 	(zTemp0),y
.264c	a5 25		lda $25				lda 	objPtr+1
.264e	c8		iny				iny
.264f	91 26		sta ($26),y			sta 	(zTemp0),y
.2651	60		rts				rts
.2652					STRFindLine:
.2652	85 26		sta $26				sta 	zTemp0 						; zTemp0 line number being searched
.2654	84 27		sty $27				sty 	zTemp0+1
.2656	ad 53 05	lda $0553			lda 	compilerEndHigh 			; work backwards through table
.2659	85 29		sta $29				sta 	zTemp1+1
.265b	64 28		stz $28				stz 	zTemp1
.265d					_STRSearch:
.265d	20 94 26	jsr $2694			jsr 	_STRPrevLine 				; look at previous record.
.2660	a0 01		ldy #$01			ldy 	#1
.2662	b2 28		lda ($28)			lda 	(zTemp1) 					; check table line # >= target
.2664	c5 26		cmp $26				cmp 	zTemp0
.2666	b1 28		lda ($28),y			lda 	(zTemp1),y
.2668	e5 27		sbc $27				sbc 	zTemp0+1
.266a	b0 0b		bcs $2677			bcs 	_STRFound 					; >=
.266c					_STRNext:
.266c	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.266e	b1 28		lda ($28),y			lda 	(zTemp1),y
.2670	c9 ff		cmp #$ff			cmp 	#$FF
.2672	d0 e9		bne $265d			bne 	_STRSearch
.2674	4c 8a 10	jmp $108a		jmp	ErrorV_internal
.2677					_STRFound:
.2677	b2 28		lda ($28)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.2679	45 26		eor $26				eor 	zTemp0
.267b	d0 06		bne $2683			bne 	_STRDifferent
.267d	b2 28		lda ($28)			lda 	(zTemp1)
.267f	45 26		eor $26				eor 	zTemp0
.2681	f0 02		beq $2685			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.2683					_STRDifferent:
.2683	a9 ff		lda #$ff			lda 	#$FF
.2685					_STROut:
.2685	18		clc				clc  								; set carry if different, e.g. > rather than >=
.2686	69 ff		adc #$ff			adc 	#255
.2688	08		php				php
.2689	c8		iny				iny 								; address into YA
.268a	b1 28		lda ($28),y			lda 	(zTemp1),y
.268c	48		pha				pha
.268d	c8		iny				iny
.268e	b1 28		lda ($28),y			lda 	(zTemp1),y
.2690	a8		tay				tay
.2691	68		pla				pla
.2692	28		plp				plp
.2693	60		rts				rts
.2694					_STRPrevLine:
.2694	38		sec				sec 								; move backwards one entry.
.2695	a5 28		lda $28				lda 	zTemp1
.2697	e9 04		sbc #$04			sbc 	#4
.2699	85 28		sta $28				sta 	zTemp1
.269b	a5 29		lda $29				lda 	zTemp1+1
.269d	e9 00		sbc #$00			sbc 	#0
.269f	85 29		sta $29				sta 	zTemp1+1
.26a1	60		rts				rts
.26a2					STRMakeOffset:
.26a2	18		clc				clc 								; borrow 1
.26a3	e5 24		sbc $24				sbc 	objPtr
.26a5	48		pha				pha
.26a6	98		tya				tya
.26a7	e5 25		sbc $25				sbc 	objPtr+1
.26a9	a8		tay				tay
.26aa	68		pla				pla
.26ab	60		rts				rts
.26ac					CommandNEXT:
.26ac	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.26af	20 d1 24	jsr $24d1			jsr 	CharIsAlpha 				; if not alpha , error
.26b2	90 0c		bcc $26c0			bcc 	_CNNoReferenceGiven
.26b4	20 b0 24	jsr $24b0			jsr 	GetNext
.26b7	20 fc 27	jsr $27fc			jsr 	GetReferenceTerm 			; figure out the reference.
.26ba	8a		txa				txa 								; reference in YA
.26bb	20 5a 1c	jsr $1c5a			jsr 	PushIntegerYA 				; write it out.
.26be	80 06		bra $26c6			bra 	_CNParametersDone
.26c0					_CNNoReferenceGiven:
.26c0	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.26c2	a8		tay				tay
.26c3	20 5a 1c	jsr $1c5a			jsr 	PushIntegerYA 				; write it out.
.26c6					_CNParametersDone:
.26c6	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.26c8	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.26cb	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; look for ,
.26ce	c9 2c		cmp #$2c			cmp 	#","
.26d0	d0 05		bne $26d7			bne 	_CNExit
.26d2	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume ,
.26d5	80 d5		bra $26ac			bra 	CommandNEXT 				; and go round.
.26d7					_CNExit:
.26d7	60		rts				rts
.26d8					CommandON:
.26d8	20 bb 24	jsr $24bb			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.26db	48		pha				pha 								; save on stack
.26dc	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.26de	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.26e0	f0 09		beq $26eb			beq 	_COCreateLoop
.26e2	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.26e4	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.26e6	f0 03		beq $26eb			beq 	_COCreateLoop
.26e8	4c 30 10	jmp $1030		jmp	ErrorV_syntax
.26eb					_COCreateLoop:
.26eb	8a		txa				txa 								; compile a goto/gosub somewhere
.26ec	da		phx				phx
.26ed	20 8b 25	jsr $258b			jsr 	CompileBranchCommand
.26f0	fa		plx				plx
.26f1	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace			; ',' follows
.26f4	c9 2c		cmp #$2c			cmp 	#","
.26f6	d0 0a		bne $2702			bne 	_COComplete 				; if so, more line numbers
.26f8	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.26fa	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.26fd	20 b0 24	jsr $24b0			jsr 	GetNext
.2700	80 e9		bra $26eb			bra 	_COCreateLoop
.2702					_COComplete:
.2702	68		pla				pla 								; throw GOTO/GOSUB
.2703	60		rts				rts
.2704					ParseConstant:
.2704	a2 00		ldx #$00			ldx 	#0
.2706	20 56 15	jsr $1556			jsr 	FloatEncodeStart 			; send first
.2709					_ParseLoop:
.2709	20 9f 24	jsr $249f			jsr 	LookNext 					; send subsequent
.270c	20 59 15	jsr $1559			jsr 	FloatEncodeContinue
.270f	90 05		bcc $2716			bcc 	_ParseDone
.2711	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume it
.2714	80 f3		bra $2709			bra 	_ParseLoop
.2716					_ParseDone:
.2716	b5 2c		lda $2c,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.2718	29 80		and #$80			and 	#$80
.271a	15 68		ora $68,x			ora 	NSExponent,x 				; 16 bit int check
.271c	15 50		ora $50,x			ora 	NSMantissa2,x
.271e	15 5c		ora $5c,x			ora 	NSMantissa3,x
.2720	18		clc				clc
.2721	d0 05		bne $2728			bne 	_ParseExit 					; exit with CC if need float to compile
.2723	b5 38		lda $38,x			lda 	NSMantissa0,x 				; read into YA.
.2725	b4 44		ldy $44,x			ldy		NSMantissa1,x
.2727	38		sec				sec
.2728					_ParseExit:
.2728	60		rts				rts
.2729					CommandPRINT:
.2729	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace			; what follows ?
.272c	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.272e	f0 1f		beq $274f			beq 	_CPCheckEnd
.2730	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.2732	f0 16		beq $274a			beq 	_CPTabCheckEnd
.2734	20 66 27	jsr $2766			jsr 	_CPAtEnd 					; check for : and EOL
.2737	b0 22		bcs $275b			bcs 	_CPExitCR 					; exit with CR
.2739	20 5b 1e	jsr $1e5b			jsr 	CompileExpressionAt0 		; so it is something to print
.273c	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.273e	29 40		and #$40			and 	#NSSString 					; if string
.2740	d0 02		bne $2744			bne 	_CPOut
.2742	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.2744					_CPOut:
.2744	8a		txa				txa 								; print that thing
.2745	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2748	80 df		bra $2729			bra 	CommandPRINT 				; and loop round/
.274a					_CPTabCheckEnd:
.274a	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.274c	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.274f					_CPCheckEnd:
.274f	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume it.
.2752	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; what follows ?
.2755	20 66 27	jsr $2766			jsr 	_CPAtEnd 					; reached end
.2758	90 cf		bcc $2729			bcc 	CommandPRINT 				; no, loop back
.275a	60		rts				rts
.275b					_CPExitCR:
.275b	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.275d	20 6d 1c	jsr $1c6d			jsr 	PushIntegerA
.2760	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.2762	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2765	60		rts				rts
.2766					_CPAtEnd:
.2766	c9 00		cmp #$00			cmp 	#0
.2768	f0 06		beq $2770			beq 	_CPIsEnd
.276a	c9 3a		cmp #$3a			cmp 	#":"
.276c	f0 02		beq $2770			beq 	_CPIsEnd
.276e	18		clc				clc
.276f	60		rts				rts
.2770					_CPIsEnd:
.2770	38		sec				sec
.2771	60		rts				rts
.2772					CommandREAD:
.2772	a2 b2		ldx #$b2			ldx 	#PCD_READ
.2774	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.2776					CommandReadInputCommon:
.2776	8e 58 05	stx $0558			stx 	numberPCode
.2779	8c 59 05	sty $0559			sty 	stringPCode
.277c					_CRLoop:
.277c	20 bb 24	jsr $24bb			jsr 	GetNextNonSpace 			; first char of identifier
.277f	20 d1 24	jsr $24d1			jsr 	CharIsAlpha 				; check A-Z
.2782	90 27		bcc $27ab			bcc 	_CRSyntax
.2784	20 fc 27	jsr $27fc			jsr 	GetReferenceTerm 			; get the variable.
.2787	48		pha				pha 								; save type.
.2788	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.278a	c9 40		cmp #$40			cmp 	#NSSString
.278c	f0 05		beq $2793			beq 	_CRString
.278e	ad 58 05	lda $0558			lda 	numberPCode 				; output read/input
.2791	80 03		bra $2796			bra 	_CRHaveType
.2793					_CRString:
.2793	ad 59 05	lda $0559			lda 	stringPCode					; output read$/input$
.2796					_CRHaveType:
.2796	20 45 1b	jsr $1b45			jsr 	WriteCodeByte 				; so we have one typed data item.
.2799	68		pla				pla 								; restore type
.279a	38		sec				sec  								; write update code.
.279b	20 ae 27	jsr $27ae			jsr 	GetSetVariable
.279e	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; , follows ?
.27a1	c9 2c		cmp #$2c			cmp 	#","
.27a3	d0 05		bne $27aa			bne 	_CRExit 					; if not, end of READ.
.27a5	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume comma
.27a8	80 d2		bra $277c			bra 	_CRLoop 					; keep going
.27aa					_CRExit:
.27aa	60		rts				rts
.27ab					_CRSyntax:
.27ab	4c 30 10	jmp $1030		jmp	ErrorV_syntax
.0558					numberPCode:
>0558							.fill 	1
.0559					stringPCode:
>0559							.fill 	1
.27ae					GetSetVariable:
.27ae	08		php				php 								; save direction on stack
.27af	c0 00		cpy #$00			cpy 	#$00
.27b1	30 21		bmi $27d4			bmi 	_GSVReadWriteSpecial
.27b3	c9 00		cmp #$00			cmp 	#$00
.27b5	30 33		bmi $27ea			bmi 	_GSVArray
.27b7	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.27b9	4a		lsr a				lsr 	a 							; divide by 2
.27ba	09 40		ora #$40			ora 	#64 						; and set bit 6.
.27bc	28		plp				plp
.27bd	90 02		bcc $27c1			bcc 	_GSVNotWrite
.27bf	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.27c1					_GSVNotWrite:
.27c1	85 26		sta $26				sta 	zTemp0
.27c3	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.27c4	4a		lsr a				lsr 	a
.27c5	a8		tay				tay
.27c6	8a		txa				txa
.27c7	6a		ror a				ror 	a
.27c8	aa		tax				tax
.27c9	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.27ca	05 26		ora $26				ora 	zTemp0 						; which is the first byte of the opcode
.27cc	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.27cf	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.27d0	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.27d3	60		rts				rts
.27d4					_GSVReadWriteSpecial:
.27d4	28		plp				plp
.27d5	b0 10		bcs $27e7			bcs 	_GSVSyntax
.27d7	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.27d9	f0 06		beq $27e1			beq 	_GSVRWString
.27db	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.27dd	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.27e0	60		rts				rts
.27e1					_GSVRWString:
.27e1	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.27e3	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.27e6	60		rts				rts
.27e7					_GSVSyntax:
.27e7	4c 30 10	jmp $1030		jmp	ErrorV_syntax
.27ea					_GSVArray:
.27ea	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.27ec	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.27ed	4a		lsr a				lsr 	a
.27ee	4a		lsr a				lsr 	a
.27ef	4a		lsr a				lsr 	a
.27f0	4a		lsr a				lsr 	a
.27f1	28		plp				plp 								; if writing array then set bit 2.
.27f2	90 02		bcc $27f6			bcc 	_GSVANotWrite
.27f4	09 04		ora #$04			ora 	#4
.27f6					_GSVANotWrite:
.27f6	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.27f8	20 45 1b	jsr $1b45			jsr 	WriteCodeByte 				; and write it out
.27fb	60		rts				rts
.27fc					GetReferenceTerm:
.27fc	20 20 25	jsr $2520			jsr 	ExtractVariableName 		; get name & type info
.27ff	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.2801	30 10		bmi $2813			bmi 	_GRTArray
.2803	da		phx				phx 								; save type on stack
.2804	20 15 1f	jsr $1f15			jsr 	FindVariable 				; find it
.2807	b0 06		bcs $280f			bcs 	_GRTNoCreate 				; create if required.
.2809	20 9f 1c	jsr $1c9f			jsr 	CreateVariableRecord 		; create a variable.
.280c	20 f4 1c	jsr $1cf4			jsr 	AllocateBytesForType 		; allocate memory for it
.280f					_GRTNoCreate:
.280f	68		pla				pla 								; get type back, strip out type information.
.2810	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2812	60		rts				rts
.2813					_GRTArray:
.2813	da		phx				phx 								; save type information
.2814	20 15 1f	jsr $1f15			jsr 	FindVariable 				; read its data, the base address in YX
.2817	90 18		bcc $2831			bcc 	_GRTUndeclared 				; undeclared array.
.2819	da		phx				phx 								; save base address
.281a	5a		phy				phy
.281b	20 eb 1d	jsr $1deb			jsr 	OutputIndexGroup 			; create an index group and generate them
.281e	7a		ply				ply 								; get the array base address into YX
.281f	fa		plx				plx
.2820	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2822	18		clc				clc
.2823	20 ae 27	jsr $27ae			jsr 	GetSetVariable 				; load the address of the array structure.
.2826	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.2828	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.282b	68		pla				pla 								; and the type data into A
.282c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.282e	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.2830	60		rts				rts
.2831					_GRTUndeclared:
.2831	4c e7 10	jmp $10e7		jmp	ErrorV_undeclared
.2834					CommandREM:
.2834	20 9f 24	jsr $249f			jsr 	LookNext
.2837	f0 05		beq $283e			beq 	_CRExit
.2839	20 b0 24	jsr $24b0			jsr 	GetNext
.283c	80 f6		bra $2834			bra 	CommandREM
.283e					_CRExit:
.283e	60		rts				rts
.283f					STRReset:
.283f	ad 52 05	lda $0552			lda	 	compilerStartHigh 			; set up the two table pointers
.2842	8d 5d 05	sta $055d			sta 	variableListEnd+1
.2845	9c 5c 05	stz $055c			stz 	variableListEnd
.2848	ad 53 05	lda $0553			lda 	compilerEndHigh
.284b	8d 5b 05	sta $055b			sta 	lineNumberTable+1
.284e	9c 5a 05	stz $055a			stz 	lineNumberTable
.2851	ad 5c 05	lda $055c			lda 	variableListEnd
.2854	85 27		sta $27				sta 	zTemp0+1
.2856	64 26		stz $26				stz 	zTemp0
.2858	a9 00		lda #$00			lda 	#0
.285a	92 26		sta ($26)			sta 	(zTemp0)
.285c	a9 00		lda #$00			lda 	#((0) & $FF)
.285e	8d 5e 05	sta $055e			sta 	0+freeVariableMemory
.2861	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.2863	8d 5f 05	sta $055f			sta 	1+freeVariableMemory
.2866	60		rts				rts
.055a					lineNumberTable:
>055a							.fill 	2
.055c					variableListEnd:
>055c							.fill 	2
.055e					freeVariableMemory:
>055e							.fill 	2
.2867					CompileTerm:
.2867	20 bb 24	jsr $24bb			jsr 	GetNextNonSpace 			; get first non space character.
.286a	30 72		bmi $28de			bmi 	_CTUnaryFunctions
.286c	20 c5 24	jsr $24c5			jsr 	CharIsDigit 				; found a number
.286f	b0 3a		bcs $28ab			bcs 	_CTDigit
.2871	c9 2e		cmp #$2e			cmp 	#"."
.2873	f0 36		beq $28ab			beq 	_CTDigit
.2875	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.2877	f0 43		beq $28bc			beq 	_CTString
.2879	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.287b	f0 28		beq $28a5			beq 	_CTOtherBase
.287d	c9 24		cmp #$24			cmp 	#"$"
.287f	f0 24		beq $28a5			beq 	_CTOtherBase
.2881	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.2883	f0 17		beq $289c			beq 	_CTBrackets
.2885	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.2887	90 10		bcc $2899			bcc 	_CTSyntax
.2889	c9 5b		cmp #$5b			cmp 	#"Z"+1
.288b	b0 0c		bcs $2899			bcs 	_CTSyntax
.288d	20 fc 27	jsr $27fc			jsr 	GetReferenceTerm 			; figure out what it is.
.2890	48		pha				pha 								; save type on stack
.2891	18		clc				clc 								; read it
.2892	20 ae 27	jsr $27ae			jsr 	GetSetVariable
.2895	68		pla				pla
.2896	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.2898	60		rts				rts
.2899					_CTSyntax:
.2899	4c 30 10	jmp $1030		jmp	ErrorV_syntax
.289c					_CTBrackets:
.289c	20 5b 1e	jsr $1e5b			jsr 	CompileExpressionAt0
.289f	48		pha				pha
.28a0	20 a7 1b	jsr $1ba7			jsr 	CheckNextRParen
.28a3	68		pla				pla
.28a4	60		rts				rts
.28a5					_CTOtherBase:
.28a5	20 f3 1a	jsr $1af3			jsr 	InlineNonDecimal 			; non decimal constant handler
.28a8	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.28aa	60		rts				rts
.28ab					_CTDigit:
.28ab	20 04 27	jsr $2704			jsr 	ParseConstant 				; parse out an number, first is in A already.
.28ae	90 06		bcc $28b6			bcc	 	_CTFloat 					; have a float or long int.
.28b0	20 5a 1c	jsr $1c5a			jsr 	PushIntegerYA 				; code to push on stack
.28b3	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.28b5	60		rts				rts
.28b6					_CTFloat:
.28b6	20 7c 1c	jsr $1c7c			jsr 	PushFloatCommand			; code to push float
.28b9	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.28bb	60		rts				rts
.28bc					_CTString:
.28bc	20 7c 1b	jsr $1b7c			jsr 	BufferClear 				; copy it to the buffer
.28bf					_CTStringLoop:
.28bf	20 9f 24	jsr $249f			jsr 	LookNext 					; reached EOL/EOS
.28c2	f0 d5		beq $2899			beq 	_CTSyntax
.28c4	c9 22		cmp #$22			cmp 	#'"'
.28c6	f0 08		beq $28d0			beq 	_CTStringDone
.28c8	20 80 1b	jsr $1b80			jsr 	BufferWrite 				; write and consume
.28cb	20 b0 24	jsr $24b0			jsr 	GetNext
.28ce	80 ef		bra $28bf			bra 	_CTStringLoop
.28d0					_CTStringDone:
.28d0	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume closing quote.
.28d3	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.28d5	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.28d8	20 8c 1b	jsr $1b8c			jsr 	BufferOutput
.28db	a9 40		lda #$40			lda 	#NSSString 					; string type
.28dd	60		rts				rts
.28de					_CTUnaryFunctions:
.28de	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.28e0	f0 0a		beq $28ec			beq 	_CTNegation
.28e2	a2 47		ldx #$47			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.28e4	a0 22		ldy #$22			ldy 	#UnaryTables >> 8
.28e6	20 41 23	jsr $2341			jsr 	GeneratorProcess
.28e9	90 ae		bcc $2899			bcc		_CTSyntax
.28eb	60		rts				rts
.28ec					_CTNegation:
.28ec	20 67 28	jsr $2867			jsr 	CompileTerm 				; compile a term.
.28ef	48		pha				pha
.28f0	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.28f2	c9 00		cmp #$00			cmp 	#NSSIFloat
.28f4	d0 07		bne $28fd			bne 	_CTType 					; error
.28f6	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.28f8	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.28fb	68		pla				pla 								; return original type.
.28fc	60		rts				rts
.28fd					_CTType:
.28fd	4c 40 10	jmp $1040		jmp	ErrorV_type
.2900					CommandWAIT:
.2900	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace
.2903	c9 2c		cmp #$2c			cmp 	#","
.2905	f0 10		beq $2917			beq 	_CWThirdParameter
.2907	a9 00		lda #$00			lda 	#0
.2909	20 6d 1c	jsr $1c6d			jsr 	PushIntegerA
.290c					_CWExit:
.290c	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.290e	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2911	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.2913	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2916	60		rts				rts
.2917					_CWThirdParameter:
.2917	20 b0 24	jsr $24b0			jsr 	GetNext
.291a	20 5d 1e	jsr $1e5d			jsr 	CompileExpressionAtA
.291d	29 40		and #$40			and 	#NSSTypeMask
.291f	c9 00		cmp #$00			cmp 	#NSSIFloat
.2921	f0 e9		beq $290c			beq 	_CWExit
.2923	4c 40 10	jmp $1040		jmp	ErrorV_type
.2926					CommandCMD:
.2926	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.2928	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.292b	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; followed by a , ?
.292e	c9 2c		cmp #$2c			cmp 	#","
.2930	d0 06		bne $2938			bne 	_CCMDExit
.2932	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume comma.
.2935	20 29 27	jsr $2729			jsr 	CommandPRINT 				; do the print code
.2938					_CCMDExit:
.2938	60		rts				rts
.2939					CommandOPEN:
.2939	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; followed by a , ?
.293c	c9 2c		cmp #$2c			cmp 	#","
.293e	d0 15		bne $2955			bne 	_COTwoDefaults
.2940	20 b0 24	jsr $24b0			jsr 	GetNext 					; consume comma
.2943	20 5b 1e	jsr $1e5b			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.2946	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.2948	f0 1e		beq $2968			beq 	_COThreeIntegers
.294a	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.294c	20 6d 1c	jsr $1c6d			jsr 	PushIntegerA
.294f	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2951	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2954	60		rts				rts
.2955					_COTwoDefaults:
.2955	a9 00		lda #$00			lda 	#0
.2957	20 6d 1c	jsr $1c6d			jsr 	PushIntegerA
.295a					_COCompileNullString:
.295a	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.295c	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.295f	a9 00		lda #$00			lda 	#0
.2961	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2964	20 45 1b	jsr $1b45			jsr 	WriteCodeByte
.2967	60		rts				rts
.2968					_COThreeIntegers:
.2968	20 a2 24	jsr $24a2			jsr 	LookNextNonSpace 			; is there a ,
.296b	c9 2c		cmp #$2c			cmp 	#","
.296d	d0 eb		bne $295a			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.296f	20 b0 24	jsr $24b0			jsr 	GetNext
.2972	20 5b 1e	jsr $1e5b			jsr 	CompileExpressionAt0 		; should be a filename
.2975	29 40		and #$40			and 	#NSSString
.2977	f0 01		beq $297a			beq 	_COType
.2979	60		rts				rts
.297a					_COType:
.297a	4c 40 10	jmp $1040		jmp	ErrorV_type

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0076					zsTemp:
>0076							.fill 	2
.0078					runtimeStackPtr:
>0078							.fill 	2
.0560					stringLowMemory:
>0560							.fill 	2
.0562					stringHighMemory:
>0562							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.297d					StartRuntime:
.297d	8d 64 05	sta $0564			sta 	runtimeHigh 				; save address of code.
.2980	85 23		sta $23				sta 	codePtr+1 					; set pointer to code.
.2982	64 22		stz $22				stz 	codePtr
.2984	8e 65 05	stx $0565			stx 	storeStartHigh 				; save from-to address.
.2987	8c 66 05	sty $0566			sty 	storeEndHigh
.298a	8e 67 05	stx $0567			stx 	variableStartPage
.298d	a0 2d		ldy #$2d			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.298f	a2 97		ldx #$97			ldx 	#RuntimeErrorHandler & $FF
.2991	20 09 10	jsr $1009			jsr 	SetErrorHandler
.2994	20 c6 2b	jsr $2bc6			jsr 	ClearMemory 				; clear memory.
.2997	20 a5 37	jsr $37a5			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.299a	20 a7 34	jsr $34a7		 	jsr		SetDefaultChannel			; set default input/output channel.
.299d	20 dd 36	jsr $36dd			jsr 	RestoreCode 				; which we now call
.29a0	a0 00		ldy #$00			ldy 	#0
.29a2					NextCommand:
.29a2	b1 22		lda ($22),y			lda 	(codePtr),y 				; get next
.29a4	30 5b		bmi $2a01			bmi 	NXCommand 					; -if -ve command
.29a6	c8		iny				iny
.29a7	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.29a9	90 39		bcc $29e4			bcc 	PushByteA 					; 0..63 is short constants.
.29ab					NXLoadStore:
.29ab	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.29ad	b0 19		bcs $29c8			bcs 	NXIndirectLoadStore
.29af	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.29b0	4a		lsr a				lsr 	a
.29b1	29 0e		and #$0e			and 	#$0E
.29b3	da		phx				phx 								; get ready to jump
.29b4	aa		tax				tax
.29b5	7c b8 29	jmp ($29b8,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.29b8					ReadWriteVectors:
>29b8	13 36						.word 	ReadFloatCommand			; read float
>29ba	ee 3b						.word 	WriteFloatCommand 			; write float
>29bc	4f 36						.word 	ReadIntegerCommand 			; read integer
>29be	2a 3c						.word 	WriteIntegerCommand 		; write integer
>29c0	94 36						.word 	ReadStringCommand 			; read string
>29c2	69 3c						.word 	WriteStringCommand 			; write string
>29c4	94 2d						.word 	Unimplemented
>29c6	94 2d						.word 	Unimplemented
.29c8					NXIndirectLoadStore:
.29c8	29 07		and #$07			and 	#7
.29ca	0a		asl a				asl 	a
.29cb	da		phx				phx
.29cc	aa		tax				tax
.29cd	7c d0 29	jmp ($29d0,x)			jmp 	(IndirectVectors,x)
.29d0					IndirectVectors:
>29d0	49 30						.word 	IndFloatRead 				; float read
>29d2	5d 30						.word 	IndInt16Read 				; int16 read
>29d4	71 30						.word 	IndStringRead 				; string read
>29d6	94 2d						.word 	Unimplemented
>29d8	85 30						.word 	IndFloatWrite				; float write
>29da	99 30						.word 	IndInt16Write 				; int16 write
>29dc	ad 30						.word 	IndStringWrite 				; string write
>29de	94 2d						.word 	Unimplemented
.29e0					PushByteCommand:
.29e0	fa		plx				plx
.29e1	b1 22		lda ($22),y			lda 	(codePtr),y 				; get byte to write.
.29e3	c8		iny				iny
.29e4					PushByteA:
.29e4	e8		inx				inx 								; push constant on stack
.29e5	95 38		sta $38,x			sta 	NSMantissa0,x 				; save byte
.29e7	74 44		stz $44,x			stz 	NSMantissa1,x 				; clear MSB
.29e9					ClearRestWord:
.29e9	74 50		stz $50,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.29eb	74 5c		stz $5c,x			stz 	NSMantissa3,x
.29ed	74 68		stz $68,x			stz 	NSExponent,x
.29ef	74 2c		stz $2c,x			stz 	NSStatus,x
.29f1	80 af		bra $29a2			bra 	NextCommand
.29f3					PushWordCommand:
.29f3	fa		plx				plx
.29f4	e8		inx				inx
.29f5	b1 22		lda ($22),y			lda 	(codePtr),y 				; word to stack
.29f7	c8		iny				iny
.29f8	95 38		sta $38,x			sta 	NSMantissa0,x
.29fa	b1 22		lda ($22),y			lda 	(codePtr),y
.29fc	c8		iny				iny
.29fd	95 44		sta $44,x			sta 	NSMantissa1,x
.29ff	80 e8		bra $29e9			bra 	ClearRestWord 				; handle everything else.
.2a01					NXCommand:
.2a01	c8		iny				iny 								; consume command.
.2a02	10 03		bpl $2a07			bpl 	_NXCommandNoFixUp
.2a04	20 0d 2a	jsr $2a0d			jsr 	FixUpY
.2a07					_NXCommandNoFixUp:
.2a07	0a		asl a				asl 	a 							; shift left
.2a08	da		phx				phx 								; save SP on stack
.2a09	aa		tax				tax				 					; and jump indirect
.2a0a	7c cf 3a	jmp ($3acf,x)			jmp 	(VectorTable,x)
.2a0d					FixUpY:
.2a0d	48		pha				pha
.2a0e	98		tya				tya
.2a0f	18		clc				clc
.2a10	65 22		adc $22				adc 	codePtr
.2a12	85 22		sta $22				sta 	codePtr
.2a14	90 02		bcc $2a18			bcc 	_NoCPCarry
.2a16	e6 23		inc $23				inc 	codePtr+1
.2a18					_NoCPCarry:
.2a18	a0 00		ldy #$00			ldy 	#0
.2a1a	68		pla				pla
.2a1b	60		rts				rts
.0564					runtimeHigh:
>0564							.fill 	1
.0565					storeStartHigh:
>0565							.fill 	1
.0566					storeEndHigh:
>0566							.fill 	1
.0567					variableStartPage:
>0567							.fill 	1
.2a1c					AbsoluteTOS:
.2a1c	fa		plx				plx
.2a1d	74 2c		stz $2c,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.2a1f	4c a2 29	jmp $29a2			jmp 	NextCommand
.2a22					CommandVarSpace:
.2a22	fa		plx				plx
.2a23	b1 22		lda ($22),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.2a25	85 7a		sta $7a				sta 	availableMemory
.2a27	c8		iny				iny
.2a28	b1 22		lda ($22),y			lda 	(codePtr),y
.2a2a	18		clc				clc
.2a2b	6d 67 05	adc $0567			adc 	variableStartPage			; offset to actual address.
.2a2e	85 7b		sta $7b				sta 	availableMemory+1
.2a30	c8		iny				iny
.2a31	4c a2 29	jmp $29a2			jmp 	NextCommand
.007a					availableMemory:
>007a							.fill 	2
.2a34					BinaryAnd:
.2a34	fa		plx				plx
.2a35	38		sec				sec
.2a36	80 02		bra $2a3a			bra 	AndOrCommon
.2a38					BinaryOr:
.2a38	fa		plx				plx
.2a39	18		clc				clc
.2a3a					AndOrCommon:
.2a3a	08		php				php 								; save AND/OR flag
.2a3b	20 84 31	jsr $3184			jsr 	GetInteger16Bit
.2a3e	ca		dex				dex
.2a3f	20 84 31	jsr $3184			jsr 	GetInteger16Bit
.2a42	28		plp				plp
.2a43	90 0e		bcc $2a53			bcc 	_AOCOrCode
.2a45	b5 38		lda $38,x			lda 	NSMantissa0,x 				; AND code
.2a47	35 39		and $39,x			and		NSMantissa0+1,x
.2a49	95 38		sta $38,x			sta 	NSMantissa0,x
.2a4b	b5 44		lda $44,x			lda 	NSMantissa1,x
.2a4d	35 45		and $45,x			and		NSMantissa1+1,x
.2a4f	95 44		sta $44,x			sta 	NSMantissa1,x
.2a51	80 0c		bra $2a5f			bra 	_AOCComplete
.2a53					_AOCOrCode:
.2a53	b5 38		lda $38,x			lda 	NSMantissa0,x 				; OR code
.2a55	15 39		ora $39,x			ora		NSMantissa0+1,x
.2a57	95 38		sta $38,x			sta 	NSMantissa0,x
.2a59	b5 44		lda $44,x			lda 	NSMantissa1,x
.2a5b	15 45		ora $45,x			ora		NSMantissa1+1,x
.2a5d	95 44		sta $44,x			sta 	NSMantissa1,x
.2a5f					_AOCComplete:
.2a5f	74 2c		stz $2c,x			stz 	NSStatus,x 					; make integer ?
.2a61	34 44		bit $44,x			bit 	NSMantissa1,x 				; result is -ve
.2a63	10 07		bpl $2a6c			bpl 	_AOCExit
.2a65	20 94 31	jsr $3194			jsr 	Negate16Bit 				; 2's complement
.2a68	a9 80		lda #$80			lda 	#$80 						; make it -ve
.2a6a	95 2c		sta $2c,x			sta 	NSStatus,x
.2a6c					_AOCExit:
.2a6c	4c a2 29	jmp $29a2			jmp 	NextCommand
.2a6f					ArrayConvert:
.2a6f	fa		plx				plx
.2a70	5a		phy				phy
.2a71	b5 38		lda $38,x			lda 	NSMantissa0,x
.2a73	85 28		sta $28				sta 	zTemp1
.2a75	b5 44		lda $44,x			lda 	NSMantissa1,x
.2a77	18		clc				clc
.2a78	6d 67 05	adc $0567			adc 	variableStartPage
.2a7b	85 29		sta $29				sta 	zTemp1+1
.2a7d	ca		dex				dex 								; count of indices to follow -> zTemp2
.2a7e	20 7e 31	jsr $317e			jsr 	GetInteger8Bit
.2a81	85 2a		sta $2a				sta 	zTemp2 						; subtract from stack.
.2a83	8a		txa				txa
.2a84	38		sec				sec
.2a85	e5 2a		sbc $2a				sbc 	zTemp2
.2a87	aa		tax				tax
.2a88	da		phx				phx 								; stack points at the first index, which will be replaced.
.2a89					_ACIndexLoop:
.2a89	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart 			; integer array index
.2a8c	20 84 31	jsr $3184			jsr 	GetInteger16Bit 			; get the index => zTemp0
.2a8f	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.2a91	a5 26		lda $26				lda 	zTemp0
.2a93	d2 28		cmp ($28)			cmp 	(zTemp1)
.2a95	a5 27		lda $27				lda 	zTemp0+1
.2a97	f1 28		sbc ($28),y			sbc 	(zTemp1),y
.2a99	b0 79		bcs $2b14			bcs 	_ACBadIndex 				; index error.
.2a9b	c6 2a		dec $2a				dec 	zTemp2 						; decrement count, if zero, then innermost level
.2a9d	f0 29		beq $2ac8			beq 	_ACInnerLevel
.2a9f	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.2aa1	b1 28		lda ($28),y			lda 	(zTemp1),y
.2aa3	10 6f		bpl $2b14			bpl 	_ACBadIndex
.2aa5	06 26		asl $26				asl 	zTemp0 						; double the index and add it to the base address
.2aa7	26 27		rol $27				rol 	zTemp0+1
.2aa9	18		clc				clc
.2aaa	a5 26		lda $26				lda		zTemp0
.2aac	65 28		adc $28				adc 	zTemp1
.2aae	85 26		sta $26				sta 	zTemp0
.2ab0	a5 27		lda $27				lda		zTemp0+1
.2ab2	65 29		adc $29				adc 	zTemp1+1
.2ab4	85 27		sta $27				sta 	zTemp0+1
.2ab6	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.2ab8	b1 26		lda ($26),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.2aba	85 28		sta $28				sta 	zTemp1
.2abc	c8		iny				iny
.2abd	b1 26		lda ($26),y			lda 	(zTemp0),y
.2abf	18		clc				clc
.2ac0	6d 67 05	adc $0567			adc 	variableStartPage
.2ac3	85 29		sta $29				sta 	zTemp1+1
.2ac5	e8		inx				inx 								; next index
.2ac6	80 c1		bra $2a89			bra 	_ACIndexLoop
.2ac8					_ACInnerLevel:
.2ac8	a0 02		ldy #$02			ldy 	#2
.2aca	b1 28		lda ($28),y			lda 	(zTemp1),y
.2acc	30 46		bmi $2b14			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.2ace	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.2ad0	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ad2	d0 13		bne $2ae7			bne 	_ACNotFloat
.2ad4	a5 27		lda $27				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.2ad6	48		pha				pha
.2ad7	a5 26		lda $26				lda 	zTemp0
.2ad9	06 26		asl $26				asl 	zTemp0 						; x 2
.2adb	26 27		rol $27				rol 	zTemp0+1
.2add	18		clc				clc 								; add back x 3
.2ade	65 26		adc $26				adc 	zTemp0
.2ae0	85 26		sta $26				sta 	zTemp0
.2ae2	68		pla				pla
.2ae3	65 27		adc $27				adc 	zTemp0+1
.2ae5	85 27		sta $27				sta 	zTemp0+1
.2ae7					_ACNotFloat:
.2ae7	06 26		asl $26				asl 	zTemp0 						; x 2 or x 6 depending.
.2ae9	26 27		rol $27				rol 	zTemp0+1
.2aeb	18		clc				clc
.2aec	a5 26		lda $26				lda 	zTemp0
.2aee	69 03		adc #$03			adc 	#3
.2af0	85 26		sta $26				sta 	zTemp0
.2af2	90 02		bcc $2af6			bcc 	_ACNoCarry
.2af4	e6 27		inc $27				inc 	zTemp0+1
.2af6					_ACNoCarry:
.2af6	fa		plx				plx 								; X points to first slot of array parameters
.2af7	18		clc				clc
.2af8	a5 26		lda $26				lda 	zTemp0
.2afa	65 28		adc $28				adc 	zTemp1
.2afc	95 38		sta $38,x			sta 	NSMantissa0,x
.2afe	a5 27		lda $27				lda 	zTemp0+1
.2b00	65 29		adc $29				adc 	zTemp1+1
.2b02	38		sec				sec
.2b03	ed 67 05	sbc $0567			sbc 	variableStartPage
.2b06	95 44		sta $44,x			sta 	NSMantissa1,x
.2b08	74 50		stz $50,x			stz 	NSMantissa2,x
.2b0a	74 5c		stz $5c,x			stz 	NSMantissa3,x
.2b0c	74 2c		stz $2c,x			stz 	NSStatus,x
.2b0e	74 68		stz $68,x			stz 	NSExponent,x
.2b10	7a		ply				ply 	 							; restore code pointer
.2b11	4c a2 29	jmp $29a2			jmp 	NextCommand
.2b14					_ACBadIndex:
.2b14	4c 0b 11	jmp $110b		jmp	ErrorV_index
.2b17					UnaryAsc:
.2b17	fa		plx				plx
.2b18	5a		phy				phy
.2b19	b5 38		lda $38,x			lda 	NSMantissa0,x 				; string address.
.2b1b	85 26		sta $26				sta 	zTemp0
.2b1d	b5 44		lda $44,x			lda 	NSMantissa1,x
.2b1f	85 27		sta $27				sta 	zTemp0+1
.2b21	b2 26		lda ($26)			lda 	(zTemp0) 					; if empty string return zero
.2b23	f0 06		beq $2b2b			beq 	_UAExit
.2b25	5a		phy				phy 								; otherwise first character
.2b26	a0 01		ldy #$01			ldy 	#1
.2b28	b1 26		lda ($26),y			lda 	(zTemp0),y
.2b2a	7a		ply				ply
.2b2b					_UAExit:
.2b2b	20 78 17	jsr $1778			jsr 	FloatSetByte
.2b2e	7a		ply				ply
.2b2f	4c a2 29	jmp $29a2			jmp 	NextCommand
.2b32					CommandAssert:
.2b32	fa		plx				plx
.2b33	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.2b35	d0 09		bne $2b40			bne 	_CAFail
.2b37	20 98 17	jsr $1798			jsr 	FloatIsZero 				; is it zero ?
.2b3a	f0 04		beq $2b40			beq 	_CAFail
.2b3c	ca		dex				dex
.2b3d	4c a2 29	jmp $29a2			jmp 	NextCommand
.2b40					_CAFail:
.2b40	4c 64 10	jmp $1064		jmp	ErrorV_assert
.2b43					X16_Audio_Parameters8_16:
.2b43	20 49 2b	jsr $2b49			jsr 	X16_Audio_Parameters8_8
.2b46	a4 45		ldy $45				ldy 	NSMantissa1+1
.2b48	60		rts				rts
.2b49					X16_Audio_Parameters8_8:
.2b49	a2 01		ldx #$01			ldx 	#1
.2b4b	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.2b4e	ca		dex				dex
.2b4f	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.2b52	20 7e 31	jsr $317e			jsr 	GetInteger8Bit
.2b55	a6 39		ldx $39				ldx 	NSMantissa0+1
.2b57	a0 00		ldy #$00			ldy 	#0
.2b59	60		rts				rts
.2b5a					X16_Audio_Parameters8_String:
.2b5a	20 43 2b	jsr $2b43			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.2b5d	da		phx				phx 								; set the voice
.2b5e	5a		phy				phy
.2b5f	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.2b62	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>2b65	0a						.byte 	X16_AudioCodeBank
.2b66	7a		ply				ply
.2b67	fa		plx				plx
.2b68	86 26		stx $26				stx 	zTemp0
.2b6a	84 27		sty $27				sty 	zTemp0+1
.2b6c	b2 26		lda ($26)			lda 	(zTemp0) 					; read length
.2b6e	e8		inx				inx 								; point YX to first character.
.2b6f	d0 01		bne $2b72			bne 	_X16APSSkip
.2b71	c8		iny				iny
.2b72					_X16APSSkip:
.2b72	60		rts				rts
.2b73					Unary16Bin:
.2b73	fa		plx				plx
.2b74	20 84 31	jsr $3184			jsr 	GetInteger16Bit				; 16 bit int
.2b77	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.2b79	20 4e 38	jsr $384e			jsr 	StringAllocTemp
.2b7c	a5 27		lda $27				lda 	zTemp0+1
.2b7e	f0 03		beq $2b83			beq 	_UBNoHigh
.2b80	20 8b 2b	jsr $2b8b			jsr 	_UBWriteBinary
.2b83					_UBNoHigh:
.2b83	a5 26		lda $26				lda 	zTemp0
.2b85	20 8b 2b	jsr $2b8b			jsr 	_UBWriteBinary
.2b88	4c a2 29	jmp $29a2			jmp 	NextCommand
.2b8b					_UBWriteBinary:
.2b8b	5a		phy				phy
.2b8c	a0 08		ldy #$08			ldy 	#8
.2b8e					_UBWLoop:
.2b8e	0a		asl a				asl 	a
.2b8f	48		pha				pha
.2b90	a9 00		lda #$00			lda  	#0
.2b92	69 30		adc #$30			adc 	#48
.2b94	20 77 38	jsr $3877			jsr 	StringWriteChar
.2b97	68		pla				pla
.2b98	88		dey				dey
.2b99	d0 f3		bne $2b8e			bne 	_UBWLoop
.2b9b	7a		ply				ply
.2b9c	60		rts				rts
.2b9d					PrintCharacterX:
.2b9d	fa		plx				plx
.2b9e	b5 38		lda $38,x			lda 	NSMantissa0,x
.2ba0	ca		dex				dex
.2ba1	20 ab 34	jsr $34ab			jsr 	VectorPrintCharacter
.2ba4	4c a2 29	jmp $29a2			jmp 	NextCommand
.2ba7					UnaryChr:
.2ba7	fa		plx				plx
.2ba8	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; get integer to convert.
.2bab	48		pha				pha 								; save it and allocate for it
.2bac	a9 01		lda #$01			lda 	#1 							; 1 character
.2bae	20 4e 38	jsr $384e			jsr 	StringAllocTemp
.2bb1	a9 01		lda #$01			lda 	#1 							; length 1.
.2bb3	92 76		sta ($76)			sta 	(zsTemp)
.2bb5	68		pla				pla 								; character code makes string.
.2bb6	5a		phy				phy
.2bb7	a0 01		ldy #$01			ldy 	#1
.2bb9	91 76		sta ($76),y			sta 	(zsTemp),y
.2bbb	7a		ply				ply
.2bbc	4c a2 29	jmp $29a2			jmp 	NextCommand
.2bbf					CommandClr:
.2bbf	fa		plx				plx
.2bc0	20 c6 2b	jsr $2bc6			jsr 	ClearMemory
.2bc3	4c a2 29	jmp $29a2			jmp 	NextCommand
.2bc6					ClearMemory:
.2bc6	ad 65 05	lda $0565			lda 	storeStartHigh 							; erase the work area
.2bc9	85 27		sta $27				sta 	zTemp0+1
.2bcb	64 26		stz $26				stz 	zTemp0
.2bcd	5a		phy				phy
.2bce	a0 00		ldy #$00			ldy 	#0
.2bd0					_ClearLoop1:
.2bd0	a9 00		lda #$00			lda 	#0
.2bd2	91 26		sta ($26),y			sta 	(zTemp0),y
.2bd4	c8		iny				iny
.2bd5	d0 f9		bne $2bd0			bne 	_ClearLoop1
.2bd7	e6 27		inc $27				inc 	zTemp0+1
.2bd9	a5 27		lda $27				lda 	zTemp0+1
.2bdb	cd 66 05	cmp $0566			cmp 	storeEndHigh
.2bde	d0 f0		bne $2bd0			bne 	_ClearLoop1
.2be0	38		sec				sec 											; stack space = number of pages in total / 4
.2be1	ad 66 05	lda $0566			lda 	storeEndHigh
.2be4	ed 65 05	sbc $0565			sbc		storeStartHigh
.2be7	4a		lsr a				lsr 	a
.2be8	4a		lsr a				lsr 	a
.2be9	d0 02		bne $2bed			bne 	_NotEmpty 								; at least 1 !
.2beb	a9 01		lda #$01			lda 	#1
.2bed					_NotEmpty:
.2bed	38		sec				sec 											; subtract from high to give string high memory
.2bee	49 ff		eor #$ff			eor 	#$FF
.2bf0	6d 66 05	adc $0566			adc 	storeEndHigh
.2bf3	8d 63 05	sta $0563			sta 	stringHighMemory+1
.2bf6	9c 62 05	stz $0562			stz 	stringHighMemory
.2bf9	9c c8 06	stz $06c8			stz 	stringInitialised 						; string system not initialised
.2bfc	ad 65 05	lda $0565			lda 	storeStartHigh 							; stack at end of start memory.
.2bff	3a		dec a				dec 	a
.2c00	85 79		sta $79				sta 	runtimeStackPtr+1
.2c02	a9 ff		lda #$ff			lda 	#$FF
.2c04	85 78		sta $78				sta 	runtimeStackPtr
.2c06	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.2c08	92 78		sta ($78)			sta 	(runtimeStackPtr)
.2c0a	7a		ply				ply
.2c0b	60		rts				rts
.2c0c					CompareStrings:
.2c0c	fa		plx				plx
.2c0d	ca		dex				dex
.2c0e	b5 38		lda $38,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.2c10	85 26		sta $26				sta 	zTemp0
.2c12	b5 44		lda $44,x			lda 	NSMantissa1,x
.2c14	85 27		sta $27				sta 	zTemp0+1
.2c16	b5 39		lda $39,x			lda 	NSMantissa0+1,x
.2c18	85 28		sta $28				sta 	zTemp1
.2c1a	b5 45		lda $45,x			lda 	NSMantissa1+1,x
.2c1c	85 29		sta $29				sta 	zTemp1+1
.2c1e	da		phx				phx
.2c1f	5a		phy				phy
.2c20	b2 26		lda ($26)			lda 	(zTemp0)					; work out number to compare
.2c22	d2 28		cmp ($28)			cmp 	(zTemp1)
.2c24	90 02		bcc $2c28			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.2c26	b2 28		lda ($28)			lda 	(zTemp1)
.2c28					_CSNIsSmallest:
.2c28	aa		tax				tax 								; count in X
.2c29	f0 0c		beq $2c37			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.2c2b	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.2c2d					_CSNCompareString:
.2c2d	c8		iny				iny 								; pre increment
.2c2e	b1 26		lda ($26),y			lda 	(zTemp0),y
.2c30	d1 28		cmp ($28),y			cmp 	(zTemp1),y
.2c32	d0 0a		bne $2c3e			bne 	_CSNDifferent 				; numbers are different.
.2c34	ca		dex				dex
.2c35	d0 f6		bne $2c2d			bne 	_CSNCompareString 			; compare common characters in two strings.
.2c37					_CSNMatches:
.2c37	38		sec				sec
.2c38	b2 26		lda ($26)			lda 	(zTemp0)					; compare lengths
.2c3a	f2 28		sbc ($28)			sbc 	(zTemp1)
.2c3c	f0 06		beq $2c44			beq 	_CSNSExit 					; if zero, then strings match and exit.
.2c3e					_CSNDifferent:
.2c3e	a9 ff		lda #$ff			lda 	#$FF
.2c40	90 02		bcc $2c44			bcc 	_CSNSExit
.2c42	a9 01		lda #$01			lda 	#$01
.2c44					_CSNSExit:
.2c44	7a		ply				ply
.2c45	fa		plx				plx
.2c46	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.2c48	20 78 17	jsr $1778			jsr 	FloatSetByte 				; output the byte
.2c4b	4c a2 29	jmp $29a2			jmp 	NextCommand
.2c4e					StringConcrete:
.2c4e	9c c8 06	stz $06c8			stz 	stringInitialised	 		; initialise next usage
.2c51	84 2b		sty $2b				sty 	zTemp2+1 					; save pointer to new string
.2c53	85 2a		sta $2a				sta 	zTemp2
.2c55	b2 2a		lda ($2a)			lda 	(zTemp2) 					; length required
.2c57	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.2c58	18		clc				clc
.2c59	72 2a		adc ($2a)			adc 	(zTemp2)
.2c5b	90 02		bcc $2c5f			bcc 	_SCNoOverflow
.2c5d	a9 ff		lda #$ff			lda 	#255
.2c5f					_SCNoOverflow:
.2c5f	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.2c61	b0 02		bcs $2c65			bcs 	_SCNoMinimum
.2c63	a9 0a		lda #$0a			lda 	#10
.2c65					_SCNoMinimum:
.2c65	85 28		sta $28				sta 	zTemp1 						; save max length.
.2c67	38		sec				sec
.2c68	ad 62 05	lda $0562			lda		stringHighMemory 			; subtract max length from high memory.
.2c6b	e5 28		sbc $28				sbc 	zTemp1
.2c6d	a8		tay				tay
.2c6e	ad 63 05	lda $0563			lda 	stringHighMemory+1
.2c71	e9 00		sbc #$00			sbc 	#0
.2c73	48		pha				pha
.2c74	38		sec				sec 								; subtract 3 more
.2c75	98		tya				tya
.2c76	e9 03		sbc #$03			sbc 	#3
.2c78	8d 62 05	sta $0562			sta 	stringHighMemory 			; to string high memory/zsTemp
.2c7b	85 76		sta $76				sta 	zsTemp
.2c7d	68		pla				pla
.2c7e	e9 00		sbc #$00			sbc 	#0
.2c80	8d 63 05	sta $0563			sta 	stringHighMemory+1
.2c83	85 77		sta $77				sta 	zsTemp+1
.2c85	a5 28		lda $28				lda 	zTemp1 						; set max length.
.2c87	92 76		sta ($76)			sta 	(zsTemp)
.2c89	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.2c8b	a9 00		lda #$00			lda 	#0
.2c8d	91 76		sta ($76),y			sta 	(zsTemp),y
.2c8f	a5 76		lda $76				lda 	zsTemp 						; new empty string in YA.
.2c91	a4 77		ldy $77				ldy 	zsTemp+1
.2c93	60		rts				rts
.2c94					CommandXData:
.2c94	fa		plx				plx
.2c95	98		tya				tya 								; data length +1 added to Y
.2c96	38		sec				sec
.2c97	71 22		adc ($22),y			adc 	(codePtr),y 				; next instruction
.2c99	a8		tay				tay
.2c9a	4c a2 29	jmp $29a2			jmp 	NextCommand
.2c9d					CommandXDIM:
.2c9d	fa		plx				plx
.2c9e	5a		phy				phy
.2c9f	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.2ca2	8d 68 05	sta $0568			sta 	dimType
.2ca5	ca		dex				dex 								; this is the number of indices
.2ca6	20 7e 31	jsr $317e			jsr 	GetInteger8Bit
.2ca9	85 28		sta $28				sta 	zTemp1 						; subtract n from X so X points at the *first*
.2cab	8a		txa				txa 								; dimension.
.2cac	38		sec				sec
.2cad	e5 28		sbc $28				sbc 	zTemp1
.2caf	aa		tax				tax
.2cb0	a5 28		lda $28				lda 	zTemp1 						; number of indices.
.2cb2	20 c6 2c	jsr $2cc6			jsr 	DIMCreateOneLevel 			; create one at this level
.2cb5	95 38		sta $38,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.2cb7	98		tya				tya
.2cb8	95 44		sta $44,x			sta 	NSMantissa1,x
.2cba	74 50		stz $50,x			stz 	NSMantissa2,x
.2cbc	74 5c		stz $5c,x			stz 	NSMantissa3,x
.2cbe	74 2c		stz $2c,x			stz 	NSStatus,x
.2cc0	74 68		stz $68,x			stz 	NSExponent,x
.2cc2	7a		ply				ply
.2cc3	4c a2 29	jmp $29a2			jmp 	NextCommand
.2cc6					DIMCreateOneLevel:
.2cc6	a4 7a		ldy $7a				ldy 	availableMemory 			; push the start of this block on the stack.
.2cc8	5a		phy				phy
.2cc9	a4 7b		ldy $7b				ldy 	availableMemory+1
.2ccb	5a		phy				phy
.2ccc	a8		tay				tay 			 					; save current level into Y
.2ccd	20 84 31	jsr $3184			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.2cd0	e6 26		inc $26				inc 	zTemp0 						; bump the size of the dimension as we need one more
.2cd2	d0 02		bne $2cd6			bne 	_DCOLNoCarry
.2cd4	e6 27		inc $27				inc 	zTemp0+1
.2cd6					_DCOLNoCarry:
.2cd6	a5 26		lda $26				lda 	zTemp0 						; write out the +1 size of the dimension
.2cd8	20 79 2d	jsr $2d79			jsr 	DIMWriteByte
.2cdb	a5 27		lda $27				lda 	zTemp0+1
.2cdd	20 79 2d	jsr $2d79			jsr 	DIMWriteByte
.2ce0	ad 68 05	lda $0568			lda 	dimType 					; get type information
.2ce3	29 7f		and #$7f			and 	#$7F
.2ce5	c0 01		cpy #$01			cpy 	#1
.2ce7	f0 02		beq $2ceb			beq 	_DCOLNoSubLevel
.2ce9	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.2ceb					_DCOLNoSubLevel:
.2ceb	20 79 2d	jsr $2d79			jsr 	DIMWriteByte
.2cee	a5 7a		lda $7a				lda 	availableMemory
.2cf0	85 28		sta $28				sta 	zTemp1
.2cf2	a5 7b		lda $7b				lda 	availableMemory+1
.2cf4	85 29		sta $29				sta 	zTemp1+1
.2cf6	a5 26		lda $26				lda 	zTemp0
.2cf8	85 2a		sta $2a				sta 	zTemp2
.2cfa	a5 27		lda $27				lda 	zTemp0+1
.2cfc	85 2b		sta $2b				sta 	zTemp2+1
.2cfe					_DCOLFillArray:
.2cfe	20 5d 2d	jsr $2d5d			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.2d01	a5 26		lda $26				lda 	zTemp0 						; decrement one from count.
.2d03	d0 02		bne $2d07			bne 	_DCOLNoBorrow
.2d05	c6 27		dec $27				dec 	zTemp0+1
.2d07					_DCOLNoBorrow:
.2d07	c6 26		dec $26				dec 	zTemp0
.2d09	a5 26		lda $26				lda 	zTemp0 						; until completed.
.2d0b	05 27		ora $27				ora 	zTemp0+1
.2d0d	d0 ef		bne $2cfe			bne 	_DCOLFillArray
.2d0f	c0 01		cpy #$01			cpy 	#1
.2d11	f0 42		beq $2d55			beq 	_DCOLExit
.2d13					_DCOLRecursionLoop:
.2d13	da		phx				phx 								; save XY
.2d14	5a		phy				phy
.2d15	a5 28		lda $28				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.2d17	48		pha				pha
.2d18	a5 29		lda $29				lda 	zTemp1+1
.2d1a	48		pha				pha
.2d1b	a5 2a		lda $2a				lda 	zTemp2
.2d1d	48		pha				pha
.2d1e	a5 2b		lda $2b				lda 	zTemp2+1
.2d20	48		pha				pha
.2d21	88		dey				dey  								; lower level -> A
.2d22	98		tya				tya
.2d23	e8		inx				inx 								; next index size
.2d24	20 c6 2c	jsr $2cc6			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.2d27	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.2d28	86 2b		stx $2b				stx 	zTemp2+1
.2d2a	fa		plx				plx
.2d2b	86 2a		stx $2a				stx 	zTemp2
.2d2d	fa		plx				plx
.2d2e	86 29		stx $29				stx 	zTemp1+1
.2d30	fa		plx				plx
.2d31	86 28		stx $28				stx 	zTemp1
.2d33	92 28		sta ($28)			sta 	(zTemp1) 					; write out position
.2d35	98		tya				tya
.2d36	a0 01		ldy #$01			ldy 	#1
.2d38	91 28		sta ($28),y			sta 	(zTemp1),y
.2d3a	7a		ply				ply 								; restore XY
.2d3b	fa		plx				plx
.2d3c	18		clc				clc
.2d3d	a5 28		lda $28				lda 	zTemp1 						; add 2 to zTemp1
.2d3f	69 02		adc #$02			adc 	#2
.2d41	85 28		sta $28				sta 	zTemp1
.2d43	90 02		bcc $2d47			bcc 	_DCOLRNoCarry
.2d45	e6 29		inc $29				inc 	zTemp1+1
.2d47					_DCOLRNoCarry:
.2d47	a5 2a		lda $2a				lda 	zTemp2 						; decrement one from count in zTemp2
.2d49	d0 02		bne $2d4d			bne 	_DCOLRNoBorrow
.2d4b	c6 2b		dec $2b				dec 	zTemp2+1
.2d4d					_DCOLRNoBorrow:
.2d4d	c6 2a		dec $2a				dec 	zTemp2
.2d4f	a5 2a		lda $2a				lda 	zTemp2 						; until completed.
.2d51	05 2b		ora $2b				ora 	zTemp2+1
.2d53	d0 be		bne $2d13			bne 	_DCOLRecursionLoop
.2d55					_DCOLExit:
.2d55	68		pla				pla 								; get MSB, make offset again
.2d56	38		sec				sec
.2d57	ed 67 05	sbc $0567			sbc 	variableStartPage
.2d5a	a8		tay				tay
.2d5b	68		pla				pla 								; YA now contains offset address.
.2d5c	60		rts				rts
.2d5d					DIMWriteElement:
.2d5d	da		phx				phx
.2d5e	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.2d60	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.2d62	d0 0b		bne $2d6f			bne 	_DIMWENotFloat
.2d64	ad 68 05	lda $0568			lda 	dimType
.2d67	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2d69	c9 00		cmp #$00			cmp 	#NSSIFloat
.2d6b	d0 02		bne $2d6f			bne 	_DIMWENotFloat
.2d6d	a2 06		ldx #$06			ldx 	#6
.2d6f					_DIMWENotFloat:
.2d6f	a9 00		lda #$00			lda 	#0
.2d71	20 79 2d	jsr $2d79			jsr 	DIMWriteByte
.2d74	ca		dex				dex
.2d75	d0 f8		bne $2d6f			bne 	_DIMWENotFloat
.2d77	fa		plx				plx
.2d78	60		rts				rts
.2d79					DIMWriteByte:
.2d79	92 7a		sta ($7a)			sta 	(availableMemory)
.2d7b	e6 7a		inc $7a				inc 	availableMemory
.2d7d	d0 0b		bne $2d8a			bne 	_DIMWBSkip
.2d7f	e6 7b		inc $7b				inc 	availableMemory+1
.2d81	48		pha				pha
.2d82	a5 7b		lda $7b				lda 	availableMemory+1 			; check out of memory
.2d84	cd 63 05	cmp $0563			cmp 	stringHighMemory+1
.2d87	b0 02		bcs $2d8b			bcs 	_DIMWBMemory
.2d89	68		pla				pla
.2d8a					_DIMWBSkip:
.2d8a	60		rts				rts
.2d8b					_DIMWBMemory:
.2d8b	4c 1e 11	jmp $111e		jmp	ErrorV_memory
.0568					dimType:
>0568							.fill 	1
.2d8e					CommandEnd:
.2d8e	fa		plx				plx
.2d8f	86 26		stx $26				stx 	zTemp0
.2d91	4c ff ff	jmp $ffff			jmp 	$FFFF
.2d94					Unimplemented:
.2d94	4c 51 10	jmp $1051			jmp 	ErrorV_unimplemented
.2d97					RuntimeErrorHandler:
.2d97	98		tya				tya
.2d98	18		clc				clc
.2d99	65 22		adc $22				adc 	codePtr
.2d9b	85 22		sta $22				sta 	codePtr
.2d9d	90 02		bcc $2da1			bcc 	_EHNoCarry
.2d9f	e6 23		inc $23				inc 	codePtr+1
.2da1					_EHNoCarry:
.2da1	68		pla				pla
.2da2	7a		ply				ply
.2da3	85 26		sta $26				sta 	zTemp0
.2da5	84 27		sty $27				sty 	zTemp0+1
.2da7	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.2da9	a0 01		ldy #$01			ldy 	#1
.2dab					_EHDisplayMsg:
.2dab	b1 26		lda ($26),y			lda 	(zTemp0),y
.2dad	20 c3 3d	jsr $3dc3			jsr 	XPrintCharacterToChannel
.2db0	c8		iny				iny
.2db1	b1 26		lda ($26),y			lda 	(zTemp0),y
.2db3	d0 f6		bne $2dab			bne 	_EHDisplayMsg
.2db5	a9 20		lda #$20			lda 	#32
.2db7	20 c3 3d	jsr $3dc3			jsr 	XPrintCharacterToChannel
.2dba	a9 40		lda #$40			lda 	#64
.2dbc	20 c3 3d	jsr $3dc3			jsr 	XPrintCharacterToChannel
.2dbf	a9 20		lda #$20			lda 	#32
.2dc1	20 c3 3d	jsr $3dc3			jsr 	XPrintCharacterToChannel
.2dc4	20 c9 2d	jsr $2dc9			jsr 	EHDisplayCodePtr
.2dc7	80 fe		bra $2dc7	_EHStop:bra 	_EHStop
.2dc9					EHDisplayCodePtr:
.2dc9	a9 24		lda #$24			lda 	#'$'
.2dcb	20 c3 3d	jsr $3dc3			jsr 	XPrintCharacterToChannel
.2dce	38		sec				sec
.2dcf	a5 23		lda $23				lda 	codePtr+1 					; display the p-code address of the error.
.2dd1	ed 64 05	sbc $0564			sbc 	runtimeHigh
.2dd4	20 dd 2d	jsr $2ddd			jsr 	_EHDisplayHex
.2dd7	a5 22		lda $22				lda 	codePtr
.2dd9	20 dd 2d	jsr $2ddd			jsr 	_EHDisplayHex
.2ddc	60		rts				rts
.2ddd					_EHDisplayHex:
.2ddd	48		pha				pha
.2dde	4a		lsr a				lsr 	a
.2ddf	4a		lsr a				lsr 	a
.2de0	4a		lsr a				lsr 	a
.2de1	4a		lsr a				lsr 	a
.2de2	20 e6 2d	jsr $2de6			jsr 	_EHDisplayNibble
.2de5	68		pla				pla
.2de6					_EHDisplayNibble:
.2de6	29 0f		and #$0f			and 	#15
.2de8	c9 0a		cmp #$0a			cmp 	#10
.2dea	90 02		bcc $2dee			bcc 	_EHNotHex
.2dec	69 06		adc #$06			adc 	#6
.2dee					_EHNotHex:
.2dee	69 30		adc #$30			adc 	#48
.2df0	4c c3 3d	jmp $3dc3			jmp 	XPrintCharacterToChannel
.2df3					CommandXFor:
.2df3	fa		plx				plx
.2df4	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.2df6	20 76 2e	jsr $2e76			jsr 	StackOpenFrame
.2df9	20 b5 32	jsr $32b5			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.2dfc	a0 07		ldy #$07			ldy 	#7 							; copy step out
.2dfe	20 58 2e	jsr $2e58			jsr 	CopyTOSToOffsetY
.2e01	ca		dex				dex
.2e02	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.2e04	20 58 2e	jsr $2e58			jsr 	CopyTOSToOffsetY
.2e07	ca		dex				dex
.2e08	b5 44		lda $44,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.2e0a	29 80		and #$80			and 	#$80
.2e0c	a0 04		ldy #$04			ldy 	#4
.2e0e	91 78		sta ($78),y			sta 	(runtimeStackPtr),y
.2e10	b5 38		lda $38,x			lda 	NSMantissa0,x 				; copy the reference address
.2e12	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.2e14	91 78		sta ($78),y			sta 	(runtimeStackPtr),y
.2e16	85 26		sta $26				sta 	zTemp0 						; also to zTemp0
.2e18	c8		iny				iny
.2e19	b5 44		lda $44,x			lda 	NSMantissa1,x
.2e1b	18		clc				clc
.2e1c	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.2e1e	91 78		sta ($78),y			sta 	(runtimeStackPtr),y
.2e20	6d 67 05	adc $0567			adc 	variableStartPage 			; point to variable page.
.2e23	85 27		sta $27				sta 	zTemp0+1
.2e25	ca		dex				dex 								; throw reference.
.2e26	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.2e28	b1 26		lda ($26),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.2e2a	a0 0c		ldy #$0c			ldy 	#12
.2e2c	11 78		ora ($78),y			ora 	(runtimeStackPtr),y
.2e2e	a0 12		ldy #$12			ldy 	#18
.2e30	11 78		ora ($78),y			ora 	(runtimeStackPtr),y
.2e32	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.2e34	88		dey				dey 								; now the exponents.
.2e35	11 26		ora ($26),y			ora 	(zTemp0),y
.2e37	a0 0b		ldy #$0b			ldy 	#11
.2e39	11 78		ora ($78),y			ora 	(runtimeStackPtr),y
.2e3b	a0 11		ldy #$11			ldy 	#17
.2e3d	11 78		ora ($78),y			ora 	(runtimeStackPtr),y
.2e3f	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.2e41	11 78		ora ($78),y			ora 	(runtimeStackPtr),y
.2e43	c8		iny				iny
.2e44	11 78		ora ($78),y			ora 	(runtimeStackPtr),y
.2e46	c8		iny				iny
.2e47	11 78		ora ($78),y			ora 	(runtimeStackPtr),y
.2e49	d0 08		bne $2e53			bne 	_CFNoOptimise
.2e4b	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.2e4d	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.2e4f	09 40		ora #$40			ora 	#$40
.2e51	91 78		sta ($78),y			sta 	(runtimeStackPtr),y
.2e53					_CFNoOptimise:
.2e53	a0 00		ldy #$00			ldy 	#0
.2e55	4c a2 29	jmp $29a2			jmp 	NextCommand
.2e58					CopyTOSToOffsetY:
.2e58	b5 38		lda $38,x			lda 	NSMantissa0,x
.2e5a	91 78		sta ($78),y			sta 	(runtimeStackPtr),y
.2e5c	c8		iny				iny
.2e5d	b5 44		lda $44,x			lda 	NSMantissa1,x
.2e5f	91 78		sta ($78),y			sta 	(runtimeStackPtr),y
.2e61	c8		iny				iny
.2e62	b5 50		lda $50,x			lda 	NSMantissa2,x
.2e64	91 78		sta ($78),y			sta 	(runtimeStackPtr),y
.2e66	c8		iny				iny
.2e67	b5 5c		lda $5c,x			lda 	NSMantissa3,x
.2e69	91 78		sta ($78),y			sta 	(runtimeStackPtr),y
.2e6b	c8		iny				iny
.2e6c	b5 68		lda $68,x			lda 	NSExponent,x
.2e6e	91 78		sta ($78),y			sta 	(runtimeStackPtr),y
.2e70	c8		iny				iny
.2e71	b5 2c		lda $2c,x			lda 	NSStatus,x
.2e73	91 78		sta ($78),y			sta 	(runtimeStackPtr),y
.2e75	60		rts				rts
.2e76					StackOpenFrame:
.2e76	48		pha				pha 								; save frame marker
.2e77	29 1f		and #$1f			and 	#$1F 						; bytes required.
.2e79	85 26		sta $26				sta 	zTemp0
.2e7b	38		sec				sec 								; subtract from runtime stack pointer.
.2e7c	a5 78		lda $78				lda		runtimeStackPtr
.2e7e	e5 26		sbc $26				sbc 	zTemp0
.2e80	85 78		sta $78				sta 	runtimeStackPtr
.2e82	a5 79		lda $79				lda		runtimeStackPtr+1
.2e84	e9 00		sbc #$00			sbc 	#0
.2e86	85 79		sta $79				sta 	runtimeStackPtr+1
.2e88	68		pla				pla 								; put frame marker at +0
.2e89	92 78		sta ($78)			sta 	(runtimeStackPtr)
.2e8b	60		rts				rts
.2e8c					StackCloseFrame:
.2e8c	b2 78		lda ($78)			lda 	(runtimeStackPtr)			; get frame marker
.2e8e	29 1f		and #$1f			and 	#$1F 						; size
.2e90	18		clc				clc
.2e91	65 78		adc $78				adc 	runtimeStackPtr
.2e93	85 78		sta $78				sta 	runtimeStackPtr
.2e95	90 02		bcc $2e99			bcc 	_SCFNoCarry
.2e97	e6 79		inc $79				inc 	runtimeStackPtr+1
.2e99					_SCFNoCarry:
.2e99	60		rts				rts
.2e9a					StackFindFrame:
.2e9a	8d 69 05	sta $0569			sta 	requiredFrame
.2e9d					_SFFLoop:
.2e9d	b2 78		lda ($78)			lda 	(runtimeStackPtr) 			; get TOS
.2e9f	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.2ea1	f0 10		beq $2eb3			beq 	SCFFail
.2ea3	cd 69 05	cmp $0569			cmp 	requiredFrame 				; found this type ?
.2ea6	f0 05		beq $2ead			beq 	_SFFFound
.2ea8	20 8c 2e	jsr $2e8c			jsr 	StackCloseFrame 			; close the top frame
.2eab	80 f0		bra $2e9d			bra 	_SFFLoop 					; and try te next.
.2ead					_SFFFound:
.2ead	60		rts				rts
.2eae					StackCheckFrame:
.2eae	d2 78		cmp ($78)			cmp 	(runtimeStackPtr) 			; matches current frame
.2eb0	d0 01		bne $2eb3			bne 	SCFFail
.2eb2	60		rts				rts
.2eb3					SCFFail:
.2eb3	4c ae 10	jmp $10ae		jmp	ErrorV_structure
.0569					requiredFrame:
>0569							.fill 	1
.2eb6					UnaryFre:
.2eb6	fa		plx				plx
.2eb7	20 76 17	jsr $1776			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.2eba	38		sec				sec
.2ebb	ad 62 05	lda $0562			lda 	stringHighMemory 			; calculate the free memory.
.2ebe	ed 60 05	sbc $0560			sbc 	stringLowMemory
.2ec1	95 38		sta $38,x			sta		NSMantissa0,x
.2ec3	ad 63 05	lda $0563			lda 	stringHighMemory+1
.2ec6	ed 61 05	sbc $0561			sbc 	stringLowMemory+1
.2ec9	95 44		sta $44,x			sta		NSMantissa1,x
.2ecb	4c a2 29	jmp $29a2			jmp 	NextCommand
.2ece					CommandXGet:
.2ece	fa		plx				plx
.2ecf	e8		inx				inx
.2ed0	a9 01		lda #$01			lda 	#1 							; 1 character space
.2ed2	20 4e 38	jsr $384e			jsr 	StringAllocTemp
.2ed5	20 b4 34	jsr $34b4			jsr 	VectorGetCharacter 			; get a character
.2ed8	c9 00		cmp #$00			cmp 	#0
.2eda	f0 09		beq $2ee5			beq 	_CGNone
.2edc	5a		phy				phy
.2edd	a0 01		ldy #$01			ldy 	#1 							; store char
.2edf	91 76		sta ($76),y			sta 	(zsTemp),y
.2ee1	98		tya				tya 								; store length.
.2ee2	92 76		sta ($76)			sta 	(zsTemp)
.2ee4	7a		ply				ply
.2ee5					_CGNone:
.2ee5	4c a2 29	jmp $29a2			jmp 	NextCommand
.2ee8					CommandXGosub:
.2ee8	fa		plx				plx
.2ee9	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.2eeb	20 76 2e	jsr $2e76			jsr 	StackOpenFrame
.2eee	20 b5 32	jsr $32b5			jsr 	StackSaveCurrentPosition
.2ef1	4c 06 2f	jmp $2f06			jmp 	PerformGOTO
.2ef4					CommandReturn:
.2ef4	fa		plx				plx
.2ef5	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.2ef7	20 9a 2e	jsr $2e9a			jsr 	StackFindFrame
.2efa	20 c6 32	jsr $32c6			jsr 	StackLoadCurrentPosition
.2efd	c8		iny				iny
.2efe	c8		iny				iny
.2eff	20 8c 2e	jsr $2e8c			jsr 	StackCloseFrame
.2f02	4c a2 29	jmp $29a2			jmp 	NextCommand
.2f05					CommandXGoto:
.2f05	fa		plx				plx
.2f06					PerformGOTO:
.2f06	c8		iny				iny 								; push MSB of offset on stack
.2f07	b1 22		lda ($22),y			lda 	(codePtr),y
.2f09	48		pha				pha
.2f0a	88		dey				dey 								; point LSB of offset
.2f0b	18		clc				clc 								; add LSB
.2f0c	b1 22		lda ($22),y			lda 	(codePtr),y
.2f0e	65 22		adc $22				adc 	codePtr
.2f10	85 22		sta $22				sta 	codePtr
.2f12	68		pla				pla 								; restore offset MSB and add
.2f13	65 23		adc $23				adc 	codePtr+1
.2f15	85 23		sta $23				sta 	codePtr+1
.2f17	4c a2 29	jmp $29a2			jmp 	NextCommand
.2f1a					CommandGotoZ:
.2f1a	fa		plx				plx
.2f1b	20 98 17	jsr $1798			jsr 	FloatIsZero
.2f1e	ca		dex				dex
.2f1f	c9 00		cmp #$00			cmp 	#0
.2f21	f0 e3		beq $2f06			beq 	PerformGOTO
.2f23	c8		iny				iny
.2f24	c8		iny				iny
.2f25	4c a2 29	jmp $29a2			jmp 	NextCommand
.2f28					CommandGotoNZ:
.2f28	fa		plx				plx
.2f29	20 98 17	jsr $1798			jsr 	FloatIsZero
.2f2c	ca		dex				dex
.2f2d	c9 00		cmp #$00			cmp 	#0
.2f2f	d0 d5		bne $2f06			bne 	PerformGOTO
.2f31	c8		iny				iny
.2f32	c8		iny				iny
.2f33	4c a2 29	jmp $29a2			jmp 	NextCommand
.2f36					Command_PSET:
.2f36	fa		plx				plx
.2f37	5a		phy				phy
.2f38	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; get the colour
.2f3b	48		pha				pha
.2f3c	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.2f3e	a0 02		ldy #$02			ldy 	#X16_r0
.2f40	20 c2 2f	jsr $2fc2			jsr 	GraphicsCopy2
.2f43	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.2f46	68		pla				pla 								; set pixel.
.2f47	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.2f4a	7a		ply				ply
.2f4b	a2 ff		ldx #$ff			ldx 	#$FF
.2f4d	4c a2 29	jmp $29a2			jmp 	NextCommand
.2f50					Command_LINE:
.2f50	fa		plx				plx
.2f51	5a		phy				phy
.2f52	20 b5 2f	jsr $2fb5			jsr 	GraphicsColour
.2f55	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.2f57	a0 02		ldy #$02			ldy 	#X16_r0
.2f59	20 bf 2f	jsr $2fbf			jsr 	GraphicsCopy4
.2f5c	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.2f5f	7a		ply				ply
.2f60	a2 ff		ldx #$ff			ldx 	#$FF
.2f62	4c a2 29	jmp $29a2			jmp 	NextCommand
.2f65					Command_RECT:
.2f65	fa		plx				plx
.2f66	5a		phy				phy
.2f67	20 d6 2f	jsr $2fd6			jsr 	GraphicsRectCoords
.2f6a	38		sec				sec
.2f6b	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.2f6e	7a		ply				ply
.2f6f	a2 ff		ldx #$ff			ldx 	#$FF
.2f71	4c a2 29	jmp $29a2			jmp 	NextCommand
.2f74					Command_FRAME:
.2f74	fa		plx				plx
.2f75	5a		phy				phy
.2f76	20 d6 2f	jsr $2fd6			jsr 	GraphicsRectCoords
.2f79	18		clc				clc
.2f7a	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.2f7d	7a		ply				ply
.2f7e	a2 ff		ldx #$ff			ldx 	#$FF
.2f80	4c a2 29	jmp $29a2			jmp 	NextCommand
.2f83					Command_CHAR:
.2f83	fa		plx				plx
.2f84	5a		phy				phy
.2f85	ca		dex				dex  								; set the draw colour
.2f86	20 b5 2f	jsr $2fb5			jsr 	GraphicsColour
.2f89	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.2f8b	a0 02		ldy #$02			ldy 	#X16_r0
.2f8d	20 c2 2f	jsr $2fc2			jsr 	GraphicsCopy2
.2f90	a5 3b		lda $3b				lda 	NSMantissa0+3 				; copy string address to zTemp0
.2f92	85 26		sta $26				sta 	zTemp0
.2f94	a5 47		lda $47				lda 	NSMantissa1+3
.2f96	85 27		sta $27				sta 	zTemp0+1
.2f98	b2 26		lda ($26)			lda 	(zTemp0) 					; count of chars to zTemp1
.2f9a	85 28		sta $28				sta 	zTemp1
.2f9c					_CCLoop:
.2f9c	a5 28		lda $28				lda 	zTemp1 						; done all chars ?
.2f9e	f0 0f		beq $2faf			beq 	_CCExit
.2fa0	c6 28		dec $28				dec 	zTemp1 						; dec counter
.2fa2	e6 26		inc $26				inc 	zTemp0 						; pre-bump pointer
.2fa4	d0 02		bne $2fa8			bne 	_CCNoCarry
.2fa6	e6 27		inc $27				inc 	zTemp0+1
.2fa8					_CCNoCarry:
.2fa8	b2 26		lda ($26)			lda 	(zTemp0) 					; get character
.2faa	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.2fad	80 ed		bra $2f9c			bra 	_CCLoop						; go round.
.2faf					_CCExit:
.2faf	7a		ply				ply
.2fb0	a2 ff		ldx #$ff			ldx 	#$FF
.2fb2	4c a2 29	jmp $29a2			jmp 	NextCommand
.2fb5					GraphicsColour:
.2fb5	20 7e 31	jsr $317e			jsr 	GetInteger8Bit
.2fb8	aa		tax				tax
.2fb9	a0 00		ldy #$00			ldy 	#0
.2fbb	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.2fbe	60		rts				rts
.2fbf					GraphicsCopy4:
.2fbf	20 c2 2f	jsr $2fc2			jsr 	GraphicsCopy2
.2fc2					GraphicsCopy2:
.2fc2	20 c5 2f	jsr $2fc5			jsr 	GraphicsCopy1
.2fc5					GraphicsCopy1:
.2fc5	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.2fc8	b5 38		lda $38,x			lda 	NSMantissa0,x
.2fca	99 00 00	sta $0000,y			sta 	0,y
.2fcd	b5 44		lda $44,x			lda 	NSMantissa1,x
.2fcf	99 01 00	sta $0001,y			sta 	1,y
.2fd2	e8		inx				inx
.2fd3	c8		iny				iny
.2fd4	c8		iny				iny
.2fd5	60		rts				rts
.2fd6					GraphicsRectCoords:
.2fd6	20 b5 2f	jsr $2fb5			jsr 	GraphicsColour 				; set colour
.2fd9	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.2fdb	a0 02		ldy #$02			ldy 	#X16_r0
.2fdd	20 bf 2f	jsr $2fbf			jsr 	GraphicsCopy4
.2fe0	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.2fe2	20 ef 2f	jsr $2fef			jsr 	_GRCSortSubtract
.2fe5	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.2fe7	20 ef 2f	jsr $2fef			jsr 	_GRCSortSubtract
.2fea	74 08		stz $08,x			stz 	8,x 						; zero rounding
.2fec	74 09		stz $09,x			stz 	9,x
.2fee	60		rts				rts
.2fef					_GRCSortSubtract:
.2fef	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.2ff1	d5 00		cmp $00,x			cmp 	0,x
.2ff3	b5 05		lda $05,x			lda 	5,x
.2ff5	f5 01		sbc $01,x			sbc 	1,x
.2ff7	b0 08		bcs $3001			bcs 	_GRCNoSwap 					; >= swap.
.2ff9	20 0f 30	jsr $300f			jsr 	_GRCSwapByte 				; swap 0/2
.2ffc	e8		inx				inx
.2ffd	20 0f 30	jsr $300f			jsr 	_GRCSwapByte 				; swap 1/3
.3000	ca		dex				dex
.3001					_GRCNoSwap:
.3001	38		sec				sec 								; calculate width/height into 4,5
.3002	b5 04		lda $04,x			lda 	4,x
.3004	f5 00		sbc $00,x			sbc 	0,x
.3006	95 04		sta $04,x			sta 	4,x
.3008	b5 05		lda $05,x			lda 	5,x
.300a	f5 01		sbc $01,x			sbc 	1,x
.300c	95 05		sta $05,x			sta 	5,x
.300e	60		rts				rts
.300f					_GRCSwapByte:
.300f	b5 04		lda $04,x			lda 	4,x
.3011	48		pha				pha
.3012	b5 00		lda $00,x			lda 	0,x
.3014	95 04		sta $04,x			sta 	4,x
.3016	68		pla				pla
.3017	95 00		sta $00,x			sta 	0,x
.3019	60		rts				rts
.301a					Unary16Hex:
.301a	fa		plx				plx
.301b	20 84 31	jsr $3184			jsr 	GetInteger16Bit
.301e	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.3020	20 4e 38	jsr $384e			jsr 	StringAllocTemp
.3023	a5 27		lda $27				lda 	zTemp0+1
.3025	f0 03		beq $302a			beq 	_UHNoHigh
.3027	20 32 30	jsr $3032			jsr 	_UHWriteHex
.302a					_UHNoHigh:
.302a	a5 26		lda $26				lda 	zTemp0
.302c	20 32 30	jsr $3032			jsr 	_UHWriteHex
.302f	4c a2 29	jmp $29a2			jmp 	NextCommand
.3032					_UHWriteHex:
.3032	48		pha				pha
.3033	4a		lsr a				lsr 	a
.3034	4a		lsr a				lsr 	a
.3035	4a		lsr a				lsr 	a
.3036	4a		lsr a				lsr 	a
.3037	20 3b 30	jsr $303b			jsr 	_UHWriteNibl
.303a	68		pla				pla
.303b					_UHWriteNibl:
.303b	29 0f		and #$0f			and 	#15
.303d	c9 0a		cmp #$0a			cmp 	#10
.303f	90 02		bcc $3043			bcc 	_UHDigit
.3041	69 06		adc #$06			adc 	#6
.3043					_UHDigit:
.3043	69 30		adc #$30			adc 	#48
.3045	20 77 38	jsr $3877			jsr 	StringWriteChar
.3048	60		rts				rts
.3049					IndFloatRead:
.3049	fa		plx				plx
.304a	b5 38		lda $38,x			lda 	NSMantissa0,x 				; copy address
.304c	85 26		sta $26				sta 	zTemp0
.304e	b5 44		lda $44,x			lda 	NSMantissa1,x
.3050	18		clc				clc
.3051	6d 67 05	adc $0567			adc 	variableStartPage
.3054	85 27		sta $27				sta 	zTemp0+1
.3056	ca		dex				dex 								; throw the address
.3057	20 2d 36	jsr $362d			jsr 	ReadFloatZTemp0Sub 							; call read routine
.305a	4c a2 29	jmp $29a2			jmp 	NextCommand
.305d					IndInt16Read:
.305d	fa		plx				plx
.305e	b5 38		lda $38,x			lda 	NSMantissa0,x 				; copy address
.3060	85 26		sta $26				sta 	zTemp0
.3062	b5 44		lda $44,x			lda 	NSMantissa1,x
.3064	18		clc				clc
.3065	6d 67 05	adc $0567			adc 	variableStartPage
.3068	85 27		sta $27				sta 	zTemp0+1
.306a	ca		dex				dex 								; throw the address
.306b	20 69 36	jsr $3669			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.306e	4c a2 29	jmp $29a2			jmp 	NextCommand
.3071					IndStringRead:
.3071	fa		plx				plx
.3072	b5 38		lda $38,x			lda 	NSMantissa0,x 				; copy address
.3074	85 26		sta $26				sta 	zTemp0
.3076	b5 44		lda $44,x			lda 	NSMantissa1,x
.3078	18		clc				clc
.3079	6d 67 05	adc $0567			adc 	variableStartPage
.307c	85 27		sta $27				sta 	zTemp0+1
.307e	ca		dex				dex 								; throw the address
.307f	20 ae 36	jsr $36ae			jsr 	ReadStringZTemp0Sub 							; call read routine
.3082	4c a2 29	jmp $29a2			jmp 	NextCommand
.3085					IndFloatWrite:
.3085	fa		plx				plx
.3086	b5 37		lda $37,x			lda 	NSMantissa0-1,x 			; copy address
.3088	85 26		sta $26				sta 	zTemp0
.308a	b5 43		lda $43,x			lda 	NSMantissa1-1,x
.308c	18		clc				clc
.308d	6d 67 05	adc $0567			adc 	variableStartPage
.3090	85 27		sta $27				sta 	zTemp0+1
.3092	20 08 3c	jsr $3c08			jsr 	WriteFloatZTemp0Sub 							; call write routine
.3095	ca		dex				dex 								; throw the address as well.
.3096	4c a2 29	jmp $29a2			jmp 	NextCommand
.3099					IndInt16Write:
.3099	fa		plx				plx
.309a	b5 37		lda $37,x			lda 	NSMantissa0-1,x 			; copy address
.309c	85 26		sta $26				sta 	zTemp0
.309e	b5 43		lda $43,x			lda 	NSMantissa1-1,x
.30a0	18		clc				clc
.30a1	6d 67 05	adc $0567			adc 	variableStartPage
.30a4	85 27		sta $27				sta 	zTemp0+1
.30a6	20 44 3c	jsr $3c44			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.30a9	ca		dex				dex 								; throw the address as well.
.30aa	4c a2 29	jmp $29a2			jmp 	NextCommand
.30ad					IndStringWrite:
.30ad	fa		plx				plx
.30ae	b5 37		lda $37,x			lda 	NSMantissa0-1,x 			; copy address
.30b0	85 26		sta $26				sta 	zTemp0
.30b2	b5 43		lda $43,x			lda 	NSMantissa1-1,x
.30b4	18		clc				clc
.30b5	6d 67 05	adc $0567			adc 	variableStartPage
.30b8	85 27		sta $27				sta 	zTemp0+1
.30ba	20 83 3c	jsr $3c83			jsr 	WriteStringZTemp0Sub 							; call write routine
.30bd	ca		dex				dex 								; throw the address as well.
.30be	4c a2 29	jmp $29a2			jmp 	NextCommand
.30c1					CommandXInput:
.30c1	fa		plx				plx
.30c2	5a		phy				phy 								; save Y
.30c3	e8		inx				inx									; space on stack
.30c4					_INError:
.30c4	20 f8 30	jsr $30f8			jsr 	InputStringToBuffer 		; input from keyboard
.30c7	a9 bf		lda #$bf			lda 	#((ReadBufferSize) & $FF)
.30c9	85 26		sta $26				sta 	0+zTemp0
.30cb	a9 05		lda #$05			lda 	#((ReadBufferSize) >> 8) & $FF
.30cd	85 27		sta $27				sta 	1+zTemp0
.30cf	20 95 3a	jsr $3a95			jsr 	ValEvaluateZTemp0
.30d2	b0 f0		bcs $30c4			bcs 	_INError 					; failed, try again.
.30d4	7a		ply				ply 								; restore Y
.30d5	4c a2 29	jmp $29a2			jmp 	NextCommand
.30d8					CommandInputString:
.30d8	fa		plx				plx
.30d9	5a		phy				phy 								; save Y
.30da	20 f8 30	jsr $30f8			jsr 	InputStringToBuffer 		; input from keyboard
.30dd	e8		inx				inx 								; make space on stack
.30de	20 76 17	jsr $1776			jsr 	FloatSetZero 				; store as string on stack
.30e1	a9 bf		lda #$bf			lda 	#ReadBufferSize & $FF
.30e3	95 38		sta $38,x			sta 	NSMantissa0,x
.30e5	a9 05		lda #$05			lda 	#ReadBufferSize >> 8
.30e7	95 44		sta $44,x			sta 	NSMantissa1,x
.30e9	a9 40		lda #$40			lda 	#NSSString
.30eb	95 2c		sta $2c,x			sta 	NSStatus,x
.30ed	7a		ply				ply 								; restore Y
.30ee	4c a2 29	jmp $29a2			jmp 	NextCommand
.30f1					CommandInputReset:
.30f1	fa		plx				plx
.30f2	9c 6a 05	stz $056a			stz 	InputBuffer
.30f5	4c a2 29	jmp $29a2			jmp 	NextCommand
.30f8					InputStringToBuffer:
.30f8	a9 32		lda #$32			lda 	#((InputBumpNext) & $FF)
.30fa	8d bf 06	sta $06bf			sta 	0+ReadBumpNextVec
.30fd	a9 31		lda #$31			lda 	#((InputBumpNext) >> 8) & $FF
.30ff	8d c0 06	sta $06c0			sta 	1+ReadBumpNextVec
.3102	a9 0f		lda #$0f			lda 	#((InputLookNext) & $FF)
.3104	8d c1 06	sta $06c1			sta 	0+ReadLookNextVec
.3107	a9 31		lda #$31			lda 	#((InputLookNext) >> 8) & $FF
.3109	8d c2 06	sta $06c2			sta 	1+ReadLookNextVec
.310c	4c 8a 35	jmp $358a			jmp 	GetStringToBuffer
.310f					InputLookNext:
.310f	da		phx				phx
.3110					_ILNRetry:
.3110	ad 6a 05	lda $056a			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.3113	d0 08		bne $311d			bne 	_ILNNotEmpty
.3115	20 36 31	jsr $3136			jsr 	InputGetNewLine 			; get a new line
.3118	9c bb 05	stz $05bb			stz 	InputBufferPos 				; reset read position.
.311b	80 f3		bra $3110			bra 	_ILNRetry
.311d					_ILNNotEmpty:
.311d	ae bb 05	ldx $05bb			ldx 	InputBufferPos 				; get head available character
.3120	bd 6a 05	lda $056a,x			lda 	InputBuffer,x
.3123	d0 08		bne $312d			bne 	_ILNExit 					; if not EOS return it with CC.
.3125					_ILNNextLine:
.3125	9c 6a 05	stz $056a			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.3128	38		sec				sec 								; return CS,Zero
.3129	fa		plx				plx
.312a	a9 0d		lda #$0d			lda 	#13
.312c	60		rts				rts
.312d					_ILNExit:
.312d	fa		plx				plx
.312e	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.3130	18		clc				clc
.3131	60		rts				rts
.3132					InputBumpNext:
.3132	ee bb 05	inc $05bb			inc 	InputBufferPos
.3135	60		rts				rts
.3136					InputGetNewLine:
.3136	48		pha				pha
.3137	da		phx				phx
.3138	5a		phy				phy
.3139	a9 3f		lda #$3f			lda 	#"?"
.313b	20 75 31	jsr $3175			jsr 	IGNLEchoIfScreen
.313e	a0 00		ldy #$00			ldy 	#0 							; line position.
.3140					_IGNLLoop:
.3140	20 b4 34	jsr $34b4			jsr 	VectorGetCharacter 			; get a character
.3143	c9 00		cmp #$00			cmp 	#0
.3145	f0 f9		beq $3140			beq 	_IGNLLoop
.3147	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.3149	f0 11		beq $315c			beq 	_IGNBackspace
.314b	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.314d	f0 17		beq $3166			beq 	_IGNExit
.314f	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.3151	f0 ed		beq $3140			beq 	_IGNLLoop
.3153	99 6a 05	sta $056a,y			sta 	InputBuffer,y
.3156	c8		iny				iny
.3157	20 75 31	jsr $3175			jsr 	IGNLEchoIfScreen
.315a	80 e4		bra $3140			bra 	_IGNLLoop
.315c					_IGNBackspace:
.315c	c0 00		cpy #$00			cpy 	#0
.315e	f0 e0		beq $3140			beq 	_IGNLLoop
.3160	20 75 31	jsr $3175			jsr 	IGNLEchoIfScreen
.3163	88		dey				dey
.3164	80 da		bra $3140			bra 	_IGNLLoop
.3166					_IGNExit:
.3166	20 75 31	jsr $3175			jsr 	IGNLEchoIfScreen
.3169	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.316b	99 6a 05	sta $056a,y			sta 	InputBuffer,y
.316e	9c bb 05	stz $05bb			stz 	InputBufferPos 				; reset position to start of input buffer.
.3171	7a		ply				ply
.3172	fa		plx				plx
.3173	68		pla				pla
.3174	60		rts				rts
.3175					IGNLEchoIfScreen:
.3175	ae bd 05	ldx $05bd			ldx 	currentChannel
.3178	d0 03		bne $317d			bne 	_IGNLEExit
.317a	20 ab 34	jsr $34ab			jsr 	VectorPrintCharacter
.317d					_IGNLEExit:
.317d	60		rts				rts
.056a					InputBuffer:
>056a							.fill 	81
.05bb					InputBufferPos:
>05bb							.fill 	1
.317e					GetInteger8Bit:
.317e	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.3181	b5 38		lda $38,x			lda 	NSMantissa0,x
.3183	60		rts				rts
.3184					GetInteger16Bit:
.3184	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.3187	34 2c		bit $2c,x			bit 	NSStatus,x
.3189	30 09		bmi $3194			bmi 	Negate16Bit
.318b	b5 38		lda $38,x			lda 	NSMantissa0,x
.318d	85 26		sta $26				sta 	zTemp0
.318f	b5 44		lda $44,x			lda 	NSMantissa1,x
.3191	85 27		sta $27				sta 	zTemp0+1
.3193	60		rts				rts
.3194					Negate16Bit:
.3194	38		sec				sec
.3195	a9 00		lda #$00			lda 	#0
.3197	f5 38		sbc $38,x			sbc 	NSMantissa0,x
.3199	95 38		sta $38,x			sta 	NSMantissa0,x
.319b	85 26		sta $26				sta 	zTemp0
.319d	a9 00		lda #$00			lda 	#0
.319f	f5 44		sbc $44,x			sbc 	NSMantissa1,x
.31a1	95 44		sta $44,x			sta 	NSMantissa1,x
.31a3	85 27		sta $27				sta 	zTemp0+1
.31a5	60		rts				rts
.31a6					UnaryJoy:
.31a6	fa		plx				plx
.31a7	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; port #
.31aa	48		pha				pha 								; zero the result.
.31ab	20 76 17	jsr $1776			jsr 	FloatSetZero
.31ae	68		pla				pla
.31af	5a		phy				phy
.31b0	da		phx				phx
.31b1	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.31b4	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.31b6	d0 10		bne $31c8			bne 	_UJNoHardware
.31b8	a8		tay				tay 								; move XA -> AY
.31b9	8a		txa				txa
.31ba	fa		plx				plx 								; we can update it now.
.31bb	49 ff		eor #$ff			eor 	#$FF
.31bd	95 44		sta $44,x			sta 	NSMantissa1,x
.31bf	98		tya				tya
.31c0	49 ff		eor #$ff			eor 	#$FF
.31c2	95 38		sta $38,x			sta 	NSMantissa0,x
.31c4	7a		ply				ply 								; restore Y
.31c5	4c a2 29	jmp $29a2			jmp 	NextCommand
.31c8					_UJNoHardware:
.31c8	fa		plx				plx
.31c9	7a		ply				ply
.31ca	a9 01		lda #$01			lda 	#1 							; set result to -1
.31cc	20 78 17	jsr $1778			jsr 	FloatSetByte
.31cf	20 38 17	jsr $1738			jsr 	FloatNegate
.31d2	4c a2 29	jmp $29a2			jmp 	NextCommand
.31d5					UnaryLen:
.31d5	fa		plx				plx
.31d6	b5 38		lda $38,x			lda 	NSMantissa0,x 				; string address.
.31d8	85 26		sta $26				sta 	zTemp0
.31da	b5 44		lda $44,x			lda 	NSMantissa1,x
.31dc	85 27		sta $27				sta 	zTemp0+1
.31de	b2 26		lda ($26)			lda 	(zTemp0) 					; get length
.31e0	20 78 17	jsr $1778			jsr 	FloatSetByte
.31e3	4c a2 29	jmp $29a2			jmp 	NextCommand
.31e6					LinkFloatAdd:
.31e6	fa		plx				plx
.31e7	5a		phy			phy
.31e8	20 9a 11	jsr $119a		jsr	FloatAdd
.31eb	7a		ply			ply
.31ec	4c a2 29	jmp $29a2			jmp 	NextCommand
.31ef					LinkFloatSubtract:
.31ef	fa		plx				plx
.31f0	5a		phy			phy
.31f1	20 94 11	jsr $1194		jsr	FloatSubtract
.31f4	7a		ply			ply
.31f5	4c a2 29	jmp $29a2			jmp 	NextCommand
.31f8					LinkFloatMultiply:
.31f8	fa		plx				plx
.31f9	5a		phy			phy
.31fa	20 36 14	jsr $1436		jsr	FloatMultiply
.31fd	7a		ply			ply
.31fe	4c a2 29	jmp $29a2			jmp 	NextCommand
.3201					LinkFloatDivide:
.3201	fa		plx				plx
.3202	5a		phy			phy
.3203	20 bf 12	jsr $12bf		jsr	FloatDivide
.3206	b0 5c		bcs $3264		bcs	DivZeroError
.3208	7a		ply			ply
.3209	4c a2 29	jmp $29a2			jmp 	NextCommand
.320c					LinkFloatPower:
.320c	fa		plx				plx
.320d	5a		phy			phy
.320e	20 3f 1a	jsr $1a3f		jsr	FloatPower
.3211	b0 4e		bcs $3261		bcs	MapRangeError
.3213	7a		ply			ply
.3214	4c a2 29	jmp $29a2			jmp 	NextCommand
.3217					LinkCompareGreater:
.3217	fa		plx				plx
.3218	5a		phy			phy
.3219	20 43 12	jsr $1243		jsr	CompareGreater
.321c	7a		ply			ply
.321d	4c a2 29	jmp $29a2			jmp 	NextCommand
.3220					LinkCompareEqual:
.3220	fa		plx				plx
.3221	5a		phy			phy
.3222	20 25 12	jsr $1225		jsr	CompareEqual
.3225	7a		ply			ply
.3226	4c a2 29	jmp $29a2			jmp 	NextCommand
.3229					LinkCompareLess:
.3229	fa		plx				plx
.322a	5a		phy			phy
.322b	20 3b 12	jsr $123b		jsr	CompareLess
.322e	7a		ply			ply
.322f	4c a2 29	jmp $29a2			jmp 	NextCommand
.3232					LinkCompareGreaterEqual:
.3232	fa		plx				plx
.3233	5a		phy			phy
.3234	20 53 12	jsr $1253		jsr	CompareGreaterEqual
.3237	7a		ply			ply
.3238	4c a2 29	jmp $29a2			jmp 	NextCommand
.323b					LinkCompareNotEqual:
.323b	fa		plx				plx
.323c	5a		phy			phy
.323d	20 35 12	jsr $1235		jsr	CompareNotEqual
.3240	7a		ply			ply
.3241	4c a2 29	jmp $29a2			jmp 	NextCommand
.3244					LinkCompareLessEqual:
.3244	fa		plx				plx
.3245	5a		phy			phy
.3246	20 4b 12	jsr $124b		jsr	CompareLessEqual
.3249	7a		ply			ply
.324a	4c a2 29	jmp $29a2			jmp 	NextCommand
.324d					LinkFloatIntegerPartDown:
.324d	fa		plx				plx
.324e	5a		phy			phy
.324f	20 d5 13	jsr $13d5		jsr	FloatIntegerPartDown
.3252	7a		ply			ply
.3253	4c a2 29	jmp $29a2			jmp 	NextCommand
.3256					LinkFloatSquareRoot:
.3256	fa		plx				plx
.3257	5a		phy			phy
.3258	20 c1 1a	jsr $1ac1		jsr	FloatSquareRoot
.325b	b0 04		bcs $3261		bcs	MapRangeError
.325d	7a		ply			ply
.325e	4c a2 29	jmp $29a2			jmp 	NextCommand
.3261					MapRangeError:
.3261	4c 13 10	jmp $1013		jmp	ErrorV_range
.3264					DivZeroError:
.3264	4c 9c 10	jmp $109c		jmp	ErrorV_divzero
.3267					LinkFloatLogarithm:
.3267	fa		plx				plx
.3268	5a		phy			phy
.3269	20 cb 19	jsr $19cb		jsr	FloatLogarithm
.326c	b0 f3		bcs $3261		bcs	MapRangeError
.326e	7a		ply			ply
.326f	4c a2 29	jmp $29a2			jmp 	NextCommand
.3272					LinkFloatExponent:
.3272	fa		plx				plx
.3273	5a		phy			phy
.3274	20 c8 18	jsr $18c8		jsr	FloatExponent
.3277	7a		ply			ply
.3278	4c a2 29	jmp $29a2			jmp 	NextCommand
.327b					LinkFloatCosine:
.327b	fa		plx				plx
.327c	5a		phy			phy
.327d	20 bc 18	jsr $18bc		jsr	FloatCosine
.3280	7a		ply			ply
.3281	4c a2 29	jmp $29a2			jmp 	NextCommand
.3284					LinkFloatSine:
.3284	fa		plx				plx
.3285	5a		phy			phy
.3286	20 5c 1a	jsr $1a5c		jsr	FloatSine
.3289	7a		ply			ply
.328a	4c a2 29	jmp $29a2			jmp 	NextCommand
.328d					LinkFloatTangent:
.328d	fa		plx				plx
.328e	5a		phy			phy
.328f	20 cd 1a	jsr $1acd		jsr	FloatTangent
.3292	7a		ply			ply
.3293	4c a2 29	jmp $29a2			jmp 	NextCommand
.3296					LinkFloatArcTan:
.3296	fa		plx				plx
.3297	5a		phy			phy
.3298	20 a1 17	jsr $17a1		jsr	FloatArcTan
.329b	b0 c4		bcs $3261		bcs	MapRangeError
.329d	7a		ply			ply
.329e	4c a2 29	jmp $29a2			jmp 	NextCommand
.32a1					LinkFloatCompare:
.32a1	fa		plx				plx
.32a2	5a		phy			phy
.32a3	20 5b 12	jsr $125b		jsr	FloatCompare
.32a6	7a		ply			ply
.32a7	4c a2 29	jmp $29a2			jmp 	NextCommand
.32aa					LinkDivideInt32:
.32aa	fa		plx				plx
.32ab	5a		phy			phy
.32ac	20 e9 12	jsr $12e9		jsr	DivideInt32
.32af	b0 b0		bcs $3261		bcs	MapRangeError
.32b1	7a		ply			ply
.32b2	4c a2 29	jmp $29a2			jmp 	NextCommand
.32b5					StackSaveCurrentPosition:
.32b5	20 0d 2a	jsr $2a0d			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.32b8	5a		phy				phy
.32b9	a0 02		ldy #$02			ldy 	#2
.32bb	a5 22		lda $22				lda 	codePtr
.32bd	91 78		sta ($78),y			sta 	(runtimeStackPtr),y
.32bf	c8		iny				iny
.32c0	a5 23		lda $23				lda 	codePtr+1
.32c2	91 78		sta ($78),y			sta 	(runtimeStackPtr),y
.32c4	7a		ply				ply
.32c5	60		rts				rts
.32c6					StackLoadCurrentPosition:
.32c6	a0 02		ldy #$02			ldy 	#2
.32c8	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.32ca	85 22		sta $22				sta 	codePtr
.32cc	c8		iny				iny
.32cd	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.32cf	85 23		sta $23				sta 	codePtr+1
.32d1	a0 00		ldy #$00			ldy 	#0
.32d3	60		rts				rts
.32d4					XCommandMouse:
.32d4	fa		plx				plx
.32d5	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; mouse control.
.32d8	ca		dex				dex
.32d9	da		phx				phx
.32da	5a		phy				phy
.32db	48		pha				pha
.32dc	38		sec				sec 								; get screen resolution
.32dd	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.32e0	68		pla				pla
.32e1	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.32e4	7a		ply				ply
.32e5	fa		plx				plx
.32e6	4c a2 29	jmp $29a2			jmp 	NextCommand
.32e9					XUnaryMB:
.32e9	fa		plx				plx
.32ea	20 18 33	jsr $3318			jsr 	XUnaryMouseCommon
.32ed	a5 2a		lda $2a				lda 	zTemp2
.32ef	e8		inx				inx
.32f0	20 78 17	jsr $1778			jsr 	FloatSetByte
.32f3	4c a2 29	jmp $29a2			jmp 	NextCommand
.32f6					XUnaryMX:
.32f6	fa		plx				plx
.32f7	20 18 33	jsr $3318			jsr 	XUnaryMouseCommon
.32fa	a5 26		lda $26				lda 	zTemp0
.32fc	e8		inx				inx
.32fd	20 78 17	jsr $1778			jsr 	FloatSetByte
.3300	a5 27		lda $27				lda 	zTemp0+1
.3302	95 44		sta $44,x			sta 	NSMantissa1,x
.3304	4c a2 29	jmp $29a2			jmp 	NextCommand
.3307					XUnaryMY:
.3307	fa		plx				plx
.3308	20 18 33	jsr $3318			jsr 	XUnaryMouseCommon
.330b	a5 28		lda $28				lda 	zTemp1
.330d	e8		inx				inx
.330e	20 78 17	jsr $1778			jsr 	FloatSetByte
.3311	a5 29		lda $29				lda 	zTemp1+1
.3313	95 44		sta $44,x			sta 	NSMantissa1,x
.3315	4c a2 29	jmp $29a2			jmp 	NextCommand
.3318					XUnaryMouseCommon:
.3318	da		phx				phx
.3319	5a		phy				phy
.331a	a2 26		ldx #$26			ldx 	#zTemp0
.331c	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.331f	85 2a		sta $2a				sta 	zTemp2
.3321	7a		ply				ply
.3322	fa		plx				plx
.3323	60		rts				rts
.3324					NegateTOS:
.3324	fa		plx				plx
.3325	20 38 17	jsr $1738			jsr 	FloatNegate
.3328	4c a2 29	jmp $29a2			jmp 	NextCommand
.332b					CommandNewLine:
.332b	fa		plx				plx
.332c	9c c8 06	stz $06c8			stz 	stringInitialised
.332f	a2 ff		ldx #$ff			ldx 	#$FF
.3331	4c a2 29	jmp $29a2			jmp 	NextCommand
.3334					CommandXNext:
.3334	fa		plx				plx
.3335					_CNRetry:
.3335	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.3337	20 9a 2e	jsr $2e9a			jsr 	StackFindFrame
.333a	20 0d 2a	jsr $2a0d			jsr 	FixUpY 						; so we can use Y
.333d	b5 38		lda $38,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.333f	35 44		and $44,x			and 	NSMantissa1,x
.3341	c9 ff		cmp #$ff			cmp 	#$FF
.3343	f0 16		beq $335b			beq 	_CNNoIndexVariable
.3345	b5 38		lda $38,x			lda 	NSMantissa0,x
.3347	a0 05		ldy #$05			ldy 	#5
.3349	d1 78		cmp ($78),y			cmp 	(runtimeStackPtr),y
.334b	d0 07		bne $3354			bne 	_CNNIndexFail
.334d	b5 44		lda $44,x			lda 	NSMantissa1,x
.334f	c8		iny				iny
.3350	d1 78		cmp ($78),y			cmp 	(runtimeStackPtr),y
.3352	f0 07		beq $335b			beq 	_CNNoIndexVariable
.3354					_CNNIndexFail:
.3354	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.3356	20 8c 2e	jsr $2e8c			jsr 	StackCloseFrame 			; close this frame
.3359	80 da		bra $3335			bra 	_CNRetry
.335b					_CNNoIndexVariable:
.335b	ca		dex				dex
.335c	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.335e	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.3360	29 40		and #$40			and 	#$40	 					; bit 6
.3362	d0 55		bne $33b9			bne 	_CNOptimisedNext
.3364	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.3366	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.3368	48		pha				pha
.3369	85 26		sta $26				sta 	zTemp0
.336b	c8		iny				iny
.336c	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.336e	18		clc				clc
.336f	6d 67 05	adc $0567			adc 	variableStartPage 			; point to variable page.
.3372	48		pha				pha
.3373	85 27		sta $27				sta 	zTemp0+1
.3375	20 2d 36	jsr $362d			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.3378	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.337a	e8		inx				inx
.337b	20 fc 33	jsr $33fc			jsr 	CopyOffsetYToTOS
.337e	20 9a 11	jsr $119a			jsr 	FloatAdd
.3381	68		pla				pla 								; restore address
.3382	85 27		sta $27				sta 	zTemp0+1
.3384	68		pla				pla
.3385	85 26		sta $26				sta 	zTemp0
.3387	20 08 3c	jsr $3c08			jsr 	WriteFloatZTemp0Sub			; write float.
.338a	e8		inx				inx  								; recover written
.338b	e8		inx				inx 								; load offset
.338c	a0 0d		ldy #$0d			ldy 	#13
.338e	20 fc 33	jsr $33fc			jsr 	CopyOffsetYToTOS
.3391	20 5b 12	jsr $125b			jsr 	FloatCompare 				; and compare the floats.
.3394	ca		dex				dex 								; throw result (in NSMantissa0+1)
.3395	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.3397	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.3399	30 08		bmi $33a3			bmi 	_CNDownStep
.339b	b5 39		lda $39,x			lda 	NSMantissa0+1,x 			; get comparator
.339d	c9 01		cmp #$01			cmp 	#1 							; gone higher
.339f	f0 10		beq $33b1			beq 	_CNExitFor 					; if so exit the loop
.33a1	80 06		bra $33a9			bra 	_CNLoopBack
.33a3					_CNDownStep:
.33a3	b5 39		lda $39,x			lda 	NSMantissa0+1,x 			; get comparator
.33a5	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.33a7	f0 08		beq $33b1			beq 	_CNExitFor
.33a9					_CNLoopBack:
.33a9	20 c6 32	jsr $32c6			jsr 	StackLoadCurrentPosition 	; loop back
.33ac	a0 00		ldy #$00			ldy 	#0
.33ae	4c a2 29	jmp $29a2			jmp 	NextCommand
.33b1					_CNExitFor:
.33b1	20 8c 2e	jsr $2e8c			jsr 	StackCloseFrame 			; remove the frame and exit
.33b4	a0 00		ldy #$00			ldy 	#0
.33b6	4c a2 29	jmp $29a2			jmp 	NextCommand
.33b9					_CNOptimisedNext:
.33b9	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.33bb	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.33bd	85 26		sta $26				sta 	zTemp0
.33bf	c8		iny				iny
.33c0	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.33c2	18		clc				clc
.33c3	6d 67 05	adc $0567			adc 	variableStartPage 			; point to variable page.
.33c6	85 27		sta $27				sta 	zTemp0+1
.33c8	a0 07		ldy #$07			ldy 	#7 							; STEP value
.33ca	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.33cc	a0 ff		ldy #$ff			ldy 	#$FF
.33ce	18		clc				clc
.33cf					_CNOIncrement:
.33cf	c8		iny				iny
.33d0	71 26		adc ($26),y			adc 	(zTemp0),y
.33d2	91 26		sta ($26),y			sta 	(zTemp0),y
.33d4	f0 f9		beq $33cf			beq 	_CNOIncrement
.33d6	18		clc				clc
.33d7	a5 78		lda $78				lda 	runtimeStackPtr
.33d9	69 0d		adc #$0d			adc 	#13
.33db	85 28		sta $28				sta 	zTemp1
.33dd	a5 79		lda $79				lda 	runtimeStackPtr+1
.33df	69 00		adc #$00			adc 	#0
.33e1	85 29		sta $29				sta 	zTemp1+1
.33e3	a0 00		ldy #$00			ldy 	#0
.33e5	b1 28		lda ($28),y			lda 	(zTemp1),y 					; byte 0
.33e7	d1 26		cmp ($26),y			cmp 	(zTemp0),y
.33e9	c8		iny				iny
.33ea	b1 28		lda ($28),y			lda 	(zTemp1),y 					; byte 1
.33ec	f1 26		sbc ($26),y			sbc 	(zTemp0),y
.33ee	c8		iny				iny
.33ef	b1 28		lda ($28),y			lda 	(zTemp1),y 					; byte 2
.33f1	f1 26		sbc ($26),y			sbc 	(zTemp0),y
.33f3	c8		iny				iny
.33f4	b1 28		lda ($28),y			lda 	(zTemp1),y 					; byte 3
.33f6	f1 26		sbc ($26),y			sbc 	(zTemp0),y
.33f8	90 b7		bcc $33b1			bcc	 	_CNExitFor
.33fa	80 ad		bra $33a9			bra 	_CNLoopBack
.33fc					CopyOffsetYToTOS:
.33fc	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.33fe	95 38		sta $38,x			sta 	NSMantissa0,x
.3400	c8		iny				iny
.3401	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.3403	95 44		sta $44,x			sta 	NSMantissa1,x
.3405	c8		iny				iny
.3406	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.3408	95 50		sta $50,x			sta 	NSMantissa2,x
.340a	c8		iny				iny
.340b	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.340d	95 5c		sta $5c,x			sta 	NSMantissa3,x
.340f	c8		iny				iny
.3410	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.3412	95 68		sta $68,x			sta 	NSExponent,x
.3414	c8		iny				iny
.3415	b1 78		lda ($78),y			lda 	(runtimeStackPtr),y
.3417	95 2c		sta $2c,x			sta 	NSStatus,x
.3419	60		rts				rts
.341a	4c a2 29	jmp $29a2			jmp 	NextCommand
.341d					NotTOS:
.341d	fa		plx				plx
.341e	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.3421	74 50		stz $50,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.3423	74 5c		stz $5c,x			stz 	NSMantissa3,x
.3425	20 38 17	jsr $1738			jsr 	FloatNegate		 			; negate
.3428	e8		inx				inx 								; and subtract 1.
.3429	a9 01		lda #$01			lda 	#1
.342b	20 78 17	jsr $1778			jsr 	FloatSetByte
.342e	20 94 11	jsr $1194			jsr 	FloatSubtract
.3431					_NotTOSSkip:
.3431	4c a2 29	jmp $29a2			jmp 	NextCommand
.3434					CommandXOn:
.3434	fa		plx				plx
.3435	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.3438	8d bc 05	sta $05bc			sta 	onCount 					; save it.
.343b	20 0d 2a	jsr $2a0d			jsr 	FixUpY 						; Y = 0
.343e					_CONFind:
.343e	ce bc 05	dec $05bc			dec 	onCount 					; reached zero, do this one
.3441	f0 0b		beq $344e			beq 	_CONFound
.3443	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.3444	c8		iny				iny
.3445	c8		iny				iny
.3446	b1 22		lda ($22),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.3448	c8		iny				iny
.3449	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.344b	f0 f1		beq $343e			beq 	_CONFind
.344d	88		dey				dey 								; point to character after last GOTO/GOSUB
.344e					_CONFound:
.344e	4c a2 29	jmp $29a2			jmp 	NextCommand
.3451					CommandMoreOn:
.3451	fa		plx				plx
.3452	c8		iny				iny 								; so it goes to the first non-goto/gosub
.3453	c8		iny				iny
.3454	c8		iny				iny
.3455	4c a2 29	jmp $29a2			jmp 	NextCommand
.05bc					onCount:
>05bc							.fill 	1
.3458					UnaryPeek:
.3458	fa		plx				plx
.3459	20 84 31	jsr $3184			jsr 	GetInteger16Bit
.345c	da		phx				phx
.345d	5a		phy				phy
.345e	a6 26		ldx $26				ldx 	zTemp0
.3460	a4 27		ldy $27				ldy 	zTemp0+1
.3462	20 99 3d	jsr $3d99			jsr 	XPeekMemory
.3465	7a		ply				ply
.3466	fa		plx				plx
.3467	20 78 17	jsr $1778			jsr 	FloatSetByte
.346a	4c a2 29	jmp $29a2			jmp 	NextCommand
.346d					CommandPOKE:
.346d	fa		plx				plx
.346e	da		phx				phx 								; save XY
.346f	5a		phy				phy
.3470	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.3473	48		pha				pha
.3474	b5 43		lda $43,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.3476	a8		tay				tay
.3477	b5 37		lda $37,x			lda 	NSMantissa0-1,x
.3479	aa		tax				tax
.347a	68		pla				pla
.347b	20 85 3d	jsr $3d85			jsr 	XPokeMemory
.347e	7a		ply				ply 								; restore YX and drop 2
.347f	fa		plx				plx
.3480	ca		dex				dex
.3481	ca		dex				dex
.3482	4c a2 29	jmp $29a2			jmp 	NextCommand
.3485					UnaryPos:
.3485	fa		plx				plx
.3486	20 18 3d	jsr $3d18			jsr 	XGetHPos
.3489	20 78 17	jsr $1778			jsr 	FloatSetByte
.348c	4c a2 29	jmp $29a2			jmp 	NextCommand
.348f					GetChannel:
.348f	fa		plx				plx
.3490	ad bd 05	lda $05bd			lda 	currentChannel
.3493	e8		inx				inx
.3494	20 78 17	jsr $1778			jsr 	FloatSetByte
.3497	4c a2 29	jmp $29a2			jmp 	NextCommand
.349a					SetChannel:
.349a	fa		plx				plx
.349b	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.349e	b5 38		lda $38,x			lda 	NSMantissa0,x
.34a0	8d bd 05	sta $05bd			sta 	currentChannel
.34a3	ca		dex				dex
.34a4	4c a2 29	jmp $29a2			jmp 	NextCommand
.34a7					SetDefaultChannel:
.34a7	9c bd 05	stz $05bd			stz 	currentChannel
.34aa	60		rts				rts
.34ab					VectorPrintCharacter:
.34ab	da		phx				phx
.34ac	ae bd 05	ldx $05bd			ldx 	currentChannel
.34af	20 c3 3d	jsr $3dc3			jsr 	XPrintCharacterToChannel
.34b2	fa		plx				plx
.34b3	60		rts				rts
.34b4					VectorGetCharacter:
.34b4	da		phx				phx
.34b5	ae bd 05	ldx $05bd			ldx 	currentChannel
.34b8	20 fc 3c	jsr $3cfc			jsr 	XGetCharacterFromChannel
.34bb	fa		plx				plx
.34bc	60		rts				rts
.05bd					currentChannel:
>05bd							.fill 	1
.34bd					PrintNumber:
.34bd	fa		plx				plx
.34be	a9 07		lda #$07			lda 	#7
.34c0	20 5e 16	jsr $165e			jsr 	FloatToString 				; to number in decimal buffer
.34c3	ca		dex				dex 								; drop
.34c4	da		phx				phx
.34c5	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.34c7					_PNLoop:
.34c7	bd 29 04	lda $0429,x			lda 	decimalBuffer,x
.34ca	20 ab 34	jsr $34ab			jsr 	VectorPrintCharacter
.34cd	e8		inx				inx
.34ce	bd 29 04	lda $0429,x			lda	 	decimalBuffer,x
.34d1	d0 f4		bne $34c7			bne 	_PNLoop
.34d3	a9 20		lda #$20			lda 	#32 						; trailing space
.34d5	20 ab 34	jsr $34ab			jsr 	VectorPrintCharacter
.34d8	fa		plx				plx
.34d9	4c a2 29	jmp $29a2			jmp 	NextCommand
.34dc					PrintString:
.34dc	fa		plx				plx
.34dd	b5 38		lda $38,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.34df	85 26		sta $26				sta 	zTemp0
.34e1	b5 44		lda $44,x			lda 	NSMantissa1,x
.34e3	85 27		sta $27				sta 	zTemp0+1
.34e5	ca		dex				dex 								; drop
.34e6	da		phx				phx
.34e7	5a		phy				phy
.34e8	b2 26		lda ($26)			lda 	(zTemp0) 					; X = count
.34ea	aa		tax				tax
.34eb	a0 01		ldy #$01			ldy 	#1 							; Y = position
.34ed					_PSLoop:
.34ed	e0 00		cpx #$00			cpx 	#0 							; complete ?
.34ef	f0 09		beq $34fa			beq 	_PSExit
.34f1	ca		dex				dex 								; dec count
.34f2	b1 26		lda ($26),y			lda 	(zTemp0),y 					; print char and bump
.34f4	20 ab 34	jsr $34ab			jsr 	VectorPrintCharacter
.34f7	c8		iny				iny
.34f8	80 f3		bra $34ed			bra 	_PSLoop
.34fa					_PSExit:
.34fa	7a		ply				ply
.34fb	fa		plx				plx
.34fc	4c a2 29	jmp $29a2			jmp 	NextCommand
.34ff					CommandPushN:
.34ff	fa		plx				plx
.3500	e8		inx				inx 								; next slot on stack
.3501	b1 22		lda ($22),y			lda 	(codePtr),y 				; exponent
.3503	95 68		sta $68,x			sta 	NSExponent,x
.3505	c8		iny				iny
.3506	b1 22		lda ($22),y			lda 	(codePtr),y 				; mantissa
.3508	95 38		sta $38,x			sta 	NSMantissa0,x
.350a	c8		iny				iny
.350b	b1 22		lda ($22),y			lda 	(codePtr),y
.350d	95 44		sta $44,x			sta 	NSMantissa1,x
.350f	c8		iny				iny
.3510	b1 22		lda ($22),y			lda 	(codePtr),y
.3512	95 50		sta $50,x			sta 	NSMantissa2,x
.3514	c8		iny				iny
.3515	b1 22		lda ($22),y			lda 	(codePtr),y
.3517	48		pha				pha
.3518	29 7f		and #$7f			and 	#$7F
.351a	95 5c		sta $5c,x			sta 	NSMantissa3,x
.351c	68		pla				pla 								; sign in mantissa3:7
.351d	29 80		and #$80			and 	#$80
.351f	95 2c		sta $2c,x			sta 	NSStatus,x
.3521	c8		iny				iny
.3522	4c a2 29	jmp $29a2			jmp 	NextCommand
.3525					CommandPushS:
.3525	fa		plx				plx
.3526	e8		inx				inx 								; next slot on stack
.3527	18		clc				clc
.3528	98		tya				tya
.3529	65 22		adc $22				adc 	codePtr 					; the string is inline
.352b	95 38		sta $38,x			sta 	NSMantissa0,x
.352d	a5 23		lda $23				lda 	codePtr+1
.352f	69 00		adc #$00			adc 	#0
.3531	95 44		sta $44,x			sta 	NSMantissa1,x
.3533	74 50		stz $50,x			stz 	NSMantissa2,x
.3535	74 5c		stz $5c,x			stz 	NSMantissa3,x
.3537	a9 40		lda #$40			lda 	#NSSString
.3539	95 2c		sta $2c,x			sta 	NSStatus,x
.353b	98		tya				tya 								; string length +1 added to Y
.353c	38		sec				sec
.353d	71 22		adc ($22),y			adc 	(codePtr),y 				; next instruction
.353f	a8		tay				tay
.3540	4c a2 29	jmp $29a2			jmp 	NextCommand
.3543					CommandXRead:
.3543	fa		plx				plx
.3544	5a		phy				phy 								; save Y
.3545	20 76 35	jsr $3576			jsr 	ReadStringToBuffer 			; read element into buffer
.3548	e8		inx				inx									; space on stack
.3549	a9 bf		lda #$bf			lda 	#((ReadBufferSize) & $FF)
.354b	85 26		sta $26				sta 	0+zTemp0
.354d	a9 05		lda #$05			lda 	#((ReadBufferSize) >> 8) & $FF
.354f	85 27		sta $27				sta 	1+zTemp0
.3551	20 95 3a	jsr $3a95			jsr 	ValEvaluateZTemp0
.3554	b0 04		bcs $355a			bcs 	_CRError 					; failed
.3556	7a		ply				ply 								; restore Y
.3557	4c a2 29	jmp $29a2			jmp 	NextCommand
.355a					_CRError:
.355a	4c 23 10	jmp $1023		jmp	ErrorV_value
.355d					CommandReadString:
.355d	fa		plx				plx
.355e	5a		phy				phy 								; save Y
.355f	20 76 35	jsr $3576			jsr 	ReadStringToBuffer 			; read text
.3562	e8		inx				inx 								; make space on stack
.3563	20 76 17	jsr $1776			jsr 	FloatSetZero 				; store as string on stack
.3566	a9 bf		lda #$bf			lda 	#ReadBufferSize & $FF
.3568	95 38		sta $38,x			sta 	NSMantissa0,x
.356a	a9 05		lda #$05			lda 	#ReadBufferSize >> 8
.356c	95 44		sta $44,x			sta 	NSMantissa1,x
.356e	a9 40		lda #$40			lda 	#NSSString
.3570	95 2c		sta $2c,x			sta 	NSStatus,x
.3572	7a		ply				ply 								; restore Y
.3573	4c a2 29	jmp $29a2			jmp 	NextCommand
.3576					ReadStringToBuffer:
.3576	a9 09		lda #$09			lda 	#((ReadBumpNext) & $FF)
.3578	8d bf 06	sta $06bf			sta 	0+ReadBumpNextVec
.357b	a9 36		lda #$36			lda 	#((ReadBumpNext) >> 8) & $FF
.357d	8d c0 06	sta $06c0			sta 	1+ReadBumpNextVec
.3580	a9 dc		lda #$dc			lda 	#((ReadLookNext) & $FF)
.3582	8d c1 06	sta $06c1			sta 	0+ReadLookNextVec
.3585	a9 35		lda #$35			lda 	#((ReadLookNext) >> 8) & $FF
.3587	8d c2 06	sta $06c2			sta 	1+ReadLookNextVec
.358a					GetStringToBuffer:
.358a	20 d9 35	jsr $35d9			jsr		GetLookNext 				; skip all leading spaces.
.358d	f0 44		beq $35d3			beq 	_RBError 					; end of data
.358f	b0 f9		bcs $358a			bcs 	GetStringToBuffer 			; switched to new data line.
.3591	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.3593	b0 05		bcs $359a			bcs 	_RBNoSpace
.3595	20 d6 35	jsr $35d6			jsr 	GetBumpNext 				; consume space and loop round.
.3598	80 f0		bra $358a			bra 	GetStringToBuffer
.359a					_RBNoSpace:
.359a	9c bf 05	stz $05bf			stz 	ReadBufferSize 				; empty the buffer.
.359d	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.359f	d0 08		bne $35a9			bne 	_RBCommaSep
.35a1	8d be 05	sta $05be			sta 	ReadSep 					; use as a seperator
.35a4	20 d6 35	jsr $35d6			jsr 	GetBumpNext 				; consume the '"'
.35a7	80 05		bra $35ae			bra 	_RBGetText
.35a9					_RBCommaSep:
.35a9	a9 2c		lda #$2c			lda 	#","						; get till comma
.35ab	8d be 05	sta $05be			sta 	ReadSep
.35ae					_RBGetText:
.35ae	20 d9 35	jsr $35d9			jsr 	GetLookNext 				; what follows
.35b1	b0 18		bcs $35cb			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.35b3	20 d6 35	jsr $35d6			jsr 	GetBumpNext 				; consume it whatever
.35b6	cd be 05	cmp $05be			cmp 	ReadSep 					; if found the seperator.
.35b9	f0 10		beq $35cb			beq 	_RBEndGet 					; exit after consumption
.35bb	da		phx				phx
.35bc	ae bf 05	ldx $05bf			ldx 	ReadBufferSize 				; copy into buffer.
.35bf	ee bf 05	inc $05bf			inc 	ReadBufferSize
.35c2	9d c0 05	sta $05c0,x			sta 	ReadBuffer,x
.35c5	9e c1 05	stz $05c1,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.35c8	fa		plx				plx
.35c9	80 e3		bra $35ae			bra 	_RBGetText
.35cb					_RBEndGet:
.35cb	c9 22		cmp #$22			cmp 	#'"'
.35cd	d0 03		bne $35d2			bne 	_RBNotQuote
.35cf	20 d6 35	jsr $35d6			jsr 	GetBumpNext
.35d2					_RBNotQuote:
.35d2	60		rts				rts
.35d3					_RBError:
.35d3	4c d8 10	jmp $10d8		jmp	ErrorV_data
.35d6					GetBumpNext:
.35d6	6c bf 06	jmp ($06bf)			jmp 	(ReadBumpNextVec)
.35d9					GetLookNext:
.35d9	6c c1 06	jmp ($06c1)			jmp 	(ReadLookNextVec)
.35dc					ReadLookNext:
.35dc	ad c3 06	lda $06c3			lda 	dataRemaining 				; any data remaining
.35df	f0 04		beq $35e5			beq 	_RLNFindData
.35e1	b2 24		lda ($24)			lda 	(objPtr) 					; return that object.
.35e3	18		clc				clc
.35e4	60		rts				rts
.35e5					_RLNFindData:
.35e5	b2 24		lda ($24)			lda 	(objPtr) 					; see where we are
.35e7	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.35e9	f0 1a		beq $3605			beq 	_RLNNoData
.35eb	c9 cf		cmp #$cf			cmp 	#PCD_CMD_DATA 				; Found DATA
.35ed	f0 05		beq $35f4			beq 	_RLNHaveData
.35ef					_RLNNext:
.35ef	20 45 11	jsr $1145			jsr 	MoveObjectForward			; else scan forward.
.35f2	80 f1		bra $35e5			bra 	_RLNFindData
.35f4					_RLNHaveData:
.35f4	a0 01		ldy #$01			ldy 	#1 							; get length
.35f6	b1 24		lda ($24),y			lda 	(objPtr),y
.35f8	f0 f5		beq $35ef			beq 	_RLNNext 					; skip if DATA alone
.35fa	20 09 36	jsr $3609			jsr 	ReadBumpNext 				; advance by two
.35fd	20 09 36	jsr $3609			jsr 	ReadBumpNext
.3600	8d c3 06	sta $06c3			sta 	dataRemaining 				; set data left count.
.3603	38		sec				sec
.3604	60		rts				rts
.3605					_RLNNoData:
.3605	a9 00		lda #$00			lda 	#0
.3607	38		sec				sec
.3608	60		rts				rts
.3609					ReadBumpNext:
.3609	e6 24		inc $24				inc 	objPtr
.360b	d0 02		bne $360f			bne 	_RBNSkip
.360d	e6 25		inc $25				inc 	objPtr+1
.360f					_RBNSkip:
.360f	ce c3 06	dec $06c3			dec 	dataRemaining
.3612	60		rts				rts
.05be					ReadSep:
>05be							.fill 	1
.05bf					ReadBufferSize:
>05bf							.fill 	1
.05c0					ReadBuffer:
>05c0							.fill 	255
.06bf					ReadBumpNextVec:
>06bf							.fill 	2
.06c1					ReadLookNextVec:
>06c1							.fill 	2
.3613					ReadFloatCommand:
.3613	fa		plx				plx
.3614	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.3616	85 26		sta $26				sta 	zTemp0 						; save in MSB
.3618	88		dey				dey 								; get the upper 3 bits
.3619	b1 22		lda ($22),y			lda 	(codePtr),y
.361b	29 07		and #$07			and 	#7
.361d	c8		iny				iny
.361e	c8		iny				iny
.361f	06 26		asl $26				asl 	zTemp0 						; shift zTemp0:A left
.3621	2a		rol a				rol 	a 							; carry will be clear.
.3622	6d 67 05	adc $0567			adc 	variableStartPage			; make it point to variable page.
.3625	85 27		sta $27				sta 	zTemp0+1
.3627	20 2d 36	jsr $362d			jsr 	ReadFloatZTemp0Sub
.362a	4c a2 29	jmp $29a2			jmp 	NextCommand
.362d					ReadFloatZTemp0Sub:
.362d	5a		phy				phy 								; start write
.362e	a0 01		ldy #$01			ldy 	#1
.3630	e8		inx				inx
.3631	b2 26		lda ($26)			lda 	(zTemp0)
.3633	95 38		sta $38,x			sta 	NSMantissa0,x
.3635	b1 26		lda ($26),y			lda 	(zTemp0),y
.3637	95 44		sta $44,x			sta 	NSMantissa1,x
.3639	c8		iny				iny
.363a	b1 26		lda ($26),y			lda 	(zTemp0),y
.363c	95 50		sta $50,x			sta 	NSMantissa2,x
.363e	c8		iny				iny
.363f	b1 26		lda ($26),y			lda 	(zTemp0),y
.3641	95 5c		sta $5c,x			sta 	NSMantissa3,x
.3643	c8		iny				iny
.3644	b1 26		lda ($26),y			lda 	(zTemp0),y
.3646	95 68		sta $68,x			sta 	NSExponent,x
.3648	c8		iny				iny
.3649	b1 26		lda ($26),y			lda 	(zTemp0),y
.364b	95 2c		sta $2c,x			sta 	NSStatus,x
.364d	7a		ply				ply
.364e	60		rts				rts
.364f					ReadIntegerCommand:
.364f	fa		plx				plx
.3650	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.3652	85 26		sta $26				sta 	zTemp0 						; save in MSB
.3654	88		dey				dey 								; get the upper 3 bits
.3655	b1 22		lda ($22),y			lda 	(codePtr),y
.3657	29 07		and #$07			and 	#7
.3659	c8		iny				iny
.365a	c8		iny				iny
.365b	06 26		asl $26				asl 	zTemp0 						; shift zTemp0:A left
.365d	2a		rol a				rol 	a 							; carry will be clear.
.365e	6d 67 05	adc $0567			adc 	variableStartPage			; make it point to variable page.
.3661	85 27		sta $27				sta 	zTemp0+1
.3663	20 69 36	jsr $3669			jsr 	ReadIntegerZTemp0Sub
.3666	4c a2 29	jmp $29a2			jmp 	NextCommand
.3669					ReadIntegerZTemp0Sub:
.3669	5a		phy				phy 								; start write
.366a	a0 01		ldy #$01			ldy 	#1
.366c	e8		inx				inx 								; prepare
.366d	74 50		stz $50,x			stz 	NSMantissa2,x
.366f	74 5c		stz $5c,x			stz 	NSMantissa3,x
.3671	74 68		stz $68,x			stz 	NSExponent,x
.3673	74 2c		stz $2c,x			stz 	NSStatus,x
.3675	b1 26		lda ($26),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.3677	30 08		bmi $3681			bmi 	_RIZNegative
.3679	95 44		sta $44,x			sta 	NSMantissa1,x 				; +ve read
.367b	b2 26		lda ($26)			lda 	(zTemp0)
.367d	95 38		sta $38,x			sta 	NSMantissa0,x
.367f	7a		ply				ply
.3680	60		rts				rts
.3681					_RIZNegative:
.3681	38		sec				sec 								; -ve read
.3682	a9 00		lda #$00			lda 	#0
.3684	f2 26		sbc ($26)			sbc 	(zTemp0)
.3686	95 38		sta $38,x			sta 	NSMantissa0,x
.3688	a9 00		lda #$00			lda 	#0
.368a	f1 26		sbc ($26),y			sbc 	(zTemp0),y
.368c	95 44		sta $44,x			sta 	NSMantissa1,x
.368e	a9 80		lda #$80			lda 	#$80
.3690	95 2c		sta $2c,x			sta 	NSStatus,x
.3692	7a		ply				ply
.3693	60		rts				rts
.3694					ReadStringCommand:
.3694	fa		plx				plx
.3695	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.3697	85 26		sta $26				sta 	zTemp0 						; save in MSB
.3699	88		dey				dey 								; get the upper 3 bits
.369a	b1 22		lda ($22),y			lda 	(codePtr),y
.369c	29 07		and #$07			and 	#7
.369e	c8		iny				iny
.369f	c8		iny				iny
.36a0	06 26		asl $26				asl 	zTemp0 						; shift zTemp0:A left
.36a2	2a		rol a				rol 	a 							; carry will be clear.
.36a3	6d 67 05	adc $0567			adc 	variableStartPage			; make it point to variable page.
.36a6	85 27		sta $27				sta 	zTemp0+1
.36a8	20 ae 36	jsr $36ae			jsr 	ReadStringZTemp0Sub
.36ab	4c a2 29	jmp $29a2			jmp 	NextCommand
.36ae					ReadStringZTemp0Sub:
.36ae	5a		phy				phy 								; start write
.36af	e8		inx				inx 								; prepare
.36b0	74 50		stz $50,x			stz 	NSMantissa2,x
.36b2	74 5c		stz $5c,x			stz 	NSMantissa3,x
.36b4	74 68		stz $68,x			stz 	NSExponent,x
.36b6	a9 40		lda #$40			lda 	#NSSString
.36b8	74 2c		stz $2c,x			stz 	NSStatus,x
.36ba	18		clc				clc
.36bb	b2 26		lda ($26)			lda 	(zTemp0)					; read address of block add 2.
.36bd	69 02		adc #$02			adc 	#2 							; this points to actual data
.36bf	95 38		sta $38,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.36c1	a0 01		ldy #$01			ldy 	#1
.36c3	b1 26		lda ($26),y			lda 	(zTemp0),y
.36c5	69 00		adc #$00			adc 	#0
.36c7	95 44		sta $44,x			sta 	NSMantissa1,x 				; +ve read
.36c9	d0 08		bne $36d3			bne 	_RSZNoDefault 				; if read $00 use a default value.
.36cb	a9 d5		lda #$d5			lda 	#_RSZNull & $FF
.36cd	95 38		sta $38,x			sta 	NSMantissa0,x
.36cf	a9 36		lda #$36			lda 	#_RSZNull >> 8
.36d1	95 44		sta $44,x			sta 	NSMantissa1,x
.36d3					_RSZNoDefault:
.36d3	7a		ply				ply
.36d4	60		rts				rts
.36d5					_RSZNull:
>36d5	00						.byte 	0
.36d6					CommandRestore:
.36d6	fa		plx				plx
.36d7	20 dd 36	jsr $36dd			jsr 	RestoreCode
.36da	4c a2 29	jmp $29a2			jmp 	NextCommand
.36dd					RestoreCode:
.36dd	ad 64 05	lda $0564			lda 	runtimeHigh 				; reset pointer
.36e0	85 25		sta $25				sta 	objPtr+1
.36e2	64 24		stz $24				stz 	objPtr
.36e4	9c c3 06	stz $06c3			stz 	dataRemaining 				; no data remaining.
.36e7	60		rts				rts
.06c3					dataRemaining:
>06c3							.fill 	1		 					; 0 if not in data statement
.36e8					UnaryRND:
.36e8	fa		plx				plx
.36e9	34 2c		bit $2c,x			bit 	NSStatus,x 					; -ve then set seed from operand
.36eb	10 17		bpl $3704			bpl 	_URNoSeed
.36ed	20 cb 14	jsr $14cb			jsr 	FloatNormalise 				; some float value
.36f0	b5 38		lda $38,x			lda 	NSMantissa0,x 				; copy to Mantissa
.36f2	8d c4 06	sta $06c4			sta 	randomSeed+0
.36f5	b5 44		lda $44,x			lda 	NSMantissa1,x
.36f7	8d c5 06	sta $06c5			sta 	randomSeed+1
.36fa	b5 50		lda $50,x			lda 	NSMantissa2,x
.36fc	8d c6 06	sta $06c6			sta 	randomSeed+2
.36ff	b5 5c		lda $5c,x			lda 	NSMantissa3,x
.3701	8d c7 06	sta $06c7			sta 	randomSeed+3
.3704					_URNoSeed:
.3704	20 26 37	jsr $3726			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.3707	ad c4 06	lda $06c4			lda 	randomSeed+0
.370a	95 38		sta $38,x			sta 	NSMantissa0,x
.370c	ad c5 06	lda $06c5			lda 	randomSeed+1
.370f	95 44		sta $44,x			sta 	NSMantissa1,x
.3711	ad c6 06	lda $06c6			lda 	randomSeed+2
.3714	95 50		sta $50,x			sta 	NSMantissa2,x
.3716	ad c7 06	lda $06c7			lda 	randomSeed+3
.3719	29 7f		and #$7f			and 	#$7F
.371b	95 5c		sta $5c,x			sta 	NSMantissa3,x
.371d	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.371f	95 68		sta $68,x			sta 	NSExponent,x
.3721	74 2c		stz $2c,x			stz 	NSStatus,x
.3723	4c a2 29	jmp $29a2			jmp 	NextCommand
.3726					RandomNumberGenerator:
.3726	5a		phy				phy
.3727	ad c4 06	lda $06c4			lda 	randomSeed+0 				; check if zero
.372a	0d c5 06	ora $06c5			ora 	randomSeed+1
.372d	0d c6 06	ora $06c6			ora 	randomSeed+2
.3730	0d c7 06	ora $06c7			ora 	randomSeed+3
.3733	d0 07		bne $373c			bne 	_RNGNoSeed
.3735	ce c7 06	dec $06c7			dec 	randomSeed+3 				; if so tweak and flog
.3738	a0 64		ldy #$64			ldy 	#100
.373a	80 05		bra $3741			bra 	_RNGLoop
.373c					_RNGNoSeed:
.373c	a0 08		ldy #$08			ldy 	#8
.373e	ad c4 06	lda $06c4			lda 	randomSeed+0
.3741					_RNGLoop:
.3741	0a		asl a				asl		a
.3742	2e c5 06	rol $06c5			rol 	randomSeed+1
.3745	2e c6 06	rol $06c6			rol 	randomSeed+2
.3748	2e c7 06	rol $06c7			rol 	randomSeed+3
.374b	90 02		bcc $374f			bcc		_RNGSkip
.374d	49 c5		eor #$c5			eor 	#$C5
.374f					_RNGSkip:
.374f	88		dey				dey
.3750	d0 ef		bne $3741			bne		_RNGLoop
.3752	8d c4 06	sta $06c4			sta 	randomSeed+0
.3755	7a		ply				ply
.3756	60		rts				rts
.06c4					randomSeed:
>06c4							.fill 	4
.3757					StringConcatenate:
.3757	fa		plx				plx
.3758	ca		dex				dex
.3759	b5 38		lda $38,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.375b	85 28		sta $28				sta 	zTemp1
.375d	b5 44		lda $44,x			lda 	NSMantissa1,x
.375f	85 29		sta $29				sta 	zTemp1+1
.3761	b5 39		lda $39,x			lda 	NSMantissa0+1,x
.3763	85 2a		sta $2a				sta 	zTemp2
.3765	b5 45		lda $45,x			lda 	NSMantissa1+1,x
.3767	85 2b		sta $2b				sta 	zTemp2+1
.3769	18		clc				clc 								; work out total length
.376a	b2 28		lda ($28)			lda 	(zTemp1)
.376c	72 2a		adc ($2a)			adc 	(zTemp2)
.376e	b0 18		bcs $3788			bcs 	_BCLength 					; more than 255 characters.
.3770	48		pha				pha 								; save total
.3771	20 4e 38	jsr $384e			jsr 	StringAllocTemp 			; space for result.
.3774	68		pla				pla 								; write total as first.
.3775	92 76		sta ($76)			sta 	(zsTemp)
.3777	20 8b 37	jsr $378b			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.377a	a5 2a		lda $2a				lda 	zTemp2 						; copy address zTemp2->1
.377c	85 28		sta $28				sta 	zTemp1
.377e	a5 2b		lda $2b				lda 	zTemp2+1
.3780	85 29		sta $29				sta 	zTemp1+1
.3782	20 8b 37	jsr $378b			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.3785	4c a2 29	jmp $29a2			jmp 	NextCommand
.3788					_BCLength:
.3788	4c 13 10	jmp $1013		jmp	ErrorV_range
.378b					_BCCopyZTemp1:
.378b	b2 28		lda ($28)			lda 	(zTemp1) 					; bytes to copy
.378d	f0 15		beq $37a4			beq 	_BCCExit 					; none.
.378f	da		phx				phx 								; save XY
.3790	5a		phy				phy
.3791	aa		tax				tax 								; count in X.
.3792	a0 01		ldy #$01			ldy 	#1
.3794					_BCCLoop:
.3794	e6 76		inc $76				inc 	zsTemp 						; bump pointer, pre-increment
.3796	d0 02		bne $379a			bne 	_BCCNoCarry
.3798	e6 77		inc $77				inc 	zsTemp+1
.379a					_BCCNoCarry:
.379a	b1 28		lda ($28),y			lda 	(zTemp1),y				 	; copy bytes
.379c	92 76		sta ($76)			sta 	(zsTemp)
.379e	c8		iny				iny
.379f	ca		dex				dex 								; X times
.37a0	d0 f2		bne $3794			bne 	_BCCLoop
.37a2	7a		ply				ply 								; restore YX
.37a3	fa		plx				plx
.37a4					_BCCExit:
.37a4	60		rts				rts
.37a5					XRuntimeSetup:
.37a5	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.37a7	8d cb 06	sta $06cb	 		sta 	ramBank
.37aa	8d cc 06	sta $06cc	 		sta 	romBank
.37ad	60		rts				rts
.37ae					SignTOS:
.37ae	fa		plx				plx
.37af	20 98 17	jsr $1798			jsr 	FloatIsZero 				; if zero
.37b2	f0 0f		beq $37c3			beq 	_SGZero  					; return Int Zero
.37b4	b5 2c		lda $2c,x			lda 	NSStatus,x 					; get status w/sign
.37b6	48		pha				pha
.37b7	a9 01		lda #$01			lda 	#1 							; set result to 1
.37b9	20 78 17	jsr $1778			jsr 	FloatSetByte
.37bc	68		pla				pla
.37bd	29 80		and #$80			and		#$80 						; copy the sign byte out
.37bf	95 2c		sta $2c,x			sta 	NSStatus,x  				; so it will be -1 or 1
.37c1	80 03		bra $37c6			bra 	_SGExit
.37c3					_SGZero:
.37c3	20 76 17	jsr $1776			jsr 	FloatSetZero
.37c6					_SGExit:
.37c6	4c a2 29	jmp $29a2			jmp 	NextCommand
.37c9					CommandShift:
.37c9	b1 22		lda ($22),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.37cb	c8		iny				iny
.37cc	0a		asl a				asl 	a 							; double into X
.37cd	aa		tax				tax
.37ce	7c 79 3b	jmp ($3b79,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.37d1					PrintTab:
.37d1	fa		plx				plx
.37d2	20 18 3d	jsr $3d18			jsr 	XGetHPos
.37d5					_PTMod10:
.37d5	38		sec				sec
.37d6	e9 0a		sbc #$0a			sbc 	#10
.37d8	b0 fb		bcs $37d5			bcs 	_PTMod10
.37da	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.37dc	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.37dd	80 15		bra $37f4			bra 	PrintSpaceLoop
.37df					PrintPos:
.37df	fa		plx				plx
.37e0	20 18 3d	jsr $3d18			jsr		XGetHPos 					; get current position
.37e3	85 26		sta $26				sta 	zTemp0
.37e5	38		sec				sec 								; calculate spaces required
.37e6	b5 38		lda $38,x			lda 	NSMantissa0,x
.37e8	ca		dex				dex
.37e9	e5 26		sbc $26				sbc 	zTemp0
.37eb	b0 07		bcs $37f4			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.37ed	4c a2 29	jmp $29a2			jmp 	NextCommand
.37f0					PrintSpace:
.37f0	fa		plx				plx
.37f1	b5 38		lda $38,x			lda 	NSMantissa0,x
.37f3	ca		dex				dex
.37f4					PrintSpaceLoop:
.37f4	c9 00		cmp #$00			cmp 	#0
.37f6	f0 0a		beq $3802			beq 	_PSExit
.37f8	48		pha				pha
.37f9	a9 20		lda #$20			lda 	#" "
.37fb	20 ab 34	jsr $34ab			jsr 	VectorPrintCharacter
.37fe	68		pla				pla
.37ff	3a		dec a				dec 	a
.3800	80 f2		bra $37f4			bra 	PrintSpaceLoop
.3802					_PSExit:
.3802	4c a2 29	jmp $29a2			jmp 	NextCommand
.3805					CommandStop:
.3805	fa		plx				plx
.3806	4c c5 10	jmp $10c5		jmp	ErrorV_stop
.3809					Unary_Str:
.3809	fa		plx				plx
.380a	5a		phy				phy
.380b	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.380d	20 5e 16	jsr $165e			jsr 	FloatToString 				; do the conversion.
.3810	a9 21		lda #$21			lda		#33 						; create buffer
.3812	20 4e 38	jsr $384e			jsr 	StringAllocTemp 			; allocate memory
.3815	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.3817					_USCopy:
.3817	b9 28 04	lda $0428,y			lda 	decimalBuffer-1,y
.381a	f0 05		beq $3821			beq 	_USExit
.381c	91 76		sta ($76),y			sta 	(zsTemp),y
.381e	c8		iny				iny
.381f	80 f6		bra $3817			bra 	_USCopy
.3821					_USExit:
.3821	98		tya				tya
.3822	3a		dec a				dec 	a
.3823	92 76		sta ($76)			sta 	(zsTemp)
.3825	7a		ply				ply
.3826	4c a2 29	jmp $29a2			jmp 	NextCommand
.3829					StringInitialise:
.3829	48		pha				pha
.382a	ad c8 06	lda $06c8			lda 	stringInitialised 			; already done
.382d	d0 11		bne $3840			bne 	_SIExit
.382f	ad 62 05	lda $0562			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.3832	8d c9 06	sta $06c9			sta 	stringTempPointer
.3835	ad 63 05	lda $0563			lda 	stringHighMemory+1
.3838	3a		dec a				dec 	a
.3839	3a		dec a				dec 	a
.383a	8d ca 06	sta $06ca			sta 	stringTempPointer+1
.383d	ce c8 06	dec $06c8			dec 	stringInitialised 			; set the initialised flag.
.3840					_SIExit:
.3840	a5 7b		lda $7b				lda 	availableMemory+1 			; check out of memory
.3842	1a		inc a				inc 	a
.3843	1a		inc a				inc 	a
.3844	cd 63 05	cmp $0563			cmp 	stringHighMemory+1
.3847	b0 02		bcs $384b			bcs 	_SIMemory
.3849	68		pla				pla
.384a	60		rts				rts
.384b					_SIMemory:
.384b	4c 1e 11	jmp $111e		jmp	ErrorV_memory
.384e					StringAllocTemp:
.384e	20 29 38	jsr $3829			jsr 	StringInitialise 			; check it is initialised.
.3851	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.3853	18		clc				clc
.3854	6d c9 06	adc $06c9			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.3857	8d c9 06	sta $06c9			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.385a	85 76		sta $76				sta 	zsTemp
.385c	95 38		sta $38,x			sta 	NSMantissa0,x
.385e	ad ca 06	lda $06ca			lda 	stringTempPointer+1
.3861	69 ff		adc #$ff			adc 	#$FF
.3863	8d ca 06	sta $06ca			sta 	stringTempPointer+1
.3866	85 77		sta $77				sta 	zsTemp+1
.3868	95 44		sta $44,x			sta 	NSMantissa1,x
.386a	74 50		stz $50,x			stz 	NSMantissa2,x
.386c	74 5c		stz $5c,x			stz 	NSMantissa3,x
.386e	a9 00		lda #$00			lda 	#0 							; clear string.
.3870	92 76		sta ($76)			sta 	(zsTemp)
.3872	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.3874	95 2c		sta $2c,x			sta 	NSStatus,x
.3876	60		rts				rts
.3877					StringWriteChar:
.3877	5a		phy				phy
.3878	48		pha				pha
.3879	b2 76		lda ($76)			lda 	(zsTemp)
.387b	1a		inc a				inc 	a
.387c	92 76		sta ($76)			sta 	(zsTemp)
.387e	a8		tay				tay
.387f	68		pla				pla
.3880	91 76		sta ($76),y			sta 	(zsTemp),y
.3882	7a		ply				ply
.3883	60		rts				rts
.06c8					stringInitialised:
>06c8							.fill 	1
.06c9					stringTempPointer:
>06c9							.fill 	2
.3884					Unary_Left:
.3884	fa		plx				plx
.3885	5a		phy				phy
.3886	18		clc				clc 								; only one parameter
.3887	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; push the length of the string.
.388a	48		pha				pha
.388b	ca		dex				dex
.388c	a9 00		lda #$00			lda 	#0 							; push the start position.
.388e	48		pha				pha
.388f	20 c7 38	jsr $38c7			jsr 	UnarySStringToZTemp0
.3892	80 3c		bra $38d0			bra 	SubstringMain 				; stack now points to the string to slice.
.3894					Unary_Right:
.3894	fa		plx				plx
.3895	5a		phy				phy
.3896	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.3898	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; push the right length of the string.
.389b	48		pha				pha
.389c	ca		dex				dex
.389d	20 c7 38	jsr $38c7			jsr 	UnarySStringToZTemp0
.38a0	68		pla				pla 								; this is the right requirement
.38a1	38		sec				sec
.38a2	49 ff		eor #$ff			eor 	#$FF
.38a4	72 26		adc ($26)			adc 	(zTemp0)
.38a6	b0 02		bcs $38aa			bcs 	_URHaveCount
.38a8	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.38aa					_URHaveCount:
.38aa	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.38ac	5a		phy				phy
.38ad	48		pha				pha 								; start position
.38ae	80 20		bra $38d0			bra 	SubstringMain
.38b0					Unary_Mid:
.38b0	fa		plx				plx
.38b1	5a		phy				phy
.38b2	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; push the length of the string required.
.38b5	48		pha				pha
.38b6	ca		dex				dex
.38b7	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; put the start position.
.38ba	f0 08		beq $38c4			beq 	_UMError
.38bc	3a		dec a				dec 	a
.38bd	48		pha				pha
.38be	ca		dex				dex
.38bf	20 c7 38	jsr $38c7			jsr 	UnarySStringToZTemp0
.38c2	80 0c		bra $38d0			bra 	SubstringMain 				; stack now points to the string to slice.
.38c4					_UMError:
.38c4	4c 13 10	jmp $1013		jmp	ErrorV_range
.38c7					UnarySStringToZTemp0:
.38c7	b5 38		lda $38,x			lda 	NSMantissa0,x
.38c9	85 26		sta $26				sta 	zTemp0
.38cb	b5 44		lda $44,x			lda 	NSMantissa1,x
.38cd	85 27		sta $27				sta 	zTemp0+1
.38cf	60		rts				rts
.38d0					SubstringMain:
.38d0	68		pla				pla 								; get the start offset
.38d1	7a		ply				ply 								; get the count to do.
.38d2	d2 26		cmp ($26)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.38d4	b0 38		bcs $390e			bcs 	_SSReturnNull
.38d6	85 28		sta $28				sta 	zTemp1 						; save start position.
.38d8	84 29		sty $29				sty 	zTemp1+1 					; save count
.38da	18		clc				clc
.38db	65 29		adc $29				adc 	zTemp1+1 					; this is the end position.
.38dd	b0 06		bcs $38e5			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.38df	d2 26		cmp ($26)			cmp 	(zTemp0) 					; ok if limit is <= length.
.38e1	f0 04		beq $38e7			beq 	_SMIsOkay
.38e3	90 02		bcc $38e7			bcc 	_SMIsOkay
.38e5					_SMTruncateToEnd:
.38e5	b2 26		lda ($26)			lda 	(zTemp0) 					; end position is length.
.38e7					_SMIsOkay:
.38e7	85 29		sta $29				sta 	zTemp1+1
.38e9	38		sec				sec		 							; work out size
.38ea	a5 29		lda $29				lda 	zTemp1+1
.38ec	e5 28		sbc $28				sbc 	zTemp1
.38ee	f0 1e		beq $390e			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.38f0	20 4e 38	jsr $384e			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.38f3	a4 28		ldy $28				ldy 	zTemp1 						; start
.38f5					_SMCopy:
.38f5	c4 29		cpy $29				cpy 	zTemp1+1 					; exit if reached end
.38f7	f0 11		beq $390a			beq 	_SMExit
.38f9	c8		iny				iny 								; bump and
.38fa	b1 26		lda ($26),y			lda 	(zTemp0),y 					; get character (prefix)
.38fc	5a		phy				phy
.38fd	48		pha				pha
.38fe	b2 76		lda ($76)			lda 	(zsTemp) 					; bump length => Y
.3900	1a		inc a				inc 	a
.3901	a8		tay				tay
.3902	92 76		sta ($76)			sta 	(zsTemp)
.3904	68		pla				pla 								; write character out
.3905	91 76		sta ($76),y			sta 	(zsTemp),y
.3907	7a		ply				ply 								; restore Y
.3908	80 eb		bra $38f5			bra 	_SMCopy
.390a					_SMExit:
.390a	7a		ply				ply
.390b	4c a2 29	jmp $29a2			jmp 	NextCommand
.390e					_SSReturnNull:
.390e	a9 20		lda #$20			lda 	#SSRNull & $FF 				; set up mantissa
.3910	95 38		sta $38,x			sta 	NSMantissa0,x
.3912	a9 39		lda #$39			lda 	#SSRNull >> 8
.3914	95 44		sta $44,x			sta 	NSMantissa1,x
.3916	74 50		stz $50,x			stz 	NSMantissa2,x
.3918	74 5c		stz $5c,x			stz 	NSMantissa3,x
.391a	a9 40		lda #$40			lda 	#NSSString
.391c	95 2c		sta $2c,x			sta 	NSStatus,x
.391e	80 ea		bra $390a			bra 	_SMExit
.3920					SSRNull:
>3920	00 00						.word 	0
.3922					CommandSwap:
.3922	fa		plx				plx
.3923	b5 38		lda $38,x			lda 	NSMantissa0,x
.3925	48		pha				pha
.3926	b5 37		lda $37,x			lda 	NSMantissa0-1,x
.3928	95 38		sta $38,x			sta 	NSMantissa0,x
.392a	68		pla				pla
.392b	95 37		sta $37,x			sta 	NSMantissa0-1,x
.392d	b5 44		lda $44,x			lda 	NSMantissa1,x
.392f	48		pha				pha
.3930	b5 43		lda $43,x			lda 	NSMantissa1-1,x
.3932	95 44		sta $44,x			sta 	NSMantissa1,x
.3934	68		pla				pla
.3935	95 43		sta $43,x			sta 	NSMantissa1-1,x
.3937	b5 50		lda $50,x			lda 	NSMantissa2,x
.3939	48		pha				pha
.393a	b5 4f		lda $4f,x			lda 	NSMantissa2-1,x
.393c	95 50		sta $50,x			sta 	NSMantissa2,x
.393e	68		pla				pla
.393f	95 4f		sta $4f,x			sta 	NSMantissa2-1,x
.3941	b5 5c		lda $5c,x			lda 	NSMantissa3,x
.3943	48		pha				pha
.3944	b5 5b		lda $5b,x			lda 	NSMantissa3-1,x
.3946	95 5c		sta $5c,x			sta 	NSMantissa3,x
.3948	68		pla				pla
.3949	95 5b		sta $5b,x			sta 	NSMantissa3-1,x
.394b	b5 68		lda $68,x			lda 	NSExponent,x
.394d	48		pha				pha
.394e	b5 67		lda $67,x			lda 	NSExponent-1,x
.3950	95 68		sta $68,x			sta 	NSExponent,x
.3952	68		pla				pla
.3953	95 67		sta $67,x			sta 	NSExponent-1,x
.3955	b5 2c		lda $2c,x			lda 	NSStatus,x
.3957	48		pha				pha
.3958	b5 2b		lda $2b,x			lda 	NSStatus-1,x
.395a	95 2c		sta $2c,x			sta 	NSStatus,x
.395c	68		pla				pla
.395d	95 2b		sta $2b,x			sta 	NSStatus-1,x
.395f	4c a2 29	jmp $29a2			jmp 	NextCommand
.3962					CommandSYS:
.3962	fa		plx				plx
.3963	da		phx				phx 								; save XY
.3964	5a		phy				phy
.3965	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.3968	b5 44		lda $44,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.396a	85 27		sta $27				sta 	zTemp0+1
.396c	b5 38		lda $38,x			lda 	NSMantissa0,x
.396e	85 26		sta $26				sta 	zTemp0
.3970	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.3973	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.3976	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.3979	48		pha				pha
.397a	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.397d	28		plp				plp
.397e	20 95 39	jsr $3995			jsr 	_CSZTemp0
.3981	08		php				php
.3982	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.3985	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.3988	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.398b	68		pla				pla
.398c	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.398f	7a		ply				ply 								; restore YX and drop 2
.3990	fa		plx				plx
.3991	ca		dex				dex
.3992	4c a2 29	jmp $29a2			jmp 	NextCommand
.3995					_CSZTemp0:
.3995	6c 26 00	jmp ($0026)			jmp 	(zTemp0)
.3998					TimeTOS:
.3998	fa		plx				plx
.3999	20 f3 39	jsr $39f3			jsr 	TIPushClock 				; push clock to TOS
.399c	4c a2 29	jmp $29a2			jmp 	NextCommand
.399f					TimeString:
.399f	fa		plx				plx
.39a0	20 f3 39	jsr $39f3			jsr 	TIPushClock 				; push clock to TOS
.39a3	20 c8 39	jsr $39c8			jsr 	_TSDivMod60 				; result in seconds
.39a6	20 c8 39	jsr $39c8			jsr 	_TSDivMod60 				; seconds
.39a9	48		pha				pha
.39aa	20 c8 39	jsr $39c8			jsr 	_TSDivMod60 				; minutes
.39ad	48		pha				pha
.39ae	a9 18		lda #$18			lda 	#24 						; hours
.39b0	20 ca 39	jsr $39ca			jsr 	_TSDivModA
.39b3	48		pha				pha
.39b4	a9 06		lda #$06			lda 	#6
.39b6	20 4e 38	jsr $384e			jsr 	StringAllocTemp
.39b9	68		pla				pla
.39ba	20 da 39	jsr $39da			jsr 	_TSWriteDecimal
.39bd	68		pla				pla
.39be	20 da 39	jsr $39da			jsr 	_TSWriteDecimal
.39c1	68		pla				pla
.39c2	20 da 39	jsr $39da			jsr 	_TSWriteDecimal
.39c5	4c a2 29	jmp $29a2			jmp 	NextCommand
.39c8					_TSDivMod60:
.39c8	a9 3c		lda #$3c			lda 	#60
.39ca					_TSDivModA:
.39ca	e8		inx				inx
.39cb	20 78 17	jsr $1778			jsr 	FloatSetByte
.39ce	ca		dex				dex
.39cf	20 0c 13	jsr $130c			jsr 	Int32Divide
.39d2	b5 38		lda $38,x			lda 	NSMantissa0,x 				; get modulus
.39d4	48		pha				pha
.39d5	20 fb 12	jsr $12fb			jsr 	NSMCopyPlusTwoToZero
.39d8	68		pla				pla
.39d9	60		rts				rts
.39da					_TSWriteDecimal:
.39da	da		phx				phx
.39db	a2 30		ldx #$30			ldx 	#'0'
.39dd					_TSWDLoop:
.39dd	c9 0a		cmp #$0a			cmp 	#10
.39df	90 05		bcc $39e6			bcc 	_TSWDEnd
.39e1	e9 0a		sbc #$0a			sbc 	#10
.39e3	e8		inx				inx
.39e4	80 f7		bra $39dd			bra 	_TSWDLoop
.39e6					_TSWDEnd:
.39e6	48		pha				pha
.39e7	8a		txa				txa
.39e8	20 77 38	jsr $3877			jsr 	StringWriteChar
.39eb	68		pla				pla
.39ec	09 30		ora #$30			ora 	#'0'
.39ee	20 77 38	jsr $3877			jsr 	StringWriteChar
.39f1	fa		plx				plx
.39f2	60		rts				rts
.39f3					TIPushClock:
.39f3	5a		phy				phy
.39f4	e8		inx				inx 								; push 0 on the stack
.39f5	20 76 17	jsr $1776			jsr 	FloatSetZero
.39f8	da		phx				phx
.39f9	20 e3 3d	jsr $3de3			jsr 	XReadClock 					; read time into YXA
.39fc	86 26		stx $26				stx 	zTemp0
.39fe	fa		plx				plx
.39ff	95 38		sta $38,x			sta 	NSMantissa0,x
.3a01	a5 26		lda $26				lda 	zTemp0
.3a03	95 44		sta $44,x			sta 	NSMantissa1,x
.3a05	98		tya				tya
.3a06	95 50		sta $50,x			sta 	NSMantissa2,x
.3a08	7a		ply				ply
.3a09	60		rts				rts
.3a0a					CommandTIWrite:
.3a0a	fa		plx				plx
.3a0b	b5 38		lda $38,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.3a0d	85 76		sta $76				sta 	zsTemp
.3a0f	b5 44		lda $44,x			lda 	NSMantissa1,x
.3a11	85 77		sta $77				sta 	zsTemp+1
.3a13	b2 76		lda ($76)			lda 	(zsTemp) 					; check if it is six
.3a15	c9 06		cmp #$06			cmp 	#6
.3a17	d0 59		bne $3a72			bne 	_CTIWError
.3a19	20 76 17	jsr $1776			jsr 	FloatSetZero
.3a1c	20 3e 3a	jsr $3a3e			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.3a1f	20 3e 3a	jsr $3a3e			jsr 	_CTIWDigitPair
.3a22	20 3e 3a	jsr $3a3e			jsr 	_CTIWDigitPair
.3a25	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.3a27	20 69 3a	jsr $3a69			jsr 	_CTIWMultiply
.3a2a	da		phx				phx
.3a2b	5a		phy				phy
.3a2c	b5 44		lda $44,x			lda 	NSMantissa1,x 				; get time into YXA
.3a2e	48		pha				pha
.3a2f	b5 50		lda $50,x			lda 	NSMantissa2,x
.3a31	a8		tay				tay
.3a32	b5 38		lda $38,x			lda 	NSMantissa0,x
.3a34	fa		plx				plx
.3a35	20 e7 3d	jsr $3de7			jsr 	XWriteClock 				; update the clock.
.3a38	7a		ply				ply
.3a39	fa		plx				plx
.3a3a	ca		dex				dex 								; throw result.
.3a3b	4c a2 29	jmp $29a2			jmp 	NextCommand
.3a3e					_CTIWDigitPair:
.3a3e	a9 06		lda #$06			lda 	#6 							; x 6
.3a40	20 69 3a	jsr $3a69			jsr 	_CTIWMultiply
.3a43	20 4f 3a	jsr $3a4f			jsr 	_CTIWAddDigit 				; add digit
.3a46	a9 0a		lda #$0a			lda 	#10 						; x 10
.3a48	20 69 3a	jsr $3a69			jsr 	_CTIWMultiply
.3a4b	20 4f 3a	jsr $3a4f			jsr 	_CTIWAddDigit 				; add digit
.3a4e	60		rts				rts
.3a4f					_CTIWAddDigit:
.3a4f	e6 76		inc $76				inc 	zsTemp 						; pre-increment
.3a51	d0 02		bne $3a55			bne 	_CTIWASkip
.3a53	e6 77		inc $77				inc 	zsTemp+1
.3a55					_CTIWASkip:
.3a55	b2 76		lda ($76)			lda 	(zsTemp) 					; read and validate it
.3a57	38		sec				sec
.3a58	e9 30		sbc #$30			sbc 	#"0"
.3a5a	90 16		bcc $3a72			bcc 	_CTIWError
.3a5c	c9 0a		cmp #$0a			cmp 	#9+1
.3a5e	b0 12		bcs $3a72			bcs 	_CTIWError
.3a60	e8		inx				inx 								; store at +1
.3a61	20 78 17	jsr $1778			jsr 	FloatSetByte
.3a64	ca		dex				dex
.3a65	20 02 15	jsr $1502			jsr 	FloatAddTopTwoStack
.3a68	60		rts				rts
.3a69					_CTIWMultiply:
.3a69	e8		inx				inx
.3a6a	20 78 17	jsr $1778			jsr 	FloatSetByte
.3a6d	ca		dex				dex
.3a6e	20 83 14	jsr $1483			jsr 	FloatMultiplyShort
.3a71	60		rts				rts
.3a72					_CTIWError:
.3a72	4c 23 10	jmp $1023		jmp	ErrorV_value
.3a75					UnaryUsr:
.3a75	fa		plx				plx
.3a76	5a		phy				phy
.3a77	20 7e 3a	jsr $3a7e			jsr 	_UUCallVector
.3a7a	7a		ply				ply
.3a7b	4c a2 29	jmp $29a2			jmp 	NextCommand
.3a7e					_UUCallVector:
.3a7e	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.3a81					ValUnary:
.3a81	fa		plx				plx
.3a82	b5 38		lda $38,x			lda 	NSMantissa0,x
.3a84	85 26		sta $26				sta 	zTemp0
.3a86	b5 44		lda $44,x			lda 	NSMantissa1,x
.3a88	85 27		sta $27				sta 	zTemp0+1
.3a8a	20 95 3a	jsr $3a95			jsr 	ValEvaluateZTemp0
.3a8d	b0 03		bcs $3a92			bcs 	_VUError 					; couldn't convert
.3a8f	4c a2 29	jmp $29a2			jmp 	NextCommand
.3a92					_VUError:
.3a92	4c 23 10	jmp $1023		jmp	ErrorV_value
.3a95					ValEvaluateZTemp0:
.3a95	5a		phy				phy
.3a96	b2 26		lda ($26)			lda 	(zTemp0) 					; check not empty string
.3a98	f0 22		beq $3abc			beq 	_VMCFail2
.3a9a	a0 00		ldy #$00			ldy 	#0 							; start position
.3a9c					_VMCSpaces:
.3a9c	c8		iny				iny 								; skip leading spaces
.3a9d	b1 26		lda ($26),y			lda 	(zTemp0),y
.3a9f	c9 20		cmp #$20			cmp 	#" "
.3aa1	f0 f9		beq $3a9c			beq 	_VMCSpaces
.3aa3	48		pha				pha 								; save first character
.3aa4	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.3aa6	d0 01		bne $3aa9			bne 	_VMCStart
.3aa8	c8		iny				iny 								; skip over - if so.
.3aa9					_VMCStart:
.3aa9	38		sec				sec 								; initialise first time round.
.3aaa					_VMCNext:
.3aaa	98		tya				tya 								; reached end of string
.3aab	3a		dec a				dec 	a
.3aac	52 26		eor ($26)			eor 	(zTemp0) 					; compare length preserve carry.
.3aae	f0 0f		beq $3abf			beq 	_VMCSuccess 				; successful.
.3ab0	b1 26		lda ($26),y			lda 	(zTemp0),y 					; encode a number.
.3ab2	c8		iny				iny
.3ab3	20 5a 15	jsr $155a			jsr 	FloatEncode 				; send it to the number-builder
.3ab6	90 03		bcc $3abb			bcc 	_VMCFail 					; if failed, give up.
.3ab8	18		clc				clc 								; next time round, countinue
.3ab9	80 ef		bra $3aaa			bra 	_VMCNext
.3abb					_VMCFail:
.3abb	68		pla				pla
.3abc					_VMCFail2:
.3abc	7a		ply				ply
.3abd	38		sec				sec
.3abe	60		rts				rts
.3abf					_VMCSuccess:
.3abf	a9 00		lda #$00			lda 	#0 							; construct final
.3ac1	20 5a 15	jsr $155a			jsr 	FloatEncode 				; by sending a duff value.
.3ac4	68		pla				pla 								; if it was -ve
.3ac5	c9 2d		cmp #$2d			cmp 	#"-"
.3ac7	d0 03		bne $3acc			bne 	_VMCNotNegative
.3ac9	20 38 17	jsr $1738			jsr		FloatNegate 				; negate it.
.3acc					_VMCNotNegative:
.3acc	7a		ply				ply
.3acd	18		clc				clc
.3ace	60		rts				rts
.3acf					VectorTable:
>3acf	e6 31					.word	LinkFloatAdd             ; $80 +
>3ad1	ef 31					.word	LinkFloatSubtract        ; $81 -
>3ad3	f8 31					.word	LinkFloatMultiply        ; $82 *
>3ad5	01 32					.word	LinkFloatDivide          ; $83 /
>3ad7	0c 32					.word	LinkFloatPower           ; $84 ^
>3ad9	34 2a					.word	BinaryAnd                ; $85 and
>3adb	38 2a					.word	BinaryOr                 ; $86 or
>3add	17 32					.word	LinkCompareGreater       ; $87 >
>3adf	20 32					.word	LinkCompareEqual         ; $88 =
>3ae1	29 32					.word	LinkCompareLess          ; $89 <
>3ae3	32 32					.word	LinkCompareGreaterEqual  ; $8a >=
>3ae5	3b 32					.word	LinkCompareNotEqual      ; $8b <>
>3ae7	44 32					.word	LinkCompareLessEqual     ; $8c <=
>3ae9	1c 2a					.word	AbsoluteTOS              ; $8d abs
>3aeb	6f 2a					.word	ArrayConvert             ; $8e array
>3aed	17 2b					.word	UnaryAsc                 ; $8f asc
>3aef	32 2b					.word	CommandAssert            ; $90 assert
>3af1	73 2b					.word	Unary16Bin               ; $91 bin$
>3af3	9d 2b					.word	PrintCharacterX          ; $92 print.chr
>3af5	a7 2b					.word	UnaryChr                 ; $93 chr$
>3af7	0c 2c					.word	CompareStrings           ; $94 s.cmp
>3af9	f3 2d					.word	CommandXFor              ; $95 for
>3afb	b6 2e					.word	UnaryFre                 ; $96 fre
>3afd	ce 2e					.word	CommandXGet              ; $97 get
>3aff	f4 2e					.word	CommandReturn            ; $98 return
>3b01	36 2f					.word	Command_PSET             ; $99 pset
>3b03	50 2f					.word	Command_LINE             ; $9a line
>3b05	65 2f					.word	Command_RECT             ; $9b rect
>3b07	74 2f					.word	Command_FRAME            ; $9c frame
>3b09	83 2f					.word	Command_CHAR             ; $9d char
>3b0b	1a 30					.word	Unary16Hex               ; $9e hex$
>3b0d	c1 30					.word	CommandXInput            ; $9f input
>3b0f	d8 30					.word	CommandInputString       ; $a0 input$
>3b11	f1 30					.word	CommandInputReset        ; $a1 input.start
>3b13	d5 31					.word	UnaryLen                 ; $a2 len
>3b15	a1 32					.word	LinkFloatCompare         ; $a3 f.cmp
>3b17	aa 32					.word	LinkDivideInt32          ; $a4 int.div
>3b19	24 33					.word	NegateTOS                ; $a5 negate
>3b1b	2b 33					.word	CommandNewLine           ; $a6 new.line
>3b1d	34 33					.word	CommandXNext             ; $a7 next
>3b1f	1d 34					.word	NotTOS                   ; $a8 not
>3b21	34 34					.word	CommandXOn               ; $a9 on
>3b23	51 34					.word	CommandMoreOn            ; $aa moreon
>3b25	58 34					.word	UnaryPeek                ; $ab peek
>3b27	6d 34					.word	CommandPOKE              ; $ac poke
>3b29	85 34					.word	UnaryPos                 ; $ad pos
>3b2b	8f 34					.word	GetChannel               ; $ae getchannel
>3b2d	9a 34					.word	SetChannel               ; $af setchannel
>3b2f	bd 34					.word	PrintNumber              ; $b0 print.n
>3b31	dc 34					.word	PrintString              ; $b1 print.s
>3b33	43 35					.word	CommandXRead             ; $b2 read
>3b35	5d 35					.word	CommandReadString        ; $b3 read$
>3b37	e8 36					.word	UnaryRND                 ; $b4 rnd
>3b39	57 37					.word	StringConcatenate        ; $b5 concat
>3b3b	ae 37					.word	SignTOS                  ; $b6 sgn
>3b3d	d1 37					.word	PrintTab                 ; $b7 print.tab
>3b3f	df 37					.word	PrintPos                 ; $b8 print.pos
>3b41	f0 37					.word	PrintSpace               ; $b9 print.spc
>3b43	09 38					.word	Unary_Str                ; $ba str$
>3b45	84 38					.word	Unary_Left               ; $bb left$
>3b47	94 38					.word	Unary_Right              ; $bc right$
>3b49	b0 38					.word	Unary_Mid                ; $bd mid$
>3b4b	22 39					.word	CommandSwap              ; $be swap
>3b4d	98 39					.word	TimeTOS                  ; $bf ti
>3b4f	9f 39					.word	TimeString               ; $c0 ti$
>3b51	75 3a					.word	UnaryUsr                 ; $c1 usr
>3b53	81 3a					.word	ValUnary                 ; $c2 val
>3b55	df 3c					.word	CommandClose             ; $c3 close
>3b57	f1 3c					.word	CommandExit              ; $c4 exit
>3b59	f7 3c					.word	CommandDebug             ; $c5 debug
>3b5b	5d 3d					.word	CommandXOpen             ; $c6 open
>3b5d	f1 3d					.word	CommandScreen            ; $c7 screen
>3b5f	d8 3f					.word	CommandVPOKE             ; $c8 vpoke
>3b61	fd 3f					.word	CommandVPEEK             ; $c9 vpeek
>3b63	c9 37					.word	CommandShift             ; $ca .shift
>3b65	e0 29					.word	PushByteCommand          ; $cb .byte
>3b67	f3 29					.word	PushWordCommand          ; $cc .word
>3b69	ff 34					.word	CommandPushN             ; $cd .float
>3b6b	25 35					.word	CommandPushS             ; $ce .string
>3b6d	94 2c					.word	CommandXData             ; $cf .data
>3b6f	05 2f					.word	CommandXGoto             ; $d0 .goto
>3b71	e8 2e					.word	CommandXGosub            ; $d1 .gosub
>3b73	1a 2f					.word	CommandGotoZ             ; $d2 .goto.z
>3b75	28 2f					.word	CommandGotoNZ            ; $d3 .goto.nz
>3b77	22 2a					.word	CommandVarSpace          ; $d4 .varspace
.3b79					ShiftVectorTable:
>3b79	bf 2b					.word	CommandClr               ; $ca80 clr
>3b7b	9d 2c					.word	CommandXDIM              ; $ca81 dim
>3b7d	8e 2d					.word	CommandEnd               ; $ca82 end
>3b7f	a6 31					.word	UnaryJoy                 ; $ca83 joy
>3b81	4d 32					.word	LinkFloatIntegerPartDown ; $ca84 int
>3b83	56 32					.word	LinkFloatSquareRoot      ; $ca85 sqr
>3b85	67 32					.word	LinkFloatLogarithm       ; $ca86 log
>3b87	72 32					.word	LinkFloatExponent        ; $ca87 exp
>3b89	7b 32					.word	LinkFloatCosine          ; $ca88 cos
>3b8b	84 32					.word	LinkFloatSine            ; $ca89 sin
>3b8d	8d 32					.word	LinkFloatTangent         ; $ca8a tan
>3b8f	96 32					.word	LinkFloatArcTan          ; $ca8b atn
>3b91	d4 32					.word	XCommandMouse            ; $ca8c mouse
>3b93	e9 32					.word	XUnaryMB                 ; $ca8d mb
>3b95	f6 32					.word	XUnaryMX                 ; $ca8e mx
>3b97	07 33					.word	XUnaryMY                 ; $ca8f my
>3b99	d6 36					.word	CommandRestore           ; $ca90 restore
>3b9b	05 38					.word	CommandStop              ; $ca91 stop
>3b9d	62 39					.word	CommandSYS               ; $ca92 sys
>3b9f	0a 3a					.word	CommandTIWrite           ; $ca93 ti$.write
>3ba1	d7 3b					.word	CommandXWAIT             ; $ca94 wait
>3ba3	22 3d					.word	X16I2CPoke               ; $ca95 i2cpoke
>3ba5	42 3d					.word	X16I2CPeek               ; $ca96 i2cpeek
>3ba7	ad 3d					.word	CommandBank              ; $ca97 bank
>3ba9	00 3e					.word	XCommandSleep            ; $ca98 sleep
>3bab	24 3e					.word	X16_Audio_FMINIT         ; $ca99 fminit
>3bad	32 3e					.word	X16_Audio_FMNOTE         ; $ca9a fmnote
>3baf	44 3e					.word	X16_Audio_FMDRUM         ; $ca9b fmdrum
>3bb1	56 3e					.word	X16_Audio_FMINST         ; $ca9c fminst
>3bb3	68 3e					.word	X16_Audio_FMVIB          ; $ca9d fmvib
>3bb5	7a 3e					.word	X16_Audio_FMFREQ         ; $ca9e fmfreq
>3bb7	8b 3e					.word	X16_Audio_FMVOL          ; $ca9f fmvol
>3bb9	9d 3e					.word	X16_Audio_FMPAN          ; $caa0 fmpan
>3bbb	af 3e					.word	X16_Audio_FMPLAY         ; $caa1 fmplay
>3bbd	c0 3e					.word	X16_Audio_FMCHORD        ; $caa2 fmchord
>3bbf	d1 3e					.word	X16_Audio_FMPOKE         ; $caa3 fmpoke
>3bc1	e3 3e					.word	X16_Audio_PSGINIT        ; $caa4 psginit
>3bc3	f1 3e					.word	X16_Audio_PSGNOTE        ; $caa5 psgnote
>3bc5	03 3f					.word	X16_Audio_PSGVOL         ; $caa6 psgvol
>3bc7	15 3f					.word	X16_Audio_PSGWAV         ; $caa7 psgwav
>3bc9	27 3f					.word	X16_Audio_PSGFREQ        ; $caa8 psgfreq
>3bcb	38 3f					.word	X16_Audio_PSGPAN         ; $caa9 psgpan
>3bcd	4a 3f					.word	X16_Audio_PSGPLAY        ; $caaa psgplay
>3bcf	5b 3f					.word	X16_Audio_PSGCHORD       ; $caab psgchord
>3bd1	6c 3f					.word	CommandCls               ; $caac cls
>3bd3	75 3f					.word	CommandLocate            ; $caad locate
>3bd5	9f 3f					.word	CommandColor             ; $caae color
.3bd7					CommandXWAIT:
.3bd7	fa		plx				plx
.3bd8	b5 36		lda $36,x			lda 	NSMantissa0-2,x 			; get wait address
.3bda	85 26		sta $26				sta 	zTemp0
.3bdc	b5 42		lda $42,x			lda 	NSMantissa1-2,x
.3bde	85 27		sta $27				sta 	zTemp0+1
.3be0					_WaitLoop:
.3be0	b2 26		lda ($26)			lda 	(zTemp0) 					; read it
.3be2	35 37		and $37,x			and 	NSMantissa0-1,x		 		; and with mask
.3be4	55 38		eor $38,x			eor 	NSMantissa0-0,x 			; toggle
.3be6	f0 f8		beq $3be0			beq 	_WaitLoop 					; keep going if zero
.3be8	ca		dex				dex 								; drop 3.
.3be9	ca		dex				dex
.3bea	ca		dex				dex
.3beb	4c a2 29	jmp $29a2			jmp 	NextCommand
.3bee					WriteFloatCommand:
.3bee	fa		plx				plx
.3bef	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.3bf1	85 26		sta $26				sta 	zTemp0 						; save in MSB
.3bf3	88		dey				dey 								; get the upper 3 bits
.3bf4	b1 22		lda ($22),y			lda 	(codePtr),y
.3bf6	29 07		and #$07			and 	#7
.3bf8	c8		iny				iny
.3bf9	c8		iny				iny
.3bfa	06 26		asl $26				asl 	zTemp0 						; shift zTemp0:A left
.3bfc	2a		rol a				rol 	a 							; carry will be clear.
.3bfd	6d 67 05	adc $0567			adc 	variableStartPage			; make it point to variable page.
.3c00	85 27		sta $27				sta 	zTemp0+1
.3c02	20 08 3c	jsr $3c08			jsr 	WriteFloatZTemp0Sub
.3c05	4c a2 29	jmp $29a2			jmp 	NextCommand
.3c08					WriteFloatZTemp0Sub:
.3c08	5a		phy				phy 								; ldart write
.3c09	a0 01		ldy #$01			ldy 	#1
.3c0b	b5 38		lda $38,x			lda 	NSMantissa0,x
.3c0d	92 26		sta ($26)			sta 	(zTemp0)
.3c0f	b5 44		lda $44,x			lda 	NSMantissa1,x
.3c11	91 26		sta ($26),y			sta 	(zTemp0),y
.3c13	c8		iny				iny
.3c14	b5 50		lda $50,x			lda 	NSMantissa2,x
.3c16	91 26		sta ($26),y			sta 	(zTemp0),y
.3c18	c8		iny				iny
.3c19	b5 5c		lda $5c,x			lda 	NSMantissa3,x
.3c1b	91 26		sta ($26),y			sta 	(zTemp0),y
.3c1d	c8		iny				iny
.3c1e	b5 68		lda $68,x			lda 	NSExponent,x
.3c20	91 26		sta ($26),y			sta 	(zTemp0),y
.3c22	c8		iny				iny
.3c23	b5 2c		lda $2c,x			lda 	NSStatus,x
.3c25	91 26		sta ($26),y			sta 	(zTemp0),y
.3c27	ca		dex				dex
.3c28	7a		ply				ply
.3c29	60		rts				rts
.3c2a					WriteIntegerCommand:
.3c2a	fa		plx				plx
.3c2b	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.3c2d	85 26		sta $26				sta 	zTemp0 						; save in MSB
.3c2f	88		dey				dey 								; get the upper 3 bits
.3c30	b1 22		lda ($22),y			lda 	(codePtr),y
.3c32	29 07		and #$07			and 	#7
.3c34	c8		iny				iny
.3c35	c8		iny				iny
.3c36	06 26		asl $26				asl 	zTemp0 						; shift zTemp0:A left
.3c38	2a		rol a				rol 	a 							; carry will be clear.
.3c39	6d 67 05	adc $0567			adc 	variableStartPage			; make it point to variable page.
.3c3c	85 27		sta $27				sta 	zTemp0+1
.3c3e	20 44 3c	jsr $3c44			jsr 	WriteIntegerZTemp0Sub
.3c41	4c a2 29	jmp $29a2			jmp 	NextCommand
.3c44					WriteIntegerZTemp0Sub:
.3c44	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.3c47	5a		phy				phy 								; start write
.3c48	a0 01		ldy #$01			ldy 	#1
.3c4a	b5 2c		lda $2c,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.3c4c	30 0b		bmi $3c59			bmi 	_WIZNegative
.3c4e	b5 38		lda $38,x			lda 	NSMantissa0,x 				; +ve write
.3c50	92 26		sta ($26)			sta 	(zTemp0)
.3c52	b5 44		lda $44,x			lda 	NSMantissa1,x
.3c54	91 26		sta ($26),y			sta 	(zTemp0),y
.3c56	7a		ply				ply
.3c57	ca		dex				dex
.3c58	60		rts				rts
.3c59					_WIZNegative:
.3c59	38		sec				sec 								; -ve read
.3c5a	a9 00		lda #$00			lda 	#0
.3c5c	f5 38		sbc $38,x			sbc 	NSMantissa0,x
.3c5e	92 26		sta ($26)			sta 	(zTemp0)
.3c60	a9 00		lda #$00			lda 	#0
.3c62	f5 44		sbc $44,x			sbc 	NSMantissa1,x
.3c64	91 26		sta ($26),y			sta 	(zTemp0),y
.3c66	7a		ply				ply
.3c67	ca		dex				dex
.3c68	60		rts				rts
.3c69					WriteStringCommand:
.3c69	fa		plx				plx
.3c6a	b1 22		lda ($22),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.3c6c	85 26		sta $26				sta 	zTemp0 						; save in MSB
.3c6e	88		dey				dey 								; get the upper 3 bits
.3c6f	b1 22		lda ($22),y			lda 	(codePtr),y
.3c71	29 07		and #$07			and 	#7
.3c73	c8		iny				iny
.3c74	c8		iny				iny
.3c75	06 26		asl $26				asl 	zTemp0 						; shift zTemp0:A left
.3c77	2a		rol a				rol 	a 							; carry will be clear.
.3c78	6d 67 05	adc $0567			adc 	variableStartPage			; make it point to variable page.
.3c7b	85 27		sta $27				sta 	zTemp0+1
.3c7d	20 83 3c	jsr $3c83			jsr 	WriteStringZTemp0Sub
.3c80	4c a2 29	jmp $29a2			jmp 	NextCommand
.3c83					WriteStringZTemp0Sub:
.3c83	5a		phy				phy
.3c84	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.3c86	b2 26		lda ($26)			lda 	(zTemp0)
.3c88	11 26		ora ($26),y			ora 	(zTemp0),y
.3c8a	f0 1e		beq $3caa			beq 	_WSConcrete
.3c8c	b2 26		lda ($26)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.3c8e	85 28		sta $28				sta 	zTemp1
.3c90	b1 26		lda ($26),y			lda 	(zTemp0),y
.3c92	85 29		sta $29				sta 	zTemp1+1
.3c94	b5 38		lda $38,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.3c96	85 2a		sta $2a				sta 	zTemp2
.3c98	b5 44		lda $44,x			lda 	NSMantissa1,x
.3c9a	85 2b		sta $2b				sta 	zTemp2+1
.3c9c	b2 28		lda ($28)			lda 	(zTemp1) 					; space available
.3c9e	d2 2a		cmp ($2a)			cmp 	(zTemp2) 					; if >= required length then copy
.3ca0	b0 17		bcs $3cb9			bcs 	_WSCopy
.3ca2	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.3ca4	b1 28		lda ($28),y			lda 	(zTemp1),y
.3ca6	09 80		ora #$80			ora 	#$80
.3ca8	91 28		sta ($28),y			sta 	(zTemp1),y
.3caa					_WSConcrete:
.3caa	b5 44		lda $44,x			lda 	NSMantissa1,x 				; string in YA
.3cac	a8		tay				tay
.3cad	b5 38		lda $38,x			lda 	NSMantissa0,x
.3caf	20 4e 2c	jsr $2c4e			jsr 	StringConcrete
.3cb2	92 26		sta ($26)			sta 	(zTemp0) 					; save returned address
.3cb4	98		tya				tya
.3cb5	a0 01		ldy #$01			ldy 	#1
.3cb7	91 26		sta ($26),y			sta 	(zTemp0),y
.3cb9					_WSCopy
.3cb9	18		clc				clc  								; copy target+2 to zTemp2
.3cba	b2 26		lda ($26)			lda 	(zTemp0)
.3cbc	69 02		adc #$02			adc 	#2
.3cbe	85 2a		sta $2a				sta 	zTemp2
.3cc0	a0 01		ldy #$01			ldy 	#1
.3cc2	b1 26		lda ($26),y			lda 	(zTemp0),y
.3cc4	69 00		adc #$00			adc 	#0
.3cc6	85 2b		sta $2b				sta 	zTemp2+1
.3cc8	b5 38		lda $38,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.3cca	85 28		sta $28				sta 	zTemp1
.3ccc	b5 44		lda $44,x			lda 	NSMantissa1,x
.3cce	85 29		sta $29				sta 	zTemp1+1
.3cd0	b2 28		lda ($28)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.3cd2	a8		tay				tay
.3cd3					_WSCopyLoop:
.3cd3	b1 28		lda ($28),y			lda 	(zTemp1),y
.3cd5	91 2a		sta ($2a),y			sta 	(zTemp2),y
.3cd7	88		dey				dey
.3cd8	c0 ff		cpy #$ff			cpy 	#$FF
.3cda	d0 f7		bne $3cd3			bne 	_WSCopyLoop
.3cdc	ca		dex				dex
.3cdd	7a		ply				ply
.3cde	60		rts				rts
.3cdf					CommandClose:
.3cdf	fa		plx				plx
.3ce0	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; channel to close
.3ce3	cd bd 05	cmp $05bd			cmp 	currentChannel 				; is it the current channel
.3ce6	d0 03		bne $3ceb			bne 	_CCNotCurrent
.3ce8	9c bd 05	stz $05bd			stz 	currentChannel 				; effectively disables CMD
.3ceb					_CCNotCurrent:
.3ceb	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.3cee	4c a2 29	jmp $29a2			jmp 	NextCommand
.3cf1					CommandExit:
.3cf1	fa		plx				plx
.3cf2	86 26		stx $26				stx 	zTemp0 						; stack position.
.3cf4	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.3cf7					CommandDebug:
.3cf7	fa		plx				plx
>3cf8	db						.byte 	$DB 						; causes a break in the emulator
.3cf9	4c a2 29	jmp $29a2			jmp 	NextCommand
.3cfc					XGetCharacterFromChannel:
.3cfc	da		phx				phx
.3cfd	5a		phy				phy
.3cfe	e0 00		cpx #$00			cpx 	#0 							; is it default
.3d00	d0 05		bne $3d07			bne 	_XGetChannel
.3d02	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.3d05	80 08		bra $3d0f			bra 	_XGetChar
.3d07					_XGetChannel:
.3d07	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.3d0a	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.3d0d	d0 06		bne $3d15			bne 	_XGCError
.3d0f					_XGetChar:
.3d0f	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.3d12	7a		ply				ply
.3d13	fa		plx				plx
.3d14	60		rts				rts
.3d15					_XGCError:
.3d15	4c 2f 11	jmp $112f		jmp	ErrorV_channel
.3d18					XGetHPos:
.3d18	da		phx				phx
.3d19	5a		phy				phy
.3d1a	38		sec				sec
.3d1b	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.3d1e	98		tya				tya
.3d1f	7a		ply				ply
.3d20	fa		plx				plx
.3d21	60		rts				rts
.3d22					X16I2CPoke:
.3d22	fa		plx				plx
.3d23	5a		phy				phy
.3d24	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; value
.3d27	48		pha				pha
.3d28	ca		dex				dex
.3d29	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; register
.3d2c	48		pha				pha
.3d2d	ca		dex				dex
.3d2e	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; device
.3d31	aa		tax				tax
.3d32	7a		ply				ply
.3d33	68		pla				pla
.3d34	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.3d37	b0 06		bcs $3d3f			bcs 	X16I2CError
.3d39	7a		ply				ply
.3d3a	a2 ff		ldx #$ff			ldx 	#$FF
.3d3c	4c a2 29	jmp $29a2			jmp 	NextCommand
.3d3f					X16I2CError:
.3d3f	4c 2f 11	jmp $112f		jmp	ErrorV_channel
.3d42					X16I2CPeek:
.3d42	fa		plx				plx
.3d43	da		phx				phx
.3d44	5a		phy				phy
.3d45	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; register
.3d48	48		pha				pha
.3d49	ca		dex				dex
.3d4a	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; device
.3d4d	aa		tax				tax 								; X device
.3d4e	7a		ply				ply 								; Y register
.3d4f	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.3d52	b0 eb		bcs $3d3f			bcs 	X16I2CError
.3d54	7a		ply				ply 								; restore Y/X
.3d55	fa		plx				plx
.3d56	ca		dex				dex 								; drop TOS (register)
.3d57	20 78 17	jsr $1778			jsr 	FloatSetByte 				; write read value to TOS.
.3d5a	4c a2 29	jmp $29a2			jmp 	NextCommand
.3d5d					CommandXOpen:
.3d5d	fa		plx				plx
.3d5e	a5 3b		lda $3b				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.3d60	85 26		sta $26				sta 	zTemp0
.3d62	aa		tax				tax
.3d63	a5 47		lda $47				lda 	NSMantissa1+3
.3d65	85 27		sta $27				sta 	zTemp0+1
.3d67	a8		tay				tay
.3d68	e8		inx				inx 								; XY points to first character
.3d69	d0 01		bne $3d6c			bne 	_CONoCarry
.3d6b	c8		iny				iny
.3d6c					_CONoCarry:
.3d6c	b2 26		lda ($26)			lda 	(zTemp0) 					; get length of filename
.3d6e	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.3d71	a5 38		lda $38				lda 	NSMantissa0+0
.3d73	a6 39		ldx $39				ldx 	NSMantissa0+1
.3d75	a4 3a		ldy $3a				ldy 	NSMantissa0+2
.3d77	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.3d7a	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.3d7d	b0 03		bcs $3d82			bcs 	_COError
.3d7f	4c a2 29	jmp $29a2			jmp 	NextCommand
.3d82					_COError:
.3d82	4c 2f 11	jmp $112f		jmp	ErrorV_channel
.3d85					XPokeMemory:
.3d85	86 26		stx $26				stx 	zTemp0
.3d87	84 27		sty $27				sty 	zTemp0+1
.3d89	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.3d8b	ae cb 06	ldx $06cb			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.3d8e	e0 ff		cpx #$ff			cpx 	#$FF
.3d90	f0 02		beq $3d94			beq 	_XPMNoSwitch
.3d92	86 00		stx $00				stx 	SelectRAMBank
.3d94					_XPMNoSwitch:
.3d94	92 26		sta ($26)			sta 	(zTemp0) 					; do the POKE
.3d96	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.3d98					_XPMExit:
.3d98	60		rts				rts
.3d99					XPeekMemory:
.3d99	86 26		stx $26				stx 	zTemp0
.3d9b	84 27		sty $27				sty 	zTemp0+1
.3d9d	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.3d9f	ae cb 06	ldx $06cb			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.3da2	e0 ff		cpx #$ff			cpx 	#$FF
.3da4	f0 02		beq $3da8			beq 	_XPMNoSwitch
.3da6	86 00		stx $00				stx 	SelectRAMBank
.3da8					_XPMNoSwitch:
.3da8	b2 26		lda ($26)			lda 	(zTemp0) 					; do the PEEK
.3daa	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.3dac	60		rts				rts
.3dad					CommandBank:
.3dad	fa		plx				plx
.3dae	a5 38		lda $38				lda 	NSMantissa0 				; RAM bank
.3db0	8d cb 06	sta $06cb			sta 	ramBank 					; store & make current
.3db3	85 00		sta $00				sta 	SelectRAMBank
.3db5	a5 39		lda $39				lda 	NSMantissa0+1 		 		; ROM specified
.3db7	c9 ff		cmp #$ff			cmp 	#$FF
.3db9	f0 03		beq $3dbe			beq 	_CBNoUpdate
.3dbb	8d cc 06	sta $06cc			sta 	romBank 					; this doesn't set the hardware page.
.3dbe					_CBNoUpdate:
.3dbe	a2 ff		ldx #$ff			ldx 	#$FF
.3dc0	4c a2 29	jmp $29a2			jmp 	NextCommand
.06cb					ramBank:
>06cb							.fill 	1
.06cc					romBank:
>06cc							.fill 	1
.3dc3					XPrintCharacterToChannel:
.3dc3	48		pha				pha
.3dc4	da		phx				phx
.3dc5	5a		phy				phy
.3dc6	48		pha				pha  								; save char
.3dc7	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.3dc9	d0 05		bne $3dd0			bne 	_XPCNotDefault
.3dcb	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.3dce	80 08		bra $3dd8			bra 	_XPCSend
.3dd0					_XPCNotDefault:
.3dd0	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.3dd3	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.3dd6	d0 08		bne $3de0			bne 	_XPCError
.3dd8					_XPCSend:
.3dd8	68		pla				pla 								; restore character
.3dd9	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.3ddc	7a		ply				ply
.3ddd	fa		plx				plx
.3dde	68		pla				pla
.3ddf	60		rts				rts
.3de0					_XPCError:
.3de0	4c 2f 11	jmp $112f		jmp	ErrorV_channel
.3de3					XReadClock:
.3de3	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.3de6	60		rts				rts
.3de7					XWriteClock:
.3de7	48		pha				pha
.3de8	da		phx				phx
.3de9	5a		phy				phy
.3dea	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.3ded	7a		ply				ply
.3dee	fa		plx				plx
.3def	68		pla				pla
.3df0	60		rts				rts
.3df1					CommandScreen:
.3df1	fa		plx				plx
.3df2	da		phx				phx
.3df3	5a		phy				phy
.3df4	20 7e 31	jsr $317e			jsr 	GetInteger8Bit
.3df7	18		clc				clc
.3df8	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.3dfb	7a		ply				ply
.3dfc	fa		plx				plx
.3dfd	4c a2 29	jmp $29a2			jmp 	NextCommand
.3e00					XCommandSleep:
.3e00	fa		plx				plx
.3e01	5a		phy				phy
.3e02	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.3e05	ca		dex				dex
.3e06	20 e3 3d	jsr $3de3			jsr 	XReadClock 					; read clock to YXA
.3e09	18		clc				clc 								; calculate end time in zTemp0
.3e0a	65 38		adc $38				adc 	NSMantissa0
.3e0c	85 26		sta $26				sta 	zTemp0
.3e0e	8a		txa				txa
.3e0f	65 44		adc $44				adc 	NSMantissa1
.3e11	85 27		sta $27				sta 	zTemp0+1
.3e13					_XCWait:
.3e13	20 e3 3d	jsr $3de3			jsr 	XReadClock 					; and wait for it.
.3e16	c5 26		cmp $26				cmp 	zTemp0
.3e18	d0 f9		bne $3e13			bne 	_XCWait
.3e1a	e4 27		cpx $27				cpx 	zTemp0+1
.3e1c	d0 f5		bne $3e13			bne 	_XCWait
.3e1e	a2 ff		ldx #$ff			ldx 	#$FF
.3e20	7a		ply				ply
.3e21	4c a2 29	jmp $29a2			jmp 	NextCommand
.3e24					X16_Audio_FMINIT:
.3e24	fa		plx				plx
.3e25	5a		phy			phy
.3e26	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3e29	63 c0					.word	X16A_ym_init
>3e2b	0a					.byte	X16_AudioCodeBank
.3e2c	a2 ff		ldx #$ff		ldx	#$FF
.3e2e	7a		ply			ply
.3e2f	4c a2 29	jmp $29a2			jmp 	NextCommand
.3e32					X16_Audio_FMNOTE:
.3e32	fa		plx				plx
.3e33	5a		phy			phy
.3e34	20 49 2b	jsr $2b49		jsr		X16_Audio_Parameters8_8
.3e37	18		clc			clc
.3e38	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3e3b	03 c0					.word	X16A_bas_fmnote
>3e3d	0a					.byte	X16_AudioCodeBank
.3e3e	a2 ff		ldx #$ff		ldx	#$FF
.3e40	7a		ply			ply
.3e41	4c a2 29	jmp $29a2			jmp 	NextCommand
.3e44					X16_Audio_FMDRUM:
.3e44	fa		plx				plx
.3e45	5a		phy			phy
.3e46	20 49 2b	jsr $2b49		jsr		X16_Audio_Parameters8_8
.3e49	18		clc			clc
.3e4a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3e4d	6f c0					.word	X16A_ym_playdrum
>3e4f	0a					.byte	X16_AudioCodeBank
.3e50	a2 ff		ldx #$ff		ldx	#$FF
.3e52	7a		ply			ply
.3e53	4c a2 29	jmp $29a2			jmp 	NextCommand
.3e56					X16_Audio_FMINST:
.3e56	fa		plx				plx
.3e57	5a		phy			phy
.3e58	20 49 2b	jsr $2b49		jsr		X16_Audio_Parameters8_8
.3e5b	38		sec			sec
.3e5c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3e5f	69 c0					.word	X16A_ym_loadpatch
>3e61	0a					.byte	X16_AudioCodeBank
.3e62	a2 ff		ldx #$ff		ldx	#$FF
.3e64	7a		ply			ply
.3e65	4c a2 29	jmp $29a2			jmp 	NextCommand
.3e68					X16_Audio_FMVIB:
.3e68	fa		plx				plx
.3e69	5a		phy			phy
.3e6a	20 49 2b	jsr $2b49		jsr		X16_Audio_Parameters8_8
.3e6d	18		clc			clc
.3e6e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3e71	09 c0					.word	X16A_bas_fmvib
>3e73	0a					.byte	X16_AudioCodeBank
.3e74	a2 ff		ldx #$ff		ldx	#$FF
.3e76	7a		ply			ply
.3e77	4c a2 29	jmp $29a2			jmp 	NextCommand
.3e7a					X16_Audio_FMFREQ:
.3e7a	fa		plx				plx
.3e7b	5a		phy			phy
.3e7c	20 43 2b	jsr $2b43		jsr		X16_Audio_Parameters8_16
.3e7f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3e82	00 c0					.word	X16A_bas_fmfreq
>3e84	0a					.byte	X16_AudioCodeBank
.3e85	a2 ff		ldx #$ff		ldx	#$FF
.3e87	7a		ply			ply
.3e88	4c a2 29	jmp $29a2			jmp 	NextCommand
.3e8b					X16_Audio_FMVOL:
.3e8b	fa		plx				plx
.3e8c	5a		phy			phy
.3e8d	20 49 2b	jsr $2b49		jsr		X16_Audio_Parameters8_8
.3e90	18		clc			clc
.3e91	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3e94	75 c0					.word	X16A_ym_setatten
>3e96	0a					.byte	X16_AudioCodeBank
.3e97	a2 ff		ldx #$ff		ldx	#$FF
.3e99	7a		ply			ply
.3e9a	4c a2 29	jmp $29a2			jmp 	NextCommand
.3e9d					X16_Audio_FMPAN:
.3e9d	fa		plx				plx
.3e9e	5a		phy			phy
.3e9f	20 49 2b	jsr $2b49		jsr		X16_Audio_Parameters8_8
.3ea2	18		clc			clc
.3ea3	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3ea6	7e c0					.word	X16A_ym_setpan
>3ea8	0a					.byte	X16_AudioCodeBank
.3ea9	a2 ff		ldx #$ff		ldx	#$FF
.3eab	7a		ply			ply
.3eac	4c a2 29	jmp $29a2			jmp 	NextCommand
.3eaf					X16_Audio_FMPLAY:
.3eaf	fa		plx				plx
.3eb0	5a		phy			phy
.3eb1	20 5a 2b	jsr $2b5a		jsr		X16_Audio_Parameters8_String
.3eb4	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3eb7	06 c0					.word	X16A_bas_fmplaystring
>3eb9	0a					.byte	X16_AudioCodeBank
.3eba	a2 ff		ldx #$ff		ldx	#$FF
.3ebc	7a		ply			ply
.3ebd	4c a2 29	jmp $29a2			jmp 	NextCommand
.3ec0					X16_Audio_FMCHORD:
.3ec0	fa		plx				plx
.3ec1	5a		phy			phy
.3ec2	20 5a 2b	jsr $2b5a		jsr		X16_Audio_Parameters8_String
.3ec5	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3ec8	8d c0					.word	X16A_bas_fmchordstring
>3eca	0a					.byte	X16_AudioCodeBank
.3ecb	a2 ff		ldx #$ff		ldx	#$FF
.3ecd	7a		ply			ply
.3ece	4c a2 29	jmp $29a2			jmp 	NextCommand
.3ed1					X16_Audio_FMPOKE:
.3ed1	fa		plx				plx
.3ed2	5a		phy			phy
.3ed3	20 49 2b	jsr $2b49		jsr		X16_Audio_Parameters8_8
.3ed6	18		clc			clc
.3ed7	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3eda	8a c0					.word	X16A_ym_write
>3edc	0a					.byte	X16_AudioCodeBank
.3edd	a2 ff		ldx #$ff		ldx	#$FF
.3edf	7a		ply			ply
.3ee0	4c a2 29	jmp $29a2			jmp 	NextCommand
.3ee3					X16_Audio_PSGINIT:
.3ee3	fa		plx				plx
.3ee4	5a		phy			phy
.3ee5	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3ee8	4b c0					.word	X16A_psg_init
>3eea	0a					.byte	X16_AudioCodeBank
.3eeb	a2 ff		ldx #$ff		ldx	#$FF
.3eed	7a		ply			ply
.3eee	4c a2 29	jmp $29a2			jmp 	NextCommand
.3ef1					X16_Audio_PSGNOTE:
.3ef1	fa		plx				plx
.3ef2	5a		phy			phy
.3ef3	20 49 2b	jsr $2b49		jsr		X16_Audio_Parameters8_8
.3ef6	18		clc			clc
.3ef7	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3efa	12 c0					.word	X16A_bas_psgnote
>3efc	0a					.byte	X16_AudioCodeBank
.3efd	a2 ff		ldx #$ff		ldx	#$FF
.3eff	7a		ply			ply
.3f00	4c a2 29	jmp $29a2			jmp 	NextCommand
.3f03					X16_Audio_PSGVOL:
.3f03	fa		plx				plx
.3f04	5a		phy			phy
.3f05	20 49 2b	jsr $2b49		jsr		X16_Audio_Parameters8_8
.3f08	18		clc			clc
.3f09	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3f0c	54 c0					.word	X16A_psg_setatten
>3f0e	0a					.byte	X16_AudioCodeBank
.3f0f	a2 ff		ldx #$ff		ldx	#$FF
.3f11	7a		ply			ply
.3f12	4c a2 29	jmp $29a2			jmp 	NextCommand
.3f15					X16_Audio_PSGWAV:
.3f15	fa		plx				plx
.3f16	5a		phy			phy
.3f17	20 49 2b	jsr $2b49		jsr		X16_Audio_Parameters8_8
.3f1a	18		clc			clc
.3f1b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3f1e	15 c0					.word	X16A_bas_psgwav
>3f20	0a					.byte	X16_AudioCodeBank
.3f21	a2 ff		ldx #$ff		ldx	#$FF
.3f23	7a		ply			ply
.3f24	4c a2 29	jmp $29a2			jmp 	NextCommand
.3f27					X16_Audio_PSGFREQ:
.3f27	fa		plx				plx
.3f28	5a		phy			phy
.3f29	20 43 2b	jsr $2b43		jsr		X16_Audio_Parameters8_16
.3f2c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3f2f	0f c0					.word	X16A_bas_psgfreq
>3f31	0a					.byte	X16_AudioCodeBank
.3f32	a2 ff		ldx #$ff		ldx	#$FF
.3f34	7a		ply			ply
.3f35	4c a2 29	jmp $29a2			jmp 	NextCommand
.3f38					X16_Audio_PSGPAN:
.3f38	fa		plx				plx
.3f39	5a		phy			phy
.3f3a	20 49 2b	jsr $2b49		jsr		X16_Audio_Parameters8_8
.3f3d	18		clc			clc
.3f3e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3f41	5a c0					.word	X16A_psg_setpan
>3f43	0a					.byte	X16_AudioCodeBank
.3f44	a2 ff		ldx #$ff		ldx	#$FF
.3f46	7a		ply			ply
.3f47	4c a2 29	jmp $29a2			jmp 	NextCommand
.3f4a					X16_Audio_PSGPLAY:
.3f4a	fa		plx				plx
.3f4b	5a		phy			phy
.3f4c	20 5a 2b	jsr $2b5a		jsr		X16_Audio_Parameters8_String
.3f4f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3f52	18 c0					.word	X16A_bas_psgplaystring
>3f54	0a					.byte	X16_AudioCodeBank
.3f55	a2 ff		ldx #$ff		ldx	#$FF
.3f57	7a		ply			ply
.3f58	4c a2 29	jmp $29a2			jmp 	NextCommand
.3f5b					X16_Audio_PSGCHORD:
.3f5b	fa		plx				plx
.3f5c	5a		phy			phy
.3f5d	20 5a 2b	jsr $2b5a		jsr		X16_Audio_Parameters8_String
.3f60	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>3f63	90 c0					.word	X16A_bas_psgchordstring
>3f65	0a					.byte	X16_AudioCodeBank
.3f66	a2 ff		ldx #$ff		ldx	#$FF
.3f68	7a		ply			ply
.3f69	4c a2 29	jmp $29a2			jmp 	NextCommand
.3f6c					CommandCls:
.3f6c	fa		plx				plx
.3f6d	a9 93		lda #$93			lda 	#147
.3f6f	20 c3 3d	jsr $3dc3			jsr 	XPrintCharacterToChannel
.3f72	4c a2 29	jmp $29a2			jmp 	NextCommand
.3f75					CommandLocate:
.3f75	fa		plx				plx
.3f76	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.3f79	ca		dex				dex
.3f7a	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.3f7d	ca		dex				dex
.3f7e	a9 13		lda #$13			lda 	#$13 						; home.
.3f80	20 c3 3d	jsr $3dc3			jsr 	XPrintCharacterToChannel
.3f83	a9 1d		lda #$1d			lda 	#$1D 						; do cursor rights
.3f85	a6 39		ldx $39				ldx 	NSMantissa0+1
.3f87	20 94 3f	jsr $3f94			jsr 	_CLOutputXA
.3f8a	a9 11		lda #$11			lda 	#$11 						; do cursor downs.
.3f8c	a6 38		ldx $38				ldx 	NSMantissa0
.3f8e	20 94 3f	jsr $3f94			jsr 	_CLOutputXA
.3f91	4c a2 29	jmp $29a2			jmp 	NextCommand
.3f94					_CLOutputXA:
.3f94	ca		dex				dex
.3f95	f0 07		beq $3f9e			beq 	_CLOExit
.3f97	30 05		bmi $3f9e			bmi 	_CLOExit
.3f99	20 c3 3d	jsr $3dc3			jsr 	XPrintCharacterToChannel
.3f9c	80 f6		bra $3f94			bra 	_CLOutputXA
.3f9e					_CLOExit:
.3f9e	60		rts				rts
.3f9f					CommandColor:
.3f9f	fa		plx				plx
.3fa0	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.3fa3	ca		dex				dex
.3fa4	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.3fa7	ca		dex				dex
.3fa8	a5 39		lda $39				lda 	NSMantissa0+1 				; bgr specified
.3faa	c9 ff		cmp #$ff			cmp 	#$FF
.3fac	f0 08		beq $3fb6			beq 	_CCNoBGR 					; if so, change background
.3fae	20 be 3f	jsr $3fbe			jsr 	_CCSetColour
.3fb1	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.3fb3	20 c3 3d	jsr $3dc3			jsr 	XPrintCharacterToChannel
.3fb6					_CCNoBGR:
.3fb6	a5 38		lda $38				lda 	NSMantissa0
.3fb8	20 be 3f	jsr $3fbe			jsr 	_CCSetColour
.3fbb	4c a2 29	jmp $29a2			jmp 	NextCommand
.3fbe					_CCSetColour:
.3fbe	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.3fc0	aa		tax				tax
.3fc1	bd c8 3f	lda $3fc8,x			lda 	_CCCommandTable,x
.3fc4	20 c3 3d	jsr $3dc3			jsr 	XPrintCharacterToChannel
.3fc7	60		rts				rts
.3fc8					_CCCommandTable:
>3fc8	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>3fd0	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.3fd8					CommandVPOKE:
.3fd8	fa		plx				plx
.3fd9	20 7e 31	jsr $317e			jsr 	GetInteger8Bit 				; poke value
.3fdc	48		pha				pha
.3fdd	ca		dex				dex
.3fde	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.3fe1	b5 38		lda $38,x			lda 	NSMantissa0,x
.3fe3	8d 20 9f	sta $9f20			sta 	VRAMLow0
.3fe6	b5 44		lda $44,x			lda 	NSMantissa1,x
.3fe8	8d 21 9f	sta $9f21			sta 	VRAMMed0
.3feb	ca		dex				dex
.3fec	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.3fef	20 7e 31	jsr $317e			jsr 	GetInteger8Bit
.3ff2	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.3ff5	ca		dex				dex
.3ff6	68		pla				pla 								; poke value back
.3ff7	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.3ffa	4c a2 29	jmp $29a2			jmp 	NextCommand
.3ffd					CommandVPEEK:
.3ffd	fa		plx				plx
.3ffe	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.4001	b5 38		lda $38,x			lda 	NSMantissa0,x
.4003	8d 20 9f	sta $9f20			sta 	VRAMLow0
.4006	b5 44		lda $44,x			lda 	NSMantissa1,x
.4008	8d 21 9f	sta $9f21			sta 	VRAMMed0
.400b	ca		dex				dex
.400c	20 b1 13	jsr $13b1			jsr 	FloatIntegerPart
.400f	20 7e 31	jsr $317e			jsr 	GetInteger8Bit
.4012	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.4015	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.4018	20 78 17	jsr $1778			jsr 	FloatSetByte 				; return as byte
.401b	4c a2 29	jmp $29a2			jmp 	NextCommand

;******  Processing input file: testing/testend.asm

=$4100							nextPage = (* + $FF) & $FF00 		; so I can include with that f*****g header.
.40fe					ObjectCodePreHeader:
>40fe	00 a0 d4 54 00 a6 0e 48				.binary "code/code.bin"
>4106	00 a6 03 c7 a6 cb 93 93 b1 ce 0d 48 45 4c 4c 4f
>4116	20 57 4f 52 4c 44 20 21 b1 0d 92 a6 40 00 01 00
>4126	ca 81 58 03 40 00 01 00 ca 81 58 06 40 00 01 00
>4136	ca 81 58 09 a6 40 00 01 00 ca 81 58 0c 40 00 01
>4146	00 ca 81 58 0f a6 00 48 12 24 40 00 01 95 a6 40
>4156	12 01 50 03 8e 01 b4 28 82 ca 84 02 82 01 80 7c
>4166	a6 40 12 01 50 06 8e 01 b4 1e 82 ca 84 cc 00 01
>4176	82 7c a6 40 12 01 50 09 8e 01 b4 0e 82 ca 84 01
>4186	80 7c a6 40 12 01 50 0c 8e 01 b4 02 82 ca 84 7c
>4196	a6 a6 40 12 01 50 0f 8e 01 7c a6 24 a7 a6 a6 00
>41a6	48 15 2a 1d 01 95 00 48 18 30 27 01 95 a6 40 15
>41b6	cc 00 01 82 40 18 02 82 80 cc 00 b0 80 48 1b a6
>41c6	01 40 1b cb 51 c8 01 40 1b 01 80 00 c8 a6 30 a7
>41d6	2a a7 a6 01 48 12 24 40 00 01 95 a6 01 cc 00 b0
>41e6	40 12 01 50 06 8e 78 80 40 12 01 50 03 8e 78 80
>41f6	00 c8 a6 40 12 01 50 0c 8e 78 48 1e a6 40 1e 00
>4206	a3 88 d2 05 00 d1 55 00 a6 40 1e 01 a3 88 d2 05
>4216	00 d1 73 00 a6 40 12 01 50 0f 8e 78 48 21 a6 40
>4226	21 00 a3 88 d2 05 00 d1 91 00 a6 40 21 01 a3 88
>4236	d2 05 00 d1 b1 00 a6 01 cc 00 b0 40 12 01 50 06
>4246	8e 78 80 40 12 01 50 03 8e 78 80 40 12 01 50 09
>4256	8e 78 c8 a6 24 a7 a6 d0 7a ff a6 a6 40 12 01 50
>4266	03 8e 78 48 24 a6 40 24 01 a3 88 d2 0b 00 40 12
>4276	01 50 0c 8e 01 7c 98 a6 40 12 01 50 03 8e 40 24
>4286	02 81 7c 98 a6 a6 40 12 01 50 03 8e 78 48 24 a6
>4296	40 24 cb 4f a3 88 d2 14 00 40 12 01 50 03 8e cb
>42a6	4d 7c 40 12 01 50 0c 8e 00 7c 98 a6 40 12 01 50
>42b6	03 8e 40 24 02 80 7c 98 a6 a6 40 12 01 50 06 8e
>42c6	78 48 27 a6 40 27 00 a3 88 d2 0b 00 40 12 01 50
>42d6	0f 8e 01 7c 98 a6 40 12 01 50 06 8e 40 27 cc 00
>42e6	01 81 7c 98 a6 a6 40 12 01 50 06 8e 78 48 27 a6
>42f6	40 27 cc 00 1d a3 88 d2 15 00 40 12 01 50 06 8e
>4306	cc 00 1c 7c 40 12 01 50 0f 8e 00 7c 98 a6 40 12
>4316	01 50 06 8e 40 27 cc 00 01 80 7c 98 c4 ff
=16640					ObjectCode = ObjectCodePreHeader+2 			; so the code is at XX00

;******  End of listing
