
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library testing/testend.asm
; Sat Oct 14 16:10:51 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

.0801					WrapperBoot:
.0801	a9 2b		lda #$2b			lda 	#ObjectCode >> 8 			; address of object code to run.
.0803	a2 81		ldx #$81			ldx 	#$81 						; first page of allocatable memory
.0805	a0 9f		ldy #$9f			ldy 	#$9F 						; byte after end of last page.
.0807	20 0f 08	jsr $080f			jsr 	StartRuntime 				; try to run it
.080a					_WBStop:
.080a	b0 fe		bcs $080a			bcs 	_WBStop
.080c	4c ff ff	jmp $ffff			jmp 	$FFFF 						; then exit.

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.080f					StartRuntime:
.080f	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.0812	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.0814	64 28		stz $28				stz 	codePtr
.0816	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0819	8c 06 04	sty $0406			sty 	storeEndHigh
.081c	8e 07 04	stx $0407			stx 	variableStartPage
.081f	ba		tsx				tsx 								; save the stack.
.0820	8e 08 04	stx $0408			stx 	Runtime6502SP
.0823	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.0825	a2 41		ldx #$41			ldx 	#RuntimeErrorHandler & $FF
.0827	20 15 1f	jsr $1f15			jsr 	SetErrorHandler
.082a	20 6d 0a	jsr $0a6d			jsr 	ClearMemory 				; clear memory.
.082d	20 92 16	jsr $1692			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0830	20 7e 13	jsr $137e		 	jsr		SetDefaultChannel			; set default input/output channel.
.0833	20 ca 15	jsr $15ca			jsr 	RestoreCode 				; which we now call
.0836	a0 00		ldy #$00			ldy 	#0
.0838					NextCommand:
.0838	ad 09 04	lda $0409			lda  	breakCount 					; only check every 16 instructions.
.083b	69 10		adc #$10			adc 	#16
.083d	8d 09 04	sta $0409			sta 	breakCount
.0840	90 07		bcc $0849			bcc 	_NXNoCheck
.0842	da		phx				phx
.0843	5a		phy				phy 								; check Ctrl+C
.0844	20 d0 1b	jsr $1bd0			jsr 	XCheckStop
.0847	7a		ply				ply
.0848	fa		plx				plx
.0849					_NXNoCheck:
.0849	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.084b	30 5b		bmi $08a8			bmi 	NXCommand 					; -if -ve command
.084d	c8		iny				iny
.084e	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0850	90 39		bcc $088b			bcc 	PushByteA 					; 0..63 is short constants.
.0852					NXLoadStore:
.0852	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.0854	b0 19		bcs $086f			bcs 	NXIndirectLoadStore
.0856	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.0857	4a		lsr a				lsr 	a
.0858	29 0e		and #$0e			and 	#$0E
.085a	da		phx				phx 								; get ready to jump
.085b	aa		tax				tax
.085c	7c 5f 08	jmp ($085f,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.085f					ReadWriteVectors:
>085f	ea 14						.word 	ReadFloatCommand			; read float
>0861	df 1a						.word 	WriteFloatCommand 			; write float
>0863	26 15						.word 	ReadIntegerCommand 			; read integer
>0865	1b 1b						.word 	WriteIntegerCommand 		; write integer
>0867	6b 15						.word 	ReadStringCommand 			; read string
>0869	5a 1b						.word 	WriteStringCommand 			; write string
>086b	3e 0c						.word 	Unimplemented
>086d	3e 0c						.word 	Unimplemented
.086f					NXIndirectLoadStore:
.086f	29 07		and #$07			and 	#7
.0871	0a		asl a				asl 	a
.0872	da		phx				phx
.0873	aa		tax				tax
.0874	7c 77 08	jmp ($0877,x)			jmp 	(IndirectVectors,x)
.0877					IndirectVectors:
>0877	fb 0e						.word 	IndFloatRead 				; float read
>0879	0f 0f						.word 	IndInt16Read 				; int16 read
>087b	23 0f						.word 	IndStringRead 				; string read
>087d	3e 0c						.word 	Unimplemented
>087f	37 0f						.word 	IndFloatWrite				; float write
>0881	4b 0f						.word 	IndInt16Write 				; int16 write
>0883	5f 0f						.word 	IndStringWrite 				; string write
>0885	3e 0c						.word 	Unimplemented
.0887					PushByteCommand:
.0887	fa		plx				plx
.0888	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.088a	c8		iny				iny
.088b					PushByteA:
.088b	e8		inx				inx 								; push constant on stack
.088c	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.088e	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.0890					ClearRestWord:
.0890	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.0892	74 62		stz $62,x			stz 	NSMantissa3,x
.0894	74 6e		stz $6e,x			stz 	NSExponent,x
.0896	74 32		stz $32,x			stz 	NSStatus,x
.0898	80 9e		bra $0838			bra 	NextCommand
.089a					PushWordCommand:
.089a	fa		plx				plx
.089b	e8		inx				inx
.089c	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.089e	c8		iny				iny
.089f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08a1	b1 28		lda ($28),y			lda 	(codePtr),y
.08a3	c8		iny				iny
.08a4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08a6	80 e8		bra $0890			bra 	ClearRestWord 				; handle everything else.
.08a8					NXCommand:
.08a8	c8		iny				iny 								; consume command.
.08a9	10 03		bpl $08ae			bpl 	_NXCommandNoFixUp
.08ab	20 b4 08	jsr $08b4			jsr 	FixUpY
.08ae					_NXCommandNoFixUp:
.08ae	0a		asl a				asl 	a 							; shift left
.08af	da		phx				phx 								; save SP on stack
.08b0	aa		tax				tax				 					; and jump indirect
.08b1	7c bc 19	jmp ($19bc,x)			jmp 	(VectorTable,x)
.08b4					FixUpY:
.08b4	48		pha				pha
.08b5	98		tya				tya
.08b6	18		clc				clc
.08b7	65 28		adc $28				adc 	codePtr
.08b9	85 28		sta $28				sta 	codePtr
.08bb	90 02		bcc $08bf			bcc 	_NoCPCarry
.08bd	e6 29		inc $29				inc 	codePtr+1
.08bf					_NoCPCarry:
.08bf	a0 00		ldy #$00			ldy 	#0
.08c1	68		pla				pla
.08c2	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.0408					Runtime6502SP:
>0408							.fill 	1
.0409					breakCount:
>0409							.fill 	1
.08c3					AbsoluteTOS:
.08c3	fa		plx				plx
.08c4	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08c6	4c 38 08	jmp $0838			jmp 	NextCommand
.08c9					CommandVarSpace:
.08c9	fa		plx				plx
.08ca	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08cc	85 26		sta $26				sta 	availableMemory
.08ce	c8		iny				iny
.08cf	b1 28		lda ($28),y			lda 	(codePtr),y
.08d1	18		clc				clc
.08d2	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08d5	85 27		sta $27				sta 	availableMemory+1
.08d7	c8		iny				iny
.08d8	4c 38 08	jmp $0838			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08db					BinaryAnd:
.08db	fa		plx				plx
.08dc	38		sec				sec
.08dd	80 02		bra $08e1			bra 	AndOrCommon
.08df					BinaryOr:
.08df	fa		plx				plx
.08e0	18		clc				clc
.08e1					AndOrCommon:
.08e1	08		php				php 								; save AND/OR flag
.08e2	20 36 10	jsr $1036			jsr 	GetInteger16Bit
.08e5	ca		dex				dex
.08e6	20 36 10	jsr $1036			jsr 	GetInteger16Bit
.08e9	28		plp				plp
.08ea	90 0e		bcc $08fa			bcc 	_AOCOrCode
.08ec	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.08ee	35 3f		and $3f,x			and		NSMantissa0+1,x
.08f0	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08f2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.08f4	35 4b		and $4b,x			and		NSMantissa1+1,x
.08f6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08f8	80 0c		bra $0906			bra 	_AOCComplete
.08fa					_AOCOrCode:
.08fa	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.08fc	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.08fe	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0900	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0902	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.0904	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0906					_AOCComplete:
.0906	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.0908	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.090a	10 07		bpl $0913			bpl 	_AOCExit
.090c	20 46 10	jsr $1046			jsr 	Negate16Bit 				; 2's complement
.090f	a9 80		lda #$80			lda 	#$80 						; make it -ve
.0911	95 32		sta $32,x			sta 	NSStatus,x
.0913					_AOCExit:
.0913	4c 38 08	jmp $0838			jmp 	NextCommand
.0916					ArrayConvert:
.0916	fa		plx				plx
.0917	5a		phy				phy
.0918	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.091a	85 2e		sta $2e				sta 	zTemp1
.091c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.091e	18		clc				clc
.091f	6d 07 04	adc $0407			adc 	variableStartPage
.0922	85 2f		sta $2f				sta 	zTemp1+1
.0924	ca		dex				dex 								; count of indices to follow -> zTemp2
.0925	20 30 10	jsr $1030			jsr 	GetInteger8Bit
.0928	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.092a	8a		txa				txa
.092b	38		sec				sec
.092c	e5 30		sbc $30				sbc 	zTemp2
.092e	aa		tax				tax
.092f	da		phx				phx 								; stack points at the first index, which will be replaced.
.0930					_ACIndexLoop:
.0930	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart 			; integer array index
.0933	20 36 10	jsr $1036			jsr 	GetInteger16Bit 			; get the index => zTemp0
.0936	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.0938	a5 2c		lda $2c				lda 	zTemp0
.093a	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.093c	a5 2d		lda $2d				lda 	zTemp0+1
.093e	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0940	b0 79		bcs $09bb			bcs 	_ACBadIndex 				; index error.
.0942	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.0944	f0 29		beq $096f			beq 	_ACInnerLevel
.0946	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.0948	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.094a	10 6f		bpl $09bb			bpl 	_ACBadIndex
.094c	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.094e	26 2d		rol $2d				rol 	zTemp0+1
.0950	18		clc				clc
.0951	a5 2c		lda $2c				lda		zTemp0
.0953	65 2e		adc $2e				adc 	zTemp1
.0955	85 2c		sta $2c				sta 	zTemp0
.0957	a5 2d		lda $2d				lda		zTemp0+1
.0959	65 2f		adc $2f				adc 	zTemp1+1
.095b	85 2d		sta $2d				sta 	zTemp0+1
.095d	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.095f	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0961	85 2e		sta $2e				sta 	zTemp1
.0963	c8		iny				iny
.0964	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0966	18		clc				clc
.0967	6d 07 04	adc $0407			adc 	variableStartPage
.096a	85 2f		sta $2f				sta 	zTemp1+1
.096c	e8		inx				inx 								; next index
.096d	80 c1		bra $0930			bra 	_ACIndexLoop
.096f					_ACInnerLevel:
.096f	a0 02		ldy #$02			ldy 	#2
.0971	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0973	30 46		bmi $09bb			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.0975	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.0977	c9 00		cmp #$00			cmp 	#NSSIFloat
.0979	d0 13		bne $098e			bne 	_ACNotFloat
.097b	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.097d	48		pha				pha
.097e	a5 2c		lda $2c				lda 	zTemp0
.0980	06 2c		asl $2c				asl 	zTemp0 						; x 2
.0982	26 2d		rol $2d				rol 	zTemp0+1
.0984	18		clc				clc 								; add back x 3
.0985	65 2c		adc $2c				adc 	zTemp0
.0987	85 2c		sta $2c				sta 	zTemp0
.0989	68		pla				pla
.098a	65 2d		adc $2d				adc 	zTemp0+1
.098c	85 2d		sta $2d				sta 	zTemp0+1
.098e					_ACNotFloat:
.098e	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.0990	26 2d		rol $2d				rol 	zTemp0+1
.0992	18		clc				clc
.0993	a5 2c		lda $2c				lda 	zTemp0
.0995	69 03		adc #$03			adc 	#3
.0997	85 2c		sta $2c				sta 	zTemp0
.0999	90 02		bcc $099d			bcc 	_ACNoCarry
.099b	e6 2d		inc $2d				inc 	zTemp0+1
.099d					_ACNoCarry:
.099d	fa		plx				plx 								; X points to first slot of array parameters
.099e	18		clc				clc
.099f	a5 2c		lda $2c				lda 	zTemp0
.09a1	65 2e		adc $2e				adc 	zTemp1
.09a3	95 3e		sta $3e,x			sta 	NSMantissa0,x
.09a5	a5 2d		lda $2d				lda 	zTemp0+1
.09a7	65 2f		adc $2f				adc 	zTemp1+1
.09a9	38		sec				sec
.09aa	ed 07 04	sbc $0407			sbc 	variableStartPage
.09ad	95 4a		sta $4a,x			sta 	NSMantissa1,x
.09af	74 56		stz $56,x			stz 	NSMantissa2,x
.09b1	74 62		stz $62,x			stz 	NSMantissa3,x
.09b3	74 32		stz $32,x			stz 	NSStatus,x
.09b5	74 6e		stz $6e,x			stz 	NSExponent,x
.09b7	7a		ply				ply 	 							; restore code pointer
.09b8	4c 38 08	jmp $0838			jmp 	NextCommand
.09bb					_ACBadIndex:
.09bb	4c 17 20	jmp $2017		jmp	ErrorV_index
.09be					UnaryAsc:
.09be	fa		plx				plx
.09bf	5a		phy				phy
.09c0	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09c2	85 2c		sta $2c				sta 	zTemp0
.09c4	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09c6	85 2d		sta $2d				sta 	zTemp0+1
.09c8	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09ca	f0 06		beq $09d2			beq 	_UAExit
.09cc	5a		phy				phy 								; otherwise first character
.09cd	a0 01		ldy #$01			ldy 	#1
.09cf	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09d1	7a		ply				ply
.09d2					_UAExit:
.09d2	20 96 26	jsr $2696			jsr 	FloatSetByte
.09d5	7a		ply				ply
.09d6	4c 38 08	jmp $0838			jmp 	NextCommand
.09d9					CommandAssert:
.09d9	fa		plx				plx
.09da	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09dc	d0 09		bne $09e7			bne 	_CAFail
.09de	20 b6 26	jsr $26b6			jsr 	FloatIsZero 				; is it zero ?
.09e1	f0 04		beq $09e7			beq 	_CAFail
.09e3	ca		dex				dex
.09e4	4c 38 08	jmp $0838			jmp 	NextCommand
.09e7					_CAFail:
.09e7	4c 70 1f	jmp $1f70		jmp	ErrorV_assert
.09ea					X16_Audio_Parameters8_16:
.09ea	20 f0 09	jsr $09f0			jsr 	X16_Audio_Parameters8_8
.09ed	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.09ef	60		rts				rts
.09f0					X16_Audio_Parameters8_8:
.09f0	a2 01		ldx #$01			ldx 	#1
.09f2	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.09f5	ca		dex				dex
.09f6	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.09f9	20 30 10	jsr $1030			jsr 	GetInteger8Bit
.09fc	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.09fe	a0 00		ldy #$00			ldy 	#0
.0a00	60		rts				rts
.0a01					X16_Audio_Parameters8_String:
.0a01	20 ea 09	jsr $09ea			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.0a04	da		phx				phx 								; set the voice
.0a05	5a		phy				phy
.0a06	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.0a09	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>0a0c	0a						.byte 	X16_AudioCodeBank
.0a0d	7a		ply				ply
.0a0e	fa		plx				plx
.0a0f	86 2c		stx $2c				stx 	zTemp0
.0a11	84 2d		sty $2d				sty 	zTemp0+1
.0a13	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a15	e8		inx				inx 								; point YX to first character.
.0a16	d0 01		bne $0a19			bne 	_X16APSSkip
.0a18	c8		iny				iny
.0a19					_X16APSSkip:
.0a19	60		rts				rts
.0a1a					Unary16Bin:
.0a1a	fa		plx				plx
.0a1b	20 36 10	jsr $1036			jsr 	GetInteger16Bit				; 16 bit int
.0a1e	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a20	20 3b 17	jsr $173b			jsr 	StringAllocTemp
.0a23	a5 2d		lda $2d				lda 	zTemp0+1
.0a25	f0 03		beq $0a2a			beq 	_UBNoHigh
.0a27	20 32 0a	jsr $0a32			jsr 	_UBWriteBinary
.0a2a					_UBNoHigh:
.0a2a	a5 2c		lda $2c				lda 	zTemp0
.0a2c	20 32 0a	jsr $0a32			jsr 	_UBWriteBinary
.0a2f	4c 38 08	jmp $0838			jmp 	NextCommand
.0a32					_UBWriteBinary:
.0a32	5a		phy				phy
.0a33	a0 08		ldy #$08			ldy 	#8
.0a35					_UBWLoop:
.0a35	0a		asl a				asl 	a
.0a36	48		pha				pha
.0a37	a9 00		lda #$00			lda  	#0
.0a39	69 30		adc #$30			adc 	#48
.0a3b	20 64 17	jsr $1764			jsr 	StringWriteChar
.0a3e	68		pla				pla
.0a3f	88		dey				dey
.0a40	d0 f3		bne $0a35			bne 	_UBWLoop
.0a42	7a		ply				ply
.0a43	60		rts				rts
.0a44					PrintCharacterX:
.0a44	fa		plx				plx
.0a45	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a47	ca		dex				dex
.0a48	20 82 13	jsr $1382			jsr 	VectorPrintCharacter
.0a4b	4c 38 08	jmp $0838			jmp 	NextCommand
.0a4e					UnaryChr:
.0a4e	fa		plx				plx
.0a4f	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; get integer to convert.
.0a52	48		pha				pha 								; save it and allocate for it
.0a53	a9 01		lda #$01			lda 	#1 							; 1 character
.0a55	20 3b 17	jsr $173b			jsr 	StringAllocTemp
.0a58	a9 01		lda #$01			lda 	#1 							; length 1.
.0a5a	92 22		sta ($22)			sta 	(zsTemp)
.0a5c	68		pla				pla 								; character code makes string.
.0a5d	5a		phy				phy
.0a5e	a0 01		ldy #$01			ldy 	#1
.0a60	91 22		sta ($22),y			sta 	(zsTemp),y
.0a62	7a		ply				ply
.0a63	4c 38 08	jmp $0838			jmp 	NextCommand
.0a66					CommandClr:
.0a66	fa		plx				plx
.0a67	20 6d 0a	jsr $0a6d			jsr 	ClearMemory
.0a6a	4c 38 08	jmp $0838			jmp 	NextCommand
.0a6d					ClearMemory:
.0a6d	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a70	85 2d		sta $2d				sta 	zTemp0+1
.0a72	64 2c		stz $2c				stz 	zTemp0
.0a74	5a		phy				phy
.0a75	a0 00		ldy #$00			ldy 	#0
.0a77					_ClearLoop1:
.0a77	a9 00		lda #$00			lda 	#0
.0a79	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a7b	c8		iny				iny
.0a7c	d0 f9		bne $0a77			bne 	_ClearLoop1
.0a7e	e6 2d		inc $2d				inc 	zTemp0+1
.0a80	a5 2d		lda $2d				lda 	zTemp0+1
.0a82	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a85	d0 f0		bne $0a77			bne 	_ClearLoop1
.0a87	38		sec				sec 											; stack space = number of pages in total / 4
.0a88	ad 06 04	lda $0406			lda 	storeEndHigh
.0a8b	ed 05 04	sbc $0405			sbc		storeStartHigh
.0a8e	4a		lsr a				lsr 	a
.0a8f	4a		lsr a				lsr 	a
.0a90	d0 02		bne $0a94			bne 	_NotEmpty 								; at least 1 !
.0a92	a9 01		lda #$01			lda 	#1
.0a94					_NotEmpty:
.0a94	38		sec				sec 											; subtract from high to give string high memory
.0a95	49 ff		eor #$ff			eor 	#$FF
.0a97	6d 06 04	adc $0406			adc 	storeEndHigh
.0a9a	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0a9d	9c 02 04	stz $0402			stz 	stringHighMemory
.0aa0	9c 6a 05	stz $056a			stz 	stringInitialised 						; string system not initialised
.0aa3	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0aa6	3a		dec a				dec 	a
.0aa7	85 25		sta $25				sta 	runtimeStackPtr+1
.0aa9	a9 ff		lda #$ff			lda 	#$FF
.0aab	85 24		sta $24				sta 	runtimeStackPtr
.0aad	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0aaf	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0ab1	7a		ply				ply
.0ab2	60		rts				rts
.0ab3					CompareStrings:
.0ab3	fa		plx				plx
.0ab4	ca		dex				dex
.0ab5	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0ab7	85 2c		sta $2c				sta 	zTemp0
.0ab9	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0abb	85 2d		sta $2d				sta 	zTemp0+1
.0abd	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0abf	85 2e		sta $2e				sta 	zTemp1
.0ac1	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0ac3	85 2f		sta $2f				sta 	zTemp1+1
.0ac5	da		phx				phx
.0ac6	5a		phy				phy
.0ac7	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0ac9	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0acb	90 02		bcc $0acf			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0acd	b2 2e		lda ($2e)			lda 	(zTemp1)
.0acf					_CSNIsSmallest:
.0acf	aa		tax				tax 								; count in X
.0ad0	f0 0c		beq $0ade			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0ad2	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0ad4					_CSNCompareString:
.0ad4	c8		iny				iny 								; pre increment
.0ad5	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0ad7	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0ad9	d0 0a		bne $0ae5			bne 	_CSNDifferent 				; numbers are different.
.0adb	ca		dex				dex
.0adc	d0 f6		bne $0ad4			bne 	_CSNCompareString 			; compare common characters in two strings.
.0ade					_CSNMatches:
.0ade	38		sec				sec
.0adf	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0ae1	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0ae3	f0 06		beq $0aeb			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0ae5					_CSNDifferent:
.0ae5	a9 ff		lda #$ff			lda 	#$FF
.0ae7	90 02		bcc $0aeb			bcc 	_CSNSExit
.0ae9	a9 01		lda #$01			lda 	#$01
.0aeb					_CSNSExit:
.0aeb	7a		ply				ply
.0aec	fa		plx				plx
.0aed	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0aef	20 96 26	jsr $2696			jsr 	FloatSetByte 				; output the byte
.0af2	4c 38 08	jmp $0838			jmp 	NextCommand
.0af5					StringConcrete:
.0af5	9c 6a 05	stz $056a			stz 	stringInitialised	 		; initialise next usage
.0af8	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0afa	85 30		sta $30				sta 	zTemp2
.0afc	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0afe	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0aff	18		clc				clc
.0b00	72 30		adc ($30)			adc 	(zTemp2)
.0b02	90 02		bcc $0b06			bcc 	_SCNoOverflow
.0b04	a9 ff		lda #$ff			lda 	#255
.0b06					_SCNoOverflow:
.0b06	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0b08	b0 02		bcs $0b0c			bcs 	_SCNoMinimum
.0b0a	a9 0a		lda #$0a			lda 	#10
.0b0c					_SCNoMinimum:
.0b0c	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0b0e	38		sec				sec
.0b0f	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0b12	e5 2e		sbc $2e				sbc 	zTemp1
.0b14	a8		tay				tay
.0b15	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b18	e9 00		sbc #$00			sbc 	#0
.0b1a	48		pha				pha
.0b1b	38		sec				sec 								; subtract 3 more
.0b1c	98		tya				tya
.0b1d	e9 03		sbc #$03			sbc 	#3
.0b1f	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b22	85 22		sta $22				sta 	zsTemp
.0b24	68		pla				pla
.0b25	e9 00		sbc #$00			sbc 	#0
.0b27	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b2a	85 23		sta $23				sta 	zsTemp+1
.0b2c	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b2e	92 22		sta ($22)			sta 	(zsTemp)
.0b30	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b32	a9 00		lda #$00			lda 	#0
.0b34	91 22		sta ($22),y			sta 	(zsTemp),y
.0b36	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b38	a4 23		ldy $23				ldy 	zsTemp+1
.0b3a	60		rts				rts
.0b3b					CommandXData:
.0b3b	fa		plx				plx
.0b3c	98		tya				tya 								; data length +1 added to Y
.0b3d	38		sec				sec
.0b3e	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b40	a8		tay				tay
.0b41	4c 38 08	jmp $0838			jmp 	NextCommand
.0b44					CommandXDIM:
.0b44	fa		plx				plx
.0b45	5a		phy				phy
.0b46	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b49	8d 0a 04	sta $040a			sta 	dimType
.0b4c	ca		dex				dex 								; this is the number of indices
.0b4d	20 30 10	jsr $1030			jsr 	GetInteger8Bit
.0b50	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b52	8a		txa				txa 								; dimension.
.0b53	38		sec				sec
.0b54	e5 2e		sbc $2e				sbc 	zTemp1
.0b56	aa		tax				tax
.0b57	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b59	20 6d 0b	jsr $0b6d			jsr 	DIMCreateOneLevel 			; create one at this level
.0b5c	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b5e	98		tya				tya
.0b5f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b61	74 56		stz $56,x			stz 	NSMantissa2,x
.0b63	74 62		stz $62,x			stz 	NSMantissa3,x
.0b65	74 32		stz $32,x			stz 	NSStatus,x
.0b67	74 6e		stz $6e,x			stz 	NSExponent,x
.0b69	7a		ply				ply
.0b6a	4c 38 08	jmp $0838			jmp 	NextCommand
.0b6d					DIMCreateOneLevel:
.0b6d	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b6f	5a		phy				phy
.0b70	a4 27		ldy $27				ldy 	availableMemory+1
.0b72	5a		phy				phy
.0b73	a8		tay				tay 			 					; save current level into Y
.0b74	20 36 10	jsr $1036			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b77	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b79	d0 02		bne $0b7d			bne 	_DCOLNoCarry
.0b7b	e6 2d		inc $2d				inc 	zTemp0+1
.0b7d					_DCOLNoCarry:
.0b7d	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b7f	20 20 0c	jsr $0c20			jsr 	DIMWriteByte
.0b82	a5 2d		lda $2d				lda 	zTemp0+1
.0b84	20 20 0c	jsr $0c20			jsr 	DIMWriteByte
.0b87	ad 0a 04	lda $040a			lda 	dimType 					; get type information
.0b8a	29 7f		and #$7f			and 	#$7F
.0b8c	c0 01		cpy #$01			cpy 	#1
.0b8e	f0 02		beq $0b92			beq 	_DCOLNoSubLevel
.0b90	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0b92					_DCOLNoSubLevel:
.0b92	20 20 0c	jsr $0c20			jsr 	DIMWriteByte
.0b95	a5 26		lda $26				lda 	availableMemory
.0b97	85 2e		sta $2e				sta 	zTemp1
.0b99	a5 27		lda $27				lda 	availableMemory+1
.0b9b	85 2f		sta $2f				sta 	zTemp1+1
.0b9d	a5 2c		lda $2c				lda 	zTemp0
.0b9f	85 30		sta $30				sta 	zTemp2
.0ba1	a5 2d		lda $2d				lda 	zTemp0+1
.0ba3	85 31		sta $31				sta 	zTemp2+1
.0ba5					_DCOLFillArray:
.0ba5	20 04 0c	jsr $0c04			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0ba8	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0baa	d0 02		bne $0bae			bne 	_DCOLNoBorrow
.0bac	c6 2d		dec $2d				dec 	zTemp0+1
.0bae					_DCOLNoBorrow:
.0bae	c6 2c		dec $2c				dec 	zTemp0
.0bb0	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0bb2	05 2d		ora $2d				ora 	zTemp0+1
.0bb4	d0 ef		bne $0ba5			bne 	_DCOLFillArray
.0bb6	c0 01		cpy #$01			cpy 	#1
.0bb8	f0 42		beq $0bfc			beq 	_DCOLExit
.0bba					_DCOLRecursionLoop:
.0bba	da		phx				phx 								; save XY
.0bbb	5a		phy				phy
.0bbc	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0bbe	48		pha				pha
.0bbf	a5 2f		lda $2f				lda 	zTemp1+1
.0bc1	48		pha				pha
.0bc2	a5 30		lda $30				lda 	zTemp2
.0bc4	48		pha				pha
.0bc5	a5 31		lda $31				lda 	zTemp2+1
.0bc7	48		pha				pha
.0bc8	88		dey				dey  								; lower level -> A
.0bc9	98		tya				tya
.0bca	e8		inx				inx 								; next index size
.0bcb	20 6d 0b	jsr $0b6d			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0bce	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0bcf	86 31		stx $31				stx 	zTemp2+1
.0bd1	fa		plx				plx
.0bd2	86 30		stx $30				stx 	zTemp2
.0bd4	fa		plx				plx
.0bd5	86 2f		stx $2f				stx 	zTemp1+1
.0bd7	fa		plx				plx
.0bd8	86 2e		stx $2e				stx 	zTemp1
.0bda	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0bdc	98		tya				tya
.0bdd	a0 01		ldy #$01			ldy 	#1
.0bdf	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0be1	7a		ply				ply 								; restore XY
.0be2	fa		plx				plx
.0be3	18		clc				clc
.0be4	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0be6	69 02		adc #$02			adc 	#2
.0be8	85 2e		sta $2e				sta 	zTemp1
.0bea	90 02		bcc $0bee			bcc 	_DCOLRNoCarry
.0bec	e6 2f		inc $2f				inc 	zTemp1+1
.0bee					_DCOLRNoCarry:
.0bee	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0bf0	d0 02		bne $0bf4			bne 	_DCOLRNoBorrow
.0bf2	c6 31		dec $31				dec 	zTemp2+1
.0bf4					_DCOLRNoBorrow:
.0bf4	c6 30		dec $30				dec 	zTemp2
.0bf6	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0bf8	05 31		ora $31				ora 	zTemp2+1
.0bfa	d0 be		bne $0bba			bne 	_DCOLRecursionLoop
.0bfc					_DCOLExit:
.0bfc	68		pla				pla 								; get MSB, make offset again
.0bfd	38		sec				sec
.0bfe	ed 07 04	sbc $0407			sbc 	variableStartPage
.0c01	a8		tay				tay
.0c02	68		pla				pla 								; YA now contains offset address.
.0c03	60		rts				rts
.0c04					DIMWriteElement:
.0c04	da		phx				phx
.0c05	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0c07	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0c09	d0 0b		bne $0c16			bne 	_DIMWENotFloat
.0c0b	ad 0a 04	lda $040a			lda 	dimType
.0c0e	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0c10	c9 00		cmp #$00			cmp 	#NSSIFloat
.0c12	d0 02		bne $0c16			bne 	_DIMWENotFloat
.0c14	a2 06		ldx #$06			ldx 	#6
.0c16					_DIMWENotFloat:
.0c16	a9 00		lda #$00			lda 	#0
.0c18	20 20 0c	jsr $0c20			jsr 	DIMWriteByte
.0c1b	ca		dex				dex
.0c1c	d0 f8		bne $0c16			bne 	_DIMWENotFloat
.0c1e	fa		plx				plx
.0c1f	60		rts				rts
.0c20					DIMWriteByte:
.0c20	92 26		sta ($26)			sta 	(availableMemory)
.0c22	e6 26		inc $26				inc 	availableMemory
.0c24	d0 0b		bne $0c31			bne 	_DIMWBSkip
.0c26	e6 27		inc $27				inc 	availableMemory+1
.0c28	48		pha				pha
.0c29	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c2b	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c2e	b0 02		bcs $0c32			bcs 	_DIMWBMemory
.0c30	68		pla				pla
.0c31					_DIMWBSkip:
.0c31	60		rts				rts
.0c32					_DIMWBMemory:
.0c32	4c 2a 20	jmp $202a		jmp	ErrorV_memory
.040a					dimType:
>040a							.fill 	1
.0c35					CommandEnd:
.0c35	fa		plx				plx
.0c36	86 2c		stx $2c				stx 	zTemp0
.0c38	18		clc				clc 								; exited okay.
.0c39					EndRuntime:
.0c39	ae 08 04	ldx $0408			ldx 	Runtime6502SP 				; set up the stack pointer
.0c3c	9a		txs				txs
.0c3d	60		rts				rts
.0c3e					Unimplemented:
.0c3e	4c 5d 1f	jmp $1f5d			jmp 	ErrorV_unimplemented
.0c41					RuntimeErrorHandler:
.0c41	98		tya				tya
.0c42	18		clc				clc
.0c43	65 28		adc $28				adc 	codePtr
.0c45	85 28		sta $28				sta 	codePtr
.0c47	90 02		bcc $0c4b			bcc 	_EHNoCarry
.0c49	e6 29		inc $29				inc 	codePtr+1
.0c4b					_EHNoCarry:
.0c4b	68		pla				pla
.0c4c	7a		ply				ply
.0c4d	85 2c		sta $2c				sta 	zTemp0
.0c4f	84 2d		sty $2d				sty 	zTemp0+1
.0c51	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c53	a0 01		ldy #$01			ldy 	#1
.0c55					_EHDisplayMsg:
.0c55	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c57	20 bd 1c	jsr $1cbd			jsr 	XPrintCharacterToChannel
.0c5a	c8		iny				iny
.0c5b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c5d	d0 f6		bne $0c55			bne 	_EHDisplayMsg
.0c5f	a9 20		lda #$20			lda 	#32
.0c61	20 bd 1c	jsr $1cbd			jsr 	XPrintCharacterToChannel
.0c64	a9 40		lda #$40			lda 	#64
.0c66	20 bd 1c	jsr $1cbd			jsr 	XPrintCharacterToChannel
.0c69	a9 20		lda #$20			lda 	#32
.0c6b	20 bd 1c	jsr $1cbd			jsr 	XPrintCharacterToChannel
.0c6e	20 75 0c	jsr $0c75			jsr 	EHDisplayCodePtr
.0c71	38		sec				sec 								; report error.
.0c72	4c 39 0c	jmp $0c39			jmp 	EndRuntime
.0c75					EHDisplayCodePtr:
.0c75	a9 24		lda #$24			lda 	#'$'
.0c77	20 bd 1c	jsr $1cbd			jsr 	XPrintCharacterToChannel
.0c7a	38		sec				sec
.0c7b	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c7d	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c80	20 89 0c	jsr $0c89			jsr 	_EHDisplayHex
.0c83	a5 28		lda $28				lda 	codePtr
.0c85	20 89 0c	jsr $0c89			jsr 	_EHDisplayHex
.0c88	60		rts				rts
.0c89					_EHDisplayHex:
.0c89	48		pha				pha
.0c8a	4a		lsr a				lsr 	a
.0c8b	4a		lsr a				lsr 	a
.0c8c	4a		lsr a				lsr 	a
.0c8d	4a		lsr a				lsr 	a
.0c8e	20 92 0c	jsr $0c92			jsr 	_EHDisplayNibble
.0c91	68		pla				pla
.0c92					_EHDisplayNibble:
.0c92	29 0f		and #$0f			and 	#15
.0c94	c9 0a		cmp #$0a			cmp 	#10
.0c96	90 02		bcc $0c9a			bcc 	_EHNotHex
.0c98	69 06		adc #$06			adc 	#6
.0c9a					_EHNotHex:
.0c9a	69 30		adc #$30			adc 	#48
.0c9c	4c bd 1c	jmp $1cbd			jmp 	XPrintCharacterToChannel
.0c9f					CommandXFor:
.0c9f	fa		plx				plx
.0ca0	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0ca2	20 22 0d	jsr $0d22			jsr 	StackOpenFrame
.0ca5	20 67 11	jsr $1167			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0ca8	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0caa	20 04 0d	jsr $0d04			jsr 	CopyTOSToOffsetY
.0cad	ca		dex				dex
.0cae	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0cb0	20 04 0d	jsr $0d04			jsr 	CopyTOSToOffsetY
.0cb3	ca		dex				dex
.0cb4	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0cb6	29 80		and #$80			and 	#$80
.0cb8	a0 04		ldy #$04			ldy 	#4
.0cba	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cbc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0cbe	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0cc0	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cc2	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0cc4	c8		iny				iny
.0cc5	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cc7	18		clc				clc
.0cc8	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0cca	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ccc	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0ccf	85 2d		sta $2d				sta 	zTemp0+1
.0cd1	ca		dex				dex 								; throw reference.
.0cd2	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0cd4	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0cd6	a0 0c		ldy #$0c			ldy 	#12
.0cd8	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cda	a0 12		ldy #$12			ldy 	#18
.0cdc	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cde	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0ce0	88		dey				dey 								; now the exponents.
.0ce1	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0ce3	a0 0b		ldy #$0b			ldy 	#11
.0ce5	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0ce7	a0 11		ldy #$11			ldy 	#17
.0ce9	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0ceb	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0ced	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cef	c8		iny				iny
.0cf0	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf2	c8		iny				iny
.0cf3	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf5	d0 08		bne $0cff			bne 	_CFNoOptimise
.0cf7	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0cf9	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0cfb	09 40		ora #$40			ora 	#$40
.0cfd	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cff					_CFNoOptimise:
.0cff	a0 00		ldy #$00			ldy 	#0
.0d01	4c 38 08	jmp $0838			jmp 	NextCommand
.0d04					CopyTOSToOffsetY:
.0d04	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0d06	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d08	c8		iny				iny
.0d09	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0d0b	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d0d	c8		iny				iny
.0d0e	b5 56		lda $56,x			lda 	NSMantissa2,x
.0d10	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d12	c8		iny				iny
.0d13	b5 62		lda $62,x			lda 	NSMantissa3,x
.0d15	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d17	c8		iny				iny
.0d18	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d1a	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d1c	c8		iny				iny
.0d1d	b5 32		lda $32,x			lda 	NSStatus,x
.0d1f	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d21	60		rts				rts
.0d22					StackOpenFrame:
.0d22	48		pha				pha 								; save frame marker
.0d23	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d25	85 2c		sta $2c				sta 	zTemp0
.0d27	38		sec				sec 								; subtract from runtime stack pointer.
.0d28	a5 24		lda $24				lda		runtimeStackPtr
.0d2a	e5 2c		sbc $2c				sbc 	zTemp0
.0d2c	85 24		sta $24				sta 	runtimeStackPtr
.0d2e	a5 25		lda $25				lda		runtimeStackPtr+1
.0d30	e9 00		sbc #$00			sbc 	#0
.0d32	85 25		sta $25				sta 	runtimeStackPtr+1
.0d34	68		pla				pla 								; put frame marker at +0
.0d35	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d37	60		rts				rts
.0d38					StackCloseFrame:
.0d38	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d3a	29 1f		and #$1f			and 	#$1F 						; size
.0d3c	18		clc				clc
.0d3d	65 24		adc $24				adc 	runtimeStackPtr
.0d3f	85 24		sta $24				sta 	runtimeStackPtr
.0d41	90 02		bcc $0d45			bcc 	_SCFNoCarry
.0d43	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d45					_SCFNoCarry:
.0d45	60		rts				rts
.0d46					StackFindFrame:
.0d46	8d 0b 04	sta $040b			sta 	requiredFrame
.0d49					_SFFLoop:
.0d49	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d4b	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d4d	f0 10		beq $0d5f			beq 	SCFFail
.0d4f	cd 0b 04	cmp $040b			cmp 	requiredFrame 				; found this type ?
.0d52	f0 05		beq $0d59			beq 	_SFFFound
.0d54	20 38 0d	jsr $0d38			jsr 	StackCloseFrame 			; close the top frame
.0d57	80 f0		bra $0d49			bra 	_SFFLoop 					; and try te next.
.0d59					_SFFFound:
.0d59	60		rts				rts
.0d5a					StackCheckFrame:
.0d5a	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d5c	d0 01		bne $0d5f			bne 	SCFFail
.0d5e	60		rts				rts
.0d5f					SCFFail:
.0d5f	4c ba 1f	jmp $1fba		jmp	ErrorV_structure
.040b					requiredFrame:
>040b							.fill 	1
.0d62					UnaryFre:
.0d62	fa		plx				plx
.0d63	20 94 26	jsr $2694			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d66	38		sec				sec
.0d67	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d6a	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d6d	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d6f	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d72	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d75	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d77	4c 38 08	jmp $0838			jmp 	NextCommand
.0d7a					CommandXGet:
.0d7a	fa		plx				plx
.0d7b	e8		inx				inx
.0d7c	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d7e	20 3b 17	jsr $173b			jsr 	StringAllocTemp
.0d81	20 8b 13	jsr $138b			jsr 	VectorGetCharacter 			; get a character
.0d84	c9 00		cmp #$00			cmp 	#0
.0d86	f0 09		beq $0d91			beq 	_CGNone
.0d88	5a		phy				phy
.0d89	a0 01		ldy #$01			ldy 	#1 							; store char
.0d8b	91 22		sta ($22),y			sta 	(zsTemp),y
.0d8d	98		tya				tya 								; store length.
.0d8e	92 22		sta ($22)			sta 	(zsTemp)
.0d90	7a		ply				ply
.0d91					_CGNone:
.0d91	4c 38 08	jmp $0838			jmp 	NextCommand
.0d94					CommandXGosub:
.0d94	fa		plx				plx
.0d95	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0d97	20 22 0d	jsr $0d22			jsr 	StackOpenFrame
.0d9a	20 67 11	jsr $1167			jsr 	StackSaveCurrentPosition
.0d9d	4c b2 0d	jmp $0db2			jmp 	PerformGOTO
.0da0					CommandReturn:
.0da0	fa		plx				plx
.0da1	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0da3	20 46 0d	jsr $0d46			jsr 	StackFindFrame
.0da6	20 78 11	jsr $1178			jsr 	StackLoadCurrentPosition
.0da9	c8		iny				iny
.0daa	c8		iny				iny
.0dab	20 38 0d	jsr $0d38			jsr 	StackCloseFrame
.0dae	4c 38 08	jmp $0838			jmp 	NextCommand
.0db1					CommandXGoto:
.0db1	fa		plx				plx
.0db2					PerformGOTO:
.0db2	c8		iny				iny 								; push MSB of offset on stack
.0db3	b1 28		lda ($28),y			lda 	(codePtr),y
.0db5	48		pha				pha
.0db6	88		dey				dey 								; point LSB of offset
.0db7	18		clc				clc 								; add LSB
.0db8	b1 28		lda ($28),y			lda 	(codePtr),y
.0dba	65 28		adc $28				adc 	codePtr
.0dbc	85 28		sta $28				sta 	codePtr
.0dbe	68		pla				pla 								; restore offset MSB and add
.0dbf	65 29		adc $29				adc 	codePtr+1
.0dc1	85 29		sta $29				sta 	codePtr+1
.0dc3	4c 38 08	jmp $0838			jmp 	NextCommand
.0dc6					CommandGotoZ:
.0dc6	fa		plx				plx
.0dc7	20 b6 26	jsr $26b6			jsr 	FloatIsZero
.0dca	ca		dex				dex
.0dcb	c9 00		cmp #$00			cmp 	#0
.0dcd	f0 e3		beq $0db2			beq 	PerformGOTO
.0dcf	c8		iny				iny
.0dd0	c8		iny				iny
.0dd1	4c 38 08	jmp $0838			jmp 	NextCommand
.0dd4					CommandGotoNZ:
.0dd4	fa		plx				plx
.0dd5	20 b6 26	jsr $26b6			jsr 	FloatIsZero
.0dd8	ca		dex				dex
.0dd9	c9 00		cmp #$00			cmp 	#0
.0ddb	d0 d5		bne $0db2			bne 	PerformGOTO
.0ddd	c8		iny				iny
.0dde	c8		iny				iny
.0ddf	4c 38 08	jmp $0838			jmp 	NextCommand
.0de2					Command_PSET:
.0de2	fa		plx				plx
.0de3	5a		phy				phy
.0de4	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; get the colour
.0de7	48		pha				pha
.0de8	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0dea	a0 02		ldy #$02			ldy 	#X16_r0
.0dec	20 6e 0e	jsr $0e6e			jsr 	GraphicsCopy2
.0def	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0df2	68		pla				pla 								; set pixel.
.0df3	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0df6	7a		ply				ply
.0df7	a2 ff		ldx #$ff			ldx 	#$FF
.0df9	4c 38 08	jmp $0838			jmp 	NextCommand
.0dfc					Command_LINE:
.0dfc	fa		plx				plx
.0dfd	5a		phy				phy
.0dfe	20 61 0e	jsr $0e61			jsr 	GraphicsColour
.0e01	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0e03	a0 02		ldy #$02			ldy 	#X16_r0
.0e05	20 6b 0e	jsr $0e6b			jsr 	GraphicsCopy4
.0e08	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0e0b	7a		ply				ply
.0e0c	a2 ff		ldx #$ff			ldx 	#$FF
.0e0e	4c 38 08	jmp $0838			jmp 	NextCommand
.0e11					Command_RECT:
.0e11	fa		plx				plx
.0e12	5a		phy				phy
.0e13	20 82 0e	jsr $0e82			jsr 	GraphicsRectCoords
.0e16	38		sec				sec
.0e17	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e1a	7a		ply				ply
.0e1b	a2 ff		ldx #$ff			ldx 	#$FF
.0e1d	4c 38 08	jmp $0838			jmp 	NextCommand
.0e20					Command_FRAME:
.0e20	fa		plx				plx
.0e21	5a		phy				phy
.0e22	20 82 0e	jsr $0e82			jsr 	GraphicsRectCoords
.0e25	18		clc				clc
.0e26	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e29	7a		ply				ply
.0e2a	a2 ff		ldx #$ff			ldx 	#$FF
.0e2c	4c 38 08	jmp $0838			jmp 	NextCommand
.0e2f					Command_CHAR:
.0e2f	fa		plx				plx
.0e30	5a		phy				phy
.0e31	ca		dex				dex  								; set the draw colour
.0e32	20 61 0e	jsr $0e61			jsr 	GraphicsColour
.0e35	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e37	a0 02		ldy #$02			ldy 	#X16_r0
.0e39	20 6e 0e	jsr $0e6e			jsr 	GraphicsCopy2
.0e3c	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e3e	85 2c		sta $2c				sta 	zTemp0
.0e40	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e42	85 2d		sta $2d				sta 	zTemp0+1
.0e44	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e46	85 2e		sta $2e				sta 	zTemp1
.0e48					_CCLoop:
.0e48	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e4a	f0 0f		beq $0e5b			beq 	_CCExit
.0e4c	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e4e	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e50	d0 02		bne $0e54			bne 	_CCNoCarry
.0e52	e6 2d		inc $2d				inc 	zTemp0+1
.0e54					_CCNoCarry:
.0e54	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e56	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e59	80 ed		bra $0e48			bra 	_CCLoop						; go round.
.0e5b					_CCExit:
.0e5b	7a		ply				ply
.0e5c	a2 ff		ldx #$ff			ldx 	#$FF
.0e5e	4c 38 08	jmp $0838			jmp 	NextCommand
.0e61					GraphicsColour:
.0e61	20 30 10	jsr $1030			jsr 	GetInteger8Bit
.0e64	aa		tax				tax
.0e65	a0 00		ldy #$00			ldy 	#0
.0e67	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e6a	60		rts				rts
.0e6b					GraphicsCopy4:
.0e6b	20 6e 0e	jsr $0e6e			jsr 	GraphicsCopy2
.0e6e					GraphicsCopy2:
.0e6e	20 71 0e	jsr $0e71			jsr 	GraphicsCopy1
.0e71					GraphicsCopy1:
.0e71	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.0e74	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e76	99 00 00	sta $0000,y			sta 	0,y
.0e79	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e7b	99 01 00	sta $0001,y			sta 	1,y
.0e7e	e8		inx				inx
.0e7f	c8		iny				iny
.0e80	c8		iny				iny
.0e81	60		rts				rts
.0e82					GraphicsRectCoords:
.0e82	20 61 0e	jsr $0e61			jsr 	GraphicsColour 				; set colour
.0e85	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e87	a0 02		ldy #$02			ldy 	#X16_r0
.0e89	20 6b 0e	jsr $0e6b			jsr 	GraphicsCopy4
.0e8c	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0e8e	20 9b 0e	jsr $0e9b			jsr 	_GRCSortSubtract
.0e91	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0e93	20 9b 0e	jsr $0e9b			jsr 	_GRCSortSubtract
.0e96	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0e98	74 09		stz $09,x			stz 	9,x
.0e9a	60		rts				rts
.0e9b					_GRCSortSubtract:
.0e9b	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0e9d	d5 00		cmp $00,x			cmp 	0,x
.0e9f	b5 05		lda $05,x			lda 	5,x
.0ea1	f5 01		sbc $01,x			sbc 	1,x
.0ea3	b0 08		bcs $0ead			bcs 	_GRCNoSwap 					; >= swap.
.0ea5	20 c1 0e	jsr $0ec1			jsr 	_GRCSwapByte 				; swap 0/2
.0ea8	e8		inx				inx
.0ea9	20 c1 0e	jsr $0ec1			jsr 	_GRCSwapByte 				; swap 1/3
.0eac	ca		dex				dex
.0ead					_GRCNoSwap:
.0ead	38		sec				sec 								; calculate width/height into 4,5
.0eae	b5 04		lda $04,x			lda 	4,x
.0eb0	f5 00		sbc $00,x			sbc 	0,x
.0eb2	95 04		sta $04,x			sta 	4,x
.0eb4	b5 05		lda $05,x			lda 	5,x
.0eb6	f5 01		sbc $01,x			sbc 	1,x
.0eb8	95 05		sta $05,x			sta 	5,x
.0eba	f6 04		inc $04,x			inc 	4,x 						; size does not include limits.
.0ebc	d0 02		bne $0ec0			bne 	_GRCNoCarry
.0ebe	f6 05		inc $05,x			inc 	5,x
.0ec0					_GRCNoCarry:
.0ec0	60		rts				rts
.0ec1					_GRCSwapByte:
.0ec1	b5 04		lda $04,x			lda 	4,x
.0ec3	48		pha				pha
.0ec4	b5 00		lda $00,x			lda 	0,x
.0ec6	95 04		sta $04,x			sta 	4,x
.0ec8	68		pla				pla
.0ec9	95 00		sta $00,x			sta 	0,x
.0ecb	60		rts				rts
.0ecc					Unary16Hex:
.0ecc	fa		plx				plx
.0ecd	20 36 10	jsr $1036			jsr 	GetInteger16Bit
.0ed0	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0ed2	20 3b 17	jsr $173b			jsr 	StringAllocTemp
.0ed5	a5 2d		lda $2d				lda 	zTemp0+1
.0ed7	f0 03		beq $0edc			beq 	_UHNoHigh
.0ed9	20 e4 0e	jsr $0ee4			jsr 	_UHWriteHex
.0edc					_UHNoHigh:
.0edc	a5 2c		lda $2c				lda 	zTemp0
.0ede	20 e4 0e	jsr $0ee4			jsr 	_UHWriteHex
.0ee1	4c 38 08	jmp $0838			jmp 	NextCommand
.0ee4					_UHWriteHex:
.0ee4	48		pha				pha
.0ee5	4a		lsr a				lsr 	a
.0ee6	4a		lsr a				lsr 	a
.0ee7	4a		lsr a				lsr 	a
.0ee8	4a		lsr a				lsr 	a
.0ee9	20 ed 0e	jsr $0eed			jsr 	_UHWriteNibl
.0eec	68		pla				pla
.0eed					_UHWriteNibl:
.0eed	29 0f		and #$0f			and 	#15
.0eef	c9 0a		cmp #$0a			cmp 	#10
.0ef1	90 02		bcc $0ef5			bcc 	_UHDigit
.0ef3	69 06		adc #$06			adc 	#6
.0ef5					_UHDigit:
.0ef5	69 30		adc #$30			adc 	#48
.0ef7	20 64 17	jsr $1764			jsr 	StringWriteChar
.0efa	60		rts				rts
.0efb					IndFloatRead:
.0efb	fa		plx				plx
.0efc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0efe	85 2c		sta $2c				sta 	zTemp0
.0f00	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f02	18		clc				clc
.0f03	6d 07 04	adc $0407			adc 	variableStartPage
.0f06	85 2d		sta $2d				sta 	zTemp0+1
.0f08	ca		dex				dex 								; throw the address
.0f09	20 04 15	jsr $1504			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0f0c	4c 38 08	jmp $0838			jmp 	NextCommand
.0f0f					IndInt16Read:
.0f0f	fa		plx				plx
.0f10	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f12	85 2c		sta $2c				sta 	zTemp0
.0f14	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f16	18		clc				clc
.0f17	6d 07 04	adc $0407			adc 	variableStartPage
.0f1a	85 2d		sta $2d				sta 	zTemp0+1
.0f1c	ca		dex				dex 								; throw the address
.0f1d	20 40 15	jsr $1540			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f20	4c 38 08	jmp $0838			jmp 	NextCommand
.0f23					IndStringRead:
.0f23	fa		plx				plx
.0f24	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f26	85 2c		sta $2c				sta 	zTemp0
.0f28	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f2a	18		clc				clc
.0f2b	6d 07 04	adc $0407			adc 	variableStartPage
.0f2e	85 2d		sta $2d				sta 	zTemp0+1
.0f30	ca		dex				dex 								; throw the address
.0f31	20 85 15	jsr $1585			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f34	4c 38 08	jmp $0838			jmp 	NextCommand
.0f37					IndFloatWrite:
.0f37	fa		plx				plx
.0f38	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f3a	85 2c		sta $2c				sta 	zTemp0
.0f3c	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f3e	18		clc				clc
.0f3f	6d 07 04	adc $0407			adc 	variableStartPage
.0f42	85 2d		sta $2d				sta 	zTemp0+1
.0f44	20 f9 1a	jsr $1af9			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f47	ca		dex				dex 								; throw the address as well.
.0f48	4c 38 08	jmp $0838			jmp 	NextCommand
.0f4b					IndInt16Write:
.0f4b	fa		plx				plx
.0f4c	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f4e	85 2c		sta $2c				sta 	zTemp0
.0f50	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f52	18		clc				clc
.0f53	6d 07 04	adc $0407			adc 	variableStartPage
.0f56	85 2d		sta $2d				sta 	zTemp0+1
.0f58	20 35 1b	jsr $1b35			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f5b	ca		dex				dex 								; throw the address as well.
.0f5c	4c 38 08	jmp $0838			jmp 	NextCommand
.0f5f					IndStringWrite:
.0f5f	fa		plx				plx
.0f60	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f62	85 2c		sta $2c				sta 	zTemp0
.0f64	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f66	18		clc				clc
.0f67	6d 07 04	adc $0407			adc 	variableStartPage
.0f6a	85 2d		sta $2d				sta 	zTemp0+1
.0f6c	20 74 1b	jsr $1b74			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f6f	ca		dex				dex 								; throw the address as well.
.0f70	4c 38 08	jmp $0838			jmp 	NextCommand
.0f73					CommandXInput:
.0f73	fa		plx				plx
.0f74	5a		phy				phy 								; save Y
.0f75	e8		inx				inx									; space on stack
.0f76					_INError:
.0f76	20 aa 0f	jsr $0faa			jsr 	InputStringToBuffer 		; input from keyboard
.0f79	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.0f7b	85 2c		sta $2c				sta 	0+zTemp0
.0f7d	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f7f	85 2d		sta $2d				sta 	1+zTemp0
.0f81	20 82 19	jsr $1982			jsr 	ValEvaluateZTemp0
.0f84	b0 f0		bcs $0f76			bcs 	_INError 					; failed, try again.
.0f86	7a		ply				ply 								; restore Y
.0f87	4c 38 08	jmp $0838			jmp 	NextCommand
.0f8a					CommandInputString:
.0f8a	fa		plx				plx
.0f8b	5a		phy				phy 								; save Y
.0f8c	20 aa 0f	jsr $0faa			jsr 	InputStringToBuffer 		; input from keyboard
.0f8f	e8		inx				inx 								; make space on stack
.0f90	20 94 26	jsr $2694			jsr 	FloatSetZero 				; store as string on stack
.0f93	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.0f95	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0f97	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0f99	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0f9b	a9 40		lda #$40			lda 	#NSSString
.0f9d	95 32		sta $32,x			sta 	NSStatus,x
.0f9f	7a		ply				ply 								; restore Y
.0fa0	4c 38 08	jmp $0838			jmp 	NextCommand
.0fa3					CommandInputReset:
.0fa3	fa		plx				plx
.0fa4	9c 0c 04	stz $040c			stz 	InputBuffer
.0fa7	4c 38 08	jmp $0838			jmp 	NextCommand
.0faa					InputStringToBuffer:
.0faa	a9 e4		lda #$e4			lda 	#((InputBumpNext) & $FF)
.0fac	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.0faf	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0fb1	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.0fb4	a9 c1		lda #$c1			lda 	#((InputLookNext) & $FF)
.0fb6	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.0fb9	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0fbb	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.0fbe	4c 61 14	jmp $1461			jmp 	GetStringToBuffer
.0fc1					InputLookNext:
.0fc1	da		phx				phx
.0fc2					_ILNRetry:
.0fc2	ad 0c 04	lda $040c			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fc5	d0 08		bne $0fcf			bne 	_ILNNotEmpty
.0fc7	20 e8 0f	jsr $0fe8			jsr 	InputGetNewLine 			; get a new line
.0fca	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset read position.
.0fcd	80 f3		bra $0fc2			bra 	_ILNRetry
.0fcf					_ILNNotEmpty:
.0fcf	ae 5d 04	ldx $045d			ldx 	InputBufferPos 				; get head available character
.0fd2	bd 0c 04	lda $040c,x			lda 	InputBuffer,x
.0fd5	d0 08		bne $0fdf			bne 	_ILNExit 					; if not EOS return it with CC.
.0fd7					_ILNNextLine:
.0fd7	9c 0c 04	stz $040c			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0fda	38		sec				sec 								; return CS,Zero
.0fdb	fa		plx				plx
.0fdc	a9 0d		lda #$0d			lda 	#13
.0fde	60		rts				rts
.0fdf					_ILNExit:
.0fdf	fa		plx				plx
.0fe0	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0fe2	18		clc				clc
.0fe3	60		rts				rts
.0fe4					InputBumpNext:
.0fe4	ee 5d 04	inc $045d			inc 	InputBufferPos
.0fe7	60		rts				rts
.0fe8					InputGetNewLine:
.0fe8	48		pha				pha
.0fe9	da		phx				phx
.0fea	5a		phy				phy
.0feb	a9 3f		lda #$3f			lda 	#"?"
.0fed	20 27 10	jsr $1027			jsr 	IGNLEchoIfScreen
.0ff0	a0 00		ldy #$00			ldy 	#0 							; line position.
.0ff2					_IGNLLoop:
.0ff2	20 8b 13	jsr $138b			jsr 	VectorGetCharacter 			; get a character
.0ff5	c9 00		cmp #$00			cmp 	#0
.0ff7	f0 f9		beq $0ff2			beq 	_IGNLLoop
.0ff9	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.0ffb	f0 11		beq $100e			beq 	_IGNBackspace
.0ffd	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.0fff	f0 17		beq $1018			beq 	_IGNExit
.1001	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.1003	f0 ed		beq $0ff2			beq 	_IGNLLoop
.1005	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1008	c8		iny				iny
.1009	20 27 10	jsr $1027			jsr 	IGNLEchoIfScreen
.100c	80 e4		bra $0ff2			bra 	_IGNLLoop
.100e					_IGNBackspace:
.100e	c0 00		cpy #$00			cpy 	#0
.1010	f0 e0		beq $0ff2			beq 	_IGNLLoop
.1012	20 27 10	jsr $1027			jsr 	IGNLEchoIfScreen
.1015	88		dey				dey
.1016	80 da		bra $0ff2			bra 	_IGNLLoop
.1018					_IGNExit:
.1018	20 27 10	jsr $1027			jsr 	IGNLEchoIfScreen
.101b	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.101d	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1020	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset position to start of input buffer.
.1023	7a		ply				ply
.1024	fa		plx				plx
.1025	68		pla				pla
.1026	60		rts				rts
.1027					IGNLEchoIfScreen:
.1027	ae 5f 04	ldx $045f			ldx 	currentChannel
.102a	d0 03		bne $102f			bne 	_IGNLEExit
.102c	20 82 13	jsr $1382			jsr 	VectorPrintCharacter
.102f					_IGNLEExit:
.102f	60		rts				rts
.040c					InputBuffer:
>040c							.fill 	81
.045d					InputBufferPos:
>045d							.fill 	1
.1030					GetInteger8Bit:
.1030	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.1033	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1035	60		rts				rts
.1036					GetInteger16Bit:
.1036	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.1039	34 32		bit $32,x			bit 	NSStatus,x
.103b	30 09		bmi $1046			bmi 	Negate16Bit
.103d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.103f	85 2c		sta $2c				sta 	zTemp0
.1041	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1043	85 2d		sta $2d				sta 	zTemp0+1
.1045	60		rts				rts
.1046					Negate16Bit:
.1046	38		sec				sec
.1047	a9 00		lda #$00			lda 	#0
.1049	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.104b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.104d	85 2c		sta $2c				sta 	zTemp0
.104f	a9 00		lda #$00			lda 	#0
.1051	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1053	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1055	85 2d		sta $2d				sta 	zTemp0+1
.1057	60		rts				rts
.1058					UnaryJoy:
.1058	fa		plx				plx
.1059	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; port #
.105c	48		pha				pha 								; zero the result.
.105d	20 94 26	jsr $2694			jsr 	FloatSetZero
.1060	68		pla				pla
.1061	5a		phy				phy
.1062	da		phx				phx
.1063	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1066	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1068	d0 10		bne $107a			bne 	_UJNoHardware
.106a	a8		tay				tay 								; move XA -> AY
.106b	8a		txa				txa
.106c	fa		plx				plx 								; we can update it now.
.106d	49 ff		eor #$ff			eor 	#$FF
.106f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1071	98		tya				tya
.1072	49 ff		eor #$ff			eor 	#$FF
.1074	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1076	7a		ply				ply 								; restore Y
.1077	4c 38 08	jmp $0838			jmp 	NextCommand
.107a					_UJNoHardware:
.107a	fa		plx				plx
.107b	7a		ply				ply
.107c	a9 01		lda #$01			lda 	#1 							; set result to -1
.107e	20 96 26	jsr $2696			jsr 	FloatSetByte
.1081	20 56 26	jsr $2656			jsr 	FloatNegate
.1084	4c 38 08	jmp $0838			jmp 	NextCommand
.1087					UnaryLen:
.1087	fa		plx				plx
.1088	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.108a	85 2c		sta $2c				sta 	zTemp0
.108c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.108e	85 2d		sta $2d				sta 	zTemp0+1
.1090	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.1092	20 96 26	jsr $2696			jsr 	FloatSetByte
.1095	4c 38 08	jmp $0838			jmp 	NextCommand
.1098					LinkFloatAdd:
.1098	fa		plx				plx
.1099	5a		phy			phy
.109a	20 b8 20	jsr $20b8		jsr	FloatAdd
.109d	7a		ply			ply
.109e	4c 38 08	jmp $0838			jmp 	NextCommand
.10a1					LinkFloatSubtract:
.10a1	fa		plx				plx
.10a2	5a		phy			phy
.10a3	20 b2 20	jsr $20b2		jsr	FloatSubtract
.10a6	7a		ply			ply
.10a7	4c 38 08	jmp $0838			jmp 	NextCommand
.10aa					LinkFloatMultiply:
.10aa	fa		plx				plx
.10ab	5a		phy			phy
.10ac	20 54 23	jsr $2354		jsr	FloatMultiply
.10af	7a		ply			ply
.10b0	4c 38 08	jmp $0838			jmp 	NextCommand
.10b3					LinkFloatDivide:
.10b3	fa		plx				plx
.10b4	5a		phy			phy
.10b5	20 dd 21	jsr $21dd		jsr	FloatDivide
.10b8	b0 5c		bcs $1116		bcs	DivZeroError
.10ba	7a		ply			ply
.10bb	4c 38 08	jmp $0838			jmp 	NextCommand
.10be					LinkFloatPower:
.10be	fa		plx				plx
.10bf	5a		phy			phy
.10c0	20 5d 29	jsr $295d		jsr	FloatPower
.10c3	b0 4e		bcs $1113		bcs	MapRangeError
.10c5	7a		ply			ply
.10c6	4c 38 08	jmp $0838			jmp 	NextCommand
.10c9					LinkCompareGreater:
.10c9	fa		plx				plx
.10ca	5a		phy			phy
.10cb	20 61 21	jsr $2161		jsr	CompareGreater
.10ce	7a		ply			ply
.10cf	4c 38 08	jmp $0838			jmp 	NextCommand
.10d2					LinkCompareEqual:
.10d2	fa		plx				plx
.10d3	5a		phy			phy
.10d4	20 43 21	jsr $2143		jsr	CompareEqual
.10d7	7a		ply			ply
.10d8	4c 38 08	jmp $0838			jmp 	NextCommand
.10db					LinkCompareLess:
.10db	fa		plx				plx
.10dc	5a		phy			phy
.10dd	20 59 21	jsr $2159		jsr	CompareLess
.10e0	7a		ply			ply
.10e1	4c 38 08	jmp $0838			jmp 	NextCommand
.10e4					LinkCompareGreaterEqual:
.10e4	fa		plx				plx
.10e5	5a		phy			phy
.10e6	20 71 21	jsr $2171		jsr	CompareGreaterEqual
.10e9	7a		ply			ply
.10ea	4c 38 08	jmp $0838			jmp 	NextCommand
.10ed					LinkCompareNotEqual:
.10ed	fa		plx				plx
.10ee	5a		phy			phy
.10ef	20 53 21	jsr $2153		jsr	CompareNotEqual
.10f2	7a		ply			ply
.10f3	4c 38 08	jmp $0838			jmp 	NextCommand
.10f6					LinkCompareLessEqual:
.10f6	fa		plx				plx
.10f7	5a		phy			phy
.10f8	20 69 21	jsr $2169		jsr	CompareLessEqual
.10fb	7a		ply			ply
.10fc	4c 38 08	jmp $0838			jmp 	NextCommand
.10ff					LinkFloatIntegerPartDown:
.10ff	fa		plx				plx
.1100	5a		phy			phy
.1101	20 f3 22	jsr $22f3		jsr	FloatIntegerPartDown
.1104	7a		ply			ply
.1105	4c 38 08	jmp $0838			jmp 	NextCommand
.1108					LinkFloatSquareRoot:
.1108	fa		plx				plx
.1109	5a		phy			phy
.110a	20 df 29	jsr $29df		jsr	FloatSquareRoot
.110d	b0 04		bcs $1113		bcs	MapRangeError
.110f	7a		ply			ply
.1110	4c 38 08	jmp $0838			jmp 	NextCommand
.1113					MapRangeError:
.1113	4c 1f 1f	jmp $1f1f		jmp	ErrorV_range
.1116					DivZeroError:
.1116	4c a8 1f	jmp $1fa8		jmp	ErrorV_divzero
.1119					LinkFloatLogarithm:
.1119	fa		plx				plx
.111a	5a		phy			phy
.111b	20 e9 28	jsr $28e9		jsr	FloatLogarithm
.111e	b0 f3		bcs $1113		bcs	MapRangeError
.1120	7a		ply			ply
.1121	4c 38 08	jmp $0838			jmp 	NextCommand
.1124					LinkFloatExponent:
.1124	fa		plx				plx
.1125	5a		phy			phy
.1126	20 e6 27	jsr $27e6		jsr	FloatExponent
.1129	7a		ply			ply
.112a	4c 38 08	jmp $0838			jmp 	NextCommand
.112d					LinkFloatCosine:
.112d	fa		plx				plx
.112e	5a		phy			phy
.112f	20 da 27	jsr $27da		jsr	FloatCosine
.1132	7a		ply			ply
.1133	4c 38 08	jmp $0838			jmp 	NextCommand
.1136					LinkFloatSine:
.1136	fa		plx				plx
.1137	5a		phy			phy
.1138	20 7a 29	jsr $297a		jsr	FloatSine
.113b	7a		ply			ply
.113c	4c 38 08	jmp $0838			jmp 	NextCommand
.113f					LinkFloatTangent:
.113f	fa		plx				plx
.1140	5a		phy			phy
.1141	20 eb 29	jsr $29eb		jsr	FloatTangent
.1144	7a		ply			ply
.1145	4c 38 08	jmp $0838			jmp 	NextCommand
.1148					LinkFloatArcTan:
.1148	fa		plx				plx
.1149	5a		phy			phy
.114a	20 bf 26	jsr $26bf		jsr	FloatArcTan
.114d	b0 c4		bcs $1113		bcs	MapRangeError
.114f	7a		ply			ply
.1150	4c 38 08	jmp $0838			jmp 	NextCommand
.1153					LinkFloatCompare:
.1153	fa		plx				plx
.1154	5a		phy			phy
.1155	20 79 21	jsr $2179		jsr	FloatCompare
.1158	7a		ply			ply
.1159	4c 38 08	jmp $0838			jmp 	NextCommand
.115c					LinkDivideInt32:
.115c	fa		plx				plx
.115d	5a		phy			phy
.115e	20 07 22	jsr $2207		jsr	DivideInt32
.1161	b0 b0		bcs $1113		bcs	MapRangeError
.1163	7a		ply			ply
.1164	4c 38 08	jmp $0838			jmp 	NextCommand
.1167					StackSaveCurrentPosition:
.1167	20 b4 08	jsr $08b4			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.116a	5a		phy				phy
.116b	a0 02		ldy #$02			ldy 	#2
.116d	a5 28		lda $28				lda 	codePtr
.116f	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1171	c8		iny				iny
.1172	a5 29		lda $29				lda 	codePtr+1
.1174	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1176	7a		ply				ply
.1177	60		rts				rts
.1178					StackLoadCurrentPosition:
.1178	a0 02		ldy #$02			ldy 	#2
.117a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.117c	85 28		sta $28				sta 	codePtr
.117e	c8		iny				iny
.117f	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1181	85 29		sta $29				sta 	codePtr+1
.1183	a0 00		ldy #$00			ldy 	#0
.1185	60		rts				rts
.1186					XCommandMouse:
.1186	fa		plx				plx
.1187	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; mouse control.
.118a	ca		dex				dex
.118b	da		phx				phx
.118c	5a		phy				phy
.118d	48		pha				pha
.118e	38		sec				sec 								; get screen resolution
.118f	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1192	68		pla				pla
.1193	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.1196	7a		ply				ply
.1197	fa		plx				plx
.1198	4c 38 08	jmp $0838			jmp 	NextCommand
.119b					XUnaryMB:
.119b	fa		plx				plx
.119c	20 e3 11	jsr $11e3			jsr 	XUnaryMouseCommon
.119f	a5 30		lda $30				lda 	zTemp2
.11a1	e8		inx				inx
.11a2	20 96 26	jsr $2696			jsr 	FloatSetByte
.11a5	4c 38 08	jmp $0838			jmp 	NextCommand
.11a8					XUnaryMX:
.11a8	fa		plx				plx
.11a9	20 e3 11	jsr $11e3			jsr 	XUnaryMouseCommon
.11ac	a5 2c		lda $2c				lda 	zTemp0
.11ae	e8		inx				inx
.11af	20 96 26	jsr $2696			jsr 	FloatSetByte
.11b2	a5 2d		lda $2d				lda 	zTemp0+1
.11b4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11b6	4c 38 08	jmp $0838			jmp 	NextCommand
.11b9					XUnaryMY:
.11b9	fa		plx				plx
.11ba	20 e3 11	jsr $11e3			jsr 	XUnaryMouseCommon
.11bd	a5 2e		lda $2e				lda 	zTemp1
.11bf	e8		inx				inx
.11c0	20 96 26	jsr $2696			jsr 	FloatSetByte
.11c3	a5 2f		lda $2f				lda 	zTemp1+1
.11c5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11c7	4c 38 08	jmp $0838			jmp 	NextCommand
.11ca					XUnaryMWheel:
.11ca	fa		plx				plx
.11cb	20 e3 11	jsr $11e3			jsr 	XUnaryMouseCommon 			; read mouse status
.11ce	e8		inx				inx
.11cf	a5 31		lda $31				lda 	zTemp2+1 					; set mantissa to |wheel|
.11d1	48		pha				pha
.11d2	10 03		bpl $11d7			bpl 	_XUMNotNegative
.11d4	49 ff		eor #$ff			eor 	#$FF
.11d6	1a		inc a				inc 	a
.11d7					_XUMNotNegative:
.11d7	20 96 26	jsr $2696			jsr 	FloatSetByte
.11da	68		pla				pla  								; negate if it was -ve
.11db	10 03		bpl $11e0			bpl 	_XUMNotNegative2
.11dd	20 56 26	jsr $2656			jsr 	FloatNegate
.11e0					_XUMNotNegative2:
.11e0	4c 38 08	jmp $0838			jmp 	NextCommand
.11e3					XUnaryMouseCommon:
.11e3	da		phx				phx
.11e4	5a		phy				phy
.11e5	a2 2c		ldx #$2c			ldx 	#zTemp0
.11e7	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.11ea	85 30		sta $30				sta 	zTemp2
.11ec	86 31		stx $31				stx 	zTemp2+1
.11ee	7a		ply				ply
.11ef	fa		plx				plx
.11f0	60		rts				rts
.11f1					NegateTOS:
.11f1	fa		plx				plx
.11f2	20 56 26	jsr $2656			jsr 	FloatNegate
.11f5	4c 38 08	jmp $0838			jmp 	NextCommand
.11f8					CommandNewLine:
.11f8	fa		plx				plx
.11f9	9c 6a 05	stz $056a			stz 	stringInitialised
.11fc	a2 ff		ldx #$ff			ldx 	#$FF
.11fe	4c 38 08	jmp $0838			jmp 	NextCommand
.1201					CommandXNext:
.1201	fa		plx				plx
.1202					_CNRetry:
.1202	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.1204	20 46 0d	jsr $0d46			jsr 	StackFindFrame
.1207	20 b4 08	jsr $08b4			jsr 	FixUpY 						; so we can use Y
.120a	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.120c	35 4a		and $4a,x			and 	NSMantissa1,x
.120e	c9 ff		cmp #$ff			cmp 	#$FF
.1210	f0 16		beq $1228			beq 	_CNNoIndexVariable
.1212	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1214	a0 05		ldy #$05			ldy 	#5
.1216	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.1218	d0 07		bne $1221			bne 	_CNNIndexFail
.121a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.121c	c8		iny				iny
.121d	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.121f	f0 07		beq $1228			beq 	_CNNoIndexVariable
.1221					_CNNIndexFail:
.1221	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.1223	20 38 0d	jsr $0d38			jsr 	StackCloseFrame 			; close this frame
.1226	80 da		bra $1202			bra 	_CNRetry
.1228					_CNNoIndexVariable:
.1228	ca		dex				dex
.1229	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.122b	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.122d	29 40		and #$40			and 	#$40	 					; bit 6
.122f	d0 55		bne $1286			bne 	_CNOptimisedNext
.1231	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1233	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1235	48		pha				pha
.1236	85 2c		sta $2c				sta 	zTemp0
.1238	c8		iny				iny
.1239	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.123b	18		clc				clc
.123c	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.123f	48		pha				pha
.1240	85 2d		sta $2d				sta 	zTemp0+1
.1242	20 04 15	jsr $1504			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.1245	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.1247	e8		inx				inx
.1248	20 c9 12	jsr $12c9			jsr 	CopyOffsetYToTOS
.124b	20 b8 20	jsr $20b8			jsr 	FloatAdd
.124e	68		pla				pla 								; restore address
.124f	85 2d		sta $2d				sta 	zTemp0+1
.1251	68		pla				pla
.1252	85 2c		sta $2c				sta 	zTemp0
.1254	20 f9 1a	jsr $1af9			jsr 	WriteFloatZTemp0Sub			; write float.
.1257	e8		inx				inx  								; recover written
.1258	e8		inx				inx 								; load offset
.1259	a0 0d		ldy #$0d			ldy 	#13
.125b	20 c9 12	jsr $12c9			jsr 	CopyOffsetYToTOS
.125e	20 79 21	jsr $2179			jsr 	FloatCompare 				; and compare the floats.
.1261	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1262	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.1264	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1266	30 08		bmi $1270			bmi 	_CNDownStep
.1268	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.126a	c9 01		cmp #$01			cmp 	#1 							; gone higher
.126c	f0 10		beq $127e			beq 	_CNExitFor 					; if so exit the loop
.126e	80 06		bra $1276			bra 	_CNLoopBack
.1270					_CNDownStep:
.1270	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1272	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.1274	f0 08		beq $127e			beq 	_CNExitFor
.1276					_CNLoopBack:
.1276	20 78 11	jsr $1178			jsr 	StackLoadCurrentPosition 	; loop back
.1279	a0 00		ldy #$00			ldy 	#0
.127b	4c 38 08	jmp $0838			jmp 	NextCommand
.127e					_CNExitFor:
.127e	20 38 0d	jsr $0d38			jsr 	StackCloseFrame 			; remove the frame and exit
.1281	a0 00		ldy #$00			ldy 	#0
.1283	4c 38 08	jmp $0838			jmp 	NextCommand
.1286					_CNOptimisedNext:
.1286	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1288	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.128a	85 2c		sta $2c				sta 	zTemp0
.128c	c8		iny				iny
.128d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.128f	18		clc				clc
.1290	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1293	85 2d		sta $2d				sta 	zTemp0+1
.1295	a0 07		ldy #$07			ldy 	#7 							; STEP value
.1297	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1299	a0 ff		ldy #$ff			ldy 	#$FF
.129b	18		clc				clc
.129c					_CNOIncrement:
.129c	c8		iny				iny
.129d	71 2c		adc ($2c),y			adc 	(zTemp0),y
.129f	91 2c		sta ($2c),y			sta 	(zTemp0),y
.12a1	f0 f9		beq $129c			beq 	_CNOIncrement
.12a3	18		clc				clc
.12a4	a5 24		lda $24				lda 	runtimeStackPtr
.12a6	69 0d		adc #$0d			adc 	#13
.12a8	85 2e		sta $2e				sta 	zTemp1
.12aa	a5 25		lda $25				lda 	runtimeStackPtr+1
.12ac	69 00		adc #$00			adc 	#0
.12ae	85 2f		sta $2f				sta 	zTemp1+1
.12b0	a0 00		ldy #$00			ldy 	#0
.12b2	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.12b4	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.12b6	c8		iny				iny
.12b7	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.12b9	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12bb	c8		iny				iny
.12bc	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.12be	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12c0	c8		iny				iny
.12c1	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.12c3	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12c5	90 b7		bcc $127e			bcc	 	_CNExitFor
.12c7	80 ad		bra $1276			bra 	_CNLoopBack
.12c9					CopyOffsetYToTOS:
.12c9	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12cb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.12cd	c8		iny				iny
.12ce	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12d2	c8		iny				iny
.12d3	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d5	95 56		sta $56,x			sta 	NSMantissa2,x
.12d7	c8		iny				iny
.12d8	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12da	95 62		sta $62,x			sta 	NSMantissa3,x
.12dc	c8		iny				iny
.12dd	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12df	95 6e		sta $6e,x			sta 	NSExponent,x
.12e1	c8		iny				iny
.12e2	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12e4	95 32		sta $32,x			sta 	NSStatus,x
.12e6	60		rts				rts
.12e7	4c 38 08	jmp $0838			jmp 	NextCommand
.12ea					NotTOS:
.12ea	fa		plx				plx
.12eb	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.12ee	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.12f0	74 62		stz $62,x			stz 	NSMantissa3,x
.12f2	20 56 26	jsr $2656			jsr 	FloatNegate		 			; negate
.12f5	e8		inx				inx 								; and subtract 1.
.12f6	a9 01		lda #$01			lda 	#1
.12f8	20 96 26	jsr $2696			jsr 	FloatSetByte
.12fb	20 b2 20	jsr $20b2			jsr 	FloatSubtract
.12fe					_NotTOSSkip:
.12fe	4c 38 08	jmp $0838			jmp 	NextCommand
.1301					CommandXOn:
.1301	fa		plx				plx
.1302	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.1305	8d 5e 04	sta $045e			sta 	onCount 					; save it.
.1308	20 b4 08	jsr $08b4			jsr 	FixUpY 						; Y = 0
.130b					_CONFind:
.130b	ce 5e 04	dec $045e			dec 	onCount 					; reached zero, do this one
.130e	f0 0b		beq $131b			beq 	_CONFound
.1310	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1311	c8		iny				iny
.1312	c8		iny				iny
.1313	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.1315	c8		iny				iny
.1316	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.1318	f0 f1		beq $130b			beq 	_CONFind
.131a	88		dey				dey 								; point to character after last GOTO/GOSUB
.131b					_CONFound:
.131b	4c 38 08	jmp $0838			jmp 	NextCommand
.131e					CommandMoreOn:
.131e	fa		plx				plx
.131f	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1320	c8		iny				iny
.1321	c8		iny				iny
.1322	4c 38 08	jmp $0838			jmp 	NextCommand
.045e					onCount:
>045e							.fill 	1
.1325					UnaryPeek:
.1325	fa		plx				plx
.1326	20 36 10	jsr $1036			jsr 	GetInteger16Bit
.1329	da		phx				phx
.132a	5a		phy				phy
.132b	a6 2c		ldx $2c				ldx 	zTemp0
.132d	a4 2d		ldy $2d				ldy 	zTemp0+1
.132f	20 93 1c	jsr $1c93			jsr 	XPeekMemory
.1332	7a		ply				ply
.1333	fa		plx				plx
.1334	20 96 26	jsr $2696			jsr 	FloatSetByte
.1337	4c 38 08	jmp $0838			jmp 	NextCommand
.133a					UnaryPI:
.133a	fa		plx				plx
.133b	a9 19		lda #$19			lda 	#Const_pi-Const_base
.133d	20 c4 28	jsr $28c4			jsr 	LoadConstant
.1340	e8		inx				inx
.1341	4c 38 08	jmp $0838			jmp 	NextCommand
.1344					CommandPOKE:
.1344	fa		plx				plx
.1345	da		phx				phx 								; save XY
.1346	5a		phy				phy
.1347	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.134a	48		pha				pha
.134b	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.134d	a8		tay				tay
.134e	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1350	aa		tax				tax
.1351	68		pla				pla
.1352	20 7f 1c	jsr $1c7f			jsr 	XPokeMemory
.1355	7a		ply				ply 								; restore YX and drop 2
.1356	fa		plx				plx
.1357	ca		dex				dex
.1358	ca		dex				dex
.1359	4c 38 08	jmp $0838			jmp 	NextCommand
.135c					UnaryPos:
.135c	fa		plx				plx
.135d	20 12 1c	jsr $1c12			jsr 	XGetHPos
.1360	20 96 26	jsr $2696			jsr 	FloatSetByte
.1363	4c 38 08	jmp $0838			jmp 	NextCommand
.1366					GetChannel:
.1366	fa		plx				plx
.1367	ad 5f 04	lda $045f			lda 	currentChannel
.136a	e8		inx				inx
.136b	20 96 26	jsr $2696			jsr 	FloatSetByte
.136e	4c 38 08	jmp $0838			jmp 	NextCommand
.1371					SetChannel:
.1371	fa		plx				plx
.1372	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.1375	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1377	8d 5f 04	sta $045f			sta 	currentChannel
.137a	ca		dex				dex
.137b	4c 38 08	jmp $0838			jmp 	NextCommand
.137e					SetDefaultChannel:
.137e	9c 5f 04	stz $045f			stz 	currentChannel
.1381	60		rts				rts
.1382					VectorPrintCharacter:
.1382	da		phx				phx
.1383	ae 5f 04	ldx $045f			ldx 	currentChannel
.1386	20 bd 1c	jsr $1cbd			jsr 	XPrintCharacterToChannel
.1389	fa		plx				plx
.138a	60		rts				rts
.138b					VectorGetCharacter:
.138b	da		phx				phx
.138c	ae 5f 04	ldx $045f			ldx 	currentChannel
.138f	20 f6 1b	jsr $1bf6			jsr 	XGetCharacterFromChannel
.1392	fa		plx				plx
.1393	60		rts				rts
.045f					currentChannel:
>045f							.fill 	1
.1394					PrintNumber:
.1394	fa		plx				plx
.1395	a9 07		lda #$07			lda 	#7
.1397	20 7c 25	jsr $257c			jsr 	FloatToString 				; to number in decimal buffer
.139a	ca		dex				dex 								; drop
.139b	da		phx				phx
.139c	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.139e					_PNLoop:
.139e	bd 98 05	lda $0598,x			lda 	decimalBuffer,x
.13a1	20 82 13	jsr $1382			jsr 	VectorPrintCharacter
.13a4	e8		inx				inx
.13a5	bd 98 05	lda $0598,x			lda	 	decimalBuffer,x
.13a8	d0 f4		bne $139e			bne 	_PNLoop
.13aa	a9 20		lda #$20			lda 	#32 						; trailing space
.13ac	20 82 13	jsr $1382			jsr 	VectorPrintCharacter
.13af	fa		plx				plx
.13b0	4c 38 08	jmp $0838			jmp 	NextCommand
.13b3					PrintString:
.13b3	fa		plx				plx
.13b4	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.13b6	85 2c		sta $2c				sta 	zTemp0
.13b8	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.13ba	85 2d		sta $2d				sta 	zTemp0+1
.13bc	ca		dex				dex 								; drop
.13bd	da		phx				phx
.13be	5a		phy				phy
.13bf	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.13c1	aa		tax				tax
.13c2	a0 01		ldy #$01			ldy 	#1 							; Y = position
.13c4					_PSLoop:
.13c4	e0 00		cpx #$00			cpx 	#0 							; complete ?
.13c6	f0 09		beq $13d1			beq 	_PSExit
.13c8	ca		dex				dex 								; dec count
.13c9	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.13cb	20 82 13	jsr $1382			jsr 	VectorPrintCharacter
.13ce	c8		iny				iny
.13cf	80 f3		bra $13c4			bra 	_PSLoop
.13d1					_PSExit:
.13d1	7a		ply				ply
.13d2	fa		plx				plx
.13d3	4c 38 08	jmp $0838			jmp 	NextCommand
.13d6					CommandPushN:
.13d6	fa		plx				plx
.13d7	e8		inx				inx 								; next slot on stack
.13d8	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.13da	95 6e		sta $6e,x			sta 	NSExponent,x
.13dc	c8		iny				iny
.13dd	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.13df	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13e1	c8		iny				iny
.13e2	b1 28		lda ($28),y			lda 	(codePtr),y
.13e4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13e6	c8		iny				iny
.13e7	b1 28		lda ($28),y			lda 	(codePtr),y
.13e9	95 56		sta $56,x			sta 	NSMantissa2,x
.13eb	c8		iny				iny
.13ec	b1 28		lda ($28),y			lda 	(codePtr),y
.13ee	48		pha				pha
.13ef	29 7f		and #$7f			and 	#$7F
.13f1	95 62		sta $62,x			sta 	NSMantissa3,x
.13f3	68		pla				pla 								; sign in mantissa3:7
.13f4	29 80		and #$80			and 	#$80
.13f6	95 32		sta $32,x			sta 	NSStatus,x
.13f8	c8		iny				iny
.13f9	4c 38 08	jmp $0838			jmp 	NextCommand
.13fc					CommandPushS:
.13fc	fa		plx				plx
.13fd	e8		inx				inx 								; next slot on stack
.13fe	18		clc				clc
.13ff	98		tya				tya
.1400	65 28		adc $28				adc 	codePtr 					; the string is inline
.1402	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1404	a5 29		lda $29				lda 	codePtr+1
.1406	69 00		adc #$00			adc 	#0
.1408	95 4a		sta $4a,x			sta 	NSMantissa1,x
.140a	74 56		stz $56,x			stz 	NSMantissa2,x
.140c	74 62		stz $62,x			stz 	NSMantissa3,x
.140e	a9 40		lda #$40			lda 	#NSSString
.1410	95 32		sta $32,x			sta 	NSStatus,x
.1412	98		tya				tya 								; string length +1 added to Y
.1413	38		sec				sec
.1414	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.1416	a8		tay				tay
.1417	4c 38 08	jmp $0838			jmp 	NextCommand
.141a					CommandXRead:
.141a	fa		plx				plx
.141b	5a		phy				phy 								; save Y
.141c	20 4d 14	jsr $144d			jsr 	ReadStringToBuffer 			; read element into buffer
.141f	e8		inx				inx									; space on stack
.1420	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.1422	85 2c		sta $2c				sta 	0+zTemp0
.1424	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.1426	85 2d		sta $2d				sta 	1+zTemp0
.1428	20 82 19	jsr $1982			jsr 	ValEvaluateZTemp0
.142b	b0 04		bcs $1431			bcs 	_CRError 					; failed
.142d	7a		ply				ply 								; restore Y
.142e	4c 38 08	jmp $0838			jmp 	NextCommand
.1431					_CRError:
.1431	4c 2f 1f	jmp $1f2f		jmp	ErrorV_value
.1434					CommandReadString:
.1434	fa		plx				plx
.1435	5a		phy				phy 								; save Y
.1436	20 4d 14	jsr $144d			jsr 	ReadStringToBuffer 			; read text
.1439	e8		inx				inx 								; make space on stack
.143a	20 94 26	jsr $2694			jsr 	FloatSetZero 				; store as string on stack
.143d	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.143f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1441	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.1443	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1445	a9 40		lda #$40			lda 	#NSSString
.1447	95 32		sta $32,x			sta 	NSStatus,x
.1449	7a		ply				ply 								; restore Y
.144a	4c 38 08	jmp $0838			jmp 	NextCommand
.144d					ReadStringToBuffer:
.144d	a9 e0		lda #$e0			lda 	#((ReadBumpNext) & $FF)
.144f	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.1452	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.1454	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.1457	a9 b3		lda #$b3			lda 	#((ReadLookNext) & $FF)
.1459	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.145c	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.145e	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.1461					GetStringToBuffer:
.1461	20 b0 14	jsr $14b0			jsr		GetLookNext 				; skip all leading spaces.
.1464	f0 44		beq $14aa			beq 	_RBError 					; end of data
.1466	b0 f9		bcs $1461			bcs 	GetStringToBuffer 			; switched to new data line.
.1468	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.146a	b0 05		bcs $1471			bcs 	_RBNoSpace
.146c	20 ad 14	jsr $14ad			jsr 	GetBumpNext 				; consume space and loop round.
.146f	80 f0		bra $1461			bra 	GetStringToBuffer
.1471					_RBNoSpace:
.1471	9c 61 04	stz $0461			stz 	ReadBufferSize 				; empty the buffer.
.1474	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.1476	d0 08		bne $1480			bne 	_RBCommaSep
.1478	8d 60 04	sta $0460			sta 	ReadSep 					; use as a seperator
.147b	20 ad 14	jsr $14ad			jsr 	GetBumpNext 				; consume the '"'
.147e	80 05		bra $1485			bra 	_RBGetText
.1480					_RBCommaSep:
.1480	a9 2c		lda #$2c			lda 	#","						; get till comma
.1482	8d 60 04	sta $0460			sta 	ReadSep
.1485					_RBGetText:
.1485	20 b0 14	jsr $14b0			jsr 	GetLookNext 				; what follows
.1488	b0 18		bcs $14a2			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.148a	20 ad 14	jsr $14ad			jsr 	GetBumpNext 				; consume it whatever
.148d	cd 60 04	cmp $0460			cmp 	ReadSep 					; if found the seperator.
.1490	f0 10		beq $14a2			beq 	_RBEndGet 					; exit after consumption
.1492	da		phx				phx
.1493	ae 61 04	ldx $0461			ldx 	ReadBufferSize 				; copy into buffer.
.1496	ee 61 04	inc $0461			inc 	ReadBufferSize
.1499	9d 62 04	sta $0462,x			sta 	ReadBuffer,x
.149c	9e 63 04	stz $0463,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.149f	fa		plx				plx
.14a0	80 e3		bra $1485			bra 	_RBGetText
.14a2					_RBEndGet:
.14a2	c9 22		cmp #$22			cmp 	#'"'
.14a4	d0 03		bne $14a9			bne 	_RBNotQuote
.14a6	20 ad 14	jsr $14ad			jsr 	GetBumpNext
.14a9					_RBNotQuote:
.14a9	60		rts				rts
.14aa					_RBError:
.14aa	4c e4 1f	jmp $1fe4		jmp	ErrorV_data
.14ad					GetBumpNext:
.14ad	6c 61 05	jmp ($0561)			jmp 	(ReadBumpNextVec)
.14b0					GetLookNext:
.14b0	6c 63 05	jmp ($0563)			jmp 	(ReadLookNextVec)
.14b3					ReadLookNext:
.14b3	ad 65 05	lda $0565			lda 	dataRemaining 				; any data remaining
.14b6	f0 04		beq $14bc			beq 	_RLNFindData
.14b8	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.14ba	18		clc				clc
.14bb	60		rts				rts
.14bc					_RLNFindData:
.14bc	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.14be	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.14c0	f0 1a		beq $14dc			beq 	_RLNNoData
.14c2	c9 d0		cmp #$d0			cmp 	#PCD_CMD_DATA 				; Found DATA
.14c4	f0 05		beq $14cb			beq 	_RLNHaveData
.14c6					_RLNNext:
.14c6	20 62 20	jsr $2062			jsr 	MoveObjectForward			; else scan forward.
.14c9	80 f1		bra $14bc			bra 	_RLNFindData
.14cb					_RLNHaveData:
.14cb	a0 01		ldy #$01			ldy 	#1 							; get length
.14cd	b1 2a		lda ($2a),y			lda 	(objPtr),y
.14cf	f0 f5		beq $14c6			beq 	_RLNNext 					; skip if DATA alone
.14d1	20 e0 14	jsr $14e0			jsr 	ReadBumpNext 				; advance by two
.14d4	20 e0 14	jsr $14e0			jsr 	ReadBumpNext
.14d7	8d 65 05	sta $0565			sta 	dataRemaining 				; set data left count.
.14da	38		sec				sec
.14db	60		rts				rts
.14dc					_RLNNoData:
.14dc	a9 00		lda #$00			lda 	#0
.14de	38		sec				sec
.14df	60		rts				rts
.14e0					ReadBumpNext:
.14e0	e6 2a		inc $2a				inc 	objPtr
.14e2	d0 02		bne $14e6			bne 	_RBNSkip
.14e4	e6 2b		inc $2b				inc 	objPtr+1
.14e6					_RBNSkip:
.14e6	ce 65 05	dec $0565			dec 	dataRemaining
.14e9	60		rts				rts
.0460					ReadSep:
>0460							.fill 	1
.0461					ReadBufferSize:
>0461							.fill 	1
.0462					ReadBuffer:
>0462							.fill 	255
.0561					ReadBumpNextVec:
>0561							.fill 	2
.0563					ReadLookNextVec:
>0563							.fill 	2
.14ea					ReadFloatCommand:
.14ea	fa		plx				plx
.14eb	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14ed	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14ef	88		dey				dey 								; get the upper 3 bits
.14f0	b1 28		lda ($28),y			lda 	(codePtr),y
.14f2	29 07		and #$07			and 	#7
.14f4	c8		iny				iny
.14f5	c8		iny				iny
.14f6	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14f8	2a		rol a				rol 	a 							; carry will be clear.
.14f9	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14fc	85 2d		sta $2d				sta 	zTemp0+1
.14fe	20 04 15	jsr $1504			jsr 	ReadFloatZTemp0Sub
.1501	4c 38 08	jmp $0838			jmp 	NextCommand
.1504					ReadFloatZTemp0Sub:
.1504	5a		phy				phy 								; start write
.1505	a0 01		ldy #$01			ldy 	#1
.1507	e8		inx				inx
.1508	b2 2c		lda ($2c)			lda 	(zTemp0)
.150a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.150c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.150e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1510	c8		iny				iny
.1511	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1513	95 56		sta $56,x			sta 	NSMantissa2,x
.1515	c8		iny				iny
.1516	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1518	95 62		sta $62,x			sta 	NSMantissa3,x
.151a	c8		iny				iny
.151b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.151d	95 6e		sta $6e,x			sta 	NSExponent,x
.151f	c8		iny				iny
.1520	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1522	95 32		sta $32,x			sta 	NSStatus,x
.1524	7a		ply				ply
.1525	60		rts				rts
.1526					ReadIntegerCommand:
.1526	fa		plx				plx
.1527	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1529	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.152b	88		dey				dey 								; get the upper 3 bits
.152c	b1 28		lda ($28),y			lda 	(codePtr),y
.152e	29 07		and #$07			and 	#7
.1530	c8		iny				iny
.1531	c8		iny				iny
.1532	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1534	2a		rol a				rol 	a 							; carry will be clear.
.1535	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1538	85 2d		sta $2d				sta 	zTemp0+1
.153a	20 40 15	jsr $1540			jsr 	ReadIntegerZTemp0Sub
.153d	4c 38 08	jmp $0838			jmp 	NextCommand
.1540					ReadIntegerZTemp0Sub:
.1540	5a		phy				phy 								; start write
.1541	a0 01		ldy #$01			ldy 	#1
.1543	e8		inx				inx 								; prepare
.1544	74 56		stz $56,x			stz 	NSMantissa2,x
.1546	74 62		stz $62,x			stz 	NSMantissa3,x
.1548	74 6e		stz $6e,x			stz 	NSExponent,x
.154a	74 32		stz $32,x			stz 	NSStatus,x
.154c	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.154e	30 08		bmi $1558			bmi 	_RIZNegative
.1550	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1552	b2 2c		lda ($2c)			lda 	(zTemp0)
.1554	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1556	7a		ply				ply
.1557	60		rts				rts
.1558					_RIZNegative:
.1558	38		sec				sec 								; -ve read
.1559	a9 00		lda #$00			lda 	#0
.155b	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.155d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.155f	a9 00		lda #$00			lda 	#0
.1561	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1563	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1565	a9 80		lda #$80			lda 	#$80
.1567	95 32		sta $32,x			sta 	NSStatus,x
.1569	7a		ply				ply
.156a	60		rts				rts
.156b					ReadStringCommand:
.156b	fa		plx				plx
.156c	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.156e	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1570	88		dey				dey 								; get the upper 3 bits
.1571	b1 28		lda ($28),y			lda 	(codePtr),y
.1573	29 07		and #$07			and 	#7
.1575	c8		iny				iny
.1576	c8		iny				iny
.1577	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1579	2a		rol a				rol 	a 							; carry will be clear.
.157a	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.157d	85 2d		sta $2d				sta 	zTemp0+1
.157f	20 85 15	jsr $1585			jsr 	ReadStringZTemp0Sub
.1582	4c 38 08	jmp $0838			jmp 	NextCommand
.1585					ReadStringZTemp0Sub:
.1585	5a		phy				phy 								; start write
.1586	e8		inx				inx 								; prepare
.1587	74 56		stz $56,x			stz 	NSMantissa2,x
.1589	74 62		stz $62,x			stz 	NSMantissa3,x
.158b	74 6e		stz $6e,x			stz 	NSExponent,x
.158d	a9 40		lda #$40			lda 	#NSSString
.158f	74 32		stz $32,x			stz 	NSStatus,x
.1591	18		clc				clc
.1592	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.1594	69 02		adc #$02			adc 	#2 							; this points to actual data
.1596	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.1598	a0 01		ldy #$01			ldy 	#1
.159a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.159c	69 00		adc #$00			adc 	#0
.159e	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.15a0	d0 08		bne $15aa			bne 	_RSZNoDefault 				; if read $00 use a default value.
.15a2	a9 ac		lda #$ac			lda 	#_RSZNull & $FF
.15a4	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15a6	a9 15		lda #$15			lda 	#_RSZNull >> 8
.15a8	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15aa					_RSZNoDefault:
.15aa	7a		ply				ply
.15ab	60		rts				rts
.15ac					_RSZNull:
>15ac	00						.byte 	0
.15ad					CommandRestoreX:
.15ad	fa		plx				plx
.15ae	20 b4 15	jsr $15b4			jsr 	RestoreCodeOffset
.15b1	4c 38 08	jmp $0838			jmp 	NextCommand
.15b4					RestoreCodeOffset:
.15b4	20 b4 08	jsr $08b4			jsr 	FixUpY  					; make Y = 0 adjusting code Ptr.
.15b7	18		clc				clc 								; add LSB
.15b8	b1 28		lda ($28),y			lda 	(codePtr),y
.15ba	65 28		adc $28				adc 	codePtr
.15bc	85 2a		sta $2a				sta 	objPtr
.15be	c8		iny				iny 								; add MSB
.15bf	b1 28		lda ($28),y			lda 	(codePtr),y
.15c1	65 29		adc $29				adc 	codePtr+1
.15c3	85 2b		sta $2b				sta 	objPtr+1
.15c5	c8		iny				iny 								; next command.
.15c6	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15c9	60		rts				rts
.15ca					RestoreCode:
.15ca	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.15cd	85 2b		sta $2b				sta 	objPtr+1
.15cf	64 2a		stz $2a				stz 	objPtr
.15d1	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15d4	60		rts				rts
.0565					dataRemaining:
>0565							.fill 	1		 					; 0 if not in data statement
.15d5					UnaryRND:
.15d5	fa		plx				plx
.15d6	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.15d8	10 17		bpl $15f1			bpl 	_URNoSeed
.15da	20 e9 23	jsr $23e9			jsr 	FloatNormalise 				; some float value
.15dd	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.15df	8d 66 05	sta $0566			sta 	randomSeed+0
.15e2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15e4	8d 67 05	sta $0567			sta 	randomSeed+1
.15e7	b5 56		lda $56,x			lda 	NSMantissa2,x
.15e9	8d 68 05	sta $0568			sta 	randomSeed+2
.15ec	b5 62		lda $62,x			lda 	NSMantissa3,x
.15ee	8d 69 05	sta $0569			sta 	randomSeed+3
.15f1					_URNoSeed:
.15f1	20 13 16	jsr $1613			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.15f4	ad 66 05	lda $0566			lda 	randomSeed+0
.15f7	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15f9	ad 67 05	lda $0567			lda 	randomSeed+1
.15fc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15fe	ad 68 05	lda $0568			lda 	randomSeed+2
.1601	95 56		sta $56,x			sta 	NSMantissa2,x
.1603	ad 69 05	lda $0569			lda 	randomSeed+3
.1606	29 7f		and #$7f			and 	#$7F
.1608	95 62		sta $62,x			sta 	NSMantissa3,x
.160a	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.160c	95 6e		sta $6e,x			sta 	NSExponent,x
.160e	74 32		stz $32,x			stz 	NSStatus,x
.1610	4c 38 08	jmp $0838			jmp 	NextCommand
.1613					RandomNumberGenerator:
.1613	5a		phy				phy
.1614	ad 66 05	lda $0566			lda 	randomSeed+0 				; check if zero
.1617	0d 67 05	ora $0567			ora 	randomSeed+1
.161a	0d 68 05	ora $0568			ora 	randomSeed+2
.161d	0d 69 05	ora $0569			ora 	randomSeed+3
.1620	d0 07		bne $1629			bne 	_RNGNoSeed
.1622	ce 69 05	dec $0569			dec 	randomSeed+3 				; if so tweak and flog
.1625	a0 64		ldy #$64			ldy 	#100
.1627	80 05		bra $162e			bra 	_RNGLoop
.1629					_RNGNoSeed:
.1629	a0 08		ldy #$08			ldy 	#8
.162b	ad 66 05	lda $0566			lda 	randomSeed+0
.162e					_RNGLoop:
.162e	0a		asl a				asl		a
.162f	2e 67 05	rol $0567			rol 	randomSeed+1
.1632	2e 68 05	rol $0568			rol 	randomSeed+2
.1635	2e 69 05	rol $0569			rol 	randomSeed+3
.1638	90 02		bcc $163c			bcc		_RNGSkip
.163a	49 c5		eor #$c5			eor 	#$C5
.163c					_RNGSkip:
.163c	88		dey				dey
.163d	d0 ef		bne $162e			bne		_RNGLoop
.163f	8d 66 05	sta $0566			sta 	randomSeed+0
.1642	7a		ply				ply
.1643	60		rts				rts
.0566					randomSeed:
>0566							.fill 	4
.1644					StringConcatenate:
.1644	fa		plx				plx
.1645	ca		dex				dex
.1646	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.1648	85 2e		sta $2e				sta 	zTemp1
.164a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.164c	85 2f		sta $2f				sta 	zTemp1+1
.164e	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.1650	85 30		sta $30				sta 	zTemp2
.1652	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.1654	85 31		sta $31				sta 	zTemp2+1
.1656	18		clc				clc 								; work out total length
.1657	b2 2e		lda ($2e)			lda 	(zTemp1)
.1659	72 30		adc ($30)			adc 	(zTemp2)
.165b	b0 18		bcs $1675			bcs 	_BCLength 					; more than 255 characters.
.165d	48		pha				pha 								; save total
.165e	20 3b 17	jsr $173b			jsr 	StringAllocTemp 			; space for result.
.1661	68		pla				pla 								; write total as first.
.1662	92 22		sta ($22)			sta 	(zsTemp)
.1664	20 78 16	jsr $1678			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.1667	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.1669	85 2e		sta $2e				sta 	zTemp1
.166b	a5 31		lda $31				lda 	zTemp2+1
.166d	85 2f		sta $2f				sta 	zTemp1+1
.166f	20 78 16	jsr $1678			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1672	4c 38 08	jmp $0838			jmp 	NextCommand
.1675					_BCLength:
.1675	4c 1f 1f	jmp $1f1f		jmp	ErrorV_range
.1678					_BCCopyZTemp1:
.1678	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.167a	f0 15		beq $1691			beq 	_BCCExit 					; none.
.167c	da		phx				phx 								; save XY
.167d	5a		phy				phy
.167e	aa		tax				tax 								; count in X.
.167f	a0 01		ldy #$01			ldy 	#1
.1681					_BCCLoop:
.1681	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1683	d0 02		bne $1687			bne 	_BCCNoCarry
.1685	e6 23		inc $23				inc 	zsTemp+1
.1687					_BCCNoCarry:
.1687	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.1689	92 22		sta ($22)			sta 	(zsTemp)
.168b	c8		iny				iny
.168c	ca		dex				dex 								; X times
.168d	d0 f2		bne $1681			bne 	_BCCLoop
.168f	7a		ply				ply 								; restore YX
.1690	fa		plx				plx
.1691					_BCCExit:
.1691	60		rts				rts
.1692					XRuntimeSetup:
.1692	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1694	8d 6d 05	sta $056d	 		sta 	ramBank
.1697	8d 6e 05	sta $056e	 		sta 	romBank
.169a	60		rts				rts
.169b					SignTOS:
.169b	fa		plx				plx
.169c	20 b6 26	jsr $26b6			jsr 	FloatIsZero 				; if zero
.169f	f0 0f		beq $16b0			beq 	_SGZero  					; return Int Zero
.16a1	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.16a3	48		pha				pha
.16a4	a9 01		lda #$01			lda 	#1 							; set result to 1
.16a6	20 96 26	jsr $2696			jsr 	FloatSetByte
.16a9	68		pla				pla
.16aa	29 80		and #$80			and		#$80 						; copy the sign byte out
.16ac	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.16ae	80 03		bra $16b3			bra 	_SGExit
.16b0					_SGZero:
.16b0	20 94 26	jsr $2694			jsr 	FloatSetZero
.16b3					_SGExit:
.16b3	4c 38 08	jmp $0838			jmp 	NextCommand
.16b6					CommandShift:
.16b6	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.16b8	c8		iny				iny
.16b9	0a		asl a				asl 	a 							; double into X
.16ba	aa		tax				tax
.16bb	7c 6a 1a	jmp ($1a6a,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.16be					PrintTab:
.16be	fa		plx				plx
.16bf	20 12 1c	jsr $1c12			jsr 	XGetHPos
.16c2					_PTMod10:
.16c2	38		sec				sec
.16c3	e9 0a		sbc #$0a			sbc 	#10
.16c5	b0 fb		bcs $16c2			bcs 	_PTMod10
.16c7	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.16c9	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.16ca	80 15		bra $16e1			bra 	PrintSpaceLoop
.16cc					PrintPos:
.16cc	fa		plx				plx
.16cd	20 12 1c	jsr $1c12			jsr		XGetHPos 					; get current position
.16d0	85 2c		sta $2c				sta 	zTemp0
.16d2	38		sec				sec 								; calculate spaces required
.16d3	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16d5	ca		dex				dex
.16d6	e5 2c		sbc $2c				sbc 	zTemp0
.16d8	b0 07		bcs $16e1			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.16da	4c 38 08	jmp $0838			jmp 	NextCommand
.16dd					PrintSpace:
.16dd	fa		plx				plx
.16de	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16e0	ca		dex				dex
.16e1					PrintSpaceLoop:
.16e1	c9 00		cmp #$00			cmp 	#0
.16e3	f0 0a		beq $16ef			beq 	_PSExit
.16e5	48		pha				pha
.16e6	a9 20		lda #$20			lda 	#" "
.16e8	20 82 13	jsr $1382			jsr 	VectorPrintCharacter
.16eb	68		pla				pla
.16ec	3a		dec a				dec 	a
.16ed	80 f2		bra $16e1			bra 	PrintSpaceLoop
.16ef					_PSExit:
.16ef	4c 38 08	jmp $0838			jmp 	NextCommand
.16f2					CommandStop:
.16f2	fa		plx				plx
.16f3	4c d1 1f	jmp $1fd1		jmp	ErrorV_stop
.16f6					Unary_Str:
.16f6	fa		plx				plx
.16f7	5a		phy				phy
.16f8	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.16fa	20 7c 25	jsr $257c			jsr 	FloatToString 				; do the conversion.
.16fd	a9 21		lda #$21			lda		#33 						; create buffer
.16ff	20 3b 17	jsr $173b			jsr 	StringAllocTemp 			; allocate memory
.1702	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.1704					_USCopy:
.1704	b9 97 05	lda $0597,y			lda 	decimalBuffer-1,y
.1707	f0 05		beq $170e			beq 	_USExit
.1709	91 22		sta ($22),y			sta 	(zsTemp),y
.170b	c8		iny				iny
.170c	80 f6		bra $1704			bra 	_USCopy
.170e					_USExit:
.170e	98		tya				tya
.170f	3a		dec a				dec 	a
.1710	92 22		sta ($22)			sta 	(zsTemp)
.1712	7a		ply				ply
.1713	4c 38 08	jmp $0838			jmp 	NextCommand
.1716					StringInitialise:
.1716	48		pha				pha
.1717	ad 6a 05	lda $056a			lda 	stringInitialised 			; already done
.171a	d0 11		bne $172d			bne 	_SIExit
.171c	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.171f	8d 6b 05	sta $056b			sta 	stringTempPointer
.1722	ad 03 04	lda $0403			lda 	stringHighMemory+1
.1725	3a		dec a				dec 	a
.1726	3a		dec a				dec 	a
.1727	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.172a	ce 6a 05	dec $056a			dec 	stringInitialised 			; set the initialised flag.
.172d					_SIExit:
.172d	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.172f	1a		inc a				inc 	a
.1730	1a		inc a				inc 	a
.1731	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.1734	b0 02		bcs $1738			bcs 	_SIMemory
.1736	68		pla				pla
.1737	60		rts				rts
.1738					_SIMemory:
.1738	4c 2a 20	jmp $202a		jmp	ErrorV_memory
.173b					StringAllocTemp:
.173b	20 16 17	jsr $1716			jsr 	StringInitialise 			; check it is initialised.
.173e	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.1740	18		clc				clc
.1741	6d 6b 05	adc $056b			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.1744	8d 6b 05	sta $056b			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.1747	85 22		sta $22				sta 	zsTemp
.1749	95 3e		sta $3e,x			sta 	NSMantissa0,x
.174b	ad 6c 05	lda $056c			lda 	stringTempPointer+1
.174e	69 ff		adc #$ff			adc 	#$FF
.1750	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.1753	85 23		sta $23				sta 	zsTemp+1
.1755	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1757	74 56		stz $56,x			stz 	NSMantissa2,x
.1759	74 62		stz $62,x			stz 	NSMantissa3,x
.175b	a9 00		lda #$00			lda 	#0 							; clear string.
.175d	92 22		sta ($22)			sta 	(zsTemp)
.175f	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1761	95 32		sta $32,x			sta 	NSStatus,x
.1763	60		rts				rts
.1764					StringWriteChar:
.1764	5a		phy				phy
.1765	48		pha				pha
.1766	b2 22		lda ($22)			lda 	(zsTemp)
.1768	1a		inc a				inc 	a
.1769	92 22		sta ($22)			sta 	(zsTemp)
.176b	a8		tay				tay
.176c	68		pla				pla
.176d	91 22		sta ($22),y			sta 	(zsTemp),y
.176f	7a		ply				ply
.1770	60		rts				rts
.056a					stringInitialised:
>056a							.fill 	1
.056b					stringTempPointer:
>056b							.fill 	2
.1771					Unary_Left:
.1771	fa		plx				plx
.1772	5a		phy				phy
.1773	18		clc				clc 								; only one parameter
.1774	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; push the length of the string.
.1777	48		pha				pha
.1778	ca		dex				dex
.1779	a9 00		lda #$00			lda 	#0 							; push the start position.
.177b	48		pha				pha
.177c	20 b4 17	jsr $17b4			jsr 	UnarySStringToZTemp0
.177f	80 3c		bra $17bd			bra 	SubstringMain 				; stack now points to the string to slice.
.1781					Unary_Right:
.1781	fa		plx				plx
.1782	5a		phy				phy
.1783	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.1785	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; push the right length of the string.
.1788	48		pha				pha
.1789	ca		dex				dex
.178a	20 b4 17	jsr $17b4			jsr 	UnarySStringToZTemp0
.178d	68		pla				pla 								; this is the right requirement
.178e	38		sec				sec
.178f	49 ff		eor #$ff			eor 	#$FF
.1791	72 2c		adc ($2c)			adc 	(zTemp0)
.1793	b0 02		bcs $1797			bcs 	_URHaveCount
.1795	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.1797					_URHaveCount:
.1797	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.1799	5a		phy				phy
.179a	48		pha				pha 								; start position
.179b	80 20		bra $17bd			bra 	SubstringMain
.179d					Unary_Mid:
.179d	fa		plx				plx
.179e	5a		phy				phy
.179f	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; push the length of the string required.
.17a2	48		pha				pha
.17a3	ca		dex				dex
.17a4	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; put the start position.
.17a7	f0 08		beq $17b1			beq 	_UMError
.17a9	3a		dec a				dec 	a
.17aa	48		pha				pha
.17ab	ca		dex				dex
.17ac	20 b4 17	jsr $17b4			jsr 	UnarySStringToZTemp0
.17af	80 0c		bra $17bd			bra 	SubstringMain 				; stack now points to the string to slice.
.17b1					_UMError:
.17b1	4c 1f 1f	jmp $1f1f		jmp	ErrorV_range
.17b4					UnarySStringToZTemp0:
.17b4	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17b6	85 2c		sta $2c				sta 	zTemp0
.17b8	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17ba	85 2d		sta $2d				sta 	zTemp0+1
.17bc	60		rts				rts
.17bd					SubstringMain:
.17bd	68		pla				pla 								; get the start offset
.17be	7a		ply				ply 								; get the count to do.
.17bf	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.17c1	b0 38		bcs $17fb			bcs 	_SSReturnNull
.17c3	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.17c5	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.17c7	18		clc				clc
.17c8	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.17ca	b0 06		bcs $17d2			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.17cc	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.17ce	f0 04		beq $17d4			beq 	_SMIsOkay
.17d0	90 02		bcc $17d4			bcc 	_SMIsOkay
.17d2					_SMTruncateToEnd:
.17d2	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.17d4					_SMIsOkay:
.17d4	85 2f		sta $2f				sta 	zTemp1+1
.17d6	38		sec				sec		 							; work out size
.17d7	a5 2f		lda $2f				lda 	zTemp1+1
.17d9	e5 2e		sbc $2e				sbc 	zTemp1
.17db	f0 1e		beq $17fb			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.17dd	20 3b 17	jsr $173b			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.17e0	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.17e2					_SMCopy:
.17e2	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.17e4	f0 11		beq $17f7			beq 	_SMExit
.17e6	c8		iny				iny 								; bump and
.17e7	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.17e9	5a		phy				phy
.17ea	48		pha				pha
.17eb	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.17ed	1a		inc a				inc 	a
.17ee	a8		tay				tay
.17ef	92 22		sta ($22)			sta 	(zsTemp)
.17f1	68		pla				pla 								; write character out
.17f2	91 22		sta ($22),y			sta 	(zsTemp),y
.17f4	7a		ply				ply 								; restore Y
.17f5	80 eb		bra $17e2			bra 	_SMCopy
.17f7					_SMExit:
.17f7	7a		ply				ply
.17f8	4c 38 08	jmp $0838			jmp 	NextCommand
.17fb					_SSReturnNull:
.17fb	a9 0d		lda #$0d			lda 	#SSRNull & $FF 				; set up mantissa
.17fd	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17ff	a9 18		lda #$18			lda 	#SSRNull >> 8
.1801	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1803	74 56		stz $56,x			stz 	NSMantissa2,x
.1805	74 62		stz $62,x			stz 	NSMantissa3,x
.1807	a9 40		lda #$40			lda 	#NSSString
.1809	95 32		sta $32,x			sta 	NSStatus,x
.180b	80 ea		bra $17f7			bra 	_SMExit
.180d					SSRNull:
>180d	00 00						.word 	0
.180f					CommandSwap:
.180f	fa		plx				plx
.1810	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1812	48		pha				pha
.1813	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1815	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1817	68		pla				pla
.1818	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.181a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.181c	48		pha				pha
.181d	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.181f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1821	68		pla				pla
.1822	95 49		sta $49,x			sta 	NSMantissa1-1,x
.1824	b5 56		lda $56,x			lda 	NSMantissa2,x
.1826	48		pha				pha
.1827	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.1829	95 56		sta $56,x			sta 	NSMantissa2,x
.182b	68		pla				pla
.182c	95 55		sta $55,x			sta 	NSMantissa2-1,x
.182e	b5 62		lda $62,x			lda 	NSMantissa3,x
.1830	48		pha				pha
.1831	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.1833	95 62		sta $62,x			sta 	NSMantissa3,x
.1835	68		pla				pla
.1836	95 61		sta $61,x			sta 	NSMantissa3-1,x
.1838	b5 6e		lda $6e,x			lda 	NSExponent,x
.183a	48		pha				pha
.183b	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.183d	95 6e		sta $6e,x			sta 	NSExponent,x
.183f	68		pla				pla
.1840	95 6d		sta $6d,x			sta 	NSExponent-1,x
.1842	b5 32		lda $32,x			lda 	NSStatus,x
.1844	48		pha				pha
.1845	b5 31		lda $31,x			lda 	NSStatus-1,x
.1847	95 32		sta $32,x			sta 	NSStatus,x
.1849	68		pla				pla
.184a	95 31		sta $31,x			sta 	NSStatus-1,x
.184c	4c 38 08	jmp $0838			jmp 	NextCommand
.184f					CommandSYS:
.184f	fa		plx				plx
.1850	da		phx				phx 								; save XY
.1851	5a		phy				phy
.1852	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.1855	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.1857	85 2d		sta $2d				sta 	zTemp0+1
.1859	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.185b	85 2c		sta $2c				sta 	zTemp0
.185d	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1860	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.1863	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.1866	48		pha				pha
.1867	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.186a	28		plp				plp
.186b	20 82 18	jsr $1882			jsr 	_CSZTemp0
.186e	08		php				php
.186f	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1872	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.1875	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.1878	68		pla				pla
.1879	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.187c	7a		ply				ply 								; restore YX and drop 2
.187d	fa		plx				plx
.187e	ca		dex				dex
.187f	4c 38 08	jmp $0838			jmp 	NextCommand
.1882					_CSZTemp0:
.1882	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.1885					TimeTOS:
.1885	fa		plx				plx
.1886	20 e0 18	jsr $18e0			jsr 	TIPushClock 				; push clock to TOS
.1889	4c 38 08	jmp $0838			jmp 	NextCommand
.188c					TimeString:
.188c	fa		plx				plx
.188d	20 e0 18	jsr $18e0			jsr 	TIPushClock 				; push clock to TOS
.1890	20 b5 18	jsr $18b5			jsr 	_TSDivMod60 				; result in seconds
.1893	20 b5 18	jsr $18b5			jsr 	_TSDivMod60 				; seconds
.1896	48		pha				pha
.1897	20 b5 18	jsr $18b5			jsr 	_TSDivMod60 				; minutes
.189a	48		pha				pha
.189b	a9 18		lda #$18			lda 	#24 						; hours
.189d	20 b7 18	jsr $18b7			jsr 	_TSDivModA
.18a0	48		pha				pha
.18a1	a9 06		lda #$06			lda 	#6
.18a3	20 3b 17	jsr $173b			jsr 	StringAllocTemp
.18a6	68		pla				pla
.18a7	20 c7 18	jsr $18c7			jsr 	_TSWriteDecimal
.18aa	68		pla				pla
.18ab	20 c7 18	jsr $18c7			jsr 	_TSWriteDecimal
.18ae	68		pla				pla
.18af	20 c7 18	jsr $18c7			jsr 	_TSWriteDecimal
.18b2	4c 38 08	jmp $0838			jmp 	NextCommand
.18b5					_TSDivMod60:
.18b5	a9 3c		lda #$3c			lda 	#60
.18b7					_TSDivModA:
.18b7	e8		inx				inx
.18b8	20 96 26	jsr $2696			jsr 	FloatSetByte
.18bb	ca		dex				dex
.18bc	20 2a 22	jsr $222a			jsr 	Int32Divide
.18bf	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.18c1	48		pha				pha
.18c2	20 19 22	jsr $2219			jsr 	NSMCopyPlusTwoToZero
.18c5	68		pla				pla
.18c6	60		rts				rts
.18c7					_TSWriteDecimal:
.18c7	da		phx				phx
.18c8	a2 30		ldx #$30			ldx 	#'0'
.18ca					_TSWDLoop:
.18ca	c9 0a		cmp #$0a			cmp 	#10
.18cc	90 05		bcc $18d3			bcc 	_TSWDEnd
.18ce	e9 0a		sbc #$0a			sbc 	#10
.18d0	e8		inx				inx
.18d1	80 f7		bra $18ca			bra 	_TSWDLoop
.18d3					_TSWDEnd:
.18d3	48		pha				pha
.18d4	8a		txa				txa
.18d5	20 64 17	jsr $1764			jsr 	StringWriteChar
.18d8	68		pla				pla
.18d9	09 30		ora #$30			ora 	#'0'
.18db	20 64 17	jsr $1764			jsr 	StringWriteChar
.18de	fa		plx				plx
.18df	60		rts				rts
.18e0					TIPushClock:
.18e0	5a		phy				phy
.18e1	e8		inx				inx 								; push 0 on the stack
.18e2	20 94 26	jsr $2694			jsr 	FloatSetZero
.18e5	da		phx				phx
.18e6	20 dd 1c	jsr $1cdd			jsr 	XReadClock 					; read time into YXA
.18e9	86 2c		stx $2c				stx 	zTemp0
.18eb	fa		plx				plx
.18ec	95 3e		sta $3e,x			sta 	NSMantissa0,x
.18ee	a5 2c		lda $2c				lda 	zTemp0
.18f0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.18f2	98		tya				tya
.18f3	95 56		sta $56,x			sta 	NSMantissa2,x
.18f5	7a		ply				ply
.18f6	60		rts				rts
.18f7					CommandTIWrite:
.18f7	fa		plx				plx
.18f8	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.18fa	85 22		sta $22				sta 	zsTemp
.18fc	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.18fe	85 23		sta $23				sta 	zsTemp+1
.1900	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.1902	c9 06		cmp #$06			cmp 	#6
.1904	d0 59		bne $195f			bne 	_CTIWError
.1906	20 94 26	jsr $2694			jsr 	FloatSetZero
.1909	20 2b 19	jsr $192b			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.190c	20 2b 19	jsr $192b			jsr 	_CTIWDigitPair
.190f	20 2b 19	jsr $192b			jsr 	_CTIWDigitPair
.1912	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.1914	20 56 19	jsr $1956			jsr 	_CTIWMultiply
.1917	da		phx				phx
.1918	5a		phy				phy
.1919	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.191b	48		pha				pha
.191c	b5 56		lda $56,x			lda 	NSMantissa2,x
.191e	a8		tay				tay
.191f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1921	fa		plx				plx
.1922	20 e1 1c	jsr $1ce1			jsr 	XWriteClock 				; update the clock.
.1925	7a		ply				ply
.1926	fa		plx				plx
.1927	ca		dex				dex 								; throw result.
.1928	4c 38 08	jmp $0838			jmp 	NextCommand
.192b					_CTIWDigitPair:
.192b	a9 06		lda #$06			lda 	#6 							; x 6
.192d	20 56 19	jsr $1956			jsr 	_CTIWMultiply
.1930	20 3c 19	jsr $193c			jsr 	_CTIWAddDigit 				; add digit
.1933	a9 0a		lda #$0a			lda 	#10 						; x 10
.1935	20 56 19	jsr $1956			jsr 	_CTIWMultiply
.1938	20 3c 19	jsr $193c			jsr 	_CTIWAddDigit 				; add digit
.193b	60		rts				rts
.193c					_CTIWAddDigit:
.193c	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.193e	d0 02		bne $1942			bne 	_CTIWASkip
.1940	e6 23		inc $23				inc 	zsTemp+1
.1942					_CTIWASkip:
.1942	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.1944	38		sec				sec
.1945	e9 30		sbc #$30			sbc 	#"0"
.1947	90 16		bcc $195f			bcc 	_CTIWError
.1949	c9 0a		cmp #$0a			cmp 	#9+1
.194b	b0 12		bcs $195f			bcs 	_CTIWError
.194d	e8		inx				inx 								; store at +1
.194e	20 96 26	jsr $2696			jsr 	FloatSetByte
.1951	ca		dex				dex
.1952	20 20 24	jsr $2420			jsr 	FloatAddTopTwoStack
.1955	60		rts				rts
.1956					_CTIWMultiply:
.1956	e8		inx				inx
.1957	20 96 26	jsr $2696			jsr 	FloatSetByte
.195a	ca		dex				dex
.195b	20 a1 23	jsr $23a1			jsr 	FloatMultiplyShort
.195e	60		rts				rts
.195f					_CTIWError:
.195f	4c 2f 1f	jmp $1f2f		jmp	ErrorV_value
.1962					UnaryUsr:
.1962	fa		plx				plx
.1963	5a		phy				phy
.1964	20 6b 19	jsr $196b			jsr 	_UUCallVector
.1967	7a		ply				ply
.1968	4c 38 08	jmp $0838			jmp 	NextCommand
.196b					_UUCallVector:
.196b	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.196e					ValUnary:
.196e	fa		plx				plx
.196f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1971	85 2c		sta $2c				sta 	zTemp0
.1973	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1975	85 2d		sta $2d				sta 	zTemp0+1
.1977	20 82 19	jsr $1982			jsr 	ValEvaluateZTemp0
.197a	b0 03		bcs $197f			bcs 	_VUError 					; couldn't convert
.197c	4c 38 08	jmp $0838			jmp 	NextCommand
.197f					_VUError:
.197f	4c 2f 1f	jmp $1f2f		jmp	ErrorV_value
.1982					ValEvaluateZTemp0:
.1982	5a		phy				phy
.1983	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.1985	f0 22		beq $19a9			beq 	_VMCFail2
.1987	a0 00		ldy #$00			ldy 	#0 							; start position
.1989					_VMCSpaces:
.1989	c8		iny				iny 								; skip leading spaces
.198a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.198c	c9 20		cmp #$20			cmp 	#" "
.198e	f0 f9		beq $1989			beq 	_VMCSpaces
.1990	48		pha				pha 								; save first character
.1991	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.1993	d0 01		bne $1996			bne 	_VMCStart
.1995	c8		iny				iny 								; skip over - if so.
.1996					_VMCStart:
.1996	38		sec				sec 								; initialise first time round.
.1997					_VMCNext:
.1997	98		tya				tya 								; reached end of string
.1998	3a		dec a				dec 	a
.1999	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.199b	f0 0f		beq $19ac			beq 	_VMCSuccess 				; successful.
.199d	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.199f	c8		iny				iny
.19a0	20 78 24	jsr $2478			jsr 	FloatEncode 				; send it to the number-builder
.19a3	90 03		bcc $19a8			bcc 	_VMCFail 					; if failed, give up.
.19a5	18		clc				clc 								; next time round, countinue
.19a6	80 ef		bra $1997			bra 	_VMCNext
.19a8					_VMCFail:
.19a8	68		pla				pla
.19a9					_VMCFail2:
.19a9	7a		ply				ply
.19aa	38		sec				sec
.19ab	60		rts				rts
.19ac					_VMCSuccess:
.19ac	a9 00		lda #$00			lda 	#0 							; construct final
.19ae	20 78 24	jsr $2478			jsr 	FloatEncode 				; by sending a duff value.
.19b1	68		pla				pla 								; if it was -ve
.19b2	c9 2d		cmp #$2d			cmp 	#"-"
.19b4	d0 03		bne $19b9			bne 	_VMCNotNegative
.19b6	20 56 26	jsr $2656			jsr		FloatNegate 				; negate it.
.19b9					_VMCNotNegative:
.19b9	7a		ply				ply
.19ba	18		clc				clc
.19bb	60		rts				rts
.19bc					VectorTable:
>19bc	98 10					.word	LinkFloatAdd             ; $80 +
>19be	a1 10					.word	LinkFloatSubtract        ; $81 -
>19c0	aa 10					.word	LinkFloatMultiply        ; $82 *
>19c2	b3 10					.word	LinkFloatDivide          ; $83 /
>19c4	be 10					.word	LinkFloatPower           ; $84 ^
>19c6	db 08					.word	BinaryAnd                ; $85 and
>19c8	df 08					.word	BinaryOr                 ; $86 or
>19ca	c9 10					.word	LinkCompareGreater       ; $87 >
>19cc	d2 10					.word	LinkCompareEqual         ; $88 =
>19ce	db 10					.word	LinkCompareLess          ; $89 <
>19d0	e4 10					.word	LinkCompareGreaterEqual  ; $8a >=
>19d2	ed 10					.word	LinkCompareNotEqual      ; $8b <>
>19d4	f6 10					.word	LinkCompareLessEqual     ; $8c <=
>19d6	c3 08					.word	AbsoluteTOS              ; $8d abs
>19d8	16 09					.word	ArrayConvert             ; $8e array
>19da	be 09					.word	UnaryAsc                 ; $8f asc
>19dc	d9 09					.word	CommandAssert            ; $90 assert
>19de	1a 0a					.word	Unary16Bin               ; $91 bin$
>19e0	44 0a					.word	PrintCharacterX          ; $92 print.chr
>19e2	4e 0a					.word	UnaryChr                 ; $93 chr$
>19e4	b3 0a					.word	CompareStrings           ; $94 s.cmp
>19e6	9f 0c					.word	CommandXFor              ; $95 for
>19e8	62 0d					.word	UnaryFre                 ; $96 fre
>19ea	7a 0d					.word	CommandXGet              ; $97 get
>19ec	a0 0d					.word	CommandReturn            ; $98 return
>19ee	e2 0d					.word	Command_PSET             ; $99 pset
>19f0	fc 0d					.word	Command_LINE             ; $9a line
>19f2	11 0e					.word	Command_RECT             ; $9b rect
>19f4	20 0e					.word	Command_FRAME            ; $9c frame
>19f6	2f 0e					.word	Command_CHAR             ; $9d char
>19f8	cc 0e					.word	Unary16Hex               ; $9e hex$
>19fa	73 0f					.word	CommandXInput            ; $9f input
>19fc	8a 0f					.word	CommandInputString       ; $a0 input$
>19fe	a3 0f					.word	CommandInputReset        ; $a1 input.start
>1a00	87 10					.word	UnaryLen                 ; $a2 len
>1a02	53 11					.word	LinkFloatCompare         ; $a3 f.cmp
>1a04	5c 11					.word	LinkDivideInt32          ; $a4 int.div
>1a06	f1 11					.word	NegateTOS                ; $a5 negate
>1a08	f8 11					.word	CommandNewLine           ; $a6 new.line
>1a0a	01 12					.word	CommandXNext             ; $a7 next
>1a0c	ea 12					.word	NotTOS                   ; $a8 not
>1a0e	01 13					.word	CommandXOn               ; $a9 on
>1a10	1e 13					.word	CommandMoreOn            ; $aa moreon
>1a12	25 13					.word	UnaryPeek                ; $ab peek
>1a14	3a 13					.word	UnaryPI                  ; $ac pi
>1a16	44 13					.word	CommandPOKE              ; $ad poke
>1a18	5c 13					.word	UnaryPos                 ; $ae pos
>1a1a	66 13					.word	GetChannel               ; $af getchannel
>1a1c	71 13					.word	SetChannel               ; $b0 setchannel
>1a1e	94 13					.word	PrintNumber              ; $b1 print.n
>1a20	b3 13					.word	PrintString              ; $b2 print.s
>1a22	1a 14					.word	CommandXRead             ; $b3 read
>1a24	34 14					.word	CommandReadString        ; $b4 read$
>1a26	d5 15					.word	UnaryRND                 ; $b5 rnd
>1a28	44 16					.word	StringConcatenate        ; $b6 concat
>1a2a	9b 16					.word	SignTOS                  ; $b7 sgn
>1a2c	be 16					.word	PrintTab                 ; $b8 print.tab
>1a2e	cc 16					.word	PrintPos                 ; $b9 print.pos
>1a30	dd 16					.word	PrintSpace               ; $ba print.spc
>1a32	f6 16					.word	Unary_Str                ; $bb str$
>1a34	71 17					.word	Unary_Left               ; $bc left$
>1a36	81 17					.word	Unary_Right              ; $bd right$
>1a38	9d 17					.word	Unary_Mid                ; $be mid$
>1a3a	0f 18					.word	CommandSwap              ; $bf swap
>1a3c	85 18					.word	TimeTOS                  ; $c0 ti
>1a3e	8c 18					.word	TimeString               ; $c1 ti$
>1a40	62 19					.word	UnaryUsr                 ; $c2 usr
>1a42	6e 19					.word	ValUnary                 ; $c3 val
>1a44	d9 1b					.word	CommandClose             ; $c4 close
>1a46	eb 1b					.word	CommandExit              ; $c5 exit
>1a48	f1 1b					.word	CommandDebug             ; $c6 debug
>1a4a	57 1c					.word	CommandXOpen             ; $c7 open
>1a4c	eb 1c					.word	CommandScreen            ; $c8 screen
>1a4e	cf 1e					.word	CommandVPOKE             ; $c9 vpoke
>1a50	f4 1e					.word	CommandVPEEK             ; $ca vpeek
>1a52	b6 16					.word	CommandShift             ; $cb .shift
>1a54	87 08					.word	PushByteCommand          ; $cc .byte
>1a56	9a 08					.word	PushWordCommand          ; $cd .word
>1a58	d6 13					.word	CommandPushN             ; $ce .float
>1a5a	fc 13					.word	CommandPushS             ; $cf .string
>1a5c	3b 0b					.word	CommandXData             ; $d0 .data
>1a5e	b1 0d					.word	CommandXGoto             ; $d1 .goto
>1a60	94 0d					.word	CommandXGosub            ; $d2 .gosub
>1a62	c6 0d					.word	CommandGotoZ             ; $d3 .goto.z
>1a64	d4 0d					.word	CommandGotoNZ            ; $d4 .goto.nz
>1a66	c9 08					.word	CommandVarSpace          ; $d5 .varspace
>1a68	ad 15					.word	CommandRestoreX          ; $d6 .restore
.1a6a					ShiftVectorTable:
>1a6a	66 0a					.word	CommandClr               ; $cb80 clr
>1a6c	44 0b					.word	CommandXDIM              ; $cb81 dim
>1a6e	35 0c					.word	CommandEnd               ; $cb82 end
>1a70	58 10					.word	UnaryJoy                 ; $cb83 joy
>1a72	ff 10					.word	LinkFloatIntegerPartDown ; $cb84 int
>1a74	08 11					.word	LinkFloatSquareRoot      ; $cb85 sqr
>1a76	19 11					.word	LinkFloatLogarithm       ; $cb86 log
>1a78	24 11					.word	LinkFloatExponent        ; $cb87 exp
>1a7a	2d 11					.word	LinkFloatCosine          ; $cb88 cos
>1a7c	36 11					.word	LinkFloatSine            ; $cb89 sin
>1a7e	3f 11					.word	LinkFloatTangent         ; $cb8a tan
>1a80	48 11					.word	LinkFloatArcTan          ; $cb8b atn
>1a82	86 11					.word	XCommandMouse            ; $cb8c mouse
>1a84	9b 11					.word	XUnaryMB                 ; $cb8d mb
>1a86	a8 11					.word	XUnaryMX                 ; $cb8e mx
>1a88	b9 11					.word	XUnaryMY                 ; $cb8f my
>1a8a	ca 11					.word	XUnaryMWheel             ; $cb90 mwheel
>1a8c	f2 16					.word	CommandStop              ; $cb91 stop
>1a8e	4f 18					.word	CommandSYS               ; $cb92 sys
>1a90	f7 18					.word	CommandTIWrite           ; $cb93 ti$.write
>1a92	c8 1a					.word	CommandXWAIT             ; $cb94 wait
>1a94	1c 1c					.word	X16I2CPoke               ; $cb95 i2cpoke
>1a96	3c 1c					.word	X16I2CPeek               ; $cb96 i2cpeek
>1a98	a7 1c					.word	CommandBank              ; $cb97 bank
>1a9a	fa 1c					.word	XCommandSleep            ; $cb98 sleep
>1a9c	1e 1d					.word	X16_Audio_FMINIT         ; $cb99 fminit
>1a9e	2c 1d					.word	X16_Audio_FMNOTE         ; $cb9a fmnote
>1aa0	3e 1d					.word	X16_Audio_FMDRUM         ; $cb9b fmdrum
>1aa2	50 1d					.word	X16_Audio_FMINST         ; $cb9c fminst
>1aa4	62 1d					.word	X16_Audio_FMVIB          ; $cb9d fmvib
>1aa6	74 1d					.word	X16_Audio_FMFREQ         ; $cb9e fmfreq
>1aa8	85 1d					.word	X16_Audio_FMVOL          ; $cb9f fmvol
>1aaa	97 1d					.word	X16_Audio_FMPAN          ; $cba0 fmpan
>1aac	a9 1d					.word	X16_Audio_FMPLAY         ; $cba1 fmplay
>1aae	ba 1d					.word	X16_Audio_FMCHORD        ; $cba2 fmchord
>1ab0	cb 1d					.word	X16_Audio_FMPOKE         ; $cba3 fmpoke
>1ab2	dd 1d					.word	X16_Audio_PSGINIT        ; $cba4 psginit
>1ab4	eb 1d					.word	X16_Audio_PSGNOTE        ; $cba5 psgnote
>1ab6	fd 1d					.word	X16_Audio_PSGVOL         ; $cba6 psgvol
>1ab8	0f 1e					.word	X16_Audio_PSGWAV         ; $cba7 psgwav
>1aba	21 1e					.word	X16_Audio_PSGFREQ        ; $cba8 psgfreq
>1abc	32 1e					.word	X16_Audio_PSGPAN         ; $cba9 psgpan
>1abe	44 1e					.word	X16_Audio_PSGPLAY        ; $cbaa psgplay
>1ac0	55 1e					.word	X16_Audio_PSGCHORD       ; $cbab psgchord
>1ac2	66 1e					.word	CommandCls               ; $cbac cls
>1ac4	6f 1e					.word	CommandLocate            ; $cbad locate
>1ac6	96 1e					.word	CommandColor             ; $cbae color
.1ac8					CommandXWAIT:
.1ac8	fa		plx				plx
.1ac9	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1acb	85 2c		sta $2c				sta 	zTemp0
.1acd	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1acf	85 2d		sta $2d				sta 	zTemp0+1
.1ad1					_WaitLoop:
.1ad1	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1ad3	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1ad5	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1ad7	f0 f8		beq $1ad1			beq 	_WaitLoop 					; keep going if zero
.1ad9	ca		dex				dex 								; drop 3.
.1ada	ca		dex				dex
.1adb	ca		dex				dex
.1adc	4c 38 08	jmp $0838			jmp 	NextCommand
.1adf					WriteFloatCommand:
.1adf	fa		plx				plx
.1ae0	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1ae2	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1ae4	88		dey				dey 								; get the upper 3 bits
.1ae5	b1 28		lda ($28),y			lda 	(codePtr),y
.1ae7	29 07		and #$07			and 	#7
.1ae9	c8		iny				iny
.1aea	c8		iny				iny
.1aeb	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1aed	2a		rol a				rol 	a 							; carry will be clear.
.1aee	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1af1	85 2d		sta $2d				sta 	zTemp0+1
.1af3	20 f9 1a	jsr $1af9			jsr 	WriteFloatZTemp0Sub
.1af6	4c 38 08	jmp $0838			jmp 	NextCommand
.1af9					WriteFloatZTemp0Sub:
.1af9	5a		phy				phy 								; ldart write
.1afa	a0 01		ldy #$01			ldy 	#1
.1afc	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1afe	92 2c		sta ($2c)			sta 	(zTemp0)
.1b00	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b02	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b04	c8		iny				iny
.1b05	b5 56		lda $56,x			lda 	NSMantissa2,x
.1b07	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b09	c8		iny				iny
.1b0a	b5 62		lda $62,x			lda 	NSMantissa3,x
.1b0c	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b0e	c8		iny				iny
.1b0f	b5 6e		lda $6e,x			lda 	NSExponent,x
.1b11	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b13	c8		iny				iny
.1b14	b5 32		lda $32,x			lda 	NSStatus,x
.1b16	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b18	ca		dex				dex
.1b19	7a		ply				ply
.1b1a	60		rts				rts
.1b1b					WriteIntegerCommand:
.1b1b	fa		plx				plx
.1b1c	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b1e	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b20	88		dey				dey 								; get the upper 3 bits
.1b21	b1 28		lda ($28),y			lda 	(codePtr),y
.1b23	29 07		and #$07			and 	#7
.1b25	c8		iny				iny
.1b26	c8		iny				iny
.1b27	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b29	2a		rol a				rol 	a 							; carry will be clear.
.1b2a	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b2d	85 2d		sta $2d				sta 	zTemp0+1
.1b2f	20 35 1b	jsr $1b35			jsr 	WriteIntegerZTemp0Sub
.1b32	4c 38 08	jmp $0838			jmp 	NextCommand
.1b35					WriteIntegerZTemp0Sub:
.1b35	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.1b38	5a		phy				phy 								; start write
.1b39	a0 01		ldy #$01			ldy 	#1
.1b3b	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1b3d	30 0b		bmi $1b4a			bmi 	_WIZNegative
.1b3f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1b41	92 2c		sta ($2c)			sta 	(zTemp0)
.1b43	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b45	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b47	7a		ply				ply
.1b48	ca		dex				dex
.1b49	60		rts				rts
.1b4a					_WIZNegative:
.1b4a	38		sec				sec 								; -ve read
.1b4b	a9 00		lda #$00			lda 	#0
.1b4d	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1b4f	92 2c		sta ($2c)			sta 	(zTemp0)
.1b51	a9 00		lda #$00			lda 	#0
.1b53	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1b55	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b57	7a		ply				ply
.1b58	ca		dex				dex
.1b59	60		rts				rts
.1b5a					WriteStringCommand:
.1b5a	fa		plx				plx
.1b5b	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b5d	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b5f	88		dey				dey 								; get the upper 3 bits
.1b60	b1 28		lda ($28),y			lda 	(codePtr),y
.1b62	29 07		and #$07			and 	#7
.1b64	c8		iny				iny
.1b65	c8		iny				iny
.1b66	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b68	2a		rol a				rol 	a 							; carry will be clear.
.1b69	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b6c	85 2d		sta $2d				sta 	zTemp0+1
.1b6e	20 74 1b	jsr $1b74			jsr 	WriteStringZTemp0Sub
.1b71	4c 38 08	jmp $0838			jmp 	NextCommand
.1b74					WriteStringZTemp0Sub:
.1b74	5a		phy				phy
.1b75	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b77	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b79	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b7b	f0 1e		beq $1b9b			beq 	_WSConcrete
.1b7d	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b7f	85 2e		sta $2e				sta 	zTemp1
.1b81	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b83	85 2f		sta $2f				sta 	zTemp1+1
.1b85	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b87	85 30		sta $30				sta 	zTemp2
.1b89	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b8b	85 31		sta $31				sta 	zTemp2+1
.1b8d	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1b8f	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1b91	b0 17		bcs $1baa			bcs 	_WSCopy
.1b93	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1b95	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b97	09 80		ora #$80			ora 	#$80
.1b99	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1b9b					_WSConcrete:
.1b9b	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1b9d	a8		tay				tay
.1b9e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ba0	20 f5 0a	jsr $0af5			jsr 	StringConcrete
.1ba3	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1ba5	98		tya				tya
.1ba6	a0 01		ldy #$01			ldy 	#1
.1ba8	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1baa					_WSCopy
.1baa	18		clc				clc  								; copy target+2 to zTemp2
.1bab	b2 2c		lda ($2c)			lda 	(zTemp0)
.1bad	69 02		adc #$02			adc 	#2
.1baf	85 30		sta $30				sta 	zTemp2
.1bb1	a0 01		ldy #$01			ldy 	#1
.1bb3	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1bb5	69 00		adc #$00			adc 	#0
.1bb7	85 31		sta $31				sta 	zTemp2+1
.1bb9	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1bbb	85 2e		sta $2e				sta 	zTemp1
.1bbd	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1bbf	85 2f		sta $2f				sta 	zTemp1+1
.1bc1	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1bc3	a8		tay				tay
.1bc4					_WSCopyLoop:
.1bc4	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1bc6	91 30		sta ($30),y			sta 	(zTemp2),y
.1bc8	88		dey				dey
.1bc9	c0 ff		cpy #$ff			cpy 	#$FF
.1bcb	d0 f7		bne $1bc4			bne 	_WSCopyLoop
.1bcd	ca		dex				dex
.1bce	7a		ply				ply
.1bcf	60		rts				rts
.1bd0					XCheckStop:
.1bd0	20 e1 ff	jsr $ffe1			jsr 	$FFE1 						; check stop
.1bd3	f0 01		beq $1bd6			beq 	_XCSStop
.1bd5	60		rts				rts
.1bd6					_XCSStop:
.1bd6	4c 51 20	jmp $2051		jmp	ErrorV_break
.1bd9					CommandClose:
.1bd9	fa		plx				plx
.1bda	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; channel to close
.1bdd	cd 5f 04	cmp $045f			cmp 	currentChannel 				; is it the current channel
.1be0	d0 03		bne $1be5			bne 	_CCNotCurrent
.1be2	9c 5f 04	stz $045f			stz 	currentChannel 				; effectively disables CMD
.1be5					_CCNotCurrent:
.1be5	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1be8	4c 38 08	jmp $0838			jmp 	NextCommand
.1beb					CommandExit:
.1beb	fa		plx				plx
.1bec	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1bee	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1bf1					CommandDebug:
.1bf1	fa		plx				plx
>1bf2	db						.byte 	$DB 						; causes a break in the emulator
.1bf3	4c 38 08	jmp $0838			jmp 	NextCommand
.1bf6					XGetCharacterFromChannel:
.1bf6	da		phx				phx
.1bf7	5a		phy				phy
.1bf8	e0 00		cpx #$00			cpx 	#0 							; is it default
.1bfa	d0 05		bne $1c01			bne 	_XGetChannel
.1bfc	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1bff	80 08		bra $1c09			bra 	_XGetChar
.1c01					_XGetChannel:
.1c01	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1c04	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1c07	d0 06		bne $1c0f			bne 	_XGCError
.1c09					_XGetChar:
.1c09	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1c0c	7a		ply				ply
.1c0d	fa		plx				plx
.1c0e	60		rts				rts
.1c0f					_XGCError:
.1c0f	4c 3b 20	jmp $203b		jmp	ErrorV_channel
.1c12					XGetHPos:
.1c12	da		phx				phx
.1c13	5a		phy				phy
.1c14	38		sec				sec
.1c15	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1c18	98		tya				tya
.1c19	7a		ply				ply
.1c1a	fa		plx				plx
.1c1b	60		rts				rts
.1c1c					X16I2CPoke:
.1c1c	fa		plx				plx
.1c1d	5a		phy				phy
.1c1e	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; value
.1c21	48		pha				pha
.1c22	ca		dex				dex
.1c23	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; register
.1c26	48		pha				pha
.1c27	ca		dex				dex
.1c28	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; device
.1c2b	aa		tax				tax
.1c2c	7a		ply				ply
.1c2d	68		pla				pla
.1c2e	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1c31	b0 06		bcs $1c39			bcs 	X16I2CError
.1c33	7a		ply				ply
.1c34	a2 ff		ldx #$ff			ldx 	#$FF
.1c36	4c 38 08	jmp $0838			jmp 	NextCommand
.1c39					X16I2CError:
.1c39	4c 3b 20	jmp $203b		jmp	ErrorV_channel
.1c3c					X16I2CPeek:
.1c3c	fa		plx				plx
.1c3d	da		phx				phx
.1c3e	5a		phy				phy
.1c3f	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; register
.1c42	48		pha				pha
.1c43	ca		dex				dex
.1c44	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; device
.1c47	aa		tax				tax 								; X device
.1c48	7a		ply				ply 								; Y register
.1c49	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1c4c	b0 eb		bcs $1c39			bcs 	X16I2CError
.1c4e	7a		ply				ply 								; restore Y/X
.1c4f	fa		plx				plx
.1c50	ca		dex				dex 								; drop TOS (register)
.1c51	20 96 26	jsr $2696			jsr 	FloatSetByte 				; write read value to TOS.
.1c54	4c 38 08	jmp $0838			jmp 	NextCommand
.1c57					CommandXOpen:
.1c57	fa		plx				plx
.1c58	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1c5a	85 2c		sta $2c				sta 	zTemp0
.1c5c	aa		tax				tax
.1c5d	a5 4d		lda $4d				lda 	NSMantissa1+3
.1c5f	85 2d		sta $2d				sta 	zTemp0+1
.1c61	a8		tay				tay
.1c62	e8		inx				inx 								; XY points to first character
.1c63	d0 01		bne $1c66			bne 	_CONoCarry
.1c65	c8		iny				iny
.1c66					_CONoCarry:
.1c66	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c68	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c6b	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c6d	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c6f	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c71	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c74	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c77	b0 03		bcs $1c7c			bcs 	_COError
.1c79	4c 38 08	jmp $0838			jmp 	NextCommand
.1c7c					_COError:
.1c7c	4c 3b 20	jmp $203b		jmp	ErrorV_channel
.1c7f					XPokeMemory:
.1c7f	86 2c		stx $2c				stx 	zTemp0
.1c81	84 2d		sty $2d				sty 	zTemp0+1
.1c83	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c85	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c88	e0 ff		cpx #$ff			cpx 	#$FF
.1c8a	f0 02		beq $1c8e			beq 	_XPMNoSwitch
.1c8c	86 00		stx $00				stx 	SelectRAMBank
.1c8e					_XPMNoSwitch:
.1c8e	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1c90	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1c92					_XPMExit:
.1c92	60		rts				rts
.1c93					XPeekMemory:
.1c93	86 2c		stx $2c				stx 	zTemp0
.1c95	84 2d		sty $2d				sty 	zTemp0+1
.1c97	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c99	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c9c	e0 ff		cpx #$ff			cpx 	#$FF
.1c9e	f0 02		beq $1ca2			beq 	_XPMNoSwitch
.1ca0	86 00		stx $00				stx 	SelectRAMBank
.1ca2					_XPMNoSwitch:
.1ca2	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1ca4	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1ca6	60		rts				rts
.1ca7					CommandBank:
.1ca7	fa		plx				plx
.1ca8	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1caa	8d 6d 05	sta $056d			sta 	ramBank 					; store & make current
.1cad	85 00		sta $00				sta 	SelectRAMBank
.1caf	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1cb1	c9 ff		cmp #$ff			cmp 	#$FF
.1cb3	f0 03		beq $1cb8			beq 	_CBNoUpdate
.1cb5	8d 6e 05	sta $056e			sta 	romBank 					; this doesn't set the hardware page.
.1cb8					_CBNoUpdate:
.1cb8	a2 ff		ldx #$ff			ldx 	#$FF
.1cba	4c 38 08	jmp $0838			jmp 	NextCommand
.056d					ramBank:
>056d							.fill 	1
.056e					romBank:
>056e							.fill 	1
.1cbd					XPrintCharacterToChannel:
.1cbd	48		pha				pha
.1cbe	da		phx				phx
.1cbf	5a		phy				phy
.1cc0	48		pha				pha  								; save char
.1cc1	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1cc3	d0 05		bne $1cca			bne 	_XPCNotDefault
.1cc5	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1cc8	80 08		bra $1cd2			bra 	_XPCSend
.1cca					_XPCNotDefault:
.1cca	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1ccd	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1cd0	d0 08		bne $1cda			bne 	_XPCError
.1cd2					_XPCSend:
.1cd2	68		pla				pla 								; restore character
.1cd3	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1cd6	7a		ply				ply
.1cd7	fa		plx				plx
.1cd8	68		pla				pla
.1cd9	60		rts				rts
.1cda					_XPCError:
.1cda	4c 3b 20	jmp $203b		jmp	ErrorV_channel
.1cdd					XReadClock:
.1cdd	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1ce0	60		rts				rts
.1ce1					XWriteClock:
.1ce1	48		pha				pha
.1ce2	da		phx				phx
.1ce3	5a		phy				phy
.1ce4	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1ce7	7a		ply				ply
.1ce8	fa		plx				plx
.1ce9	68		pla				pla
.1cea	60		rts				rts
.1ceb					CommandScreen:
.1ceb	fa		plx				plx
.1cec	da		phx				phx
.1ced	5a		phy				phy
.1cee	20 30 10	jsr $1030			jsr 	GetInteger8Bit
.1cf1	18		clc				clc
.1cf2	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1cf5	7a		ply				ply
.1cf6	fa		plx				plx
.1cf7	4c 38 08	jmp $0838			jmp 	NextCommand
.1cfa					XCommandSleep:
.1cfa	fa		plx				plx
.1cfb	5a		phy				phy
.1cfc	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.1cff	ca		dex				dex
.1d00	20 dd 1c	jsr $1cdd			jsr 	XReadClock 					; read clock to YXA
.1d03	18		clc				clc 								; calculate end time in zTemp0
.1d04	65 3e		adc $3e				adc 	NSMantissa0
.1d06	85 2c		sta $2c				sta 	zTemp0
.1d08	8a		txa				txa
.1d09	65 4a		adc $4a				adc 	NSMantissa1
.1d0b	85 2d		sta $2d				sta 	zTemp0+1
.1d0d					_XCWait:
.1d0d	20 dd 1c	jsr $1cdd			jsr 	XReadClock 					; and wait for it.
.1d10	c5 2c		cmp $2c				cmp 	zTemp0
.1d12	d0 f9		bne $1d0d			bne 	_XCWait
.1d14	e4 2d		cpx $2d				cpx 	zTemp0+1
.1d16	d0 f5		bne $1d0d			bne 	_XCWait
.1d18	a2 ff		ldx #$ff			ldx 	#$FF
.1d1a	7a		ply				ply
.1d1b	4c 38 08	jmp $0838			jmp 	NextCommand
.1d1e					X16_Audio_FMINIT:
.1d1e	fa		plx				plx
.1d1f	5a		phy			phy
.1d20	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d23	63 c0					.word	X16A_ym_init
>1d25	0a					.byte	X16_AudioCodeBank
.1d26	a2 ff		ldx #$ff		ldx	#$FF
.1d28	7a		ply			ply
.1d29	4c 38 08	jmp $0838			jmp 	NextCommand
.1d2c					X16_Audio_FMNOTE:
.1d2c	fa		plx				plx
.1d2d	5a		phy			phy
.1d2e	20 f0 09	jsr $09f0		jsr		X16_Audio_Parameters8_8
.1d31	18		clc			clc
.1d32	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d35	03 c0					.word	X16A_bas_fmnote
>1d37	0a					.byte	X16_AudioCodeBank
.1d38	a2 ff		ldx #$ff		ldx	#$FF
.1d3a	7a		ply			ply
.1d3b	4c 38 08	jmp $0838			jmp 	NextCommand
.1d3e					X16_Audio_FMDRUM:
.1d3e	fa		plx				plx
.1d3f	5a		phy			phy
.1d40	20 f0 09	jsr $09f0		jsr		X16_Audio_Parameters8_8
.1d43	18		clc			clc
.1d44	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d47	6f c0					.word	X16A_ym_playdrum
>1d49	0a					.byte	X16_AudioCodeBank
.1d4a	a2 ff		ldx #$ff		ldx	#$FF
.1d4c	7a		ply			ply
.1d4d	4c 38 08	jmp $0838			jmp 	NextCommand
.1d50					X16_Audio_FMINST:
.1d50	fa		plx				plx
.1d51	5a		phy			phy
.1d52	20 f0 09	jsr $09f0		jsr		X16_Audio_Parameters8_8
.1d55	38		sec			sec
.1d56	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d59	69 c0					.word	X16A_ym_loadpatch
>1d5b	0a					.byte	X16_AudioCodeBank
.1d5c	a2 ff		ldx #$ff		ldx	#$FF
.1d5e	7a		ply			ply
.1d5f	4c 38 08	jmp $0838			jmp 	NextCommand
.1d62					X16_Audio_FMVIB:
.1d62	fa		plx				plx
.1d63	5a		phy			phy
.1d64	20 f0 09	jsr $09f0		jsr		X16_Audio_Parameters8_8
.1d67	18		clc			clc
.1d68	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d6b	09 c0					.word	X16A_bas_fmvib
>1d6d	0a					.byte	X16_AudioCodeBank
.1d6e	a2 ff		ldx #$ff		ldx	#$FF
.1d70	7a		ply			ply
.1d71	4c 38 08	jmp $0838			jmp 	NextCommand
.1d74					X16_Audio_FMFREQ:
.1d74	fa		plx				plx
.1d75	5a		phy			phy
.1d76	20 ea 09	jsr $09ea		jsr		X16_Audio_Parameters8_16
.1d79	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d7c	00 c0					.word	X16A_bas_fmfreq
>1d7e	0a					.byte	X16_AudioCodeBank
.1d7f	a2 ff		ldx #$ff		ldx	#$FF
.1d81	7a		ply			ply
.1d82	4c 38 08	jmp $0838			jmp 	NextCommand
.1d85					X16_Audio_FMVOL:
.1d85	fa		plx				plx
.1d86	5a		phy			phy
.1d87	20 f0 09	jsr $09f0		jsr		X16_Audio_Parameters8_8
.1d8a	18		clc			clc
.1d8b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d8e	75 c0					.word	X16A_ym_setatten
>1d90	0a					.byte	X16_AudioCodeBank
.1d91	a2 ff		ldx #$ff		ldx	#$FF
.1d93	7a		ply			ply
.1d94	4c 38 08	jmp $0838			jmp 	NextCommand
.1d97					X16_Audio_FMPAN:
.1d97	fa		plx				plx
.1d98	5a		phy			phy
.1d99	20 f0 09	jsr $09f0		jsr		X16_Audio_Parameters8_8
.1d9c	18		clc			clc
.1d9d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1da0	7e c0					.word	X16A_ym_setpan
>1da2	0a					.byte	X16_AudioCodeBank
.1da3	a2 ff		ldx #$ff		ldx	#$FF
.1da5	7a		ply			ply
.1da6	4c 38 08	jmp $0838			jmp 	NextCommand
.1da9					X16_Audio_FMPLAY:
.1da9	fa		plx				plx
.1daa	5a		phy			phy
.1dab	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_String
.1dae	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1db1	06 c0					.word	X16A_bas_fmplaystring
>1db3	0a					.byte	X16_AudioCodeBank
.1db4	a2 ff		ldx #$ff		ldx	#$FF
.1db6	7a		ply			ply
.1db7	4c 38 08	jmp $0838			jmp 	NextCommand
.1dba					X16_Audio_FMCHORD:
.1dba	fa		plx				plx
.1dbb	5a		phy			phy
.1dbc	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_String
.1dbf	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dc2	8d c0					.word	X16A_bas_fmchordstring
>1dc4	0a					.byte	X16_AudioCodeBank
.1dc5	a2 ff		ldx #$ff		ldx	#$FF
.1dc7	7a		ply			ply
.1dc8	4c 38 08	jmp $0838			jmp 	NextCommand
.1dcb					X16_Audio_FMPOKE:
.1dcb	fa		plx				plx
.1dcc	5a		phy			phy
.1dcd	20 f0 09	jsr $09f0		jsr		X16_Audio_Parameters8_8
.1dd0	18		clc			clc
.1dd1	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dd4	8a c0					.word	X16A_ym_write
>1dd6	0a					.byte	X16_AudioCodeBank
.1dd7	a2 ff		ldx #$ff		ldx	#$FF
.1dd9	7a		ply			ply
.1dda	4c 38 08	jmp $0838			jmp 	NextCommand
.1ddd					X16_Audio_PSGINIT:
.1ddd	fa		plx				plx
.1dde	5a		phy			phy
.1ddf	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1de2	4b c0					.word	X16A_psg_init
>1de4	0a					.byte	X16_AudioCodeBank
.1de5	a2 ff		ldx #$ff		ldx	#$FF
.1de7	7a		ply			ply
.1de8	4c 38 08	jmp $0838			jmp 	NextCommand
.1deb					X16_Audio_PSGNOTE:
.1deb	fa		plx				plx
.1dec	5a		phy			phy
.1ded	20 f0 09	jsr $09f0		jsr		X16_Audio_Parameters8_8
.1df0	18		clc			clc
.1df1	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1df4	12 c0					.word	X16A_bas_psgnote
>1df6	0a					.byte	X16_AudioCodeBank
.1df7	a2 ff		ldx #$ff		ldx	#$FF
.1df9	7a		ply			ply
.1dfa	4c 38 08	jmp $0838			jmp 	NextCommand
.1dfd					X16_Audio_PSGVOL:
.1dfd	fa		plx				plx
.1dfe	5a		phy			phy
.1dff	20 f0 09	jsr $09f0		jsr		X16_Audio_Parameters8_8
.1e02	18		clc			clc
.1e03	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e06	54 c0					.word	X16A_psg_setatten
>1e08	0a					.byte	X16_AudioCodeBank
.1e09	a2 ff		ldx #$ff		ldx	#$FF
.1e0b	7a		ply			ply
.1e0c	4c 38 08	jmp $0838			jmp 	NextCommand
.1e0f					X16_Audio_PSGWAV:
.1e0f	fa		plx				plx
.1e10	5a		phy			phy
.1e11	20 f0 09	jsr $09f0		jsr		X16_Audio_Parameters8_8
.1e14	18		clc			clc
.1e15	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e18	15 c0					.word	X16A_bas_psgwav
>1e1a	0a					.byte	X16_AudioCodeBank
.1e1b	a2 ff		ldx #$ff		ldx	#$FF
.1e1d	7a		ply			ply
.1e1e	4c 38 08	jmp $0838			jmp 	NextCommand
.1e21					X16_Audio_PSGFREQ:
.1e21	fa		plx				plx
.1e22	5a		phy			phy
.1e23	20 ea 09	jsr $09ea		jsr		X16_Audio_Parameters8_16
.1e26	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e29	0f c0					.word	X16A_bas_psgfreq
>1e2b	0a					.byte	X16_AudioCodeBank
.1e2c	a2 ff		ldx #$ff		ldx	#$FF
.1e2e	7a		ply			ply
.1e2f	4c 38 08	jmp $0838			jmp 	NextCommand
.1e32					X16_Audio_PSGPAN:
.1e32	fa		plx				plx
.1e33	5a		phy			phy
.1e34	20 f0 09	jsr $09f0		jsr		X16_Audio_Parameters8_8
.1e37	18		clc			clc
.1e38	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e3b	5a c0					.word	X16A_psg_setpan
>1e3d	0a					.byte	X16_AudioCodeBank
.1e3e	a2 ff		ldx #$ff		ldx	#$FF
.1e40	7a		ply			ply
.1e41	4c 38 08	jmp $0838			jmp 	NextCommand
.1e44					X16_Audio_PSGPLAY:
.1e44	fa		plx				plx
.1e45	5a		phy			phy
.1e46	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_String
.1e49	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e4c	18 c0					.word	X16A_bas_psgplaystring
>1e4e	0a					.byte	X16_AudioCodeBank
.1e4f	a2 ff		ldx #$ff		ldx	#$FF
.1e51	7a		ply			ply
.1e52	4c 38 08	jmp $0838			jmp 	NextCommand
.1e55					X16_Audio_PSGCHORD:
.1e55	fa		plx				plx
.1e56	5a		phy			phy
.1e57	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_String
.1e5a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e5d	90 c0					.word	X16A_bas_psgchordstring
>1e5f	0a					.byte	X16_AudioCodeBank
.1e60	a2 ff		ldx #$ff		ldx	#$FF
.1e62	7a		ply			ply
.1e63	4c 38 08	jmp $0838			jmp 	NextCommand
.1e66					CommandCls:
.1e66	fa		plx				plx
.1e67	a9 93		lda #$93			lda 	#147
.1e69	20 bd 1c	jsr $1cbd			jsr 	XPrintCharacterToChannel
.1e6c	4c 38 08	jmp $0838			jmp 	NextCommand
.1e6f					CommandLocate:
.1e6f	fa		plx				plx
.1e70	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.1e73	ca		dex				dex
.1e74	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.1e77	ca		dex				dex
.1e78	48		pha				pha 								; save registers
.1e79	da		phx				phx
.1e7a	5a		phy				phy
.1e7b	18		clc				clc
.1e7c	a4 3f		ldy $3f				ldy 	NSMantissa0+1 				; get coords
.1e7e	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e80	88		dey				dey 								; fix up
.1e81	ca		dex				dex
.1e82	20 f0 ff	jsr $fff0			jsr 	$FFF0 						; PLOT
.1e85	7a		ply				ply 								; restore registers
.1e86	fa		plx				plx
.1e87	68		pla				pla
.1e88	4c 38 08	jmp $0838			jmp 	NextCommand
.1e8b					_CLOutputXA:
.1e8b	ca		dex				dex
.1e8c	f0 07		beq $1e95			beq 	_CLOExit
.1e8e	30 05		bmi $1e95			bmi 	_CLOExit
.1e90	20 bd 1c	jsr $1cbd			jsr 	XPrintCharacterToChannel
.1e93	80 f6		bra $1e8b			bra 	_CLOutputXA
.1e95					_CLOExit:
.1e95	60		rts				rts
.1e96					CommandColor:
.1e96	fa		plx				plx
.1e97	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.1e9a	ca		dex				dex
.1e9b	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.1e9e	ca		dex				dex
.1e9f	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1ea1	c9 ff		cmp #$ff			cmp 	#$FF
.1ea3	f0 08		beq $1ead			beq 	_CCNoBGR 					; if so, change background
.1ea5	20 b5 1e	jsr $1eb5			jsr 	_CCSetColour
.1ea8	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1eaa	20 bd 1c	jsr $1cbd			jsr 	XPrintCharacterToChannel
.1ead					_CCNoBGR:
.1ead	a5 3e		lda $3e				lda 	NSMantissa0
.1eaf	20 b5 1e	jsr $1eb5			jsr 	_CCSetColour
.1eb2	4c 38 08	jmp $0838			jmp 	NextCommand
.1eb5					_CCSetColour:
.1eb5	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1eb7	aa		tax				tax
.1eb8	bd bf 1e	lda $1ebf,x			lda 	_CCCommandTable,x
.1ebb	20 bd 1c	jsr $1cbd			jsr 	XPrintCharacterToChannel
.1ebe	60		rts				rts
.1ebf					_CCCommandTable:
>1ebf	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1ec7	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1ecf					CommandVPOKE:
.1ecf	fa		plx				plx
.1ed0	20 30 10	jsr $1030			jsr 	GetInteger8Bit 				; poke value
.1ed3	48		pha				pha
.1ed4	ca		dex				dex
.1ed5	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.1ed8	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1eda	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1edd	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1edf	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ee2	ca		dex				dex
.1ee3	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.1ee6	20 30 10	jsr $1030			jsr 	GetInteger8Bit
.1ee9	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1eec	ca		dex				dex
.1eed	68		pla				pla 								; poke value back
.1eee	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1ef1	4c 38 08	jmp $0838			jmp 	NextCommand
.1ef4					CommandVPEEK:
.1ef4	fa		plx				plx
.1ef5	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.1ef8	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1efa	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1efd	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1eff	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1f02	ca		dex				dex
.1f03	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.1f06	20 30 10	jsr $1030			jsr 	GetInteger8Bit
.1f09	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1f0c	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1f0f	20 96 26	jsr $2696			jsr 	FloatSetByte 				; return as byte
.1f12	4c 38 08	jmp $0838			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ff					C64_PI                   = $ff ; $ff pi
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ceb7					C64_BANNER               = $ceb7 ; $ceb7 banner
=$ceb8					C64_EXEC                 = $ceb8 ; $ceb8 exec
=$ceb9					C64_TILE                 = $ceb9 ; $ceb9 tile
=$ceba					C64_EDIT                 = $ceba ; $ceba edit
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$cedb					C64_MWHEEL               = $cedb ; $cedb mwheel
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$cb					PCD_ENDCOMMAND = $cb
=$cb					PCD_STARTSYSTEM = $cb
=$d7					PCD_ENDSYSTEM = $d7
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_PI               = $ac ; pi
=$ad					PCD_POKE             = $ad ; poke
=$ae					PCD_POS              = $ae ; pos
=$af					PCD_GETCHANNEL       = $af ; getchannel
=$b0					PCD_SETCHANNEL       = $b0 ; setchannel
=$b1					PCD_PRINTCMD_N       = $b1 ; print.n
=$b2					PCD_PRINTCMD_S       = $b2 ; print.s
=$b3					PCD_READ             = $b3 ; read
=$b4					PCD_READDOLLAR       = $b4 ; read$
=$b5					PCD_RND              = $b5 ; rnd
=$b6					PCD_CONCAT           = $b6 ; concat
=$b7					PCD_SGN              = $b7 ; sgn
=$b8					PCD_PRINTCMD_TAB     = $b8 ; print.tab
=$b9					PCD_PRINTCMD_POS     = $b9 ; print.pos
=$ba					PCD_PRINTCMD_SPC     = $ba ; print.spc
=$bb					PCD_STRDOLLAR        = $bb ; str$
=$bc					PCD_LEFTDOLLAR       = $bc ; left$
=$bd					PCD_RIGHTDOLLAR      = $bd ; right$
=$be					PCD_MIDDOLLAR        = $be ; mid$
=$bf					PCD_SWAP             = $bf ; swap
=$c0					PCD_TI               = $c0 ; ti
=$c1					PCD_TIDOLLAR         = $c1 ; ti$
=$c2					PCD_USR              = $c2 ; usr
=$c3					PCD_VAL              = $c3 ; val
=$c4					PCD_CLOSE            = $c4 ; close
=$c5					PCD_EXIT             = $c5 ; exit
=$c6					PCD_DEBUG            = $c6 ; debug
=$c7					PCD_OPEN             = $c7 ; open
=$c8					PCD_SCREEN           = $c8 ; screen
=$c9					PCD_VPOKE            = $c9 ; vpoke
=$ca					PCD_VPEEK            = $ca ; vpeek
=$cb					PCD_CMD_SHIFT        = $cb ; .shift
=$cc					PCD_CMD_BYTE         = $cc ; .byte
=$cd					PCD_CMD_WORD         = $cd ; .word
=$ce					PCD_CMD_FLOAT        = $ce ; .float
=$cf					PCD_CMD_STRING       = $cf ; .string
=$d0					PCD_CMD_DATA         = $d0 ; .data
=$d1					PCD_CMD_GOTO         = $d1 ; .goto
=$d2					PCD_CMD_GOSUB        = $d2 ; .gosub
=$d3					PCD_CMD_GOTOCMD_Z    = $d3 ; .goto.z
=$d4					PCD_CMD_GOTOCMD_NZ   = $d4 ; .goto.nz
=$d5					PCD_CMD_VARSPACE     = $d5 ; .varspace
=$d6					PCD_CMD_RESTORE      = $d6 ; .restore
=$cb80					PCD_CLR              = $cb80 ; clr
=$cb81					PCD_DIM              = $cb81 ; dim
=$cb82					PCD_END              = $cb82 ; end
=$cb83					PCD_JOY              = $cb83 ; joy
=$cb84					PCD_INT              = $cb84 ; int
=$cb85					PCD_SQR              = $cb85 ; sqr
=$cb86					PCD_LOG              = $cb86 ; log
=$cb87					PCD_EXP              = $cb87 ; exp
=$cb88					PCD_COS              = $cb88 ; cos
=$cb89					PCD_SIN              = $cb89 ; sin
=$cb8a					PCD_TAN              = $cb8a ; tan
=$cb8b					PCD_ATN              = $cb8b ; atn
=$cb8c					PCD_MOUSE            = $cb8c ; mouse
=$cb8d					PCD_MB               = $cb8d ; mb
=$cb8e					PCD_MX               = $cb8e ; mx
=$cb8f					PCD_MY               = $cb8f ; my
=$cb90					PCD_MWHEEL           = $cb90 ; mwheel
=$cb91					PCD_STOP             = $cb91 ; stop
=$cb92					PCD_SYS              = $cb92 ; sys
=$cb93					PCD_TIDOLLARCMD_WRITE = $cb93 ; ti$.write
=$cb94					PCD_WAIT             = $cb94 ; wait
=$cb95					PCD_I2CPOKE          = $cb95 ; i2cpoke
=$cb96					PCD_I2CPEEK          = $cb96 ; i2cpeek
=$cb97					PCD_BANK             = $cb97 ; bank
=$cb98					PCD_SLEEP            = $cb98 ; sleep
=$cb99					PCD_FMINIT           = $cb99 ; fminit
=$cb9a					PCD_FMNOTE           = $cb9a ; fmnote
=$cb9b					PCD_FMDRUM           = $cb9b ; fmdrum
=$cb9c					PCD_FMINST           = $cb9c ; fminst
=$cb9d					PCD_FMVIB            = $cb9d ; fmvib
=$cb9e					PCD_FMFREQ           = $cb9e ; fmfreq
=$cb9f					PCD_FMVOL            = $cb9f ; fmvol
=$cba0					PCD_FMPAN            = $cba0 ; fmpan
=$cba1					PCD_FMPLAY           = $cba1 ; fmplay
=$cba2					PCD_FMCHORD          = $cba2 ; fmchord
=$cba3					PCD_FMPOKE           = $cba3 ; fmpoke
=$cba4					PCD_PSGINIT          = $cba4 ; psginit
=$cba5					PCD_PSGNOTE          = $cba5 ; psgnote
=$cba6					PCD_PSGVOL           = $cba6 ; psgvol
=$cba7					PCD_PSGWAV           = $cba7 ; psgwav
=$cba8					PCD_PSGFREQ          = $cba8 ; psgfreq
=$cba9					PCD_PSGPAN           = $cba9 ; psgpan
=$cbaa					PCD_PSGPLAY          = $cbaa ; psgplay
=$cbab					PCD_PSGCHORD         = $cbab ; psgchord
=$cbac					PCD_CLS              = $cbac ; cls
=$cbad					PCD_LOCATE           = $cbad ; locate
=$cbae					PCD_COLOR            = $cbae ; color
.1f15					SetErrorHandler:
.1f15	8c 70 05	sty $0570			sty 	ErrorHandlerVector+1
.1f18	8e 6f 05	stx $056f			stx 	ErrorHandlerVector
.1f1b	60		rts				rts
.1f1c					CallErrorHandler:
.1f1c	6c 6f 05	jmp ($056f)			jmp 	(ErrorHandlerVector)
.056f					ErrorHandlerVector:
>056f							.fill 	2
.1f1f					ErrorV_range:
.1f1f	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>1f22	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f2a	41 4e 47 45 00
.1f2f					ErrorV_value:
.1f2f	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>1f32	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f3a	45 00
.1f3c					ErrorV_syntax:
.1f3c	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>1f3f	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f47	52 52 4f 52 00
.1f4c					ErrorV_type:
.1f4c	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>1f4f	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f57	4d 41 54 43 48 00
.1f5d					ErrorV_unimplemented:
.1f5d	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>1f60	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f68	45 4d 45 4e 54 45 44 00
.1f70					ErrorV_assert:
.1f70	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>1f73	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f7b	41 49 4c 00
.1f7f					ErrorV_line:
.1f7f	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>1f82	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f8a	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f96					ErrorV_internal:
.1f96	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>1f99	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1fa1	20 45 52 52 4f 52 00
.1fa8					ErrorV_divzero:
.1fa8	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>1fab	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fb3	59 20 5a 45 52 4f 00
.1fba					ErrorV_structure:
.1fba	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>1fbd	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fc5	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fd1					ErrorV_stop:
.1fd1	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>1fd4	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fdc	53 54 4f 50 50 45 44 00
.1fe4					ErrorV_data:
.1fe4	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>1fe7	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fef	41 54 41 00
.1ff3					ErrorV_undeclared:
.1ff3	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>1ff6	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1ffe	41 52 52 41 59 00
.2004					ErrorV_redefine:
.2004	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>2007	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>200f	44 45 46 49 4e 45 44 00
.2017					ErrorV_index:
.2017	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>201a	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2022	59 20 49 4e 44 45 58 00
.202a					ErrorV_memory:
.202a	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>202d	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2035	45 4d 4f 52 59 00
.203b					ErrorV_channel:
.203b	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>203e	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2046	54 50 55 54 20 45 52 52 4f 52 00
.2051					ErrorV_break:
.2051	20 1c 1f	jsr $1f1c		jsr	CallErrorHandler
>2054	42 52 45 41 4b 20 50 52			.text	"BREAK PRESSED",0
>205c	45 53 53 45 44 00
.2062					MoveObjectForward:
.2062	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.2064	c9 ff		cmp #$ff			cmp 	#$FF
.2066	f0 36		beq $209e			beq 	_MOFEnd
.2068	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.206a	90 24		bcc $2090			bcc 	_MOFAdvance1 				; forward 1
.206c	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.206e	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2070	90 20		bcc $2092			bcc 	_MOFAdvanceY
.2072	c9 cb		cmp #$cb			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2074	90 1a		bcc $2090			bcc 	_MOFAdvance1 				; forward 1
.2076	a8		tay				tay 								; read the size.
.2077	b9 db 1f	lda $1fdb,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.207a	a8		tay				tay
.207b	c8		iny				iny 								; add 1 for the system token.
.207c	d0 14		bne $2092			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.207e	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2080	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2082	a8		tay				tay 								; into Y.
.2083	18		clc				clc
.2084	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.2086	69 02		adc #$02			adc 	#2
.2088	85 2a		sta $2a				sta 	objPtr
.208a	90 02		bcc $208e			bcc 	_MOFNoCarry1
.208c	e6 2b		inc $2b				inc 	objPtr+1
.208e					_MOFNoCarry1:
.208e	80 02		bra $2092			bra 	_MOFAdvanceY
.2090					_MOFAdvance1:
.2090	a0 01		ldy #$01			ldy 	#1
.2092					_MOFAdvanceY:
.2092	98		tya				tya 								; add Y to objPtr
.2093	18		clc				clc
.2094	65 2a		adc $2a				adc 	objPtr
.2096	85 2a		sta $2a				sta 	objPtr
.2098	90 02		bcc $209c			bcc 	_MOFNoCarry2
.209a	e6 2b		inc $2b				inc 	objPtr+1
.209c					_MOFNoCarry2:
.209c	18		clc				clc 								; not completed.
.209d	60		rts				rts
.209e					_MOFEnd:
.209e	e6 2a		inc $2a				inc 	objPtr
.20a0	d0 02		bne $20a4			bne 	_MOFENoCarry
.20a2	e6 2b		inc $2b				inc 	objPtr+1
.20a4					_MOFENoCarry:
.20a4	38		sec				sec
.20a5	60		rts				rts
.20a6					MOFSizeTable:
>20a6	01					.byte	1         	; $cb .shift
>20a7	01					.byte	1         	; $cc .byte
>20a8	02					.byte	2         	; $cd .word
>20a9	05					.byte	5         	; $ce .float
>20aa	ff					.byte	255       	; $cf .string
>20ab	ff					.byte	255       	; $d0 .data
>20ac	02					.byte	2         	; $d1 .goto
>20ad	02					.byte	2         	; $d2 .gosub
>20ae	02					.byte	2         	; $d3 .goto.z
>20af	02					.byte	2         	; $d4 .goto.nz
>20b0	02					.byte	2         	; $d5 .varspace
>20b1	02					.byte	2         	; $d6 .restore

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0571					numberBuffer:
>0571							.fill 	34
.20b2					FloatSubtract:
.20b2	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.20b4	49 80		eor #$80			eor 	#$80
.20b6	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.20b8					FloatAdd:
.20b8	ca		dex				dex
.20b9	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.20bb	15 6f		ora $6f,x			ora 	NSExponent+1,x
.20bd	15 62		ora $62,x			ora 	NSMantissa3,x
.20bf	15 63		ora $63,x			ora 	NSMantissa3+1,x
.20c1	d0 04		bne $20c7			bne 	_FAUseFloat
.20c3	20 54 24	jsr $2454			jsr 	FloatInt32Add 				; use the int32 one.
.20c6	60		rts				rts
.20c7					_FAUseFloat:
.20c7	20 e9 23	jsr $23e9			jsr 	FloatNormalise 				; normalise S[X]
.20ca	f0 51		beq $211d			beq 	_FAReturn1
.20cc	e8		inx				inx 								; normalise S[X+1]
.20cd	20 e9 23	jsr $23e9			jsr 	FloatNormalise
.20d0	ca		dex				dex
.20d1	c9 00		cmp #$00			cmp 	#0
.20d3	f0 60		beq $2135			beq 	_FAExit 					; if so, just return A
.20d5	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20d7	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20d9	f0 18		beq $20f3			beq 	_FAExponentsEqual
.20db	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20dd	a8		tay				tay
.20de	38		sec				sec 								; do a signed comparison of the exponents.
.20df	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20e1	50 02		bvc $20e5			bvc 	_FANoSignedChange
.20e3	49 80		eor #$80			eor 	#$80
.20e5					_FANoSignedChange:
.20e5	29 80		and #$80			and 	#$80
.20e7	10 02		bpl $20eb			bpl 	_FAHaveMax
.20e9	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.20eb					_FAHaveMax:
.20eb	20 36 21	jsr $2136			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20ee	e8		inx				inx
.20ef	20 36 21	jsr $2136			jsr 	_FAShiftToExponent
.20f2	ca		dex				dex
.20f3					_FAExponentsEqual:
.20f3	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.20f5	55 33		eor $33,x			eor 	NSStatus+1,x
.20f7	30 0e		bmi $2107			bmi 	_FADifferentSigns
.20f9	20 20 24	jsr $2420			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20fc	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20fe	10 35		bpl $2135			bpl 	_FAExit 					; if no, we are done.
.2100	20 ad 26	jsr $26ad			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.2103	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.2105	80 2e		bra $2135			bra 	_FAExit
.2107					_FADifferentSigns:
.2107	20 3a 24	jsr $243a			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.210a	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.210c	10 06		bpl $2114			bpl 	_FACheckZero 				; if no, check for -0
.210e	20 56 26	jsr $2656			jsr 	FloatNegate 					; netate result
.2111	20 5d 26	jsr $265d			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.2114					_FACheckZero:
.2114	20 b6 26	jsr $26b6			jsr 	FloatIsZero	 				; check for -0
.2117	d0 1c		bne $2135			bne 	_FAExit
.2119	74 32		stz $32,x			stz 	NSStatus,x
.211b	80 18		bra $2135			bra 	_FAExit
.211d					_FAReturn1:
.211d	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.211f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2121	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2123	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2125	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.2127	95 56		sta $56,x			sta 	NSMantissa2,x
.2129	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.212b	95 62		sta $62,x			sta 	NSMantissa3,x
.212d	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.212f	95 6e		sta $6e,x			sta 	NSExponent,x
.2131	b5 33		lda $33,x			lda 	NSStatus+1,x
.2133	95 32		sta $32,x			sta 	NSStatus,x
.2135					_FAExit:
.2135	60		rts				rts
.2136					_FAShiftToExponent:
.2136					_FAShiftToExponent2:
.2136	98		tya				tya 								; compare Y to exponent
.2137	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2139	f0 07		beq $2142			beq 	_FASEExit 					; exit if so.
.213b	20 ad 26	jsr $26ad			jsr 	FloatShiftRight	 			; shift the mantissa right
.213e	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.2140	80 f4		bra $2136			bra 	_FAShiftToExponent2
.2142					_FASEExit:
.2142	60		rts				rts
.2143					CompareEqual:
.2143	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2145	d0 09		bne $2150			bne 	ReturnFalse
.2147					ReturnTrue:
.2147	a9 01		lda #$01			lda 	#1
.2149	95 3e		sta $3e,x			sta 	NSMantissa0,x
.214b	a9 80		lda #$80			lda 	#$80
.214d	95 32		sta $32,x			sta 	NSStatus,x
.214f	60		rts				rts
.2150					ReturnFalse:
.2150	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2152	60		rts				rts
.2153					CompareNotEqual:
.2153	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2155	d0 f0		bne $2147			bne 	ReturnTrue
.2157	80 f7		bra $2150			bra 	ReturnFalse
.2159					CompareLess:
.2159	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.215b	c9 ff		cmp #$ff			cmp 	#$FF
.215d	f0 e8		beq $2147			beq 	ReturnTrue
.215f	80 ef		bra $2150			bra 	ReturnFalse
.2161					CompareGreater:
.2161	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2163	c9 01		cmp #$01			cmp 	#$01
.2165	f0 e0		beq $2147			beq 	ReturnTrue
.2167	80 e7		bra $2150			bra 	ReturnFalse
.2169					CompareLessEqual:
.2169	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.216b	c9 01		cmp #$01			cmp 	#$01
.216d	d0 d8		bne $2147			bne 	ReturnTrue
.216f	80 df		bra $2150			bra 	ReturnFalse
.2171					CompareGreaterEqual:
.2171	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2173	c9 ff		cmp #$ff			cmp 	#$FF
.2175	d0 d0		bne $2147			bne 	ReturnTrue
.2177	80 d7		bra $2150			bra 	ReturnFalse
.2179					FloatCompare:
.2179	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.217b	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.217d	48		pha				pha
.217e	20 b2 20	jsr $20b2			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2181	68		pla				pla
.2182	d0 0c		bne $2190			bne 	_FCCompareFloat
.2184	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2186	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2188	15 56		ora $56,x			ora 	NSMantissa2,x
.218a	15 62		ora $62,x			ora 	NSMantissa3,x
.218c	f0 14		beq $21a2			beq 	_FCExit 					; if zero, return zero
.218e	80 0a		bra $219a			bra 	_FCSign
.2190					_FCCompareFloat:
.2190	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2192	29 f0		and #$f0			and 	#$F0
.2194	15 56		ora $56,x			ora 	NSMantissa2,x
.2196	15 62		ora $62,x			ora 	NSMantissa3,x
.2198	f0 08		beq $21a2			beq 	_FCExit 					; zero, so approximately identical
.219a					_FCSign:
.219a	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.219c	34 32		bit $32,x			bit 	NSStatus,x
.219e	10 02		bpl $21a2			bpl 	_FCExit
.21a0					_FCNegative:
.21a0	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.21a2					_FCExit:
.21a2	20 96 26	jsr $2696			jsr 	FloatSetByte 				; set the result 255,0,1
.21a5	60		rts				rts
.21a6					FloatScalarTable:
>21a6	66 66 66 66				.dword $66666666 ; 0.1
>21aa	de					.byte $de
>21ab	1f 85 eb 51				.dword $51eb851f ; 0.01
>21af	db					.byte $db
>21b0	4c 37 89 41				.dword $4189374c ; 0.001
>21b4	d8					.byte $d8
>21b5	ac 8b db 68				.dword $68db8bac ; 0.0001
>21b9	d4					.byte $d4
>21ba	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>21be	d1					.byte $d1
>21bf	83 de 1b 43				.dword $431bde83 ; 1e-06
>21c3	ce					.byte $ce
>21c4	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21c8	ca					.byte $ca
>21c9	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21cd	c7					.byte $c7
>21ce	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21d2	c4					.byte $c4
>21d3	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21d7	c0					.byte $c0
>21d8	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21dc	bd					.byte $bd
.21dd					FloatDivide:
.21dd	48		pha				pha
.21de	20 e9 23	jsr $23e9			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21e1	ca		dex				dex
.21e2	c9 00		cmp #$00			cmp 	#0
.21e4	f0 1e		beq $2204			beq 	_FDZero
.21e6	20 e9 23	jsr $23e9			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21e9	f0 16		beq $2201			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21eb	20 4c 22	jsr $224c			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21ee	20 19 22	jsr $2219			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21f1	20 e9 23	jsr $23e9			jsr		FloatNormalise 				; renormalise
.21f4	20 df 23	jsr $23df			jsr 	FloatCalculateSign 			; calculate result sign
.21f7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.21f9	38		sec				sec
.21fa	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.21fc	38		sec				sec
.21fd	e9 1e		sbc #$1e			sbc 	#30
.21ff	95 6e		sta $6e,x			sta 	NSExponent,x
.2201					_FDExit:
.2201	68		pla				pla
.2202	18		clc				clc
.2203	60		rts				rts
.2204					_FDZero:
.2204	68		pla				pla
.2205	38		sec				sec
.2206	60		rts				rts
.2207					DivideInt32:
.2207	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart 			; make both integers
.220a	ca		dex				dex
.220b	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.220e	20 2a 22	jsr $222a			jsr 	Int32Divide 				; divide
.2211	20 19 22	jsr $2219			jsr 	NSMCopyPlusTwoToZero 		; copy result
.2214	20 df 23	jsr $23df			jsr 	FloatCalculateSign 			; calculate result sign
.2217	18		clc				clc
.2218	60		rts				rts
.2219					NSMCopyPlusTwoToZero:
.2219	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.221b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.221d	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.221f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2221	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.2223	95 56		sta $56,x			sta 	NSMantissa2,x
.2225	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.2227	95 62		sta $62,x			sta 	NSMantissa3,x
.2229	60		rts				rts
.222a					Int32Divide:
.222a	48		pha				pha 								; save AXY
.222b	5a		phy				phy
.222c	20 77 26	jsr $2677			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.222f	20 90 26	jsr $2690			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2232	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2234					_I32DivideLoop:
.2234	e8		inx				inx
.2235	e8		inx				inx
.2236	20 a3 26	jsr $26a3			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2239	ca		dex				dex
.223a	ca		dex				dex
.223b	20 a4 26	jsr $26a4			jsr 	FloatRotateLeft
.223e	20 6a 22	jsr $226a			jsr 	FloatDivideCheck 			; check if subtract possible
.2241	90 02		bcc $2245			bcc 	_I32DivideNoCarryIn
.2243	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2245					_I32DivideNoCarryIn:
.2245	88		dey				dey 								; loop round till division completed.
.2246	d0 ec		bne $2234			bne 	_I32DivideLoop
.2248	7a		ply				ply 								; restore AXY and exit
.2249	68		pla				pla
.224a	18		clc				clc
.224b	60		rts				rts
.224c					Int32ShiftDivide:
.224c	48		pha				pha 								; save AY
.224d	5a		phy				phy
.224e	e8		inx				inx 								; clear S[X+2]
.224f	e8		inx				inx
.2250	20 94 26	jsr $2694			jsr 	FloatSetZero
.2253	ca		dex				dex
.2254	ca		dex				dex
.2255	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2257					_I32SDLoop:
.2257	20 6a 22	jsr $226a			jsr 	FloatDivideCheck 			; check if subtract possible
.225a	e8		inx				inx
.225b	e8		inx				inx
.225c	20 a4 26	jsr $26a4			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.225f	ca		dex				dex
.2260	ca		dex				dex
.2261	20 a4 26	jsr $26a4			jsr 	FloatRotateLeft
.2264	88		dey				dey 	 							; do 31 times
.2265	d0 f0		bne $2257			bne 	_I32SDLoop
.2267	7a		ply				ply 								; restore AY and exit
.2268	68		pla				pla
.2269	60		rts				rts
.226a					FloatDivideCheck:
.226a	20 3a 24	jsr $243a			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.226d	b0 04		bcs $2273			bcs 	_DCSExit 					; if carry set, then could do, exit
.226f	20 20 24	jsr $2420			jsr 	FloatAddTopTwoStack 		; add it back in
.2272	18		clc				clc 								; and return False
.2273					_DCSExit:
.2273	60		rts				rts
.2274					FloatFractionalPart:
.2274	5a		phy				phy
.2275	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.2277	29 7f		and #$7f			and 	#$7F
.2279	95 32		sta $32,x			sta 	NSStatus,x
.227b	20 e9 23	jsr $23e9			jsr 	FloatNormalise
.227e	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2280	38		sec				sec
.2281	e9 e0		sbc #$e0			sbc 	#$E0
.2283	90 29		bcc $22ae			bcc 	_FFPExit 					; already fractional
.2285	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2287	b0 22		bcs $22ab			bcs 	_FFPZero
.2289	a8		tay				tay 								; put count to do in Y
.228a	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.228c	20 b3 22	jsr $22b3			jsr 	_FFPPartial
.228f	95 62		sta $62,x			sta 	NSMantissa3,x
.2291	b5 56		lda $56,x			lda 	NSMantissa2,x
.2293	20 b3 22	jsr $22b3			jsr 	_FFPPartial
.2296	95 56		sta $56,x			sta 	NSMantissa2,x
.2298	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.229a	20 b3 22	jsr $22b3			jsr 	_FFPPartial
.229d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.229f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.22a1	20 b3 22	jsr $22b3			jsr 	_FFPPartial
.22a4	95 3e		sta $3e,x			sta 	NSMantissa0,x
.22a6	20 b6 26	jsr $26b6			jsr 	FloatIsZero 					; zeroed check.
.22a9	d0 03		bne $22ae			bne 	_FFPExit
.22ab					_FFPZero:
.22ab	20 94 26	jsr $2694			jsr 	FloatSetZero
.22ae					_FFPExit:
.22ae	20 e9 23	jsr $23e9			jsr 	FloatNormalise
.22b1	7a		ply				ply
.22b2	60		rts				rts
.22b3					_FFPPartial:
.22b3	c0 00		cpy #$00			cpy 	#0 							; no more to do
.22b5	f0 17		beq $22ce			beq 	_FFFPPExit
.22b7	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.22b9	b0 0c		bcs $22c7			bcs 	_FFFPPWholeByte
.22bb	5a		phy				phy
.22bc					_FFFPPLeft:
.22bc	0a		asl a				asl 	a
.22bd	88		dey				dey
.22be	d0 fc		bne $22bc			bne 	_FFFPPLeft
.22c0	7a		ply				ply
.22c1					_FFFPPRight:
.22c1	4a		lsr a				lsr 	a
.22c2	88		dey				dey
.22c3	d0 fc		bne $22c1			bne 	_FFFPPRight
.22c5	80 07		bra $22ce			bra 	_FFFPPExit
.22c7					_FFFPPWholeByte:
.22c7	98		tya				tya 								; subtract 8 from count
.22c8	38		sec				sec
.22c9	e9 08		sbc #$08			sbc 	#8
.22cb	a8		tay				tay
.22cc	a9 00		lda #$00			lda 	#0 							; and clear all
.22ce					_FFFPPExit:
.22ce	60		rts				rts
.22cf					FloatIntegerPart:
.22cf	48		pha				pha
.22d0	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22d2	f0 1d		beq $22f1			beq 	_FIPExit 					; if so do nothing
.22d4	20 b6 26	jsr $26b6			jsr 	FloatIsZero 				; is it zero ?
.22d7	f0 15		beq $22ee			beq 	_FIPZero 					; if so return zero.
.22d9	20 e9 23	jsr $23e9			jsr 	FloatNormalise 				; normalise
.22dc	f0 10		beq $22ee			beq 	_FIPZero 					; normalised to zero, exit zero
.22de					_FIPShift:
.22de	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22e0	10 07		bpl $22e9			bpl 	_FIPCheckZero
.22e2	20 ad 26	jsr $26ad			jsr 	FloatShiftRight 			; shift mantissa right
.22e5	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22e7	80 f5		bra $22de			bra 	_FIPShift
.22e9					_FIPCheckZero:
.22e9	20 b6 26	jsr $26b6			jsr 	FloatIsZero 				; avoid -0 problem
.22ec	d0 03		bne $22f1			bne 	_FIPExit 					; set to zero if mantissa zero.
.22ee					_FIPZero:
.22ee	20 94 26	jsr $2694			jsr 	FloatSetZero
.22f1					_FIPExit:
.22f1	68		pla				pla
.22f2	60		rts				rts
.22f3					FloatIntegerPartDown:
.22f3	48		pha				pha
.22f4	5a		phy				phy
.22f5	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22f7	f0 36		beq $232f			beq 	_FIPExit 					; if so do nothing
.22f9	20 b6 26	jsr $26b6			jsr 	FloatIsZero 				; is it zero ?
.22fc	f0 2e		beq $232c			beq 	_FIPZero 					; if so return zero.
.22fe	20 e9 23	jsr $23e9			jsr 	FloatNormalise 				; normalise
.2301	f0 29		beq $232c			beq 	_FIPZero 					; normalised to zero, exit zero
.2303	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.2305					_FIPShift:
.2305	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2307	10 0a		bpl $2313			bpl 	_FIPCheckDown
.2309	20 ad 26	jsr $26ad			jsr 	FloatShiftRight 			; shift mantissa right
.230c	90 01		bcc $230f			bcc 	_FIPNoFrac 					; shifted a zero out ?
.230e	c8		iny				iny
.230f					_FIPNoFrac:
.230f	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.2311	80 f2		bra $2305			bra 	_FIPShift
.2313					_FIPCheckDown:
.2313	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.2315	f0 10		beq $2327			beq 	_FIPCheckZero
.2317	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.2319	10 0c		bpl $2327			bpl 	_FIPCheckZero
.231b	e8		inx				inx 								; -ve so round *down*.
.231c	a9 01		lda #$01			lda 	#1
.231e	20 96 26	jsr $2696			jsr 	FloatSetByte
.2321	20 56 26	jsr $2656			jsr 	FloatNegate
.2324	20 b8 20	jsr $20b8			jsr 	FloatAdd
.2327					_FIPCheckZero:
.2327	20 b6 26	jsr $26b6			jsr 	FloatIsZero 				; avoid -0 problem
.232a	d0 03		bne $232f			bne 	_FIPExit 					; set to zero if mantissa zero.
.232c					_FIPZero:
.232c	20 94 26	jsr $2694			jsr 	FloatSetZero
.232f					_FIPExit:
.232f	7a		ply				ply
.2330	68		pla				pla
.2331	60		rts				rts
.2332					FloatInt8Multiply:
.2332	5a		phy				phy
.2333	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2335	a8		tay				tay
.2336	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2338					_FI8MLoop:
.2338	98		tya				tya 								; shift right shifter right into carry
.2339	4a		lsr a				lsr 	a
.233a	a8		tay				tay
.233b	90 0d		bcc $234a			bcc 	_FI8MNoAdd
.233d	18		clc				clc
.233e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2340	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.2342	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2344	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2346	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.2348	95 4a		sta $4a,x			sta 	NSMantissa1,x
.234a					_FI8MNoAdd:
.234a	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.234c	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.234e	c0 00		cpy #$00			cpy 	#0
.2350	d0 e6		bne $2338			bne 	_FI8MLoop 					; until right shifter zero.
.2352	7a		ply				ply
.2353	60		rts				rts
.2354					FloatMultiply:
.2354	ca		dex				dex
.2355	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.2357	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2359	15 62		ora $62,x			ora 	NSMantissa3,x
.235b	15 63		ora $63,x			ora 	NSMantissa3+1,x
.235d	d0 21		bne $2380			bne 	_FMUseFloat
.235f	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2361	15 33		ora $33,x			ora 	NSStatus+1,x
.2363	29 80		and #$80			and 	#$80
.2365	15 62		ora $62,x			ora 	NSMantissa3,x
.2367	15 56		ora $56,x			ora 	NSMantissa2,x
.2369	15 4a		ora $4a,x			ora 	NSMantissa1,x
.236b	15 63		ora $63,x			ora 	NSMantissa3+1,x
.236d	15 57		ora $57,x			ora 	NSMantissa2+1,x
.236f	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2371	d0 04		bne $2377			bne 	_FMInt32
.2373	20 32 23	jsr $2332			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2376	60		rts				rts
.2377					_FMInt32:
.2377	20 a1 23	jsr $23a1			jsr 	FloatMultiplyShort			; use the int32 one.
.237a	18		clc				clc 								; fix it up if gone out of range
.237b	75 6e		adc $6e,x			adc 	NSExponent,x
.237d	95 6e		sta $6e,x			sta 	NSExponent,x
.237f	60		rts				rts
.2380					_FMUseFloat:
.2380	20 e9 23	jsr $23e9			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2383	f0 18		beq $239d			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2385	e8		inx				inx
.2386	20 e9 23	jsr $23e9			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2389	ca		dex				dex
.238a	c9 00		cmp #$00			cmp 	#0
.238c	f0 0c		beq $239a			beq 	_FDSetZero
.238e	20 a1 23	jsr $23a1			jsr 	FloatMultiplyShort 			; calculate the result.
.2391	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2393	18		clc				clc
.2394	75 6f		adc $6f,x			adc 	NSExponent+1,x
.2396	95 6e		sta $6e,x			sta 	NSExponent,x
.2398	80 03		bra $239d			bra 	_FDExit
.239a					_FDSetZero:
.239a	20 94 26	jsr $2694			jsr 	FloatSetZero 				; return 0
.239d					_FDExit:
.239d	20 e9 23	jsr $23e9			jsr 	FloatNormalise 				; normalise the result
.23a0	60		rts				rts
.23a1					FloatMultiplyShort:
.23a1	5a		phy				phy 								; save Y
.23a2	20 77 26	jsr $2677			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.23a5	20 90 26	jsr $2690			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.23a8	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.23aa					_I32MLoop:
.23aa	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.23ac	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.23ae	15 58		ora $58,x			ora 	NSMantissa2+2,x
.23b0	15 64		ora $64,x			ora 	NSMantissa3+2,x
.23b2	f0 25		beq $23d9			beq 	_I32MExit 					; exit if zero
.23b4	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.23b6	29 01		and #$01			and 	#1
.23b8	f0 0d		beq $23c7			beq 	_I32MNoAdd
.23ba	20 20 24	jsr $2420			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.23bd	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.23bf	10 06		bpl $23c7			bpl 	_I32MNoAdd
.23c1					_I32ShiftRight:
.23c1	20 ad 26	jsr $26ad			jsr 	FloatShiftRight 			; shift S[X] right
.23c4	c8		iny				iny 								; increment shift count
.23c5	80 09		bra $23d0			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23c7					_I32MNoAdd:
.23c7	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23c9	70 f6		bvs $23c1			bvs 	_I32ShiftRight 				; instead.
.23cb	e8		inx				inx
.23cc	20 a3 26	jsr $26a3			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23cf	ca		dex				dex
.23d0					_I32MShiftUpper:
.23d0	e8		inx				inx 								; shift S[X+2] right
.23d1	e8		inx				inx
.23d2	20 ad 26	jsr $26ad			jsr 	FloatShiftRight
.23d5	ca		dex				dex
.23d6	ca		dex				dex
.23d7	80 d1		bra $23aa			bra 	_I32MLoop 					; try again.
.23d9					_I32MExit:
.23d9	20 df 23	jsr $23df			jsr 	FloatCalculateSign
.23dc	98		tya				tya 								; shift in A
.23dd	7a		ply				ply 								; restore Y and exit
.23de	60		rts				rts
.23df					FloatCalculateSign:
.23df	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23e1	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23e3	55 33		eor $33,x			eor 	NSStatus+1,x
.23e5	0a		asl a				asl 	a 							; shift bit 7 into carry
.23e6	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23e8	60		rts				rts
.23e9					FloatNormalise:
.23e9	20 b6 26	jsr $26b6			jsr 	FloatIsZero 				; if zero exit
.23ec	d0 07		bne $23f5			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23ee	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.23f0	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.23f2	a9 00		lda #$00			lda 	#0 							; set Z flag
.23f4	60		rts				rts
.23f5					_NSNormaliseOptimise:
.23f5	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23f7	d0 19		bne $2412			bne 	_NSNormaliseLoop
.23f9	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.23fb	30 15		bmi $2412			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23fd	95 62		sta $62,x			sta 	NSMantissa3,x
.23ff	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2401	95 56		sta $56,x			sta 	NSMantissa2,x
.2403	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2405	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2407	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2409	b5 6e		lda $6e,x			lda 	NSExponent,x
.240b	38		sec				sec
.240c	e9 08		sbc #$08			sbc 	#8
.240e	95 6e		sta $6e,x			sta 	NSExponent,x
.2410	80 e3		bra $23f5			bra 	_NSNormaliseOptimise
.2412					_NSNormaliseLoop:
.2412	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.2414	70 07		bvs $241d			bvs 	_NSNExit 					; exit if so with Z flag clear
.2416	20 a3 26	jsr $26a3			jsr 	FloatShiftLeft 				; shift mantissa left
.2419	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.241b	80 f5		bra $2412			bra 	_NSNormaliseLoop
.241d					_NSNExit:
.241d	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.241f	60		rts				rts
.2420					FloatAddTopTwoStack:
.2420	18		clc				clc
.2421	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2423	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.2425	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2427	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2429	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.242b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.242d	b5 56		lda $56,x			lda		NSMantissa2,x
.242f	75 57		adc $57,x			adc 		NSMantissa2+1,x
.2431	95 56		sta $56,x			sta 	NSMantissa2,x
.2433	b5 62		lda $62,x			lda		NSMantissa3,x
.2435	75 63		adc $63,x			adc 		NSMantissa3+1,x
.2437	95 62		sta $62,x			sta 	NSMantissa3,x
.2439	60		rts				rts
.243a					FloatSubTopTwoStack:
.243a	38		sec				sec
.243b	b5 3e		lda $3e,x			lda		NSMantissa0,x
.243d	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.243f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2441	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2443	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.2445	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2447	b5 56		lda $56,x			lda		NSMantissa2,x
.2449	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.244b	95 56		sta $56,x			sta 	NSMantissa2,x
.244d	b5 62		lda $62,x			lda		NSMantissa3,x
.244f	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.2451	95 62		sta $62,x			sta 	NSMantissa3,x
.2453	60		rts				rts
.2454					FloatInt32Add:
.2454	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2456	55 33		eor $33,x			eor 	NSStatus+1,x
.2458	30 04		bmi $245e			bmi 	_DiffSigns
.245a	20 20 24	jsr $2420			jsr		FloatAddTopTwoStack
.245d	60		rts				rts
.245e					_DiffSigns:
.245e	20 3a 24	jsr $243a			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2461	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2463	10 07		bpl $246c			bpl 	_AddExit
.2465	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2467	95 32		sta $32,x			sta 	NSStatus,x
.2469	20 5d 26	jsr $265d			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.246c					_AddExit:
.246c	20 b6 26	jsr $26b6			jsr 	FloatIsZero 				; check for -0
.246f	d0 02		bne $2473			bne 	_AddNonZero
.2471	74 32		stz $32,x			stz 	NSStatus,x
.2473					_AddNonZero:
.2473	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2474					FloatEncodeStart:
.2474	38		sec				sec
.2475	80 01		bra $2478			bra 	FloatEncodeContinue+1
.2477					FloatEncodeContinue:
.2477	18		clc				clc
.2478					FloatEncode:
.2478	08		php				php 								; save reset flag.
.2479	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.247b	f0 15		beq $2492			beq 	_ENIsOkay
.247d	c9 30		cmp #$30			cmp 	#"0"
.247f	90 04		bcc $2485			bcc 	_ENBadNumber
.2481	c9 3a		cmp #$3a			cmp 	#"9"+1
.2483	90 0d		bcc $2492			bcc 	_ENIsOkay
.2485					_ENBadNumber:
.2485	28		plp				plp 								; throw saved reset
.2486	ad 93 05	lda $0593			lda 	encodeState 				; if in decimal mode, construct final number
.2489	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.248b	d0 03		bne $2490			bne 	_ENFail
.248d	4c 0a 25	jmp $250a			jmp 	_ENConstructFinal
.2490					_ENFail:
.2490	18		clc				clc 								; not allowed
.2491	60		rts				rts
.2492					_ENIsOkay:
.2492	28		plp				plp 								; are we restarting
.2493	90 15		bcc $24aa			bcc 	_ENNoRestart
.2495					_ENStartEncode:
.2495	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2497	f0 0c		beq $24a5			beq 	_ENFirstDP
.2499	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.249b	20 96 26	jsr $2696			jsr 	FloatSetByte 				; in single byte mode.
.249e	a9 01		lda #$01			lda 	#ESTA_Low
.24a0					_ENExitChange:
.24a0	8d 93 05	sta $0593			sta 	encodeState 				; save new state
.24a3	38		sec				sec
.24a4	60		rts				rts
.24a5					_ENFirstDP:
.24a5	20 94 26	jsr $2694			jsr 	FloatSetZero 				; clear integer part
.24a8	80 3c		bra $24e6			bra 	_ESTASwitchFloat			; go straight to float and exi
.24aa					_ENNoRestart:
.24aa	48		pha				pha 								; save digit or DP on stack.
.24ab	ad 93 05	lda $0593			lda 	encodeState 				; get current state
.24ae	c9 01		cmp #$01			cmp 	#ESTA_Low
.24b0	f0 09		beq $24bb			beq  	_ESTALowState
.24b2	c9 02		cmp #$02			cmp 	#ESTA_High
.24b4	f0 26		beq $24dc			beq 	_ESTAHighState
.24b6	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.24b8	f0 38		beq $24f2			beq 	_ESTADecimalState
>24ba	db						.byte 	$DB 						; causes a break in the emulator
.24bb					_ESTALowState:
.24bb	68		pla				pla 								; get value back
.24bc	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.24be	f0 26		beq $24e6			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24c0	29 0f		and #$0f			and 	#15 						; make digit
.24c2	8d 94 05	sta $0594			sta 	digitTemp 					; save it.
.24c5	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24c7	0a		asl a				asl 	a
.24c8	0a		asl a				asl 	a
.24c9	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24cb	0a		asl a				asl 	a
.24cc	6d 94 05	adc $0594			adc 	digitTemp
.24cf	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24d1	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24d3	90 05		bcc $24da			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24d5	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24d7	8d 93 05	sta $0593			sta 	encodeState
.24da					_ESTANoSwitch:
.24da	38		sec				sec
.24db	60		rts				rts
.24dc					_ESTAHighState:
.24dc	68		pla				pla 								; get value back
.24dd	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24df	f0 05		beq $24e6			beq 	_ESTASwitchFloat
.24e1	20 3c 25	jsr $253c			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24e4	38		sec				sec
.24e5	60		rts				rts
.24e6					_ESTASwitchFloat:
.24e6	9c 95 05	stz $0595			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24e9	e8		inx				inx 								; zero the decimal additive.
.24ea	20 94 26	jsr $2694			jsr 	FloatSetZero
.24ed	ca		dex				dex
.24ee	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24f0	80 ae		bra $24a0			bra 	_ENExitChange
.24f2					_ESTADecimalState:
.24f2	68		pla				pla 								; digit.
.24f3	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24f5	f0 99		beq $2490			beq 	_ENFail
.24f7	e8		inx				inx 								; put digit into fractional part of X+1
.24f8	20 3c 25	jsr $253c			jsr 	ESTAShiftDigitIntoMantissa
.24fb	ca		dex				dex
.24fc	ee 95 05	inc $0595			inc 	decimalCount 				; bump the count of decimals
.24ff	ad 95 05	lda $0595			lda 	decimalCount 				; too many decimal digits.
.2502	c9 0b		cmp #$0b			cmp 	#11
.2504	f0 02		beq $2508			beq 	_ESTADSFail
.2506	38		sec				sec
.2507	60		rts				rts
.2508					_ESTADSFail:
.2508	18		clc				clc
.2509	60		rts				rts
.250a					_ENConstructFinal:
.250a	ad 95 05	lda $0595			lda 	decimalCount 				; get decimal count
.250d	f0 2b		beq $253a			beq 	_ENCFExit 					; no decimals
.250f	5a		phy				phy
.2510	0a		asl a				asl 	a 							; x 4 and CLC
.2511	0a		asl a				asl 	a
.2512	6d 95 05	adc $0595			adc 	decimalCount
.2515	a8		tay				tay
.2516	b9 a1 21	lda $21a1,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.2519	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.251b	b9 a2 21	lda $21a2,y			lda 	FloatScalarTable-5+1,y
.251e	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2520	b9 a3 21	lda $21a3,y			lda 	FloatScalarTable-5+2,y
.2523	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2525	b9 a4 21	lda $21a4,y			lda 	FloatScalarTable-5+3,y
.2528	95 64		sta $64,x			sta 	NSMantissa3+2,x
.252a	b9 a5 21	lda $21a5,y			lda 	FloatScalarTable-5+4,y
.252d	95 70		sta $70,x			sta 	NSExponent+2,x
.252f	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.2531	e8		inx				inx 								; multiply decimal const by decimal scalar
.2532	e8		inx				inx
.2533	20 54 23	jsr $2354			jsr 	FloatMultiply
.2536	20 b8 20	jsr $20b8			jsr 	FloatAdd 					; add to integer part.
.2539	7a		ply				ply
.253a					_ENCFExit:
.253a	18		clc				clc 								; reject the digit.
.253b	60		rts				rts
.253c					ESTAShiftDigitIntoMantissa:
.253c	29 0f		and #$0f			and 	#15 						; save digit
.253e	48		pha				pha
.253f	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2541	48		pha				pha
.2542	b5 56		lda $56,x			lda 	NSMantissa2,x
.2544	48		pha				pha
.2545	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2547	48		pha				pha
.2548	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.254a	48		pha				pha
.254b	20 a3 26	jsr $26a3			jsr 	FloatShiftLeft 				; x 2
.254e	20 a3 26	jsr $26a3			jsr 	FloatShiftLeft 				; x 4
.2551	18		clc				clc 								; pop mantissa and add
.2552	68		pla				pla
.2553	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2555	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2557	68		pla				pla
.2558	75 4a		adc $4a,x			adc 	NSMantissa1,x
.255a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.255c	68		pla				pla
.255d	75 56		adc $56,x			adc 	NSMantissa2,x
.255f	95 56		sta $56,x			sta 	NSMantissa2,x
.2561	68		pla				pla
.2562	75 62		adc $62,x			adc 	NSMantissa3,x
.2564	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.2566	20 a3 26	jsr $26a3			jsr 	FloatShiftLeft 				; x 10
.2569	68		pla				pla 								; add digit
.256a	18		clc				clc
.256b	75 3e		adc $3e,x			adc 	NSMantissa0,x
.256d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.256f	90 0a		bcc $257b			bcc 	_ESTASDExit
.2571	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2573	d0 06		bne $257b			bne 	_ESTASDExit
.2575	f6 56		inc $56,x			inc 	NSMantissa2,x
.2577	d0 02		bne $257b			bne 	_ESTASDExit
.2579	f6 62		inc $62,x			inc 	NSMantissa3,x
.257b					_ESTASDExit:
.257b	60		rts				rts
.0593					encodeState:
>0593							.fill 	1
.0594					digitTemp:
>0594							.fill 	1
.0595					decimalCount:
>0595							.fill 	1
.257c					FloatToString:
.257c	da		phx				phx
.257d	5a		phy				phy 								; save code position
.257e	8d 96 05	sta $0596			sta 	decimalPlaces	 			; save number of DPs.
.2581	9c 97 05	stz $0597			stz 	dbOffset 					; offset into decimal buffer = start.
.2584	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.2586	10 08		bpl $2590			bpl 	_CNTSNotNegative
.2588	29 7f		and #$7f			and 	#$7F 						; make +ve
.258a	95 32		sta $32,x			sta 	NSStatus,x
.258c	a9 2d		lda #$2d			lda 	#"-"
.258e	80 02		bra $2592			bra 	_CNTMain
.2590					_CNTSNotNegative:
.2590	a9 20		lda #$20			lda 	#" "
.2592					_CNTMain:
.2592	20 f4 25	jsr $25f4			jsr 	WriteDecimalBuffer
.2595	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.2597	f0 0d		beq $25a6			beq 	_CNTSNotFloat
.2599	e8		inx				inx 								; round up so we don't get too many 6.999999
.259a	a9 01		lda #$01			lda 	#1
.259c	20 96 26	jsr $2696			jsr 	FloatSetByte
.259f	b5 6d		lda $6d,x			lda		NSExponent-1,x
.25a1	95 6e		sta $6e,x			sta 	NSExponent,x
.25a3	20 b8 20	jsr $20b8			jsr 	FloatAdd
.25a6					_CNTSNotFloat:
.25a6	20 d6 25	jsr $25d6			jsr 	MakePlusTwoString 			; do the integer part.
.25a9	20 74 22	jsr $2274			jsr 	FloatFractionalPart 		; get the fractional part
.25ac	20 e9 23	jsr $23e9			jsr 	FloatNormalise					; normalise , exit if zero
.25af	f0 22		beq $25d3			beq 	_CNTSExit
.25b1	a9 2e		lda #$2e			lda 	#"."
.25b3	20 f4 25	jsr $25f4			jsr 	WriteDecimalBuffer 			; write decimal place
.25b6					_CNTSDecimal:
.25b6	ce 96 05	dec $0596			dec 	decimalPlaces 				; done all the decimals
.25b9	30 18		bmi $25d3			bmi 	_CNTSExit
.25bb	e8		inx				inx 								; x 10.0
.25bc	a9 0a		lda #$0a			lda 	#10
.25be	20 96 26	jsr $2696			jsr 	FloatSetByte
.25c1	20 54 23	jsr $2354			jsr 	FloatMultiply
.25c4	20 d6 25	jsr $25d6			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25c7	20 74 22	jsr $2274			jsr 	FloatFractionalPart 		; get the fractional part
.25ca	20 e9 23	jsr $23e9			jsr 	FloatNormalise 				; normalise it.
.25cd	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25cf	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25d1	b0 e3		bcs $25b6			bcs 	_CNTSDecimal 				; keep going.
.25d3					_CNTSExit:
.25d3	7a		ply				ply
.25d4	fa		plx				plx
.25d5	60		rts				rts
.25d6					MakePlusTwoString:
.25d6	da		phx				phx
.25d7	20 77 26	jsr $2677			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25da	e8		inx				inx 								; access it
.25db	e8		inx				inx
.25dc	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart 			; make it an integer
.25df	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25e1	20 13 26	jsr $2613			jsr 	ConvertInt32
.25e4	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25e6					_MPTSCopy:
.25e6	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25e9	20 f4 25	jsr $25f4			jsr 	WriteDecimalBuffer
.25ec	e8		inx				inx
.25ed	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25f0	d0 f4		bne $25e6			bne 	_MPTSCopy
.25f2	fa		plx				plx
.25f3	60		rts				rts
.25f4					WriteDecimalBuffer:
.25f4	da		phx				phx
.25f5	ae 97 05	ldx $0597			ldx 	dbOffset
.25f8	9d 98 05	sta $0598,x			sta 	decimalBuffer,x
.25fb	9e 99 05	stz $0599,x			stz 	decimalBuffer+1,x
.25fe	ee 97 05	inc $0597			inc 	dbOffset
.2601	fa		plx				plx
.2602	60		rts				rts
.0596					decimalPlaces:
>0596							.fill 	1
.0597					dbOffset:
>0597							.fill 	1
.0598					decimalBuffer:
>0598							.fill 	32
.2603					ConvertInt16:
.2603	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.2605	86 4a		stx $4a				stx 	NSMantissa1
.2607	64 56		stz $56				stz 	NSMantissa2
.2609	64 62		stz $62				stz 	NSMantissa3
.260b	64 32		stz $32				stz 	NSStatus 					; positive integer
.260d	a2 00		ldx #$00			ldx 	#0 							; stack level
.260f	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.2611	80 00		bra $2613			bra 	ConvertInt32
.2613					ConvertInt32:
.2613	5a		phy				phy
.2614	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.2616	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.2618	10 08		bpl $2622			bpl 	_CI32NotNeg
.261a	48		pha				pha
.261b	a9 2d		lda #$2d			lda 	#'-'
.261d	99 71 05	sta $0571,y			sta 	numberBuffer,y
.2620	c8		iny				iny
.2621	68		pla				pla
.2622					_CI32NotNeg:
.2622	20 30 26	jsr $2630			jsr 	_CI32DivideConvert 			; recursive conversion
.2625	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2627	99 71 05	sta $0571,y			sta 	numberBuffer,y
.262a	7a		ply				ply
.262b	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.262d	a9 71		lda #$71			lda 	#numberBuffer & $FF
.262f	60		rts				rts
.2630					_CI32DivideConvert:
.2630	e8		inx				inx 								; write to next slot up
.2631	20 96 26	jsr $2696			jsr 	FloatSetByte 		 		; write the base out.
.2634	ca		dex				dex
.2635	20 2a 22	jsr $222a			jsr 	Int32Divide 				; divide
.2638	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.263a	48		pha				pha
.263b	20 19 22	jsr $2219			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.263e	20 b6 26	jsr $26b6			jsr 	FloatIsZero 				; is it zero ?
.2641	f0 05		beq $2648			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2643	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2645	20 30 26	jsr $2630			jsr 	_CI32DivideConvert 			; and recusrively call.
.2648					_CI32NoRecurse:
.2648	68		pla				pla 								; remainder
.2649	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.264b	90 02		bcc $264f			bcc 	_CI32NotHex
.264d	69 26		adc #$26			adc 	#6+32
.264f					_CI32NotHex:
.264f	69 30		adc #$30			adc 	#48
.2651	99 71 05	sta $0571,y			sta 	numberBuffer,y 				; write out and exit
.2654	c8		iny				iny
.2655	60		rts				rts
.2656					FloatNegate:
.2656	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2658	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.265a	95 32		sta $32,x			sta 	NSStatus,x
.265c	60		rts				rts
.265d					FloatNegateMantissa:
.265d	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.265e	a9 00		lda #$00			lda 	#0
.2660	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2662	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2664	a9 00		lda #$00			lda 	#0
.2666	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.2668	95 4a		sta $4a,x			sta 	NSMantissa1,x
.266a	a9 00		lda #$00			lda 	#0
.266c	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.266e	95 56		sta $56,x			sta 	NSMantissa2,x
.2670	a9 00		lda #$00			lda 	#0
.2672	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2674	95 62		sta $62,x			sta 	NSMantissa3,x
.2676	60		rts				rts
.2677					FloatShiftUpTwo:
.2677	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2679	95 40		sta $40,x			sta 	NSMantissa0+2,x
.267b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.267d	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.267f	b5 56		lda $56,x			lda 	NSMantissa2,x
.2681	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2683	b5 62		lda $62,x			lda 	NSMantissa3,x
.2685	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2687	b5 6e		lda $6e,x			lda 	NSExponent,x
.2689	95 70		sta $70,x			sta 	NSExponent+2,x
.268b	b5 32		lda $32,x			lda 	NSStatus,x
.268d	95 34		sta $34,x			sta 	NSStatus+2,x
.268f	60		rts				rts
.2690					FloatSetZeroMantissaOnly:
.2690	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2692	80 08		bra $269c			bra 	FloatZero13
.2694					FloatSetZero:
.2694	a9 00		lda #$00			lda 	#0
.2696					FloatSetByte:
.2696	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2698					FloatSetMantissa:
.2698	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.269a	74 32		stz $32,x			stz 	NSStatus,x
.269c					FloatZero13:
.269c	74 4a		stz $4a,x			stz 	NSMantissa1,x
.269e	74 56		stz $56,x			stz 	NSMantissa2,x
.26a0	74 62		stz $62,x			stz 	NSMantissa3,x
.26a2	60		rts				rts
.26a3					FloatShiftLeft:
.26a3	18		clc				clc
.26a4					FloatRotateLeft:
.26a4	36 3e		rol $3e,x			rol 	NSMantissa0,x
.26a6	36 4a		rol $4a,x			rol		NSMantissa1,x
.26a8	36 56		rol $56,x			rol		NSMantissa2,x
.26aa	36 62		rol $62,x			rol		NSMantissa3,x
.26ac	60		rts				rts
.26ad					FloatShiftRight:
.26ad	56 62		lsr $62,x			lsr 	NSMantissa3,x
.26af	76 56		ror $56,x			ror		NSMantissa2,x
.26b1	76 4a		ror $4a,x			ror		NSMantissa1,x
.26b3	76 3e		ror $3e,x			ror		NSMantissa0,x
.26b5	60		rts				rts
.26b6					FloatIsZero:
.26b6	b5 62		lda $62,x			lda 	NSMantissa3,x
.26b8	15 56		ora $56,x			ora		NSMantissa2,x
.26ba	15 4a		ora $4a,x			ora		NSMantissa1,x
.26bc	15 3e		ora $3e,x			ora		NSMantissa0,x
.26be	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.26bf					FloatArcTan:
.26bf	20 e9 23	jsr $23e9			jsr 	FloatNormalise 					; normalise x
.26c2	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.26c4	48		pha				pha
.26c5	74 32		stz $32,x			stz 	NSStatus,x
.26c7	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.26c9	c9 e2		cmp #$e2			cmp 	#$E2
.26cb	90 25		bcc $26f2			bcc 	_UANoFixup
.26cd	8a		txa				txa 									; value in +1
.26ce	a8		tay				tay
.26cf	c8		iny				iny
.26d0	20 78 28	jsr $2878			jsr 	CopyFloatXY
.26d3	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.26d5	20 96 26	jsr $2696			jsr 	FloatSetByte
.26d8	e8		inx				inx
.26d9	20 dd 21	jsr $21dd			jsr 	FloatDivide
.26dc	b0 21		bcs $26ff			bcs 	_FATError
.26de	20 02 27	jsr $2702			jsr 	CoreAtn 						; calculate the root
.26e1	20 6d 28	jsr $286d			jsr 	CompletePolynomial
.26e4	20 56 26	jsr $2656			jsr 	FloatNegate 					; make -ve
.26e7	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.26e9	20 c4 28	jsr $28c4			jsr 	LoadConstant
.26ec	e8		inx				inx
.26ed	20 b8 20	jsr $20b8			jsr 	FloatAdd
.26f0	80 06		bra $26f8			bra 	_UAComplete
.26f2					_UANoFixup:
.26f2	20 02 27	jsr $2702			jsr 	CoreAtn
.26f5	20 6d 28	jsr $286d			jsr 	CompletePolynomial
.26f8					_UAComplete:
.26f8	68		pla				pla 									; apply the result.
.26f9	55 32		eor $32,x			eor 	NSStatus,x
.26fb	95 32		sta $32,x			sta 	NSStatus,x
.26fd	18		clc				clc
.26fe	60		rts				rts
.26ff					_FATError:
.26ff	68		pla				pla
.2700	38		sec				sec
.2701	60		rts				rts
.2702					CoreAtn:
.2702	a9 70		lda #$70			lda 	#AtnCoefficients & $FF
.2704	a0 27		ldy #$27			ldy 	#AtnCoefficients >> 8
.2706	4c c1 29	jmp $29c1			jmp 	CorePolySquared
.2709					ExpCoefficients:
>2709	07					.byte	7
>270a	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>270e	d2					.byte	$d2
>270f	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>2713	d5					.byte	$d5
>2714	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>2718	d8					.byte	$d8
>2719	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>271d	db					.byte	$db
>271e	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>2722	dd					.byte	$dd
>2723	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>2727	df					.byte	$df
>2728	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>272c	e1					.byte	$e1
>272d	00 00 00 40				.dword	$40000000 ; 1.0
>2731	e2					.byte	$e2
.2732					SinCoefficients:
>2732	06					.byte	6
>2733	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>2737	e5					.byte	$e5
>2738	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>273c	e7					.byte	$e7
>273d	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>2741	e8					.byte	$e8
>2742	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>2746	e8					.byte	$e8
>2747	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>274b	e7					.byte	$e7
>274c	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>2750	e4					.byte	$e4
>2751	00 00 00 00				.dword	$00000000 ; 0.0
>2755	00					.byte	$00
.2756					LogCoefficients:
>2756	04					.byte	4
>2757	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>275b	e0					.byte	$e0
>275c	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>2760	e1					.byte	$e1
>2761	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>2765	e1					.byte	$e1
>2766	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>276a	e3					.byte	$e3
>276b	00 00 00 c0				.dword	$c0000000 ; -0.5
>276f	e1					.byte	$e1
.2770					AtnCoefficients:
>2770	0c					.byte	12
>2771	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2775	d7					.byte	$d7
>2776	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>277a	da					.byte	$da
>277b	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>277f	dc					.byte	$dc
>2780	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2784	dd					.byte	$dd
>2785	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>2789	dd					.byte	$dd
>278a	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>278e	de					.byte	$de
>278f	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2793	de					.byte	$de
>2794	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>2798	de					.byte	$de
>2799	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>279d	df					.byte	$df
>279e	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>27a2	df					.byte	$df
>27a3	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>27a7	e0					.byte	$e0
>27a8	00 00 00 40				.dword	$40000000 ; 1.0
>27ac	e2					.byte	$e2
>27ad	00 00 00 00				.dword	$00000000 ; 0.0
>27b1	00					.byte	$00
.27b2					Const_Base:
.27b2					Const_1Div2Pi:
>27b2	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>27b6	df					.byte	$df
.27b7					Const_PiDiv2:
>27b7	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>27bb	e2					.byte	$e2
.27bc					Const_Log2_e:
>27bc	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>27c0	e2					.byte	$e2
.27c1					Const_sqrt_2:
>27c1	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>27c5	e2					.byte	$e2
.27c6					Const_sqrt_half:
>27c6	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>27ca	e1					.byte	$e1
.27cb					Const_pi:
>27cb	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>27cf	e3					.byte	$e3
.27d0					Const_half:
>27d0	00 00 00 40				.dword	$40000000 ; 0.50000000
>27d4	e1					.byte	$e1
.27d5					Const_ln_e:
>27d5	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>27d9	e1					.byte	$e1
.27da					FloatCosine:
.27da	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.27dc	20 c4 28	jsr $28c4			jsr 	LoadConstant
.27df	e8		inx				inx
.27e0	20 b8 20	jsr $20b8			jsr 	FloatAdd
.27e3	4c 7a 29	jmp $297a			jmp 	FloatSine
.27e6					FloatExponent:
.27e6	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.27e8	20 c4 28	jsr $28c4			jsr 	LoadConstant
.27eb	e8		inx				inx
.27ec	20 54 23	jsr $2354			jsr 	FloatMultiply
.27ef	20 31 28	jsr $2831			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.27f2	e8		inx				inx
.27f3	20 cf 22	jsr $22cf			jsr 	FloatIntegerPart
.27f6	ca		dex				dex
.27f7	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.27f9	15 57		ora $57,x			ora 	NSMantissa2+1,x
.27fb	15 63		ora $63,x			ora 	NSMantissa3+1,x
.27fd	d0 38		bne $2837			bne 	_UERangeError
.27ff	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.2801	c9 40		cmp #$40			cmp 	#64
.2803	b0 32		bcs $2837			bcs 	_UERangeError
.2805	48		pha				pha
.2806	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.2808	48		pha				pha
.2809	20 74 22	jsr $2274			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.280c	68		pla				pla
.280d	10 14		bpl $2823			bpl 	_UEPositive
.280f	e8		inx				inx 							; 1-x
.2810	a9 01		lda #$01			lda 	#1
.2812	20 96 26	jsr $2696			jsr 	FloatSetByte
.2815	ca		dex				dex
.2816	20 56 26	jsr $2656			jsr 	FloatNegate
.2819	e8		inx				inx
.281a	20 b8 20	jsr $20b8			jsr 	FloatAdd
.281d	68		pla				pla 							; integer part +1 and negated.
.281e	1a		inc a				inc 	a
.281f	49 ff		eor #$ff			eor 	#$FF
.2821	1a		inc a				inc 	a
.2822	48		pha				pha
.2823					_UEPositive:
.2823	20 39 28	jsr $2839			jsr 	CoreExponent
.2826	20 6d 28	jsr $286d			jsr 	CompletePolynomial
.2829	68		pla				pla
.282a	18		clc				clc
.282b	75 6e		adc $6e,x			adc 	NSExponent,x
.282d	95 6e		sta $6e,x			sta 	NSExponent,x
.282f	18		clc				clc
.2830	60		rts				rts
.2831					_UECopy01:
.2831	8a		txa				txa
.2832	a8		tay				tay
.2833	c8		iny				iny
.2834	4c 78 28	jmp $2878			jmp 	CopyFloatXY
.2837					_UERangeError:
.2837	38		sec				sec
.2838	60		rts				rts
.2839					CoreExponent:
.2839	a9 09		lda #$09			lda 	#ExpCoefficients & $FF
.283b	a0 27		ldy #$27			ldy 	#ExpCoefficients >> 8
.283d	20 41 28	jsr $2841			jsr 	CalculateHornerPolynomial
.2840	60		rts				rts
.2841					CalculateHornerPolynomial:
.2841	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.2843	84 2d		sty $2d				sty 	zTemp0+1
.2845	9c b8 05	stz $05b8			stz 	coefficientCount 			; zero the count.
.2848	8e b9 05	stx $05b9			stx 	xValueSlot 					; save xValue slot.
.284b	e8		inx				inx 								; set the count to zero.
.284c	20 94 26	jsr $2694			jsr 	FloatSetZero
.284f					_CHPLoop:
.284f	8a		txa				txa 								; copy X-1 to X+1
.2850	a8		tay				tay
.2851	ca		dex				dex
.2852	c8		iny				iny
.2853	20 78 28	jsr $2878			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.2856	e8		inx				inx
.2857	e8		inx				inx
.2858	20 54 23	jsr $2354			jsr 	FloatMultiply 				; times current by X
.285b	e8		inx				inx
.285c	20 97 28	jsr $2897			jsr 	GetCoefficient 				; coefficient into X+1
.285f	20 b8 20	jsr $20b8			jsr 	FloatAdd 					; and add
.2862	ee b8 05	inc $05b8			inc 	coefficientCount
.2865	ad b8 05	lda $05b8			lda 	coefficientCount
.2868	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.286a	d0 e3		bne $284f			bne 	_CHPLoop
.286c	60		rts				rts
.286d					CompletePolynomial:
.286d	20 54 23	jsr $2354			jsr 	FloatMultiply
.2870	e8		inx				inx 								; get the last value
.2871	20 97 28	jsr $2897			jsr 	GetCoefficient
.2874	20 b8 20	jsr $20b8			jsr 	FloatAdd 					; and add it
.2877	60		rts				rts
.2878					CopyFloatXY:
.2878	b5 6e		lda $6e,x			lda 	NSExponent,x
.287a	99 6e 00	sta $006e,y			sta 	NSExponent,y
.287d	b5 32		lda $32,x			lda 	NSStatus,x
.287f	99 32 00	sta $0032,y			sta 	NSStatus,y
.2882	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2884	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.2887	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2889	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.288c	b5 56		lda $56,x			lda 	NSMantissa2,x
.288e	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.2891	b5 62		lda $62,x			lda 	NSMantissa3,x
.2893	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.2896	60		rts				rts
.2897					GetCoefficient:
.2897	5a		phy				phy
.2898	ad b8 05	lda $05b8			lda 	coefficientCount 			; 5 per block
.289b	0a		asl a				asl 	a
.289c	0a		asl a				asl 	a
.289d	38		sec				sec 								; +1 for count
.289e	6d b8 05	adc $05b8			adc 	coefficientCount
.28a1	a8		tay				tay
.28a2	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.28a4	95 3e		sta $3e,x			sta 	NSMantissa0,x
.28a6	c8		iny				iny
.28a7	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28a9	95 4a		sta $4a,x			sta 	NSMantissa1,x
.28ab	c8		iny				iny
.28ac	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28ae	95 56		sta $56,x			sta 	NSMantissa2,x
.28b0	c8		iny				iny
.28b1	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28b3	48		pha				pha
.28b4	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.28b6	95 62		sta $62,x			sta 	NSMantissa3,x
.28b8	c8		iny				iny
.28b9	68		pla				pla
.28ba	29 80		and #$80			and 	#$80
.28bc	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.28be	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28c0	95 6e		sta $6e,x			sta 	NSExponent,x
.28c2	7a		ply				ply
.28c3	60		rts				rts
.05b8					coefficientCount:
>05b8							.fill 	1
.05b9					xValueSlot:
>05b9							.fill 	1
.28c4					LoadConstant:
.28c4	5a		phy				phy
.28c5	a8		tay				tay
.28c6	b9 b2 27	lda $27b2,y			lda 	Const_Base+0,y
.28c9	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.28cb	b9 b3 27	lda $27b3,y			lda 	Const_Base+1,y
.28ce	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.28d0	b9 b4 27	lda $27b4,y			lda 	Const_Base+2,y
.28d3	95 57		sta $57,x			sta 	NSMantissa2+1,x
.28d5	b9 b5 27	lda $27b5,y			lda 	Const_Base+3,y
.28d8	48		pha				pha
.28d9	29 7f		and #$7f			and 	#$7F
.28db	95 63		sta $63,x			sta 	NSMantissa3+1,x
.28dd	68		pla				pla
.28de	29 80		and #$80			and 	#$80
.28e0	95 33		sta $33,x			sta 	NSStatus+1,x
.28e2	b9 b6 27	lda $27b6,y			lda 	Const_Base+4,y
.28e5	95 6f		sta $6f,x			sta 	NSExponent+1,x
.28e7	7a		ply				ply
.28e8	60		rts				rts
.28e9					FloatLogarithm:
.28e9	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.28eb	30 5f		bmi $294c			bmi 	_ULRange
.28ed	20 b6 26	jsr $26b6			jsr 	FloatIsZero
.28f0	f0 5a		beq $294c			beq 	_ULRange
.28f2	20 e9 23	jsr $23e9			jsr 	FloatNormalise 				; put into FP mode.
.28f5	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.28f7	48		pha				pha
.28f8	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.28fa	95 6e		sta $6e,x			sta 	NSExponent,x
.28fc	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.28fe	20 c4 28	jsr $28c4			jsr 	LoadConstant
.2901	e8		inx				inx
.2902	20 b8 20	jsr $20b8			jsr 	FloatAdd
.2905	8a		txa				txa 								; divide into sqrt 2.0
.2906	a8		tay				tay
.2907	c8		iny				iny
.2908	20 78 28	jsr $2878			jsr 	CopyFloatXY
.290b	ca		dex				dex
.290c	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.290e	20 c4 28	jsr $28c4			jsr 	LoadConstant
.2911	e8		inx				inx
.2912	e8		inx				inx
.2913	20 dd 21	jsr $21dd			jsr 	FloatDivide 				; if zero, error.
.2916	b0 33		bcs $294b			bcs 	_ULRangePla
.2918	20 56 26	jsr $2656			jsr 	FloatNegate 				; subtract from 1
.291b	e8		inx				inx
.291c	a9 01		lda #$01			lda 	#1
.291e	20 96 26	jsr $2696			jsr 	FloatSetByte
.2921	20 b8 20	jsr $20b8			jsr 	FloatAdd
.2924	20 4e 29	jsr $294e			jsr 	CoreLog
.2927	20 6d 28	jsr $286d			jsr 	CompletePolynomial
.292a	68		pla				pla 								; add exponent
.292b	18		clc				clc
.292c	69 1f		adc #$1f			adc 	#31 						; fix up
.292e	48		pha				pha
.292f	10 03		bpl $2934			bpl 	_LogNotNeg
.2931	49 ff		eor #$ff			eor 	#$FF
.2933	1a		inc a				inc 	a
.2934					_LogNotNeg:
.2934	e8		inx				inx 								; set byte and sign.
.2935	20 96 26	jsr $2696			jsr 	FloatSetByte
.2938	68		pla				pla
.2939	29 80		and #$80			and 	#$80
.293b	95 32		sta $32,x			sta 	NSStatus,x
.293d	20 b8 20	jsr $20b8			jsr 	FloatAdd
.2940	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.2942	20 c4 28	jsr $28c4			jsr 	LoadConstant
.2945	e8		inx				inx
.2946	20 54 23	jsr $2354			jsr 	FloatMultiply
.2949	18		clc				clc
.294a	60		rts				rts
.294b					_ULRangePla:
.294b	68		pla				pla
.294c					_ULRange:
.294c	38		sec				sec
.294d	60		rts				rts
.294e					CoreLog:
.294e	a9 56		lda #$56			lda 	#LogCoefficients & $FF
.2950	a0 27		ldy #$27			ldy 	#LogCoefficients >> 8
.2952	4c c1 29	jmp $29c1			jmp 	CorePolySquared
.2955					FloatPI:
.2955	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.2957	20 c4 28	jsr $28c4			jsr 	LoadConstant
.295a	e8		inx				inx
.295b	18		clc				clc
.295c	60		rts				rts
.295d					FloatPower:
.295d	ca		dex				dex
.295e	8a		txa				txa 							; copy 0 to 2, so we can process it
.295f	a8		tay				tay
.2960	c8		iny				iny
.2961	c8		iny				iny
.2962	20 78 28	jsr $2878			jsr 	CopyFloatXY
.2965	e8		inx				inx 							; 2 = Log(0)
.2966	e8		inx				inx
.2967	20 e9 28	jsr $28e9			jsr 	FloatLogarithm
.296a	b0 0d		bcs $2979			bcs 	_FPWExit
.296c	20 54 23	jsr $2354			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.296f	8a		txa				txa 							; copy to slot 0
.2970	a8		tay				tay
.2971	88		dey				dey
.2972	20 78 28	jsr $2878			jsr 	CopyFloatXY
.2975	ca		dex				dex  							; Exponent code.
.2976	20 e6 27	jsr $27e6			jsr 	FloatExponent
.2979					_FPWExit:
.2979	60		rts				rts
.297a					FloatSine:
.297a	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.297c	48		pha				pha
.297d	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.297f	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.2981	20 c4 28	jsr $28c4			jsr 	LoadConstant
.2984	e8		inx				inx
.2985	20 54 23	jsr $2354			jsr 	FloatMultiply
.2988	20 74 22	jsr $2274			jsr 	FloatFractionalPart 		; take the fractional part
.298b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.298d	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.298f	90 1f		bcc $29b0			bcc 	_USProcessExit
.2991	f0 06		beq $2999			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.2993	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.2995	c9 60		cmp #$60			cmp 	#$60
.2997	b0 0e		bcs $29a7			bcs 	_USSubtractOne
.2999					_USSubtractFromHalf:
.2999	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.299b	20 c4 28	jsr $28c4			jsr 	LoadConstant
.299e	e8		inx				inx
.299f	20 b2 20	jsr $20b2			jsr 	FloatSubtract
.29a2	20 56 26	jsr $2656			jsr 	FloatNegate 				; then negate it
.29a5	80 09		bra $29b0			bra 	_USProcessExit 				; and exit
.29a7					_USSubtractOne:
.29a7	e8		inx				inx
.29a8	a9 01		lda #$01			lda 	#1
.29aa	20 96 26	jsr $2696			jsr 	FloatSetByte
.29ad	20 b2 20	jsr $20b2			jsr 	FloatSubtract
.29b0					_USProcessExit:
.29b0	20 bd 29	jsr $29bd			jsr 	CoreSine
.29b3	20 6d 28	jsr $286d			jsr 	CompletePolynomial
.29b6	68		pla				pla 								; restore sign and apply
.29b7	55 32		eor $32,x			eor 	NSStatus,x
.29b9	95 32		sta $32,x			sta 	NSStatus,x
.29bb	18		clc				clc
.29bc	60		rts				rts
.29bd					CoreSine:
.29bd	a9 32		lda #$32			lda 	#SinCoefficients & $FF
.29bf	a0 27		ldy #$27			ldy 	#SinCoefficients >> 8
.29c1					CorePolySquared:
.29c1	48		pha				pha 								; save coefficient table
.29c2	5a		phy				phy
.29c3	8a		txa				txa 								; copy X to +1, +2
.29c4	a8		tay				tay
.29c5	c8		iny				iny
.29c6	20 78 28	jsr $2878			jsr 	CopyFloatXY
.29c9	c8		iny				iny
.29ca	20 78 28	jsr $2878			jsr 	CopyFloatXY
.29cd	e8		inx				inx 								; point to the pair and put x^2 on stack
.29ce	e8		inx				inx
.29cf	20 54 23	jsr $2354			jsr 	FloatMultiply
.29d2	7a		ply				ply 								; coefficient table back.
.29d3	68		pla				pla
.29d4	20 41 28	jsr $2841			jsr 	CalculateHornerPolynomial
.29d7	8a		txa				txa 								; copy back to slot #1
.29d8	a8		tay				tay
.29d9	88		dey				dey
.29da	20 78 28	jsr $2878			jsr	 	CopyFloatXY
.29dd	ca		dex				dex 								; point at result
.29de	60		rts				rts
.29df					FloatSquareRoot:
.29df	20 e9 28	jsr $28e9			jsr 	FloatLogarithm
.29e2	b0 06		bcs $29ea			bcs 	_FSQExit
.29e4	d6 6e		dec $6e,x			dec 	NSExponent,x
.29e6	20 e6 27	jsr $27e6			jsr 	FloatExponent
.29e9	18		clc				clc
.29ea					_FSQExit:
.29ea	60		rts				rts
.29eb					FloatTangent:
.29eb	da		phx				phx
.29ec	8a		txa				txa 								; sin -> +1
.29ed	a8		tay				tay
.29ee	c8		iny				iny
.29ef	20 78 28	jsr $2878			jsr 	CopyFloatXY
.29f2	e8		inx				inx
.29f3	20 7a 29	jsr $297a			jsr 	FloatSine
.29f6	ca		dex				dex
.29f7	8a		txa				txa 								; cos -> +2
.29f8	a8		tay				tay
.29f9	c8		iny				iny
.29fa	c8		iny				iny
.29fb	20 78 28	jsr $2878			jsr 	CopyFloatXY
.29fe	e8		inx				inx
.29ff	e8		inx				inx
.2a00	20 da 27	jsr $27da			jsr 	FloatCosine
.2a03	20 dd 21	jsr $21dd			jsr 	FloatDivide 				; calculate sin/cos
.2a06	b0 07		bcs $2a0f			bcs 	_FTExit 					; divide by zero
.2a08	8a		txa				txa 								; copy result down.
.2a09	a8		tay				tay
.2a0a	88		dey				dey
.2a0b	20 78 28	jsr $2878			jsr 	CopyFloatXY
.2a0e	18		clc				clc
.2a0f					_FTExit:
.2a0f	fa		plx				plx
.2a10	60		rts				rts

;******  Processing input file: testing/testend.asm

=$2b00							nextPage = (* + $FF) & $FF00 		; so I can include with that f*****g header.
.2afe					ObjectCodePreHeader:
>2afe	00 a0 d5 36 00 a6 a6 07				.binary "code/code.bin"
>2b06	01 00 cb 81 58 00 a6 04 04 02 20 cb 81 58 03 a6
>2b16	02 04 02 cc 40 cb 81 58 06 a6 04 01 00 cb 81 58
>2b26	09 a6 04 02 02 20 cb 81 58 0c a6 02 02 02 cc 40
>2b36	cb 81 58 0f a6 07 01 00 cb 81 58 12 a6 03 03 02
>2b46	20 cb 81 58 15 a6 04 02 02 cc 40 cb 81 58 18 a6
>2b56	04 01 50 00 8e ce f0 66 66 4b 79 a5 7c a6 03 04
>2b66	02 50 03 8e cd be 35 7d a6 02 01 02 50 06 8e cf
>2b76	06 4e 57 58 54 59 52 7e a6 03 01 50 09 8e ce f0
>2b86	d7 23 7c 79 a5 7c a6 04 00 02 50 0c 8e cd a6 38
>2b96	a5 7d a6 02 00 02 50 0f 8e cf 03 5a 5a 59 7e a6
>2ba6	06 01 50 12 8e ce f0 14 ae b9 56 a5 7c a6 00 02
>2bb6	02 50 15 8e cd a4 3e a5 7d a6 03 01 02 50 18 8e
>2bc6	cf 04 56 4b 4b 49 7e a6 00 01 50 00 8e ce ee 47
>2bd6	e1 82 58 a5 7c a6 03 03 02 50 03 8e cd e7 24 7d
>2be6	a6 00 02 02 50 06 8e cf 08 49 50 52 56 57 59 55
>2bf6	5a 7e a6 01 01 50 09 8e ce ed f5 28 d4 46 a5 7c
>2c06	a6 03 01 02 50 0c 8e cd 23 36 a5 7d a6 02 01 02
>2c16	50 0f 8e cf 00 7e a6 04 01 50 12 8e ce f0 b8 1e
>2c26	bc 40 7c a6 03 02 02 50 15 8e cd aa 67 a5 7d a6
>2c36	00 02 02 50 18 8e cf 06 47 47 59 4f 4c 4f 7e a6
>2c46	01 01 50 00 8e ce ee 00 00 51 7a a5 7c a6 00 00
>2c56	02 50 03 8e cc 6c a5 7d a6 00 01 02 50 06 8e cf
>2c66	04 49 48 52 4d 7e a6 02 01 50 09 8e ce f0 f5 28
>2c76	e9 5e a5 7c a6 03 01 02 50 0c 8e cd 74 63 7d a6
>2c86	02 01 02 50 0f 8e cf 03 50 55 53 7e a6 07 01 50
>2c96	12 8e ce ed a3 70 83 66 7c a6 03 02 02 50 15 8e
>2ca6	cd 6b 43 7d a6 03 02 02 50 18 8e cf 04 52 53 54
>2cb6	4d 7e a6 05 01 50 00 8e ce f0 28 1c dd 64 a5 7c
>2cc6	a6 04 01 02 50 03 8e cd 87 30 7d a6 01 01 02 50
>2cd6	06 8e cf 07 4a 52 55 51 53 4e 46 7e a6 00 01 50
>2ce6	09 8e ce ee e1 7a bb 50 7c a6 00 01 02 50 0c 8e
>2cf6	cd 78 32 a5 7d a6 01 01 02 50 0f 8e cf 06 4e 4b
>2d06	4b 41 52 4c 7e a6 01 01 50 12 8e ce ec 7a 14 06
>2d16	4f a5 7c a6 01 00 02 50 15 8e cd 56 04 7d a6 02
>2d26	01 02 50 18 8e cf 01 4c 7e a6 03 01 50 00 8e ce
>2d36	ec 66 66 42 69 7c a6 01 00 02 50 03 8e cd 70 68
>2d46	7d a6 01 00 02 50 06 8e cf 00 7e a6 04 01 50 09
>2d56	8e ce ee 85 eb cf 7f a5 7c a6 01 00 02 50 0c 8e
>2d66	cd a3 2a a5 7d a6 02 00 02 50 0f 8e cf 00 7e a6
>2d76	02 01 50 12 8e ce f0 7a d4 0c 52 a5 7c a6 02 03
>2d86	02 50 15 8e cd 7c 76 a5 7d a6 00 01 02 50 18 8e
>2d96	cf 03 50 55 4a 7e a6 06 01 50 00 8e ce f0 5c 8f
>2da6	08 64 a5 7c a6 00 04 02 50 03 8e cd e1 66 7d a6
>2db6	02 00 02 50 06 8e cf 08 4d 4f 54 4a 4c 57 57 54
>2dc6	7e a6 02 01 50 09 8e ce ee a3 70 ec 7c a5 7c a6
>2dd6	04 00 02 50 0c 8e cd c7 1e a5 7d a6 00 02 02 50
>2de6	0f 8e cf 01 45 7e a6 01 01 50 12 8e ce ee 66 66
>2df6	06 66 a5 7c a6 00 02 02 50 15 8e cd 59 69 a5 7d
>2e06	a6 01 00 02 50 18 8e cf 01 44 7e a6 03 01 50 00
>2e16	8e ce ed 99 99 f7 66 7c a6 02 02 02 50 03 8e cd
>2e26	b6 3f a5 7d a6 00 01 02 50 06 8e cf 07 46 4a 4e
>2e36	55 4b 44 4c 7e a6 00 01 50 09 8e cd ea 4e a5 7c
>2e46	a6 03 01 02 50 0c 8e cd 51 1e a5 7d a6 02 01 02
>2e56	50 0f 8e cf 04 45 5a 56 5a 7e a6 00 01 50 12 8e
>2e66	cd d8 0f 7c a6 01 03 02 50 15 8e cd c9 48 a5 7d
>2e76	a6 03 00 02 50 18 8e cf 01 42 7e a6 07 01 50 00
>2e86	8e ce f0 28 dc 38 64 a5 7c a6 03 04 02 50 03 8e
>2e96	cd b8 33 7d a6 02 00 02 50 06 8e cf 00 7e a6 02
>2ea6	01 50 09 8e ce ef a3 70 70 50 a5 7c a6 02 01 02
>2eb6	50 0c 8e cd 26 56 7d a6 01 00 02 50 0f 8e cf 00
>2ec6	7e a6 01 01 50 12 8e ce ef d7 a3 03 6d 7c a6 01
>2ed6	03 02 50 15 8e cd 96 6b a5 7d a6 00 01 02 50 18
>2ee6	8e cf 06 5a 54 48 44 46 53 7e a6 05 01 50 00 8e
>2ef6	ce ee 3d 0a 99 77 7c a6 04 01 02 50 03 8e cd fc
>2f06	0a 7d a6 00 02 02 50 06 8e cf 01 4b 7e a6 02 01
>2f16	50 09 8e ce ec cc cc 94 4c 7c a6 04 01 02 50 0c
>2f26	8e cd c6 10 a5 7d a6 00 01 02 50 0f 8e cf 06 44
>2f36	45 52 4f 4b 49 7e a6 06 01 50 12 8e ce f0 51 f8
>2f46	53 7b 7c a6 01 00 02 50 15 8e cd a4 0c 7d a6 04
>2f56	01 02 50 18 8e cf 05 4a 45 47 54 46 7e a6 02 01
>2f66	50 00 8e ce f0 3d 8a 68 6d a5 7c a6 01 02 02 50
>2f76	03 8e cd 9b 4d 7d a6 02 02 02 50 06 8e cf 00 7e
>2f86	a6 02 01 50 09 8e ce ef ae c7 52 4f a5 7c a6 04
>2f96	01 02 50 0c 8e cd 21 38 a5 7d a6 02 00 02 50 0f
>2fa6	8e cf 06 4f 48 4e 46 4f 41 7e a6 00 01 50 12 8e
>2fb6	ce ef 33 33 b2 66 7c a6 02 00 02 50 15 8e cd 3e
>2fc6	64 a5 7d a6 01 01 02 50 18 8e cf 04 43 55 4a 51
>2fd6	7e a6 00 01 50 00 8e 78 ce ee 47 e1 82 58 a5 a3
>2fe6	8b d3 0a 00 cd 4c 04 b1 0d 92 cb 91 a6 01 01 50
>2ff6	00 8e 78 ce ee 00 00 51 7a a5 a3 8b d3 0a 00 cd
>3006	56 04 b1 0d 92 cb 91 a6 02 01 50 00 8e 78 ce f0
>3016	3d 8a 68 6d a5 a3 8b d3 0a 00 cd 60 04 b1 0d 92
>3026	cb 91 a6 03 01 50 00 8e 78 ce ed 99 99 f7 66 a3
>3036	8b d3 0a 00 cd 6a 04 b1 0d 92 cb 91 a6 04 01 50
>3046	00 8e 78 ce f0 66 66 4b 79 a5 a3 8b d3 0a 00 cd
>3056	74 04 b1 0d 92 cb 91 a6 05 01 50 00 8e 78 ce ee
>3066	3d 0a 99 77 a3 8b d3 0a 00 cd 7e 04 b1 0d 92 cb
>3076	91 a6 06 01 50 00 8e 78 ce f0 5c 8f 08 64 a5 a3
>3086	8b d3 0a 00 cd 88 04 b1 0d 92 cb 91 a6 07 01 50
>3096	00 8e 78 ce f0 28 dc 38 64 a5 a3 8b d3 0a 00 cd
>30a6	92 04 b1 0d 92 cb 91 a6 00 00 02 50 03 8e 79 cc
>30b6	6c a5 a3 8b d3 0a 00 cd 9c 04 b1 0d 92 cb 91 a6
>30c6	00 04 02 50 03 8e 79 cd e1 66 a3 8b d3 0a 00 cd
>30d6	a6 04 b1 0d 92 cb 91 a6 01 00 02 50 03 8e 79 cd
>30e6	70 68 a3 8b d3 0a 00 cd b0 04 b1 0d 92 cb 91 a6
>30f6	01 02 02 50 03 8e 79 cd 9b 4d a3 8b d3 0a 00 cd
>3106	ba 04 b1 0d 92 cb 91 a6 02 02 02 50 03 8e 79 cd
>3116	b6 3f a5 a3 8b d3 0a 00 cd c4 04 b1 0d 92 cb 91
>3126	a6 03 03 02 50 03 8e 79 cd e7 24 a3 8b d3 0a 00
>3136	cd ce 04 b1 0d 92 cb 91 a6 03 04 02 50 03 8e 79
>3146	cd b8 33 a3 8b d3 0a 00 cd d8 04 b1 0d 92 cb 91
>3156	a6 04 01 02 50 03 8e 79 cd fc 0a a3 8b d3 0a 00
>3166	cd e2 04 b1 0d 92 cb 91 a6 00 01 02 50 06 8e 7a
>3176	cf 07 46 4a 4e 55 4b 44 4c 94 8b d3 0a 00 cd ec
>3186	04 b1 0d 92 cb 91 a6 00 02 02 50 06 8e 7a cf 01
>3196	4b 94 8b d3 0a 00 cd f6 04 b1 0d 92 cb 91 a6 01
>31a6	00 02 50 06 8e 7a cf 00 94 8b d3 0a 00 cd 00 05
>31b6	b1 0d 92 cb 91 a6 01 01 02 50 06 8e 7a cf 07 4a
>31c6	52 55 51 53 4e 46 94 8b d3 0a 00 cd 0a 05 b1 0d
>31d6	92 cb 91 a6 02 00 02 50 06 8e 7a cf 00 94 8b d3
>31e6	0a 00 cd 14 05 b1 0d 92 cb 91 a6 02 01 02 50 06
>31f6	8e 7a cf 06 4e 57 58 54 59 52 94 8b d3 0a 00 cd
>3206	1e 05 b1 0d 92 cb 91 a6 02 02 02 50 06 8e 7a cf
>3216	00 94 8b d3 0a 00 cd 28 05 b1 0d 92 cb 91 a6 00
>3226	01 50 09 8e 78 cd ea 4e a5 a3 8b d3 0a 00 cd 32
>3236	05 b1 0d 92 cb 91 a6 01 01 50 09 8e 78 ce ed f5
>3246	28 d4 46 a5 a3 8b d3 0a 00 cd 3c 05 b1 0d 92 cb
>3256	91 a6 02 01 50 09 8e 78 ce ef ae c7 52 4f a5 a3
>3266	8b d3 0a 00 cd 46 05 b1 0d 92 cb 91 a6 03 01 50
>3276	09 8e 78 ce f0 d7 23 7c 79 a5 a3 8b d3 0a 00 cd
>3286	50 05 b1 0d 92 cb 91 a6 04 01 50 09 8e 78 ce ee
>3296	85 eb cf 7f a5 a3 8b d3 0a 00 cd 5a 05 b1 0d 92
>32a6	cb 91 a6 00 01 02 50 0c 8e 79 cd 78 32 a5 a3 8b
>32b6	d3 0a 00 cd 64 05 b1 0d 92 cb 91 a6 01 00 02 50
>32c6	0c 8e 79 cd a3 2a a5 a3 8b d3 0a 00 cd 6e 05 b1
>32d6	0d 92 cb 91 a6 02 01 02 50 0c 8e 79 cd 26 56 a3
>32e6	8b d3 0a 00 cd 78 05 b1 0d 92 cb 91 a6 03 01 02
>32f6	50 0c 8e 79 cd 51 1e a5 a3 8b d3 0a 00 cd 82 05
>3306	b1 0d 92 cb 91 a6 04 00 02 50 0c 8e 79 cd c7 1e
>3316	a5 a3 8b d3 0a 00 cd 8c 05 b1 0d 92 cb 91 a6 04
>3326	01 02 50 0c 8e 79 cd 21 38 a5 a3 8b d3 0a 00 cd
>3336	96 05 b1 0d 92 cb 91 a6 00 01 02 50 0f 8e 7a cf
>3346	06 44 45 52 4f 4b 49 94 8b d3 0a 00 cd a0 05 b1
>3356	0d 92 cb 91 a6 00 02 02 50 0f 8e 7a cf 01 45 94
>3366	8b d3 0a 00 cd aa 05 b1 0d 92 cb 91 a6 01 00 02
>3376	50 0f 8e 7a cf 00 94 8b d3 0a 00 cd b4 05 b1 0d
>3386	92 cb 91 a6 01 01 02 50 0f 8e 7a cf 06 4e 4b 4b
>3396	41 52 4c 94 8b d3 0a 00 cd be 05 b1 0d 92 cb 91
>33a6	a6 02 00 02 50 0f 8e 7a cf 06 4f 48 4e 46 4f 41
>33b6	94 8b d3 0a 00 cd c8 05 b1 0d 92 cb 91 a6 02 01
>33c6	02 50 0f 8e 7a cf 04 45 5a 56 5a 94 8b d3 0a 00
>33d6	cd d2 05 b1 0d 92 cb 91 a6 00 01 50 12 8e 78 ce
>33e6	ef 33 33 b2 66 a3 8b d3 0a 00 cd dc 05 b1 0d 92
>33f6	cb 91 a6 01 01 50 12 8e 78 ce ef d7 a3 03 6d a3
>3406	8b d3 0a 00 cd e6 05 b1 0d 92 cb 91 a6 02 01 50
>3416	12 8e 78 ce f0 7a d4 0c 52 a5 a3 8b d3 0a 00 cd
>3426	f0 05 b1 0d 92 cb 91 a6 04 01 50 12 8e 78 ce f0
>3436	b8 1e bc 40 a3 8b d3 0a 00 cd fa 05 b1 0d 92 cb
>3446	91 a6 06 01 50 12 8e 78 ce f0 51 f8 53 7b a3 8b
>3456	d3 0a 00 cd 04 06 b1 0d 92 cb 91 a6 07 01 50 12
>3466	8e 78 ce ed a3 70 83 66 a3 8b d3 0a 00 cd 0e 06
>3476	b1 0d 92 cb 91 a6 00 02 02 50 15 8e 79 cd 59 69
>3486	a5 a3 8b d3 0a 00 cd 18 06 b1 0d 92 cb 91 a6 01
>3496	00 02 50 15 8e 79 cd a4 0c a3 8b d3 0a 00 cd 22
>34a6	06 b1 0d 92 cb 91 a6 01 03 02 50 15 8e 79 cd 96
>34b6	6b a5 a3 8b d3 0a 00 cd 2c 06 b1 0d 92 cb 91 a6
>34c6	02 00 02 50 15 8e 79 cd 3e 64 a5 a3 8b d3 0a 00
>34d6	cd 36 06 b1 0d 92 cb 91 a6 02 03 02 50 15 8e 79
>34e6	cd 7c 76 a5 a3 8b d3 0a 00 cd 40 06 b1 0d 92 cb
>34f6	91 a6 03 02 02 50 15 8e 79 cd 6b 43 a3 8b d3 0a
>3506	00 cd 4a 06 b1 0d 92 cb 91 a6 00 01 02 50 18 8e
>3516	7a cf 06 5a 54 48 44 46 53 94 8b d3 0a 00 cd 54
>3526	06 b1 0d 92 cb 91 a6 00 02 02 50 18 8e 7a cf 06
>3536	47 47 59 4f 4c 4f 94 8b d3 0a 00 cd 5e 06 b1 0d
>3546	92 cb 91 a6 01 00 02 50 18 8e 7a cf 01 44 94 8b
>3556	d3 0a 00 cd 68 06 b1 0d 92 cb 91 a6 01 01 02 50
>3566	18 8e 7a cf 04 43 55 4a 51 94 8b d3 0a 00 cd 72
>3576	06 b1 0d 92 cb 91 a6 02 01 02 50 18 8e 7a cf 01
>3586	4c 94 8b d3 0a 00 cd 7c 06 b1 0d 92 cb 91 a6 03
>3596	00 02 50 18 8e 7a cf 01 42 94 8b d3 0a 00 cd 86
>35a6	06 b1 0d 92 cb 91 a6 03 01 02 50 18 8e 7a cf 04
>35b6	56 4b 4b 49 94 8b d3 0a 00 cd 90 06 b1 0d 92 cb
>35c6	91 a6 03 02 02 50 18 8e 7a cf 04 52 53 54 4d 94
>35d6	8b d3 0a 00 cd 9a 06 b1 0d 92 cb 91 a6 04 01 02
>35e6	50 18 8e 7a cf 05 4a 45 47 54 46 94 8b d3 0a 00
>35f6	cd a4 06 b1 0d 92 cb 91 a6 cb 82 c5 ff
=11008					ObjectCode = ObjectCodePreHeader+2 			; so the code is at XX00

;******  End of listing
