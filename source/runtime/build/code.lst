
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl testing/testing.asm /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library testing/testend.asm
; Sun Oct  8 16:02:23 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: testing/testing.asm

.1000					WrapperBoot:
.1000	a9 32		lda #$32			lda 	#ObjectCode >> 8 			; address of object code to run.
.1002	a2 81		ldx #$81			ldx 	#$81 						; first page of allocatable memory
.1004	a0 9f		ldy #$9f			ldy 	#$9F 						; byte after end of last page.
.1006	4c 09 10	jmp $1009			jmp 	StartRuntime

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.1009					StartRuntime:
.1009	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.100c	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.100e	64 28		stz $28				stz 	codePtr
.1010	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.1013	8c 06 04	sty $0406			sty 	storeEndHigh
.1016	8e 07 04	stx $0407			stx 	variableStartPage
.1019	20 4b 12	jsr $124b			jsr 	ClearMemory 				; clear memory.
.101c	20 2a 1e	jsr $1e2a			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.101f	20 2c 1b	jsr $1b2c		 	jsr		SetDefaultChannel			; set default input/output channel.
.1022	20 62 1d	jsr $1d62			jsr 	RestoreCode 				; which we now call
.1025	a0 00		ldy #$00			ldy 	#0
.1027					NextCommand:
.1027	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.1029	30 5b		bmi $1086			bmi 	NXCommand 					; -if -ve command
.102b	c8		iny				iny
.102c	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.102e	90 39		bcc $1069			bcc 	PushByteA 					; 0..63 is short constants.
.1030					NXLoadStore:
.1030	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.1032	b0 19		bcs $104d			bcs 	NXIndirectLoadStore
.1034	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.1035	4a		lsr a				lsr 	a
.1036	29 0e		and #$0e			and 	#$0E
.1038	da		phx				phx 								; get ready to jump
.1039	aa		tax				tax
.103a	7c 3d 10	jmp ($103d,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.103d					ReadWriteVectors:
>103d	98 1c						.word 	ReadFloatCommand			; read float
>103f	73 22						.word 	WriteFloatCommand 			; write float
>1041	d4 1c						.word 	ReadIntegerCommand 			; read integer
>1043	af 22						.word 	WriteIntegerCommand 		; write integer
>1045	19 1d						.word 	ReadStringCommand 			; read string
>1047	ee 22						.word 	WriteStringCommand 			; write string
>1049	19 14						.word 	Unimplemented
>104b	19 14						.word 	Unimplemented
.104d					NXIndirectLoadStore:
.104d	29 07		and #$07			and 	#7
.104f	0a		asl a				asl 	a
.1050	da		phx				phx
.1051	aa		tax				tax
.1052	7c 55 10	jmp ($1055,x)			jmp 	(IndirectVectors,x)
.1055					IndirectVectors:
>1055	ce 16						.word 	IndFloatRead 				; float read
>1057	e2 16						.word 	IndInt16Read 				; int16 read
>1059	f6 16						.word 	IndStringRead 				; string read
>105b	19 14						.word 	Unimplemented
>105d	0a 17						.word 	IndFloatWrite				; float write
>105f	1e 17						.word 	IndInt16Write 				; int16 write
>1061	32 17						.word 	IndStringWrite 				; string write
>1063	19 14						.word 	Unimplemented
.1065					PushByteCommand:
.1065	fa		plx				plx
.1066	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.1068	c8		iny				iny
.1069					PushByteA:
.1069	e8		inx				inx 								; push constant on stack
.106a	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.106c	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.106e					ClearRestWord:
.106e	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.1070	74 62		stz $62,x			stz 	NSMantissa3,x
.1072	74 6e		stz $6e,x			stz 	NSExponent,x
.1074	74 32		stz $32,x			stz 	NSStatus,x
.1076	80 af		bra $1027			bra 	NextCommand
.1078					PushWordCommand:
.1078	fa		plx				plx
.1079	e8		inx				inx
.107a	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.107c	c8		iny				iny
.107d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.107f	b1 28		lda ($28),y			lda 	(codePtr),y
.1081	c8		iny				iny
.1082	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1084	80 e8		bra $106e			bra 	ClearRestWord 				; handle everything else.
.1086					NXCommand:
.1086	c8		iny				iny 								; consume command.
.1087	10 03		bpl $108c			bpl 	_NXCommandNoFixUp
.1089	20 92 10	jsr $1092			jsr 	FixUpY
.108c					_NXCommandNoFixUp:
.108c	0a		asl a				asl 	a 							; shift left
.108d	da		phx				phx 								; save SP on stack
.108e	aa		tax				tax				 					; and jump indirect
.108f	7c 54 21	jmp ($2154,x)			jmp 	(VectorTable,x)
.1092					FixUpY:
.1092	48		pha				pha
.1093	98		tya				tya
.1094	18		clc				clc
.1095	65 28		adc $28				adc 	codePtr
.1097	85 28		sta $28				sta 	codePtr
.1099	90 02		bcc $109d			bcc 	_NoCPCarry
.109b	e6 29		inc $29				inc 	codePtr+1
.109d					_NoCPCarry:
.109d	a0 00		ldy #$00			ldy 	#0
.109f	68		pla				pla
.10a0	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.10a1					AbsoluteTOS:
.10a1	fa		plx				plx
.10a2	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.10a4	4c 27 10	jmp $1027			jmp 	NextCommand
.10a7					CommandVarSpace:
.10a7	fa		plx				plx
.10a8	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.10aa	85 26		sta $26				sta 	availableMemory
.10ac	c8		iny				iny
.10ad	b1 28		lda ($28),y			lda 	(codePtr),y
.10af	18		clc				clc
.10b0	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.10b3	85 27		sta $27				sta 	availableMemory+1
.10b5	c8		iny				iny
.10b6	4c 27 10	jmp $1027			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.10b9					BinaryAnd:
.10b9	fa		plx				plx
.10ba	38		sec				sec
.10bb	80 02		bra $10bf			bra 	AndOrCommon
.10bd					BinaryOr:
.10bd	fa		plx				plx
.10be	18		clc				clc
.10bf					AndOrCommon:
.10bf	08		php				php 								; save AND/OR flag
.10c0	20 09 18	jsr $1809			jsr 	GetInteger16Bit
.10c3	ca		dex				dex
.10c4	20 09 18	jsr $1809			jsr 	GetInteger16Bit
.10c7	28		plp				plp
.10c8	90 0e		bcc $10d8			bcc 	_AOCOrCode
.10ca	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.10cc	35 3f		and $3f,x			and		NSMantissa0+1,x
.10ce	95 3e		sta $3e,x			sta 	NSMantissa0,x
.10d0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.10d2	35 4b		and $4b,x			and		NSMantissa1+1,x
.10d4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.10d6	80 0c		bra $10e4			bra 	_AOCComplete
.10d8					_AOCOrCode:
.10d8	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.10da	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.10dc	95 3e		sta $3e,x			sta 	NSMantissa0,x
.10de	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.10e0	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.10e2	95 4a		sta $4a,x			sta 	NSMantissa1,x
.10e4					_AOCComplete:
.10e4	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.10e6	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.10e8	10 07		bpl $10f1			bpl 	_AOCExit
.10ea	20 19 18	jsr $1819			jsr 	Negate16Bit 				; 2's complement
.10ed	a9 80		lda #$80			lda 	#$80 						; make it -ve
.10ef	95 32		sta $32,x			sta 	NSStatus,x
.10f1					_AOCExit:
.10f1	4c 27 10	jmp $1027			jmp 	NextCommand
.10f4					ArrayConvert:
.10f4	fa		plx				plx
.10f5	5a		phy				phy
.10f6	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.10f8	85 2e		sta $2e				sta 	zTemp1
.10fa	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.10fc	18		clc				clc
.10fd	6d 07 04	adc $0407			adc 	variableStartPage
.1100	85 2f		sta $2f				sta 	zTemp1+1
.1102	ca		dex				dex 								; count of indices to follow -> zTemp2
.1103	20 03 18	jsr $1803			jsr 	GetInteger8Bit
.1106	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.1108	8a		txa				txa
.1109	38		sec				sec
.110a	e5 30		sbc $30				sbc 	zTemp2
.110c	aa		tax				tax
.110d	da		phx				phx 								; stack points at the first index, which will be replaced.
.110e					_ACIndexLoop:
.110e	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart 			; integer array index
.1111	20 09 18	jsr $1809			jsr 	GetInteger16Bit 			; get the index => zTemp0
.1114	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.1116	a5 2c		lda $2c				lda 	zTemp0
.1118	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.111a	a5 2d		lda $2d				lda 	zTemp0+1
.111c	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.111e	b0 79		bcs $1199			bcs 	_ACBadIndex 				; index error.
.1120	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.1122	f0 29		beq $114d			beq 	_ACInnerLevel
.1124	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.1126	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1128	10 6f		bpl $1199			bpl 	_ACBadIndex
.112a	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.112c	26 2d		rol $2d				rol 	zTemp0+1
.112e	18		clc				clc
.112f	a5 2c		lda $2c				lda		zTemp0
.1131	65 2e		adc $2e				adc 	zTemp1
.1133	85 2c		sta $2c				sta 	zTemp0
.1135	a5 2d		lda $2d				lda		zTemp0+1
.1137	65 2f		adc $2f				adc 	zTemp1+1
.1139	85 2d		sta $2d				sta 	zTemp0+1
.113b	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.113d	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.113f	85 2e		sta $2e				sta 	zTemp1
.1141	c8		iny				iny
.1142	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1144	18		clc				clc
.1145	6d 07 04	adc $0407			adc 	variableStartPage
.1148	85 2f		sta $2f				sta 	zTemp1+1
.114a	e8		inx				inx 								; next index
.114b	80 c1		bra $110e			bra 	_ACIndexLoop
.114d					_ACInnerLevel:
.114d	a0 02		ldy #$02			ldy 	#2
.114f	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1151	30 46		bmi $1199			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.1153	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.1155	c9 00		cmp #$00			cmp 	#NSSIFloat
.1157	d0 13		bne $116c			bne 	_ACNotFloat
.1159	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.115b	48		pha				pha
.115c	a5 2c		lda $2c				lda 	zTemp0
.115e	06 2c		asl $2c				asl 	zTemp0 						; x 2
.1160	26 2d		rol $2d				rol 	zTemp0+1
.1162	18		clc				clc 								; add back x 3
.1163	65 2c		adc $2c				adc 	zTemp0
.1165	85 2c		sta $2c				sta 	zTemp0
.1167	68		pla				pla
.1168	65 2d		adc $2d				adc 	zTemp0+1
.116a	85 2d		sta $2d				sta 	zTemp0+1
.116c					_ACNotFloat:
.116c	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.116e	26 2d		rol $2d				rol 	zTemp0+1
.1170	18		clc				clc
.1171	a5 2c		lda $2c				lda 	zTemp0
.1173	69 03		adc #$03			adc 	#3
.1175	85 2c		sta $2c				sta 	zTemp0
.1177	90 02		bcc $117b			bcc 	_ACNoCarry
.1179	e6 2d		inc $2d				inc 	zTemp0+1
.117b					_ACNoCarry:
.117b	fa		plx				plx 								; X points to first slot of array parameters
.117c	18		clc				clc
.117d	a5 2c		lda $2c				lda 	zTemp0
.117f	65 2e		adc $2e				adc 	zTemp1
.1181	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1183	a5 2d		lda $2d				lda 	zTemp0+1
.1185	65 2f		adc $2f				adc 	zTemp1+1
.1187	38		sec				sec
.1188	ed 07 04	sbc $0407			sbc 	variableStartPage
.118b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.118d	74 56		stz $56,x			stz 	NSMantissa2,x
.118f	74 62		stz $62,x			stz 	NSMantissa3,x
.1191	74 32		stz $32,x			stz 	NSStatus,x
.1193	74 6e		stz $6e,x			stz 	NSExponent,x
.1195	7a		ply				ply 	 							; restore code pointer
.1196	4c 27 10	jmp $1027			jmp 	NextCommand
.1199					_ACBadIndex:
.1199	4c 9b 27	jmp $279b		jmp	ErrorV_index
.119c					UnaryAsc:
.119c	fa		plx				plx
.119d	5a		phy				phy
.119e	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.11a0	85 2c		sta $2c				sta 	zTemp0
.11a2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.11a4	85 2d		sta $2d				sta 	zTemp0+1
.11a6	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.11a8	f0 06		beq $11b0			beq 	_UAExit
.11aa	5a		phy				phy 								; otherwise first character
.11ab	a0 01		ldy #$01			ldy 	#1
.11ad	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.11af	7a		ply				ply
.11b0					_UAExit:
.11b0	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.11b3	7a		ply				ply
.11b4	4c 27 10	jmp $1027			jmp 	NextCommand
.11b7					CommandAssert:
.11b7	fa		plx				plx
.11b8	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.11ba	d0 09		bne $11c5			bne 	_CAFail
.11bc	20 28 2e	jsr $2e28			jsr 	FloatIsZero 				; is it zero ?
.11bf	f0 04		beq $11c5			beq 	_CAFail
.11c1	ca		dex				dex
.11c2	4c 27 10	jmp $1027			jmp 	NextCommand
.11c5					_CAFail:
.11c5	4c f4 26	jmp $26f4		jmp	ErrorV_assert
.11c8					X16_Audio_Parameters8_16:
.11c8	20 ce 11	jsr $11ce			jsr 	X16_Audio_Parameters8_8
.11cb	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.11cd	60		rts				rts
.11ce					X16_Audio_Parameters8_8:
.11ce	a2 01		ldx #$01			ldx 	#1
.11d0	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.11d3	ca		dex				dex
.11d4	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.11d7	20 03 18	jsr $1803			jsr 	GetInteger8Bit
.11da	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.11dc	a0 00		ldy #$00			ldy 	#0
.11de	60		rts				rts
.11df					X16_Audio_Parameters8_String:
.11df	20 c8 11	jsr $11c8			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.11e2	da		phx				phx 								; set the voice
.11e3	5a		phy				phy
.11e4	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.11e7	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>11ea	0a						.byte 	X16_AudioCodeBank
.11eb	7a		ply				ply
.11ec	fa		plx				plx
.11ed	86 2c		stx $2c				stx 	zTemp0
.11ef	84 2d		sty $2d				sty 	zTemp0+1
.11f1	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.11f3	e8		inx				inx 								; point YX to first character.
.11f4	d0 01		bne $11f7			bne 	_X16APSSkip
.11f6	c8		iny				iny
.11f7					_X16APSSkip:
.11f7	60		rts				rts
.11f8					Unary16Bin:
.11f8	fa		plx				plx
.11f9	20 09 18	jsr $1809			jsr 	GetInteger16Bit				; 16 bit int
.11fc	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.11fe	20 d3 1e	jsr $1ed3			jsr 	StringAllocTemp
.1201	a5 2d		lda $2d				lda 	zTemp0+1
.1203	f0 03		beq $1208			beq 	_UBNoHigh
.1205	20 10 12	jsr $1210			jsr 	_UBWriteBinary
.1208					_UBNoHigh:
.1208	a5 2c		lda $2c				lda 	zTemp0
.120a	20 10 12	jsr $1210			jsr 	_UBWriteBinary
.120d	4c 27 10	jmp $1027			jmp 	NextCommand
.1210					_UBWriteBinary:
.1210	5a		phy				phy
.1211	a0 08		ldy #$08			ldy 	#8
.1213					_UBWLoop:
.1213	0a		asl a				asl 	a
.1214	48		pha				pha
.1215	a9 00		lda #$00			lda  	#0
.1217	69 30		adc #$30			adc 	#48
.1219	20 fc 1e	jsr $1efc			jsr 	StringWriteChar
.121c	68		pla				pla
.121d	88		dey				dey
.121e	d0 f3		bne $1213			bne 	_UBWLoop
.1220	7a		ply				ply
.1221	60		rts				rts
.1222					PrintCharacter:
.1222	fa		plx				plx
.1223	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1225	ca		dex				dex
.1226	20 30 1b	jsr $1b30			jsr 	VectorPrintCharacter
.1229	4c 27 10	jmp $1027			jmp 	NextCommand
.122c					UnaryChr:
.122c	fa		plx				plx
.122d	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; get integer to convert.
.1230	48		pha				pha 								; save it and allocate for it
.1231	a9 01		lda #$01			lda 	#1 							; 1 character
.1233	20 d3 1e	jsr $1ed3			jsr 	StringAllocTemp
.1236	a9 01		lda #$01			lda 	#1 							; length 1.
.1238	92 22		sta ($22)			sta 	(zsTemp)
.123a	68		pla				pla 								; character code makes string.
.123b	5a		phy				phy
.123c	a0 01		ldy #$01			ldy 	#1
.123e	91 22		sta ($22),y			sta 	(zsTemp),y
.1240	7a		ply				ply
.1241	4c 27 10	jmp $1027			jmp 	NextCommand
.1244					CommandClr:
.1244	fa		plx				plx
.1245	20 4b 12	jsr $124b			jsr 	ClearMemory
.1248	4c 27 10	jmp $1027			jmp 	NextCommand
.124b					ClearMemory:
.124b	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.124e	85 2d		sta $2d				sta 	zTemp0+1
.1250	64 2c		stz $2c				stz 	zTemp0
.1252	5a		phy				phy
.1253	a0 00		ldy #$00			ldy 	#0
.1255					_ClearLoop1:
.1255	a9 00		lda #$00			lda 	#0
.1257	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1259	c8		iny				iny
.125a	d0 f9		bne $1255			bne 	_ClearLoop1
.125c	e6 2d		inc $2d				inc 	zTemp0+1
.125e	a5 2d		lda $2d				lda 	zTemp0+1
.1260	cd 06 04	cmp $0406			cmp 	storeEndHigh
.1263	d0 f0		bne $1255			bne 	_ClearLoop1
.1265	38		sec				sec 											; stack space = number of pages in total / 4
.1266	ad 06 04	lda $0406			lda 	storeEndHigh
.1269	ed 05 04	sbc $0405			sbc		storeStartHigh
.126c	4a		lsr a				lsr 	a
.126d	4a		lsr a				lsr 	a
.126e	d0 02		bne $1272			bne 	_NotEmpty 								; at least 1 !
.1270	a9 01		lda #$01			lda 	#1
.1272					_NotEmpty:
.1272	38		sec				sec 											; subtract from high to give string high memory
.1273	49 ff		eor #$ff			eor 	#$FF
.1275	6d 06 04	adc $0406			adc 	storeEndHigh
.1278	8d 03 04	sta $0403			sta 	stringHighMemory+1
.127b	9c 02 04	stz $0402			stz 	stringHighMemory
.127e	9c 68 05	stz $0568			stz 	stringInitialised 						; string system not initialised
.1281	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.1284	3a		dec a				dec 	a
.1285	85 25		sta $25				sta 	runtimeStackPtr+1
.1287	a9 ff		lda #$ff			lda 	#$FF
.1289	85 24		sta $24				sta 	runtimeStackPtr
.128b	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.128d	92 24		sta ($24)			sta 	(runtimeStackPtr)
.128f	7a		ply				ply
.1290	60		rts				rts
.1291					CompareStrings:
.1291	fa		plx				plx
.1292	ca		dex				dex
.1293	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.1295	85 2c		sta $2c				sta 	zTemp0
.1297	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1299	85 2d		sta $2d				sta 	zTemp0+1
.129b	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.129d	85 2e		sta $2e				sta 	zTemp1
.129f	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.12a1	85 2f		sta $2f				sta 	zTemp1+1
.12a3	da		phx				phx
.12a4	5a		phy				phy
.12a5	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.12a7	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.12a9	90 02		bcc $12ad			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.12ab	b2 2e		lda ($2e)			lda 	(zTemp1)
.12ad					_CSNIsSmallest:
.12ad	aa		tax				tax 								; count in X
.12ae	f0 0c		beq $12bc			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.12b0	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.12b2					_CSNCompareString:
.12b2	c8		iny				iny 								; pre increment
.12b3	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.12b5	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.12b7	d0 0a		bne $12c3			bne 	_CSNDifferent 				; numbers are different.
.12b9	ca		dex				dex
.12ba	d0 f6		bne $12b2			bne 	_CSNCompareString 			; compare common characters in two strings.
.12bc					_CSNMatches:
.12bc	38		sec				sec
.12bd	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.12bf	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.12c1	f0 06		beq $12c9			beq 	_CSNSExit 					; if zero, then strings match and exit.
.12c3					_CSNDifferent:
.12c3	a9 ff		lda #$ff			lda 	#$FF
.12c5	90 02		bcc $12c9			bcc 	_CSNSExit
.12c7	a9 01		lda #$01			lda 	#$01
.12c9					_CSNSExit:
.12c9	7a		ply				ply
.12ca	fa		plx				plx
.12cb	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.12cd	20 08 2e	jsr $2e08			jsr 	FloatSetByte 				; output the byte
.12d0	4c 27 10	jmp $1027			jmp 	NextCommand
.12d3					StringConcrete:
.12d3	9c 68 05	stz $0568			stz 	stringInitialised	 		; initialise next usage
.12d6	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.12d8	85 30		sta $30				sta 	zTemp2
.12da	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.12dc	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.12dd	18		clc				clc
.12de	72 30		adc ($30)			adc 	(zTemp2)
.12e0	90 02		bcc $12e4			bcc 	_SCNoOverflow
.12e2	a9 ff		lda #$ff			lda 	#255
.12e4					_SCNoOverflow:
.12e4	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.12e6	b0 02		bcs $12ea			bcs 	_SCNoMinimum
.12e8	a9 0a		lda #$0a			lda 	#10
.12ea					_SCNoMinimum:
.12ea	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.12ec	38		sec				sec
.12ed	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.12f0	e5 2e		sbc $2e				sbc 	zTemp1
.12f2	a8		tay				tay
.12f3	ad 03 04	lda $0403			lda 	stringHighMemory+1
.12f6	e9 00		sbc #$00			sbc 	#0
.12f8	48		pha				pha
.12f9	38		sec				sec 								; subtract 3 more
.12fa	98		tya				tya
.12fb	e9 03		sbc #$03			sbc 	#3
.12fd	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.1300	85 22		sta $22				sta 	zsTemp
.1302	68		pla				pla
.1303	e9 00		sbc #$00			sbc 	#0
.1305	8d 03 04	sta $0403			sta 	stringHighMemory+1
.1308	85 23		sta $23				sta 	zsTemp+1
.130a	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.130c	92 22		sta ($22)			sta 	(zsTemp)
.130e	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.1310	a9 00		lda #$00			lda 	#0
.1312	91 22		sta ($22),y			sta 	(zsTemp),y
.1314	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.1316	a4 23		ldy $23				ldy 	zsTemp+1
.1318	60		rts				rts
.1319					CommandData:
.1319	fa		plx				plx
.131a	98		tya				tya 								; data length +1 added to Y
.131b	38		sec				sec
.131c	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.131e	a8		tay				tay
.131f	4c 27 10	jmp $1027			jmp 	NextCommand
.1322					CommandDIM:
.1322	fa		plx				plx
.1323	5a		phy				phy
.1324	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.1327	8d 08 04	sta $0408			sta 	dimType
.132a	ca		dex				dex 								; this is the number of indices
.132b	20 03 18	jsr $1803			jsr 	GetInteger8Bit
.132e	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.1330	8a		txa				txa 								; dimension.
.1331	38		sec				sec
.1332	e5 2e		sbc $2e				sbc 	zTemp1
.1334	aa		tax				tax
.1335	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.1337	20 4b 13	jsr $134b			jsr 	DIMCreateOneLevel 			; create one at this level
.133a	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.133c	98		tya				tya
.133d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.133f	74 56		stz $56,x			stz 	NSMantissa2,x
.1341	74 62		stz $62,x			stz 	NSMantissa3,x
.1343	74 32		stz $32,x			stz 	NSStatus,x
.1345	74 6e		stz $6e,x			stz 	NSExponent,x
.1347	7a		ply				ply
.1348	4c 27 10	jmp $1027			jmp 	NextCommand
.134b					DIMCreateOneLevel:
.134b	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.134d	5a		phy				phy
.134e	a4 27		ldy $27				ldy 	availableMemory+1
.1350	5a		phy				phy
.1351	a8		tay				tay 			 					; save current level into Y
.1352	20 09 18	jsr $1809			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.1355	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.1357	d0 02		bne $135b			bne 	_DCOLNoCarry
.1359	e6 2d		inc $2d				inc 	zTemp0+1
.135b					_DCOLNoCarry:
.135b	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.135d	20 fe 13	jsr $13fe			jsr 	DIMWriteByte
.1360	a5 2d		lda $2d				lda 	zTemp0+1
.1362	20 fe 13	jsr $13fe			jsr 	DIMWriteByte
.1365	ad 08 04	lda $0408			lda 	dimType 					; get type information
.1368	29 7f		and #$7f			and 	#$7F
.136a	c0 01		cpy #$01			cpy 	#1
.136c	f0 02		beq $1370			beq 	_DCOLNoSubLevel
.136e	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.1370					_DCOLNoSubLevel:
.1370	20 fe 13	jsr $13fe			jsr 	DIMWriteByte
.1373	a5 26		lda $26				lda 	availableMemory
.1375	85 2e		sta $2e				sta 	zTemp1
.1377	a5 27		lda $27				lda 	availableMemory+1
.1379	85 2f		sta $2f				sta 	zTemp1+1
.137b	a5 2c		lda $2c				lda 	zTemp0
.137d	85 30		sta $30				sta 	zTemp2
.137f	a5 2d		lda $2d				lda 	zTemp0+1
.1381	85 31		sta $31				sta 	zTemp2+1
.1383					_DCOLFillArray:
.1383	20 e2 13	jsr $13e2			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.1386	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.1388	d0 02		bne $138c			bne 	_DCOLNoBorrow
.138a	c6 2d		dec $2d				dec 	zTemp0+1
.138c					_DCOLNoBorrow:
.138c	c6 2c		dec $2c				dec 	zTemp0
.138e	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.1390	05 2d		ora $2d				ora 	zTemp0+1
.1392	d0 ef		bne $1383			bne 	_DCOLFillArray
.1394	c0 01		cpy #$01			cpy 	#1
.1396	f0 42		beq $13da			beq 	_DCOLExit
.1398					_DCOLRecursionLoop:
.1398	da		phx				phx 								; save XY
.1399	5a		phy				phy
.139a	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.139c	48		pha				pha
.139d	a5 2f		lda $2f				lda 	zTemp1+1
.139f	48		pha				pha
.13a0	a5 30		lda $30				lda 	zTemp2
.13a2	48		pha				pha
.13a3	a5 31		lda $31				lda 	zTemp2+1
.13a5	48		pha				pha
.13a6	88		dey				dey  								; lower level -> A
.13a7	98		tya				tya
.13a8	e8		inx				inx 								; next index size
.13a9	20 4b 13	jsr $134b			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.13ac	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.13ad	86 31		stx $31				stx 	zTemp2+1
.13af	fa		plx				plx
.13b0	86 30		stx $30				stx 	zTemp2
.13b2	fa		plx				plx
.13b3	86 2f		stx $2f				stx 	zTemp1+1
.13b5	fa		plx				plx
.13b6	86 2e		stx $2e				stx 	zTemp1
.13b8	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.13ba	98		tya				tya
.13bb	a0 01		ldy #$01			ldy 	#1
.13bd	91 2e		sta ($2e),y			sta 	(zTemp1),y
.13bf	7a		ply				ply 								; restore XY
.13c0	fa		plx				plx
.13c1	18		clc				clc
.13c2	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.13c4	69 02		adc #$02			adc 	#2
.13c6	85 2e		sta $2e				sta 	zTemp1
.13c8	90 02		bcc $13cc			bcc 	_DCOLRNoCarry
.13ca	e6 2f		inc $2f				inc 	zTemp1+1
.13cc					_DCOLRNoCarry:
.13cc	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.13ce	d0 02		bne $13d2			bne 	_DCOLRNoBorrow
.13d0	c6 31		dec $31				dec 	zTemp2+1
.13d2					_DCOLRNoBorrow:
.13d2	c6 30		dec $30				dec 	zTemp2
.13d4	a5 30		lda $30				lda 	zTemp2 						; until completed.
.13d6	05 31		ora $31				ora 	zTemp2+1
.13d8	d0 be		bne $1398			bne 	_DCOLRecursionLoop
.13da					_DCOLExit:
.13da	68		pla				pla 								; get MSB, make offset again
.13db	38		sec				sec
.13dc	ed 07 04	sbc $0407			sbc 	variableStartPage
.13df	a8		tay				tay
.13e0	68		pla				pla 								; YA now contains offset address.
.13e1	60		rts				rts
.13e2					DIMWriteElement:
.13e2	da		phx				phx
.13e3	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.13e5	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.13e7	d0 0b		bne $13f4			bne 	_DIMWENotFloat
.13e9	ad 08 04	lda $0408			lda 	dimType
.13ec	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.13ee	c9 00		cmp #$00			cmp 	#NSSIFloat
.13f0	d0 02		bne $13f4			bne 	_DIMWENotFloat
.13f2	a2 06		ldx #$06			ldx 	#6
.13f4					_DIMWENotFloat:
.13f4	a9 00		lda #$00			lda 	#0
.13f6	20 fe 13	jsr $13fe			jsr 	DIMWriteByte
.13f9	ca		dex				dex
.13fa	d0 f8		bne $13f4			bne 	_DIMWENotFloat
.13fc	fa		plx				plx
.13fd	60		rts				rts
.13fe					DIMWriteByte:
.13fe	92 26		sta ($26)			sta 	(availableMemory)
.1400	e6 26		inc $26				inc 	availableMemory
.1402	d0 0b		bne $140f			bne 	_DIMWBSkip
.1404	e6 27		inc $27				inc 	availableMemory+1
.1406	48		pha				pha
.1407	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.1409	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.140c	b0 02		bcs $1410			bcs 	_DIMWBMemory
.140e	68		pla				pla
.140f					_DIMWBSkip:
.140f	60		rts				rts
.1410					_DIMWBMemory:
.1410	4c ae 27	jmp $27ae		jmp	ErrorV_memory
.0408					dimType:
>0408							.fill 	1
.1413					CommandEnd:
.1413	fa		plx				plx
.1414	86 2c		stx $2c				stx 	zTemp0
.1416	4c ff ff	jmp $ffff			jmp 	$FFFF
.1419					Unimplemented:
.1419	4c e1 26	jmp $26e1			jmp 	ErrorV_unimplemented
.141c					ErrorHandler:
.141c	98		tya				tya
.141d	18		clc				clc
.141e	65 28		adc $28				adc 	codePtr
.1420	85 28		sta $28				sta 	codePtr
.1422	90 02		bcc $1426			bcc 	_EHNoCarry
.1424	e6 29		inc $29				inc 	codePtr+1
.1426					_EHNoCarry:
.1426	68		pla				pla
.1427	7a		ply				ply
.1428	85 2c		sta $2c				sta 	zTemp0
.142a	84 2d		sty $2d				sty 	zTemp0+1
.142c	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.142e	a0 01		ldy #$01			ldy 	#1
.1430					_EHDisplayMsg:
.1430	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1432	20 48 24	jsr $2448			jsr 	XPrintCharacterToChannel
.1435	c8		iny				iny
.1436	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1438	d0 f6		bne $1430			bne 	_EHDisplayMsg
.143a	a9 20		lda #$20			lda 	#32
.143c	20 48 24	jsr $2448			jsr 	XPrintCharacterToChannel
.143f	a9 40		lda #$40			lda 	#64
.1441	20 48 24	jsr $2448			jsr 	XPrintCharacterToChannel
.1444	a9 20		lda #$20			lda 	#32
.1446	20 48 24	jsr $2448			jsr 	XPrintCharacterToChannel
.1449	20 4e 14	jsr $144e			jsr 	EHDisplayCodePtr
.144c	80 fe		bra $144c	_EHStop:bra 	_EHStop
.144e					EHDisplayCodePtr:
.144e	a9 20		lda #$20			lda 	#32
.1450	20 48 24	jsr $2448			jsr 	XPrintCharacterToChannel
.1453	38		sec				sec
.1454	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.1456	ed 04 04	sbc $0404			sbc 	runtimeHigh
.1459	20 62 14	jsr $1462			jsr 	_EHDisplayHex
.145c	a5 28		lda $28				lda 	codePtr
.145e	20 62 14	jsr $1462			jsr 	_EHDisplayHex
.1461	60		rts				rts
.1462					_EHDisplayHex:
.1462	48		pha				pha
.1463	4a		lsr a				lsr 	a
.1464	4a		lsr a				lsr 	a
.1465	4a		lsr a				lsr 	a
.1466	4a		lsr a				lsr 	a
.1467	20 6b 14	jsr $146b			jsr 	_EHDisplayNibble
.146a	68		pla				pla
.146b					_EHDisplayNibble:
.146b	29 0f		and #$0f			and 	#15
.146d	c9 0a		cmp #$0a			cmp 	#10
.146f	90 02		bcc $1473			bcc 	_EHNotHex
.1471	69 06		adc #$06			adc 	#6
.1473					_EHNotHex:
.1473	69 30		adc #$30			adc 	#48
.1475	4c 48 24	jmp $2448			jmp 	XPrintCharacterToChannel
.1478					CommandFor:
.1478	fa		plx				plx
.1479	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.147b	20 fb 14	jsr $14fb			jsr 	StackOpenFrame
.147e	20 3a 19	jsr $193a			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.1481	a0 07		ldy #$07			ldy 	#7 							; copy step out
.1483	20 dd 14	jsr $14dd			jsr 	CopyTOSToOffsetY
.1486	ca		dex				dex
.1487	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.1489	20 dd 14	jsr $14dd			jsr 	CopyTOSToOffsetY
.148c	ca		dex				dex
.148d	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.148f	29 80		and #$80			and 	#$80
.1491	a0 04		ldy #$04			ldy 	#4
.1493	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1495	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.1497	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.1499	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.149b	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.149d	c8		iny				iny
.149e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.14a0	18		clc				clc
.14a1	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.14a3	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14a5	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.14a8	85 2d		sta $2d				sta 	zTemp0+1
.14aa	ca		dex				dex 								; throw reference.
.14ab	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.14ad	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.14af	a0 0c		ldy #$0c			ldy 	#12
.14b1	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.14b3	a0 12		ldy #$12			ldy 	#18
.14b5	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.14b7	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.14b9	88		dey				dey 								; now the exponents.
.14ba	11 2c		ora ($2c),y			ora 	(zTemp0),y
.14bc	a0 0b		ldy #$0b			ldy 	#11
.14be	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.14c0	a0 11		ldy #$11			ldy 	#17
.14c2	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.14c4	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.14c6	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.14c8	c8		iny				iny
.14c9	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.14cb	c8		iny				iny
.14cc	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.14ce	d0 08		bne $14d8			bne 	_CFNoOptimise
.14d0	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.14d2	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.14d4	09 40		ora #$40			ora 	#$40
.14d6	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14d8					_CFNoOptimise:
.14d8	a0 00		ldy #$00			ldy 	#0
.14da	4c 27 10	jmp $1027			jmp 	NextCommand
.14dd					CopyTOSToOffsetY:
.14dd	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.14df	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14e1	c8		iny				iny
.14e2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.14e4	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14e6	c8		iny				iny
.14e7	b5 56		lda $56,x			lda 	NSMantissa2,x
.14e9	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14eb	c8		iny				iny
.14ec	b5 62		lda $62,x			lda 	NSMantissa3,x
.14ee	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14f0	c8		iny				iny
.14f1	b5 6e		lda $6e,x			lda 	NSExponent,x
.14f3	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14f5	c8		iny				iny
.14f6	b5 32		lda $32,x			lda 	NSStatus,x
.14f8	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.14fa	60		rts				rts
.14fb					StackOpenFrame:
.14fb	48		pha				pha 								; save frame marker
.14fc	29 1f		and #$1f			and 	#$1F 						; bytes required.
.14fe	85 2c		sta $2c				sta 	zTemp0
.1500	38		sec				sec 								; subtract from runtime stack pointer.
.1501	a5 24		lda $24				lda		runtimeStackPtr
.1503	e5 2c		sbc $2c				sbc 	zTemp0
.1505	85 24		sta $24				sta 	runtimeStackPtr
.1507	a5 25		lda $25				lda		runtimeStackPtr+1
.1509	e9 00		sbc #$00			sbc 	#0
.150b	85 25		sta $25				sta 	runtimeStackPtr+1
.150d	68		pla				pla 								; put frame marker at +0
.150e	92 24		sta ($24)			sta 	(runtimeStackPtr)
.1510	60		rts				rts
.1511					StackCloseFrame:
.1511	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.1513	29 1f		and #$1f			and 	#$1F 						; size
.1515	18		clc				clc
.1516	65 24		adc $24				adc 	runtimeStackPtr
.1518	85 24		sta $24				sta 	runtimeStackPtr
.151a	90 02		bcc $151e			bcc 	_SCFNoCarry
.151c	e6 25		inc $25				inc 	runtimeStackPtr+1
.151e					_SCFNoCarry:
.151e	60		rts				rts
.151f					StackFindFrame:
.151f	8d 09 04	sta $0409			sta 	requiredFrame
.1522					_SFFLoop:
.1522	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.1524	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.1526	f0 10		beq $1538			beq 	SCFFail
.1528	cd 09 04	cmp $0409			cmp 	requiredFrame 				; found this type ?
.152b	f0 05		beq $1532			beq 	_SFFFound
.152d	20 11 15	jsr $1511			jsr 	StackCloseFrame 			; close the top frame
.1530	80 f0		bra $1522			bra 	_SFFLoop 					; and try te next.
.1532					_SFFFound:
.1532	60		rts				rts
.1533					StackCheckFrame:
.1533	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.1535	d0 01		bne $1538			bne 	SCFFail
.1537	60		rts				rts
.1538					SCFFail:
.1538	4c 3e 27	jmp $273e		jmp	ErrorV_structure
.0409					requiredFrame:
>0409							.fill 	1
.153b					UnaryFre:
.153b	fa		plx				plx
.153c	20 06 2e	jsr $2e06			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.153f	38		sec				sec
.1540	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.1543	ed 00 04	sbc $0400			sbc 	stringLowMemory
.1546	95 3e		sta $3e,x			sta		NSMantissa0,x
.1548	ad 03 04	lda $0403			lda 	stringHighMemory+1
.154b	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.154e	95 4a		sta $4a,x			sta		NSMantissa1,x
.1550	4c 27 10	jmp $1027			jmp 	NextCommand
.1553					CommandGet:
.1553	fa		plx				plx
.1554	e8		inx				inx
.1555	a9 01		lda #$01			lda 	#1 							; 1 character space
.1557	20 d3 1e	jsr $1ed3			jsr 	StringAllocTemp
.155a	20 39 1b	jsr $1b39			jsr 	VectorGetCharacter 			; get a character
.155d	c9 00		cmp #$00			cmp 	#0
.155f	f0 09		beq $156a			beq 	_CGNone
.1561	5a		phy				phy
.1562	a0 01		ldy #$01			ldy 	#1 							; store char
.1564	91 22		sta ($22),y			sta 	(zsTemp),y
.1566	98		tya				tya 								; store length.
.1567	92 22		sta ($22)			sta 	(zsTemp)
.1569	7a		ply				ply
.156a					_CGNone:
.156a	4c 27 10	jmp $1027			jmp 	NextCommand
.156d					CommandGosub:
.156d	fa		plx				plx
.156e	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.1570	20 fb 14	jsr $14fb			jsr 	StackOpenFrame
.1573	20 3a 19	jsr $193a			jsr 	StackSaveCurrentPosition
.1576	4c 8b 15	jmp $158b			jmp 	PerformGOTO
.1579					CommandReturn:
.1579	fa		plx				plx
.157a	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.157c	20 1f 15	jsr $151f			jsr 	StackFindFrame
.157f	20 4b 19	jsr $194b			jsr 	StackLoadCurrentPosition
.1582	c8		iny				iny
.1583	c8		iny				iny
.1584	20 11 15	jsr $1511			jsr 	StackCloseFrame
.1587	4c 27 10	jmp $1027			jmp 	NextCommand
.158a					CommandGoto:
.158a	fa		plx				plx
.158b					PerformGOTO:
.158b	c8		iny				iny 								; push MSB of offset on stack
.158c	b1 28		lda ($28),y			lda 	(codePtr),y
.158e	48		pha				pha
.158f	88		dey				dey 								; point LSB of offset
.1590	18		clc				clc 								; add LSB
.1591	b1 28		lda ($28),y			lda 	(codePtr),y
.1593	65 28		adc $28				adc 	codePtr
.1595	85 28		sta $28				sta 	codePtr
.1597	68		pla				pla 								; restore offset MSB and add
.1598	65 29		adc $29				adc 	codePtr+1
.159a	85 29		sta $29				sta 	codePtr+1
.159c	4c 27 10	jmp $1027			jmp 	NextCommand
.159f					CommandGotoZ:
.159f	fa		plx				plx
.15a0	20 28 2e	jsr $2e28			jsr 	FloatIsZero
.15a3	ca		dex				dex
.15a4	c9 00		cmp #$00			cmp 	#0
.15a6	f0 e3		beq $158b			beq 	PerformGOTO
.15a8	c8		iny				iny
.15a9	c8		iny				iny
.15aa	4c 27 10	jmp $1027			jmp 	NextCommand
.15ad					CommandGotoNZ:
.15ad	fa		plx				plx
.15ae	20 28 2e	jsr $2e28			jsr 	FloatIsZero
.15b1	ca		dex				dex
.15b2	c9 00		cmp #$00			cmp 	#0
.15b4	d0 d5		bne $158b			bne 	PerformGOTO
.15b6	c8		iny				iny
.15b7	c8		iny				iny
.15b8	4c 27 10	jmp $1027			jmp 	NextCommand
.15bb					Command_PSET:
.15bb	fa		plx				plx
.15bc	5a		phy				phy
.15bd	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; get the colour
.15c0	48		pha				pha
.15c1	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.15c3	a0 02		ldy #$02			ldy 	#X16_r0
.15c5	20 47 16	jsr $1647			jsr 	GraphicsCopy2
.15c8	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.15cb	68		pla				pla 								; set pixel.
.15cc	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.15cf	7a		ply				ply
.15d0	a2 ff		ldx #$ff			ldx 	#$FF
.15d2	4c 27 10	jmp $1027			jmp 	NextCommand
.15d5					Command_LINE:
.15d5	fa		plx				plx
.15d6	5a		phy				phy
.15d7	20 3a 16	jsr $163a			jsr 	GraphicsColour
.15da	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.15dc	a0 02		ldy #$02			ldy 	#X16_r0
.15de	20 44 16	jsr $1644			jsr 	GraphicsCopy4
.15e1	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.15e4	7a		ply				ply
.15e5	a2 ff		ldx #$ff			ldx 	#$FF
.15e7	4c 27 10	jmp $1027			jmp 	NextCommand
.15ea					Command_RECT:
.15ea	fa		plx				plx
.15eb	5a		phy				phy
.15ec	20 5b 16	jsr $165b			jsr 	GraphicsRectCoords
.15ef	38		sec				sec
.15f0	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.15f3	7a		ply				ply
.15f4	a2 ff		ldx #$ff			ldx 	#$FF
.15f6	4c 27 10	jmp $1027			jmp 	NextCommand
.15f9					Command_FRAME:
.15f9	fa		plx				plx
.15fa	5a		phy				phy
.15fb	20 5b 16	jsr $165b			jsr 	GraphicsRectCoords
.15fe	18		clc				clc
.15ff	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.1602	7a		ply				ply
.1603	a2 ff		ldx #$ff			ldx 	#$FF
.1605	4c 27 10	jmp $1027			jmp 	NextCommand
.1608					Command_CHAR:
.1608	fa		plx				plx
.1609	5a		phy				phy
.160a	ca		dex				dex  								; set the draw colour
.160b	20 3a 16	jsr $163a			jsr 	GraphicsColour
.160e	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.1610	a0 02		ldy #$02			ldy 	#X16_r0
.1612	20 47 16	jsr $1647			jsr 	GraphicsCopy2
.1615	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.1617	85 2c		sta $2c				sta 	zTemp0
.1619	a5 4d		lda $4d				lda 	NSMantissa1+3
.161b	85 2d		sta $2d				sta 	zTemp0+1
.161d	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.161f	85 2e		sta $2e				sta 	zTemp1
.1621					_CCLoop:
.1621	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.1623	f0 0f		beq $1634			beq 	_CCExit
.1625	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.1627	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.1629	d0 02		bne $162d			bne 	_CCNoCarry
.162b	e6 2d		inc $2d				inc 	zTemp0+1
.162d					_CCNoCarry:
.162d	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.162f	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.1632	80 ed		bra $1621			bra 	_CCLoop						; go round.
.1634					_CCExit:
.1634	7a		ply				ply
.1635	a2 ff		ldx #$ff			ldx 	#$FF
.1637	4c 27 10	jmp $1027			jmp 	NextCommand
.163a					GraphicsColour:
.163a	20 03 18	jsr $1803			jsr 	GetInteger8Bit
.163d	aa		tax				tax
.163e	a0 00		ldy #$00			ldy 	#0
.1640	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.1643	60		rts				rts
.1644					GraphicsCopy4:
.1644	20 47 16	jsr $1647			jsr 	GraphicsCopy2
.1647					GraphicsCopy2:
.1647	20 4a 16	jsr $164a			jsr 	GraphicsCopy1
.164a					GraphicsCopy1:
.164a	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.164d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.164f	99 00 00	sta $0000,y			sta 	0,y
.1652	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1654	99 01 00	sta $0001,y			sta 	1,y
.1657	e8		inx				inx
.1658	c8		iny				iny
.1659	c8		iny				iny
.165a	60		rts				rts
.165b					GraphicsRectCoords:
.165b	20 3a 16	jsr $163a			jsr 	GraphicsColour 				; set colour
.165e	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.1660	a0 02		ldy #$02			ldy 	#X16_r0
.1662	20 44 16	jsr $1644			jsr 	GraphicsCopy4
.1665	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.1667	20 74 16	jsr $1674			jsr 	_GRCSortSubtract
.166a	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.166c	20 74 16	jsr $1674			jsr 	_GRCSortSubtract
.166f	74 08		stz $08,x			stz 	8,x 						; zero rounding
.1671	74 09		stz $09,x			stz 	9,x
.1673	60		rts				rts
.1674					_GRCSortSubtract:
.1674	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.1676	d5 00		cmp $00,x			cmp 	0,x
.1678	b5 05		lda $05,x			lda 	5,x
.167a	f5 01		sbc $01,x			sbc 	1,x
.167c	b0 08		bcs $1686			bcs 	_GRCNoSwap 					; >= swap.
.167e	20 94 16	jsr $1694			jsr 	_GRCSwapByte 				; swap 0/2
.1681	e8		inx				inx
.1682	20 94 16	jsr $1694			jsr 	_GRCSwapByte 				; swap 1/3
.1685	ca		dex				dex
.1686					_GRCNoSwap:
.1686	38		sec				sec 								; calculate width/height into 4,5
.1687	b5 04		lda $04,x			lda 	4,x
.1689	f5 00		sbc $00,x			sbc 	0,x
.168b	95 04		sta $04,x			sta 	4,x
.168d	b5 05		lda $05,x			lda 	5,x
.168f	f5 01		sbc $01,x			sbc 	1,x
.1691	95 05		sta $05,x			sta 	5,x
.1693	60		rts				rts
.1694					_GRCSwapByte:
.1694	b5 04		lda $04,x			lda 	4,x
.1696	48		pha				pha
.1697	b5 00		lda $00,x			lda 	0,x
.1699	95 04		sta $04,x			sta 	4,x
.169b	68		pla				pla
.169c	95 00		sta $00,x			sta 	0,x
.169e	60		rts				rts
.169f					Unary16Hex:
.169f	fa		plx				plx
.16a0	20 09 18	jsr $1809			jsr 	GetInteger16Bit
.16a3	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.16a5	20 d3 1e	jsr $1ed3			jsr 	StringAllocTemp
.16a8	a5 2d		lda $2d				lda 	zTemp0+1
.16aa	f0 03		beq $16af			beq 	_UHNoHigh
.16ac	20 b7 16	jsr $16b7			jsr 	_UHWriteHex
.16af					_UHNoHigh:
.16af	a5 2c		lda $2c				lda 	zTemp0
.16b1	20 b7 16	jsr $16b7			jsr 	_UHWriteHex
.16b4	4c 27 10	jmp $1027			jmp 	NextCommand
.16b7					_UHWriteHex:
.16b7	48		pha				pha
.16b8	4a		lsr a				lsr 	a
.16b9	4a		lsr a				lsr 	a
.16ba	4a		lsr a				lsr 	a
.16bb	4a		lsr a				lsr 	a
.16bc	20 c0 16	jsr $16c0			jsr 	_UHWriteNibl
.16bf	68		pla				pla
.16c0					_UHWriteNibl:
.16c0	29 0f		and #$0f			and 	#15
.16c2	c9 0a		cmp #$0a			cmp 	#10
.16c4	90 02		bcc $16c8			bcc 	_UHDigit
.16c6	69 06		adc #$06			adc 	#6
.16c8					_UHDigit:
.16c8	69 30		adc #$30			adc 	#48
.16ca	20 fc 1e	jsr $1efc			jsr 	StringWriteChar
.16cd	60		rts				rts
.16ce					IndFloatRead:
.16ce	fa		plx				plx
.16cf	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.16d1	85 2c		sta $2c				sta 	zTemp0
.16d3	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.16d5	18		clc				clc
.16d6	6d 07 04	adc $0407			adc 	variableStartPage
.16d9	85 2d		sta $2d				sta 	zTemp0+1
.16db	ca		dex				dex 								; throw the address
.16dc	20 b2 1c	jsr $1cb2			jsr 	ReadFloatZTemp0Sub 							; call read routine
.16df	4c 27 10	jmp $1027			jmp 	NextCommand
.16e2					IndInt16Read:
.16e2	fa		plx				plx
.16e3	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.16e5	85 2c		sta $2c				sta 	zTemp0
.16e7	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.16e9	18		clc				clc
.16ea	6d 07 04	adc $0407			adc 	variableStartPage
.16ed	85 2d		sta $2d				sta 	zTemp0+1
.16ef	ca		dex				dex 								; throw the address
.16f0	20 ee 1c	jsr $1cee			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.16f3	4c 27 10	jmp $1027			jmp 	NextCommand
.16f6					IndStringRead:
.16f6	fa		plx				plx
.16f7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.16f9	85 2c		sta $2c				sta 	zTemp0
.16fb	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.16fd	18		clc				clc
.16fe	6d 07 04	adc $0407			adc 	variableStartPage
.1701	85 2d		sta $2d				sta 	zTemp0+1
.1703	ca		dex				dex 								; throw the address
.1704	20 33 1d	jsr $1d33			jsr 	ReadStringZTemp0Sub 							; call read routine
.1707	4c 27 10	jmp $1027			jmp 	NextCommand
.170a					IndFloatWrite:
.170a	fa		plx				plx
.170b	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.170d	85 2c		sta $2c				sta 	zTemp0
.170f	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.1711	18		clc				clc
.1712	6d 07 04	adc $0407			adc 	variableStartPage
.1715	85 2d		sta $2d				sta 	zTemp0+1
.1717	20 8d 22	jsr $228d			jsr 	WriteFloatZTemp0Sub 							; call write routine
.171a	ca		dex				dex 								; throw the address as well.
.171b	4c 27 10	jmp $1027			jmp 	NextCommand
.171e					IndInt16Write:
.171e	fa		plx				plx
.171f	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.1721	85 2c		sta $2c				sta 	zTemp0
.1723	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.1725	18		clc				clc
.1726	6d 07 04	adc $0407			adc 	variableStartPage
.1729	85 2d		sta $2d				sta 	zTemp0+1
.172b	20 c9 22	jsr $22c9			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.172e	ca		dex				dex 								; throw the address as well.
.172f	4c 27 10	jmp $1027			jmp 	NextCommand
.1732					IndStringWrite:
.1732	fa		plx				plx
.1733	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.1735	85 2c		sta $2c				sta 	zTemp0
.1737	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.1739	18		clc				clc
.173a	6d 07 04	adc $0407			adc 	variableStartPage
.173d	85 2d		sta $2d				sta 	zTemp0+1
.173f	20 08 23	jsr $2308			jsr 	WriteStringZTemp0Sub 							; call write routine
.1742	ca		dex				dex 								; throw the address as well.
.1743	4c 27 10	jmp $1027			jmp 	NextCommand
.1746					CommandInput:
.1746	fa		plx				plx
.1747	5a		phy				phy 								; save Y
.1748	e8		inx				inx									; space on stack
.1749					_INError:
.1749	20 7d 17	jsr $177d			jsr 	InputStringToBuffer 		; input from keyboard
.174c	a9 5f		lda #$5f			lda 	#((ReadBufferSize) & $FF)
.174e	85 2c		sta $2c				sta 	0+zTemp0
.1750	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.1752	85 2d		sta $2d				sta 	1+zTemp0
.1754	20 1a 21	jsr $211a			jsr 	ValEvaluateZTemp0
.1757	b0 f0		bcs $1749			bcs 	_INError 					; failed, try again.
.1759	7a		ply				ply 								; restore Y
.175a	4c 27 10	jmp $1027			jmp 	NextCommand
.175d					CommandInputString:
.175d	fa		plx				plx
.175e	5a		phy				phy 								; save Y
.175f	20 7d 17	jsr $177d			jsr 	InputStringToBuffer 		; input from keyboard
.1762	e8		inx				inx 								; make space on stack
.1763	20 06 2e	jsr $2e06			jsr 	FloatSetZero 				; store as string on stack
.1766	a9 5f		lda #$5f			lda 	#ReadBufferSize & $FF
.1768	95 3e		sta $3e,x			sta 	NSMantissa0,x
.176a	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.176c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.176e	a9 40		lda #$40			lda 	#NSSString
.1770	95 32		sta $32,x			sta 	NSStatus,x
.1772	7a		ply				ply 								; restore Y
.1773	4c 27 10	jmp $1027			jmp 	NextCommand
.1776					CommandInputReset:
.1776	fa		plx				plx
.1777	9c 0a 04	stz $040a			stz 	InputBuffer
.177a	4c 27 10	jmp $1027			jmp 	NextCommand
.177d					InputStringToBuffer:
.177d	a9 b7		lda #$b7			lda 	#((InputBumpNext) & $FF)
.177f	8d 5f 05	sta $055f			sta 	0+ReadBumpNextVec
.1782	a9 17		lda #$17			lda 	#((InputBumpNext) >> 8) & $FF
.1784	8d 60 05	sta $0560			sta 	1+ReadBumpNextVec
.1787	a9 94		lda #$94			lda 	#((InputLookNext) & $FF)
.1789	8d 61 05	sta $0561			sta 	0+ReadLookNextVec
.178c	a9 17		lda #$17			lda 	#((InputLookNext) >> 8) & $FF
.178e	8d 62 05	sta $0562			sta 	1+ReadLookNextVec
.1791	4c 0f 1c	jmp $1c0f			jmp 	GetStringToBuffer
.1794					InputLookNext:
.1794	da		phx				phx
.1795					_ILNRetry:
.1795	ad 0a 04	lda $040a			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.1798	d0 08		bne $17a2			bne 	_ILNNotEmpty
.179a	20 bb 17	jsr $17bb			jsr 	InputGetNewLine 			; get a new line
.179d	9c 5b 04	stz $045b			stz 	InputBufferPos 				; reset read position.
.17a0	80 f3		bra $1795			bra 	_ILNRetry
.17a2					_ILNNotEmpty:
.17a2	ae 5b 04	ldx $045b			ldx 	InputBufferPos 				; get head available character
.17a5	bd 0a 04	lda $040a,x			lda 	InputBuffer,x
.17a8	d0 08		bne $17b2			bne 	_ILNExit 					; if not EOS return it with CC.
.17aa					_ILNNextLine:
.17aa	9c 0a 04	stz $040a			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.17ad	38		sec				sec 								; return CS,Zero
.17ae	fa		plx				plx
.17af	a9 0d		lda #$0d			lda 	#13
.17b1	60		rts				rts
.17b2					_ILNExit:
.17b2	fa		plx				plx
.17b3	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.17b5	18		clc				clc
.17b6	60		rts				rts
.17b7					InputBumpNext:
.17b7	ee 5b 04	inc $045b			inc 	InputBufferPos
.17ba	60		rts				rts
.17bb					InputGetNewLine:
.17bb	48		pha				pha
.17bc	da		phx				phx
.17bd	5a		phy				phy
.17be	a9 3f		lda #$3f			lda 	#"?"
.17c0	20 fa 17	jsr $17fa			jsr 	IGNLEchoIfScreen
.17c3	a0 00		ldy #$00			ldy 	#0 							; line position.
.17c5					_IGNLLoop:
.17c5	20 39 1b	jsr $1b39			jsr 	VectorGetCharacter 			; get a character
.17c8	c9 00		cmp #$00			cmp 	#0
.17ca	f0 f9		beq $17c5			beq 	_IGNLLoop
.17cc	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.17ce	f0 11		beq $17e1			beq 	_IGNBackspace
.17d0	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.17d2	f0 17		beq $17eb			beq 	_IGNExit
.17d4	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.17d6	f0 ed		beq $17c5			beq 	_IGNLLoop
.17d8	99 0a 04	sta $040a,y			sta 	InputBuffer,y
.17db	c8		iny				iny
.17dc	20 fa 17	jsr $17fa			jsr 	IGNLEchoIfScreen
.17df	80 e4		bra $17c5			bra 	_IGNLLoop
.17e1					_IGNBackspace:
.17e1	c0 00		cpy #$00			cpy 	#0
.17e3	f0 e0		beq $17c5			beq 	_IGNLLoop
.17e5	20 fa 17	jsr $17fa			jsr 	IGNLEchoIfScreen
.17e8	88		dey				dey
.17e9	80 da		bra $17c5			bra 	_IGNLLoop
.17eb					_IGNExit:
.17eb	20 fa 17	jsr $17fa			jsr 	IGNLEchoIfScreen
.17ee	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.17f0	99 0a 04	sta $040a,y			sta 	InputBuffer,y
.17f3	9c 5b 04	stz $045b			stz 	InputBufferPos 				; reset position to start of input buffer.
.17f6	7a		ply				ply
.17f7	fa		plx				plx
.17f8	68		pla				pla
.17f9	60		rts				rts
.17fa					IGNLEchoIfScreen:
.17fa	ae 5d 04	ldx $045d			ldx 	currentChannel
.17fd	d0 03		bne $1802			bne 	_IGNLEExit
.17ff	20 30 1b	jsr $1b30			jsr 	VectorPrintCharacter
.1802					_IGNLEExit:
.1802	60		rts				rts
.040a					InputBuffer:
>040a							.fill 	81
.045b					InputBufferPos:
>045b							.fill 	1
.1803					GetInteger8Bit:
.1803	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.1806	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1808	60		rts				rts
.1809					GetInteger16Bit:
.1809	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.180c	34 32		bit $32,x			bit 	NSStatus,x
.180e	30 09		bmi $1819			bmi 	Negate16Bit
.1810	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1812	85 2c		sta $2c				sta 	zTemp0
.1814	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1816	85 2d		sta $2d				sta 	zTemp0+1
.1818	60		rts				rts
.1819					Negate16Bit:
.1819	38		sec				sec
.181a	a9 00		lda #$00			lda 	#0
.181c	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.181e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1820	85 2c		sta $2c				sta 	zTemp0
.1822	a9 00		lda #$00			lda 	#0
.1824	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1826	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1828	85 2d		sta $2d				sta 	zTemp0+1
.182a	60		rts				rts
.182b					UnaryJoy:
.182b	fa		plx				plx
.182c	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; port #
.182f	48		pha				pha 								; zero the result.
.1830	20 06 2e	jsr $2e06			jsr 	FloatSetZero
.1833	68		pla				pla
.1834	5a		phy				phy
.1835	da		phx				phx
.1836	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1839	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.183b	d0 10		bne $184d			bne 	_UJNoHardware
.183d	a8		tay				tay 								; move XA -> AY
.183e	8a		txa				txa
.183f	fa		plx				plx 								; we can update it now.
.1840	49 ff		eor #$ff			eor 	#$FF
.1842	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1844	98		tya				tya
.1845	49 ff		eor #$ff			eor 	#$FF
.1847	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1849	7a		ply				ply 								; restore Y
.184a	4c 27 10	jmp $1027			jmp 	NextCommand
.184d					_UJNoHardware:
.184d	fa		plx				plx
.184e	7a		ply				ply
.184f	a9 01		lda #$01			lda 	#1 							; set result to -1
.1851	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.1854	20 c8 2d	jsr $2dc8			jsr 	FloatNegate
.1857	4c 27 10	jmp $1027			jmp 	NextCommand
.185a					UnaryLen:
.185a	fa		plx				plx
.185b	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.185d	85 2c		sta $2c				sta 	zTemp0
.185f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1861	85 2d		sta $2d				sta 	zTemp0+1
.1863	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.1865	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.1868	4c 27 10	jmp $1027			jmp 	NextCommand
.186b					LinkFloatAdd:
.186b	fa		plx				plx
.186c	5a		phy			phy
.186d	20 2a 28	jsr $282a		jsr	FloatAdd
.1870	7a		ply			ply
.1871	4c 27 10	jmp $1027			jmp 	NextCommand
.1874					LinkFloatSubtract:
.1874	fa		plx				plx
.1875	5a		phy			phy
.1876	20 24 28	jsr $2824		jsr	FloatSubtract
.1879	7a		ply			ply
.187a	4c 27 10	jmp $1027			jmp 	NextCommand
.187d					LinkFloatMultiply:
.187d	fa		plx				plx
.187e	5a		phy			phy
.187f	20 c6 2a	jsr $2ac6		jsr	FloatMultiply
.1882	7a		ply			ply
.1883	4c 27 10	jmp $1027			jmp 	NextCommand
.1886					LinkFloatDivide:
.1886	fa		plx				plx
.1887	5a		phy			phy
.1888	20 4f 29	jsr $294f		jsr	FloatDivide
.188b	b0 5c		bcs $18e9		bcs	DivZeroError
.188d	7a		ply			ply
.188e	4c 27 10	jmp $1027			jmp 	NextCommand
.1891					LinkFloatPower:
.1891	fa		plx				plx
.1892	5a		phy			phy
.1893	20 cf 30	jsr $30cf		jsr	FloatPower
.1896	b0 4e		bcs $18e6		bcs	MapRangeError
.1898	7a		ply			ply
.1899	4c 27 10	jmp $1027			jmp 	NextCommand
.189c					LinkCompareGreater:
.189c	fa		plx				plx
.189d	5a		phy			phy
.189e	20 d3 28	jsr $28d3		jsr	CompareGreater
.18a1	7a		ply			ply
.18a2	4c 27 10	jmp $1027			jmp 	NextCommand
.18a5					LinkCompareEqual:
.18a5	fa		plx				plx
.18a6	5a		phy			phy
.18a7	20 b5 28	jsr $28b5		jsr	CompareEqual
.18aa	7a		ply			ply
.18ab	4c 27 10	jmp $1027			jmp 	NextCommand
.18ae					LinkCompareLess:
.18ae	fa		plx				plx
.18af	5a		phy			phy
.18b0	20 cb 28	jsr $28cb		jsr	CompareLess
.18b3	7a		ply			ply
.18b4	4c 27 10	jmp $1027			jmp 	NextCommand
.18b7					LinkCompareGreaterEqual:
.18b7	fa		plx				plx
.18b8	5a		phy			phy
.18b9	20 e3 28	jsr $28e3		jsr	CompareGreaterEqual
.18bc	7a		ply			ply
.18bd	4c 27 10	jmp $1027			jmp 	NextCommand
.18c0					LinkCompareNotEqual:
.18c0	fa		plx				plx
.18c1	5a		phy			phy
.18c2	20 c5 28	jsr $28c5		jsr	CompareNotEqual
.18c5	7a		ply			ply
.18c6	4c 27 10	jmp $1027			jmp 	NextCommand
.18c9					LinkCompareLessEqual:
.18c9	fa		plx				plx
.18ca	5a		phy			phy
.18cb	20 db 28	jsr $28db		jsr	CompareLessEqual
.18ce	7a		ply			ply
.18cf	4c 27 10	jmp $1027			jmp 	NextCommand
.18d2					LinkFloatIntegerPartDown:
.18d2	fa		plx				plx
.18d3	5a		phy			phy
.18d4	20 65 2a	jsr $2a65		jsr	FloatIntegerPartDown
.18d7	7a		ply			ply
.18d8	4c 27 10	jmp $1027			jmp 	NextCommand
.18db					LinkFloatSquareRoot:
.18db	fa		plx				plx
.18dc	5a		phy			phy
.18dd	20 51 31	jsr $3151		jsr	FloatSquareRoot
.18e0	b0 04		bcs $18e6		bcs	MapRangeError
.18e2	7a		ply			ply
.18e3	4c 27 10	jmp $1027			jmp 	NextCommand
.18e6					MapRangeError:
.18e6	4c a3 26	jmp $26a3		jmp	ErrorV_range
.18e9					DivZeroError:
.18e9	4c 2c 27	jmp $272c		jmp	ErrorV_divzero
.18ec					LinkFloatLogarithm:
.18ec	fa		plx				plx
.18ed	5a		phy			phy
.18ee	20 5b 30	jsr $305b		jsr	FloatLogarithm
.18f1	b0 f3		bcs $18e6		bcs	MapRangeError
.18f3	7a		ply			ply
.18f4	4c 27 10	jmp $1027			jmp 	NextCommand
.18f7					LinkFloatExponent:
.18f7	fa		plx				plx
.18f8	5a		phy			phy
.18f9	20 58 2f	jsr $2f58		jsr	FloatExponent
.18fc	7a		ply			ply
.18fd	4c 27 10	jmp $1027			jmp 	NextCommand
.1900					LinkFloatCosine:
.1900	fa		plx				plx
.1901	5a		phy			phy
.1902	20 4c 2f	jsr $2f4c		jsr	FloatCosine
.1905	7a		ply			ply
.1906	4c 27 10	jmp $1027			jmp 	NextCommand
.1909					LinkFloatSine:
.1909	fa		plx				plx
.190a	5a		phy			phy
.190b	20 ec 30	jsr $30ec		jsr	FloatSine
.190e	7a		ply			ply
.190f	4c 27 10	jmp $1027			jmp 	NextCommand
.1912					LinkFloatTangent:
.1912	fa		plx				plx
.1913	5a		phy			phy
.1914	20 5d 31	jsr $315d		jsr	FloatTangent
.1917	7a		ply			ply
.1918	4c 27 10	jmp $1027			jmp 	NextCommand
.191b					LinkFloatArcTan:
.191b	fa		plx				plx
.191c	5a		phy			phy
.191d	20 31 2e	jsr $2e31		jsr	FloatArcTan
.1920	b0 c4		bcs $18e6		bcs	MapRangeError
.1922	7a		ply			ply
.1923	4c 27 10	jmp $1027			jmp 	NextCommand
.1926					LinkFloatCompare:
.1926	fa		plx				plx
.1927	5a		phy			phy
.1928	20 eb 28	jsr $28eb		jsr	FloatCompare
.192b	7a		ply			ply
.192c	4c 27 10	jmp $1027			jmp 	NextCommand
.192f					LinkDivideInt32:
.192f	fa		plx				plx
.1930	5a		phy			phy
.1931	20 79 29	jsr $2979		jsr	DivideInt32
.1934	b0 b0		bcs $18e6		bcs	MapRangeError
.1936	7a		ply			ply
.1937	4c 27 10	jmp $1027			jmp 	NextCommand
.193a					StackSaveCurrentPosition:
.193a	20 92 10	jsr $1092			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.193d	5a		phy				phy
.193e	a0 02		ldy #$02			ldy 	#2
.1940	a5 28		lda $28				lda 	codePtr
.1942	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1944	c8		iny				iny
.1945	a5 29		lda $29				lda 	codePtr+1
.1947	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1949	7a		ply				ply
.194a	60		rts				rts
.194b					StackLoadCurrentPosition:
.194b	a0 02		ldy #$02			ldy 	#2
.194d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.194f	85 28		sta $28				sta 	codePtr
.1951	c8		iny				iny
.1952	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1954	85 29		sta $29				sta 	codePtr+1
.1956	a0 00		ldy #$00			ldy 	#0
.1958	60		rts				rts
.1959					XCommandMouse:
.1959	fa		plx				plx
.195a	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; mouse control.
.195d	ca		dex				dex
.195e	da		phx				phx
.195f	5a		phy				phy
.1960	48		pha				pha
.1961	38		sec				sec 								; get screen resolution
.1962	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1965	68		pla				pla
.1966	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.1969	7a		ply				ply
.196a	fa		plx				plx
.196b	4c 27 10	jmp $1027			jmp 	NextCommand
.196e					XUnaryMB:
.196e	fa		plx				plx
.196f	20 9d 19	jsr $199d			jsr 	XUnaryMouseCommon
.1972	a5 30		lda $30				lda 	zTemp2
.1974	e8		inx				inx
.1975	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.1978	4c 27 10	jmp $1027			jmp 	NextCommand
.197b					XUnaryMX:
.197b	fa		plx				plx
.197c	20 9d 19	jsr $199d			jsr 	XUnaryMouseCommon
.197f	a5 2c		lda $2c				lda 	zTemp0
.1981	e8		inx				inx
.1982	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.1985	a5 2d		lda $2d				lda 	zTemp0+1
.1987	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1989	4c 27 10	jmp $1027			jmp 	NextCommand
.198c					XUnaryMY:
.198c	fa		plx				plx
.198d	20 9d 19	jsr $199d			jsr 	XUnaryMouseCommon
.1990	a5 2e		lda $2e				lda 	zTemp1
.1992	e8		inx				inx
.1993	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.1996	a5 2f		lda $2f				lda 	zTemp1+1
.1998	95 4a		sta $4a,x			sta 	NSMantissa1,x
.199a	4c 27 10	jmp $1027			jmp 	NextCommand
.199d					XUnaryMouseCommon:
.199d	da		phx				phx
.199e	5a		phy				phy
.199f	a2 2c		ldx #$2c			ldx 	#zTemp0
.19a1	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.19a4	85 30		sta $30				sta 	zTemp2
.19a6	7a		ply				ply
.19a7	fa		plx				plx
.19a8	60		rts				rts
.19a9					NegateTOS:
.19a9	fa		plx				plx
.19aa	20 c8 2d	jsr $2dc8			jsr 	FloatNegate
.19ad	4c 27 10	jmp $1027			jmp 	NextCommand
.19b0					CommandNewLine:
.19b0	fa		plx				plx
.19b1	9c 68 05	stz $0568			stz 	stringInitialised
.19b4	a2 ff		ldx #$ff			ldx 	#$FF
.19b6	4c 27 10	jmp $1027			jmp 	NextCommand
.19b9					CommandNext:
.19b9	fa		plx				plx
.19ba					_CNRetry:
.19ba	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.19bc	20 1f 15	jsr $151f			jsr 	StackFindFrame
.19bf	20 92 10	jsr $1092			jsr 	FixUpY 						; so we can use Y
.19c2	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.19c4	35 4a		and $4a,x			and 	NSMantissa1,x
.19c6	c9 ff		cmp #$ff			cmp 	#$FF
.19c8	f0 16		beq $19e0			beq 	_CNNoIndexVariable
.19ca	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.19cc	a0 05		ldy #$05			ldy 	#5
.19ce	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.19d0	d0 07		bne $19d9			bne 	_CNNIndexFail
.19d2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.19d4	c8		iny				iny
.19d5	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.19d7	f0 07		beq $19e0			beq 	_CNNoIndexVariable
.19d9					_CNNIndexFail:
.19d9	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.19db	20 11 15	jsr $1511			jsr 	StackCloseFrame 			; close this frame
.19de	80 da		bra $19ba			bra 	_CNRetry
.19e0					_CNNoIndexVariable:
.19e0	ca		dex				dex
.19e1	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.19e3	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.19e5	29 40		and #$40			and 	#$40	 					; bit 6
.19e7	d0 55		bne $1a3e			bne 	_CNOptimisedNext
.19e9	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.19eb	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.19ed	48		pha				pha
.19ee	85 2c		sta $2c				sta 	zTemp0
.19f0	c8		iny				iny
.19f1	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.19f3	18		clc				clc
.19f4	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.19f7	48		pha				pha
.19f8	85 2d		sta $2d				sta 	zTemp0+1
.19fa	20 b2 1c	jsr $1cb2			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.19fd	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.19ff	e8		inx				inx
.1a00	20 81 1a	jsr $1a81			jsr 	CopyOffsetYToTOS
.1a03	20 2a 28	jsr $282a			jsr 	FloatAdd
.1a06	68		pla				pla 								; restore address
.1a07	85 2d		sta $2d				sta 	zTemp0+1
.1a09	68		pla				pla
.1a0a	85 2c		sta $2c				sta 	zTemp0
.1a0c	20 8d 22	jsr $228d			jsr 	WriteFloatZTemp0Sub			; write float.
.1a0f	e8		inx				inx  								; recover written
.1a10	e8		inx				inx 								; load offset
.1a11	a0 0d		ldy #$0d			ldy 	#13
.1a13	20 81 1a	jsr $1a81			jsr 	CopyOffsetYToTOS
.1a16	20 eb 28	jsr $28eb			jsr 	FloatCompare 				; and compare the floats.
.1a19	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1a1a	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.1a1c	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a1e	30 08		bmi $1a28			bmi 	_CNDownStep
.1a20	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1a22	c9 01		cmp #$01			cmp 	#1 							; gone higher
.1a24	f0 10		beq $1a36			beq 	_CNExitFor 					; if so exit the loop
.1a26	80 06		bra $1a2e			bra 	_CNLoopBack
.1a28					_CNDownStep:
.1a28	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1a2a	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.1a2c	f0 08		beq $1a36			beq 	_CNExitFor
.1a2e					_CNLoopBack:
.1a2e	20 4b 19	jsr $194b			jsr 	StackLoadCurrentPosition 	; loop back
.1a31	a0 00		ldy #$00			ldy 	#0
.1a33	4c 27 10	jmp $1027			jmp 	NextCommand
.1a36					_CNExitFor:
.1a36	20 11 15	jsr $1511			jsr 	StackCloseFrame 			; remove the frame and exit
.1a39	a0 00		ldy #$00			ldy 	#0
.1a3b	4c 27 10	jmp $1027			jmp 	NextCommand
.1a3e					_CNOptimisedNext:
.1a3e	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1a40	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a42	85 2c		sta $2c				sta 	zTemp0
.1a44	c8		iny				iny
.1a45	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a47	18		clc				clc
.1a48	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1a4b	85 2d		sta $2d				sta 	zTemp0+1
.1a4d	a0 07		ldy #$07			ldy 	#7 							; STEP value
.1a4f	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a51	a0 ff		ldy #$ff			ldy 	#$FF
.1a53	18		clc				clc
.1a54					_CNOIncrement:
.1a54	c8		iny				iny
.1a55	71 2c		adc ($2c),y			adc 	(zTemp0),y
.1a57	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1a59	f0 f9		beq $1a54			beq 	_CNOIncrement
.1a5b	18		clc				clc
.1a5c	a5 24		lda $24				lda 	runtimeStackPtr
.1a5e	69 0d		adc #$0d			adc 	#13
.1a60	85 2e		sta $2e				sta 	zTemp1
.1a62	a5 25		lda $25				lda 	runtimeStackPtr+1
.1a64	69 00		adc #$00			adc 	#0
.1a66	85 2f		sta $2f				sta 	zTemp1+1
.1a68	a0 00		ldy #$00			ldy 	#0
.1a6a	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.1a6c	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.1a6e	c8		iny				iny
.1a6f	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.1a71	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1a73	c8		iny				iny
.1a74	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.1a76	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1a78	c8		iny				iny
.1a79	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.1a7b	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1a7d	90 b7		bcc $1a36			bcc	 	_CNExitFor
.1a7f	80 ad		bra $1a2e			bra 	_CNLoopBack
.1a81					CopyOffsetYToTOS:
.1a81	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a83	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1a85	c8		iny				iny
.1a86	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a88	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1a8a	c8		iny				iny
.1a8b	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a8d	95 56		sta $56,x			sta 	NSMantissa2,x
.1a8f	c8		iny				iny
.1a90	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a92	95 62		sta $62,x			sta 	NSMantissa3,x
.1a94	c8		iny				iny
.1a95	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a97	95 6e		sta $6e,x			sta 	NSExponent,x
.1a99	c8		iny				iny
.1a9a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1a9c	95 32		sta $32,x			sta 	NSStatus,x
.1a9e	60		rts				rts
.1a9f	4c 27 10	jmp $1027			jmp 	NextCommand
.1aa2					NotTOS:
.1aa2	fa		plx				plx
.1aa3	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.1aa6	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.1aa8	74 62		stz $62,x			stz 	NSMantissa3,x
.1aaa	20 c8 2d	jsr $2dc8			jsr 	FloatNegate		 			; negate
.1aad	e8		inx				inx 								; and subtract 1.
.1aae	a9 01		lda #$01			lda 	#1
.1ab0	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.1ab3	20 24 28	jsr $2824			jsr 	FloatSubtract
.1ab6					_NotTOSSkip:
.1ab6	4c 27 10	jmp $1027			jmp 	NextCommand
.1ab9					CommandOn:
.1ab9	fa		plx				plx
.1aba	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.1abd	8d 5c 04	sta $045c			sta 	onCount 					; save it.
.1ac0	20 92 10	jsr $1092			jsr 	FixUpY 						; Y = 0
.1ac3					_CONFind:
.1ac3	ce 5c 04	dec $045c			dec 	onCount 					; reached zero, do this one
.1ac6	f0 0b		beq $1ad3			beq 	_CONFound
.1ac8	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1ac9	c8		iny				iny
.1aca	c8		iny				iny
.1acb	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.1acd	c8		iny				iny
.1ace	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.1ad0	f0 f1		beq $1ac3			beq 	_CONFind
.1ad2	88		dey				dey 								; point to character after last GOTO/GOSUB
.1ad3					_CONFound:
.1ad3	4c 27 10	jmp $1027			jmp 	NextCommand
.1ad6					CommandMoreOn:
.1ad6	fa		plx				plx
.1ad7	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1ad8	c8		iny				iny
.1ad9	c8		iny				iny
.1ada	4c 27 10	jmp $1027			jmp 	NextCommand
.045c					onCount:
>045c							.fill 	1
.1add					UnaryPeek:
.1add	fa		plx				plx
.1ade	20 09 18	jsr $1809			jsr 	GetInteger16Bit
.1ae1	da		phx				phx
.1ae2	5a		phy				phy
.1ae3	a6 2c		ldx $2c				ldx 	zTemp0
.1ae5	a4 2d		ldy $2d				ldy 	zTemp0+1
.1ae7	20 1e 24	jsr $241e			jsr 	XPeekMemory
.1aea	7a		ply				ply
.1aeb	fa		plx				plx
.1aec	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.1aef	4c 27 10	jmp $1027			jmp 	NextCommand
.1af2					CommandPOKE:
.1af2	fa		plx				plx
.1af3	da		phx				phx 								; save XY
.1af4	5a		phy				phy
.1af5	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1af8	48		pha				pha
.1af9	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1afb	a8		tay				tay
.1afc	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1afe	aa		tax				tax
.1aff	68		pla				pla
.1b00	20 0a 24	jsr $240a			jsr 	XPokeMemory
.1b03	7a		ply				ply 								; restore YX and drop 2
.1b04	fa		plx				plx
.1b05	ca		dex				dex
.1b06	ca		dex				dex
.1b07	4c 27 10	jmp $1027			jmp 	NextCommand
.1b0a					UnaryPos:
.1b0a	fa		plx				plx
.1b0b	20 9d 23	jsr $239d			jsr 	XGetHPos
.1b0e	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.1b11	4c 27 10	jmp $1027			jmp 	NextCommand
.1b14					GetChannel:
.1b14	fa		plx				plx
.1b15	ad 5d 04	lda $045d			lda 	currentChannel
.1b18	e8		inx				inx
.1b19	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.1b1c	4c 27 10	jmp $1027			jmp 	NextCommand
.1b1f					SetChannel:
.1b1f	fa		plx				plx
.1b20	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.1b23	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b25	8d 5d 04	sta $045d			sta 	currentChannel
.1b28	ca		dex				dex
.1b29	4c 27 10	jmp $1027			jmp 	NextCommand
.1b2c					SetDefaultChannel:
.1b2c	9c 5d 04	stz $045d			stz 	currentChannel
.1b2f	60		rts				rts
.1b30					VectorPrintCharacter:
.1b30	da		phx				phx
.1b31	ae 5d 04	ldx $045d			ldx 	currentChannel
.1b34	20 48 24	jsr $2448			jsr 	XPrintCharacterToChannel
.1b37	fa		plx				plx
.1b38	60		rts				rts
.1b39					VectorGetCharacter:
.1b39	da		phx				phx
.1b3a	ae 5d 04	ldx $045d			ldx 	currentChannel
.1b3d	20 81 23	jsr $2381			jsr 	XGetCharacterFromChannel
.1b40	fa		plx				plx
.1b41	60		rts				rts
.045d					currentChannel:
>045d							.fill 	1
.1b42					PrintNumber:
.1b42	fa		plx				plx
.1b43	a9 07		lda #$07			lda 	#7
.1b45	20 ee 2c	jsr $2cee			jsr 	FloatToString 				; to number in decimal buffer
.1b48	ca		dex				dex 								; drop
.1b49	da		phx				phx
.1b4a	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1b4c					_PNLoop:
.1b4c	bd 94 05	lda $0594,x			lda 	decimalBuffer,x
.1b4f	20 30 1b	jsr $1b30			jsr 	VectorPrintCharacter
.1b52	e8		inx				inx
.1b53	bd 94 05	lda $0594,x			lda	 	decimalBuffer,x
.1b56	d0 f4		bne $1b4c			bne 	_PNLoop
.1b58	a9 20		lda #$20			lda 	#32 						; trailing space
.1b5a	20 30 1b	jsr $1b30			jsr 	VectorPrintCharacter
.1b5d	fa		plx				plx
.1b5e	4c 27 10	jmp $1027			jmp 	NextCommand
.1b61					PrintString:
.1b61	fa		plx				plx
.1b62	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.1b64	85 2c		sta $2c				sta 	zTemp0
.1b66	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b68	85 2d		sta $2d				sta 	zTemp0+1
.1b6a	ca		dex				dex 								; drop
.1b6b	da		phx				phx
.1b6c	5a		phy				phy
.1b6d	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.1b6f	aa		tax				tax
.1b70	a0 01		ldy #$01			ldy 	#1 							; Y = position
.1b72					_PSLoop:
.1b72	e0 00		cpx #$00			cpx 	#0 							; complete ?
.1b74	f0 09		beq $1b7f			beq 	_PSExit
.1b76	ca		dex				dex 								; dec count
.1b77	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.1b79	20 30 1b	jsr $1b30			jsr 	VectorPrintCharacter
.1b7c	c8		iny				iny
.1b7d	80 f3		bra $1b72			bra 	_PSLoop
.1b7f					_PSExit:
.1b7f	7a		ply				ply
.1b80	fa		plx				plx
.1b81	4c 27 10	jmp $1027			jmp 	NextCommand
.1b84					CommandPushN:
.1b84	fa		plx				plx
.1b85	e8		inx				inx 								; next slot on stack
.1b86	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.1b88	95 6e		sta $6e,x			sta 	NSExponent,x
.1b8a	c8		iny				iny
.1b8b	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.1b8d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1b8f	c8		iny				iny
.1b90	b1 28		lda ($28),y			lda 	(codePtr),y
.1b92	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1b94	c8		iny				iny
.1b95	b1 28		lda ($28),y			lda 	(codePtr),y
.1b97	95 56		sta $56,x			sta 	NSMantissa2,x
.1b99	c8		iny				iny
.1b9a	b1 28		lda ($28),y			lda 	(codePtr),y
.1b9c	48		pha				pha
.1b9d	29 7f		and #$7f			and 	#$7F
.1b9f	95 62		sta $62,x			sta 	NSMantissa3,x
.1ba1	68		pla				pla 								; sign in mantissa3:7
.1ba2	29 80		and #$80			and 	#$80
.1ba4	95 32		sta $32,x			sta 	NSStatus,x
.1ba6	c8		iny				iny
.1ba7	4c 27 10	jmp $1027			jmp 	NextCommand
.1baa					CommandPushS:
.1baa	fa		plx				plx
.1bab	e8		inx				inx 								; next slot on stack
.1bac	18		clc				clc
.1bad	98		tya				tya
.1bae	65 28		adc $28				adc 	codePtr 					; the string is inline
.1bb0	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1bb2	a5 29		lda $29				lda 	codePtr+1
.1bb4	69 00		adc #$00			adc 	#0
.1bb6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1bb8	74 56		stz $56,x			stz 	NSMantissa2,x
.1bba	74 62		stz $62,x			stz 	NSMantissa3,x
.1bbc	a9 40		lda #$40			lda 	#NSSString
.1bbe	95 32		sta $32,x			sta 	NSStatus,x
.1bc0	98		tya				tya 								; string length +1 added to Y
.1bc1	38		sec				sec
.1bc2	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.1bc4	a8		tay				tay
.1bc5	4c 27 10	jmp $1027			jmp 	NextCommand
.1bc8					CommandRead:
.1bc8	fa		plx				plx
.1bc9	5a		phy				phy 								; save Y
.1bca	20 fb 1b	jsr $1bfb			jsr 	ReadStringToBuffer 			; read element into buffer
.1bcd	e8		inx				inx									; space on stack
.1bce	a9 5f		lda #$5f			lda 	#((ReadBufferSize) & $FF)
.1bd0	85 2c		sta $2c				sta 	0+zTemp0
.1bd2	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.1bd4	85 2d		sta $2d				sta 	1+zTemp0
.1bd6	20 1a 21	jsr $211a			jsr 	ValEvaluateZTemp0
.1bd9	b0 04		bcs $1bdf			bcs 	_CRError 					; failed
.1bdb	7a		ply				ply 								; restore Y
.1bdc	4c 27 10	jmp $1027			jmp 	NextCommand
.1bdf					_CRError:
.1bdf	4c b3 26	jmp $26b3		jmp	ErrorV_value
.1be2					CommandReadString:
.1be2	fa		plx				plx
.1be3	5a		phy				phy 								; save Y
.1be4	20 fb 1b	jsr $1bfb			jsr 	ReadStringToBuffer 			; read text
.1be7	e8		inx				inx 								; make space on stack
.1be8	20 06 2e	jsr $2e06			jsr 	FloatSetZero 				; store as string on stack
.1beb	a9 5f		lda #$5f			lda 	#ReadBufferSize & $FF
.1bed	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1bef	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.1bf1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1bf3	a9 40		lda #$40			lda 	#NSSString
.1bf5	95 32		sta $32,x			sta 	NSStatus,x
.1bf7	7a		ply				ply 								; restore Y
.1bf8	4c 27 10	jmp $1027			jmp 	NextCommand
.1bfb					ReadStringToBuffer:
.1bfb	a9 8e		lda #$8e			lda 	#((ReadBumpNext) & $FF)
.1bfd	8d 5f 05	sta $055f			sta 	0+ReadBumpNextVec
.1c00	a9 1c		lda #$1c			lda 	#((ReadBumpNext) >> 8) & $FF
.1c02	8d 60 05	sta $0560			sta 	1+ReadBumpNextVec
.1c05	a9 61		lda #$61			lda 	#((ReadLookNext) & $FF)
.1c07	8d 61 05	sta $0561			sta 	0+ReadLookNextVec
.1c0a	a9 1c		lda #$1c			lda 	#((ReadLookNext) >> 8) & $FF
.1c0c	8d 62 05	sta $0562			sta 	1+ReadLookNextVec
.1c0f					GetStringToBuffer:
.1c0f	20 5e 1c	jsr $1c5e			jsr		GetLookNext 				; skip all leading spaces.
.1c12	f0 44		beq $1c58			beq 	_RBError 					; end of data
.1c14	b0 f9		bcs $1c0f			bcs 	GetStringToBuffer 			; switched to new data line.
.1c16	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1c18	b0 05		bcs $1c1f			bcs 	_RBNoSpace
.1c1a	20 5b 1c	jsr $1c5b			jsr 	GetBumpNext 				; consume space and loop round.
.1c1d	80 f0		bra $1c0f			bra 	GetStringToBuffer
.1c1f					_RBNoSpace:
.1c1f	9c 5f 04	stz $045f			stz 	ReadBufferSize 				; empty the buffer.
.1c22	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.1c24	d0 08		bne $1c2e			bne 	_RBCommaSep
.1c26	8d 5e 04	sta $045e			sta 	ReadSep 					; use as a seperator
.1c29	20 5b 1c	jsr $1c5b			jsr 	GetBumpNext 				; consume the '"'
.1c2c	80 05		bra $1c33			bra 	_RBGetText
.1c2e					_RBCommaSep:
.1c2e	a9 2c		lda #$2c			lda 	#","						; get till comma
.1c30	8d 5e 04	sta $045e			sta 	ReadSep
.1c33					_RBGetText:
.1c33	20 5e 1c	jsr $1c5e			jsr 	GetLookNext 				; what follows
.1c36	b0 18		bcs $1c50			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.1c38	20 5b 1c	jsr $1c5b			jsr 	GetBumpNext 				; consume it whatever
.1c3b	cd 5e 04	cmp $045e			cmp 	ReadSep 					; if found the seperator.
.1c3e	f0 10		beq $1c50			beq 	_RBEndGet 					; exit after consumption
.1c40	da		phx				phx
.1c41	ae 5f 04	ldx $045f			ldx 	ReadBufferSize 				; copy into buffer.
.1c44	ee 5f 04	inc $045f			inc 	ReadBufferSize
.1c47	9d 60 04	sta $0460,x			sta 	ReadBuffer,x
.1c4a	9e 61 04	stz $0461,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.1c4d	fa		plx				plx
.1c4e	80 e3		bra $1c33			bra 	_RBGetText
.1c50					_RBEndGet:
.1c50	c9 22		cmp #$22			cmp 	#'"'
.1c52	d0 03		bne $1c57			bne 	_RBNotQuote
.1c54	20 5b 1c	jsr $1c5b			jsr 	GetBumpNext
.1c57					_RBNotQuote:
.1c57	60		rts				rts
.1c58					_RBError:
.1c58	4c 68 27	jmp $2768		jmp	ErrorV_data
.1c5b					GetBumpNext:
.1c5b	6c 5f 05	jmp ($055f)			jmp 	(ReadBumpNextVec)
.1c5e					GetLookNext:
.1c5e	6c 61 05	jmp ($0561)			jmp 	(ReadLookNextVec)
.1c61					ReadLookNext:
.1c61	ad 63 05	lda $0563			lda 	dataRemaining 				; any data remaining
.1c64	f0 04		beq $1c6a			beq 	_RLNFindData
.1c66	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.1c68	18		clc				clc
.1c69	60		rts				rts
.1c6a					_RLNFindData:
.1c6a	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.1c6c	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.1c6e	f0 1a		beq $1c8a			beq 	_RLNNoData
.1c70	c9 cf		cmp #$cf			cmp 	#PCD_CMD_DATA 				; Found DATA
.1c72	f0 05		beq $1c79			beq 	_RLNHaveData
.1c74					_RLNNext:
.1c74	20 d5 27	jsr $27d5			jsr 	MoveObjectForward			; else scan forward.
.1c77	80 f1		bra $1c6a			bra 	_RLNFindData
.1c79					_RLNHaveData:
.1c79	a0 01		ldy #$01			ldy 	#1 							; get length
.1c7b	b1 2a		lda ($2a),y			lda 	(objPtr),y
.1c7d	f0 f5		beq $1c74			beq 	_RLNNext 					; skip if DATA alone
.1c7f	20 8e 1c	jsr $1c8e			jsr 	ReadBumpNext 				; advance by two
.1c82	20 8e 1c	jsr $1c8e			jsr 	ReadBumpNext
.1c85	8d 63 05	sta $0563			sta 	dataRemaining 				; set data left count.
.1c88	38		sec				sec
.1c89	60		rts				rts
.1c8a					_RLNNoData:
.1c8a	a9 00		lda #$00			lda 	#0
.1c8c	38		sec				sec
.1c8d	60		rts				rts
.1c8e					ReadBumpNext:
.1c8e	e6 2a		inc $2a				inc 	objPtr
.1c90	d0 02		bne $1c94			bne 	_RBNSkip
.1c92	e6 2b		inc $2b				inc 	objPtr+1
.1c94					_RBNSkip:
.1c94	ce 63 05	dec $0563			dec 	dataRemaining
.1c97	60		rts				rts
.045e					ReadSep:
>045e							.fill 	1
.045f					ReadBufferSize:
>045f							.fill 	1
.0460					ReadBuffer:
>0460							.fill 	255
.055f					ReadBumpNextVec:
>055f							.fill 	2
.0561					ReadLookNextVec:
>0561							.fill 	2
.1c98					ReadFloatCommand:
.1c98	fa		plx				plx
.1c99	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1c9b	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1c9d	88		dey				dey 								; get the upper 3 bits
.1c9e	b1 28		lda ($28),y			lda 	(codePtr),y
.1ca0	29 07		and #$07			and 	#7
.1ca2	c8		iny				iny
.1ca3	c8		iny				iny
.1ca4	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1ca6	2a		rol a				rol 	a 							; carry will be clear.
.1ca7	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1caa	85 2d		sta $2d				sta 	zTemp0+1
.1cac	20 b2 1c	jsr $1cb2			jsr 	ReadFloatZTemp0Sub
.1caf	4c 27 10	jmp $1027			jmp 	NextCommand
.1cb2					ReadFloatZTemp0Sub:
.1cb2	5a		phy				phy 								; start write
.1cb3	a0 01		ldy #$01			ldy 	#1
.1cb5	e8		inx				inx
.1cb6	b2 2c		lda ($2c)			lda 	(zTemp0)
.1cb8	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1cba	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1cbc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1cbe	c8		iny				iny
.1cbf	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1cc1	95 56		sta $56,x			sta 	NSMantissa2,x
.1cc3	c8		iny				iny
.1cc4	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1cc6	95 62		sta $62,x			sta 	NSMantissa3,x
.1cc8	c8		iny				iny
.1cc9	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1ccb	95 6e		sta $6e,x			sta 	NSExponent,x
.1ccd	c8		iny				iny
.1cce	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1cd0	95 32		sta $32,x			sta 	NSStatus,x
.1cd2	7a		ply				ply
.1cd3	60		rts				rts
.1cd4					ReadIntegerCommand:
.1cd4	fa		plx				plx
.1cd5	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1cd7	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1cd9	88		dey				dey 								; get the upper 3 bits
.1cda	b1 28		lda ($28),y			lda 	(codePtr),y
.1cdc	29 07		and #$07			and 	#7
.1cde	c8		iny				iny
.1cdf	c8		iny				iny
.1ce0	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1ce2	2a		rol a				rol 	a 							; carry will be clear.
.1ce3	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1ce6	85 2d		sta $2d				sta 	zTemp0+1
.1ce8	20 ee 1c	jsr $1cee			jsr 	ReadIntegerZTemp0Sub
.1ceb	4c 27 10	jmp $1027			jmp 	NextCommand
.1cee					ReadIntegerZTemp0Sub:
.1cee	5a		phy				phy 								; start write
.1cef	a0 01		ldy #$01			ldy 	#1
.1cf1	e8		inx				inx 								; prepare
.1cf2	74 56		stz $56,x			stz 	NSMantissa2,x
.1cf4	74 62		stz $62,x			stz 	NSMantissa3,x
.1cf6	74 6e		stz $6e,x			stz 	NSExponent,x
.1cf8	74 32		stz $32,x			stz 	NSStatus,x
.1cfa	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1cfc	30 08		bmi $1d06			bmi 	_RIZNegative
.1cfe	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1d00	b2 2c		lda ($2c)			lda 	(zTemp0)
.1d02	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1d04	7a		ply				ply
.1d05	60		rts				rts
.1d06					_RIZNegative:
.1d06	38		sec				sec 								; -ve read
.1d07	a9 00		lda #$00			lda 	#0
.1d09	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.1d0b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1d0d	a9 00		lda #$00			lda 	#0
.1d0f	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1d11	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1d13	a9 80		lda #$80			lda 	#$80
.1d15	95 32		sta $32,x			sta 	NSStatus,x
.1d17	7a		ply				ply
.1d18	60		rts				rts
.1d19					ReadStringCommand:
.1d19	fa		plx				plx
.1d1a	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1d1c	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1d1e	88		dey				dey 								; get the upper 3 bits
.1d1f	b1 28		lda ($28),y			lda 	(codePtr),y
.1d21	29 07		and #$07			and 	#7
.1d23	c8		iny				iny
.1d24	c8		iny				iny
.1d25	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1d27	2a		rol a				rol 	a 							; carry will be clear.
.1d28	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1d2b	85 2d		sta $2d				sta 	zTemp0+1
.1d2d	20 33 1d	jsr $1d33			jsr 	ReadStringZTemp0Sub
.1d30	4c 27 10	jmp $1027			jmp 	NextCommand
.1d33					ReadStringZTemp0Sub:
.1d33	5a		phy				phy 								; start write
.1d34	e8		inx				inx 								; prepare
.1d35	74 56		stz $56,x			stz 	NSMantissa2,x
.1d37	74 62		stz $62,x			stz 	NSMantissa3,x
.1d39	74 6e		stz $6e,x			stz 	NSExponent,x
.1d3b	a9 40		lda #$40			lda 	#NSSString
.1d3d	74 32		stz $32,x			stz 	NSStatus,x
.1d3f	18		clc				clc
.1d40	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.1d42	69 02		adc #$02			adc 	#2 							; this points to actual data
.1d44	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.1d46	a0 01		ldy #$01			ldy 	#1
.1d48	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1d4a	69 00		adc #$00			adc 	#0
.1d4c	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1d4e	d0 08		bne $1d58			bne 	_RSZNoDefault 				; if read $00 use a default value.
.1d50	a9 5a		lda #$5a			lda 	#_RSZNull & $FF
.1d52	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1d54	a9 1d		lda #$1d			lda 	#_RSZNull >> 8
.1d56	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1d58					_RSZNoDefault:
.1d58	7a		ply				ply
.1d59	60		rts				rts
.1d5a					_RSZNull:
>1d5a	00						.byte 	0
.1d5b					CommandRestore:
.1d5b	fa		plx				plx
.1d5c	20 62 1d	jsr $1d62			jsr 	RestoreCode
.1d5f	4c 27 10	jmp $1027			jmp 	NextCommand
.1d62					RestoreCode:
.1d62	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.1d65	85 2b		sta $2b				sta 	objPtr+1
.1d67	64 2a		stz $2a				stz 	objPtr
.1d69	9c 63 05	stz $0563			stz 	dataRemaining 				; no data remaining.
.1d6c	60		rts				rts
.0563					dataRemaining:
>0563							.fill 	1		 					; 0 if not in data statement
.1d6d					UnaryRND:
.1d6d	fa		plx				plx
.1d6e	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.1d70	10 17		bpl $1d89			bpl 	_URNoSeed
.1d72	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise 				; some float value
.1d75	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.1d77	8d 64 05	sta $0564			sta 	randomSeed+0
.1d7a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1d7c	8d 65 05	sta $0565			sta 	randomSeed+1
.1d7f	b5 56		lda $56,x			lda 	NSMantissa2,x
.1d81	8d 66 05	sta $0566			sta 	randomSeed+2
.1d84	b5 62		lda $62,x			lda 	NSMantissa3,x
.1d86	8d 67 05	sta $0567			sta 	randomSeed+3
.1d89					_URNoSeed:
.1d89	20 ab 1d	jsr $1dab			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.1d8c	ad 64 05	lda $0564			lda 	randomSeed+0
.1d8f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1d91	ad 65 05	lda $0565			lda 	randomSeed+1
.1d94	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1d96	ad 66 05	lda $0566			lda 	randomSeed+2
.1d99	95 56		sta $56,x			sta 	NSMantissa2,x
.1d9b	ad 67 05	lda $0567			lda 	randomSeed+3
.1d9e	29 7f		and #$7f			and 	#$7F
.1da0	95 62		sta $62,x			sta 	NSMantissa3,x
.1da2	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.1da4	95 6e		sta $6e,x			sta 	NSExponent,x
.1da6	74 32		stz $32,x			stz 	NSStatus,x
.1da8	4c 27 10	jmp $1027			jmp 	NextCommand
.1dab					RandomNumberGenerator:
.1dab	5a		phy				phy
.1dac	ad 64 05	lda $0564			lda 	randomSeed+0 				; check if zero
.1daf	0d 65 05	ora $0565			ora 	randomSeed+1
.1db2	0d 66 05	ora $0566			ora 	randomSeed+2
.1db5	0d 67 05	ora $0567			ora 	randomSeed+3
.1db8	d0 07		bne $1dc1			bne 	_RNGNoSeed
.1dba	ce 67 05	dec $0567			dec 	randomSeed+3 				; if so tweak and flog
.1dbd	a0 64		ldy #$64			ldy 	#100
.1dbf	80 05		bra $1dc6			bra 	_RNGLoop
.1dc1					_RNGNoSeed:
.1dc1	a0 08		ldy #$08			ldy 	#8
.1dc3	ad 64 05	lda $0564			lda 	randomSeed+0
.1dc6					_RNGLoop:
.1dc6	0a		asl a				asl		a
.1dc7	2e 65 05	rol $0565			rol 	randomSeed+1
.1dca	2e 66 05	rol $0566			rol 	randomSeed+2
.1dcd	2e 67 05	rol $0567			rol 	randomSeed+3
.1dd0	90 02		bcc $1dd4			bcc		_RNGSkip
.1dd2	49 c5		eor #$c5			eor 	#$C5
.1dd4					_RNGSkip:
.1dd4	88		dey				dey
.1dd5	d0 ef		bne $1dc6			bne		_RNGLoop
.1dd7	8d 64 05	sta $0564			sta 	randomSeed+0
.1dda	7a		ply				ply
.1ddb	60		rts				rts
.0564					randomSeed:
>0564							.fill 	4
.1ddc					StringConcatenate:
.1ddc	fa		plx				plx
.1ddd	ca		dex				dex
.1dde	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.1de0	85 2e		sta $2e				sta 	zTemp1
.1de2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1de4	85 2f		sta $2f				sta 	zTemp1+1
.1de6	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.1de8	85 30		sta $30				sta 	zTemp2
.1dea	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.1dec	85 31		sta $31				sta 	zTemp2+1
.1dee	18		clc				clc 								; work out total length
.1def	b2 2e		lda ($2e)			lda 	(zTemp1)
.1df1	72 30		adc ($30)			adc 	(zTemp2)
.1df3	b0 18		bcs $1e0d			bcs 	_BCLength 					; more than 255 characters.
.1df5	48		pha				pha 								; save total
.1df6	20 d3 1e	jsr $1ed3			jsr 	StringAllocTemp 			; space for result.
.1df9	68		pla				pla 								; write total as first.
.1dfa	92 22		sta ($22)			sta 	(zsTemp)
.1dfc	20 10 1e	jsr $1e10			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.1dff	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.1e01	85 2e		sta $2e				sta 	zTemp1
.1e03	a5 31		lda $31				lda 	zTemp2+1
.1e05	85 2f		sta $2f				sta 	zTemp1+1
.1e07	20 10 1e	jsr $1e10			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1e0a	4c 27 10	jmp $1027			jmp 	NextCommand
.1e0d					_BCLength:
.1e0d	4c a3 26	jmp $26a3		jmp	ErrorV_range
.1e10					_BCCopyZTemp1:
.1e10	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.1e12	f0 15		beq $1e29			beq 	_BCCExit 					; none.
.1e14	da		phx				phx 								; save XY
.1e15	5a		phy				phy
.1e16	aa		tax				tax 								; count in X.
.1e17	a0 01		ldy #$01			ldy 	#1
.1e19					_BCCLoop:
.1e19	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1e1b	d0 02		bne $1e1f			bne 	_BCCNoCarry
.1e1d	e6 23		inc $23				inc 	zsTemp+1
.1e1f					_BCCNoCarry:
.1e1f	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.1e21	92 22		sta ($22)			sta 	(zsTemp)
.1e23	c8		iny				iny
.1e24	ca		dex				dex 								; X times
.1e25	d0 f2		bne $1e19			bne 	_BCCLoop
.1e27	7a		ply				ply 								; restore YX
.1e28	fa		plx				plx
.1e29					_BCCExit:
.1e29	60		rts				rts
.1e2a					XRuntimeSetup:
.1e2a	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1e2c	8d 6b 05	sta $056b	 		sta 	ramBank
.1e2f	8d 6c 05	sta $056c	 		sta 	romBank
.1e32	60		rts				rts
.1e33					SignTOS:
.1e33	fa		plx				plx
.1e34	20 28 2e	jsr $2e28			jsr 	FloatIsZero 				; if zero
.1e37	f0 0f		beq $1e48			beq 	_SGZero  					; return Int Zero
.1e39	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.1e3b	48		pha				pha
.1e3c	a9 01		lda #$01			lda 	#1 							; set result to 1
.1e3e	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.1e41	68		pla				pla
.1e42	29 80		and #$80			and		#$80 						; copy the sign byte out
.1e44	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.1e46	80 03		bra $1e4b			bra 	_SGExit
.1e48					_SGZero:
.1e48	20 06 2e	jsr $2e06			jsr 	FloatSetZero
.1e4b					_SGExit:
.1e4b	4c 27 10	jmp $1027			jmp 	NextCommand
.1e4e					CommandShift:
.1e4e	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.1e50	c8		iny				iny
.1e51	0a		asl a				asl 	a 							; double into X
.1e52	aa		tax				tax
.1e53	7c fe 21	jmp ($21fe,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.1e56					PrintTab:
.1e56	fa		plx				plx
.1e57	20 9d 23	jsr $239d			jsr 	XGetHPos
.1e5a					_PTMod10:
.1e5a	38		sec				sec
.1e5b	e9 0a		sbc #$0a			sbc 	#10
.1e5d	b0 fb		bcs $1e5a			bcs 	_PTMod10
.1e5f	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.1e61	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.1e62	80 15		bra $1e79			bra 	PrintSpaceLoop
.1e64					PrintPos:
.1e64	fa		plx				plx
.1e65	20 9d 23	jsr $239d			jsr		XGetHPos 					; get current position
.1e68	85 2c		sta $2c				sta 	zTemp0
.1e6a	38		sec				sec 								; calculate spaces required
.1e6b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e6d	ca		dex				dex
.1e6e	e5 2c		sbc $2c				sbc 	zTemp0
.1e70	b0 07		bcs $1e79			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.1e72	4c 27 10	jmp $1027			jmp 	NextCommand
.1e75					PrintSpace:
.1e75	fa		plx				plx
.1e76	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e78	ca		dex				dex
.1e79					PrintSpaceLoop:
.1e79	c9 00		cmp #$00			cmp 	#0
.1e7b	f0 0a		beq $1e87			beq 	_PSExit
.1e7d	48		pha				pha
.1e7e	a9 20		lda #$20			lda 	#" "
.1e80	20 30 1b	jsr $1b30			jsr 	VectorPrintCharacter
.1e83	68		pla				pla
.1e84	3a		dec a				dec 	a
.1e85	80 f2		bra $1e79			bra 	PrintSpaceLoop
.1e87					_PSExit:
.1e87	4c 27 10	jmp $1027			jmp 	NextCommand
.1e8a					CommandStop:
.1e8a	fa		plx				plx
.1e8b	4c 55 27	jmp $2755		jmp	ErrorV_stop
.1e8e					Unary_Str:
.1e8e	fa		plx				plx
.1e8f	5a		phy				phy
.1e90	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.1e92	20 ee 2c	jsr $2cee			jsr 	FloatToString 				; do the conversion.
.1e95	a9 21		lda #$21			lda		#33 						; create buffer
.1e97	20 d3 1e	jsr $1ed3			jsr 	StringAllocTemp 			; allocate memory
.1e9a	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.1e9c					_USCopy:
.1e9c	b9 93 05	lda $0593,y			lda 	decimalBuffer-1,y
.1e9f	f0 05		beq $1ea6			beq 	_USExit
.1ea1	91 22		sta ($22),y			sta 	(zsTemp),y
.1ea3	c8		iny				iny
.1ea4	80 f6		bra $1e9c			bra 	_USCopy
.1ea6					_USExit:
.1ea6	98		tya				tya
.1ea7	3a		dec a				dec 	a
.1ea8	92 22		sta ($22)			sta 	(zsTemp)
.1eaa	7a		ply				ply
.1eab	4c 27 10	jmp $1027			jmp 	NextCommand
.1eae					StringInitialise:
.1eae	48		pha				pha
.1eaf	ad 68 05	lda $0568			lda 	stringInitialised 			; already done
.1eb2	d0 11		bne $1ec5			bne 	_SIExit
.1eb4	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.1eb7	8d 69 05	sta $0569			sta 	stringTempPointer
.1eba	ad 03 04	lda $0403			lda 	stringHighMemory+1
.1ebd	3a		dec a				dec 	a
.1ebe	3a		dec a				dec 	a
.1ebf	8d 6a 05	sta $056a			sta 	stringTempPointer+1
.1ec2	ce 68 05	dec $0568			dec 	stringInitialised 			; set the initialised flag.
.1ec5					_SIExit:
.1ec5	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.1ec7	1a		inc a				inc 	a
.1ec8	1a		inc a				inc 	a
.1ec9	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.1ecc	b0 02		bcs $1ed0			bcs 	_SIMemory
.1ece	68		pla				pla
.1ecf	60		rts				rts
.1ed0					_SIMemory:
.1ed0	4c ae 27	jmp $27ae		jmp	ErrorV_memory
.1ed3					StringAllocTemp:
.1ed3	20 ae 1e	jsr $1eae			jsr 	StringInitialise 			; check it is initialised.
.1ed6	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.1ed8	18		clc				clc
.1ed9	6d 69 05	adc $0569			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.1edc	8d 69 05	sta $0569			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.1edf	85 22		sta $22				sta 	zsTemp
.1ee1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1ee3	ad 6a 05	lda $056a			lda 	stringTempPointer+1
.1ee6	69 ff		adc #$ff			adc 	#$FF
.1ee8	8d 6a 05	sta $056a			sta 	stringTempPointer+1
.1eeb	85 23		sta $23				sta 	zsTemp+1
.1eed	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1eef	74 56		stz $56,x			stz 	NSMantissa2,x
.1ef1	74 62		stz $62,x			stz 	NSMantissa3,x
.1ef3	a9 00		lda #$00			lda 	#0 							; clear string.
.1ef5	92 22		sta ($22)			sta 	(zsTemp)
.1ef7	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1ef9	95 32		sta $32,x			sta 	NSStatus,x
.1efb	60		rts				rts
.1efc					StringWriteChar:
.1efc	5a		phy				phy
.1efd	48		pha				pha
.1efe	b2 22		lda ($22)			lda 	(zsTemp)
.1f00	1a		inc a				inc 	a
.1f01	92 22		sta ($22)			sta 	(zsTemp)
.1f03	a8		tay				tay
.1f04	68		pla				pla
.1f05	91 22		sta ($22),y			sta 	(zsTemp),y
.1f07	7a		ply				ply
.1f08	60		rts				rts
.0568					stringInitialised:
>0568							.fill 	1
.0569					stringTempPointer:
>0569							.fill 	2
.1f09					Unary_Left:
.1f09	fa		plx				plx
.1f0a	5a		phy				phy
.1f0b	18		clc				clc 								; only one parameter
.1f0c	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; push the length of the string.
.1f0f	48		pha				pha
.1f10	ca		dex				dex
.1f11	a9 00		lda #$00			lda 	#0 							; push the start position.
.1f13	48		pha				pha
.1f14	20 4c 1f	jsr $1f4c			jsr 	UnarySStringToZTemp0
.1f17	80 3c		bra $1f55			bra 	SubstringMain 				; stack now points to the string to slice.
.1f19					Unary_Right:
.1f19	fa		plx				plx
.1f1a	5a		phy				phy
.1f1b	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.1f1d	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; push the right length of the string.
.1f20	48		pha				pha
.1f21	ca		dex				dex
.1f22	20 4c 1f	jsr $1f4c			jsr 	UnarySStringToZTemp0
.1f25	68		pla				pla 								; this is the right requirement
.1f26	38		sec				sec
.1f27	49 ff		eor #$ff			eor 	#$FF
.1f29	72 2c		adc ($2c)			adc 	(zTemp0)
.1f2b	b0 02		bcs $1f2f			bcs 	_URHaveCount
.1f2d	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.1f2f					_URHaveCount:
.1f2f	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.1f31	5a		phy				phy
.1f32	48		pha				pha 								; start position
.1f33	80 20		bra $1f55			bra 	SubstringMain
.1f35					Unary_Mid:
.1f35	fa		plx				plx
.1f36	5a		phy				phy
.1f37	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; push the length of the string required.
.1f3a	48		pha				pha
.1f3b	ca		dex				dex
.1f3c	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; put the start position.
.1f3f	f0 08		beq $1f49			beq 	_UMError
.1f41	3a		dec a				dec 	a
.1f42	48		pha				pha
.1f43	ca		dex				dex
.1f44	20 4c 1f	jsr $1f4c			jsr 	UnarySStringToZTemp0
.1f47	80 0c		bra $1f55			bra 	SubstringMain 				; stack now points to the string to slice.
.1f49					_UMError:
.1f49	4c a3 26	jmp $26a3		jmp	ErrorV_range
.1f4c					UnarySStringToZTemp0:
.1f4c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1f4e	85 2c		sta $2c				sta 	zTemp0
.1f50	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1f52	85 2d		sta $2d				sta 	zTemp0+1
.1f54	60		rts				rts
.1f55					SubstringMain:
.1f55	68		pla				pla 								; get the start offset
.1f56	7a		ply				ply 								; get the count to do.
.1f57	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.1f59	b0 38		bcs $1f93			bcs 	_SSReturnNull
.1f5b	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.1f5d	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.1f5f	18		clc				clc
.1f60	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.1f62	b0 06		bcs $1f6a			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.1f64	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.1f66	f0 04		beq $1f6c			beq 	_SMIsOkay
.1f68	90 02		bcc $1f6c			bcc 	_SMIsOkay
.1f6a					_SMTruncateToEnd:
.1f6a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.1f6c					_SMIsOkay:
.1f6c	85 2f		sta $2f				sta 	zTemp1+1
.1f6e	38		sec				sec		 							; work out size
.1f6f	a5 2f		lda $2f				lda 	zTemp1+1
.1f71	e5 2e		sbc $2e				sbc 	zTemp1
.1f73	f0 1e		beq $1f93			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.1f75	20 d3 1e	jsr $1ed3			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.1f78	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.1f7a					_SMCopy:
.1f7a	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.1f7c	f0 11		beq $1f8f			beq 	_SMExit
.1f7e	c8		iny				iny 								; bump and
.1f7f	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.1f81	5a		phy				phy
.1f82	48		pha				pha
.1f83	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.1f85	1a		inc a				inc 	a
.1f86	a8		tay				tay
.1f87	92 22		sta ($22)			sta 	(zsTemp)
.1f89	68		pla				pla 								; write character out
.1f8a	91 22		sta ($22),y			sta 	(zsTemp),y
.1f8c	7a		ply				ply 								; restore Y
.1f8d	80 eb		bra $1f7a			bra 	_SMCopy
.1f8f					_SMExit:
.1f8f	7a		ply				ply
.1f90	4c 27 10	jmp $1027			jmp 	NextCommand
.1f93					_SSReturnNull:
.1f93	a9 a5		lda #$a5			lda 	#SSRNull & $FF 				; set up mantissa
.1f95	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1f97	a9 1f		lda #$1f			lda 	#SSRNull >> 8
.1f99	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1f9b	74 56		stz $56,x			stz 	NSMantissa2,x
.1f9d	74 62		stz $62,x			stz 	NSMantissa3,x
.1f9f	a9 40		lda #$40			lda 	#NSSString
.1fa1	95 32		sta $32,x			sta 	NSStatus,x
.1fa3	80 ea		bra $1f8f			bra 	_SMExit
.1fa5					SSRNull:
>1fa5	00 00						.word 	0
.1fa7					CommandSwap:
.1fa7	fa		plx				plx
.1fa8	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1faa	48		pha				pha
.1fab	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1fad	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1faf	68		pla				pla
.1fb0	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.1fb2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1fb4	48		pha				pha
.1fb5	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.1fb7	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1fb9	68		pla				pla
.1fba	95 49		sta $49,x			sta 	NSMantissa1-1,x
.1fbc	b5 56		lda $56,x			lda 	NSMantissa2,x
.1fbe	48		pha				pha
.1fbf	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.1fc1	95 56		sta $56,x			sta 	NSMantissa2,x
.1fc3	68		pla				pla
.1fc4	95 55		sta $55,x			sta 	NSMantissa2-1,x
.1fc6	b5 62		lda $62,x			lda 	NSMantissa3,x
.1fc8	48		pha				pha
.1fc9	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.1fcb	95 62		sta $62,x			sta 	NSMantissa3,x
.1fcd	68		pla				pla
.1fce	95 61		sta $61,x			sta 	NSMantissa3-1,x
.1fd0	b5 6e		lda $6e,x			lda 	NSExponent,x
.1fd2	48		pha				pha
.1fd3	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.1fd5	95 6e		sta $6e,x			sta 	NSExponent,x
.1fd7	68		pla				pla
.1fd8	95 6d		sta $6d,x			sta 	NSExponent-1,x
.1fda	b5 32		lda $32,x			lda 	NSStatus,x
.1fdc	48		pha				pha
.1fdd	b5 31		lda $31,x			lda 	NSStatus-1,x
.1fdf	95 32		sta $32,x			sta 	NSStatus,x
.1fe1	68		pla				pla
.1fe2	95 31		sta $31,x			sta 	NSStatus-1,x
.1fe4	4c 27 10	jmp $1027			jmp 	NextCommand
.1fe7					CommandSYS:
.1fe7	fa		plx				plx
.1fe8	da		phx				phx 								; save XY
.1fe9	5a		phy				phy
.1fea	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.1fed	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.1fef	85 2d		sta $2d				sta 	zTemp0+1
.1ff1	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ff3	85 2c		sta $2c				sta 	zTemp0
.1ff5	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1ff8	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.1ffb	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.1ffe	48		pha				pha
.1fff	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.2002	28		plp				plp
.2003	20 1a 20	jsr $201a			jsr 	_CSZTemp0
.2006	08		php				php
.2007	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.200a	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.200d	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.2010	68		pla				pla
.2011	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.2014	7a		ply				ply 								; restore YX and drop 2
.2015	fa		plx				plx
.2016	ca		dex				dex
.2017	4c 27 10	jmp $1027			jmp 	NextCommand
.201a					_CSZTemp0:
.201a	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.201d					TimeTOS:
.201d	fa		plx				plx
.201e	20 78 20	jsr $2078			jsr 	TIPushClock 				; push clock to TOS
.2021	4c 27 10	jmp $1027			jmp 	NextCommand
.2024					TimeString:
.2024	fa		plx				plx
.2025	20 78 20	jsr $2078			jsr 	TIPushClock 				; push clock to TOS
.2028	20 4d 20	jsr $204d			jsr 	_TSDivMod60 				; result in seconds
.202b	20 4d 20	jsr $204d			jsr 	_TSDivMod60 				; seconds
.202e	48		pha				pha
.202f	20 4d 20	jsr $204d			jsr 	_TSDivMod60 				; minutes
.2032	48		pha				pha
.2033	a9 18		lda #$18			lda 	#24 						; hours
.2035	20 4f 20	jsr $204f			jsr 	_TSDivModA
.2038	48		pha				pha
.2039	a9 06		lda #$06			lda 	#6
.203b	20 d3 1e	jsr $1ed3			jsr 	StringAllocTemp
.203e	68		pla				pla
.203f	20 5f 20	jsr $205f			jsr 	_TSWriteDecimal
.2042	68		pla				pla
.2043	20 5f 20	jsr $205f			jsr 	_TSWriteDecimal
.2046	68		pla				pla
.2047	20 5f 20	jsr $205f			jsr 	_TSWriteDecimal
.204a	4c 27 10	jmp $1027			jmp 	NextCommand
.204d					_TSDivMod60:
.204d	a9 3c		lda #$3c			lda 	#60
.204f					_TSDivModA:
.204f	e8		inx				inx
.2050	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.2053	ca		dex				dex
.2054	20 9c 29	jsr $299c			jsr 	Int32Divide
.2057	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.2059	48		pha				pha
.205a	20 8b 29	jsr $298b			jsr 	NSMCopyPlusTwoToZero
.205d	68		pla				pla
.205e	60		rts				rts
.205f					_TSWriteDecimal:
.205f	da		phx				phx
.2060	a2 30		ldx #$30			ldx 	#'0'
.2062					_TSWDLoop:
.2062	c9 0a		cmp #$0a			cmp 	#10
.2064	90 05		bcc $206b			bcc 	_TSWDEnd
.2066	e9 0a		sbc #$0a			sbc 	#10
.2068	e8		inx				inx
.2069	80 f7		bra $2062			bra 	_TSWDLoop
.206b					_TSWDEnd:
.206b	48		pha				pha
.206c	8a		txa				txa
.206d	20 fc 1e	jsr $1efc			jsr 	StringWriteChar
.2070	68		pla				pla
.2071	09 30		ora #$30			ora 	#'0'
.2073	20 fc 1e	jsr $1efc			jsr 	StringWriteChar
.2076	fa		plx				plx
.2077	60		rts				rts
.2078					TIPushClock:
.2078	5a		phy				phy
.2079	e8		inx				inx 								; push 0 on the stack
.207a	20 06 2e	jsr $2e06			jsr 	FloatSetZero
.207d	da		phx				phx
.207e	20 68 24	jsr $2468			jsr 	XReadClock 					; read time into YXA
.2081	86 2c		stx $2c				stx 	zTemp0
.2083	fa		plx				plx
.2084	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2086	a5 2c		lda $2c				lda 	zTemp0
.2088	95 4a		sta $4a,x			sta 	NSMantissa1,x
.208a	98		tya				tya
.208b	95 56		sta $56,x			sta 	NSMantissa2,x
.208d	7a		ply				ply
.208e	60		rts				rts
.208f					CommandTIWrite:
.208f	fa		plx				plx
.2090	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.2092	85 22		sta $22				sta 	zsTemp
.2094	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2096	85 23		sta $23				sta 	zsTemp+1
.2098	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.209a	c9 06		cmp #$06			cmp 	#6
.209c	d0 59		bne $20f7			bne 	_CTIWError
.209e	20 06 2e	jsr $2e06			jsr 	FloatSetZero
.20a1	20 c3 20	jsr $20c3			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.20a4	20 c3 20	jsr $20c3			jsr 	_CTIWDigitPair
.20a7	20 c3 20	jsr $20c3			jsr 	_CTIWDigitPair
.20aa	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.20ac	20 ee 20	jsr $20ee			jsr 	_CTIWMultiply
.20af	da		phx				phx
.20b0	5a		phy				phy
.20b1	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.20b3	48		pha				pha
.20b4	b5 56		lda $56,x			lda 	NSMantissa2,x
.20b6	a8		tay				tay
.20b7	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20b9	fa		plx				plx
.20ba	20 6c 24	jsr $246c			jsr 	XWriteClock 				; update the clock.
.20bd	7a		ply				ply
.20be	fa		plx				plx
.20bf	ca		dex				dex 								; throw result.
.20c0	4c 27 10	jmp $1027			jmp 	NextCommand
.20c3					_CTIWDigitPair:
.20c3	a9 06		lda #$06			lda 	#6 							; x 6
.20c5	20 ee 20	jsr $20ee			jsr 	_CTIWMultiply
.20c8	20 d4 20	jsr $20d4			jsr 	_CTIWAddDigit 				; add digit
.20cb	a9 0a		lda #$0a			lda 	#10 						; x 10
.20cd	20 ee 20	jsr $20ee			jsr 	_CTIWMultiply
.20d0	20 d4 20	jsr $20d4			jsr 	_CTIWAddDigit 				; add digit
.20d3	60		rts				rts
.20d4					_CTIWAddDigit:
.20d4	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.20d6	d0 02		bne $20da			bne 	_CTIWASkip
.20d8	e6 23		inc $23				inc 	zsTemp+1
.20da					_CTIWASkip:
.20da	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.20dc	38		sec				sec
.20dd	e9 30		sbc #$30			sbc 	#"0"
.20df	90 16		bcc $20f7			bcc 	_CTIWError
.20e1	c9 0a		cmp #$0a			cmp 	#9+1
.20e3	b0 12		bcs $20f7			bcs 	_CTIWError
.20e5	e8		inx				inx 								; store at +1
.20e6	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.20e9	ca		dex				dex
.20ea	20 92 2b	jsr $2b92			jsr 	FloatAddTopTwoStack
.20ed	60		rts				rts
.20ee					_CTIWMultiply:
.20ee	e8		inx				inx
.20ef	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.20f2	ca		dex				dex
.20f3	20 13 2b	jsr $2b13			jsr 	FloatMultiplyShort
.20f6	60		rts				rts
.20f7					_CTIWError:
.20f7	4c b3 26	jmp $26b3		jmp	ErrorV_value
.20fa					UnaryUsr:
.20fa	fa		plx				plx
.20fb	5a		phy				phy
.20fc	20 03 21	jsr $2103			jsr 	_UUCallVector
.20ff	7a		ply				ply
.2100	4c 27 10	jmp $1027			jmp 	NextCommand
.2103					_UUCallVector:
.2103	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.2106					ValUnary:
.2106	fa		plx				plx
.2107	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2109	85 2c		sta $2c				sta 	zTemp0
.210b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.210d	85 2d		sta $2d				sta 	zTemp0+1
.210f	20 1a 21	jsr $211a			jsr 	ValEvaluateZTemp0
.2112	b0 03		bcs $2117			bcs 	_VUError 					; couldn't convert
.2114	4c 27 10	jmp $1027			jmp 	NextCommand
.2117					_VUError:
.2117	4c b3 26	jmp $26b3		jmp	ErrorV_value
.211a					ValEvaluateZTemp0:
.211a	5a		phy				phy
.211b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.211d	f0 22		beq $2141			beq 	_VMCFail2
.211f	a0 00		ldy #$00			ldy 	#0 							; start position
.2121					_VMCSpaces:
.2121	c8		iny				iny 								; skip leading spaces
.2122	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2124	c9 20		cmp #$20			cmp 	#" "
.2126	f0 f9		beq $2121			beq 	_VMCSpaces
.2128	48		pha				pha 								; save first character
.2129	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.212b	d0 01		bne $212e			bne 	_VMCStart
.212d	c8		iny				iny 								; skip over - if so.
.212e					_VMCStart:
.212e	38		sec				sec 								; initialise first time round.
.212f					_VMCNext:
.212f	98		tya				tya 								; reached end of string
.2130	3a		dec a				dec 	a
.2131	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.2133	f0 0f		beq $2144			beq 	_VMCSuccess 				; successful.
.2135	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.2137	c8		iny				iny
.2138	20 ea 2b	jsr $2bea			jsr 	FloatEncode 				; send it to the number-builder
.213b	90 03		bcc $2140			bcc 	_VMCFail 					; if failed, give up.
.213d	18		clc				clc 								; next time round, countinue
.213e	80 ef		bra $212f			bra 	_VMCNext
.2140					_VMCFail:
.2140	68		pla				pla
.2141					_VMCFail2:
.2141	7a		ply				ply
.2142	38		sec				sec
.2143	60		rts				rts
.2144					_VMCSuccess:
.2144	a9 00		lda #$00			lda 	#0 							; construct final
.2146	20 ea 2b	jsr $2bea			jsr 	FloatEncode 				; by sending a duff value.
.2149	68		pla				pla 								; if it was -ve
.214a	c9 2d		cmp #$2d			cmp 	#"-"
.214c	d0 03		bne $2151			bne 	_VMCNotNegative
.214e	20 c8 2d	jsr $2dc8			jsr		FloatNegate 				; negate it.
.2151					_VMCNotNegative:
.2151	7a		ply				ply
.2152	18		clc				clc
.2153	60		rts				rts
.2154					VectorTable:
>2154	6b 18					.word	LinkFloatAdd             ; $80 +
>2156	74 18					.word	LinkFloatSubtract        ; $81 -
>2158	7d 18					.word	LinkFloatMultiply        ; $82 *
>215a	86 18					.word	LinkFloatDivide          ; $83 /
>215c	91 18					.word	LinkFloatPower           ; $84 ^
>215e	b9 10					.word	BinaryAnd                ; $85 and
>2160	bd 10					.word	BinaryOr                 ; $86 or
>2162	9c 18					.word	LinkCompareGreater       ; $87 >
>2164	a5 18					.word	LinkCompareEqual         ; $88 =
>2166	ae 18					.word	LinkCompareLess          ; $89 <
>2168	b7 18					.word	LinkCompareGreaterEqual  ; $8a >=
>216a	c0 18					.word	LinkCompareNotEqual      ; $8b <>
>216c	c9 18					.word	LinkCompareLessEqual     ; $8c <=
>216e	a1 10					.word	AbsoluteTOS              ; $8d abs
>2170	f4 10					.word	ArrayConvert             ; $8e array
>2172	9c 11					.word	UnaryAsc                 ; $8f asc
>2174	b7 11					.word	CommandAssert            ; $90 assert
>2176	f8 11					.word	Unary16Bin               ; $91 bin$
>2178	22 12					.word	PrintCharacter           ; $92 print.chr
>217a	2c 12					.word	UnaryChr                 ; $93 chr$
>217c	91 12					.word	CompareStrings           ; $94 s.cmp
>217e	78 14					.word	CommandFor               ; $95 for
>2180	3b 15					.word	UnaryFre                 ; $96 fre
>2182	53 15					.word	CommandGet               ; $97 get
>2184	79 15					.word	CommandReturn            ; $98 return
>2186	bb 15					.word	Command_PSET             ; $99 pset
>2188	d5 15					.word	Command_LINE             ; $9a line
>218a	ea 15					.word	Command_RECT             ; $9b rect
>218c	f9 15					.word	Command_FRAME            ; $9c frame
>218e	08 16					.word	Command_CHAR             ; $9d char
>2190	9f 16					.word	Unary16Hex               ; $9e hex$
>2192	46 17					.word	CommandInput             ; $9f input
>2194	5d 17					.word	CommandInputString       ; $a0 input$
>2196	76 17					.word	CommandInputReset        ; $a1 input.start
>2198	5a 18					.word	UnaryLen                 ; $a2 len
>219a	26 19					.word	LinkFloatCompare         ; $a3 f.cmp
>219c	2f 19					.word	LinkDivideInt32          ; $a4 int.div
>219e	a9 19					.word	NegateTOS                ; $a5 negate
>21a0	b0 19					.word	CommandNewLine           ; $a6 new.line
>21a2	b9 19					.word	CommandNext              ; $a7 next
>21a4	a2 1a					.word	NotTOS                   ; $a8 not
>21a6	b9 1a					.word	CommandOn                ; $a9 on
>21a8	d6 1a					.word	CommandMoreOn            ; $aa moreon
>21aa	dd 1a					.word	UnaryPeek                ; $ab peek
>21ac	f2 1a					.word	CommandPOKE              ; $ac poke
>21ae	0a 1b					.word	UnaryPos                 ; $ad pos
>21b0	14 1b					.word	GetChannel               ; $ae getchannel
>21b2	1f 1b					.word	SetChannel               ; $af setchannel
>21b4	42 1b					.word	PrintNumber              ; $b0 print.n
>21b6	61 1b					.word	PrintString              ; $b1 print.s
>21b8	c8 1b					.word	CommandRead              ; $b2 read
>21ba	e2 1b					.word	CommandReadString        ; $b3 read$
>21bc	6d 1d					.word	UnaryRND                 ; $b4 rnd
>21be	dc 1d					.word	StringConcatenate        ; $b5 concat
>21c0	33 1e					.word	SignTOS                  ; $b6 sgn
>21c2	56 1e					.word	PrintTab                 ; $b7 print.tab
>21c4	64 1e					.word	PrintPos                 ; $b8 print.pos
>21c6	75 1e					.word	PrintSpace               ; $b9 print.spc
>21c8	8e 1e					.word	Unary_Str                ; $ba str$
>21ca	09 1f					.word	Unary_Left               ; $bb left$
>21cc	19 1f					.word	Unary_Right              ; $bc right$
>21ce	35 1f					.word	Unary_Mid                ; $bd mid$
>21d0	a7 1f					.word	CommandSwap              ; $be swap
>21d2	1d 20					.word	TimeTOS                  ; $bf ti
>21d4	24 20					.word	TimeString               ; $c0 ti$
>21d6	fa 20					.word	UnaryUsr                 ; $c1 usr
>21d8	06 21					.word	ValUnary                 ; $c2 val
>21da	64 23					.word	CommandClose             ; $c3 close
>21dc	76 23					.word	CommandExit              ; $c4 exit
>21de	7c 23					.word	CommandDebug             ; $c5 debug
>21e0	e2 23					.word	CommandOpen              ; $c6 open
>21e2	76 24					.word	CommandScreen            ; $c7 screen
>21e4	5d 26					.word	CommandVPOKE             ; $c8 vpoke
>21e6	82 26					.word	CommandVPEEK             ; $c9 vpeek
>21e8	4e 1e					.word	CommandShift             ; $ca .shift
>21ea	65 10					.word	PushByteCommand          ; $cb .byte
>21ec	78 10					.word	PushWordCommand          ; $cc .word
>21ee	84 1b					.word	CommandPushN             ; $cd .float
>21f0	aa 1b					.word	CommandPushS             ; $ce .string
>21f2	19 13					.word	CommandData              ; $cf .data
>21f4	8a 15					.word	CommandGoto              ; $d0 .goto
>21f6	6d 15					.word	CommandGosub             ; $d1 .gosub
>21f8	9f 15					.word	CommandGotoZ             ; $d2 .goto.z
>21fa	ad 15					.word	CommandGotoNZ            ; $d3 .goto.nz
>21fc	a7 10					.word	CommandVarSpace          ; $d4 .varspace
.21fe					ShiftVectorTable:
>21fe	44 12					.word	CommandClr               ; $ca80 clr
>2200	22 13					.word	CommandDIM               ; $ca81 dim
>2202	13 14					.word	CommandEnd               ; $ca82 end
>2204	2b 18					.word	UnaryJoy                 ; $ca83 joy
>2206	d2 18					.word	LinkFloatIntegerPartDown ; $ca84 int
>2208	db 18					.word	LinkFloatSquareRoot      ; $ca85 sqr
>220a	ec 18					.word	LinkFloatLogarithm       ; $ca86 log
>220c	f7 18					.word	LinkFloatExponent        ; $ca87 exp
>220e	00 19					.word	LinkFloatCosine          ; $ca88 cos
>2210	09 19					.word	LinkFloatSine            ; $ca89 sin
>2212	12 19					.word	LinkFloatTangent         ; $ca8a tan
>2214	1b 19					.word	LinkFloatArcTan          ; $ca8b atn
>2216	59 19					.word	XCommandMouse            ; $ca8c mouse
>2218	6e 19					.word	XUnaryMB                 ; $ca8d mb
>221a	7b 19					.word	XUnaryMX                 ; $ca8e mx
>221c	8c 19					.word	XUnaryMY                 ; $ca8f my
>221e	5b 1d					.word	CommandRestore           ; $ca90 restore
>2220	8a 1e					.word	CommandStop              ; $ca91 stop
>2222	e7 1f					.word	CommandSYS               ; $ca92 sys
>2224	8f 20					.word	CommandTIWrite           ; $ca93 ti$.write
>2226	5c 22					.word	CommandWAIT              ; $ca94 wait
>2228	a7 23					.word	X16I2CPoke               ; $ca95 i2cpoke
>222a	c7 23					.word	X16I2CPeek               ; $ca96 i2cpeek
>222c	32 24					.word	CommandBank              ; $ca97 bank
>222e	85 24					.word	XCommandSleep            ; $ca98 sleep
>2230	a9 24					.word	X16_Audio_FMINIT         ; $ca99 fminit
>2232	b7 24					.word	X16_Audio_FMNOTE         ; $ca9a fmnote
>2234	c9 24					.word	X16_Audio_FMDRUM         ; $ca9b fmdrum
>2236	db 24					.word	X16_Audio_FMINST         ; $ca9c fminst
>2238	ed 24					.word	X16_Audio_FMVIB          ; $ca9d fmvib
>223a	ff 24					.word	X16_Audio_FMFREQ         ; $ca9e fmfreq
>223c	10 25					.word	X16_Audio_FMVOL          ; $ca9f fmvol
>223e	22 25					.word	X16_Audio_FMPAN          ; $caa0 fmpan
>2240	34 25					.word	X16_Audio_FMPLAY         ; $caa1 fmplay
>2242	45 25					.word	X16_Audio_FMCHORD        ; $caa2 fmchord
>2244	56 25					.word	X16_Audio_FMPOKE         ; $caa3 fmpoke
>2246	68 25					.word	X16_Audio_PSGINIT        ; $caa4 psginit
>2248	76 25					.word	X16_Audio_PSGNOTE        ; $caa5 psgnote
>224a	88 25					.word	X16_Audio_PSGVOL         ; $caa6 psgvol
>224c	9a 25					.word	X16_Audio_PSGWAV         ; $caa7 psgwav
>224e	ac 25					.word	X16_Audio_PSGFREQ        ; $caa8 psgfreq
>2250	bd 25					.word	X16_Audio_PSGPAN         ; $caa9 psgpan
>2252	cf 25					.word	X16_Audio_PSGPLAY        ; $caaa psgplay
>2254	e0 25					.word	X16_Audio_PSGCHORD       ; $caab psgchord
>2256	f1 25					.word	CommandCls               ; $caac cls
>2258	fa 25					.word	CommandLocate            ; $caad locate
>225a	24 26					.word	CommandColor             ; $caae color
.225c					CommandWAIT:
.225c	fa		plx				plx
.225d	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.225f	85 2c		sta $2c				sta 	zTemp0
.2261	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.2263	85 2d		sta $2d				sta 	zTemp0+1
.2265					_WaitLoop:
.2265	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.2267	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.2269	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.226b	f0 f8		beq $2265			beq 	_WaitLoop 					; keep going if zero
.226d	ca		dex				dex 								; drop 3.
.226e	ca		dex				dex
.226f	ca		dex				dex
.2270	4c 27 10	jmp $1027			jmp 	NextCommand
.2273					WriteFloatCommand:
.2273	fa		plx				plx
.2274	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.2276	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.2278	88		dey				dey 								; get the upper 3 bits
.2279	b1 28		lda ($28),y			lda 	(codePtr),y
.227b	29 07		and #$07			and 	#7
.227d	c8		iny				iny
.227e	c8		iny				iny
.227f	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.2281	2a		rol a				rol 	a 							; carry will be clear.
.2282	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.2285	85 2d		sta $2d				sta 	zTemp0+1
.2287	20 8d 22	jsr $228d			jsr 	WriteFloatZTemp0Sub
.228a	4c 27 10	jmp $1027			jmp 	NextCommand
.228d					WriteFloatZTemp0Sub:
.228d	5a		phy				phy 								; ldart write
.228e	a0 01		ldy #$01			ldy 	#1
.2290	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2292	92 2c		sta ($2c)			sta 	(zTemp0)
.2294	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2296	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2298	c8		iny				iny
.2299	b5 56		lda $56,x			lda 	NSMantissa2,x
.229b	91 2c		sta ($2c),y			sta 	(zTemp0),y
.229d	c8		iny				iny
.229e	b5 62		lda $62,x			lda 	NSMantissa3,x
.22a0	91 2c		sta ($2c),y			sta 	(zTemp0),y
.22a2	c8		iny				iny
.22a3	b5 6e		lda $6e,x			lda 	NSExponent,x
.22a5	91 2c		sta ($2c),y			sta 	(zTemp0),y
.22a7	c8		iny				iny
.22a8	b5 32		lda $32,x			lda 	NSStatus,x
.22aa	91 2c		sta ($2c),y			sta 	(zTemp0),y
.22ac	ca		dex				dex
.22ad	7a		ply				ply
.22ae	60		rts				rts
.22af					WriteIntegerCommand:
.22af	fa		plx				plx
.22b0	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.22b2	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.22b4	88		dey				dey 								; get the upper 3 bits
.22b5	b1 28		lda ($28),y			lda 	(codePtr),y
.22b7	29 07		and #$07			and 	#7
.22b9	c8		iny				iny
.22ba	c8		iny				iny
.22bb	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.22bd	2a		rol a				rol 	a 							; carry will be clear.
.22be	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.22c1	85 2d		sta $2d				sta 	zTemp0+1
.22c3	20 c9 22	jsr $22c9			jsr 	WriteIntegerZTemp0Sub
.22c6	4c 27 10	jmp $1027			jmp 	NextCommand
.22c9					WriteIntegerZTemp0Sub:
.22c9	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.22cc	5a		phy				phy 								; start write
.22cd	a0 01		ldy #$01			ldy 	#1
.22cf	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.22d1	30 0b		bmi $22de			bmi 	_WIZNegative
.22d3	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.22d5	92 2c		sta ($2c)			sta 	(zTemp0)
.22d7	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.22d9	91 2c		sta ($2c),y			sta 	(zTemp0),y
.22db	7a		ply				ply
.22dc	ca		dex				dex
.22dd	60		rts				rts
.22de					_WIZNegative:
.22de	38		sec				sec 								; -ve read
.22df	a9 00		lda #$00			lda 	#0
.22e1	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.22e3	92 2c		sta ($2c)			sta 	(zTemp0)
.22e5	a9 00		lda #$00			lda 	#0
.22e7	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.22e9	91 2c		sta ($2c),y			sta 	(zTemp0),y
.22eb	7a		ply				ply
.22ec	ca		dex				dex
.22ed	60		rts				rts
.22ee					WriteStringCommand:
.22ee	fa		plx				plx
.22ef	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.22f1	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.22f3	88		dey				dey 								; get the upper 3 bits
.22f4	b1 28		lda ($28),y			lda 	(codePtr),y
.22f6	29 07		and #$07			and 	#7
.22f8	c8		iny				iny
.22f9	c8		iny				iny
.22fa	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.22fc	2a		rol a				rol 	a 							; carry will be clear.
.22fd	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.2300	85 2d		sta $2d				sta 	zTemp0+1
.2302	20 08 23	jsr $2308			jsr 	WriteStringZTemp0Sub
.2305	4c 27 10	jmp $1027			jmp 	NextCommand
.2308					WriteStringZTemp0Sub:
.2308	5a		phy				phy
.2309	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.230b	b2 2c		lda ($2c)			lda 	(zTemp0)
.230d	11 2c		ora ($2c),y			ora 	(zTemp0),y
.230f	f0 1e		beq $232f			beq 	_WSConcrete
.2311	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.2313	85 2e		sta $2e				sta 	zTemp1
.2315	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2317	85 2f		sta $2f				sta 	zTemp1+1
.2319	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.231b	85 30		sta $30				sta 	zTemp2
.231d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.231f	85 31		sta $31				sta 	zTemp2+1
.2321	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.2323	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.2325	b0 17		bcs $233e			bcs 	_WSCopy
.2327	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.2329	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.232b	09 80		ora #$80			ora 	#$80
.232d	91 2e		sta ($2e),y			sta 	(zTemp1),y
.232f					_WSConcrete:
.232f	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.2331	a8		tay				tay
.2332	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2334	20 d3 12	jsr $12d3			jsr 	StringConcrete
.2337	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.2339	98		tya				tya
.233a	a0 01		ldy #$01			ldy 	#1
.233c	91 2c		sta ($2c),y			sta 	(zTemp0),y
.233e					_WSCopy
.233e	18		clc				clc  								; copy target+2 to zTemp2
.233f	b2 2c		lda ($2c)			lda 	(zTemp0)
.2341	69 02		adc #$02			adc 	#2
.2343	85 30		sta $30				sta 	zTemp2
.2345	a0 01		ldy #$01			ldy 	#1
.2347	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2349	69 00		adc #$00			adc 	#0
.234b	85 31		sta $31				sta 	zTemp2+1
.234d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.234f	85 2e		sta $2e				sta 	zTemp1
.2351	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2353	85 2f		sta $2f				sta 	zTemp1+1
.2355	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.2357	a8		tay				tay
.2358					_WSCopyLoop:
.2358	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.235a	91 30		sta ($30),y			sta 	(zTemp2),y
.235c	88		dey				dey
.235d	c0 ff		cpy #$ff			cpy 	#$FF
.235f	d0 f7		bne $2358			bne 	_WSCopyLoop
.2361	ca		dex				dex
.2362	7a		ply				ply
.2363	60		rts				rts
.2364					CommandClose:
.2364	fa		plx				plx
.2365	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; channel to close
.2368	cd 5d 04	cmp $045d			cmp 	currentChannel 				; is it the current channel
.236b	d0 03		bne $2370			bne 	_CCNotCurrent
.236d	9c 5d 04	stz $045d			stz 	currentChannel 				; effectively disables CMD
.2370					_CCNotCurrent:
.2370	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.2373	4c 27 10	jmp $1027			jmp 	NextCommand
.2376					CommandExit:
.2376	fa		plx				plx
.2377	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.2379	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.237c					CommandDebug:
.237c	fa		plx				plx
>237d	db						.byte 	$DB 						; causes a break in the emulator
.237e	4c 27 10	jmp $1027			jmp 	NextCommand
.2381					XGetCharacterFromChannel:
.2381	da		phx				phx
.2382	5a		phy				phy
.2383	e0 00		cpx #$00			cpx 	#0 							; is it default
.2385	d0 05		bne $238c			bne 	_XGetChannel
.2387	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.238a	80 08		bra $2394			bra 	_XGetChar
.238c					_XGetChannel:
.238c	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.238f	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.2392	d0 06		bne $239a			bne 	_XGCError
.2394					_XGetChar:
.2394	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.2397	7a		ply				ply
.2398	fa		plx				plx
.2399	60		rts				rts
.239a					_XGCError:
.239a	4c bf 27	jmp $27bf		jmp	ErrorV_channel
.239d					XGetHPos:
.239d	da		phx				phx
.239e	5a		phy				phy
.239f	38		sec				sec
.23a0	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.23a3	98		tya				tya
.23a4	7a		ply				ply
.23a5	fa		plx				plx
.23a6	60		rts				rts
.23a7					X16I2CPoke:
.23a7	fa		plx				plx
.23a8	5a		phy				phy
.23a9	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; value
.23ac	48		pha				pha
.23ad	ca		dex				dex
.23ae	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; register
.23b1	48		pha				pha
.23b2	ca		dex				dex
.23b3	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; device
.23b6	aa		tax				tax
.23b7	7a		ply				ply
.23b8	68		pla				pla
.23b9	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.23bc	b0 06		bcs $23c4			bcs 	X16I2CError
.23be	7a		ply				ply
.23bf	a2 ff		ldx #$ff			ldx 	#$FF
.23c1	4c 27 10	jmp $1027			jmp 	NextCommand
.23c4					X16I2CError:
.23c4	4c bf 27	jmp $27bf		jmp	ErrorV_channel
.23c7					X16I2CPeek:
.23c7	fa		plx				plx
.23c8	da		phx				phx
.23c9	5a		phy				phy
.23ca	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; register
.23cd	48		pha				pha
.23ce	ca		dex				dex
.23cf	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; device
.23d2	aa		tax				tax 								; X device
.23d3	7a		ply				ply 								; Y register
.23d4	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.23d7	b0 eb		bcs $23c4			bcs 	X16I2CError
.23d9	7a		ply				ply 								; restore Y/X
.23da	fa		plx				plx
.23db	ca		dex				dex 								; drop TOS (register)
.23dc	20 08 2e	jsr $2e08			jsr 	FloatSetByte 				; write read value to TOS.
.23df	4c 27 10	jmp $1027			jmp 	NextCommand
.23e2					CommandOpen:
.23e2	fa		plx				plx
.23e3	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.23e5	85 2c		sta $2c				sta 	zTemp0
.23e7	aa		tax				tax
.23e8	a5 4d		lda $4d				lda 	NSMantissa1+3
.23ea	85 2d		sta $2d				sta 	zTemp0+1
.23ec	a8		tay				tay
.23ed	e8		inx				inx 								; XY points to first character
.23ee	d0 01		bne $23f1			bne 	_CONoCarry
.23f0	c8		iny				iny
.23f1					_CONoCarry:
.23f1	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.23f3	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.23f6	a5 3e		lda $3e				lda 	NSMantissa0+0
.23f8	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.23fa	a4 40		ldy $40				ldy 	NSMantissa0+2
.23fc	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.23ff	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.2402	b0 03		bcs $2407			bcs 	_COError
.2404	4c 27 10	jmp $1027			jmp 	NextCommand
.2407					_COError:
.2407	4c bf 27	jmp $27bf		jmp	ErrorV_channel
.240a					XPokeMemory:
.240a	86 2c		stx $2c				stx 	zTemp0
.240c	84 2d		sty $2d				sty 	zTemp0+1
.240e	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.2410	ae 6b 05	ldx $056b			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.2413	e0 ff		cpx #$ff			cpx 	#$FF
.2415	f0 02		beq $2419			beq 	_XPMNoSwitch
.2417	86 00		stx $00				stx 	SelectRAMBank
.2419					_XPMNoSwitch:
.2419	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.241b	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.241d					_XPMExit:
.241d	60		rts				rts
.241e					XPeekMemory:
.241e	86 2c		stx $2c				stx 	zTemp0
.2420	84 2d		sty $2d				sty 	zTemp0+1
.2422	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.2424	ae 6b 05	ldx $056b			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.2427	e0 ff		cpx #$ff			cpx 	#$FF
.2429	f0 02		beq $242d			beq 	_XPMNoSwitch
.242b	86 00		stx $00				stx 	SelectRAMBank
.242d					_XPMNoSwitch:
.242d	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.242f	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.2431	60		rts				rts
.2432					CommandBank:
.2432	fa		plx				plx
.2433	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.2435	8d 6b 05	sta $056b			sta 	ramBank 					; store & make current
.2438	85 00		sta $00				sta 	SelectRAMBank
.243a	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.243c	c9 ff		cmp #$ff			cmp 	#$FF
.243e	f0 03		beq $2443			beq 	_CBNoUpdate
.2440	8d 6c 05	sta $056c			sta 	romBank 					; this doesn't set the hardware page.
.2443					_CBNoUpdate:
.2443	a2 ff		ldx #$ff			ldx 	#$FF
.2445	4c 27 10	jmp $1027			jmp 	NextCommand
.056b					ramBank:
>056b							.fill 	1
.056c					romBank:
>056c							.fill 	1
.2448					XPrintCharacterToChannel:
.2448	48		pha				pha
.2449	da		phx				phx
.244a	5a		phy				phy
.244b	48		pha				pha  								; save char
.244c	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.244e	d0 05		bne $2455			bne 	_XPCNotDefault
.2450	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.2453	80 08		bra $245d			bra 	_XPCSend
.2455					_XPCNotDefault:
.2455	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.2458	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.245b	d0 08		bne $2465			bne 	_XPCError
.245d					_XPCSend:
.245d	68		pla				pla 								; restore character
.245e	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.2461	7a		ply				ply
.2462	fa		plx				plx
.2463	68		pla				pla
.2464	60		rts				rts
.2465					_XPCError:
.2465	4c bf 27	jmp $27bf		jmp	ErrorV_channel
.2468					XReadClock:
.2468	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.246b	60		rts				rts
.246c					XWriteClock:
.246c	48		pha				pha
.246d	da		phx				phx
.246e	5a		phy				phy
.246f	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.2472	7a		ply				ply
.2473	fa		plx				plx
.2474	68		pla				pla
.2475	60		rts				rts
.2476					CommandScreen:
.2476	fa		plx				plx
.2477	da		phx				phx
.2478	5a		phy				phy
.2479	20 03 18	jsr $1803			jsr 	GetInteger8Bit
.247c	18		clc				clc
.247d	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.2480	7a		ply				ply
.2481	fa		plx				plx
.2482	4c 27 10	jmp $1027			jmp 	NextCommand
.2485					XCommandSleep:
.2485	fa		plx				plx
.2486	5a		phy				phy
.2487	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.248a	ca		dex				dex
.248b	20 68 24	jsr $2468			jsr 	XReadClock 					; read clock to YXA
.248e	18		clc				clc 								; calculate end time in zTemp0
.248f	65 3e		adc $3e				adc 	NSMantissa0
.2491	85 2c		sta $2c				sta 	zTemp0
.2493	8a		txa				txa
.2494	65 4a		adc $4a				adc 	NSMantissa1
.2496	85 2d		sta $2d				sta 	zTemp0+1
.2498					_XCWait:
.2498	20 68 24	jsr $2468			jsr 	XReadClock 					; and wait for it.
.249b	c5 2c		cmp $2c				cmp 	zTemp0
.249d	d0 f9		bne $2498			bne 	_XCWait
.249f	e4 2d		cpx $2d				cpx 	zTemp0+1
.24a1	d0 f5		bne $2498			bne 	_XCWait
.24a3	a2 ff		ldx #$ff			ldx 	#$FF
.24a5	7a		ply				ply
.24a6	4c 27 10	jmp $1027			jmp 	NextCommand
.24a9					X16_Audio_FMINIT:
.24a9	fa		plx				plx
.24aa	5a		phy			phy
.24ab	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>24ae	63 c0					.word	X16A_ym_init
>24b0	0a					.byte	X16_AudioCodeBank
.24b1	a2 ff		ldx #$ff		ldx	#$FF
.24b3	7a		ply			ply
.24b4	4c 27 10	jmp $1027			jmp 	NextCommand
.24b7					X16_Audio_FMNOTE:
.24b7	fa		plx				plx
.24b8	5a		phy			phy
.24b9	20 ce 11	jsr $11ce		jsr		X16_Audio_Parameters8_8
.24bc	18		clc			clc
.24bd	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>24c0	03 c0					.word	X16A_bas_fmnote
>24c2	0a					.byte	X16_AudioCodeBank
.24c3	a2 ff		ldx #$ff		ldx	#$FF
.24c5	7a		ply			ply
.24c6	4c 27 10	jmp $1027			jmp 	NextCommand
.24c9					X16_Audio_FMDRUM:
.24c9	fa		plx				plx
.24ca	5a		phy			phy
.24cb	20 ce 11	jsr $11ce		jsr		X16_Audio_Parameters8_8
.24ce	18		clc			clc
.24cf	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>24d2	6f c0					.word	X16A_ym_playdrum
>24d4	0a					.byte	X16_AudioCodeBank
.24d5	a2 ff		ldx #$ff		ldx	#$FF
.24d7	7a		ply			ply
.24d8	4c 27 10	jmp $1027			jmp 	NextCommand
.24db					X16_Audio_FMINST:
.24db	fa		plx				plx
.24dc	5a		phy			phy
.24dd	20 ce 11	jsr $11ce		jsr		X16_Audio_Parameters8_8
.24e0	38		sec			sec
.24e1	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>24e4	69 c0					.word	X16A_ym_loadpatch
>24e6	0a					.byte	X16_AudioCodeBank
.24e7	a2 ff		ldx #$ff		ldx	#$FF
.24e9	7a		ply			ply
.24ea	4c 27 10	jmp $1027			jmp 	NextCommand
.24ed					X16_Audio_FMVIB:
.24ed	fa		plx				plx
.24ee	5a		phy			phy
.24ef	20 ce 11	jsr $11ce		jsr		X16_Audio_Parameters8_8
.24f2	18		clc			clc
.24f3	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>24f6	09 c0					.word	X16A_bas_fmvib
>24f8	0a					.byte	X16_AudioCodeBank
.24f9	a2 ff		ldx #$ff		ldx	#$FF
.24fb	7a		ply			ply
.24fc	4c 27 10	jmp $1027			jmp 	NextCommand
.24ff					X16_Audio_FMFREQ:
.24ff	fa		plx				plx
.2500	5a		phy			phy
.2501	20 c8 11	jsr $11c8		jsr		X16_Audio_Parameters8_16
.2504	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2507	00 c0					.word	X16A_bas_fmfreq
>2509	0a					.byte	X16_AudioCodeBank
.250a	a2 ff		ldx #$ff		ldx	#$FF
.250c	7a		ply			ply
.250d	4c 27 10	jmp $1027			jmp 	NextCommand
.2510					X16_Audio_FMVOL:
.2510	fa		plx				plx
.2511	5a		phy			phy
.2512	20 ce 11	jsr $11ce		jsr		X16_Audio_Parameters8_8
.2515	18		clc			clc
.2516	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2519	75 c0					.word	X16A_ym_setatten
>251b	0a					.byte	X16_AudioCodeBank
.251c	a2 ff		ldx #$ff		ldx	#$FF
.251e	7a		ply			ply
.251f	4c 27 10	jmp $1027			jmp 	NextCommand
.2522					X16_Audio_FMPAN:
.2522	fa		plx				plx
.2523	5a		phy			phy
.2524	20 ce 11	jsr $11ce		jsr		X16_Audio_Parameters8_8
.2527	18		clc			clc
.2528	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>252b	7e c0					.word	X16A_ym_setpan
>252d	0a					.byte	X16_AudioCodeBank
.252e	a2 ff		ldx #$ff		ldx	#$FF
.2530	7a		ply			ply
.2531	4c 27 10	jmp $1027			jmp 	NextCommand
.2534					X16_Audio_FMPLAY:
.2534	fa		plx				plx
.2535	5a		phy			phy
.2536	20 df 11	jsr $11df		jsr		X16_Audio_Parameters8_String
.2539	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>253c	06 c0					.word	X16A_bas_fmplaystring
>253e	0a					.byte	X16_AudioCodeBank
.253f	a2 ff		ldx #$ff		ldx	#$FF
.2541	7a		ply			ply
.2542	4c 27 10	jmp $1027			jmp 	NextCommand
.2545					X16_Audio_FMCHORD:
.2545	fa		plx				plx
.2546	5a		phy			phy
.2547	20 df 11	jsr $11df		jsr		X16_Audio_Parameters8_String
.254a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>254d	8d c0					.word	X16A_bas_fmchordstring
>254f	0a					.byte	X16_AudioCodeBank
.2550	a2 ff		ldx #$ff		ldx	#$FF
.2552	7a		ply			ply
.2553	4c 27 10	jmp $1027			jmp 	NextCommand
.2556					X16_Audio_FMPOKE:
.2556	fa		plx				plx
.2557	5a		phy			phy
.2558	20 ce 11	jsr $11ce		jsr		X16_Audio_Parameters8_8
.255b	18		clc			clc
.255c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>255f	8a c0					.word	X16A_ym_write
>2561	0a					.byte	X16_AudioCodeBank
.2562	a2 ff		ldx #$ff		ldx	#$FF
.2564	7a		ply			ply
.2565	4c 27 10	jmp $1027			jmp 	NextCommand
.2568					X16_Audio_PSGINIT:
.2568	fa		plx				plx
.2569	5a		phy			phy
.256a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>256d	4b c0					.word	X16A_psg_init
>256f	0a					.byte	X16_AudioCodeBank
.2570	a2 ff		ldx #$ff		ldx	#$FF
.2572	7a		ply			ply
.2573	4c 27 10	jmp $1027			jmp 	NextCommand
.2576					X16_Audio_PSGNOTE:
.2576	fa		plx				plx
.2577	5a		phy			phy
.2578	20 ce 11	jsr $11ce		jsr		X16_Audio_Parameters8_8
.257b	18		clc			clc
.257c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>257f	12 c0					.word	X16A_bas_psgnote
>2581	0a					.byte	X16_AudioCodeBank
.2582	a2 ff		ldx #$ff		ldx	#$FF
.2584	7a		ply			ply
.2585	4c 27 10	jmp $1027			jmp 	NextCommand
.2588					X16_Audio_PSGVOL:
.2588	fa		plx				plx
.2589	5a		phy			phy
.258a	20 ce 11	jsr $11ce		jsr		X16_Audio_Parameters8_8
.258d	18		clc			clc
.258e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>2591	54 c0					.word	X16A_psg_setatten
>2593	0a					.byte	X16_AudioCodeBank
.2594	a2 ff		ldx #$ff		ldx	#$FF
.2596	7a		ply			ply
.2597	4c 27 10	jmp $1027			jmp 	NextCommand
.259a					X16_Audio_PSGWAV:
.259a	fa		plx				plx
.259b	5a		phy			phy
.259c	20 ce 11	jsr $11ce		jsr		X16_Audio_Parameters8_8
.259f	18		clc			clc
.25a0	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>25a3	15 c0					.word	X16A_bas_psgwav
>25a5	0a					.byte	X16_AudioCodeBank
.25a6	a2 ff		ldx #$ff		ldx	#$FF
.25a8	7a		ply			ply
.25a9	4c 27 10	jmp $1027			jmp 	NextCommand
.25ac					X16_Audio_PSGFREQ:
.25ac	fa		plx				plx
.25ad	5a		phy			phy
.25ae	20 c8 11	jsr $11c8		jsr		X16_Audio_Parameters8_16
.25b1	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>25b4	0f c0					.word	X16A_bas_psgfreq
>25b6	0a					.byte	X16_AudioCodeBank
.25b7	a2 ff		ldx #$ff		ldx	#$FF
.25b9	7a		ply			ply
.25ba	4c 27 10	jmp $1027			jmp 	NextCommand
.25bd					X16_Audio_PSGPAN:
.25bd	fa		plx				plx
.25be	5a		phy			phy
.25bf	20 ce 11	jsr $11ce		jsr		X16_Audio_Parameters8_8
.25c2	18		clc			clc
.25c3	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>25c6	5a c0					.word	X16A_psg_setpan
>25c8	0a					.byte	X16_AudioCodeBank
.25c9	a2 ff		ldx #$ff		ldx	#$FF
.25cb	7a		ply			ply
.25cc	4c 27 10	jmp $1027			jmp 	NextCommand
.25cf					X16_Audio_PSGPLAY:
.25cf	fa		plx				plx
.25d0	5a		phy			phy
.25d1	20 df 11	jsr $11df		jsr		X16_Audio_Parameters8_String
.25d4	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>25d7	18 c0					.word	X16A_bas_psgplaystring
>25d9	0a					.byte	X16_AudioCodeBank
.25da	a2 ff		ldx #$ff		ldx	#$FF
.25dc	7a		ply			ply
.25dd	4c 27 10	jmp $1027			jmp 	NextCommand
.25e0					X16_Audio_PSGCHORD:
.25e0	fa		plx				plx
.25e1	5a		phy			phy
.25e2	20 df 11	jsr $11df		jsr		X16_Audio_Parameters8_String
.25e5	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>25e8	90 c0					.word	X16A_bas_psgchordstring
>25ea	0a					.byte	X16_AudioCodeBank
.25eb	a2 ff		ldx #$ff		ldx	#$FF
.25ed	7a		ply			ply
.25ee	4c 27 10	jmp $1027			jmp 	NextCommand
.25f1					CommandCls:
.25f1	fa		plx				plx
.25f2	a9 93		lda #$93			lda 	#147
.25f4	20 48 24	jsr $2448			jsr 	XPrintCharacterToChannel
.25f7	4c 27 10	jmp $1027			jmp 	NextCommand
.25fa					CommandLocate:
.25fa	fa		plx				plx
.25fb	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.25fe	ca		dex				dex
.25ff	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.2602	ca		dex				dex
.2603	a9 13		lda #$13			lda 	#$13 						; home.
.2605	20 48 24	jsr $2448			jsr 	XPrintCharacterToChannel
.2608	a9 1d		lda #$1d			lda 	#$1D 						; do cursor rights
.260a	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.260c	20 19 26	jsr $2619			jsr 	_CLOutputXA
.260f	a9 11		lda #$11			lda 	#$11 						; do cursor downs.
.2611	a6 3e		ldx $3e				ldx 	NSMantissa0
.2613	20 19 26	jsr $2619			jsr 	_CLOutputXA
.2616	4c 27 10	jmp $1027			jmp 	NextCommand
.2619					_CLOutputXA:
.2619	ca		dex				dex
.261a	f0 07		beq $2623			beq 	_CLOExit
.261c	30 05		bmi $2623			bmi 	_CLOExit
.261e	20 48 24	jsr $2448			jsr 	XPrintCharacterToChannel
.2621	80 f6		bra $2619			bra 	_CLOutputXA
.2623					_CLOExit:
.2623	60		rts				rts
.2624					CommandColor:
.2624	fa		plx				plx
.2625	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.2628	ca		dex				dex
.2629	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.262c	ca		dex				dex
.262d	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.262f	c9 ff		cmp #$ff			cmp 	#$FF
.2631	f0 08		beq $263b			beq 	_CCNoBGR 					; if so, change background
.2633	20 43 26	jsr $2643			jsr 	_CCSetColour
.2636	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.2638	20 48 24	jsr $2448			jsr 	XPrintCharacterToChannel
.263b					_CCNoBGR:
.263b	a5 3e		lda $3e				lda 	NSMantissa0
.263d	20 43 26	jsr $2643			jsr 	_CCSetColour
.2640	4c 27 10	jmp $1027			jmp 	NextCommand
.2643					_CCSetColour:
.2643	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.2645	aa		tax				tax
.2646	bd 4d 26	lda $264d,x			lda 	_CCCommandTable,x
.2649	20 48 24	jsr $2448			jsr 	XPrintCharacterToChannel
.264c	60		rts				rts
.264d					_CCCommandTable:
>264d	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>2655	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.265d					CommandVPOKE:
.265d	fa		plx				plx
.265e	20 03 18	jsr $1803			jsr 	GetInteger8Bit 				; poke value
.2661	48		pha				pha
.2662	ca		dex				dex
.2663	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.2666	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2668	8d 20 9f	sta $9f20			sta 	VRAMLow0
.266b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.266d	8d 21 9f	sta $9f21			sta 	VRAMMed0
.2670	ca		dex				dex
.2671	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.2674	20 03 18	jsr $1803			jsr 	GetInteger8Bit
.2677	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.267a	ca		dex				dex
.267b	68		pla				pla 								; poke value back
.267c	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.267f	4c 27 10	jmp $1027			jmp 	NextCommand
.2682					CommandVPEEK:
.2682	fa		plx				plx
.2683	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.2686	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2688	8d 20 9f	sta $9f20			sta 	VRAMLow0
.268b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.268d	8d 21 9f	sta $9f21			sta 	VRAMMed0
.2690	ca		dex				dex
.2691	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.2694	20 03 18	jsr $1803			jsr 	GetInteger8Bit
.2697	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.269a	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.269d	20 08 2e	jsr $2e08			jsr 	FloatSetByte 				; return as byte
.26a0	4c 27 10	jmp $1027			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$1000					CodeStart = $1000
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.26a3					ErrorV_range:
.26a3	20 1c 14	jsr $141c		jsr	ErrorHandler
>26a6	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>26ae	41 4e 47 45 00
.26b3					ErrorV_value:
.26b3	20 1c 14	jsr $141c		jsr	ErrorHandler
>26b6	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>26be	45 00
.26c0					ErrorV_syntax:
.26c0	20 1c 14	jsr $141c		jsr	ErrorHandler
>26c3	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>26cb	52 52 4f 52 00
.26d0					ErrorV_type:
.26d0	20 1c 14	jsr $141c		jsr	ErrorHandler
>26d3	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>26db	4d 41 54 43 48 00
.26e1					ErrorV_unimplemented:
.26e1	20 1c 14	jsr $141c		jsr	ErrorHandler
>26e4	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>26ec	45 4d 45 4e 54 45 44 00
.26f4					ErrorV_assert:
.26f4	20 1c 14	jsr $141c		jsr	ErrorHandler
>26f7	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>26ff	41 49 4c 00
.2703					ErrorV_line:
.2703	20 1c 14	jsr $141c		jsr	ErrorHandler
>2706	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>270e	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.271a					ErrorV_internal:
.271a	20 1c 14	jsr $141c		jsr	ErrorHandler
>271d	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>2725	20 45 52 52 4f 52 00
.272c					ErrorV_divzero:
.272c	20 1c 14	jsr $141c		jsr	ErrorHandler
>272f	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>2737	59 20 5a 45 52 4f 00
.273e					ErrorV_structure:
.273e	20 1c 14	jsr $141c		jsr	ErrorHandler
>2741	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>2749	45 20 49 4d 42 41 4c 41 4e 43 45 00
.2755					ErrorV_stop:
.2755	20 1c 14	jsr $141c		jsr	ErrorHandler
>2758	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>2760	53 54 4f 50 50 45 44 00
.2768					ErrorV_data:
.2768	20 1c 14	jsr $141c		jsr	ErrorHandler
>276b	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>2773	41 54 41 00
.2777					ErrorV_undeclared:
.2777	20 1c 14	jsr $141c		jsr	ErrorHandler
>277a	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>2782	41 52 52 41 59 00
.2788					ErrorV_redefine:
.2788	20 1c 14	jsr $141c		jsr	ErrorHandler
>278b	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>2793	44 45 46 49 4e 45 44 00
.279b					ErrorV_index:
.279b	20 1c 14	jsr $141c		jsr	ErrorHandler
>279e	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>27a6	59 20 49 4e 44 45 58 00
.27ae					ErrorV_memory:
.27ae	20 1c 14	jsr $141c		jsr	ErrorHandler
>27b1	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>27b9	45 4d 4f 52 59 00
.27bf					ErrorV_channel:
.27bf	20 1c 14	jsr $141c		jsr	ErrorHandler
>27c2	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>27ca	54 50 55 54 20 45 52 52 4f 52 00
.27d5					MoveObjectForward:
.27d5	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.27d7	c9 ff		cmp #$ff			cmp 	#$FF
.27d9	f0 36		beq $2811			beq 	_MOFEnd
.27db	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.27dd	90 24		bcc $2803			bcc 	_MOFAdvance1 				; forward 1
.27df	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.27e1	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.27e3	90 20		bcc $2805			bcc 	_MOFAdvanceY
.27e5	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.27e7	90 1a		bcc $2803			bcc 	_MOFAdvance1 				; forward 1
.27e9	a8		tay				tay 								; read the size.
.27ea	b9 4f 27	lda $274f,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.27ed	a8		tay				tay
.27ee	c8		iny				iny 								; add 1 for the system token.
.27ef	d0 14		bne $2805			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.27f1	a0 01		ldy #$01			ldy 	#1 							; get length byte
.27f3	b1 2a		lda ($2a),y			lda 	(objPtr),y
.27f5	a8		tay				tay 								; into Y.
.27f6	18		clc				clc
.27f7	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.27f9	69 02		adc #$02			adc 	#2
.27fb	85 2a		sta $2a				sta 	objPtr
.27fd	90 02		bcc $2801			bcc 	_MOFNoCarry1
.27ff	e6 2b		inc $2b				inc 	objPtr+1
.2801					_MOFNoCarry1:
.2801	80 02		bra $2805			bra 	_MOFAdvanceY
.2803					_MOFAdvance1:
.2803	a0 01		ldy #$01			ldy 	#1
.2805					_MOFAdvanceY:
.2805	98		tya				tya 								; add Y to objPtr
.2806	18		clc				clc
.2807	65 2a		adc $2a				adc 	objPtr
.2809	85 2a		sta $2a				sta 	objPtr
.280b	90 02		bcc $280f			bcc 	_MOFNoCarry2
.280d	e6 2b		inc $2b				inc 	objPtr+1
.280f					_MOFNoCarry2:
.280f	18		clc				clc 								; not completed.
.2810	60		rts				rts
.2811					_MOFEnd:
.2811	e6 2a		inc $2a				inc 	objPtr
.2813	d0 02		bne $2817			bne 	_MOFENoCarry
.2815	e6 2b		inc $2b				inc 	objPtr+1
.2817					_MOFENoCarry:
.2817	38		sec				sec
.2818	60		rts				rts
.2819					MOFSizeTable:
>2819	01					.byte	1         	; $ca .shift
>281a	01					.byte	1         	; $cb .byte
>281b	02					.byte	2         	; $cc .word
>281c	05					.byte	5         	; $cd .float
>281d	ff					.byte	255       	; $ce .string
>281e	ff					.byte	255       	; $cf .data
>281f	02					.byte	2         	; $d0 .goto
>2820	02					.byte	2         	; $d1 .gosub
>2821	02					.byte	2         	; $d2 .goto.z
>2822	02					.byte	2         	; $d3 .goto.nz
>2823	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.056d					numberBuffer:
>056d							.fill 	34
.2824					FloatSubtract:
.2824	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.2826	49 80		eor #$80			eor 	#$80
.2828	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.282a					FloatAdd:
.282a	ca		dex				dex
.282b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.282d	15 6f		ora $6f,x			ora 	NSExponent+1,x
.282f	15 62		ora $62,x			ora 	NSMantissa3,x
.2831	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2833	d0 04		bne $2839			bne 	_FAUseFloat
.2835	20 c6 2b	jsr $2bc6			jsr 	FloatInt32Add 				; use the int32 one.
.2838	60		rts				rts
.2839					_FAUseFloat:
.2839	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise 				; normalise S[X]
.283c	f0 51		beq $288f			beq 	_FAReturn1
.283e	e8		inx				inx 								; normalise S[X+1]
.283f	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise
.2842	ca		dex				dex
.2843	c9 00		cmp #$00			cmp 	#0
.2845	f0 60		beq $28a7			beq 	_FAExit 					; if so, just return A
.2847	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.2849	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.284b	f0 18		beq $2865			beq 	_FAExponentsEqual
.284d	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.284f	a8		tay				tay
.2850	38		sec				sec 								; do a signed comparison of the exponents.
.2851	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.2853	50 02		bvc $2857			bvc 	_FANoSignedChange
.2855	49 80		eor #$80			eor 	#$80
.2857					_FANoSignedChange:
.2857	29 80		and #$80			and 	#$80
.2859	10 02		bpl $285d			bpl 	_FAHaveMax
.285b	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.285d					_FAHaveMax:
.285d	20 a8 28	jsr $28a8			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.2860	e8		inx				inx
.2861	20 a8 28	jsr $28a8			jsr 	_FAShiftToExponent
.2864	ca		dex				dex
.2865					_FAExponentsEqual:
.2865	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.2867	55 33		eor $33,x			eor 	NSStatus+1,x
.2869	30 0e		bmi $2879			bmi 	_FADifferentSigns
.286b	20 92 2b	jsr $2b92			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.286e	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.2870	10 35		bpl $28a7			bpl 	_FAExit 					; if no, we are done.
.2872	20 1f 2e	jsr $2e1f			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.2875	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.2877	80 2e		bra $28a7			bra 	_FAExit
.2879					_FADifferentSigns:
.2879	20 ac 2b	jsr $2bac			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.287c	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.287e	10 06		bpl $2886			bpl 	_FACheckZero 				; if no, check for -0
.2880	20 c8 2d	jsr $2dc8			jsr 	FloatNegate 					; netate result
.2883	20 cf 2d	jsr $2dcf			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.2886					_FACheckZero:
.2886	20 28 2e	jsr $2e28			jsr 	FloatIsZero	 				; check for -0
.2889	d0 1c		bne $28a7			bne 	_FAExit
.288b	74 32		stz $32,x			stz 	NSStatus,x
.288d	80 18		bra $28a7			bra 	_FAExit
.288f					_FAReturn1:
.288f	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.2891	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2893	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2895	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2897	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.2899	95 56		sta $56,x			sta 	NSMantissa2,x
.289b	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.289d	95 62		sta $62,x			sta 	NSMantissa3,x
.289f	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.28a1	95 6e		sta $6e,x			sta 	NSExponent,x
.28a3	b5 33		lda $33,x			lda 	NSStatus+1,x
.28a5	95 32		sta $32,x			sta 	NSStatus,x
.28a7					_FAExit:
.28a7	60		rts				rts
.28a8					_FAShiftToExponent:
.28a8					_FAShiftToExponent2:
.28a8	98		tya				tya 								; compare Y to exponent
.28a9	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.28ab	f0 07		beq $28b4			beq 	_FASEExit 					; exit if so.
.28ad	20 1f 2e	jsr $2e1f			jsr 	FloatShiftRight	 			; shift the mantissa right
.28b0	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.28b2	80 f4		bra $28a8			bra 	_FAShiftToExponent2
.28b4					_FASEExit:
.28b4	60		rts				rts
.28b5					CompareEqual:
.28b5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.28b7	d0 09		bne $28c2			bne 	ReturnFalse
.28b9					ReturnTrue:
.28b9	a9 01		lda #$01			lda 	#1
.28bb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.28bd	a9 80		lda #$80			lda 	#$80
.28bf	95 32		sta $32,x			sta 	NSStatus,x
.28c1	60		rts				rts
.28c2					ReturnFalse:
.28c2	74 3e		stz $3e,x			stz 	NSMantissa0,x
.28c4	60		rts				rts
.28c5					CompareNotEqual:
.28c5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.28c7	d0 f0		bne $28b9			bne 	ReturnTrue
.28c9	80 f7		bra $28c2			bra 	ReturnFalse
.28cb					CompareLess:
.28cb	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.28cd	c9 ff		cmp #$ff			cmp 	#$FF
.28cf	f0 e8		beq $28b9			beq 	ReturnTrue
.28d1	80 ef		bra $28c2			bra 	ReturnFalse
.28d3					CompareGreater:
.28d3	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.28d5	c9 01		cmp #$01			cmp 	#$01
.28d7	f0 e0		beq $28b9			beq 	ReturnTrue
.28d9	80 e7		bra $28c2			bra 	ReturnFalse
.28db					CompareLessEqual:
.28db	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.28dd	c9 01		cmp #$01			cmp 	#$01
.28df	d0 d8		bne $28b9			bne 	ReturnTrue
.28e1	80 df		bra $28c2			bra 	ReturnFalse
.28e3					CompareGreaterEqual:
.28e3	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.28e5	c9 ff		cmp #$ff			cmp 	#$FF
.28e7	d0 d0		bne $28b9			bne 	ReturnTrue
.28e9	80 d7		bra $28c2			bra 	ReturnFalse
.28eb					FloatCompare:
.28eb	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.28ed	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.28ef	48		pha				pha
.28f0	20 24 28	jsr $2824			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.28f3	68		pla				pla
.28f4	d0 0c		bne $2902			bne 	_FCCompareFloat
.28f6	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.28f8	15 4a		ora $4a,x			ora 	NSMantissa1,x
.28fa	15 56		ora $56,x			ora 	NSMantissa2,x
.28fc	15 62		ora $62,x			ora 	NSMantissa3,x
.28fe	f0 14		beq $2914			beq 	_FCExit 					; if zero, return zero
.2900	80 0a		bra $290c			bra 	_FCSign
.2902					_FCCompareFloat:
.2902	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2904	29 f0		and #$f0			and 	#$F0
.2906	15 56		ora $56,x			ora 	NSMantissa2,x
.2908	15 62		ora $62,x			ora 	NSMantissa3,x
.290a	f0 08		beq $2914			beq 	_FCExit 					; zero, so approximately identical
.290c					_FCSign:
.290c	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.290e	34 32		bit $32,x			bit 	NSStatus,x
.2910	10 02		bpl $2914			bpl 	_FCExit
.2912					_FCNegative:
.2912	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2914					_FCExit:
.2914	20 08 2e	jsr $2e08			jsr 	FloatSetByte 				; set the result 255,0,1
.2917	60		rts				rts
.2918					FloatScalarTable:
>2918	66 66 66 66				.dword $66666666 ; 0.1
>291c	de					.byte $de
>291d	1f 85 eb 51				.dword $51eb851f ; 0.01
>2921	db					.byte $db
>2922	4c 37 89 41				.dword $4189374c ; 0.001
>2926	d8					.byte $d8
>2927	ac 8b db 68				.dword $68db8bac ; 0.0001
>292b	d4					.byte $d4
>292c	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>2930	d1					.byte $d1
>2931	83 de 1b 43				.dword $431bde83 ; 1e-06
>2935	ce					.byte $ce
>2936	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>293a	ca					.byte $ca
>293b	89 3b e6 55				.dword $55e63b89 ; 1e-08
>293f	c7					.byte $c7
>2940	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>2944	c4					.byte $c4
>2945	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>2949	c0					.byte $c0
>294a	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>294e	bd					.byte $bd
.294f					FloatDivide:
.294f	48		pha				pha
.2950	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2953	ca		dex				dex
.2954	c9 00		cmp #$00			cmp 	#0
.2956	f0 1e		beq $2976			beq 	_FDZero
.2958	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.295b	f0 16		beq $2973			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.295d	20 be 29	jsr $29be			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.2960	20 8b 29	jsr $298b			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.2963	20 5b 2b	jsr $2b5b			jsr		FloatNormalise 				; renormalise
.2966	20 51 2b	jsr $2b51			jsr 	FloatCalculateSign 			; calculate result sign
.2969	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.296b	38		sec				sec
.296c	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.296e	38		sec				sec
.296f	e9 1e		sbc #$1e			sbc 	#30
.2971	95 6e		sta $6e,x			sta 	NSExponent,x
.2973					_FDExit:
.2973	68		pla				pla
.2974	18		clc				clc
.2975	60		rts				rts
.2976					_FDZero:
.2976	68		pla				pla
.2977	38		sec				sec
.2978	60		rts				rts
.2979					DivideInt32:
.2979	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart 			; make both integers
.297c	ca		dex				dex
.297d	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.2980	20 9c 29	jsr $299c			jsr 	Int32Divide 				; divide
.2983	20 8b 29	jsr $298b			jsr 	NSMCopyPlusTwoToZero 		; copy result
.2986	20 51 2b	jsr $2b51			jsr 	FloatCalculateSign 			; calculate result sign
.2989	18		clc				clc
.298a	60		rts				rts
.298b					NSMCopyPlusTwoToZero:
.298b	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.298d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.298f	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.2991	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2993	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.2995	95 56		sta $56,x			sta 	NSMantissa2,x
.2997	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.2999	95 62		sta $62,x			sta 	NSMantissa3,x
.299b	60		rts				rts
.299c					Int32Divide:
.299c	48		pha				pha 								; save AXY
.299d	5a		phy				phy
.299e	20 e9 2d	jsr $2de9			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.29a1	20 02 2e	jsr $2e02			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.29a4	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.29a6					_I32DivideLoop:
.29a6	e8		inx				inx
.29a7	e8		inx				inx
.29a8	20 15 2e	jsr $2e15			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.29ab	ca		dex				dex
.29ac	ca		dex				dex
.29ad	20 16 2e	jsr $2e16			jsr 	FloatRotateLeft
.29b0	20 dc 29	jsr $29dc			jsr 	FloatDivideCheck 			; check if subtract possible
.29b3	90 02		bcc $29b7			bcc 	_I32DivideNoCarryIn
.29b5	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.29b7					_I32DivideNoCarryIn:
.29b7	88		dey				dey 								; loop round till division completed.
.29b8	d0 ec		bne $29a6			bne 	_I32DivideLoop
.29ba	7a		ply				ply 								; restore AXY and exit
.29bb	68		pla				pla
.29bc	18		clc				clc
.29bd	60		rts				rts
.29be					Int32ShiftDivide:
.29be	48		pha				pha 								; save AY
.29bf	5a		phy				phy
.29c0	e8		inx				inx 								; clear S[X+2]
.29c1	e8		inx				inx
.29c2	20 06 2e	jsr $2e06			jsr 	FloatSetZero
.29c5	ca		dex				dex
.29c6	ca		dex				dex
.29c7	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.29c9					_I32SDLoop:
.29c9	20 dc 29	jsr $29dc			jsr 	FloatDivideCheck 			; check if subtract possible
.29cc	e8		inx				inx
.29cd	e8		inx				inx
.29ce	20 16 2e	jsr $2e16			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.29d1	ca		dex				dex
.29d2	ca		dex				dex
.29d3	20 16 2e	jsr $2e16			jsr 	FloatRotateLeft
.29d6	88		dey				dey 	 							; do 31 times
.29d7	d0 f0		bne $29c9			bne 	_I32SDLoop
.29d9	7a		ply				ply 								; restore AY and exit
.29da	68		pla				pla
.29db	60		rts				rts
.29dc					FloatDivideCheck:
.29dc	20 ac 2b	jsr $2bac			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.29df	b0 04		bcs $29e5			bcs 	_DCSExit 					; if carry set, then could do, exit
.29e1	20 92 2b	jsr $2b92			jsr 	FloatAddTopTwoStack 		; add it back in
.29e4	18		clc				clc 								; and return False
.29e5					_DCSExit:
.29e5	60		rts				rts
.29e6					FloatFractionalPart:
.29e6	5a		phy				phy
.29e7	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.29e9	29 7f		and #$7f			and 	#$7F
.29eb	95 32		sta $32,x			sta 	NSStatus,x
.29ed	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise
.29f0	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.29f2	38		sec				sec
.29f3	e9 e0		sbc #$e0			sbc 	#$E0
.29f5	90 29		bcc $2a20			bcc 	_FFPExit 					; already fractional
.29f7	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.29f9	b0 22		bcs $2a1d			bcs 	_FFPZero
.29fb	a8		tay				tay 								; put count to do in Y
.29fc	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.29fe	20 25 2a	jsr $2a25			jsr 	_FFPPartial
.2a01	95 62		sta $62,x			sta 	NSMantissa3,x
.2a03	b5 56		lda $56,x			lda 	NSMantissa2,x
.2a05	20 25 2a	jsr $2a25			jsr 	_FFPPartial
.2a08	95 56		sta $56,x			sta 	NSMantissa2,x
.2a0a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2a0c	20 25 2a	jsr $2a25			jsr 	_FFPPartial
.2a0f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2a11	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2a13	20 25 2a	jsr $2a25			jsr 	_FFPPartial
.2a16	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2a18	20 28 2e	jsr $2e28			jsr 	FloatIsZero 					; zeroed check.
.2a1b	d0 03		bne $2a20			bne 	_FFPExit
.2a1d					_FFPZero:
.2a1d	20 06 2e	jsr $2e06			jsr 	FloatSetZero
.2a20					_FFPExit:
.2a20	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise
.2a23	7a		ply				ply
.2a24	60		rts				rts
.2a25					_FFPPartial:
.2a25	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2a27	f0 17		beq $2a40			beq 	_FFFPPExit
.2a29	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.2a2b	b0 0c		bcs $2a39			bcs 	_FFFPPWholeByte
.2a2d	5a		phy				phy
.2a2e					_FFFPPLeft:
.2a2e	0a		asl a				asl 	a
.2a2f	88		dey				dey
.2a30	d0 fc		bne $2a2e			bne 	_FFFPPLeft
.2a32	7a		ply				ply
.2a33					_FFFPPRight:
.2a33	4a		lsr a				lsr 	a
.2a34	88		dey				dey
.2a35	d0 fc		bne $2a33			bne 	_FFFPPRight
.2a37	80 07		bra $2a40			bra 	_FFFPPExit
.2a39					_FFFPPWholeByte:
.2a39	98		tya				tya 								; subtract 8 from count
.2a3a	38		sec				sec
.2a3b	e9 08		sbc #$08			sbc 	#8
.2a3d	a8		tay				tay
.2a3e	a9 00		lda #$00			lda 	#0 							; and clear all
.2a40					_FFFPPExit:
.2a40	60		rts				rts
.2a41					FloatIntegerPart:
.2a41	48		pha				pha
.2a42	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.2a44	f0 1d		beq $2a63			beq 	_FIPExit 					; if so do nothing
.2a46	20 28 2e	jsr $2e28			jsr 	FloatIsZero 				; is it zero ?
.2a49	f0 15		beq $2a60			beq 	_FIPZero 					; if so return zero.
.2a4b	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise 				; normalise
.2a4e	f0 10		beq $2a60			beq 	_FIPZero 					; normalised to zero, exit zero
.2a50					_FIPShift:
.2a50	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2a52	10 07		bpl $2a5b			bpl 	_FIPCheckZero
.2a54	20 1f 2e	jsr $2e1f			jsr 	FloatShiftRight 			; shift mantissa right
.2a57	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.2a59	80 f5		bra $2a50			bra 	_FIPShift
.2a5b					_FIPCheckZero:
.2a5b	20 28 2e	jsr $2e28			jsr 	FloatIsZero 				; avoid -0 problem
.2a5e	d0 03		bne $2a63			bne 	_FIPExit 					; set to zero if mantissa zero.
.2a60					_FIPZero:
.2a60	20 06 2e	jsr $2e06			jsr 	FloatSetZero
.2a63					_FIPExit:
.2a63	68		pla				pla
.2a64	60		rts				rts
.2a65					FloatIntegerPartDown:
.2a65	48		pha				pha
.2a66	5a		phy				phy
.2a67	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.2a69	f0 36		beq $2aa1			beq 	_FIPExit 					; if so do nothing
.2a6b	20 28 2e	jsr $2e28			jsr 	FloatIsZero 				; is it zero ?
.2a6e	f0 2e		beq $2a9e			beq 	_FIPZero 					; if so return zero.
.2a70	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise 				; normalise
.2a73	f0 29		beq $2a9e			beq 	_FIPZero 					; normalised to zero, exit zero
.2a75	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.2a77					_FIPShift:
.2a77	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2a79	10 0a		bpl $2a85			bpl 	_FIPCheckDown
.2a7b	20 1f 2e	jsr $2e1f			jsr 	FloatShiftRight 			; shift mantissa right
.2a7e	90 01		bcc $2a81			bcc 	_FIPNoFrac 					; shifted a zero out ?
.2a80	c8		iny				iny
.2a81					_FIPNoFrac:
.2a81	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.2a83	80 f2		bra $2a77			bra 	_FIPShift
.2a85					_FIPCheckDown:
.2a85	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.2a87	f0 10		beq $2a99			beq 	_FIPCheckZero
.2a89	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.2a8b	10 0c		bpl $2a99			bpl 	_FIPCheckZero
.2a8d	e8		inx				inx 								; -ve so round *down*.
.2a8e	a9 01		lda #$01			lda 	#1
.2a90	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.2a93	20 c8 2d	jsr $2dc8			jsr 	FloatNegate
.2a96	20 2a 28	jsr $282a			jsr 	FloatAdd
.2a99					_FIPCheckZero:
.2a99	20 28 2e	jsr $2e28			jsr 	FloatIsZero 				; avoid -0 problem
.2a9c	d0 03		bne $2aa1			bne 	_FIPExit 					; set to zero if mantissa zero.
.2a9e					_FIPZero:
.2a9e	20 06 2e	jsr $2e06			jsr 	FloatSetZero
.2aa1					_FIPExit:
.2aa1	7a		ply				ply
.2aa2	68		pla				pla
.2aa3	60		rts				rts
.2aa4					FloatInt8Multiply:
.2aa4	5a		phy				phy
.2aa5	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2aa7	a8		tay				tay
.2aa8	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2aaa					_FI8MLoop:
.2aaa	98		tya				tya 								; shift right shifter right into carry
.2aab	4a		lsr a				lsr 	a
.2aac	a8		tay				tay
.2aad	90 0d		bcc $2abc			bcc 	_FI8MNoAdd
.2aaf	18		clc				clc
.2ab0	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2ab2	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.2ab4	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2ab6	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2ab8	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.2aba	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2abc					_FI8MNoAdd:
.2abc	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.2abe	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.2ac0	c0 00		cpy #$00			cpy 	#0
.2ac2	d0 e6		bne $2aaa			bne 	_FI8MLoop 					; until right shifter zero.
.2ac4	7a		ply				ply
.2ac5	60		rts				rts
.2ac6					FloatMultiply:
.2ac6	ca		dex				dex
.2ac7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.2ac9	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2acb	15 62		ora $62,x			ora 	NSMantissa3,x
.2acd	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2acf	d0 21		bne $2af2			bne 	_FMUseFloat
.2ad1	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2ad3	15 33		ora $33,x			ora 	NSStatus+1,x
.2ad5	29 80		and #$80			and 	#$80
.2ad7	15 62		ora $62,x			ora 	NSMantissa3,x
.2ad9	15 56		ora $56,x			ora 	NSMantissa2,x
.2adb	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2add	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2adf	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2ae1	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2ae3	d0 04		bne $2ae9			bne 	_FMInt32
.2ae5	20 a4 2a	jsr $2aa4			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2ae8	60		rts				rts
.2ae9					_FMInt32:
.2ae9	20 13 2b	jsr $2b13			jsr 	FloatMultiplyShort			; use the int32 one.
.2aec	18		clc				clc 								; fix it up if gone out of range
.2aed	75 6e		adc $6e,x			adc 	NSExponent,x
.2aef	95 6e		sta $6e,x			sta 	NSExponent,x
.2af1	60		rts				rts
.2af2					_FMUseFloat:
.2af2	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2af5	f0 18		beq $2b0f			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2af7	e8		inx				inx
.2af8	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2afb	ca		dex				dex
.2afc	c9 00		cmp #$00			cmp 	#0
.2afe	f0 0c		beq $2b0c			beq 	_FDSetZero
.2b00	20 13 2b	jsr $2b13			jsr 	FloatMultiplyShort 			; calculate the result.
.2b03	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2b05	18		clc				clc
.2b06	75 6f		adc $6f,x			adc 	NSExponent+1,x
.2b08	95 6e		sta $6e,x			sta 	NSExponent,x
.2b0a	80 03		bra $2b0f			bra 	_FDExit
.2b0c					_FDSetZero:
.2b0c	20 06 2e	jsr $2e06			jsr 	FloatSetZero 				; return 0
.2b0f					_FDExit:
.2b0f	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise 				; normalise the result
.2b12	60		rts				rts
.2b13					FloatMultiplyShort:
.2b13	5a		phy				phy 								; save Y
.2b14	20 e9 2d	jsr $2de9			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2b17	20 02 2e	jsr $2e02			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2b1a	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2b1c					_I32MLoop:
.2b1c	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2b1e	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.2b20	15 58		ora $58,x			ora 	NSMantissa2+2,x
.2b22	15 64		ora $64,x			ora 	NSMantissa3+2,x
.2b24	f0 25		beq $2b4b			beq 	_I32MExit 					; exit if zero
.2b26	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2b28	29 01		and #$01			and 	#1
.2b2a	f0 0d		beq $2b39			beq 	_I32MNoAdd
.2b2c	20 92 2b	jsr $2b92			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.2b2f	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.2b31	10 06		bpl $2b39			bpl 	_I32MNoAdd
.2b33					_I32ShiftRight:
.2b33	20 1f 2e	jsr $2e1f			jsr 	FloatShiftRight 			; shift S[X] right
.2b36	c8		iny				iny 								; increment shift count
.2b37	80 09		bra $2b42			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.2b39					_I32MNoAdd:
.2b39	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.2b3b	70 f6		bvs $2b33			bvs 	_I32ShiftRight 				; instead.
.2b3d	e8		inx				inx
.2b3e	20 15 2e	jsr $2e15			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.2b41	ca		dex				dex
.2b42					_I32MShiftUpper:
.2b42	e8		inx				inx 								; shift S[X+2] right
.2b43	e8		inx				inx
.2b44	20 1f 2e	jsr $2e1f			jsr 	FloatShiftRight
.2b47	ca		dex				dex
.2b48	ca		dex				dex
.2b49	80 d1		bra $2b1c			bra 	_I32MLoop 					; try again.
.2b4b					_I32MExit:
.2b4b	20 51 2b	jsr $2b51			jsr 	FloatCalculateSign
.2b4e	98		tya				tya 								; shift in A
.2b4f	7a		ply				ply 								; restore Y and exit
.2b50	60		rts				rts
.2b51					FloatCalculateSign:
.2b51	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.2b53	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.2b55	55 33		eor $33,x			eor 	NSStatus+1,x
.2b57	0a		asl a				asl 	a 							; shift bit 7 into carry
.2b58	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.2b5a	60		rts				rts
.2b5b					FloatNormalise:
.2b5b	20 28 2e	jsr $2e28			jsr 	FloatIsZero 				; if zero exit
.2b5e	d0 07		bne $2b67			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.2b60	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.2b62	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.2b64	a9 00		lda #$00			lda 	#0 							; set Z flag
.2b66	60		rts				rts
.2b67					_NSNormaliseOptimise:
.2b67	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.2b69	d0 19		bne $2b84			bne 	_NSNormaliseLoop
.2b6b	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.2b6d	30 15		bmi $2b84			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.2b6f	95 62		sta $62,x			sta 	NSMantissa3,x
.2b71	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2b73	95 56		sta $56,x			sta 	NSMantissa2,x
.2b75	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2b77	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2b79	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2b7b	b5 6e		lda $6e,x			lda 	NSExponent,x
.2b7d	38		sec				sec
.2b7e	e9 08		sbc #$08			sbc 	#8
.2b80	95 6e		sta $6e,x			sta 	NSExponent,x
.2b82	80 e3		bra $2b67			bra 	_NSNormaliseOptimise
.2b84					_NSNormaliseLoop:
.2b84	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.2b86	70 07		bvs $2b8f			bvs 	_NSNExit 					; exit if so with Z flag clear
.2b88	20 15 2e	jsr $2e15			jsr 	FloatShiftLeft 				; shift mantissa left
.2b8b	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.2b8d	80 f5		bra $2b84			bra 	_NSNormaliseLoop
.2b8f					_NSNExit:
.2b8f	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.2b91	60		rts				rts
.2b92					FloatAddTopTwoStack:
.2b92	18		clc				clc
.2b93	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2b95	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.2b97	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2b99	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2b9b	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.2b9d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2b9f	b5 56		lda $56,x			lda		NSMantissa2,x
.2ba1	75 57		adc $57,x			adc 		NSMantissa2+1,x
.2ba3	95 56		sta $56,x			sta 	NSMantissa2,x
.2ba5	b5 62		lda $62,x			lda		NSMantissa3,x
.2ba7	75 63		adc $63,x			adc 		NSMantissa3+1,x
.2ba9	95 62		sta $62,x			sta 	NSMantissa3,x
.2bab	60		rts				rts
.2bac					FloatSubTopTwoStack:
.2bac	38		sec				sec
.2bad	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2baf	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.2bb1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2bb3	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2bb5	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.2bb7	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2bb9	b5 56		lda $56,x			lda		NSMantissa2,x
.2bbb	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.2bbd	95 56		sta $56,x			sta 	NSMantissa2,x
.2bbf	b5 62		lda $62,x			lda		NSMantissa3,x
.2bc1	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.2bc3	95 62		sta $62,x			sta 	NSMantissa3,x
.2bc5	60		rts				rts
.2bc6					FloatInt32Add:
.2bc6	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2bc8	55 33		eor $33,x			eor 	NSStatus+1,x
.2bca	30 04		bmi $2bd0			bmi 	_DiffSigns
.2bcc	20 92 2b	jsr $2b92			jsr		FloatAddTopTwoStack
.2bcf	60		rts				rts
.2bd0					_DiffSigns:
.2bd0	20 ac 2b	jsr $2bac			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2bd3	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2bd5	10 07		bpl $2bde			bpl 	_AddExit
.2bd7	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2bd9	95 32		sta $32,x			sta 	NSStatus,x
.2bdb	20 cf 2d	jsr $2dcf			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2bde					_AddExit:
.2bde	20 28 2e	jsr $2e28			jsr 	FloatIsZero 				; check for -0
.2be1	d0 02		bne $2be5			bne 	_AddNonZero
.2be3	74 32		stz $32,x			stz 	NSStatus,x
.2be5					_AddNonZero:
.2be5	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2be6					FloatEncodeStart:
.2be6	38		sec				sec
.2be7	80 01		bra $2bea			bra 	FloatEncodeContinue+1
.2be9					FloatEncodeContinue:
.2be9	18		clc				clc
.2bea					FloatEncode:
.2bea	08		php				php 								; save reset flag.
.2beb	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2bed	f0 15		beq $2c04			beq 	_ENIsOkay
.2bef	c9 30		cmp #$30			cmp 	#"0"
.2bf1	90 04		bcc $2bf7			bcc 	_ENBadNumber
.2bf3	c9 3a		cmp #$3a			cmp 	#"9"+1
.2bf5	90 0d		bcc $2c04			bcc 	_ENIsOkay
.2bf7					_ENBadNumber:
.2bf7	28		plp				plp 								; throw saved reset
.2bf8	ad 8f 05	lda $058f			lda 	encodeState 				; if in decimal mode, construct final number
.2bfb	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2bfd	d0 03		bne $2c02			bne 	_ENFail
.2bff	4c 7c 2c	jmp $2c7c			jmp 	_ENConstructFinal
.2c02					_ENFail:
.2c02	18		clc				clc 								; not allowed
.2c03	60		rts				rts
.2c04					_ENIsOkay:
.2c04	28		plp				plp 								; are we restarting
.2c05	90 15		bcc $2c1c			bcc 	_ENNoRestart
.2c07					_ENStartEncode:
.2c07	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2c09	f0 0c		beq $2c17			beq 	_ENFirstDP
.2c0b	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2c0d	20 08 2e	jsr $2e08			jsr 	FloatSetByte 				; in single byte mode.
.2c10	a9 01		lda #$01			lda 	#ESTA_Low
.2c12					_ENExitChange:
.2c12	8d 8f 05	sta $058f			sta 	encodeState 				; save new state
.2c15	38		sec				sec
.2c16	60		rts				rts
.2c17					_ENFirstDP:
.2c17	20 06 2e	jsr $2e06			jsr 	FloatSetZero 				; clear integer part
.2c1a	80 3c		bra $2c58			bra 	_ESTASwitchFloat			; go straight to float and exi
.2c1c					_ENNoRestart:
.2c1c	48		pha				pha 								; save digit or DP on stack.
.2c1d	ad 8f 05	lda $058f			lda 	encodeState 				; get current state
.2c20	c9 01		cmp #$01			cmp 	#ESTA_Low
.2c22	f0 09		beq $2c2d			beq  	_ESTALowState
.2c24	c9 02		cmp #$02			cmp 	#ESTA_High
.2c26	f0 26		beq $2c4e			beq 	_ESTAHighState
.2c28	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2c2a	f0 38		beq $2c64			beq 	_ESTADecimalState
>2c2c	db						.byte 	$DB 						; causes a break in the emulator
.2c2d					_ESTALowState:
.2c2d	68		pla				pla 								; get value back
.2c2e	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.2c30	f0 26		beq $2c58			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.2c32	29 0f		and #$0f			and 	#15 						; make digit
.2c34	8d 90 05	sta $0590			sta 	digitTemp 					; save it.
.2c37	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.2c39	0a		asl a				asl 	a
.2c3a	0a		asl a				asl 	a
.2c3b	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2c3d	0a		asl a				asl 	a
.2c3e	6d 90 05	adc $0590			adc 	digitTemp
.2c41	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2c43	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.2c45	90 05		bcc $2c4c			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.2c47	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.2c49	8d 8f 05	sta $058f			sta 	encodeState
.2c4c					_ESTANoSwitch:
.2c4c	38		sec				sec
.2c4d	60		rts				rts
.2c4e					_ESTAHighState:
.2c4e	68		pla				pla 								; get value back
.2c4f	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.2c51	f0 05		beq $2c58			beq 	_ESTASwitchFloat
.2c53	20 ae 2c	jsr $2cae			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.2c56	38		sec				sec
.2c57	60		rts				rts
.2c58					_ESTASwitchFloat:
.2c58	9c 91 05	stz $0591			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.2c5b	e8		inx				inx 								; zero the decimal additive.
.2c5c	20 06 2e	jsr $2e06			jsr 	FloatSetZero
.2c5f	ca		dex				dex
.2c60	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.2c62	80 ae		bra $2c12			bra 	_ENExitChange
.2c64					_ESTADecimalState:
.2c64	68		pla				pla 								; digit.
.2c65	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.2c67	f0 99		beq $2c02			beq 	_ENFail
.2c69	e8		inx				inx 								; put digit into fractional part of X+1
.2c6a	20 ae 2c	jsr $2cae			jsr 	ESTAShiftDigitIntoMantissa
.2c6d	ca		dex				dex
.2c6e	ee 91 05	inc $0591			inc 	decimalCount 				; bump the count of decimals
.2c71	ad 91 05	lda $0591			lda 	decimalCount 				; too many decimal digits.
.2c74	c9 0b		cmp #$0b			cmp 	#11
.2c76	f0 02		beq $2c7a			beq 	_ESTADSFail
.2c78	38		sec				sec
.2c79	60		rts				rts
.2c7a					_ESTADSFail:
.2c7a	18		clc				clc
.2c7b	60		rts				rts
.2c7c					_ENConstructFinal:
.2c7c	ad 91 05	lda $0591			lda 	decimalCount 				; get decimal count
.2c7f	f0 2b		beq $2cac			beq 	_ENCFExit 					; no decimals
.2c81	5a		phy				phy
.2c82	0a		asl a				asl 	a 							; x 4 and CLC
.2c83	0a		asl a				asl 	a
.2c84	6d 91 05	adc $0591			adc 	decimalCount
.2c87	a8		tay				tay
.2c88	b9 13 29	lda $2913,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.2c8b	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.2c8d	b9 14 29	lda $2914,y			lda 	FloatScalarTable-5+1,y
.2c90	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2c92	b9 15 29	lda $2915,y			lda 	FloatScalarTable-5+2,y
.2c95	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2c97	b9 16 29	lda $2916,y			lda 	FloatScalarTable-5+3,y
.2c9a	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2c9c	b9 17 29	lda $2917,y			lda 	FloatScalarTable-5+4,y
.2c9f	95 70		sta $70,x			sta 	NSExponent+2,x
.2ca1	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.2ca3	e8		inx				inx 								; multiply decimal const by decimal scalar
.2ca4	e8		inx				inx
.2ca5	20 c6 2a	jsr $2ac6			jsr 	FloatMultiply
.2ca8	20 2a 28	jsr $282a			jsr 	FloatAdd 					; add to integer part.
.2cab	7a		ply				ply
.2cac					_ENCFExit:
.2cac	18		clc				clc 								; reject the digit.
.2cad	60		rts				rts
.2cae					ESTAShiftDigitIntoMantissa:
.2cae	29 0f		and #$0f			and 	#15 						; save digit
.2cb0	48		pha				pha
.2cb1	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2cb3	48		pha				pha
.2cb4	b5 56		lda $56,x			lda 	NSMantissa2,x
.2cb6	48		pha				pha
.2cb7	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2cb9	48		pha				pha
.2cba	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2cbc	48		pha				pha
.2cbd	20 15 2e	jsr $2e15			jsr 	FloatShiftLeft 				; x 2
.2cc0	20 15 2e	jsr $2e15			jsr 	FloatShiftLeft 				; x 4
.2cc3	18		clc				clc 								; pop mantissa and add
.2cc4	68		pla				pla
.2cc5	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2cc7	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2cc9	68		pla				pla
.2cca	75 4a		adc $4a,x			adc 	NSMantissa1,x
.2ccc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2cce	68		pla				pla
.2ccf	75 56		adc $56,x			adc 	NSMantissa2,x
.2cd1	95 56		sta $56,x			sta 	NSMantissa2,x
.2cd3	68		pla				pla
.2cd4	75 62		adc $62,x			adc 	NSMantissa3,x
.2cd6	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.2cd8	20 15 2e	jsr $2e15			jsr 	FloatShiftLeft 				; x 10
.2cdb	68		pla				pla 								; add digit
.2cdc	18		clc				clc
.2cdd	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2cdf	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2ce1	90 0a		bcc $2ced			bcc 	_ESTASDExit
.2ce3	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2ce5	d0 06		bne $2ced			bne 	_ESTASDExit
.2ce7	f6 56		inc $56,x			inc 	NSMantissa2,x
.2ce9	d0 02		bne $2ced			bne 	_ESTASDExit
.2ceb	f6 62		inc $62,x			inc 	NSMantissa3,x
.2ced					_ESTASDExit:
.2ced	60		rts				rts
.058f					encodeState:
>058f							.fill 	1
.0590					digitTemp:
>0590							.fill 	1
.0591					decimalCount:
>0591							.fill 	1
.2cee					FloatToString:
.2cee	da		phx				phx
.2cef	5a		phy				phy 								; save code position
.2cf0	8d 92 05	sta $0592			sta 	decimalPlaces	 			; save number of DPs.
.2cf3	9c 93 05	stz $0593			stz 	dbOffset 					; offset into decimal buffer = start.
.2cf6	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.2cf8	10 08		bpl $2d02			bpl 	_CNTSNotNegative
.2cfa	29 7f		and #$7f			and 	#$7F 						; make +ve
.2cfc	95 32		sta $32,x			sta 	NSStatus,x
.2cfe	a9 2d		lda #$2d			lda 	#"-"
.2d00	80 02		bra $2d04			bra 	_CNTMain
.2d02					_CNTSNotNegative:
.2d02	a9 20		lda #$20			lda 	#" "
.2d04					_CNTMain:
.2d04	20 66 2d	jsr $2d66			jsr 	WriteDecimalBuffer
.2d07	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.2d09	f0 0d		beq $2d18			beq 	_CNTSNotFloat
.2d0b	e8		inx				inx 								; round up so we don't get too many 6.999999
.2d0c	a9 01		lda #$01			lda 	#1
.2d0e	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.2d11	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2d13	95 6e		sta $6e,x			sta 	NSExponent,x
.2d15	20 2a 28	jsr $282a			jsr 	FloatAdd
.2d18					_CNTSNotFloat:
.2d18	20 48 2d	jsr $2d48			jsr 	MakePlusTwoString 			; do the integer part.
.2d1b	20 e6 29	jsr $29e6			jsr 	FloatFractionalPart 		; get the fractional part
.2d1e	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise					; normalise , exit if zero
.2d21	f0 22		beq $2d45			beq 	_CNTSExit
.2d23	a9 2e		lda #$2e			lda 	#"."
.2d25	20 66 2d	jsr $2d66			jsr 	WriteDecimalBuffer 			; write decimal place
.2d28					_CNTSDecimal:
.2d28	ce 92 05	dec $0592			dec 	decimalPlaces 				; done all the decimals
.2d2b	30 18		bmi $2d45			bmi 	_CNTSExit
.2d2d	e8		inx				inx 								; x 10.0
.2d2e	a9 0a		lda #$0a			lda 	#10
.2d30	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.2d33	20 c6 2a	jsr $2ac6			jsr 	FloatMultiply
.2d36	20 48 2d	jsr $2d48			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.2d39	20 e6 29	jsr $29e6			jsr 	FloatFractionalPart 		; get the fractional part
.2d3c	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise 				; normalise it.
.2d3f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.2d41	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.2d43	b0 e3		bcs $2d28			bcs 	_CNTSDecimal 				; keep going.
.2d45					_CNTSExit:
.2d45	7a		ply				ply
.2d46	fa		plx				plx
.2d47	60		rts				rts
.2d48					MakePlusTwoString:
.2d48	da		phx				phx
.2d49	20 e9 2d	jsr $2de9			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.2d4c	e8		inx				inx 								; access it
.2d4d	e8		inx				inx
.2d4e	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart 			; make it an integer
.2d51	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.2d53	20 85 2d	jsr $2d85			jsr 	ConvertInt32
.2d56	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.2d58					_MPTSCopy:
.2d58	bd 6d 05	lda $056d,x			lda 	numberBuffer,x
.2d5b	20 66 2d	jsr $2d66			jsr 	WriteDecimalBuffer
.2d5e	e8		inx				inx
.2d5f	bd 6d 05	lda $056d,x			lda 	numberBuffer,x
.2d62	d0 f4		bne $2d58			bne 	_MPTSCopy
.2d64	fa		plx				plx
.2d65	60		rts				rts
.2d66					WriteDecimalBuffer:
.2d66	da		phx				phx
.2d67	ae 93 05	ldx $0593			ldx 	dbOffset
.2d6a	9d 94 05	sta $0594,x			sta 	decimalBuffer,x
.2d6d	9e 95 05	stz $0595,x			stz 	decimalBuffer+1,x
.2d70	ee 93 05	inc $0593			inc 	dbOffset
.2d73	fa		plx				plx
.2d74	60		rts				rts
.0592					decimalPlaces:
>0592							.fill 	1
.0593					dbOffset:
>0593							.fill 	1
.0594					decimalBuffer:
>0594							.fill 	32
.2d75					ConvertInt16:
.2d75	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.2d77	86 4a		stx $4a				stx 	NSMantissa1
.2d79	64 56		stz $56				stz 	NSMantissa2
.2d7b	64 62		stz $62				stz 	NSMantissa3
.2d7d	64 32		stz $32				stz 	NSStatus 					; positive integer
.2d7f	a2 00		ldx #$00			ldx 	#0 							; stack level
.2d81	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.2d83	80 00		bra $2d85			bra 	ConvertInt32
.2d85					ConvertInt32:
.2d85	5a		phy				phy
.2d86	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.2d88	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.2d8a	10 08		bpl $2d94			bpl 	_CI32NotNeg
.2d8c	48		pha				pha
.2d8d	a9 2d		lda #$2d			lda 	#'-'
.2d8f	99 6d 05	sta $056d,y			sta 	numberBuffer,y
.2d92	c8		iny				iny
.2d93	68		pla				pla
.2d94					_CI32NotNeg:
.2d94	20 a2 2d	jsr $2da2			jsr 	_CI32DivideConvert 			; recursive conversion
.2d97	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2d99	99 6d 05	sta $056d,y			sta 	numberBuffer,y
.2d9c	7a		ply				ply
.2d9d	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.2d9f	a9 6d		lda #$6d			lda 	#numberBuffer & $FF
.2da1	60		rts				rts
.2da2					_CI32DivideConvert:
.2da2	e8		inx				inx 								; write to next slot up
.2da3	20 08 2e	jsr $2e08			jsr 	FloatSetByte 		 		; write the base out.
.2da6	ca		dex				dex
.2da7	20 9c 29	jsr $299c			jsr 	Int32Divide 				; divide
.2daa	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.2dac	48		pha				pha
.2dad	20 8b 29	jsr $298b			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2db0	20 28 2e	jsr $2e28			jsr 	FloatIsZero 				; is it zero ?
.2db3	f0 05		beq $2dba			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2db5	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2db7	20 a2 2d	jsr $2da2			jsr 	_CI32DivideConvert 			; and recusrively call.
.2dba					_CI32NoRecurse:
.2dba	68		pla				pla 								; remainder
.2dbb	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2dbd	90 02		bcc $2dc1			bcc 	_CI32NotHex
.2dbf	69 26		adc #$26			adc 	#6+32
.2dc1					_CI32NotHex:
.2dc1	69 30		adc #$30			adc 	#48
.2dc3	99 6d 05	sta $056d,y			sta 	numberBuffer,y 				; write out and exit
.2dc6	c8		iny				iny
.2dc7	60		rts				rts
.2dc8					FloatNegate:
.2dc8	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2dca	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2dcc	95 32		sta $32,x			sta 	NSStatus,x
.2dce	60		rts				rts
.2dcf					FloatNegateMantissa:
.2dcf	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2dd0	a9 00		lda #$00			lda 	#0
.2dd2	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2dd4	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2dd6	a9 00		lda #$00			lda 	#0
.2dd8	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.2dda	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2ddc	a9 00		lda #$00			lda 	#0
.2dde	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.2de0	95 56		sta $56,x			sta 	NSMantissa2,x
.2de2	a9 00		lda #$00			lda 	#0
.2de4	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2de6	95 62		sta $62,x			sta 	NSMantissa3,x
.2de8	60		rts				rts
.2de9					FloatShiftUpTwo:
.2de9	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2deb	95 40		sta $40,x			sta 	NSMantissa0+2,x
.2ded	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2def	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2df1	b5 56		lda $56,x			lda 	NSMantissa2,x
.2df3	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2df5	b5 62		lda $62,x			lda 	NSMantissa3,x
.2df7	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2df9	b5 6e		lda $6e,x			lda 	NSExponent,x
.2dfb	95 70		sta $70,x			sta 	NSExponent+2,x
.2dfd	b5 32		lda $32,x			lda 	NSStatus,x
.2dff	95 34		sta $34,x			sta 	NSStatus+2,x
.2e01	60		rts				rts
.2e02					FloatSetZeroMantissaOnly:
.2e02	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2e04	80 08		bra $2e0e			bra 	FloatZero13
.2e06					FloatSetZero:
.2e06	a9 00		lda #$00			lda 	#0
.2e08					FloatSetByte:
.2e08	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2e0a					FloatSetMantissa:
.2e0a	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.2e0c	74 32		stz $32,x			stz 	NSStatus,x
.2e0e					FloatZero13:
.2e0e	74 4a		stz $4a,x			stz 	NSMantissa1,x
.2e10	74 56		stz $56,x			stz 	NSMantissa2,x
.2e12	74 62		stz $62,x			stz 	NSMantissa3,x
.2e14	60		rts				rts
.2e15					FloatShiftLeft:
.2e15	18		clc				clc
.2e16					FloatRotateLeft:
.2e16	36 3e		rol $3e,x			rol 	NSMantissa0,x
.2e18	36 4a		rol $4a,x			rol		NSMantissa1,x
.2e1a	36 56		rol $56,x			rol		NSMantissa2,x
.2e1c	36 62		rol $62,x			rol		NSMantissa3,x
.2e1e	60		rts				rts
.2e1f					FloatShiftRight:
.2e1f	56 62		lsr $62,x			lsr 	NSMantissa3,x
.2e21	76 56		ror $56,x			ror		NSMantissa2,x
.2e23	76 4a		ror $4a,x			ror		NSMantissa1,x
.2e25	76 3e		ror $3e,x			ror		NSMantissa0,x
.2e27	60		rts				rts
.2e28					FloatIsZero:
.2e28	b5 62		lda $62,x			lda 	NSMantissa3,x
.2e2a	15 56		ora $56,x			ora		NSMantissa2,x
.2e2c	15 4a		ora $4a,x			ora		NSMantissa1,x
.2e2e	15 3e		ora $3e,x			ora		NSMantissa0,x
.2e30	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.2e31					FloatArcTan:
.2e31	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise 					; normalise x
.2e34	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.2e36	48		pha				pha
.2e37	74 32		stz $32,x			stz 	NSStatus,x
.2e39	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.2e3b	c9 e2		cmp #$e2			cmp 	#$E2
.2e3d	90 25		bcc $2e64			bcc 	_UANoFixup
.2e3f	8a		txa				txa 									; value in +1
.2e40	a8		tay				tay
.2e41	c8		iny				iny
.2e42	20 ea 2f	jsr $2fea			jsr 	CopyFloatXY
.2e45	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.2e47	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.2e4a	e8		inx				inx
.2e4b	20 4f 29	jsr $294f			jsr 	FloatDivide
.2e4e	b0 21		bcs $2e71			bcs 	_FATError
.2e50	20 74 2e	jsr $2e74			jsr 	CoreAtn 						; calculate the root
.2e53	20 df 2f	jsr $2fdf			jsr 	CompletePolynomial
.2e56	20 c8 2d	jsr $2dc8			jsr 	FloatNegate 					; make -ve
.2e59	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2e5b	20 36 30	jsr $3036			jsr 	LoadConstant
.2e5e	e8		inx				inx
.2e5f	20 2a 28	jsr $282a			jsr 	FloatAdd
.2e62	80 06		bra $2e6a			bra 	_UAComplete
.2e64					_UANoFixup:
.2e64	20 74 2e	jsr $2e74			jsr 	CoreAtn
.2e67	20 df 2f	jsr $2fdf			jsr 	CompletePolynomial
.2e6a					_UAComplete:
.2e6a	68		pla				pla 									; apply the result.
.2e6b	55 32		eor $32,x			eor 	NSStatus,x
.2e6d	95 32		sta $32,x			sta 	NSStatus,x
.2e6f	18		clc				clc
.2e70	60		rts				rts
.2e71					_FATError:
.2e71	68		pla				pla
.2e72	38		sec				sec
.2e73	60		rts				rts
.2e74					CoreAtn:
.2e74	a9 e2		lda #$e2			lda 	#AtnCoefficients & $FF
.2e76	a0 2e		ldy #$2e			ldy 	#AtnCoefficients >> 8
.2e78	4c 33 31	jmp $3133			jmp 	CorePolySquared
.2e7b					ExpCoefficients:
>2e7b	07					.byte	7
>2e7c	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>2e80	d2					.byte	$d2
>2e81	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>2e85	d5					.byte	$d5
>2e86	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>2e8a	d8					.byte	$d8
>2e8b	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>2e8f	db					.byte	$db
>2e90	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>2e94	dd					.byte	$dd
>2e95	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>2e99	df					.byte	$df
>2e9a	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>2e9e	e1					.byte	$e1
>2e9f	00 00 00 40				.dword	$40000000 ; 1.0
>2ea3	e2					.byte	$e2
.2ea4					SinCoefficients:
>2ea4	06					.byte	6
>2ea5	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>2ea9	e5					.byte	$e5
>2eaa	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>2eae	e7					.byte	$e7
>2eaf	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>2eb3	e8					.byte	$e8
>2eb4	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>2eb8	e8					.byte	$e8
>2eb9	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>2ebd	e7					.byte	$e7
>2ebe	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>2ec2	e4					.byte	$e4
>2ec3	00 00 00 00				.dword	$00000000 ; 0.0
>2ec7	00					.byte	$00
.2ec8					LogCoefficients:
>2ec8	04					.byte	4
>2ec9	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>2ecd	e0					.byte	$e0
>2ece	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>2ed2	e1					.byte	$e1
>2ed3	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>2ed7	e1					.byte	$e1
>2ed8	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>2edc	e3					.byte	$e3
>2edd	00 00 00 c0				.dword	$c0000000 ; -0.5
>2ee1	e1					.byte	$e1
.2ee2					AtnCoefficients:
>2ee2	0c					.byte	12
>2ee3	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2ee7	d7					.byte	$d7
>2ee8	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>2eec	da					.byte	$da
>2eed	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>2ef1	dc					.byte	$dc
>2ef2	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2ef6	dd					.byte	$dd
>2ef7	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>2efb	dd					.byte	$dd
>2efc	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>2f00	de					.byte	$de
>2f01	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2f05	de					.byte	$de
>2f06	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>2f0a	de					.byte	$de
>2f0b	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>2f0f	df					.byte	$df
>2f10	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>2f14	df					.byte	$df
>2f15	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>2f19	e0					.byte	$e0
>2f1a	00 00 00 40				.dword	$40000000 ; 1.0
>2f1e	e2					.byte	$e2
>2f1f	00 00 00 00				.dword	$00000000 ; 0.0
>2f23	00					.byte	$00
.2f24					Const_Base:
.2f24					Const_1Div2Pi:
>2f24	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>2f28	df					.byte	$df
.2f29					Const_PiDiv2:
>2f29	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>2f2d	e2					.byte	$e2
.2f2e					Const_Log2_e:
>2f2e	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>2f32	e2					.byte	$e2
.2f33					Const_sqrt_2:
>2f33	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>2f37	e2					.byte	$e2
.2f38					Const_sqrt_half:
>2f38	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>2f3c	e1					.byte	$e1
.2f3d					Const_pi:
>2f3d	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>2f41	e3					.byte	$e3
.2f42					Const_half:
>2f42	00 00 00 40				.dword	$40000000 ; 0.50000000
>2f46	e1					.byte	$e1
.2f47					Const_ln_e:
>2f47	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>2f4b	e1					.byte	$e1
.2f4c					FloatCosine:
.2f4c	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2f4e	20 36 30	jsr $3036			jsr 	LoadConstant
.2f51	e8		inx				inx
.2f52	20 2a 28	jsr $282a			jsr 	FloatAdd
.2f55	4c ec 30	jmp $30ec			jmp 	FloatSine
.2f58					FloatExponent:
.2f58	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.2f5a	20 36 30	jsr $3036			jsr 	LoadConstant
.2f5d	e8		inx				inx
.2f5e	20 c6 2a	jsr $2ac6			jsr 	FloatMultiply
.2f61	20 a3 2f	jsr $2fa3			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.2f64	e8		inx				inx
.2f65	20 41 2a	jsr $2a41			jsr 	FloatIntegerPart
.2f68	ca		dex				dex
.2f69	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2f6b	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2f6d	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2f6f	d0 38		bne $2fa9			bne 	_UERangeError
.2f71	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.2f73	c9 40		cmp #$40			cmp 	#64
.2f75	b0 32		bcs $2fa9			bcs 	_UERangeError
.2f77	48		pha				pha
.2f78	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.2f7a	48		pha				pha
.2f7b	20 e6 29	jsr $29e6			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.2f7e	68		pla				pla
.2f7f	10 14		bpl $2f95			bpl 	_UEPositive
.2f81	e8		inx				inx 							; 1-x
.2f82	a9 01		lda #$01			lda 	#1
.2f84	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.2f87	ca		dex				dex
.2f88	20 c8 2d	jsr $2dc8			jsr 	FloatNegate
.2f8b	e8		inx				inx
.2f8c	20 2a 28	jsr $282a			jsr 	FloatAdd
.2f8f	68		pla				pla 							; integer part +1 and negated.
.2f90	1a		inc a				inc 	a
.2f91	49 ff		eor #$ff			eor 	#$FF
.2f93	1a		inc a				inc 	a
.2f94	48		pha				pha
.2f95					_UEPositive:
.2f95	20 ab 2f	jsr $2fab			jsr 	CoreExponent
.2f98	20 df 2f	jsr $2fdf			jsr 	CompletePolynomial
.2f9b	68		pla				pla
.2f9c	18		clc				clc
.2f9d	75 6e		adc $6e,x			adc 	NSExponent,x
.2f9f	95 6e		sta $6e,x			sta 	NSExponent,x
.2fa1	18		clc				clc
.2fa2	60		rts				rts
.2fa3					_UECopy01:
.2fa3	8a		txa				txa
.2fa4	a8		tay				tay
.2fa5	c8		iny				iny
.2fa6	4c ea 2f	jmp $2fea			jmp 	CopyFloatXY
.2fa9					_UERangeError:
.2fa9	38		sec				sec
.2faa	60		rts				rts
.2fab					CoreExponent:
.2fab	a9 7b		lda #$7b			lda 	#ExpCoefficients & $FF
.2fad	a0 2e		ldy #$2e			ldy 	#ExpCoefficients >> 8
.2faf	20 b3 2f	jsr $2fb3			jsr 	CalculateHornerPolynomial
.2fb2	60		rts				rts
.2fb3					CalculateHornerPolynomial:
.2fb3	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.2fb5	84 2d		sty $2d				sty 	zTemp0+1
.2fb7	9c b4 05	stz $05b4			stz 	coefficientCount 			; zero the count.
.2fba	8e b5 05	stx $05b5			stx 	xValueSlot 					; save xValue slot.
.2fbd	e8		inx				inx 								; set the count to zero.
.2fbe	20 06 2e	jsr $2e06			jsr 	FloatSetZero
.2fc1					_CHPLoop:
.2fc1	8a		txa				txa 								; copy X-1 to X+1
.2fc2	a8		tay				tay
.2fc3	ca		dex				dex
.2fc4	c8		iny				iny
.2fc5	20 ea 2f	jsr $2fea			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.2fc8	e8		inx				inx
.2fc9	e8		inx				inx
.2fca	20 c6 2a	jsr $2ac6			jsr 	FloatMultiply 				; times current by X
.2fcd	e8		inx				inx
.2fce	20 09 30	jsr $3009			jsr 	GetCoefficient 				; coefficient into X+1
.2fd1	20 2a 28	jsr $282a			jsr 	FloatAdd 					; and add
.2fd4	ee b4 05	inc $05b4			inc 	coefficientCount
.2fd7	ad b4 05	lda $05b4			lda 	coefficientCount
.2fda	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.2fdc	d0 e3		bne $2fc1			bne 	_CHPLoop
.2fde	60		rts				rts
.2fdf					CompletePolynomial:
.2fdf	20 c6 2a	jsr $2ac6			jsr 	FloatMultiply
.2fe2	e8		inx				inx 								; get the last value
.2fe3	20 09 30	jsr $3009			jsr 	GetCoefficient
.2fe6	20 2a 28	jsr $282a			jsr 	FloatAdd 					; and add it
.2fe9	60		rts				rts
.2fea					CopyFloatXY:
.2fea	b5 6e		lda $6e,x			lda 	NSExponent,x
.2fec	99 6e 00	sta $006e,y			sta 	NSExponent,y
.2fef	b5 32		lda $32,x			lda 	NSStatus,x
.2ff1	99 32 00	sta $0032,y			sta 	NSStatus,y
.2ff4	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2ff6	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.2ff9	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2ffb	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.2ffe	b5 56		lda $56,x			lda 	NSMantissa2,x
.3000	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.3003	b5 62		lda $62,x			lda 	NSMantissa3,x
.3005	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.3008	60		rts				rts
.3009					GetCoefficient:
.3009	5a		phy				phy
.300a	ad b4 05	lda $05b4			lda 	coefficientCount 			; 5 per block
.300d	0a		asl a				asl 	a
.300e	0a		asl a				asl 	a
.300f	38		sec				sec 								; +1 for count
.3010	6d b4 05	adc $05b4			adc 	coefficientCount
.3013	a8		tay				tay
.3014	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.3016	95 3e		sta $3e,x			sta 	NSMantissa0,x
.3018	c8		iny				iny
.3019	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.301b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.301d	c8		iny				iny
.301e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.3020	95 56		sta $56,x			sta 	NSMantissa2,x
.3022	c8		iny				iny
.3023	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.3025	48		pha				pha
.3026	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.3028	95 62		sta $62,x			sta 	NSMantissa3,x
.302a	c8		iny				iny
.302b	68		pla				pla
.302c	29 80		and #$80			and 	#$80
.302e	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.3030	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.3032	95 6e		sta $6e,x			sta 	NSExponent,x
.3034	7a		ply				ply
.3035	60		rts				rts
.05b4					coefficientCount:
>05b4							.fill 	1
.05b5					xValueSlot:
>05b5							.fill 	1
.3036					LoadConstant:
.3036	5a		phy				phy
.3037	a8		tay				tay
.3038	b9 24 2f	lda $2f24,y			lda 	Const_Base+0,y
.303b	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.303d	b9 25 2f	lda $2f25,y			lda 	Const_Base+1,y
.3040	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.3042	b9 26 2f	lda $2f26,y			lda 	Const_Base+2,y
.3045	95 57		sta $57,x			sta 	NSMantissa2+1,x
.3047	b9 27 2f	lda $2f27,y			lda 	Const_Base+3,y
.304a	48		pha				pha
.304b	29 7f		and #$7f			and 	#$7F
.304d	95 63		sta $63,x			sta 	NSMantissa3+1,x
.304f	68		pla				pla
.3050	29 80		and #$80			and 	#$80
.3052	95 33		sta $33,x			sta 	NSStatus+1,x
.3054	b9 28 2f	lda $2f28,y			lda 	Const_Base+4,y
.3057	95 6f		sta $6f,x			sta 	NSExponent+1,x
.3059	7a		ply				ply
.305a	60		rts				rts
.305b					FloatLogarithm:
.305b	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.305d	30 5f		bmi $30be			bmi 	_ULRange
.305f	20 28 2e	jsr $2e28			jsr 	FloatIsZero
.3062	f0 5a		beq $30be			beq 	_ULRange
.3064	20 5b 2b	jsr $2b5b			jsr 	FloatNormalise 				; put into FP mode.
.3067	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.3069	48		pha				pha
.306a	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.306c	95 6e		sta $6e,x			sta 	NSExponent,x
.306e	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.3070	20 36 30	jsr $3036			jsr 	LoadConstant
.3073	e8		inx				inx
.3074	20 2a 28	jsr $282a			jsr 	FloatAdd
.3077	8a		txa				txa 								; divide into sqrt 2.0
.3078	a8		tay				tay
.3079	c8		iny				iny
.307a	20 ea 2f	jsr $2fea			jsr 	CopyFloatXY
.307d	ca		dex				dex
.307e	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.3080	20 36 30	jsr $3036			jsr 	LoadConstant
.3083	e8		inx				inx
.3084	e8		inx				inx
.3085	20 4f 29	jsr $294f			jsr 	FloatDivide 				; if zero, error.
.3088	b0 33		bcs $30bd			bcs 	_ULRangePla
.308a	20 c8 2d	jsr $2dc8			jsr 	FloatNegate 				; subtract from 1
.308d	e8		inx				inx
.308e	a9 01		lda #$01			lda 	#1
.3090	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.3093	20 2a 28	jsr $282a			jsr 	FloatAdd
.3096	20 c0 30	jsr $30c0			jsr 	CoreLog
.3099	20 df 2f	jsr $2fdf			jsr 	CompletePolynomial
.309c	68		pla				pla 								; add exponent
.309d	18		clc				clc
.309e	69 1f		adc #$1f			adc 	#31 						; fix up
.30a0	48		pha				pha
.30a1	10 03		bpl $30a6			bpl 	_LogNotNeg
.30a3	49 ff		eor #$ff			eor 	#$FF
.30a5	1a		inc a				inc 	a
.30a6					_LogNotNeg:
.30a6	e8		inx				inx 								; set byte and sign.
.30a7	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.30aa	68		pla				pla
.30ab	29 80		and #$80			and 	#$80
.30ad	95 32		sta $32,x			sta 	NSStatus,x
.30af	20 2a 28	jsr $282a			jsr 	FloatAdd
.30b2	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.30b4	20 36 30	jsr $3036			jsr 	LoadConstant
.30b7	e8		inx				inx
.30b8	20 c6 2a	jsr $2ac6			jsr 	FloatMultiply
.30bb	18		clc				clc
.30bc	60		rts				rts
.30bd					_ULRangePla:
.30bd	68		pla				pla
.30be					_ULRange:
.30be	38		sec				sec
.30bf	60		rts				rts
.30c0					CoreLog:
.30c0	a9 c8		lda #$c8			lda 	#LogCoefficients & $FF
.30c2	a0 2e		ldy #$2e			ldy 	#LogCoefficients >> 8
.30c4	4c 33 31	jmp $3133			jmp 	CorePolySquared
.30c7					FloatPI:
.30c7	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.30c9	20 36 30	jsr $3036			jsr 	LoadConstant
.30cc	e8		inx				inx
.30cd	18		clc				clc
.30ce	60		rts				rts
.30cf					FloatPower:
.30cf	ca		dex				dex
.30d0	8a		txa				txa 							; copy 0 to 2, so we can process it
.30d1	a8		tay				tay
.30d2	c8		iny				iny
.30d3	c8		iny				iny
.30d4	20 ea 2f	jsr $2fea			jsr 	CopyFloatXY
.30d7	e8		inx				inx 							; 2 = Log(0)
.30d8	e8		inx				inx
.30d9	20 5b 30	jsr $305b			jsr 	FloatLogarithm
.30dc	b0 0d		bcs $30eb			bcs 	_FPWExit
.30de	20 c6 2a	jsr $2ac6			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.30e1	8a		txa				txa 							; copy to slot 0
.30e2	a8		tay				tay
.30e3	88		dey				dey
.30e4	20 ea 2f	jsr $2fea			jsr 	CopyFloatXY
.30e7	ca		dex				dex  							; Exponent code.
.30e8	20 58 2f	jsr $2f58			jsr 	FloatExponent
.30eb					_FPWExit:
.30eb	60		rts				rts
.30ec					FloatSine:
.30ec	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.30ee	48		pha				pha
.30ef	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.30f1	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.30f3	20 36 30	jsr $3036			jsr 	LoadConstant
.30f6	e8		inx				inx
.30f7	20 c6 2a	jsr $2ac6			jsr 	FloatMultiply
.30fa	20 e6 29	jsr $29e6			jsr 	FloatFractionalPart 		; take the fractional part
.30fd	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.30ff	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.3101	90 1f		bcc $3122			bcc 	_USProcessExit
.3103	f0 06		beq $310b			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.3105	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.3107	c9 60		cmp #$60			cmp 	#$60
.3109	b0 0e		bcs $3119			bcs 	_USSubtractOne
.310b					_USSubtractFromHalf:
.310b	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.310d	20 36 30	jsr $3036			jsr 	LoadConstant
.3110	e8		inx				inx
.3111	20 24 28	jsr $2824			jsr 	FloatSubtract
.3114	20 c8 2d	jsr $2dc8			jsr 	FloatNegate 				; then negate it
.3117	80 09		bra $3122			bra 	_USProcessExit 				; and exit
.3119					_USSubtractOne:
.3119	e8		inx				inx
.311a	a9 01		lda #$01			lda 	#1
.311c	20 08 2e	jsr $2e08			jsr 	FloatSetByte
.311f	20 24 28	jsr $2824			jsr 	FloatSubtract
.3122					_USProcessExit:
.3122	20 2f 31	jsr $312f			jsr 	CoreSine
.3125	20 df 2f	jsr $2fdf			jsr 	CompletePolynomial
.3128	68		pla				pla 								; restore sign and apply
.3129	55 32		eor $32,x			eor 	NSStatus,x
.312b	95 32		sta $32,x			sta 	NSStatus,x
.312d	18		clc				clc
.312e	60		rts				rts
.312f					CoreSine:
.312f	a9 a4		lda #$a4			lda 	#SinCoefficients & $FF
.3131	a0 2e		ldy #$2e			ldy 	#SinCoefficients >> 8
.3133					CorePolySquared:
.3133	48		pha				pha 								; save coefficient table
.3134	5a		phy				phy
.3135	8a		txa				txa 								; copy X to +1, +2
.3136	a8		tay				tay
.3137	c8		iny				iny
.3138	20 ea 2f	jsr $2fea			jsr 	CopyFloatXY
.313b	c8		iny				iny
.313c	20 ea 2f	jsr $2fea			jsr 	CopyFloatXY
.313f	e8		inx				inx 								; point to the pair and put x^2 on stack
.3140	e8		inx				inx
.3141	20 c6 2a	jsr $2ac6			jsr 	FloatMultiply
.3144	7a		ply				ply 								; coefficient table back.
.3145	68		pla				pla
.3146	20 b3 2f	jsr $2fb3			jsr 	CalculateHornerPolynomial
.3149	8a		txa				txa 								; copy back to slot #1
.314a	a8		tay				tay
.314b	88		dey				dey
.314c	20 ea 2f	jsr $2fea			jsr	 	CopyFloatXY
.314f	ca		dex				dex 								; point at result
.3150	60		rts				rts
.3151					FloatSquareRoot:
.3151	20 5b 30	jsr $305b			jsr 	FloatLogarithm
.3154	b0 06		bcs $315c			bcs 	_FSQExit
.3156	d6 6e		dec $6e,x			dec 	NSExponent,x
.3158	20 58 2f	jsr $2f58			jsr 	FloatExponent
.315b	18		clc				clc
.315c					_FSQExit:
.315c	60		rts				rts
.315d					FloatTangent:
.315d	da		phx				phx
.315e	8a		txa				txa 								; sin -> +1
.315f	a8		tay				tay
.3160	c8		iny				iny
.3161	20 ea 2f	jsr $2fea			jsr 	CopyFloatXY
.3164	e8		inx				inx
.3165	20 ec 30	jsr $30ec			jsr 	FloatSine
.3168	ca		dex				dex
.3169	8a		txa				txa 								; cos -> +2
.316a	a8		tay				tay
.316b	c8		iny				iny
.316c	c8		iny				iny
.316d	20 ea 2f	jsr $2fea			jsr 	CopyFloatXY
.3170	e8		inx				inx
.3171	e8		inx				inx
.3172	20 4c 2f	jsr $2f4c			jsr 	FloatCosine
.3175	20 4f 29	jsr $294f			jsr 	FloatDivide 				; calculate sin/cos
.3178	b0 07		bcs $3181			bcs 	_FTExit 					; divide by zero
.317a	8a		txa				txa 								; copy result down.
.317b	a8		tay				tay
.317c	88		dey				dey
.317d	20 ea 2f	jsr $2fea			jsr 	CopyFloatXY
.3180	18		clc				clc
.3181					_FTExit:
.3181	fa		plx				plx
.3182	60		rts				rts

;******  Processing input file: testing/testend.asm

=$3200							nextPage = (* + $FF) & $FF00 		; so I can include with that f*****g header.
.31fe					ObjectCodePreHeader:
>31fe	00 a0 d4 ae 00 a6 01 48				.binary "code/code.bin"
>3206	00 a6 01 48 03 a6 01 48 06 a6 01 48 09 a6 cb 60
>3216	48 0c a6 40 00 48 0f a6 40 03 48 12 a6 40 06 48
>3226	15 a6 40 09 48 18 a6 3c 01 00 ca 81 58 1b a6 cb
>3236	b0 48 1e 3c cb eb 01 95 a6 40 1e cb af 81 01 50
>3246	1b 8e 40 1e 7c a6 3c a7 a6 01 06 ca ae a6 03 c7
>3256	a6 00 06 ca ae a6 01 27 ca ad a6 ce 02 56 2a b1
>3266	a6 04 06 ca ae a6 01 02 ca ad a6 ce 0d 44 49 53
>3276	50 4c 41 59 2d 43 4f 44 45 53 b1 a6 01 18 ca ad
>3286	a6 ce 0c 43 55 52 52 45 4e 54 2d 46 4f 4e 54 b1
>3296	a6 15 01 ca ad a6 ce 13 50 52 49 4e 54 2d 43 4f
>32a6	44 45 53 20 28 48 45 58 20 24 29 b1 a6 01 06 ca
>32b6	ae a6 d1 8a 07 a6 d1 21 03 a6 d1 d1 03 a6 d1 7c
>32c6	01 a6 a6 97 68 21 a6 60 21 8f 48 24 a6 a6 40 24
>32d6	cb 57 a3 88 d2 0b 00 40 0f 01 81 48 0f d1 5d 01
>32e6	a6 40 24 cb 53 a3 88 d2 0b 00 40 0f 01 80 48 0f
>32f6	d1 4a 01 a6 40 24 cb 41 a3 88 d2 0b 00 40 12 01
>3306	81 48 12 d1 37 01 a6 40 24 cb 44 a3 88 d2 0b 00
>3316	40 12 01 80 48 12 d1 24 01 a6 a6 40 24 cb 91 a3
>3326	88 d2 0b 00 40 15 01 81 48 15 d1 10 01 a6 40 24
>3336	11 a3 88 d2 0b 00 40 15 01 80 48 15 d1 fe 00 a6
>3346	40 24 cb 9d a3 88 d2 0b 00 40 18 01 81 48 18 d1
>3356	eb 00 a6 40 24 1d a3 88 d2 0b 00 40 18 01 80 48
>3366	18 d1 d9 00 a6 40 24 20 a3 88 d2 08 00 d1 62 03
>3376	d1 ca 00 a6 40 24 cb 49 a3 88 d2 08 00 d1 53 09
>3386	d1 ba 00 a6 40 24 cb 43 a3 88 d2 08 00 d1 16 08
>3396	d1 aa 00 a6 40 24 cb 45 a3 88 d2 08 00 d1 4a 08
>33a6	d1 9a 00 a6 40 24 cb 4b a3 88 d2 08 00 d1 7f 08
>33b6	d1 8a 00 a6 40 24 cb 56 a3 88 d2 05 00 d1 e1 04
>33c6	a6 40 24 cb 4c a3 88 d2 08 00 d1 ab 05 d1 6d 00
>33d6	a6 40 24 cb 58 a3 88 d2 05 00 d1 53 03 a6 00 48
>33e6	27 a6 40 24 cb 5d a3 88 d2 17 00 40 0c 08 80 48
>33f6	0c 01 48 27 40 0c cb c0 a3 87 d2 05 00 00 48 0c
>3406	a6 40 24 cb 5b a3 88 d2 17 00 40 0c 08 81 48 0c
>3416	01 48 27 40 0c 00 a3 89 d2 06 00 cb c0 48 0c a6
>3426	40 27 01 a3 88 d2 05 00 d1 af 01 a6 40 24 1b a3
>3436	88 d2 05 00 d0 06 0a a6 d0 88 fe a6 40 03 01 80
>3446	48 2a a6 40 00 01 80 48 2d a6 cb 61 48 30 a6 d1
>3456	b4 09 a6 ce 00 b1 0d 92 a6 0d 06 ca ae a6 a6 40
>3466	00 01 80 12 ca ad a6 ce 01 20 b1 a6 40 0f 10 a3
>3476	87 d2 05 00 01 48 0f a6 40 0f 01 a3 89 d2 05 00
>3486	10 48 0f a6 40 0f 48 00 a6 40 00 01 80 12 ca ad
>3496	a6 cb 5f 93 b1 a6 12 40 03 01 80 ca ad a6 ce 01
>34a6	20 b1 a6 40 12 10 a3 87 d2 05 00 01 48 12 a6 40
>34b6	12 01 a3 89 d2 05 00 10 48 12 a6 40 12 48 03 a6
>34c6	12 40 03 01 80 ca ad a6 ce 01 5e b1 a6 a6 40 06
>34d6	01 80 26 ca ad a6 ce 01 20 b1 a6 40 15 08 a3 87
>34e6	d2 05 00 01 48 15 a6 40 15 01 a3 89 d2 05 00 08
>34f6	48 15 a6 40 15 48 06 a6 40 06 01 80 26 ca ad a6
>3506	cb 5f 93 b1 a6 0a 40 09 1d 80 ca ad a6 ce 01 20
>3516	b1 a6 40 18 08 a3 87 d2 05 00 01 48 18 a6 40 18
>3526	01 a3 89 d2 05 00 08 48 18 a6 40 18 48 09 a6 0a
>3536	40 09 1d 80 ca ad a6 ce 01 5e b1 a6 cc 00 f0 40
>3546	00 01 81 10 82 40 03 01 81 80 08 82 80 48 30 a6
>3556	03 06 ca ae a6 01 48 1e 3c 08 01 95 a6 01 40 1e
>3566	80 18 ca ad a6 ce 01 24 b1 40 30 9e b1 a6 01 40
>3576	30 c9 48 33 a6 01 40 1e 80 1e ca ad a6 40 33 91
>3586	b1 a6 40 30 01 80 48 30 a6 3c a7 a6 01 11 ca ad
>3596	a6 ce 04 20 20 20 20 b1 a6 01 11 ca ad a6 40 00
>35a6	01 81 10 82 40 03 01 81 80 b0 0d 92 a6 40 03 01
>35b6	80 48 2a a6 40 00 01 80 48 2d a6 cb e7 48 30 a6
>35c6	d1 43 08 a6 40 09 1d 80 48 2a a6 40 06 01 80 48
>35d6	2d a6 a6 d1 30 08 a6 98 a6 01 48 2a a6 16 48 2d
>35e6	a6 40 0c 48 1e a6 00 48 36 a6 01 06 ca ae a6 00
>35f6	48 27 a6 40 1e 20 a3 8a 40 1e cb 7f a3 8c 85 d2
>3606	05 00 01 48 27 a6 40 1e cb a0 a3 8a 40 1e cb ff
>3616	a3 8c 85 d2 05 00 01 48 27 a6 40 2d 40 2a ca ad
>3626	ce 03 20 20 20 b1 a6 40 2d 40 2a ca ad 40 1e 9e
>3636	b1 a6 40 2d 40 2a 03 80 ca ad a6 40 27 00 a3 88
>3646	d2 06 00 ce 01 2e b1 a6 40 27 00 a3 8b d2 06 00
>3656	40 1e 93 b1 a6 40 2a 05 80 48 2a 40 36 01 80 48
>3666	36 a6 40 2a 28 a3 87 d2 0b 00 40 2d 01 80 48 2d
>3676	01 48 2a a6 40 1e 01 80 48 1e a6 40 36 3f a3 87
>3686	d2 05 00 d0 06 00 a6 d0 66 ff a6 98 a6 02 48 2a
>3696	a6 02 48 2d a6 00 48 30 a6 40 30 cb ff a3 87 d2
>36a6	05 00 d0 2a 00 a6 d1 37 07 a6 40 2a 01 80 48 2a
>36b6	a6 40 2a 11 a3 87 d2 0b 00 40 2d 01 80 48 2d 02
>36c6	48 2a a6 40 30 01 80 48 30 a6 d0 cd ff a6 a6 98
>36d6	a6 cc 00 f0 40 00 01 81 10 82 40 03 01 81 80 08
>36e6	82 80 48 30 a6 40 30 40 06 01 81 80 48 30 a6 01
>36f6	40 30 c9 48 33 a6 cc 00 01 48 39 a6 40 09 48 1e
>3706	3c 01 01 a5 95 a6 40 39 02 83 ca 84 48 39 a6 3c
>3716	a7 a6 40 33 40 39 80 02 40 33 40 39 85 82 81 48
>3726	33 a6 01 40 30 40 33 c8 a6 d1 02 07 a6 98 a6 07
>3736	06 ca ae a6 02 13 ca ad a6 ce 04 57 41 49 54 b1
>3746	a6 03 13 ca ad a6 ce 03 45 58 50 b1 a6 cc 00 f0
>3756	48 3c a6 40 3c cb 7f 80 48 3f a6 01 48 42 a6 cc
>3766	60 6d 40 00 cc d0 07 82 80 48 2a a6 00 48 36 a6
>3776	01 48 45 a6 40 42 40 00 a3 88 d2 05 00 d0 0e 00
>3786	a6 40 36 cb 80 80 48 36 a6 d0 c7 00 a6 ce 06 40
>3796	3a 46 4f 4e 54 40 42 ba b5 ce 08 2e 42 41 53 2c
>37a6	53 2c 57 b5 68 48 a6 01 08 02 60 48 c6 a6 13 01
>37b6	ca ad a6 ce 05 20 20 20 20 20 b1 0d 92 a6 13 01
>37c6	ca ad a6 40 4b b0 0d 92 a6 40 3c 48 1e 3c 40 3f
>37d6	01 95 a6 40 45 01 a3 88 d2 25 00 ae 01 af 40 2a
>37e6	b0 ce 0a 20 52 45 4d 20 46 4f 4e 54 20 b1 40 36
>37f6	08 83 ca 84 b0 0d 92 af 40 2a 0a 80 48 2a a6 01
>3806	40 1e c9 48 33 a6 ae 01 af 40 2a b0 ce 0a 20 56
>3816	50 4f 4b 45 20 31 2c 24 b1 40 1e 9e b1 ce 02 2c
>3826	25 b1 b7 40 33 91 b1 0d 92 af a6 40 2a 0a 80 48
>3836	2a a6 40 45 01 80 48 45 a6 40 45 08 a3 87 d2 05
>3846	00 01 48 45 a6 40 36 01 80 48 36 a6 3c a7 a6 01
>3856	c3 a6 40 42 10 a3 89 d2 19 00 40 42 01 80 48 42
>3866	40 3c cb 80 80 48 3c 40 3f cb 80 80 48 3f d0 04
>3876	ff a6 01 06 ca ae a6 02 13 ca ad a6 ce 04 20 20
>3886	20 20 b1 a6 03 13 ca ad a6 ce 04 20 20 20 20 b1
>3896	a6 04 13 ca ad a6 ce 04 20 20 20 20 b1 a6 98 a6
>38a6	07 06 ca ae a6 02 13 ca ad a6 ce 04 57 41 49 54
>38b6	b1 a6 03 13 ca ad a6 ce 04 53 41 56 45 b1 a6 ce
>38c6	09 40 3a 58 31 36 46 4f 4e 54 40 00 ba b5 ce 08
>38d6	2e 44 41 54 2c 53 2c 57 b5 68 48 a6 01 08 02 60
>38e6	48 c6 a6 13 01 ca ad a6 ce 05 20 20 20 20 20 b1
>38f6	0d 92 a6 13 01 ca ad a6 40 4b b0 0d 92 a6 40 4b
>3906	00 a3 88 d2 0d 00 40 00 01 80 01 ca ad ce 01 20
>3916	b1 a6 cc 00 f0 40 00 01 81 cb 80 82 80 48 3c a6
>3926	40 3c cb 7f 80 48 3f a6 40 3c 48 1e 3c 40 3f 01
>3936	95 a6 01 40 1e c9 48 33 a6 ae 01 af 40 33 b0 0d
>3946	92 af a6 3c a7 a6 01 c3 a6 01 06 ca ae a6 02 13
>3956	ca ad a6 ce 04 20 20 20 20 b1 a6 03 13 ca ad a6
>3966	ce 04 20 20 20 20 b1 a6 04 13 ca ad a6 ce 04 20
>3976	20 20 20 b1 a6 98 a6 07 06 ca ae a6 02 13 ca ad
>3986	a6 ce 04 57 41 49 54 b1 a6 03 13 ca ad a6 ce 04
>3996	4c 4f 41 44 b1 a6 ce 07 58 31 36 46 4f 4e 54 40
>39a6	00 ba b5 ce 08 2e 44 41 54 2c 53 2c 52 b5 68 48
>39b6	a6 01 08 02 60 48 c6 a6 13 01 ca ad a6 ce 05 20
>39c6	20 20 20 20 b1 0d 92 a6 13 01 ca ad a6 40 4b b0
>39d6	0d 92 a6 40 4b 00 a3 88 d2 0d 00 40 00 01 80 01
>39e6	ca ad ce 01 20 b1 a6 cc 00 f0 40 00 01 81 cb 80
>39f6	82 80 48 3c a6 40 3c cb 7f 80 48 3f a6 40 3c 48
>3a06	1e 3c 40 3f 01 95 a6 ae 01 af a1 9f 48 33 af a6
>3a16	01 40 1e 40 33 c8 a6 3c a7 a6 01 c3 a6 01 06 ca
>3a26	ae a6 02 13 ca ad a6 ce 04 20 20 20 20 b1 a6 03
>3a36	13 ca ad a6 ce 04 20 20 20 20 b1 a6 98 a6 0c 06
>3a46	ca ae a6 0b 13 ca ad ce 16 41 52 52 4f 57 20 4b
>3a56	45 59 53 20 20 20 4d 4f 56 45 20 46 4f 4e 54 b1
>3a66	a6 0c 13 ca ad ce 16 57 2d 41 2d 53 2d 44 20 20
>3a76	20 4d 4f 56 45 20 44 49 53 50 4c 41 59 b1 a6 0d
>3a86	13 ca ad ce 16 53 50 41 43 45 20 20 54 4f 47 47
>3a96	4c 45 20 46 4f 4e 54 20 42 49 54 b1 a6 0e 13 ca
>3aa6	ad ce 16 56 20 20 53 41 56 45 20 20 20 58 31 36
>3ab6	46 4f 4e 54 4e 2e 44 41 54 b1 a6 0f 13 ca ad ce
>3ac6	16 4c 20 20 4c 4f 41 44 20 20 20 58 31 36 46 4f
>3ad6	4e 54 4e 2e 44 41 54 b1 a6 10 13 ca ad ce 16 58
>3ae6	20 20 45 58 50 4f 52 54 20 20 20 20 46 4f 4e 54
>3af6	4e 2e 42 41 53 b1 a6 11 13 ca ad ce 16 49 20 20
>3b06	49 4e 56 45 52 54 20 52 4f 57 2d 43 4f 4c 2d 42
>3b16	4f 54 48 b1 a6 12 13 ca ad ce 16 43 20 20 43 4c
>3b26	45 41 52 20 41 4c 4c 2f 45 3d 53 45 54 20 41 4c
>3b36	4c b1 a6 13 13 ca ad ce 16 5b 20 5d 20 20 44 45
>3b46	43 20 2f 20 49 4e 43 20 44 49 53 50 4c 41 59 b1
>3b56	a6 14 13 ca ad ce 16 4b 20 20 43 4f 50 59 20 20
>3b66	20 20 20 2f 20 45 53 43 20 45 58 49 54 b1 a6 a6
>3b76	1e 01 ca ad ce 26 55 53 45 20 53 48 49 46 54 2b
>3b86	41 4c 54 20 54 4f 20 52 45 53 54 4f 52 45 20 4f
>3b96	52 49 47 49 4e 41 4c 20 46 4f 4e 54 b1 a6 01 06
>3ba6	ca ae a6 98 a6 cc 00 f0 40 00 01 81 10 82 40 03
>3bb6	01 81 80 08 82 80 48 30 a6 40 06 48 4e a6 01 48
>3bc6	06 0c 08 01 95 a6 40 30 40 06 01 81 80 48 51 a6
>3bd6	00 48 33 a6 01 40 51 40 33 c8 a6 0c a7 a6 40 4e
>3be6	48 06 a6 d1 48 02 a6 98 a6 cc 00 f0 40 00 01 81
>3bf6	10 82 40 03 01 81 80 08 82 80 48 30 a6 40 06 48
>3c06	4e a6 01 48 06 0c 08 01 95 a6 40 30 40 06 01 81
>3c16	80 48 51 a6 cb ff 48 33 a6 01 40 51 40 33 c8 a6
>3c26	0c a7 a6 40 4e 48 06 a6 d1 03 02 a6 98 a6 15 12
>3c36	ca ad a6 07 06 ca ae a6 ce 0d 57 48 49 43 48 20
>3c46	28 30 2d 32 35 35 29 b1 a6 a1 9f 48 24 a6 40 24
>3c56	40 00 01 81 10 82 40 03 01 81 08 82 80 a3 88 d2
>3c66	05 00 d0 44 00 a6 cc 00 f0 40 00 01 81 10 82 40
>3c76	03 01 81 80 08 82 80 48 30 a6 cc 00 f0 40 24 08
>3c86	82 80 48 51 a6 00 48 1e 3c 07 01 95 a6 01 40 51
>3c96	40 1e 80 c9 48 33 a6 01 40 30 40 1e 80 40 33 c8
>3ca6	a6 3c a7 a6 d1 87 01 a6 15 12 ca ad a6 01 06 ca
>3cb6	ae a6 ce 16 20 20 20 20 20 20 20 20 20 20 20 20
>3cc6	20 20 20 20 20 20 20 20 20 20 b1 a6 00 48 24 a6
>3cd6	98 a6 ce 00 b1 0d 92 a6 15 12 ca ad a6 07 06 ca
>3ce6	ae a6 ce 16 43 3d 43 4f 4c 2c 52 2d 52 4f 57 2c
>3cf6	42 2d 42 4f 54 48 2f 45 53 43 b1 a6 00 48 24 a6
>3d06	97 68 21 a6 60 21 8f 48 24 a6 40 24 00 a3 88 d2
>3d16	05 00 d0 ec ff a6 40 24 cb 43 a3 88 d2 05 00 d0
>3d26	51 00 a6 40 24 cb 52 a3 88 d2 05 00 d0 65 00 a6
>3d36	40 24 1b a3 88 d2 05 00 d0 7a 00 a6 40 09 48 4e
>3d46	a6 40 06 48 54 a6 01 48 09 12 08 01 95 a6 01 48
>3d56	06 0c 08 01 95 a6 d1 79 f9 a6 0c a7 a6 12 a7 a6
>3d66	40 4e 48 09 a6 40 54 48 06 a6 d1 c1 00 a6 d0 44
>3d76	00 a6 40 06 48 4e a6 01 48 06 0c 08 01 95 a6 d1
>3d86	50 f9 a6 0c a7 a6 40 4e 48 06 a6 d1 a0 00 a6 d0
>3d96	23 00 a6 40 09 48 4e a6 01 48 09 12 08 01 95 a6
>3da6	d1 2f f9 a6 12 a7 a6 40 4e 48 09 a6 d1 7f 00 a6
>3db6	d0 02 00 a6 15 12 ca ad a6 01 06 ca ae a6 a6 ce
>3dc6	16 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
>3dd6	20 20 20 20 20 20 20 b1 a6 00 48 24 a6 98 a6 cc
>3de6	20 9f 40 2a 01 81 02 82 ac a6 cc 21 9f 40 2d 01
>3df6	50 1b 8e 78 ac a6 cc 22 9f 21 ac a6 cc 23 9f 40
>3e06	30 ac a6 98 a6 cc 20 9f 40 2a 01 81 02 82 01 80
>3e16	ac a6 cc 21 9f 40 2d 01 50 1b 8e 78 ac a6 cc 22
>3e26	9f 21 ac a6 cc 23 9f 40 30 ac a6 98 a6 40 00 01
>3e36	80 cb ff ca ad ce 01 2a b1 a6 98 a6 1d 01 ca ad
>3e46	a6 ca 82 c4 ff
=12800					ObjectCode = ObjectCodePreHeader+2 			; so the code is at XX00

;******  End of listing
