
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl source/main/00main.header /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library _library.asm source/main/zzfree.footer
; Wed Oct 11 08:28:45 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: source/main/00main.header

.0801					StartBasicProgram:
>0801	0c 08						.word 	$080C 						; offset to next.
>0803	0a 00						.word 	10 							; line #
>0805	9e						.byte 	$9E 						; token for 'SYS'
>0806	20 32 30 36 32					.text 	' 2062'						; space, $080E in decimal
>080b	00						.byte  	0 							; end of line
>080c	00 00						.word 	0 							; end of program
.080e					StartCode:
.080e	4c 7b 39	jmp $397b			jmp 	CompileCode 				; to starting the runtime in the saved code.
.0811	a9 3b		lda #$3b			lda 	#FreeMemory >> 8 			; address of object code to run.
.0813	a2 80		ldx #$80			ldx 	#$80 						; 8000-9EFF is used for workspace.
.0815	a0 9f		ldy #$9f			ldy 	#$9F
.0817	4c 26 08	jmp $0826			jmp 	StartRuntime 				; and go do it !
.081a					PatchOutCompile:
.081a	a9 ea		lda #$ea			lda 	#$EA 						; $EA is NOP 65C02
.081c	8d 0e 08	sta $080e			sta 	StartCode 					; patch out "JMP COMPILECODE"
.081f	8d 0f 08	sta $080f			sta 	StartCode+1
.0822	8d 10 08	sta $0810			sta 	StartCode+2
.0825	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.0826					StartRuntime:
.0826	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.0829	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.082b	64 28		stz $28				stz 	codePtr
.082d	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0830	8c 06 04	sty $0406			sty 	storeEndHigh
.0833	8e 07 04	stx $0407			stx 	variableStartPage
.0836	ba		tsx				tsx 								; save the stack.
.0837	8e 08 04	stx $0408			stx 	Runtime6502SP
.083a	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.083c	a2 58		ldx #$58			ldx 	#RuntimeErrorHandler & $FF
.083e	20 ea 1e	jsr $1eea			jsr 	SetErrorHandler
.0841	20 84 0a	jsr $0a84			jsr 	ClearMemory 				; clear memory.
.0844	20 68 16	jsr $1668			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0847	20 6a 13	jsr $136a		 	jsr		SetDefaultChannel			; set default input/output channel.
.084a	20 a0 15	jsr $15a0			jsr 	RestoreCode 				; which we now call
.084d	a0 00		ldy #$00			ldy 	#0
.084f					NextCommand:
.084f	ad 09 04	lda $0409			lda  	breakCount 					; only check every 16 instructions.
.0852	69 10		adc #$10			adc 	#16
.0854	8d 09 04	sta $0409			sta 	breakCount
.0857	90 07		bcc $0860			bcc 	_NXNoCheck
.0859	da		phx				phx
.085a	5a		phy				phy 								; check Ctrl+C
.085b	20 a2 1b	jsr $1ba2			jsr 	XCheckStop
.085e	7a		ply				ply
.085f	fa		plx				plx
.0860					_NXNoCheck:
.0860	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.0862	30 5b		bmi $08bf			bmi 	NXCommand 					; -if -ve command
.0864	c8		iny				iny
.0865	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0867	90 39		bcc $08a2			bcc 	PushByteA 					; 0..63 is short constants.
.0869					NXLoadStore:
.0869	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.086b	b0 19		bcs $0886			bcs 	NXIndirectLoadStore
.086d	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.086e	4a		lsr a				lsr 	a
.086f	29 0e		and #$0e			and 	#$0E
.0871	da		phx				phx 								; get ready to jump
.0872	aa		tax				tax
.0873	7c 76 08	jmp ($0876,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.0876					ReadWriteVectors:
>0876	d6 14						.word 	ReadFloatCommand			; read float
>0878	b1 1a						.word 	WriteFloatCommand 			; write float
>087a	12 15						.word 	ReadIntegerCommand 			; read integer
>087c	ed 1a						.word 	WriteIntegerCommand 		; write integer
>087e	57 15						.word 	ReadStringCommand 			; read string
>0880	2c 1b						.word 	WriteStringCommand 			; write string
>0882	55 0c						.word 	Unimplemented
>0884	55 0c						.word 	Unimplemented
.0886					NXIndirectLoadStore:
.0886	29 07		and #$07			and 	#7
.0888	0a		asl a				asl 	a
.0889	da		phx				phx
.088a	aa		tax				tax
.088b	7c 8e 08	jmp ($088e,x)			jmp 	(IndirectVectors,x)
.088e					IndirectVectors:
>088e	0c 0f						.word 	IndFloatRead 				; float read
>0890	20 0f						.word 	IndInt16Read 				; int16 read
>0892	34 0f						.word 	IndStringRead 				; string read
>0894	55 0c						.word 	Unimplemented
>0896	48 0f						.word 	IndFloatWrite				; float write
>0898	5c 0f						.word 	IndInt16Write 				; int16 write
>089a	70 0f						.word 	IndStringWrite 				; string write
>089c	55 0c						.word 	Unimplemented
.089e					PushByteCommand:
.089e	fa		plx				plx
.089f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.08a1	c8		iny				iny
.08a2					PushByteA:
.08a2	e8		inx				inx 								; push constant on stack
.08a3	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.08a5	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.08a7					ClearRestWord:
.08a7	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.08a9	74 62		stz $62,x			stz 	NSMantissa3,x
.08ab	74 6e		stz $6e,x			stz 	NSExponent,x
.08ad	74 32		stz $32,x			stz 	NSStatus,x
.08af	80 9e		bra $084f			bra 	NextCommand
.08b1					PushWordCommand:
.08b1	fa		plx				plx
.08b2	e8		inx				inx
.08b3	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.08b5	c8		iny				iny
.08b6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08b8	b1 28		lda ($28),y			lda 	(codePtr),y
.08ba	c8		iny				iny
.08bb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08bd	80 e8		bra $08a7			bra 	ClearRestWord 				; handle everything else.
.08bf					NXCommand:
.08bf	c8		iny				iny 								; consume command.
.08c0	10 03		bpl $08c5			bpl 	_NXCommandNoFixUp
.08c2	20 cb 08	jsr $08cb			jsr 	FixUpY
.08c5					_NXCommandNoFixUp:
.08c5	0a		asl a				asl 	a 							; shift left
.08c6	da		phx				phx 								; save SP on stack
.08c7	aa		tax				tax				 					; and jump indirect
.08c8	7c 92 19	jmp ($1992,x)			jmp 	(VectorTable,x)
.08cb					FixUpY:
.08cb	48		pha				pha
.08cc	98		tya				tya
.08cd	18		clc				clc
.08ce	65 28		adc $28				adc 	codePtr
.08d0	85 28		sta $28				sta 	codePtr
.08d2	90 02		bcc $08d6			bcc 	_NoCPCarry
.08d4	e6 29		inc $29				inc 	codePtr+1
.08d6					_NoCPCarry:
.08d6	a0 00		ldy #$00			ldy 	#0
.08d8	68		pla				pla
.08d9	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.0408					Runtime6502SP:
>0408							.fill 	1
.0409					breakCount:
>0409							.fill 	1
.08da					AbsoluteTOS:
.08da	fa		plx				plx
.08db	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.08e0					CommandVarSpace:
.08e0	fa		plx				plx
.08e1	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08e3	85 26		sta $26				sta 	availableMemory
.08e5	c8		iny				iny
.08e6	b1 28		lda ($28),y			lda 	(codePtr),y
.08e8	18		clc				clc
.08e9	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08ec	85 27		sta $27				sta 	availableMemory+1
.08ee	c8		iny				iny
.08ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08f2					BinaryAnd:
.08f2	fa		plx				plx
.08f3	38		sec				sec
.08f4	80 02		bra $08f8			bra 	AndOrCommon
.08f6					BinaryOr:
.08f6	fa		plx				plx
.08f7	18		clc				clc
.08f8					AndOrCommon:
.08f8	08		php				php 								; save AND/OR flag
.08f9	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.08fc	ca		dex				dex
.08fd	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.0900	28		plp				plp
.0901	90 0e		bcc $0911			bcc 	_AOCOrCode
.0903	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.0905	35 3f		and $3f,x			and		NSMantissa0+1,x
.0907	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0909	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.090b	35 4b		and $4b,x			and		NSMantissa1+1,x
.090d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.090f	80 0c		bra $091d			bra 	_AOCComplete
.0911					_AOCOrCode:
.0911	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.0913	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.0915	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0917	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0919	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.091b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.091d					_AOCComplete:
.091d	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.091f	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.0921	10 07		bpl $092a			bpl 	_AOCExit
.0923	20 57 10	jsr $1057			jsr 	Negate16Bit 				; 2's complement
.0926	a9 80		lda #$80			lda 	#$80 						; make it -ve
.0928	95 32		sta $32,x			sta 	NSStatus,x
.092a					_AOCExit:
.092a	4c 4f 08	jmp $084f			jmp 	NextCommand
.092d					ArrayConvert:
.092d	fa		plx				plx
.092e	5a		phy				phy
.092f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0931	85 2e		sta $2e				sta 	zTemp1
.0933	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0935	18		clc				clc
.0936	6d 07 04	adc $0407			adc 	variableStartPage
.0939	85 2f		sta $2f				sta 	zTemp1+1
.093b	ca		dex				dex 								; count of indices to follow -> zTemp2
.093c	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.093f	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.0941	8a		txa				txa
.0942	38		sec				sec
.0943	e5 30		sbc $30				sbc 	zTemp2
.0945	aa		tax				tax
.0946	da		phx				phx 								; stack points at the first index, which will be replaced.
.0947					_ACIndexLoop:
.0947	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart 			; integer array index
.094a	20 47 10	jsr $1047			jsr 	GetInteger16Bit 			; get the index => zTemp0
.094d	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.094f	a5 2c		lda $2c				lda 	zTemp0
.0951	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0953	a5 2d		lda $2d				lda 	zTemp0+1
.0955	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0957	b0 79		bcs $09d2			bcs 	_ACBadIndex 				; index error.
.0959	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.095b	f0 29		beq $0986			beq 	_ACInnerLevel
.095d	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.095f	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0961	10 6f		bpl $09d2			bpl 	_ACBadIndex
.0963	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0965	26 2d		rol $2d				rol 	zTemp0+1
.0967	18		clc				clc
.0968	a5 2c		lda $2c				lda		zTemp0
.096a	65 2e		adc $2e				adc 	zTemp1
.096c	85 2c		sta $2c				sta 	zTemp0
.096e	a5 2d		lda $2d				lda		zTemp0+1
.0970	65 2f		adc $2f				adc 	zTemp1+1
.0972	85 2d		sta $2d				sta 	zTemp0+1
.0974	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.0976	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0978	85 2e		sta $2e				sta 	zTemp1
.097a	c8		iny				iny
.097b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.097d	18		clc				clc
.097e	6d 07 04	adc $0407			adc 	variableStartPage
.0981	85 2f		sta $2f				sta 	zTemp1+1
.0983	e8		inx				inx 								; next index
.0984	80 c1		bra $0947			bra 	_ACIndexLoop
.0986					_ACInnerLevel:
.0986	a0 02		ldy #$02			ldy 	#2
.0988	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.098a	30 46		bmi $09d2			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.098c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.098e	c9 00		cmp #$00			cmp 	#NSSIFloat
.0990	d0 13		bne $09a5			bne 	_ACNotFloat
.0992	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.0994	48		pha				pha
.0995	a5 2c		lda $2c				lda 	zTemp0
.0997	06 2c		asl $2c				asl 	zTemp0 						; x 2
.0999	26 2d		rol $2d				rol 	zTemp0+1
.099b	18		clc				clc 								; add back x 3
.099c	65 2c		adc $2c				adc 	zTemp0
.099e	85 2c		sta $2c				sta 	zTemp0
.09a0	68		pla				pla
.09a1	65 2d		adc $2d				adc 	zTemp0+1
.09a3	85 2d		sta $2d				sta 	zTemp0+1
.09a5					_ACNotFloat:
.09a5	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.09a7	26 2d		rol $2d				rol 	zTemp0+1
.09a9	18		clc				clc
.09aa	a5 2c		lda $2c				lda 	zTemp0
.09ac	69 03		adc #$03			adc 	#3
.09ae	85 2c		sta $2c				sta 	zTemp0
.09b0	90 02		bcc $09b4			bcc 	_ACNoCarry
.09b2	e6 2d		inc $2d				inc 	zTemp0+1
.09b4					_ACNoCarry:
.09b4	fa		plx				plx 								; X points to first slot of array parameters
.09b5	18		clc				clc
.09b6	a5 2c		lda $2c				lda 	zTemp0
.09b8	65 2e		adc $2e				adc 	zTemp1
.09ba	95 3e		sta $3e,x			sta 	NSMantissa0,x
.09bc	a5 2d		lda $2d				lda 	zTemp0+1
.09be	65 2f		adc $2f				adc 	zTemp1+1
.09c0	38		sec				sec
.09c1	ed 07 04	sbc $0407			sbc 	variableStartPage
.09c4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.09c6	74 56		stz $56,x			stz 	NSMantissa2,x
.09c8	74 62		stz $62,x			stz 	NSMantissa3,x
.09ca	74 32		stz $32,x			stz 	NSStatus,x
.09cc	74 6e		stz $6e,x			stz 	NSExponent,x
.09ce	7a		ply				ply 	 							; restore code pointer
.09cf	4c 4f 08	jmp $084f			jmp 	NextCommand
.09d2					_ACBadIndex:
.09d2	4c ec 1f	jmp $1fec		jmp	ErrorV_index
.09d5					UnaryAsc:
.09d5	fa		plx				plx
.09d6	5a		phy				phy
.09d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09d9	85 2c		sta $2c				sta 	zTemp0
.09db	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09dd	85 2d		sta $2d				sta 	zTemp0+1
.09df	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09e1	f0 06		beq $09e9			beq 	_UAExit
.09e3	5a		phy				phy 								; otherwise first character
.09e4	a0 01		ldy #$01			ldy 	#1
.09e6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09e8	7a		ply				ply
.09e9					_UAExit:
.09e9	20 6a 26	jsr $266a			jsr 	FloatSetByte
.09ec	7a		ply				ply
.09ed	4c 4f 08	jmp $084f			jmp 	NextCommand
.09f0					CommandAssert:
.09f0	fa		plx				plx
.09f1	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09f3	d0 09		bne $09fe			bne 	_CAFail
.09f5	20 8a 26	jsr $268a			jsr 	FloatIsZero 				; is it zero ?
.09f8	f0 04		beq $09fe			beq 	_CAFail
.09fa	ca		dex				dex
.09fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.09fe					_CAFail:
.09fe	4c 45 1f	jmp $1f45		jmp	ErrorV_assert
.0a01					X16_Audio_Parameters8_16:
.0a01	20 07 0a	jsr $0a07			jsr 	X16_Audio_Parameters8_8
.0a04	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.0a06	60		rts				rts
.0a07					X16_Audio_Parameters8_8:
.0a07	a2 01		ldx #$01			ldx 	#1
.0a09	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.0a0c	ca		dex				dex
.0a0d	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.0a10	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0a13	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.0a15	a0 00		ldy #$00			ldy 	#0
.0a17	60		rts				rts
.0a18					X16_Audio_Parameters8_String:
.0a18	20 01 0a	jsr $0a01			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.0a1b	da		phx				phx 								; set the voice
.0a1c	5a		phy				phy
.0a1d	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.0a20	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>0a23	0a						.byte 	X16_AudioCodeBank
.0a24	7a		ply				ply
.0a25	fa		plx				plx
.0a26	86 2c		stx $2c				stx 	zTemp0
.0a28	84 2d		sty $2d				sty 	zTemp0+1
.0a2a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a2c	e8		inx				inx 								; point YX to first character.
.0a2d	d0 01		bne $0a30			bne 	_X16APSSkip
.0a2f	c8		iny				iny
.0a30					_X16APSSkip:
.0a30	60		rts				rts
.0a31					Unary16Bin:
.0a31	fa		plx				plx
.0a32	20 47 10	jsr $1047			jsr 	GetInteger16Bit				; 16 bit int
.0a35	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a37	20 11 17	jsr $1711			jsr 	StringAllocTemp
.0a3a	a5 2d		lda $2d				lda 	zTemp0+1
.0a3c	f0 03		beq $0a41			beq 	_UBNoHigh
.0a3e	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a41					_UBNoHigh:
.0a41	a5 2c		lda $2c				lda 	zTemp0
.0a43	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a46	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a49					_UBWriteBinary:
.0a49	5a		phy				phy
.0a4a	a0 08		ldy #$08			ldy 	#8
.0a4c					_UBWLoop:
.0a4c	0a		asl a				asl 	a
.0a4d	48		pha				pha
.0a4e	a9 00		lda #$00			lda  	#0
.0a50	69 30		adc #$30			adc 	#48
.0a52	20 3a 17	jsr $173a			jsr 	StringWriteChar
.0a55	68		pla				pla
.0a56	88		dey				dey
.0a57	d0 f3		bne $0a4c			bne 	_UBWLoop
.0a59	7a		ply				ply
.0a5a	60		rts				rts
.0a5b					PrintCharacterX:
.0a5b	fa		plx				plx
.0a5c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a5e	ca		dex				dex
.0a5f	20 6e 13	jsr $136e			jsr 	VectorPrintCharacter
.0a62	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a65					UnaryChr:
.0a65	fa		plx				plx
.0a66	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get integer to convert.
.0a69	48		pha				pha 								; save it and allocate for it
.0a6a	a9 01		lda #$01			lda 	#1 							; 1 character
.0a6c	20 11 17	jsr $1711			jsr 	StringAllocTemp
.0a6f	a9 01		lda #$01			lda 	#1 							; length 1.
.0a71	92 22		sta ($22)			sta 	(zsTemp)
.0a73	68		pla				pla 								; character code makes string.
.0a74	5a		phy				phy
.0a75	a0 01		ldy #$01			ldy 	#1
.0a77	91 22		sta ($22),y			sta 	(zsTemp),y
.0a79	7a		ply				ply
.0a7a	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a7d					CommandClr:
.0a7d	fa		plx				plx
.0a7e	20 84 0a	jsr $0a84			jsr 	ClearMemory
.0a81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a84					ClearMemory:
.0a84	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a87	85 2d		sta $2d				sta 	zTemp0+1
.0a89	64 2c		stz $2c				stz 	zTemp0
.0a8b	5a		phy				phy
.0a8c	a0 00		ldy #$00			ldy 	#0
.0a8e					_ClearLoop1:
.0a8e	a9 00		lda #$00			lda 	#0
.0a90	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a92	c8		iny				iny
.0a93	d0 f9		bne $0a8e			bne 	_ClearLoop1
.0a95	e6 2d		inc $2d				inc 	zTemp0+1
.0a97	a5 2d		lda $2d				lda 	zTemp0+1
.0a99	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a9c	d0 f0		bne $0a8e			bne 	_ClearLoop1
.0a9e	38		sec				sec 											; stack space = number of pages in total / 4
.0a9f	ad 06 04	lda $0406			lda 	storeEndHigh
.0aa2	ed 05 04	sbc $0405			sbc		storeStartHigh
.0aa5	4a		lsr a				lsr 	a
.0aa6	4a		lsr a				lsr 	a
.0aa7	d0 02		bne $0aab			bne 	_NotEmpty 								; at least 1 !
.0aa9	a9 01		lda #$01			lda 	#1
.0aab					_NotEmpty:
.0aab	38		sec				sec 											; subtract from high to give string high memory
.0aac	49 ff		eor #$ff			eor 	#$FF
.0aae	6d 06 04	adc $0406			adc 	storeEndHigh
.0ab1	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0ab4	9c 02 04	stz $0402			stz 	stringHighMemory
.0ab7	9c 6a 05	stz $056a			stz 	stringInitialised 						; string system not initialised
.0aba	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0abd	3a		dec a				dec 	a
.0abe	85 25		sta $25				sta 	runtimeStackPtr+1
.0ac0	a9 ff		lda #$ff			lda 	#$FF
.0ac2	85 24		sta $24				sta 	runtimeStackPtr
.0ac4	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0ac6	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0ac8	7a		ply				ply
.0ac9	60		rts				rts
.0aca					CompareStrings:
.0aca	fa		plx				plx
.0acb	ca		dex				dex
.0acc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0ace	85 2c		sta $2c				sta 	zTemp0
.0ad0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ad2	85 2d		sta $2d				sta 	zTemp0+1
.0ad4	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0ad6	85 2e		sta $2e				sta 	zTemp1
.0ad8	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0ada	85 2f		sta $2f				sta 	zTemp1+1
.0adc	da		phx				phx
.0add	5a		phy				phy
.0ade	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0ae0	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0ae2	90 02		bcc $0ae6			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0ae4	b2 2e		lda ($2e)			lda 	(zTemp1)
.0ae6					_CSNIsSmallest:
.0ae6	aa		tax				tax 								; count in X
.0ae7	f0 0c		beq $0af5			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0ae9	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0aeb					_CSNCompareString:
.0aeb	c8		iny				iny 								; pre increment
.0aec	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0aee	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0af0	d0 0a		bne $0afc			bne 	_CSNDifferent 				; numbers are different.
.0af2	ca		dex				dex
.0af3	d0 f6		bne $0aeb			bne 	_CSNCompareString 			; compare common characters in two strings.
.0af5					_CSNMatches:
.0af5	38		sec				sec
.0af6	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0af8	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0afa	f0 06		beq $0b02			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0afc					_CSNDifferent:
.0afc	a9 ff		lda #$ff			lda 	#$FF
.0afe	90 02		bcc $0b02			bcc 	_CSNSExit
.0b00	a9 01		lda #$01			lda 	#$01
.0b02					_CSNSExit:
.0b02	7a		ply				ply
.0b03	fa		plx				plx
.0b04	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0b06	20 6a 26	jsr $266a			jsr 	FloatSetByte 				; output the byte
.0b09	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b0c					StringConcrete:
.0b0c	9c 6a 05	stz $056a			stz 	stringInitialised	 		; initialise next usage
.0b0f	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0b11	85 30		sta $30				sta 	zTemp2
.0b13	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0b15	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0b16	18		clc				clc
.0b17	72 30		adc ($30)			adc 	(zTemp2)
.0b19	90 02		bcc $0b1d			bcc 	_SCNoOverflow
.0b1b	a9 ff		lda #$ff			lda 	#255
.0b1d					_SCNoOverflow:
.0b1d	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0b1f	b0 02		bcs $0b23			bcs 	_SCNoMinimum
.0b21	a9 0a		lda #$0a			lda 	#10
.0b23					_SCNoMinimum:
.0b23	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0b25	38		sec				sec
.0b26	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0b29	e5 2e		sbc $2e				sbc 	zTemp1
.0b2b	a8		tay				tay
.0b2c	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b2f	e9 00		sbc #$00			sbc 	#0
.0b31	48		pha				pha
.0b32	38		sec				sec 								; subtract 3 more
.0b33	98		tya				tya
.0b34	e9 03		sbc #$03			sbc 	#3
.0b36	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b39	85 22		sta $22				sta 	zsTemp
.0b3b	68		pla				pla
.0b3c	e9 00		sbc #$00			sbc 	#0
.0b3e	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b41	85 23		sta $23				sta 	zsTemp+1
.0b43	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b45	92 22		sta ($22)			sta 	(zsTemp)
.0b47	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b49	a9 00		lda #$00			lda 	#0
.0b4b	91 22		sta ($22),y			sta 	(zsTemp),y
.0b4d	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b4f	a4 23		ldy $23				ldy 	zsTemp+1
.0b51	60		rts				rts
.0b52					CommandXData:
.0b52	fa		plx				plx
.0b53	98		tya				tya 								; data length +1 added to Y
.0b54	38		sec				sec
.0b55	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b57	a8		tay				tay
.0b58	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b5b					CommandXDIM:
.0b5b	fa		plx				plx
.0b5c	5a		phy				phy
.0b5d	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b60	8d 0a 04	sta $040a			sta 	dimType
.0b63	ca		dex				dex 								; this is the number of indices
.0b64	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0b67	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b69	8a		txa				txa 								; dimension.
.0b6a	38		sec				sec
.0b6b	e5 2e		sbc $2e				sbc 	zTemp1
.0b6d	aa		tax				tax
.0b6e	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b70	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create one at this level
.0b73	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b75	98		tya				tya
.0b76	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b78	74 56		stz $56,x			stz 	NSMantissa2,x
.0b7a	74 62		stz $62,x			stz 	NSMantissa3,x
.0b7c	74 32		stz $32,x			stz 	NSStatus,x
.0b7e	74 6e		stz $6e,x			stz 	NSExponent,x
.0b80	7a		ply				ply
.0b81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b84					DIMCreateOneLevel:
.0b84	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b86	5a		phy				phy
.0b87	a4 27		ldy $27				ldy 	availableMemory+1
.0b89	5a		phy				phy
.0b8a	a8		tay				tay 			 					; save current level into Y
.0b8b	20 47 10	jsr $1047			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b8e	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b90	d0 02		bne $0b94			bne 	_DCOLNoCarry
.0b92	e6 2d		inc $2d				inc 	zTemp0+1
.0b94					_DCOLNoCarry:
.0b94	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b96	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b99	a5 2d		lda $2d				lda 	zTemp0+1
.0b9b	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b9e	ad 0a 04	lda $040a			lda 	dimType 					; get type information
.0ba1	29 7f		and #$7f			and 	#$7F
.0ba3	c0 01		cpy #$01			cpy 	#1
.0ba5	f0 02		beq $0ba9			beq 	_DCOLNoSubLevel
.0ba7	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0ba9					_DCOLNoSubLevel:
.0ba9	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0bac	a5 26		lda $26				lda 	availableMemory
.0bae	85 2e		sta $2e				sta 	zTemp1
.0bb0	a5 27		lda $27				lda 	availableMemory+1
.0bb2	85 2f		sta $2f				sta 	zTemp1+1
.0bb4	a5 2c		lda $2c				lda 	zTemp0
.0bb6	85 30		sta $30				sta 	zTemp2
.0bb8	a5 2d		lda $2d				lda 	zTemp0+1
.0bba	85 31		sta $31				sta 	zTemp2+1
.0bbc					_DCOLFillArray:
.0bbc	20 1b 0c	jsr $0c1b			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0bbf	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0bc1	d0 02		bne $0bc5			bne 	_DCOLNoBorrow
.0bc3	c6 2d		dec $2d				dec 	zTemp0+1
.0bc5					_DCOLNoBorrow:
.0bc5	c6 2c		dec $2c				dec 	zTemp0
.0bc7	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0bc9	05 2d		ora $2d				ora 	zTemp0+1
.0bcb	d0 ef		bne $0bbc			bne 	_DCOLFillArray
.0bcd	c0 01		cpy #$01			cpy 	#1
.0bcf	f0 42		beq $0c13			beq 	_DCOLExit
.0bd1					_DCOLRecursionLoop:
.0bd1	da		phx				phx 								; save XY
.0bd2	5a		phy				phy
.0bd3	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0bd5	48		pha				pha
.0bd6	a5 2f		lda $2f				lda 	zTemp1+1
.0bd8	48		pha				pha
.0bd9	a5 30		lda $30				lda 	zTemp2
.0bdb	48		pha				pha
.0bdc	a5 31		lda $31				lda 	zTemp2+1
.0bde	48		pha				pha
.0bdf	88		dey				dey  								; lower level -> A
.0be0	98		tya				tya
.0be1	e8		inx				inx 								; next index size
.0be2	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0be5	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0be6	86 31		stx $31				stx 	zTemp2+1
.0be8	fa		plx				plx
.0be9	86 30		stx $30				stx 	zTemp2
.0beb	fa		plx				plx
.0bec	86 2f		stx $2f				stx 	zTemp1+1
.0bee	fa		plx				plx
.0bef	86 2e		stx $2e				stx 	zTemp1
.0bf1	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0bf3	98		tya				tya
.0bf4	a0 01		ldy #$01			ldy 	#1
.0bf6	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0bf8	7a		ply				ply 								; restore XY
.0bf9	fa		plx				plx
.0bfa	18		clc				clc
.0bfb	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0bfd	69 02		adc #$02			adc 	#2
.0bff	85 2e		sta $2e				sta 	zTemp1
.0c01	90 02		bcc $0c05			bcc 	_DCOLRNoCarry
.0c03	e6 2f		inc $2f				inc 	zTemp1+1
.0c05					_DCOLRNoCarry:
.0c05	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0c07	d0 02		bne $0c0b			bne 	_DCOLRNoBorrow
.0c09	c6 31		dec $31				dec 	zTemp2+1
.0c0b					_DCOLRNoBorrow:
.0c0b	c6 30		dec $30				dec 	zTemp2
.0c0d	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0c0f	05 31		ora $31				ora 	zTemp2+1
.0c11	d0 be		bne $0bd1			bne 	_DCOLRecursionLoop
.0c13					_DCOLExit:
.0c13	68		pla				pla 								; get MSB, make offset again
.0c14	38		sec				sec
.0c15	ed 07 04	sbc $0407			sbc 	variableStartPage
.0c18	a8		tay				tay
.0c19	68		pla				pla 								; YA now contains offset address.
.0c1a	60		rts				rts
.0c1b					DIMWriteElement:
.0c1b	da		phx				phx
.0c1c	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0c1e	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0c20	d0 0b		bne $0c2d			bne 	_DIMWENotFloat
.0c22	ad 0a 04	lda $040a			lda 	dimType
.0c25	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0c27	c9 00		cmp #$00			cmp 	#NSSIFloat
.0c29	d0 02		bne $0c2d			bne 	_DIMWENotFloat
.0c2b	a2 06		ldx #$06			ldx 	#6
.0c2d					_DIMWENotFloat:
.0c2d	a9 00		lda #$00			lda 	#0
.0c2f	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0c32	ca		dex				dex
.0c33	d0 f8		bne $0c2d			bne 	_DIMWENotFloat
.0c35	fa		plx				plx
.0c36	60		rts				rts
.0c37					DIMWriteByte:
.0c37	92 26		sta ($26)			sta 	(availableMemory)
.0c39	e6 26		inc $26				inc 	availableMemory
.0c3b	d0 0b		bne $0c48			bne 	_DIMWBSkip
.0c3d	e6 27		inc $27				inc 	availableMemory+1
.0c3f	48		pha				pha
.0c40	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c42	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c45	b0 02		bcs $0c49			bcs 	_DIMWBMemory
.0c47	68		pla				pla
.0c48					_DIMWBSkip:
.0c48	60		rts				rts
.0c49					_DIMWBMemory:
.0c49	4c ff 1f	jmp $1fff		jmp	ErrorV_memory
.040a					dimType:
>040a							.fill 	1
.0c4c					CommandEnd:
.0c4c	fa		plx				plx
.0c4d	86 2c		stx $2c				stx 	zTemp0
.0c4f	18		clc				clc 								; exit okay.
.0c50					EndRuntime:
.0c50	ae 08 04	ldx $0408			ldx 	Runtime6502SP 				; set up the stack pointer
.0c53	9a		txs				txs
.0c54	60		rts				rts
.0c55					Unimplemented:
.0c55	4c 32 1f	jmp $1f32			jmp 	ErrorV_unimplemented
.0c58					RuntimeErrorHandler:
.0c58	98		tya				tya
.0c59	18		clc				clc
.0c5a	65 28		adc $28				adc 	codePtr
.0c5c	85 28		sta $28				sta 	codePtr
.0c5e	90 02		bcc $0c62			bcc 	_EHNoCarry
.0c60	e6 29		inc $29				inc 	codePtr+1
.0c62					_EHNoCarry:
.0c62	68		pla				pla
.0c63	7a		ply				ply
.0c64	85 2c		sta $2c				sta 	zTemp0
.0c66	84 2d		sty $2d				sty 	zTemp0+1
.0c68	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c6a	a0 01		ldy #$01			ldy 	#1
.0c6c					_EHDisplayMsg:
.0c6c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c6e	20 8f 1c	jsr $1c8f			jsr 	XPrintCharacterToChannel
.0c71	c8		iny				iny
.0c72	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c74	d0 f6		bne $0c6c			bne 	_EHDisplayMsg
.0c76	a9 20		lda #$20			lda 	#32
.0c78	20 8f 1c	jsr $1c8f			jsr 	XPrintCharacterToChannel
.0c7b	a9 40		lda #$40			lda 	#64
.0c7d	20 8f 1c	jsr $1c8f			jsr 	XPrintCharacterToChannel
.0c80	a9 20		lda #$20			lda 	#32
.0c82	20 8f 1c	jsr $1c8f			jsr 	XPrintCharacterToChannel
.0c85	20 8c 0c	jsr $0c8c			jsr 	EHDisplayCodePtr
.0c88	38		sec				sec 								; error.
.0c89	4c 50 0c	jmp $0c50			jmp 	EndRuntime
.0c8c					EHDisplayCodePtr:
.0c8c	a9 24		lda #$24			lda 	#'$'
.0c8e	20 8f 1c	jsr $1c8f			jsr 	XPrintCharacterToChannel
.0c91	38		sec				sec
.0c92	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c94	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c97	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9a	a5 28		lda $28				lda 	codePtr
.0c9c	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9f	60		rts				rts
.0ca0					_EHDisplayHex:
.0ca0	48		pha				pha
.0ca1	4a		lsr a				lsr 	a
.0ca2	4a		lsr a				lsr 	a
.0ca3	4a		lsr a				lsr 	a
.0ca4	4a		lsr a				lsr 	a
.0ca5	20 a9 0c	jsr $0ca9			jsr 	_EHDisplayNibble
.0ca8	68		pla				pla
.0ca9					_EHDisplayNibble:
.0ca9	29 0f		and #$0f			and 	#15
.0cab	c9 0a		cmp #$0a			cmp 	#10
.0cad	90 02		bcc $0cb1			bcc 	_EHNotHex
.0caf	69 06		adc #$06			adc 	#6
.0cb1					_EHNotHex:
.0cb1	69 30		adc #$30			adc 	#48
.0cb3	4c 8f 1c	jmp $1c8f			jmp 	XPrintCharacterToChannel
.0cb6					CommandXFor:
.0cb6	fa		plx				plx
.0cb7	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0cb9	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0cbc	20 78 11	jsr $1178			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0cbf	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0cc1	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cc4	ca		dex				dex
.0cc5	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0cc7	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cca	ca		dex				dex
.0ccb	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0ccd	29 80		and #$80			and 	#$80
.0ccf	a0 04		ldy #$04			ldy 	#4
.0cd1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd3	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0cd5	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0cd7	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd9	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0cdb	c8		iny				iny
.0cdc	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cde	18		clc				clc
.0cdf	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0ce1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ce3	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0ce6	85 2d		sta $2d				sta 	zTemp0+1
.0ce8	ca		dex				dex 								; throw reference.
.0ce9	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0ceb	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0ced	a0 0c		ldy #$0c			ldy 	#12
.0cef	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf1	a0 12		ldy #$12			ldy 	#18
.0cf3	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf5	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0cf7	88		dey				dey 								; now the exponents.
.0cf8	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0cfa	a0 0b		ldy #$0b			ldy 	#11
.0cfc	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cfe	a0 11		ldy #$11			ldy 	#17
.0d00	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d02	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0d04	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d06	c8		iny				iny
.0d07	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d09	c8		iny				iny
.0d0a	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d0c	d0 08		bne $0d16			bne 	_CFNoOptimise
.0d0e	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0d10	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0d12	09 40		ora #$40			ora 	#$40
.0d14	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d16					_CFNoOptimise:
.0d16	a0 00		ldy #$00			ldy 	#0
.0d18	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d1b					CopyTOSToOffsetY:
.0d1b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0d1d	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d1f	c8		iny				iny
.0d20	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0d22	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d24	c8		iny				iny
.0d25	b5 56		lda $56,x			lda 	NSMantissa2,x
.0d27	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d29	c8		iny				iny
.0d2a	b5 62		lda $62,x			lda 	NSMantissa3,x
.0d2c	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d2e	c8		iny				iny
.0d2f	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d31	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d33	c8		iny				iny
.0d34	b5 32		lda $32,x			lda 	NSStatus,x
.0d36	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d38	60		rts				rts
.0d39					StackOpenFrame:
.0d39	48		pha				pha 								; save frame marker
.0d3a	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d3c	85 2c		sta $2c				sta 	zTemp0
.0d3e	38		sec				sec 								; subtract from runtime stack pointer.
.0d3f	a5 24		lda $24				lda		runtimeStackPtr
.0d41	e5 2c		sbc $2c				sbc 	zTemp0
.0d43	85 24		sta $24				sta 	runtimeStackPtr
.0d45	a5 25		lda $25				lda		runtimeStackPtr+1
.0d47	e9 00		sbc #$00			sbc 	#0
.0d49	85 25		sta $25				sta 	runtimeStackPtr+1
.0d4b	68		pla				pla 								; put frame marker at +0
.0d4c	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d4e	60		rts				rts
.0d4f					StackCloseFrame:
.0d4f	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d51	29 1f		and #$1f			and 	#$1F 						; size
.0d53	18		clc				clc
.0d54	65 24		adc $24				adc 	runtimeStackPtr
.0d56	85 24		sta $24				sta 	runtimeStackPtr
.0d58	90 02		bcc $0d5c			bcc 	_SCFNoCarry
.0d5a	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d5c					_SCFNoCarry:
.0d5c	60		rts				rts
.0d5d					StackFindFrame:
.0d5d	8d 0b 04	sta $040b			sta 	requiredFrame
.0d60					_SFFLoop:
.0d60	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d62	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d64	f0 10		beq $0d76			beq 	SCFFail
.0d66	cd 0b 04	cmp $040b			cmp 	requiredFrame 				; found this type ?
.0d69	f0 05		beq $0d70			beq 	_SFFFound
.0d6b	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close the top frame
.0d6e	80 f0		bra $0d60			bra 	_SFFLoop 					; and try te next.
.0d70					_SFFFound:
.0d70	60		rts				rts
.0d71					StackCheckFrame:
.0d71	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d73	d0 01		bne $0d76			bne 	SCFFail
.0d75	60		rts				rts
.0d76					SCFFail:
.0d76	4c 8f 1f	jmp $1f8f		jmp	ErrorV_structure
.040b					requiredFrame:
>040b							.fill 	1
.0d79					UnaryFre:
.0d79	fa		plx				plx
.0d7a	20 68 26	jsr $2668			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d7d	38		sec				sec
.0d7e	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d81	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d84	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d86	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d89	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d8c	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d8e	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d91					CommandXGet:
.0d91	fa		plx				plx
.0d92	e8		inx				inx
.0d93	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d95	20 11 17	jsr $1711			jsr 	StringAllocTemp
.0d98	20 77 13	jsr $1377			jsr 	VectorGetCharacter 			; get a character
.0d9b	c9 00		cmp #$00			cmp 	#0
.0d9d	f0 09		beq $0da8			beq 	_CGNone
.0d9f	5a		phy				phy
.0da0	a0 01		ldy #$01			ldy 	#1 							; store char
.0da2	91 22		sta ($22),y			sta 	(zsTemp),y
.0da4	98		tya				tya 								; store length.
.0da5	92 22		sta ($22)			sta 	(zsTemp)
.0da7	7a		ply				ply
.0da8					_CGNone:
.0da8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dab					CommandXGosub:
.0dab	fa		plx				plx
.0dac	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dae	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0db1	20 78 11	jsr $1178			jsr 	StackSaveCurrentPosition
.0db4	4c c9 0d	jmp $0dc9			jmp 	PerformGOTO
.0db7					CommandReturn:
.0db7	fa		plx				plx
.0db8	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dba	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.0dbd	20 89 11	jsr $1189			jsr 	StackLoadCurrentPosition
.0dc0	c8		iny				iny
.0dc1	c8		iny				iny
.0dc2	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame
.0dc5	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dc8					CommandXGoto:
.0dc8	fa		plx				plx
.0dc9					PerformGOTO:
.0dc9	c8		iny				iny 								; push MSB of offset on stack
.0dca	b1 28		lda ($28),y			lda 	(codePtr),y
.0dcc	48		pha				pha
.0dcd	88		dey				dey 								; point LSB of offset
.0dce	18		clc				clc 								; add LSB
.0dcf	b1 28		lda ($28),y			lda 	(codePtr),y
.0dd1	65 28		adc $28				adc 	codePtr
.0dd3	85 28		sta $28				sta 	codePtr
.0dd5	68		pla				pla 								; restore offset MSB and add
.0dd6	65 29		adc $29				adc 	codePtr+1
.0dd8	85 29		sta $29				sta 	codePtr+1
.0dda	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ddd					CommandGotoZ:
.0ddd	fa		plx				plx
.0dde	20 8a 26	jsr $268a			jsr 	FloatIsZero
.0de1	ca		dex				dex
.0de2	c9 00		cmp #$00			cmp 	#0
.0de4	f0 e3		beq $0dc9			beq 	PerformGOTO
.0de6	c8		iny				iny
.0de7	c8		iny				iny
.0de8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0deb					CommandGotoNZ:
.0deb	fa		plx				plx
.0dec	20 8a 26	jsr $268a			jsr 	FloatIsZero
.0def	ca		dex				dex
.0df0	c9 00		cmp #$00			cmp 	#0
.0df2	d0 d5		bne $0dc9			bne 	PerformGOTO
.0df4	c8		iny				iny
.0df5	c8		iny				iny
.0df6	4c 4f 08	jmp $084f			jmp 	NextCommand
.0df9					Command_PSET:
.0df9	fa		plx				plx
.0dfa	5a		phy				phy
.0dfb	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the colour
.0dfe	48		pha				pha
.0dff	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e01	a0 02		ldy #$02			ldy 	#X16_r0
.0e03	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e06	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0e09	68		pla				pla 								; set pixel.
.0e0a	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0e0d	7a		ply				ply
.0e0e	a2 ff		ldx #$ff			ldx 	#$FF
.0e10	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e13					Command_LINE:
.0e13	fa		plx				plx
.0e14	5a		phy				phy
.0e15	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e18	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0e1a	a0 02		ldy #$02			ldy 	#X16_r0
.0e1c	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0e1f	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0e22	7a		ply				ply
.0e23	a2 ff		ldx #$ff			ldx 	#$FF
.0e25	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e28					Command_RECT:
.0e28	fa		plx				plx
.0e29	5a		phy				phy
.0e2a	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e2d	38		sec				sec
.0e2e	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e31	7a		ply				ply
.0e32	a2 ff		ldx #$ff			ldx 	#$FF
.0e34	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e37					Command_FRAME:
.0e37	fa		plx				plx
.0e38	5a		phy				phy
.0e39	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e3c	18		clc				clc
.0e3d	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e40	7a		ply				ply
.0e41	a2 ff		ldx #$ff			ldx 	#$FF
.0e43	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e46					Command_CHAR:
.0e46	fa		plx				plx
.0e47	5a		phy				phy
.0e48	ca		dex				dex  								; set the draw colour
.0e49	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e4c	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e4e	a0 02		ldy #$02			ldy 	#X16_r0
.0e50	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e53	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e55	85 2c		sta $2c				sta 	zTemp0
.0e57	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e59	85 2d		sta $2d				sta 	zTemp0+1
.0e5b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e5d	85 2e		sta $2e				sta 	zTemp1
.0e5f					_CCLoop:
.0e5f	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e61	f0 0f		beq $0e72			beq 	_CCExit
.0e63	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e65	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e67	d0 02		bne $0e6b			bne 	_CCNoCarry
.0e69	e6 2d		inc $2d				inc 	zTemp0+1
.0e6b					_CCNoCarry:
.0e6b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e6d	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e70	80 ed		bra $0e5f			bra 	_CCLoop						; go round.
.0e72					_CCExit:
.0e72	7a		ply				ply
.0e73	a2 ff		ldx #$ff			ldx 	#$FF
.0e75	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e78					GraphicsColour:
.0e78	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0e7b	aa		tax				tax
.0e7c	a0 00		ldy #$00			ldy 	#0
.0e7e	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e81	60		rts				rts
.0e82					GraphicsCopy4:
.0e82	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e85					GraphicsCopy2:
.0e85	20 88 0e	jsr $0e88			jsr 	GraphicsCopy1
.0e88					GraphicsCopy1:
.0e88	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.0e8b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e8d	99 00 00	sta $0000,y			sta 	0,y
.0e90	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e92	99 01 00	sta $0001,y			sta 	1,y
.0e95	e8		inx				inx
.0e96	c8		iny				iny
.0e97	c8		iny				iny
.0e98	60		rts				rts
.0e99					GraphicsRectCoords:
.0e99	20 78 0e	jsr $0e78			jsr 	GraphicsColour 				; set colour
.0e9c	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e9e	a0 02		ldy #$02			ldy 	#X16_r0
.0ea0	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0ea3	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0ea5	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ea8	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0eaa	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ead	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0eaf	74 09		stz $09,x			stz 	9,x
.0eb1	60		rts				rts
.0eb2					_GRCSortSubtract:
.0eb2	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0eb4	d5 00		cmp $00,x			cmp 	0,x
.0eb6	b5 05		lda $05,x			lda 	5,x
.0eb8	f5 01		sbc $01,x			sbc 	1,x
.0eba	b0 08		bcs $0ec4			bcs 	_GRCNoSwap 					; >= swap.
.0ebc	20 d2 0e	jsr $0ed2			jsr 	_GRCSwapByte 				; swap 0/2
.0ebf	e8		inx				inx
.0ec0	20 d2 0e	jsr $0ed2			jsr 	_GRCSwapByte 				; swap 1/3
.0ec3	ca		dex				dex
.0ec4					_GRCNoSwap:
.0ec4	38		sec				sec 								; calculate width/height into 4,5
.0ec5	b5 04		lda $04,x			lda 	4,x
.0ec7	f5 00		sbc $00,x			sbc 	0,x
.0ec9	95 04		sta $04,x			sta 	4,x
.0ecb	b5 05		lda $05,x			lda 	5,x
.0ecd	f5 01		sbc $01,x			sbc 	1,x
.0ecf	95 05		sta $05,x			sta 	5,x
.0ed1	60		rts				rts
.0ed2					_GRCSwapByte:
.0ed2	b5 04		lda $04,x			lda 	4,x
.0ed4	48		pha				pha
.0ed5	b5 00		lda $00,x			lda 	0,x
.0ed7	95 04		sta $04,x			sta 	4,x
.0ed9	68		pla				pla
.0eda	95 00		sta $00,x			sta 	0,x
.0edc	60		rts				rts
.0edd					Unary16Hex:
.0edd	fa		plx				plx
.0ede	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.0ee1	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0ee3	20 11 17	jsr $1711			jsr 	StringAllocTemp
.0ee6	a5 2d		lda $2d				lda 	zTemp0+1
.0ee8	f0 03		beq $0eed			beq 	_UHNoHigh
.0eea	20 f5 0e	jsr $0ef5			jsr 	_UHWriteHex
.0eed					_UHNoHigh:
.0eed	a5 2c		lda $2c				lda 	zTemp0
.0eef	20 f5 0e	jsr $0ef5			jsr 	_UHWriteHex
.0ef2	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ef5					_UHWriteHex:
.0ef5	48		pha				pha
.0ef6	4a		lsr a				lsr 	a
.0ef7	4a		lsr a				lsr 	a
.0ef8	4a		lsr a				lsr 	a
.0ef9	4a		lsr a				lsr 	a
.0efa	20 fe 0e	jsr $0efe			jsr 	_UHWriteNibl
.0efd	68		pla				pla
.0efe					_UHWriteNibl:
.0efe	29 0f		and #$0f			and 	#15
.0f00	c9 0a		cmp #$0a			cmp 	#10
.0f02	90 02		bcc $0f06			bcc 	_UHDigit
.0f04	69 06		adc #$06			adc 	#6
.0f06					_UHDigit:
.0f06	69 30		adc #$30			adc 	#48
.0f08	20 3a 17	jsr $173a			jsr 	StringWriteChar
.0f0b	60		rts				rts
.0f0c					IndFloatRead:
.0f0c	fa		plx				plx
.0f0d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f0f	85 2c		sta $2c				sta 	zTemp0
.0f11	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f13	18		clc				clc
.0f14	6d 07 04	adc $0407			adc 	variableStartPage
.0f17	85 2d		sta $2d				sta 	zTemp0+1
.0f19	ca		dex				dex 								; throw the address
.0f1a	20 f0 14	jsr $14f0			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0f1d	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f20					IndInt16Read:
.0f20	fa		plx				plx
.0f21	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f23	85 2c		sta $2c				sta 	zTemp0
.0f25	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f27	18		clc				clc
.0f28	6d 07 04	adc $0407			adc 	variableStartPage
.0f2b	85 2d		sta $2d				sta 	zTemp0+1
.0f2d	ca		dex				dex 								; throw the address
.0f2e	20 2c 15	jsr $152c			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f31	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f34					IndStringRead:
.0f34	fa		plx				plx
.0f35	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f37	85 2c		sta $2c				sta 	zTemp0
.0f39	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f3b	18		clc				clc
.0f3c	6d 07 04	adc $0407			adc 	variableStartPage
.0f3f	85 2d		sta $2d				sta 	zTemp0+1
.0f41	ca		dex				dex 								; throw the address
.0f42	20 71 15	jsr $1571			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f45	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f48					IndFloatWrite:
.0f48	fa		plx				plx
.0f49	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f4b	85 2c		sta $2c				sta 	zTemp0
.0f4d	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f4f	18		clc				clc
.0f50	6d 07 04	adc $0407			adc 	variableStartPage
.0f53	85 2d		sta $2d				sta 	zTemp0+1
.0f55	20 cb 1a	jsr $1acb			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f58	ca		dex				dex 								; throw the address as well.
.0f59	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f5c					IndInt16Write:
.0f5c	fa		plx				plx
.0f5d	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f5f	85 2c		sta $2c				sta 	zTemp0
.0f61	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f63	18		clc				clc
.0f64	6d 07 04	adc $0407			adc 	variableStartPage
.0f67	85 2d		sta $2d				sta 	zTemp0+1
.0f69	20 07 1b	jsr $1b07			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f6c	ca		dex				dex 								; throw the address as well.
.0f6d	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f70					IndStringWrite:
.0f70	fa		plx				plx
.0f71	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f73	85 2c		sta $2c				sta 	zTemp0
.0f75	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f77	18		clc				clc
.0f78	6d 07 04	adc $0407			adc 	variableStartPage
.0f7b	85 2d		sta $2d				sta 	zTemp0+1
.0f7d	20 46 1b	jsr $1b46			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f80	ca		dex				dex 								; throw the address as well.
.0f81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f84					CommandXInput:
.0f84	fa		plx				plx
.0f85	5a		phy				phy 								; save Y
.0f86	e8		inx				inx									; space on stack
.0f87					_INError:
.0f87	20 bb 0f	jsr $0fbb			jsr 	InputStringToBuffer 		; input from keyboard
.0f8a	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.0f8c	85 2c		sta $2c				sta 	0+zTemp0
.0f8e	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f90	85 2d		sta $2d				sta 	1+zTemp0
.0f92	20 58 19	jsr $1958			jsr 	ValEvaluateZTemp0
.0f95	b0 f0		bcs $0f87			bcs 	_INError 					; failed, try again.
.0f97	7a		ply				ply 								; restore Y
.0f98	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f9b					CommandInputString:
.0f9b	fa		plx				plx
.0f9c	5a		phy				phy 								; save Y
.0f9d	20 bb 0f	jsr $0fbb			jsr 	InputStringToBuffer 		; input from keyboard
.0fa0	e8		inx				inx 								; make space on stack
.0fa1	20 68 26	jsr $2668			jsr 	FloatSetZero 				; store as string on stack
.0fa4	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.0fa6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0fa8	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0faa	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0fac	a9 40		lda #$40			lda 	#NSSString
.0fae	95 32		sta $32,x			sta 	NSStatus,x
.0fb0	7a		ply				ply 								; restore Y
.0fb1	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fb4					CommandInputReset:
.0fb4	fa		plx				plx
.0fb5	9c 0c 04	stz $040c			stz 	InputBuffer
.0fb8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fbb					InputStringToBuffer:
.0fbb	a9 f5		lda #$f5			lda 	#((InputBumpNext) & $FF)
.0fbd	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.0fc0	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0fc2	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.0fc5	a9 d2		lda #$d2			lda 	#((InputLookNext) & $FF)
.0fc7	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.0fca	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0fcc	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.0fcf	4c 4d 14	jmp $144d			jmp 	GetStringToBuffer
.0fd2					InputLookNext:
.0fd2	da		phx				phx
.0fd3					_ILNRetry:
.0fd3	ad 0c 04	lda $040c			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fd6	d0 08		bne $0fe0			bne 	_ILNNotEmpty
.0fd8	20 f9 0f	jsr $0ff9			jsr 	InputGetNewLine 			; get a new line
.0fdb	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset read position.
.0fde	80 f3		bra $0fd3			bra 	_ILNRetry
.0fe0					_ILNNotEmpty:
.0fe0	ae 5d 04	ldx $045d			ldx 	InputBufferPos 				; get head available character
.0fe3	bd 0c 04	lda $040c,x			lda 	InputBuffer,x
.0fe6	d0 08		bne $0ff0			bne 	_ILNExit 					; if not EOS return it with CC.
.0fe8					_ILNNextLine:
.0fe8	9c 0c 04	stz $040c			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0feb	38		sec				sec 								; return CS,Zero
.0fec	fa		plx				plx
.0fed	a9 0d		lda #$0d			lda 	#13
.0fef	60		rts				rts
.0ff0					_ILNExit:
.0ff0	fa		plx				plx
.0ff1	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0ff3	18		clc				clc
.0ff4	60		rts				rts
.0ff5					InputBumpNext:
.0ff5	ee 5d 04	inc $045d			inc 	InputBufferPos
.0ff8	60		rts				rts
.0ff9					InputGetNewLine:
.0ff9	48		pha				pha
.0ffa	da		phx				phx
.0ffb	5a		phy				phy
.0ffc	a9 3f		lda #$3f			lda 	#"?"
.0ffe	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.1001	a0 00		ldy #$00			ldy 	#0 							; line position.
.1003					_IGNLLoop:
.1003	20 77 13	jsr $1377			jsr 	VectorGetCharacter 			; get a character
.1006	c9 00		cmp #$00			cmp 	#0
.1008	f0 f9		beq $1003			beq 	_IGNLLoop
.100a	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.100c	f0 11		beq $101f			beq 	_IGNBackspace
.100e	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.1010	f0 17		beq $1029			beq 	_IGNExit
.1012	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.1014	f0 ed		beq $1003			beq 	_IGNLLoop
.1016	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1019	c8		iny				iny
.101a	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.101d	80 e4		bra $1003			bra 	_IGNLLoop
.101f					_IGNBackspace:
.101f	c0 00		cpy #$00			cpy 	#0
.1021	f0 e0		beq $1003			beq 	_IGNLLoop
.1023	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.1026	88		dey				dey
.1027	80 da		bra $1003			bra 	_IGNLLoop
.1029					_IGNExit:
.1029	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.102c	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.102e	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1031	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset position to start of input buffer.
.1034	7a		ply				ply
.1035	fa		plx				plx
.1036	68		pla				pla
.1037	60		rts				rts
.1038					IGNLEchoIfScreen:
.1038	ae 5f 04	ldx $045f			ldx 	currentChannel
.103b	d0 03		bne $1040			bne 	_IGNLEExit
.103d	20 6e 13	jsr $136e			jsr 	VectorPrintCharacter
.1040					_IGNLEExit:
.1040	60		rts				rts
.040c					InputBuffer:
>040c							.fill 	81
.045d					InputBufferPos:
>045d							.fill 	1
.1041					GetInteger8Bit:
.1041	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.1044	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1046	60		rts				rts
.1047					GetInteger16Bit:
.1047	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.104a	34 32		bit $32,x			bit 	NSStatus,x
.104c	30 09		bmi $1057			bmi 	Negate16Bit
.104e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1050	85 2c		sta $2c				sta 	zTemp0
.1052	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1054	85 2d		sta $2d				sta 	zTemp0+1
.1056	60		rts				rts
.1057					Negate16Bit:
.1057	38		sec				sec
.1058	a9 00		lda #$00			lda 	#0
.105a	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.105c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.105e	85 2c		sta $2c				sta 	zTemp0
.1060	a9 00		lda #$00			lda 	#0
.1062	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1064	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1066	85 2d		sta $2d				sta 	zTemp0+1
.1068	60		rts				rts
.1069					UnaryJoy:
.1069	fa		plx				plx
.106a	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; port #
.106d	48		pha				pha 								; zero the result.
.106e	20 68 26	jsr $2668			jsr 	FloatSetZero
.1071	68		pla				pla
.1072	5a		phy				phy
.1073	da		phx				phx
.1074	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1077	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1079	d0 10		bne $108b			bne 	_UJNoHardware
.107b	a8		tay				tay 								; move XA -> AY
.107c	8a		txa				txa
.107d	fa		plx				plx 								; we can update it now.
.107e	49 ff		eor #$ff			eor 	#$FF
.1080	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1082	98		tya				tya
.1083	49 ff		eor #$ff			eor 	#$FF
.1085	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1087	7a		ply				ply 								; restore Y
.1088	4c 4f 08	jmp $084f			jmp 	NextCommand
.108b					_UJNoHardware:
.108b	fa		plx				plx
.108c	7a		ply				ply
.108d	a9 01		lda #$01			lda 	#1 							; set result to -1
.108f	20 6a 26	jsr $266a			jsr 	FloatSetByte
.1092	20 2a 26	jsr $262a			jsr 	FloatNegate
.1095	4c 4f 08	jmp $084f			jmp 	NextCommand
.1098					UnaryLen:
.1098	fa		plx				plx
.1099	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.109b	85 2c		sta $2c				sta 	zTemp0
.109d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.109f	85 2d		sta $2d				sta 	zTemp0+1
.10a1	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.10a3	20 6a 26	jsr $266a			jsr 	FloatSetByte
.10a6	4c 4f 08	jmp $084f			jmp 	NextCommand
.10a9					LinkFloatAdd:
.10a9	fa		plx				plx
.10aa	5a		phy			phy
.10ab	20 8c 20	jsr $208c		jsr	FloatAdd
.10ae	7a		ply			ply
.10af	4c 4f 08	jmp $084f			jmp 	NextCommand
.10b2					LinkFloatSubtract:
.10b2	fa		plx				plx
.10b3	5a		phy			phy
.10b4	20 86 20	jsr $2086		jsr	FloatSubtract
.10b7	7a		ply			ply
.10b8	4c 4f 08	jmp $084f			jmp 	NextCommand
.10bb					LinkFloatMultiply:
.10bb	fa		plx				plx
.10bc	5a		phy			phy
.10bd	20 28 23	jsr $2328		jsr	FloatMultiply
.10c0	7a		ply			ply
.10c1	4c 4f 08	jmp $084f			jmp 	NextCommand
.10c4					LinkFloatDivide:
.10c4	fa		plx				plx
.10c5	5a		phy			phy
.10c6	20 b1 21	jsr $21b1		jsr	FloatDivide
.10c9	b0 5c		bcs $1127		bcs	DivZeroError
.10cb	7a		ply			ply
.10cc	4c 4f 08	jmp $084f			jmp 	NextCommand
.10cf					LinkFloatPower:
.10cf	fa		plx				plx
.10d0	5a		phy			phy
.10d1	20 31 29	jsr $2931		jsr	FloatPower
.10d4	b0 4e		bcs $1124		bcs	MapRangeError
.10d6	7a		ply			ply
.10d7	4c 4f 08	jmp $084f			jmp 	NextCommand
.10da					LinkCompareGreater:
.10da	fa		plx				plx
.10db	5a		phy			phy
.10dc	20 35 21	jsr $2135		jsr	CompareGreater
.10df	7a		ply			ply
.10e0	4c 4f 08	jmp $084f			jmp 	NextCommand
.10e3					LinkCompareEqual:
.10e3	fa		plx				plx
.10e4	5a		phy			phy
.10e5	20 17 21	jsr $2117		jsr	CompareEqual
.10e8	7a		ply			ply
.10e9	4c 4f 08	jmp $084f			jmp 	NextCommand
.10ec					LinkCompareLess:
.10ec	fa		plx				plx
.10ed	5a		phy			phy
.10ee	20 2d 21	jsr $212d		jsr	CompareLess
.10f1	7a		ply			ply
.10f2	4c 4f 08	jmp $084f			jmp 	NextCommand
.10f5					LinkCompareGreaterEqual:
.10f5	fa		plx				plx
.10f6	5a		phy			phy
.10f7	20 45 21	jsr $2145		jsr	CompareGreaterEqual
.10fa	7a		ply			ply
.10fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.10fe					LinkCompareNotEqual:
.10fe	fa		plx				plx
.10ff	5a		phy			phy
.1100	20 27 21	jsr $2127		jsr	CompareNotEqual
.1103	7a		ply			ply
.1104	4c 4f 08	jmp $084f			jmp 	NextCommand
.1107					LinkCompareLessEqual:
.1107	fa		plx				plx
.1108	5a		phy			phy
.1109	20 3d 21	jsr $213d		jsr	CompareLessEqual
.110c	7a		ply			ply
.110d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1110					LinkFloatIntegerPartDown:
.1110	fa		plx				plx
.1111	5a		phy			phy
.1112	20 c7 22	jsr $22c7		jsr	FloatIntegerPartDown
.1115	7a		ply			ply
.1116	4c 4f 08	jmp $084f			jmp 	NextCommand
.1119					LinkFloatSquareRoot:
.1119	fa		plx				plx
.111a	5a		phy			phy
.111b	20 b3 29	jsr $29b3		jsr	FloatSquareRoot
.111e	b0 04		bcs $1124		bcs	MapRangeError
.1120	7a		ply			ply
.1121	4c 4f 08	jmp $084f			jmp 	NextCommand
.1124					MapRangeError:
.1124	4c f4 1e	jmp $1ef4		jmp	ErrorV_range
.1127					DivZeroError:
.1127	4c 7d 1f	jmp $1f7d		jmp	ErrorV_divzero
.112a					LinkFloatLogarithm:
.112a	fa		plx				plx
.112b	5a		phy			phy
.112c	20 bd 28	jsr $28bd		jsr	FloatLogarithm
.112f	b0 f3		bcs $1124		bcs	MapRangeError
.1131	7a		ply			ply
.1132	4c 4f 08	jmp $084f			jmp 	NextCommand
.1135					LinkFloatExponent:
.1135	fa		plx				plx
.1136	5a		phy			phy
.1137	20 ba 27	jsr $27ba		jsr	FloatExponent
.113a	7a		ply			ply
.113b	4c 4f 08	jmp $084f			jmp 	NextCommand
.113e					LinkFloatCosine:
.113e	fa		plx				plx
.113f	5a		phy			phy
.1140	20 ae 27	jsr $27ae		jsr	FloatCosine
.1143	7a		ply			ply
.1144	4c 4f 08	jmp $084f			jmp 	NextCommand
.1147					LinkFloatSine:
.1147	fa		plx				plx
.1148	5a		phy			phy
.1149	20 4e 29	jsr $294e		jsr	FloatSine
.114c	7a		ply			ply
.114d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1150					LinkFloatTangent:
.1150	fa		plx				plx
.1151	5a		phy			phy
.1152	20 bf 29	jsr $29bf		jsr	FloatTangent
.1155	7a		ply			ply
.1156	4c 4f 08	jmp $084f			jmp 	NextCommand
.1159					LinkFloatArcTan:
.1159	fa		plx				plx
.115a	5a		phy			phy
.115b	20 93 26	jsr $2693		jsr	FloatArcTan
.115e	b0 c4		bcs $1124		bcs	MapRangeError
.1160	7a		ply			ply
.1161	4c 4f 08	jmp $084f			jmp 	NextCommand
.1164					LinkFloatCompare:
.1164	fa		plx				plx
.1165	5a		phy			phy
.1166	20 4d 21	jsr $214d		jsr	FloatCompare
.1169	7a		ply			ply
.116a	4c 4f 08	jmp $084f			jmp 	NextCommand
.116d					LinkDivideInt32:
.116d	fa		plx				plx
.116e	5a		phy			phy
.116f	20 db 21	jsr $21db		jsr	DivideInt32
.1172	b0 b0		bcs $1124		bcs	MapRangeError
.1174	7a		ply			ply
.1175	4c 4f 08	jmp $084f			jmp 	NextCommand
.1178					StackSaveCurrentPosition:
.1178	20 cb 08	jsr $08cb			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.117b	5a		phy				phy
.117c	a0 02		ldy #$02			ldy 	#2
.117e	a5 28		lda $28				lda 	codePtr
.1180	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1182	c8		iny				iny
.1183	a5 29		lda $29				lda 	codePtr+1
.1185	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1187	7a		ply				ply
.1188	60		rts				rts
.1189					StackLoadCurrentPosition:
.1189	a0 02		ldy #$02			ldy 	#2
.118b	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.118d	85 28		sta $28				sta 	codePtr
.118f	c8		iny				iny
.1190	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1192	85 29		sta $29				sta 	codePtr+1
.1194	a0 00		ldy #$00			ldy 	#0
.1196	60		rts				rts
.1197					XCommandMouse:
.1197	fa		plx				plx
.1198	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; mouse control.
.119b	ca		dex				dex
.119c	da		phx				phx
.119d	5a		phy				phy
.119e	48		pha				pha
.119f	38		sec				sec 								; get screen resolution
.11a0	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.11a3	68		pla				pla
.11a4	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.11a7	7a		ply				ply
.11a8	fa		plx				plx
.11a9	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ac					XUnaryMB:
.11ac	fa		plx				plx
.11ad	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11b0	a5 30		lda $30				lda 	zTemp2
.11b2	e8		inx				inx
.11b3	20 6a 26	jsr $266a			jsr 	FloatSetByte
.11b6	4c 4f 08	jmp $084f			jmp 	NextCommand
.11b9					XUnaryMX:
.11b9	fa		plx				plx
.11ba	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11bd	a5 2c		lda $2c				lda 	zTemp0
.11bf	e8		inx				inx
.11c0	20 6a 26	jsr $266a			jsr 	FloatSetByte
.11c3	a5 2d		lda $2d				lda 	zTemp0+1
.11c5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11c7	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ca					XUnaryMY:
.11ca	fa		plx				plx
.11cb	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11ce	a5 2e		lda $2e				lda 	zTemp1
.11d0	e8		inx				inx
.11d1	20 6a 26	jsr $266a			jsr 	FloatSetByte
.11d4	a5 2f		lda $2f				lda 	zTemp1+1
.11d6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11d8	4c 4f 08	jmp $084f			jmp 	NextCommand
.11db					XUnaryMouseCommon:
.11db	da		phx				phx
.11dc	5a		phy				phy
.11dd	a2 2c		ldx #$2c			ldx 	#zTemp0
.11df	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.11e2	85 30		sta $30				sta 	zTemp2
.11e4	7a		ply				ply
.11e5	fa		plx				plx
.11e6	60		rts				rts
.11e7					NegateTOS:
.11e7	fa		plx				plx
.11e8	20 2a 26	jsr $262a			jsr 	FloatNegate
.11eb	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ee					CommandNewLine:
.11ee	fa		plx				plx
.11ef	9c 6a 05	stz $056a			stz 	stringInitialised
.11f2	a2 ff		ldx #$ff			ldx 	#$FF
.11f4	4c 4f 08	jmp $084f			jmp 	NextCommand
.11f7					CommandXNext:
.11f7	fa		plx				plx
.11f8					_CNRetry:
.11f8	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.11fa	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.11fd	20 cb 08	jsr $08cb			jsr 	FixUpY 						; so we can use Y
.1200	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.1202	35 4a		and $4a,x			and 	NSMantissa1,x
.1204	c9 ff		cmp #$ff			cmp 	#$FF
.1206	f0 16		beq $121e			beq 	_CNNoIndexVariable
.1208	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.120a	a0 05		ldy #$05			ldy 	#5
.120c	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.120e	d0 07		bne $1217			bne 	_CNNIndexFail
.1210	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1212	c8		iny				iny
.1213	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.1215	f0 07		beq $121e			beq 	_CNNoIndexVariable
.1217					_CNNIndexFail:
.1217	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.1219	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close this frame
.121c	80 da		bra $11f8			bra 	_CNRetry
.121e					_CNNoIndexVariable:
.121e	ca		dex				dex
.121f	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.1221	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1223	29 40		and #$40			and 	#$40	 					; bit 6
.1225	d0 55		bne $127c			bne 	_CNOptimisedNext
.1227	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1229	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.122b	48		pha				pha
.122c	85 2c		sta $2c				sta 	zTemp0
.122e	c8		iny				iny
.122f	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1231	18		clc				clc
.1232	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1235	48		pha				pha
.1236	85 2d		sta $2d				sta 	zTemp0+1
.1238	20 f0 14	jsr $14f0			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.123b	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.123d	e8		inx				inx
.123e	20 bf 12	jsr $12bf			jsr 	CopyOffsetYToTOS
.1241	20 8c 20	jsr $208c			jsr 	FloatAdd
.1244	68		pla				pla 								; restore address
.1245	85 2d		sta $2d				sta 	zTemp0+1
.1247	68		pla				pla
.1248	85 2c		sta $2c				sta 	zTemp0
.124a	20 cb 1a	jsr $1acb			jsr 	WriteFloatZTemp0Sub			; write float.
.124d	e8		inx				inx  								; recover written
.124e	e8		inx				inx 								; load offset
.124f	a0 0d		ldy #$0d			ldy 	#13
.1251	20 bf 12	jsr $12bf			jsr 	CopyOffsetYToTOS
.1254	20 4d 21	jsr $214d			jsr 	FloatCompare 				; and compare the floats.
.1257	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1258	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.125a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.125c	30 08		bmi $1266			bmi 	_CNDownStep
.125e	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1260	c9 01		cmp #$01			cmp 	#1 							; gone higher
.1262	f0 10		beq $1274			beq 	_CNExitFor 					; if so exit the loop
.1264	80 06		bra $126c			bra 	_CNLoopBack
.1266					_CNDownStep:
.1266	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1268	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.126a	f0 08		beq $1274			beq 	_CNExitFor
.126c					_CNLoopBack:
.126c	20 89 11	jsr $1189			jsr 	StackLoadCurrentPosition 	; loop back
.126f	a0 00		ldy #$00			ldy 	#0
.1271	4c 4f 08	jmp $084f			jmp 	NextCommand
.1274					_CNExitFor:
.1274	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; remove the frame and exit
.1277	a0 00		ldy #$00			ldy 	#0
.1279	4c 4f 08	jmp $084f			jmp 	NextCommand
.127c					_CNOptimisedNext:
.127c	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.127e	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1280	85 2c		sta $2c				sta 	zTemp0
.1282	c8		iny				iny
.1283	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1285	18		clc				clc
.1286	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1289	85 2d		sta $2d				sta 	zTemp0+1
.128b	a0 07		ldy #$07			ldy 	#7 							; STEP value
.128d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.128f	a0 ff		ldy #$ff			ldy 	#$FF
.1291	18		clc				clc
.1292					_CNOIncrement:
.1292	c8		iny				iny
.1293	71 2c		adc ($2c),y			adc 	(zTemp0),y
.1295	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1297	f0 f9		beq $1292			beq 	_CNOIncrement
.1299	18		clc				clc
.129a	a5 24		lda $24				lda 	runtimeStackPtr
.129c	69 0d		adc #$0d			adc 	#13
.129e	85 2e		sta $2e				sta 	zTemp1
.12a0	a5 25		lda $25				lda 	runtimeStackPtr+1
.12a2	69 00		adc #$00			adc 	#0
.12a4	85 2f		sta $2f				sta 	zTemp1+1
.12a6	a0 00		ldy #$00			ldy 	#0
.12a8	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.12aa	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.12ac	c8		iny				iny
.12ad	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.12af	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12b1	c8		iny				iny
.12b2	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.12b4	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12b6	c8		iny				iny
.12b7	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.12b9	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12bb	90 b7		bcc $1274			bcc	 	_CNExitFor
.12bd	80 ad		bra $126c			bra 	_CNLoopBack
.12bf					CopyOffsetYToTOS:
.12bf	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.12c3	c8		iny				iny
.12c4	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12c8	c8		iny				iny
.12c9	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12cb	95 56		sta $56,x			sta 	NSMantissa2,x
.12cd	c8		iny				iny
.12ce	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d0	95 62		sta $62,x			sta 	NSMantissa3,x
.12d2	c8		iny				iny
.12d3	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d5	95 6e		sta $6e,x			sta 	NSExponent,x
.12d7	c8		iny				iny
.12d8	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12da	95 32		sta $32,x			sta 	NSStatus,x
.12dc	60		rts				rts
.12dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.12e0					NotTOS:
.12e0	fa		plx				plx
.12e1	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.12e4	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.12e6	74 62		stz $62,x			stz 	NSMantissa3,x
.12e8	20 2a 26	jsr $262a			jsr 	FloatNegate		 			; negate
.12eb	e8		inx				inx 								; and subtract 1.
.12ec	a9 01		lda #$01			lda 	#1
.12ee	20 6a 26	jsr $266a			jsr 	FloatSetByte
.12f1	20 86 20	jsr $2086			jsr 	FloatSubtract
.12f4					_NotTOSSkip:
.12f4	4c 4f 08	jmp $084f			jmp 	NextCommand
.12f7					CommandXOn:
.12f7	fa		plx				plx
.12f8	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.12fb	8d 5e 04	sta $045e			sta 	onCount 					; save it.
.12fe	20 cb 08	jsr $08cb			jsr 	FixUpY 						; Y = 0
.1301					_CONFind:
.1301	ce 5e 04	dec $045e			dec 	onCount 					; reached zero, do this one
.1304	f0 0b		beq $1311			beq 	_CONFound
.1306	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1307	c8		iny				iny
.1308	c8		iny				iny
.1309	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.130b	c8		iny				iny
.130c	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.130e	f0 f1		beq $1301			beq 	_CONFind
.1310	88		dey				dey 								; point to character after last GOTO/GOSUB
.1311					_CONFound:
.1311	4c 4f 08	jmp $084f			jmp 	NextCommand
.1314					CommandMoreOn:
.1314	fa		plx				plx
.1315	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1316	c8		iny				iny
.1317	c8		iny				iny
.1318	4c 4f 08	jmp $084f			jmp 	NextCommand
.045e					onCount:
>045e							.fill 	1
.131b					UnaryPeek:
.131b	fa		plx				plx
.131c	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.131f	da		phx				phx
.1320	5a		phy				phy
.1321	a6 2c		ldx $2c				ldx 	zTemp0
.1323	a4 2d		ldy $2d				ldy 	zTemp0+1
.1325	20 65 1c	jsr $1c65			jsr 	XPeekMemory
.1328	7a		ply				ply
.1329	fa		plx				plx
.132a	20 6a 26	jsr $266a			jsr 	FloatSetByte
.132d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1330					CommandPOKE:
.1330	fa		plx				plx
.1331	da		phx				phx 								; save XY
.1332	5a		phy				phy
.1333	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1336	48		pha				pha
.1337	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1339	a8		tay				tay
.133a	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.133c	aa		tax				tax
.133d	68		pla				pla
.133e	20 51 1c	jsr $1c51			jsr 	XPokeMemory
.1341	7a		ply				ply 								; restore YX and drop 2
.1342	fa		plx				plx
.1343	ca		dex				dex
.1344	ca		dex				dex
.1345	4c 4f 08	jmp $084f			jmp 	NextCommand
.1348					UnaryPos:
.1348	fa		plx				plx
.1349	20 e4 1b	jsr $1be4			jsr 	XGetHPos
.134c	20 6a 26	jsr $266a			jsr 	FloatSetByte
.134f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1352					GetChannel:
.1352	fa		plx				plx
.1353	ad 5f 04	lda $045f			lda 	currentChannel
.1356	e8		inx				inx
.1357	20 6a 26	jsr $266a			jsr 	FloatSetByte
.135a	4c 4f 08	jmp $084f			jmp 	NextCommand
.135d					SetChannel:
.135d	fa		plx				plx
.135e	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.1361	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1363	8d 5f 04	sta $045f			sta 	currentChannel
.1366	ca		dex				dex
.1367	4c 4f 08	jmp $084f			jmp 	NextCommand
.136a					SetDefaultChannel:
.136a	9c 5f 04	stz $045f			stz 	currentChannel
.136d	60		rts				rts
.136e					VectorPrintCharacter:
.136e	da		phx				phx
.136f	ae 5f 04	ldx $045f			ldx 	currentChannel
.1372	20 8f 1c	jsr $1c8f			jsr 	XPrintCharacterToChannel
.1375	fa		plx				plx
.1376	60		rts				rts
.1377					VectorGetCharacter:
.1377	da		phx				phx
.1378	ae 5f 04	ldx $045f			ldx 	currentChannel
.137b	20 c8 1b	jsr $1bc8			jsr 	XGetCharacterFromChannel
.137e	fa		plx				plx
.137f	60		rts				rts
.045f					currentChannel:
>045f							.fill 	1
.1380					PrintNumber:
.1380	fa		plx				plx
.1381	a9 07		lda #$07			lda 	#7
.1383	20 50 25	jsr $2550			jsr 	FloatToString 				; to number in decimal buffer
.1386	ca		dex				dex 								; drop
.1387	da		phx				phx
.1388	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.138a					_PNLoop:
.138a	bd 98 05	lda $0598,x			lda 	decimalBuffer,x
.138d	20 6e 13	jsr $136e			jsr 	VectorPrintCharacter
.1390	e8		inx				inx
.1391	bd 98 05	lda $0598,x			lda	 	decimalBuffer,x
.1394	d0 f4		bne $138a			bne 	_PNLoop
.1396	a9 20		lda #$20			lda 	#32 						; trailing space
.1398	20 6e 13	jsr $136e			jsr 	VectorPrintCharacter
.139b	fa		plx				plx
.139c	4c 4f 08	jmp $084f			jmp 	NextCommand
.139f					PrintString:
.139f	fa		plx				plx
.13a0	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.13a2	85 2c		sta $2c				sta 	zTemp0
.13a4	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.13a6	85 2d		sta $2d				sta 	zTemp0+1
.13a8	ca		dex				dex 								; drop
.13a9	da		phx				phx
.13aa	5a		phy				phy
.13ab	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.13ad	aa		tax				tax
.13ae	a0 01		ldy #$01			ldy 	#1 							; Y = position
.13b0					_PSLoop:
.13b0	e0 00		cpx #$00			cpx 	#0 							; complete ?
.13b2	f0 09		beq $13bd			beq 	_PSExit
.13b4	ca		dex				dex 								; dec count
.13b5	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.13b7	20 6e 13	jsr $136e			jsr 	VectorPrintCharacter
.13ba	c8		iny				iny
.13bb	80 f3		bra $13b0			bra 	_PSLoop
.13bd					_PSExit:
.13bd	7a		ply				ply
.13be	fa		plx				plx
.13bf	4c 4f 08	jmp $084f			jmp 	NextCommand
.13c2					CommandPushN:
.13c2	fa		plx				plx
.13c3	e8		inx				inx 								; next slot on stack
.13c4	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.13c6	95 6e		sta $6e,x			sta 	NSExponent,x
.13c8	c8		iny				iny
.13c9	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.13cb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13cd	c8		iny				iny
.13ce	b1 28		lda ($28),y			lda 	(codePtr),y
.13d0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13d2	c8		iny				iny
.13d3	b1 28		lda ($28),y			lda 	(codePtr),y
.13d5	95 56		sta $56,x			sta 	NSMantissa2,x
.13d7	c8		iny				iny
.13d8	b1 28		lda ($28),y			lda 	(codePtr),y
.13da	48		pha				pha
.13db	29 7f		and #$7f			and 	#$7F
.13dd	95 62		sta $62,x			sta 	NSMantissa3,x
.13df	68		pla				pla 								; sign in mantissa3:7
.13e0	29 80		and #$80			and 	#$80
.13e2	95 32		sta $32,x			sta 	NSStatus,x
.13e4	c8		iny				iny
.13e5	4c 4f 08	jmp $084f			jmp 	NextCommand
.13e8					CommandPushS:
.13e8	fa		plx				plx
.13e9	e8		inx				inx 								; next slot on stack
.13ea	18		clc				clc
.13eb	98		tya				tya
.13ec	65 28		adc $28				adc 	codePtr 					; the string is inline
.13ee	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13f0	a5 29		lda $29				lda 	codePtr+1
.13f2	69 00		adc #$00			adc 	#0
.13f4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13f6	74 56		stz $56,x			stz 	NSMantissa2,x
.13f8	74 62		stz $62,x			stz 	NSMantissa3,x
.13fa	a9 40		lda #$40			lda 	#NSSString
.13fc	95 32		sta $32,x			sta 	NSStatus,x
.13fe	98		tya				tya 								; string length +1 added to Y
.13ff	38		sec				sec
.1400	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.1402	a8		tay				tay
.1403	4c 4f 08	jmp $084f			jmp 	NextCommand
.1406					CommandXRead:
.1406	fa		plx				plx
.1407	5a		phy				phy 								; save Y
.1408	20 39 14	jsr $1439			jsr 	ReadStringToBuffer 			; read element into buffer
.140b	e8		inx				inx									; space on stack
.140c	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.140e	85 2c		sta $2c				sta 	0+zTemp0
.1410	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.1412	85 2d		sta $2d				sta 	1+zTemp0
.1414	20 58 19	jsr $1958			jsr 	ValEvaluateZTemp0
.1417	b0 04		bcs $141d			bcs 	_CRError 					; failed
.1419	7a		ply				ply 								; restore Y
.141a	4c 4f 08	jmp $084f			jmp 	NextCommand
.141d					_CRError:
.141d	4c 04 1f	jmp $1f04		jmp	ErrorV_value
.1420					CommandReadString:
.1420	fa		plx				plx
.1421	5a		phy				phy 								; save Y
.1422	20 39 14	jsr $1439			jsr 	ReadStringToBuffer 			; read text
.1425	e8		inx				inx 								; make space on stack
.1426	20 68 26	jsr $2668			jsr 	FloatSetZero 				; store as string on stack
.1429	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.142b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.142d	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.142f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1431	a9 40		lda #$40			lda 	#NSSString
.1433	95 32		sta $32,x			sta 	NSStatus,x
.1435	7a		ply				ply 								; restore Y
.1436	4c 4f 08	jmp $084f			jmp 	NextCommand
.1439					ReadStringToBuffer:
.1439	a9 cc		lda #$cc			lda 	#((ReadBumpNext) & $FF)
.143b	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.143e	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.1440	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.1443	a9 9f		lda #$9f			lda 	#((ReadLookNext) & $FF)
.1445	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.1448	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.144a	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.144d					GetStringToBuffer:
.144d	20 9c 14	jsr $149c			jsr		GetLookNext 				; skip all leading spaces.
.1450	f0 44		beq $1496			beq 	_RBError 					; end of data
.1452	b0 f9		bcs $144d			bcs 	GetStringToBuffer 			; switched to new data line.
.1454	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1456	b0 05		bcs $145d			bcs 	_RBNoSpace
.1458	20 99 14	jsr $1499			jsr 	GetBumpNext 				; consume space and loop round.
.145b	80 f0		bra $144d			bra 	GetStringToBuffer
.145d					_RBNoSpace:
.145d	9c 61 04	stz $0461			stz 	ReadBufferSize 				; empty the buffer.
.1460	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.1462	d0 08		bne $146c			bne 	_RBCommaSep
.1464	8d 60 04	sta $0460			sta 	ReadSep 					; use as a seperator
.1467	20 99 14	jsr $1499			jsr 	GetBumpNext 				; consume the '"'
.146a	80 05		bra $1471			bra 	_RBGetText
.146c					_RBCommaSep:
.146c	a9 2c		lda #$2c			lda 	#","						; get till comma
.146e	8d 60 04	sta $0460			sta 	ReadSep
.1471					_RBGetText:
.1471	20 9c 14	jsr $149c			jsr 	GetLookNext 				; what follows
.1474	b0 18		bcs $148e			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.1476	20 99 14	jsr $1499			jsr 	GetBumpNext 				; consume it whatever
.1479	cd 60 04	cmp $0460			cmp 	ReadSep 					; if found the seperator.
.147c	f0 10		beq $148e			beq 	_RBEndGet 					; exit after consumption
.147e	da		phx				phx
.147f	ae 61 04	ldx $0461			ldx 	ReadBufferSize 				; copy into buffer.
.1482	ee 61 04	inc $0461			inc 	ReadBufferSize
.1485	9d 62 04	sta $0462,x			sta 	ReadBuffer,x
.1488	9e 63 04	stz $0463,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.148b	fa		plx				plx
.148c	80 e3		bra $1471			bra 	_RBGetText
.148e					_RBEndGet:
.148e	c9 22		cmp #$22			cmp 	#'"'
.1490	d0 03		bne $1495			bne 	_RBNotQuote
.1492	20 99 14	jsr $1499			jsr 	GetBumpNext
.1495					_RBNotQuote:
.1495	60		rts				rts
.1496					_RBError:
.1496	4c b9 1f	jmp $1fb9		jmp	ErrorV_data
.1499					GetBumpNext:
.1499	6c 61 05	jmp ($0561)			jmp 	(ReadBumpNextVec)
.149c					GetLookNext:
.149c	6c 63 05	jmp ($0563)			jmp 	(ReadLookNextVec)
.149f					ReadLookNext:
.149f	ad 65 05	lda $0565			lda 	dataRemaining 				; any data remaining
.14a2	f0 04		beq $14a8			beq 	_RLNFindData
.14a4	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.14a6	18		clc				clc
.14a7	60		rts				rts
.14a8					_RLNFindData:
.14a8	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.14aa	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.14ac	f0 1a		beq $14c8			beq 	_RLNNoData
.14ae	c9 cf		cmp #$cf			cmp 	#PCD_CMD_DATA 				; Found DATA
.14b0	f0 05		beq $14b7			beq 	_RLNHaveData
.14b2					_RLNNext:
.14b2	20 37 20	jsr $2037			jsr 	MoveObjectForward			; else scan forward.
.14b5	80 f1		bra $14a8			bra 	_RLNFindData
.14b7					_RLNHaveData:
.14b7	a0 01		ldy #$01			ldy 	#1 							; get length
.14b9	b1 2a		lda ($2a),y			lda 	(objPtr),y
.14bb	f0 f5		beq $14b2			beq 	_RLNNext 					; skip if DATA alone
.14bd	20 cc 14	jsr $14cc			jsr 	ReadBumpNext 				; advance by two
.14c0	20 cc 14	jsr $14cc			jsr 	ReadBumpNext
.14c3	8d 65 05	sta $0565			sta 	dataRemaining 				; set data left count.
.14c6	38		sec				sec
.14c7	60		rts				rts
.14c8					_RLNNoData:
.14c8	a9 00		lda #$00			lda 	#0
.14ca	38		sec				sec
.14cb	60		rts				rts
.14cc					ReadBumpNext:
.14cc	e6 2a		inc $2a				inc 	objPtr
.14ce	d0 02		bne $14d2			bne 	_RBNSkip
.14d0	e6 2b		inc $2b				inc 	objPtr+1
.14d2					_RBNSkip:
.14d2	ce 65 05	dec $0565			dec 	dataRemaining
.14d5	60		rts				rts
.0460					ReadSep:
>0460							.fill 	1
.0461					ReadBufferSize:
>0461							.fill 	1
.0462					ReadBuffer:
>0462							.fill 	255
.0561					ReadBumpNextVec:
>0561							.fill 	2
.0563					ReadLookNextVec:
>0563							.fill 	2
.14d6					ReadFloatCommand:
.14d6	fa		plx				plx
.14d7	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14d9	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14db	88		dey				dey 								; get the upper 3 bits
.14dc	b1 28		lda ($28),y			lda 	(codePtr),y
.14de	29 07		and #$07			and 	#7
.14e0	c8		iny				iny
.14e1	c8		iny				iny
.14e2	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14e4	2a		rol a				rol 	a 							; carry will be clear.
.14e5	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14e8	85 2d		sta $2d				sta 	zTemp0+1
.14ea	20 f0 14	jsr $14f0			jsr 	ReadFloatZTemp0Sub
.14ed	4c 4f 08	jmp $084f			jmp 	NextCommand
.14f0					ReadFloatZTemp0Sub:
.14f0	5a		phy				phy 								; start write
.14f1	a0 01		ldy #$01			ldy 	#1
.14f3	e8		inx				inx
.14f4	b2 2c		lda ($2c)			lda 	(zTemp0)
.14f6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.14f8	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14fa	95 4a		sta $4a,x			sta 	NSMantissa1,x
.14fc	c8		iny				iny
.14fd	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14ff	95 56		sta $56,x			sta 	NSMantissa2,x
.1501	c8		iny				iny
.1502	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1504	95 62		sta $62,x			sta 	NSMantissa3,x
.1506	c8		iny				iny
.1507	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1509	95 6e		sta $6e,x			sta 	NSExponent,x
.150b	c8		iny				iny
.150c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.150e	95 32		sta $32,x			sta 	NSStatus,x
.1510	7a		ply				ply
.1511	60		rts				rts
.1512					ReadIntegerCommand:
.1512	fa		plx				plx
.1513	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1515	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1517	88		dey				dey 								; get the upper 3 bits
.1518	b1 28		lda ($28),y			lda 	(codePtr),y
.151a	29 07		and #$07			and 	#7
.151c	c8		iny				iny
.151d	c8		iny				iny
.151e	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1520	2a		rol a				rol 	a 							; carry will be clear.
.1521	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1524	85 2d		sta $2d				sta 	zTemp0+1
.1526	20 2c 15	jsr $152c			jsr 	ReadIntegerZTemp0Sub
.1529	4c 4f 08	jmp $084f			jmp 	NextCommand
.152c					ReadIntegerZTemp0Sub:
.152c	5a		phy				phy 								; start write
.152d	a0 01		ldy #$01			ldy 	#1
.152f	e8		inx				inx 								; prepare
.1530	74 56		stz $56,x			stz 	NSMantissa2,x
.1532	74 62		stz $62,x			stz 	NSMantissa3,x
.1534	74 6e		stz $6e,x			stz 	NSExponent,x
.1536	74 32		stz $32,x			stz 	NSStatus,x
.1538	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.153a	30 08		bmi $1544			bmi 	_RIZNegative
.153c	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.153e	b2 2c		lda ($2c)			lda 	(zTemp0)
.1540	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1542	7a		ply				ply
.1543	60		rts				rts
.1544					_RIZNegative:
.1544	38		sec				sec 								; -ve read
.1545	a9 00		lda #$00			lda 	#0
.1547	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.1549	95 3e		sta $3e,x			sta 	NSMantissa0,x
.154b	a9 00		lda #$00			lda 	#0
.154d	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.154f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1551	a9 80		lda #$80			lda 	#$80
.1553	95 32		sta $32,x			sta 	NSStatus,x
.1555	7a		ply				ply
.1556	60		rts				rts
.1557					ReadStringCommand:
.1557	fa		plx				plx
.1558	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.155a	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.155c	88		dey				dey 								; get the upper 3 bits
.155d	b1 28		lda ($28),y			lda 	(codePtr),y
.155f	29 07		and #$07			and 	#7
.1561	c8		iny				iny
.1562	c8		iny				iny
.1563	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1565	2a		rol a				rol 	a 							; carry will be clear.
.1566	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1569	85 2d		sta $2d				sta 	zTemp0+1
.156b	20 71 15	jsr $1571			jsr 	ReadStringZTemp0Sub
.156e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1571					ReadStringZTemp0Sub:
.1571	5a		phy				phy 								; start write
.1572	e8		inx				inx 								; prepare
.1573	74 56		stz $56,x			stz 	NSMantissa2,x
.1575	74 62		stz $62,x			stz 	NSMantissa3,x
.1577	74 6e		stz $6e,x			stz 	NSExponent,x
.1579	a9 40		lda #$40			lda 	#NSSString
.157b	74 32		stz $32,x			stz 	NSStatus,x
.157d	18		clc				clc
.157e	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.1580	69 02		adc #$02			adc 	#2 							; this points to actual data
.1582	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.1584	a0 01		ldy #$01			ldy 	#1
.1586	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1588	69 00		adc #$00			adc 	#0
.158a	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.158c	d0 08		bne $1596			bne 	_RSZNoDefault 				; if read $00 use a default value.
.158e	a9 98		lda #$98			lda 	#_RSZNull & $FF
.1590	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1592	a9 15		lda #$15			lda 	#_RSZNull >> 8
.1594	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1596					_RSZNoDefault:
.1596	7a		ply				ply
.1597	60		rts				rts
.1598					_RSZNull:
>1598	00						.byte 	0
.1599					CommandRestore:
.1599	fa		plx				plx
.159a	20 a0 15	jsr $15a0			jsr 	RestoreCode
.159d	4c 4f 08	jmp $084f			jmp 	NextCommand
.15a0					RestoreCode:
.15a0	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.15a3	85 2b		sta $2b				sta 	objPtr+1
.15a5	64 2a		stz $2a				stz 	objPtr
.15a7	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15aa	60		rts				rts
.0565					dataRemaining:
>0565							.fill 	1		 					; 0 if not in data statement
.15ab					UnaryRND:
.15ab	fa		plx				plx
.15ac	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.15ae	10 17		bpl $15c7			bpl 	_URNoSeed
.15b0	20 bd 23	jsr $23bd			jsr 	FloatNormalise 				; some float value
.15b3	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.15b5	8d 66 05	sta $0566			sta 	randomSeed+0
.15b8	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15ba	8d 67 05	sta $0567			sta 	randomSeed+1
.15bd	b5 56		lda $56,x			lda 	NSMantissa2,x
.15bf	8d 68 05	sta $0568			sta 	randomSeed+2
.15c2	b5 62		lda $62,x			lda 	NSMantissa3,x
.15c4	8d 69 05	sta $0569			sta 	randomSeed+3
.15c7					_URNoSeed:
.15c7	20 e9 15	jsr $15e9			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.15ca	ad 66 05	lda $0566			lda 	randomSeed+0
.15cd	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15cf	ad 67 05	lda $0567			lda 	randomSeed+1
.15d2	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15d4	ad 68 05	lda $0568			lda 	randomSeed+2
.15d7	95 56		sta $56,x			sta 	NSMantissa2,x
.15d9	ad 69 05	lda $0569			lda 	randomSeed+3
.15dc	29 7f		and #$7f			and 	#$7F
.15de	95 62		sta $62,x			sta 	NSMantissa3,x
.15e0	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.15e2	95 6e		sta $6e,x			sta 	NSExponent,x
.15e4	74 32		stz $32,x			stz 	NSStatus,x
.15e6	4c 4f 08	jmp $084f			jmp 	NextCommand
.15e9					RandomNumberGenerator:
.15e9	5a		phy				phy
.15ea	ad 66 05	lda $0566			lda 	randomSeed+0 				; check if zero
.15ed	0d 67 05	ora $0567			ora 	randomSeed+1
.15f0	0d 68 05	ora $0568			ora 	randomSeed+2
.15f3	0d 69 05	ora $0569			ora 	randomSeed+3
.15f6	d0 07		bne $15ff			bne 	_RNGNoSeed
.15f8	ce 69 05	dec $0569			dec 	randomSeed+3 				; if so tweak and flog
.15fb	a0 64		ldy #$64			ldy 	#100
.15fd	80 05		bra $1604			bra 	_RNGLoop
.15ff					_RNGNoSeed:
.15ff	a0 08		ldy #$08			ldy 	#8
.1601	ad 66 05	lda $0566			lda 	randomSeed+0
.1604					_RNGLoop:
.1604	0a		asl a				asl		a
.1605	2e 67 05	rol $0567			rol 	randomSeed+1
.1608	2e 68 05	rol $0568			rol 	randomSeed+2
.160b	2e 69 05	rol $0569			rol 	randomSeed+3
.160e	90 02		bcc $1612			bcc		_RNGSkip
.1610	49 c5		eor #$c5			eor 	#$C5
.1612					_RNGSkip:
.1612	88		dey				dey
.1613	d0 ef		bne $1604			bne		_RNGLoop
.1615	8d 66 05	sta $0566			sta 	randomSeed+0
.1618	7a		ply				ply
.1619	60		rts				rts
.0566					randomSeed:
>0566							.fill 	4
.161a					StringConcatenate:
.161a	fa		plx				plx
.161b	ca		dex				dex
.161c	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.161e	85 2e		sta $2e				sta 	zTemp1
.1620	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1622	85 2f		sta $2f				sta 	zTemp1+1
.1624	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.1626	85 30		sta $30				sta 	zTemp2
.1628	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.162a	85 31		sta $31				sta 	zTemp2+1
.162c	18		clc				clc 								; work out total length
.162d	b2 2e		lda ($2e)			lda 	(zTemp1)
.162f	72 30		adc ($30)			adc 	(zTemp2)
.1631	b0 18		bcs $164b			bcs 	_BCLength 					; more than 255 characters.
.1633	48		pha				pha 								; save total
.1634	20 11 17	jsr $1711			jsr 	StringAllocTemp 			; space for result.
.1637	68		pla				pla 								; write total as first.
.1638	92 22		sta ($22)			sta 	(zsTemp)
.163a	20 4e 16	jsr $164e			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.163d	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.163f	85 2e		sta $2e				sta 	zTemp1
.1641	a5 31		lda $31				lda 	zTemp2+1
.1643	85 2f		sta $2f				sta 	zTemp1+1
.1645	20 4e 16	jsr $164e			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1648	4c 4f 08	jmp $084f			jmp 	NextCommand
.164b					_BCLength:
.164b	4c f4 1e	jmp $1ef4		jmp	ErrorV_range
.164e					_BCCopyZTemp1:
.164e	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.1650	f0 15		beq $1667			beq 	_BCCExit 					; none.
.1652	da		phx				phx 								; save XY
.1653	5a		phy				phy
.1654	aa		tax				tax 								; count in X.
.1655	a0 01		ldy #$01			ldy 	#1
.1657					_BCCLoop:
.1657	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1659	d0 02		bne $165d			bne 	_BCCNoCarry
.165b	e6 23		inc $23				inc 	zsTemp+1
.165d					_BCCNoCarry:
.165d	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.165f	92 22		sta ($22)			sta 	(zsTemp)
.1661	c8		iny				iny
.1662	ca		dex				dex 								; X times
.1663	d0 f2		bne $1657			bne 	_BCCLoop
.1665	7a		ply				ply 								; restore YX
.1666	fa		plx				plx
.1667					_BCCExit:
.1667	60		rts				rts
.1668					XRuntimeSetup:
.1668	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.166a	8d 6d 05	sta $056d	 		sta 	ramBank
.166d	8d 6e 05	sta $056e	 		sta 	romBank
.1670	60		rts				rts
.1671					SignTOS:
.1671	fa		plx				plx
.1672	20 8a 26	jsr $268a			jsr 	FloatIsZero 				; if zero
.1675	f0 0f		beq $1686			beq 	_SGZero  					; return Int Zero
.1677	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.1679	48		pha				pha
.167a	a9 01		lda #$01			lda 	#1 							; set result to 1
.167c	20 6a 26	jsr $266a			jsr 	FloatSetByte
.167f	68		pla				pla
.1680	29 80		and #$80			and		#$80 						; copy the sign byte out
.1682	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.1684	80 03		bra $1689			bra 	_SGExit
.1686					_SGZero:
.1686	20 68 26	jsr $2668			jsr 	FloatSetZero
.1689					_SGExit:
.1689	4c 4f 08	jmp $084f			jmp 	NextCommand
.168c					CommandShift:
.168c	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.168e	c8		iny				iny
.168f	0a		asl a				asl 	a 							; double into X
.1690	aa		tax				tax
.1691	7c 3c 1a	jmp ($1a3c,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.1694					PrintTab:
.1694	fa		plx				plx
.1695	20 e4 1b	jsr $1be4			jsr 	XGetHPos
.1698					_PTMod10:
.1698	38		sec				sec
.1699	e9 0a		sbc #$0a			sbc 	#10
.169b	b0 fb		bcs $1698			bcs 	_PTMod10
.169d	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.169f	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.16a0	80 15		bra $16b7			bra 	PrintSpaceLoop
.16a2					PrintPos:
.16a2	fa		plx				plx
.16a3	20 e4 1b	jsr $1be4			jsr		XGetHPos 					; get current position
.16a6	85 2c		sta $2c				sta 	zTemp0
.16a8	38		sec				sec 								; calculate spaces required
.16a9	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16ab	ca		dex				dex
.16ac	e5 2c		sbc $2c				sbc 	zTemp0
.16ae	b0 07		bcs $16b7			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.16b0	4c 4f 08	jmp $084f			jmp 	NextCommand
.16b3					PrintSpace:
.16b3	fa		plx				plx
.16b4	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16b6	ca		dex				dex
.16b7					PrintSpaceLoop:
.16b7	c9 00		cmp #$00			cmp 	#0
.16b9	f0 0a		beq $16c5			beq 	_PSExit
.16bb	48		pha				pha
.16bc	a9 20		lda #$20			lda 	#" "
.16be	20 6e 13	jsr $136e			jsr 	VectorPrintCharacter
.16c1	68		pla				pla
.16c2	3a		dec a				dec 	a
.16c3	80 f2		bra $16b7			bra 	PrintSpaceLoop
.16c5					_PSExit:
.16c5	4c 4f 08	jmp $084f			jmp 	NextCommand
.16c8					CommandStop:
.16c8	fa		plx				plx
.16c9	4c a6 1f	jmp $1fa6		jmp	ErrorV_stop
.16cc					Unary_Str:
.16cc	fa		plx				plx
.16cd	5a		phy				phy
.16ce	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.16d0	20 50 25	jsr $2550			jsr 	FloatToString 				; do the conversion.
.16d3	a9 21		lda #$21			lda		#33 						; create buffer
.16d5	20 11 17	jsr $1711			jsr 	StringAllocTemp 			; allocate memory
.16d8	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.16da					_USCopy:
.16da	b9 97 05	lda $0597,y			lda 	decimalBuffer-1,y
.16dd	f0 05		beq $16e4			beq 	_USExit
.16df	91 22		sta ($22),y			sta 	(zsTemp),y
.16e1	c8		iny				iny
.16e2	80 f6		bra $16da			bra 	_USCopy
.16e4					_USExit:
.16e4	98		tya				tya
.16e5	3a		dec a				dec 	a
.16e6	92 22		sta ($22)			sta 	(zsTemp)
.16e8	7a		ply				ply
.16e9	4c 4f 08	jmp $084f			jmp 	NextCommand
.16ec					StringInitialise:
.16ec	48		pha				pha
.16ed	ad 6a 05	lda $056a			lda 	stringInitialised 			; already done
.16f0	d0 11		bne $1703			bne 	_SIExit
.16f2	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.16f5	8d 6b 05	sta $056b			sta 	stringTempPointer
.16f8	ad 03 04	lda $0403			lda 	stringHighMemory+1
.16fb	3a		dec a				dec 	a
.16fc	3a		dec a				dec 	a
.16fd	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.1700	ce 6a 05	dec $056a			dec 	stringInitialised 			; set the initialised flag.
.1703					_SIExit:
.1703	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.1705	1a		inc a				inc 	a
.1706	1a		inc a				inc 	a
.1707	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.170a	b0 02		bcs $170e			bcs 	_SIMemory
.170c	68		pla				pla
.170d	60		rts				rts
.170e					_SIMemory:
.170e	4c ff 1f	jmp $1fff		jmp	ErrorV_memory
.1711					StringAllocTemp:
.1711	20 ec 16	jsr $16ec			jsr 	StringInitialise 			; check it is initialised.
.1714	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.1716	18		clc				clc
.1717	6d 6b 05	adc $056b			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.171a	8d 6b 05	sta $056b			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.171d	85 22		sta $22				sta 	zsTemp
.171f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1721	ad 6c 05	lda $056c			lda 	stringTempPointer+1
.1724	69 ff		adc #$ff			adc 	#$FF
.1726	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.1729	85 23		sta $23				sta 	zsTemp+1
.172b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.172d	74 56		stz $56,x			stz 	NSMantissa2,x
.172f	74 62		stz $62,x			stz 	NSMantissa3,x
.1731	a9 00		lda #$00			lda 	#0 							; clear string.
.1733	92 22		sta ($22)			sta 	(zsTemp)
.1735	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1737	95 32		sta $32,x			sta 	NSStatus,x
.1739	60		rts				rts
.173a					StringWriteChar:
.173a	5a		phy				phy
.173b	48		pha				pha
.173c	b2 22		lda ($22)			lda 	(zsTemp)
.173e	1a		inc a				inc 	a
.173f	92 22		sta ($22)			sta 	(zsTemp)
.1741	a8		tay				tay
.1742	68		pla				pla
.1743	91 22		sta ($22),y			sta 	(zsTemp),y
.1745	7a		ply				ply
.1746	60		rts				rts
.056a					stringInitialised:
>056a							.fill 	1
.056b					stringTempPointer:
>056b							.fill 	2
.1747					Unary_Left:
.1747	fa		plx				plx
.1748	5a		phy				phy
.1749	18		clc				clc 								; only one parameter
.174a	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the length of the string.
.174d	48		pha				pha
.174e	ca		dex				dex
.174f	a9 00		lda #$00			lda 	#0 							; push the start position.
.1751	48		pha				pha
.1752	20 8a 17	jsr $178a			jsr 	UnarySStringToZTemp0
.1755	80 3c		bra $1793			bra 	SubstringMain 				; stack now points to the string to slice.
.1757					Unary_Right:
.1757	fa		plx				plx
.1758	5a		phy				phy
.1759	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.175b	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the right length of the string.
.175e	48		pha				pha
.175f	ca		dex				dex
.1760	20 8a 17	jsr $178a			jsr 	UnarySStringToZTemp0
.1763	68		pla				pla 								; this is the right requirement
.1764	38		sec				sec
.1765	49 ff		eor #$ff			eor 	#$FF
.1767	72 2c		adc ($2c)			adc 	(zTemp0)
.1769	b0 02		bcs $176d			bcs 	_URHaveCount
.176b	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.176d					_URHaveCount:
.176d	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.176f	5a		phy				phy
.1770	48		pha				pha 								; start position
.1771	80 20		bra $1793			bra 	SubstringMain
.1773					Unary_Mid:
.1773	fa		plx				plx
.1774	5a		phy				phy
.1775	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the length of the string required.
.1778	48		pha				pha
.1779	ca		dex				dex
.177a	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; put the start position.
.177d	f0 08		beq $1787			beq 	_UMError
.177f	3a		dec a				dec 	a
.1780	48		pha				pha
.1781	ca		dex				dex
.1782	20 8a 17	jsr $178a			jsr 	UnarySStringToZTemp0
.1785	80 0c		bra $1793			bra 	SubstringMain 				; stack now points to the string to slice.
.1787					_UMError:
.1787	4c f4 1e	jmp $1ef4		jmp	ErrorV_range
.178a					UnarySStringToZTemp0:
.178a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.178c	85 2c		sta $2c				sta 	zTemp0
.178e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1790	85 2d		sta $2d				sta 	zTemp0+1
.1792	60		rts				rts
.1793					SubstringMain:
.1793	68		pla				pla 								; get the start offset
.1794	7a		ply				ply 								; get the count to do.
.1795	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.1797	b0 38		bcs $17d1			bcs 	_SSReturnNull
.1799	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.179b	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.179d	18		clc				clc
.179e	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.17a0	b0 06		bcs $17a8			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.17a2	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.17a4	f0 04		beq $17aa			beq 	_SMIsOkay
.17a6	90 02		bcc $17aa			bcc 	_SMIsOkay
.17a8					_SMTruncateToEnd:
.17a8	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.17aa					_SMIsOkay:
.17aa	85 2f		sta $2f				sta 	zTemp1+1
.17ac	38		sec				sec		 							; work out size
.17ad	a5 2f		lda $2f				lda 	zTemp1+1
.17af	e5 2e		sbc $2e				sbc 	zTemp1
.17b1	f0 1e		beq $17d1			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.17b3	20 11 17	jsr $1711			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.17b6	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.17b8					_SMCopy:
.17b8	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.17ba	f0 11		beq $17cd			beq 	_SMExit
.17bc	c8		iny				iny 								; bump and
.17bd	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.17bf	5a		phy				phy
.17c0	48		pha				pha
.17c1	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.17c3	1a		inc a				inc 	a
.17c4	a8		tay				tay
.17c5	92 22		sta ($22)			sta 	(zsTemp)
.17c7	68		pla				pla 								; write character out
.17c8	91 22		sta ($22),y			sta 	(zsTemp),y
.17ca	7a		ply				ply 								; restore Y
.17cb	80 eb		bra $17b8			bra 	_SMCopy
.17cd					_SMExit:
.17cd	7a		ply				ply
.17ce	4c 4f 08	jmp $084f			jmp 	NextCommand
.17d1					_SSReturnNull:
.17d1	a9 e3		lda #$e3			lda 	#SSRNull & $FF 				; set up mantissa
.17d3	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17d5	a9 17		lda #$17			lda 	#SSRNull >> 8
.17d7	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17d9	74 56		stz $56,x			stz 	NSMantissa2,x
.17db	74 62		stz $62,x			stz 	NSMantissa3,x
.17dd	a9 40		lda #$40			lda 	#NSSString
.17df	95 32		sta $32,x			sta 	NSStatus,x
.17e1	80 ea		bra $17cd			bra 	_SMExit
.17e3					SSRNull:
>17e3	00 00						.word 	0
.17e5					CommandSwap:
.17e5	fa		plx				plx
.17e6	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17e8	48		pha				pha
.17e9	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.17eb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17ed	68		pla				pla
.17ee	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.17f0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17f2	48		pha				pha
.17f3	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.17f5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17f7	68		pla				pla
.17f8	95 49		sta $49,x			sta 	NSMantissa1-1,x
.17fa	b5 56		lda $56,x			lda 	NSMantissa2,x
.17fc	48		pha				pha
.17fd	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.17ff	95 56		sta $56,x			sta 	NSMantissa2,x
.1801	68		pla				pla
.1802	95 55		sta $55,x			sta 	NSMantissa2-1,x
.1804	b5 62		lda $62,x			lda 	NSMantissa3,x
.1806	48		pha				pha
.1807	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.1809	95 62		sta $62,x			sta 	NSMantissa3,x
.180b	68		pla				pla
.180c	95 61		sta $61,x			sta 	NSMantissa3-1,x
.180e	b5 6e		lda $6e,x			lda 	NSExponent,x
.1810	48		pha				pha
.1811	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.1813	95 6e		sta $6e,x			sta 	NSExponent,x
.1815	68		pla				pla
.1816	95 6d		sta $6d,x			sta 	NSExponent-1,x
.1818	b5 32		lda $32,x			lda 	NSStatus,x
.181a	48		pha				pha
.181b	b5 31		lda $31,x			lda 	NSStatus-1,x
.181d	95 32		sta $32,x			sta 	NSStatus,x
.181f	68		pla				pla
.1820	95 31		sta $31,x			sta 	NSStatus-1,x
.1822	4c 4f 08	jmp $084f			jmp 	NextCommand
.1825					CommandSYS:
.1825	fa		plx				plx
.1826	da		phx				phx 								; save XY
.1827	5a		phy				phy
.1828	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.182b	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.182d	85 2d		sta $2d				sta 	zTemp0+1
.182f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1831	85 2c		sta $2c				sta 	zTemp0
.1833	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1836	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.1839	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.183c	48		pha				pha
.183d	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.1840	28		plp				plp
.1841	20 58 18	jsr $1858			jsr 	_CSZTemp0
.1844	08		php				php
.1845	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1848	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.184b	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.184e	68		pla				pla
.184f	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.1852	7a		ply				ply 								; restore YX and drop 2
.1853	fa		plx				plx
.1854	ca		dex				dex
.1855	4c 4f 08	jmp $084f			jmp 	NextCommand
.1858					_CSZTemp0:
.1858	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.185b					TimeTOS:
.185b	fa		plx				plx
.185c	20 b6 18	jsr $18b6			jsr 	TIPushClock 				; push clock to TOS
.185f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1862					TimeString:
.1862	fa		plx				plx
.1863	20 b6 18	jsr $18b6			jsr 	TIPushClock 				; push clock to TOS
.1866	20 8b 18	jsr $188b			jsr 	_TSDivMod60 				; result in seconds
.1869	20 8b 18	jsr $188b			jsr 	_TSDivMod60 				; seconds
.186c	48		pha				pha
.186d	20 8b 18	jsr $188b			jsr 	_TSDivMod60 				; minutes
.1870	48		pha				pha
.1871	a9 18		lda #$18			lda 	#24 						; hours
.1873	20 8d 18	jsr $188d			jsr 	_TSDivModA
.1876	48		pha				pha
.1877	a9 06		lda #$06			lda 	#6
.1879	20 11 17	jsr $1711			jsr 	StringAllocTemp
.187c	68		pla				pla
.187d	20 9d 18	jsr $189d			jsr 	_TSWriteDecimal
.1880	68		pla				pla
.1881	20 9d 18	jsr $189d			jsr 	_TSWriteDecimal
.1884	68		pla				pla
.1885	20 9d 18	jsr $189d			jsr 	_TSWriteDecimal
.1888	4c 4f 08	jmp $084f			jmp 	NextCommand
.188b					_TSDivMod60:
.188b	a9 3c		lda #$3c			lda 	#60
.188d					_TSDivModA:
.188d	e8		inx				inx
.188e	20 6a 26	jsr $266a			jsr 	FloatSetByte
.1891	ca		dex				dex
.1892	20 fe 21	jsr $21fe			jsr 	Int32Divide
.1895	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.1897	48		pha				pha
.1898	20 ed 21	jsr $21ed			jsr 	NSMCopyPlusTwoToZero
.189b	68		pla				pla
.189c	60		rts				rts
.189d					_TSWriteDecimal:
.189d	da		phx				phx
.189e	a2 30		ldx #$30			ldx 	#'0'
.18a0					_TSWDLoop:
.18a0	c9 0a		cmp #$0a			cmp 	#10
.18a2	90 05		bcc $18a9			bcc 	_TSWDEnd
.18a4	e9 0a		sbc #$0a			sbc 	#10
.18a6	e8		inx				inx
.18a7	80 f7		bra $18a0			bra 	_TSWDLoop
.18a9					_TSWDEnd:
.18a9	48		pha				pha
.18aa	8a		txa				txa
.18ab	20 3a 17	jsr $173a			jsr 	StringWriteChar
.18ae	68		pla				pla
.18af	09 30		ora #$30			ora 	#'0'
.18b1	20 3a 17	jsr $173a			jsr 	StringWriteChar
.18b4	fa		plx				plx
.18b5	60		rts				rts
.18b6					TIPushClock:
.18b6	5a		phy				phy
.18b7	e8		inx				inx 								; push 0 on the stack
.18b8	20 68 26	jsr $2668			jsr 	FloatSetZero
.18bb	da		phx				phx
.18bc	20 af 1c	jsr $1caf			jsr 	XReadClock 					; read time into YXA
.18bf	86 2c		stx $2c				stx 	zTemp0
.18c1	fa		plx				plx
.18c2	95 3e		sta $3e,x			sta 	NSMantissa0,x
.18c4	a5 2c		lda $2c				lda 	zTemp0
.18c6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.18c8	98		tya				tya
.18c9	95 56		sta $56,x			sta 	NSMantissa2,x
.18cb	7a		ply				ply
.18cc	60		rts				rts
.18cd					CommandTIWrite:
.18cd	fa		plx				plx
.18ce	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.18d0	85 22		sta $22				sta 	zsTemp
.18d2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.18d4	85 23		sta $23				sta 	zsTemp+1
.18d6	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.18d8	c9 06		cmp #$06			cmp 	#6
.18da	d0 59		bne $1935			bne 	_CTIWError
.18dc	20 68 26	jsr $2668			jsr 	FloatSetZero
.18df	20 01 19	jsr $1901			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.18e2	20 01 19	jsr $1901			jsr 	_CTIWDigitPair
.18e5	20 01 19	jsr $1901			jsr 	_CTIWDigitPair
.18e8	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.18ea	20 2c 19	jsr $192c			jsr 	_CTIWMultiply
.18ed	da		phx				phx
.18ee	5a		phy				phy
.18ef	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.18f1	48		pha				pha
.18f2	b5 56		lda $56,x			lda 	NSMantissa2,x
.18f4	a8		tay				tay
.18f5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.18f7	fa		plx				plx
.18f8	20 b3 1c	jsr $1cb3			jsr 	XWriteClock 				; update the clock.
.18fb	7a		ply				ply
.18fc	fa		plx				plx
.18fd	ca		dex				dex 								; throw result.
.18fe	4c 4f 08	jmp $084f			jmp 	NextCommand
.1901					_CTIWDigitPair:
.1901	a9 06		lda #$06			lda 	#6 							; x 6
.1903	20 2c 19	jsr $192c			jsr 	_CTIWMultiply
.1906	20 12 19	jsr $1912			jsr 	_CTIWAddDigit 				; add digit
.1909	a9 0a		lda #$0a			lda 	#10 						; x 10
.190b	20 2c 19	jsr $192c			jsr 	_CTIWMultiply
.190e	20 12 19	jsr $1912			jsr 	_CTIWAddDigit 				; add digit
.1911	60		rts				rts
.1912					_CTIWAddDigit:
.1912	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.1914	d0 02		bne $1918			bne 	_CTIWASkip
.1916	e6 23		inc $23				inc 	zsTemp+1
.1918					_CTIWASkip:
.1918	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.191a	38		sec				sec
.191b	e9 30		sbc #$30			sbc 	#"0"
.191d	90 16		bcc $1935			bcc 	_CTIWError
.191f	c9 0a		cmp #$0a			cmp 	#9+1
.1921	b0 12		bcs $1935			bcs 	_CTIWError
.1923	e8		inx				inx 								; store at +1
.1924	20 6a 26	jsr $266a			jsr 	FloatSetByte
.1927	ca		dex				dex
.1928	20 f4 23	jsr $23f4			jsr 	FloatAddTopTwoStack
.192b	60		rts				rts
.192c					_CTIWMultiply:
.192c	e8		inx				inx
.192d	20 6a 26	jsr $266a			jsr 	FloatSetByte
.1930	ca		dex				dex
.1931	20 75 23	jsr $2375			jsr 	FloatMultiplyShort
.1934	60		rts				rts
.1935					_CTIWError:
.1935	4c 04 1f	jmp $1f04		jmp	ErrorV_value
.1938					UnaryUsr:
.1938	fa		plx				plx
.1939	5a		phy				phy
.193a	20 41 19	jsr $1941			jsr 	_UUCallVector
.193d	7a		ply				ply
.193e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1941					_UUCallVector:
.1941	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.1944					ValUnary:
.1944	fa		plx				plx
.1945	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1947	85 2c		sta $2c				sta 	zTemp0
.1949	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.194b	85 2d		sta $2d				sta 	zTemp0+1
.194d	20 58 19	jsr $1958			jsr 	ValEvaluateZTemp0
.1950	b0 03		bcs $1955			bcs 	_VUError 					; couldn't convert
.1952	4c 4f 08	jmp $084f			jmp 	NextCommand
.1955					_VUError:
.1955	4c 04 1f	jmp $1f04		jmp	ErrorV_value
.1958					ValEvaluateZTemp0:
.1958	5a		phy				phy
.1959	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.195b	f0 22		beq $197f			beq 	_VMCFail2
.195d	a0 00		ldy #$00			ldy 	#0 							; start position
.195f					_VMCSpaces:
.195f	c8		iny				iny 								; skip leading spaces
.1960	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1962	c9 20		cmp #$20			cmp 	#" "
.1964	f0 f9		beq $195f			beq 	_VMCSpaces
.1966	48		pha				pha 								; save first character
.1967	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.1969	d0 01		bne $196c			bne 	_VMCStart
.196b	c8		iny				iny 								; skip over - if so.
.196c					_VMCStart:
.196c	38		sec				sec 								; initialise first time round.
.196d					_VMCNext:
.196d	98		tya				tya 								; reached end of string
.196e	3a		dec a				dec 	a
.196f	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.1971	f0 0f		beq $1982			beq 	_VMCSuccess 				; successful.
.1973	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.1975	c8		iny				iny
.1976	20 4c 24	jsr $244c			jsr 	FloatEncode 				; send it to the number-builder
.1979	90 03		bcc $197e			bcc 	_VMCFail 					; if failed, give up.
.197b	18		clc				clc 								; next time round, countinue
.197c	80 ef		bra $196d			bra 	_VMCNext
.197e					_VMCFail:
.197e	68		pla				pla
.197f					_VMCFail2:
.197f	7a		ply				ply
.1980	38		sec				sec
.1981	60		rts				rts
.1982					_VMCSuccess:
.1982	a9 00		lda #$00			lda 	#0 							; construct final
.1984	20 4c 24	jsr $244c			jsr 	FloatEncode 				; by sending a duff value.
.1987	68		pla				pla 								; if it was -ve
.1988	c9 2d		cmp #$2d			cmp 	#"-"
.198a	d0 03		bne $198f			bne 	_VMCNotNegative
.198c	20 2a 26	jsr $262a			jsr		FloatNegate 				; negate it.
.198f					_VMCNotNegative:
.198f	7a		ply				ply
.1990	18		clc				clc
.1991	60		rts				rts
.1992					VectorTable:
>1992	a9 10					.word	LinkFloatAdd             ; $80 +
>1994	b2 10					.word	LinkFloatSubtract        ; $81 -
>1996	bb 10					.word	LinkFloatMultiply        ; $82 *
>1998	c4 10					.word	LinkFloatDivide          ; $83 /
>199a	cf 10					.word	LinkFloatPower           ; $84 ^
>199c	f2 08					.word	BinaryAnd                ; $85 and
>199e	f6 08					.word	BinaryOr                 ; $86 or
>19a0	da 10					.word	LinkCompareGreater       ; $87 >
>19a2	e3 10					.word	LinkCompareEqual         ; $88 =
>19a4	ec 10					.word	LinkCompareLess          ; $89 <
>19a6	f5 10					.word	LinkCompareGreaterEqual  ; $8a >=
>19a8	fe 10					.word	LinkCompareNotEqual      ; $8b <>
>19aa	07 11					.word	LinkCompareLessEqual     ; $8c <=
>19ac	da 08					.word	AbsoluteTOS              ; $8d abs
>19ae	2d 09					.word	ArrayConvert             ; $8e array
>19b0	d5 09					.word	UnaryAsc                 ; $8f asc
>19b2	f0 09					.word	CommandAssert            ; $90 assert
>19b4	31 0a					.word	Unary16Bin               ; $91 bin$
>19b6	5b 0a					.word	PrintCharacterX          ; $92 print.chr
>19b8	65 0a					.word	UnaryChr                 ; $93 chr$
>19ba	ca 0a					.word	CompareStrings           ; $94 s.cmp
>19bc	b6 0c					.word	CommandXFor              ; $95 for
>19be	79 0d					.word	UnaryFre                 ; $96 fre
>19c0	91 0d					.word	CommandXGet              ; $97 get
>19c2	b7 0d					.word	CommandReturn            ; $98 return
>19c4	f9 0d					.word	Command_PSET             ; $99 pset
>19c6	13 0e					.word	Command_LINE             ; $9a line
>19c8	28 0e					.word	Command_RECT             ; $9b rect
>19ca	37 0e					.word	Command_FRAME            ; $9c frame
>19cc	46 0e					.word	Command_CHAR             ; $9d char
>19ce	dd 0e					.word	Unary16Hex               ; $9e hex$
>19d0	84 0f					.word	CommandXInput            ; $9f input
>19d2	9b 0f					.word	CommandInputString       ; $a0 input$
>19d4	b4 0f					.word	CommandInputReset        ; $a1 input.start
>19d6	98 10					.word	UnaryLen                 ; $a2 len
>19d8	64 11					.word	LinkFloatCompare         ; $a3 f.cmp
>19da	6d 11					.word	LinkDivideInt32          ; $a4 int.div
>19dc	e7 11					.word	NegateTOS                ; $a5 negate
>19de	ee 11					.word	CommandNewLine           ; $a6 new.line
>19e0	f7 11					.word	CommandXNext             ; $a7 next
>19e2	e0 12					.word	NotTOS                   ; $a8 not
>19e4	f7 12					.word	CommandXOn               ; $a9 on
>19e6	14 13					.word	CommandMoreOn            ; $aa moreon
>19e8	1b 13					.word	UnaryPeek                ; $ab peek
>19ea	30 13					.word	CommandPOKE              ; $ac poke
>19ec	48 13					.word	UnaryPos                 ; $ad pos
>19ee	52 13					.word	GetChannel               ; $ae getchannel
>19f0	5d 13					.word	SetChannel               ; $af setchannel
>19f2	80 13					.word	PrintNumber              ; $b0 print.n
>19f4	9f 13					.word	PrintString              ; $b1 print.s
>19f6	06 14					.word	CommandXRead             ; $b2 read
>19f8	20 14					.word	CommandReadString        ; $b3 read$
>19fa	ab 15					.word	UnaryRND                 ; $b4 rnd
>19fc	1a 16					.word	StringConcatenate        ; $b5 concat
>19fe	71 16					.word	SignTOS                  ; $b6 sgn
>1a00	94 16					.word	PrintTab                 ; $b7 print.tab
>1a02	a2 16					.word	PrintPos                 ; $b8 print.pos
>1a04	b3 16					.word	PrintSpace               ; $b9 print.spc
>1a06	cc 16					.word	Unary_Str                ; $ba str$
>1a08	47 17					.word	Unary_Left               ; $bb left$
>1a0a	57 17					.word	Unary_Right              ; $bc right$
>1a0c	73 17					.word	Unary_Mid                ; $bd mid$
>1a0e	e5 17					.word	CommandSwap              ; $be swap
>1a10	5b 18					.word	TimeTOS                  ; $bf ti
>1a12	62 18					.word	TimeString               ; $c0 ti$
>1a14	38 19					.word	UnaryUsr                 ; $c1 usr
>1a16	44 19					.word	ValUnary                 ; $c2 val
>1a18	ab 1b					.word	CommandClose             ; $c3 close
>1a1a	bd 1b					.word	CommandExit              ; $c4 exit
>1a1c	c3 1b					.word	CommandDebug             ; $c5 debug
>1a1e	29 1c					.word	CommandXOpen             ; $c6 open
>1a20	bd 1c					.word	CommandScreen            ; $c7 screen
>1a22	a4 1e					.word	CommandVPOKE             ; $c8 vpoke
>1a24	c9 1e					.word	CommandVPEEK             ; $c9 vpeek
>1a26	8c 16					.word	CommandShift             ; $ca .shift
>1a28	9e 08					.word	PushByteCommand          ; $cb .byte
>1a2a	b1 08					.word	PushWordCommand          ; $cc .word
>1a2c	c2 13					.word	CommandPushN             ; $cd .float
>1a2e	e8 13					.word	CommandPushS             ; $ce .string
>1a30	52 0b					.word	CommandXData             ; $cf .data
>1a32	c8 0d					.word	CommandXGoto             ; $d0 .goto
>1a34	ab 0d					.word	CommandXGosub            ; $d1 .gosub
>1a36	dd 0d					.word	CommandGotoZ             ; $d2 .goto.z
>1a38	eb 0d					.word	CommandGotoNZ            ; $d3 .goto.nz
>1a3a	e0 08					.word	CommandVarSpace          ; $d4 .varspace
.1a3c					ShiftVectorTable:
>1a3c	7d 0a					.word	CommandClr               ; $ca80 clr
>1a3e	5b 0b					.word	CommandXDIM              ; $ca81 dim
>1a40	4c 0c					.word	CommandEnd               ; $ca82 end
>1a42	69 10					.word	UnaryJoy                 ; $ca83 joy
>1a44	10 11					.word	LinkFloatIntegerPartDown ; $ca84 int
>1a46	19 11					.word	LinkFloatSquareRoot      ; $ca85 sqr
>1a48	2a 11					.word	LinkFloatLogarithm       ; $ca86 log
>1a4a	35 11					.word	LinkFloatExponent        ; $ca87 exp
>1a4c	3e 11					.word	LinkFloatCosine          ; $ca88 cos
>1a4e	47 11					.word	LinkFloatSine            ; $ca89 sin
>1a50	50 11					.word	LinkFloatTangent         ; $ca8a tan
>1a52	59 11					.word	LinkFloatArcTan          ; $ca8b atn
>1a54	97 11					.word	XCommandMouse            ; $ca8c mouse
>1a56	ac 11					.word	XUnaryMB                 ; $ca8d mb
>1a58	b9 11					.word	XUnaryMX                 ; $ca8e mx
>1a5a	ca 11					.word	XUnaryMY                 ; $ca8f my
>1a5c	99 15					.word	CommandRestore           ; $ca90 restore
>1a5e	c8 16					.word	CommandStop              ; $ca91 stop
>1a60	25 18					.word	CommandSYS               ; $ca92 sys
>1a62	cd 18					.word	CommandTIWrite           ; $ca93 ti$.write
>1a64	9a 1a					.word	CommandXWAIT             ; $ca94 wait
>1a66	ee 1b					.word	X16I2CPoke               ; $ca95 i2cpoke
>1a68	0e 1c					.word	X16I2CPeek               ; $ca96 i2cpeek
>1a6a	79 1c					.word	CommandBank              ; $ca97 bank
>1a6c	cc 1c					.word	XCommandSleep            ; $ca98 sleep
>1a6e	f0 1c					.word	X16_Audio_FMINIT         ; $ca99 fminit
>1a70	fe 1c					.word	X16_Audio_FMNOTE         ; $ca9a fmnote
>1a72	10 1d					.word	X16_Audio_FMDRUM         ; $ca9b fmdrum
>1a74	22 1d					.word	X16_Audio_FMINST         ; $ca9c fminst
>1a76	34 1d					.word	X16_Audio_FMVIB          ; $ca9d fmvib
>1a78	46 1d					.word	X16_Audio_FMFREQ         ; $ca9e fmfreq
>1a7a	57 1d					.word	X16_Audio_FMVOL          ; $ca9f fmvol
>1a7c	69 1d					.word	X16_Audio_FMPAN          ; $caa0 fmpan
>1a7e	7b 1d					.word	X16_Audio_FMPLAY         ; $caa1 fmplay
>1a80	8c 1d					.word	X16_Audio_FMCHORD        ; $caa2 fmchord
>1a82	9d 1d					.word	X16_Audio_FMPOKE         ; $caa3 fmpoke
>1a84	af 1d					.word	X16_Audio_PSGINIT        ; $caa4 psginit
>1a86	bd 1d					.word	X16_Audio_PSGNOTE        ; $caa5 psgnote
>1a88	cf 1d					.word	X16_Audio_PSGVOL         ; $caa6 psgvol
>1a8a	e1 1d					.word	X16_Audio_PSGWAV         ; $caa7 psgwav
>1a8c	f3 1d					.word	X16_Audio_PSGFREQ        ; $caa8 psgfreq
>1a8e	04 1e					.word	X16_Audio_PSGPAN         ; $caa9 psgpan
>1a90	16 1e					.word	X16_Audio_PSGPLAY        ; $caaa psgplay
>1a92	27 1e					.word	X16_Audio_PSGCHORD       ; $caab psgchord
>1a94	38 1e					.word	CommandCls               ; $caac cls
>1a96	41 1e					.word	CommandLocate            ; $caad locate
>1a98	6b 1e					.word	CommandColor             ; $caae color
.1a9a					CommandXWAIT:
.1a9a	fa		plx				plx
.1a9b	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1a9d	85 2c		sta $2c				sta 	zTemp0
.1a9f	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1aa1	85 2d		sta $2d				sta 	zTemp0+1
.1aa3					_WaitLoop:
.1aa3	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1aa5	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1aa7	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1aa9	f0 f8		beq $1aa3			beq 	_WaitLoop 					; keep going if zero
.1aab	ca		dex				dex 								; drop 3.
.1aac	ca		dex				dex
.1aad	ca		dex				dex
.1aae	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ab1					WriteFloatCommand:
.1ab1	fa		plx				plx
.1ab2	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1ab4	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1ab6	88		dey				dey 								; get the upper 3 bits
.1ab7	b1 28		lda ($28),y			lda 	(codePtr),y
.1ab9	29 07		and #$07			and 	#7
.1abb	c8		iny				iny
.1abc	c8		iny				iny
.1abd	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1abf	2a		rol a				rol 	a 							; carry will be clear.
.1ac0	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1ac3	85 2d		sta $2d				sta 	zTemp0+1
.1ac5	20 cb 1a	jsr $1acb			jsr 	WriteFloatZTemp0Sub
.1ac8	4c 4f 08	jmp $084f			jmp 	NextCommand
.1acb					WriteFloatZTemp0Sub:
.1acb	5a		phy				phy 								; ldart write
.1acc	a0 01		ldy #$01			ldy 	#1
.1ace	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ad0	92 2c		sta ($2c)			sta 	(zTemp0)
.1ad2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ad4	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ad6	c8		iny				iny
.1ad7	b5 56		lda $56,x			lda 	NSMantissa2,x
.1ad9	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1adb	c8		iny				iny
.1adc	b5 62		lda $62,x			lda 	NSMantissa3,x
.1ade	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ae0	c8		iny				iny
.1ae1	b5 6e		lda $6e,x			lda 	NSExponent,x
.1ae3	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ae5	c8		iny				iny
.1ae6	b5 32		lda $32,x			lda 	NSStatus,x
.1ae8	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1aea	ca		dex				dex
.1aeb	7a		ply				ply
.1aec	60		rts				rts
.1aed					WriteIntegerCommand:
.1aed	fa		plx				plx
.1aee	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1af0	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1af2	88		dey				dey 								; get the upper 3 bits
.1af3	b1 28		lda ($28),y			lda 	(codePtr),y
.1af5	29 07		and #$07			and 	#7
.1af7	c8		iny				iny
.1af8	c8		iny				iny
.1af9	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1afb	2a		rol a				rol 	a 							; carry will be clear.
.1afc	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1aff	85 2d		sta $2d				sta 	zTemp0+1
.1b01	20 07 1b	jsr $1b07			jsr 	WriteIntegerZTemp0Sub
.1b04	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b07					WriteIntegerZTemp0Sub:
.1b07	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.1b0a	5a		phy				phy 								; start write
.1b0b	a0 01		ldy #$01			ldy 	#1
.1b0d	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1b0f	30 0b		bmi $1b1c			bmi 	_WIZNegative
.1b11	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1b13	92 2c		sta ($2c)			sta 	(zTemp0)
.1b15	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b17	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b19	7a		ply				ply
.1b1a	ca		dex				dex
.1b1b	60		rts				rts
.1b1c					_WIZNegative:
.1b1c	38		sec				sec 								; -ve read
.1b1d	a9 00		lda #$00			lda 	#0
.1b1f	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1b21	92 2c		sta ($2c)			sta 	(zTemp0)
.1b23	a9 00		lda #$00			lda 	#0
.1b25	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1b27	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b29	7a		ply				ply
.1b2a	ca		dex				dex
.1b2b	60		rts				rts
.1b2c					WriteStringCommand:
.1b2c	fa		plx				plx
.1b2d	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b2f	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b31	88		dey				dey 								; get the upper 3 bits
.1b32	b1 28		lda ($28),y			lda 	(codePtr),y
.1b34	29 07		and #$07			and 	#7
.1b36	c8		iny				iny
.1b37	c8		iny				iny
.1b38	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b3a	2a		rol a				rol 	a 							; carry will be clear.
.1b3b	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b3e	85 2d		sta $2d				sta 	zTemp0+1
.1b40	20 46 1b	jsr $1b46			jsr 	WriteStringZTemp0Sub
.1b43	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b46					WriteStringZTemp0Sub:
.1b46	5a		phy				phy
.1b47	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b49	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b4b	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b4d	f0 1e		beq $1b6d			beq 	_WSConcrete
.1b4f	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b51	85 2e		sta $2e				sta 	zTemp1
.1b53	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b55	85 2f		sta $2f				sta 	zTemp1+1
.1b57	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b59	85 30		sta $30				sta 	zTemp2
.1b5b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b5d	85 31		sta $31				sta 	zTemp2+1
.1b5f	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1b61	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1b63	b0 17		bcs $1b7c			bcs 	_WSCopy
.1b65	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1b67	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b69	09 80		ora #$80			ora 	#$80
.1b6b	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1b6d					_WSConcrete:
.1b6d	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1b6f	a8		tay				tay
.1b70	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b72	20 0c 0b	jsr $0b0c			jsr 	StringConcrete
.1b75	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1b77	98		tya				tya
.1b78	a0 01		ldy #$01			ldy 	#1
.1b7a	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b7c					_WSCopy
.1b7c	18		clc				clc  								; copy target+2 to zTemp2
.1b7d	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b7f	69 02		adc #$02			adc 	#2
.1b81	85 30		sta $30				sta 	zTemp2
.1b83	a0 01		ldy #$01			ldy 	#1
.1b85	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b87	69 00		adc #$00			adc 	#0
.1b89	85 31		sta $31				sta 	zTemp2+1
.1b8b	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1b8d	85 2e		sta $2e				sta 	zTemp1
.1b8f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b91	85 2f		sta $2f				sta 	zTemp1+1
.1b93	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1b95	a8		tay				tay
.1b96					_WSCopyLoop:
.1b96	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b98	91 30		sta ($30),y			sta 	(zTemp2),y
.1b9a	88		dey				dey
.1b9b	c0 ff		cpy #$ff			cpy 	#$FF
.1b9d	d0 f7		bne $1b96			bne 	_WSCopyLoop
.1b9f	ca		dex				dex
.1ba0	7a		ply				ply
.1ba1	60		rts				rts
.1ba2					XCheckStop:
.1ba2	20 e1 ff	jsr $ffe1			jsr 	$FFE1 						; check stop
.1ba5	f0 01		beq $1ba8			beq 	_XCSStop
.1ba7	60		rts				rts
.1ba8					_XCSStop:
.1ba8	4c 26 20	jmp $2026		jmp	ErrorV_break
.1bab					CommandClose:
.1bab	fa		plx				plx
.1bac	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; channel to close
.1baf	cd 5f 04	cmp $045f			cmp 	currentChannel 				; is it the current channel
.1bb2	d0 03		bne $1bb7			bne 	_CCNotCurrent
.1bb4	9c 5f 04	stz $045f			stz 	currentChannel 				; effectively disables CMD
.1bb7					_CCNotCurrent:
.1bb7	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1bba	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bbd					CommandExit:
.1bbd	fa		plx				plx
.1bbe	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1bc0	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1bc3					CommandDebug:
.1bc3	fa		plx				plx
>1bc4	db						.byte 	$DB 						; causes a break in the emulator
.1bc5	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bc8					XGetCharacterFromChannel:
.1bc8	da		phx				phx
.1bc9	5a		phy				phy
.1bca	e0 00		cpx #$00			cpx 	#0 							; is it default
.1bcc	d0 05		bne $1bd3			bne 	_XGetChannel
.1bce	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1bd1	80 08		bra $1bdb			bra 	_XGetChar
.1bd3					_XGetChannel:
.1bd3	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1bd6	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1bd9	d0 06		bne $1be1			bne 	_XGCError
.1bdb					_XGetChar:
.1bdb	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1bde	7a		ply				ply
.1bdf	fa		plx				plx
.1be0	60		rts				rts
.1be1					_XGCError:
.1be1	4c 10 20	jmp $2010		jmp	ErrorV_channel
.1be4					XGetHPos:
.1be4	da		phx				phx
.1be5	5a		phy				phy
.1be6	38		sec				sec
.1be7	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1bea	98		tya				tya
.1beb	7a		ply				ply
.1bec	fa		plx				plx
.1bed	60		rts				rts
.1bee					X16I2CPoke:
.1bee	fa		plx				plx
.1bef	5a		phy				phy
.1bf0	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; value
.1bf3	48		pha				pha
.1bf4	ca		dex				dex
.1bf5	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; register
.1bf8	48		pha				pha
.1bf9	ca		dex				dex
.1bfa	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; device
.1bfd	aa		tax				tax
.1bfe	7a		ply				ply
.1bff	68		pla				pla
.1c00	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1c03	b0 06		bcs $1c0b			bcs 	X16I2CError
.1c05	7a		ply				ply
.1c06	a2 ff		ldx #$ff			ldx 	#$FF
.1c08	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c0b					X16I2CError:
.1c0b	4c 10 20	jmp $2010		jmp	ErrorV_channel
.1c0e					X16I2CPeek:
.1c0e	fa		plx				plx
.1c0f	da		phx				phx
.1c10	5a		phy				phy
.1c11	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; register
.1c14	48		pha				pha
.1c15	ca		dex				dex
.1c16	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; device
.1c19	aa		tax				tax 								; X device
.1c1a	7a		ply				ply 								; Y register
.1c1b	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1c1e	b0 eb		bcs $1c0b			bcs 	X16I2CError
.1c20	7a		ply				ply 								; restore Y/X
.1c21	fa		plx				plx
.1c22	ca		dex				dex 								; drop TOS (register)
.1c23	20 6a 26	jsr $266a			jsr 	FloatSetByte 				; write read value to TOS.
.1c26	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c29					CommandXOpen:
.1c29	fa		plx				plx
.1c2a	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1c2c	85 2c		sta $2c				sta 	zTemp0
.1c2e	aa		tax				tax
.1c2f	a5 4d		lda $4d				lda 	NSMantissa1+3
.1c31	85 2d		sta $2d				sta 	zTemp0+1
.1c33	a8		tay				tay
.1c34	e8		inx				inx 								; XY points to first character
.1c35	d0 01		bne $1c38			bne 	_CONoCarry
.1c37	c8		iny				iny
.1c38					_CONoCarry:
.1c38	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c3a	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c3d	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c3f	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c41	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c43	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c46	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c49	b0 03		bcs $1c4e			bcs 	_COError
.1c4b	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c4e					_COError:
.1c4e	4c 10 20	jmp $2010		jmp	ErrorV_channel
.1c51					XPokeMemory:
.1c51	86 2c		stx $2c				stx 	zTemp0
.1c53	84 2d		sty $2d				sty 	zTemp0+1
.1c55	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c57	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c5a	e0 ff		cpx #$ff			cpx 	#$FF
.1c5c	f0 02		beq $1c60			beq 	_XPMNoSwitch
.1c5e	86 00		stx $00				stx 	SelectRAMBank
.1c60					_XPMNoSwitch:
.1c60	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1c62	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1c64					_XPMExit:
.1c64	60		rts				rts
.1c65					XPeekMemory:
.1c65	86 2c		stx $2c				stx 	zTemp0
.1c67	84 2d		sty $2d				sty 	zTemp0+1
.1c69	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c6b	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c6e	e0 ff		cpx #$ff			cpx 	#$FF
.1c70	f0 02		beq $1c74			beq 	_XPMNoSwitch
.1c72	86 00		stx $00				stx 	SelectRAMBank
.1c74					_XPMNoSwitch:
.1c74	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1c76	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1c78	60		rts				rts
.1c79					CommandBank:
.1c79	fa		plx				plx
.1c7a	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1c7c	8d 6d 05	sta $056d			sta 	ramBank 					; store & make current
.1c7f	85 00		sta $00				sta 	SelectRAMBank
.1c81	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1c83	c9 ff		cmp #$ff			cmp 	#$FF
.1c85	f0 03		beq $1c8a			beq 	_CBNoUpdate
.1c87	8d 6e 05	sta $056e			sta 	romBank 					; this doesn't set the hardware page.
.1c8a					_CBNoUpdate:
.1c8a	a2 ff		ldx #$ff			ldx 	#$FF
.1c8c	4c 4f 08	jmp $084f			jmp 	NextCommand
.056d					ramBank:
>056d							.fill 	1
.056e					romBank:
>056e							.fill 	1
.1c8f					XPrintCharacterToChannel:
.1c8f	48		pha				pha
.1c90	da		phx				phx
.1c91	5a		phy				phy
.1c92	48		pha				pha  								; save char
.1c93	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1c95	d0 05		bne $1c9c			bne 	_XPCNotDefault
.1c97	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1c9a	80 08		bra $1ca4			bra 	_XPCSend
.1c9c					_XPCNotDefault:
.1c9c	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1c9f	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1ca2	d0 08		bne $1cac			bne 	_XPCError
.1ca4					_XPCSend:
.1ca4	68		pla				pla 								; restore character
.1ca5	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1ca8	7a		ply				ply
.1ca9	fa		plx				plx
.1caa	68		pla				pla
.1cab	60		rts				rts
.1cac					_XPCError:
.1cac	4c 10 20	jmp $2010		jmp	ErrorV_channel
.1caf					XReadClock:
.1caf	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1cb2	60		rts				rts
.1cb3					XWriteClock:
.1cb3	48		pha				pha
.1cb4	da		phx				phx
.1cb5	5a		phy				phy
.1cb6	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1cb9	7a		ply				ply
.1cba	fa		plx				plx
.1cbb	68		pla				pla
.1cbc	60		rts				rts
.1cbd					CommandScreen:
.1cbd	fa		plx				plx
.1cbe	da		phx				phx
.1cbf	5a		phy				phy
.1cc0	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1cc3	18		clc				clc
.1cc4	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1cc7	7a		ply				ply
.1cc8	fa		plx				plx
.1cc9	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ccc					XCommandSleep:
.1ccc	fa		plx				plx
.1ccd	5a		phy				phy
.1cce	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.1cd1	ca		dex				dex
.1cd2	20 af 1c	jsr $1caf			jsr 	XReadClock 					; read clock to YXA
.1cd5	18		clc				clc 								; calculate end time in zTemp0
.1cd6	65 3e		adc $3e				adc 	NSMantissa0
.1cd8	85 2c		sta $2c				sta 	zTemp0
.1cda	8a		txa				txa
.1cdb	65 4a		adc $4a				adc 	NSMantissa1
.1cdd	85 2d		sta $2d				sta 	zTemp0+1
.1cdf					_XCWait:
.1cdf	20 af 1c	jsr $1caf			jsr 	XReadClock 					; and wait for it.
.1ce2	c5 2c		cmp $2c				cmp 	zTemp0
.1ce4	d0 f9		bne $1cdf			bne 	_XCWait
.1ce6	e4 2d		cpx $2d				cpx 	zTemp0+1
.1ce8	d0 f5		bne $1cdf			bne 	_XCWait
.1cea	a2 ff		ldx #$ff			ldx 	#$FF
.1cec	7a		ply				ply
.1ced	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cf0					X16_Audio_FMINIT:
.1cf0	fa		plx				plx
.1cf1	5a		phy			phy
.1cf2	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cf5	63 c0					.word	X16A_ym_init
>1cf7	0a					.byte	X16_AudioCodeBank
.1cf8	a2 ff		ldx #$ff		ldx	#$FF
.1cfa	7a		ply			ply
.1cfb	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cfe					X16_Audio_FMNOTE:
.1cfe	fa		plx				plx
.1cff	5a		phy			phy
.1d00	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d03	18		clc			clc
.1d04	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d07	03 c0					.word	X16A_bas_fmnote
>1d09	0a					.byte	X16_AudioCodeBank
.1d0a	a2 ff		ldx #$ff		ldx	#$FF
.1d0c	7a		ply			ply
.1d0d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d10					X16_Audio_FMDRUM:
.1d10	fa		plx				plx
.1d11	5a		phy			phy
.1d12	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d15	18		clc			clc
.1d16	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d19	6f c0					.word	X16A_ym_playdrum
>1d1b	0a					.byte	X16_AudioCodeBank
.1d1c	a2 ff		ldx #$ff		ldx	#$FF
.1d1e	7a		ply			ply
.1d1f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d22					X16_Audio_FMINST:
.1d22	fa		plx				plx
.1d23	5a		phy			phy
.1d24	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d27	38		sec			sec
.1d28	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d2b	69 c0					.word	X16A_ym_loadpatch
>1d2d	0a					.byte	X16_AudioCodeBank
.1d2e	a2 ff		ldx #$ff		ldx	#$FF
.1d30	7a		ply			ply
.1d31	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d34					X16_Audio_FMVIB:
.1d34	fa		plx				plx
.1d35	5a		phy			phy
.1d36	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d39	18		clc			clc
.1d3a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d3d	09 c0					.word	X16A_bas_fmvib
>1d3f	0a					.byte	X16_AudioCodeBank
.1d40	a2 ff		ldx #$ff		ldx	#$FF
.1d42	7a		ply			ply
.1d43	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d46					X16_Audio_FMFREQ:
.1d46	fa		plx				plx
.1d47	5a		phy			phy
.1d48	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1d4b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d4e	00 c0					.word	X16A_bas_fmfreq
>1d50	0a					.byte	X16_AudioCodeBank
.1d51	a2 ff		ldx #$ff		ldx	#$FF
.1d53	7a		ply			ply
.1d54	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d57					X16_Audio_FMVOL:
.1d57	fa		plx				plx
.1d58	5a		phy			phy
.1d59	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d5c	18		clc			clc
.1d5d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d60	75 c0					.word	X16A_ym_setatten
>1d62	0a					.byte	X16_AudioCodeBank
.1d63	a2 ff		ldx #$ff		ldx	#$FF
.1d65	7a		ply			ply
.1d66	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d69					X16_Audio_FMPAN:
.1d69	fa		plx				plx
.1d6a	5a		phy			phy
.1d6b	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d6e	18		clc			clc
.1d6f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d72	7e c0					.word	X16A_ym_setpan
>1d74	0a					.byte	X16_AudioCodeBank
.1d75	a2 ff		ldx #$ff		ldx	#$FF
.1d77	7a		ply			ply
.1d78	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d7b					X16_Audio_FMPLAY:
.1d7b	fa		plx				plx
.1d7c	5a		phy			phy
.1d7d	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1d80	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d83	06 c0					.word	X16A_bas_fmplaystring
>1d85	0a					.byte	X16_AudioCodeBank
.1d86	a2 ff		ldx #$ff		ldx	#$FF
.1d88	7a		ply			ply
.1d89	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d8c					X16_Audio_FMCHORD:
.1d8c	fa		plx				plx
.1d8d	5a		phy			phy
.1d8e	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1d91	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d94	8d c0					.word	X16A_bas_fmchordstring
>1d96	0a					.byte	X16_AudioCodeBank
.1d97	a2 ff		ldx #$ff		ldx	#$FF
.1d99	7a		ply			ply
.1d9a	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d9d					X16_Audio_FMPOKE:
.1d9d	fa		plx				plx
.1d9e	5a		phy			phy
.1d9f	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1da2	18		clc			clc
.1da3	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1da6	8a c0					.word	X16A_ym_write
>1da8	0a					.byte	X16_AudioCodeBank
.1da9	a2 ff		ldx #$ff		ldx	#$FF
.1dab	7a		ply			ply
.1dac	4c 4f 08	jmp $084f			jmp 	NextCommand
.1daf					X16_Audio_PSGINIT:
.1daf	fa		plx				plx
.1db0	5a		phy			phy
.1db1	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1db4	4b c0					.word	X16A_psg_init
>1db6	0a					.byte	X16_AudioCodeBank
.1db7	a2 ff		ldx #$ff		ldx	#$FF
.1db9	7a		ply			ply
.1dba	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dbd					X16_Audio_PSGNOTE:
.1dbd	fa		plx				plx
.1dbe	5a		phy			phy
.1dbf	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1dc2	18		clc			clc
.1dc3	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dc6	12 c0					.word	X16A_bas_psgnote
>1dc8	0a					.byte	X16_AudioCodeBank
.1dc9	a2 ff		ldx #$ff		ldx	#$FF
.1dcb	7a		ply			ply
.1dcc	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dcf					X16_Audio_PSGVOL:
.1dcf	fa		plx				plx
.1dd0	5a		phy			phy
.1dd1	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1dd4	18		clc			clc
.1dd5	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dd8	54 c0					.word	X16A_psg_setatten
>1dda	0a					.byte	X16_AudioCodeBank
.1ddb	a2 ff		ldx #$ff		ldx	#$FF
.1ddd	7a		ply			ply
.1dde	4c 4f 08	jmp $084f			jmp 	NextCommand
.1de1					X16_Audio_PSGWAV:
.1de1	fa		plx				plx
.1de2	5a		phy			phy
.1de3	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1de6	18		clc			clc
.1de7	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dea	15 c0					.word	X16A_bas_psgwav
>1dec	0a					.byte	X16_AudioCodeBank
.1ded	a2 ff		ldx #$ff		ldx	#$FF
.1def	7a		ply			ply
.1df0	4c 4f 08	jmp $084f			jmp 	NextCommand
.1df3					X16_Audio_PSGFREQ:
.1df3	fa		plx				plx
.1df4	5a		phy			phy
.1df5	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1df8	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dfb	0f c0					.word	X16A_bas_psgfreq
>1dfd	0a					.byte	X16_AudioCodeBank
.1dfe	a2 ff		ldx #$ff		ldx	#$FF
.1e00	7a		ply			ply
.1e01	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e04					X16_Audio_PSGPAN:
.1e04	fa		plx				plx
.1e05	5a		phy			phy
.1e06	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e09	18		clc			clc
.1e0a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e0d	5a c0					.word	X16A_psg_setpan
>1e0f	0a					.byte	X16_AudioCodeBank
.1e10	a2 ff		ldx #$ff		ldx	#$FF
.1e12	7a		ply			ply
.1e13	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e16					X16_Audio_PSGPLAY:
.1e16	fa		plx				plx
.1e17	5a		phy			phy
.1e18	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e1b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e1e	18 c0					.word	X16A_bas_psgplaystring
>1e20	0a					.byte	X16_AudioCodeBank
.1e21	a2 ff		ldx #$ff		ldx	#$FF
.1e23	7a		ply			ply
.1e24	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e27					X16_Audio_PSGCHORD:
.1e27	fa		plx				plx
.1e28	5a		phy			phy
.1e29	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e2c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e2f	90 c0					.word	X16A_bas_psgchordstring
>1e31	0a					.byte	X16_AudioCodeBank
.1e32	a2 ff		ldx #$ff		ldx	#$FF
.1e34	7a		ply			ply
.1e35	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e38					CommandCls:
.1e38	fa		plx				plx
.1e39	a9 93		lda #$93			lda 	#147
.1e3b	20 8f 1c	jsr $1c8f			jsr 	XPrintCharacterToChannel
.1e3e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e41					CommandLocate:
.1e41	fa		plx				plx
.1e42	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.1e45	ca		dex				dex
.1e46	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.1e49	ca		dex				dex
.1e4a	a9 13		lda #$13			lda 	#$13 						; home.
.1e4c	20 8f 1c	jsr $1c8f			jsr 	XPrintCharacterToChannel
.1e4f	a9 1d		lda #$1d			lda 	#$1D 						; do cursor rights
.1e51	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1e53	20 60 1e	jsr $1e60			jsr 	_CLOutputXA
.1e56	a9 11		lda #$11			lda 	#$11 						; do cursor downs.
.1e58	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e5a	20 60 1e	jsr $1e60			jsr 	_CLOutputXA
.1e5d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e60					_CLOutputXA:
.1e60	ca		dex				dex
.1e61	f0 07		beq $1e6a			beq 	_CLOExit
.1e63	30 05		bmi $1e6a			bmi 	_CLOExit
.1e65	20 8f 1c	jsr $1c8f			jsr 	XPrintCharacterToChannel
.1e68	80 f6		bra $1e60			bra 	_CLOutputXA
.1e6a					_CLOExit:
.1e6a	60		rts				rts
.1e6b					CommandColor:
.1e6b	fa		plx				plx
.1e6c	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.1e6f	ca		dex				dex
.1e70	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.1e73	ca		dex				dex
.1e74	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1e76	c9 ff		cmp #$ff			cmp 	#$FF
.1e78	f0 08		beq $1e82			beq 	_CCNoBGR 					; if so, change background
.1e7a	20 8a 1e	jsr $1e8a			jsr 	_CCSetColour
.1e7d	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1e7f	20 8f 1c	jsr $1c8f			jsr 	XPrintCharacterToChannel
.1e82					_CCNoBGR:
.1e82	a5 3e		lda $3e				lda 	NSMantissa0
.1e84	20 8a 1e	jsr $1e8a			jsr 	_CCSetColour
.1e87	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e8a					_CCSetColour:
.1e8a	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1e8c	aa		tax				tax
.1e8d	bd 94 1e	lda $1e94,x			lda 	_CCCommandTable,x
.1e90	20 8f 1c	jsr $1c8f			jsr 	XPrintCharacterToChannel
.1e93	60		rts				rts
.1e94					_CCCommandTable:
>1e94	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1e9c	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1ea4					CommandVPOKE:
.1ea4	fa		plx				plx
.1ea5	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; poke value
.1ea8	48		pha				pha
.1ea9	ca		dex				dex
.1eaa	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.1ead	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1eaf	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1eb2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1eb4	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1eb7	ca		dex				dex
.1eb8	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.1ebb	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1ebe	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1ec1	ca		dex				dex
.1ec2	68		pla				pla 								; poke value back
.1ec3	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1ec6	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ec9					CommandVPEEK:
.1ec9	fa		plx				plx
.1eca	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.1ecd	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ecf	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1ed2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ed4	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ed7	ca		dex				dex
.1ed8	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.1edb	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1ede	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1ee1	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1ee4	20 6a 26	jsr $266a			jsr 	FloatSetByte 				; return as byte
.1ee7	4c 4f 08	jmp $084f			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ceb7					C64_BANNER               = $ceb7 ; $ceb7 banner
=$ceb8					C64_EXEC                 = $ceb8 ; $ceb8 exec
=$ceb9					C64_TILE                 = $ceb9 ; $ceb9 tile
=$ceba					C64_EDIT                 = $ceba ; $ceba edit
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$cedb					C64_MWHEEL               = $cedb ; $cedb mwheel
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1eea					SetErrorHandler:
.1eea	8c 70 05	sty $0570			sty 	ErrorHandlerVector+1
.1eed	8e 6f 05	stx $056f			stx 	ErrorHandlerVector
.1ef0	60		rts				rts
.1ef1					CallErrorHandler:
.1ef1	6c 6f 05	jmp ($056f)			jmp 	(ErrorHandlerVector)
.056f					ErrorHandlerVector:
>056f							.fill 	2
.1ef4					ErrorV_range:
.1ef4	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1ef7	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1eff	41 4e 47 45 00
.1f04					ErrorV_value:
.1f04	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1f07	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f0f	45 00
.1f11					ErrorV_syntax:
.1f11	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1f14	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f1c	52 52 4f 52 00
.1f21					ErrorV_type:
.1f21	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1f24	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f2c	4d 41 54 43 48 00
.1f32					ErrorV_unimplemented:
.1f32	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1f35	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f3d	45 4d 45 4e 54 45 44 00
.1f45					ErrorV_assert:
.1f45	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1f48	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f50	41 49 4c 00
.1f54					ErrorV_line:
.1f54	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1f57	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f5f	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f6b					ErrorV_internal:
.1f6b	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1f6e	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f76	20 45 52 52 4f 52 00
.1f7d					ErrorV_divzero:
.1f7d	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1f80	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1f88	59 20 5a 45 52 4f 00
.1f8f					ErrorV_structure:
.1f8f	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1f92	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1f9a	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fa6					ErrorV_stop:
.1fa6	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1fa9	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fb1	53 54 4f 50 50 45 44 00
.1fb9					ErrorV_data:
.1fb9	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1fbc	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fc4	41 54 41 00
.1fc8					ErrorV_undeclared:
.1fc8	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1fcb	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1fd3	41 52 52 41 59 00
.1fd9					ErrorV_redefine:
.1fd9	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1fdc	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1fe4	44 45 46 49 4e 45 44 00
.1fec					ErrorV_index:
.1fec	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>1fef	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1ff7	59 20 49 4e 44 45 58 00
.1fff					ErrorV_memory:
.1fff	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>2002	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>200a	45 4d 4f 52 59 00
.2010					ErrorV_channel:
.2010	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>2013	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>201b	54 50 55 54 20 45 52 52 4f 52 00
.2026					ErrorV_break:
.2026	20 f1 1e	jsr $1ef1		jsr	CallErrorHandler
>2029	42 52 45 41 4b 20 50 52			.text	"BREAK PRESSED",0
>2031	45 53 53 45 44 00
.2037					MoveObjectForward:
.2037	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.2039	c9 ff		cmp #$ff			cmp 	#$FF
.203b	f0 36		beq $2073			beq 	_MOFEnd
.203d	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.203f	90 24		bcc $2065			bcc 	_MOFAdvance1 				; forward 1
.2041	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.2043	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2045	90 20		bcc $2067			bcc 	_MOFAdvanceY
.2047	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2049	90 1a		bcc $2065			bcc 	_MOFAdvance1 				; forward 1
.204b	a8		tay				tay 								; read the size.
.204c	b9 b1 1f	lda $1fb1,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.204f	a8		tay				tay
.2050	c8		iny				iny 								; add 1 for the system token.
.2051	d0 14		bne $2067			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2053	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2055	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2057	a8		tay				tay 								; into Y.
.2058	18		clc				clc
.2059	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.205b	69 02		adc #$02			adc 	#2
.205d	85 2a		sta $2a				sta 	objPtr
.205f	90 02		bcc $2063			bcc 	_MOFNoCarry1
.2061	e6 2b		inc $2b				inc 	objPtr+1
.2063					_MOFNoCarry1:
.2063	80 02		bra $2067			bra 	_MOFAdvanceY
.2065					_MOFAdvance1:
.2065	a0 01		ldy #$01			ldy 	#1
.2067					_MOFAdvanceY:
.2067	98		tya				tya 								; add Y to objPtr
.2068	18		clc				clc
.2069	65 2a		adc $2a				adc 	objPtr
.206b	85 2a		sta $2a				sta 	objPtr
.206d	90 02		bcc $2071			bcc 	_MOFNoCarry2
.206f	e6 2b		inc $2b				inc 	objPtr+1
.2071					_MOFNoCarry2:
.2071	18		clc				clc 								; not completed.
.2072	60		rts				rts
.2073					_MOFEnd:
.2073	e6 2a		inc $2a				inc 	objPtr
.2075	d0 02		bne $2079			bne 	_MOFENoCarry
.2077	e6 2b		inc $2b				inc 	objPtr+1
.2079					_MOFENoCarry:
.2079	38		sec				sec
.207a	60		rts				rts
.207b					MOFSizeTable:
>207b	01					.byte	1         	; $ca .shift
>207c	01					.byte	1         	; $cb .byte
>207d	02					.byte	2         	; $cc .word
>207e	05					.byte	5         	; $cd .float
>207f	ff					.byte	255       	; $ce .string
>2080	ff					.byte	255       	; $cf .data
>2081	02					.byte	2         	; $d0 .goto
>2082	02					.byte	2         	; $d1 .gosub
>2083	02					.byte	2         	; $d2 .goto.z
>2084	02					.byte	2         	; $d3 .goto.nz
>2085	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0571					numberBuffer:
>0571							.fill 	34
.2086					FloatSubtract:
.2086	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.2088	49 80		eor #$80			eor 	#$80
.208a	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.208c					FloatAdd:
.208c	ca		dex				dex
.208d	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.208f	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2091	15 62		ora $62,x			ora 	NSMantissa3,x
.2093	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2095	d0 04		bne $209b			bne 	_FAUseFloat
.2097	20 28 24	jsr $2428			jsr 	FloatInt32Add 				; use the int32 one.
.209a	60		rts				rts
.209b					_FAUseFloat:
.209b	20 bd 23	jsr $23bd			jsr 	FloatNormalise 				; normalise S[X]
.209e	f0 51		beq $20f1			beq 	_FAReturn1
.20a0	e8		inx				inx 								; normalise S[X+1]
.20a1	20 bd 23	jsr $23bd			jsr 	FloatNormalise
.20a4	ca		dex				dex
.20a5	c9 00		cmp #$00			cmp 	#0
.20a7	f0 60		beq $2109			beq 	_FAExit 					; if so, just return A
.20a9	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20ab	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20ad	f0 18		beq $20c7			beq 	_FAExponentsEqual
.20af	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20b1	a8		tay				tay
.20b2	38		sec				sec 								; do a signed comparison of the exponents.
.20b3	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20b5	50 02		bvc $20b9			bvc 	_FANoSignedChange
.20b7	49 80		eor #$80			eor 	#$80
.20b9					_FANoSignedChange:
.20b9	29 80		and #$80			and 	#$80
.20bb	10 02		bpl $20bf			bpl 	_FAHaveMax
.20bd	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.20bf					_FAHaveMax:
.20bf	20 0a 21	jsr $210a			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20c2	e8		inx				inx
.20c3	20 0a 21	jsr $210a			jsr 	_FAShiftToExponent
.20c6	ca		dex				dex
.20c7					_FAExponentsEqual:
.20c7	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.20c9	55 33		eor $33,x			eor 	NSStatus+1,x
.20cb	30 0e		bmi $20db			bmi 	_FADifferentSigns
.20cd	20 f4 23	jsr $23f4			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20d0	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20d2	10 35		bpl $2109			bpl 	_FAExit 					; if no, we are done.
.20d4	20 81 26	jsr $2681			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20d7	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.20d9	80 2e		bra $2109			bra 	_FAExit
.20db					_FADifferentSigns:
.20db	20 0e 24	jsr $240e			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20de	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.20e0	10 06		bpl $20e8			bpl 	_FACheckZero 				; if no, check for -0
.20e2	20 2a 26	jsr $262a			jsr 	FloatNegate 					; netate result
.20e5	20 31 26	jsr $2631			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20e8					_FACheckZero:
.20e8	20 8a 26	jsr $268a			jsr 	FloatIsZero	 				; check for -0
.20eb	d0 1c		bne $2109			bne 	_FAExit
.20ed	74 32		stz $32,x			stz 	NSStatus,x
.20ef	80 18		bra $2109			bra 	_FAExit
.20f1					_FAReturn1:
.20f1	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20f3	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20f5	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.20f7	95 4a		sta $4a,x			sta 	NSMantissa1,x
.20f9	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.20fb	95 56		sta $56,x			sta 	NSMantissa2,x
.20fd	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.20ff	95 62		sta $62,x			sta 	NSMantissa3,x
.2101	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.2103	95 6e		sta $6e,x			sta 	NSExponent,x
.2105	b5 33		lda $33,x			lda 	NSStatus+1,x
.2107	95 32		sta $32,x			sta 	NSStatus,x
.2109					_FAExit:
.2109	60		rts				rts
.210a					_FAShiftToExponent:
.210a					_FAShiftToExponent2:
.210a	98		tya				tya 								; compare Y to exponent
.210b	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.210d	f0 07		beq $2116			beq 	_FASEExit 					; exit if so.
.210f	20 81 26	jsr $2681			jsr 	FloatShiftRight	 			; shift the mantissa right
.2112	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.2114	80 f4		bra $210a			bra 	_FAShiftToExponent2
.2116					_FASEExit:
.2116	60		rts				rts
.2117					CompareEqual:
.2117	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2119	d0 09		bne $2124			bne 	ReturnFalse
.211b					ReturnTrue:
.211b	a9 01		lda #$01			lda 	#1
.211d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.211f	a9 80		lda #$80			lda 	#$80
.2121	95 32		sta $32,x			sta 	NSStatus,x
.2123	60		rts				rts
.2124					ReturnFalse:
.2124	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2126	60		rts				rts
.2127					CompareNotEqual:
.2127	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2129	d0 f0		bne $211b			bne 	ReturnTrue
.212b	80 f7		bra $2124			bra 	ReturnFalse
.212d					CompareLess:
.212d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.212f	c9 ff		cmp #$ff			cmp 	#$FF
.2131	f0 e8		beq $211b			beq 	ReturnTrue
.2133	80 ef		bra $2124			bra 	ReturnFalse
.2135					CompareGreater:
.2135	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2137	c9 01		cmp #$01			cmp 	#$01
.2139	f0 e0		beq $211b			beq 	ReturnTrue
.213b	80 e7		bra $2124			bra 	ReturnFalse
.213d					CompareLessEqual:
.213d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.213f	c9 01		cmp #$01			cmp 	#$01
.2141	d0 d8		bne $211b			bne 	ReturnTrue
.2143	80 df		bra $2124			bra 	ReturnFalse
.2145					CompareGreaterEqual:
.2145	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2147	c9 ff		cmp #$ff			cmp 	#$FF
.2149	d0 d0		bne $211b			bne 	ReturnTrue
.214b	80 d7		bra $2124			bra 	ReturnFalse
.214d					FloatCompare:
.214d	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.214f	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.2151	48		pha				pha
.2152	20 86 20	jsr $2086			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2155	68		pla				pla
.2156	d0 0c		bne $2164			bne 	_FCCompareFloat
.2158	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.215a	15 4a		ora $4a,x			ora 	NSMantissa1,x
.215c	15 56		ora $56,x			ora 	NSMantissa2,x
.215e	15 62		ora $62,x			ora 	NSMantissa3,x
.2160	f0 14		beq $2176			beq 	_FCExit 					; if zero, return zero
.2162	80 0a		bra $216e			bra 	_FCSign
.2164					_FCCompareFloat:
.2164	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2166	29 f0		and #$f0			and 	#$F0
.2168	15 56		ora $56,x			ora 	NSMantissa2,x
.216a	15 62		ora $62,x			ora 	NSMantissa3,x
.216c	f0 08		beq $2176			beq 	_FCExit 					; zero, so approximately identical
.216e					_FCSign:
.216e	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2170	34 32		bit $32,x			bit 	NSStatus,x
.2172	10 02		bpl $2176			bpl 	_FCExit
.2174					_FCNegative:
.2174	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2176					_FCExit:
.2176	20 6a 26	jsr $266a			jsr 	FloatSetByte 				; set the result 255,0,1
.2179	60		rts				rts
.217a					FloatScalarTable:
>217a	66 66 66 66				.dword $66666666 ; 0.1
>217e	de					.byte $de
>217f	1f 85 eb 51				.dword $51eb851f ; 0.01
>2183	db					.byte $db
>2184	4c 37 89 41				.dword $4189374c ; 0.001
>2188	d8					.byte $d8
>2189	ac 8b db 68				.dword $68db8bac ; 0.0001
>218d	d4					.byte $d4
>218e	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>2192	d1					.byte $d1
>2193	83 de 1b 43				.dword $431bde83 ; 1e-06
>2197	ce					.byte $ce
>2198	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>219c	ca					.byte $ca
>219d	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21a1	c7					.byte $c7
>21a2	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21a6	c4					.byte $c4
>21a7	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21ab	c0					.byte $c0
>21ac	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21b0	bd					.byte $bd
.21b1					FloatDivide:
.21b1	48		pha				pha
.21b2	20 bd 23	jsr $23bd			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21b5	ca		dex				dex
.21b6	c9 00		cmp #$00			cmp 	#0
.21b8	f0 1e		beq $21d8			beq 	_FDZero
.21ba	20 bd 23	jsr $23bd			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21bd	f0 16		beq $21d5			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21bf	20 20 22	jsr $2220			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21c2	20 ed 21	jsr $21ed			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21c5	20 bd 23	jsr $23bd			jsr		FloatNormalise 				; renormalise
.21c8	20 b3 23	jsr $23b3			jsr 	FloatCalculateSign 			; calculate result sign
.21cb	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.21cd	38		sec				sec
.21ce	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.21d0	38		sec				sec
.21d1	e9 1e		sbc #$1e			sbc 	#30
.21d3	95 6e		sta $6e,x			sta 	NSExponent,x
.21d5					_FDExit:
.21d5	68		pla				pla
.21d6	18		clc				clc
.21d7	60		rts				rts
.21d8					_FDZero:
.21d8	68		pla				pla
.21d9	38		sec				sec
.21da	60		rts				rts
.21db					DivideInt32:
.21db	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart 			; make both integers
.21de	ca		dex				dex
.21df	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.21e2	20 fe 21	jsr $21fe			jsr 	Int32Divide 				; divide
.21e5	20 ed 21	jsr $21ed			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21e8	20 b3 23	jsr $23b3			jsr 	FloatCalculateSign 			; calculate result sign
.21eb	18		clc				clc
.21ec	60		rts				rts
.21ed					NSMCopyPlusTwoToZero:
.21ed	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21ef	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21f1	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21f3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.21f5	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.21f7	95 56		sta $56,x			sta 	NSMantissa2,x
.21f9	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.21fb	95 62		sta $62,x			sta 	NSMantissa3,x
.21fd	60		rts				rts
.21fe					Int32Divide:
.21fe	48		pha				pha 								; save AXY
.21ff	5a		phy				phy
.2200	20 4b 26	jsr $264b			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2203	20 64 26	jsr $2664			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2206	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2208					_I32DivideLoop:
.2208	e8		inx				inx
.2209	e8		inx				inx
.220a	20 77 26	jsr $2677			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.220d	ca		dex				dex
.220e	ca		dex				dex
.220f	20 78 26	jsr $2678			jsr 	FloatRotateLeft
.2212	20 3e 22	jsr $223e			jsr 	FloatDivideCheck 			; check if subtract possible
.2215	90 02		bcc $2219			bcc 	_I32DivideNoCarryIn
.2217	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2219					_I32DivideNoCarryIn:
.2219	88		dey				dey 								; loop round till division completed.
.221a	d0 ec		bne $2208			bne 	_I32DivideLoop
.221c	7a		ply				ply 								; restore AXY and exit
.221d	68		pla				pla
.221e	18		clc				clc
.221f	60		rts				rts
.2220					Int32ShiftDivide:
.2220	48		pha				pha 								; save AY
.2221	5a		phy				phy
.2222	e8		inx				inx 								; clear S[X+2]
.2223	e8		inx				inx
.2224	20 68 26	jsr $2668			jsr 	FloatSetZero
.2227	ca		dex				dex
.2228	ca		dex				dex
.2229	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.222b					_I32SDLoop:
.222b	20 3e 22	jsr $223e			jsr 	FloatDivideCheck 			; check if subtract possible
.222e	e8		inx				inx
.222f	e8		inx				inx
.2230	20 78 26	jsr $2678			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.2233	ca		dex				dex
.2234	ca		dex				dex
.2235	20 78 26	jsr $2678			jsr 	FloatRotateLeft
.2238	88		dey				dey 	 							; do 31 times
.2239	d0 f0		bne $222b			bne 	_I32SDLoop
.223b	7a		ply				ply 								; restore AY and exit
.223c	68		pla				pla
.223d	60		rts				rts
.223e					FloatDivideCheck:
.223e	20 0e 24	jsr $240e			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.2241	b0 04		bcs $2247			bcs 	_DCSExit 					; if carry set, then could do, exit
.2243	20 f4 23	jsr $23f4			jsr 	FloatAddTopTwoStack 		; add it back in
.2246	18		clc				clc 								; and return False
.2247					_DCSExit:
.2247	60		rts				rts
.2248					FloatFractionalPart:
.2248	5a		phy				phy
.2249	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.224b	29 7f		and #$7f			and 	#$7F
.224d	95 32		sta $32,x			sta 	NSStatus,x
.224f	20 bd 23	jsr $23bd			jsr 	FloatNormalise
.2252	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2254	38		sec				sec
.2255	e9 e0		sbc #$e0			sbc 	#$E0
.2257	90 29		bcc $2282			bcc 	_FFPExit 					; already fractional
.2259	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.225b	b0 22		bcs $227f			bcs 	_FFPZero
.225d	a8		tay				tay 								; put count to do in Y
.225e	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.2260	20 87 22	jsr $2287			jsr 	_FFPPartial
.2263	95 62		sta $62,x			sta 	NSMantissa3,x
.2265	b5 56		lda $56,x			lda 	NSMantissa2,x
.2267	20 87 22	jsr $2287			jsr 	_FFPPartial
.226a	95 56		sta $56,x			sta 	NSMantissa2,x
.226c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.226e	20 87 22	jsr $2287			jsr 	_FFPPartial
.2271	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2273	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2275	20 87 22	jsr $2287			jsr 	_FFPPartial
.2278	95 3e		sta $3e,x			sta 	NSMantissa0,x
.227a	20 8a 26	jsr $268a			jsr 	FloatIsZero 					; zeroed check.
.227d	d0 03		bne $2282			bne 	_FFPExit
.227f					_FFPZero:
.227f	20 68 26	jsr $2668			jsr 	FloatSetZero
.2282					_FFPExit:
.2282	20 bd 23	jsr $23bd			jsr 	FloatNormalise
.2285	7a		ply				ply
.2286	60		rts				rts
.2287					_FFPPartial:
.2287	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2289	f0 17		beq $22a2			beq 	_FFFPPExit
.228b	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.228d	b0 0c		bcs $229b			bcs 	_FFFPPWholeByte
.228f	5a		phy				phy
.2290					_FFFPPLeft:
.2290	0a		asl a				asl 	a
.2291	88		dey				dey
.2292	d0 fc		bne $2290			bne 	_FFFPPLeft
.2294	7a		ply				ply
.2295					_FFFPPRight:
.2295	4a		lsr a				lsr 	a
.2296	88		dey				dey
.2297	d0 fc		bne $2295			bne 	_FFFPPRight
.2299	80 07		bra $22a2			bra 	_FFFPPExit
.229b					_FFFPPWholeByte:
.229b	98		tya				tya 								; subtract 8 from count
.229c	38		sec				sec
.229d	e9 08		sbc #$08			sbc 	#8
.229f	a8		tay				tay
.22a0	a9 00		lda #$00			lda 	#0 							; and clear all
.22a2					_FFFPPExit:
.22a2	60		rts				rts
.22a3					FloatIntegerPart:
.22a3	48		pha				pha
.22a4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22a6	f0 1d		beq $22c5			beq 	_FIPExit 					; if so do nothing
.22a8	20 8a 26	jsr $268a			jsr 	FloatIsZero 				; is it zero ?
.22ab	f0 15		beq $22c2			beq 	_FIPZero 					; if so return zero.
.22ad	20 bd 23	jsr $23bd			jsr 	FloatNormalise 				; normalise
.22b0	f0 10		beq $22c2			beq 	_FIPZero 					; normalised to zero, exit zero
.22b2					_FIPShift:
.22b2	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22b4	10 07		bpl $22bd			bpl 	_FIPCheckZero
.22b6	20 81 26	jsr $2681			jsr 	FloatShiftRight 			; shift mantissa right
.22b9	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22bb	80 f5		bra $22b2			bra 	_FIPShift
.22bd					_FIPCheckZero:
.22bd	20 8a 26	jsr $268a			jsr 	FloatIsZero 				; avoid -0 problem
.22c0	d0 03		bne $22c5			bne 	_FIPExit 					; set to zero if mantissa zero.
.22c2					_FIPZero:
.22c2	20 68 26	jsr $2668			jsr 	FloatSetZero
.22c5					_FIPExit:
.22c5	68		pla				pla
.22c6	60		rts				rts
.22c7					FloatIntegerPartDown:
.22c7	48		pha				pha
.22c8	5a		phy				phy
.22c9	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22cb	f0 36		beq $2303			beq 	_FIPExit 					; if so do nothing
.22cd	20 8a 26	jsr $268a			jsr 	FloatIsZero 				; is it zero ?
.22d0	f0 2e		beq $2300			beq 	_FIPZero 					; if so return zero.
.22d2	20 bd 23	jsr $23bd			jsr 	FloatNormalise 				; normalise
.22d5	f0 29		beq $2300			beq 	_FIPZero 					; normalised to zero, exit zero
.22d7	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22d9					_FIPShift:
.22d9	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22db	10 0a		bpl $22e7			bpl 	_FIPCheckDown
.22dd	20 81 26	jsr $2681			jsr 	FloatShiftRight 			; shift mantissa right
.22e0	90 01		bcc $22e3			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22e2	c8		iny				iny
.22e3					_FIPNoFrac:
.22e3	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22e5	80 f2		bra $22d9			bra 	_FIPShift
.22e7					_FIPCheckDown:
.22e7	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22e9	f0 10		beq $22fb			beq 	_FIPCheckZero
.22eb	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22ed	10 0c		bpl $22fb			bpl 	_FIPCheckZero
.22ef	e8		inx				inx 								; -ve so round *down*.
.22f0	a9 01		lda #$01			lda 	#1
.22f2	20 6a 26	jsr $266a			jsr 	FloatSetByte
.22f5	20 2a 26	jsr $262a			jsr 	FloatNegate
.22f8	20 8c 20	jsr $208c			jsr 	FloatAdd
.22fb					_FIPCheckZero:
.22fb	20 8a 26	jsr $268a			jsr 	FloatIsZero 				; avoid -0 problem
.22fe	d0 03		bne $2303			bne 	_FIPExit 					; set to zero if mantissa zero.
.2300					_FIPZero:
.2300	20 68 26	jsr $2668			jsr 	FloatSetZero
.2303					_FIPExit:
.2303	7a		ply				ply
.2304	68		pla				pla
.2305	60		rts				rts
.2306					FloatInt8Multiply:
.2306	5a		phy				phy
.2307	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2309	a8		tay				tay
.230a	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.230c					_FI8MLoop:
.230c	98		tya				tya 								; shift right shifter right into carry
.230d	4a		lsr a				lsr 	a
.230e	a8		tay				tay
.230f	90 0d		bcc $231e			bcc 	_FI8MNoAdd
.2311	18		clc				clc
.2312	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2314	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.2316	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2318	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.231a	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.231c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.231e					_FI8MNoAdd:
.231e	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.2320	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.2322	c0 00		cpy #$00			cpy 	#0
.2324	d0 e6		bne $230c			bne 	_FI8MLoop 					; until right shifter zero.
.2326	7a		ply				ply
.2327	60		rts				rts
.2328					FloatMultiply:
.2328	ca		dex				dex
.2329	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.232b	15 6f		ora $6f,x			ora 	NSExponent+1,x
.232d	15 62		ora $62,x			ora 	NSMantissa3,x
.232f	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2331	d0 21		bne $2354			bne 	_FMUseFloat
.2333	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2335	15 33		ora $33,x			ora 	NSStatus+1,x
.2337	29 80		and #$80			and 	#$80
.2339	15 62		ora $62,x			ora 	NSMantissa3,x
.233b	15 56		ora $56,x			ora 	NSMantissa2,x
.233d	15 4a		ora $4a,x			ora 	NSMantissa1,x
.233f	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2341	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2343	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2345	d0 04		bne $234b			bne 	_FMInt32
.2347	20 06 23	jsr $2306			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.234a	60		rts				rts
.234b					_FMInt32:
.234b	20 75 23	jsr $2375			jsr 	FloatMultiplyShort			; use the int32 one.
.234e	18		clc				clc 								; fix it up if gone out of range
.234f	75 6e		adc $6e,x			adc 	NSExponent,x
.2351	95 6e		sta $6e,x			sta 	NSExponent,x
.2353	60		rts				rts
.2354					_FMUseFloat:
.2354	20 bd 23	jsr $23bd			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2357	f0 18		beq $2371			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2359	e8		inx				inx
.235a	20 bd 23	jsr $23bd			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.235d	ca		dex				dex
.235e	c9 00		cmp #$00			cmp 	#0
.2360	f0 0c		beq $236e			beq 	_FDSetZero
.2362	20 75 23	jsr $2375			jsr 	FloatMultiplyShort 			; calculate the result.
.2365	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2367	18		clc				clc
.2368	75 6f		adc $6f,x			adc 	NSExponent+1,x
.236a	95 6e		sta $6e,x			sta 	NSExponent,x
.236c	80 03		bra $2371			bra 	_FDExit
.236e					_FDSetZero:
.236e	20 68 26	jsr $2668			jsr 	FloatSetZero 				; return 0
.2371					_FDExit:
.2371	20 bd 23	jsr $23bd			jsr 	FloatNormalise 				; normalise the result
.2374	60		rts				rts
.2375					FloatMultiplyShort:
.2375	5a		phy				phy 								; save Y
.2376	20 4b 26	jsr $264b			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2379	20 64 26	jsr $2664			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.237c	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.237e					_I32MLoop:
.237e	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2380	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.2382	15 58		ora $58,x			ora 	NSMantissa2+2,x
.2384	15 64		ora $64,x			ora 	NSMantissa3+2,x
.2386	f0 25		beq $23ad			beq 	_I32MExit 					; exit if zero
.2388	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.238a	29 01		and #$01			and 	#1
.238c	f0 0d		beq $239b			beq 	_I32MNoAdd
.238e	20 f4 23	jsr $23f4			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.2391	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.2393	10 06		bpl $239b			bpl 	_I32MNoAdd
.2395					_I32ShiftRight:
.2395	20 81 26	jsr $2681			jsr 	FloatShiftRight 			; shift S[X] right
.2398	c8		iny				iny 								; increment shift count
.2399	80 09		bra $23a4			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.239b					_I32MNoAdd:
.239b	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.239d	70 f6		bvs $2395			bvs 	_I32ShiftRight 				; instead.
.239f	e8		inx				inx
.23a0	20 77 26	jsr $2677			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23a3	ca		dex				dex
.23a4					_I32MShiftUpper:
.23a4	e8		inx				inx 								; shift S[X+2] right
.23a5	e8		inx				inx
.23a6	20 81 26	jsr $2681			jsr 	FloatShiftRight
.23a9	ca		dex				dex
.23aa	ca		dex				dex
.23ab	80 d1		bra $237e			bra 	_I32MLoop 					; try again.
.23ad					_I32MExit:
.23ad	20 b3 23	jsr $23b3			jsr 	FloatCalculateSign
.23b0	98		tya				tya 								; shift in A
.23b1	7a		ply				ply 								; restore Y and exit
.23b2	60		rts				rts
.23b3					FloatCalculateSign:
.23b3	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23b5	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23b7	55 33		eor $33,x			eor 	NSStatus+1,x
.23b9	0a		asl a				asl 	a 							; shift bit 7 into carry
.23ba	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23bc	60		rts				rts
.23bd					FloatNormalise:
.23bd	20 8a 26	jsr $268a			jsr 	FloatIsZero 				; if zero exit
.23c0	d0 07		bne $23c9			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23c2	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.23c4	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.23c6	a9 00		lda #$00			lda 	#0 							; set Z flag
.23c8	60		rts				rts
.23c9					_NSNormaliseOptimise:
.23c9	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23cb	d0 19		bne $23e6			bne 	_NSNormaliseLoop
.23cd	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.23cf	30 15		bmi $23e6			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23d1	95 62		sta $62,x			sta 	NSMantissa3,x
.23d3	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.23d5	95 56		sta $56,x			sta 	NSMantissa2,x
.23d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.23d9	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23db	74 3e		stz $3e,x			stz 	NSMantissa0,x
.23dd	b5 6e		lda $6e,x			lda 	NSExponent,x
.23df	38		sec				sec
.23e0	e9 08		sbc #$08			sbc 	#8
.23e2	95 6e		sta $6e,x			sta 	NSExponent,x
.23e4	80 e3		bra $23c9			bra 	_NSNormaliseOptimise
.23e6					_NSNormaliseLoop:
.23e6	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23e8	70 07		bvs $23f1			bvs 	_NSNExit 					; exit if so with Z flag clear
.23ea	20 77 26	jsr $2677			jsr 	FloatShiftLeft 				; shift mantissa left
.23ed	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23ef	80 f5		bra $23e6			bra 	_NSNormaliseLoop
.23f1					_NSNExit:
.23f1	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23f3	60		rts				rts
.23f4					FloatAddTopTwoStack:
.23f4	18		clc				clc
.23f5	b5 3e		lda $3e,x			lda		NSMantissa0,x
.23f7	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.23f9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.23fb	b5 4a		lda $4a,x			lda		NSMantissa1,x
.23fd	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.23ff	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2401	b5 56		lda $56,x			lda		NSMantissa2,x
.2403	75 57		adc $57,x			adc 		NSMantissa2+1,x
.2405	95 56		sta $56,x			sta 	NSMantissa2,x
.2407	b5 62		lda $62,x			lda		NSMantissa3,x
.2409	75 63		adc $63,x			adc 		NSMantissa3+1,x
.240b	95 62		sta $62,x			sta 	NSMantissa3,x
.240d	60		rts				rts
.240e					FloatSubTopTwoStack:
.240e	38		sec				sec
.240f	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2411	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.2413	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2415	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2417	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.2419	95 4a		sta $4a,x			sta 	NSMantissa1,x
.241b	b5 56		lda $56,x			lda		NSMantissa2,x
.241d	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.241f	95 56		sta $56,x			sta 	NSMantissa2,x
.2421	b5 62		lda $62,x			lda		NSMantissa3,x
.2423	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.2425	95 62		sta $62,x			sta 	NSMantissa3,x
.2427	60		rts				rts
.2428					FloatInt32Add:
.2428	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.242a	55 33		eor $33,x			eor 	NSStatus+1,x
.242c	30 04		bmi $2432			bmi 	_DiffSigns
.242e	20 f4 23	jsr $23f4			jsr		FloatAddTopTwoStack
.2431	60		rts				rts
.2432					_DiffSigns:
.2432	20 0e 24	jsr $240e			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2435	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2437	10 07		bpl $2440			bpl 	_AddExit
.2439	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.243b	95 32		sta $32,x			sta 	NSStatus,x
.243d	20 31 26	jsr $2631			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2440					_AddExit:
.2440	20 8a 26	jsr $268a			jsr 	FloatIsZero 				; check for -0
.2443	d0 02		bne $2447			bne 	_AddNonZero
.2445	74 32		stz $32,x			stz 	NSStatus,x
.2447					_AddNonZero:
.2447	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2448					FloatEncodeStart:
.2448	38		sec				sec
.2449	80 01		bra $244c			bra 	FloatEncodeContinue+1
.244b					FloatEncodeContinue:
.244b	18		clc				clc
.244c					FloatEncode:
.244c	08		php				php 								; save reset flag.
.244d	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.244f	f0 15		beq $2466			beq 	_ENIsOkay
.2451	c9 30		cmp #$30			cmp 	#"0"
.2453	90 04		bcc $2459			bcc 	_ENBadNumber
.2455	c9 3a		cmp #$3a			cmp 	#"9"+1
.2457	90 0d		bcc $2466			bcc 	_ENIsOkay
.2459					_ENBadNumber:
.2459	28		plp				plp 								; throw saved reset
.245a	ad 93 05	lda $0593			lda 	encodeState 				; if in decimal mode, construct final number
.245d	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.245f	d0 03		bne $2464			bne 	_ENFail
.2461	4c de 24	jmp $24de			jmp 	_ENConstructFinal
.2464					_ENFail:
.2464	18		clc				clc 								; not allowed
.2465	60		rts				rts
.2466					_ENIsOkay:
.2466	28		plp				plp 								; are we restarting
.2467	90 15		bcc $247e			bcc 	_ENNoRestart
.2469					_ENStartEncode:
.2469	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.246b	f0 0c		beq $2479			beq 	_ENFirstDP
.246d	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.246f	20 6a 26	jsr $266a			jsr 	FloatSetByte 				; in single byte mode.
.2472	a9 01		lda #$01			lda 	#ESTA_Low
.2474					_ENExitChange:
.2474	8d 93 05	sta $0593			sta 	encodeState 				; save new state
.2477	38		sec				sec
.2478	60		rts				rts
.2479					_ENFirstDP:
.2479	20 68 26	jsr $2668			jsr 	FloatSetZero 				; clear integer part
.247c	80 3c		bra $24ba			bra 	_ESTASwitchFloat			; go straight to float and exi
.247e					_ENNoRestart:
.247e	48		pha				pha 								; save digit or DP on stack.
.247f	ad 93 05	lda $0593			lda 	encodeState 				; get current state
.2482	c9 01		cmp #$01			cmp 	#ESTA_Low
.2484	f0 09		beq $248f			beq  	_ESTALowState
.2486	c9 02		cmp #$02			cmp 	#ESTA_High
.2488	f0 26		beq $24b0			beq 	_ESTAHighState
.248a	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.248c	f0 38		beq $24c6			beq 	_ESTADecimalState
>248e	db						.byte 	$DB 						; causes a break in the emulator
.248f					_ESTALowState:
.248f	68		pla				pla 								; get value back
.2490	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.2492	f0 26		beq $24ba			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.2494	29 0f		and #$0f			and 	#15 						; make digit
.2496	8d 94 05	sta $0594			sta 	digitTemp 					; save it.
.2499	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.249b	0a		asl a				asl 	a
.249c	0a		asl a				asl 	a
.249d	75 3e		adc $3e,x			adc 	NSMantissa0,x
.249f	0a		asl a				asl 	a
.24a0	6d 94 05	adc $0594			adc 	digitTemp
.24a3	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24a5	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24a7	90 05		bcc $24ae			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24a9	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24ab	8d 93 05	sta $0593			sta 	encodeState
.24ae					_ESTANoSwitch:
.24ae	38		sec				sec
.24af	60		rts				rts
.24b0					_ESTAHighState:
.24b0	68		pla				pla 								; get value back
.24b1	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24b3	f0 05		beq $24ba			beq 	_ESTASwitchFloat
.24b5	20 10 25	jsr $2510			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24b8	38		sec				sec
.24b9	60		rts				rts
.24ba					_ESTASwitchFloat:
.24ba	9c 95 05	stz $0595			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24bd	e8		inx				inx 								; zero the decimal additive.
.24be	20 68 26	jsr $2668			jsr 	FloatSetZero
.24c1	ca		dex				dex
.24c2	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24c4	80 ae		bra $2474			bra 	_ENExitChange
.24c6					_ESTADecimalState:
.24c6	68		pla				pla 								; digit.
.24c7	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24c9	f0 99		beq $2464			beq 	_ENFail
.24cb	e8		inx				inx 								; put digit into fractional part of X+1
.24cc	20 10 25	jsr $2510			jsr 	ESTAShiftDigitIntoMantissa
.24cf	ca		dex				dex
.24d0	ee 95 05	inc $0595			inc 	decimalCount 				; bump the count of decimals
.24d3	ad 95 05	lda $0595			lda 	decimalCount 				; too many decimal digits.
.24d6	c9 0b		cmp #$0b			cmp 	#11
.24d8	f0 02		beq $24dc			beq 	_ESTADSFail
.24da	38		sec				sec
.24db	60		rts				rts
.24dc					_ESTADSFail:
.24dc	18		clc				clc
.24dd	60		rts				rts
.24de					_ENConstructFinal:
.24de	ad 95 05	lda $0595			lda 	decimalCount 				; get decimal count
.24e1	f0 2b		beq $250e			beq 	_ENCFExit 					; no decimals
.24e3	5a		phy				phy
.24e4	0a		asl a				asl 	a 							; x 4 and CLC
.24e5	0a		asl a				asl 	a
.24e6	6d 95 05	adc $0595			adc 	decimalCount
.24e9	a8		tay				tay
.24ea	b9 75 21	lda $2175,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24ed	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24ef	b9 76 21	lda $2176,y			lda 	FloatScalarTable-5+1,y
.24f2	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.24f4	b9 77 21	lda $2177,y			lda 	FloatScalarTable-5+2,y
.24f7	95 58		sta $58,x			sta 	NSMantissa2+2,x
.24f9	b9 78 21	lda $2178,y			lda 	FloatScalarTable-5+3,y
.24fc	95 64		sta $64,x			sta 	NSMantissa3+2,x
.24fe	b9 79 21	lda $2179,y			lda 	FloatScalarTable-5+4,y
.2501	95 70		sta $70,x			sta 	NSExponent+2,x
.2503	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.2505	e8		inx				inx 								; multiply decimal const by decimal scalar
.2506	e8		inx				inx
.2507	20 28 23	jsr $2328			jsr 	FloatMultiply
.250a	20 8c 20	jsr $208c			jsr 	FloatAdd 					; add to integer part.
.250d	7a		ply				ply
.250e					_ENCFExit:
.250e	18		clc				clc 								; reject the digit.
.250f	60		rts				rts
.2510					ESTAShiftDigitIntoMantissa:
.2510	29 0f		and #$0f			and 	#15 						; save digit
.2512	48		pha				pha
.2513	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2515	48		pha				pha
.2516	b5 56		lda $56,x			lda 	NSMantissa2,x
.2518	48		pha				pha
.2519	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.251b	48		pha				pha
.251c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.251e	48		pha				pha
.251f	20 77 26	jsr $2677			jsr 	FloatShiftLeft 				; x 2
.2522	20 77 26	jsr $2677			jsr 	FloatShiftLeft 				; x 4
.2525	18		clc				clc 								; pop mantissa and add
.2526	68		pla				pla
.2527	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2529	95 3e		sta $3e,x			sta 	NSMantissa0,x
.252b	68		pla				pla
.252c	75 4a		adc $4a,x			adc 	NSMantissa1,x
.252e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2530	68		pla				pla
.2531	75 56		adc $56,x			adc 	NSMantissa2,x
.2533	95 56		sta $56,x			sta 	NSMantissa2,x
.2535	68		pla				pla
.2536	75 62		adc $62,x			adc 	NSMantissa3,x
.2538	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.253a	20 77 26	jsr $2677			jsr 	FloatShiftLeft 				; x 10
.253d	68		pla				pla 								; add digit
.253e	18		clc				clc
.253f	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2541	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2543	90 0a		bcc $254f			bcc 	_ESTASDExit
.2545	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2547	d0 06		bne $254f			bne 	_ESTASDExit
.2549	f6 56		inc $56,x			inc 	NSMantissa2,x
.254b	d0 02		bne $254f			bne 	_ESTASDExit
.254d	f6 62		inc $62,x			inc 	NSMantissa3,x
.254f					_ESTASDExit:
.254f	60		rts				rts
.0593					encodeState:
>0593							.fill 	1
.0594					digitTemp:
>0594							.fill 	1
.0595					decimalCount:
>0595							.fill 	1
.2550					FloatToString:
.2550	da		phx				phx
.2551	5a		phy				phy 								; save code position
.2552	8d 96 05	sta $0596			sta 	decimalPlaces	 			; save number of DPs.
.2555	9c 97 05	stz $0597			stz 	dbOffset 					; offset into decimal buffer = start.
.2558	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.255a	10 08		bpl $2564			bpl 	_CNTSNotNegative
.255c	29 7f		and #$7f			and 	#$7F 						; make +ve
.255e	95 32		sta $32,x			sta 	NSStatus,x
.2560	a9 2d		lda #$2d			lda 	#"-"
.2562	80 02		bra $2566			bra 	_CNTMain
.2564					_CNTSNotNegative:
.2564	a9 20		lda #$20			lda 	#" "
.2566					_CNTMain:
.2566	20 c8 25	jsr $25c8			jsr 	WriteDecimalBuffer
.2569	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.256b	f0 0d		beq $257a			beq 	_CNTSNotFloat
.256d	e8		inx				inx 								; round up so we don't get too many 6.999999
.256e	a9 01		lda #$01			lda 	#1
.2570	20 6a 26	jsr $266a			jsr 	FloatSetByte
.2573	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2575	95 6e		sta $6e,x			sta 	NSExponent,x
.2577	20 8c 20	jsr $208c			jsr 	FloatAdd
.257a					_CNTSNotFloat:
.257a	20 aa 25	jsr $25aa			jsr 	MakePlusTwoString 			; do the integer part.
.257d	20 48 22	jsr $2248			jsr 	FloatFractionalPart 		; get the fractional part
.2580	20 bd 23	jsr $23bd			jsr 	FloatNormalise					; normalise , exit if zero
.2583	f0 22		beq $25a7			beq 	_CNTSExit
.2585	a9 2e		lda #$2e			lda 	#"."
.2587	20 c8 25	jsr $25c8			jsr 	WriteDecimalBuffer 			; write decimal place
.258a					_CNTSDecimal:
.258a	ce 96 05	dec $0596			dec 	decimalPlaces 				; done all the decimals
.258d	30 18		bmi $25a7			bmi 	_CNTSExit
.258f	e8		inx				inx 								; x 10.0
.2590	a9 0a		lda #$0a			lda 	#10
.2592	20 6a 26	jsr $266a			jsr 	FloatSetByte
.2595	20 28 23	jsr $2328			jsr 	FloatMultiply
.2598	20 aa 25	jsr $25aa			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.259b	20 48 22	jsr $2248			jsr 	FloatFractionalPart 		; get the fractional part
.259e	20 bd 23	jsr $23bd			jsr 	FloatNormalise 				; normalise it.
.25a1	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25a3	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25a5	b0 e3		bcs $258a			bcs 	_CNTSDecimal 				; keep going.
.25a7					_CNTSExit:
.25a7	7a		ply				ply
.25a8	fa		plx				plx
.25a9	60		rts				rts
.25aa					MakePlusTwoString:
.25aa	da		phx				phx
.25ab	20 4b 26	jsr $264b			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25ae	e8		inx				inx 								; access it
.25af	e8		inx				inx
.25b0	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart 			; make it an integer
.25b3	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25b5	20 e7 25	jsr $25e7			jsr 	ConvertInt32
.25b8	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25ba					_MPTSCopy:
.25ba	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25bd	20 c8 25	jsr $25c8			jsr 	WriteDecimalBuffer
.25c0	e8		inx				inx
.25c1	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25c4	d0 f4		bne $25ba			bne 	_MPTSCopy
.25c6	fa		plx				plx
.25c7	60		rts				rts
.25c8					WriteDecimalBuffer:
.25c8	da		phx				phx
.25c9	ae 97 05	ldx $0597			ldx 	dbOffset
.25cc	9d 98 05	sta $0598,x			sta 	decimalBuffer,x
.25cf	9e 99 05	stz $0599,x			stz 	decimalBuffer+1,x
.25d2	ee 97 05	inc $0597			inc 	dbOffset
.25d5	fa		plx				plx
.25d6	60		rts				rts
.0596					decimalPlaces:
>0596							.fill 	1
.0597					dbOffset:
>0597							.fill 	1
.0598					decimalBuffer:
>0598							.fill 	32
.25d7					ConvertInt16:
.25d7	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.25d9	86 4a		stx $4a				stx 	NSMantissa1
.25db	64 56		stz $56				stz 	NSMantissa2
.25dd	64 62		stz $62				stz 	NSMantissa3
.25df	64 32		stz $32				stz 	NSStatus 					; positive integer
.25e1	a2 00		ldx #$00			ldx 	#0 							; stack level
.25e3	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25e5	80 00		bra $25e7			bra 	ConvertInt32
.25e7					ConvertInt32:
.25e7	5a		phy				phy
.25e8	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25ea	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25ec	10 08		bpl $25f6			bpl 	_CI32NotNeg
.25ee	48		pha				pha
.25ef	a9 2d		lda #$2d			lda 	#'-'
.25f1	99 71 05	sta $0571,y			sta 	numberBuffer,y
.25f4	c8		iny				iny
.25f5	68		pla				pla
.25f6					_CI32NotNeg:
.25f6	20 04 26	jsr $2604			jsr 	_CI32DivideConvert 			; recursive conversion
.25f9	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.25fb	99 71 05	sta $0571,y			sta 	numberBuffer,y
.25fe	7a		ply				ply
.25ff	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.2601	a9 71		lda #$71			lda 	#numberBuffer & $FF
.2603	60		rts				rts
.2604					_CI32DivideConvert:
.2604	e8		inx				inx 								; write to next slot up
.2605	20 6a 26	jsr $266a			jsr 	FloatSetByte 		 		; write the base out.
.2608	ca		dex				dex
.2609	20 fe 21	jsr $21fe			jsr 	Int32Divide 				; divide
.260c	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.260e	48		pha				pha
.260f	20 ed 21	jsr $21ed			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2612	20 8a 26	jsr $268a			jsr 	FloatIsZero 				; is it zero ?
.2615	f0 05		beq $261c			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2617	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2619	20 04 26	jsr $2604			jsr 	_CI32DivideConvert 			; and recusrively call.
.261c					_CI32NoRecurse:
.261c	68		pla				pla 								; remainder
.261d	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.261f	90 02		bcc $2623			bcc 	_CI32NotHex
.2621	69 26		adc #$26			adc 	#6+32
.2623					_CI32NotHex:
.2623	69 30		adc #$30			adc 	#48
.2625	99 71 05	sta $0571,y			sta 	numberBuffer,y 				; write out and exit
.2628	c8		iny				iny
.2629	60		rts				rts
.262a					FloatNegate:
.262a	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.262c	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.262e	95 32		sta $32,x			sta 	NSStatus,x
.2630	60		rts				rts
.2631					FloatNegateMantissa:
.2631	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2632	a9 00		lda #$00			lda 	#0
.2634	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2636	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2638	a9 00		lda #$00			lda 	#0
.263a	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.263c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.263e	a9 00		lda #$00			lda 	#0
.2640	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.2642	95 56		sta $56,x			sta 	NSMantissa2,x
.2644	a9 00		lda #$00			lda 	#0
.2646	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2648	95 62		sta $62,x			sta 	NSMantissa3,x
.264a	60		rts				rts
.264b					FloatShiftUpTwo:
.264b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.264d	95 40		sta $40,x			sta 	NSMantissa0+2,x
.264f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2651	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2653	b5 56		lda $56,x			lda 	NSMantissa2,x
.2655	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2657	b5 62		lda $62,x			lda 	NSMantissa3,x
.2659	95 64		sta $64,x			sta 	NSMantissa3+2,x
.265b	b5 6e		lda $6e,x			lda 	NSExponent,x
.265d	95 70		sta $70,x			sta 	NSExponent+2,x
.265f	b5 32		lda $32,x			lda 	NSStatus,x
.2661	95 34		sta $34,x			sta 	NSStatus+2,x
.2663	60		rts				rts
.2664					FloatSetZeroMantissaOnly:
.2664	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2666	80 08		bra $2670			bra 	FloatZero13
.2668					FloatSetZero:
.2668	a9 00		lda #$00			lda 	#0
.266a					FloatSetByte:
.266a	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.266c					FloatSetMantissa:
.266c	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.266e	74 32		stz $32,x			stz 	NSStatus,x
.2670					FloatZero13:
.2670	74 4a		stz $4a,x			stz 	NSMantissa1,x
.2672	74 56		stz $56,x			stz 	NSMantissa2,x
.2674	74 62		stz $62,x			stz 	NSMantissa3,x
.2676	60		rts				rts
.2677					FloatShiftLeft:
.2677	18		clc				clc
.2678					FloatRotateLeft:
.2678	36 3e		rol $3e,x			rol 	NSMantissa0,x
.267a	36 4a		rol $4a,x			rol		NSMantissa1,x
.267c	36 56		rol $56,x			rol		NSMantissa2,x
.267e	36 62		rol $62,x			rol		NSMantissa3,x
.2680	60		rts				rts
.2681					FloatShiftRight:
.2681	56 62		lsr $62,x			lsr 	NSMantissa3,x
.2683	76 56		ror $56,x			ror		NSMantissa2,x
.2685	76 4a		ror $4a,x			ror		NSMantissa1,x
.2687	76 3e		ror $3e,x			ror		NSMantissa0,x
.2689	60		rts				rts
.268a					FloatIsZero:
.268a	b5 62		lda $62,x			lda 	NSMantissa3,x
.268c	15 56		ora $56,x			ora		NSMantissa2,x
.268e	15 4a		ora $4a,x			ora		NSMantissa1,x
.2690	15 3e		ora $3e,x			ora		NSMantissa0,x
.2692	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.2693					FloatArcTan:
.2693	20 bd 23	jsr $23bd			jsr 	FloatNormalise 					; normalise x
.2696	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.2698	48		pha				pha
.2699	74 32		stz $32,x			stz 	NSStatus,x
.269b	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.269d	c9 e2		cmp #$e2			cmp 	#$E2
.269f	90 25		bcc $26c6			bcc 	_UANoFixup
.26a1	8a		txa				txa 									; value in +1
.26a2	a8		tay				tay
.26a3	c8		iny				iny
.26a4	20 4c 28	jsr $284c			jsr 	CopyFloatXY
.26a7	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.26a9	20 6a 26	jsr $266a			jsr 	FloatSetByte
.26ac	e8		inx				inx
.26ad	20 b1 21	jsr $21b1			jsr 	FloatDivide
.26b0	b0 21		bcs $26d3			bcs 	_FATError
.26b2	20 d6 26	jsr $26d6			jsr 	CoreAtn 						; calculate the root
.26b5	20 41 28	jsr $2841			jsr 	CompletePolynomial
.26b8	20 2a 26	jsr $262a			jsr 	FloatNegate 					; make -ve
.26bb	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.26bd	20 98 28	jsr $2898			jsr 	LoadConstant
.26c0	e8		inx				inx
.26c1	20 8c 20	jsr $208c			jsr 	FloatAdd
.26c4	80 06		bra $26cc			bra 	_UAComplete
.26c6					_UANoFixup:
.26c6	20 d6 26	jsr $26d6			jsr 	CoreAtn
.26c9	20 41 28	jsr $2841			jsr 	CompletePolynomial
.26cc					_UAComplete:
.26cc	68		pla				pla 									; apply the result.
.26cd	55 32		eor $32,x			eor 	NSStatus,x
.26cf	95 32		sta $32,x			sta 	NSStatus,x
.26d1	18		clc				clc
.26d2	60		rts				rts
.26d3					_FATError:
.26d3	68		pla				pla
.26d4	38		sec				sec
.26d5	60		rts				rts
.26d6					CoreAtn:
.26d6	a9 44		lda #$44			lda 	#AtnCoefficients & $FF
.26d8	a0 27		ldy #$27			ldy 	#AtnCoefficients >> 8
.26da	4c 95 29	jmp $2995			jmp 	CorePolySquared
.26dd					ExpCoefficients:
>26dd	07					.byte	7
>26de	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>26e2	d2					.byte	$d2
>26e3	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>26e7	d5					.byte	$d5
>26e8	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>26ec	d8					.byte	$d8
>26ed	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>26f1	db					.byte	$db
>26f2	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>26f6	dd					.byte	$dd
>26f7	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>26fb	df					.byte	$df
>26fc	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>2700	e1					.byte	$e1
>2701	00 00 00 40				.dword	$40000000 ; 1.0
>2705	e2					.byte	$e2
.2706					SinCoefficients:
>2706	06					.byte	6
>2707	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>270b	e5					.byte	$e5
>270c	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>2710	e7					.byte	$e7
>2711	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>2715	e8					.byte	$e8
>2716	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>271a	e8					.byte	$e8
>271b	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>271f	e7					.byte	$e7
>2720	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>2724	e4					.byte	$e4
>2725	00 00 00 00				.dword	$00000000 ; 0.0
>2729	00					.byte	$00
.272a					LogCoefficients:
>272a	04					.byte	4
>272b	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>272f	e0					.byte	$e0
>2730	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>2734	e1					.byte	$e1
>2735	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>2739	e1					.byte	$e1
>273a	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>273e	e3					.byte	$e3
>273f	00 00 00 c0				.dword	$c0000000 ; -0.5
>2743	e1					.byte	$e1
.2744					AtnCoefficients:
>2744	0c					.byte	12
>2745	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2749	d7					.byte	$d7
>274a	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>274e	da					.byte	$da
>274f	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>2753	dc					.byte	$dc
>2754	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2758	dd					.byte	$dd
>2759	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>275d	dd					.byte	$dd
>275e	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>2762	de					.byte	$de
>2763	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2767	de					.byte	$de
>2768	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>276c	de					.byte	$de
>276d	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>2771	df					.byte	$df
>2772	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>2776	df					.byte	$df
>2777	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>277b	e0					.byte	$e0
>277c	00 00 00 40				.dword	$40000000 ; 1.0
>2780	e2					.byte	$e2
>2781	00 00 00 00				.dword	$00000000 ; 0.0
>2785	00					.byte	$00
.2786					Const_Base:
.2786					Const_1Div2Pi:
>2786	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>278a	df					.byte	$df
.278b					Const_PiDiv2:
>278b	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>278f	e2					.byte	$e2
.2790					Const_Log2_e:
>2790	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>2794	e2					.byte	$e2
.2795					Const_sqrt_2:
>2795	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>2799	e2					.byte	$e2
.279a					Const_sqrt_half:
>279a	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>279e	e1					.byte	$e1
.279f					Const_pi:
>279f	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>27a3	e3					.byte	$e3
.27a4					Const_half:
>27a4	00 00 00 40				.dword	$40000000 ; 0.50000000
>27a8	e1					.byte	$e1
.27a9					Const_ln_e:
>27a9	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>27ad	e1					.byte	$e1
.27ae					FloatCosine:
.27ae	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.27b0	20 98 28	jsr $2898			jsr 	LoadConstant
.27b3	e8		inx				inx
.27b4	20 8c 20	jsr $208c			jsr 	FloatAdd
.27b7	4c 4e 29	jmp $294e			jmp 	FloatSine
.27ba					FloatExponent:
.27ba	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.27bc	20 98 28	jsr $2898			jsr 	LoadConstant
.27bf	e8		inx				inx
.27c0	20 28 23	jsr $2328			jsr 	FloatMultiply
.27c3	20 05 28	jsr $2805			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.27c6	e8		inx				inx
.27c7	20 a3 22	jsr $22a3			jsr 	FloatIntegerPart
.27ca	ca		dex				dex
.27cb	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.27cd	15 57		ora $57,x			ora 	NSMantissa2+1,x
.27cf	15 63		ora $63,x			ora 	NSMantissa3+1,x
.27d1	d0 38		bne $280b			bne 	_UERangeError
.27d3	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.27d5	c9 40		cmp #$40			cmp 	#64
.27d7	b0 32		bcs $280b			bcs 	_UERangeError
.27d9	48		pha				pha
.27da	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.27dc	48		pha				pha
.27dd	20 48 22	jsr $2248			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.27e0	68		pla				pla
.27e1	10 14		bpl $27f7			bpl 	_UEPositive
.27e3	e8		inx				inx 							; 1-x
.27e4	a9 01		lda #$01			lda 	#1
.27e6	20 6a 26	jsr $266a			jsr 	FloatSetByte
.27e9	ca		dex				dex
.27ea	20 2a 26	jsr $262a			jsr 	FloatNegate
.27ed	e8		inx				inx
.27ee	20 8c 20	jsr $208c			jsr 	FloatAdd
.27f1	68		pla				pla 							; integer part +1 and negated.
.27f2	1a		inc a				inc 	a
.27f3	49 ff		eor #$ff			eor 	#$FF
.27f5	1a		inc a				inc 	a
.27f6	48		pha				pha
.27f7					_UEPositive:
.27f7	20 0d 28	jsr $280d			jsr 	CoreExponent
.27fa	20 41 28	jsr $2841			jsr 	CompletePolynomial
.27fd	68		pla				pla
.27fe	18		clc				clc
.27ff	75 6e		adc $6e,x			adc 	NSExponent,x
.2801	95 6e		sta $6e,x			sta 	NSExponent,x
.2803	18		clc				clc
.2804	60		rts				rts
.2805					_UECopy01:
.2805	8a		txa				txa
.2806	a8		tay				tay
.2807	c8		iny				iny
.2808	4c 4c 28	jmp $284c			jmp 	CopyFloatXY
.280b					_UERangeError:
.280b	38		sec				sec
.280c	60		rts				rts
.280d					CoreExponent:
.280d	a9 dd		lda #$dd			lda 	#ExpCoefficients & $FF
.280f	a0 26		ldy #$26			ldy 	#ExpCoefficients >> 8
.2811	20 15 28	jsr $2815			jsr 	CalculateHornerPolynomial
.2814	60		rts				rts
.2815					CalculateHornerPolynomial:
.2815	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.2817	84 2d		sty $2d				sty 	zTemp0+1
.2819	9c b8 05	stz $05b8			stz 	coefficientCount 			; zero the count.
.281c	8e b9 05	stx $05b9			stx 	xValueSlot 					; save xValue slot.
.281f	e8		inx				inx 								; set the count to zero.
.2820	20 68 26	jsr $2668			jsr 	FloatSetZero
.2823					_CHPLoop:
.2823	8a		txa				txa 								; copy X-1 to X+1
.2824	a8		tay				tay
.2825	ca		dex				dex
.2826	c8		iny				iny
.2827	20 4c 28	jsr $284c			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.282a	e8		inx				inx
.282b	e8		inx				inx
.282c	20 28 23	jsr $2328			jsr 	FloatMultiply 				; times current by X
.282f	e8		inx				inx
.2830	20 6b 28	jsr $286b			jsr 	GetCoefficient 				; coefficient into X+1
.2833	20 8c 20	jsr $208c			jsr 	FloatAdd 					; and add
.2836	ee b8 05	inc $05b8			inc 	coefficientCount
.2839	ad b8 05	lda $05b8			lda 	coefficientCount
.283c	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.283e	d0 e3		bne $2823			bne 	_CHPLoop
.2840	60		rts				rts
.2841					CompletePolynomial:
.2841	20 28 23	jsr $2328			jsr 	FloatMultiply
.2844	e8		inx				inx 								; get the last value
.2845	20 6b 28	jsr $286b			jsr 	GetCoefficient
.2848	20 8c 20	jsr $208c			jsr 	FloatAdd 					; and add it
.284b	60		rts				rts
.284c					CopyFloatXY:
.284c	b5 6e		lda $6e,x			lda 	NSExponent,x
.284e	99 6e 00	sta $006e,y			sta 	NSExponent,y
.2851	b5 32		lda $32,x			lda 	NSStatus,x
.2853	99 32 00	sta $0032,y			sta 	NSStatus,y
.2856	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2858	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.285b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.285d	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.2860	b5 56		lda $56,x			lda 	NSMantissa2,x
.2862	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.2865	b5 62		lda $62,x			lda 	NSMantissa3,x
.2867	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.286a	60		rts				rts
.286b					GetCoefficient:
.286b	5a		phy				phy
.286c	ad b8 05	lda $05b8			lda 	coefficientCount 			; 5 per block
.286f	0a		asl a				asl 	a
.2870	0a		asl a				asl 	a
.2871	38		sec				sec 								; +1 for count
.2872	6d b8 05	adc $05b8			adc 	coefficientCount
.2875	a8		tay				tay
.2876	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.2878	95 3e		sta $3e,x			sta 	NSMantissa0,x
.287a	c8		iny				iny
.287b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.287d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.287f	c8		iny				iny
.2880	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2882	95 56		sta $56,x			sta 	NSMantissa2,x
.2884	c8		iny				iny
.2885	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2887	48		pha				pha
.2888	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.288a	95 62		sta $62,x			sta 	NSMantissa3,x
.288c	c8		iny				iny
.288d	68		pla				pla
.288e	29 80		and #$80			and 	#$80
.2890	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.2892	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2894	95 6e		sta $6e,x			sta 	NSExponent,x
.2896	7a		ply				ply
.2897	60		rts				rts
.05b8					coefficientCount:
>05b8							.fill 	1
.05b9					xValueSlot:
>05b9							.fill 	1
.2898					LoadConstant:
.2898	5a		phy				phy
.2899	a8		tay				tay
.289a	b9 86 27	lda $2786,y			lda 	Const_Base+0,y
.289d	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.289f	b9 87 27	lda $2787,y			lda 	Const_Base+1,y
.28a2	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.28a4	b9 88 27	lda $2788,y			lda 	Const_Base+2,y
.28a7	95 57		sta $57,x			sta 	NSMantissa2+1,x
.28a9	b9 89 27	lda $2789,y			lda 	Const_Base+3,y
.28ac	48		pha				pha
.28ad	29 7f		and #$7f			and 	#$7F
.28af	95 63		sta $63,x			sta 	NSMantissa3+1,x
.28b1	68		pla				pla
.28b2	29 80		and #$80			and 	#$80
.28b4	95 33		sta $33,x			sta 	NSStatus+1,x
.28b6	b9 8a 27	lda $278a,y			lda 	Const_Base+4,y
.28b9	95 6f		sta $6f,x			sta 	NSExponent+1,x
.28bb	7a		ply				ply
.28bc	60		rts				rts
.28bd					FloatLogarithm:
.28bd	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.28bf	30 5f		bmi $2920			bmi 	_ULRange
.28c1	20 8a 26	jsr $268a			jsr 	FloatIsZero
.28c4	f0 5a		beq $2920			beq 	_ULRange
.28c6	20 bd 23	jsr $23bd			jsr 	FloatNormalise 				; put into FP mode.
.28c9	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.28cb	48		pha				pha
.28cc	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.28ce	95 6e		sta $6e,x			sta 	NSExponent,x
.28d0	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.28d2	20 98 28	jsr $2898			jsr 	LoadConstant
.28d5	e8		inx				inx
.28d6	20 8c 20	jsr $208c			jsr 	FloatAdd
.28d9	8a		txa				txa 								; divide into sqrt 2.0
.28da	a8		tay				tay
.28db	c8		iny				iny
.28dc	20 4c 28	jsr $284c			jsr 	CopyFloatXY
.28df	ca		dex				dex
.28e0	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.28e2	20 98 28	jsr $2898			jsr 	LoadConstant
.28e5	e8		inx				inx
.28e6	e8		inx				inx
.28e7	20 b1 21	jsr $21b1			jsr 	FloatDivide 				; if zero, error.
.28ea	b0 33		bcs $291f			bcs 	_ULRangePla
.28ec	20 2a 26	jsr $262a			jsr 	FloatNegate 				; subtract from 1
.28ef	e8		inx				inx
.28f0	a9 01		lda #$01			lda 	#1
.28f2	20 6a 26	jsr $266a			jsr 	FloatSetByte
.28f5	20 8c 20	jsr $208c			jsr 	FloatAdd
.28f8	20 22 29	jsr $2922			jsr 	CoreLog
.28fb	20 41 28	jsr $2841			jsr 	CompletePolynomial
.28fe	68		pla				pla 								; add exponent
.28ff	18		clc				clc
.2900	69 1f		adc #$1f			adc 	#31 						; fix up
.2902	48		pha				pha
.2903	10 03		bpl $2908			bpl 	_LogNotNeg
.2905	49 ff		eor #$ff			eor 	#$FF
.2907	1a		inc a				inc 	a
.2908					_LogNotNeg:
.2908	e8		inx				inx 								; set byte and sign.
.2909	20 6a 26	jsr $266a			jsr 	FloatSetByte
.290c	68		pla				pla
.290d	29 80		and #$80			and 	#$80
.290f	95 32		sta $32,x			sta 	NSStatus,x
.2911	20 8c 20	jsr $208c			jsr 	FloatAdd
.2914	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.2916	20 98 28	jsr $2898			jsr 	LoadConstant
.2919	e8		inx				inx
.291a	20 28 23	jsr $2328			jsr 	FloatMultiply
.291d	18		clc				clc
.291e	60		rts				rts
.291f					_ULRangePla:
.291f	68		pla				pla
.2920					_ULRange:
.2920	38		sec				sec
.2921	60		rts				rts
.2922					CoreLog:
.2922	a9 2a		lda #$2a			lda 	#LogCoefficients & $FF
.2924	a0 27		ldy #$27			ldy 	#LogCoefficients >> 8
.2926	4c 95 29	jmp $2995			jmp 	CorePolySquared
.2929					FloatPI:
.2929	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.292b	20 98 28	jsr $2898			jsr 	LoadConstant
.292e	e8		inx				inx
.292f	18		clc				clc
.2930	60		rts				rts
.2931					FloatPower:
.2931	ca		dex				dex
.2932	8a		txa				txa 							; copy 0 to 2, so we can process it
.2933	a8		tay				tay
.2934	c8		iny				iny
.2935	c8		iny				iny
.2936	20 4c 28	jsr $284c			jsr 	CopyFloatXY
.2939	e8		inx				inx 							; 2 = Log(0)
.293a	e8		inx				inx
.293b	20 bd 28	jsr $28bd			jsr 	FloatLogarithm
.293e	b0 0d		bcs $294d			bcs 	_FPWExit
.2940	20 28 23	jsr $2328			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.2943	8a		txa				txa 							; copy to slot 0
.2944	a8		tay				tay
.2945	88		dey				dey
.2946	20 4c 28	jsr $284c			jsr 	CopyFloatXY
.2949	ca		dex				dex  							; Exponent code.
.294a	20 ba 27	jsr $27ba			jsr 	FloatExponent
.294d					_FPWExit:
.294d	60		rts				rts
.294e					FloatSine:
.294e	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.2950	48		pha				pha
.2951	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.2953	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.2955	20 98 28	jsr $2898			jsr 	LoadConstant
.2958	e8		inx				inx
.2959	20 28 23	jsr $2328			jsr 	FloatMultiply
.295c	20 48 22	jsr $2248			jsr 	FloatFractionalPart 		; take the fractional part
.295f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.2961	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.2963	90 1f		bcc $2984			bcc 	_USProcessExit
.2965	f0 06		beq $296d			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.2967	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.2969	c9 60		cmp #$60			cmp 	#$60
.296b	b0 0e		bcs $297b			bcs 	_USSubtractOne
.296d					_USSubtractFromHalf:
.296d	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.296f	20 98 28	jsr $2898			jsr 	LoadConstant
.2972	e8		inx				inx
.2973	20 86 20	jsr $2086			jsr 	FloatSubtract
.2976	20 2a 26	jsr $262a			jsr 	FloatNegate 				; then negate it
.2979	80 09		bra $2984			bra 	_USProcessExit 				; and exit
.297b					_USSubtractOne:
.297b	e8		inx				inx
.297c	a9 01		lda #$01			lda 	#1
.297e	20 6a 26	jsr $266a			jsr 	FloatSetByte
.2981	20 86 20	jsr $2086			jsr 	FloatSubtract
.2984					_USProcessExit:
.2984	20 91 29	jsr $2991			jsr 	CoreSine
.2987	20 41 28	jsr $2841			jsr 	CompletePolynomial
.298a	68		pla				pla 								; restore sign and apply
.298b	55 32		eor $32,x			eor 	NSStatus,x
.298d	95 32		sta $32,x			sta 	NSStatus,x
.298f	18		clc				clc
.2990	60		rts				rts
.2991					CoreSine:
.2991	a9 06		lda #$06			lda 	#SinCoefficients & $FF
.2993	a0 27		ldy #$27			ldy 	#SinCoefficients >> 8
.2995					CorePolySquared:
.2995	48		pha				pha 								; save coefficient table
.2996	5a		phy				phy
.2997	8a		txa				txa 								; copy X to +1, +2
.2998	a8		tay				tay
.2999	c8		iny				iny
.299a	20 4c 28	jsr $284c			jsr 	CopyFloatXY
.299d	c8		iny				iny
.299e	20 4c 28	jsr $284c			jsr 	CopyFloatXY
.29a1	e8		inx				inx 								; point to the pair and put x^2 on stack
.29a2	e8		inx				inx
.29a3	20 28 23	jsr $2328			jsr 	FloatMultiply
.29a6	7a		ply				ply 								; coefficient table back.
.29a7	68		pla				pla
.29a8	20 15 28	jsr $2815			jsr 	CalculateHornerPolynomial
.29ab	8a		txa				txa 								; copy back to slot #1
.29ac	a8		tay				tay
.29ad	88		dey				dey
.29ae	20 4c 28	jsr $284c			jsr	 	CopyFloatXY
.29b1	ca		dex				dex 								; point at result
.29b2	60		rts				rts
.29b3					FloatSquareRoot:
.29b3	20 bd 28	jsr $28bd			jsr 	FloatLogarithm
.29b6	b0 06		bcs $29be			bcs 	_FSQExit
.29b8	d6 6e		dec $6e,x			dec 	NSExponent,x
.29ba	20 ba 27	jsr $27ba			jsr 	FloatExponent
.29bd	18		clc				clc
.29be					_FSQExit:
.29be	60		rts				rts
.29bf					FloatTangent:
.29bf	da		phx				phx
.29c0	8a		txa				txa 								; sin -> +1
.29c1	a8		tay				tay
.29c2	c8		iny				iny
.29c3	20 4c 28	jsr $284c			jsr 	CopyFloatXY
.29c6	e8		inx				inx
.29c7	20 4e 29	jsr $294e			jsr 	FloatSine
.29ca	ca		dex				dex
.29cb	8a		txa				txa 								; cos -> +2
.29cc	a8		tay				tay
.29cd	c8		iny				iny
.29ce	c8		iny				iny
.29cf	20 4c 28	jsr $284c			jsr 	CopyFloatXY
.29d2	e8		inx				inx
.29d3	e8		inx				inx
.29d4	20 ae 27	jsr $27ae			jsr 	FloatCosine
.29d7	20 b1 21	jsr $21b1			jsr 	FloatDivide 				; calculate sin/cos
.29da	b0 07		bcs $29e3			bcs 	_FTExit 					; divide by zero
.29dc	8a		txa				txa 								; copy result down.
.29dd	a8		tay				tay
.29de	88		dey				dey
.29df	20 4c 28	jsr $284c			jsr 	CopyFloatXY
.29e2	18		clc				clc
.29e3					_FTExit:
.29e3	fa		plx				plx
.29e4	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.007a					srcPtr:
>007a							.fill 	2
.05ba					currentLineNumber:
>05ba							.fill 	2
.29e5					InlineNonDecimal:
.29e5	a2 02		ldx #$02			ldx 	#2 							; get size in X
.29e7	c9 25		cmp #$25			cmp 	#"%"
.29e9	f0 02		beq $29ed			beq 	_INDBinary
.29eb	a2 10		ldx #$10			ldx 	#16
.29ed					_INDBinary:
.29ed	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.29ef	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.29f1	64 2c		stz $2c				stz 	zTemp0 						; zero result
.29f3	64 2d		stz $2d				stz 	zTemp0+1
.29f5					_INDLoop:
.29f5	20 91 33	jsr $3391			jsr 	LookNext 					; check next character
.29f8	20 cd 33	jsr $33cd			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.29fb	90 1f		bcc $2a1c			bcc		_INDDone 					; didn't convert
.29fd	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.29ff	b0 1b		bcs $2a1c			bcs 	_INDDone
.2a01	20 2b 2a	jsr $2a2b			jsr 	_INDShift 					; x 2 or x 16
.2a04	e0 02		cpx #$02			cpx 	#2
.2a06	f0 09		beq $2a11			beq 	_INDNotHex
.2a08	20 2b 2a	jsr $2a2b			jsr 	_INDShift
.2a0b	20 2b 2a	jsr $2a2b			jsr 	_INDShift
.2a0e	20 2b 2a	jsr $2a2b			jsr 	_INDShift
.2a11					_INDNotHex:
.2a11	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.2a13	85 2c		sta $2c				sta 	zTemp0
.2a15	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume
.2a18	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.2a1a	80 d9		bra $29f5			bra 	_INDLoop
.2a1c					_INDDone:
.2a1c	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.2a1e	f0 08		beq $2a28			beq 	_INDError
.2a20	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.2a22	a5 2c		lda $2c				lda 	zTemp0
.2a24	20 4d 2b	jsr $2b4d			jsr 	PushIntegerYA
.2a27	60		rts				rts
.2a28					_INDError:
.2a28	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.2a2b					_INDShift:
.2a2b	06 2c		asl $2c				asl 	zTemp0
.2a2d	26 2d		rol $2d				rol 	zTemp0+1
.2a2f	60		rts				rts
.2a30					GetLineNumber:
.2a30	ac bb 05	ldy $05bb			ldy 	currentLineNumber+1
.2a33	ad ba 05	lda $05ba			lda 	currentLineNumber
.2a36	60		rts				rts
.2a37					WriteCodeByte:
.2a37	48		pha				pha 								; save on stack
.2a38	da		phx				phx
.2a39	5a		phy				phy
.2a3a	aa		tax				tax
.2a3b	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.2a3d	20 4a 2b	jsr $2b4a			jsr 	CallAPIHandler
.2a40	7a		ply				ply 								; restore from stack
.2a41	fa		plx				plx
.2a42	68		pla				pla
.2a43	60		rts				rts
.2a44					PrintCharacter
.2a44	48		pha				pha
.2a45	da		phx				phx
.2a46	5a		phy				phy
.2a47	aa		tax				tax
.2a48	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.2a4a	20 4a 2b	jsr $2b4a			jsr 	CallAPIHandler
.2a4d	7a		ply				ply
.2a4e	fa		plx				plx
.2a4f	68		pla				pla
.2a50	60		rts				rts
.2a51					ProcessNewLine:
.2a51	86 2c		stx $2c				stx 	zTemp0 						; save address in zTemp0
.2a53	84 2d		sty $2d				sty 	zTemp0+1
.2a55	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.2a56	8a		txa				txa
.2a57	69 04		adc #$04			adc 	#4
.2a59	85 7a		sta $7a				sta 	srcPtr
.2a5b	98		tya				tya
.2a5c	69 00		adc #$00			adc 	#0
.2a5e	85 7b		sta $7b				sta 	srcPtr+1
.2a60	a0 02		ldy #$02			ldy 	#2							; read and save line number
.2a62	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a64	8d ba 05	sta $05ba			sta 	currentLineNumber
.2a67	c8		iny				iny
.2a68	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a6a	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2a6d	60		rts				rts
.2a6e					BufferClear:
.2a6e	9c bc 05	stz $05bc			stz 	bufferSize
.2a71	60		rts				rts
.2a72					BufferWrite:
.2a72	da		phx				phx
.2a73	ae bc 05	ldx $05bc			ldx 	bufferSize
.2a76	9d bd 05	sta $05bd,x			sta 	dataBuffer,x
.2a79	ee bc 05	inc $05bc			inc 	bufferSize
.2a7c	fa		plx				plx
.2a7d	60		rts				rts
.2a7e					BufferOutput:
.2a7e	ad bc 05	lda $05bc			lda 	bufferSize
.2a81	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2a84	a2 00		ldx #$00			ldx 	#0
.2a86					_BOLoop:
.2a86	ec bc 05	cpx $05bc			cpx 	bufferSize
.2a89	f0 09		beq $2a94			beq 	_BOExit
.2a8b	bd bd 05	lda $05bd,x			lda 	dataBuffer,x
.2a8e	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2a91	e8		inx				inx
.2a92	80 f2		bra $2a86			bra 	_BOLoop
.2a94					_BOExit:
.2a94	60		rts				rts
.05bc					bufferSize:
>05bc							.fill 	1
.05bd					dataBuffer:
>05bd							.fill 	256
.2a95					CheckNextComma:
.2a95	a9 2c		lda #$2c			lda	 	#","
.2a97	80 06		bra $2a9f			bra 	CheckNextA
.2a99					CheckNextRParen:
.2a99	a9 29		lda #$29			lda	 	#")"
.2a9b	80 02		bra $2a9f			bra 	CheckNextA
.2a9d					CheckNextLParen:
.2a9d	a9 28		lda #$28			lda 	#"("
.2a9f					CheckNextA:
.2a9f	8d bd 06	sta $06bd			sta 	checkCharacter 				; save test character
.2aa2					_CNALoop:
.2aa2	20 ad 33	jsr $33ad			jsr 	GetNextNonSpace 			; get next skipping spaces.
.2aa5	cd bd 06	cmp $06bd			cmp 	checkCharacter 				; matches ?
.2aa8	f0 03		beq $2aad			beq 	_CNAExit
.2aaa	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.2aad					_CNAExit:
.2aad	60		rts				rts
.06bd					checkCharacter:
>06bd							.fill 	1
.2aae					StartCompiler:
.2aae	86 2c		stx $2c				stx 	zTemp0 						; access API
.2ab0	84 2d		sty $2d				sty 	zTemp0+1
.2ab2	a0 2d		ldy #$2d			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.2ab4	a2 06		ldx #$06			ldx 	#CompilerErrorHandler & $FF
.2ab6	20 ea 1e	jsr $1eea			jsr 	SetErrorHandler
.2ab9	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.2abb	b2 2c		lda ($2c)			lda 	(zTemp0)
.2abd	8d bf 06	sta $06bf			sta 	APIVector
.2ac0	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ac2	8d c0 06	sta $06c0			sta 	APIVector+1
.2ac5	c8		iny				iny 								; copy data area range.
.2ac6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ac8	8d c1 06	sta $06c1			sta 	compilerStartHigh
.2acb	c8		iny				iny
.2acc	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ace	8d c2 06	sta $06c2			sta 	compilerEndHigh
.2ad1	ba		tsx				tsx 								; save stack pointer
.2ad2	8e be 06	stx $06be			stx 	compilerSP
.2ad5	20 31 37	jsr $3731			jsr 	STRReset 					; reset storage (line#, variable)
.2ad8	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.2ada	20 4a 2b	jsr $2b4a			jsr 	CallAPIHandler
.2add	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.2adf	20 4a 2b	jsr $2b4a			jsr 	CallAPIHandler
.2ae2	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.2ae4	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2ae7	a9 00		lda #$00			lda 	#0
.2ae9	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2aec	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2aef					MainCompileLoop:
.2aef	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.2af1	20 4a 2b	jsr $2b4a			jsr 	CallAPIHandler
.2af4	90 31		bcc $2b27			bcc 	SaveCodeAndExit 			; end of source.
.2af6	20 51 2a	jsr $2a51			jsr 	ProcessNewLine 				; set up pointer and line number.
.2af9	20 30 2a	jsr $2a30			jsr 	GetLineNumber 				; get line #
.2afc	20 1b 35	jsr $351b			jsr 	STRMarkLine 				; remember the code position and number of this line.
.2aff	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.2b01	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2b04					_MCLSameLine:
.2b04	20 ad 33	jsr $33ad			jsr 	GetNextNonSpace 			; get the first character.
.2b07	f0 e6		beq $2aef			beq 	MainCompileLoop 			; end of line, get next line.
.2b09	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.2b0b	f0 f7		beq $2b04			beq 	_MCLSameLine
.2b0d	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.2b0f	10 0c		bpl $2b1d			bpl 	_MCLCheckAssignment
.2b11	a2 6b		ldx #$6b			ldx 	#CommandTables & $FF 		; do command tables.
.2b13	a0 2f		ldy #$2f			ldy 	#CommandTables >> 8
.2b15	20 33 32	jsr $3233			jsr 	GeneratorProcess
.2b18	b0 ea		bcs $2b04			bcs 	_MCLSameLine 				; keep trying to compile the line.
.2b1a					_MCLSyntax:
.2b1a	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.2b1d					_MCLCheckAssignment:
.2b1d	20 c3 33	jsr $33c3			jsr 	CharIsAlpha 				; if not alpha then syntax error
.2b20	90 f8		bcc $2b1a			bcc 	_MCLSyntax
.2b22	20 e9 34	jsr $34e9			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.2b25	80 dd		bra $2b04			bra		_MCLSameLine 				; loop back.
.2b27					SaveCodeAndExit:
.2b27	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.2b29	20 4a 2b	jsr $2b4a			jsr 	CallAPIHandler
.2b2c	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.2b2e	a8		tay				tay
.2b2f	20 1b 35	jsr $351b			jsr 	STRMarkLine
.2b32	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.2b34	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2b37	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.2b39	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2b3c	20 63 2e	jsr $2e63			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.2b3f	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.2b41	20 4a 2b	jsr $2b4a			jsr 	CallAPIHandler
.2b44	18		clc				clc 								; CC = success
.2b45					ExitCompiler:
.2b45	ae be 06	ldx $06be			ldx 	compilerSP 					; reload SP and exit.
.2b48	9a		txs				txs
.2b49	60		rts				rts
.2b4a					CallAPIHandler:
.2b4a	6c bf 06	jmp ($06bf)			jmp 	(APIVector)
.06be					compilerSP:
>06be							.fill 	1
.06bf					APIVector:
>06bf							.fill 	2
.06c1					compilerStartHigh:
>06c1							.fill 	1
.06c2					compilerEndHigh:
>06c2							.fill 	1
.2b4d					PushIntegerYA:
.2b4d	c0 00		cpy #$00			cpy 	#0 							; 0-255
.2b4f	f0 0f		beq $2b60			beq 	PushIntegerA
.2b51	48		pha				pha
.2b52	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.2b54	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2b57	68		pla				pla 								; then LSB
.2b58	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2b5b	98		tya				tya 								; then MSB
.2b5c	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2b5f	60		rts				rts
.2b60					PushIntegerA:
.2b60	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.2b62	90 07		bcc $2b6b			bcc 	_PIWriteA
.2b64	48		pha				pha
.2b65	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.2b67	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2b6a	68		pla				pla
.2b6b					_PIWriteA:
.2b6b	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2b6e	60		rts				rts
.2b6f					PushFloatCommand:
.2b6f	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.2b71	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2b74	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.2b76	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2b79	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2b7b	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2b7e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2b80	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2b83	b5 56		lda $56,x			lda 	NSMantissa2,x
.2b85	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2b88	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.2b8a	29 80		and #$80			and 	#$80
.2b8c	15 62		ora $62,x			ora 	NSMantissa3,x
.2b8e	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2b91	60		rts				rts
.2b92					CreateVariableRecord:
.2b92	48		pha				pha
.2b93	ad cd 06	lda $06cd			lda 	freeVariableMemory 		; push current free address on stack.
.2b96	48		pha				pha
.2b97	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2b9a	48		pha				pha
.2b9b	ad cb 06	lda $06cb			lda 	variableListEnd  		; copy end of list to zTemp0
.2b9e	85 2c		sta $2c				sta 	zTemp0
.2ba0	ad cc 06	lda $06cc			lda 	variableListEnd+1
.2ba3	85 2d		sta $2d				sta 	zTemp0+1
.2ba5	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.2ba7	92 2c		sta ($2c)			sta 	(zTemp0)
.2ba9	98		tya				tya
.2baa	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.2bac	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bae	88		dey				dey
.2baf	8a		txa				txa
.2bb0	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bb2	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.2bb4	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2bb7	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bb9	c8		iny				iny
.2bba	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2bbd	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bbf	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.2bc1	a9 00		lda #$00			lda 	#0
.2bc3	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bc5	18		clc				clc
.2bc6	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.2bc8	6d cb 06	adc $06cb			adc  	variableListEnd
.2bcb	8d cb 06	sta $06cb			sta 	variableListEnd
.2bce	90 03		bcc $2bd3			bcc 	_CVNoCarry2
.2bd0	ee cc 06	inc $06cc			inc 	variableListEnd+1
.2bd3					_CVNoCarry2:
.2bd3	7a		ply				ply
.2bd4	fa		plx				plx
.2bd5	68		pla				pla
.2bd6	60		rts				rts
.2bd7					SetVariableRecordToCodePosition:
.2bd7	48		pha				pha
.2bd8	5a		phy				phy
.2bd9	a0 03		ldy #$03			ldy 	#3
.2bdb	a5 2b		lda $2b				lda 	objPtr+1
.2bdd	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bdf	c8		iny				iny
.2be0	a5 2a		lda $2a				lda 	objPtr
.2be2	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2be4	7a		ply				ply
.2be5	68		pla				pla
.2be6	60		rts				rts
.2be7					AllocateBytesForType:
.2be7	48		pha				pha
.2be8	da		phx				phx
.2be9	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.2beb	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2bed	c9 00		cmp #$00			cmp 	#NSSIFloat
.2bef	d0 02		bne $2bf3			bne 	_CVNotFloat
.2bf1	a2 06		ldx #$06			ldx 	#6
.2bf3					_CVNotFloat:
.2bf3	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.2bf4	18		clc				clc
.2bf5	6d cd 06	adc $06cd			adc 	freeVariableMemory
.2bf8	8d cd 06	sta $06cd			sta 	freeVariableMemory
.2bfb	90 03		bcc $2c00			bcc 	_CVNoCarry1
.2bfd	ee ce 06	inc $06ce			inc 	freeVariableMemory+1
.2c00					_CVNoCarry1:
.2c00	fa		plx				plx
.2c01	68		pla				pla
.2c02	60		rts				rts
.2c03					CommandDATA:
.2c03	20 6e 2a	jsr $2a6e			jsr 	BufferClear 				; copy it to the buffer
.2c06	20 94 33	jsr $3394			jsr 	LookNextNonSpace
.2c09					_CTDataLoop:
.2c09	20 91 33	jsr $3391			jsr 	LookNext 					; reached EOL
.2c0c	f0 08		beq $2c16			beq 	_CTDataDone
.2c0e	20 72 2a	jsr $2a72			jsr 	BufferWrite 				; write and consume
.2c11	20 a2 33	jsr $33a2			jsr 	GetNext
.2c14	80 f3		bra $2c09			bra 	_CTDataLoop
.2c16					_CTDataDone:
.2c16	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.2c18	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2c1b	20 7e 2a	jsr $2a7e			jsr 	BufferOutput
.2c1e	60		rts				rts
.2c1f					CommandDEF:
.2c1f	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.2c21	20 60 2b	jsr $2b60			jsr 	PushIntegerA
.2c24	20 b2 34	jsr $34b2			jsr 	CompileGotoEOL 				; compile skip over DEF
.2c27	a9 a5		lda #$a5			lda 	#C64_FN
.2c29	20 9f 2a	jsr $2a9f			jsr 	CheckNextA
.2c2c	20 ad 33	jsr $33ad			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2c2f	20 12 34	jsr $3412			jsr 	ExtractVariableName
.2c32	8a		txa				txa
.2c33	10 51		bpl $2c86			bpl 	_CDError
.2c35	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2c36	29 7f		and #$7f			and 	#$7F
.2c38	aa		tax				tax
.2c39	98		tya				tya
.2c3a	09 80		ora #$80			ora 	#$80
.2c3c	a8		tay				tay
.2c3d	20 07 2e	jsr $2e07			jsr 	FindVariable				; does it already exist ?
.2c40	b0 44		bcs $2c86			bcs 	_CDError 					; if so, that's an error.
.2c42	20 92 2b	jsr $2b92			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.2c45	20 d7 2b	jsr $2bd7			jsr 	SetVariableRecordToCodePosition
.2c48	20 ad 33	jsr $33ad			jsr 	GetNextNonSpace
.2c4b	20 ee 36	jsr $36ee			jsr 	GetReferenceTerm 			; get var ref, not array
.2c4e	c9 00		cmp #$00			cmp 	#0
.2c50	30 34		bmi $2c86			bmi 	_CDError
.2c52	8d c3 06	sta $06c3			sta 	defType 					; save type
.2c55	8e c4 06	stx $06c4			stx 	defVariable 				; save var ref
.2c58	8c c5 06	sty $06c5			sty 	defVariable+1
.2c5b	29 40		and #$40			and 	#NSSString 					; only numbers.
.2c5d	d0 27		bne $2c86			bne 	_CDError
.2c5f	20 99 2a	jsr $2a99			jsr 	CheckNextRParen 			; check )
.2c62	a9 b2		lda #$b2			lda 	#C64_EQUAL
.2c64	20 9f 2a	jsr $2a9f			jsr 	CheckNextA 					; check =
.2c67	18		clc				clc 								; if this is DEF FNxx(A), read A
.2c68	20 89 2c	jsr $2c89			jsr 	CDReadWriteVariable
.2c6b	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2c6d	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2c70	38		sec				sec
.2c71	20 89 2c	jsr $2c89			jsr 	CDReadWriteVariable 		; A is now updated
.2c74	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAt0 		; the actual body of the function.
.2c77	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2c79	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2c7c	38		sec				sec
.2c7d	20 89 2c	jsr $2c89			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.2c80	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.2c82	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2c85	60		rts				rts
.2c86					_CDError:
.2c86	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.2c89					CDReadWriteVariable:
.2c89	ac c5 06	ldy $06c5			ldy 	defVariable+1 				; set up YX
.2c8c	ae c4 06	ldx $06c4			ldx 	defVariable
.2c8f	ad c3 06	lda $06c3			lda 	defType
.2c92	20 a0 36	jsr $36a0			jsr 	GetSetVariable
.2c95	60		rts				rts
.06c3					defType:
>06c3							.fill 	1
.06c4					defVariable:
>06c4							.fill 	2
.2c96					CommandDIM:
.2c96	20 ad 33	jsr $33ad			jsr 	GetNextNonSpace 			; get the first non space character
.2c99	20 12 34	jsr $3412			jsr 	ExtractVariableName 		; variable name to XY
.2c9c	da		phx				phx 								; save name with type bits.
.2c9d	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.2c9f	10 37		bpl $2cd8			bpl 	_CDError
.2ca1	20 07 2e	jsr $2e07			jsr 	FindVariable	 			; see if already exist
.2ca4	b0 35		bcs $2cdb			bcs 	_CDRedefine 				; it still exists.
.2ca6	20 92 2b	jsr $2b92			jsr 	CreateVariableRecord 		; create the basic variable
.2ca9	20 e7 2b	jsr $2be7			jsr 	AllocateBytesForType 		; allocate memory for it
.2cac	68		pla				pla 								; restore type bits
.2cad	5a		phy				phy 								; save the address of the basic storage
.2cae	da		phx				phx
.2caf	48		pha				pha
.2cb0	20 de 2c	jsr $2cde			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.2cb3	68		pla				pla
.2cb4	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.2cb6	20 60 2b	jsr $2b60			jsr 	PushIntegerA 				; push that type data out.
.2cb9	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.2cbb	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2cbe	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.2cc0	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2cc3	fa		plx				plx 								; restore address
.2cc4	7a		ply				ply
.2cc5	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2cc7	38		sec				sec
.2cc8	20 a0 36	jsr $36a0			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.2ccb	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; , follows ?
.2cce	c9 2c		cmp #$2c			cmp 	#","
.2cd0	d0 05		bne $2cd7			bne 	_CDExit
.2cd2	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume comma
.2cd5	80 bf		bra $2c96			bra 	CommandDIM 					; do another DIM
.2cd7					_CDExit:
.2cd7	60		rts				rts
.2cd8					_CDError:
.2cd8	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.2cdb					_CDRedefine:
.2cdb	4c d9 1f	jmp $1fd9		jmp	ErrorV_redefine
.2cde					OutputIndexGroup:
.2cde	9c c6 06	stz $06c6			stz 	IndexCount 					; count of number of indices.
.2ce1					_OIGNext:
.2ce1	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAt0 		; get a dimension
.2ce4	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ce6	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ce8	d0 19		bne $2d03			bne 	_OIGType
.2cea	ee c6 06	inc $06c6			inc 	IndexCount 					; bump the counter.
.2ced	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; does a , follow ?
.2cf0	c9 2c		cmp #$2c			cmp 	#","
.2cf2	d0 05		bne $2cf9			bne 	_OIGCheckEnd
.2cf4	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume comma
.2cf7	80 e8		bra $2ce1			bra 	_OIGNext 					; get next dimension
.2cf9					_OIGCheckEnd:
.2cf9	20 99 2a	jsr $2a99			jsr 	CheckNextRParen 			; check and consume )
.2cfc	ad c6 06	lda $06c6			lda 	IndexCount
.2cff	20 60 2b	jsr $2b60			jsr 	PushIntegerA 				; compile the dimension count.
.2d02	60		rts				rts
.2d03					_OIGType:
.2d03	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.06c6					IndexCount:
>06c6							.fill 	1
.2d06					CompilerErrorHandler:
.2d06	68		pla				pla
.2d07	7a		ply				ply
.2d08	85 2c		sta $2c				sta 	zTemp0
.2d0a	84 2d		sty $2d				sty 	zTemp0+1
.2d0c	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.2d0e	a0 01		ldy #$01			ldy 	#1
.2d10					_EHDisplayMsg:
.2d10	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d12	20 44 2a	jsr $2a44			jsr 	PrintCharacter
.2d15	c8		iny				iny
.2d16	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d18	d0 f6		bne $2d10			bne 	_EHDisplayMsg
.2d1a	a9 20		lda #$20			lda 	#32
.2d1c	20 44 2a	jsr $2a44			jsr 	PrintCharacter
.2d1f	a9 40		lda #$40			lda 	#64
.2d21	20 44 2a	jsr $2a44			jsr 	PrintCharacter
.2d24	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.2d26	20 6a 26	jsr $266a			jsr 	FloatSetByte
.2d29	20 30 2a	jsr $2a30			jsr 	GetLineNumber
.2d2c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2d2e	98		tya				tya
.2d2f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2d31	20 50 25	jsr $2550			jsr 	FloatToString
.2d34	a0 00		ldy #$00			ldy 	#0 							; display that string.
.2d36	a2 00		ldx #$00			ldx 	#0
.2d38					_EHDisplayLine:
.2d38	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d3b	20 44 2a	jsr $2a44			jsr 	PrintCharacter
.2d3e	c8		iny				iny
.2d3f	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d42	d0 f4		bne $2d38			bne 	_EHDisplayLine
.2d44	a9 0d		lda #$0d			lda 	#13
.2d46	20 44 2a	jsr $2a44			jsr 	PrintCharacter
.2d49	38		sec				sec 								; CS = error
.2d4a	4c 45 2b	jmp $2b45			jmp 	ExitCompiler
.2d4d					CompileExpressionAt0:
.2d4d	a9 00		lda #$00			lda 	#0
.2d4f					CompileExpressionAtA:
.2d4f	48		pha				pha  								; save level
.2d50	20 59 37	jsr $3759			jsr 	CompileTerm 				; compile a term.
.2d53	fa		plx				plx 								; get level back into X
.2d54					_ECALoop:
.2d54	48		pha				pha 								; save type on stack.
.2d55	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; get the next character
.2d58	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.2d5a	90 04		bcc $2d60			bcc 	_ECAExit
.2d5c	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.2d5e	90 02		bcc $2d62			bcc 	_ECAHaveToken
.2d60					_ECAExit:
.2d60	68		pla				pla 								; throw type off stack
.2d61	60		rts				rts
.2d62					_ECAHaveToken:
.2d62	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.2d64	aa		tax				tax 								; X contains the operator token
.2d65	bd 50 2d	lda $2d50,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.2d68	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.2d6a	90 f4		bcc $2d60			bcc 	_ECAExit
.2d6c	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.2d6e	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume the token.
.2d71	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.2d73	f0 11		beq $2d86			beq 	_ECAGreaterCheck
.2d75	e0 b3		cpx #$b3			cpx 	#C64_LESS
.2d77	d0 1a		bne $2d93			bne 	_ECAHaveFullToken
.2d79	20 91 33	jsr $3391			jsr 	LookNext 					; checks for < (<= or <>)
.2d7c	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.2d7e	f0 0e		beq $2d8e			beq	 	_ECAToNotEqual
.2d80	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.2d82	d0 0f		bne $2d93			bne 	_ECAHaveFullToken
.2d84	80 07		bra $2d8d			bra 	_ECAAddEqual
.2d86					_ECAGreaterCheck:
.2d86	20 91 33	jsr $3391			jsr 	LookNext
.2d89	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.2d8b	d0 06		bne $2d93			bne 	_ECAHaveFullToken
.2d8d					_ECAAddEqual:
.2d8d	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.2d8e					_ECAToNotEqual:
.2d8e	e8		inx				inx
.2d8f	e8		inx				inx
.2d90	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume the = or > in >= <= <>
.2d93					_ECAHaveFullToken:
.2d93	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.2d95	d0 0a		bne $2da1			bne 	_ECANotConcat
.2d97	68		pla				pla 								; get type back
.2d98	48		pha				pha
.2d99	29 40		and #$40			and 	#NSSTypeMask
.2d9b	c9 40		cmp #$40			cmp 	#NSSString
.2d9d	d0 02		bne $2da1			bne 	_ECANotConcat
.2d9f	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2da1					_ECANotConcat:
.2da1	da		phx				phx 								; save operator on the stack
.2da2	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.2da4	da		phx				phx
.2da5	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.2da7	1a		inc a				inc 	a
.2da8	20 4f 2d	jsr $2d4f			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.2dab	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.2dad	fa		plx				plx 								; restore current precedence in X
.2dae	68		pla				pla 								; restore operator
.2daf	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.2db1	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.2db3	90 17		bcc $2dcc			bcc 	_ECANotCompare
.2db5	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.2db7	b0 13		bcs $2dcc			bcs 	_ECANotCompare
.2db9	7a		ply				ply 								; get type into Y
.2dba	5a		phy				phy
.2dbb	48		pha				pha 								; save operator
.2dbc	98		tya				tya 								; get type
.2dbd	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.2dbf	29 40		and #$40			and 	#NSSTypeMask
.2dc1	c9 40		cmp #$40			cmp 	#NSSString
.2dc3	f0 02		beq $2dc7			beq 	_ECANotString
.2dc5	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.2dc7					_ECANotString:
.2dc7	98		tya				tya									; output token Y
.2dc8	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2dcb	68		pla				pla 								; restore operator.
.2dcc					_ECANotCompare:
.2dcc	18		clc				clc 								; convert to P-Code and compile.
.2dcd	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.2dcf	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2dd2	68		pla				pla 								; type of current result
.2dd3	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.2dd5	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.2dd7	d0 19		bne $2df2			bne		_ECAType
.2dd9	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.2ddb	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.2ddd	d0 18		bne $2df7			bne 	_ECAGoLoop
.2ddf	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.2de1	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2de3	f0 10		beq $2df5			beq 	_ECAOkayString 				; (this is post conversion)
.2de5	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.2de7	90 09		bcc $2df2			bcc 	_ECAType
.2de9	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.2deb	b0 05		bcs $2df2			bcs 	_ECAType
.2ded	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.2def	4c 54 2d	jmp $2d54			jmp 	_ECALoop
.2df2					_ECAType:
.2df2	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.2df5					_ECAOkayString:
.2df5	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.2df7					_ECAGoLoop:
.2df7	4c 54 2d	jmp $2d54			jmp 	_ECALoop
.2dfa					PrecedenceTable:
>2dfa	03						.byte 	3 					; '+'
>2dfb	03						.byte 	3 					; '-'
>2dfc	04						.byte 	4 					; '*'
>2dfd	04						.byte 	4 					; '/'
>2dfe	05						.byte 	5 					; '^'
>2dff	01						.byte 	1 					; 'and'
>2e00	00						.byte 	0 					; 'or'
>2e01	02						.byte 	2 					; '>'
>2e02	02						.byte 	2 					; '='
>2e03	02						.byte 	2 					; '<'
>2e04	02						.byte 	2 					; '>='
>2e05	02						.byte 	2 					; '<='
>2e06	02						.byte 	2 					; '<>'
.2e07					FindVariable:
.2e07	86 2e		stx $2e				stx 	zTemp1 						; save name.
.2e09	84 2f		sty $2f				sty 	zTemp1+1
.2e0b					_IVCheckSpecial:
.2e0b	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.2e0d	d0 18		bne $2e27			bne 	_IVStandard
.2e0f	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.2e11	f0 0c		beq $2e1f			beq 	_IVTIFloat
.2e13	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.2e15	d0 10		bne $2e27			bne 	_IVStandard
.2e17	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.2e19	a2 01		ldx #$01			ldx 	#$01
.2e1b	a9 40		lda #$40			lda 	#NSSString
.2e1d	38		sec				sec
.2e1e	60		rts				rts
.2e1f					_IVTIFloat:
.2e1f	a0 80		ldy #$80			ldy 	#$80
.2e21	a2 00		ldx #$00			ldx 	#$00
.2e23	a9 00		lda #$00			lda 	#0
.2e25	38		sec				sec
.2e26	60		rts				rts
.2e27					_IVStandard:
.2e27	ad c1 06	lda $06c1			lda 	compilerStartHigh			; start scanning from here.
.2e2a	85 2d		sta $2d				sta 	zTemp0+1
.2e2c	64 2c		stz $2c				stz 	zTemp0
.2e2e					_IVCheckLoop:
.2e2e	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.2e30	f0 2b		beq $2e5d			beq  	_IVNotFound 				; if so, return with CC.
.2e32	a0 01		ldy #$01			ldy 	#1 							; match ?
.2e34	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e36	c5 2e		cmp $2e				cmp 	zTemp1
.2e38	d0 07		bne $2e41			bne	 	_IVNext
.2e3a	c8		iny				iny
.2e3b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e3d	c5 2f		cmp $2f				cmp 	zTemp1+1
.2e3f	f0 0d		beq $2e4e			beq 	_IVFound
.2e41					_IVNext:
.2e41	18		clc				clc
.2e42	a5 2c		lda $2c				lda 	zTemp0
.2e44	72 2c		adc ($2c)			adc 	(zTemp0)
.2e46	85 2c		sta $2c				sta 	zTemp0
.2e48	90 e4		bcc $2e2e			bcc 	_IVCheckLoop
.2e4a	e6 2d		inc $2d				inc 	zTemp0+1
.2e4c	80 e0		bra $2e2e			bra 	_IVCheckLoop
.2e4e					_IVFound:
.2e4e	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.2e50	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e52	aa		tax				tax
.2e53	c8		iny				iny
.2e54	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e56	48		pha				pha
.2e57	c8		iny				iny
.2e58	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e5a	7a		ply				ply
.2e5b	38		sec				sec
.2e5c	60		rts				rts
.2e5d					_IVNotFound:
.2e5d	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.2e5f	a4 2f		ldy $2f				ldy 	zTemp1+1
.2e61	18		clc				clc
.2e62	60		rts				rts
.2e63					FixBranches:
.2e63	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.2e65	20 4a 2b	jsr $2b4a			jsr 	CallAPIHandler
.2e68					_FBLoop:
.2e68	b2 2a		lda ($2a)			lda 	(objPtr) 					; get the next one.
.2e6a	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.2e6c	f0 16		beq $2e84			beq 	_FBFixGotoGosub
.2e6e	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.2e70	f0 12		beq $2e84			beq 	_FBFixGotoGosub
.2e72	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.2e74	f0 0e		beq $2e84			beq 	_FBFixGotoGosub
.2e76	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.2e78	f0 0a		beq $2e84			beq 	_FBFixGotoGosub
.2e7a	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.2e7c	f0 3b		beq $2eb9			beq 	_FBFixVarSpace
.2e7e					_FBNext:
.2e7e	20 37 20	jsr $2037			jsr 	MoveObjectForward 			; move forward in object code.
.2e81	90 e5		bcc $2e68			bcc 	_FBLoop 					; not finished
.2e83					_FBExit:
.2e83	60		rts				rts
.2e84					_FBFixGotoGosub:
.2e84	a0 01		ldy #$01			ldy 	#1							; line number in YA
.2e86	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e88	48		pha				pha
.2e89	c8		iny				iny
.2e8a	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e8c	a8		tay				tay
.2e8d	68		pla				pla
.2e8e	20 44 35	jsr $3544			jsr 	STRFindLine			 		; find where it is YA
.2e91	90 08		bcc $2e9b			bcc 	_FBFFound 					; not found, so must be >
.2e93	48		pha				pha
.2e94	b2 2a		lda ($2a)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.2e96	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.2e98	d0 0f		bne $2ea9			bne 	_FBFFail
.2e9a	68		pla				pla
.2e9b					_FBFFound:
.2e9b	20 94 35	jsr $3594			jsr 	STRMakeOffset 				; make it an offset from X:YA
.2e9e	5a		phy				phy	 								; patch the GOTO/GOSUB
.2e9f	a0 01		ldy #$01			ldy 	#1
.2ea1	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ea3	c8		iny				iny
.2ea4	68		pla				pla
.2ea5	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ea7	80 d5		bra $2e7e			bra 	_FBNext
.2ea9					_FBFFail:
.2ea9	a0 02		ldy #$02			ldy 	#2
.2eab	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ead	8d ba 05	sta $05ba			sta 	currentLineNumber
.2eb0	c8		iny				iny
.2eb1	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2eb3	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2eb6	4c 54 1f	jmp $1f54		jmp	ErrorV_line
.2eb9					_FBFixVarSpace:
.2eb9	a0 01		ldy #$01			ldy 	#1
.2ebb	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2ebe	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ec0	c8		iny				iny
.2ec1	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2ec4	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ec6	80 b6		bra $2e7e			bra 	_FBNext
.2ec8					CommandFOR:
.2ec8	20 ad 33	jsr $33ad			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.2ecb	20 c3 33	jsr $33c3			jsr 	CharIsAlpha 				; if not alpha , error
.2ece	90 59		bcc $2f29			bcc 	_CFFail
.2ed0	20 ee 36	jsr $36ee			jsr 	GetReferenceTerm 			; figure out the reference.
.2ed3	48		pha				pha 								; save type
.2ed4	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ed6	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ed8	d0 4f		bne $2f29			bne 	_CFFail
.2eda	5a		phy				phy 								; save reference on the stack
.2edb	da		phx				phx
.2edc	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.2ede	20 9f 2a	jsr $2a9f			jsr 	CheckNextA
.2ee1	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAt0 		; initial value
.2ee4	fa		plx				plx 								; get reference back.
.2ee5	7a		ply				ply
.2ee6	5a		phy				phy
.2ee7	da		phx				phx
.2ee8	38		sec				sec 								; set initial value.
.2ee9	20 a0 36	jsr $36a0			jsr 	GetSetVariable
.2eec	fa		plx				plx
.2eed	7a		ply				ply
.2eee	68		pla				pla
.2eef	29 20		and #$20			and 	#NSSIInt16
.2ef1	f0 04		beq $2ef7			beq 	_CFNotInt16
.2ef3	98		tya				tya
.2ef4	09 80		ora #$80			ora 	#$80
.2ef6	a8		tay				tay
.2ef7					_CFNotInt16:
.2ef7	8a		txa				txa 								; reference in YA
.2ef8	20 4d 2b	jsr $2b4d			jsr 	PushIntegerYA
.2efb	a9 a4		lda #$a4			lda 	#C64_TO
.2efd	20 9f 2a	jsr $2a9f			jsr 	CheckNextA
.2f00	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAt0 		; terminal value
.2f03	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f05	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f07	d0 20		bne $2f29			bne 	_CFFail
.2f09	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; followed by STEP
.2f0c	c9 a9		cmp #$a9			cmp 	#C64_STEP
.2f0e	d0 0e		bne $2f1e			bne 	_CFNoStep
.2f10	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume it.
.2f13	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAt0 		; terminal value
.2f16	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f18	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f1a	d0 0d		bne $2f29			bne 	_CFFail
.2f1c	80 05		bra $2f23			bra 	_CFParametersDone
.2f1e					_CFNoStep:
.2f1e	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.2f20	20 60 2b	jsr $2b60			jsr 	PushIntegerA
.2f23					_CFParametersDone:
.2f23	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2f25	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2f28	60		rts				rts
.2f29					_CFFail:
.2f29	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.2f2c					FNCompile:
.2f2c	20 ad 33	jsr $33ad			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2f2f	20 12 34	jsr $3412			jsr 	ExtractVariableName
.2f32	e0 00		cpx #$00			cpx 	#0
.2f34	10 32		bpl $2f68			bpl 	_FNError
.2f36	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2f37	29 7f		and #$7f			and 	#$7F
.2f39	aa		tax				tax
.2f3a	98		tya				tya
.2f3b	09 80		ora #$80			ora 	#$80
.2f3d	a8		tay				tay
.2f3e	20 07 2e	jsr $2e07			jsr 	FindVariable				; does it already exist ?
.2f41	90 25		bcc $2f68			bcc 	_FNError 					; no.
.2f43	20 94 35	jsr $3594			jsr 	STRMakeOffset 				; convert to a relative address.
.2f46	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2f48	d0 01		bne $2f4b			bne 	_FNNoBorrow
.2f4a	88		dey				dey
.2f4b					_FNNoBorrow:
.2f4b	3a		dec a				dec 	a
.2f4c	5a		phy				phy 								; save location of routine on stack.
.2f4d	48		pha				pha
.2f4e	da		phx				phx
.2f4f	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAt0
.2f52	20 99 2a	jsr $2a99			jsr 	CheckNextRParen
.2f55	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.2f57	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2f5a	68		pla				pla
.2f5b	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2f5e	68		pla				pla
.2f5f	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2f62	68		pla				pla
.2f63	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.2f66	18		clc				clc
.2f67	60		rts				rts
.2f68					_FNError:
.2f68	4c 04 1f	jmp $1f04		jmp	ErrorV_value
.2f6b					CommandTables:
>2f6b	07 cb 00 03 70 34 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2f72	07 89 00 03 77 34 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2f79	07 8d 00 03 6a 34 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>2f80	07 88 00 03 e6 34 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2f87	07 85 00 03 c6 34 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>2f8e	07 84 00 04 da 34 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>2f95	07 99 00 03 1b 36 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2f9c	07 98 00 04 1b 36 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2fa3	07 8f 00 03 26 37 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>2faa	07 81 00 03 c8 2e 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>2fb1	07 82 00 03 9e 35 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>2fb8	07 a1 00 03 e3 33 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>2fbf	07 83 00 03 03 2c 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>2fc6	07 87 00 03 64 36 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>2fcd	07 86 00 03 96 2c 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>2fd4	07 96 00 03 1f 2c 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>2fdb	07 8b 00 e3 93 34 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>2fe2	08 92 00 ea e3 f2 37 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>2fea	09 91 00 e1 a9 03 ca 35			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>2ff2	06
>2ff3	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>2ffa	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>3001	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>3007	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>300e	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>3015	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>301c	07 9d 00 e3 18 38 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>3023	0a 9f 00 ea e3 2b 38 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>302b	c6 06
>302d	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>3033	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>303a	0a ce 92 e3 60 33 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>3042	ad 06
>3044	0a ce 8d e3 60 33 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>304c	ae 06
>304e	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>3054	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>305c	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>3063	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>306a	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>3072	06
>3073	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>307b	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>3083	9a 06
>3085	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>308d	9b 06
>308f	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>3097	9c 06
>3099	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>30a1	06
>30a2	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>30a9	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>30b1	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>30b9	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>30c1	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>30c9	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>30d1	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>30d9	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>30e1	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>30e9	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>30f1	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>30f9	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>3100	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>3108	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>3110	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>3118	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>3120	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>3128	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>3130	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>3138	00						.byte 	0
.3139					UnaryTables:
>3139	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>3140	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>3148	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>314f	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>3156	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>315d	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>3164	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>316c	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>3173	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>317b	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>3183	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>318b	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>3193	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>319b	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>31a3	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>31aa	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>31b1	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>31b8	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>31bf	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>31c6	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>31cd	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>31d5	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>31dd	0b ca 00 8f ae 03 60 33			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>31e5	91 bd 07
>31e8	07 a8 00 03 7f 33 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>31ef	07 a5 00 03 2c 2f 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>31f6	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>31fd	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>3204	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>320c	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>3214	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>321b	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>3222	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>3229	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>3231	06
>3232	00						.byte 	0
.3233					GeneratorProcess:
.3233	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.3235	84 2d		sty $2d				sty 	zTemp0+1
.3237	85 2e		sta $2e				sta 	zTemp1 						; first match token
.3239	64 2f		stz $2f				stz 	zTemp1+1
.323b	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.323d	d0 05		bne $3244			bne 	_GPNotShifted
.323f	20 a2 33	jsr $33a2			jsr 	GetNext 					; get the shifted token
.3242	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.3244					_GPNotShifted:
.3244					_GPSearch:
.3244	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.3246	18		clc				clc
.3247	f0 2f		beq $3278			beq 	_GPExit
.3249	a0 01		ldy #$01			ldy 	#1 							; tokens match
.324b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.324d	c5 2e		cmp $2e				cmp 	zTemp1
.324f	d0 09		bne $325a			bne 	_GPNext
.3251	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.3253	f0 12		beq $3267			beq 	_GPFound
.3255	c8		iny				iny 								; check match.
.3256	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.3258	f0 0d		beq $3267			beq 	_GPFound
.325a					_GPNext:
.325a	18		clc				clc 								; follow to next
.325b	a5 2c		lda $2c				lda 	zTemp0
.325d	72 2c		adc ($2c)			adc 	(zTemp0)
.325f	85 2c		sta $2c				sta 	zTemp0
.3261	90 e1		bcc $3244			bcc 	_GPSearch
.3263	e6 2d		inc $2d				inc 	zTemp0+1
.3265	80 dd		bra $3244			bra 	_GPSearch
.3267					_GPFound:
.3267	18		clc				clc 								; skip to action bytes
.3268	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.326a	69 03		adc #$03			adc 	#3
.326c	85 2c		sta $2c				sta 	zTemp0
.326e	90 02		bcc $3272			bcc 	_GPNoCarry
.3270	e6 2d		inc $2d				inc 	zTemp0+1
.3272					_GPNoCarry:
.3272					_GPLoop:
.3272	20 79 32	jsr $3279			jsr 	GeneratorExecute 			; execute one command
.3275	90 fb		bcc $3272			bcc 	_GPLoop 					; go back if not completed.
.3277	38		sec				sec 								; return with CS.
.3278					_GPExit:
.3278	60		rts				rts
.3279					GeneratorExecute:
.3279	20 25 33	jsr $3325			jsr 	_GEFetchZTemp0 				; get next.
.327c	48		pha				pha 								; split into 2 nibbles
.327d	4a		lsr a				lsr 	a
.327e	4a		lsr a				lsr 	a
.327f	4a		lsr a				lsr		a
.3280	4a		lsr a				lsr 	a
.3281	20 8b 32	jsr $328b			jsr 	_GEExecuteNibble 			; MSB first
.3284	68		pla				pla
.3285	b0 03		bcs $328a			bcs 	_GEHaveCompleted
.3287	20 8b 32	jsr $328b			jsr 	_GEExecuteNibble 			; LSB second
.328a					_GEHaveCompleted:
.328a	60		rts				rts
.328b					_GEExecuteNibble:
.328b	29 0f		and #$0f			and 	#$0F
.328d	0a		asl a				asl 	a
.328e	aa		tax				tax
.328f	7c 92 32	jmp ($3292,x)			jmp 	(_GEExecuteVectors,x)
.3292					_GEExecuteVectors:
>3292	b2 32						.word 	_GEXNop 					; 0  (no operation)
>3294	ba 32						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>3296	b4 32						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>3298	08 33						.word 	_GEXExecute 				; 3  (run arbitrary code)
>329a	fb 32						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>329c	b2 32						.word 	_GEXNop 					; 5
>329e	c2 32						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>32a0	c6 32						.word 	_GEXExitString 				; 7  exit return string type
>32a2	ca 32						.word 	_GEXLParam 					; 8  check ( follows
>32a4	ce 32						.word 	_GEXRParam 					; 9  check ) follows
>32a6	d2 32						.word 	_GEXComma					; A  check , follows
>32a8	b2 32						.word 	_GEXNop 					; B
>32aa	b2 32						.word 	_GEXNop 					; C
>32ac	b2 32						.word 	_GEXNop 					; D
>32ae	e2 32						.word 	_GEXNumber 					; E  compile get any number
>32b0	ed 32						.word 	_GEXString 					; F  compile get any string
.32b2					_GEXNop:
.32b2	18		clc				clc
.32b3	60		rts				rts
.32b4					_GEXToken2:
.32b4	20 25 33	jsr $3325			jsr 	_GEFetchZTemp0
.32b7	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.32ba					_GEXToken1:
.32ba	20 25 33	jsr $3325			jsr 	_GEFetchZTemp0
.32bd	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.32c0	18		clc				clc
.32c1	60		rts				rts
.32c2					_GEXExitNumber:
.32c2	a9 00		lda #$00			lda 	#NSSIFloat
.32c4	38		sec				sec
.32c5	60		rts				rts
.32c6					_GEXExitString:
.32c6	a9 40		lda #$40			lda 	#NSSString
.32c8	38		sec				sec
.32c9	60		rts				rts
.32ca					_GEXLParam:
.32ca	a9 28		lda #$28			lda 	#"("
.32cc	80 06		bra $32d4			bra 	_GEXCheck
.32ce					_GEXRParam:
.32ce	a9 29		lda #$29			lda 	#")"
.32d0	80 02		bra $32d4			bra 	_GEXCheck
.32d2					_GEXComma:
.32d2	a9 2c		lda #$2c			lda 	#","
.32d4					_GEXCheck:
.32d4	85 30		sta $30				sta 	zTemp2 						; save match
.32d6	20 ad 33	jsr $33ad			jsr 	GetNextNonSpace 			; get next skipping spaces
.32d9	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.32db	d0 02		bne $32df			bne 	_GEXSyntax
.32dd	18		clc				clc
.32de	60		rts				rts
.32df					_GEXSyntax:
.32df	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.32e2					_GEXNumber:
.32e2	20 2e 33	jsr $332e			jsr 	GEXCompileExpression 		; compile expression
.32e5	29 40		and #$40			and 	#NSSTypeMask
.32e7	c9 00		cmp #$00			cmp  	#NSSIFloat
.32e9	d0 0d		bne $32f8			bne 	_GEXType
.32eb	18		clc				clc
.32ec	60		rts				rts
.32ed					_GEXString:
.32ed	20 2e 33	jsr $332e			jsr 	GEXCompileExpression 		; compile expression
.32f0	29 40		and #$40			and 	#NSSTypeMask
.32f2	c9 40		cmp #$40			cmp  	#NSSString
.32f4	d0 02		bne $32f8			bne 	_GEXType
.32f6	18		clc				clc
.32f7	60		rts				rts
.32f8					_GEXType:
.32f8	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.32fb					_GEXChannelExec:
.32fb	20 3e 33	jsr $333e			jsr 	ChannelPrefix 				; set up default
.32fe	20 08 33	jsr $3308			jsr 	_GEXExecute
.3301	08		php				php
.3302	20 59 33	jsr $3359			jsr 	ChannelPostfix 				; replace default.
.3305	28		plp				plp
.3306	60		rts				rts
>3307	db						.byte 	$DB 						; causes a break in the emulator
.3308					_GEXExecute:
.3308	20 25 33	jsr $3325			jsr 	_GEFetchZTemp0 				; get vector
.330b	85 30		sta $30				sta 	zTemp2
.330d	20 25 33	jsr $3325			jsr 	_GEFetchZTemp0
.3310	85 31		sta $31				sta 	zTemp2+1
.3312	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.3314	da		phx				phx
.3315	a6 2d		ldx $2d				ldx 	zTemp0+1
.3317	da		phx				phx
.3318	20 22 33	jsr $3322			jsr 	_GECallZTemp2 				; execute code
.331b	fa		plx				plx 								; recover generation exec
.331c	86 2d		stx $2d				stx 	zTemp0+1
.331e	fa		plx				plx
.331f	86 2c		stx $2c				stx 	zTemp0
.3321	60		rts				rts
.3322					_GECallZTemp2:
.3322	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.3325					_GEFetchZTemp0:
.3325	b2 2c		lda ($2c)			lda 	(zTemp0)
.3327	e6 2c		inc $2c				inc 	zTemp0
.3329	d0 02		bne $332d			bne 	_GEFZ0Skip
.332b	e6 2d		inc $2d				inc 	zTemp0+1
.332d					_GEFZ0Skip:
.332d	60		rts				rts
.332e					GEXCompileExpression:
.332e	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.3330	da		phx				phx
.3331	a6 2d		ldx $2d				ldx 	zTemp0+1
.3333	da		phx				phx
.3334	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAt0 		; compile expression.
.3337	fa		plx				plx 								; recover generation exec
.3338	86 2d		stx $2d				stx 	zTemp0+1
.333a	fa		plx				plx
.333b	86 2c		stx $2c				stx 	zTemp0
.333d	60		rts				rts
.333e					ChannelPrefix:
.333e	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.3340	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.3343	20 2e 33	jsr $332e			jsr 	GEXCompileExpression 		; channel #
.3346	29 40		and #$40			and 	#NSSTypeMask
.3348	c9 00		cmp #$00			cmp 	#NSSIFloat
.334a	d0 0a		bne $3356			bne 	_CPXType
.334c	20 95 2a	jsr $2a95			jsr 	CheckNextComma 				; check , follows.
.334f	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.3351	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.3354	18		clc				clc
.3355	60		rts				rts
.3356					_CPXType:
.3356	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.3359					ChannelPostfix:
.3359	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.335b	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.335e	18		clc				clc
.335f	60		rts				rts
.3360					OptionalParameterCompile:
.3360	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; what follows.
.3363	c9 2c		cmp #$2c			cmp 	#","
.3365	d0 0e		bne $3375			bne 	_MidDefault
.3367	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume ,
.336a	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAt0
.336d	29 40		and #$40			and 	#NSSTypeMask
.336f	c9 00		cmp #$00			cmp 	#NSSIFloat
.3371	d0 09		bne $337c			bne 	MidFailType
.3373	80 05		bra $337a			bra 	_MidComplete
.3375					_MidDefault:
.3375	a9 ff		lda #$ff			lda 	#255 						; default of 255
.3377	20 60 2b	jsr $2b60			jsr 	PushIntegerA
.337a					_MidComplete:
.337a	18		clc				clc
.337b	60		rts				rts
.337c					MidFailType:
.337c	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.337f					NotUnaryCompile:
.337f	ad 02 2e	lda $2e02			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.3382	20 4f 2d	jsr $2d4f			jsr 	CompileExpressionAtA 		; evaluate at that level
.3385	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.3387	c9 00		cmp #$00			cmp 	#NSSIFloat
.3389	d0 f1		bne $337c			bne 	MidFailType
.338b	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.338d	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.3390	60		rts				rts
.3391					LookNext:
.3391	b2 7a		lda ($7a)			lda 	(srcPtr)
.3393	60		rts				rts
.3394					LookNextNonSpace:
.3394	b2 7a		lda ($7a)			lda 	(srcPtr)
.3396	c9 20		cmp #$20			cmp		#' '
.3398	f0 03		beq $339d			beq 	_LNNSkip
.339a	c9 00		cmp #$00			cmp 	#0
.339c	60		rts				rts
.339d					_LNNSkip:
.339d	20 a2 33	jsr $33a2			jsr 	GetNext
.33a0	80 f2		bra $3394			bra 	LookNextNonSpace
.33a2					GetNext:
.33a2	b2 7a		lda ($7a)			lda 	(srcPtr) 					; get next
.33a4	e6 7a		inc $7a				inc 	srcPtr
.33a6	d0 02		bne $33aa			bne 	_GNSkip
.33a8	e6 7b		inc $7b				inc 	srcPtr+1
.33aa					_GNSkip:
.33aa	c9 00		cmp #$00			cmp 	#0
.33ac	60		rts				rts
.33ad					GetNextNonSpace:
.33ad	20 a2 33	jsr $33a2			jsr 	GetNext
.33b0	c9 20		cmp #$20			cmp 	#' '
.33b2	f0 f9		beq $33ad			beq 	GetNextNonSpace
.33b4	c9 00		cmp #$00			cmp 	#0
.33b6	60		rts				rts
.33b7					CharIsDigit:
.33b7	c9 30		cmp #$30			cmp 	#"0"
.33b9	90 06		bcc $33c1			bcc 	CCFalse
.33bb	c9 3a		cmp #$3a			cmp 	#"9"+1
.33bd	b0 02		bcs $33c1			bcs 	CCFalse
.33bf					CCTrue:
.33bf	38		sec				sec
.33c0	60		rts				rts
.33c1					CCFalse:
.33c1	18		clc				clc
.33c2	60		rts				rts
.33c3					CharIsAlpha:
.33c3	c9 41		cmp #$41			cmp 	#"A"
.33c5	90 fa		bcc $33c1			bcc 	CCFalse
.33c7	c9 5b		cmp #$5b			cmp 	#"Z"+1
.33c9	b0 f6		bcs $33c1			bcs 	CCFalse
.33cb	80 f2		bra $33bf			bra 	CCTrue
.33cd					ConvertHexStyle:
.33cd	38		sec				sec
.33ce	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.33d0	90 ef		bcc $33c1			bcc 	CCFalse
.33d2	c9 0a		cmp #$0a			cmp 	#9+1
.33d4	90 e9		bcc $33bf			bcc 	CCTrue
.33d6	38		sec				sec 								; shift into hex space A=>0 Z=>25
.33d7	e9 11		sbc #$11			sbc 	#"A"-"0"
.33d9	90 e6		bcc $33c1			bcc 	CCFalse
.33db	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.33dd	b0 e2		bcs $33c1			bcs 	CCFalse
.33df	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.33e1	80 dc		bra $33bf			bra 	CCTrue
.33e3					CommandGET:
.33e3	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; # follows ?
.33e6	c9 23		cmp #$23			cmp 	#"#"
.33e8	d0 0d		bne $33f7			bne 	CommandGetBody
.33ea	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume #
.33ed	20 3e 33	jsr $333e			jsr 	ChannelPrefix 				; do it as GET#
.33f0	20 f7 33	jsr $33f7			jsr 	CommandGetBody
.33f3	20 59 33	jsr $3359			jsr 	ChannelPostfix
.33f6	60		rts				rts
.33f7					CommandGetBody:
.33f7	20 ad 33	jsr $33ad			jsr 	GetNextNonSpace 			; get the first character
.33fa	20 ee 36	jsr $36ee			jsr 	GetReferenceTerm 			; identify variable to assign to
.33fd	48		pha				pha
.33fe	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.3400	c9 40		cmp #$40			cmp 	#NSSString
.3402	d0 0b		bne $340f			bne 	_CGType
.3404	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.3406	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.3409	38		sec				sec
.340a	68		pla				pla
.340b	20 a0 36	jsr $36a0			jsr		GetSetVariable
.340e	60		rts				rts
.340f					_CGType:
.340f	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.3412					ExtractVariableName:
.3412	20 c3 33	jsr $33c3			jsr 	CharIsAlpha
.3415	90 50		bcc $3467			bcc 	_IVSyntax
.3417	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.3419	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.341b	64 2f		stz $2f				stz 	zTemp1+1
.341d	20 91 33	jsr $3391			jsr 	LookNext 					; is there a second character ?
.3420	20 c3 33	jsr $33c3			jsr 	CharIsAlpha  				; must be alphanumeric
.3423	b0 05		bcs $342a			bcs 	_IVHasSecond
.3425	20 b7 33	jsr $33b7			jsr 	CharIsDigit
.3428	90 07		bcc $3431			bcc 	_IVCheckType
.342a					_IVHasSecond:
.342a	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.342c	85 2f		sta $2f				sta 	zTemp1+1
.342e					_IVGetNextCheck:
.342e	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume it
.3431					_IVCheckType:
.3431	20 91 33	jsr $3391			jsr 	LookNext					; check if string follows.
.3434	20 c3 33	jsr $33c3			jsr 	CharIsAlpha
.3437	b0 f5		bcs $342e			bcs 	_IVGetNextCheck
.3439	20 b7 33	jsr $33b7			jsr 	CharIsDigit
.343c	b0 f0		bcs $342e			bcs 	_IVGetNextCheck
.343e	a2 40		ldx #$40			ldx 	#NSSString
.3440	c9 24		cmp #$24			cmp 	#"$"
.3442	f0 06		beq $344a			beq 	_IVHasType
.3444	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.3446	c9 25		cmp #$25			cmp 	#"%"
.3448	d0 08		bne $3452			bne 	_IVCheckArray
.344a					_IVHasType:
.344a	8a		txa				txa 								; Or X into zTemp1
.344b	05 2e		ora $2e				ora 	zTemp1
.344d	85 2e		sta $2e				sta 	zTemp1
.344f	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume it
.3452					_IVCheckArray:
.3452	20 91 33	jsr $3391			jsr 	LookNext 					; check if array follows
.3455	c9 28		cmp #$28			cmp 	#"("
.3457	d0 09		bne $3462			bne 	_IVNotArray
.3459	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.345b	09 80		ora #$80			ora 	#NSSArray
.345d	85 2e		sta $2e				sta 	zTemp1
.345f	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume it
.3462					_IVNotArray:
.3462	a6 2e		ldx $2e				ldx 	zTemp1
.3464	a4 2f		ldy $2f				ldy 	zTemp1+1
.3466	60		rts				rts
.3467					_IVSyntax:
.3467	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.346a					CommandGOSUB:
.346a	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.346c	20 7d 34	jsr $347d			jsr 	CompileBranchCommand
.346f	60		rts				rts
.3470					CommandGOAlt:
.3470	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.3472	20 9f 2a	jsr $2a9f			jsr 	CheckNextA
.3475	80 00		bra $3477			bra 	CommandGOTO
.3477					CommandGOTO:
.3477	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.3479	20 7d 34	jsr $347d			jsr 	CompileBranchCommand
.347c	60		rts				rts
.347d					CompileBranchCommand:
.347d	20 37 2a	jsr $2a37			jsr 	WriteCodeByte 				; write the command out.
.3480	20 ad 33	jsr $33ad			jsr 	GetNextNonSpace
.3483	20 f6 35	jsr $35f6			jsr 	ParseConstant 				; get constant into YA
.3486	90 08		bcc $3490			bcc 	_CBCSyntax
.3488	20 37 2a	jsr $2a37			jsr 	WriteCodeByte				; and compile the actual line number
.348b	98		tya				tya
.348c	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.348f	60		rts				rts
.3490					_CBCSyntax:
.3490	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.3493					CommandIF:
.3493	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; what follows the tests ?
.3496	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.3498	f0 0f		beq $34a9			beq 	_CIGoto
.349a	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.349c	20 9f 2a	jsr $2a9f			jsr 	CheckNextA
.349f	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; THEN <number>
.34a2	20 b7 33	jsr $33b7			jsr 	CharIsDigit
.34a5	b0 05		bcs $34ac			bcs 	_CIGoto2
.34a7	80 09		bra $34b2			bra 	CompileGotoEOL
.34a9					_CIGoto:
.34a9	20 a2 33	jsr $33a2			jsr 	GetNext
.34ac					_CIGoto2:
.34ac	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.34ae	20 7d 34	jsr $347d			jsr 	CompileBranchCommand
.34b1	60		rts				rts
.34b2					CompileGotoEOL:
.34b2	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.34b4	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.34b7	20 30 2a	jsr $2a30			jsr 	GetLineNumber 				; Get the current line number => YA
.34ba	1a		inc a				inc 	a 							; and branch to +1
.34bb	d0 01		bne $34be			bne 	_CGENoCarry
.34bd	c8		iny				iny
.34be					_CGENoCarry:
.34be	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.34c1	98		tya				tya
.34c2	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.34c5	60		rts				rts
.34c6					CommandINPUT:
.34c6	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; check for "
.34c9	c9 22		cmp #$22			cmp 	#'"'
.34cb	d0 0d		bne $34da			bne 	CommandINPUTStream
.34cd	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAt0
.34d0	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.34d2	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.34d5	a9 2c		lda #$2c			lda 	#","
.34d7	20 95 2a	jsr $2a95			jsr 	CheckNextComma
.34da					CommandINPUTStream:
.34da	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.34dc	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.34df	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.34e1	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.34e3	4c 68 36	jmp $3668			jmp 	CommandReadInputCommon
.34e6					CommandLET:
.34e6	20 ad 33	jsr $33ad			jsr 	GetNextNonSpace 			; get the first character
.34e9					CommandLETHaveFirst:
.34e9	20 ee 36	jsr $36ee			jsr 	GetReferenceTerm 			; identify variable to assign to
.34ec	da		phx				phx 								; save target on the stack.
.34ed	5a		phy				phy
.34ee	48		pha				pha
.34ef	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.34f1	20 9f 2a	jsr $2a9f			jsr 	CheckNextA
.34f4	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.34f7	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.34f9	68		pla				pla 								; get type of assignment
.34fa	48		pha				pha
.34fb	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.34fd	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.34ff	d0 17		bne $3518			bne 	_CLType
.3501	68		pla				pla 								; restore and compile save code
.3502	7a		ply				ply
.3503	fa		plx				plx
.3504	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.3506	f0 05		beq $350d			beq 	_CLTIString
.3508	38		sec				sec
.3509	20 a0 36	jsr $36a0			jsr		GetSetVariable
.350c	60		rts				rts
.350d					_CLTIString:
.350d	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.350f	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.3512	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.3514	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.3517	60		rts				rts
.3518					_CLType:
.3518	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.351b					STRMarkLine:
.351b	48		pha				pha
.351c	38		sec				sec 								; allocate 4 bytes (line #,address)
.351d	ad c9 06	lda $06c9			lda 	lineNumberTable 			; and copy to zTemp0
.3520	e9 04		sbc #$04			sbc 	#4
.3522	8d c9 06	sta $06c9			sta 	lineNumberTable
.3525	85 2c		sta $2c				sta 	zTemp0
.3527	ad ca 06	lda $06ca			lda 	lineNumberTable+1
.352a	e9 00		sbc #$00			sbc 	#0
.352c	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.352f	85 2d		sta $2d				sta 	zTemp0+1
.3531	68		pla				pla
.3532	92 2c		sta ($2c)			sta 	(zTemp0) 					; line # save it in +0,+1
.3534	98		tya				tya
.3535	a0 01		ldy #$01			ldy 	#1
.3537	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3539	a5 2a		lda $2a				lda 	objPtr 						; save current address in +2,+3
.353b	c8		iny				iny
.353c	91 2c		sta ($2c),y			sta 	(zTemp0),y
.353e	a5 2b		lda $2b				lda 	objPtr+1
.3540	c8		iny				iny
.3541	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3543	60		rts				rts
.3544					STRFindLine:
.3544	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.3546	84 2d		sty $2d				sty 	zTemp0+1
.3548	ad c2 06	lda $06c2			lda 	compilerEndHigh 			; work backwards through table
.354b	85 2f		sta $2f				sta 	zTemp1+1
.354d	64 2e		stz $2e				stz 	zTemp1
.354f					_STRSearch:
.354f	20 86 35	jsr $3586			jsr 	_STRPrevLine 				; look at previous record.
.3552	a0 01		ldy #$01			ldy 	#1
.3554	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.3556	c5 2c		cmp $2c				cmp 	zTemp0
.3558	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.355a	e5 2d		sbc $2d				sbc 	zTemp0+1
.355c	b0 0b		bcs $3569			bcs 	_STRFound 					; >=
.355e					_STRNext:
.355e	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.3560	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3562	c9 ff		cmp #$ff			cmp 	#$FF
.3564	d0 e9		bne $354f			bne 	_STRSearch
.3566	4c 6b 1f	jmp $1f6b		jmp	ErrorV_internal
.3569					_STRFound:
.3569	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.356b	45 2c		eor $2c				eor 	zTemp0
.356d	d0 06		bne $3575			bne 	_STRDifferent
.356f	b2 2e		lda ($2e)			lda 	(zTemp1)
.3571	45 2c		eor $2c				eor 	zTemp0
.3573	f0 02		beq $3577			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.3575					_STRDifferent:
.3575	a9 ff		lda #$ff			lda 	#$FF
.3577					_STROut:
.3577	18		clc				clc  								; set carry if different, e.g. > rather than >=
.3578	69 ff		adc #$ff			adc 	#255
.357a	08		php				php
.357b	c8		iny				iny 								; address into YA
.357c	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.357e	48		pha				pha
.357f	c8		iny				iny
.3580	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3582	a8		tay				tay
.3583	68		pla				pla
.3584	28		plp				plp
.3585	60		rts				rts
.3586					_STRPrevLine:
.3586	38		sec				sec 								; move backwards one entry.
.3587	a5 2e		lda $2e				lda 	zTemp1
.3589	e9 04		sbc #$04			sbc 	#4
.358b	85 2e		sta $2e				sta 	zTemp1
.358d	a5 2f		lda $2f				lda 	zTemp1+1
.358f	e9 00		sbc #$00			sbc 	#0
.3591	85 2f		sta $2f				sta 	zTemp1+1
.3593	60		rts				rts
.3594					STRMakeOffset:
.3594	18		clc				clc 								; borrow 1
.3595	e5 2a		sbc $2a				sbc 	objPtr
.3597	48		pha				pha
.3598	98		tya				tya
.3599	e5 2b		sbc $2b				sbc 	objPtr+1
.359b	a8		tay				tay
.359c	68		pla				pla
.359d	60		rts				rts
.359e					CommandNEXT:
.359e	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.35a1	20 c3 33	jsr $33c3			jsr 	CharIsAlpha 				; if not alpha , error
.35a4	90 0c		bcc $35b2			bcc 	_CNNoReferenceGiven
.35a6	20 a2 33	jsr $33a2			jsr 	GetNext
.35a9	20 ee 36	jsr $36ee			jsr 	GetReferenceTerm 			; figure out the reference.
.35ac	8a		txa				txa 								; reference in YA
.35ad	20 4d 2b	jsr $2b4d			jsr 	PushIntegerYA 				; write it out.
.35b0	80 06		bra $35b8			bra 	_CNParametersDone
.35b2					_CNNoReferenceGiven:
.35b2	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.35b4	a8		tay				tay
.35b5	20 4d 2b	jsr $2b4d			jsr 	PushIntegerYA 				; write it out.
.35b8					_CNParametersDone:
.35b8	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.35ba	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.35bd	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; look for ,
.35c0	c9 2c		cmp #$2c			cmp 	#","
.35c2	d0 05		bne $35c9			bne 	_CNExit
.35c4	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume ,
.35c7	80 d5		bra $359e			bra 	CommandNEXT 				; and go round.
.35c9					_CNExit:
.35c9	60		rts				rts
.35ca					CommandON:
.35ca	20 ad 33	jsr $33ad			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.35cd	48		pha				pha 								; save on stack
.35ce	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.35d0	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.35d2	f0 09		beq $35dd			beq 	_COCreateLoop
.35d4	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.35d6	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.35d8	f0 03		beq $35dd			beq 	_COCreateLoop
.35da	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.35dd					_COCreateLoop:
.35dd	8a		txa				txa 								; compile a goto/gosub somewhere
.35de	da		phx				phx
.35df	20 7d 34	jsr $347d			jsr 	CompileBranchCommand
.35e2	fa		plx				plx
.35e3	20 94 33	jsr $3394			jsr 	LookNextNonSpace			; ',' follows
.35e6	c9 2c		cmp #$2c			cmp 	#","
.35e8	d0 0a		bne $35f4			bne 	_COComplete 				; if so, more line numbers
.35ea	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.35ec	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.35ef	20 a2 33	jsr $33a2			jsr 	GetNext
.35f2	80 e9		bra $35dd			bra 	_COCreateLoop
.35f4					_COComplete:
.35f4	68		pla				pla 								; throw GOTO/GOSUB
.35f5	60		rts				rts
.35f6					ParseConstant:
.35f6	a2 00		ldx #$00			ldx 	#0
.35f8	20 48 24	jsr $2448			jsr 	FloatEncodeStart 			; send first
.35fb					_ParseLoop:
.35fb	20 91 33	jsr $3391			jsr 	LookNext 					; send subsequent
.35fe	20 4b 24	jsr $244b			jsr 	FloatEncodeContinue
.3601	90 05		bcc $3608			bcc 	_ParseDone
.3603	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume it
.3606	80 f3		bra $35fb			bra 	_ParseLoop
.3608					_ParseDone:
.3608	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.360a	29 80		and #$80			and 	#$80
.360c	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.360e	15 56		ora $56,x			ora 	NSMantissa2,x
.3610	15 62		ora $62,x			ora 	NSMantissa3,x
.3612	18		clc				clc
.3613	d0 05		bne $361a			bne 	_ParseExit 					; exit with CC if need float to compile
.3615	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.3617	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.3619	38		sec				sec
.361a					_ParseExit:
.361a	60		rts				rts
.361b					CommandPRINT:
.361b	20 94 33	jsr $3394			jsr 	LookNextNonSpace			; what follows ?
.361e	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.3620	f0 1f		beq $3641			beq 	_CPCheckEnd
.3622	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.3624	f0 16		beq $363c			beq 	_CPTabCheckEnd
.3626	20 58 36	jsr $3658			jsr 	_CPAtEnd 					; check for : and EOL
.3629	b0 22		bcs $364d			bcs 	_CPExitCR 					; exit with CR
.362b	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAt0 		; so it is something to print
.362e	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.3630	29 40		and #$40			and 	#NSSString 					; if string
.3632	d0 02		bne $3636			bne 	_CPOut
.3634	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.3636					_CPOut:
.3636	8a		txa				txa 								; print that thing
.3637	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.363a	80 df		bra $361b			bra 	CommandPRINT 				; and loop round/
.363c					_CPTabCheckEnd:
.363c	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.363e	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.3641					_CPCheckEnd:
.3641	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume it.
.3644	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; what follows ?
.3647	20 58 36	jsr $3658			jsr 	_CPAtEnd 					; reached end
.364a	90 cf		bcc $361b			bcc 	CommandPRINT 				; no, loop back
.364c	60		rts				rts
.364d					_CPExitCR:
.364d	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.364f	20 60 2b	jsr $2b60			jsr 	PushIntegerA
.3652	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.3654	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.3657	60		rts				rts
.3658					_CPAtEnd:
.3658	c9 00		cmp #$00			cmp 	#0
.365a	f0 06		beq $3662			beq 	_CPIsEnd
.365c	c9 3a		cmp #$3a			cmp 	#":"
.365e	f0 02		beq $3662			beq 	_CPIsEnd
.3660	18		clc				clc
.3661	60		rts				rts
.3662					_CPIsEnd:
.3662	38		sec				sec
.3663	60		rts				rts
.3664					CommandREAD:
.3664	a2 b2		ldx #$b2			ldx 	#PCD_READ
.3666	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.3668					CommandReadInputCommon:
.3668	8e c7 06	stx $06c7			stx 	numberPCode
.366b	8c c8 06	sty $06c8			sty 	stringPCode
.366e					_CRLoop:
.366e	20 ad 33	jsr $33ad			jsr 	GetNextNonSpace 			; first char of identifier
.3671	20 c3 33	jsr $33c3			jsr 	CharIsAlpha 				; check A-Z
.3674	90 27		bcc $369d			bcc 	_CRSyntax
.3676	20 ee 36	jsr $36ee			jsr 	GetReferenceTerm 			; get the variable.
.3679	48		pha				pha 								; save type.
.367a	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.367c	c9 40		cmp #$40			cmp 	#NSSString
.367e	f0 05		beq $3685			beq 	_CRString
.3680	ad c7 06	lda $06c7			lda 	numberPCode 				; output read/input
.3683	80 03		bra $3688			bra 	_CRHaveType
.3685					_CRString:
.3685	ad c8 06	lda $06c8			lda 	stringPCode					; output read$/input$
.3688					_CRHaveType:
.3688	20 37 2a	jsr $2a37			jsr 	WriteCodeByte 				; so we have one typed data item.
.368b	68		pla				pla 								; restore type
.368c	38		sec				sec  								; write update code.
.368d	20 a0 36	jsr $36a0			jsr 	GetSetVariable
.3690	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; , follows ?
.3693	c9 2c		cmp #$2c			cmp 	#","
.3695	d0 05		bne $369c			bne 	_CRExit 					; if not, end of READ.
.3697	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume comma
.369a	80 d2		bra $366e			bra 	_CRLoop 					; keep going
.369c					_CRExit:
.369c	60		rts				rts
.369d					_CRSyntax:
.369d	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.06c7					numberPCode:
>06c7							.fill 	1
.06c8					stringPCode:
>06c8							.fill 	1
.36a0					GetSetVariable:
.36a0	08		php				php 								; save direction on stack
.36a1	c0 00		cpy #$00			cpy 	#$00
.36a3	30 21		bmi $36c6			bmi 	_GSVReadWriteSpecial
.36a5	c9 00		cmp #$00			cmp 	#$00
.36a7	30 33		bmi $36dc			bmi 	_GSVArray
.36a9	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.36ab	4a		lsr a				lsr 	a 							; divide by 2
.36ac	09 40		ora #$40			ora 	#64 						; and set bit 6.
.36ae	28		plp				plp
.36af	90 02		bcc $36b3			bcc 	_GSVNotWrite
.36b1	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.36b3					_GSVNotWrite:
.36b3	85 2c		sta $2c				sta 	zTemp0
.36b5	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.36b6	4a		lsr a				lsr 	a
.36b7	a8		tay				tay
.36b8	8a		txa				txa
.36b9	6a		ror a				ror 	a
.36ba	aa		tax				tax
.36bb	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.36bc	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.36be	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.36c1	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.36c2	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.36c5	60		rts				rts
.36c6					_GSVReadWriteSpecial:
.36c6	28		plp				plp
.36c7	b0 10		bcs $36d9			bcs 	_GSVSyntax
.36c9	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.36cb	f0 06		beq $36d3			beq 	_GSVRWString
.36cd	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.36cf	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.36d2	60		rts				rts
.36d3					_GSVRWString:
.36d3	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.36d5	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.36d8	60		rts				rts
.36d9					_GSVSyntax:
.36d9	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.36dc					_GSVArray:
.36dc	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.36de	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.36df	4a		lsr a				lsr 	a
.36e0	4a		lsr a				lsr 	a
.36e1	4a		lsr a				lsr 	a
.36e2	4a		lsr a				lsr 	a
.36e3	28		plp				plp 								; if writing array then set bit 2.
.36e4	90 02		bcc $36e8			bcc 	_GSVANotWrite
.36e6	09 04		ora #$04			ora 	#4
.36e8					_GSVANotWrite:
.36e8	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.36ea	20 37 2a	jsr $2a37			jsr 	WriteCodeByte 				; and write it out
.36ed	60		rts				rts
.36ee					GetReferenceTerm:
.36ee	20 12 34	jsr $3412			jsr 	ExtractVariableName 		; get name & type info
.36f1	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.36f3	30 10		bmi $3705			bmi 	_GRTArray
.36f5	da		phx				phx 								; save type on stack
.36f6	20 07 2e	jsr $2e07			jsr 	FindVariable 				; find it
.36f9	b0 06		bcs $3701			bcs 	_GRTNoCreate 				; create if required.
.36fb	20 92 2b	jsr $2b92			jsr 	CreateVariableRecord 		; create a variable.
.36fe	20 e7 2b	jsr $2be7			jsr 	AllocateBytesForType 		; allocate memory for it
.3701					_GRTNoCreate:
.3701	68		pla				pla 								; get type back, strip out type information.
.3702	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.3704	60		rts				rts
.3705					_GRTArray:
.3705	da		phx				phx 								; save type information
.3706	20 07 2e	jsr $2e07			jsr 	FindVariable 				; read its data, the base address in YX
.3709	90 18		bcc $3723			bcc 	_GRTUndeclared 				; undeclared array.
.370b	da		phx				phx 								; save base address
.370c	5a		phy				phy
.370d	20 de 2c	jsr $2cde			jsr 	OutputIndexGroup 			; create an index group and generate them
.3710	7a		ply				ply 								; get the array base address into YX
.3711	fa		plx				plx
.3712	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.3714	18		clc				clc
.3715	20 a0 36	jsr $36a0			jsr 	GetSetVariable 				; load the address of the array structure.
.3718	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.371a	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.371d	68		pla				pla 								; and the type data into A
.371e	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.3720	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.3722	60		rts				rts
.3723					_GRTUndeclared:
.3723	4c c8 1f	jmp $1fc8		jmp	ErrorV_undeclared
.3726					CommandREM:
.3726	20 91 33	jsr $3391			jsr 	LookNext
.3729	f0 05		beq $3730			beq 	_CRExit
.372b	20 a2 33	jsr $33a2			jsr 	GetNext
.372e	80 f6		bra $3726			bra 	CommandREM
.3730					_CRExit:
.3730	60		rts				rts
.3731					STRReset:
.3731	ad c1 06	lda $06c1			lda	 	compilerStartHigh 			; set up the two table pointers
.3734	8d cc 06	sta $06cc			sta 	variableListEnd+1
.3737	9c cb 06	stz $06cb			stz 	variableListEnd
.373a	ad c2 06	lda $06c2			lda 	compilerEndHigh
.373d	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.3740	9c c9 06	stz $06c9			stz 	lineNumberTable
.3743	ad cb 06	lda $06cb			lda 	variableListEnd
.3746	85 2d		sta $2d				sta 	zTemp0+1
.3748	64 2c		stz $2c				stz 	zTemp0
.374a	a9 00		lda #$00			lda 	#0
.374c	92 2c		sta ($2c)			sta 	(zTemp0)
.374e	a9 00		lda #$00			lda 	#((0) & $FF)
.3750	8d cd 06	sta $06cd			sta 	0+freeVariableMemory
.3753	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.3755	8d ce 06	sta $06ce			sta 	1+freeVariableMemory
.3758	60		rts				rts
.06c9					lineNumberTable:
>06c9							.fill 	2
.06cb					variableListEnd:
>06cb							.fill 	2
.06cd					freeVariableMemory:
>06cd							.fill 	2
.3759					CompileTerm:
.3759	20 ad 33	jsr $33ad			jsr 	GetNextNonSpace 			; get first non space character.
.375c	30 72		bmi $37d0			bmi 	_CTUnaryFunctions
.375e	20 b7 33	jsr $33b7			jsr 	CharIsDigit 				; found a number
.3761	b0 3a		bcs $379d			bcs 	_CTDigit
.3763	c9 2e		cmp #$2e			cmp 	#"."
.3765	f0 36		beq $379d			beq 	_CTDigit
.3767	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.3769	f0 43		beq $37ae			beq 	_CTString
.376b	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.376d	f0 28		beq $3797			beq 	_CTOtherBase
.376f	c9 24		cmp #$24			cmp 	#"$"
.3771	f0 24		beq $3797			beq 	_CTOtherBase
.3773	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.3775	f0 17		beq $378e			beq 	_CTBrackets
.3777	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.3779	90 10		bcc $378b			bcc 	_CTSyntax
.377b	c9 5b		cmp #$5b			cmp 	#"Z"+1
.377d	b0 0c		bcs $378b			bcs 	_CTSyntax
.377f	20 ee 36	jsr $36ee			jsr 	GetReferenceTerm 			; figure out what it is.
.3782	48		pha				pha 								; save type on stack
.3783	18		clc				clc 								; read it
.3784	20 a0 36	jsr $36a0			jsr 	GetSetVariable
.3787	68		pla				pla
.3788	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.378a	60		rts				rts
.378b					_CTSyntax:
.378b	4c 11 1f	jmp $1f11		jmp	ErrorV_syntax
.378e					_CTBrackets:
.378e	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAt0
.3791	48		pha				pha
.3792	20 99 2a	jsr $2a99			jsr 	CheckNextRParen
.3795	68		pla				pla
.3796	60		rts				rts
.3797					_CTOtherBase:
.3797	20 e5 29	jsr $29e5			jsr 	InlineNonDecimal 			; non decimal constant handler
.379a	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.379c	60		rts				rts
.379d					_CTDigit:
.379d	20 f6 35	jsr $35f6			jsr 	ParseConstant 				; parse out an number, first is in A already.
.37a0	90 06		bcc $37a8			bcc	 	_CTFloat 					; have a float or long int.
.37a2	20 4d 2b	jsr $2b4d			jsr 	PushIntegerYA 				; code to push on stack
.37a5	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.37a7	60		rts				rts
.37a8					_CTFloat:
.37a8	20 6f 2b	jsr $2b6f			jsr 	PushFloatCommand			; code to push float
.37ab	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.37ad	60		rts				rts
.37ae					_CTString:
.37ae	20 6e 2a	jsr $2a6e			jsr 	BufferClear 				; copy it to the buffer
.37b1					_CTStringLoop:
.37b1	20 91 33	jsr $3391			jsr 	LookNext 					; reached EOL/EOS
.37b4	f0 d5		beq $378b			beq 	_CTSyntax
.37b6	c9 22		cmp #$22			cmp 	#'"'
.37b8	f0 08		beq $37c2			beq 	_CTStringDone
.37ba	20 72 2a	jsr $2a72			jsr 	BufferWrite 				; write and consume
.37bd	20 a2 33	jsr $33a2			jsr 	GetNext
.37c0	80 ef		bra $37b1			bra 	_CTStringLoop
.37c2					_CTStringDone:
.37c2	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume closing quote.
.37c5	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.37c7	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.37ca	20 7e 2a	jsr $2a7e			jsr 	BufferOutput
.37cd	a9 40		lda #$40			lda 	#NSSString 					; string type
.37cf	60		rts				rts
.37d0					_CTUnaryFunctions:
.37d0	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.37d2	f0 0a		beq $37de			beq 	_CTNegation
.37d4	a2 39		ldx #$39			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.37d6	a0 31		ldy #$31			ldy 	#UnaryTables >> 8
.37d8	20 33 32	jsr $3233			jsr 	GeneratorProcess
.37db	90 ae		bcc $378b			bcc		_CTSyntax
.37dd	60		rts				rts
.37de					_CTNegation:
.37de	20 59 37	jsr $3759			jsr 	CompileTerm 				; compile a term.
.37e1	48		pha				pha
.37e2	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.37e4	c9 00		cmp #$00			cmp 	#NSSIFloat
.37e6	d0 07		bne $37ef			bne 	_CTType 					; error
.37e8	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.37ea	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.37ed	68		pla				pla 								; return original type.
.37ee	60		rts				rts
.37ef					_CTType:
.37ef	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.37f2					CommandWAIT:
.37f2	20 94 33	jsr $3394			jsr 	LookNextNonSpace
.37f5	c9 2c		cmp #$2c			cmp 	#","
.37f7	f0 10		beq $3809			beq 	_CWThirdParameter
.37f9	a9 00		lda #$00			lda 	#0
.37fb	20 60 2b	jsr $2b60			jsr 	PushIntegerA
.37fe					_CWExit:
.37fe	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.3800	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.3803	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.3805	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.3808	60		rts				rts
.3809					_CWThirdParameter:
.3809	20 a2 33	jsr $33a2			jsr 	GetNext
.380c	20 4f 2d	jsr $2d4f			jsr 	CompileExpressionAtA
.380f	29 40		and #$40			and 	#NSSTypeMask
.3811	c9 00		cmp #$00			cmp 	#NSSIFloat
.3813	f0 e9		beq $37fe			beq 	_CWExit
.3815	4c 21 1f	jmp $1f21		jmp	ErrorV_type
.3818					CommandCMD:
.3818	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.381a	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.381d	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; followed by a , ?
.3820	c9 2c		cmp #$2c			cmp 	#","
.3822	d0 06		bne $382a			bne 	_CCMDExit
.3824	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume comma.
.3827	20 1b 36	jsr $361b			jsr 	CommandPRINT 				; do the print code
.382a					_CCMDExit:
.382a	60		rts				rts
.382b					CommandOPEN:
.382b	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; followed by a , ?
.382e	c9 2c		cmp #$2c			cmp 	#","
.3830	d0 15		bne $3847			bne 	_COTwoDefaults
.3832	20 a2 33	jsr $33a2			jsr 	GetNext 					; consume comma
.3835	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.3838	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.383a	f0 1e		beq $385a			beq 	_COThreeIntegers
.383c	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.383e	20 60 2b	jsr $2b60			jsr 	PushIntegerA
.3841	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.3843	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.3846	60		rts				rts
.3847					_COTwoDefaults:
.3847	a9 00		lda #$00			lda 	#0
.3849	20 60 2b	jsr $2b60			jsr 	PushIntegerA
.384c					_COCompileNullString:
.384c	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.384e	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.3851	a9 00		lda #$00			lda 	#0
.3853	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.3856	20 37 2a	jsr $2a37			jsr 	WriteCodeByte
.3859	60		rts				rts
.385a					_COThreeIntegers:
.385a	20 94 33	jsr $3394			jsr 	LookNextNonSpace 			; is there a ,
.385d	c9 2c		cmp #$2c			cmp 	#","
.385f	d0 eb		bne $384c			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.3861	20 a2 33	jsr $33a2			jsr 	GetNext
.3864	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAt0 		; should be a filename
.3867	29 40		and #$40			and 	#NSSString
.3869	f0 01		beq $386c			beq 	_COType
.386b	60		rts				rts
.386c					_COType:
.386c	4c 21 1f	jmp $1f21		jmp	ErrorV_type

;******  Processing input file: _library.asm

.386f					CompilerAPI:
.386f	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.3871	f0 19		beq $388c			beq 	_CAOpenIn
.3873	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.3875	f0 23		beq $389a			beq 	_CACloseIn
.3877	c9 02		cmp #$02			cmp 	#BLC_READIN
.3879	f0 3a		beq $38b5			beq 	_CARead
.387b	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.387d	f0 1e		beq $389d			beq 	_CAResetOut
.387f	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.3881	f0 23		beq $38a6			beq 	_CACloseOut
.3883	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.3885	f0 20		beq $38a7			beq 	_CAWriteByte
.3887	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.3889	f0 26		beq $38b1			beq 	_CAPrintScreen
>388b	db						.byte 	$DB 						; causes a break in the emulator
.388c					_CAOpenIn:
.388c	a0 39		ldy #$39			ldy 	#SourceFile >> 8 			; name of file
.388e	a2 ac		ldx #$ac			ldx 	#SourceFile & $FF
.3890	20 1d 39	jsr $391d			jsr 	IOOpenRead 					; open file
.3893	20 28 39	jsr $3928			jsr 	IOReadByte 					; skip the 2 byte load address header
.3896	20 28 39	jsr $3928			jsr 	IOReadByte
.3899	60		rts				rts
.389a					_CACloseIn:
.389a	4c 37 39	jmp $3937			jmp 	IOReadClose
.389d					_CAResetOut:
.389d	a9 00		lda #$00			lda 	#((FreeMemory) & $FF)
.389f	85 2a		sta $2a				sta 	0+objPtr
.38a1	a9 3b		lda #$3b			lda 	#((FreeMemory) >> 8) & $FF
.38a3	85 2b		sta $2b				sta 	1+objPtr
.38a5	60		rts				rts
.38a6					_CACloseOut:
.38a6	60		rts				rts
.38a7					_CAWriteByte:
.38a7	8a		txa				txa
.38a8	92 2a		sta ($2a)			sta 	(objPtr)
.38aa	e6 2a		inc $2a				inc 	objPtr
.38ac	d0 02		bne $38b0			bne 	_HWOWBNoCarry
.38ae	e6 2b		inc $2b				inc 	objPtr+1
.38b0					_HWOWBNoCarry:
.38b0	60		rts				rts
.38b1					_CAPrintScreen:
.38b1	8a		txa				txa
.38b2	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.38b5					_CARead:
.38b5	20 28 39	jsr $3928			jsr 	IOReadByte 				; copy the address of next into the buffer
.38b8	8d cf 06	sta $06cf			sta 	SourceLine+0
.38bb	20 28 39	jsr $3928			jsr 	IOReadByte
.38be	8d d0 06	sta $06d0			sta 	SourceLine+1
.38c1	0d cf 06	ora $06cf			ora 	sourceLine				; if both were zero, exit with CC (e.g. fail)
.38c4	18		clc				clc
.38c5	f0 1e		beq $38e5			beq		_CARExit
.38c7	20 28 39	jsr $3928			jsr 	IOReadByte 				; read the line # into the buffer.
.38ca	8d d1 06	sta $06d1			sta 	SourceLine+2
.38cd	20 28 39	jsr $3928			jsr 	IOReadByte
.38d0	8d d2 06	sta $06d2			sta 	SourceLine+3
.38d3	a2 04		ldx #$04			ldx 	#4 						; read the body of the line.
.38d5					_CAReadLine:
.38d5	20 28 39	jsr $3928			jsr 	IOReadByte 				; now keep copying to EOL
.38d8	9d cf 06	sta $06cf,x			sta 	SourceLine,x
.38db	e8		inx				inx
.38dc	c9 00		cmp #$00			cmp 	#0
.38de	d0 f5		bne $38d5			bne 	_CAReadLine
.38e0	38		sec				sec 							; read a line okay
.38e1	a0 06		ldy #$06			ldy 	#SourceLine >> 8
.38e3	a2 cf		ldx #$cf			ldx 	#SourceLine & $FF
.38e5					_CARExit:
.38e5	60		rts				rts
.06cf					SourceLine:
>06cf							.fill 	256
.38e6					WriteObjectCode:
.38e6	20 1a 08	jsr $081a			jsr 	PatchOutCompile 			; makes it run the runtime on reload
.38e9	a0 39		ldy #$39			ldy 	#ObjectFile >> 8
.38eb	a2 a1		ldx #$a1			ldx 	#ObjectFile & $FF
.38ed	20 10 3a	jsr $3a10			jsr 	IOOpenWrite 				; open write
.38f0	a9 01		lda #$01			lda 	#1 							; write out the load address $0801
.38f2	20 1b 3a	jsr $3a1b			jsr 	IOWriteByte
.38f5	a9 08		lda #$08			lda 	#8
.38f7	20 1b 3a	jsr $3a1b			jsr 	IOWriteByte
.38fa	a9 01		lda #$01			lda 	#((StartBasicProgram) & $FF)
.38fc	85 2c		sta $2c				sta 	0+zTemp0
.38fe	a9 08		lda #$08			lda 	#((StartBasicProgram) >> 8) & $FF
.3900	85 2d		sta $2d				sta 	1+zTemp0
.3902					_WOCLoop:
.3902	b2 2c		lda ($2c)			lda 	(zTemp0) 					; write code
.3904	20 1b 3a	jsr $3a1b			jsr 	IOWriteByte
.3907	e6 2c		inc $2c				inc 	zTemp0 						; advance pointer
.3909	d0 02		bne $390d			bne 	_WOCSkip
.390b	e6 2d		inc $2d				inc 	zTemp0+1
.390d					_WOCSkip:
.390d	a5 2c		lda $2c				lda 	zTemp0 						; check end
.390f	c5 2a		cmp $2a				cmp 	objPtr
.3911	d0 ef		bne $3902			bne 	_WOCLoop
.3913	a5 2d		lda $2d				lda 	zTemp0+1
.3915	c5 2b		cmp $2b				cmp 	objPtr+1
.3917	d0 e9		bne $3902			bne 	_WOCLoop
.3919	20 37 39	jsr $3937			jsr 	IOWriteClose 				; close the file.
.391c	60		rts				rts
.391d					IOOpenRead:
.391d	a9 52		lda #$52			lda 	#'R' 						; read.
.391f	20 40 39	jsr $3940			jsr 	IOSetFileName 				; set up name/LFS
.3922	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for reading
.3924	20 c6 ff	jsr $ffc6			jsr 	$FFC6 						; CHKIN
.3927	60		rts				rts
.3928					IOReadByte:
.3928	da		phx				phx
.3929	5a		phy				phy
.392a	20 b7 ff	jsr $ffb7			jsr 	$FFB7 						; read ST
.392d	38		sec				sec
.392e	d0 04		bne $3934			bne 	_IORExit
.3930	20 cf ff	jsr $ffcf			jsr 	$FFCF 						; read a byte
.3933	18		clc				clc 								; status OK.
.3934					_IORExit:
.3934	7a		ply				ply
.3935	fa		plx				plx
.3936	60		rts				rts
.3937					IOReadClose:
.3937					IOWriteClose:
.3937	a9 03		lda #$03			lda 	#3 							; CLOSE# 3
.3939	20 c3 ff	jsr $ffc3			jsr 	$FFC3
.393c	20 cc ff	jsr $ffcc			jsr 	$FFCC 						; CLRCHN
.393f	60		rts				rts
.3940					IOSetFileName:
.3940	48		pha				pha 								; save R/W
.3941	86 2c		stx $2c				stx 	zTemp0
.3943	84 2d		sty $2d				sty 	zTemp0+1
.3945	a0 ff		ldy #$ff			ldy 	#$FF 						; copy name given
.3947					_IOSCopy:
.3947	c8		iny				iny 								; pre-increment copy
.3948	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.394a	99 cf 07	sta $07cf,y			sta 	IONameBuffer,y
.394d	d0 f8		bne $3947			bne 	_IOSCopy
.394f	99 d3 07	sta $07d3,y			sta 	IONameBuffer+4,y
.3952	a9 2c		lda #$2c			lda 	#',' 						; append ,S,[R|W]
.3954	99 cf 07	sta $07cf,y			sta 	IONameBuffer+0,y
.3957	99 d1 07	sta $07d1,y			sta 	IONameBuffer+2,y
.395a	a9 53		lda #$53			lda 	#'S'
.395c	99 d0 07	sta $07d0,y			sta 	IONameBuffer+1,y
.395f	68		pla				pla 								; write R/W out
.3960	99 d2 07	sta $07d2,y			sta 	IONameBuffer+3,y
.3963	98		tya				tya 								; length of name to A
.3964	18		clc				clc
.3965	69 04		adc #$04			adc 	#4 							; we added 4 characters.
.3967	a2 cf		ldx #$cf			ldx 	#IONameBuffer & $FF			; name address to YX
.3969	a0 07		ldy #$07			ldy 	#IONameBuffer >> 8
.396b	20 bd ff	jsr $ffbd		    jsr 	$FFBD          				; call SETNAM
.396e	a9 03		lda #$03	    	lda 	#3 							; set LFS to 3,8,3
.3970	a2 08		ldx #$08			ldx 	#8
.3972	a0 03		ldy #$03			ldy 	#3
.3974	20 ba ff	jsr $ffba			jsr 	$FFBA
.3977	20 c0 ff	jsr $ffc0			jsr 	$FFC0 						; OPEN
.397a	60		rts				rts
.07cf					IONameBuffer:
>07cf							.fill 	64
.397b					CompileCode:
.397b	a2 00		ldx #$00			ldx 	#0
.397d	bd b7 39	lda $39b7,x	_Prompt:lda 	Prompt,x
.3980	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3983	e8		inx				inx
.3984	c9 00		cmp #$00			cmp 	#0
.3986	d0 f5		bne $397d			bne 	_Prompt
.3988	a2 9d		ldx #$9d			ldx 	#APIDesc & $FF
.398a	a0 39		ldy #$39			ldy 	#APIDesc >> 8
.398c	20 ae 2a	jsr $2aae			jsr 	StartCompiler
.398f	20 e6 38	jsr $38e6			jsr 	WriteObjectCode
.3992	a9 4f		lda #$4f			lda 	#"O"
.3994	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3997	a9 4b		lda #$4b			lda 	#"K"
.3999	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.399c	60		rts				rts
.399d					APIDesc:
>399d	6f 38						.word 	CompilerAPI 				; the compiler API Implementeation
>399f	80						.byte 	$80 						; start of workspace for compiler $8000
>39a0	9f						.byte 	$9F							; end of workspace for compiler $9F00
.39a1					ObjectFile:
>39a1	4f 42 4a 45 43 54 2e 50				.text 	'OBJECT.PRG',0
>39a9	52 47 00
.39ac					SourceFile:
>39ac	53 4f 55 52 43 45 2e 50				.text 	'SOURCE.PRG',0
>39b4	52 47 00
.39b7					Prompt:
>39b7	2a 2a 2a 20 42 4c 49 54				.text 	'*** BLITZ (ALPHA 09-10-23) ***',13,13
>39bf	5a 20 28 41 4c 50 48 41 20 30 39 2d 31 30 2d 32
>39cf	33 29 20 2a 2a 2a 0d 0d
>39d7	42 55 47 53 3a 48 54 54				.text 	'BUGS:HTTPS://GITHUB.COM/PAULSCOTTROBSON/BLITZ-COMPILER',13,13,0
>39df	50 53 3a 2f 2f 47 49 54 48 55 42 2e 43 4f 4d 2f
>39ef	50 41 55 4c 53 43 4f 54 54 52 4f 42 53 4f 4e 2f
>39ff	42 4c 49 54 5a 2d 43 4f 4d 50 49 4c 45 52 0d 0d
>3a0f	00
.3a10					IOOpenWrite:
.3a10	a9 57		lda #$57			lda 	#'W'			 			; write
.3a12	20 40 39	jsr $3940			jsr 	IOSetFileName 				; set up name/LFS
.3a15	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for writing
.3a17	20 c9 ff	jsr $ffc9			jsr 	$FFC9 						; CHKOUT
.3a1a	60		rts				rts
.3a1b					IOWriteByte:
.3a1b	48		pha				pha
.3a1c	da		phx				phx
.3a1d	5a		phy				phy
.3a1e	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a21	7a		ply				ply
.3a22	fa		plx				plx
.3a23	68		pla				pla
.3a24	60		rts				rts

;******  Processing input file: source/main/zzfree.footer

>3a25							.align 	256
.3b00					FreeMemory:

;******  End of listing
