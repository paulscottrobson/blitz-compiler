
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl source/main/00main.header /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library _library.asm source/main/zzfree.footer
; Sat Oct 14 16:10:51 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: source/main/00main.header

.0801					StartBasicProgram:
>0801	0c 08						.word 	$080C 						; offset to next.
>0803	0a 00						.word 	10 							; line #
>0805	9e						.byte 	$9E 						; token for 'SYS'
>0806	20 32 30 36 32					.text 	' 2062'						; space, $080E in decimal
>080b	00						.byte  	0 							; end of line
>080c	00 00						.word 	0 							; end of program
.080e					StartCode:
.080e	4c f2 39	jmp $39f2			jmp 	CompileCode 				; to starting the runtime in the saved code.
.0811	a9 3b		lda #$3b			lda 	#FreeMemory >> 8 			; address of object code to run.
.0813	a2 80		ldx #$80			ldx 	#$80 						; 8000-9EFF is used for workspace.
.0815	a0 9f		ldy #$9f			ldy 	#$9F
.0817	4c 26 08	jmp $0826			jmp 	StartRuntime 				; and go do it !
.081a					PatchOutCompile:
.081a	a9 ea		lda #$ea			lda 	#$EA 						; $EA is NOP 65C02
.081c	8d 0e 08	sta $080e			sta 	StartCode 					; patch out "JMP COMPILECODE"
.081f	8d 0f 08	sta $080f			sta 	StartCode+1
.0822	8d 10 08	sta $0810			sta 	StartCode+2
.0825	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.0826					StartRuntime:
.0826	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.0829	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.082b	64 28		stz $28				stz 	codePtr
.082d	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0830	8c 06 04	sty $0406			sty 	storeEndHigh
.0833	8e 07 04	stx $0407			stx 	variableStartPage
.0836	ba		tsx				tsx 								; save the stack.
.0837	8e 08 04	stx $0408			stx 	Runtime6502SP
.083a	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.083c	a2 58		ldx #$58			ldx 	#RuntimeErrorHandler & $FF
.083e	20 2c 1f	jsr $1f2c			jsr 	SetErrorHandler
.0841	20 84 0a	jsr $0a84			jsr 	ClearMemory 				; clear memory.
.0844	20 a9 16	jsr $16a9			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0847	20 95 13	jsr $1395		 	jsr		SetDefaultChannel			; set default input/output channel.
.084a	20 e1 15	jsr $15e1			jsr 	RestoreCode 				; which we now call
.084d	a0 00		ldy #$00			ldy 	#0
.084f					NextCommand:
.084f	ad 09 04	lda $0409			lda  	breakCount 					; only check every 16 instructions.
.0852	69 10		adc #$10			adc 	#16
.0854	8d 09 04	sta $0409			sta 	breakCount
.0857	90 07		bcc $0860			bcc 	_NXNoCheck
.0859	da		phx				phx
.085a	5a		phy				phy 								; check Ctrl+C
.085b	20 e7 1b	jsr $1be7			jsr 	XCheckStop
.085e	7a		ply				ply
.085f	fa		plx				plx
.0860					_NXNoCheck:
.0860	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.0862	30 5b		bmi $08bf			bmi 	NXCommand 					; -if -ve command
.0864	c8		iny				iny
.0865	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0867	90 39		bcc $08a2			bcc 	PushByteA 					; 0..63 is short constants.
.0869					NXLoadStore:
.0869	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.086b	b0 19		bcs $0886			bcs 	NXIndirectLoadStore
.086d	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.086e	4a		lsr a				lsr 	a
.086f	29 0e		and #$0e			and 	#$0E
.0871	da		phx				phx 								; get ready to jump
.0872	aa		tax				tax
.0873	7c 76 08	jmp ($0876,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.0876					ReadWriteVectors:
>0876	01 15						.word 	ReadFloatCommand			; read float
>0878	f6 1a						.word 	WriteFloatCommand 			; write float
>087a	3d 15						.word 	ReadIntegerCommand 			; read integer
>087c	32 1b						.word 	WriteIntegerCommand 		; write integer
>087e	82 15						.word 	ReadStringCommand 			; read string
>0880	71 1b						.word 	WriteStringCommand 			; write string
>0882	55 0c						.word 	Unimplemented
>0884	55 0c						.word 	Unimplemented
.0886					NXIndirectLoadStore:
.0886	29 07		and #$07			and 	#7
.0888	0a		asl a				asl 	a
.0889	da		phx				phx
.088a	aa		tax				tax
.088b	7c 8e 08	jmp ($088e,x)			jmp 	(IndirectVectors,x)
.088e					IndirectVectors:
>088e	12 0f						.word 	IndFloatRead 				; float read
>0890	26 0f						.word 	IndInt16Read 				; int16 read
>0892	3a 0f						.word 	IndStringRead 				; string read
>0894	55 0c						.word 	Unimplemented
>0896	4e 0f						.word 	IndFloatWrite				; float write
>0898	62 0f						.word 	IndInt16Write 				; int16 write
>089a	76 0f						.word 	IndStringWrite 				; string write
>089c	55 0c						.word 	Unimplemented
.089e					PushByteCommand:
.089e	fa		plx				plx
.089f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.08a1	c8		iny				iny
.08a2					PushByteA:
.08a2	e8		inx				inx 								; push constant on stack
.08a3	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.08a5	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.08a7					ClearRestWord:
.08a7	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.08a9	74 62		stz $62,x			stz 	NSMantissa3,x
.08ab	74 6e		stz $6e,x			stz 	NSExponent,x
.08ad	74 32		stz $32,x			stz 	NSStatus,x
.08af	80 9e		bra $084f			bra 	NextCommand
.08b1					PushWordCommand:
.08b1	fa		plx				plx
.08b2	e8		inx				inx
.08b3	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.08b5	c8		iny				iny
.08b6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08b8	b1 28		lda ($28),y			lda 	(codePtr),y
.08ba	c8		iny				iny
.08bb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08bd	80 e8		bra $08a7			bra 	ClearRestWord 				; handle everything else.
.08bf					NXCommand:
.08bf	c8		iny				iny 								; consume command.
.08c0	10 03		bpl $08c5			bpl 	_NXCommandNoFixUp
.08c2	20 cb 08	jsr $08cb			jsr 	FixUpY
.08c5					_NXCommandNoFixUp:
.08c5	0a		asl a				asl 	a 							; shift left
.08c6	da		phx				phx 								; save SP on stack
.08c7	aa		tax				tax				 					; and jump indirect
.08c8	7c d3 19	jmp ($19d3,x)			jmp 	(VectorTable,x)
.08cb					FixUpY:
.08cb	48		pha				pha
.08cc	98		tya				tya
.08cd	18		clc				clc
.08ce	65 28		adc $28				adc 	codePtr
.08d0	85 28		sta $28				sta 	codePtr
.08d2	90 02		bcc $08d6			bcc 	_NoCPCarry
.08d4	e6 29		inc $29				inc 	codePtr+1
.08d6					_NoCPCarry:
.08d6	a0 00		ldy #$00			ldy 	#0
.08d8	68		pla				pla
.08d9	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.0408					Runtime6502SP:
>0408							.fill 	1
.0409					breakCount:
>0409							.fill 	1
.08da					AbsoluteTOS:
.08da	fa		plx				plx
.08db	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.08e0					CommandVarSpace:
.08e0	fa		plx				plx
.08e1	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08e3	85 26		sta $26				sta 	availableMemory
.08e5	c8		iny				iny
.08e6	b1 28		lda ($28),y			lda 	(codePtr),y
.08e8	18		clc				clc
.08e9	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08ec	85 27		sta $27				sta 	availableMemory+1
.08ee	c8		iny				iny
.08ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08f2					BinaryAnd:
.08f2	fa		plx				plx
.08f3	38		sec				sec
.08f4	80 02		bra $08f8			bra 	AndOrCommon
.08f6					BinaryOr:
.08f6	fa		plx				plx
.08f7	18		clc				clc
.08f8					AndOrCommon:
.08f8	08		php				php 								; save AND/OR flag
.08f9	20 4d 10	jsr $104d			jsr 	GetInteger16Bit
.08fc	ca		dex				dex
.08fd	20 4d 10	jsr $104d			jsr 	GetInteger16Bit
.0900	28		plp				plp
.0901	90 0e		bcc $0911			bcc 	_AOCOrCode
.0903	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.0905	35 3f		and $3f,x			and		NSMantissa0+1,x
.0907	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0909	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.090b	35 4b		and $4b,x			and		NSMantissa1+1,x
.090d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.090f	80 0c		bra $091d			bra 	_AOCComplete
.0911					_AOCOrCode:
.0911	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.0913	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.0915	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0917	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0919	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.091b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.091d					_AOCComplete:
.091d	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.091f	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.0921	10 07		bpl $092a			bpl 	_AOCExit
.0923	20 5d 10	jsr $105d			jsr 	Negate16Bit 				; 2's complement
.0926	a9 80		lda #$80			lda 	#$80 						; make it -ve
.0928	95 32		sta $32,x			sta 	NSStatus,x
.092a					_AOCExit:
.092a	4c 4f 08	jmp $084f			jmp 	NextCommand
.092d					ArrayConvert:
.092d	fa		plx				plx
.092e	5a		phy				phy
.092f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0931	85 2e		sta $2e				sta 	zTemp1
.0933	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0935	18		clc				clc
.0936	6d 07 04	adc $0407			adc 	variableStartPage
.0939	85 2f		sta $2f				sta 	zTemp1+1
.093b	ca		dex				dex 								; count of indices to follow -> zTemp2
.093c	20 47 10	jsr $1047			jsr 	GetInteger8Bit
.093f	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.0941	8a		txa				txa
.0942	38		sec				sec
.0943	e5 30		sbc $30				sbc 	zTemp2
.0945	aa		tax				tax
.0946	da		phx				phx 								; stack points at the first index, which will be replaced.
.0947					_ACIndexLoop:
.0947	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart 			; integer array index
.094a	20 4d 10	jsr $104d			jsr 	GetInteger16Bit 			; get the index => zTemp0
.094d	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.094f	a5 2c		lda $2c				lda 	zTemp0
.0951	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0953	a5 2d		lda $2d				lda 	zTemp0+1
.0955	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0957	b0 79		bcs $09d2			bcs 	_ACBadIndex 				; index error.
.0959	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.095b	f0 29		beq $0986			beq 	_ACInnerLevel
.095d	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.095f	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0961	10 6f		bpl $09d2			bpl 	_ACBadIndex
.0963	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0965	26 2d		rol $2d				rol 	zTemp0+1
.0967	18		clc				clc
.0968	a5 2c		lda $2c				lda		zTemp0
.096a	65 2e		adc $2e				adc 	zTemp1
.096c	85 2c		sta $2c				sta 	zTemp0
.096e	a5 2d		lda $2d				lda		zTemp0+1
.0970	65 2f		adc $2f				adc 	zTemp1+1
.0972	85 2d		sta $2d				sta 	zTemp0+1
.0974	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.0976	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0978	85 2e		sta $2e				sta 	zTemp1
.097a	c8		iny				iny
.097b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.097d	18		clc				clc
.097e	6d 07 04	adc $0407			adc 	variableStartPage
.0981	85 2f		sta $2f				sta 	zTemp1+1
.0983	e8		inx				inx 								; next index
.0984	80 c1		bra $0947			bra 	_ACIndexLoop
.0986					_ACInnerLevel:
.0986	a0 02		ldy #$02			ldy 	#2
.0988	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.098a	30 46		bmi $09d2			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.098c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.098e	c9 00		cmp #$00			cmp 	#NSSIFloat
.0990	d0 13		bne $09a5			bne 	_ACNotFloat
.0992	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.0994	48		pha				pha
.0995	a5 2c		lda $2c				lda 	zTemp0
.0997	06 2c		asl $2c				asl 	zTemp0 						; x 2
.0999	26 2d		rol $2d				rol 	zTemp0+1
.099b	18		clc				clc 								; add back x 3
.099c	65 2c		adc $2c				adc 	zTemp0
.099e	85 2c		sta $2c				sta 	zTemp0
.09a0	68		pla				pla
.09a1	65 2d		adc $2d				adc 	zTemp0+1
.09a3	85 2d		sta $2d				sta 	zTemp0+1
.09a5					_ACNotFloat:
.09a5	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.09a7	26 2d		rol $2d				rol 	zTemp0+1
.09a9	18		clc				clc
.09aa	a5 2c		lda $2c				lda 	zTemp0
.09ac	69 03		adc #$03			adc 	#3
.09ae	85 2c		sta $2c				sta 	zTemp0
.09b0	90 02		bcc $09b4			bcc 	_ACNoCarry
.09b2	e6 2d		inc $2d				inc 	zTemp0+1
.09b4					_ACNoCarry:
.09b4	fa		plx				plx 								; X points to first slot of array parameters
.09b5	18		clc				clc
.09b6	a5 2c		lda $2c				lda 	zTemp0
.09b8	65 2e		adc $2e				adc 	zTemp1
.09ba	95 3e		sta $3e,x			sta 	NSMantissa0,x
.09bc	a5 2d		lda $2d				lda 	zTemp0+1
.09be	65 2f		adc $2f				adc 	zTemp1+1
.09c0	38		sec				sec
.09c1	ed 07 04	sbc $0407			sbc 	variableStartPage
.09c4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.09c6	74 56		stz $56,x			stz 	NSMantissa2,x
.09c8	74 62		stz $62,x			stz 	NSMantissa3,x
.09ca	74 32		stz $32,x			stz 	NSStatus,x
.09cc	74 6e		stz $6e,x			stz 	NSExponent,x
.09ce	7a		ply				ply 	 							; restore code pointer
.09cf	4c 4f 08	jmp $084f			jmp 	NextCommand
.09d2					_ACBadIndex:
.09d2	4c 2e 20	jmp $202e		jmp	ErrorV_index
.09d5					UnaryAsc:
.09d5	fa		plx				plx
.09d6	5a		phy				phy
.09d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09d9	85 2c		sta $2c				sta 	zTemp0
.09db	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09dd	85 2d		sta $2d				sta 	zTemp0+1
.09df	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09e1	f0 06		beq $09e9			beq 	_UAExit
.09e3	5a		phy				phy 								; otherwise first character
.09e4	a0 01		ldy #$01			ldy 	#1
.09e6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09e8	7a		ply				ply
.09e9					_UAExit:
.09e9	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.09ec	7a		ply				ply
.09ed	4c 4f 08	jmp $084f			jmp 	NextCommand
.09f0					CommandAssert:
.09f0	fa		plx				plx
.09f1	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09f3	d0 09		bne $09fe			bne 	_CAFail
.09f5	20 cd 26	jsr $26cd			jsr 	FloatIsZero 				; is it zero ?
.09f8	f0 04		beq $09fe			beq 	_CAFail
.09fa	ca		dex				dex
.09fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.09fe					_CAFail:
.09fe	4c 87 1f	jmp $1f87		jmp	ErrorV_assert
.0a01					X16_Audio_Parameters8_16:
.0a01	20 07 0a	jsr $0a07			jsr 	X16_Audio_Parameters8_8
.0a04	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.0a06	60		rts				rts
.0a07					X16_Audio_Parameters8_8:
.0a07	a2 01		ldx #$01			ldx 	#1
.0a09	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.0a0c	ca		dex				dex
.0a0d	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.0a10	20 47 10	jsr $1047			jsr 	GetInteger8Bit
.0a13	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.0a15	a0 00		ldy #$00			ldy 	#0
.0a17	60		rts				rts
.0a18					X16_Audio_Parameters8_String:
.0a18	20 01 0a	jsr $0a01			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.0a1b	da		phx				phx 								; set the voice
.0a1c	5a		phy				phy
.0a1d	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.0a20	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>0a23	0a						.byte 	X16_AudioCodeBank
.0a24	7a		ply				ply
.0a25	fa		plx				plx
.0a26	86 2c		stx $2c				stx 	zTemp0
.0a28	84 2d		sty $2d				sty 	zTemp0+1
.0a2a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a2c	e8		inx				inx 								; point YX to first character.
.0a2d	d0 01		bne $0a30			bne 	_X16APSSkip
.0a2f	c8		iny				iny
.0a30					_X16APSSkip:
.0a30	60		rts				rts
.0a31					Unary16Bin:
.0a31	fa		plx				plx
.0a32	20 4d 10	jsr $104d			jsr 	GetInteger16Bit				; 16 bit int
.0a35	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a37	20 52 17	jsr $1752			jsr 	StringAllocTemp
.0a3a	a5 2d		lda $2d				lda 	zTemp0+1
.0a3c	f0 03		beq $0a41			beq 	_UBNoHigh
.0a3e	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a41					_UBNoHigh:
.0a41	a5 2c		lda $2c				lda 	zTemp0
.0a43	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a46	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a49					_UBWriteBinary:
.0a49	5a		phy				phy
.0a4a	a0 08		ldy #$08			ldy 	#8
.0a4c					_UBWLoop:
.0a4c	0a		asl a				asl 	a
.0a4d	48		pha				pha
.0a4e	a9 00		lda #$00			lda  	#0
.0a50	69 30		adc #$30			adc 	#48
.0a52	20 7b 17	jsr $177b			jsr 	StringWriteChar
.0a55	68		pla				pla
.0a56	88		dey				dey
.0a57	d0 f3		bne $0a4c			bne 	_UBWLoop
.0a59	7a		ply				ply
.0a5a	60		rts				rts
.0a5b					PrintCharacterX:
.0a5b	fa		plx				plx
.0a5c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a5e	ca		dex				dex
.0a5f	20 99 13	jsr $1399			jsr 	VectorPrintCharacter
.0a62	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a65					UnaryChr:
.0a65	fa		plx				plx
.0a66	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; get integer to convert.
.0a69	48		pha				pha 								; save it and allocate for it
.0a6a	a9 01		lda #$01			lda 	#1 							; 1 character
.0a6c	20 52 17	jsr $1752			jsr 	StringAllocTemp
.0a6f	a9 01		lda #$01			lda 	#1 							; length 1.
.0a71	92 22		sta ($22)			sta 	(zsTemp)
.0a73	68		pla				pla 								; character code makes string.
.0a74	5a		phy				phy
.0a75	a0 01		ldy #$01			ldy 	#1
.0a77	91 22		sta ($22),y			sta 	(zsTemp),y
.0a79	7a		ply				ply
.0a7a	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a7d					CommandClr:
.0a7d	fa		plx				plx
.0a7e	20 84 0a	jsr $0a84			jsr 	ClearMemory
.0a81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a84					ClearMemory:
.0a84	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a87	85 2d		sta $2d				sta 	zTemp0+1
.0a89	64 2c		stz $2c				stz 	zTemp0
.0a8b	5a		phy				phy
.0a8c	a0 00		ldy #$00			ldy 	#0
.0a8e					_ClearLoop1:
.0a8e	a9 00		lda #$00			lda 	#0
.0a90	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a92	c8		iny				iny
.0a93	d0 f9		bne $0a8e			bne 	_ClearLoop1
.0a95	e6 2d		inc $2d				inc 	zTemp0+1
.0a97	a5 2d		lda $2d				lda 	zTemp0+1
.0a99	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a9c	d0 f0		bne $0a8e			bne 	_ClearLoop1
.0a9e	38		sec				sec 											; stack space = number of pages in total / 4
.0a9f	ad 06 04	lda $0406			lda 	storeEndHigh
.0aa2	ed 05 04	sbc $0405			sbc		storeStartHigh
.0aa5	4a		lsr a				lsr 	a
.0aa6	4a		lsr a				lsr 	a
.0aa7	d0 02		bne $0aab			bne 	_NotEmpty 								; at least 1 !
.0aa9	a9 01		lda #$01			lda 	#1
.0aab					_NotEmpty:
.0aab	38		sec				sec 											; subtract from high to give string high memory
.0aac	49 ff		eor #$ff			eor 	#$FF
.0aae	6d 06 04	adc $0406			adc 	storeEndHigh
.0ab1	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0ab4	9c 02 04	stz $0402			stz 	stringHighMemory
.0ab7	9c 6a 05	stz $056a			stz 	stringInitialised 						; string system not initialised
.0aba	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0abd	3a		dec a				dec 	a
.0abe	85 25		sta $25				sta 	runtimeStackPtr+1
.0ac0	a9 ff		lda #$ff			lda 	#$FF
.0ac2	85 24		sta $24				sta 	runtimeStackPtr
.0ac4	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0ac6	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0ac8	7a		ply				ply
.0ac9	60		rts				rts
.0aca					CompareStrings:
.0aca	fa		plx				plx
.0acb	ca		dex				dex
.0acc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0ace	85 2c		sta $2c				sta 	zTemp0
.0ad0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ad2	85 2d		sta $2d				sta 	zTemp0+1
.0ad4	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0ad6	85 2e		sta $2e				sta 	zTemp1
.0ad8	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0ada	85 2f		sta $2f				sta 	zTemp1+1
.0adc	da		phx				phx
.0add	5a		phy				phy
.0ade	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0ae0	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0ae2	90 02		bcc $0ae6			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0ae4	b2 2e		lda ($2e)			lda 	(zTemp1)
.0ae6					_CSNIsSmallest:
.0ae6	aa		tax				tax 								; count in X
.0ae7	f0 0c		beq $0af5			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0ae9	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0aeb					_CSNCompareString:
.0aeb	c8		iny				iny 								; pre increment
.0aec	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0aee	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0af0	d0 0a		bne $0afc			bne 	_CSNDifferent 				; numbers are different.
.0af2	ca		dex				dex
.0af3	d0 f6		bne $0aeb			bne 	_CSNCompareString 			; compare common characters in two strings.
.0af5					_CSNMatches:
.0af5	38		sec				sec
.0af6	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0af8	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0afa	f0 06		beq $0b02			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0afc					_CSNDifferent:
.0afc	a9 ff		lda #$ff			lda 	#$FF
.0afe	90 02		bcc $0b02			bcc 	_CSNSExit
.0b00	a9 01		lda #$01			lda 	#$01
.0b02					_CSNSExit:
.0b02	7a		ply				ply
.0b03	fa		plx				plx
.0b04	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0b06	20 ad 26	jsr $26ad			jsr 	FloatSetByte 				; output the byte
.0b09	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b0c					StringConcrete:
.0b0c	9c 6a 05	stz $056a			stz 	stringInitialised	 		; initialise next usage
.0b0f	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0b11	85 30		sta $30				sta 	zTemp2
.0b13	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0b15	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0b16	18		clc				clc
.0b17	72 30		adc ($30)			adc 	(zTemp2)
.0b19	90 02		bcc $0b1d			bcc 	_SCNoOverflow
.0b1b	a9 ff		lda #$ff			lda 	#255
.0b1d					_SCNoOverflow:
.0b1d	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0b1f	b0 02		bcs $0b23			bcs 	_SCNoMinimum
.0b21	a9 0a		lda #$0a			lda 	#10
.0b23					_SCNoMinimum:
.0b23	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0b25	38		sec				sec
.0b26	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0b29	e5 2e		sbc $2e				sbc 	zTemp1
.0b2b	a8		tay				tay
.0b2c	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b2f	e9 00		sbc #$00			sbc 	#0
.0b31	48		pha				pha
.0b32	38		sec				sec 								; subtract 3 more
.0b33	98		tya				tya
.0b34	e9 03		sbc #$03			sbc 	#3
.0b36	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b39	85 22		sta $22				sta 	zsTemp
.0b3b	68		pla				pla
.0b3c	e9 00		sbc #$00			sbc 	#0
.0b3e	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b41	85 23		sta $23				sta 	zsTemp+1
.0b43	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b45	92 22		sta ($22)			sta 	(zsTemp)
.0b47	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b49	a9 00		lda #$00			lda 	#0
.0b4b	91 22		sta ($22),y			sta 	(zsTemp),y
.0b4d	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b4f	a4 23		ldy $23				ldy 	zsTemp+1
.0b51	60		rts				rts
.0b52					CommandXData:
.0b52	fa		plx				plx
.0b53	98		tya				tya 								; data length +1 added to Y
.0b54	38		sec				sec
.0b55	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b57	a8		tay				tay
.0b58	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b5b					CommandXDIM:
.0b5b	fa		plx				plx
.0b5c	5a		phy				phy
.0b5d	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b60	8d 0a 04	sta $040a			sta 	dimType
.0b63	ca		dex				dex 								; this is the number of indices
.0b64	20 47 10	jsr $1047			jsr 	GetInteger8Bit
.0b67	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b69	8a		txa				txa 								; dimension.
.0b6a	38		sec				sec
.0b6b	e5 2e		sbc $2e				sbc 	zTemp1
.0b6d	aa		tax				tax
.0b6e	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b70	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create one at this level
.0b73	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b75	98		tya				tya
.0b76	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b78	74 56		stz $56,x			stz 	NSMantissa2,x
.0b7a	74 62		stz $62,x			stz 	NSMantissa3,x
.0b7c	74 32		stz $32,x			stz 	NSStatus,x
.0b7e	74 6e		stz $6e,x			stz 	NSExponent,x
.0b80	7a		ply				ply
.0b81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b84					DIMCreateOneLevel:
.0b84	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b86	5a		phy				phy
.0b87	a4 27		ldy $27				ldy 	availableMemory+1
.0b89	5a		phy				phy
.0b8a	a8		tay				tay 			 					; save current level into Y
.0b8b	20 4d 10	jsr $104d			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b8e	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b90	d0 02		bne $0b94			bne 	_DCOLNoCarry
.0b92	e6 2d		inc $2d				inc 	zTemp0+1
.0b94					_DCOLNoCarry:
.0b94	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b96	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b99	a5 2d		lda $2d				lda 	zTemp0+1
.0b9b	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b9e	ad 0a 04	lda $040a			lda 	dimType 					; get type information
.0ba1	29 7f		and #$7f			and 	#$7F
.0ba3	c0 01		cpy #$01			cpy 	#1
.0ba5	f0 02		beq $0ba9			beq 	_DCOLNoSubLevel
.0ba7	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0ba9					_DCOLNoSubLevel:
.0ba9	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0bac	a5 26		lda $26				lda 	availableMemory
.0bae	85 2e		sta $2e				sta 	zTemp1
.0bb0	a5 27		lda $27				lda 	availableMemory+1
.0bb2	85 2f		sta $2f				sta 	zTemp1+1
.0bb4	a5 2c		lda $2c				lda 	zTemp0
.0bb6	85 30		sta $30				sta 	zTemp2
.0bb8	a5 2d		lda $2d				lda 	zTemp0+1
.0bba	85 31		sta $31				sta 	zTemp2+1
.0bbc					_DCOLFillArray:
.0bbc	20 1b 0c	jsr $0c1b			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0bbf	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0bc1	d0 02		bne $0bc5			bne 	_DCOLNoBorrow
.0bc3	c6 2d		dec $2d				dec 	zTemp0+1
.0bc5					_DCOLNoBorrow:
.0bc5	c6 2c		dec $2c				dec 	zTemp0
.0bc7	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0bc9	05 2d		ora $2d				ora 	zTemp0+1
.0bcb	d0 ef		bne $0bbc			bne 	_DCOLFillArray
.0bcd	c0 01		cpy #$01			cpy 	#1
.0bcf	f0 42		beq $0c13			beq 	_DCOLExit
.0bd1					_DCOLRecursionLoop:
.0bd1	da		phx				phx 								; save XY
.0bd2	5a		phy				phy
.0bd3	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0bd5	48		pha				pha
.0bd6	a5 2f		lda $2f				lda 	zTemp1+1
.0bd8	48		pha				pha
.0bd9	a5 30		lda $30				lda 	zTemp2
.0bdb	48		pha				pha
.0bdc	a5 31		lda $31				lda 	zTemp2+1
.0bde	48		pha				pha
.0bdf	88		dey				dey  								; lower level -> A
.0be0	98		tya				tya
.0be1	e8		inx				inx 								; next index size
.0be2	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0be5	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0be6	86 31		stx $31				stx 	zTemp2+1
.0be8	fa		plx				plx
.0be9	86 30		stx $30				stx 	zTemp2
.0beb	fa		plx				plx
.0bec	86 2f		stx $2f				stx 	zTemp1+1
.0bee	fa		plx				plx
.0bef	86 2e		stx $2e				stx 	zTemp1
.0bf1	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0bf3	98		tya				tya
.0bf4	a0 01		ldy #$01			ldy 	#1
.0bf6	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0bf8	7a		ply				ply 								; restore XY
.0bf9	fa		plx				plx
.0bfa	18		clc				clc
.0bfb	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0bfd	69 02		adc #$02			adc 	#2
.0bff	85 2e		sta $2e				sta 	zTemp1
.0c01	90 02		bcc $0c05			bcc 	_DCOLRNoCarry
.0c03	e6 2f		inc $2f				inc 	zTemp1+1
.0c05					_DCOLRNoCarry:
.0c05	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0c07	d0 02		bne $0c0b			bne 	_DCOLRNoBorrow
.0c09	c6 31		dec $31				dec 	zTemp2+1
.0c0b					_DCOLRNoBorrow:
.0c0b	c6 30		dec $30				dec 	zTemp2
.0c0d	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0c0f	05 31		ora $31				ora 	zTemp2+1
.0c11	d0 be		bne $0bd1			bne 	_DCOLRecursionLoop
.0c13					_DCOLExit:
.0c13	68		pla				pla 								; get MSB, make offset again
.0c14	38		sec				sec
.0c15	ed 07 04	sbc $0407			sbc 	variableStartPage
.0c18	a8		tay				tay
.0c19	68		pla				pla 								; YA now contains offset address.
.0c1a	60		rts				rts
.0c1b					DIMWriteElement:
.0c1b	da		phx				phx
.0c1c	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0c1e	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0c20	d0 0b		bne $0c2d			bne 	_DIMWENotFloat
.0c22	ad 0a 04	lda $040a			lda 	dimType
.0c25	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0c27	c9 00		cmp #$00			cmp 	#NSSIFloat
.0c29	d0 02		bne $0c2d			bne 	_DIMWENotFloat
.0c2b	a2 06		ldx #$06			ldx 	#6
.0c2d					_DIMWENotFloat:
.0c2d	a9 00		lda #$00			lda 	#0
.0c2f	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0c32	ca		dex				dex
.0c33	d0 f8		bne $0c2d			bne 	_DIMWENotFloat
.0c35	fa		plx				plx
.0c36	60		rts				rts
.0c37					DIMWriteByte:
.0c37	92 26		sta ($26)			sta 	(availableMemory)
.0c39	e6 26		inc $26				inc 	availableMemory
.0c3b	d0 0b		bne $0c48			bne 	_DIMWBSkip
.0c3d	e6 27		inc $27				inc 	availableMemory+1
.0c3f	48		pha				pha
.0c40	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c42	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c45	b0 02		bcs $0c49			bcs 	_DIMWBMemory
.0c47	68		pla				pla
.0c48					_DIMWBSkip:
.0c48	60		rts				rts
.0c49					_DIMWBMemory:
.0c49	4c 41 20	jmp $2041		jmp	ErrorV_memory
.040a					dimType:
>040a							.fill 	1
.0c4c					CommandEnd:
.0c4c	fa		plx				plx
.0c4d	86 2c		stx $2c				stx 	zTemp0
.0c4f	18		clc				clc 								; exited okay.
.0c50					EndRuntime:
.0c50	ae 08 04	ldx $0408			ldx 	Runtime6502SP 				; set up the stack pointer
.0c53	9a		txs				txs
.0c54	60		rts				rts
.0c55					Unimplemented:
.0c55	4c 74 1f	jmp $1f74			jmp 	ErrorV_unimplemented
.0c58					RuntimeErrorHandler:
.0c58	98		tya				tya
.0c59	18		clc				clc
.0c5a	65 28		adc $28				adc 	codePtr
.0c5c	85 28		sta $28				sta 	codePtr
.0c5e	90 02		bcc $0c62			bcc 	_EHNoCarry
.0c60	e6 29		inc $29				inc 	codePtr+1
.0c62					_EHNoCarry:
.0c62	68		pla				pla
.0c63	7a		ply				ply
.0c64	85 2c		sta $2c				sta 	zTemp0
.0c66	84 2d		sty $2d				sty 	zTemp0+1
.0c68	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c6a	a0 01		ldy #$01			ldy 	#1
.0c6c					_EHDisplayMsg:
.0c6c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c6e	20 d4 1c	jsr $1cd4			jsr 	XPrintCharacterToChannel
.0c71	c8		iny				iny
.0c72	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c74	d0 f6		bne $0c6c			bne 	_EHDisplayMsg
.0c76	a9 20		lda #$20			lda 	#32
.0c78	20 d4 1c	jsr $1cd4			jsr 	XPrintCharacterToChannel
.0c7b	a9 40		lda #$40			lda 	#64
.0c7d	20 d4 1c	jsr $1cd4			jsr 	XPrintCharacterToChannel
.0c80	a9 20		lda #$20			lda 	#32
.0c82	20 d4 1c	jsr $1cd4			jsr 	XPrintCharacterToChannel
.0c85	20 8c 0c	jsr $0c8c			jsr 	EHDisplayCodePtr
.0c88	38		sec				sec 								; report error.
.0c89	4c 50 0c	jmp $0c50			jmp 	EndRuntime
.0c8c					EHDisplayCodePtr:
.0c8c	a9 24		lda #$24			lda 	#'$'
.0c8e	20 d4 1c	jsr $1cd4			jsr 	XPrintCharacterToChannel
.0c91	38		sec				sec
.0c92	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c94	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c97	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9a	a5 28		lda $28				lda 	codePtr
.0c9c	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9f	60		rts				rts
.0ca0					_EHDisplayHex:
.0ca0	48		pha				pha
.0ca1	4a		lsr a				lsr 	a
.0ca2	4a		lsr a				lsr 	a
.0ca3	4a		lsr a				lsr 	a
.0ca4	4a		lsr a				lsr 	a
.0ca5	20 a9 0c	jsr $0ca9			jsr 	_EHDisplayNibble
.0ca8	68		pla				pla
.0ca9					_EHDisplayNibble:
.0ca9	29 0f		and #$0f			and 	#15
.0cab	c9 0a		cmp #$0a			cmp 	#10
.0cad	90 02		bcc $0cb1			bcc 	_EHNotHex
.0caf	69 06		adc #$06			adc 	#6
.0cb1					_EHNotHex:
.0cb1	69 30		adc #$30			adc 	#48
.0cb3	4c d4 1c	jmp $1cd4			jmp 	XPrintCharacterToChannel
.0cb6					CommandXFor:
.0cb6	fa		plx				plx
.0cb7	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0cb9	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0cbc	20 7e 11	jsr $117e			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0cbf	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0cc1	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cc4	ca		dex				dex
.0cc5	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0cc7	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cca	ca		dex				dex
.0ccb	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0ccd	29 80		and #$80			and 	#$80
.0ccf	a0 04		ldy #$04			ldy 	#4
.0cd1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd3	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0cd5	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0cd7	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd9	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0cdb	c8		iny				iny
.0cdc	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cde	18		clc				clc
.0cdf	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0ce1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ce3	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0ce6	85 2d		sta $2d				sta 	zTemp0+1
.0ce8	ca		dex				dex 								; throw reference.
.0ce9	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0ceb	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0ced	a0 0c		ldy #$0c			ldy 	#12
.0cef	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf1	a0 12		ldy #$12			ldy 	#18
.0cf3	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf5	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0cf7	88		dey				dey 								; now the exponents.
.0cf8	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0cfa	a0 0b		ldy #$0b			ldy 	#11
.0cfc	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cfe	a0 11		ldy #$11			ldy 	#17
.0d00	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d02	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0d04	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d06	c8		iny				iny
.0d07	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d09	c8		iny				iny
.0d0a	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d0c	d0 08		bne $0d16			bne 	_CFNoOptimise
.0d0e	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0d10	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0d12	09 40		ora #$40			ora 	#$40
.0d14	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d16					_CFNoOptimise:
.0d16	a0 00		ldy #$00			ldy 	#0
.0d18	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d1b					CopyTOSToOffsetY:
.0d1b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0d1d	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d1f	c8		iny				iny
.0d20	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0d22	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d24	c8		iny				iny
.0d25	b5 56		lda $56,x			lda 	NSMantissa2,x
.0d27	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d29	c8		iny				iny
.0d2a	b5 62		lda $62,x			lda 	NSMantissa3,x
.0d2c	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d2e	c8		iny				iny
.0d2f	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d31	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d33	c8		iny				iny
.0d34	b5 32		lda $32,x			lda 	NSStatus,x
.0d36	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d38	60		rts				rts
.0d39					StackOpenFrame:
.0d39	48		pha				pha 								; save frame marker
.0d3a	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d3c	85 2c		sta $2c				sta 	zTemp0
.0d3e	38		sec				sec 								; subtract from runtime stack pointer.
.0d3f	a5 24		lda $24				lda		runtimeStackPtr
.0d41	e5 2c		sbc $2c				sbc 	zTemp0
.0d43	85 24		sta $24				sta 	runtimeStackPtr
.0d45	a5 25		lda $25				lda		runtimeStackPtr+1
.0d47	e9 00		sbc #$00			sbc 	#0
.0d49	85 25		sta $25				sta 	runtimeStackPtr+1
.0d4b	68		pla				pla 								; put frame marker at +0
.0d4c	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d4e	60		rts				rts
.0d4f					StackCloseFrame:
.0d4f	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d51	29 1f		and #$1f			and 	#$1F 						; size
.0d53	18		clc				clc
.0d54	65 24		adc $24				adc 	runtimeStackPtr
.0d56	85 24		sta $24				sta 	runtimeStackPtr
.0d58	90 02		bcc $0d5c			bcc 	_SCFNoCarry
.0d5a	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d5c					_SCFNoCarry:
.0d5c	60		rts				rts
.0d5d					StackFindFrame:
.0d5d	8d 0b 04	sta $040b			sta 	requiredFrame
.0d60					_SFFLoop:
.0d60	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d62	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d64	f0 10		beq $0d76			beq 	SCFFail
.0d66	cd 0b 04	cmp $040b			cmp 	requiredFrame 				; found this type ?
.0d69	f0 05		beq $0d70			beq 	_SFFFound
.0d6b	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close the top frame
.0d6e	80 f0		bra $0d60			bra 	_SFFLoop 					; and try te next.
.0d70					_SFFFound:
.0d70	60		rts				rts
.0d71					StackCheckFrame:
.0d71	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d73	d0 01		bne $0d76			bne 	SCFFail
.0d75	60		rts				rts
.0d76					SCFFail:
.0d76	4c d1 1f	jmp $1fd1		jmp	ErrorV_structure
.040b					requiredFrame:
>040b							.fill 	1
.0d79					UnaryFre:
.0d79	fa		plx				plx
.0d7a	20 ab 26	jsr $26ab			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d7d	38		sec				sec
.0d7e	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d81	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d84	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d86	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d89	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d8c	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d8e	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d91					CommandXGet:
.0d91	fa		plx				plx
.0d92	e8		inx				inx
.0d93	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d95	20 52 17	jsr $1752			jsr 	StringAllocTemp
.0d98	20 a2 13	jsr $13a2			jsr 	VectorGetCharacter 			; get a character
.0d9b	c9 00		cmp #$00			cmp 	#0
.0d9d	f0 09		beq $0da8			beq 	_CGNone
.0d9f	5a		phy				phy
.0da0	a0 01		ldy #$01			ldy 	#1 							; store char
.0da2	91 22		sta ($22),y			sta 	(zsTemp),y
.0da4	98		tya				tya 								; store length.
.0da5	92 22		sta ($22)			sta 	(zsTemp)
.0da7	7a		ply				ply
.0da8					_CGNone:
.0da8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dab					CommandXGosub:
.0dab	fa		plx				plx
.0dac	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dae	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0db1	20 7e 11	jsr $117e			jsr 	StackSaveCurrentPosition
.0db4	4c c9 0d	jmp $0dc9			jmp 	PerformGOTO
.0db7					CommandReturn:
.0db7	fa		plx				plx
.0db8	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dba	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.0dbd	20 8f 11	jsr $118f			jsr 	StackLoadCurrentPosition
.0dc0	c8		iny				iny
.0dc1	c8		iny				iny
.0dc2	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame
.0dc5	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dc8					CommandXGoto:
.0dc8	fa		plx				plx
.0dc9					PerformGOTO:
.0dc9	c8		iny				iny 								; push MSB of offset on stack
.0dca	b1 28		lda ($28),y			lda 	(codePtr),y
.0dcc	48		pha				pha
.0dcd	88		dey				dey 								; point LSB of offset
.0dce	18		clc				clc 								; add LSB
.0dcf	b1 28		lda ($28),y			lda 	(codePtr),y
.0dd1	65 28		adc $28				adc 	codePtr
.0dd3	85 28		sta $28				sta 	codePtr
.0dd5	68		pla				pla 								; restore offset MSB and add
.0dd6	65 29		adc $29				adc 	codePtr+1
.0dd8	85 29		sta $29				sta 	codePtr+1
.0dda	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ddd					CommandGotoZ:
.0ddd	fa		plx				plx
.0dde	20 cd 26	jsr $26cd			jsr 	FloatIsZero
.0de1	ca		dex				dex
.0de2	c9 00		cmp #$00			cmp 	#0
.0de4	f0 e3		beq $0dc9			beq 	PerformGOTO
.0de6	c8		iny				iny
.0de7	c8		iny				iny
.0de8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0deb					CommandGotoNZ:
.0deb	fa		plx				plx
.0dec	20 cd 26	jsr $26cd			jsr 	FloatIsZero
.0def	ca		dex				dex
.0df0	c9 00		cmp #$00			cmp 	#0
.0df2	d0 d5		bne $0dc9			bne 	PerformGOTO
.0df4	c8		iny				iny
.0df5	c8		iny				iny
.0df6	4c 4f 08	jmp $084f			jmp 	NextCommand
.0df9					Command_PSET:
.0df9	fa		plx				plx
.0dfa	5a		phy				phy
.0dfb	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; get the colour
.0dfe	48		pha				pha
.0dff	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e01	a0 02		ldy #$02			ldy 	#X16_r0
.0e03	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e06	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0e09	68		pla				pla 								; set pixel.
.0e0a	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0e0d	7a		ply				ply
.0e0e	a2 ff		ldx #$ff			ldx 	#$FF
.0e10	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e13					Command_LINE:
.0e13	fa		plx				plx
.0e14	5a		phy				phy
.0e15	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e18	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0e1a	a0 02		ldy #$02			ldy 	#X16_r0
.0e1c	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0e1f	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0e22	7a		ply				ply
.0e23	a2 ff		ldx #$ff			ldx 	#$FF
.0e25	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e28					Command_RECT:
.0e28	fa		plx				plx
.0e29	5a		phy				phy
.0e2a	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e2d	38		sec				sec
.0e2e	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e31	7a		ply				ply
.0e32	a2 ff		ldx #$ff			ldx 	#$FF
.0e34	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e37					Command_FRAME:
.0e37	fa		plx				plx
.0e38	5a		phy				phy
.0e39	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e3c	18		clc				clc
.0e3d	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e40	7a		ply				ply
.0e41	a2 ff		ldx #$ff			ldx 	#$FF
.0e43	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e46					Command_CHAR:
.0e46	fa		plx				plx
.0e47	5a		phy				phy
.0e48	ca		dex				dex  								; set the draw colour
.0e49	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e4c	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e4e	a0 02		ldy #$02			ldy 	#X16_r0
.0e50	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e53	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e55	85 2c		sta $2c				sta 	zTemp0
.0e57	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e59	85 2d		sta $2d				sta 	zTemp0+1
.0e5b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e5d	85 2e		sta $2e				sta 	zTemp1
.0e5f					_CCLoop:
.0e5f	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e61	f0 0f		beq $0e72			beq 	_CCExit
.0e63	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e65	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e67	d0 02		bne $0e6b			bne 	_CCNoCarry
.0e69	e6 2d		inc $2d				inc 	zTemp0+1
.0e6b					_CCNoCarry:
.0e6b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e6d	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e70	80 ed		bra $0e5f			bra 	_CCLoop						; go round.
.0e72					_CCExit:
.0e72	7a		ply				ply
.0e73	a2 ff		ldx #$ff			ldx 	#$FF
.0e75	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e78					GraphicsColour:
.0e78	20 47 10	jsr $1047			jsr 	GetInteger8Bit
.0e7b	aa		tax				tax
.0e7c	a0 00		ldy #$00			ldy 	#0
.0e7e	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e81	60		rts				rts
.0e82					GraphicsCopy4:
.0e82	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e85					GraphicsCopy2:
.0e85	20 88 0e	jsr $0e88			jsr 	GraphicsCopy1
.0e88					GraphicsCopy1:
.0e88	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.0e8b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e8d	99 00 00	sta $0000,y			sta 	0,y
.0e90	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e92	99 01 00	sta $0001,y			sta 	1,y
.0e95	e8		inx				inx
.0e96	c8		iny				iny
.0e97	c8		iny				iny
.0e98	60		rts				rts
.0e99					GraphicsRectCoords:
.0e99	20 78 0e	jsr $0e78			jsr 	GraphicsColour 				; set colour
.0e9c	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e9e	a0 02		ldy #$02			ldy 	#X16_r0
.0ea0	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0ea3	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0ea5	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ea8	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0eaa	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ead	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0eaf	74 09		stz $09,x			stz 	9,x
.0eb1	60		rts				rts
.0eb2					_GRCSortSubtract:
.0eb2	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0eb4	d5 00		cmp $00,x			cmp 	0,x
.0eb6	b5 05		lda $05,x			lda 	5,x
.0eb8	f5 01		sbc $01,x			sbc 	1,x
.0eba	b0 08		bcs $0ec4			bcs 	_GRCNoSwap 					; >= swap.
.0ebc	20 d8 0e	jsr $0ed8			jsr 	_GRCSwapByte 				; swap 0/2
.0ebf	e8		inx				inx
.0ec0	20 d8 0e	jsr $0ed8			jsr 	_GRCSwapByte 				; swap 1/3
.0ec3	ca		dex				dex
.0ec4					_GRCNoSwap:
.0ec4	38		sec				sec 								; calculate width/height into 4,5
.0ec5	b5 04		lda $04,x			lda 	4,x
.0ec7	f5 00		sbc $00,x			sbc 	0,x
.0ec9	95 04		sta $04,x			sta 	4,x
.0ecb	b5 05		lda $05,x			lda 	5,x
.0ecd	f5 01		sbc $01,x			sbc 	1,x
.0ecf	95 05		sta $05,x			sta 	5,x
.0ed1	f6 04		inc $04,x			inc 	4,x 						; size does not include limits.
.0ed3	d0 02		bne $0ed7			bne 	_GRCNoCarry
.0ed5	f6 05		inc $05,x			inc 	5,x
.0ed7					_GRCNoCarry:
.0ed7	60		rts				rts
.0ed8					_GRCSwapByte:
.0ed8	b5 04		lda $04,x			lda 	4,x
.0eda	48		pha				pha
.0edb	b5 00		lda $00,x			lda 	0,x
.0edd	95 04		sta $04,x			sta 	4,x
.0edf	68		pla				pla
.0ee0	95 00		sta $00,x			sta 	0,x
.0ee2	60		rts				rts
.0ee3					Unary16Hex:
.0ee3	fa		plx				plx
.0ee4	20 4d 10	jsr $104d			jsr 	GetInteger16Bit
.0ee7	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0ee9	20 52 17	jsr $1752			jsr 	StringAllocTemp
.0eec	a5 2d		lda $2d				lda 	zTemp0+1
.0eee	f0 03		beq $0ef3			beq 	_UHNoHigh
.0ef0	20 fb 0e	jsr $0efb			jsr 	_UHWriteHex
.0ef3					_UHNoHigh:
.0ef3	a5 2c		lda $2c				lda 	zTemp0
.0ef5	20 fb 0e	jsr $0efb			jsr 	_UHWriteHex
.0ef8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0efb					_UHWriteHex:
.0efb	48		pha				pha
.0efc	4a		lsr a				lsr 	a
.0efd	4a		lsr a				lsr 	a
.0efe	4a		lsr a				lsr 	a
.0eff	4a		lsr a				lsr 	a
.0f00	20 04 0f	jsr $0f04			jsr 	_UHWriteNibl
.0f03	68		pla				pla
.0f04					_UHWriteNibl:
.0f04	29 0f		and #$0f			and 	#15
.0f06	c9 0a		cmp #$0a			cmp 	#10
.0f08	90 02		bcc $0f0c			bcc 	_UHDigit
.0f0a	69 06		adc #$06			adc 	#6
.0f0c					_UHDigit:
.0f0c	69 30		adc #$30			adc 	#48
.0f0e	20 7b 17	jsr $177b			jsr 	StringWriteChar
.0f11	60		rts				rts
.0f12					IndFloatRead:
.0f12	fa		plx				plx
.0f13	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f15	85 2c		sta $2c				sta 	zTemp0
.0f17	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f19	18		clc				clc
.0f1a	6d 07 04	adc $0407			adc 	variableStartPage
.0f1d	85 2d		sta $2d				sta 	zTemp0+1
.0f1f	ca		dex				dex 								; throw the address
.0f20	20 1b 15	jsr $151b			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0f23	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f26					IndInt16Read:
.0f26	fa		plx				plx
.0f27	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f29	85 2c		sta $2c				sta 	zTemp0
.0f2b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f2d	18		clc				clc
.0f2e	6d 07 04	adc $0407			adc 	variableStartPage
.0f31	85 2d		sta $2d				sta 	zTemp0+1
.0f33	ca		dex				dex 								; throw the address
.0f34	20 57 15	jsr $1557			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f37	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f3a					IndStringRead:
.0f3a	fa		plx				plx
.0f3b	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f3d	85 2c		sta $2c				sta 	zTemp0
.0f3f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f41	18		clc				clc
.0f42	6d 07 04	adc $0407			adc 	variableStartPage
.0f45	85 2d		sta $2d				sta 	zTemp0+1
.0f47	ca		dex				dex 								; throw the address
.0f48	20 9c 15	jsr $159c			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f4b	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f4e					IndFloatWrite:
.0f4e	fa		plx				plx
.0f4f	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f51	85 2c		sta $2c				sta 	zTemp0
.0f53	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f55	18		clc				clc
.0f56	6d 07 04	adc $0407			adc 	variableStartPage
.0f59	85 2d		sta $2d				sta 	zTemp0+1
.0f5b	20 10 1b	jsr $1b10			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f5e	ca		dex				dex 								; throw the address as well.
.0f5f	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f62					IndInt16Write:
.0f62	fa		plx				plx
.0f63	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f65	85 2c		sta $2c				sta 	zTemp0
.0f67	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f69	18		clc				clc
.0f6a	6d 07 04	adc $0407			adc 	variableStartPage
.0f6d	85 2d		sta $2d				sta 	zTemp0+1
.0f6f	20 4c 1b	jsr $1b4c			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f72	ca		dex				dex 								; throw the address as well.
.0f73	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f76					IndStringWrite:
.0f76	fa		plx				plx
.0f77	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f79	85 2c		sta $2c				sta 	zTemp0
.0f7b	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f7d	18		clc				clc
.0f7e	6d 07 04	adc $0407			adc 	variableStartPage
.0f81	85 2d		sta $2d				sta 	zTemp0+1
.0f83	20 8b 1b	jsr $1b8b			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f86	ca		dex				dex 								; throw the address as well.
.0f87	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f8a					CommandXInput:
.0f8a	fa		plx				plx
.0f8b	5a		phy				phy 								; save Y
.0f8c	e8		inx				inx									; space on stack
.0f8d					_INError:
.0f8d	20 c1 0f	jsr $0fc1			jsr 	InputStringToBuffer 		; input from keyboard
.0f90	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.0f92	85 2c		sta $2c				sta 	0+zTemp0
.0f94	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f96	85 2d		sta $2d				sta 	1+zTemp0
.0f98	20 99 19	jsr $1999			jsr 	ValEvaluateZTemp0
.0f9b	b0 f0		bcs $0f8d			bcs 	_INError 					; failed, try again.
.0f9d	7a		ply				ply 								; restore Y
.0f9e	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fa1					CommandInputString:
.0fa1	fa		plx				plx
.0fa2	5a		phy				phy 								; save Y
.0fa3	20 c1 0f	jsr $0fc1			jsr 	InputStringToBuffer 		; input from keyboard
.0fa6	e8		inx				inx 								; make space on stack
.0fa7	20 ab 26	jsr $26ab			jsr 	FloatSetZero 				; store as string on stack
.0faa	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.0fac	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0fae	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0fb0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0fb2	a9 40		lda #$40			lda 	#NSSString
.0fb4	95 32		sta $32,x			sta 	NSStatus,x
.0fb6	7a		ply				ply 								; restore Y
.0fb7	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fba					CommandInputReset:
.0fba	fa		plx				plx
.0fbb	9c 0c 04	stz $040c			stz 	InputBuffer
.0fbe	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fc1					InputStringToBuffer:
.0fc1	a9 fb		lda #$fb			lda 	#((InputBumpNext) & $FF)
.0fc3	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.0fc6	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0fc8	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.0fcb	a9 d8		lda #$d8			lda 	#((InputLookNext) & $FF)
.0fcd	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.0fd0	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0fd2	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.0fd5	4c 78 14	jmp $1478			jmp 	GetStringToBuffer
.0fd8					InputLookNext:
.0fd8	da		phx				phx
.0fd9					_ILNRetry:
.0fd9	ad 0c 04	lda $040c			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fdc	d0 08		bne $0fe6			bne 	_ILNNotEmpty
.0fde	20 ff 0f	jsr $0fff			jsr 	InputGetNewLine 			; get a new line
.0fe1	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset read position.
.0fe4	80 f3		bra $0fd9			bra 	_ILNRetry
.0fe6					_ILNNotEmpty:
.0fe6	ae 5d 04	ldx $045d			ldx 	InputBufferPos 				; get head available character
.0fe9	bd 0c 04	lda $040c,x			lda 	InputBuffer,x
.0fec	d0 08		bne $0ff6			bne 	_ILNExit 					; if not EOS return it with CC.
.0fee					_ILNNextLine:
.0fee	9c 0c 04	stz $040c			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0ff1	38		sec				sec 								; return CS,Zero
.0ff2	fa		plx				plx
.0ff3	a9 0d		lda #$0d			lda 	#13
.0ff5	60		rts				rts
.0ff6					_ILNExit:
.0ff6	fa		plx				plx
.0ff7	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0ff9	18		clc				clc
.0ffa	60		rts				rts
.0ffb					InputBumpNext:
.0ffb	ee 5d 04	inc $045d			inc 	InputBufferPos
.0ffe	60		rts				rts
.0fff					InputGetNewLine:
.0fff	48		pha				pha
.1000	da		phx				phx
.1001	5a		phy				phy
.1002	a9 3f		lda #$3f			lda 	#"?"
.1004	20 3e 10	jsr $103e			jsr 	IGNLEchoIfScreen
.1007	a0 00		ldy #$00			ldy 	#0 							; line position.
.1009					_IGNLLoop:
.1009	20 a2 13	jsr $13a2			jsr 	VectorGetCharacter 			; get a character
.100c	c9 00		cmp #$00			cmp 	#0
.100e	f0 f9		beq $1009			beq 	_IGNLLoop
.1010	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.1012	f0 11		beq $1025			beq 	_IGNBackspace
.1014	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.1016	f0 17		beq $102f			beq 	_IGNExit
.1018	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.101a	f0 ed		beq $1009			beq 	_IGNLLoop
.101c	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.101f	c8		iny				iny
.1020	20 3e 10	jsr $103e			jsr 	IGNLEchoIfScreen
.1023	80 e4		bra $1009			bra 	_IGNLLoop
.1025					_IGNBackspace:
.1025	c0 00		cpy #$00			cpy 	#0
.1027	f0 e0		beq $1009			beq 	_IGNLLoop
.1029	20 3e 10	jsr $103e			jsr 	IGNLEchoIfScreen
.102c	88		dey				dey
.102d	80 da		bra $1009			bra 	_IGNLLoop
.102f					_IGNExit:
.102f	20 3e 10	jsr $103e			jsr 	IGNLEchoIfScreen
.1032	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.1034	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1037	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset position to start of input buffer.
.103a	7a		ply				ply
.103b	fa		plx				plx
.103c	68		pla				pla
.103d	60		rts				rts
.103e					IGNLEchoIfScreen:
.103e	ae 5f 04	ldx $045f			ldx 	currentChannel
.1041	d0 03		bne $1046			bne 	_IGNLEExit
.1043	20 99 13	jsr $1399			jsr 	VectorPrintCharacter
.1046					_IGNLEExit:
.1046	60		rts				rts
.040c					InputBuffer:
>040c							.fill 	81
.045d					InputBufferPos:
>045d							.fill 	1
.1047					GetInteger8Bit:
.1047	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.104a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.104c	60		rts				rts
.104d					GetInteger16Bit:
.104d	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.1050	34 32		bit $32,x			bit 	NSStatus,x
.1052	30 09		bmi $105d			bmi 	Negate16Bit
.1054	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1056	85 2c		sta $2c				sta 	zTemp0
.1058	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.105a	85 2d		sta $2d				sta 	zTemp0+1
.105c	60		rts				rts
.105d					Negate16Bit:
.105d	38		sec				sec
.105e	a9 00		lda #$00			lda 	#0
.1060	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1062	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1064	85 2c		sta $2c				sta 	zTemp0
.1066	a9 00		lda #$00			lda 	#0
.1068	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.106a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.106c	85 2d		sta $2d				sta 	zTemp0+1
.106e	60		rts				rts
.106f					UnaryJoy:
.106f	fa		plx				plx
.1070	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; port #
.1073	48		pha				pha 								; zero the result.
.1074	20 ab 26	jsr $26ab			jsr 	FloatSetZero
.1077	68		pla				pla
.1078	5a		phy				phy
.1079	da		phx				phx
.107a	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.107d	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.107f	d0 10		bne $1091			bne 	_UJNoHardware
.1081	a8		tay				tay 								; move XA -> AY
.1082	8a		txa				txa
.1083	fa		plx				plx 								; we can update it now.
.1084	49 ff		eor #$ff			eor 	#$FF
.1086	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1088	98		tya				tya
.1089	49 ff		eor #$ff			eor 	#$FF
.108b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.108d	7a		ply				ply 								; restore Y
.108e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1091					_UJNoHardware:
.1091	fa		plx				plx
.1092	7a		ply				ply
.1093	a9 01		lda #$01			lda 	#1 							; set result to -1
.1095	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.1098	20 6d 26	jsr $266d			jsr 	FloatNegate
.109b	4c 4f 08	jmp $084f			jmp 	NextCommand
.109e					UnaryLen:
.109e	fa		plx				plx
.109f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.10a1	85 2c		sta $2c				sta 	zTemp0
.10a3	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.10a5	85 2d		sta $2d				sta 	zTemp0+1
.10a7	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.10a9	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.10ac	4c 4f 08	jmp $084f			jmp 	NextCommand
.10af					LinkFloatAdd:
.10af	fa		plx				plx
.10b0	5a		phy			phy
.10b1	20 cf 20	jsr $20cf		jsr	FloatAdd
.10b4	7a		ply			ply
.10b5	4c 4f 08	jmp $084f			jmp 	NextCommand
.10b8					LinkFloatSubtract:
.10b8	fa		plx				plx
.10b9	5a		phy			phy
.10ba	20 c9 20	jsr $20c9		jsr	FloatSubtract
.10bd	7a		ply			ply
.10be	4c 4f 08	jmp $084f			jmp 	NextCommand
.10c1					LinkFloatMultiply:
.10c1	fa		plx				plx
.10c2	5a		phy			phy
.10c3	20 6b 23	jsr $236b		jsr	FloatMultiply
.10c6	7a		ply			ply
.10c7	4c 4f 08	jmp $084f			jmp 	NextCommand
.10ca					LinkFloatDivide:
.10ca	fa		plx				plx
.10cb	5a		phy			phy
.10cc	20 f4 21	jsr $21f4		jsr	FloatDivide
.10cf	b0 5c		bcs $112d		bcs	DivZeroError
.10d1	7a		ply			ply
.10d2	4c 4f 08	jmp $084f			jmp 	NextCommand
.10d5					LinkFloatPower:
.10d5	fa		plx				plx
.10d6	5a		phy			phy
.10d7	20 74 29	jsr $2974		jsr	FloatPower
.10da	b0 4e		bcs $112a		bcs	MapRangeError
.10dc	7a		ply			ply
.10dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.10e0					LinkCompareGreater:
.10e0	fa		plx				plx
.10e1	5a		phy			phy
.10e2	20 78 21	jsr $2178		jsr	CompareGreater
.10e5	7a		ply			ply
.10e6	4c 4f 08	jmp $084f			jmp 	NextCommand
.10e9					LinkCompareEqual:
.10e9	fa		plx				plx
.10ea	5a		phy			phy
.10eb	20 5a 21	jsr $215a		jsr	CompareEqual
.10ee	7a		ply			ply
.10ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.10f2					LinkCompareLess:
.10f2	fa		plx				plx
.10f3	5a		phy			phy
.10f4	20 70 21	jsr $2170		jsr	CompareLess
.10f7	7a		ply			ply
.10f8	4c 4f 08	jmp $084f			jmp 	NextCommand
.10fb					LinkCompareGreaterEqual:
.10fb	fa		plx				plx
.10fc	5a		phy			phy
.10fd	20 88 21	jsr $2188		jsr	CompareGreaterEqual
.1100	7a		ply			ply
.1101	4c 4f 08	jmp $084f			jmp 	NextCommand
.1104					LinkCompareNotEqual:
.1104	fa		plx				plx
.1105	5a		phy			phy
.1106	20 6a 21	jsr $216a		jsr	CompareNotEqual
.1109	7a		ply			ply
.110a	4c 4f 08	jmp $084f			jmp 	NextCommand
.110d					LinkCompareLessEqual:
.110d	fa		plx				plx
.110e	5a		phy			phy
.110f	20 80 21	jsr $2180		jsr	CompareLessEqual
.1112	7a		ply			ply
.1113	4c 4f 08	jmp $084f			jmp 	NextCommand
.1116					LinkFloatIntegerPartDown:
.1116	fa		plx				plx
.1117	5a		phy			phy
.1118	20 0a 23	jsr $230a		jsr	FloatIntegerPartDown
.111b	7a		ply			ply
.111c	4c 4f 08	jmp $084f			jmp 	NextCommand
.111f					LinkFloatSquareRoot:
.111f	fa		plx				plx
.1120	5a		phy			phy
.1121	20 f6 29	jsr $29f6		jsr	FloatSquareRoot
.1124	b0 04		bcs $112a		bcs	MapRangeError
.1126	7a		ply			ply
.1127	4c 4f 08	jmp $084f			jmp 	NextCommand
.112a					MapRangeError:
.112a	4c 36 1f	jmp $1f36		jmp	ErrorV_range
.112d					DivZeroError:
.112d	4c bf 1f	jmp $1fbf		jmp	ErrorV_divzero
.1130					LinkFloatLogarithm:
.1130	fa		plx				plx
.1131	5a		phy			phy
.1132	20 00 29	jsr $2900		jsr	FloatLogarithm
.1135	b0 f3		bcs $112a		bcs	MapRangeError
.1137	7a		ply			ply
.1138	4c 4f 08	jmp $084f			jmp 	NextCommand
.113b					LinkFloatExponent:
.113b	fa		plx				plx
.113c	5a		phy			phy
.113d	20 fd 27	jsr $27fd		jsr	FloatExponent
.1140	7a		ply			ply
.1141	4c 4f 08	jmp $084f			jmp 	NextCommand
.1144					LinkFloatCosine:
.1144	fa		plx				plx
.1145	5a		phy			phy
.1146	20 f1 27	jsr $27f1		jsr	FloatCosine
.1149	7a		ply			ply
.114a	4c 4f 08	jmp $084f			jmp 	NextCommand
.114d					LinkFloatSine:
.114d	fa		plx				plx
.114e	5a		phy			phy
.114f	20 91 29	jsr $2991		jsr	FloatSine
.1152	7a		ply			ply
.1153	4c 4f 08	jmp $084f			jmp 	NextCommand
.1156					LinkFloatTangent:
.1156	fa		plx				plx
.1157	5a		phy			phy
.1158	20 02 2a	jsr $2a02		jsr	FloatTangent
.115b	7a		ply			ply
.115c	4c 4f 08	jmp $084f			jmp 	NextCommand
.115f					LinkFloatArcTan:
.115f	fa		plx				plx
.1160	5a		phy			phy
.1161	20 d6 26	jsr $26d6		jsr	FloatArcTan
.1164	b0 c4		bcs $112a		bcs	MapRangeError
.1166	7a		ply			ply
.1167	4c 4f 08	jmp $084f			jmp 	NextCommand
.116a					LinkFloatCompare:
.116a	fa		plx				plx
.116b	5a		phy			phy
.116c	20 90 21	jsr $2190		jsr	FloatCompare
.116f	7a		ply			ply
.1170	4c 4f 08	jmp $084f			jmp 	NextCommand
.1173					LinkDivideInt32:
.1173	fa		plx				plx
.1174	5a		phy			phy
.1175	20 1e 22	jsr $221e		jsr	DivideInt32
.1178	b0 b0		bcs $112a		bcs	MapRangeError
.117a	7a		ply			ply
.117b	4c 4f 08	jmp $084f			jmp 	NextCommand
.117e					StackSaveCurrentPosition:
.117e	20 cb 08	jsr $08cb			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.1181	5a		phy				phy
.1182	a0 02		ldy #$02			ldy 	#2
.1184	a5 28		lda $28				lda 	codePtr
.1186	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1188	c8		iny				iny
.1189	a5 29		lda $29				lda 	codePtr+1
.118b	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.118d	7a		ply				ply
.118e	60		rts				rts
.118f					StackLoadCurrentPosition:
.118f	a0 02		ldy #$02			ldy 	#2
.1191	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1193	85 28		sta $28				sta 	codePtr
.1195	c8		iny				iny
.1196	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1198	85 29		sta $29				sta 	codePtr+1
.119a	a0 00		ldy #$00			ldy 	#0
.119c	60		rts				rts
.119d					XCommandMouse:
.119d	fa		plx				plx
.119e	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; mouse control.
.11a1	ca		dex				dex
.11a2	da		phx				phx
.11a3	5a		phy				phy
.11a4	48		pha				pha
.11a5	38		sec				sec 								; get screen resolution
.11a6	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.11a9	68		pla				pla
.11aa	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.11ad	7a		ply				ply
.11ae	fa		plx				plx
.11af	4c 4f 08	jmp $084f			jmp 	NextCommand
.11b2					XUnaryMB:
.11b2	fa		plx				plx
.11b3	20 fa 11	jsr $11fa			jsr 	XUnaryMouseCommon
.11b6	a5 30		lda $30				lda 	zTemp2
.11b8	e8		inx				inx
.11b9	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.11bc	4c 4f 08	jmp $084f			jmp 	NextCommand
.11bf					XUnaryMX:
.11bf	fa		plx				plx
.11c0	20 fa 11	jsr $11fa			jsr 	XUnaryMouseCommon
.11c3	a5 2c		lda $2c				lda 	zTemp0
.11c5	e8		inx				inx
.11c6	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.11c9	a5 2d		lda $2d				lda 	zTemp0+1
.11cb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11cd	4c 4f 08	jmp $084f			jmp 	NextCommand
.11d0					XUnaryMY:
.11d0	fa		plx				plx
.11d1	20 fa 11	jsr $11fa			jsr 	XUnaryMouseCommon
.11d4	a5 2e		lda $2e				lda 	zTemp1
.11d6	e8		inx				inx
.11d7	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.11da	a5 2f		lda $2f				lda 	zTemp1+1
.11dc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11de	4c 4f 08	jmp $084f			jmp 	NextCommand
.11e1					XUnaryMWheel:
.11e1	fa		plx				plx
.11e2	20 fa 11	jsr $11fa			jsr 	XUnaryMouseCommon 			; read mouse status
.11e5	e8		inx				inx
.11e6	a5 31		lda $31				lda 	zTemp2+1 					; set mantissa to |wheel|
.11e8	48		pha				pha
.11e9	10 03		bpl $11ee			bpl 	_XUMNotNegative
.11eb	49 ff		eor #$ff			eor 	#$FF
.11ed	1a		inc a				inc 	a
.11ee					_XUMNotNegative:
.11ee	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.11f1	68		pla				pla  								; negate if it was -ve
.11f2	10 03		bpl $11f7			bpl 	_XUMNotNegative2
.11f4	20 6d 26	jsr $266d			jsr 	FloatNegate
.11f7					_XUMNotNegative2:
.11f7	4c 4f 08	jmp $084f			jmp 	NextCommand
.11fa					XUnaryMouseCommon:
.11fa	da		phx				phx
.11fb	5a		phy				phy
.11fc	a2 2c		ldx #$2c			ldx 	#zTemp0
.11fe	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.1201	85 30		sta $30				sta 	zTemp2
.1203	86 31		stx $31				stx 	zTemp2+1
.1205	7a		ply				ply
.1206	fa		plx				plx
.1207	60		rts				rts
.1208					NegateTOS:
.1208	fa		plx				plx
.1209	20 6d 26	jsr $266d			jsr 	FloatNegate
.120c	4c 4f 08	jmp $084f			jmp 	NextCommand
.120f					CommandNewLine:
.120f	fa		plx				plx
.1210	9c 6a 05	stz $056a			stz 	stringInitialised
.1213	a2 ff		ldx #$ff			ldx 	#$FF
.1215	4c 4f 08	jmp $084f			jmp 	NextCommand
.1218					CommandXNext:
.1218	fa		plx				plx
.1219					_CNRetry:
.1219	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.121b	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.121e	20 cb 08	jsr $08cb			jsr 	FixUpY 						; so we can use Y
.1221	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.1223	35 4a		and $4a,x			and 	NSMantissa1,x
.1225	c9 ff		cmp #$ff			cmp 	#$FF
.1227	f0 16		beq $123f			beq 	_CNNoIndexVariable
.1229	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.122b	a0 05		ldy #$05			ldy 	#5
.122d	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.122f	d0 07		bne $1238			bne 	_CNNIndexFail
.1231	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1233	c8		iny				iny
.1234	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.1236	f0 07		beq $123f			beq 	_CNNoIndexVariable
.1238					_CNNIndexFail:
.1238	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.123a	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close this frame
.123d	80 da		bra $1219			bra 	_CNRetry
.123f					_CNNoIndexVariable:
.123f	ca		dex				dex
.1240	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.1242	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1244	29 40		and #$40			and 	#$40	 					; bit 6
.1246	d0 55		bne $129d			bne 	_CNOptimisedNext
.1248	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.124a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.124c	48		pha				pha
.124d	85 2c		sta $2c				sta 	zTemp0
.124f	c8		iny				iny
.1250	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1252	18		clc				clc
.1253	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1256	48		pha				pha
.1257	85 2d		sta $2d				sta 	zTemp0+1
.1259	20 1b 15	jsr $151b			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.125c	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.125e	e8		inx				inx
.125f	20 e0 12	jsr $12e0			jsr 	CopyOffsetYToTOS
.1262	20 cf 20	jsr $20cf			jsr 	FloatAdd
.1265	68		pla				pla 								; restore address
.1266	85 2d		sta $2d				sta 	zTemp0+1
.1268	68		pla				pla
.1269	85 2c		sta $2c				sta 	zTemp0
.126b	20 10 1b	jsr $1b10			jsr 	WriteFloatZTemp0Sub			; write float.
.126e	e8		inx				inx  								; recover written
.126f	e8		inx				inx 								; load offset
.1270	a0 0d		ldy #$0d			ldy 	#13
.1272	20 e0 12	jsr $12e0			jsr 	CopyOffsetYToTOS
.1275	20 90 21	jsr $2190			jsr 	FloatCompare 				; and compare the floats.
.1278	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1279	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.127b	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.127d	30 08		bmi $1287			bmi 	_CNDownStep
.127f	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1281	c9 01		cmp #$01			cmp 	#1 							; gone higher
.1283	f0 10		beq $1295			beq 	_CNExitFor 					; if so exit the loop
.1285	80 06		bra $128d			bra 	_CNLoopBack
.1287					_CNDownStep:
.1287	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1289	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.128b	f0 08		beq $1295			beq 	_CNExitFor
.128d					_CNLoopBack:
.128d	20 8f 11	jsr $118f			jsr 	StackLoadCurrentPosition 	; loop back
.1290	a0 00		ldy #$00			ldy 	#0
.1292	4c 4f 08	jmp $084f			jmp 	NextCommand
.1295					_CNExitFor:
.1295	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; remove the frame and exit
.1298	a0 00		ldy #$00			ldy 	#0
.129a	4c 4f 08	jmp $084f			jmp 	NextCommand
.129d					_CNOptimisedNext:
.129d	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.129f	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12a1	85 2c		sta $2c				sta 	zTemp0
.12a3	c8		iny				iny
.12a4	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12a6	18		clc				clc
.12a7	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.12aa	85 2d		sta $2d				sta 	zTemp0+1
.12ac	a0 07		ldy #$07			ldy 	#7 							; STEP value
.12ae	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12b0	a0 ff		ldy #$ff			ldy 	#$FF
.12b2	18		clc				clc
.12b3					_CNOIncrement:
.12b3	c8		iny				iny
.12b4	71 2c		adc ($2c),y			adc 	(zTemp0),y
.12b6	91 2c		sta ($2c),y			sta 	(zTemp0),y
.12b8	f0 f9		beq $12b3			beq 	_CNOIncrement
.12ba	18		clc				clc
.12bb	a5 24		lda $24				lda 	runtimeStackPtr
.12bd	69 0d		adc #$0d			adc 	#13
.12bf	85 2e		sta $2e				sta 	zTemp1
.12c1	a5 25		lda $25				lda 	runtimeStackPtr+1
.12c3	69 00		adc #$00			adc 	#0
.12c5	85 2f		sta $2f				sta 	zTemp1+1
.12c7	a0 00		ldy #$00			ldy 	#0
.12c9	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.12cb	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.12cd	c8		iny				iny
.12ce	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.12d0	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12d2	c8		iny				iny
.12d3	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.12d5	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12d7	c8		iny				iny
.12d8	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.12da	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12dc	90 b7		bcc $1295			bcc	 	_CNExitFor
.12de	80 ad		bra $128d			bra 	_CNLoopBack
.12e0					CopyOffsetYToTOS:
.12e0	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12e2	95 3e		sta $3e,x			sta 	NSMantissa0,x
.12e4	c8		iny				iny
.12e5	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12e7	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12e9	c8		iny				iny
.12ea	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12ec	95 56		sta $56,x			sta 	NSMantissa2,x
.12ee	c8		iny				iny
.12ef	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12f1	95 62		sta $62,x			sta 	NSMantissa3,x
.12f3	c8		iny				iny
.12f4	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12f6	95 6e		sta $6e,x			sta 	NSExponent,x
.12f8	c8		iny				iny
.12f9	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12fb	95 32		sta $32,x			sta 	NSStatus,x
.12fd	60		rts				rts
.12fe	4c 4f 08	jmp $084f			jmp 	NextCommand
.1301					NotTOS:
.1301	fa		plx				plx
.1302	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.1305	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.1307	74 62		stz $62,x			stz 	NSMantissa3,x
.1309	20 6d 26	jsr $266d			jsr 	FloatNegate		 			; negate
.130c	e8		inx				inx 								; and subtract 1.
.130d	a9 01		lda #$01			lda 	#1
.130f	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.1312	20 c9 20	jsr $20c9			jsr 	FloatSubtract
.1315					_NotTOSSkip:
.1315	4c 4f 08	jmp $084f			jmp 	NextCommand
.1318					CommandXOn:
.1318	fa		plx				plx
.1319	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.131c	8d 5e 04	sta $045e			sta 	onCount 					; save it.
.131f	20 cb 08	jsr $08cb			jsr 	FixUpY 						; Y = 0
.1322					_CONFind:
.1322	ce 5e 04	dec $045e			dec 	onCount 					; reached zero, do this one
.1325	f0 0b		beq $1332			beq 	_CONFound
.1327	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1328	c8		iny				iny
.1329	c8		iny				iny
.132a	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.132c	c8		iny				iny
.132d	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.132f	f0 f1		beq $1322			beq 	_CONFind
.1331	88		dey				dey 								; point to character after last GOTO/GOSUB
.1332					_CONFound:
.1332	4c 4f 08	jmp $084f			jmp 	NextCommand
.1335					CommandMoreOn:
.1335	fa		plx				plx
.1336	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1337	c8		iny				iny
.1338	c8		iny				iny
.1339	4c 4f 08	jmp $084f			jmp 	NextCommand
.045e					onCount:
>045e							.fill 	1
.133c					UnaryPeek:
.133c	fa		plx				plx
.133d	20 4d 10	jsr $104d			jsr 	GetInteger16Bit
.1340	da		phx				phx
.1341	5a		phy				phy
.1342	a6 2c		ldx $2c				ldx 	zTemp0
.1344	a4 2d		ldy $2d				ldy 	zTemp0+1
.1346	20 aa 1c	jsr $1caa			jsr 	XPeekMemory
.1349	7a		ply				ply
.134a	fa		plx				plx
.134b	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.134e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1351					UnaryPI:
.1351	fa		plx				plx
.1352	a9 19		lda #$19			lda 	#Const_pi-Const_base
.1354	20 db 28	jsr $28db			jsr 	LoadConstant
.1357	e8		inx				inx
.1358	4c 4f 08	jmp $084f			jmp 	NextCommand
.135b					CommandPOKE:
.135b	fa		plx				plx
.135c	da		phx				phx 								; save XY
.135d	5a		phy				phy
.135e	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1361	48		pha				pha
.1362	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1364	a8		tay				tay
.1365	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1367	aa		tax				tax
.1368	68		pla				pla
.1369	20 96 1c	jsr $1c96			jsr 	XPokeMemory
.136c	7a		ply				ply 								; restore YX and drop 2
.136d	fa		plx				plx
.136e	ca		dex				dex
.136f	ca		dex				dex
.1370	4c 4f 08	jmp $084f			jmp 	NextCommand
.1373					UnaryPos:
.1373	fa		plx				plx
.1374	20 29 1c	jsr $1c29			jsr 	XGetHPos
.1377	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.137a	4c 4f 08	jmp $084f			jmp 	NextCommand
.137d					GetChannel:
.137d	fa		plx				plx
.137e	ad 5f 04	lda $045f			lda 	currentChannel
.1381	e8		inx				inx
.1382	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.1385	4c 4f 08	jmp $084f			jmp 	NextCommand
.1388					SetChannel:
.1388	fa		plx				plx
.1389	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.138c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.138e	8d 5f 04	sta $045f			sta 	currentChannel
.1391	ca		dex				dex
.1392	4c 4f 08	jmp $084f			jmp 	NextCommand
.1395					SetDefaultChannel:
.1395	9c 5f 04	stz $045f			stz 	currentChannel
.1398	60		rts				rts
.1399					VectorPrintCharacter:
.1399	da		phx				phx
.139a	ae 5f 04	ldx $045f			ldx 	currentChannel
.139d	20 d4 1c	jsr $1cd4			jsr 	XPrintCharacterToChannel
.13a0	fa		plx				plx
.13a1	60		rts				rts
.13a2					VectorGetCharacter:
.13a2	da		phx				phx
.13a3	ae 5f 04	ldx $045f			ldx 	currentChannel
.13a6	20 0d 1c	jsr $1c0d			jsr 	XGetCharacterFromChannel
.13a9	fa		plx				plx
.13aa	60		rts				rts
.045f					currentChannel:
>045f							.fill 	1
.13ab					PrintNumber:
.13ab	fa		plx				plx
.13ac	a9 07		lda #$07			lda 	#7
.13ae	20 93 25	jsr $2593			jsr 	FloatToString 				; to number in decimal buffer
.13b1	ca		dex				dex 								; drop
.13b2	da		phx				phx
.13b3	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.13b5					_PNLoop:
.13b5	bd 98 05	lda $0598,x			lda 	decimalBuffer,x
.13b8	20 99 13	jsr $1399			jsr 	VectorPrintCharacter
.13bb	e8		inx				inx
.13bc	bd 98 05	lda $0598,x			lda	 	decimalBuffer,x
.13bf	d0 f4		bne $13b5			bne 	_PNLoop
.13c1	a9 20		lda #$20			lda 	#32 						; trailing space
.13c3	20 99 13	jsr $1399			jsr 	VectorPrintCharacter
.13c6	fa		plx				plx
.13c7	4c 4f 08	jmp $084f			jmp 	NextCommand
.13ca					PrintString:
.13ca	fa		plx				plx
.13cb	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.13cd	85 2c		sta $2c				sta 	zTemp0
.13cf	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.13d1	85 2d		sta $2d				sta 	zTemp0+1
.13d3	ca		dex				dex 								; drop
.13d4	da		phx				phx
.13d5	5a		phy				phy
.13d6	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.13d8	aa		tax				tax
.13d9	a0 01		ldy #$01			ldy 	#1 							; Y = position
.13db					_PSLoop:
.13db	e0 00		cpx #$00			cpx 	#0 							; complete ?
.13dd	f0 09		beq $13e8			beq 	_PSExit
.13df	ca		dex				dex 								; dec count
.13e0	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.13e2	20 99 13	jsr $1399			jsr 	VectorPrintCharacter
.13e5	c8		iny				iny
.13e6	80 f3		bra $13db			bra 	_PSLoop
.13e8					_PSExit:
.13e8	7a		ply				ply
.13e9	fa		plx				plx
.13ea	4c 4f 08	jmp $084f			jmp 	NextCommand
.13ed					CommandPushN:
.13ed	fa		plx				plx
.13ee	e8		inx				inx 								; next slot on stack
.13ef	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.13f1	95 6e		sta $6e,x			sta 	NSExponent,x
.13f3	c8		iny				iny
.13f4	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.13f6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13f8	c8		iny				iny
.13f9	b1 28		lda ($28),y			lda 	(codePtr),y
.13fb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13fd	c8		iny				iny
.13fe	b1 28		lda ($28),y			lda 	(codePtr),y
.1400	95 56		sta $56,x			sta 	NSMantissa2,x
.1402	c8		iny				iny
.1403	b1 28		lda ($28),y			lda 	(codePtr),y
.1405	48		pha				pha
.1406	29 7f		and #$7f			and 	#$7F
.1408	95 62		sta $62,x			sta 	NSMantissa3,x
.140a	68		pla				pla 								; sign in mantissa3:7
.140b	29 80		and #$80			and 	#$80
.140d	95 32		sta $32,x			sta 	NSStatus,x
.140f	c8		iny				iny
.1410	4c 4f 08	jmp $084f			jmp 	NextCommand
.1413					CommandPushS:
.1413	fa		plx				plx
.1414	e8		inx				inx 								; next slot on stack
.1415	18		clc				clc
.1416	98		tya				tya
.1417	65 28		adc $28				adc 	codePtr 					; the string is inline
.1419	95 3e		sta $3e,x			sta 	NSMantissa0,x
.141b	a5 29		lda $29				lda 	codePtr+1
.141d	69 00		adc #$00			adc 	#0
.141f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1421	74 56		stz $56,x			stz 	NSMantissa2,x
.1423	74 62		stz $62,x			stz 	NSMantissa3,x
.1425	a9 40		lda #$40			lda 	#NSSString
.1427	95 32		sta $32,x			sta 	NSStatus,x
.1429	98		tya				tya 								; string length +1 added to Y
.142a	38		sec				sec
.142b	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.142d	a8		tay				tay
.142e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1431					CommandXRead:
.1431	fa		plx				plx
.1432	5a		phy				phy 								; save Y
.1433	20 64 14	jsr $1464			jsr 	ReadStringToBuffer 			; read element into buffer
.1436	e8		inx				inx									; space on stack
.1437	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.1439	85 2c		sta $2c				sta 	0+zTemp0
.143b	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.143d	85 2d		sta $2d				sta 	1+zTemp0
.143f	20 99 19	jsr $1999			jsr 	ValEvaluateZTemp0
.1442	b0 04		bcs $1448			bcs 	_CRError 					; failed
.1444	7a		ply				ply 								; restore Y
.1445	4c 4f 08	jmp $084f			jmp 	NextCommand
.1448					_CRError:
.1448	4c 46 1f	jmp $1f46		jmp	ErrorV_value
.144b					CommandReadString:
.144b	fa		plx				plx
.144c	5a		phy				phy 								; save Y
.144d	20 64 14	jsr $1464			jsr 	ReadStringToBuffer 			; read text
.1450	e8		inx				inx 								; make space on stack
.1451	20 ab 26	jsr $26ab			jsr 	FloatSetZero 				; store as string on stack
.1454	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.1456	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1458	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.145a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.145c	a9 40		lda #$40			lda 	#NSSString
.145e	95 32		sta $32,x			sta 	NSStatus,x
.1460	7a		ply				ply 								; restore Y
.1461	4c 4f 08	jmp $084f			jmp 	NextCommand
.1464					ReadStringToBuffer:
.1464	a9 f7		lda #$f7			lda 	#((ReadBumpNext) & $FF)
.1466	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.1469	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.146b	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.146e	a9 ca		lda #$ca			lda 	#((ReadLookNext) & $FF)
.1470	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.1473	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.1475	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.1478					GetStringToBuffer:
.1478	20 c7 14	jsr $14c7			jsr		GetLookNext 				; skip all leading spaces.
.147b	f0 44		beq $14c1			beq 	_RBError 					; end of data
.147d	b0 f9		bcs $1478			bcs 	GetStringToBuffer 			; switched to new data line.
.147f	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1481	b0 05		bcs $1488			bcs 	_RBNoSpace
.1483	20 c4 14	jsr $14c4			jsr 	GetBumpNext 				; consume space and loop round.
.1486	80 f0		bra $1478			bra 	GetStringToBuffer
.1488					_RBNoSpace:
.1488	9c 61 04	stz $0461			stz 	ReadBufferSize 				; empty the buffer.
.148b	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.148d	d0 08		bne $1497			bne 	_RBCommaSep
.148f	8d 60 04	sta $0460			sta 	ReadSep 					; use as a seperator
.1492	20 c4 14	jsr $14c4			jsr 	GetBumpNext 				; consume the '"'
.1495	80 05		bra $149c			bra 	_RBGetText
.1497					_RBCommaSep:
.1497	a9 2c		lda #$2c			lda 	#","						; get till comma
.1499	8d 60 04	sta $0460			sta 	ReadSep
.149c					_RBGetText:
.149c	20 c7 14	jsr $14c7			jsr 	GetLookNext 				; what follows
.149f	b0 18		bcs $14b9			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.14a1	20 c4 14	jsr $14c4			jsr 	GetBumpNext 				; consume it whatever
.14a4	cd 60 04	cmp $0460			cmp 	ReadSep 					; if found the seperator.
.14a7	f0 10		beq $14b9			beq 	_RBEndGet 					; exit after consumption
.14a9	da		phx				phx
.14aa	ae 61 04	ldx $0461			ldx 	ReadBufferSize 				; copy into buffer.
.14ad	ee 61 04	inc $0461			inc 	ReadBufferSize
.14b0	9d 62 04	sta $0462,x			sta 	ReadBuffer,x
.14b3	9e 63 04	stz $0463,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.14b6	fa		plx				plx
.14b7	80 e3		bra $149c			bra 	_RBGetText
.14b9					_RBEndGet:
.14b9	c9 22		cmp #$22			cmp 	#'"'
.14bb	d0 03		bne $14c0			bne 	_RBNotQuote
.14bd	20 c4 14	jsr $14c4			jsr 	GetBumpNext
.14c0					_RBNotQuote:
.14c0	60		rts				rts
.14c1					_RBError:
.14c1	4c fb 1f	jmp $1ffb		jmp	ErrorV_data
.14c4					GetBumpNext:
.14c4	6c 61 05	jmp ($0561)			jmp 	(ReadBumpNextVec)
.14c7					GetLookNext:
.14c7	6c 63 05	jmp ($0563)			jmp 	(ReadLookNextVec)
.14ca					ReadLookNext:
.14ca	ad 65 05	lda $0565			lda 	dataRemaining 				; any data remaining
.14cd	f0 04		beq $14d3			beq 	_RLNFindData
.14cf	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.14d1	18		clc				clc
.14d2	60		rts				rts
.14d3					_RLNFindData:
.14d3	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.14d5	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.14d7	f0 1a		beq $14f3			beq 	_RLNNoData
.14d9	c9 d0		cmp #$d0			cmp 	#PCD_CMD_DATA 				; Found DATA
.14db	f0 05		beq $14e2			beq 	_RLNHaveData
.14dd					_RLNNext:
.14dd	20 79 20	jsr $2079			jsr 	MoveObjectForward			; else scan forward.
.14e0	80 f1		bra $14d3			bra 	_RLNFindData
.14e2					_RLNHaveData:
.14e2	a0 01		ldy #$01			ldy 	#1 							; get length
.14e4	b1 2a		lda ($2a),y			lda 	(objPtr),y
.14e6	f0 f5		beq $14dd			beq 	_RLNNext 					; skip if DATA alone
.14e8	20 f7 14	jsr $14f7			jsr 	ReadBumpNext 				; advance by two
.14eb	20 f7 14	jsr $14f7			jsr 	ReadBumpNext
.14ee	8d 65 05	sta $0565			sta 	dataRemaining 				; set data left count.
.14f1	38		sec				sec
.14f2	60		rts				rts
.14f3					_RLNNoData:
.14f3	a9 00		lda #$00			lda 	#0
.14f5	38		sec				sec
.14f6	60		rts				rts
.14f7					ReadBumpNext:
.14f7	e6 2a		inc $2a				inc 	objPtr
.14f9	d0 02		bne $14fd			bne 	_RBNSkip
.14fb	e6 2b		inc $2b				inc 	objPtr+1
.14fd					_RBNSkip:
.14fd	ce 65 05	dec $0565			dec 	dataRemaining
.1500	60		rts				rts
.0460					ReadSep:
>0460							.fill 	1
.0461					ReadBufferSize:
>0461							.fill 	1
.0462					ReadBuffer:
>0462							.fill 	255
.0561					ReadBumpNextVec:
>0561							.fill 	2
.0563					ReadLookNextVec:
>0563							.fill 	2
.1501					ReadFloatCommand:
.1501	fa		plx				plx
.1502	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1504	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1506	88		dey				dey 								; get the upper 3 bits
.1507	b1 28		lda ($28),y			lda 	(codePtr),y
.1509	29 07		and #$07			and 	#7
.150b	c8		iny				iny
.150c	c8		iny				iny
.150d	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.150f	2a		rol a				rol 	a 							; carry will be clear.
.1510	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1513	85 2d		sta $2d				sta 	zTemp0+1
.1515	20 1b 15	jsr $151b			jsr 	ReadFloatZTemp0Sub
.1518	4c 4f 08	jmp $084f			jmp 	NextCommand
.151b					ReadFloatZTemp0Sub:
.151b	5a		phy				phy 								; start write
.151c	a0 01		ldy #$01			ldy 	#1
.151e	e8		inx				inx
.151f	b2 2c		lda ($2c)			lda 	(zTemp0)
.1521	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1523	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1525	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1527	c8		iny				iny
.1528	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.152a	95 56		sta $56,x			sta 	NSMantissa2,x
.152c	c8		iny				iny
.152d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.152f	95 62		sta $62,x			sta 	NSMantissa3,x
.1531	c8		iny				iny
.1532	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1534	95 6e		sta $6e,x			sta 	NSExponent,x
.1536	c8		iny				iny
.1537	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1539	95 32		sta $32,x			sta 	NSStatus,x
.153b	7a		ply				ply
.153c	60		rts				rts
.153d					ReadIntegerCommand:
.153d	fa		plx				plx
.153e	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1540	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1542	88		dey				dey 								; get the upper 3 bits
.1543	b1 28		lda ($28),y			lda 	(codePtr),y
.1545	29 07		and #$07			and 	#7
.1547	c8		iny				iny
.1548	c8		iny				iny
.1549	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.154b	2a		rol a				rol 	a 							; carry will be clear.
.154c	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.154f	85 2d		sta $2d				sta 	zTemp0+1
.1551	20 57 15	jsr $1557			jsr 	ReadIntegerZTemp0Sub
.1554	4c 4f 08	jmp $084f			jmp 	NextCommand
.1557					ReadIntegerZTemp0Sub:
.1557	5a		phy				phy 								; start write
.1558	a0 01		ldy #$01			ldy 	#1
.155a	e8		inx				inx 								; prepare
.155b	74 56		stz $56,x			stz 	NSMantissa2,x
.155d	74 62		stz $62,x			stz 	NSMantissa3,x
.155f	74 6e		stz $6e,x			stz 	NSExponent,x
.1561	74 32		stz $32,x			stz 	NSStatus,x
.1563	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1565	30 08		bmi $156f			bmi 	_RIZNegative
.1567	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1569	b2 2c		lda ($2c)			lda 	(zTemp0)
.156b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.156d	7a		ply				ply
.156e	60		rts				rts
.156f					_RIZNegative:
.156f	38		sec				sec 								; -ve read
.1570	a9 00		lda #$00			lda 	#0
.1572	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.1574	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1576	a9 00		lda #$00			lda 	#0
.1578	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.157a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.157c	a9 80		lda #$80			lda 	#$80
.157e	95 32		sta $32,x			sta 	NSStatus,x
.1580	7a		ply				ply
.1581	60		rts				rts
.1582					ReadStringCommand:
.1582	fa		plx				plx
.1583	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1585	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1587	88		dey				dey 								; get the upper 3 bits
.1588	b1 28		lda ($28),y			lda 	(codePtr),y
.158a	29 07		and #$07			and 	#7
.158c	c8		iny				iny
.158d	c8		iny				iny
.158e	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1590	2a		rol a				rol 	a 							; carry will be clear.
.1591	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1594	85 2d		sta $2d				sta 	zTemp0+1
.1596	20 9c 15	jsr $159c			jsr 	ReadStringZTemp0Sub
.1599	4c 4f 08	jmp $084f			jmp 	NextCommand
.159c					ReadStringZTemp0Sub:
.159c	5a		phy				phy 								; start write
.159d	e8		inx				inx 								; prepare
.159e	74 56		stz $56,x			stz 	NSMantissa2,x
.15a0	74 62		stz $62,x			stz 	NSMantissa3,x
.15a2	74 6e		stz $6e,x			stz 	NSExponent,x
.15a4	a9 40		lda #$40			lda 	#NSSString
.15a6	74 32		stz $32,x			stz 	NSStatus,x
.15a8	18		clc				clc
.15a9	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.15ab	69 02		adc #$02			adc 	#2 							; this points to actual data
.15ad	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.15af	a0 01		ldy #$01			ldy 	#1
.15b1	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.15b3	69 00		adc #$00			adc 	#0
.15b5	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.15b7	d0 08		bne $15c1			bne 	_RSZNoDefault 				; if read $00 use a default value.
.15b9	a9 c3		lda #$c3			lda 	#_RSZNull & $FF
.15bb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15bd	a9 15		lda #$15			lda 	#_RSZNull >> 8
.15bf	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15c1					_RSZNoDefault:
.15c1	7a		ply				ply
.15c2	60		rts				rts
.15c3					_RSZNull:
>15c3	00						.byte 	0
.15c4					CommandRestoreX:
.15c4	fa		plx				plx
.15c5	20 cb 15	jsr $15cb			jsr 	RestoreCodeOffset
.15c8	4c 4f 08	jmp $084f			jmp 	NextCommand
.15cb					RestoreCodeOffset:
.15cb	20 cb 08	jsr $08cb			jsr 	FixUpY  					; make Y = 0 adjusting code Ptr.
.15ce	18		clc				clc 								; add LSB
.15cf	b1 28		lda ($28),y			lda 	(codePtr),y
.15d1	65 28		adc $28				adc 	codePtr
.15d3	85 2a		sta $2a				sta 	objPtr
.15d5	c8		iny				iny 								; add MSB
.15d6	b1 28		lda ($28),y			lda 	(codePtr),y
.15d8	65 29		adc $29				adc 	codePtr+1
.15da	85 2b		sta $2b				sta 	objPtr+1
.15dc	c8		iny				iny 								; next command.
.15dd	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15e0	60		rts				rts
.15e1					RestoreCode:
.15e1	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.15e4	85 2b		sta $2b				sta 	objPtr+1
.15e6	64 2a		stz $2a				stz 	objPtr
.15e8	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15eb	60		rts				rts
.0565					dataRemaining:
>0565							.fill 	1		 					; 0 if not in data statement
.15ec					UnaryRND:
.15ec	fa		plx				plx
.15ed	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.15ef	10 17		bpl $1608			bpl 	_URNoSeed
.15f1	20 00 24	jsr $2400			jsr 	FloatNormalise 				; some float value
.15f4	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.15f6	8d 66 05	sta $0566			sta 	randomSeed+0
.15f9	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15fb	8d 67 05	sta $0567			sta 	randomSeed+1
.15fe	b5 56		lda $56,x			lda 	NSMantissa2,x
.1600	8d 68 05	sta $0568			sta 	randomSeed+2
.1603	b5 62		lda $62,x			lda 	NSMantissa3,x
.1605	8d 69 05	sta $0569			sta 	randomSeed+3
.1608					_URNoSeed:
.1608	20 2a 16	jsr $162a			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.160b	ad 66 05	lda $0566			lda 	randomSeed+0
.160e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1610	ad 67 05	lda $0567			lda 	randomSeed+1
.1613	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1615	ad 68 05	lda $0568			lda 	randomSeed+2
.1618	95 56		sta $56,x			sta 	NSMantissa2,x
.161a	ad 69 05	lda $0569			lda 	randomSeed+3
.161d	29 7f		and #$7f			and 	#$7F
.161f	95 62		sta $62,x			sta 	NSMantissa3,x
.1621	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.1623	95 6e		sta $6e,x			sta 	NSExponent,x
.1625	74 32		stz $32,x			stz 	NSStatus,x
.1627	4c 4f 08	jmp $084f			jmp 	NextCommand
.162a					RandomNumberGenerator:
.162a	5a		phy				phy
.162b	ad 66 05	lda $0566			lda 	randomSeed+0 				; check if zero
.162e	0d 67 05	ora $0567			ora 	randomSeed+1
.1631	0d 68 05	ora $0568			ora 	randomSeed+2
.1634	0d 69 05	ora $0569			ora 	randomSeed+3
.1637	d0 07		bne $1640			bne 	_RNGNoSeed
.1639	ce 69 05	dec $0569			dec 	randomSeed+3 				; if so tweak and flog
.163c	a0 64		ldy #$64			ldy 	#100
.163e	80 05		bra $1645			bra 	_RNGLoop
.1640					_RNGNoSeed:
.1640	a0 08		ldy #$08			ldy 	#8
.1642	ad 66 05	lda $0566			lda 	randomSeed+0
.1645					_RNGLoop:
.1645	0a		asl a				asl		a
.1646	2e 67 05	rol $0567			rol 	randomSeed+1
.1649	2e 68 05	rol $0568			rol 	randomSeed+2
.164c	2e 69 05	rol $0569			rol 	randomSeed+3
.164f	90 02		bcc $1653			bcc		_RNGSkip
.1651	49 c5		eor #$c5			eor 	#$C5
.1653					_RNGSkip:
.1653	88		dey				dey
.1654	d0 ef		bne $1645			bne		_RNGLoop
.1656	8d 66 05	sta $0566			sta 	randomSeed+0
.1659	7a		ply				ply
.165a	60		rts				rts
.0566					randomSeed:
>0566							.fill 	4
.165b					StringConcatenate:
.165b	fa		plx				plx
.165c	ca		dex				dex
.165d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.165f	85 2e		sta $2e				sta 	zTemp1
.1661	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1663	85 2f		sta $2f				sta 	zTemp1+1
.1665	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.1667	85 30		sta $30				sta 	zTemp2
.1669	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.166b	85 31		sta $31				sta 	zTemp2+1
.166d	18		clc				clc 								; work out total length
.166e	b2 2e		lda ($2e)			lda 	(zTemp1)
.1670	72 30		adc ($30)			adc 	(zTemp2)
.1672	b0 18		bcs $168c			bcs 	_BCLength 					; more than 255 characters.
.1674	48		pha				pha 								; save total
.1675	20 52 17	jsr $1752			jsr 	StringAllocTemp 			; space for result.
.1678	68		pla				pla 								; write total as first.
.1679	92 22		sta ($22)			sta 	(zsTemp)
.167b	20 8f 16	jsr $168f			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.167e	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.1680	85 2e		sta $2e				sta 	zTemp1
.1682	a5 31		lda $31				lda 	zTemp2+1
.1684	85 2f		sta $2f				sta 	zTemp1+1
.1686	20 8f 16	jsr $168f			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1689	4c 4f 08	jmp $084f			jmp 	NextCommand
.168c					_BCLength:
.168c	4c 36 1f	jmp $1f36		jmp	ErrorV_range
.168f					_BCCopyZTemp1:
.168f	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.1691	f0 15		beq $16a8			beq 	_BCCExit 					; none.
.1693	da		phx				phx 								; save XY
.1694	5a		phy				phy
.1695	aa		tax				tax 								; count in X.
.1696	a0 01		ldy #$01			ldy 	#1
.1698					_BCCLoop:
.1698	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.169a	d0 02		bne $169e			bne 	_BCCNoCarry
.169c	e6 23		inc $23				inc 	zsTemp+1
.169e					_BCCNoCarry:
.169e	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.16a0	92 22		sta ($22)			sta 	(zsTemp)
.16a2	c8		iny				iny
.16a3	ca		dex				dex 								; X times
.16a4	d0 f2		bne $1698			bne 	_BCCLoop
.16a6	7a		ply				ply 								; restore YX
.16a7	fa		plx				plx
.16a8					_BCCExit:
.16a8	60		rts				rts
.16a9					XRuntimeSetup:
.16a9	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.16ab	8d 6d 05	sta $056d	 		sta 	ramBank
.16ae	8d 6e 05	sta $056e	 		sta 	romBank
.16b1	60		rts				rts
.16b2					SignTOS:
.16b2	fa		plx				plx
.16b3	20 cd 26	jsr $26cd			jsr 	FloatIsZero 				; if zero
.16b6	f0 0f		beq $16c7			beq 	_SGZero  					; return Int Zero
.16b8	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.16ba	48		pha				pha
.16bb	a9 01		lda #$01			lda 	#1 							; set result to 1
.16bd	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.16c0	68		pla				pla
.16c1	29 80		and #$80			and		#$80 						; copy the sign byte out
.16c3	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.16c5	80 03		bra $16ca			bra 	_SGExit
.16c7					_SGZero:
.16c7	20 ab 26	jsr $26ab			jsr 	FloatSetZero
.16ca					_SGExit:
.16ca	4c 4f 08	jmp $084f			jmp 	NextCommand
.16cd					CommandShift:
.16cd	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.16cf	c8		iny				iny
.16d0	0a		asl a				asl 	a 							; double into X
.16d1	aa		tax				tax
.16d2	7c 81 1a	jmp ($1a81,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.16d5					PrintTab:
.16d5	fa		plx				plx
.16d6	20 29 1c	jsr $1c29			jsr 	XGetHPos
.16d9					_PTMod10:
.16d9	38		sec				sec
.16da	e9 0a		sbc #$0a			sbc 	#10
.16dc	b0 fb		bcs $16d9			bcs 	_PTMod10
.16de	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.16e0	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.16e1	80 15		bra $16f8			bra 	PrintSpaceLoop
.16e3					PrintPos:
.16e3	fa		plx				plx
.16e4	20 29 1c	jsr $1c29			jsr		XGetHPos 					; get current position
.16e7	85 2c		sta $2c				sta 	zTemp0
.16e9	38		sec				sec 								; calculate spaces required
.16ea	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16ec	ca		dex				dex
.16ed	e5 2c		sbc $2c				sbc 	zTemp0
.16ef	b0 07		bcs $16f8			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.16f1	4c 4f 08	jmp $084f			jmp 	NextCommand
.16f4					PrintSpace:
.16f4	fa		plx				plx
.16f5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16f7	ca		dex				dex
.16f8					PrintSpaceLoop:
.16f8	c9 00		cmp #$00			cmp 	#0
.16fa	f0 0a		beq $1706			beq 	_PSExit
.16fc	48		pha				pha
.16fd	a9 20		lda #$20			lda 	#" "
.16ff	20 99 13	jsr $1399			jsr 	VectorPrintCharacter
.1702	68		pla				pla
.1703	3a		dec a				dec 	a
.1704	80 f2		bra $16f8			bra 	PrintSpaceLoop
.1706					_PSExit:
.1706	4c 4f 08	jmp $084f			jmp 	NextCommand
.1709					CommandStop:
.1709	fa		plx				plx
.170a	4c e8 1f	jmp $1fe8		jmp	ErrorV_stop
.170d					Unary_Str:
.170d	fa		plx				plx
.170e	5a		phy				phy
.170f	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.1711	20 93 25	jsr $2593			jsr 	FloatToString 				; do the conversion.
.1714	a9 21		lda #$21			lda		#33 						; create buffer
.1716	20 52 17	jsr $1752			jsr 	StringAllocTemp 			; allocate memory
.1719	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.171b					_USCopy:
.171b	b9 97 05	lda $0597,y			lda 	decimalBuffer-1,y
.171e	f0 05		beq $1725			beq 	_USExit
.1720	91 22		sta ($22),y			sta 	(zsTemp),y
.1722	c8		iny				iny
.1723	80 f6		bra $171b			bra 	_USCopy
.1725					_USExit:
.1725	98		tya				tya
.1726	3a		dec a				dec 	a
.1727	92 22		sta ($22)			sta 	(zsTemp)
.1729	7a		ply				ply
.172a	4c 4f 08	jmp $084f			jmp 	NextCommand
.172d					StringInitialise:
.172d	48		pha				pha
.172e	ad 6a 05	lda $056a			lda 	stringInitialised 			; already done
.1731	d0 11		bne $1744			bne 	_SIExit
.1733	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.1736	8d 6b 05	sta $056b			sta 	stringTempPointer
.1739	ad 03 04	lda $0403			lda 	stringHighMemory+1
.173c	3a		dec a				dec 	a
.173d	3a		dec a				dec 	a
.173e	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.1741	ce 6a 05	dec $056a			dec 	stringInitialised 			; set the initialised flag.
.1744					_SIExit:
.1744	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.1746	1a		inc a				inc 	a
.1747	1a		inc a				inc 	a
.1748	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.174b	b0 02		bcs $174f			bcs 	_SIMemory
.174d	68		pla				pla
.174e	60		rts				rts
.174f					_SIMemory:
.174f	4c 41 20	jmp $2041		jmp	ErrorV_memory
.1752					StringAllocTemp:
.1752	20 2d 17	jsr $172d			jsr 	StringInitialise 			; check it is initialised.
.1755	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.1757	18		clc				clc
.1758	6d 6b 05	adc $056b			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.175b	8d 6b 05	sta $056b			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.175e	85 22		sta $22				sta 	zsTemp
.1760	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1762	ad 6c 05	lda $056c			lda 	stringTempPointer+1
.1765	69 ff		adc #$ff			adc 	#$FF
.1767	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.176a	85 23		sta $23				sta 	zsTemp+1
.176c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.176e	74 56		stz $56,x			stz 	NSMantissa2,x
.1770	74 62		stz $62,x			stz 	NSMantissa3,x
.1772	a9 00		lda #$00			lda 	#0 							; clear string.
.1774	92 22		sta ($22)			sta 	(zsTemp)
.1776	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1778	95 32		sta $32,x			sta 	NSStatus,x
.177a	60		rts				rts
.177b					StringWriteChar:
.177b	5a		phy				phy
.177c	48		pha				pha
.177d	b2 22		lda ($22)			lda 	(zsTemp)
.177f	1a		inc a				inc 	a
.1780	92 22		sta ($22)			sta 	(zsTemp)
.1782	a8		tay				tay
.1783	68		pla				pla
.1784	91 22		sta ($22),y			sta 	(zsTemp),y
.1786	7a		ply				ply
.1787	60		rts				rts
.056a					stringInitialised:
>056a							.fill 	1
.056b					stringTempPointer:
>056b							.fill 	2
.1788					Unary_Left:
.1788	fa		plx				plx
.1789	5a		phy				phy
.178a	18		clc				clc 								; only one parameter
.178b	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; push the length of the string.
.178e	48		pha				pha
.178f	ca		dex				dex
.1790	a9 00		lda #$00			lda 	#0 							; push the start position.
.1792	48		pha				pha
.1793	20 cb 17	jsr $17cb			jsr 	UnarySStringToZTemp0
.1796	80 3c		bra $17d4			bra 	SubstringMain 				; stack now points to the string to slice.
.1798					Unary_Right:
.1798	fa		plx				plx
.1799	5a		phy				phy
.179a	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.179c	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; push the right length of the string.
.179f	48		pha				pha
.17a0	ca		dex				dex
.17a1	20 cb 17	jsr $17cb			jsr 	UnarySStringToZTemp0
.17a4	68		pla				pla 								; this is the right requirement
.17a5	38		sec				sec
.17a6	49 ff		eor #$ff			eor 	#$FF
.17a8	72 2c		adc ($2c)			adc 	(zTemp0)
.17aa	b0 02		bcs $17ae			bcs 	_URHaveCount
.17ac	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.17ae					_URHaveCount:
.17ae	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.17b0	5a		phy				phy
.17b1	48		pha				pha 								; start position
.17b2	80 20		bra $17d4			bra 	SubstringMain
.17b4					Unary_Mid:
.17b4	fa		plx				plx
.17b5	5a		phy				phy
.17b6	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; push the length of the string required.
.17b9	48		pha				pha
.17ba	ca		dex				dex
.17bb	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; put the start position.
.17be	f0 08		beq $17c8			beq 	_UMError
.17c0	3a		dec a				dec 	a
.17c1	48		pha				pha
.17c2	ca		dex				dex
.17c3	20 cb 17	jsr $17cb			jsr 	UnarySStringToZTemp0
.17c6	80 0c		bra $17d4			bra 	SubstringMain 				; stack now points to the string to slice.
.17c8					_UMError:
.17c8	4c 36 1f	jmp $1f36		jmp	ErrorV_range
.17cb					UnarySStringToZTemp0:
.17cb	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17cd	85 2c		sta $2c				sta 	zTemp0
.17cf	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17d1	85 2d		sta $2d				sta 	zTemp0+1
.17d3	60		rts				rts
.17d4					SubstringMain:
.17d4	68		pla				pla 								; get the start offset
.17d5	7a		ply				ply 								; get the count to do.
.17d6	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.17d8	b0 38		bcs $1812			bcs 	_SSReturnNull
.17da	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.17dc	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.17de	18		clc				clc
.17df	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.17e1	b0 06		bcs $17e9			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.17e3	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.17e5	f0 04		beq $17eb			beq 	_SMIsOkay
.17e7	90 02		bcc $17eb			bcc 	_SMIsOkay
.17e9					_SMTruncateToEnd:
.17e9	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.17eb					_SMIsOkay:
.17eb	85 2f		sta $2f				sta 	zTemp1+1
.17ed	38		sec				sec		 							; work out size
.17ee	a5 2f		lda $2f				lda 	zTemp1+1
.17f0	e5 2e		sbc $2e				sbc 	zTemp1
.17f2	f0 1e		beq $1812			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.17f4	20 52 17	jsr $1752			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.17f7	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.17f9					_SMCopy:
.17f9	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.17fb	f0 11		beq $180e			beq 	_SMExit
.17fd	c8		iny				iny 								; bump and
.17fe	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.1800	5a		phy				phy
.1801	48		pha				pha
.1802	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.1804	1a		inc a				inc 	a
.1805	a8		tay				tay
.1806	92 22		sta ($22)			sta 	(zsTemp)
.1808	68		pla				pla 								; write character out
.1809	91 22		sta ($22),y			sta 	(zsTemp),y
.180b	7a		ply				ply 								; restore Y
.180c	80 eb		bra $17f9			bra 	_SMCopy
.180e					_SMExit:
.180e	7a		ply				ply
.180f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1812					_SSReturnNull:
.1812	a9 24		lda #$24			lda 	#SSRNull & $FF 				; set up mantissa
.1814	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1816	a9 18		lda #$18			lda 	#SSRNull >> 8
.1818	95 4a		sta $4a,x			sta 	NSMantissa1,x
.181a	74 56		stz $56,x			stz 	NSMantissa2,x
.181c	74 62		stz $62,x			stz 	NSMantissa3,x
.181e	a9 40		lda #$40			lda 	#NSSString
.1820	95 32		sta $32,x			sta 	NSStatus,x
.1822	80 ea		bra $180e			bra 	_SMExit
.1824					SSRNull:
>1824	00 00						.word 	0
.1826					CommandSwap:
.1826	fa		plx				plx
.1827	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1829	48		pha				pha
.182a	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.182c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.182e	68		pla				pla
.182f	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.1831	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1833	48		pha				pha
.1834	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.1836	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1838	68		pla				pla
.1839	95 49		sta $49,x			sta 	NSMantissa1-1,x
.183b	b5 56		lda $56,x			lda 	NSMantissa2,x
.183d	48		pha				pha
.183e	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.1840	95 56		sta $56,x			sta 	NSMantissa2,x
.1842	68		pla				pla
.1843	95 55		sta $55,x			sta 	NSMantissa2-1,x
.1845	b5 62		lda $62,x			lda 	NSMantissa3,x
.1847	48		pha				pha
.1848	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.184a	95 62		sta $62,x			sta 	NSMantissa3,x
.184c	68		pla				pla
.184d	95 61		sta $61,x			sta 	NSMantissa3-1,x
.184f	b5 6e		lda $6e,x			lda 	NSExponent,x
.1851	48		pha				pha
.1852	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.1854	95 6e		sta $6e,x			sta 	NSExponent,x
.1856	68		pla				pla
.1857	95 6d		sta $6d,x			sta 	NSExponent-1,x
.1859	b5 32		lda $32,x			lda 	NSStatus,x
.185b	48		pha				pha
.185c	b5 31		lda $31,x			lda 	NSStatus-1,x
.185e	95 32		sta $32,x			sta 	NSStatus,x
.1860	68		pla				pla
.1861	95 31		sta $31,x			sta 	NSStatus-1,x
.1863	4c 4f 08	jmp $084f			jmp 	NextCommand
.1866					CommandSYS:
.1866	fa		plx				plx
.1867	da		phx				phx 								; save XY
.1868	5a		phy				phy
.1869	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.186c	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.186e	85 2d		sta $2d				sta 	zTemp0+1
.1870	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1872	85 2c		sta $2c				sta 	zTemp0
.1874	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1877	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.187a	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.187d	48		pha				pha
.187e	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.1881	28		plp				plp
.1882	20 99 18	jsr $1899			jsr 	_CSZTemp0
.1885	08		php				php
.1886	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1889	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.188c	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.188f	68		pla				pla
.1890	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.1893	7a		ply				ply 								; restore YX and drop 2
.1894	fa		plx				plx
.1895	ca		dex				dex
.1896	4c 4f 08	jmp $084f			jmp 	NextCommand
.1899					_CSZTemp0:
.1899	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.189c					TimeTOS:
.189c	fa		plx				plx
.189d	20 f7 18	jsr $18f7			jsr 	TIPushClock 				; push clock to TOS
.18a0	4c 4f 08	jmp $084f			jmp 	NextCommand
.18a3					TimeString:
.18a3	fa		plx				plx
.18a4	20 f7 18	jsr $18f7			jsr 	TIPushClock 				; push clock to TOS
.18a7	20 cc 18	jsr $18cc			jsr 	_TSDivMod60 				; result in seconds
.18aa	20 cc 18	jsr $18cc			jsr 	_TSDivMod60 				; seconds
.18ad	48		pha				pha
.18ae	20 cc 18	jsr $18cc			jsr 	_TSDivMod60 				; minutes
.18b1	48		pha				pha
.18b2	a9 18		lda #$18			lda 	#24 						; hours
.18b4	20 ce 18	jsr $18ce			jsr 	_TSDivModA
.18b7	48		pha				pha
.18b8	a9 06		lda #$06			lda 	#6
.18ba	20 52 17	jsr $1752			jsr 	StringAllocTemp
.18bd	68		pla				pla
.18be	20 de 18	jsr $18de			jsr 	_TSWriteDecimal
.18c1	68		pla				pla
.18c2	20 de 18	jsr $18de			jsr 	_TSWriteDecimal
.18c5	68		pla				pla
.18c6	20 de 18	jsr $18de			jsr 	_TSWriteDecimal
.18c9	4c 4f 08	jmp $084f			jmp 	NextCommand
.18cc					_TSDivMod60:
.18cc	a9 3c		lda #$3c			lda 	#60
.18ce					_TSDivModA:
.18ce	e8		inx				inx
.18cf	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.18d2	ca		dex				dex
.18d3	20 41 22	jsr $2241			jsr 	Int32Divide
.18d6	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.18d8	48		pha				pha
.18d9	20 30 22	jsr $2230			jsr 	NSMCopyPlusTwoToZero
.18dc	68		pla				pla
.18dd	60		rts				rts
.18de					_TSWriteDecimal:
.18de	da		phx				phx
.18df	a2 30		ldx #$30			ldx 	#'0'
.18e1					_TSWDLoop:
.18e1	c9 0a		cmp #$0a			cmp 	#10
.18e3	90 05		bcc $18ea			bcc 	_TSWDEnd
.18e5	e9 0a		sbc #$0a			sbc 	#10
.18e7	e8		inx				inx
.18e8	80 f7		bra $18e1			bra 	_TSWDLoop
.18ea					_TSWDEnd:
.18ea	48		pha				pha
.18eb	8a		txa				txa
.18ec	20 7b 17	jsr $177b			jsr 	StringWriteChar
.18ef	68		pla				pla
.18f0	09 30		ora #$30			ora 	#'0'
.18f2	20 7b 17	jsr $177b			jsr 	StringWriteChar
.18f5	fa		plx				plx
.18f6	60		rts				rts
.18f7					TIPushClock:
.18f7	5a		phy				phy
.18f8	e8		inx				inx 								; push 0 on the stack
.18f9	20 ab 26	jsr $26ab			jsr 	FloatSetZero
.18fc	da		phx				phx
.18fd	20 f4 1c	jsr $1cf4			jsr 	XReadClock 					; read time into YXA
.1900	86 2c		stx $2c				stx 	zTemp0
.1902	fa		plx				plx
.1903	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1905	a5 2c		lda $2c				lda 	zTemp0
.1907	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1909	98		tya				tya
.190a	95 56		sta $56,x			sta 	NSMantissa2,x
.190c	7a		ply				ply
.190d	60		rts				rts
.190e					CommandTIWrite:
.190e	fa		plx				plx
.190f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.1911	85 22		sta $22				sta 	zsTemp
.1913	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1915	85 23		sta $23				sta 	zsTemp+1
.1917	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.1919	c9 06		cmp #$06			cmp 	#6
.191b	d0 59		bne $1976			bne 	_CTIWError
.191d	20 ab 26	jsr $26ab			jsr 	FloatSetZero
.1920	20 42 19	jsr $1942			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.1923	20 42 19	jsr $1942			jsr 	_CTIWDigitPair
.1926	20 42 19	jsr $1942			jsr 	_CTIWDigitPair
.1929	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.192b	20 6d 19	jsr $196d			jsr 	_CTIWMultiply
.192e	da		phx				phx
.192f	5a		phy				phy
.1930	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.1932	48		pha				pha
.1933	b5 56		lda $56,x			lda 	NSMantissa2,x
.1935	a8		tay				tay
.1936	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1938	fa		plx				plx
.1939	20 f8 1c	jsr $1cf8			jsr 	XWriteClock 				; update the clock.
.193c	7a		ply				ply
.193d	fa		plx				plx
.193e	ca		dex				dex 								; throw result.
.193f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1942					_CTIWDigitPair:
.1942	a9 06		lda #$06			lda 	#6 							; x 6
.1944	20 6d 19	jsr $196d			jsr 	_CTIWMultiply
.1947	20 53 19	jsr $1953			jsr 	_CTIWAddDigit 				; add digit
.194a	a9 0a		lda #$0a			lda 	#10 						; x 10
.194c	20 6d 19	jsr $196d			jsr 	_CTIWMultiply
.194f	20 53 19	jsr $1953			jsr 	_CTIWAddDigit 				; add digit
.1952	60		rts				rts
.1953					_CTIWAddDigit:
.1953	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.1955	d0 02		bne $1959			bne 	_CTIWASkip
.1957	e6 23		inc $23				inc 	zsTemp+1
.1959					_CTIWASkip:
.1959	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.195b	38		sec				sec
.195c	e9 30		sbc #$30			sbc 	#"0"
.195e	90 16		bcc $1976			bcc 	_CTIWError
.1960	c9 0a		cmp #$0a			cmp 	#9+1
.1962	b0 12		bcs $1976			bcs 	_CTIWError
.1964	e8		inx				inx 								; store at +1
.1965	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.1968	ca		dex				dex
.1969	20 37 24	jsr $2437			jsr 	FloatAddTopTwoStack
.196c	60		rts				rts
.196d					_CTIWMultiply:
.196d	e8		inx				inx
.196e	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.1971	ca		dex				dex
.1972	20 b8 23	jsr $23b8			jsr 	FloatMultiplyShort
.1975	60		rts				rts
.1976					_CTIWError:
.1976	4c 46 1f	jmp $1f46		jmp	ErrorV_value
.1979					UnaryUsr:
.1979	fa		plx				plx
.197a	5a		phy				phy
.197b	20 82 19	jsr $1982			jsr 	_UUCallVector
.197e	7a		ply				ply
.197f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1982					_UUCallVector:
.1982	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.1985					ValUnary:
.1985	fa		plx				plx
.1986	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1988	85 2c		sta $2c				sta 	zTemp0
.198a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.198c	85 2d		sta $2d				sta 	zTemp0+1
.198e	20 99 19	jsr $1999			jsr 	ValEvaluateZTemp0
.1991	b0 03		bcs $1996			bcs 	_VUError 					; couldn't convert
.1993	4c 4f 08	jmp $084f			jmp 	NextCommand
.1996					_VUError:
.1996	4c 46 1f	jmp $1f46		jmp	ErrorV_value
.1999					ValEvaluateZTemp0:
.1999	5a		phy				phy
.199a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.199c	f0 22		beq $19c0			beq 	_VMCFail2
.199e	a0 00		ldy #$00			ldy 	#0 							; start position
.19a0					_VMCSpaces:
.19a0	c8		iny				iny 								; skip leading spaces
.19a1	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.19a3	c9 20		cmp #$20			cmp 	#" "
.19a5	f0 f9		beq $19a0			beq 	_VMCSpaces
.19a7	48		pha				pha 								; save first character
.19a8	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.19aa	d0 01		bne $19ad			bne 	_VMCStart
.19ac	c8		iny				iny 								; skip over - if so.
.19ad					_VMCStart:
.19ad	38		sec				sec 								; initialise first time round.
.19ae					_VMCNext:
.19ae	98		tya				tya 								; reached end of string
.19af	3a		dec a				dec 	a
.19b0	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.19b2	f0 0f		beq $19c3			beq 	_VMCSuccess 				; successful.
.19b4	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.19b6	c8		iny				iny
.19b7	20 8f 24	jsr $248f			jsr 	FloatEncode 				; send it to the number-builder
.19ba	90 03		bcc $19bf			bcc 	_VMCFail 					; if failed, give up.
.19bc	18		clc				clc 								; next time round, countinue
.19bd	80 ef		bra $19ae			bra 	_VMCNext
.19bf					_VMCFail:
.19bf	68		pla				pla
.19c0					_VMCFail2:
.19c0	7a		ply				ply
.19c1	38		sec				sec
.19c2	60		rts				rts
.19c3					_VMCSuccess:
.19c3	a9 00		lda #$00			lda 	#0 							; construct final
.19c5	20 8f 24	jsr $248f			jsr 	FloatEncode 				; by sending a duff value.
.19c8	68		pla				pla 								; if it was -ve
.19c9	c9 2d		cmp #$2d			cmp 	#"-"
.19cb	d0 03		bne $19d0			bne 	_VMCNotNegative
.19cd	20 6d 26	jsr $266d			jsr		FloatNegate 				; negate it.
.19d0					_VMCNotNegative:
.19d0	7a		ply				ply
.19d1	18		clc				clc
.19d2	60		rts				rts
.19d3					VectorTable:
>19d3	af 10					.word	LinkFloatAdd             ; $80 +
>19d5	b8 10					.word	LinkFloatSubtract        ; $81 -
>19d7	c1 10					.word	LinkFloatMultiply        ; $82 *
>19d9	ca 10					.word	LinkFloatDivide          ; $83 /
>19db	d5 10					.word	LinkFloatPower           ; $84 ^
>19dd	f2 08					.word	BinaryAnd                ; $85 and
>19df	f6 08					.word	BinaryOr                 ; $86 or
>19e1	e0 10					.word	LinkCompareGreater       ; $87 >
>19e3	e9 10					.word	LinkCompareEqual         ; $88 =
>19e5	f2 10					.word	LinkCompareLess          ; $89 <
>19e7	fb 10					.word	LinkCompareGreaterEqual  ; $8a >=
>19e9	04 11					.word	LinkCompareNotEqual      ; $8b <>
>19eb	0d 11					.word	LinkCompareLessEqual     ; $8c <=
>19ed	da 08					.word	AbsoluteTOS              ; $8d abs
>19ef	2d 09					.word	ArrayConvert             ; $8e array
>19f1	d5 09					.word	UnaryAsc                 ; $8f asc
>19f3	f0 09					.word	CommandAssert            ; $90 assert
>19f5	31 0a					.word	Unary16Bin               ; $91 bin$
>19f7	5b 0a					.word	PrintCharacterX          ; $92 print.chr
>19f9	65 0a					.word	UnaryChr                 ; $93 chr$
>19fb	ca 0a					.word	CompareStrings           ; $94 s.cmp
>19fd	b6 0c					.word	CommandXFor              ; $95 for
>19ff	79 0d					.word	UnaryFre                 ; $96 fre
>1a01	91 0d					.word	CommandXGet              ; $97 get
>1a03	b7 0d					.word	CommandReturn            ; $98 return
>1a05	f9 0d					.word	Command_PSET             ; $99 pset
>1a07	13 0e					.word	Command_LINE             ; $9a line
>1a09	28 0e					.word	Command_RECT             ; $9b rect
>1a0b	37 0e					.word	Command_FRAME            ; $9c frame
>1a0d	46 0e					.word	Command_CHAR             ; $9d char
>1a0f	e3 0e					.word	Unary16Hex               ; $9e hex$
>1a11	8a 0f					.word	CommandXInput            ; $9f input
>1a13	a1 0f					.word	CommandInputString       ; $a0 input$
>1a15	ba 0f					.word	CommandInputReset        ; $a1 input.start
>1a17	9e 10					.word	UnaryLen                 ; $a2 len
>1a19	6a 11					.word	LinkFloatCompare         ; $a3 f.cmp
>1a1b	73 11					.word	LinkDivideInt32          ; $a4 int.div
>1a1d	08 12					.word	NegateTOS                ; $a5 negate
>1a1f	0f 12					.word	CommandNewLine           ; $a6 new.line
>1a21	18 12					.word	CommandXNext             ; $a7 next
>1a23	01 13					.word	NotTOS                   ; $a8 not
>1a25	18 13					.word	CommandXOn               ; $a9 on
>1a27	35 13					.word	CommandMoreOn            ; $aa moreon
>1a29	3c 13					.word	UnaryPeek                ; $ab peek
>1a2b	51 13					.word	UnaryPI                  ; $ac pi
>1a2d	5b 13					.word	CommandPOKE              ; $ad poke
>1a2f	73 13					.word	UnaryPos                 ; $ae pos
>1a31	7d 13					.word	GetChannel               ; $af getchannel
>1a33	88 13					.word	SetChannel               ; $b0 setchannel
>1a35	ab 13					.word	PrintNumber              ; $b1 print.n
>1a37	ca 13					.word	PrintString              ; $b2 print.s
>1a39	31 14					.word	CommandXRead             ; $b3 read
>1a3b	4b 14					.word	CommandReadString        ; $b4 read$
>1a3d	ec 15					.word	UnaryRND                 ; $b5 rnd
>1a3f	5b 16					.word	StringConcatenate        ; $b6 concat
>1a41	b2 16					.word	SignTOS                  ; $b7 sgn
>1a43	d5 16					.word	PrintTab                 ; $b8 print.tab
>1a45	e3 16					.word	PrintPos                 ; $b9 print.pos
>1a47	f4 16					.word	PrintSpace               ; $ba print.spc
>1a49	0d 17					.word	Unary_Str                ; $bb str$
>1a4b	88 17					.word	Unary_Left               ; $bc left$
>1a4d	98 17					.word	Unary_Right              ; $bd right$
>1a4f	b4 17					.word	Unary_Mid                ; $be mid$
>1a51	26 18					.word	CommandSwap              ; $bf swap
>1a53	9c 18					.word	TimeTOS                  ; $c0 ti
>1a55	a3 18					.word	TimeString               ; $c1 ti$
>1a57	79 19					.word	UnaryUsr                 ; $c2 usr
>1a59	85 19					.word	ValUnary                 ; $c3 val
>1a5b	f0 1b					.word	CommandClose             ; $c4 close
>1a5d	02 1c					.word	CommandExit              ; $c5 exit
>1a5f	08 1c					.word	CommandDebug             ; $c6 debug
>1a61	6e 1c					.word	CommandXOpen             ; $c7 open
>1a63	02 1d					.word	CommandScreen            ; $c8 screen
>1a65	e6 1e					.word	CommandVPOKE             ; $c9 vpoke
>1a67	0b 1f					.word	CommandVPEEK             ; $ca vpeek
>1a69	cd 16					.word	CommandShift             ; $cb .shift
>1a6b	9e 08					.word	PushByteCommand          ; $cc .byte
>1a6d	b1 08					.word	PushWordCommand          ; $cd .word
>1a6f	ed 13					.word	CommandPushN             ; $ce .float
>1a71	13 14					.word	CommandPushS             ; $cf .string
>1a73	52 0b					.word	CommandXData             ; $d0 .data
>1a75	c8 0d					.word	CommandXGoto             ; $d1 .goto
>1a77	ab 0d					.word	CommandXGosub            ; $d2 .gosub
>1a79	dd 0d					.word	CommandGotoZ             ; $d3 .goto.z
>1a7b	eb 0d					.word	CommandGotoNZ            ; $d4 .goto.nz
>1a7d	e0 08					.word	CommandVarSpace          ; $d5 .varspace
>1a7f	c4 15					.word	CommandRestoreX          ; $d6 .restore
.1a81					ShiftVectorTable:
>1a81	7d 0a					.word	CommandClr               ; $cb80 clr
>1a83	5b 0b					.word	CommandXDIM              ; $cb81 dim
>1a85	4c 0c					.word	CommandEnd               ; $cb82 end
>1a87	6f 10					.word	UnaryJoy                 ; $cb83 joy
>1a89	16 11					.word	LinkFloatIntegerPartDown ; $cb84 int
>1a8b	1f 11					.word	LinkFloatSquareRoot      ; $cb85 sqr
>1a8d	30 11					.word	LinkFloatLogarithm       ; $cb86 log
>1a8f	3b 11					.word	LinkFloatExponent        ; $cb87 exp
>1a91	44 11					.word	LinkFloatCosine          ; $cb88 cos
>1a93	4d 11					.word	LinkFloatSine            ; $cb89 sin
>1a95	56 11					.word	LinkFloatTangent         ; $cb8a tan
>1a97	5f 11					.word	LinkFloatArcTan          ; $cb8b atn
>1a99	9d 11					.word	XCommandMouse            ; $cb8c mouse
>1a9b	b2 11					.word	XUnaryMB                 ; $cb8d mb
>1a9d	bf 11					.word	XUnaryMX                 ; $cb8e mx
>1a9f	d0 11					.word	XUnaryMY                 ; $cb8f my
>1aa1	e1 11					.word	XUnaryMWheel             ; $cb90 mwheel
>1aa3	09 17					.word	CommandStop              ; $cb91 stop
>1aa5	66 18					.word	CommandSYS               ; $cb92 sys
>1aa7	0e 19					.word	CommandTIWrite           ; $cb93 ti$.write
>1aa9	df 1a					.word	CommandXWAIT             ; $cb94 wait
>1aab	33 1c					.word	X16I2CPoke               ; $cb95 i2cpoke
>1aad	53 1c					.word	X16I2CPeek               ; $cb96 i2cpeek
>1aaf	be 1c					.word	CommandBank              ; $cb97 bank
>1ab1	11 1d					.word	XCommandSleep            ; $cb98 sleep
>1ab3	35 1d					.word	X16_Audio_FMINIT         ; $cb99 fminit
>1ab5	43 1d					.word	X16_Audio_FMNOTE         ; $cb9a fmnote
>1ab7	55 1d					.word	X16_Audio_FMDRUM         ; $cb9b fmdrum
>1ab9	67 1d					.word	X16_Audio_FMINST         ; $cb9c fminst
>1abb	79 1d					.word	X16_Audio_FMVIB          ; $cb9d fmvib
>1abd	8b 1d					.word	X16_Audio_FMFREQ         ; $cb9e fmfreq
>1abf	9c 1d					.word	X16_Audio_FMVOL          ; $cb9f fmvol
>1ac1	ae 1d					.word	X16_Audio_FMPAN          ; $cba0 fmpan
>1ac3	c0 1d					.word	X16_Audio_FMPLAY         ; $cba1 fmplay
>1ac5	d1 1d					.word	X16_Audio_FMCHORD        ; $cba2 fmchord
>1ac7	e2 1d					.word	X16_Audio_FMPOKE         ; $cba3 fmpoke
>1ac9	f4 1d					.word	X16_Audio_PSGINIT        ; $cba4 psginit
>1acb	02 1e					.word	X16_Audio_PSGNOTE        ; $cba5 psgnote
>1acd	14 1e					.word	X16_Audio_PSGVOL         ; $cba6 psgvol
>1acf	26 1e					.word	X16_Audio_PSGWAV         ; $cba7 psgwav
>1ad1	38 1e					.word	X16_Audio_PSGFREQ        ; $cba8 psgfreq
>1ad3	49 1e					.word	X16_Audio_PSGPAN         ; $cba9 psgpan
>1ad5	5b 1e					.word	X16_Audio_PSGPLAY        ; $cbaa psgplay
>1ad7	6c 1e					.word	X16_Audio_PSGCHORD       ; $cbab psgchord
>1ad9	7d 1e					.word	CommandCls               ; $cbac cls
>1adb	86 1e					.word	CommandLocate            ; $cbad locate
>1add	ad 1e					.word	CommandColor             ; $cbae color
.1adf					CommandXWAIT:
.1adf	fa		plx				plx
.1ae0	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1ae2	85 2c		sta $2c				sta 	zTemp0
.1ae4	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1ae6	85 2d		sta $2d				sta 	zTemp0+1
.1ae8					_WaitLoop:
.1ae8	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1aea	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1aec	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1aee	f0 f8		beq $1ae8			beq 	_WaitLoop 					; keep going if zero
.1af0	ca		dex				dex 								; drop 3.
.1af1	ca		dex				dex
.1af2	ca		dex				dex
.1af3	4c 4f 08	jmp $084f			jmp 	NextCommand
.1af6					WriteFloatCommand:
.1af6	fa		plx				plx
.1af7	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1af9	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1afb	88		dey				dey 								; get the upper 3 bits
.1afc	b1 28		lda ($28),y			lda 	(codePtr),y
.1afe	29 07		and #$07			and 	#7
.1b00	c8		iny				iny
.1b01	c8		iny				iny
.1b02	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b04	2a		rol a				rol 	a 							; carry will be clear.
.1b05	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b08	85 2d		sta $2d				sta 	zTemp0+1
.1b0a	20 10 1b	jsr $1b10			jsr 	WriteFloatZTemp0Sub
.1b0d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b10					WriteFloatZTemp0Sub:
.1b10	5a		phy				phy 								; ldart write
.1b11	a0 01		ldy #$01			ldy 	#1
.1b13	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b15	92 2c		sta ($2c)			sta 	(zTemp0)
.1b17	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b19	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b1b	c8		iny				iny
.1b1c	b5 56		lda $56,x			lda 	NSMantissa2,x
.1b1e	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b20	c8		iny				iny
.1b21	b5 62		lda $62,x			lda 	NSMantissa3,x
.1b23	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b25	c8		iny				iny
.1b26	b5 6e		lda $6e,x			lda 	NSExponent,x
.1b28	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b2a	c8		iny				iny
.1b2b	b5 32		lda $32,x			lda 	NSStatus,x
.1b2d	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b2f	ca		dex				dex
.1b30	7a		ply				ply
.1b31	60		rts				rts
.1b32					WriteIntegerCommand:
.1b32	fa		plx				plx
.1b33	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b35	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b37	88		dey				dey 								; get the upper 3 bits
.1b38	b1 28		lda ($28),y			lda 	(codePtr),y
.1b3a	29 07		and #$07			and 	#7
.1b3c	c8		iny				iny
.1b3d	c8		iny				iny
.1b3e	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b40	2a		rol a				rol 	a 							; carry will be clear.
.1b41	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b44	85 2d		sta $2d				sta 	zTemp0+1
.1b46	20 4c 1b	jsr $1b4c			jsr 	WriteIntegerZTemp0Sub
.1b49	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b4c					WriteIntegerZTemp0Sub:
.1b4c	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.1b4f	5a		phy				phy 								; start write
.1b50	a0 01		ldy #$01			ldy 	#1
.1b52	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1b54	30 0b		bmi $1b61			bmi 	_WIZNegative
.1b56	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1b58	92 2c		sta ($2c)			sta 	(zTemp0)
.1b5a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b5c	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b5e	7a		ply				ply
.1b5f	ca		dex				dex
.1b60	60		rts				rts
.1b61					_WIZNegative:
.1b61	38		sec				sec 								; -ve read
.1b62	a9 00		lda #$00			lda 	#0
.1b64	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1b66	92 2c		sta ($2c)			sta 	(zTemp0)
.1b68	a9 00		lda #$00			lda 	#0
.1b6a	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1b6c	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b6e	7a		ply				ply
.1b6f	ca		dex				dex
.1b70	60		rts				rts
.1b71					WriteStringCommand:
.1b71	fa		plx				plx
.1b72	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b74	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b76	88		dey				dey 								; get the upper 3 bits
.1b77	b1 28		lda ($28),y			lda 	(codePtr),y
.1b79	29 07		and #$07			and 	#7
.1b7b	c8		iny				iny
.1b7c	c8		iny				iny
.1b7d	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b7f	2a		rol a				rol 	a 							; carry will be clear.
.1b80	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b83	85 2d		sta $2d				sta 	zTemp0+1
.1b85	20 8b 1b	jsr $1b8b			jsr 	WriteStringZTemp0Sub
.1b88	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b8b					WriteStringZTemp0Sub:
.1b8b	5a		phy				phy
.1b8c	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b8e	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b90	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b92	f0 1e		beq $1bb2			beq 	_WSConcrete
.1b94	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b96	85 2e		sta $2e				sta 	zTemp1
.1b98	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b9a	85 2f		sta $2f				sta 	zTemp1+1
.1b9c	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b9e	85 30		sta $30				sta 	zTemp2
.1ba0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ba2	85 31		sta $31				sta 	zTemp2+1
.1ba4	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1ba6	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1ba8	b0 17		bcs $1bc1			bcs 	_WSCopy
.1baa	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1bac	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1bae	09 80		ora #$80			ora 	#$80
.1bb0	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1bb2					_WSConcrete:
.1bb2	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1bb4	a8		tay				tay
.1bb5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1bb7	20 0c 0b	jsr $0b0c			jsr 	StringConcrete
.1bba	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1bbc	98		tya				tya
.1bbd	a0 01		ldy #$01			ldy 	#1
.1bbf	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1bc1					_WSCopy
.1bc1	18		clc				clc  								; copy target+2 to zTemp2
.1bc2	b2 2c		lda ($2c)			lda 	(zTemp0)
.1bc4	69 02		adc #$02			adc 	#2
.1bc6	85 30		sta $30				sta 	zTemp2
.1bc8	a0 01		ldy #$01			ldy 	#1
.1bca	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1bcc	69 00		adc #$00			adc 	#0
.1bce	85 31		sta $31				sta 	zTemp2+1
.1bd0	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1bd2	85 2e		sta $2e				sta 	zTemp1
.1bd4	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1bd6	85 2f		sta $2f				sta 	zTemp1+1
.1bd8	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1bda	a8		tay				tay
.1bdb					_WSCopyLoop:
.1bdb	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1bdd	91 30		sta ($30),y			sta 	(zTemp2),y
.1bdf	88		dey				dey
.1be0	c0 ff		cpy #$ff			cpy 	#$FF
.1be2	d0 f7		bne $1bdb			bne 	_WSCopyLoop
.1be4	ca		dex				dex
.1be5	7a		ply				ply
.1be6	60		rts				rts
.1be7					XCheckStop:
.1be7	20 e1 ff	jsr $ffe1			jsr 	$FFE1 						; check stop
.1bea	f0 01		beq $1bed			beq 	_XCSStop
.1bec	60		rts				rts
.1bed					_XCSStop:
.1bed	4c 68 20	jmp $2068		jmp	ErrorV_break
.1bf0					CommandClose:
.1bf0	fa		plx				plx
.1bf1	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; channel to close
.1bf4	cd 5f 04	cmp $045f			cmp 	currentChannel 				; is it the current channel
.1bf7	d0 03		bne $1bfc			bne 	_CCNotCurrent
.1bf9	9c 5f 04	stz $045f			stz 	currentChannel 				; effectively disables CMD
.1bfc					_CCNotCurrent:
.1bfc	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1bff	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c02					CommandExit:
.1c02	fa		plx				plx
.1c03	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1c05	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1c08					CommandDebug:
.1c08	fa		plx				plx
>1c09	db						.byte 	$DB 						; causes a break in the emulator
.1c0a	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c0d					XGetCharacterFromChannel:
.1c0d	da		phx				phx
.1c0e	5a		phy				phy
.1c0f	e0 00		cpx #$00			cpx 	#0 							; is it default
.1c11	d0 05		bne $1c18			bne 	_XGetChannel
.1c13	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1c16	80 08		bra $1c20			bra 	_XGetChar
.1c18					_XGetChannel:
.1c18	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1c1b	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1c1e	d0 06		bne $1c26			bne 	_XGCError
.1c20					_XGetChar:
.1c20	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1c23	7a		ply				ply
.1c24	fa		plx				plx
.1c25	60		rts				rts
.1c26					_XGCError:
.1c26	4c 52 20	jmp $2052		jmp	ErrorV_channel
.1c29					XGetHPos:
.1c29	da		phx				phx
.1c2a	5a		phy				phy
.1c2b	38		sec				sec
.1c2c	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1c2f	98		tya				tya
.1c30	7a		ply				ply
.1c31	fa		plx				plx
.1c32	60		rts				rts
.1c33					X16I2CPoke:
.1c33	fa		plx				plx
.1c34	5a		phy				phy
.1c35	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; value
.1c38	48		pha				pha
.1c39	ca		dex				dex
.1c3a	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; register
.1c3d	48		pha				pha
.1c3e	ca		dex				dex
.1c3f	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; device
.1c42	aa		tax				tax
.1c43	7a		ply				ply
.1c44	68		pla				pla
.1c45	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1c48	b0 06		bcs $1c50			bcs 	X16I2CError
.1c4a	7a		ply				ply
.1c4b	a2 ff		ldx #$ff			ldx 	#$FF
.1c4d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c50					X16I2CError:
.1c50	4c 52 20	jmp $2052		jmp	ErrorV_channel
.1c53					X16I2CPeek:
.1c53	fa		plx				plx
.1c54	da		phx				phx
.1c55	5a		phy				phy
.1c56	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; register
.1c59	48		pha				pha
.1c5a	ca		dex				dex
.1c5b	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; device
.1c5e	aa		tax				tax 								; X device
.1c5f	7a		ply				ply 								; Y register
.1c60	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1c63	b0 eb		bcs $1c50			bcs 	X16I2CError
.1c65	7a		ply				ply 								; restore Y/X
.1c66	fa		plx				plx
.1c67	ca		dex				dex 								; drop TOS (register)
.1c68	20 ad 26	jsr $26ad			jsr 	FloatSetByte 				; write read value to TOS.
.1c6b	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c6e					CommandXOpen:
.1c6e	fa		plx				plx
.1c6f	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1c71	85 2c		sta $2c				sta 	zTemp0
.1c73	aa		tax				tax
.1c74	a5 4d		lda $4d				lda 	NSMantissa1+3
.1c76	85 2d		sta $2d				sta 	zTemp0+1
.1c78	a8		tay				tay
.1c79	e8		inx				inx 								; XY points to first character
.1c7a	d0 01		bne $1c7d			bne 	_CONoCarry
.1c7c	c8		iny				iny
.1c7d					_CONoCarry:
.1c7d	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c7f	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c82	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c84	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c86	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c88	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c8b	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c8e	b0 03		bcs $1c93			bcs 	_COError
.1c90	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c93					_COError:
.1c93	4c 52 20	jmp $2052		jmp	ErrorV_channel
.1c96					XPokeMemory:
.1c96	86 2c		stx $2c				stx 	zTemp0
.1c98	84 2d		sty $2d				sty 	zTemp0+1
.1c9a	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c9c	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c9f	e0 ff		cpx #$ff			cpx 	#$FF
.1ca1	f0 02		beq $1ca5			beq 	_XPMNoSwitch
.1ca3	86 00		stx $00				stx 	SelectRAMBank
.1ca5					_XPMNoSwitch:
.1ca5	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1ca7	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1ca9					_XPMExit:
.1ca9	60		rts				rts
.1caa					XPeekMemory:
.1caa	86 2c		stx $2c				stx 	zTemp0
.1cac	84 2d		sty $2d				sty 	zTemp0+1
.1cae	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1cb0	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1cb3	e0 ff		cpx #$ff			cpx 	#$FF
.1cb5	f0 02		beq $1cb9			beq 	_XPMNoSwitch
.1cb7	86 00		stx $00				stx 	SelectRAMBank
.1cb9					_XPMNoSwitch:
.1cb9	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1cbb	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1cbd	60		rts				rts
.1cbe					CommandBank:
.1cbe	fa		plx				plx
.1cbf	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1cc1	8d 6d 05	sta $056d			sta 	ramBank 					; store & make current
.1cc4	85 00		sta $00				sta 	SelectRAMBank
.1cc6	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1cc8	c9 ff		cmp #$ff			cmp 	#$FF
.1cca	f0 03		beq $1ccf			beq 	_CBNoUpdate
.1ccc	8d 6e 05	sta $056e			sta 	romBank 					; this doesn't set the hardware page.
.1ccf					_CBNoUpdate:
.1ccf	a2 ff		ldx #$ff			ldx 	#$FF
.1cd1	4c 4f 08	jmp $084f			jmp 	NextCommand
.056d					ramBank:
>056d							.fill 	1
.056e					romBank:
>056e							.fill 	1
.1cd4					XPrintCharacterToChannel:
.1cd4	48		pha				pha
.1cd5	da		phx				phx
.1cd6	5a		phy				phy
.1cd7	48		pha				pha  								; save char
.1cd8	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1cda	d0 05		bne $1ce1			bne 	_XPCNotDefault
.1cdc	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1cdf	80 08		bra $1ce9			bra 	_XPCSend
.1ce1					_XPCNotDefault:
.1ce1	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1ce4	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1ce7	d0 08		bne $1cf1			bne 	_XPCError
.1ce9					_XPCSend:
.1ce9	68		pla				pla 								; restore character
.1cea	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1ced	7a		ply				ply
.1cee	fa		plx				plx
.1cef	68		pla				pla
.1cf0	60		rts				rts
.1cf1					_XPCError:
.1cf1	4c 52 20	jmp $2052		jmp	ErrorV_channel
.1cf4					XReadClock:
.1cf4	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1cf7	60		rts				rts
.1cf8					XWriteClock:
.1cf8	48		pha				pha
.1cf9	da		phx				phx
.1cfa	5a		phy				phy
.1cfb	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1cfe	7a		ply				ply
.1cff	fa		plx				plx
.1d00	68		pla				pla
.1d01	60		rts				rts
.1d02					CommandScreen:
.1d02	fa		plx				plx
.1d03	da		phx				phx
.1d04	5a		phy				phy
.1d05	20 47 10	jsr $1047			jsr 	GetInteger8Bit
.1d08	18		clc				clc
.1d09	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1d0c	7a		ply				ply
.1d0d	fa		plx				plx
.1d0e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d11					XCommandSleep:
.1d11	fa		plx				plx
.1d12	5a		phy				phy
.1d13	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.1d16	ca		dex				dex
.1d17	20 f4 1c	jsr $1cf4			jsr 	XReadClock 					; read clock to YXA
.1d1a	18		clc				clc 								; calculate end time in zTemp0
.1d1b	65 3e		adc $3e				adc 	NSMantissa0
.1d1d	85 2c		sta $2c				sta 	zTemp0
.1d1f	8a		txa				txa
.1d20	65 4a		adc $4a				adc 	NSMantissa1
.1d22	85 2d		sta $2d				sta 	zTemp0+1
.1d24					_XCWait:
.1d24	20 f4 1c	jsr $1cf4			jsr 	XReadClock 					; and wait for it.
.1d27	c5 2c		cmp $2c				cmp 	zTemp0
.1d29	d0 f9		bne $1d24			bne 	_XCWait
.1d2b	e4 2d		cpx $2d				cpx 	zTemp0+1
.1d2d	d0 f5		bne $1d24			bne 	_XCWait
.1d2f	a2 ff		ldx #$ff			ldx 	#$FF
.1d31	7a		ply				ply
.1d32	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d35					X16_Audio_FMINIT:
.1d35	fa		plx				plx
.1d36	5a		phy			phy
.1d37	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d3a	63 c0					.word	X16A_ym_init
>1d3c	0a					.byte	X16_AudioCodeBank
.1d3d	a2 ff		ldx #$ff		ldx	#$FF
.1d3f	7a		ply			ply
.1d40	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d43					X16_Audio_FMNOTE:
.1d43	fa		plx				plx
.1d44	5a		phy			phy
.1d45	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d48	18		clc			clc
.1d49	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d4c	03 c0					.word	X16A_bas_fmnote
>1d4e	0a					.byte	X16_AudioCodeBank
.1d4f	a2 ff		ldx #$ff		ldx	#$FF
.1d51	7a		ply			ply
.1d52	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d55					X16_Audio_FMDRUM:
.1d55	fa		plx				plx
.1d56	5a		phy			phy
.1d57	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d5a	18		clc			clc
.1d5b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d5e	6f c0					.word	X16A_ym_playdrum
>1d60	0a					.byte	X16_AudioCodeBank
.1d61	a2 ff		ldx #$ff		ldx	#$FF
.1d63	7a		ply			ply
.1d64	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d67					X16_Audio_FMINST:
.1d67	fa		plx				plx
.1d68	5a		phy			phy
.1d69	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d6c	38		sec			sec
.1d6d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d70	69 c0					.word	X16A_ym_loadpatch
>1d72	0a					.byte	X16_AudioCodeBank
.1d73	a2 ff		ldx #$ff		ldx	#$FF
.1d75	7a		ply			ply
.1d76	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d79					X16_Audio_FMVIB:
.1d79	fa		plx				plx
.1d7a	5a		phy			phy
.1d7b	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d7e	18		clc			clc
.1d7f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d82	09 c0					.word	X16A_bas_fmvib
>1d84	0a					.byte	X16_AudioCodeBank
.1d85	a2 ff		ldx #$ff		ldx	#$FF
.1d87	7a		ply			ply
.1d88	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d8b					X16_Audio_FMFREQ:
.1d8b	fa		plx				plx
.1d8c	5a		phy			phy
.1d8d	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1d90	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d93	00 c0					.word	X16A_bas_fmfreq
>1d95	0a					.byte	X16_AudioCodeBank
.1d96	a2 ff		ldx #$ff		ldx	#$FF
.1d98	7a		ply			ply
.1d99	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d9c					X16_Audio_FMVOL:
.1d9c	fa		plx				plx
.1d9d	5a		phy			phy
.1d9e	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1da1	18		clc			clc
.1da2	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1da5	75 c0					.word	X16A_ym_setatten
>1da7	0a					.byte	X16_AudioCodeBank
.1da8	a2 ff		ldx #$ff		ldx	#$FF
.1daa	7a		ply			ply
.1dab	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dae					X16_Audio_FMPAN:
.1dae	fa		plx				plx
.1daf	5a		phy			phy
.1db0	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1db3	18		clc			clc
.1db4	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1db7	7e c0					.word	X16A_ym_setpan
>1db9	0a					.byte	X16_AudioCodeBank
.1dba	a2 ff		ldx #$ff		ldx	#$FF
.1dbc	7a		ply			ply
.1dbd	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dc0					X16_Audio_FMPLAY:
.1dc0	fa		plx				plx
.1dc1	5a		phy			phy
.1dc2	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1dc5	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dc8	06 c0					.word	X16A_bas_fmplaystring
>1dca	0a					.byte	X16_AudioCodeBank
.1dcb	a2 ff		ldx #$ff		ldx	#$FF
.1dcd	7a		ply			ply
.1dce	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dd1					X16_Audio_FMCHORD:
.1dd1	fa		plx				plx
.1dd2	5a		phy			phy
.1dd3	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1dd6	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dd9	8d c0					.word	X16A_bas_fmchordstring
>1ddb	0a					.byte	X16_AudioCodeBank
.1ddc	a2 ff		ldx #$ff		ldx	#$FF
.1dde	7a		ply			ply
.1ddf	4c 4f 08	jmp $084f			jmp 	NextCommand
.1de2					X16_Audio_FMPOKE:
.1de2	fa		plx				plx
.1de3	5a		phy			phy
.1de4	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1de7	18		clc			clc
.1de8	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1deb	8a c0					.word	X16A_ym_write
>1ded	0a					.byte	X16_AudioCodeBank
.1dee	a2 ff		ldx #$ff		ldx	#$FF
.1df0	7a		ply			ply
.1df1	4c 4f 08	jmp $084f			jmp 	NextCommand
.1df4					X16_Audio_PSGINIT:
.1df4	fa		plx				plx
.1df5	5a		phy			phy
.1df6	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1df9	4b c0					.word	X16A_psg_init
>1dfb	0a					.byte	X16_AudioCodeBank
.1dfc	a2 ff		ldx #$ff		ldx	#$FF
.1dfe	7a		ply			ply
.1dff	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e02					X16_Audio_PSGNOTE:
.1e02	fa		plx				plx
.1e03	5a		phy			phy
.1e04	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e07	18		clc			clc
.1e08	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e0b	12 c0					.word	X16A_bas_psgnote
>1e0d	0a					.byte	X16_AudioCodeBank
.1e0e	a2 ff		ldx #$ff		ldx	#$FF
.1e10	7a		ply			ply
.1e11	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e14					X16_Audio_PSGVOL:
.1e14	fa		plx				plx
.1e15	5a		phy			phy
.1e16	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e19	18		clc			clc
.1e1a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e1d	54 c0					.word	X16A_psg_setatten
>1e1f	0a					.byte	X16_AudioCodeBank
.1e20	a2 ff		ldx #$ff		ldx	#$FF
.1e22	7a		ply			ply
.1e23	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e26					X16_Audio_PSGWAV:
.1e26	fa		plx				plx
.1e27	5a		phy			phy
.1e28	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e2b	18		clc			clc
.1e2c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e2f	15 c0					.word	X16A_bas_psgwav
>1e31	0a					.byte	X16_AudioCodeBank
.1e32	a2 ff		ldx #$ff		ldx	#$FF
.1e34	7a		ply			ply
.1e35	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e38					X16_Audio_PSGFREQ:
.1e38	fa		plx				plx
.1e39	5a		phy			phy
.1e3a	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1e3d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e40	0f c0					.word	X16A_bas_psgfreq
>1e42	0a					.byte	X16_AudioCodeBank
.1e43	a2 ff		ldx #$ff		ldx	#$FF
.1e45	7a		ply			ply
.1e46	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e49					X16_Audio_PSGPAN:
.1e49	fa		plx				plx
.1e4a	5a		phy			phy
.1e4b	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e4e	18		clc			clc
.1e4f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e52	5a c0					.word	X16A_psg_setpan
>1e54	0a					.byte	X16_AudioCodeBank
.1e55	a2 ff		ldx #$ff		ldx	#$FF
.1e57	7a		ply			ply
.1e58	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e5b					X16_Audio_PSGPLAY:
.1e5b	fa		plx				plx
.1e5c	5a		phy			phy
.1e5d	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e60	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e63	18 c0					.word	X16A_bas_psgplaystring
>1e65	0a					.byte	X16_AudioCodeBank
.1e66	a2 ff		ldx #$ff		ldx	#$FF
.1e68	7a		ply			ply
.1e69	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e6c					X16_Audio_PSGCHORD:
.1e6c	fa		plx				plx
.1e6d	5a		phy			phy
.1e6e	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e71	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e74	90 c0					.word	X16A_bas_psgchordstring
>1e76	0a					.byte	X16_AudioCodeBank
.1e77	a2 ff		ldx #$ff		ldx	#$FF
.1e79	7a		ply			ply
.1e7a	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e7d					CommandCls:
.1e7d	fa		plx				plx
.1e7e	a9 93		lda #$93			lda 	#147
.1e80	20 d4 1c	jsr $1cd4			jsr 	XPrintCharacterToChannel
.1e83	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e86					CommandLocate:
.1e86	fa		plx				plx
.1e87	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.1e8a	ca		dex				dex
.1e8b	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.1e8e	ca		dex				dex
.1e8f	48		pha				pha 								; save registers
.1e90	da		phx				phx
.1e91	5a		phy				phy
.1e92	18		clc				clc
.1e93	a4 3f		ldy $3f				ldy 	NSMantissa0+1 				; get coords
.1e95	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e97	88		dey				dey 								; fix up
.1e98	ca		dex				dex
.1e99	20 f0 ff	jsr $fff0			jsr 	$FFF0 						; PLOT
.1e9c	7a		ply				ply 								; restore registers
.1e9d	fa		plx				plx
.1e9e	68		pla				pla
.1e9f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ea2					_CLOutputXA:
.1ea2	ca		dex				dex
.1ea3	f0 07		beq $1eac			beq 	_CLOExit
.1ea5	30 05		bmi $1eac			bmi 	_CLOExit
.1ea7	20 d4 1c	jsr $1cd4			jsr 	XPrintCharacterToChannel
.1eaa	80 f6		bra $1ea2			bra 	_CLOutputXA
.1eac					_CLOExit:
.1eac	60		rts				rts
.1ead					CommandColor:
.1ead	fa		plx				plx
.1eae	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.1eb1	ca		dex				dex
.1eb2	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.1eb5	ca		dex				dex
.1eb6	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1eb8	c9 ff		cmp #$ff			cmp 	#$FF
.1eba	f0 08		beq $1ec4			beq 	_CCNoBGR 					; if so, change background
.1ebc	20 cc 1e	jsr $1ecc			jsr 	_CCSetColour
.1ebf	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1ec1	20 d4 1c	jsr $1cd4			jsr 	XPrintCharacterToChannel
.1ec4					_CCNoBGR:
.1ec4	a5 3e		lda $3e				lda 	NSMantissa0
.1ec6	20 cc 1e	jsr $1ecc			jsr 	_CCSetColour
.1ec9	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ecc					_CCSetColour:
.1ecc	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1ece	aa		tax				tax
.1ecf	bd d6 1e	lda $1ed6,x			lda 	_CCCommandTable,x
.1ed2	20 d4 1c	jsr $1cd4			jsr 	XPrintCharacterToChannel
.1ed5	60		rts				rts
.1ed6					_CCCommandTable:
>1ed6	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1ede	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1ee6					CommandVPOKE:
.1ee6	fa		plx				plx
.1ee7	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; poke value
.1eea	48		pha				pha
.1eeb	ca		dex				dex
.1eec	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.1eef	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ef1	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1ef4	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ef6	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ef9	ca		dex				dex
.1efa	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.1efd	20 47 10	jsr $1047			jsr 	GetInteger8Bit
.1f00	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1f03	ca		dex				dex
.1f04	68		pla				pla 								; poke value back
.1f05	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1f08	4c 4f 08	jmp $084f			jmp 	NextCommand
.1f0b					CommandVPEEK:
.1f0b	fa		plx				plx
.1f0c	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.1f0f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1f11	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1f14	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1f16	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1f19	ca		dex				dex
.1f1a	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.1f1d	20 47 10	jsr $1047			jsr 	GetInteger8Bit
.1f20	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1f23	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1f26	20 ad 26	jsr $26ad			jsr 	FloatSetByte 				; return as byte
.1f29	4c 4f 08	jmp $084f			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ff					C64_PI                   = $ff ; $ff pi
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ceb7					C64_BANNER               = $ceb7 ; $ceb7 banner
=$ceb8					C64_EXEC                 = $ceb8 ; $ceb8 exec
=$ceb9					C64_TILE                 = $ceb9 ; $ceb9 tile
=$ceba					C64_EDIT                 = $ceba ; $ceba edit
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$cedb					C64_MWHEEL               = $cedb ; $cedb mwheel
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$cb					PCD_ENDCOMMAND = $cb
=$cb					PCD_STARTSYSTEM = $cb
=$d7					PCD_ENDSYSTEM = $d7
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_PI               = $ac ; pi
=$ad					PCD_POKE             = $ad ; poke
=$ae					PCD_POS              = $ae ; pos
=$af					PCD_GETCHANNEL       = $af ; getchannel
=$b0					PCD_SETCHANNEL       = $b0 ; setchannel
=$b1					PCD_PRINTCMD_N       = $b1 ; print.n
=$b2					PCD_PRINTCMD_S       = $b2 ; print.s
=$b3					PCD_READ             = $b3 ; read
=$b4					PCD_READDOLLAR       = $b4 ; read$
=$b5					PCD_RND              = $b5 ; rnd
=$b6					PCD_CONCAT           = $b6 ; concat
=$b7					PCD_SGN              = $b7 ; sgn
=$b8					PCD_PRINTCMD_TAB     = $b8 ; print.tab
=$b9					PCD_PRINTCMD_POS     = $b9 ; print.pos
=$ba					PCD_PRINTCMD_SPC     = $ba ; print.spc
=$bb					PCD_STRDOLLAR        = $bb ; str$
=$bc					PCD_LEFTDOLLAR       = $bc ; left$
=$bd					PCD_RIGHTDOLLAR      = $bd ; right$
=$be					PCD_MIDDOLLAR        = $be ; mid$
=$bf					PCD_SWAP             = $bf ; swap
=$c0					PCD_TI               = $c0 ; ti
=$c1					PCD_TIDOLLAR         = $c1 ; ti$
=$c2					PCD_USR              = $c2 ; usr
=$c3					PCD_VAL              = $c3 ; val
=$c4					PCD_CLOSE            = $c4 ; close
=$c5					PCD_EXIT             = $c5 ; exit
=$c6					PCD_DEBUG            = $c6 ; debug
=$c7					PCD_OPEN             = $c7 ; open
=$c8					PCD_SCREEN           = $c8 ; screen
=$c9					PCD_VPOKE            = $c9 ; vpoke
=$ca					PCD_VPEEK            = $ca ; vpeek
=$cb					PCD_CMD_SHIFT        = $cb ; .shift
=$cc					PCD_CMD_BYTE         = $cc ; .byte
=$cd					PCD_CMD_WORD         = $cd ; .word
=$ce					PCD_CMD_FLOAT        = $ce ; .float
=$cf					PCD_CMD_STRING       = $cf ; .string
=$d0					PCD_CMD_DATA         = $d0 ; .data
=$d1					PCD_CMD_GOTO         = $d1 ; .goto
=$d2					PCD_CMD_GOSUB        = $d2 ; .gosub
=$d3					PCD_CMD_GOTOCMD_Z    = $d3 ; .goto.z
=$d4					PCD_CMD_GOTOCMD_NZ   = $d4 ; .goto.nz
=$d5					PCD_CMD_VARSPACE     = $d5 ; .varspace
=$d6					PCD_CMD_RESTORE      = $d6 ; .restore
=$cb80					PCD_CLR              = $cb80 ; clr
=$cb81					PCD_DIM              = $cb81 ; dim
=$cb82					PCD_END              = $cb82 ; end
=$cb83					PCD_JOY              = $cb83 ; joy
=$cb84					PCD_INT              = $cb84 ; int
=$cb85					PCD_SQR              = $cb85 ; sqr
=$cb86					PCD_LOG              = $cb86 ; log
=$cb87					PCD_EXP              = $cb87 ; exp
=$cb88					PCD_COS              = $cb88 ; cos
=$cb89					PCD_SIN              = $cb89 ; sin
=$cb8a					PCD_TAN              = $cb8a ; tan
=$cb8b					PCD_ATN              = $cb8b ; atn
=$cb8c					PCD_MOUSE            = $cb8c ; mouse
=$cb8d					PCD_MB               = $cb8d ; mb
=$cb8e					PCD_MX               = $cb8e ; mx
=$cb8f					PCD_MY               = $cb8f ; my
=$cb90					PCD_MWHEEL           = $cb90 ; mwheel
=$cb91					PCD_STOP             = $cb91 ; stop
=$cb92					PCD_SYS              = $cb92 ; sys
=$cb93					PCD_TIDOLLARCMD_WRITE = $cb93 ; ti$.write
=$cb94					PCD_WAIT             = $cb94 ; wait
=$cb95					PCD_I2CPOKE          = $cb95 ; i2cpoke
=$cb96					PCD_I2CPEEK          = $cb96 ; i2cpeek
=$cb97					PCD_BANK             = $cb97 ; bank
=$cb98					PCD_SLEEP            = $cb98 ; sleep
=$cb99					PCD_FMINIT           = $cb99 ; fminit
=$cb9a					PCD_FMNOTE           = $cb9a ; fmnote
=$cb9b					PCD_FMDRUM           = $cb9b ; fmdrum
=$cb9c					PCD_FMINST           = $cb9c ; fminst
=$cb9d					PCD_FMVIB            = $cb9d ; fmvib
=$cb9e					PCD_FMFREQ           = $cb9e ; fmfreq
=$cb9f					PCD_FMVOL            = $cb9f ; fmvol
=$cba0					PCD_FMPAN            = $cba0 ; fmpan
=$cba1					PCD_FMPLAY           = $cba1 ; fmplay
=$cba2					PCD_FMCHORD          = $cba2 ; fmchord
=$cba3					PCD_FMPOKE           = $cba3 ; fmpoke
=$cba4					PCD_PSGINIT          = $cba4 ; psginit
=$cba5					PCD_PSGNOTE          = $cba5 ; psgnote
=$cba6					PCD_PSGVOL           = $cba6 ; psgvol
=$cba7					PCD_PSGWAV           = $cba7 ; psgwav
=$cba8					PCD_PSGFREQ          = $cba8 ; psgfreq
=$cba9					PCD_PSGPAN           = $cba9 ; psgpan
=$cbaa					PCD_PSGPLAY          = $cbaa ; psgplay
=$cbab					PCD_PSGCHORD         = $cbab ; psgchord
=$cbac					PCD_CLS              = $cbac ; cls
=$cbad					PCD_LOCATE           = $cbad ; locate
=$cbae					PCD_COLOR            = $cbae ; color
.1f2c					SetErrorHandler:
.1f2c	8c 70 05	sty $0570			sty 	ErrorHandlerVector+1
.1f2f	8e 6f 05	stx $056f			stx 	ErrorHandlerVector
.1f32	60		rts				rts
.1f33					CallErrorHandler:
.1f33	6c 6f 05	jmp ($056f)			jmp 	(ErrorHandlerVector)
.056f					ErrorHandlerVector:
>056f							.fill 	2
.1f36					ErrorV_range:
.1f36	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>1f39	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f41	41 4e 47 45 00
.1f46					ErrorV_value:
.1f46	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>1f49	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f51	45 00
.1f53					ErrorV_syntax:
.1f53	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>1f56	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f5e	52 52 4f 52 00
.1f63					ErrorV_type:
.1f63	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>1f66	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f6e	4d 41 54 43 48 00
.1f74					ErrorV_unimplemented:
.1f74	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>1f77	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f7f	45 4d 45 4e 54 45 44 00
.1f87					ErrorV_assert:
.1f87	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>1f8a	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f92	41 49 4c 00
.1f96					ErrorV_line:
.1f96	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>1f99	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1fa1	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1fad					ErrorV_internal:
.1fad	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>1fb0	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1fb8	20 45 52 52 4f 52 00
.1fbf					ErrorV_divzero:
.1fbf	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>1fc2	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fca	59 20 5a 45 52 4f 00
.1fd1					ErrorV_structure:
.1fd1	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>1fd4	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fdc	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fe8					ErrorV_stop:
.1fe8	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>1feb	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1ff3	53 54 4f 50 50 45 44 00
.1ffb					ErrorV_data:
.1ffb	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>1ffe	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>2006	41 54 41 00
.200a					ErrorV_undeclared:
.200a	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>200d	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>2015	41 52 52 41 59 00
.201b					ErrorV_redefine:
.201b	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>201e	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>2026	44 45 46 49 4e 45 44 00
.202e					ErrorV_index:
.202e	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>2031	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2039	59 20 49 4e 44 45 58 00
.2041					ErrorV_memory:
.2041	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>2044	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>204c	45 4d 4f 52 59 00
.2052					ErrorV_channel:
.2052	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>2055	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>205d	54 50 55 54 20 45 52 52 4f 52 00
.2068					ErrorV_break:
.2068	20 33 1f	jsr $1f33		jsr	CallErrorHandler
>206b	42 52 45 41 4b 20 50 52			.text	"BREAK PRESSED",0
>2073	45 53 53 45 44 00
.2079					MoveObjectForward:
.2079	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.207b	c9 ff		cmp #$ff			cmp 	#$FF
.207d	f0 36		beq $20b5			beq 	_MOFEnd
.207f	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.2081	90 24		bcc $20a7			bcc 	_MOFAdvance1 				; forward 1
.2083	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.2085	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2087	90 20		bcc $20a9			bcc 	_MOFAdvanceY
.2089	c9 cb		cmp #$cb			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.208b	90 1a		bcc $20a7			bcc 	_MOFAdvance1 				; forward 1
.208d	a8		tay				tay 								; read the size.
.208e	b9 f2 1f	lda $1ff2,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.2091	a8		tay				tay
.2092	c8		iny				iny 								; add 1 for the system token.
.2093	d0 14		bne $20a9			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2095	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2097	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2099	a8		tay				tay 								; into Y.
.209a	18		clc				clc
.209b	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.209d	69 02		adc #$02			adc 	#2
.209f	85 2a		sta $2a				sta 	objPtr
.20a1	90 02		bcc $20a5			bcc 	_MOFNoCarry1
.20a3	e6 2b		inc $2b				inc 	objPtr+1
.20a5					_MOFNoCarry1:
.20a5	80 02		bra $20a9			bra 	_MOFAdvanceY
.20a7					_MOFAdvance1:
.20a7	a0 01		ldy #$01			ldy 	#1
.20a9					_MOFAdvanceY:
.20a9	98		tya				tya 								; add Y to objPtr
.20aa	18		clc				clc
.20ab	65 2a		adc $2a				adc 	objPtr
.20ad	85 2a		sta $2a				sta 	objPtr
.20af	90 02		bcc $20b3			bcc 	_MOFNoCarry2
.20b1	e6 2b		inc $2b				inc 	objPtr+1
.20b3					_MOFNoCarry2:
.20b3	18		clc				clc 								; not completed.
.20b4	60		rts				rts
.20b5					_MOFEnd:
.20b5	e6 2a		inc $2a				inc 	objPtr
.20b7	d0 02		bne $20bb			bne 	_MOFENoCarry
.20b9	e6 2b		inc $2b				inc 	objPtr+1
.20bb					_MOFENoCarry:
.20bb	38		sec				sec
.20bc	60		rts				rts
.20bd					MOFSizeTable:
>20bd	01					.byte	1         	; $cb .shift
>20be	01					.byte	1         	; $cc .byte
>20bf	02					.byte	2         	; $cd .word
>20c0	05					.byte	5         	; $ce .float
>20c1	ff					.byte	255       	; $cf .string
>20c2	ff					.byte	255       	; $d0 .data
>20c3	02					.byte	2         	; $d1 .goto
>20c4	02					.byte	2         	; $d2 .gosub
>20c5	02					.byte	2         	; $d3 .goto.z
>20c6	02					.byte	2         	; $d4 .goto.nz
>20c7	02					.byte	2         	; $d5 .varspace
>20c8	02					.byte	2         	; $d6 .restore

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0571					numberBuffer:
>0571							.fill 	34
.20c9					FloatSubtract:
.20c9	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.20cb	49 80		eor #$80			eor 	#$80
.20cd	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.20cf					FloatAdd:
.20cf	ca		dex				dex
.20d0	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.20d2	15 6f		ora $6f,x			ora 	NSExponent+1,x
.20d4	15 62		ora $62,x			ora 	NSMantissa3,x
.20d6	15 63		ora $63,x			ora 	NSMantissa3+1,x
.20d8	d0 04		bne $20de			bne 	_FAUseFloat
.20da	20 6b 24	jsr $246b			jsr 	FloatInt32Add 				; use the int32 one.
.20dd	60		rts				rts
.20de					_FAUseFloat:
.20de	20 00 24	jsr $2400			jsr 	FloatNormalise 				; normalise S[X]
.20e1	f0 51		beq $2134			beq 	_FAReturn1
.20e3	e8		inx				inx 								; normalise S[X+1]
.20e4	20 00 24	jsr $2400			jsr 	FloatNormalise
.20e7	ca		dex				dex
.20e8	c9 00		cmp #$00			cmp 	#0
.20ea	f0 60		beq $214c			beq 	_FAExit 					; if so, just return A
.20ec	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20ee	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20f0	f0 18		beq $210a			beq 	_FAExponentsEqual
.20f2	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20f4	a8		tay				tay
.20f5	38		sec				sec 								; do a signed comparison of the exponents.
.20f6	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20f8	50 02		bvc $20fc			bvc 	_FANoSignedChange
.20fa	49 80		eor #$80			eor 	#$80
.20fc					_FANoSignedChange:
.20fc	29 80		and #$80			and 	#$80
.20fe	10 02		bpl $2102			bpl 	_FAHaveMax
.2100	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.2102					_FAHaveMax:
.2102	20 4d 21	jsr $214d			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.2105	e8		inx				inx
.2106	20 4d 21	jsr $214d			jsr 	_FAShiftToExponent
.2109	ca		dex				dex
.210a					_FAExponentsEqual:
.210a	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.210c	55 33		eor $33,x			eor 	NSStatus+1,x
.210e	30 0e		bmi $211e			bmi 	_FADifferentSigns
.2110	20 37 24	jsr $2437			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.2113	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.2115	10 35		bpl $214c			bpl 	_FAExit 					; if no, we are done.
.2117	20 c4 26	jsr $26c4			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.211a	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.211c	80 2e		bra $214c			bra 	_FAExit
.211e					_FADifferentSigns:
.211e	20 51 24	jsr $2451			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.2121	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.2123	10 06		bpl $212b			bpl 	_FACheckZero 				; if no, check for -0
.2125	20 6d 26	jsr $266d			jsr 	FloatNegate 					; netate result
.2128	20 74 26	jsr $2674			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.212b					_FACheckZero:
.212b	20 cd 26	jsr $26cd			jsr 	FloatIsZero	 				; check for -0
.212e	d0 1c		bne $214c			bne 	_FAExit
.2130	74 32		stz $32,x			stz 	NSStatus,x
.2132	80 18		bra $214c			bra 	_FAExit
.2134					_FAReturn1:
.2134	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.2136	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2138	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.213a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.213c	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.213e	95 56		sta $56,x			sta 	NSMantissa2,x
.2140	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.2142	95 62		sta $62,x			sta 	NSMantissa3,x
.2144	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.2146	95 6e		sta $6e,x			sta 	NSExponent,x
.2148	b5 33		lda $33,x			lda 	NSStatus+1,x
.214a	95 32		sta $32,x			sta 	NSStatus,x
.214c					_FAExit:
.214c	60		rts				rts
.214d					_FAShiftToExponent:
.214d					_FAShiftToExponent2:
.214d	98		tya				tya 								; compare Y to exponent
.214e	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2150	f0 07		beq $2159			beq 	_FASEExit 					; exit if so.
.2152	20 c4 26	jsr $26c4			jsr 	FloatShiftRight	 			; shift the mantissa right
.2155	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.2157	80 f4		bra $214d			bra 	_FAShiftToExponent2
.2159					_FASEExit:
.2159	60		rts				rts
.215a					CompareEqual:
.215a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.215c	d0 09		bne $2167			bne 	ReturnFalse
.215e					ReturnTrue:
.215e	a9 01		lda #$01			lda 	#1
.2160	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2162	a9 80		lda #$80			lda 	#$80
.2164	95 32		sta $32,x			sta 	NSStatus,x
.2166	60		rts				rts
.2167					ReturnFalse:
.2167	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2169	60		rts				rts
.216a					CompareNotEqual:
.216a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.216c	d0 f0		bne $215e			bne 	ReturnTrue
.216e	80 f7		bra $2167			bra 	ReturnFalse
.2170					CompareLess:
.2170	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2172	c9 ff		cmp #$ff			cmp 	#$FF
.2174	f0 e8		beq $215e			beq 	ReturnTrue
.2176	80 ef		bra $2167			bra 	ReturnFalse
.2178					CompareGreater:
.2178	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.217a	c9 01		cmp #$01			cmp 	#$01
.217c	f0 e0		beq $215e			beq 	ReturnTrue
.217e	80 e7		bra $2167			bra 	ReturnFalse
.2180					CompareLessEqual:
.2180	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2182	c9 01		cmp #$01			cmp 	#$01
.2184	d0 d8		bne $215e			bne 	ReturnTrue
.2186	80 df		bra $2167			bra 	ReturnFalse
.2188					CompareGreaterEqual:
.2188	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.218a	c9 ff		cmp #$ff			cmp 	#$FF
.218c	d0 d0		bne $215e			bne 	ReturnTrue
.218e	80 d7		bra $2167			bra 	ReturnFalse
.2190					FloatCompare:
.2190	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.2192	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.2194	48		pha				pha
.2195	20 c9 20	jsr $20c9			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2198	68		pla				pla
.2199	d0 0c		bne $21a7			bne 	_FCCompareFloat
.219b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.219d	15 4a		ora $4a,x			ora 	NSMantissa1,x
.219f	15 56		ora $56,x			ora 	NSMantissa2,x
.21a1	15 62		ora $62,x			ora 	NSMantissa3,x
.21a3	f0 14		beq $21b9			beq 	_FCExit 					; if zero, return zero
.21a5	80 0a		bra $21b1			bra 	_FCSign
.21a7					_FCCompareFloat:
.21a7	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.21a9	29 f0		and #$f0			and 	#$F0
.21ab	15 56		ora $56,x			ora 	NSMantissa2,x
.21ad	15 62		ora $62,x			ora 	NSMantissa3,x
.21af	f0 08		beq $21b9			beq 	_FCExit 					; zero, so approximately identical
.21b1					_FCSign:
.21b1	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.21b3	34 32		bit $32,x			bit 	NSStatus,x
.21b5	10 02		bpl $21b9			bpl 	_FCExit
.21b7					_FCNegative:
.21b7	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.21b9					_FCExit:
.21b9	20 ad 26	jsr $26ad			jsr 	FloatSetByte 				; set the result 255,0,1
.21bc	60		rts				rts
.21bd					FloatScalarTable:
>21bd	66 66 66 66				.dword $66666666 ; 0.1
>21c1	de					.byte $de
>21c2	1f 85 eb 51				.dword $51eb851f ; 0.01
>21c6	db					.byte $db
>21c7	4c 37 89 41				.dword $4189374c ; 0.001
>21cb	d8					.byte $d8
>21cc	ac 8b db 68				.dword $68db8bac ; 0.0001
>21d0	d4					.byte $d4
>21d1	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>21d5	d1					.byte $d1
>21d6	83 de 1b 43				.dword $431bde83 ; 1e-06
>21da	ce					.byte $ce
>21db	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21df	ca					.byte $ca
>21e0	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21e4	c7					.byte $c7
>21e5	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21e9	c4					.byte $c4
>21ea	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21ee	c0					.byte $c0
>21ef	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21f3	bd					.byte $bd
.21f4					FloatDivide:
.21f4	48		pha				pha
.21f5	20 00 24	jsr $2400			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21f8	ca		dex				dex
.21f9	c9 00		cmp #$00			cmp 	#0
.21fb	f0 1e		beq $221b			beq 	_FDZero
.21fd	20 00 24	jsr $2400			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2200	f0 16		beq $2218			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.2202	20 63 22	jsr $2263			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.2205	20 30 22	jsr $2230			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.2208	20 00 24	jsr $2400			jsr		FloatNormalise 				; renormalise
.220b	20 f6 23	jsr $23f6			jsr 	FloatCalculateSign 			; calculate result sign
.220e	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.2210	38		sec				sec
.2211	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.2213	38		sec				sec
.2214	e9 1e		sbc #$1e			sbc 	#30
.2216	95 6e		sta $6e,x			sta 	NSExponent,x
.2218					_FDExit:
.2218	68		pla				pla
.2219	18		clc				clc
.221a	60		rts				rts
.221b					_FDZero:
.221b	68		pla				pla
.221c	38		sec				sec
.221d	60		rts				rts
.221e					DivideInt32:
.221e	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart 			; make both integers
.2221	ca		dex				dex
.2222	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.2225	20 41 22	jsr $2241			jsr 	Int32Divide 				; divide
.2228	20 30 22	jsr $2230			jsr 	NSMCopyPlusTwoToZero 		; copy result
.222b	20 f6 23	jsr $23f6			jsr 	FloatCalculateSign 			; calculate result sign
.222e	18		clc				clc
.222f	60		rts				rts
.2230					NSMCopyPlusTwoToZero:
.2230	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.2232	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2234	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.2236	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2238	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.223a	95 56		sta $56,x			sta 	NSMantissa2,x
.223c	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.223e	95 62		sta $62,x			sta 	NSMantissa3,x
.2240	60		rts				rts
.2241					Int32Divide:
.2241	48		pha				pha 								; save AXY
.2242	5a		phy				phy
.2243	20 8e 26	jsr $268e			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2246	20 a7 26	jsr $26a7			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2249	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.224b					_I32DivideLoop:
.224b	e8		inx				inx
.224c	e8		inx				inx
.224d	20 ba 26	jsr $26ba			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2250	ca		dex				dex
.2251	ca		dex				dex
.2252	20 bb 26	jsr $26bb			jsr 	FloatRotateLeft
.2255	20 81 22	jsr $2281			jsr 	FloatDivideCheck 			; check if subtract possible
.2258	90 02		bcc $225c			bcc 	_I32DivideNoCarryIn
.225a	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.225c					_I32DivideNoCarryIn:
.225c	88		dey				dey 								; loop round till division completed.
.225d	d0 ec		bne $224b			bne 	_I32DivideLoop
.225f	7a		ply				ply 								; restore AXY and exit
.2260	68		pla				pla
.2261	18		clc				clc
.2262	60		rts				rts
.2263					Int32ShiftDivide:
.2263	48		pha				pha 								; save AY
.2264	5a		phy				phy
.2265	e8		inx				inx 								; clear S[X+2]
.2266	e8		inx				inx
.2267	20 ab 26	jsr $26ab			jsr 	FloatSetZero
.226a	ca		dex				dex
.226b	ca		dex				dex
.226c	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.226e					_I32SDLoop:
.226e	20 81 22	jsr $2281			jsr 	FloatDivideCheck 			; check if subtract possible
.2271	e8		inx				inx
.2272	e8		inx				inx
.2273	20 bb 26	jsr $26bb			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.2276	ca		dex				dex
.2277	ca		dex				dex
.2278	20 bb 26	jsr $26bb			jsr 	FloatRotateLeft
.227b	88		dey				dey 	 							; do 31 times
.227c	d0 f0		bne $226e			bne 	_I32SDLoop
.227e	7a		ply				ply 								; restore AY and exit
.227f	68		pla				pla
.2280	60		rts				rts
.2281					FloatDivideCheck:
.2281	20 51 24	jsr $2451			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.2284	b0 04		bcs $228a			bcs 	_DCSExit 					; if carry set, then could do, exit
.2286	20 37 24	jsr $2437			jsr 	FloatAddTopTwoStack 		; add it back in
.2289	18		clc				clc 								; and return False
.228a					_DCSExit:
.228a	60		rts				rts
.228b					FloatFractionalPart:
.228b	5a		phy				phy
.228c	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.228e	29 7f		and #$7f			and 	#$7F
.2290	95 32		sta $32,x			sta 	NSStatus,x
.2292	20 00 24	jsr $2400			jsr 	FloatNormalise
.2295	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2297	38		sec				sec
.2298	e9 e0		sbc #$e0			sbc 	#$E0
.229a	90 29		bcc $22c5			bcc 	_FFPExit 					; already fractional
.229c	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.229e	b0 22		bcs $22c2			bcs 	_FFPZero
.22a0	a8		tay				tay 								; put count to do in Y
.22a1	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.22a3	20 ca 22	jsr $22ca			jsr 	_FFPPartial
.22a6	95 62		sta $62,x			sta 	NSMantissa3,x
.22a8	b5 56		lda $56,x			lda 	NSMantissa2,x
.22aa	20 ca 22	jsr $22ca			jsr 	_FFPPartial
.22ad	95 56		sta $56,x			sta 	NSMantissa2,x
.22af	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.22b1	20 ca 22	jsr $22ca			jsr 	_FFPPartial
.22b4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.22b6	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.22b8	20 ca 22	jsr $22ca			jsr 	_FFPPartial
.22bb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.22bd	20 cd 26	jsr $26cd			jsr 	FloatIsZero 					; zeroed check.
.22c0	d0 03		bne $22c5			bne 	_FFPExit
.22c2					_FFPZero:
.22c2	20 ab 26	jsr $26ab			jsr 	FloatSetZero
.22c5					_FFPExit:
.22c5	20 00 24	jsr $2400			jsr 	FloatNormalise
.22c8	7a		ply				ply
.22c9	60		rts				rts
.22ca					_FFPPartial:
.22ca	c0 00		cpy #$00			cpy 	#0 							; no more to do
.22cc	f0 17		beq $22e5			beq 	_FFFPPExit
.22ce	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.22d0	b0 0c		bcs $22de			bcs 	_FFFPPWholeByte
.22d2	5a		phy				phy
.22d3					_FFFPPLeft:
.22d3	0a		asl a				asl 	a
.22d4	88		dey				dey
.22d5	d0 fc		bne $22d3			bne 	_FFFPPLeft
.22d7	7a		ply				ply
.22d8					_FFFPPRight:
.22d8	4a		lsr a				lsr 	a
.22d9	88		dey				dey
.22da	d0 fc		bne $22d8			bne 	_FFFPPRight
.22dc	80 07		bra $22e5			bra 	_FFFPPExit
.22de					_FFFPPWholeByte:
.22de	98		tya				tya 								; subtract 8 from count
.22df	38		sec				sec
.22e0	e9 08		sbc #$08			sbc 	#8
.22e2	a8		tay				tay
.22e3	a9 00		lda #$00			lda 	#0 							; and clear all
.22e5					_FFFPPExit:
.22e5	60		rts				rts
.22e6					FloatIntegerPart:
.22e6	48		pha				pha
.22e7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22e9	f0 1d		beq $2308			beq 	_FIPExit 					; if so do nothing
.22eb	20 cd 26	jsr $26cd			jsr 	FloatIsZero 				; is it zero ?
.22ee	f0 15		beq $2305			beq 	_FIPZero 					; if so return zero.
.22f0	20 00 24	jsr $2400			jsr 	FloatNormalise 				; normalise
.22f3	f0 10		beq $2305			beq 	_FIPZero 					; normalised to zero, exit zero
.22f5					_FIPShift:
.22f5	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22f7	10 07		bpl $2300			bpl 	_FIPCheckZero
.22f9	20 c4 26	jsr $26c4			jsr 	FloatShiftRight 			; shift mantissa right
.22fc	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22fe	80 f5		bra $22f5			bra 	_FIPShift
.2300					_FIPCheckZero:
.2300	20 cd 26	jsr $26cd			jsr 	FloatIsZero 				; avoid -0 problem
.2303	d0 03		bne $2308			bne 	_FIPExit 					; set to zero if mantissa zero.
.2305					_FIPZero:
.2305	20 ab 26	jsr $26ab			jsr 	FloatSetZero
.2308					_FIPExit:
.2308	68		pla				pla
.2309	60		rts				rts
.230a					FloatIntegerPartDown:
.230a	48		pha				pha
.230b	5a		phy				phy
.230c	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.230e	f0 36		beq $2346			beq 	_FIPExit 					; if so do nothing
.2310	20 cd 26	jsr $26cd			jsr 	FloatIsZero 				; is it zero ?
.2313	f0 2e		beq $2343			beq 	_FIPZero 					; if so return zero.
.2315	20 00 24	jsr $2400			jsr 	FloatNormalise 				; normalise
.2318	f0 29		beq $2343			beq 	_FIPZero 					; normalised to zero, exit zero
.231a	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.231c					_FIPShift:
.231c	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.231e	10 0a		bpl $232a			bpl 	_FIPCheckDown
.2320	20 c4 26	jsr $26c4			jsr 	FloatShiftRight 			; shift mantissa right
.2323	90 01		bcc $2326			bcc 	_FIPNoFrac 					; shifted a zero out ?
.2325	c8		iny				iny
.2326					_FIPNoFrac:
.2326	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.2328	80 f2		bra $231c			bra 	_FIPShift
.232a					_FIPCheckDown:
.232a	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.232c	f0 10		beq $233e			beq 	_FIPCheckZero
.232e	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.2330	10 0c		bpl $233e			bpl 	_FIPCheckZero
.2332	e8		inx				inx 								; -ve so round *down*.
.2333	a9 01		lda #$01			lda 	#1
.2335	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.2338	20 6d 26	jsr $266d			jsr 	FloatNegate
.233b	20 cf 20	jsr $20cf			jsr 	FloatAdd
.233e					_FIPCheckZero:
.233e	20 cd 26	jsr $26cd			jsr 	FloatIsZero 				; avoid -0 problem
.2341	d0 03		bne $2346			bne 	_FIPExit 					; set to zero if mantissa zero.
.2343					_FIPZero:
.2343	20 ab 26	jsr $26ab			jsr 	FloatSetZero
.2346					_FIPExit:
.2346	7a		ply				ply
.2347	68		pla				pla
.2348	60		rts				rts
.2349					FloatInt8Multiply:
.2349	5a		phy				phy
.234a	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.234c	a8		tay				tay
.234d	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.234f					_FI8MLoop:
.234f	98		tya				tya 								; shift right shifter right into carry
.2350	4a		lsr a				lsr 	a
.2351	a8		tay				tay
.2352	90 0d		bcc $2361			bcc 	_FI8MNoAdd
.2354	18		clc				clc
.2355	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2357	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.2359	95 3e		sta $3e,x			sta 	NSMantissa0,x
.235b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.235d	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.235f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2361					_FI8MNoAdd:
.2361	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.2363	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.2365	c0 00		cpy #$00			cpy 	#0
.2367	d0 e6		bne $234f			bne 	_FI8MLoop 					; until right shifter zero.
.2369	7a		ply				ply
.236a	60		rts				rts
.236b					FloatMultiply:
.236b	ca		dex				dex
.236c	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.236e	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2370	15 62		ora $62,x			ora 	NSMantissa3,x
.2372	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2374	d0 21		bne $2397			bne 	_FMUseFloat
.2376	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2378	15 33		ora $33,x			ora 	NSStatus+1,x
.237a	29 80		and #$80			and 	#$80
.237c	15 62		ora $62,x			ora 	NSMantissa3,x
.237e	15 56		ora $56,x			ora 	NSMantissa2,x
.2380	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2382	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2384	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2386	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2388	d0 04		bne $238e			bne 	_FMInt32
.238a	20 49 23	jsr $2349			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.238d	60		rts				rts
.238e					_FMInt32:
.238e	20 b8 23	jsr $23b8			jsr 	FloatMultiplyShort			; use the int32 one.
.2391	18		clc				clc 								; fix it up if gone out of range
.2392	75 6e		adc $6e,x			adc 	NSExponent,x
.2394	95 6e		sta $6e,x			sta 	NSExponent,x
.2396	60		rts				rts
.2397					_FMUseFloat:
.2397	20 00 24	jsr $2400			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.239a	f0 18		beq $23b4			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.239c	e8		inx				inx
.239d	20 00 24	jsr $2400			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.23a0	ca		dex				dex
.23a1	c9 00		cmp #$00			cmp 	#0
.23a3	f0 0c		beq $23b1			beq 	_FDSetZero
.23a5	20 b8 23	jsr $23b8			jsr 	FloatMultiplyShort 			; calculate the result.
.23a8	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.23aa	18		clc				clc
.23ab	75 6f		adc $6f,x			adc 	NSExponent+1,x
.23ad	95 6e		sta $6e,x			sta 	NSExponent,x
.23af	80 03		bra $23b4			bra 	_FDExit
.23b1					_FDSetZero:
.23b1	20 ab 26	jsr $26ab			jsr 	FloatSetZero 				; return 0
.23b4					_FDExit:
.23b4	20 00 24	jsr $2400			jsr 	FloatNormalise 				; normalise the result
.23b7	60		rts				rts
.23b8					FloatMultiplyShort:
.23b8	5a		phy				phy 								; save Y
.23b9	20 8e 26	jsr $268e			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.23bc	20 a7 26	jsr $26a7			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.23bf	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.23c1					_I32MLoop:
.23c1	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.23c3	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.23c5	15 58		ora $58,x			ora 	NSMantissa2+2,x
.23c7	15 64		ora $64,x			ora 	NSMantissa3+2,x
.23c9	f0 25		beq $23f0			beq 	_I32MExit 					; exit if zero
.23cb	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.23cd	29 01		and #$01			and 	#1
.23cf	f0 0d		beq $23de			beq 	_I32MNoAdd
.23d1	20 37 24	jsr $2437			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.23d4	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.23d6	10 06		bpl $23de			bpl 	_I32MNoAdd
.23d8					_I32ShiftRight:
.23d8	20 c4 26	jsr $26c4			jsr 	FloatShiftRight 			; shift S[X] right
.23db	c8		iny				iny 								; increment shift count
.23dc	80 09		bra $23e7			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23de					_I32MNoAdd:
.23de	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23e0	70 f6		bvs $23d8			bvs 	_I32ShiftRight 				; instead.
.23e2	e8		inx				inx
.23e3	20 ba 26	jsr $26ba			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23e6	ca		dex				dex
.23e7					_I32MShiftUpper:
.23e7	e8		inx				inx 								; shift S[X+2] right
.23e8	e8		inx				inx
.23e9	20 c4 26	jsr $26c4			jsr 	FloatShiftRight
.23ec	ca		dex				dex
.23ed	ca		dex				dex
.23ee	80 d1		bra $23c1			bra 	_I32MLoop 					; try again.
.23f0					_I32MExit:
.23f0	20 f6 23	jsr $23f6			jsr 	FloatCalculateSign
.23f3	98		tya				tya 								; shift in A
.23f4	7a		ply				ply 								; restore Y and exit
.23f5	60		rts				rts
.23f6					FloatCalculateSign:
.23f6	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23f8	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23fa	55 33		eor $33,x			eor 	NSStatus+1,x
.23fc	0a		asl a				asl 	a 							; shift bit 7 into carry
.23fd	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23ff	60		rts				rts
.2400					FloatNormalise:
.2400	20 cd 26	jsr $26cd			jsr 	FloatIsZero 				; if zero exit
.2403	d0 07		bne $240c			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.2405	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.2407	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.2409	a9 00		lda #$00			lda 	#0 							; set Z flag
.240b	60		rts				rts
.240c					_NSNormaliseOptimise:
.240c	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.240e	d0 19		bne $2429			bne 	_NSNormaliseLoop
.2410	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.2412	30 15		bmi $2429			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.2414	95 62		sta $62,x			sta 	NSMantissa3,x
.2416	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2418	95 56		sta $56,x			sta 	NSMantissa2,x
.241a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.241c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.241e	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2420	b5 6e		lda $6e,x			lda 	NSExponent,x
.2422	38		sec				sec
.2423	e9 08		sbc #$08			sbc 	#8
.2425	95 6e		sta $6e,x			sta 	NSExponent,x
.2427	80 e3		bra $240c			bra 	_NSNormaliseOptimise
.2429					_NSNormaliseLoop:
.2429	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.242b	70 07		bvs $2434			bvs 	_NSNExit 					; exit if so with Z flag clear
.242d	20 ba 26	jsr $26ba			jsr 	FloatShiftLeft 				; shift mantissa left
.2430	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.2432	80 f5		bra $2429			bra 	_NSNormaliseLoop
.2434					_NSNExit:
.2434	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.2436	60		rts				rts
.2437					FloatAddTopTwoStack:
.2437	18		clc				clc
.2438	b5 3e		lda $3e,x			lda		NSMantissa0,x
.243a	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.243c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.243e	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2440	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.2442	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2444	b5 56		lda $56,x			lda		NSMantissa2,x
.2446	75 57		adc $57,x			adc 		NSMantissa2+1,x
.2448	95 56		sta $56,x			sta 	NSMantissa2,x
.244a	b5 62		lda $62,x			lda		NSMantissa3,x
.244c	75 63		adc $63,x			adc 		NSMantissa3+1,x
.244e	95 62		sta $62,x			sta 	NSMantissa3,x
.2450	60		rts				rts
.2451					FloatSubTopTwoStack:
.2451	38		sec				sec
.2452	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2454	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.2456	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2458	b5 4a		lda $4a,x			lda		NSMantissa1,x
.245a	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.245c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.245e	b5 56		lda $56,x			lda		NSMantissa2,x
.2460	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.2462	95 56		sta $56,x			sta 	NSMantissa2,x
.2464	b5 62		lda $62,x			lda		NSMantissa3,x
.2466	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.2468	95 62		sta $62,x			sta 	NSMantissa3,x
.246a	60		rts				rts
.246b					FloatInt32Add:
.246b	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.246d	55 33		eor $33,x			eor 	NSStatus+1,x
.246f	30 04		bmi $2475			bmi 	_DiffSigns
.2471	20 37 24	jsr $2437			jsr		FloatAddTopTwoStack
.2474	60		rts				rts
.2475					_DiffSigns:
.2475	20 51 24	jsr $2451			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2478	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.247a	10 07		bpl $2483			bpl 	_AddExit
.247c	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.247e	95 32		sta $32,x			sta 	NSStatus,x
.2480	20 74 26	jsr $2674			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2483					_AddExit:
.2483	20 cd 26	jsr $26cd			jsr 	FloatIsZero 				; check for -0
.2486	d0 02		bne $248a			bne 	_AddNonZero
.2488	74 32		stz $32,x			stz 	NSStatus,x
.248a					_AddNonZero:
.248a	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.248b					FloatEncodeStart:
.248b	38		sec				sec
.248c	80 01		bra $248f			bra 	FloatEncodeContinue+1
.248e					FloatEncodeContinue:
.248e	18		clc				clc
.248f					FloatEncode:
.248f	08		php				php 								; save reset flag.
.2490	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2492	f0 15		beq $24a9			beq 	_ENIsOkay
.2494	c9 30		cmp #$30			cmp 	#"0"
.2496	90 04		bcc $249c			bcc 	_ENBadNumber
.2498	c9 3a		cmp #$3a			cmp 	#"9"+1
.249a	90 0d		bcc $24a9			bcc 	_ENIsOkay
.249c					_ENBadNumber:
.249c	28		plp				plp 								; throw saved reset
.249d	ad 93 05	lda $0593			lda 	encodeState 				; if in decimal mode, construct final number
.24a0	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.24a2	d0 03		bne $24a7			bne 	_ENFail
.24a4	4c 21 25	jmp $2521			jmp 	_ENConstructFinal
.24a7					_ENFail:
.24a7	18		clc				clc 								; not allowed
.24a8	60		rts				rts
.24a9					_ENIsOkay:
.24a9	28		plp				plp 								; are we restarting
.24aa	90 15		bcc $24c1			bcc 	_ENNoRestart
.24ac					_ENStartEncode:
.24ac	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.24ae	f0 0c		beq $24bc			beq 	_ENFirstDP
.24b0	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.24b2	20 ad 26	jsr $26ad			jsr 	FloatSetByte 				; in single byte mode.
.24b5	a9 01		lda #$01			lda 	#ESTA_Low
.24b7					_ENExitChange:
.24b7	8d 93 05	sta $0593			sta 	encodeState 				; save new state
.24ba	38		sec				sec
.24bb	60		rts				rts
.24bc					_ENFirstDP:
.24bc	20 ab 26	jsr $26ab			jsr 	FloatSetZero 				; clear integer part
.24bf	80 3c		bra $24fd			bra 	_ESTASwitchFloat			; go straight to float and exi
.24c1					_ENNoRestart:
.24c1	48		pha				pha 								; save digit or DP on stack.
.24c2	ad 93 05	lda $0593			lda 	encodeState 				; get current state
.24c5	c9 01		cmp #$01			cmp 	#ESTA_Low
.24c7	f0 09		beq $24d2			beq  	_ESTALowState
.24c9	c9 02		cmp #$02			cmp 	#ESTA_High
.24cb	f0 26		beq $24f3			beq 	_ESTAHighState
.24cd	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.24cf	f0 38		beq $2509			beq 	_ESTADecimalState
>24d1	db						.byte 	$DB 						; causes a break in the emulator
.24d2					_ESTALowState:
.24d2	68		pla				pla 								; get value back
.24d3	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.24d5	f0 26		beq $24fd			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24d7	29 0f		and #$0f			and 	#15 						; make digit
.24d9	8d 94 05	sta $0594			sta 	digitTemp 					; save it.
.24dc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24de	0a		asl a				asl 	a
.24df	0a		asl a				asl 	a
.24e0	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24e2	0a		asl a				asl 	a
.24e3	6d 94 05	adc $0594			adc 	digitTemp
.24e6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24e8	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24ea	90 05		bcc $24f1			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24ec	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24ee	8d 93 05	sta $0593			sta 	encodeState
.24f1					_ESTANoSwitch:
.24f1	38		sec				sec
.24f2	60		rts				rts
.24f3					_ESTAHighState:
.24f3	68		pla				pla 								; get value back
.24f4	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24f6	f0 05		beq $24fd			beq 	_ESTASwitchFloat
.24f8	20 53 25	jsr $2553			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24fb	38		sec				sec
.24fc	60		rts				rts
.24fd					_ESTASwitchFloat:
.24fd	9c 95 05	stz $0595			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.2500	e8		inx				inx 								; zero the decimal additive.
.2501	20 ab 26	jsr $26ab			jsr 	FloatSetZero
.2504	ca		dex				dex
.2505	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.2507	80 ae		bra $24b7			bra 	_ENExitChange
.2509					_ESTADecimalState:
.2509	68		pla				pla 								; digit.
.250a	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.250c	f0 99		beq $24a7			beq 	_ENFail
.250e	e8		inx				inx 								; put digit into fractional part of X+1
.250f	20 53 25	jsr $2553			jsr 	ESTAShiftDigitIntoMantissa
.2512	ca		dex				dex
.2513	ee 95 05	inc $0595			inc 	decimalCount 				; bump the count of decimals
.2516	ad 95 05	lda $0595			lda 	decimalCount 				; too many decimal digits.
.2519	c9 0b		cmp #$0b			cmp 	#11
.251b	f0 02		beq $251f			beq 	_ESTADSFail
.251d	38		sec				sec
.251e	60		rts				rts
.251f					_ESTADSFail:
.251f	18		clc				clc
.2520	60		rts				rts
.2521					_ENConstructFinal:
.2521	ad 95 05	lda $0595			lda 	decimalCount 				; get decimal count
.2524	f0 2b		beq $2551			beq 	_ENCFExit 					; no decimals
.2526	5a		phy				phy
.2527	0a		asl a				asl 	a 							; x 4 and CLC
.2528	0a		asl a				asl 	a
.2529	6d 95 05	adc $0595			adc 	decimalCount
.252c	a8		tay				tay
.252d	b9 b8 21	lda $21b8,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.2530	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.2532	b9 b9 21	lda $21b9,y			lda 	FloatScalarTable-5+1,y
.2535	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2537	b9 ba 21	lda $21ba,y			lda 	FloatScalarTable-5+2,y
.253a	95 58		sta $58,x			sta 	NSMantissa2+2,x
.253c	b9 bb 21	lda $21bb,y			lda 	FloatScalarTable-5+3,y
.253f	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2541	b9 bc 21	lda $21bc,y			lda 	FloatScalarTable-5+4,y
.2544	95 70		sta $70,x			sta 	NSExponent+2,x
.2546	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.2548	e8		inx				inx 								; multiply decimal const by decimal scalar
.2549	e8		inx				inx
.254a	20 6b 23	jsr $236b			jsr 	FloatMultiply
.254d	20 cf 20	jsr $20cf			jsr 	FloatAdd 					; add to integer part.
.2550	7a		ply				ply
.2551					_ENCFExit:
.2551	18		clc				clc 								; reject the digit.
.2552	60		rts				rts
.2553					ESTAShiftDigitIntoMantissa:
.2553	29 0f		and #$0f			and 	#15 						; save digit
.2555	48		pha				pha
.2556	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2558	48		pha				pha
.2559	b5 56		lda $56,x			lda 	NSMantissa2,x
.255b	48		pha				pha
.255c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.255e	48		pha				pha
.255f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2561	48		pha				pha
.2562	20 ba 26	jsr $26ba			jsr 	FloatShiftLeft 				; x 2
.2565	20 ba 26	jsr $26ba			jsr 	FloatShiftLeft 				; x 4
.2568	18		clc				clc 								; pop mantissa and add
.2569	68		pla				pla
.256a	75 3e		adc $3e,x			adc 	NSMantissa0,x
.256c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.256e	68		pla				pla
.256f	75 4a		adc $4a,x			adc 	NSMantissa1,x
.2571	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2573	68		pla				pla
.2574	75 56		adc $56,x			adc 	NSMantissa2,x
.2576	95 56		sta $56,x			sta 	NSMantissa2,x
.2578	68		pla				pla
.2579	75 62		adc $62,x			adc 	NSMantissa3,x
.257b	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.257d	20 ba 26	jsr $26ba			jsr 	FloatShiftLeft 				; x 10
.2580	68		pla				pla 								; add digit
.2581	18		clc				clc
.2582	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2584	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2586	90 0a		bcc $2592			bcc 	_ESTASDExit
.2588	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.258a	d0 06		bne $2592			bne 	_ESTASDExit
.258c	f6 56		inc $56,x			inc 	NSMantissa2,x
.258e	d0 02		bne $2592			bne 	_ESTASDExit
.2590	f6 62		inc $62,x			inc 	NSMantissa3,x
.2592					_ESTASDExit:
.2592	60		rts				rts
.0593					encodeState:
>0593							.fill 	1
.0594					digitTemp:
>0594							.fill 	1
.0595					decimalCount:
>0595							.fill 	1
.2593					FloatToString:
.2593	da		phx				phx
.2594	5a		phy				phy 								; save code position
.2595	8d 96 05	sta $0596			sta 	decimalPlaces	 			; save number of DPs.
.2598	9c 97 05	stz $0597			stz 	dbOffset 					; offset into decimal buffer = start.
.259b	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.259d	10 08		bpl $25a7			bpl 	_CNTSNotNegative
.259f	29 7f		and #$7f			and 	#$7F 						; make +ve
.25a1	95 32		sta $32,x			sta 	NSStatus,x
.25a3	a9 2d		lda #$2d			lda 	#"-"
.25a5	80 02		bra $25a9			bra 	_CNTMain
.25a7					_CNTSNotNegative:
.25a7	a9 20		lda #$20			lda 	#" "
.25a9					_CNTMain:
.25a9	20 0b 26	jsr $260b			jsr 	WriteDecimalBuffer
.25ac	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.25ae	f0 0d		beq $25bd			beq 	_CNTSNotFloat
.25b0	e8		inx				inx 								; round up so we don't get too many 6.999999
.25b1	a9 01		lda #$01			lda 	#1
.25b3	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.25b6	b5 6d		lda $6d,x			lda		NSExponent-1,x
.25b8	95 6e		sta $6e,x			sta 	NSExponent,x
.25ba	20 cf 20	jsr $20cf			jsr 	FloatAdd
.25bd					_CNTSNotFloat:
.25bd	20 ed 25	jsr $25ed			jsr 	MakePlusTwoString 			; do the integer part.
.25c0	20 8b 22	jsr $228b			jsr 	FloatFractionalPart 		; get the fractional part
.25c3	20 00 24	jsr $2400			jsr 	FloatNormalise					; normalise , exit if zero
.25c6	f0 22		beq $25ea			beq 	_CNTSExit
.25c8	a9 2e		lda #$2e			lda 	#"."
.25ca	20 0b 26	jsr $260b			jsr 	WriteDecimalBuffer 			; write decimal place
.25cd					_CNTSDecimal:
.25cd	ce 96 05	dec $0596			dec 	decimalPlaces 				; done all the decimals
.25d0	30 18		bmi $25ea			bmi 	_CNTSExit
.25d2	e8		inx				inx 								; x 10.0
.25d3	a9 0a		lda #$0a			lda 	#10
.25d5	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.25d8	20 6b 23	jsr $236b			jsr 	FloatMultiply
.25db	20 ed 25	jsr $25ed			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25de	20 8b 22	jsr $228b			jsr 	FloatFractionalPart 		; get the fractional part
.25e1	20 00 24	jsr $2400			jsr 	FloatNormalise 				; normalise it.
.25e4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25e6	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25e8	b0 e3		bcs $25cd			bcs 	_CNTSDecimal 				; keep going.
.25ea					_CNTSExit:
.25ea	7a		ply				ply
.25eb	fa		plx				plx
.25ec	60		rts				rts
.25ed					MakePlusTwoString:
.25ed	da		phx				phx
.25ee	20 8e 26	jsr $268e			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25f1	e8		inx				inx 								; access it
.25f2	e8		inx				inx
.25f3	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart 			; make it an integer
.25f6	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25f8	20 2a 26	jsr $262a			jsr 	ConvertInt32
.25fb	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25fd					_MPTSCopy:
.25fd	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.2600	20 0b 26	jsr $260b			jsr 	WriteDecimalBuffer
.2603	e8		inx				inx
.2604	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.2607	d0 f4		bne $25fd			bne 	_MPTSCopy
.2609	fa		plx				plx
.260a	60		rts				rts
.260b					WriteDecimalBuffer:
.260b	da		phx				phx
.260c	ae 97 05	ldx $0597			ldx 	dbOffset
.260f	9d 98 05	sta $0598,x			sta 	decimalBuffer,x
.2612	9e 99 05	stz $0599,x			stz 	decimalBuffer+1,x
.2615	ee 97 05	inc $0597			inc 	dbOffset
.2618	fa		plx				plx
.2619	60		rts				rts
.0596					decimalPlaces:
>0596							.fill 	1
.0597					dbOffset:
>0597							.fill 	1
.0598					decimalBuffer:
>0598							.fill 	32
.261a					ConvertInt16:
.261a	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.261c	86 4a		stx $4a				stx 	NSMantissa1
.261e	64 56		stz $56				stz 	NSMantissa2
.2620	64 62		stz $62				stz 	NSMantissa3
.2622	64 32		stz $32				stz 	NSStatus 					; positive integer
.2624	a2 00		ldx #$00			ldx 	#0 							; stack level
.2626	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.2628	80 00		bra $262a			bra 	ConvertInt32
.262a					ConvertInt32:
.262a	5a		phy				phy
.262b	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.262d	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.262f	10 08		bpl $2639			bpl 	_CI32NotNeg
.2631	48		pha				pha
.2632	a9 2d		lda #$2d			lda 	#'-'
.2634	99 71 05	sta $0571,y			sta 	numberBuffer,y
.2637	c8		iny				iny
.2638	68		pla				pla
.2639					_CI32NotNeg:
.2639	20 47 26	jsr $2647			jsr 	_CI32DivideConvert 			; recursive conversion
.263c	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.263e	99 71 05	sta $0571,y			sta 	numberBuffer,y
.2641	7a		ply				ply
.2642	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.2644	a9 71		lda #$71			lda 	#numberBuffer & $FF
.2646	60		rts				rts
.2647					_CI32DivideConvert:
.2647	e8		inx				inx 								; write to next slot up
.2648	20 ad 26	jsr $26ad			jsr 	FloatSetByte 		 		; write the base out.
.264b	ca		dex				dex
.264c	20 41 22	jsr $2241			jsr 	Int32Divide 				; divide
.264f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.2651	48		pha				pha
.2652	20 30 22	jsr $2230			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2655	20 cd 26	jsr $26cd			jsr 	FloatIsZero 				; is it zero ?
.2658	f0 05		beq $265f			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.265a	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.265c	20 47 26	jsr $2647			jsr 	_CI32DivideConvert 			; and recusrively call.
.265f					_CI32NoRecurse:
.265f	68		pla				pla 								; remainder
.2660	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2662	90 02		bcc $2666			bcc 	_CI32NotHex
.2664	69 26		adc #$26			adc 	#6+32
.2666					_CI32NotHex:
.2666	69 30		adc #$30			adc 	#48
.2668	99 71 05	sta $0571,y			sta 	numberBuffer,y 				; write out and exit
.266b	c8		iny				iny
.266c	60		rts				rts
.266d					FloatNegate:
.266d	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.266f	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2671	95 32		sta $32,x			sta 	NSStatus,x
.2673	60		rts				rts
.2674					FloatNegateMantissa:
.2674	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2675	a9 00		lda #$00			lda 	#0
.2677	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2679	95 3e		sta $3e,x			sta 	NSMantissa0,x
.267b	a9 00		lda #$00			lda 	#0
.267d	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.267f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2681	a9 00		lda #$00			lda 	#0
.2683	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.2685	95 56		sta $56,x			sta 	NSMantissa2,x
.2687	a9 00		lda #$00			lda 	#0
.2689	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.268b	95 62		sta $62,x			sta 	NSMantissa3,x
.268d	60		rts				rts
.268e					FloatShiftUpTwo:
.268e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2690	95 40		sta $40,x			sta 	NSMantissa0+2,x
.2692	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2694	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2696	b5 56		lda $56,x			lda 	NSMantissa2,x
.2698	95 58		sta $58,x			sta 	NSMantissa2+2,x
.269a	b5 62		lda $62,x			lda 	NSMantissa3,x
.269c	95 64		sta $64,x			sta 	NSMantissa3+2,x
.269e	b5 6e		lda $6e,x			lda 	NSExponent,x
.26a0	95 70		sta $70,x			sta 	NSExponent+2,x
.26a2	b5 32		lda $32,x			lda 	NSStatus,x
.26a4	95 34		sta $34,x			sta 	NSStatus+2,x
.26a6	60		rts				rts
.26a7					FloatSetZeroMantissaOnly:
.26a7	74 3e		stz $3e,x			stz 	NSMantissa0,x
.26a9	80 08		bra $26b3			bra 	FloatZero13
.26ab					FloatSetZero:
.26ab	a9 00		lda #$00			lda 	#0
.26ad					FloatSetByte:
.26ad	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.26af					FloatSetMantissa:
.26af	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.26b1	74 32		stz $32,x			stz 	NSStatus,x
.26b3					FloatZero13:
.26b3	74 4a		stz $4a,x			stz 	NSMantissa1,x
.26b5	74 56		stz $56,x			stz 	NSMantissa2,x
.26b7	74 62		stz $62,x			stz 	NSMantissa3,x
.26b9	60		rts				rts
.26ba					FloatShiftLeft:
.26ba	18		clc				clc
.26bb					FloatRotateLeft:
.26bb	36 3e		rol $3e,x			rol 	NSMantissa0,x
.26bd	36 4a		rol $4a,x			rol		NSMantissa1,x
.26bf	36 56		rol $56,x			rol		NSMantissa2,x
.26c1	36 62		rol $62,x			rol		NSMantissa3,x
.26c3	60		rts				rts
.26c4					FloatShiftRight:
.26c4	56 62		lsr $62,x			lsr 	NSMantissa3,x
.26c6	76 56		ror $56,x			ror		NSMantissa2,x
.26c8	76 4a		ror $4a,x			ror		NSMantissa1,x
.26ca	76 3e		ror $3e,x			ror		NSMantissa0,x
.26cc	60		rts				rts
.26cd					FloatIsZero:
.26cd	b5 62		lda $62,x			lda 	NSMantissa3,x
.26cf	15 56		ora $56,x			ora		NSMantissa2,x
.26d1	15 4a		ora $4a,x			ora		NSMantissa1,x
.26d3	15 3e		ora $3e,x			ora		NSMantissa0,x
.26d5	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.26d6					FloatArcTan:
.26d6	20 00 24	jsr $2400			jsr 	FloatNormalise 					; normalise x
.26d9	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.26db	48		pha				pha
.26dc	74 32		stz $32,x			stz 	NSStatus,x
.26de	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.26e0	c9 e2		cmp #$e2			cmp 	#$E2
.26e2	90 25		bcc $2709			bcc 	_UANoFixup
.26e4	8a		txa				txa 									; value in +1
.26e5	a8		tay				tay
.26e6	c8		iny				iny
.26e7	20 8f 28	jsr $288f			jsr 	CopyFloatXY
.26ea	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.26ec	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.26ef	e8		inx				inx
.26f0	20 f4 21	jsr $21f4			jsr 	FloatDivide
.26f3	b0 21		bcs $2716			bcs 	_FATError
.26f5	20 19 27	jsr $2719			jsr 	CoreAtn 						; calculate the root
.26f8	20 84 28	jsr $2884			jsr 	CompletePolynomial
.26fb	20 6d 26	jsr $266d			jsr 	FloatNegate 					; make -ve
.26fe	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2700	20 db 28	jsr $28db			jsr 	LoadConstant
.2703	e8		inx				inx
.2704	20 cf 20	jsr $20cf			jsr 	FloatAdd
.2707	80 06		bra $270f			bra 	_UAComplete
.2709					_UANoFixup:
.2709	20 19 27	jsr $2719			jsr 	CoreAtn
.270c	20 84 28	jsr $2884			jsr 	CompletePolynomial
.270f					_UAComplete:
.270f	68		pla				pla 									; apply the result.
.2710	55 32		eor $32,x			eor 	NSStatus,x
.2712	95 32		sta $32,x			sta 	NSStatus,x
.2714	18		clc				clc
.2715	60		rts				rts
.2716					_FATError:
.2716	68		pla				pla
.2717	38		sec				sec
.2718	60		rts				rts
.2719					CoreAtn:
.2719	a9 87		lda #$87			lda 	#AtnCoefficients & $FF
.271b	a0 27		ldy #$27			ldy 	#AtnCoefficients >> 8
.271d	4c d8 29	jmp $29d8			jmp 	CorePolySquared
.2720					ExpCoefficients:
>2720	07					.byte	7
>2721	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>2725	d2					.byte	$d2
>2726	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>272a	d5					.byte	$d5
>272b	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>272f	d8					.byte	$d8
>2730	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>2734	db					.byte	$db
>2735	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>2739	dd					.byte	$dd
>273a	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>273e	df					.byte	$df
>273f	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>2743	e1					.byte	$e1
>2744	00 00 00 40				.dword	$40000000 ; 1.0
>2748	e2					.byte	$e2
.2749					SinCoefficients:
>2749	06					.byte	6
>274a	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>274e	e5					.byte	$e5
>274f	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>2753	e7					.byte	$e7
>2754	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>2758	e8					.byte	$e8
>2759	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>275d	e8					.byte	$e8
>275e	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>2762	e7					.byte	$e7
>2763	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>2767	e4					.byte	$e4
>2768	00 00 00 00				.dword	$00000000 ; 0.0
>276c	00					.byte	$00
.276d					LogCoefficients:
>276d	04					.byte	4
>276e	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>2772	e0					.byte	$e0
>2773	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>2777	e1					.byte	$e1
>2778	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>277c	e1					.byte	$e1
>277d	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>2781	e3					.byte	$e3
>2782	00 00 00 c0				.dword	$c0000000 ; -0.5
>2786	e1					.byte	$e1
.2787					AtnCoefficients:
>2787	0c					.byte	12
>2788	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>278c	d7					.byte	$d7
>278d	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>2791	da					.byte	$da
>2792	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>2796	dc					.byte	$dc
>2797	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>279b	dd					.byte	$dd
>279c	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>27a0	dd					.byte	$dd
>27a1	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>27a5	de					.byte	$de
>27a6	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>27aa	de					.byte	$de
>27ab	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>27af	de					.byte	$de
>27b0	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>27b4	df					.byte	$df
>27b5	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>27b9	df					.byte	$df
>27ba	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>27be	e0					.byte	$e0
>27bf	00 00 00 40				.dword	$40000000 ; 1.0
>27c3	e2					.byte	$e2
>27c4	00 00 00 00				.dword	$00000000 ; 0.0
>27c8	00					.byte	$00
.27c9					Const_Base:
.27c9					Const_1Div2Pi:
>27c9	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>27cd	df					.byte	$df
.27ce					Const_PiDiv2:
>27ce	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>27d2	e2					.byte	$e2
.27d3					Const_Log2_e:
>27d3	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>27d7	e2					.byte	$e2
.27d8					Const_sqrt_2:
>27d8	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>27dc	e2					.byte	$e2
.27dd					Const_sqrt_half:
>27dd	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>27e1	e1					.byte	$e1
.27e2					Const_pi:
>27e2	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>27e6	e3					.byte	$e3
.27e7					Const_half:
>27e7	00 00 00 40				.dword	$40000000 ; 0.50000000
>27eb	e1					.byte	$e1
.27ec					Const_ln_e:
>27ec	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>27f0	e1					.byte	$e1
.27f1					FloatCosine:
.27f1	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.27f3	20 db 28	jsr $28db			jsr 	LoadConstant
.27f6	e8		inx				inx
.27f7	20 cf 20	jsr $20cf			jsr 	FloatAdd
.27fa	4c 91 29	jmp $2991			jmp 	FloatSine
.27fd					FloatExponent:
.27fd	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.27ff	20 db 28	jsr $28db			jsr 	LoadConstant
.2802	e8		inx				inx
.2803	20 6b 23	jsr $236b			jsr 	FloatMultiply
.2806	20 48 28	jsr $2848			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.2809	e8		inx				inx
.280a	20 e6 22	jsr $22e6			jsr 	FloatIntegerPart
.280d	ca		dex				dex
.280e	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2810	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2812	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2814	d0 38		bne $284e			bne 	_UERangeError
.2816	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.2818	c9 40		cmp #$40			cmp 	#64
.281a	b0 32		bcs $284e			bcs 	_UERangeError
.281c	48		pha				pha
.281d	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.281f	48		pha				pha
.2820	20 8b 22	jsr $228b			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.2823	68		pla				pla
.2824	10 14		bpl $283a			bpl 	_UEPositive
.2826	e8		inx				inx 							; 1-x
.2827	a9 01		lda #$01			lda 	#1
.2829	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.282c	ca		dex				dex
.282d	20 6d 26	jsr $266d			jsr 	FloatNegate
.2830	e8		inx				inx
.2831	20 cf 20	jsr $20cf			jsr 	FloatAdd
.2834	68		pla				pla 							; integer part +1 and negated.
.2835	1a		inc a				inc 	a
.2836	49 ff		eor #$ff			eor 	#$FF
.2838	1a		inc a				inc 	a
.2839	48		pha				pha
.283a					_UEPositive:
.283a	20 50 28	jsr $2850			jsr 	CoreExponent
.283d	20 84 28	jsr $2884			jsr 	CompletePolynomial
.2840	68		pla				pla
.2841	18		clc				clc
.2842	75 6e		adc $6e,x			adc 	NSExponent,x
.2844	95 6e		sta $6e,x			sta 	NSExponent,x
.2846	18		clc				clc
.2847	60		rts				rts
.2848					_UECopy01:
.2848	8a		txa				txa
.2849	a8		tay				tay
.284a	c8		iny				iny
.284b	4c 8f 28	jmp $288f			jmp 	CopyFloatXY
.284e					_UERangeError:
.284e	38		sec				sec
.284f	60		rts				rts
.2850					CoreExponent:
.2850	a9 20		lda #$20			lda 	#ExpCoefficients & $FF
.2852	a0 27		ldy #$27			ldy 	#ExpCoefficients >> 8
.2854	20 58 28	jsr $2858			jsr 	CalculateHornerPolynomial
.2857	60		rts				rts
.2858					CalculateHornerPolynomial:
.2858	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.285a	84 2d		sty $2d				sty 	zTemp0+1
.285c	9c b8 05	stz $05b8			stz 	coefficientCount 			; zero the count.
.285f	8e b9 05	stx $05b9			stx 	xValueSlot 					; save xValue slot.
.2862	e8		inx				inx 								; set the count to zero.
.2863	20 ab 26	jsr $26ab			jsr 	FloatSetZero
.2866					_CHPLoop:
.2866	8a		txa				txa 								; copy X-1 to X+1
.2867	a8		tay				tay
.2868	ca		dex				dex
.2869	c8		iny				iny
.286a	20 8f 28	jsr $288f			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.286d	e8		inx				inx
.286e	e8		inx				inx
.286f	20 6b 23	jsr $236b			jsr 	FloatMultiply 				; times current by X
.2872	e8		inx				inx
.2873	20 ae 28	jsr $28ae			jsr 	GetCoefficient 				; coefficient into X+1
.2876	20 cf 20	jsr $20cf			jsr 	FloatAdd 					; and add
.2879	ee b8 05	inc $05b8			inc 	coefficientCount
.287c	ad b8 05	lda $05b8			lda 	coefficientCount
.287f	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.2881	d0 e3		bne $2866			bne 	_CHPLoop
.2883	60		rts				rts
.2884					CompletePolynomial:
.2884	20 6b 23	jsr $236b			jsr 	FloatMultiply
.2887	e8		inx				inx 								; get the last value
.2888	20 ae 28	jsr $28ae			jsr 	GetCoefficient
.288b	20 cf 20	jsr $20cf			jsr 	FloatAdd 					; and add it
.288e	60		rts				rts
.288f					CopyFloatXY:
.288f	b5 6e		lda $6e,x			lda 	NSExponent,x
.2891	99 6e 00	sta $006e,y			sta 	NSExponent,y
.2894	b5 32		lda $32,x			lda 	NSStatus,x
.2896	99 32 00	sta $0032,y			sta 	NSStatus,y
.2899	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.289b	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.289e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.28a0	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.28a3	b5 56		lda $56,x			lda 	NSMantissa2,x
.28a5	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.28a8	b5 62		lda $62,x			lda 	NSMantissa3,x
.28aa	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.28ad	60		rts				rts
.28ae					GetCoefficient:
.28ae	5a		phy				phy
.28af	ad b8 05	lda $05b8			lda 	coefficientCount 			; 5 per block
.28b2	0a		asl a				asl 	a
.28b3	0a		asl a				asl 	a
.28b4	38		sec				sec 								; +1 for count
.28b5	6d b8 05	adc $05b8			adc 	coefficientCount
.28b8	a8		tay				tay
.28b9	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.28bb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.28bd	c8		iny				iny
.28be	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28c0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.28c2	c8		iny				iny
.28c3	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28c5	95 56		sta $56,x			sta 	NSMantissa2,x
.28c7	c8		iny				iny
.28c8	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28ca	48		pha				pha
.28cb	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.28cd	95 62		sta $62,x			sta 	NSMantissa3,x
.28cf	c8		iny				iny
.28d0	68		pla				pla
.28d1	29 80		and #$80			and 	#$80
.28d3	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.28d5	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28d7	95 6e		sta $6e,x			sta 	NSExponent,x
.28d9	7a		ply				ply
.28da	60		rts				rts
.05b8					coefficientCount:
>05b8							.fill 	1
.05b9					xValueSlot:
>05b9							.fill 	1
.28db					LoadConstant:
.28db	5a		phy				phy
.28dc	a8		tay				tay
.28dd	b9 c9 27	lda $27c9,y			lda 	Const_Base+0,y
.28e0	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.28e2	b9 ca 27	lda $27ca,y			lda 	Const_Base+1,y
.28e5	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.28e7	b9 cb 27	lda $27cb,y			lda 	Const_Base+2,y
.28ea	95 57		sta $57,x			sta 	NSMantissa2+1,x
.28ec	b9 cc 27	lda $27cc,y			lda 	Const_Base+3,y
.28ef	48		pha				pha
.28f0	29 7f		and #$7f			and 	#$7F
.28f2	95 63		sta $63,x			sta 	NSMantissa3+1,x
.28f4	68		pla				pla
.28f5	29 80		and #$80			and 	#$80
.28f7	95 33		sta $33,x			sta 	NSStatus+1,x
.28f9	b9 cd 27	lda $27cd,y			lda 	Const_Base+4,y
.28fc	95 6f		sta $6f,x			sta 	NSExponent+1,x
.28fe	7a		ply				ply
.28ff	60		rts				rts
.2900					FloatLogarithm:
.2900	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.2902	30 5f		bmi $2963			bmi 	_ULRange
.2904	20 cd 26	jsr $26cd			jsr 	FloatIsZero
.2907	f0 5a		beq $2963			beq 	_ULRange
.2909	20 00 24	jsr $2400			jsr 	FloatNormalise 				; put into FP mode.
.290c	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.290e	48		pha				pha
.290f	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.2911	95 6e		sta $6e,x			sta 	NSExponent,x
.2913	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.2915	20 db 28	jsr $28db			jsr 	LoadConstant
.2918	e8		inx				inx
.2919	20 cf 20	jsr $20cf			jsr 	FloatAdd
.291c	8a		txa				txa 								; divide into sqrt 2.0
.291d	a8		tay				tay
.291e	c8		iny				iny
.291f	20 8f 28	jsr $288f			jsr 	CopyFloatXY
.2922	ca		dex				dex
.2923	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.2925	20 db 28	jsr $28db			jsr 	LoadConstant
.2928	e8		inx				inx
.2929	e8		inx				inx
.292a	20 f4 21	jsr $21f4			jsr 	FloatDivide 				; if zero, error.
.292d	b0 33		bcs $2962			bcs 	_ULRangePla
.292f	20 6d 26	jsr $266d			jsr 	FloatNegate 				; subtract from 1
.2932	e8		inx				inx
.2933	a9 01		lda #$01			lda 	#1
.2935	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.2938	20 cf 20	jsr $20cf			jsr 	FloatAdd
.293b	20 65 29	jsr $2965			jsr 	CoreLog
.293e	20 84 28	jsr $2884			jsr 	CompletePolynomial
.2941	68		pla				pla 								; add exponent
.2942	18		clc				clc
.2943	69 1f		adc #$1f			adc 	#31 						; fix up
.2945	48		pha				pha
.2946	10 03		bpl $294b			bpl 	_LogNotNeg
.2948	49 ff		eor #$ff			eor 	#$FF
.294a	1a		inc a				inc 	a
.294b					_LogNotNeg:
.294b	e8		inx				inx 								; set byte and sign.
.294c	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.294f	68		pla				pla
.2950	29 80		and #$80			and 	#$80
.2952	95 32		sta $32,x			sta 	NSStatus,x
.2954	20 cf 20	jsr $20cf			jsr 	FloatAdd
.2957	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.2959	20 db 28	jsr $28db			jsr 	LoadConstant
.295c	e8		inx				inx
.295d	20 6b 23	jsr $236b			jsr 	FloatMultiply
.2960	18		clc				clc
.2961	60		rts				rts
.2962					_ULRangePla:
.2962	68		pla				pla
.2963					_ULRange:
.2963	38		sec				sec
.2964	60		rts				rts
.2965					CoreLog:
.2965	a9 6d		lda #$6d			lda 	#LogCoefficients & $FF
.2967	a0 27		ldy #$27			ldy 	#LogCoefficients >> 8
.2969	4c d8 29	jmp $29d8			jmp 	CorePolySquared
.296c					FloatPI:
.296c	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.296e	20 db 28	jsr $28db			jsr 	LoadConstant
.2971	e8		inx				inx
.2972	18		clc				clc
.2973	60		rts				rts
.2974					FloatPower:
.2974	ca		dex				dex
.2975	8a		txa				txa 							; copy 0 to 2, so we can process it
.2976	a8		tay				tay
.2977	c8		iny				iny
.2978	c8		iny				iny
.2979	20 8f 28	jsr $288f			jsr 	CopyFloatXY
.297c	e8		inx				inx 							; 2 = Log(0)
.297d	e8		inx				inx
.297e	20 00 29	jsr $2900			jsr 	FloatLogarithm
.2981	b0 0d		bcs $2990			bcs 	_FPWExit
.2983	20 6b 23	jsr $236b			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.2986	8a		txa				txa 							; copy to slot 0
.2987	a8		tay				tay
.2988	88		dey				dey
.2989	20 8f 28	jsr $288f			jsr 	CopyFloatXY
.298c	ca		dex				dex  							; Exponent code.
.298d	20 fd 27	jsr $27fd			jsr 	FloatExponent
.2990					_FPWExit:
.2990	60		rts				rts
.2991					FloatSine:
.2991	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.2993	48		pha				pha
.2994	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.2996	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.2998	20 db 28	jsr $28db			jsr 	LoadConstant
.299b	e8		inx				inx
.299c	20 6b 23	jsr $236b			jsr 	FloatMultiply
.299f	20 8b 22	jsr $228b			jsr 	FloatFractionalPart 		; take the fractional part
.29a2	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.29a4	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.29a6	90 1f		bcc $29c7			bcc 	_USProcessExit
.29a8	f0 06		beq $29b0			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.29aa	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.29ac	c9 60		cmp #$60			cmp 	#$60
.29ae	b0 0e		bcs $29be			bcs 	_USSubtractOne
.29b0					_USSubtractFromHalf:
.29b0	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.29b2	20 db 28	jsr $28db			jsr 	LoadConstant
.29b5	e8		inx				inx
.29b6	20 c9 20	jsr $20c9			jsr 	FloatSubtract
.29b9	20 6d 26	jsr $266d			jsr 	FloatNegate 				; then negate it
.29bc	80 09		bra $29c7			bra 	_USProcessExit 				; and exit
.29be					_USSubtractOne:
.29be	e8		inx				inx
.29bf	a9 01		lda #$01			lda 	#1
.29c1	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.29c4	20 c9 20	jsr $20c9			jsr 	FloatSubtract
.29c7					_USProcessExit:
.29c7	20 d4 29	jsr $29d4			jsr 	CoreSine
.29ca	20 84 28	jsr $2884			jsr 	CompletePolynomial
.29cd	68		pla				pla 								; restore sign and apply
.29ce	55 32		eor $32,x			eor 	NSStatus,x
.29d0	95 32		sta $32,x			sta 	NSStatus,x
.29d2	18		clc				clc
.29d3	60		rts				rts
.29d4					CoreSine:
.29d4	a9 49		lda #$49			lda 	#SinCoefficients & $FF
.29d6	a0 27		ldy #$27			ldy 	#SinCoefficients >> 8
.29d8					CorePolySquared:
.29d8	48		pha				pha 								; save coefficient table
.29d9	5a		phy				phy
.29da	8a		txa				txa 								; copy X to +1, +2
.29db	a8		tay				tay
.29dc	c8		iny				iny
.29dd	20 8f 28	jsr $288f			jsr 	CopyFloatXY
.29e0	c8		iny				iny
.29e1	20 8f 28	jsr $288f			jsr 	CopyFloatXY
.29e4	e8		inx				inx 								; point to the pair and put x^2 on stack
.29e5	e8		inx				inx
.29e6	20 6b 23	jsr $236b			jsr 	FloatMultiply
.29e9	7a		ply				ply 								; coefficient table back.
.29ea	68		pla				pla
.29eb	20 58 28	jsr $2858			jsr 	CalculateHornerPolynomial
.29ee	8a		txa				txa 								; copy back to slot #1
.29ef	a8		tay				tay
.29f0	88		dey				dey
.29f1	20 8f 28	jsr $288f			jsr	 	CopyFloatXY
.29f4	ca		dex				dex 								; point at result
.29f5	60		rts				rts
.29f6					FloatSquareRoot:
.29f6	20 00 29	jsr $2900			jsr 	FloatLogarithm
.29f9	b0 06		bcs $2a01			bcs 	_FSQExit
.29fb	d6 6e		dec $6e,x			dec 	NSExponent,x
.29fd	20 fd 27	jsr $27fd			jsr 	FloatExponent
.2a00	18		clc				clc
.2a01					_FSQExit:
.2a01	60		rts				rts
.2a02					FloatTangent:
.2a02	da		phx				phx
.2a03	8a		txa				txa 								; sin -> +1
.2a04	a8		tay				tay
.2a05	c8		iny				iny
.2a06	20 8f 28	jsr $288f			jsr 	CopyFloatXY
.2a09	e8		inx				inx
.2a0a	20 91 29	jsr $2991			jsr 	FloatSine
.2a0d	ca		dex				dex
.2a0e	8a		txa				txa 								; cos -> +2
.2a0f	a8		tay				tay
.2a10	c8		iny				iny
.2a11	c8		iny				iny
.2a12	20 8f 28	jsr $288f			jsr 	CopyFloatXY
.2a15	e8		inx				inx
.2a16	e8		inx				inx
.2a17	20 f1 27	jsr $27f1			jsr 	FloatCosine
.2a1a	20 f4 21	jsr $21f4			jsr 	FloatDivide 				; calculate sin/cos
.2a1d	b0 07		bcs $2a26			bcs 	_FTExit 					; divide by zero
.2a1f	8a		txa				txa 								; copy result down.
.2a20	a8		tay				tay
.2a21	88		dey				dey
.2a22	20 8f 28	jsr $288f			jsr 	CopyFloatXY
.2a25	18		clc				clc
.2a26					_FTExit:
.2a26	fa		plx				plx
.2a27	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.007a					srcPtr:
>007a							.fill 	2
.05ba					currentLineNumber:
>05ba							.fill 	2
.2a28					InlineNonDecimal:
.2a28	a2 02		ldx #$02			ldx 	#2 							; get size in X
.2a2a	c9 25		cmp #$25			cmp 	#"%"
.2a2c	f0 02		beq $2a30			beq 	_INDBinary
.2a2e	a2 10		ldx #$10			ldx 	#16
.2a30					_INDBinary:
.2a30	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.2a32	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.2a34	64 2c		stz $2c				stz 	zTemp0 						; zero result
.2a36	64 2d		stz $2d				stz 	zTemp0+1
.2a38					_INDLoop:
.2a38	20 e9 33	jsr $33e9			jsr 	LookNext 					; check next character
.2a3b	20 25 34	jsr $3425			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.2a3e	90 1f		bcc $2a5f			bcc		_INDDone 					; didn't convert
.2a40	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.2a42	b0 1b		bcs $2a5f			bcs 	_INDDone
.2a44	20 6e 2a	jsr $2a6e			jsr 	_INDShift 					; x 2 or x 16
.2a47	e0 02		cpx #$02			cpx 	#2
.2a49	f0 09		beq $2a54			beq 	_INDNotHex
.2a4b	20 6e 2a	jsr $2a6e			jsr 	_INDShift
.2a4e	20 6e 2a	jsr $2a6e			jsr 	_INDShift
.2a51	20 6e 2a	jsr $2a6e			jsr 	_INDShift
.2a54					_INDNotHex:
.2a54	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.2a56	85 2c		sta $2c				sta 	zTemp0
.2a58	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume
.2a5b	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.2a5d	80 d9		bra $2a38			bra 	_INDLoop
.2a5f					_INDDone:
.2a5f	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.2a61	f0 08		beq $2a6b			beq 	_INDError
.2a63	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.2a65	a5 2c		lda $2c				lda 	zTemp0
.2a67	20 90 2b	jsr $2b90			jsr 	PushIntegerYA
.2a6a	60		rts				rts
.2a6b					_INDError:
.2a6b	4c 53 1f	jmp $1f53		jmp	ErrorV_syntax
.2a6e					_INDShift:
.2a6e	06 2c		asl $2c				asl 	zTemp0
.2a70	26 2d		rol $2d				rol 	zTemp0+1
.2a72	60		rts				rts
.2a73					GetLineNumber:
.2a73	ac bb 05	ldy $05bb			ldy 	currentLineNumber+1
.2a76	ad ba 05	lda $05ba			lda 	currentLineNumber
.2a79	60		rts				rts
.2a7a					WriteCodeByte:
.2a7a	48		pha				pha 								; save on stack
.2a7b	da		phx				phx
.2a7c	5a		phy				phy
.2a7d	aa		tax				tax
.2a7e	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.2a80	20 8d 2b	jsr $2b8d			jsr 	CallAPIHandler
.2a83	7a		ply				ply 								; restore from stack
.2a84	fa		plx				plx
.2a85	68		pla				pla
.2a86	60		rts				rts
.2a87					PrintCharacter
.2a87	48		pha				pha
.2a88	da		phx				phx
.2a89	5a		phy				phy
.2a8a	aa		tax				tax
.2a8b	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.2a8d	20 8d 2b	jsr $2b8d			jsr 	CallAPIHandler
.2a90	7a		ply				ply
.2a91	fa		plx				plx
.2a92	68		pla				pla
.2a93	60		rts				rts
.2a94					ProcessNewLine:
.2a94	86 2c		stx $2c				stx 	zTemp0 						; save address in zTemp0
.2a96	84 2d		sty $2d				sty 	zTemp0+1
.2a98	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.2a99	8a		txa				txa
.2a9a	69 04		adc #$04			adc 	#4
.2a9c	85 7a		sta $7a				sta 	srcPtr
.2a9e	98		tya				tya
.2a9f	69 00		adc #$00			adc 	#0
.2aa1	85 7b		sta $7b				sta 	srcPtr+1
.2aa3	a0 02		ldy #$02			ldy 	#2							; read and save line number
.2aa5	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2aa7	8d ba 05	sta $05ba			sta 	currentLineNumber
.2aaa	c8		iny				iny
.2aab	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2aad	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2ab0	60		rts				rts
.2ab1					BufferClear:
.2ab1	9c bc 05	stz $05bc			stz 	bufferSize
.2ab4	60		rts				rts
.2ab5					BufferWrite:
.2ab5	da		phx				phx
.2ab6	ae bc 05	ldx $05bc			ldx 	bufferSize
.2ab9	9d bd 05	sta $05bd,x			sta 	dataBuffer,x
.2abc	ee bc 05	inc $05bc			inc 	bufferSize
.2abf	fa		plx				plx
.2ac0	60		rts				rts
.2ac1					BufferOutput:
.2ac1	ad bc 05	lda $05bc			lda 	bufferSize
.2ac4	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2ac7	a2 00		ldx #$00			ldx 	#0
.2ac9					_BOLoop:
.2ac9	ec bc 05	cpx $05bc			cpx 	bufferSize
.2acc	f0 09		beq $2ad7			beq 	_BOExit
.2ace	bd bd 05	lda $05bd,x			lda 	dataBuffer,x
.2ad1	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2ad4	e8		inx				inx
.2ad5	80 f2		bra $2ac9			bra 	_BOLoop
.2ad7					_BOExit:
.2ad7	60		rts				rts
.05bc					bufferSize:
>05bc							.fill 	1
.05bd					dataBuffer:
>05bd							.fill 	256
.2ad8					CheckNextComma:
.2ad8	a9 2c		lda #$2c			lda	 	#","
.2ada	80 06		bra $2ae2			bra 	CheckNextA
.2adc					CheckNextRParen:
.2adc	a9 29		lda #$29			lda	 	#")"
.2ade	80 02		bra $2ae2			bra 	CheckNextA
.2ae0					CheckNextLParen:
.2ae0	a9 28		lda #$28			lda 	#"("
.2ae2					CheckNextA:
.2ae2	8d bd 06	sta $06bd			sta 	checkCharacter 				; save test character
.2ae5					_CNALoop:
.2ae5	20 05 34	jsr $3405			jsr 	GetNextNonSpace 			; get next skipping spaces.
.2ae8	cd bd 06	cmp $06bd			cmp 	checkCharacter 				; matches ?
.2aeb	f0 03		beq $2af0			beq 	_CNAExit
.2aed	4c 53 1f	jmp $1f53		jmp	ErrorV_syntax
.2af0					_CNAExit:
.2af0	60		rts				rts
.06bd					checkCharacter:
>06bd							.fill 	1
.2af1					StartCompiler:
.2af1	86 2c		stx $2c				stx 	zTemp0 						; access API
.2af3	84 2d		sty $2d				sty 	zTemp0+1
.2af5	a0 2d		ldy #$2d			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.2af7	a2 49		ldx #$49			ldx 	#CompilerErrorHandler & $FF
.2af9	20 2c 1f	jsr $1f2c			jsr 	SetErrorHandler
.2afc	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.2afe	b2 2c		lda ($2c)			lda 	(zTemp0)
.2b00	8d bf 06	sta $06bf			sta 	APIVector
.2b03	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2b05	8d c0 06	sta $06c0			sta 	APIVector+1
.2b08	c8		iny				iny 								; copy data area range.
.2b09	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2b0b	8d c1 06	sta $06c1			sta 	compilerStartHigh
.2b0e	c8		iny				iny
.2b0f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2b11	8d c2 06	sta $06c2			sta 	compilerEndHigh
.2b14	ba		tsx				tsx 								; save stack pointer
.2b15	8e be 06	stx $06be			stx 	compilerSP
.2b18	20 89 37	jsr $3789			jsr 	STRReset 					; reset storage (line#, variable)
.2b1b	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.2b1d	20 8d 2b	jsr $2b8d			jsr 	CallAPIHandler
.2b20	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.2b22	20 8d 2b	jsr $2b8d			jsr 	CallAPIHandler
.2b25	a9 d5		lda #$d5			lda 	#PCD_CMD_VARSPACE
.2b27	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2b2a	a9 00		lda #$00			lda 	#0
.2b2c	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2b2f	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2b32					MainCompileLoop:
.2b32	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.2b34	20 8d 2b	jsr $2b8d			jsr 	CallAPIHandler
.2b37	90 31		bcc $2b6a			bcc 	SaveCodeAndExit 			; end of source.
.2b39	20 94 2a	jsr $2a94			jsr 	ProcessNewLine 				; set up pointer and line number.
.2b3c	20 73 2a	jsr $2a73			jsr 	GetLineNumber 				; get line #
.2b3f	20 73 35	jsr $3573			jsr 	STRMarkLine 				; remember the code position and number of this line.
.2b42	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.2b44	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2b47					_MCLSameLine:
.2b47	20 05 34	jsr $3405			jsr 	GetNextNonSpace 			; get the first character.
.2b4a	f0 e6		beq $2b32			beq 	MainCompileLoop 			; end of line, get next line.
.2b4c	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.2b4e	f0 f7		beq $2b47			beq 	_MCLSameLine
.2b50	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.2b52	10 0c		bpl $2b60			bpl 	_MCLCheckAssignment
.2b54	a2 b6		ldx #$b6			ldx 	#CommandTables & $FF 		; do command tables.
.2b56	a0 2f		ldy #$2f			ldy 	#CommandTables >> 8
.2b58	20 8b 32	jsr $328b			jsr 	GeneratorProcess
.2b5b	b0 ea		bcs $2b47			bcs 	_MCLSameLine 				; keep trying to compile the line.
.2b5d					_MCLSyntax:
.2b5d	4c 53 1f	jmp $1f53		jmp	ErrorV_syntax
.2b60					_MCLCheckAssignment:
.2b60	20 1b 34	jsr $341b			jsr 	CharIsAlpha 				; if not alpha then syntax error
.2b63	90 f8		bcc $2b5d			bcc 	_MCLSyntax
.2b65	20 41 35	jsr $3541			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.2b68	80 dd		bra $2b47			bra		_MCLSameLine 				; loop back.
.2b6a					SaveCodeAndExit:
.2b6a	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.2b6c	20 8d 2b	jsr $2b8d			jsr 	CallAPIHandler
.2b6f	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.2b71	a8		tay				tay
.2b72	20 73 35	jsr $3573			jsr 	STRMarkLine
.2b75	a9 c5		lda #$c5			lda 	#PCD_EXIT 					; add an END
.2b77	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2b7a	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.2b7c	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2b7f	20 a6 2e	jsr $2ea6			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.2b82	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.2b84	20 8d 2b	jsr $2b8d			jsr 	CallAPIHandler
.2b87	18		clc				clc 								; CC = success
.2b88					ExitCompiler:
.2b88	ae be 06	ldx $06be			ldx 	compilerSP 					; reload SP and exit.
.2b8b	9a		txs				txs
.2b8c	60		rts				rts
.2b8d					CallAPIHandler:
.2b8d	6c bf 06	jmp ($06bf)			jmp 	(APIVector)
.06be					compilerSP:
>06be							.fill 	1
.06bf					APIVector:
>06bf							.fill 	2
.06c1					compilerStartHigh:
>06c1							.fill 	1
.06c2					compilerEndHigh:
>06c2							.fill 	1
.2b90					PushIntegerYA:
.2b90	c0 00		cpy #$00			cpy 	#0 							; 0-255
.2b92	f0 0f		beq $2ba3			beq 	PushIntegerA
.2b94	48		pha				pha
.2b95	a9 cd		lda #$cd			lda 	#PCD_CMD_WORD 				; send .word
.2b97	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2b9a	68		pla				pla 								; then LSB
.2b9b	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2b9e	98		tya				tya 								; then MSB
.2b9f	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2ba2	60		rts				rts
.2ba3					PushIntegerA:
.2ba3	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.2ba5	90 07		bcc $2bae			bcc 	_PIWriteA
.2ba7	48		pha				pha
.2ba8	a9 cc		lda #$cc			lda 	#PCD_CMD_BYTE 				; send .byte
.2baa	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2bad	68		pla				pla
.2bae					_PIWriteA:
.2bae	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2bb1	60		rts				rts
.2bb2					PushFloatCommand:
.2bb2	a9 ce		lda #$ce			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.2bb4	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2bb7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.2bb9	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2bbc	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2bbe	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2bc1	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2bc3	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2bc6	b5 56		lda $56,x			lda 	NSMantissa2,x
.2bc8	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2bcb	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.2bcd	29 80		and #$80			and 	#$80
.2bcf	15 62		ora $62,x			ora 	NSMantissa3,x
.2bd1	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2bd4	60		rts				rts
.2bd5					CreateVariableRecord:
.2bd5	48		pha				pha
.2bd6	ad cd 06	lda $06cd			lda 	freeVariableMemory 		; push current free address on stack.
.2bd9	48		pha				pha
.2bda	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2bdd	48		pha				pha
.2bde	ad cb 06	lda $06cb			lda 	variableListEnd  		; copy end of list to zTemp0
.2be1	85 2c		sta $2c				sta 	zTemp0
.2be3	ad cc 06	lda $06cc			lda 	variableListEnd+1
.2be6	85 2d		sta $2d				sta 	zTemp0+1
.2be8	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.2bea	92 2c		sta ($2c)			sta 	(zTemp0)
.2bec	98		tya				tya
.2bed	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.2bef	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bf1	88		dey				dey
.2bf2	8a		txa				txa
.2bf3	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bf5	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.2bf7	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2bfa	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bfc	c8		iny				iny
.2bfd	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2c00	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2c02	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.2c04	a9 00		lda #$00			lda 	#0
.2c06	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2c08	18		clc				clc
.2c09	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.2c0b	6d cb 06	adc $06cb			adc  	variableListEnd
.2c0e	8d cb 06	sta $06cb			sta 	variableListEnd
.2c11	90 03		bcc $2c16			bcc 	_CVNoCarry2
.2c13	ee cc 06	inc $06cc			inc 	variableListEnd+1
.2c16					_CVNoCarry2:
.2c16	7a		ply				ply
.2c17	fa		plx				plx
.2c18	68		pla				pla
.2c19	60		rts				rts
.2c1a					SetVariableRecordToCodePosition:
.2c1a	48		pha				pha
.2c1b	5a		phy				phy
.2c1c	a0 03		ldy #$03			ldy 	#3
.2c1e	a5 2b		lda $2b				lda 	objPtr+1
.2c20	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2c22	c8		iny				iny
.2c23	a5 2a		lda $2a				lda 	objPtr
.2c25	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2c27	7a		ply				ply
.2c28	68		pla				pla
.2c29	60		rts				rts
.2c2a					AllocateBytesForType:
.2c2a	48		pha				pha
.2c2b	da		phx				phx
.2c2c	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.2c2e	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2c30	c9 00		cmp #$00			cmp 	#NSSIFloat
.2c32	d0 02		bne $2c36			bne 	_CVNotFloat
.2c34	a2 06		ldx #$06			ldx 	#6
.2c36					_CVNotFloat:
.2c36	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.2c37	18		clc				clc
.2c38	6d cd 06	adc $06cd			adc 	freeVariableMemory
.2c3b	8d cd 06	sta $06cd			sta 	freeVariableMemory
.2c3e	90 03		bcc $2c43			bcc 	_CVNoCarry1
.2c40	ee ce 06	inc $06ce			inc 	freeVariableMemory+1
.2c43					_CVNoCarry1:
.2c43	fa		plx				plx
.2c44	68		pla				pla
.2c45	60		rts				rts
.2c46					CommandDATA:
.2c46	20 b1 2a	jsr $2ab1			jsr 	BufferClear 				; copy it to the buffer
.2c49	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace
.2c4c					_CTDataLoop:
.2c4c	20 e9 33	jsr $33e9			jsr 	LookNext 					; reached EOL
.2c4f	f0 08		beq $2c59			beq 	_CTDataDone
.2c51	20 b5 2a	jsr $2ab5			jsr 	BufferWrite 				; write and consume
.2c54	20 fa 33	jsr $33fa			jsr 	GetNext
.2c57	80 f3		bra $2c4c			bra 	_CTDataLoop
.2c59					_CTDataDone:
.2c59	a9 d0		lda #$d0			lda 	#PCD_CMD_DATA 				; output command and buffer
.2c5b	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2c5e	20 c1 2a	jsr $2ac1			jsr 	BufferOutput
.2c61	60		rts				rts
.2c62					CommandDEF:
.2c62	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.2c64	20 a3 2b	jsr $2ba3			jsr 	PushIntegerA
.2c67	20 0a 35	jsr $350a			jsr 	CompileGotoEOL 				; compile skip over DEF
.2c6a	a9 a5		lda #$a5			lda 	#C64_FN
.2c6c	20 e2 2a	jsr $2ae2			jsr 	CheckNextA
.2c6f	20 05 34	jsr $3405			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2c72	20 6a 34	jsr $346a			jsr 	ExtractVariableName
.2c75	8a		txa				txa
.2c76	10 51		bpl $2cc9			bpl 	_CDError
.2c78	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2c79	29 7f		and #$7f			and 	#$7F
.2c7b	aa		tax				tax
.2c7c	98		tya				tya
.2c7d	09 80		ora #$80			ora 	#$80
.2c7f	a8		tay				tay
.2c80	20 4a 2e	jsr $2e4a			jsr 	FindVariable				; does it already exist ?
.2c83	b0 44		bcs $2cc9			bcs 	_CDError 					; if so, that's an error.
.2c85	20 d5 2b	jsr $2bd5			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.2c88	20 1a 2c	jsr $2c1a			jsr 	SetVariableRecordToCodePosition
.2c8b	20 05 34	jsr $3405			jsr 	GetNextNonSpace
.2c8e	20 46 37	jsr $3746			jsr 	GetReferenceTerm 			; get var ref, not array
.2c91	c9 00		cmp #$00			cmp 	#0
.2c93	30 34		bmi $2cc9			bmi 	_CDError
.2c95	8d c3 06	sta $06c3			sta 	defType 					; save type
.2c98	8e c4 06	stx $06c4			stx 	defVariable 				; save var ref
.2c9b	8c c5 06	sty $06c5			sty 	defVariable+1
.2c9e	29 40		and #$40			and 	#NSSString 					; only numbers.
.2ca0	d0 27		bne $2cc9			bne 	_CDError
.2ca2	20 dc 2a	jsr $2adc			jsr 	CheckNextRParen 			; check )
.2ca5	a9 b2		lda #$b2			lda 	#C64_EQUAL
.2ca7	20 e2 2a	jsr $2ae2			jsr 	CheckNextA 					; check =
.2caa	18		clc				clc 								; if this is DEF FNxx(A), read A
.2cab	20 cc 2c	jsr $2ccc			jsr 	CDReadWriteVariable
.2cae	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.2cb0	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2cb3	38		sec				sec
.2cb4	20 cc 2c	jsr $2ccc			jsr 	CDReadWriteVariable 		; A is now updated
.2cb7	20 90 2d	jsr $2d90			jsr 	CompileExpressionAt0 		; the actual body of the function.
.2cba	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.2cbc	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2cbf	38		sec				sec
.2cc0	20 cc 2c	jsr $2ccc			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.2cc3	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.2cc5	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2cc8	60		rts				rts
.2cc9					_CDError:
.2cc9	4c 53 1f	jmp $1f53		jmp	ErrorV_syntax
.2ccc					CDReadWriteVariable:
.2ccc	ac c5 06	ldy $06c5			ldy 	defVariable+1 				; set up YX
.2ccf	ae c4 06	ldx $06c4			ldx 	defVariable
.2cd2	ad c3 06	lda $06c3			lda 	defType
.2cd5	20 f8 36	jsr $36f8			jsr 	GetSetVariable
.2cd8	60		rts				rts
.06c3					defType:
>06c3							.fill 	1
.06c4					defVariable:
>06c4							.fill 	2
.2cd9					CommandDIM:
.2cd9	20 05 34	jsr $3405			jsr 	GetNextNonSpace 			; get the first non space character
.2cdc	20 6a 34	jsr $346a			jsr 	ExtractVariableName 		; variable name to XY
.2cdf	da		phx				phx 								; save name with type bits.
.2ce0	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.2ce2	10 37		bpl $2d1b			bpl 	_CDError
.2ce4	20 4a 2e	jsr $2e4a			jsr 	FindVariable	 			; see if already exist
.2ce7	b0 35		bcs $2d1e			bcs 	_CDRedefine 				; it still exists.
.2ce9	20 d5 2b	jsr $2bd5			jsr 	CreateVariableRecord 		; create the basic variable
.2cec	20 2a 2c	jsr $2c2a			jsr 	AllocateBytesForType 		; allocate memory for it
.2cef	68		pla				pla 								; restore type bits
.2cf0	5a		phy				phy 								; save the address of the basic storage
.2cf1	da		phx				phx
.2cf2	48		pha				pha
.2cf3	20 21 2d	jsr $2d21			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.2cf6	68		pla				pla
.2cf7	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.2cf9	20 a3 2b	jsr $2ba3			jsr 	PushIntegerA 				; push that type data out.
.2cfc	a9 cb		lda #$cb			lda 	#(PCD_DIM) >> 8
.2cfe	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2d01	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.2d03	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2d06	fa		plx				plx 								; restore address
.2d07	7a		ply				ply
.2d08	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2d0a	38		sec				sec
.2d0b	20 f8 36	jsr $36f8			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.2d0e	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; , follows ?
.2d11	c9 2c		cmp #$2c			cmp 	#","
.2d13	d0 05		bne $2d1a			bne 	_CDExit
.2d15	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume comma
.2d18	80 bf		bra $2cd9			bra 	CommandDIM 					; do another DIM
.2d1a					_CDExit:
.2d1a	60		rts				rts
.2d1b					_CDError:
.2d1b	4c 53 1f	jmp $1f53		jmp	ErrorV_syntax
.2d1e					_CDRedefine:
.2d1e	4c 1b 20	jmp $201b		jmp	ErrorV_redefine
.2d21					OutputIndexGroup:
.2d21	9c c6 06	stz $06c6			stz 	IndexCount 					; count of number of indices.
.2d24					_OIGNext:
.2d24	20 90 2d	jsr $2d90			jsr 	CompileExpressionAt0 		; get a dimension
.2d27	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2d29	c9 00		cmp #$00			cmp 	#NSSIFloat
.2d2b	d0 19		bne $2d46			bne 	_OIGType
.2d2d	ee c6 06	inc $06c6			inc 	IndexCount 					; bump the counter.
.2d30	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; does a , follow ?
.2d33	c9 2c		cmp #$2c			cmp 	#","
.2d35	d0 05		bne $2d3c			bne 	_OIGCheckEnd
.2d37	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume comma
.2d3a	80 e8		bra $2d24			bra 	_OIGNext 					; get next dimension
.2d3c					_OIGCheckEnd:
.2d3c	20 dc 2a	jsr $2adc			jsr 	CheckNextRParen 			; check and consume )
.2d3f	ad c6 06	lda $06c6			lda 	IndexCount
.2d42	20 a3 2b	jsr $2ba3			jsr 	PushIntegerA 				; compile the dimension count.
.2d45	60		rts				rts
.2d46					_OIGType:
.2d46	4c 63 1f	jmp $1f63		jmp	ErrorV_type
.06c6					IndexCount:
>06c6							.fill 	1
.2d49					CompilerErrorHandler:
.2d49	68		pla				pla
.2d4a	7a		ply				ply
.2d4b	85 2c		sta $2c				sta 	zTemp0
.2d4d	84 2d		sty $2d				sty 	zTemp0+1
.2d4f	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.2d51	a0 01		ldy #$01			ldy 	#1
.2d53					_EHDisplayMsg:
.2d53	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d55	20 87 2a	jsr $2a87			jsr 	PrintCharacter
.2d58	c8		iny				iny
.2d59	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d5b	d0 f6		bne $2d53			bne 	_EHDisplayMsg
.2d5d	a9 20		lda #$20			lda 	#32
.2d5f	20 87 2a	jsr $2a87			jsr 	PrintCharacter
.2d62	a9 40		lda #$40			lda 	#64
.2d64	20 87 2a	jsr $2a87			jsr 	PrintCharacter
.2d67	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.2d69	20 ad 26	jsr $26ad			jsr 	FloatSetByte
.2d6c	20 73 2a	jsr $2a73			jsr 	GetLineNumber
.2d6f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2d71	98		tya				tya
.2d72	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2d74	20 93 25	jsr $2593			jsr 	FloatToString
.2d77	a0 00		ldy #$00			ldy 	#0 							; display that string.
.2d79	a2 00		ldx #$00			ldx 	#0
.2d7b					_EHDisplayLine:
.2d7b	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d7e	20 87 2a	jsr $2a87			jsr 	PrintCharacter
.2d81	c8		iny				iny
.2d82	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d85	d0 f4		bne $2d7b			bne 	_EHDisplayLine
.2d87	a9 0d		lda #$0d			lda 	#13
.2d89	20 87 2a	jsr $2a87			jsr 	PrintCharacter
.2d8c	38		sec				sec 								; CS = error
.2d8d	4c 88 2b	jmp $2b88			jmp 	ExitCompiler
.2d90					CompileExpressionAt0:
.2d90	a9 00		lda #$00			lda 	#0
.2d92					CompileExpressionAtA:
.2d92	48		pha				pha  								; save level
.2d93	20 d0 37	jsr $37d0			jsr 	CompileTerm 				; compile a term.
.2d96	fa		plx				plx 								; get level back into X
.2d97					_ECALoop:
.2d97	48		pha				pha 								; save type on stack.
.2d98	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; get the next character
.2d9b	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.2d9d	90 04		bcc $2da3			bcc 	_ECAExit
.2d9f	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.2da1	90 02		bcc $2da5			bcc 	_ECAHaveToken
.2da3					_ECAExit:
.2da3	68		pla				pla 								; throw type off stack
.2da4	60		rts				rts
.2da5					_ECAHaveToken:
.2da5	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.2da7	aa		tax				tax 								; X contains the operator token
.2da8	bd 93 2d	lda $2d93,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.2dab	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.2dad	90 f4		bcc $2da3			bcc 	_ECAExit
.2daf	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.2db1	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume the token.
.2db4	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.2db6	f0 11		beq $2dc9			beq 	_ECAGreaterCheck
.2db8	e0 b3		cpx #$b3			cpx 	#C64_LESS
.2dba	d0 1a		bne $2dd6			bne 	_ECAHaveFullToken
.2dbc	20 e9 33	jsr $33e9			jsr 	LookNext 					; checks for < (<= or <>)
.2dbf	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.2dc1	f0 0e		beq $2dd1			beq	 	_ECAToNotEqual
.2dc3	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.2dc5	d0 0f		bne $2dd6			bne 	_ECAHaveFullToken
.2dc7	80 07		bra $2dd0			bra 	_ECAAddEqual
.2dc9					_ECAGreaterCheck:
.2dc9	20 e9 33	jsr $33e9			jsr 	LookNext
.2dcc	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.2dce	d0 06		bne $2dd6			bne 	_ECAHaveFullToken
.2dd0					_ECAAddEqual:
.2dd0	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.2dd1					_ECAToNotEqual:
.2dd1	e8		inx				inx
.2dd2	e8		inx				inx
.2dd3	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume the = or > in >= <= <>
.2dd6					_ECAHaveFullToken:
.2dd6	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.2dd8	d0 0a		bne $2de4			bne 	_ECANotConcat
.2dda	68		pla				pla 								; get type back
.2ddb	48		pha				pha
.2ddc	29 40		and #$40			and 	#NSSTypeMask
.2dde	c9 40		cmp #$40			cmp 	#NSSString
.2de0	d0 02		bne $2de4			bne 	_ECANotConcat
.2de2	a2 e0		ldx #$e0			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2de4					_ECANotConcat:
.2de4	da		phx				phx 								; save operator on the stack
.2de5	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.2de7	da		phx				phx
.2de8	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.2dea	1a		inc a				inc 	a
.2deb	20 92 2d	jsr $2d92			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.2dee	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.2df0	fa		plx				plx 								; restore current precedence in X
.2df1	68		pla				pla 								; restore operator
.2df2	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.2df4	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.2df6	90 17		bcc $2e0f			bcc 	_ECANotCompare
.2df8	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.2dfa	b0 13		bcs $2e0f			bcs 	_ECANotCompare
.2dfc	7a		ply				ply 								; get type into Y
.2dfd	5a		phy				phy
.2dfe	48		pha				pha 								; save operator
.2dff	98		tya				tya 								; get type
.2e00	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.2e02	29 40		and #$40			and 	#NSSTypeMask
.2e04	c9 40		cmp #$40			cmp 	#NSSString
.2e06	f0 02		beq $2e0a			beq 	_ECANotString
.2e08	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.2e0a					_ECANotString:
.2e0a	98		tya				tya									; output token Y
.2e0b	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2e0e	68		pla				pla 								; restore operator.
.2e0f					_ECANotCompare:
.2e0f	18		clc				clc 								; convert to P-Code and compile.
.2e10	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.2e12	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2e15	68		pla				pla 								; type of current result
.2e16	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.2e18	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.2e1a	d0 19		bne $2e35			bne		_ECAType
.2e1c	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.2e1e	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.2e20	d0 18		bne $2e3a			bne 	_ECAGoLoop
.2e22	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.2e24	c9 e0		cmp #$e0			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2e26	f0 10		beq $2e38			beq 	_ECAOkayString 				; (this is post conversion)
.2e28	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.2e2a	90 09		bcc $2e35			bcc 	_ECAType
.2e2c	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.2e2e	b0 05		bcs $2e35			bcs 	_ECAType
.2e30	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.2e32	4c 97 2d	jmp $2d97			jmp 	_ECALoop
.2e35					_ECAType:
.2e35	4c 63 1f	jmp $1f63		jmp	ErrorV_type
.2e38					_ECAOkayString:
.2e38	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.2e3a					_ECAGoLoop:
.2e3a	4c 97 2d	jmp $2d97			jmp 	_ECALoop
.2e3d					PrecedenceTable:
>2e3d	03						.byte 	3 					; '+'
>2e3e	03						.byte 	3 					; '-'
>2e3f	04						.byte 	4 					; '*'
>2e40	04						.byte 	4 					; '/'
>2e41	05						.byte 	5 					; '^'
>2e42	01						.byte 	1 					; 'and'
>2e43	00						.byte 	0 					; 'or'
>2e44	02						.byte 	2 					; '>'
>2e45	02						.byte 	2 					; '='
>2e46	02						.byte 	2 					; '<'
>2e47	02						.byte 	2 					; '>='
>2e48	02						.byte 	2 					; '<='
>2e49	02						.byte 	2 					; '<>'
.2e4a					FindVariable:
.2e4a	86 2e		stx $2e				stx 	zTemp1 						; save name.
.2e4c	84 2f		sty $2f				sty 	zTemp1+1
.2e4e					_IVCheckSpecial:
.2e4e	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.2e50	d0 18		bne $2e6a			bne 	_IVStandard
.2e52	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.2e54	f0 0c		beq $2e62			beq 	_IVTIFloat
.2e56	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.2e58	d0 10		bne $2e6a			bne 	_IVStandard
.2e5a	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.2e5c	a2 01		ldx #$01			ldx 	#$01
.2e5e	a9 40		lda #$40			lda 	#NSSString
.2e60	38		sec				sec
.2e61	60		rts				rts
.2e62					_IVTIFloat:
.2e62	a0 80		ldy #$80			ldy 	#$80
.2e64	a2 00		ldx #$00			ldx 	#$00
.2e66	a9 00		lda #$00			lda 	#0
.2e68	38		sec				sec
.2e69	60		rts				rts
.2e6a					_IVStandard:
.2e6a	ad c1 06	lda $06c1			lda 	compilerStartHigh			; start scanning from here.
.2e6d	85 2d		sta $2d				sta 	zTemp0+1
.2e6f	64 2c		stz $2c				stz 	zTemp0
.2e71					_IVCheckLoop:
.2e71	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.2e73	f0 2b		beq $2ea0			beq  	_IVNotFound 				; if so, return with CC.
.2e75	a0 01		ldy #$01			ldy 	#1 							; match ?
.2e77	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e79	c5 2e		cmp $2e				cmp 	zTemp1
.2e7b	d0 07		bne $2e84			bne	 	_IVNext
.2e7d	c8		iny				iny
.2e7e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e80	c5 2f		cmp $2f				cmp 	zTemp1+1
.2e82	f0 0d		beq $2e91			beq 	_IVFound
.2e84					_IVNext:
.2e84	18		clc				clc
.2e85	a5 2c		lda $2c				lda 	zTemp0
.2e87	72 2c		adc ($2c)			adc 	(zTemp0)
.2e89	85 2c		sta $2c				sta 	zTemp0
.2e8b	90 e4		bcc $2e71			bcc 	_IVCheckLoop
.2e8d	e6 2d		inc $2d				inc 	zTemp0+1
.2e8f	80 e0		bra $2e71			bra 	_IVCheckLoop
.2e91					_IVFound:
.2e91	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.2e93	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e95	aa		tax				tax
.2e96	c8		iny				iny
.2e97	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e99	48		pha				pha
.2e9a	c8		iny				iny
.2e9b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e9d	7a		ply				ply
.2e9e	38		sec				sec
.2e9f	60		rts				rts
.2ea0					_IVNotFound:
.2ea0	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.2ea2	a4 2f		ldy $2f				ldy 	zTemp1+1
.2ea4	18		clc				clc
.2ea5	60		rts				rts
.2ea6					FixBranches:
.2ea6	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.2ea8	20 8d 2b	jsr $2b8d			jsr 	CallAPIHandler
.2eab					_FBLoop:
.2eab	b2 2a		lda ($2a)			lda 	(objPtr) 					; get the next one.
.2ead	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.2eaf	f0 1a		beq $2ecb			beq 	_FBFixGotoGosub
.2eb1	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOSUB
.2eb3	f0 16		beq $2ecb			beq 	_FBFixGotoGosub
.2eb5	c9 d4		cmp #$d4			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.2eb7	f0 12		beq $2ecb			beq 	_FBFixGotoGosub
.2eb9	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_Z
.2ebb	f0 0e		beq $2ecb			beq 	_FBFixGotoGosub
.2ebd	c9 d5		cmp #$d5			cmp 	#PCD_CMD_VARSPACE
.2ebf	f0 43		beq $2f04			beq 	_FBFixVarSpace
.2ec1	c9 d6		cmp #$d6			cmp 	#PCD_CMD_RESTORE 			; patch restore.
.2ec3	f0 06		beq $2ecb			beq 	_FBFixRestore
.2ec5					_FBNext:
.2ec5	20 79 20	jsr $2079			jsr 	MoveObjectForward 			; move forward in object code.
.2ec8	90 e1		bcc $2eab			bcc 	_FBLoop 					; not finished
.2eca					_FBExit:
.2eca	60		rts				rts
.2ecb					_FBFixGotoGosub:
.2ecb					_FBFixRestore:
.2ecb	a0 01		ldy #$01			ldy 	#1							; line number in YA
.2ecd	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ecf	48		pha				pha
.2ed0	c8		iny				iny
.2ed1	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ed3	a8		tay				tay
.2ed4	68		pla				pla
.2ed5	20 9c 35	jsr $359c			jsr 	STRFindLine			 		; find where it is YA
.2ed8	90 0c		bcc $2ee6			bcc 	_FBFFound 					; not found, so must be >
.2eda	48		pha				pha
.2edb	b2 2a		lda ($2a)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.2edd	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_Z 			; or RESTORE. These go to the next line
.2edf	f0 04		beq $2ee5			beq 	_FBFAllowZero 				; after ; for IF forward scanning, and
.2ee1	c9 d6		cmp #$d6			cmp 	#PCD_CMD_RESTORE 			; because RESTORE <n> <n> is optional.
.2ee3	d0 0f		bne $2ef4			bne 	_FBFFail
.2ee5					_FBFAllowZero:
.2ee5	68		pla				pla
.2ee6					_FBFFound:
.2ee6	20 ec 35	jsr $35ec			jsr 	STRMakeOffset 				; make it an offset from X:YA
.2ee9	5a		phy				phy	 								; patch the GOTO/GOSUB
.2eea	a0 01		ldy #$01			ldy 	#1
.2eec	91 2a		sta ($2a),y			sta 	(objPtr),y
.2eee	c8		iny				iny
.2eef	68		pla				pla
.2ef0	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ef2	80 d1		bra $2ec5			bra 	_FBNext
.2ef4					_FBFFail:
.2ef4	a0 02		ldy #$02			ldy 	#2
.2ef6	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ef8	8d ba 05	sta $05ba			sta 	currentLineNumber
.2efb	c8		iny				iny
.2efc	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2efe	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2f01	4c 96 1f	jmp $1f96		jmp	ErrorV_line
.2f04					_FBFixVarSpace:
.2f04	a0 01		ldy #$01			ldy 	#1
.2f06	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2f09	91 2a		sta ($2a),y			sta 	(objPtr),y
.2f0b	c8		iny				iny
.2f0c	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2f0f	91 2a		sta ($2a),y			sta 	(objPtr),y
.2f11	80 b2		bra $2ec5			bra 	_FBNext
.2f13					CommandFOR:
.2f13	20 05 34	jsr $3405			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.2f16	20 1b 34	jsr $341b			jsr 	CharIsAlpha 				; if not alpha , error
.2f19	90 59		bcc $2f74			bcc 	_CFFail
.2f1b	20 46 37	jsr $3746			jsr 	GetReferenceTerm 			; figure out the reference.
.2f1e	48		pha				pha 								; save type
.2f1f	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f21	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f23	d0 4f		bne $2f74			bne 	_CFFail
.2f25	5a		phy				phy 								; save reference on the stack
.2f26	da		phx				phx
.2f27	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.2f29	20 e2 2a	jsr $2ae2			jsr 	CheckNextA
.2f2c	20 90 2d	jsr $2d90			jsr 	CompileExpressionAt0 		; initial value
.2f2f	fa		plx				plx 								; get reference back.
.2f30	7a		ply				ply
.2f31	5a		phy				phy
.2f32	da		phx				phx
.2f33	38		sec				sec 								; set initial value.
.2f34	20 f8 36	jsr $36f8			jsr 	GetSetVariable
.2f37	fa		plx				plx
.2f38	7a		ply				ply
.2f39	68		pla				pla
.2f3a	29 20		and #$20			and 	#NSSIInt16
.2f3c	f0 04		beq $2f42			beq 	_CFNotInt16
.2f3e	98		tya				tya
.2f3f	09 80		ora #$80			ora 	#$80
.2f41	a8		tay				tay
.2f42					_CFNotInt16:
.2f42	8a		txa				txa 								; reference in YA
.2f43	20 90 2b	jsr $2b90			jsr 	PushIntegerYA
.2f46	a9 a4		lda #$a4			lda 	#C64_TO
.2f48	20 e2 2a	jsr $2ae2			jsr 	CheckNextA
.2f4b	20 90 2d	jsr $2d90			jsr 	CompileExpressionAt0 		; terminal value
.2f4e	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f50	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f52	d0 20		bne $2f74			bne 	_CFFail
.2f54	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; followed by STEP
.2f57	c9 a9		cmp #$a9			cmp 	#C64_STEP
.2f59	d0 0e		bne $2f69			bne 	_CFNoStep
.2f5b	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume it.
.2f5e	20 90 2d	jsr $2d90			jsr 	CompileExpressionAt0 		; terminal value
.2f61	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f63	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f65	d0 0d		bne $2f74			bne 	_CFFail
.2f67	80 05		bra $2f6e			bra 	_CFParametersDone
.2f69					_CFNoStep:
.2f69	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.2f6b	20 a3 2b	jsr $2ba3			jsr 	PushIntegerA
.2f6e					_CFParametersDone:
.2f6e	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2f70	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2f73	60		rts				rts
.2f74					_CFFail:
.2f74	4c 53 1f	jmp $1f53		jmp	ErrorV_syntax
.2f77					FNCompile:
.2f77	20 05 34	jsr $3405			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2f7a	20 6a 34	jsr $346a			jsr 	ExtractVariableName
.2f7d	e0 00		cpx #$00			cpx 	#0
.2f7f	10 32		bpl $2fb3			bpl 	_FNError
.2f81	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2f82	29 7f		and #$7f			and 	#$7F
.2f84	aa		tax				tax
.2f85	98		tya				tya
.2f86	09 80		ora #$80			ora 	#$80
.2f88	a8		tay				tay
.2f89	20 4a 2e	jsr $2e4a			jsr 	FindVariable				; does it already exist ?
.2f8c	90 25		bcc $2fb3			bcc 	_FNError 					; no.
.2f8e	20 ec 35	jsr $35ec			jsr 	STRMakeOffset 				; convert to a relative address.
.2f91	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2f93	d0 01		bne $2f96			bne 	_FNNoBorrow
.2f95	88		dey				dey
.2f96					_FNNoBorrow:
.2f96	3a		dec a				dec 	a
.2f97	5a		phy				phy 								; save location of routine on stack.
.2f98	48		pha				pha
.2f99	da		phx				phx
.2f9a	20 90 2d	jsr $2d90			jsr 	CompileExpressionAt0
.2f9d	20 dc 2a	jsr $2adc			jsr 	CheckNextRParen
.2fa0	a9 d2		lda #$d2			lda 	#PCD_CMD_GOSUB
.2fa2	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2fa5	68		pla				pla
.2fa6	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2fa9	68		pla				pla
.2faa	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2fad	68		pla				pla
.2fae	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.2fb1	18		clc				clc
.2fb2	60		rts				rts
.2fb3					_FNError:
.2fb3	4c 46 1f	jmp $1f46		jmp	ErrorV_value
.2fb6					CommandTables:
>2fb6	07 cb 00 03 c8 34 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2fbd	07 89 00 03 cf 34 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2fc4	07 8d 00 03 c2 34 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>2fcb	07 8c 00 03 b1 37 06			.byte	$07,$8c,$00,$03,CommandRESTORE & $FF,CommandRESTORE >> 8,$06
>2fd2	07 88 00 03 3e 35 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2fd9	07 85 00 03 1e 35 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>2fe0	07 84 00 04 32 35 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>2fe7	07 99 00 03 73 36 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2fee	07 98 00 04 73 36 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2ff5	07 8f 00 03 7e 37 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>2ffc	07 81 00 03 13 2f 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>3003	07 82 00 03 f6 35 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>300a	07 a1 00 03 3b 34 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>3011	07 83 00 03 46 2c 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>3018	07 87 00 03 bc 36 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>301f	07 86 00 03 d9 2c 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>3026	07 96 00 03 62 2c 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>302d	07 8b 00 e3 eb 34 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>3034	08 92 00 ea e3 69 38 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>303c	09 91 00 e1 a9 03 22 36			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>3044	06
>3045	07 9e 00 e2 cb 92 06			.byte	$07,$9e,$00,$e2,37579 & $FF,37579 >> 8,$06
>304c	07 97 00 ea e1 ad 06			.byte	$07,$97,$00,$ea,$e1,173,$06
>3053	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>3059	07 90 00 20 cb 91 06			.byte	$07,$90,$00,$20,37323 & $FF,37323 >> 8,$06
>3060	07 80 00 20 cb 82 06			.byte	$07,$80,$00,$20,33483 & $FF,33483 >> 8,$06
>3067	07 9d 00 e3 8f 38 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>306e	0a 9f 00 ea e3 a2 38 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,199,$06
>3076	c7 06
>3078	06 a0 00 e1 c4 06			.byte	$06,$a0,$00,$e1,196,$06
>307e	07 ce 90 20 cb ac 06			.byte	$07,$ce,$90,$20,44235 & $FF,44235 >> 8,$06
>3085	0a ce 92 e3 b8 33 20 cb			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44491 & $FF,44491 >> 8,$06
>308d	ad 06
>308f	0a ce 8d e3 b8 33 20 cb			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44747 & $FF,44747 >> 8,$06
>3097	ae 06
>3099	06 ce 86 e1 c8 06			.byte	$06,$ce,$86,$e1,200,$06
>309f	08 ce 84 ea ea e1 c9 06			.byte	$08,$ce,$84,$ea,$ea,$e1,201,$06
>30a7	07 ce af e2 cb 98 06			.byte	$07,$ce,$af,$e2,39115 & $FF,39115 >> 8,$06
>30ae	07 ce 8c e2 cb 8c 06			.byte	$07,$ce,$8c,$e2,36043 & $FF,36043 >> 8,$06
>30b5	09 ce ae ea ea e2 cb 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38347 & $FF,38347 >> 8,$06
>30bd	06
>30be	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>30c6	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>30ce	9a 06
>30d0	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>30d8	9b 06
>30da	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>30e2	9c 06
>30e4	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>30ec	06
>30ed	07 ce 99 20 cb 99 06			.byte	$07,$ce,$99,$20,39371 & $FF,39371 >> 8,$06
>30f4	08 ce 9a ea e2 cb 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39627 & $FF,39627 >> 8,$06
>30fc	08 ce 9b ea e2 cb 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39883 & $FF,39883 >> 8,$06
>3104	08 ce 9c ea e2 cb 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40139 & $FF,40139 >> 8,$06
>310c	08 ce 9d ea e2 cb 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40395 & $FF,40395 >> 8,$06
>3114	08 ce 9e ea e2 cb 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40651 & $FF,40651 >> 8,$06
>311c	08 ce 9f ea e2 cb 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40907 & $FF,40907 >> 8,$06
>3124	08 ce a0 ea e2 cb a0 06			.byte	$08,$ce,$a0,$ea,$e2,41163 & $FF,41163 >> 8,$06
>312c	08 ce a1 ea f2 cb a1 06			.byte	$08,$ce,$a1,$ea,$f2,41419 & $FF,41419 >> 8,$06
>3134	08 ce a2 ea f2 cb a2 06			.byte	$08,$ce,$a2,$ea,$f2,41675 & $FF,41675 >> 8,$06
>313c	08 ce a3 ea e2 cb a3 06			.byte	$08,$ce,$a3,$ea,$e2,41931 & $FF,41931 >> 8,$06
>3144	07 ce a4 20 cb a4 06			.byte	$07,$ce,$a4,$20,42187 & $FF,42187 >> 8,$06
>314b	08 ce a5 ea e2 cb a5 06			.byte	$08,$ce,$a5,$ea,$e2,42443 & $FF,42443 >> 8,$06
>3153	08 ce a6 ea e2 cb a6 06			.byte	$08,$ce,$a6,$ea,$e2,42699 & $FF,42699 >> 8,$06
>315b	08 ce a7 ea e2 cb a7 06			.byte	$08,$ce,$a7,$ea,$e2,42955 & $FF,42955 >> 8,$06
>3163	08 ce a8 ea e2 cb a8 06			.byte	$08,$ce,$a8,$ea,$e2,43211 & $FF,43211 >> 8,$06
>316b	08 ce a9 ea e2 cb a9 06			.byte	$08,$ce,$a9,$ea,$e2,43467 & $FF,43467 >> 8,$06
>3173	08 ce aa ea f2 cb aa 06			.byte	$08,$ce,$aa,$ea,$f2,43723 & $FF,43723 >> 8,$06
>317b	08 ce ab ea f2 cb ab 06			.byte	$08,$ce,$ab,$ea,$f2,43979 & $FF,43979 >> 8,$06
>3183	00						.byte 	0
.3184					UnaryTables:
>3184	07 b4 00 8e 91 b7 06			.byte	$07,$b4,$00,$8e,$91,183,$06
>318b	08 b5 00 8e 92 cb 84 06			.byte	$08,$b5,$00,$8e,$92,33995 & $FF,33995 >> 8,$06
>3193	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>319a	07 b7 00 8e 91 c2 06			.byte	$07,$b7,$00,$8e,$91,194,$06
>31a1	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>31a8	07 b9 00 8e 91 ae 06			.byte	$07,$b9,$00,$8e,$91,174,$06
>31af	08 ba 00 8e 92 cb 85 06			.byte	$08,$ba,$00,$8e,$92,34251 & $FF,34251 >> 8,$06
>31b7	07 bb 00 8e 91 b5 06			.byte	$07,$bb,$00,$8e,$91,181,$06
>31be	08 bc 00 8e 92 cb 86 06			.byte	$08,$bc,$00,$8e,$92,34507 & $FF,34507 >> 8,$06
>31c6	08 bd 00 8e 92 cb 87 06			.byte	$08,$bd,$00,$8e,$92,34763 & $FF,34763 >> 8,$06
>31ce	08 be 00 8e 92 cb 88 06			.byte	$08,$be,$00,$8e,$92,35019 & $FF,35019 >> 8,$06
>31d6	08 bf 00 8e 92 cb 89 06			.byte	$08,$bf,$00,$8e,$92,35275 & $FF,35275 >> 8,$06
>31de	08 c0 00 8e 92 cb 8a 06			.byte	$08,$c0,$00,$8e,$92,35531 & $FF,35531 >> 8,$06
>31e6	08 c1 00 8e 92 cb 8b 06			.byte	$08,$c1,$00,$8e,$92,35787 & $FF,35787 >> 8,$06
>31ee	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>31f5	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>31fc	07 c4 00 8e 91 bb 07			.byte	$07,$c4,$00,$8e,$91,187,$07
>3203	07 c5 00 8f 91 c3 06			.byte	$07,$c5,$00,$8f,$91,195,$06
>320a	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>3211	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>3218	08 c8 00 8f ae 91 bc 07			.byte	$08,$c8,$00,$8f,$ae,$91,188,$07
>3220	08 c9 00 8f ae 91 bd 07			.byte	$08,$c9,$00,$8f,$ae,$91,189,$07
>3228	0b ca 00 8f ae 03 b8 33			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,190,$07
>3230	91 be 07
>3233	07 a8 00 03 d7 33 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>323a	07 a5 00 03 77 2f 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>3241	06 ff 00 10 ac 06			.byte	$06,$ff,$00,$10,172,$06
>3247	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>324e	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>3255	08 ce d0 8e ae 91 ca 06			.byte	$08,$ce,$d0,$8e,$ae,$91,202,$06
>325d	08 ce d4 8e 92 cb 83 06			.byte	$08,$ce,$d4,$8e,$92,33739 & $FF,33739 >> 8,$06
>3265	07 ce d3 20 cb 8d 06			.byte	$07,$ce,$d3,$20,36299 & $FF,36299 >> 8,$06
>326c	07 ce d1 20 cb 8e 06			.byte	$07,$ce,$d1,$20,36555 & $FF,36555 >> 8,$06
>3273	07 ce d2 20 cb 8f 06			.byte	$07,$ce,$d2,$20,36811 & $FF,36811 >> 8,$06
>327a	07 ce db 20 cb 90 06			.byte	$07,$ce,$db,$20,37067 & $FF,37067 >> 8,$06
>3281	09 ce d7 8e ae 92 cb 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38603 & $FF,38603 >> 8,$06
>3289	06
>328a	00						.byte 	0
.328b					GeneratorProcess:
.328b	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.328d	84 2d		sty $2d				sty 	zTemp0+1
.328f	85 2e		sta $2e				sta 	zTemp1 						; first match token
.3291	64 2f		stz $2f				stz 	zTemp1+1
.3293	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.3295	d0 05		bne $329c			bne 	_GPNotShifted
.3297	20 fa 33	jsr $33fa			jsr 	GetNext 					; get the shifted token
.329a	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.329c					_GPNotShifted:
.329c					_GPSearch:
.329c	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.329e	18		clc				clc
.329f	f0 2f		beq $32d0			beq 	_GPExit
.32a1	a0 01		ldy #$01			ldy 	#1 							; tokens match
.32a3	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.32a5	c5 2e		cmp $2e				cmp 	zTemp1
.32a7	d0 09		bne $32b2			bne 	_GPNext
.32a9	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.32ab	f0 12		beq $32bf			beq 	_GPFound
.32ad	c8		iny				iny 								; check match.
.32ae	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.32b0	f0 0d		beq $32bf			beq 	_GPFound
.32b2					_GPNext:
.32b2	18		clc				clc 								; follow to next
.32b3	a5 2c		lda $2c				lda 	zTemp0
.32b5	72 2c		adc ($2c)			adc 	(zTemp0)
.32b7	85 2c		sta $2c				sta 	zTemp0
.32b9	90 e1		bcc $329c			bcc 	_GPSearch
.32bb	e6 2d		inc $2d				inc 	zTemp0+1
.32bd	80 dd		bra $329c			bra 	_GPSearch
.32bf					_GPFound:
.32bf	18		clc				clc 								; skip to action bytes
.32c0	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.32c2	69 03		adc #$03			adc 	#3
.32c4	85 2c		sta $2c				sta 	zTemp0
.32c6	90 02		bcc $32ca			bcc 	_GPNoCarry
.32c8	e6 2d		inc $2d				inc 	zTemp0+1
.32ca					_GPNoCarry:
.32ca					_GPLoop:
.32ca	20 d1 32	jsr $32d1			jsr 	GeneratorExecute 			; execute one command
.32cd	90 fb		bcc $32ca			bcc 	_GPLoop 					; go back if not completed.
.32cf	38		sec				sec 								; return with CS.
.32d0					_GPExit:
.32d0	60		rts				rts
.32d1					GeneratorExecute:
.32d1	20 7d 33	jsr $337d			jsr 	_GEFetchZTemp0 				; get next.
.32d4	48		pha				pha 								; split into 2 nibbles
.32d5	4a		lsr a				lsr 	a
.32d6	4a		lsr a				lsr 	a
.32d7	4a		lsr a				lsr		a
.32d8	4a		lsr a				lsr 	a
.32d9	20 e3 32	jsr $32e3			jsr 	_GEExecuteNibble 			; MSB first
.32dc	68		pla				pla
.32dd	b0 03		bcs $32e2			bcs 	_GEHaveCompleted
.32df	20 e3 32	jsr $32e3			jsr 	_GEExecuteNibble 			; LSB second
.32e2					_GEHaveCompleted:
.32e2	60		rts				rts
.32e3					_GEExecuteNibble:
.32e3	29 0f		and #$0f			and 	#$0F
.32e5	0a		asl a				asl 	a
.32e6	aa		tax				tax
.32e7	7c ea 32	jmp ($32ea,x)			jmp 	(_GEExecuteVectors,x)
.32ea					_GEExecuteVectors:
>32ea	0a 33						.word 	_GEXNop 					; 0  (no operation)
>32ec	12 33						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>32ee	0c 33						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>32f0	60 33						.word 	_GEXExecute 				; 3  (run arbitrary code)
>32f2	53 33						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>32f4	0a 33						.word 	_GEXNop 					; 5
>32f6	1a 33						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>32f8	1e 33						.word 	_GEXExitString 				; 7  exit return string type
>32fa	22 33						.word 	_GEXLParam 					; 8  check ( follows
>32fc	26 33						.word 	_GEXRParam 					; 9  check ) follows
>32fe	2a 33						.word 	_GEXComma					; A  check , follows
>3300	0a 33						.word 	_GEXNop 					; B
>3302	0a 33						.word 	_GEXNop 					; C
>3304	0a 33						.word 	_GEXNop 					; D
>3306	3a 33						.word 	_GEXNumber 					; E  compile get any number
>3308	45 33						.word 	_GEXString 					; F  compile get any string
.330a					_GEXNop:
.330a	18		clc				clc
.330b	60		rts				rts
.330c					_GEXToken2:
.330c	20 7d 33	jsr $337d			jsr 	_GEFetchZTemp0
.330f	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3312					_GEXToken1:
.3312	20 7d 33	jsr $337d			jsr 	_GEFetchZTemp0
.3315	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3318	18		clc				clc
.3319	60		rts				rts
.331a					_GEXExitNumber:
.331a	a9 00		lda #$00			lda 	#NSSIFloat
.331c	38		sec				sec
.331d	60		rts				rts
.331e					_GEXExitString:
.331e	a9 40		lda #$40			lda 	#NSSString
.3320	38		sec				sec
.3321	60		rts				rts
.3322					_GEXLParam:
.3322	a9 28		lda #$28			lda 	#"("
.3324	80 06		bra $332c			bra 	_GEXCheck
.3326					_GEXRParam:
.3326	a9 29		lda #$29			lda 	#")"
.3328	80 02		bra $332c			bra 	_GEXCheck
.332a					_GEXComma:
.332a	a9 2c		lda #$2c			lda 	#","
.332c					_GEXCheck:
.332c	85 30		sta $30				sta 	zTemp2 						; save match
.332e	20 05 34	jsr $3405			jsr 	GetNextNonSpace 			; get next skipping spaces
.3331	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.3333	d0 02		bne $3337			bne 	_GEXSyntax
.3335	18		clc				clc
.3336	60		rts				rts
.3337					_GEXSyntax:
.3337	4c 53 1f	jmp $1f53		jmp	ErrorV_syntax
.333a					_GEXNumber:
.333a	20 86 33	jsr $3386			jsr 	GEXCompileExpression 		; compile expression
.333d	29 40		and #$40			and 	#NSSTypeMask
.333f	c9 00		cmp #$00			cmp  	#NSSIFloat
.3341	d0 0d		bne $3350			bne 	_GEXType
.3343	18		clc				clc
.3344	60		rts				rts
.3345					_GEXString:
.3345	20 86 33	jsr $3386			jsr 	GEXCompileExpression 		; compile expression
.3348	29 40		and #$40			and 	#NSSTypeMask
.334a	c9 40		cmp #$40			cmp  	#NSSString
.334c	d0 02		bne $3350			bne 	_GEXType
.334e	18		clc				clc
.334f	60		rts				rts
.3350					_GEXType:
.3350	4c 63 1f	jmp $1f63		jmp	ErrorV_type
.3353					_GEXChannelExec:
.3353	20 96 33	jsr $3396			jsr 	ChannelPrefix 				; set up default
.3356	20 60 33	jsr $3360			jsr 	_GEXExecute
.3359	08		php				php
.335a	20 b1 33	jsr $33b1			jsr 	ChannelPostfix 				; replace default.
.335d	28		plp				plp
.335e	60		rts				rts
>335f	db						.byte 	$DB 						; causes a break in the emulator
.3360					_GEXExecute:
.3360	20 7d 33	jsr $337d			jsr 	_GEFetchZTemp0 				; get vector
.3363	85 30		sta $30				sta 	zTemp2
.3365	20 7d 33	jsr $337d			jsr 	_GEFetchZTemp0
.3368	85 31		sta $31				sta 	zTemp2+1
.336a	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.336c	da		phx				phx
.336d	a6 2d		ldx $2d				ldx 	zTemp0+1
.336f	da		phx				phx
.3370	20 7a 33	jsr $337a			jsr 	_GECallZTemp2 				; execute code
.3373	fa		plx				plx 								; recover generation exec
.3374	86 2d		stx $2d				stx 	zTemp0+1
.3376	fa		plx				plx
.3377	86 2c		stx $2c				stx 	zTemp0
.3379	60		rts				rts
.337a					_GECallZTemp2:
.337a	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.337d					_GEFetchZTemp0:
.337d	b2 2c		lda ($2c)			lda 	(zTemp0)
.337f	e6 2c		inc $2c				inc 	zTemp0
.3381	d0 02		bne $3385			bne 	_GEFZ0Skip
.3383	e6 2d		inc $2d				inc 	zTemp0+1
.3385					_GEFZ0Skip:
.3385	60		rts				rts
.3386					GEXCompileExpression:
.3386	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.3388	da		phx				phx
.3389	a6 2d		ldx $2d				ldx 	zTemp0+1
.338b	da		phx				phx
.338c	20 90 2d	jsr $2d90			jsr 	CompileExpressionAt0 		; compile expression.
.338f	fa		plx				plx 								; recover generation exec
.3390	86 2d		stx $2d				stx 	zTemp0+1
.3392	fa		plx				plx
.3393	86 2c		stx $2c				stx 	zTemp0
.3395	60		rts				rts
.3396					ChannelPrefix:
.3396	a9 af		lda #$af			lda 	#PCD_GETCHANNEL				; set channel onto stack
.3398	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.339b	20 86 33	jsr $3386			jsr 	GEXCompileExpression 		; channel #
.339e	29 40		and #$40			and 	#NSSTypeMask
.33a0	c9 00		cmp #$00			cmp 	#NSSIFloat
.33a2	d0 0a		bne $33ae			bne 	_CPXType
.33a4	20 d8 2a	jsr $2ad8			jsr 	CheckNextComma 				; check , follows.
.33a7	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL				; set channel
.33a9	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.33ac	18		clc				clc
.33ad	60		rts				rts
.33ae					_CPXType:
.33ae	4c 63 1f	jmp $1f63		jmp	ErrorV_type
.33b1					ChannelPostfix:
.33b1	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.33b3	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.33b6	18		clc				clc
.33b7	60		rts				rts
.33b8					OptionalParameterCompile:
.33b8	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; what follows.
.33bb	c9 2c		cmp #$2c			cmp 	#","
.33bd	d0 0e		bne $33cd			bne 	_MidDefault
.33bf	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume ,
.33c2	20 90 2d	jsr $2d90			jsr 	CompileExpressionAt0
.33c5	29 40		and #$40			and 	#NSSTypeMask
.33c7	c9 00		cmp #$00			cmp 	#NSSIFloat
.33c9	d0 09		bne $33d4			bne 	MidFailType
.33cb	80 05		bra $33d2			bra 	_MidComplete
.33cd					_MidDefault:
.33cd	a9 ff		lda #$ff			lda 	#255 						; default of 255
.33cf	20 a3 2b	jsr $2ba3			jsr 	PushIntegerA
.33d2					_MidComplete:
.33d2	18		clc				clc
.33d3	60		rts				rts
.33d4					MidFailType:
.33d4	4c 63 1f	jmp $1f63		jmp	ErrorV_type
.33d7					NotUnaryCompile:
.33d7	ad 45 2e	lda $2e45			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.33da	20 92 2d	jsr $2d92			jsr 	CompileExpressionAtA 		; evaluate at that level
.33dd	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.33df	c9 00		cmp #$00			cmp 	#NSSIFloat
.33e1	d0 f1		bne $33d4			bne 	MidFailType
.33e3	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.33e5	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.33e8	60		rts				rts
.33e9					LookNext:
.33e9	b2 7a		lda ($7a)			lda 	(srcPtr)
.33eb	60		rts				rts
.33ec					LookNextNonSpace:
.33ec	b2 7a		lda ($7a)			lda 	(srcPtr)
.33ee	c9 20		cmp #$20			cmp		#' '
.33f0	f0 03		beq $33f5			beq 	_LNNSkip
.33f2	c9 00		cmp #$00			cmp 	#0
.33f4	60		rts				rts
.33f5					_LNNSkip:
.33f5	20 fa 33	jsr $33fa			jsr 	GetNext
.33f8	80 f2		bra $33ec			bra 	LookNextNonSpace
.33fa					GetNext:
.33fa	b2 7a		lda ($7a)			lda 	(srcPtr) 					; get next
.33fc	e6 7a		inc $7a				inc 	srcPtr
.33fe	d0 02		bne $3402			bne 	_GNSkip
.3400	e6 7b		inc $7b				inc 	srcPtr+1
.3402					_GNSkip:
.3402	c9 00		cmp #$00			cmp 	#0
.3404	60		rts				rts
.3405					GetNextNonSpace:
.3405	20 fa 33	jsr $33fa			jsr 	GetNext
.3408	c9 20		cmp #$20			cmp 	#' '
.340a	f0 f9		beq $3405			beq 	GetNextNonSpace
.340c	c9 00		cmp #$00			cmp 	#0
.340e	60		rts				rts
.340f					CharIsDigit:
.340f	c9 30		cmp #$30			cmp 	#"0"
.3411	90 06		bcc $3419			bcc 	CCFalse
.3413	c9 3a		cmp #$3a			cmp 	#"9"+1
.3415	b0 02		bcs $3419			bcs 	CCFalse
.3417					CCTrue:
.3417	38		sec				sec
.3418	60		rts				rts
.3419					CCFalse:
.3419	18		clc				clc
.341a	60		rts				rts
.341b					CharIsAlpha:
.341b	c9 41		cmp #$41			cmp 	#"A"
.341d	90 fa		bcc $3419			bcc 	CCFalse
.341f	c9 5b		cmp #$5b			cmp 	#"Z"+1
.3421	b0 f6		bcs $3419			bcs 	CCFalse
.3423	80 f2		bra $3417			bra 	CCTrue
.3425					ConvertHexStyle:
.3425	38		sec				sec
.3426	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.3428	90 ef		bcc $3419			bcc 	CCFalse
.342a	c9 0a		cmp #$0a			cmp 	#9+1
.342c	90 e9		bcc $3417			bcc 	CCTrue
.342e	38		sec				sec 								; shift into hex space A=>0 Z=>25
.342f	e9 11		sbc #$11			sbc 	#"A"-"0"
.3431	90 e6		bcc $3419			bcc 	CCFalse
.3433	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.3435	b0 e2		bcs $3419			bcs 	CCFalse
.3437	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.3439	80 dc		bra $3417			bra 	CCTrue
.343b					CommandGET:
.343b	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; # follows ?
.343e	c9 23		cmp #$23			cmp 	#"#"
.3440	d0 0d		bne $344f			bne 	CommandGetBody
.3442	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume #
.3445	20 96 33	jsr $3396			jsr 	ChannelPrefix 				; do it as GET#
.3448	20 4f 34	jsr $344f			jsr 	CommandGetBody
.344b	20 b1 33	jsr $33b1			jsr 	ChannelPostfix
.344e	60		rts				rts
.344f					CommandGetBody:
.344f	20 05 34	jsr $3405			jsr 	GetNextNonSpace 			; get the first character
.3452	20 46 37	jsr $3746			jsr 	GetReferenceTerm 			; identify variable to assign to
.3455	48		pha				pha
.3456	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.3458	c9 40		cmp #$40			cmp 	#NSSString
.345a	d0 0b		bne $3467			bne 	_CGType
.345c	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.345e	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3461	38		sec				sec
.3462	68		pla				pla
.3463	20 f8 36	jsr $36f8			jsr		GetSetVariable
.3466	60		rts				rts
.3467					_CGType:
.3467	4c 63 1f	jmp $1f63		jmp	ErrorV_type
.346a					ExtractVariableName:
.346a	20 1b 34	jsr $341b			jsr 	CharIsAlpha
.346d	90 50		bcc $34bf			bcc 	_IVSyntax
.346f	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.3471	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.3473	64 2f		stz $2f				stz 	zTemp1+1
.3475	20 e9 33	jsr $33e9			jsr 	LookNext 					; is there a second character ?
.3478	20 1b 34	jsr $341b			jsr 	CharIsAlpha  				; must be alphanumeric
.347b	b0 05		bcs $3482			bcs 	_IVHasSecond
.347d	20 0f 34	jsr $340f			jsr 	CharIsDigit
.3480	90 07		bcc $3489			bcc 	_IVCheckType
.3482					_IVHasSecond:
.3482	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.3484	85 2f		sta $2f				sta 	zTemp1+1
.3486					_IVGetNextCheck:
.3486	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume it
.3489					_IVCheckType:
.3489	20 e9 33	jsr $33e9			jsr 	LookNext					; check if string follows.
.348c	20 1b 34	jsr $341b			jsr 	CharIsAlpha
.348f	b0 f5		bcs $3486			bcs 	_IVGetNextCheck
.3491	20 0f 34	jsr $340f			jsr 	CharIsDigit
.3494	b0 f0		bcs $3486			bcs 	_IVGetNextCheck
.3496	a2 40		ldx #$40			ldx 	#NSSString
.3498	c9 24		cmp #$24			cmp 	#"$"
.349a	f0 06		beq $34a2			beq 	_IVHasType
.349c	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.349e	c9 25		cmp #$25			cmp 	#"%"
.34a0	d0 08		bne $34aa			bne 	_IVCheckArray
.34a2					_IVHasType:
.34a2	8a		txa				txa 								; Or X into zTemp1
.34a3	05 2e		ora $2e				ora 	zTemp1
.34a5	85 2e		sta $2e				sta 	zTemp1
.34a7	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume it
.34aa					_IVCheckArray:
.34aa	20 e9 33	jsr $33e9			jsr 	LookNext 					; check if array follows
.34ad	c9 28		cmp #$28			cmp 	#"("
.34af	d0 09		bne $34ba			bne 	_IVNotArray
.34b1	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.34b3	09 80		ora #$80			ora 	#NSSArray
.34b5	85 2e		sta $2e				sta 	zTemp1
.34b7	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume it
.34ba					_IVNotArray:
.34ba	a6 2e		ldx $2e				ldx 	zTemp1
.34bc	a4 2f		ldy $2f				ldy 	zTemp1+1
.34be	60		rts				rts
.34bf					_IVSyntax:
.34bf	4c 53 1f	jmp $1f53		jmp	ErrorV_syntax
.34c2					CommandGOSUB:
.34c2	a9 d2		lda #$d2			lda 	#PCD_CMD_GOSUB
.34c4	20 d5 34	jsr $34d5			jsr 	CompileBranchCommand
.34c7	60		rts				rts
.34c8					CommandGOAlt:
.34c8	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.34ca	20 e2 2a	jsr $2ae2			jsr 	CheckNextA
.34cd	80 00		bra $34cf			bra 	CommandGOTO
.34cf					CommandGOTO:
.34cf	a9 d1		lda #$d1			lda 	#PCD_CMD_GOTO
.34d1	20 d5 34	jsr $34d5			jsr 	CompileBranchCommand
.34d4	60		rts				rts
.34d5					CompileBranchCommand:
.34d5	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte 				; write the command out.
.34d8	20 05 34	jsr $3405			jsr 	GetNextNonSpace
.34db	20 4e 36	jsr $364e			jsr 	ParseConstant 				; get constant into YA
.34de	90 08		bcc $34e8			bcc 	_CBCSyntax
.34e0	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte				; and compile the actual line number
.34e3	98		tya				tya
.34e4	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.34e7	60		rts				rts
.34e8					_CBCSyntax:
.34e8	4c 53 1f	jmp $1f53		jmp	ErrorV_syntax
.34eb					CommandIF:
.34eb	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; what follows the tests ?
.34ee	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.34f0	f0 0f		beq $3501			beq 	_CIGoto
.34f2	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.34f4	20 e2 2a	jsr $2ae2			jsr 	CheckNextA
.34f7	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; THEN <number>
.34fa	20 0f 34	jsr $340f			jsr 	CharIsDigit
.34fd	b0 05		bcs $3504			bcs 	_CIGoto2
.34ff	80 09		bra $350a			bra 	CompileGotoEOL
.3501					_CIGoto:
.3501	20 fa 33	jsr $33fa			jsr 	GetNext
.3504					_CIGoto2:
.3504	a9 d4		lda #$d4			lda 	#PCD_CMD_GOTOCMD_NZ
.3506	20 d5 34	jsr $34d5			jsr 	CompileBranchCommand
.3509	60		rts				rts
.350a					CompileGotoEOL:
.350a	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_Z
.350c	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.350f	20 73 2a	jsr $2a73			jsr 	GetLineNumber 				; Get the current line number => YA
.3512	1a		inc a				inc 	a 							; and branch to +1
.3513	d0 01		bne $3516			bne 	_CGENoCarry
.3515	c8		iny				iny
.3516					_CGENoCarry:
.3516	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3519	98		tya				tya
.351a	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.351d	60		rts				rts
.351e					CommandINPUT:
.351e	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; check for "
.3521	c9 22		cmp #$22			cmp 	#'"'
.3523	d0 0d		bne $3532			bne 	CommandINPUTStream
.3525	20 90 2d	jsr $2d90			jsr 	CompileExpressionAt0
.3528	a9 b2		lda #$b2			lda 	#(PCD_PRINTCMD_S) & $FF
.352a	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.352d	a9 2c		lda #$2c			lda 	#","
.352f	20 d8 2a	jsr $2ad8			jsr 	CheckNextComma
.3532					CommandINPUTStream:
.3532	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.3534	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3537	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.3539	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.353b	4c c0 36	jmp $36c0			jmp 	CommandReadInputCommon
.353e					CommandLET:
.353e	20 05 34	jsr $3405			jsr 	GetNextNonSpace 			; get the first character
.3541					CommandLETHaveFirst:
.3541	20 46 37	jsr $3746			jsr 	GetReferenceTerm 			; identify variable to assign to
.3544	da		phx				phx 								; save target on the stack.
.3545	5a		phy				phy
.3546	48		pha				pha
.3547	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.3549	20 e2 2a	jsr $2ae2			jsr 	CheckNextA
.354c	20 90 2d	jsr $2d90			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.354f	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.3551	68		pla				pla 								; get type of assignment
.3552	48		pha				pha
.3553	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.3555	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.3557	d0 17		bne $3570			bne 	_CLType
.3559	68		pla				pla 								; restore and compile save code
.355a	7a		ply				ply
.355b	fa		plx				plx
.355c	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.355e	f0 05		beq $3565			beq 	_CLTIString
.3560	38		sec				sec
.3561	20 f8 36	jsr $36f8			jsr		GetSetVariable
.3564	60		rts				rts
.3565					_CLTIString:
.3565	a9 cb		lda #$cb			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.3567	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.356a	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.356c	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.356f	60		rts				rts
.3570					_CLType:
.3570	4c 63 1f	jmp $1f63		jmp	ErrorV_type
.3573					STRMarkLine:
.3573	48		pha				pha
.3574	38		sec				sec 								; allocate 4 bytes (line #,address)
.3575	ad c9 06	lda $06c9			lda 	lineNumberTable 			; and copy to zTemp0
.3578	e9 04		sbc #$04			sbc 	#4
.357a	8d c9 06	sta $06c9			sta 	lineNumberTable
.357d	85 2c		sta $2c				sta 	zTemp0
.357f	ad ca 06	lda $06ca			lda 	lineNumberTable+1
.3582	e9 00		sbc #$00			sbc 	#0
.3584	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.3587	85 2d		sta $2d				sta 	zTemp0+1
.3589	68		pla				pla
.358a	92 2c		sta ($2c)			sta 	(zTemp0) 					; line # save it in +0,+1
.358c	98		tya				tya
.358d	a0 01		ldy #$01			ldy 	#1
.358f	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3591	a5 2a		lda $2a				lda 	objPtr 						; save current address in +2,+3
.3593	c8		iny				iny
.3594	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3596	a5 2b		lda $2b				lda 	objPtr+1
.3598	c8		iny				iny
.3599	91 2c		sta ($2c),y			sta 	(zTemp0),y
.359b	60		rts				rts
.359c					STRFindLine:
.359c	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.359e	84 2d		sty $2d				sty 	zTemp0+1
.35a0	ad c2 06	lda $06c2			lda 	compilerEndHigh 			; work backwards through table
.35a3	85 2f		sta $2f				sta 	zTemp1+1
.35a5	64 2e		stz $2e				stz 	zTemp1
.35a7					_STRSearch:
.35a7	20 de 35	jsr $35de			jsr 	_STRPrevLine 				; look at previous record.
.35aa	a0 01		ldy #$01			ldy 	#1
.35ac	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.35ae	c5 2c		cmp $2c				cmp 	zTemp0
.35b0	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.35b2	e5 2d		sbc $2d				sbc 	zTemp0+1
.35b4	b0 0b		bcs $35c1			bcs 	_STRFound 					; >=
.35b6					_STRNext:
.35b6	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.35b8	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.35ba	c9 ff		cmp #$ff			cmp 	#$FF
.35bc	d0 e9		bne $35a7			bne 	_STRSearch
.35be	4c ad 1f	jmp $1fad		jmp	ErrorV_internal
.35c1					_STRFound:
.35c1	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.35c3	45 2c		eor $2c				eor 	zTemp0
.35c5	d0 06		bne $35cd			bne 	_STRDifferent
.35c7	b2 2e		lda ($2e)			lda 	(zTemp1)
.35c9	45 2c		eor $2c				eor 	zTemp0
.35cb	f0 02		beq $35cf			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.35cd					_STRDifferent:
.35cd	a9 ff		lda #$ff			lda 	#$FF
.35cf					_STROut:
.35cf	18		clc				clc  								; set carry if different, e.g. > rather than >=
.35d0	69 ff		adc #$ff			adc 	#255
.35d2	08		php				php
.35d3	c8		iny				iny 								; address into YA
.35d4	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.35d6	48		pha				pha
.35d7	c8		iny				iny
.35d8	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.35da	a8		tay				tay
.35db	68		pla				pla
.35dc	28		plp				plp
.35dd	60		rts				rts
.35de					_STRPrevLine:
.35de	38		sec				sec 								; move backwards one entry.
.35df	a5 2e		lda $2e				lda 	zTemp1
.35e1	e9 04		sbc #$04			sbc 	#4
.35e3	85 2e		sta $2e				sta 	zTemp1
.35e5	a5 2f		lda $2f				lda 	zTemp1+1
.35e7	e9 00		sbc #$00			sbc 	#0
.35e9	85 2f		sta $2f				sta 	zTemp1+1
.35eb	60		rts				rts
.35ec					STRMakeOffset:
.35ec	18		clc				clc 								; borrow 1
.35ed	e5 2a		sbc $2a				sbc 	objPtr
.35ef	48		pha				pha
.35f0	98		tya				tya
.35f1	e5 2b		sbc $2b				sbc 	objPtr+1
.35f3	a8		tay				tay
.35f4	68		pla				pla
.35f5	60		rts				rts
.35f6					CommandNEXT:
.35f6	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.35f9	20 1b 34	jsr $341b			jsr 	CharIsAlpha 				; if not alpha , error
.35fc	90 0c		bcc $360a			bcc 	_CNNoReferenceGiven
.35fe	20 fa 33	jsr $33fa			jsr 	GetNext
.3601	20 46 37	jsr $3746			jsr 	GetReferenceTerm 			; figure out the reference.
.3604	8a		txa				txa 								; reference in YA
.3605	20 90 2b	jsr $2b90			jsr 	PushIntegerYA 				; write it out.
.3608	80 06		bra $3610			bra 	_CNParametersDone
.360a					_CNNoReferenceGiven:
.360a	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.360c	a8		tay				tay
.360d	20 90 2b	jsr $2b90			jsr 	PushIntegerYA 				; write it out.
.3610					_CNParametersDone:
.3610	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.3612	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3615	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; look for ,
.3618	c9 2c		cmp #$2c			cmp 	#","
.361a	d0 05		bne $3621			bne 	_CNExit
.361c	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume ,
.361f	80 d5		bra $35f6			bra 	CommandNEXT 				; and go round.
.3621					_CNExit:
.3621	60		rts				rts
.3622					CommandON:
.3622	20 05 34	jsr $3405			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.3625	48		pha				pha 								; save on stack
.3626	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOTO
.3628	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.362a	f0 09		beq $3635			beq 	_COCreateLoop
.362c	a2 d2		ldx #$d2			ldx 	#PCD_CMD_GOSUB
.362e	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.3630	f0 03		beq $3635			beq 	_COCreateLoop
.3632	4c 53 1f	jmp $1f53		jmp	ErrorV_syntax
.3635					_COCreateLoop:
.3635	8a		txa				txa 								; compile a goto/gosub somewhere
.3636	da		phx				phx
.3637	20 d5 34	jsr $34d5			jsr 	CompileBranchCommand
.363a	fa		plx				plx
.363b	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace			; ',' follows
.363e	c9 2c		cmp #$2c			cmp 	#","
.3640	d0 0a		bne $364c			bne 	_COComplete 				; if so, more line numbers
.3642	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.3644	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3647	20 fa 33	jsr $33fa			jsr 	GetNext
.364a	80 e9		bra $3635			bra 	_COCreateLoop
.364c					_COComplete:
.364c	68		pla				pla 								; throw GOTO/GOSUB
.364d	60		rts				rts
.364e					ParseConstant:
.364e	a2 00		ldx #$00			ldx 	#0
.3650	20 8b 24	jsr $248b			jsr 	FloatEncodeStart 			; send first
.3653					_ParseLoop:
.3653	20 e9 33	jsr $33e9			jsr 	LookNext 					; send subsequent
.3656	20 8e 24	jsr $248e			jsr 	FloatEncodeContinue
.3659	90 05		bcc $3660			bcc 	_ParseDone
.365b	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume it
.365e	80 f3		bra $3653			bra 	_ParseLoop
.3660					_ParseDone:
.3660	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.3662	29 80		and #$80			and 	#$80
.3664	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.3666	15 56		ora $56,x			ora 	NSMantissa2,x
.3668	15 62		ora $62,x			ora 	NSMantissa3,x
.366a	18		clc				clc
.366b	d0 05		bne $3672			bne 	_ParseExit 					; exit with CC if need float to compile
.366d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.366f	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.3671	38		sec				sec
.3672					_ParseExit:
.3672	60		rts				rts
.3673					CommandPRINT:
.3673	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace			; what follows ?
.3676	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.3678	f0 1f		beq $3699			beq 	_CPCheckEnd
.367a	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.367c	f0 16		beq $3694			beq 	_CPTabCheckEnd
.367e	20 b0 36	jsr $36b0			jsr 	_CPAtEnd 					; check for : and EOL
.3681	b0 22		bcs $36a5			bcs 	_CPExitCR 					; exit with CR
.3683	20 90 2d	jsr $2d90			jsr 	CompileExpressionAt0 		; so it is something to print
.3686	a2 b2		ldx #$b2			ldx 	#PCD_PRINTCMD_S
.3688	29 40		and #$40			and 	#NSSString 					; if string
.368a	d0 02		bne $368e			bne 	_CPOut
.368c	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_N
.368e					_CPOut:
.368e	8a		txa				txa 								; print that thing
.368f	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3692	80 df		bra $3673			bra 	CommandPRINT 				; and loop round/
.3694					_CPTabCheckEnd:
.3694	a9 b8		lda #$b8			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.3696	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3699					_CPCheckEnd:
.3699	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume it.
.369c	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; what follows ?
.369f	20 b0 36	jsr $36b0			jsr 	_CPAtEnd 					; reached end
.36a2	90 cf		bcc $3673			bcc 	CommandPRINT 				; no, loop back
.36a4	60		rts				rts
.36a5					_CPExitCR:
.36a5	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.36a7	20 a3 2b	jsr $2ba3			jsr 	PushIntegerA
.36aa	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.36ac	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.36af	60		rts				rts
.36b0					_CPAtEnd:
.36b0	c9 00		cmp #$00			cmp 	#0
.36b2	f0 06		beq $36ba			beq 	_CPIsEnd
.36b4	c9 3a		cmp #$3a			cmp 	#":"
.36b6	f0 02		beq $36ba			beq 	_CPIsEnd
.36b8	18		clc				clc
.36b9	60		rts				rts
.36ba					_CPIsEnd:
.36ba	38		sec				sec
.36bb	60		rts				rts
.36bc					CommandREAD:
.36bc	a2 b3		ldx #$b3			ldx 	#PCD_READ
.36be	a0 b4		ldy #$b4			ldy 	#PCD_READDOLLAR
.36c0					CommandReadInputCommon:
.36c0	8e c7 06	stx $06c7			stx 	numberPCode
.36c3	8c c8 06	sty $06c8			sty 	stringPCode
.36c6					_CRLoop:
.36c6	20 05 34	jsr $3405			jsr 	GetNextNonSpace 			; first char of identifier
.36c9	20 1b 34	jsr $341b			jsr 	CharIsAlpha 				; check A-Z
.36cc	90 27		bcc $36f5			bcc 	_CRSyntax
.36ce	20 46 37	jsr $3746			jsr 	GetReferenceTerm 			; get the variable.
.36d1	48		pha				pha 								; save type.
.36d2	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.36d4	c9 40		cmp #$40			cmp 	#NSSString
.36d6	f0 05		beq $36dd			beq 	_CRString
.36d8	ad c7 06	lda $06c7			lda 	numberPCode 				; output read/input
.36db	80 03		bra $36e0			bra 	_CRHaveType
.36dd					_CRString:
.36dd	ad c8 06	lda $06c8			lda 	stringPCode					; output read$/input$
.36e0					_CRHaveType:
.36e0	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte 				; so we have one typed data item.
.36e3	68		pla				pla 								; restore type
.36e4	38		sec				sec  								; write update code.
.36e5	20 f8 36	jsr $36f8			jsr 	GetSetVariable
.36e8	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; , follows ?
.36eb	c9 2c		cmp #$2c			cmp 	#","
.36ed	d0 05		bne $36f4			bne 	_CRExit 					; if not, end of READ.
.36ef	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume comma
.36f2	80 d2		bra $36c6			bra 	_CRLoop 					; keep going
.36f4					_CRExit:
.36f4	60		rts				rts
.36f5					_CRSyntax:
.36f5	4c 53 1f	jmp $1f53		jmp	ErrorV_syntax
.06c7					numberPCode:
>06c7							.fill 	1
.06c8					stringPCode:
>06c8							.fill 	1
.36f8					GetSetVariable:
.36f8	08		php				php 								; save direction on stack
.36f9	c0 00		cpy #$00			cpy 	#$00
.36fb	30 21		bmi $371e			bmi 	_GSVReadWriteSpecial
.36fd	c9 00		cmp #$00			cmp 	#$00
.36ff	30 33		bmi $3734			bmi 	_GSVArray
.3701	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.3703	4a		lsr a				lsr 	a 							; divide by 2
.3704	09 40		ora #$40			ora 	#64 						; and set bit 6.
.3706	28		plp				plp
.3707	90 02		bcc $370b			bcc 	_GSVNotWrite
.3709	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.370b					_GSVNotWrite:
.370b	85 2c		sta $2c				sta 	zTemp0
.370d	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.370e	4a		lsr a				lsr 	a
.370f	a8		tay				tay
.3710	8a		txa				txa
.3711	6a		ror a				ror 	a
.3712	aa		tax				tax
.3713	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.3714	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.3716	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3719	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.371a	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.371d	60		rts				rts
.371e					_GSVReadWriteSpecial:
.371e	28		plp				plp
.371f	b0 10		bcs $3731			bcs 	_GSVSyntax
.3721	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.3723	f0 06		beq $372b			beq 	_GSVRWString
.3725	a9 c0		lda #$c0			lda 	#(PCD_TI) & $FF
.3727	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.372a	60		rts				rts
.372b					_GSVRWString:
.372b	a9 c1		lda #$c1			lda 	#(PCD_TIDOLLAR) & $FF
.372d	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3730	60		rts				rts
.3731					_GSVSyntax:
.3731	4c 53 1f	jmp $1f53		jmp	ErrorV_syntax
.3734					_GSVArray:
.3734	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.3736	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.3737	4a		lsr a				lsr 	a
.3738	4a		lsr a				lsr 	a
.3739	4a		lsr a				lsr 	a
.373a	4a		lsr a				lsr 	a
.373b	28		plp				plp 								; if writing array then set bit 2.
.373c	90 02		bcc $3740			bcc 	_GSVANotWrite
.373e	09 04		ora #$04			ora 	#4
.3740					_GSVANotWrite:
.3740	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.3742	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte 				; and write it out
.3745	60		rts				rts
.3746					GetReferenceTerm:
.3746	20 6a 34	jsr $346a			jsr 	ExtractVariableName 		; get name & type info
.3749	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.374b	30 10		bmi $375d			bmi 	_GRTArray
.374d	da		phx				phx 								; save type on stack
.374e	20 4a 2e	jsr $2e4a			jsr 	FindVariable 				; find it
.3751	b0 06		bcs $3759			bcs 	_GRTNoCreate 				; create if required.
.3753	20 d5 2b	jsr $2bd5			jsr 	CreateVariableRecord 		; create a variable.
.3756	20 2a 2c	jsr $2c2a			jsr 	AllocateBytesForType 		; allocate memory for it
.3759					_GRTNoCreate:
.3759	68		pla				pla 								; get type back, strip out type information.
.375a	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.375c	60		rts				rts
.375d					_GRTArray:
.375d	da		phx				phx 								; save type information
.375e	20 4a 2e	jsr $2e4a			jsr 	FindVariable 				; read its data, the base address in YX
.3761	90 18		bcc $377b			bcc 	_GRTUndeclared 				; undeclared array.
.3763	da		phx				phx 								; save base address
.3764	5a		phy				phy
.3765	20 21 2d	jsr $2d21			jsr 	OutputIndexGroup 			; create an index group and generate them
.3768	7a		ply				ply 								; get the array base address into YX
.3769	fa		plx				plx
.376a	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.376c	18		clc				clc
.376d	20 f8 36	jsr $36f8			jsr 	GetSetVariable 				; load the address of the array structure.
.3770	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.3772	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3775	68		pla				pla 								; and the type data into A
.3776	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.3778	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.377a	60		rts				rts
.377b					_GRTUndeclared:
.377b	4c 0a 20	jmp $200a		jmp	ErrorV_undeclared
.377e					CommandREM:
.377e	20 e9 33	jsr $33e9			jsr 	LookNext
.3781	f0 05		beq $3788			beq 	_CRExit
.3783	20 fa 33	jsr $33fa			jsr 	GetNext
.3786	80 f6		bra $377e			bra 	CommandREM
.3788					_CRExit:
.3788	60		rts				rts
.3789					STRReset:
.3789	ad c1 06	lda $06c1			lda	 	compilerStartHigh 			; set up the two table pointers
.378c	8d cc 06	sta $06cc			sta 	variableListEnd+1
.378f	9c cb 06	stz $06cb			stz 	variableListEnd
.3792	ad c2 06	lda $06c2			lda 	compilerEndHigh
.3795	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.3798	9c c9 06	stz $06c9			stz 	lineNumberTable
.379b	ad cb 06	lda $06cb			lda 	variableListEnd
.379e	85 2d		sta $2d				sta 	zTemp0+1
.37a0	64 2c		stz $2c				stz 	zTemp0
.37a2	a9 00		lda #$00			lda 	#0
.37a4	92 2c		sta ($2c)			sta 	(zTemp0)
.37a6	a9 00		lda #$00			lda 	#((0) & $FF)
.37a8	8d cd 06	sta $06cd			sta 	0+freeVariableMemory
.37ab	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.37ad	8d ce 06	sta $06ce			sta 	1+freeVariableMemory
.37b0	60		rts				rts
.06c9					lineNumberTable:
>06c9							.fill 	2
.06cb					variableListEnd:
>06cb							.fill 	2
.06cd					freeVariableMemory:
>06cd							.fill 	2
.37b1					CommandRESTORE:
.37b1	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; what follows ?
.37b4	c9 3a		cmp #$3a			cmp 	#':'						; if : or EOL then default
.37b6	f0 0a		beq $37c2			beq 	_CRDefault
.37b8	c9 00		cmp #$00			cmp 	#0
.37ba	f0 06		beq $37c2			beq 	_CRDefault
.37bc	a9 d6		lda #$d6			lda 	#PCD_CMD_RESTORE 			; no, we have a parameter like GOTO/GOSUB
.37be	20 d5 34	jsr $34d5			jsr 	CompileBranchCommand
.37c1	60		rts				rts
.37c2					_CRDefault:
.37c2	a9 d6		lda #$d6			lda 	#PCD_CMD_RESTORE 			; compile RESTORE
.37c4	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.37c7	a9 00		lda #$00			lda 	#0		 					; with zero "line#"
.37c9	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.37cc	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.37cf	60		rts				rts
.37d0					CompileTerm:
.37d0	20 05 34	jsr $3405			jsr 	GetNextNonSpace 			; get first non space character.
.37d3	30 72		bmi $3847			bmi 	_CTUnaryFunctions
.37d5	20 0f 34	jsr $340f			jsr 	CharIsDigit 				; found a number
.37d8	b0 3a		bcs $3814			bcs 	_CTDigit
.37da	c9 2e		cmp #$2e			cmp 	#"."
.37dc	f0 36		beq $3814			beq 	_CTDigit
.37de	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.37e0	f0 43		beq $3825			beq 	_CTString
.37e2	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.37e4	f0 28		beq $380e			beq 	_CTOtherBase
.37e6	c9 24		cmp #$24			cmp 	#"$"
.37e8	f0 24		beq $380e			beq 	_CTOtherBase
.37ea	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.37ec	f0 17		beq $3805			beq 	_CTBrackets
.37ee	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.37f0	90 10		bcc $3802			bcc 	_CTSyntax
.37f2	c9 5b		cmp #$5b			cmp 	#"Z"+1
.37f4	b0 0c		bcs $3802			bcs 	_CTSyntax
.37f6	20 46 37	jsr $3746			jsr 	GetReferenceTerm 			; figure out what it is.
.37f9	48		pha				pha 								; save type on stack
.37fa	18		clc				clc 								; read it
.37fb	20 f8 36	jsr $36f8			jsr 	GetSetVariable
.37fe	68		pla				pla
.37ff	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.3801	60		rts				rts
.3802					_CTSyntax:
.3802	4c 53 1f	jmp $1f53		jmp	ErrorV_syntax
.3805					_CTBrackets:
.3805	20 90 2d	jsr $2d90			jsr 	CompileExpressionAt0
.3808	48		pha				pha
.3809	20 dc 2a	jsr $2adc			jsr 	CheckNextRParen
.380c	68		pla				pla
.380d	60		rts				rts
.380e					_CTOtherBase:
.380e	20 28 2a	jsr $2a28			jsr 	InlineNonDecimal 			; non decimal constant handler
.3811	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.3813	60		rts				rts
.3814					_CTDigit:
.3814	20 4e 36	jsr $364e			jsr 	ParseConstant 				; parse out an number, first is in A already.
.3817	90 06		bcc $381f			bcc	 	_CTFloat 					; have a float or long int.
.3819	20 90 2b	jsr $2b90			jsr 	PushIntegerYA 				; code to push on stack
.381c	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.381e	60		rts				rts
.381f					_CTFloat:
.381f	20 b2 2b	jsr $2bb2			jsr 	PushFloatCommand			; code to push float
.3822	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.3824	60		rts				rts
.3825					_CTString:
.3825	20 b1 2a	jsr $2ab1			jsr 	BufferClear 				; copy it to the buffer
.3828					_CTStringLoop:
.3828	20 e9 33	jsr $33e9			jsr 	LookNext 					; reached EOL/EOS
.382b	f0 d5		beq $3802			beq 	_CTSyntax
.382d	c9 22		cmp #$22			cmp 	#'"'
.382f	f0 08		beq $3839			beq 	_CTStringDone
.3831	20 b5 2a	jsr $2ab5			jsr 	BufferWrite 				; write and consume
.3834	20 fa 33	jsr $33fa			jsr 	GetNext
.3837	80 ef		bra $3828			bra 	_CTStringLoop
.3839					_CTStringDone:
.3839	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume closing quote.
.383c	a9 cf		lda #$cf			lda 	#PCD_CMD_STRING 			; output command and buffer
.383e	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3841	20 c1 2a	jsr $2ac1			jsr 	BufferOutput
.3844	a9 40		lda #$40			lda 	#NSSString 					; string type
.3846	60		rts				rts
.3847					_CTUnaryFunctions:
.3847	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.3849	f0 0a		beq $3855			beq 	_CTNegation
.384b	a2 84		ldx #$84			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.384d	a0 31		ldy #$31			ldy 	#UnaryTables >> 8
.384f	20 8b 32	jsr $328b			jsr 	GeneratorProcess
.3852	90 ae		bcc $3802			bcc		_CTSyntax
.3854	60		rts				rts
.3855					_CTNegation:
.3855	20 d0 37	jsr $37d0			jsr 	CompileTerm 				; compile a term.
.3858	48		pha				pha
.3859	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.385b	c9 00		cmp #$00			cmp 	#NSSIFloat
.385d	d0 07		bne $3866			bne 	_CTType 					; error
.385f	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.3861	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3864	68		pla				pla 								; return original type.
.3865	60		rts				rts
.3866					_CTType:
.3866	4c 63 1f	jmp $1f63		jmp	ErrorV_type
.3869					CommandWAIT:
.3869	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace
.386c	c9 2c		cmp #$2c			cmp 	#","
.386e	f0 10		beq $3880			beq 	_CWThirdParameter
.3870	a9 00		lda #$00			lda 	#0
.3872	20 a3 2b	jsr $2ba3			jsr 	PushIntegerA
.3875					_CWExit:
.3875	a9 cb		lda #$cb			lda 	#(PCD_WAIT) >> 8
.3877	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.387a	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.387c	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.387f	60		rts				rts
.3880					_CWThirdParameter:
.3880	20 fa 33	jsr $33fa			jsr 	GetNext
.3883	20 92 2d	jsr $2d92			jsr 	CompileExpressionAtA
.3886	29 40		and #$40			and 	#NSSTypeMask
.3888	c9 00		cmp #$00			cmp 	#NSSIFloat
.388a	f0 e9		beq $3875			beq 	_CWExit
.388c	4c 63 1f	jmp $1f63		jmp	ErrorV_type
.388f					CommandCMD:
.388f	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.3891	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.3894	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; followed by a , ?
.3897	c9 2c		cmp #$2c			cmp 	#","
.3899	d0 06		bne $38a1			bne 	_CCMDExit
.389b	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume comma.
.389e	20 73 36	jsr $3673			jsr 	CommandPRINT 				; do the print code
.38a1					_CCMDExit:
.38a1	60		rts				rts
.38a2					CommandOPEN:
.38a2	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; followed by a , ?
.38a5	c9 2c		cmp #$2c			cmp 	#","
.38a7	d0 15		bne $38be			bne 	_COTwoDefaults
.38a9	20 fa 33	jsr $33fa			jsr 	GetNext 					; consume comma
.38ac	20 90 2d	jsr $2d90			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.38af	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.38b1	f0 1e		beq $38d1			beq 	_COThreeIntegers
.38b3	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.38b5	20 a3 2b	jsr $2ba3			jsr 	PushIntegerA
.38b8	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.38ba	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.38bd	60		rts				rts
.38be					_COTwoDefaults:
.38be	a9 00		lda #$00			lda 	#0
.38c0	20 a3 2b	jsr $2ba3			jsr 	PushIntegerA
.38c3					_COCompileNullString:
.38c3	a9 cf		lda #$cf			lda 	#(PCD_CMD_STRING) & $FF
.38c5	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.38c8	a9 00		lda #$00			lda 	#0
.38ca	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.38cd	20 7a 2a	jsr $2a7a			jsr 	WriteCodeByte
.38d0	60		rts				rts
.38d1					_COThreeIntegers:
.38d1	20 ec 33	jsr $33ec			jsr 	LookNextNonSpace 			; is there a ,
.38d4	c9 2c		cmp #$2c			cmp 	#","
.38d6	d0 eb		bne $38c3			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.38d8	20 fa 33	jsr $33fa			jsr 	GetNext
.38db	20 90 2d	jsr $2d90			jsr 	CompileExpressionAt0 		; should be a filename
.38de	29 40		and #$40			and 	#NSSString
.38e0	f0 01		beq $38e3			beq 	_COType
.38e2	60		rts				rts
.38e3					_COType:
.38e3	4c 63 1f	jmp $1f63		jmp	ErrorV_type

;******  Processing input file: _library.asm

.38e6					CompilerAPI:
.38e6	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.38e8	f0 19		beq $3903			beq 	_CAOpenIn
.38ea	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.38ec	f0 23		beq $3911			beq 	_CACloseIn
.38ee	c9 02		cmp #$02			cmp 	#BLC_READIN
.38f0	f0 3a		beq $392c			beq 	_CARead
.38f2	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.38f4	f0 1e		beq $3914			beq 	_CAResetOut
.38f6	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.38f8	f0 23		beq $391d			beq 	_CACloseOut
.38fa	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.38fc	f0 20		beq $391e			beq 	_CAWriteByte
.38fe	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.3900	f0 26		beq $3928			beq 	_CAPrintScreen
>3902	db						.byte 	$DB 						; causes a break in the emulator
.3903					_CAOpenIn:
.3903	a0 3a		ldy #$3a			ldy 	#SourceFile >> 8 			; name of file
.3905	a2 23		ldx #$23			ldx 	#SourceFile & $FF
.3907	20 94 39	jsr $3994			jsr 	IOOpenRead 					; open file
.390a	20 9f 39	jsr $399f			jsr 	IOReadByte 					; skip the 2 byte load address header
.390d	20 9f 39	jsr $399f			jsr 	IOReadByte
.3910	60		rts				rts
.3911					_CACloseIn:
.3911	4c ae 39	jmp $39ae			jmp 	IOReadClose
.3914					_CAResetOut:
.3914	a9 00		lda #$00			lda 	#((FreeMemory) & $FF)
.3916	85 2a		sta $2a				sta 	0+objPtr
.3918	a9 3b		lda #$3b			lda 	#((FreeMemory) >> 8) & $FF
.391a	85 2b		sta $2b				sta 	1+objPtr
.391c	60		rts				rts
.391d					_CACloseOut:
.391d	60		rts				rts
.391e					_CAWriteByte:
.391e	8a		txa				txa
.391f	92 2a		sta ($2a)			sta 	(objPtr)
.3921	e6 2a		inc $2a				inc 	objPtr
.3923	d0 02		bne $3927			bne 	_HWOWBNoCarry
.3925	e6 2b		inc $2b				inc 	objPtr+1
.3927					_HWOWBNoCarry:
.3927	60		rts				rts
.3928					_CAPrintScreen:
.3928	8a		txa				txa
.3929	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.392c					_CARead:
.392c	20 9f 39	jsr $399f			jsr 	IOReadByte 				; copy the address of next into the buffer
.392f	8d cf 06	sta $06cf			sta 	SourceLine+0
.3932	20 9f 39	jsr $399f			jsr 	IOReadByte
.3935	8d d0 06	sta $06d0			sta 	SourceLine+1
.3938	0d cf 06	ora $06cf			ora 	sourceLine				; if both were zero, exit with CC (e.g. fail)
.393b	18		clc				clc
.393c	f0 1e		beq $395c			beq		_CARExit
.393e	20 9f 39	jsr $399f			jsr 	IOReadByte 				; read the line # into the buffer.
.3941	8d d1 06	sta $06d1			sta 	SourceLine+2
.3944	20 9f 39	jsr $399f			jsr 	IOReadByte
.3947	8d d2 06	sta $06d2			sta 	SourceLine+3
.394a	a2 04		ldx #$04			ldx 	#4 						; read the body of the line.
.394c					_CAReadLine:
.394c	20 9f 39	jsr $399f			jsr 	IOReadByte 				; now keep copying to EOL
.394f	9d cf 06	sta $06cf,x			sta 	SourceLine,x
.3952	e8		inx				inx
.3953	c9 00		cmp #$00			cmp 	#0
.3955	d0 f5		bne $394c			bne 	_CAReadLine
.3957	38		sec				sec 							; read a line okay
.3958	a0 06		ldy #$06			ldy 	#SourceLine >> 8
.395a	a2 cf		ldx #$cf			ldx 	#SourceLine & $FF
.395c					_CARExit:
.395c	60		rts				rts
.06cf					SourceLine:
>06cf							.fill 	256
.395d					WriteObjectCode:
.395d	20 1a 08	jsr $081a			jsr 	PatchOutCompile 			; makes it run the runtime on reload
.3960	a0 3a		ldy #$3a			ldy 	#ObjectFile >> 8
.3962	a2 18		ldx #$18			ldx 	#ObjectFile & $FF
.3964	20 8a 3a	jsr $3a8a			jsr 	IOOpenWrite 				; open write
.3967	a9 01		lda #$01			lda 	#1 							; write out the load address $0801
.3969	20 95 3a	jsr $3a95			jsr 	IOWriteByte
.396c	a9 08		lda #$08			lda 	#8
.396e	20 95 3a	jsr $3a95			jsr 	IOWriteByte
.3971	a9 01		lda #$01			lda 	#((StartBasicProgram) & $FF)
.3973	85 2c		sta $2c				sta 	0+zTemp0
.3975	a9 08		lda #$08			lda 	#((StartBasicProgram) >> 8) & $FF
.3977	85 2d		sta $2d				sta 	1+zTemp0
.3979					_WOCLoop:
.3979	b2 2c		lda ($2c)			lda 	(zTemp0) 					; write code
.397b	20 95 3a	jsr $3a95			jsr 	IOWriteByte
.397e	e6 2c		inc $2c				inc 	zTemp0 						; advance pointer
.3980	d0 02		bne $3984			bne 	_WOCSkip
.3982	e6 2d		inc $2d				inc 	zTemp0+1
.3984					_WOCSkip:
.3984	a5 2c		lda $2c				lda 	zTemp0 						; check end
.3986	c5 2a		cmp $2a				cmp 	objPtr
.3988	d0 ef		bne $3979			bne 	_WOCLoop
.398a	a5 2d		lda $2d				lda 	zTemp0+1
.398c	c5 2b		cmp $2b				cmp 	objPtr+1
.398e	d0 e9		bne $3979			bne 	_WOCLoop
.3990	20 ae 39	jsr $39ae			jsr 	IOWriteClose 				; close the file.
.3993	60		rts				rts
.3994					IOOpenRead:
.3994	a9 52		lda #$52			lda 	#'R' 						; read.
.3996	20 b7 39	jsr $39b7			jsr 	IOSetFileName 				; set up name/LFS
.3999	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for reading
.399b	20 c6 ff	jsr $ffc6			jsr 	$FFC6 						; CHKIN
.399e	60		rts				rts
.399f					IOReadByte:
.399f	da		phx				phx
.39a0	5a		phy				phy
.39a1	20 b7 ff	jsr $ffb7			jsr 	$FFB7 						; read ST
.39a4	38		sec				sec
.39a5	d0 04		bne $39ab			bne 	_IORExit
.39a7	20 cf ff	jsr $ffcf			jsr 	$FFCF 						; read a byte
.39aa	18		clc				clc 								; status OK.
.39ab					_IORExit:
.39ab	7a		ply				ply
.39ac	fa		plx				plx
.39ad	60		rts				rts
.39ae					IOReadClose:
.39ae					IOWriteClose:
.39ae	a9 03		lda #$03			lda 	#3 							; CLOSE# 3
.39b0	20 c3 ff	jsr $ffc3			jsr 	$FFC3
.39b3	20 cc ff	jsr $ffcc			jsr 	$FFCC 						; CLRCHN
.39b6	60		rts				rts
.39b7					IOSetFileName:
.39b7	48		pha				pha 								; save R/W
.39b8	86 2c		stx $2c				stx 	zTemp0
.39ba	84 2d		sty $2d				sty 	zTemp0+1
.39bc	a0 ff		ldy #$ff			ldy 	#$FF 						; copy name given
.39be					_IOSCopy:
.39be	c8		iny				iny 								; pre-increment copy
.39bf	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.39c1	99 cf 07	sta $07cf,y			sta 	IONameBuffer,y
.39c4	d0 f8		bne $39be			bne 	_IOSCopy
.39c6	99 d3 07	sta $07d3,y			sta 	IONameBuffer+4,y
.39c9	a9 2c		lda #$2c			lda 	#',' 						; append ,S,[R|W]
.39cb	99 cf 07	sta $07cf,y			sta 	IONameBuffer+0,y
.39ce	99 d1 07	sta $07d1,y			sta 	IONameBuffer+2,y
.39d1	a9 53		lda #$53			lda 	#'S'
.39d3	99 d0 07	sta $07d0,y			sta 	IONameBuffer+1,y
.39d6	68		pla				pla 								; write R/W out
.39d7	99 d2 07	sta $07d2,y			sta 	IONameBuffer+3,y
.39da	98		tya				tya 								; length of name to A
.39db	18		clc				clc
.39dc	69 04		adc #$04			adc 	#4 							; we added 4 characters.
.39de	a2 cf		ldx #$cf			ldx 	#IONameBuffer & $FF			; name address to YX
.39e0	a0 07		ldy #$07			ldy 	#IONameBuffer >> 8
.39e2	20 bd ff	jsr $ffbd		    jsr 	$FFBD          				; call SETNAM
.39e5	a9 03		lda #$03	    	lda 	#3 							; set LFS to 3,8,3
.39e7	a2 08		ldx #$08			ldx 	#8
.39e9	a0 03		ldy #$03			ldy 	#3
.39eb	20 ba ff	jsr $ffba			jsr 	$FFBA
.39ee	20 c0 ff	jsr $ffc0			jsr 	$FFC0 						; OPEN
.39f1	60		rts				rts
.07cf					IONameBuffer:
>07cf							.fill 	64
.39f2					CompileCode:
.39f2	a2 00		ldx #$00			ldx 	#0
.39f4	bd 2e 3a	lda $3a2e,x	_Prompt:lda 	Prompt,x
.39f7	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.39fa	e8		inx				inx
.39fb	c9 00		cmp #$00			cmp 	#0
.39fd	d0 f5		bne $39f4			bne 	_Prompt
.39ff	a2 14		ldx #$14			ldx 	#APIDesc & $FF
.3a01	a0 3a		ldy #$3a			ldy 	#APIDesc >> 8
.3a03	20 f1 2a	jsr $2af1			jsr 	StartCompiler
.3a06	20 5d 39	jsr $395d			jsr 	WriteObjectCode
.3a09	a9 4f		lda #$4f			lda 	#"O"
.3a0b	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a0e	a9 4b		lda #$4b			lda 	#"K"
.3a10	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a13	60		rts				rts
.3a14					APIDesc:
>3a14	e6 38						.word 	CompilerAPI 				; the compiler API Implementeation
>3a16	80						.byte 	$80 						; start of workspace for compiler $8000
>3a17	9f						.byte 	$9F							; end of workspace for compiler $9F00
.3a18					ObjectFile:
>3a18	4f 42 4a 45 43 54 2e 50				.text 	'OBJECT.PRG',0
>3a20	52 47 00
.3a23					SourceFile:
>3a23	53 4f 55 52 43 45 2e 50				.text 	'SOURCE.PRG',0
>3a2b	52 47 00
.3a2e					Prompt:
>3a2e	2a 2a 2a 20 42 4c 49 54				.text 	'*** BLITZ (ALPHA 14-10-23) ***',13,13
>3a36	5a 20 28 41 4c 50 48 41 20 31 34 2d 31 30 2d 32
>3a46	33 29 20 2a 2a 2a 0d 0d
>3a4e	42 55 47 53 20 2d 3e 20				.text 	'BUGS -> HTTPS://GITHUB.COM/PAULSCOTTROBSON/BLITZ-COMPILER',13,13,0
>3a56	48 54 54 50 53 3a 2f 2f 47 49 54 48 55 42 2e 43
>3a66	4f 4d 2f 50 41 55 4c 53 43 4f 54 54 52 4f 42 53
>3a76	4f 4e 2f 42 4c 49 54 5a 2d 43 4f 4d 50 49 4c 45
>3a86	52 0d 0d 00
.3a8a					IOOpenWrite:
.3a8a	a9 57		lda #$57			lda 	#'W'			 			; write
.3a8c	20 b7 39	jsr $39b7			jsr 	IOSetFileName 				; set up name/LFS
.3a8f	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for writing
.3a91	20 c9 ff	jsr $ffc9			jsr 	$FFC9 						; CHKOUT
.3a94	60		rts				rts
.3a95					IOWriteByte:
.3a95	48		pha				pha
.3a96	da		phx				phx
.3a97	5a		phy				phy
.3a98	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a9b	7a		ply				ply
.3a9c	fa		plx				plx
.3a9d	68		pla				pla
.3a9e	60		rts				rts

;******  Processing input file: source/main/zzfree.footer

>3a9f							.align 	256
.3b00					FreeMemory:

;******  End of listing
