
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl source/main/00main.header /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library _library.asm source/main/zzfree.footer
; Mon Oct  9 12:07:49 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: source/main/00main.header

.0801					StartBasicProgram:
>0801	0c 08						.word 	$080C 						; offset to next.
>0803	0a 00						.word 	10 							; line #
>0805	9e						.byte 	$9E 						; token for 'SYS'
>0806	20 32 30 36 32					.text 	' 2062'						; space, $080E in decimal
>080b	00						.byte  	0 							; end of line
>080c	00 00						.word 	0 							; end of program
.080e					StartCode:
.080e	4c 47 39	jmp $3947			jmp 	CompileCode 				; to starting the runtime in the saved code.
.0811	a9 3a		lda #$3a			lda 	#FreeMemory >> 8 			; address of object code to run.
.0813	a2 80		ldx #$80			ldx 	#$80 						; 8000-9EFF is used for workspace.
.0815	a0 9f		ldy #$9f			ldy 	#$9F
.0817	4c 26 08	jmp $0826			jmp 	StartRuntime 				; and go do it !
.081a					PatchOutCompile:
.081a	a9 ea		lda #$ea			lda 	#$EA 						; $EA is NOP 65C02
.081c	8d 0e 08	sta $080e			sta 	StartCode 					; patch out "JMP COMPILECODE"
.081f	8d 0f 08	sta $080f			sta 	StartCode+1
.0822	8d 10 08	sta $0810			sta 	StartCode+2
.0825	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.0826					StartRuntime:
.0826	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.0829	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.082b	64 28		stz $28				stz 	codePtr
.082d	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0830	8c 06 04	sty $0406			sty 	storeEndHigh
.0833	8e 07 04	stx $0407			stx 	variableStartPage
.0836	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.0838	a2 40		ldx #$40			ldx 	#RuntimeErrorHandler & $FF
.083a	20 c7 1e	jsr $1ec7			jsr 	SetErrorHandler
.083d	20 6f 0a	jsr $0a6f			jsr 	ClearMemory 				; clear memory.
.0840	20 4e 16	jsr $164e			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0843	20 50 13	jsr $1350		 	jsr		SetDefaultChannel			; set default input/output channel.
.0846	20 86 15	jsr $1586			jsr 	RestoreCode 				; which we now call
.0849	a0 00		ldy #$00			ldy 	#0
.084b					NextCommand:
.084b	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.084d	30 5b		bmi $08aa			bmi 	NXCommand 					; -if -ve command
.084f	c8		iny				iny
.0850	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0852	90 39		bcc $088d			bcc 	PushByteA 					; 0..63 is short constants.
.0854					NXLoadStore:
.0854	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.0856	b0 19		bcs $0871			bcs 	NXIndirectLoadStore
.0858	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.0859	4a		lsr a				lsr 	a
.085a	29 0e		and #$0e			and 	#$0E
.085c	da		phx				phx 								; get ready to jump
.085d	aa		tax				tax
.085e	7c 61 08	jmp ($0861,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.0861					ReadWriteVectors:
>0861	bc 14						.word 	ReadFloatCommand			; read float
>0863	97 1a						.word 	WriteFloatCommand 			; write float
>0865	f8 14						.word 	ReadIntegerCommand 			; read integer
>0867	d3 1a						.word 	WriteIntegerCommand 		; write integer
>0869	3d 15						.word 	ReadStringCommand 			; read string
>086b	12 1b						.word 	WriteStringCommand 			; write string
>086d	3d 0c						.word 	Unimplemented
>086f	3d 0c						.word 	Unimplemented
.0871					NXIndirectLoadStore:
.0871	29 07		and #$07			and 	#7
.0873	0a		asl a				asl 	a
.0874	da		phx				phx
.0875	aa		tax				tax
.0876	7c 79 08	jmp ($0879,x)			jmp 	(IndirectVectors,x)
.0879					IndirectVectors:
>0879	f2 0e						.word 	IndFloatRead 				; float read
>087b	06 0f						.word 	IndInt16Read 				; int16 read
>087d	1a 0f						.word 	IndStringRead 				; string read
>087f	3d 0c						.word 	Unimplemented
>0881	2e 0f						.word 	IndFloatWrite				; float write
>0883	42 0f						.word 	IndInt16Write 				; int16 write
>0885	56 0f						.word 	IndStringWrite 				; string write
>0887	3d 0c						.word 	Unimplemented
.0889					PushByteCommand:
.0889	fa		plx				plx
.088a	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.088c	c8		iny				iny
.088d					PushByteA:
.088d	e8		inx				inx 								; push constant on stack
.088e	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.0890	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.0892					ClearRestWord:
.0892	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.0894	74 62		stz $62,x			stz 	NSMantissa3,x
.0896	74 6e		stz $6e,x			stz 	NSExponent,x
.0898	74 32		stz $32,x			stz 	NSStatus,x
.089a	80 af		bra $084b			bra 	NextCommand
.089c					PushWordCommand:
.089c	fa		plx				plx
.089d	e8		inx				inx
.089e	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.08a0	c8		iny				iny
.08a1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08a3	b1 28		lda ($28),y			lda 	(codePtr),y
.08a5	c8		iny				iny
.08a6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08a8	80 e8		bra $0892			bra 	ClearRestWord 				; handle everything else.
.08aa					NXCommand:
.08aa	c8		iny				iny 								; consume command.
.08ab	10 03		bpl $08b0			bpl 	_NXCommandNoFixUp
.08ad	20 b6 08	jsr $08b6			jsr 	FixUpY
.08b0					_NXCommandNoFixUp:
.08b0	0a		asl a				asl 	a 							; shift left
.08b1	da		phx				phx 								; save SP on stack
.08b2	aa		tax				tax				 					; and jump indirect
.08b3	7c 78 19	jmp ($1978,x)			jmp 	(VectorTable,x)
.08b6					FixUpY:
.08b6	48		pha				pha
.08b7	98		tya				tya
.08b8	18		clc				clc
.08b9	65 28		adc $28				adc 	codePtr
.08bb	85 28		sta $28				sta 	codePtr
.08bd	90 02		bcc $08c1			bcc 	_NoCPCarry
.08bf	e6 29		inc $29				inc 	codePtr+1
.08c1					_NoCPCarry:
.08c1	a0 00		ldy #$00			ldy 	#0
.08c3	68		pla				pla
.08c4	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.08c5					AbsoluteTOS:
.08c5	fa		plx				plx
.08c6	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08c8	4c 4b 08	jmp $084b			jmp 	NextCommand
.08cb					CommandVarSpace:
.08cb	fa		plx				plx
.08cc	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08ce	85 26		sta $26				sta 	availableMemory
.08d0	c8		iny				iny
.08d1	b1 28		lda ($28),y			lda 	(codePtr),y
.08d3	18		clc				clc
.08d4	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08d7	85 27		sta $27				sta 	availableMemory+1
.08d9	c8		iny				iny
.08da	4c 4b 08	jmp $084b			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08dd					BinaryAnd:
.08dd	fa		plx				plx
.08de	38		sec				sec
.08df	80 02		bra $08e3			bra 	AndOrCommon
.08e1					BinaryOr:
.08e1	fa		plx				plx
.08e2	18		clc				clc
.08e3					AndOrCommon:
.08e3	08		php				php 								; save AND/OR flag
.08e4	20 2d 10	jsr $102d			jsr 	GetInteger16Bit
.08e7	ca		dex				dex
.08e8	20 2d 10	jsr $102d			jsr 	GetInteger16Bit
.08eb	28		plp				plp
.08ec	90 0e		bcc $08fc			bcc 	_AOCOrCode
.08ee	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.08f0	35 3f		and $3f,x			and		NSMantissa0+1,x
.08f2	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08f4	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.08f6	35 4b		and $4b,x			and		NSMantissa1+1,x
.08f8	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08fa	80 0c		bra $0908			bra 	_AOCComplete
.08fc					_AOCOrCode:
.08fc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.08fe	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.0900	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0902	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0904	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.0906	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0908					_AOCComplete:
.0908	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.090a	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.090c	10 07		bpl $0915			bpl 	_AOCExit
.090e	20 3d 10	jsr $103d			jsr 	Negate16Bit 				; 2's complement
.0911	a9 80		lda #$80			lda 	#$80 						; make it -ve
.0913	95 32		sta $32,x			sta 	NSStatus,x
.0915					_AOCExit:
.0915	4c 4b 08	jmp $084b			jmp 	NextCommand
.0918					ArrayConvert:
.0918	fa		plx				plx
.0919	5a		phy				phy
.091a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.091c	85 2e		sta $2e				sta 	zTemp1
.091e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0920	18		clc				clc
.0921	6d 07 04	adc $0407			adc 	variableStartPage
.0924	85 2f		sta $2f				sta 	zTemp1+1
.0926	ca		dex				dex 								; count of indices to follow -> zTemp2
.0927	20 27 10	jsr $1027			jsr 	GetInteger8Bit
.092a	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.092c	8a		txa				txa
.092d	38		sec				sec
.092e	e5 30		sbc $30				sbc 	zTemp2
.0930	aa		tax				tax
.0931	da		phx				phx 								; stack points at the first index, which will be replaced.
.0932					_ACIndexLoop:
.0932	20 6f 22	jsr $226f			jsr 	FloatIntegerPart 			; integer array index
.0935	20 2d 10	jsr $102d			jsr 	GetInteger16Bit 			; get the index => zTemp0
.0938	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.093a	a5 2c		lda $2c				lda 	zTemp0
.093c	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.093e	a5 2d		lda $2d				lda 	zTemp0+1
.0940	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0942	b0 79		bcs $09bd			bcs 	_ACBadIndex 				; index error.
.0944	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.0946	f0 29		beq $0971			beq 	_ACInnerLevel
.0948	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.094a	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.094c	10 6f		bpl $09bd			bpl 	_ACBadIndex
.094e	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0950	26 2d		rol $2d				rol 	zTemp0+1
.0952	18		clc				clc
.0953	a5 2c		lda $2c				lda		zTemp0
.0955	65 2e		adc $2e				adc 	zTemp1
.0957	85 2c		sta $2c				sta 	zTemp0
.0959	a5 2d		lda $2d				lda		zTemp0+1
.095b	65 2f		adc $2f				adc 	zTemp1+1
.095d	85 2d		sta $2d				sta 	zTemp0+1
.095f	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.0961	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0963	85 2e		sta $2e				sta 	zTemp1
.0965	c8		iny				iny
.0966	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0968	18		clc				clc
.0969	6d 07 04	adc $0407			adc 	variableStartPage
.096c	85 2f		sta $2f				sta 	zTemp1+1
.096e	e8		inx				inx 								; next index
.096f	80 c1		bra $0932			bra 	_ACIndexLoop
.0971					_ACInnerLevel:
.0971	a0 02		ldy #$02			ldy 	#2
.0973	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0975	30 46		bmi $09bd			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.0977	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.0979	c9 00		cmp #$00			cmp 	#NSSIFloat
.097b	d0 13		bne $0990			bne 	_ACNotFloat
.097d	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.097f	48		pha				pha
.0980	a5 2c		lda $2c				lda 	zTemp0
.0982	06 2c		asl $2c				asl 	zTemp0 						; x 2
.0984	26 2d		rol $2d				rol 	zTemp0+1
.0986	18		clc				clc 								; add back x 3
.0987	65 2c		adc $2c				adc 	zTemp0
.0989	85 2c		sta $2c				sta 	zTemp0
.098b	68		pla				pla
.098c	65 2d		adc $2d				adc 	zTemp0+1
.098e	85 2d		sta $2d				sta 	zTemp0+1
.0990					_ACNotFloat:
.0990	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.0992	26 2d		rol $2d				rol 	zTemp0+1
.0994	18		clc				clc
.0995	a5 2c		lda $2c				lda 	zTemp0
.0997	69 03		adc #$03			adc 	#3
.0999	85 2c		sta $2c				sta 	zTemp0
.099b	90 02		bcc $099f			bcc 	_ACNoCarry
.099d	e6 2d		inc $2d				inc 	zTemp0+1
.099f					_ACNoCarry:
.099f	fa		plx				plx 								; X points to first slot of array parameters
.09a0	18		clc				clc
.09a1	a5 2c		lda $2c				lda 	zTemp0
.09a3	65 2e		adc $2e				adc 	zTemp1
.09a5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.09a7	a5 2d		lda $2d				lda 	zTemp0+1
.09a9	65 2f		adc $2f				adc 	zTemp1+1
.09ab	38		sec				sec
.09ac	ed 07 04	sbc $0407			sbc 	variableStartPage
.09af	95 4a		sta $4a,x			sta 	NSMantissa1,x
.09b1	74 56		stz $56,x			stz 	NSMantissa2,x
.09b3	74 62		stz $62,x			stz 	NSMantissa3,x
.09b5	74 32		stz $32,x			stz 	NSStatus,x
.09b7	74 6e		stz $6e,x			stz 	NSExponent,x
.09b9	7a		ply				ply 	 							; restore code pointer
.09ba	4c 4b 08	jmp $084b			jmp 	NextCommand
.09bd					_ACBadIndex:
.09bd	4c c9 1f	jmp $1fc9		jmp	ErrorV_index
.09c0					UnaryAsc:
.09c0	fa		plx				plx
.09c1	5a		phy				phy
.09c2	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09c4	85 2c		sta $2c				sta 	zTemp0
.09c6	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09c8	85 2d		sta $2d				sta 	zTemp0+1
.09ca	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09cc	f0 06		beq $09d4			beq 	_UAExit
.09ce	5a		phy				phy 								; otherwise first character
.09cf	a0 01		ldy #$01			ldy 	#1
.09d1	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09d3	7a		ply				ply
.09d4					_UAExit:
.09d4	20 36 26	jsr $2636			jsr 	FloatSetByte
.09d7	7a		ply				ply
.09d8	4c 4b 08	jmp $084b			jmp 	NextCommand
.09db					CommandAssert:
.09db	fa		plx				plx
.09dc	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09de	d0 09		bne $09e9			bne 	_CAFail
.09e0	20 56 26	jsr $2656			jsr 	FloatIsZero 				; is it zero ?
.09e3	f0 04		beq $09e9			beq 	_CAFail
.09e5	ca		dex				dex
.09e6	4c 4b 08	jmp $084b			jmp 	NextCommand
.09e9					_CAFail:
.09e9	4c 22 1f	jmp $1f22		jmp	ErrorV_assert
.09ec					X16_Audio_Parameters8_16:
.09ec	20 f2 09	jsr $09f2			jsr 	X16_Audio_Parameters8_8
.09ef	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.09f1	60		rts				rts
.09f2					X16_Audio_Parameters8_8:
.09f2	a2 01		ldx #$01			ldx 	#1
.09f4	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.09f7	ca		dex				dex
.09f8	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.09fb	20 27 10	jsr $1027			jsr 	GetInteger8Bit
.09fe	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.0a00	a0 00		ldy #$00			ldy 	#0
.0a02	60		rts				rts
.0a03					X16_Audio_Parameters8_String:
.0a03	20 ec 09	jsr $09ec			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.0a06	da		phx				phx 								; set the voice
.0a07	5a		phy				phy
.0a08	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.0a0b	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>0a0e	0a						.byte 	X16_AudioCodeBank
.0a0f	7a		ply				ply
.0a10	fa		plx				plx
.0a11	86 2c		stx $2c				stx 	zTemp0
.0a13	84 2d		sty $2d				sty 	zTemp0+1
.0a15	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a17	e8		inx				inx 								; point YX to first character.
.0a18	d0 01		bne $0a1b			bne 	_X16APSSkip
.0a1a	c8		iny				iny
.0a1b					_X16APSSkip:
.0a1b	60		rts				rts
.0a1c					Unary16Bin:
.0a1c	fa		plx				plx
.0a1d	20 2d 10	jsr $102d			jsr 	GetInteger16Bit				; 16 bit int
.0a20	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a22	20 f7 16	jsr $16f7			jsr 	StringAllocTemp
.0a25	a5 2d		lda $2d				lda 	zTemp0+1
.0a27	f0 03		beq $0a2c			beq 	_UBNoHigh
.0a29	20 34 0a	jsr $0a34			jsr 	_UBWriteBinary
.0a2c					_UBNoHigh:
.0a2c	a5 2c		lda $2c				lda 	zTemp0
.0a2e	20 34 0a	jsr $0a34			jsr 	_UBWriteBinary
.0a31	4c 4b 08	jmp $084b			jmp 	NextCommand
.0a34					_UBWriteBinary:
.0a34	5a		phy				phy
.0a35	a0 08		ldy #$08			ldy 	#8
.0a37					_UBWLoop:
.0a37	0a		asl a				asl 	a
.0a38	48		pha				pha
.0a39	a9 00		lda #$00			lda  	#0
.0a3b	69 30		adc #$30			adc 	#48
.0a3d	20 20 17	jsr $1720			jsr 	StringWriteChar
.0a40	68		pla				pla
.0a41	88		dey				dey
.0a42	d0 f3		bne $0a37			bne 	_UBWLoop
.0a44	7a		ply				ply
.0a45	60		rts				rts
.0a46					PrintCharacterX:
.0a46	fa		plx				plx
.0a47	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a49	ca		dex				dex
.0a4a	20 54 13	jsr $1354			jsr 	VectorPrintCharacter
.0a4d	4c 4b 08	jmp $084b			jmp 	NextCommand
.0a50					UnaryChr:
.0a50	fa		plx				plx
.0a51	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; get integer to convert.
.0a54	48		pha				pha 								; save it and allocate for it
.0a55	a9 01		lda #$01			lda 	#1 							; 1 character
.0a57	20 f7 16	jsr $16f7			jsr 	StringAllocTemp
.0a5a	a9 01		lda #$01			lda 	#1 							; length 1.
.0a5c	92 22		sta ($22)			sta 	(zsTemp)
.0a5e	68		pla				pla 								; character code makes string.
.0a5f	5a		phy				phy
.0a60	a0 01		ldy #$01			ldy 	#1
.0a62	91 22		sta ($22),y			sta 	(zsTemp),y
.0a64	7a		ply				ply
.0a65	4c 4b 08	jmp $084b			jmp 	NextCommand
.0a68					CommandClr:
.0a68	fa		plx				plx
.0a69	20 6f 0a	jsr $0a6f			jsr 	ClearMemory
.0a6c	4c 4b 08	jmp $084b			jmp 	NextCommand
.0a6f					ClearMemory:
.0a6f	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a72	85 2d		sta $2d				sta 	zTemp0+1
.0a74	64 2c		stz $2c				stz 	zTemp0
.0a76	5a		phy				phy
.0a77	a0 00		ldy #$00			ldy 	#0
.0a79					_ClearLoop1:
.0a79	a9 00		lda #$00			lda 	#0
.0a7b	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a7d	c8		iny				iny
.0a7e	d0 f9		bne $0a79			bne 	_ClearLoop1
.0a80	e6 2d		inc $2d				inc 	zTemp0+1
.0a82	a5 2d		lda $2d				lda 	zTemp0+1
.0a84	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a87	d0 f0		bne $0a79			bne 	_ClearLoop1
.0a89	38		sec				sec 											; stack space = number of pages in total / 4
.0a8a	ad 06 04	lda $0406			lda 	storeEndHigh
.0a8d	ed 05 04	sbc $0405			sbc		storeStartHigh
.0a90	4a		lsr a				lsr 	a
.0a91	4a		lsr a				lsr 	a
.0a92	d0 02		bne $0a96			bne 	_NotEmpty 								; at least 1 !
.0a94	a9 01		lda #$01			lda 	#1
.0a96					_NotEmpty:
.0a96	38		sec				sec 											; subtract from high to give string high memory
.0a97	49 ff		eor #$ff			eor 	#$FF
.0a99	6d 06 04	adc $0406			adc 	storeEndHigh
.0a9c	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0a9f	9c 02 04	stz $0402			stz 	stringHighMemory
.0aa2	9c 68 05	stz $0568			stz 	stringInitialised 						; string system not initialised
.0aa5	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0aa8	3a		dec a				dec 	a
.0aa9	85 25		sta $25				sta 	runtimeStackPtr+1
.0aab	a9 ff		lda #$ff			lda 	#$FF
.0aad	85 24		sta $24				sta 	runtimeStackPtr
.0aaf	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0ab1	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0ab3	7a		ply				ply
.0ab4	60		rts				rts
.0ab5					CompareStrings:
.0ab5	fa		plx				plx
.0ab6	ca		dex				dex
.0ab7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0ab9	85 2c		sta $2c				sta 	zTemp0
.0abb	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0abd	85 2d		sta $2d				sta 	zTemp0+1
.0abf	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0ac1	85 2e		sta $2e				sta 	zTemp1
.0ac3	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0ac5	85 2f		sta $2f				sta 	zTemp1+1
.0ac7	da		phx				phx
.0ac8	5a		phy				phy
.0ac9	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0acb	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0acd	90 02		bcc $0ad1			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0acf	b2 2e		lda ($2e)			lda 	(zTemp1)
.0ad1					_CSNIsSmallest:
.0ad1	aa		tax				tax 								; count in X
.0ad2	f0 0c		beq $0ae0			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0ad4	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0ad6					_CSNCompareString:
.0ad6	c8		iny				iny 								; pre increment
.0ad7	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0ad9	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0adb	d0 0a		bne $0ae7			bne 	_CSNDifferent 				; numbers are different.
.0add	ca		dex				dex
.0ade	d0 f6		bne $0ad6			bne 	_CSNCompareString 			; compare common characters in two strings.
.0ae0					_CSNMatches:
.0ae0	38		sec				sec
.0ae1	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0ae3	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0ae5	f0 06		beq $0aed			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0ae7					_CSNDifferent:
.0ae7	a9 ff		lda #$ff			lda 	#$FF
.0ae9	90 02		bcc $0aed			bcc 	_CSNSExit
.0aeb	a9 01		lda #$01			lda 	#$01
.0aed					_CSNSExit:
.0aed	7a		ply				ply
.0aee	fa		plx				plx
.0aef	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0af1	20 36 26	jsr $2636			jsr 	FloatSetByte 				; output the byte
.0af4	4c 4b 08	jmp $084b			jmp 	NextCommand
.0af7					StringConcrete:
.0af7	9c 68 05	stz $0568			stz 	stringInitialised	 		; initialise next usage
.0afa	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0afc	85 30		sta $30				sta 	zTemp2
.0afe	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0b00	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0b01	18		clc				clc
.0b02	72 30		adc ($30)			adc 	(zTemp2)
.0b04	90 02		bcc $0b08			bcc 	_SCNoOverflow
.0b06	a9 ff		lda #$ff			lda 	#255
.0b08					_SCNoOverflow:
.0b08	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0b0a	b0 02		bcs $0b0e			bcs 	_SCNoMinimum
.0b0c	a9 0a		lda #$0a			lda 	#10
.0b0e					_SCNoMinimum:
.0b0e	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0b10	38		sec				sec
.0b11	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0b14	e5 2e		sbc $2e				sbc 	zTemp1
.0b16	a8		tay				tay
.0b17	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b1a	e9 00		sbc #$00			sbc 	#0
.0b1c	48		pha				pha
.0b1d	38		sec				sec 								; subtract 3 more
.0b1e	98		tya				tya
.0b1f	e9 03		sbc #$03			sbc 	#3
.0b21	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b24	85 22		sta $22				sta 	zsTemp
.0b26	68		pla				pla
.0b27	e9 00		sbc #$00			sbc 	#0
.0b29	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b2c	85 23		sta $23				sta 	zsTemp+1
.0b2e	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b30	92 22		sta ($22)			sta 	(zsTemp)
.0b32	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b34	a9 00		lda #$00			lda 	#0
.0b36	91 22		sta ($22),y			sta 	(zsTemp),y
.0b38	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b3a	a4 23		ldy $23				ldy 	zsTemp+1
.0b3c	60		rts				rts
.0b3d					CommandXData:
.0b3d	fa		plx				plx
.0b3e	98		tya				tya 								; data length +1 added to Y
.0b3f	38		sec				sec
.0b40	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b42	a8		tay				tay
.0b43	4c 4b 08	jmp $084b			jmp 	NextCommand
.0b46					CommandXDIM:
.0b46	fa		plx				plx
.0b47	5a		phy				phy
.0b48	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b4b	8d 08 04	sta $0408			sta 	dimType
.0b4e	ca		dex				dex 								; this is the number of indices
.0b4f	20 27 10	jsr $1027			jsr 	GetInteger8Bit
.0b52	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b54	8a		txa				txa 								; dimension.
.0b55	38		sec				sec
.0b56	e5 2e		sbc $2e				sbc 	zTemp1
.0b58	aa		tax				tax
.0b59	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b5b	20 6f 0b	jsr $0b6f			jsr 	DIMCreateOneLevel 			; create one at this level
.0b5e	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b60	98		tya				tya
.0b61	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b63	74 56		stz $56,x			stz 	NSMantissa2,x
.0b65	74 62		stz $62,x			stz 	NSMantissa3,x
.0b67	74 32		stz $32,x			stz 	NSStatus,x
.0b69	74 6e		stz $6e,x			stz 	NSExponent,x
.0b6b	7a		ply				ply
.0b6c	4c 4b 08	jmp $084b			jmp 	NextCommand
.0b6f					DIMCreateOneLevel:
.0b6f	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b71	5a		phy				phy
.0b72	a4 27		ldy $27				ldy 	availableMemory+1
.0b74	5a		phy				phy
.0b75	a8		tay				tay 			 					; save current level into Y
.0b76	20 2d 10	jsr $102d			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b79	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b7b	d0 02		bne $0b7f			bne 	_DCOLNoCarry
.0b7d	e6 2d		inc $2d				inc 	zTemp0+1
.0b7f					_DCOLNoCarry:
.0b7f	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b81	20 22 0c	jsr $0c22			jsr 	DIMWriteByte
.0b84	a5 2d		lda $2d				lda 	zTemp0+1
.0b86	20 22 0c	jsr $0c22			jsr 	DIMWriteByte
.0b89	ad 08 04	lda $0408			lda 	dimType 					; get type information
.0b8c	29 7f		and #$7f			and 	#$7F
.0b8e	c0 01		cpy #$01			cpy 	#1
.0b90	f0 02		beq $0b94			beq 	_DCOLNoSubLevel
.0b92	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0b94					_DCOLNoSubLevel:
.0b94	20 22 0c	jsr $0c22			jsr 	DIMWriteByte
.0b97	a5 26		lda $26				lda 	availableMemory
.0b99	85 2e		sta $2e				sta 	zTemp1
.0b9b	a5 27		lda $27				lda 	availableMemory+1
.0b9d	85 2f		sta $2f				sta 	zTemp1+1
.0b9f	a5 2c		lda $2c				lda 	zTemp0
.0ba1	85 30		sta $30				sta 	zTemp2
.0ba3	a5 2d		lda $2d				lda 	zTemp0+1
.0ba5	85 31		sta $31				sta 	zTemp2+1
.0ba7					_DCOLFillArray:
.0ba7	20 06 0c	jsr $0c06			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0baa	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0bac	d0 02		bne $0bb0			bne 	_DCOLNoBorrow
.0bae	c6 2d		dec $2d				dec 	zTemp0+1
.0bb0					_DCOLNoBorrow:
.0bb0	c6 2c		dec $2c				dec 	zTemp0
.0bb2	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0bb4	05 2d		ora $2d				ora 	zTemp0+1
.0bb6	d0 ef		bne $0ba7			bne 	_DCOLFillArray
.0bb8	c0 01		cpy #$01			cpy 	#1
.0bba	f0 42		beq $0bfe			beq 	_DCOLExit
.0bbc					_DCOLRecursionLoop:
.0bbc	da		phx				phx 								; save XY
.0bbd	5a		phy				phy
.0bbe	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0bc0	48		pha				pha
.0bc1	a5 2f		lda $2f				lda 	zTemp1+1
.0bc3	48		pha				pha
.0bc4	a5 30		lda $30				lda 	zTemp2
.0bc6	48		pha				pha
.0bc7	a5 31		lda $31				lda 	zTemp2+1
.0bc9	48		pha				pha
.0bca	88		dey				dey  								; lower level -> A
.0bcb	98		tya				tya
.0bcc	e8		inx				inx 								; next index size
.0bcd	20 6f 0b	jsr $0b6f			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0bd0	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0bd1	86 31		stx $31				stx 	zTemp2+1
.0bd3	fa		plx				plx
.0bd4	86 30		stx $30				stx 	zTemp2
.0bd6	fa		plx				plx
.0bd7	86 2f		stx $2f				stx 	zTemp1+1
.0bd9	fa		plx				plx
.0bda	86 2e		stx $2e				stx 	zTemp1
.0bdc	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0bde	98		tya				tya
.0bdf	a0 01		ldy #$01			ldy 	#1
.0be1	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0be3	7a		ply				ply 								; restore XY
.0be4	fa		plx				plx
.0be5	18		clc				clc
.0be6	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0be8	69 02		adc #$02			adc 	#2
.0bea	85 2e		sta $2e				sta 	zTemp1
.0bec	90 02		bcc $0bf0			bcc 	_DCOLRNoCarry
.0bee	e6 2f		inc $2f				inc 	zTemp1+1
.0bf0					_DCOLRNoCarry:
.0bf0	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0bf2	d0 02		bne $0bf6			bne 	_DCOLRNoBorrow
.0bf4	c6 31		dec $31				dec 	zTemp2+1
.0bf6					_DCOLRNoBorrow:
.0bf6	c6 30		dec $30				dec 	zTemp2
.0bf8	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0bfa	05 31		ora $31				ora 	zTemp2+1
.0bfc	d0 be		bne $0bbc			bne 	_DCOLRecursionLoop
.0bfe					_DCOLExit:
.0bfe	68		pla				pla 								; get MSB, make offset again
.0bff	38		sec				sec
.0c00	ed 07 04	sbc $0407			sbc 	variableStartPage
.0c03	a8		tay				tay
.0c04	68		pla				pla 								; YA now contains offset address.
.0c05	60		rts				rts
.0c06					DIMWriteElement:
.0c06	da		phx				phx
.0c07	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0c09	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0c0b	d0 0b		bne $0c18			bne 	_DIMWENotFloat
.0c0d	ad 08 04	lda $0408			lda 	dimType
.0c10	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0c12	c9 00		cmp #$00			cmp 	#NSSIFloat
.0c14	d0 02		bne $0c18			bne 	_DIMWENotFloat
.0c16	a2 06		ldx #$06			ldx 	#6
.0c18					_DIMWENotFloat:
.0c18	a9 00		lda #$00			lda 	#0
.0c1a	20 22 0c	jsr $0c22			jsr 	DIMWriteByte
.0c1d	ca		dex				dex
.0c1e	d0 f8		bne $0c18			bne 	_DIMWENotFloat
.0c20	fa		plx				plx
.0c21	60		rts				rts
.0c22					DIMWriteByte:
.0c22	92 26		sta ($26)			sta 	(availableMemory)
.0c24	e6 26		inc $26				inc 	availableMemory
.0c26	d0 0b		bne $0c33			bne 	_DIMWBSkip
.0c28	e6 27		inc $27				inc 	availableMemory+1
.0c2a	48		pha				pha
.0c2b	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c2d	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c30	b0 02		bcs $0c34			bcs 	_DIMWBMemory
.0c32	68		pla				pla
.0c33					_DIMWBSkip:
.0c33	60		rts				rts
.0c34					_DIMWBMemory:
.0c34	4c dc 1f	jmp $1fdc		jmp	ErrorV_memory
.0408					dimType:
>0408							.fill 	1
.0c37					CommandEnd:
.0c37	fa		plx				plx
.0c38	86 2c		stx $2c				stx 	zTemp0
.0c3a	4c ff ff	jmp $ffff			jmp 	$FFFF
.0c3d					Unimplemented:
.0c3d	4c 0f 1f	jmp $1f0f			jmp 	ErrorV_unimplemented
.0c40					RuntimeErrorHandler:
.0c40	98		tya				tya
.0c41	18		clc				clc
.0c42	65 28		adc $28				adc 	codePtr
.0c44	85 28		sta $28				sta 	codePtr
.0c46	90 02		bcc $0c4a			bcc 	_EHNoCarry
.0c48	e6 29		inc $29				inc 	codePtr+1
.0c4a					_EHNoCarry:
.0c4a	68		pla				pla
.0c4b	7a		ply				ply
.0c4c	85 2c		sta $2c				sta 	zTemp0
.0c4e	84 2d		sty $2d				sty 	zTemp0+1
.0c50	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c52	a0 01		ldy #$01			ldy 	#1
.0c54					_EHDisplayMsg:
.0c54	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c56	20 6c 1c	jsr $1c6c			jsr 	XPrintCharacterToChannel
.0c59	c8		iny				iny
.0c5a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c5c	d0 f6		bne $0c54			bne 	_EHDisplayMsg
.0c5e	a9 20		lda #$20			lda 	#32
.0c60	20 6c 1c	jsr $1c6c			jsr 	XPrintCharacterToChannel
.0c63	a9 40		lda #$40			lda 	#64
.0c65	20 6c 1c	jsr $1c6c			jsr 	XPrintCharacterToChannel
.0c68	a9 20		lda #$20			lda 	#32
.0c6a	20 6c 1c	jsr $1c6c			jsr 	XPrintCharacterToChannel
.0c6d	20 72 0c	jsr $0c72			jsr 	EHDisplayCodePtr
.0c70	80 fe		bra $0c70	_EHStop:bra 	_EHStop
.0c72					EHDisplayCodePtr:
.0c72	a9 24		lda #$24			lda 	#'$'
.0c74	20 6c 1c	jsr $1c6c			jsr 	XPrintCharacterToChannel
.0c77	38		sec				sec
.0c78	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c7a	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c7d	20 86 0c	jsr $0c86			jsr 	_EHDisplayHex
.0c80	a5 28		lda $28				lda 	codePtr
.0c82	20 86 0c	jsr $0c86			jsr 	_EHDisplayHex
.0c85	60		rts				rts
.0c86					_EHDisplayHex:
.0c86	48		pha				pha
.0c87	4a		lsr a				lsr 	a
.0c88	4a		lsr a				lsr 	a
.0c89	4a		lsr a				lsr 	a
.0c8a	4a		lsr a				lsr 	a
.0c8b	20 8f 0c	jsr $0c8f			jsr 	_EHDisplayNibble
.0c8e	68		pla				pla
.0c8f					_EHDisplayNibble:
.0c8f	29 0f		and #$0f			and 	#15
.0c91	c9 0a		cmp #$0a			cmp 	#10
.0c93	90 02		bcc $0c97			bcc 	_EHNotHex
.0c95	69 06		adc #$06			adc 	#6
.0c97					_EHNotHex:
.0c97	69 30		adc #$30			adc 	#48
.0c99	4c 6c 1c	jmp $1c6c			jmp 	XPrintCharacterToChannel
.0c9c					CommandXFor:
.0c9c	fa		plx				plx
.0c9d	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0c9f	20 1f 0d	jsr $0d1f			jsr 	StackOpenFrame
.0ca2	20 5e 11	jsr $115e			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0ca5	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0ca7	20 01 0d	jsr $0d01			jsr 	CopyTOSToOffsetY
.0caa	ca		dex				dex
.0cab	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0cad	20 01 0d	jsr $0d01			jsr 	CopyTOSToOffsetY
.0cb0	ca		dex				dex
.0cb1	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0cb3	29 80		and #$80			and 	#$80
.0cb5	a0 04		ldy #$04			ldy 	#4
.0cb7	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cb9	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0cbb	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0cbd	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cbf	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0cc1	c8		iny				iny
.0cc2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cc4	18		clc				clc
.0cc5	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0cc7	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cc9	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0ccc	85 2d		sta $2d				sta 	zTemp0+1
.0cce	ca		dex				dex 								; throw reference.
.0ccf	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0cd1	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0cd3	a0 0c		ldy #$0c			ldy 	#12
.0cd5	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cd7	a0 12		ldy #$12			ldy 	#18
.0cd9	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cdb	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0cdd	88		dey				dey 								; now the exponents.
.0cde	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0ce0	a0 0b		ldy #$0b			ldy 	#11
.0ce2	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0ce4	a0 11		ldy #$11			ldy 	#17
.0ce6	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0ce8	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0cea	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cec	c8		iny				iny
.0ced	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cef	c8		iny				iny
.0cf0	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf2	d0 08		bne $0cfc			bne 	_CFNoOptimise
.0cf4	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0cf6	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0cf8	09 40		ora #$40			ora 	#$40
.0cfa	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cfc					_CFNoOptimise:
.0cfc	a0 00		ldy #$00			ldy 	#0
.0cfe	4c 4b 08	jmp $084b			jmp 	NextCommand
.0d01					CopyTOSToOffsetY:
.0d01	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0d03	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d05	c8		iny				iny
.0d06	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0d08	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d0a	c8		iny				iny
.0d0b	b5 56		lda $56,x			lda 	NSMantissa2,x
.0d0d	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d0f	c8		iny				iny
.0d10	b5 62		lda $62,x			lda 	NSMantissa3,x
.0d12	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d14	c8		iny				iny
.0d15	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d17	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d19	c8		iny				iny
.0d1a	b5 32		lda $32,x			lda 	NSStatus,x
.0d1c	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d1e	60		rts				rts
.0d1f					StackOpenFrame:
.0d1f	48		pha				pha 								; save frame marker
.0d20	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d22	85 2c		sta $2c				sta 	zTemp0
.0d24	38		sec				sec 								; subtract from runtime stack pointer.
.0d25	a5 24		lda $24				lda		runtimeStackPtr
.0d27	e5 2c		sbc $2c				sbc 	zTemp0
.0d29	85 24		sta $24				sta 	runtimeStackPtr
.0d2b	a5 25		lda $25				lda		runtimeStackPtr+1
.0d2d	e9 00		sbc #$00			sbc 	#0
.0d2f	85 25		sta $25				sta 	runtimeStackPtr+1
.0d31	68		pla				pla 								; put frame marker at +0
.0d32	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d34	60		rts				rts
.0d35					StackCloseFrame:
.0d35	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d37	29 1f		and #$1f			and 	#$1F 						; size
.0d39	18		clc				clc
.0d3a	65 24		adc $24				adc 	runtimeStackPtr
.0d3c	85 24		sta $24				sta 	runtimeStackPtr
.0d3e	90 02		bcc $0d42			bcc 	_SCFNoCarry
.0d40	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d42					_SCFNoCarry:
.0d42	60		rts				rts
.0d43					StackFindFrame:
.0d43	8d 09 04	sta $0409			sta 	requiredFrame
.0d46					_SFFLoop:
.0d46	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d48	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d4a	f0 10		beq $0d5c			beq 	SCFFail
.0d4c	cd 09 04	cmp $0409			cmp 	requiredFrame 				; found this type ?
.0d4f	f0 05		beq $0d56			beq 	_SFFFound
.0d51	20 35 0d	jsr $0d35			jsr 	StackCloseFrame 			; close the top frame
.0d54	80 f0		bra $0d46			bra 	_SFFLoop 					; and try te next.
.0d56					_SFFFound:
.0d56	60		rts				rts
.0d57					StackCheckFrame:
.0d57	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d59	d0 01		bne $0d5c			bne 	SCFFail
.0d5b	60		rts				rts
.0d5c					SCFFail:
.0d5c	4c 6c 1f	jmp $1f6c		jmp	ErrorV_structure
.0409					requiredFrame:
>0409							.fill 	1
.0d5f					UnaryFre:
.0d5f	fa		plx				plx
.0d60	20 34 26	jsr $2634			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d63	38		sec				sec
.0d64	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d67	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d6a	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d6c	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d6f	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d72	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d74	4c 4b 08	jmp $084b			jmp 	NextCommand
.0d77					CommandXGet:
.0d77	fa		plx				plx
.0d78	e8		inx				inx
.0d79	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d7b	20 f7 16	jsr $16f7			jsr 	StringAllocTemp
.0d7e	20 5d 13	jsr $135d			jsr 	VectorGetCharacter 			; get a character
.0d81	c9 00		cmp #$00			cmp 	#0
.0d83	f0 09		beq $0d8e			beq 	_CGNone
.0d85	5a		phy				phy
.0d86	a0 01		ldy #$01			ldy 	#1 							; store char
.0d88	91 22		sta ($22),y			sta 	(zsTemp),y
.0d8a	98		tya				tya 								; store length.
.0d8b	92 22		sta ($22)			sta 	(zsTemp)
.0d8d	7a		ply				ply
.0d8e					_CGNone:
.0d8e	4c 4b 08	jmp $084b			jmp 	NextCommand
.0d91					CommandXGosub:
.0d91	fa		plx				plx
.0d92	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0d94	20 1f 0d	jsr $0d1f			jsr 	StackOpenFrame
.0d97	20 5e 11	jsr $115e			jsr 	StackSaveCurrentPosition
.0d9a	4c af 0d	jmp $0daf			jmp 	PerformGOTO
.0d9d					CommandReturn:
.0d9d	fa		plx				plx
.0d9e	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0da0	20 43 0d	jsr $0d43			jsr 	StackFindFrame
.0da3	20 6f 11	jsr $116f			jsr 	StackLoadCurrentPosition
.0da6	c8		iny				iny
.0da7	c8		iny				iny
.0da8	20 35 0d	jsr $0d35			jsr 	StackCloseFrame
.0dab	4c 4b 08	jmp $084b			jmp 	NextCommand
.0dae					CommandXGoto:
.0dae	fa		plx				plx
.0daf					PerformGOTO:
.0daf	c8		iny				iny 								; push MSB of offset on stack
.0db0	b1 28		lda ($28),y			lda 	(codePtr),y
.0db2	48		pha				pha
.0db3	88		dey				dey 								; point LSB of offset
.0db4	18		clc				clc 								; add LSB
.0db5	b1 28		lda ($28),y			lda 	(codePtr),y
.0db7	65 28		adc $28				adc 	codePtr
.0db9	85 28		sta $28				sta 	codePtr
.0dbb	68		pla				pla 								; restore offset MSB and add
.0dbc	65 29		adc $29				adc 	codePtr+1
.0dbe	85 29		sta $29				sta 	codePtr+1
.0dc0	4c 4b 08	jmp $084b			jmp 	NextCommand
.0dc3					CommandGotoZ:
.0dc3	fa		plx				plx
.0dc4	20 56 26	jsr $2656			jsr 	FloatIsZero
.0dc7	ca		dex				dex
.0dc8	c9 00		cmp #$00			cmp 	#0
.0dca	f0 e3		beq $0daf			beq 	PerformGOTO
.0dcc	c8		iny				iny
.0dcd	c8		iny				iny
.0dce	4c 4b 08	jmp $084b			jmp 	NextCommand
.0dd1					CommandGotoNZ:
.0dd1	fa		plx				plx
.0dd2	20 56 26	jsr $2656			jsr 	FloatIsZero
.0dd5	ca		dex				dex
.0dd6	c9 00		cmp #$00			cmp 	#0
.0dd8	d0 d5		bne $0daf			bne 	PerformGOTO
.0dda	c8		iny				iny
.0ddb	c8		iny				iny
.0ddc	4c 4b 08	jmp $084b			jmp 	NextCommand
.0ddf					Command_PSET:
.0ddf	fa		plx				plx
.0de0	5a		phy				phy
.0de1	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; get the colour
.0de4	48		pha				pha
.0de5	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0de7	a0 02		ldy #$02			ldy 	#X16_r0
.0de9	20 6b 0e	jsr $0e6b			jsr 	GraphicsCopy2
.0dec	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0def	68		pla				pla 								; set pixel.
.0df0	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0df3	7a		ply				ply
.0df4	a2 ff		ldx #$ff			ldx 	#$FF
.0df6	4c 4b 08	jmp $084b			jmp 	NextCommand
.0df9					Command_LINE:
.0df9	fa		plx				plx
.0dfa	5a		phy				phy
.0dfb	20 5e 0e	jsr $0e5e			jsr 	GraphicsColour
.0dfe	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0e00	a0 02		ldy #$02			ldy 	#X16_r0
.0e02	20 68 0e	jsr $0e68			jsr 	GraphicsCopy4
.0e05	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0e08	7a		ply				ply
.0e09	a2 ff		ldx #$ff			ldx 	#$FF
.0e0b	4c 4b 08	jmp $084b			jmp 	NextCommand
.0e0e					Command_RECT:
.0e0e	fa		plx				plx
.0e0f	5a		phy				phy
.0e10	20 7f 0e	jsr $0e7f			jsr 	GraphicsRectCoords
.0e13	38		sec				sec
.0e14	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e17	7a		ply				ply
.0e18	a2 ff		ldx #$ff			ldx 	#$FF
.0e1a	4c 4b 08	jmp $084b			jmp 	NextCommand
.0e1d					Command_FRAME:
.0e1d	fa		plx				plx
.0e1e	5a		phy				phy
.0e1f	20 7f 0e	jsr $0e7f			jsr 	GraphicsRectCoords
.0e22	18		clc				clc
.0e23	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e26	7a		ply				ply
.0e27	a2 ff		ldx #$ff			ldx 	#$FF
.0e29	4c 4b 08	jmp $084b			jmp 	NextCommand
.0e2c					Command_CHAR:
.0e2c	fa		plx				plx
.0e2d	5a		phy				phy
.0e2e	ca		dex				dex  								; set the draw colour
.0e2f	20 5e 0e	jsr $0e5e			jsr 	GraphicsColour
.0e32	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e34	a0 02		ldy #$02			ldy 	#X16_r0
.0e36	20 6b 0e	jsr $0e6b			jsr 	GraphicsCopy2
.0e39	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e3b	85 2c		sta $2c				sta 	zTemp0
.0e3d	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e3f	85 2d		sta $2d				sta 	zTemp0+1
.0e41	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e43	85 2e		sta $2e				sta 	zTemp1
.0e45					_CCLoop:
.0e45	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e47	f0 0f		beq $0e58			beq 	_CCExit
.0e49	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e4b	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e4d	d0 02		bne $0e51			bne 	_CCNoCarry
.0e4f	e6 2d		inc $2d				inc 	zTemp0+1
.0e51					_CCNoCarry:
.0e51	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e53	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e56	80 ed		bra $0e45			bra 	_CCLoop						; go round.
.0e58					_CCExit:
.0e58	7a		ply				ply
.0e59	a2 ff		ldx #$ff			ldx 	#$FF
.0e5b	4c 4b 08	jmp $084b			jmp 	NextCommand
.0e5e					GraphicsColour:
.0e5e	20 27 10	jsr $1027			jsr 	GetInteger8Bit
.0e61	aa		tax				tax
.0e62	a0 00		ldy #$00			ldy 	#0
.0e64	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e67	60		rts				rts
.0e68					GraphicsCopy4:
.0e68	20 6b 0e	jsr $0e6b			jsr 	GraphicsCopy2
.0e6b					GraphicsCopy2:
.0e6b	20 6e 0e	jsr $0e6e			jsr 	GraphicsCopy1
.0e6e					GraphicsCopy1:
.0e6e	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.0e71	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e73	99 00 00	sta $0000,y			sta 	0,y
.0e76	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e78	99 01 00	sta $0001,y			sta 	1,y
.0e7b	e8		inx				inx
.0e7c	c8		iny				iny
.0e7d	c8		iny				iny
.0e7e	60		rts				rts
.0e7f					GraphicsRectCoords:
.0e7f	20 5e 0e	jsr $0e5e			jsr 	GraphicsColour 				; set colour
.0e82	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e84	a0 02		ldy #$02			ldy 	#X16_r0
.0e86	20 68 0e	jsr $0e68			jsr 	GraphicsCopy4
.0e89	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0e8b	20 98 0e	jsr $0e98			jsr 	_GRCSortSubtract
.0e8e	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0e90	20 98 0e	jsr $0e98			jsr 	_GRCSortSubtract
.0e93	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0e95	74 09		stz $09,x			stz 	9,x
.0e97	60		rts				rts
.0e98					_GRCSortSubtract:
.0e98	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0e9a	d5 00		cmp $00,x			cmp 	0,x
.0e9c	b5 05		lda $05,x			lda 	5,x
.0e9e	f5 01		sbc $01,x			sbc 	1,x
.0ea0	b0 08		bcs $0eaa			bcs 	_GRCNoSwap 					; >= swap.
.0ea2	20 b8 0e	jsr $0eb8			jsr 	_GRCSwapByte 				; swap 0/2
.0ea5	e8		inx				inx
.0ea6	20 b8 0e	jsr $0eb8			jsr 	_GRCSwapByte 				; swap 1/3
.0ea9	ca		dex				dex
.0eaa					_GRCNoSwap:
.0eaa	38		sec				sec 								; calculate width/height into 4,5
.0eab	b5 04		lda $04,x			lda 	4,x
.0ead	f5 00		sbc $00,x			sbc 	0,x
.0eaf	95 04		sta $04,x			sta 	4,x
.0eb1	b5 05		lda $05,x			lda 	5,x
.0eb3	f5 01		sbc $01,x			sbc 	1,x
.0eb5	95 05		sta $05,x			sta 	5,x
.0eb7	60		rts				rts
.0eb8					_GRCSwapByte:
.0eb8	b5 04		lda $04,x			lda 	4,x
.0eba	48		pha				pha
.0ebb	b5 00		lda $00,x			lda 	0,x
.0ebd	95 04		sta $04,x			sta 	4,x
.0ebf	68		pla				pla
.0ec0	95 00		sta $00,x			sta 	0,x
.0ec2	60		rts				rts
.0ec3					Unary16Hex:
.0ec3	fa		plx				plx
.0ec4	20 2d 10	jsr $102d			jsr 	GetInteger16Bit
.0ec7	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0ec9	20 f7 16	jsr $16f7			jsr 	StringAllocTemp
.0ecc	a5 2d		lda $2d				lda 	zTemp0+1
.0ece	f0 03		beq $0ed3			beq 	_UHNoHigh
.0ed0	20 db 0e	jsr $0edb			jsr 	_UHWriteHex
.0ed3					_UHNoHigh:
.0ed3	a5 2c		lda $2c				lda 	zTemp0
.0ed5	20 db 0e	jsr $0edb			jsr 	_UHWriteHex
.0ed8	4c 4b 08	jmp $084b			jmp 	NextCommand
.0edb					_UHWriteHex:
.0edb	48		pha				pha
.0edc	4a		lsr a				lsr 	a
.0edd	4a		lsr a				lsr 	a
.0ede	4a		lsr a				lsr 	a
.0edf	4a		lsr a				lsr 	a
.0ee0	20 e4 0e	jsr $0ee4			jsr 	_UHWriteNibl
.0ee3	68		pla				pla
.0ee4					_UHWriteNibl:
.0ee4	29 0f		and #$0f			and 	#15
.0ee6	c9 0a		cmp #$0a			cmp 	#10
.0ee8	90 02		bcc $0eec			bcc 	_UHDigit
.0eea	69 06		adc #$06			adc 	#6
.0eec					_UHDigit:
.0eec	69 30		adc #$30			adc 	#48
.0eee	20 20 17	jsr $1720			jsr 	StringWriteChar
.0ef1	60		rts				rts
.0ef2					IndFloatRead:
.0ef2	fa		plx				plx
.0ef3	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0ef5	85 2c		sta $2c				sta 	zTemp0
.0ef7	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ef9	18		clc				clc
.0efa	6d 07 04	adc $0407			adc 	variableStartPage
.0efd	85 2d		sta $2d				sta 	zTemp0+1
.0eff	ca		dex				dex 								; throw the address
.0f00	20 d6 14	jsr $14d6			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0f03	4c 4b 08	jmp $084b			jmp 	NextCommand
.0f06					IndInt16Read:
.0f06	fa		plx				plx
.0f07	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f09	85 2c		sta $2c				sta 	zTemp0
.0f0b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f0d	18		clc				clc
.0f0e	6d 07 04	adc $0407			adc 	variableStartPage
.0f11	85 2d		sta $2d				sta 	zTemp0+1
.0f13	ca		dex				dex 								; throw the address
.0f14	20 12 15	jsr $1512			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f17	4c 4b 08	jmp $084b			jmp 	NextCommand
.0f1a					IndStringRead:
.0f1a	fa		plx				plx
.0f1b	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f1d	85 2c		sta $2c				sta 	zTemp0
.0f1f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f21	18		clc				clc
.0f22	6d 07 04	adc $0407			adc 	variableStartPage
.0f25	85 2d		sta $2d				sta 	zTemp0+1
.0f27	ca		dex				dex 								; throw the address
.0f28	20 57 15	jsr $1557			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f2b	4c 4b 08	jmp $084b			jmp 	NextCommand
.0f2e					IndFloatWrite:
.0f2e	fa		plx				plx
.0f2f	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f31	85 2c		sta $2c				sta 	zTemp0
.0f33	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f35	18		clc				clc
.0f36	6d 07 04	adc $0407			adc 	variableStartPage
.0f39	85 2d		sta $2d				sta 	zTemp0+1
.0f3b	20 b1 1a	jsr $1ab1			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f3e	ca		dex				dex 								; throw the address as well.
.0f3f	4c 4b 08	jmp $084b			jmp 	NextCommand
.0f42					IndInt16Write:
.0f42	fa		plx				plx
.0f43	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f45	85 2c		sta $2c				sta 	zTemp0
.0f47	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f49	18		clc				clc
.0f4a	6d 07 04	adc $0407			adc 	variableStartPage
.0f4d	85 2d		sta $2d				sta 	zTemp0+1
.0f4f	20 ed 1a	jsr $1aed			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f52	ca		dex				dex 								; throw the address as well.
.0f53	4c 4b 08	jmp $084b			jmp 	NextCommand
.0f56					IndStringWrite:
.0f56	fa		plx				plx
.0f57	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f59	85 2c		sta $2c				sta 	zTemp0
.0f5b	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f5d	18		clc				clc
.0f5e	6d 07 04	adc $0407			adc 	variableStartPage
.0f61	85 2d		sta $2d				sta 	zTemp0+1
.0f63	20 2c 1b	jsr $1b2c			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f66	ca		dex				dex 								; throw the address as well.
.0f67	4c 4b 08	jmp $084b			jmp 	NextCommand
.0f6a					CommandXInput:
.0f6a	fa		plx				plx
.0f6b	5a		phy				phy 								; save Y
.0f6c	e8		inx				inx									; space on stack
.0f6d					_INError:
.0f6d	20 a1 0f	jsr $0fa1			jsr 	InputStringToBuffer 		; input from keyboard
.0f70	a9 5f		lda #$5f			lda 	#((ReadBufferSize) & $FF)
.0f72	85 2c		sta $2c				sta 	0+zTemp0
.0f74	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f76	85 2d		sta $2d				sta 	1+zTemp0
.0f78	20 3e 19	jsr $193e			jsr 	ValEvaluateZTemp0
.0f7b	b0 f0		bcs $0f6d			bcs 	_INError 					; failed, try again.
.0f7d	7a		ply				ply 								; restore Y
.0f7e	4c 4b 08	jmp $084b			jmp 	NextCommand
.0f81					CommandInputString:
.0f81	fa		plx				plx
.0f82	5a		phy				phy 								; save Y
.0f83	20 a1 0f	jsr $0fa1			jsr 	InputStringToBuffer 		; input from keyboard
.0f86	e8		inx				inx 								; make space on stack
.0f87	20 34 26	jsr $2634			jsr 	FloatSetZero 				; store as string on stack
.0f8a	a9 5f		lda #$5f			lda 	#ReadBufferSize & $FF
.0f8c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0f8e	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0f90	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0f92	a9 40		lda #$40			lda 	#NSSString
.0f94	95 32		sta $32,x			sta 	NSStatus,x
.0f96	7a		ply				ply 								; restore Y
.0f97	4c 4b 08	jmp $084b			jmp 	NextCommand
.0f9a					CommandInputReset:
.0f9a	fa		plx				plx
.0f9b	9c 0a 04	stz $040a			stz 	InputBuffer
.0f9e	4c 4b 08	jmp $084b			jmp 	NextCommand
.0fa1					InputStringToBuffer:
.0fa1	a9 db		lda #$db			lda 	#((InputBumpNext) & $FF)
.0fa3	8d 5f 05	sta $055f			sta 	0+ReadBumpNextVec
.0fa6	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0fa8	8d 60 05	sta $0560			sta 	1+ReadBumpNextVec
.0fab	a9 b8		lda #$b8			lda 	#((InputLookNext) & $FF)
.0fad	8d 61 05	sta $0561			sta 	0+ReadLookNextVec
.0fb0	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0fb2	8d 62 05	sta $0562			sta 	1+ReadLookNextVec
.0fb5	4c 33 14	jmp $1433			jmp 	GetStringToBuffer
.0fb8					InputLookNext:
.0fb8	da		phx				phx
.0fb9					_ILNRetry:
.0fb9	ad 0a 04	lda $040a			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fbc	d0 08		bne $0fc6			bne 	_ILNNotEmpty
.0fbe	20 df 0f	jsr $0fdf			jsr 	InputGetNewLine 			; get a new line
.0fc1	9c 5b 04	stz $045b			stz 	InputBufferPos 				; reset read position.
.0fc4	80 f3		bra $0fb9			bra 	_ILNRetry
.0fc6					_ILNNotEmpty:
.0fc6	ae 5b 04	ldx $045b			ldx 	InputBufferPos 				; get head available character
.0fc9	bd 0a 04	lda $040a,x			lda 	InputBuffer,x
.0fcc	d0 08		bne $0fd6			bne 	_ILNExit 					; if not EOS return it with CC.
.0fce					_ILNNextLine:
.0fce	9c 0a 04	stz $040a			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0fd1	38		sec				sec 								; return CS,Zero
.0fd2	fa		plx				plx
.0fd3	a9 0d		lda #$0d			lda 	#13
.0fd5	60		rts				rts
.0fd6					_ILNExit:
.0fd6	fa		plx				plx
.0fd7	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0fd9	18		clc				clc
.0fda	60		rts				rts
.0fdb					InputBumpNext:
.0fdb	ee 5b 04	inc $045b			inc 	InputBufferPos
.0fde	60		rts				rts
.0fdf					InputGetNewLine:
.0fdf	48		pha				pha
.0fe0	da		phx				phx
.0fe1	5a		phy				phy
.0fe2	a9 3f		lda #$3f			lda 	#"?"
.0fe4	20 1e 10	jsr $101e			jsr 	IGNLEchoIfScreen
.0fe7	a0 00		ldy #$00			ldy 	#0 							; line position.
.0fe9					_IGNLLoop:
.0fe9	20 5d 13	jsr $135d			jsr 	VectorGetCharacter 			; get a character
.0fec	c9 00		cmp #$00			cmp 	#0
.0fee	f0 f9		beq $0fe9			beq 	_IGNLLoop
.0ff0	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.0ff2	f0 11		beq $1005			beq 	_IGNBackspace
.0ff4	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.0ff6	f0 17		beq $100f			beq 	_IGNExit
.0ff8	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.0ffa	f0 ed		beq $0fe9			beq 	_IGNLLoop
.0ffc	99 0a 04	sta $040a,y			sta 	InputBuffer,y
.0fff	c8		iny				iny
.1000	20 1e 10	jsr $101e			jsr 	IGNLEchoIfScreen
.1003	80 e4		bra $0fe9			bra 	_IGNLLoop
.1005					_IGNBackspace:
.1005	c0 00		cpy #$00			cpy 	#0
.1007	f0 e0		beq $0fe9			beq 	_IGNLLoop
.1009	20 1e 10	jsr $101e			jsr 	IGNLEchoIfScreen
.100c	88		dey				dey
.100d	80 da		bra $0fe9			bra 	_IGNLLoop
.100f					_IGNExit:
.100f	20 1e 10	jsr $101e			jsr 	IGNLEchoIfScreen
.1012	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.1014	99 0a 04	sta $040a,y			sta 	InputBuffer,y
.1017	9c 5b 04	stz $045b			stz 	InputBufferPos 				; reset position to start of input buffer.
.101a	7a		ply				ply
.101b	fa		plx				plx
.101c	68		pla				pla
.101d	60		rts				rts
.101e					IGNLEchoIfScreen:
.101e	ae 5d 04	ldx $045d			ldx 	currentChannel
.1021	d0 03		bne $1026			bne 	_IGNLEExit
.1023	20 54 13	jsr $1354			jsr 	VectorPrintCharacter
.1026					_IGNLEExit:
.1026	60		rts				rts
.040a					InputBuffer:
>040a							.fill 	81
.045b					InputBufferPos:
>045b							.fill 	1
.1027					GetInteger8Bit:
.1027	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.102a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.102c	60		rts				rts
.102d					GetInteger16Bit:
.102d	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.1030	34 32		bit $32,x			bit 	NSStatus,x
.1032	30 09		bmi $103d			bmi 	Negate16Bit
.1034	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1036	85 2c		sta $2c				sta 	zTemp0
.1038	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.103a	85 2d		sta $2d				sta 	zTemp0+1
.103c	60		rts				rts
.103d					Negate16Bit:
.103d	38		sec				sec
.103e	a9 00		lda #$00			lda 	#0
.1040	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1042	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1044	85 2c		sta $2c				sta 	zTemp0
.1046	a9 00		lda #$00			lda 	#0
.1048	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.104a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.104c	85 2d		sta $2d				sta 	zTemp0+1
.104e	60		rts				rts
.104f					UnaryJoy:
.104f	fa		plx				plx
.1050	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; port #
.1053	48		pha				pha 								; zero the result.
.1054	20 34 26	jsr $2634			jsr 	FloatSetZero
.1057	68		pla				pla
.1058	5a		phy				phy
.1059	da		phx				phx
.105a	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.105d	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.105f	d0 10		bne $1071			bne 	_UJNoHardware
.1061	a8		tay				tay 								; move XA -> AY
.1062	8a		txa				txa
.1063	fa		plx				plx 								; we can update it now.
.1064	49 ff		eor #$ff			eor 	#$FF
.1066	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1068	98		tya				tya
.1069	49 ff		eor #$ff			eor 	#$FF
.106b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.106d	7a		ply				ply 								; restore Y
.106e	4c 4b 08	jmp $084b			jmp 	NextCommand
.1071					_UJNoHardware:
.1071	fa		plx				plx
.1072	7a		ply				ply
.1073	a9 01		lda #$01			lda 	#1 							; set result to -1
.1075	20 36 26	jsr $2636			jsr 	FloatSetByte
.1078	20 f6 25	jsr $25f6			jsr 	FloatNegate
.107b	4c 4b 08	jmp $084b			jmp 	NextCommand
.107e					UnaryLen:
.107e	fa		plx				plx
.107f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.1081	85 2c		sta $2c				sta 	zTemp0
.1083	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1085	85 2d		sta $2d				sta 	zTemp0+1
.1087	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.1089	20 36 26	jsr $2636			jsr 	FloatSetByte
.108c	4c 4b 08	jmp $084b			jmp 	NextCommand
.108f					LinkFloatAdd:
.108f	fa		plx				plx
.1090	5a		phy			phy
.1091	20 58 20	jsr $2058		jsr	FloatAdd
.1094	7a		ply			ply
.1095	4c 4b 08	jmp $084b			jmp 	NextCommand
.1098					LinkFloatSubtract:
.1098	fa		plx				plx
.1099	5a		phy			phy
.109a	20 52 20	jsr $2052		jsr	FloatSubtract
.109d	7a		ply			ply
.109e	4c 4b 08	jmp $084b			jmp 	NextCommand
.10a1					LinkFloatMultiply:
.10a1	fa		plx				plx
.10a2	5a		phy			phy
.10a3	20 f4 22	jsr $22f4		jsr	FloatMultiply
.10a6	7a		ply			ply
.10a7	4c 4b 08	jmp $084b			jmp 	NextCommand
.10aa					LinkFloatDivide:
.10aa	fa		plx				plx
.10ab	5a		phy			phy
.10ac	20 7d 21	jsr $217d		jsr	FloatDivide
.10af	b0 5c		bcs $110d		bcs	DivZeroError
.10b1	7a		ply			ply
.10b2	4c 4b 08	jmp $084b			jmp 	NextCommand
.10b5					LinkFloatPower:
.10b5	fa		plx				plx
.10b6	5a		phy			phy
.10b7	20 fd 28	jsr $28fd		jsr	FloatPower
.10ba	b0 4e		bcs $110a		bcs	MapRangeError
.10bc	7a		ply			ply
.10bd	4c 4b 08	jmp $084b			jmp 	NextCommand
.10c0					LinkCompareGreater:
.10c0	fa		plx				plx
.10c1	5a		phy			phy
.10c2	20 01 21	jsr $2101		jsr	CompareGreater
.10c5	7a		ply			ply
.10c6	4c 4b 08	jmp $084b			jmp 	NextCommand
.10c9					LinkCompareEqual:
.10c9	fa		plx				plx
.10ca	5a		phy			phy
.10cb	20 e3 20	jsr $20e3		jsr	CompareEqual
.10ce	7a		ply			ply
.10cf	4c 4b 08	jmp $084b			jmp 	NextCommand
.10d2					LinkCompareLess:
.10d2	fa		plx				plx
.10d3	5a		phy			phy
.10d4	20 f9 20	jsr $20f9		jsr	CompareLess
.10d7	7a		ply			ply
.10d8	4c 4b 08	jmp $084b			jmp 	NextCommand
.10db					LinkCompareGreaterEqual:
.10db	fa		plx				plx
.10dc	5a		phy			phy
.10dd	20 11 21	jsr $2111		jsr	CompareGreaterEqual
.10e0	7a		ply			ply
.10e1	4c 4b 08	jmp $084b			jmp 	NextCommand
.10e4					LinkCompareNotEqual:
.10e4	fa		plx				plx
.10e5	5a		phy			phy
.10e6	20 f3 20	jsr $20f3		jsr	CompareNotEqual
.10e9	7a		ply			ply
.10ea	4c 4b 08	jmp $084b			jmp 	NextCommand
.10ed					LinkCompareLessEqual:
.10ed	fa		plx				plx
.10ee	5a		phy			phy
.10ef	20 09 21	jsr $2109		jsr	CompareLessEqual
.10f2	7a		ply			ply
.10f3	4c 4b 08	jmp $084b			jmp 	NextCommand
.10f6					LinkFloatIntegerPartDown:
.10f6	fa		plx				plx
.10f7	5a		phy			phy
.10f8	20 93 22	jsr $2293		jsr	FloatIntegerPartDown
.10fb	7a		ply			ply
.10fc	4c 4b 08	jmp $084b			jmp 	NextCommand
.10ff					LinkFloatSquareRoot:
.10ff	fa		plx				plx
.1100	5a		phy			phy
.1101	20 7f 29	jsr $297f		jsr	FloatSquareRoot
.1104	b0 04		bcs $110a		bcs	MapRangeError
.1106	7a		ply			ply
.1107	4c 4b 08	jmp $084b			jmp 	NextCommand
.110a					MapRangeError:
.110a	4c d1 1e	jmp $1ed1		jmp	ErrorV_range
.110d					DivZeroError:
.110d	4c 5a 1f	jmp $1f5a		jmp	ErrorV_divzero
.1110					LinkFloatLogarithm:
.1110	fa		plx				plx
.1111	5a		phy			phy
.1112	20 89 28	jsr $2889		jsr	FloatLogarithm
.1115	b0 f3		bcs $110a		bcs	MapRangeError
.1117	7a		ply			ply
.1118	4c 4b 08	jmp $084b			jmp 	NextCommand
.111b					LinkFloatExponent:
.111b	fa		plx				plx
.111c	5a		phy			phy
.111d	20 86 27	jsr $2786		jsr	FloatExponent
.1120	7a		ply			ply
.1121	4c 4b 08	jmp $084b			jmp 	NextCommand
.1124					LinkFloatCosine:
.1124	fa		plx				plx
.1125	5a		phy			phy
.1126	20 7a 27	jsr $277a		jsr	FloatCosine
.1129	7a		ply			ply
.112a	4c 4b 08	jmp $084b			jmp 	NextCommand
.112d					LinkFloatSine:
.112d	fa		plx				plx
.112e	5a		phy			phy
.112f	20 1a 29	jsr $291a		jsr	FloatSine
.1132	7a		ply			ply
.1133	4c 4b 08	jmp $084b			jmp 	NextCommand
.1136					LinkFloatTangent:
.1136	fa		plx				plx
.1137	5a		phy			phy
.1138	20 8b 29	jsr $298b		jsr	FloatTangent
.113b	7a		ply			ply
.113c	4c 4b 08	jmp $084b			jmp 	NextCommand
.113f					LinkFloatArcTan:
.113f	fa		plx				plx
.1140	5a		phy			phy
.1141	20 5f 26	jsr $265f		jsr	FloatArcTan
.1144	b0 c4		bcs $110a		bcs	MapRangeError
.1146	7a		ply			ply
.1147	4c 4b 08	jmp $084b			jmp 	NextCommand
.114a					LinkFloatCompare:
.114a	fa		plx				plx
.114b	5a		phy			phy
.114c	20 19 21	jsr $2119		jsr	FloatCompare
.114f	7a		ply			ply
.1150	4c 4b 08	jmp $084b			jmp 	NextCommand
.1153					LinkDivideInt32:
.1153	fa		plx				plx
.1154	5a		phy			phy
.1155	20 a7 21	jsr $21a7		jsr	DivideInt32
.1158	b0 b0		bcs $110a		bcs	MapRangeError
.115a	7a		ply			ply
.115b	4c 4b 08	jmp $084b			jmp 	NextCommand
.115e					StackSaveCurrentPosition:
.115e	20 b6 08	jsr $08b6			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.1161	5a		phy				phy
.1162	a0 02		ldy #$02			ldy 	#2
.1164	a5 28		lda $28				lda 	codePtr
.1166	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1168	c8		iny				iny
.1169	a5 29		lda $29				lda 	codePtr+1
.116b	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.116d	7a		ply				ply
.116e	60		rts				rts
.116f					StackLoadCurrentPosition:
.116f	a0 02		ldy #$02			ldy 	#2
.1171	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1173	85 28		sta $28				sta 	codePtr
.1175	c8		iny				iny
.1176	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1178	85 29		sta $29				sta 	codePtr+1
.117a	a0 00		ldy #$00			ldy 	#0
.117c	60		rts				rts
.117d					XCommandMouse:
.117d	fa		plx				plx
.117e	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; mouse control.
.1181	ca		dex				dex
.1182	da		phx				phx
.1183	5a		phy				phy
.1184	48		pha				pha
.1185	38		sec				sec 								; get screen resolution
.1186	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1189	68		pla				pla
.118a	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.118d	7a		ply				ply
.118e	fa		plx				plx
.118f	4c 4b 08	jmp $084b			jmp 	NextCommand
.1192					XUnaryMB:
.1192	fa		plx				plx
.1193	20 c1 11	jsr $11c1			jsr 	XUnaryMouseCommon
.1196	a5 30		lda $30				lda 	zTemp2
.1198	e8		inx				inx
.1199	20 36 26	jsr $2636			jsr 	FloatSetByte
.119c	4c 4b 08	jmp $084b			jmp 	NextCommand
.119f					XUnaryMX:
.119f	fa		plx				plx
.11a0	20 c1 11	jsr $11c1			jsr 	XUnaryMouseCommon
.11a3	a5 2c		lda $2c				lda 	zTemp0
.11a5	e8		inx				inx
.11a6	20 36 26	jsr $2636			jsr 	FloatSetByte
.11a9	a5 2d		lda $2d				lda 	zTemp0+1
.11ab	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11ad	4c 4b 08	jmp $084b			jmp 	NextCommand
.11b0					XUnaryMY:
.11b0	fa		plx				plx
.11b1	20 c1 11	jsr $11c1			jsr 	XUnaryMouseCommon
.11b4	a5 2e		lda $2e				lda 	zTemp1
.11b6	e8		inx				inx
.11b7	20 36 26	jsr $2636			jsr 	FloatSetByte
.11ba	a5 2f		lda $2f				lda 	zTemp1+1
.11bc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11be	4c 4b 08	jmp $084b			jmp 	NextCommand
.11c1					XUnaryMouseCommon:
.11c1	da		phx				phx
.11c2	5a		phy				phy
.11c3	a2 2c		ldx #$2c			ldx 	#zTemp0
.11c5	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.11c8	85 30		sta $30				sta 	zTemp2
.11ca	7a		ply				ply
.11cb	fa		plx				plx
.11cc	60		rts				rts
.11cd					NegateTOS:
.11cd	fa		plx				plx
.11ce	20 f6 25	jsr $25f6			jsr 	FloatNegate
.11d1	4c 4b 08	jmp $084b			jmp 	NextCommand
.11d4					CommandNewLine:
.11d4	fa		plx				plx
.11d5	9c 68 05	stz $0568			stz 	stringInitialised
.11d8	a2 ff		ldx #$ff			ldx 	#$FF
.11da	4c 4b 08	jmp $084b			jmp 	NextCommand
.11dd					CommandXNext:
.11dd	fa		plx				plx
.11de					_CNRetry:
.11de	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.11e0	20 43 0d	jsr $0d43			jsr 	StackFindFrame
.11e3	20 b6 08	jsr $08b6			jsr 	FixUpY 						; so we can use Y
.11e6	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.11e8	35 4a		and $4a,x			and 	NSMantissa1,x
.11ea	c9 ff		cmp #$ff			cmp 	#$FF
.11ec	f0 16		beq $1204			beq 	_CNNoIndexVariable
.11ee	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.11f0	a0 05		ldy #$05			ldy 	#5
.11f2	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.11f4	d0 07		bne $11fd			bne 	_CNNIndexFail
.11f6	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.11f8	c8		iny				iny
.11f9	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.11fb	f0 07		beq $1204			beq 	_CNNoIndexVariable
.11fd					_CNNIndexFail:
.11fd	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.11ff	20 35 0d	jsr $0d35			jsr 	StackCloseFrame 			; close this frame
.1202	80 da		bra $11de			bra 	_CNRetry
.1204					_CNNoIndexVariable:
.1204	ca		dex				dex
.1205	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.1207	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1209	29 40		and #$40			and 	#$40	 					; bit 6
.120b	d0 55		bne $1262			bne 	_CNOptimisedNext
.120d	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.120f	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1211	48		pha				pha
.1212	85 2c		sta $2c				sta 	zTemp0
.1214	c8		iny				iny
.1215	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1217	18		clc				clc
.1218	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.121b	48		pha				pha
.121c	85 2d		sta $2d				sta 	zTemp0+1
.121e	20 d6 14	jsr $14d6			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.1221	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.1223	e8		inx				inx
.1224	20 a5 12	jsr $12a5			jsr 	CopyOffsetYToTOS
.1227	20 58 20	jsr $2058			jsr 	FloatAdd
.122a	68		pla				pla 								; restore address
.122b	85 2d		sta $2d				sta 	zTemp0+1
.122d	68		pla				pla
.122e	85 2c		sta $2c				sta 	zTemp0
.1230	20 b1 1a	jsr $1ab1			jsr 	WriteFloatZTemp0Sub			; write float.
.1233	e8		inx				inx  								; recover written
.1234	e8		inx				inx 								; load offset
.1235	a0 0d		ldy #$0d			ldy 	#13
.1237	20 a5 12	jsr $12a5			jsr 	CopyOffsetYToTOS
.123a	20 19 21	jsr $2119			jsr 	FloatCompare 				; and compare the floats.
.123d	ca		dex				dex 								; throw result (in NSMantissa0+1)
.123e	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.1240	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1242	30 08		bmi $124c			bmi 	_CNDownStep
.1244	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1246	c9 01		cmp #$01			cmp 	#1 							; gone higher
.1248	f0 10		beq $125a			beq 	_CNExitFor 					; if so exit the loop
.124a	80 06		bra $1252			bra 	_CNLoopBack
.124c					_CNDownStep:
.124c	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.124e	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.1250	f0 08		beq $125a			beq 	_CNExitFor
.1252					_CNLoopBack:
.1252	20 6f 11	jsr $116f			jsr 	StackLoadCurrentPosition 	; loop back
.1255	a0 00		ldy #$00			ldy 	#0
.1257	4c 4b 08	jmp $084b			jmp 	NextCommand
.125a					_CNExitFor:
.125a	20 35 0d	jsr $0d35			jsr 	StackCloseFrame 			; remove the frame and exit
.125d	a0 00		ldy #$00			ldy 	#0
.125f	4c 4b 08	jmp $084b			jmp 	NextCommand
.1262					_CNOptimisedNext:
.1262	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1264	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1266	85 2c		sta $2c				sta 	zTemp0
.1268	c8		iny				iny
.1269	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.126b	18		clc				clc
.126c	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.126f	85 2d		sta $2d				sta 	zTemp0+1
.1271	a0 07		ldy #$07			ldy 	#7 							; STEP value
.1273	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1275	a0 ff		ldy #$ff			ldy 	#$FF
.1277	18		clc				clc
.1278					_CNOIncrement:
.1278	c8		iny				iny
.1279	71 2c		adc ($2c),y			adc 	(zTemp0),y
.127b	91 2c		sta ($2c),y			sta 	(zTemp0),y
.127d	f0 f9		beq $1278			beq 	_CNOIncrement
.127f	18		clc				clc
.1280	a5 24		lda $24				lda 	runtimeStackPtr
.1282	69 0d		adc #$0d			adc 	#13
.1284	85 2e		sta $2e				sta 	zTemp1
.1286	a5 25		lda $25				lda 	runtimeStackPtr+1
.1288	69 00		adc #$00			adc 	#0
.128a	85 2f		sta $2f				sta 	zTemp1+1
.128c	a0 00		ldy #$00			ldy 	#0
.128e	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.1290	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.1292	c8		iny				iny
.1293	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.1295	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1297	c8		iny				iny
.1298	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.129a	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.129c	c8		iny				iny
.129d	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.129f	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12a1	90 b7		bcc $125a			bcc	 	_CNExitFor
.12a3	80 ad		bra $1252			bra 	_CNLoopBack
.12a5					CopyOffsetYToTOS:
.12a5	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12a7	95 3e		sta $3e,x			sta 	NSMantissa0,x
.12a9	c8		iny				iny
.12aa	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12ac	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12ae	c8		iny				iny
.12af	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12b1	95 56		sta $56,x			sta 	NSMantissa2,x
.12b3	c8		iny				iny
.12b4	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12b6	95 62		sta $62,x			sta 	NSMantissa3,x
.12b8	c8		iny				iny
.12b9	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12bb	95 6e		sta $6e,x			sta 	NSExponent,x
.12bd	c8		iny				iny
.12be	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c0	95 32		sta $32,x			sta 	NSStatus,x
.12c2	60		rts				rts
.12c3	4c 4b 08	jmp $084b			jmp 	NextCommand
.12c6					NotTOS:
.12c6	fa		plx				plx
.12c7	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.12ca	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.12cc	74 62		stz $62,x			stz 	NSMantissa3,x
.12ce	20 f6 25	jsr $25f6			jsr 	FloatNegate		 			; negate
.12d1	e8		inx				inx 								; and subtract 1.
.12d2	a9 01		lda #$01			lda 	#1
.12d4	20 36 26	jsr $2636			jsr 	FloatSetByte
.12d7	20 52 20	jsr $2052			jsr 	FloatSubtract
.12da					_NotTOSSkip:
.12da	4c 4b 08	jmp $084b			jmp 	NextCommand
.12dd					CommandXOn:
.12dd	fa		plx				plx
.12de	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.12e1	8d 5c 04	sta $045c			sta 	onCount 					; save it.
.12e4	20 b6 08	jsr $08b6			jsr 	FixUpY 						; Y = 0
.12e7					_CONFind:
.12e7	ce 5c 04	dec $045c			dec 	onCount 					; reached zero, do this one
.12ea	f0 0b		beq $12f7			beq 	_CONFound
.12ec	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.12ed	c8		iny				iny
.12ee	c8		iny				iny
.12ef	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.12f1	c8		iny				iny
.12f2	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.12f4	f0 f1		beq $12e7			beq 	_CONFind
.12f6	88		dey				dey 								; point to character after last GOTO/GOSUB
.12f7					_CONFound:
.12f7	4c 4b 08	jmp $084b			jmp 	NextCommand
.12fa					CommandMoreOn:
.12fa	fa		plx				plx
.12fb	c8		iny				iny 								; so it goes to the first non-goto/gosub
.12fc	c8		iny				iny
.12fd	c8		iny				iny
.12fe	4c 4b 08	jmp $084b			jmp 	NextCommand
.045c					onCount:
>045c							.fill 	1
.1301					UnaryPeek:
.1301	fa		plx				plx
.1302	20 2d 10	jsr $102d			jsr 	GetInteger16Bit
.1305	da		phx				phx
.1306	5a		phy				phy
.1307	a6 2c		ldx $2c				ldx 	zTemp0
.1309	a4 2d		ldy $2d				ldy 	zTemp0+1
.130b	20 42 1c	jsr $1c42			jsr 	XPeekMemory
.130e	7a		ply				ply
.130f	fa		plx				plx
.1310	20 36 26	jsr $2636			jsr 	FloatSetByte
.1313	4c 4b 08	jmp $084b			jmp 	NextCommand
.1316					CommandPOKE:
.1316	fa		plx				plx
.1317	da		phx				phx 								; save XY
.1318	5a		phy				phy
.1319	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.131c	48		pha				pha
.131d	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.131f	a8		tay				tay
.1320	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1322	aa		tax				tax
.1323	68		pla				pla
.1324	20 2e 1c	jsr $1c2e			jsr 	XPokeMemory
.1327	7a		ply				ply 								; restore YX and drop 2
.1328	fa		plx				plx
.1329	ca		dex				dex
.132a	ca		dex				dex
.132b	4c 4b 08	jmp $084b			jmp 	NextCommand
.132e					UnaryPos:
.132e	fa		plx				plx
.132f	20 c1 1b	jsr $1bc1			jsr 	XGetHPos
.1332	20 36 26	jsr $2636			jsr 	FloatSetByte
.1335	4c 4b 08	jmp $084b			jmp 	NextCommand
.1338					GetChannel:
.1338	fa		plx				plx
.1339	ad 5d 04	lda $045d			lda 	currentChannel
.133c	e8		inx				inx
.133d	20 36 26	jsr $2636			jsr 	FloatSetByte
.1340	4c 4b 08	jmp $084b			jmp 	NextCommand
.1343					SetChannel:
.1343	fa		plx				plx
.1344	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.1347	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1349	8d 5d 04	sta $045d			sta 	currentChannel
.134c	ca		dex				dex
.134d	4c 4b 08	jmp $084b			jmp 	NextCommand
.1350					SetDefaultChannel:
.1350	9c 5d 04	stz $045d			stz 	currentChannel
.1353	60		rts				rts
.1354					VectorPrintCharacter:
.1354	da		phx				phx
.1355	ae 5d 04	ldx $045d			ldx 	currentChannel
.1358	20 6c 1c	jsr $1c6c			jsr 	XPrintCharacterToChannel
.135b	fa		plx				plx
.135c	60		rts				rts
.135d					VectorGetCharacter:
.135d	da		phx				phx
.135e	ae 5d 04	ldx $045d			ldx 	currentChannel
.1361	20 a5 1b	jsr $1ba5			jsr 	XGetCharacterFromChannel
.1364	fa		plx				plx
.1365	60		rts				rts
.045d					currentChannel:
>045d							.fill 	1
.1366					PrintNumber:
.1366	fa		plx				plx
.1367	a9 07		lda #$07			lda 	#7
.1369	20 1c 25	jsr $251c			jsr 	FloatToString 				; to number in decimal buffer
.136c	ca		dex				dex 								; drop
.136d	da		phx				phx
.136e	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1370					_PNLoop:
.1370	bd 96 05	lda $0596,x			lda 	decimalBuffer,x
.1373	20 54 13	jsr $1354			jsr 	VectorPrintCharacter
.1376	e8		inx				inx
.1377	bd 96 05	lda $0596,x			lda	 	decimalBuffer,x
.137a	d0 f4		bne $1370			bne 	_PNLoop
.137c	a9 20		lda #$20			lda 	#32 						; trailing space
.137e	20 54 13	jsr $1354			jsr 	VectorPrintCharacter
.1381	fa		plx				plx
.1382	4c 4b 08	jmp $084b			jmp 	NextCommand
.1385					PrintString:
.1385	fa		plx				plx
.1386	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.1388	85 2c		sta $2c				sta 	zTemp0
.138a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.138c	85 2d		sta $2d				sta 	zTemp0+1
.138e	ca		dex				dex 								; drop
.138f	da		phx				phx
.1390	5a		phy				phy
.1391	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.1393	aa		tax				tax
.1394	a0 01		ldy #$01			ldy 	#1 							; Y = position
.1396					_PSLoop:
.1396	e0 00		cpx #$00			cpx 	#0 							; complete ?
.1398	f0 09		beq $13a3			beq 	_PSExit
.139a	ca		dex				dex 								; dec count
.139b	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.139d	20 54 13	jsr $1354			jsr 	VectorPrintCharacter
.13a0	c8		iny				iny
.13a1	80 f3		bra $1396			bra 	_PSLoop
.13a3					_PSExit:
.13a3	7a		ply				ply
.13a4	fa		plx				plx
.13a5	4c 4b 08	jmp $084b			jmp 	NextCommand
.13a8					CommandPushN:
.13a8	fa		plx				plx
.13a9	e8		inx				inx 								; next slot on stack
.13aa	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.13ac	95 6e		sta $6e,x			sta 	NSExponent,x
.13ae	c8		iny				iny
.13af	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.13b1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13b3	c8		iny				iny
.13b4	b1 28		lda ($28),y			lda 	(codePtr),y
.13b6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13b8	c8		iny				iny
.13b9	b1 28		lda ($28),y			lda 	(codePtr),y
.13bb	95 56		sta $56,x			sta 	NSMantissa2,x
.13bd	c8		iny				iny
.13be	b1 28		lda ($28),y			lda 	(codePtr),y
.13c0	48		pha				pha
.13c1	29 7f		and #$7f			and 	#$7F
.13c3	95 62		sta $62,x			sta 	NSMantissa3,x
.13c5	68		pla				pla 								; sign in mantissa3:7
.13c6	29 80		and #$80			and 	#$80
.13c8	95 32		sta $32,x			sta 	NSStatus,x
.13ca	c8		iny				iny
.13cb	4c 4b 08	jmp $084b			jmp 	NextCommand
.13ce					CommandPushS:
.13ce	fa		plx				plx
.13cf	e8		inx				inx 								; next slot on stack
.13d0	18		clc				clc
.13d1	98		tya				tya
.13d2	65 28		adc $28				adc 	codePtr 					; the string is inline
.13d4	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13d6	a5 29		lda $29				lda 	codePtr+1
.13d8	69 00		adc #$00			adc 	#0
.13da	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13dc	74 56		stz $56,x			stz 	NSMantissa2,x
.13de	74 62		stz $62,x			stz 	NSMantissa3,x
.13e0	a9 40		lda #$40			lda 	#NSSString
.13e2	95 32		sta $32,x			sta 	NSStatus,x
.13e4	98		tya				tya 								; string length +1 added to Y
.13e5	38		sec				sec
.13e6	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.13e8	a8		tay				tay
.13e9	4c 4b 08	jmp $084b			jmp 	NextCommand
.13ec					CommandXRead:
.13ec	fa		plx				plx
.13ed	5a		phy				phy 								; save Y
.13ee	20 1f 14	jsr $141f			jsr 	ReadStringToBuffer 			; read element into buffer
.13f1	e8		inx				inx									; space on stack
.13f2	a9 5f		lda #$5f			lda 	#((ReadBufferSize) & $FF)
.13f4	85 2c		sta $2c				sta 	0+zTemp0
.13f6	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.13f8	85 2d		sta $2d				sta 	1+zTemp0
.13fa	20 3e 19	jsr $193e			jsr 	ValEvaluateZTemp0
.13fd	b0 04		bcs $1403			bcs 	_CRError 					; failed
.13ff	7a		ply				ply 								; restore Y
.1400	4c 4b 08	jmp $084b			jmp 	NextCommand
.1403					_CRError:
.1403	4c e1 1e	jmp $1ee1		jmp	ErrorV_value
.1406					CommandReadString:
.1406	fa		plx				plx
.1407	5a		phy				phy 								; save Y
.1408	20 1f 14	jsr $141f			jsr 	ReadStringToBuffer 			; read text
.140b	e8		inx				inx 								; make space on stack
.140c	20 34 26	jsr $2634			jsr 	FloatSetZero 				; store as string on stack
.140f	a9 5f		lda #$5f			lda 	#ReadBufferSize & $FF
.1411	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1413	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.1415	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1417	a9 40		lda #$40			lda 	#NSSString
.1419	95 32		sta $32,x			sta 	NSStatus,x
.141b	7a		ply				ply 								; restore Y
.141c	4c 4b 08	jmp $084b			jmp 	NextCommand
.141f					ReadStringToBuffer:
.141f	a9 b2		lda #$b2			lda 	#((ReadBumpNext) & $FF)
.1421	8d 5f 05	sta $055f			sta 	0+ReadBumpNextVec
.1424	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.1426	8d 60 05	sta $0560			sta 	1+ReadBumpNextVec
.1429	a9 85		lda #$85			lda 	#((ReadLookNext) & $FF)
.142b	8d 61 05	sta $0561			sta 	0+ReadLookNextVec
.142e	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.1430	8d 62 05	sta $0562			sta 	1+ReadLookNextVec
.1433					GetStringToBuffer:
.1433	20 82 14	jsr $1482			jsr		GetLookNext 				; skip all leading spaces.
.1436	f0 44		beq $147c			beq 	_RBError 					; end of data
.1438	b0 f9		bcs $1433			bcs 	GetStringToBuffer 			; switched to new data line.
.143a	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.143c	b0 05		bcs $1443			bcs 	_RBNoSpace
.143e	20 7f 14	jsr $147f			jsr 	GetBumpNext 				; consume space and loop round.
.1441	80 f0		bra $1433			bra 	GetStringToBuffer
.1443					_RBNoSpace:
.1443	9c 5f 04	stz $045f			stz 	ReadBufferSize 				; empty the buffer.
.1446	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.1448	d0 08		bne $1452			bne 	_RBCommaSep
.144a	8d 5e 04	sta $045e			sta 	ReadSep 					; use as a seperator
.144d	20 7f 14	jsr $147f			jsr 	GetBumpNext 				; consume the '"'
.1450	80 05		bra $1457			bra 	_RBGetText
.1452					_RBCommaSep:
.1452	a9 2c		lda #$2c			lda 	#","						; get till comma
.1454	8d 5e 04	sta $045e			sta 	ReadSep
.1457					_RBGetText:
.1457	20 82 14	jsr $1482			jsr 	GetLookNext 				; what follows
.145a	b0 18		bcs $1474			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.145c	20 7f 14	jsr $147f			jsr 	GetBumpNext 				; consume it whatever
.145f	cd 5e 04	cmp $045e			cmp 	ReadSep 					; if found the seperator.
.1462	f0 10		beq $1474			beq 	_RBEndGet 					; exit after consumption
.1464	da		phx				phx
.1465	ae 5f 04	ldx $045f			ldx 	ReadBufferSize 				; copy into buffer.
.1468	ee 5f 04	inc $045f			inc 	ReadBufferSize
.146b	9d 60 04	sta $0460,x			sta 	ReadBuffer,x
.146e	9e 61 04	stz $0461,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.1471	fa		plx				plx
.1472	80 e3		bra $1457			bra 	_RBGetText
.1474					_RBEndGet:
.1474	c9 22		cmp #$22			cmp 	#'"'
.1476	d0 03		bne $147b			bne 	_RBNotQuote
.1478	20 7f 14	jsr $147f			jsr 	GetBumpNext
.147b					_RBNotQuote:
.147b	60		rts				rts
.147c					_RBError:
.147c	4c 96 1f	jmp $1f96		jmp	ErrorV_data
.147f					GetBumpNext:
.147f	6c 5f 05	jmp ($055f)			jmp 	(ReadBumpNextVec)
.1482					GetLookNext:
.1482	6c 61 05	jmp ($0561)			jmp 	(ReadLookNextVec)
.1485					ReadLookNext:
.1485	ad 63 05	lda $0563			lda 	dataRemaining 				; any data remaining
.1488	f0 04		beq $148e			beq 	_RLNFindData
.148a	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.148c	18		clc				clc
.148d	60		rts				rts
.148e					_RLNFindData:
.148e	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.1490	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.1492	f0 1a		beq $14ae			beq 	_RLNNoData
.1494	c9 cf		cmp #$cf			cmp 	#PCD_CMD_DATA 				; Found DATA
.1496	f0 05		beq $149d			beq 	_RLNHaveData
.1498					_RLNNext:
.1498	20 03 20	jsr $2003			jsr 	MoveObjectForward			; else scan forward.
.149b	80 f1		bra $148e			bra 	_RLNFindData
.149d					_RLNHaveData:
.149d	a0 01		ldy #$01			ldy 	#1 							; get length
.149f	b1 2a		lda ($2a),y			lda 	(objPtr),y
.14a1	f0 f5		beq $1498			beq 	_RLNNext 					; skip if DATA alone
.14a3	20 b2 14	jsr $14b2			jsr 	ReadBumpNext 				; advance by two
.14a6	20 b2 14	jsr $14b2			jsr 	ReadBumpNext
.14a9	8d 63 05	sta $0563			sta 	dataRemaining 				; set data left count.
.14ac	38		sec				sec
.14ad	60		rts				rts
.14ae					_RLNNoData:
.14ae	a9 00		lda #$00			lda 	#0
.14b0	38		sec				sec
.14b1	60		rts				rts
.14b2					ReadBumpNext:
.14b2	e6 2a		inc $2a				inc 	objPtr
.14b4	d0 02		bne $14b8			bne 	_RBNSkip
.14b6	e6 2b		inc $2b				inc 	objPtr+1
.14b8					_RBNSkip:
.14b8	ce 63 05	dec $0563			dec 	dataRemaining
.14bb	60		rts				rts
.045e					ReadSep:
>045e							.fill 	1
.045f					ReadBufferSize:
>045f							.fill 	1
.0460					ReadBuffer:
>0460							.fill 	255
.055f					ReadBumpNextVec:
>055f							.fill 	2
.0561					ReadLookNextVec:
>0561							.fill 	2
.14bc					ReadFloatCommand:
.14bc	fa		plx				plx
.14bd	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14bf	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14c1	88		dey				dey 								; get the upper 3 bits
.14c2	b1 28		lda ($28),y			lda 	(codePtr),y
.14c4	29 07		and #$07			and 	#7
.14c6	c8		iny				iny
.14c7	c8		iny				iny
.14c8	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14ca	2a		rol a				rol 	a 							; carry will be clear.
.14cb	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14ce	85 2d		sta $2d				sta 	zTemp0+1
.14d0	20 d6 14	jsr $14d6			jsr 	ReadFloatZTemp0Sub
.14d3	4c 4b 08	jmp $084b			jmp 	NextCommand
.14d6					ReadFloatZTemp0Sub:
.14d6	5a		phy				phy 								; start write
.14d7	a0 01		ldy #$01			ldy 	#1
.14d9	e8		inx				inx
.14da	b2 2c		lda ($2c)			lda 	(zTemp0)
.14dc	95 3e		sta $3e,x			sta 	NSMantissa0,x
.14de	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14e0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.14e2	c8		iny				iny
.14e3	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14e5	95 56		sta $56,x			sta 	NSMantissa2,x
.14e7	c8		iny				iny
.14e8	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14ea	95 62		sta $62,x			sta 	NSMantissa3,x
.14ec	c8		iny				iny
.14ed	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14ef	95 6e		sta $6e,x			sta 	NSExponent,x
.14f1	c8		iny				iny
.14f2	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14f4	95 32		sta $32,x			sta 	NSStatus,x
.14f6	7a		ply				ply
.14f7	60		rts				rts
.14f8					ReadIntegerCommand:
.14f8	fa		plx				plx
.14f9	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14fb	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14fd	88		dey				dey 								; get the upper 3 bits
.14fe	b1 28		lda ($28),y			lda 	(codePtr),y
.1500	29 07		and #$07			and 	#7
.1502	c8		iny				iny
.1503	c8		iny				iny
.1504	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1506	2a		rol a				rol 	a 							; carry will be clear.
.1507	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.150a	85 2d		sta $2d				sta 	zTemp0+1
.150c	20 12 15	jsr $1512			jsr 	ReadIntegerZTemp0Sub
.150f	4c 4b 08	jmp $084b			jmp 	NextCommand
.1512					ReadIntegerZTemp0Sub:
.1512	5a		phy				phy 								; start write
.1513	a0 01		ldy #$01			ldy 	#1
.1515	e8		inx				inx 								; prepare
.1516	74 56		stz $56,x			stz 	NSMantissa2,x
.1518	74 62		stz $62,x			stz 	NSMantissa3,x
.151a	74 6e		stz $6e,x			stz 	NSExponent,x
.151c	74 32		stz $32,x			stz 	NSStatus,x
.151e	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1520	30 08		bmi $152a			bmi 	_RIZNegative
.1522	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1524	b2 2c		lda ($2c)			lda 	(zTemp0)
.1526	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1528	7a		ply				ply
.1529	60		rts				rts
.152a					_RIZNegative:
.152a	38		sec				sec 								; -ve read
.152b	a9 00		lda #$00			lda 	#0
.152d	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.152f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1531	a9 00		lda #$00			lda 	#0
.1533	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1535	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1537	a9 80		lda #$80			lda 	#$80
.1539	95 32		sta $32,x			sta 	NSStatus,x
.153b	7a		ply				ply
.153c	60		rts				rts
.153d					ReadStringCommand:
.153d	fa		plx				plx
.153e	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1540	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1542	88		dey				dey 								; get the upper 3 bits
.1543	b1 28		lda ($28),y			lda 	(codePtr),y
.1545	29 07		and #$07			and 	#7
.1547	c8		iny				iny
.1548	c8		iny				iny
.1549	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.154b	2a		rol a				rol 	a 							; carry will be clear.
.154c	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.154f	85 2d		sta $2d				sta 	zTemp0+1
.1551	20 57 15	jsr $1557			jsr 	ReadStringZTemp0Sub
.1554	4c 4b 08	jmp $084b			jmp 	NextCommand
.1557					ReadStringZTemp0Sub:
.1557	5a		phy				phy 								; start write
.1558	e8		inx				inx 								; prepare
.1559	74 56		stz $56,x			stz 	NSMantissa2,x
.155b	74 62		stz $62,x			stz 	NSMantissa3,x
.155d	74 6e		stz $6e,x			stz 	NSExponent,x
.155f	a9 40		lda #$40			lda 	#NSSString
.1561	74 32		stz $32,x			stz 	NSStatus,x
.1563	18		clc				clc
.1564	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.1566	69 02		adc #$02			adc 	#2 							; this points to actual data
.1568	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.156a	a0 01		ldy #$01			ldy 	#1
.156c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.156e	69 00		adc #$00			adc 	#0
.1570	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1572	d0 08		bne $157c			bne 	_RSZNoDefault 				; if read $00 use a default value.
.1574	a9 7e		lda #$7e			lda 	#_RSZNull & $FF
.1576	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1578	a9 15		lda #$15			lda 	#_RSZNull >> 8
.157a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.157c					_RSZNoDefault:
.157c	7a		ply				ply
.157d	60		rts				rts
.157e					_RSZNull:
>157e	00						.byte 	0
.157f					CommandRestore:
.157f	fa		plx				plx
.1580	20 86 15	jsr $1586			jsr 	RestoreCode
.1583	4c 4b 08	jmp $084b			jmp 	NextCommand
.1586					RestoreCode:
.1586	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.1589	85 2b		sta $2b				sta 	objPtr+1
.158b	64 2a		stz $2a				stz 	objPtr
.158d	9c 63 05	stz $0563			stz 	dataRemaining 				; no data remaining.
.1590	60		rts				rts
.0563					dataRemaining:
>0563							.fill 	1		 					; 0 if not in data statement
.1591					UnaryRND:
.1591	fa		plx				plx
.1592	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.1594	10 17		bpl $15ad			bpl 	_URNoSeed
.1596	20 89 23	jsr $2389			jsr 	FloatNormalise 				; some float value
.1599	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.159b	8d 64 05	sta $0564			sta 	randomSeed+0
.159e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15a0	8d 65 05	sta $0565			sta 	randomSeed+1
.15a3	b5 56		lda $56,x			lda 	NSMantissa2,x
.15a5	8d 66 05	sta $0566			sta 	randomSeed+2
.15a8	b5 62		lda $62,x			lda 	NSMantissa3,x
.15aa	8d 67 05	sta $0567			sta 	randomSeed+3
.15ad					_URNoSeed:
.15ad	20 cf 15	jsr $15cf			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.15b0	ad 64 05	lda $0564			lda 	randomSeed+0
.15b3	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15b5	ad 65 05	lda $0565			lda 	randomSeed+1
.15b8	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15ba	ad 66 05	lda $0566			lda 	randomSeed+2
.15bd	95 56		sta $56,x			sta 	NSMantissa2,x
.15bf	ad 67 05	lda $0567			lda 	randomSeed+3
.15c2	29 7f		and #$7f			and 	#$7F
.15c4	95 62		sta $62,x			sta 	NSMantissa3,x
.15c6	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.15c8	95 6e		sta $6e,x			sta 	NSExponent,x
.15ca	74 32		stz $32,x			stz 	NSStatus,x
.15cc	4c 4b 08	jmp $084b			jmp 	NextCommand
.15cf					RandomNumberGenerator:
.15cf	5a		phy				phy
.15d0	ad 64 05	lda $0564			lda 	randomSeed+0 				; check if zero
.15d3	0d 65 05	ora $0565			ora 	randomSeed+1
.15d6	0d 66 05	ora $0566			ora 	randomSeed+2
.15d9	0d 67 05	ora $0567			ora 	randomSeed+3
.15dc	d0 07		bne $15e5			bne 	_RNGNoSeed
.15de	ce 67 05	dec $0567			dec 	randomSeed+3 				; if so tweak and flog
.15e1	a0 64		ldy #$64			ldy 	#100
.15e3	80 05		bra $15ea			bra 	_RNGLoop
.15e5					_RNGNoSeed:
.15e5	a0 08		ldy #$08			ldy 	#8
.15e7	ad 64 05	lda $0564			lda 	randomSeed+0
.15ea					_RNGLoop:
.15ea	0a		asl a				asl		a
.15eb	2e 65 05	rol $0565			rol 	randomSeed+1
.15ee	2e 66 05	rol $0566			rol 	randomSeed+2
.15f1	2e 67 05	rol $0567			rol 	randomSeed+3
.15f4	90 02		bcc $15f8			bcc		_RNGSkip
.15f6	49 c5		eor #$c5			eor 	#$C5
.15f8					_RNGSkip:
.15f8	88		dey				dey
.15f9	d0 ef		bne $15ea			bne		_RNGLoop
.15fb	8d 64 05	sta $0564			sta 	randomSeed+0
.15fe	7a		ply				ply
.15ff	60		rts				rts
.0564					randomSeed:
>0564							.fill 	4
.1600					StringConcatenate:
.1600	fa		plx				plx
.1601	ca		dex				dex
.1602	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.1604	85 2e		sta $2e				sta 	zTemp1
.1606	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1608	85 2f		sta $2f				sta 	zTemp1+1
.160a	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.160c	85 30		sta $30				sta 	zTemp2
.160e	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.1610	85 31		sta $31				sta 	zTemp2+1
.1612	18		clc				clc 								; work out total length
.1613	b2 2e		lda ($2e)			lda 	(zTemp1)
.1615	72 30		adc ($30)			adc 	(zTemp2)
.1617	b0 18		bcs $1631			bcs 	_BCLength 					; more than 255 characters.
.1619	48		pha				pha 								; save total
.161a	20 f7 16	jsr $16f7			jsr 	StringAllocTemp 			; space for result.
.161d	68		pla				pla 								; write total as first.
.161e	92 22		sta ($22)			sta 	(zsTemp)
.1620	20 34 16	jsr $1634			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.1623	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.1625	85 2e		sta $2e				sta 	zTemp1
.1627	a5 31		lda $31				lda 	zTemp2+1
.1629	85 2f		sta $2f				sta 	zTemp1+1
.162b	20 34 16	jsr $1634			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.162e	4c 4b 08	jmp $084b			jmp 	NextCommand
.1631					_BCLength:
.1631	4c d1 1e	jmp $1ed1		jmp	ErrorV_range
.1634					_BCCopyZTemp1:
.1634	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.1636	f0 15		beq $164d			beq 	_BCCExit 					; none.
.1638	da		phx				phx 								; save XY
.1639	5a		phy				phy
.163a	aa		tax				tax 								; count in X.
.163b	a0 01		ldy #$01			ldy 	#1
.163d					_BCCLoop:
.163d	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.163f	d0 02		bne $1643			bne 	_BCCNoCarry
.1641	e6 23		inc $23				inc 	zsTemp+1
.1643					_BCCNoCarry:
.1643	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.1645	92 22		sta ($22)			sta 	(zsTemp)
.1647	c8		iny				iny
.1648	ca		dex				dex 								; X times
.1649	d0 f2		bne $163d			bne 	_BCCLoop
.164b	7a		ply				ply 								; restore YX
.164c	fa		plx				plx
.164d					_BCCExit:
.164d	60		rts				rts
.164e					XRuntimeSetup:
.164e	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1650	8d 6b 05	sta $056b	 		sta 	ramBank
.1653	8d 6c 05	sta $056c	 		sta 	romBank
.1656	60		rts				rts
.1657					SignTOS:
.1657	fa		plx				plx
.1658	20 56 26	jsr $2656			jsr 	FloatIsZero 				; if zero
.165b	f0 0f		beq $166c			beq 	_SGZero  					; return Int Zero
.165d	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.165f	48		pha				pha
.1660	a9 01		lda #$01			lda 	#1 							; set result to 1
.1662	20 36 26	jsr $2636			jsr 	FloatSetByte
.1665	68		pla				pla
.1666	29 80		and #$80			and		#$80 						; copy the sign byte out
.1668	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.166a	80 03		bra $166f			bra 	_SGExit
.166c					_SGZero:
.166c	20 34 26	jsr $2634			jsr 	FloatSetZero
.166f					_SGExit:
.166f	4c 4b 08	jmp $084b			jmp 	NextCommand
.1672					CommandShift:
.1672	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.1674	c8		iny				iny
.1675	0a		asl a				asl 	a 							; double into X
.1676	aa		tax				tax
.1677	7c 22 1a	jmp ($1a22,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.167a					PrintTab:
.167a	fa		plx				plx
.167b	20 c1 1b	jsr $1bc1			jsr 	XGetHPos
.167e					_PTMod10:
.167e	38		sec				sec
.167f	e9 0a		sbc #$0a			sbc 	#10
.1681	b0 fb		bcs $167e			bcs 	_PTMod10
.1683	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.1685	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.1686	80 15		bra $169d			bra 	PrintSpaceLoop
.1688					PrintPos:
.1688	fa		plx				plx
.1689	20 c1 1b	jsr $1bc1			jsr		XGetHPos 					; get current position
.168c	85 2c		sta $2c				sta 	zTemp0
.168e	38		sec				sec 								; calculate spaces required
.168f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1691	ca		dex				dex
.1692	e5 2c		sbc $2c				sbc 	zTemp0
.1694	b0 07		bcs $169d			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.1696	4c 4b 08	jmp $084b			jmp 	NextCommand
.1699					PrintSpace:
.1699	fa		plx				plx
.169a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.169c	ca		dex				dex
.169d					PrintSpaceLoop:
.169d	c9 00		cmp #$00			cmp 	#0
.169f	f0 0a		beq $16ab			beq 	_PSExit
.16a1	48		pha				pha
.16a2	a9 20		lda #$20			lda 	#" "
.16a4	20 54 13	jsr $1354			jsr 	VectorPrintCharacter
.16a7	68		pla				pla
.16a8	3a		dec a				dec 	a
.16a9	80 f2		bra $169d			bra 	PrintSpaceLoop
.16ab					_PSExit:
.16ab	4c 4b 08	jmp $084b			jmp 	NextCommand
.16ae					CommandStop:
.16ae	fa		plx				plx
.16af	4c 83 1f	jmp $1f83		jmp	ErrorV_stop
.16b2					Unary_Str:
.16b2	fa		plx				plx
.16b3	5a		phy				phy
.16b4	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.16b6	20 1c 25	jsr $251c			jsr 	FloatToString 				; do the conversion.
.16b9	a9 21		lda #$21			lda		#33 						; create buffer
.16bb	20 f7 16	jsr $16f7			jsr 	StringAllocTemp 			; allocate memory
.16be	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.16c0					_USCopy:
.16c0	b9 95 05	lda $0595,y			lda 	decimalBuffer-1,y
.16c3	f0 05		beq $16ca			beq 	_USExit
.16c5	91 22		sta ($22),y			sta 	(zsTemp),y
.16c7	c8		iny				iny
.16c8	80 f6		bra $16c0			bra 	_USCopy
.16ca					_USExit:
.16ca	98		tya				tya
.16cb	3a		dec a				dec 	a
.16cc	92 22		sta ($22)			sta 	(zsTemp)
.16ce	7a		ply				ply
.16cf	4c 4b 08	jmp $084b			jmp 	NextCommand
.16d2					StringInitialise:
.16d2	48		pha				pha
.16d3	ad 68 05	lda $0568			lda 	stringInitialised 			; already done
.16d6	d0 11		bne $16e9			bne 	_SIExit
.16d8	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.16db	8d 69 05	sta $0569			sta 	stringTempPointer
.16de	ad 03 04	lda $0403			lda 	stringHighMemory+1
.16e1	3a		dec a				dec 	a
.16e2	3a		dec a				dec 	a
.16e3	8d 6a 05	sta $056a			sta 	stringTempPointer+1
.16e6	ce 68 05	dec $0568			dec 	stringInitialised 			; set the initialised flag.
.16e9					_SIExit:
.16e9	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.16eb	1a		inc a				inc 	a
.16ec	1a		inc a				inc 	a
.16ed	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.16f0	b0 02		bcs $16f4			bcs 	_SIMemory
.16f2	68		pla				pla
.16f3	60		rts				rts
.16f4					_SIMemory:
.16f4	4c dc 1f	jmp $1fdc		jmp	ErrorV_memory
.16f7					StringAllocTemp:
.16f7	20 d2 16	jsr $16d2			jsr 	StringInitialise 			; check it is initialised.
.16fa	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.16fc	18		clc				clc
.16fd	6d 69 05	adc $0569			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.1700	8d 69 05	sta $0569			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.1703	85 22		sta $22				sta 	zsTemp
.1705	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1707	ad 6a 05	lda $056a			lda 	stringTempPointer+1
.170a	69 ff		adc #$ff			adc 	#$FF
.170c	8d 6a 05	sta $056a			sta 	stringTempPointer+1
.170f	85 23		sta $23				sta 	zsTemp+1
.1711	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1713	74 56		stz $56,x			stz 	NSMantissa2,x
.1715	74 62		stz $62,x			stz 	NSMantissa3,x
.1717	a9 00		lda #$00			lda 	#0 							; clear string.
.1719	92 22		sta ($22)			sta 	(zsTemp)
.171b	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.171d	95 32		sta $32,x			sta 	NSStatus,x
.171f	60		rts				rts
.1720					StringWriteChar:
.1720	5a		phy				phy
.1721	48		pha				pha
.1722	b2 22		lda ($22)			lda 	(zsTemp)
.1724	1a		inc a				inc 	a
.1725	92 22		sta ($22)			sta 	(zsTemp)
.1727	a8		tay				tay
.1728	68		pla				pla
.1729	91 22		sta ($22),y			sta 	(zsTemp),y
.172b	7a		ply				ply
.172c	60		rts				rts
.0568					stringInitialised:
>0568							.fill 	1
.0569					stringTempPointer:
>0569							.fill 	2
.172d					Unary_Left:
.172d	fa		plx				plx
.172e	5a		phy				phy
.172f	18		clc				clc 								; only one parameter
.1730	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; push the length of the string.
.1733	48		pha				pha
.1734	ca		dex				dex
.1735	a9 00		lda #$00			lda 	#0 							; push the start position.
.1737	48		pha				pha
.1738	20 70 17	jsr $1770			jsr 	UnarySStringToZTemp0
.173b	80 3c		bra $1779			bra 	SubstringMain 				; stack now points to the string to slice.
.173d					Unary_Right:
.173d	fa		plx				plx
.173e	5a		phy				phy
.173f	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.1741	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; push the right length of the string.
.1744	48		pha				pha
.1745	ca		dex				dex
.1746	20 70 17	jsr $1770			jsr 	UnarySStringToZTemp0
.1749	68		pla				pla 								; this is the right requirement
.174a	38		sec				sec
.174b	49 ff		eor #$ff			eor 	#$FF
.174d	72 2c		adc ($2c)			adc 	(zTemp0)
.174f	b0 02		bcs $1753			bcs 	_URHaveCount
.1751	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.1753					_URHaveCount:
.1753	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.1755	5a		phy				phy
.1756	48		pha				pha 								; start position
.1757	80 20		bra $1779			bra 	SubstringMain
.1759					Unary_Mid:
.1759	fa		plx				plx
.175a	5a		phy				phy
.175b	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; push the length of the string required.
.175e	48		pha				pha
.175f	ca		dex				dex
.1760	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; put the start position.
.1763	f0 08		beq $176d			beq 	_UMError
.1765	3a		dec a				dec 	a
.1766	48		pha				pha
.1767	ca		dex				dex
.1768	20 70 17	jsr $1770			jsr 	UnarySStringToZTemp0
.176b	80 0c		bra $1779			bra 	SubstringMain 				; stack now points to the string to slice.
.176d					_UMError:
.176d	4c d1 1e	jmp $1ed1		jmp	ErrorV_range
.1770					UnarySStringToZTemp0:
.1770	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1772	85 2c		sta $2c				sta 	zTemp0
.1774	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1776	85 2d		sta $2d				sta 	zTemp0+1
.1778	60		rts				rts
.1779					SubstringMain:
.1779	68		pla				pla 								; get the start offset
.177a	7a		ply				ply 								; get the count to do.
.177b	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.177d	b0 38		bcs $17b7			bcs 	_SSReturnNull
.177f	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.1781	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.1783	18		clc				clc
.1784	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.1786	b0 06		bcs $178e			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.1788	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.178a	f0 04		beq $1790			beq 	_SMIsOkay
.178c	90 02		bcc $1790			bcc 	_SMIsOkay
.178e					_SMTruncateToEnd:
.178e	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.1790					_SMIsOkay:
.1790	85 2f		sta $2f				sta 	zTemp1+1
.1792	38		sec				sec		 							; work out size
.1793	a5 2f		lda $2f				lda 	zTemp1+1
.1795	e5 2e		sbc $2e				sbc 	zTemp1
.1797	f0 1e		beq $17b7			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.1799	20 f7 16	jsr $16f7			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.179c	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.179e					_SMCopy:
.179e	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.17a0	f0 11		beq $17b3			beq 	_SMExit
.17a2	c8		iny				iny 								; bump and
.17a3	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.17a5	5a		phy				phy
.17a6	48		pha				pha
.17a7	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.17a9	1a		inc a				inc 	a
.17aa	a8		tay				tay
.17ab	92 22		sta ($22)			sta 	(zsTemp)
.17ad	68		pla				pla 								; write character out
.17ae	91 22		sta ($22),y			sta 	(zsTemp),y
.17b0	7a		ply				ply 								; restore Y
.17b1	80 eb		bra $179e			bra 	_SMCopy
.17b3					_SMExit:
.17b3	7a		ply				ply
.17b4	4c 4b 08	jmp $084b			jmp 	NextCommand
.17b7					_SSReturnNull:
.17b7	a9 c9		lda #$c9			lda 	#SSRNull & $FF 				; set up mantissa
.17b9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17bb	a9 17		lda #$17			lda 	#SSRNull >> 8
.17bd	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17bf	74 56		stz $56,x			stz 	NSMantissa2,x
.17c1	74 62		stz $62,x			stz 	NSMantissa3,x
.17c3	a9 40		lda #$40			lda 	#NSSString
.17c5	95 32		sta $32,x			sta 	NSStatus,x
.17c7	80 ea		bra $17b3			bra 	_SMExit
.17c9					SSRNull:
>17c9	00 00						.word 	0
.17cb					CommandSwap:
.17cb	fa		plx				plx
.17cc	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17ce	48		pha				pha
.17cf	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.17d1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17d3	68		pla				pla
.17d4	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.17d6	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17d8	48		pha				pha
.17d9	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.17db	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17dd	68		pla				pla
.17de	95 49		sta $49,x			sta 	NSMantissa1-1,x
.17e0	b5 56		lda $56,x			lda 	NSMantissa2,x
.17e2	48		pha				pha
.17e3	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.17e5	95 56		sta $56,x			sta 	NSMantissa2,x
.17e7	68		pla				pla
.17e8	95 55		sta $55,x			sta 	NSMantissa2-1,x
.17ea	b5 62		lda $62,x			lda 	NSMantissa3,x
.17ec	48		pha				pha
.17ed	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.17ef	95 62		sta $62,x			sta 	NSMantissa3,x
.17f1	68		pla				pla
.17f2	95 61		sta $61,x			sta 	NSMantissa3-1,x
.17f4	b5 6e		lda $6e,x			lda 	NSExponent,x
.17f6	48		pha				pha
.17f7	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.17f9	95 6e		sta $6e,x			sta 	NSExponent,x
.17fb	68		pla				pla
.17fc	95 6d		sta $6d,x			sta 	NSExponent-1,x
.17fe	b5 32		lda $32,x			lda 	NSStatus,x
.1800	48		pha				pha
.1801	b5 31		lda $31,x			lda 	NSStatus-1,x
.1803	95 32		sta $32,x			sta 	NSStatus,x
.1805	68		pla				pla
.1806	95 31		sta $31,x			sta 	NSStatus-1,x
.1808	4c 4b 08	jmp $084b			jmp 	NextCommand
.180b					CommandSYS:
.180b	fa		plx				plx
.180c	da		phx				phx 								; save XY
.180d	5a		phy				phy
.180e	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.1811	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.1813	85 2d		sta $2d				sta 	zTemp0+1
.1815	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1817	85 2c		sta $2c				sta 	zTemp0
.1819	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.181c	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.181f	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.1822	48		pha				pha
.1823	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.1826	28		plp				plp
.1827	20 3e 18	jsr $183e			jsr 	_CSZTemp0
.182a	08		php				php
.182b	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.182e	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.1831	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.1834	68		pla				pla
.1835	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.1838	7a		ply				ply 								; restore YX and drop 2
.1839	fa		plx				plx
.183a	ca		dex				dex
.183b	4c 4b 08	jmp $084b			jmp 	NextCommand
.183e					_CSZTemp0:
.183e	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.1841					TimeTOS:
.1841	fa		plx				plx
.1842	20 9c 18	jsr $189c			jsr 	TIPushClock 				; push clock to TOS
.1845	4c 4b 08	jmp $084b			jmp 	NextCommand
.1848					TimeString:
.1848	fa		plx				plx
.1849	20 9c 18	jsr $189c			jsr 	TIPushClock 				; push clock to TOS
.184c	20 71 18	jsr $1871			jsr 	_TSDivMod60 				; result in seconds
.184f	20 71 18	jsr $1871			jsr 	_TSDivMod60 				; seconds
.1852	48		pha				pha
.1853	20 71 18	jsr $1871			jsr 	_TSDivMod60 				; minutes
.1856	48		pha				pha
.1857	a9 18		lda #$18			lda 	#24 						; hours
.1859	20 73 18	jsr $1873			jsr 	_TSDivModA
.185c	48		pha				pha
.185d	a9 06		lda #$06			lda 	#6
.185f	20 f7 16	jsr $16f7			jsr 	StringAllocTemp
.1862	68		pla				pla
.1863	20 83 18	jsr $1883			jsr 	_TSWriteDecimal
.1866	68		pla				pla
.1867	20 83 18	jsr $1883			jsr 	_TSWriteDecimal
.186a	68		pla				pla
.186b	20 83 18	jsr $1883			jsr 	_TSWriteDecimal
.186e	4c 4b 08	jmp $084b			jmp 	NextCommand
.1871					_TSDivMod60:
.1871	a9 3c		lda #$3c			lda 	#60
.1873					_TSDivModA:
.1873	e8		inx				inx
.1874	20 36 26	jsr $2636			jsr 	FloatSetByte
.1877	ca		dex				dex
.1878	20 ca 21	jsr $21ca			jsr 	Int32Divide
.187b	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.187d	48		pha				pha
.187e	20 b9 21	jsr $21b9			jsr 	NSMCopyPlusTwoToZero
.1881	68		pla				pla
.1882	60		rts				rts
.1883					_TSWriteDecimal:
.1883	da		phx				phx
.1884	a2 30		ldx #$30			ldx 	#'0'
.1886					_TSWDLoop:
.1886	c9 0a		cmp #$0a			cmp 	#10
.1888	90 05		bcc $188f			bcc 	_TSWDEnd
.188a	e9 0a		sbc #$0a			sbc 	#10
.188c	e8		inx				inx
.188d	80 f7		bra $1886			bra 	_TSWDLoop
.188f					_TSWDEnd:
.188f	48		pha				pha
.1890	8a		txa				txa
.1891	20 20 17	jsr $1720			jsr 	StringWriteChar
.1894	68		pla				pla
.1895	09 30		ora #$30			ora 	#'0'
.1897	20 20 17	jsr $1720			jsr 	StringWriteChar
.189a	fa		plx				plx
.189b	60		rts				rts
.189c					TIPushClock:
.189c	5a		phy				phy
.189d	e8		inx				inx 								; push 0 on the stack
.189e	20 34 26	jsr $2634			jsr 	FloatSetZero
.18a1	da		phx				phx
.18a2	20 8c 1c	jsr $1c8c			jsr 	XReadClock 					; read time into YXA
.18a5	86 2c		stx $2c				stx 	zTemp0
.18a7	fa		plx				plx
.18a8	95 3e		sta $3e,x			sta 	NSMantissa0,x
.18aa	a5 2c		lda $2c				lda 	zTemp0
.18ac	95 4a		sta $4a,x			sta 	NSMantissa1,x
.18ae	98		tya				tya
.18af	95 56		sta $56,x			sta 	NSMantissa2,x
.18b1	7a		ply				ply
.18b2	60		rts				rts
.18b3					CommandTIWrite:
.18b3	fa		plx				plx
.18b4	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.18b6	85 22		sta $22				sta 	zsTemp
.18b8	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.18ba	85 23		sta $23				sta 	zsTemp+1
.18bc	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.18be	c9 06		cmp #$06			cmp 	#6
.18c0	d0 59		bne $191b			bne 	_CTIWError
.18c2	20 34 26	jsr $2634			jsr 	FloatSetZero
.18c5	20 e7 18	jsr $18e7			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.18c8	20 e7 18	jsr $18e7			jsr 	_CTIWDigitPair
.18cb	20 e7 18	jsr $18e7			jsr 	_CTIWDigitPair
.18ce	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.18d0	20 12 19	jsr $1912			jsr 	_CTIWMultiply
.18d3	da		phx				phx
.18d4	5a		phy				phy
.18d5	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.18d7	48		pha				pha
.18d8	b5 56		lda $56,x			lda 	NSMantissa2,x
.18da	a8		tay				tay
.18db	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.18dd	fa		plx				plx
.18de	20 90 1c	jsr $1c90			jsr 	XWriteClock 				; update the clock.
.18e1	7a		ply				ply
.18e2	fa		plx				plx
.18e3	ca		dex				dex 								; throw result.
.18e4	4c 4b 08	jmp $084b			jmp 	NextCommand
.18e7					_CTIWDigitPair:
.18e7	a9 06		lda #$06			lda 	#6 							; x 6
.18e9	20 12 19	jsr $1912			jsr 	_CTIWMultiply
.18ec	20 f8 18	jsr $18f8			jsr 	_CTIWAddDigit 				; add digit
.18ef	a9 0a		lda #$0a			lda 	#10 						; x 10
.18f1	20 12 19	jsr $1912			jsr 	_CTIWMultiply
.18f4	20 f8 18	jsr $18f8			jsr 	_CTIWAddDigit 				; add digit
.18f7	60		rts				rts
.18f8					_CTIWAddDigit:
.18f8	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.18fa	d0 02		bne $18fe			bne 	_CTIWASkip
.18fc	e6 23		inc $23				inc 	zsTemp+1
.18fe					_CTIWASkip:
.18fe	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.1900	38		sec				sec
.1901	e9 30		sbc #$30			sbc 	#"0"
.1903	90 16		bcc $191b			bcc 	_CTIWError
.1905	c9 0a		cmp #$0a			cmp 	#9+1
.1907	b0 12		bcs $191b			bcs 	_CTIWError
.1909	e8		inx				inx 								; store at +1
.190a	20 36 26	jsr $2636			jsr 	FloatSetByte
.190d	ca		dex				dex
.190e	20 c0 23	jsr $23c0			jsr 	FloatAddTopTwoStack
.1911	60		rts				rts
.1912					_CTIWMultiply:
.1912	e8		inx				inx
.1913	20 36 26	jsr $2636			jsr 	FloatSetByte
.1916	ca		dex				dex
.1917	20 41 23	jsr $2341			jsr 	FloatMultiplyShort
.191a	60		rts				rts
.191b					_CTIWError:
.191b	4c e1 1e	jmp $1ee1		jmp	ErrorV_value
.191e					UnaryUsr:
.191e	fa		plx				plx
.191f	5a		phy				phy
.1920	20 27 19	jsr $1927			jsr 	_UUCallVector
.1923	7a		ply				ply
.1924	4c 4b 08	jmp $084b			jmp 	NextCommand
.1927					_UUCallVector:
.1927	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.192a					ValUnary:
.192a	fa		plx				plx
.192b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.192d	85 2c		sta $2c				sta 	zTemp0
.192f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1931	85 2d		sta $2d				sta 	zTemp0+1
.1933	20 3e 19	jsr $193e			jsr 	ValEvaluateZTemp0
.1936	b0 03		bcs $193b			bcs 	_VUError 					; couldn't convert
.1938	4c 4b 08	jmp $084b			jmp 	NextCommand
.193b					_VUError:
.193b	4c e1 1e	jmp $1ee1		jmp	ErrorV_value
.193e					ValEvaluateZTemp0:
.193e	5a		phy				phy
.193f	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.1941	f0 22		beq $1965			beq 	_VMCFail2
.1943	a0 00		ldy #$00			ldy 	#0 							; start position
.1945					_VMCSpaces:
.1945	c8		iny				iny 								; skip leading spaces
.1946	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1948	c9 20		cmp #$20			cmp 	#" "
.194a	f0 f9		beq $1945			beq 	_VMCSpaces
.194c	48		pha				pha 								; save first character
.194d	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.194f	d0 01		bne $1952			bne 	_VMCStart
.1951	c8		iny				iny 								; skip over - if so.
.1952					_VMCStart:
.1952	38		sec				sec 								; initialise first time round.
.1953					_VMCNext:
.1953	98		tya				tya 								; reached end of string
.1954	3a		dec a				dec 	a
.1955	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.1957	f0 0f		beq $1968			beq 	_VMCSuccess 				; successful.
.1959	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.195b	c8		iny				iny
.195c	20 18 24	jsr $2418			jsr 	FloatEncode 				; send it to the number-builder
.195f	90 03		bcc $1964			bcc 	_VMCFail 					; if failed, give up.
.1961	18		clc				clc 								; next time round, countinue
.1962	80 ef		bra $1953			bra 	_VMCNext
.1964					_VMCFail:
.1964	68		pla				pla
.1965					_VMCFail2:
.1965	7a		ply				ply
.1966	38		sec				sec
.1967	60		rts				rts
.1968					_VMCSuccess:
.1968	a9 00		lda #$00			lda 	#0 							; construct final
.196a	20 18 24	jsr $2418			jsr 	FloatEncode 				; by sending a duff value.
.196d	68		pla				pla 								; if it was -ve
.196e	c9 2d		cmp #$2d			cmp 	#"-"
.1970	d0 03		bne $1975			bne 	_VMCNotNegative
.1972	20 f6 25	jsr $25f6			jsr		FloatNegate 				; negate it.
.1975					_VMCNotNegative:
.1975	7a		ply				ply
.1976	18		clc				clc
.1977	60		rts				rts
.1978					VectorTable:
>1978	8f 10					.word	LinkFloatAdd             ; $80 +
>197a	98 10					.word	LinkFloatSubtract        ; $81 -
>197c	a1 10					.word	LinkFloatMultiply        ; $82 *
>197e	aa 10					.word	LinkFloatDivide          ; $83 /
>1980	b5 10					.word	LinkFloatPower           ; $84 ^
>1982	dd 08					.word	BinaryAnd                ; $85 and
>1984	e1 08					.word	BinaryOr                 ; $86 or
>1986	c0 10					.word	LinkCompareGreater       ; $87 >
>1988	c9 10					.word	LinkCompareEqual         ; $88 =
>198a	d2 10					.word	LinkCompareLess          ; $89 <
>198c	db 10					.word	LinkCompareGreaterEqual  ; $8a >=
>198e	e4 10					.word	LinkCompareNotEqual      ; $8b <>
>1990	ed 10					.word	LinkCompareLessEqual     ; $8c <=
>1992	c5 08					.word	AbsoluteTOS              ; $8d abs
>1994	18 09					.word	ArrayConvert             ; $8e array
>1996	c0 09					.word	UnaryAsc                 ; $8f asc
>1998	db 09					.word	CommandAssert            ; $90 assert
>199a	1c 0a					.word	Unary16Bin               ; $91 bin$
>199c	46 0a					.word	PrintCharacterX          ; $92 print.chr
>199e	50 0a					.word	UnaryChr                 ; $93 chr$
>19a0	b5 0a					.word	CompareStrings           ; $94 s.cmp
>19a2	9c 0c					.word	CommandXFor              ; $95 for
>19a4	5f 0d					.word	UnaryFre                 ; $96 fre
>19a6	77 0d					.word	CommandXGet              ; $97 get
>19a8	9d 0d					.word	CommandReturn            ; $98 return
>19aa	df 0d					.word	Command_PSET             ; $99 pset
>19ac	f9 0d					.word	Command_LINE             ; $9a line
>19ae	0e 0e					.word	Command_RECT             ; $9b rect
>19b0	1d 0e					.word	Command_FRAME            ; $9c frame
>19b2	2c 0e					.word	Command_CHAR             ; $9d char
>19b4	c3 0e					.word	Unary16Hex               ; $9e hex$
>19b6	6a 0f					.word	CommandXInput            ; $9f input
>19b8	81 0f					.word	CommandInputString       ; $a0 input$
>19ba	9a 0f					.word	CommandInputReset        ; $a1 input.start
>19bc	7e 10					.word	UnaryLen                 ; $a2 len
>19be	4a 11					.word	LinkFloatCompare         ; $a3 f.cmp
>19c0	53 11					.word	LinkDivideInt32          ; $a4 int.div
>19c2	cd 11					.word	NegateTOS                ; $a5 negate
>19c4	d4 11					.word	CommandNewLine           ; $a6 new.line
>19c6	dd 11					.word	CommandXNext             ; $a7 next
>19c8	c6 12					.word	NotTOS                   ; $a8 not
>19ca	dd 12					.word	CommandXOn               ; $a9 on
>19cc	fa 12					.word	CommandMoreOn            ; $aa moreon
>19ce	01 13					.word	UnaryPeek                ; $ab peek
>19d0	16 13					.word	CommandPOKE              ; $ac poke
>19d2	2e 13					.word	UnaryPos                 ; $ad pos
>19d4	38 13					.word	GetChannel               ; $ae getchannel
>19d6	43 13					.word	SetChannel               ; $af setchannel
>19d8	66 13					.word	PrintNumber              ; $b0 print.n
>19da	85 13					.word	PrintString              ; $b1 print.s
>19dc	ec 13					.word	CommandXRead             ; $b2 read
>19de	06 14					.word	CommandReadString        ; $b3 read$
>19e0	91 15					.word	UnaryRND                 ; $b4 rnd
>19e2	00 16					.word	StringConcatenate        ; $b5 concat
>19e4	57 16					.word	SignTOS                  ; $b6 sgn
>19e6	7a 16					.word	PrintTab                 ; $b7 print.tab
>19e8	88 16					.word	PrintPos                 ; $b8 print.pos
>19ea	99 16					.word	PrintSpace               ; $b9 print.spc
>19ec	b2 16					.word	Unary_Str                ; $ba str$
>19ee	2d 17					.word	Unary_Left               ; $bb left$
>19f0	3d 17					.word	Unary_Right              ; $bc right$
>19f2	59 17					.word	Unary_Mid                ; $bd mid$
>19f4	cb 17					.word	CommandSwap              ; $be swap
>19f6	41 18					.word	TimeTOS                  ; $bf ti
>19f8	48 18					.word	TimeString               ; $c0 ti$
>19fa	1e 19					.word	UnaryUsr                 ; $c1 usr
>19fc	2a 19					.word	ValUnary                 ; $c2 val
>19fe	88 1b					.word	CommandClose             ; $c3 close
>1a00	9a 1b					.word	CommandExit              ; $c4 exit
>1a02	a0 1b					.word	CommandDebug             ; $c5 debug
>1a04	06 1c					.word	CommandXOpen             ; $c6 open
>1a06	9a 1c					.word	CommandScreen            ; $c7 screen
>1a08	81 1e					.word	CommandVPOKE             ; $c8 vpoke
>1a0a	a6 1e					.word	CommandVPEEK             ; $c9 vpeek
>1a0c	72 16					.word	CommandShift             ; $ca .shift
>1a0e	89 08					.word	PushByteCommand          ; $cb .byte
>1a10	9c 08					.word	PushWordCommand          ; $cc .word
>1a12	a8 13					.word	CommandPushN             ; $cd .float
>1a14	ce 13					.word	CommandPushS             ; $ce .string
>1a16	3d 0b					.word	CommandXData             ; $cf .data
>1a18	ae 0d					.word	CommandXGoto             ; $d0 .goto
>1a1a	91 0d					.word	CommandXGosub            ; $d1 .gosub
>1a1c	c3 0d					.word	CommandGotoZ             ; $d2 .goto.z
>1a1e	d1 0d					.word	CommandGotoNZ            ; $d3 .goto.nz
>1a20	cb 08					.word	CommandVarSpace          ; $d4 .varspace
.1a22					ShiftVectorTable:
>1a22	68 0a					.word	CommandClr               ; $ca80 clr
>1a24	46 0b					.word	CommandXDIM              ; $ca81 dim
>1a26	37 0c					.word	CommandEnd               ; $ca82 end
>1a28	4f 10					.word	UnaryJoy                 ; $ca83 joy
>1a2a	f6 10					.word	LinkFloatIntegerPartDown ; $ca84 int
>1a2c	ff 10					.word	LinkFloatSquareRoot      ; $ca85 sqr
>1a2e	10 11					.word	LinkFloatLogarithm       ; $ca86 log
>1a30	1b 11					.word	LinkFloatExponent        ; $ca87 exp
>1a32	24 11					.word	LinkFloatCosine          ; $ca88 cos
>1a34	2d 11					.word	LinkFloatSine            ; $ca89 sin
>1a36	36 11					.word	LinkFloatTangent         ; $ca8a tan
>1a38	3f 11					.word	LinkFloatArcTan          ; $ca8b atn
>1a3a	7d 11					.word	XCommandMouse            ; $ca8c mouse
>1a3c	92 11					.word	XUnaryMB                 ; $ca8d mb
>1a3e	9f 11					.word	XUnaryMX                 ; $ca8e mx
>1a40	b0 11					.word	XUnaryMY                 ; $ca8f my
>1a42	7f 15					.word	CommandRestore           ; $ca90 restore
>1a44	ae 16					.word	CommandStop              ; $ca91 stop
>1a46	0b 18					.word	CommandSYS               ; $ca92 sys
>1a48	b3 18					.word	CommandTIWrite           ; $ca93 ti$.write
>1a4a	80 1a					.word	CommandXWAIT             ; $ca94 wait
>1a4c	cb 1b					.word	X16I2CPoke               ; $ca95 i2cpoke
>1a4e	eb 1b					.word	X16I2CPeek               ; $ca96 i2cpeek
>1a50	56 1c					.word	CommandBank              ; $ca97 bank
>1a52	a9 1c					.word	XCommandSleep            ; $ca98 sleep
>1a54	cd 1c					.word	X16_Audio_FMINIT         ; $ca99 fminit
>1a56	db 1c					.word	X16_Audio_FMNOTE         ; $ca9a fmnote
>1a58	ed 1c					.word	X16_Audio_FMDRUM         ; $ca9b fmdrum
>1a5a	ff 1c					.word	X16_Audio_FMINST         ; $ca9c fminst
>1a5c	11 1d					.word	X16_Audio_FMVIB          ; $ca9d fmvib
>1a5e	23 1d					.word	X16_Audio_FMFREQ         ; $ca9e fmfreq
>1a60	34 1d					.word	X16_Audio_FMVOL          ; $ca9f fmvol
>1a62	46 1d					.word	X16_Audio_FMPAN          ; $caa0 fmpan
>1a64	58 1d					.word	X16_Audio_FMPLAY         ; $caa1 fmplay
>1a66	69 1d					.word	X16_Audio_FMCHORD        ; $caa2 fmchord
>1a68	7a 1d					.word	X16_Audio_FMPOKE         ; $caa3 fmpoke
>1a6a	8c 1d					.word	X16_Audio_PSGINIT        ; $caa4 psginit
>1a6c	9a 1d					.word	X16_Audio_PSGNOTE        ; $caa5 psgnote
>1a6e	ac 1d					.word	X16_Audio_PSGVOL         ; $caa6 psgvol
>1a70	be 1d					.word	X16_Audio_PSGWAV         ; $caa7 psgwav
>1a72	d0 1d					.word	X16_Audio_PSGFREQ        ; $caa8 psgfreq
>1a74	e1 1d					.word	X16_Audio_PSGPAN         ; $caa9 psgpan
>1a76	f3 1d					.word	X16_Audio_PSGPLAY        ; $caaa psgplay
>1a78	04 1e					.word	X16_Audio_PSGCHORD       ; $caab psgchord
>1a7a	15 1e					.word	CommandCls               ; $caac cls
>1a7c	1e 1e					.word	CommandLocate            ; $caad locate
>1a7e	48 1e					.word	CommandColor             ; $caae color
.1a80					CommandXWAIT:
.1a80	fa		plx				plx
.1a81	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1a83	85 2c		sta $2c				sta 	zTemp0
.1a85	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1a87	85 2d		sta $2d				sta 	zTemp0+1
.1a89					_WaitLoop:
.1a89	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1a8b	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1a8d	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1a8f	f0 f8		beq $1a89			beq 	_WaitLoop 					; keep going if zero
.1a91	ca		dex				dex 								; drop 3.
.1a92	ca		dex				dex
.1a93	ca		dex				dex
.1a94	4c 4b 08	jmp $084b			jmp 	NextCommand
.1a97					WriteFloatCommand:
.1a97	fa		plx				plx
.1a98	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1a9a	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1a9c	88		dey				dey 								; get the upper 3 bits
.1a9d	b1 28		lda ($28),y			lda 	(codePtr),y
.1a9f	29 07		and #$07			and 	#7
.1aa1	c8		iny				iny
.1aa2	c8		iny				iny
.1aa3	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1aa5	2a		rol a				rol 	a 							; carry will be clear.
.1aa6	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1aa9	85 2d		sta $2d				sta 	zTemp0+1
.1aab	20 b1 1a	jsr $1ab1			jsr 	WriteFloatZTemp0Sub
.1aae	4c 4b 08	jmp $084b			jmp 	NextCommand
.1ab1					WriteFloatZTemp0Sub:
.1ab1	5a		phy				phy 								; ldart write
.1ab2	a0 01		ldy #$01			ldy 	#1
.1ab4	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ab6	92 2c		sta ($2c)			sta 	(zTemp0)
.1ab8	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1aba	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1abc	c8		iny				iny
.1abd	b5 56		lda $56,x			lda 	NSMantissa2,x
.1abf	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ac1	c8		iny				iny
.1ac2	b5 62		lda $62,x			lda 	NSMantissa3,x
.1ac4	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ac6	c8		iny				iny
.1ac7	b5 6e		lda $6e,x			lda 	NSExponent,x
.1ac9	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1acb	c8		iny				iny
.1acc	b5 32		lda $32,x			lda 	NSStatus,x
.1ace	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ad0	ca		dex				dex
.1ad1	7a		ply				ply
.1ad2	60		rts				rts
.1ad3					WriteIntegerCommand:
.1ad3	fa		plx				plx
.1ad4	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1ad6	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1ad8	88		dey				dey 								; get the upper 3 bits
.1ad9	b1 28		lda ($28),y			lda 	(codePtr),y
.1adb	29 07		and #$07			and 	#7
.1add	c8		iny				iny
.1ade	c8		iny				iny
.1adf	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1ae1	2a		rol a				rol 	a 							; carry will be clear.
.1ae2	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1ae5	85 2d		sta $2d				sta 	zTemp0+1
.1ae7	20 ed 1a	jsr $1aed			jsr 	WriteIntegerZTemp0Sub
.1aea	4c 4b 08	jmp $084b			jmp 	NextCommand
.1aed					WriteIntegerZTemp0Sub:
.1aed	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.1af0	5a		phy				phy 								; start write
.1af1	a0 01		ldy #$01			ldy 	#1
.1af3	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1af5	30 0b		bmi $1b02			bmi 	_WIZNegative
.1af7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1af9	92 2c		sta ($2c)			sta 	(zTemp0)
.1afb	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1afd	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1aff	7a		ply				ply
.1b00	ca		dex				dex
.1b01	60		rts				rts
.1b02					_WIZNegative:
.1b02	38		sec				sec 								; -ve read
.1b03	a9 00		lda #$00			lda 	#0
.1b05	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1b07	92 2c		sta ($2c)			sta 	(zTemp0)
.1b09	a9 00		lda #$00			lda 	#0
.1b0b	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1b0d	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b0f	7a		ply				ply
.1b10	ca		dex				dex
.1b11	60		rts				rts
.1b12					WriteStringCommand:
.1b12	fa		plx				plx
.1b13	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b15	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b17	88		dey				dey 								; get the upper 3 bits
.1b18	b1 28		lda ($28),y			lda 	(codePtr),y
.1b1a	29 07		and #$07			and 	#7
.1b1c	c8		iny				iny
.1b1d	c8		iny				iny
.1b1e	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b20	2a		rol a				rol 	a 							; carry will be clear.
.1b21	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b24	85 2d		sta $2d				sta 	zTemp0+1
.1b26	20 2c 1b	jsr $1b2c			jsr 	WriteStringZTemp0Sub
.1b29	4c 4b 08	jmp $084b			jmp 	NextCommand
.1b2c					WriteStringZTemp0Sub:
.1b2c	5a		phy				phy
.1b2d	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b2f	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b31	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b33	f0 1e		beq $1b53			beq 	_WSConcrete
.1b35	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b37	85 2e		sta $2e				sta 	zTemp1
.1b39	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b3b	85 2f		sta $2f				sta 	zTemp1+1
.1b3d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b3f	85 30		sta $30				sta 	zTemp2
.1b41	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b43	85 31		sta $31				sta 	zTemp2+1
.1b45	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1b47	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1b49	b0 17		bcs $1b62			bcs 	_WSCopy
.1b4b	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1b4d	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b4f	09 80		ora #$80			ora 	#$80
.1b51	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1b53					_WSConcrete:
.1b53	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1b55	a8		tay				tay
.1b56	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b58	20 f7 0a	jsr $0af7			jsr 	StringConcrete
.1b5b	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1b5d	98		tya				tya
.1b5e	a0 01		ldy #$01			ldy 	#1
.1b60	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b62					_WSCopy
.1b62	18		clc				clc  								; copy target+2 to zTemp2
.1b63	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b65	69 02		adc #$02			adc 	#2
.1b67	85 30		sta $30				sta 	zTemp2
.1b69	a0 01		ldy #$01			ldy 	#1
.1b6b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b6d	69 00		adc #$00			adc 	#0
.1b6f	85 31		sta $31				sta 	zTemp2+1
.1b71	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1b73	85 2e		sta $2e				sta 	zTemp1
.1b75	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b77	85 2f		sta $2f				sta 	zTemp1+1
.1b79	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1b7b	a8		tay				tay
.1b7c					_WSCopyLoop:
.1b7c	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b7e	91 30		sta ($30),y			sta 	(zTemp2),y
.1b80	88		dey				dey
.1b81	c0 ff		cpy #$ff			cpy 	#$FF
.1b83	d0 f7		bne $1b7c			bne 	_WSCopyLoop
.1b85	ca		dex				dex
.1b86	7a		ply				ply
.1b87	60		rts				rts
.1b88					CommandClose:
.1b88	fa		plx				plx
.1b89	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; channel to close
.1b8c	cd 5d 04	cmp $045d			cmp 	currentChannel 				; is it the current channel
.1b8f	d0 03		bne $1b94			bne 	_CCNotCurrent
.1b91	9c 5d 04	stz $045d			stz 	currentChannel 				; effectively disables CMD
.1b94					_CCNotCurrent:
.1b94	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1b97	4c 4b 08	jmp $084b			jmp 	NextCommand
.1b9a					CommandExit:
.1b9a	fa		plx				plx
.1b9b	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1b9d	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1ba0					CommandDebug:
.1ba0	fa		plx				plx
>1ba1	db						.byte 	$DB 						; causes a break in the emulator
.1ba2	4c 4b 08	jmp $084b			jmp 	NextCommand
.1ba5					XGetCharacterFromChannel:
.1ba5	da		phx				phx
.1ba6	5a		phy				phy
.1ba7	e0 00		cpx #$00			cpx 	#0 							; is it default
.1ba9	d0 05		bne $1bb0			bne 	_XGetChannel
.1bab	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1bae	80 08		bra $1bb8			bra 	_XGetChar
.1bb0					_XGetChannel:
.1bb0	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1bb3	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1bb6	d0 06		bne $1bbe			bne 	_XGCError
.1bb8					_XGetChar:
.1bb8	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1bbb	7a		ply				ply
.1bbc	fa		plx				plx
.1bbd	60		rts				rts
.1bbe					_XGCError:
.1bbe	4c ed 1f	jmp $1fed		jmp	ErrorV_channel
.1bc1					XGetHPos:
.1bc1	da		phx				phx
.1bc2	5a		phy				phy
.1bc3	38		sec				sec
.1bc4	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1bc7	98		tya				tya
.1bc8	7a		ply				ply
.1bc9	fa		plx				plx
.1bca	60		rts				rts
.1bcb					X16I2CPoke:
.1bcb	fa		plx				plx
.1bcc	5a		phy				phy
.1bcd	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; value
.1bd0	48		pha				pha
.1bd1	ca		dex				dex
.1bd2	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; register
.1bd5	48		pha				pha
.1bd6	ca		dex				dex
.1bd7	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; device
.1bda	aa		tax				tax
.1bdb	7a		ply				ply
.1bdc	68		pla				pla
.1bdd	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1be0	b0 06		bcs $1be8			bcs 	X16I2CError
.1be2	7a		ply				ply
.1be3	a2 ff		ldx #$ff			ldx 	#$FF
.1be5	4c 4b 08	jmp $084b			jmp 	NextCommand
.1be8					X16I2CError:
.1be8	4c ed 1f	jmp $1fed		jmp	ErrorV_channel
.1beb					X16I2CPeek:
.1beb	fa		plx				plx
.1bec	da		phx				phx
.1bed	5a		phy				phy
.1bee	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; register
.1bf1	48		pha				pha
.1bf2	ca		dex				dex
.1bf3	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; device
.1bf6	aa		tax				tax 								; X device
.1bf7	7a		ply				ply 								; Y register
.1bf8	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1bfb	b0 eb		bcs $1be8			bcs 	X16I2CError
.1bfd	7a		ply				ply 								; restore Y/X
.1bfe	fa		plx				plx
.1bff	ca		dex				dex 								; drop TOS (register)
.1c00	20 36 26	jsr $2636			jsr 	FloatSetByte 				; write read value to TOS.
.1c03	4c 4b 08	jmp $084b			jmp 	NextCommand
.1c06					CommandXOpen:
.1c06	fa		plx				plx
.1c07	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1c09	85 2c		sta $2c				sta 	zTemp0
.1c0b	aa		tax				tax
.1c0c	a5 4d		lda $4d				lda 	NSMantissa1+3
.1c0e	85 2d		sta $2d				sta 	zTemp0+1
.1c10	a8		tay				tay
.1c11	e8		inx				inx 								; XY points to first character
.1c12	d0 01		bne $1c15			bne 	_CONoCarry
.1c14	c8		iny				iny
.1c15					_CONoCarry:
.1c15	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c17	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c1a	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c1c	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c1e	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c20	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c23	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c26	b0 03		bcs $1c2b			bcs 	_COError
.1c28	4c 4b 08	jmp $084b			jmp 	NextCommand
.1c2b					_COError:
.1c2b	4c ed 1f	jmp $1fed		jmp	ErrorV_channel
.1c2e					XPokeMemory:
.1c2e	86 2c		stx $2c				stx 	zTemp0
.1c30	84 2d		sty $2d				sty 	zTemp0+1
.1c32	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c34	ae 6b 05	ldx $056b			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c37	e0 ff		cpx #$ff			cpx 	#$FF
.1c39	f0 02		beq $1c3d			beq 	_XPMNoSwitch
.1c3b	86 00		stx $00				stx 	SelectRAMBank
.1c3d					_XPMNoSwitch:
.1c3d	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1c3f	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1c41					_XPMExit:
.1c41	60		rts				rts
.1c42					XPeekMemory:
.1c42	86 2c		stx $2c				stx 	zTemp0
.1c44	84 2d		sty $2d				sty 	zTemp0+1
.1c46	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c48	ae 6b 05	ldx $056b			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c4b	e0 ff		cpx #$ff			cpx 	#$FF
.1c4d	f0 02		beq $1c51			beq 	_XPMNoSwitch
.1c4f	86 00		stx $00				stx 	SelectRAMBank
.1c51					_XPMNoSwitch:
.1c51	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1c53	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1c55	60		rts				rts
.1c56					CommandBank:
.1c56	fa		plx				plx
.1c57	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1c59	8d 6b 05	sta $056b			sta 	ramBank 					; store & make current
.1c5c	85 00		sta $00				sta 	SelectRAMBank
.1c5e	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1c60	c9 ff		cmp #$ff			cmp 	#$FF
.1c62	f0 03		beq $1c67			beq 	_CBNoUpdate
.1c64	8d 6c 05	sta $056c			sta 	romBank 					; this doesn't set the hardware page.
.1c67					_CBNoUpdate:
.1c67	a2 ff		ldx #$ff			ldx 	#$FF
.1c69	4c 4b 08	jmp $084b			jmp 	NextCommand
.056b					ramBank:
>056b							.fill 	1
.056c					romBank:
>056c							.fill 	1
.1c6c					XPrintCharacterToChannel:
.1c6c	48		pha				pha
.1c6d	da		phx				phx
.1c6e	5a		phy				phy
.1c6f	48		pha				pha  								; save char
.1c70	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1c72	d0 05		bne $1c79			bne 	_XPCNotDefault
.1c74	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1c77	80 08		bra $1c81			bra 	_XPCSend
.1c79					_XPCNotDefault:
.1c79	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1c7c	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1c7f	d0 08		bne $1c89			bne 	_XPCError
.1c81					_XPCSend:
.1c81	68		pla				pla 								; restore character
.1c82	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1c85	7a		ply				ply
.1c86	fa		plx				plx
.1c87	68		pla				pla
.1c88	60		rts				rts
.1c89					_XPCError:
.1c89	4c ed 1f	jmp $1fed		jmp	ErrorV_channel
.1c8c					XReadClock:
.1c8c	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1c8f	60		rts				rts
.1c90					XWriteClock:
.1c90	48		pha				pha
.1c91	da		phx				phx
.1c92	5a		phy				phy
.1c93	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1c96	7a		ply				ply
.1c97	fa		plx				plx
.1c98	68		pla				pla
.1c99	60		rts				rts
.1c9a					CommandScreen:
.1c9a	fa		plx				plx
.1c9b	da		phx				phx
.1c9c	5a		phy				phy
.1c9d	20 27 10	jsr $1027			jsr 	GetInteger8Bit
.1ca0	18		clc				clc
.1ca1	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1ca4	7a		ply				ply
.1ca5	fa		plx				plx
.1ca6	4c 4b 08	jmp $084b			jmp 	NextCommand
.1ca9					XCommandSleep:
.1ca9	fa		plx				plx
.1caa	5a		phy				phy
.1cab	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.1cae	ca		dex				dex
.1caf	20 8c 1c	jsr $1c8c			jsr 	XReadClock 					; read clock to YXA
.1cb2	18		clc				clc 								; calculate end time in zTemp0
.1cb3	65 3e		adc $3e				adc 	NSMantissa0
.1cb5	85 2c		sta $2c				sta 	zTemp0
.1cb7	8a		txa				txa
.1cb8	65 4a		adc $4a				adc 	NSMantissa1
.1cba	85 2d		sta $2d				sta 	zTemp0+1
.1cbc					_XCWait:
.1cbc	20 8c 1c	jsr $1c8c			jsr 	XReadClock 					; and wait for it.
.1cbf	c5 2c		cmp $2c				cmp 	zTemp0
.1cc1	d0 f9		bne $1cbc			bne 	_XCWait
.1cc3	e4 2d		cpx $2d				cpx 	zTemp0+1
.1cc5	d0 f5		bne $1cbc			bne 	_XCWait
.1cc7	a2 ff		ldx #$ff			ldx 	#$FF
.1cc9	7a		ply				ply
.1cca	4c 4b 08	jmp $084b			jmp 	NextCommand
.1ccd					X16_Audio_FMINIT:
.1ccd	fa		plx				plx
.1cce	5a		phy			phy
.1ccf	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cd2	63 c0					.word	X16A_ym_init
>1cd4	0a					.byte	X16_AudioCodeBank
.1cd5	a2 ff		ldx #$ff		ldx	#$FF
.1cd7	7a		ply			ply
.1cd8	4c 4b 08	jmp $084b			jmp 	NextCommand
.1cdb					X16_Audio_FMNOTE:
.1cdb	fa		plx				plx
.1cdc	5a		phy			phy
.1cdd	20 f2 09	jsr $09f2		jsr		X16_Audio_Parameters8_8
.1ce0	18		clc			clc
.1ce1	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1ce4	03 c0					.word	X16A_bas_fmnote
>1ce6	0a					.byte	X16_AudioCodeBank
.1ce7	a2 ff		ldx #$ff		ldx	#$FF
.1ce9	7a		ply			ply
.1cea	4c 4b 08	jmp $084b			jmp 	NextCommand
.1ced					X16_Audio_FMDRUM:
.1ced	fa		plx				plx
.1cee	5a		phy			phy
.1cef	20 f2 09	jsr $09f2		jsr		X16_Audio_Parameters8_8
.1cf2	18		clc			clc
.1cf3	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cf6	6f c0					.word	X16A_ym_playdrum
>1cf8	0a					.byte	X16_AudioCodeBank
.1cf9	a2 ff		ldx #$ff		ldx	#$FF
.1cfb	7a		ply			ply
.1cfc	4c 4b 08	jmp $084b			jmp 	NextCommand
.1cff					X16_Audio_FMINST:
.1cff	fa		plx				plx
.1d00	5a		phy			phy
.1d01	20 f2 09	jsr $09f2		jsr		X16_Audio_Parameters8_8
.1d04	38		sec			sec
.1d05	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d08	69 c0					.word	X16A_ym_loadpatch
>1d0a	0a					.byte	X16_AudioCodeBank
.1d0b	a2 ff		ldx #$ff		ldx	#$FF
.1d0d	7a		ply			ply
.1d0e	4c 4b 08	jmp $084b			jmp 	NextCommand
.1d11					X16_Audio_FMVIB:
.1d11	fa		plx				plx
.1d12	5a		phy			phy
.1d13	20 f2 09	jsr $09f2		jsr		X16_Audio_Parameters8_8
.1d16	18		clc			clc
.1d17	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d1a	09 c0					.word	X16A_bas_fmvib
>1d1c	0a					.byte	X16_AudioCodeBank
.1d1d	a2 ff		ldx #$ff		ldx	#$FF
.1d1f	7a		ply			ply
.1d20	4c 4b 08	jmp $084b			jmp 	NextCommand
.1d23					X16_Audio_FMFREQ:
.1d23	fa		plx				plx
.1d24	5a		phy			phy
.1d25	20 ec 09	jsr $09ec		jsr		X16_Audio_Parameters8_16
.1d28	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d2b	00 c0					.word	X16A_bas_fmfreq
>1d2d	0a					.byte	X16_AudioCodeBank
.1d2e	a2 ff		ldx #$ff		ldx	#$FF
.1d30	7a		ply			ply
.1d31	4c 4b 08	jmp $084b			jmp 	NextCommand
.1d34					X16_Audio_FMVOL:
.1d34	fa		plx				plx
.1d35	5a		phy			phy
.1d36	20 f2 09	jsr $09f2		jsr		X16_Audio_Parameters8_8
.1d39	18		clc			clc
.1d3a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d3d	75 c0					.word	X16A_ym_setatten
>1d3f	0a					.byte	X16_AudioCodeBank
.1d40	a2 ff		ldx #$ff		ldx	#$FF
.1d42	7a		ply			ply
.1d43	4c 4b 08	jmp $084b			jmp 	NextCommand
.1d46					X16_Audio_FMPAN:
.1d46	fa		plx				plx
.1d47	5a		phy			phy
.1d48	20 f2 09	jsr $09f2		jsr		X16_Audio_Parameters8_8
.1d4b	18		clc			clc
.1d4c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d4f	7e c0					.word	X16A_ym_setpan
>1d51	0a					.byte	X16_AudioCodeBank
.1d52	a2 ff		ldx #$ff		ldx	#$FF
.1d54	7a		ply			ply
.1d55	4c 4b 08	jmp $084b			jmp 	NextCommand
.1d58					X16_Audio_FMPLAY:
.1d58	fa		plx				plx
.1d59	5a		phy			phy
.1d5a	20 03 0a	jsr $0a03		jsr		X16_Audio_Parameters8_String
.1d5d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d60	06 c0					.word	X16A_bas_fmplaystring
>1d62	0a					.byte	X16_AudioCodeBank
.1d63	a2 ff		ldx #$ff		ldx	#$FF
.1d65	7a		ply			ply
.1d66	4c 4b 08	jmp $084b			jmp 	NextCommand
.1d69					X16_Audio_FMCHORD:
.1d69	fa		plx				plx
.1d6a	5a		phy			phy
.1d6b	20 03 0a	jsr $0a03		jsr		X16_Audio_Parameters8_String
.1d6e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d71	8d c0					.word	X16A_bas_fmchordstring
>1d73	0a					.byte	X16_AudioCodeBank
.1d74	a2 ff		ldx #$ff		ldx	#$FF
.1d76	7a		ply			ply
.1d77	4c 4b 08	jmp $084b			jmp 	NextCommand
.1d7a					X16_Audio_FMPOKE:
.1d7a	fa		plx				plx
.1d7b	5a		phy			phy
.1d7c	20 f2 09	jsr $09f2		jsr		X16_Audio_Parameters8_8
.1d7f	18		clc			clc
.1d80	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d83	8a c0					.word	X16A_ym_write
>1d85	0a					.byte	X16_AudioCodeBank
.1d86	a2 ff		ldx #$ff		ldx	#$FF
.1d88	7a		ply			ply
.1d89	4c 4b 08	jmp $084b			jmp 	NextCommand
.1d8c					X16_Audio_PSGINIT:
.1d8c	fa		plx				plx
.1d8d	5a		phy			phy
.1d8e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d91	4b c0					.word	X16A_psg_init
>1d93	0a					.byte	X16_AudioCodeBank
.1d94	a2 ff		ldx #$ff		ldx	#$FF
.1d96	7a		ply			ply
.1d97	4c 4b 08	jmp $084b			jmp 	NextCommand
.1d9a					X16_Audio_PSGNOTE:
.1d9a	fa		plx				plx
.1d9b	5a		phy			phy
.1d9c	20 f2 09	jsr $09f2		jsr		X16_Audio_Parameters8_8
.1d9f	18		clc			clc
.1da0	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1da3	12 c0					.word	X16A_bas_psgnote
>1da5	0a					.byte	X16_AudioCodeBank
.1da6	a2 ff		ldx #$ff		ldx	#$FF
.1da8	7a		ply			ply
.1da9	4c 4b 08	jmp $084b			jmp 	NextCommand
.1dac					X16_Audio_PSGVOL:
.1dac	fa		plx				plx
.1dad	5a		phy			phy
.1dae	20 f2 09	jsr $09f2		jsr		X16_Audio_Parameters8_8
.1db1	18		clc			clc
.1db2	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1db5	54 c0					.word	X16A_psg_setatten
>1db7	0a					.byte	X16_AudioCodeBank
.1db8	a2 ff		ldx #$ff		ldx	#$FF
.1dba	7a		ply			ply
.1dbb	4c 4b 08	jmp $084b			jmp 	NextCommand
.1dbe					X16_Audio_PSGWAV:
.1dbe	fa		plx				plx
.1dbf	5a		phy			phy
.1dc0	20 f2 09	jsr $09f2		jsr		X16_Audio_Parameters8_8
.1dc3	18		clc			clc
.1dc4	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dc7	15 c0					.word	X16A_bas_psgwav
>1dc9	0a					.byte	X16_AudioCodeBank
.1dca	a2 ff		ldx #$ff		ldx	#$FF
.1dcc	7a		ply			ply
.1dcd	4c 4b 08	jmp $084b			jmp 	NextCommand
.1dd0					X16_Audio_PSGFREQ:
.1dd0	fa		plx				plx
.1dd1	5a		phy			phy
.1dd2	20 ec 09	jsr $09ec		jsr		X16_Audio_Parameters8_16
.1dd5	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dd8	0f c0					.word	X16A_bas_psgfreq
>1dda	0a					.byte	X16_AudioCodeBank
.1ddb	a2 ff		ldx #$ff		ldx	#$FF
.1ddd	7a		ply			ply
.1dde	4c 4b 08	jmp $084b			jmp 	NextCommand
.1de1					X16_Audio_PSGPAN:
.1de1	fa		plx				plx
.1de2	5a		phy			phy
.1de3	20 f2 09	jsr $09f2		jsr		X16_Audio_Parameters8_8
.1de6	18		clc			clc
.1de7	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dea	5a c0					.word	X16A_psg_setpan
>1dec	0a					.byte	X16_AudioCodeBank
.1ded	a2 ff		ldx #$ff		ldx	#$FF
.1def	7a		ply			ply
.1df0	4c 4b 08	jmp $084b			jmp 	NextCommand
.1df3					X16_Audio_PSGPLAY:
.1df3	fa		plx				plx
.1df4	5a		phy			phy
.1df5	20 03 0a	jsr $0a03		jsr		X16_Audio_Parameters8_String
.1df8	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dfb	18 c0					.word	X16A_bas_psgplaystring
>1dfd	0a					.byte	X16_AudioCodeBank
.1dfe	a2 ff		ldx #$ff		ldx	#$FF
.1e00	7a		ply			ply
.1e01	4c 4b 08	jmp $084b			jmp 	NextCommand
.1e04					X16_Audio_PSGCHORD:
.1e04	fa		plx				plx
.1e05	5a		phy			phy
.1e06	20 03 0a	jsr $0a03		jsr		X16_Audio_Parameters8_String
.1e09	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e0c	90 c0					.word	X16A_bas_psgchordstring
>1e0e	0a					.byte	X16_AudioCodeBank
.1e0f	a2 ff		ldx #$ff		ldx	#$FF
.1e11	7a		ply			ply
.1e12	4c 4b 08	jmp $084b			jmp 	NextCommand
.1e15					CommandCls:
.1e15	fa		plx				plx
.1e16	a9 93		lda #$93			lda 	#147
.1e18	20 6c 1c	jsr $1c6c			jsr 	XPrintCharacterToChannel
.1e1b	4c 4b 08	jmp $084b			jmp 	NextCommand
.1e1e					CommandLocate:
.1e1e	fa		plx				plx
.1e1f	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.1e22	ca		dex				dex
.1e23	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.1e26	ca		dex				dex
.1e27	a9 13		lda #$13			lda 	#$13 						; home.
.1e29	20 6c 1c	jsr $1c6c			jsr 	XPrintCharacterToChannel
.1e2c	a9 1d		lda #$1d			lda 	#$1D 						; do cursor rights
.1e2e	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1e30	20 3d 1e	jsr $1e3d			jsr 	_CLOutputXA
.1e33	a9 11		lda #$11			lda 	#$11 						; do cursor downs.
.1e35	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e37	20 3d 1e	jsr $1e3d			jsr 	_CLOutputXA
.1e3a	4c 4b 08	jmp $084b			jmp 	NextCommand
.1e3d					_CLOutputXA:
.1e3d	ca		dex				dex
.1e3e	f0 07		beq $1e47			beq 	_CLOExit
.1e40	30 05		bmi $1e47			bmi 	_CLOExit
.1e42	20 6c 1c	jsr $1c6c			jsr 	XPrintCharacterToChannel
.1e45	80 f6		bra $1e3d			bra 	_CLOutputXA
.1e47					_CLOExit:
.1e47	60		rts				rts
.1e48					CommandColor:
.1e48	fa		plx				plx
.1e49	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.1e4c	ca		dex				dex
.1e4d	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.1e50	ca		dex				dex
.1e51	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1e53	c9 ff		cmp #$ff			cmp 	#$FF
.1e55	f0 08		beq $1e5f			beq 	_CCNoBGR 					; if so, change background
.1e57	20 67 1e	jsr $1e67			jsr 	_CCSetColour
.1e5a	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1e5c	20 6c 1c	jsr $1c6c			jsr 	XPrintCharacterToChannel
.1e5f					_CCNoBGR:
.1e5f	a5 3e		lda $3e				lda 	NSMantissa0
.1e61	20 67 1e	jsr $1e67			jsr 	_CCSetColour
.1e64	4c 4b 08	jmp $084b			jmp 	NextCommand
.1e67					_CCSetColour:
.1e67	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1e69	aa		tax				tax
.1e6a	bd 71 1e	lda $1e71,x			lda 	_CCCommandTable,x
.1e6d	20 6c 1c	jsr $1c6c			jsr 	XPrintCharacterToChannel
.1e70	60		rts				rts
.1e71					_CCCommandTable:
>1e71	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1e79	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1e81					CommandVPOKE:
.1e81	fa		plx				plx
.1e82	20 27 10	jsr $1027			jsr 	GetInteger8Bit 				; poke value
.1e85	48		pha				pha
.1e86	ca		dex				dex
.1e87	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.1e8a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e8c	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1e8f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1e91	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1e94	ca		dex				dex
.1e95	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.1e98	20 27 10	jsr $1027			jsr 	GetInteger8Bit
.1e9b	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1e9e	ca		dex				dex
.1e9f	68		pla				pla 								; poke value back
.1ea0	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1ea3	4c 4b 08	jmp $084b			jmp 	NextCommand
.1ea6					CommandVPEEK:
.1ea6	fa		plx				plx
.1ea7	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.1eaa	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1eac	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1eaf	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1eb1	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1eb4	ca		dex				dex
.1eb5	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.1eb8	20 27 10	jsr $1027			jsr 	GetInteger8Bit
.1ebb	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1ebe	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1ec1	20 36 26	jsr $2636			jsr 	FloatSetByte 				; return as byte
.1ec4	4c 4b 08	jmp $084b			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1ec7					SetErrorHandler:
.1ec7	8c 6e 05	sty $056e			sty 	ErrorHandlerVector+1
.1eca	8e 6d 05	stx $056d			stx 	ErrorHandlerVector
.1ecd	60		rts				rts
.1ece					CallErrorHandler:
.1ece	6c 6d 05	jmp ($056d)			jmp 	(ErrorHandlerVector)
.056d					ErrorHandlerVector:
>056d							.fill 	2
.1ed1					ErrorV_range:
.1ed1	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1ed4	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1edc	41 4e 47 45 00
.1ee1					ErrorV_value:
.1ee1	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1ee4	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1eec	45 00
.1eee					ErrorV_syntax:
.1eee	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1ef1	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1ef9	52 52 4f 52 00
.1efe					ErrorV_type:
.1efe	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1f01	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f09	4d 41 54 43 48 00
.1f0f					ErrorV_unimplemented:
.1f0f	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1f12	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f1a	45 4d 45 4e 54 45 44 00
.1f22					ErrorV_assert:
.1f22	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1f25	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f2d	41 49 4c 00
.1f31					ErrorV_line:
.1f31	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1f34	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f3c	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f48					ErrorV_internal:
.1f48	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1f4b	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f53	20 45 52 52 4f 52 00
.1f5a					ErrorV_divzero:
.1f5a	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1f5d	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1f65	59 20 5a 45 52 4f 00
.1f6c					ErrorV_structure:
.1f6c	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1f6f	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1f77	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1f83					ErrorV_stop:
.1f83	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1f86	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1f8e	53 54 4f 50 50 45 44 00
.1f96					ErrorV_data:
.1f96	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1f99	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fa1	41 54 41 00
.1fa5					ErrorV_undeclared:
.1fa5	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1fa8	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1fb0	41 52 52 41 59 00
.1fb6					ErrorV_redefine:
.1fb6	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1fb9	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1fc1	44 45 46 49 4e 45 44 00
.1fc9					ErrorV_index:
.1fc9	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1fcc	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1fd4	59 20 49 4e 44 45 58 00
.1fdc					ErrorV_memory:
.1fdc	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1fdf	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>1fe7	45 4d 4f 52 59 00
.1fed					ErrorV_channel:
.1fed	20 ce 1e	jsr $1ece		jsr	CallErrorHandler
>1ff0	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>1ff8	54 50 55 54 20 45 52 52 4f 52 00
.2003					MoveObjectForward:
.2003	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.2005	c9 ff		cmp #$ff			cmp 	#$FF
.2007	f0 36		beq $203f			beq 	_MOFEnd
.2009	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.200b	90 24		bcc $2031			bcc 	_MOFAdvance1 				; forward 1
.200d	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.200f	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2011	90 20		bcc $2033			bcc 	_MOFAdvanceY
.2013	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2015	90 1a		bcc $2031			bcc 	_MOFAdvance1 				; forward 1
.2017	a8		tay				tay 								; read the size.
.2018	b9 7d 1f	lda $1f7d,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.201b	a8		tay				tay
.201c	c8		iny				iny 								; add 1 for the system token.
.201d	d0 14		bne $2033			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.201f	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2021	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2023	a8		tay				tay 								; into Y.
.2024	18		clc				clc
.2025	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.2027	69 02		adc #$02			adc 	#2
.2029	85 2a		sta $2a				sta 	objPtr
.202b	90 02		bcc $202f			bcc 	_MOFNoCarry1
.202d	e6 2b		inc $2b				inc 	objPtr+1
.202f					_MOFNoCarry1:
.202f	80 02		bra $2033			bra 	_MOFAdvanceY
.2031					_MOFAdvance1:
.2031	a0 01		ldy #$01			ldy 	#1
.2033					_MOFAdvanceY:
.2033	98		tya				tya 								; add Y to objPtr
.2034	18		clc				clc
.2035	65 2a		adc $2a				adc 	objPtr
.2037	85 2a		sta $2a				sta 	objPtr
.2039	90 02		bcc $203d			bcc 	_MOFNoCarry2
.203b	e6 2b		inc $2b				inc 	objPtr+1
.203d					_MOFNoCarry2:
.203d	18		clc				clc 								; not completed.
.203e	60		rts				rts
.203f					_MOFEnd:
.203f	e6 2a		inc $2a				inc 	objPtr
.2041	d0 02		bne $2045			bne 	_MOFENoCarry
.2043	e6 2b		inc $2b				inc 	objPtr+1
.2045					_MOFENoCarry:
.2045	38		sec				sec
.2046	60		rts				rts
.2047					MOFSizeTable:
>2047	01					.byte	1         	; $ca .shift
>2048	01					.byte	1         	; $cb .byte
>2049	02					.byte	2         	; $cc .word
>204a	05					.byte	5         	; $cd .float
>204b	ff					.byte	255       	; $ce .string
>204c	ff					.byte	255       	; $cf .data
>204d	02					.byte	2         	; $d0 .goto
>204e	02					.byte	2         	; $d1 .gosub
>204f	02					.byte	2         	; $d2 .goto.z
>2050	02					.byte	2         	; $d3 .goto.nz
>2051	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.056f					numberBuffer:
>056f							.fill 	34
.2052					FloatSubtract:
.2052	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.2054	49 80		eor #$80			eor 	#$80
.2056	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.2058					FloatAdd:
.2058	ca		dex				dex
.2059	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.205b	15 6f		ora $6f,x			ora 	NSExponent+1,x
.205d	15 62		ora $62,x			ora 	NSMantissa3,x
.205f	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2061	d0 04		bne $2067			bne 	_FAUseFloat
.2063	20 f4 23	jsr $23f4			jsr 	FloatInt32Add 				; use the int32 one.
.2066	60		rts				rts
.2067					_FAUseFloat:
.2067	20 89 23	jsr $2389			jsr 	FloatNormalise 				; normalise S[X]
.206a	f0 51		beq $20bd			beq 	_FAReturn1
.206c	e8		inx				inx 								; normalise S[X+1]
.206d	20 89 23	jsr $2389			jsr 	FloatNormalise
.2070	ca		dex				dex
.2071	c9 00		cmp #$00			cmp 	#0
.2073	f0 60		beq $20d5			beq 	_FAExit 					; if so, just return A
.2075	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.2077	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.2079	f0 18		beq $2093			beq 	_FAExponentsEqual
.207b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.207d	a8		tay				tay
.207e	38		sec				sec 								; do a signed comparison of the exponents.
.207f	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.2081	50 02		bvc $2085			bvc 	_FANoSignedChange
.2083	49 80		eor #$80			eor 	#$80
.2085					_FANoSignedChange:
.2085	29 80		and #$80			and 	#$80
.2087	10 02		bpl $208b			bpl 	_FAHaveMax
.2089	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.208b					_FAHaveMax:
.208b	20 d6 20	jsr $20d6			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.208e	e8		inx				inx
.208f	20 d6 20	jsr $20d6			jsr 	_FAShiftToExponent
.2092	ca		dex				dex
.2093					_FAExponentsEqual:
.2093	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.2095	55 33		eor $33,x			eor 	NSStatus+1,x
.2097	30 0e		bmi $20a7			bmi 	_FADifferentSigns
.2099	20 c0 23	jsr $23c0			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.209c	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.209e	10 35		bpl $20d5			bpl 	_FAExit 					; if no, we are done.
.20a0	20 4d 26	jsr $264d			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20a3	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.20a5	80 2e		bra $20d5			bra 	_FAExit
.20a7					_FADifferentSigns:
.20a7	20 da 23	jsr $23da			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20aa	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.20ac	10 06		bpl $20b4			bpl 	_FACheckZero 				; if no, check for -0
.20ae	20 f6 25	jsr $25f6			jsr 	FloatNegate 					; netate result
.20b1	20 fd 25	jsr $25fd			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20b4					_FACheckZero:
.20b4	20 56 26	jsr $2656			jsr 	FloatIsZero	 				; check for -0
.20b7	d0 1c		bne $20d5			bne 	_FAExit
.20b9	74 32		stz $32,x			stz 	NSStatus,x
.20bb	80 18		bra $20d5			bra 	_FAExit
.20bd					_FAReturn1:
.20bd	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20bf	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20c1	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.20c3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.20c5	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.20c7	95 56		sta $56,x			sta 	NSMantissa2,x
.20c9	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.20cb	95 62		sta $62,x			sta 	NSMantissa3,x
.20cd	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.20cf	95 6e		sta $6e,x			sta 	NSExponent,x
.20d1	b5 33		lda $33,x			lda 	NSStatus+1,x
.20d3	95 32		sta $32,x			sta 	NSStatus,x
.20d5					_FAExit:
.20d5	60		rts				rts
.20d6					_FAShiftToExponent:
.20d6					_FAShiftToExponent2:
.20d6	98		tya				tya 								; compare Y to exponent
.20d7	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.20d9	f0 07		beq $20e2			beq 	_FASEExit 					; exit if so.
.20db	20 4d 26	jsr $264d			jsr 	FloatShiftRight	 			; shift the mantissa right
.20de	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.20e0	80 f4		bra $20d6			bra 	_FAShiftToExponent2
.20e2					_FASEExit:
.20e2	60		rts				rts
.20e3					CompareEqual:
.20e3	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20e5	d0 09		bne $20f0			bne 	ReturnFalse
.20e7					ReturnTrue:
.20e7	a9 01		lda #$01			lda 	#1
.20e9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20eb	a9 80		lda #$80			lda 	#$80
.20ed	95 32		sta $32,x			sta 	NSStatus,x
.20ef	60		rts				rts
.20f0					ReturnFalse:
.20f0	74 3e		stz $3e,x			stz 	NSMantissa0,x
.20f2	60		rts				rts
.20f3					CompareNotEqual:
.20f3	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20f5	d0 f0		bne $20e7			bne 	ReturnTrue
.20f7	80 f7		bra $20f0			bra 	ReturnFalse
.20f9					CompareLess:
.20f9	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20fb	c9 ff		cmp #$ff			cmp 	#$FF
.20fd	f0 e8		beq $20e7			beq 	ReturnTrue
.20ff	80 ef		bra $20f0			bra 	ReturnFalse
.2101					CompareGreater:
.2101	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2103	c9 01		cmp #$01			cmp 	#$01
.2105	f0 e0		beq $20e7			beq 	ReturnTrue
.2107	80 e7		bra $20f0			bra 	ReturnFalse
.2109					CompareLessEqual:
.2109	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.210b	c9 01		cmp #$01			cmp 	#$01
.210d	d0 d8		bne $20e7			bne 	ReturnTrue
.210f	80 df		bra $20f0			bra 	ReturnFalse
.2111					CompareGreaterEqual:
.2111	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2113	c9 ff		cmp #$ff			cmp 	#$FF
.2115	d0 d0		bne $20e7			bne 	ReturnTrue
.2117	80 d7		bra $20f0			bra 	ReturnFalse
.2119					FloatCompare:
.2119	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.211b	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.211d	48		pha				pha
.211e	20 52 20	jsr $2052			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2121	68		pla				pla
.2122	d0 0c		bne $2130			bne 	_FCCompareFloat
.2124	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2126	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2128	15 56		ora $56,x			ora 	NSMantissa2,x
.212a	15 62		ora $62,x			ora 	NSMantissa3,x
.212c	f0 14		beq $2142			beq 	_FCExit 					; if zero, return zero
.212e	80 0a		bra $213a			bra 	_FCSign
.2130					_FCCompareFloat:
.2130	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2132	29 f0		and #$f0			and 	#$F0
.2134	15 56		ora $56,x			ora 	NSMantissa2,x
.2136	15 62		ora $62,x			ora 	NSMantissa3,x
.2138	f0 08		beq $2142			beq 	_FCExit 					; zero, so approximately identical
.213a					_FCSign:
.213a	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.213c	34 32		bit $32,x			bit 	NSStatus,x
.213e	10 02		bpl $2142			bpl 	_FCExit
.2140					_FCNegative:
.2140	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2142					_FCExit:
.2142	20 36 26	jsr $2636			jsr 	FloatSetByte 				; set the result 255,0,1
.2145	60		rts				rts
.2146					FloatScalarTable:
>2146	66 66 66 66				.dword $66666666 ; 0.1
>214a	de					.byte $de
>214b	1f 85 eb 51				.dword $51eb851f ; 0.01
>214f	db					.byte $db
>2150	4c 37 89 41				.dword $4189374c ; 0.001
>2154	d8					.byte $d8
>2155	ac 8b db 68				.dword $68db8bac ; 0.0001
>2159	d4					.byte $d4
>215a	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>215e	d1					.byte $d1
>215f	83 de 1b 43				.dword $431bde83 ; 1e-06
>2163	ce					.byte $ce
>2164	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>2168	ca					.byte $ca
>2169	89 3b e6 55				.dword $55e63b89 ; 1e-08
>216d	c7					.byte $c7
>216e	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>2172	c4					.byte $c4
>2173	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>2177	c0					.byte $c0
>2178	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>217c	bd					.byte $bd
.217d					FloatDivide:
.217d	48		pha				pha
.217e	20 89 23	jsr $2389			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2181	ca		dex				dex
.2182	c9 00		cmp #$00			cmp 	#0
.2184	f0 1e		beq $21a4			beq 	_FDZero
.2186	20 89 23	jsr $2389			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2189	f0 16		beq $21a1			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.218b	20 ec 21	jsr $21ec			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.218e	20 b9 21	jsr $21b9			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.2191	20 89 23	jsr $2389			jsr		FloatNormalise 				; renormalise
.2194	20 7f 23	jsr $237f			jsr 	FloatCalculateSign 			; calculate result sign
.2197	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.2199	38		sec				sec
.219a	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.219c	38		sec				sec
.219d	e9 1e		sbc #$1e			sbc 	#30
.219f	95 6e		sta $6e,x			sta 	NSExponent,x
.21a1					_FDExit:
.21a1	68		pla				pla
.21a2	18		clc				clc
.21a3	60		rts				rts
.21a4					_FDZero:
.21a4	68		pla				pla
.21a5	38		sec				sec
.21a6	60		rts				rts
.21a7					DivideInt32:
.21a7	20 6f 22	jsr $226f			jsr 	FloatIntegerPart 			; make both integers
.21aa	ca		dex				dex
.21ab	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.21ae	20 ca 21	jsr $21ca			jsr 	Int32Divide 				; divide
.21b1	20 b9 21	jsr $21b9			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21b4	20 7f 23	jsr $237f			jsr 	FloatCalculateSign 			; calculate result sign
.21b7	18		clc				clc
.21b8	60		rts				rts
.21b9					NSMCopyPlusTwoToZero:
.21b9	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21bb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21bd	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21bf	95 4a		sta $4a,x			sta 	NSMantissa1,x
.21c1	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.21c3	95 56		sta $56,x			sta 	NSMantissa2,x
.21c5	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.21c7	95 62		sta $62,x			sta 	NSMantissa3,x
.21c9	60		rts				rts
.21ca					Int32Divide:
.21ca	48		pha				pha 								; save AXY
.21cb	5a		phy				phy
.21cc	20 17 26	jsr $2617			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.21cf	20 30 26	jsr $2630			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.21d2	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.21d4					_I32DivideLoop:
.21d4	e8		inx				inx
.21d5	e8		inx				inx
.21d6	20 43 26	jsr $2643			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.21d9	ca		dex				dex
.21da	ca		dex				dex
.21db	20 44 26	jsr $2644			jsr 	FloatRotateLeft
.21de	20 0a 22	jsr $220a			jsr 	FloatDivideCheck 			; check if subtract possible
.21e1	90 02		bcc $21e5			bcc 	_I32DivideNoCarryIn
.21e3	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.21e5					_I32DivideNoCarryIn:
.21e5	88		dey				dey 								; loop round till division completed.
.21e6	d0 ec		bne $21d4			bne 	_I32DivideLoop
.21e8	7a		ply				ply 								; restore AXY and exit
.21e9	68		pla				pla
.21ea	18		clc				clc
.21eb	60		rts				rts
.21ec					Int32ShiftDivide:
.21ec	48		pha				pha 								; save AY
.21ed	5a		phy				phy
.21ee	e8		inx				inx 								; clear S[X+2]
.21ef	e8		inx				inx
.21f0	20 34 26	jsr $2634			jsr 	FloatSetZero
.21f3	ca		dex				dex
.21f4	ca		dex				dex
.21f5	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.21f7					_I32SDLoop:
.21f7	20 0a 22	jsr $220a			jsr 	FloatDivideCheck 			; check if subtract possible
.21fa	e8		inx				inx
.21fb	e8		inx				inx
.21fc	20 44 26	jsr $2644			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.21ff	ca		dex				dex
.2200	ca		dex				dex
.2201	20 44 26	jsr $2644			jsr 	FloatRotateLeft
.2204	88		dey				dey 	 							; do 31 times
.2205	d0 f0		bne $21f7			bne 	_I32SDLoop
.2207	7a		ply				ply 								; restore AY and exit
.2208	68		pla				pla
.2209	60		rts				rts
.220a					FloatDivideCheck:
.220a	20 da 23	jsr $23da			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.220d	b0 04		bcs $2213			bcs 	_DCSExit 					; if carry set, then could do, exit
.220f	20 c0 23	jsr $23c0			jsr 	FloatAddTopTwoStack 		; add it back in
.2212	18		clc				clc 								; and return False
.2213					_DCSExit:
.2213	60		rts				rts
.2214					FloatFractionalPart:
.2214	5a		phy				phy
.2215	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.2217	29 7f		and #$7f			and 	#$7F
.2219	95 32		sta $32,x			sta 	NSStatus,x
.221b	20 89 23	jsr $2389			jsr 	FloatNormalise
.221e	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2220	38		sec				sec
.2221	e9 e0		sbc #$e0			sbc 	#$E0
.2223	90 29		bcc $224e			bcc 	_FFPExit 					; already fractional
.2225	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2227	b0 22		bcs $224b			bcs 	_FFPZero
.2229	a8		tay				tay 								; put count to do in Y
.222a	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.222c	20 53 22	jsr $2253			jsr 	_FFPPartial
.222f	95 62		sta $62,x			sta 	NSMantissa3,x
.2231	b5 56		lda $56,x			lda 	NSMantissa2,x
.2233	20 53 22	jsr $2253			jsr 	_FFPPartial
.2236	95 56		sta $56,x			sta 	NSMantissa2,x
.2238	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.223a	20 53 22	jsr $2253			jsr 	_FFPPartial
.223d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.223f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2241	20 53 22	jsr $2253			jsr 	_FFPPartial
.2244	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2246	20 56 26	jsr $2656			jsr 	FloatIsZero 					; zeroed check.
.2249	d0 03		bne $224e			bne 	_FFPExit
.224b					_FFPZero:
.224b	20 34 26	jsr $2634			jsr 	FloatSetZero
.224e					_FFPExit:
.224e	20 89 23	jsr $2389			jsr 	FloatNormalise
.2251	7a		ply				ply
.2252	60		rts				rts
.2253					_FFPPartial:
.2253	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2255	f0 17		beq $226e			beq 	_FFFPPExit
.2257	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.2259	b0 0c		bcs $2267			bcs 	_FFFPPWholeByte
.225b	5a		phy				phy
.225c					_FFFPPLeft:
.225c	0a		asl a				asl 	a
.225d	88		dey				dey
.225e	d0 fc		bne $225c			bne 	_FFFPPLeft
.2260	7a		ply				ply
.2261					_FFFPPRight:
.2261	4a		lsr a				lsr 	a
.2262	88		dey				dey
.2263	d0 fc		bne $2261			bne 	_FFFPPRight
.2265	80 07		bra $226e			bra 	_FFFPPExit
.2267					_FFFPPWholeByte:
.2267	98		tya				tya 								; subtract 8 from count
.2268	38		sec				sec
.2269	e9 08		sbc #$08			sbc 	#8
.226b	a8		tay				tay
.226c	a9 00		lda #$00			lda 	#0 							; and clear all
.226e					_FFFPPExit:
.226e	60		rts				rts
.226f					FloatIntegerPart:
.226f	48		pha				pha
.2270	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.2272	f0 1d		beq $2291			beq 	_FIPExit 					; if so do nothing
.2274	20 56 26	jsr $2656			jsr 	FloatIsZero 				; is it zero ?
.2277	f0 15		beq $228e			beq 	_FIPZero 					; if so return zero.
.2279	20 89 23	jsr $2389			jsr 	FloatNormalise 				; normalise
.227c	f0 10		beq $228e			beq 	_FIPZero 					; normalised to zero, exit zero
.227e					_FIPShift:
.227e	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2280	10 07		bpl $2289			bpl 	_FIPCheckZero
.2282	20 4d 26	jsr $264d			jsr 	FloatShiftRight 			; shift mantissa right
.2285	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.2287	80 f5		bra $227e			bra 	_FIPShift
.2289					_FIPCheckZero:
.2289	20 56 26	jsr $2656			jsr 	FloatIsZero 				; avoid -0 problem
.228c	d0 03		bne $2291			bne 	_FIPExit 					; set to zero if mantissa zero.
.228e					_FIPZero:
.228e	20 34 26	jsr $2634			jsr 	FloatSetZero
.2291					_FIPExit:
.2291	68		pla				pla
.2292	60		rts				rts
.2293					FloatIntegerPartDown:
.2293	48		pha				pha
.2294	5a		phy				phy
.2295	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.2297	f0 36		beq $22cf			beq 	_FIPExit 					; if so do nothing
.2299	20 56 26	jsr $2656			jsr 	FloatIsZero 				; is it zero ?
.229c	f0 2e		beq $22cc			beq 	_FIPZero 					; if so return zero.
.229e	20 89 23	jsr $2389			jsr 	FloatNormalise 				; normalise
.22a1	f0 29		beq $22cc			beq 	_FIPZero 					; normalised to zero, exit zero
.22a3	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22a5					_FIPShift:
.22a5	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22a7	10 0a		bpl $22b3			bpl 	_FIPCheckDown
.22a9	20 4d 26	jsr $264d			jsr 	FloatShiftRight 			; shift mantissa right
.22ac	90 01		bcc $22af			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22ae	c8		iny				iny
.22af					_FIPNoFrac:
.22af	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22b1	80 f2		bra $22a5			bra 	_FIPShift
.22b3					_FIPCheckDown:
.22b3	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22b5	f0 10		beq $22c7			beq 	_FIPCheckZero
.22b7	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22b9	10 0c		bpl $22c7			bpl 	_FIPCheckZero
.22bb	e8		inx				inx 								; -ve so round *down*.
.22bc	a9 01		lda #$01			lda 	#1
.22be	20 36 26	jsr $2636			jsr 	FloatSetByte
.22c1	20 f6 25	jsr $25f6			jsr 	FloatNegate
.22c4	20 58 20	jsr $2058			jsr 	FloatAdd
.22c7					_FIPCheckZero:
.22c7	20 56 26	jsr $2656			jsr 	FloatIsZero 				; avoid -0 problem
.22ca	d0 03		bne $22cf			bne 	_FIPExit 					; set to zero if mantissa zero.
.22cc					_FIPZero:
.22cc	20 34 26	jsr $2634			jsr 	FloatSetZero
.22cf					_FIPExit:
.22cf	7a		ply				ply
.22d0	68		pla				pla
.22d1	60		rts				rts
.22d2					FloatInt8Multiply:
.22d2	5a		phy				phy
.22d3	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.22d5	a8		tay				tay
.22d6	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.22d8					_FI8MLoop:
.22d8	98		tya				tya 								; shift right shifter right into carry
.22d9	4a		lsr a				lsr 	a
.22da	a8		tay				tay
.22db	90 0d		bcc $22ea			bcc 	_FI8MNoAdd
.22dd	18		clc				clc
.22de	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.22e0	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.22e2	95 3e		sta $3e,x			sta 	NSMantissa0,x
.22e4	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.22e6	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.22e8	95 4a		sta $4a,x			sta 	NSMantissa1,x
.22ea					_FI8MNoAdd:
.22ea	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.22ec	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.22ee	c0 00		cpy #$00			cpy 	#0
.22f0	d0 e6		bne $22d8			bne 	_FI8MLoop 					; until right shifter zero.
.22f2	7a		ply				ply
.22f3	60		rts				rts
.22f4					FloatMultiply:
.22f4	ca		dex				dex
.22f5	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.22f7	15 6f		ora $6f,x			ora 	NSExponent+1,x
.22f9	15 62		ora $62,x			ora 	NSMantissa3,x
.22fb	15 63		ora $63,x			ora 	NSMantissa3+1,x
.22fd	d0 21		bne $2320			bne 	_FMUseFloat
.22ff	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2301	15 33		ora $33,x			ora 	NSStatus+1,x
.2303	29 80		and #$80			and 	#$80
.2305	15 62		ora $62,x			ora 	NSMantissa3,x
.2307	15 56		ora $56,x			ora 	NSMantissa2,x
.2309	15 4a		ora $4a,x			ora 	NSMantissa1,x
.230b	15 63		ora $63,x			ora 	NSMantissa3+1,x
.230d	15 57		ora $57,x			ora 	NSMantissa2+1,x
.230f	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2311	d0 04		bne $2317			bne 	_FMInt32
.2313	20 d2 22	jsr $22d2			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2316	60		rts				rts
.2317					_FMInt32:
.2317	20 41 23	jsr $2341			jsr 	FloatMultiplyShort			; use the int32 one.
.231a	18		clc				clc 								; fix it up if gone out of range
.231b	75 6e		adc $6e,x			adc 	NSExponent,x
.231d	95 6e		sta $6e,x			sta 	NSExponent,x
.231f	60		rts				rts
.2320					_FMUseFloat:
.2320	20 89 23	jsr $2389			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2323	f0 18		beq $233d			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2325	e8		inx				inx
.2326	20 89 23	jsr $2389			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2329	ca		dex				dex
.232a	c9 00		cmp #$00			cmp 	#0
.232c	f0 0c		beq $233a			beq 	_FDSetZero
.232e	20 41 23	jsr $2341			jsr 	FloatMultiplyShort 			; calculate the result.
.2331	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2333	18		clc				clc
.2334	75 6f		adc $6f,x			adc 	NSExponent+1,x
.2336	95 6e		sta $6e,x			sta 	NSExponent,x
.2338	80 03		bra $233d			bra 	_FDExit
.233a					_FDSetZero:
.233a	20 34 26	jsr $2634			jsr 	FloatSetZero 				; return 0
.233d					_FDExit:
.233d	20 89 23	jsr $2389			jsr 	FloatNormalise 				; normalise the result
.2340	60		rts				rts
.2341					FloatMultiplyShort:
.2341	5a		phy				phy 								; save Y
.2342	20 17 26	jsr $2617			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2345	20 30 26	jsr $2630			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2348	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.234a					_I32MLoop:
.234a	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.234c	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.234e	15 58		ora $58,x			ora 	NSMantissa2+2,x
.2350	15 64		ora $64,x			ora 	NSMantissa3+2,x
.2352	f0 25		beq $2379			beq 	_I32MExit 					; exit if zero
.2354	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2356	29 01		and #$01			and 	#1
.2358	f0 0d		beq $2367			beq 	_I32MNoAdd
.235a	20 c0 23	jsr $23c0			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.235d	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.235f	10 06		bpl $2367			bpl 	_I32MNoAdd
.2361					_I32ShiftRight:
.2361	20 4d 26	jsr $264d			jsr 	FloatShiftRight 			; shift S[X] right
.2364	c8		iny				iny 								; increment shift count
.2365	80 09		bra $2370			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.2367					_I32MNoAdd:
.2367	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.2369	70 f6		bvs $2361			bvs 	_I32ShiftRight 				; instead.
.236b	e8		inx				inx
.236c	20 43 26	jsr $2643			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.236f	ca		dex				dex
.2370					_I32MShiftUpper:
.2370	e8		inx				inx 								; shift S[X+2] right
.2371	e8		inx				inx
.2372	20 4d 26	jsr $264d			jsr 	FloatShiftRight
.2375	ca		dex				dex
.2376	ca		dex				dex
.2377	80 d1		bra $234a			bra 	_I32MLoop 					; try again.
.2379					_I32MExit:
.2379	20 7f 23	jsr $237f			jsr 	FloatCalculateSign
.237c	98		tya				tya 								; shift in A
.237d	7a		ply				ply 								; restore Y and exit
.237e	60		rts				rts
.237f					FloatCalculateSign:
.237f	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.2381	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.2383	55 33		eor $33,x			eor 	NSStatus+1,x
.2385	0a		asl a				asl 	a 							; shift bit 7 into carry
.2386	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.2388	60		rts				rts
.2389					FloatNormalise:
.2389	20 56 26	jsr $2656			jsr 	FloatIsZero 				; if zero exit
.238c	d0 07		bne $2395			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.238e	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.2390	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.2392	a9 00		lda #$00			lda 	#0 							; set Z flag
.2394	60		rts				rts
.2395					_NSNormaliseOptimise:
.2395	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.2397	d0 19		bne $23b2			bne 	_NSNormaliseLoop
.2399	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.239b	30 15		bmi $23b2			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.239d	95 62		sta $62,x			sta 	NSMantissa3,x
.239f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.23a1	95 56		sta $56,x			sta 	NSMantissa2,x
.23a3	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.23a5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23a7	74 3e		stz $3e,x			stz 	NSMantissa0,x
.23a9	b5 6e		lda $6e,x			lda 	NSExponent,x
.23ab	38		sec				sec
.23ac	e9 08		sbc #$08			sbc 	#8
.23ae	95 6e		sta $6e,x			sta 	NSExponent,x
.23b0	80 e3		bra $2395			bra 	_NSNormaliseOptimise
.23b2					_NSNormaliseLoop:
.23b2	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23b4	70 07		bvs $23bd			bvs 	_NSNExit 					; exit if so with Z flag clear
.23b6	20 43 26	jsr $2643			jsr 	FloatShiftLeft 				; shift mantissa left
.23b9	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23bb	80 f5		bra $23b2			bra 	_NSNormaliseLoop
.23bd					_NSNExit:
.23bd	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23bf	60		rts				rts
.23c0					FloatAddTopTwoStack:
.23c0	18		clc				clc
.23c1	b5 3e		lda $3e,x			lda		NSMantissa0,x
.23c3	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.23c5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.23c7	b5 4a		lda $4a,x			lda		NSMantissa1,x
.23c9	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.23cb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23cd	b5 56		lda $56,x			lda		NSMantissa2,x
.23cf	75 57		adc $57,x			adc 		NSMantissa2+1,x
.23d1	95 56		sta $56,x			sta 	NSMantissa2,x
.23d3	b5 62		lda $62,x			lda		NSMantissa3,x
.23d5	75 63		adc $63,x			adc 		NSMantissa3+1,x
.23d7	95 62		sta $62,x			sta 	NSMantissa3,x
.23d9	60		rts				rts
.23da					FloatSubTopTwoStack:
.23da	38		sec				sec
.23db	b5 3e		lda $3e,x			lda		NSMantissa0,x
.23dd	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.23df	95 3e		sta $3e,x			sta 	NSMantissa0,x
.23e1	b5 4a		lda $4a,x			lda		NSMantissa1,x
.23e3	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.23e5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23e7	b5 56		lda $56,x			lda		NSMantissa2,x
.23e9	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.23eb	95 56		sta $56,x			sta 	NSMantissa2,x
.23ed	b5 62		lda $62,x			lda		NSMantissa3,x
.23ef	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.23f1	95 62		sta $62,x			sta 	NSMantissa3,x
.23f3	60		rts				rts
.23f4					FloatInt32Add:
.23f4	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.23f6	55 33		eor $33,x			eor 	NSStatus+1,x
.23f8	30 04		bmi $23fe			bmi 	_DiffSigns
.23fa	20 c0 23	jsr $23c0			jsr		FloatAddTopTwoStack
.23fd	60		rts				rts
.23fe					_DiffSigns:
.23fe	20 da 23	jsr $23da			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2401	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2403	10 07		bpl $240c			bpl 	_AddExit
.2405	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2407	95 32		sta $32,x			sta 	NSStatus,x
.2409	20 fd 25	jsr $25fd			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.240c					_AddExit:
.240c	20 56 26	jsr $2656			jsr 	FloatIsZero 				; check for -0
.240f	d0 02		bne $2413			bne 	_AddNonZero
.2411	74 32		stz $32,x			stz 	NSStatus,x
.2413					_AddNonZero:
.2413	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2414					FloatEncodeStart:
.2414	38		sec				sec
.2415	80 01		bra $2418			bra 	FloatEncodeContinue+1
.2417					FloatEncodeContinue:
.2417	18		clc				clc
.2418					FloatEncode:
.2418	08		php				php 								; save reset flag.
.2419	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.241b	f0 15		beq $2432			beq 	_ENIsOkay
.241d	c9 30		cmp #$30			cmp 	#"0"
.241f	90 04		bcc $2425			bcc 	_ENBadNumber
.2421	c9 3a		cmp #$3a			cmp 	#"9"+1
.2423	90 0d		bcc $2432			bcc 	_ENIsOkay
.2425					_ENBadNumber:
.2425	28		plp				plp 								; throw saved reset
.2426	ad 91 05	lda $0591			lda 	encodeState 				; if in decimal mode, construct final number
.2429	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.242b	d0 03		bne $2430			bne 	_ENFail
.242d	4c aa 24	jmp $24aa			jmp 	_ENConstructFinal
.2430					_ENFail:
.2430	18		clc				clc 								; not allowed
.2431	60		rts				rts
.2432					_ENIsOkay:
.2432	28		plp				plp 								; are we restarting
.2433	90 15		bcc $244a			bcc 	_ENNoRestart
.2435					_ENStartEncode:
.2435	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2437	f0 0c		beq $2445			beq 	_ENFirstDP
.2439	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.243b	20 36 26	jsr $2636			jsr 	FloatSetByte 				; in single byte mode.
.243e	a9 01		lda #$01			lda 	#ESTA_Low
.2440					_ENExitChange:
.2440	8d 91 05	sta $0591			sta 	encodeState 				; save new state
.2443	38		sec				sec
.2444	60		rts				rts
.2445					_ENFirstDP:
.2445	20 34 26	jsr $2634			jsr 	FloatSetZero 				; clear integer part
.2448	80 3c		bra $2486			bra 	_ESTASwitchFloat			; go straight to float and exi
.244a					_ENNoRestart:
.244a	48		pha				pha 								; save digit or DP on stack.
.244b	ad 91 05	lda $0591			lda 	encodeState 				; get current state
.244e	c9 01		cmp #$01			cmp 	#ESTA_Low
.2450	f0 09		beq $245b			beq  	_ESTALowState
.2452	c9 02		cmp #$02			cmp 	#ESTA_High
.2454	f0 26		beq $247c			beq 	_ESTAHighState
.2456	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2458	f0 38		beq $2492			beq 	_ESTADecimalState
>245a	db						.byte 	$DB 						; causes a break in the emulator
.245b					_ESTALowState:
.245b	68		pla				pla 								; get value back
.245c	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.245e	f0 26		beq $2486			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.2460	29 0f		and #$0f			and 	#15 						; make digit
.2462	8d 92 05	sta $0592			sta 	digitTemp 					; save it.
.2465	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.2467	0a		asl a				asl 	a
.2468	0a		asl a				asl 	a
.2469	75 3e		adc $3e,x			adc 	NSMantissa0,x
.246b	0a		asl a				asl 	a
.246c	6d 92 05	adc $0592			adc 	digitTemp
.246f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2471	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.2473	90 05		bcc $247a			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.2475	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.2477	8d 91 05	sta $0591			sta 	encodeState
.247a					_ESTANoSwitch:
.247a	38		sec				sec
.247b	60		rts				rts
.247c					_ESTAHighState:
.247c	68		pla				pla 								; get value back
.247d	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.247f	f0 05		beq $2486			beq 	_ESTASwitchFloat
.2481	20 dc 24	jsr $24dc			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.2484	38		sec				sec
.2485	60		rts				rts
.2486					_ESTASwitchFloat:
.2486	9c 93 05	stz $0593			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.2489	e8		inx				inx 								; zero the decimal additive.
.248a	20 34 26	jsr $2634			jsr 	FloatSetZero
.248d	ca		dex				dex
.248e	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.2490	80 ae		bra $2440			bra 	_ENExitChange
.2492					_ESTADecimalState:
.2492	68		pla				pla 								; digit.
.2493	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.2495	f0 99		beq $2430			beq 	_ENFail
.2497	e8		inx				inx 								; put digit into fractional part of X+1
.2498	20 dc 24	jsr $24dc			jsr 	ESTAShiftDigitIntoMantissa
.249b	ca		dex				dex
.249c	ee 93 05	inc $0593			inc 	decimalCount 				; bump the count of decimals
.249f	ad 93 05	lda $0593			lda 	decimalCount 				; too many decimal digits.
.24a2	c9 0b		cmp #$0b			cmp 	#11
.24a4	f0 02		beq $24a8			beq 	_ESTADSFail
.24a6	38		sec				sec
.24a7	60		rts				rts
.24a8					_ESTADSFail:
.24a8	18		clc				clc
.24a9	60		rts				rts
.24aa					_ENConstructFinal:
.24aa	ad 93 05	lda $0593			lda 	decimalCount 				; get decimal count
.24ad	f0 2b		beq $24da			beq 	_ENCFExit 					; no decimals
.24af	5a		phy				phy
.24b0	0a		asl a				asl 	a 							; x 4 and CLC
.24b1	0a		asl a				asl 	a
.24b2	6d 93 05	adc $0593			adc 	decimalCount
.24b5	a8		tay				tay
.24b6	b9 41 21	lda $2141,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24b9	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24bb	b9 42 21	lda $2142,y			lda 	FloatScalarTable-5+1,y
.24be	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.24c0	b9 43 21	lda $2143,y			lda 	FloatScalarTable-5+2,y
.24c3	95 58		sta $58,x			sta 	NSMantissa2+2,x
.24c5	b9 44 21	lda $2144,y			lda 	FloatScalarTable-5+3,y
.24c8	95 64		sta $64,x			sta 	NSMantissa3+2,x
.24ca	b9 45 21	lda $2145,y			lda 	FloatScalarTable-5+4,y
.24cd	95 70		sta $70,x			sta 	NSExponent+2,x
.24cf	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.24d1	e8		inx				inx 								; multiply decimal const by decimal scalar
.24d2	e8		inx				inx
.24d3	20 f4 22	jsr $22f4			jsr 	FloatMultiply
.24d6	20 58 20	jsr $2058			jsr 	FloatAdd 					; add to integer part.
.24d9	7a		ply				ply
.24da					_ENCFExit:
.24da	18		clc				clc 								; reject the digit.
.24db	60		rts				rts
.24dc					ESTAShiftDigitIntoMantissa:
.24dc	29 0f		and #$0f			and 	#15 						; save digit
.24de	48		pha				pha
.24df	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.24e1	48		pha				pha
.24e2	b5 56		lda $56,x			lda 	NSMantissa2,x
.24e4	48		pha				pha
.24e5	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.24e7	48		pha				pha
.24e8	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.24ea	48		pha				pha
.24eb	20 43 26	jsr $2643			jsr 	FloatShiftLeft 				; x 2
.24ee	20 43 26	jsr $2643			jsr 	FloatShiftLeft 				; x 4
.24f1	18		clc				clc 								; pop mantissa and add
.24f2	68		pla				pla
.24f3	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24f5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24f7	68		pla				pla
.24f8	75 4a		adc $4a,x			adc 	NSMantissa1,x
.24fa	95 4a		sta $4a,x			sta 	NSMantissa1,x
.24fc	68		pla				pla
.24fd	75 56		adc $56,x			adc 	NSMantissa2,x
.24ff	95 56		sta $56,x			sta 	NSMantissa2,x
.2501	68		pla				pla
.2502	75 62		adc $62,x			adc 	NSMantissa3,x
.2504	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.2506	20 43 26	jsr $2643			jsr 	FloatShiftLeft 				; x 10
.2509	68		pla				pla 								; add digit
.250a	18		clc				clc
.250b	75 3e		adc $3e,x			adc 	NSMantissa0,x
.250d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.250f	90 0a		bcc $251b			bcc 	_ESTASDExit
.2511	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2513	d0 06		bne $251b			bne 	_ESTASDExit
.2515	f6 56		inc $56,x			inc 	NSMantissa2,x
.2517	d0 02		bne $251b			bne 	_ESTASDExit
.2519	f6 62		inc $62,x			inc 	NSMantissa3,x
.251b					_ESTASDExit:
.251b	60		rts				rts
.0591					encodeState:
>0591							.fill 	1
.0592					digitTemp:
>0592							.fill 	1
.0593					decimalCount:
>0593							.fill 	1
.251c					FloatToString:
.251c	da		phx				phx
.251d	5a		phy				phy 								; save code position
.251e	8d 94 05	sta $0594			sta 	decimalPlaces	 			; save number of DPs.
.2521	9c 95 05	stz $0595			stz 	dbOffset 					; offset into decimal buffer = start.
.2524	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.2526	10 08		bpl $2530			bpl 	_CNTSNotNegative
.2528	29 7f		and #$7f			and 	#$7F 						; make +ve
.252a	95 32		sta $32,x			sta 	NSStatus,x
.252c	a9 2d		lda #$2d			lda 	#"-"
.252e	80 02		bra $2532			bra 	_CNTMain
.2530					_CNTSNotNegative:
.2530	a9 20		lda #$20			lda 	#" "
.2532					_CNTMain:
.2532	20 94 25	jsr $2594			jsr 	WriteDecimalBuffer
.2535	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.2537	f0 0d		beq $2546			beq 	_CNTSNotFloat
.2539	e8		inx				inx 								; round up so we don't get too many 6.999999
.253a	a9 01		lda #$01			lda 	#1
.253c	20 36 26	jsr $2636			jsr 	FloatSetByte
.253f	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2541	95 6e		sta $6e,x			sta 	NSExponent,x
.2543	20 58 20	jsr $2058			jsr 	FloatAdd
.2546					_CNTSNotFloat:
.2546	20 76 25	jsr $2576			jsr 	MakePlusTwoString 			; do the integer part.
.2549	20 14 22	jsr $2214			jsr 	FloatFractionalPart 		; get the fractional part
.254c	20 89 23	jsr $2389			jsr 	FloatNormalise					; normalise , exit if zero
.254f	f0 22		beq $2573			beq 	_CNTSExit
.2551	a9 2e		lda #$2e			lda 	#"."
.2553	20 94 25	jsr $2594			jsr 	WriteDecimalBuffer 			; write decimal place
.2556					_CNTSDecimal:
.2556	ce 94 05	dec $0594			dec 	decimalPlaces 				; done all the decimals
.2559	30 18		bmi $2573			bmi 	_CNTSExit
.255b	e8		inx				inx 								; x 10.0
.255c	a9 0a		lda #$0a			lda 	#10
.255e	20 36 26	jsr $2636			jsr 	FloatSetByte
.2561	20 f4 22	jsr $22f4			jsr 	FloatMultiply
.2564	20 76 25	jsr $2576			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.2567	20 14 22	jsr $2214			jsr 	FloatFractionalPart 		; get the fractional part
.256a	20 89 23	jsr $2389			jsr 	FloatNormalise 				; normalise it.
.256d	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.256f	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.2571	b0 e3		bcs $2556			bcs 	_CNTSDecimal 				; keep going.
.2573					_CNTSExit:
.2573	7a		ply				ply
.2574	fa		plx				plx
.2575	60		rts				rts
.2576					MakePlusTwoString:
.2576	da		phx				phx
.2577	20 17 26	jsr $2617			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.257a	e8		inx				inx 								; access it
.257b	e8		inx				inx
.257c	20 6f 22	jsr $226f			jsr 	FloatIntegerPart 			; make it an integer
.257f	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.2581	20 b3 25	jsr $25b3			jsr 	ConvertInt32
.2584	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.2586					_MPTSCopy:
.2586	bd 6f 05	lda $056f,x			lda 	numberBuffer,x
.2589	20 94 25	jsr $2594			jsr 	WriteDecimalBuffer
.258c	e8		inx				inx
.258d	bd 6f 05	lda $056f,x			lda 	numberBuffer,x
.2590	d0 f4		bne $2586			bne 	_MPTSCopy
.2592	fa		plx				plx
.2593	60		rts				rts
.2594					WriteDecimalBuffer:
.2594	da		phx				phx
.2595	ae 95 05	ldx $0595			ldx 	dbOffset
.2598	9d 96 05	sta $0596,x			sta 	decimalBuffer,x
.259b	9e 97 05	stz $0597,x			stz 	decimalBuffer+1,x
.259e	ee 95 05	inc $0595			inc 	dbOffset
.25a1	fa		plx				plx
.25a2	60		rts				rts
.0594					decimalPlaces:
>0594							.fill 	1
.0595					dbOffset:
>0595							.fill 	1
.0596					decimalBuffer:
>0596							.fill 	32
.25a3					ConvertInt16:
.25a3	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.25a5	86 4a		stx $4a				stx 	NSMantissa1
.25a7	64 56		stz $56				stz 	NSMantissa2
.25a9	64 62		stz $62				stz 	NSMantissa3
.25ab	64 32		stz $32				stz 	NSStatus 					; positive integer
.25ad	a2 00		ldx #$00			ldx 	#0 							; stack level
.25af	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25b1	80 00		bra $25b3			bra 	ConvertInt32
.25b3					ConvertInt32:
.25b3	5a		phy				phy
.25b4	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25b6	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25b8	10 08		bpl $25c2			bpl 	_CI32NotNeg
.25ba	48		pha				pha
.25bb	a9 2d		lda #$2d			lda 	#'-'
.25bd	99 6f 05	sta $056f,y			sta 	numberBuffer,y
.25c0	c8		iny				iny
.25c1	68		pla				pla
.25c2					_CI32NotNeg:
.25c2	20 d0 25	jsr $25d0			jsr 	_CI32DivideConvert 			; recursive conversion
.25c5	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.25c7	99 6f 05	sta $056f,y			sta 	numberBuffer,y
.25ca	7a		ply				ply
.25cb	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.25cd	a9 6f		lda #$6f			lda 	#numberBuffer & $FF
.25cf	60		rts				rts
.25d0					_CI32DivideConvert:
.25d0	e8		inx				inx 								; write to next slot up
.25d1	20 36 26	jsr $2636			jsr 	FloatSetByte 		 		; write the base out.
.25d4	ca		dex				dex
.25d5	20 ca 21	jsr $21ca			jsr 	Int32Divide 				; divide
.25d8	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.25da	48		pha				pha
.25db	20 b9 21	jsr $21b9			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.25de	20 56 26	jsr $2656			jsr 	FloatIsZero 				; is it zero ?
.25e1	f0 05		beq $25e8			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.25e3	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.25e5	20 d0 25	jsr $25d0			jsr 	_CI32DivideConvert 			; and recusrively call.
.25e8					_CI32NoRecurse:
.25e8	68		pla				pla 								; remainder
.25e9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.25eb	90 02		bcc $25ef			bcc 	_CI32NotHex
.25ed	69 26		adc #$26			adc 	#6+32
.25ef					_CI32NotHex:
.25ef	69 30		adc #$30			adc 	#48
.25f1	99 6f 05	sta $056f,y			sta 	numberBuffer,y 				; write out and exit
.25f4	c8		iny				iny
.25f5	60		rts				rts
.25f6					FloatNegate:
.25f6	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.25f8	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.25fa	95 32		sta $32,x			sta 	NSStatus,x
.25fc	60		rts				rts
.25fd					FloatNegateMantissa:
.25fd	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.25fe	a9 00		lda #$00			lda 	#0
.2600	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2602	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2604	a9 00		lda #$00			lda 	#0
.2606	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.2608	95 4a		sta $4a,x			sta 	NSMantissa1,x
.260a	a9 00		lda #$00			lda 	#0
.260c	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.260e	95 56		sta $56,x			sta 	NSMantissa2,x
.2610	a9 00		lda #$00			lda 	#0
.2612	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2614	95 62		sta $62,x			sta 	NSMantissa3,x
.2616	60		rts				rts
.2617					FloatShiftUpTwo:
.2617	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2619	95 40		sta $40,x			sta 	NSMantissa0+2,x
.261b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.261d	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.261f	b5 56		lda $56,x			lda 	NSMantissa2,x
.2621	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2623	b5 62		lda $62,x			lda 	NSMantissa3,x
.2625	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2627	b5 6e		lda $6e,x			lda 	NSExponent,x
.2629	95 70		sta $70,x			sta 	NSExponent+2,x
.262b	b5 32		lda $32,x			lda 	NSStatus,x
.262d	95 34		sta $34,x			sta 	NSStatus+2,x
.262f	60		rts				rts
.2630					FloatSetZeroMantissaOnly:
.2630	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2632	80 08		bra $263c			bra 	FloatZero13
.2634					FloatSetZero:
.2634	a9 00		lda #$00			lda 	#0
.2636					FloatSetByte:
.2636	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2638					FloatSetMantissa:
.2638	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.263a	74 32		stz $32,x			stz 	NSStatus,x
.263c					FloatZero13:
.263c	74 4a		stz $4a,x			stz 	NSMantissa1,x
.263e	74 56		stz $56,x			stz 	NSMantissa2,x
.2640	74 62		stz $62,x			stz 	NSMantissa3,x
.2642	60		rts				rts
.2643					FloatShiftLeft:
.2643	18		clc				clc
.2644					FloatRotateLeft:
.2644	36 3e		rol $3e,x			rol 	NSMantissa0,x
.2646	36 4a		rol $4a,x			rol		NSMantissa1,x
.2648	36 56		rol $56,x			rol		NSMantissa2,x
.264a	36 62		rol $62,x			rol		NSMantissa3,x
.264c	60		rts				rts
.264d					FloatShiftRight:
.264d	56 62		lsr $62,x			lsr 	NSMantissa3,x
.264f	76 56		ror $56,x			ror		NSMantissa2,x
.2651	76 4a		ror $4a,x			ror		NSMantissa1,x
.2653	76 3e		ror $3e,x			ror		NSMantissa0,x
.2655	60		rts				rts
.2656					FloatIsZero:
.2656	b5 62		lda $62,x			lda 	NSMantissa3,x
.2658	15 56		ora $56,x			ora		NSMantissa2,x
.265a	15 4a		ora $4a,x			ora		NSMantissa1,x
.265c	15 3e		ora $3e,x			ora		NSMantissa0,x
.265e	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.265f					FloatArcTan:
.265f	20 89 23	jsr $2389			jsr 	FloatNormalise 					; normalise x
.2662	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.2664	48		pha				pha
.2665	74 32		stz $32,x			stz 	NSStatus,x
.2667	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.2669	c9 e2		cmp #$e2			cmp 	#$E2
.266b	90 25		bcc $2692			bcc 	_UANoFixup
.266d	8a		txa				txa 									; value in +1
.266e	a8		tay				tay
.266f	c8		iny				iny
.2670	20 18 28	jsr $2818			jsr 	CopyFloatXY
.2673	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.2675	20 36 26	jsr $2636			jsr 	FloatSetByte
.2678	e8		inx				inx
.2679	20 7d 21	jsr $217d			jsr 	FloatDivide
.267c	b0 21		bcs $269f			bcs 	_FATError
.267e	20 a2 26	jsr $26a2			jsr 	CoreAtn 						; calculate the root
.2681	20 0d 28	jsr $280d			jsr 	CompletePolynomial
.2684	20 f6 25	jsr $25f6			jsr 	FloatNegate 					; make -ve
.2687	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2689	20 64 28	jsr $2864			jsr 	LoadConstant
.268c	e8		inx				inx
.268d	20 58 20	jsr $2058			jsr 	FloatAdd
.2690	80 06		bra $2698			bra 	_UAComplete
.2692					_UANoFixup:
.2692	20 a2 26	jsr $26a2			jsr 	CoreAtn
.2695	20 0d 28	jsr $280d			jsr 	CompletePolynomial
.2698					_UAComplete:
.2698	68		pla				pla 									; apply the result.
.2699	55 32		eor $32,x			eor 	NSStatus,x
.269b	95 32		sta $32,x			sta 	NSStatus,x
.269d	18		clc				clc
.269e	60		rts				rts
.269f					_FATError:
.269f	68		pla				pla
.26a0	38		sec				sec
.26a1	60		rts				rts
.26a2					CoreAtn:
.26a2	a9 10		lda #$10			lda 	#AtnCoefficients & $FF
.26a4	a0 27		ldy #$27			ldy 	#AtnCoefficients >> 8
.26a6	4c 61 29	jmp $2961			jmp 	CorePolySquared
.26a9					ExpCoefficients:
>26a9	07					.byte	7
>26aa	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>26ae	d2					.byte	$d2
>26af	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>26b3	d5					.byte	$d5
>26b4	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>26b8	d8					.byte	$d8
>26b9	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>26bd	db					.byte	$db
>26be	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>26c2	dd					.byte	$dd
>26c3	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>26c7	df					.byte	$df
>26c8	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>26cc	e1					.byte	$e1
>26cd	00 00 00 40				.dword	$40000000 ; 1.0
>26d1	e2					.byte	$e2
.26d2					SinCoefficients:
>26d2	06					.byte	6
>26d3	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>26d7	e5					.byte	$e5
>26d8	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>26dc	e7					.byte	$e7
>26dd	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>26e1	e8					.byte	$e8
>26e2	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>26e6	e8					.byte	$e8
>26e7	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>26eb	e7					.byte	$e7
>26ec	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>26f0	e4					.byte	$e4
>26f1	00 00 00 00				.dword	$00000000 ; 0.0
>26f5	00					.byte	$00
.26f6					LogCoefficients:
>26f6	04					.byte	4
>26f7	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>26fb	e0					.byte	$e0
>26fc	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>2700	e1					.byte	$e1
>2701	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>2705	e1					.byte	$e1
>2706	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>270a	e3					.byte	$e3
>270b	00 00 00 c0				.dword	$c0000000 ; -0.5
>270f	e1					.byte	$e1
.2710					AtnCoefficients:
>2710	0c					.byte	12
>2711	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2715	d7					.byte	$d7
>2716	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>271a	da					.byte	$da
>271b	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>271f	dc					.byte	$dc
>2720	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2724	dd					.byte	$dd
>2725	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>2729	dd					.byte	$dd
>272a	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>272e	de					.byte	$de
>272f	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2733	de					.byte	$de
>2734	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>2738	de					.byte	$de
>2739	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>273d	df					.byte	$df
>273e	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>2742	df					.byte	$df
>2743	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>2747	e0					.byte	$e0
>2748	00 00 00 40				.dword	$40000000 ; 1.0
>274c	e2					.byte	$e2
>274d	00 00 00 00				.dword	$00000000 ; 0.0
>2751	00					.byte	$00
.2752					Const_Base:
.2752					Const_1Div2Pi:
>2752	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>2756	df					.byte	$df
.2757					Const_PiDiv2:
>2757	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>275b	e2					.byte	$e2
.275c					Const_Log2_e:
>275c	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>2760	e2					.byte	$e2
.2761					Const_sqrt_2:
>2761	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>2765	e2					.byte	$e2
.2766					Const_sqrt_half:
>2766	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>276a	e1					.byte	$e1
.276b					Const_pi:
>276b	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>276f	e3					.byte	$e3
.2770					Const_half:
>2770	00 00 00 40				.dword	$40000000 ; 0.50000000
>2774	e1					.byte	$e1
.2775					Const_ln_e:
>2775	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>2779	e1					.byte	$e1
.277a					FloatCosine:
.277a	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.277c	20 64 28	jsr $2864			jsr 	LoadConstant
.277f	e8		inx				inx
.2780	20 58 20	jsr $2058			jsr 	FloatAdd
.2783	4c 1a 29	jmp $291a			jmp 	FloatSine
.2786					FloatExponent:
.2786	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.2788	20 64 28	jsr $2864			jsr 	LoadConstant
.278b	e8		inx				inx
.278c	20 f4 22	jsr $22f4			jsr 	FloatMultiply
.278f	20 d1 27	jsr $27d1			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.2792	e8		inx				inx
.2793	20 6f 22	jsr $226f			jsr 	FloatIntegerPart
.2796	ca		dex				dex
.2797	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2799	15 57		ora $57,x			ora 	NSMantissa2+1,x
.279b	15 63		ora $63,x			ora 	NSMantissa3+1,x
.279d	d0 38		bne $27d7			bne 	_UERangeError
.279f	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.27a1	c9 40		cmp #$40			cmp 	#64
.27a3	b0 32		bcs $27d7			bcs 	_UERangeError
.27a5	48		pha				pha
.27a6	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.27a8	48		pha				pha
.27a9	20 14 22	jsr $2214			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.27ac	68		pla				pla
.27ad	10 14		bpl $27c3			bpl 	_UEPositive
.27af	e8		inx				inx 							; 1-x
.27b0	a9 01		lda #$01			lda 	#1
.27b2	20 36 26	jsr $2636			jsr 	FloatSetByte
.27b5	ca		dex				dex
.27b6	20 f6 25	jsr $25f6			jsr 	FloatNegate
.27b9	e8		inx				inx
.27ba	20 58 20	jsr $2058			jsr 	FloatAdd
.27bd	68		pla				pla 							; integer part +1 and negated.
.27be	1a		inc a				inc 	a
.27bf	49 ff		eor #$ff			eor 	#$FF
.27c1	1a		inc a				inc 	a
.27c2	48		pha				pha
.27c3					_UEPositive:
.27c3	20 d9 27	jsr $27d9			jsr 	CoreExponent
.27c6	20 0d 28	jsr $280d			jsr 	CompletePolynomial
.27c9	68		pla				pla
.27ca	18		clc				clc
.27cb	75 6e		adc $6e,x			adc 	NSExponent,x
.27cd	95 6e		sta $6e,x			sta 	NSExponent,x
.27cf	18		clc				clc
.27d0	60		rts				rts
.27d1					_UECopy01:
.27d1	8a		txa				txa
.27d2	a8		tay				tay
.27d3	c8		iny				iny
.27d4	4c 18 28	jmp $2818			jmp 	CopyFloatXY
.27d7					_UERangeError:
.27d7	38		sec				sec
.27d8	60		rts				rts
.27d9					CoreExponent:
.27d9	a9 a9		lda #$a9			lda 	#ExpCoefficients & $FF
.27db	a0 26		ldy #$26			ldy 	#ExpCoefficients >> 8
.27dd	20 e1 27	jsr $27e1			jsr 	CalculateHornerPolynomial
.27e0	60		rts				rts
.27e1					CalculateHornerPolynomial:
.27e1	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.27e3	84 2d		sty $2d				sty 	zTemp0+1
.27e5	9c b6 05	stz $05b6			stz 	coefficientCount 			; zero the count.
.27e8	8e b7 05	stx $05b7			stx 	xValueSlot 					; save xValue slot.
.27eb	e8		inx				inx 								; set the count to zero.
.27ec	20 34 26	jsr $2634			jsr 	FloatSetZero
.27ef					_CHPLoop:
.27ef	8a		txa				txa 								; copy X-1 to X+1
.27f0	a8		tay				tay
.27f1	ca		dex				dex
.27f2	c8		iny				iny
.27f3	20 18 28	jsr $2818			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.27f6	e8		inx				inx
.27f7	e8		inx				inx
.27f8	20 f4 22	jsr $22f4			jsr 	FloatMultiply 				; times current by X
.27fb	e8		inx				inx
.27fc	20 37 28	jsr $2837			jsr 	GetCoefficient 				; coefficient into X+1
.27ff	20 58 20	jsr $2058			jsr 	FloatAdd 					; and add
.2802	ee b6 05	inc $05b6			inc 	coefficientCount
.2805	ad b6 05	lda $05b6			lda 	coefficientCount
.2808	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.280a	d0 e3		bne $27ef			bne 	_CHPLoop
.280c	60		rts				rts
.280d					CompletePolynomial:
.280d	20 f4 22	jsr $22f4			jsr 	FloatMultiply
.2810	e8		inx				inx 								; get the last value
.2811	20 37 28	jsr $2837			jsr 	GetCoefficient
.2814	20 58 20	jsr $2058			jsr 	FloatAdd 					; and add it
.2817	60		rts				rts
.2818					CopyFloatXY:
.2818	b5 6e		lda $6e,x			lda 	NSExponent,x
.281a	99 6e 00	sta $006e,y			sta 	NSExponent,y
.281d	b5 32		lda $32,x			lda 	NSStatus,x
.281f	99 32 00	sta $0032,y			sta 	NSStatus,y
.2822	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2824	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.2827	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2829	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.282c	b5 56		lda $56,x			lda 	NSMantissa2,x
.282e	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.2831	b5 62		lda $62,x			lda 	NSMantissa3,x
.2833	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.2836	60		rts				rts
.2837					GetCoefficient:
.2837	5a		phy				phy
.2838	ad b6 05	lda $05b6			lda 	coefficientCount 			; 5 per block
.283b	0a		asl a				asl 	a
.283c	0a		asl a				asl 	a
.283d	38		sec				sec 								; +1 for count
.283e	6d b6 05	adc $05b6			adc 	coefficientCount
.2841	a8		tay				tay
.2842	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.2844	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2846	c8		iny				iny
.2847	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2849	95 4a		sta $4a,x			sta 	NSMantissa1,x
.284b	c8		iny				iny
.284c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.284e	95 56		sta $56,x			sta 	NSMantissa2,x
.2850	c8		iny				iny
.2851	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2853	48		pha				pha
.2854	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.2856	95 62		sta $62,x			sta 	NSMantissa3,x
.2858	c8		iny				iny
.2859	68		pla				pla
.285a	29 80		and #$80			and 	#$80
.285c	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.285e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2860	95 6e		sta $6e,x			sta 	NSExponent,x
.2862	7a		ply				ply
.2863	60		rts				rts
.05b6					coefficientCount:
>05b6							.fill 	1
.05b7					xValueSlot:
>05b7							.fill 	1
.2864					LoadConstant:
.2864	5a		phy				phy
.2865	a8		tay				tay
.2866	b9 52 27	lda $2752,y			lda 	Const_Base+0,y
.2869	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.286b	b9 53 27	lda $2753,y			lda 	Const_Base+1,y
.286e	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.2870	b9 54 27	lda $2754,y			lda 	Const_Base+2,y
.2873	95 57		sta $57,x			sta 	NSMantissa2+1,x
.2875	b9 55 27	lda $2755,y			lda 	Const_Base+3,y
.2878	48		pha				pha
.2879	29 7f		and #$7f			and 	#$7F
.287b	95 63		sta $63,x			sta 	NSMantissa3+1,x
.287d	68		pla				pla
.287e	29 80		and #$80			and 	#$80
.2880	95 33		sta $33,x			sta 	NSStatus+1,x
.2882	b9 56 27	lda $2756,y			lda 	Const_Base+4,y
.2885	95 6f		sta $6f,x			sta 	NSExponent+1,x
.2887	7a		ply				ply
.2888	60		rts				rts
.2889					FloatLogarithm:
.2889	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.288b	30 5f		bmi $28ec			bmi 	_ULRange
.288d	20 56 26	jsr $2656			jsr 	FloatIsZero
.2890	f0 5a		beq $28ec			beq 	_ULRange
.2892	20 89 23	jsr $2389			jsr 	FloatNormalise 				; put into FP mode.
.2895	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.2897	48		pha				pha
.2898	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.289a	95 6e		sta $6e,x			sta 	NSExponent,x
.289c	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.289e	20 64 28	jsr $2864			jsr 	LoadConstant
.28a1	e8		inx				inx
.28a2	20 58 20	jsr $2058			jsr 	FloatAdd
.28a5	8a		txa				txa 								; divide into sqrt 2.0
.28a6	a8		tay				tay
.28a7	c8		iny				iny
.28a8	20 18 28	jsr $2818			jsr 	CopyFloatXY
.28ab	ca		dex				dex
.28ac	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.28ae	20 64 28	jsr $2864			jsr 	LoadConstant
.28b1	e8		inx				inx
.28b2	e8		inx				inx
.28b3	20 7d 21	jsr $217d			jsr 	FloatDivide 				; if zero, error.
.28b6	b0 33		bcs $28eb			bcs 	_ULRangePla
.28b8	20 f6 25	jsr $25f6			jsr 	FloatNegate 				; subtract from 1
.28bb	e8		inx				inx
.28bc	a9 01		lda #$01			lda 	#1
.28be	20 36 26	jsr $2636			jsr 	FloatSetByte
.28c1	20 58 20	jsr $2058			jsr 	FloatAdd
.28c4	20 ee 28	jsr $28ee			jsr 	CoreLog
.28c7	20 0d 28	jsr $280d			jsr 	CompletePolynomial
.28ca	68		pla				pla 								; add exponent
.28cb	18		clc				clc
.28cc	69 1f		adc #$1f			adc 	#31 						; fix up
.28ce	48		pha				pha
.28cf	10 03		bpl $28d4			bpl 	_LogNotNeg
.28d1	49 ff		eor #$ff			eor 	#$FF
.28d3	1a		inc a				inc 	a
.28d4					_LogNotNeg:
.28d4	e8		inx				inx 								; set byte and sign.
.28d5	20 36 26	jsr $2636			jsr 	FloatSetByte
.28d8	68		pla				pla
.28d9	29 80		and #$80			and 	#$80
.28db	95 32		sta $32,x			sta 	NSStatus,x
.28dd	20 58 20	jsr $2058			jsr 	FloatAdd
.28e0	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.28e2	20 64 28	jsr $2864			jsr 	LoadConstant
.28e5	e8		inx				inx
.28e6	20 f4 22	jsr $22f4			jsr 	FloatMultiply
.28e9	18		clc				clc
.28ea	60		rts				rts
.28eb					_ULRangePla:
.28eb	68		pla				pla
.28ec					_ULRange:
.28ec	38		sec				sec
.28ed	60		rts				rts
.28ee					CoreLog:
.28ee	a9 f6		lda #$f6			lda 	#LogCoefficients & $FF
.28f0	a0 26		ldy #$26			ldy 	#LogCoefficients >> 8
.28f2	4c 61 29	jmp $2961			jmp 	CorePolySquared
.28f5					FloatPI:
.28f5	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.28f7	20 64 28	jsr $2864			jsr 	LoadConstant
.28fa	e8		inx				inx
.28fb	18		clc				clc
.28fc	60		rts				rts
.28fd					FloatPower:
.28fd	ca		dex				dex
.28fe	8a		txa				txa 							; copy 0 to 2, so we can process it
.28ff	a8		tay				tay
.2900	c8		iny				iny
.2901	c8		iny				iny
.2902	20 18 28	jsr $2818			jsr 	CopyFloatXY
.2905	e8		inx				inx 							; 2 = Log(0)
.2906	e8		inx				inx
.2907	20 89 28	jsr $2889			jsr 	FloatLogarithm
.290a	b0 0d		bcs $2919			bcs 	_FPWExit
.290c	20 f4 22	jsr $22f4			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.290f	8a		txa				txa 							; copy to slot 0
.2910	a8		tay				tay
.2911	88		dey				dey
.2912	20 18 28	jsr $2818			jsr 	CopyFloatXY
.2915	ca		dex				dex  							; Exponent code.
.2916	20 86 27	jsr $2786			jsr 	FloatExponent
.2919					_FPWExit:
.2919	60		rts				rts
.291a					FloatSine:
.291a	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.291c	48		pha				pha
.291d	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.291f	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.2921	20 64 28	jsr $2864			jsr 	LoadConstant
.2924	e8		inx				inx
.2925	20 f4 22	jsr $22f4			jsr 	FloatMultiply
.2928	20 14 22	jsr $2214			jsr 	FloatFractionalPart 		; take the fractional part
.292b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.292d	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.292f	90 1f		bcc $2950			bcc 	_USProcessExit
.2931	f0 06		beq $2939			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.2933	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.2935	c9 60		cmp #$60			cmp 	#$60
.2937	b0 0e		bcs $2947			bcs 	_USSubtractOne
.2939					_USSubtractFromHalf:
.2939	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.293b	20 64 28	jsr $2864			jsr 	LoadConstant
.293e	e8		inx				inx
.293f	20 52 20	jsr $2052			jsr 	FloatSubtract
.2942	20 f6 25	jsr $25f6			jsr 	FloatNegate 				; then negate it
.2945	80 09		bra $2950			bra 	_USProcessExit 				; and exit
.2947					_USSubtractOne:
.2947	e8		inx				inx
.2948	a9 01		lda #$01			lda 	#1
.294a	20 36 26	jsr $2636			jsr 	FloatSetByte
.294d	20 52 20	jsr $2052			jsr 	FloatSubtract
.2950					_USProcessExit:
.2950	20 5d 29	jsr $295d			jsr 	CoreSine
.2953	20 0d 28	jsr $280d			jsr 	CompletePolynomial
.2956	68		pla				pla 								; restore sign and apply
.2957	55 32		eor $32,x			eor 	NSStatus,x
.2959	95 32		sta $32,x			sta 	NSStatus,x
.295b	18		clc				clc
.295c	60		rts				rts
.295d					CoreSine:
.295d	a9 d2		lda #$d2			lda 	#SinCoefficients & $FF
.295f	a0 26		ldy #$26			ldy 	#SinCoefficients >> 8
.2961					CorePolySquared:
.2961	48		pha				pha 								; save coefficient table
.2962	5a		phy				phy
.2963	8a		txa				txa 								; copy X to +1, +2
.2964	a8		tay				tay
.2965	c8		iny				iny
.2966	20 18 28	jsr $2818			jsr 	CopyFloatXY
.2969	c8		iny				iny
.296a	20 18 28	jsr $2818			jsr 	CopyFloatXY
.296d	e8		inx				inx 								; point to the pair and put x^2 on stack
.296e	e8		inx				inx
.296f	20 f4 22	jsr $22f4			jsr 	FloatMultiply
.2972	7a		ply				ply 								; coefficient table back.
.2973	68		pla				pla
.2974	20 e1 27	jsr $27e1			jsr 	CalculateHornerPolynomial
.2977	8a		txa				txa 								; copy back to slot #1
.2978	a8		tay				tay
.2979	88		dey				dey
.297a	20 18 28	jsr $2818			jsr	 	CopyFloatXY
.297d	ca		dex				dex 								; point at result
.297e	60		rts				rts
.297f					FloatSquareRoot:
.297f	20 89 28	jsr $2889			jsr 	FloatLogarithm
.2982	b0 06		bcs $298a			bcs 	_FSQExit
.2984	d6 6e		dec $6e,x			dec 	NSExponent,x
.2986	20 86 27	jsr $2786			jsr 	FloatExponent
.2989	18		clc				clc
.298a					_FSQExit:
.298a	60		rts				rts
.298b					FloatTangent:
.298b	da		phx				phx
.298c	8a		txa				txa 								; sin -> +1
.298d	a8		tay				tay
.298e	c8		iny				iny
.298f	20 18 28	jsr $2818			jsr 	CopyFloatXY
.2992	e8		inx				inx
.2993	20 1a 29	jsr $291a			jsr 	FloatSine
.2996	ca		dex				dex
.2997	8a		txa				txa 								; cos -> +2
.2998	a8		tay				tay
.2999	c8		iny				iny
.299a	c8		iny				iny
.299b	20 18 28	jsr $2818			jsr 	CopyFloatXY
.299e	e8		inx				inx
.299f	e8		inx				inx
.29a0	20 7a 27	jsr $277a			jsr 	FloatCosine
.29a3	20 7d 21	jsr $217d			jsr 	FloatDivide 				; calculate sin/cos
.29a6	b0 07		bcs $29af			bcs 	_FTExit 					; divide by zero
.29a8	8a		txa				txa 								; copy result down.
.29a9	a8		tay				tay
.29aa	88		dey				dey
.29ab	20 18 28	jsr $2818			jsr 	CopyFloatXY
.29ae	18		clc				clc
.29af					_FTExit:
.29af	fa		plx				plx
.29b0	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.007a					srcPtr:
>007a							.fill 	2
.05b8					currentLineNumber:
>05b8							.fill 	2
.29b1					InlineNonDecimal:
.29b1	a2 02		ldx #$02			ldx 	#2 							; get size in X
.29b3	c9 25		cmp #$25			cmp 	#"%"
.29b5	f0 02		beq $29b9			beq 	_INDBinary
.29b7	a2 10		ldx #$10			ldx 	#16
.29b9					_INDBinary:
.29b9	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.29bb	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.29bd	64 2c		stz $2c				stz 	zTemp0 						; zero result
.29bf	64 2d		stz $2d				stz 	zTemp0+1
.29c1					_INDLoop:
.29c1	20 5d 33	jsr $335d			jsr 	LookNext 					; check next character
.29c4	20 99 33	jsr $3399			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.29c7	90 1f		bcc $29e8			bcc		_INDDone 					; didn't convert
.29c9	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.29cb	b0 1b		bcs $29e8			bcs 	_INDDone
.29cd	20 f7 29	jsr $29f7			jsr 	_INDShift 					; x 2 or x 16
.29d0	e0 02		cpx #$02			cpx 	#2
.29d2	f0 09		beq $29dd			beq 	_INDNotHex
.29d4	20 f7 29	jsr $29f7			jsr 	_INDShift
.29d7	20 f7 29	jsr $29f7			jsr 	_INDShift
.29da	20 f7 29	jsr $29f7			jsr 	_INDShift
.29dd					_INDNotHex:
.29dd	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.29df	85 2c		sta $2c				sta 	zTemp0
.29e1	20 6e 33	jsr $336e			jsr 	GetNext 					; consume
.29e4	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.29e6	80 d9		bra $29c1			bra 	_INDLoop
.29e8					_INDDone:
.29e8	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.29ea	f0 08		beq $29f4			beq 	_INDError
.29ec	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.29ee	a5 2c		lda $2c				lda 	zTemp0
.29f0	20 18 2b	jsr $2b18			jsr 	PushIntegerYA
.29f3	60		rts				rts
.29f4					_INDError:
.29f4	4c ee 1e	jmp $1eee		jmp	ErrorV_syntax
.29f7					_INDShift:
.29f7	06 2c		asl $2c				asl 	zTemp0
.29f9	26 2d		rol $2d				rol 	zTemp0+1
.29fb	60		rts				rts
.29fc					GetLineNumber:
.29fc	ac b9 05	ldy $05b9			ldy 	currentLineNumber+1
.29ff	ad b8 05	lda $05b8			lda 	currentLineNumber
.2a02	60		rts				rts
.2a03					WriteCodeByte:
.2a03	48		pha				pha 								; save on stack
.2a04	da		phx				phx
.2a05	5a		phy				phy
.2a06	aa		tax				tax
.2a07	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.2a09	20 15 2b	jsr $2b15			jsr 	CallAPIHandler
.2a0c	7a		ply				ply 								; restore from stack
.2a0d	fa		plx				plx
.2a0e	68		pla				pla
.2a0f	60		rts				rts
.2a10					PrintCharacter
.2a10	48		pha				pha
.2a11	da		phx				phx
.2a12	5a		phy				phy
.2a13	aa		tax				tax
.2a14	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.2a16	20 15 2b	jsr $2b15			jsr 	CallAPIHandler
.2a19	7a		ply				ply
.2a1a	fa		plx				plx
.2a1b	68		pla				pla
.2a1c	60		rts				rts
.2a1d					ProcessNewLine:
.2a1d	86 2c		stx $2c				stx 	zTemp0 						; save address in zTemp0
.2a1f	84 2d		sty $2d				sty 	zTemp0+1
.2a21	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.2a22	8a		txa				txa
.2a23	69 04		adc #$04			adc 	#4
.2a25	85 7a		sta $7a				sta 	srcPtr
.2a27	98		tya				tya
.2a28	69 00		adc #$00			adc 	#0
.2a2a	85 7b		sta $7b				sta 	srcPtr+1
.2a2c	a0 02		ldy #$02			ldy 	#2							; read and save line number
.2a2e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a30	8d b8 05	sta $05b8			sta 	currentLineNumber
.2a33	c8		iny				iny
.2a34	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a36	8d b9 05	sta $05b9			sta 	currentLineNumber+1
.2a39	60		rts				rts
.2a3a					BufferClear:
.2a3a	9c ba 05	stz $05ba			stz 	bufferSize
.2a3d	60		rts				rts
.2a3e					BufferWrite:
.2a3e	da		phx				phx
.2a3f	ae ba 05	ldx $05ba			ldx 	bufferSize
.2a42	9d bb 05	sta $05bb,x			sta 	dataBuffer,x
.2a45	ee ba 05	inc $05ba			inc 	bufferSize
.2a48	fa		plx				plx
.2a49	60		rts				rts
.2a4a					BufferOutput:
.2a4a	ad ba 05	lda $05ba			lda 	bufferSize
.2a4d	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2a50	a2 00		ldx #$00			ldx 	#0
.2a52					_BOLoop:
.2a52	ec ba 05	cpx $05ba			cpx 	bufferSize
.2a55	f0 09		beq $2a60			beq 	_BOExit
.2a57	bd bb 05	lda $05bb,x			lda 	dataBuffer,x
.2a5a	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2a5d	e8		inx				inx
.2a5e	80 f2		bra $2a52			bra 	_BOLoop
.2a60					_BOExit:
.2a60	60		rts				rts
.05ba					bufferSize:
>05ba							.fill 	1
.05bb					dataBuffer:
>05bb							.fill 	256
.2a61					CheckNextComma:
.2a61	a9 2c		lda #$2c			lda	 	#","
.2a63	80 06		bra $2a6b			bra 	CheckNextA
.2a65					CheckNextRParen:
.2a65	a9 29		lda #$29			lda	 	#")"
.2a67	80 02		bra $2a6b			bra 	CheckNextA
.2a69					CheckNextLParen:
.2a69	a9 28		lda #$28			lda 	#"("
.2a6b					CheckNextA:
.2a6b	8d bb 06	sta $06bb			sta 	checkCharacter 				; save test character
.2a6e					_CNALoop:
.2a6e	20 79 33	jsr $3379			jsr 	GetNextNonSpace 			; get next skipping spaces.
.2a71	cd bb 06	cmp $06bb			cmp 	checkCharacter 				; matches ?
.2a74	f0 03		beq $2a79			beq 	_CNAExit
.2a76	4c ee 1e	jmp $1eee		jmp	ErrorV_syntax
.2a79					_CNAExit:
.2a79	60		rts				rts
.06bb					checkCharacter:
>06bb							.fill 	1
.2a7a					StartCompiler:
.2a7a	86 2c		stx $2c				stx 	zTemp0 						; access API
.2a7c	84 2d		sty $2d				sty 	zTemp0+1
.2a7e	a0 2c		ldy #$2c			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.2a80	a2 d1		ldx #$d1			ldx 	#CompilerErrorHandler & $FF
.2a82	20 c7 1e	jsr $1ec7			jsr 	SetErrorHandler
.2a85	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.2a87	b2 2c		lda ($2c)			lda 	(zTemp0)
.2a89	8d bd 06	sta $06bd			sta 	APIVector
.2a8c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a8e	8d be 06	sta $06be			sta 	APIVector+1
.2a91	c8		iny				iny 								; copy data area range.
.2a92	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a94	8d bf 06	sta $06bf			sta 	compilerStartHigh
.2a97	c8		iny				iny
.2a98	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a9a	8d c0 06	sta $06c0			sta 	compilerEndHigh
.2a9d	ba		tsx				tsx 								; save stack pointer
.2a9e	8e bc 06	stx $06bc			stx 	compilerSP
.2aa1	20 fd 36	jsr $36fd			jsr 	STRReset 					; reset storage (line#, variable)
.2aa4	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.2aa6	20 15 2b	jsr $2b15			jsr 	CallAPIHandler
.2aa9	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.2aab	20 15 2b	jsr $2b15			jsr 	CallAPIHandler
.2aae	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.2ab0	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2ab3	a9 00		lda #$00			lda 	#0
.2ab5	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2ab8	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2abb					MainCompileLoop:
.2abb	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.2abd	20 15 2b	jsr $2b15			jsr 	CallAPIHandler
.2ac0	90 31		bcc $2af3			bcc 	SaveCodeAndExit 			; end of source.
.2ac2	20 1d 2a	jsr $2a1d			jsr 	ProcessNewLine 				; set up pointer and line number.
.2ac5	20 fc 29	jsr $29fc			jsr 	GetLineNumber 				; get line #
.2ac8	20 e7 34	jsr $34e7			jsr 	STRMarkLine 				; remember the code position and number of this line.
.2acb	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.2acd	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2ad0					_MCLSameLine:
.2ad0	20 79 33	jsr $3379			jsr 	GetNextNonSpace 			; get the first character.
.2ad3	f0 e6		beq $2abb			beq 	MainCompileLoop 			; end of line, get next line.
.2ad5	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.2ad7	f0 f7		beq $2ad0			beq 	_MCLSameLine
.2ad9	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.2adb	10 0c		bpl $2ae9			bpl 	_MCLCheckAssignment
.2add	a2 37		ldx #$37			ldx 	#CommandTables & $FF 		; do command tables.
.2adf	a0 2f		ldy #$2f			ldy 	#CommandTables >> 8
.2ae1	20 ff 31	jsr $31ff			jsr 	GeneratorProcess
.2ae4	b0 ea		bcs $2ad0			bcs 	_MCLSameLine 				; keep trying to compile the line.
.2ae6					_MCLSyntax:
.2ae6	4c ee 1e	jmp $1eee		jmp	ErrorV_syntax
.2ae9					_MCLCheckAssignment:
.2ae9	20 8f 33	jsr $338f			jsr 	CharIsAlpha 				; if not alpha then syntax error
.2aec	90 f8		bcc $2ae6			bcc 	_MCLSyntax
.2aee	20 b5 34	jsr $34b5			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.2af1	80 dd		bra $2ad0			bra		_MCLSameLine 				; loop back.
.2af3					SaveCodeAndExit:
.2af3	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.2af5	20 15 2b	jsr $2b15			jsr 	CallAPIHandler
.2af8	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.2afa	a8		tay				tay
.2afb	20 e7 34	jsr $34e7			jsr 	STRMarkLine
.2afe	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.2b00	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2b03	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.2b05	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2b08	20 2f 2e	jsr $2e2f			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.2b0b	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.2b0d	20 15 2b	jsr $2b15			jsr 	CallAPIHandler
.2b10					ExitCompiler:
.2b10	ae bc 06	ldx $06bc			ldx 	compilerSP 					; reload SP and exit.
.2b13	9a		txs				txs
.2b14	60		rts				rts
.2b15					CallAPIHandler:
.2b15	6c bd 06	jmp ($06bd)			jmp 	(APIVector)
.06bc					compilerSP:
>06bc							.fill 	1
.06bd					APIVector:
>06bd							.fill 	2
.06bf					compilerStartHigh:
>06bf							.fill 	1
.06c0					compilerEndHigh:
>06c0							.fill 	1
.2b18					PushIntegerYA:
.2b18	c0 00		cpy #$00			cpy 	#0 							; 0-255
.2b1a	f0 0f		beq $2b2b			beq 	PushIntegerA
.2b1c	48		pha				pha
.2b1d	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.2b1f	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2b22	68		pla				pla 								; then LSB
.2b23	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2b26	98		tya				tya 								; then MSB
.2b27	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2b2a	60		rts				rts
.2b2b					PushIntegerA:
.2b2b	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.2b2d	90 07		bcc $2b36			bcc 	_PIWriteA
.2b2f	48		pha				pha
.2b30	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.2b32	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2b35	68		pla				pla
.2b36					_PIWriteA:
.2b36	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2b39	60		rts				rts
.2b3a					PushFloatCommand:
.2b3a	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.2b3c	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2b3f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.2b41	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2b44	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2b46	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2b49	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2b4b	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2b4e	b5 56		lda $56,x			lda 	NSMantissa2,x
.2b50	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2b53	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.2b55	29 80		and #$80			and 	#$80
.2b57	15 62		ora $62,x			ora 	NSMantissa3,x
.2b59	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2b5c	60		rts				rts
.2b5d					CreateVariableRecord:
.2b5d	48		pha				pha
.2b5e	ad cb 06	lda $06cb			lda 	freeVariableMemory 		; push current free address on stack.
.2b61	48		pha				pha
.2b62	ad cc 06	lda $06cc			lda 	freeVariableMemory+1
.2b65	48		pha				pha
.2b66	ad c9 06	lda $06c9			lda 	variableListEnd  		; copy end of list to zTemp0
.2b69	85 2c		sta $2c				sta 	zTemp0
.2b6b	ad ca 06	lda $06ca			lda 	variableListEnd+1
.2b6e	85 2d		sta $2d				sta 	zTemp0+1
.2b70	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.2b72	92 2c		sta ($2c)			sta 	(zTemp0)
.2b74	98		tya				tya
.2b75	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.2b77	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b79	88		dey				dey
.2b7a	8a		txa				txa
.2b7b	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b7d	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.2b7f	ad cb 06	lda $06cb			lda 	freeVariableMemory
.2b82	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b84	c8		iny				iny
.2b85	ad cc 06	lda $06cc			lda 	freeVariableMemory+1
.2b88	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b8a	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.2b8c	a9 00		lda #$00			lda 	#0
.2b8e	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b90	18		clc				clc
.2b91	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.2b93	6d c9 06	adc $06c9			adc  	variableListEnd
.2b96	8d c9 06	sta $06c9			sta 	variableListEnd
.2b99	90 03		bcc $2b9e			bcc 	_CVNoCarry2
.2b9b	ee ca 06	inc $06ca			inc 	variableListEnd+1
.2b9e					_CVNoCarry2:
.2b9e	7a		ply				ply
.2b9f	fa		plx				plx
.2ba0	68		pla				pla
.2ba1	60		rts				rts
.2ba2					SetVariableRecordToCodePosition:
.2ba2	48		pha				pha
.2ba3	5a		phy				phy
.2ba4	a0 03		ldy #$03			ldy 	#3
.2ba6	a5 2b		lda $2b				lda 	objPtr+1
.2ba8	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2baa	c8		iny				iny
.2bab	a5 2a		lda $2a				lda 	objPtr
.2bad	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2baf	7a		ply				ply
.2bb0	68		pla				pla
.2bb1	60		rts				rts
.2bb2					AllocateBytesForType:
.2bb2	48		pha				pha
.2bb3	da		phx				phx
.2bb4	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.2bb6	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2bb8	c9 00		cmp #$00			cmp 	#NSSIFloat
.2bba	d0 02		bne $2bbe			bne 	_CVNotFloat
.2bbc	a2 06		ldx #$06			ldx 	#6
.2bbe					_CVNotFloat:
.2bbe	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.2bbf	18		clc				clc
.2bc0	6d cb 06	adc $06cb			adc 	freeVariableMemory
.2bc3	8d cb 06	sta $06cb			sta 	freeVariableMemory
.2bc6	90 03		bcc $2bcb			bcc 	_CVNoCarry1
.2bc8	ee cc 06	inc $06cc			inc 	freeVariableMemory+1
.2bcb					_CVNoCarry1:
.2bcb	fa		plx				plx
.2bcc	68		pla				pla
.2bcd	60		rts				rts
.2bce					CommandDATA:
.2bce	20 3a 2a	jsr $2a3a			jsr 	BufferClear 				; copy it to the buffer
.2bd1	20 60 33	jsr $3360			jsr 	LookNextNonSpace
.2bd4					_CTDataLoop:
.2bd4	20 5d 33	jsr $335d			jsr 	LookNext 					; reached EOL
.2bd7	f0 08		beq $2be1			beq 	_CTDataDone
.2bd9	20 3e 2a	jsr $2a3e			jsr 	BufferWrite 				; write and consume
.2bdc	20 6e 33	jsr $336e			jsr 	GetNext
.2bdf	80 f3		bra $2bd4			bra 	_CTDataLoop
.2be1					_CTDataDone:
.2be1	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.2be3	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2be6	20 4a 2a	jsr $2a4a			jsr 	BufferOutput
.2be9	60		rts				rts
.2bea					CommandDEF:
.2bea	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.2bec	20 2b 2b	jsr $2b2b			jsr 	PushIntegerA
.2bef	20 7e 34	jsr $347e			jsr 	CompileGotoEOL 				; compile skip over DEF
.2bf2	a9 a5		lda #$a5			lda 	#C64_FN
.2bf4	20 6b 2a	jsr $2a6b			jsr 	CheckNextA
.2bf7	20 79 33	jsr $3379			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2bfa	20 de 33	jsr $33de			jsr 	ExtractVariableName
.2bfd	8a		txa				txa
.2bfe	10 51		bpl $2c51			bpl 	_CDError
.2c00	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2c01	29 7f		and #$7f			and 	#$7F
.2c03	aa		tax				tax
.2c04	98		tya				tya
.2c05	09 80		ora #$80			ora 	#$80
.2c07	a8		tay				tay
.2c08	20 d3 2d	jsr $2dd3			jsr 	FindVariable				; does it already exist ?
.2c0b	b0 44		bcs $2c51			bcs 	_CDError 					; if so, that's an error.
.2c0d	20 5d 2b	jsr $2b5d			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.2c10	20 a2 2b	jsr $2ba2			jsr 	SetVariableRecordToCodePosition
.2c13	20 79 33	jsr $3379			jsr 	GetNextNonSpace
.2c16	20 ba 36	jsr $36ba			jsr 	GetReferenceTerm 			; get var ref, not array
.2c19	c9 00		cmp #$00			cmp 	#0
.2c1b	30 34		bmi $2c51			bmi 	_CDError
.2c1d	8d c1 06	sta $06c1			sta 	defType 					; save type
.2c20	8e c2 06	stx $06c2			stx 	defVariable 				; save var ref
.2c23	8c c3 06	sty $06c3			sty 	defVariable+1
.2c26	29 40		and #$40			and 	#NSSString 					; only numbers.
.2c28	d0 27		bne $2c51			bne 	_CDError
.2c2a	20 65 2a	jsr $2a65			jsr 	CheckNextRParen 			; check )
.2c2d	a9 b2		lda #$b2			lda 	#C64_EQUAL
.2c2f	20 6b 2a	jsr $2a6b			jsr 	CheckNextA 					; check =
.2c32	18		clc				clc 								; if this is DEF FNxx(A), read A
.2c33	20 54 2c	jsr $2c54			jsr 	CDReadWriteVariable
.2c36	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2c38	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2c3b	38		sec				sec
.2c3c	20 54 2c	jsr $2c54			jsr 	CDReadWriteVariable 		; A is now updated
.2c3f	20 19 2d	jsr $2d19			jsr 	CompileExpressionAt0 		; the actual body of the function.
.2c42	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2c44	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2c47	38		sec				sec
.2c48	20 54 2c	jsr $2c54			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.2c4b	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.2c4d	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2c50	60		rts				rts
.2c51					_CDError:
.2c51	4c ee 1e	jmp $1eee		jmp	ErrorV_syntax
.2c54					CDReadWriteVariable:
.2c54	ac c3 06	ldy $06c3			ldy 	defVariable+1 				; set up YX
.2c57	ae c2 06	ldx $06c2			ldx 	defVariable
.2c5a	ad c1 06	lda $06c1			lda 	defType
.2c5d	20 6c 36	jsr $366c			jsr 	GetSetVariable
.2c60	60		rts				rts
.06c1					defType:
>06c1							.fill 	1
.06c2					defVariable:
>06c2							.fill 	2
.2c61					CommandDIM:
.2c61	20 79 33	jsr $3379			jsr 	GetNextNonSpace 			; get the first non space character
.2c64	20 de 33	jsr $33de			jsr 	ExtractVariableName 		; variable name to XY
.2c67	da		phx				phx 								; save name with type bits.
.2c68	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.2c6a	10 37		bpl $2ca3			bpl 	_CDError
.2c6c	20 d3 2d	jsr $2dd3			jsr 	FindVariable	 			; see if already exist
.2c6f	b0 35		bcs $2ca6			bcs 	_CDRedefine 				; it still exists.
.2c71	20 5d 2b	jsr $2b5d			jsr 	CreateVariableRecord 		; create the basic variable
.2c74	20 b2 2b	jsr $2bb2			jsr 	AllocateBytesForType 		; allocate memory for it
.2c77	68		pla				pla 								; restore type bits
.2c78	5a		phy				phy 								; save the address of the basic storage
.2c79	da		phx				phx
.2c7a	48		pha				pha
.2c7b	20 a9 2c	jsr $2ca9			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.2c7e	68		pla				pla
.2c7f	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.2c81	20 2b 2b	jsr $2b2b			jsr 	PushIntegerA 				; push that type data out.
.2c84	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.2c86	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2c89	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.2c8b	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2c8e	fa		plx				plx 								; restore address
.2c8f	7a		ply				ply
.2c90	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2c92	38		sec				sec
.2c93	20 6c 36	jsr $366c			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.2c96	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; , follows ?
.2c99	c9 2c		cmp #$2c			cmp 	#","
.2c9b	d0 05		bne $2ca2			bne 	_CDExit
.2c9d	20 6e 33	jsr $336e			jsr 	GetNext 					; consume comma
.2ca0	80 bf		bra $2c61			bra 	CommandDIM 					; do another DIM
.2ca2					_CDExit:
.2ca2	60		rts				rts
.2ca3					_CDError:
.2ca3	4c ee 1e	jmp $1eee		jmp	ErrorV_syntax
.2ca6					_CDRedefine:
.2ca6	4c b6 1f	jmp $1fb6		jmp	ErrorV_redefine
.2ca9					OutputIndexGroup:
.2ca9	9c c4 06	stz $06c4			stz 	IndexCount 					; count of number of indices.
.2cac					_OIGNext:
.2cac	20 19 2d	jsr $2d19			jsr 	CompileExpressionAt0 		; get a dimension
.2caf	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2cb1	c9 00		cmp #$00			cmp 	#NSSIFloat
.2cb3	d0 19		bne $2cce			bne 	_OIGType
.2cb5	ee c4 06	inc $06c4			inc 	IndexCount 					; bump the counter.
.2cb8	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; does a , follow ?
.2cbb	c9 2c		cmp #$2c			cmp 	#","
.2cbd	d0 05		bne $2cc4			bne 	_OIGCheckEnd
.2cbf	20 6e 33	jsr $336e			jsr 	GetNext 					; consume comma
.2cc2	80 e8		bra $2cac			bra 	_OIGNext 					; get next dimension
.2cc4					_OIGCheckEnd:
.2cc4	20 65 2a	jsr $2a65			jsr 	CheckNextRParen 			; check and consume )
.2cc7	ad c4 06	lda $06c4			lda 	IndexCount
.2cca	20 2b 2b	jsr $2b2b			jsr 	PushIntegerA 				; compile the dimension count.
.2ccd	60		rts				rts
.2cce					_OIGType:
.2cce	4c fe 1e	jmp $1efe		jmp	ErrorV_type
.06c4					IndexCount:
>06c4							.fill 	1
.2cd1					CompilerErrorHandler:
.2cd1	68		pla				pla
.2cd2	7a		ply				ply
.2cd3	85 2c		sta $2c				sta 	zTemp0
.2cd5	84 2d		sty $2d				sty 	zTemp0+1
.2cd7	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.2cd9	a0 01		ldy #$01			ldy 	#1
.2cdb					_EHDisplayMsg:
.2cdb	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2cdd	20 10 2a	jsr $2a10			jsr 	PrintCharacter
.2ce0	c8		iny				iny
.2ce1	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ce3	d0 f6		bne $2cdb			bne 	_EHDisplayMsg
.2ce5	a9 20		lda #$20			lda 	#32
.2ce7	20 10 2a	jsr $2a10			jsr 	PrintCharacter
.2cea	a9 40		lda #$40			lda 	#64
.2cec	20 10 2a	jsr $2a10			jsr 	PrintCharacter
.2cef	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.2cf1	20 36 26	jsr $2636			jsr 	FloatSetByte
.2cf4	20 fc 29	jsr $29fc			jsr 	GetLineNumber
.2cf7	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2cf9	98		tya				tya
.2cfa	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2cfc	20 1c 25	jsr $251c			jsr 	FloatToString
.2cff	a0 00		ldy #$00			ldy 	#0 							; display that string.
.2d01	a2 00		ldx #$00			ldx 	#0
.2d03					_EHDisplayLine:
.2d03	b9 96 05	lda $0596,y			lda 	decimalBuffer,y
.2d06	20 10 2a	jsr $2a10			jsr 	PrintCharacter
.2d09	c8		iny				iny
.2d0a	b9 96 05	lda $0596,y			lda 	decimalBuffer,y
.2d0d	d0 f4		bne $2d03			bne 	_EHDisplayLine
.2d0f	a9 0d		lda #$0d			lda 	#13
.2d11	20 10 2a	jsr $2a10			jsr 	PrintCharacter
.2d14	80 fe		bra $2d14	_EHHalt:bra 	_EHHalt
.2d16	4c 10 2b	jmp $2b10			jmp 	ExitCompiler
.2d19					CompileExpressionAt0:
.2d19	a9 00		lda #$00			lda 	#0
.2d1b					CompileExpressionAtA:
.2d1b	48		pha				pha  								; save level
.2d1c	20 25 37	jsr $3725			jsr 	CompileTerm 				; compile a term.
.2d1f	fa		plx				plx 								; get level back into X
.2d20					_ECALoop:
.2d20	48		pha				pha 								; save type on stack.
.2d21	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; get the next character
.2d24	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.2d26	90 04		bcc $2d2c			bcc 	_ECAExit
.2d28	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.2d2a	90 02		bcc $2d2e			bcc 	_ECAHaveToken
.2d2c					_ECAExit:
.2d2c	68		pla				pla 								; throw type off stack
.2d2d	60		rts				rts
.2d2e					_ECAHaveToken:
.2d2e	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.2d30	aa		tax				tax 								; X contains the operator token
.2d31	bd 1c 2d	lda $2d1c,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.2d34	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.2d36	90 f4		bcc $2d2c			bcc 	_ECAExit
.2d38	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.2d3a	20 6e 33	jsr $336e			jsr 	GetNext 					; consume the token.
.2d3d	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.2d3f	f0 11		beq $2d52			beq 	_ECAGreaterCheck
.2d41	e0 b3		cpx #$b3			cpx 	#C64_LESS
.2d43	d0 1a		bne $2d5f			bne 	_ECAHaveFullToken
.2d45	20 5d 33	jsr $335d			jsr 	LookNext 					; checks for < (<= or <>)
.2d48	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.2d4a	f0 0e		beq $2d5a			beq	 	_ECAToNotEqual
.2d4c	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.2d4e	d0 0f		bne $2d5f			bne 	_ECAHaveFullToken
.2d50	80 07		bra $2d59			bra 	_ECAAddEqual
.2d52					_ECAGreaterCheck:
.2d52	20 5d 33	jsr $335d			jsr 	LookNext
.2d55	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.2d57	d0 06		bne $2d5f			bne 	_ECAHaveFullToken
.2d59					_ECAAddEqual:
.2d59	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.2d5a					_ECAToNotEqual:
.2d5a	e8		inx				inx
.2d5b	e8		inx				inx
.2d5c	20 6e 33	jsr $336e			jsr 	GetNext 					; consume the = or > in >= <= <>
.2d5f					_ECAHaveFullToken:
.2d5f	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.2d61	d0 0a		bne $2d6d			bne 	_ECANotConcat
.2d63	68		pla				pla 								; get type back
.2d64	48		pha				pha
.2d65	29 40		and #$40			and 	#NSSTypeMask
.2d67	c9 40		cmp #$40			cmp 	#NSSString
.2d69	d0 02		bne $2d6d			bne 	_ECANotConcat
.2d6b	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2d6d					_ECANotConcat:
.2d6d	da		phx				phx 								; save operator on the stack
.2d6e	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.2d70	da		phx				phx
.2d71	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.2d73	1a		inc a				inc 	a
.2d74	20 1b 2d	jsr $2d1b			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.2d77	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.2d79	fa		plx				plx 								; restore current precedence in X
.2d7a	68		pla				pla 								; restore operator
.2d7b	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.2d7d	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.2d7f	90 17		bcc $2d98			bcc 	_ECANotCompare
.2d81	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.2d83	b0 13		bcs $2d98			bcs 	_ECANotCompare
.2d85	7a		ply				ply 								; get type into Y
.2d86	5a		phy				phy
.2d87	48		pha				pha 								; save operator
.2d88	98		tya				tya 								; get type
.2d89	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.2d8b	29 40		and #$40			and 	#NSSTypeMask
.2d8d	c9 40		cmp #$40			cmp 	#NSSString
.2d8f	f0 02		beq $2d93			beq 	_ECANotString
.2d91	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.2d93					_ECANotString:
.2d93	98		tya				tya									; output token Y
.2d94	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2d97	68		pla				pla 								; restore operator.
.2d98					_ECANotCompare:
.2d98	18		clc				clc 								; convert to P-Code and compile.
.2d99	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.2d9b	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2d9e	68		pla				pla 								; type of current result
.2d9f	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.2da1	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.2da3	d0 19		bne $2dbe			bne		_ECAType
.2da5	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.2da7	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.2da9	d0 18		bne $2dc3			bne 	_ECAGoLoop
.2dab	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.2dad	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2daf	f0 10		beq $2dc1			beq 	_ECAOkayString 				; (this is post conversion)
.2db1	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.2db3	90 09		bcc $2dbe			bcc 	_ECAType
.2db5	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.2db7	b0 05		bcs $2dbe			bcs 	_ECAType
.2db9	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.2dbb	4c 20 2d	jmp $2d20			jmp 	_ECALoop
.2dbe					_ECAType:
.2dbe	4c fe 1e	jmp $1efe		jmp	ErrorV_type
.2dc1					_ECAOkayString:
.2dc1	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.2dc3					_ECAGoLoop:
.2dc3	4c 20 2d	jmp $2d20			jmp 	_ECALoop
.2dc6					PrecedenceTable:
>2dc6	03						.byte 	3 					; '+'
>2dc7	03						.byte 	3 					; '-'
>2dc8	04						.byte 	4 					; '*'
>2dc9	04						.byte 	4 					; '/'
>2dca	05						.byte 	5 					; '^'
>2dcb	01						.byte 	1 					; 'and'
>2dcc	00						.byte 	0 					; 'or'
>2dcd	02						.byte 	2 					; '>'
>2dce	02						.byte 	2 					; '='
>2dcf	02						.byte 	2 					; '<'
>2dd0	02						.byte 	2 					; '>='
>2dd1	02						.byte 	2 					; '<='
>2dd2	02						.byte 	2 					; '<>'
.2dd3					FindVariable:
.2dd3	86 2e		stx $2e				stx 	zTemp1 						; save name.
.2dd5	84 2f		sty $2f				sty 	zTemp1+1
.2dd7					_IVCheckSpecial:
.2dd7	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.2dd9	d0 18		bne $2df3			bne 	_IVStandard
.2ddb	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.2ddd	f0 0c		beq $2deb			beq 	_IVTIFloat
.2ddf	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.2de1	d0 10		bne $2df3			bne 	_IVStandard
.2de3	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.2de5	a2 01		ldx #$01			ldx 	#$01
.2de7	a9 40		lda #$40			lda 	#NSSString
.2de9	38		sec				sec
.2dea	60		rts				rts
.2deb					_IVTIFloat:
.2deb	a0 80		ldy #$80			ldy 	#$80
.2ded	a2 00		ldx #$00			ldx 	#$00
.2def	a9 00		lda #$00			lda 	#0
.2df1	38		sec				sec
.2df2	60		rts				rts
.2df3					_IVStandard:
.2df3	ad bf 06	lda $06bf			lda 	compilerStartHigh			; start scanning from here.
.2df6	85 2d		sta $2d				sta 	zTemp0+1
.2df8	64 2c		stz $2c				stz 	zTemp0
.2dfa					_IVCheckLoop:
.2dfa	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.2dfc	f0 2b		beq $2e29			beq  	_IVNotFound 				; if so, return with CC.
.2dfe	a0 01		ldy #$01			ldy 	#1 							; match ?
.2e00	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e02	c5 2e		cmp $2e				cmp 	zTemp1
.2e04	d0 07		bne $2e0d			bne	 	_IVNext
.2e06	c8		iny				iny
.2e07	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e09	c5 2f		cmp $2f				cmp 	zTemp1+1
.2e0b	f0 0d		beq $2e1a			beq 	_IVFound
.2e0d					_IVNext:
.2e0d	18		clc				clc
.2e0e	a5 2c		lda $2c				lda 	zTemp0
.2e10	72 2c		adc ($2c)			adc 	(zTemp0)
.2e12	85 2c		sta $2c				sta 	zTemp0
.2e14	90 e4		bcc $2dfa			bcc 	_IVCheckLoop
.2e16	e6 2d		inc $2d				inc 	zTemp0+1
.2e18	80 e0		bra $2dfa			bra 	_IVCheckLoop
.2e1a					_IVFound:
.2e1a	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.2e1c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e1e	aa		tax				tax
.2e1f	c8		iny				iny
.2e20	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e22	48		pha				pha
.2e23	c8		iny				iny
.2e24	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e26	7a		ply				ply
.2e27	38		sec				sec
.2e28	60		rts				rts
.2e29					_IVNotFound:
.2e29	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.2e2b	a4 2f		ldy $2f				ldy 	zTemp1+1
.2e2d	18		clc				clc
.2e2e	60		rts				rts
.2e2f					FixBranches:
.2e2f	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.2e31	20 15 2b	jsr $2b15			jsr 	CallAPIHandler
.2e34					_FBLoop:
.2e34	b2 2a		lda ($2a)			lda 	(objPtr) 					; get the next one.
.2e36	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.2e38	f0 16		beq $2e50			beq 	_FBFixGotoGosub
.2e3a	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.2e3c	f0 12		beq $2e50			beq 	_FBFixGotoGosub
.2e3e	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.2e40	f0 0e		beq $2e50			beq 	_FBFixGotoGosub
.2e42	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.2e44	f0 0a		beq $2e50			beq 	_FBFixGotoGosub
.2e46	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.2e48	f0 3b		beq $2e85			beq 	_FBFixVarSpace
.2e4a					_FBNext:
.2e4a	20 03 20	jsr $2003			jsr 	MoveObjectForward 			; move forward in object code.
.2e4d	90 e5		bcc $2e34			bcc 	_FBLoop 					; not finished
.2e4f					_FBExit:
.2e4f	60		rts				rts
.2e50					_FBFixGotoGosub:
.2e50	a0 01		ldy #$01			ldy 	#1							; line number in YA
.2e52	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e54	48		pha				pha
.2e55	c8		iny				iny
.2e56	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e58	a8		tay				tay
.2e59	68		pla				pla
.2e5a	20 10 35	jsr $3510			jsr 	STRFindLine			 		; find where it is YA
.2e5d	90 08		bcc $2e67			bcc 	_FBFFound 					; not found, so must be >
.2e5f	48		pha				pha
.2e60	b2 2a		lda ($2a)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.2e62	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.2e64	d0 0f		bne $2e75			bne 	_FBFFail
.2e66	68		pla				pla
.2e67					_FBFFound:
.2e67	20 60 35	jsr $3560			jsr 	STRMakeOffset 				; make it an offset from X:YA
.2e6a	5a		phy				phy	 								; patch the GOTO/GOSUB
.2e6b	a0 01		ldy #$01			ldy 	#1
.2e6d	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e6f	c8		iny				iny
.2e70	68		pla				pla
.2e71	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e73	80 d5		bra $2e4a			bra 	_FBNext
.2e75					_FBFFail:
.2e75	a0 02		ldy #$02			ldy 	#2
.2e77	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e79	8d b8 05	sta $05b8			sta 	currentLineNumber
.2e7c	c8		iny				iny
.2e7d	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e7f	8d b9 05	sta $05b9			sta 	currentLineNumber+1
.2e82	4c 31 1f	jmp $1f31		jmp	ErrorV_line
.2e85					_FBFixVarSpace:
.2e85	a0 01		ldy #$01			ldy 	#1
.2e87	ad cb 06	lda $06cb			lda 	freeVariableMemory
.2e8a	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e8c	c8		iny				iny
.2e8d	ad cc 06	lda $06cc			lda 	freeVariableMemory+1
.2e90	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e92	80 b6		bra $2e4a			bra 	_FBNext
.2e94					CommandFOR:
.2e94	20 79 33	jsr $3379			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.2e97	20 8f 33	jsr $338f			jsr 	CharIsAlpha 				; if not alpha , error
.2e9a	90 59		bcc $2ef5			bcc 	_CFFail
.2e9c	20 ba 36	jsr $36ba			jsr 	GetReferenceTerm 			; figure out the reference.
.2e9f	48		pha				pha 								; save type
.2ea0	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ea2	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ea4	d0 4f		bne $2ef5			bne 	_CFFail
.2ea6	5a		phy				phy 								; save reference on the stack
.2ea7	da		phx				phx
.2ea8	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.2eaa	20 6b 2a	jsr $2a6b			jsr 	CheckNextA
.2ead	20 19 2d	jsr $2d19			jsr 	CompileExpressionAt0 		; initial value
.2eb0	fa		plx				plx 								; get reference back.
.2eb1	7a		ply				ply
.2eb2	5a		phy				phy
.2eb3	da		phx				phx
.2eb4	38		sec				sec 								; set initial value.
.2eb5	20 6c 36	jsr $366c			jsr 	GetSetVariable
.2eb8	fa		plx				plx
.2eb9	7a		ply				ply
.2eba	68		pla				pla
.2ebb	29 20		and #$20			and 	#NSSIInt16
.2ebd	f0 04		beq $2ec3			beq 	_CFNotInt16
.2ebf	98		tya				tya
.2ec0	09 80		ora #$80			ora 	#$80
.2ec2	a8		tay				tay
.2ec3					_CFNotInt16:
.2ec3	8a		txa				txa 								; reference in YA
.2ec4	20 18 2b	jsr $2b18			jsr 	PushIntegerYA
.2ec7	a9 a4		lda #$a4			lda 	#C64_TO
.2ec9	20 6b 2a	jsr $2a6b			jsr 	CheckNextA
.2ecc	20 19 2d	jsr $2d19			jsr 	CompileExpressionAt0 		; terminal value
.2ecf	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ed1	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ed3	d0 20		bne $2ef5			bne 	_CFFail
.2ed5	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; followed by STEP
.2ed8	c9 a9		cmp #$a9			cmp 	#C64_STEP
.2eda	d0 0e		bne $2eea			bne 	_CFNoStep
.2edc	20 6e 33	jsr $336e			jsr 	GetNext 					; consume it.
.2edf	20 19 2d	jsr $2d19			jsr 	CompileExpressionAt0 		; terminal value
.2ee2	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ee4	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ee6	d0 0d		bne $2ef5			bne 	_CFFail
.2ee8	80 05		bra $2eef			bra 	_CFParametersDone
.2eea					_CFNoStep:
.2eea	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.2eec	20 2b 2b	jsr $2b2b			jsr 	PushIntegerA
.2eef					_CFParametersDone:
.2eef	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2ef1	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2ef4	60		rts				rts
.2ef5					_CFFail:
.2ef5	4c ee 1e	jmp $1eee		jmp	ErrorV_syntax
.2ef8					FNCompile:
.2ef8	20 79 33	jsr $3379			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2efb	20 de 33	jsr $33de			jsr 	ExtractVariableName
.2efe	e0 00		cpx #$00			cpx 	#0
.2f00	10 32		bpl $2f34			bpl 	_FNError
.2f02	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2f03	29 7f		and #$7f			and 	#$7F
.2f05	aa		tax				tax
.2f06	98		tya				tya
.2f07	09 80		ora #$80			ora 	#$80
.2f09	a8		tay				tay
.2f0a	20 d3 2d	jsr $2dd3			jsr 	FindVariable				; does it already exist ?
.2f0d	90 25		bcc $2f34			bcc 	_FNError 					; no.
.2f0f	20 60 35	jsr $3560			jsr 	STRMakeOffset 				; convert to a relative address.
.2f12	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2f14	d0 01		bne $2f17			bne 	_FNNoBorrow
.2f16	88		dey				dey
.2f17					_FNNoBorrow:
.2f17	3a		dec a				dec 	a
.2f18	5a		phy				phy 								; save location of routine on stack.
.2f19	48		pha				pha
.2f1a	da		phx				phx
.2f1b	20 19 2d	jsr $2d19			jsr 	CompileExpressionAt0
.2f1e	20 65 2a	jsr $2a65			jsr 	CheckNextRParen
.2f21	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.2f23	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2f26	68		pla				pla
.2f27	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2f2a	68		pla				pla
.2f2b	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2f2e	68		pla				pla
.2f2f	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.2f32	18		clc				clc
.2f33	60		rts				rts
.2f34					_FNError:
.2f34	4c e1 1e	jmp $1ee1		jmp	ErrorV_value
.2f37					CommandTables:
>2f37	07 cb 00 03 3c 34 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2f3e	07 89 00 03 43 34 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2f45	07 8d 00 03 36 34 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>2f4c	07 88 00 03 b2 34 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2f53	07 85 00 03 92 34 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>2f5a	07 84 00 04 a6 34 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>2f61	07 99 00 03 e7 35 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2f68	07 98 00 04 e7 35 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2f6f	07 8f 00 03 f2 36 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>2f76	07 81 00 03 94 2e 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>2f7d	07 82 00 03 6a 35 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>2f84	07 a1 00 03 af 33 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>2f8b	07 83 00 03 ce 2b 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>2f92	07 87 00 03 30 36 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>2f99	07 86 00 03 61 2c 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>2fa0	07 96 00 03 ea 2b 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>2fa7	07 8b 00 e3 5f 34 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>2fae	08 92 00 ea e3 be 37 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>2fb6	09 91 00 e1 a9 03 96 35			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>2fbe	06
>2fbf	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>2fc6	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>2fcd	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>2fd3	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>2fda	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>2fe1	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>2fe8	07 9d 00 e3 e4 37 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>2fef	0a 9f 00 ea e3 f7 37 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>2ff7	c6 06
>2ff9	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>2fff	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>3006	0a ce 92 e3 2c 33 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>300e	ad 06
>3010	0a ce 8d e3 2c 33 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>3018	ae 06
>301a	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>3020	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>3028	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>302f	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>3036	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>303e	06
>303f	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>3047	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>304f	9a 06
>3051	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>3059	9b 06
>305b	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>3063	9c 06
>3065	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>306d	06
>306e	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>3075	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>307d	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>3085	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>308d	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>3095	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>309d	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>30a5	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>30ad	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>30b5	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>30bd	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>30c5	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>30cc	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>30d4	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>30dc	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>30e4	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>30ec	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>30f4	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>30fc	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>3104	00						.byte 	0
.3105					UnaryTables:
>3105	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>310c	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>3114	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>311b	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>3122	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>3129	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>3130	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>3138	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>313f	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>3147	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>314f	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>3157	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>315f	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>3167	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>316f	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>3176	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>317d	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>3184	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>318b	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>3192	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>3199	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>31a1	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>31a9	0b ca 00 8f ae 03 2c 33			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>31b1	91 bd 07
>31b4	07 a8 00 03 4b 33 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>31bb	07 a5 00 03 f8 2e 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>31c2	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>31c9	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>31d0	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>31d8	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>31e0	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>31e7	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>31ee	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>31f5	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>31fd	06
>31fe	00						.byte 	0
.31ff					GeneratorProcess:
.31ff	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.3201	84 2d		sty $2d				sty 	zTemp0+1
.3203	85 2e		sta $2e				sta 	zTemp1 						; first match token
.3205	64 2f		stz $2f				stz 	zTemp1+1
.3207	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.3209	d0 05		bne $3210			bne 	_GPNotShifted
.320b	20 6e 33	jsr $336e			jsr 	GetNext 					; get the shifted token
.320e	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.3210					_GPNotShifted:
.3210					_GPSearch:
.3210	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.3212	18		clc				clc
.3213	f0 2f		beq $3244			beq 	_GPExit
.3215	a0 01		ldy #$01			ldy 	#1 							; tokens match
.3217	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.3219	c5 2e		cmp $2e				cmp 	zTemp1
.321b	d0 09		bne $3226			bne 	_GPNext
.321d	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.321f	f0 12		beq $3233			beq 	_GPFound
.3221	c8		iny				iny 								; check match.
.3222	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.3224	f0 0d		beq $3233			beq 	_GPFound
.3226					_GPNext:
.3226	18		clc				clc 								; follow to next
.3227	a5 2c		lda $2c				lda 	zTemp0
.3229	72 2c		adc ($2c)			adc 	(zTemp0)
.322b	85 2c		sta $2c				sta 	zTemp0
.322d	90 e1		bcc $3210			bcc 	_GPSearch
.322f	e6 2d		inc $2d				inc 	zTemp0+1
.3231	80 dd		bra $3210			bra 	_GPSearch
.3233					_GPFound:
.3233	18		clc				clc 								; skip to action bytes
.3234	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.3236	69 03		adc #$03			adc 	#3
.3238	85 2c		sta $2c				sta 	zTemp0
.323a	90 02		bcc $323e			bcc 	_GPNoCarry
.323c	e6 2d		inc $2d				inc 	zTemp0+1
.323e					_GPNoCarry:
.323e					_GPLoop:
.323e	20 45 32	jsr $3245			jsr 	GeneratorExecute 			; execute one command
.3241	90 fb		bcc $323e			bcc 	_GPLoop 					; go back if not completed.
.3243	38		sec				sec 								; return with CS.
.3244					_GPExit:
.3244	60		rts				rts
.3245					GeneratorExecute:
.3245	20 f1 32	jsr $32f1			jsr 	_GEFetchZTemp0 				; get next.
.3248	48		pha				pha 								; split into 2 nibbles
.3249	4a		lsr a				lsr 	a
.324a	4a		lsr a				lsr 	a
.324b	4a		lsr a				lsr		a
.324c	4a		lsr a				lsr 	a
.324d	20 57 32	jsr $3257			jsr 	_GEExecuteNibble 			; MSB first
.3250	68		pla				pla
.3251	b0 03		bcs $3256			bcs 	_GEHaveCompleted
.3253	20 57 32	jsr $3257			jsr 	_GEExecuteNibble 			; LSB second
.3256					_GEHaveCompleted:
.3256	60		rts				rts
.3257					_GEExecuteNibble:
.3257	29 0f		and #$0f			and 	#$0F
.3259	0a		asl a				asl 	a
.325a	aa		tax				tax
.325b	7c 5e 32	jmp ($325e,x)			jmp 	(_GEExecuteVectors,x)
.325e					_GEExecuteVectors:
>325e	7e 32						.word 	_GEXNop 					; 0  (no operation)
>3260	86 32						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>3262	80 32						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>3264	d4 32						.word 	_GEXExecute 				; 3  (run arbitrary code)
>3266	c7 32						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>3268	7e 32						.word 	_GEXNop 					; 5
>326a	8e 32						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>326c	92 32						.word 	_GEXExitString 				; 7  exit return string type
>326e	96 32						.word 	_GEXLParam 					; 8  check ( follows
>3270	9a 32						.word 	_GEXRParam 					; 9  check ) follows
>3272	9e 32						.word 	_GEXComma					; A  check , follows
>3274	7e 32						.word 	_GEXNop 					; B
>3276	7e 32						.word 	_GEXNop 					; C
>3278	7e 32						.word 	_GEXNop 					; D
>327a	ae 32						.word 	_GEXNumber 					; E  compile get any number
>327c	b9 32						.word 	_GEXString 					; F  compile get any string
.327e					_GEXNop:
.327e	18		clc				clc
.327f	60		rts				rts
.3280					_GEXToken2:
.3280	20 f1 32	jsr $32f1			jsr 	_GEFetchZTemp0
.3283	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.3286					_GEXToken1:
.3286	20 f1 32	jsr $32f1			jsr 	_GEFetchZTemp0
.3289	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.328c	18		clc				clc
.328d	60		rts				rts
.328e					_GEXExitNumber:
.328e	a9 00		lda #$00			lda 	#NSSIFloat
.3290	38		sec				sec
.3291	60		rts				rts
.3292					_GEXExitString:
.3292	a9 40		lda #$40			lda 	#NSSString
.3294	38		sec				sec
.3295	60		rts				rts
.3296					_GEXLParam:
.3296	a9 28		lda #$28			lda 	#"("
.3298	80 06		bra $32a0			bra 	_GEXCheck
.329a					_GEXRParam:
.329a	a9 29		lda #$29			lda 	#")"
.329c	80 02		bra $32a0			bra 	_GEXCheck
.329e					_GEXComma:
.329e	a9 2c		lda #$2c			lda 	#","
.32a0					_GEXCheck:
.32a0	85 30		sta $30				sta 	zTemp2 						; save match
.32a2	20 79 33	jsr $3379			jsr 	GetNextNonSpace 			; get next skipping spaces
.32a5	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.32a7	d0 02		bne $32ab			bne 	_GEXSyntax
.32a9	18		clc				clc
.32aa	60		rts				rts
.32ab					_GEXSyntax:
.32ab	4c ee 1e	jmp $1eee		jmp	ErrorV_syntax
.32ae					_GEXNumber:
.32ae	20 fa 32	jsr $32fa			jsr 	GEXCompileExpression 		; compile expression
.32b1	29 40		and #$40			and 	#NSSTypeMask
.32b3	c9 00		cmp #$00			cmp  	#NSSIFloat
.32b5	d0 0d		bne $32c4			bne 	_GEXType
.32b7	18		clc				clc
.32b8	60		rts				rts
.32b9					_GEXString:
.32b9	20 fa 32	jsr $32fa			jsr 	GEXCompileExpression 		; compile expression
.32bc	29 40		and #$40			and 	#NSSTypeMask
.32be	c9 40		cmp #$40			cmp  	#NSSString
.32c0	d0 02		bne $32c4			bne 	_GEXType
.32c2	18		clc				clc
.32c3	60		rts				rts
.32c4					_GEXType:
.32c4	4c fe 1e	jmp $1efe		jmp	ErrorV_type
.32c7					_GEXChannelExec:
.32c7	20 0a 33	jsr $330a			jsr 	ChannelPrefix 				; set up default
.32ca	20 d4 32	jsr $32d4			jsr 	_GEXExecute
.32cd	08		php				php
.32ce	20 25 33	jsr $3325			jsr 	ChannelPostfix 				; replace default.
.32d1	28		plp				plp
.32d2	60		rts				rts
>32d3	db						.byte 	$DB 						; causes a break in the emulator
.32d4					_GEXExecute:
.32d4	20 f1 32	jsr $32f1			jsr 	_GEFetchZTemp0 				; get vector
.32d7	85 30		sta $30				sta 	zTemp2
.32d9	20 f1 32	jsr $32f1			jsr 	_GEFetchZTemp0
.32dc	85 31		sta $31				sta 	zTemp2+1
.32de	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.32e0	da		phx				phx
.32e1	a6 2d		ldx $2d				ldx 	zTemp0+1
.32e3	da		phx				phx
.32e4	20 ee 32	jsr $32ee			jsr 	_GECallZTemp2 				; execute code
.32e7	fa		plx				plx 								; recover generation exec
.32e8	86 2d		stx $2d				stx 	zTemp0+1
.32ea	fa		plx				plx
.32eb	86 2c		stx $2c				stx 	zTemp0
.32ed	60		rts				rts
.32ee					_GECallZTemp2:
.32ee	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.32f1					_GEFetchZTemp0:
.32f1	b2 2c		lda ($2c)			lda 	(zTemp0)
.32f3	e6 2c		inc $2c				inc 	zTemp0
.32f5	d0 02		bne $32f9			bne 	_GEFZ0Skip
.32f7	e6 2d		inc $2d				inc 	zTemp0+1
.32f9					_GEFZ0Skip:
.32f9	60		rts				rts
.32fa					GEXCompileExpression:
.32fa	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.32fc	da		phx				phx
.32fd	a6 2d		ldx $2d				ldx 	zTemp0+1
.32ff	da		phx				phx
.3300	20 19 2d	jsr $2d19			jsr 	CompileExpressionAt0 		; compile expression.
.3303	fa		plx				plx 								; recover generation exec
.3304	86 2d		stx $2d				stx 	zTemp0+1
.3306	fa		plx				plx
.3307	86 2c		stx $2c				stx 	zTemp0
.3309	60		rts				rts
.330a					ChannelPrefix:
.330a	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.330c	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.330f	20 fa 32	jsr $32fa			jsr 	GEXCompileExpression 		; channel #
.3312	29 40		and #$40			and 	#NSSTypeMask
.3314	c9 00		cmp #$00			cmp 	#NSSIFloat
.3316	d0 0a		bne $3322			bne 	_CPXType
.3318	20 61 2a	jsr $2a61			jsr 	CheckNextComma 				; check , follows.
.331b	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.331d	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.3320	18		clc				clc
.3321	60		rts				rts
.3322					_CPXType:
.3322	4c fe 1e	jmp $1efe		jmp	ErrorV_type
.3325					ChannelPostfix:
.3325	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.3327	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.332a	18		clc				clc
.332b	60		rts				rts
.332c					OptionalParameterCompile:
.332c	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; what follows.
.332f	c9 2c		cmp #$2c			cmp 	#","
.3331	d0 0e		bne $3341			bne 	_MidDefault
.3333	20 6e 33	jsr $336e			jsr 	GetNext 					; consume ,
.3336	20 19 2d	jsr $2d19			jsr 	CompileExpressionAt0
.3339	29 40		and #$40			and 	#NSSTypeMask
.333b	c9 00		cmp #$00			cmp 	#NSSIFloat
.333d	d0 09		bne $3348			bne 	MidFailType
.333f	80 05		bra $3346			bra 	_MidComplete
.3341					_MidDefault:
.3341	a9 ff		lda #$ff			lda 	#255 						; default of 255
.3343	20 2b 2b	jsr $2b2b			jsr 	PushIntegerA
.3346					_MidComplete:
.3346	18		clc				clc
.3347	60		rts				rts
.3348					MidFailType:
.3348	4c fe 1e	jmp $1efe		jmp	ErrorV_type
.334b					NotUnaryCompile:
.334b	ad ce 2d	lda $2dce			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.334e	20 1b 2d	jsr $2d1b			jsr 	CompileExpressionAtA 		; evaluate at that level
.3351	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.3353	c9 00		cmp #$00			cmp 	#NSSIFloat
.3355	d0 f1		bne $3348			bne 	MidFailType
.3357	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.3359	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.335c	60		rts				rts
.335d					LookNext:
.335d	b2 7a		lda ($7a)			lda 	(srcPtr)
.335f	60		rts				rts
.3360					LookNextNonSpace:
.3360	b2 7a		lda ($7a)			lda 	(srcPtr)
.3362	c9 20		cmp #$20			cmp		#' '
.3364	f0 03		beq $3369			beq 	_LNNSkip
.3366	c9 00		cmp #$00			cmp 	#0
.3368	60		rts				rts
.3369					_LNNSkip:
.3369	20 6e 33	jsr $336e			jsr 	GetNext
.336c	80 f2		bra $3360			bra 	LookNextNonSpace
.336e					GetNext:
.336e	b2 7a		lda ($7a)			lda 	(srcPtr) 					; get next
.3370	e6 7a		inc $7a				inc 	srcPtr
.3372	d0 02		bne $3376			bne 	_GNSkip
.3374	e6 7b		inc $7b				inc 	srcPtr+1
.3376					_GNSkip:
.3376	c9 00		cmp #$00			cmp 	#0
.3378	60		rts				rts
.3379					GetNextNonSpace:
.3379	20 6e 33	jsr $336e			jsr 	GetNext
.337c	c9 20		cmp #$20			cmp 	#' '
.337e	f0 f9		beq $3379			beq 	GetNextNonSpace
.3380	c9 00		cmp #$00			cmp 	#0
.3382	60		rts				rts
.3383					CharIsDigit:
.3383	c9 30		cmp #$30			cmp 	#"0"
.3385	90 06		bcc $338d			bcc 	CCFalse
.3387	c9 3a		cmp #$3a			cmp 	#"9"+1
.3389	b0 02		bcs $338d			bcs 	CCFalse
.338b					CCTrue:
.338b	38		sec				sec
.338c	60		rts				rts
.338d					CCFalse:
.338d	18		clc				clc
.338e	60		rts				rts
.338f					CharIsAlpha:
.338f	c9 41		cmp #$41			cmp 	#"A"
.3391	90 fa		bcc $338d			bcc 	CCFalse
.3393	c9 5b		cmp #$5b			cmp 	#"Z"+1
.3395	b0 f6		bcs $338d			bcs 	CCFalse
.3397	80 f2		bra $338b			bra 	CCTrue
.3399					ConvertHexStyle:
.3399	38		sec				sec
.339a	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.339c	90 ef		bcc $338d			bcc 	CCFalse
.339e	c9 0a		cmp #$0a			cmp 	#9+1
.33a0	90 e9		bcc $338b			bcc 	CCTrue
.33a2	38		sec				sec 								; shift into hex space A=>0 Z=>25
.33a3	e9 11		sbc #$11			sbc 	#"A"-"0"
.33a5	90 e6		bcc $338d			bcc 	CCFalse
.33a7	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.33a9	b0 e2		bcs $338d			bcs 	CCFalse
.33ab	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.33ad	80 dc		bra $338b			bra 	CCTrue
.33af					CommandGET:
.33af	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; # follows ?
.33b2	c9 23		cmp #$23			cmp 	#"#"
.33b4	d0 0d		bne $33c3			bne 	CommandGetBody
.33b6	20 6e 33	jsr $336e			jsr 	GetNext 					; consume #
.33b9	20 0a 33	jsr $330a			jsr 	ChannelPrefix 				; do it as GET#
.33bc	20 c3 33	jsr $33c3			jsr 	CommandGetBody
.33bf	20 25 33	jsr $3325			jsr 	ChannelPostfix
.33c2	60		rts				rts
.33c3					CommandGetBody:
.33c3	20 79 33	jsr $3379			jsr 	GetNextNonSpace 			; get the first character
.33c6	20 ba 36	jsr $36ba			jsr 	GetReferenceTerm 			; identify variable to assign to
.33c9	48		pha				pha
.33ca	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.33cc	c9 40		cmp #$40			cmp 	#NSSString
.33ce	d0 0b		bne $33db			bne 	_CGType
.33d0	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.33d2	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.33d5	38		sec				sec
.33d6	68		pla				pla
.33d7	20 6c 36	jsr $366c			jsr		GetSetVariable
.33da	60		rts				rts
.33db					_CGType:
.33db	4c fe 1e	jmp $1efe		jmp	ErrorV_type
.33de					ExtractVariableName:
.33de	20 8f 33	jsr $338f			jsr 	CharIsAlpha
.33e1	90 50		bcc $3433			bcc 	_IVSyntax
.33e3	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.33e5	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.33e7	64 2f		stz $2f				stz 	zTemp1+1
.33e9	20 5d 33	jsr $335d			jsr 	LookNext 					; is there a second character ?
.33ec	20 8f 33	jsr $338f			jsr 	CharIsAlpha  				; must be alphanumeric
.33ef	b0 05		bcs $33f6			bcs 	_IVHasSecond
.33f1	20 83 33	jsr $3383			jsr 	CharIsDigit
.33f4	90 07		bcc $33fd			bcc 	_IVCheckType
.33f6					_IVHasSecond:
.33f6	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.33f8	85 2f		sta $2f				sta 	zTemp1+1
.33fa					_IVGetNextCheck:
.33fa	20 6e 33	jsr $336e			jsr 	GetNext 					; consume it
.33fd					_IVCheckType:
.33fd	20 5d 33	jsr $335d			jsr 	LookNext					; check if string follows.
.3400	20 8f 33	jsr $338f			jsr 	CharIsAlpha
.3403	b0 f5		bcs $33fa			bcs 	_IVGetNextCheck
.3405	20 83 33	jsr $3383			jsr 	CharIsDigit
.3408	b0 f0		bcs $33fa			bcs 	_IVGetNextCheck
.340a	a2 40		ldx #$40			ldx 	#NSSString
.340c	c9 24		cmp #$24			cmp 	#"$"
.340e	f0 06		beq $3416			beq 	_IVHasType
.3410	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.3412	c9 25		cmp #$25			cmp 	#"%"
.3414	d0 08		bne $341e			bne 	_IVCheckArray
.3416					_IVHasType:
.3416	8a		txa				txa 								; Or X into zTemp1
.3417	05 2e		ora $2e				ora 	zTemp1
.3419	85 2e		sta $2e				sta 	zTemp1
.341b	20 6e 33	jsr $336e			jsr 	GetNext 					; consume it
.341e					_IVCheckArray:
.341e	20 5d 33	jsr $335d			jsr 	LookNext 					; check if array follows
.3421	c9 28		cmp #$28			cmp 	#"("
.3423	d0 09		bne $342e			bne 	_IVNotArray
.3425	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.3427	09 80		ora #$80			ora 	#NSSArray
.3429	85 2e		sta $2e				sta 	zTemp1
.342b	20 6e 33	jsr $336e			jsr 	GetNext 					; consume it
.342e					_IVNotArray:
.342e	a6 2e		ldx $2e				ldx 	zTemp1
.3430	a4 2f		ldy $2f				ldy 	zTemp1+1
.3432	60		rts				rts
.3433					_IVSyntax:
.3433	4c ee 1e	jmp $1eee		jmp	ErrorV_syntax
.3436					CommandGOSUB:
.3436	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.3438	20 49 34	jsr $3449			jsr 	CompileBranchCommand
.343b	60		rts				rts
.343c					CommandGOAlt:
.343c	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.343e	20 6b 2a	jsr $2a6b			jsr 	CheckNextA
.3441	80 00		bra $3443			bra 	CommandGOTO
.3443					CommandGOTO:
.3443	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.3445	20 49 34	jsr $3449			jsr 	CompileBranchCommand
.3448	60		rts				rts
.3449					CompileBranchCommand:
.3449	20 03 2a	jsr $2a03			jsr 	WriteCodeByte 				; write the command out.
.344c	20 79 33	jsr $3379			jsr 	GetNextNonSpace
.344f	20 c2 35	jsr $35c2			jsr 	ParseConstant 				; get constant into YA
.3452	90 08		bcc $345c			bcc 	_CBCSyntax
.3454	20 03 2a	jsr $2a03			jsr 	WriteCodeByte				; and compile the actual line number
.3457	98		tya				tya
.3458	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.345b	60		rts				rts
.345c					_CBCSyntax:
.345c	4c ee 1e	jmp $1eee		jmp	ErrorV_syntax
.345f					CommandIF:
.345f	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; what follows the tests ?
.3462	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.3464	f0 0f		beq $3475			beq 	_CIGoto
.3466	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.3468	20 6b 2a	jsr $2a6b			jsr 	CheckNextA
.346b	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; THEN <number>
.346e	20 83 33	jsr $3383			jsr 	CharIsDigit
.3471	b0 05		bcs $3478			bcs 	_CIGoto2
.3473	80 09		bra $347e			bra 	CompileGotoEOL
.3475					_CIGoto:
.3475	20 6e 33	jsr $336e			jsr 	GetNext
.3478					_CIGoto2:
.3478	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.347a	20 49 34	jsr $3449			jsr 	CompileBranchCommand
.347d	60		rts				rts
.347e					CompileGotoEOL:
.347e	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.3480	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.3483	20 fc 29	jsr $29fc			jsr 	GetLineNumber 				; Get the current line number => YA
.3486	1a		inc a				inc 	a 							; and branch to +1
.3487	d0 01		bne $348a			bne 	_CGENoCarry
.3489	c8		iny				iny
.348a					_CGENoCarry:
.348a	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.348d	98		tya				tya
.348e	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.3491	60		rts				rts
.3492					CommandINPUT:
.3492	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; check for "
.3495	c9 22		cmp #$22			cmp 	#'"'
.3497	d0 0d		bne $34a6			bne 	CommandINPUTStream
.3499	20 19 2d	jsr $2d19			jsr 	CompileExpressionAt0
.349c	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.349e	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.34a1	a9 2c		lda #$2c			lda 	#","
.34a3	20 61 2a	jsr $2a61			jsr 	CheckNextComma
.34a6					CommandINPUTStream:
.34a6	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.34a8	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.34ab	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.34ad	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.34af	4c 34 36	jmp $3634			jmp 	CommandReadInputCommon
.34b2					CommandLET:
.34b2	20 79 33	jsr $3379			jsr 	GetNextNonSpace 			; get the first character
.34b5					CommandLETHaveFirst:
.34b5	20 ba 36	jsr $36ba			jsr 	GetReferenceTerm 			; identify variable to assign to
.34b8	da		phx				phx 								; save target on the stack.
.34b9	5a		phy				phy
.34ba	48		pha				pha
.34bb	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.34bd	20 6b 2a	jsr $2a6b			jsr 	CheckNextA
.34c0	20 19 2d	jsr $2d19			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.34c3	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.34c5	68		pla				pla 								; get type of assignment
.34c6	48		pha				pha
.34c7	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.34c9	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.34cb	d0 17		bne $34e4			bne 	_CLType
.34cd	68		pla				pla 								; restore and compile save code
.34ce	7a		ply				ply
.34cf	fa		plx				plx
.34d0	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.34d2	f0 05		beq $34d9			beq 	_CLTIString
.34d4	38		sec				sec
.34d5	20 6c 36	jsr $366c			jsr		GetSetVariable
.34d8	60		rts				rts
.34d9					_CLTIString:
.34d9	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.34db	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.34de	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.34e0	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.34e3	60		rts				rts
.34e4					_CLType:
.34e4	4c fe 1e	jmp $1efe		jmp	ErrorV_type
.34e7					STRMarkLine:
.34e7	48		pha				pha
.34e8	38		sec				sec 								; allocate 4 bytes (line #,address)
.34e9	ad c7 06	lda $06c7			lda 	lineNumberTable 			; and copy to zTemp0
.34ec	e9 04		sbc #$04			sbc 	#4
.34ee	8d c7 06	sta $06c7			sta 	lineNumberTable
.34f1	85 2c		sta $2c				sta 	zTemp0
.34f3	ad c8 06	lda $06c8			lda 	lineNumberTable+1
.34f6	e9 00		sbc #$00			sbc 	#0
.34f8	8d c8 06	sta $06c8			sta 	lineNumberTable+1
.34fb	85 2d		sta $2d				sta 	zTemp0+1
.34fd	68		pla				pla
.34fe	92 2c		sta ($2c)			sta 	(zTemp0) 					; line # save it in +0,+1
.3500	98		tya				tya
.3501	a0 01		ldy #$01			ldy 	#1
.3503	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3505	a5 2a		lda $2a				lda 	objPtr 						; save current address in +2,+3
.3507	c8		iny				iny
.3508	91 2c		sta ($2c),y			sta 	(zTemp0),y
.350a	a5 2b		lda $2b				lda 	objPtr+1
.350c	c8		iny				iny
.350d	91 2c		sta ($2c),y			sta 	(zTemp0),y
.350f	60		rts				rts
.3510					STRFindLine:
.3510	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.3512	84 2d		sty $2d				sty 	zTemp0+1
.3514	ad c0 06	lda $06c0			lda 	compilerEndHigh 			; work backwards through table
.3517	85 2f		sta $2f				sta 	zTemp1+1
.3519	64 2e		stz $2e				stz 	zTemp1
.351b					_STRSearch:
.351b	20 52 35	jsr $3552			jsr 	_STRPrevLine 				; look at previous record.
.351e	a0 01		ldy #$01			ldy 	#1
.3520	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.3522	c5 2c		cmp $2c				cmp 	zTemp0
.3524	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3526	e5 2d		sbc $2d				sbc 	zTemp0+1
.3528	b0 0b		bcs $3535			bcs 	_STRFound 					; >=
.352a					_STRNext:
.352a	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.352c	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.352e	c9 ff		cmp #$ff			cmp 	#$FF
.3530	d0 e9		bne $351b			bne 	_STRSearch
.3532	4c 48 1f	jmp $1f48		jmp	ErrorV_internal
.3535					_STRFound:
.3535	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.3537	45 2c		eor $2c				eor 	zTemp0
.3539	d0 06		bne $3541			bne 	_STRDifferent
.353b	b2 2e		lda ($2e)			lda 	(zTemp1)
.353d	45 2c		eor $2c				eor 	zTemp0
.353f	f0 02		beq $3543			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.3541					_STRDifferent:
.3541	a9 ff		lda #$ff			lda 	#$FF
.3543					_STROut:
.3543	18		clc				clc  								; set carry if different, e.g. > rather than >=
.3544	69 ff		adc #$ff			adc 	#255
.3546	08		php				php
.3547	c8		iny				iny 								; address into YA
.3548	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.354a	48		pha				pha
.354b	c8		iny				iny
.354c	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.354e	a8		tay				tay
.354f	68		pla				pla
.3550	28		plp				plp
.3551	60		rts				rts
.3552					_STRPrevLine:
.3552	38		sec				sec 								; move backwards one entry.
.3553	a5 2e		lda $2e				lda 	zTemp1
.3555	e9 04		sbc #$04			sbc 	#4
.3557	85 2e		sta $2e				sta 	zTemp1
.3559	a5 2f		lda $2f				lda 	zTemp1+1
.355b	e9 00		sbc #$00			sbc 	#0
.355d	85 2f		sta $2f				sta 	zTemp1+1
.355f	60		rts				rts
.3560					STRMakeOffset:
.3560	18		clc				clc 								; borrow 1
.3561	e5 2a		sbc $2a				sbc 	objPtr
.3563	48		pha				pha
.3564	98		tya				tya
.3565	e5 2b		sbc $2b				sbc 	objPtr+1
.3567	a8		tay				tay
.3568	68		pla				pla
.3569	60		rts				rts
.356a					CommandNEXT:
.356a	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.356d	20 8f 33	jsr $338f			jsr 	CharIsAlpha 				; if not alpha , error
.3570	90 0c		bcc $357e			bcc 	_CNNoReferenceGiven
.3572	20 6e 33	jsr $336e			jsr 	GetNext
.3575	20 ba 36	jsr $36ba			jsr 	GetReferenceTerm 			; figure out the reference.
.3578	8a		txa				txa 								; reference in YA
.3579	20 18 2b	jsr $2b18			jsr 	PushIntegerYA 				; write it out.
.357c	80 06		bra $3584			bra 	_CNParametersDone
.357e					_CNNoReferenceGiven:
.357e	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.3580	a8		tay				tay
.3581	20 18 2b	jsr $2b18			jsr 	PushIntegerYA 				; write it out.
.3584					_CNParametersDone:
.3584	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.3586	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.3589	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; look for ,
.358c	c9 2c		cmp #$2c			cmp 	#","
.358e	d0 05		bne $3595			bne 	_CNExit
.3590	20 6e 33	jsr $336e			jsr 	GetNext 					; consume ,
.3593	80 d5		bra $356a			bra 	CommandNEXT 				; and go round.
.3595					_CNExit:
.3595	60		rts				rts
.3596					CommandON:
.3596	20 79 33	jsr $3379			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.3599	48		pha				pha 								; save on stack
.359a	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.359c	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.359e	f0 09		beq $35a9			beq 	_COCreateLoop
.35a0	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.35a2	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.35a4	f0 03		beq $35a9			beq 	_COCreateLoop
.35a6	4c ee 1e	jmp $1eee		jmp	ErrorV_syntax
.35a9					_COCreateLoop:
.35a9	8a		txa				txa 								; compile a goto/gosub somewhere
.35aa	da		phx				phx
.35ab	20 49 34	jsr $3449			jsr 	CompileBranchCommand
.35ae	fa		plx				plx
.35af	20 60 33	jsr $3360			jsr 	LookNextNonSpace			; ',' follows
.35b2	c9 2c		cmp #$2c			cmp 	#","
.35b4	d0 0a		bne $35c0			bne 	_COComplete 				; if so, more line numbers
.35b6	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.35b8	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.35bb	20 6e 33	jsr $336e			jsr 	GetNext
.35be	80 e9		bra $35a9			bra 	_COCreateLoop
.35c0					_COComplete:
.35c0	68		pla				pla 								; throw GOTO/GOSUB
.35c1	60		rts				rts
.35c2					ParseConstant:
.35c2	a2 00		ldx #$00			ldx 	#0
.35c4	20 14 24	jsr $2414			jsr 	FloatEncodeStart 			; send first
.35c7					_ParseLoop:
.35c7	20 5d 33	jsr $335d			jsr 	LookNext 					; send subsequent
.35ca	20 17 24	jsr $2417			jsr 	FloatEncodeContinue
.35cd	90 05		bcc $35d4			bcc 	_ParseDone
.35cf	20 6e 33	jsr $336e			jsr 	GetNext 					; consume it
.35d2	80 f3		bra $35c7			bra 	_ParseLoop
.35d4					_ParseDone:
.35d4	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.35d6	29 80		and #$80			and 	#$80
.35d8	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.35da	15 56		ora $56,x			ora 	NSMantissa2,x
.35dc	15 62		ora $62,x			ora 	NSMantissa3,x
.35de	18		clc				clc
.35df	d0 05		bne $35e6			bne 	_ParseExit 					; exit with CC if need float to compile
.35e1	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.35e3	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.35e5	38		sec				sec
.35e6					_ParseExit:
.35e6	60		rts				rts
.35e7					CommandPRINT:
.35e7	20 60 33	jsr $3360			jsr 	LookNextNonSpace			; what follows ?
.35ea	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.35ec	f0 1f		beq $360d			beq 	_CPCheckEnd
.35ee	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.35f0	f0 16		beq $3608			beq 	_CPTabCheckEnd
.35f2	20 24 36	jsr $3624			jsr 	_CPAtEnd 					; check for : and EOL
.35f5	b0 22		bcs $3619			bcs 	_CPExitCR 					; exit with CR
.35f7	20 19 2d	jsr $2d19			jsr 	CompileExpressionAt0 		; so it is something to print
.35fa	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.35fc	29 40		and #$40			and 	#NSSString 					; if string
.35fe	d0 02		bne $3602			bne 	_CPOut
.3600	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.3602					_CPOut:
.3602	8a		txa				txa 								; print that thing
.3603	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.3606	80 df		bra $35e7			bra 	CommandPRINT 				; and loop round/
.3608					_CPTabCheckEnd:
.3608	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.360a	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.360d					_CPCheckEnd:
.360d	20 6e 33	jsr $336e			jsr 	GetNext 					; consume it.
.3610	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; what follows ?
.3613	20 24 36	jsr $3624			jsr 	_CPAtEnd 					; reached end
.3616	90 cf		bcc $35e7			bcc 	CommandPRINT 				; no, loop back
.3618	60		rts				rts
.3619					_CPExitCR:
.3619	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.361b	20 2b 2b	jsr $2b2b			jsr 	PushIntegerA
.361e	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.3620	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.3623	60		rts				rts
.3624					_CPAtEnd:
.3624	c9 00		cmp #$00			cmp 	#0
.3626	f0 06		beq $362e			beq 	_CPIsEnd
.3628	c9 3a		cmp #$3a			cmp 	#":"
.362a	f0 02		beq $362e			beq 	_CPIsEnd
.362c	18		clc				clc
.362d	60		rts				rts
.362e					_CPIsEnd:
.362e	38		sec				sec
.362f	60		rts				rts
.3630					CommandREAD:
.3630	a2 b2		ldx #$b2			ldx 	#PCD_READ
.3632	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.3634					CommandReadInputCommon:
.3634	8e c5 06	stx $06c5			stx 	numberPCode
.3637	8c c6 06	sty $06c6			sty 	stringPCode
.363a					_CRLoop:
.363a	20 79 33	jsr $3379			jsr 	GetNextNonSpace 			; first char of identifier
.363d	20 8f 33	jsr $338f			jsr 	CharIsAlpha 				; check A-Z
.3640	90 27		bcc $3669			bcc 	_CRSyntax
.3642	20 ba 36	jsr $36ba			jsr 	GetReferenceTerm 			; get the variable.
.3645	48		pha				pha 								; save type.
.3646	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.3648	c9 40		cmp #$40			cmp 	#NSSString
.364a	f0 05		beq $3651			beq 	_CRString
.364c	ad c5 06	lda $06c5			lda 	numberPCode 				; output read/input
.364f	80 03		bra $3654			bra 	_CRHaveType
.3651					_CRString:
.3651	ad c6 06	lda $06c6			lda 	stringPCode					; output read$/input$
.3654					_CRHaveType:
.3654	20 03 2a	jsr $2a03			jsr 	WriteCodeByte 				; so we have one typed data item.
.3657	68		pla				pla 								; restore type
.3658	38		sec				sec  								; write update code.
.3659	20 6c 36	jsr $366c			jsr 	GetSetVariable
.365c	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; , follows ?
.365f	c9 2c		cmp #$2c			cmp 	#","
.3661	d0 05		bne $3668			bne 	_CRExit 					; if not, end of READ.
.3663	20 6e 33	jsr $336e			jsr 	GetNext 					; consume comma
.3666	80 d2		bra $363a			bra 	_CRLoop 					; keep going
.3668					_CRExit:
.3668	60		rts				rts
.3669					_CRSyntax:
.3669	4c ee 1e	jmp $1eee		jmp	ErrorV_syntax
.06c5					numberPCode:
>06c5							.fill 	1
.06c6					stringPCode:
>06c6							.fill 	1
.366c					GetSetVariable:
.366c	08		php				php 								; save direction on stack
.366d	c0 00		cpy #$00			cpy 	#$00
.366f	30 21		bmi $3692			bmi 	_GSVReadWriteSpecial
.3671	c9 00		cmp #$00			cmp 	#$00
.3673	30 33		bmi $36a8			bmi 	_GSVArray
.3675	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.3677	4a		lsr a				lsr 	a 							; divide by 2
.3678	09 40		ora #$40			ora 	#64 						; and set bit 6.
.367a	28		plp				plp
.367b	90 02		bcc $367f			bcc 	_GSVNotWrite
.367d	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.367f					_GSVNotWrite:
.367f	85 2c		sta $2c				sta 	zTemp0
.3681	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.3682	4a		lsr a				lsr 	a
.3683	a8		tay				tay
.3684	8a		txa				txa
.3685	6a		ror a				ror 	a
.3686	aa		tax				tax
.3687	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.3688	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.368a	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.368d	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.368e	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.3691	60		rts				rts
.3692					_GSVReadWriteSpecial:
.3692	28		plp				plp
.3693	b0 10		bcs $36a5			bcs 	_GSVSyntax
.3695	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.3697	f0 06		beq $369f			beq 	_GSVRWString
.3699	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.369b	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.369e	60		rts				rts
.369f					_GSVRWString:
.369f	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.36a1	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.36a4	60		rts				rts
.36a5					_GSVSyntax:
.36a5	4c ee 1e	jmp $1eee		jmp	ErrorV_syntax
.36a8					_GSVArray:
.36a8	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.36aa	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.36ab	4a		lsr a				lsr 	a
.36ac	4a		lsr a				lsr 	a
.36ad	4a		lsr a				lsr 	a
.36ae	4a		lsr a				lsr 	a
.36af	28		plp				plp 								; if writing array then set bit 2.
.36b0	90 02		bcc $36b4			bcc 	_GSVANotWrite
.36b2	09 04		ora #$04			ora 	#4
.36b4					_GSVANotWrite:
.36b4	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.36b6	20 03 2a	jsr $2a03			jsr 	WriteCodeByte 				; and write it out
.36b9	60		rts				rts
.36ba					GetReferenceTerm:
.36ba	20 de 33	jsr $33de			jsr 	ExtractVariableName 		; get name & type info
.36bd	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.36bf	30 10		bmi $36d1			bmi 	_GRTArray
.36c1	da		phx				phx 								; save type on stack
.36c2	20 d3 2d	jsr $2dd3			jsr 	FindVariable 				; find it
.36c5	b0 06		bcs $36cd			bcs 	_GRTNoCreate 				; create if required.
.36c7	20 5d 2b	jsr $2b5d			jsr 	CreateVariableRecord 		; create a variable.
.36ca	20 b2 2b	jsr $2bb2			jsr 	AllocateBytesForType 		; allocate memory for it
.36cd					_GRTNoCreate:
.36cd	68		pla				pla 								; get type back, strip out type information.
.36ce	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.36d0	60		rts				rts
.36d1					_GRTArray:
.36d1	da		phx				phx 								; save type information
.36d2	20 d3 2d	jsr $2dd3			jsr 	FindVariable 				; read its data, the base address in YX
.36d5	90 18		bcc $36ef			bcc 	_GRTUndeclared 				; undeclared array.
.36d7	da		phx				phx 								; save base address
.36d8	5a		phy				phy
.36d9	20 a9 2c	jsr $2ca9			jsr 	OutputIndexGroup 			; create an index group and generate them
.36dc	7a		ply				ply 								; get the array base address into YX
.36dd	fa		plx				plx
.36de	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.36e0	18		clc				clc
.36e1	20 6c 36	jsr $366c			jsr 	GetSetVariable 				; load the address of the array structure.
.36e4	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.36e6	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.36e9	68		pla				pla 								; and the type data into A
.36ea	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.36ec	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.36ee	60		rts				rts
.36ef					_GRTUndeclared:
.36ef	4c a5 1f	jmp $1fa5		jmp	ErrorV_undeclared
.36f2					CommandREM:
.36f2	20 5d 33	jsr $335d			jsr 	LookNext
.36f5	f0 05		beq $36fc			beq 	_CRExit
.36f7	20 6e 33	jsr $336e			jsr 	GetNext
.36fa	80 f6		bra $36f2			bra 	CommandREM
.36fc					_CRExit:
.36fc	60		rts				rts
.36fd					STRReset:
.36fd	ad bf 06	lda $06bf			lda	 	compilerStartHigh 			; set up the two table pointers
.3700	8d ca 06	sta $06ca			sta 	variableListEnd+1
.3703	9c c9 06	stz $06c9			stz 	variableListEnd
.3706	ad c0 06	lda $06c0			lda 	compilerEndHigh
.3709	8d c8 06	sta $06c8			sta 	lineNumberTable+1
.370c	9c c7 06	stz $06c7			stz 	lineNumberTable
.370f	ad c9 06	lda $06c9			lda 	variableListEnd
.3712	85 2d		sta $2d				sta 	zTemp0+1
.3714	64 2c		stz $2c				stz 	zTemp0
.3716	a9 00		lda #$00			lda 	#0
.3718	92 2c		sta ($2c)			sta 	(zTemp0)
.371a	a9 00		lda #$00			lda 	#((0) & $FF)
.371c	8d cb 06	sta $06cb			sta 	0+freeVariableMemory
.371f	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.3721	8d cc 06	sta $06cc			sta 	1+freeVariableMemory
.3724	60		rts				rts
.06c7					lineNumberTable:
>06c7							.fill 	2
.06c9					variableListEnd:
>06c9							.fill 	2
.06cb					freeVariableMemory:
>06cb							.fill 	2
.3725					CompileTerm:
.3725	20 79 33	jsr $3379			jsr 	GetNextNonSpace 			; get first non space character.
.3728	30 72		bmi $379c			bmi 	_CTUnaryFunctions
.372a	20 83 33	jsr $3383			jsr 	CharIsDigit 				; found a number
.372d	b0 3a		bcs $3769			bcs 	_CTDigit
.372f	c9 2e		cmp #$2e			cmp 	#"."
.3731	f0 36		beq $3769			beq 	_CTDigit
.3733	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.3735	f0 43		beq $377a			beq 	_CTString
.3737	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.3739	f0 28		beq $3763			beq 	_CTOtherBase
.373b	c9 24		cmp #$24			cmp 	#"$"
.373d	f0 24		beq $3763			beq 	_CTOtherBase
.373f	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.3741	f0 17		beq $375a			beq 	_CTBrackets
.3743	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.3745	90 10		bcc $3757			bcc 	_CTSyntax
.3747	c9 5b		cmp #$5b			cmp 	#"Z"+1
.3749	b0 0c		bcs $3757			bcs 	_CTSyntax
.374b	20 ba 36	jsr $36ba			jsr 	GetReferenceTerm 			; figure out what it is.
.374e	48		pha				pha 								; save type on stack
.374f	18		clc				clc 								; read it
.3750	20 6c 36	jsr $366c			jsr 	GetSetVariable
.3753	68		pla				pla
.3754	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.3756	60		rts				rts
.3757					_CTSyntax:
.3757	4c ee 1e	jmp $1eee		jmp	ErrorV_syntax
.375a					_CTBrackets:
.375a	20 19 2d	jsr $2d19			jsr 	CompileExpressionAt0
.375d	48		pha				pha
.375e	20 65 2a	jsr $2a65			jsr 	CheckNextRParen
.3761	68		pla				pla
.3762	60		rts				rts
.3763					_CTOtherBase:
.3763	20 b1 29	jsr $29b1			jsr 	InlineNonDecimal 			; non decimal constant handler
.3766	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.3768	60		rts				rts
.3769					_CTDigit:
.3769	20 c2 35	jsr $35c2			jsr 	ParseConstant 				; parse out an number, first is in A already.
.376c	90 06		bcc $3774			bcc	 	_CTFloat 					; have a float or long int.
.376e	20 18 2b	jsr $2b18			jsr 	PushIntegerYA 				; code to push on stack
.3771	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.3773	60		rts				rts
.3774					_CTFloat:
.3774	20 3a 2b	jsr $2b3a			jsr 	PushFloatCommand			; code to push float
.3777	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.3779	60		rts				rts
.377a					_CTString:
.377a	20 3a 2a	jsr $2a3a			jsr 	BufferClear 				; copy it to the buffer
.377d					_CTStringLoop:
.377d	20 5d 33	jsr $335d			jsr 	LookNext 					; reached EOL/EOS
.3780	f0 d5		beq $3757			beq 	_CTSyntax
.3782	c9 22		cmp #$22			cmp 	#'"'
.3784	f0 08		beq $378e			beq 	_CTStringDone
.3786	20 3e 2a	jsr $2a3e			jsr 	BufferWrite 				; write and consume
.3789	20 6e 33	jsr $336e			jsr 	GetNext
.378c	80 ef		bra $377d			bra 	_CTStringLoop
.378e					_CTStringDone:
.378e	20 6e 33	jsr $336e			jsr 	GetNext 					; consume closing quote.
.3791	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.3793	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.3796	20 4a 2a	jsr $2a4a			jsr 	BufferOutput
.3799	a9 40		lda #$40			lda 	#NSSString 					; string type
.379b	60		rts				rts
.379c					_CTUnaryFunctions:
.379c	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.379e	f0 0a		beq $37aa			beq 	_CTNegation
.37a0	a2 05		ldx #$05			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.37a2	a0 31		ldy #$31			ldy 	#UnaryTables >> 8
.37a4	20 ff 31	jsr $31ff			jsr 	GeneratorProcess
.37a7	90 ae		bcc $3757			bcc		_CTSyntax
.37a9	60		rts				rts
.37aa					_CTNegation:
.37aa	20 25 37	jsr $3725			jsr 	CompileTerm 				; compile a term.
.37ad	48		pha				pha
.37ae	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.37b0	c9 00		cmp #$00			cmp 	#NSSIFloat
.37b2	d0 07		bne $37bb			bne 	_CTType 					; error
.37b4	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.37b6	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.37b9	68		pla				pla 								; return original type.
.37ba	60		rts				rts
.37bb					_CTType:
.37bb	4c fe 1e	jmp $1efe		jmp	ErrorV_type
.37be					CommandWAIT:
.37be	20 60 33	jsr $3360			jsr 	LookNextNonSpace
.37c1	c9 2c		cmp #$2c			cmp 	#","
.37c3	f0 10		beq $37d5			beq 	_CWThirdParameter
.37c5	a9 00		lda #$00			lda 	#0
.37c7	20 2b 2b	jsr $2b2b			jsr 	PushIntegerA
.37ca					_CWExit:
.37ca	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.37cc	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.37cf	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.37d1	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.37d4	60		rts				rts
.37d5					_CWThirdParameter:
.37d5	20 6e 33	jsr $336e			jsr 	GetNext
.37d8	20 1b 2d	jsr $2d1b			jsr 	CompileExpressionAtA
.37db	29 40		and #$40			and 	#NSSTypeMask
.37dd	c9 00		cmp #$00			cmp 	#NSSIFloat
.37df	f0 e9		beq $37ca			beq 	_CWExit
.37e1	4c fe 1e	jmp $1efe		jmp	ErrorV_type
.37e4					CommandCMD:
.37e4	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.37e6	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.37e9	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; followed by a , ?
.37ec	c9 2c		cmp #$2c			cmp 	#","
.37ee	d0 06		bne $37f6			bne 	_CCMDExit
.37f0	20 6e 33	jsr $336e			jsr 	GetNext 					; consume comma.
.37f3	20 e7 35	jsr $35e7			jsr 	CommandPRINT 				; do the print code
.37f6					_CCMDExit:
.37f6	60		rts				rts
.37f7					CommandOPEN:
.37f7	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; followed by a , ?
.37fa	c9 2c		cmp #$2c			cmp 	#","
.37fc	d0 15		bne $3813			bne 	_COTwoDefaults
.37fe	20 6e 33	jsr $336e			jsr 	GetNext 					; consume comma
.3801	20 19 2d	jsr $2d19			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.3804	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.3806	f0 1e		beq $3826			beq 	_COThreeIntegers
.3808	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.380a	20 2b 2b	jsr $2b2b			jsr 	PushIntegerA
.380d	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.380f	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.3812	60		rts				rts
.3813					_COTwoDefaults:
.3813	a9 00		lda #$00			lda 	#0
.3815	20 2b 2b	jsr $2b2b			jsr 	PushIntegerA
.3818					_COCompileNullString:
.3818	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.381a	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.381d	a9 00		lda #$00			lda 	#0
.381f	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.3822	20 03 2a	jsr $2a03			jsr 	WriteCodeByte
.3825	60		rts				rts
.3826					_COThreeIntegers:
.3826	20 60 33	jsr $3360			jsr 	LookNextNonSpace 			; is there a ,
.3829	c9 2c		cmp #$2c			cmp 	#","
.382b	d0 eb		bne $3818			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.382d	20 6e 33	jsr $336e			jsr 	GetNext
.3830	20 19 2d	jsr $2d19			jsr 	CompileExpressionAt0 		; should be a filename
.3833	29 40		and #$40			and 	#NSSString
.3835	f0 01		beq $3838			beq 	_COType
.3837	60		rts				rts
.3838					_COType:
.3838	4c fe 1e	jmp $1efe		jmp	ErrorV_type

;******  Processing input file: _library.asm

.383b					CompilerAPI:
.383b	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.383d	f0 19		beq $3858			beq 	_CAOpenIn
.383f	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.3841	f0 23		beq $3866			beq 	_CACloseIn
.3843	c9 02		cmp #$02			cmp 	#BLC_READIN
.3845	f0 3a		beq $3881			beq 	_CARead
.3847	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.3849	f0 1e		beq $3869			beq 	_CAResetOut
.384b	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.384d	f0 23		beq $3872			beq 	_CACloseOut
.384f	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.3851	f0 20		beq $3873			beq 	_CAWriteByte
.3853	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.3855	f0 26		beq $387d			beq 	_CAPrintScreen
>3857	db						.byte 	$DB 						; causes a break in the emulator
.3858					_CAOpenIn:
.3858	a0 39		ldy #$39			ldy 	#SourceFile >> 8 			; name of file
.385a	a2 6e		ldx #$6e			ldx 	#SourceFile & $FF
.385c	20 e9 38	jsr $38e9			jsr 	IOOpenRead 					; open file
.385f	20 f4 38	jsr $38f4			jsr 	IOReadByte 					; skip the 2 byte load address header
.3862	20 f4 38	jsr $38f4			jsr 	IOReadByte
.3865	60		rts				rts
.3866					_CACloseIn:
.3866	4c 03 39	jmp $3903			jmp 	IOReadClose
.3869					_CAResetOut:
.3869	a9 00		lda #$00			lda 	#((FreeMemory) & $FF)
.386b	85 2a		sta $2a				sta 	0+objPtr
.386d	a9 3a		lda #$3a			lda 	#((FreeMemory) >> 8) & $FF
.386f	85 2b		sta $2b				sta 	1+objPtr
.3871	60		rts				rts
.3872					_CACloseOut:
.3872	60		rts				rts
.3873					_CAWriteByte:
.3873	8a		txa				txa
.3874	92 2a		sta ($2a)			sta 	(objPtr)
.3876	e6 2a		inc $2a				inc 	objPtr
.3878	d0 02		bne $387c			bne 	_HWOWBNoCarry
.387a	e6 2b		inc $2b				inc 	objPtr+1
.387c					_HWOWBNoCarry:
.387c	60		rts				rts
.387d					_CAPrintScreen:
.387d	8a		txa				txa
.387e	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.3881					_CARead:
.3881	20 f4 38	jsr $38f4			jsr 	IOReadByte 				; copy the address of next into the buffer
.3884	8d cd 06	sta $06cd			sta 	SourceLine+0
.3887	20 f4 38	jsr $38f4			jsr 	IOReadByte
.388a	8d ce 06	sta $06ce			sta 	SourceLine+1
.388d	0d cd 06	ora $06cd			ora 	sourceLine				; if both were zero, exit with CC (e.g. fail)
.3890	18		clc				clc
.3891	f0 1e		beq $38b1			beq		_CARExit
.3893	20 f4 38	jsr $38f4			jsr 	IOReadByte 				; read the line # into the buffer.
.3896	8d cf 06	sta $06cf			sta 	SourceLine+2
.3899	20 f4 38	jsr $38f4			jsr 	IOReadByte
.389c	8d d0 06	sta $06d0			sta 	SourceLine+3
.389f	a2 04		ldx #$04			ldx 	#4 						; read the body of the line.
.38a1					_CAReadLine:
.38a1	20 f4 38	jsr $38f4			jsr 	IOReadByte 				; now keep copying to EOL
.38a4	9d cd 06	sta $06cd,x			sta 	SourceLine,x
.38a7	e8		inx				inx
.38a8	c9 00		cmp #$00			cmp 	#0
.38aa	d0 f5		bne $38a1			bne 	_CAReadLine
.38ac	38		sec				sec 							; read a line okay
.38ad	a0 06		ldy #$06			ldy 	#SourceLine >> 8
.38af	a2 cd		ldx #$cd			ldx 	#SourceLine & $FF
.38b1					_CARExit:
.38b1	60		rts				rts
.06cd					SourceLine:
>06cd							.fill 	256
.38b2					WriteObjectCode:
.38b2	20 1a 08	jsr $081a			jsr 	PatchOutCompile 			; makes it run the runtime on reload
.38b5	a0 39		ldy #$39			ldy 	#ObjectFile >> 8
.38b7	a2 63		ldx #$63			ldx 	#ObjectFile & $FF
.38b9	20 ca 39	jsr $39ca			jsr 	IOOpenWrite 				; open write
.38bc	a9 01		lda #$01			lda 	#1 							; write out the load address $0801
.38be	20 d5 39	jsr $39d5			jsr 	IOWriteByte
.38c1	a9 08		lda #$08			lda 	#8
.38c3	20 d5 39	jsr $39d5			jsr 	IOWriteByte
.38c6	a9 01		lda #$01			lda 	#((StartBasicProgram) & $FF)
.38c8	85 2c		sta $2c				sta 	0+zTemp0
.38ca	a9 08		lda #$08			lda 	#((StartBasicProgram) >> 8) & $FF
.38cc	85 2d		sta $2d				sta 	1+zTemp0
.38ce					_WOCLoop:
.38ce	b2 2c		lda ($2c)			lda 	(zTemp0) 					; write code
.38d0	20 d5 39	jsr $39d5			jsr 	IOWriteByte
.38d3	e6 2c		inc $2c				inc 	zTemp0 						; advance pointer
.38d5	d0 02		bne $38d9			bne 	_WOCSkip
.38d7	e6 2d		inc $2d				inc 	zTemp0+1
.38d9					_WOCSkip:
.38d9	a5 2c		lda $2c				lda 	zTemp0 						; check end
.38db	c5 2a		cmp $2a				cmp 	objPtr
.38dd	d0 ef		bne $38ce			bne 	_WOCLoop
.38df	a5 2d		lda $2d				lda 	zTemp0+1
.38e1	c5 2b		cmp $2b				cmp 	objPtr+1
.38e3	d0 e9		bne $38ce			bne 	_WOCLoop
.38e5	20 03 39	jsr $3903			jsr 	IOWriteClose 				; close the file.
.38e8	60		rts				rts
.38e9					IOOpenRead:
.38e9	a9 52		lda #$52			lda 	#'R' 						; read.
.38eb	20 0c 39	jsr $390c			jsr 	IOSetFileName 				; set up name/LFS
.38ee	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for reading
.38f0	20 c6 ff	jsr $ffc6			jsr 	$FFC6 						; CHKIN
.38f3	60		rts				rts
.38f4					IOReadByte:
.38f4	da		phx				phx
.38f5	5a		phy				phy
.38f6	20 b7 ff	jsr $ffb7			jsr 	$FFB7 						; read ST
.38f9	38		sec				sec
.38fa	d0 04		bne $3900			bne 	_IORExit
.38fc	20 cf ff	jsr $ffcf			jsr 	$FFCF 						; read a byte
.38ff	18		clc				clc 								; status OK.
.3900					_IORExit:
.3900	7a		ply				ply
.3901	fa		plx				plx
.3902	60		rts				rts
.3903					IOReadClose:
.3903					IOWriteClose:
.3903	a9 03		lda #$03			lda 	#3 							; CLOSE# 3
.3905	20 c3 ff	jsr $ffc3			jsr 	$FFC3
.3908	20 cc ff	jsr $ffcc			jsr 	$FFCC 						; CLRCHN
.390b	60		rts				rts
.390c					IOSetFileName:
.390c	48		pha				pha 								; save R/W
.390d	86 2c		stx $2c				stx 	zTemp0
.390f	84 2d		sty $2d				sty 	zTemp0+1
.3911	a0 ff		ldy #$ff			ldy 	#$FF 						; copy name given
.3913					_IOSCopy:
.3913	c8		iny				iny 								; pre-increment copy
.3914	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.3916	99 cd 07	sta $07cd,y			sta 	IONameBuffer,y
.3919	d0 f8		bne $3913			bne 	_IOSCopy
.391b	99 d1 07	sta $07d1,y			sta 	IONameBuffer+4,y
.391e	a9 2c		lda #$2c			lda 	#',' 						; append ,S,[R|W]
.3920	99 cd 07	sta $07cd,y			sta 	IONameBuffer+0,y
.3923	99 cf 07	sta $07cf,y			sta 	IONameBuffer+2,y
.3926	a9 53		lda #$53			lda 	#'S'
.3928	99 ce 07	sta $07ce,y			sta 	IONameBuffer+1,y
.392b	68		pla				pla 								; write R/W out
.392c	99 d0 07	sta $07d0,y			sta 	IONameBuffer+3,y
.392f	98		tya				tya 								; length of name to A
.3930	18		clc				clc
.3931	69 04		adc #$04			adc 	#4 							; we added 4 characters.
.3933	a2 cd		ldx #$cd			ldx 	#IONameBuffer & $FF			; name address to YX
.3935	a0 07		ldy #$07			ldy 	#IONameBuffer >> 8
.3937	20 bd ff	jsr $ffbd		    jsr 	$FFBD          				; call SETNAM
.393a	a9 03		lda #$03	    	lda 	#3 							; set LFS to 3,8,3
.393c	a2 08		ldx #$08			ldx 	#8
.393e	a0 03		ldy #$03			ldy 	#3
.3940	20 ba ff	jsr $ffba			jsr 	$FFBA
.3943	20 c0 ff	jsr $ffc0			jsr 	$FFC0 						; OPEN
.3946	60		rts				rts
.07cd					IONameBuffer:
>07cd							.fill 	64
.3947					CompileCode:
.3947	a2 00		ldx #$00			ldx 	#0
.3949	bd 79 39	lda $3979,x	_Prompt:lda 	Prompt,x
.394c	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.394f	e8		inx				inx
.3950	c9 00		cmp #$00			cmp 	#0
.3952	d0 f5		bne $3949			bne 	_Prompt
.3954	a2 5f		ldx #$5f			ldx 	#APIDesc & $FF
.3956	a0 39		ldy #$39			ldy 	#APIDesc >> 8
.3958	20 7a 2a	jsr $2a7a			jsr 	StartCompiler
.395b	20 b2 38	jsr $38b2			jsr 	WriteObjectCode
.395e	60		rts				rts
.395f					APIDesc:
>395f	3b 38						.word 	CompilerAPI 				; the compiler API Implementeation
>3961	80						.byte 	$80 						; start of workspace for compiler $8000
>3962	9f						.byte 	$9F							; end of workspace for compiler $9F00
.3963					ObjectFile:
>3963	4f 42 4a 45 43 54 2e 50				.text 	'OBJECT.PRG',0
>396b	52 47 00
.396e					SourceFile:
>396e	53 4f 55 52 43 45 2e 50				.text 	'SOURCE.PRG',0
>3976	52 47 00
.3979					Prompt:
>3979	42 4c 49 54 5a 20 28 41				.text 	'BLITZ (ALPHA 09-10-23)',13,13,'BUGS:HTTPS://GITHUB.COM/PAULSCOTTROBSON/BLITZ-COMPILER',13,13,0
>3981	4c 50 48 41 20 30 39 2d 31 30 2d 32 33 29 0d 0d
>3991	42 55 47 53 3a 48 54 54 50 53 3a 2f 2f 47 49 54
>39a1	48 55 42 2e 43 4f 4d 2f 50 41 55 4c 53 43 4f 54
>39b1	54 52 4f 42 53 4f 4e 2f 42 4c 49 54 5a 2d 43 4f
>39c1	4d 50 49 4c 45 52 0d 0d 00
.39ca					IOOpenWrite:
.39ca	a9 57		lda #$57			lda 	#'W'			 			; write
.39cc	20 0c 39	jsr $390c			jsr 	IOSetFileName 				; set up name/LFS
.39cf	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for writing
.39d1	20 c9 ff	jsr $ffc9			jsr 	$FFC9 						; CHKOUT
.39d4	60		rts				rts
.39d5					IOWriteByte:
.39d5	48		pha				pha
.39d6	da		phx				phx
.39d7	5a		phy				phy
.39d8	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.39db	7a		ply				ply
.39dc	fa		plx				plx
.39dd	68		pla				pla
.39de	60		rts				rts

;******  Processing input file: source/main/zzfree.footer

>39df							.align 	256
.3a00					FreeMemory:

;******  End of listing
