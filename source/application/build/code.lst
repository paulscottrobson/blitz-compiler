
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl source/main/00main.header /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library _library.asm source/main/zzfree.footer
; Sat Oct 14 09:06:19 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: source/main/00main.header

.0801					StartBasicProgram:
>0801	0c 08						.word 	$080C 						; offset to next.
>0803	0a 00						.word 	10 							; line #
>0805	9e						.byte 	$9E 						; token for 'SYS'
>0806	20 32 30 36 32					.text 	' 2062'						; space, $080E in decimal
>080b	00						.byte  	0 							; end of line
>080c	00 00						.word 	0 							; end of program
.080e					StartCode:
.080e	4c ec 39	jmp $39ec			jmp 	CompileCode 				; to starting the runtime in the saved code.
.0811	a9 3b		lda #$3b			lda 	#FreeMemory >> 8 			; address of object code to run.
.0813	a2 80		ldx #$80			ldx 	#$80 						; 8000-9EFF is used for workspace.
.0815	a0 9f		ldy #$9f			ldy 	#$9F
.0817	4c 26 08	jmp $0826			jmp 	StartRuntime 				; and go do it !
.081a					PatchOutCompile:
.081a	a9 ea		lda #$ea			lda 	#$EA 						; $EA is NOP 65C02
.081c	8d 0e 08	sta $080e			sta 	StartCode 					; patch out "JMP COMPILECODE"
.081f	8d 0f 08	sta $080f			sta 	StartCode+1
.0822	8d 10 08	sta $0810			sta 	StartCode+2
.0825	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.0826					StartRuntime:
.0826	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.0829	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.082b	64 28		stz $28				stz 	codePtr
.082d	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0830	8c 06 04	sty $0406			sty 	storeEndHigh
.0833	8e 07 04	stx $0407			stx 	variableStartPage
.0836	ba		tsx				tsx 								; save the stack.
.0837	8e 08 04	stx $0408			stx 	Runtime6502SP
.083a	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.083c	a2 58		ldx #$58			ldx 	#RuntimeErrorHandler & $FF
.083e	20 26 1f	jsr $1f26			jsr 	SetErrorHandler
.0841	20 84 0a	jsr $0a84			jsr 	ClearMemory 				; clear memory.
.0844	20 a3 16	jsr $16a3			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0847	20 8f 13	jsr $138f		 	jsr		SetDefaultChannel			; set default input/output channel.
.084a	20 db 15	jsr $15db			jsr 	RestoreCode 				; which we now call
.084d	a0 00		ldy #$00			ldy 	#0
.084f					NextCommand:
.084f	ad 09 04	lda $0409			lda  	breakCount 					; only check every 16 instructions.
.0852	69 10		adc #$10			adc 	#16
.0854	8d 09 04	sta $0409			sta 	breakCount
.0857	90 07		bcc $0860			bcc 	_NXNoCheck
.0859	da		phx				phx
.085a	5a		phy				phy 								; check Ctrl+C
.085b	20 e1 1b	jsr $1be1			jsr 	XCheckStop
.085e	7a		ply				ply
.085f	fa		plx				plx
.0860					_NXNoCheck:
.0860	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.0862	30 5b		bmi $08bf			bmi 	NXCommand 					; -if -ve command
.0864	c8		iny				iny
.0865	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0867	90 39		bcc $08a2			bcc 	PushByteA 					; 0..63 is short constants.
.0869					NXLoadStore:
.0869	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.086b	b0 19		bcs $0886			bcs 	NXIndirectLoadStore
.086d	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.086e	4a		lsr a				lsr 	a
.086f	29 0e		and #$0e			and 	#$0E
.0871	da		phx				phx 								; get ready to jump
.0872	aa		tax				tax
.0873	7c 76 08	jmp ($0876,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.0876					ReadWriteVectors:
>0876	fb 14						.word 	ReadFloatCommand			; read float
>0878	f0 1a						.word 	WriteFloatCommand 			; write float
>087a	37 15						.word 	ReadIntegerCommand 			; read integer
>087c	2c 1b						.word 	WriteIntegerCommand 		; write integer
>087e	7c 15						.word 	ReadStringCommand 			; read string
>0880	6b 1b						.word 	WriteStringCommand 			; write string
>0882	55 0c						.word 	Unimplemented
>0884	55 0c						.word 	Unimplemented
.0886					NXIndirectLoadStore:
.0886	29 07		and #$07			and 	#7
.0888	0a		asl a				asl 	a
.0889	da		phx				phx
.088a	aa		tax				tax
.088b	7c 8e 08	jmp ($088e,x)			jmp 	(IndirectVectors,x)
.088e					IndirectVectors:
>088e	0c 0f						.word 	IndFloatRead 				; float read
>0890	20 0f						.word 	IndInt16Read 				; int16 read
>0892	34 0f						.word 	IndStringRead 				; string read
>0894	55 0c						.word 	Unimplemented
>0896	48 0f						.word 	IndFloatWrite				; float write
>0898	5c 0f						.word 	IndInt16Write 				; int16 write
>089a	70 0f						.word 	IndStringWrite 				; string write
>089c	55 0c						.word 	Unimplemented
.089e					PushByteCommand:
.089e	fa		plx				plx
.089f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.08a1	c8		iny				iny
.08a2					PushByteA:
.08a2	e8		inx				inx 								; push constant on stack
.08a3	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.08a5	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.08a7					ClearRestWord:
.08a7	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.08a9	74 62		stz $62,x			stz 	NSMantissa3,x
.08ab	74 6e		stz $6e,x			stz 	NSExponent,x
.08ad	74 32		stz $32,x			stz 	NSStatus,x
.08af	80 9e		bra $084f			bra 	NextCommand
.08b1					PushWordCommand:
.08b1	fa		plx				plx
.08b2	e8		inx				inx
.08b3	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.08b5	c8		iny				iny
.08b6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08b8	b1 28		lda ($28),y			lda 	(codePtr),y
.08ba	c8		iny				iny
.08bb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08bd	80 e8		bra $08a7			bra 	ClearRestWord 				; handle everything else.
.08bf					NXCommand:
.08bf	c8		iny				iny 								; consume command.
.08c0	10 03		bpl $08c5			bpl 	_NXCommandNoFixUp
.08c2	20 cb 08	jsr $08cb			jsr 	FixUpY
.08c5					_NXCommandNoFixUp:
.08c5	0a		asl a				asl 	a 							; shift left
.08c6	da		phx				phx 								; save SP on stack
.08c7	aa		tax				tax				 					; and jump indirect
.08c8	7c cd 19	jmp ($19cd,x)			jmp 	(VectorTable,x)
.08cb					FixUpY:
.08cb	48		pha				pha
.08cc	98		tya				tya
.08cd	18		clc				clc
.08ce	65 28		adc $28				adc 	codePtr
.08d0	85 28		sta $28				sta 	codePtr
.08d2	90 02		bcc $08d6			bcc 	_NoCPCarry
.08d4	e6 29		inc $29				inc 	codePtr+1
.08d6					_NoCPCarry:
.08d6	a0 00		ldy #$00			ldy 	#0
.08d8	68		pla				pla
.08d9	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.0408					Runtime6502SP:
>0408							.fill 	1
.0409					breakCount:
>0409							.fill 	1
.08da					AbsoluteTOS:
.08da	fa		plx				plx
.08db	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.08e0					CommandVarSpace:
.08e0	fa		plx				plx
.08e1	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08e3	85 26		sta $26				sta 	availableMemory
.08e5	c8		iny				iny
.08e6	b1 28		lda ($28),y			lda 	(codePtr),y
.08e8	18		clc				clc
.08e9	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08ec	85 27		sta $27				sta 	availableMemory+1
.08ee	c8		iny				iny
.08ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08f2					BinaryAnd:
.08f2	fa		plx				plx
.08f3	38		sec				sec
.08f4	80 02		bra $08f8			bra 	AndOrCommon
.08f6					BinaryOr:
.08f6	fa		plx				plx
.08f7	18		clc				clc
.08f8					AndOrCommon:
.08f8	08		php				php 								; save AND/OR flag
.08f9	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.08fc	ca		dex				dex
.08fd	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.0900	28		plp				plp
.0901	90 0e		bcc $0911			bcc 	_AOCOrCode
.0903	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.0905	35 3f		and $3f,x			and		NSMantissa0+1,x
.0907	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0909	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.090b	35 4b		and $4b,x			and		NSMantissa1+1,x
.090d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.090f	80 0c		bra $091d			bra 	_AOCComplete
.0911					_AOCOrCode:
.0911	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.0913	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.0915	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0917	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0919	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.091b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.091d					_AOCComplete:
.091d	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.091f	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.0921	10 07		bpl $092a			bpl 	_AOCExit
.0923	20 57 10	jsr $1057			jsr 	Negate16Bit 				; 2's complement
.0926	a9 80		lda #$80			lda 	#$80 						; make it -ve
.0928	95 32		sta $32,x			sta 	NSStatus,x
.092a					_AOCExit:
.092a	4c 4f 08	jmp $084f			jmp 	NextCommand
.092d					ArrayConvert:
.092d	fa		plx				plx
.092e	5a		phy				phy
.092f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0931	85 2e		sta $2e				sta 	zTemp1
.0933	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0935	18		clc				clc
.0936	6d 07 04	adc $0407			adc 	variableStartPage
.0939	85 2f		sta $2f				sta 	zTemp1+1
.093b	ca		dex				dex 								; count of indices to follow -> zTemp2
.093c	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.093f	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.0941	8a		txa				txa
.0942	38		sec				sec
.0943	e5 30		sbc $30				sbc 	zTemp2
.0945	aa		tax				tax
.0946	da		phx				phx 								; stack points at the first index, which will be replaced.
.0947					_ACIndexLoop:
.0947	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart 			; integer array index
.094a	20 47 10	jsr $1047			jsr 	GetInteger16Bit 			; get the index => zTemp0
.094d	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.094f	a5 2c		lda $2c				lda 	zTemp0
.0951	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0953	a5 2d		lda $2d				lda 	zTemp0+1
.0955	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0957	b0 79		bcs $09d2			bcs 	_ACBadIndex 				; index error.
.0959	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.095b	f0 29		beq $0986			beq 	_ACInnerLevel
.095d	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.095f	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0961	10 6f		bpl $09d2			bpl 	_ACBadIndex
.0963	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0965	26 2d		rol $2d				rol 	zTemp0+1
.0967	18		clc				clc
.0968	a5 2c		lda $2c				lda		zTemp0
.096a	65 2e		adc $2e				adc 	zTemp1
.096c	85 2c		sta $2c				sta 	zTemp0
.096e	a5 2d		lda $2d				lda		zTemp0+1
.0970	65 2f		adc $2f				adc 	zTemp1+1
.0972	85 2d		sta $2d				sta 	zTemp0+1
.0974	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.0976	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0978	85 2e		sta $2e				sta 	zTemp1
.097a	c8		iny				iny
.097b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.097d	18		clc				clc
.097e	6d 07 04	adc $0407			adc 	variableStartPage
.0981	85 2f		sta $2f				sta 	zTemp1+1
.0983	e8		inx				inx 								; next index
.0984	80 c1		bra $0947			bra 	_ACIndexLoop
.0986					_ACInnerLevel:
.0986	a0 02		ldy #$02			ldy 	#2
.0988	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.098a	30 46		bmi $09d2			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.098c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.098e	c9 00		cmp #$00			cmp 	#NSSIFloat
.0990	d0 13		bne $09a5			bne 	_ACNotFloat
.0992	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.0994	48		pha				pha
.0995	a5 2c		lda $2c				lda 	zTemp0
.0997	06 2c		asl $2c				asl 	zTemp0 						; x 2
.0999	26 2d		rol $2d				rol 	zTemp0+1
.099b	18		clc				clc 								; add back x 3
.099c	65 2c		adc $2c				adc 	zTemp0
.099e	85 2c		sta $2c				sta 	zTemp0
.09a0	68		pla				pla
.09a1	65 2d		adc $2d				adc 	zTemp0+1
.09a3	85 2d		sta $2d				sta 	zTemp0+1
.09a5					_ACNotFloat:
.09a5	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.09a7	26 2d		rol $2d				rol 	zTemp0+1
.09a9	18		clc				clc
.09aa	a5 2c		lda $2c				lda 	zTemp0
.09ac	69 03		adc #$03			adc 	#3
.09ae	85 2c		sta $2c				sta 	zTemp0
.09b0	90 02		bcc $09b4			bcc 	_ACNoCarry
.09b2	e6 2d		inc $2d				inc 	zTemp0+1
.09b4					_ACNoCarry:
.09b4	fa		plx				plx 								; X points to first slot of array parameters
.09b5	18		clc				clc
.09b6	a5 2c		lda $2c				lda 	zTemp0
.09b8	65 2e		adc $2e				adc 	zTemp1
.09ba	95 3e		sta $3e,x			sta 	NSMantissa0,x
.09bc	a5 2d		lda $2d				lda 	zTemp0+1
.09be	65 2f		adc $2f				adc 	zTemp1+1
.09c0	38		sec				sec
.09c1	ed 07 04	sbc $0407			sbc 	variableStartPage
.09c4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.09c6	74 56		stz $56,x			stz 	NSMantissa2,x
.09c8	74 62		stz $62,x			stz 	NSMantissa3,x
.09ca	74 32		stz $32,x			stz 	NSStatus,x
.09cc	74 6e		stz $6e,x			stz 	NSExponent,x
.09ce	7a		ply				ply 	 							; restore code pointer
.09cf	4c 4f 08	jmp $084f			jmp 	NextCommand
.09d2					_ACBadIndex:
.09d2	4c 28 20	jmp $2028		jmp	ErrorV_index
.09d5					UnaryAsc:
.09d5	fa		plx				plx
.09d6	5a		phy				phy
.09d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09d9	85 2c		sta $2c				sta 	zTemp0
.09db	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09dd	85 2d		sta $2d				sta 	zTemp0+1
.09df	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09e1	f0 06		beq $09e9			beq 	_UAExit
.09e3	5a		phy				phy 								; otherwise first character
.09e4	a0 01		ldy #$01			ldy 	#1
.09e6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09e8	7a		ply				ply
.09e9					_UAExit:
.09e9	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.09ec	7a		ply				ply
.09ed	4c 4f 08	jmp $084f			jmp 	NextCommand
.09f0					CommandAssert:
.09f0	fa		plx				plx
.09f1	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09f3	d0 09		bne $09fe			bne 	_CAFail
.09f5	20 c7 26	jsr $26c7			jsr 	FloatIsZero 				; is it zero ?
.09f8	f0 04		beq $09fe			beq 	_CAFail
.09fa	ca		dex				dex
.09fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.09fe					_CAFail:
.09fe	4c 81 1f	jmp $1f81		jmp	ErrorV_assert
.0a01					X16_Audio_Parameters8_16:
.0a01	20 07 0a	jsr $0a07			jsr 	X16_Audio_Parameters8_8
.0a04	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.0a06	60		rts				rts
.0a07					X16_Audio_Parameters8_8:
.0a07	a2 01		ldx #$01			ldx 	#1
.0a09	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.0a0c	ca		dex				dex
.0a0d	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.0a10	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0a13	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.0a15	a0 00		ldy #$00			ldy 	#0
.0a17	60		rts				rts
.0a18					X16_Audio_Parameters8_String:
.0a18	20 01 0a	jsr $0a01			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.0a1b	da		phx				phx 								; set the voice
.0a1c	5a		phy				phy
.0a1d	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.0a20	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>0a23	0a						.byte 	X16_AudioCodeBank
.0a24	7a		ply				ply
.0a25	fa		plx				plx
.0a26	86 2c		stx $2c				stx 	zTemp0
.0a28	84 2d		sty $2d				sty 	zTemp0+1
.0a2a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a2c	e8		inx				inx 								; point YX to first character.
.0a2d	d0 01		bne $0a30			bne 	_X16APSSkip
.0a2f	c8		iny				iny
.0a30					_X16APSSkip:
.0a30	60		rts				rts
.0a31					Unary16Bin:
.0a31	fa		plx				plx
.0a32	20 47 10	jsr $1047			jsr 	GetInteger16Bit				; 16 bit int
.0a35	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a37	20 4c 17	jsr $174c			jsr 	StringAllocTemp
.0a3a	a5 2d		lda $2d				lda 	zTemp0+1
.0a3c	f0 03		beq $0a41			beq 	_UBNoHigh
.0a3e	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a41					_UBNoHigh:
.0a41	a5 2c		lda $2c				lda 	zTemp0
.0a43	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a46	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a49					_UBWriteBinary:
.0a49	5a		phy				phy
.0a4a	a0 08		ldy #$08			ldy 	#8
.0a4c					_UBWLoop:
.0a4c	0a		asl a				asl 	a
.0a4d	48		pha				pha
.0a4e	a9 00		lda #$00			lda  	#0
.0a50	69 30		adc #$30			adc 	#48
.0a52	20 75 17	jsr $1775			jsr 	StringWriteChar
.0a55	68		pla				pla
.0a56	88		dey				dey
.0a57	d0 f3		bne $0a4c			bne 	_UBWLoop
.0a59	7a		ply				ply
.0a5a	60		rts				rts
.0a5b					PrintCharacterX:
.0a5b	fa		plx				plx
.0a5c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a5e	ca		dex				dex
.0a5f	20 93 13	jsr $1393			jsr 	VectorPrintCharacter
.0a62	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a65					UnaryChr:
.0a65	fa		plx				plx
.0a66	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get integer to convert.
.0a69	48		pha				pha 								; save it and allocate for it
.0a6a	a9 01		lda #$01			lda 	#1 							; 1 character
.0a6c	20 4c 17	jsr $174c			jsr 	StringAllocTemp
.0a6f	a9 01		lda #$01			lda 	#1 							; length 1.
.0a71	92 22		sta ($22)			sta 	(zsTemp)
.0a73	68		pla				pla 								; character code makes string.
.0a74	5a		phy				phy
.0a75	a0 01		ldy #$01			ldy 	#1
.0a77	91 22		sta ($22),y			sta 	(zsTemp),y
.0a79	7a		ply				ply
.0a7a	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a7d					CommandClr:
.0a7d	fa		plx				plx
.0a7e	20 84 0a	jsr $0a84			jsr 	ClearMemory
.0a81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a84					ClearMemory:
.0a84	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a87	85 2d		sta $2d				sta 	zTemp0+1
.0a89	64 2c		stz $2c				stz 	zTemp0
.0a8b	5a		phy				phy
.0a8c	a0 00		ldy #$00			ldy 	#0
.0a8e					_ClearLoop1:
.0a8e	a9 00		lda #$00			lda 	#0
.0a90	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a92	c8		iny				iny
.0a93	d0 f9		bne $0a8e			bne 	_ClearLoop1
.0a95	e6 2d		inc $2d				inc 	zTemp0+1
.0a97	a5 2d		lda $2d				lda 	zTemp0+1
.0a99	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a9c	d0 f0		bne $0a8e			bne 	_ClearLoop1
.0a9e	38		sec				sec 											; stack space = number of pages in total / 4
.0a9f	ad 06 04	lda $0406			lda 	storeEndHigh
.0aa2	ed 05 04	sbc $0405			sbc		storeStartHigh
.0aa5	4a		lsr a				lsr 	a
.0aa6	4a		lsr a				lsr 	a
.0aa7	d0 02		bne $0aab			bne 	_NotEmpty 								; at least 1 !
.0aa9	a9 01		lda #$01			lda 	#1
.0aab					_NotEmpty:
.0aab	38		sec				sec 											; subtract from high to give string high memory
.0aac	49 ff		eor #$ff			eor 	#$FF
.0aae	6d 06 04	adc $0406			adc 	storeEndHigh
.0ab1	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0ab4	9c 02 04	stz $0402			stz 	stringHighMemory
.0ab7	9c 6a 05	stz $056a			stz 	stringInitialised 						; string system not initialised
.0aba	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0abd	3a		dec a				dec 	a
.0abe	85 25		sta $25				sta 	runtimeStackPtr+1
.0ac0	a9 ff		lda #$ff			lda 	#$FF
.0ac2	85 24		sta $24				sta 	runtimeStackPtr
.0ac4	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0ac6	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0ac8	7a		ply				ply
.0ac9	60		rts				rts
.0aca					CompareStrings:
.0aca	fa		plx				plx
.0acb	ca		dex				dex
.0acc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0ace	85 2c		sta $2c				sta 	zTemp0
.0ad0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ad2	85 2d		sta $2d				sta 	zTemp0+1
.0ad4	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0ad6	85 2e		sta $2e				sta 	zTemp1
.0ad8	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0ada	85 2f		sta $2f				sta 	zTemp1+1
.0adc	da		phx				phx
.0add	5a		phy				phy
.0ade	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0ae0	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0ae2	90 02		bcc $0ae6			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0ae4	b2 2e		lda ($2e)			lda 	(zTemp1)
.0ae6					_CSNIsSmallest:
.0ae6	aa		tax				tax 								; count in X
.0ae7	f0 0c		beq $0af5			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0ae9	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0aeb					_CSNCompareString:
.0aeb	c8		iny				iny 								; pre increment
.0aec	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0aee	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0af0	d0 0a		bne $0afc			bne 	_CSNDifferent 				; numbers are different.
.0af2	ca		dex				dex
.0af3	d0 f6		bne $0aeb			bne 	_CSNCompareString 			; compare common characters in two strings.
.0af5					_CSNMatches:
.0af5	38		sec				sec
.0af6	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0af8	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0afa	f0 06		beq $0b02			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0afc					_CSNDifferent:
.0afc	a9 ff		lda #$ff			lda 	#$FF
.0afe	90 02		bcc $0b02			bcc 	_CSNSExit
.0b00	a9 01		lda #$01			lda 	#$01
.0b02					_CSNSExit:
.0b02	7a		ply				ply
.0b03	fa		plx				plx
.0b04	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0b06	20 a7 26	jsr $26a7			jsr 	FloatSetByte 				; output the byte
.0b09	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b0c					StringConcrete:
.0b0c	9c 6a 05	stz $056a			stz 	stringInitialised	 		; initialise next usage
.0b0f	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0b11	85 30		sta $30				sta 	zTemp2
.0b13	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0b15	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0b16	18		clc				clc
.0b17	72 30		adc ($30)			adc 	(zTemp2)
.0b19	90 02		bcc $0b1d			bcc 	_SCNoOverflow
.0b1b	a9 ff		lda #$ff			lda 	#255
.0b1d					_SCNoOverflow:
.0b1d	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0b1f	b0 02		bcs $0b23			bcs 	_SCNoMinimum
.0b21	a9 0a		lda #$0a			lda 	#10
.0b23					_SCNoMinimum:
.0b23	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0b25	38		sec				sec
.0b26	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0b29	e5 2e		sbc $2e				sbc 	zTemp1
.0b2b	a8		tay				tay
.0b2c	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b2f	e9 00		sbc #$00			sbc 	#0
.0b31	48		pha				pha
.0b32	38		sec				sec 								; subtract 3 more
.0b33	98		tya				tya
.0b34	e9 03		sbc #$03			sbc 	#3
.0b36	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b39	85 22		sta $22				sta 	zsTemp
.0b3b	68		pla				pla
.0b3c	e9 00		sbc #$00			sbc 	#0
.0b3e	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b41	85 23		sta $23				sta 	zsTemp+1
.0b43	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b45	92 22		sta ($22)			sta 	(zsTemp)
.0b47	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b49	a9 00		lda #$00			lda 	#0
.0b4b	91 22		sta ($22),y			sta 	(zsTemp),y
.0b4d	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b4f	a4 23		ldy $23				ldy 	zsTemp+1
.0b51	60		rts				rts
.0b52					CommandXData:
.0b52	fa		plx				plx
.0b53	98		tya				tya 								; data length +1 added to Y
.0b54	38		sec				sec
.0b55	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b57	a8		tay				tay
.0b58	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b5b					CommandXDIM:
.0b5b	fa		plx				plx
.0b5c	5a		phy				phy
.0b5d	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b60	8d 0a 04	sta $040a			sta 	dimType
.0b63	ca		dex				dex 								; this is the number of indices
.0b64	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0b67	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b69	8a		txa				txa 								; dimension.
.0b6a	38		sec				sec
.0b6b	e5 2e		sbc $2e				sbc 	zTemp1
.0b6d	aa		tax				tax
.0b6e	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b70	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create one at this level
.0b73	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b75	98		tya				tya
.0b76	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b78	74 56		stz $56,x			stz 	NSMantissa2,x
.0b7a	74 62		stz $62,x			stz 	NSMantissa3,x
.0b7c	74 32		stz $32,x			stz 	NSStatus,x
.0b7e	74 6e		stz $6e,x			stz 	NSExponent,x
.0b80	7a		ply				ply
.0b81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b84					DIMCreateOneLevel:
.0b84	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b86	5a		phy				phy
.0b87	a4 27		ldy $27				ldy 	availableMemory+1
.0b89	5a		phy				phy
.0b8a	a8		tay				tay 			 					; save current level into Y
.0b8b	20 47 10	jsr $1047			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b8e	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b90	d0 02		bne $0b94			bne 	_DCOLNoCarry
.0b92	e6 2d		inc $2d				inc 	zTemp0+1
.0b94					_DCOLNoCarry:
.0b94	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b96	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b99	a5 2d		lda $2d				lda 	zTemp0+1
.0b9b	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b9e	ad 0a 04	lda $040a			lda 	dimType 					; get type information
.0ba1	29 7f		and #$7f			and 	#$7F
.0ba3	c0 01		cpy #$01			cpy 	#1
.0ba5	f0 02		beq $0ba9			beq 	_DCOLNoSubLevel
.0ba7	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0ba9					_DCOLNoSubLevel:
.0ba9	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0bac	a5 26		lda $26				lda 	availableMemory
.0bae	85 2e		sta $2e				sta 	zTemp1
.0bb0	a5 27		lda $27				lda 	availableMemory+1
.0bb2	85 2f		sta $2f				sta 	zTemp1+1
.0bb4	a5 2c		lda $2c				lda 	zTemp0
.0bb6	85 30		sta $30				sta 	zTemp2
.0bb8	a5 2d		lda $2d				lda 	zTemp0+1
.0bba	85 31		sta $31				sta 	zTemp2+1
.0bbc					_DCOLFillArray:
.0bbc	20 1b 0c	jsr $0c1b			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0bbf	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0bc1	d0 02		bne $0bc5			bne 	_DCOLNoBorrow
.0bc3	c6 2d		dec $2d				dec 	zTemp0+1
.0bc5					_DCOLNoBorrow:
.0bc5	c6 2c		dec $2c				dec 	zTemp0
.0bc7	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0bc9	05 2d		ora $2d				ora 	zTemp0+1
.0bcb	d0 ef		bne $0bbc			bne 	_DCOLFillArray
.0bcd	c0 01		cpy #$01			cpy 	#1
.0bcf	f0 42		beq $0c13			beq 	_DCOLExit
.0bd1					_DCOLRecursionLoop:
.0bd1	da		phx				phx 								; save XY
.0bd2	5a		phy				phy
.0bd3	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0bd5	48		pha				pha
.0bd6	a5 2f		lda $2f				lda 	zTemp1+1
.0bd8	48		pha				pha
.0bd9	a5 30		lda $30				lda 	zTemp2
.0bdb	48		pha				pha
.0bdc	a5 31		lda $31				lda 	zTemp2+1
.0bde	48		pha				pha
.0bdf	88		dey				dey  								; lower level -> A
.0be0	98		tya				tya
.0be1	e8		inx				inx 								; next index size
.0be2	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0be5	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0be6	86 31		stx $31				stx 	zTemp2+1
.0be8	fa		plx				plx
.0be9	86 30		stx $30				stx 	zTemp2
.0beb	fa		plx				plx
.0bec	86 2f		stx $2f				stx 	zTemp1+1
.0bee	fa		plx				plx
.0bef	86 2e		stx $2e				stx 	zTemp1
.0bf1	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0bf3	98		tya				tya
.0bf4	a0 01		ldy #$01			ldy 	#1
.0bf6	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0bf8	7a		ply				ply 								; restore XY
.0bf9	fa		plx				plx
.0bfa	18		clc				clc
.0bfb	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0bfd	69 02		adc #$02			adc 	#2
.0bff	85 2e		sta $2e				sta 	zTemp1
.0c01	90 02		bcc $0c05			bcc 	_DCOLRNoCarry
.0c03	e6 2f		inc $2f				inc 	zTemp1+1
.0c05					_DCOLRNoCarry:
.0c05	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0c07	d0 02		bne $0c0b			bne 	_DCOLRNoBorrow
.0c09	c6 31		dec $31				dec 	zTemp2+1
.0c0b					_DCOLRNoBorrow:
.0c0b	c6 30		dec $30				dec 	zTemp2
.0c0d	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0c0f	05 31		ora $31				ora 	zTemp2+1
.0c11	d0 be		bne $0bd1			bne 	_DCOLRecursionLoop
.0c13					_DCOLExit:
.0c13	68		pla				pla 								; get MSB, make offset again
.0c14	38		sec				sec
.0c15	ed 07 04	sbc $0407			sbc 	variableStartPage
.0c18	a8		tay				tay
.0c19	68		pla				pla 								; YA now contains offset address.
.0c1a	60		rts				rts
.0c1b					DIMWriteElement:
.0c1b	da		phx				phx
.0c1c	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0c1e	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0c20	d0 0b		bne $0c2d			bne 	_DIMWENotFloat
.0c22	ad 0a 04	lda $040a			lda 	dimType
.0c25	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0c27	c9 00		cmp #$00			cmp 	#NSSIFloat
.0c29	d0 02		bne $0c2d			bne 	_DIMWENotFloat
.0c2b	a2 06		ldx #$06			ldx 	#6
.0c2d					_DIMWENotFloat:
.0c2d	a9 00		lda #$00			lda 	#0
.0c2f	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0c32	ca		dex				dex
.0c33	d0 f8		bne $0c2d			bne 	_DIMWENotFloat
.0c35	fa		plx				plx
.0c36	60		rts				rts
.0c37					DIMWriteByte:
.0c37	92 26		sta ($26)			sta 	(availableMemory)
.0c39	e6 26		inc $26				inc 	availableMemory
.0c3b	d0 0b		bne $0c48			bne 	_DIMWBSkip
.0c3d	e6 27		inc $27				inc 	availableMemory+1
.0c3f	48		pha				pha
.0c40	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c42	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c45	b0 02		bcs $0c49			bcs 	_DIMWBMemory
.0c47	68		pla				pla
.0c48					_DIMWBSkip:
.0c48	60		rts				rts
.0c49					_DIMWBMemory:
.0c49	4c 3b 20	jmp $203b		jmp	ErrorV_memory
.040a					dimType:
>040a							.fill 	1
.0c4c					CommandEnd:
.0c4c	fa		plx				plx
.0c4d	86 2c		stx $2c				stx 	zTemp0
.0c4f	18		clc				clc 								; exited okay.
.0c50					EndRuntime:
.0c50	ae 08 04	ldx $0408			ldx 	Runtime6502SP 				; set up the stack pointer
.0c53	9a		txs				txs
.0c54	60		rts				rts
.0c55					Unimplemented:
.0c55	4c 6e 1f	jmp $1f6e			jmp 	ErrorV_unimplemented
.0c58					RuntimeErrorHandler:
.0c58	98		tya				tya
.0c59	18		clc				clc
.0c5a	65 28		adc $28				adc 	codePtr
.0c5c	85 28		sta $28				sta 	codePtr
.0c5e	90 02		bcc $0c62			bcc 	_EHNoCarry
.0c60	e6 29		inc $29				inc 	codePtr+1
.0c62					_EHNoCarry:
.0c62	68		pla				pla
.0c63	7a		ply				ply
.0c64	85 2c		sta $2c				sta 	zTemp0
.0c66	84 2d		sty $2d				sty 	zTemp0+1
.0c68	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c6a	a0 01		ldy #$01			ldy 	#1
.0c6c					_EHDisplayMsg:
.0c6c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c6e	20 ce 1c	jsr $1cce			jsr 	XPrintCharacterToChannel
.0c71	c8		iny				iny
.0c72	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c74	d0 f6		bne $0c6c			bne 	_EHDisplayMsg
.0c76	a9 20		lda #$20			lda 	#32
.0c78	20 ce 1c	jsr $1cce			jsr 	XPrintCharacterToChannel
.0c7b	a9 40		lda #$40			lda 	#64
.0c7d	20 ce 1c	jsr $1cce			jsr 	XPrintCharacterToChannel
.0c80	a9 20		lda #$20			lda 	#32
.0c82	20 ce 1c	jsr $1cce			jsr 	XPrintCharacterToChannel
.0c85	20 8c 0c	jsr $0c8c			jsr 	EHDisplayCodePtr
.0c88	38		sec				sec 								; report error.
.0c89	4c 50 0c	jmp $0c50			jmp 	EndRuntime
.0c8c					EHDisplayCodePtr:
.0c8c	a9 24		lda #$24			lda 	#'$'
.0c8e	20 ce 1c	jsr $1cce			jsr 	XPrintCharacterToChannel
.0c91	38		sec				sec
.0c92	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c94	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c97	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9a	a5 28		lda $28				lda 	codePtr
.0c9c	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9f	60		rts				rts
.0ca0					_EHDisplayHex:
.0ca0	48		pha				pha
.0ca1	4a		lsr a				lsr 	a
.0ca2	4a		lsr a				lsr 	a
.0ca3	4a		lsr a				lsr 	a
.0ca4	4a		lsr a				lsr 	a
.0ca5	20 a9 0c	jsr $0ca9			jsr 	_EHDisplayNibble
.0ca8	68		pla				pla
.0ca9					_EHDisplayNibble:
.0ca9	29 0f		and #$0f			and 	#15
.0cab	c9 0a		cmp #$0a			cmp 	#10
.0cad	90 02		bcc $0cb1			bcc 	_EHNotHex
.0caf	69 06		adc #$06			adc 	#6
.0cb1					_EHNotHex:
.0cb1	69 30		adc #$30			adc 	#48
.0cb3	4c ce 1c	jmp $1cce			jmp 	XPrintCharacterToChannel
.0cb6					CommandXFor:
.0cb6	fa		plx				plx
.0cb7	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0cb9	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0cbc	20 78 11	jsr $1178			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0cbf	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0cc1	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cc4	ca		dex				dex
.0cc5	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0cc7	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cca	ca		dex				dex
.0ccb	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0ccd	29 80		and #$80			and 	#$80
.0ccf	a0 04		ldy #$04			ldy 	#4
.0cd1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd3	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0cd5	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0cd7	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd9	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0cdb	c8		iny				iny
.0cdc	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cde	18		clc				clc
.0cdf	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0ce1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ce3	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0ce6	85 2d		sta $2d				sta 	zTemp0+1
.0ce8	ca		dex				dex 								; throw reference.
.0ce9	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0ceb	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0ced	a0 0c		ldy #$0c			ldy 	#12
.0cef	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf1	a0 12		ldy #$12			ldy 	#18
.0cf3	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf5	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0cf7	88		dey				dey 								; now the exponents.
.0cf8	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0cfa	a0 0b		ldy #$0b			ldy 	#11
.0cfc	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cfe	a0 11		ldy #$11			ldy 	#17
.0d00	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d02	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0d04	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d06	c8		iny				iny
.0d07	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d09	c8		iny				iny
.0d0a	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d0c	d0 08		bne $0d16			bne 	_CFNoOptimise
.0d0e	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0d10	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0d12	09 40		ora #$40			ora 	#$40
.0d14	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d16					_CFNoOptimise:
.0d16	a0 00		ldy #$00			ldy 	#0
.0d18	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d1b					CopyTOSToOffsetY:
.0d1b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0d1d	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d1f	c8		iny				iny
.0d20	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0d22	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d24	c8		iny				iny
.0d25	b5 56		lda $56,x			lda 	NSMantissa2,x
.0d27	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d29	c8		iny				iny
.0d2a	b5 62		lda $62,x			lda 	NSMantissa3,x
.0d2c	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d2e	c8		iny				iny
.0d2f	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d31	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d33	c8		iny				iny
.0d34	b5 32		lda $32,x			lda 	NSStatus,x
.0d36	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d38	60		rts				rts
.0d39					StackOpenFrame:
.0d39	48		pha				pha 								; save frame marker
.0d3a	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d3c	85 2c		sta $2c				sta 	zTemp0
.0d3e	38		sec				sec 								; subtract from runtime stack pointer.
.0d3f	a5 24		lda $24				lda		runtimeStackPtr
.0d41	e5 2c		sbc $2c				sbc 	zTemp0
.0d43	85 24		sta $24				sta 	runtimeStackPtr
.0d45	a5 25		lda $25				lda		runtimeStackPtr+1
.0d47	e9 00		sbc #$00			sbc 	#0
.0d49	85 25		sta $25				sta 	runtimeStackPtr+1
.0d4b	68		pla				pla 								; put frame marker at +0
.0d4c	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d4e	60		rts				rts
.0d4f					StackCloseFrame:
.0d4f	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d51	29 1f		and #$1f			and 	#$1F 						; size
.0d53	18		clc				clc
.0d54	65 24		adc $24				adc 	runtimeStackPtr
.0d56	85 24		sta $24				sta 	runtimeStackPtr
.0d58	90 02		bcc $0d5c			bcc 	_SCFNoCarry
.0d5a	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d5c					_SCFNoCarry:
.0d5c	60		rts				rts
.0d5d					StackFindFrame:
.0d5d	8d 0b 04	sta $040b			sta 	requiredFrame
.0d60					_SFFLoop:
.0d60	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d62	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d64	f0 10		beq $0d76			beq 	SCFFail
.0d66	cd 0b 04	cmp $040b			cmp 	requiredFrame 				; found this type ?
.0d69	f0 05		beq $0d70			beq 	_SFFFound
.0d6b	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close the top frame
.0d6e	80 f0		bra $0d60			bra 	_SFFLoop 					; and try te next.
.0d70					_SFFFound:
.0d70	60		rts				rts
.0d71					StackCheckFrame:
.0d71	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d73	d0 01		bne $0d76			bne 	SCFFail
.0d75	60		rts				rts
.0d76					SCFFail:
.0d76	4c cb 1f	jmp $1fcb		jmp	ErrorV_structure
.040b					requiredFrame:
>040b							.fill 	1
.0d79					UnaryFre:
.0d79	fa		plx				plx
.0d7a	20 a5 26	jsr $26a5			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d7d	38		sec				sec
.0d7e	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d81	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d84	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d86	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d89	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d8c	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d8e	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d91					CommandXGet:
.0d91	fa		plx				plx
.0d92	e8		inx				inx
.0d93	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d95	20 4c 17	jsr $174c			jsr 	StringAllocTemp
.0d98	20 9c 13	jsr $139c			jsr 	VectorGetCharacter 			; get a character
.0d9b	c9 00		cmp #$00			cmp 	#0
.0d9d	f0 09		beq $0da8			beq 	_CGNone
.0d9f	5a		phy				phy
.0da0	a0 01		ldy #$01			ldy 	#1 							; store char
.0da2	91 22		sta ($22),y			sta 	(zsTemp),y
.0da4	98		tya				tya 								; store length.
.0da5	92 22		sta ($22)			sta 	(zsTemp)
.0da7	7a		ply				ply
.0da8					_CGNone:
.0da8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dab					CommandXGosub:
.0dab	fa		plx				plx
.0dac	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dae	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0db1	20 78 11	jsr $1178			jsr 	StackSaveCurrentPosition
.0db4	4c c9 0d	jmp $0dc9			jmp 	PerformGOTO
.0db7					CommandReturn:
.0db7	fa		plx				plx
.0db8	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dba	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.0dbd	20 89 11	jsr $1189			jsr 	StackLoadCurrentPosition
.0dc0	c8		iny				iny
.0dc1	c8		iny				iny
.0dc2	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame
.0dc5	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dc8					CommandXGoto:
.0dc8	fa		plx				plx
.0dc9					PerformGOTO:
.0dc9	c8		iny				iny 								; push MSB of offset on stack
.0dca	b1 28		lda ($28),y			lda 	(codePtr),y
.0dcc	48		pha				pha
.0dcd	88		dey				dey 								; point LSB of offset
.0dce	18		clc				clc 								; add LSB
.0dcf	b1 28		lda ($28),y			lda 	(codePtr),y
.0dd1	65 28		adc $28				adc 	codePtr
.0dd3	85 28		sta $28				sta 	codePtr
.0dd5	68		pla				pla 								; restore offset MSB and add
.0dd6	65 29		adc $29				adc 	codePtr+1
.0dd8	85 29		sta $29				sta 	codePtr+1
.0dda	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ddd					CommandGotoZ:
.0ddd	fa		plx				plx
.0dde	20 c7 26	jsr $26c7			jsr 	FloatIsZero
.0de1	ca		dex				dex
.0de2	c9 00		cmp #$00			cmp 	#0
.0de4	f0 e3		beq $0dc9			beq 	PerformGOTO
.0de6	c8		iny				iny
.0de7	c8		iny				iny
.0de8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0deb					CommandGotoNZ:
.0deb	fa		plx				plx
.0dec	20 c7 26	jsr $26c7			jsr 	FloatIsZero
.0def	ca		dex				dex
.0df0	c9 00		cmp #$00			cmp 	#0
.0df2	d0 d5		bne $0dc9			bne 	PerformGOTO
.0df4	c8		iny				iny
.0df5	c8		iny				iny
.0df6	4c 4f 08	jmp $084f			jmp 	NextCommand
.0df9					Command_PSET:
.0df9	fa		plx				plx
.0dfa	5a		phy				phy
.0dfb	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the colour
.0dfe	48		pha				pha
.0dff	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e01	a0 02		ldy #$02			ldy 	#X16_r0
.0e03	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e06	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0e09	68		pla				pla 								; set pixel.
.0e0a	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0e0d	7a		ply				ply
.0e0e	a2 ff		ldx #$ff			ldx 	#$FF
.0e10	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e13					Command_LINE:
.0e13	fa		plx				plx
.0e14	5a		phy				phy
.0e15	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e18	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0e1a	a0 02		ldy #$02			ldy 	#X16_r0
.0e1c	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0e1f	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0e22	7a		ply				ply
.0e23	a2 ff		ldx #$ff			ldx 	#$FF
.0e25	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e28					Command_RECT:
.0e28	fa		plx				plx
.0e29	5a		phy				phy
.0e2a	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e2d	38		sec				sec
.0e2e	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e31	7a		ply				ply
.0e32	a2 ff		ldx #$ff			ldx 	#$FF
.0e34	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e37					Command_FRAME:
.0e37	fa		plx				plx
.0e38	5a		phy				phy
.0e39	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e3c	18		clc				clc
.0e3d	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e40	7a		ply				ply
.0e41	a2 ff		ldx #$ff			ldx 	#$FF
.0e43	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e46					Command_CHAR:
.0e46	fa		plx				plx
.0e47	5a		phy				phy
.0e48	ca		dex				dex  								; set the draw colour
.0e49	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e4c	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e4e	a0 02		ldy #$02			ldy 	#X16_r0
.0e50	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e53	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e55	85 2c		sta $2c				sta 	zTemp0
.0e57	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e59	85 2d		sta $2d				sta 	zTemp0+1
.0e5b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e5d	85 2e		sta $2e				sta 	zTemp1
.0e5f					_CCLoop:
.0e5f	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e61	f0 0f		beq $0e72			beq 	_CCExit
.0e63	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e65	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e67	d0 02		bne $0e6b			bne 	_CCNoCarry
.0e69	e6 2d		inc $2d				inc 	zTemp0+1
.0e6b					_CCNoCarry:
.0e6b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e6d	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e70	80 ed		bra $0e5f			bra 	_CCLoop						; go round.
.0e72					_CCExit:
.0e72	7a		ply				ply
.0e73	a2 ff		ldx #$ff			ldx 	#$FF
.0e75	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e78					GraphicsColour:
.0e78	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0e7b	aa		tax				tax
.0e7c	a0 00		ldy #$00			ldy 	#0
.0e7e	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e81	60		rts				rts
.0e82					GraphicsCopy4:
.0e82	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e85					GraphicsCopy2:
.0e85	20 88 0e	jsr $0e88			jsr 	GraphicsCopy1
.0e88					GraphicsCopy1:
.0e88	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.0e8b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e8d	99 00 00	sta $0000,y			sta 	0,y
.0e90	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e92	99 01 00	sta $0001,y			sta 	1,y
.0e95	e8		inx				inx
.0e96	c8		iny				iny
.0e97	c8		iny				iny
.0e98	60		rts				rts
.0e99					GraphicsRectCoords:
.0e99	20 78 0e	jsr $0e78			jsr 	GraphicsColour 				; set colour
.0e9c	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e9e	a0 02		ldy #$02			ldy 	#X16_r0
.0ea0	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0ea3	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0ea5	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ea8	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0eaa	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ead	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0eaf	74 09		stz $09,x			stz 	9,x
.0eb1	60		rts				rts
.0eb2					_GRCSortSubtract:
.0eb2	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0eb4	d5 00		cmp $00,x			cmp 	0,x
.0eb6	b5 05		lda $05,x			lda 	5,x
.0eb8	f5 01		sbc $01,x			sbc 	1,x
.0eba	b0 08		bcs $0ec4			bcs 	_GRCNoSwap 					; >= swap.
.0ebc	20 d2 0e	jsr $0ed2			jsr 	_GRCSwapByte 				; swap 0/2
.0ebf	e8		inx				inx
.0ec0	20 d2 0e	jsr $0ed2			jsr 	_GRCSwapByte 				; swap 1/3
.0ec3	ca		dex				dex
.0ec4					_GRCNoSwap:
.0ec4	38		sec				sec 								; calculate width/height into 4,5
.0ec5	b5 04		lda $04,x			lda 	4,x
.0ec7	f5 00		sbc $00,x			sbc 	0,x
.0ec9	95 04		sta $04,x			sta 	4,x
.0ecb	b5 05		lda $05,x			lda 	5,x
.0ecd	f5 01		sbc $01,x			sbc 	1,x
.0ecf	95 05		sta $05,x			sta 	5,x
.0ed1	60		rts				rts
.0ed2					_GRCSwapByte:
.0ed2	b5 04		lda $04,x			lda 	4,x
.0ed4	48		pha				pha
.0ed5	b5 00		lda $00,x			lda 	0,x
.0ed7	95 04		sta $04,x			sta 	4,x
.0ed9	68		pla				pla
.0eda	95 00		sta $00,x			sta 	0,x
.0edc	60		rts				rts
.0edd					Unary16Hex:
.0edd	fa		plx				plx
.0ede	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.0ee1	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0ee3	20 4c 17	jsr $174c			jsr 	StringAllocTemp
.0ee6	a5 2d		lda $2d				lda 	zTemp0+1
.0ee8	f0 03		beq $0eed			beq 	_UHNoHigh
.0eea	20 f5 0e	jsr $0ef5			jsr 	_UHWriteHex
.0eed					_UHNoHigh:
.0eed	a5 2c		lda $2c				lda 	zTemp0
.0eef	20 f5 0e	jsr $0ef5			jsr 	_UHWriteHex
.0ef2	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ef5					_UHWriteHex:
.0ef5	48		pha				pha
.0ef6	4a		lsr a				lsr 	a
.0ef7	4a		lsr a				lsr 	a
.0ef8	4a		lsr a				lsr 	a
.0ef9	4a		lsr a				lsr 	a
.0efa	20 fe 0e	jsr $0efe			jsr 	_UHWriteNibl
.0efd	68		pla				pla
.0efe					_UHWriteNibl:
.0efe	29 0f		and #$0f			and 	#15
.0f00	c9 0a		cmp #$0a			cmp 	#10
.0f02	90 02		bcc $0f06			bcc 	_UHDigit
.0f04	69 06		adc #$06			adc 	#6
.0f06					_UHDigit:
.0f06	69 30		adc #$30			adc 	#48
.0f08	20 75 17	jsr $1775			jsr 	StringWriteChar
.0f0b	60		rts				rts
.0f0c					IndFloatRead:
.0f0c	fa		plx				plx
.0f0d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f0f	85 2c		sta $2c				sta 	zTemp0
.0f11	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f13	18		clc				clc
.0f14	6d 07 04	adc $0407			adc 	variableStartPage
.0f17	85 2d		sta $2d				sta 	zTemp0+1
.0f19	ca		dex				dex 								; throw the address
.0f1a	20 15 15	jsr $1515			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0f1d	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f20					IndInt16Read:
.0f20	fa		plx				plx
.0f21	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f23	85 2c		sta $2c				sta 	zTemp0
.0f25	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f27	18		clc				clc
.0f28	6d 07 04	adc $0407			adc 	variableStartPage
.0f2b	85 2d		sta $2d				sta 	zTemp0+1
.0f2d	ca		dex				dex 								; throw the address
.0f2e	20 51 15	jsr $1551			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f31	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f34					IndStringRead:
.0f34	fa		plx				plx
.0f35	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f37	85 2c		sta $2c				sta 	zTemp0
.0f39	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f3b	18		clc				clc
.0f3c	6d 07 04	adc $0407			adc 	variableStartPage
.0f3f	85 2d		sta $2d				sta 	zTemp0+1
.0f41	ca		dex				dex 								; throw the address
.0f42	20 96 15	jsr $1596			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f45	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f48					IndFloatWrite:
.0f48	fa		plx				plx
.0f49	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f4b	85 2c		sta $2c				sta 	zTemp0
.0f4d	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f4f	18		clc				clc
.0f50	6d 07 04	adc $0407			adc 	variableStartPage
.0f53	85 2d		sta $2d				sta 	zTemp0+1
.0f55	20 0a 1b	jsr $1b0a			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f58	ca		dex				dex 								; throw the address as well.
.0f59	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f5c					IndInt16Write:
.0f5c	fa		plx				plx
.0f5d	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f5f	85 2c		sta $2c				sta 	zTemp0
.0f61	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f63	18		clc				clc
.0f64	6d 07 04	adc $0407			adc 	variableStartPage
.0f67	85 2d		sta $2d				sta 	zTemp0+1
.0f69	20 46 1b	jsr $1b46			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f6c	ca		dex				dex 								; throw the address as well.
.0f6d	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f70					IndStringWrite:
.0f70	fa		plx				plx
.0f71	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f73	85 2c		sta $2c				sta 	zTemp0
.0f75	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f77	18		clc				clc
.0f78	6d 07 04	adc $0407			adc 	variableStartPage
.0f7b	85 2d		sta $2d				sta 	zTemp0+1
.0f7d	20 85 1b	jsr $1b85			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f80	ca		dex				dex 								; throw the address as well.
.0f81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f84					CommandXInput:
.0f84	fa		plx				plx
.0f85	5a		phy				phy 								; save Y
.0f86	e8		inx				inx									; space on stack
.0f87					_INError:
.0f87	20 bb 0f	jsr $0fbb			jsr 	InputStringToBuffer 		; input from keyboard
.0f8a	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.0f8c	85 2c		sta $2c				sta 	0+zTemp0
.0f8e	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f90	85 2d		sta $2d				sta 	1+zTemp0
.0f92	20 93 19	jsr $1993			jsr 	ValEvaluateZTemp0
.0f95	b0 f0		bcs $0f87			bcs 	_INError 					; failed, try again.
.0f97	7a		ply				ply 								; restore Y
.0f98	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f9b					CommandInputString:
.0f9b	fa		plx				plx
.0f9c	5a		phy				phy 								; save Y
.0f9d	20 bb 0f	jsr $0fbb			jsr 	InputStringToBuffer 		; input from keyboard
.0fa0	e8		inx				inx 								; make space on stack
.0fa1	20 a5 26	jsr $26a5			jsr 	FloatSetZero 				; store as string on stack
.0fa4	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.0fa6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0fa8	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0faa	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0fac	a9 40		lda #$40			lda 	#NSSString
.0fae	95 32		sta $32,x			sta 	NSStatus,x
.0fb0	7a		ply				ply 								; restore Y
.0fb1	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fb4					CommandInputReset:
.0fb4	fa		plx				plx
.0fb5	9c 0c 04	stz $040c			stz 	InputBuffer
.0fb8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fbb					InputStringToBuffer:
.0fbb	a9 f5		lda #$f5			lda 	#((InputBumpNext) & $FF)
.0fbd	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.0fc0	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0fc2	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.0fc5	a9 d2		lda #$d2			lda 	#((InputLookNext) & $FF)
.0fc7	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.0fca	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0fcc	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.0fcf	4c 72 14	jmp $1472			jmp 	GetStringToBuffer
.0fd2					InputLookNext:
.0fd2	da		phx				phx
.0fd3					_ILNRetry:
.0fd3	ad 0c 04	lda $040c			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fd6	d0 08		bne $0fe0			bne 	_ILNNotEmpty
.0fd8	20 f9 0f	jsr $0ff9			jsr 	InputGetNewLine 			; get a new line
.0fdb	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset read position.
.0fde	80 f3		bra $0fd3			bra 	_ILNRetry
.0fe0					_ILNNotEmpty:
.0fe0	ae 5d 04	ldx $045d			ldx 	InputBufferPos 				; get head available character
.0fe3	bd 0c 04	lda $040c,x			lda 	InputBuffer,x
.0fe6	d0 08		bne $0ff0			bne 	_ILNExit 					; if not EOS return it with CC.
.0fe8					_ILNNextLine:
.0fe8	9c 0c 04	stz $040c			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0feb	38		sec				sec 								; return CS,Zero
.0fec	fa		plx				plx
.0fed	a9 0d		lda #$0d			lda 	#13
.0fef	60		rts				rts
.0ff0					_ILNExit:
.0ff0	fa		plx				plx
.0ff1	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0ff3	18		clc				clc
.0ff4	60		rts				rts
.0ff5					InputBumpNext:
.0ff5	ee 5d 04	inc $045d			inc 	InputBufferPos
.0ff8	60		rts				rts
.0ff9					InputGetNewLine:
.0ff9	48		pha				pha
.0ffa	da		phx				phx
.0ffb	5a		phy				phy
.0ffc	a9 3f		lda #$3f			lda 	#"?"
.0ffe	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.1001	a0 00		ldy #$00			ldy 	#0 							; line position.
.1003					_IGNLLoop:
.1003	20 9c 13	jsr $139c			jsr 	VectorGetCharacter 			; get a character
.1006	c9 00		cmp #$00			cmp 	#0
.1008	f0 f9		beq $1003			beq 	_IGNLLoop
.100a	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.100c	f0 11		beq $101f			beq 	_IGNBackspace
.100e	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.1010	f0 17		beq $1029			beq 	_IGNExit
.1012	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.1014	f0 ed		beq $1003			beq 	_IGNLLoop
.1016	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1019	c8		iny				iny
.101a	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.101d	80 e4		bra $1003			bra 	_IGNLLoop
.101f					_IGNBackspace:
.101f	c0 00		cpy #$00			cpy 	#0
.1021	f0 e0		beq $1003			beq 	_IGNLLoop
.1023	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.1026	88		dey				dey
.1027	80 da		bra $1003			bra 	_IGNLLoop
.1029					_IGNExit:
.1029	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.102c	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.102e	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1031	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset position to start of input buffer.
.1034	7a		ply				ply
.1035	fa		plx				plx
.1036	68		pla				pla
.1037	60		rts				rts
.1038					IGNLEchoIfScreen:
.1038	ae 5f 04	ldx $045f			ldx 	currentChannel
.103b	d0 03		bne $1040			bne 	_IGNLEExit
.103d	20 93 13	jsr $1393			jsr 	VectorPrintCharacter
.1040					_IGNLEExit:
.1040	60		rts				rts
.040c					InputBuffer:
>040c							.fill 	81
.045d					InputBufferPos:
>045d							.fill 	1
.1041					GetInteger8Bit:
.1041	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.1044	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1046	60		rts				rts
.1047					GetInteger16Bit:
.1047	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.104a	34 32		bit $32,x			bit 	NSStatus,x
.104c	30 09		bmi $1057			bmi 	Negate16Bit
.104e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1050	85 2c		sta $2c				sta 	zTemp0
.1052	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1054	85 2d		sta $2d				sta 	zTemp0+1
.1056	60		rts				rts
.1057					Negate16Bit:
.1057	38		sec				sec
.1058	a9 00		lda #$00			lda 	#0
.105a	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.105c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.105e	85 2c		sta $2c				sta 	zTemp0
.1060	a9 00		lda #$00			lda 	#0
.1062	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1064	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1066	85 2d		sta $2d				sta 	zTemp0+1
.1068	60		rts				rts
.1069					UnaryJoy:
.1069	fa		plx				plx
.106a	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; port #
.106d	48		pha				pha 								; zero the result.
.106e	20 a5 26	jsr $26a5			jsr 	FloatSetZero
.1071	68		pla				pla
.1072	5a		phy				phy
.1073	da		phx				phx
.1074	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1077	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1079	d0 10		bne $108b			bne 	_UJNoHardware
.107b	a8		tay				tay 								; move XA -> AY
.107c	8a		txa				txa
.107d	fa		plx				plx 								; we can update it now.
.107e	49 ff		eor #$ff			eor 	#$FF
.1080	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1082	98		tya				tya
.1083	49 ff		eor #$ff			eor 	#$FF
.1085	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1087	7a		ply				ply 								; restore Y
.1088	4c 4f 08	jmp $084f			jmp 	NextCommand
.108b					_UJNoHardware:
.108b	fa		plx				plx
.108c	7a		ply				ply
.108d	a9 01		lda #$01			lda 	#1 							; set result to -1
.108f	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.1092	20 67 26	jsr $2667			jsr 	FloatNegate
.1095	4c 4f 08	jmp $084f			jmp 	NextCommand
.1098					UnaryLen:
.1098	fa		plx				plx
.1099	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.109b	85 2c		sta $2c				sta 	zTemp0
.109d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.109f	85 2d		sta $2d				sta 	zTemp0+1
.10a1	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.10a3	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.10a6	4c 4f 08	jmp $084f			jmp 	NextCommand
.10a9					LinkFloatAdd:
.10a9	fa		plx				plx
.10aa	5a		phy			phy
.10ab	20 c9 20	jsr $20c9		jsr	FloatAdd
.10ae	7a		ply			ply
.10af	4c 4f 08	jmp $084f			jmp 	NextCommand
.10b2					LinkFloatSubtract:
.10b2	fa		plx				plx
.10b3	5a		phy			phy
.10b4	20 c3 20	jsr $20c3		jsr	FloatSubtract
.10b7	7a		ply			ply
.10b8	4c 4f 08	jmp $084f			jmp 	NextCommand
.10bb					LinkFloatMultiply:
.10bb	fa		plx				plx
.10bc	5a		phy			phy
.10bd	20 65 23	jsr $2365		jsr	FloatMultiply
.10c0	7a		ply			ply
.10c1	4c 4f 08	jmp $084f			jmp 	NextCommand
.10c4					LinkFloatDivide:
.10c4	fa		plx				plx
.10c5	5a		phy			phy
.10c6	20 ee 21	jsr $21ee		jsr	FloatDivide
.10c9	b0 5c		bcs $1127		bcs	DivZeroError
.10cb	7a		ply			ply
.10cc	4c 4f 08	jmp $084f			jmp 	NextCommand
.10cf					LinkFloatPower:
.10cf	fa		plx				plx
.10d0	5a		phy			phy
.10d1	20 6e 29	jsr $296e		jsr	FloatPower
.10d4	b0 4e		bcs $1124		bcs	MapRangeError
.10d6	7a		ply			ply
.10d7	4c 4f 08	jmp $084f			jmp 	NextCommand
.10da					LinkCompareGreater:
.10da	fa		plx				plx
.10db	5a		phy			phy
.10dc	20 72 21	jsr $2172		jsr	CompareGreater
.10df	7a		ply			ply
.10e0	4c 4f 08	jmp $084f			jmp 	NextCommand
.10e3					LinkCompareEqual:
.10e3	fa		plx				plx
.10e4	5a		phy			phy
.10e5	20 54 21	jsr $2154		jsr	CompareEqual
.10e8	7a		ply			ply
.10e9	4c 4f 08	jmp $084f			jmp 	NextCommand
.10ec					LinkCompareLess:
.10ec	fa		plx				plx
.10ed	5a		phy			phy
.10ee	20 6a 21	jsr $216a		jsr	CompareLess
.10f1	7a		ply			ply
.10f2	4c 4f 08	jmp $084f			jmp 	NextCommand
.10f5					LinkCompareGreaterEqual:
.10f5	fa		plx				plx
.10f6	5a		phy			phy
.10f7	20 82 21	jsr $2182		jsr	CompareGreaterEqual
.10fa	7a		ply			ply
.10fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.10fe					LinkCompareNotEqual:
.10fe	fa		plx				plx
.10ff	5a		phy			phy
.1100	20 64 21	jsr $2164		jsr	CompareNotEqual
.1103	7a		ply			ply
.1104	4c 4f 08	jmp $084f			jmp 	NextCommand
.1107					LinkCompareLessEqual:
.1107	fa		plx				plx
.1108	5a		phy			phy
.1109	20 7a 21	jsr $217a		jsr	CompareLessEqual
.110c	7a		ply			ply
.110d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1110					LinkFloatIntegerPartDown:
.1110	fa		plx				plx
.1111	5a		phy			phy
.1112	20 04 23	jsr $2304		jsr	FloatIntegerPartDown
.1115	7a		ply			ply
.1116	4c 4f 08	jmp $084f			jmp 	NextCommand
.1119					LinkFloatSquareRoot:
.1119	fa		plx				plx
.111a	5a		phy			phy
.111b	20 f0 29	jsr $29f0		jsr	FloatSquareRoot
.111e	b0 04		bcs $1124		bcs	MapRangeError
.1120	7a		ply			ply
.1121	4c 4f 08	jmp $084f			jmp 	NextCommand
.1124					MapRangeError:
.1124	4c 30 1f	jmp $1f30		jmp	ErrorV_range
.1127					DivZeroError:
.1127	4c b9 1f	jmp $1fb9		jmp	ErrorV_divzero
.112a					LinkFloatLogarithm:
.112a	fa		plx				plx
.112b	5a		phy			phy
.112c	20 fa 28	jsr $28fa		jsr	FloatLogarithm
.112f	b0 f3		bcs $1124		bcs	MapRangeError
.1131	7a		ply			ply
.1132	4c 4f 08	jmp $084f			jmp 	NextCommand
.1135					LinkFloatExponent:
.1135	fa		plx				plx
.1136	5a		phy			phy
.1137	20 f7 27	jsr $27f7		jsr	FloatExponent
.113a	7a		ply			ply
.113b	4c 4f 08	jmp $084f			jmp 	NextCommand
.113e					LinkFloatCosine:
.113e	fa		plx				plx
.113f	5a		phy			phy
.1140	20 eb 27	jsr $27eb		jsr	FloatCosine
.1143	7a		ply			ply
.1144	4c 4f 08	jmp $084f			jmp 	NextCommand
.1147					LinkFloatSine:
.1147	fa		plx				plx
.1148	5a		phy			phy
.1149	20 8b 29	jsr $298b		jsr	FloatSine
.114c	7a		ply			ply
.114d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1150					LinkFloatTangent:
.1150	fa		plx				plx
.1151	5a		phy			phy
.1152	20 fc 29	jsr $29fc		jsr	FloatTangent
.1155	7a		ply			ply
.1156	4c 4f 08	jmp $084f			jmp 	NextCommand
.1159					LinkFloatArcTan:
.1159	fa		plx				plx
.115a	5a		phy			phy
.115b	20 d0 26	jsr $26d0		jsr	FloatArcTan
.115e	b0 c4		bcs $1124		bcs	MapRangeError
.1160	7a		ply			ply
.1161	4c 4f 08	jmp $084f			jmp 	NextCommand
.1164					LinkFloatCompare:
.1164	fa		plx				plx
.1165	5a		phy			phy
.1166	20 8a 21	jsr $218a		jsr	FloatCompare
.1169	7a		ply			ply
.116a	4c 4f 08	jmp $084f			jmp 	NextCommand
.116d					LinkDivideInt32:
.116d	fa		plx				plx
.116e	5a		phy			phy
.116f	20 18 22	jsr $2218		jsr	DivideInt32
.1172	b0 b0		bcs $1124		bcs	MapRangeError
.1174	7a		ply			ply
.1175	4c 4f 08	jmp $084f			jmp 	NextCommand
.1178					StackSaveCurrentPosition:
.1178	20 cb 08	jsr $08cb			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.117b	5a		phy				phy
.117c	a0 02		ldy #$02			ldy 	#2
.117e	a5 28		lda $28				lda 	codePtr
.1180	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1182	c8		iny				iny
.1183	a5 29		lda $29				lda 	codePtr+1
.1185	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1187	7a		ply				ply
.1188	60		rts				rts
.1189					StackLoadCurrentPosition:
.1189	a0 02		ldy #$02			ldy 	#2
.118b	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.118d	85 28		sta $28				sta 	codePtr
.118f	c8		iny				iny
.1190	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1192	85 29		sta $29				sta 	codePtr+1
.1194	a0 00		ldy #$00			ldy 	#0
.1196	60		rts				rts
.1197					XCommandMouse:
.1197	fa		plx				plx
.1198	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; mouse control.
.119b	ca		dex				dex
.119c	da		phx				phx
.119d	5a		phy				phy
.119e	48		pha				pha
.119f	38		sec				sec 								; get screen resolution
.11a0	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.11a3	68		pla				pla
.11a4	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.11a7	7a		ply				ply
.11a8	fa		plx				plx
.11a9	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ac					XUnaryMB:
.11ac	fa		plx				plx
.11ad	20 f4 11	jsr $11f4			jsr 	XUnaryMouseCommon
.11b0	a5 30		lda $30				lda 	zTemp2
.11b2	e8		inx				inx
.11b3	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.11b6	4c 4f 08	jmp $084f			jmp 	NextCommand
.11b9					XUnaryMX:
.11b9	fa		plx				plx
.11ba	20 f4 11	jsr $11f4			jsr 	XUnaryMouseCommon
.11bd	a5 2c		lda $2c				lda 	zTemp0
.11bf	e8		inx				inx
.11c0	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.11c3	a5 2d		lda $2d				lda 	zTemp0+1
.11c5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11c7	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ca					XUnaryMY:
.11ca	fa		plx				plx
.11cb	20 f4 11	jsr $11f4			jsr 	XUnaryMouseCommon
.11ce	a5 2e		lda $2e				lda 	zTemp1
.11d0	e8		inx				inx
.11d1	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.11d4	a5 2f		lda $2f				lda 	zTemp1+1
.11d6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11d8	4c 4f 08	jmp $084f			jmp 	NextCommand
.11db					XUnaryMWheel:
.11db	fa		plx				plx
.11dc	20 f4 11	jsr $11f4			jsr 	XUnaryMouseCommon 			; read mouse status
.11df	e8		inx				inx
.11e0	a5 31		lda $31				lda 	zTemp2+1 					; set mantissa to |wheel|
.11e2	48		pha				pha
.11e3	10 03		bpl $11e8			bpl 	_XUMNotNegative
.11e5	49 ff		eor #$ff			eor 	#$FF
.11e7	1a		inc a				inc 	a
.11e8					_XUMNotNegative:
.11e8	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.11eb	68		pla				pla  								; negate if it was -ve
.11ec	10 03		bpl $11f1			bpl 	_XUMNotNegative2
.11ee	20 67 26	jsr $2667			jsr 	FloatNegate
.11f1					_XUMNotNegative2:
.11f1	4c 4f 08	jmp $084f			jmp 	NextCommand
.11f4					XUnaryMouseCommon:
.11f4	da		phx				phx
.11f5	5a		phy				phy
.11f6	a2 2c		ldx #$2c			ldx 	#zTemp0
.11f8	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.11fb	85 30		sta $30				sta 	zTemp2
.11fd	86 31		stx $31				stx 	zTemp2+1
.11ff	7a		ply				ply
.1200	fa		plx				plx
.1201	60		rts				rts
.1202					NegateTOS:
.1202	fa		plx				plx
.1203	20 67 26	jsr $2667			jsr 	FloatNegate
.1206	4c 4f 08	jmp $084f			jmp 	NextCommand
.1209					CommandNewLine:
.1209	fa		plx				plx
.120a	9c 6a 05	stz $056a			stz 	stringInitialised
.120d	a2 ff		ldx #$ff			ldx 	#$FF
.120f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1212					CommandXNext:
.1212	fa		plx				plx
.1213					_CNRetry:
.1213	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.1215	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.1218	20 cb 08	jsr $08cb			jsr 	FixUpY 						; so we can use Y
.121b	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.121d	35 4a		and $4a,x			and 	NSMantissa1,x
.121f	c9 ff		cmp #$ff			cmp 	#$FF
.1221	f0 16		beq $1239			beq 	_CNNoIndexVariable
.1223	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1225	a0 05		ldy #$05			ldy 	#5
.1227	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.1229	d0 07		bne $1232			bne 	_CNNIndexFail
.122b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.122d	c8		iny				iny
.122e	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.1230	f0 07		beq $1239			beq 	_CNNoIndexVariable
.1232					_CNNIndexFail:
.1232	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.1234	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close this frame
.1237	80 da		bra $1213			bra 	_CNRetry
.1239					_CNNoIndexVariable:
.1239	ca		dex				dex
.123a	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.123c	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.123e	29 40		and #$40			and 	#$40	 					; bit 6
.1240	d0 55		bne $1297			bne 	_CNOptimisedNext
.1242	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1244	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1246	48		pha				pha
.1247	85 2c		sta $2c				sta 	zTemp0
.1249	c8		iny				iny
.124a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.124c	18		clc				clc
.124d	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1250	48		pha				pha
.1251	85 2d		sta $2d				sta 	zTemp0+1
.1253	20 15 15	jsr $1515			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.1256	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.1258	e8		inx				inx
.1259	20 da 12	jsr $12da			jsr 	CopyOffsetYToTOS
.125c	20 c9 20	jsr $20c9			jsr 	FloatAdd
.125f	68		pla				pla 								; restore address
.1260	85 2d		sta $2d				sta 	zTemp0+1
.1262	68		pla				pla
.1263	85 2c		sta $2c				sta 	zTemp0
.1265	20 0a 1b	jsr $1b0a			jsr 	WriteFloatZTemp0Sub			; write float.
.1268	e8		inx				inx  								; recover written
.1269	e8		inx				inx 								; load offset
.126a	a0 0d		ldy #$0d			ldy 	#13
.126c	20 da 12	jsr $12da			jsr 	CopyOffsetYToTOS
.126f	20 8a 21	jsr $218a			jsr 	FloatCompare 				; and compare the floats.
.1272	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1273	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.1275	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1277	30 08		bmi $1281			bmi 	_CNDownStep
.1279	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.127b	c9 01		cmp #$01			cmp 	#1 							; gone higher
.127d	f0 10		beq $128f			beq 	_CNExitFor 					; if so exit the loop
.127f	80 06		bra $1287			bra 	_CNLoopBack
.1281					_CNDownStep:
.1281	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1283	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.1285	f0 08		beq $128f			beq 	_CNExitFor
.1287					_CNLoopBack:
.1287	20 89 11	jsr $1189			jsr 	StackLoadCurrentPosition 	; loop back
.128a	a0 00		ldy #$00			ldy 	#0
.128c	4c 4f 08	jmp $084f			jmp 	NextCommand
.128f					_CNExitFor:
.128f	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; remove the frame and exit
.1292	a0 00		ldy #$00			ldy 	#0
.1294	4c 4f 08	jmp $084f			jmp 	NextCommand
.1297					_CNOptimisedNext:
.1297	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1299	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.129b	85 2c		sta $2c				sta 	zTemp0
.129d	c8		iny				iny
.129e	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12a0	18		clc				clc
.12a1	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.12a4	85 2d		sta $2d				sta 	zTemp0+1
.12a6	a0 07		ldy #$07			ldy 	#7 							; STEP value
.12a8	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12aa	a0 ff		ldy #$ff			ldy 	#$FF
.12ac	18		clc				clc
.12ad					_CNOIncrement:
.12ad	c8		iny				iny
.12ae	71 2c		adc ($2c),y			adc 	(zTemp0),y
.12b0	91 2c		sta ($2c),y			sta 	(zTemp0),y
.12b2	f0 f9		beq $12ad			beq 	_CNOIncrement
.12b4	18		clc				clc
.12b5	a5 24		lda $24				lda 	runtimeStackPtr
.12b7	69 0d		adc #$0d			adc 	#13
.12b9	85 2e		sta $2e				sta 	zTemp1
.12bb	a5 25		lda $25				lda 	runtimeStackPtr+1
.12bd	69 00		adc #$00			adc 	#0
.12bf	85 2f		sta $2f				sta 	zTemp1+1
.12c1	a0 00		ldy #$00			ldy 	#0
.12c3	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.12c5	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.12c7	c8		iny				iny
.12c8	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.12ca	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12cc	c8		iny				iny
.12cd	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.12cf	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12d1	c8		iny				iny
.12d2	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.12d4	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12d6	90 b7		bcc $128f			bcc	 	_CNExitFor
.12d8	80 ad		bra $1287			bra 	_CNLoopBack
.12da					CopyOffsetYToTOS:
.12da	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12dc	95 3e		sta $3e,x			sta 	NSMantissa0,x
.12de	c8		iny				iny
.12df	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12e1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12e3	c8		iny				iny
.12e4	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12e6	95 56		sta $56,x			sta 	NSMantissa2,x
.12e8	c8		iny				iny
.12e9	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12eb	95 62		sta $62,x			sta 	NSMantissa3,x
.12ed	c8		iny				iny
.12ee	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12f0	95 6e		sta $6e,x			sta 	NSExponent,x
.12f2	c8		iny				iny
.12f3	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12f5	95 32		sta $32,x			sta 	NSStatus,x
.12f7	60		rts				rts
.12f8	4c 4f 08	jmp $084f			jmp 	NextCommand
.12fb					NotTOS:
.12fb	fa		plx				plx
.12fc	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.12ff	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.1301	74 62		stz $62,x			stz 	NSMantissa3,x
.1303	20 67 26	jsr $2667			jsr 	FloatNegate		 			; negate
.1306	e8		inx				inx 								; and subtract 1.
.1307	a9 01		lda #$01			lda 	#1
.1309	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.130c	20 c3 20	jsr $20c3			jsr 	FloatSubtract
.130f					_NotTOSSkip:
.130f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1312					CommandXOn:
.1312	fa		plx				plx
.1313	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.1316	8d 5e 04	sta $045e			sta 	onCount 					; save it.
.1319	20 cb 08	jsr $08cb			jsr 	FixUpY 						; Y = 0
.131c					_CONFind:
.131c	ce 5e 04	dec $045e			dec 	onCount 					; reached zero, do this one
.131f	f0 0b		beq $132c			beq 	_CONFound
.1321	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1322	c8		iny				iny
.1323	c8		iny				iny
.1324	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.1326	c8		iny				iny
.1327	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.1329	f0 f1		beq $131c			beq 	_CONFind
.132b	88		dey				dey 								; point to character after last GOTO/GOSUB
.132c					_CONFound:
.132c	4c 4f 08	jmp $084f			jmp 	NextCommand
.132f					CommandMoreOn:
.132f	fa		plx				plx
.1330	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1331	c8		iny				iny
.1332	c8		iny				iny
.1333	4c 4f 08	jmp $084f			jmp 	NextCommand
.045e					onCount:
>045e							.fill 	1
.1336					UnaryPeek:
.1336	fa		plx				plx
.1337	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.133a	da		phx				phx
.133b	5a		phy				phy
.133c	a6 2c		ldx $2c				ldx 	zTemp0
.133e	a4 2d		ldy $2d				ldy 	zTemp0+1
.1340	20 a4 1c	jsr $1ca4			jsr 	XPeekMemory
.1343	7a		ply				ply
.1344	fa		plx				plx
.1345	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.1348	4c 4f 08	jmp $084f			jmp 	NextCommand
.134b					UnaryPI:
.134b	fa		plx				plx
.134c	a9 19		lda #$19			lda 	#Const_pi-Const_base
.134e	20 d5 28	jsr $28d5			jsr 	LoadConstant
.1351	e8		inx				inx
.1352	4c 4f 08	jmp $084f			jmp 	NextCommand
.1355					CommandPOKE:
.1355	fa		plx				plx
.1356	da		phx				phx 								; save XY
.1357	5a		phy				phy
.1358	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.135b	48		pha				pha
.135c	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.135e	a8		tay				tay
.135f	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1361	aa		tax				tax
.1362	68		pla				pla
.1363	20 90 1c	jsr $1c90			jsr 	XPokeMemory
.1366	7a		ply				ply 								; restore YX and drop 2
.1367	fa		plx				plx
.1368	ca		dex				dex
.1369	ca		dex				dex
.136a	4c 4f 08	jmp $084f			jmp 	NextCommand
.136d					UnaryPos:
.136d	fa		plx				plx
.136e	20 23 1c	jsr $1c23			jsr 	XGetHPos
.1371	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.1374	4c 4f 08	jmp $084f			jmp 	NextCommand
.1377					GetChannel:
.1377	fa		plx				plx
.1378	ad 5f 04	lda $045f			lda 	currentChannel
.137b	e8		inx				inx
.137c	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.137f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1382					SetChannel:
.1382	fa		plx				plx
.1383	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.1386	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1388	8d 5f 04	sta $045f			sta 	currentChannel
.138b	ca		dex				dex
.138c	4c 4f 08	jmp $084f			jmp 	NextCommand
.138f					SetDefaultChannel:
.138f	9c 5f 04	stz $045f			stz 	currentChannel
.1392	60		rts				rts
.1393					VectorPrintCharacter:
.1393	da		phx				phx
.1394	ae 5f 04	ldx $045f			ldx 	currentChannel
.1397	20 ce 1c	jsr $1cce			jsr 	XPrintCharacterToChannel
.139a	fa		plx				plx
.139b	60		rts				rts
.139c					VectorGetCharacter:
.139c	da		phx				phx
.139d	ae 5f 04	ldx $045f			ldx 	currentChannel
.13a0	20 07 1c	jsr $1c07			jsr 	XGetCharacterFromChannel
.13a3	fa		plx				plx
.13a4	60		rts				rts
.045f					currentChannel:
>045f							.fill 	1
.13a5					PrintNumber:
.13a5	fa		plx				plx
.13a6	a9 07		lda #$07			lda 	#7
.13a8	20 8d 25	jsr $258d			jsr 	FloatToString 				; to number in decimal buffer
.13ab	ca		dex				dex 								; drop
.13ac	da		phx				phx
.13ad	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.13af					_PNLoop:
.13af	bd 98 05	lda $0598,x			lda 	decimalBuffer,x
.13b2	20 93 13	jsr $1393			jsr 	VectorPrintCharacter
.13b5	e8		inx				inx
.13b6	bd 98 05	lda $0598,x			lda	 	decimalBuffer,x
.13b9	d0 f4		bne $13af			bne 	_PNLoop
.13bb	a9 20		lda #$20			lda 	#32 						; trailing space
.13bd	20 93 13	jsr $1393			jsr 	VectorPrintCharacter
.13c0	fa		plx				plx
.13c1	4c 4f 08	jmp $084f			jmp 	NextCommand
.13c4					PrintString:
.13c4	fa		plx				plx
.13c5	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.13c7	85 2c		sta $2c				sta 	zTemp0
.13c9	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.13cb	85 2d		sta $2d				sta 	zTemp0+1
.13cd	ca		dex				dex 								; drop
.13ce	da		phx				phx
.13cf	5a		phy				phy
.13d0	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.13d2	aa		tax				tax
.13d3	a0 01		ldy #$01			ldy 	#1 							; Y = position
.13d5					_PSLoop:
.13d5	e0 00		cpx #$00			cpx 	#0 							; complete ?
.13d7	f0 09		beq $13e2			beq 	_PSExit
.13d9	ca		dex				dex 								; dec count
.13da	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.13dc	20 93 13	jsr $1393			jsr 	VectorPrintCharacter
.13df	c8		iny				iny
.13e0	80 f3		bra $13d5			bra 	_PSLoop
.13e2					_PSExit:
.13e2	7a		ply				ply
.13e3	fa		plx				plx
.13e4	4c 4f 08	jmp $084f			jmp 	NextCommand
.13e7					CommandPushN:
.13e7	fa		plx				plx
.13e8	e8		inx				inx 								; next slot on stack
.13e9	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.13eb	95 6e		sta $6e,x			sta 	NSExponent,x
.13ed	c8		iny				iny
.13ee	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.13f0	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13f2	c8		iny				iny
.13f3	b1 28		lda ($28),y			lda 	(codePtr),y
.13f5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13f7	c8		iny				iny
.13f8	b1 28		lda ($28),y			lda 	(codePtr),y
.13fa	95 56		sta $56,x			sta 	NSMantissa2,x
.13fc	c8		iny				iny
.13fd	b1 28		lda ($28),y			lda 	(codePtr),y
.13ff	48		pha				pha
.1400	29 7f		and #$7f			and 	#$7F
.1402	95 62		sta $62,x			sta 	NSMantissa3,x
.1404	68		pla				pla 								; sign in mantissa3:7
.1405	29 80		and #$80			and 	#$80
.1407	95 32		sta $32,x			sta 	NSStatus,x
.1409	c8		iny				iny
.140a	4c 4f 08	jmp $084f			jmp 	NextCommand
.140d					CommandPushS:
.140d	fa		plx				plx
.140e	e8		inx				inx 								; next slot on stack
.140f	18		clc				clc
.1410	98		tya				tya
.1411	65 28		adc $28				adc 	codePtr 					; the string is inline
.1413	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1415	a5 29		lda $29				lda 	codePtr+1
.1417	69 00		adc #$00			adc 	#0
.1419	95 4a		sta $4a,x			sta 	NSMantissa1,x
.141b	74 56		stz $56,x			stz 	NSMantissa2,x
.141d	74 62		stz $62,x			stz 	NSMantissa3,x
.141f	a9 40		lda #$40			lda 	#NSSString
.1421	95 32		sta $32,x			sta 	NSStatus,x
.1423	98		tya				tya 								; string length +1 added to Y
.1424	38		sec				sec
.1425	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.1427	a8		tay				tay
.1428	4c 4f 08	jmp $084f			jmp 	NextCommand
.142b					CommandXRead:
.142b	fa		plx				plx
.142c	5a		phy				phy 								; save Y
.142d	20 5e 14	jsr $145e			jsr 	ReadStringToBuffer 			; read element into buffer
.1430	e8		inx				inx									; space on stack
.1431	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.1433	85 2c		sta $2c				sta 	0+zTemp0
.1435	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.1437	85 2d		sta $2d				sta 	1+zTemp0
.1439	20 93 19	jsr $1993			jsr 	ValEvaluateZTemp0
.143c	b0 04		bcs $1442			bcs 	_CRError 					; failed
.143e	7a		ply				ply 								; restore Y
.143f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1442					_CRError:
.1442	4c 40 1f	jmp $1f40		jmp	ErrorV_value
.1445					CommandReadString:
.1445	fa		plx				plx
.1446	5a		phy				phy 								; save Y
.1447	20 5e 14	jsr $145e			jsr 	ReadStringToBuffer 			; read text
.144a	e8		inx				inx 								; make space on stack
.144b	20 a5 26	jsr $26a5			jsr 	FloatSetZero 				; store as string on stack
.144e	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.1450	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1452	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.1454	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1456	a9 40		lda #$40			lda 	#NSSString
.1458	95 32		sta $32,x			sta 	NSStatus,x
.145a	7a		ply				ply 								; restore Y
.145b	4c 4f 08	jmp $084f			jmp 	NextCommand
.145e					ReadStringToBuffer:
.145e	a9 f1		lda #$f1			lda 	#((ReadBumpNext) & $FF)
.1460	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.1463	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.1465	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.1468	a9 c4		lda #$c4			lda 	#((ReadLookNext) & $FF)
.146a	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.146d	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.146f	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.1472					GetStringToBuffer:
.1472	20 c1 14	jsr $14c1			jsr		GetLookNext 				; skip all leading spaces.
.1475	f0 44		beq $14bb			beq 	_RBError 					; end of data
.1477	b0 f9		bcs $1472			bcs 	GetStringToBuffer 			; switched to new data line.
.1479	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.147b	b0 05		bcs $1482			bcs 	_RBNoSpace
.147d	20 be 14	jsr $14be			jsr 	GetBumpNext 				; consume space and loop round.
.1480	80 f0		bra $1472			bra 	GetStringToBuffer
.1482					_RBNoSpace:
.1482	9c 61 04	stz $0461			stz 	ReadBufferSize 				; empty the buffer.
.1485	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.1487	d0 08		bne $1491			bne 	_RBCommaSep
.1489	8d 60 04	sta $0460			sta 	ReadSep 					; use as a seperator
.148c	20 be 14	jsr $14be			jsr 	GetBumpNext 				; consume the '"'
.148f	80 05		bra $1496			bra 	_RBGetText
.1491					_RBCommaSep:
.1491	a9 2c		lda #$2c			lda 	#","						; get till comma
.1493	8d 60 04	sta $0460			sta 	ReadSep
.1496					_RBGetText:
.1496	20 c1 14	jsr $14c1			jsr 	GetLookNext 				; what follows
.1499	b0 18		bcs $14b3			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.149b	20 be 14	jsr $14be			jsr 	GetBumpNext 				; consume it whatever
.149e	cd 60 04	cmp $0460			cmp 	ReadSep 					; if found the seperator.
.14a1	f0 10		beq $14b3			beq 	_RBEndGet 					; exit after consumption
.14a3	da		phx				phx
.14a4	ae 61 04	ldx $0461			ldx 	ReadBufferSize 				; copy into buffer.
.14a7	ee 61 04	inc $0461			inc 	ReadBufferSize
.14aa	9d 62 04	sta $0462,x			sta 	ReadBuffer,x
.14ad	9e 63 04	stz $0463,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.14b0	fa		plx				plx
.14b1	80 e3		bra $1496			bra 	_RBGetText
.14b3					_RBEndGet:
.14b3	c9 22		cmp #$22			cmp 	#'"'
.14b5	d0 03		bne $14ba			bne 	_RBNotQuote
.14b7	20 be 14	jsr $14be			jsr 	GetBumpNext
.14ba					_RBNotQuote:
.14ba	60		rts				rts
.14bb					_RBError:
.14bb	4c f5 1f	jmp $1ff5		jmp	ErrorV_data
.14be					GetBumpNext:
.14be	6c 61 05	jmp ($0561)			jmp 	(ReadBumpNextVec)
.14c1					GetLookNext:
.14c1	6c 63 05	jmp ($0563)			jmp 	(ReadLookNextVec)
.14c4					ReadLookNext:
.14c4	ad 65 05	lda $0565			lda 	dataRemaining 				; any data remaining
.14c7	f0 04		beq $14cd			beq 	_RLNFindData
.14c9	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.14cb	18		clc				clc
.14cc	60		rts				rts
.14cd					_RLNFindData:
.14cd	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.14cf	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.14d1	f0 1a		beq $14ed			beq 	_RLNNoData
.14d3	c9 d0		cmp #$d0			cmp 	#PCD_CMD_DATA 				; Found DATA
.14d5	f0 05		beq $14dc			beq 	_RLNHaveData
.14d7					_RLNNext:
.14d7	20 73 20	jsr $2073			jsr 	MoveObjectForward			; else scan forward.
.14da	80 f1		bra $14cd			bra 	_RLNFindData
.14dc					_RLNHaveData:
.14dc	a0 01		ldy #$01			ldy 	#1 							; get length
.14de	b1 2a		lda ($2a),y			lda 	(objPtr),y
.14e0	f0 f5		beq $14d7			beq 	_RLNNext 					; skip if DATA alone
.14e2	20 f1 14	jsr $14f1			jsr 	ReadBumpNext 				; advance by two
.14e5	20 f1 14	jsr $14f1			jsr 	ReadBumpNext
.14e8	8d 65 05	sta $0565			sta 	dataRemaining 				; set data left count.
.14eb	38		sec				sec
.14ec	60		rts				rts
.14ed					_RLNNoData:
.14ed	a9 00		lda #$00			lda 	#0
.14ef	38		sec				sec
.14f0	60		rts				rts
.14f1					ReadBumpNext:
.14f1	e6 2a		inc $2a				inc 	objPtr
.14f3	d0 02		bne $14f7			bne 	_RBNSkip
.14f5	e6 2b		inc $2b				inc 	objPtr+1
.14f7					_RBNSkip:
.14f7	ce 65 05	dec $0565			dec 	dataRemaining
.14fa	60		rts				rts
.0460					ReadSep:
>0460							.fill 	1
.0461					ReadBufferSize:
>0461							.fill 	1
.0462					ReadBuffer:
>0462							.fill 	255
.0561					ReadBumpNextVec:
>0561							.fill 	2
.0563					ReadLookNextVec:
>0563							.fill 	2
.14fb					ReadFloatCommand:
.14fb	fa		plx				plx
.14fc	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14fe	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1500	88		dey				dey 								; get the upper 3 bits
.1501	b1 28		lda ($28),y			lda 	(codePtr),y
.1503	29 07		and #$07			and 	#7
.1505	c8		iny				iny
.1506	c8		iny				iny
.1507	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1509	2a		rol a				rol 	a 							; carry will be clear.
.150a	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.150d	85 2d		sta $2d				sta 	zTemp0+1
.150f	20 15 15	jsr $1515			jsr 	ReadFloatZTemp0Sub
.1512	4c 4f 08	jmp $084f			jmp 	NextCommand
.1515					ReadFloatZTemp0Sub:
.1515	5a		phy				phy 								; start write
.1516	a0 01		ldy #$01			ldy 	#1
.1518	e8		inx				inx
.1519	b2 2c		lda ($2c)			lda 	(zTemp0)
.151b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.151d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.151f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1521	c8		iny				iny
.1522	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1524	95 56		sta $56,x			sta 	NSMantissa2,x
.1526	c8		iny				iny
.1527	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1529	95 62		sta $62,x			sta 	NSMantissa3,x
.152b	c8		iny				iny
.152c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.152e	95 6e		sta $6e,x			sta 	NSExponent,x
.1530	c8		iny				iny
.1531	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1533	95 32		sta $32,x			sta 	NSStatus,x
.1535	7a		ply				ply
.1536	60		rts				rts
.1537					ReadIntegerCommand:
.1537	fa		plx				plx
.1538	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.153a	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.153c	88		dey				dey 								; get the upper 3 bits
.153d	b1 28		lda ($28),y			lda 	(codePtr),y
.153f	29 07		and #$07			and 	#7
.1541	c8		iny				iny
.1542	c8		iny				iny
.1543	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1545	2a		rol a				rol 	a 							; carry will be clear.
.1546	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1549	85 2d		sta $2d				sta 	zTemp0+1
.154b	20 51 15	jsr $1551			jsr 	ReadIntegerZTemp0Sub
.154e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1551					ReadIntegerZTemp0Sub:
.1551	5a		phy				phy 								; start write
.1552	a0 01		ldy #$01			ldy 	#1
.1554	e8		inx				inx 								; prepare
.1555	74 56		stz $56,x			stz 	NSMantissa2,x
.1557	74 62		stz $62,x			stz 	NSMantissa3,x
.1559	74 6e		stz $6e,x			stz 	NSExponent,x
.155b	74 32		stz $32,x			stz 	NSStatus,x
.155d	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.155f	30 08		bmi $1569			bmi 	_RIZNegative
.1561	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1563	b2 2c		lda ($2c)			lda 	(zTemp0)
.1565	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1567	7a		ply				ply
.1568	60		rts				rts
.1569					_RIZNegative:
.1569	38		sec				sec 								; -ve read
.156a	a9 00		lda #$00			lda 	#0
.156c	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.156e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1570	a9 00		lda #$00			lda 	#0
.1572	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1574	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1576	a9 80		lda #$80			lda 	#$80
.1578	95 32		sta $32,x			sta 	NSStatus,x
.157a	7a		ply				ply
.157b	60		rts				rts
.157c					ReadStringCommand:
.157c	fa		plx				plx
.157d	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.157f	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1581	88		dey				dey 								; get the upper 3 bits
.1582	b1 28		lda ($28),y			lda 	(codePtr),y
.1584	29 07		and #$07			and 	#7
.1586	c8		iny				iny
.1587	c8		iny				iny
.1588	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.158a	2a		rol a				rol 	a 							; carry will be clear.
.158b	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.158e	85 2d		sta $2d				sta 	zTemp0+1
.1590	20 96 15	jsr $1596			jsr 	ReadStringZTemp0Sub
.1593	4c 4f 08	jmp $084f			jmp 	NextCommand
.1596					ReadStringZTemp0Sub:
.1596	5a		phy				phy 								; start write
.1597	e8		inx				inx 								; prepare
.1598	74 56		stz $56,x			stz 	NSMantissa2,x
.159a	74 62		stz $62,x			stz 	NSMantissa3,x
.159c	74 6e		stz $6e,x			stz 	NSExponent,x
.159e	a9 40		lda #$40			lda 	#NSSString
.15a0	74 32		stz $32,x			stz 	NSStatus,x
.15a2	18		clc				clc
.15a3	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.15a5	69 02		adc #$02			adc 	#2 							; this points to actual data
.15a7	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.15a9	a0 01		ldy #$01			ldy 	#1
.15ab	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.15ad	69 00		adc #$00			adc 	#0
.15af	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.15b1	d0 08		bne $15bb			bne 	_RSZNoDefault 				; if read $00 use a default value.
.15b3	a9 bd		lda #$bd			lda 	#_RSZNull & $FF
.15b5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15b7	a9 15		lda #$15			lda 	#_RSZNull >> 8
.15b9	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15bb					_RSZNoDefault:
.15bb	7a		ply				ply
.15bc	60		rts				rts
.15bd					_RSZNull:
>15bd	00						.byte 	0
.15be					CommandRestoreX:
.15be	fa		plx				plx
.15bf	20 c5 15	jsr $15c5			jsr 	RestoreCodeOffset
.15c2	4c 4f 08	jmp $084f			jmp 	NextCommand
.15c5					RestoreCodeOffset:
.15c5	20 cb 08	jsr $08cb			jsr 	FixUpY  					; make Y = 0 adjusting code Ptr.
.15c8	18		clc				clc 								; add LSB
.15c9	b1 28		lda ($28),y			lda 	(codePtr),y
.15cb	65 28		adc $28				adc 	codePtr
.15cd	85 2a		sta $2a				sta 	objPtr
.15cf	c8		iny				iny 								; add MSB
.15d0	b1 28		lda ($28),y			lda 	(codePtr),y
.15d2	65 29		adc $29				adc 	codePtr+1
.15d4	85 2b		sta $2b				sta 	objPtr+1
.15d6	c8		iny				iny 								; next command.
.15d7	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15da	60		rts				rts
.15db					RestoreCode:
.15db	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.15de	85 2b		sta $2b				sta 	objPtr+1
.15e0	64 2a		stz $2a				stz 	objPtr
.15e2	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15e5	60		rts				rts
.0565					dataRemaining:
>0565							.fill 	1		 					; 0 if not in data statement
.15e6					UnaryRND:
.15e6	fa		plx				plx
.15e7	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.15e9	10 17		bpl $1602			bpl 	_URNoSeed
.15eb	20 fa 23	jsr $23fa			jsr 	FloatNormalise 				; some float value
.15ee	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.15f0	8d 66 05	sta $0566			sta 	randomSeed+0
.15f3	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15f5	8d 67 05	sta $0567			sta 	randomSeed+1
.15f8	b5 56		lda $56,x			lda 	NSMantissa2,x
.15fa	8d 68 05	sta $0568			sta 	randomSeed+2
.15fd	b5 62		lda $62,x			lda 	NSMantissa3,x
.15ff	8d 69 05	sta $0569			sta 	randomSeed+3
.1602					_URNoSeed:
.1602	20 24 16	jsr $1624			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.1605	ad 66 05	lda $0566			lda 	randomSeed+0
.1608	95 3e		sta $3e,x			sta 	NSMantissa0,x
.160a	ad 67 05	lda $0567			lda 	randomSeed+1
.160d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.160f	ad 68 05	lda $0568			lda 	randomSeed+2
.1612	95 56		sta $56,x			sta 	NSMantissa2,x
.1614	ad 69 05	lda $0569			lda 	randomSeed+3
.1617	29 7f		and #$7f			and 	#$7F
.1619	95 62		sta $62,x			sta 	NSMantissa3,x
.161b	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.161d	95 6e		sta $6e,x			sta 	NSExponent,x
.161f	74 32		stz $32,x			stz 	NSStatus,x
.1621	4c 4f 08	jmp $084f			jmp 	NextCommand
.1624					RandomNumberGenerator:
.1624	5a		phy				phy
.1625	ad 66 05	lda $0566			lda 	randomSeed+0 				; check if zero
.1628	0d 67 05	ora $0567			ora 	randomSeed+1
.162b	0d 68 05	ora $0568			ora 	randomSeed+2
.162e	0d 69 05	ora $0569			ora 	randomSeed+3
.1631	d0 07		bne $163a			bne 	_RNGNoSeed
.1633	ce 69 05	dec $0569			dec 	randomSeed+3 				; if so tweak and flog
.1636	a0 64		ldy #$64			ldy 	#100
.1638	80 05		bra $163f			bra 	_RNGLoop
.163a					_RNGNoSeed:
.163a	a0 08		ldy #$08			ldy 	#8
.163c	ad 66 05	lda $0566			lda 	randomSeed+0
.163f					_RNGLoop:
.163f	0a		asl a				asl		a
.1640	2e 67 05	rol $0567			rol 	randomSeed+1
.1643	2e 68 05	rol $0568			rol 	randomSeed+2
.1646	2e 69 05	rol $0569			rol 	randomSeed+3
.1649	90 02		bcc $164d			bcc		_RNGSkip
.164b	49 c5		eor #$c5			eor 	#$C5
.164d					_RNGSkip:
.164d	88		dey				dey
.164e	d0 ef		bne $163f			bne		_RNGLoop
.1650	8d 66 05	sta $0566			sta 	randomSeed+0
.1653	7a		ply				ply
.1654	60		rts				rts
.0566					randomSeed:
>0566							.fill 	4
.1655					StringConcatenate:
.1655	fa		plx				plx
.1656	ca		dex				dex
.1657	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.1659	85 2e		sta $2e				sta 	zTemp1
.165b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.165d	85 2f		sta $2f				sta 	zTemp1+1
.165f	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.1661	85 30		sta $30				sta 	zTemp2
.1663	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.1665	85 31		sta $31				sta 	zTemp2+1
.1667	18		clc				clc 								; work out total length
.1668	b2 2e		lda ($2e)			lda 	(zTemp1)
.166a	72 30		adc ($30)			adc 	(zTemp2)
.166c	b0 18		bcs $1686			bcs 	_BCLength 					; more than 255 characters.
.166e	48		pha				pha 								; save total
.166f	20 4c 17	jsr $174c			jsr 	StringAllocTemp 			; space for result.
.1672	68		pla				pla 								; write total as first.
.1673	92 22		sta ($22)			sta 	(zsTemp)
.1675	20 89 16	jsr $1689			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.1678	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.167a	85 2e		sta $2e				sta 	zTemp1
.167c	a5 31		lda $31				lda 	zTemp2+1
.167e	85 2f		sta $2f				sta 	zTemp1+1
.1680	20 89 16	jsr $1689			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1683	4c 4f 08	jmp $084f			jmp 	NextCommand
.1686					_BCLength:
.1686	4c 30 1f	jmp $1f30		jmp	ErrorV_range
.1689					_BCCopyZTemp1:
.1689	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.168b	f0 15		beq $16a2			beq 	_BCCExit 					; none.
.168d	da		phx				phx 								; save XY
.168e	5a		phy				phy
.168f	aa		tax				tax 								; count in X.
.1690	a0 01		ldy #$01			ldy 	#1
.1692					_BCCLoop:
.1692	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1694	d0 02		bne $1698			bne 	_BCCNoCarry
.1696	e6 23		inc $23				inc 	zsTemp+1
.1698					_BCCNoCarry:
.1698	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.169a	92 22		sta ($22)			sta 	(zsTemp)
.169c	c8		iny				iny
.169d	ca		dex				dex 								; X times
.169e	d0 f2		bne $1692			bne 	_BCCLoop
.16a0	7a		ply				ply 								; restore YX
.16a1	fa		plx				plx
.16a2					_BCCExit:
.16a2	60		rts				rts
.16a3					XRuntimeSetup:
.16a3	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.16a5	8d 6d 05	sta $056d	 		sta 	ramBank
.16a8	8d 6e 05	sta $056e	 		sta 	romBank
.16ab	60		rts				rts
.16ac					SignTOS:
.16ac	fa		plx				plx
.16ad	20 c7 26	jsr $26c7			jsr 	FloatIsZero 				; if zero
.16b0	f0 0f		beq $16c1			beq 	_SGZero  					; return Int Zero
.16b2	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.16b4	48		pha				pha
.16b5	a9 01		lda #$01			lda 	#1 							; set result to 1
.16b7	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.16ba	68		pla				pla
.16bb	29 80		and #$80			and		#$80 						; copy the sign byte out
.16bd	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.16bf	80 03		bra $16c4			bra 	_SGExit
.16c1					_SGZero:
.16c1	20 a5 26	jsr $26a5			jsr 	FloatSetZero
.16c4					_SGExit:
.16c4	4c 4f 08	jmp $084f			jmp 	NextCommand
.16c7					CommandShift:
.16c7	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.16c9	c8		iny				iny
.16ca	0a		asl a				asl 	a 							; double into X
.16cb	aa		tax				tax
.16cc	7c 7b 1a	jmp ($1a7b,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.16cf					PrintTab:
.16cf	fa		plx				plx
.16d0	20 23 1c	jsr $1c23			jsr 	XGetHPos
.16d3					_PTMod10:
.16d3	38		sec				sec
.16d4	e9 0a		sbc #$0a			sbc 	#10
.16d6	b0 fb		bcs $16d3			bcs 	_PTMod10
.16d8	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.16da	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.16db	80 15		bra $16f2			bra 	PrintSpaceLoop
.16dd					PrintPos:
.16dd	fa		plx				plx
.16de	20 23 1c	jsr $1c23			jsr		XGetHPos 					; get current position
.16e1	85 2c		sta $2c				sta 	zTemp0
.16e3	38		sec				sec 								; calculate spaces required
.16e4	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16e6	ca		dex				dex
.16e7	e5 2c		sbc $2c				sbc 	zTemp0
.16e9	b0 07		bcs $16f2			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.16eb	4c 4f 08	jmp $084f			jmp 	NextCommand
.16ee					PrintSpace:
.16ee	fa		plx				plx
.16ef	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16f1	ca		dex				dex
.16f2					PrintSpaceLoop:
.16f2	c9 00		cmp #$00			cmp 	#0
.16f4	f0 0a		beq $1700			beq 	_PSExit
.16f6	48		pha				pha
.16f7	a9 20		lda #$20			lda 	#" "
.16f9	20 93 13	jsr $1393			jsr 	VectorPrintCharacter
.16fc	68		pla				pla
.16fd	3a		dec a				dec 	a
.16fe	80 f2		bra $16f2			bra 	PrintSpaceLoop
.1700					_PSExit:
.1700	4c 4f 08	jmp $084f			jmp 	NextCommand
.1703					CommandStop:
.1703	fa		plx				plx
.1704	4c e2 1f	jmp $1fe2		jmp	ErrorV_stop
.1707					Unary_Str:
.1707	fa		plx				plx
.1708	5a		phy				phy
.1709	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.170b	20 8d 25	jsr $258d			jsr 	FloatToString 				; do the conversion.
.170e	a9 21		lda #$21			lda		#33 						; create buffer
.1710	20 4c 17	jsr $174c			jsr 	StringAllocTemp 			; allocate memory
.1713	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.1715					_USCopy:
.1715	b9 97 05	lda $0597,y			lda 	decimalBuffer-1,y
.1718	f0 05		beq $171f			beq 	_USExit
.171a	91 22		sta ($22),y			sta 	(zsTemp),y
.171c	c8		iny				iny
.171d	80 f6		bra $1715			bra 	_USCopy
.171f					_USExit:
.171f	98		tya				tya
.1720	3a		dec a				dec 	a
.1721	92 22		sta ($22)			sta 	(zsTemp)
.1723	7a		ply				ply
.1724	4c 4f 08	jmp $084f			jmp 	NextCommand
.1727					StringInitialise:
.1727	48		pha				pha
.1728	ad 6a 05	lda $056a			lda 	stringInitialised 			; already done
.172b	d0 11		bne $173e			bne 	_SIExit
.172d	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.1730	8d 6b 05	sta $056b			sta 	stringTempPointer
.1733	ad 03 04	lda $0403			lda 	stringHighMemory+1
.1736	3a		dec a				dec 	a
.1737	3a		dec a				dec 	a
.1738	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.173b	ce 6a 05	dec $056a			dec 	stringInitialised 			; set the initialised flag.
.173e					_SIExit:
.173e	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.1740	1a		inc a				inc 	a
.1741	1a		inc a				inc 	a
.1742	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.1745	b0 02		bcs $1749			bcs 	_SIMemory
.1747	68		pla				pla
.1748	60		rts				rts
.1749					_SIMemory:
.1749	4c 3b 20	jmp $203b		jmp	ErrorV_memory
.174c					StringAllocTemp:
.174c	20 27 17	jsr $1727			jsr 	StringInitialise 			; check it is initialised.
.174f	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.1751	18		clc				clc
.1752	6d 6b 05	adc $056b			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.1755	8d 6b 05	sta $056b			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.1758	85 22		sta $22				sta 	zsTemp
.175a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.175c	ad 6c 05	lda $056c			lda 	stringTempPointer+1
.175f	69 ff		adc #$ff			adc 	#$FF
.1761	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.1764	85 23		sta $23				sta 	zsTemp+1
.1766	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1768	74 56		stz $56,x			stz 	NSMantissa2,x
.176a	74 62		stz $62,x			stz 	NSMantissa3,x
.176c	a9 00		lda #$00			lda 	#0 							; clear string.
.176e	92 22		sta ($22)			sta 	(zsTemp)
.1770	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1772	95 32		sta $32,x			sta 	NSStatus,x
.1774	60		rts				rts
.1775					StringWriteChar:
.1775	5a		phy				phy
.1776	48		pha				pha
.1777	b2 22		lda ($22)			lda 	(zsTemp)
.1779	1a		inc a				inc 	a
.177a	92 22		sta ($22)			sta 	(zsTemp)
.177c	a8		tay				tay
.177d	68		pla				pla
.177e	91 22		sta ($22),y			sta 	(zsTemp),y
.1780	7a		ply				ply
.1781	60		rts				rts
.056a					stringInitialised:
>056a							.fill 	1
.056b					stringTempPointer:
>056b							.fill 	2
.1782					Unary_Left:
.1782	fa		plx				plx
.1783	5a		phy				phy
.1784	18		clc				clc 								; only one parameter
.1785	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the length of the string.
.1788	48		pha				pha
.1789	ca		dex				dex
.178a	a9 00		lda #$00			lda 	#0 							; push the start position.
.178c	48		pha				pha
.178d	20 c5 17	jsr $17c5			jsr 	UnarySStringToZTemp0
.1790	80 3c		bra $17ce			bra 	SubstringMain 				; stack now points to the string to slice.
.1792					Unary_Right:
.1792	fa		plx				plx
.1793	5a		phy				phy
.1794	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.1796	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the right length of the string.
.1799	48		pha				pha
.179a	ca		dex				dex
.179b	20 c5 17	jsr $17c5			jsr 	UnarySStringToZTemp0
.179e	68		pla				pla 								; this is the right requirement
.179f	38		sec				sec
.17a0	49 ff		eor #$ff			eor 	#$FF
.17a2	72 2c		adc ($2c)			adc 	(zTemp0)
.17a4	b0 02		bcs $17a8			bcs 	_URHaveCount
.17a6	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.17a8					_URHaveCount:
.17a8	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.17aa	5a		phy				phy
.17ab	48		pha				pha 								; start position
.17ac	80 20		bra $17ce			bra 	SubstringMain
.17ae					Unary_Mid:
.17ae	fa		plx				plx
.17af	5a		phy				phy
.17b0	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the length of the string required.
.17b3	48		pha				pha
.17b4	ca		dex				dex
.17b5	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; put the start position.
.17b8	f0 08		beq $17c2			beq 	_UMError
.17ba	3a		dec a				dec 	a
.17bb	48		pha				pha
.17bc	ca		dex				dex
.17bd	20 c5 17	jsr $17c5			jsr 	UnarySStringToZTemp0
.17c0	80 0c		bra $17ce			bra 	SubstringMain 				; stack now points to the string to slice.
.17c2					_UMError:
.17c2	4c 30 1f	jmp $1f30		jmp	ErrorV_range
.17c5					UnarySStringToZTemp0:
.17c5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17c7	85 2c		sta $2c				sta 	zTemp0
.17c9	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17cb	85 2d		sta $2d				sta 	zTemp0+1
.17cd	60		rts				rts
.17ce					SubstringMain:
.17ce	68		pla				pla 								; get the start offset
.17cf	7a		ply				ply 								; get the count to do.
.17d0	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.17d2	b0 38		bcs $180c			bcs 	_SSReturnNull
.17d4	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.17d6	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.17d8	18		clc				clc
.17d9	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.17db	b0 06		bcs $17e3			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.17dd	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.17df	f0 04		beq $17e5			beq 	_SMIsOkay
.17e1	90 02		bcc $17e5			bcc 	_SMIsOkay
.17e3					_SMTruncateToEnd:
.17e3	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.17e5					_SMIsOkay:
.17e5	85 2f		sta $2f				sta 	zTemp1+1
.17e7	38		sec				sec		 							; work out size
.17e8	a5 2f		lda $2f				lda 	zTemp1+1
.17ea	e5 2e		sbc $2e				sbc 	zTemp1
.17ec	f0 1e		beq $180c			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.17ee	20 4c 17	jsr $174c			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.17f1	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.17f3					_SMCopy:
.17f3	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.17f5	f0 11		beq $1808			beq 	_SMExit
.17f7	c8		iny				iny 								; bump and
.17f8	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.17fa	5a		phy				phy
.17fb	48		pha				pha
.17fc	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.17fe	1a		inc a				inc 	a
.17ff	a8		tay				tay
.1800	92 22		sta ($22)			sta 	(zsTemp)
.1802	68		pla				pla 								; write character out
.1803	91 22		sta ($22),y			sta 	(zsTemp),y
.1805	7a		ply				ply 								; restore Y
.1806	80 eb		bra $17f3			bra 	_SMCopy
.1808					_SMExit:
.1808	7a		ply				ply
.1809	4c 4f 08	jmp $084f			jmp 	NextCommand
.180c					_SSReturnNull:
.180c	a9 1e		lda #$1e			lda 	#SSRNull & $FF 				; set up mantissa
.180e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1810	a9 18		lda #$18			lda 	#SSRNull >> 8
.1812	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1814	74 56		stz $56,x			stz 	NSMantissa2,x
.1816	74 62		stz $62,x			stz 	NSMantissa3,x
.1818	a9 40		lda #$40			lda 	#NSSString
.181a	95 32		sta $32,x			sta 	NSStatus,x
.181c	80 ea		bra $1808			bra 	_SMExit
.181e					SSRNull:
>181e	00 00						.word 	0
.1820					CommandSwap:
.1820	fa		plx				plx
.1821	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1823	48		pha				pha
.1824	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1826	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1828	68		pla				pla
.1829	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.182b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.182d	48		pha				pha
.182e	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.1830	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1832	68		pla				pla
.1833	95 49		sta $49,x			sta 	NSMantissa1-1,x
.1835	b5 56		lda $56,x			lda 	NSMantissa2,x
.1837	48		pha				pha
.1838	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.183a	95 56		sta $56,x			sta 	NSMantissa2,x
.183c	68		pla				pla
.183d	95 55		sta $55,x			sta 	NSMantissa2-1,x
.183f	b5 62		lda $62,x			lda 	NSMantissa3,x
.1841	48		pha				pha
.1842	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.1844	95 62		sta $62,x			sta 	NSMantissa3,x
.1846	68		pla				pla
.1847	95 61		sta $61,x			sta 	NSMantissa3-1,x
.1849	b5 6e		lda $6e,x			lda 	NSExponent,x
.184b	48		pha				pha
.184c	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.184e	95 6e		sta $6e,x			sta 	NSExponent,x
.1850	68		pla				pla
.1851	95 6d		sta $6d,x			sta 	NSExponent-1,x
.1853	b5 32		lda $32,x			lda 	NSStatus,x
.1855	48		pha				pha
.1856	b5 31		lda $31,x			lda 	NSStatus-1,x
.1858	95 32		sta $32,x			sta 	NSStatus,x
.185a	68		pla				pla
.185b	95 31		sta $31,x			sta 	NSStatus-1,x
.185d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1860					CommandSYS:
.1860	fa		plx				plx
.1861	da		phx				phx 								; save XY
.1862	5a		phy				phy
.1863	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.1866	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.1868	85 2d		sta $2d				sta 	zTemp0+1
.186a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.186c	85 2c		sta $2c				sta 	zTemp0
.186e	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1871	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.1874	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.1877	48		pha				pha
.1878	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.187b	28		plp				plp
.187c	20 93 18	jsr $1893			jsr 	_CSZTemp0
.187f	08		php				php
.1880	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1883	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.1886	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.1889	68		pla				pla
.188a	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.188d	7a		ply				ply 								; restore YX and drop 2
.188e	fa		plx				plx
.188f	ca		dex				dex
.1890	4c 4f 08	jmp $084f			jmp 	NextCommand
.1893					_CSZTemp0:
.1893	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.1896					TimeTOS:
.1896	fa		plx				plx
.1897	20 f1 18	jsr $18f1			jsr 	TIPushClock 				; push clock to TOS
.189a	4c 4f 08	jmp $084f			jmp 	NextCommand
.189d					TimeString:
.189d	fa		plx				plx
.189e	20 f1 18	jsr $18f1			jsr 	TIPushClock 				; push clock to TOS
.18a1	20 c6 18	jsr $18c6			jsr 	_TSDivMod60 				; result in seconds
.18a4	20 c6 18	jsr $18c6			jsr 	_TSDivMod60 				; seconds
.18a7	48		pha				pha
.18a8	20 c6 18	jsr $18c6			jsr 	_TSDivMod60 				; minutes
.18ab	48		pha				pha
.18ac	a9 18		lda #$18			lda 	#24 						; hours
.18ae	20 c8 18	jsr $18c8			jsr 	_TSDivModA
.18b1	48		pha				pha
.18b2	a9 06		lda #$06			lda 	#6
.18b4	20 4c 17	jsr $174c			jsr 	StringAllocTemp
.18b7	68		pla				pla
.18b8	20 d8 18	jsr $18d8			jsr 	_TSWriteDecimal
.18bb	68		pla				pla
.18bc	20 d8 18	jsr $18d8			jsr 	_TSWriteDecimal
.18bf	68		pla				pla
.18c0	20 d8 18	jsr $18d8			jsr 	_TSWriteDecimal
.18c3	4c 4f 08	jmp $084f			jmp 	NextCommand
.18c6					_TSDivMod60:
.18c6	a9 3c		lda #$3c			lda 	#60
.18c8					_TSDivModA:
.18c8	e8		inx				inx
.18c9	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.18cc	ca		dex				dex
.18cd	20 3b 22	jsr $223b			jsr 	Int32Divide
.18d0	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.18d2	48		pha				pha
.18d3	20 2a 22	jsr $222a			jsr 	NSMCopyPlusTwoToZero
.18d6	68		pla				pla
.18d7	60		rts				rts
.18d8					_TSWriteDecimal:
.18d8	da		phx				phx
.18d9	a2 30		ldx #$30			ldx 	#'0'
.18db					_TSWDLoop:
.18db	c9 0a		cmp #$0a			cmp 	#10
.18dd	90 05		bcc $18e4			bcc 	_TSWDEnd
.18df	e9 0a		sbc #$0a			sbc 	#10
.18e1	e8		inx				inx
.18e2	80 f7		bra $18db			bra 	_TSWDLoop
.18e4					_TSWDEnd:
.18e4	48		pha				pha
.18e5	8a		txa				txa
.18e6	20 75 17	jsr $1775			jsr 	StringWriteChar
.18e9	68		pla				pla
.18ea	09 30		ora #$30			ora 	#'0'
.18ec	20 75 17	jsr $1775			jsr 	StringWriteChar
.18ef	fa		plx				plx
.18f0	60		rts				rts
.18f1					TIPushClock:
.18f1	5a		phy				phy
.18f2	e8		inx				inx 								; push 0 on the stack
.18f3	20 a5 26	jsr $26a5			jsr 	FloatSetZero
.18f6	da		phx				phx
.18f7	20 ee 1c	jsr $1cee			jsr 	XReadClock 					; read time into YXA
.18fa	86 2c		stx $2c				stx 	zTemp0
.18fc	fa		plx				plx
.18fd	95 3e		sta $3e,x			sta 	NSMantissa0,x
.18ff	a5 2c		lda $2c				lda 	zTemp0
.1901	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1903	98		tya				tya
.1904	95 56		sta $56,x			sta 	NSMantissa2,x
.1906	7a		ply				ply
.1907	60		rts				rts
.1908					CommandTIWrite:
.1908	fa		plx				plx
.1909	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.190b	85 22		sta $22				sta 	zsTemp
.190d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.190f	85 23		sta $23				sta 	zsTemp+1
.1911	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.1913	c9 06		cmp #$06			cmp 	#6
.1915	d0 59		bne $1970			bne 	_CTIWError
.1917	20 a5 26	jsr $26a5			jsr 	FloatSetZero
.191a	20 3c 19	jsr $193c			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.191d	20 3c 19	jsr $193c			jsr 	_CTIWDigitPair
.1920	20 3c 19	jsr $193c			jsr 	_CTIWDigitPair
.1923	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.1925	20 67 19	jsr $1967			jsr 	_CTIWMultiply
.1928	da		phx				phx
.1929	5a		phy				phy
.192a	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.192c	48		pha				pha
.192d	b5 56		lda $56,x			lda 	NSMantissa2,x
.192f	a8		tay				tay
.1930	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1932	fa		plx				plx
.1933	20 f2 1c	jsr $1cf2			jsr 	XWriteClock 				; update the clock.
.1936	7a		ply				ply
.1937	fa		plx				plx
.1938	ca		dex				dex 								; throw result.
.1939	4c 4f 08	jmp $084f			jmp 	NextCommand
.193c					_CTIWDigitPair:
.193c	a9 06		lda #$06			lda 	#6 							; x 6
.193e	20 67 19	jsr $1967			jsr 	_CTIWMultiply
.1941	20 4d 19	jsr $194d			jsr 	_CTIWAddDigit 				; add digit
.1944	a9 0a		lda #$0a			lda 	#10 						; x 10
.1946	20 67 19	jsr $1967			jsr 	_CTIWMultiply
.1949	20 4d 19	jsr $194d			jsr 	_CTIWAddDigit 				; add digit
.194c	60		rts				rts
.194d					_CTIWAddDigit:
.194d	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.194f	d0 02		bne $1953			bne 	_CTIWASkip
.1951	e6 23		inc $23				inc 	zsTemp+1
.1953					_CTIWASkip:
.1953	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.1955	38		sec				sec
.1956	e9 30		sbc #$30			sbc 	#"0"
.1958	90 16		bcc $1970			bcc 	_CTIWError
.195a	c9 0a		cmp #$0a			cmp 	#9+1
.195c	b0 12		bcs $1970			bcs 	_CTIWError
.195e	e8		inx				inx 								; store at +1
.195f	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.1962	ca		dex				dex
.1963	20 31 24	jsr $2431			jsr 	FloatAddTopTwoStack
.1966	60		rts				rts
.1967					_CTIWMultiply:
.1967	e8		inx				inx
.1968	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.196b	ca		dex				dex
.196c	20 b2 23	jsr $23b2			jsr 	FloatMultiplyShort
.196f	60		rts				rts
.1970					_CTIWError:
.1970	4c 40 1f	jmp $1f40		jmp	ErrorV_value
.1973					UnaryUsr:
.1973	fa		plx				plx
.1974	5a		phy				phy
.1975	20 7c 19	jsr $197c			jsr 	_UUCallVector
.1978	7a		ply				ply
.1979	4c 4f 08	jmp $084f			jmp 	NextCommand
.197c					_UUCallVector:
.197c	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.197f					ValUnary:
.197f	fa		plx				plx
.1980	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1982	85 2c		sta $2c				sta 	zTemp0
.1984	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1986	85 2d		sta $2d				sta 	zTemp0+1
.1988	20 93 19	jsr $1993			jsr 	ValEvaluateZTemp0
.198b	b0 03		bcs $1990			bcs 	_VUError 					; couldn't convert
.198d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1990					_VUError:
.1990	4c 40 1f	jmp $1f40		jmp	ErrorV_value
.1993					ValEvaluateZTemp0:
.1993	5a		phy				phy
.1994	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.1996	f0 22		beq $19ba			beq 	_VMCFail2
.1998	a0 00		ldy #$00			ldy 	#0 							; start position
.199a					_VMCSpaces:
.199a	c8		iny				iny 								; skip leading spaces
.199b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.199d	c9 20		cmp #$20			cmp 	#" "
.199f	f0 f9		beq $199a			beq 	_VMCSpaces
.19a1	48		pha				pha 								; save first character
.19a2	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.19a4	d0 01		bne $19a7			bne 	_VMCStart
.19a6	c8		iny				iny 								; skip over - if so.
.19a7					_VMCStart:
.19a7	38		sec				sec 								; initialise first time round.
.19a8					_VMCNext:
.19a8	98		tya				tya 								; reached end of string
.19a9	3a		dec a				dec 	a
.19aa	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.19ac	f0 0f		beq $19bd			beq 	_VMCSuccess 				; successful.
.19ae	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.19b0	c8		iny				iny
.19b1	20 89 24	jsr $2489			jsr 	FloatEncode 				; send it to the number-builder
.19b4	90 03		bcc $19b9			bcc 	_VMCFail 					; if failed, give up.
.19b6	18		clc				clc 								; next time round, countinue
.19b7	80 ef		bra $19a8			bra 	_VMCNext
.19b9					_VMCFail:
.19b9	68		pla				pla
.19ba					_VMCFail2:
.19ba	7a		ply				ply
.19bb	38		sec				sec
.19bc	60		rts				rts
.19bd					_VMCSuccess:
.19bd	a9 00		lda #$00			lda 	#0 							; construct final
.19bf	20 89 24	jsr $2489			jsr 	FloatEncode 				; by sending a duff value.
.19c2	68		pla				pla 								; if it was -ve
.19c3	c9 2d		cmp #$2d			cmp 	#"-"
.19c5	d0 03		bne $19ca			bne 	_VMCNotNegative
.19c7	20 67 26	jsr $2667			jsr		FloatNegate 				; negate it.
.19ca					_VMCNotNegative:
.19ca	7a		ply				ply
.19cb	18		clc				clc
.19cc	60		rts				rts
.19cd					VectorTable:
>19cd	a9 10					.word	LinkFloatAdd             ; $80 +
>19cf	b2 10					.word	LinkFloatSubtract        ; $81 -
>19d1	bb 10					.word	LinkFloatMultiply        ; $82 *
>19d3	c4 10					.word	LinkFloatDivide          ; $83 /
>19d5	cf 10					.word	LinkFloatPower           ; $84 ^
>19d7	f2 08					.word	BinaryAnd                ; $85 and
>19d9	f6 08					.word	BinaryOr                 ; $86 or
>19db	da 10					.word	LinkCompareGreater       ; $87 >
>19dd	e3 10					.word	LinkCompareEqual         ; $88 =
>19df	ec 10					.word	LinkCompareLess          ; $89 <
>19e1	f5 10					.word	LinkCompareGreaterEqual  ; $8a >=
>19e3	fe 10					.word	LinkCompareNotEqual      ; $8b <>
>19e5	07 11					.word	LinkCompareLessEqual     ; $8c <=
>19e7	da 08					.word	AbsoluteTOS              ; $8d abs
>19e9	2d 09					.word	ArrayConvert             ; $8e array
>19eb	d5 09					.word	UnaryAsc                 ; $8f asc
>19ed	f0 09					.word	CommandAssert            ; $90 assert
>19ef	31 0a					.word	Unary16Bin               ; $91 bin$
>19f1	5b 0a					.word	PrintCharacterX          ; $92 print.chr
>19f3	65 0a					.word	UnaryChr                 ; $93 chr$
>19f5	ca 0a					.word	CompareStrings           ; $94 s.cmp
>19f7	b6 0c					.word	CommandXFor              ; $95 for
>19f9	79 0d					.word	UnaryFre                 ; $96 fre
>19fb	91 0d					.word	CommandXGet              ; $97 get
>19fd	b7 0d					.word	CommandReturn            ; $98 return
>19ff	f9 0d					.word	Command_PSET             ; $99 pset
>1a01	13 0e					.word	Command_LINE             ; $9a line
>1a03	28 0e					.word	Command_RECT             ; $9b rect
>1a05	37 0e					.word	Command_FRAME            ; $9c frame
>1a07	46 0e					.word	Command_CHAR             ; $9d char
>1a09	dd 0e					.word	Unary16Hex               ; $9e hex$
>1a0b	84 0f					.word	CommandXInput            ; $9f input
>1a0d	9b 0f					.word	CommandInputString       ; $a0 input$
>1a0f	b4 0f					.word	CommandInputReset        ; $a1 input.start
>1a11	98 10					.word	UnaryLen                 ; $a2 len
>1a13	64 11					.word	LinkFloatCompare         ; $a3 f.cmp
>1a15	6d 11					.word	LinkDivideInt32          ; $a4 int.div
>1a17	02 12					.word	NegateTOS                ; $a5 negate
>1a19	09 12					.word	CommandNewLine           ; $a6 new.line
>1a1b	12 12					.word	CommandXNext             ; $a7 next
>1a1d	fb 12					.word	NotTOS                   ; $a8 not
>1a1f	12 13					.word	CommandXOn               ; $a9 on
>1a21	2f 13					.word	CommandMoreOn            ; $aa moreon
>1a23	36 13					.word	UnaryPeek                ; $ab peek
>1a25	4b 13					.word	UnaryPI                  ; $ac pi
>1a27	55 13					.word	CommandPOKE              ; $ad poke
>1a29	6d 13					.word	UnaryPos                 ; $ae pos
>1a2b	77 13					.word	GetChannel               ; $af getchannel
>1a2d	82 13					.word	SetChannel               ; $b0 setchannel
>1a2f	a5 13					.word	PrintNumber              ; $b1 print.n
>1a31	c4 13					.word	PrintString              ; $b2 print.s
>1a33	2b 14					.word	CommandXRead             ; $b3 read
>1a35	45 14					.word	CommandReadString        ; $b4 read$
>1a37	e6 15					.word	UnaryRND                 ; $b5 rnd
>1a39	55 16					.word	StringConcatenate        ; $b6 concat
>1a3b	ac 16					.word	SignTOS                  ; $b7 sgn
>1a3d	cf 16					.word	PrintTab                 ; $b8 print.tab
>1a3f	dd 16					.word	PrintPos                 ; $b9 print.pos
>1a41	ee 16					.word	PrintSpace               ; $ba print.spc
>1a43	07 17					.word	Unary_Str                ; $bb str$
>1a45	82 17					.word	Unary_Left               ; $bc left$
>1a47	92 17					.word	Unary_Right              ; $bd right$
>1a49	ae 17					.word	Unary_Mid                ; $be mid$
>1a4b	20 18					.word	CommandSwap              ; $bf swap
>1a4d	96 18					.word	TimeTOS                  ; $c0 ti
>1a4f	9d 18					.word	TimeString               ; $c1 ti$
>1a51	73 19					.word	UnaryUsr                 ; $c2 usr
>1a53	7f 19					.word	ValUnary                 ; $c3 val
>1a55	ea 1b					.word	CommandClose             ; $c4 close
>1a57	fc 1b					.word	CommandExit              ; $c5 exit
>1a59	02 1c					.word	CommandDebug             ; $c6 debug
>1a5b	68 1c					.word	CommandXOpen             ; $c7 open
>1a5d	fc 1c					.word	CommandScreen            ; $c8 screen
>1a5f	e0 1e					.word	CommandVPOKE             ; $c9 vpoke
>1a61	05 1f					.word	CommandVPEEK             ; $ca vpeek
>1a63	c7 16					.word	CommandShift             ; $cb .shift
>1a65	9e 08					.word	PushByteCommand          ; $cc .byte
>1a67	b1 08					.word	PushWordCommand          ; $cd .word
>1a69	e7 13					.word	CommandPushN             ; $ce .float
>1a6b	0d 14					.word	CommandPushS             ; $cf .string
>1a6d	52 0b					.word	CommandXData             ; $d0 .data
>1a6f	c8 0d					.word	CommandXGoto             ; $d1 .goto
>1a71	ab 0d					.word	CommandXGosub            ; $d2 .gosub
>1a73	dd 0d					.word	CommandGotoZ             ; $d3 .goto.z
>1a75	eb 0d					.word	CommandGotoNZ            ; $d4 .goto.nz
>1a77	e0 08					.word	CommandVarSpace          ; $d5 .varspace
>1a79	be 15					.word	CommandRestoreX          ; $d6 .restore
.1a7b					ShiftVectorTable:
>1a7b	7d 0a					.word	CommandClr               ; $cb80 clr
>1a7d	5b 0b					.word	CommandXDIM              ; $cb81 dim
>1a7f	4c 0c					.word	CommandEnd               ; $cb82 end
>1a81	69 10					.word	UnaryJoy                 ; $cb83 joy
>1a83	10 11					.word	LinkFloatIntegerPartDown ; $cb84 int
>1a85	19 11					.word	LinkFloatSquareRoot      ; $cb85 sqr
>1a87	2a 11					.word	LinkFloatLogarithm       ; $cb86 log
>1a89	35 11					.word	LinkFloatExponent        ; $cb87 exp
>1a8b	3e 11					.word	LinkFloatCosine          ; $cb88 cos
>1a8d	47 11					.word	LinkFloatSine            ; $cb89 sin
>1a8f	50 11					.word	LinkFloatTangent         ; $cb8a tan
>1a91	59 11					.word	LinkFloatArcTan          ; $cb8b atn
>1a93	97 11					.word	XCommandMouse            ; $cb8c mouse
>1a95	ac 11					.word	XUnaryMB                 ; $cb8d mb
>1a97	b9 11					.word	XUnaryMX                 ; $cb8e mx
>1a99	ca 11					.word	XUnaryMY                 ; $cb8f my
>1a9b	db 11					.word	XUnaryMWheel             ; $cb90 mwheel
>1a9d	03 17					.word	CommandStop              ; $cb91 stop
>1a9f	60 18					.word	CommandSYS               ; $cb92 sys
>1aa1	08 19					.word	CommandTIWrite           ; $cb93 ti$.write
>1aa3	d9 1a					.word	CommandXWAIT             ; $cb94 wait
>1aa5	2d 1c					.word	X16I2CPoke               ; $cb95 i2cpoke
>1aa7	4d 1c					.word	X16I2CPeek               ; $cb96 i2cpeek
>1aa9	b8 1c					.word	CommandBank              ; $cb97 bank
>1aab	0b 1d					.word	XCommandSleep            ; $cb98 sleep
>1aad	2f 1d					.word	X16_Audio_FMINIT         ; $cb99 fminit
>1aaf	3d 1d					.word	X16_Audio_FMNOTE         ; $cb9a fmnote
>1ab1	4f 1d					.word	X16_Audio_FMDRUM         ; $cb9b fmdrum
>1ab3	61 1d					.word	X16_Audio_FMINST         ; $cb9c fminst
>1ab5	73 1d					.word	X16_Audio_FMVIB          ; $cb9d fmvib
>1ab7	85 1d					.word	X16_Audio_FMFREQ         ; $cb9e fmfreq
>1ab9	96 1d					.word	X16_Audio_FMVOL          ; $cb9f fmvol
>1abb	a8 1d					.word	X16_Audio_FMPAN          ; $cba0 fmpan
>1abd	ba 1d					.word	X16_Audio_FMPLAY         ; $cba1 fmplay
>1abf	cb 1d					.word	X16_Audio_FMCHORD        ; $cba2 fmchord
>1ac1	dc 1d					.word	X16_Audio_FMPOKE         ; $cba3 fmpoke
>1ac3	ee 1d					.word	X16_Audio_PSGINIT        ; $cba4 psginit
>1ac5	fc 1d					.word	X16_Audio_PSGNOTE        ; $cba5 psgnote
>1ac7	0e 1e					.word	X16_Audio_PSGVOL         ; $cba6 psgvol
>1ac9	20 1e					.word	X16_Audio_PSGWAV         ; $cba7 psgwav
>1acb	32 1e					.word	X16_Audio_PSGFREQ        ; $cba8 psgfreq
>1acd	43 1e					.word	X16_Audio_PSGPAN         ; $cba9 psgpan
>1acf	55 1e					.word	X16_Audio_PSGPLAY        ; $cbaa psgplay
>1ad1	66 1e					.word	X16_Audio_PSGCHORD       ; $cbab psgchord
>1ad3	77 1e					.word	CommandCls               ; $cbac cls
>1ad5	80 1e					.word	CommandLocate            ; $cbad locate
>1ad7	a7 1e					.word	CommandColor             ; $cbae color
.1ad9					CommandXWAIT:
.1ad9	fa		plx				plx
.1ada	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1adc	85 2c		sta $2c				sta 	zTemp0
.1ade	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1ae0	85 2d		sta $2d				sta 	zTemp0+1
.1ae2					_WaitLoop:
.1ae2	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1ae4	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1ae6	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1ae8	f0 f8		beq $1ae2			beq 	_WaitLoop 					; keep going if zero
.1aea	ca		dex				dex 								; drop 3.
.1aeb	ca		dex				dex
.1aec	ca		dex				dex
.1aed	4c 4f 08	jmp $084f			jmp 	NextCommand
.1af0					WriteFloatCommand:
.1af0	fa		plx				plx
.1af1	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1af3	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1af5	88		dey				dey 								; get the upper 3 bits
.1af6	b1 28		lda ($28),y			lda 	(codePtr),y
.1af8	29 07		and #$07			and 	#7
.1afa	c8		iny				iny
.1afb	c8		iny				iny
.1afc	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1afe	2a		rol a				rol 	a 							; carry will be clear.
.1aff	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b02	85 2d		sta $2d				sta 	zTemp0+1
.1b04	20 0a 1b	jsr $1b0a			jsr 	WriteFloatZTemp0Sub
.1b07	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b0a					WriteFloatZTemp0Sub:
.1b0a	5a		phy				phy 								; ldart write
.1b0b	a0 01		ldy #$01			ldy 	#1
.1b0d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b0f	92 2c		sta ($2c)			sta 	(zTemp0)
.1b11	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b13	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b15	c8		iny				iny
.1b16	b5 56		lda $56,x			lda 	NSMantissa2,x
.1b18	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b1a	c8		iny				iny
.1b1b	b5 62		lda $62,x			lda 	NSMantissa3,x
.1b1d	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b1f	c8		iny				iny
.1b20	b5 6e		lda $6e,x			lda 	NSExponent,x
.1b22	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b24	c8		iny				iny
.1b25	b5 32		lda $32,x			lda 	NSStatus,x
.1b27	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b29	ca		dex				dex
.1b2a	7a		ply				ply
.1b2b	60		rts				rts
.1b2c					WriteIntegerCommand:
.1b2c	fa		plx				plx
.1b2d	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b2f	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b31	88		dey				dey 								; get the upper 3 bits
.1b32	b1 28		lda ($28),y			lda 	(codePtr),y
.1b34	29 07		and #$07			and 	#7
.1b36	c8		iny				iny
.1b37	c8		iny				iny
.1b38	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b3a	2a		rol a				rol 	a 							; carry will be clear.
.1b3b	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b3e	85 2d		sta $2d				sta 	zTemp0+1
.1b40	20 46 1b	jsr $1b46			jsr 	WriteIntegerZTemp0Sub
.1b43	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b46					WriteIntegerZTemp0Sub:
.1b46	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.1b49	5a		phy				phy 								; start write
.1b4a	a0 01		ldy #$01			ldy 	#1
.1b4c	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1b4e	30 0b		bmi $1b5b			bmi 	_WIZNegative
.1b50	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1b52	92 2c		sta ($2c)			sta 	(zTemp0)
.1b54	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b56	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b58	7a		ply				ply
.1b59	ca		dex				dex
.1b5a	60		rts				rts
.1b5b					_WIZNegative:
.1b5b	38		sec				sec 								; -ve read
.1b5c	a9 00		lda #$00			lda 	#0
.1b5e	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1b60	92 2c		sta ($2c)			sta 	(zTemp0)
.1b62	a9 00		lda #$00			lda 	#0
.1b64	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1b66	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b68	7a		ply				ply
.1b69	ca		dex				dex
.1b6a	60		rts				rts
.1b6b					WriteStringCommand:
.1b6b	fa		plx				plx
.1b6c	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b6e	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b70	88		dey				dey 								; get the upper 3 bits
.1b71	b1 28		lda ($28),y			lda 	(codePtr),y
.1b73	29 07		and #$07			and 	#7
.1b75	c8		iny				iny
.1b76	c8		iny				iny
.1b77	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b79	2a		rol a				rol 	a 							; carry will be clear.
.1b7a	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b7d	85 2d		sta $2d				sta 	zTemp0+1
.1b7f	20 85 1b	jsr $1b85			jsr 	WriteStringZTemp0Sub
.1b82	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b85					WriteStringZTemp0Sub:
.1b85	5a		phy				phy
.1b86	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b88	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b8a	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b8c	f0 1e		beq $1bac			beq 	_WSConcrete
.1b8e	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b90	85 2e		sta $2e				sta 	zTemp1
.1b92	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b94	85 2f		sta $2f				sta 	zTemp1+1
.1b96	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b98	85 30		sta $30				sta 	zTemp2
.1b9a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b9c	85 31		sta $31				sta 	zTemp2+1
.1b9e	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1ba0	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1ba2	b0 17		bcs $1bbb			bcs 	_WSCopy
.1ba4	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1ba6	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1ba8	09 80		ora #$80			ora 	#$80
.1baa	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1bac					_WSConcrete:
.1bac	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1bae	a8		tay				tay
.1baf	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1bb1	20 0c 0b	jsr $0b0c			jsr 	StringConcrete
.1bb4	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1bb6	98		tya				tya
.1bb7	a0 01		ldy #$01			ldy 	#1
.1bb9	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1bbb					_WSCopy
.1bbb	18		clc				clc  								; copy target+2 to zTemp2
.1bbc	b2 2c		lda ($2c)			lda 	(zTemp0)
.1bbe	69 02		adc #$02			adc 	#2
.1bc0	85 30		sta $30				sta 	zTemp2
.1bc2	a0 01		ldy #$01			ldy 	#1
.1bc4	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1bc6	69 00		adc #$00			adc 	#0
.1bc8	85 31		sta $31				sta 	zTemp2+1
.1bca	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1bcc	85 2e		sta $2e				sta 	zTemp1
.1bce	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1bd0	85 2f		sta $2f				sta 	zTemp1+1
.1bd2	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1bd4	a8		tay				tay
.1bd5					_WSCopyLoop:
.1bd5	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1bd7	91 30		sta ($30),y			sta 	(zTemp2),y
.1bd9	88		dey				dey
.1bda	c0 ff		cpy #$ff			cpy 	#$FF
.1bdc	d0 f7		bne $1bd5			bne 	_WSCopyLoop
.1bde	ca		dex				dex
.1bdf	7a		ply				ply
.1be0	60		rts				rts
.1be1					XCheckStop:
.1be1	20 e1 ff	jsr $ffe1			jsr 	$FFE1 						; check stop
.1be4	f0 01		beq $1be7			beq 	_XCSStop
.1be6	60		rts				rts
.1be7					_XCSStop:
.1be7	4c 62 20	jmp $2062		jmp	ErrorV_break
.1bea					CommandClose:
.1bea	fa		plx				plx
.1beb	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; channel to close
.1bee	cd 5f 04	cmp $045f			cmp 	currentChannel 				; is it the current channel
.1bf1	d0 03		bne $1bf6			bne 	_CCNotCurrent
.1bf3	9c 5f 04	stz $045f			stz 	currentChannel 				; effectively disables CMD
.1bf6					_CCNotCurrent:
.1bf6	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1bf9	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bfc					CommandExit:
.1bfc	fa		plx				plx
.1bfd	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1bff	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1c02					CommandDebug:
.1c02	fa		plx				plx
>1c03	db						.byte 	$DB 						; causes a break in the emulator
.1c04	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c07					XGetCharacterFromChannel:
.1c07	da		phx				phx
.1c08	5a		phy				phy
.1c09	e0 00		cpx #$00			cpx 	#0 							; is it default
.1c0b	d0 05		bne $1c12			bne 	_XGetChannel
.1c0d	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1c10	80 08		bra $1c1a			bra 	_XGetChar
.1c12					_XGetChannel:
.1c12	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1c15	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1c18	d0 06		bne $1c20			bne 	_XGCError
.1c1a					_XGetChar:
.1c1a	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1c1d	7a		ply				ply
.1c1e	fa		plx				plx
.1c1f	60		rts				rts
.1c20					_XGCError:
.1c20	4c 4c 20	jmp $204c		jmp	ErrorV_channel
.1c23					XGetHPos:
.1c23	da		phx				phx
.1c24	5a		phy				phy
.1c25	38		sec				sec
.1c26	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1c29	98		tya				tya
.1c2a	7a		ply				ply
.1c2b	fa		plx				plx
.1c2c	60		rts				rts
.1c2d					X16I2CPoke:
.1c2d	fa		plx				plx
.1c2e	5a		phy				phy
.1c2f	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; value
.1c32	48		pha				pha
.1c33	ca		dex				dex
.1c34	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; register
.1c37	48		pha				pha
.1c38	ca		dex				dex
.1c39	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; device
.1c3c	aa		tax				tax
.1c3d	7a		ply				ply
.1c3e	68		pla				pla
.1c3f	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1c42	b0 06		bcs $1c4a			bcs 	X16I2CError
.1c44	7a		ply				ply
.1c45	a2 ff		ldx #$ff			ldx 	#$FF
.1c47	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c4a					X16I2CError:
.1c4a	4c 4c 20	jmp $204c		jmp	ErrorV_channel
.1c4d					X16I2CPeek:
.1c4d	fa		plx				plx
.1c4e	da		phx				phx
.1c4f	5a		phy				phy
.1c50	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; register
.1c53	48		pha				pha
.1c54	ca		dex				dex
.1c55	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; device
.1c58	aa		tax				tax 								; X device
.1c59	7a		ply				ply 								; Y register
.1c5a	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1c5d	b0 eb		bcs $1c4a			bcs 	X16I2CError
.1c5f	7a		ply				ply 								; restore Y/X
.1c60	fa		plx				plx
.1c61	ca		dex				dex 								; drop TOS (register)
.1c62	20 a7 26	jsr $26a7			jsr 	FloatSetByte 				; write read value to TOS.
.1c65	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c68					CommandXOpen:
.1c68	fa		plx				plx
.1c69	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1c6b	85 2c		sta $2c				sta 	zTemp0
.1c6d	aa		tax				tax
.1c6e	a5 4d		lda $4d				lda 	NSMantissa1+3
.1c70	85 2d		sta $2d				sta 	zTemp0+1
.1c72	a8		tay				tay
.1c73	e8		inx				inx 								; XY points to first character
.1c74	d0 01		bne $1c77			bne 	_CONoCarry
.1c76	c8		iny				iny
.1c77					_CONoCarry:
.1c77	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c79	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c7c	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c7e	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c80	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c82	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c85	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c88	b0 03		bcs $1c8d			bcs 	_COError
.1c8a	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c8d					_COError:
.1c8d	4c 4c 20	jmp $204c		jmp	ErrorV_channel
.1c90					XPokeMemory:
.1c90	86 2c		stx $2c				stx 	zTemp0
.1c92	84 2d		sty $2d				sty 	zTemp0+1
.1c94	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c96	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c99	e0 ff		cpx #$ff			cpx 	#$FF
.1c9b	f0 02		beq $1c9f			beq 	_XPMNoSwitch
.1c9d	86 00		stx $00				stx 	SelectRAMBank
.1c9f					_XPMNoSwitch:
.1c9f	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1ca1	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1ca3					_XPMExit:
.1ca3	60		rts				rts
.1ca4					XPeekMemory:
.1ca4	86 2c		stx $2c				stx 	zTemp0
.1ca6	84 2d		sty $2d				sty 	zTemp0+1
.1ca8	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1caa	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1cad	e0 ff		cpx #$ff			cpx 	#$FF
.1caf	f0 02		beq $1cb3			beq 	_XPMNoSwitch
.1cb1	86 00		stx $00				stx 	SelectRAMBank
.1cb3					_XPMNoSwitch:
.1cb3	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1cb5	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1cb7	60		rts				rts
.1cb8					CommandBank:
.1cb8	fa		plx				plx
.1cb9	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1cbb	8d 6d 05	sta $056d			sta 	ramBank 					; store & make current
.1cbe	85 00		sta $00				sta 	SelectRAMBank
.1cc0	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1cc2	c9 ff		cmp #$ff			cmp 	#$FF
.1cc4	f0 03		beq $1cc9			beq 	_CBNoUpdate
.1cc6	8d 6e 05	sta $056e			sta 	romBank 					; this doesn't set the hardware page.
.1cc9					_CBNoUpdate:
.1cc9	a2 ff		ldx #$ff			ldx 	#$FF
.1ccb	4c 4f 08	jmp $084f			jmp 	NextCommand
.056d					ramBank:
>056d							.fill 	1
.056e					romBank:
>056e							.fill 	1
.1cce					XPrintCharacterToChannel:
.1cce	48		pha				pha
.1ccf	da		phx				phx
.1cd0	5a		phy				phy
.1cd1	48		pha				pha  								; save char
.1cd2	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1cd4	d0 05		bne $1cdb			bne 	_XPCNotDefault
.1cd6	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1cd9	80 08		bra $1ce3			bra 	_XPCSend
.1cdb					_XPCNotDefault:
.1cdb	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1cde	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1ce1	d0 08		bne $1ceb			bne 	_XPCError
.1ce3					_XPCSend:
.1ce3	68		pla				pla 								; restore character
.1ce4	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1ce7	7a		ply				ply
.1ce8	fa		plx				plx
.1ce9	68		pla				pla
.1cea	60		rts				rts
.1ceb					_XPCError:
.1ceb	4c 4c 20	jmp $204c		jmp	ErrorV_channel
.1cee					XReadClock:
.1cee	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1cf1	60		rts				rts
.1cf2					XWriteClock:
.1cf2	48		pha				pha
.1cf3	da		phx				phx
.1cf4	5a		phy				phy
.1cf5	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1cf8	7a		ply				ply
.1cf9	fa		plx				plx
.1cfa	68		pla				pla
.1cfb	60		rts				rts
.1cfc					CommandScreen:
.1cfc	fa		plx				plx
.1cfd	da		phx				phx
.1cfe	5a		phy				phy
.1cff	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1d02	18		clc				clc
.1d03	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1d06	7a		ply				ply
.1d07	fa		plx				plx
.1d08	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d0b					XCommandSleep:
.1d0b	fa		plx				plx
.1d0c	5a		phy				phy
.1d0d	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.1d10	ca		dex				dex
.1d11	20 ee 1c	jsr $1cee			jsr 	XReadClock 					; read clock to YXA
.1d14	18		clc				clc 								; calculate end time in zTemp0
.1d15	65 3e		adc $3e				adc 	NSMantissa0
.1d17	85 2c		sta $2c				sta 	zTemp0
.1d19	8a		txa				txa
.1d1a	65 4a		adc $4a				adc 	NSMantissa1
.1d1c	85 2d		sta $2d				sta 	zTemp0+1
.1d1e					_XCWait:
.1d1e	20 ee 1c	jsr $1cee			jsr 	XReadClock 					; and wait for it.
.1d21	c5 2c		cmp $2c				cmp 	zTemp0
.1d23	d0 f9		bne $1d1e			bne 	_XCWait
.1d25	e4 2d		cpx $2d				cpx 	zTemp0+1
.1d27	d0 f5		bne $1d1e			bne 	_XCWait
.1d29	a2 ff		ldx #$ff			ldx 	#$FF
.1d2b	7a		ply				ply
.1d2c	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d2f					X16_Audio_FMINIT:
.1d2f	fa		plx				plx
.1d30	5a		phy			phy
.1d31	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d34	63 c0					.word	X16A_ym_init
>1d36	0a					.byte	X16_AudioCodeBank
.1d37	a2 ff		ldx #$ff		ldx	#$FF
.1d39	7a		ply			ply
.1d3a	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d3d					X16_Audio_FMNOTE:
.1d3d	fa		plx				plx
.1d3e	5a		phy			phy
.1d3f	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d42	18		clc			clc
.1d43	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d46	03 c0					.word	X16A_bas_fmnote
>1d48	0a					.byte	X16_AudioCodeBank
.1d49	a2 ff		ldx #$ff		ldx	#$FF
.1d4b	7a		ply			ply
.1d4c	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d4f					X16_Audio_FMDRUM:
.1d4f	fa		plx				plx
.1d50	5a		phy			phy
.1d51	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d54	18		clc			clc
.1d55	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d58	6f c0					.word	X16A_ym_playdrum
>1d5a	0a					.byte	X16_AudioCodeBank
.1d5b	a2 ff		ldx #$ff		ldx	#$FF
.1d5d	7a		ply			ply
.1d5e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d61					X16_Audio_FMINST:
.1d61	fa		plx				plx
.1d62	5a		phy			phy
.1d63	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d66	38		sec			sec
.1d67	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d6a	69 c0					.word	X16A_ym_loadpatch
>1d6c	0a					.byte	X16_AudioCodeBank
.1d6d	a2 ff		ldx #$ff		ldx	#$FF
.1d6f	7a		ply			ply
.1d70	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d73					X16_Audio_FMVIB:
.1d73	fa		plx				plx
.1d74	5a		phy			phy
.1d75	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d78	18		clc			clc
.1d79	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d7c	09 c0					.word	X16A_bas_fmvib
>1d7e	0a					.byte	X16_AudioCodeBank
.1d7f	a2 ff		ldx #$ff		ldx	#$FF
.1d81	7a		ply			ply
.1d82	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d85					X16_Audio_FMFREQ:
.1d85	fa		plx				plx
.1d86	5a		phy			phy
.1d87	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1d8a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d8d	00 c0					.word	X16A_bas_fmfreq
>1d8f	0a					.byte	X16_AudioCodeBank
.1d90	a2 ff		ldx #$ff		ldx	#$FF
.1d92	7a		ply			ply
.1d93	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d96					X16_Audio_FMVOL:
.1d96	fa		plx				plx
.1d97	5a		phy			phy
.1d98	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d9b	18		clc			clc
.1d9c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d9f	75 c0					.word	X16A_ym_setatten
>1da1	0a					.byte	X16_AudioCodeBank
.1da2	a2 ff		ldx #$ff		ldx	#$FF
.1da4	7a		ply			ply
.1da5	4c 4f 08	jmp $084f			jmp 	NextCommand
.1da8					X16_Audio_FMPAN:
.1da8	fa		plx				plx
.1da9	5a		phy			phy
.1daa	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1dad	18		clc			clc
.1dae	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1db1	7e c0					.word	X16A_ym_setpan
>1db3	0a					.byte	X16_AudioCodeBank
.1db4	a2 ff		ldx #$ff		ldx	#$FF
.1db6	7a		ply			ply
.1db7	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dba					X16_Audio_FMPLAY:
.1dba	fa		plx				plx
.1dbb	5a		phy			phy
.1dbc	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1dbf	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dc2	06 c0					.word	X16A_bas_fmplaystring
>1dc4	0a					.byte	X16_AudioCodeBank
.1dc5	a2 ff		ldx #$ff		ldx	#$FF
.1dc7	7a		ply			ply
.1dc8	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dcb					X16_Audio_FMCHORD:
.1dcb	fa		plx				plx
.1dcc	5a		phy			phy
.1dcd	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1dd0	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dd3	8d c0					.word	X16A_bas_fmchordstring
>1dd5	0a					.byte	X16_AudioCodeBank
.1dd6	a2 ff		ldx #$ff		ldx	#$FF
.1dd8	7a		ply			ply
.1dd9	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ddc					X16_Audio_FMPOKE:
.1ddc	fa		plx				plx
.1ddd	5a		phy			phy
.1dde	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1de1	18		clc			clc
.1de2	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1de5	8a c0					.word	X16A_ym_write
>1de7	0a					.byte	X16_AudioCodeBank
.1de8	a2 ff		ldx #$ff		ldx	#$FF
.1dea	7a		ply			ply
.1deb	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dee					X16_Audio_PSGINIT:
.1dee	fa		plx				plx
.1def	5a		phy			phy
.1df0	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1df3	4b c0					.word	X16A_psg_init
>1df5	0a					.byte	X16_AudioCodeBank
.1df6	a2 ff		ldx #$ff		ldx	#$FF
.1df8	7a		ply			ply
.1df9	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dfc					X16_Audio_PSGNOTE:
.1dfc	fa		plx				plx
.1dfd	5a		phy			phy
.1dfe	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e01	18		clc			clc
.1e02	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e05	12 c0					.word	X16A_bas_psgnote
>1e07	0a					.byte	X16_AudioCodeBank
.1e08	a2 ff		ldx #$ff		ldx	#$FF
.1e0a	7a		ply			ply
.1e0b	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e0e					X16_Audio_PSGVOL:
.1e0e	fa		plx				plx
.1e0f	5a		phy			phy
.1e10	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e13	18		clc			clc
.1e14	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e17	54 c0					.word	X16A_psg_setatten
>1e19	0a					.byte	X16_AudioCodeBank
.1e1a	a2 ff		ldx #$ff		ldx	#$FF
.1e1c	7a		ply			ply
.1e1d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e20					X16_Audio_PSGWAV:
.1e20	fa		plx				plx
.1e21	5a		phy			phy
.1e22	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e25	18		clc			clc
.1e26	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e29	15 c0					.word	X16A_bas_psgwav
>1e2b	0a					.byte	X16_AudioCodeBank
.1e2c	a2 ff		ldx #$ff		ldx	#$FF
.1e2e	7a		ply			ply
.1e2f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e32					X16_Audio_PSGFREQ:
.1e32	fa		plx				plx
.1e33	5a		phy			phy
.1e34	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1e37	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e3a	0f c0					.word	X16A_bas_psgfreq
>1e3c	0a					.byte	X16_AudioCodeBank
.1e3d	a2 ff		ldx #$ff		ldx	#$FF
.1e3f	7a		ply			ply
.1e40	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e43					X16_Audio_PSGPAN:
.1e43	fa		plx				plx
.1e44	5a		phy			phy
.1e45	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e48	18		clc			clc
.1e49	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e4c	5a c0					.word	X16A_psg_setpan
>1e4e	0a					.byte	X16_AudioCodeBank
.1e4f	a2 ff		ldx #$ff		ldx	#$FF
.1e51	7a		ply			ply
.1e52	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e55					X16_Audio_PSGPLAY:
.1e55	fa		plx				plx
.1e56	5a		phy			phy
.1e57	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e5a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e5d	18 c0					.word	X16A_bas_psgplaystring
>1e5f	0a					.byte	X16_AudioCodeBank
.1e60	a2 ff		ldx #$ff		ldx	#$FF
.1e62	7a		ply			ply
.1e63	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e66					X16_Audio_PSGCHORD:
.1e66	fa		plx				plx
.1e67	5a		phy			phy
.1e68	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e6b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e6e	90 c0					.word	X16A_bas_psgchordstring
>1e70	0a					.byte	X16_AudioCodeBank
.1e71	a2 ff		ldx #$ff		ldx	#$FF
.1e73	7a		ply			ply
.1e74	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e77					CommandCls:
.1e77	fa		plx				plx
.1e78	a9 93		lda #$93			lda 	#147
.1e7a	20 ce 1c	jsr $1cce			jsr 	XPrintCharacterToChannel
.1e7d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e80					CommandLocate:
.1e80	fa		plx				plx
.1e81	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.1e84	ca		dex				dex
.1e85	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.1e88	ca		dex				dex
.1e89	48		pha				pha 								; save registers
.1e8a	da		phx				phx
.1e8b	5a		phy				phy
.1e8c	18		clc				clc
.1e8d	a4 3f		ldy $3f				ldy 	NSMantissa0+1 				; get coords
.1e8f	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e91	88		dey				dey 								; fix up
.1e92	ca		dex				dex
.1e93	20 f0 ff	jsr $fff0			jsr 	$FFF0 						; PLOT
.1e96	7a		ply				ply 								; restore registers
.1e97	fa		plx				plx
.1e98	68		pla				pla
.1e99	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e9c					_CLOutputXA:
.1e9c	ca		dex				dex
.1e9d	f0 07		beq $1ea6			beq 	_CLOExit
.1e9f	30 05		bmi $1ea6			bmi 	_CLOExit
.1ea1	20 ce 1c	jsr $1cce			jsr 	XPrintCharacterToChannel
.1ea4	80 f6		bra $1e9c			bra 	_CLOutputXA
.1ea6					_CLOExit:
.1ea6	60		rts				rts
.1ea7					CommandColor:
.1ea7	fa		plx				plx
.1ea8	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.1eab	ca		dex				dex
.1eac	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.1eaf	ca		dex				dex
.1eb0	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1eb2	c9 ff		cmp #$ff			cmp 	#$FF
.1eb4	f0 08		beq $1ebe			beq 	_CCNoBGR 					; if so, change background
.1eb6	20 c6 1e	jsr $1ec6			jsr 	_CCSetColour
.1eb9	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1ebb	20 ce 1c	jsr $1cce			jsr 	XPrintCharacterToChannel
.1ebe					_CCNoBGR:
.1ebe	a5 3e		lda $3e				lda 	NSMantissa0
.1ec0	20 c6 1e	jsr $1ec6			jsr 	_CCSetColour
.1ec3	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ec6					_CCSetColour:
.1ec6	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1ec8	aa		tax				tax
.1ec9	bd d0 1e	lda $1ed0,x			lda 	_CCCommandTable,x
.1ecc	20 ce 1c	jsr $1cce			jsr 	XPrintCharacterToChannel
.1ecf	60		rts				rts
.1ed0					_CCCommandTable:
>1ed0	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1ed8	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1ee0					CommandVPOKE:
.1ee0	fa		plx				plx
.1ee1	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; poke value
.1ee4	48		pha				pha
.1ee5	ca		dex				dex
.1ee6	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.1ee9	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1eeb	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1eee	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ef0	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ef3	ca		dex				dex
.1ef4	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.1ef7	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1efa	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1efd	ca		dex				dex
.1efe	68		pla				pla 								; poke value back
.1eff	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1f02	4c 4f 08	jmp $084f			jmp 	NextCommand
.1f05					CommandVPEEK:
.1f05	fa		plx				plx
.1f06	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.1f09	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1f0b	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1f0e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1f10	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1f13	ca		dex				dex
.1f14	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.1f17	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1f1a	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1f1d	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1f20	20 a7 26	jsr $26a7			jsr 	FloatSetByte 				; return as byte
.1f23	4c 4f 08	jmp $084f			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ff					C64_PI                   = $ff ; $ff pi
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ceb7					C64_BANNER               = $ceb7 ; $ceb7 banner
=$ceb8					C64_EXEC                 = $ceb8 ; $ceb8 exec
=$ceb9					C64_TILE                 = $ceb9 ; $ceb9 tile
=$ceba					C64_EDIT                 = $ceba ; $ceba edit
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$cedb					C64_MWHEEL               = $cedb ; $cedb mwheel
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$cb					PCD_ENDCOMMAND = $cb
=$cb					PCD_STARTSYSTEM = $cb
=$d7					PCD_ENDSYSTEM = $d7
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_PI               = $ac ; pi
=$ad					PCD_POKE             = $ad ; poke
=$ae					PCD_POS              = $ae ; pos
=$af					PCD_GETCHANNEL       = $af ; getchannel
=$b0					PCD_SETCHANNEL       = $b0 ; setchannel
=$b1					PCD_PRINTCMD_N       = $b1 ; print.n
=$b2					PCD_PRINTCMD_S       = $b2 ; print.s
=$b3					PCD_READ             = $b3 ; read
=$b4					PCD_READDOLLAR       = $b4 ; read$
=$b5					PCD_RND              = $b5 ; rnd
=$b6					PCD_CONCAT           = $b6 ; concat
=$b7					PCD_SGN              = $b7 ; sgn
=$b8					PCD_PRINTCMD_TAB     = $b8 ; print.tab
=$b9					PCD_PRINTCMD_POS     = $b9 ; print.pos
=$ba					PCD_PRINTCMD_SPC     = $ba ; print.spc
=$bb					PCD_STRDOLLAR        = $bb ; str$
=$bc					PCD_LEFTDOLLAR       = $bc ; left$
=$bd					PCD_RIGHTDOLLAR      = $bd ; right$
=$be					PCD_MIDDOLLAR        = $be ; mid$
=$bf					PCD_SWAP             = $bf ; swap
=$c0					PCD_TI               = $c0 ; ti
=$c1					PCD_TIDOLLAR         = $c1 ; ti$
=$c2					PCD_USR              = $c2 ; usr
=$c3					PCD_VAL              = $c3 ; val
=$c4					PCD_CLOSE            = $c4 ; close
=$c5					PCD_EXIT             = $c5 ; exit
=$c6					PCD_DEBUG            = $c6 ; debug
=$c7					PCD_OPEN             = $c7 ; open
=$c8					PCD_SCREEN           = $c8 ; screen
=$c9					PCD_VPOKE            = $c9 ; vpoke
=$ca					PCD_VPEEK            = $ca ; vpeek
=$cb					PCD_CMD_SHIFT        = $cb ; .shift
=$cc					PCD_CMD_BYTE         = $cc ; .byte
=$cd					PCD_CMD_WORD         = $cd ; .word
=$ce					PCD_CMD_FLOAT        = $ce ; .float
=$cf					PCD_CMD_STRING       = $cf ; .string
=$d0					PCD_CMD_DATA         = $d0 ; .data
=$d1					PCD_CMD_GOTO         = $d1 ; .goto
=$d2					PCD_CMD_GOSUB        = $d2 ; .gosub
=$d3					PCD_CMD_GOTOCMD_Z    = $d3 ; .goto.z
=$d4					PCD_CMD_GOTOCMD_NZ   = $d4 ; .goto.nz
=$d5					PCD_CMD_VARSPACE     = $d5 ; .varspace
=$d6					PCD_CMD_RESTORE      = $d6 ; .restore
=$cb80					PCD_CLR              = $cb80 ; clr
=$cb81					PCD_DIM              = $cb81 ; dim
=$cb82					PCD_END              = $cb82 ; end
=$cb83					PCD_JOY              = $cb83 ; joy
=$cb84					PCD_INT              = $cb84 ; int
=$cb85					PCD_SQR              = $cb85 ; sqr
=$cb86					PCD_LOG              = $cb86 ; log
=$cb87					PCD_EXP              = $cb87 ; exp
=$cb88					PCD_COS              = $cb88 ; cos
=$cb89					PCD_SIN              = $cb89 ; sin
=$cb8a					PCD_TAN              = $cb8a ; tan
=$cb8b					PCD_ATN              = $cb8b ; atn
=$cb8c					PCD_MOUSE            = $cb8c ; mouse
=$cb8d					PCD_MB               = $cb8d ; mb
=$cb8e					PCD_MX               = $cb8e ; mx
=$cb8f					PCD_MY               = $cb8f ; my
=$cb90					PCD_MWHEEL           = $cb90 ; mwheel
=$cb91					PCD_STOP             = $cb91 ; stop
=$cb92					PCD_SYS              = $cb92 ; sys
=$cb93					PCD_TIDOLLARCMD_WRITE = $cb93 ; ti$.write
=$cb94					PCD_WAIT             = $cb94 ; wait
=$cb95					PCD_I2CPOKE          = $cb95 ; i2cpoke
=$cb96					PCD_I2CPEEK          = $cb96 ; i2cpeek
=$cb97					PCD_BANK             = $cb97 ; bank
=$cb98					PCD_SLEEP            = $cb98 ; sleep
=$cb99					PCD_FMINIT           = $cb99 ; fminit
=$cb9a					PCD_FMNOTE           = $cb9a ; fmnote
=$cb9b					PCD_FMDRUM           = $cb9b ; fmdrum
=$cb9c					PCD_FMINST           = $cb9c ; fminst
=$cb9d					PCD_FMVIB            = $cb9d ; fmvib
=$cb9e					PCD_FMFREQ           = $cb9e ; fmfreq
=$cb9f					PCD_FMVOL            = $cb9f ; fmvol
=$cba0					PCD_FMPAN            = $cba0 ; fmpan
=$cba1					PCD_FMPLAY           = $cba1 ; fmplay
=$cba2					PCD_FMCHORD          = $cba2 ; fmchord
=$cba3					PCD_FMPOKE           = $cba3 ; fmpoke
=$cba4					PCD_PSGINIT          = $cba4 ; psginit
=$cba5					PCD_PSGNOTE          = $cba5 ; psgnote
=$cba6					PCD_PSGVOL           = $cba6 ; psgvol
=$cba7					PCD_PSGWAV           = $cba7 ; psgwav
=$cba8					PCD_PSGFREQ          = $cba8 ; psgfreq
=$cba9					PCD_PSGPAN           = $cba9 ; psgpan
=$cbaa					PCD_PSGPLAY          = $cbaa ; psgplay
=$cbab					PCD_PSGCHORD         = $cbab ; psgchord
=$cbac					PCD_CLS              = $cbac ; cls
=$cbad					PCD_LOCATE           = $cbad ; locate
=$cbae					PCD_COLOR            = $cbae ; color
.1f26					SetErrorHandler:
.1f26	8c 70 05	sty $0570			sty 	ErrorHandlerVector+1
.1f29	8e 6f 05	stx $056f			stx 	ErrorHandlerVector
.1f2c	60		rts				rts
.1f2d					CallErrorHandler:
.1f2d	6c 6f 05	jmp ($056f)			jmp 	(ErrorHandlerVector)
.056f					ErrorHandlerVector:
>056f							.fill 	2
.1f30					ErrorV_range:
.1f30	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>1f33	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f3b	41 4e 47 45 00
.1f40					ErrorV_value:
.1f40	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>1f43	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f4b	45 00
.1f4d					ErrorV_syntax:
.1f4d	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>1f50	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f58	52 52 4f 52 00
.1f5d					ErrorV_type:
.1f5d	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>1f60	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f68	4d 41 54 43 48 00
.1f6e					ErrorV_unimplemented:
.1f6e	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>1f71	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f79	45 4d 45 4e 54 45 44 00
.1f81					ErrorV_assert:
.1f81	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>1f84	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f8c	41 49 4c 00
.1f90					ErrorV_line:
.1f90	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>1f93	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f9b	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1fa7					ErrorV_internal:
.1fa7	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>1faa	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1fb2	20 45 52 52 4f 52 00
.1fb9					ErrorV_divzero:
.1fb9	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>1fbc	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fc4	59 20 5a 45 52 4f 00
.1fcb					ErrorV_structure:
.1fcb	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>1fce	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fd6	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fe2					ErrorV_stop:
.1fe2	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>1fe5	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fed	53 54 4f 50 50 45 44 00
.1ff5					ErrorV_data:
.1ff5	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>1ff8	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>2000	41 54 41 00
.2004					ErrorV_undeclared:
.2004	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>2007	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>200f	41 52 52 41 59 00
.2015					ErrorV_redefine:
.2015	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>2018	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>2020	44 45 46 49 4e 45 44 00
.2028					ErrorV_index:
.2028	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>202b	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2033	59 20 49 4e 44 45 58 00
.203b					ErrorV_memory:
.203b	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>203e	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2046	45 4d 4f 52 59 00
.204c					ErrorV_channel:
.204c	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>204f	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2057	54 50 55 54 20 45 52 52 4f 52 00
.2062					ErrorV_break:
.2062	20 2d 1f	jsr $1f2d		jsr	CallErrorHandler
>2065	42 52 45 41 4b 20 50 52			.text	"BREAK PRESSED",0
>206d	45 53 53 45 44 00
.2073					MoveObjectForward:
.2073	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.2075	c9 ff		cmp #$ff			cmp 	#$FF
.2077	f0 36		beq $20af			beq 	_MOFEnd
.2079	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.207b	90 24		bcc $20a1			bcc 	_MOFAdvance1 				; forward 1
.207d	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.207f	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2081	90 20		bcc $20a3			bcc 	_MOFAdvanceY
.2083	c9 cb		cmp #$cb			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2085	90 1a		bcc $20a1			bcc 	_MOFAdvance1 				; forward 1
.2087	a8		tay				tay 								; read the size.
.2088	b9 ec 1f	lda $1fec,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.208b	a8		tay				tay
.208c	c8		iny				iny 								; add 1 for the system token.
.208d	d0 14		bne $20a3			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.208f	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2091	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2093	a8		tay				tay 								; into Y.
.2094	18		clc				clc
.2095	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.2097	69 02		adc #$02			adc 	#2
.2099	85 2a		sta $2a				sta 	objPtr
.209b	90 02		bcc $209f			bcc 	_MOFNoCarry1
.209d	e6 2b		inc $2b				inc 	objPtr+1
.209f					_MOFNoCarry1:
.209f	80 02		bra $20a3			bra 	_MOFAdvanceY
.20a1					_MOFAdvance1:
.20a1	a0 01		ldy #$01			ldy 	#1
.20a3					_MOFAdvanceY:
.20a3	98		tya				tya 								; add Y to objPtr
.20a4	18		clc				clc
.20a5	65 2a		adc $2a				adc 	objPtr
.20a7	85 2a		sta $2a				sta 	objPtr
.20a9	90 02		bcc $20ad			bcc 	_MOFNoCarry2
.20ab	e6 2b		inc $2b				inc 	objPtr+1
.20ad					_MOFNoCarry2:
.20ad	18		clc				clc 								; not completed.
.20ae	60		rts				rts
.20af					_MOFEnd:
.20af	e6 2a		inc $2a				inc 	objPtr
.20b1	d0 02		bne $20b5			bne 	_MOFENoCarry
.20b3	e6 2b		inc $2b				inc 	objPtr+1
.20b5					_MOFENoCarry:
.20b5	38		sec				sec
.20b6	60		rts				rts
.20b7					MOFSizeTable:
>20b7	01					.byte	1         	; $cb .shift
>20b8	01					.byte	1         	; $cc .byte
>20b9	02					.byte	2         	; $cd .word
>20ba	05					.byte	5         	; $ce .float
>20bb	ff					.byte	255       	; $cf .string
>20bc	ff					.byte	255       	; $d0 .data
>20bd	02					.byte	2         	; $d1 .goto
>20be	02					.byte	2         	; $d2 .gosub
>20bf	02					.byte	2         	; $d3 .goto.z
>20c0	02					.byte	2         	; $d4 .goto.nz
>20c1	02					.byte	2         	; $d5 .varspace
>20c2	02					.byte	2         	; $d6 .restore

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0571					numberBuffer:
>0571							.fill 	34
.20c3					FloatSubtract:
.20c3	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.20c5	49 80		eor #$80			eor 	#$80
.20c7	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.20c9					FloatAdd:
.20c9	ca		dex				dex
.20ca	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.20cc	15 6f		ora $6f,x			ora 	NSExponent+1,x
.20ce	15 62		ora $62,x			ora 	NSMantissa3,x
.20d0	15 63		ora $63,x			ora 	NSMantissa3+1,x
.20d2	d0 04		bne $20d8			bne 	_FAUseFloat
.20d4	20 65 24	jsr $2465			jsr 	FloatInt32Add 				; use the int32 one.
.20d7	60		rts				rts
.20d8					_FAUseFloat:
.20d8	20 fa 23	jsr $23fa			jsr 	FloatNormalise 				; normalise S[X]
.20db	f0 51		beq $212e			beq 	_FAReturn1
.20dd	e8		inx				inx 								; normalise S[X+1]
.20de	20 fa 23	jsr $23fa			jsr 	FloatNormalise
.20e1	ca		dex				dex
.20e2	c9 00		cmp #$00			cmp 	#0
.20e4	f0 60		beq $2146			beq 	_FAExit 					; if so, just return A
.20e6	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20e8	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20ea	f0 18		beq $2104			beq 	_FAExponentsEqual
.20ec	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20ee	a8		tay				tay
.20ef	38		sec				sec 								; do a signed comparison of the exponents.
.20f0	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20f2	50 02		bvc $20f6			bvc 	_FANoSignedChange
.20f4	49 80		eor #$80			eor 	#$80
.20f6					_FANoSignedChange:
.20f6	29 80		and #$80			and 	#$80
.20f8	10 02		bpl $20fc			bpl 	_FAHaveMax
.20fa	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.20fc					_FAHaveMax:
.20fc	20 47 21	jsr $2147			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20ff	e8		inx				inx
.2100	20 47 21	jsr $2147			jsr 	_FAShiftToExponent
.2103	ca		dex				dex
.2104					_FAExponentsEqual:
.2104	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.2106	55 33		eor $33,x			eor 	NSStatus+1,x
.2108	30 0e		bmi $2118			bmi 	_FADifferentSigns
.210a	20 31 24	jsr $2431			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.210d	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.210f	10 35		bpl $2146			bpl 	_FAExit 					; if no, we are done.
.2111	20 be 26	jsr $26be			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.2114	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.2116	80 2e		bra $2146			bra 	_FAExit
.2118					_FADifferentSigns:
.2118	20 4b 24	jsr $244b			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.211b	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.211d	10 06		bpl $2125			bpl 	_FACheckZero 				; if no, check for -0
.211f	20 67 26	jsr $2667			jsr 	FloatNegate 					; netate result
.2122	20 6e 26	jsr $266e			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.2125					_FACheckZero:
.2125	20 c7 26	jsr $26c7			jsr 	FloatIsZero	 				; check for -0
.2128	d0 1c		bne $2146			bne 	_FAExit
.212a	74 32		stz $32,x			stz 	NSStatus,x
.212c	80 18		bra $2146			bra 	_FAExit
.212e					_FAReturn1:
.212e	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.2130	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2132	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2134	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2136	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.2138	95 56		sta $56,x			sta 	NSMantissa2,x
.213a	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.213c	95 62		sta $62,x			sta 	NSMantissa3,x
.213e	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.2140	95 6e		sta $6e,x			sta 	NSExponent,x
.2142	b5 33		lda $33,x			lda 	NSStatus+1,x
.2144	95 32		sta $32,x			sta 	NSStatus,x
.2146					_FAExit:
.2146	60		rts				rts
.2147					_FAShiftToExponent:
.2147					_FAShiftToExponent2:
.2147	98		tya				tya 								; compare Y to exponent
.2148	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.214a	f0 07		beq $2153			beq 	_FASEExit 					; exit if so.
.214c	20 be 26	jsr $26be			jsr 	FloatShiftRight	 			; shift the mantissa right
.214f	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.2151	80 f4		bra $2147			bra 	_FAShiftToExponent2
.2153					_FASEExit:
.2153	60		rts				rts
.2154					CompareEqual:
.2154	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2156	d0 09		bne $2161			bne 	ReturnFalse
.2158					ReturnTrue:
.2158	a9 01		lda #$01			lda 	#1
.215a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.215c	a9 80		lda #$80			lda 	#$80
.215e	95 32		sta $32,x			sta 	NSStatus,x
.2160	60		rts				rts
.2161					ReturnFalse:
.2161	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2163	60		rts				rts
.2164					CompareNotEqual:
.2164	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2166	d0 f0		bne $2158			bne 	ReturnTrue
.2168	80 f7		bra $2161			bra 	ReturnFalse
.216a					CompareLess:
.216a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.216c	c9 ff		cmp #$ff			cmp 	#$FF
.216e	f0 e8		beq $2158			beq 	ReturnTrue
.2170	80 ef		bra $2161			bra 	ReturnFalse
.2172					CompareGreater:
.2172	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2174	c9 01		cmp #$01			cmp 	#$01
.2176	f0 e0		beq $2158			beq 	ReturnTrue
.2178	80 e7		bra $2161			bra 	ReturnFalse
.217a					CompareLessEqual:
.217a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.217c	c9 01		cmp #$01			cmp 	#$01
.217e	d0 d8		bne $2158			bne 	ReturnTrue
.2180	80 df		bra $2161			bra 	ReturnFalse
.2182					CompareGreaterEqual:
.2182	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2184	c9 ff		cmp #$ff			cmp 	#$FF
.2186	d0 d0		bne $2158			bne 	ReturnTrue
.2188	80 d7		bra $2161			bra 	ReturnFalse
.218a					FloatCompare:
.218a	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.218c	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.218e	48		pha				pha
.218f	20 c3 20	jsr $20c3			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2192	68		pla				pla
.2193	d0 0c		bne $21a1			bne 	_FCCompareFloat
.2195	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2197	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2199	15 56		ora $56,x			ora 	NSMantissa2,x
.219b	15 62		ora $62,x			ora 	NSMantissa3,x
.219d	f0 14		beq $21b3			beq 	_FCExit 					; if zero, return zero
.219f	80 0a		bra $21ab			bra 	_FCSign
.21a1					_FCCompareFloat:
.21a1	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.21a3	29 f0		and #$f0			and 	#$F0
.21a5	15 56		ora $56,x			ora 	NSMantissa2,x
.21a7	15 62		ora $62,x			ora 	NSMantissa3,x
.21a9	f0 08		beq $21b3			beq 	_FCExit 					; zero, so approximately identical
.21ab					_FCSign:
.21ab	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.21ad	34 32		bit $32,x			bit 	NSStatus,x
.21af	10 02		bpl $21b3			bpl 	_FCExit
.21b1					_FCNegative:
.21b1	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.21b3					_FCExit:
.21b3	20 a7 26	jsr $26a7			jsr 	FloatSetByte 				; set the result 255,0,1
.21b6	60		rts				rts
.21b7					FloatScalarTable:
>21b7	66 66 66 66				.dword $66666666 ; 0.1
>21bb	de					.byte $de
>21bc	1f 85 eb 51				.dword $51eb851f ; 0.01
>21c0	db					.byte $db
>21c1	4c 37 89 41				.dword $4189374c ; 0.001
>21c5	d8					.byte $d8
>21c6	ac 8b db 68				.dword $68db8bac ; 0.0001
>21ca	d4					.byte $d4
>21cb	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>21cf	d1					.byte $d1
>21d0	83 de 1b 43				.dword $431bde83 ; 1e-06
>21d4	ce					.byte $ce
>21d5	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21d9	ca					.byte $ca
>21da	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21de	c7					.byte $c7
>21df	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21e3	c4					.byte $c4
>21e4	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21e8	c0					.byte $c0
>21e9	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21ed	bd					.byte $bd
.21ee					FloatDivide:
.21ee	48		pha				pha
.21ef	20 fa 23	jsr $23fa			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21f2	ca		dex				dex
.21f3	c9 00		cmp #$00			cmp 	#0
.21f5	f0 1e		beq $2215			beq 	_FDZero
.21f7	20 fa 23	jsr $23fa			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21fa	f0 16		beq $2212			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21fc	20 5d 22	jsr $225d			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21ff	20 2a 22	jsr $222a			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.2202	20 fa 23	jsr $23fa			jsr		FloatNormalise 				; renormalise
.2205	20 f0 23	jsr $23f0			jsr 	FloatCalculateSign 			; calculate result sign
.2208	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.220a	38		sec				sec
.220b	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.220d	38		sec				sec
.220e	e9 1e		sbc #$1e			sbc 	#30
.2210	95 6e		sta $6e,x			sta 	NSExponent,x
.2212					_FDExit:
.2212	68		pla				pla
.2213	18		clc				clc
.2214	60		rts				rts
.2215					_FDZero:
.2215	68		pla				pla
.2216	38		sec				sec
.2217	60		rts				rts
.2218					DivideInt32:
.2218	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart 			; make both integers
.221b	ca		dex				dex
.221c	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.221f	20 3b 22	jsr $223b			jsr 	Int32Divide 				; divide
.2222	20 2a 22	jsr $222a			jsr 	NSMCopyPlusTwoToZero 		; copy result
.2225	20 f0 23	jsr $23f0			jsr 	FloatCalculateSign 			; calculate result sign
.2228	18		clc				clc
.2229	60		rts				rts
.222a					NSMCopyPlusTwoToZero:
.222a	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.222c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.222e	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.2230	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2232	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.2234	95 56		sta $56,x			sta 	NSMantissa2,x
.2236	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.2238	95 62		sta $62,x			sta 	NSMantissa3,x
.223a	60		rts				rts
.223b					Int32Divide:
.223b	48		pha				pha 								; save AXY
.223c	5a		phy				phy
.223d	20 88 26	jsr $2688			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2240	20 a1 26	jsr $26a1			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2243	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2245					_I32DivideLoop:
.2245	e8		inx				inx
.2246	e8		inx				inx
.2247	20 b4 26	jsr $26b4			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.224a	ca		dex				dex
.224b	ca		dex				dex
.224c	20 b5 26	jsr $26b5			jsr 	FloatRotateLeft
.224f	20 7b 22	jsr $227b			jsr 	FloatDivideCheck 			; check if subtract possible
.2252	90 02		bcc $2256			bcc 	_I32DivideNoCarryIn
.2254	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2256					_I32DivideNoCarryIn:
.2256	88		dey				dey 								; loop round till division completed.
.2257	d0 ec		bne $2245			bne 	_I32DivideLoop
.2259	7a		ply				ply 								; restore AXY and exit
.225a	68		pla				pla
.225b	18		clc				clc
.225c	60		rts				rts
.225d					Int32ShiftDivide:
.225d	48		pha				pha 								; save AY
.225e	5a		phy				phy
.225f	e8		inx				inx 								; clear S[X+2]
.2260	e8		inx				inx
.2261	20 a5 26	jsr $26a5			jsr 	FloatSetZero
.2264	ca		dex				dex
.2265	ca		dex				dex
.2266	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2268					_I32SDLoop:
.2268	20 7b 22	jsr $227b			jsr 	FloatDivideCheck 			; check if subtract possible
.226b	e8		inx				inx
.226c	e8		inx				inx
.226d	20 b5 26	jsr $26b5			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.2270	ca		dex				dex
.2271	ca		dex				dex
.2272	20 b5 26	jsr $26b5			jsr 	FloatRotateLeft
.2275	88		dey				dey 	 							; do 31 times
.2276	d0 f0		bne $2268			bne 	_I32SDLoop
.2278	7a		ply				ply 								; restore AY and exit
.2279	68		pla				pla
.227a	60		rts				rts
.227b					FloatDivideCheck:
.227b	20 4b 24	jsr $244b			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.227e	b0 04		bcs $2284			bcs 	_DCSExit 					; if carry set, then could do, exit
.2280	20 31 24	jsr $2431			jsr 	FloatAddTopTwoStack 		; add it back in
.2283	18		clc				clc 								; and return False
.2284					_DCSExit:
.2284	60		rts				rts
.2285					FloatFractionalPart:
.2285	5a		phy				phy
.2286	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.2288	29 7f		and #$7f			and 	#$7F
.228a	95 32		sta $32,x			sta 	NSStatus,x
.228c	20 fa 23	jsr $23fa			jsr 	FloatNormalise
.228f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2291	38		sec				sec
.2292	e9 e0		sbc #$e0			sbc 	#$E0
.2294	90 29		bcc $22bf			bcc 	_FFPExit 					; already fractional
.2296	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2298	b0 22		bcs $22bc			bcs 	_FFPZero
.229a	a8		tay				tay 								; put count to do in Y
.229b	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.229d	20 c4 22	jsr $22c4			jsr 	_FFPPartial
.22a0	95 62		sta $62,x			sta 	NSMantissa3,x
.22a2	b5 56		lda $56,x			lda 	NSMantissa2,x
.22a4	20 c4 22	jsr $22c4			jsr 	_FFPPartial
.22a7	95 56		sta $56,x			sta 	NSMantissa2,x
.22a9	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.22ab	20 c4 22	jsr $22c4			jsr 	_FFPPartial
.22ae	95 4a		sta $4a,x			sta 	NSMantissa1,x
.22b0	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.22b2	20 c4 22	jsr $22c4			jsr 	_FFPPartial
.22b5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.22b7	20 c7 26	jsr $26c7			jsr 	FloatIsZero 					; zeroed check.
.22ba	d0 03		bne $22bf			bne 	_FFPExit
.22bc					_FFPZero:
.22bc	20 a5 26	jsr $26a5			jsr 	FloatSetZero
.22bf					_FFPExit:
.22bf	20 fa 23	jsr $23fa			jsr 	FloatNormalise
.22c2	7a		ply				ply
.22c3	60		rts				rts
.22c4					_FFPPartial:
.22c4	c0 00		cpy #$00			cpy 	#0 							; no more to do
.22c6	f0 17		beq $22df			beq 	_FFFPPExit
.22c8	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.22ca	b0 0c		bcs $22d8			bcs 	_FFFPPWholeByte
.22cc	5a		phy				phy
.22cd					_FFFPPLeft:
.22cd	0a		asl a				asl 	a
.22ce	88		dey				dey
.22cf	d0 fc		bne $22cd			bne 	_FFFPPLeft
.22d1	7a		ply				ply
.22d2					_FFFPPRight:
.22d2	4a		lsr a				lsr 	a
.22d3	88		dey				dey
.22d4	d0 fc		bne $22d2			bne 	_FFFPPRight
.22d6	80 07		bra $22df			bra 	_FFFPPExit
.22d8					_FFFPPWholeByte:
.22d8	98		tya				tya 								; subtract 8 from count
.22d9	38		sec				sec
.22da	e9 08		sbc #$08			sbc 	#8
.22dc	a8		tay				tay
.22dd	a9 00		lda #$00			lda 	#0 							; and clear all
.22df					_FFFPPExit:
.22df	60		rts				rts
.22e0					FloatIntegerPart:
.22e0	48		pha				pha
.22e1	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22e3	f0 1d		beq $2302			beq 	_FIPExit 					; if so do nothing
.22e5	20 c7 26	jsr $26c7			jsr 	FloatIsZero 				; is it zero ?
.22e8	f0 15		beq $22ff			beq 	_FIPZero 					; if so return zero.
.22ea	20 fa 23	jsr $23fa			jsr 	FloatNormalise 				; normalise
.22ed	f0 10		beq $22ff			beq 	_FIPZero 					; normalised to zero, exit zero
.22ef					_FIPShift:
.22ef	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22f1	10 07		bpl $22fa			bpl 	_FIPCheckZero
.22f3	20 be 26	jsr $26be			jsr 	FloatShiftRight 			; shift mantissa right
.22f6	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22f8	80 f5		bra $22ef			bra 	_FIPShift
.22fa					_FIPCheckZero:
.22fa	20 c7 26	jsr $26c7			jsr 	FloatIsZero 				; avoid -0 problem
.22fd	d0 03		bne $2302			bne 	_FIPExit 					; set to zero if mantissa zero.
.22ff					_FIPZero:
.22ff	20 a5 26	jsr $26a5			jsr 	FloatSetZero
.2302					_FIPExit:
.2302	68		pla				pla
.2303	60		rts				rts
.2304					FloatIntegerPartDown:
.2304	48		pha				pha
.2305	5a		phy				phy
.2306	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.2308	f0 36		beq $2340			beq 	_FIPExit 					; if so do nothing
.230a	20 c7 26	jsr $26c7			jsr 	FloatIsZero 				; is it zero ?
.230d	f0 2e		beq $233d			beq 	_FIPZero 					; if so return zero.
.230f	20 fa 23	jsr $23fa			jsr 	FloatNormalise 				; normalise
.2312	f0 29		beq $233d			beq 	_FIPZero 					; normalised to zero, exit zero
.2314	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.2316					_FIPShift:
.2316	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2318	10 0a		bpl $2324			bpl 	_FIPCheckDown
.231a	20 be 26	jsr $26be			jsr 	FloatShiftRight 			; shift mantissa right
.231d	90 01		bcc $2320			bcc 	_FIPNoFrac 					; shifted a zero out ?
.231f	c8		iny				iny
.2320					_FIPNoFrac:
.2320	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.2322	80 f2		bra $2316			bra 	_FIPShift
.2324					_FIPCheckDown:
.2324	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.2326	f0 10		beq $2338			beq 	_FIPCheckZero
.2328	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.232a	10 0c		bpl $2338			bpl 	_FIPCheckZero
.232c	e8		inx				inx 								; -ve so round *down*.
.232d	a9 01		lda #$01			lda 	#1
.232f	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.2332	20 67 26	jsr $2667			jsr 	FloatNegate
.2335	20 c9 20	jsr $20c9			jsr 	FloatAdd
.2338					_FIPCheckZero:
.2338	20 c7 26	jsr $26c7			jsr 	FloatIsZero 				; avoid -0 problem
.233b	d0 03		bne $2340			bne 	_FIPExit 					; set to zero if mantissa zero.
.233d					_FIPZero:
.233d	20 a5 26	jsr $26a5			jsr 	FloatSetZero
.2340					_FIPExit:
.2340	7a		ply				ply
.2341	68		pla				pla
.2342	60		rts				rts
.2343					FloatInt8Multiply:
.2343	5a		phy				phy
.2344	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2346	a8		tay				tay
.2347	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2349					_FI8MLoop:
.2349	98		tya				tya 								; shift right shifter right into carry
.234a	4a		lsr a				lsr 	a
.234b	a8		tay				tay
.234c	90 0d		bcc $235b			bcc 	_FI8MNoAdd
.234e	18		clc				clc
.234f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2351	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.2353	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2355	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2357	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.2359	95 4a		sta $4a,x			sta 	NSMantissa1,x
.235b					_FI8MNoAdd:
.235b	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.235d	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.235f	c0 00		cpy #$00			cpy 	#0
.2361	d0 e6		bne $2349			bne 	_FI8MLoop 					; until right shifter zero.
.2363	7a		ply				ply
.2364	60		rts				rts
.2365					FloatMultiply:
.2365	ca		dex				dex
.2366	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.2368	15 6f		ora $6f,x			ora 	NSExponent+1,x
.236a	15 62		ora $62,x			ora 	NSMantissa3,x
.236c	15 63		ora $63,x			ora 	NSMantissa3+1,x
.236e	d0 21		bne $2391			bne 	_FMUseFloat
.2370	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2372	15 33		ora $33,x			ora 	NSStatus+1,x
.2374	29 80		and #$80			and 	#$80
.2376	15 62		ora $62,x			ora 	NSMantissa3,x
.2378	15 56		ora $56,x			ora 	NSMantissa2,x
.237a	15 4a		ora $4a,x			ora 	NSMantissa1,x
.237c	15 63		ora $63,x			ora 	NSMantissa3+1,x
.237e	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2380	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2382	d0 04		bne $2388			bne 	_FMInt32
.2384	20 43 23	jsr $2343			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2387	60		rts				rts
.2388					_FMInt32:
.2388	20 b2 23	jsr $23b2			jsr 	FloatMultiplyShort			; use the int32 one.
.238b	18		clc				clc 								; fix it up if gone out of range
.238c	75 6e		adc $6e,x			adc 	NSExponent,x
.238e	95 6e		sta $6e,x			sta 	NSExponent,x
.2390	60		rts				rts
.2391					_FMUseFloat:
.2391	20 fa 23	jsr $23fa			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2394	f0 18		beq $23ae			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2396	e8		inx				inx
.2397	20 fa 23	jsr $23fa			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.239a	ca		dex				dex
.239b	c9 00		cmp #$00			cmp 	#0
.239d	f0 0c		beq $23ab			beq 	_FDSetZero
.239f	20 b2 23	jsr $23b2			jsr 	FloatMultiplyShort 			; calculate the result.
.23a2	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.23a4	18		clc				clc
.23a5	75 6f		adc $6f,x			adc 	NSExponent+1,x
.23a7	95 6e		sta $6e,x			sta 	NSExponent,x
.23a9	80 03		bra $23ae			bra 	_FDExit
.23ab					_FDSetZero:
.23ab	20 a5 26	jsr $26a5			jsr 	FloatSetZero 				; return 0
.23ae					_FDExit:
.23ae	20 fa 23	jsr $23fa			jsr 	FloatNormalise 				; normalise the result
.23b1	60		rts				rts
.23b2					FloatMultiplyShort:
.23b2	5a		phy				phy 								; save Y
.23b3	20 88 26	jsr $2688			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.23b6	20 a1 26	jsr $26a1			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.23b9	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.23bb					_I32MLoop:
.23bb	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.23bd	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.23bf	15 58		ora $58,x			ora 	NSMantissa2+2,x
.23c1	15 64		ora $64,x			ora 	NSMantissa3+2,x
.23c3	f0 25		beq $23ea			beq 	_I32MExit 					; exit if zero
.23c5	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.23c7	29 01		and #$01			and 	#1
.23c9	f0 0d		beq $23d8			beq 	_I32MNoAdd
.23cb	20 31 24	jsr $2431			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.23ce	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.23d0	10 06		bpl $23d8			bpl 	_I32MNoAdd
.23d2					_I32ShiftRight:
.23d2	20 be 26	jsr $26be			jsr 	FloatShiftRight 			; shift S[X] right
.23d5	c8		iny				iny 								; increment shift count
.23d6	80 09		bra $23e1			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23d8					_I32MNoAdd:
.23d8	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23da	70 f6		bvs $23d2			bvs 	_I32ShiftRight 				; instead.
.23dc	e8		inx				inx
.23dd	20 b4 26	jsr $26b4			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23e0	ca		dex				dex
.23e1					_I32MShiftUpper:
.23e1	e8		inx				inx 								; shift S[X+2] right
.23e2	e8		inx				inx
.23e3	20 be 26	jsr $26be			jsr 	FloatShiftRight
.23e6	ca		dex				dex
.23e7	ca		dex				dex
.23e8	80 d1		bra $23bb			bra 	_I32MLoop 					; try again.
.23ea					_I32MExit:
.23ea	20 f0 23	jsr $23f0			jsr 	FloatCalculateSign
.23ed	98		tya				tya 								; shift in A
.23ee	7a		ply				ply 								; restore Y and exit
.23ef	60		rts				rts
.23f0					FloatCalculateSign:
.23f0	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23f2	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23f4	55 33		eor $33,x			eor 	NSStatus+1,x
.23f6	0a		asl a				asl 	a 							; shift bit 7 into carry
.23f7	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23f9	60		rts				rts
.23fa					FloatNormalise:
.23fa	20 c7 26	jsr $26c7			jsr 	FloatIsZero 				; if zero exit
.23fd	d0 07		bne $2406			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23ff	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.2401	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.2403	a9 00		lda #$00			lda 	#0 							; set Z flag
.2405	60		rts				rts
.2406					_NSNormaliseOptimise:
.2406	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.2408	d0 19		bne $2423			bne 	_NSNormaliseLoop
.240a	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.240c	30 15		bmi $2423			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.240e	95 62		sta $62,x			sta 	NSMantissa3,x
.2410	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2412	95 56		sta $56,x			sta 	NSMantissa2,x
.2414	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2416	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2418	74 3e		stz $3e,x			stz 	NSMantissa0,x
.241a	b5 6e		lda $6e,x			lda 	NSExponent,x
.241c	38		sec				sec
.241d	e9 08		sbc #$08			sbc 	#8
.241f	95 6e		sta $6e,x			sta 	NSExponent,x
.2421	80 e3		bra $2406			bra 	_NSNormaliseOptimise
.2423					_NSNormaliseLoop:
.2423	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.2425	70 07		bvs $242e			bvs 	_NSNExit 					; exit if so with Z flag clear
.2427	20 b4 26	jsr $26b4			jsr 	FloatShiftLeft 				; shift mantissa left
.242a	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.242c	80 f5		bra $2423			bra 	_NSNormaliseLoop
.242e					_NSNExit:
.242e	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.2430	60		rts				rts
.2431					FloatAddTopTwoStack:
.2431	18		clc				clc
.2432	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2434	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.2436	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2438	b5 4a		lda $4a,x			lda		NSMantissa1,x
.243a	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.243c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.243e	b5 56		lda $56,x			lda		NSMantissa2,x
.2440	75 57		adc $57,x			adc 		NSMantissa2+1,x
.2442	95 56		sta $56,x			sta 	NSMantissa2,x
.2444	b5 62		lda $62,x			lda		NSMantissa3,x
.2446	75 63		adc $63,x			adc 		NSMantissa3+1,x
.2448	95 62		sta $62,x			sta 	NSMantissa3,x
.244a	60		rts				rts
.244b					FloatSubTopTwoStack:
.244b	38		sec				sec
.244c	b5 3e		lda $3e,x			lda		NSMantissa0,x
.244e	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.2450	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2452	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2454	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.2456	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2458	b5 56		lda $56,x			lda		NSMantissa2,x
.245a	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.245c	95 56		sta $56,x			sta 	NSMantissa2,x
.245e	b5 62		lda $62,x			lda		NSMantissa3,x
.2460	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.2462	95 62		sta $62,x			sta 	NSMantissa3,x
.2464	60		rts				rts
.2465					FloatInt32Add:
.2465	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2467	55 33		eor $33,x			eor 	NSStatus+1,x
.2469	30 04		bmi $246f			bmi 	_DiffSigns
.246b	20 31 24	jsr $2431			jsr		FloatAddTopTwoStack
.246e	60		rts				rts
.246f					_DiffSigns:
.246f	20 4b 24	jsr $244b			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2472	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2474	10 07		bpl $247d			bpl 	_AddExit
.2476	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2478	95 32		sta $32,x			sta 	NSStatus,x
.247a	20 6e 26	jsr $266e			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.247d					_AddExit:
.247d	20 c7 26	jsr $26c7			jsr 	FloatIsZero 				; check for -0
.2480	d0 02		bne $2484			bne 	_AddNonZero
.2482	74 32		stz $32,x			stz 	NSStatus,x
.2484					_AddNonZero:
.2484	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2485					FloatEncodeStart:
.2485	38		sec				sec
.2486	80 01		bra $2489			bra 	FloatEncodeContinue+1
.2488					FloatEncodeContinue:
.2488	18		clc				clc
.2489					FloatEncode:
.2489	08		php				php 								; save reset flag.
.248a	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.248c	f0 15		beq $24a3			beq 	_ENIsOkay
.248e	c9 30		cmp #$30			cmp 	#"0"
.2490	90 04		bcc $2496			bcc 	_ENBadNumber
.2492	c9 3a		cmp #$3a			cmp 	#"9"+1
.2494	90 0d		bcc $24a3			bcc 	_ENIsOkay
.2496					_ENBadNumber:
.2496	28		plp				plp 								; throw saved reset
.2497	ad 93 05	lda $0593			lda 	encodeState 				; if in decimal mode, construct final number
.249a	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.249c	d0 03		bne $24a1			bne 	_ENFail
.249e	4c 1b 25	jmp $251b			jmp 	_ENConstructFinal
.24a1					_ENFail:
.24a1	18		clc				clc 								; not allowed
.24a2	60		rts				rts
.24a3					_ENIsOkay:
.24a3	28		plp				plp 								; are we restarting
.24a4	90 15		bcc $24bb			bcc 	_ENNoRestart
.24a6					_ENStartEncode:
.24a6	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.24a8	f0 0c		beq $24b6			beq 	_ENFirstDP
.24aa	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.24ac	20 a7 26	jsr $26a7			jsr 	FloatSetByte 				; in single byte mode.
.24af	a9 01		lda #$01			lda 	#ESTA_Low
.24b1					_ENExitChange:
.24b1	8d 93 05	sta $0593			sta 	encodeState 				; save new state
.24b4	38		sec				sec
.24b5	60		rts				rts
.24b6					_ENFirstDP:
.24b6	20 a5 26	jsr $26a5			jsr 	FloatSetZero 				; clear integer part
.24b9	80 3c		bra $24f7			bra 	_ESTASwitchFloat			; go straight to float and exi
.24bb					_ENNoRestart:
.24bb	48		pha				pha 								; save digit or DP on stack.
.24bc	ad 93 05	lda $0593			lda 	encodeState 				; get current state
.24bf	c9 01		cmp #$01			cmp 	#ESTA_Low
.24c1	f0 09		beq $24cc			beq  	_ESTALowState
.24c3	c9 02		cmp #$02			cmp 	#ESTA_High
.24c5	f0 26		beq $24ed			beq 	_ESTAHighState
.24c7	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.24c9	f0 38		beq $2503			beq 	_ESTADecimalState
>24cb	db						.byte 	$DB 						; causes a break in the emulator
.24cc					_ESTALowState:
.24cc	68		pla				pla 								; get value back
.24cd	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.24cf	f0 26		beq $24f7			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24d1	29 0f		and #$0f			and 	#15 						; make digit
.24d3	8d 94 05	sta $0594			sta 	digitTemp 					; save it.
.24d6	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24d8	0a		asl a				asl 	a
.24d9	0a		asl a				asl 	a
.24da	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24dc	0a		asl a				asl 	a
.24dd	6d 94 05	adc $0594			adc 	digitTemp
.24e0	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24e2	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24e4	90 05		bcc $24eb			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24e6	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24e8	8d 93 05	sta $0593			sta 	encodeState
.24eb					_ESTANoSwitch:
.24eb	38		sec				sec
.24ec	60		rts				rts
.24ed					_ESTAHighState:
.24ed	68		pla				pla 								; get value back
.24ee	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24f0	f0 05		beq $24f7			beq 	_ESTASwitchFloat
.24f2	20 4d 25	jsr $254d			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24f5	38		sec				sec
.24f6	60		rts				rts
.24f7					_ESTASwitchFloat:
.24f7	9c 95 05	stz $0595			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24fa	e8		inx				inx 								; zero the decimal additive.
.24fb	20 a5 26	jsr $26a5			jsr 	FloatSetZero
.24fe	ca		dex				dex
.24ff	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.2501	80 ae		bra $24b1			bra 	_ENExitChange
.2503					_ESTADecimalState:
.2503	68		pla				pla 								; digit.
.2504	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.2506	f0 99		beq $24a1			beq 	_ENFail
.2508	e8		inx				inx 								; put digit into fractional part of X+1
.2509	20 4d 25	jsr $254d			jsr 	ESTAShiftDigitIntoMantissa
.250c	ca		dex				dex
.250d	ee 95 05	inc $0595			inc 	decimalCount 				; bump the count of decimals
.2510	ad 95 05	lda $0595			lda 	decimalCount 				; too many decimal digits.
.2513	c9 0b		cmp #$0b			cmp 	#11
.2515	f0 02		beq $2519			beq 	_ESTADSFail
.2517	38		sec				sec
.2518	60		rts				rts
.2519					_ESTADSFail:
.2519	18		clc				clc
.251a	60		rts				rts
.251b					_ENConstructFinal:
.251b	ad 95 05	lda $0595			lda 	decimalCount 				; get decimal count
.251e	f0 2b		beq $254b			beq 	_ENCFExit 					; no decimals
.2520	5a		phy				phy
.2521	0a		asl a				asl 	a 							; x 4 and CLC
.2522	0a		asl a				asl 	a
.2523	6d 95 05	adc $0595			adc 	decimalCount
.2526	a8		tay				tay
.2527	b9 b2 21	lda $21b2,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.252a	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.252c	b9 b3 21	lda $21b3,y			lda 	FloatScalarTable-5+1,y
.252f	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2531	b9 b4 21	lda $21b4,y			lda 	FloatScalarTable-5+2,y
.2534	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2536	b9 b5 21	lda $21b5,y			lda 	FloatScalarTable-5+3,y
.2539	95 64		sta $64,x			sta 	NSMantissa3+2,x
.253b	b9 b6 21	lda $21b6,y			lda 	FloatScalarTable-5+4,y
.253e	95 70		sta $70,x			sta 	NSExponent+2,x
.2540	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.2542	e8		inx				inx 								; multiply decimal const by decimal scalar
.2543	e8		inx				inx
.2544	20 65 23	jsr $2365			jsr 	FloatMultiply
.2547	20 c9 20	jsr $20c9			jsr 	FloatAdd 					; add to integer part.
.254a	7a		ply				ply
.254b					_ENCFExit:
.254b	18		clc				clc 								; reject the digit.
.254c	60		rts				rts
.254d					ESTAShiftDigitIntoMantissa:
.254d	29 0f		and #$0f			and 	#15 						; save digit
.254f	48		pha				pha
.2550	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2552	48		pha				pha
.2553	b5 56		lda $56,x			lda 	NSMantissa2,x
.2555	48		pha				pha
.2556	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2558	48		pha				pha
.2559	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.255b	48		pha				pha
.255c	20 b4 26	jsr $26b4			jsr 	FloatShiftLeft 				; x 2
.255f	20 b4 26	jsr $26b4			jsr 	FloatShiftLeft 				; x 4
.2562	18		clc				clc 								; pop mantissa and add
.2563	68		pla				pla
.2564	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2566	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2568	68		pla				pla
.2569	75 4a		adc $4a,x			adc 	NSMantissa1,x
.256b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.256d	68		pla				pla
.256e	75 56		adc $56,x			adc 	NSMantissa2,x
.2570	95 56		sta $56,x			sta 	NSMantissa2,x
.2572	68		pla				pla
.2573	75 62		adc $62,x			adc 	NSMantissa3,x
.2575	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.2577	20 b4 26	jsr $26b4			jsr 	FloatShiftLeft 				; x 10
.257a	68		pla				pla 								; add digit
.257b	18		clc				clc
.257c	75 3e		adc $3e,x			adc 	NSMantissa0,x
.257e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2580	90 0a		bcc $258c			bcc 	_ESTASDExit
.2582	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2584	d0 06		bne $258c			bne 	_ESTASDExit
.2586	f6 56		inc $56,x			inc 	NSMantissa2,x
.2588	d0 02		bne $258c			bne 	_ESTASDExit
.258a	f6 62		inc $62,x			inc 	NSMantissa3,x
.258c					_ESTASDExit:
.258c	60		rts				rts
.0593					encodeState:
>0593							.fill 	1
.0594					digitTemp:
>0594							.fill 	1
.0595					decimalCount:
>0595							.fill 	1
.258d					FloatToString:
.258d	da		phx				phx
.258e	5a		phy				phy 								; save code position
.258f	8d 96 05	sta $0596			sta 	decimalPlaces	 			; save number of DPs.
.2592	9c 97 05	stz $0597			stz 	dbOffset 					; offset into decimal buffer = start.
.2595	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.2597	10 08		bpl $25a1			bpl 	_CNTSNotNegative
.2599	29 7f		and #$7f			and 	#$7F 						; make +ve
.259b	95 32		sta $32,x			sta 	NSStatus,x
.259d	a9 2d		lda #$2d			lda 	#"-"
.259f	80 02		bra $25a3			bra 	_CNTMain
.25a1					_CNTSNotNegative:
.25a1	a9 20		lda #$20			lda 	#" "
.25a3					_CNTMain:
.25a3	20 05 26	jsr $2605			jsr 	WriteDecimalBuffer
.25a6	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.25a8	f0 0d		beq $25b7			beq 	_CNTSNotFloat
.25aa	e8		inx				inx 								; round up so we don't get too many 6.999999
.25ab	a9 01		lda #$01			lda 	#1
.25ad	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.25b0	b5 6d		lda $6d,x			lda		NSExponent-1,x
.25b2	95 6e		sta $6e,x			sta 	NSExponent,x
.25b4	20 c9 20	jsr $20c9			jsr 	FloatAdd
.25b7					_CNTSNotFloat:
.25b7	20 e7 25	jsr $25e7			jsr 	MakePlusTwoString 			; do the integer part.
.25ba	20 85 22	jsr $2285			jsr 	FloatFractionalPart 		; get the fractional part
.25bd	20 fa 23	jsr $23fa			jsr 	FloatNormalise					; normalise , exit if zero
.25c0	f0 22		beq $25e4			beq 	_CNTSExit
.25c2	a9 2e		lda #$2e			lda 	#"."
.25c4	20 05 26	jsr $2605			jsr 	WriteDecimalBuffer 			; write decimal place
.25c7					_CNTSDecimal:
.25c7	ce 96 05	dec $0596			dec 	decimalPlaces 				; done all the decimals
.25ca	30 18		bmi $25e4			bmi 	_CNTSExit
.25cc	e8		inx				inx 								; x 10.0
.25cd	a9 0a		lda #$0a			lda 	#10
.25cf	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.25d2	20 65 23	jsr $2365			jsr 	FloatMultiply
.25d5	20 e7 25	jsr $25e7			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25d8	20 85 22	jsr $2285			jsr 	FloatFractionalPart 		; get the fractional part
.25db	20 fa 23	jsr $23fa			jsr 	FloatNormalise 				; normalise it.
.25de	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25e0	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25e2	b0 e3		bcs $25c7			bcs 	_CNTSDecimal 				; keep going.
.25e4					_CNTSExit:
.25e4	7a		ply				ply
.25e5	fa		plx				plx
.25e6	60		rts				rts
.25e7					MakePlusTwoString:
.25e7	da		phx				phx
.25e8	20 88 26	jsr $2688			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25eb	e8		inx				inx 								; access it
.25ec	e8		inx				inx
.25ed	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart 			; make it an integer
.25f0	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25f2	20 24 26	jsr $2624			jsr 	ConvertInt32
.25f5	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25f7					_MPTSCopy:
.25f7	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25fa	20 05 26	jsr $2605			jsr 	WriteDecimalBuffer
.25fd	e8		inx				inx
.25fe	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.2601	d0 f4		bne $25f7			bne 	_MPTSCopy
.2603	fa		plx				plx
.2604	60		rts				rts
.2605					WriteDecimalBuffer:
.2605	da		phx				phx
.2606	ae 97 05	ldx $0597			ldx 	dbOffset
.2609	9d 98 05	sta $0598,x			sta 	decimalBuffer,x
.260c	9e 99 05	stz $0599,x			stz 	decimalBuffer+1,x
.260f	ee 97 05	inc $0597			inc 	dbOffset
.2612	fa		plx				plx
.2613	60		rts				rts
.0596					decimalPlaces:
>0596							.fill 	1
.0597					dbOffset:
>0597							.fill 	1
.0598					decimalBuffer:
>0598							.fill 	32
.2614					ConvertInt16:
.2614	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.2616	86 4a		stx $4a				stx 	NSMantissa1
.2618	64 56		stz $56				stz 	NSMantissa2
.261a	64 62		stz $62				stz 	NSMantissa3
.261c	64 32		stz $32				stz 	NSStatus 					; positive integer
.261e	a2 00		ldx #$00			ldx 	#0 							; stack level
.2620	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.2622	80 00		bra $2624			bra 	ConvertInt32
.2624					ConvertInt32:
.2624	5a		phy				phy
.2625	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.2627	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.2629	10 08		bpl $2633			bpl 	_CI32NotNeg
.262b	48		pha				pha
.262c	a9 2d		lda #$2d			lda 	#'-'
.262e	99 71 05	sta $0571,y			sta 	numberBuffer,y
.2631	c8		iny				iny
.2632	68		pla				pla
.2633					_CI32NotNeg:
.2633	20 41 26	jsr $2641			jsr 	_CI32DivideConvert 			; recursive conversion
.2636	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2638	99 71 05	sta $0571,y			sta 	numberBuffer,y
.263b	7a		ply				ply
.263c	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.263e	a9 71		lda #$71			lda 	#numberBuffer & $FF
.2640	60		rts				rts
.2641					_CI32DivideConvert:
.2641	e8		inx				inx 								; write to next slot up
.2642	20 a7 26	jsr $26a7			jsr 	FloatSetByte 		 		; write the base out.
.2645	ca		dex				dex
.2646	20 3b 22	jsr $223b			jsr 	Int32Divide 				; divide
.2649	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.264b	48		pha				pha
.264c	20 2a 22	jsr $222a			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.264f	20 c7 26	jsr $26c7			jsr 	FloatIsZero 				; is it zero ?
.2652	f0 05		beq $2659			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2654	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2656	20 41 26	jsr $2641			jsr 	_CI32DivideConvert 			; and recusrively call.
.2659					_CI32NoRecurse:
.2659	68		pla				pla 								; remainder
.265a	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.265c	90 02		bcc $2660			bcc 	_CI32NotHex
.265e	69 26		adc #$26			adc 	#6+32
.2660					_CI32NotHex:
.2660	69 30		adc #$30			adc 	#48
.2662	99 71 05	sta $0571,y			sta 	numberBuffer,y 				; write out and exit
.2665	c8		iny				iny
.2666	60		rts				rts
.2667					FloatNegate:
.2667	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2669	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.266b	95 32		sta $32,x			sta 	NSStatus,x
.266d	60		rts				rts
.266e					FloatNegateMantissa:
.266e	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.266f	a9 00		lda #$00			lda 	#0
.2671	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2673	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2675	a9 00		lda #$00			lda 	#0
.2677	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.2679	95 4a		sta $4a,x			sta 	NSMantissa1,x
.267b	a9 00		lda #$00			lda 	#0
.267d	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.267f	95 56		sta $56,x			sta 	NSMantissa2,x
.2681	a9 00		lda #$00			lda 	#0
.2683	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2685	95 62		sta $62,x			sta 	NSMantissa3,x
.2687	60		rts				rts
.2688					FloatShiftUpTwo:
.2688	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.268a	95 40		sta $40,x			sta 	NSMantissa0+2,x
.268c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.268e	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2690	b5 56		lda $56,x			lda 	NSMantissa2,x
.2692	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2694	b5 62		lda $62,x			lda 	NSMantissa3,x
.2696	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2698	b5 6e		lda $6e,x			lda 	NSExponent,x
.269a	95 70		sta $70,x			sta 	NSExponent+2,x
.269c	b5 32		lda $32,x			lda 	NSStatus,x
.269e	95 34		sta $34,x			sta 	NSStatus+2,x
.26a0	60		rts				rts
.26a1					FloatSetZeroMantissaOnly:
.26a1	74 3e		stz $3e,x			stz 	NSMantissa0,x
.26a3	80 08		bra $26ad			bra 	FloatZero13
.26a5					FloatSetZero:
.26a5	a9 00		lda #$00			lda 	#0
.26a7					FloatSetByte:
.26a7	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.26a9					FloatSetMantissa:
.26a9	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.26ab	74 32		stz $32,x			stz 	NSStatus,x
.26ad					FloatZero13:
.26ad	74 4a		stz $4a,x			stz 	NSMantissa1,x
.26af	74 56		stz $56,x			stz 	NSMantissa2,x
.26b1	74 62		stz $62,x			stz 	NSMantissa3,x
.26b3	60		rts				rts
.26b4					FloatShiftLeft:
.26b4	18		clc				clc
.26b5					FloatRotateLeft:
.26b5	36 3e		rol $3e,x			rol 	NSMantissa0,x
.26b7	36 4a		rol $4a,x			rol		NSMantissa1,x
.26b9	36 56		rol $56,x			rol		NSMantissa2,x
.26bb	36 62		rol $62,x			rol		NSMantissa3,x
.26bd	60		rts				rts
.26be					FloatShiftRight:
.26be	56 62		lsr $62,x			lsr 	NSMantissa3,x
.26c0	76 56		ror $56,x			ror		NSMantissa2,x
.26c2	76 4a		ror $4a,x			ror		NSMantissa1,x
.26c4	76 3e		ror $3e,x			ror		NSMantissa0,x
.26c6	60		rts				rts
.26c7					FloatIsZero:
.26c7	b5 62		lda $62,x			lda 	NSMantissa3,x
.26c9	15 56		ora $56,x			ora		NSMantissa2,x
.26cb	15 4a		ora $4a,x			ora		NSMantissa1,x
.26cd	15 3e		ora $3e,x			ora		NSMantissa0,x
.26cf	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.26d0					FloatArcTan:
.26d0	20 fa 23	jsr $23fa			jsr 	FloatNormalise 					; normalise x
.26d3	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.26d5	48		pha				pha
.26d6	74 32		stz $32,x			stz 	NSStatus,x
.26d8	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.26da	c9 e2		cmp #$e2			cmp 	#$E2
.26dc	90 25		bcc $2703			bcc 	_UANoFixup
.26de	8a		txa				txa 									; value in +1
.26df	a8		tay				tay
.26e0	c8		iny				iny
.26e1	20 89 28	jsr $2889			jsr 	CopyFloatXY
.26e4	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.26e6	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.26e9	e8		inx				inx
.26ea	20 ee 21	jsr $21ee			jsr 	FloatDivide
.26ed	b0 21		bcs $2710			bcs 	_FATError
.26ef	20 13 27	jsr $2713			jsr 	CoreAtn 						; calculate the root
.26f2	20 7e 28	jsr $287e			jsr 	CompletePolynomial
.26f5	20 67 26	jsr $2667			jsr 	FloatNegate 					; make -ve
.26f8	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.26fa	20 d5 28	jsr $28d5			jsr 	LoadConstant
.26fd	e8		inx				inx
.26fe	20 c9 20	jsr $20c9			jsr 	FloatAdd
.2701	80 06		bra $2709			bra 	_UAComplete
.2703					_UANoFixup:
.2703	20 13 27	jsr $2713			jsr 	CoreAtn
.2706	20 7e 28	jsr $287e			jsr 	CompletePolynomial
.2709					_UAComplete:
.2709	68		pla				pla 									; apply the result.
.270a	55 32		eor $32,x			eor 	NSStatus,x
.270c	95 32		sta $32,x			sta 	NSStatus,x
.270e	18		clc				clc
.270f	60		rts				rts
.2710					_FATError:
.2710	68		pla				pla
.2711	38		sec				sec
.2712	60		rts				rts
.2713					CoreAtn:
.2713	a9 81		lda #$81			lda 	#AtnCoefficients & $FF
.2715	a0 27		ldy #$27			ldy 	#AtnCoefficients >> 8
.2717	4c d2 29	jmp $29d2			jmp 	CorePolySquared
.271a					ExpCoefficients:
>271a	07					.byte	7
>271b	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>271f	d2					.byte	$d2
>2720	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>2724	d5					.byte	$d5
>2725	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>2729	d8					.byte	$d8
>272a	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>272e	db					.byte	$db
>272f	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>2733	dd					.byte	$dd
>2734	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>2738	df					.byte	$df
>2739	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>273d	e1					.byte	$e1
>273e	00 00 00 40				.dword	$40000000 ; 1.0
>2742	e2					.byte	$e2
.2743					SinCoefficients:
>2743	06					.byte	6
>2744	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>2748	e5					.byte	$e5
>2749	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>274d	e7					.byte	$e7
>274e	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>2752	e8					.byte	$e8
>2753	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>2757	e8					.byte	$e8
>2758	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>275c	e7					.byte	$e7
>275d	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>2761	e4					.byte	$e4
>2762	00 00 00 00				.dword	$00000000 ; 0.0
>2766	00					.byte	$00
.2767					LogCoefficients:
>2767	04					.byte	4
>2768	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>276c	e0					.byte	$e0
>276d	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>2771	e1					.byte	$e1
>2772	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>2776	e1					.byte	$e1
>2777	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>277b	e3					.byte	$e3
>277c	00 00 00 c0				.dword	$c0000000 ; -0.5
>2780	e1					.byte	$e1
.2781					AtnCoefficients:
>2781	0c					.byte	12
>2782	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2786	d7					.byte	$d7
>2787	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>278b	da					.byte	$da
>278c	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>2790	dc					.byte	$dc
>2791	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2795	dd					.byte	$dd
>2796	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>279a	dd					.byte	$dd
>279b	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>279f	de					.byte	$de
>27a0	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>27a4	de					.byte	$de
>27a5	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>27a9	de					.byte	$de
>27aa	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>27ae	df					.byte	$df
>27af	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>27b3	df					.byte	$df
>27b4	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>27b8	e0					.byte	$e0
>27b9	00 00 00 40				.dword	$40000000 ; 1.0
>27bd	e2					.byte	$e2
>27be	00 00 00 00				.dword	$00000000 ; 0.0
>27c2	00					.byte	$00
.27c3					Const_Base:
.27c3					Const_1Div2Pi:
>27c3	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>27c7	df					.byte	$df
.27c8					Const_PiDiv2:
>27c8	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>27cc	e2					.byte	$e2
.27cd					Const_Log2_e:
>27cd	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>27d1	e2					.byte	$e2
.27d2					Const_sqrt_2:
>27d2	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>27d6	e2					.byte	$e2
.27d7					Const_sqrt_half:
>27d7	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>27db	e1					.byte	$e1
.27dc					Const_pi:
>27dc	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>27e0	e3					.byte	$e3
.27e1					Const_half:
>27e1	00 00 00 40				.dword	$40000000 ; 0.50000000
>27e5	e1					.byte	$e1
.27e6					Const_ln_e:
>27e6	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>27ea	e1					.byte	$e1
.27eb					FloatCosine:
.27eb	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.27ed	20 d5 28	jsr $28d5			jsr 	LoadConstant
.27f0	e8		inx				inx
.27f1	20 c9 20	jsr $20c9			jsr 	FloatAdd
.27f4	4c 8b 29	jmp $298b			jmp 	FloatSine
.27f7					FloatExponent:
.27f7	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.27f9	20 d5 28	jsr $28d5			jsr 	LoadConstant
.27fc	e8		inx				inx
.27fd	20 65 23	jsr $2365			jsr 	FloatMultiply
.2800	20 42 28	jsr $2842			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.2803	e8		inx				inx
.2804	20 e0 22	jsr $22e0			jsr 	FloatIntegerPart
.2807	ca		dex				dex
.2808	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.280a	15 57		ora $57,x			ora 	NSMantissa2+1,x
.280c	15 63		ora $63,x			ora 	NSMantissa3+1,x
.280e	d0 38		bne $2848			bne 	_UERangeError
.2810	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.2812	c9 40		cmp #$40			cmp 	#64
.2814	b0 32		bcs $2848			bcs 	_UERangeError
.2816	48		pha				pha
.2817	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.2819	48		pha				pha
.281a	20 85 22	jsr $2285			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.281d	68		pla				pla
.281e	10 14		bpl $2834			bpl 	_UEPositive
.2820	e8		inx				inx 							; 1-x
.2821	a9 01		lda #$01			lda 	#1
.2823	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.2826	ca		dex				dex
.2827	20 67 26	jsr $2667			jsr 	FloatNegate
.282a	e8		inx				inx
.282b	20 c9 20	jsr $20c9			jsr 	FloatAdd
.282e	68		pla				pla 							; integer part +1 and negated.
.282f	1a		inc a				inc 	a
.2830	49 ff		eor #$ff			eor 	#$FF
.2832	1a		inc a				inc 	a
.2833	48		pha				pha
.2834					_UEPositive:
.2834	20 4a 28	jsr $284a			jsr 	CoreExponent
.2837	20 7e 28	jsr $287e			jsr 	CompletePolynomial
.283a	68		pla				pla
.283b	18		clc				clc
.283c	75 6e		adc $6e,x			adc 	NSExponent,x
.283e	95 6e		sta $6e,x			sta 	NSExponent,x
.2840	18		clc				clc
.2841	60		rts				rts
.2842					_UECopy01:
.2842	8a		txa				txa
.2843	a8		tay				tay
.2844	c8		iny				iny
.2845	4c 89 28	jmp $2889			jmp 	CopyFloatXY
.2848					_UERangeError:
.2848	38		sec				sec
.2849	60		rts				rts
.284a					CoreExponent:
.284a	a9 1a		lda #$1a			lda 	#ExpCoefficients & $FF
.284c	a0 27		ldy #$27			ldy 	#ExpCoefficients >> 8
.284e	20 52 28	jsr $2852			jsr 	CalculateHornerPolynomial
.2851	60		rts				rts
.2852					CalculateHornerPolynomial:
.2852	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.2854	84 2d		sty $2d				sty 	zTemp0+1
.2856	9c b8 05	stz $05b8			stz 	coefficientCount 			; zero the count.
.2859	8e b9 05	stx $05b9			stx 	xValueSlot 					; save xValue slot.
.285c	e8		inx				inx 								; set the count to zero.
.285d	20 a5 26	jsr $26a5			jsr 	FloatSetZero
.2860					_CHPLoop:
.2860	8a		txa				txa 								; copy X-1 to X+1
.2861	a8		tay				tay
.2862	ca		dex				dex
.2863	c8		iny				iny
.2864	20 89 28	jsr $2889			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.2867	e8		inx				inx
.2868	e8		inx				inx
.2869	20 65 23	jsr $2365			jsr 	FloatMultiply 				; times current by X
.286c	e8		inx				inx
.286d	20 a8 28	jsr $28a8			jsr 	GetCoefficient 				; coefficient into X+1
.2870	20 c9 20	jsr $20c9			jsr 	FloatAdd 					; and add
.2873	ee b8 05	inc $05b8			inc 	coefficientCount
.2876	ad b8 05	lda $05b8			lda 	coefficientCount
.2879	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.287b	d0 e3		bne $2860			bne 	_CHPLoop
.287d	60		rts				rts
.287e					CompletePolynomial:
.287e	20 65 23	jsr $2365			jsr 	FloatMultiply
.2881	e8		inx				inx 								; get the last value
.2882	20 a8 28	jsr $28a8			jsr 	GetCoefficient
.2885	20 c9 20	jsr $20c9			jsr 	FloatAdd 					; and add it
.2888	60		rts				rts
.2889					CopyFloatXY:
.2889	b5 6e		lda $6e,x			lda 	NSExponent,x
.288b	99 6e 00	sta $006e,y			sta 	NSExponent,y
.288e	b5 32		lda $32,x			lda 	NSStatus,x
.2890	99 32 00	sta $0032,y			sta 	NSStatus,y
.2893	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2895	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.2898	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.289a	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.289d	b5 56		lda $56,x			lda 	NSMantissa2,x
.289f	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.28a2	b5 62		lda $62,x			lda 	NSMantissa3,x
.28a4	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.28a7	60		rts				rts
.28a8					GetCoefficient:
.28a8	5a		phy				phy
.28a9	ad b8 05	lda $05b8			lda 	coefficientCount 			; 5 per block
.28ac	0a		asl a				asl 	a
.28ad	0a		asl a				asl 	a
.28ae	38		sec				sec 								; +1 for count
.28af	6d b8 05	adc $05b8			adc 	coefficientCount
.28b2	a8		tay				tay
.28b3	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.28b5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.28b7	c8		iny				iny
.28b8	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28ba	95 4a		sta $4a,x			sta 	NSMantissa1,x
.28bc	c8		iny				iny
.28bd	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28bf	95 56		sta $56,x			sta 	NSMantissa2,x
.28c1	c8		iny				iny
.28c2	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28c4	48		pha				pha
.28c5	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.28c7	95 62		sta $62,x			sta 	NSMantissa3,x
.28c9	c8		iny				iny
.28ca	68		pla				pla
.28cb	29 80		and #$80			and 	#$80
.28cd	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.28cf	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28d1	95 6e		sta $6e,x			sta 	NSExponent,x
.28d3	7a		ply				ply
.28d4	60		rts				rts
.05b8					coefficientCount:
>05b8							.fill 	1
.05b9					xValueSlot:
>05b9							.fill 	1
.28d5					LoadConstant:
.28d5	5a		phy				phy
.28d6	a8		tay				tay
.28d7	b9 c3 27	lda $27c3,y			lda 	Const_Base+0,y
.28da	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.28dc	b9 c4 27	lda $27c4,y			lda 	Const_Base+1,y
.28df	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.28e1	b9 c5 27	lda $27c5,y			lda 	Const_Base+2,y
.28e4	95 57		sta $57,x			sta 	NSMantissa2+1,x
.28e6	b9 c6 27	lda $27c6,y			lda 	Const_Base+3,y
.28e9	48		pha				pha
.28ea	29 7f		and #$7f			and 	#$7F
.28ec	95 63		sta $63,x			sta 	NSMantissa3+1,x
.28ee	68		pla				pla
.28ef	29 80		and #$80			and 	#$80
.28f1	95 33		sta $33,x			sta 	NSStatus+1,x
.28f3	b9 c7 27	lda $27c7,y			lda 	Const_Base+4,y
.28f6	95 6f		sta $6f,x			sta 	NSExponent+1,x
.28f8	7a		ply				ply
.28f9	60		rts				rts
.28fa					FloatLogarithm:
.28fa	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.28fc	30 5f		bmi $295d			bmi 	_ULRange
.28fe	20 c7 26	jsr $26c7			jsr 	FloatIsZero
.2901	f0 5a		beq $295d			beq 	_ULRange
.2903	20 fa 23	jsr $23fa			jsr 	FloatNormalise 				; put into FP mode.
.2906	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.2908	48		pha				pha
.2909	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.290b	95 6e		sta $6e,x			sta 	NSExponent,x
.290d	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.290f	20 d5 28	jsr $28d5			jsr 	LoadConstant
.2912	e8		inx				inx
.2913	20 c9 20	jsr $20c9			jsr 	FloatAdd
.2916	8a		txa				txa 								; divide into sqrt 2.0
.2917	a8		tay				tay
.2918	c8		iny				iny
.2919	20 89 28	jsr $2889			jsr 	CopyFloatXY
.291c	ca		dex				dex
.291d	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.291f	20 d5 28	jsr $28d5			jsr 	LoadConstant
.2922	e8		inx				inx
.2923	e8		inx				inx
.2924	20 ee 21	jsr $21ee			jsr 	FloatDivide 				; if zero, error.
.2927	b0 33		bcs $295c			bcs 	_ULRangePla
.2929	20 67 26	jsr $2667			jsr 	FloatNegate 				; subtract from 1
.292c	e8		inx				inx
.292d	a9 01		lda #$01			lda 	#1
.292f	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.2932	20 c9 20	jsr $20c9			jsr 	FloatAdd
.2935	20 5f 29	jsr $295f			jsr 	CoreLog
.2938	20 7e 28	jsr $287e			jsr 	CompletePolynomial
.293b	68		pla				pla 								; add exponent
.293c	18		clc				clc
.293d	69 1f		adc #$1f			adc 	#31 						; fix up
.293f	48		pha				pha
.2940	10 03		bpl $2945			bpl 	_LogNotNeg
.2942	49 ff		eor #$ff			eor 	#$FF
.2944	1a		inc a				inc 	a
.2945					_LogNotNeg:
.2945	e8		inx				inx 								; set byte and sign.
.2946	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.2949	68		pla				pla
.294a	29 80		and #$80			and 	#$80
.294c	95 32		sta $32,x			sta 	NSStatus,x
.294e	20 c9 20	jsr $20c9			jsr 	FloatAdd
.2951	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.2953	20 d5 28	jsr $28d5			jsr 	LoadConstant
.2956	e8		inx				inx
.2957	20 65 23	jsr $2365			jsr 	FloatMultiply
.295a	18		clc				clc
.295b	60		rts				rts
.295c					_ULRangePla:
.295c	68		pla				pla
.295d					_ULRange:
.295d	38		sec				sec
.295e	60		rts				rts
.295f					CoreLog:
.295f	a9 67		lda #$67			lda 	#LogCoefficients & $FF
.2961	a0 27		ldy #$27			ldy 	#LogCoefficients >> 8
.2963	4c d2 29	jmp $29d2			jmp 	CorePolySquared
.2966					FloatPI:
.2966	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.2968	20 d5 28	jsr $28d5			jsr 	LoadConstant
.296b	e8		inx				inx
.296c	18		clc				clc
.296d	60		rts				rts
.296e					FloatPower:
.296e	ca		dex				dex
.296f	8a		txa				txa 							; copy 0 to 2, so we can process it
.2970	a8		tay				tay
.2971	c8		iny				iny
.2972	c8		iny				iny
.2973	20 89 28	jsr $2889			jsr 	CopyFloatXY
.2976	e8		inx				inx 							; 2 = Log(0)
.2977	e8		inx				inx
.2978	20 fa 28	jsr $28fa			jsr 	FloatLogarithm
.297b	b0 0d		bcs $298a			bcs 	_FPWExit
.297d	20 65 23	jsr $2365			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.2980	8a		txa				txa 							; copy to slot 0
.2981	a8		tay				tay
.2982	88		dey				dey
.2983	20 89 28	jsr $2889			jsr 	CopyFloatXY
.2986	ca		dex				dex  							; Exponent code.
.2987	20 f7 27	jsr $27f7			jsr 	FloatExponent
.298a					_FPWExit:
.298a	60		rts				rts
.298b					FloatSine:
.298b	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.298d	48		pha				pha
.298e	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.2990	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.2992	20 d5 28	jsr $28d5			jsr 	LoadConstant
.2995	e8		inx				inx
.2996	20 65 23	jsr $2365			jsr 	FloatMultiply
.2999	20 85 22	jsr $2285			jsr 	FloatFractionalPart 		; take the fractional part
.299c	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.299e	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.29a0	90 1f		bcc $29c1			bcc 	_USProcessExit
.29a2	f0 06		beq $29aa			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.29a4	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.29a6	c9 60		cmp #$60			cmp 	#$60
.29a8	b0 0e		bcs $29b8			bcs 	_USSubtractOne
.29aa					_USSubtractFromHalf:
.29aa	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.29ac	20 d5 28	jsr $28d5			jsr 	LoadConstant
.29af	e8		inx				inx
.29b0	20 c3 20	jsr $20c3			jsr 	FloatSubtract
.29b3	20 67 26	jsr $2667			jsr 	FloatNegate 				; then negate it
.29b6	80 09		bra $29c1			bra 	_USProcessExit 				; and exit
.29b8					_USSubtractOne:
.29b8	e8		inx				inx
.29b9	a9 01		lda #$01			lda 	#1
.29bb	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.29be	20 c3 20	jsr $20c3			jsr 	FloatSubtract
.29c1					_USProcessExit:
.29c1	20 ce 29	jsr $29ce			jsr 	CoreSine
.29c4	20 7e 28	jsr $287e			jsr 	CompletePolynomial
.29c7	68		pla				pla 								; restore sign and apply
.29c8	55 32		eor $32,x			eor 	NSStatus,x
.29ca	95 32		sta $32,x			sta 	NSStatus,x
.29cc	18		clc				clc
.29cd	60		rts				rts
.29ce					CoreSine:
.29ce	a9 43		lda #$43			lda 	#SinCoefficients & $FF
.29d0	a0 27		ldy #$27			ldy 	#SinCoefficients >> 8
.29d2					CorePolySquared:
.29d2	48		pha				pha 								; save coefficient table
.29d3	5a		phy				phy
.29d4	8a		txa				txa 								; copy X to +1, +2
.29d5	a8		tay				tay
.29d6	c8		iny				iny
.29d7	20 89 28	jsr $2889			jsr 	CopyFloatXY
.29da	c8		iny				iny
.29db	20 89 28	jsr $2889			jsr 	CopyFloatXY
.29de	e8		inx				inx 								; point to the pair and put x^2 on stack
.29df	e8		inx				inx
.29e0	20 65 23	jsr $2365			jsr 	FloatMultiply
.29e3	7a		ply				ply 								; coefficient table back.
.29e4	68		pla				pla
.29e5	20 52 28	jsr $2852			jsr 	CalculateHornerPolynomial
.29e8	8a		txa				txa 								; copy back to slot #1
.29e9	a8		tay				tay
.29ea	88		dey				dey
.29eb	20 89 28	jsr $2889			jsr	 	CopyFloatXY
.29ee	ca		dex				dex 								; point at result
.29ef	60		rts				rts
.29f0					FloatSquareRoot:
.29f0	20 fa 28	jsr $28fa			jsr 	FloatLogarithm
.29f3	b0 06		bcs $29fb			bcs 	_FSQExit
.29f5	d6 6e		dec $6e,x			dec 	NSExponent,x
.29f7	20 f7 27	jsr $27f7			jsr 	FloatExponent
.29fa	18		clc				clc
.29fb					_FSQExit:
.29fb	60		rts				rts
.29fc					FloatTangent:
.29fc	da		phx				phx
.29fd	8a		txa				txa 								; sin -> +1
.29fe	a8		tay				tay
.29ff	c8		iny				iny
.2a00	20 89 28	jsr $2889			jsr 	CopyFloatXY
.2a03	e8		inx				inx
.2a04	20 8b 29	jsr $298b			jsr 	FloatSine
.2a07	ca		dex				dex
.2a08	8a		txa				txa 								; cos -> +2
.2a09	a8		tay				tay
.2a0a	c8		iny				iny
.2a0b	c8		iny				iny
.2a0c	20 89 28	jsr $2889			jsr 	CopyFloatXY
.2a0f	e8		inx				inx
.2a10	e8		inx				inx
.2a11	20 eb 27	jsr $27eb			jsr 	FloatCosine
.2a14	20 ee 21	jsr $21ee			jsr 	FloatDivide 				; calculate sin/cos
.2a17	b0 07		bcs $2a20			bcs 	_FTExit 					; divide by zero
.2a19	8a		txa				txa 								; copy result down.
.2a1a	a8		tay				tay
.2a1b	88		dey				dey
.2a1c	20 89 28	jsr $2889			jsr 	CopyFloatXY
.2a1f	18		clc				clc
.2a20					_FTExit:
.2a20	fa		plx				plx
.2a21	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.007a					srcPtr:
>007a							.fill 	2
.05ba					currentLineNumber:
>05ba							.fill 	2
.2a22					InlineNonDecimal:
.2a22	a2 02		ldx #$02			ldx 	#2 							; get size in X
.2a24	c9 25		cmp #$25			cmp 	#"%"
.2a26	f0 02		beq $2a2a			beq 	_INDBinary
.2a28	a2 10		ldx #$10			ldx 	#16
.2a2a					_INDBinary:
.2a2a	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.2a2c	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.2a2e	64 2c		stz $2c				stz 	zTemp0 						; zero result
.2a30	64 2d		stz $2d				stz 	zTemp0+1
.2a32					_INDLoop:
.2a32	20 e3 33	jsr $33e3			jsr 	LookNext 					; check next character
.2a35	20 1f 34	jsr $341f			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.2a38	90 1f		bcc $2a59			bcc		_INDDone 					; didn't convert
.2a3a	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.2a3c	b0 1b		bcs $2a59			bcs 	_INDDone
.2a3e	20 68 2a	jsr $2a68			jsr 	_INDShift 					; x 2 or x 16
.2a41	e0 02		cpx #$02			cpx 	#2
.2a43	f0 09		beq $2a4e			beq 	_INDNotHex
.2a45	20 68 2a	jsr $2a68			jsr 	_INDShift
.2a48	20 68 2a	jsr $2a68			jsr 	_INDShift
.2a4b	20 68 2a	jsr $2a68			jsr 	_INDShift
.2a4e					_INDNotHex:
.2a4e	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.2a50	85 2c		sta $2c				sta 	zTemp0
.2a52	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume
.2a55	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.2a57	80 d9		bra $2a32			bra 	_INDLoop
.2a59					_INDDone:
.2a59	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.2a5b	f0 08		beq $2a65			beq 	_INDError
.2a5d	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.2a5f	a5 2c		lda $2c				lda 	zTemp0
.2a61	20 8a 2b	jsr $2b8a			jsr 	PushIntegerYA
.2a64	60		rts				rts
.2a65					_INDError:
.2a65	4c 4d 1f	jmp $1f4d		jmp	ErrorV_syntax
.2a68					_INDShift:
.2a68	06 2c		asl $2c				asl 	zTemp0
.2a6a	26 2d		rol $2d				rol 	zTemp0+1
.2a6c	60		rts				rts
.2a6d					GetLineNumber:
.2a6d	ac bb 05	ldy $05bb			ldy 	currentLineNumber+1
.2a70	ad ba 05	lda $05ba			lda 	currentLineNumber
.2a73	60		rts				rts
.2a74					WriteCodeByte:
.2a74	48		pha				pha 								; save on stack
.2a75	da		phx				phx
.2a76	5a		phy				phy
.2a77	aa		tax				tax
.2a78	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.2a7a	20 87 2b	jsr $2b87			jsr 	CallAPIHandler
.2a7d	7a		ply				ply 								; restore from stack
.2a7e	fa		plx				plx
.2a7f	68		pla				pla
.2a80	60		rts				rts
.2a81					PrintCharacter
.2a81	48		pha				pha
.2a82	da		phx				phx
.2a83	5a		phy				phy
.2a84	aa		tax				tax
.2a85	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.2a87	20 87 2b	jsr $2b87			jsr 	CallAPIHandler
.2a8a	7a		ply				ply
.2a8b	fa		plx				plx
.2a8c	68		pla				pla
.2a8d	60		rts				rts
.2a8e					ProcessNewLine:
.2a8e	86 2c		stx $2c				stx 	zTemp0 						; save address in zTemp0
.2a90	84 2d		sty $2d				sty 	zTemp0+1
.2a92	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.2a93	8a		txa				txa
.2a94	69 04		adc #$04			adc 	#4
.2a96	85 7a		sta $7a				sta 	srcPtr
.2a98	98		tya				tya
.2a99	69 00		adc #$00			adc 	#0
.2a9b	85 7b		sta $7b				sta 	srcPtr+1
.2a9d	a0 02		ldy #$02			ldy 	#2							; read and save line number
.2a9f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2aa1	8d ba 05	sta $05ba			sta 	currentLineNumber
.2aa4	c8		iny				iny
.2aa5	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2aa7	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2aaa	60		rts				rts
.2aab					BufferClear:
.2aab	9c bc 05	stz $05bc			stz 	bufferSize
.2aae	60		rts				rts
.2aaf					BufferWrite:
.2aaf	da		phx				phx
.2ab0	ae bc 05	ldx $05bc			ldx 	bufferSize
.2ab3	9d bd 05	sta $05bd,x			sta 	dataBuffer,x
.2ab6	ee bc 05	inc $05bc			inc 	bufferSize
.2ab9	fa		plx				plx
.2aba	60		rts				rts
.2abb					BufferOutput:
.2abb	ad bc 05	lda $05bc			lda 	bufferSize
.2abe	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2ac1	a2 00		ldx #$00			ldx 	#0
.2ac3					_BOLoop:
.2ac3	ec bc 05	cpx $05bc			cpx 	bufferSize
.2ac6	f0 09		beq $2ad1			beq 	_BOExit
.2ac8	bd bd 05	lda $05bd,x			lda 	dataBuffer,x
.2acb	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2ace	e8		inx				inx
.2acf	80 f2		bra $2ac3			bra 	_BOLoop
.2ad1					_BOExit:
.2ad1	60		rts				rts
.05bc					bufferSize:
>05bc							.fill 	1
.05bd					dataBuffer:
>05bd							.fill 	256
.2ad2					CheckNextComma:
.2ad2	a9 2c		lda #$2c			lda	 	#","
.2ad4	80 06		bra $2adc			bra 	CheckNextA
.2ad6					CheckNextRParen:
.2ad6	a9 29		lda #$29			lda	 	#")"
.2ad8	80 02		bra $2adc			bra 	CheckNextA
.2ada					CheckNextLParen:
.2ada	a9 28		lda #$28			lda 	#"("
.2adc					CheckNextA:
.2adc	8d bd 06	sta $06bd			sta 	checkCharacter 				; save test character
.2adf					_CNALoop:
.2adf	20 ff 33	jsr $33ff			jsr 	GetNextNonSpace 			; get next skipping spaces.
.2ae2	cd bd 06	cmp $06bd			cmp 	checkCharacter 				; matches ?
.2ae5	f0 03		beq $2aea			beq 	_CNAExit
.2ae7	4c 4d 1f	jmp $1f4d		jmp	ErrorV_syntax
.2aea					_CNAExit:
.2aea	60		rts				rts
.06bd					checkCharacter:
>06bd							.fill 	1
.2aeb					StartCompiler:
.2aeb	86 2c		stx $2c				stx 	zTemp0 						; access API
.2aed	84 2d		sty $2d				sty 	zTemp0+1
.2aef	a0 2d		ldy #$2d			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.2af1	a2 43		ldx #$43			ldx 	#CompilerErrorHandler & $FF
.2af3	20 26 1f	jsr $1f26			jsr 	SetErrorHandler
.2af6	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.2af8	b2 2c		lda ($2c)			lda 	(zTemp0)
.2afa	8d bf 06	sta $06bf			sta 	APIVector
.2afd	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2aff	8d c0 06	sta $06c0			sta 	APIVector+1
.2b02	c8		iny				iny 								; copy data area range.
.2b03	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2b05	8d c1 06	sta $06c1			sta 	compilerStartHigh
.2b08	c8		iny				iny
.2b09	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2b0b	8d c2 06	sta $06c2			sta 	compilerEndHigh
.2b0e	ba		tsx				tsx 								; save stack pointer
.2b0f	8e be 06	stx $06be			stx 	compilerSP
.2b12	20 83 37	jsr $3783			jsr 	STRReset 					; reset storage (line#, variable)
.2b15	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.2b17	20 87 2b	jsr $2b87			jsr 	CallAPIHandler
.2b1a	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.2b1c	20 87 2b	jsr $2b87			jsr 	CallAPIHandler
.2b1f	a9 d5		lda #$d5			lda 	#PCD_CMD_VARSPACE
.2b21	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2b24	a9 00		lda #$00			lda 	#0
.2b26	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2b29	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2b2c					MainCompileLoop:
.2b2c	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.2b2e	20 87 2b	jsr $2b87			jsr 	CallAPIHandler
.2b31	90 31		bcc $2b64			bcc 	SaveCodeAndExit 			; end of source.
.2b33	20 8e 2a	jsr $2a8e			jsr 	ProcessNewLine 				; set up pointer and line number.
.2b36	20 6d 2a	jsr $2a6d			jsr 	GetLineNumber 				; get line #
.2b39	20 6d 35	jsr $356d			jsr 	STRMarkLine 				; remember the code position and number of this line.
.2b3c	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.2b3e	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2b41					_MCLSameLine:
.2b41	20 ff 33	jsr $33ff			jsr 	GetNextNonSpace 			; get the first character.
.2b44	f0 e6		beq $2b2c			beq 	MainCompileLoop 			; end of line, get next line.
.2b46	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.2b48	f0 f7		beq $2b41			beq 	_MCLSameLine
.2b4a	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.2b4c	10 0c		bpl $2b5a			bpl 	_MCLCheckAssignment
.2b4e	a2 b0		ldx #$b0			ldx 	#CommandTables & $FF 		; do command tables.
.2b50	a0 2f		ldy #$2f			ldy 	#CommandTables >> 8
.2b52	20 85 32	jsr $3285			jsr 	GeneratorProcess
.2b55	b0 ea		bcs $2b41			bcs 	_MCLSameLine 				; keep trying to compile the line.
.2b57					_MCLSyntax:
.2b57	4c 4d 1f	jmp $1f4d		jmp	ErrorV_syntax
.2b5a					_MCLCheckAssignment:
.2b5a	20 15 34	jsr $3415			jsr 	CharIsAlpha 				; if not alpha then syntax error
.2b5d	90 f8		bcc $2b57			bcc 	_MCLSyntax
.2b5f	20 3b 35	jsr $353b			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.2b62	80 dd		bra $2b41			bra		_MCLSameLine 				; loop back.
.2b64					SaveCodeAndExit:
.2b64	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.2b66	20 87 2b	jsr $2b87			jsr 	CallAPIHandler
.2b69	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.2b6b	a8		tay				tay
.2b6c	20 6d 35	jsr $356d			jsr 	STRMarkLine
.2b6f	a9 c5		lda #$c5			lda 	#PCD_EXIT 					; add an END
.2b71	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2b74	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.2b76	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2b79	20 a0 2e	jsr $2ea0			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.2b7c	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.2b7e	20 87 2b	jsr $2b87			jsr 	CallAPIHandler
.2b81	18		clc				clc 								; CC = success
.2b82					ExitCompiler:
.2b82	ae be 06	ldx $06be			ldx 	compilerSP 					; reload SP and exit.
.2b85	9a		txs				txs
.2b86	60		rts				rts
.2b87					CallAPIHandler:
.2b87	6c bf 06	jmp ($06bf)			jmp 	(APIVector)
.06be					compilerSP:
>06be							.fill 	1
.06bf					APIVector:
>06bf							.fill 	2
.06c1					compilerStartHigh:
>06c1							.fill 	1
.06c2					compilerEndHigh:
>06c2							.fill 	1
.2b8a					PushIntegerYA:
.2b8a	c0 00		cpy #$00			cpy 	#0 							; 0-255
.2b8c	f0 0f		beq $2b9d			beq 	PushIntegerA
.2b8e	48		pha				pha
.2b8f	a9 cd		lda #$cd			lda 	#PCD_CMD_WORD 				; send .word
.2b91	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2b94	68		pla				pla 								; then LSB
.2b95	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2b98	98		tya				tya 								; then MSB
.2b99	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2b9c	60		rts				rts
.2b9d					PushIntegerA:
.2b9d	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.2b9f	90 07		bcc $2ba8			bcc 	_PIWriteA
.2ba1	48		pha				pha
.2ba2	a9 cc		lda #$cc			lda 	#PCD_CMD_BYTE 				; send .byte
.2ba4	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2ba7	68		pla				pla
.2ba8					_PIWriteA:
.2ba8	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2bab	60		rts				rts
.2bac					PushFloatCommand:
.2bac	a9 ce		lda #$ce			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.2bae	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2bb1	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.2bb3	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2bb6	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2bb8	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2bbb	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2bbd	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2bc0	b5 56		lda $56,x			lda 	NSMantissa2,x
.2bc2	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2bc5	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.2bc7	29 80		and #$80			and 	#$80
.2bc9	15 62		ora $62,x			ora 	NSMantissa3,x
.2bcb	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2bce	60		rts				rts
.2bcf					CreateVariableRecord:
.2bcf	48		pha				pha
.2bd0	ad cd 06	lda $06cd			lda 	freeVariableMemory 		; push current free address on stack.
.2bd3	48		pha				pha
.2bd4	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2bd7	48		pha				pha
.2bd8	ad cb 06	lda $06cb			lda 	variableListEnd  		; copy end of list to zTemp0
.2bdb	85 2c		sta $2c				sta 	zTemp0
.2bdd	ad cc 06	lda $06cc			lda 	variableListEnd+1
.2be0	85 2d		sta $2d				sta 	zTemp0+1
.2be2	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.2be4	92 2c		sta ($2c)			sta 	(zTemp0)
.2be6	98		tya				tya
.2be7	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.2be9	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2beb	88		dey				dey
.2bec	8a		txa				txa
.2bed	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bef	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.2bf1	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2bf4	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bf6	c8		iny				iny
.2bf7	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2bfa	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bfc	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.2bfe	a9 00		lda #$00			lda 	#0
.2c00	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2c02	18		clc				clc
.2c03	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.2c05	6d cb 06	adc $06cb			adc  	variableListEnd
.2c08	8d cb 06	sta $06cb			sta 	variableListEnd
.2c0b	90 03		bcc $2c10			bcc 	_CVNoCarry2
.2c0d	ee cc 06	inc $06cc			inc 	variableListEnd+1
.2c10					_CVNoCarry2:
.2c10	7a		ply				ply
.2c11	fa		plx				plx
.2c12	68		pla				pla
.2c13	60		rts				rts
.2c14					SetVariableRecordToCodePosition:
.2c14	48		pha				pha
.2c15	5a		phy				phy
.2c16	a0 03		ldy #$03			ldy 	#3
.2c18	a5 2b		lda $2b				lda 	objPtr+1
.2c1a	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2c1c	c8		iny				iny
.2c1d	a5 2a		lda $2a				lda 	objPtr
.2c1f	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2c21	7a		ply				ply
.2c22	68		pla				pla
.2c23	60		rts				rts
.2c24					AllocateBytesForType:
.2c24	48		pha				pha
.2c25	da		phx				phx
.2c26	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.2c28	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2c2a	c9 00		cmp #$00			cmp 	#NSSIFloat
.2c2c	d0 02		bne $2c30			bne 	_CVNotFloat
.2c2e	a2 06		ldx #$06			ldx 	#6
.2c30					_CVNotFloat:
.2c30	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.2c31	18		clc				clc
.2c32	6d cd 06	adc $06cd			adc 	freeVariableMemory
.2c35	8d cd 06	sta $06cd			sta 	freeVariableMemory
.2c38	90 03		bcc $2c3d			bcc 	_CVNoCarry1
.2c3a	ee ce 06	inc $06ce			inc 	freeVariableMemory+1
.2c3d					_CVNoCarry1:
.2c3d	fa		plx				plx
.2c3e	68		pla				pla
.2c3f	60		rts				rts
.2c40					CommandDATA:
.2c40	20 ab 2a	jsr $2aab			jsr 	BufferClear 				; copy it to the buffer
.2c43	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace
.2c46					_CTDataLoop:
.2c46	20 e3 33	jsr $33e3			jsr 	LookNext 					; reached EOL
.2c49	f0 08		beq $2c53			beq 	_CTDataDone
.2c4b	20 af 2a	jsr $2aaf			jsr 	BufferWrite 				; write and consume
.2c4e	20 f4 33	jsr $33f4			jsr 	GetNext
.2c51	80 f3		bra $2c46			bra 	_CTDataLoop
.2c53					_CTDataDone:
.2c53	a9 d0		lda #$d0			lda 	#PCD_CMD_DATA 				; output command and buffer
.2c55	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2c58	20 bb 2a	jsr $2abb			jsr 	BufferOutput
.2c5b	60		rts				rts
.2c5c					CommandDEF:
.2c5c	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.2c5e	20 9d 2b	jsr $2b9d			jsr 	PushIntegerA
.2c61	20 04 35	jsr $3504			jsr 	CompileGotoEOL 				; compile skip over DEF
.2c64	a9 a5		lda #$a5			lda 	#C64_FN
.2c66	20 dc 2a	jsr $2adc			jsr 	CheckNextA
.2c69	20 ff 33	jsr $33ff			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2c6c	20 64 34	jsr $3464			jsr 	ExtractVariableName
.2c6f	8a		txa				txa
.2c70	10 51		bpl $2cc3			bpl 	_CDError
.2c72	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2c73	29 7f		and #$7f			and 	#$7F
.2c75	aa		tax				tax
.2c76	98		tya				tya
.2c77	09 80		ora #$80			ora 	#$80
.2c79	a8		tay				tay
.2c7a	20 44 2e	jsr $2e44			jsr 	FindVariable				; does it already exist ?
.2c7d	b0 44		bcs $2cc3			bcs 	_CDError 					; if so, that's an error.
.2c7f	20 cf 2b	jsr $2bcf			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.2c82	20 14 2c	jsr $2c14			jsr 	SetVariableRecordToCodePosition
.2c85	20 ff 33	jsr $33ff			jsr 	GetNextNonSpace
.2c88	20 40 37	jsr $3740			jsr 	GetReferenceTerm 			; get var ref, not array
.2c8b	c9 00		cmp #$00			cmp 	#0
.2c8d	30 34		bmi $2cc3			bmi 	_CDError
.2c8f	8d c3 06	sta $06c3			sta 	defType 					; save type
.2c92	8e c4 06	stx $06c4			stx 	defVariable 				; save var ref
.2c95	8c c5 06	sty $06c5			sty 	defVariable+1
.2c98	29 40		and #$40			and 	#NSSString 					; only numbers.
.2c9a	d0 27		bne $2cc3			bne 	_CDError
.2c9c	20 d6 2a	jsr $2ad6			jsr 	CheckNextRParen 			; check )
.2c9f	a9 b2		lda #$b2			lda 	#C64_EQUAL
.2ca1	20 dc 2a	jsr $2adc			jsr 	CheckNextA 					; check =
.2ca4	18		clc				clc 								; if this is DEF FNxx(A), read A
.2ca5	20 c6 2c	jsr $2cc6			jsr 	CDReadWriteVariable
.2ca8	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.2caa	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2cad	38		sec				sec
.2cae	20 c6 2c	jsr $2cc6			jsr 	CDReadWriteVariable 		; A is now updated
.2cb1	20 8a 2d	jsr $2d8a			jsr 	CompileExpressionAt0 		; the actual body of the function.
.2cb4	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.2cb6	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2cb9	38		sec				sec
.2cba	20 c6 2c	jsr $2cc6			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.2cbd	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.2cbf	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2cc2	60		rts				rts
.2cc3					_CDError:
.2cc3	4c 4d 1f	jmp $1f4d		jmp	ErrorV_syntax
.2cc6					CDReadWriteVariable:
.2cc6	ac c5 06	ldy $06c5			ldy 	defVariable+1 				; set up YX
.2cc9	ae c4 06	ldx $06c4			ldx 	defVariable
.2ccc	ad c3 06	lda $06c3			lda 	defType
.2ccf	20 f2 36	jsr $36f2			jsr 	GetSetVariable
.2cd2	60		rts				rts
.06c3					defType:
>06c3							.fill 	1
.06c4					defVariable:
>06c4							.fill 	2
.2cd3					CommandDIM:
.2cd3	20 ff 33	jsr $33ff			jsr 	GetNextNonSpace 			; get the first non space character
.2cd6	20 64 34	jsr $3464			jsr 	ExtractVariableName 		; variable name to XY
.2cd9	da		phx				phx 								; save name with type bits.
.2cda	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.2cdc	10 37		bpl $2d15			bpl 	_CDError
.2cde	20 44 2e	jsr $2e44			jsr 	FindVariable	 			; see if already exist
.2ce1	b0 35		bcs $2d18			bcs 	_CDRedefine 				; it still exists.
.2ce3	20 cf 2b	jsr $2bcf			jsr 	CreateVariableRecord 		; create the basic variable
.2ce6	20 24 2c	jsr $2c24			jsr 	AllocateBytesForType 		; allocate memory for it
.2ce9	68		pla				pla 								; restore type bits
.2cea	5a		phy				phy 								; save the address of the basic storage
.2ceb	da		phx				phx
.2cec	48		pha				pha
.2ced	20 1b 2d	jsr $2d1b			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.2cf0	68		pla				pla
.2cf1	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.2cf3	20 9d 2b	jsr $2b9d			jsr 	PushIntegerA 				; push that type data out.
.2cf6	a9 cb		lda #$cb			lda 	#(PCD_DIM) >> 8
.2cf8	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2cfb	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.2cfd	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2d00	fa		plx				plx 								; restore address
.2d01	7a		ply				ply
.2d02	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2d04	38		sec				sec
.2d05	20 f2 36	jsr $36f2			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.2d08	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; , follows ?
.2d0b	c9 2c		cmp #$2c			cmp 	#","
.2d0d	d0 05		bne $2d14			bne 	_CDExit
.2d0f	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume comma
.2d12	80 bf		bra $2cd3			bra 	CommandDIM 					; do another DIM
.2d14					_CDExit:
.2d14	60		rts				rts
.2d15					_CDError:
.2d15	4c 4d 1f	jmp $1f4d		jmp	ErrorV_syntax
.2d18					_CDRedefine:
.2d18	4c 15 20	jmp $2015		jmp	ErrorV_redefine
.2d1b					OutputIndexGroup:
.2d1b	9c c6 06	stz $06c6			stz 	IndexCount 					; count of number of indices.
.2d1e					_OIGNext:
.2d1e	20 8a 2d	jsr $2d8a			jsr 	CompileExpressionAt0 		; get a dimension
.2d21	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2d23	c9 00		cmp #$00			cmp 	#NSSIFloat
.2d25	d0 19		bne $2d40			bne 	_OIGType
.2d27	ee c6 06	inc $06c6			inc 	IndexCount 					; bump the counter.
.2d2a	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; does a , follow ?
.2d2d	c9 2c		cmp #$2c			cmp 	#","
.2d2f	d0 05		bne $2d36			bne 	_OIGCheckEnd
.2d31	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume comma
.2d34	80 e8		bra $2d1e			bra 	_OIGNext 					; get next dimension
.2d36					_OIGCheckEnd:
.2d36	20 d6 2a	jsr $2ad6			jsr 	CheckNextRParen 			; check and consume )
.2d39	ad c6 06	lda $06c6			lda 	IndexCount
.2d3c	20 9d 2b	jsr $2b9d			jsr 	PushIntegerA 				; compile the dimension count.
.2d3f	60		rts				rts
.2d40					_OIGType:
.2d40	4c 5d 1f	jmp $1f5d		jmp	ErrorV_type
.06c6					IndexCount:
>06c6							.fill 	1
.2d43					CompilerErrorHandler:
.2d43	68		pla				pla
.2d44	7a		ply				ply
.2d45	85 2c		sta $2c				sta 	zTemp0
.2d47	84 2d		sty $2d				sty 	zTemp0+1
.2d49	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.2d4b	a0 01		ldy #$01			ldy 	#1
.2d4d					_EHDisplayMsg:
.2d4d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d4f	20 81 2a	jsr $2a81			jsr 	PrintCharacter
.2d52	c8		iny				iny
.2d53	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d55	d0 f6		bne $2d4d			bne 	_EHDisplayMsg
.2d57	a9 20		lda #$20			lda 	#32
.2d59	20 81 2a	jsr $2a81			jsr 	PrintCharacter
.2d5c	a9 40		lda #$40			lda 	#64
.2d5e	20 81 2a	jsr $2a81			jsr 	PrintCharacter
.2d61	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.2d63	20 a7 26	jsr $26a7			jsr 	FloatSetByte
.2d66	20 6d 2a	jsr $2a6d			jsr 	GetLineNumber
.2d69	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2d6b	98		tya				tya
.2d6c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2d6e	20 8d 25	jsr $258d			jsr 	FloatToString
.2d71	a0 00		ldy #$00			ldy 	#0 							; display that string.
.2d73	a2 00		ldx #$00			ldx 	#0
.2d75					_EHDisplayLine:
.2d75	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d78	20 81 2a	jsr $2a81			jsr 	PrintCharacter
.2d7b	c8		iny				iny
.2d7c	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d7f	d0 f4		bne $2d75			bne 	_EHDisplayLine
.2d81	a9 0d		lda #$0d			lda 	#13
.2d83	20 81 2a	jsr $2a81			jsr 	PrintCharacter
.2d86	38		sec				sec 								; CS = error
.2d87	4c 82 2b	jmp $2b82			jmp 	ExitCompiler
.2d8a					CompileExpressionAt0:
.2d8a	a9 00		lda #$00			lda 	#0
.2d8c					CompileExpressionAtA:
.2d8c	48		pha				pha  								; save level
.2d8d	20 ca 37	jsr $37ca			jsr 	CompileTerm 				; compile a term.
.2d90	fa		plx				plx 								; get level back into X
.2d91					_ECALoop:
.2d91	48		pha				pha 								; save type on stack.
.2d92	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; get the next character
.2d95	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.2d97	90 04		bcc $2d9d			bcc 	_ECAExit
.2d99	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.2d9b	90 02		bcc $2d9f			bcc 	_ECAHaveToken
.2d9d					_ECAExit:
.2d9d	68		pla				pla 								; throw type off stack
.2d9e	60		rts				rts
.2d9f					_ECAHaveToken:
.2d9f	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.2da1	aa		tax				tax 								; X contains the operator token
.2da2	bd 8d 2d	lda $2d8d,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.2da5	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.2da7	90 f4		bcc $2d9d			bcc 	_ECAExit
.2da9	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.2dab	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume the token.
.2dae	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.2db0	f0 11		beq $2dc3			beq 	_ECAGreaterCheck
.2db2	e0 b3		cpx #$b3			cpx 	#C64_LESS
.2db4	d0 1a		bne $2dd0			bne 	_ECAHaveFullToken
.2db6	20 e3 33	jsr $33e3			jsr 	LookNext 					; checks for < (<= or <>)
.2db9	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.2dbb	f0 0e		beq $2dcb			beq	 	_ECAToNotEqual
.2dbd	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.2dbf	d0 0f		bne $2dd0			bne 	_ECAHaveFullToken
.2dc1	80 07		bra $2dca			bra 	_ECAAddEqual
.2dc3					_ECAGreaterCheck:
.2dc3	20 e3 33	jsr $33e3			jsr 	LookNext
.2dc6	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.2dc8	d0 06		bne $2dd0			bne 	_ECAHaveFullToken
.2dca					_ECAAddEqual:
.2dca	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.2dcb					_ECAToNotEqual:
.2dcb	e8		inx				inx
.2dcc	e8		inx				inx
.2dcd	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume the = or > in >= <= <>
.2dd0					_ECAHaveFullToken:
.2dd0	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.2dd2	d0 0a		bne $2dde			bne 	_ECANotConcat
.2dd4	68		pla				pla 								; get type back
.2dd5	48		pha				pha
.2dd6	29 40		and #$40			and 	#NSSTypeMask
.2dd8	c9 40		cmp #$40			cmp 	#NSSString
.2dda	d0 02		bne $2dde			bne 	_ECANotConcat
.2ddc	a2 e0		ldx #$e0			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2dde					_ECANotConcat:
.2dde	da		phx				phx 								; save operator on the stack
.2ddf	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.2de1	da		phx				phx
.2de2	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.2de4	1a		inc a				inc 	a
.2de5	20 8c 2d	jsr $2d8c			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.2de8	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.2dea	fa		plx				plx 								; restore current precedence in X
.2deb	68		pla				pla 								; restore operator
.2dec	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.2dee	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.2df0	90 17		bcc $2e09			bcc 	_ECANotCompare
.2df2	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.2df4	b0 13		bcs $2e09			bcs 	_ECANotCompare
.2df6	7a		ply				ply 								; get type into Y
.2df7	5a		phy				phy
.2df8	48		pha				pha 								; save operator
.2df9	98		tya				tya 								; get type
.2dfa	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.2dfc	29 40		and #$40			and 	#NSSTypeMask
.2dfe	c9 40		cmp #$40			cmp 	#NSSString
.2e00	f0 02		beq $2e04			beq 	_ECANotString
.2e02	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.2e04					_ECANotString:
.2e04	98		tya				tya									; output token Y
.2e05	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2e08	68		pla				pla 								; restore operator.
.2e09					_ECANotCompare:
.2e09	18		clc				clc 								; convert to P-Code and compile.
.2e0a	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.2e0c	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2e0f	68		pla				pla 								; type of current result
.2e10	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.2e12	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.2e14	d0 19		bne $2e2f			bne		_ECAType
.2e16	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.2e18	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.2e1a	d0 18		bne $2e34			bne 	_ECAGoLoop
.2e1c	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.2e1e	c9 e0		cmp #$e0			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2e20	f0 10		beq $2e32			beq 	_ECAOkayString 				; (this is post conversion)
.2e22	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.2e24	90 09		bcc $2e2f			bcc 	_ECAType
.2e26	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.2e28	b0 05		bcs $2e2f			bcs 	_ECAType
.2e2a	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.2e2c	4c 91 2d	jmp $2d91			jmp 	_ECALoop
.2e2f					_ECAType:
.2e2f	4c 5d 1f	jmp $1f5d		jmp	ErrorV_type
.2e32					_ECAOkayString:
.2e32	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.2e34					_ECAGoLoop:
.2e34	4c 91 2d	jmp $2d91			jmp 	_ECALoop
.2e37					PrecedenceTable:
>2e37	03						.byte 	3 					; '+'
>2e38	03						.byte 	3 					; '-'
>2e39	04						.byte 	4 					; '*'
>2e3a	04						.byte 	4 					; '/'
>2e3b	05						.byte 	5 					; '^'
>2e3c	01						.byte 	1 					; 'and'
>2e3d	00						.byte 	0 					; 'or'
>2e3e	02						.byte 	2 					; '>'
>2e3f	02						.byte 	2 					; '='
>2e40	02						.byte 	2 					; '<'
>2e41	02						.byte 	2 					; '>='
>2e42	02						.byte 	2 					; '<='
>2e43	02						.byte 	2 					; '<>'
.2e44					FindVariable:
.2e44	86 2e		stx $2e				stx 	zTemp1 						; save name.
.2e46	84 2f		sty $2f				sty 	zTemp1+1
.2e48					_IVCheckSpecial:
.2e48	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.2e4a	d0 18		bne $2e64			bne 	_IVStandard
.2e4c	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.2e4e	f0 0c		beq $2e5c			beq 	_IVTIFloat
.2e50	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.2e52	d0 10		bne $2e64			bne 	_IVStandard
.2e54	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.2e56	a2 01		ldx #$01			ldx 	#$01
.2e58	a9 40		lda #$40			lda 	#NSSString
.2e5a	38		sec				sec
.2e5b	60		rts				rts
.2e5c					_IVTIFloat:
.2e5c	a0 80		ldy #$80			ldy 	#$80
.2e5e	a2 00		ldx #$00			ldx 	#$00
.2e60	a9 00		lda #$00			lda 	#0
.2e62	38		sec				sec
.2e63	60		rts				rts
.2e64					_IVStandard:
.2e64	ad c1 06	lda $06c1			lda 	compilerStartHigh			; start scanning from here.
.2e67	85 2d		sta $2d				sta 	zTemp0+1
.2e69	64 2c		stz $2c				stz 	zTemp0
.2e6b					_IVCheckLoop:
.2e6b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.2e6d	f0 2b		beq $2e9a			beq  	_IVNotFound 				; if so, return with CC.
.2e6f	a0 01		ldy #$01			ldy 	#1 							; match ?
.2e71	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e73	c5 2e		cmp $2e				cmp 	zTemp1
.2e75	d0 07		bne $2e7e			bne	 	_IVNext
.2e77	c8		iny				iny
.2e78	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e7a	c5 2f		cmp $2f				cmp 	zTemp1+1
.2e7c	f0 0d		beq $2e8b			beq 	_IVFound
.2e7e					_IVNext:
.2e7e	18		clc				clc
.2e7f	a5 2c		lda $2c				lda 	zTemp0
.2e81	72 2c		adc ($2c)			adc 	(zTemp0)
.2e83	85 2c		sta $2c				sta 	zTemp0
.2e85	90 e4		bcc $2e6b			bcc 	_IVCheckLoop
.2e87	e6 2d		inc $2d				inc 	zTemp0+1
.2e89	80 e0		bra $2e6b			bra 	_IVCheckLoop
.2e8b					_IVFound:
.2e8b	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.2e8d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e8f	aa		tax				tax
.2e90	c8		iny				iny
.2e91	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e93	48		pha				pha
.2e94	c8		iny				iny
.2e95	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e97	7a		ply				ply
.2e98	38		sec				sec
.2e99	60		rts				rts
.2e9a					_IVNotFound:
.2e9a	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.2e9c	a4 2f		ldy $2f				ldy 	zTemp1+1
.2e9e	18		clc				clc
.2e9f	60		rts				rts
.2ea0					FixBranches:
.2ea0	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.2ea2	20 87 2b	jsr $2b87			jsr 	CallAPIHandler
.2ea5					_FBLoop:
.2ea5	b2 2a		lda ($2a)			lda 	(objPtr) 					; get the next one.
.2ea7	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.2ea9	f0 1a		beq $2ec5			beq 	_FBFixGotoGosub
.2eab	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOSUB
.2ead	f0 16		beq $2ec5			beq 	_FBFixGotoGosub
.2eaf	c9 d4		cmp #$d4			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.2eb1	f0 12		beq $2ec5			beq 	_FBFixGotoGosub
.2eb3	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_Z
.2eb5	f0 0e		beq $2ec5			beq 	_FBFixGotoGosub
.2eb7	c9 d5		cmp #$d5			cmp 	#PCD_CMD_VARSPACE
.2eb9	f0 43		beq $2efe			beq 	_FBFixVarSpace
.2ebb	c9 d6		cmp #$d6			cmp 	#PCD_CMD_RESTORE 			; patch restore.
.2ebd	f0 06		beq $2ec5			beq 	_FBFixRestore
.2ebf					_FBNext:
.2ebf	20 73 20	jsr $2073			jsr 	MoveObjectForward 			; move forward in object code.
.2ec2	90 e1		bcc $2ea5			bcc 	_FBLoop 					; not finished
.2ec4					_FBExit:
.2ec4	60		rts				rts
.2ec5					_FBFixGotoGosub:
.2ec5					_FBFixRestore:
.2ec5	a0 01		ldy #$01			ldy 	#1							; line number in YA
.2ec7	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ec9	48		pha				pha
.2eca	c8		iny				iny
.2ecb	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ecd	a8		tay				tay
.2ece	68		pla				pla
.2ecf	20 96 35	jsr $3596			jsr 	STRFindLine			 		; find where it is YA
.2ed2	90 0c		bcc $2ee0			bcc 	_FBFFound 					; not found, so must be >
.2ed4	48		pha				pha
.2ed5	b2 2a		lda ($2a)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.2ed7	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_Z 			; or RESTORE. These go to the next line
.2ed9	f0 04		beq $2edf			beq 	_FBFAllowZero 				; after ; for IF forward scanning, and
.2edb	c9 d6		cmp #$d6			cmp 	#PCD_CMD_RESTORE 			; because RESTORE <n> <n> is optional.
.2edd	d0 0f		bne $2eee			bne 	_FBFFail
.2edf					_FBFAllowZero:
.2edf	68		pla				pla
.2ee0					_FBFFound:
.2ee0	20 e6 35	jsr $35e6			jsr 	STRMakeOffset 				; make it an offset from X:YA
.2ee3	5a		phy				phy	 								; patch the GOTO/GOSUB
.2ee4	a0 01		ldy #$01			ldy 	#1
.2ee6	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ee8	c8		iny				iny
.2ee9	68		pla				pla
.2eea	91 2a		sta ($2a),y			sta 	(objPtr),y
.2eec	80 d1		bra $2ebf			bra 	_FBNext
.2eee					_FBFFail:
.2eee	a0 02		ldy #$02			ldy 	#2
.2ef0	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ef2	8d ba 05	sta $05ba			sta 	currentLineNumber
.2ef5	c8		iny				iny
.2ef6	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ef8	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2efb	4c 90 1f	jmp $1f90		jmp	ErrorV_line
.2efe					_FBFixVarSpace:
.2efe	a0 01		ldy #$01			ldy 	#1
.2f00	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2f03	91 2a		sta ($2a),y			sta 	(objPtr),y
.2f05	c8		iny				iny
.2f06	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2f09	91 2a		sta ($2a),y			sta 	(objPtr),y
.2f0b	80 b2		bra $2ebf			bra 	_FBNext
.2f0d					CommandFOR:
.2f0d	20 ff 33	jsr $33ff			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.2f10	20 15 34	jsr $3415			jsr 	CharIsAlpha 				; if not alpha , error
.2f13	90 59		bcc $2f6e			bcc 	_CFFail
.2f15	20 40 37	jsr $3740			jsr 	GetReferenceTerm 			; figure out the reference.
.2f18	48		pha				pha 								; save type
.2f19	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f1b	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f1d	d0 4f		bne $2f6e			bne 	_CFFail
.2f1f	5a		phy				phy 								; save reference on the stack
.2f20	da		phx				phx
.2f21	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.2f23	20 dc 2a	jsr $2adc			jsr 	CheckNextA
.2f26	20 8a 2d	jsr $2d8a			jsr 	CompileExpressionAt0 		; initial value
.2f29	fa		plx				plx 								; get reference back.
.2f2a	7a		ply				ply
.2f2b	5a		phy				phy
.2f2c	da		phx				phx
.2f2d	38		sec				sec 								; set initial value.
.2f2e	20 f2 36	jsr $36f2			jsr 	GetSetVariable
.2f31	fa		plx				plx
.2f32	7a		ply				ply
.2f33	68		pla				pla
.2f34	29 20		and #$20			and 	#NSSIInt16
.2f36	f0 04		beq $2f3c			beq 	_CFNotInt16
.2f38	98		tya				tya
.2f39	09 80		ora #$80			ora 	#$80
.2f3b	a8		tay				tay
.2f3c					_CFNotInt16:
.2f3c	8a		txa				txa 								; reference in YA
.2f3d	20 8a 2b	jsr $2b8a			jsr 	PushIntegerYA
.2f40	a9 a4		lda #$a4			lda 	#C64_TO
.2f42	20 dc 2a	jsr $2adc			jsr 	CheckNextA
.2f45	20 8a 2d	jsr $2d8a			jsr 	CompileExpressionAt0 		; terminal value
.2f48	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f4a	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f4c	d0 20		bne $2f6e			bne 	_CFFail
.2f4e	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; followed by STEP
.2f51	c9 a9		cmp #$a9			cmp 	#C64_STEP
.2f53	d0 0e		bne $2f63			bne 	_CFNoStep
.2f55	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume it.
.2f58	20 8a 2d	jsr $2d8a			jsr 	CompileExpressionAt0 		; terminal value
.2f5b	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f5d	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f5f	d0 0d		bne $2f6e			bne 	_CFFail
.2f61	80 05		bra $2f68			bra 	_CFParametersDone
.2f63					_CFNoStep:
.2f63	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.2f65	20 9d 2b	jsr $2b9d			jsr 	PushIntegerA
.2f68					_CFParametersDone:
.2f68	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2f6a	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2f6d	60		rts				rts
.2f6e					_CFFail:
.2f6e	4c 4d 1f	jmp $1f4d		jmp	ErrorV_syntax
.2f71					FNCompile:
.2f71	20 ff 33	jsr $33ff			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2f74	20 64 34	jsr $3464			jsr 	ExtractVariableName
.2f77	e0 00		cpx #$00			cpx 	#0
.2f79	10 32		bpl $2fad			bpl 	_FNError
.2f7b	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2f7c	29 7f		and #$7f			and 	#$7F
.2f7e	aa		tax				tax
.2f7f	98		tya				tya
.2f80	09 80		ora #$80			ora 	#$80
.2f82	a8		tay				tay
.2f83	20 44 2e	jsr $2e44			jsr 	FindVariable				; does it already exist ?
.2f86	90 25		bcc $2fad			bcc 	_FNError 					; no.
.2f88	20 e6 35	jsr $35e6			jsr 	STRMakeOffset 				; convert to a relative address.
.2f8b	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2f8d	d0 01		bne $2f90			bne 	_FNNoBorrow
.2f8f	88		dey				dey
.2f90					_FNNoBorrow:
.2f90	3a		dec a				dec 	a
.2f91	5a		phy				phy 								; save location of routine on stack.
.2f92	48		pha				pha
.2f93	da		phx				phx
.2f94	20 8a 2d	jsr $2d8a			jsr 	CompileExpressionAt0
.2f97	20 d6 2a	jsr $2ad6			jsr 	CheckNextRParen
.2f9a	a9 d2		lda #$d2			lda 	#PCD_CMD_GOSUB
.2f9c	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2f9f	68		pla				pla
.2fa0	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2fa3	68		pla				pla
.2fa4	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2fa7	68		pla				pla
.2fa8	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.2fab	18		clc				clc
.2fac	60		rts				rts
.2fad					_FNError:
.2fad	4c 40 1f	jmp $1f40		jmp	ErrorV_value
.2fb0					CommandTables:
>2fb0	07 cb 00 03 c2 34 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2fb7	07 89 00 03 c9 34 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2fbe	07 8d 00 03 bc 34 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>2fc5	07 8c 00 03 ab 37 06			.byte	$07,$8c,$00,$03,CommandRESTORE & $FF,CommandRESTORE >> 8,$06
>2fcc	07 88 00 03 38 35 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2fd3	07 85 00 03 18 35 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>2fda	07 84 00 04 2c 35 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>2fe1	07 99 00 03 6d 36 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2fe8	07 98 00 04 6d 36 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2fef	07 8f 00 03 78 37 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>2ff6	07 81 00 03 0d 2f 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>2ffd	07 82 00 03 f0 35 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>3004	07 a1 00 03 35 34 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>300b	07 83 00 03 40 2c 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>3012	07 87 00 03 b6 36 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>3019	07 86 00 03 d3 2c 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>3020	07 96 00 03 5c 2c 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>3027	07 8b 00 e3 e5 34 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>302e	08 92 00 ea e3 63 38 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>3036	09 91 00 e1 a9 03 1c 36			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>303e	06
>303f	07 9e 00 e2 cb 92 06			.byte	$07,$9e,$00,$e2,37579 & $FF,37579 >> 8,$06
>3046	07 97 00 ea e1 ad 06			.byte	$07,$97,$00,$ea,$e1,173,$06
>304d	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>3053	07 90 00 20 cb 91 06			.byte	$07,$90,$00,$20,37323 & $FF,37323 >> 8,$06
>305a	07 80 00 20 cb 82 06			.byte	$07,$80,$00,$20,33483 & $FF,33483 >> 8,$06
>3061	07 9d 00 e3 89 38 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>3068	0a 9f 00 ea e3 9c 38 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,199,$06
>3070	c7 06
>3072	06 a0 00 e1 c4 06			.byte	$06,$a0,$00,$e1,196,$06
>3078	07 ce 90 20 cb ac 06			.byte	$07,$ce,$90,$20,44235 & $FF,44235 >> 8,$06
>307f	0a ce 92 e3 b2 33 20 cb			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44491 & $FF,44491 >> 8,$06
>3087	ad 06
>3089	0a ce 8d e3 b2 33 20 cb			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44747 & $FF,44747 >> 8,$06
>3091	ae 06
>3093	06 ce 86 e1 c8 06			.byte	$06,$ce,$86,$e1,200,$06
>3099	08 ce 84 ea ea e1 c9 06			.byte	$08,$ce,$84,$ea,$ea,$e1,201,$06
>30a1	07 ce af e2 cb 98 06			.byte	$07,$ce,$af,$e2,39115 & $FF,39115 >> 8,$06
>30a8	07 ce 8c e2 cb 8c 06			.byte	$07,$ce,$8c,$e2,36043 & $FF,36043 >> 8,$06
>30af	09 ce ae ea ea e2 cb 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38347 & $FF,38347 >> 8,$06
>30b7	06
>30b8	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>30c0	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>30c8	9a 06
>30ca	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>30d2	9b 06
>30d4	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>30dc	9c 06
>30de	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>30e6	06
>30e7	07 ce 99 20 cb 99 06			.byte	$07,$ce,$99,$20,39371 & $FF,39371 >> 8,$06
>30ee	08 ce 9a ea e2 cb 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39627 & $FF,39627 >> 8,$06
>30f6	08 ce 9b ea e2 cb 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39883 & $FF,39883 >> 8,$06
>30fe	08 ce 9c ea e2 cb 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40139 & $FF,40139 >> 8,$06
>3106	08 ce 9d ea e2 cb 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40395 & $FF,40395 >> 8,$06
>310e	08 ce 9e ea e2 cb 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40651 & $FF,40651 >> 8,$06
>3116	08 ce 9f ea e2 cb 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40907 & $FF,40907 >> 8,$06
>311e	08 ce a0 ea e2 cb a0 06			.byte	$08,$ce,$a0,$ea,$e2,41163 & $FF,41163 >> 8,$06
>3126	08 ce a1 ea f2 cb a1 06			.byte	$08,$ce,$a1,$ea,$f2,41419 & $FF,41419 >> 8,$06
>312e	08 ce a2 ea f2 cb a2 06			.byte	$08,$ce,$a2,$ea,$f2,41675 & $FF,41675 >> 8,$06
>3136	08 ce a3 ea e2 cb a3 06			.byte	$08,$ce,$a3,$ea,$e2,41931 & $FF,41931 >> 8,$06
>313e	07 ce a4 20 cb a4 06			.byte	$07,$ce,$a4,$20,42187 & $FF,42187 >> 8,$06
>3145	08 ce a5 ea e2 cb a5 06			.byte	$08,$ce,$a5,$ea,$e2,42443 & $FF,42443 >> 8,$06
>314d	08 ce a6 ea e2 cb a6 06			.byte	$08,$ce,$a6,$ea,$e2,42699 & $FF,42699 >> 8,$06
>3155	08 ce a7 ea e2 cb a7 06			.byte	$08,$ce,$a7,$ea,$e2,42955 & $FF,42955 >> 8,$06
>315d	08 ce a8 ea e2 cb a8 06			.byte	$08,$ce,$a8,$ea,$e2,43211 & $FF,43211 >> 8,$06
>3165	08 ce a9 ea e2 cb a9 06			.byte	$08,$ce,$a9,$ea,$e2,43467 & $FF,43467 >> 8,$06
>316d	08 ce aa ea f2 cb aa 06			.byte	$08,$ce,$aa,$ea,$f2,43723 & $FF,43723 >> 8,$06
>3175	08 ce ab ea f2 cb ab 06			.byte	$08,$ce,$ab,$ea,$f2,43979 & $FF,43979 >> 8,$06
>317d	00						.byte 	0
.317e					UnaryTables:
>317e	07 b4 00 8e 91 b7 06			.byte	$07,$b4,$00,$8e,$91,183,$06
>3185	08 b5 00 8e 92 cb 84 06			.byte	$08,$b5,$00,$8e,$92,33995 & $FF,33995 >> 8,$06
>318d	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>3194	07 b7 00 8e 91 c2 06			.byte	$07,$b7,$00,$8e,$91,194,$06
>319b	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>31a2	07 b9 00 8e 91 ae 06			.byte	$07,$b9,$00,$8e,$91,174,$06
>31a9	08 ba 00 8e 92 cb 85 06			.byte	$08,$ba,$00,$8e,$92,34251 & $FF,34251 >> 8,$06
>31b1	07 bb 00 8e 91 b5 06			.byte	$07,$bb,$00,$8e,$91,181,$06
>31b8	08 bc 00 8e 92 cb 86 06			.byte	$08,$bc,$00,$8e,$92,34507 & $FF,34507 >> 8,$06
>31c0	08 bd 00 8e 92 cb 87 06			.byte	$08,$bd,$00,$8e,$92,34763 & $FF,34763 >> 8,$06
>31c8	08 be 00 8e 92 cb 88 06			.byte	$08,$be,$00,$8e,$92,35019 & $FF,35019 >> 8,$06
>31d0	08 bf 00 8e 92 cb 89 06			.byte	$08,$bf,$00,$8e,$92,35275 & $FF,35275 >> 8,$06
>31d8	08 c0 00 8e 92 cb 8a 06			.byte	$08,$c0,$00,$8e,$92,35531 & $FF,35531 >> 8,$06
>31e0	08 c1 00 8e 92 cb 8b 06			.byte	$08,$c1,$00,$8e,$92,35787 & $FF,35787 >> 8,$06
>31e8	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>31ef	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>31f6	07 c4 00 8e 91 bb 07			.byte	$07,$c4,$00,$8e,$91,187,$07
>31fd	07 c5 00 8f 91 c3 06			.byte	$07,$c5,$00,$8f,$91,195,$06
>3204	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>320b	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>3212	08 c8 00 8f ae 91 bc 07			.byte	$08,$c8,$00,$8f,$ae,$91,188,$07
>321a	08 c9 00 8f ae 91 bd 07			.byte	$08,$c9,$00,$8f,$ae,$91,189,$07
>3222	0b ca 00 8f ae 03 b2 33			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,190,$07
>322a	91 be 07
>322d	07 a8 00 03 d1 33 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>3234	07 a5 00 03 71 2f 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>323b	06 ff 00 10 ac 06			.byte	$06,$ff,$00,$10,172,$06
>3241	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>3248	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>324f	08 ce d0 8e ae 91 ca 06			.byte	$08,$ce,$d0,$8e,$ae,$91,202,$06
>3257	08 ce d4 8e 92 cb 83 06			.byte	$08,$ce,$d4,$8e,$92,33739 & $FF,33739 >> 8,$06
>325f	07 ce d3 20 cb 8d 06			.byte	$07,$ce,$d3,$20,36299 & $FF,36299 >> 8,$06
>3266	07 ce d1 20 cb 8e 06			.byte	$07,$ce,$d1,$20,36555 & $FF,36555 >> 8,$06
>326d	07 ce d2 20 cb 8f 06			.byte	$07,$ce,$d2,$20,36811 & $FF,36811 >> 8,$06
>3274	07 ce db 20 cb 90 06			.byte	$07,$ce,$db,$20,37067 & $FF,37067 >> 8,$06
>327b	09 ce d7 8e ae 92 cb 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38603 & $FF,38603 >> 8,$06
>3283	06
>3284	00						.byte 	0
.3285					GeneratorProcess:
.3285	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.3287	84 2d		sty $2d				sty 	zTemp0+1
.3289	85 2e		sta $2e				sta 	zTemp1 						; first match token
.328b	64 2f		stz $2f				stz 	zTemp1+1
.328d	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.328f	d0 05		bne $3296			bne 	_GPNotShifted
.3291	20 f4 33	jsr $33f4			jsr 	GetNext 					; get the shifted token
.3294	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.3296					_GPNotShifted:
.3296					_GPSearch:
.3296	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.3298	18		clc				clc
.3299	f0 2f		beq $32ca			beq 	_GPExit
.329b	a0 01		ldy #$01			ldy 	#1 							; tokens match
.329d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.329f	c5 2e		cmp $2e				cmp 	zTemp1
.32a1	d0 09		bne $32ac			bne 	_GPNext
.32a3	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.32a5	f0 12		beq $32b9			beq 	_GPFound
.32a7	c8		iny				iny 								; check match.
.32a8	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.32aa	f0 0d		beq $32b9			beq 	_GPFound
.32ac					_GPNext:
.32ac	18		clc				clc 								; follow to next
.32ad	a5 2c		lda $2c				lda 	zTemp0
.32af	72 2c		adc ($2c)			adc 	(zTemp0)
.32b1	85 2c		sta $2c				sta 	zTemp0
.32b3	90 e1		bcc $3296			bcc 	_GPSearch
.32b5	e6 2d		inc $2d				inc 	zTemp0+1
.32b7	80 dd		bra $3296			bra 	_GPSearch
.32b9					_GPFound:
.32b9	18		clc				clc 								; skip to action bytes
.32ba	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.32bc	69 03		adc #$03			adc 	#3
.32be	85 2c		sta $2c				sta 	zTemp0
.32c0	90 02		bcc $32c4			bcc 	_GPNoCarry
.32c2	e6 2d		inc $2d				inc 	zTemp0+1
.32c4					_GPNoCarry:
.32c4					_GPLoop:
.32c4	20 cb 32	jsr $32cb			jsr 	GeneratorExecute 			; execute one command
.32c7	90 fb		bcc $32c4			bcc 	_GPLoop 					; go back if not completed.
.32c9	38		sec				sec 								; return with CS.
.32ca					_GPExit:
.32ca	60		rts				rts
.32cb					GeneratorExecute:
.32cb	20 77 33	jsr $3377			jsr 	_GEFetchZTemp0 				; get next.
.32ce	48		pha				pha 								; split into 2 nibbles
.32cf	4a		lsr a				lsr 	a
.32d0	4a		lsr a				lsr 	a
.32d1	4a		lsr a				lsr		a
.32d2	4a		lsr a				lsr 	a
.32d3	20 dd 32	jsr $32dd			jsr 	_GEExecuteNibble 			; MSB first
.32d6	68		pla				pla
.32d7	b0 03		bcs $32dc			bcs 	_GEHaveCompleted
.32d9	20 dd 32	jsr $32dd			jsr 	_GEExecuteNibble 			; LSB second
.32dc					_GEHaveCompleted:
.32dc	60		rts				rts
.32dd					_GEExecuteNibble:
.32dd	29 0f		and #$0f			and 	#$0F
.32df	0a		asl a				asl 	a
.32e0	aa		tax				tax
.32e1	7c e4 32	jmp ($32e4,x)			jmp 	(_GEExecuteVectors,x)
.32e4					_GEExecuteVectors:
>32e4	04 33						.word 	_GEXNop 					; 0  (no operation)
>32e6	0c 33						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>32e8	06 33						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>32ea	5a 33						.word 	_GEXExecute 				; 3  (run arbitrary code)
>32ec	4d 33						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>32ee	04 33						.word 	_GEXNop 					; 5
>32f0	14 33						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>32f2	18 33						.word 	_GEXExitString 				; 7  exit return string type
>32f4	1c 33						.word 	_GEXLParam 					; 8  check ( follows
>32f6	20 33						.word 	_GEXRParam 					; 9  check ) follows
>32f8	24 33						.word 	_GEXComma					; A  check , follows
>32fa	04 33						.word 	_GEXNop 					; B
>32fc	04 33						.word 	_GEXNop 					; C
>32fe	04 33						.word 	_GEXNop 					; D
>3300	34 33						.word 	_GEXNumber 					; E  compile get any number
>3302	3f 33						.word 	_GEXString 					; F  compile get any string
.3304					_GEXNop:
.3304	18		clc				clc
.3305	60		rts				rts
.3306					_GEXToken2:
.3306	20 77 33	jsr $3377			jsr 	_GEFetchZTemp0
.3309	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.330c					_GEXToken1:
.330c	20 77 33	jsr $3377			jsr 	_GEFetchZTemp0
.330f	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3312	18		clc				clc
.3313	60		rts				rts
.3314					_GEXExitNumber:
.3314	a9 00		lda #$00			lda 	#NSSIFloat
.3316	38		sec				sec
.3317	60		rts				rts
.3318					_GEXExitString:
.3318	a9 40		lda #$40			lda 	#NSSString
.331a	38		sec				sec
.331b	60		rts				rts
.331c					_GEXLParam:
.331c	a9 28		lda #$28			lda 	#"("
.331e	80 06		bra $3326			bra 	_GEXCheck
.3320					_GEXRParam:
.3320	a9 29		lda #$29			lda 	#")"
.3322	80 02		bra $3326			bra 	_GEXCheck
.3324					_GEXComma:
.3324	a9 2c		lda #$2c			lda 	#","
.3326					_GEXCheck:
.3326	85 30		sta $30				sta 	zTemp2 						; save match
.3328	20 ff 33	jsr $33ff			jsr 	GetNextNonSpace 			; get next skipping spaces
.332b	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.332d	d0 02		bne $3331			bne 	_GEXSyntax
.332f	18		clc				clc
.3330	60		rts				rts
.3331					_GEXSyntax:
.3331	4c 4d 1f	jmp $1f4d		jmp	ErrorV_syntax
.3334					_GEXNumber:
.3334	20 80 33	jsr $3380			jsr 	GEXCompileExpression 		; compile expression
.3337	29 40		and #$40			and 	#NSSTypeMask
.3339	c9 00		cmp #$00			cmp  	#NSSIFloat
.333b	d0 0d		bne $334a			bne 	_GEXType
.333d	18		clc				clc
.333e	60		rts				rts
.333f					_GEXString:
.333f	20 80 33	jsr $3380			jsr 	GEXCompileExpression 		; compile expression
.3342	29 40		and #$40			and 	#NSSTypeMask
.3344	c9 40		cmp #$40			cmp  	#NSSString
.3346	d0 02		bne $334a			bne 	_GEXType
.3348	18		clc				clc
.3349	60		rts				rts
.334a					_GEXType:
.334a	4c 5d 1f	jmp $1f5d		jmp	ErrorV_type
.334d					_GEXChannelExec:
.334d	20 90 33	jsr $3390			jsr 	ChannelPrefix 				; set up default
.3350	20 5a 33	jsr $335a			jsr 	_GEXExecute
.3353	08		php				php
.3354	20 ab 33	jsr $33ab			jsr 	ChannelPostfix 				; replace default.
.3357	28		plp				plp
.3358	60		rts				rts
>3359	db						.byte 	$DB 						; causes a break in the emulator
.335a					_GEXExecute:
.335a	20 77 33	jsr $3377			jsr 	_GEFetchZTemp0 				; get vector
.335d	85 30		sta $30				sta 	zTemp2
.335f	20 77 33	jsr $3377			jsr 	_GEFetchZTemp0
.3362	85 31		sta $31				sta 	zTemp2+1
.3364	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.3366	da		phx				phx
.3367	a6 2d		ldx $2d				ldx 	zTemp0+1
.3369	da		phx				phx
.336a	20 74 33	jsr $3374			jsr 	_GECallZTemp2 				; execute code
.336d	fa		plx				plx 								; recover generation exec
.336e	86 2d		stx $2d				stx 	zTemp0+1
.3370	fa		plx				plx
.3371	86 2c		stx $2c				stx 	zTemp0
.3373	60		rts				rts
.3374					_GECallZTemp2:
.3374	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.3377					_GEFetchZTemp0:
.3377	b2 2c		lda ($2c)			lda 	(zTemp0)
.3379	e6 2c		inc $2c				inc 	zTemp0
.337b	d0 02		bne $337f			bne 	_GEFZ0Skip
.337d	e6 2d		inc $2d				inc 	zTemp0+1
.337f					_GEFZ0Skip:
.337f	60		rts				rts
.3380					GEXCompileExpression:
.3380	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.3382	da		phx				phx
.3383	a6 2d		ldx $2d				ldx 	zTemp0+1
.3385	da		phx				phx
.3386	20 8a 2d	jsr $2d8a			jsr 	CompileExpressionAt0 		; compile expression.
.3389	fa		plx				plx 								; recover generation exec
.338a	86 2d		stx $2d				stx 	zTemp0+1
.338c	fa		plx				plx
.338d	86 2c		stx $2c				stx 	zTemp0
.338f	60		rts				rts
.3390					ChannelPrefix:
.3390	a9 af		lda #$af			lda 	#PCD_GETCHANNEL				; set channel onto stack
.3392	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3395	20 80 33	jsr $3380			jsr 	GEXCompileExpression 		; channel #
.3398	29 40		and #$40			and 	#NSSTypeMask
.339a	c9 00		cmp #$00			cmp 	#NSSIFloat
.339c	d0 0a		bne $33a8			bne 	_CPXType
.339e	20 d2 2a	jsr $2ad2			jsr 	CheckNextComma 				; check , follows.
.33a1	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL				; set channel
.33a3	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.33a6	18		clc				clc
.33a7	60		rts				rts
.33a8					_CPXType:
.33a8	4c 5d 1f	jmp $1f5d		jmp	ErrorV_type
.33ab					ChannelPostfix:
.33ab	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.33ad	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.33b0	18		clc				clc
.33b1	60		rts				rts
.33b2					OptionalParameterCompile:
.33b2	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; what follows.
.33b5	c9 2c		cmp #$2c			cmp 	#","
.33b7	d0 0e		bne $33c7			bne 	_MidDefault
.33b9	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume ,
.33bc	20 8a 2d	jsr $2d8a			jsr 	CompileExpressionAt0
.33bf	29 40		and #$40			and 	#NSSTypeMask
.33c1	c9 00		cmp #$00			cmp 	#NSSIFloat
.33c3	d0 09		bne $33ce			bne 	MidFailType
.33c5	80 05		bra $33cc			bra 	_MidComplete
.33c7					_MidDefault:
.33c7	a9 ff		lda #$ff			lda 	#255 						; default of 255
.33c9	20 9d 2b	jsr $2b9d			jsr 	PushIntegerA
.33cc					_MidComplete:
.33cc	18		clc				clc
.33cd	60		rts				rts
.33ce					MidFailType:
.33ce	4c 5d 1f	jmp $1f5d		jmp	ErrorV_type
.33d1					NotUnaryCompile:
.33d1	ad 3f 2e	lda $2e3f			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.33d4	20 8c 2d	jsr $2d8c			jsr 	CompileExpressionAtA 		; evaluate at that level
.33d7	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.33d9	c9 00		cmp #$00			cmp 	#NSSIFloat
.33db	d0 f1		bne $33ce			bne 	MidFailType
.33dd	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.33df	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.33e2	60		rts				rts
.33e3					LookNext:
.33e3	b2 7a		lda ($7a)			lda 	(srcPtr)
.33e5	60		rts				rts
.33e6					LookNextNonSpace:
.33e6	b2 7a		lda ($7a)			lda 	(srcPtr)
.33e8	c9 20		cmp #$20			cmp		#' '
.33ea	f0 03		beq $33ef			beq 	_LNNSkip
.33ec	c9 00		cmp #$00			cmp 	#0
.33ee	60		rts				rts
.33ef					_LNNSkip:
.33ef	20 f4 33	jsr $33f4			jsr 	GetNext
.33f2	80 f2		bra $33e6			bra 	LookNextNonSpace
.33f4					GetNext:
.33f4	b2 7a		lda ($7a)			lda 	(srcPtr) 					; get next
.33f6	e6 7a		inc $7a				inc 	srcPtr
.33f8	d0 02		bne $33fc			bne 	_GNSkip
.33fa	e6 7b		inc $7b				inc 	srcPtr+1
.33fc					_GNSkip:
.33fc	c9 00		cmp #$00			cmp 	#0
.33fe	60		rts				rts
.33ff					GetNextNonSpace:
.33ff	20 f4 33	jsr $33f4			jsr 	GetNext
.3402	c9 20		cmp #$20			cmp 	#' '
.3404	f0 f9		beq $33ff			beq 	GetNextNonSpace
.3406	c9 00		cmp #$00			cmp 	#0
.3408	60		rts				rts
.3409					CharIsDigit:
.3409	c9 30		cmp #$30			cmp 	#"0"
.340b	90 06		bcc $3413			bcc 	CCFalse
.340d	c9 3a		cmp #$3a			cmp 	#"9"+1
.340f	b0 02		bcs $3413			bcs 	CCFalse
.3411					CCTrue:
.3411	38		sec				sec
.3412	60		rts				rts
.3413					CCFalse:
.3413	18		clc				clc
.3414	60		rts				rts
.3415					CharIsAlpha:
.3415	c9 41		cmp #$41			cmp 	#"A"
.3417	90 fa		bcc $3413			bcc 	CCFalse
.3419	c9 5b		cmp #$5b			cmp 	#"Z"+1
.341b	b0 f6		bcs $3413			bcs 	CCFalse
.341d	80 f2		bra $3411			bra 	CCTrue
.341f					ConvertHexStyle:
.341f	38		sec				sec
.3420	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.3422	90 ef		bcc $3413			bcc 	CCFalse
.3424	c9 0a		cmp #$0a			cmp 	#9+1
.3426	90 e9		bcc $3411			bcc 	CCTrue
.3428	38		sec				sec 								; shift into hex space A=>0 Z=>25
.3429	e9 11		sbc #$11			sbc 	#"A"-"0"
.342b	90 e6		bcc $3413			bcc 	CCFalse
.342d	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.342f	b0 e2		bcs $3413			bcs 	CCFalse
.3431	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.3433	80 dc		bra $3411			bra 	CCTrue
.3435					CommandGET:
.3435	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; # follows ?
.3438	c9 23		cmp #$23			cmp 	#"#"
.343a	d0 0d		bne $3449			bne 	CommandGetBody
.343c	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume #
.343f	20 90 33	jsr $3390			jsr 	ChannelPrefix 				; do it as GET#
.3442	20 49 34	jsr $3449			jsr 	CommandGetBody
.3445	20 ab 33	jsr $33ab			jsr 	ChannelPostfix
.3448	60		rts				rts
.3449					CommandGetBody:
.3449	20 ff 33	jsr $33ff			jsr 	GetNextNonSpace 			; get the first character
.344c	20 40 37	jsr $3740			jsr 	GetReferenceTerm 			; identify variable to assign to
.344f	48		pha				pha
.3450	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.3452	c9 40		cmp #$40			cmp 	#NSSString
.3454	d0 0b		bne $3461			bne 	_CGType
.3456	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.3458	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.345b	38		sec				sec
.345c	68		pla				pla
.345d	20 f2 36	jsr $36f2			jsr		GetSetVariable
.3460	60		rts				rts
.3461					_CGType:
.3461	4c 5d 1f	jmp $1f5d		jmp	ErrorV_type
.3464					ExtractVariableName:
.3464	20 15 34	jsr $3415			jsr 	CharIsAlpha
.3467	90 50		bcc $34b9			bcc 	_IVSyntax
.3469	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.346b	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.346d	64 2f		stz $2f				stz 	zTemp1+1
.346f	20 e3 33	jsr $33e3			jsr 	LookNext 					; is there a second character ?
.3472	20 15 34	jsr $3415			jsr 	CharIsAlpha  				; must be alphanumeric
.3475	b0 05		bcs $347c			bcs 	_IVHasSecond
.3477	20 09 34	jsr $3409			jsr 	CharIsDigit
.347a	90 07		bcc $3483			bcc 	_IVCheckType
.347c					_IVHasSecond:
.347c	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.347e	85 2f		sta $2f				sta 	zTemp1+1
.3480					_IVGetNextCheck:
.3480	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume it
.3483					_IVCheckType:
.3483	20 e3 33	jsr $33e3			jsr 	LookNext					; check if string follows.
.3486	20 15 34	jsr $3415			jsr 	CharIsAlpha
.3489	b0 f5		bcs $3480			bcs 	_IVGetNextCheck
.348b	20 09 34	jsr $3409			jsr 	CharIsDigit
.348e	b0 f0		bcs $3480			bcs 	_IVGetNextCheck
.3490	a2 40		ldx #$40			ldx 	#NSSString
.3492	c9 24		cmp #$24			cmp 	#"$"
.3494	f0 06		beq $349c			beq 	_IVHasType
.3496	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.3498	c9 25		cmp #$25			cmp 	#"%"
.349a	d0 08		bne $34a4			bne 	_IVCheckArray
.349c					_IVHasType:
.349c	8a		txa				txa 								; Or X into zTemp1
.349d	05 2e		ora $2e				ora 	zTemp1
.349f	85 2e		sta $2e				sta 	zTemp1
.34a1	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume it
.34a4					_IVCheckArray:
.34a4	20 e3 33	jsr $33e3			jsr 	LookNext 					; check if array follows
.34a7	c9 28		cmp #$28			cmp 	#"("
.34a9	d0 09		bne $34b4			bne 	_IVNotArray
.34ab	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.34ad	09 80		ora #$80			ora 	#NSSArray
.34af	85 2e		sta $2e				sta 	zTemp1
.34b1	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume it
.34b4					_IVNotArray:
.34b4	a6 2e		ldx $2e				ldx 	zTemp1
.34b6	a4 2f		ldy $2f				ldy 	zTemp1+1
.34b8	60		rts				rts
.34b9					_IVSyntax:
.34b9	4c 4d 1f	jmp $1f4d		jmp	ErrorV_syntax
.34bc					CommandGOSUB:
.34bc	a9 d2		lda #$d2			lda 	#PCD_CMD_GOSUB
.34be	20 cf 34	jsr $34cf			jsr 	CompileBranchCommand
.34c1	60		rts				rts
.34c2					CommandGOAlt:
.34c2	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.34c4	20 dc 2a	jsr $2adc			jsr 	CheckNextA
.34c7	80 00		bra $34c9			bra 	CommandGOTO
.34c9					CommandGOTO:
.34c9	a9 d1		lda #$d1			lda 	#PCD_CMD_GOTO
.34cb	20 cf 34	jsr $34cf			jsr 	CompileBranchCommand
.34ce	60		rts				rts
.34cf					CompileBranchCommand:
.34cf	20 74 2a	jsr $2a74			jsr 	WriteCodeByte 				; write the command out.
.34d2	20 ff 33	jsr $33ff			jsr 	GetNextNonSpace
.34d5	20 48 36	jsr $3648			jsr 	ParseConstant 				; get constant into YA
.34d8	90 08		bcc $34e2			bcc 	_CBCSyntax
.34da	20 74 2a	jsr $2a74			jsr 	WriteCodeByte				; and compile the actual line number
.34dd	98		tya				tya
.34de	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.34e1	60		rts				rts
.34e2					_CBCSyntax:
.34e2	4c 4d 1f	jmp $1f4d		jmp	ErrorV_syntax
.34e5					CommandIF:
.34e5	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; what follows the tests ?
.34e8	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.34ea	f0 0f		beq $34fb			beq 	_CIGoto
.34ec	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.34ee	20 dc 2a	jsr $2adc			jsr 	CheckNextA
.34f1	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; THEN <number>
.34f4	20 09 34	jsr $3409			jsr 	CharIsDigit
.34f7	b0 05		bcs $34fe			bcs 	_CIGoto2
.34f9	80 09		bra $3504			bra 	CompileGotoEOL
.34fb					_CIGoto:
.34fb	20 f4 33	jsr $33f4			jsr 	GetNext
.34fe					_CIGoto2:
.34fe	a9 d4		lda #$d4			lda 	#PCD_CMD_GOTOCMD_NZ
.3500	20 cf 34	jsr $34cf			jsr 	CompileBranchCommand
.3503	60		rts				rts
.3504					CompileGotoEOL:
.3504	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_Z
.3506	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3509	20 6d 2a	jsr $2a6d			jsr 	GetLineNumber 				; Get the current line number => YA
.350c	1a		inc a				inc 	a 							; and branch to +1
.350d	d0 01		bne $3510			bne 	_CGENoCarry
.350f	c8		iny				iny
.3510					_CGENoCarry:
.3510	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3513	98		tya				tya
.3514	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3517	60		rts				rts
.3518					CommandINPUT:
.3518	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; check for "
.351b	c9 22		cmp #$22			cmp 	#'"'
.351d	d0 0d		bne $352c			bne 	CommandINPUTStream
.351f	20 8a 2d	jsr $2d8a			jsr 	CompileExpressionAt0
.3522	a9 b2		lda #$b2			lda 	#(PCD_PRINTCMD_S) & $FF
.3524	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3527	a9 2c		lda #$2c			lda 	#","
.3529	20 d2 2a	jsr $2ad2			jsr 	CheckNextComma
.352c					CommandINPUTStream:
.352c	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.352e	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3531	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.3533	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.3535	4c ba 36	jmp $36ba			jmp 	CommandReadInputCommon
.3538					CommandLET:
.3538	20 ff 33	jsr $33ff			jsr 	GetNextNonSpace 			; get the first character
.353b					CommandLETHaveFirst:
.353b	20 40 37	jsr $3740			jsr 	GetReferenceTerm 			; identify variable to assign to
.353e	da		phx				phx 								; save target on the stack.
.353f	5a		phy				phy
.3540	48		pha				pha
.3541	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.3543	20 dc 2a	jsr $2adc			jsr 	CheckNextA
.3546	20 8a 2d	jsr $2d8a			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.3549	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.354b	68		pla				pla 								; get type of assignment
.354c	48		pha				pha
.354d	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.354f	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.3551	d0 17		bne $356a			bne 	_CLType
.3553	68		pla				pla 								; restore and compile save code
.3554	7a		ply				ply
.3555	fa		plx				plx
.3556	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.3558	f0 05		beq $355f			beq 	_CLTIString
.355a	38		sec				sec
.355b	20 f2 36	jsr $36f2			jsr		GetSetVariable
.355e	60		rts				rts
.355f					_CLTIString:
.355f	a9 cb		lda #$cb			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.3561	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3564	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.3566	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3569	60		rts				rts
.356a					_CLType:
.356a	4c 5d 1f	jmp $1f5d		jmp	ErrorV_type
.356d					STRMarkLine:
.356d	48		pha				pha
.356e	38		sec				sec 								; allocate 4 bytes (line #,address)
.356f	ad c9 06	lda $06c9			lda 	lineNumberTable 			; and copy to zTemp0
.3572	e9 04		sbc #$04			sbc 	#4
.3574	8d c9 06	sta $06c9			sta 	lineNumberTable
.3577	85 2c		sta $2c				sta 	zTemp0
.3579	ad ca 06	lda $06ca			lda 	lineNumberTable+1
.357c	e9 00		sbc #$00			sbc 	#0
.357e	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.3581	85 2d		sta $2d				sta 	zTemp0+1
.3583	68		pla				pla
.3584	92 2c		sta ($2c)			sta 	(zTemp0) 					; line # save it in +0,+1
.3586	98		tya				tya
.3587	a0 01		ldy #$01			ldy 	#1
.3589	91 2c		sta ($2c),y			sta 	(zTemp0),y
.358b	a5 2a		lda $2a				lda 	objPtr 						; save current address in +2,+3
.358d	c8		iny				iny
.358e	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3590	a5 2b		lda $2b				lda 	objPtr+1
.3592	c8		iny				iny
.3593	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3595	60		rts				rts
.3596					STRFindLine:
.3596	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.3598	84 2d		sty $2d				sty 	zTemp0+1
.359a	ad c2 06	lda $06c2			lda 	compilerEndHigh 			; work backwards through table
.359d	85 2f		sta $2f				sta 	zTemp1+1
.359f	64 2e		stz $2e				stz 	zTemp1
.35a1					_STRSearch:
.35a1	20 d8 35	jsr $35d8			jsr 	_STRPrevLine 				; look at previous record.
.35a4	a0 01		ldy #$01			ldy 	#1
.35a6	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.35a8	c5 2c		cmp $2c				cmp 	zTemp0
.35aa	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.35ac	e5 2d		sbc $2d				sbc 	zTemp0+1
.35ae	b0 0b		bcs $35bb			bcs 	_STRFound 					; >=
.35b0					_STRNext:
.35b0	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.35b2	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.35b4	c9 ff		cmp #$ff			cmp 	#$FF
.35b6	d0 e9		bne $35a1			bne 	_STRSearch
.35b8	4c a7 1f	jmp $1fa7		jmp	ErrorV_internal
.35bb					_STRFound:
.35bb	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.35bd	45 2c		eor $2c				eor 	zTemp0
.35bf	d0 06		bne $35c7			bne 	_STRDifferent
.35c1	b2 2e		lda ($2e)			lda 	(zTemp1)
.35c3	45 2c		eor $2c				eor 	zTemp0
.35c5	f0 02		beq $35c9			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.35c7					_STRDifferent:
.35c7	a9 ff		lda #$ff			lda 	#$FF
.35c9					_STROut:
.35c9	18		clc				clc  								; set carry if different, e.g. > rather than >=
.35ca	69 ff		adc #$ff			adc 	#255
.35cc	08		php				php
.35cd	c8		iny				iny 								; address into YA
.35ce	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.35d0	48		pha				pha
.35d1	c8		iny				iny
.35d2	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.35d4	a8		tay				tay
.35d5	68		pla				pla
.35d6	28		plp				plp
.35d7	60		rts				rts
.35d8					_STRPrevLine:
.35d8	38		sec				sec 								; move backwards one entry.
.35d9	a5 2e		lda $2e				lda 	zTemp1
.35db	e9 04		sbc #$04			sbc 	#4
.35dd	85 2e		sta $2e				sta 	zTemp1
.35df	a5 2f		lda $2f				lda 	zTemp1+1
.35e1	e9 00		sbc #$00			sbc 	#0
.35e3	85 2f		sta $2f				sta 	zTemp1+1
.35e5	60		rts				rts
.35e6					STRMakeOffset:
.35e6	18		clc				clc 								; borrow 1
.35e7	e5 2a		sbc $2a				sbc 	objPtr
.35e9	48		pha				pha
.35ea	98		tya				tya
.35eb	e5 2b		sbc $2b				sbc 	objPtr+1
.35ed	a8		tay				tay
.35ee	68		pla				pla
.35ef	60		rts				rts
.35f0					CommandNEXT:
.35f0	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.35f3	20 15 34	jsr $3415			jsr 	CharIsAlpha 				; if not alpha , error
.35f6	90 0c		bcc $3604			bcc 	_CNNoReferenceGiven
.35f8	20 f4 33	jsr $33f4			jsr 	GetNext
.35fb	20 40 37	jsr $3740			jsr 	GetReferenceTerm 			; figure out the reference.
.35fe	8a		txa				txa 								; reference in YA
.35ff	20 8a 2b	jsr $2b8a			jsr 	PushIntegerYA 				; write it out.
.3602	80 06		bra $360a			bra 	_CNParametersDone
.3604					_CNNoReferenceGiven:
.3604	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.3606	a8		tay				tay
.3607	20 8a 2b	jsr $2b8a			jsr 	PushIntegerYA 				; write it out.
.360a					_CNParametersDone:
.360a	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.360c	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.360f	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; look for ,
.3612	c9 2c		cmp #$2c			cmp 	#","
.3614	d0 05		bne $361b			bne 	_CNExit
.3616	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume ,
.3619	80 d5		bra $35f0			bra 	CommandNEXT 				; and go round.
.361b					_CNExit:
.361b	60		rts				rts
.361c					CommandON:
.361c	20 ff 33	jsr $33ff			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.361f	48		pha				pha 								; save on stack
.3620	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOTO
.3622	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.3624	f0 09		beq $362f			beq 	_COCreateLoop
.3626	a2 d2		ldx #$d2			ldx 	#PCD_CMD_GOSUB
.3628	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.362a	f0 03		beq $362f			beq 	_COCreateLoop
.362c	4c 4d 1f	jmp $1f4d		jmp	ErrorV_syntax
.362f					_COCreateLoop:
.362f	8a		txa				txa 								; compile a goto/gosub somewhere
.3630	da		phx				phx
.3631	20 cf 34	jsr $34cf			jsr 	CompileBranchCommand
.3634	fa		plx				plx
.3635	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace			; ',' follows
.3638	c9 2c		cmp #$2c			cmp 	#","
.363a	d0 0a		bne $3646			bne 	_COComplete 				; if so, more line numbers
.363c	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.363e	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3641	20 f4 33	jsr $33f4			jsr 	GetNext
.3644	80 e9		bra $362f			bra 	_COCreateLoop
.3646					_COComplete:
.3646	68		pla				pla 								; throw GOTO/GOSUB
.3647	60		rts				rts
.3648					ParseConstant:
.3648	a2 00		ldx #$00			ldx 	#0
.364a	20 85 24	jsr $2485			jsr 	FloatEncodeStart 			; send first
.364d					_ParseLoop:
.364d	20 e3 33	jsr $33e3			jsr 	LookNext 					; send subsequent
.3650	20 88 24	jsr $2488			jsr 	FloatEncodeContinue
.3653	90 05		bcc $365a			bcc 	_ParseDone
.3655	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume it
.3658	80 f3		bra $364d			bra 	_ParseLoop
.365a					_ParseDone:
.365a	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.365c	29 80		and #$80			and 	#$80
.365e	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.3660	15 56		ora $56,x			ora 	NSMantissa2,x
.3662	15 62		ora $62,x			ora 	NSMantissa3,x
.3664	18		clc				clc
.3665	d0 05		bne $366c			bne 	_ParseExit 					; exit with CC if need float to compile
.3667	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.3669	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.366b	38		sec				sec
.366c					_ParseExit:
.366c	60		rts				rts
.366d					CommandPRINT:
.366d	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace			; what follows ?
.3670	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.3672	f0 1f		beq $3693			beq 	_CPCheckEnd
.3674	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.3676	f0 16		beq $368e			beq 	_CPTabCheckEnd
.3678	20 aa 36	jsr $36aa			jsr 	_CPAtEnd 					; check for : and EOL
.367b	b0 22		bcs $369f			bcs 	_CPExitCR 					; exit with CR
.367d	20 8a 2d	jsr $2d8a			jsr 	CompileExpressionAt0 		; so it is something to print
.3680	a2 b2		ldx #$b2			ldx 	#PCD_PRINTCMD_S
.3682	29 40		and #$40			and 	#NSSString 					; if string
.3684	d0 02		bne $3688			bne 	_CPOut
.3686	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_N
.3688					_CPOut:
.3688	8a		txa				txa 								; print that thing
.3689	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.368c	80 df		bra $366d			bra 	CommandPRINT 				; and loop round/
.368e					_CPTabCheckEnd:
.368e	a9 b8		lda #$b8			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.3690	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3693					_CPCheckEnd:
.3693	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume it.
.3696	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; what follows ?
.3699	20 aa 36	jsr $36aa			jsr 	_CPAtEnd 					; reached end
.369c	90 cf		bcc $366d			bcc 	CommandPRINT 				; no, loop back
.369e	60		rts				rts
.369f					_CPExitCR:
.369f	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.36a1	20 9d 2b	jsr $2b9d			jsr 	PushIntegerA
.36a4	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.36a6	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.36a9	60		rts				rts
.36aa					_CPAtEnd:
.36aa	c9 00		cmp #$00			cmp 	#0
.36ac	f0 06		beq $36b4			beq 	_CPIsEnd
.36ae	c9 3a		cmp #$3a			cmp 	#":"
.36b0	f0 02		beq $36b4			beq 	_CPIsEnd
.36b2	18		clc				clc
.36b3	60		rts				rts
.36b4					_CPIsEnd:
.36b4	38		sec				sec
.36b5	60		rts				rts
.36b6					CommandREAD:
.36b6	a2 b3		ldx #$b3			ldx 	#PCD_READ
.36b8	a0 b4		ldy #$b4			ldy 	#PCD_READDOLLAR
.36ba					CommandReadInputCommon:
.36ba	8e c7 06	stx $06c7			stx 	numberPCode
.36bd	8c c8 06	sty $06c8			sty 	stringPCode
.36c0					_CRLoop:
.36c0	20 ff 33	jsr $33ff			jsr 	GetNextNonSpace 			; first char of identifier
.36c3	20 15 34	jsr $3415			jsr 	CharIsAlpha 				; check A-Z
.36c6	90 27		bcc $36ef			bcc 	_CRSyntax
.36c8	20 40 37	jsr $3740			jsr 	GetReferenceTerm 			; get the variable.
.36cb	48		pha				pha 								; save type.
.36cc	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.36ce	c9 40		cmp #$40			cmp 	#NSSString
.36d0	f0 05		beq $36d7			beq 	_CRString
.36d2	ad c7 06	lda $06c7			lda 	numberPCode 				; output read/input
.36d5	80 03		bra $36da			bra 	_CRHaveType
.36d7					_CRString:
.36d7	ad c8 06	lda $06c8			lda 	stringPCode					; output read$/input$
.36da					_CRHaveType:
.36da	20 74 2a	jsr $2a74			jsr 	WriteCodeByte 				; so we have one typed data item.
.36dd	68		pla				pla 								; restore type
.36de	38		sec				sec  								; write update code.
.36df	20 f2 36	jsr $36f2			jsr 	GetSetVariable
.36e2	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; , follows ?
.36e5	c9 2c		cmp #$2c			cmp 	#","
.36e7	d0 05		bne $36ee			bne 	_CRExit 					; if not, end of READ.
.36e9	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume comma
.36ec	80 d2		bra $36c0			bra 	_CRLoop 					; keep going
.36ee					_CRExit:
.36ee	60		rts				rts
.36ef					_CRSyntax:
.36ef	4c 4d 1f	jmp $1f4d		jmp	ErrorV_syntax
.06c7					numberPCode:
>06c7							.fill 	1
.06c8					stringPCode:
>06c8							.fill 	1
.36f2					GetSetVariable:
.36f2	08		php				php 								; save direction on stack
.36f3	c0 00		cpy #$00			cpy 	#$00
.36f5	30 21		bmi $3718			bmi 	_GSVReadWriteSpecial
.36f7	c9 00		cmp #$00			cmp 	#$00
.36f9	30 33		bmi $372e			bmi 	_GSVArray
.36fb	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.36fd	4a		lsr a				lsr 	a 							; divide by 2
.36fe	09 40		ora #$40			ora 	#64 						; and set bit 6.
.3700	28		plp				plp
.3701	90 02		bcc $3705			bcc 	_GSVNotWrite
.3703	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.3705					_GSVNotWrite:
.3705	85 2c		sta $2c				sta 	zTemp0
.3707	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.3708	4a		lsr a				lsr 	a
.3709	a8		tay				tay
.370a	8a		txa				txa
.370b	6a		ror a				ror 	a
.370c	aa		tax				tax
.370d	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.370e	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.3710	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3713	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.3714	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3717	60		rts				rts
.3718					_GSVReadWriteSpecial:
.3718	28		plp				plp
.3719	b0 10		bcs $372b			bcs 	_GSVSyntax
.371b	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.371d	f0 06		beq $3725			beq 	_GSVRWString
.371f	a9 c0		lda #$c0			lda 	#(PCD_TI) & $FF
.3721	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3724	60		rts				rts
.3725					_GSVRWString:
.3725	a9 c1		lda #$c1			lda 	#(PCD_TIDOLLAR) & $FF
.3727	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.372a	60		rts				rts
.372b					_GSVSyntax:
.372b	4c 4d 1f	jmp $1f4d		jmp	ErrorV_syntax
.372e					_GSVArray:
.372e	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.3730	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.3731	4a		lsr a				lsr 	a
.3732	4a		lsr a				lsr 	a
.3733	4a		lsr a				lsr 	a
.3734	4a		lsr a				lsr 	a
.3735	28		plp				plp 								; if writing array then set bit 2.
.3736	90 02		bcc $373a			bcc 	_GSVANotWrite
.3738	09 04		ora #$04			ora 	#4
.373a					_GSVANotWrite:
.373a	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.373c	20 74 2a	jsr $2a74			jsr 	WriteCodeByte 				; and write it out
.373f	60		rts				rts
.3740					GetReferenceTerm:
.3740	20 64 34	jsr $3464			jsr 	ExtractVariableName 		; get name & type info
.3743	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.3745	30 10		bmi $3757			bmi 	_GRTArray
.3747	da		phx				phx 								; save type on stack
.3748	20 44 2e	jsr $2e44			jsr 	FindVariable 				; find it
.374b	b0 06		bcs $3753			bcs 	_GRTNoCreate 				; create if required.
.374d	20 cf 2b	jsr $2bcf			jsr 	CreateVariableRecord 		; create a variable.
.3750	20 24 2c	jsr $2c24			jsr 	AllocateBytesForType 		; allocate memory for it
.3753					_GRTNoCreate:
.3753	68		pla				pla 								; get type back, strip out type information.
.3754	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.3756	60		rts				rts
.3757					_GRTArray:
.3757	da		phx				phx 								; save type information
.3758	20 44 2e	jsr $2e44			jsr 	FindVariable 				; read its data, the base address in YX
.375b	90 18		bcc $3775			bcc 	_GRTUndeclared 				; undeclared array.
.375d	da		phx				phx 								; save base address
.375e	5a		phy				phy
.375f	20 1b 2d	jsr $2d1b			jsr 	OutputIndexGroup 			; create an index group and generate them
.3762	7a		ply				ply 								; get the array base address into YX
.3763	fa		plx				plx
.3764	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.3766	18		clc				clc
.3767	20 f2 36	jsr $36f2			jsr 	GetSetVariable 				; load the address of the array structure.
.376a	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.376c	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.376f	68		pla				pla 								; and the type data into A
.3770	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.3772	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.3774	60		rts				rts
.3775					_GRTUndeclared:
.3775	4c 04 20	jmp $2004		jmp	ErrorV_undeclared
.3778					CommandREM:
.3778	20 e3 33	jsr $33e3			jsr 	LookNext
.377b	f0 05		beq $3782			beq 	_CRExit
.377d	20 f4 33	jsr $33f4			jsr 	GetNext
.3780	80 f6		bra $3778			bra 	CommandREM
.3782					_CRExit:
.3782	60		rts				rts
.3783					STRReset:
.3783	ad c1 06	lda $06c1			lda	 	compilerStartHigh 			; set up the two table pointers
.3786	8d cc 06	sta $06cc			sta 	variableListEnd+1
.3789	9c cb 06	stz $06cb			stz 	variableListEnd
.378c	ad c2 06	lda $06c2			lda 	compilerEndHigh
.378f	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.3792	9c c9 06	stz $06c9			stz 	lineNumberTable
.3795	ad cb 06	lda $06cb			lda 	variableListEnd
.3798	85 2d		sta $2d				sta 	zTemp0+1
.379a	64 2c		stz $2c				stz 	zTemp0
.379c	a9 00		lda #$00			lda 	#0
.379e	92 2c		sta ($2c)			sta 	(zTemp0)
.37a0	a9 00		lda #$00			lda 	#((0) & $FF)
.37a2	8d cd 06	sta $06cd			sta 	0+freeVariableMemory
.37a5	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.37a7	8d ce 06	sta $06ce			sta 	1+freeVariableMemory
.37aa	60		rts				rts
.06c9					lineNumberTable:
>06c9							.fill 	2
.06cb					variableListEnd:
>06cb							.fill 	2
.06cd					freeVariableMemory:
>06cd							.fill 	2
.37ab					CommandRESTORE:
.37ab	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; what follows ?
.37ae	c9 3a		cmp #$3a			cmp 	#':'						; if : or EOL then default
.37b0	f0 0a		beq $37bc			beq 	_CRDefault
.37b2	c9 00		cmp #$00			cmp 	#0
.37b4	f0 06		beq $37bc			beq 	_CRDefault
.37b6	a9 d6		lda #$d6			lda 	#PCD_CMD_RESTORE 			; no, we have a parameter like GOTO/GOSUB
.37b8	20 cf 34	jsr $34cf			jsr 	CompileBranchCommand
.37bb	60		rts				rts
.37bc					_CRDefault:
.37bc	a9 d6		lda #$d6			lda 	#PCD_CMD_RESTORE 			; compile RESTORE
.37be	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.37c1	a9 00		lda #$00			lda 	#0		 					; with zero "line#"
.37c3	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.37c6	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.37c9	60		rts				rts
.37ca					CompileTerm:
.37ca	20 ff 33	jsr $33ff			jsr 	GetNextNonSpace 			; get first non space character.
.37cd	30 72		bmi $3841			bmi 	_CTUnaryFunctions
.37cf	20 09 34	jsr $3409			jsr 	CharIsDigit 				; found a number
.37d2	b0 3a		bcs $380e			bcs 	_CTDigit
.37d4	c9 2e		cmp #$2e			cmp 	#"."
.37d6	f0 36		beq $380e			beq 	_CTDigit
.37d8	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.37da	f0 43		beq $381f			beq 	_CTString
.37dc	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.37de	f0 28		beq $3808			beq 	_CTOtherBase
.37e0	c9 24		cmp #$24			cmp 	#"$"
.37e2	f0 24		beq $3808			beq 	_CTOtherBase
.37e4	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.37e6	f0 17		beq $37ff			beq 	_CTBrackets
.37e8	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.37ea	90 10		bcc $37fc			bcc 	_CTSyntax
.37ec	c9 5b		cmp #$5b			cmp 	#"Z"+1
.37ee	b0 0c		bcs $37fc			bcs 	_CTSyntax
.37f0	20 40 37	jsr $3740			jsr 	GetReferenceTerm 			; figure out what it is.
.37f3	48		pha				pha 								; save type on stack
.37f4	18		clc				clc 								; read it
.37f5	20 f2 36	jsr $36f2			jsr 	GetSetVariable
.37f8	68		pla				pla
.37f9	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.37fb	60		rts				rts
.37fc					_CTSyntax:
.37fc	4c 4d 1f	jmp $1f4d		jmp	ErrorV_syntax
.37ff					_CTBrackets:
.37ff	20 8a 2d	jsr $2d8a			jsr 	CompileExpressionAt0
.3802	48		pha				pha
.3803	20 d6 2a	jsr $2ad6			jsr 	CheckNextRParen
.3806	68		pla				pla
.3807	60		rts				rts
.3808					_CTOtherBase:
.3808	20 22 2a	jsr $2a22			jsr 	InlineNonDecimal 			; non decimal constant handler
.380b	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.380d	60		rts				rts
.380e					_CTDigit:
.380e	20 48 36	jsr $3648			jsr 	ParseConstant 				; parse out an number, first is in A already.
.3811	90 06		bcc $3819			bcc	 	_CTFloat 					; have a float or long int.
.3813	20 8a 2b	jsr $2b8a			jsr 	PushIntegerYA 				; code to push on stack
.3816	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.3818	60		rts				rts
.3819					_CTFloat:
.3819	20 ac 2b	jsr $2bac			jsr 	PushFloatCommand			; code to push float
.381c	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.381e	60		rts				rts
.381f					_CTString:
.381f	20 ab 2a	jsr $2aab			jsr 	BufferClear 				; copy it to the buffer
.3822					_CTStringLoop:
.3822	20 e3 33	jsr $33e3			jsr 	LookNext 					; reached EOL/EOS
.3825	f0 d5		beq $37fc			beq 	_CTSyntax
.3827	c9 22		cmp #$22			cmp 	#'"'
.3829	f0 08		beq $3833			beq 	_CTStringDone
.382b	20 af 2a	jsr $2aaf			jsr 	BufferWrite 				; write and consume
.382e	20 f4 33	jsr $33f4			jsr 	GetNext
.3831	80 ef		bra $3822			bra 	_CTStringLoop
.3833					_CTStringDone:
.3833	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume closing quote.
.3836	a9 cf		lda #$cf			lda 	#PCD_CMD_STRING 			; output command and buffer
.3838	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.383b	20 bb 2a	jsr $2abb			jsr 	BufferOutput
.383e	a9 40		lda #$40			lda 	#NSSString 					; string type
.3840	60		rts				rts
.3841					_CTUnaryFunctions:
.3841	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.3843	f0 0a		beq $384f			beq 	_CTNegation
.3845	a2 7e		ldx #$7e			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.3847	a0 31		ldy #$31			ldy 	#UnaryTables >> 8
.3849	20 85 32	jsr $3285			jsr 	GeneratorProcess
.384c	90 ae		bcc $37fc			bcc		_CTSyntax
.384e	60		rts				rts
.384f					_CTNegation:
.384f	20 ca 37	jsr $37ca			jsr 	CompileTerm 				; compile a term.
.3852	48		pha				pha
.3853	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.3855	c9 00		cmp #$00			cmp 	#NSSIFloat
.3857	d0 07		bne $3860			bne 	_CTType 					; error
.3859	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.385b	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.385e	68		pla				pla 								; return original type.
.385f	60		rts				rts
.3860					_CTType:
.3860	4c 5d 1f	jmp $1f5d		jmp	ErrorV_type
.3863					CommandWAIT:
.3863	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace
.3866	c9 2c		cmp #$2c			cmp 	#","
.3868	f0 10		beq $387a			beq 	_CWThirdParameter
.386a	a9 00		lda #$00			lda 	#0
.386c	20 9d 2b	jsr $2b9d			jsr 	PushIntegerA
.386f					_CWExit:
.386f	a9 cb		lda #$cb			lda 	#(PCD_WAIT) >> 8
.3871	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3874	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.3876	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.3879	60		rts				rts
.387a					_CWThirdParameter:
.387a	20 f4 33	jsr $33f4			jsr 	GetNext
.387d	20 8c 2d	jsr $2d8c			jsr 	CompileExpressionAtA
.3880	29 40		and #$40			and 	#NSSTypeMask
.3882	c9 00		cmp #$00			cmp 	#NSSIFloat
.3884	f0 e9		beq $386f			beq 	_CWExit
.3886	4c 5d 1f	jmp $1f5d		jmp	ErrorV_type
.3889					CommandCMD:
.3889	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.388b	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.388e	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; followed by a , ?
.3891	c9 2c		cmp #$2c			cmp 	#","
.3893	d0 06		bne $389b			bne 	_CCMDExit
.3895	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume comma.
.3898	20 6d 36	jsr $366d			jsr 	CommandPRINT 				; do the print code
.389b					_CCMDExit:
.389b	60		rts				rts
.389c					CommandOPEN:
.389c	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; followed by a , ?
.389f	c9 2c		cmp #$2c			cmp 	#","
.38a1	d0 15		bne $38b8			bne 	_COTwoDefaults
.38a3	20 f4 33	jsr $33f4			jsr 	GetNext 					; consume comma
.38a6	20 8a 2d	jsr $2d8a			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.38a9	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.38ab	f0 1e		beq $38cb			beq 	_COThreeIntegers
.38ad	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.38af	20 9d 2b	jsr $2b9d			jsr 	PushIntegerA
.38b2	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.38b4	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.38b7	60		rts				rts
.38b8					_COTwoDefaults:
.38b8	a9 00		lda #$00			lda 	#0
.38ba	20 9d 2b	jsr $2b9d			jsr 	PushIntegerA
.38bd					_COCompileNullString:
.38bd	a9 cf		lda #$cf			lda 	#(PCD_CMD_STRING) & $FF
.38bf	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.38c2	a9 00		lda #$00			lda 	#0
.38c4	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.38c7	20 74 2a	jsr $2a74			jsr 	WriteCodeByte
.38ca	60		rts				rts
.38cb					_COThreeIntegers:
.38cb	20 e6 33	jsr $33e6			jsr 	LookNextNonSpace 			; is there a ,
.38ce	c9 2c		cmp #$2c			cmp 	#","
.38d0	d0 eb		bne $38bd			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.38d2	20 f4 33	jsr $33f4			jsr 	GetNext
.38d5	20 8a 2d	jsr $2d8a			jsr 	CompileExpressionAt0 		; should be a filename
.38d8	29 40		and #$40			and 	#NSSString
.38da	f0 01		beq $38dd			beq 	_COType
.38dc	60		rts				rts
.38dd					_COType:
.38dd	4c 5d 1f	jmp $1f5d		jmp	ErrorV_type

;******  Processing input file: _library.asm

.38e0					CompilerAPI:
.38e0	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.38e2	f0 19		beq $38fd			beq 	_CAOpenIn
.38e4	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.38e6	f0 23		beq $390b			beq 	_CACloseIn
.38e8	c9 02		cmp #$02			cmp 	#BLC_READIN
.38ea	f0 3a		beq $3926			beq 	_CARead
.38ec	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.38ee	f0 1e		beq $390e			beq 	_CAResetOut
.38f0	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.38f2	f0 23		beq $3917			beq 	_CACloseOut
.38f4	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.38f6	f0 20		beq $3918			beq 	_CAWriteByte
.38f8	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.38fa	f0 26		beq $3922			beq 	_CAPrintScreen
>38fc	db						.byte 	$DB 						; causes a break in the emulator
.38fd					_CAOpenIn:
.38fd	a0 3a		ldy #$3a			ldy 	#SourceFile >> 8 			; name of file
.38ff	a2 1d		ldx #$1d			ldx 	#SourceFile & $FF
.3901	20 8e 39	jsr $398e			jsr 	IOOpenRead 					; open file
.3904	20 99 39	jsr $3999			jsr 	IOReadByte 					; skip the 2 byte load address header
.3907	20 99 39	jsr $3999			jsr 	IOReadByte
.390a	60		rts				rts
.390b					_CACloseIn:
.390b	4c a8 39	jmp $39a8			jmp 	IOReadClose
.390e					_CAResetOut:
.390e	a9 00		lda #$00			lda 	#((FreeMemory) & $FF)
.3910	85 2a		sta $2a				sta 	0+objPtr
.3912	a9 3b		lda #$3b			lda 	#((FreeMemory) >> 8) & $FF
.3914	85 2b		sta $2b				sta 	1+objPtr
.3916	60		rts				rts
.3917					_CACloseOut:
.3917	60		rts				rts
.3918					_CAWriteByte:
.3918	8a		txa				txa
.3919	92 2a		sta ($2a)			sta 	(objPtr)
.391b	e6 2a		inc $2a				inc 	objPtr
.391d	d0 02		bne $3921			bne 	_HWOWBNoCarry
.391f	e6 2b		inc $2b				inc 	objPtr+1
.3921					_HWOWBNoCarry:
.3921	60		rts				rts
.3922					_CAPrintScreen:
.3922	8a		txa				txa
.3923	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.3926					_CARead:
.3926	20 99 39	jsr $3999			jsr 	IOReadByte 				; copy the address of next into the buffer
.3929	8d cf 06	sta $06cf			sta 	SourceLine+0
.392c	20 99 39	jsr $3999			jsr 	IOReadByte
.392f	8d d0 06	sta $06d0			sta 	SourceLine+1
.3932	0d cf 06	ora $06cf			ora 	sourceLine				; if both were zero, exit with CC (e.g. fail)
.3935	18		clc				clc
.3936	f0 1e		beq $3956			beq		_CARExit
.3938	20 99 39	jsr $3999			jsr 	IOReadByte 				; read the line # into the buffer.
.393b	8d d1 06	sta $06d1			sta 	SourceLine+2
.393e	20 99 39	jsr $3999			jsr 	IOReadByte
.3941	8d d2 06	sta $06d2			sta 	SourceLine+3
.3944	a2 04		ldx #$04			ldx 	#4 						; read the body of the line.
.3946					_CAReadLine:
.3946	20 99 39	jsr $3999			jsr 	IOReadByte 				; now keep copying to EOL
.3949	9d cf 06	sta $06cf,x			sta 	SourceLine,x
.394c	e8		inx				inx
.394d	c9 00		cmp #$00			cmp 	#0
.394f	d0 f5		bne $3946			bne 	_CAReadLine
.3951	38		sec				sec 							; read a line okay
.3952	a0 06		ldy #$06			ldy 	#SourceLine >> 8
.3954	a2 cf		ldx #$cf			ldx 	#SourceLine & $FF
.3956					_CARExit:
.3956	60		rts				rts
.06cf					SourceLine:
>06cf							.fill 	256
.3957					WriteObjectCode:
.3957	20 1a 08	jsr $081a			jsr 	PatchOutCompile 			; makes it run the runtime on reload
.395a	a0 3a		ldy #$3a			ldy 	#ObjectFile >> 8
.395c	a2 12		ldx #$12			ldx 	#ObjectFile & $FF
.395e	20 84 3a	jsr $3a84			jsr 	IOOpenWrite 				; open write
.3961	a9 01		lda #$01			lda 	#1 							; write out the load address $0801
.3963	20 8f 3a	jsr $3a8f			jsr 	IOWriteByte
.3966	a9 08		lda #$08			lda 	#8
.3968	20 8f 3a	jsr $3a8f			jsr 	IOWriteByte
.396b	a9 01		lda #$01			lda 	#((StartBasicProgram) & $FF)
.396d	85 2c		sta $2c				sta 	0+zTemp0
.396f	a9 08		lda #$08			lda 	#((StartBasicProgram) >> 8) & $FF
.3971	85 2d		sta $2d				sta 	1+zTemp0
.3973					_WOCLoop:
.3973	b2 2c		lda ($2c)			lda 	(zTemp0) 					; write code
.3975	20 8f 3a	jsr $3a8f			jsr 	IOWriteByte
.3978	e6 2c		inc $2c				inc 	zTemp0 						; advance pointer
.397a	d0 02		bne $397e			bne 	_WOCSkip
.397c	e6 2d		inc $2d				inc 	zTemp0+1
.397e					_WOCSkip:
.397e	a5 2c		lda $2c				lda 	zTemp0 						; check end
.3980	c5 2a		cmp $2a				cmp 	objPtr
.3982	d0 ef		bne $3973			bne 	_WOCLoop
.3984	a5 2d		lda $2d				lda 	zTemp0+1
.3986	c5 2b		cmp $2b				cmp 	objPtr+1
.3988	d0 e9		bne $3973			bne 	_WOCLoop
.398a	20 a8 39	jsr $39a8			jsr 	IOWriteClose 				; close the file.
.398d	60		rts				rts
.398e					IOOpenRead:
.398e	a9 52		lda #$52			lda 	#'R' 						; read.
.3990	20 b1 39	jsr $39b1			jsr 	IOSetFileName 				; set up name/LFS
.3993	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for reading
.3995	20 c6 ff	jsr $ffc6			jsr 	$FFC6 						; CHKIN
.3998	60		rts				rts
.3999					IOReadByte:
.3999	da		phx				phx
.399a	5a		phy				phy
.399b	20 b7 ff	jsr $ffb7			jsr 	$FFB7 						; read ST
.399e	38		sec				sec
.399f	d0 04		bne $39a5			bne 	_IORExit
.39a1	20 cf ff	jsr $ffcf			jsr 	$FFCF 						; read a byte
.39a4	18		clc				clc 								; status OK.
.39a5					_IORExit:
.39a5	7a		ply				ply
.39a6	fa		plx				plx
.39a7	60		rts				rts
.39a8					IOReadClose:
.39a8					IOWriteClose:
.39a8	a9 03		lda #$03			lda 	#3 							; CLOSE# 3
.39aa	20 c3 ff	jsr $ffc3			jsr 	$FFC3
.39ad	20 cc ff	jsr $ffcc			jsr 	$FFCC 						; CLRCHN
.39b0	60		rts				rts
.39b1					IOSetFileName:
.39b1	48		pha				pha 								; save R/W
.39b2	86 2c		stx $2c				stx 	zTemp0
.39b4	84 2d		sty $2d				sty 	zTemp0+1
.39b6	a0 ff		ldy #$ff			ldy 	#$FF 						; copy name given
.39b8					_IOSCopy:
.39b8	c8		iny				iny 								; pre-increment copy
.39b9	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.39bb	99 cf 07	sta $07cf,y			sta 	IONameBuffer,y
.39be	d0 f8		bne $39b8			bne 	_IOSCopy
.39c0	99 d3 07	sta $07d3,y			sta 	IONameBuffer+4,y
.39c3	a9 2c		lda #$2c			lda 	#',' 						; append ,S,[R|W]
.39c5	99 cf 07	sta $07cf,y			sta 	IONameBuffer+0,y
.39c8	99 d1 07	sta $07d1,y			sta 	IONameBuffer+2,y
.39cb	a9 53		lda #$53			lda 	#'S'
.39cd	99 d0 07	sta $07d0,y			sta 	IONameBuffer+1,y
.39d0	68		pla				pla 								; write R/W out
.39d1	99 d2 07	sta $07d2,y			sta 	IONameBuffer+3,y
.39d4	98		tya				tya 								; length of name to A
.39d5	18		clc				clc
.39d6	69 04		adc #$04			adc 	#4 							; we added 4 characters.
.39d8	a2 cf		ldx #$cf			ldx 	#IONameBuffer & $FF			; name address to YX
.39da	a0 07		ldy #$07			ldy 	#IONameBuffer >> 8
.39dc	20 bd ff	jsr $ffbd		    jsr 	$FFBD          				; call SETNAM
.39df	a9 03		lda #$03	    	lda 	#3 							; set LFS to 3,8,3
.39e1	a2 08		ldx #$08			ldx 	#8
.39e3	a0 03		ldy #$03			ldy 	#3
.39e5	20 ba ff	jsr $ffba			jsr 	$FFBA
.39e8	20 c0 ff	jsr $ffc0			jsr 	$FFC0 						; OPEN
.39eb	60		rts				rts
.07cf					IONameBuffer:
>07cf							.fill 	64
.39ec					CompileCode:
.39ec	a2 00		ldx #$00			ldx 	#0
.39ee	bd 28 3a	lda $3a28,x	_Prompt:lda 	Prompt,x
.39f1	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.39f4	e8		inx				inx
.39f5	c9 00		cmp #$00			cmp 	#0
.39f7	d0 f5		bne $39ee			bne 	_Prompt
.39f9	a2 0e		ldx #$0e			ldx 	#APIDesc & $FF
.39fb	a0 3a		ldy #$3a			ldy 	#APIDesc >> 8
.39fd	20 eb 2a	jsr $2aeb			jsr 	StartCompiler
.3a00	20 57 39	jsr $3957			jsr 	WriteObjectCode
.3a03	a9 4f		lda #$4f			lda 	#"O"
.3a05	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a08	a9 4b		lda #$4b			lda 	#"K"
.3a0a	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a0d	60		rts				rts
.3a0e					APIDesc:
>3a0e	e0 38						.word 	CompilerAPI 				; the compiler API Implementeation
>3a10	80						.byte 	$80 						; start of workspace for compiler $8000
>3a11	9f						.byte 	$9F							; end of workspace for compiler $9F00
.3a12					ObjectFile:
>3a12	4f 42 4a 45 43 54 2e 50				.text 	'OBJECT.PRG',0
>3a1a	52 47 00
.3a1d					SourceFile:
>3a1d	53 4f 55 52 43 45 2e 50				.text 	'SOURCE.PRG',0
>3a25	52 47 00
.3a28					Prompt:
>3a28	2a 2a 2a 20 42 4c 49 54				.text 	'*** BLITZ (ALPHA 14-10-23) ***',13,13
>3a30	5a 20 28 41 4c 50 48 41 20 31 34 2d 31 30 2d 32
>3a40	33 29 20 2a 2a 2a 0d 0d
>3a48	42 55 47 53 20 2d 3e 20				.text 	'BUGS -> HTTPS://GITHUB.COM/PAULSCOTTROBSON/BLITZ-COMPILER',13,13,0
>3a50	48 54 54 50 53 3a 2f 2f 47 49 54 48 55 42 2e 43
>3a60	4f 4d 2f 50 41 55 4c 53 43 4f 54 54 52 4f 42 53
>3a70	4f 4e 2f 42 4c 49 54 5a 2d 43 4f 4d 50 49 4c 45
>3a80	52 0d 0d 00
.3a84					IOOpenWrite:
.3a84	a9 57		lda #$57			lda 	#'W'			 			; write
.3a86	20 b1 39	jsr $39b1			jsr 	IOSetFileName 				; set up name/LFS
.3a89	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for writing
.3a8b	20 c9 ff	jsr $ffc9			jsr 	$FFC9 						; CHKOUT
.3a8e	60		rts				rts
.3a8f					IOWriteByte:
.3a8f	48		pha				pha
.3a90	da		phx				phx
.3a91	5a		phy				phy
.3a92	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a95	7a		ply				ply
.3a96	fa		plx				plx
.3a97	68		pla				pla
.3a98	60		rts				rts

;******  Processing input file: source/main/zzfree.footer

>3a99							.align 	256
.3b00					FreeMemory:

;******  End of listing
