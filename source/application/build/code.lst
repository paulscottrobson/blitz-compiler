
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl source/main/00main.header /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library _library.asm source/main/zzfree.footer
; Wed Oct 11 18:43:04 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: source/main/00main.header

.0801					StartBasicProgram:
>0801	0c 08						.word 	$080C 						; offset to next.
>0803	0a 00						.word 	10 							; line #
>0805	9e						.byte 	$9E 						; token for 'SYS'
>0806	20 32 30 36 32					.text 	' 2062'						; space, $080E in decimal
>080b	00						.byte  	0 							; end of line
>080c	00 00						.word 	0 							; end of program
.080e					StartCode:
.080e	4c 8a 39	jmp $398a			jmp 	CompileCode 				; to starting the runtime in the saved code.
.0811	a9 3b		lda #$3b			lda 	#FreeMemory >> 8 			; address of object code to run.
.0813	a2 80		ldx #$80			ldx 	#$80 						; 8000-9EFF is used for workspace.
.0815	a0 9f		ldy #$9f			ldy 	#$9F
.0817	4c 26 08	jmp $0826			jmp 	StartRuntime 				; and go do it !
.081a					PatchOutCompile:
.081a	a9 ea		lda #$ea			lda 	#$EA 						; $EA is NOP 65C02
.081c	8d 0e 08	sta $080e			sta 	StartCode 					; patch out "JMP COMPILECODE"
.081f	8d 0f 08	sta $080f			sta 	StartCode+1
.0822	8d 10 08	sta $0810			sta 	StartCode+2
.0825	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.0826					StartRuntime:
.0826	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.0829	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.082b	64 28		stz $28				stz 	codePtr
.082d	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0830	8c 06 04	sty $0406			sty 	storeEndHigh
.0833	8e 07 04	stx $0407			stx 	variableStartPage
.0836	ba		tsx				tsx 								; save the stack.
.0837	8e 08 04	stx $0408			stx 	Runtime6502SP
.083a	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.083c	a2 58		ldx #$58			ldx 	#RuntimeErrorHandler & $FF
.083e	20 f3 1e	jsr $1ef3			jsr 	SetErrorHandler
.0841	20 84 0a	jsr $0a84			jsr 	ClearMemory 				; clear memory.
.0844	20 72 16	jsr $1672			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0847	20 74 13	jsr $1374		 	jsr		SetDefaultChannel			; set default input/output channel.
.084a	20 aa 15	jsr $15aa			jsr 	RestoreCode 				; which we now call
.084d	a0 00		ldy #$00			ldy 	#0
.084f					NextCommand:
.084f	ad 09 04	lda $0409			lda  	breakCount 					; only check every 16 instructions.
.0852	69 10		adc #$10			adc 	#16
.0854	8d 09 04	sta $0409			sta 	breakCount
.0857	90 07		bcc $0860			bcc 	_NXNoCheck
.0859	da		phx				phx
.085a	5a		phy				phy 								; check Ctrl+C
.085b	20 ae 1b	jsr $1bae			jsr 	XCheckStop
.085e	7a		ply				ply
.085f	fa		plx				plx
.0860					_NXNoCheck:
.0860	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.0862	30 5b		bmi $08bf			bmi 	NXCommand 					; -if -ve command
.0864	c8		iny				iny
.0865	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0867	90 39		bcc $08a2			bcc 	PushByteA 					; 0..63 is short constants.
.0869					NXLoadStore:
.0869	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.086b	b0 19		bcs $0886			bcs 	NXIndirectLoadStore
.086d	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.086e	4a		lsr a				lsr 	a
.086f	29 0e		and #$0e			and 	#$0E
.0871	da		phx				phx 								; get ready to jump
.0872	aa		tax				tax
.0873	7c 76 08	jmp ($0876,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.0876					ReadWriteVectors:
>0876	e0 14						.word 	ReadFloatCommand			; read float
>0878	bd 1a						.word 	WriteFloatCommand 			; write float
>087a	1c 15						.word 	ReadIntegerCommand 			; read integer
>087c	f9 1a						.word 	WriteIntegerCommand 		; write integer
>087e	61 15						.word 	ReadStringCommand 			; read string
>0880	38 1b						.word 	WriteStringCommand 			; write string
>0882	55 0c						.word 	Unimplemented
>0884	55 0c						.word 	Unimplemented
.0886					NXIndirectLoadStore:
.0886	29 07		and #$07			and 	#7
.0888	0a		asl a				asl 	a
.0889	da		phx				phx
.088a	aa		tax				tax
.088b	7c 8e 08	jmp ($088e,x)			jmp 	(IndirectVectors,x)
.088e					IndirectVectors:
>088e	0c 0f						.word 	IndFloatRead 				; float read
>0890	20 0f						.word 	IndInt16Read 				; int16 read
>0892	34 0f						.word 	IndStringRead 				; string read
>0894	55 0c						.word 	Unimplemented
>0896	48 0f						.word 	IndFloatWrite				; float write
>0898	5c 0f						.word 	IndInt16Write 				; int16 write
>089a	70 0f						.word 	IndStringWrite 				; string write
>089c	55 0c						.word 	Unimplemented
.089e					PushByteCommand:
.089e	fa		plx				plx
.089f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.08a1	c8		iny				iny
.08a2					PushByteA:
.08a2	e8		inx				inx 								; push constant on stack
.08a3	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.08a5	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.08a7					ClearRestWord:
.08a7	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.08a9	74 62		stz $62,x			stz 	NSMantissa3,x
.08ab	74 6e		stz $6e,x			stz 	NSExponent,x
.08ad	74 32		stz $32,x			stz 	NSStatus,x
.08af	80 9e		bra $084f			bra 	NextCommand
.08b1					PushWordCommand:
.08b1	fa		plx				plx
.08b2	e8		inx				inx
.08b3	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.08b5	c8		iny				iny
.08b6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08b8	b1 28		lda ($28),y			lda 	(codePtr),y
.08ba	c8		iny				iny
.08bb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08bd	80 e8		bra $08a7			bra 	ClearRestWord 				; handle everything else.
.08bf					NXCommand:
.08bf	c8		iny				iny 								; consume command.
.08c0	10 03		bpl $08c5			bpl 	_NXCommandNoFixUp
.08c2	20 cb 08	jsr $08cb			jsr 	FixUpY
.08c5					_NXCommandNoFixUp:
.08c5	0a		asl a				asl 	a 							; shift left
.08c6	da		phx				phx 								; save SP on stack
.08c7	aa		tax				tax				 					; and jump indirect
.08c8	7c 9c 19	jmp ($199c,x)			jmp 	(VectorTable,x)
.08cb					FixUpY:
.08cb	48		pha				pha
.08cc	98		tya				tya
.08cd	18		clc				clc
.08ce	65 28		adc $28				adc 	codePtr
.08d0	85 28		sta $28				sta 	codePtr
.08d2	90 02		bcc $08d6			bcc 	_NoCPCarry
.08d4	e6 29		inc $29				inc 	codePtr+1
.08d6					_NoCPCarry:
.08d6	a0 00		ldy #$00			ldy 	#0
.08d8	68		pla				pla
.08d9	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.0408					Runtime6502SP:
>0408							.fill 	1
.0409					breakCount:
>0409							.fill 	1
.08da					AbsoluteTOS:
.08da	fa		plx				plx
.08db	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.08e0					CommandVarSpace:
.08e0	fa		plx				plx
.08e1	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08e3	85 26		sta $26				sta 	availableMemory
.08e5	c8		iny				iny
.08e6	b1 28		lda ($28),y			lda 	(codePtr),y
.08e8	18		clc				clc
.08e9	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08ec	85 27		sta $27				sta 	availableMemory+1
.08ee	c8		iny				iny
.08ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08f2					BinaryAnd:
.08f2	fa		plx				plx
.08f3	38		sec				sec
.08f4	80 02		bra $08f8			bra 	AndOrCommon
.08f6					BinaryOr:
.08f6	fa		plx				plx
.08f7	18		clc				clc
.08f8					AndOrCommon:
.08f8	08		php				php 								; save AND/OR flag
.08f9	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.08fc	ca		dex				dex
.08fd	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.0900	28		plp				plp
.0901	90 0e		bcc $0911			bcc 	_AOCOrCode
.0903	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.0905	35 3f		and $3f,x			and		NSMantissa0+1,x
.0907	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0909	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.090b	35 4b		and $4b,x			and		NSMantissa1+1,x
.090d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.090f	80 0c		bra $091d			bra 	_AOCComplete
.0911					_AOCOrCode:
.0911	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.0913	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.0915	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0917	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0919	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.091b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.091d					_AOCComplete:
.091d	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.091f	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.0921	10 07		bpl $092a			bpl 	_AOCExit
.0923	20 57 10	jsr $1057			jsr 	Negate16Bit 				; 2's complement
.0926	a9 80		lda #$80			lda 	#$80 						; make it -ve
.0928	95 32		sta $32,x			sta 	NSStatus,x
.092a					_AOCExit:
.092a	4c 4f 08	jmp $084f			jmp 	NextCommand
.092d					ArrayConvert:
.092d	fa		plx				plx
.092e	5a		phy				phy
.092f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0931	85 2e		sta $2e				sta 	zTemp1
.0933	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0935	18		clc				clc
.0936	6d 07 04	adc $0407			adc 	variableStartPage
.0939	85 2f		sta $2f				sta 	zTemp1+1
.093b	ca		dex				dex 								; count of indices to follow -> zTemp2
.093c	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.093f	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.0941	8a		txa				txa
.0942	38		sec				sec
.0943	e5 30		sbc $30				sbc 	zTemp2
.0945	aa		tax				tax
.0946	da		phx				phx 								; stack points at the first index, which will be replaced.
.0947					_ACIndexLoop:
.0947	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart 			; integer array index
.094a	20 47 10	jsr $1047			jsr 	GetInteger16Bit 			; get the index => zTemp0
.094d	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.094f	a5 2c		lda $2c				lda 	zTemp0
.0951	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0953	a5 2d		lda $2d				lda 	zTemp0+1
.0955	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0957	b0 79		bcs $09d2			bcs 	_ACBadIndex 				; index error.
.0959	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.095b	f0 29		beq $0986			beq 	_ACInnerLevel
.095d	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.095f	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0961	10 6f		bpl $09d2			bpl 	_ACBadIndex
.0963	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0965	26 2d		rol $2d				rol 	zTemp0+1
.0967	18		clc				clc
.0968	a5 2c		lda $2c				lda		zTemp0
.096a	65 2e		adc $2e				adc 	zTemp1
.096c	85 2c		sta $2c				sta 	zTemp0
.096e	a5 2d		lda $2d				lda		zTemp0+1
.0970	65 2f		adc $2f				adc 	zTemp1+1
.0972	85 2d		sta $2d				sta 	zTemp0+1
.0974	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.0976	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0978	85 2e		sta $2e				sta 	zTemp1
.097a	c8		iny				iny
.097b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.097d	18		clc				clc
.097e	6d 07 04	adc $0407			adc 	variableStartPage
.0981	85 2f		sta $2f				sta 	zTemp1+1
.0983	e8		inx				inx 								; next index
.0984	80 c1		bra $0947			bra 	_ACIndexLoop
.0986					_ACInnerLevel:
.0986	a0 02		ldy #$02			ldy 	#2
.0988	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.098a	30 46		bmi $09d2			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.098c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.098e	c9 00		cmp #$00			cmp 	#NSSIFloat
.0990	d0 13		bne $09a5			bne 	_ACNotFloat
.0992	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.0994	48		pha				pha
.0995	a5 2c		lda $2c				lda 	zTemp0
.0997	06 2c		asl $2c				asl 	zTemp0 						; x 2
.0999	26 2d		rol $2d				rol 	zTemp0+1
.099b	18		clc				clc 								; add back x 3
.099c	65 2c		adc $2c				adc 	zTemp0
.099e	85 2c		sta $2c				sta 	zTemp0
.09a0	68		pla				pla
.09a1	65 2d		adc $2d				adc 	zTemp0+1
.09a3	85 2d		sta $2d				sta 	zTemp0+1
.09a5					_ACNotFloat:
.09a5	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.09a7	26 2d		rol $2d				rol 	zTemp0+1
.09a9	18		clc				clc
.09aa	a5 2c		lda $2c				lda 	zTemp0
.09ac	69 03		adc #$03			adc 	#3
.09ae	85 2c		sta $2c				sta 	zTemp0
.09b0	90 02		bcc $09b4			bcc 	_ACNoCarry
.09b2	e6 2d		inc $2d				inc 	zTemp0+1
.09b4					_ACNoCarry:
.09b4	fa		plx				plx 								; X points to first slot of array parameters
.09b5	18		clc				clc
.09b6	a5 2c		lda $2c				lda 	zTemp0
.09b8	65 2e		adc $2e				adc 	zTemp1
.09ba	95 3e		sta $3e,x			sta 	NSMantissa0,x
.09bc	a5 2d		lda $2d				lda 	zTemp0+1
.09be	65 2f		adc $2f				adc 	zTemp1+1
.09c0	38		sec				sec
.09c1	ed 07 04	sbc $0407			sbc 	variableStartPage
.09c4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.09c6	74 56		stz $56,x			stz 	NSMantissa2,x
.09c8	74 62		stz $62,x			stz 	NSMantissa3,x
.09ca	74 32		stz $32,x			stz 	NSStatus,x
.09cc	74 6e		stz $6e,x			stz 	NSExponent,x
.09ce	7a		ply				ply 	 							; restore code pointer
.09cf	4c 4f 08	jmp $084f			jmp 	NextCommand
.09d2					_ACBadIndex:
.09d2	4c f5 1f	jmp $1ff5		jmp	ErrorV_index
.09d5					UnaryAsc:
.09d5	fa		plx				plx
.09d6	5a		phy				phy
.09d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09d9	85 2c		sta $2c				sta 	zTemp0
.09db	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09dd	85 2d		sta $2d				sta 	zTemp0+1
.09df	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09e1	f0 06		beq $09e9			beq 	_UAExit
.09e3	5a		phy				phy 								; otherwise first character
.09e4	a0 01		ldy #$01			ldy 	#1
.09e6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09e8	7a		ply				ply
.09e9					_UAExit:
.09e9	20 73 26	jsr $2673			jsr 	FloatSetByte
.09ec	7a		ply				ply
.09ed	4c 4f 08	jmp $084f			jmp 	NextCommand
.09f0					CommandAssert:
.09f0	fa		plx				plx
.09f1	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09f3	d0 09		bne $09fe			bne 	_CAFail
.09f5	20 93 26	jsr $2693			jsr 	FloatIsZero 				; is it zero ?
.09f8	f0 04		beq $09fe			beq 	_CAFail
.09fa	ca		dex				dex
.09fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.09fe					_CAFail:
.09fe	4c 4e 1f	jmp $1f4e		jmp	ErrorV_assert
.0a01					X16_Audio_Parameters8_16:
.0a01	20 07 0a	jsr $0a07			jsr 	X16_Audio_Parameters8_8
.0a04	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.0a06	60		rts				rts
.0a07					X16_Audio_Parameters8_8:
.0a07	a2 01		ldx #$01			ldx 	#1
.0a09	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.0a0c	ca		dex				dex
.0a0d	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.0a10	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0a13	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.0a15	a0 00		ldy #$00			ldy 	#0
.0a17	60		rts				rts
.0a18					X16_Audio_Parameters8_String:
.0a18	20 01 0a	jsr $0a01			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.0a1b	da		phx				phx 								; set the voice
.0a1c	5a		phy				phy
.0a1d	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.0a20	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>0a23	0a						.byte 	X16_AudioCodeBank
.0a24	7a		ply				ply
.0a25	fa		plx				plx
.0a26	86 2c		stx $2c				stx 	zTemp0
.0a28	84 2d		sty $2d				sty 	zTemp0+1
.0a2a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a2c	e8		inx				inx 								; point YX to first character.
.0a2d	d0 01		bne $0a30			bne 	_X16APSSkip
.0a2f	c8		iny				iny
.0a30					_X16APSSkip:
.0a30	60		rts				rts
.0a31					Unary16Bin:
.0a31	fa		plx				plx
.0a32	20 47 10	jsr $1047			jsr 	GetInteger16Bit				; 16 bit int
.0a35	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a37	20 1b 17	jsr $171b			jsr 	StringAllocTemp
.0a3a	a5 2d		lda $2d				lda 	zTemp0+1
.0a3c	f0 03		beq $0a41			beq 	_UBNoHigh
.0a3e	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a41					_UBNoHigh:
.0a41	a5 2c		lda $2c				lda 	zTemp0
.0a43	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a46	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a49					_UBWriteBinary:
.0a49	5a		phy				phy
.0a4a	a0 08		ldy #$08			ldy 	#8
.0a4c					_UBWLoop:
.0a4c	0a		asl a				asl 	a
.0a4d	48		pha				pha
.0a4e	a9 00		lda #$00			lda  	#0
.0a50	69 30		adc #$30			adc 	#48
.0a52	20 44 17	jsr $1744			jsr 	StringWriteChar
.0a55	68		pla				pla
.0a56	88		dey				dey
.0a57	d0 f3		bne $0a4c			bne 	_UBWLoop
.0a59	7a		ply				ply
.0a5a	60		rts				rts
.0a5b					PrintCharacterX:
.0a5b	fa		plx				plx
.0a5c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a5e	ca		dex				dex
.0a5f	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.0a62	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a65					UnaryChr:
.0a65	fa		plx				plx
.0a66	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get integer to convert.
.0a69	48		pha				pha 								; save it and allocate for it
.0a6a	a9 01		lda #$01			lda 	#1 							; 1 character
.0a6c	20 1b 17	jsr $171b			jsr 	StringAllocTemp
.0a6f	a9 01		lda #$01			lda 	#1 							; length 1.
.0a71	92 22		sta ($22)			sta 	(zsTemp)
.0a73	68		pla				pla 								; character code makes string.
.0a74	5a		phy				phy
.0a75	a0 01		ldy #$01			ldy 	#1
.0a77	91 22		sta ($22),y			sta 	(zsTemp),y
.0a79	7a		ply				ply
.0a7a	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a7d					CommandClr:
.0a7d	fa		plx				plx
.0a7e	20 84 0a	jsr $0a84			jsr 	ClearMemory
.0a81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a84					ClearMemory:
.0a84	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a87	85 2d		sta $2d				sta 	zTemp0+1
.0a89	64 2c		stz $2c				stz 	zTemp0
.0a8b	5a		phy				phy
.0a8c	a0 00		ldy #$00			ldy 	#0
.0a8e					_ClearLoop1:
.0a8e	a9 00		lda #$00			lda 	#0
.0a90	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a92	c8		iny				iny
.0a93	d0 f9		bne $0a8e			bne 	_ClearLoop1
.0a95	e6 2d		inc $2d				inc 	zTemp0+1
.0a97	a5 2d		lda $2d				lda 	zTemp0+1
.0a99	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a9c	d0 f0		bne $0a8e			bne 	_ClearLoop1
.0a9e	38		sec				sec 											; stack space = number of pages in total / 4
.0a9f	ad 06 04	lda $0406			lda 	storeEndHigh
.0aa2	ed 05 04	sbc $0405			sbc		storeStartHigh
.0aa5	4a		lsr a				lsr 	a
.0aa6	4a		lsr a				lsr 	a
.0aa7	d0 02		bne $0aab			bne 	_NotEmpty 								; at least 1 !
.0aa9	a9 01		lda #$01			lda 	#1
.0aab					_NotEmpty:
.0aab	38		sec				sec 											; subtract from high to give string high memory
.0aac	49 ff		eor #$ff			eor 	#$FF
.0aae	6d 06 04	adc $0406			adc 	storeEndHigh
.0ab1	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0ab4	9c 02 04	stz $0402			stz 	stringHighMemory
.0ab7	9c 6a 05	stz $056a			stz 	stringInitialised 						; string system not initialised
.0aba	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0abd	3a		dec a				dec 	a
.0abe	85 25		sta $25				sta 	runtimeStackPtr+1
.0ac0	a9 ff		lda #$ff			lda 	#$FF
.0ac2	85 24		sta $24				sta 	runtimeStackPtr
.0ac4	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0ac6	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0ac8	7a		ply				ply
.0ac9	60		rts				rts
.0aca					CompareStrings:
.0aca	fa		plx				plx
.0acb	ca		dex				dex
.0acc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0ace	85 2c		sta $2c				sta 	zTemp0
.0ad0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ad2	85 2d		sta $2d				sta 	zTemp0+1
.0ad4	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0ad6	85 2e		sta $2e				sta 	zTemp1
.0ad8	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0ada	85 2f		sta $2f				sta 	zTemp1+1
.0adc	da		phx				phx
.0add	5a		phy				phy
.0ade	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0ae0	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0ae2	90 02		bcc $0ae6			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0ae4	b2 2e		lda ($2e)			lda 	(zTemp1)
.0ae6					_CSNIsSmallest:
.0ae6	aa		tax				tax 								; count in X
.0ae7	f0 0c		beq $0af5			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0ae9	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0aeb					_CSNCompareString:
.0aeb	c8		iny				iny 								; pre increment
.0aec	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0aee	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0af0	d0 0a		bne $0afc			bne 	_CSNDifferent 				; numbers are different.
.0af2	ca		dex				dex
.0af3	d0 f6		bne $0aeb			bne 	_CSNCompareString 			; compare common characters in two strings.
.0af5					_CSNMatches:
.0af5	38		sec				sec
.0af6	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0af8	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0afa	f0 06		beq $0b02			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0afc					_CSNDifferent:
.0afc	a9 ff		lda #$ff			lda 	#$FF
.0afe	90 02		bcc $0b02			bcc 	_CSNSExit
.0b00	a9 01		lda #$01			lda 	#$01
.0b02					_CSNSExit:
.0b02	7a		ply				ply
.0b03	fa		plx				plx
.0b04	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0b06	20 73 26	jsr $2673			jsr 	FloatSetByte 				; output the byte
.0b09	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b0c					StringConcrete:
.0b0c	9c 6a 05	stz $056a			stz 	stringInitialised	 		; initialise next usage
.0b0f	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0b11	85 30		sta $30				sta 	zTemp2
.0b13	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0b15	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0b16	18		clc				clc
.0b17	72 30		adc ($30)			adc 	(zTemp2)
.0b19	90 02		bcc $0b1d			bcc 	_SCNoOverflow
.0b1b	a9 ff		lda #$ff			lda 	#255
.0b1d					_SCNoOverflow:
.0b1d	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0b1f	b0 02		bcs $0b23			bcs 	_SCNoMinimum
.0b21	a9 0a		lda #$0a			lda 	#10
.0b23					_SCNoMinimum:
.0b23	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0b25	38		sec				sec
.0b26	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0b29	e5 2e		sbc $2e				sbc 	zTemp1
.0b2b	a8		tay				tay
.0b2c	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b2f	e9 00		sbc #$00			sbc 	#0
.0b31	48		pha				pha
.0b32	38		sec				sec 								; subtract 3 more
.0b33	98		tya				tya
.0b34	e9 03		sbc #$03			sbc 	#3
.0b36	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b39	85 22		sta $22				sta 	zsTemp
.0b3b	68		pla				pla
.0b3c	e9 00		sbc #$00			sbc 	#0
.0b3e	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b41	85 23		sta $23				sta 	zsTemp+1
.0b43	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b45	92 22		sta ($22)			sta 	(zsTemp)
.0b47	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b49	a9 00		lda #$00			lda 	#0
.0b4b	91 22		sta ($22),y			sta 	(zsTemp),y
.0b4d	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b4f	a4 23		ldy $23				ldy 	zsTemp+1
.0b51	60		rts				rts
.0b52					CommandXData:
.0b52	fa		plx				plx
.0b53	98		tya				tya 								; data length +1 added to Y
.0b54	38		sec				sec
.0b55	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b57	a8		tay				tay
.0b58	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b5b					CommandXDIM:
.0b5b	fa		plx				plx
.0b5c	5a		phy				phy
.0b5d	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b60	8d 0a 04	sta $040a			sta 	dimType
.0b63	ca		dex				dex 								; this is the number of indices
.0b64	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0b67	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b69	8a		txa				txa 								; dimension.
.0b6a	38		sec				sec
.0b6b	e5 2e		sbc $2e				sbc 	zTemp1
.0b6d	aa		tax				tax
.0b6e	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b70	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create one at this level
.0b73	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b75	98		tya				tya
.0b76	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b78	74 56		stz $56,x			stz 	NSMantissa2,x
.0b7a	74 62		stz $62,x			stz 	NSMantissa3,x
.0b7c	74 32		stz $32,x			stz 	NSStatus,x
.0b7e	74 6e		stz $6e,x			stz 	NSExponent,x
.0b80	7a		ply				ply
.0b81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b84					DIMCreateOneLevel:
.0b84	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b86	5a		phy				phy
.0b87	a4 27		ldy $27				ldy 	availableMemory+1
.0b89	5a		phy				phy
.0b8a	a8		tay				tay 			 					; save current level into Y
.0b8b	20 47 10	jsr $1047			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b8e	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b90	d0 02		bne $0b94			bne 	_DCOLNoCarry
.0b92	e6 2d		inc $2d				inc 	zTemp0+1
.0b94					_DCOLNoCarry:
.0b94	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b96	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b99	a5 2d		lda $2d				lda 	zTemp0+1
.0b9b	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b9e	ad 0a 04	lda $040a			lda 	dimType 					; get type information
.0ba1	29 7f		and #$7f			and 	#$7F
.0ba3	c0 01		cpy #$01			cpy 	#1
.0ba5	f0 02		beq $0ba9			beq 	_DCOLNoSubLevel
.0ba7	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0ba9					_DCOLNoSubLevel:
.0ba9	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0bac	a5 26		lda $26				lda 	availableMemory
.0bae	85 2e		sta $2e				sta 	zTemp1
.0bb0	a5 27		lda $27				lda 	availableMemory+1
.0bb2	85 2f		sta $2f				sta 	zTemp1+1
.0bb4	a5 2c		lda $2c				lda 	zTemp0
.0bb6	85 30		sta $30				sta 	zTemp2
.0bb8	a5 2d		lda $2d				lda 	zTemp0+1
.0bba	85 31		sta $31				sta 	zTemp2+1
.0bbc					_DCOLFillArray:
.0bbc	20 1b 0c	jsr $0c1b			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0bbf	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0bc1	d0 02		bne $0bc5			bne 	_DCOLNoBorrow
.0bc3	c6 2d		dec $2d				dec 	zTemp0+1
.0bc5					_DCOLNoBorrow:
.0bc5	c6 2c		dec $2c				dec 	zTemp0
.0bc7	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0bc9	05 2d		ora $2d				ora 	zTemp0+1
.0bcb	d0 ef		bne $0bbc			bne 	_DCOLFillArray
.0bcd	c0 01		cpy #$01			cpy 	#1
.0bcf	f0 42		beq $0c13			beq 	_DCOLExit
.0bd1					_DCOLRecursionLoop:
.0bd1	da		phx				phx 								; save XY
.0bd2	5a		phy				phy
.0bd3	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0bd5	48		pha				pha
.0bd6	a5 2f		lda $2f				lda 	zTemp1+1
.0bd8	48		pha				pha
.0bd9	a5 30		lda $30				lda 	zTemp2
.0bdb	48		pha				pha
.0bdc	a5 31		lda $31				lda 	zTemp2+1
.0bde	48		pha				pha
.0bdf	88		dey				dey  								; lower level -> A
.0be0	98		tya				tya
.0be1	e8		inx				inx 								; next index size
.0be2	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0be5	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0be6	86 31		stx $31				stx 	zTemp2+1
.0be8	fa		plx				plx
.0be9	86 30		stx $30				stx 	zTemp2
.0beb	fa		plx				plx
.0bec	86 2f		stx $2f				stx 	zTemp1+1
.0bee	fa		plx				plx
.0bef	86 2e		stx $2e				stx 	zTemp1
.0bf1	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0bf3	98		tya				tya
.0bf4	a0 01		ldy #$01			ldy 	#1
.0bf6	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0bf8	7a		ply				ply 								; restore XY
.0bf9	fa		plx				plx
.0bfa	18		clc				clc
.0bfb	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0bfd	69 02		adc #$02			adc 	#2
.0bff	85 2e		sta $2e				sta 	zTemp1
.0c01	90 02		bcc $0c05			bcc 	_DCOLRNoCarry
.0c03	e6 2f		inc $2f				inc 	zTemp1+1
.0c05					_DCOLRNoCarry:
.0c05	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0c07	d0 02		bne $0c0b			bne 	_DCOLRNoBorrow
.0c09	c6 31		dec $31				dec 	zTemp2+1
.0c0b					_DCOLRNoBorrow:
.0c0b	c6 30		dec $30				dec 	zTemp2
.0c0d	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0c0f	05 31		ora $31				ora 	zTemp2+1
.0c11	d0 be		bne $0bd1			bne 	_DCOLRecursionLoop
.0c13					_DCOLExit:
.0c13	68		pla				pla 								; get MSB, make offset again
.0c14	38		sec				sec
.0c15	ed 07 04	sbc $0407			sbc 	variableStartPage
.0c18	a8		tay				tay
.0c19	68		pla				pla 								; YA now contains offset address.
.0c1a	60		rts				rts
.0c1b					DIMWriteElement:
.0c1b	da		phx				phx
.0c1c	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0c1e	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0c20	d0 0b		bne $0c2d			bne 	_DIMWENotFloat
.0c22	ad 0a 04	lda $040a			lda 	dimType
.0c25	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0c27	c9 00		cmp #$00			cmp 	#NSSIFloat
.0c29	d0 02		bne $0c2d			bne 	_DIMWENotFloat
.0c2b	a2 06		ldx #$06			ldx 	#6
.0c2d					_DIMWENotFloat:
.0c2d	a9 00		lda #$00			lda 	#0
.0c2f	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0c32	ca		dex				dex
.0c33	d0 f8		bne $0c2d			bne 	_DIMWENotFloat
.0c35	fa		plx				plx
.0c36	60		rts				rts
.0c37					DIMWriteByte:
.0c37	92 26		sta ($26)			sta 	(availableMemory)
.0c39	e6 26		inc $26				inc 	availableMemory
.0c3b	d0 0b		bne $0c48			bne 	_DIMWBSkip
.0c3d	e6 27		inc $27				inc 	availableMemory+1
.0c3f	48		pha				pha
.0c40	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c42	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c45	b0 02		bcs $0c49			bcs 	_DIMWBMemory
.0c47	68		pla				pla
.0c48					_DIMWBSkip:
.0c48	60		rts				rts
.0c49					_DIMWBMemory:
.0c49	4c 08 20	jmp $2008		jmp	ErrorV_memory
.040a					dimType:
>040a							.fill 	1
.0c4c					CommandEnd:
.0c4c	fa		plx				plx
.0c4d	86 2c		stx $2c				stx 	zTemp0
.0c4f	18		clc				clc 								; exited okay.
.0c50					EndRuntime:
.0c50	ae 08 04	ldx $0408			ldx 	Runtime6502SP 				; set up the stack pointer
.0c53	9a		txs				txs
.0c54	60		rts				rts
.0c55					Unimplemented:
.0c55	4c 3b 1f	jmp $1f3b			jmp 	ErrorV_unimplemented
.0c58					RuntimeErrorHandler:
.0c58	98		tya				tya
.0c59	18		clc				clc
.0c5a	65 28		adc $28				adc 	codePtr
.0c5c	85 28		sta $28				sta 	codePtr
.0c5e	90 02		bcc $0c62			bcc 	_EHNoCarry
.0c60	e6 29		inc $29				inc 	codePtr+1
.0c62					_EHNoCarry:
.0c62	68		pla				pla
.0c63	7a		ply				ply
.0c64	85 2c		sta $2c				sta 	zTemp0
.0c66	84 2d		sty $2d				sty 	zTemp0+1
.0c68	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c6a	a0 01		ldy #$01			ldy 	#1
.0c6c					_EHDisplayMsg:
.0c6c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c6e	20 9b 1c	jsr $1c9b			jsr 	XPrintCharacterToChannel
.0c71	c8		iny				iny
.0c72	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c74	d0 f6		bne $0c6c			bne 	_EHDisplayMsg
.0c76	a9 20		lda #$20			lda 	#32
.0c78	20 9b 1c	jsr $1c9b			jsr 	XPrintCharacterToChannel
.0c7b	a9 40		lda #$40			lda 	#64
.0c7d	20 9b 1c	jsr $1c9b			jsr 	XPrintCharacterToChannel
.0c80	a9 20		lda #$20			lda 	#32
.0c82	20 9b 1c	jsr $1c9b			jsr 	XPrintCharacterToChannel
.0c85	20 8c 0c	jsr $0c8c			jsr 	EHDisplayCodePtr
.0c88	38		sec				sec 								; report error.
.0c89	4c 50 0c	jmp $0c50			jmp 	EndRuntime
.0c8c					EHDisplayCodePtr:
.0c8c	a9 24		lda #$24			lda 	#'$'
.0c8e	20 9b 1c	jsr $1c9b			jsr 	XPrintCharacterToChannel
.0c91	38		sec				sec
.0c92	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c94	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c97	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9a	a5 28		lda $28				lda 	codePtr
.0c9c	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9f	60		rts				rts
.0ca0					_EHDisplayHex:
.0ca0	48		pha				pha
.0ca1	4a		lsr a				lsr 	a
.0ca2	4a		lsr a				lsr 	a
.0ca3	4a		lsr a				lsr 	a
.0ca4	4a		lsr a				lsr 	a
.0ca5	20 a9 0c	jsr $0ca9			jsr 	_EHDisplayNibble
.0ca8	68		pla				pla
.0ca9					_EHDisplayNibble:
.0ca9	29 0f		and #$0f			and 	#15
.0cab	c9 0a		cmp #$0a			cmp 	#10
.0cad	90 02		bcc $0cb1			bcc 	_EHNotHex
.0caf	69 06		adc #$06			adc 	#6
.0cb1					_EHNotHex:
.0cb1	69 30		adc #$30			adc 	#48
.0cb3	4c 9b 1c	jmp $1c9b			jmp 	XPrintCharacterToChannel
.0cb6					CommandXFor:
.0cb6	fa		plx				plx
.0cb7	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0cb9	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0cbc	20 78 11	jsr $1178			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0cbf	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0cc1	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cc4	ca		dex				dex
.0cc5	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0cc7	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cca	ca		dex				dex
.0ccb	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0ccd	29 80		and #$80			and 	#$80
.0ccf	a0 04		ldy #$04			ldy 	#4
.0cd1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd3	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0cd5	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0cd7	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd9	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0cdb	c8		iny				iny
.0cdc	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cde	18		clc				clc
.0cdf	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0ce1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ce3	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0ce6	85 2d		sta $2d				sta 	zTemp0+1
.0ce8	ca		dex				dex 								; throw reference.
.0ce9	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0ceb	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0ced	a0 0c		ldy #$0c			ldy 	#12
.0cef	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf1	a0 12		ldy #$12			ldy 	#18
.0cf3	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf5	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0cf7	88		dey				dey 								; now the exponents.
.0cf8	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0cfa	a0 0b		ldy #$0b			ldy 	#11
.0cfc	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cfe	a0 11		ldy #$11			ldy 	#17
.0d00	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d02	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0d04	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d06	c8		iny				iny
.0d07	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d09	c8		iny				iny
.0d0a	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d0c	d0 08		bne $0d16			bne 	_CFNoOptimise
.0d0e	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0d10	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0d12	09 40		ora #$40			ora 	#$40
.0d14	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d16					_CFNoOptimise:
.0d16	a0 00		ldy #$00			ldy 	#0
.0d18	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d1b					CopyTOSToOffsetY:
.0d1b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0d1d	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d1f	c8		iny				iny
.0d20	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0d22	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d24	c8		iny				iny
.0d25	b5 56		lda $56,x			lda 	NSMantissa2,x
.0d27	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d29	c8		iny				iny
.0d2a	b5 62		lda $62,x			lda 	NSMantissa3,x
.0d2c	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d2e	c8		iny				iny
.0d2f	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d31	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d33	c8		iny				iny
.0d34	b5 32		lda $32,x			lda 	NSStatus,x
.0d36	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d38	60		rts				rts
.0d39					StackOpenFrame:
.0d39	48		pha				pha 								; save frame marker
.0d3a	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d3c	85 2c		sta $2c				sta 	zTemp0
.0d3e	38		sec				sec 								; subtract from runtime stack pointer.
.0d3f	a5 24		lda $24				lda		runtimeStackPtr
.0d41	e5 2c		sbc $2c				sbc 	zTemp0
.0d43	85 24		sta $24				sta 	runtimeStackPtr
.0d45	a5 25		lda $25				lda		runtimeStackPtr+1
.0d47	e9 00		sbc #$00			sbc 	#0
.0d49	85 25		sta $25				sta 	runtimeStackPtr+1
.0d4b	68		pla				pla 								; put frame marker at +0
.0d4c	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d4e	60		rts				rts
.0d4f					StackCloseFrame:
.0d4f	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d51	29 1f		and #$1f			and 	#$1F 						; size
.0d53	18		clc				clc
.0d54	65 24		adc $24				adc 	runtimeStackPtr
.0d56	85 24		sta $24				sta 	runtimeStackPtr
.0d58	90 02		bcc $0d5c			bcc 	_SCFNoCarry
.0d5a	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d5c					_SCFNoCarry:
.0d5c	60		rts				rts
.0d5d					StackFindFrame:
.0d5d	8d 0b 04	sta $040b			sta 	requiredFrame
.0d60					_SFFLoop:
.0d60	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d62	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d64	f0 10		beq $0d76			beq 	SCFFail
.0d66	cd 0b 04	cmp $040b			cmp 	requiredFrame 				; found this type ?
.0d69	f0 05		beq $0d70			beq 	_SFFFound
.0d6b	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close the top frame
.0d6e	80 f0		bra $0d60			bra 	_SFFLoop 					; and try te next.
.0d70					_SFFFound:
.0d70	60		rts				rts
.0d71					StackCheckFrame:
.0d71	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d73	d0 01		bne $0d76			bne 	SCFFail
.0d75	60		rts				rts
.0d76					SCFFail:
.0d76	4c 98 1f	jmp $1f98		jmp	ErrorV_structure
.040b					requiredFrame:
>040b							.fill 	1
.0d79					UnaryFre:
.0d79	fa		plx				plx
.0d7a	20 71 26	jsr $2671			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d7d	38		sec				sec
.0d7e	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d81	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d84	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d86	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d89	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d8c	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d8e	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d91					CommandXGet:
.0d91	fa		plx				plx
.0d92	e8		inx				inx
.0d93	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d95	20 1b 17	jsr $171b			jsr 	StringAllocTemp
.0d98	20 81 13	jsr $1381			jsr 	VectorGetCharacter 			; get a character
.0d9b	c9 00		cmp #$00			cmp 	#0
.0d9d	f0 09		beq $0da8			beq 	_CGNone
.0d9f	5a		phy				phy
.0da0	a0 01		ldy #$01			ldy 	#1 							; store char
.0da2	91 22		sta ($22),y			sta 	(zsTemp),y
.0da4	98		tya				tya 								; store length.
.0da5	92 22		sta ($22)			sta 	(zsTemp)
.0da7	7a		ply				ply
.0da8					_CGNone:
.0da8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dab					CommandXGosub:
.0dab	fa		plx				plx
.0dac	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dae	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0db1	20 78 11	jsr $1178			jsr 	StackSaveCurrentPosition
.0db4	4c c9 0d	jmp $0dc9			jmp 	PerformGOTO
.0db7					CommandReturn:
.0db7	fa		plx				plx
.0db8	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dba	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.0dbd	20 89 11	jsr $1189			jsr 	StackLoadCurrentPosition
.0dc0	c8		iny				iny
.0dc1	c8		iny				iny
.0dc2	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame
.0dc5	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dc8					CommandXGoto:
.0dc8	fa		plx				plx
.0dc9					PerformGOTO:
.0dc9	c8		iny				iny 								; push MSB of offset on stack
.0dca	b1 28		lda ($28),y			lda 	(codePtr),y
.0dcc	48		pha				pha
.0dcd	88		dey				dey 								; point LSB of offset
.0dce	18		clc				clc 								; add LSB
.0dcf	b1 28		lda ($28),y			lda 	(codePtr),y
.0dd1	65 28		adc $28				adc 	codePtr
.0dd3	85 28		sta $28				sta 	codePtr
.0dd5	68		pla				pla 								; restore offset MSB and add
.0dd6	65 29		adc $29				adc 	codePtr+1
.0dd8	85 29		sta $29				sta 	codePtr+1
.0dda	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ddd					CommandGotoZ:
.0ddd	fa		plx				plx
.0dde	20 93 26	jsr $2693			jsr 	FloatIsZero
.0de1	ca		dex				dex
.0de2	c9 00		cmp #$00			cmp 	#0
.0de4	f0 e3		beq $0dc9			beq 	PerformGOTO
.0de6	c8		iny				iny
.0de7	c8		iny				iny
.0de8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0deb					CommandGotoNZ:
.0deb	fa		plx				plx
.0dec	20 93 26	jsr $2693			jsr 	FloatIsZero
.0def	ca		dex				dex
.0df0	c9 00		cmp #$00			cmp 	#0
.0df2	d0 d5		bne $0dc9			bne 	PerformGOTO
.0df4	c8		iny				iny
.0df5	c8		iny				iny
.0df6	4c 4f 08	jmp $084f			jmp 	NextCommand
.0df9					Command_PSET:
.0df9	fa		plx				plx
.0dfa	5a		phy				phy
.0dfb	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the colour
.0dfe	48		pha				pha
.0dff	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e01	a0 02		ldy #$02			ldy 	#X16_r0
.0e03	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e06	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0e09	68		pla				pla 								; set pixel.
.0e0a	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0e0d	7a		ply				ply
.0e0e	a2 ff		ldx #$ff			ldx 	#$FF
.0e10	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e13					Command_LINE:
.0e13	fa		plx				plx
.0e14	5a		phy				phy
.0e15	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e18	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0e1a	a0 02		ldy #$02			ldy 	#X16_r0
.0e1c	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0e1f	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0e22	7a		ply				ply
.0e23	a2 ff		ldx #$ff			ldx 	#$FF
.0e25	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e28					Command_RECT:
.0e28	fa		plx				plx
.0e29	5a		phy				phy
.0e2a	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e2d	38		sec				sec
.0e2e	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e31	7a		ply				ply
.0e32	a2 ff		ldx #$ff			ldx 	#$FF
.0e34	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e37					Command_FRAME:
.0e37	fa		plx				plx
.0e38	5a		phy				phy
.0e39	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e3c	18		clc				clc
.0e3d	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e40	7a		ply				ply
.0e41	a2 ff		ldx #$ff			ldx 	#$FF
.0e43	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e46					Command_CHAR:
.0e46	fa		plx				plx
.0e47	5a		phy				phy
.0e48	ca		dex				dex  								; set the draw colour
.0e49	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e4c	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e4e	a0 02		ldy #$02			ldy 	#X16_r0
.0e50	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e53	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e55	85 2c		sta $2c				sta 	zTemp0
.0e57	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e59	85 2d		sta $2d				sta 	zTemp0+1
.0e5b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e5d	85 2e		sta $2e				sta 	zTemp1
.0e5f					_CCLoop:
.0e5f	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e61	f0 0f		beq $0e72			beq 	_CCExit
.0e63	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e65	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e67	d0 02		bne $0e6b			bne 	_CCNoCarry
.0e69	e6 2d		inc $2d				inc 	zTemp0+1
.0e6b					_CCNoCarry:
.0e6b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e6d	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e70	80 ed		bra $0e5f			bra 	_CCLoop						; go round.
.0e72					_CCExit:
.0e72	7a		ply				ply
.0e73	a2 ff		ldx #$ff			ldx 	#$FF
.0e75	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e78					GraphicsColour:
.0e78	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0e7b	aa		tax				tax
.0e7c	a0 00		ldy #$00			ldy 	#0
.0e7e	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e81	60		rts				rts
.0e82					GraphicsCopy4:
.0e82	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e85					GraphicsCopy2:
.0e85	20 88 0e	jsr $0e88			jsr 	GraphicsCopy1
.0e88					GraphicsCopy1:
.0e88	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.0e8b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e8d	99 00 00	sta $0000,y			sta 	0,y
.0e90	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e92	99 01 00	sta $0001,y			sta 	1,y
.0e95	e8		inx				inx
.0e96	c8		iny				iny
.0e97	c8		iny				iny
.0e98	60		rts				rts
.0e99					GraphicsRectCoords:
.0e99	20 78 0e	jsr $0e78			jsr 	GraphicsColour 				; set colour
.0e9c	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e9e	a0 02		ldy #$02			ldy 	#X16_r0
.0ea0	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0ea3	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0ea5	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ea8	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0eaa	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ead	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0eaf	74 09		stz $09,x			stz 	9,x
.0eb1	60		rts				rts
.0eb2					_GRCSortSubtract:
.0eb2	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0eb4	d5 00		cmp $00,x			cmp 	0,x
.0eb6	b5 05		lda $05,x			lda 	5,x
.0eb8	f5 01		sbc $01,x			sbc 	1,x
.0eba	b0 08		bcs $0ec4			bcs 	_GRCNoSwap 					; >= swap.
.0ebc	20 d2 0e	jsr $0ed2			jsr 	_GRCSwapByte 				; swap 0/2
.0ebf	e8		inx				inx
.0ec0	20 d2 0e	jsr $0ed2			jsr 	_GRCSwapByte 				; swap 1/3
.0ec3	ca		dex				dex
.0ec4					_GRCNoSwap:
.0ec4	38		sec				sec 								; calculate width/height into 4,5
.0ec5	b5 04		lda $04,x			lda 	4,x
.0ec7	f5 00		sbc $00,x			sbc 	0,x
.0ec9	95 04		sta $04,x			sta 	4,x
.0ecb	b5 05		lda $05,x			lda 	5,x
.0ecd	f5 01		sbc $01,x			sbc 	1,x
.0ecf	95 05		sta $05,x			sta 	5,x
.0ed1	60		rts				rts
.0ed2					_GRCSwapByte:
.0ed2	b5 04		lda $04,x			lda 	4,x
.0ed4	48		pha				pha
.0ed5	b5 00		lda $00,x			lda 	0,x
.0ed7	95 04		sta $04,x			sta 	4,x
.0ed9	68		pla				pla
.0eda	95 00		sta $00,x			sta 	0,x
.0edc	60		rts				rts
.0edd					Unary16Hex:
.0edd	fa		plx				plx
.0ede	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.0ee1	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0ee3	20 1b 17	jsr $171b			jsr 	StringAllocTemp
.0ee6	a5 2d		lda $2d				lda 	zTemp0+1
.0ee8	f0 03		beq $0eed			beq 	_UHNoHigh
.0eea	20 f5 0e	jsr $0ef5			jsr 	_UHWriteHex
.0eed					_UHNoHigh:
.0eed	a5 2c		lda $2c				lda 	zTemp0
.0eef	20 f5 0e	jsr $0ef5			jsr 	_UHWriteHex
.0ef2	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ef5					_UHWriteHex:
.0ef5	48		pha				pha
.0ef6	4a		lsr a				lsr 	a
.0ef7	4a		lsr a				lsr 	a
.0ef8	4a		lsr a				lsr 	a
.0ef9	4a		lsr a				lsr 	a
.0efa	20 fe 0e	jsr $0efe			jsr 	_UHWriteNibl
.0efd	68		pla				pla
.0efe					_UHWriteNibl:
.0efe	29 0f		and #$0f			and 	#15
.0f00	c9 0a		cmp #$0a			cmp 	#10
.0f02	90 02		bcc $0f06			bcc 	_UHDigit
.0f04	69 06		adc #$06			adc 	#6
.0f06					_UHDigit:
.0f06	69 30		adc #$30			adc 	#48
.0f08	20 44 17	jsr $1744			jsr 	StringWriteChar
.0f0b	60		rts				rts
.0f0c					IndFloatRead:
.0f0c	fa		plx				plx
.0f0d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f0f	85 2c		sta $2c				sta 	zTemp0
.0f11	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f13	18		clc				clc
.0f14	6d 07 04	adc $0407			adc 	variableStartPage
.0f17	85 2d		sta $2d				sta 	zTemp0+1
.0f19	ca		dex				dex 								; throw the address
.0f1a	20 fa 14	jsr $14fa			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0f1d	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f20					IndInt16Read:
.0f20	fa		plx				plx
.0f21	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f23	85 2c		sta $2c				sta 	zTemp0
.0f25	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f27	18		clc				clc
.0f28	6d 07 04	adc $0407			adc 	variableStartPage
.0f2b	85 2d		sta $2d				sta 	zTemp0+1
.0f2d	ca		dex				dex 								; throw the address
.0f2e	20 36 15	jsr $1536			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f31	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f34					IndStringRead:
.0f34	fa		plx				plx
.0f35	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f37	85 2c		sta $2c				sta 	zTemp0
.0f39	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f3b	18		clc				clc
.0f3c	6d 07 04	adc $0407			adc 	variableStartPage
.0f3f	85 2d		sta $2d				sta 	zTemp0+1
.0f41	ca		dex				dex 								; throw the address
.0f42	20 7b 15	jsr $157b			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f45	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f48					IndFloatWrite:
.0f48	fa		plx				plx
.0f49	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f4b	85 2c		sta $2c				sta 	zTemp0
.0f4d	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f4f	18		clc				clc
.0f50	6d 07 04	adc $0407			adc 	variableStartPage
.0f53	85 2d		sta $2d				sta 	zTemp0+1
.0f55	20 d7 1a	jsr $1ad7			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f58	ca		dex				dex 								; throw the address as well.
.0f59	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f5c					IndInt16Write:
.0f5c	fa		plx				plx
.0f5d	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f5f	85 2c		sta $2c				sta 	zTemp0
.0f61	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f63	18		clc				clc
.0f64	6d 07 04	adc $0407			adc 	variableStartPage
.0f67	85 2d		sta $2d				sta 	zTemp0+1
.0f69	20 13 1b	jsr $1b13			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f6c	ca		dex				dex 								; throw the address as well.
.0f6d	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f70					IndStringWrite:
.0f70	fa		plx				plx
.0f71	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f73	85 2c		sta $2c				sta 	zTemp0
.0f75	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f77	18		clc				clc
.0f78	6d 07 04	adc $0407			adc 	variableStartPage
.0f7b	85 2d		sta $2d				sta 	zTemp0+1
.0f7d	20 52 1b	jsr $1b52			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f80	ca		dex				dex 								; throw the address as well.
.0f81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f84					CommandXInput:
.0f84	fa		plx				plx
.0f85	5a		phy				phy 								; save Y
.0f86	e8		inx				inx									; space on stack
.0f87					_INError:
.0f87	20 bb 0f	jsr $0fbb			jsr 	InputStringToBuffer 		; input from keyboard
.0f8a	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.0f8c	85 2c		sta $2c				sta 	0+zTemp0
.0f8e	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f90	85 2d		sta $2d				sta 	1+zTemp0
.0f92	20 62 19	jsr $1962			jsr 	ValEvaluateZTemp0
.0f95	b0 f0		bcs $0f87			bcs 	_INError 					; failed, try again.
.0f97	7a		ply				ply 								; restore Y
.0f98	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f9b					CommandInputString:
.0f9b	fa		plx				plx
.0f9c	5a		phy				phy 								; save Y
.0f9d	20 bb 0f	jsr $0fbb			jsr 	InputStringToBuffer 		; input from keyboard
.0fa0	e8		inx				inx 								; make space on stack
.0fa1	20 71 26	jsr $2671			jsr 	FloatSetZero 				; store as string on stack
.0fa4	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.0fa6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0fa8	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0faa	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0fac	a9 40		lda #$40			lda 	#NSSString
.0fae	95 32		sta $32,x			sta 	NSStatus,x
.0fb0	7a		ply				ply 								; restore Y
.0fb1	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fb4					CommandInputReset:
.0fb4	fa		plx				plx
.0fb5	9c 0c 04	stz $040c			stz 	InputBuffer
.0fb8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fbb					InputStringToBuffer:
.0fbb	a9 f5		lda #$f5			lda 	#((InputBumpNext) & $FF)
.0fbd	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.0fc0	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0fc2	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.0fc5	a9 d2		lda #$d2			lda 	#((InputLookNext) & $FF)
.0fc7	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.0fca	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0fcc	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.0fcf	4c 57 14	jmp $1457			jmp 	GetStringToBuffer
.0fd2					InputLookNext:
.0fd2	da		phx				phx
.0fd3					_ILNRetry:
.0fd3	ad 0c 04	lda $040c			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fd6	d0 08		bne $0fe0			bne 	_ILNNotEmpty
.0fd8	20 f9 0f	jsr $0ff9			jsr 	InputGetNewLine 			; get a new line
.0fdb	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset read position.
.0fde	80 f3		bra $0fd3			bra 	_ILNRetry
.0fe0					_ILNNotEmpty:
.0fe0	ae 5d 04	ldx $045d			ldx 	InputBufferPos 				; get head available character
.0fe3	bd 0c 04	lda $040c,x			lda 	InputBuffer,x
.0fe6	d0 08		bne $0ff0			bne 	_ILNExit 					; if not EOS return it with CC.
.0fe8					_ILNNextLine:
.0fe8	9c 0c 04	stz $040c			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0feb	38		sec				sec 								; return CS,Zero
.0fec	fa		plx				plx
.0fed	a9 0d		lda #$0d			lda 	#13
.0fef	60		rts				rts
.0ff0					_ILNExit:
.0ff0	fa		plx				plx
.0ff1	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0ff3	18		clc				clc
.0ff4	60		rts				rts
.0ff5					InputBumpNext:
.0ff5	ee 5d 04	inc $045d			inc 	InputBufferPos
.0ff8	60		rts				rts
.0ff9					InputGetNewLine:
.0ff9	48		pha				pha
.0ffa	da		phx				phx
.0ffb	5a		phy				phy
.0ffc	a9 3f		lda #$3f			lda 	#"?"
.0ffe	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.1001	a0 00		ldy #$00			ldy 	#0 							; line position.
.1003					_IGNLLoop:
.1003	20 81 13	jsr $1381			jsr 	VectorGetCharacter 			; get a character
.1006	c9 00		cmp #$00			cmp 	#0
.1008	f0 f9		beq $1003			beq 	_IGNLLoop
.100a	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.100c	f0 11		beq $101f			beq 	_IGNBackspace
.100e	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.1010	f0 17		beq $1029			beq 	_IGNExit
.1012	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.1014	f0 ed		beq $1003			beq 	_IGNLLoop
.1016	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1019	c8		iny				iny
.101a	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.101d	80 e4		bra $1003			bra 	_IGNLLoop
.101f					_IGNBackspace:
.101f	c0 00		cpy #$00			cpy 	#0
.1021	f0 e0		beq $1003			beq 	_IGNLLoop
.1023	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.1026	88		dey				dey
.1027	80 da		bra $1003			bra 	_IGNLLoop
.1029					_IGNExit:
.1029	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.102c	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.102e	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1031	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset position to start of input buffer.
.1034	7a		ply				ply
.1035	fa		plx				plx
.1036	68		pla				pla
.1037	60		rts				rts
.1038					IGNLEchoIfScreen:
.1038	ae 5f 04	ldx $045f			ldx 	currentChannel
.103b	d0 03		bne $1040			bne 	_IGNLEExit
.103d	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.1040					_IGNLEExit:
.1040	60		rts				rts
.040c					InputBuffer:
>040c							.fill 	81
.045d					InputBufferPos:
>045d							.fill 	1
.1041					GetInteger8Bit:
.1041	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.1044	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1046	60		rts				rts
.1047					GetInteger16Bit:
.1047	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.104a	34 32		bit $32,x			bit 	NSStatus,x
.104c	30 09		bmi $1057			bmi 	Negate16Bit
.104e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1050	85 2c		sta $2c				sta 	zTemp0
.1052	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1054	85 2d		sta $2d				sta 	zTemp0+1
.1056	60		rts				rts
.1057					Negate16Bit:
.1057	38		sec				sec
.1058	a9 00		lda #$00			lda 	#0
.105a	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.105c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.105e	85 2c		sta $2c				sta 	zTemp0
.1060	a9 00		lda #$00			lda 	#0
.1062	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1064	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1066	85 2d		sta $2d				sta 	zTemp0+1
.1068	60		rts				rts
.1069					UnaryJoy:
.1069	fa		plx				plx
.106a	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; port #
.106d	48		pha				pha 								; zero the result.
.106e	20 71 26	jsr $2671			jsr 	FloatSetZero
.1071	68		pla				pla
.1072	5a		phy				phy
.1073	da		phx				phx
.1074	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1077	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1079	d0 10		bne $108b			bne 	_UJNoHardware
.107b	a8		tay				tay 								; move XA -> AY
.107c	8a		txa				txa
.107d	fa		plx				plx 								; we can update it now.
.107e	49 ff		eor #$ff			eor 	#$FF
.1080	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1082	98		tya				tya
.1083	49 ff		eor #$ff			eor 	#$FF
.1085	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1087	7a		ply				ply 								; restore Y
.1088	4c 4f 08	jmp $084f			jmp 	NextCommand
.108b					_UJNoHardware:
.108b	fa		plx				plx
.108c	7a		ply				ply
.108d	a9 01		lda #$01			lda 	#1 							; set result to -1
.108f	20 73 26	jsr $2673			jsr 	FloatSetByte
.1092	20 33 26	jsr $2633			jsr 	FloatNegate
.1095	4c 4f 08	jmp $084f			jmp 	NextCommand
.1098					UnaryLen:
.1098	fa		plx				plx
.1099	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.109b	85 2c		sta $2c				sta 	zTemp0
.109d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.109f	85 2d		sta $2d				sta 	zTemp0+1
.10a1	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.10a3	20 73 26	jsr $2673			jsr 	FloatSetByte
.10a6	4c 4f 08	jmp $084f			jmp 	NextCommand
.10a9					LinkFloatAdd:
.10a9	fa		plx				plx
.10aa	5a		phy			phy
.10ab	20 95 20	jsr $2095		jsr	FloatAdd
.10ae	7a		ply			ply
.10af	4c 4f 08	jmp $084f			jmp 	NextCommand
.10b2					LinkFloatSubtract:
.10b2	fa		plx				plx
.10b3	5a		phy			phy
.10b4	20 8f 20	jsr $208f		jsr	FloatSubtract
.10b7	7a		ply			ply
.10b8	4c 4f 08	jmp $084f			jmp 	NextCommand
.10bb					LinkFloatMultiply:
.10bb	fa		plx				plx
.10bc	5a		phy			phy
.10bd	20 31 23	jsr $2331		jsr	FloatMultiply
.10c0	7a		ply			ply
.10c1	4c 4f 08	jmp $084f			jmp 	NextCommand
.10c4					LinkFloatDivide:
.10c4	fa		plx				plx
.10c5	5a		phy			phy
.10c6	20 ba 21	jsr $21ba		jsr	FloatDivide
.10c9	b0 5c		bcs $1127		bcs	DivZeroError
.10cb	7a		ply			ply
.10cc	4c 4f 08	jmp $084f			jmp 	NextCommand
.10cf					LinkFloatPower:
.10cf	fa		plx				plx
.10d0	5a		phy			phy
.10d1	20 3a 29	jsr $293a		jsr	FloatPower
.10d4	b0 4e		bcs $1124		bcs	MapRangeError
.10d6	7a		ply			ply
.10d7	4c 4f 08	jmp $084f			jmp 	NextCommand
.10da					LinkCompareGreater:
.10da	fa		plx				plx
.10db	5a		phy			phy
.10dc	20 3e 21	jsr $213e		jsr	CompareGreater
.10df	7a		ply			ply
.10e0	4c 4f 08	jmp $084f			jmp 	NextCommand
.10e3					LinkCompareEqual:
.10e3	fa		plx				plx
.10e4	5a		phy			phy
.10e5	20 20 21	jsr $2120		jsr	CompareEqual
.10e8	7a		ply			ply
.10e9	4c 4f 08	jmp $084f			jmp 	NextCommand
.10ec					LinkCompareLess:
.10ec	fa		plx				plx
.10ed	5a		phy			phy
.10ee	20 36 21	jsr $2136		jsr	CompareLess
.10f1	7a		ply			ply
.10f2	4c 4f 08	jmp $084f			jmp 	NextCommand
.10f5					LinkCompareGreaterEqual:
.10f5	fa		plx				plx
.10f6	5a		phy			phy
.10f7	20 4e 21	jsr $214e		jsr	CompareGreaterEqual
.10fa	7a		ply			ply
.10fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.10fe					LinkCompareNotEqual:
.10fe	fa		plx				plx
.10ff	5a		phy			phy
.1100	20 30 21	jsr $2130		jsr	CompareNotEqual
.1103	7a		ply			ply
.1104	4c 4f 08	jmp $084f			jmp 	NextCommand
.1107					LinkCompareLessEqual:
.1107	fa		plx				plx
.1108	5a		phy			phy
.1109	20 46 21	jsr $2146		jsr	CompareLessEqual
.110c	7a		ply			ply
.110d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1110					LinkFloatIntegerPartDown:
.1110	fa		plx				plx
.1111	5a		phy			phy
.1112	20 d0 22	jsr $22d0		jsr	FloatIntegerPartDown
.1115	7a		ply			ply
.1116	4c 4f 08	jmp $084f			jmp 	NextCommand
.1119					LinkFloatSquareRoot:
.1119	fa		plx				plx
.111a	5a		phy			phy
.111b	20 bc 29	jsr $29bc		jsr	FloatSquareRoot
.111e	b0 04		bcs $1124		bcs	MapRangeError
.1120	7a		ply			ply
.1121	4c 4f 08	jmp $084f			jmp 	NextCommand
.1124					MapRangeError:
.1124	4c fd 1e	jmp $1efd		jmp	ErrorV_range
.1127					DivZeroError:
.1127	4c 86 1f	jmp $1f86		jmp	ErrorV_divzero
.112a					LinkFloatLogarithm:
.112a	fa		plx				plx
.112b	5a		phy			phy
.112c	20 c6 28	jsr $28c6		jsr	FloatLogarithm
.112f	b0 f3		bcs $1124		bcs	MapRangeError
.1131	7a		ply			ply
.1132	4c 4f 08	jmp $084f			jmp 	NextCommand
.1135					LinkFloatExponent:
.1135	fa		plx				plx
.1136	5a		phy			phy
.1137	20 c3 27	jsr $27c3		jsr	FloatExponent
.113a	7a		ply			ply
.113b	4c 4f 08	jmp $084f			jmp 	NextCommand
.113e					LinkFloatCosine:
.113e	fa		plx				plx
.113f	5a		phy			phy
.1140	20 b7 27	jsr $27b7		jsr	FloatCosine
.1143	7a		ply			ply
.1144	4c 4f 08	jmp $084f			jmp 	NextCommand
.1147					LinkFloatSine:
.1147	fa		plx				plx
.1148	5a		phy			phy
.1149	20 57 29	jsr $2957		jsr	FloatSine
.114c	7a		ply			ply
.114d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1150					LinkFloatTangent:
.1150	fa		plx				plx
.1151	5a		phy			phy
.1152	20 c8 29	jsr $29c8		jsr	FloatTangent
.1155	7a		ply			ply
.1156	4c 4f 08	jmp $084f			jmp 	NextCommand
.1159					LinkFloatArcTan:
.1159	fa		plx				plx
.115a	5a		phy			phy
.115b	20 9c 26	jsr $269c		jsr	FloatArcTan
.115e	b0 c4		bcs $1124		bcs	MapRangeError
.1160	7a		ply			ply
.1161	4c 4f 08	jmp $084f			jmp 	NextCommand
.1164					LinkFloatCompare:
.1164	fa		plx				plx
.1165	5a		phy			phy
.1166	20 56 21	jsr $2156		jsr	FloatCompare
.1169	7a		ply			ply
.116a	4c 4f 08	jmp $084f			jmp 	NextCommand
.116d					LinkDivideInt32:
.116d	fa		plx				plx
.116e	5a		phy			phy
.116f	20 e4 21	jsr $21e4		jsr	DivideInt32
.1172	b0 b0		bcs $1124		bcs	MapRangeError
.1174	7a		ply			ply
.1175	4c 4f 08	jmp $084f			jmp 	NextCommand
.1178					StackSaveCurrentPosition:
.1178	20 cb 08	jsr $08cb			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.117b	5a		phy				phy
.117c	a0 02		ldy #$02			ldy 	#2
.117e	a5 28		lda $28				lda 	codePtr
.1180	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1182	c8		iny				iny
.1183	a5 29		lda $29				lda 	codePtr+1
.1185	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1187	7a		ply				ply
.1188	60		rts				rts
.1189					StackLoadCurrentPosition:
.1189	a0 02		ldy #$02			ldy 	#2
.118b	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.118d	85 28		sta $28				sta 	codePtr
.118f	c8		iny				iny
.1190	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1192	85 29		sta $29				sta 	codePtr+1
.1194	a0 00		ldy #$00			ldy 	#0
.1196	60		rts				rts
.1197					XCommandMouse:
.1197	fa		plx				plx
.1198	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; mouse control.
.119b	ca		dex				dex
.119c	da		phx				phx
.119d	5a		phy				phy
.119e	48		pha				pha
.119f	38		sec				sec 								; get screen resolution
.11a0	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.11a3	68		pla				pla
.11a4	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.11a7	7a		ply				ply
.11a8	fa		plx				plx
.11a9	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ac					XUnaryMB:
.11ac	fa		plx				plx
.11ad	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11b0	a5 30		lda $30				lda 	zTemp2
.11b2	e8		inx				inx
.11b3	20 73 26	jsr $2673			jsr 	FloatSetByte
.11b6	4c 4f 08	jmp $084f			jmp 	NextCommand
.11b9					XUnaryMX:
.11b9	fa		plx				plx
.11ba	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11bd	a5 2c		lda $2c				lda 	zTemp0
.11bf	e8		inx				inx
.11c0	20 73 26	jsr $2673			jsr 	FloatSetByte
.11c3	a5 2d		lda $2d				lda 	zTemp0+1
.11c5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11c7	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ca					XUnaryMY:
.11ca	fa		plx				plx
.11cb	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11ce	a5 2e		lda $2e				lda 	zTemp1
.11d0	e8		inx				inx
.11d1	20 73 26	jsr $2673			jsr 	FloatSetByte
.11d4	a5 2f		lda $2f				lda 	zTemp1+1
.11d6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11d8	4c 4f 08	jmp $084f			jmp 	NextCommand
.11db					XUnaryMouseCommon:
.11db	da		phx				phx
.11dc	5a		phy				phy
.11dd	a2 2c		ldx #$2c			ldx 	#zTemp0
.11df	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.11e2	85 30		sta $30				sta 	zTemp2
.11e4	7a		ply				ply
.11e5	fa		plx				plx
.11e6	60		rts				rts
.11e7					NegateTOS:
.11e7	fa		plx				plx
.11e8	20 33 26	jsr $2633			jsr 	FloatNegate
.11eb	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ee					CommandNewLine:
.11ee	fa		plx				plx
.11ef	9c 6a 05	stz $056a			stz 	stringInitialised
.11f2	a2 ff		ldx #$ff			ldx 	#$FF
.11f4	4c 4f 08	jmp $084f			jmp 	NextCommand
.11f7					CommandXNext:
.11f7	fa		plx				plx
.11f8					_CNRetry:
.11f8	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.11fa	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.11fd	20 cb 08	jsr $08cb			jsr 	FixUpY 						; so we can use Y
.1200	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.1202	35 4a		and $4a,x			and 	NSMantissa1,x
.1204	c9 ff		cmp #$ff			cmp 	#$FF
.1206	f0 16		beq $121e			beq 	_CNNoIndexVariable
.1208	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.120a	a0 05		ldy #$05			ldy 	#5
.120c	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.120e	d0 07		bne $1217			bne 	_CNNIndexFail
.1210	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1212	c8		iny				iny
.1213	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.1215	f0 07		beq $121e			beq 	_CNNoIndexVariable
.1217					_CNNIndexFail:
.1217	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.1219	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close this frame
.121c	80 da		bra $11f8			bra 	_CNRetry
.121e					_CNNoIndexVariable:
.121e	ca		dex				dex
.121f	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.1221	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1223	29 40		and #$40			and 	#$40	 					; bit 6
.1225	d0 55		bne $127c			bne 	_CNOptimisedNext
.1227	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1229	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.122b	48		pha				pha
.122c	85 2c		sta $2c				sta 	zTemp0
.122e	c8		iny				iny
.122f	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1231	18		clc				clc
.1232	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1235	48		pha				pha
.1236	85 2d		sta $2d				sta 	zTemp0+1
.1238	20 fa 14	jsr $14fa			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.123b	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.123d	e8		inx				inx
.123e	20 bf 12	jsr $12bf			jsr 	CopyOffsetYToTOS
.1241	20 95 20	jsr $2095			jsr 	FloatAdd
.1244	68		pla				pla 								; restore address
.1245	85 2d		sta $2d				sta 	zTemp0+1
.1247	68		pla				pla
.1248	85 2c		sta $2c				sta 	zTemp0
.124a	20 d7 1a	jsr $1ad7			jsr 	WriteFloatZTemp0Sub			; write float.
.124d	e8		inx				inx  								; recover written
.124e	e8		inx				inx 								; load offset
.124f	a0 0d		ldy #$0d			ldy 	#13
.1251	20 bf 12	jsr $12bf			jsr 	CopyOffsetYToTOS
.1254	20 56 21	jsr $2156			jsr 	FloatCompare 				; and compare the floats.
.1257	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1258	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.125a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.125c	30 08		bmi $1266			bmi 	_CNDownStep
.125e	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1260	c9 01		cmp #$01			cmp 	#1 							; gone higher
.1262	f0 10		beq $1274			beq 	_CNExitFor 					; if so exit the loop
.1264	80 06		bra $126c			bra 	_CNLoopBack
.1266					_CNDownStep:
.1266	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1268	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.126a	f0 08		beq $1274			beq 	_CNExitFor
.126c					_CNLoopBack:
.126c	20 89 11	jsr $1189			jsr 	StackLoadCurrentPosition 	; loop back
.126f	a0 00		ldy #$00			ldy 	#0
.1271	4c 4f 08	jmp $084f			jmp 	NextCommand
.1274					_CNExitFor:
.1274	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; remove the frame and exit
.1277	a0 00		ldy #$00			ldy 	#0
.1279	4c 4f 08	jmp $084f			jmp 	NextCommand
.127c					_CNOptimisedNext:
.127c	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.127e	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1280	85 2c		sta $2c				sta 	zTemp0
.1282	c8		iny				iny
.1283	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1285	18		clc				clc
.1286	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1289	85 2d		sta $2d				sta 	zTemp0+1
.128b	a0 07		ldy #$07			ldy 	#7 							; STEP value
.128d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.128f	a0 ff		ldy #$ff			ldy 	#$FF
.1291	18		clc				clc
.1292					_CNOIncrement:
.1292	c8		iny				iny
.1293	71 2c		adc ($2c),y			adc 	(zTemp0),y
.1295	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1297	f0 f9		beq $1292			beq 	_CNOIncrement
.1299	18		clc				clc
.129a	a5 24		lda $24				lda 	runtimeStackPtr
.129c	69 0d		adc #$0d			adc 	#13
.129e	85 2e		sta $2e				sta 	zTemp1
.12a0	a5 25		lda $25				lda 	runtimeStackPtr+1
.12a2	69 00		adc #$00			adc 	#0
.12a4	85 2f		sta $2f				sta 	zTemp1+1
.12a6	a0 00		ldy #$00			ldy 	#0
.12a8	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.12aa	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.12ac	c8		iny				iny
.12ad	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.12af	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12b1	c8		iny				iny
.12b2	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.12b4	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12b6	c8		iny				iny
.12b7	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.12b9	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12bb	90 b7		bcc $1274			bcc	 	_CNExitFor
.12bd	80 ad		bra $126c			bra 	_CNLoopBack
.12bf					CopyOffsetYToTOS:
.12bf	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.12c3	c8		iny				iny
.12c4	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12c8	c8		iny				iny
.12c9	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12cb	95 56		sta $56,x			sta 	NSMantissa2,x
.12cd	c8		iny				iny
.12ce	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d0	95 62		sta $62,x			sta 	NSMantissa3,x
.12d2	c8		iny				iny
.12d3	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d5	95 6e		sta $6e,x			sta 	NSExponent,x
.12d7	c8		iny				iny
.12d8	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12da	95 32		sta $32,x			sta 	NSStatus,x
.12dc	60		rts				rts
.12dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.12e0					NotTOS:
.12e0	fa		plx				plx
.12e1	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.12e4	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.12e6	74 62		stz $62,x			stz 	NSMantissa3,x
.12e8	20 33 26	jsr $2633			jsr 	FloatNegate		 			; negate
.12eb	e8		inx				inx 								; and subtract 1.
.12ec	a9 01		lda #$01			lda 	#1
.12ee	20 73 26	jsr $2673			jsr 	FloatSetByte
.12f1	20 8f 20	jsr $208f			jsr 	FloatSubtract
.12f4					_NotTOSSkip:
.12f4	4c 4f 08	jmp $084f			jmp 	NextCommand
.12f7					CommandXOn:
.12f7	fa		plx				plx
.12f8	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.12fb	8d 5e 04	sta $045e			sta 	onCount 					; save it.
.12fe	20 cb 08	jsr $08cb			jsr 	FixUpY 						; Y = 0
.1301					_CONFind:
.1301	ce 5e 04	dec $045e			dec 	onCount 					; reached zero, do this one
.1304	f0 0b		beq $1311			beq 	_CONFound
.1306	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1307	c8		iny				iny
.1308	c8		iny				iny
.1309	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.130b	c8		iny				iny
.130c	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.130e	f0 f1		beq $1301			beq 	_CONFind
.1310	88		dey				dey 								; point to character after last GOTO/GOSUB
.1311					_CONFound:
.1311	4c 4f 08	jmp $084f			jmp 	NextCommand
.1314					CommandMoreOn:
.1314	fa		plx				plx
.1315	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1316	c8		iny				iny
.1317	c8		iny				iny
.1318	4c 4f 08	jmp $084f			jmp 	NextCommand
.045e					onCount:
>045e							.fill 	1
.131b					UnaryPeek:
.131b	fa		plx				plx
.131c	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.131f	da		phx				phx
.1320	5a		phy				phy
.1321	a6 2c		ldx $2c				ldx 	zTemp0
.1323	a4 2d		ldy $2d				ldy 	zTemp0+1
.1325	20 71 1c	jsr $1c71			jsr 	XPeekMemory
.1328	7a		ply				ply
.1329	fa		plx				plx
.132a	20 73 26	jsr $2673			jsr 	FloatSetByte
.132d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1330					UnaryPI:
.1330	fa		plx				plx
.1331	a9 19		lda #$19			lda 	#Const_pi-Const_base
.1333	20 a1 28	jsr $28a1			jsr 	LoadConstant
.1336	e8		inx				inx
.1337	4c 4f 08	jmp $084f			jmp 	NextCommand
.133a					CommandPOKE:
.133a	fa		plx				plx
.133b	da		phx				phx 								; save XY
.133c	5a		phy				phy
.133d	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1340	48		pha				pha
.1341	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1343	a8		tay				tay
.1344	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1346	aa		tax				tax
.1347	68		pla				pla
.1348	20 5d 1c	jsr $1c5d			jsr 	XPokeMemory
.134b	7a		ply				ply 								; restore YX and drop 2
.134c	fa		plx				plx
.134d	ca		dex				dex
.134e	ca		dex				dex
.134f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1352					UnaryPos:
.1352	fa		plx				plx
.1353	20 f0 1b	jsr $1bf0			jsr 	XGetHPos
.1356	20 73 26	jsr $2673			jsr 	FloatSetByte
.1359	4c 4f 08	jmp $084f			jmp 	NextCommand
.135c					GetChannel:
.135c	fa		plx				plx
.135d	ad 5f 04	lda $045f			lda 	currentChannel
.1360	e8		inx				inx
.1361	20 73 26	jsr $2673			jsr 	FloatSetByte
.1364	4c 4f 08	jmp $084f			jmp 	NextCommand
.1367					SetChannel:
.1367	fa		plx				plx
.1368	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.136b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.136d	8d 5f 04	sta $045f			sta 	currentChannel
.1370	ca		dex				dex
.1371	4c 4f 08	jmp $084f			jmp 	NextCommand
.1374					SetDefaultChannel:
.1374	9c 5f 04	stz $045f			stz 	currentChannel
.1377	60		rts				rts
.1378					VectorPrintCharacter:
.1378	da		phx				phx
.1379	ae 5f 04	ldx $045f			ldx 	currentChannel
.137c	20 9b 1c	jsr $1c9b			jsr 	XPrintCharacterToChannel
.137f	fa		plx				plx
.1380	60		rts				rts
.1381					VectorGetCharacter:
.1381	da		phx				phx
.1382	ae 5f 04	ldx $045f			ldx 	currentChannel
.1385	20 d4 1b	jsr $1bd4			jsr 	XGetCharacterFromChannel
.1388	fa		plx				plx
.1389	60		rts				rts
.045f					currentChannel:
>045f							.fill 	1
.138a					PrintNumber:
.138a	fa		plx				plx
.138b	a9 07		lda #$07			lda 	#7
.138d	20 59 25	jsr $2559			jsr 	FloatToString 				; to number in decimal buffer
.1390	ca		dex				dex 								; drop
.1391	da		phx				phx
.1392	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1394					_PNLoop:
.1394	bd 98 05	lda $0598,x			lda 	decimalBuffer,x
.1397	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.139a	e8		inx				inx
.139b	bd 98 05	lda $0598,x			lda	 	decimalBuffer,x
.139e	d0 f4		bne $1394			bne 	_PNLoop
.13a0	a9 20		lda #$20			lda 	#32 						; trailing space
.13a2	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.13a5	fa		plx				plx
.13a6	4c 4f 08	jmp $084f			jmp 	NextCommand
.13a9					PrintString:
.13a9	fa		plx				plx
.13aa	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.13ac	85 2c		sta $2c				sta 	zTemp0
.13ae	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.13b0	85 2d		sta $2d				sta 	zTemp0+1
.13b2	ca		dex				dex 								; drop
.13b3	da		phx				phx
.13b4	5a		phy				phy
.13b5	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.13b7	aa		tax				tax
.13b8	a0 01		ldy #$01			ldy 	#1 							; Y = position
.13ba					_PSLoop:
.13ba	e0 00		cpx #$00			cpx 	#0 							; complete ?
.13bc	f0 09		beq $13c7			beq 	_PSExit
.13be	ca		dex				dex 								; dec count
.13bf	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.13c1	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.13c4	c8		iny				iny
.13c5	80 f3		bra $13ba			bra 	_PSLoop
.13c7					_PSExit:
.13c7	7a		ply				ply
.13c8	fa		plx				plx
.13c9	4c 4f 08	jmp $084f			jmp 	NextCommand
.13cc					CommandPushN:
.13cc	fa		plx				plx
.13cd	e8		inx				inx 								; next slot on stack
.13ce	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.13d0	95 6e		sta $6e,x			sta 	NSExponent,x
.13d2	c8		iny				iny
.13d3	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.13d5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13d7	c8		iny				iny
.13d8	b1 28		lda ($28),y			lda 	(codePtr),y
.13da	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13dc	c8		iny				iny
.13dd	b1 28		lda ($28),y			lda 	(codePtr),y
.13df	95 56		sta $56,x			sta 	NSMantissa2,x
.13e1	c8		iny				iny
.13e2	b1 28		lda ($28),y			lda 	(codePtr),y
.13e4	48		pha				pha
.13e5	29 7f		and #$7f			and 	#$7F
.13e7	95 62		sta $62,x			sta 	NSMantissa3,x
.13e9	68		pla				pla 								; sign in mantissa3:7
.13ea	29 80		and #$80			and 	#$80
.13ec	95 32		sta $32,x			sta 	NSStatus,x
.13ee	c8		iny				iny
.13ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.13f2					CommandPushS:
.13f2	fa		plx				plx
.13f3	e8		inx				inx 								; next slot on stack
.13f4	18		clc				clc
.13f5	98		tya				tya
.13f6	65 28		adc $28				adc 	codePtr 					; the string is inline
.13f8	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13fa	a5 29		lda $29				lda 	codePtr+1
.13fc	69 00		adc #$00			adc 	#0
.13fe	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1400	74 56		stz $56,x			stz 	NSMantissa2,x
.1402	74 62		stz $62,x			stz 	NSMantissa3,x
.1404	a9 40		lda #$40			lda 	#NSSString
.1406	95 32		sta $32,x			sta 	NSStatus,x
.1408	98		tya				tya 								; string length +1 added to Y
.1409	38		sec				sec
.140a	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.140c	a8		tay				tay
.140d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1410					CommandXRead:
.1410	fa		plx				plx
.1411	5a		phy				phy 								; save Y
.1412	20 43 14	jsr $1443			jsr 	ReadStringToBuffer 			; read element into buffer
.1415	e8		inx				inx									; space on stack
.1416	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.1418	85 2c		sta $2c				sta 	0+zTemp0
.141a	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.141c	85 2d		sta $2d				sta 	1+zTemp0
.141e	20 62 19	jsr $1962			jsr 	ValEvaluateZTemp0
.1421	b0 04		bcs $1427			bcs 	_CRError 					; failed
.1423	7a		ply				ply 								; restore Y
.1424	4c 4f 08	jmp $084f			jmp 	NextCommand
.1427					_CRError:
.1427	4c 0d 1f	jmp $1f0d		jmp	ErrorV_value
.142a					CommandReadString:
.142a	fa		plx				plx
.142b	5a		phy				phy 								; save Y
.142c	20 43 14	jsr $1443			jsr 	ReadStringToBuffer 			; read text
.142f	e8		inx				inx 								; make space on stack
.1430	20 71 26	jsr $2671			jsr 	FloatSetZero 				; store as string on stack
.1433	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.1435	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1437	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.1439	95 4a		sta $4a,x			sta 	NSMantissa1,x
.143b	a9 40		lda #$40			lda 	#NSSString
.143d	95 32		sta $32,x			sta 	NSStatus,x
.143f	7a		ply				ply 								; restore Y
.1440	4c 4f 08	jmp $084f			jmp 	NextCommand
.1443					ReadStringToBuffer:
.1443	a9 d6		lda #$d6			lda 	#((ReadBumpNext) & $FF)
.1445	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.1448	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.144a	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.144d	a9 a9		lda #$a9			lda 	#((ReadLookNext) & $FF)
.144f	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.1452	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.1454	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.1457					GetStringToBuffer:
.1457	20 a6 14	jsr $14a6			jsr		GetLookNext 				; skip all leading spaces.
.145a	f0 44		beq $14a0			beq 	_RBError 					; end of data
.145c	b0 f9		bcs $1457			bcs 	GetStringToBuffer 			; switched to new data line.
.145e	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1460	b0 05		bcs $1467			bcs 	_RBNoSpace
.1462	20 a3 14	jsr $14a3			jsr 	GetBumpNext 				; consume space and loop round.
.1465	80 f0		bra $1457			bra 	GetStringToBuffer
.1467					_RBNoSpace:
.1467	9c 61 04	stz $0461			stz 	ReadBufferSize 				; empty the buffer.
.146a	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.146c	d0 08		bne $1476			bne 	_RBCommaSep
.146e	8d 60 04	sta $0460			sta 	ReadSep 					; use as a seperator
.1471	20 a3 14	jsr $14a3			jsr 	GetBumpNext 				; consume the '"'
.1474	80 05		bra $147b			bra 	_RBGetText
.1476					_RBCommaSep:
.1476	a9 2c		lda #$2c			lda 	#","						; get till comma
.1478	8d 60 04	sta $0460			sta 	ReadSep
.147b					_RBGetText:
.147b	20 a6 14	jsr $14a6			jsr 	GetLookNext 				; what follows
.147e	b0 18		bcs $1498			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.1480	20 a3 14	jsr $14a3			jsr 	GetBumpNext 				; consume it whatever
.1483	cd 60 04	cmp $0460			cmp 	ReadSep 					; if found the seperator.
.1486	f0 10		beq $1498			beq 	_RBEndGet 					; exit after consumption
.1488	da		phx				phx
.1489	ae 61 04	ldx $0461			ldx 	ReadBufferSize 				; copy into buffer.
.148c	ee 61 04	inc $0461			inc 	ReadBufferSize
.148f	9d 62 04	sta $0462,x			sta 	ReadBuffer,x
.1492	9e 63 04	stz $0463,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.1495	fa		plx				plx
.1496	80 e3		bra $147b			bra 	_RBGetText
.1498					_RBEndGet:
.1498	c9 22		cmp #$22			cmp 	#'"'
.149a	d0 03		bne $149f			bne 	_RBNotQuote
.149c	20 a3 14	jsr $14a3			jsr 	GetBumpNext
.149f					_RBNotQuote:
.149f	60		rts				rts
.14a0					_RBError:
.14a0	4c c2 1f	jmp $1fc2		jmp	ErrorV_data
.14a3					GetBumpNext:
.14a3	6c 61 05	jmp ($0561)			jmp 	(ReadBumpNextVec)
.14a6					GetLookNext:
.14a6	6c 63 05	jmp ($0563)			jmp 	(ReadLookNextVec)
.14a9					ReadLookNext:
.14a9	ad 65 05	lda $0565			lda 	dataRemaining 				; any data remaining
.14ac	f0 04		beq $14b2			beq 	_RLNFindData
.14ae	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.14b0	18		clc				clc
.14b1	60		rts				rts
.14b2					_RLNFindData:
.14b2	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.14b4	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.14b6	f0 1a		beq $14d2			beq 	_RLNNoData
.14b8	c9 d0		cmp #$d0			cmp 	#PCD_CMD_DATA 				; Found DATA
.14ba	f0 05		beq $14c1			beq 	_RLNHaveData
.14bc					_RLNNext:
.14bc	20 40 20	jsr $2040			jsr 	MoveObjectForward			; else scan forward.
.14bf	80 f1		bra $14b2			bra 	_RLNFindData
.14c1					_RLNHaveData:
.14c1	a0 01		ldy #$01			ldy 	#1 							; get length
.14c3	b1 2a		lda ($2a),y			lda 	(objPtr),y
.14c5	f0 f5		beq $14bc			beq 	_RLNNext 					; skip if DATA alone
.14c7	20 d6 14	jsr $14d6			jsr 	ReadBumpNext 				; advance by two
.14ca	20 d6 14	jsr $14d6			jsr 	ReadBumpNext
.14cd	8d 65 05	sta $0565			sta 	dataRemaining 				; set data left count.
.14d0	38		sec				sec
.14d1	60		rts				rts
.14d2					_RLNNoData:
.14d2	a9 00		lda #$00			lda 	#0
.14d4	38		sec				sec
.14d5	60		rts				rts
.14d6					ReadBumpNext:
.14d6	e6 2a		inc $2a				inc 	objPtr
.14d8	d0 02		bne $14dc			bne 	_RBNSkip
.14da	e6 2b		inc $2b				inc 	objPtr+1
.14dc					_RBNSkip:
.14dc	ce 65 05	dec $0565			dec 	dataRemaining
.14df	60		rts				rts
.0460					ReadSep:
>0460							.fill 	1
.0461					ReadBufferSize:
>0461							.fill 	1
.0462					ReadBuffer:
>0462							.fill 	255
.0561					ReadBumpNextVec:
>0561							.fill 	2
.0563					ReadLookNextVec:
>0563							.fill 	2
.14e0					ReadFloatCommand:
.14e0	fa		plx				plx
.14e1	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14e3	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14e5	88		dey				dey 								; get the upper 3 bits
.14e6	b1 28		lda ($28),y			lda 	(codePtr),y
.14e8	29 07		and #$07			and 	#7
.14ea	c8		iny				iny
.14eb	c8		iny				iny
.14ec	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14ee	2a		rol a				rol 	a 							; carry will be clear.
.14ef	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14f2	85 2d		sta $2d				sta 	zTemp0+1
.14f4	20 fa 14	jsr $14fa			jsr 	ReadFloatZTemp0Sub
.14f7	4c 4f 08	jmp $084f			jmp 	NextCommand
.14fa					ReadFloatZTemp0Sub:
.14fa	5a		phy				phy 								; start write
.14fb	a0 01		ldy #$01			ldy 	#1
.14fd	e8		inx				inx
.14fe	b2 2c		lda ($2c)			lda 	(zTemp0)
.1500	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1502	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1504	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1506	c8		iny				iny
.1507	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1509	95 56		sta $56,x			sta 	NSMantissa2,x
.150b	c8		iny				iny
.150c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.150e	95 62		sta $62,x			sta 	NSMantissa3,x
.1510	c8		iny				iny
.1511	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1513	95 6e		sta $6e,x			sta 	NSExponent,x
.1515	c8		iny				iny
.1516	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1518	95 32		sta $32,x			sta 	NSStatus,x
.151a	7a		ply				ply
.151b	60		rts				rts
.151c					ReadIntegerCommand:
.151c	fa		plx				plx
.151d	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.151f	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1521	88		dey				dey 								; get the upper 3 bits
.1522	b1 28		lda ($28),y			lda 	(codePtr),y
.1524	29 07		and #$07			and 	#7
.1526	c8		iny				iny
.1527	c8		iny				iny
.1528	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.152a	2a		rol a				rol 	a 							; carry will be clear.
.152b	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.152e	85 2d		sta $2d				sta 	zTemp0+1
.1530	20 36 15	jsr $1536			jsr 	ReadIntegerZTemp0Sub
.1533	4c 4f 08	jmp $084f			jmp 	NextCommand
.1536					ReadIntegerZTemp0Sub:
.1536	5a		phy				phy 								; start write
.1537	a0 01		ldy #$01			ldy 	#1
.1539	e8		inx				inx 								; prepare
.153a	74 56		stz $56,x			stz 	NSMantissa2,x
.153c	74 62		stz $62,x			stz 	NSMantissa3,x
.153e	74 6e		stz $6e,x			stz 	NSExponent,x
.1540	74 32		stz $32,x			stz 	NSStatus,x
.1542	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1544	30 08		bmi $154e			bmi 	_RIZNegative
.1546	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1548	b2 2c		lda ($2c)			lda 	(zTemp0)
.154a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.154c	7a		ply				ply
.154d	60		rts				rts
.154e					_RIZNegative:
.154e	38		sec				sec 								; -ve read
.154f	a9 00		lda #$00			lda 	#0
.1551	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.1553	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1555	a9 00		lda #$00			lda 	#0
.1557	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1559	95 4a		sta $4a,x			sta 	NSMantissa1,x
.155b	a9 80		lda #$80			lda 	#$80
.155d	95 32		sta $32,x			sta 	NSStatus,x
.155f	7a		ply				ply
.1560	60		rts				rts
.1561					ReadStringCommand:
.1561	fa		plx				plx
.1562	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1564	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1566	88		dey				dey 								; get the upper 3 bits
.1567	b1 28		lda ($28),y			lda 	(codePtr),y
.1569	29 07		and #$07			and 	#7
.156b	c8		iny				iny
.156c	c8		iny				iny
.156d	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.156f	2a		rol a				rol 	a 							; carry will be clear.
.1570	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1573	85 2d		sta $2d				sta 	zTemp0+1
.1575	20 7b 15	jsr $157b			jsr 	ReadStringZTemp0Sub
.1578	4c 4f 08	jmp $084f			jmp 	NextCommand
.157b					ReadStringZTemp0Sub:
.157b	5a		phy				phy 								; start write
.157c	e8		inx				inx 								; prepare
.157d	74 56		stz $56,x			stz 	NSMantissa2,x
.157f	74 62		stz $62,x			stz 	NSMantissa3,x
.1581	74 6e		stz $6e,x			stz 	NSExponent,x
.1583	a9 40		lda #$40			lda 	#NSSString
.1585	74 32		stz $32,x			stz 	NSStatus,x
.1587	18		clc				clc
.1588	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.158a	69 02		adc #$02			adc 	#2 							; this points to actual data
.158c	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.158e	a0 01		ldy #$01			ldy 	#1
.1590	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1592	69 00		adc #$00			adc 	#0
.1594	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1596	d0 08		bne $15a0			bne 	_RSZNoDefault 				; if read $00 use a default value.
.1598	a9 a2		lda #$a2			lda 	#_RSZNull & $FF
.159a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.159c	a9 15		lda #$15			lda 	#_RSZNull >> 8
.159e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15a0					_RSZNoDefault:
.15a0	7a		ply				ply
.15a1	60		rts				rts
.15a2					_RSZNull:
>15a2	00						.byte 	0
.15a3					CommandRestore:
.15a3	fa		plx				plx
.15a4	20 aa 15	jsr $15aa			jsr 	RestoreCode
.15a7	4c 4f 08	jmp $084f			jmp 	NextCommand
.15aa					RestoreCode:
.15aa	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.15ad	85 2b		sta $2b				sta 	objPtr+1
.15af	64 2a		stz $2a				stz 	objPtr
.15b1	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15b4	60		rts				rts
.0565					dataRemaining:
>0565							.fill 	1		 					; 0 if not in data statement
.15b5					UnaryRND:
.15b5	fa		plx				plx
.15b6	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.15b8	10 17		bpl $15d1			bpl 	_URNoSeed
.15ba	20 c6 23	jsr $23c6			jsr 	FloatNormalise 				; some float value
.15bd	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.15bf	8d 66 05	sta $0566			sta 	randomSeed+0
.15c2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15c4	8d 67 05	sta $0567			sta 	randomSeed+1
.15c7	b5 56		lda $56,x			lda 	NSMantissa2,x
.15c9	8d 68 05	sta $0568			sta 	randomSeed+2
.15cc	b5 62		lda $62,x			lda 	NSMantissa3,x
.15ce	8d 69 05	sta $0569			sta 	randomSeed+3
.15d1					_URNoSeed:
.15d1	20 f3 15	jsr $15f3			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.15d4	ad 66 05	lda $0566			lda 	randomSeed+0
.15d7	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15d9	ad 67 05	lda $0567			lda 	randomSeed+1
.15dc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15de	ad 68 05	lda $0568			lda 	randomSeed+2
.15e1	95 56		sta $56,x			sta 	NSMantissa2,x
.15e3	ad 69 05	lda $0569			lda 	randomSeed+3
.15e6	29 7f		and #$7f			and 	#$7F
.15e8	95 62		sta $62,x			sta 	NSMantissa3,x
.15ea	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.15ec	95 6e		sta $6e,x			sta 	NSExponent,x
.15ee	74 32		stz $32,x			stz 	NSStatus,x
.15f0	4c 4f 08	jmp $084f			jmp 	NextCommand
.15f3					RandomNumberGenerator:
.15f3	5a		phy				phy
.15f4	ad 66 05	lda $0566			lda 	randomSeed+0 				; check if zero
.15f7	0d 67 05	ora $0567			ora 	randomSeed+1
.15fa	0d 68 05	ora $0568			ora 	randomSeed+2
.15fd	0d 69 05	ora $0569			ora 	randomSeed+3
.1600	d0 07		bne $1609			bne 	_RNGNoSeed
.1602	ce 69 05	dec $0569			dec 	randomSeed+3 				; if so tweak and flog
.1605	a0 64		ldy #$64			ldy 	#100
.1607	80 05		bra $160e			bra 	_RNGLoop
.1609					_RNGNoSeed:
.1609	a0 08		ldy #$08			ldy 	#8
.160b	ad 66 05	lda $0566			lda 	randomSeed+0
.160e					_RNGLoop:
.160e	0a		asl a				asl		a
.160f	2e 67 05	rol $0567			rol 	randomSeed+1
.1612	2e 68 05	rol $0568			rol 	randomSeed+2
.1615	2e 69 05	rol $0569			rol 	randomSeed+3
.1618	90 02		bcc $161c			bcc		_RNGSkip
.161a	49 c5		eor #$c5			eor 	#$C5
.161c					_RNGSkip:
.161c	88		dey				dey
.161d	d0 ef		bne $160e			bne		_RNGLoop
.161f	8d 66 05	sta $0566			sta 	randomSeed+0
.1622	7a		ply				ply
.1623	60		rts				rts
.0566					randomSeed:
>0566							.fill 	4
.1624					StringConcatenate:
.1624	fa		plx				plx
.1625	ca		dex				dex
.1626	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.1628	85 2e		sta $2e				sta 	zTemp1
.162a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.162c	85 2f		sta $2f				sta 	zTemp1+1
.162e	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.1630	85 30		sta $30				sta 	zTemp2
.1632	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.1634	85 31		sta $31				sta 	zTemp2+1
.1636	18		clc				clc 								; work out total length
.1637	b2 2e		lda ($2e)			lda 	(zTemp1)
.1639	72 30		adc ($30)			adc 	(zTemp2)
.163b	b0 18		bcs $1655			bcs 	_BCLength 					; more than 255 characters.
.163d	48		pha				pha 								; save total
.163e	20 1b 17	jsr $171b			jsr 	StringAllocTemp 			; space for result.
.1641	68		pla				pla 								; write total as first.
.1642	92 22		sta ($22)			sta 	(zsTemp)
.1644	20 58 16	jsr $1658			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.1647	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.1649	85 2e		sta $2e				sta 	zTemp1
.164b	a5 31		lda $31				lda 	zTemp2+1
.164d	85 2f		sta $2f				sta 	zTemp1+1
.164f	20 58 16	jsr $1658			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1652	4c 4f 08	jmp $084f			jmp 	NextCommand
.1655					_BCLength:
.1655	4c fd 1e	jmp $1efd		jmp	ErrorV_range
.1658					_BCCopyZTemp1:
.1658	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.165a	f0 15		beq $1671			beq 	_BCCExit 					; none.
.165c	da		phx				phx 								; save XY
.165d	5a		phy				phy
.165e	aa		tax				tax 								; count in X.
.165f	a0 01		ldy #$01			ldy 	#1
.1661					_BCCLoop:
.1661	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1663	d0 02		bne $1667			bne 	_BCCNoCarry
.1665	e6 23		inc $23				inc 	zsTemp+1
.1667					_BCCNoCarry:
.1667	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.1669	92 22		sta ($22)			sta 	(zsTemp)
.166b	c8		iny				iny
.166c	ca		dex				dex 								; X times
.166d	d0 f2		bne $1661			bne 	_BCCLoop
.166f	7a		ply				ply 								; restore YX
.1670	fa		plx				plx
.1671					_BCCExit:
.1671	60		rts				rts
.1672					XRuntimeSetup:
.1672	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1674	8d 6d 05	sta $056d	 		sta 	ramBank
.1677	8d 6e 05	sta $056e	 		sta 	romBank
.167a	60		rts				rts
.167b					SignTOS:
.167b	fa		plx				plx
.167c	20 93 26	jsr $2693			jsr 	FloatIsZero 				; if zero
.167f	f0 0f		beq $1690			beq 	_SGZero  					; return Int Zero
.1681	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.1683	48		pha				pha
.1684	a9 01		lda #$01			lda 	#1 							; set result to 1
.1686	20 73 26	jsr $2673			jsr 	FloatSetByte
.1689	68		pla				pla
.168a	29 80		and #$80			and		#$80 						; copy the sign byte out
.168c	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.168e	80 03		bra $1693			bra 	_SGExit
.1690					_SGZero:
.1690	20 71 26	jsr $2671			jsr 	FloatSetZero
.1693					_SGExit:
.1693	4c 4f 08	jmp $084f			jmp 	NextCommand
.1696					CommandShift:
.1696	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.1698	c8		iny				iny
.1699	0a		asl a				asl 	a 							; double into X
.169a	aa		tax				tax
.169b	7c 48 1a	jmp ($1a48,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.169e					PrintTab:
.169e	fa		plx				plx
.169f	20 f0 1b	jsr $1bf0			jsr 	XGetHPos
.16a2					_PTMod10:
.16a2	38		sec				sec
.16a3	e9 0a		sbc #$0a			sbc 	#10
.16a5	b0 fb		bcs $16a2			bcs 	_PTMod10
.16a7	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.16a9	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.16aa	80 15		bra $16c1			bra 	PrintSpaceLoop
.16ac					PrintPos:
.16ac	fa		plx				plx
.16ad	20 f0 1b	jsr $1bf0			jsr		XGetHPos 					; get current position
.16b0	85 2c		sta $2c				sta 	zTemp0
.16b2	38		sec				sec 								; calculate spaces required
.16b3	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16b5	ca		dex				dex
.16b6	e5 2c		sbc $2c				sbc 	zTemp0
.16b8	b0 07		bcs $16c1			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.16ba	4c 4f 08	jmp $084f			jmp 	NextCommand
.16bd					PrintSpace:
.16bd	fa		plx				plx
.16be	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16c0	ca		dex				dex
.16c1					PrintSpaceLoop:
.16c1	c9 00		cmp #$00			cmp 	#0
.16c3	f0 0a		beq $16cf			beq 	_PSExit
.16c5	48		pha				pha
.16c6	a9 20		lda #$20			lda 	#" "
.16c8	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.16cb	68		pla				pla
.16cc	3a		dec a				dec 	a
.16cd	80 f2		bra $16c1			bra 	PrintSpaceLoop
.16cf					_PSExit:
.16cf	4c 4f 08	jmp $084f			jmp 	NextCommand
.16d2					CommandStop:
.16d2	fa		plx				plx
.16d3	4c af 1f	jmp $1faf		jmp	ErrorV_stop
.16d6					Unary_Str:
.16d6	fa		plx				plx
.16d7	5a		phy				phy
.16d8	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.16da	20 59 25	jsr $2559			jsr 	FloatToString 				; do the conversion.
.16dd	a9 21		lda #$21			lda		#33 						; create buffer
.16df	20 1b 17	jsr $171b			jsr 	StringAllocTemp 			; allocate memory
.16e2	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.16e4					_USCopy:
.16e4	b9 97 05	lda $0597,y			lda 	decimalBuffer-1,y
.16e7	f0 05		beq $16ee			beq 	_USExit
.16e9	91 22		sta ($22),y			sta 	(zsTemp),y
.16eb	c8		iny				iny
.16ec	80 f6		bra $16e4			bra 	_USCopy
.16ee					_USExit:
.16ee	98		tya				tya
.16ef	3a		dec a				dec 	a
.16f0	92 22		sta ($22)			sta 	(zsTemp)
.16f2	7a		ply				ply
.16f3	4c 4f 08	jmp $084f			jmp 	NextCommand
.16f6					StringInitialise:
.16f6	48		pha				pha
.16f7	ad 6a 05	lda $056a			lda 	stringInitialised 			; already done
.16fa	d0 11		bne $170d			bne 	_SIExit
.16fc	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.16ff	8d 6b 05	sta $056b			sta 	stringTempPointer
.1702	ad 03 04	lda $0403			lda 	stringHighMemory+1
.1705	3a		dec a				dec 	a
.1706	3a		dec a				dec 	a
.1707	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.170a	ce 6a 05	dec $056a			dec 	stringInitialised 			; set the initialised flag.
.170d					_SIExit:
.170d	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.170f	1a		inc a				inc 	a
.1710	1a		inc a				inc 	a
.1711	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.1714	b0 02		bcs $1718			bcs 	_SIMemory
.1716	68		pla				pla
.1717	60		rts				rts
.1718					_SIMemory:
.1718	4c 08 20	jmp $2008		jmp	ErrorV_memory
.171b					StringAllocTemp:
.171b	20 f6 16	jsr $16f6			jsr 	StringInitialise 			; check it is initialised.
.171e	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.1720	18		clc				clc
.1721	6d 6b 05	adc $056b			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.1724	8d 6b 05	sta $056b			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.1727	85 22		sta $22				sta 	zsTemp
.1729	95 3e		sta $3e,x			sta 	NSMantissa0,x
.172b	ad 6c 05	lda $056c			lda 	stringTempPointer+1
.172e	69 ff		adc #$ff			adc 	#$FF
.1730	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.1733	85 23		sta $23				sta 	zsTemp+1
.1735	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1737	74 56		stz $56,x			stz 	NSMantissa2,x
.1739	74 62		stz $62,x			stz 	NSMantissa3,x
.173b	a9 00		lda #$00			lda 	#0 							; clear string.
.173d	92 22		sta ($22)			sta 	(zsTemp)
.173f	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1741	95 32		sta $32,x			sta 	NSStatus,x
.1743	60		rts				rts
.1744					StringWriteChar:
.1744	5a		phy				phy
.1745	48		pha				pha
.1746	b2 22		lda ($22)			lda 	(zsTemp)
.1748	1a		inc a				inc 	a
.1749	92 22		sta ($22)			sta 	(zsTemp)
.174b	a8		tay				tay
.174c	68		pla				pla
.174d	91 22		sta ($22),y			sta 	(zsTemp),y
.174f	7a		ply				ply
.1750	60		rts				rts
.056a					stringInitialised:
>056a							.fill 	1
.056b					stringTempPointer:
>056b							.fill 	2
.1751					Unary_Left:
.1751	fa		plx				plx
.1752	5a		phy				phy
.1753	18		clc				clc 								; only one parameter
.1754	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the length of the string.
.1757	48		pha				pha
.1758	ca		dex				dex
.1759	a9 00		lda #$00			lda 	#0 							; push the start position.
.175b	48		pha				pha
.175c	20 94 17	jsr $1794			jsr 	UnarySStringToZTemp0
.175f	80 3c		bra $179d			bra 	SubstringMain 				; stack now points to the string to slice.
.1761					Unary_Right:
.1761	fa		plx				plx
.1762	5a		phy				phy
.1763	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.1765	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the right length of the string.
.1768	48		pha				pha
.1769	ca		dex				dex
.176a	20 94 17	jsr $1794			jsr 	UnarySStringToZTemp0
.176d	68		pla				pla 								; this is the right requirement
.176e	38		sec				sec
.176f	49 ff		eor #$ff			eor 	#$FF
.1771	72 2c		adc ($2c)			adc 	(zTemp0)
.1773	b0 02		bcs $1777			bcs 	_URHaveCount
.1775	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.1777					_URHaveCount:
.1777	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.1779	5a		phy				phy
.177a	48		pha				pha 								; start position
.177b	80 20		bra $179d			bra 	SubstringMain
.177d					Unary_Mid:
.177d	fa		plx				plx
.177e	5a		phy				phy
.177f	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the length of the string required.
.1782	48		pha				pha
.1783	ca		dex				dex
.1784	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; put the start position.
.1787	f0 08		beq $1791			beq 	_UMError
.1789	3a		dec a				dec 	a
.178a	48		pha				pha
.178b	ca		dex				dex
.178c	20 94 17	jsr $1794			jsr 	UnarySStringToZTemp0
.178f	80 0c		bra $179d			bra 	SubstringMain 				; stack now points to the string to slice.
.1791					_UMError:
.1791	4c fd 1e	jmp $1efd		jmp	ErrorV_range
.1794					UnarySStringToZTemp0:
.1794	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1796	85 2c		sta $2c				sta 	zTemp0
.1798	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.179a	85 2d		sta $2d				sta 	zTemp0+1
.179c	60		rts				rts
.179d					SubstringMain:
.179d	68		pla				pla 								; get the start offset
.179e	7a		ply				ply 								; get the count to do.
.179f	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.17a1	b0 38		bcs $17db			bcs 	_SSReturnNull
.17a3	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.17a5	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.17a7	18		clc				clc
.17a8	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.17aa	b0 06		bcs $17b2			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.17ac	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.17ae	f0 04		beq $17b4			beq 	_SMIsOkay
.17b0	90 02		bcc $17b4			bcc 	_SMIsOkay
.17b2					_SMTruncateToEnd:
.17b2	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.17b4					_SMIsOkay:
.17b4	85 2f		sta $2f				sta 	zTemp1+1
.17b6	38		sec				sec		 							; work out size
.17b7	a5 2f		lda $2f				lda 	zTemp1+1
.17b9	e5 2e		sbc $2e				sbc 	zTemp1
.17bb	f0 1e		beq $17db			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.17bd	20 1b 17	jsr $171b			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.17c0	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.17c2					_SMCopy:
.17c2	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.17c4	f0 11		beq $17d7			beq 	_SMExit
.17c6	c8		iny				iny 								; bump and
.17c7	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.17c9	5a		phy				phy
.17ca	48		pha				pha
.17cb	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.17cd	1a		inc a				inc 	a
.17ce	a8		tay				tay
.17cf	92 22		sta ($22)			sta 	(zsTemp)
.17d1	68		pla				pla 								; write character out
.17d2	91 22		sta ($22),y			sta 	(zsTemp),y
.17d4	7a		ply				ply 								; restore Y
.17d5	80 eb		bra $17c2			bra 	_SMCopy
.17d7					_SMExit:
.17d7	7a		ply				ply
.17d8	4c 4f 08	jmp $084f			jmp 	NextCommand
.17db					_SSReturnNull:
.17db	a9 ed		lda #$ed			lda 	#SSRNull & $FF 				; set up mantissa
.17dd	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17df	a9 17		lda #$17			lda 	#SSRNull >> 8
.17e1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17e3	74 56		stz $56,x			stz 	NSMantissa2,x
.17e5	74 62		stz $62,x			stz 	NSMantissa3,x
.17e7	a9 40		lda #$40			lda 	#NSSString
.17e9	95 32		sta $32,x			sta 	NSStatus,x
.17eb	80 ea		bra $17d7			bra 	_SMExit
.17ed					SSRNull:
>17ed	00 00						.word 	0
.17ef					CommandSwap:
.17ef	fa		plx				plx
.17f0	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17f2	48		pha				pha
.17f3	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.17f5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17f7	68		pla				pla
.17f8	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.17fa	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17fc	48		pha				pha
.17fd	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.17ff	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1801	68		pla				pla
.1802	95 49		sta $49,x			sta 	NSMantissa1-1,x
.1804	b5 56		lda $56,x			lda 	NSMantissa2,x
.1806	48		pha				pha
.1807	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.1809	95 56		sta $56,x			sta 	NSMantissa2,x
.180b	68		pla				pla
.180c	95 55		sta $55,x			sta 	NSMantissa2-1,x
.180e	b5 62		lda $62,x			lda 	NSMantissa3,x
.1810	48		pha				pha
.1811	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.1813	95 62		sta $62,x			sta 	NSMantissa3,x
.1815	68		pla				pla
.1816	95 61		sta $61,x			sta 	NSMantissa3-1,x
.1818	b5 6e		lda $6e,x			lda 	NSExponent,x
.181a	48		pha				pha
.181b	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.181d	95 6e		sta $6e,x			sta 	NSExponent,x
.181f	68		pla				pla
.1820	95 6d		sta $6d,x			sta 	NSExponent-1,x
.1822	b5 32		lda $32,x			lda 	NSStatus,x
.1824	48		pha				pha
.1825	b5 31		lda $31,x			lda 	NSStatus-1,x
.1827	95 32		sta $32,x			sta 	NSStatus,x
.1829	68		pla				pla
.182a	95 31		sta $31,x			sta 	NSStatus-1,x
.182c	4c 4f 08	jmp $084f			jmp 	NextCommand
.182f					CommandSYS:
.182f	fa		plx				plx
.1830	da		phx				phx 								; save XY
.1831	5a		phy				phy
.1832	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.1835	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.1837	85 2d		sta $2d				sta 	zTemp0+1
.1839	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.183b	85 2c		sta $2c				sta 	zTemp0
.183d	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1840	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.1843	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.1846	48		pha				pha
.1847	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.184a	28		plp				plp
.184b	20 62 18	jsr $1862			jsr 	_CSZTemp0
.184e	08		php				php
.184f	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1852	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.1855	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.1858	68		pla				pla
.1859	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.185c	7a		ply				ply 								; restore YX and drop 2
.185d	fa		plx				plx
.185e	ca		dex				dex
.185f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1862					_CSZTemp0:
.1862	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.1865					TimeTOS:
.1865	fa		plx				plx
.1866	20 c0 18	jsr $18c0			jsr 	TIPushClock 				; push clock to TOS
.1869	4c 4f 08	jmp $084f			jmp 	NextCommand
.186c					TimeString:
.186c	fa		plx				plx
.186d	20 c0 18	jsr $18c0			jsr 	TIPushClock 				; push clock to TOS
.1870	20 95 18	jsr $1895			jsr 	_TSDivMod60 				; result in seconds
.1873	20 95 18	jsr $1895			jsr 	_TSDivMod60 				; seconds
.1876	48		pha				pha
.1877	20 95 18	jsr $1895			jsr 	_TSDivMod60 				; minutes
.187a	48		pha				pha
.187b	a9 18		lda #$18			lda 	#24 						; hours
.187d	20 97 18	jsr $1897			jsr 	_TSDivModA
.1880	48		pha				pha
.1881	a9 06		lda #$06			lda 	#6
.1883	20 1b 17	jsr $171b			jsr 	StringAllocTemp
.1886	68		pla				pla
.1887	20 a7 18	jsr $18a7			jsr 	_TSWriteDecimal
.188a	68		pla				pla
.188b	20 a7 18	jsr $18a7			jsr 	_TSWriteDecimal
.188e	68		pla				pla
.188f	20 a7 18	jsr $18a7			jsr 	_TSWriteDecimal
.1892	4c 4f 08	jmp $084f			jmp 	NextCommand
.1895					_TSDivMod60:
.1895	a9 3c		lda #$3c			lda 	#60
.1897					_TSDivModA:
.1897	e8		inx				inx
.1898	20 73 26	jsr $2673			jsr 	FloatSetByte
.189b	ca		dex				dex
.189c	20 07 22	jsr $2207			jsr 	Int32Divide
.189f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.18a1	48		pha				pha
.18a2	20 f6 21	jsr $21f6			jsr 	NSMCopyPlusTwoToZero
.18a5	68		pla				pla
.18a6	60		rts				rts
.18a7					_TSWriteDecimal:
.18a7	da		phx				phx
.18a8	a2 30		ldx #$30			ldx 	#'0'
.18aa					_TSWDLoop:
.18aa	c9 0a		cmp #$0a			cmp 	#10
.18ac	90 05		bcc $18b3			bcc 	_TSWDEnd
.18ae	e9 0a		sbc #$0a			sbc 	#10
.18b0	e8		inx				inx
.18b1	80 f7		bra $18aa			bra 	_TSWDLoop
.18b3					_TSWDEnd:
.18b3	48		pha				pha
.18b4	8a		txa				txa
.18b5	20 44 17	jsr $1744			jsr 	StringWriteChar
.18b8	68		pla				pla
.18b9	09 30		ora #$30			ora 	#'0'
.18bb	20 44 17	jsr $1744			jsr 	StringWriteChar
.18be	fa		plx				plx
.18bf	60		rts				rts
.18c0					TIPushClock:
.18c0	5a		phy				phy
.18c1	e8		inx				inx 								; push 0 on the stack
.18c2	20 71 26	jsr $2671			jsr 	FloatSetZero
.18c5	da		phx				phx
.18c6	20 bb 1c	jsr $1cbb			jsr 	XReadClock 					; read time into YXA
.18c9	86 2c		stx $2c				stx 	zTemp0
.18cb	fa		plx				plx
.18cc	95 3e		sta $3e,x			sta 	NSMantissa0,x
.18ce	a5 2c		lda $2c				lda 	zTemp0
.18d0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.18d2	98		tya				tya
.18d3	95 56		sta $56,x			sta 	NSMantissa2,x
.18d5	7a		ply				ply
.18d6	60		rts				rts
.18d7					CommandTIWrite:
.18d7	fa		plx				plx
.18d8	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.18da	85 22		sta $22				sta 	zsTemp
.18dc	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.18de	85 23		sta $23				sta 	zsTemp+1
.18e0	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.18e2	c9 06		cmp #$06			cmp 	#6
.18e4	d0 59		bne $193f			bne 	_CTIWError
.18e6	20 71 26	jsr $2671			jsr 	FloatSetZero
.18e9	20 0b 19	jsr $190b			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.18ec	20 0b 19	jsr $190b			jsr 	_CTIWDigitPair
.18ef	20 0b 19	jsr $190b			jsr 	_CTIWDigitPair
.18f2	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.18f4	20 36 19	jsr $1936			jsr 	_CTIWMultiply
.18f7	da		phx				phx
.18f8	5a		phy				phy
.18f9	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.18fb	48		pha				pha
.18fc	b5 56		lda $56,x			lda 	NSMantissa2,x
.18fe	a8		tay				tay
.18ff	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1901	fa		plx				plx
.1902	20 bf 1c	jsr $1cbf			jsr 	XWriteClock 				; update the clock.
.1905	7a		ply				ply
.1906	fa		plx				plx
.1907	ca		dex				dex 								; throw result.
.1908	4c 4f 08	jmp $084f			jmp 	NextCommand
.190b					_CTIWDigitPair:
.190b	a9 06		lda #$06			lda 	#6 							; x 6
.190d	20 36 19	jsr $1936			jsr 	_CTIWMultiply
.1910	20 1c 19	jsr $191c			jsr 	_CTIWAddDigit 				; add digit
.1913	a9 0a		lda #$0a			lda 	#10 						; x 10
.1915	20 36 19	jsr $1936			jsr 	_CTIWMultiply
.1918	20 1c 19	jsr $191c			jsr 	_CTIWAddDigit 				; add digit
.191b	60		rts				rts
.191c					_CTIWAddDigit:
.191c	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.191e	d0 02		bne $1922			bne 	_CTIWASkip
.1920	e6 23		inc $23				inc 	zsTemp+1
.1922					_CTIWASkip:
.1922	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.1924	38		sec				sec
.1925	e9 30		sbc #$30			sbc 	#"0"
.1927	90 16		bcc $193f			bcc 	_CTIWError
.1929	c9 0a		cmp #$0a			cmp 	#9+1
.192b	b0 12		bcs $193f			bcs 	_CTIWError
.192d	e8		inx				inx 								; store at +1
.192e	20 73 26	jsr $2673			jsr 	FloatSetByte
.1931	ca		dex				dex
.1932	20 fd 23	jsr $23fd			jsr 	FloatAddTopTwoStack
.1935	60		rts				rts
.1936					_CTIWMultiply:
.1936	e8		inx				inx
.1937	20 73 26	jsr $2673			jsr 	FloatSetByte
.193a	ca		dex				dex
.193b	20 7e 23	jsr $237e			jsr 	FloatMultiplyShort
.193e	60		rts				rts
.193f					_CTIWError:
.193f	4c 0d 1f	jmp $1f0d		jmp	ErrorV_value
.1942					UnaryUsr:
.1942	fa		plx				plx
.1943	5a		phy				phy
.1944	20 4b 19	jsr $194b			jsr 	_UUCallVector
.1947	7a		ply				ply
.1948	4c 4f 08	jmp $084f			jmp 	NextCommand
.194b					_UUCallVector:
.194b	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.194e					ValUnary:
.194e	fa		plx				plx
.194f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1951	85 2c		sta $2c				sta 	zTemp0
.1953	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1955	85 2d		sta $2d				sta 	zTemp0+1
.1957	20 62 19	jsr $1962			jsr 	ValEvaluateZTemp0
.195a	b0 03		bcs $195f			bcs 	_VUError 					; couldn't convert
.195c	4c 4f 08	jmp $084f			jmp 	NextCommand
.195f					_VUError:
.195f	4c 0d 1f	jmp $1f0d		jmp	ErrorV_value
.1962					ValEvaluateZTemp0:
.1962	5a		phy				phy
.1963	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.1965	f0 22		beq $1989			beq 	_VMCFail2
.1967	a0 00		ldy #$00			ldy 	#0 							; start position
.1969					_VMCSpaces:
.1969	c8		iny				iny 								; skip leading spaces
.196a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.196c	c9 20		cmp #$20			cmp 	#" "
.196e	f0 f9		beq $1969			beq 	_VMCSpaces
.1970	48		pha				pha 								; save first character
.1971	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.1973	d0 01		bne $1976			bne 	_VMCStart
.1975	c8		iny				iny 								; skip over - if so.
.1976					_VMCStart:
.1976	38		sec				sec 								; initialise first time round.
.1977					_VMCNext:
.1977	98		tya				tya 								; reached end of string
.1978	3a		dec a				dec 	a
.1979	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.197b	f0 0f		beq $198c			beq 	_VMCSuccess 				; successful.
.197d	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.197f	c8		iny				iny
.1980	20 55 24	jsr $2455			jsr 	FloatEncode 				; send it to the number-builder
.1983	90 03		bcc $1988			bcc 	_VMCFail 					; if failed, give up.
.1985	18		clc				clc 								; next time round, countinue
.1986	80 ef		bra $1977			bra 	_VMCNext
.1988					_VMCFail:
.1988	68		pla				pla
.1989					_VMCFail2:
.1989	7a		ply				ply
.198a	38		sec				sec
.198b	60		rts				rts
.198c					_VMCSuccess:
.198c	a9 00		lda #$00			lda 	#0 							; construct final
.198e	20 55 24	jsr $2455			jsr 	FloatEncode 				; by sending a duff value.
.1991	68		pla				pla 								; if it was -ve
.1992	c9 2d		cmp #$2d			cmp 	#"-"
.1994	d0 03		bne $1999			bne 	_VMCNotNegative
.1996	20 33 26	jsr $2633			jsr		FloatNegate 				; negate it.
.1999					_VMCNotNegative:
.1999	7a		ply				ply
.199a	18		clc				clc
.199b	60		rts				rts
.199c					VectorTable:
>199c	a9 10					.word	LinkFloatAdd             ; $80 +
>199e	b2 10					.word	LinkFloatSubtract        ; $81 -
>19a0	bb 10					.word	LinkFloatMultiply        ; $82 *
>19a2	c4 10					.word	LinkFloatDivide          ; $83 /
>19a4	cf 10					.word	LinkFloatPower           ; $84 ^
>19a6	f2 08					.word	BinaryAnd                ; $85 and
>19a8	f6 08					.word	BinaryOr                 ; $86 or
>19aa	da 10					.word	LinkCompareGreater       ; $87 >
>19ac	e3 10					.word	LinkCompareEqual         ; $88 =
>19ae	ec 10					.word	LinkCompareLess          ; $89 <
>19b0	f5 10					.word	LinkCompareGreaterEqual  ; $8a >=
>19b2	fe 10					.word	LinkCompareNotEqual      ; $8b <>
>19b4	07 11					.word	LinkCompareLessEqual     ; $8c <=
>19b6	da 08					.word	AbsoluteTOS              ; $8d abs
>19b8	2d 09					.word	ArrayConvert             ; $8e array
>19ba	d5 09					.word	UnaryAsc                 ; $8f asc
>19bc	f0 09					.word	CommandAssert            ; $90 assert
>19be	31 0a					.word	Unary16Bin               ; $91 bin$
>19c0	5b 0a					.word	PrintCharacterX          ; $92 print.chr
>19c2	65 0a					.word	UnaryChr                 ; $93 chr$
>19c4	ca 0a					.word	CompareStrings           ; $94 s.cmp
>19c6	b6 0c					.word	CommandXFor              ; $95 for
>19c8	79 0d					.word	UnaryFre                 ; $96 fre
>19ca	91 0d					.word	CommandXGet              ; $97 get
>19cc	b7 0d					.word	CommandReturn            ; $98 return
>19ce	f9 0d					.word	Command_PSET             ; $99 pset
>19d0	13 0e					.word	Command_LINE             ; $9a line
>19d2	28 0e					.word	Command_RECT             ; $9b rect
>19d4	37 0e					.word	Command_FRAME            ; $9c frame
>19d6	46 0e					.word	Command_CHAR             ; $9d char
>19d8	dd 0e					.word	Unary16Hex               ; $9e hex$
>19da	84 0f					.word	CommandXInput            ; $9f input
>19dc	9b 0f					.word	CommandInputString       ; $a0 input$
>19de	b4 0f					.word	CommandInputReset        ; $a1 input.start
>19e0	98 10					.word	UnaryLen                 ; $a2 len
>19e2	64 11					.word	LinkFloatCompare         ; $a3 f.cmp
>19e4	6d 11					.word	LinkDivideInt32          ; $a4 int.div
>19e6	e7 11					.word	NegateTOS                ; $a5 negate
>19e8	ee 11					.word	CommandNewLine           ; $a6 new.line
>19ea	f7 11					.word	CommandXNext             ; $a7 next
>19ec	e0 12					.word	NotTOS                   ; $a8 not
>19ee	f7 12					.word	CommandXOn               ; $a9 on
>19f0	14 13					.word	CommandMoreOn            ; $aa moreon
>19f2	1b 13					.word	UnaryPeek                ; $ab peek
>19f4	30 13					.word	UnaryPI                  ; $ac pi
>19f6	3a 13					.word	CommandPOKE              ; $ad poke
>19f8	52 13					.word	UnaryPos                 ; $ae pos
>19fa	5c 13					.word	GetChannel               ; $af getchannel
>19fc	67 13					.word	SetChannel               ; $b0 setchannel
>19fe	8a 13					.word	PrintNumber              ; $b1 print.n
>1a00	a9 13					.word	PrintString              ; $b2 print.s
>1a02	10 14					.word	CommandXRead             ; $b3 read
>1a04	2a 14					.word	CommandReadString        ; $b4 read$
>1a06	b5 15					.word	UnaryRND                 ; $b5 rnd
>1a08	24 16					.word	StringConcatenate        ; $b6 concat
>1a0a	7b 16					.word	SignTOS                  ; $b7 sgn
>1a0c	9e 16					.word	PrintTab                 ; $b8 print.tab
>1a0e	ac 16					.word	PrintPos                 ; $b9 print.pos
>1a10	bd 16					.word	PrintSpace               ; $ba print.spc
>1a12	d6 16					.word	Unary_Str                ; $bb str$
>1a14	51 17					.word	Unary_Left               ; $bc left$
>1a16	61 17					.word	Unary_Right              ; $bd right$
>1a18	7d 17					.word	Unary_Mid                ; $be mid$
>1a1a	ef 17					.word	CommandSwap              ; $bf swap
>1a1c	65 18					.word	TimeTOS                  ; $c0 ti
>1a1e	6c 18					.word	TimeString               ; $c1 ti$
>1a20	42 19					.word	UnaryUsr                 ; $c2 usr
>1a22	4e 19					.word	ValUnary                 ; $c3 val
>1a24	b7 1b					.word	CommandClose             ; $c4 close
>1a26	c9 1b					.word	CommandExit              ; $c5 exit
>1a28	cf 1b					.word	CommandDebug             ; $c6 debug
>1a2a	35 1c					.word	CommandXOpen             ; $c7 open
>1a2c	c9 1c					.word	CommandScreen            ; $c8 screen
>1a2e	ad 1e					.word	CommandVPOKE             ; $c9 vpoke
>1a30	d2 1e					.word	CommandVPEEK             ; $ca vpeek
>1a32	96 16					.word	CommandShift             ; $cb .shift
>1a34	9e 08					.word	PushByteCommand          ; $cc .byte
>1a36	b1 08					.word	PushWordCommand          ; $cd .word
>1a38	cc 13					.word	CommandPushN             ; $ce .float
>1a3a	f2 13					.word	CommandPushS             ; $cf .string
>1a3c	52 0b					.word	CommandXData             ; $d0 .data
>1a3e	c8 0d					.word	CommandXGoto             ; $d1 .goto
>1a40	ab 0d					.word	CommandXGosub            ; $d2 .gosub
>1a42	dd 0d					.word	CommandGotoZ             ; $d3 .goto.z
>1a44	eb 0d					.word	CommandGotoNZ            ; $d4 .goto.nz
>1a46	e0 08					.word	CommandVarSpace          ; $d5 .varspace
.1a48					ShiftVectorTable:
>1a48	7d 0a					.word	CommandClr               ; $cb80 clr
>1a4a	5b 0b					.word	CommandXDIM              ; $cb81 dim
>1a4c	4c 0c					.word	CommandEnd               ; $cb82 end
>1a4e	69 10					.word	UnaryJoy                 ; $cb83 joy
>1a50	10 11					.word	LinkFloatIntegerPartDown ; $cb84 int
>1a52	19 11					.word	LinkFloatSquareRoot      ; $cb85 sqr
>1a54	2a 11					.word	LinkFloatLogarithm       ; $cb86 log
>1a56	35 11					.word	LinkFloatExponent        ; $cb87 exp
>1a58	3e 11					.word	LinkFloatCosine          ; $cb88 cos
>1a5a	47 11					.word	LinkFloatSine            ; $cb89 sin
>1a5c	50 11					.word	LinkFloatTangent         ; $cb8a tan
>1a5e	59 11					.word	LinkFloatArcTan          ; $cb8b atn
>1a60	97 11					.word	XCommandMouse            ; $cb8c mouse
>1a62	ac 11					.word	XUnaryMB                 ; $cb8d mb
>1a64	b9 11					.word	XUnaryMX                 ; $cb8e mx
>1a66	ca 11					.word	XUnaryMY                 ; $cb8f my
>1a68	a3 15					.word	CommandRestore           ; $cb90 restore
>1a6a	d2 16					.word	CommandStop              ; $cb91 stop
>1a6c	2f 18					.word	CommandSYS               ; $cb92 sys
>1a6e	d7 18					.word	CommandTIWrite           ; $cb93 ti$.write
>1a70	a6 1a					.word	CommandXWAIT             ; $cb94 wait
>1a72	fa 1b					.word	X16I2CPoke               ; $cb95 i2cpoke
>1a74	1a 1c					.word	X16I2CPeek               ; $cb96 i2cpeek
>1a76	85 1c					.word	CommandBank              ; $cb97 bank
>1a78	d8 1c					.word	XCommandSleep            ; $cb98 sleep
>1a7a	fc 1c					.word	X16_Audio_FMINIT         ; $cb99 fminit
>1a7c	0a 1d					.word	X16_Audio_FMNOTE         ; $cb9a fmnote
>1a7e	1c 1d					.word	X16_Audio_FMDRUM         ; $cb9b fmdrum
>1a80	2e 1d					.word	X16_Audio_FMINST         ; $cb9c fminst
>1a82	40 1d					.word	X16_Audio_FMVIB          ; $cb9d fmvib
>1a84	52 1d					.word	X16_Audio_FMFREQ         ; $cb9e fmfreq
>1a86	63 1d					.word	X16_Audio_FMVOL          ; $cb9f fmvol
>1a88	75 1d					.word	X16_Audio_FMPAN          ; $cba0 fmpan
>1a8a	87 1d					.word	X16_Audio_FMPLAY         ; $cba1 fmplay
>1a8c	98 1d					.word	X16_Audio_FMCHORD        ; $cba2 fmchord
>1a8e	a9 1d					.word	X16_Audio_FMPOKE         ; $cba3 fmpoke
>1a90	bb 1d					.word	X16_Audio_PSGINIT        ; $cba4 psginit
>1a92	c9 1d					.word	X16_Audio_PSGNOTE        ; $cba5 psgnote
>1a94	db 1d					.word	X16_Audio_PSGVOL         ; $cba6 psgvol
>1a96	ed 1d					.word	X16_Audio_PSGWAV         ; $cba7 psgwav
>1a98	ff 1d					.word	X16_Audio_PSGFREQ        ; $cba8 psgfreq
>1a9a	10 1e					.word	X16_Audio_PSGPAN         ; $cba9 psgpan
>1a9c	22 1e					.word	X16_Audio_PSGPLAY        ; $cbaa psgplay
>1a9e	33 1e					.word	X16_Audio_PSGCHORD       ; $cbab psgchord
>1aa0	44 1e					.word	CommandCls               ; $cbac cls
>1aa2	4d 1e					.word	CommandLocate            ; $cbad locate
>1aa4	74 1e					.word	CommandColor             ; $cbae color
.1aa6					CommandXWAIT:
.1aa6	fa		plx				plx
.1aa7	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1aa9	85 2c		sta $2c				sta 	zTemp0
.1aab	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1aad	85 2d		sta $2d				sta 	zTemp0+1
.1aaf					_WaitLoop:
.1aaf	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1ab1	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1ab3	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1ab5	f0 f8		beq $1aaf			beq 	_WaitLoop 					; keep going if zero
.1ab7	ca		dex				dex 								; drop 3.
.1ab8	ca		dex				dex
.1ab9	ca		dex				dex
.1aba	4c 4f 08	jmp $084f			jmp 	NextCommand
.1abd					WriteFloatCommand:
.1abd	fa		plx				plx
.1abe	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1ac0	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1ac2	88		dey				dey 								; get the upper 3 bits
.1ac3	b1 28		lda ($28),y			lda 	(codePtr),y
.1ac5	29 07		and #$07			and 	#7
.1ac7	c8		iny				iny
.1ac8	c8		iny				iny
.1ac9	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1acb	2a		rol a				rol 	a 							; carry will be clear.
.1acc	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1acf	85 2d		sta $2d				sta 	zTemp0+1
.1ad1	20 d7 1a	jsr $1ad7			jsr 	WriteFloatZTemp0Sub
.1ad4	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ad7					WriteFloatZTemp0Sub:
.1ad7	5a		phy				phy 								; ldart write
.1ad8	a0 01		ldy #$01			ldy 	#1
.1ada	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1adc	92 2c		sta ($2c)			sta 	(zTemp0)
.1ade	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ae0	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ae2	c8		iny				iny
.1ae3	b5 56		lda $56,x			lda 	NSMantissa2,x
.1ae5	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ae7	c8		iny				iny
.1ae8	b5 62		lda $62,x			lda 	NSMantissa3,x
.1aea	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1aec	c8		iny				iny
.1aed	b5 6e		lda $6e,x			lda 	NSExponent,x
.1aef	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1af1	c8		iny				iny
.1af2	b5 32		lda $32,x			lda 	NSStatus,x
.1af4	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1af6	ca		dex				dex
.1af7	7a		ply				ply
.1af8	60		rts				rts
.1af9					WriteIntegerCommand:
.1af9	fa		plx				plx
.1afa	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1afc	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1afe	88		dey				dey 								; get the upper 3 bits
.1aff	b1 28		lda ($28),y			lda 	(codePtr),y
.1b01	29 07		and #$07			and 	#7
.1b03	c8		iny				iny
.1b04	c8		iny				iny
.1b05	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b07	2a		rol a				rol 	a 							; carry will be clear.
.1b08	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b0b	85 2d		sta $2d				sta 	zTemp0+1
.1b0d	20 13 1b	jsr $1b13			jsr 	WriteIntegerZTemp0Sub
.1b10	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b13					WriteIntegerZTemp0Sub:
.1b13	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.1b16	5a		phy				phy 								; start write
.1b17	a0 01		ldy #$01			ldy 	#1
.1b19	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1b1b	30 0b		bmi $1b28			bmi 	_WIZNegative
.1b1d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1b1f	92 2c		sta ($2c)			sta 	(zTemp0)
.1b21	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b23	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b25	7a		ply				ply
.1b26	ca		dex				dex
.1b27	60		rts				rts
.1b28					_WIZNegative:
.1b28	38		sec				sec 								; -ve read
.1b29	a9 00		lda #$00			lda 	#0
.1b2b	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1b2d	92 2c		sta ($2c)			sta 	(zTemp0)
.1b2f	a9 00		lda #$00			lda 	#0
.1b31	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1b33	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b35	7a		ply				ply
.1b36	ca		dex				dex
.1b37	60		rts				rts
.1b38					WriteStringCommand:
.1b38	fa		plx				plx
.1b39	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b3b	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b3d	88		dey				dey 								; get the upper 3 bits
.1b3e	b1 28		lda ($28),y			lda 	(codePtr),y
.1b40	29 07		and #$07			and 	#7
.1b42	c8		iny				iny
.1b43	c8		iny				iny
.1b44	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b46	2a		rol a				rol 	a 							; carry will be clear.
.1b47	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b4a	85 2d		sta $2d				sta 	zTemp0+1
.1b4c	20 52 1b	jsr $1b52			jsr 	WriteStringZTemp0Sub
.1b4f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b52					WriteStringZTemp0Sub:
.1b52	5a		phy				phy
.1b53	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b55	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b57	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b59	f0 1e		beq $1b79			beq 	_WSConcrete
.1b5b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b5d	85 2e		sta $2e				sta 	zTemp1
.1b5f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b61	85 2f		sta $2f				sta 	zTemp1+1
.1b63	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b65	85 30		sta $30				sta 	zTemp2
.1b67	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b69	85 31		sta $31				sta 	zTemp2+1
.1b6b	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1b6d	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1b6f	b0 17		bcs $1b88			bcs 	_WSCopy
.1b71	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1b73	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b75	09 80		ora #$80			ora 	#$80
.1b77	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1b79					_WSConcrete:
.1b79	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1b7b	a8		tay				tay
.1b7c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b7e	20 0c 0b	jsr $0b0c			jsr 	StringConcrete
.1b81	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1b83	98		tya				tya
.1b84	a0 01		ldy #$01			ldy 	#1
.1b86	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b88					_WSCopy
.1b88	18		clc				clc  								; copy target+2 to zTemp2
.1b89	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b8b	69 02		adc #$02			adc 	#2
.1b8d	85 30		sta $30				sta 	zTemp2
.1b8f	a0 01		ldy #$01			ldy 	#1
.1b91	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b93	69 00		adc #$00			adc 	#0
.1b95	85 31		sta $31				sta 	zTemp2+1
.1b97	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1b99	85 2e		sta $2e				sta 	zTemp1
.1b9b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b9d	85 2f		sta $2f				sta 	zTemp1+1
.1b9f	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1ba1	a8		tay				tay
.1ba2					_WSCopyLoop:
.1ba2	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1ba4	91 30		sta ($30),y			sta 	(zTemp2),y
.1ba6	88		dey				dey
.1ba7	c0 ff		cpy #$ff			cpy 	#$FF
.1ba9	d0 f7		bne $1ba2			bne 	_WSCopyLoop
.1bab	ca		dex				dex
.1bac	7a		ply				ply
.1bad	60		rts				rts
.1bae					XCheckStop:
.1bae	20 e1 ff	jsr $ffe1			jsr 	$FFE1 						; check stop
.1bb1	f0 01		beq $1bb4			beq 	_XCSStop
.1bb3	60		rts				rts
.1bb4					_XCSStop:
.1bb4	4c 2f 20	jmp $202f		jmp	ErrorV_break
.1bb7					CommandClose:
.1bb7	fa		plx				plx
.1bb8	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; channel to close
.1bbb	cd 5f 04	cmp $045f			cmp 	currentChannel 				; is it the current channel
.1bbe	d0 03		bne $1bc3			bne 	_CCNotCurrent
.1bc0	9c 5f 04	stz $045f			stz 	currentChannel 				; effectively disables CMD
.1bc3					_CCNotCurrent:
.1bc3	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1bc6	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bc9					CommandExit:
.1bc9	fa		plx				plx
.1bca	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1bcc	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1bcf					CommandDebug:
.1bcf	fa		plx				plx
>1bd0	db						.byte 	$DB 						; causes a break in the emulator
.1bd1	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bd4					XGetCharacterFromChannel:
.1bd4	da		phx				phx
.1bd5	5a		phy				phy
.1bd6	e0 00		cpx #$00			cpx 	#0 							; is it default
.1bd8	d0 05		bne $1bdf			bne 	_XGetChannel
.1bda	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1bdd	80 08		bra $1be7			bra 	_XGetChar
.1bdf					_XGetChannel:
.1bdf	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1be2	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1be5	d0 06		bne $1bed			bne 	_XGCError
.1be7					_XGetChar:
.1be7	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1bea	7a		ply				ply
.1beb	fa		plx				plx
.1bec	60		rts				rts
.1bed					_XGCError:
.1bed	4c 19 20	jmp $2019		jmp	ErrorV_channel
.1bf0					XGetHPos:
.1bf0	da		phx				phx
.1bf1	5a		phy				phy
.1bf2	38		sec				sec
.1bf3	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1bf6	98		tya				tya
.1bf7	7a		ply				ply
.1bf8	fa		plx				plx
.1bf9	60		rts				rts
.1bfa					X16I2CPoke:
.1bfa	fa		plx				plx
.1bfb	5a		phy				phy
.1bfc	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; value
.1bff	48		pha				pha
.1c00	ca		dex				dex
.1c01	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; register
.1c04	48		pha				pha
.1c05	ca		dex				dex
.1c06	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; device
.1c09	aa		tax				tax
.1c0a	7a		ply				ply
.1c0b	68		pla				pla
.1c0c	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1c0f	b0 06		bcs $1c17			bcs 	X16I2CError
.1c11	7a		ply				ply
.1c12	a2 ff		ldx #$ff			ldx 	#$FF
.1c14	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c17					X16I2CError:
.1c17	4c 19 20	jmp $2019		jmp	ErrorV_channel
.1c1a					X16I2CPeek:
.1c1a	fa		plx				plx
.1c1b	da		phx				phx
.1c1c	5a		phy				phy
.1c1d	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; register
.1c20	48		pha				pha
.1c21	ca		dex				dex
.1c22	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; device
.1c25	aa		tax				tax 								; X device
.1c26	7a		ply				ply 								; Y register
.1c27	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1c2a	b0 eb		bcs $1c17			bcs 	X16I2CError
.1c2c	7a		ply				ply 								; restore Y/X
.1c2d	fa		plx				plx
.1c2e	ca		dex				dex 								; drop TOS (register)
.1c2f	20 73 26	jsr $2673			jsr 	FloatSetByte 				; write read value to TOS.
.1c32	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c35					CommandXOpen:
.1c35	fa		plx				plx
.1c36	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1c38	85 2c		sta $2c				sta 	zTemp0
.1c3a	aa		tax				tax
.1c3b	a5 4d		lda $4d				lda 	NSMantissa1+3
.1c3d	85 2d		sta $2d				sta 	zTemp0+1
.1c3f	a8		tay				tay
.1c40	e8		inx				inx 								; XY points to first character
.1c41	d0 01		bne $1c44			bne 	_CONoCarry
.1c43	c8		iny				iny
.1c44					_CONoCarry:
.1c44	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c46	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c49	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c4b	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c4d	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c4f	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c52	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c55	b0 03		bcs $1c5a			bcs 	_COError
.1c57	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c5a					_COError:
.1c5a	4c 19 20	jmp $2019		jmp	ErrorV_channel
.1c5d					XPokeMemory:
.1c5d	86 2c		stx $2c				stx 	zTemp0
.1c5f	84 2d		sty $2d				sty 	zTemp0+1
.1c61	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c63	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c66	e0 ff		cpx #$ff			cpx 	#$FF
.1c68	f0 02		beq $1c6c			beq 	_XPMNoSwitch
.1c6a	86 00		stx $00				stx 	SelectRAMBank
.1c6c					_XPMNoSwitch:
.1c6c	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1c6e	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1c70					_XPMExit:
.1c70	60		rts				rts
.1c71					XPeekMemory:
.1c71	86 2c		stx $2c				stx 	zTemp0
.1c73	84 2d		sty $2d				sty 	zTemp0+1
.1c75	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c77	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c7a	e0 ff		cpx #$ff			cpx 	#$FF
.1c7c	f0 02		beq $1c80			beq 	_XPMNoSwitch
.1c7e	86 00		stx $00				stx 	SelectRAMBank
.1c80					_XPMNoSwitch:
.1c80	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1c82	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1c84	60		rts				rts
.1c85					CommandBank:
.1c85	fa		plx				plx
.1c86	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1c88	8d 6d 05	sta $056d			sta 	ramBank 					; store & make current
.1c8b	85 00		sta $00				sta 	SelectRAMBank
.1c8d	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1c8f	c9 ff		cmp #$ff			cmp 	#$FF
.1c91	f0 03		beq $1c96			beq 	_CBNoUpdate
.1c93	8d 6e 05	sta $056e			sta 	romBank 					; this doesn't set the hardware page.
.1c96					_CBNoUpdate:
.1c96	a2 ff		ldx #$ff			ldx 	#$FF
.1c98	4c 4f 08	jmp $084f			jmp 	NextCommand
.056d					ramBank:
>056d							.fill 	1
.056e					romBank:
>056e							.fill 	1
.1c9b					XPrintCharacterToChannel:
.1c9b	48		pha				pha
.1c9c	da		phx				phx
.1c9d	5a		phy				phy
.1c9e	48		pha				pha  								; save char
.1c9f	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1ca1	d0 05		bne $1ca8			bne 	_XPCNotDefault
.1ca3	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1ca6	80 08		bra $1cb0			bra 	_XPCSend
.1ca8					_XPCNotDefault:
.1ca8	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1cab	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1cae	d0 08		bne $1cb8			bne 	_XPCError
.1cb0					_XPCSend:
.1cb0	68		pla				pla 								; restore character
.1cb1	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1cb4	7a		ply				ply
.1cb5	fa		plx				plx
.1cb6	68		pla				pla
.1cb7	60		rts				rts
.1cb8					_XPCError:
.1cb8	4c 19 20	jmp $2019		jmp	ErrorV_channel
.1cbb					XReadClock:
.1cbb	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1cbe	60		rts				rts
.1cbf					XWriteClock:
.1cbf	48		pha				pha
.1cc0	da		phx				phx
.1cc1	5a		phy				phy
.1cc2	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1cc5	7a		ply				ply
.1cc6	fa		plx				plx
.1cc7	68		pla				pla
.1cc8	60		rts				rts
.1cc9					CommandScreen:
.1cc9	fa		plx				plx
.1cca	da		phx				phx
.1ccb	5a		phy				phy
.1ccc	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1ccf	18		clc				clc
.1cd0	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1cd3	7a		ply				ply
.1cd4	fa		plx				plx
.1cd5	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cd8					XCommandSleep:
.1cd8	fa		plx				plx
.1cd9	5a		phy				phy
.1cda	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.1cdd	ca		dex				dex
.1cde	20 bb 1c	jsr $1cbb			jsr 	XReadClock 					; read clock to YXA
.1ce1	18		clc				clc 								; calculate end time in zTemp0
.1ce2	65 3e		adc $3e				adc 	NSMantissa0
.1ce4	85 2c		sta $2c				sta 	zTemp0
.1ce6	8a		txa				txa
.1ce7	65 4a		adc $4a				adc 	NSMantissa1
.1ce9	85 2d		sta $2d				sta 	zTemp0+1
.1ceb					_XCWait:
.1ceb	20 bb 1c	jsr $1cbb			jsr 	XReadClock 					; and wait for it.
.1cee	c5 2c		cmp $2c				cmp 	zTemp0
.1cf0	d0 f9		bne $1ceb			bne 	_XCWait
.1cf2	e4 2d		cpx $2d				cpx 	zTemp0+1
.1cf4	d0 f5		bne $1ceb			bne 	_XCWait
.1cf6	a2 ff		ldx #$ff			ldx 	#$FF
.1cf8	7a		ply				ply
.1cf9	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cfc					X16_Audio_FMINIT:
.1cfc	fa		plx				plx
.1cfd	5a		phy			phy
.1cfe	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d01	63 c0					.word	X16A_ym_init
>1d03	0a					.byte	X16_AudioCodeBank
.1d04	a2 ff		ldx #$ff		ldx	#$FF
.1d06	7a		ply			ply
.1d07	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d0a					X16_Audio_FMNOTE:
.1d0a	fa		plx				plx
.1d0b	5a		phy			phy
.1d0c	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d0f	18		clc			clc
.1d10	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d13	03 c0					.word	X16A_bas_fmnote
>1d15	0a					.byte	X16_AudioCodeBank
.1d16	a2 ff		ldx #$ff		ldx	#$FF
.1d18	7a		ply			ply
.1d19	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d1c					X16_Audio_FMDRUM:
.1d1c	fa		plx				plx
.1d1d	5a		phy			phy
.1d1e	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d21	18		clc			clc
.1d22	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d25	6f c0					.word	X16A_ym_playdrum
>1d27	0a					.byte	X16_AudioCodeBank
.1d28	a2 ff		ldx #$ff		ldx	#$FF
.1d2a	7a		ply			ply
.1d2b	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d2e					X16_Audio_FMINST:
.1d2e	fa		plx				plx
.1d2f	5a		phy			phy
.1d30	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d33	38		sec			sec
.1d34	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d37	69 c0					.word	X16A_ym_loadpatch
>1d39	0a					.byte	X16_AudioCodeBank
.1d3a	a2 ff		ldx #$ff		ldx	#$FF
.1d3c	7a		ply			ply
.1d3d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d40					X16_Audio_FMVIB:
.1d40	fa		plx				plx
.1d41	5a		phy			phy
.1d42	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d45	18		clc			clc
.1d46	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d49	09 c0					.word	X16A_bas_fmvib
>1d4b	0a					.byte	X16_AudioCodeBank
.1d4c	a2 ff		ldx #$ff		ldx	#$FF
.1d4e	7a		ply			ply
.1d4f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d52					X16_Audio_FMFREQ:
.1d52	fa		plx				plx
.1d53	5a		phy			phy
.1d54	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1d57	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d5a	00 c0					.word	X16A_bas_fmfreq
>1d5c	0a					.byte	X16_AudioCodeBank
.1d5d	a2 ff		ldx #$ff		ldx	#$FF
.1d5f	7a		ply			ply
.1d60	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d63					X16_Audio_FMVOL:
.1d63	fa		plx				plx
.1d64	5a		phy			phy
.1d65	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d68	18		clc			clc
.1d69	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d6c	75 c0					.word	X16A_ym_setatten
>1d6e	0a					.byte	X16_AudioCodeBank
.1d6f	a2 ff		ldx #$ff		ldx	#$FF
.1d71	7a		ply			ply
.1d72	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d75					X16_Audio_FMPAN:
.1d75	fa		plx				plx
.1d76	5a		phy			phy
.1d77	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d7a	18		clc			clc
.1d7b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d7e	7e c0					.word	X16A_ym_setpan
>1d80	0a					.byte	X16_AudioCodeBank
.1d81	a2 ff		ldx #$ff		ldx	#$FF
.1d83	7a		ply			ply
.1d84	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d87					X16_Audio_FMPLAY:
.1d87	fa		plx				plx
.1d88	5a		phy			phy
.1d89	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1d8c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d8f	06 c0					.word	X16A_bas_fmplaystring
>1d91	0a					.byte	X16_AudioCodeBank
.1d92	a2 ff		ldx #$ff		ldx	#$FF
.1d94	7a		ply			ply
.1d95	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d98					X16_Audio_FMCHORD:
.1d98	fa		plx				plx
.1d99	5a		phy			phy
.1d9a	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1d9d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1da0	8d c0					.word	X16A_bas_fmchordstring
>1da2	0a					.byte	X16_AudioCodeBank
.1da3	a2 ff		ldx #$ff		ldx	#$FF
.1da5	7a		ply			ply
.1da6	4c 4f 08	jmp $084f			jmp 	NextCommand
.1da9					X16_Audio_FMPOKE:
.1da9	fa		plx				plx
.1daa	5a		phy			phy
.1dab	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1dae	18		clc			clc
.1daf	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1db2	8a c0					.word	X16A_ym_write
>1db4	0a					.byte	X16_AudioCodeBank
.1db5	a2 ff		ldx #$ff		ldx	#$FF
.1db7	7a		ply			ply
.1db8	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dbb					X16_Audio_PSGINIT:
.1dbb	fa		plx				plx
.1dbc	5a		phy			phy
.1dbd	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dc0	4b c0					.word	X16A_psg_init
>1dc2	0a					.byte	X16_AudioCodeBank
.1dc3	a2 ff		ldx #$ff		ldx	#$FF
.1dc5	7a		ply			ply
.1dc6	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dc9					X16_Audio_PSGNOTE:
.1dc9	fa		plx				plx
.1dca	5a		phy			phy
.1dcb	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1dce	18		clc			clc
.1dcf	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dd2	12 c0					.word	X16A_bas_psgnote
>1dd4	0a					.byte	X16_AudioCodeBank
.1dd5	a2 ff		ldx #$ff		ldx	#$FF
.1dd7	7a		ply			ply
.1dd8	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ddb					X16_Audio_PSGVOL:
.1ddb	fa		plx				plx
.1ddc	5a		phy			phy
.1ddd	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1de0	18		clc			clc
.1de1	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1de4	54 c0					.word	X16A_psg_setatten
>1de6	0a					.byte	X16_AudioCodeBank
.1de7	a2 ff		ldx #$ff		ldx	#$FF
.1de9	7a		ply			ply
.1dea	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ded					X16_Audio_PSGWAV:
.1ded	fa		plx				plx
.1dee	5a		phy			phy
.1def	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1df2	18		clc			clc
.1df3	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1df6	15 c0					.word	X16A_bas_psgwav
>1df8	0a					.byte	X16_AudioCodeBank
.1df9	a2 ff		ldx #$ff		ldx	#$FF
.1dfb	7a		ply			ply
.1dfc	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dff					X16_Audio_PSGFREQ:
.1dff	fa		plx				plx
.1e00	5a		phy			phy
.1e01	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1e04	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e07	0f c0					.word	X16A_bas_psgfreq
>1e09	0a					.byte	X16_AudioCodeBank
.1e0a	a2 ff		ldx #$ff		ldx	#$FF
.1e0c	7a		ply			ply
.1e0d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e10					X16_Audio_PSGPAN:
.1e10	fa		plx				plx
.1e11	5a		phy			phy
.1e12	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e15	18		clc			clc
.1e16	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e19	5a c0					.word	X16A_psg_setpan
>1e1b	0a					.byte	X16_AudioCodeBank
.1e1c	a2 ff		ldx #$ff		ldx	#$FF
.1e1e	7a		ply			ply
.1e1f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e22					X16_Audio_PSGPLAY:
.1e22	fa		plx				plx
.1e23	5a		phy			phy
.1e24	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e27	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e2a	18 c0					.word	X16A_bas_psgplaystring
>1e2c	0a					.byte	X16_AudioCodeBank
.1e2d	a2 ff		ldx #$ff		ldx	#$FF
.1e2f	7a		ply			ply
.1e30	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e33					X16_Audio_PSGCHORD:
.1e33	fa		plx				plx
.1e34	5a		phy			phy
.1e35	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e38	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e3b	90 c0					.word	X16A_bas_psgchordstring
>1e3d	0a					.byte	X16_AudioCodeBank
.1e3e	a2 ff		ldx #$ff		ldx	#$FF
.1e40	7a		ply			ply
.1e41	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e44					CommandCls:
.1e44	fa		plx				plx
.1e45	a9 93		lda #$93			lda 	#147
.1e47	20 9b 1c	jsr $1c9b			jsr 	XPrintCharacterToChannel
.1e4a	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e4d					CommandLocate:
.1e4d	fa		plx				plx
.1e4e	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.1e51	ca		dex				dex
.1e52	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.1e55	ca		dex				dex
.1e56	48		pha				pha 								; save registers
.1e57	da		phx				phx
.1e58	5a		phy				phy
.1e59	18		clc				clc
.1e5a	a4 3f		ldy $3f				ldy 	NSMantissa0+1 				; get coords
.1e5c	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e5e	88		dey				dey 								; fix up
.1e5f	ca		dex				dex
.1e60	20 f0 ff	jsr $fff0			jsr 	$FFF0 						; PLOT
.1e63	7a		ply				ply 								; restore registers
.1e64	fa		plx				plx
.1e65	68		pla				pla
.1e66	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e69					_CLOutputXA:
.1e69	ca		dex				dex
.1e6a	f0 07		beq $1e73			beq 	_CLOExit
.1e6c	30 05		bmi $1e73			bmi 	_CLOExit
.1e6e	20 9b 1c	jsr $1c9b			jsr 	XPrintCharacterToChannel
.1e71	80 f6		bra $1e69			bra 	_CLOutputXA
.1e73					_CLOExit:
.1e73	60		rts				rts
.1e74					CommandColor:
.1e74	fa		plx				plx
.1e75	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.1e78	ca		dex				dex
.1e79	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.1e7c	ca		dex				dex
.1e7d	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1e7f	c9 ff		cmp #$ff			cmp 	#$FF
.1e81	f0 08		beq $1e8b			beq 	_CCNoBGR 					; if so, change background
.1e83	20 93 1e	jsr $1e93			jsr 	_CCSetColour
.1e86	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1e88	20 9b 1c	jsr $1c9b			jsr 	XPrintCharacterToChannel
.1e8b					_CCNoBGR:
.1e8b	a5 3e		lda $3e				lda 	NSMantissa0
.1e8d	20 93 1e	jsr $1e93			jsr 	_CCSetColour
.1e90	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e93					_CCSetColour:
.1e93	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1e95	aa		tax				tax
.1e96	bd 9d 1e	lda $1e9d,x			lda 	_CCCommandTable,x
.1e99	20 9b 1c	jsr $1c9b			jsr 	XPrintCharacterToChannel
.1e9c	60		rts				rts
.1e9d					_CCCommandTable:
>1e9d	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1ea5	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1ead					CommandVPOKE:
.1ead	fa		plx				plx
.1eae	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; poke value
.1eb1	48		pha				pha
.1eb2	ca		dex				dex
.1eb3	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.1eb6	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1eb8	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1ebb	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ebd	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ec0	ca		dex				dex
.1ec1	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.1ec4	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1ec7	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1eca	ca		dex				dex
.1ecb	68		pla				pla 								; poke value back
.1ecc	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1ecf	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ed2					CommandVPEEK:
.1ed2	fa		plx				plx
.1ed3	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.1ed6	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ed8	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1edb	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1edd	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ee0	ca		dex				dex
.1ee1	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.1ee4	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1ee7	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1eea	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1eed	20 73 26	jsr $2673			jsr 	FloatSetByte 				; return as byte
.1ef0	4c 4f 08	jmp $084f			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ff					C64_PI                   = $ff ; $ff pi
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ceb7					C64_BANNER               = $ceb7 ; $ceb7 banner
=$ceb8					C64_EXEC                 = $ceb8 ; $ceb8 exec
=$ceb9					C64_TILE                 = $ceb9 ; $ceb9 tile
=$ceba					C64_EDIT                 = $ceba ; $ceba edit
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$cedb					C64_MWHEEL               = $cedb ; $cedb mwheel
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$cb					PCD_ENDCOMMAND = $cb
=$cb					PCD_STARTSYSTEM = $cb
=$d6					PCD_ENDSYSTEM = $d6
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_PI               = $ac ; pi
=$ad					PCD_POKE             = $ad ; poke
=$ae					PCD_POS              = $ae ; pos
=$af					PCD_GETCHANNEL       = $af ; getchannel
=$b0					PCD_SETCHANNEL       = $b0 ; setchannel
=$b1					PCD_PRINTCMD_N       = $b1 ; print.n
=$b2					PCD_PRINTCMD_S       = $b2 ; print.s
=$b3					PCD_READ             = $b3 ; read
=$b4					PCD_READDOLLAR       = $b4 ; read$
=$b5					PCD_RND              = $b5 ; rnd
=$b6					PCD_CONCAT           = $b6 ; concat
=$b7					PCD_SGN              = $b7 ; sgn
=$b8					PCD_PRINTCMD_TAB     = $b8 ; print.tab
=$b9					PCD_PRINTCMD_POS     = $b9 ; print.pos
=$ba					PCD_PRINTCMD_SPC     = $ba ; print.spc
=$bb					PCD_STRDOLLAR        = $bb ; str$
=$bc					PCD_LEFTDOLLAR       = $bc ; left$
=$bd					PCD_RIGHTDOLLAR      = $bd ; right$
=$be					PCD_MIDDOLLAR        = $be ; mid$
=$bf					PCD_SWAP             = $bf ; swap
=$c0					PCD_TI               = $c0 ; ti
=$c1					PCD_TIDOLLAR         = $c1 ; ti$
=$c2					PCD_USR              = $c2 ; usr
=$c3					PCD_VAL              = $c3 ; val
=$c4					PCD_CLOSE            = $c4 ; close
=$c5					PCD_EXIT             = $c5 ; exit
=$c6					PCD_DEBUG            = $c6 ; debug
=$c7					PCD_OPEN             = $c7 ; open
=$c8					PCD_SCREEN           = $c8 ; screen
=$c9					PCD_VPOKE            = $c9 ; vpoke
=$ca					PCD_VPEEK            = $ca ; vpeek
=$cb					PCD_CMD_SHIFT        = $cb ; .shift
=$cc					PCD_CMD_BYTE         = $cc ; .byte
=$cd					PCD_CMD_WORD         = $cd ; .word
=$ce					PCD_CMD_FLOAT        = $ce ; .float
=$cf					PCD_CMD_STRING       = $cf ; .string
=$d0					PCD_CMD_DATA         = $d0 ; .data
=$d1					PCD_CMD_GOTO         = $d1 ; .goto
=$d2					PCD_CMD_GOSUB        = $d2 ; .gosub
=$d3					PCD_CMD_GOTOCMD_Z    = $d3 ; .goto.z
=$d4					PCD_CMD_GOTOCMD_NZ   = $d4 ; .goto.nz
=$d5					PCD_CMD_VARSPACE     = $d5 ; .varspace
=$cb80					PCD_CLR              = $cb80 ; clr
=$cb81					PCD_DIM              = $cb81 ; dim
=$cb82					PCD_END              = $cb82 ; end
=$cb83					PCD_JOY              = $cb83 ; joy
=$cb84					PCD_INT              = $cb84 ; int
=$cb85					PCD_SQR              = $cb85 ; sqr
=$cb86					PCD_LOG              = $cb86 ; log
=$cb87					PCD_EXP              = $cb87 ; exp
=$cb88					PCD_COS              = $cb88 ; cos
=$cb89					PCD_SIN              = $cb89 ; sin
=$cb8a					PCD_TAN              = $cb8a ; tan
=$cb8b					PCD_ATN              = $cb8b ; atn
=$cb8c					PCD_MOUSE            = $cb8c ; mouse
=$cb8d					PCD_MB               = $cb8d ; mb
=$cb8e					PCD_MX               = $cb8e ; mx
=$cb8f					PCD_MY               = $cb8f ; my
=$cb90					PCD_RESTORE          = $cb90 ; restore
=$cb91					PCD_STOP             = $cb91 ; stop
=$cb92					PCD_SYS              = $cb92 ; sys
=$cb93					PCD_TIDOLLARCMD_WRITE = $cb93 ; ti$.write
=$cb94					PCD_WAIT             = $cb94 ; wait
=$cb95					PCD_I2CPOKE          = $cb95 ; i2cpoke
=$cb96					PCD_I2CPEEK          = $cb96 ; i2cpeek
=$cb97					PCD_BANK             = $cb97 ; bank
=$cb98					PCD_SLEEP            = $cb98 ; sleep
=$cb99					PCD_FMINIT           = $cb99 ; fminit
=$cb9a					PCD_FMNOTE           = $cb9a ; fmnote
=$cb9b					PCD_FMDRUM           = $cb9b ; fmdrum
=$cb9c					PCD_FMINST           = $cb9c ; fminst
=$cb9d					PCD_FMVIB            = $cb9d ; fmvib
=$cb9e					PCD_FMFREQ           = $cb9e ; fmfreq
=$cb9f					PCD_FMVOL            = $cb9f ; fmvol
=$cba0					PCD_FMPAN            = $cba0 ; fmpan
=$cba1					PCD_FMPLAY           = $cba1 ; fmplay
=$cba2					PCD_FMCHORD          = $cba2 ; fmchord
=$cba3					PCD_FMPOKE           = $cba3 ; fmpoke
=$cba4					PCD_PSGINIT          = $cba4 ; psginit
=$cba5					PCD_PSGNOTE          = $cba5 ; psgnote
=$cba6					PCD_PSGVOL           = $cba6 ; psgvol
=$cba7					PCD_PSGWAV           = $cba7 ; psgwav
=$cba8					PCD_PSGFREQ          = $cba8 ; psgfreq
=$cba9					PCD_PSGPAN           = $cba9 ; psgpan
=$cbaa					PCD_PSGPLAY          = $cbaa ; psgplay
=$cbab					PCD_PSGCHORD         = $cbab ; psgchord
=$cbac					PCD_CLS              = $cbac ; cls
=$cbad					PCD_LOCATE           = $cbad ; locate
=$cbae					PCD_COLOR            = $cbae ; color
.1ef3					SetErrorHandler:
.1ef3	8c 70 05	sty $0570			sty 	ErrorHandlerVector+1
.1ef6	8e 6f 05	stx $056f			stx 	ErrorHandlerVector
.1ef9	60		rts				rts
.1efa					CallErrorHandler:
.1efa	6c 6f 05	jmp ($056f)			jmp 	(ErrorHandlerVector)
.056f					ErrorHandlerVector:
>056f							.fill 	2
.1efd					ErrorV_range:
.1efd	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1f00	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f08	41 4e 47 45 00
.1f0d					ErrorV_value:
.1f0d	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1f10	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f18	45 00
.1f1a					ErrorV_syntax:
.1f1a	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1f1d	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f25	52 52 4f 52 00
.1f2a					ErrorV_type:
.1f2a	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1f2d	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f35	4d 41 54 43 48 00
.1f3b					ErrorV_unimplemented:
.1f3b	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1f3e	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f46	45 4d 45 4e 54 45 44 00
.1f4e					ErrorV_assert:
.1f4e	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1f51	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f59	41 49 4c 00
.1f5d					ErrorV_line:
.1f5d	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1f60	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f68	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f74					ErrorV_internal:
.1f74	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1f77	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f7f	20 45 52 52 4f 52 00
.1f86					ErrorV_divzero:
.1f86	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1f89	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1f91	59 20 5a 45 52 4f 00
.1f98					ErrorV_structure:
.1f98	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1f9b	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fa3	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1faf					ErrorV_stop:
.1faf	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1fb2	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fba	53 54 4f 50 50 45 44 00
.1fc2					ErrorV_data:
.1fc2	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1fc5	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fcd	41 54 41 00
.1fd1					ErrorV_undeclared:
.1fd1	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1fd4	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1fdc	41 52 52 41 59 00
.1fe2					ErrorV_redefine:
.1fe2	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1fe5	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1fed	44 45 46 49 4e 45 44 00
.1ff5					ErrorV_index:
.1ff5	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>1ff8	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2000	59 20 49 4e 44 45 58 00
.2008					ErrorV_memory:
.2008	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>200b	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2013	45 4d 4f 52 59 00
.2019					ErrorV_channel:
.2019	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>201c	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2024	54 50 55 54 20 45 52 52 4f 52 00
.202f					ErrorV_break:
.202f	20 fa 1e	jsr $1efa		jsr	CallErrorHandler
>2032	42 52 45 41 4b 20 50 52			.text	"BREAK PRESSED",0
>203a	45 53 53 45 44 00
.2040					MoveObjectForward:
.2040	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.2042	c9 ff		cmp #$ff			cmp 	#$FF
.2044	f0 36		beq $207c			beq 	_MOFEnd
.2046	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.2048	90 24		bcc $206e			bcc 	_MOFAdvance1 				; forward 1
.204a	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.204c	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.204e	90 20		bcc $2070			bcc 	_MOFAdvanceY
.2050	c9 cb		cmp #$cb			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2052	90 1a		bcc $206e			bcc 	_MOFAdvance1 				; forward 1
.2054	a8		tay				tay 								; read the size.
.2055	b9 b9 1f	lda $1fb9,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.2058	a8		tay				tay
.2059	c8		iny				iny 								; add 1 for the system token.
.205a	d0 14		bne $2070			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.205c	a0 01		ldy #$01			ldy 	#1 							; get length byte
.205e	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2060	a8		tay				tay 								; into Y.
.2061	18		clc				clc
.2062	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.2064	69 02		adc #$02			adc 	#2
.2066	85 2a		sta $2a				sta 	objPtr
.2068	90 02		bcc $206c			bcc 	_MOFNoCarry1
.206a	e6 2b		inc $2b				inc 	objPtr+1
.206c					_MOFNoCarry1:
.206c	80 02		bra $2070			bra 	_MOFAdvanceY
.206e					_MOFAdvance1:
.206e	a0 01		ldy #$01			ldy 	#1
.2070					_MOFAdvanceY:
.2070	98		tya				tya 								; add Y to objPtr
.2071	18		clc				clc
.2072	65 2a		adc $2a				adc 	objPtr
.2074	85 2a		sta $2a				sta 	objPtr
.2076	90 02		bcc $207a			bcc 	_MOFNoCarry2
.2078	e6 2b		inc $2b				inc 	objPtr+1
.207a					_MOFNoCarry2:
.207a	18		clc				clc 								; not completed.
.207b	60		rts				rts
.207c					_MOFEnd:
.207c	e6 2a		inc $2a				inc 	objPtr
.207e	d0 02		bne $2082			bne 	_MOFENoCarry
.2080	e6 2b		inc $2b				inc 	objPtr+1
.2082					_MOFENoCarry:
.2082	38		sec				sec
.2083	60		rts				rts
.2084					MOFSizeTable:
>2084	01					.byte	1         	; $cb .shift
>2085	01					.byte	1         	; $cc .byte
>2086	02					.byte	2         	; $cd .word
>2087	05					.byte	5         	; $ce .float
>2088	ff					.byte	255       	; $cf .string
>2089	ff					.byte	255       	; $d0 .data
>208a	02					.byte	2         	; $d1 .goto
>208b	02					.byte	2         	; $d2 .gosub
>208c	02					.byte	2         	; $d3 .goto.z
>208d	02					.byte	2         	; $d4 .goto.nz
>208e	02					.byte	2         	; $d5 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0571					numberBuffer:
>0571							.fill 	34
.208f					FloatSubtract:
.208f	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.2091	49 80		eor #$80			eor 	#$80
.2093	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.2095					FloatAdd:
.2095	ca		dex				dex
.2096	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.2098	15 6f		ora $6f,x			ora 	NSExponent+1,x
.209a	15 62		ora $62,x			ora 	NSMantissa3,x
.209c	15 63		ora $63,x			ora 	NSMantissa3+1,x
.209e	d0 04		bne $20a4			bne 	_FAUseFloat
.20a0	20 31 24	jsr $2431			jsr 	FloatInt32Add 				; use the int32 one.
.20a3	60		rts				rts
.20a4					_FAUseFloat:
.20a4	20 c6 23	jsr $23c6			jsr 	FloatNormalise 				; normalise S[X]
.20a7	f0 51		beq $20fa			beq 	_FAReturn1
.20a9	e8		inx				inx 								; normalise S[X+1]
.20aa	20 c6 23	jsr $23c6			jsr 	FloatNormalise
.20ad	ca		dex				dex
.20ae	c9 00		cmp #$00			cmp 	#0
.20b0	f0 60		beq $2112			beq 	_FAExit 					; if so, just return A
.20b2	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20b4	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20b6	f0 18		beq $20d0			beq 	_FAExponentsEqual
.20b8	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20ba	a8		tay				tay
.20bb	38		sec				sec 								; do a signed comparison of the exponents.
.20bc	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20be	50 02		bvc $20c2			bvc 	_FANoSignedChange
.20c0	49 80		eor #$80			eor 	#$80
.20c2					_FANoSignedChange:
.20c2	29 80		and #$80			and 	#$80
.20c4	10 02		bpl $20c8			bpl 	_FAHaveMax
.20c6	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.20c8					_FAHaveMax:
.20c8	20 13 21	jsr $2113			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20cb	e8		inx				inx
.20cc	20 13 21	jsr $2113			jsr 	_FAShiftToExponent
.20cf	ca		dex				dex
.20d0					_FAExponentsEqual:
.20d0	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.20d2	55 33		eor $33,x			eor 	NSStatus+1,x
.20d4	30 0e		bmi $20e4			bmi 	_FADifferentSigns
.20d6	20 fd 23	jsr $23fd			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20d9	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20db	10 35		bpl $2112			bpl 	_FAExit 					; if no, we are done.
.20dd	20 8a 26	jsr $268a			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20e0	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.20e2	80 2e		bra $2112			bra 	_FAExit
.20e4					_FADifferentSigns:
.20e4	20 17 24	jsr $2417			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20e7	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.20e9	10 06		bpl $20f1			bpl 	_FACheckZero 				; if no, check for -0
.20eb	20 33 26	jsr $2633			jsr 	FloatNegate 					; netate result
.20ee	20 3a 26	jsr $263a			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20f1					_FACheckZero:
.20f1	20 93 26	jsr $2693			jsr 	FloatIsZero	 				; check for -0
.20f4	d0 1c		bne $2112			bne 	_FAExit
.20f6	74 32		stz $32,x			stz 	NSStatus,x
.20f8	80 18		bra $2112			bra 	_FAExit
.20fa					_FAReturn1:
.20fa	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20fc	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20fe	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2100	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2102	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.2104	95 56		sta $56,x			sta 	NSMantissa2,x
.2106	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.2108	95 62		sta $62,x			sta 	NSMantissa3,x
.210a	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.210c	95 6e		sta $6e,x			sta 	NSExponent,x
.210e	b5 33		lda $33,x			lda 	NSStatus+1,x
.2110	95 32		sta $32,x			sta 	NSStatus,x
.2112					_FAExit:
.2112	60		rts				rts
.2113					_FAShiftToExponent:
.2113					_FAShiftToExponent2:
.2113	98		tya				tya 								; compare Y to exponent
.2114	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2116	f0 07		beq $211f			beq 	_FASEExit 					; exit if so.
.2118	20 8a 26	jsr $268a			jsr 	FloatShiftRight	 			; shift the mantissa right
.211b	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.211d	80 f4		bra $2113			bra 	_FAShiftToExponent2
.211f					_FASEExit:
.211f	60		rts				rts
.2120					CompareEqual:
.2120	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2122	d0 09		bne $212d			bne 	ReturnFalse
.2124					ReturnTrue:
.2124	a9 01		lda #$01			lda 	#1
.2126	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2128	a9 80		lda #$80			lda 	#$80
.212a	95 32		sta $32,x			sta 	NSStatus,x
.212c	60		rts				rts
.212d					ReturnFalse:
.212d	74 3e		stz $3e,x			stz 	NSMantissa0,x
.212f	60		rts				rts
.2130					CompareNotEqual:
.2130	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2132	d0 f0		bne $2124			bne 	ReturnTrue
.2134	80 f7		bra $212d			bra 	ReturnFalse
.2136					CompareLess:
.2136	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2138	c9 ff		cmp #$ff			cmp 	#$FF
.213a	f0 e8		beq $2124			beq 	ReturnTrue
.213c	80 ef		bra $212d			bra 	ReturnFalse
.213e					CompareGreater:
.213e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2140	c9 01		cmp #$01			cmp 	#$01
.2142	f0 e0		beq $2124			beq 	ReturnTrue
.2144	80 e7		bra $212d			bra 	ReturnFalse
.2146					CompareLessEqual:
.2146	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2148	c9 01		cmp #$01			cmp 	#$01
.214a	d0 d8		bne $2124			bne 	ReturnTrue
.214c	80 df		bra $212d			bra 	ReturnFalse
.214e					CompareGreaterEqual:
.214e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2150	c9 ff		cmp #$ff			cmp 	#$FF
.2152	d0 d0		bne $2124			bne 	ReturnTrue
.2154	80 d7		bra $212d			bra 	ReturnFalse
.2156					FloatCompare:
.2156	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.2158	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.215a	48		pha				pha
.215b	20 8f 20	jsr $208f			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.215e	68		pla				pla
.215f	d0 0c		bne $216d			bne 	_FCCompareFloat
.2161	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2163	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2165	15 56		ora $56,x			ora 	NSMantissa2,x
.2167	15 62		ora $62,x			ora 	NSMantissa3,x
.2169	f0 14		beq $217f			beq 	_FCExit 					; if zero, return zero
.216b	80 0a		bra $2177			bra 	_FCSign
.216d					_FCCompareFloat:
.216d	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.216f	29 f0		and #$f0			and 	#$F0
.2171	15 56		ora $56,x			ora 	NSMantissa2,x
.2173	15 62		ora $62,x			ora 	NSMantissa3,x
.2175	f0 08		beq $217f			beq 	_FCExit 					; zero, so approximately identical
.2177					_FCSign:
.2177	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2179	34 32		bit $32,x			bit 	NSStatus,x
.217b	10 02		bpl $217f			bpl 	_FCExit
.217d					_FCNegative:
.217d	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.217f					_FCExit:
.217f	20 73 26	jsr $2673			jsr 	FloatSetByte 				; set the result 255,0,1
.2182	60		rts				rts
.2183					FloatScalarTable:
>2183	66 66 66 66				.dword $66666666 ; 0.1
>2187	de					.byte $de
>2188	1f 85 eb 51				.dword $51eb851f ; 0.01
>218c	db					.byte $db
>218d	4c 37 89 41				.dword $4189374c ; 0.001
>2191	d8					.byte $d8
>2192	ac 8b db 68				.dword $68db8bac ; 0.0001
>2196	d4					.byte $d4
>2197	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>219b	d1					.byte $d1
>219c	83 de 1b 43				.dword $431bde83 ; 1e-06
>21a0	ce					.byte $ce
>21a1	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21a5	ca					.byte $ca
>21a6	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21aa	c7					.byte $c7
>21ab	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21af	c4					.byte $c4
>21b0	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21b4	c0					.byte $c0
>21b5	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21b9	bd					.byte $bd
.21ba					FloatDivide:
.21ba	48		pha				pha
.21bb	20 c6 23	jsr $23c6			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21be	ca		dex				dex
.21bf	c9 00		cmp #$00			cmp 	#0
.21c1	f0 1e		beq $21e1			beq 	_FDZero
.21c3	20 c6 23	jsr $23c6			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21c6	f0 16		beq $21de			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21c8	20 29 22	jsr $2229			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21cb	20 f6 21	jsr $21f6			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21ce	20 c6 23	jsr $23c6			jsr		FloatNormalise 				; renormalise
.21d1	20 bc 23	jsr $23bc			jsr 	FloatCalculateSign 			; calculate result sign
.21d4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.21d6	38		sec				sec
.21d7	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.21d9	38		sec				sec
.21da	e9 1e		sbc #$1e			sbc 	#30
.21dc	95 6e		sta $6e,x			sta 	NSExponent,x
.21de					_FDExit:
.21de	68		pla				pla
.21df	18		clc				clc
.21e0	60		rts				rts
.21e1					_FDZero:
.21e1	68		pla				pla
.21e2	38		sec				sec
.21e3	60		rts				rts
.21e4					DivideInt32:
.21e4	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart 			; make both integers
.21e7	ca		dex				dex
.21e8	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.21eb	20 07 22	jsr $2207			jsr 	Int32Divide 				; divide
.21ee	20 f6 21	jsr $21f6			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21f1	20 bc 23	jsr $23bc			jsr 	FloatCalculateSign 			; calculate result sign
.21f4	18		clc				clc
.21f5	60		rts				rts
.21f6					NSMCopyPlusTwoToZero:
.21f6	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21f8	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21fa	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21fc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.21fe	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.2200	95 56		sta $56,x			sta 	NSMantissa2,x
.2202	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.2204	95 62		sta $62,x			sta 	NSMantissa3,x
.2206	60		rts				rts
.2207					Int32Divide:
.2207	48		pha				pha 								; save AXY
.2208	5a		phy				phy
.2209	20 54 26	jsr $2654			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.220c	20 6d 26	jsr $266d			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.220f	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2211					_I32DivideLoop:
.2211	e8		inx				inx
.2212	e8		inx				inx
.2213	20 80 26	jsr $2680			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2216	ca		dex				dex
.2217	ca		dex				dex
.2218	20 81 26	jsr $2681			jsr 	FloatRotateLeft
.221b	20 47 22	jsr $2247			jsr 	FloatDivideCheck 			; check if subtract possible
.221e	90 02		bcc $2222			bcc 	_I32DivideNoCarryIn
.2220	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2222					_I32DivideNoCarryIn:
.2222	88		dey				dey 								; loop round till division completed.
.2223	d0 ec		bne $2211			bne 	_I32DivideLoop
.2225	7a		ply				ply 								; restore AXY and exit
.2226	68		pla				pla
.2227	18		clc				clc
.2228	60		rts				rts
.2229					Int32ShiftDivide:
.2229	48		pha				pha 								; save AY
.222a	5a		phy				phy
.222b	e8		inx				inx 								; clear S[X+2]
.222c	e8		inx				inx
.222d	20 71 26	jsr $2671			jsr 	FloatSetZero
.2230	ca		dex				dex
.2231	ca		dex				dex
.2232	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2234					_I32SDLoop:
.2234	20 47 22	jsr $2247			jsr 	FloatDivideCheck 			; check if subtract possible
.2237	e8		inx				inx
.2238	e8		inx				inx
.2239	20 81 26	jsr $2681			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.223c	ca		dex				dex
.223d	ca		dex				dex
.223e	20 81 26	jsr $2681			jsr 	FloatRotateLeft
.2241	88		dey				dey 	 							; do 31 times
.2242	d0 f0		bne $2234			bne 	_I32SDLoop
.2244	7a		ply				ply 								; restore AY and exit
.2245	68		pla				pla
.2246	60		rts				rts
.2247					FloatDivideCheck:
.2247	20 17 24	jsr $2417			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.224a	b0 04		bcs $2250			bcs 	_DCSExit 					; if carry set, then could do, exit
.224c	20 fd 23	jsr $23fd			jsr 	FloatAddTopTwoStack 		; add it back in
.224f	18		clc				clc 								; and return False
.2250					_DCSExit:
.2250	60		rts				rts
.2251					FloatFractionalPart:
.2251	5a		phy				phy
.2252	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.2254	29 7f		and #$7f			and 	#$7F
.2256	95 32		sta $32,x			sta 	NSStatus,x
.2258	20 c6 23	jsr $23c6			jsr 	FloatNormalise
.225b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.225d	38		sec				sec
.225e	e9 e0		sbc #$e0			sbc 	#$E0
.2260	90 29		bcc $228b			bcc 	_FFPExit 					; already fractional
.2262	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2264	b0 22		bcs $2288			bcs 	_FFPZero
.2266	a8		tay				tay 								; put count to do in Y
.2267	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.2269	20 90 22	jsr $2290			jsr 	_FFPPartial
.226c	95 62		sta $62,x			sta 	NSMantissa3,x
.226e	b5 56		lda $56,x			lda 	NSMantissa2,x
.2270	20 90 22	jsr $2290			jsr 	_FFPPartial
.2273	95 56		sta $56,x			sta 	NSMantissa2,x
.2275	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2277	20 90 22	jsr $2290			jsr 	_FFPPartial
.227a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.227c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.227e	20 90 22	jsr $2290			jsr 	_FFPPartial
.2281	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2283	20 93 26	jsr $2693			jsr 	FloatIsZero 					; zeroed check.
.2286	d0 03		bne $228b			bne 	_FFPExit
.2288					_FFPZero:
.2288	20 71 26	jsr $2671			jsr 	FloatSetZero
.228b					_FFPExit:
.228b	20 c6 23	jsr $23c6			jsr 	FloatNormalise
.228e	7a		ply				ply
.228f	60		rts				rts
.2290					_FFPPartial:
.2290	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2292	f0 17		beq $22ab			beq 	_FFFPPExit
.2294	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.2296	b0 0c		bcs $22a4			bcs 	_FFFPPWholeByte
.2298	5a		phy				phy
.2299					_FFFPPLeft:
.2299	0a		asl a				asl 	a
.229a	88		dey				dey
.229b	d0 fc		bne $2299			bne 	_FFFPPLeft
.229d	7a		ply				ply
.229e					_FFFPPRight:
.229e	4a		lsr a				lsr 	a
.229f	88		dey				dey
.22a0	d0 fc		bne $229e			bne 	_FFFPPRight
.22a2	80 07		bra $22ab			bra 	_FFFPPExit
.22a4					_FFFPPWholeByte:
.22a4	98		tya				tya 								; subtract 8 from count
.22a5	38		sec				sec
.22a6	e9 08		sbc #$08			sbc 	#8
.22a8	a8		tay				tay
.22a9	a9 00		lda #$00			lda 	#0 							; and clear all
.22ab					_FFFPPExit:
.22ab	60		rts				rts
.22ac					FloatIntegerPart:
.22ac	48		pha				pha
.22ad	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22af	f0 1d		beq $22ce			beq 	_FIPExit 					; if so do nothing
.22b1	20 93 26	jsr $2693			jsr 	FloatIsZero 				; is it zero ?
.22b4	f0 15		beq $22cb			beq 	_FIPZero 					; if so return zero.
.22b6	20 c6 23	jsr $23c6			jsr 	FloatNormalise 				; normalise
.22b9	f0 10		beq $22cb			beq 	_FIPZero 					; normalised to zero, exit zero
.22bb					_FIPShift:
.22bb	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22bd	10 07		bpl $22c6			bpl 	_FIPCheckZero
.22bf	20 8a 26	jsr $268a			jsr 	FloatShiftRight 			; shift mantissa right
.22c2	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22c4	80 f5		bra $22bb			bra 	_FIPShift
.22c6					_FIPCheckZero:
.22c6	20 93 26	jsr $2693			jsr 	FloatIsZero 				; avoid -0 problem
.22c9	d0 03		bne $22ce			bne 	_FIPExit 					; set to zero if mantissa zero.
.22cb					_FIPZero:
.22cb	20 71 26	jsr $2671			jsr 	FloatSetZero
.22ce					_FIPExit:
.22ce	68		pla				pla
.22cf	60		rts				rts
.22d0					FloatIntegerPartDown:
.22d0	48		pha				pha
.22d1	5a		phy				phy
.22d2	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22d4	f0 36		beq $230c			beq 	_FIPExit 					; if so do nothing
.22d6	20 93 26	jsr $2693			jsr 	FloatIsZero 				; is it zero ?
.22d9	f0 2e		beq $2309			beq 	_FIPZero 					; if so return zero.
.22db	20 c6 23	jsr $23c6			jsr 	FloatNormalise 				; normalise
.22de	f0 29		beq $2309			beq 	_FIPZero 					; normalised to zero, exit zero
.22e0	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22e2					_FIPShift:
.22e2	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22e4	10 0a		bpl $22f0			bpl 	_FIPCheckDown
.22e6	20 8a 26	jsr $268a			jsr 	FloatShiftRight 			; shift mantissa right
.22e9	90 01		bcc $22ec			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22eb	c8		iny				iny
.22ec					_FIPNoFrac:
.22ec	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22ee	80 f2		bra $22e2			bra 	_FIPShift
.22f0					_FIPCheckDown:
.22f0	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22f2	f0 10		beq $2304			beq 	_FIPCheckZero
.22f4	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22f6	10 0c		bpl $2304			bpl 	_FIPCheckZero
.22f8	e8		inx				inx 								; -ve so round *down*.
.22f9	a9 01		lda #$01			lda 	#1
.22fb	20 73 26	jsr $2673			jsr 	FloatSetByte
.22fe	20 33 26	jsr $2633			jsr 	FloatNegate
.2301	20 95 20	jsr $2095			jsr 	FloatAdd
.2304					_FIPCheckZero:
.2304	20 93 26	jsr $2693			jsr 	FloatIsZero 				; avoid -0 problem
.2307	d0 03		bne $230c			bne 	_FIPExit 					; set to zero if mantissa zero.
.2309					_FIPZero:
.2309	20 71 26	jsr $2671			jsr 	FloatSetZero
.230c					_FIPExit:
.230c	7a		ply				ply
.230d	68		pla				pla
.230e	60		rts				rts
.230f					FloatInt8Multiply:
.230f	5a		phy				phy
.2310	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2312	a8		tay				tay
.2313	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2315					_FI8MLoop:
.2315	98		tya				tya 								; shift right shifter right into carry
.2316	4a		lsr a				lsr 	a
.2317	a8		tay				tay
.2318	90 0d		bcc $2327			bcc 	_FI8MNoAdd
.231a	18		clc				clc
.231b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.231d	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.231f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2321	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2323	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.2325	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2327					_FI8MNoAdd:
.2327	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.2329	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.232b	c0 00		cpy #$00			cpy 	#0
.232d	d0 e6		bne $2315			bne 	_FI8MLoop 					; until right shifter zero.
.232f	7a		ply				ply
.2330	60		rts				rts
.2331					FloatMultiply:
.2331	ca		dex				dex
.2332	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.2334	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2336	15 62		ora $62,x			ora 	NSMantissa3,x
.2338	15 63		ora $63,x			ora 	NSMantissa3+1,x
.233a	d0 21		bne $235d			bne 	_FMUseFloat
.233c	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.233e	15 33		ora $33,x			ora 	NSStatus+1,x
.2340	29 80		and #$80			and 	#$80
.2342	15 62		ora $62,x			ora 	NSMantissa3,x
.2344	15 56		ora $56,x			ora 	NSMantissa2,x
.2346	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2348	15 63		ora $63,x			ora 	NSMantissa3+1,x
.234a	15 57		ora $57,x			ora 	NSMantissa2+1,x
.234c	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.234e	d0 04		bne $2354			bne 	_FMInt32
.2350	20 0f 23	jsr $230f			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2353	60		rts				rts
.2354					_FMInt32:
.2354	20 7e 23	jsr $237e			jsr 	FloatMultiplyShort			; use the int32 one.
.2357	18		clc				clc 								; fix it up if gone out of range
.2358	75 6e		adc $6e,x			adc 	NSExponent,x
.235a	95 6e		sta $6e,x			sta 	NSExponent,x
.235c	60		rts				rts
.235d					_FMUseFloat:
.235d	20 c6 23	jsr $23c6			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2360	f0 18		beq $237a			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2362	e8		inx				inx
.2363	20 c6 23	jsr $23c6			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2366	ca		dex				dex
.2367	c9 00		cmp #$00			cmp 	#0
.2369	f0 0c		beq $2377			beq 	_FDSetZero
.236b	20 7e 23	jsr $237e			jsr 	FloatMultiplyShort 			; calculate the result.
.236e	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2370	18		clc				clc
.2371	75 6f		adc $6f,x			adc 	NSExponent+1,x
.2373	95 6e		sta $6e,x			sta 	NSExponent,x
.2375	80 03		bra $237a			bra 	_FDExit
.2377					_FDSetZero:
.2377	20 71 26	jsr $2671			jsr 	FloatSetZero 				; return 0
.237a					_FDExit:
.237a	20 c6 23	jsr $23c6			jsr 	FloatNormalise 				; normalise the result
.237d	60		rts				rts
.237e					FloatMultiplyShort:
.237e	5a		phy				phy 								; save Y
.237f	20 54 26	jsr $2654			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2382	20 6d 26	jsr $266d			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2385	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2387					_I32MLoop:
.2387	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2389	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.238b	15 58		ora $58,x			ora 	NSMantissa2+2,x
.238d	15 64		ora $64,x			ora 	NSMantissa3+2,x
.238f	f0 25		beq $23b6			beq 	_I32MExit 					; exit if zero
.2391	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2393	29 01		and #$01			and 	#1
.2395	f0 0d		beq $23a4			beq 	_I32MNoAdd
.2397	20 fd 23	jsr $23fd			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.239a	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.239c	10 06		bpl $23a4			bpl 	_I32MNoAdd
.239e					_I32ShiftRight:
.239e	20 8a 26	jsr $268a			jsr 	FloatShiftRight 			; shift S[X] right
.23a1	c8		iny				iny 								; increment shift count
.23a2	80 09		bra $23ad			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23a4					_I32MNoAdd:
.23a4	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23a6	70 f6		bvs $239e			bvs 	_I32ShiftRight 				; instead.
.23a8	e8		inx				inx
.23a9	20 80 26	jsr $2680			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23ac	ca		dex				dex
.23ad					_I32MShiftUpper:
.23ad	e8		inx				inx 								; shift S[X+2] right
.23ae	e8		inx				inx
.23af	20 8a 26	jsr $268a			jsr 	FloatShiftRight
.23b2	ca		dex				dex
.23b3	ca		dex				dex
.23b4	80 d1		bra $2387			bra 	_I32MLoop 					; try again.
.23b6					_I32MExit:
.23b6	20 bc 23	jsr $23bc			jsr 	FloatCalculateSign
.23b9	98		tya				tya 								; shift in A
.23ba	7a		ply				ply 								; restore Y and exit
.23bb	60		rts				rts
.23bc					FloatCalculateSign:
.23bc	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23be	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23c0	55 33		eor $33,x			eor 	NSStatus+1,x
.23c2	0a		asl a				asl 	a 							; shift bit 7 into carry
.23c3	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23c5	60		rts				rts
.23c6					FloatNormalise:
.23c6	20 93 26	jsr $2693			jsr 	FloatIsZero 				; if zero exit
.23c9	d0 07		bne $23d2			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23cb	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.23cd	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.23cf	a9 00		lda #$00			lda 	#0 							; set Z flag
.23d1	60		rts				rts
.23d2					_NSNormaliseOptimise:
.23d2	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23d4	d0 19		bne $23ef			bne 	_NSNormaliseLoop
.23d6	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.23d8	30 15		bmi $23ef			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23da	95 62		sta $62,x			sta 	NSMantissa3,x
.23dc	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.23de	95 56		sta $56,x			sta 	NSMantissa2,x
.23e0	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.23e2	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23e4	74 3e		stz $3e,x			stz 	NSMantissa0,x
.23e6	b5 6e		lda $6e,x			lda 	NSExponent,x
.23e8	38		sec				sec
.23e9	e9 08		sbc #$08			sbc 	#8
.23eb	95 6e		sta $6e,x			sta 	NSExponent,x
.23ed	80 e3		bra $23d2			bra 	_NSNormaliseOptimise
.23ef					_NSNormaliseLoop:
.23ef	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23f1	70 07		bvs $23fa			bvs 	_NSNExit 					; exit if so with Z flag clear
.23f3	20 80 26	jsr $2680			jsr 	FloatShiftLeft 				; shift mantissa left
.23f6	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23f8	80 f5		bra $23ef			bra 	_NSNormaliseLoop
.23fa					_NSNExit:
.23fa	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23fc	60		rts				rts
.23fd					FloatAddTopTwoStack:
.23fd	18		clc				clc
.23fe	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2400	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.2402	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2404	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2406	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.2408	95 4a		sta $4a,x			sta 	NSMantissa1,x
.240a	b5 56		lda $56,x			lda		NSMantissa2,x
.240c	75 57		adc $57,x			adc 		NSMantissa2+1,x
.240e	95 56		sta $56,x			sta 	NSMantissa2,x
.2410	b5 62		lda $62,x			lda		NSMantissa3,x
.2412	75 63		adc $63,x			adc 		NSMantissa3+1,x
.2414	95 62		sta $62,x			sta 	NSMantissa3,x
.2416	60		rts				rts
.2417					FloatSubTopTwoStack:
.2417	38		sec				sec
.2418	b5 3e		lda $3e,x			lda		NSMantissa0,x
.241a	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.241c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.241e	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2420	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.2422	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2424	b5 56		lda $56,x			lda		NSMantissa2,x
.2426	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.2428	95 56		sta $56,x			sta 	NSMantissa2,x
.242a	b5 62		lda $62,x			lda		NSMantissa3,x
.242c	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.242e	95 62		sta $62,x			sta 	NSMantissa3,x
.2430	60		rts				rts
.2431					FloatInt32Add:
.2431	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2433	55 33		eor $33,x			eor 	NSStatus+1,x
.2435	30 04		bmi $243b			bmi 	_DiffSigns
.2437	20 fd 23	jsr $23fd			jsr		FloatAddTopTwoStack
.243a	60		rts				rts
.243b					_DiffSigns:
.243b	20 17 24	jsr $2417			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.243e	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2440	10 07		bpl $2449			bpl 	_AddExit
.2442	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2444	95 32		sta $32,x			sta 	NSStatus,x
.2446	20 3a 26	jsr $263a			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2449					_AddExit:
.2449	20 93 26	jsr $2693			jsr 	FloatIsZero 				; check for -0
.244c	d0 02		bne $2450			bne 	_AddNonZero
.244e	74 32		stz $32,x			stz 	NSStatus,x
.2450					_AddNonZero:
.2450	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2451					FloatEncodeStart:
.2451	38		sec				sec
.2452	80 01		bra $2455			bra 	FloatEncodeContinue+1
.2454					FloatEncodeContinue:
.2454	18		clc				clc
.2455					FloatEncode:
.2455	08		php				php 								; save reset flag.
.2456	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2458	f0 15		beq $246f			beq 	_ENIsOkay
.245a	c9 30		cmp #$30			cmp 	#"0"
.245c	90 04		bcc $2462			bcc 	_ENBadNumber
.245e	c9 3a		cmp #$3a			cmp 	#"9"+1
.2460	90 0d		bcc $246f			bcc 	_ENIsOkay
.2462					_ENBadNumber:
.2462	28		plp				plp 								; throw saved reset
.2463	ad 93 05	lda $0593			lda 	encodeState 				; if in decimal mode, construct final number
.2466	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2468	d0 03		bne $246d			bne 	_ENFail
.246a	4c e7 24	jmp $24e7			jmp 	_ENConstructFinal
.246d					_ENFail:
.246d	18		clc				clc 								; not allowed
.246e	60		rts				rts
.246f					_ENIsOkay:
.246f	28		plp				plp 								; are we restarting
.2470	90 15		bcc $2487			bcc 	_ENNoRestart
.2472					_ENStartEncode:
.2472	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2474	f0 0c		beq $2482			beq 	_ENFirstDP
.2476	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2478	20 73 26	jsr $2673			jsr 	FloatSetByte 				; in single byte mode.
.247b	a9 01		lda #$01			lda 	#ESTA_Low
.247d					_ENExitChange:
.247d	8d 93 05	sta $0593			sta 	encodeState 				; save new state
.2480	38		sec				sec
.2481	60		rts				rts
.2482					_ENFirstDP:
.2482	20 71 26	jsr $2671			jsr 	FloatSetZero 				; clear integer part
.2485	80 3c		bra $24c3			bra 	_ESTASwitchFloat			; go straight to float and exi
.2487					_ENNoRestart:
.2487	48		pha				pha 								; save digit or DP on stack.
.2488	ad 93 05	lda $0593			lda 	encodeState 				; get current state
.248b	c9 01		cmp #$01			cmp 	#ESTA_Low
.248d	f0 09		beq $2498			beq  	_ESTALowState
.248f	c9 02		cmp #$02			cmp 	#ESTA_High
.2491	f0 26		beq $24b9			beq 	_ESTAHighState
.2493	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2495	f0 38		beq $24cf			beq 	_ESTADecimalState
>2497	db						.byte 	$DB 						; causes a break in the emulator
.2498					_ESTALowState:
.2498	68		pla				pla 								; get value back
.2499	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.249b	f0 26		beq $24c3			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.249d	29 0f		and #$0f			and 	#15 						; make digit
.249f	8d 94 05	sta $0594			sta 	digitTemp 					; save it.
.24a2	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24a4	0a		asl a				asl 	a
.24a5	0a		asl a				asl 	a
.24a6	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24a8	0a		asl a				asl 	a
.24a9	6d 94 05	adc $0594			adc 	digitTemp
.24ac	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24ae	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24b0	90 05		bcc $24b7			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24b2	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24b4	8d 93 05	sta $0593			sta 	encodeState
.24b7					_ESTANoSwitch:
.24b7	38		sec				sec
.24b8	60		rts				rts
.24b9					_ESTAHighState:
.24b9	68		pla				pla 								; get value back
.24ba	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24bc	f0 05		beq $24c3			beq 	_ESTASwitchFloat
.24be	20 19 25	jsr $2519			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24c1	38		sec				sec
.24c2	60		rts				rts
.24c3					_ESTASwitchFloat:
.24c3	9c 95 05	stz $0595			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24c6	e8		inx				inx 								; zero the decimal additive.
.24c7	20 71 26	jsr $2671			jsr 	FloatSetZero
.24ca	ca		dex				dex
.24cb	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24cd	80 ae		bra $247d			bra 	_ENExitChange
.24cf					_ESTADecimalState:
.24cf	68		pla				pla 								; digit.
.24d0	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24d2	f0 99		beq $246d			beq 	_ENFail
.24d4	e8		inx				inx 								; put digit into fractional part of X+1
.24d5	20 19 25	jsr $2519			jsr 	ESTAShiftDigitIntoMantissa
.24d8	ca		dex				dex
.24d9	ee 95 05	inc $0595			inc 	decimalCount 				; bump the count of decimals
.24dc	ad 95 05	lda $0595			lda 	decimalCount 				; too many decimal digits.
.24df	c9 0b		cmp #$0b			cmp 	#11
.24e1	f0 02		beq $24e5			beq 	_ESTADSFail
.24e3	38		sec				sec
.24e4	60		rts				rts
.24e5					_ESTADSFail:
.24e5	18		clc				clc
.24e6	60		rts				rts
.24e7					_ENConstructFinal:
.24e7	ad 95 05	lda $0595			lda 	decimalCount 				; get decimal count
.24ea	f0 2b		beq $2517			beq 	_ENCFExit 					; no decimals
.24ec	5a		phy				phy
.24ed	0a		asl a				asl 	a 							; x 4 and CLC
.24ee	0a		asl a				asl 	a
.24ef	6d 95 05	adc $0595			adc 	decimalCount
.24f2	a8		tay				tay
.24f3	b9 7e 21	lda $217e,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24f6	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24f8	b9 7f 21	lda $217f,y			lda 	FloatScalarTable-5+1,y
.24fb	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.24fd	b9 80 21	lda $2180,y			lda 	FloatScalarTable-5+2,y
.2500	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2502	b9 81 21	lda $2181,y			lda 	FloatScalarTable-5+3,y
.2505	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2507	b9 82 21	lda $2182,y			lda 	FloatScalarTable-5+4,y
.250a	95 70		sta $70,x			sta 	NSExponent+2,x
.250c	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.250e	e8		inx				inx 								; multiply decimal const by decimal scalar
.250f	e8		inx				inx
.2510	20 31 23	jsr $2331			jsr 	FloatMultiply
.2513	20 95 20	jsr $2095			jsr 	FloatAdd 					; add to integer part.
.2516	7a		ply				ply
.2517					_ENCFExit:
.2517	18		clc				clc 								; reject the digit.
.2518	60		rts				rts
.2519					ESTAShiftDigitIntoMantissa:
.2519	29 0f		and #$0f			and 	#15 						; save digit
.251b	48		pha				pha
.251c	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.251e	48		pha				pha
.251f	b5 56		lda $56,x			lda 	NSMantissa2,x
.2521	48		pha				pha
.2522	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2524	48		pha				pha
.2525	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2527	48		pha				pha
.2528	20 80 26	jsr $2680			jsr 	FloatShiftLeft 				; x 2
.252b	20 80 26	jsr $2680			jsr 	FloatShiftLeft 				; x 4
.252e	18		clc				clc 								; pop mantissa and add
.252f	68		pla				pla
.2530	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2532	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2534	68		pla				pla
.2535	75 4a		adc $4a,x			adc 	NSMantissa1,x
.2537	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2539	68		pla				pla
.253a	75 56		adc $56,x			adc 	NSMantissa2,x
.253c	95 56		sta $56,x			sta 	NSMantissa2,x
.253e	68		pla				pla
.253f	75 62		adc $62,x			adc 	NSMantissa3,x
.2541	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.2543	20 80 26	jsr $2680			jsr 	FloatShiftLeft 				; x 10
.2546	68		pla				pla 								; add digit
.2547	18		clc				clc
.2548	75 3e		adc $3e,x			adc 	NSMantissa0,x
.254a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.254c	90 0a		bcc $2558			bcc 	_ESTASDExit
.254e	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2550	d0 06		bne $2558			bne 	_ESTASDExit
.2552	f6 56		inc $56,x			inc 	NSMantissa2,x
.2554	d0 02		bne $2558			bne 	_ESTASDExit
.2556	f6 62		inc $62,x			inc 	NSMantissa3,x
.2558					_ESTASDExit:
.2558	60		rts				rts
.0593					encodeState:
>0593							.fill 	1
.0594					digitTemp:
>0594							.fill 	1
.0595					decimalCount:
>0595							.fill 	1
.2559					FloatToString:
.2559	da		phx				phx
.255a	5a		phy				phy 								; save code position
.255b	8d 96 05	sta $0596			sta 	decimalPlaces	 			; save number of DPs.
.255e	9c 97 05	stz $0597			stz 	dbOffset 					; offset into decimal buffer = start.
.2561	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.2563	10 08		bpl $256d			bpl 	_CNTSNotNegative
.2565	29 7f		and #$7f			and 	#$7F 						; make +ve
.2567	95 32		sta $32,x			sta 	NSStatus,x
.2569	a9 2d		lda #$2d			lda 	#"-"
.256b	80 02		bra $256f			bra 	_CNTMain
.256d					_CNTSNotNegative:
.256d	a9 20		lda #$20			lda 	#" "
.256f					_CNTMain:
.256f	20 d1 25	jsr $25d1			jsr 	WriteDecimalBuffer
.2572	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.2574	f0 0d		beq $2583			beq 	_CNTSNotFloat
.2576	e8		inx				inx 								; round up so we don't get too many 6.999999
.2577	a9 01		lda #$01			lda 	#1
.2579	20 73 26	jsr $2673			jsr 	FloatSetByte
.257c	b5 6d		lda $6d,x			lda		NSExponent-1,x
.257e	95 6e		sta $6e,x			sta 	NSExponent,x
.2580	20 95 20	jsr $2095			jsr 	FloatAdd
.2583					_CNTSNotFloat:
.2583	20 b3 25	jsr $25b3			jsr 	MakePlusTwoString 			; do the integer part.
.2586	20 51 22	jsr $2251			jsr 	FloatFractionalPart 		; get the fractional part
.2589	20 c6 23	jsr $23c6			jsr 	FloatNormalise					; normalise , exit if zero
.258c	f0 22		beq $25b0			beq 	_CNTSExit
.258e	a9 2e		lda #$2e			lda 	#"."
.2590	20 d1 25	jsr $25d1			jsr 	WriteDecimalBuffer 			; write decimal place
.2593					_CNTSDecimal:
.2593	ce 96 05	dec $0596			dec 	decimalPlaces 				; done all the decimals
.2596	30 18		bmi $25b0			bmi 	_CNTSExit
.2598	e8		inx				inx 								; x 10.0
.2599	a9 0a		lda #$0a			lda 	#10
.259b	20 73 26	jsr $2673			jsr 	FloatSetByte
.259e	20 31 23	jsr $2331			jsr 	FloatMultiply
.25a1	20 b3 25	jsr $25b3			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25a4	20 51 22	jsr $2251			jsr 	FloatFractionalPart 		; get the fractional part
.25a7	20 c6 23	jsr $23c6			jsr 	FloatNormalise 				; normalise it.
.25aa	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25ac	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25ae	b0 e3		bcs $2593			bcs 	_CNTSDecimal 				; keep going.
.25b0					_CNTSExit:
.25b0	7a		ply				ply
.25b1	fa		plx				plx
.25b2	60		rts				rts
.25b3					MakePlusTwoString:
.25b3	da		phx				phx
.25b4	20 54 26	jsr $2654			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25b7	e8		inx				inx 								; access it
.25b8	e8		inx				inx
.25b9	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart 			; make it an integer
.25bc	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25be	20 f0 25	jsr $25f0			jsr 	ConvertInt32
.25c1	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25c3					_MPTSCopy:
.25c3	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25c6	20 d1 25	jsr $25d1			jsr 	WriteDecimalBuffer
.25c9	e8		inx				inx
.25ca	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25cd	d0 f4		bne $25c3			bne 	_MPTSCopy
.25cf	fa		plx				plx
.25d0	60		rts				rts
.25d1					WriteDecimalBuffer:
.25d1	da		phx				phx
.25d2	ae 97 05	ldx $0597			ldx 	dbOffset
.25d5	9d 98 05	sta $0598,x			sta 	decimalBuffer,x
.25d8	9e 99 05	stz $0599,x			stz 	decimalBuffer+1,x
.25db	ee 97 05	inc $0597			inc 	dbOffset
.25de	fa		plx				plx
.25df	60		rts				rts
.0596					decimalPlaces:
>0596							.fill 	1
.0597					dbOffset:
>0597							.fill 	1
.0598					decimalBuffer:
>0598							.fill 	32
.25e0					ConvertInt16:
.25e0	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.25e2	86 4a		stx $4a				stx 	NSMantissa1
.25e4	64 56		stz $56				stz 	NSMantissa2
.25e6	64 62		stz $62				stz 	NSMantissa3
.25e8	64 32		stz $32				stz 	NSStatus 					; positive integer
.25ea	a2 00		ldx #$00			ldx 	#0 							; stack level
.25ec	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25ee	80 00		bra $25f0			bra 	ConvertInt32
.25f0					ConvertInt32:
.25f0	5a		phy				phy
.25f1	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25f3	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25f5	10 08		bpl $25ff			bpl 	_CI32NotNeg
.25f7	48		pha				pha
.25f8	a9 2d		lda #$2d			lda 	#'-'
.25fa	99 71 05	sta $0571,y			sta 	numberBuffer,y
.25fd	c8		iny				iny
.25fe	68		pla				pla
.25ff					_CI32NotNeg:
.25ff	20 0d 26	jsr $260d			jsr 	_CI32DivideConvert 			; recursive conversion
.2602	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2604	99 71 05	sta $0571,y			sta 	numberBuffer,y
.2607	7a		ply				ply
.2608	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.260a	a9 71		lda #$71			lda 	#numberBuffer & $FF
.260c	60		rts				rts
.260d					_CI32DivideConvert:
.260d	e8		inx				inx 								; write to next slot up
.260e	20 73 26	jsr $2673			jsr 	FloatSetByte 		 		; write the base out.
.2611	ca		dex				dex
.2612	20 07 22	jsr $2207			jsr 	Int32Divide 				; divide
.2615	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.2617	48		pha				pha
.2618	20 f6 21	jsr $21f6			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.261b	20 93 26	jsr $2693			jsr 	FloatIsZero 				; is it zero ?
.261e	f0 05		beq $2625			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2620	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2622	20 0d 26	jsr $260d			jsr 	_CI32DivideConvert 			; and recusrively call.
.2625					_CI32NoRecurse:
.2625	68		pla				pla 								; remainder
.2626	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2628	90 02		bcc $262c			bcc 	_CI32NotHex
.262a	69 26		adc #$26			adc 	#6+32
.262c					_CI32NotHex:
.262c	69 30		adc #$30			adc 	#48
.262e	99 71 05	sta $0571,y			sta 	numberBuffer,y 				; write out and exit
.2631	c8		iny				iny
.2632	60		rts				rts
.2633					FloatNegate:
.2633	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2635	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2637	95 32		sta $32,x			sta 	NSStatus,x
.2639	60		rts				rts
.263a					FloatNegateMantissa:
.263a	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.263b	a9 00		lda #$00			lda 	#0
.263d	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.263f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2641	a9 00		lda #$00			lda 	#0
.2643	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.2645	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2647	a9 00		lda #$00			lda 	#0
.2649	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.264b	95 56		sta $56,x			sta 	NSMantissa2,x
.264d	a9 00		lda #$00			lda 	#0
.264f	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2651	95 62		sta $62,x			sta 	NSMantissa3,x
.2653	60		rts				rts
.2654					FloatShiftUpTwo:
.2654	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2656	95 40		sta $40,x			sta 	NSMantissa0+2,x
.2658	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.265a	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.265c	b5 56		lda $56,x			lda 	NSMantissa2,x
.265e	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2660	b5 62		lda $62,x			lda 	NSMantissa3,x
.2662	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2664	b5 6e		lda $6e,x			lda 	NSExponent,x
.2666	95 70		sta $70,x			sta 	NSExponent+2,x
.2668	b5 32		lda $32,x			lda 	NSStatus,x
.266a	95 34		sta $34,x			sta 	NSStatus+2,x
.266c	60		rts				rts
.266d					FloatSetZeroMantissaOnly:
.266d	74 3e		stz $3e,x			stz 	NSMantissa0,x
.266f	80 08		bra $2679			bra 	FloatZero13
.2671					FloatSetZero:
.2671	a9 00		lda #$00			lda 	#0
.2673					FloatSetByte:
.2673	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2675					FloatSetMantissa:
.2675	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.2677	74 32		stz $32,x			stz 	NSStatus,x
.2679					FloatZero13:
.2679	74 4a		stz $4a,x			stz 	NSMantissa1,x
.267b	74 56		stz $56,x			stz 	NSMantissa2,x
.267d	74 62		stz $62,x			stz 	NSMantissa3,x
.267f	60		rts				rts
.2680					FloatShiftLeft:
.2680	18		clc				clc
.2681					FloatRotateLeft:
.2681	36 3e		rol $3e,x			rol 	NSMantissa0,x
.2683	36 4a		rol $4a,x			rol		NSMantissa1,x
.2685	36 56		rol $56,x			rol		NSMantissa2,x
.2687	36 62		rol $62,x			rol		NSMantissa3,x
.2689	60		rts				rts
.268a					FloatShiftRight:
.268a	56 62		lsr $62,x			lsr 	NSMantissa3,x
.268c	76 56		ror $56,x			ror		NSMantissa2,x
.268e	76 4a		ror $4a,x			ror		NSMantissa1,x
.2690	76 3e		ror $3e,x			ror		NSMantissa0,x
.2692	60		rts				rts
.2693					FloatIsZero:
.2693	b5 62		lda $62,x			lda 	NSMantissa3,x
.2695	15 56		ora $56,x			ora		NSMantissa2,x
.2697	15 4a		ora $4a,x			ora		NSMantissa1,x
.2699	15 3e		ora $3e,x			ora		NSMantissa0,x
.269b	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.269c					FloatArcTan:
.269c	20 c6 23	jsr $23c6			jsr 	FloatNormalise 					; normalise x
.269f	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.26a1	48		pha				pha
.26a2	74 32		stz $32,x			stz 	NSStatus,x
.26a4	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.26a6	c9 e2		cmp #$e2			cmp 	#$E2
.26a8	90 25		bcc $26cf			bcc 	_UANoFixup
.26aa	8a		txa				txa 									; value in +1
.26ab	a8		tay				tay
.26ac	c8		iny				iny
.26ad	20 55 28	jsr $2855			jsr 	CopyFloatXY
.26b0	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.26b2	20 73 26	jsr $2673			jsr 	FloatSetByte
.26b5	e8		inx				inx
.26b6	20 ba 21	jsr $21ba			jsr 	FloatDivide
.26b9	b0 21		bcs $26dc			bcs 	_FATError
.26bb	20 df 26	jsr $26df			jsr 	CoreAtn 						; calculate the root
.26be	20 4a 28	jsr $284a			jsr 	CompletePolynomial
.26c1	20 33 26	jsr $2633			jsr 	FloatNegate 					; make -ve
.26c4	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.26c6	20 a1 28	jsr $28a1			jsr 	LoadConstant
.26c9	e8		inx				inx
.26ca	20 95 20	jsr $2095			jsr 	FloatAdd
.26cd	80 06		bra $26d5			bra 	_UAComplete
.26cf					_UANoFixup:
.26cf	20 df 26	jsr $26df			jsr 	CoreAtn
.26d2	20 4a 28	jsr $284a			jsr 	CompletePolynomial
.26d5					_UAComplete:
.26d5	68		pla				pla 									; apply the result.
.26d6	55 32		eor $32,x			eor 	NSStatus,x
.26d8	95 32		sta $32,x			sta 	NSStatus,x
.26da	18		clc				clc
.26db	60		rts				rts
.26dc					_FATError:
.26dc	68		pla				pla
.26dd	38		sec				sec
.26de	60		rts				rts
.26df					CoreAtn:
.26df	a9 4d		lda #$4d			lda 	#AtnCoefficients & $FF
.26e1	a0 27		ldy #$27			ldy 	#AtnCoefficients >> 8
.26e3	4c 9e 29	jmp $299e			jmp 	CorePolySquared
.26e6					ExpCoefficients:
>26e6	07					.byte	7
>26e7	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>26eb	d2					.byte	$d2
>26ec	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>26f0	d5					.byte	$d5
>26f1	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>26f5	d8					.byte	$d8
>26f6	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>26fa	db					.byte	$db
>26fb	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>26ff	dd					.byte	$dd
>2700	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>2704	df					.byte	$df
>2705	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>2709	e1					.byte	$e1
>270a	00 00 00 40				.dword	$40000000 ; 1.0
>270e	e2					.byte	$e2
.270f					SinCoefficients:
>270f	06					.byte	6
>2710	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>2714	e5					.byte	$e5
>2715	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>2719	e7					.byte	$e7
>271a	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>271e	e8					.byte	$e8
>271f	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>2723	e8					.byte	$e8
>2724	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>2728	e7					.byte	$e7
>2729	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>272d	e4					.byte	$e4
>272e	00 00 00 00				.dword	$00000000 ; 0.0
>2732	00					.byte	$00
.2733					LogCoefficients:
>2733	04					.byte	4
>2734	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>2738	e0					.byte	$e0
>2739	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>273d	e1					.byte	$e1
>273e	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>2742	e1					.byte	$e1
>2743	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>2747	e3					.byte	$e3
>2748	00 00 00 c0				.dword	$c0000000 ; -0.5
>274c	e1					.byte	$e1
.274d					AtnCoefficients:
>274d	0c					.byte	12
>274e	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2752	d7					.byte	$d7
>2753	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>2757	da					.byte	$da
>2758	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>275c	dc					.byte	$dc
>275d	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2761	dd					.byte	$dd
>2762	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>2766	dd					.byte	$dd
>2767	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>276b	de					.byte	$de
>276c	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2770	de					.byte	$de
>2771	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>2775	de					.byte	$de
>2776	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>277a	df					.byte	$df
>277b	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>277f	df					.byte	$df
>2780	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>2784	e0					.byte	$e0
>2785	00 00 00 40				.dword	$40000000 ; 1.0
>2789	e2					.byte	$e2
>278a	00 00 00 00				.dword	$00000000 ; 0.0
>278e	00					.byte	$00
.278f					Const_Base:
.278f					Const_1Div2Pi:
>278f	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>2793	df					.byte	$df
.2794					Const_PiDiv2:
>2794	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>2798	e2					.byte	$e2
.2799					Const_Log2_e:
>2799	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>279d	e2					.byte	$e2
.279e					Const_sqrt_2:
>279e	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>27a2	e2					.byte	$e2
.27a3					Const_sqrt_half:
>27a3	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>27a7	e1					.byte	$e1
.27a8					Const_pi:
>27a8	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>27ac	e3					.byte	$e3
.27ad					Const_half:
>27ad	00 00 00 40				.dword	$40000000 ; 0.50000000
>27b1	e1					.byte	$e1
.27b2					Const_ln_e:
>27b2	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>27b6	e1					.byte	$e1
.27b7					FloatCosine:
.27b7	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.27b9	20 a1 28	jsr $28a1			jsr 	LoadConstant
.27bc	e8		inx				inx
.27bd	20 95 20	jsr $2095			jsr 	FloatAdd
.27c0	4c 57 29	jmp $2957			jmp 	FloatSine
.27c3					FloatExponent:
.27c3	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.27c5	20 a1 28	jsr $28a1			jsr 	LoadConstant
.27c8	e8		inx				inx
.27c9	20 31 23	jsr $2331			jsr 	FloatMultiply
.27cc	20 0e 28	jsr $280e			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.27cf	e8		inx				inx
.27d0	20 ac 22	jsr $22ac			jsr 	FloatIntegerPart
.27d3	ca		dex				dex
.27d4	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.27d6	15 57		ora $57,x			ora 	NSMantissa2+1,x
.27d8	15 63		ora $63,x			ora 	NSMantissa3+1,x
.27da	d0 38		bne $2814			bne 	_UERangeError
.27dc	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.27de	c9 40		cmp #$40			cmp 	#64
.27e0	b0 32		bcs $2814			bcs 	_UERangeError
.27e2	48		pha				pha
.27e3	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.27e5	48		pha				pha
.27e6	20 51 22	jsr $2251			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.27e9	68		pla				pla
.27ea	10 14		bpl $2800			bpl 	_UEPositive
.27ec	e8		inx				inx 							; 1-x
.27ed	a9 01		lda #$01			lda 	#1
.27ef	20 73 26	jsr $2673			jsr 	FloatSetByte
.27f2	ca		dex				dex
.27f3	20 33 26	jsr $2633			jsr 	FloatNegate
.27f6	e8		inx				inx
.27f7	20 95 20	jsr $2095			jsr 	FloatAdd
.27fa	68		pla				pla 							; integer part +1 and negated.
.27fb	1a		inc a				inc 	a
.27fc	49 ff		eor #$ff			eor 	#$FF
.27fe	1a		inc a				inc 	a
.27ff	48		pha				pha
.2800					_UEPositive:
.2800	20 16 28	jsr $2816			jsr 	CoreExponent
.2803	20 4a 28	jsr $284a			jsr 	CompletePolynomial
.2806	68		pla				pla
.2807	18		clc				clc
.2808	75 6e		adc $6e,x			adc 	NSExponent,x
.280a	95 6e		sta $6e,x			sta 	NSExponent,x
.280c	18		clc				clc
.280d	60		rts				rts
.280e					_UECopy01:
.280e	8a		txa				txa
.280f	a8		tay				tay
.2810	c8		iny				iny
.2811	4c 55 28	jmp $2855			jmp 	CopyFloatXY
.2814					_UERangeError:
.2814	38		sec				sec
.2815	60		rts				rts
.2816					CoreExponent:
.2816	a9 e6		lda #$e6			lda 	#ExpCoefficients & $FF
.2818	a0 26		ldy #$26			ldy 	#ExpCoefficients >> 8
.281a	20 1e 28	jsr $281e			jsr 	CalculateHornerPolynomial
.281d	60		rts				rts
.281e					CalculateHornerPolynomial:
.281e	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.2820	84 2d		sty $2d				sty 	zTemp0+1
.2822	9c b8 05	stz $05b8			stz 	coefficientCount 			; zero the count.
.2825	8e b9 05	stx $05b9			stx 	xValueSlot 					; save xValue slot.
.2828	e8		inx				inx 								; set the count to zero.
.2829	20 71 26	jsr $2671			jsr 	FloatSetZero
.282c					_CHPLoop:
.282c	8a		txa				txa 								; copy X-1 to X+1
.282d	a8		tay				tay
.282e	ca		dex				dex
.282f	c8		iny				iny
.2830	20 55 28	jsr $2855			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.2833	e8		inx				inx
.2834	e8		inx				inx
.2835	20 31 23	jsr $2331			jsr 	FloatMultiply 				; times current by X
.2838	e8		inx				inx
.2839	20 74 28	jsr $2874			jsr 	GetCoefficient 				; coefficient into X+1
.283c	20 95 20	jsr $2095			jsr 	FloatAdd 					; and add
.283f	ee b8 05	inc $05b8			inc 	coefficientCount
.2842	ad b8 05	lda $05b8			lda 	coefficientCount
.2845	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.2847	d0 e3		bne $282c			bne 	_CHPLoop
.2849	60		rts				rts
.284a					CompletePolynomial:
.284a	20 31 23	jsr $2331			jsr 	FloatMultiply
.284d	e8		inx				inx 								; get the last value
.284e	20 74 28	jsr $2874			jsr 	GetCoefficient
.2851	20 95 20	jsr $2095			jsr 	FloatAdd 					; and add it
.2854	60		rts				rts
.2855					CopyFloatXY:
.2855	b5 6e		lda $6e,x			lda 	NSExponent,x
.2857	99 6e 00	sta $006e,y			sta 	NSExponent,y
.285a	b5 32		lda $32,x			lda 	NSStatus,x
.285c	99 32 00	sta $0032,y			sta 	NSStatus,y
.285f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2861	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.2864	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2866	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.2869	b5 56		lda $56,x			lda 	NSMantissa2,x
.286b	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.286e	b5 62		lda $62,x			lda 	NSMantissa3,x
.2870	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.2873	60		rts				rts
.2874					GetCoefficient:
.2874	5a		phy				phy
.2875	ad b8 05	lda $05b8			lda 	coefficientCount 			; 5 per block
.2878	0a		asl a				asl 	a
.2879	0a		asl a				asl 	a
.287a	38		sec				sec 								; +1 for count
.287b	6d b8 05	adc $05b8			adc 	coefficientCount
.287e	a8		tay				tay
.287f	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.2881	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2883	c8		iny				iny
.2884	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2886	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2888	c8		iny				iny
.2889	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.288b	95 56		sta $56,x			sta 	NSMantissa2,x
.288d	c8		iny				iny
.288e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2890	48		pha				pha
.2891	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.2893	95 62		sta $62,x			sta 	NSMantissa3,x
.2895	c8		iny				iny
.2896	68		pla				pla
.2897	29 80		and #$80			and 	#$80
.2899	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.289b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.289d	95 6e		sta $6e,x			sta 	NSExponent,x
.289f	7a		ply				ply
.28a0	60		rts				rts
.05b8					coefficientCount:
>05b8							.fill 	1
.05b9					xValueSlot:
>05b9							.fill 	1
.28a1					LoadConstant:
.28a1	5a		phy				phy
.28a2	a8		tay				tay
.28a3	b9 8f 27	lda $278f,y			lda 	Const_Base+0,y
.28a6	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.28a8	b9 90 27	lda $2790,y			lda 	Const_Base+1,y
.28ab	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.28ad	b9 91 27	lda $2791,y			lda 	Const_Base+2,y
.28b0	95 57		sta $57,x			sta 	NSMantissa2+1,x
.28b2	b9 92 27	lda $2792,y			lda 	Const_Base+3,y
.28b5	48		pha				pha
.28b6	29 7f		and #$7f			and 	#$7F
.28b8	95 63		sta $63,x			sta 	NSMantissa3+1,x
.28ba	68		pla				pla
.28bb	29 80		and #$80			and 	#$80
.28bd	95 33		sta $33,x			sta 	NSStatus+1,x
.28bf	b9 93 27	lda $2793,y			lda 	Const_Base+4,y
.28c2	95 6f		sta $6f,x			sta 	NSExponent+1,x
.28c4	7a		ply				ply
.28c5	60		rts				rts
.28c6					FloatLogarithm:
.28c6	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.28c8	30 5f		bmi $2929			bmi 	_ULRange
.28ca	20 93 26	jsr $2693			jsr 	FloatIsZero
.28cd	f0 5a		beq $2929			beq 	_ULRange
.28cf	20 c6 23	jsr $23c6			jsr 	FloatNormalise 				; put into FP mode.
.28d2	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.28d4	48		pha				pha
.28d5	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.28d7	95 6e		sta $6e,x			sta 	NSExponent,x
.28d9	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.28db	20 a1 28	jsr $28a1			jsr 	LoadConstant
.28de	e8		inx				inx
.28df	20 95 20	jsr $2095			jsr 	FloatAdd
.28e2	8a		txa				txa 								; divide into sqrt 2.0
.28e3	a8		tay				tay
.28e4	c8		iny				iny
.28e5	20 55 28	jsr $2855			jsr 	CopyFloatXY
.28e8	ca		dex				dex
.28e9	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.28eb	20 a1 28	jsr $28a1			jsr 	LoadConstant
.28ee	e8		inx				inx
.28ef	e8		inx				inx
.28f0	20 ba 21	jsr $21ba			jsr 	FloatDivide 				; if zero, error.
.28f3	b0 33		bcs $2928			bcs 	_ULRangePla
.28f5	20 33 26	jsr $2633			jsr 	FloatNegate 				; subtract from 1
.28f8	e8		inx				inx
.28f9	a9 01		lda #$01			lda 	#1
.28fb	20 73 26	jsr $2673			jsr 	FloatSetByte
.28fe	20 95 20	jsr $2095			jsr 	FloatAdd
.2901	20 2b 29	jsr $292b			jsr 	CoreLog
.2904	20 4a 28	jsr $284a			jsr 	CompletePolynomial
.2907	68		pla				pla 								; add exponent
.2908	18		clc				clc
.2909	69 1f		adc #$1f			adc 	#31 						; fix up
.290b	48		pha				pha
.290c	10 03		bpl $2911			bpl 	_LogNotNeg
.290e	49 ff		eor #$ff			eor 	#$FF
.2910	1a		inc a				inc 	a
.2911					_LogNotNeg:
.2911	e8		inx				inx 								; set byte and sign.
.2912	20 73 26	jsr $2673			jsr 	FloatSetByte
.2915	68		pla				pla
.2916	29 80		and #$80			and 	#$80
.2918	95 32		sta $32,x			sta 	NSStatus,x
.291a	20 95 20	jsr $2095			jsr 	FloatAdd
.291d	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.291f	20 a1 28	jsr $28a1			jsr 	LoadConstant
.2922	e8		inx				inx
.2923	20 31 23	jsr $2331			jsr 	FloatMultiply
.2926	18		clc				clc
.2927	60		rts				rts
.2928					_ULRangePla:
.2928	68		pla				pla
.2929					_ULRange:
.2929	38		sec				sec
.292a	60		rts				rts
.292b					CoreLog:
.292b	a9 33		lda #$33			lda 	#LogCoefficients & $FF
.292d	a0 27		ldy #$27			ldy 	#LogCoefficients >> 8
.292f	4c 9e 29	jmp $299e			jmp 	CorePolySquared
.2932					FloatPI:
.2932	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.2934	20 a1 28	jsr $28a1			jsr 	LoadConstant
.2937	e8		inx				inx
.2938	18		clc				clc
.2939	60		rts				rts
.293a					FloatPower:
.293a	ca		dex				dex
.293b	8a		txa				txa 							; copy 0 to 2, so we can process it
.293c	a8		tay				tay
.293d	c8		iny				iny
.293e	c8		iny				iny
.293f	20 55 28	jsr $2855			jsr 	CopyFloatXY
.2942	e8		inx				inx 							; 2 = Log(0)
.2943	e8		inx				inx
.2944	20 c6 28	jsr $28c6			jsr 	FloatLogarithm
.2947	b0 0d		bcs $2956			bcs 	_FPWExit
.2949	20 31 23	jsr $2331			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.294c	8a		txa				txa 							; copy to slot 0
.294d	a8		tay				tay
.294e	88		dey				dey
.294f	20 55 28	jsr $2855			jsr 	CopyFloatXY
.2952	ca		dex				dex  							; Exponent code.
.2953	20 c3 27	jsr $27c3			jsr 	FloatExponent
.2956					_FPWExit:
.2956	60		rts				rts
.2957					FloatSine:
.2957	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.2959	48		pha				pha
.295a	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.295c	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.295e	20 a1 28	jsr $28a1			jsr 	LoadConstant
.2961	e8		inx				inx
.2962	20 31 23	jsr $2331			jsr 	FloatMultiply
.2965	20 51 22	jsr $2251			jsr 	FloatFractionalPart 		; take the fractional part
.2968	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.296a	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.296c	90 1f		bcc $298d			bcc 	_USProcessExit
.296e	f0 06		beq $2976			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.2970	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.2972	c9 60		cmp #$60			cmp 	#$60
.2974	b0 0e		bcs $2984			bcs 	_USSubtractOne
.2976					_USSubtractFromHalf:
.2976	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.2978	20 a1 28	jsr $28a1			jsr 	LoadConstant
.297b	e8		inx				inx
.297c	20 8f 20	jsr $208f			jsr 	FloatSubtract
.297f	20 33 26	jsr $2633			jsr 	FloatNegate 				; then negate it
.2982	80 09		bra $298d			bra 	_USProcessExit 				; and exit
.2984					_USSubtractOne:
.2984	e8		inx				inx
.2985	a9 01		lda #$01			lda 	#1
.2987	20 73 26	jsr $2673			jsr 	FloatSetByte
.298a	20 8f 20	jsr $208f			jsr 	FloatSubtract
.298d					_USProcessExit:
.298d	20 9a 29	jsr $299a			jsr 	CoreSine
.2990	20 4a 28	jsr $284a			jsr 	CompletePolynomial
.2993	68		pla				pla 								; restore sign and apply
.2994	55 32		eor $32,x			eor 	NSStatus,x
.2996	95 32		sta $32,x			sta 	NSStatus,x
.2998	18		clc				clc
.2999	60		rts				rts
.299a					CoreSine:
.299a	a9 0f		lda #$0f			lda 	#SinCoefficients & $FF
.299c	a0 27		ldy #$27			ldy 	#SinCoefficients >> 8
.299e					CorePolySquared:
.299e	48		pha				pha 								; save coefficient table
.299f	5a		phy				phy
.29a0	8a		txa				txa 								; copy X to +1, +2
.29a1	a8		tay				tay
.29a2	c8		iny				iny
.29a3	20 55 28	jsr $2855			jsr 	CopyFloatXY
.29a6	c8		iny				iny
.29a7	20 55 28	jsr $2855			jsr 	CopyFloatXY
.29aa	e8		inx				inx 								; point to the pair and put x^2 on stack
.29ab	e8		inx				inx
.29ac	20 31 23	jsr $2331			jsr 	FloatMultiply
.29af	7a		ply				ply 								; coefficient table back.
.29b0	68		pla				pla
.29b1	20 1e 28	jsr $281e			jsr 	CalculateHornerPolynomial
.29b4	8a		txa				txa 								; copy back to slot #1
.29b5	a8		tay				tay
.29b6	88		dey				dey
.29b7	20 55 28	jsr $2855			jsr	 	CopyFloatXY
.29ba	ca		dex				dex 								; point at result
.29bb	60		rts				rts
.29bc					FloatSquareRoot:
.29bc	20 c6 28	jsr $28c6			jsr 	FloatLogarithm
.29bf	b0 06		bcs $29c7			bcs 	_FSQExit
.29c1	d6 6e		dec $6e,x			dec 	NSExponent,x
.29c3	20 c3 27	jsr $27c3			jsr 	FloatExponent
.29c6	18		clc				clc
.29c7					_FSQExit:
.29c7	60		rts				rts
.29c8					FloatTangent:
.29c8	da		phx				phx
.29c9	8a		txa				txa 								; sin -> +1
.29ca	a8		tay				tay
.29cb	c8		iny				iny
.29cc	20 55 28	jsr $2855			jsr 	CopyFloatXY
.29cf	e8		inx				inx
.29d0	20 57 29	jsr $2957			jsr 	FloatSine
.29d3	ca		dex				dex
.29d4	8a		txa				txa 								; cos -> +2
.29d5	a8		tay				tay
.29d6	c8		iny				iny
.29d7	c8		iny				iny
.29d8	20 55 28	jsr $2855			jsr 	CopyFloatXY
.29db	e8		inx				inx
.29dc	e8		inx				inx
.29dd	20 b7 27	jsr $27b7			jsr 	FloatCosine
.29e0	20 ba 21	jsr $21ba			jsr 	FloatDivide 				; calculate sin/cos
.29e3	b0 07		bcs $29ec			bcs 	_FTExit 					; divide by zero
.29e5	8a		txa				txa 								; copy result down.
.29e6	a8		tay				tay
.29e7	88		dey				dey
.29e8	20 55 28	jsr $2855			jsr 	CopyFloatXY
.29eb	18		clc				clc
.29ec					_FTExit:
.29ec	fa		plx				plx
.29ed	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.007a					srcPtr:
>007a							.fill 	2
.05ba					currentLineNumber:
>05ba							.fill 	2
.29ee					InlineNonDecimal:
.29ee	a2 02		ldx #$02			ldx 	#2 							; get size in X
.29f0	c9 25		cmp #$25			cmp 	#"%"
.29f2	f0 02		beq $29f6			beq 	_INDBinary
.29f4	a2 10		ldx #$10			ldx 	#16
.29f6					_INDBinary:
.29f6	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.29f8	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.29fa	64 2c		stz $2c				stz 	zTemp0 						; zero result
.29fc	64 2d		stz $2d				stz 	zTemp0+1
.29fe					_INDLoop:
.29fe	20 a0 33	jsr $33a0			jsr 	LookNext 					; check next character
.2a01	20 dc 33	jsr $33dc			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.2a04	90 1f		bcc $2a25			bcc		_INDDone 					; didn't convert
.2a06	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.2a08	b0 1b		bcs $2a25			bcs 	_INDDone
.2a0a	20 34 2a	jsr $2a34			jsr 	_INDShift 					; x 2 or x 16
.2a0d	e0 02		cpx #$02			cpx 	#2
.2a0f	f0 09		beq $2a1a			beq 	_INDNotHex
.2a11	20 34 2a	jsr $2a34			jsr 	_INDShift
.2a14	20 34 2a	jsr $2a34			jsr 	_INDShift
.2a17	20 34 2a	jsr $2a34			jsr 	_INDShift
.2a1a					_INDNotHex:
.2a1a	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.2a1c	85 2c		sta $2c				sta 	zTemp0
.2a1e	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume
.2a21	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.2a23	80 d9		bra $29fe			bra 	_INDLoop
.2a25					_INDDone:
.2a25	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.2a27	f0 08		beq $2a31			beq 	_INDError
.2a29	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.2a2b	a5 2c		lda $2c				lda 	zTemp0
.2a2d	20 56 2b	jsr $2b56			jsr 	PushIntegerYA
.2a30	60		rts				rts
.2a31					_INDError:
.2a31	4c 1a 1f	jmp $1f1a		jmp	ErrorV_syntax
.2a34					_INDShift:
.2a34	06 2c		asl $2c				asl 	zTemp0
.2a36	26 2d		rol $2d				rol 	zTemp0+1
.2a38	60		rts				rts
.2a39					GetLineNumber:
.2a39	ac bb 05	ldy $05bb			ldy 	currentLineNumber+1
.2a3c	ad ba 05	lda $05ba			lda 	currentLineNumber
.2a3f	60		rts				rts
.2a40					WriteCodeByte:
.2a40	48		pha				pha 								; save on stack
.2a41	da		phx				phx
.2a42	5a		phy				phy
.2a43	aa		tax				tax
.2a44	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.2a46	20 53 2b	jsr $2b53			jsr 	CallAPIHandler
.2a49	7a		ply				ply 								; restore from stack
.2a4a	fa		plx				plx
.2a4b	68		pla				pla
.2a4c	60		rts				rts
.2a4d					PrintCharacter
.2a4d	48		pha				pha
.2a4e	da		phx				phx
.2a4f	5a		phy				phy
.2a50	aa		tax				tax
.2a51	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.2a53	20 53 2b	jsr $2b53			jsr 	CallAPIHandler
.2a56	7a		ply				ply
.2a57	fa		plx				plx
.2a58	68		pla				pla
.2a59	60		rts				rts
.2a5a					ProcessNewLine:
.2a5a	86 2c		stx $2c				stx 	zTemp0 						; save address in zTemp0
.2a5c	84 2d		sty $2d				sty 	zTemp0+1
.2a5e	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.2a5f	8a		txa				txa
.2a60	69 04		adc #$04			adc 	#4
.2a62	85 7a		sta $7a				sta 	srcPtr
.2a64	98		tya				tya
.2a65	69 00		adc #$00			adc 	#0
.2a67	85 7b		sta $7b				sta 	srcPtr+1
.2a69	a0 02		ldy #$02			ldy 	#2							; read and save line number
.2a6b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a6d	8d ba 05	sta $05ba			sta 	currentLineNumber
.2a70	c8		iny				iny
.2a71	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a73	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2a76	60		rts				rts
.2a77					BufferClear:
.2a77	9c bc 05	stz $05bc			stz 	bufferSize
.2a7a	60		rts				rts
.2a7b					BufferWrite:
.2a7b	da		phx				phx
.2a7c	ae bc 05	ldx $05bc			ldx 	bufferSize
.2a7f	9d bd 05	sta $05bd,x			sta 	dataBuffer,x
.2a82	ee bc 05	inc $05bc			inc 	bufferSize
.2a85	fa		plx				plx
.2a86	60		rts				rts
.2a87					BufferOutput:
.2a87	ad bc 05	lda $05bc			lda 	bufferSize
.2a8a	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2a8d	a2 00		ldx #$00			ldx 	#0
.2a8f					_BOLoop:
.2a8f	ec bc 05	cpx $05bc			cpx 	bufferSize
.2a92	f0 09		beq $2a9d			beq 	_BOExit
.2a94	bd bd 05	lda $05bd,x			lda 	dataBuffer,x
.2a97	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2a9a	e8		inx				inx
.2a9b	80 f2		bra $2a8f			bra 	_BOLoop
.2a9d					_BOExit:
.2a9d	60		rts				rts
.05bc					bufferSize:
>05bc							.fill 	1
.05bd					dataBuffer:
>05bd							.fill 	256
.2a9e					CheckNextComma:
.2a9e	a9 2c		lda #$2c			lda	 	#","
.2aa0	80 06		bra $2aa8			bra 	CheckNextA
.2aa2					CheckNextRParen:
.2aa2	a9 29		lda #$29			lda	 	#")"
.2aa4	80 02		bra $2aa8			bra 	CheckNextA
.2aa6					CheckNextLParen:
.2aa6	a9 28		lda #$28			lda 	#"("
.2aa8					CheckNextA:
.2aa8	8d bd 06	sta $06bd			sta 	checkCharacter 				; save test character
.2aab					_CNALoop:
.2aab	20 bc 33	jsr $33bc			jsr 	GetNextNonSpace 			; get next skipping spaces.
.2aae	cd bd 06	cmp $06bd			cmp 	checkCharacter 				; matches ?
.2ab1	f0 03		beq $2ab6			beq 	_CNAExit
.2ab3	4c 1a 1f	jmp $1f1a		jmp	ErrorV_syntax
.2ab6					_CNAExit:
.2ab6	60		rts				rts
.06bd					checkCharacter:
>06bd							.fill 	1
.2ab7					StartCompiler:
.2ab7	86 2c		stx $2c				stx 	zTemp0 						; access API
.2ab9	84 2d		sty $2d				sty 	zTemp0+1
.2abb	a0 2d		ldy #$2d			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.2abd	a2 0f		ldx #$0f			ldx 	#CompilerErrorHandler & $FF
.2abf	20 f3 1e	jsr $1ef3			jsr 	SetErrorHandler
.2ac2	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.2ac4	b2 2c		lda ($2c)			lda 	(zTemp0)
.2ac6	8d bf 06	sta $06bf			sta 	APIVector
.2ac9	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2acb	8d c0 06	sta $06c0			sta 	APIVector+1
.2ace	c8		iny				iny 								; copy data area range.
.2acf	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ad1	8d c1 06	sta $06c1			sta 	compilerStartHigh
.2ad4	c8		iny				iny
.2ad5	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ad7	8d c2 06	sta $06c2			sta 	compilerEndHigh
.2ada	ba		tsx				tsx 								; save stack pointer
.2adb	8e be 06	stx $06be			stx 	compilerSP
.2ade	20 40 37	jsr $3740			jsr 	STRReset 					; reset storage (line#, variable)
.2ae1	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.2ae3	20 53 2b	jsr $2b53			jsr 	CallAPIHandler
.2ae6	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.2ae8	20 53 2b	jsr $2b53			jsr 	CallAPIHandler
.2aeb	a9 d5		lda #$d5			lda 	#PCD_CMD_VARSPACE
.2aed	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2af0	a9 00		lda #$00			lda 	#0
.2af2	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2af5	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2af8					MainCompileLoop:
.2af8	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.2afa	20 53 2b	jsr $2b53			jsr 	CallAPIHandler
.2afd	90 31		bcc $2b30			bcc 	SaveCodeAndExit 			; end of source.
.2aff	20 5a 2a	jsr $2a5a			jsr 	ProcessNewLine 				; set up pointer and line number.
.2b02	20 39 2a	jsr $2a39			jsr 	GetLineNumber 				; get line #
.2b05	20 2a 35	jsr $352a			jsr 	STRMarkLine 				; remember the code position and number of this line.
.2b08	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.2b0a	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2b0d					_MCLSameLine:
.2b0d	20 bc 33	jsr $33bc			jsr 	GetNextNonSpace 			; get the first character.
.2b10	f0 e6		beq $2af8			beq 	MainCompileLoop 			; end of line, get next line.
.2b12	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.2b14	f0 f7		beq $2b0d			beq 	_MCLSameLine
.2b16	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.2b18	10 0c		bpl $2b26			bpl 	_MCLCheckAssignment
.2b1a	a2 74		ldx #$74			ldx 	#CommandTables & $FF 		; do command tables.
.2b1c	a0 2f		ldy #$2f			ldy 	#CommandTables >> 8
.2b1e	20 42 32	jsr $3242			jsr 	GeneratorProcess
.2b21	b0 ea		bcs $2b0d			bcs 	_MCLSameLine 				; keep trying to compile the line.
.2b23					_MCLSyntax:
.2b23	4c 1a 1f	jmp $1f1a		jmp	ErrorV_syntax
.2b26					_MCLCheckAssignment:
.2b26	20 d2 33	jsr $33d2			jsr 	CharIsAlpha 				; if not alpha then syntax error
.2b29	90 f8		bcc $2b23			bcc 	_MCLSyntax
.2b2b	20 f8 34	jsr $34f8			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.2b2e	80 dd		bra $2b0d			bra		_MCLSameLine 				; loop back.
.2b30					SaveCodeAndExit:
.2b30	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.2b32	20 53 2b	jsr $2b53			jsr 	CallAPIHandler
.2b35	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.2b37	a8		tay				tay
.2b38	20 2a 35	jsr $352a			jsr 	STRMarkLine
.2b3b	a9 c5		lda #$c5			lda 	#PCD_EXIT 					; add an END
.2b3d	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2b40	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.2b42	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2b45	20 6c 2e	jsr $2e6c			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.2b48	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.2b4a	20 53 2b	jsr $2b53			jsr 	CallAPIHandler
.2b4d	18		clc				clc 								; CC = success
.2b4e					ExitCompiler:
.2b4e	ae be 06	ldx $06be			ldx 	compilerSP 					; reload SP and exit.
.2b51	9a		txs				txs
.2b52	60		rts				rts
.2b53					CallAPIHandler:
.2b53	6c bf 06	jmp ($06bf)			jmp 	(APIVector)
.06be					compilerSP:
>06be							.fill 	1
.06bf					APIVector:
>06bf							.fill 	2
.06c1					compilerStartHigh:
>06c1							.fill 	1
.06c2					compilerEndHigh:
>06c2							.fill 	1
.2b56					PushIntegerYA:
.2b56	c0 00		cpy #$00			cpy 	#0 							; 0-255
.2b58	f0 0f		beq $2b69			beq 	PushIntegerA
.2b5a	48		pha				pha
.2b5b	a9 cd		lda #$cd			lda 	#PCD_CMD_WORD 				; send .word
.2b5d	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2b60	68		pla				pla 								; then LSB
.2b61	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2b64	98		tya				tya 								; then MSB
.2b65	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2b68	60		rts				rts
.2b69					PushIntegerA:
.2b69	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.2b6b	90 07		bcc $2b74			bcc 	_PIWriteA
.2b6d	48		pha				pha
.2b6e	a9 cc		lda #$cc			lda 	#PCD_CMD_BYTE 				; send .byte
.2b70	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2b73	68		pla				pla
.2b74					_PIWriteA:
.2b74	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2b77	60		rts				rts
.2b78					PushFloatCommand:
.2b78	a9 ce		lda #$ce			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.2b7a	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2b7d	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.2b7f	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2b82	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2b84	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2b87	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2b89	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2b8c	b5 56		lda $56,x			lda 	NSMantissa2,x
.2b8e	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2b91	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.2b93	29 80		and #$80			and 	#$80
.2b95	15 62		ora $62,x			ora 	NSMantissa3,x
.2b97	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2b9a	60		rts				rts
.2b9b					CreateVariableRecord:
.2b9b	48		pha				pha
.2b9c	ad cd 06	lda $06cd			lda 	freeVariableMemory 		; push current free address on stack.
.2b9f	48		pha				pha
.2ba0	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2ba3	48		pha				pha
.2ba4	ad cb 06	lda $06cb			lda 	variableListEnd  		; copy end of list to zTemp0
.2ba7	85 2c		sta $2c				sta 	zTemp0
.2ba9	ad cc 06	lda $06cc			lda 	variableListEnd+1
.2bac	85 2d		sta $2d				sta 	zTemp0+1
.2bae	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.2bb0	92 2c		sta ($2c)			sta 	(zTemp0)
.2bb2	98		tya				tya
.2bb3	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.2bb5	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bb7	88		dey				dey
.2bb8	8a		txa				txa
.2bb9	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bbb	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.2bbd	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2bc0	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bc2	c8		iny				iny
.2bc3	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2bc6	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bc8	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.2bca	a9 00		lda #$00			lda 	#0
.2bcc	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bce	18		clc				clc
.2bcf	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.2bd1	6d cb 06	adc $06cb			adc  	variableListEnd
.2bd4	8d cb 06	sta $06cb			sta 	variableListEnd
.2bd7	90 03		bcc $2bdc			bcc 	_CVNoCarry2
.2bd9	ee cc 06	inc $06cc			inc 	variableListEnd+1
.2bdc					_CVNoCarry2:
.2bdc	7a		ply				ply
.2bdd	fa		plx				plx
.2bde	68		pla				pla
.2bdf	60		rts				rts
.2be0					SetVariableRecordToCodePosition:
.2be0	48		pha				pha
.2be1	5a		phy				phy
.2be2	a0 03		ldy #$03			ldy 	#3
.2be4	a5 2b		lda $2b				lda 	objPtr+1
.2be6	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2be8	c8		iny				iny
.2be9	a5 2a		lda $2a				lda 	objPtr
.2beb	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bed	7a		ply				ply
.2bee	68		pla				pla
.2bef	60		rts				rts
.2bf0					AllocateBytesForType:
.2bf0	48		pha				pha
.2bf1	da		phx				phx
.2bf2	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.2bf4	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2bf6	c9 00		cmp #$00			cmp 	#NSSIFloat
.2bf8	d0 02		bne $2bfc			bne 	_CVNotFloat
.2bfa	a2 06		ldx #$06			ldx 	#6
.2bfc					_CVNotFloat:
.2bfc	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.2bfd	18		clc				clc
.2bfe	6d cd 06	adc $06cd			adc 	freeVariableMemory
.2c01	8d cd 06	sta $06cd			sta 	freeVariableMemory
.2c04	90 03		bcc $2c09			bcc 	_CVNoCarry1
.2c06	ee ce 06	inc $06ce			inc 	freeVariableMemory+1
.2c09					_CVNoCarry1:
.2c09	fa		plx				plx
.2c0a	68		pla				pla
.2c0b	60		rts				rts
.2c0c					CommandDATA:
.2c0c	20 77 2a	jsr $2a77			jsr 	BufferClear 				; copy it to the buffer
.2c0f	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace
.2c12					_CTDataLoop:
.2c12	20 a0 33	jsr $33a0			jsr 	LookNext 					; reached EOL
.2c15	f0 08		beq $2c1f			beq 	_CTDataDone
.2c17	20 7b 2a	jsr $2a7b			jsr 	BufferWrite 				; write and consume
.2c1a	20 b1 33	jsr $33b1			jsr 	GetNext
.2c1d	80 f3		bra $2c12			bra 	_CTDataLoop
.2c1f					_CTDataDone:
.2c1f	a9 d0		lda #$d0			lda 	#PCD_CMD_DATA 				; output command and buffer
.2c21	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2c24	20 87 2a	jsr $2a87			jsr 	BufferOutput
.2c27	60		rts				rts
.2c28					CommandDEF:
.2c28	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.2c2a	20 69 2b	jsr $2b69			jsr 	PushIntegerA
.2c2d	20 c1 34	jsr $34c1			jsr 	CompileGotoEOL 				; compile skip over DEF
.2c30	a9 a5		lda #$a5			lda 	#C64_FN
.2c32	20 a8 2a	jsr $2aa8			jsr 	CheckNextA
.2c35	20 bc 33	jsr $33bc			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2c38	20 21 34	jsr $3421			jsr 	ExtractVariableName
.2c3b	8a		txa				txa
.2c3c	10 51		bpl $2c8f			bpl 	_CDError
.2c3e	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2c3f	29 7f		and #$7f			and 	#$7F
.2c41	aa		tax				tax
.2c42	98		tya				tya
.2c43	09 80		ora #$80			ora 	#$80
.2c45	a8		tay				tay
.2c46	20 10 2e	jsr $2e10			jsr 	FindVariable				; does it already exist ?
.2c49	b0 44		bcs $2c8f			bcs 	_CDError 					; if so, that's an error.
.2c4b	20 9b 2b	jsr $2b9b			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.2c4e	20 e0 2b	jsr $2be0			jsr 	SetVariableRecordToCodePosition
.2c51	20 bc 33	jsr $33bc			jsr 	GetNextNonSpace
.2c54	20 fd 36	jsr $36fd			jsr 	GetReferenceTerm 			; get var ref, not array
.2c57	c9 00		cmp #$00			cmp 	#0
.2c59	30 34		bmi $2c8f			bmi 	_CDError
.2c5b	8d c3 06	sta $06c3			sta 	defType 					; save type
.2c5e	8e c4 06	stx $06c4			stx 	defVariable 				; save var ref
.2c61	8c c5 06	sty $06c5			sty 	defVariable+1
.2c64	29 40		and #$40			and 	#NSSString 					; only numbers.
.2c66	d0 27		bne $2c8f			bne 	_CDError
.2c68	20 a2 2a	jsr $2aa2			jsr 	CheckNextRParen 			; check )
.2c6b	a9 b2		lda #$b2			lda 	#C64_EQUAL
.2c6d	20 a8 2a	jsr $2aa8			jsr 	CheckNextA 					; check =
.2c70	18		clc				clc 								; if this is DEF FNxx(A), read A
.2c71	20 92 2c	jsr $2c92			jsr 	CDReadWriteVariable
.2c74	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.2c76	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2c79	38		sec				sec
.2c7a	20 92 2c	jsr $2c92			jsr 	CDReadWriteVariable 		; A is now updated
.2c7d	20 56 2d	jsr $2d56			jsr 	CompileExpressionAt0 		; the actual body of the function.
.2c80	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.2c82	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2c85	38		sec				sec
.2c86	20 92 2c	jsr $2c92			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.2c89	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.2c8b	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2c8e	60		rts				rts
.2c8f					_CDError:
.2c8f	4c 1a 1f	jmp $1f1a		jmp	ErrorV_syntax
.2c92					CDReadWriteVariable:
.2c92	ac c5 06	ldy $06c5			ldy 	defVariable+1 				; set up YX
.2c95	ae c4 06	ldx $06c4			ldx 	defVariable
.2c98	ad c3 06	lda $06c3			lda 	defType
.2c9b	20 af 36	jsr $36af			jsr 	GetSetVariable
.2c9e	60		rts				rts
.06c3					defType:
>06c3							.fill 	1
.06c4					defVariable:
>06c4							.fill 	2
.2c9f					CommandDIM:
.2c9f	20 bc 33	jsr $33bc			jsr 	GetNextNonSpace 			; get the first non space character
.2ca2	20 21 34	jsr $3421			jsr 	ExtractVariableName 		; variable name to XY
.2ca5	da		phx				phx 								; save name with type bits.
.2ca6	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.2ca8	10 37		bpl $2ce1			bpl 	_CDError
.2caa	20 10 2e	jsr $2e10			jsr 	FindVariable	 			; see if already exist
.2cad	b0 35		bcs $2ce4			bcs 	_CDRedefine 				; it still exists.
.2caf	20 9b 2b	jsr $2b9b			jsr 	CreateVariableRecord 		; create the basic variable
.2cb2	20 f0 2b	jsr $2bf0			jsr 	AllocateBytesForType 		; allocate memory for it
.2cb5	68		pla				pla 								; restore type bits
.2cb6	5a		phy				phy 								; save the address of the basic storage
.2cb7	da		phx				phx
.2cb8	48		pha				pha
.2cb9	20 e7 2c	jsr $2ce7			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.2cbc	68		pla				pla
.2cbd	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.2cbf	20 69 2b	jsr $2b69			jsr 	PushIntegerA 				; push that type data out.
.2cc2	a9 cb		lda #$cb			lda 	#(PCD_DIM) >> 8
.2cc4	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2cc7	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.2cc9	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2ccc	fa		plx				plx 								; restore address
.2ccd	7a		ply				ply
.2cce	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2cd0	38		sec				sec
.2cd1	20 af 36	jsr $36af			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.2cd4	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; , follows ?
.2cd7	c9 2c		cmp #$2c			cmp 	#","
.2cd9	d0 05		bne $2ce0			bne 	_CDExit
.2cdb	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume comma
.2cde	80 bf		bra $2c9f			bra 	CommandDIM 					; do another DIM
.2ce0					_CDExit:
.2ce0	60		rts				rts
.2ce1					_CDError:
.2ce1	4c 1a 1f	jmp $1f1a		jmp	ErrorV_syntax
.2ce4					_CDRedefine:
.2ce4	4c e2 1f	jmp $1fe2		jmp	ErrorV_redefine
.2ce7					OutputIndexGroup:
.2ce7	9c c6 06	stz $06c6			stz 	IndexCount 					; count of number of indices.
.2cea					_OIGNext:
.2cea	20 56 2d	jsr $2d56			jsr 	CompileExpressionAt0 		; get a dimension
.2ced	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2cef	c9 00		cmp #$00			cmp 	#NSSIFloat
.2cf1	d0 19		bne $2d0c			bne 	_OIGType
.2cf3	ee c6 06	inc $06c6			inc 	IndexCount 					; bump the counter.
.2cf6	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; does a , follow ?
.2cf9	c9 2c		cmp #$2c			cmp 	#","
.2cfb	d0 05		bne $2d02			bne 	_OIGCheckEnd
.2cfd	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume comma
.2d00	80 e8		bra $2cea			bra 	_OIGNext 					; get next dimension
.2d02					_OIGCheckEnd:
.2d02	20 a2 2a	jsr $2aa2			jsr 	CheckNextRParen 			; check and consume )
.2d05	ad c6 06	lda $06c6			lda 	IndexCount
.2d08	20 69 2b	jsr $2b69			jsr 	PushIntegerA 				; compile the dimension count.
.2d0b	60		rts				rts
.2d0c					_OIGType:
.2d0c	4c 2a 1f	jmp $1f2a		jmp	ErrorV_type
.06c6					IndexCount:
>06c6							.fill 	1
.2d0f					CompilerErrorHandler:
.2d0f	68		pla				pla
.2d10	7a		ply				ply
.2d11	85 2c		sta $2c				sta 	zTemp0
.2d13	84 2d		sty $2d				sty 	zTemp0+1
.2d15	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.2d17	a0 01		ldy #$01			ldy 	#1
.2d19					_EHDisplayMsg:
.2d19	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d1b	20 4d 2a	jsr $2a4d			jsr 	PrintCharacter
.2d1e	c8		iny				iny
.2d1f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d21	d0 f6		bne $2d19			bne 	_EHDisplayMsg
.2d23	a9 20		lda #$20			lda 	#32
.2d25	20 4d 2a	jsr $2a4d			jsr 	PrintCharacter
.2d28	a9 40		lda #$40			lda 	#64
.2d2a	20 4d 2a	jsr $2a4d			jsr 	PrintCharacter
.2d2d	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.2d2f	20 73 26	jsr $2673			jsr 	FloatSetByte
.2d32	20 39 2a	jsr $2a39			jsr 	GetLineNumber
.2d35	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2d37	98		tya				tya
.2d38	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2d3a	20 59 25	jsr $2559			jsr 	FloatToString
.2d3d	a0 00		ldy #$00			ldy 	#0 							; display that string.
.2d3f	a2 00		ldx #$00			ldx 	#0
.2d41					_EHDisplayLine:
.2d41	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d44	20 4d 2a	jsr $2a4d			jsr 	PrintCharacter
.2d47	c8		iny				iny
.2d48	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d4b	d0 f4		bne $2d41			bne 	_EHDisplayLine
.2d4d	a9 0d		lda #$0d			lda 	#13
.2d4f	20 4d 2a	jsr $2a4d			jsr 	PrintCharacter
.2d52	38		sec				sec 								; CS = error
.2d53	4c 4e 2b	jmp $2b4e			jmp 	ExitCompiler
.2d56					CompileExpressionAt0:
.2d56	a9 00		lda #$00			lda 	#0
.2d58					CompileExpressionAtA:
.2d58	48		pha				pha  								; save level
.2d59	20 68 37	jsr $3768			jsr 	CompileTerm 				; compile a term.
.2d5c	fa		plx				plx 								; get level back into X
.2d5d					_ECALoop:
.2d5d	48		pha				pha 								; save type on stack.
.2d5e	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; get the next character
.2d61	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.2d63	90 04		bcc $2d69			bcc 	_ECAExit
.2d65	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.2d67	90 02		bcc $2d6b			bcc 	_ECAHaveToken
.2d69					_ECAExit:
.2d69	68		pla				pla 								; throw type off stack
.2d6a	60		rts				rts
.2d6b					_ECAHaveToken:
.2d6b	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.2d6d	aa		tax				tax 								; X contains the operator token
.2d6e	bd 59 2d	lda $2d59,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.2d71	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.2d73	90 f4		bcc $2d69			bcc 	_ECAExit
.2d75	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.2d77	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume the token.
.2d7a	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.2d7c	f0 11		beq $2d8f			beq 	_ECAGreaterCheck
.2d7e	e0 b3		cpx #$b3			cpx 	#C64_LESS
.2d80	d0 1a		bne $2d9c			bne 	_ECAHaveFullToken
.2d82	20 a0 33	jsr $33a0			jsr 	LookNext 					; checks for < (<= or <>)
.2d85	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.2d87	f0 0e		beq $2d97			beq	 	_ECAToNotEqual
.2d89	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.2d8b	d0 0f		bne $2d9c			bne 	_ECAHaveFullToken
.2d8d	80 07		bra $2d96			bra 	_ECAAddEqual
.2d8f					_ECAGreaterCheck:
.2d8f	20 a0 33	jsr $33a0			jsr 	LookNext
.2d92	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.2d94	d0 06		bne $2d9c			bne 	_ECAHaveFullToken
.2d96					_ECAAddEqual:
.2d96	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.2d97					_ECAToNotEqual:
.2d97	e8		inx				inx
.2d98	e8		inx				inx
.2d99	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume the = or > in >= <= <>
.2d9c					_ECAHaveFullToken:
.2d9c	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.2d9e	d0 0a		bne $2daa			bne 	_ECANotConcat
.2da0	68		pla				pla 								; get type back
.2da1	48		pha				pha
.2da2	29 40		and #$40			and 	#NSSTypeMask
.2da4	c9 40		cmp #$40			cmp 	#NSSString
.2da6	d0 02		bne $2daa			bne 	_ECANotConcat
.2da8	a2 e0		ldx #$e0			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2daa					_ECANotConcat:
.2daa	da		phx				phx 								; save operator on the stack
.2dab	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.2dad	da		phx				phx
.2dae	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.2db0	1a		inc a				inc 	a
.2db1	20 58 2d	jsr $2d58			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.2db4	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.2db6	fa		plx				plx 								; restore current precedence in X
.2db7	68		pla				pla 								; restore operator
.2db8	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.2dba	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.2dbc	90 17		bcc $2dd5			bcc 	_ECANotCompare
.2dbe	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.2dc0	b0 13		bcs $2dd5			bcs 	_ECANotCompare
.2dc2	7a		ply				ply 								; get type into Y
.2dc3	5a		phy				phy
.2dc4	48		pha				pha 								; save operator
.2dc5	98		tya				tya 								; get type
.2dc6	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.2dc8	29 40		and #$40			and 	#NSSTypeMask
.2dca	c9 40		cmp #$40			cmp 	#NSSString
.2dcc	f0 02		beq $2dd0			beq 	_ECANotString
.2dce	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.2dd0					_ECANotString:
.2dd0	98		tya				tya									; output token Y
.2dd1	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2dd4	68		pla				pla 								; restore operator.
.2dd5					_ECANotCompare:
.2dd5	18		clc				clc 								; convert to P-Code and compile.
.2dd6	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.2dd8	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2ddb	68		pla				pla 								; type of current result
.2ddc	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.2dde	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.2de0	d0 19		bne $2dfb			bne		_ECAType
.2de2	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.2de4	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.2de6	d0 18		bne $2e00			bne 	_ECAGoLoop
.2de8	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.2dea	c9 e0		cmp #$e0			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2dec	f0 10		beq $2dfe			beq 	_ECAOkayString 				; (this is post conversion)
.2dee	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.2df0	90 09		bcc $2dfb			bcc 	_ECAType
.2df2	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.2df4	b0 05		bcs $2dfb			bcs 	_ECAType
.2df6	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.2df8	4c 5d 2d	jmp $2d5d			jmp 	_ECALoop
.2dfb					_ECAType:
.2dfb	4c 2a 1f	jmp $1f2a		jmp	ErrorV_type
.2dfe					_ECAOkayString:
.2dfe	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.2e00					_ECAGoLoop:
.2e00	4c 5d 2d	jmp $2d5d			jmp 	_ECALoop
.2e03					PrecedenceTable:
>2e03	03						.byte 	3 					; '+'
>2e04	03						.byte 	3 					; '-'
>2e05	04						.byte 	4 					; '*'
>2e06	04						.byte 	4 					; '/'
>2e07	05						.byte 	5 					; '^'
>2e08	01						.byte 	1 					; 'and'
>2e09	00						.byte 	0 					; 'or'
>2e0a	02						.byte 	2 					; '>'
>2e0b	02						.byte 	2 					; '='
>2e0c	02						.byte 	2 					; '<'
>2e0d	02						.byte 	2 					; '>='
>2e0e	02						.byte 	2 					; '<='
>2e0f	02						.byte 	2 					; '<>'
.2e10					FindVariable:
.2e10	86 2e		stx $2e				stx 	zTemp1 						; save name.
.2e12	84 2f		sty $2f				sty 	zTemp1+1
.2e14					_IVCheckSpecial:
.2e14	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.2e16	d0 18		bne $2e30			bne 	_IVStandard
.2e18	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.2e1a	f0 0c		beq $2e28			beq 	_IVTIFloat
.2e1c	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.2e1e	d0 10		bne $2e30			bne 	_IVStandard
.2e20	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.2e22	a2 01		ldx #$01			ldx 	#$01
.2e24	a9 40		lda #$40			lda 	#NSSString
.2e26	38		sec				sec
.2e27	60		rts				rts
.2e28					_IVTIFloat:
.2e28	a0 80		ldy #$80			ldy 	#$80
.2e2a	a2 00		ldx #$00			ldx 	#$00
.2e2c	a9 00		lda #$00			lda 	#0
.2e2e	38		sec				sec
.2e2f	60		rts				rts
.2e30					_IVStandard:
.2e30	ad c1 06	lda $06c1			lda 	compilerStartHigh			; start scanning from here.
.2e33	85 2d		sta $2d				sta 	zTemp0+1
.2e35	64 2c		stz $2c				stz 	zTemp0
.2e37					_IVCheckLoop:
.2e37	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.2e39	f0 2b		beq $2e66			beq  	_IVNotFound 				; if so, return with CC.
.2e3b	a0 01		ldy #$01			ldy 	#1 							; match ?
.2e3d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e3f	c5 2e		cmp $2e				cmp 	zTemp1
.2e41	d0 07		bne $2e4a			bne	 	_IVNext
.2e43	c8		iny				iny
.2e44	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e46	c5 2f		cmp $2f				cmp 	zTemp1+1
.2e48	f0 0d		beq $2e57			beq 	_IVFound
.2e4a					_IVNext:
.2e4a	18		clc				clc
.2e4b	a5 2c		lda $2c				lda 	zTemp0
.2e4d	72 2c		adc ($2c)			adc 	(zTemp0)
.2e4f	85 2c		sta $2c				sta 	zTemp0
.2e51	90 e4		bcc $2e37			bcc 	_IVCheckLoop
.2e53	e6 2d		inc $2d				inc 	zTemp0+1
.2e55	80 e0		bra $2e37			bra 	_IVCheckLoop
.2e57					_IVFound:
.2e57	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.2e59	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e5b	aa		tax				tax
.2e5c	c8		iny				iny
.2e5d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e5f	48		pha				pha
.2e60	c8		iny				iny
.2e61	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e63	7a		ply				ply
.2e64	38		sec				sec
.2e65	60		rts				rts
.2e66					_IVNotFound:
.2e66	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.2e68	a4 2f		ldy $2f				ldy 	zTemp1+1
.2e6a	18		clc				clc
.2e6b	60		rts				rts
.2e6c					FixBranches:
.2e6c	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.2e6e	20 53 2b	jsr $2b53			jsr 	CallAPIHandler
.2e71					_FBLoop:
.2e71	b2 2a		lda ($2a)			lda 	(objPtr) 					; get the next one.
.2e73	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.2e75	f0 16		beq $2e8d			beq 	_FBFixGotoGosub
.2e77	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOSUB
.2e79	f0 12		beq $2e8d			beq 	_FBFixGotoGosub
.2e7b	c9 d4		cmp #$d4			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.2e7d	f0 0e		beq $2e8d			beq 	_FBFixGotoGosub
.2e7f	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_Z
.2e81	f0 0a		beq $2e8d			beq 	_FBFixGotoGosub
.2e83	c9 d5		cmp #$d5			cmp 	#PCD_CMD_VARSPACE
.2e85	f0 3b		beq $2ec2			beq 	_FBFixVarSpace
.2e87					_FBNext:
.2e87	20 40 20	jsr $2040			jsr 	MoveObjectForward 			; move forward in object code.
.2e8a	90 e5		bcc $2e71			bcc 	_FBLoop 					; not finished
.2e8c					_FBExit:
.2e8c	60		rts				rts
.2e8d					_FBFixGotoGosub:
.2e8d	a0 01		ldy #$01			ldy 	#1							; line number in YA
.2e8f	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e91	48		pha				pha
.2e92	c8		iny				iny
.2e93	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e95	a8		tay				tay
.2e96	68		pla				pla
.2e97	20 53 35	jsr $3553			jsr 	STRFindLine			 		; find where it is YA
.2e9a	90 08		bcc $2ea4			bcc 	_FBFFound 					; not found, so must be >
.2e9c	48		pha				pha
.2e9d	b2 2a		lda ($2a)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.2e9f	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_Z
.2ea1	d0 0f		bne $2eb2			bne 	_FBFFail
.2ea3	68		pla				pla
.2ea4					_FBFFound:
.2ea4	20 a3 35	jsr $35a3			jsr 	STRMakeOffset 				; make it an offset from X:YA
.2ea7	5a		phy				phy	 								; patch the GOTO/GOSUB
.2ea8	a0 01		ldy #$01			ldy 	#1
.2eaa	91 2a		sta ($2a),y			sta 	(objPtr),y
.2eac	c8		iny				iny
.2ead	68		pla				pla
.2eae	91 2a		sta ($2a),y			sta 	(objPtr),y
.2eb0	80 d5		bra $2e87			bra 	_FBNext
.2eb2					_FBFFail:
.2eb2	a0 02		ldy #$02			ldy 	#2
.2eb4	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2eb6	8d ba 05	sta $05ba			sta 	currentLineNumber
.2eb9	c8		iny				iny
.2eba	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ebc	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2ebf	4c 5d 1f	jmp $1f5d		jmp	ErrorV_line
.2ec2					_FBFixVarSpace:
.2ec2	a0 01		ldy #$01			ldy 	#1
.2ec4	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2ec7	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ec9	c8		iny				iny
.2eca	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2ecd	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ecf	80 b6		bra $2e87			bra 	_FBNext
.2ed1					CommandFOR:
.2ed1	20 bc 33	jsr $33bc			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.2ed4	20 d2 33	jsr $33d2			jsr 	CharIsAlpha 				; if not alpha , error
.2ed7	90 59		bcc $2f32			bcc 	_CFFail
.2ed9	20 fd 36	jsr $36fd			jsr 	GetReferenceTerm 			; figure out the reference.
.2edc	48		pha				pha 								; save type
.2edd	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2edf	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ee1	d0 4f		bne $2f32			bne 	_CFFail
.2ee3	5a		phy				phy 								; save reference on the stack
.2ee4	da		phx				phx
.2ee5	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.2ee7	20 a8 2a	jsr $2aa8			jsr 	CheckNextA
.2eea	20 56 2d	jsr $2d56			jsr 	CompileExpressionAt0 		; initial value
.2eed	fa		plx				plx 								; get reference back.
.2eee	7a		ply				ply
.2eef	5a		phy				phy
.2ef0	da		phx				phx
.2ef1	38		sec				sec 								; set initial value.
.2ef2	20 af 36	jsr $36af			jsr 	GetSetVariable
.2ef5	fa		plx				plx
.2ef6	7a		ply				ply
.2ef7	68		pla				pla
.2ef8	29 20		and #$20			and 	#NSSIInt16
.2efa	f0 04		beq $2f00			beq 	_CFNotInt16
.2efc	98		tya				tya
.2efd	09 80		ora #$80			ora 	#$80
.2eff	a8		tay				tay
.2f00					_CFNotInt16:
.2f00	8a		txa				txa 								; reference in YA
.2f01	20 56 2b	jsr $2b56			jsr 	PushIntegerYA
.2f04	a9 a4		lda #$a4			lda 	#C64_TO
.2f06	20 a8 2a	jsr $2aa8			jsr 	CheckNextA
.2f09	20 56 2d	jsr $2d56			jsr 	CompileExpressionAt0 		; terminal value
.2f0c	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f0e	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f10	d0 20		bne $2f32			bne 	_CFFail
.2f12	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; followed by STEP
.2f15	c9 a9		cmp #$a9			cmp 	#C64_STEP
.2f17	d0 0e		bne $2f27			bne 	_CFNoStep
.2f19	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume it.
.2f1c	20 56 2d	jsr $2d56			jsr 	CompileExpressionAt0 		; terminal value
.2f1f	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f21	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f23	d0 0d		bne $2f32			bne 	_CFFail
.2f25	80 05		bra $2f2c			bra 	_CFParametersDone
.2f27					_CFNoStep:
.2f27	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.2f29	20 69 2b	jsr $2b69			jsr 	PushIntegerA
.2f2c					_CFParametersDone:
.2f2c	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2f2e	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2f31	60		rts				rts
.2f32					_CFFail:
.2f32	4c 1a 1f	jmp $1f1a		jmp	ErrorV_syntax
.2f35					FNCompile:
.2f35	20 bc 33	jsr $33bc			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2f38	20 21 34	jsr $3421			jsr 	ExtractVariableName
.2f3b	e0 00		cpx #$00			cpx 	#0
.2f3d	10 32		bpl $2f71			bpl 	_FNError
.2f3f	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2f40	29 7f		and #$7f			and 	#$7F
.2f42	aa		tax				tax
.2f43	98		tya				tya
.2f44	09 80		ora #$80			ora 	#$80
.2f46	a8		tay				tay
.2f47	20 10 2e	jsr $2e10			jsr 	FindVariable				; does it already exist ?
.2f4a	90 25		bcc $2f71			bcc 	_FNError 					; no.
.2f4c	20 a3 35	jsr $35a3			jsr 	STRMakeOffset 				; convert to a relative address.
.2f4f	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2f51	d0 01		bne $2f54			bne 	_FNNoBorrow
.2f53	88		dey				dey
.2f54					_FNNoBorrow:
.2f54	3a		dec a				dec 	a
.2f55	5a		phy				phy 								; save location of routine on stack.
.2f56	48		pha				pha
.2f57	da		phx				phx
.2f58	20 56 2d	jsr $2d56			jsr 	CompileExpressionAt0
.2f5b	20 a2 2a	jsr $2aa2			jsr 	CheckNextRParen
.2f5e	a9 d2		lda #$d2			lda 	#PCD_CMD_GOSUB
.2f60	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2f63	68		pla				pla
.2f64	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2f67	68		pla				pla
.2f68	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2f6b	68		pla				pla
.2f6c	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.2f6f	18		clc				clc
.2f70	60		rts				rts
.2f71					_FNError:
.2f71	4c 0d 1f	jmp $1f0d		jmp	ErrorV_value
.2f74					CommandTables:
>2f74	07 cb 00 03 7f 34 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2f7b	07 89 00 03 86 34 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2f82	07 8d 00 03 79 34 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>2f89	07 88 00 03 f5 34 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2f90	07 85 00 03 d5 34 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>2f97	07 84 00 04 e9 34 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>2f9e	07 99 00 03 2a 36 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2fa5	07 98 00 04 2a 36 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2fac	07 8f 00 03 35 37 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>2fb3	07 81 00 03 d1 2e 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>2fba	07 82 00 03 ad 35 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>2fc1	07 a1 00 03 f2 33 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>2fc8	07 83 00 03 0c 2c 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>2fcf	07 87 00 03 73 36 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>2fd6	07 86 00 03 9f 2c 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>2fdd	07 96 00 03 28 2c 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>2fe4	07 8b 00 e3 a2 34 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>2feb	08 92 00 ea e3 01 38 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>2ff3	09 91 00 e1 a9 03 d9 35			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>2ffb	06
>2ffc	07 9e 00 e2 cb 92 06			.byte	$07,$9e,$00,$e2,37579 & $FF,37579 >> 8,$06
>3003	07 97 00 ea e1 ad 06			.byte	$07,$97,$00,$ea,$e1,173,$06
>300a	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>3010	07 90 00 20 cb 91 06			.byte	$07,$90,$00,$20,37323 & $FF,37323 >> 8,$06
>3017	07 80 00 20 cb 82 06			.byte	$07,$80,$00,$20,33483 & $FF,33483 >> 8,$06
>301e	07 8c 00 20 cb 90 06			.byte	$07,$8c,$00,$20,37067 & $FF,37067 >> 8,$06
>3025	07 9d 00 e3 27 38 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>302c	0a 9f 00 ea e3 3a 38 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,199,$06
>3034	c7 06
>3036	06 a0 00 e1 c4 06			.byte	$06,$a0,$00,$e1,196,$06
>303c	07 ce 90 20 cb ac 06			.byte	$07,$ce,$90,$20,44235 & $FF,44235 >> 8,$06
>3043	0a ce 92 e3 6f 33 20 cb			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44491 & $FF,44491 >> 8,$06
>304b	ad 06
>304d	0a ce 8d e3 6f 33 20 cb			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44747 & $FF,44747 >> 8,$06
>3055	ae 06
>3057	06 ce 86 e1 c8 06			.byte	$06,$ce,$86,$e1,200,$06
>305d	08 ce 84 ea ea e1 c9 06			.byte	$08,$ce,$84,$ea,$ea,$e1,201,$06
>3065	07 ce af e2 cb 98 06			.byte	$07,$ce,$af,$e2,39115 & $FF,39115 >> 8,$06
>306c	07 ce 8c e2 cb 8c 06			.byte	$07,$ce,$8c,$e2,36043 & $FF,36043 >> 8,$06
>3073	09 ce ae ea ea e2 cb 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38347 & $FF,38347 >> 8,$06
>307b	06
>307c	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>3084	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>308c	9a 06
>308e	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>3096	9b 06
>3098	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>30a0	9c 06
>30a2	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>30aa	06
>30ab	07 ce 99 20 cb 99 06			.byte	$07,$ce,$99,$20,39371 & $FF,39371 >> 8,$06
>30b2	08 ce 9a ea e2 cb 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39627 & $FF,39627 >> 8,$06
>30ba	08 ce 9b ea e2 cb 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39883 & $FF,39883 >> 8,$06
>30c2	08 ce 9c ea e2 cb 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40139 & $FF,40139 >> 8,$06
>30ca	08 ce 9d ea e2 cb 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40395 & $FF,40395 >> 8,$06
>30d2	08 ce 9e ea e2 cb 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40651 & $FF,40651 >> 8,$06
>30da	08 ce 9f ea e2 cb 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40907 & $FF,40907 >> 8,$06
>30e2	08 ce a0 ea e2 cb a0 06			.byte	$08,$ce,$a0,$ea,$e2,41163 & $FF,41163 >> 8,$06
>30ea	08 ce a1 ea f2 cb a1 06			.byte	$08,$ce,$a1,$ea,$f2,41419 & $FF,41419 >> 8,$06
>30f2	08 ce a2 ea f2 cb a2 06			.byte	$08,$ce,$a2,$ea,$f2,41675 & $FF,41675 >> 8,$06
>30fa	08 ce a3 ea e2 cb a3 06			.byte	$08,$ce,$a3,$ea,$e2,41931 & $FF,41931 >> 8,$06
>3102	07 ce a4 20 cb a4 06			.byte	$07,$ce,$a4,$20,42187 & $FF,42187 >> 8,$06
>3109	08 ce a5 ea e2 cb a5 06			.byte	$08,$ce,$a5,$ea,$e2,42443 & $FF,42443 >> 8,$06
>3111	08 ce a6 ea e2 cb a6 06			.byte	$08,$ce,$a6,$ea,$e2,42699 & $FF,42699 >> 8,$06
>3119	08 ce a7 ea e2 cb a7 06			.byte	$08,$ce,$a7,$ea,$e2,42955 & $FF,42955 >> 8,$06
>3121	08 ce a8 ea e2 cb a8 06			.byte	$08,$ce,$a8,$ea,$e2,43211 & $FF,43211 >> 8,$06
>3129	08 ce a9 ea e2 cb a9 06			.byte	$08,$ce,$a9,$ea,$e2,43467 & $FF,43467 >> 8,$06
>3131	08 ce aa ea f2 cb aa 06			.byte	$08,$ce,$aa,$ea,$f2,43723 & $FF,43723 >> 8,$06
>3139	08 ce ab ea f2 cb ab 06			.byte	$08,$ce,$ab,$ea,$f2,43979 & $FF,43979 >> 8,$06
>3141	00						.byte 	0
.3142					UnaryTables:
>3142	07 b4 00 8e 91 b7 06			.byte	$07,$b4,$00,$8e,$91,183,$06
>3149	08 b5 00 8e 92 cb 84 06			.byte	$08,$b5,$00,$8e,$92,33995 & $FF,33995 >> 8,$06
>3151	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>3158	07 b7 00 8e 91 c2 06			.byte	$07,$b7,$00,$8e,$91,194,$06
>315f	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>3166	07 b9 00 8e 91 ae 06			.byte	$07,$b9,$00,$8e,$91,174,$06
>316d	08 ba 00 8e 92 cb 85 06			.byte	$08,$ba,$00,$8e,$92,34251 & $FF,34251 >> 8,$06
>3175	07 bb 00 8e 91 b5 06			.byte	$07,$bb,$00,$8e,$91,181,$06
>317c	08 bc 00 8e 92 cb 86 06			.byte	$08,$bc,$00,$8e,$92,34507 & $FF,34507 >> 8,$06
>3184	08 bd 00 8e 92 cb 87 06			.byte	$08,$bd,$00,$8e,$92,34763 & $FF,34763 >> 8,$06
>318c	08 be 00 8e 92 cb 88 06			.byte	$08,$be,$00,$8e,$92,35019 & $FF,35019 >> 8,$06
>3194	08 bf 00 8e 92 cb 89 06			.byte	$08,$bf,$00,$8e,$92,35275 & $FF,35275 >> 8,$06
>319c	08 c0 00 8e 92 cb 8a 06			.byte	$08,$c0,$00,$8e,$92,35531 & $FF,35531 >> 8,$06
>31a4	08 c1 00 8e 92 cb 8b 06			.byte	$08,$c1,$00,$8e,$92,35787 & $FF,35787 >> 8,$06
>31ac	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>31b3	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>31ba	07 c4 00 8e 91 bb 07			.byte	$07,$c4,$00,$8e,$91,187,$07
>31c1	07 c5 00 8f 91 c3 06			.byte	$07,$c5,$00,$8f,$91,195,$06
>31c8	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>31cf	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>31d6	08 c8 00 8f ae 91 bc 07			.byte	$08,$c8,$00,$8f,$ae,$91,188,$07
>31de	08 c9 00 8f ae 91 bd 07			.byte	$08,$c9,$00,$8f,$ae,$91,189,$07
>31e6	0b ca 00 8f ae 03 6f 33			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,190,$07
>31ee	91 be 07
>31f1	07 a8 00 03 8e 33 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>31f8	07 a5 00 03 35 2f 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>31ff	06 ff 00 10 ac 06			.byte	$06,$ff,$00,$10,172,$06
>3205	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>320c	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>3213	08 ce d0 8e ae 91 ca 06			.byte	$08,$ce,$d0,$8e,$ae,$91,202,$06
>321b	08 ce d4 8e 92 cb 83 06			.byte	$08,$ce,$d4,$8e,$92,33739 & $FF,33739 >> 8,$06
>3223	07 ce d3 20 cb 8d 06			.byte	$07,$ce,$d3,$20,36299 & $FF,36299 >> 8,$06
>322a	07 ce d1 20 cb 8e 06			.byte	$07,$ce,$d1,$20,36555 & $FF,36555 >> 8,$06
>3231	07 ce d2 20 cb 8f 06			.byte	$07,$ce,$d2,$20,36811 & $FF,36811 >> 8,$06
>3238	09 ce d7 8e ae 92 cb 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38603 & $FF,38603 >> 8,$06
>3240	06
>3241	00						.byte 	0
.3242					GeneratorProcess:
.3242	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.3244	84 2d		sty $2d				sty 	zTemp0+1
.3246	85 2e		sta $2e				sta 	zTemp1 						; first match token
.3248	64 2f		stz $2f				stz 	zTemp1+1
.324a	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.324c	d0 05		bne $3253			bne 	_GPNotShifted
.324e	20 b1 33	jsr $33b1			jsr 	GetNext 					; get the shifted token
.3251	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.3253					_GPNotShifted:
.3253					_GPSearch:
.3253	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.3255	18		clc				clc
.3256	f0 2f		beq $3287			beq 	_GPExit
.3258	a0 01		ldy #$01			ldy 	#1 							; tokens match
.325a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.325c	c5 2e		cmp $2e				cmp 	zTemp1
.325e	d0 09		bne $3269			bne 	_GPNext
.3260	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.3262	f0 12		beq $3276			beq 	_GPFound
.3264	c8		iny				iny 								; check match.
.3265	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.3267	f0 0d		beq $3276			beq 	_GPFound
.3269					_GPNext:
.3269	18		clc				clc 								; follow to next
.326a	a5 2c		lda $2c				lda 	zTemp0
.326c	72 2c		adc ($2c)			adc 	(zTemp0)
.326e	85 2c		sta $2c				sta 	zTemp0
.3270	90 e1		bcc $3253			bcc 	_GPSearch
.3272	e6 2d		inc $2d				inc 	zTemp0+1
.3274	80 dd		bra $3253			bra 	_GPSearch
.3276					_GPFound:
.3276	18		clc				clc 								; skip to action bytes
.3277	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.3279	69 03		adc #$03			adc 	#3
.327b	85 2c		sta $2c				sta 	zTemp0
.327d	90 02		bcc $3281			bcc 	_GPNoCarry
.327f	e6 2d		inc $2d				inc 	zTemp0+1
.3281					_GPNoCarry:
.3281					_GPLoop:
.3281	20 88 32	jsr $3288			jsr 	GeneratorExecute 			; execute one command
.3284	90 fb		bcc $3281			bcc 	_GPLoop 					; go back if not completed.
.3286	38		sec				sec 								; return with CS.
.3287					_GPExit:
.3287	60		rts				rts
.3288					GeneratorExecute:
.3288	20 34 33	jsr $3334			jsr 	_GEFetchZTemp0 				; get next.
.328b	48		pha				pha 								; split into 2 nibbles
.328c	4a		lsr a				lsr 	a
.328d	4a		lsr a				lsr 	a
.328e	4a		lsr a				lsr		a
.328f	4a		lsr a				lsr 	a
.3290	20 9a 32	jsr $329a			jsr 	_GEExecuteNibble 			; MSB first
.3293	68		pla				pla
.3294	b0 03		bcs $3299			bcs 	_GEHaveCompleted
.3296	20 9a 32	jsr $329a			jsr 	_GEExecuteNibble 			; LSB second
.3299					_GEHaveCompleted:
.3299	60		rts				rts
.329a					_GEExecuteNibble:
.329a	29 0f		and #$0f			and 	#$0F
.329c	0a		asl a				asl 	a
.329d	aa		tax				tax
.329e	7c a1 32	jmp ($32a1,x)			jmp 	(_GEExecuteVectors,x)
.32a1					_GEExecuteVectors:
>32a1	c1 32						.word 	_GEXNop 					; 0  (no operation)
>32a3	c9 32						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>32a5	c3 32						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>32a7	17 33						.word 	_GEXExecute 				; 3  (run arbitrary code)
>32a9	0a 33						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>32ab	c1 32						.word 	_GEXNop 					; 5
>32ad	d1 32						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>32af	d5 32						.word 	_GEXExitString 				; 7  exit return string type
>32b1	d9 32						.word 	_GEXLParam 					; 8  check ( follows
>32b3	dd 32						.word 	_GEXRParam 					; 9  check ) follows
>32b5	e1 32						.word 	_GEXComma					; A  check , follows
>32b7	c1 32						.word 	_GEXNop 					; B
>32b9	c1 32						.word 	_GEXNop 					; C
>32bb	c1 32						.word 	_GEXNop 					; D
>32bd	f1 32						.word 	_GEXNumber 					; E  compile get any number
>32bf	fc 32						.word 	_GEXString 					; F  compile get any string
.32c1					_GEXNop:
.32c1	18		clc				clc
.32c2	60		rts				rts
.32c3					_GEXToken2:
.32c3	20 34 33	jsr $3334			jsr 	_GEFetchZTemp0
.32c6	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.32c9					_GEXToken1:
.32c9	20 34 33	jsr $3334			jsr 	_GEFetchZTemp0
.32cc	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.32cf	18		clc				clc
.32d0	60		rts				rts
.32d1					_GEXExitNumber:
.32d1	a9 00		lda #$00			lda 	#NSSIFloat
.32d3	38		sec				sec
.32d4	60		rts				rts
.32d5					_GEXExitString:
.32d5	a9 40		lda #$40			lda 	#NSSString
.32d7	38		sec				sec
.32d8	60		rts				rts
.32d9					_GEXLParam:
.32d9	a9 28		lda #$28			lda 	#"("
.32db	80 06		bra $32e3			bra 	_GEXCheck
.32dd					_GEXRParam:
.32dd	a9 29		lda #$29			lda 	#")"
.32df	80 02		bra $32e3			bra 	_GEXCheck
.32e1					_GEXComma:
.32e1	a9 2c		lda #$2c			lda 	#","
.32e3					_GEXCheck:
.32e3	85 30		sta $30				sta 	zTemp2 						; save match
.32e5	20 bc 33	jsr $33bc			jsr 	GetNextNonSpace 			; get next skipping spaces
.32e8	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.32ea	d0 02		bne $32ee			bne 	_GEXSyntax
.32ec	18		clc				clc
.32ed	60		rts				rts
.32ee					_GEXSyntax:
.32ee	4c 1a 1f	jmp $1f1a		jmp	ErrorV_syntax
.32f1					_GEXNumber:
.32f1	20 3d 33	jsr $333d			jsr 	GEXCompileExpression 		; compile expression
.32f4	29 40		and #$40			and 	#NSSTypeMask
.32f6	c9 00		cmp #$00			cmp  	#NSSIFloat
.32f8	d0 0d		bne $3307			bne 	_GEXType
.32fa	18		clc				clc
.32fb	60		rts				rts
.32fc					_GEXString:
.32fc	20 3d 33	jsr $333d			jsr 	GEXCompileExpression 		; compile expression
.32ff	29 40		and #$40			and 	#NSSTypeMask
.3301	c9 40		cmp #$40			cmp  	#NSSString
.3303	d0 02		bne $3307			bne 	_GEXType
.3305	18		clc				clc
.3306	60		rts				rts
.3307					_GEXType:
.3307	4c 2a 1f	jmp $1f2a		jmp	ErrorV_type
.330a					_GEXChannelExec:
.330a	20 4d 33	jsr $334d			jsr 	ChannelPrefix 				; set up default
.330d	20 17 33	jsr $3317			jsr 	_GEXExecute
.3310	08		php				php
.3311	20 68 33	jsr $3368			jsr 	ChannelPostfix 				; replace default.
.3314	28		plp				plp
.3315	60		rts				rts
>3316	db						.byte 	$DB 						; causes a break in the emulator
.3317					_GEXExecute:
.3317	20 34 33	jsr $3334			jsr 	_GEFetchZTemp0 				; get vector
.331a	85 30		sta $30				sta 	zTemp2
.331c	20 34 33	jsr $3334			jsr 	_GEFetchZTemp0
.331f	85 31		sta $31				sta 	zTemp2+1
.3321	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.3323	da		phx				phx
.3324	a6 2d		ldx $2d				ldx 	zTemp0+1
.3326	da		phx				phx
.3327	20 31 33	jsr $3331			jsr 	_GECallZTemp2 				; execute code
.332a	fa		plx				plx 								; recover generation exec
.332b	86 2d		stx $2d				stx 	zTemp0+1
.332d	fa		plx				plx
.332e	86 2c		stx $2c				stx 	zTemp0
.3330	60		rts				rts
.3331					_GECallZTemp2:
.3331	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.3334					_GEFetchZTemp0:
.3334	b2 2c		lda ($2c)			lda 	(zTemp0)
.3336	e6 2c		inc $2c				inc 	zTemp0
.3338	d0 02		bne $333c			bne 	_GEFZ0Skip
.333a	e6 2d		inc $2d				inc 	zTemp0+1
.333c					_GEFZ0Skip:
.333c	60		rts				rts
.333d					GEXCompileExpression:
.333d	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.333f	da		phx				phx
.3340	a6 2d		ldx $2d				ldx 	zTemp0+1
.3342	da		phx				phx
.3343	20 56 2d	jsr $2d56			jsr 	CompileExpressionAt0 		; compile expression.
.3346	fa		plx				plx 								; recover generation exec
.3347	86 2d		stx $2d				stx 	zTemp0+1
.3349	fa		plx				plx
.334a	86 2c		stx $2c				stx 	zTemp0
.334c	60		rts				rts
.334d					ChannelPrefix:
.334d	a9 af		lda #$af			lda 	#PCD_GETCHANNEL				; set channel onto stack
.334f	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.3352	20 3d 33	jsr $333d			jsr 	GEXCompileExpression 		; channel #
.3355	29 40		and #$40			and 	#NSSTypeMask
.3357	c9 00		cmp #$00			cmp 	#NSSIFloat
.3359	d0 0a		bne $3365			bne 	_CPXType
.335b	20 9e 2a	jsr $2a9e			jsr 	CheckNextComma 				; check , follows.
.335e	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL				; set channel
.3360	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.3363	18		clc				clc
.3364	60		rts				rts
.3365					_CPXType:
.3365	4c 2a 1f	jmp $1f2a		jmp	ErrorV_type
.3368					ChannelPostfix:
.3368	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.336a	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.336d	18		clc				clc
.336e	60		rts				rts
.336f					OptionalParameterCompile:
.336f	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; what follows.
.3372	c9 2c		cmp #$2c			cmp 	#","
.3374	d0 0e		bne $3384			bne 	_MidDefault
.3376	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume ,
.3379	20 56 2d	jsr $2d56			jsr 	CompileExpressionAt0
.337c	29 40		and #$40			and 	#NSSTypeMask
.337e	c9 00		cmp #$00			cmp 	#NSSIFloat
.3380	d0 09		bne $338b			bne 	MidFailType
.3382	80 05		bra $3389			bra 	_MidComplete
.3384					_MidDefault:
.3384	a9 ff		lda #$ff			lda 	#255 						; default of 255
.3386	20 69 2b	jsr $2b69			jsr 	PushIntegerA
.3389					_MidComplete:
.3389	18		clc				clc
.338a	60		rts				rts
.338b					MidFailType:
.338b	4c 2a 1f	jmp $1f2a		jmp	ErrorV_type
.338e					NotUnaryCompile:
.338e	ad 0b 2e	lda $2e0b			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.3391	20 58 2d	jsr $2d58			jsr 	CompileExpressionAtA 		; evaluate at that level
.3394	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.3396	c9 00		cmp #$00			cmp 	#NSSIFloat
.3398	d0 f1		bne $338b			bne 	MidFailType
.339a	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.339c	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.339f	60		rts				rts
.33a0					LookNext:
.33a0	b2 7a		lda ($7a)			lda 	(srcPtr)
.33a2	60		rts				rts
.33a3					LookNextNonSpace:
.33a3	b2 7a		lda ($7a)			lda 	(srcPtr)
.33a5	c9 20		cmp #$20			cmp		#' '
.33a7	f0 03		beq $33ac			beq 	_LNNSkip
.33a9	c9 00		cmp #$00			cmp 	#0
.33ab	60		rts				rts
.33ac					_LNNSkip:
.33ac	20 b1 33	jsr $33b1			jsr 	GetNext
.33af	80 f2		bra $33a3			bra 	LookNextNonSpace
.33b1					GetNext:
.33b1	b2 7a		lda ($7a)			lda 	(srcPtr) 					; get next
.33b3	e6 7a		inc $7a				inc 	srcPtr
.33b5	d0 02		bne $33b9			bne 	_GNSkip
.33b7	e6 7b		inc $7b				inc 	srcPtr+1
.33b9					_GNSkip:
.33b9	c9 00		cmp #$00			cmp 	#0
.33bb	60		rts				rts
.33bc					GetNextNonSpace:
.33bc	20 b1 33	jsr $33b1			jsr 	GetNext
.33bf	c9 20		cmp #$20			cmp 	#' '
.33c1	f0 f9		beq $33bc			beq 	GetNextNonSpace
.33c3	c9 00		cmp #$00			cmp 	#0
.33c5	60		rts				rts
.33c6					CharIsDigit:
.33c6	c9 30		cmp #$30			cmp 	#"0"
.33c8	90 06		bcc $33d0			bcc 	CCFalse
.33ca	c9 3a		cmp #$3a			cmp 	#"9"+1
.33cc	b0 02		bcs $33d0			bcs 	CCFalse
.33ce					CCTrue:
.33ce	38		sec				sec
.33cf	60		rts				rts
.33d0					CCFalse:
.33d0	18		clc				clc
.33d1	60		rts				rts
.33d2					CharIsAlpha:
.33d2	c9 41		cmp #$41			cmp 	#"A"
.33d4	90 fa		bcc $33d0			bcc 	CCFalse
.33d6	c9 5b		cmp #$5b			cmp 	#"Z"+1
.33d8	b0 f6		bcs $33d0			bcs 	CCFalse
.33da	80 f2		bra $33ce			bra 	CCTrue
.33dc					ConvertHexStyle:
.33dc	38		sec				sec
.33dd	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.33df	90 ef		bcc $33d0			bcc 	CCFalse
.33e1	c9 0a		cmp #$0a			cmp 	#9+1
.33e3	90 e9		bcc $33ce			bcc 	CCTrue
.33e5	38		sec				sec 								; shift into hex space A=>0 Z=>25
.33e6	e9 11		sbc #$11			sbc 	#"A"-"0"
.33e8	90 e6		bcc $33d0			bcc 	CCFalse
.33ea	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.33ec	b0 e2		bcs $33d0			bcs 	CCFalse
.33ee	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.33f0	80 dc		bra $33ce			bra 	CCTrue
.33f2					CommandGET:
.33f2	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; # follows ?
.33f5	c9 23		cmp #$23			cmp 	#"#"
.33f7	d0 0d		bne $3406			bne 	CommandGetBody
.33f9	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume #
.33fc	20 4d 33	jsr $334d			jsr 	ChannelPrefix 				; do it as GET#
.33ff	20 06 34	jsr $3406			jsr 	CommandGetBody
.3402	20 68 33	jsr $3368			jsr 	ChannelPostfix
.3405	60		rts				rts
.3406					CommandGetBody:
.3406	20 bc 33	jsr $33bc			jsr 	GetNextNonSpace 			; get the first character
.3409	20 fd 36	jsr $36fd			jsr 	GetReferenceTerm 			; identify variable to assign to
.340c	48		pha				pha
.340d	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.340f	c9 40		cmp #$40			cmp 	#NSSString
.3411	d0 0b		bne $341e			bne 	_CGType
.3413	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.3415	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.3418	38		sec				sec
.3419	68		pla				pla
.341a	20 af 36	jsr $36af			jsr		GetSetVariable
.341d	60		rts				rts
.341e					_CGType:
.341e	4c 2a 1f	jmp $1f2a		jmp	ErrorV_type
.3421					ExtractVariableName:
.3421	20 d2 33	jsr $33d2			jsr 	CharIsAlpha
.3424	90 50		bcc $3476			bcc 	_IVSyntax
.3426	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.3428	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.342a	64 2f		stz $2f				stz 	zTemp1+1
.342c	20 a0 33	jsr $33a0			jsr 	LookNext 					; is there a second character ?
.342f	20 d2 33	jsr $33d2			jsr 	CharIsAlpha  				; must be alphanumeric
.3432	b0 05		bcs $3439			bcs 	_IVHasSecond
.3434	20 c6 33	jsr $33c6			jsr 	CharIsDigit
.3437	90 07		bcc $3440			bcc 	_IVCheckType
.3439					_IVHasSecond:
.3439	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.343b	85 2f		sta $2f				sta 	zTemp1+1
.343d					_IVGetNextCheck:
.343d	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume it
.3440					_IVCheckType:
.3440	20 a0 33	jsr $33a0			jsr 	LookNext					; check if string follows.
.3443	20 d2 33	jsr $33d2			jsr 	CharIsAlpha
.3446	b0 f5		bcs $343d			bcs 	_IVGetNextCheck
.3448	20 c6 33	jsr $33c6			jsr 	CharIsDigit
.344b	b0 f0		bcs $343d			bcs 	_IVGetNextCheck
.344d	a2 40		ldx #$40			ldx 	#NSSString
.344f	c9 24		cmp #$24			cmp 	#"$"
.3451	f0 06		beq $3459			beq 	_IVHasType
.3453	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.3455	c9 25		cmp #$25			cmp 	#"%"
.3457	d0 08		bne $3461			bne 	_IVCheckArray
.3459					_IVHasType:
.3459	8a		txa				txa 								; Or X into zTemp1
.345a	05 2e		ora $2e				ora 	zTemp1
.345c	85 2e		sta $2e				sta 	zTemp1
.345e	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume it
.3461					_IVCheckArray:
.3461	20 a0 33	jsr $33a0			jsr 	LookNext 					; check if array follows
.3464	c9 28		cmp #$28			cmp 	#"("
.3466	d0 09		bne $3471			bne 	_IVNotArray
.3468	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.346a	09 80		ora #$80			ora 	#NSSArray
.346c	85 2e		sta $2e				sta 	zTemp1
.346e	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume it
.3471					_IVNotArray:
.3471	a6 2e		ldx $2e				ldx 	zTemp1
.3473	a4 2f		ldy $2f				ldy 	zTemp1+1
.3475	60		rts				rts
.3476					_IVSyntax:
.3476	4c 1a 1f	jmp $1f1a		jmp	ErrorV_syntax
.3479					CommandGOSUB:
.3479	a9 d2		lda #$d2			lda 	#PCD_CMD_GOSUB
.347b	20 8c 34	jsr $348c			jsr 	CompileBranchCommand
.347e	60		rts				rts
.347f					CommandGOAlt:
.347f	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.3481	20 a8 2a	jsr $2aa8			jsr 	CheckNextA
.3484	80 00		bra $3486			bra 	CommandGOTO
.3486					CommandGOTO:
.3486	a9 d1		lda #$d1			lda 	#PCD_CMD_GOTO
.3488	20 8c 34	jsr $348c			jsr 	CompileBranchCommand
.348b	60		rts				rts
.348c					CompileBranchCommand:
.348c	20 40 2a	jsr $2a40			jsr 	WriteCodeByte 				; write the command out.
.348f	20 bc 33	jsr $33bc			jsr 	GetNextNonSpace
.3492	20 05 36	jsr $3605			jsr 	ParseConstant 				; get constant into YA
.3495	90 08		bcc $349f			bcc 	_CBCSyntax
.3497	20 40 2a	jsr $2a40			jsr 	WriteCodeByte				; and compile the actual line number
.349a	98		tya				tya
.349b	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.349e	60		rts				rts
.349f					_CBCSyntax:
.349f	4c 1a 1f	jmp $1f1a		jmp	ErrorV_syntax
.34a2					CommandIF:
.34a2	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; what follows the tests ?
.34a5	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.34a7	f0 0f		beq $34b8			beq 	_CIGoto
.34a9	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.34ab	20 a8 2a	jsr $2aa8			jsr 	CheckNextA
.34ae	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; THEN <number>
.34b1	20 c6 33	jsr $33c6			jsr 	CharIsDigit
.34b4	b0 05		bcs $34bb			bcs 	_CIGoto2
.34b6	80 09		bra $34c1			bra 	CompileGotoEOL
.34b8					_CIGoto:
.34b8	20 b1 33	jsr $33b1			jsr 	GetNext
.34bb					_CIGoto2:
.34bb	a9 d4		lda #$d4			lda 	#PCD_CMD_GOTOCMD_NZ
.34bd	20 8c 34	jsr $348c			jsr 	CompileBranchCommand
.34c0	60		rts				rts
.34c1					CompileGotoEOL:
.34c1	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_Z
.34c3	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.34c6	20 39 2a	jsr $2a39			jsr 	GetLineNumber 				; Get the current line number => YA
.34c9	1a		inc a				inc 	a 							; and branch to +1
.34ca	d0 01		bne $34cd			bne 	_CGENoCarry
.34cc	c8		iny				iny
.34cd					_CGENoCarry:
.34cd	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.34d0	98		tya				tya
.34d1	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.34d4	60		rts				rts
.34d5					CommandINPUT:
.34d5	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; check for "
.34d8	c9 22		cmp #$22			cmp 	#'"'
.34da	d0 0d		bne $34e9			bne 	CommandINPUTStream
.34dc	20 56 2d	jsr $2d56			jsr 	CompileExpressionAt0
.34df	a9 b2		lda #$b2			lda 	#(PCD_PRINTCMD_S) & $FF
.34e1	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.34e4	a9 2c		lda #$2c			lda 	#","
.34e6	20 9e 2a	jsr $2a9e			jsr 	CheckNextComma
.34e9					CommandINPUTStream:
.34e9	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.34eb	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.34ee	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.34f0	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.34f2	4c 77 36	jmp $3677			jmp 	CommandReadInputCommon
.34f5					CommandLET:
.34f5	20 bc 33	jsr $33bc			jsr 	GetNextNonSpace 			; get the first character
.34f8					CommandLETHaveFirst:
.34f8	20 fd 36	jsr $36fd			jsr 	GetReferenceTerm 			; identify variable to assign to
.34fb	da		phx				phx 								; save target on the stack.
.34fc	5a		phy				phy
.34fd	48		pha				pha
.34fe	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.3500	20 a8 2a	jsr $2aa8			jsr 	CheckNextA
.3503	20 56 2d	jsr $2d56			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.3506	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.3508	68		pla				pla 								; get type of assignment
.3509	48		pha				pha
.350a	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.350c	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.350e	d0 17		bne $3527			bne 	_CLType
.3510	68		pla				pla 								; restore and compile save code
.3511	7a		ply				ply
.3512	fa		plx				plx
.3513	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.3515	f0 05		beq $351c			beq 	_CLTIString
.3517	38		sec				sec
.3518	20 af 36	jsr $36af			jsr		GetSetVariable
.351b	60		rts				rts
.351c					_CLTIString:
.351c	a9 cb		lda #$cb			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.351e	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.3521	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.3523	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.3526	60		rts				rts
.3527					_CLType:
.3527	4c 2a 1f	jmp $1f2a		jmp	ErrorV_type
.352a					STRMarkLine:
.352a	48		pha				pha
.352b	38		sec				sec 								; allocate 4 bytes (line #,address)
.352c	ad c9 06	lda $06c9			lda 	lineNumberTable 			; and copy to zTemp0
.352f	e9 04		sbc #$04			sbc 	#4
.3531	8d c9 06	sta $06c9			sta 	lineNumberTable
.3534	85 2c		sta $2c				sta 	zTemp0
.3536	ad ca 06	lda $06ca			lda 	lineNumberTable+1
.3539	e9 00		sbc #$00			sbc 	#0
.353b	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.353e	85 2d		sta $2d				sta 	zTemp0+1
.3540	68		pla				pla
.3541	92 2c		sta ($2c)			sta 	(zTemp0) 					; line # save it in +0,+1
.3543	98		tya				tya
.3544	a0 01		ldy #$01			ldy 	#1
.3546	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3548	a5 2a		lda $2a				lda 	objPtr 						; save current address in +2,+3
.354a	c8		iny				iny
.354b	91 2c		sta ($2c),y			sta 	(zTemp0),y
.354d	a5 2b		lda $2b				lda 	objPtr+1
.354f	c8		iny				iny
.3550	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3552	60		rts				rts
.3553					STRFindLine:
.3553	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.3555	84 2d		sty $2d				sty 	zTemp0+1
.3557	ad c2 06	lda $06c2			lda 	compilerEndHigh 			; work backwards through table
.355a	85 2f		sta $2f				sta 	zTemp1+1
.355c	64 2e		stz $2e				stz 	zTemp1
.355e					_STRSearch:
.355e	20 95 35	jsr $3595			jsr 	_STRPrevLine 				; look at previous record.
.3561	a0 01		ldy #$01			ldy 	#1
.3563	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.3565	c5 2c		cmp $2c				cmp 	zTemp0
.3567	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3569	e5 2d		sbc $2d				sbc 	zTemp0+1
.356b	b0 0b		bcs $3578			bcs 	_STRFound 					; >=
.356d					_STRNext:
.356d	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.356f	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3571	c9 ff		cmp #$ff			cmp 	#$FF
.3573	d0 e9		bne $355e			bne 	_STRSearch
.3575	4c 74 1f	jmp $1f74		jmp	ErrorV_internal
.3578					_STRFound:
.3578	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.357a	45 2c		eor $2c				eor 	zTemp0
.357c	d0 06		bne $3584			bne 	_STRDifferent
.357e	b2 2e		lda ($2e)			lda 	(zTemp1)
.3580	45 2c		eor $2c				eor 	zTemp0
.3582	f0 02		beq $3586			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.3584					_STRDifferent:
.3584	a9 ff		lda #$ff			lda 	#$FF
.3586					_STROut:
.3586	18		clc				clc  								; set carry if different, e.g. > rather than >=
.3587	69 ff		adc #$ff			adc 	#255
.3589	08		php				php
.358a	c8		iny				iny 								; address into YA
.358b	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.358d	48		pha				pha
.358e	c8		iny				iny
.358f	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3591	a8		tay				tay
.3592	68		pla				pla
.3593	28		plp				plp
.3594	60		rts				rts
.3595					_STRPrevLine:
.3595	38		sec				sec 								; move backwards one entry.
.3596	a5 2e		lda $2e				lda 	zTemp1
.3598	e9 04		sbc #$04			sbc 	#4
.359a	85 2e		sta $2e				sta 	zTemp1
.359c	a5 2f		lda $2f				lda 	zTemp1+1
.359e	e9 00		sbc #$00			sbc 	#0
.35a0	85 2f		sta $2f				sta 	zTemp1+1
.35a2	60		rts				rts
.35a3					STRMakeOffset:
.35a3	18		clc				clc 								; borrow 1
.35a4	e5 2a		sbc $2a				sbc 	objPtr
.35a6	48		pha				pha
.35a7	98		tya				tya
.35a8	e5 2b		sbc $2b				sbc 	objPtr+1
.35aa	a8		tay				tay
.35ab	68		pla				pla
.35ac	60		rts				rts
.35ad					CommandNEXT:
.35ad	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.35b0	20 d2 33	jsr $33d2			jsr 	CharIsAlpha 				; if not alpha , error
.35b3	90 0c		bcc $35c1			bcc 	_CNNoReferenceGiven
.35b5	20 b1 33	jsr $33b1			jsr 	GetNext
.35b8	20 fd 36	jsr $36fd			jsr 	GetReferenceTerm 			; figure out the reference.
.35bb	8a		txa				txa 								; reference in YA
.35bc	20 56 2b	jsr $2b56			jsr 	PushIntegerYA 				; write it out.
.35bf	80 06		bra $35c7			bra 	_CNParametersDone
.35c1					_CNNoReferenceGiven:
.35c1	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.35c3	a8		tay				tay
.35c4	20 56 2b	jsr $2b56			jsr 	PushIntegerYA 				; write it out.
.35c7					_CNParametersDone:
.35c7	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.35c9	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.35cc	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; look for ,
.35cf	c9 2c		cmp #$2c			cmp 	#","
.35d1	d0 05		bne $35d8			bne 	_CNExit
.35d3	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume ,
.35d6	80 d5		bra $35ad			bra 	CommandNEXT 				; and go round.
.35d8					_CNExit:
.35d8	60		rts				rts
.35d9					CommandON:
.35d9	20 bc 33	jsr $33bc			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.35dc	48		pha				pha 								; save on stack
.35dd	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOTO
.35df	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.35e1	f0 09		beq $35ec			beq 	_COCreateLoop
.35e3	a2 d2		ldx #$d2			ldx 	#PCD_CMD_GOSUB
.35e5	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.35e7	f0 03		beq $35ec			beq 	_COCreateLoop
.35e9	4c 1a 1f	jmp $1f1a		jmp	ErrorV_syntax
.35ec					_COCreateLoop:
.35ec	8a		txa				txa 								; compile a goto/gosub somewhere
.35ed	da		phx				phx
.35ee	20 8c 34	jsr $348c			jsr 	CompileBranchCommand
.35f1	fa		plx				plx
.35f2	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace			; ',' follows
.35f5	c9 2c		cmp #$2c			cmp 	#","
.35f7	d0 0a		bne $3603			bne 	_COComplete 				; if so, more line numbers
.35f9	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.35fb	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.35fe	20 b1 33	jsr $33b1			jsr 	GetNext
.3601	80 e9		bra $35ec			bra 	_COCreateLoop
.3603					_COComplete:
.3603	68		pla				pla 								; throw GOTO/GOSUB
.3604	60		rts				rts
.3605					ParseConstant:
.3605	a2 00		ldx #$00			ldx 	#0
.3607	20 51 24	jsr $2451			jsr 	FloatEncodeStart 			; send first
.360a					_ParseLoop:
.360a	20 a0 33	jsr $33a0			jsr 	LookNext 					; send subsequent
.360d	20 54 24	jsr $2454			jsr 	FloatEncodeContinue
.3610	90 05		bcc $3617			bcc 	_ParseDone
.3612	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume it
.3615	80 f3		bra $360a			bra 	_ParseLoop
.3617					_ParseDone:
.3617	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.3619	29 80		and #$80			and 	#$80
.361b	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.361d	15 56		ora $56,x			ora 	NSMantissa2,x
.361f	15 62		ora $62,x			ora 	NSMantissa3,x
.3621	18		clc				clc
.3622	d0 05		bne $3629			bne 	_ParseExit 					; exit with CC if need float to compile
.3624	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.3626	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.3628	38		sec				sec
.3629					_ParseExit:
.3629	60		rts				rts
.362a					CommandPRINT:
.362a	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace			; what follows ?
.362d	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.362f	f0 1f		beq $3650			beq 	_CPCheckEnd
.3631	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.3633	f0 16		beq $364b			beq 	_CPTabCheckEnd
.3635	20 67 36	jsr $3667			jsr 	_CPAtEnd 					; check for : and EOL
.3638	b0 22		bcs $365c			bcs 	_CPExitCR 					; exit with CR
.363a	20 56 2d	jsr $2d56			jsr 	CompileExpressionAt0 		; so it is something to print
.363d	a2 b2		ldx #$b2			ldx 	#PCD_PRINTCMD_S
.363f	29 40		and #$40			and 	#NSSString 					; if string
.3641	d0 02		bne $3645			bne 	_CPOut
.3643	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_N
.3645					_CPOut:
.3645	8a		txa				txa 								; print that thing
.3646	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.3649	80 df		bra $362a			bra 	CommandPRINT 				; and loop round/
.364b					_CPTabCheckEnd:
.364b	a9 b8		lda #$b8			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.364d	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.3650					_CPCheckEnd:
.3650	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume it.
.3653	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; what follows ?
.3656	20 67 36	jsr $3667			jsr 	_CPAtEnd 					; reached end
.3659	90 cf		bcc $362a			bcc 	CommandPRINT 				; no, loop back
.365b	60		rts				rts
.365c					_CPExitCR:
.365c	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.365e	20 69 2b	jsr $2b69			jsr 	PushIntegerA
.3661	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.3663	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.3666	60		rts				rts
.3667					_CPAtEnd:
.3667	c9 00		cmp #$00			cmp 	#0
.3669	f0 06		beq $3671			beq 	_CPIsEnd
.366b	c9 3a		cmp #$3a			cmp 	#":"
.366d	f0 02		beq $3671			beq 	_CPIsEnd
.366f	18		clc				clc
.3670	60		rts				rts
.3671					_CPIsEnd:
.3671	38		sec				sec
.3672	60		rts				rts
.3673					CommandREAD:
.3673	a2 b3		ldx #$b3			ldx 	#PCD_READ
.3675	a0 b4		ldy #$b4			ldy 	#PCD_READDOLLAR
.3677					CommandReadInputCommon:
.3677	8e c7 06	stx $06c7			stx 	numberPCode
.367a	8c c8 06	sty $06c8			sty 	stringPCode
.367d					_CRLoop:
.367d	20 bc 33	jsr $33bc			jsr 	GetNextNonSpace 			; first char of identifier
.3680	20 d2 33	jsr $33d2			jsr 	CharIsAlpha 				; check A-Z
.3683	90 27		bcc $36ac			bcc 	_CRSyntax
.3685	20 fd 36	jsr $36fd			jsr 	GetReferenceTerm 			; get the variable.
.3688	48		pha				pha 								; save type.
.3689	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.368b	c9 40		cmp #$40			cmp 	#NSSString
.368d	f0 05		beq $3694			beq 	_CRString
.368f	ad c7 06	lda $06c7			lda 	numberPCode 				; output read/input
.3692	80 03		bra $3697			bra 	_CRHaveType
.3694					_CRString:
.3694	ad c8 06	lda $06c8			lda 	stringPCode					; output read$/input$
.3697					_CRHaveType:
.3697	20 40 2a	jsr $2a40			jsr 	WriteCodeByte 				; so we have one typed data item.
.369a	68		pla				pla 								; restore type
.369b	38		sec				sec  								; write update code.
.369c	20 af 36	jsr $36af			jsr 	GetSetVariable
.369f	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; , follows ?
.36a2	c9 2c		cmp #$2c			cmp 	#","
.36a4	d0 05		bne $36ab			bne 	_CRExit 					; if not, end of READ.
.36a6	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume comma
.36a9	80 d2		bra $367d			bra 	_CRLoop 					; keep going
.36ab					_CRExit:
.36ab	60		rts				rts
.36ac					_CRSyntax:
.36ac	4c 1a 1f	jmp $1f1a		jmp	ErrorV_syntax
.06c7					numberPCode:
>06c7							.fill 	1
.06c8					stringPCode:
>06c8							.fill 	1
.36af					GetSetVariable:
.36af	08		php				php 								; save direction on stack
.36b0	c0 00		cpy #$00			cpy 	#$00
.36b2	30 21		bmi $36d5			bmi 	_GSVReadWriteSpecial
.36b4	c9 00		cmp #$00			cmp 	#$00
.36b6	30 33		bmi $36eb			bmi 	_GSVArray
.36b8	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.36ba	4a		lsr a				lsr 	a 							; divide by 2
.36bb	09 40		ora #$40			ora 	#64 						; and set bit 6.
.36bd	28		plp				plp
.36be	90 02		bcc $36c2			bcc 	_GSVNotWrite
.36c0	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.36c2					_GSVNotWrite:
.36c2	85 2c		sta $2c				sta 	zTemp0
.36c4	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.36c5	4a		lsr a				lsr 	a
.36c6	a8		tay				tay
.36c7	8a		txa				txa
.36c8	6a		ror a				ror 	a
.36c9	aa		tax				tax
.36ca	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.36cb	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.36cd	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.36d0	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.36d1	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.36d4	60		rts				rts
.36d5					_GSVReadWriteSpecial:
.36d5	28		plp				plp
.36d6	b0 10		bcs $36e8			bcs 	_GSVSyntax
.36d8	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.36da	f0 06		beq $36e2			beq 	_GSVRWString
.36dc	a9 c0		lda #$c0			lda 	#(PCD_TI) & $FF
.36de	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.36e1	60		rts				rts
.36e2					_GSVRWString:
.36e2	a9 c1		lda #$c1			lda 	#(PCD_TIDOLLAR) & $FF
.36e4	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.36e7	60		rts				rts
.36e8					_GSVSyntax:
.36e8	4c 1a 1f	jmp $1f1a		jmp	ErrorV_syntax
.36eb					_GSVArray:
.36eb	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.36ed	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.36ee	4a		lsr a				lsr 	a
.36ef	4a		lsr a				lsr 	a
.36f0	4a		lsr a				lsr 	a
.36f1	4a		lsr a				lsr 	a
.36f2	28		plp				plp 								; if writing array then set bit 2.
.36f3	90 02		bcc $36f7			bcc 	_GSVANotWrite
.36f5	09 04		ora #$04			ora 	#4
.36f7					_GSVANotWrite:
.36f7	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.36f9	20 40 2a	jsr $2a40			jsr 	WriteCodeByte 				; and write it out
.36fc	60		rts				rts
.36fd					GetReferenceTerm:
.36fd	20 21 34	jsr $3421			jsr 	ExtractVariableName 		; get name & type info
.3700	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.3702	30 10		bmi $3714			bmi 	_GRTArray
.3704	da		phx				phx 								; save type on stack
.3705	20 10 2e	jsr $2e10			jsr 	FindVariable 				; find it
.3708	b0 06		bcs $3710			bcs 	_GRTNoCreate 				; create if required.
.370a	20 9b 2b	jsr $2b9b			jsr 	CreateVariableRecord 		; create a variable.
.370d	20 f0 2b	jsr $2bf0			jsr 	AllocateBytesForType 		; allocate memory for it
.3710					_GRTNoCreate:
.3710	68		pla				pla 								; get type back, strip out type information.
.3711	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.3713	60		rts				rts
.3714					_GRTArray:
.3714	da		phx				phx 								; save type information
.3715	20 10 2e	jsr $2e10			jsr 	FindVariable 				; read its data, the base address in YX
.3718	90 18		bcc $3732			bcc 	_GRTUndeclared 				; undeclared array.
.371a	da		phx				phx 								; save base address
.371b	5a		phy				phy
.371c	20 e7 2c	jsr $2ce7			jsr 	OutputIndexGroup 			; create an index group and generate them
.371f	7a		ply				ply 								; get the array base address into YX
.3720	fa		plx				plx
.3721	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.3723	18		clc				clc
.3724	20 af 36	jsr $36af			jsr 	GetSetVariable 				; load the address of the array structure.
.3727	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.3729	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.372c	68		pla				pla 								; and the type data into A
.372d	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.372f	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.3731	60		rts				rts
.3732					_GRTUndeclared:
.3732	4c d1 1f	jmp $1fd1		jmp	ErrorV_undeclared
.3735					CommandREM:
.3735	20 a0 33	jsr $33a0			jsr 	LookNext
.3738	f0 05		beq $373f			beq 	_CRExit
.373a	20 b1 33	jsr $33b1			jsr 	GetNext
.373d	80 f6		bra $3735			bra 	CommandREM
.373f					_CRExit:
.373f	60		rts				rts
.3740					STRReset:
.3740	ad c1 06	lda $06c1			lda	 	compilerStartHigh 			; set up the two table pointers
.3743	8d cc 06	sta $06cc			sta 	variableListEnd+1
.3746	9c cb 06	stz $06cb			stz 	variableListEnd
.3749	ad c2 06	lda $06c2			lda 	compilerEndHigh
.374c	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.374f	9c c9 06	stz $06c9			stz 	lineNumberTable
.3752	ad cb 06	lda $06cb			lda 	variableListEnd
.3755	85 2d		sta $2d				sta 	zTemp0+1
.3757	64 2c		stz $2c				stz 	zTemp0
.3759	a9 00		lda #$00			lda 	#0
.375b	92 2c		sta ($2c)			sta 	(zTemp0)
.375d	a9 00		lda #$00			lda 	#((0) & $FF)
.375f	8d cd 06	sta $06cd			sta 	0+freeVariableMemory
.3762	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.3764	8d ce 06	sta $06ce			sta 	1+freeVariableMemory
.3767	60		rts				rts
.06c9					lineNumberTable:
>06c9							.fill 	2
.06cb					variableListEnd:
>06cb							.fill 	2
.06cd					freeVariableMemory:
>06cd							.fill 	2
.3768					CompileTerm:
.3768	20 bc 33	jsr $33bc			jsr 	GetNextNonSpace 			; get first non space character.
.376b	30 72		bmi $37df			bmi 	_CTUnaryFunctions
.376d	20 c6 33	jsr $33c6			jsr 	CharIsDigit 				; found a number
.3770	b0 3a		bcs $37ac			bcs 	_CTDigit
.3772	c9 2e		cmp #$2e			cmp 	#"."
.3774	f0 36		beq $37ac			beq 	_CTDigit
.3776	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.3778	f0 43		beq $37bd			beq 	_CTString
.377a	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.377c	f0 28		beq $37a6			beq 	_CTOtherBase
.377e	c9 24		cmp #$24			cmp 	#"$"
.3780	f0 24		beq $37a6			beq 	_CTOtherBase
.3782	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.3784	f0 17		beq $379d			beq 	_CTBrackets
.3786	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.3788	90 10		bcc $379a			bcc 	_CTSyntax
.378a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.378c	b0 0c		bcs $379a			bcs 	_CTSyntax
.378e	20 fd 36	jsr $36fd			jsr 	GetReferenceTerm 			; figure out what it is.
.3791	48		pha				pha 								; save type on stack
.3792	18		clc				clc 								; read it
.3793	20 af 36	jsr $36af			jsr 	GetSetVariable
.3796	68		pla				pla
.3797	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.3799	60		rts				rts
.379a					_CTSyntax:
.379a	4c 1a 1f	jmp $1f1a		jmp	ErrorV_syntax
.379d					_CTBrackets:
.379d	20 56 2d	jsr $2d56			jsr 	CompileExpressionAt0
.37a0	48		pha				pha
.37a1	20 a2 2a	jsr $2aa2			jsr 	CheckNextRParen
.37a4	68		pla				pla
.37a5	60		rts				rts
.37a6					_CTOtherBase:
.37a6	20 ee 29	jsr $29ee			jsr 	InlineNonDecimal 			; non decimal constant handler
.37a9	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.37ab	60		rts				rts
.37ac					_CTDigit:
.37ac	20 05 36	jsr $3605			jsr 	ParseConstant 				; parse out an number, first is in A already.
.37af	90 06		bcc $37b7			bcc	 	_CTFloat 					; have a float or long int.
.37b1	20 56 2b	jsr $2b56			jsr 	PushIntegerYA 				; code to push on stack
.37b4	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.37b6	60		rts				rts
.37b7					_CTFloat:
.37b7	20 78 2b	jsr $2b78			jsr 	PushFloatCommand			; code to push float
.37ba	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.37bc	60		rts				rts
.37bd					_CTString:
.37bd	20 77 2a	jsr $2a77			jsr 	BufferClear 				; copy it to the buffer
.37c0					_CTStringLoop:
.37c0	20 a0 33	jsr $33a0			jsr 	LookNext 					; reached EOL/EOS
.37c3	f0 d5		beq $379a			beq 	_CTSyntax
.37c5	c9 22		cmp #$22			cmp 	#'"'
.37c7	f0 08		beq $37d1			beq 	_CTStringDone
.37c9	20 7b 2a	jsr $2a7b			jsr 	BufferWrite 				; write and consume
.37cc	20 b1 33	jsr $33b1			jsr 	GetNext
.37cf	80 ef		bra $37c0			bra 	_CTStringLoop
.37d1					_CTStringDone:
.37d1	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume closing quote.
.37d4	a9 cf		lda #$cf			lda 	#PCD_CMD_STRING 			; output command and buffer
.37d6	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.37d9	20 87 2a	jsr $2a87			jsr 	BufferOutput
.37dc	a9 40		lda #$40			lda 	#NSSString 					; string type
.37de	60		rts				rts
.37df					_CTUnaryFunctions:
.37df	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.37e1	f0 0a		beq $37ed			beq 	_CTNegation
.37e3	a2 42		ldx #$42			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.37e5	a0 31		ldy #$31			ldy 	#UnaryTables >> 8
.37e7	20 42 32	jsr $3242			jsr 	GeneratorProcess
.37ea	90 ae		bcc $379a			bcc		_CTSyntax
.37ec	60		rts				rts
.37ed					_CTNegation:
.37ed	20 68 37	jsr $3768			jsr 	CompileTerm 				; compile a term.
.37f0	48		pha				pha
.37f1	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.37f3	c9 00		cmp #$00			cmp 	#NSSIFloat
.37f5	d0 07		bne $37fe			bne 	_CTType 					; error
.37f7	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.37f9	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.37fc	68		pla				pla 								; return original type.
.37fd	60		rts				rts
.37fe					_CTType:
.37fe	4c 2a 1f	jmp $1f2a		jmp	ErrorV_type
.3801					CommandWAIT:
.3801	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace
.3804	c9 2c		cmp #$2c			cmp 	#","
.3806	f0 10		beq $3818			beq 	_CWThirdParameter
.3808	a9 00		lda #$00			lda 	#0
.380a	20 69 2b	jsr $2b69			jsr 	PushIntegerA
.380d					_CWExit:
.380d	a9 cb		lda #$cb			lda 	#(PCD_WAIT) >> 8
.380f	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.3812	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.3814	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.3817	60		rts				rts
.3818					_CWThirdParameter:
.3818	20 b1 33	jsr $33b1			jsr 	GetNext
.381b	20 58 2d	jsr $2d58			jsr 	CompileExpressionAtA
.381e	29 40		and #$40			and 	#NSSTypeMask
.3820	c9 00		cmp #$00			cmp 	#NSSIFloat
.3822	f0 e9		beq $380d			beq 	_CWExit
.3824	4c 2a 1f	jmp $1f2a		jmp	ErrorV_type
.3827					CommandCMD:
.3827	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.3829	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.382c	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; followed by a , ?
.382f	c9 2c		cmp #$2c			cmp 	#","
.3831	d0 06		bne $3839			bne 	_CCMDExit
.3833	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume comma.
.3836	20 2a 36	jsr $362a			jsr 	CommandPRINT 				; do the print code
.3839					_CCMDExit:
.3839	60		rts				rts
.383a					CommandOPEN:
.383a	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; followed by a , ?
.383d	c9 2c		cmp #$2c			cmp 	#","
.383f	d0 15		bne $3856			bne 	_COTwoDefaults
.3841	20 b1 33	jsr $33b1			jsr 	GetNext 					; consume comma
.3844	20 56 2d	jsr $2d56			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.3847	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.3849	f0 1e		beq $3869			beq 	_COThreeIntegers
.384b	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.384d	20 69 2b	jsr $2b69			jsr 	PushIntegerA
.3850	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.3852	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.3855	60		rts				rts
.3856					_COTwoDefaults:
.3856	a9 00		lda #$00			lda 	#0
.3858	20 69 2b	jsr $2b69			jsr 	PushIntegerA
.385b					_COCompileNullString:
.385b	a9 cf		lda #$cf			lda 	#(PCD_CMD_STRING) & $FF
.385d	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.3860	a9 00		lda #$00			lda 	#0
.3862	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.3865	20 40 2a	jsr $2a40			jsr 	WriteCodeByte
.3868	60		rts				rts
.3869					_COThreeIntegers:
.3869	20 a3 33	jsr $33a3			jsr 	LookNextNonSpace 			; is there a ,
.386c	c9 2c		cmp #$2c			cmp 	#","
.386e	d0 eb		bne $385b			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.3870	20 b1 33	jsr $33b1			jsr 	GetNext
.3873	20 56 2d	jsr $2d56			jsr 	CompileExpressionAt0 		; should be a filename
.3876	29 40		and #$40			and 	#NSSString
.3878	f0 01		beq $387b			beq 	_COType
.387a	60		rts				rts
.387b					_COType:
.387b	4c 2a 1f	jmp $1f2a		jmp	ErrorV_type

;******  Processing input file: _library.asm

.387e					CompilerAPI:
.387e	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.3880	f0 19		beq $389b			beq 	_CAOpenIn
.3882	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.3884	f0 23		beq $38a9			beq 	_CACloseIn
.3886	c9 02		cmp #$02			cmp 	#BLC_READIN
.3888	f0 3a		beq $38c4			beq 	_CARead
.388a	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.388c	f0 1e		beq $38ac			beq 	_CAResetOut
.388e	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.3890	f0 23		beq $38b5			beq 	_CACloseOut
.3892	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.3894	f0 20		beq $38b6			beq 	_CAWriteByte
.3896	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.3898	f0 26		beq $38c0			beq 	_CAPrintScreen
>389a	db						.byte 	$DB 						; causes a break in the emulator
.389b					_CAOpenIn:
.389b	a0 39		ldy #$39			ldy 	#SourceFile >> 8 			; name of file
.389d	a2 bb		ldx #$bb			ldx 	#SourceFile & $FF
.389f	20 2c 39	jsr $392c			jsr 	IOOpenRead 					; open file
.38a2	20 37 39	jsr $3937			jsr 	IOReadByte 					; skip the 2 byte load address header
.38a5	20 37 39	jsr $3937			jsr 	IOReadByte
.38a8	60		rts				rts
.38a9					_CACloseIn:
.38a9	4c 46 39	jmp $3946			jmp 	IOReadClose
.38ac					_CAResetOut:
.38ac	a9 00		lda #$00			lda 	#((FreeMemory) & $FF)
.38ae	85 2a		sta $2a				sta 	0+objPtr
.38b0	a9 3b		lda #$3b			lda 	#((FreeMemory) >> 8) & $FF
.38b2	85 2b		sta $2b				sta 	1+objPtr
.38b4	60		rts				rts
.38b5					_CACloseOut:
.38b5	60		rts				rts
.38b6					_CAWriteByte:
.38b6	8a		txa				txa
.38b7	92 2a		sta ($2a)			sta 	(objPtr)
.38b9	e6 2a		inc $2a				inc 	objPtr
.38bb	d0 02		bne $38bf			bne 	_HWOWBNoCarry
.38bd	e6 2b		inc $2b				inc 	objPtr+1
.38bf					_HWOWBNoCarry:
.38bf	60		rts				rts
.38c0					_CAPrintScreen:
.38c0	8a		txa				txa
.38c1	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.38c4					_CARead:
.38c4	20 37 39	jsr $3937			jsr 	IOReadByte 				; copy the address of next into the buffer
.38c7	8d cf 06	sta $06cf			sta 	SourceLine+0
.38ca	20 37 39	jsr $3937			jsr 	IOReadByte
.38cd	8d d0 06	sta $06d0			sta 	SourceLine+1
.38d0	0d cf 06	ora $06cf			ora 	sourceLine				; if both were zero, exit with CC (e.g. fail)
.38d3	18		clc				clc
.38d4	f0 1e		beq $38f4			beq		_CARExit
.38d6	20 37 39	jsr $3937			jsr 	IOReadByte 				; read the line # into the buffer.
.38d9	8d d1 06	sta $06d1			sta 	SourceLine+2
.38dc	20 37 39	jsr $3937			jsr 	IOReadByte
.38df	8d d2 06	sta $06d2			sta 	SourceLine+3
.38e2	a2 04		ldx #$04			ldx 	#4 						; read the body of the line.
.38e4					_CAReadLine:
.38e4	20 37 39	jsr $3937			jsr 	IOReadByte 				; now keep copying to EOL
.38e7	9d cf 06	sta $06cf,x			sta 	SourceLine,x
.38ea	e8		inx				inx
.38eb	c9 00		cmp #$00			cmp 	#0
.38ed	d0 f5		bne $38e4			bne 	_CAReadLine
.38ef	38		sec				sec 							; read a line okay
.38f0	a0 06		ldy #$06			ldy 	#SourceLine >> 8
.38f2	a2 cf		ldx #$cf			ldx 	#SourceLine & $FF
.38f4					_CARExit:
.38f4	60		rts				rts
.06cf					SourceLine:
>06cf							.fill 	256
.38f5					WriteObjectCode:
.38f5	20 1a 08	jsr $081a			jsr 	PatchOutCompile 			; makes it run the runtime on reload
.38f8	a0 39		ldy #$39			ldy 	#ObjectFile >> 8
.38fa	a2 b0		ldx #$b0			ldx 	#ObjectFile & $FF
.38fc	20 1f 3a	jsr $3a1f			jsr 	IOOpenWrite 				; open write
.38ff	a9 01		lda #$01			lda 	#1 							; write out the load address $0801
.3901	20 2a 3a	jsr $3a2a			jsr 	IOWriteByte
.3904	a9 08		lda #$08			lda 	#8
.3906	20 2a 3a	jsr $3a2a			jsr 	IOWriteByte
.3909	a9 01		lda #$01			lda 	#((StartBasicProgram) & $FF)
.390b	85 2c		sta $2c				sta 	0+zTemp0
.390d	a9 08		lda #$08			lda 	#((StartBasicProgram) >> 8) & $FF
.390f	85 2d		sta $2d				sta 	1+zTemp0
.3911					_WOCLoop:
.3911	b2 2c		lda ($2c)			lda 	(zTemp0) 					; write code
.3913	20 2a 3a	jsr $3a2a			jsr 	IOWriteByte
.3916	e6 2c		inc $2c				inc 	zTemp0 						; advance pointer
.3918	d0 02		bne $391c			bne 	_WOCSkip
.391a	e6 2d		inc $2d				inc 	zTemp0+1
.391c					_WOCSkip:
.391c	a5 2c		lda $2c				lda 	zTemp0 						; check end
.391e	c5 2a		cmp $2a				cmp 	objPtr
.3920	d0 ef		bne $3911			bne 	_WOCLoop
.3922	a5 2d		lda $2d				lda 	zTemp0+1
.3924	c5 2b		cmp $2b				cmp 	objPtr+1
.3926	d0 e9		bne $3911			bne 	_WOCLoop
.3928	20 46 39	jsr $3946			jsr 	IOWriteClose 				; close the file.
.392b	60		rts				rts
.392c					IOOpenRead:
.392c	a9 52		lda #$52			lda 	#'R' 						; read.
.392e	20 4f 39	jsr $394f			jsr 	IOSetFileName 				; set up name/LFS
.3931	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for reading
.3933	20 c6 ff	jsr $ffc6			jsr 	$FFC6 						; CHKIN
.3936	60		rts				rts
.3937					IOReadByte:
.3937	da		phx				phx
.3938	5a		phy				phy
.3939	20 b7 ff	jsr $ffb7			jsr 	$FFB7 						; read ST
.393c	38		sec				sec
.393d	d0 04		bne $3943			bne 	_IORExit
.393f	20 cf ff	jsr $ffcf			jsr 	$FFCF 						; read a byte
.3942	18		clc				clc 								; status OK.
.3943					_IORExit:
.3943	7a		ply				ply
.3944	fa		plx				plx
.3945	60		rts				rts
.3946					IOReadClose:
.3946					IOWriteClose:
.3946	a9 03		lda #$03			lda 	#3 							; CLOSE# 3
.3948	20 c3 ff	jsr $ffc3			jsr 	$FFC3
.394b	20 cc ff	jsr $ffcc			jsr 	$FFCC 						; CLRCHN
.394e	60		rts				rts
.394f					IOSetFileName:
.394f	48		pha				pha 								; save R/W
.3950	86 2c		stx $2c				stx 	zTemp0
.3952	84 2d		sty $2d				sty 	zTemp0+1
.3954	a0 ff		ldy #$ff			ldy 	#$FF 						; copy name given
.3956					_IOSCopy:
.3956	c8		iny				iny 								; pre-increment copy
.3957	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.3959	99 cf 07	sta $07cf,y			sta 	IONameBuffer,y
.395c	d0 f8		bne $3956			bne 	_IOSCopy
.395e	99 d3 07	sta $07d3,y			sta 	IONameBuffer+4,y
.3961	a9 2c		lda #$2c			lda 	#',' 						; append ,S,[R|W]
.3963	99 cf 07	sta $07cf,y			sta 	IONameBuffer+0,y
.3966	99 d1 07	sta $07d1,y			sta 	IONameBuffer+2,y
.3969	a9 53		lda #$53			lda 	#'S'
.396b	99 d0 07	sta $07d0,y			sta 	IONameBuffer+1,y
.396e	68		pla				pla 								; write R/W out
.396f	99 d2 07	sta $07d2,y			sta 	IONameBuffer+3,y
.3972	98		tya				tya 								; length of name to A
.3973	18		clc				clc
.3974	69 04		adc #$04			adc 	#4 							; we added 4 characters.
.3976	a2 cf		ldx #$cf			ldx 	#IONameBuffer & $FF			; name address to YX
.3978	a0 07		ldy #$07			ldy 	#IONameBuffer >> 8
.397a	20 bd ff	jsr $ffbd		    jsr 	$FFBD          				; call SETNAM
.397d	a9 03		lda #$03	    	lda 	#3 							; set LFS to 3,8,3
.397f	a2 08		ldx #$08			ldx 	#8
.3981	a0 03		ldy #$03			ldy 	#3
.3983	20 ba ff	jsr $ffba			jsr 	$FFBA
.3986	20 c0 ff	jsr $ffc0			jsr 	$FFC0 						; OPEN
.3989	60		rts				rts
.07cf					IONameBuffer:
>07cf							.fill 	64
.398a					CompileCode:
.398a	a2 00		ldx #$00			ldx 	#0
.398c	bd c6 39	lda $39c6,x	_Prompt:lda 	Prompt,x
.398f	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3992	e8		inx				inx
.3993	c9 00		cmp #$00			cmp 	#0
.3995	d0 f5		bne $398c			bne 	_Prompt
.3997	a2 ac		ldx #$ac			ldx 	#APIDesc & $FF
.3999	a0 39		ldy #$39			ldy 	#APIDesc >> 8
.399b	20 b7 2a	jsr $2ab7			jsr 	StartCompiler
.399e	20 f5 38	jsr $38f5			jsr 	WriteObjectCode
.39a1	a9 4f		lda #$4f			lda 	#"O"
.39a3	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.39a6	a9 4b		lda #$4b			lda 	#"K"
.39a8	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.39ab	60		rts				rts
.39ac					APIDesc:
>39ac	7e 38						.word 	CompilerAPI 				; the compiler API Implementeation
>39ae	80						.byte 	$80 						; start of workspace for compiler $8000
>39af	9f						.byte 	$9F							; end of workspace for compiler $9F00
.39b0					ObjectFile:
>39b0	4f 42 4a 45 43 54 2e 50				.text 	'OBJECT.PRG',0
>39b8	52 47 00
.39bb					SourceFile:
>39bb	53 4f 55 52 43 45 2e 50				.text 	'SOURCE.PRG',0
>39c3	52 47 00
.39c6					Prompt:
>39c6	2a 2a 2a 20 42 4c 49 54				.text 	'*** BLITZ (ALPHA 09-10-23) ***',13,13
>39ce	5a 20 28 41 4c 50 48 41 20 30 39 2d 31 30 2d 32
>39de	33 29 20 2a 2a 2a 0d 0d
>39e6	42 55 47 53 3a 48 54 54				.text 	'BUGS:HTTPS://GITHUB.COM/PAULSCOTTROBSON/BLITZ-COMPILER',13,13,0
>39ee	50 53 3a 2f 2f 47 49 54 48 55 42 2e 43 4f 4d 2f
>39fe	50 41 55 4c 53 43 4f 54 54 52 4f 42 53 4f 4e 2f
>3a0e	42 4c 49 54 5a 2d 43 4f 4d 50 49 4c 45 52 0d 0d
>3a1e	00
.3a1f					IOOpenWrite:
.3a1f	a9 57		lda #$57			lda 	#'W'			 			; write
.3a21	20 4f 39	jsr $394f			jsr 	IOSetFileName 				; set up name/LFS
.3a24	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for writing
.3a26	20 c9 ff	jsr $ffc9			jsr 	$FFC9 						; CHKOUT
.3a29	60		rts				rts
.3a2a					IOWriteByte:
.3a2a	48		pha				pha
.3a2b	da		phx				phx
.3a2c	5a		phy				phy
.3a2d	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a30	7a		ply				ply
.3a31	fa		plx				plx
.3a32	68		pla				pla
.3a33	60		rts				rts

;******  Processing input file: source/main/zzfree.footer

>3a34							.align 	256
.3b00					FreeMemory:

;******  End of listing
