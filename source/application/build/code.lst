
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl source/main/00main.header /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library _library.asm source/main/zzfree.footer
; Sun Oct 15 04:01:51 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: source/main/00main.header

.0801					StartBasicProgram:
>0801	0c 08						.word 	$080C 						; offset to next.
>0803	0a 00						.word 	10 							; line #
>0805	9e						.byte 	$9E 						; token for 'SYS'
>0806	20 32 30 36 32					.text 	' 2062'						; space, $080E in decimal
>080b	00						.byte  	0 							; end of line
>080c	00 00						.word 	0 							; end of program
.080e					StartCode:
.080e	4c 3c 3a	jmp $3a3c			jmp 	CompileCode 				; to starting the runtime in the saved code.
.0811	a9 3b		lda #$3b			lda 	#FreeMemory >> 8 			; address of object code to run.
.0813	a2 80		ldx #$80			ldx 	#$80 						; 8000-9EFF is used for workspace.
.0815	a0 9f		ldy #$9f			ldy 	#$9F
.0817	4c 26 08	jmp $0826			jmp 	StartRuntime 				; and go do it !
.081a					PatchOutCompile:
.081a	a9 ea		lda #$ea			lda 	#$EA 						; $EA is NOP 65C02
.081c	8d 0e 08	sta $080e			sta 	StartCode 					; patch out "JMP COMPILECODE"
.081f	8d 0f 08	sta $080f			sta 	StartCode+1
.0822	8d 10 08	sta $0810			sta 	StartCode+2
.0825	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.0826					StartRuntime:
.0826	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.0829	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.082b	64 28		stz $28				stz 	codePtr
.082d	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0830	8c 06 04	sty $0406			sty 	storeEndHigh
.0833	8e 07 04	stx $0407			stx 	variableStartPage
.0836	ba		tsx				tsx 								; save the stack.
.0837	8e 08 04	stx $0408			stx 	Runtime6502SP
.083a	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.083c	a2 58		ldx #$58			ldx 	#RuntimeErrorHandler & $FF
.083e	20 32 1f	jsr $1f32			jsr 	SetErrorHandler
.0841	20 84 0a	jsr $0a84			jsr 	ClearMemory 				; clear memory.
.0844	20 a9 16	jsr $16a9			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0847	20 95 13	jsr $1395		 	jsr		SetDefaultChannel			; set default input/output channel.
.084a	20 e1 15	jsr $15e1			jsr 	RestoreCode 				; which we now call
.084d	a0 00		ldy #$00			ldy 	#0
.084f					NextCommand:
.084f	ad 09 04	lda $0409			lda  	breakCount 					; only check every 16 instructions.
.0852	69 10		adc #$10			adc 	#16
.0854	8d 09 04	sta $0409			sta 	breakCount
.0857	90 07		bcc $0860			bcc 	_NXNoCheck
.0859	da		phx				phx
.085a	5a		phy				phy 								; check Ctrl+C
.085b	20 ec 1b	jsr $1bec			jsr 	XCheckStop
.085e	7a		ply				ply
.085f	fa		plx				plx
.0860					_NXNoCheck:
.0860	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.0862	30 5b		bmi $08bf			bmi 	NXCommand 					; -if -ve command
.0864	c8		iny				iny
.0865	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0867	90 39		bcc $08a2			bcc 	PushByteA 					; 0..63 is short constants.
.0869					NXLoadStore:
.0869	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.086b	b0 19		bcs $0886			bcs 	NXIndirectLoadStore
.086d	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.086e	4a		lsr a				lsr 	a
.086f	29 0e		and #$0e			and 	#$0E
.0871	da		phx				phx 								; get ready to jump
.0872	aa		tax				tax
.0873	7c 76 08	jmp ($0876,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.0876					ReadWriteVectors:
>0876	01 15						.word 	ReadFloatCommand			; read float
>0878	fb 1a						.word 	WriteFloatCommand 			; write float
>087a	3d 15						.word 	ReadIntegerCommand 			; read integer
>087c	37 1b						.word 	WriteIntegerCommand 		; write integer
>087e	82 15						.word 	ReadStringCommand 			; read string
>0880	76 1b						.word 	WriteStringCommand 			; write string
>0882	55 0c						.word 	Unimplemented
>0884	55 0c						.word 	Unimplemented
.0886					NXIndirectLoadStore:
.0886	29 07		and #$07			and 	#7
.0888	0a		asl a				asl 	a
.0889	da		phx				phx
.088a	aa		tax				tax
.088b	7c 8e 08	jmp ($088e,x)			jmp 	(IndirectVectors,x)
.088e					IndirectVectors:
>088e	12 0f						.word 	IndFloatRead 				; float read
>0890	26 0f						.word 	IndInt16Read 				; int16 read
>0892	3a 0f						.word 	IndStringRead 				; string read
>0894	55 0c						.word 	Unimplemented
>0896	4e 0f						.word 	IndFloatWrite				; float write
>0898	62 0f						.word 	IndInt16Write 				; int16 write
>089a	76 0f						.word 	IndStringWrite 				; string write
>089c	55 0c						.word 	Unimplemented
.089e					PushByteCommand:
.089e	fa		plx				plx
.089f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.08a1	c8		iny				iny
.08a2					PushByteA:
.08a2	e8		inx				inx 								; push constant on stack
.08a3	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.08a5	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.08a7					ClearRestWord:
.08a7	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.08a9	74 62		stz $62,x			stz 	NSMantissa3,x
.08ab	74 6e		stz $6e,x			stz 	NSExponent,x
.08ad	74 32		stz $32,x			stz 	NSStatus,x
.08af	80 9e		bra $084f			bra 	NextCommand
.08b1					PushWordCommand:
.08b1	fa		plx				plx
.08b2	e8		inx				inx
.08b3	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.08b5	c8		iny				iny
.08b6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08b8	b1 28		lda ($28),y			lda 	(codePtr),y
.08ba	c8		iny				iny
.08bb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08bd	80 e8		bra $08a7			bra 	ClearRestWord 				; handle everything else.
.08bf					NXCommand:
.08bf	c8		iny				iny 								; consume command.
.08c0	10 03		bpl $08c5			bpl 	_NXCommandNoFixUp
.08c2	20 cb 08	jsr $08cb			jsr 	FixUpY
.08c5					_NXCommandNoFixUp:
.08c5	0a		asl a				asl 	a 							; shift left
.08c6	da		phx				phx 								; save SP on stack
.08c7	aa		tax				tax				 					; and jump indirect
.08c8	7c d6 19	jmp ($19d6,x)			jmp 	(VectorTable,x)
.08cb					FixUpY:
.08cb	48		pha				pha
.08cc	98		tya				tya
.08cd	18		clc				clc
.08ce	65 28		adc $28				adc 	codePtr
.08d0	85 28		sta $28				sta 	codePtr
.08d2	90 02		bcc $08d6			bcc 	_NoCPCarry
.08d4	e6 29		inc $29				inc 	codePtr+1
.08d6					_NoCPCarry:
.08d6	a0 00		ldy #$00			ldy 	#0
.08d8	68		pla				pla
.08d9	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.0408					Runtime6502SP:
>0408							.fill 	1
.0409					breakCount:
>0409							.fill 	1
.08da					AbsoluteTOS:
.08da	fa		plx				plx
.08db	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.08e0					CommandVarSpace:
.08e0	fa		plx				plx
.08e1	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08e3	85 26		sta $26				sta 	availableMemory
.08e5	c8		iny				iny
.08e6	b1 28		lda ($28),y			lda 	(codePtr),y
.08e8	18		clc				clc
.08e9	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08ec	85 27		sta $27				sta 	availableMemory+1
.08ee	c8		iny				iny
.08ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08f2					BinaryAnd:
.08f2	fa		plx				plx
.08f3	38		sec				sec
.08f4	80 02		bra $08f8			bra 	AndOrCommon
.08f6					BinaryOr:
.08f6	fa		plx				plx
.08f7	18		clc				clc
.08f8					AndOrCommon:
.08f8	08		php				php 								; save AND/OR flag
.08f9	20 4d 10	jsr $104d			jsr 	GetInteger16Bit
.08fc	ca		dex				dex
.08fd	20 4d 10	jsr $104d			jsr 	GetInteger16Bit
.0900	28		plp				plp
.0901	90 0e		bcc $0911			bcc 	_AOCOrCode
.0903	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.0905	35 3f		and $3f,x			and		NSMantissa0+1,x
.0907	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0909	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.090b	35 4b		and $4b,x			and		NSMantissa1+1,x
.090d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.090f	80 0c		bra $091d			bra 	_AOCComplete
.0911					_AOCOrCode:
.0911	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.0913	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.0915	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0917	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0919	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.091b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.091d					_AOCComplete:
.091d	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.091f	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.0921	10 07		bpl $092a			bpl 	_AOCExit
.0923	20 5d 10	jsr $105d			jsr 	Negate16Bit 				; 2's complement
.0926	a9 80		lda #$80			lda 	#$80 						; make it -ve
.0928	95 32		sta $32,x			sta 	NSStatus,x
.092a					_AOCExit:
.092a	4c 4f 08	jmp $084f			jmp 	NextCommand
.092d					ArrayConvert:
.092d	fa		plx				plx
.092e	5a		phy				phy
.092f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0931	85 2e		sta $2e				sta 	zTemp1
.0933	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0935	18		clc				clc
.0936	6d 07 04	adc $0407			adc 	variableStartPage
.0939	85 2f		sta $2f				sta 	zTemp1+1
.093b	ca		dex				dex 								; count of indices to follow -> zTemp2
.093c	20 47 10	jsr $1047			jsr 	GetInteger8Bit
.093f	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.0941	8a		txa				txa
.0942	38		sec				sec
.0943	e5 30		sbc $30				sbc 	zTemp2
.0945	aa		tax				tax
.0946	da		phx				phx 								; stack points at the first index, which will be replaced.
.0947					_ACIndexLoop:
.0947	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart 			; integer array index
.094a	20 4d 10	jsr $104d			jsr 	GetInteger16Bit 			; get the index => zTemp0
.094d	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.094f	a5 2c		lda $2c				lda 	zTemp0
.0951	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0953	a5 2d		lda $2d				lda 	zTemp0+1
.0955	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0957	b0 79		bcs $09d2			bcs 	_ACBadIndex 				; index error.
.0959	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.095b	f0 29		beq $0986			beq 	_ACInnerLevel
.095d	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.095f	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0961	10 6f		bpl $09d2			bpl 	_ACBadIndex
.0963	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0965	26 2d		rol $2d				rol 	zTemp0+1
.0967	18		clc				clc
.0968	a5 2c		lda $2c				lda		zTemp0
.096a	65 2e		adc $2e				adc 	zTemp1
.096c	85 2c		sta $2c				sta 	zTemp0
.096e	a5 2d		lda $2d				lda		zTemp0+1
.0970	65 2f		adc $2f				adc 	zTemp1+1
.0972	85 2d		sta $2d				sta 	zTemp0+1
.0974	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.0976	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0978	85 2e		sta $2e				sta 	zTemp1
.097a	c8		iny				iny
.097b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.097d	18		clc				clc
.097e	6d 07 04	adc $0407			adc 	variableStartPage
.0981	85 2f		sta $2f				sta 	zTemp1+1
.0983	e8		inx				inx 								; next index
.0984	80 c1		bra $0947			bra 	_ACIndexLoop
.0986					_ACInnerLevel:
.0986	a0 02		ldy #$02			ldy 	#2
.0988	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.098a	30 46		bmi $09d2			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.098c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.098e	c9 00		cmp #$00			cmp 	#NSSIFloat
.0990	d0 13		bne $09a5			bne 	_ACNotFloat
.0992	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.0994	48		pha				pha
.0995	a5 2c		lda $2c				lda 	zTemp0
.0997	06 2c		asl $2c				asl 	zTemp0 						; x 2
.0999	26 2d		rol $2d				rol 	zTemp0+1
.099b	18		clc				clc 								; add back x 3
.099c	65 2c		adc $2c				adc 	zTemp0
.099e	85 2c		sta $2c				sta 	zTemp0
.09a0	68		pla				pla
.09a1	65 2d		adc $2d				adc 	zTemp0+1
.09a3	85 2d		sta $2d				sta 	zTemp0+1
.09a5					_ACNotFloat:
.09a5	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.09a7	26 2d		rol $2d				rol 	zTemp0+1
.09a9	18		clc				clc
.09aa	a5 2c		lda $2c				lda 	zTemp0
.09ac	69 03		adc #$03			adc 	#3
.09ae	85 2c		sta $2c				sta 	zTemp0
.09b0	90 02		bcc $09b4			bcc 	_ACNoCarry
.09b2	e6 2d		inc $2d				inc 	zTemp0+1
.09b4					_ACNoCarry:
.09b4	fa		plx				plx 								; X points to first slot of array parameters
.09b5	18		clc				clc
.09b6	a5 2c		lda $2c				lda 	zTemp0
.09b8	65 2e		adc $2e				adc 	zTemp1
.09ba	95 3e		sta $3e,x			sta 	NSMantissa0,x
.09bc	a5 2d		lda $2d				lda 	zTemp0+1
.09be	65 2f		adc $2f				adc 	zTemp1+1
.09c0	38		sec				sec
.09c1	ed 07 04	sbc $0407			sbc 	variableStartPage
.09c4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.09c6	74 56		stz $56,x			stz 	NSMantissa2,x
.09c8	74 62		stz $62,x			stz 	NSMantissa3,x
.09ca	74 32		stz $32,x			stz 	NSStatus,x
.09cc	74 6e		stz $6e,x			stz 	NSExponent,x
.09ce	7a		ply				ply 	 							; restore code pointer
.09cf	4c 4f 08	jmp $084f			jmp 	NextCommand
.09d2					_ACBadIndex:
.09d2	4c 34 20	jmp $2034		jmp	ErrorV_index
.09d5					UnaryAsc:
.09d5	fa		plx				plx
.09d6	5a		phy				phy
.09d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09d9	85 2c		sta $2c				sta 	zTemp0
.09db	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09dd	85 2d		sta $2d				sta 	zTemp0+1
.09df	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09e1	f0 06		beq $09e9			beq 	_UAExit
.09e3	5a		phy				phy 								; otherwise first character
.09e4	a0 01		ldy #$01			ldy 	#1
.09e6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09e8	7a		ply				ply
.09e9					_UAExit:
.09e9	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.09ec	7a		ply				ply
.09ed	4c 4f 08	jmp $084f			jmp 	NextCommand
.09f0					CommandAssert:
.09f0	fa		plx				plx
.09f1	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09f3	d0 09		bne $09fe			bne 	_CAFail
.09f5	20 d3 26	jsr $26d3			jsr 	FloatIsZero 				; is it zero ?
.09f8	f0 04		beq $09fe			beq 	_CAFail
.09fa	ca		dex				dex
.09fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.09fe					_CAFail:
.09fe	4c 8d 1f	jmp $1f8d		jmp	ErrorV_assert
.0a01					X16_Audio_Parameters8_16:
.0a01	20 07 0a	jsr $0a07			jsr 	X16_Audio_Parameters8_8
.0a04	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.0a06	60		rts				rts
.0a07					X16_Audio_Parameters8_8:
.0a07	a2 01		ldx #$01			ldx 	#1
.0a09	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.0a0c	ca		dex				dex
.0a0d	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.0a10	20 47 10	jsr $1047			jsr 	GetInteger8Bit
.0a13	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.0a15	a0 00		ldy #$00			ldy 	#0
.0a17	60		rts				rts
.0a18					X16_Audio_Parameters8_String:
.0a18	20 01 0a	jsr $0a01			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.0a1b	da		phx				phx 								; set the voice
.0a1c	5a		phy				phy
.0a1d	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.0a20	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>0a23	0a						.byte 	X16_AudioCodeBank
.0a24	7a		ply				ply
.0a25	fa		plx				plx
.0a26	86 2c		stx $2c				stx 	zTemp0
.0a28	84 2d		sty $2d				sty 	zTemp0+1
.0a2a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a2c	e8		inx				inx 								; point YX to first character.
.0a2d	d0 01		bne $0a30			bne 	_X16APSSkip
.0a2f	c8		iny				iny
.0a30					_X16APSSkip:
.0a30	60		rts				rts
.0a31					Unary16Bin:
.0a31	fa		plx				plx
.0a32	20 4d 10	jsr $104d			jsr 	GetInteger16Bit				; 16 bit int
.0a35	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a37	20 52 17	jsr $1752			jsr 	StringAllocTemp
.0a3a	a5 2d		lda $2d				lda 	zTemp0+1
.0a3c	f0 03		beq $0a41			beq 	_UBNoHigh
.0a3e	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a41					_UBNoHigh:
.0a41	a5 2c		lda $2c				lda 	zTemp0
.0a43	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a46	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a49					_UBWriteBinary:
.0a49	5a		phy				phy
.0a4a	a0 08		ldy #$08			ldy 	#8
.0a4c					_UBWLoop:
.0a4c	0a		asl a				asl 	a
.0a4d	48		pha				pha
.0a4e	a9 00		lda #$00			lda  	#0
.0a50	69 30		adc #$30			adc 	#48
.0a52	20 7b 17	jsr $177b			jsr 	StringWriteChar
.0a55	68		pla				pla
.0a56	88		dey				dey
.0a57	d0 f3		bne $0a4c			bne 	_UBWLoop
.0a59	7a		ply				ply
.0a5a	60		rts				rts
.0a5b					PrintCharacterX:
.0a5b	fa		plx				plx
.0a5c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a5e	ca		dex				dex
.0a5f	20 99 13	jsr $1399			jsr 	VectorPrintCharacter
.0a62	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a65					UnaryChr:
.0a65	fa		plx				plx
.0a66	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; get integer to convert.
.0a69	48		pha				pha 								; save it and allocate for it
.0a6a	a9 01		lda #$01			lda 	#1 							; 1 character
.0a6c	20 52 17	jsr $1752			jsr 	StringAllocTemp
.0a6f	a9 01		lda #$01			lda 	#1 							; length 1.
.0a71	92 22		sta ($22)			sta 	(zsTemp)
.0a73	68		pla				pla 								; character code makes string.
.0a74	5a		phy				phy
.0a75	a0 01		ldy #$01			ldy 	#1
.0a77	91 22		sta ($22),y			sta 	(zsTemp),y
.0a79	7a		ply				ply
.0a7a	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a7d					CommandClr:
.0a7d	fa		plx				plx
.0a7e	20 84 0a	jsr $0a84			jsr 	ClearMemory
.0a81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a84					ClearMemory:
.0a84	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a87	85 2d		sta $2d				sta 	zTemp0+1
.0a89	64 2c		stz $2c				stz 	zTemp0
.0a8b	5a		phy				phy
.0a8c	a0 00		ldy #$00			ldy 	#0
.0a8e					_ClearLoop1:
.0a8e	a9 00		lda #$00			lda 	#0
.0a90	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a92	c8		iny				iny
.0a93	d0 f9		bne $0a8e			bne 	_ClearLoop1
.0a95	e6 2d		inc $2d				inc 	zTemp0+1
.0a97	a5 2d		lda $2d				lda 	zTemp0+1
.0a99	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a9c	d0 f0		bne $0a8e			bne 	_ClearLoop1
.0a9e	38		sec				sec 											; stack space = number of pages in total / 4
.0a9f	ad 06 04	lda $0406			lda 	storeEndHigh
.0aa2	ed 05 04	sbc $0405			sbc		storeStartHigh
.0aa5	4a		lsr a				lsr 	a
.0aa6	4a		lsr a				lsr 	a
.0aa7	d0 02		bne $0aab			bne 	_NotEmpty 								; at least 1 !
.0aa9	a9 01		lda #$01			lda 	#1
.0aab					_NotEmpty:
.0aab	38		sec				sec 											; subtract from high to give string high memory
.0aac	49 ff		eor #$ff			eor 	#$FF
.0aae	6d 06 04	adc $0406			adc 	storeEndHigh
.0ab1	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0ab4	9c 02 04	stz $0402			stz 	stringHighMemory
.0ab7	9c 6a 05	stz $056a			stz 	stringInitialised 						; string system not initialised
.0aba	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0abd	3a		dec a				dec 	a
.0abe	85 25		sta $25				sta 	runtimeStackPtr+1
.0ac0	a9 ff		lda #$ff			lda 	#$FF
.0ac2	85 24		sta $24				sta 	runtimeStackPtr
.0ac4	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0ac6	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0ac8	7a		ply				ply
.0ac9	60		rts				rts
.0aca					CompareStrings:
.0aca	fa		plx				plx
.0acb	ca		dex				dex
.0acc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0ace	85 2c		sta $2c				sta 	zTemp0
.0ad0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ad2	85 2d		sta $2d				sta 	zTemp0+1
.0ad4	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0ad6	85 2e		sta $2e				sta 	zTemp1
.0ad8	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0ada	85 2f		sta $2f				sta 	zTemp1+1
.0adc	da		phx				phx
.0add	5a		phy				phy
.0ade	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0ae0	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0ae2	90 02		bcc $0ae6			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0ae4	b2 2e		lda ($2e)			lda 	(zTemp1)
.0ae6					_CSNIsSmallest:
.0ae6	aa		tax				tax 								; count in X
.0ae7	f0 0c		beq $0af5			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0ae9	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0aeb					_CSNCompareString:
.0aeb	c8		iny				iny 								; pre increment
.0aec	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0aee	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0af0	d0 0a		bne $0afc			bne 	_CSNDifferent 				; numbers are different.
.0af2	ca		dex				dex
.0af3	d0 f6		bne $0aeb			bne 	_CSNCompareString 			; compare common characters in two strings.
.0af5					_CSNMatches:
.0af5	38		sec				sec
.0af6	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0af8	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0afa	f0 06		beq $0b02			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0afc					_CSNDifferent:
.0afc	a9 ff		lda #$ff			lda 	#$FF
.0afe	90 02		bcc $0b02			bcc 	_CSNSExit
.0b00	a9 01		lda #$01			lda 	#$01
.0b02					_CSNSExit:
.0b02	7a		ply				ply
.0b03	fa		plx				plx
.0b04	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0b06	20 b3 26	jsr $26b3			jsr 	FloatSetByte 				; output the byte
.0b09	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b0c					StringConcrete:
.0b0c	9c 6a 05	stz $056a			stz 	stringInitialised	 		; initialise next usage
.0b0f	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0b11	85 30		sta $30				sta 	zTemp2
.0b13	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0b15	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0b16	18		clc				clc
.0b17	72 30		adc ($30)			adc 	(zTemp2)
.0b19	90 02		bcc $0b1d			bcc 	_SCNoOverflow
.0b1b	a9 ff		lda #$ff			lda 	#255
.0b1d					_SCNoOverflow:
.0b1d	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0b1f	b0 02		bcs $0b23			bcs 	_SCNoMinimum
.0b21	a9 0a		lda #$0a			lda 	#10
.0b23					_SCNoMinimum:
.0b23	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0b25	38		sec				sec
.0b26	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0b29	e5 2e		sbc $2e				sbc 	zTemp1
.0b2b	a8		tay				tay
.0b2c	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b2f	e9 00		sbc #$00			sbc 	#0
.0b31	48		pha				pha
.0b32	38		sec				sec 								; subtract 3 more
.0b33	98		tya				tya
.0b34	e9 03		sbc #$03			sbc 	#3
.0b36	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b39	85 22		sta $22				sta 	zsTemp
.0b3b	68		pla				pla
.0b3c	e9 00		sbc #$00			sbc 	#0
.0b3e	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b41	85 23		sta $23				sta 	zsTemp+1
.0b43	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b45	92 22		sta ($22)			sta 	(zsTemp)
.0b47	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b49	a9 00		lda #$00			lda 	#0
.0b4b	91 22		sta ($22),y			sta 	(zsTemp),y
.0b4d	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b4f	a4 23		ldy $23				ldy 	zsTemp+1
.0b51	60		rts				rts
.0b52					CommandXData:
.0b52	fa		plx				plx
.0b53	98		tya				tya 								; data length +1 added to Y
.0b54	38		sec				sec
.0b55	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b57	a8		tay				tay
.0b58	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b5b					CommandXDIM:
.0b5b	fa		plx				plx
.0b5c	5a		phy				phy
.0b5d	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b60	8d 0a 04	sta $040a			sta 	dimType
.0b63	ca		dex				dex 								; this is the number of indices
.0b64	20 47 10	jsr $1047			jsr 	GetInteger8Bit
.0b67	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b69	8a		txa				txa 								; dimension.
.0b6a	38		sec				sec
.0b6b	e5 2e		sbc $2e				sbc 	zTemp1
.0b6d	aa		tax				tax
.0b6e	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b70	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create one at this level
.0b73	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b75	98		tya				tya
.0b76	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b78	74 56		stz $56,x			stz 	NSMantissa2,x
.0b7a	74 62		stz $62,x			stz 	NSMantissa3,x
.0b7c	74 32		stz $32,x			stz 	NSStatus,x
.0b7e	74 6e		stz $6e,x			stz 	NSExponent,x
.0b80	7a		ply				ply
.0b81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b84					DIMCreateOneLevel:
.0b84	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b86	5a		phy				phy
.0b87	a4 27		ldy $27				ldy 	availableMemory+1
.0b89	5a		phy				phy
.0b8a	a8		tay				tay 			 					; save current level into Y
.0b8b	20 4d 10	jsr $104d			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b8e	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b90	d0 02		bne $0b94			bne 	_DCOLNoCarry
.0b92	e6 2d		inc $2d				inc 	zTemp0+1
.0b94					_DCOLNoCarry:
.0b94	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b96	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b99	a5 2d		lda $2d				lda 	zTemp0+1
.0b9b	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b9e	ad 0a 04	lda $040a			lda 	dimType 					; get type information
.0ba1	29 7f		and #$7f			and 	#$7F
.0ba3	c0 01		cpy #$01			cpy 	#1
.0ba5	f0 02		beq $0ba9			beq 	_DCOLNoSubLevel
.0ba7	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0ba9					_DCOLNoSubLevel:
.0ba9	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0bac	a5 26		lda $26				lda 	availableMemory
.0bae	85 2e		sta $2e				sta 	zTemp1
.0bb0	a5 27		lda $27				lda 	availableMemory+1
.0bb2	85 2f		sta $2f				sta 	zTemp1+1
.0bb4	a5 2c		lda $2c				lda 	zTemp0
.0bb6	85 30		sta $30				sta 	zTemp2
.0bb8	a5 2d		lda $2d				lda 	zTemp0+1
.0bba	85 31		sta $31				sta 	zTemp2+1
.0bbc					_DCOLFillArray:
.0bbc	20 1b 0c	jsr $0c1b			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0bbf	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0bc1	d0 02		bne $0bc5			bne 	_DCOLNoBorrow
.0bc3	c6 2d		dec $2d				dec 	zTemp0+1
.0bc5					_DCOLNoBorrow:
.0bc5	c6 2c		dec $2c				dec 	zTemp0
.0bc7	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0bc9	05 2d		ora $2d				ora 	zTemp0+1
.0bcb	d0 ef		bne $0bbc			bne 	_DCOLFillArray
.0bcd	c0 01		cpy #$01			cpy 	#1
.0bcf	f0 42		beq $0c13			beq 	_DCOLExit
.0bd1					_DCOLRecursionLoop:
.0bd1	da		phx				phx 								; save XY
.0bd2	5a		phy				phy
.0bd3	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0bd5	48		pha				pha
.0bd6	a5 2f		lda $2f				lda 	zTemp1+1
.0bd8	48		pha				pha
.0bd9	a5 30		lda $30				lda 	zTemp2
.0bdb	48		pha				pha
.0bdc	a5 31		lda $31				lda 	zTemp2+1
.0bde	48		pha				pha
.0bdf	88		dey				dey  								; lower level -> A
.0be0	98		tya				tya
.0be1	e8		inx				inx 								; next index size
.0be2	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0be5	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0be6	86 31		stx $31				stx 	zTemp2+1
.0be8	fa		plx				plx
.0be9	86 30		stx $30				stx 	zTemp2
.0beb	fa		plx				plx
.0bec	86 2f		stx $2f				stx 	zTemp1+1
.0bee	fa		plx				plx
.0bef	86 2e		stx $2e				stx 	zTemp1
.0bf1	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0bf3	98		tya				tya
.0bf4	a0 01		ldy #$01			ldy 	#1
.0bf6	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0bf8	7a		ply				ply 								; restore XY
.0bf9	fa		plx				plx
.0bfa	18		clc				clc
.0bfb	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0bfd	69 02		adc #$02			adc 	#2
.0bff	85 2e		sta $2e				sta 	zTemp1
.0c01	90 02		bcc $0c05			bcc 	_DCOLRNoCarry
.0c03	e6 2f		inc $2f				inc 	zTemp1+1
.0c05					_DCOLRNoCarry:
.0c05	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0c07	d0 02		bne $0c0b			bne 	_DCOLRNoBorrow
.0c09	c6 31		dec $31				dec 	zTemp2+1
.0c0b					_DCOLRNoBorrow:
.0c0b	c6 30		dec $30				dec 	zTemp2
.0c0d	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0c0f	05 31		ora $31				ora 	zTemp2+1
.0c11	d0 be		bne $0bd1			bne 	_DCOLRecursionLoop
.0c13					_DCOLExit:
.0c13	68		pla				pla 								; get MSB, make offset again
.0c14	38		sec				sec
.0c15	ed 07 04	sbc $0407			sbc 	variableStartPage
.0c18	a8		tay				tay
.0c19	68		pla				pla 								; YA now contains offset address.
.0c1a	60		rts				rts
.0c1b					DIMWriteElement:
.0c1b	da		phx				phx
.0c1c	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0c1e	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0c20	d0 0b		bne $0c2d			bne 	_DIMWENotFloat
.0c22	ad 0a 04	lda $040a			lda 	dimType
.0c25	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0c27	c9 00		cmp #$00			cmp 	#NSSIFloat
.0c29	d0 02		bne $0c2d			bne 	_DIMWENotFloat
.0c2b	a2 06		ldx #$06			ldx 	#6
.0c2d					_DIMWENotFloat:
.0c2d	a9 00		lda #$00			lda 	#0
.0c2f	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0c32	ca		dex				dex
.0c33	d0 f8		bne $0c2d			bne 	_DIMWENotFloat
.0c35	fa		plx				plx
.0c36	60		rts				rts
.0c37					DIMWriteByte:
.0c37	92 26		sta ($26)			sta 	(availableMemory)
.0c39	e6 26		inc $26				inc 	availableMemory
.0c3b	d0 0b		bne $0c48			bne 	_DIMWBSkip
.0c3d	e6 27		inc $27				inc 	availableMemory+1
.0c3f	48		pha				pha
.0c40	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c42	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c45	b0 02		bcs $0c49			bcs 	_DIMWBMemory
.0c47	68		pla				pla
.0c48					_DIMWBSkip:
.0c48	60		rts				rts
.0c49					_DIMWBMemory:
.0c49	4c 47 20	jmp $2047		jmp	ErrorV_memory
.040a					dimType:
>040a							.fill 	1
.0c4c					CommandEnd:
.0c4c	fa		plx				plx
.0c4d	86 2c		stx $2c				stx 	zTemp0
.0c4f	18		clc				clc 								; exited okay.
.0c50					EndRuntime:
.0c50	ae 08 04	ldx $0408			ldx 	Runtime6502SP 				; set up the stack pointer
.0c53	9a		txs				txs
.0c54	60		rts				rts
.0c55					Unimplemented:
.0c55	4c 7a 1f	jmp $1f7a			jmp 	ErrorV_unimplemented
.0c58					RuntimeErrorHandler:
.0c58	98		tya				tya
.0c59	18		clc				clc
.0c5a	65 28		adc $28				adc 	codePtr
.0c5c	85 28		sta $28				sta 	codePtr
.0c5e	90 02		bcc $0c62			bcc 	_EHNoCarry
.0c60	e6 29		inc $29				inc 	codePtr+1
.0c62					_EHNoCarry:
.0c62	68		pla				pla
.0c63	7a		ply				ply
.0c64	85 2c		sta $2c				sta 	zTemp0
.0c66	84 2d		sty $2d				sty 	zTemp0+1
.0c68	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c6a	a0 01		ldy #$01			ldy 	#1
.0c6c					_EHDisplayMsg:
.0c6c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c6e	20 d9 1c	jsr $1cd9			jsr 	XPrintCharacterToChannel
.0c71	c8		iny				iny
.0c72	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c74	d0 f6		bne $0c6c			bne 	_EHDisplayMsg
.0c76	a9 20		lda #$20			lda 	#32
.0c78	20 d9 1c	jsr $1cd9			jsr 	XPrintCharacterToChannel
.0c7b	a9 40		lda #$40			lda 	#64
.0c7d	20 d9 1c	jsr $1cd9			jsr 	XPrintCharacterToChannel
.0c80	a9 20		lda #$20			lda 	#32
.0c82	20 d9 1c	jsr $1cd9			jsr 	XPrintCharacterToChannel
.0c85	20 8c 0c	jsr $0c8c			jsr 	EHDisplayCodePtr
.0c88	38		sec				sec 								; report error.
.0c89	4c 50 0c	jmp $0c50			jmp 	EndRuntime
.0c8c					EHDisplayCodePtr:
.0c8c	a9 24		lda #$24			lda 	#'$'
.0c8e	20 d9 1c	jsr $1cd9			jsr 	XPrintCharacterToChannel
.0c91	38		sec				sec
.0c92	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c94	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c97	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9a	a5 28		lda $28				lda 	codePtr
.0c9c	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9f	60		rts				rts
.0ca0					_EHDisplayHex:
.0ca0	48		pha				pha
.0ca1	4a		lsr a				lsr 	a
.0ca2	4a		lsr a				lsr 	a
.0ca3	4a		lsr a				lsr 	a
.0ca4	4a		lsr a				lsr 	a
.0ca5	20 a9 0c	jsr $0ca9			jsr 	_EHDisplayNibble
.0ca8	68		pla				pla
.0ca9					_EHDisplayNibble:
.0ca9	29 0f		and #$0f			and 	#15
.0cab	c9 0a		cmp #$0a			cmp 	#10
.0cad	90 02		bcc $0cb1			bcc 	_EHNotHex
.0caf	69 06		adc #$06			adc 	#6
.0cb1					_EHNotHex:
.0cb1	69 30		adc #$30			adc 	#48
.0cb3	4c d9 1c	jmp $1cd9			jmp 	XPrintCharacterToChannel
.0cb6					CommandXFor:
.0cb6	fa		plx				plx
.0cb7	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0cb9	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0cbc	20 7e 11	jsr $117e			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0cbf	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0cc1	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cc4	ca		dex				dex
.0cc5	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0cc7	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cca	ca		dex				dex
.0ccb	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0ccd	29 80		and #$80			and 	#$80
.0ccf	a0 04		ldy #$04			ldy 	#4
.0cd1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd3	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0cd5	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0cd7	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd9	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0cdb	c8		iny				iny
.0cdc	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cde	18		clc				clc
.0cdf	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0ce1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ce3	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0ce6	85 2d		sta $2d				sta 	zTemp0+1
.0ce8	ca		dex				dex 								; throw reference.
.0ce9	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0ceb	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0ced	a0 0c		ldy #$0c			ldy 	#12
.0cef	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf1	a0 12		ldy #$12			ldy 	#18
.0cf3	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf5	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0cf7	88		dey				dey 								; now the exponents.
.0cf8	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0cfa	a0 0b		ldy #$0b			ldy 	#11
.0cfc	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cfe	a0 11		ldy #$11			ldy 	#17
.0d00	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d02	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0d04	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d06	c8		iny				iny
.0d07	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d09	c8		iny				iny
.0d0a	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d0c	d0 08		bne $0d16			bne 	_CFNoOptimise
.0d0e	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0d10	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0d12	09 40		ora #$40			ora 	#$40
.0d14	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d16					_CFNoOptimise:
.0d16	a0 00		ldy #$00			ldy 	#0
.0d18	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d1b					CopyTOSToOffsetY:
.0d1b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0d1d	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d1f	c8		iny				iny
.0d20	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0d22	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d24	c8		iny				iny
.0d25	b5 56		lda $56,x			lda 	NSMantissa2,x
.0d27	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d29	c8		iny				iny
.0d2a	b5 62		lda $62,x			lda 	NSMantissa3,x
.0d2c	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d2e	c8		iny				iny
.0d2f	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d31	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d33	c8		iny				iny
.0d34	b5 32		lda $32,x			lda 	NSStatus,x
.0d36	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d38	60		rts				rts
.0d39					StackOpenFrame:
.0d39	48		pha				pha 								; save frame marker
.0d3a	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d3c	85 2c		sta $2c				sta 	zTemp0
.0d3e	38		sec				sec 								; subtract from runtime stack pointer.
.0d3f	a5 24		lda $24				lda		runtimeStackPtr
.0d41	e5 2c		sbc $2c				sbc 	zTemp0
.0d43	85 24		sta $24				sta 	runtimeStackPtr
.0d45	a5 25		lda $25				lda		runtimeStackPtr+1
.0d47	e9 00		sbc #$00			sbc 	#0
.0d49	85 25		sta $25				sta 	runtimeStackPtr+1
.0d4b	68		pla				pla 								; put frame marker at +0
.0d4c	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d4e	60		rts				rts
.0d4f					StackCloseFrame:
.0d4f	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d51	29 1f		and #$1f			and 	#$1F 						; size
.0d53	18		clc				clc
.0d54	65 24		adc $24				adc 	runtimeStackPtr
.0d56	85 24		sta $24				sta 	runtimeStackPtr
.0d58	90 02		bcc $0d5c			bcc 	_SCFNoCarry
.0d5a	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d5c					_SCFNoCarry:
.0d5c	60		rts				rts
.0d5d					StackFindFrame:
.0d5d	8d 0b 04	sta $040b			sta 	requiredFrame
.0d60					_SFFLoop:
.0d60	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d62	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d64	f0 10		beq $0d76			beq 	SCFFail
.0d66	cd 0b 04	cmp $040b			cmp 	requiredFrame 				; found this type ?
.0d69	f0 05		beq $0d70			beq 	_SFFFound
.0d6b	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close the top frame
.0d6e	80 f0		bra $0d60			bra 	_SFFLoop 					; and try te next.
.0d70					_SFFFound:
.0d70	60		rts				rts
.0d71					StackCheckFrame:
.0d71	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d73	d0 01		bne $0d76			bne 	SCFFail
.0d75	60		rts				rts
.0d76					SCFFail:
.0d76	4c d7 1f	jmp $1fd7		jmp	ErrorV_structure
.040b					requiredFrame:
>040b							.fill 	1
.0d79					UnaryFre:
.0d79	fa		plx				plx
.0d7a	20 b1 26	jsr $26b1			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d7d	38		sec				sec
.0d7e	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d81	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d84	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d86	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d89	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d8c	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d8e	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d91					CommandXGet:
.0d91	fa		plx				plx
.0d92	e8		inx				inx
.0d93	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d95	20 52 17	jsr $1752			jsr 	StringAllocTemp
.0d98	20 a2 13	jsr $13a2			jsr 	VectorGetCharacter 			; get a character
.0d9b	c9 00		cmp #$00			cmp 	#0
.0d9d	f0 09		beq $0da8			beq 	_CGNone
.0d9f	5a		phy				phy
.0da0	a0 01		ldy #$01			ldy 	#1 							; store char
.0da2	91 22		sta ($22),y			sta 	(zsTemp),y
.0da4	98		tya				tya 								; store length.
.0da5	92 22		sta ($22)			sta 	(zsTemp)
.0da7	7a		ply				ply
.0da8					_CGNone:
.0da8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dab					CommandXGosub:
.0dab	fa		plx				plx
.0dac	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dae	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0db1	20 7e 11	jsr $117e			jsr 	StackSaveCurrentPosition
.0db4	4c c9 0d	jmp $0dc9			jmp 	PerformGOTO
.0db7					CommandReturn:
.0db7	fa		plx				plx
.0db8	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dba	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.0dbd	20 8f 11	jsr $118f			jsr 	StackLoadCurrentPosition
.0dc0	c8		iny				iny
.0dc1	c8		iny				iny
.0dc2	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame
.0dc5	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dc8					CommandXGoto:
.0dc8	fa		plx				plx
.0dc9					PerformGOTO:
.0dc9	c8		iny				iny 								; push MSB of offset on stack
.0dca	b1 28		lda ($28),y			lda 	(codePtr),y
.0dcc	48		pha				pha
.0dcd	88		dey				dey 								; point LSB of offset
.0dce	18		clc				clc 								; add LSB
.0dcf	b1 28		lda ($28),y			lda 	(codePtr),y
.0dd1	65 28		adc $28				adc 	codePtr
.0dd3	85 28		sta $28				sta 	codePtr
.0dd5	68		pla				pla 								; restore offset MSB and add
.0dd6	65 29		adc $29				adc 	codePtr+1
.0dd8	85 29		sta $29				sta 	codePtr+1
.0dda	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ddd					CommandGotoZ:
.0ddd	fa		plx				plx
.0dde	20 d3 26	jsr $26d3			jsr 	FloatIsZero
.0de1	ca		dex				dex
.0de2	c9 00		cmp #$00			cmp 	#0
.0de4	f0 e3		beq $0dc9			beq 	PerformGOTO
.0de6	c8		iny				iny
.0de7	c8		iny				iny
.0de8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0deb					CommandGotoNZ:
.0deb	fa		plx				plx
.0dec	20 d3 26	jsr $26d3			jsr 	FloatIsZero
.0def	ca		dex				dex
.0df0	c9 00		cmp #$00			cmp 	#0
.0df2	d0 d5		bne $0dc9			bne 	PerformGOTO
.0df4	c8		iny				iny
.0df5	c8		iny				iny
.0df6	4c 4f 08	jmp $084f			jmp 	NextCommand
.0df9					Command_PSET:
.0df9	fa		plx				plx
.0dfa	5a		phy				phy
.0dfb	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; get the colour
.0dfe	48		pha				pha
.0dff	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e01	a0 02		ldy #$02			ldy 	#X16_r0
.0e03	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e06	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0e09	68		pla				pla 								; set pixel.
.0e0a	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0e0d	7a		ply				ply
.0e0e	a2 ff		ldx #$ff			ldx 	#$FF
.0e10	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e13					Command_LINE:
.0e13	fa		plx				plx
.0e14	5a		phy				phy
.0e15	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e18	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0e1a	a0 02		ldy #$02			ldy 	#X16_r0
.0e1c	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0e1f	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0e22	7a		ply				ply
.0e23	a2 ff		ldx #$ff			ldx 	#$FF
.0e25	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e28					Command_RECT:
.0e28	fa		plx				plx
.0e29	5a		phy				phy
.0e2a	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e2d	38		sec				sec
.0e2e	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e31	7a		ply				ply
.0e32	a2 ff		ldx #$ff			ldx 	#$FF
.0e34	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e37					Command_FRAME:
.0e37	fa		plx				plx
.0e38	5a		phy				phy
.0e39	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e3c	18		clc				clc
.0e3d	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e40	7a		ply				ply
.0e41	a2 ff		ldx #$ff			ldx 	#$FF
.0e43	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e46					Command_CHAR:
.0e46	fa		plx				plx
.0e47	5a		phy				phy
.0e48	ca		dex				dex  								; set the draw colour
.0e49	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e4c	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e4e	a0 02		ldy #$02			ldy 	#X16_r0
.0e50	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e53	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e55	85 2c		sta $2c				sta 	zTemp0
.0e57	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e59	85 2d		sta $2d				sta 	zTemp0+1
.0e5b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e5d	85 2e		sta $2e				sta 	zTemp1
.0e5f					_CCLoop:
.0e5f	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e61	f0 0f		beq $0e72			beq 	_CCExit
.0e63	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e65	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e67	d0 02		bne $0e6b			bne 	_CCNoCarry
.0e69	e6 2d		inc $2d				inc 	zTemp0+1
.0e6b					_CCNoCarry:
.0e6b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e6d	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e70	80 ed		bra $0e5f			bra 	_CCLoop						; go round.
.0e72					_CCExit:
.0e72	7a		ply				ply
.0e73	a2 ff		ldx #$ff			ldx 	#$FF
.0e75	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e78					GraphicsColour:
.0e78	20 47 10	jsr $1047			jsr 	GetInteger8Bit
.0e7b	aa		tax				tax
.0e7c	a0 00		ldy #$00			ldy 	#0
.0e7e	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e81	60		rts				rts
.0e82					GraphicsCopy4:
.0e82	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e85					GraphicsCopy2:
.0e85	20 88 0e	jsr $0e88			jsr 	GraphicsCopy1
.0e88					GraphicsCopy1:
.0e88	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.0e8b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e8d	99 00 00	sta $0000,y			sta 	0,y
.0e90	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e92	99 01 00	sta $0001,y			sta 	1,y
.0e95	e8		inx				inx
.0e96	c8		iny				iny
.0e97	c8		iny				iny
.0e98	60		rts				rts
.0e99					GraphicsRectCoords:
.0e99	20 78 0e	jsr $0e78			jsr 	GraphicsColour 				; set colour
.0e9c	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e9e	a0 02		ldy #$02			ldy 	#X16_r0
.0ea0	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0ea3	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0ea5	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ea8	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0eaa	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ead	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0eaf	74 09		stz $09,x			stz 	9,x
.0eb1	60		rts				rts
.0eb2					_GRCSortSubtract:
.0eb2	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0eb4	d5 00		cmp $00,x			cmp 	0,x
.0eb6	b5 05		lda $05,x			lda 	5,x
.0eb8	f5 01		sbc $01,x			sbc 	1,x
.0eba	b0 08		bcs $0ec4			bcs 	_GRCNoSwap 					; >= swap.
.0ebc	20 d8 0e	jsr $0ed8			jsr 	_GRCSwapByte 				; swap 0/2
.0ebf	e8		inx				inx
.0ec0	20 d8 0e	jsr $0ed8			jsr 	_GRCSwapByte 				; swap 1/3
.0ec3	ca		dex				dex
.0ec4					_GRCNoSwap:
.0ec4	38		sec				sec 								; calculate width/height into 4,5
.0ec5	b5 04		lda $04,x			lda 	4,x
.0ec7	f5 00		sbc $00,x			sbc 	0,x
.0ec9	95 04		sta $04,x			sta 	4,x
.0ecb	b5 05		lda $05,x			lda 	5,x
.0ecd	f5 01		sbc $01,x			sbc 	1,x
.0ecf	95 05		sta $05,x			sta 	5,x
.0ed1	f6 04		inc $04,x			inc 	4,x 						; size does not include limits.
.0ed3	d0 02		bne $0ed7			bne 	_GRCNoCarry
.0ed5	f6 05		inc $05,x			inc 	5,x
.0ed7					_GRCNoCarry:
.0ed7	60		rts				rts
.0ed8					_GRCSwapByte:
.0ed8	b5 04		lda $04,x			lda 	4,x
.0eda	48		pha				pha
.0edb	b5 00		lda $00,x			lda 	0,x
.0edd	95 04		sta $04,x			sta 	4,x
.0edf	68		pla				pla
.0ee0	95 00		sta $00,x			sta 	0,x
.0ee2	60		rts				rts
.0ee3					Unary16Hex:
.0ee3	fa		plx				plx
.0ee4	20 4d 10	jsr $104d			jsr 	GetInteger16Bit
.0ee7	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0ee9	20 52 17	jsr $1752			jsr 	StringAllocTemp
.0eec	a5 2d		lda $2d				lda 	zTemp0+1
.0eee	f0 03		beq $0ef3			beq 	_UHNoHigh
.0ef0	20 fb 0e	jsr $0efb			jsr 	_UHWriteHex
.0ef3					_UHNoHigh:
.0ef3	a5 2c		lda $2c				lda 	zTemp0
.0ef5	20 fb 0e	jsr $0efb			jsr 	_UHWriteHex
.0ef8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0efb					_UHWriteHex:
.0efb	48		pha				pha
.0efc	4a		lsr a				lsr 	a
.0efd	4a		lsr a				lsr 	a
.0efe	4a		lsr a				lsr 	a
.0eff	4a		lsr a				lsr 	a
.0f00	20 04 0f	jsr $0f04			jsr 	_UHWriteNibl
.0f03	68		pla				pla
.0f04					_UHWriteNibl:
.0f04	29 0f		and #$0f			and 	#15
.0f06	c9 0a		cmp #$0a			cmp 	#10
.0f08	90 02		bcc $0f0c			bcc 	_UHDigit
.0f0a	69 06		adc #$06			adc 	#6
.0f0c					_UHDigit:
.0f0c	69 30		adc #$30			adc 	#48
.0f0e	20 7b 17	jsr $177b			jsr 	StringWriteChar
.0f11	60		rts				rts
.0f12					IndFloatRead:
.0f12	fa		plx				plx
.0f13	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f15	85 2c		sta $2c				sta 	zTemp0
.0f17	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f19	18		clc				clc
.0f1a	6d 07 04	adc $0407			adc 	variableStartPage
.0f1d	85 2d		sta $2d				sta 	zTemp0+1
.0f1f	ca		dex				dex 								; throw the address
.0f20	20 1b 15	jsr $151b			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0f23	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f26					IndInt16Read:
.0f26	fa		plx				plx
.0f27	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f29	85 2c		sta $2c				sta 	zTemp0
.0f2b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f2d	18		clc				clc
.0f2e	6d 07 04	adc $0407			adc 	variableStartPage
.0f31	85 2d		sta $2d				sta 	zTemp0+1
.0f33	ca		dex				dex 								; throw the address
.0f34	20 57 15	jsr $1557			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f37	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f3a					IndStringRead:
.0f3a	fa		plx				plx
.0f3b	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f3d	85 2c		sta $2c				sta 	zTemp0
.0f3f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f41	18		clc				clc
.0f42	6d 07 04	adc $0407			adc 	variableStartPage
.0f45	85 2d		sta $2d				sta 	zTemp0+1
.0f47	ca		dex				dex 								; throw the address
.0f48	20 9c 15	jsr $159c			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f4b	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f4e					IndFloatWrite:
.0f4e	fa		plx				plx
.0f4f	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f51	85 2c		sta $2c				sta 	zTemp0
.0f53	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f55	18		clc				clc
.0f56	6d 07 04	adc $0407			adc 	variableStartPage
.0f59	85 2d		sta $2d				sta 	zTemp0+1
.0f5b	20 15 1b	jsr $1b15			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f5e	ca		dex				dex 								; throw the address as well.
.0f5f	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f62					IndInt16Write:
.0f62	fa		plx				plx
.0f63	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f65	85 2c		sta $2c				sta 	zTemp0
.0f67	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f69	18		clc				clc
.0f6a	6d 07 04	adc $0407			adc 	variableStartPage
.0f6d	85 2d		sta $2d				sta 	zTemp0+1
.0f6f	20 51 1b	jsr $1b51			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f72	ca		dex				dex 								; throw the address as well.
.0f73	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f76					IndStringWrite:
.0f76	fa		plx				plx
.0f77	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f79	85 2c		sta $2c				sta 	zTemp0
.0f7b	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f7d	18		clc				clc
.0f7e	6d 07 04	adc $0407			adc 	variableStartPage
.0f81	85 2d		sta $2d				sta 	zTemp0+1
.0f83	20 90 1b	jsr $1b90			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f86	ca		dex				dex 								; throw the address as well.
.0f87	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f8a					CommandXInput:
.0f8a	fa		plx				plx
.0f8b	5a		phy				phy 								; save Y
.0f8c	e8		inx				inx									; space on stack
.0f8d					_INError:
.0f8d	20 c1 0f	jsr $0fc1			jsr 	InputStringToBuffer 		; input from keyboard
.0f90	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.0f92	85 2c		sta $2c				sta 	0+zTemp0
.0f94	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f96	85 2d		sta $2d				sta 	1+zTemp0
.0f98	20 9c 19	jsr $199c			jsr 	ValEvaluateZTemp0
.0f9b	b0 f0		bcs $0f8d			bcs 	_INError 					; failed, try again.
.0f9d	7a		ply				ply 								; restore Y
.0f9e	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fa1					CommandInputString:
.0fa1	fa		plx				plx
.0fa2	5a		phy				phy 								; save Y
.0fa3	20 c1 0f	jsr $0fc1			jsr 	InputStringToBuffer 		; input from keyboard
.0fa6	e8		inx				inx 								; make space on stack
.0fa7	20 b1 26	jsr $26b1			jsr 	FloatSetZero 				; store as string on stack
.0faa	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.0fac	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0fae	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0fb0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0fb2	a9 40		lda #$40			lda 	#NSSString
.0fb4	95 32		sta $32,x			sta 	NSStatus,x
.0fb6	7a		ply				ply 								; restore Y
.0fb7	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fba					CommandInputReset:
.0fba	fa		plx				plx
.0fbb	9c 0c 04	stz $040c			stz 	InputBuffer
.0fbe	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fc1					InputStringToBuffer:
.0fc1	a9 fb		lda #$fb			lda 	#((InputBumpNext) & $FF)
.0fc3	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.0fc6	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0fc8	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.0fcb	a9 d8		lda #$d8			lda 	#((InputLookNext) & $FF)
.0fcd	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.0fd0	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0fd2	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.0fd5	4c 78 14	jmp $1478			jmp 	GetStringToBuffer
.0fd8					InputLookNext:
.0fd8	da		phx				phx
.0fd9					_ILNRetry:
.0fd9	ad 0c 04	lda $040c			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fdc	d0 08		bne $0fe6			bne 	_ILNNotEmpty
.0fde	20 ff 0f	jsr $0fff			jsr 	InputGetNewLine 			; get a new line
.0fe1	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset read position.
.0fe4	80 f3		bra $0fd9			bra 	_ILNRetry
.0fe6					_ILNNotEmpty:
.0fe6	ae 5d 04	ldx $045d			ldx 	InputBufferPos 				; get head available character
.0fe9	bd 0c 04	lda $040c,x			lda 	InputBuffer,x
.0fec	d0 08		bne $0ff6			bne 	_ILNExit 					; if not EOS return it with CC.
.0fee					_ILNNextLine:
.0fee	9c 0c 04	stz $040c			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0ff1	38		sec				sec 								; return CS,Zero
.0ff2	fa		plx				plx
.0ff3	a9 0d		lda #$0d			lda 	#13
.0ff5	60		rts				rts
.0ff6					_ILNExit:
.0ff6	fa		plx				plx
.0ff7	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0ff9	18		clc				clc
.0ffa	60		rts				rts
.0ffb					InputBumpNext:
.0ffb	ee 5d 04	inc $045d			inc 	InputBufferPos
.0ffe	60		rts				rts
.0fff					InputGetNewLine:
.0fff	48		pha				pha
.1000	da		phx				phx
.1001	5a		phy				phy
.1002	a9 3f		lda #$3f			lda 	#"?"
.1004	20 3e 10	jsr $103e			jsr 	IGNLEchoIfScreen
.1007	a0 00		ldy #$00			ldy 	#0 							; line position.
.1009					_IGNLLoop:
.1009	20 a2 13	jsr $13a2			jsr 	VectorGetCharacter 			; get a character
.100c	c9 00		cmp #$00			cmp 	#0
.100e	f0 f9		beq $1009			beq 	_IGNLLoop
.1010	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.1012	f0 11		beq $1025			beq 	_IGNBackspace
.1014	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.1016	f0 17		beq $102f			beq 	_IGNExit
.1018	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.101a	f0 ed		beq $1009			beq 	_IGNLLoop
.101c	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.101f	c8		iny				iny
.1020	20 3e 10	jsr $103e			jsr 	IGNLEchoIfScreen
.1023	80 e4		bra $1009			bra 	_IGNLLoop
.1025					_IGNBackspace:
.1025	c0 00		cpy #$00			cpy 	#0
.1027	f0 e0		beq $1009			beq 	_IGNLLoop
.1029	20 3e 10	jsr $103e			jsr 	IGNLEchoIfScreen
.102c	88		dey				dey
.102d	80 da		bra $1009			bra 	_IGNLLoop
.102f					_IGNExit:
.102f	20 3e 10	jsr $103e			jsr 	IGNLEchoIfScreen
.1032	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.1034	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1037	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset position to start of input buffer.
.103a	7a		ply				ply
.103b	fa		plx				plx
.103c	68		pla				pla
.103d	60		rts				rts
.103e					IGNLEchoIfScreen:
.103e	ae 5f 04	ldx $045f			ldx 	currentChannel
.1041	d0 03		bne $1046			bne 	_IGNLEExit
.1043	20 99 13	jsr $1399			jsr 	VectorPrintCharacter
.1046					_IGNLEExit:
.1046	60		rts				rts
.040c					InputBuffer:
>040c							.fill 	81
.045d					InputBufferPos:
>045d							.fill 	1
.1047					GetInteger8Bit:
.1047	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.104a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.104c	60		rts				rts
.104d					GetInteger16Bit:
.104d	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.1050	34 32		bit $32,x			bit 	NSStatus,x
.1052	30 09		bmi $105d			bmi 	Negate16Bit
.1054	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1056	85 2c		sta $2c				sta 	zTemp0
.1058	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.105a	85 2d		sta $2d				sta 	zTemp0+1
.105c	60		rts				rts
.105d					Negate16Bit:
.105d	38		sec				sec
.105e	a9 00		lda #$00			lda 	#0
.1060	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1062	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1064	85 2c		sta $2c				sta 	zTemp0
.1066	a9 00		lda #$00			lda 	#0
.1068	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.106a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.106c	85 2d		sta $2d				sta 	zTemp0+1
.106e	60		rts				rts
.106f					UnaryJoy:
.106f	fa		plx				plx
.1070	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; port #
.1073	48		pha				pha 								; zero the result.
.1074	20 b1 26	jsr $26b1			jsr 	FloatSetZero
.1077	68		pla				pla
.1078	5a		phy				phy
.1079	da		phx				phx
.107a	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.107d	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.107f	d0 10		bne $1091			bne 	_UJNoHardware
.1081	a8		tay				tay 								; move XA -> AY
.1082	8a		txa				txa
.1083	fa		plx				plx 								; we can update it now.
.1084	49 ff		eor #$ff			eor 	#$FF
.1086	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1088	98		tya				tya
.1089	49 ff		eor #$ff			eor 	#$FF
.108b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.108d	7a		ply				ply 								; restore Y
.108e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1091					_UJNoHardware:
.1091	fa		plx				plx
.1092	7a		ply				ply
.1093	a9 01		lda #$01			lda 	#1 							; set result to -1
.1095	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.1098	20 73 26	jsr $2673			jsr 	FloatNegate
.109b	4c 4f 08	jmp $084f			jmp 	NextCommand
.109e					UnaryLen:
.109e	fa		plx				plx
.109f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.10a1	85 2c		sta $2c				sta 	zTemp0
.10a3	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.10a5	85 2d		sta $2d				sta 	zTemp0+1
.10a7	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.10a9	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.10ac	4c 4f 08	jmp $084f			jmp 	NextCommand
.10af					LinkFloatAdd:
.10af	fa		plx				plx
.10b0	5a		phy			phy
.10b1	20 d5 20	jsr $20d5		jsr	FloatAdd
.10b4	7a		ply			ply
.10b5	4c 4f 08	jmp $084f			jmp 	NextCommand
.10b8					LinkFloatSubtract:
.10b8	fa		plx				plx
.10b9	5a		phy			phy
.10ba	20 cf 20	jsr $20cf		jsr	FloatSubtract
.10bd	7a		ply			ply
.10be	4c 4f 08	jmp $084f			jmp 	NextCommand
.10c1					LinkFloatMultiply:
.10c1	fa		plx				plx
.10c2	5a		phy			phy
.10c3	20 71 23	jsr $2371		jsr	FloatMultiply
.10c6	7a		ply			ply
.10c7	4c 4f 08	jmp $084f			jmp 	NextCommand
.10ca					LinkFloatDivide:
.10ca	fa		plx				plx
.10cb	5a		phy			phy
.10cc	20 fa 21	jsr $21fa		jsr	FloatDivide
.10cf	b0 5c		bcs $112d		bcs	DivZeroError
.10d1	7a		ply			ply
.10d2	4c 4f 08	jmp $084f			jmp 	NextCommand
.10d5					LinkFloatPower:
.10d5	fa		plx				plx
.10d6	5a		phy			phy
.10d7	20 7a 29	jsr $297a		jsr	FloatPower
.10da	b0 4e		bcs $112a		bcs	MapRangeError
.10dc	7a		ply			ply
.10dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.10e0					LinkCompareGreater:
.10e0	fa		plx				plx
.10e1	5a		phy			phy
.10e2	20 7e 21	jsr $217e		jsr	CompareGreater
.10e5	7a		ply			ply
.10e6	4c 4f 08	jmp $084f			jmp 	NextCommand
.10e9					LinkCompareEqual:
.10e9	fa		plx				plx
.10ea	5a		phy			phy
.10eb	20 60 21	jsr $2160		jsr	CompareEqual
.10ee	7a		ply			ply
.10ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.10f2					LinkCompareLess:
.10f2	fa		plx				plx
.10f3	5a		phy			phy
.10f4	20 76 21	jsr $2176		jsr	CompareLess
.10f7	7a		ply			ply
.10f8	4c 4f 08	jmp $084f			jmp 	NextCommand
.10fb					LinkCompareGreaterEqual:
.10fb	fa		plx				plx
.10fc	5a		phy			phy
.10fd	20 8e 21	jsr $218e		jsr	CompareGreaterEqual
.1100	7a		ply			ply
.1101	4c 4f 08	jmp $084f			jmp 	NextCommand
.1104					LinkCompareNotEqual:
.1104	fa		plx				plx
.1105	5a		phy			phy
.1106	20 70 21	jsr $2170		jsr	CompareNotEqual
.1109	7a		ply			ply
.110a	4c 4f 08	jmp $084f			jmp 	NextCommand
.110d					LinkCompareLessEqual:
.110d	fa		plx				plx
.110e	5a		phy			phy
.110f	20 86 21	jsr $2186		jsr	CompareLessEqual
.1112	7a		ply			ply
.1113	4c 4f 08	jmp $084f			jmp 	NextCommand
.1116					LinkFloatIntegerPartDown:
.1116	fa		plx				plx
.1117	5a		phy			phy
.1118	20 10 23	jsr $2310		jsr	FloatIntegerPartDown
.111b	7a		ply			ply
.111c	4c 4f 08	jmp $084f			jmp 	NextCommand
.111f					LinkFloatSquareRoot:
.111f	fa		plx				plx
.1120	5a		phy			phy
.1121	20 fc 29	jsr $29fc		jsr	FloatSquareRoot
.1124	b0 04		bcs $112a		bcs	MapRangeError
.1126	7a		ply			ply
.1127	4c 4f 08	jmp $084f			jmp 	NextCommand
.112a					MapRangeError:
.112a	4c 3c 1f	jmp $1f3c		jmp	ErrorV_range
.112d					DivZeroError:
.112d	4c c5 1f	jmp $1fc5		jmp	ErrorV_divzero
.1130					LinkFloatLogarithm:
.1130	fa		plx				plx
.1131	5a		phy			phy
.1132	20 06 29	jsr $2906		jsr	FloatLogarithm
.1135	b0 f3		bcs $112a		bcs	MapRangeError
.1137	7a		ply			ply
.1138	4c 4f 08	jmp $084f			jmp 	NextCommand
.113b					LinkFloatExponent:
.113b	fa		plx				plx
.113c	5a		phy			phy
.113d	20 03 28	jsr $2803		jsr	FloatExponent
.1140	7a		ply			ply
.1141	4c 4f 08	jmp $084f			jmp 	NextCommand
.1144					LinkFloatCosine:
.1144	fa		plx				plx
.1145	5a		phy			phy
.1146	20 f7 27	jsr $27f7		jsr	FloatCosine
.1149	7a		ply			ply
.114a	4c 4f 08	jmp $084f			jmp 	NextCommand
.114d					LinkFloatSine:
.114d	fa		plx				plx
.114e	5a		phy			phy
.114f	20 97 29	jsr $2997		jsr	FloatSine
.1152	7a		ply			ply
.1153	4c 4f 08	jmp $084f			jmp 	NextCommand
.1156					LinkFloatTangent:
.1156	fa		plx				plx
.1157	5a		phy			phy
.1158	20 08 2a	jsr $2a08		jsr	FloatTangent
.115b	7a		ply			ply
.115c	4c 4f 08	jmp $084f			jmp 	NextCommand
.115f					LinkFloatArcTan:
.115f	fa		plx				plx
.1160	5a		phy			phy
.1161	20 dc 26	jsr $26dc		jsr	FloatArcTan
.1164	b0 c4		bcs $112a		bcs	MapRangeError
.1166	7a		ply			ply
.1167	4c 4f 08	jmp $084f			jmp 	NextCommand
.116a					LinkFloatCompare:
.116a	fa		plx				plx
.116b	5a		phy			phy
.116c	20 96 21	jsr $2196		jsr	FloatCompare
.116f	7a		ply			ply
.1170	4c 4f 08	jmp $084f			jmp 	NextCommand
.1173					LinkDivideInt32:
.1173	fa		plx				plx
.1174	5a		phy			phy
.1175	20 24 22	jsr $2224		jsr	DivideInt32
.1178	b0 b0		bcs $112a		bcs	MapRangeError
.117a	7a		ply			ply
.117b	4c 4f 08	jmp $084f			jmp 	NextCommand
.117e					StackSaveCurrentPosition:
.117e	20 cb 08	jsr $08cb			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.1181	5a		phy				phy
.1182	a0 02		ldy #$02			ldy 	#2
.1184	a5 28		lda $28				lda 	codePtr
.1186	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1188	c8		iny				iny
.1189	a5 29		lda $29				lda 	codePtr+1
.118b	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.118d	7a		ply				ply
.118e	60		rts				rts
.118f					StackLoadCurrentPosition:
.118f	a0 02		ldy #$02			ldy 	#2
.1191	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1193	85 28		sta $28				sta 	codePtr
.1195	c8		iny				iny
.1196	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1198	85 29		sta $29				sta 	codePtr+1
.119a	a0 00		ldy #$00			ldy 	#0
.119c	60		rts				rts
.119d					XCommandMouse:
.119d	fa		plx				plx
.119e	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; mouse control.
.11a1	ca		dex				dex
.11a2	da		phx				phx
.11a3	5a		phy				phy
.11a4	48		pha				pha
.11a5	38		sec				sec 								; get screen resolution
.11a6	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.11a9	68		pla				pla
.11aa	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.11ad	7a		ply				ply
.11ae	fa		plx				plx
.11af	4c 4f 08	jmp $084f			jmp 	NextCommand
.11b2					XUnaryMB:
.11b2	fa		plx				plx
.11b3	20 fa 11	jsr $11fa			jsr 	XUnaryMouseCommon
.11b6	a5 30		lda $30				lda 	zTemp2
.11b8	e8		inx				inx
.11b9	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.11bc	4c 4f 08	jmp $084f			jmp 	NextCommand
.11bf					XUnaryMX:
.11bf	fa		plx				plx
.11c0	20 fa 11	jsr $11fa			jsr 	XUnaryMouseCommon
.11c3	a5 2c		lda $2c				lda 	zTemp0
.11c5	e8		inx				inx
.11c6	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.11c9	a5 2d		lda $2d				lda 	zTemp0+1
.11cb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11cd	4c 4f 08	jmp $084f			jmp 	NextCommand
.11d0					XUnaryMY:
.11d0	fa		plx				plx
.11d1	20 fa 11	jsr $11fa			jsr 	XUnaryMouseCommon
.11d4	a5 2e		lda $2e				lda 	zTemp1
.11d6	e8		inx				inx
.11d7	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.11da	a5 2f		lda $2f				lda 	zTemp1+1
.11dc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11de	4c 4f 08	jmp $084f			jmp 	NextCommand
.11e1					XUnaryMWheel:
.11e1	fa		plx				plx
.11e2	20 fa 11	jsr $11fa			jsr 	XUnaryMouseCommon 			; read mouse status
.11e5	e8		inx				inx
.11e6	a5 31		lda $31				lda 	zTemp2+1 					; set mantissa to |wheel|
.11e8	48		pha				pha
.11e9	10 03		bpl $11ee			bpl 	_XUMNotNegative
.11eb	49 ff		eor #$ff			eor 	#$FF
.11ed	1a		inc a				inc 	a
.11ee					_XUMNotNegative:
.11ee	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.11f1	68		pla				pla  								; negate if it was -ve
.11f2	10 03		bpl $11f7			bpl 	_XUMNotNegative2
.11f4	20 73 26	jsr $2673			jsr 	FloatNegate
.11f7					_XUMNotNegative2:
.11f7	4c 4f 08	jmp $084f			jmp 	NextCommand
.11fa					XUnaryMouseCommon:
.11fa	da		phx				phx
.11fb	5a		phy				phy
.11fc	a2 2c		ldx #$2c			ldx 	#zTemp0
.11fe	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.1201	85 30		sta $30				sta 	zTemp2
.1203	86 31		stx $31				stx 	zTemp2+1
.1205	7a		ply				ply
.1206	fa		plx				plx
.1207	60		rts				rts
.1208					NegateTOS:
.1208	fa		plx				plx
.1209	20 73 26	jsr $2673			jsr 	FloatNegate
.120c	4c 4f 08	jmp $084f			jmp 	NextCommand
.120f					CommandNewLine:
.120f	fa		plx				plx
.1210	9c 6a 05	stz $056a			stz 	stringInitialised
.1213	a2 ff		ldx #$ff			ldx 	#$FF
.1215	4c 4f 08	jmp $084f			jmp 	NextCommand
.1218					CommandXNext:
.1218	fa		plx				plx
.1219					_CNRetry:
.1219	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.121b	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.121e	20 cb 08	jsr $08cb			jsr 	FixUpY 						; so we can use Y
.1221	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.1223	35 4a		and $4a,x			and 	NSMantissa1,x
.1225	c9 ff		cmp #$ff			cmp 	#$FF
.1227	f0 16		beq $123f			beq 	_CNNoIndexVariable
.1229	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.122b	a0 05		ldy #$05			ldy 	#5
.122d	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.122f	d0 07		bne $1238			bne 	_CNNIndexFail
.1231	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1233	c8		iny				iny
.1234	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.1236	f0 07		beq $123f			beq 	_CNNoIndexVariable
.1238					_CNNIndexFail:
.1238	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.123a	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close this frame
.123d	80 da		bra $1219			bra 	_CNRetry
.123f					_CNNoIndexVariable:
.123f	ca		dex				dex
.1240	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.1242	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1244	29 40		and #$40			and 	#$40	 					; bit 6
.1246	d0 55		bne $129d			bne 	_CNOptimisedNext
.1248	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.124a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.124c	48		pha				pha
.124d	85 2c		sta $2c				sta 	zTemp0
.124f	c8		iny				iny
.1250	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1252	18		clc				clc
.1253	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1256	48		pha				pha
.1257	85 2d		sta $2d				sta 	zTemp0+1
.1259	20 1b 15	jsr $151b			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.125c	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.125e	e8		inx				inx
.125f	20 e0 12	jsr $12e0			jsr 	CopyOffsetYToTOS
.1262	20 d5 20	jsr $20d5			jsr 	FloatAdd
.1265	68		pla				pla 								; restore address
.1266	85 2d		sta $2d				sta 	zTemp0+1
.1268	68		pla				pla
.1269	85 2c		sta $2c				sta 	zTemp0
.126b	20 15 1b	jsr $1b15			jsr 	WriteFloatZTemp0Sub			; write float.
.126e	e8		inx				inx  								; recover written
.126f	e8		inx				inx 								; load offset
.1270	a0 0d		ldy #$0d			ldy 	#13
.1272	20 e0 12	jsr $12e0			jsr 	CopyOffsetYToTOS
.1275	20 96 21	jsr $2196			jsr 	FloatCompare 				; and compare the floats.
.1278	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1279	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.127b	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.127d	30 08		bmi $1287			bmi 	_CNDownStep
.127f	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1281	c9 01		cmp #$01			cmp 	#1 							; gone higher
.1283	f0 10		beq $1295			beq 	_CNExitFor 					; if so exit the loop
.1285	80 06		bra $128d			bra 	_CNLoopBack
.1287					_CNDownStep:
.1287	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1289	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.128b	f0 08		beq $1295			beq 	_CNExitFor
.128d					_CNLoopBack:
.128d	20 8f 11	jsr $118f			jsr 	StackLoadCurrentPosition 	; loop back
.1290	a0 00		ldy #$00			ldy 	#0
.1292	4c 4f 08	jmp $084f			jmp 	NextCommand
.1295					_CNExitFor:
.1295	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; remove the frame and exit
.1298	a0 00		ldy #$00			ldy 	#0
.129a	4c 4f 08	jmp $084f			jmp 	NextCommand
.129d					_CNOptimisedNext:
.129d	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.129f	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12a1	85 2c		sta $2c				sta 	zTemp0
.12a3	c8		iny				iny
.12a4	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12a6	18		clc				clc
.12a7	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.12aa	85 2d		sta $2d				sta 	zTemp0+1
.12ac	a0 07		ldy #$07			ldy 	#7 							; STEP value
.12ae	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12b0	a0 ff		ldy #$ff			ldy 	#$FF
.12b2	18		clc				clc
.12b3					_CNOIncrement:
.12b3	c8		iny				iny
.12b4	71 2c		adc ($2c),y			adc 	(zTemp0),y
.12b6	91 2c		sta ($2c),y			sta 	(zTemp0),y
.12b8	f0 f9		beq $12b3			beq 	_CNOIncrement
.12ba	18		clc				clc
.12bb	a5 24		lda $24				lda 	runtimeStackPtr
.12bd	69 0d		adc #$0d			adc 	#13
.12bf	85 2e		sta $2e				sta 	zTemp1
.12c1	a5 25		lda $25				lda 	runtimeStackPtr+1
.12c3	69 00		adc #$00			adc 	#0
.12c5	85 2f		sta $2f				sta 	zTemp1+1
.12c7	a0 00		ldy #$00			ldy 	#0
.12c9	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.12cb	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.12cd	c8		iny				iny
.12ce	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.12d0	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12d2	c8		iny				iny
.12d3	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.12d5	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12d7	c8		iny				iny
.12d8	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.12da	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12dc	90 b7		bcc $1295			bcc	 	_CNExitFor
.12de	80 ad		bra $128d			bra 	_CNLoopBack
.12e0					CopyOffsetYToTOS:
.12e0	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12e2	95 3e		sta $3e,x			sta 	NSMantissa0,x
.12e4	c8		iny				iny
.12e5	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12e7	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12e9	c8		iny				iny
.12ea	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12ec	95 56		sta $56,x			sta 	NSMantissa2,x
.12ee	c8		iny				iny
.12ef	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12f1	95 62		sta $62,x			sta 	NSMantissa3,x
.12f3	c8		iny				iny
.12f4	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12f6	95 6e		sta $6e,x			sta 	NSExponent,x
.12f8	c8		iny				iny
.12f9	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12fb	95 32		sta $32,x			sta 	NSStatus,x
.12fd	60		rts				rts
.12fe	4c 4f 08	jmp $084f			jmp 	NextCommand
.1301					NotTOS:
.1301	fa		plx				plx
.1302	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.1305	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.1307	74 62		stz $62,x			stz 	NSMantissa3,x
.1309	20 73 26	jsr $2673			jsr 	FloatNegate		 			; negate
.130c	e8		inx				inx 								; and subtract 1.
.130d	a9 01		lda #$01			lda 	#1
.130f	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.1312	20 cf 20	jsr $20cf			jsr 	FloatSubtract
.1315					_NotTOSSkip:
.1315	4c 4f 08	jmp $084f			jmp 	NextCommand
.1318					CommandXOn:
.1318	fa		plx				plx
.1319	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.131c	8d 5e 04	sta $045e			sta 	onCount 					; save it.
.131f	20 cb 08	jsr $08cb			jsr 	FixUpY 						; Y = 0
.1322					_CONFind:
.1322	ce 5e 04	dec $045e			dec 	onCount 					; reached zero, do this one
.1325	f0 0b		beq $1332			beq 	_CONFound
.1327	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1328	c8		iny				iny
.1329	c8		iny				iny
.132a	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.132c	c8		iny				iny
.132d	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.132f	f0 f1		beq $1322			beq 	_CONFind
.1331	88		dey				dey 								; point to character after last GOTO/GOSUB
.1332					_CONFound:
.1332	4c 4f 08	jmp $084f			jmp 	NextCommand
.1335					CommandMoreOn:
.1335	fa		plx				plx
.1336	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1337	c8		iny				iny
.1338	c8		iny				iny
.1339	4c 4f 08	jmp $084f			jmp 	NextCommand
.045e					onCount:
>045e							.fill 	1
.133c					UnaryPeek:
.133c	fa		plx				plx
.133d	20 4d 10	jsr $104d			jsr 	GetInteger16Bit
.1340	da		phx				phx
.1341	5a		phy				phy
.1342	a6 2c		ldx $2c				ldx 	zTemp0
.1344	a4 2d		ldy $2d				ldy 	zTemp0+1
.1346	20 af 1c	jsr $1caf			jsr 	XPeekMemory
.1349	7a		ply				ply
.134a	fa		plx				plx
.134b	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.134e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1351					UnaryPI:
.1351	fa		plx				plx
.1352	a9 19		lda #$19			lda 	#Const_pi-Const_base
.1354	20 e1 28	jsr $28e1			jsr 	LoadConstant
.1357	e8		inx				inx
.1358	4c 4f 08	jmp $084f			jmp 	NextCommand
.135b					CommandPOKE:
.135b	fa		plx				plx
.135c	da		phx				phx 								; save XY
.135d	5a		phy				phy
.135e	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1361	48		pha				pha
.1362	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1364	a8		tay				tay
.1365	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1367	aa		tax				tax
.1368	68		pla				pla
.1369	20 9b 1c	jsr $1c9b			jsr 	XPokeMemory
.136c	7a		ply				ply 								; restore YX and drop 2
.136d	fa		plx				plx
.136e	ca		dex				dex
.136f	ca		dex				dex
.1370	4c 4f 08	jmp $084f			jmp 	NextCommand
.1373					UnaryPos:
.1373	fa		plx				plx
.1374	20 2e 1c	jsr $1c2e			jsr 	XGetHPos
.1377	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.137a	4c 4f 08	jmp $084f			jmp 	NextCommand
.137d					GetChannel:
.137d	fa		plx				plx
.137e	ad 5f 04	lda $045f			lda 	currentChannel
.1381	e8		inx				inx
.1382	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.1385	4c 4f 08	jmp $084f			jmp 	NextCommand
.1388					SetChannel:
.1388	fa		plx				plx
.1389	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.138c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.138e	8d 5f 04	sta $045f			sta 	currentChannel
.1391	ca		dex				dex
.1392	4c 4f 08	jmp $084f			jmp 	NextCommand
.1395					SetDefaultChannel:
.1395	9c 5f 04	stz $045f			stz 	currentChannel
.1398	60		rts				rts
.1399					VectorPrintCharacter:
.1399	da		phx				phx
.139a	ae 5f 04	ldx $045f			ldx 	currentChannel
.139d	20 d9 1c	jsr $1cd9			jsr 	XPrintCharacterToChannel
.13a0	fa		plx				plx
.13a1	60		rts				rts
.13a2					VectorGetCharacter:
.13a2	da		phx				phx
.13a3	ae 5f 04	ldx $045f			ldx 	currentChannel
.13a6	20 12 1c	jsr $1c12			jsr 	XGetCharacterFromChannel
.13a9	fa		plx				plx
.13aa	60		rts				rts
.045f					currentChannel:
>045f							.fill 	1
.13ab					PrintNumber:
.13ab	fa		plx				plx
.13ac	a9 07		lda #$07			lda 	#7
.13ae	20 99 25	jsr $2599			jsr 	FloatToString 				; to number in decimal buffer
.13b1	ca		dex				dex 								; drop
.13b2	da		phx				phx
.13b3	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.13b5					_PNLoop:
.13b5	bd 98 05	lda $0598,x			lda 	decimalBuffer,x
.13b8	20 99 13	jsr $1399			jsr 	VectorPrintCharacter
.13bb	e8		inx				inx
.13bc	bd 98 05	lda $0598,x			lda	 	decimalBuffer,x
.13bf	d0 f4		bne $13b5			bne 	_PNLoop
.13c1	a9 20		lda #$20			lda 	#32 						; trailing space
.13c3	20 99 13	jsr $1399			jsr 	VectorPrintCharacter
.13c6	fa		plx				plx
.13c7	4c 4f 08	jmp $084f			jmp 	NextCommand
.13ca					PrintString:
.13ca	fa		plx				plx
.13cb	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.13cd	85 2c		sta $2c				sta 	zTemp0
.13cf	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.13d1	85 2d		sta $2d				sta 	zTemp0+1
.13d3	ca		dex				dex 								; drop
.13d4	da		phx				phx
.13d5	5a		phy				phy
.13d6	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.13d8	aa		tax				tax
.13d9	a0 01		ldy #$01			ldy 	#1 							; Y = position
.13db					_PSLoop:
.13db	e0 00		cpx #$00			cpx 	#0 							; complete ?
.13dd	f0 09		beq $13e8			beq 	_PSExit
.13df	ca		dex				dex 								; dec count
.13e0	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.13e2	20 99 13	jsr $1399			jsr 	VectorPrintCharacter
.13e5	c8		iny				iny
.13e6	80 f3		bra $13db			bra 	_PSLoop
.13e8					_PSExit:
.13e8	7a		ply				ply
.13e9	fa		plx				plx
.13ea	4c 4f 08	jmp $084f			jmp 	NextCommand
.13ed					CommandPushN:
.13ed	fa		plx				plx
.13ee	e8		inx				inx 								; next slot on stack
.13ef	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.13f1	95 6e		sta $6e,x			sta 	NSExponent,x
.13f3	c8		iny				iny
.13f4	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.13f6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13f8	c8		iny				iny
.13f9	b1 28		lda ($28),y			lda 	(codePtr),y
.13fb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13fd	c8		iny				iny
.13fe	b1 28		lda ($28),y			lda 	(codePtr),y
.1400	95 56		sta $56,x			sta 	NSMantissa2,x
.1402	c8		iny				iny
.1403	b1 28		lda ($28),y			lda 	(codePtr),y
.1405	48		pha				pha
.1406	29 7f		and #$7f			and 	#$7F
.1408	95 62		sta $62,x			sta 	NSMantissa3,x
.140a	68		pla				pla 								; sign in mantissa3:7
.140b	29 80		and #$80			and 	#$80
.140d	95 32		sta $32,x			sta 	NSStatus,x
.140f	c8		iny				iny
.1410	4c 4f 08	jmp $084f			jmp 	NextCommand
.1413					CommandPushS:
.1413	fa		plx				plx
.1414	e8		inx				inx 								; next slot on stack
.1415	18		clc				clc
.1416	98		tya				tya
.1417	65 28		adc $28				adc 	codePtr 					; the string is inline
.1419	95 3e		sta $3e,x			sta 	NSMantissa0,x
.141b	a5 29		lda $29				lda 	codePtr+1
.141d	69 00		adc #$00			adc 	#0
.141f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1421	74 56		stz $56,x			stz 	NSMantissa2,x
.1423	74 62		stz $62,x			stz 	NSMantissa3,x
.1425	a9 40		lda #$40			lda 	#NSSString
.1427	95 32		sta $32,x			sta 	NSStatus,x
.1429	98		tya				tya 								; string length +1 added to Y
.142a	38		sec				sec
.142b	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.142d	a8		tay				tay
.142e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1431					CommandXRead:
.1431	fa		plx				plx
.1432	5a		phy				phy 								; save Y
.1433	20 64 14	jsr $1464			jsr 	ReadStringToBuffer 			; read element into buffer
.1436	e8		inx				inx									; space on stack
.1437	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.1439	85 2c		sta $2c				sta 	0+zTemp0
.143b	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.143d	85 2d		sta $2d				sta 	1+zTemp0
.143f	20 9c 19	jsr $199c			jsr 	ValEvaluateZTemp0
.1442	b0 04		bcs $1448			bcs 	_CRError 					; failed
.1444	7a		ply				ply 								; restore Y
.1445	4c 4f 08	jmp $084f			jmp 	NextCommand
.1448					_CRError:
.1448	4c 4c 1f	jmp $1f4c		jmp	ErrorV_value
.144b					CommandReadString:
.144b	fa		plx				plx
.144c	5a		phy				phy 								; save Y
.144d	20 64 14	jsr $1464			jsr 	ReadStringToBuffer 			; read text
.1450	e8		inx				inx 								; make space on stack
.1451	20 b1 26	jsr $26b1			jsr 	FloatSetZero 				; store as string on stack
.1454	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.1456	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1458	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.145a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.145c	a9 40		lda #$40			lda 	#NSSString
.145e	95 32		sta $32,x			sta 	NSStatus,x
.1460	7a		ply				ply 								; restore Y
.1461	4c 4f 08	jmp $084f			jmp 	NextCommand
.1464					ReadStringToBuffer:
.1464	a9 f7		lda #$f7			lda 	#((ReadBumpNext) & $FF)
.1466	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.1469	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.146b	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.146e	a9 ca		lda #$ca			lda 	#((ReadLookNext) & $FF)
.1470	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.1473	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.1475	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.1478					GetStringToBuffer:
.1478	20 c7 14	jsr $14c7			jsr		GetLookNext 				; skip all leading spaces.
.147b	f0 44		beq $14c1			beq 	_RBError 					; end of data
.147d	b0 f9		bcs $1478			bcs 	GetStringToBuffer 			; switched to new data line.
.147f	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1481	b0 05		bcs $1488			bcs 	_RBNoSpace
.1483	20 c4 14	jsr $14c4			jsr 	GetBumpNext 				; consume space and loop round.
.1486	80 f0		bra $1478			bra 	GetStringToBuffer
.1488					_RBNoSpace:
.1488	9c 61 04	stz $0461			stz 	ReadBufferSize 				; empty the buffer.
.148b	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.148d	d0 08		bne $1497			bne 	_RBCommaSep
.148f	8d 60 04	sta $0460			sta 	ReadSep 					; use as a seperator
.1492	20 c4 14	jsr $14c4			jsr 	GetBumpNext 				; consume the '"'
.1495	80 05		bra $149c			bra 	_RBGetText
.1497					_RBCommaSep:
.1497	a9 2c		lda #$2c			lda 	#","						; get till comma
.1499	8d 60 04	sta $0460			sta 	ReadSep
.149c					_RBGetText:
.149c	20 c7 14	jsr $14c7			jsr 	GetLookNext 				; what follows
.149f	b0 18		bcs $14b9			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.14a1	20 c4 14	jsr $14c4			jsr 	GetBumpNext 				; consume it whatever
.14a4	cd 60 04	cmp $0460			cmp 	ReadSep 					; if found the seperator.
.14a7	f0 10		beq $14b9			beq 	_RBEndGet 					; exit after consumption
.14a9	da		phx				phx
.14aa	ae 61 04	ldx $0461			ldx 	ReadBufferSize 				; copy into buffer.
.14ad	ee 61 04	inc $0461			inc 	ReadBufferSize
.14b0	9d 62 04	sta $0462,x			sta 	ReadBuffer,x
.14b3	9e 63 04	stz $0463,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.14b6	fa		plx				plx
.14b7	80 e3		bra $149c			bra 	_RBGetText
.14b9					_RBEndGet:
.14b9	c9 22		cmp #$22			cmp 	#'"'
.14bb	d0 03		bne $14c0			bne 	_RBNotQuote
.14bd	20 c4 14	jsr $14c4			jsr 	GetBumpNext
.14c0					_RBNotQuote:
.14c0	60		rts				rts
.14c1					_RBError:
.14c1	4c 01 20	jmp $2001		jmp	ErrorV_data
.14c4					GetBumpNext:
.14c4	6c 61 05	jmp ($0561)			jmp 	(ReadBumpNextVec)
.14c7					GetLookNext:
.14c7	6c 63 05	jmp ($0563)			jmp 	(ReadLookNextVec)
.14ca					ReadLookNext:
.14ca	ad 65 05	lda $0565			lda 	dataRemaining 				; any data remaining
.14cd	f0 04		beq $14d3			beq 	_RLNFindData
.14cf	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.14d1	18		clc				clc
.14d2	60		rts				rts
.14d3					_RLNFindData:
.14d3	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.14d5	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.14d7	f0 1a		beq $14f3			beq 	_RLNNoData
.14d9	c9 d0		cmp #$d0			cmp 	#PCD_CMD_DATA 				; Found DATA
.14db	f0 05		beq $14e2			beq 	_RLNHaveData
.14dd					_RLNNext:
.14dd	20 7f 20	jsr $207f			jsr 	MoveObjectForward			; else scan forward.
.14e0	80 f1		bra $14d3			bra 	_RLNFindData
.14e2					_RLNHaveData:
.14e2	a0 01		ldy #$01			ldy 	#1 							; get length
.14e4	b1 2a		lda ($2a),y			lda 	(objPtr),y
.14e6	f0 f5		beq $14dd			beq 	_RLNNext 					; skip if DATA alone
.14e8	20 f7 14	jsr $14f7			jsr 	ReadBumpNext 				; advance by two
.14eb	20 f7 14	jsr $14f7			jsr 	ReadBumpNext
.14ee	8d 65 05	sta $0565			sta 	dataRemaining 				; set data left count.
.14f1	38		sec				sec
.14f2	60		rts				rts
.14f3					_RLNNoData:
.14f3	a9 00		lda #$00			lda 	#0
.14f5	38		sec				sec
.14f6	60		rts				rts
.14f7					ReadBumpNext:
.14f7	e6 2a		inc $2a				inc 	objPtr
.14f9	d0 02		bne $14fd			bne 	_RBNSkip
.14fb	e6 2b		inc $2b				inc 	objPtr+1
.14fd					_RBNSkip:
.14fd	ce 65 05	dec $0565			dec 	dataRemaining
.1500	60		rts				rts
.0460					ReadSep:
>0460							.fill 	1
.0461					ReadBufferSize:
>0461							.fill 	1
.0462					ReadBuffer:
>0462							.fill 	255
.0561					ReadBumpNextVec:
>0561							.fill 	2
.0563					ReadLookNextVec:
>0563							.fill 	2
.1501					ReadFloatCommand:
.1501	fa		plx				plx
.1502	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1504	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1506	88		dey				dey 								; get the upper 3 bits
.1507	b1 28		lda ($28),y			lda 	(codePtr),y
.1509	29 07		and #$07			and 	#7
.150b	c8		iny				iny
.150c	c8		iny				iny
.150d	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.150f	2a		rol a				rol 	a 							; carry will be clear.
.1510	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1513	85 2d		sta $2d				sta 	zTemp0+1
.1515	20 1b 15	jsr $151b			jsr 	ReadFloatZTemp0Sub
.1518	4c 4f 08	jmp $084f			jmp 	NextCommand
.151b					ReadFloatZTemp0Sub:
.151b	5a		phy				phy 								; start write
.151c	a0 01		ldy #$01			ldy 	#1
.151e	e8		inx				inx
.151f	b2 2c		lda ($2c)			lda 	(zTemp0)
.1521	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1523	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1525	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1527	c8		iny				iny
.1528	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.152a	95 56		sta $56,x			sta 	NSMantissa2,x
.152c	c8		iny				iny
.152d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.152f	95 62		sta $62,x			sta 	NSMantissa3,x
.1531	c8		iny				iny
.1532	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1534	95 6e		sta $6e,x			sta 	NSExponent,x
.1536	c8		iny				iny
.1537	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1539	95 32		sta $32,x			sta 	NSStatus,x
.153b	7a		ply				ply
.153c	60		rts				rts
.153d					ReadIntegerCommand:
.153d	fa		plx				plx
.153e	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1540	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1542	88		dey				dey 								; get the upper 3 bits
.1543	b1 28		lda ($28),y			lda 	(codePtr),y
.1545	29 07		and #$07			and 	#7
.1547	c8		iny				iny
.1548	c8		iny				iny
.1549	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.154b	2a		rol a				rol 	a 							; carry will be clear.
.154c	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.154f	85 2d		sta $2d				sta 	zTemp0+1
.1551	20 57 15	jsr $1557			jsr 	ReadIntegerZTemp0Sub
.1554	4c 4f 08	jmp $084f			jmp 	NextCommand
.1557					ReadIntegerZTemp0Sub:
.1557	5a		phy				phy 								; start write
.1558	a0 01		ldy #$01			ldy 	#1
.155a	e8		inx				inx 								; prepare
.155b	74 56		stz $56,x			stz 	NSMantissa2,x
.155d	74 62		stz $62,x			stz 	NSMantissa3,x
.155f	74 6e		stz $6e,x			stz 	NSExponent,x
.1561	74 32		stz $32,x			stz 	NSStatus,x
.1563	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1565	30 08		bmi $156f			bmi 	_RIZNegative
.1567	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1569	b2 2c		lda ($2c)			lda 	(zTemp0)
.156b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.156d	7a		ply				ply
.156e	60		rts				rts
.156f					_RIZNegative:
.156f	38		sec				sec 								; -ve read
.1570	a9 00		lda #$00			lda 	#0
.1572	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.1574	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1576	a9 00		lda #$00			lda 	#0
.1578	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.157a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.157c	a9 80		lda #$80			lda 	#$80
.157e	95 32		sta $32,x			sta 	NSStatus,x
.1580	7a		ply				ply
.1581	60		rts				rts
.1582					ReadStringCommand:
.1582	fa		plx				plx
.1583	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1585	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1587	88		dey				dey 								; get the upper 3 bits
.1588	b1 28		lda ($28),y			lda 	(codePtr),y
.158a	29 07		and #$07			and 	#7
.158c	c8		iny				iny
.158d	c8		iny				iny
.158e	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1590	2a		rol a				rol 	a 							; carry will be clear.
.1591	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1594	85 2d		sta $2d				sta 	zTemp0+1
.1596	20 9c 15	jsr $159c			jsr 	ReadStringZTemp0Sub
.1599	4c 4f 08	jmp $084f			jmp 	NextCommand
.159c					ReadStringZTemp0Sub:
.159c	5a		phy				phy 								; start write
.159d	e8		inx				inx 								; prepare
.159e	74 56		stz $56,x			stz 	NSMantissa2,x
.15a0	74 62		stz $62,x			stz 	NSMantissa3,x
.15a2	74 6e		stz $6e,x			stz 	NSExponent,x
.15a4	a9 40		lda #$40			lda 	#NSSString
.15a6	74 32		stz $32,x			stz 	NSStatus,x
.15a8	18		clc				clc
.15a9	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.15ab	69 02		adc #$02			adc 	#2 							; this points to actual data
.15ad	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.15af	a0 01		ldy #$01			ldy 	#1
.15b1	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.15b3	69 00		adc #$00			adc 	#0
.15b5	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.15b7	d0 08		bne $15c1			bne 	_RSZNoDefault 				; if read $00 use a default value.
.15b9	a9 c3		lda #$c3			lda 	#_RSZNull & $FF
.15bb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15bd	a9 15		lda #$15			lda 	#_RSZNull >> 8
.15bf	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15c1					_RSZNoDefault:
.15c1	7a		ply				ply
.15c2	60		rts				rts
.15c3					_RSZNull:
>15c3	00						.byte 	0
.15c4					CommandRestoreX:
.15c4	fa		plx				plx
.15c5	20 cb 15	jsr $15cb			jsr 	RestoreCodeOffset
.15c8	4c 4f 08	jmp $084f			jmp 	NextCommand
.15cb					RestoreCodeOffset:
.15cb	20 cb 08	jsr $08cb			jsr 	FixUpY  					; make Y = 0 adjusting code Ptr.
.15ce	18		clc				clc 								; add LSB
.15cf	b1 28		lda ($28),y			lda 	(codePtr),y
.15d1	65 28		adc $28				adc 	codePtr
.15d3	85 2a		sta $2a				sta 	objPtr
.15d5	c8		iny				iny 								; add MSB
.15d6	b1 28		lda ($28),y			lda 	(codePtr),y
.15d8	65 29		adc $29				adc 	codePtr+1
.15da	85 2b		sta $2b				sta 	objPtr+1
.15dc	c8		iny				iny 								; next command.
.15dd	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15e0	60		rts				rts
.15e1					RestoreCode:
.15e1	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.15e4	85 2b		sta $2b				sta 	objPtr+1
.15e6	64 2a		stz $2a				stz 	objPtr
.15e8	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15eb	60		rts				rts
.0565					dataRemaining:
>0565							.fill 	1		 					; 0 if not in data statement
.15ec					UnaryRND:
.15ec	fa		plx				plx
.15ed	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.15ef	10 17		bpl $1608			bpl 	_URNoSeed
.15f1	20 06 24	jsr $2406			jsr 	FloatNormalise 				; some float value
.15f4	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.15f6	8d 66 05	sta $0566			sta 	randomSeed+0
.15f9	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15fb	8d 67 05	sta $0567			sta 	randomSeed+1
.15fe	b5 56		lda $56,x			lda 	NSMantissa2,x
.1600	8d 68 05	sta $0568			sta 	randomSeed+2
.1603	b5 62		lda $62,x			lda 	NSMantissa3,x
.1605	8d 69 05	sta $0569			sta 	randomSeed+3
.1608					_URNoSeed:
.1608	20 2a 16	jsr $162a			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.160b	ad 66 05	lda $0566			lda 	randomSeed+0
.160e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1610	ad 67 05	lda $0567			lda 	randomSeed+1
.1613	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1615	ad 68 05	lda $0568			lda 	randomSeed+2
.1618	95 56		sta $56,x			sta 	NSMantissa2,x
.161a	ad 69 05	lda $0569			lda 	randomSeed+3
.161d	29 7f		and #$7f			and 	#$7F
.161f	95 62		sta $62,x			sta 	NSMantissa3,x
.1621	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.1623	95 6e		sta $6e,x			sta 	NSExponent,x
.1625	74 32		stz $32,x			stz 	NSStatus,x
.1627	4c 4f 08	jmp $084f			jmp 	NextCommand
.162a					RandomNumberGenerator:
.162a	5a		phy				phy
.162b	ad 66 05	lda $0566			lda 	randomSeed+0 				; check if zero
.162e	0d 67 05	ora $0567			ora 	randomSeed+1
.1631	0d 68 05	ora $0568			ora 	randomSeed+2
.1634	0d 69 05	ora $0569			ora 	randomSeed+3
.1637	d0 07		bne $1640			bne 	_RNGNoSeed
.1639	ce 69 05	dec $0569			dec 	randomSeed+3 				; if so tweak and flog
.163c	a0 64		ldy #$64			ldy 	#100
.163e	80 05		bra $1645			bra 	_RNGLoop
.1640					_RNGNoSeed:
.1640	a0 08		ldy #$08			ldy 	#8
.1642	ad 66 05	lda $0566			lda 	randomSeed+0
.1645					_RNGLoop:
.1645	0a		asl a				asl		a
.1646	2e 67 05	rol $0567			rol 	randomSeed+1
.1649	2e 68 05	rol $0568			rol 	randomSeed+2
.164c	2e 69 05	rol $0569			rol 	randomSeed+3
.164f	90 02		bcc $1653			bcc		_RNGSkip
.1651	49 c5		eor #$c5			eor 	#$C5
.1653					_RNGSkip:
.1653	88		dey				dey
.1654	d0 ef		bne $1645			bne		_RNGLoop
.1656	8d 66 05	sta $0566			sta 	randomSeed+0
.1659	7a		ply				ply
.165a	60		rts				rts
.0566					randomSeed:
>0566							.fill 	4
.165b					StringConcatenate:
.165b	fa		plx				plx
.165c	ca		dex				dex
.165d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.165f	85 2e		sta $2e				sta 	zTemp1
.1661	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1663	85 2f		sta $2f				sta 	zTemp1+1
.1665	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.1667	85 30		sta $30				sta 	zTemp2
.1669	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.166b	85 31		sta $31				sta 	zTemp2+1
.166d	18		clc				clc 								; work out total length
.166e	b2 2e		lda ($2e)			lda 	(zTemp1)
.1670	72 30		adc ($30)			adc 	(zTemp2)
.1672	b0 18		bcs $168c			bcs 	_BCLength 					; more than 255 characters.
.1674	48		pha				pha 								; save total
.1675	20 52 17	jsr $1752			jsr 	StringAllocTemp 			; space for result.
.1678	68		pla				pla 								; write total as first.
.1679	92 22		sta ($22)			sta 	(zsTemp)
.167b	20 8f 16	jsr $168f			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.167e	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.1680	85 2e		sta $2e				sta 	zTemp1
.1682	a5 31		lda $31				lda 	zTemp2+1
.1684	85 2f		sta $2f				sta 	zTemp1+1
.1686	20 8f 16	jsr $168f			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1689	4c 4f 08	jmp $084f			jmp 	NextCommand
.168c					_BCLength:
.168c	4c 3c 1f	jmp $1f3c		jmp	ErrorV_range
.168f					_BCCopyZTemp1:
.168f	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.1691	f0 15		beq $16a8			beq 	_BCCExit 					; none.
.1693	da		phx				phx 								; save XY
.1694	5a		phy				phy
.1695	aa		tax				tax 								; count in X.
.1696	a0 01		ldy #$01			ldy 	#1
.1698					_BCCLoop:
.1698	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.169a	d0 02		bne $169e			bne 	_BCCNoCarry
.169c	e6 23		inc $23				inc 	zsTemp+1
.169e					_BCCNoCarry:
.169e	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.16a0	92 22		sta ($22)			sta 	(zsTemp)
.16a2	c8		iny				iny
.16a3	ca		dex				dex 								; X times
.16a4	d0 f2		bne $1698			bne 	_BCCLoop
.16a6	7a		ply				ply 								; restore YX
.16a7	fa		plx				plx
.16a8					_BCCExit:
.16a8	60		rts				rts
.16a9					XRuntimeSetup:
.16a9	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.16ab	8d 6d 05	sta $056d	 		sta 	ramBank
.16ae	8d 6e 05	sta $056e	 		sta 	romBank
.16b1	60		rts				rts
.16b2					SignTOS:
.16b2	fa		plx				plx
.16b3	20 d3 26	jsr $26d3			jsr 	FloatIsZero 				; if zero
.16b6	f0 0f		beq $16c7			beq 	_SGZero  					; return Int Zero
.16b8	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.16ba	48		pha				pha
.16bb	a9 01		lda #$01			lda 	#1 							; set result to 1
.16bd	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.16c0	68		pla				pla
.16c1	29 80		and #$80			and		#$80 						; copy the sign byte out
.16c3	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.16c5	80 03		bra $16ca			bra 	_SGExit
.16c7					_SGZero:
.16c7	20 b1 26	jsr $26b1			jsr 	FloatSetZero
.16ca					_SGExit:
.16ca	4c 4f 08	jmp $084f			jmp 	NextCommand
.16cd					CommandShift:
.16cd	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.16cf	c8		iny				iny
.16d0	0a		asl a				asl 	a 							; double into X
.16d1	aa		tax				tax
.16d2	7c 84 1a	jmp ($1a84,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.16d5					PrintTab:
.16d5	fa		plx				plx
.16d6	20 2e 1c	jsr $1c2e			jsr 	XGetHPos
.16d9					_PTMod10:
.16d9	38		sec				sec
.16da	e9 0a		sbc #$0a			sbc 	#10
.16dc	b0 fb		bcs $16d9			bcs 	_PTMod10
.16de	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.16e0	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.16e1	80 15		bra $16f8			bra 	PrintSpaceLoop
.16e3					PrintPos:
.16e3	fa		plx				plx
.16e4	20 2e 1c	jsr $1c2e			jsr		XGetHPos 					; get current position
.16e7	85 2c		sta $2c				sta 	zTemp0
.16e9	38		sec				sec 								; calculate spaces required
.16ea	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16ec	ca		dex				dex
.16ed	e5 2c		sbc $2c				sbc 	zTemp0
.16ef	b0 07		bcs $16f8			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.16f1	4c 4f 08	jmp $084f			jmp 	NextCommand
.16f4					PrintSpace:
.16f4	fa		plx				plx
.16f5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16f7	ca		dex				dex
.16f8					PrintSpaceLoop:
.16f8	c9 00		cmp #$00			cmp 	#0
.16fa	f0 0a		beq $1706			beq 	_PSExit
.16fc	48		pha				pha
.16fd	a9 20		lda #$20			lda 	#" "
.16ff	20 99 13	jsr $1399			jsr 	VectorPrintCharacter
.1702	68		pla				pla
.1703	3a		dec a				dec 	a
.1704	80 f2		bra $16f8			bra 	PrintSpaceLoop
.1706					_PSExit:
.1706	4c 4f 08	jmp $084f			jmp 	NextCommand
.1709					CommandStop:
.1709	fa		plx				plx
.170a	4c ee 1f	jmp $1fee		jmp	ErrorV_stop
.170d					Unary_Str:
.170d	fa		plx				plx
.170e	5a		phy				phy
.170f	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.1711	20 99 25	jsr $2599			jsr 	FloatToString 				; do the conversion.
.1714	a9 21		lda #$21			lda		#33 						; create buffer
.1716	20 52 17	jsr $1752			jsr 	StringAllocTemp 			; allocate memory
.1719	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.171b					_USCopy:
.171b	b9 97 05	lda $0597,y			lda 	decimalBuffer-1,y
.171e	f0 05		beq $1725			beq 	_USExit
.1720	91 22		sta ($22),y			sta 	(zsTemp),y
.1722	c8		iny				iny
.1723	80 f6		bra $171b			bra 	_USCopy
.1725					_USExit:
.1725	98		tya				tya
.1726	3a		dec a				dec 	a
.1727	92 22		sta ($22)			sta 	(zsTemp)
.1729	7a		ply				ply
.172a	4c 4f 08	jmp $084f			jmp 	NextCommand
.172d					StringInitialise:
.172d	48		pha				pha
.172e	ad 6a 05	lda $056a			lda 	stringInitialised 			; already done
.1731	d0 11		bne $1744			bne 	_SIExit
.1733	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.1736	8d 6b 05	sta $056b			sta 	stringTempPointer
.1739	ad 03 04	lda $0403			lda 	stringHighMemory+1
.173c	3a		dec a				dec 	a
.173d	3a		dec a				dec 	a
.173e	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.1741	ce 6a 05	dec $056a			dec 	stringInitialised 			; set the initialised flag.
.1744					_SIExit:
.1744	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.1746	1a		inc a				inc 	a
.1747	1a		inc a				inc 	a
.1748	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.174b	b0 02		bcs $174f			bcs 	_SIMemory
.174d	68		pla				pla
.174e	60		rts				rts
.174f					_SIMemory:
.174f	4c 47 20	jmp $2047		jmp	ErrorV_memory
.1752					StringAllocTemp:
.1752	20 2d 17	jsr $172d			jsr 	StringInitialise 			; check it is initialised.
.1755	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.1757	18		clc				clc
.1758	6d 6b 05	adc $056b			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.175b	8d 6b 05	sta $056b			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.175e	85 22		sta $22				sta 	zsTemp
.1760	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1762	ad 6c 05	lda $056c			lda 	stringTempPointer+1
.1765	69 ff		adc #$ff			adc 	#$FF
.1767	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.176a	85 23		sta $23				sta 	zsTemp+1
.176c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.176e	74 56		stz $56,x			stz 	NSMantissa2,x
.1770	74 62		stz $62,x			stz 	NSMantissa3,x
.1772	a9 00		lda #$00			lda 	#0 							; clear string.
.1774	92 22		sta ($22)			sta 	(zsTemp)
.1776	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1778	95 32		sta $32,x			sta 	NSStatus,x
.177a	60		rts				rts
.177b					StringWriteChar:
.177b	5a		phy				phy
.177c	48		pha				pha
.177d	b2 22		lda ($22)			lda 	(zsTemp)
.177f	1a		inc a				inc 	a
.1780	92 22		sta ($22)			sta 	(zsTemp)
.1782	a8		tay				tay
.1783	68		pla				pla
.1784	91 22		sta ($22),y			sta 	(zsTemp),y
.1786	7a		ply				ply
.1787	60		rts				rts
.056a					stringInitialised:
>056a							.fill 	1
.056b					stringTempPointer:
>056b							.fill 	2
.1788					Unary_Left:
.1788	fa		plx				plx
.1789	5a		phy				phy
.178a	18		clc				clc 								; only one parameter
.178b	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; push the length of the string.
.178e	48		pha				pha
.178f	ca		dex				dex
.1790	a9 00		lda #$00			lda 	#0 							; push the start position.
.1792	48		pha				pha
.1793	20 cb 17	jsr $17cb			jsr 	UnarySStringToZTemp0
.1796	80 3c		bra $17d4			bra 	SubstringMain 				; stack now points to the string to slice.
.1798					Unary_Right:
.1798	fa		plx				plx
.1799	5a		phy				phy
.179a	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.179c	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; push the right length of the string.
.179f	48		pha				pha
.17a0	ca		dex				dex
.17a1	20 cb 17	jsr $17cb			jsr 	UnarySStringToZTemp0
.17a4	68		pla				pla 								; this is the right requirement
.17a5	38		sec				sec
.17a6	49 ff		eor #$ff			eor 	#$FF
.17a8	72 2c		adc ($2c)			adc 	(zTemp0)
.17aa	b0 02		bcs $17ae			bcs 	_URHaveCount
.17ac	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.17ae					_URHaveCount:
.17ae	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.17b0	5a		phy				phy
.17b1	48		pha				pha 								; start position
.17b2	80 20		bra $17d4			bra 	SubstringMain
.17b4					Unary_Mid:
.17b4	fa		plx				plx
.17b5	5a		phy				phy
.17b6	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; push the length of the string required.
.17b9	48		pha				pha
.17ba	ca		dex				dex
.17bb	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; put the start position.
.17be	f0 08		beq $17c8			beq 	_UMError
.17c0	3a		dec a				dec 	a
.17c1	48		pha				pha
.17c2	ca		dex				dex
.17c3	20 cb 17	jsr $17cb			jsr 	UnarySStringToZTemp0
.17c6	80 0c		bra $17d4			bra 	SubstringMain 				; stack now points to the string to slice.
.17c8					_UMError:
.17c8	4c 3c 1f	jmp $1f3c		jmp	ErrorV_range
.17cb					UnarySStringToZTemp0:
.17cb	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17cd	85 2c		sta $2c				sta 	zTemp0
.17cf	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17d1	85 2d		sta $2d				sta 	zTemp0+1
.17d3	60		rts				rts
.17d4					SubstringMain:
.17d4	68		pla				pla 								; get the start offset
.17d5	7a		ply				ply 								; get the count to do.
.17d6	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.17d8	b0 38		bcs $1812			bcs 	_SSReturnNull
.17da	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.17dc	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.17de	18		clc				clc
.17df	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.17e1	b0 06		bcs $17e9			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.17e3	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.17e5	f0 04		beq $17eb			beq 	_SMIsOkay
.17e7	90 02		bcc $17eb			bcc 	_SMIsOkay
.17e9					_SMTruncateToEnd:
.17e9	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.17eb					_SMIsOkay:
.17eb	85 2f		sta $2f				sta 	zTemp1+1
.17ed	38		sec				sec		 							; work out size
.17ee	a5 2f		lda $2f				lda 	zTemp1+1
.17f0	e5 2e		sbc $2e				sbc 	zTemp1
.17f2	f0 1e		beq $1812			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.17f4	20 52 17	jsr $1752			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.17f7	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.17f9					_SMCopy:
.17f9	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.17fb	f0 11		beq $180e			beq 	_SMExit
.17fd	c8		iny				iny 								; bump and
.17fe	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.1800	5a		phy				phy
.1801	48		pha				pha
.1802	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.1804	1a		inc a				inc 	a
.1805	a8		tay				tay
.1806	92 22		sta ($22)			sta 	(zsTemp)
.1808	68		pla				pla 								; write character out
.1809	91 22		sta ($22),y			sta 	(zsTemp),y
.180b	7a		ply				ply 								; restore Y
.180c	80 eb		bra $17f9			bra 	_SMCopy
.180e					_SMExit:
.180e	7a		ply				ply
.180f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1812					_SSReturnNull:
.1812	a9 24		lda #$24			lda 	#SSRNull & $FF 				; set up mantissa
.1814	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1816	a9 18		lda #$18			lda 	#SSRNull >> 8
.1818	95 4a		sta $4a,x			sta 	NSMantissa1,x
.181a	74 56		stz $56,x			stz 	NSMantissa2,x
.181c	74 62		stz $62,x			stz 	NSMantissa3,x
.181e	a9 40		lda #$40			lda 	#NSSString
.1820	95 32		sta $32,x			sta 	NSStatus,x
.1822	80 ea		bra $180e			bra 	_SMExit
.1824					SSRNull:
>1824	00 00						.word 	0
.1826					CommandSwap:
.1826	fa		plx				plx
.1827	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1829	48		pha				pha
.182a	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.182c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.182e	68		pla				pla
.182f	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.1831	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1833	48		pha				pha
.1834	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.1836	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1838	68		pla				pla
.1839	95 49		sta $49,x			sta 	NSMantissa1-1,x
.183b	b5 56		lda $56,x			lda 	NSMantissa2,x
.183d	48		pha				pha
.183e	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.1840	95 56		sta $56,x			sta 	NSMantissa2,x
.1842	68		pla				pla
.1843	95 55		sta $55,x			sta 	NSMantissa2-1,x
.1845	b5 62		lda $62,x			lda 	NSMantissa3,x
.1847	48		pha				pha
.1848	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.184a	95 62		sta $62,x			sta 	NSMantissa3,x
.184c	68		pla				pla
.184d	95 61		sta $61,x			sta 	NSMantissa3-1,x
.184f	b5 6e		lda $6e,x			lda 	NSExponent,x
.1851	48		pha				pha
.1852	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.1854	95 6e		sta $6e,x			sta 	NSExponent,x
.1856	68		pla				pla
.1857	95 6d		sta $6d,x			sta 	NSExponent-1,x
.1859	b5 32		lda $32,x			lda 	NSStatus,x
.185b	48		pha				pha
.185c	b5 31		lda $31,x			lda 	NSStatus-1,x
.185e	95 32		sta $32,x			sta 	NSStatus,x
.1860	68		pla				pla
.1861	95 31		sta $31,x			sta 	NSStatus-1,x
.1863	4c 4f 08	jmp $084f			jmp 	NextCommand
.1866					CommandSYS:
.1866	fa		plx				plx
.1867	da		phx				phx 								; save XY
.1868	5a		phy				phy
.1869	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.186c	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.186e	85 2d		sta $2d				sta 	zTemp0+1
.1870	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1872	85 2c		sta $2c				sta 	zTemp0
.1874	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1877	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.187a	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.187d	48		pha				pha
.187e	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.1881	28		plp				plp
.1882	20 99 18	jsr $1899			jsr 	_CSZTemp0
.1885	08		php				php
.1886	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1889	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.188c	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.188f	68		pla				pla
.1890	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.1893	7a		ply				ply 								; restore YX and drop 2
.1894	fa		plx				plx
.1895	ca		dex				dex
.1896	4c 4f 08	jmp $084f			jmp 	NextCommand
.1899					_CSZTemp0:
.1899	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.189c					TimeTOS:
.189c	fa		plx				plx
.189d	20 f7 18	jsr $18f7			jsr 	TIPushClock 				; push clock to TOS
.18a0	4c 4f 08	jmp $084f			jmp 	NextCommand
.18a3					TimeString:
.18a3	fa		plx				plx
.18a4	20 f7 18	jsr $18f7			jsr 	TIPushClock 				; push clock to TOS
.18a7	20 cc 18	jsr $18cc			jsr 	_TSDivMod60 				; result in seconds
.18aa	20 cc 18	jsr $18cc			jsr 	_TSDivMod60 				; seconds
.18ad	48		pha				pha
.18ae	20 cc 18	jsr $18cc			jsr 	_TSDivMod60 				; minutes
.18b1	48		pha				pha
.18b2	a9 18		lda #$18			lda 	#24 						; hours
.18b4	20 ce 18	jsr $18ce			jsr 	_TSDivModA
.18b7	48		pha				pha
.18b8	a9 06		lda #$06			lda 	#6
.18ba	20 52 17	jsr $1752			jsr 	StringAllocTemp
.18bd	68		pla				pla
.18be	20 de 18	jsr $18de			jsr 	_TSWriteDecimal
.18c1	68		pla				pla
.18c2	20 de 18	jsr $18de			jsr 	_TSWriteDecimal
.18c5	68		pla				pla
.18c6	20 de 18	jsr $18de			jsr 	_TSWriteDecimal
.18c9	4c 4f 08	jmp $084f			jmp 	NextCommand
.18cc					_TSDivMod60:
.18cc	a9 3c		lda #$3c			lda 	#60
.18ce					_TSDivModA:
.18ce	e8		inx				inx
.18cf	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.18d2	ca		dex				dex
.18d3	20 47 22	jsr $2247			jsr 	Int32Divide
.18d6	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.18d8	48		pha				pha
.18d9	20 36 22	jsr $2236			jsr 	NSMCopyPlusTwoToZero
.18dc	68		pla				pla
.18dd	60		rts				rts
.18de					_TSWriteDecimal:
.18de	da		phx				phx
.18df	a2 30		ldx #$30			ldx 	#'0'
.18e1					_TSWDLoop:
.18e1	c9 0a		cmp #$0a			cmp 	#10
.18e3	90 05		bcc $18ea			bcc 	_TSWDEnd
.18e5	e9 0a		sbc #$0a			sbc 	#10
.18e7	e8		inx				inx
.18e8	80 f7		bra $18e1			bra 	_TSWDLoop
.18ea					_TSWDEnd:
.18ea	48		pha				pha
.18eb	8a		txa				txa
.18ec	20 7b 17	jsr $177b			jsr 	StringWriteChar
.18ef	68		pla				pla
.18f0	09 30		ora #$30			ora 	#'0'
.18f2	20 7b 17	jsr $177b			jsr 	StringWriteChar
.18f5	fa		plx				plx
.18f6	60		rts				rts
.18f7					TIPushClock:
.18f7	5a		phy				phy
.18f8	e8		inx				inx 								; push 0 on the stack
.18f9	20 b1 26	jsr $26b1			jsr 	FloatSetZero
.18fc	da		phx				phx
.18fd	20 f9 1c	jsr $1cf9			jsr 	XReadClock 					; read time into YXA
.1900	86 2c		stx $2c				stx 	zTemp0
.1902	fa		plx				plx
.1903	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1905	a5 2c		lda $2c				lda 	zTemp0
.1907	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1909	98		tya				tya
.190a	95 56		sta $56,x			sta 	NSMantissa2,x
.190c	7a		ply				ply
.190d	60		rts				rts
.190e					CommandTIWriteN:
.190e	fa		plx				plx
.190f	80 20		bra $1931			bra 	WriteTOSToClock
.1911					CommandTIWriteS:
.1911	fa		plx				plx
.1912	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.1914	85 22		sta $22				sta 	zsTemp
.1916	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1918	85 23		sta $23				sta 	zsTemp+1
.191a	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.191c	c9 06		cmp #$06			cmp 	#6
.191e	d0 59		bne $1979			bne 	CTIWError
.1920	20 b1 26	jsr $26b1			jsr 	FloatSetZero
.1923	20 45 19	jsr $1945			jsr 	CTIWDigitPair 				; do a digit pair 3 times
.1926	20 45 19	jsr $1945			jsr 	CTIWDigitPair
.1929	20 45 19	jsr $1945			jsr 	CTIWDigitPair
.192c	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.192e	20 70 19	jsr $1970			jsr 	CTIWMultiply
.1931					WriteTOSToClock:
.1931	da		phx				phx
.1932	5a		phy				phy
.1933	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.1935	48		pha				pha
.1936	b5 56		lda $56,x			lda 	NSMantissa2,x
.1938	a8		tay				tay
.1939	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.193b	fa		plx				plx
.193c	20 fd 1c	jsr $1cfd			jsr 	XWriteClock 				; update the clock.
.193f	7a		ply				ply
.1940	fa		plx				plx
.1941	ca		dex				dex 								; throw result.
.1942	4c 4f 08	jmp $084f			jmp 	NextCommand
.1945					CTIWDigitPair:
.1945	a9 06		lda #$06			lda 	#6 							; x 6
.1947	20 70 19	jsr $1970			jsr 	CTIWMultiply
.194a	20 56 19	jsr $1956			jsr 	CTIWAddDigit 				; add digit
.194d	a9 0a		lda #$0a			lda 	#10 						; x 10
.194f	20 70 19	jsr $1970			jsr 	CTIWMultiply
.1952	20 56 19	jsr $1956			jsr 	CTIWAddDigit 				; add digit
.1955	60		rts				rts
.1956					CTIWAddDigit:
.1956	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.1958	d0 02		bne $195c			bne 	CTIWASkip
.195a	e6 23		inc $23				inc 	zsTemp+1
.195c					CTIWASkip:
.195c	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.195e	38		sec				sec
.195f	e9 30		sbc #$30			sbc 	#"0"
.1961	90 16		bcc $1979			bcc 	CTIWError
.1963	c9 0a		cmp #$0a			cmp 	#9+1
.1965	b0 12		bcs $1979			bcs 	CTIWError
.1967	e8		inx				inx 								; store at +1
.1968	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.196b	ca		dex				dex
.196c	20 3d 24	jsr $243d			jsr 	FloatAddTopTwoStack
.196f	60		rts				rts
.1970					CTIWMultiply:
.1970	e8		inx				inx
.1971	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.1974	ca		dex				dex
.1975	20 be 23	jsr $23be			jsr 	FloatMultiplyShort
.1978	60		rts				rts
.1979					CTIWError:
.1979	4c 4c 1f	jmp $1f4c		jmp	ErrorV_value
.197c					UnaryUsr:
.197c	fa		plx				plx
.197d	5a		phy				phy
.197e	20 85 19	jsr $1985			jsr 	_UUCallVector
.1981	7a		ply				ply
.1982	4c 4f 08	jmp $084f			jmp 	NextCommand
.1985					_UUCallVector:
.1985	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.1988					ValUnary:
.1988	fa		plx				plx
.1989	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.198b	85 2c		sta $2c				sta 	zTemp0
.198d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.198f	85 2d		sta $2d				sta 	zTemp0+1
.1991	20 9c 19	jsr $199c			jsr 	ValEvaluateZTemp0
.1994	b0 03		bcs $1999			bcs 	_VUError 					; couldn't convert
.1996	4c 4f 08	jmp $084f			jmp 	NextCommand
.1999					_VUError:
.1999	4c 4c 1f	jmp $1f4c		jmp	ErrorV_value
.199c					ValEvaluateZTemp0:
.199c	5a		phy				phy
.199d	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.199f	f0 22		beq $19c3			beq 	_VMCFail2
.19a1	a0 00		ldy #$00			ldy 	#0 							; start position
.19a3					_VMCSpaces:
.19a3	c8		iny				iny 								; skip leading spaces
.19a4	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.19a6	c9 20		cmp #$20			cmp 	#" "
.19a8	f0 f9		beq $19a3			beq 	_VMCSpaces
.19aa	48		pha				pha 								; save first character
.19ab	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.19ad	d0 01		bne $19b0			bne 	_VMCStart
.19af	c8		iny				iny 								; skip over - if so.
.19b0					_VMCStart:
.19b0	38		sec				sec 								; initialise first time round.
.19b1					_VMCNext:
.19b1	98		tya				tya 								; reached end of string
.19b2	3a		dec a				dec 	a
.19b3	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.19b5	f0 0f		beq $19c6			beq 	_VMCSuccess 				; successful.
.19b7	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.19b9	c8		iny				iny
.19ba	20 95 24	jsr $2495			jsr 	FloatEncode 				; send it to the number-builder
.19bd	90 03		bcc $19c2			bcc 	_VMCFail 					; if failed, give up.
.19bf	18		clc				clc 								; next time round, countinue
.19c0	80 ef		bra $19b1			bra 	_VMCNext
.19c2					_VMCFail:
.19c2	68		pla				pla
.19c3					_VMCFail2:
.19c3	7a		ply				ply
.19c4	38		sec				sec
.19c5	60		rts				rts
.19c6					_VMCSuccess:
.19c6	a9 00		lda #$00			lda 	#0 							; construct final
.19c8	20 95 24	jsr $2495			jsr 	FloatEncode 				; by sending a duff value.
.19cb	68		pla				pla 								; if it was -ve
.19cc	c9 2d		cmp #$2d			cmp 	#"-"
.19ce	d0 03		bne $19d3			bne 	_VMCNotNegative
.19d0	20 73 26	jsr $2673			jsr		FloatNegate 				; negate it.
.19d3					_VMCNotNegative:
.19d3	7a		ply				ply
.19d4	18		clc				clc
.19d5	60		rts				rts
.19d6					VectorTable:
>19d6	af 10					.word	LinkFloatAdd             ; $80 +
>19d8	b8 10					.word	LinkFloatSubtract        ; $81 -
>19da	c1 10					.word	LinkFloatMultiply        ; $82 *
>19dc	ca 10					.word	LinkFloatDivide          ; $83 /
>19de	d5 10					.word	LinkFloatPower           ; $84 ^
>19e0	f2 08					.word	BinaryAnd                ; $85 and
>19e2	f6 08					.word	BinaryOr                 ; $86 or
>19e4	e0 10					.word	LinkCompareGreater       ; $87 >
>19e6	e9 10					.word	LinkCompareEqual         ; $88 =
>19e8	f2 10					.word	LinkCompareLess          ; $89 <
>19ea	fb 10					.word	LinkCompareGreaterEqual  ; $8a >=
>19ec	04 11					.word	LinkCompareNotEqual      ; $8b <>
>19ee	0d 11					.word	LinkCompareLessEqual     ; $8c <=
>19f0	da 08					.word	AbsoluteTOS              ; $8d abs
>19f2	2d 09					.word	ArrayConvert             ; $8e array
>19f4	d5 09					.word	UnaryAsc                 ; $8f asc
>19f6	f0 09					.word	CommandAssert            ; $90 assert
>19f8	31 0a					.word	Unary16Bin               ; $91 bin$
>19fa	5b 0a					.word	PrintCharacterX          ; $92 print.chr
>19fc	65 0a					.word	UnaryChr                 ; $93 chr$
>19fe	ca 0a					.word	CompareStrings           ; $94 s.cmp
>1a00	b6 0c					.word	CommandXFor              ; $95 for
>1a02	79 0d					.word	UnaryFre                 ; $96 fre
>1a04	91 0d					.word	CommandXGet              ; $97 get
>1a06	b7 0d					.word	CommandReturn            ; $98 return
>1a08	f9 0d					.word	Command_PSET             ; $99 pset
>1a0a	13 0e					.word	Command_LINE             ; $9a line
>1a0c	28 0e					.word	Command_RECT             ; $9b rect
>1a0e	37 0e					.word	Command_FRAME            ; $9c frame
>1a10	46 0e					.word	Command_CHAR             ; $9d char
>1a12	e3 0e					.word	Unary16Hex               ; $9e hex$
>1a14	8a 0f					.word	CommandXInput            ; $9f input
>1a16	a1 0f					.word	CommandInputString       ; $a0 input$
>1a18	ba 0f					.word	CommandInputReset        ; $a1 input.start
>1a1a	9e 10					.word	UnaryLen                 ; $a2 len
>1a1c	6a 11					.word	LinkFloatCompare         ; $a3 f.cmp
>1a1e	73 11					.word	LinkDivideInt32          ; $a4 int.div
>1a20	08 12					.word	NegateTOS                ; $a5 negate
>1a22	0f 12					.word	CommandNewLine           ; $a6 new.line
>1a24	18 12					.word	CommandXNext             ; $a7 next
>1a26	01 13					.word	NotTOS                   ; $a8 not
>1a28	18 13					.word	CommandXOn               ; $a9 on
>1a2a	35 13					.word	CommandMoreOn            ; $aa moreon
>1a2c	3c 13					.word	UnaryPeek                ; $ab peek
>1a2e	51 13					.word	UnaryPI                  ; $ac pi
>1a30	5b 13					.word	CommandPOKE              ; $ad poke
>1a32	73 13					.word	UnaryPos                 ; $ae pos
>1a34	7d 13					.word	GetChannel               ; $af getchannel
>1a36	88 13					.word	SetChannel               ; $b0 setchannel
>1a38	ab 13					.word	PrintNumber              ; $b1 print.n
>1a3a	ca 13					.word	PrintString              ; $b2 print.s
>1a3c	31 14					.word	CommandXRead             ; $b3 read
>1a3e	4b 14					.word	CommandReadString        ; $b4 read$
>1a40	ec 15					.word	UnaryRND                 ; $b5 rnd
>1a42	5b 16					.word	StringConcatenate        ; $b6 concat
>1a44	b2 16					.word	SignTOS                  ; $b7 sgn
>1a46	d5 16					.word	PrintTab                 ; $b8 print.tab
>1a48	e3 16					.word	PrintPos                 ; $b9 print.pos
>1a4a	f4 16					.word	PrintSpace               ; $ba print.spc
>1a4c	0d 17					.word	Unary_Str                ; $bb str$
>1a4e	88 17					.word	Unary_Left               ; $bc left$
>1a50	98 17					.word	Unary_Right              ; $bd right$
>1a52	b4 17					.word	Unary_Mid                ; $be mid$
>1a54	26 18					.word	CommandSwap              ; $bf swap
>1a56	9c 18					.word	TimeTOS                  ; $c0 ti
>1a58	a3 18					.word	TimeString               ; $c1 ti$
>1a5a	7c 19					.word	UnaryUsr                 ; $c2 usr
>1a5c	88 19					.word	ValUnary                 ; $c3 val
>1a5e	f5 1b					.word	CommandClose             ; $c4 close
>1a60	07 1c					.word	CommandExit              ; $c5 exit
>1a62	0d 1c					.word	CommandDebug             ; $c6 debug
>1a64	73 1c					.word	CommandXOpen             ; $c7 open
>1a66	07 1d					.word	CommandScreen            ; $c8 screen
>1a68	ec 1e					.word	CommandVPOKE             ; $c9 vpoke
>1a6a	11 1f					.word	CommandVPEEK             ; $ca vpeek
>1a6c	cd 16					.word	CommandShift             ; $cb .shift
>1a6e	9e 08					.word	PushByteCommand          ; $cc .byte
>1a70	b1 08					.word	PushWordCommand          ; $cd .word
>1a72	ed 13					.word	CommandPushN             ; $ce .float
>1a74	13 14					.word	CommandPushS             ; $cf .string
>1a76	52 0b					.word	CommandXData             ; $d0 .data
>1a78	c8 0d					.word	CommandXGoto             ; $d1 .goto
>1a7a	ab 0d					.word	CommandXGosub            ; $d2 .gosub
>1a7c	dd 0d					.word	CommandGotoZ             ; $d3 .goto.z
>1a7e	eb 0d					.word	CommandGotoNZ            ; $d4 .goto.nz
>1a80	e0 08					.word	CommandVarSpace          ; $d5 .varspace
>1a82	c4 15					.word	CommandRestoreX          ; $d6 .restore
.1a84					ShiftVectorTable:
>1a84	7d 0a					.word	CommandClr               ; $cb80 clr
>1a86	5b 0b					.word	CommandXDIM              ; $cb81 dim
>1a88	4c 0c					.word	CommandEnd               ; $cb82 end
>1a8a	6f 10					.word	UnaryJoy                 ; $cb83 joy
>1a8c	16 11					.word	LinkFloatIntegerPartDown ; $cb84 int
>1a8e	1f 11					.word	LinkFloatSquareRoot      ; $cb85 sqr
>1a90	30 11					.word	LinkFloatLogarithm       ; $cb86 log
>1a92	3b 11					.word	LinkFloatExponent        ; $cb87 exp
>1a94	44 11					.word	LinkFloatCosine          ; $cb88 cos
>1a96	4d 11					.word	LinkFloatSine            ; $cb89 sin
>1a98	56 11					.word	LinkFloatTangent         ; $cb8a tan
>1a9a	5f 11					.word	LinkFloatArcTan          ; $cb8b atn
>1a9c	9d 11					.word	XCommandMouse            ; $cb8c mouse
>1a9e	b2 11					.word	XUnaryMB                 ; $cb8d mb
>1aa0	bf 11					.word	XUnaryMX                 ; $cb8e mx
>1aa2	d0 11					.word	XUnaryMY                 ; $cb8f my
>1aa4	e1 11					.word	XUnaryMWheel             ; $cb90 mwheel
>1aa6	09 17					.word	CommandStop              ; $cb91 stop
>1aa8	66 18					.word	CommandSYS               ; $cb92 sys
>1aaa	0e 19					.word	CommandTIWriteN          ; $cb93 ti.write
>1aac	11 19					.word	CommandTIWriteS          ; $cb94 ti$.write
>1aae	e4 1a					.word	CommandXWAIT             ; $cb95 wait
>1ab0	38 1c					.word	X16I2CPoke               ; $cb96 i2cpoke
>1ab2	58 1c					.word	X16I2CPeek               ; $cb97 i2cpeek
>1ab4	c3 1c					.word	CommandBank              ; $cb98 bank
>1ab6	17 1d					.word	XCommandSleep            ; $cb99 sleep
>1ab8	3b 1d					.word	X16_Audio_FMINIT         ; $cb9a fminit
>1aba	49 1d					.word	X16_Audio_FMNOTE         ; $cb9b fmnote
>1abc	5b 1d					.word	X16_Audio_FMDRUM         ; $cb9c fmdrum
>1abe	6d 1d					.word	X16_Audio_FMINST         ; $cb9d fminst
>1ac0	7f 1d					.word	X16_Audio_FMVIB          ; $cb9e fmvib
>1ac2	91 1d					.word	X16_Audio_FMFREQ         ; $cb9f fmfreq
>1ac4	a2 1d					.word	X16_Audio_FMVOL          ; $cba0 fmvol
>1ac6	b4 1d					.word	X16_Audio_FMPAN          ; $cba1 fmpan
>1ac8	c6 1d					.word	X16_Audio_FMPLAY         ; $cba2 fmplay
>1aca	d7 1d					.word	X16_Audio_FMCHORD        ; $cba3 fmchord
>1acc	e8 1d					.word	X16_Audio_FMPOKE         ; $cba4 fmpoke
>1ace	fa 1d					.word	X16_Audio_PSGINIT        ; $cba5 psginit
>1ad0	08 1e					.word	X16_Audio_PSGNOTE        ; $cba6 psgnote
>1ad2	1a 1e					.word	X16_Audio_PSGVOL         ; $cba7 psgvol
>1ad4	2c 1e					.word	X16_Audio_PSGWAV         ; $cba8 psgwav
>1ad6	3e 1e					.word	X16_Audio_PSGFREQ        ; $cba9 psgfreq
>1ad8	4f 1e					.word	X16_Audio_PSGPAN         ; $cbaa psgpan
>1ada	61 1e					.word	X16_Audio_PSGPLAY        ; $cbab psgplay
>1adc	72 1e					.word	X16_Audio_PSGCHORD       ; $cbac psgchord
>1ade	83 1e					.word	CommandCls               ; $cbad cls
>1ae0	8c 1e					.word	CommandLocate            ; $cbae locate
>1ae2	b3 1e					.word	CommandColor             ; $cbaf color
.1ae4					CommandXWAIT:
.1ae4	fa		plx				plx
.1ae5	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1ae7	85 2c		sta $2c				sta 	zTemp0
.1ae9	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1aeb	85 2d		sta $2d				sta 	zTemp0+1
.1aed					_WaitLoop:
.1aed	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1aef	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1af1	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1af3	f0 f8		beq $1aed			beq 	_WaitLoop 					; keep going if zero
.1af5	ca		dex				dex 								; drop 3.
.1af6	ca		dex				dex
.1af7	ca		dex				dex
.1af8	4c 4f 08	jmp $084f			jmp 	NextCommand
.1afb					WriteFloatCommand:
.1afb	fa		plx				plx
.1afc	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1afe	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b00	88		dey				dey 								; get the upper 3 bits
.1b01	b1 28		lda ($28),y			lda 	(codePtr),y
.1b03	29 07		and #$07			and 	#7
.1b05	c8		iny				iny
.1b06	c8		iny				iny
.1b07	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b09	2a		rol a				rol 	a 							; carry will be clear.
.1b0a	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b0d	85 2d		sta $2d				sta 	zTemp0+1
.1b0f	20 15 1b	jsr $1b15			jsr 	WriteFloatZTemp0Sub
.1b12	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b15					WriteFloatZTemp0Sub:
.1b15	5a		phy				phy 								; ldart write
.1b16	a0 01		ldy #$01			ldy 	#1
.1b18	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b1a	92 2c		sta ($2c)			sta 	(zTemp0)
.1b1c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b1e	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b20	c8		iny				iny
.1b21	b5 56		lda $56,x			lda 	NSMantissa2,x
.1b23	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b25	c8		iny				iny
.1b26	b5 62		lda $62,x			lda 	NSMantissa3,x
.1b28	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b2a	c8		iny				iny
.1b2b	b5 6e		lda $6e,x			lda 	NSExponent,x
.1b2d	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b2f	c8		iny				iny
.1b30	b5 32		lda $32,x			lda 	NSStatus,x
.1b32	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b34	ca		dex				dex
.1b35	7a		ply				ply
.1b36	60		rts				rts
.1b37					WriteIntegerCommand:
.1b37	fa		plx				plx
.1b38	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b3a	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b3c	88		dey				dey 								; get the upper 3 bits
.1b3d	b1 28		lda ($28),y			lda 	(codePtr),y
.1b3f	29 07		and #$07			and 	#7
.1b41	c8		iny				iny
.1b42	c8		iny				iny
.1b43	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b45	2a		rol a				rol 	a 							; carry will be clear.
.1b46	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b49	85 2d		sta $2d				sta 	zTemp0+1
.1b4b	20 51 1b	jsr $1b51			jsr 	WriteIntegerZTemp0Sub
.1b4e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b51					WriteIntegerZTemp0Sub:
.1b51	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.1b54	5a		phy				phy 								; start write
.1b55	a0 01		ldy #$01			ldy 	#1
.1b57	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1b59	30 0b		bmi $1b66			bmi 	_WIZNegative
.1b5b	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1b5d	92 2c		sta ($2c)			sta 	(zTemp0)
.1b5f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b61	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b63	7a		ply				ply
.1b64	ca		dex				dex
.1b65	60		rts				rts
.1b66					_WIZNegative:
.1b66	38		sec				sec 								; -ve read
.1b67	a9 00		lda #$00			lda 	#0
.1b69	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1b6b	92 2c		sta ($2c)			sta 	(zTemp0)
.1b6d	a9 00		lda #$00			lda 	#0
.1b6f	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1b71	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b73	7a		ply				ply
.1b74	ca		dex				dex
.1b75	60		rts				rts
.1b76					WriteStringCommand:
.1b76	fa		plx				plx
.1b77	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b79	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b7b	88		dey				dey 								; get the upper 3 bits
.1b7c	b1 28		lda ($28),y			lda 	(codePtr),y
.1b7e	29 07		and #$07			and 	#7
.1b80	c8		iny				iny
.1b81	c8		iny				iny
.1b82	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b84	2a		rol a				rol 	a 							; carry will be clear.
.1b85	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b88	85 2d		sta $2d				sta 	zTemp0+1
.1b8a	20 90 1b	jsr $1b90			jsr 	WriteStringZTemp0Sub
.1b8d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b90					WriteStringZTemp0Sub:
.1b90	5a		phy				phy
.1b91	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b93	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b95	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b97	f0 1e		beq $1bb7			beq 	_WSConcrete
.1b99	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b9b	85 2e		sta $2e				sta 	zTemp1
.1b9d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b9f	85 2f		sta $2f				sta 	zTemp1+1
.1ba1	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1ba3	85 30		sta $30				sta 	zTemp2
.1ba5	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ba7	85 31		sta $31				sta 	zTemp2+1
.1ba9	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1bab	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1bad	b0 17		bcs $1bc6			bcs 	_WSCopy
.1baf	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1bb1	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1bb3	09 80		ora #$80			ora 	#$80
.1bb5	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1bb7					_WSConcrete:
.1bb7	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1bb9	a8		tay				tay
.1bba	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1bbc	20 0c 0b	jsr $0b0c			jsr 	StringConcrete
.1bbf	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1bc1	98		tya				tya
.1bc2	a0 01		ldy #$01			ldy 	#1
.1bc4	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1bc6					_WSCopy
.1bc6	18		clc				clc  								; copy target+2 to zTemp2
.1bc7	b2 2c		lda ($2c)			lda 	(zTemp0)
.1bc9	69 02		adc #$02			adc 	#2
.1bcb	85 30		sta $30				sta 	zTemp2
.1bcd	a0 01		ldy #$01			ldy 	#1
.1bcf	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1bd1	69 00		adc #$00			adc 	#0
.1bd3	85 31		sta $31				sta 	zTemp2+1
.1bd5	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1bd7	85 2e		sta $2e				sta 	zTemp1
.1bd9	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1bdb	85 2f		sta $2f				sta 	zTemp1+1
.1bdd	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1bdf	a8		tay				tay
.1be0					_WSCopyLoop:
.1be0	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1be2	91 30		sta ($30),y			sta 	(zTemp2),y
.1be4	88		dey				dey
.1be5	c0 ff		cpy #$ff			cpy 	#$FF
.1be7	d0 f7		bne $1be0			bne 	_WSCopyLoop
.1be9	ca		dex				dex
.1bea	7a		ply				ply
.1beb	60		rts				rts
.1bec					XCheckStop:
.1bec	20 e1 ff	jsr $ffe1			jsr 	$FFE1 						; check stop
.1bef	f0 01		beq $1bf2			beq 	_XCSStop
.1bf1	60		rts				rts
.1bf2					_XCSStop:
.1bf2	4c 6e 20	jmp $206e		jmp	ErrorV_break
.1bf5					CommandClose:
.1bf5	fa		plx				plx
.1bf6	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; channel to close
.1bf9	cd 5f 04	cmp $045f			cmp 	currentChannel 				; is it the current channel
.1bfc	d0 03		bne $1c01			bne 	_CCNotCurrent
.1bfe	9c 5f 04	stz $045f			stz 	currentChannel 				; effectively disables CMD
.1c01					_CCNotCurrent:
.1c01	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1c04	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c07					CommandExit:
.1c07	fa		plx				plx
.1c08	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1c0a	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1c0d					CommandDebug:
.1c0d	fa		plx				plx
>1c0e	db						.byte 	$DB 						; causes a break in the emulator
.1c0f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c12					XGetCharacterFromChannel:
.1c12	da		phx				phx
.1c13	5a		phy				phy
.1c14	e0 00		cpx #$00			cpx 	#0 							; is it default
.1c16	d0 05		bne $1c1d			bne 	_XGetChannel
.1c18	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1c1b	80 08		bra $1c25			bra 	_XGetChar
.1c1d					_XGetChannel:
.1c1d	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1c20	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1c23	d0 06		bne $1c2b			bne 	_XGCError
.1c25					_XGetChar:
.1c25	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1c28	7a		ply				ply
.1c29	fa		plx				plx
.1c2a	60		rts				rts
.1c2b					_XGCError:
.1c2b	4c 58 20	jmp $2058		jmp	ErrorV_channel
.1c2e					XGetHPos:
.1c2e	da		phx				phx
.1c2f	5a		phy				phy
.1c30	38		sec				sec
.1c31	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1c34	98		tya				tya
.1c35	7a		ply				ply
.1c36	fa		plx				plx
.1c37	60		rts				rts
.1c38					X16I2CPoke:
.1c38	fa		plx				plx
.1c39	5a		phy				phy
.1c3a	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; value
.1c3d	48		pha				pha
.1c3e	ca		dex				dex
.1c3f	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; register
.1c42	48		pha				pha
.1c43	ca		dex				dex
.1c44	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; device
.1c47	aa		tax				tax
.1c48	7a		ply				ply
.1c49	68		pla				pla
.1c4a	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1c4d	b0 06		bcs $1c55			bcs 	X16I2CError
.1c4f	7a		ply				ply
.1c50	a2 ff		ldx #$ff			ldx 	#$FF
.1c52	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c55					X16I2CError:
.1c55	4c 58 20	jmp $2058		jmp	ErrorV_channel
.1c58					X16I2CPeek:
.1c58	fa		plx				plx
.1c59	da		phx				phx
.1c5a	5a		phy				phy
.1c5b	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; register
.1c5e	48		pha				pha
.1c5f	ca		dex				dex
.1c60	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; device
.1c63	aa		tax				tax 								; X device
.1c64	7a		ply				ply 								; Y register
.1c65	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1c68	b0 eb		bcs $1c55			bcs 	X16I2CError
.1c6a	7a		ply				ply 								; restore Y/X
.1c6b	fa		plx				plx
.1c6c	ca		dex				dex 								; drop TOS (register)
.1c6d	20 b3 26	jsr $26b3			jsr 	FloatSetByte 				; write read value to TOS.
.1c70	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c73					CommandXOpen:
.1c73	fa		plx				plx
.1c74	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1c76	85 2c		sta $2c				sta 	zTemp0
.1c78	aa		tax				tax
.1c79	a5 4d		lda $4d				lda 	NSMantissa1+3
.1c7b	85 2d		sta $2d				sta 	zTemp0+1
.1c7d	a8		tay				tay
.1c7e	e8		inx				inx 								; XY points to first character
.1c7f	d0 01		bne $1c82			bne 	_CONoCarry
.1c81	c8		iny				iny
.1c82					_CONoCarry:
.1c82	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c84	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c87	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c89	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c8b	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c8d	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c90	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c93	b0 03		bcs $1c98			bcs 	_COError
.1c95	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c98					_COError:
.1c98	4c 58 20	jmp $2058		jmp	ErrorV_channel
.1c9b					XPokeMemory:
.1c9b	86 2c		stx $2c				stx 	zTemp0
.1c9d	84 2d		sty $2d				sty 	zTemp0+1
.1c9f	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1ca1	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1ca4	e0 ff		cpx #$ff			cpx 	#$FF
.1ca6	f0 02		beq $1caa			beq 	_XPMNoSwitch
.1ca8	86 00		stx $00				stx 	SelectRAMBank
.1caa					_XPMNoSwitch:
.1caa	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1cac	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1cae					_XPMExit:
.1cae	60		rts				rts
.1caf					XPeekMemory:
.1caf	86 2c		stx $2c				stx 	zTemp0
.1cb1	84 2d		sty $2d				sty 	zTemp0+1
.1cb3	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1cb5	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1cb8	e0 ff		cpx #$ff			cpx 	#$FF
.1cba	f0 02		beq $1cbe			beq 	_XPMNoSwitch
.1cbc	86 00		stx $00				stx 	SelectRAMBank
.1cbe					_XPMNoSwitch:
.1cbe	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1cc0	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1cc2	60		rts				rts
.1cc3					CommandBank:
.1cc3	fa		plx				plx
.1cc4	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1cc6	8d 6d 05	sta $056d			sta 	ramBank 					; store & make current
.1cc9	85 00		sta $00				sta 	SelectRAMBank
.1ccb	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1ccd	c9 ff		cmp #$ff			cmp 	#$FF
.1ccf	f0 03		beq $1cd4			beq 	_CBNoUpdate
.1cd1	8d 6e 05	sta $056e			sta 	romBank 					; this doesn't set the hardware page.
.1cd4					_CBNoUpdate:
.1cd4	a2 ff		ldx #$ff			ldx 	#$FF
.1cd6	4c 4f 08	jmp $084f			jmp 	NextCommand
.056d					ramBank:
>056d							.fill 	1
.056e					romBank:
>056e							.fill 	1
.1cd9					XPrintCharacterToChannel:
.1cd9	48		pha				pha
.1cda	da		phx				phx
.1cdb	5a		phy				phy
.1cdc	48		pha				pha  								; save char
.1cdd	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1cdf	d0 05		bne $1ce6			bne 	_XPCNotDefault
.1ce1	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1ce4	80 08		bra $1cee			bra 	_XPCSend
.1ce6					_XPCNotDefault:
.1ce6	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1ce9	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1cec	d0 08		bne $1cf6			bne 	_XPCError
.1cee					_XPCSend:
.1cee	68		pla				pla 								; restore character
.1cef	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1cf2	7a		ply				ply
.1cf3	fa		plx				plx
.1cf4	68		pla				pla
.1cf5	60		rts				rts
.1cf6					_XPCError:
.1cf6	4c 58 20	jmp $2058		jmp	ErrorV_channel
.1cf9					XReadClock:
.1cf9	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1cfc	60		rts				rts
.1cfd					XWriteClock:
.1cfd	48		pha				pha
.1cfe	da		phx				phx
.1cff	5a		phy				phy
.1d00	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1d03	7a		ply				ply
.1d04	fa		plx				plx
.1d05	68		pla				pla
.1d06	60		rts				rts
.1d07					CommandScreen:
.1d07	fa		plx				plx
.1d08	da		phx				phx
.1d09	5a		phy				phy
.1d0a	20 47 10	jsr $1047			jsr 	GetInteger8Bit
.1d0d	18		clc				clc
.1d0e	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1d11	7a		ply				ply
.1d12	fa		plx				plx
.1d13	ca		dex				dex
.1d14	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d17					XCommandSleep:
.1d17	fa		plx				plx
.1d18	5a		phy				phy
.1d19	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.1d1c	ca		dex				dex
.1d1d	20 f9 1c	jsr $1cf9			jsr 	XReadClock 					; read clock to YXA
.1d20	18		clc				clc 								; calculate end time in zTemp0
.1d21	65 3e		adc $3e				adc 	NSMantissa0
.1d23	85 2c		sta $2c				sta 	zTemp0
.1d25	8a		txa				txa
.1d26	65 4a		adc $4a				adc 	NSMantissa1
.1d28	85 2d		sta $2d				sta 	zTemp0+1
.1d2a					_XCWait:
.1d2a	20 f9 1c	jsr $1cf9			jsr 	XReadClock 					; and wait for it.
.1d2d	c5 2c		cmp $2c				cmp 	zTemp0
.1d2f	d0 f9		bne $1d2a			bne 	_XCWait
.1d31	e4 2d		cpx $2d				cpx 	zTemp0+1
.1d33	d0 f5		bne $1d2a			bne 	_XCWait
.1d35	a2 ff		ldx #$ff			ldx 	#$FF
.1d37	7a		ply				ply
.1d38	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d3b					X16_Audio_FMINIT:
.1d3b	fa		plx				plx
.1d3c	5a		phy			phy
.1d3d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d40	63 c0					.word	X16A_ym_init
>1d42	0a					.byte	X16_AudioCodeBank
.1d43	a2 ff		ldx #$ff		ldx	#$FF
.1d45	7a		ply			ply
.1d46	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d49					X16_Audio_FMNOTE:
.1d49	fa		plx				plx
.1d4a	5a		phy			phy
.1d4b	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d4e	18		clc			clc
.1d4f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d52	03 c0					.word	X16A_bas_fmnote
>1d54	0a					.byte	X16_AudioCodeBank
.1d55	a2 ff		ldx #$ff		ldx	#$FF
.1d57	7a		ply			ply
.1d58	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d5b					X16_Audio_FMDRUM:
.1d5b	fa		plx				plx
.1d5c	5a		phy			phy
.1d5d	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d60	18		clc			clc
.1d61	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d64	6f c0					.word	X16A_ym_playdrum
>1d66	0a					.byte	X16_AudioCodeBank
.1d67	a2 ff		ldx #$ff		ldx	#$FF
.1d69	7a		ply			ply
.1d6a	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d6d					X16_Audio_FMINST:
.1d6d	fa		plx				plx
.1d6e	5a		phy			phy
.1d6f	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d72	38		sec			sec
.1d73	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d76	69 c0					.word	X16A_ym_loadpatch
>1d78	0a					.byte	X16_AudioCodeBank
.1d79	a2 ff		ldx #$ff		ldx	#$FF
.1d7b	7a		ply			ply
.1d7c	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d7f					X16_Audio_FMVIB:
.1d7f	fa		plx				plx
.1d80	5a		phy			phy
.1d81	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d84	18		clc			clc
.1d85	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d88	09 c0					.word	X16A_bas_fmvib
>1d8a	0a					.byte	X16_AudioCodeBank
.1d8b	a2 ff		ldx #$ff		ldx	#$FF
.1d8d	7a		ply			ply
.1d8e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d91					X16_Audio_FMFREQ:
.1d91	fa		plx				plx
.1d92	5a		phy			phy
.1d93	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1d96	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d99	00 c0					.word	X16A_bas_fmfreq
>1d9b	0a					.byte	X16_AudioCodeBank
.1d9c	a2 ff		ldx #$ff		ldx	#$FF
.1d9e	7a		ply			ply
.1d9f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1da2					X16_Audio_FMVOL:
.1da2	fa		plx				plx
.1da3	5a		phy			phy
.1da4	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1da7	18		clc			clc
.1da8	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dab	75 c0					.word	X16A_ym_setatten
>1dad	0a					.byte	X16_AudioCodeBank
.1dae	a2 ff		ldx #$ff		ldx	#$FF
.1db0	7a		ply			ply
.1db1	4c 4f 08	jmp $084f			jmp 	NextCommand
.1db4					X16_Audio_FMPAN:
.1db4	fa		plx				plx
.1db5	5a		phy			phy
.1db6	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1db9	18		clc			clc
.1dba	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dbd	7e c0					.word	X16A_ym_setpan
>1dbf	0a					.byte	X16_AudioCodeBank
.1dc0	a2 ff		ldx #$ff		ldx	#$FF
.1dc2	7a		ply			ply
.1dc3	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dc6					X16_Audio_FMPLAY:
.1dc6	fa		plx				plx
.1dc7	5a		phy			phy
.1dc8	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1dcb	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dce	06 c0					.word	X16A_bas_fmplaystring
>1dd0	0a					.byte	X16_AudioCodeBank
.1dd1	a2 ff		ldx #$ff		ldx	#$FF
.1dd3	7a		ply			ply
.1dd4	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dd7					X16_Audio_FMCHORD:
.1dd7	fa		plx				plx
.1dd8	5a		phy			phy
.1dd9	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1ddc	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1ddf	8d c0					.word	X16A_bas_fmchordstring
>1de1	0a					.byte	X16_AudioCodeBank
.1de2	a2 ff		ldx #$ff		ldx	#$FF
.1de4	7a		ply			ply
.1de5	4c 4f 08	jmp $084f			jmp 	NextCommand
.1de8					X16_Audio_FMPOKE:
.1de8	fa		plx				plx
.1de9	5a		phy			phy
.1dea	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1ded	18		clc			clc
.1dee	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1df1	8a c0					.word	X16A_ym_write
>1df3	0a					.byte	X16_AudioCodeBank
.1df4	a2 ff		ldx #$ff		ldx	#$FF
.1df6	7a		ply			ply
.1df7	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dfa					X16_Audio_PSGINIT:
.1dfa	fa		plx				plx
.1dfb	5a		phy			phy
.1dfc	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dff	4b c0					.word	X16A_psg_init
>1e01	0a					.byte	X16_AudioCodeBank
.1e02	a2 ff		ldx #$ff		ldx	#$FF
.1e04	7a		ply			ply
.1e05	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e08					X16_Audio_PSGNOTE:
.1e08	fa		plx				plx
.1e09	5a		phy			phy
.1e0a	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e0d	18		clc			clc
.1e0e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e11	12 c0					.word	X16A_bas_psgnote
>1e13	0a					.byte	X16_AudioCodeBank
.1e14	a2 ff		ldx #$ff		ldx	#$FF
.1e16	7a		ply			ply
.1e17	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e1a					X16_Audio_PSGVOL:
.1e1a	fa		plx				plx
.1e1b	5a		phy			phy
.1e1c	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e1f	18		clc			clc
.1e20	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e23	54 c0					.word	X16A_psg_setatten
>1e25	0a					.byte	X16_AudioCodeBank
.1e26	a2 ff		ldx #$ff		ldx	#$FF
.1e28	7a		ply			ply
.1e29	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e2c					X16_Audio_PSGWAV:
.1e2c	fa		plx				plx
.1e2d	5a		phy			phy
.1e2e	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e31	18		clc			clc
.1e32	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e35	15 c0					.word	X16A_bas_psgwav
>1e37	0a					.byte	X16_AudioCodeBank
.1e38	a2 ff		ldx #$ff		ldx	#$FF
.1e3a	7a		ply			ply
.1e3b	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e3e					X16_Audio_PSGFREQ:
.1e3e	fa		plx				plx
.1e3f	5a		phy			phy
.1e40	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1e43	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e46	0f c0					.word	X16A_bas_psgfreq
>1e48	0a					.byte	X16_AudioCodeBank
.1e49	a2 ff		ldx #$ff		ldx	#$FF
.1e4b	7a		ply			ply
.1e4c	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e4f					X16_Audio_PSGPAN:
.1e4f	fa		plx				plx
.1e50	5a		phy			phy
.1e51	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e54	18		clc			clc
.1e55	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e58	5a c0					.word	X16A_psg_setpan
>1e5a	0a					.byte	X16_AudioCodeBank
.1e5b	a2 ff		ldx #$ff		ldx	#$FF
.1e5d	7a		ply			ply
.1e5e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e61					X16_Audio_PSGPLAY:
.1e61	fa		plx				plx
.1e62	5a		phy			phy
.1e63	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e66	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e69	18 c0					.word	X16A_bas_psgplaystring
>1e6b	0a					.byte	X16_AudioCodeBank
.1e6c	a2 ff		ldx #$ff		ldx	#$FF
.1e6e	7a		ply			ply
.1e6f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e72					X16_Audio_PSGCHORD:
.1e72	fa		plx				plx
.1e73	5a		phy			phy
.1e74	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e77	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e7a	90 c0					.word	X16A_bas_psgchordstring
>1e7c	0a					.byte	X16_AudioCodeBank
.1e7d	a2 ff		ldx #$ff		ldx	#$FF
.1e7f	7a		ply			ply
.1e80	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e83					CommandCls:
.1e83	fa		plx				plx
.1e84	a9 93		lda #$93			lda 	#147
.1e86	20 d9 1c	jsr $1cd9			jsr 	XPrintCharacterToChannel
.1e89	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e8c					CommandLocate:
.1e8c	fa		plx				plx
.1e8d	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.1e90	ca		dex				dex
.1e91	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.1e94	ca		dex				dex
.1e95	48		pha				pha 								; save registers
.1e96	da		phx				phx
.1e97	5a		phy				phy
.1e98	18		clc				clc
.1e99	a4 3f		ldy $3f				ldy 	NSMantissa0+1 				; get coords
.1e9b	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e9d	88		dey				dey 								; fix up
.1e9e	ca		dex				dex
.1e9f	20 f0 ff	jsr $fff0			jsr 	$FFF0 						; PLOT
.1ea2	7a		ply				ply 								; restore registers
.1ea3	fa		plx				plx
.1ea4	68		pla				pla
.1ea5	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ea8					_CLOutputXA:
.1ea8	ca		dex				dex
.1ea9	f0 07		beq $1eb2			beq 	_CLOExit
.1eab	30 05		bmi $1eb2			bmi 	_CLOExit
.1ead	20 d9 1c	jsr $1cd9			jsr 	XPrintCharacterToChannel
.1eb0	80 f6		bra $1ea8			bra 	_CLOutputXA
.1eb2					_CLOExit:
.1eb2	60		rts				rts
.1eb3					CommandColor:
.1eb3	fa		plx				plx
.1eb4	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.1eb7	ca		dex				dex
.1eb8	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.1ebb	ca		dex				dex
.1ebc	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1ebe	c9 ff		cmp #$ff			cmp 	#$FF
.1ec0	f0 08		beq $1eca			beq 	_CCNoBGR 					; if so, change background
.1ec2	20 d2 1e	jsr $1ed2			jsr 	_CCSetColour
.1ec5	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1ec7	20 d9 1c	jsr $1cd9			jsr 	XPrintCharacterToChannel
.1eca					_CCNoBGR:
.1eca	a5 3e		lda $3e				lda 	NSMantissa0
.1ecc	20 d2 1e	jsr $1ed2			jsr 	_CCSetColour
.1ecf	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ed2					_CCSetColour:
.1ed2	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1ed4	aa		tax				tax
.1ed5	bd dc 1e	lda $1edc,x			lda 	_CCCommandTable,x
.1ed8	20 d9 1c	jsr $1cd9			jsr 	XPrintCharacterToChannel
.1edb	60		rts				rts
.1edc					_CCCommandTable:
>1edc	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1ee4	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1eec					CommandVPOKE:
.1eec	fa		plx				plx
.1eed	20 47 10	jsr $1047			jsr 	GetInteger8Bit 				; poke value
.1ef0	48		pha				pha
.1ef1	ca		dex				dex
.1ef2	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.1ef5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ef7	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1efa	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1efc	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1eff	ca		dex				dex
.1f00	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.1f03	20 47 10	jsr $1047			jsr 	GetInteger8Bit
.1f06	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1f09	ca		dex				dex
.1f0a	68		pla				pla 								; poke value back
.1f0b	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1f0e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1f11					CommandVPEEK:
.1f11	fa		plx				plx
.1f12	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.1f15	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1f17	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1f1a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1f1c	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1f1f	ca		dex				dex
.1f20	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.1f23	20 47 10	jsr $1047			jsr 	GetInteger8Bit
.1f26	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1f29	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1f2c	20 b3 26	jsr $26b3			jsr 	FloatSetByte 				; return as byte
.1f2f	4c 4f 08	jmp $084f			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ff					C64_PI                   = $ff ; $ff pi
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ceb7					C64_BANNER               = $ceb7 ; $ceb7 banner
=$ceb8					C64_EXEC                 = $ceb8 ; $ceb8 exec
=$ceb9					C64_TILE                 = $ceb9 ; $ceb9 tile
=$ceba					C64_EDIT                 = $ceba ; $ceba edit
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$cedb					C64_MWHEEL               = $cedb ; $cedb mwheel
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$cb					PCD_ENDCOMMAND = $cb
=$cb					PCD_STARTSYSTEM = $cb
=$d7					PCD_ENDSYSTEM = $d7
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_PI               = $ac ; pi
=$ad					PCD_POKE             = $ad ; poke
=$ae					PCD_POS              = $ae ; pos
=$af					PCD_GETCHANNEL       = $af ; getchannel
=$b0					PCD_SETCHANNEL       = $b0 ; setchannel
=$b1					PCD_PRINTCMD_N       = $b1 ; print.n
=$b2					PCD_PRINTCMD_S       = $b2 ; print.s
=$b3					PCD_READ             = $b3 ; read
=$b4					PCD_READDOLLAR       = $b4 ; read$
=$b5					PCD_RND              = $b5 ; rnd
=$b6					PCD_CONCAT           = $b6 ; concat
=$b7					PCD_SGN              = $b7 ; sgn
=$b8					PCD_PRINTCMD_TAB     = $b8 ; print.tab
=$b9					PCD_PRINTCMD_POS     = $b9 ; print.pos
=$ba					PCD_PRINTCMD_SPC     = $ba ; print.spc
=$bb					PCD_STRDOLLAR        = $bb ; str$
=$bc					PCD_LEFTDOLLAR       = $bc ; left$
=$bd					PCD_RIGHTDOLLAR      = $bd ; right$
=$be					PCD_MIDDOLLAR        = $be ; mid$
=$bf					PCD_SWAP             = $bf ; swap
=$c0					PCD_TI               = $c0 ; ti
=$c1					PCD_TIDOLLAR         = $c1 ; ti$
=$c2					PCD_USR              = $c2 ; usr
=$c3					PCD_VAL              = $c3 ; val
=$c4					PCD_CLOSE            = $c4 ; close
=$c5					PCD_EXIT             = $c5 ; exit
=$c6					PCD_DEBUG            = $c6 ; debug
=$c7					PCD_OPEN             = $c7 ; open
=$c8					PCD_SCREEN           = $c8 ; screen
=$c9					PCD_VPOKE            = $c9 ; vpoke
=$ca					PCD_VPEEK            = $ca ; vpeek
=$cb					PCD_CMD_SHIFT        = $cb ; .shift
=$cc					PCD_CMD_BYTE         = $cc ; .byte
=$cd					PCD_CMD_WORD         = $cd ; .word
=$ce					PCD_CMD_FLOAT        = $ce ; .float
=$cf					PCD_CMD_STRING       = $cf ; .string
=$d0					PCD_CMD_DATA         = $d0 ; .data
=$d1					PCD_CMD_GOTO         = $d1 ; .goto
=$d2					PCD_CMD_GOSUB        = $d2 ; .gosub
=$d3					PCD_CMD_GOTOCMD_Z    = $d3 ; .goto.z
=$d4					PCD_CMD_GOTOCMD_NZ   = $d4 ; .goto.nz
=$d5					PCD_CMD_VARSPACE     = $d5 ; .varspace
=$d6					PCD_CMD_RESTORE      = $d6 ; .restore
=$cb80					PCD_CLR              = $cb80 ; clr
=$cb81					PCD_DIM              = $cb81 ; dim
=$cb82					PCD_END              = $cb82 ; end
=$cb83					PCD_JOY              = $cb83 ; joy
=$cb84					PCD_INT              = $cb84 ; int
=$cb85					PCD_SQR              = $cb85 ; sqr
=$cb86					PCD_LOG              = $cb86 ; log
=$cb87					PCD_EXP              = $cb87 ; exp
=$cb88					PCD_COS              = $cb88 ; cos
=$cb89					PCD_SIN              = $cb89 ; sin
=$cb8a					PCD_TAN              = $cb8a ; tan
=$cb8b					PCD_ATN              = $cb8b ; atn
=$cb8c					PCD_MOUSE            = $cb8c ; mouse
=$cb8d					PCD_MB               = $cb8d ; mb
=$cb8e					PCD_MX               = $cb8e ; mx
=$cb8f					PCD_MY               = $cb8f ; my
=$cb90					PCD_MWHEEL           = $cb90 ; mwheel
=$cb91					PCD_STOP             = $cb91 ; stop
=$cb92					PCD_SYS              = $cb92 ; sys
=$cb93					PCD_TICMD_WRITE      = $cb93 ; ti.write
=$cb94					PCD_TIDOLLARCMD_WRITE = $cb94 ; ti$.write
=$cb95					PCD_WAIT             = $cb95 ; wait
=$cb96					PCD_I2CPOKE          = $cb96 ; i2cpoke
=$cb97					PCD_I2CPEEK          = $cb97 ; i2cpeek
=$cb98					PCD_BANK             = $cb98 ; bank
=$cb99					PCD_SLEEP            = $cb99 ; sleep
=$cb9a					PCD_FMINIT           = $cb9a ; fminit
=$cb9b					PCD_FMNOTE           = $cb9b ; fmnote
=$cb9c					PCD_FMDRUM           = $cb9c ; fmdrum
=$cb9d					PCD_FMINST           = $cb9d ; fminst
=$cb9e					PCD_FMVIB            = $cb9e ; fmvib
=$cb9f					PCD_FMFREQ           = $cb9f ; fmfreq
=$cba0					PCD_FMVOL            = $cba0 ; fmvol
=$cba1					PCD_FMPAN            = $cba1 ; fmpan
=$cba2					PCD_FMPLAY           = $cba2 ; fmplay
=$cba3					PCD_FMCHORD          = $cba3 ; fmchord
=$cba4					PCD_FMPOKE           = $cba4 ; fmpoke
=$cba5					PCD_PSGINIT          = $cba5 ; psginit
=$cba6					PCD_PSGNOTE          = $cba6 ; psgnote
=$cba7					PCD_PSGVOL           = $cba7 ; psgvol
=$cba8					PCD_PSGWAV           = $cba8 ; psgwav
=$cba9					PCD_PSGFREQ          = $cba9 ; psgfreq
=$cbaa					PCD_PSGPAN           = $cbaa ; psgpan
=$cbab					PCD_PSGPLAY          = $cbab ; psgplay
=$cbac					PCD_PSGCHORD         = $cbac ; psgchord
=$cbad					PCD_CLS              = $cbad ; cls
=$cbae					PCD_LOCATE           = $cbae ; locate
=$cbaf					PCD_COLOR            = $cbaf ; color
.1f32					SetErrorHandler:
.1f32	8c 70 05	sty $0570			sty 	ErrorHandlerVector+1
.1f35	8e 6f 05	stx $056f			stx 	ErrorHandlerVector
.1f38	60		rts				rts
.1f39					CallErrorHandler:
.1f39	6c 6f 05	jmp ($056f)			jmp 	(ErrorHandlerVector)
.056f					ErrorHandlerVector:
>056f							.fill 	2
.1f3c					ErrorV_range:
.1f3c	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>1f3f	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f47	41 4e 47 45 00
.1f4c					ErrorV_value:
.1f4c	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>1f4f	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f57	45 00
.1f59					ErrorV_syntax:
.1f59	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>1f5c	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f64	52 52 4f 52 00
.1f69					ErrorV_type:
.1f69	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>1f6c	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f74	4d 41 54 43 48 00
.1f7a					ErrorV_unimplemented:
.1f7a	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>1f7d	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f85	45 4d 45 4e 54 45 44 00
.1f8d					ErrorV_assert:
.1f8d	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>1f90	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f98	41 49 4c 00
.1f9c					ErrorV_line:
.1f9c	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>1f9f	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1fa7	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1fb3					ErrorV_internal:
.1fb3	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>1fb6	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1fbe	20 45 52 52 4f 52 00
.1fc5					ErrorV_divzero:
.1fc5	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>1fc8	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fd0	59 20 5a 45 52 4f 00
.1fd7					ErrorV_structure:
.1fd7	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>1fda	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fe2	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fee					ErrorV_stop:
.1fee	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>1ff1	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1ff9	53 54 4f 50 50 45 44 00
.2001					ErrorV_data:
.2001	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>2004	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>200c	41 54 41 00
.2010					ErrorV_undeclared:
.2010	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>2013	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>201b	41 52 52 41 59 00
.2021					ErrorV_redefine:
.2021	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>2024	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>202c	44 45 46 49 4e 45 44 00
.2034					ErrorV_index:
.2034	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>2037	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>203f	59 20 49 4e 44 45 58 00
.2047					ErrorV_memory:
.2047	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>204a	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2052	45 4d 4f 52 59 00
.2058					ErrorV_channel:
.2058	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>205b	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2063	54 50 55 54 20 45 52 52 4f 52 00
.206e					ErrorV_break:
.206e	20 39 1f	jsr $1f39		jsr	CallErrorHandler
>2071	42 52 45 41 4b 20 50 52			.text	"BREAK PRESSED",0
>2079	45 53 53 45 44 00
.207f					MoveObjectForward:
.207f	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.2081	c9 ff		cmp #$ff			cmp 	#$FF
.2083	f0 36		beq $20bb			beq 	_MOFEnd
.2085	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.2087	90 24		bcc $20ad			bcc 	_MOFAdvance1 				; forward 1
.2089	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.208b	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.208d	90 20		bcc $20af			bcc 	_MOFAdvanceY
.208f	c9 cb		cmp #$cb			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2091	90 1a		bcc $20ad			bcc 	_MOFAdvance1 				; forward 1
.2093	a8		tay				tay 								; read the size.
.2094	b9 f8 1f	lda $1ff8,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.2097	a8		tay				tay
.2098	c8		iny				iny 								; add 1 for the system token.
.2099	d0 14		bne $20af			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.209b	a0 01		ldy #$01			ldy 	#1 							; get length byte
.209d	b1 2a		lda ($2a),y			lda 	(objPtr),y
.209f	a8		tay				tay 								; into Y.
.20a0	18		clc				clc
.20a1	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.20a3	69 02		adc #$02			adc 	#2
.20a5	85 2a		sta $2a				sta 	objPtr
.20a7	90 02		bcc $20ab			bcc 	_MOFNoCarry1
.20a9	e6 2b		inc $2b				inc 	objPtr+1
.20ab					_MOFNoCarry1:
.20ab	80 02		bra $20af			bra 	_MOFAdvanceY
.20ad					_MOFAdvance1:
.20ad	a0 01		ldy #$01			ldy 	#1
.20af					_MOFAdvanceY:
.20af	98		tya				tya 								; add Y to objPtr
.20b0	18		clc				clc
.20b1	65 2a		adc $2a				adc 	objPtr
.20b3	85 2a		sta $2a				sta 	objPtr
.20b5	90 02		bcc $20b9			bcc 	_MOFNoCarry2
.20b7	e6 2b		inc $2b				inc 	objPtr+1
.20b9					_MOFNoCarry2:
.20b9	18		clc				clc 								; not completed.
.20ba	60		rts				rts
.20bb					_MOFEnd:
.20bb	e6 2a		inc $2a				inc 	objPtr
.20bd	d0 02		bne $20c1			bne 	_MOFENoCarry
.20bf	e6 2b		inc $2b				inc 	objPtr+1
.20c1					_MOFENoCarry:
.20c1	38		sec				sec
.20c2	60		rts				rts
.20c3					MOFSizeTable:
>20c3	01					.byte	1         	; $cb .shift
>20c4	01					.byte	1         	; $cc .byte
>20c5	02					.byte	2         	; $cd .word
>20c6	05					.byte	5         	; $ce .float
>20c7	ff					.byte	255       	; $cf .string
>20c8	ff					.byte	255       	; $d0 .data
>20c9	02					.byte	2         	; $d1 .goto
>20ca	02					.byte	2         	; $d2 .gosub
>20cb	02					.byte	2         	; $d3 .goto.z
>20cc	02					.byte	2         	; $d4 .goto.nz
>20cd	02					.byte	2         	; $d5 .varspace
>20ce	02					.byte	2         	; $d6 .restore

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0571					numberBuffer:
>0571							.fill 	34
.20cf					FloatSubtract:
.20cf	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.20d1	49 80		eor #$80			eor 	#$80
.20d3	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.20d5					FloatAdd:
.20d5	ca		dex				dex
.20d6	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.20d8	15 6f		ora $6f,x			ora 	NSExponent+1,x
.20da	15 62		ora $62,x			ora 	NSMantissa3,x
.20dc	15 63		ora $63,x			ora 	NSMantissa3+1,x
.20de	d0 04		bne $20e4			bne 	_FAUseFloat
.20e0	20 71 24	jsr $2471			jsr 	FloatInt32Add 				; use the int32 one.
.20e3	60		rts				rts
.20e4					_FAUseFloat:
.20e4	20 06 24	jsr $2406			jsr 	FloatNormalise 				; normalise S[X]
.20e7	f0 51		beq $213a			beq 	_FAReturn1
.20e9	e8		inx				inx 								; normalise S[X+1]
.20ea	20 06 24	jsr $2406			jsr 	FloatNormalise
.20ed	ca		dex				dex
.20ee	c9 00		cmp #$00			cmp 	#0
.20f0	f0 60		beq $2152			beq 	_FAExit 					; if so, just return A
.20f2	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20f4	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20f6	f0 18		beq $2110			beq 	_FAExponentsEqual
.20f8	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20fa	a8		tay				tay
.20fb	38		sec				sec 								; do a signed comparison of the exponents.
.20fc	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20fe	50 02		bvc $2102			bvc 	_FANoSignedChange
.2100	49 80		eor #$80			eor 	#$80
.2102					_FANoSignedChange:
.2102	29 80		and #$80			and 	#$80
.2104	10 02		bpl $2108			bpl 	_FAHaveMax
.2106	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.2108					_FAHaveMax:
.2108	20 53 21	jsr $2153			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.210b	e8		inx				inx
.210c	20 53 21	jsr $2153			jsr 	_FAShiftToExponent
.210f	ca		dex				dex
.2110					_FAExponentsEqual:
.2110	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.2112	55 33		eor $33,x			eor 	NSStatus+1,x
.2114	30 0e		bmi $2124			bmi 	_FADifferentSigns
.2116	20 3d 24	jsr $243d			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.2119	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.211b	10 35		bpl $2152			bpl 	_FAExit 					; if no, we are done.
.211d	20 ca 26	jsr $26ca			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.2120	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.2122	80 2e		bra $2152			bra 	_FAExit
.2124					_FADifferentSigns:
.2124	20 57 24	jsr $2457			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.2127	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.2129	10 06		bpl $2131			bpl 	_FACheckZero 				; if no, check for -0
.212b	20 73 26	jsr $2673			jsr 	FloatNegate 					; netate result
.212e	20 7a 26	jsr $267a			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.2131					_FACheckZero:
.2131	20 d3 26	jsr $26d3			jsr 	FloatIsZero	 				; check for -0
.2134	d0 1c		bne $2152			bne 	_FAExit
.2136	74 32		stz $32,x			stz 	NSStatus,x
.2138	80 18		bra $2152			bra 	_FAExit
.213a					_FAReturn1:
.213a	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.213c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.213e	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2140	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2142	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.2144	95 56		sta $56,x			sta 	NSMantissa2,x
.2146	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.2148	95 62		sta $62,x			sta 	NSMantissa3,x
.214a	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.214c	95 6e		sta $6e,x			sta 	NSExponent,x
.214e	b5 33		lda $33,x			lda 	NSStatus+1,x
.2150	95 32		sta $32,x			sta 	NSStatus,x
.2152					_FAExit:
.2152	60		rts				rts
.2153					_FAShiftToExponent:
.2153					_FAShiftToExponent2:
.2153	98		tya				tya 								; compare Y to exponent
.2154	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2156	f0 07		beq $215f			beq 	_FASEExit 					; exit if so.
.2158	20 ca 26	jsr $26ca			jsr 	FloatShiftRight	 			; shift the mantissa right
.215b	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.215d	80 f4		bra $2153			bra 	_FAShiftToExponent2
.215f					_FASEExit:
.215f	60		rts				rts
.2160					CompareEqual:
.2160	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2162	d0 09		bne $216d			bne 	ReturnFalse
.2164					ReturnTrue:
.2164	a9 01		lda #$01			lda 	#1
.2166	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2168	a9 80		lda #$80			lda 	#$80
.216a	95 32		sta $32,x			sta 	NSStatus,x
.216c	60		rts				rts
.216d					ReturnFalse:
.216d	74 3e		stz $3e,x			stz 	NSMantissa0,x
.216f	60		rts				rts
.2170					CompareNotEqual:
.2170	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2172	d0 f0		bne $2164			bne 	ReturnTrue
.2174	80 f7		bra $216d			bra 	ReturnFalse
.2176					CompareLess:
.2176	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2178	c9 ff		cmp #$ff			cmp 	#$FF
.217a	f0 e8		beq $2164			beq 	ReturnTrue
.217c	80 ef		bra $216d			bra 	ReturnFalse
.217e					CompareGreater:
.217e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2180	c9 01		cmp #$01			cmp 	#$01
.2182	f0 e0		beq $2164			beq 	ReturnTrue
.2184	80 e7		bra $216d			bra 	ReturnFalse
.2186					CompareLessEqual:
.2186	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2188	c9 01		cmp #$01			cmp 	#$01
.218a	d0 d8		bne $2164			bne 	ReturnTrue
.218c	80 df		bra $216d			bra 	ReturnFalse
.218e					CompareGreaterEqual:
.218e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2190	c9 ff		cmp #$ff			cmp 	#$FF
.2192	d0 d0		bne $2164			bne 	ReturnTrue
.2194	80 d7		bra $216d			bra 	ReturnFalse
.2196					FloatCompare:
.2196	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.2198	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.219a	48		pha				pha
.219b	20 cf 20	jsr $20cf			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.219e	68		pla				pla
.219f	d0 0c		bne $21ad			bne 	_FCCompareFloat
.21a1	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.21a3	15 4a		ora $4a,x			ora 	NSMantissa1,x
.21a5	15 56		ora $56,x			ora 	NSMantissa2,x
.21a7	15 62		ora $62,x			ora 	NSMantissa3,x
.21a9	f0 14		beq $21bf			beq 	_FCExit 					; if zero, return zero
.21ab	80 0a		bra $21b7			bra 	_FCSign
.21ad					_FCCompareFloat:
.21ad	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.21af	29 f0		and #$f0			and 	#$F0
.21b1	15 56		ora $56,x			ora 	NSMantissa2,x
.21b3	15 62		ora $62,x			ora 	NSMantissa3,x
.21b5	f0 08		beq $21bf			beq 	_FCExit 					; zero, so approximately identical
.21b7					_FCSign:
.21b7	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.21b9	34 32		bit $32,x			bit 	NSStatus,x
.21bb	10 02		bpl $21bf			bpl 	_FCExit
.21bd					_FCNegative:
.21bd	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.21bf					_FCExit:
.21bf	20 b3 26	jsr $26b3			jsr 	FloatSetByte 				; set the result 255,0,1
.21c2	60		rts				rts
.21c3					FloatScalarTable:
>21c3	66 66 66 66				.dword $66666666 ; 0.1
>21c7	de					.byte $de
>21c8	1f 85 eb 51				.dword $51eb851f ; 0.01
>21cc	db					.byte $db
>21cd	4c 37 89 41				.dword $4189374c ; 0.001
>21d1	d8					.byte $d8
>21d2	ac 8b db 68				.dword $68db8bac ; 0.0001
>21d6	d4					.byte $d4
>21d7	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>21db	d1					.byte $d1
>21dc	83 de 1b 43				.dword $431bde83 ; 1e-06
>21e0	ce					.byte $ce
>21e1	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21e5	ca					.byte $ca
>21e6	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21ea	c7					.byte $c7
>21eb	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21ef	c4					.byte $c4
>21f0	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21f4	c0					.byte $c0
>21f5	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21f9	bd					.byte $bd
.21fa					FloatDivide:
.21fa	48		pha				pha
.21fb	20 06 24	jsr $2406			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21fe	ca		dex				dex
.21ff	c9 00		cmp #$00			cmp 	#0
.2201	f0 1e		beq $2221			beq 	_FDZero
.2203	20 06 24	jsr $2406			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2206	f0 16		beq $221e			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.2208	20 69 22	jsr $2269			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.220b	20 36 22	jsr $2236			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.220e	20 06 24	jsr $2406			jsr		FloatNormalise 				; renormalise
.2211	20 fc 23	jsr $23fc			jsr 	FloatCalculateSign 			; calculate result sign
.2214	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.2216	38		sec				sec
.2217	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.2219	38		sec				sec
.221a	e9 1e		sbc #$1e			sbc 	#30
.221c	95 6e		sta $6e,x			sta 	NSExponent,x
.221e					_FDExit:
.221e	68		pla				pla
.221f	18		clc				clc
.2220	60		rts				rts
.2221					_FDZero:
.2221	68		pla				pla
.2222	38		sec				sec
.2223	60		rts				rts
.2224					DivideInt32:
.2224	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart 			; make both integers
.2227	ca		dex				dex
.2228	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.222b	20 47 22	jsr $2247			jsr 	Int32Divide 				; divide
.222e	20 36 22	jsr $2236			jsr 	NSMCopyPlusTwoToZero 		; copy result
.2231	20 fc 23	jsr $23fc			jsr 	FloatCalculateSign 			; calculate result sign
.2234	18		clc				clc
.2235	60		rts				rts
.2236					NSMCopyPlusTwoToZero:
.2236	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.2238	95 3e		sta $3e,x			sta 	NSMantissa0,x
.223a	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.223c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.223e	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.2240	95 56		sta $56,x			sta 	NSMantissa2,x
.2242	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.2244	95 62		sta $62,x			sta 	NSMantissa3,x
.2246	60		rts				rts
.2247					Int32Divide:
.2247	48		pha				pha 								; save AXY
.2248	5a		phy				phy
.2249	20 94 26	jsr $2694			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.224c	20 ad 26	jsr $26ad			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.224f	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2251					_I32DivideLoop:
.2251	e8		inx				inx
.2252	e8		inx				inx
.2253	20 c0 26	jsr $26c0			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2256	ca		dex				dex
.2257	ca		dex				dex
.2258	20 c1 26	jsr $26c1			jsr 	FloatRotateLeft
.225b	20 87 22	jsr $2287			jsr 	FloatDivideCheck 			; check if subtract possible
.225e	90 02		bcc $2262			bcc 	_I32DivideNoCarryIn
.2260	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2262					_I32DivideNoCarryIn:
.2262	88		dey				dey 								; loop round till division completed.
.2263	d0 ec		bne $2251			bne 	_I32DivideLoop
.2265	7a		ply				ply 								; restore AXY and exit
.2266	68		pla				pla
.2267	18		clc				clc
.2268	60		rts				rts
.2269					Int32ShiftDivide:
.2269	48		pha				pha 								; save AY
.226a	5a		phy				phy
.226b	e8		inx				inx 								; clear S[X+2]
.226c	e8		inx				inx
.226d	20 b1 26	jsr $26b1			jsr 	FloatSetZero
.2270	ca		dex				dex
.2271	ca		dex				dex
.2272	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2274					_I32SDLoop:
.2274	20 87 22	jsr $2287			jsr 	FloatDivideCheck 			; check if subtract possible
.2277	e8		inx				inx
.2278	e8		inx				inx
.2279	20 c1 26	jsr $26c1			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.227c	ca		dex				dex
.227d	ca		dex				dex
.227e	20 c1 26	jsr $26c1			jsr 	FloatRotateLeft
.2281	88		dey				dey 	 							; do 31 times
.2282	d0 f0		bne $2274			bne 	_I32SDLoop
.2284	7a		ply				ply 								; restore AY and exit
.2285	68		pla				pla
.2286	60		rts				rts
.2287					FloatDivideCheck:
.2287	20 57 24	jsr $2457			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.228a	b0 04		bcs $2290			bcs 	_DCSExit 					; if carry set, then could do, exit
.228c	20 3d 24	jsr $243d			jsr 	FloatAddTopTwoStack 		; add it back in
.228f	18		clc				clc 								; and return False
.2290					_DCSExit:
.2290	60		rts				rts
.2291					FloatFractionalPart:
.2291	5a		phy				phy
.2292	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.2294	29 7f		and #$7f			and 	#$7F
.2296	95 32		sta $32,x			sta 	NSStatus,x
.2298	20 06 24	jsr $2406			jsr 	FloatNormalise
.229b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.229d	38		sec				sec
.229e	e9 e0		sbc #$e0			sbc 	#$E0
.22a0	90 29		bcc $22cb			bcc 	_FFPExit 					; already fractional
.22a2	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.22a4	b0 22		bcs $22c8			bcs 	_FFPZero
.22a6	a8		tay				tay 								; put count to do in Y
.22a7	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.22a9	20 d0 22	jsr $22d0			jsr 	_FFPPartial
.22ac	95 62		sta $62,x			sta 	NSMantissa3,x
.22ae	b5 56		lda $56,x			lda 	NSMantissa2,x
.22b0	20 d0 22	jsr $22d0			jsr 	_FFPPartial
.22b3	95 56		sta $56,x			sta 	NSMantissa2,x
.22b5	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.22b7	20 d0 22	jsr $22d0			jsr 	_FFPPartial
.22ba	95 4a		sta $4a,x			sta 	NSMantissa1,x
.22bc	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.22be	20 d0 22	jsr $22d0			jsr 	_FFPPartial
.22c1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.22c3	20 d3 26	jsr $26d3			jsr 	FloatIsZero 					; zeroed check.
.22c6	d0 03		bne $22cb			bne 	_FFPExit
.22c8					_FFPZero:
.22c8	20 b1 26	jsr $26b1			jsr 	FloatSetZero
.22cb					_FFPExit:
.22cb	20 06 24	jsr $2406			jsr 	FloatNormalise
.22ce	7a		ply				ply
.22cf	60		rts				rts
.22d0					_FFPPartial:
.22d0	c0 00		cpy #$00			cpy 	#0 							; no more to do
.22d2	f0 17		beq $22eb			beq 	_FFFPPExit
.22d4	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.22d6	b0 0c		bcs $22e4			bcs 	_FFFPPWholeByte
.22d8	5a		phy				phy
.22d9					_FFFPPLeft:
.22d9	0a		asl a				asl 	a
.22da	88		dey				dey
.22db	d0 fc		bne $22d9			bne 	_FFFPPLeft
.22dd	7a		ply				ply
.22de					_FFFPPRight:
.22de	4a		lsr a				lsr 	a
.22df	88		dey				dey
.22e0	d0 fc		bne $22de			bne 	_FFFPPRight
.22e2	80 07		bra $22eb			bra 	_FFFPPExit
.22e4					_FFFPPWholeByte:
.22e4	98		tya				tya 								; subtract 8 from count
.22e5	38		sec				sec
.22e6	e9 08		sbc #$08			sbc 	#8
.22e8	a8		tay				tay
.22e9	a9 00		lda #$00			lda 	#0 							; and clear all
.22eb					_FFFPPExit:
.22eb	60		rts				rts
.22ec					FloatIntegerPart:
.22ec	48		pha				pha
.22ed	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22ef	f0 1d		beq $230e			beq 	_FIPExit 					; if so do nothing
.22f1	20 d3 26	jsr $26d3			jsr 	FloatIsZero 				; is it zero ?
.22f4	f0 15		beq $230b			beq 	_FIPZero 					; if so return zero.
.22f6	20 06 24	jsr $2406			jsr 	FloatNormalise 				; normalise
.22f9	f0 10		beq $230b			beq 	_FIPZero 					; normalised to zero, exit zero
.22fb					_FIPShift:
.22fb	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22fd	10 07		bpl $2306			bpl 	_FIPCheckZero
.22ff	20 ca 26	jsr $26ca			jsr 	FloatShiftRight 			; shift mantissa right
.2302	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.2304	80 f5		bra $22fb			bra 	_FIPShift
.2306					_FIPCheckZero:
.2306	20 d3 26	jsr $26d3			jsr 	FloatIsZero 				; avoid -0 problem
.2309	d0 03		bne $230e			bne 	_FIPExit 					; set to zero if mantissa zero.
.230b					_FIPZero:
.230b	20 b1 26	jsr $26b1			jsr 	FloatSetZero
.230e					_FIPExit:
.230e	68		pla				pla
.230f	60		rts				rts
.2310					FloatIntegerPartDown:
.2310	48		pha				pha
.2311	5a		phy				phy
.2312	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.2314	f0 36		beq $234c			beq 	_FIPExit 					; if so do nothing
.2316	20 d3 26	jsr $26d3			jsr 	FloatIsZero 				; is it zero ?
.2319	f0 2e		beq $2349			beq 	_FIPZero 					; if so return zero.
.231b	20 06 24	jsr $2406			jsr 	FloatNormalise 				; normalise
.231e	f0 29		beq $2349			beq 	_FIPZero 					; normalised to zero, exit zero
.2320	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.2322					_FIPShift:
.2322	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2324	10 0a		bpl $2330			bpl 	_FIPCheckDown
.2326	20 ca 26	jsr $26ca			jsr 	FloatShiftRight 			; shift mantissa right
.2329	90 01		bcc $232c			bcc 	_FIPNoFrac 					; shifted a zero out ?
.232b	c8		iny				iny
.232c					_FIPNoFrac:
.232c	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.232e	80 f2		bra $2322			bra 	_FIPShift
.2330					_FIPCheckDown:
.2330	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.2332	f0 10		beq $2344			beq 	_FIPCheckZero
.2334	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.2336	10 0c		bpl $2344			bpl 	_FIPCheckZero
.2338	e8		inx				inx 								; -ve so round *down*.
.2339	a9 01		lda #$01			lda 	#1
.233b	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.233e	20 73 26	jsr $2673			jsr 	FloatNegate
.2341	20 d5 20	jsr $20d5			jsr 	FloatAdd
.2344					_FIPCheckZero:
.2344	20 d3 26	jsr $26d3			jsr 	FloatIsZero 				; avoid -0 problem
.2347	d0 03		bne $234c			bne 	_FIPExit 					; set to zero if mantissa zero.
.2349					_FIPZero:
.2349	20 b1 26	jsr $26b1			jsr 	FloatSetZero
.234c					_FIPExit:
.234c	7a		ply				ply
.234d	68		pla				pla
.234e	60		rts				rts
.234f					FloatInt8Multiply:
.234f	5a		phy				phy
.2350	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2352	a8		tay				tay
.2353	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2355					_FI8MLoop:
.2355	98		tya				tya 								; shift right shifter right into carry
.2356	4a		lsr a				lsr 	a
.2357	a8		tay				tay
.2358	90 0d		bcc $2367			bcc 	_FI8MNoAdd
.235a	18		clc				clc
.235b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.235d	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.235f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2361	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2363	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.2365	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2367					_FI8MNoAdd:
.2367	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.2369	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.236b	c0 00		cpy #$00			cpy 	#0
.236d	d0 e6		bne $2355			bne 	_FI8MLoop 					; until right shifter zero.
.236f	7a		ply				ply
.2370	60		rts				rts
.2371					FloatMultiply:
.2371	ca		dex				dex
.2372	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.2374	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2376	15 62		ora $62,x			ora 	NSMantissa3,x
.2378	15 63		ora $63,x			ora 	NSMantissa3+1,x
.237a	d0 21		bne $239d			bne 	_FMUseFloat
.237c	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.237e	15 33		ora $33,x			ora 	NSStatus+1,x
.2380	29 80		and #$80			and 	#$80
.2382	15 62		ora $62,x			ora 	NSMantissa3,x
.2384	15 56		ora $56,x			ora 	NSMantissa2,x
.2386	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2388	15 63		ora $63,x			ora 	NSMantissa3+1,x
.238a	15 57		ora $57,x			ora 	NSMantissa2+1,x
.238c	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.238e	d0 04		bne $2394			bne 	_FMInt32
.2390	20 4f 23	jsr $234f			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2393	60		rts				rts
.2394					_FMInt32:
.2394	20 be 23	jsr $23be			jsr 	FloatMultiplyShort			; use the int32 one.
.2397	18		clc				clc 								; fix it up if gone out of range
.2398	75 6e		adc $6e,x			adc 	NSExponent,x
.239a	95 6e		sta $6e,x			sta 	NSExponent,x
.239c	60		rts				rts
.239d					_FMUseFloat:
.239d	20 06 24	jsr $2406			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.23a0	f0 18		beq $23ba			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.23a2	e8		inx				inx
.23a3	20 06 24	jsr $2406			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.23a6	ca		dex				dex
.23a7	c9 00		cmp #$00			cmp 	#0
.23a9	f0 0c		beq $23b7			beq 	_FDSetZero
.23ab	20 be 23	jsr $23be			jsr 	FloatMultiplyShort 			; calculate the result.
.23ae	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.23b0	18		clc				clc
.23b1	75 6f		adc $6f,x			adc 	NSExponent+1,x
.23b3	95 6e		sta $6e,x			sta 	NSExponent,x
.23b5	80 03		bra $23ba			bra 	_FDExit
.23b7					_FDSetZero:
.23b7	20 b1 26	jsr $26b1			jsr 	FloatSetZero 				; return 0
.23ba					_FDExit:
.23ba	20 06 24	jsr $2406			jsr 	FloatNormalise 				; normalise the result
.23bd	60		rts				rts
.23be					FloatMultiplyShort:
.23be	5a		phy				phy 								; save Y
.23bf	20 94 26	jsr $2694			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.23c2	20 ad 26	jsr $26ad			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.23c5	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.23c7					_I32MLoop:
.23c7	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.23c9	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.23cb	15 58		ora $58,x			ora 	NSMantissa2+2,x
.23cd	15 64		ora $64,x			ora 	NSMantissa3+2,x
.23cf	f0 25		beq $23f6			beq 	_I32MExit 					; exit if zero
.23d1	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.23d3	29 01		and #$01			and 	#1
.23d5	f0 0d		beq $23e4			beq 	_I32MNoAdd
.23d7	20 3d 24	jsr $243d			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.23da	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.23dc	10 06		bpl $23e4			bpl 	_I32MNoAdd
.23de					_I32ShiftRight:
.23de	20 ca 26	jsr $26ca			jsr 	FloatShiftRight 			; shift S[X] right
.23e1	c8		iny				iny 								; increment shift count
.23e2	80 09		bra $23ed			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23e4					_I32MNoAdd:
.23e4	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23e6	70 f6		bvs $23de			bvs 	_I32ShiftRight 				; instead.
.23e8	e8		inx				inx
.23e9	20 c0 26	jsr $26c0			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23ec	ca		dex				dex
.23ed					_I32MShiftUpper:
.23ed	e8		inx				inx 								; shift S[X+2] right
.23ee	e8		inx				inx
.23ef	20 ca 26	jsr $26ca			jsr 	FloatShiftRight
.23f2	ca		dex				dex
.23f3	ca		dex				dex
.23f4	80 d1		bra $23c7			bra 	_I32MLoop 					; try again.
.23f6					_I32MExit:
.23f6	20 fc 23	jsr $23fc			jsr 	FloatCalculateSign
.23f9	98		tya				tya 								; shift in A
.23fa	7a		ply				ply 								; restore Y and exit
.23fb	60		rts				rts
.23fc					FloatCalculateSign:
.23fc	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23fe	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.2400	55 33		eor $33,x			eor 	NSStatus+1,x
.2402	0a		asl a				asl 	a 							; shift bit 7 into carry
.2403	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.2405	60		rts				rts
.2406					FloatNormalise:
.2406	20 d3 26	jsr $26d3			jsr 	FloatIsZero 				; if zero exit
.2409	d0 07		bne $2412			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.240b	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.240d	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.240f	a9 00		lda #$00			lda 	#0 							; set Z flag
.2411	60		rts				rts
.2412					_NSNormaliseOptimise:
.2412	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.2414	d0 19		bne $242f			bne 	_NSNormaliseLoop
.2416	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.2418	30 15		bmi $242f			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.241a	95 62		sta $62,x			sta 	NSMantissa3,x
.241c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.241e	95 56		sta $56,x			sta 	NSMantissa2,x
.2420	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2422	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2424	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2426	b5 6e		lda $6e,x			lda 	NSExponent,x
.2428	38		sec				sec
.2429	e9 08		sbc #$08			sbc 	#8
.242b	95 6e		sta $6e,x			sta 	NSExponent,x
.242d	80 e3		bra $2412			bra 	_NSNormaliseOptimise
.242f					_NSNormaliseLoop:
.242f	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.2431	70 07		bvs $243a			bvs 	_NSNExit 					; exit if so with Z flag clear
.2433	20 c0 26	jsr $26c0			jsr 	FloatShiftLeft 				; shift mantissa left
.2436	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.2438	80 f5		bra $242f			bra 	_NSNormaliseLoop
.243a					_NSNExit:
.243a	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.243c	60		rts				rts
.243d					FloatAddTopTwoStack:
.243d	18		clc				clc
.243e	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2440	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.2442	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2444	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2446	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.2448	95 4a		sta $4a,x			sta 	NSMantissa1,x
.244a	b5 56		lda $56,x			lda		NSMantissa2,x
.244c	75 57		adc $57,x			adc 		NSMantissa2+1,x
.244e	95 56		sta $56,x			sta 	NSMantissa2,x
.2450	b5 62		lda $62,x			lda		NSMantissa3,x
.2452	75 63		adc $63,x			adc 		NSMantissa3+1,x
.2454	95 62		sta $62,x			sta 	NSMantissa3,x
.2456	60		rts				rts
.2457					FloatSubTopTwoStack:
.2457	38		sec				sec
.2458	b5 3e		lda $3e,x			lda		NSMantissa0,x
.245a	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.245c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.245e	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2460	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.2462	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2464	b5 56		lda $56,x			lda		NSMantissa2,x
.2466	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.2468	95 56		sta $56,x			sta 	NSMantissa2,x
.246a	b5 62		lda $62,x			lda		NSMantissa3,x
.246c	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.246e	95 62		sta $62,x			sta 	NSMantissa3,x
.2470	60		rts				rts
.2471					FloatInt32Add:
.2471	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2473	55 33		eor $33,x			eor 	NSStatus+1,x
.2475	30 04		bmi $247b			bmi 	_DiffSigns
.2477	20 3d 24	jsr $243d			jsr		FloatAddTopTwoStack
.247a	60		rts				rts
.247b					_DiffSigns:
.247b	20 57 24	jsr $2457			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.247e	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2480	10 07		bpl $2489			bpl 	_AddExit
.2482	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2484	95 32		sta $32,x			sta 	NSStatus,x
.2486	20 7a 26	jsr $267a			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2489					_AddExit:
.2489	20 d3 26	jsr $26d3			jsr 	FloatIsZero 				; check for -0
.248c	d0 02		bne $2490			bne 	_AddNonZero
.248e	74 32		stz $32,x			stz 	NSStatus,x
.2490					_AddNonZero:
.2490	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2491					FloatEncodeStart:
.2491	38		sec				sec
.2492	80 01		bra $2495			bra 	FloatEncodeContinue+1
.2494					FloatEncodeContinue:
.2494	18		clc				clc
.2495					FloatEncode:
.2495	08		php				php 								; save reset flag.
.2496	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2498	f0 15		beq $24af			beq 	_ENIsOkay
.249a	c9 30		cmp #$30			cmp 	#"0"
.249c	90 04		bcc $24a2			bcc 	_ENBadNumber
.249e	c9 3a		cmp #$3a			cmp 	#"9"+1
.24a0	90 0d		bcc $24af			bcc 	_ENIsOkay
.24a2					_ENBadNumber:
.24a2	28		plp				plp 								; throw saved reset
.24a3	ad 93 05	lda $0593			lda 	encodeState 				; if in decimal mode, construct final number
.24a6	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.24a8	d0 03		bne $24ad			bne 	_ENFail
.24aa	4c 27 25	jmp $2527			jmp 	_ENConstructFinal
.24ad					_ENFail:
.24ad	18		clc				clc 								; not allowed
.24ae	60		rts				rts
.24af					_ENIsOkay:
.24af	28		plp				plp 								; are we restarting
.24b0	90 15		bcc $24c7			bcc 	_ENNoRestart
.24b2					_ENStartEncode:
.24b2	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.24b4	f0 0c		beq $24c2			beq 	_ENFirstDP
.24b6	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.24b8	20 b3 26	jsr $26b3			jsr 	FloatSetByte 				; in single byte mode.
.24bb	a9 01		lda #$01			lda 	#ESTA_Low
.24bd					_ENExitChange:
.24bd	8d 93 05	sta $0593			sta 	encodeState 				; save new state
.24c0	38		sec				sec
.24c1	60		rts				rts
.24c2					_ENFirstDP:
.24c2	20 b1 26	jsr $26b1			jsr 	FloatSetZero 				; clear integer part
.24c5	80 3c		bra $2503			bra 	_ESTASwitchFloat			; go straight to float and exi
.24c7					_ENNoRestart:
.24c7	48		pha				pha 								; save digit or DP on stack.
.24c8	ad 93 05	lda $0593			lda 	encodeState 				; get current state
.24cb	c9 01		cmp #$01			cmp 	#ESTA_Low
.24cd	f0 09		beq $24d8			beq  	_ESTALowState
.24cf	c9 02		cmp #$02			cmp 	#ESTA_High
.24d1	f0 26		beq $24f9			beq 	_ESTAHighState
.24d3	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.24d5	f0 38		beq $250f			beq 	_ESTADecimalState
>24d7	db						.byte 	$DB 						; causes a break in the emulator
.24d8					_ESTALowState:
.24d8	68		pla				pla 								; get value back
.24d9	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.24db	f0 26		beq $2503			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24dd	29 0f		and #$0f			and 	#15 						; make digit
.24df	8d 94 05	sta $0594			sta 	digitTemp 					; save it.
.24e2	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24e4	0a		asl a				asl 	a
.24e5	0a		asl a				asl 	a
.24e6	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24e8	0a		asl a				asl 	a
.24e9	6d 94 05	adc $0594			adc 	digitTemp
.24ec	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24ee	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24f0	90 05		bcc $24f7			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24f2	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24f4	8d 93 05	sta $0593			sta 	encodeState
.24f7					_ESTANoSwitch:
.24f7	38		sec				sec
.24f8	60		rts				rts
.24f9					_ESTAHighState:
.24f9	68		pla				pla 								; get value back
.24fa	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24fc	f0 05		beq $2503			beq 	_ESTASwitchFloat
.24fe	20 59 25	jsr $2559			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.2501	38		sec				sec
.2502	60		rts				rts
.2503					_ESTASwitchFloat:
.2503	9c 95 05	stz $0595			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.2506	e8		inx				inx 								; zero the decimal additive.
.2507	20 b1 26	jsr $26b1			jsr 	FloatSetZero
.250a	ca		dex				dex
.250b	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.250d	80 ae		bra $24bd			bra 	_ENExitChange
.250f					_ESTADecimalState:
.250f	68		pla				pla 								; digit.
.2510	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.2512	f0 99		beq $24ad			beq 	_ENFail
.2514	e8		inx				inx 								; put digit into fractional part of X+1
.2515	20 59 25	jsr $2559			jsr 	ESTAShiftDigitIntoMantissa
.2518	ca		dex				dex
.2519	ee 95 05	inc $0595			inc 	decimalCount 				; bump the count of decimals
.251c	ad 95 05	lda $0595			lda 	decimalCount 				; too many decimal digits.
.251f	c9 0b		cmp #$0b			cmp 	#11
.2521	f0 02		beq $2525			beq 	_ESTADSFail
.2523	38		sec				sec
.2524	60		rts				rts
.2525					_ESTADSFail:
.2525	18		clc				clc
.2526	60		rts				rts
.2527					_ENConstructFinal:
.2527	ad 95 05	lda $0595			lda 	decimalCount 				; get decimal count
.252a	f0 2b		beq $2557			beq 	_ENCFExit 					; no decimals
.252c	5a		phy				phy
.252d	0a		asl a				asl 	a 							; x 4 and CLC
.252e	0a		asl a				asl 	a
.252f	6d 95 05	adc $0595			adc 	decimalCount
.2532	a8		tay				tay
.2533	b9 be 21	lda $21be,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.2536	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.2538	b9 bf 21	lda $21bf,y			lda 	FloatScalarTable-5+1,y
.253b	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.253d	b9 c0 21	lda $21c0,y			lda 	FloatScalarTable-5+2,y
.2540	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2542	b9 c1 21	lda $21c1,y			lda 	FloatScalarTable-5+3,y
.2545	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2547	b9 c2 21	lda $21c2,y			lda 	FloatScalarTable-5+4,y
.254a	95 70		sta $70,x			sta 	NSExponent+2,x
.254c	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.254e	e8		inx				inx 								; multiply decimal const by decimal scalar
.254f	e8		inx				inx
.2550	20 71 23	jsr $2371			jsr 	FloatMultiply
.2553	20 d5 20	jsr $20d5			jsr 	FloatAdd 					; add to integer part.
.2556	7a		ply				ply
.2557					_ENCFExit:
.2557	18		clc				clc 								; reject the digit.
.2558	60		rts				rts
.2559					ESTAShiftDigitIntoMantissa:
.2559	29 0f		and #$0f			and 	#15 						; save digit
.255b	48		pha				pha
.255c	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.255e	48		pha				pha
.255f	b5 56		lda $56,x			lda 	NSMantissa2,x
.2561	48		pha				pha
.2562	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2564	48		pha				pha
.2565	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2567	48		pha				pha
.2568	20 c0 26	jsr $26c0			jsr 	FloatShiftLeft 				; x 2
.256b	20 c0 26	jsr $26c0			jsr 	FloatShiftLeft 				; x 4
.256e	18		clc				clc 								; pop mantissa and add
.256f	68		pla				pla
.2570	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2572	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2574	68		pla				pla
.2575	75 4a		adc $4a,x			adc 	NSMantissa1,x
.2577	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2579	68		pla				pla
.257a	75 56		adc $56,x			adc 	NSMantissa2,x
.257c	95 56		sta $56,x			sta 	NSMantissa2,x
.257e	68		pla				pla
.257f	75 62		adc $62,x			adc 	NSMantissa3,x
.2581	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.2583	20 c0 26	jsr $26c0			jsr 	FloatShiftLeft 				; x 10
.2586	68		pla				pla 								; add digit
.2587	18		clc				clc
.2588	75 3e		adc $3e,x			adc 	NSMantissa0,x
.258a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.258c	90 0a		bcc $2598			bcc 	_ESTASDExit
.258e	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2590	d0 06		bne $2598			bne 	_ESTASDExit
.2592	f6 56		inc $56,x			inc 	NSMantissa2,x
.2594	d0 02		bne $2598			bne 	_ESTASDExit
.2596	f6 62		inc $62,x			inc 	NSMantissa3,x
.2598					_ESTASDExit:
.2598	60		rts				rts
.0593					encodeState:
>0593							.fill 	1
.0594					digitTemp:
>0594							.fill 	1
.0595					decimalCount:
>0595							.fill 	1
.2599					FloatToString:
.2599	da		phx				phx
.259a	5a		phy				phy 								; save code position
.259b	8d 96 05	sta $0596			sta 	decimalPlaces	 			; save number of DPs.
.259e	9c 97 05	stz $0597			stz 	dbOffset 					; offset into decimal buffer = start.
.25a1	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.25a3	10 08		bpl $25ad			bpl 	_CNTSNotNegative
.25a5	29 7f		and #$7f			and 	#$7F 						; make +ve
.25a7	95 32		sta $32,x			sta 	NSStatus,x
.25a9	a9 2d		lda #$2d			lda 	#"-"
.25ab	80 02		bra $25af			bra 	_CNTMain
.25ad					_CNTSNotNegative:
.25ad	a9 20		lda #$20			lda 	#" "
.25af					_CNTMain:
.25af	20 11 26	jsr $2611			jsr 	WriteDecimalBuffer
.25b2	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.25b4	f0 0d		beq $25c3			beq 	_CNTSNotFloat
.25b6	e8		inx				inx 								; round up so we don't get too many 6.999999
.25b7	a9 01		lda #$01			lda 	#1
.25b9	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.25bc	b5 6d		lda $6d,x			lda		NSExponent-1,x
.25be	95 6e		sta $6e,x			sta 	NSExponent,x
.25c0	20 d5 20	jsr $20d5			jsr 	FloatAdd
.25c3					_CNTSNotFloat:
.25c3	20 f3 25	jsr $25f3			jsr 	MakePlusTwoString 			; do the integer part.
.25c6	20 91 22	jsr $2291			jsr 	FloatFractionalPart 		; get the fractional part
.25c9	20 06 24	jsr $2406			jsr 	FloatNormalise					; normalise , exit if zero
.25cc	f0 22		beq $25f0			beq 	_CNTSExit
.25ce	a9 2e		lda #$2e			lda 	#"."
.25d0	20 11 26	jsr $2611			jsr 	WriteDecimalBuffer 			; write decimal place
.25d3					_CNTSDecimal:
.25d3	ce 96 05	dec $0596			dec 	decimalPlaces 				; done all the decimals
.25d6	30 18		bmi $25f0			bmi 	_CNTSExit
.25d8	e8		inx				inx 								; x 10.0
.25d9	a9 0a		lda #$0a			lda 	#10
.25db	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.25de	20 71 23	jsr $2371			jsr 	FloatMultiply
.25e1	20 f3 25	jsr $25f3			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25e4	20 91 22	jsr $2291			jsr 	FloatFractionalPart 		; get the fractional part
.25e7	20 06 24	jsr $2406			jsr 	FloatNormalise 				; normalise it.
.25ea	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25ec	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25ee	b0 e3		bcs $25d3			bcs 	_CNTSDecimal 				; keep going.
.25f0					_CNTSExit:
.25f0	7a		ply				ply
.25f1	fa		plx				plx
.25f2	60		rts				rts
.25f3					MakePlusTwoString:
.25f3	da		phx				phx
.25f4	20 94 26	jsr $2694			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25f7	e8		inx				inx 								; access it
.25f8	e8		inx				inx
.25f9	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart 			; make it an integer
.25fc	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25fe	20 30 26	jsr $2630			jsr 	ConvertInt32
.2601	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.2603					_MPTSCopy:
.2603	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.2606	20 11 26	jsr $2611			jsr 	WriteDecimalBuffer
.2609	e8		inx				inx
.260a	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.260d	d0 f4		bne $2603			bne 	_MPTSCopy
.260f	fa		plx				plx
.2610	60		rts				rts
.2611					WriteDecimalBuffer:
.2611	da		phx				phx
.2612	ae 97 05	ldx $0597			ldx 	dbOffset
.2615	9d 98 05	sta $0598,x			sta 	decimalBuffer,x
.2618	9e 99 05	stz $0599,x			stz 	decimalBuffer+1,x
.261b	ee 97 05	inc $0597			inc 	dbOffset
.261e	fa		plx				plx
.261f	60		rts				rts
.0596					decimalPlaces:
>0596							.fill 	1
.0597					dbOffset:
>0597							.fill 	1
.0598					decimalBuffer:
>0598							.fill 	32
.2620					ConvertInt16:
.2620	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.2622	86 4a		stx $4a				stx 	NSMantissa1
.2624	64 56		stz $56				stz 	NSMantissa2
.2626	64 62		stz $62				stz 	NSMantissa3
.2628	64 32		stz $32				stz 	NSStatus 					; positive integer
.262a	a2 00		ldx #$00			ldx 	#0 							; stack level
.262c	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.262e	80 00		bra $2630			bra 	ConvertInt32
.2630					ConvertInt32:
.2630	5a		phy				phy
.2631	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.2633	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.2635	10 08		bpl $263f			bpl 	_CI32NotNeg
.2637	48		pha				pha
.2638	a9 2d		lda #$2d			lda 	#'-'
.263a	99 71 05	sta $0571,y			sta 	numberBuffer,y
.263d	c8		iny				iny
.263e	68		pla				pla
.263f					_CI32NotNeg:
.263f	20 4d 26	jsr $264d			jsr 	_CI32DivideConvert 			; recursive conversion
.2642	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2644	99 71 05	sta $0571,y			sta 	numberBuffer,y
.2647	7a		ply				ply
.2648	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.264a	a9 71		lda #$71			lda 	#numberBuffer & $FF
.264c	60		rts				rts
.264d					_CI32DivideConvert:
.264d	e8		inx				inx 								; write to next slot up
.264e	20 b3 26	jsr $26b3			jsr 	FloatSetByte 		 		; write the base out.
.2651	ca		dex				dex
.2652	20 47 22	jsr $2247			jsr 	Int32Divide 				; divide
.2655	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.2657	48		pha				pha
.2658	20 36 22	jsr $2236			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.265b	20 d3 26	jsr $26d3			jsr 	FloatIsZero 				; is it zero ?
.265e	f0 05		beq $2665			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2660	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2662	20 4d 26	jsr $264d			jsr 	_CI32DivideConvert 			; and recusrively call.
.2665					_CI32NoRecurse:
.2665	68		pla				pla 								; remainder
.2666	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2668	90 02		bcc $266c			bcc 	_CI32NotHex
.266a	69 26		adc #$26			adc 	#6+32
.266c					_CI32NotHex:
.266c	69 30		adc #$30			adc 	#48
.266e	99 71 05	sta $0571,y			sta 	numberBuffer,y 				; write out and exit
.2671	c8		iny				iny
.2672	60		rts				rts
.2673					FloatNegate:
.2673	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2675	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2677	95 32		sta $32,x			sta 	NSStatus,x
.2679	60		rts				rts
.267a					FloatNegateMantissa:
.267a	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.267b	a9 00		lda #$00			lda 	#0
.267d	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.267f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2681	a9 00		lda #$00			lda 	#0
.2683	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.2685	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2687	a9 00		lda #$00			lda 	#0
.2689	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.268b	95 56		sta $56,x			sta 	NSMantissa2,x
.268d	a9 00		lda #$00			lda 	#0
.268f	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2691	95 62		sta $62,x			sta 	NSMantissa3,x
.2693	60		rts				rts
.2694					FloatShiftUpTwo:
.2694	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2696	95 40		sta $40,x			sta 	NSMantissa0+2,x
.2698	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.269a	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.269c	b5 56		lda $56,x			lda 	NSMantissa2,x
.269e	95 58		sta $58,x			sta 	NSMantissa2+2,x
.26a0	b5 62		lda $62,x			lda 	NSMantissa3,x
.26a2	95 64		sta $64,x			sta 	NSMantissa3+2,x
.26a4	b5 6e		lda $6e,x			lda 	NSExponent,x
.26a6	95 70		sta $70,x			sta 	NSExponent+2,x
.26a8	b5 32		lda $32,x			lda 	NSStatus,x
.26aa	95 34		sta $34,x			sta 	NSStatus+2,x
.26ac	60		rts				rts
.26ad					FloatSetZeroMantissaOnly:
.26ad	74 3e		stz $3e,x			stz 	NSMantissa0,x
.26af	80 08		bra $26b9			bra 	FloatZero13
.26b1					FloatSetZero:
.26b1	a9 00		lda #$00			lda 	#0
.26b3					FloatSetByte:
.26b3	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.26b5					FloatSetMantissa:
.26b5	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.26b7	74 32		stz $32,x			stz 	NSStatus,x
.26b9					FloatZero13:
.26b9	74 4a		stz $4a,x			stz 	NSMantissa1,x
.26bb	74 56		stz $56,x			stz 	NSMantissa2,x
.26bd	74 62		stz $62,x			stz 	NSMantissa3,x
.26bf	60		rts				rts
.26c0					FloatShiftLeft:
.26c0	18		clc				clc
.26c1					FloatRotateLeft:
.26c1	36 3e		rol $3e,x			rol 	NSMantissa0,x
.26c3	36 4a		rol $4a,x			rol		NSMantissa1,x
.26c5	36 56		rol $56,x			rol		NSMantissa2,x
.26c7	36 62		rol $62,x			rol		NSMantissa3,x
.26c9	60		rts				rts
.26ca					FloatShiftRight:
.26ca	56 62		lsr $62,x			lsr 	NSMantissa3,x
.26cc	76 56		ror $56,x			ror		NSMantissa2,x
.26ce	76 4a		ror $4a,x			ror		NSMantissa1,x
.26d0	76 3e		ror $3e,x			ror		NSMantissa0,x
.26d2	60		rts				rts
.26d3					FloatIsZero:
.26d3	b5 62		lda $62,x			lda 	NSMantissa3,x
.26d5	15 56		ora $56,x			ora		NSMantissa2,x
.26d7	15 4a		ora $4a,x			ora		NSMantissa1,x
.26d9	15 3e		ora $3e,x			ora		NSMantissa0,x
.26db	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.26dc					FloatArcTan:
.26dc	20 06 24	jsr $2406			jsr 	FloatNormalise 					; normalise x
.26df	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.26e1	48		pha				pha
.26e2	74 32		stz $32,x			stz 	NSStatus,x
.26e4	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.26e6	c9 e2		cmp #$e2			cmp 	#$E2
.26e8	90 25		bcc $270f			bcc 	_UANoFixup
.26ea	8a		txa				txa 									; value in +1
.26eb	a8		tay				tay
.26ec	c8		iny				iny
.26ed	20 95 28	jsr $2895			jsr 	CopyFloatXY
.26f0	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.26f2	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.26f5	e8		inx				inx
.26f6	20 fa 21	jsr $21fa			jsr 	FloatDivide
.26f9	b0 21		bcs $271c			bcs 	_FATError
.26fb	20 1f 27	jsr $271f			jsr 	CoreAtn 						; calculate the root
.26fe	20 8a 28	jsr $288a			jsr 	CompletePolynomial
.2701	20 73 26	jsr $2673			jsr 	FloatNegate 					; make -ve
.2704	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2706	20 e1 28	jsr $28e1			jsr 	LoadConstant
.2709	e8		inx				inx
.270a	20 d5 20	jsr $20d5			jsr 	FloatAdd
.270d	80 06		bra $2715			bra 	_UAComplete
.270f					_UANoFixup:
.270f	20 1f 27	jsr $271f			jsr 	CoreAtn
.2712	20 8a 28	jsr $288a			jsr 	CompletePolynomial
.2715					_UAComplete:
.2715	68		pla				pla 									; apply the result.
.2716	55 32		eor $32,x			eor 	NSStatus,x
.2718	95 32		sta $32,x			sta 	NSStatus,x
.271a	18		clc				clc
.271b	60		rts				rts
.271c					_FATError:
.271c	68		pla				pla
.271d	38		sec				sec
.271e	60		rts				rts
.271f					CoreAtn:
.271f	a9 8d		lda #$8d			lda 	#AtnCoefficients & $FF
.2721	a0 27		ldy #$27			ldy 	#AtnCoefficients >> 8
.2723	4c de 29	jmp $29de			jmp 	CorePolySquared
.2726					ExpCoefficients:
>2726	07					.byte	7
>2727	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>272b	d2					.byte	$d2
>272c	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>2730	d5					.byte	$d5
>2731	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>2735	d8					.byte	$d8
>2736	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>273a	db					.byte	$db
>273b	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>273f	dd					.byte	$dd
>2740	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>2744	df					.byte	$df
>2745	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>2749	e1					.byte	$e1
>274a	00 00 00 40				.dword	$40000000 ; 1.0
>274e	e2					.byte	$e2
.274f					SinCoefficients:
>274f	06					.byte	6
>2750	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>2754	e5					.byte	$e5
>2755	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>2759	e7					.byte	$e7
>275a	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>275e	e8					.byte	$e8
>275f	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>2763	e8					.byte	$e8
>2764	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>2768	e7					.byte	$e7
>2769	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>276d	e4					.byte	$e4
>276e	00 00 00 00				.dword	$00000000 ; 0.0
>2772	00					.byte	$00
.2773					LogCoefficients:
>2773	04					.byte	4
>2774	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>2778	e0					.byte	$e0
>2779	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>277d	e1					.byte	$e1
>277e	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>2782	e1					.byte	$e1
>2783	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>2787	e3					.byte	$e3
>2788	00 00 00 c0				.dword	$c0000000 ; -0.5
>278c	e1					.byte	$e1
.278d					AtnCoefficients:
>278d	0c					.byte	12
>278e	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2792	d7					.byte	$d7
>2793	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>2797	da					.byte	$da
>2798	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>279c	dc					.byte	$dc
>279d	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>27a1	dd					.byte	$dd
>27a2	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>27a6	dd					.byte	$dd
>27a7	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>27ab	de					.byte	$de
>27ac	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>27b0	de					.byte	$de
>27b1	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>27b5	de					.byte	$de
>27b6	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>27ba	df					.byte	$df
>27bb	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>27bf	df					.byte	$df
>27c0	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>27c4	e0					.byte	$e0
>27c5	00 00 00 40				.dword	$40000000 ; 1.0
>27c9	e2					.byte	$e2
>27ca	00 00 00 00				.dword	$00000000 ; 0.0
>27ce	00					.byte	$00
.27cf					Const_Base:
.27cf					Const_1Div2Pi:
>27cf	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>27d3	df					.byte	$df
.27d4					Const_PiDiv2:
>27d4	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>27d8	e2					.byte	$e2
.27d9					Const_Log2_e:
>27d9	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>27dd	e2					.byte	$e2
.27de					Const_sqrt_2:
>27de	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>27e2	e2					.byte	$e2
.27e3					Const_sqrt_half:
>27e3	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>27e7	e1					.byte	$e1
.27e8					Const_pi:
>27e8	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>27ec	e3					.byte	$e3
.27ed					Const_half:
>27ed	00 00 00 40				.dword	$40000000 ; 0.50000000
>27f1	e1					.byte	$e1
.27f2					Const_ln_e:
>27f2	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>27f6	e1					.byte	$e1
.27f7					FloatCosine:
.27f7	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.27f9	20 e1 28	jsr $28e1			jsr 	LoadConstant
.27fc	e8		inx				inx
.27fd	20 d5 20	jsr $20d5			jsr 	FloatAdd
.2800	4c 97 29	jmp $2997			jmp 	FloatSine
.2803					FloatExponent:
.2803	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.2805	20 e1 28	jsr $28e1			jsr 	LoadConstant
.2808	e8		inx				inx
.2809	20 71 23	jsr $2371			jsr 	FloatMultiply
.280c	20 4e 28	jsr $284e			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.280f	e8		inx				inx
.2810	20 ec 22	jsr $22ec			jsr 	FloatIntegerPart
.2813	ca		dex				dex
.2814	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2816	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2818	15 63		ora $63,x			ora 	NSMantissa3+1,x
.281a	d0 38		bne $2854			bne 	_UERangeError
.281c	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.281e	c9 40		cmp #$40			cmp 	#64
.2820	b0 32		bcs $2854			bcs 	_UERangeError
.2822	48		pha				pha
.2823	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.2825	48		pha				pha
.2826	20 91 22	jsr $2291			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.2829	68		pla				pla
.282a	10 14		bpl $2840			bpl 	_UEPositive
.282c	e8		inx				inx 							; 1-x
.282d	a9 01		lda #$01			lda 	#1
.282f	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.2832	ca		dex				dex
.2833	20 73 26	jsr $2673			jsr 	FloatNegate
.2836	e8		inx				inx
.2837	20 d5 20	jsr $20d5			jsr 	FloatAdd
.283a	68		pla				pla 							; integer part +1 and negated.
.283b	1a		inc a				inc 	a
.283c	49 ff		eor #$ff			eor 	#$FF
.283e	1a		inc a				inc 	a
.283f	48		pha				pha
.2840					_UEPositive:
.2840	20 56 28	jsr $2856			jsr 	CoreExponent
.2843	20 8a 28	jsr $288a			jsr 	CompletePolynomial
.2846	68		pla				pla
.2847	18		clc				clc
.2848	75 6e		adc $6e,x			adc 	NSExponent,x
.284a	95 6e		sta $6e,x			sta 	NSExponent,x
.284c	18		clc				clc
.284d	60		rts				rts
.284e					_UECopy01:
.284e	8a		txa				txa
.284f	a8		tay				tay
.2850	c8		iny				iny
.2851	4c 95 28	jmp $2895			jmp 	CopyFloatXY
.2854					_UERangeError:
.2854	38		sec				sec
.2855	60		rts				rts
.2856					CoreExponent:
.2856	a9 26		lda #$26			lda 	#ExpCoefficients & $FF
.2858	a0 27		ldy #$27			ldy 	#ExpCoefficients >> 8
.285a	20 5e 28	jsr $285e			jsr 	CalculateHornerPolynomial
.285d	60		rts				rts
.285e					CalculateHornerPolynomial:
.285e	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.2860	84 2d		sty $2d				sty 	zTemp0+1
.2862	9c b8 05	stz $05b8			stz 	coefficientCount 			; zero the count.
.2865	8e b9 05	stx $05b9			stx 	xValueSlot 					; save xValue slot.
.2868	e8		inx				inx 								; set the count to zero.
.2869	20 b1 26	jsr $26b1			jsr 	FloatSetZero
.286c					_CHPLoop:
.286c	8a		txa				txa 								; copy X-1 to X+1
.286d	a8		tay				tay
.286e	ca		dex				dex
.286f	c8		iny				iny
.2870	20 95 28	jsr $2895			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.2873	e8		inx				inx
.2874	e8		inx				inx
.2875	20 71 23	jsr $2371			jsr 	FloatMultiply 				; times current by X
.2878	e8		inx				inx
.2879	20 b4 28	jsr $28b4			jsr 	GetCoefficient 				; coefficient into X+1
.287c	20 d5 20	jsr $20d5			jsr 	FloatAdd 					; and add
.287f	ee b8 05	inc $05b8			inc 	coefficientCount
.2882	ad b8 05	lda $05b8			lda 	coefficientCount
.2885	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.2887	d0 e3		bne $286c			bne 	_CHPLoop
.2889	60		rts				rts
.288a					CompletePolynomial:
.288a	20 71 23	jsr $2371			jsr 	FloatMultiply
.288d	e8		inx				inx 								; get the last value
.288e	20 b4 28	jsr $28b4			jsr 	GetCoefficient
.2891	20 d5 20	jsr $20d5			jsr 	FloatAdd 					; and add it
.2894	60		rts				rts
.2895					CopyFloatXY:
.2895	b5 6e		lda $6e,x			lda 	NSExponent,x
.2897	99 6e 00	sta $006e,y			sta 	NSExponent,y
.289a	b5 32		lda $32,x			lda 	NSStatus,x
.289c	99 32 00	sta $0032,y			sta 	NSStatus,y
.289f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.28a1	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.28a4	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.28a6	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.28a9	b5 56		lda $56,x			lda 	NSMantissa2,x
.28ab	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.28ae	b5 62		lda $62,x			lda 	NSMantissa3,x
.28b0	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.28b3	60		rts				rts
.28b4					GetCoefficient:
.28b4	5a		phy				phy
.28b5	ad b8 05	lda $05b8			lda 	coefficientCount 			; 5 per block
.28b8	0a		asl a				asl 	a
.28b9	0a		asl a				asl 	a
.28ba	38		sec				sec 								; +1 for count
.28bb	6d b8 05	adc $05b8			adc 	coefficientCount
.28be	a8		tay				tay
.28bf	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.28c1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.28c3	c8		iny				iny
.28c4	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28c6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.28c8	c8		iny				iny
.28c9	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28cb	95 56		sta $56,x			sta 	NSMantissa2,x
.28cd	c8		iny				iny
.28ce	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28d0	48		pha				pha
.28d1	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.28d3	95 62		sta $62,x			sta 	NSMantissa3,x
.28d5	c8		iny				iny
.28d6	68		pla				pla
.28d7	29 80		and #$80			and 	#$80
.28d9	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.28db	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28dd	95 6e		sta $6e,x			sta 	NSExponent,x
.28df	7a		ply				ply
.28e0	60		rts				rts
.05b8					coefficientCount:
>05b8							.fill 	1
.05b9					xValueSlot:
>05b9							.fill 	1
.28e1					LoadConstant:
.28e1	5a		phy				phy
.28e2	a8		tay				tay
.28e3	b9 cf 27	lda $27cf,y			lda 	Const_Base+0,y
.28e6	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.28e8	b9 d0 27	lda $27d0,y			lda 	Const_Base+1,y
.28eb	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.28ed	b9 d1 27	lda $27d1,y			lda 	Const_Base+2,y
.28f0	95 57		sta $57,x			sta 	NSMantissa2+1,x
.28f2	b9 d2 27	lda $27d2,y			lda 	Const_Base+3,y
.28f5	48		pha				pha
.28f6	29 7f		and #$7f			and 	#$7F
.28f8	95 63		sta $63,x			sta 	NSMantissa3+1,x
.28fa	68		pla				pla
.28fb	29 80		and #$80			and 	#$80
.28fd	95 33		sta $33,x			sta 	NSStatus+1,x
.28ff	b9 d3 27	lda $27d3,y			lda 	Const_Base+4,y
.2902	95 6f		sta $6f,x			sta 	NSExponent+1,x
.2904	7a		ply				ply
.2905	60		rts				rts
.2906					FloatLogarithm:
.2906	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.2908	30 5f		bmi $2969			bmi 	_ULRange
.290a	20 d3 26	jsr $26d3			jsr 	FloatIsZero
.290d	f0 5a		beq $2969			beq 	_ULRange
.290f	20 06 24	jsr $2406			jsr 	FloatNormalise 				; put into FP mode.
.2912	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.2914	48		pha				pha
.2915	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.2917	95 6e		sta $6e,x			sta 	NSExponent,x
.2919	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.291b	20 e1 28	jsr $28e1			jsr 	LoadConstant
.291e	e8		inx				inx
.291f	20 d5 20	jsr $20d5			jsr 	FloatAdd
.2922	8a		txa				txa 								; divide into sqrt 2.0
.2923	a8		tay				tay
.2924	c8		iny				iny
.2925	20 95 28	jsr $2895			jsr 	CopyFloatXY
.2928	ca		dex				dex
.2929	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.292b	20 e1 28	jsr $28e1			jsr 	LoadConstant
.292e	e8		inx				inx
.292f	e8		inx				inx
.2930	20 fa 21	jsr $21fa			jsr 	FloatDivide 				; if zero, error.
.2933	b0 33		bcs $2968			bcs 	_ULRangePla
.2935	20 73 26	jsr $2673			jsr 	FloatNegate 				; subtract from 1
.2938	e8		inx				inx
.2939	a9 01		lda #$01			lda 	#1
.293b	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.293e	20 d5 20	jsr $20d5			jsr 	FloatAdd
.2941	20 6b 29	jsr $296b			jsr 	CoreLog
.2944	20 8a 28	jsr $288a			jsr 	CompletePolynomial
.2947	68		pla				pla 								; add exponent
.2948	18		clc				clc
.2949	69 1f		adc #$1f			adc 	#31 						; fix up
.294b	48		pha				pha
.294c	10 03		bpl $2951			bpl 	_LogNotNeg
.294e	49 ff		eor #$ff			eor 	#$FF
.2950	1a		inc a				inc 	a
.2951					_LogNotNeg:
.2951	e8		inx				inx 								; set byte and sign.
.2952	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.2955	68		pla				pla
.2956	29 80		and #$80			and 	#$80
.2958	95 32		sta $32,x			sta 	NSStatus,x
.295a	20 d5 20	jsr $20d5			jsr 	FloatAdd
.295d	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.295f	20 e1 28	jsr $28e1			jsr 	LoadConstant
.2962	e8		inx				inx
.2963	20 71 23	jsr $2371			jsr 	FloatMultiply
.2966	18		clc				clc
.2967	60		rts				rts
.2968					_ULRangePla:
.2968	68		pla				pla
.2969					_ULRange:
.2969	38		sec				sec
.296a	60		rts				rts
.296b					CoreLog:
.296b	a9 73		lda #$73			lda 	#LogCoefficients & $FF
.296d	a0 27		ldy #$27			ldy 	#LogCoefficients >> 8
.296f	4c de 29	jmp $29de			jmp 	CorePolySquared
.2972					FloatPI:
.2972	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.2974	20 e1 28	jsr $28e1			jsr 	LoadConstant
.2977	e8		inx				inx
.2978	18		clc				clc
.2979	60		rts				rts
.297a					FloatPower:
.297a	ca		dex				dex
.297b	8a		txa				txa 							; copy 0 to 2, so we can process it
.297c	a8		tay				tay
.297d	c8		iny				iny
.297e	c8		iny				iny
.297f	20 95 28	jsr $2895			jsr 	CopyFloatXY
.2982	e8		inx				inx 							; 2 = Log(0)
.2983	e8		inx				inx
.2984	20 06 29	jsr $2906			jsr 	FloatLogarithm
.2987	b0 0d		bcs $2996			bcs 	_FPWExit
.2989	20 71 23	jsr $2371			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.298c	8a		txa				txa 							; copy to slot 0
.298d	a8		tay				tay
.298e	88		dey				dey
.298f	20 95 28	jsr $2895			jsr 	CopyFloatXY
.2992	ca		dex				dex  							; Exponent code.
.2993	20 03 28	jsr $2803			jsr 	FloatExponent
.2996					_FPWExit:
.2996	60		rts				rts
.2997					FloatSine:
.2997	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.2999	48		pha				pha
.299a	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.299c	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.299e	20 e1 28	jsr $28e1			jsr 	LoadConstant
.29a1	e8		inx				inx
.29a2	20 71 23	jsr $2371			jsr 	FloatMultiply
.29a5	20 91 22	jsr $2291			jsr 	FloatFractionalPart 		; take the fractional part
.29a8	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.29aa	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.29ac	90 1f		bcc $29cd			bcc 	_USProcessExit
.29ae	f0 06		beq $29b6			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.29b0	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.29b2	c9 60		cmp #$60			cmp 	#$60
.29b4	b0 0e		bcs $29c4			bcs 	_USSubtractOne
.29b6					_USSubtractFromHalf:
.29b6	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.29b8	20 e1 28	jsr $28e1			jsr 	LoadConstant
.29bb	e8		inx				inx
.29bc	20 cf 20	jsr $20cf			jsr 	FloatSubtract
.29bf	20 73 26	jsr $2673			jsr 	FloatNegate 				; then negate it
.29c2	80 09		bra $29cd			bra 	_USProcessExit 				; and exit
.29c4					_USSubtractOne:
.29c4	e8		inx				inx
.29c5	a9 01		lda #$01			lda 	#1
.29c7	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.29ca	20 cf 20	jsr $20cf			jsr 	FloatSubtract
.29cd					_USProcessExit:
.29cd	20 da 29	jsr $29da			jsr 	CoreSine
.29d0	20 8a 28	jsr $288a			jsr 	CompletePolynomial
.29d3	68		pla				pla 								; restore sign and apply
.29d4	55 32		eor $32,x			eor 	NSStatus,x
.29d6	95 32		sta $32,x			sta 	NSStatus,x
.29d8	18		clc				clc
.29d9	60		rts				rts
.29da					CoreSine:
.29da	a9 4f		lda #$4f			lda 	#SinCoefficients & $FF
.29dc	a0 27		ldy #$27			ldy 	#SinCoefficients >> 8
.29de					CorePolySquared:
.29de	48		pha				pha 								; save coefficient table
.29df	5a		phy				phy
.29e0	8a		txa				txa 								; copy X to +1, +2
.29e1	a8		tay				tay
.29e2	c8		iny				iny
.29e3	20 95 28	jsr $2895			jsr 	CopyFloatXY
.29e6	c8		iny				iny
.29e7	20 95 28	jsr $2895			jsr 	CopyFloatXY
.29ea	e8		inx				inx 								; point to the pair and put x^2 on stack
.29eb	e8		inx				inx
.29ec	20 71 23	jsr $2371			jsr 	FloatMultiply
.29ef	7a		ply				ply 								; coefficient table back.
.29f0	68		pla				pla
.29f1	20 5e 28	jsr $285e			jsr 	CalculateHornerPolynomial
.29f4	8a		txa				txa 								; copy back to slot #1
.29f5	a8		tay				tay
.29f6	88		dey				dey
.29f7	20 95 28	jsr $2895			jsr	 	CopyFloatXY
.29fa	ca		dex				dex 								; point at result
.29fb	60		rts				rts
.29fc					FloatSquareRoot:
.29fc	20 06 29	jsr $2906			jsr 	FloatLogarithm
.29ff	b0 06		bcs $2a07			bcs 	_FSQExit
.2a01	d6 6e		dec $6e,x			dec 	NSExponent,x
.2a03	20 03 28	jsr $2803			jsr 	FloatExponent
.2a06	18		clc				clc
.2a07					_FSQExit:
.2a07	60		rts				rts
.2a08					FloatTangent:
.2a08	da		phx				phx
.2a09	8a		txa				txa 								; sin -> +1
.2a0a	a8		tay				tay
.2a0b	c8		iny				iny
.2a0c	20 95 28	jsr $2895			jsr 	CopyFloatXY
.2a0f	e8		inx				inx
.2a10	20 97 29	jsr $2997			jsr 	FloatSine
.2a13	ca		dex				dex
.2a14	8a		txa				txa 								; cos -> +2
.2a15	a8		tay				tay
.2a16	c8		iny				iny
.2a17	c8		iny				iny
.2a18	20 95 28	jsr $2895			jsr 	CopyFloatXY
.2a1b	e8		inx				inx
.2a1c	e8		inx				inx
.2a1d	20 f7 27	jsr $27f7			jsr 	FloatCosine
.2a20	20 fa 21	jsr $21fa			jsr 	FloatDivide 				; calculate sin/cos
.2a23	b0 07		bcs $2a2c			bcs 	_FTExit 					; divide by zero
.2a25	8a		txa				txa 								; copy result down.
.2a26	a8		tay				tay
.2a27	88		dey				dey
.2a28	20 95 28	jsr $2895			jsr 	CopyFloatXY
.2a2b	18		clc				clc
.2a2c					_FTExit:
.2a2c	fa		plx				plx
.2a2d	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.007a					srcPtr:
>007a							.fill 	2
.05ba					currentLineNumber:
>05ba							.fill 	2
.2a2e					InlineNonDecimal:
.2a2e	a2 02		ldx #$02			ldx 	#2 							; get size in X
.2a30	c9 25		cmp #$25			cmp 	#"%"
.2a32	f0 02		beq $2a36			beq 	_INDBinary
.2a34	a2 10		ldx #$10			ldx 	#16
.2a36					_INDBinary:
.2a36	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.2a38	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.2a3a	64 2c		stz $2c				stz 	zTemp0 						; zero result
.2a3c	64 2d		stz $2d				stz 	zTemp0+1
.2a3e					_INDLoop:
.2a3e	20 ef 33	jsr $33ef			jsr 	LookNext 					; check next character
.2a41	20 2b 34	jsr $342b			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.2a44	90 1f		bcc $2a65			bcc		_INDDone 					; didn't convert
.2a46	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.2a48	b0 1b		bcs $2a65			bcs 	_INDDone
.2a4a	20 74 2a	jsr $2a74			jsr 	_INDShift 					; x 2 or x 16
.2a4d	e0 02		cpx #$02			cpx 	#2
.2a4f	f0 09		beq $2a5a			beq 	_INDNotHex
.2a51	20 74 2a	jsr $2a74			jsr 	_INDShift
.2a54	20 74 2a	jsr $2a74			jsr 	_INDShift
.2a57	20 74 2a	jsr $2a74			jsr 	_INDShift
.2a5a					_INDNotHex:
.2a5a	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.2a5c	85 2c		sta $2c				sta 	zTemp0
.2a5e	20 00 34	jsr $3400			jsr 	GetNext 					; consume
.2a61	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.2a63	80 d9		bra $2a3e			bra 	_INDLoop
.2a65					_INDDone:
.2a65	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.2a67	f0 08		beq $2a71			beq 	_INDError
.2a69	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.2a6b	a5 2c		lda $2c				lda 	zTemp0
.2a6d	20 96 2b	jsr $2b96			jsr 	PushIntegerYA
.2a70	60		rts				rts
.2a71					_INDError:
.2a71	4c 59 1f	jmp $1f59		jmp	ErrorV_syntax
.2a74					_INDShift:
.2a74	06 2c		asl $2c				asl 	zTemp0
.2a76	26 2d		rol $2d				rol 	zTemp0+1
.2a78	60		rts				rts
.2a79					GetLineNumber:
.2a79	ac bb 05	ldy $05bb			ldy 	currentLineNumber+1
.2a7c	ad ba 05	lda $05ba			lda 	currentLineNumber
.2a7f	60		rts				rts
.2a80					WriteCodeByte:
.2a80	48		pha				pha 								; save on stack
.2a81	da		phx				phx
.2a82	5a		phy				phy
.2a83	aa		tax				tax
.2a84	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.2a86	20 93 2b	jsr $2b93			jsr 	CallAPIHandler
.2a89	7a		ply				ply 								; restore from stack
.2a8a	fa		plx				plx
.2a8b	68		pla				pla
.2a8c	60		rts				rts
.2a8d					PrintCharacter
.2a8d	48		pha				pha
.2a8e	da		phx				phx
.2a8f	5a		phy				phy
.2a90	aa		tax				tax
.2a91	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.2a93	20 93 2b	jsr $2b93			jsr 	CallAPIHandler
.2a96	7a		ply				ply
.2a97	fa		plx				plx
.2a98	68		pla				pla
.2a99	60		rts				rts
.2a9a					ProcessNewLine:
.2a9a	86 2c		stx $2c				stx 	zTemp0 						; save address in zTemp0
.2a9c	84 2d		sty $2d				sty 	zTemp0+1
.2a9e	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.2a9f	8a		txa				txa
.2aa0	69 04		adc #$04			adc 	#4
.2aa2	85 7a		sta $7a				sta 	srcPtr
.2aa4	98		tya				tya
.2aa5	69 00		adc #$00			adc 	#0
.2aa7	85 7b		sta $7b				sta 	srcPtr+1
.2aa9	a0 02		ldy #$02			ldy 	#2							; read and save line number
.2aab	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2aad	8d ba 05	sta $05ba			sta 	currentLineNumber
.2ab0	c8		iny				iny
.2ab1	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ab3	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2ab6	60		rts				rts
.2ab7					BufferClear:
.2ab7	9c bc 05	stz $05bc			stz 	bufferSize
.2aba	60		rts				rts
.2abb					BufferWrite:
.2abb	da		phx				phx
.2abc	ae bc 05	ldx $05bc			ldx 	bufferSize
.2abf	9d bd 05	sta $05bd,x			sta 	dataBuffer,x
.2ac2	ee bc 05	inc $05bc			inc 	bufferSize
.2ac5	fa		plx				plx
.2ac6	60		rts				rts
.2ac7					BufferOutput:
.2ac7	ad bc 05	lda $05bc			lda 	bufferSize
.2aca	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2acd	a2 00		ldx #$00			ldx 	#0
.2acf					_BOLoop:
.2acf	ec bc 05	cpx $05bc			cpx 	bufferSize
.2ad2	f0 09		beq $2add			beq 	_BOExit
.2ad4	bd bd 05	lda $05bd,x			lda 	dataBuffer,x
.2ad7	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2ada	e8		inx				inx
.2adb	80 f2		bra $2acf			bra 	_BOLoop
.2add					_BOExit:
.2add	60		rts				rts
.05bc					bufferSize:
>05bc							.fill 	1
.05bd					dataBuffer:
>05bd							.fill 	256
.2ade					CheckNextComma:
.2ade	a9 2c		lda #$2c			lda	 	#","
.2ae0	80 06		bra $2ae8			bra 	CheckNextA
.2ae2					CheckNextRParen:
.2ae2	a9 29		lda #$29			lda	 	#")"
.2ae4	80 02		bra $2ae8			bra 	CheckNextA
.2ae6					CheckNextLParen:
.2ae6	a9 28		lda #$28			lda 	#"("
.2ae8					CheckNextA:
.2ae8	8d bd 06	sta $06bd			sta 	checkCharacter 				; save test character
.2aeb					_CNALoop:
.2aeb	20 0b 34	jsr $340b			jsr 	GetNextNonSpace 			; get next skipping spaces.
.2aee	cd bd 06	cmp $06bd			cmp 	checkCharacter 				; matches ?
.2af1	f0 03		beq $2af6			beq 	_CNAExit
.2af3	4c 59 1f	jmp $1f59		jmp	ErrorV_syntax
.2af6					_CNAExit:
.2af6	60		rts				rts
.06bd					checkCharacter:
>06bd							.fill 	1
.2af7					StartCompiler:
.2af7	86 2c		stx $2c				stx 	zTemp0 						; access API
.2af9	84 2d		sty $2d				sty 	zTemp0+1
.2afb	a0 2d		ldy #$2d			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.2afd	a2 4f		ldx #$4f			ldx 	#CompilerErrorHandler & $FF
.2aff	20 32 1f	jsr $1f32			jsr 	SetErrorHandler
.2b02	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.2b04	b2 2c		lda ($2c)			lda 	(zTemp0)
.2b06	8d bf 06	sta $06bf			sta 	APIVector
.2b09	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2b0b	8d c0 06	sta $06c0			sta 	APIVector+1
.2b0e	c8		iny				iny 								; copy data area range.
.2b0f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2b11	8d c1 06	sta $06c1			sta 	compilerStartHigh
.2b14	c8		iny				iny
.2b15	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2b17	8d c2 06	sta $06c2			sta 	compilerEndHigh
.2b1a	ba		tsx				tsx 								; save stack pointer
.2b1b	8e be 06	stx $06be			stx 	compilerSP
.2b1e	20 d3 37	jsr $37d3			jsr 	STRReset 					; reset storage (line#, variable)
.2b21	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.2b23	20 93 2b	jsr $2b93			jsr 	CallAPIHandler
.2b26	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.2b28	20 93 2b	jsr $2b93			jsr 	CallAPIHandler
.2b2b	a9 d5		lda #$d5			lda 	#PCD_CMD_VARSPACE
.2b2d	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2b30	a9 00		lda #$00			lda 	#0
.2b32	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2b35	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2b38					MainCompileLoop:
.2b38	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.2b3a	20 93 2b	jsr $2b93			jsr 	CallAPIHandler
.2b3d	90 31		bcc $2b70			bcc 	SaveCodeAndExit 			; end of source.
.2b3f	20 9a 2a	jsr $2a9a			jsr 	ProcessNewLine 				; set up pointer and line number.
.2b42	20 79 2a	jsr $2a79			jsr 	GetLineNumber 				; get line #
.2b45	20 88 35	jsr $3588			jsr 	STRMarkLine 				; remember the code position and number of this line.
.2b48	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.2b4a	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2b4d					_MCLSameLine:
.2b4d	20 0b 34	jsr $340b			jsr 	GetNextNonSpace 			; get the first character.
.2b50	f0 e6		beq $2b38			beq 	MainCompileLoop 			; end of line, get next line.
.2b52	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.2b54	f0 f7		beq $2b4d			beq 	_MCLSameLine
.2b56	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.2b58	10 0c		bpl $2b66			bpl 	_MCLCheckAssignment
.2b5a	a2 bc		ldx #$bc			ldx 	#CommandTables & $FF 		; do command tables.
.2b5c	a0 2f		ldy #$2f			ldy 	#CommandTables >> 8
.2b5e	20 91 32	jsr $3291			jsr 	GeneratorProcess
.2b61	b0 ea		bcs $2b4d			bcs 	_MCLSameLine 				; keep trying to compile the line.
.2b63					_MCLSyntax:
.2b63	4c 59 1f	jmp $1f59		jmp	ErrorV_syntax
.2b66					_MCLCheckAssignment:
.2b66	20 21 34	jsr $3421			jsr 	CharIsAlpha 				; if not alpha then syntax error
.2b69	90 f8		bcc $2b63			bcc 	_MCLSyntax
.2b6b	20 47 35	jsr $3547			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.2b6e	80 dd		bra $2b4d			bra		_MCLSameLine 				; loop back.
.2b70					SaveCodeAndExit:
.2b70	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.2b72	20 93 2b	jsr $2b93			jsr 	CallAPIHandler
.2b75	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.2b77	a8		tay				tay
.2b78	20 88 35	jsr $3588			jsr 	STRMarkLine
.2b7b	a9 c5		lda #$c5			lda 	#PCD_EXIT 					; add an END
.2b7d	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2b80	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.2b82	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2b85	20 ac 2e	jsr $2eac			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.2b88	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.2b8a	20 93 2b	jsr $2b93			jsr 	CallAPIHandler
.2b8d	18		clc				clc 								; CC = success
.2b8e					ExitCompiler:
.2b8e	ae be 06	ldx $06be			ldx 	compilerSP 					; reload SP and exit.
.2b91	9a		txs				txs
.2b92	60		rts				rts
.2b93					CallAPIHandler:
.2b93	6c bf 06	jmp ($06bf)			jmp 	(APIVector)
.06be					compilerSP:
>06be							.fill 	1
.06bf					APIVector:
>06bf							.fill 	2
.06c1					compilerStartHigh:
>06c1							.fill 	1
.06c2					compilerEndHigh:
>06c2							.fill 	1
.2b96					PushIntegerYA:
.2b96	c0 00		cpy #$00			cpy 	#0 							; 0-255
.2b98	f0 0f		beq $2ba9			beq 	PushIntegerA
.2b9a	48		pha				pha
.2b9b	a9 cd		lda #$cd			lda 	#PCD_CMD_WORD 				; send .word
.2b9d	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2ba0	68		pla				pla 								; then LSB
.2ba1	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2ba4	98		tya				tya 								; then MSB
.2ba5	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2ba8	60		rts				rts
.2ba9					PushIntegerA:
.2ba9	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.2bab	90 07		bcc $2bb4			bcc 	_PIWriteA
.2bad	48		pha				pha
.2bae	a9 cc		lda #$cc			lda 	#PCD_CMD_BYTE 				; send .byte
.2bb0	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2bb3	68		pla				pla
.2bb4					_PIWriteA:
.2bb4	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2bb7	60		rts				rts
.2bb8					PushFloatCommand:
.2bb8	a9 ce		lda #$ce			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.2bba	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2bbd	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.2bbf	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2bc2	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2bc4	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2bc7	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2bc9	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2bcc	b5 56		lda $56,x			lda 	NSMantissa2,x
.2bce	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2bd1	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.2bd3	29 80		and #$80			and 	#$80
.2bd5	15 62		ora $62,x			ora 	NSMantissa3,x
.2bd7	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2bda	60		rts				rts
.2bdb					CreateVariableRecord:
.2bdb	48		pha				pha
.2bdc	ad cd 06	lda $06cd			lda 	freeVariableMemory 		; push current free address on stack.
.2bdf	48		pha				pha
.2be0	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2be3	48		pha				pha
.2be4	ad cb 06	lda $06cb			lda 	variableListEnd  		; copy end of list to zTemp0
.2be7	85 2c		sta $2c				sta 	zTemp0
.2be9	ad cc 06	lda $06cc			lda 	variableListEnd+1
.2bec	85 2d		sta $2d				sta 	zTemp0+1
.2bee	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.2bf0	92 2c		sta ($2c)			sta 	(zTemp0)
.2bf2	98		tya				tya
.2bf3	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.2bf5	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bf7	88		dey				dey
.2bf8	8a		txa				txa
.2bf9	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bfb	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.2bfd	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2c00	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2c02	c8		iny				iny
.2c03	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2c06	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2c08	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.2c0a	a9 00		lda #$00			lda 	#0
.2c0c	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2c0e	18		clc				clc
.2c0f	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.2c11	6d cb 06	adc $06cb			adc  	variableListEnd
.2c14	8d cb 06	sta $06cb			sta 	variableListEnd
.2c17	90 03		bcc $2c1c			bcc 	_CVNoCarry2
.2c19	ee cc 06	inc $06cc			inc 	variableListEnd+1
.2c1c					_CVNoCarry2:
.2c1c	7a		ply				ply
.2c1d	fa		plx				plx
.2c1e	68		pla				pla
.2c1f	60		rts				rts
.2c20					SetVariableRecordToCodePosition:
.2c20	48		pha				pha
.2c21	5a		phy				phy
.2c22	a0 03		ldy #$03			ldy 	#3
.2c24	a5 2b		lda $2b				lda 	objPtr+1
.2c26	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2c28	c8		iny				iny
.2c29	a5 2a		lda $2a				lda 	objPtr
.2c2b	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2c2d	7a		ply				ply
.2c2e	68		pla				pla
.2c2f	60		rts				rts
.2c30					AllocateBytesForType:
.2c30	48		pha				pha
.2c31	da		phx				phx
.2c32	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.2c34	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2c36	c9 00		cmp #$00			cmp 	#NSSIFloat
.2c38	d0 02		bne $2c3c			bne 	_CVNotFloat
.2c3a	a2 06		ldx #$06			ldx 	#6
.2c3c					_CVNotFloat:
.2c3c	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.2c3d	18		clc				clc
.2c3e	6d cd 06	adc $06cd			adc 	freeVariableMemory
.2c41	8d cd 06	sta $06cd			sta 	freeVariableMemory
.2c44	90 03		bcc $2c49			bcc 	_CVNoCarry1
.2c46	ee ce 06	inc $06ce			inc 	freeVariableMemory+1
.2c49					_CVNoCarry1:
.2c49	fa		plx				plx
.2c4a	68		pla				pla
.2c4b	60		rts				rts
.2c4c					CommandDATA:
.2c4c	20 b7 2a	jsr $2ab7			jsr 	BufferClear 				; copy it to the buffer
.2c4f	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace
.2c52					_CTDataLoop:
.2c52	20 ef 33	jsr $33ef			jsr 	LookNext 					; reached EOL
.2c55	f0 08		beq $2c5f			beq 	_CTDataDone
.2c57	20 bb 2a	jsr $2abb			jsr 	BufferWrite 				; write and consume
.2c5a	20 00 34	jsr $3400			jsr 	GetNext
.2c5d	80 f3		bra $2c52			bra 	_CTDataLoop
.2c5f					_CTDataDone:
.2c5f	a9 d0		lda #$d0			lda 	#PCD_CMD_DATA 				; output command and buffer
.2c61	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2c64	20 c7 2a	jsr $2ac7			jsr 	BufferOutput
.2c67	60		rts				rts
.2c68					CommandDEF:
.2c68	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.2c6a	20 a9 2b	jsr $2ba9			jsr 	PushIntegerA
.2c6d	20 10 35	jsr $3510			jsr 	CompileGotoEOL 				; compile skip over DEF
.2c70	a9 a5		lda #$a5			lda 	#C64_FN
.2c72	20 e8 2a	jsr $2ae8			jsr 	CheckNextA
.2c75	20 0b 34	jsr $340b			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2c78	20 70 34	jsr $3470			jsr 	ExtractVariableName
.2c7b	8a		txa				txa
.2c7c	10 51		bpl $2ccf			bpl 	_CDError
.2c7e	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2c7f	29 7f		and #$7f			and 	#$7F
.2c81	aa		tax				tax
.2c82	98		tya				tya
.2c83	09 80		ora #$80			ora 	#$80
.2c85	a8		tay				tay
.2c86	20 50 2e	jsr $2e50			jsr 	FindVariable				; does it already exist ?
.2c89	b0 44		bcs $2ccf			bcs 	_CDError 					; if so, that's an error.
.2c8b	20 db 2b	jsr $2bdb			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.2c8e	20 20 2c	jsr $2c20			jsr 	SetVariableRecordToCodePosition
.2c91	20 0b 34	jsr $340b			jsr 	GetNextNonSpace
.2c94	20 90 37	jsr $3790			jsr 	GetReferenceTerm 			; get var ref, not array
.2c97	c9 00		cmp #$00			cmp 	#0
.2c99	30 34		bmi $2ccf			bmi 	_CDError
.2c9b	8d c3 06	sta $06c3			sta 	defType 					; save type
.2c9e	8e c4 06	stx $06c4			stx 	defVariable 				; save var ref
.2ca1	8c c5 06	sty $06c5			sty 	defVariable+1
.2ca4	29 40		and #$40			and 	#NSSString 					; only numbers.
.2ca6	d0 27		bne $2ccf			bne 	_CDError
.2ca8	20 e2 2a	jsr $2ae2			jsr 	CheckNextRParen 			; check )
.2cab	a9 b2		lda #$b2			lda 	#C64_EQUAL
.2cad	20 e8 2a	jsr $2ae8			jsr 	CheckNextA 					; check =
.2cb0	18		clc				clc 								; if this is DEF FNxx(A), read A
.2cb1	20 d2 2c	jsr $2cd2			jsr 	CDReadWriteVariable
.2cb4	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.2cb6	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2cb9	38		sec				sec
.2cba	20 d2 2c	jsr $2cd2			jsr 	CDReadWriteVariable 		; A is now updated
.2cbd	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0 		; the actual body of the function.
.2cc0	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.2cc2	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2cc5	38		sec				sec
.2cc6	20 d2 2c	jsr $2cd2			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.2cc9	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.2ccb	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2cce	60		rts				rts
.2ccf					_CDError:
.2ccf	4c 59 1f	jmp $1f59		jmp	ErrorV_syntax
.2cd2					CDReadWriteVariable:
.2cd2	ac c5 06	ldy $06c5			ldy 	defVariable+1 				; set up YX
.2cd5	ae c4 06	ldx $06c4			ldx 	defVariable
.2cd8	ad c3 06	lda $06c3			lda 	defType
.2cdb	20 42 37	jsr $3742			jsr 	GetSetVariable
.2cde	60		rts				rts
.06c3					defType:
>06c3							.fill 	1
.06c4					defVariable:
>06c4							.fill 	2
.2cdf					CommandDIM:
.2cdf	20 0b 34	jsr $340b			jsr 	GetNextNonSpace 			; get the first non space character
.2ce2	20 70 34	jsr $3470			jsr 	ExtractVariableName 		; variable name to XY
.2ce5	da		phx				phx 								; save name with type bits.
.2ce6	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.2ce8	10 37		bpl $2d21			bpl 	_CDError
.2cea	20 50 2e	jsr $2e50			jsr 	FindVariable	 			; see if already exist
.2ced	b0 35		bcs $2d24			bcs 	_CDRedefine 				; it still exists.
.2cef	20 db 2b	jsr $2bdb			jsr 	CreateVariableRecord 		; create the basic variable
.2cf2	20 30 2c	jsr $2c30			jsr 	AllocateBytesForType 		; allocate memory for it
.2cf5	68		pla				pla 								; restore type bits
.2cf6	5a		phy				phy 								; save the address of the basic storage
.2cf7	da		phx				phx
.2cf8	48		pha				pha
.2cf9	20 27 2d	jsr $2d27			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.2cfc	68		pla				pla
.2cfd	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.2cff	20 a9 2b	jsr $2ba9			jsr 	PushIntegerA 				; push that type data out.
.2d02	a9 cb		lda #$cb			lda 	#(PCD_DIM) >> 8
.2d04	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2d07	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.2d09	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2d0c	fa		plx				plx 								; restore address
.2d0d	7a		ply				ply
.2d0e	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2d10	38		sec				sec
.2d11	20 42 37	jsr $3742			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.2d14	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; , follows ?
.2d17	c9 2c		cmp #$2c			cmp 	#","
.2d19	d0 05		bne $2d20			bne 	_CDExit
.2d1b	20 00 34	jsr $3400			jsr 	GetNext 					; consume comma
.2d1e	80 bf		bra $2cdf			bra 	CommandDIM 					; do another DIM
.2d20					_CDExit:
.2d20	60		rts				rts
.2d21					_CDError:
.2d21	4c 59 1f	jmp $1f59		jmp	ErrorV_syntax
.2d24					_CDRedefine:
.2d24	4c 21 20	jmp $2021		jmp	ErrorV_redefine
.2d27					OutputIndexGroup:
.2d27	9c c6 06	stz $06c6			stz 	IndexCount 					; count of number of indices.
.2d2a					_OIGNext:
.2d2a	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0 		; get a dimension
.2d2d	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2d2f	c9 00		cmp #$00			cmp 	#NSSIFloat
.2d31	d0 19		bne $2d4c			bne 	_OIGType
.2d33	ee c6 06	inc $06c6			inc 	IndexCount 					; bump the counter.
.2d36	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; does a , follow ?
.2d39	c9 2c		cmp #$2c			cmp 	#","
.2d3b	d0 05		bne $2d42			bne 	_OIGCheckEnd
.2d3d	20 00 34	jsr $3400			jsr 	GetNext 					; consume comma
.2d40	80 e8		bra $2d2a			bra 	_OIGNext 					; get next dimension
.2d42					_OIGCheckEnd:
.2d42	20 e2 2a	jsr $2ae2			jsr 	CheckNextRParen 			; check and consume )
.2d45	ad c6 06	lda $06c6			lda 	IndexCount
.2d48	20 a9 2b	jsr $2ba9			jsr 	PushIntegerA 				; compile the dimension count.
.2d4b	60		rts				rts
.2d4c					_OIGType:
.2d4c	4c 69 1f	jmp $1f69		jmp	ErrorV_type
.06c6					IndexCount:
>06c6							.fill 	1
.2d4f					CompilerErrorHandler:
.2d4f	68		pla				pla
.2d50	7a		ply				ply
.2d51	85 2c		sta $2c				sta 	zTemp0
.2d53	84 2d		sty $2d				sty 	zTemp0+1
.2d55	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.2d57	a0 01		ldy #$01			ldy 	#1
.2d59					_EHDisplayMsg:
.2d59	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d5b	20 8d 2a	jsr $2a8d			jsr 	PrintCharacter
.2d5e	c8		iny				iny
.2d5f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d61	d0 f6		bne $2d59			bne 	_EHDisplayMsg
.2d63	a9 20		lda #$20			lda 	#32
.2d65	20 8d 2a	jsr $2a8d			jsr 	PrintCharacter
.2d68	a9 40		lda #$40			lda 	#64
.2d6a	20 8d 2a	jsr $2a8d			jsr 	PrintCharacter
.2d6d	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.2d6f	20 b3 26	jsr $26b3			jsr 	FloatSetByte
.2d72	20 79 2a	jsr $2a79			jsr 	GetLineNumber
.2d75	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2d77	98		tya				tya
.2d78	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2d7a	20 99 25	jsr $2599			jsr 	FloatToString
.2d7d	a0 00		ldy #$00			ldy 	#0 							; display that string.
.2d7f	a2 00		ldx #$00			ldx 	#0
.2d81					_EHDisplayLine:
.2d81	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d84	20 8d 2a	jsr $2a8d			jsr 	PrintCharacter
.2d87	c8		iny				iny
.2d88	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d8b	d0 f4		bne $2d81			bne 	_EHDisplayLine
.2d8d	a9 0d		lda #$0d			lda 	#13
.2d8f	20 8d 2a	jsr $2a8d			jsr 	PrintCharacter
.2d92	38		sec				sec 								; CS = error
.2d93	4c 8e 2b	jmp $2b8e			jmp 	ExitCompiler
.2d96					CompileExpressionAt0:
.2d96	a9 00		lda #$00			lda 	#0
.2d98					CompileExpressionAtA:
.2d98	48		pha				pha  								; save level
.2d99	20 1a 38	jsr $381a			jsr 	CompileTerm 				; compile a term.
.2d9c	fa		plx				plx 								; get level back into X
.2d9d					_ECALoop:
.2d9d	48		pha				pha 								; save type on stack.
.2d9e	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; get the next character
.2da1	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.2da3	90 04		bcc $2da9			bcc 	_ECAExit
.2da5	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.2da7	90 02		bcc $2dab			bcc 	_ECAHaveToken
.2da9					_ECAExit:
.2da9	68		pla				pla 								; throw type off stack
.2daa	60		rts				rts
.2dab					_ECAHaveToken:
.2dab	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.2dad	aa		tax				tax 								; X contains the operator token
.2dae	bd 99 2d	lda $2d99,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.2db1	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.2db3	90 f4		bcc $2da9			bcc 	_ECAExit
.2db5	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.2db7	20 00 34	jsr $3400			jsr 	GetNext 					; consume the token.
.2dba	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.2dbc	f0 11		beq $2dcf			beq 	_ECAGreaterCheck
.2dbe	e0 b3		cpx #$b3			cpx 	#C64_LESS
.2dc0	d0 1a		bne $2ddc			bne 	_ECAHaveFullToken
.2dc2	20 ef 33	jsr $33ef			jsr 	LookNext 					; checks for < (<= or <>)
.2dc5	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.2dc7	f0 0e		beq $2dd7			beq	 	_ECAToNotEqual
.2dc9	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.2dcb	d0 0f		bne $2ddc			bne 	_ECAHaveFullToken
.2dcd	80 07		bra $2dd6			bra 	_ECAAddEqual
.2dcf					_ECAGreaterCheck:
.2dcf	20 ef 33	jsr $33ef			jsr 	LookNext
.2dd2	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.2dd4	d0 06		bne $2ddc			bne 	_ECAHaveFullToken
.2dd6					_ECAAddEqual:
.2dd6	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.2dd7					_ECAToNotEqual:
.2dd7	e8		inx				inx
.2dd8	e8		inx				inx
.2dd9	20 00 34	jsr $3400			jsr 	GetNext 					; consume the = or > in >= <= <>
.2ddc					_ECAHaveFullToken:
.2ddc	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.2dde	d0 0a		bne $2dea			bne 	_ECANotConcat
.2de0	68		pla				pla 								; get type back
.2de1	48		pha				pha
.2de2	29 40		and #$40			and 	#NSSTypeMask
.2de4	c9 40		cmp #$40			cmp 	#NSSString
.2de6	d0 02		bne $2dea			bne 	_ECANotConcat
.2de8	a2 e0		ldx #$e0			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2dea					_ECANotConcat:
.2dea	da		phx				phx 								; save operator on the stack
.2deb	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.2ded	da		phx				phx
.2dee	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.2df0	1a		inc a				inc 	a
.2df1	20 98 2d	jsr $2d98			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.2df4	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.2df6	fa		plx				plx 								; restore current precedence in X
.2df7	68		pla				pla 								; restore operator
.2df8	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.2dfa	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.2dfc	90 17		bcc $2e15			bcc 	_ECANotCompare
.2dfe	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.2e00	b0 13		bcs $2e15			bcs 	_ECANotCompare
.2e02	7a		ply				ply 								; get type into Y
.2e03	5a		phy				phy
.2e04	48		pha				pha 								; save operator
.2e05	98		tya				tya 								; get type
.2e06	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.2e08	29 40		and #$40			and 	#NSSTypeMask
.2e0a	c9 40		cmp #$40			cmp 	#NSSString
.2e0c	f0 02		beq $2e10			beq 	_ECANotString
.2e0e	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.2e10					_ECANotString:
.2e10	98		tya				tya									; output token Y
.2e11	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2e14	68		pla				pla 								; restore operator.
.2e15					_ECANotCompare:
.2e15	18		clc				clc 								; convert to P-Code and compile.
.2e16	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.2e18	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2e1b	68		pla				pla 								; type of current result
.2e1c	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.2e1e	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.2e20	d0 19		bne $2e3b			bne		_ECAType
.2e22	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.2e24	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.2e26	d0 18		bne $2e40			bne 	_ECAGoLoop
.2e28	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.2e2a	c9 e0		cmp #$e0			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2e2c	f0 10		beq $2e3e			beq 	_ECAOkayString 				; (this is post conversion)
.2e2e	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.2e30	90 09		bcc $2e3b			bcc 	_ECAType
.2e32	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.2e34	b0 05		bcs $2e3b			bcs 	_ECAType
.2e36	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.2e38	4c 9d 2d	jmp $2d9d			jmp 	_ECALoop
.2e3b					_ECAType:
.2e3b	4c 69 1f	jmp $1f69		jmp	ErrorV_type
.2e3e					_ECAOkayString:
.2e3e	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.2e40					_ECAGoLoop:
.2e40	4c 9d 2d	jmp $2d9d			jmp 	_ECALoop
.2e43					PrecedenceTable:
>2e43	03						.byte 	3 					; '+'
>2e44	03						.byte 	3 					; '-'
>2e45	04						.byte 	4 					; '*'
>2e46	04						.byte 	4 					; '/'
>2e47	05						.byte 	5 					; '^'
>2e48	01						.byte 	1 					; 'and'
>2e49	00						.byte 	0 					; 'or'
>2e4a	02						.byte 	2 					; '>'
>2e4b	02						.byte 	2 					; '='
>2e4c	02						.byte 	2 					; '<'
>2e4d	02						.byte 	2 					; '>='
>2e4e	02						.byte 	2 					; '<='
>2e4f	02						.byte 	2 					; '<>'
.2e50					FindVariable:
.2e50	86 2e		stx $2e				stx 	zTemp1 						; save name.
.2e52	84 2f		sty $2f				sty 	zTemp1+1
.2e54					_IVCheckSpecial:
.2e54	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.2e56	d0 18		bne $2e70			bne 	_IVStandard
.2e58	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.2e5a	f0 0c		beq $2e68			beq 	_IVTIFloat
.2e5c	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.2e5e	d0 10		bne $2e70			bne 	_IVStandard
.2e60	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.2e62	a2 01		ldx #$01			ldx 	#$01
.2e64	a9 40		lda #$40			lda 	#NSSString
.2e66	38		sec				sec
.2e67	60		rts				rts
.2e68					_IVTIFloat:
.2e68	a0 80		ldy #$80			ldy 	#$80
.2e6a	a2 00		ldx #$00			ldx 	#$00
.2e6c	a9 00		lda #$00			lda 	#0
.2e6e	38		sec				sec
.2e6f	60		rts				rts
.2e70					_IVStandard:
.2e70	ad c1 06	lda $06c1			lda 	compilerStartHigh			; start scanning from here.
.2e73	85 2d		sta $2d				sta 	zTemp0+1
.2e75	64 2c		stz $2c				stz 	zTemp0
.2e77					_IVCheckLoop:
.2e77	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.2e79	f0 2b		beq $2ea6			beq  	_IVNotFound 				; if so, return with CC.
.2e7b	a0 01		ldy #$01			ldy 	#1 							; match ?
.2e7d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e7f	c5 2e		cmp $2e				cmp 	zTemp1
.2e81	d0 07		bne $2e8a			bne	 	_IVNext
.2e83	c8		iny				iny
.2e84	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e86	c5 2f		cmp $2f				cmp 	zTemp1+1
.2e88	f0 0d		beq $2e97			beq 	_IVFound
.2e8a					_IVNext:
.2e8a	18		clc				clc
.2e8b	a5 2c		lda $2c				lda 	zTemp0
.2e8d	72 2c		adc ($2c)			adc 	(zTemp0)
.2e8f	85 2c		sta $2c				sta 	zTemp0
.2e91	90 e4		bcc $2e77			bcc 	_IVCheckLoop
.2e93	e6 2d		inc $2d				inc 	zTemp0+1
.2e95	80 e0		bra $2e77			bra 	_IVCheckLoop
.2e97					_IVFound:
.2e97	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.2e99	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e9b	aa		tax				tax
.2e9c	c8		iny				iny
.2e9d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e9f	48		pha				pha
.2ea0	c8		iny				iny
.2ea1	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ea3	7a		ply				ply
.2ea4	38		sec				sec
.2ea5	60		rts				rts
.2ea6					_IVNotFound:
.2ea6	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.2ea8	a4 2f		ldy $2f				ldy 	zTemp1+1
.2eaa	18		clc				clc
.2eab	60		rts				rts
.2eac					FixBranches:
.2eac	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.2eae	20 93 2b	jsr $2b93			jsr 	CallAPIHandler
.2eb1					_FBLoop:
.2eb1	b2 2a		lda ($2a)			lda 	(objPtr) 					; get the next one.
.2eb3	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.2eb5	f0 1a		beq $2ed1			beq 	_FBFixGotoGosub
.2eb7	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOSUB
.2eb9	f0 16		beq $2ed1			beq 	_FBFixGotoGosub
.2ebb	c9 d4		cmp #$d4			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.2ebd	f0 12		beq $2ed1			beq 	_FBFixGotoGosub
.2ebf	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_Z
.2ec1	f0 0e		beq $2ed1			beq 	_FBFixGotoGosub
.2ec3	c9 d5		cmp #$d5			cmp 	#PCD_CMD_VARSPACE
.2ec5	f0 43		beq $2f0a			beq 	_FBFixVarSpace
.2ec7	c9 d6		cmp #$d6			cmp 	#PCD_CMD_RESTORE 			; patch restore.
.2ec9	f0 06		beq $2ed1			beq 	_FBFixRestore
.2ecb					_FBNext:
.2ecb	20 7f 20	jsr $207f			jsr 	MoveObjectForward 			; move forward in object code.
.2ece	90 e1		bcc $2eb1			bcc 	_FBLoop 					; not finished
.2ed0					_FBExit:
.2ed0	60		rts				rts
.2ed1					_FBFixGotoGosub:
.2ed1					_FBFixRestore:
.2ed1	a0 01		ldy #$01			ldy 	#1							; line number in YA
.2ed3	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ed5	48		pha				pha
.2ed6	c8		iny				iny
.2ed7	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ed9	a8		tay				tay
.2eda	68		pla				pla
.2edb	20 b1 35	jsr $35b1			jsr 	STRFindLine			 		; find where it is YA
.2ede	90 0c		bcc $2eec			bcc 	_FBFFound 					; not found, so must be >
.2ee0	48		pha				pha
.2ee1	b2 2a		lda ($2a)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.2ee3	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_Z 			; or RESTORE. These go to the next line
.2ee5	f0 04		beq $2eeb			beq 	_FBFAllowZero 				; after ; for IF forward scanning, and
.2ee7	c9 d6		cmp #$d6			cmp 	#PCD_CMD_RESTORE 			; because RESTORE <n> <n> is optional.
.2ee9	d0 0f		bne $2efa			bne 	_FBFFail
.2eeb					_FBFAllowZero:
.2eeb	68		pla				pla
.2eec					_FBFFound:
.2eec	20 01 36	jsr $3601			jsr 	STRMakeOffset 				; make it an offset from X:YA
.2eef	5a		phy				phy	 								; patch the GOTO/GOSUB
.2ef0	a0 01		ldy #$01			ldy 	#1
.2ef2	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ef4	c8		iny				iny
.2ef5	68		pla				pla
.2ef6	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ef8	80 d1		bra $2ecb			bra 	_FBNext
.2efa					_FBFFail:
.2efa	a0 02		ldy #$02			ldy 	#2
.2efc	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2efe	8d ba 05	sta $05ba			sta 	currentLineNumber
.2f01	c8		iny				iny
.2f02	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2f04	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2f07	4c 9c 1f	jmp $1f9c		jmp	ErrorV_line
.2f0a					_FBFixVarSpace:
.2f0a	a0 01		ldy #$01			ldy 	#1
.2f0c	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2f0f	91 2a		sta ($2a),y			sta 	(objPtr),y
.2f11	c8		iny				iny
.2f12	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2f15	91 2a		sta ($2a),y			sta 	(objPtr),y
.2f17	80 b2		bra $2ecb			bra 	_FBNext
.2f19					CommandFOR:
.2f19	20 0b 34	jsr $340b			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.2f1c	20 21 34	jsr $3421			jsr 	CharIsAlpha 				; if not alpha , error
.2f1f	90 59		bcc $2f7a			bcc 	_CFFail
.2f21	20 90 37	jsr $3790			jsr 	GetReferenceTerm 			; figure out the reference.
.2f24	48		pha				pha 								; save type
.2f25	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f27	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f29	d0 4f		bne $2f7a			bne 	_CFFail
.2f2b	5a		phy				phy 								; save reference on the stack
.2f2c	da		phx				phx
.2f2d	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.2f2f	20 e8 2a	jsr $2ae8			jsr 	CheckNextA
.2f32	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0 		; initial value
.2f35	fa		plx				plx 								; get reference back.
.2f36	7a		ply				ply
.2f37	5a		phy				phy
.2f38	da		phx				phx
.2f39	38		sec				sec 								; set initial value.
.2f3a	20 42 37	jsr $3742			jsr 	GetSetVariable
.2f3d	fa		plx				plx
.2f3e	7a		ply				ply
.2f3f	68		pla				pla
.2f40	29 20		and #$20			and 	#NSSIInt16
.2f42	f0 04		beq $2f48			beq 	_CFNotInt16
.2f44	98		tya				tya
.2f45	09 80		ora #$80			ora 	#$80
.2f47	a8		tay				tay
.2f48					_CFNotInt16:
.2f48	8a		txa				txa 								; reference in YA
.2f49	20 96 2b	jsr $2b96			jsr 	PushIntegerYA
.2f4c	a9 a4		lda #$a4			lda 	#C64_TO
.2f4e	20 e8 2a	jsr $2ae8			jsr 	CheckNextA
.2f51	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0 		; terminal value
.2f54	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f56	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f58	d0 20		bne $2f7a			bne 	_CFFail
.2f5a	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; followed by STEP
.2f5d	c9 a9		cmp #$a9			cmp 	#C64_STEP
.2f5f	d0 0e		bne $2f6f			bne 	_CFNoStep
.2f61	20 00 34	jsr $3400			jsr 	GetNext 					; consume it.
.2f64	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0 		; terminal value
.2f67	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f69	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f6b	d0 0d		bne $2f7a			bne 	_CFFail
.2f6d	80 05		bra $2f74			bra 	_CFParametersDone
.2f6f					_CFNoStep:
.2f6f	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.2f71	20 a9 2b	jsr $2ba9			jsr 	PushIntegerA
.2f74					_CFParametersDone:
.2f74	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2f76	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2f79	60		rts				rts
.2f7a					_CFFail:
.2f7a	4c 59 1f	jmp $1f59		jmp	ErrorV_syntax
.2f7d					FNCompile:
.2f7d	20 0b 34	jsr $340b			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2f80	20 70 34	jsr $3470			jsr 	ExtractVariableName
.2f83	e0 00		cpx #$00			cpx 	#0
.2f85	10 32		bpl $2fb9			bpl 	_FNError
.2f87	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2f88	29 7f		and #$7f			and 	#$7F
.2f8a	aa		tax				tax
.2f8b	98		tya				tya
.2f8c	09 80		ora #$80			ora 	#$80
.2f8e	a8		tay				tay
.2f8f	20 50 2e	jsr $2e50			jsr 	FindVariable				; does it already exist ?
.2f92	90 25		bcc $2fb9			bcc 	_FNError 					; no.
.2f94	20 01 36	jsr $3601			jsr 	STRMakeOffset 				; convert to a relative address.
.2f97	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2f99	d0 01		bne $2f9c			bne 	_FNNoBorrow
.2f9b	88		dey				dey
.2f9c					_FNNoBorrow:
.2f9c	3a		dec a				dec 	a
.2f9d	5a		phy				phy 								; save location of routine on stack.
.2f9e	48		pha				pha
.2f9f	da		phx				phx
.2fa0	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0
.2fa3	20 e2 2a	jsr $2ae2			jsr 	CheckNextRParen
.2fa6	a9 d2		lda #$d2			lda 	#PCD_CMD_GOSUB
.2fa8	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2fab	68		pla				pla
.2fac	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2faf	68		pla				pla
.2fb0	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2fb3	68		pla				pla
.2fb4	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.2fb7	18		clc				clc
.2fb8	60		rts				rts
.2fb9					_FNError:
.2fb9	4c 4c 1f	jmp $1f4c		jmp	ErrorV_value
.2fbc					CommandTables:
>2fbc	07 cb 00 03 ce 34 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2fc3	07 89 00 03 d5 34 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2fca	07 8d 00 03 c8 34 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>2fd1	07 8c 00 03 fb 37 06			.byte	$07,$8c,$00,$03,CommandRESTORE & $FF,CommandRESTORE >> 8,$06
>2fd8	07 88 00 03 44 35 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2fdf	07 85 00 03 24 35 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>2fe6	07 84 00 04 38 35 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>2fed	07 99 00 03 88 36 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2ff4	07 98 00 04 88 36 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2ffb	07 8f 00 03 c8 37 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>3002	07 81 00 03 19 2f 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>3009	07 82 00 03 0b 36 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>3010	07 a1 00 03 41 34 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>3017	07 83 00 03 4c 2c 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>301e	07 87 00 03 06 37 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>3025	07 86 00 03 df 2c 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>302c	07 96 00 03 68 2c 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>3033	07 8b 00 e3 f1 34 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>303a	08 92 00 ea e3 b3 38 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>3042	09 91 00 e1 a9 03 37 36			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>304a	06
>304b	07 9e 00 e2 cb 92 06			.byte	$07,$9e,$00,$e2,37579 & $FF,37579 >> 8,$06
>3052	07 97 00 ea e1 ad 06			.byte	$07,$97,$00,$ea,$e1,173,$06
>3059	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>305f	07 90 00 20 cb 91 06			.byte	$07,$90,$00,$20,37323 & $FF,37323 >> 8,$06
>3066	07 80 00 20 cb 82 06			.byte	$07,$80,$00,$20,33483 & $FF,33483 >> 8,$06
>306d	07 9d 00 e3 d9 38 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>3074	0a 9f 00 ea e3 ec 38 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,199,$06
>307c	c7 06
>307e	06 a0 00 e1 c4 06			.byte	$06,$a0,$00,$e1,196,$06
>3084	07 ce 90 20 cb ad 06			.byte	$07,$ce,$90,$20,44491 & $FF,44491 >> 8,$06
>308b	0a ce 92 e3 be 33 20 cb			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44747 & $FF,44747 >> 8,$06
>3093	ae 06
>3095	0a ce 8d e3 be 33 20 cb			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,45003 & $FF,45003 >> 8,$06
>309d	af 06
>309f	06 ce 86 e1 c8 06			.byte	$06,$ce,$86,$e1,200,$06
>30a5	08 ce 84 ea ea e1 c9 06			.byte	$08,$ce,$84,$ea,$ea,$e1,201,$06
>30ad	07 ce af e2 cb 99 06			.byte	$07,$ce,$af,$e2,39371 & $FF,39371 >> 8,$06
>30b4	07 ce 8c e2 cb 8c 06			.byte	$07,$ce,$8c,$e2,36043 & $FF,36043 >> 8,$06
>30bb	09 ce ae ea ea e2 cb 96			.byte	$09,$ce,$ae,$ea,$ea,$e2,38603 & $FF,38603 >> 8,$06
>30c3	06
>30c4	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>30cc	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>30d4	9a 06
>30d6	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>30de	9b 06
>30e0	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>30e8	9c 06
>30ea	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>30f2	06
>30f3	07 ce 99 20 cb 9a 06			.byte	$07,$ce,$99,$20,39627 & $FF,39627 >> 8,$06
>30fa	08 ce 9a ea e2 cb 9b 06			.byte	$08,$ce,$9a,$ea,$e2,39883 & $FF,39883 >> 8,$06
>3102	08 ce 9b ea e2 cb 9c 06			.byte	$08,$ce,$9b,$ea,$e2,40139 & $FF,40139 >> 8,$06
>310a	08 ce 9c ea e2 cb 9d 06			.byte	$08,$ce,$9c,$ea,$e2,40395 & $FF,40395 >> 8,$06
>3112	08 ce 9d ea e2 cb 9e 06			.byte	$08,$ce,$9d,$ea,$e2,40651 & $FF,40651 >> 8,$06
>311a	08 ce 9e ea e2 cb 9f 06			.byte	$08,$ce,$9e,$ea,$e2,40907 & $FF,40907 >> 8,$06
>3122	08 ce 9f ea e2 cb a0 06			.byte	$08,$ce,$9f,$ea,$e2,41163 & $FF,41163 >> 8,$06
>312a	08 ce a0 ea e2 cb a1 06			.byte	$08,$ce,$a0,$ea,$e2,41419 & $FF,41419 >> 8,$06
>3132	08 ce a1 ea f2 cb a2 06			.byte	$08,$ce,$a1,$ea,$f2,41675 & $FF,41675 >> 8,$06
>313a	08 ce a2 ea f2 cb a3 06			.byte	$08,$ce,$a2,$ea,$f2,41931 & $FF,41931 >> 8,$06
>3142	08 ce a3 ea e2 cb a4 06			.byte	$08,$ce,$a3,$ea,$e2,42187 & $FF,42187 >> 8,$06
>314a	07 ce a4 20 cb a5 06			.byte	$07,$ce,$a4,$20,42443 & $FF,42443 >> 8,$06
>3151	08 ce a5 ea e2 cb a6 06			.byte	$08,$ce,$a5,$ea,$e2,42699 & $FF,42699 >> 8,$06
>3159	08 ce a6 ea e2 cb a7 06			.byte	$08,$ce,$a6,$ea,$e2,42955 & $FF,42955 >> 8,$06
>3161	08 ce a7 ea e2 cb a8 06			.byte	$08,$ce,$a7,$ea,$e2,43211 & $FF,43211 >> 8,$06
>3169	08 ce a8 ea e2 cb a9 06			.byte	$08,$ce,$a8,$ea,$e2,43467 & $FF,43467 >> 8,$06
>3171	08 ce a9 ea e2 cb aa 06			.byte	$08,$ce,$a9,$ea,$e2,43723 & $FF,43723 >> 8,$06
>3179	08 ce aa ea f2 cb ab 06			.byte	$08,$ce,$aa,$ea,$f2,43979 & $FF,43979 >> 8,$06
>3181	08 ce ab ea f2 cb ac 06			.byte	$08,$ce,$ab,$ea,$f2,44235 & $FF,44235 >> 8,$06
>3189	00						.byte 	0
.318a					UnaryTables:
>318a	07 b4 00 8e 91 b7 06			.byte	$07,$b4,$00,$8e,$91,183,$06
>3191	08 b5 00 8e 92 cb 84 06			.byte	$08,$b5,$00,$8e,$92,33995 & $FF,33995 >> 8,$06
>3199	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>31a0	07 b7 00 8e 91 c2 06			.byte	$07,$b7,$00,$8e,$91,194,$06
>31a7	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>31ae	07 b9 00 8e 91 ae 06			.byte	$07,$b9,$00,$8e,$91,174,$06
>31b5	08 ba 00 8e 92 cb 85 06			.byte	$08,$ba,$00,$8e,$92,34251 & $FF,34251 >> 8,$06
>31bd	07 bb 00 8e 91 b5 06			.byte	$07,$bb,$00,$8e,$91,181,$06
>31c4	08 bc 00 8e 92 cb 86 06			.byte	$08,$bc,$00,$8e,$92,34507 & $FF,34507 >> 8,$06
>31cc	08 bd 00 8e 92 cb 87 06			.byte	$08,$bd,$00,$8e,$92,34763 & $FF,34763 >> 8,$06
>31d4	08 be 00 8e 92 cb 88 06			.byte	$08,$be,$00,$8e,$92,35019 & $FF,35019 >> 8,$06
>31dc	08 bf 00 8e 92 cb 89 06			.byte	$08,$bf,$00,$8e,$92,35275 & $FF,35275 >> 8,$06
>31e4	08 c0 00 8e 92 cb 8a 06			.byte	$08,$c0,$00,$8e,$92,35531 & $FF,35531 >> 8,$06
>31ec	08 c1 00 8e 92 cb 8b 06			.byte	$08,$c1,$00,$8e,$92,35787 & $FF,35787 >> 8,$06
>31f4	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>31fb	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>3202	07 c4 00 8e 91 bb 07			.byte	$07,$c4,$00,$8e,$91,187,$07
>3209	07 c5 00 8f 91 c3 06			.byte	$07,$c5,$00,$8f,$91,195,$06
>3210	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>3217	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>321e	08 c8 00 8f ae 91 bc 07			.byte	$08,$c8,$00,$8f,$ae,$91,188,$07
>3226	08 c9 00 8f ae 91 bd 07			.byte	$08,$c9,$00,$8f,$ae,$91,189,$07
>322e	0b ca 00 8f ae 03 be 33			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,190,$07
>3236	91 be 07
>3239	07 a8 00 03 dd 33 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>3240	07 a5 00 03 7d 2f 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>3247	06 ff 00 10 ac 06			.byte	$06,$ff,$00,$10,172,$06
>324d	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>3254	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>325b	08 ce d0 8e ae 91 ca 06			.byte	$08,$ce,$d0,$8e,$ae,$91,202,$06
>3263	08 ce d4 8e 92 cb 83 06			.byte	$08,$ce,$d4,$8e,$92,33739 & $FF,33739 >> 8,$06
>326b	07 ce d3 20 cb 8d 06			.byte	$07,$ce,$d3,$20,36299 & $FF,36299 >> 8,$06
>3272	07 ce d1 20 cb 8e 06			.byte	$07,$ce,$d1,$20,36555 & $FF,36555 >> 8,$06
>3279	07 ce d2 20 cb 8f 06			.byte	$07,$ce,$d2,$20,36811 & $FF,36811 >> 8,$06
>3280	07 ce db 20 cb 90 06			.byte	$07,$ce,$db,$20,37067 & $FF,37067 >> 8,$06
>3287	09 ce d7 8e ae 92 cb 97			.byte	$09,$ce,$d7,$8e,$ae,$92,38859 & $FF,38859 >> 8,$06
>328f	06
>3290	00						.byte 	0
.3291					GeneratorProcess:
.3291	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.3293	84 2d		sty $2d				sty 	zTemp0+1
.3295	85 2e		sta $2e				sta 	zTemp1 						; first match token
.3297	64 2f		stz $2f				stz 	zTemp1+1
.3299	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.329b	d0 05		bne $32a2			bne 	_GPNotShifted
.329d	20 00 34	jsr $3400			jsr 	GetNext 					; get the shifted token
.32a0	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.32a2					_GPNotShifted:
.32a2					_GPSearch:
.32a2	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.32a4	18		clc				clc
.32a5	f0 2f		beq $32d6			beq 	_GPExit
.32a7	a0 01		ldy #$01			ldy 	#1 							; tokens match
.32a9	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.32ab	c5 2e		cmp $2e				cmp 	zTemp1
.32ad	d0 09		bne $32b8			bne 	_GPNext
.32af	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.32b1	f0 12		beq $32c5			beq 	_GPFound
.32b3	c8		iny				iny 								; check match.
.32b4	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.32b6	f0 0d		beq $32c5			beq 	_GPFound
.32b8					_GPNext:
.32b8	18		clc				clc 								; follow to next
.32b9	a5 2c		lda $2c				lda 	zTemp0
.32bb	72 2c		adc ($2c)			adc 	(zTemp0)
.32bd	85 2c		sta $2c				sta 	zTemp0
.32bf	90 e1		bcc $32a2			bcc 	_GPSearch
.32c1	e6 2d		inc $2d				inc 	zTemp0+1
.32c3	80 dd		bra $32a2			bra 	_GPSearch
.32c5					_GPFound:
.32c5	18		clc				clc 								; skip to action bytes
.32c6	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.32c8	69 03		adc #$03			adc 	#3
.32ca	85 2c		sta $2c				sta 	zTemp0
.32cc	90 02		bcc $32d0			bcc 	_GPNoCarry
.32ce	e6 2d		inc $2d				inc 	zTemp0+1
.32d0					_GPNoCarry:
.32d0					_GPLoop:
.32d0	20 d7 32	jsr $32d7			jsr 	GeneratorExecute 			; execute one command
.32d3	90 fb		bcc $32d0			bcc 	_GPLoop 					; go back if not completed.
.32d5	38		sec				sec 								; return with CS.
.32d6					_GPExit:
.32d6	60		rts				rts
.32d7					GeneratorExecute:
.32d7	20 83 33	jsr $3383			jsr 	_GEFetchZTemp0 				; get next.
.32da	48		pha				pha 								; split into 2 nibbles
.32db	4a		lsr a				lsr 	a
.32dc	4a		lsr a				lsr 	a
.32dd	4a		lsr a				lsr		a
.32de	4a		lsr a				lsr 	a
.32df	20 e9 32	jsr $32e9			jsr 	_GEExecuteNibble 			; MSB first
.32e2	68		pla				pla
.32e3	b0 03		bcs $32e8			bcs 	_GEHaveCompleted
.32e5	20 e9 32	jsr $32e9			jsr 	_GEExecuteNibble 			; LSB second
.32e8					_GEHaveCompleted:
.32e8	60		rts				rts
.32e9					_GEExecuteNibble:
.32e9	29 0f		and #$0f			and 	#$0F
.32eb	0a		asl a				asl 	a
.32ec	aa		tax				tax
.32ed	7c f0 32	jmp ($32f0,x)			jmp 	(_GEExecuteVectors,x)
.32f0					_GEExecuteVectors:
>32f0	10 33						.word 	_GEXNop 					; 0  (no operation)
>32f2	18 33						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>32f4	12 33						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>32f6	66 33						.word 	_GEXExecute 				; 3  (run arbitrary code)
>32f8	59 33						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>32fa	10 33						.word 	_GEXNop 					; 5
>32fc	20 33						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>32fe	24 33						.word 	_GEXExitString 				; 7  exit return string type
>3300	28 33						.word 	_GEXLParam 					; 8  check ( follows
>3302	2c 33						.word 	_GEXRParam 					; 9  check ) follows
>3304	30 33						.word 	_GEXComma					; A  check , follows
>3306	10 33						.word 	_GEXNop 					; B
>3308	10 33						.word 	_GEXNop 					; C
>330a	10 33						.word 	_GEXNop 					; D
>330c	40 33						.word 	_GEXNumber 					; E  compile get any number
>330e	4b 33						.word 	_GEXString 					; F  compile get any string
.3310					_GEXNop:
.3310	18		clc				clc
.3311	60		rts				rts
.3312					_GEXToken2:
.3312	20 83 33	jsr $3383			jsr 	_GEFetchZTemp0
.3315	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3318					_GEXToken1:
.3318	20 83 33	jsr $3383			jsr 	_GEFetchZTemp0
.331b	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.331e	18		clc				clc
.331f	60		rts				rts
.3320					_GEXExitNumber:
.3320	a9 00		lda #$00			lda 	#NSSIFloat
.3322	38		sec				sec
.3323	60		rts				rts
.3324					_GEXExitString:
.3324	a9 40		lda #$40			lda 	#NSSString
.3326	38		sec				sec
.3327	60		rts				rts
.3328					_GEXLParam:
.3328	a9 28		lda #$28			lda 	#"("
.332a	80 06		bra $3332			bra 	_GEXCheck
.332c					_GEXRParam:
.332c	a9 29		lda #$29			lda 	#")"
.332e	80 02		bra $3332			bra 	_GEXCheck
.3330					_GEXComma:
.3330	a9 2c		lda #$2c			lda 	#","
.3332					_GEXCheck:
.3332	85 30		sta $30				sta 	zTemp2 						; save match
.3334	20 0b 34	jsr $340b			jsr 	GetNextNonSpace 			; get next skipping spaces
.3337	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.3339	d0 02		bne $333d			bne 	_GEXSyntax
.333b	18		clc				clc
.333c	60		rts				rts
.333d					_GEXSyntax:
.333d	4c 59 1f	jmp $1f59		jmp	ErrorV_syntax
.3340					_GEXNumber:
.3340	20 8c 33	jsr $338c			jsr 	GEXCompileExpression 		; compile expression
.3343	29 40		and #$40			and 	#NSSTypeMask
.3345	c9 00		cmp #$00			cmp  	#NSSIFloat
.3347	d0 0d		bne $3356			bne 	_GEXType
.3349	18		clc				clc
.334a	60		rts				rts
.334b					_GEXString:
.334b	20 8c 33	jsr $338c			jsr 	GEXCompileExpression 		; compile expression
.334e	29 40		and #$40			and 	#NSSTypeMask
.3350	c9 40		cmp #$40			cmp  	#NSSString
.3352	d0 02		bne $3356			bne 	_GEXType
.3354	18		clc				clc
.3355	60		rts				rts
.3356					_GEXType:
.3356	4c 69 1f	jmp $1f69		jmp	ErrorV_type
.3359					_GEXChannelExec:
.3359	20 9c 33	jsr $339c			jsr 	ChannelPrefix 				; set up default
.335c	20 66 33	jsr $3366			jsr 	_GEXExecute
.335f	08		php				php
.3360	20 b7 33	jsr $33b7			jsr 	ChannelPostfix 				; replace default.
.3363	28		plp				plp
.3364	60		rts				rts
>3365	db						.byte 	$DB 						; causes a break in the emulator
.3366					_GEXExecute:
.3366	20 83 33	jsr $3383			jsr 	_GEFetchZTemp0 				; get vector
.3369	85 30		sta $30				sta 	zTemp2
.336b	20 83 33	jsr $3383			jsr 	_GEFetchZTemp0
.336e	85 31		sta $31				sta 	zTemp2+1
.3370	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.3372	da		phx				phx
.3373	a6 2d		ldx $2d				ldx 	zTemp0+1
.3375	da		phx				phx
.3376	20 80 33	jsr $3380			jsr 	_GECallZTemp2 				; execute code
.3379	fa		plx				plx 								; recover generation exec
.337a	86 2d		stx $2d				stx 	zTemp0+1
.337c	fa		plx				plx
.337d	86 2c		stx $2c				stx 	zTemp0
.337f	60		rts				rts
.3380					_GECallZTemp2:
.3380	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.3383					_GEFetchZTemp0:
.3383	b2 2c		lda ($2c)			lda 	(zTemp0)
.3385	e6 2c		inc $2c				inc 	zTemp0
.3387	d0 02		bne $338b			bne 	_GEFZ0Skip
.3389	e6 2d		inc $2d				inc 	zTemp0+1
.338b					_GEFZ0Skip:
.338b	60		rts				rts
.338c					GEXCompileExpression:
.338c	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.338e	da		phx				phx
.338f	a6 2d		ldx $2d				ldx 	zTemp0+1
.3391	da		phx				phx
.3392	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0 		; compile expression.
.3395	fa		plx				plx 								; recover generation exec
.3396	86 2d		stx $2d				stx 	zTemp0+1
.3398	fa		plx				plx
.3399	86 2c		stx $2c				stx 	zTemp0
.339b	60		rts				rts
.339c					ChannelPrefix:
.339c	a9 af		lda #$af			lda 	#PCD_GETCHANNEL				; set channel onto stack
.339e	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.33a1	20 8c 33	jsr $338c			jsr 	GEXCompileExpression 		; channel #
.33a4	29 40		and #$40			and 	#NSSTypeMask
.33a6	c9 00		cmp #$00			cmp 	#NSSIFloat
.33a8	d0 0a		bne $33b4			bne 	_CPXType
.33aa	20 de 2a	jsr $2ade			jsr 	CheckNextComma 				; check , follows.
.33ad	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL				; set channel
.33af	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.33b2	18		clc				clc
.33b3	60		rts				rts
.33b4					_CPXType:
.33b4	4c 69 1f	jmp $1f69		jmp	ErrorV_type
.33b7					ChannelPostfix:
.33b7	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.33b9	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.33bc	18		clc				clc
.33bd	60		rts				rts
.33be					OptionalParameterCompile:
.33be	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; what follows.
.33c1	c9 2c		cmp #$2c			cmp 	#","
.33c3	d0 0e		bne $33d3			bne 	_MidDefault
.33c5	20 00 34	jsr $3400			jsr 	GetNext 					; consume ,
.33c8	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0
.33cb	29 40		and #$40			and 	#NSSTypeMask
.33cd	c9 00		cmp #$00			cmp 	#NSSIFloat
.33cf	d0 09		bne $33da			bne 	MidFailType
.33d1	80 05		bra $33d8			bra 	_MidComplete
.33d3					_MidDefault:
.33d3	a9 ff		lda #$ff			lda 	#255 						; default of 255
.33d5	20 a9 2b	jsr $2ba9			jsr 	PushIntegerA
.33d8					_MidComplete:
.33d8	18		clc				clc
.33d9	60		rts				rts
.33da					MidFailType:
.33da	4c 69 1f	jmp $1f69		jmp	ErrorV_type
.33dd					NotUnaryCompile:
.33dd	ad 4b 2e	lda $2e4b			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.33e0	20 98 2d	jsr $2d98			jsr 	CompileExpressionAtA 		; evaluate at that level
.33e3	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.33e5	c9 00		cmp #$00			cmp 	#NSSIFloat
.33e7	d0 f1		bne $33da			bne 	MidFailType
.33e9	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.33eb	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.33ee	60		rts				rts
.33ef					LookNext:
.33ef	b2 7a		lda ($7a)			lda 	(srcPtr)
.33f1	60		rts				rts
.33f2					LookNextNonSpace:
.33f2	b2 7a		lda ($7a)			lda 	(srcPtr)
.33f4	c9 20		cmp #$20			cmp		#' '
.33f6	f0 03		beq $33fb			beq 	_LNNSkip
.33f8	c9 00		cmp #$00			cmp 	#0
.33fa	60		rts				rts
.33fb					_LNNSkip:
.33fb	20 00 34	jsr $3400			jsr 	GetNext
.33fe	80 f2		bra $33f2			bra 	LookNextNonSpace
.3400					GetNext:
.3400	b2 7a		lda ($7a)			lda 	(srcPtr) 					; get next
.3402	e6 7a		inc $7a				inc 	srcPtr
.3404	d0 02		bne $3408			bne 	_GNSkip
.3406	e6 7b		inc $7b				inc 	srcPtr+1
.3408					_GNSkip:
.3408	c9 00		cmp #$00			cmp 	#0
.340a	60		rts				rts
.340b					GetNextNonSpace:
.340b	20 00 34	jsr $3400			jsr 	GetNext
.340e	c9 20		cmp #$20			cmp 	#' '
.3410	f0 f9		beq $340b			beq 	GetNextNonSpace
.3412	c9 00		cmp #$00			cmp 	#0
.3414	60		rts				rts
.3415					CharIsDigit:
.3415	c9 30		cmp #$30			cmp 	#"0"
.3417	90 06		bcc $341f			bcc 	CCFalse
.3419	c9 3a		cmp #$3a			cmp 	#"9"+1
.341b	b0 02		bcs $341f			bcs 	CCFalse
.341d					CCTrue:
.341d	38		sec				sec
.341e	60		rts				rts
.341f					CCFalse:
.341f	18		clc				clc
.3420	60		rts				rts
.3421					CharIsAlpha:
.3421	c9 41		cmp #$41			cmp 	#"A"
.3423	90 fa		bcc $341f			bcc 	CCFalse
.3425	c9 5b		cmp #$5b			cmp 	#"Z"+1
.3427	b0 f6		bcs $341f			bcs 	CCFalse
.3429	80 f2		bra $341d			bra 	CCTrue
.342b					ConvertHexStyle:
.342b	38		sec				sec
.342c	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.342e	90 ef		bcc $341f			bcc 	CCFalse
.3430	c9 0a		cmp #$0a			cmp 	#9+1
.3432	90 e9		bcc $341d			bcc 	CCTrue
.3434	38		sec				sec 								; shift into hex space A=>0 Z=>25
.3435	e9 11		sbc #$11			sbc 	#"A"-"0"
.3437	90 e6		bcc $341f			bcc 	CCFalse
.3439	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.343b	b0 e2		bcs $341f			bcs 	CCFalse
.343d	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.343f	80 dc		bra $341d			bra 	CCTrue
.3441					CommandGET:
.3441	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; # follows ?
.3444	c9 23		cmp #$23			cmp 	#"#"
.3446	d0 0d		bne $3455			bne 	CommandGetBody
.3448	20 00 34	jsr $3400			jsr 	GetNext 					; consume #
.344b	20 9c 33	jsr $339c			jsr 	ChannelPrefix 				; do it as GET#
.344e	20 55 34	jsr $3455			jsr 	CommandGetBody
.3451	20 b7 33	jsr $33b7			jsr 	ChannelPostfix
.3454	60		rts				rts
.3455					CommandGetBody:
.3455	20 0b 34	jsr $340b			jsr 	GetNextNonSpace 			; get the first character
.3458	20 90 37	jsr $3790			jsr 	GetReferenceTerm 			; identify variable to assign to
.345b	48		pha				pha
.345c	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.345e	c9 40		cmp #$40			cmp 	#NSSString
.3460	d0 0b		bne $346d			bne 	_CGType
.3462	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.3464	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3467	38		sec				sec
.3468	68		pla				pla
.3469	20 42 37	jsr $3742			jsr		GetSetVariable
.346c	60		rts				rts
.346d					_CGType:
.346d	4c 69 1f	jmp $1f69		jmp	ErrorV_type
.3470					ExtractVariableName:
.3470	20 21 34	jsr $3421			jsr 	CharIsAlpha
.3473	90 50		bcc $34c5			bcc 	_IVSyntax
.3475	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.3477	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.3479	64 2f		stz $2f				stz 	zTemp1+1
.347b	20 ef 33	jsr $33ef			jsr 	LookNext 					; is there a second character ?
.347e	20 21 34	jsr $3421			jsr 	CharIsAlpha  				; must be alphanumeric
.3481	b0 05		bcs $3488			bcs 	_IVHasSecond
.3483	20 15 34	jsr $3415			jsr 	CharIsDigit
.3486	90 07		bcc $348f			bcc 	_IVCheckType
.3488					_IVHasSecond:
.3488	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.348a	85 2f		sta $2f				sta 	zTemp1+1
.348c					_IVGetNextCheck:
.348c	20 00 34	jsr $3400			jsr 	GetNext 					; consume it
.348f					_IVCheckType:
.348f	20 ef 33	jsr $33ef			jsr 	LookNext					; check if string follows.
.3492	20 21 34	jsr $3421			jsr 	CharIsAlpha
.3495	b0 f5		bcs $348c			bcs 	_IVGetNextCheck
.3497	20 15 34	jsr $3415			jsr 	CharIsDigit
.349a	b0 f0		bcs $348c			bcs 	_IVGetNextCheck
.349c	a2 40		ldx #$40			ldx 	#NSSString
.349e	c9 24		cmp #$24			cmp 	#"$"
.34a0	f0 06		beq $34a8			beq 	_IVHasType
.34a2	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.34a4	c9 25		cmp #$25			cmp 	#"%"
.34a6	d0 08		bne $34b0			bne 	_IVCheckArray
.34a8					_IVHasType:
.34a8	8a		txa				txa 								; Or X into zTemp1
.34a9	05 2e		ora $2e				ora 	zTemp1
.34ab	85 2e		sta $2e				sta 	zTemp1
.34ad	20 00 34	jsr $3400			jsr 	GetNext 					; consume it
.34b0					_IVCheckArray:
.34b0	20 ef 33	jsr $33ef			jsr 	LookNext 					; check if array follows
.34b3	c9 28		cmp #$28			cmp 	#"("
.34b5	d0 09		bne $34c0			bne 	_IVNotArray
.34b7	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.34b9	09 80		ora #$80			ora 	#NSSArray
.34bb	85 2e		sta $2e				sta 	zTemp1
.34bd	20 00 34	jsr $3400			jsr 	GetNext 					; consume it
.34c0					_IVNotArray:
.34c0	a6 2e		ldx $2e				ldx 	zTemp1
.34c2	a4 2f		ldy $2f				ldy 	zTemp1+1
.34c4	60		rts				rts
.34c5					_IVSyntax:
.34c5	4c 59 1f	jmp $1f59		jmp	ErrorV_syntax
.34c8					CommandGOSUB:
.34c8	a9 d2		lda #$d2			lda 	#PCD_CMD_GOSUB
.34ca	20 db 34	jsr $34db			jsr 	CompileBranchCommand
.34cd	60		rts				rts
.34ce					CommandGOAlt:
.34ce	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.34d0	20 e8 2a	jsr $2ae8			jsr 	CheckNextA
.34d3	80 00		bra $34d5			bra 	CommandGOTO
.34d5					CommandGOTO:
.34d5	a9 d1		lda #$d1			lda 	#PCD_CMD_GOTO
.34d7	20 db 34	jsr $34db			jsr 	CompileBranchCommand
.34da	60		rts				rts
.34db					CompileBranchCommand:
.34db	20 80 2a	jsr $2a80			jsr 	WriteCodeByte 				; write the command out.
.34de	20 0b 34	jsr $340b			jsr 	GetNextNonSpace
.34e1	20 63 36	jsr $3663			jsr 	ParseConstant 				; get constant into YA
.34e4	90 08		bcc $34ee			bcc 	_CBCSyntax
.34e6	20 80 2a	jsr $2a80			jsr 	WriteCodeByte				; and compile the actual line number
.34e9	98		tya				tya
.34ea	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.34ed	60		rts				rts
.34ee					_CBCSyntax:
.34ee	4c 59 1f	jmp $1f59		jmp	ErrorV_syntax
.34f1					CommandIF:
.34f1	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; what follows the tests ?
.34f4	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.34f6	f0 0f		beq $3507			beq 	_CIGoto
.34f8	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.34fa	20 e8 2a	jsr $2ae8			jsr 	CheckNextA
.34fd	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; THEN <number>
.3500	20 15 34	jsr $3415			jsr 	CharIsDigit
.3503	b0 05		bcs $350a			bcs 	_CIGoto2
.3505	80 09		bra $3510			bra 	CompileGotoEOL
.3507					_CIGoto:
.3507	20 00 34	jsr $3400			jsr 	GetNext
.350a					_CIGoto2:
.350a	a9 d4		lda #$d4			lda 	#PCD_CMD_GOTOCMD_NZ
.350c	20 db 34	jsr $34db			jsr 	CompileBranchCommand
.350f	60		rts				rts
.3510					CompileGotoEOL:
.3510	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_Z
.3512	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3515	20 79 2a	jsr $2a79			jsr 	GetLineNumber 				; Get the current line number => YA
.3518	1a		inc a				inc 	a 							; and branch to +1
.3519	d0 01		bne $351c			bne 	_CGENoCarry
.351b	c8		iny				iny
.351c					_CGENoCarry:
.351c	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.351f	98		tya				tya
.3520	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3523	60		rts				rts
.3524					CommandINPUT:
.3524	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; check for "
.3527	c9 22		cmp #$22			cmp 	#'"'
.3529	d0 0d		bne $3538			bne 	CommandINPUTStream
.352b	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0
.352e	a9 b2		lda #$b2			lda 	#(PCD_PRINTCMD_S) & $FF
.3530	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3533	a9 2c		lda #$2c			lda 	#","
.3535	20 de 2a	jsr $2ade			jsr 	CheckNextComma
.3538					CommandINPUTStream:
.3538	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.353a	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.353d	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.353f	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.3541	4c 0a 37	jmp $370a			jmp 	CommandReadInputCommon
.3544					CommandLET:
.3544	20 0b 34	jsr $340b			jsr 	GetNextNonSpace 			; get the first character
.3547					CommandLETHaveFirst:
.3547	20 90 37	jsr $3790			jsr 	GetReferenceTerm 			; identify variable to assign to
.354a	da		phx				phx 								; save target on the stack.
.354b	5a		phy				phy
.354c	48		pha				pha
.354d	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.354f	20 e8 2a	jsr $2ae8			jsr 	CheckNextA
.3552	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.3555	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.3557	68		pla				pla 								; get type of assignment
.3558	48		pha				pha
.3559	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.355b	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.355d	d0 26		bne $3585			bne 	_CLType
.355f	68		pla				pla 								; restore and compile save code
.3560	7a		ply				ply
.3561	fa		plx				plx
.3562	c0 80		cpy #$80			cpy 	#$80 						; is it TI = xxxxx
.3564	f0 09		beq $356f			beq 	_CLTINumber
.3566	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.3568	f0 10		beq $357a			beq 	_CLTIString
.356a	38		sec				sec
.356b	20 42 37	jsr $3742			jsr		GetSetVariable
.356e	60		rts				rts
.356f					_CLTINumber:
.356f	a9 cb		lda #$cb			lda 	#(PCD_TICMD_WRITE) >> 8
.3571	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3574	a9 93		lda #$93			lda 	#(PCD_TICMD_WRITE) & $FF
.3576	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3579	60		rts				rts
.357a					_CLTIString:
.357a	a9 cb		lda #$cb			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.357c	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.357f	a9 94		lda #$94			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.3581	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3584	60		rts				rts
.3585					_CLType:
.3585	4c 69 1f	jmp $1f69		jmp	ErrorV_type
.3588					STRMarkLine:
.3588	48		pha				pha
.3589	38		sec				sec 								; allocate 4 bytes (line #,address)
.358a	ad c9 06	lda $06c9			lda 	lineNumberTable 			; and copy to zTemp0
.358d	e9 04		sbc #$04			sbc 	#4
.358f	8d c9 06	sta $06c9			sta 	lineNumberTable
.3592	85 2c		sta $2c				sta 	zTemp0
.3594	ad ca 06	lda $06ca			lda 	lineNumberTable+1
.3597	e9 00		sbc #$00			sbc 	#0
.3599	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.359c	85 2d		sta $2d				sta 	zTemp0+1
.359e	68		pla				pla
.359f	92 2c		sta ($2c)			sta 	(zTemp0) 					; line # save it in +0,+1
.35a1	98		tya				tya
.35a2	a0 01		ldy #$01			ldy 	#1
.35a4	91 2c		sta ($2c),y			sta 	(zTemp0),y
.35a6	a5 2a		lda $2a				lda 	objPtr 						; save current address in +2,+3
.35a8	c8		iny				iny
.35a9	91 2c		sta ($2c),y			sta 	(zTemp0),y
.35ab	a5 2b		lda $2b				lda 	objPtr+1
.35ad	c8		iny				iny
.35ae	91 2c		sta ($2c),y			sta 	(zTemp0),y
.35b0	60		rts				rts
.35b1					STRFindLine:
.35b1	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.35b3	84 2d		sty $2d				sty 	zTemp0+1
.35b5	ad c2 06	lda $06c2			lda 	compilerEndHigh 			; work backwards through table
.35b8	85 2f		sta $2f				sta 	zTemp1+1
.35ba	64 2e		stz $2e				stz 	zTemp1
.35bc					_STRSearch:
.35bc	20 f3 35	jsr $35f3			jsr 	_STRPrevLine 				; look at previous record.
.35bf	a0 01		ldy #$01			ldy 	#1
.35c1	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.35c3	c5 2c		cmp $2c				cmp 	zTemp0
.35c5	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.35c7	e5 2d		sbc $2d				sbc 	zTemp0+1
.35c9	b0 0b		bcs $35d6			bcs 	_STRFound 					; >=
.35cb					_STRNext:
.35cb	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.35cd	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.35cf	c9 ff		cmp #$ff			cmp 	#$FF
.35d1	d0 e9		bne $35bc			bne 	_STRSearch
.35d3	4c b3 1f	jmp $1fb3		jmp	ErrorV_internal
.35d6					_STRFound:
.35d6	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.35d8	45 2c		eor $2c				eor 	zTemp0
.35da	d0 06		bne $35e2			bne 	_STRDifferent
.35dc	b2 2e		lda ($2e)			lda 	(zTemp1)
.35de	45 2c		eor $2c				eor 	zTemp0
.35e0	f0 02		beq $35e4			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.35e2					_STRDifferent:
.35e2	a9 ff		lda #$ff			lda 	#$FF
.35e4					_STROut:
.35e4	18		clc				clc  								; set carry if different, e.g. > rather than >=
.35e5	69 ff		adc #$ff			adc 	#255
.35e7	08		php				php
.35e8	c8		iny				iny 								; address into YA
.35e9	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.35eb	48		pha				pha
.35ec	c8		iny				iny
.35ed	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.35ef	a8		tay				tay
.35f0	68		pla				pla
.35f1	28		plp				plp
.35f2	60		rts				rts
.35f3					_STRPrevLine:
.35f3	38		sec				sec 								; move backwards one entry.
.35f4	a5 2e		lda $2e				lda 	zTemp1
.35f6	e9 04		sbc #$04			sbc 	#4
.35f8	85 2e		sta $2e				sta 	zTemp1
.35fa	a5 2f		lda $2f				lda 	zTemp1+1
.35fc	e9 00		sbc #$00			sbc 	#0
.35fe	85 2f		sta $2f				sta 	zTemp1+1
.3600	60		rts				rts
.3601					STRMakeOffset:
.3601	18		clc				clc 								; borrow 1
.3602	e5 2a		sbc $2a				sbc 	objPtr
.3604	48		pha				pha
.3605	98		tya				tya
.3606	e5 2b		sbc $2b				sbc 	objPtr+1
.3608	a8		tay				tay
.3609	68		pla				pla
.360a	60		rts				rts
.360b					CommandNEXT:
.360b	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.360e	20 21 34	jsr $3421			jsr 	CharIsAlpha 				; if not alpha , error
.3611	90 0c		bcc $361f			bcc 	_CNNoReferenceGiven
.3613	20 00 34	jsr $3400			jsr 	GetNext
.3616	20 90 37	jsr $3790			jsr 	GetReferenceTerm 			; figure out the reference.
.3619	8a		txa				txa 								; reference in YA
.361a	20 96 2b	jsr $2b96			jsr 	PushIntegerYA 				; write it out.
.361d	80 06		bra $3625			bra 	_CNParametersDone
.361f					_CNNoReferenceGiven:
.361f	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.3621	a8		tay				tay
.3622	20 96 2b	jsr $2b96			jsr 	PushIntegerYA 				; write it out.
.3625					_CNParametersDone:
.3625	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.3627	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.362a	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; look for ,
.362d	c9 2c		cmp #$2c			cmp 	#","
.362f	d0 05		bne $3636			bne 	_CNExit
.3631	20 00 34	jsr $3400			jsr 	GetNext 					; consume ,
.3634	80 d5		bra $360b			bra 	CommandNEXT 				; and go round.
.3636					_CNExit:
.3636	60		rts				rts
.3637					CommandON:
.3637	20 0b 34	jsr $340b			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.363a	48		pha				pha 								; save on stack
.363b	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOTO
.363d	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.363f	f0 09		beq $364a			beq 	_COCreateLoop
.3641	a2 d2		ldx #$d2			ldx 	#PCD_CMD_GOSUB
.3643	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.3645	f0 03		beq $364a			beq 	_COCreateLoop
.3647	4c 59 1f	jmp $1f59		jmp	ErrorV_syntax
.364a					_COCreateLoop:
.364a	8a		txa				txa 								; compile a goto/gosub somewhere
.364b	da		phx				phx
.364c	20 db 34	jsr $34db			jsr 	CompileBranchCommand
.364f	fa		plx				plx
.3650	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace			; ',' follows
.3653	c9 2c		cmp #$2c			cmp 	#","
.3655	d0 0a		bne $3661			bne 	_COComplete 				; if so, more line numbers
.3657	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.3659	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.365c	20 00 34	jsr $3400			jsr 	GetNext
.365f	80 e9		bra $364a			bra 	_COCreateLoop
.3661					_COComplete:
.3661	68		pla				pla 								; throw GOTO/GOSUB
.3662	60		rts				rts
.3663					ParseConstant:
.3663	a2 00		ldx #$00			ldx 	#0
.3665	20 91 24	jsr $2491			jsr 	FloatEncodeStart 			; send first
.3668					_ParseLoop:
.3668	20 ef 33	jsr $33ef			jsr 	LookNext 					; send subsequent
.366b	20 94 24	jsr $2494			jsr 	FloatEncodeContinue
.366e	90 05		bcc $3675			bcc 	_ParseDone
.3670	20 00 34	jsr $3400			jsr 	GetNext 					; consume it
.3673	80 f3		bra $3668			bra 	_ParseLoop
.3675					_ParseDone:
.3675	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.3677	29 80		and #$80			and 	#$80
.3679	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.367b	15 56		ora $56,x			ora 	NSMantissa2,x
.367d	15 62		ora $62,x			ora 	NSMantissa3,x
.367f	18		clc				clc
.3680	d0 05		bne $3687			bne 	_ParseExit 					; exit with CC if need float to compile
.3682	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.3684	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.3686	38		sec				sec
.3687					_ParseExit:
.3687	60		rts				rts
.3688					CommandPRINT:
.3688	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace			; what follows ?
.368b	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.368d	f0 27		beq $36b6			beq 	_CPCheckEnd
.368f	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.3691	f0 1e		beq $36b1			beq 	_CPTabCheckEnd
.3693	20 fa 36	jsr $36fa			jsr 	_CPAtEnd 					; check for : and EOL
.3696	b0 2a		bcs $36c2			bcs 	_CPExitCR 					; exit with CR
.3698	c9 a3		cmp #$a3			cmp 	#C64_TABLB 					; TAB( found
.369a	f0 31		beq $36cd			beq 	_CPHaveTabSpcFunc
.369c	c9 a6		cmp #$a6			cmp 	#C64_SPCLB 					; SPC( found
.369e	f0 2d		beq $36cd			beq 	_CPHaveTabSpcFunc
.36a0	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0 		; so it is something to print
.36a3	a2 b2		ldx #$b2			ldx 	#PCD_PRINTCMD_S
.36a5	29 40		and #$40			and 	#NSSString 					; if string
.36a7	d0 02		bne $36ab			bne 	_CPOut
.36a9	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_N
.36ab					_CPOut:
.36ab	8a		txa				txa 								; print that thing
.36ac	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.36af	80 d7		bra $3688			bra 	CommandPRINT 				; and loop round/
.36b1					_CPTabCheckEnd:
.36b1	a9 b8		lda #$b8			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.36b3	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.36b6					_CPCheckEnd:
.36b6	20 00 34	jsr $3400			jsr 	GetNext 					; consume it.
.36b9	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; what follows ?
.36bc	20 fa 36	jsr $36fa			jsr 	_CPAtEnd 					; reached end
.36bf	90 c7		bcc $3688			bcc 	CommandPRINT 				; no, loop back
.36c1	60		rts				rts
.36c2					_CPExitCR:
.36c2	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.36c4	20 a9 2b	jsr $2ba9			jsr 	PushIntegerA
.36c7	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.36c9	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.36cc	60		rts				rts
.36cd					_CPHaveTabSpcFunc:
.36cd	20 0b 34	jsr $340b			jsr 	GetNextNonSpace 			; get the TAB( or SPC(
.36d0	48		pha				pha 								; save it.
.36d1	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0 		; compile expression, the TAB or SPC size.
.36d4	29 40		and #$40			and 	#NSSTypeMask 				; check number.
.36d6	c9 00		cmp #$00			cmp  	#NSSIFloat
.36d8	d0 1d		bne $36f7			bne 	_CPType
.36da	20 0b 34	jsr $340b			jsr 	GetNextNonSpace 			; get next skipping spaces
.36dd	c9 29		cmp #$29			cmp 	#")"						; check closing bracket.
.36df	d0 13		bne $36f4			bne 	_CPSyntax
.36e1	68		pla				pla
.36e2	c9 a3		cmp #$a3			cmp 	#C64_TABLB 					; output SPC or POS command accordingly.
.36e4	f0 07		beq $36ed			beq 	_CPIsTabFunc
.36e6	a9 ba		lda #$ba			lda 	#PCD_PRINTCMD_SPC
.36e8	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.36eb	80 9b		bra $3688			bra 	CommandPRINT
.36ed					_CPIsTabFunc:
.36ed	a9 b9		lda #$b9			lda 	#PCD_PRINTCMD_POS
.36ef	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.36f2	80 94		bra $3688			bra 	CommandPRINT
.36f4					_CPSyntax:
.36f4	4c 59 1f	jmp $1f59		jmp	ErrorV_syntax
.36f7					_CPType:
.36f7	4c 69 1f	jmp $1f69		jmp	ErrorV_type
.36fa					_CPAtEnd:
.36fa	c9 00		cmp #$00			cmp 	#0
.36fc	f0 06		beq $3704			beq 	_CPIsEnd
.36fe	c9 3a		cmp #$3a			cmp 	#":"
.3700	f0 02		beq $3704			beq 	_CPIsEnd
.3702	18		clc				clc
.3703	60		rts				rts
.3704					_CPIsEnd:
.3704	38		sec				sec
.3705	60		rts				rts
.3706					CommandREAD:
.3706	a2 b3		ldx #$b3			ldx 	#PCD_READ
.3708	a0 b4		ldy #$b4			ldy 	#PCD_READDOLLAR
.370a					CommandReadInputCommon:
.370a	8e c7 06	stx $06c7			stx 	numberPCode
.370d	8c c8 06	sty $06c8			sty 	stringPCode
.3710					_CRLoop:
.3710	20 0b 34	jsr $340b			jsr 	GetNextNonSpace 			; first char of identifier
.3713	20 21 34	jsr $3421			jsr 	CharIsAlpha 				; check A-Z
.3716	90 27		bcc $373f			bcc 	_CRSyntax
.3718	20 90 37	jsr $3790			jsr 	GetReferenceTerm 			; get the variable.
.371b	48		pha				pha 								; save type.
.371c	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.371e	c9 40		cmp #$40			cmp 	#NSSString
.3720	f0 05		beq $3727			beq 	_CRString
.3722	ad c7 06	lda $06c7			lda 	numberPCode 				; output read/input
.3725	80 03		bra $372a			bra 	_CRHaveType
.3727					_CRString:
.3727	ad c8 06	lda $06c8			lda 	stringPCode					; output read$/input$
.372a					_CRHaveType:
.372a	20 80 2a	jsr $2a80			jsr 	WriteCodeByte 				; so we have one typed data item.
.372d	68		pla				pla 								; restore type
.372e	38		sec				sec  								; write update code.
.372f	20 42 37	jsr $3742			jsr 	GetSetVariable
.3732	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; , follows ?
.3735	c9 2c		cmp #$2c			cmp 	#","
.3737	d0 05		bne $373e			bne 	_CRExit 					; if not, end of READ.
.3739	20 00 34	jsr $3400			jsr 	GetNext 					; consume comma
.373c	80 d2		bra $3710			bra 	_CRLoop 					; keep going
.373e					_CRExit:
.373e	60		rts				rts
.373f					_CRSyntax:
.373f	4c 59 1f	jmp $1f59		jmp	ErrorV_syntax
.06c7					numberPCode:
>06c7							.fill 	1
.06c8					stringPCode:
>06c8							.fill 	1
.3742					GetSetVariable:
.3742	08		php				php 								; save direction on stack
.3743	c0 00		cpy #$00			cpy 	#$00
.3745	30 21		bmi $3768			bmi 	_GSVReadWriteSpecial
.3747	c9 00		cmp #$00			cmp 	#$00
.3749	30 33		bmi $377e			bmi 	_GSVArray
.374b	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.374d	4a		lsr a				lsr 	a 							; divide by 2
.374e	09 40		ora #$40			ora 	#64 						; and set bit 6.
.3750	28		plp				plp
.3751	90 02		bcc $3755			bcc 	_GSVNotWrite
.3753	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.3755					_GSVNotWrite:
.3755	85 2c		sta $2c				sta 	zTemp0
.3757	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.3758	4a		lsr a				lsr 	a
.3759	a8		tay				tay
.375a	8a		txa				txa
.375b	6a		ror a				ror 	a
.375c	aa		tax				tax
.375d	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.375e	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.3760	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3763	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.3764	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3767	60		rts				rts
.3768					_GSVReadWriteSpecial:
.3768	28		plp				plp
.3769	b0 10		bcs $377b			bcs 	_GSVSyntax
.376b	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.376d	f0 06		beq $3775			beq 	_GSVRWString
.376f	a9 c0		lda #$c0			lda 	#(PCD_TI) & $FF
.3771	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3774	60		rts				rts
.3775					_GSVRWString:
.3775	a9 c1		lda #$c1			lda 	#(PCD_TIDOLLAR) & $FF
.3777	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.377a	60		rts				rts
.377b					_GSVSyntax:
.377b	4c 59 1f	jmp $1f59		jmp	ErrorV_syntax
.377e					_GSVArray:
.377e	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.3780	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.3781	4a		lsr a				lsr 	a
.3782	4a		lsr a				lsr 	a
.3783	4a		lsr a				lsr 	a
.3784	4a		lsr a				lsr 	a
.3785	28		plp				plp 								; if writing array then set bit 2.
.3786	90 02		bcc $378a			bcc 	_GSVANotWrite
.3788	09 04		ora #$04			ora 	#4
.378a					_GSVANotWrite:
.378a	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.378c	20 80 2a	jsr $2a80			jsr 	WriteCodeByte 				; and write it out
.378f	60		rts				rts
.3790					GetReferenceTerm:
.3790	20 70 34	jsr $3470			jsr 	ExtractVariableName 		; get name & type info
.3793	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.3795	30 10		bmi $37a7			bmi 	_GRTArray
.3797	da		phx				phx 								; save type on stack
.3798	20 50 2e	jsr $2e50			jsr 	FindVariable 				; find it
.379b	b0 06		bcs $37a3			bcs 	_GRTNoCreate 				; create if required.
.379d	20 db 2b	jsr $2bdb			jsr 	CreateVariableRecord 		; create a variable.
.37a0	20 30 2c	jsr $2c30			jsr 	AllocateBytesForType 		; allocate memory for it
.37a3					_GRTNoCreate:
.37a3	68		pla				pla 								; get type back, strip out type information.
.37a4	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.37a6	60		rts				rts
.37a7					_GRTArray:
.37a7	da		phx				phx 								; save type information
.37a8	20 50 2e	jsr $2e50			jsr 	FindVariable 				; read its data, the base address in YX
.37ab	90 18		bcc $37c5			bcc 	_GRTUndeclared 				; undeclared array.
.37ad	da		phx				phx 								; save base address
.37ae	5a		phy				phy
.37af	20 27 2d	jsr $2d27			jsr 	OutputIndexGroup 			; create an index group and generate them
.37b2	7a		ply				ply 								; get the array base address into YX
.37b3	fa		plx				plx
.37b4	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.37b6	18		clc				clc
.37b7	20 42 37	jsr $3742			jsr 	GetSetVariable 				; load the address of the array structure.
.37ba	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.37bc	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.37bf	68		pla				pla 								; and the type data into A
.37c0	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.37c2	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.37c4	60		rts				rts
.37c5					_GRTUndeclared:
.37c5	4c 10 20	jmp $2010		jmp	ErrorV_undeclared
.37c8					CommandREM:
.37c8	20 ef 33	jsr $33ef			jsr 	LookNext
.37cb	f0 05		beq $37d2			beq 	_CRExit
.37cd	20 00 34	jsr $3400			jsr 	GetNext
.37d0	80 f6		bra $37c8			bra 	CommandREM
.37d2					_CRExit:
.37d2	60		rts				rts
.37d3					STRReset:
.37d3	ad c1 06	lda $06c1			lda	 	compilerStartHigh 			; set up the two table pointers
.37d6	8d cc 06	sta $06cc			sta 	variableListEnd+1
.37d9	9c cb 06	stz $06cb			stz 	variableListEnd
.37dc	ad c2 06	lda $06c2			lda 	compilerEndHigh
.37df	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.37e2	9c c9 06	stz $06c9			stz 	lineNumberTable
.37e5	ad cb 06	lda $06cb			lda 	variableListEnd
.37e8	85 2d		sta $2d				sta 	zTemp0+1
.37ea	64 2c		stz $2c				stz 	zTemp0
.37ec	a9 00		lda #$00			lda 	#0
.37ee	92 2c		sta ($2c)			sta 	(zTemp0)
.37f0	a9 00		lda #$00			lda 	#((0) & $FF)
.37f2	8d cd 06	sta $06cd			sta 	0+freeVariableMemory
.37f5	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.37f7	8d ce 06	sta $06ce			sta 	1+freeVariableMemory
.37fa	60		rts				rts
.06c9					lineNumberTable:
>06c9							.fill 	2
.06cb					variableListEnd:
>06cb							.fill 	2
.06cd					freeVariableMemory:
>06cd							.fill 	2
.37fb					CommandRESTORE:
.37fb	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; what follows ?
.37fe	c9 3a		cmp #$3a			cmp 	#':'						; if : or EOL then default
.3800	f0 0a		beq $380c			beq 	_CRDefault
.3802	c9 00		cmp #$00			cmp 	#0
.3804	f0 06		beq $380c			beq 	_CRDefault
.3806	a9 d6		lda #$d6			lda 	#PCD_CMD_RESTORE 			; no, we have a parameter like GOTO/GOSUB
.3808	20 db 34	jsr $34db			jsr 	CompileBranchCommand
.380b	60		rts				rts
.380c					_CRDefault:
.380c	a9 d6		lda #$d6			lda 	#PCD_CMD_RESTORE 			; compile RESTORE
.380e	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3811	a9 00		lda #$00			lda 	#0		 					; with zero "line#"
.3813	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3816	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3819	60		rts				rts
.381a					CompileTerm:
.381a	20 0b 34	jsr $340b			jsr 	GetNextNonSpace 			; get first non space character.
.381d	30 72		bmi $3891			bmi 	_CTUnaryFunctions
.381f	20 15 34	jsr $3415			jsr 	CharIsDigit 				; found a number
.3822	b0 3a		bcs $385e			bcs 	_CTDigit
.3824	c9 2e		cmp #$2e			cmp 	#"."
.3826	f0 36		beq $385e			beq 	_CTDigit
.3828	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.382a	f0 43		beq $386f			beq 	_CTString
.382c	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.382e	f0 28		beq $3858			beq 	_CTOtherBase
.3830	c9 24		cmp #$24			cmp 	#"$"
.3832	f0 24		beq $3858			beq 	_CTOtherBase
.3834	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.3836	f0 17		beq $384f			beq 	_CTBrackets
.3838	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.383a	90 10		bcc $384c			bcc 	_CTSyntax
.383c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.383e	b0 0c		bcs $384c			bcs 	_CTSyntax
.3840	20 90 37	jsr $3790			jsr 	GetReferenceTerm 			; figure out what it is.
.3843	48		pha				pha 								; save type on stack
.3844	18		clc				clc 								; read it
.3845	20 42 37	jsr $3742			jsr 	GetSetVariable
.3848	68		pla				pla
.3849	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.384b	60		rts				rts
.384c					_CTSyntax:
.384c	4c 59 1f	jmp $1f59		jmp	ErrorV_syntax
.384f					_CTBrackets:
.384f	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0
.3852	48		pha				pha
.3853	20 e2 2a	jsr $2ae2			jsr 	CheckNextRParen
.3856	68		pla				pla
.3857	60		rts				rts
.3858					_CTOtherBase:
.3858	20 2e 2a	jsr $2a2e			jsr 	InlineNonDecimal 			; non decimal constant handler
.385b	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.385d	60		rts				rts
.385e					_CTDigit:
.385e	20 63 36	jsr $3663			jsr 	ParseConstant 				; parse out an number, first is in A already.
.3861	90 06		bcc $3869			bcc	 	_CTFloat 					; have a float or long int.
.3863	20 96 2b	jsr $2b96			jsr 	PushIntegerYA 				; code to push on stack
.3866	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.3868	60		rts				rts
.3869					_CTFloat:
.3869	20 b8 2b	jsr $2bb8			jsr 	PushFloatCommand			; code to push float
.386c	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.386e	60		rts				rts
.386f					_CTString:
.386f	20 b7 2a	jsr $2ab7			jsr 	BufferClear 				; copy it to the buffer
.3872					_CTStringLoop:
.3872	20 ef 33	jsr $33ef			jsr 	LookNext 					; reached EOL/EOS
.3875	f0 d5		beq $384c			beq 	_CTSyntax
.3877	c9 22		cmp #$22			cmp 	#'"'
.3879	f0 08		beq $3883			beq 	_CTStringDone
.387b	20 bb 2a	jsr $2abb			jsr 	BufferWrite 				; write and consume
.387e	20 00 34	jsr $3400			jsr 	GetNext
.3881	80 ef		bra $3872			bra 	_CTStringLoop
.3883					_CTStringDone:
.3883	20 00 34	jsr $3400			jsr 	GetNext 					; consume closing quote.
.3886	a9 cf		lda #$cf			lda 	#PCD_CMD_STRING 			; output command and buffer
.3888	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.388b	20 c7 2a	jsr $2ac7			jsr 	BufferOutput
.388e	a9 40		lda #$40			lda 	#NSSString 					; string type
.3890	60		rts				rts
.3891					_CTUnaryFunctions:
.3891	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.3893	f0 0a		beq $389f			beq 	_CTNegation
.3895	a2 8a		ldx #$8a			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.3897	a0 31		ldy #$31			ldy 	#UnaryTables >> 8
.3899	20 91 32	jsr $3291			jsr 	GeneratorProcess
.389c	90 ae		bcc $384c			bcc		_CTSyntax
.389e	60		rts				rts
.389f					_CTNegation:
.389f	20 1a 38	jsr $381a			jsr 	CompileTerm 				; compile a term.
.38a2	48		pha				pha
.38a3	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.38a5	c9 00		cmp #$00			cmp 	#NSSIFloat
.38a7	d0 07		bne $38b0			bne 	_CTType 					; error
.38a9	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.38ab	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.38ae	68		pla				pla 								; return original type.
.38af	60		rts				rts
.38b0					_CTType:
.38b0	4c 69 1f	jmp $1f69		jmp	ErrorV_type
.38b3					CommandWAIT:
.38b3	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace
.38b6	c9 2c		cmp #$2c			cmp 	#","
.38b8	f0 10		beq $38ca			beq 	_CWThirdParameter
.38ba	a9 00		lda #$00			lda 	#0
.38bc	20 a9 2b	jsr $2ba9			jsr 	PushIntegerA
.38bf					_CWExit:
.38bf	a9 cb		lda #$cb			lda 	#(PCD_WAIT) >> 8
.38c1	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.38c4	a9 95		lda #$95			lda 	#(PCD_WAIT) & $FF
.38c6	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.38c9	60		rts				rts
.38ca					_CWThirdParameter:
.38ca	20 00 34	jsr $3400			jsr 	GetNext
.38cd	20 98 2d	jsr $2d98			jsr 	CompileExpressionAtA
.38d0	29 40		and #$40			and 	#NSSTypeMask
.38d2	c9 00		cmp #$00			cmp 	#NSSIFloat
.38d4	f0 e9		beq $38bf			beq 	_CWExit
.38d6	4c 69 1f	jmp $1f69		jmp	ErrorV_type
.38d9					CommandCMD:
.38d9	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.38db	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.38de	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; followed by a , ?
.38e1	c9 2c		cmp #$2c			cmp 	#","
.38e3	d0 06		bne $38eb			bne 	_CCMDExit
.38e5	20 00 34	jsr $3400			jsr 	GetNext 					; consume comma.
.38e8	20 88 36	jsr $3688			jsr 	CommandPRINT 				; do the print code
.38eb					_CCMDExit:
.38eb	60		rts				rts
.38ec					CommandOPEN:
.38ec	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; followed by a , ?
.38ef	c9 2c		cmp #$2c			cmp 	#","
.38f1	d0 15		bne $3908			bne 	_COTwoDefaults
.38f3	20 00 34	jsr $3400			jsr 	GetNext 					; consume comma
.38f6	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.38f9	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.38fb	f0 1e		beq $391b			beq 	_COThreeIntegers
.38fd	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.38ff	20 a9 2b	jsr $2ba9			jsr 	PushIntegerA
.3902	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.3904	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3907	60		rts				rts
.3908					_COTwoDefaults:
.3908	a9 00		lda #$00			lda 	#0
.390a	20 a9 2b	jsr $2ba9			jsr 	PushIntegerA
.390d					_COCompileNullString:
.390d	a9 cf		lda #$cf			lda 	#(PCD_CMD_STRING) & $FF
.390f	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3912	a9 00		lda #$00			lda 	#0
.3914	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.3917	20 80 2a	jsr $2a80			jsr 	WriteCodeByte
.391a	60		rts				rts
.391b					_COThreeIntegers:
.391b	20 f2 33	jsr $33f2			jsr 	LookNextNonSpace 			; is there a ,
.391e	c9 2c		cmp #$2c			cmp 	#","
.3920	d0 eb		bne $390d			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.3922	20 00 34	jsr $3400			jsr 	GetNext
.3925	20 96 2d	jsr $2d96			jsr 	CompileExpressionAt0 		; should be a filename
.3928	29 40		and #$40			and 	#NSSString
.392a	f0 01		beq $392d			beq 	_COType
.392c	60		rts				rts
.392d					_COType:
.392d	4c 69 1f	jmp $1f69		jmp	ErrorV_type

;******  Processing input file: _library.asm

.3930					CompilerAPI:
.3930	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.3932	f0 19		beq $394d			beq 	_CAOpenIn
.3934	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.3936	f0 23		beq $395b			beq 	_CACloseIn
.3938	c9 02		cmp #$02			cmp 	#BLC_READIN
.393a	f0 3a		beq $3976			beq 	_CARead
.393c	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.393e	f0 1e		beq $395e			beq 	_CAResetOut
.3940	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.3942	f0 23		beq $3967			beq 	_CACloseOut
.3944	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.3946	f0 20		beq $3968			beq 	_CAWriteByte
.3948	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.394a	f0 26		beq $3972			beq 	_CAPrintScreen
>394c	db						.byte 	$DB 						; causes a break in the emulator
.394d					_CAOpenIn:
.394d	a0 3a		ldy #$3a			ldy 	#SourceFile >> 8 			; name of file
.394f	a2 6d		ldx #$6d			ldx 	#SourceFile & $FF
.3951	20 de 39	jsr $39de			jsr 	IOOpenRead 					; open file
.3954	20 e9 39	jsr $39e9			jsr 	IOReadByte 					; skip the 2 byte load address header
.3957	20 e9 39	jsr $39e9			jsr 	IOReadByte
.395a	60		rts				rts
.395b					_CACloseIn:
.395b	4c f8 39	jmp $39f8			jmp 	IOReadClose
.395e					_CAResetOut:
.395e	a9 00		lda #$00			lda 	#((FreeMemory) & $FF)
.3960	85 2a		sta $2a				sta 	0+objPtr
.3962	a9 3b		lda #$3b			lda 	#((FreeMemory) >> 8) & $FF
.3964	85 2b		sta $2b				sta 	1+objPtr
.3966	60		rts				rts
.3967					_CACloseOut:
.3967	60		rts				rts
.3968					_CAWriteByte:
.3968	8a		txa				txa
.3969	92 2a		sta ($2a)			sta 	(objPtr)
.396b	e6 2a		inc $2a				inc 	objPtr
.396d	d0 02		bne $3971			bne 	_HWOWBNoCarry
.396f	e6 2b		inc $2b				inc 	objPtr+1
.3971					_HWOWBNoCarry:
.3971	60		rts				rts
.3972					_CAPrintScreen:
.3972	8a		txa				txa
.3973	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.3976					_CARead:
.3976	20 e9 39	jsr $39e9			jsr 	IOReadByte 				; copy the address of next into the buffer
.3979	8d cf 06	sta $06cf			sta 	SourceLine+0
.397c	20 e9 39	jsr $39e9			jsr 	IOReadByte
.397f	8d d0 06	sta $06d0			sta 	SourceLine+1
.3982	0d cf 06	ora $06cf			ora 	sourceLine				; if both were zero, exit with CC (e.g. fail)
.3985	18		clc				clc
.3986	f0 1e		beq $39a6			beq		_CARExit
.3988	20 e9 39	jsr $39e9			jsr 	IOReadByte 				; read the line # into the buffer.
.398b	8d d1 06	sta $06d1			sta 	SourceLine+2
.398e	20 e9 39	jsr $39e9			jsr 	IOReadByte
.3991	8d d2 06	sta $06d2			sta 	SourceLine+3
.3994	a2 04		ldx #$04			ldx 	#4 						; read the body of the line.
.3996					_CAReadLine:
.3996	20 e9 39	jsr $39e9			jsr 	IOReadByte 				; now keep copying to EOL
.3999	9d cf 06	sta $06cf,x			sta 	SourceLine,x
.399c	e8		inx				inx
.399d	c9 00		cmp #$00			cmp 	#0
.399f	d0 f5		bne $3996			bne 	_CAReadLine
.39a1	38		sec				sec 							; read a line okay
.39a2	a0 06		ldy #$06			ldy 	#SourceLine >> 8
.39a4	a2 cf		ldx #$cf			ldx 	#SourceLine & $FF
.39a6					_CARExit:
.39a6	60		rts				rts
.06cf					SourceLine:
>06cf							.fill 	256
.39a7					WriteObjectCode:
.39a7	20 1a 08	jsr $081a			jsr 	PatchOutCompile 			; makes it run the runtime on reload
.39aa	a0 3a		ldy #$3a			ldy 	#ObjectFile >> 8
.39ac	a2 62		ldx #$62			ldx 	#ObjectFile & $FF
.39ae	20 d4 3a	jsr $3ad4			jsr 	IOOpenWrite 				; open write
.39b1	a9 01		lda #$01			lda 	#1 							; write out the load address $0801
.39b3	20 df 3a	jsr $3adf			jsr 	IOWriteByte
.39b6	a9 08		lda #$08			lda 	#8
.39b8	20 df 3a	jsr $3adf			jsr 	IOWriteByte
.39bb	a9 01		lda #$01			lda 	#((StartBasicProgram) & $FF)
.39bd	85 2c		sta $2c				sta 	0+zTemp0
.39bf	a9 08		lda #$08			lda 	#((StartBasicProgram) >> 8) & $FF
.39c1	85 2d		sta $2d				sta 	1+zTemp0
.39c3					_WOCLoop:
.39c3	b2 2c		lda ($2c)			lda 	(zTemp0) 					; write code
.39c5	20 df 3a	jsr $3adf			jsr 	IOWriteByte
.39c8	e6 2c		inc $2c				inc 	zTemp0 						; advance pointer
.39ca	d0 02		bne $39ce			bne 	_WOCSkip
.39cc	e6 2d		inc $2d				inc 	zTemp0+1
.39ce					_WOCSkip:
.39ce	a5 2c		lda $2c				lda 	zTemp0 						; check end
.39d0	c5 2a		cmp $2a				cmp 	objPtr
.39d2	d0 ef		bne $39c3			bne 	_WOCLoop
.39d4	a5 2d		lda $2d				lda 	zTemp0+1
.39d6	c5 2b		cmp $2b				cmp 	objPtr+1
.39d8	d0 e9		bne $39c3			bne 	_WOCLoop
.39da	20 f8 39	jsr $39f8			jsr 	IOWriteClose 				; close the file.
.39dd	60		rts				rts
.39de					IOOpenRead:
.39de	a9 52		lda #$52			lda 	#'R' 						; read.
.39e0	20 01 3a	jsr $3a01			jsr 	IOSetFileName 				; set up name/LFS
.39e3	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for reading
.39e5	20 c6 ff	jsr $ffc6			jsr 	$FFC6 						; CHKIN
.39e8	60		rts				rts
.39e9					IOReadByte:
.39e9	da		phx				phx
.39ea	5a		phy				phy
.39eb	20 b7 ff	jsr $ffb7			jsr 	$FFB7 						; read ST
.39ee	38		sec				sec
.39ef	d0 04		bne $39f5			bne 	_IORExit
.39f1	20 cf ff	jsr $ffcf			jsr 	$FFCF 						; read a byte
.39f4	18		clc				clc 								; status OK.
.39f5					_IORExit:
.39f5	7a		ply				ply
.39f6	fa		plx				plx
.39f7	60		rts				rts
.39f8					IOReadClose:
.39f8					IOWriteClose:
.39f8	a9 03		lda #$03			lda 	#3 							; CLOSE# 3
.39fa	20 c3 ff	jsr $ffc3			jsr 	$FFC3
.39fd	20 cc ff	jsr $ffcc			jsr 	$FFCC 						; CLRCHN
.3a00	60		rts				rts
.3a01					IOSetFileName:
.3a01	48		pha				pha 								; save R/W
.3a02	86 2c		stx $2c				stx 	zTemp0
.3a04	84 2d		sty $2d				sty 	zTemp0+1
.3a06	a0 ff		ldy #$ff			ldy 	#$FF 						; copy name given
.3a08					_IOSCopy:
.3a08	c8		iny				iny 								; pre-increment copy
.3a09	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.3a0b	99 cf 07	sta $07cf,y			sta 	IONameBuffer,y
.3a0e	d0 f8		bne $3a08			bne 	_IOSCopy
.3a10	99 d3 07	sta $07d3,y			sta 	IONameBuffer+4,y
.3a13	a9 2c		lda #$2c			lda 	#',' 						; append ,S,[R|W]
.3a15	99 cf 07	sta $07cf,y			sta 	IONameBuffer+0,y
.3a18	99 d1 07	sta $07d1,y			sta 	IONameBuffer+2,y
.3a1b	a9 53		lda #$53			lda 	#'S'
.3a1d	99 d0 07	sta $07d0,y			sta 	IONameBuffer+1,y
.3a20	68		pla				pla 								; write R/W out
.3a21	99 d2 07	sta $07d2,y			sta 	IONameBuffer+3,y
.3a24	98		tya				tya 								; length of name to A
.3a25	18		clc				clc
.3a26	69 04		adc #$04			adc 	#4 							; we added 4 characters.
.3a28	a2 cf		ldx #$cf			ldx 	#IONameBuffer & $FF			; name address to YX
.3a2a	a0 07		ldy #$07			ldy 	#IONameBuffer >> 8
.3a2c	20 bd ff	jsr $ffbd		    jsr 	$FFBD          				; call SETNAM
.3a2f	a9 03		lda #$03	    	lda 	#3 							; set LFS to 3,8,3
.3a31	a2 08		ldx #$08			ldx 	#8
.3a33	a0 03		ldy #$03			ldy 	#3
.3a35	20 ba ff	jsr $ffba			jsr 	$FFBA
.3a38	20 c0 ff	jsr $ffc0			jsr 	$FFC0 						; OPEN
.3a3b	60		rts				rts
.07cf					IONameBuffer:
>07cf							.fill 	64
.3a3c					CompileCode:
.3a3c	a2 00		ldx #$00			ldx 	#0
.3a3e	bd 78 3a	lda $3a78,x	_Prompt:lda 	Prompt,x
.3a41	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a44	e8		inx				inx
.3a45	c9 00		cmp #$00			cmp 	#0
.3a47	d0 f5		bne $3a3e			bne 	_Prompt
.3a49	a2 5e		ldx #$5e			ldx 	#APIDesc & $FF
.3a4b	a0 3a		ldy #$3a			ldy 	#APIDesc >> 8
.3a4d	20 f7 2a	jsr $2af7			jsr 	StartCompiler
.3a50	20 a7 39	jsr $39a7			jsr 	WriteObjectCode
.3a53	a9 4f		lda #$4f			lda 	#"O"
.3a55	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a58	a9 4b		lda #$4b			lda 	#"K"
.3a5a	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a5d	60		rts				rts
.3a5e					APIDesc:
>3a5e	30 39						.word 	CompilerAPI 				; the compiler API Implementeation
>3a60	80						.byte 	$80 						; start of workspace for compiler $8000
>3a61	9f						.byte 	$9F							; end of workspace for compiler $9F00
.3a62					ObjectFile:
>3a62	4f 42 4a 45 43 54 2e 50				.text 	'OBJECT.PRG',0
>3a6a	52 47 00
.3a6d					SourceFile:
>3a6d	53 4f 55 52 43 45 2e 50				.text 	'SOURCE.PRG',0
>3a75	52 47 00
.3a78					Prompt:
>3a78	2a 2a 2a 20 42 4c 49 54				.text 	'*** BLITZ (ALPHA 14-10-23) ***',13,13
>3a80	5a 20 28 41 4c 50 48 41 20 31 34 2d 31 30 2d 32
>3a90	33 29 20 2a 2a 2a 0d 0d
>3a98	42 55 47 53 20 2d 3e 20				.text 	'BUGS -> HTTPS://GITHUB.COM/PAULSCOTTROBSON/BLITZ-COMPILER',13,13,0
>3aa0	48 54 54 50 53 3a 2f 2f 47 49 54 48 55 42 2e 43
>3ab0	4f 4d 2f 50 41 55 4c 53 43 4f 54 54 52 4f 42 53
>3ac0	4f 4e 2f 42 4c 49 54 5a 2d 43 4f 4d 50 49 4c 45
>3ad0	52 0d 0d 00
.3ad4					IOOpenWrite:
.3ad4	a9 57		lda #$57			lda 	#'W'			 			; write
.3ad6	20 01 3a	jsr $3a01			jsr 	IOSetFileName 				; set up name/LFS
.3ad9	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for writing
.3adb	20 c9 ff	jsr $ffc9			jsr 	$FFC9 						; CHKOUT
.3ade	60		rts				rts
.3adf					IOWriteByte:
.3adf	48		pha				pha
.3ae0	da		phx				phx
.3ae1	5a		phy				phy
.3ae2	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3ae5	7a		ply				ply
.3ae6	fa		plx				plx
.3ae7	68		pla				pla
.3ae8	60		rts				rts

;******  Processing input file: source/main/zzfree.footer

>3ae9							.align 	256
.3b00					FreeMemory:

;******  End of listing
