
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl source/main/00main.header /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library _library.asm source/main/zzfree.footer
; Mon Oct  9 06:17:26 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: source/main/00main.header

.0801					StartBasicProgram:
>0801	0c 08						.word 	$080C 						; offset to next.
>0803	0a 00						.word 	10 							; line #
>0805	9e						.byte 	$9E 						; token for 'SYS'
>0806	20 32 30 36 32					.text 	' 2062'						; space, $080E in decimal
>080b	00						.byte  	0 							; end of line
>080c	00 00						.word 	0 							; end of program
.080e	a0 08		ldy #$08			ldy 	#ObjectFile >> 8
.0810	a2 36		ldx #$36			ldx 	#ObjectFile & $FF
.0812	20 bf 38	jsr $38bf			jsr 	IOOpenWrite
.0815	a9 0c		lda #$0c			lda 	#12
.0817	20 ca 38	jsr $38ca			jsr 	IOWriteByte
.081a	a9 0d		lda #$0d			lda 	#13
.081c	20 ca 38	jsr $38ca			jsr 	IOWriteByte
.081f	20 7b 38	jsr $387b			jsr 	IOWriteClose
.0822	a0 08		ldy #$08			ldy 	#SourceFile >> 8
.0824	a2 41		ldx #$41			ldx 	#SourceFile & $FF
.0826	20 61 38	jsr $3861			jsr 	IOOpenRead
>0829	db						.byte 	$DB 						; causes a break in the emulator
.082a	20 6c 38	jsr $386c			jsr 	IOReadByte
.082d	20 6c 38	jsr $386c			jsr 	IOReadByte
.0830	20 7b 38	jsr $387b			jsr 	IOReadClose
.0833	4c ff ff	jmp $ffff			jmp 	$FFFF
.0836					ObjectFile:
>0836	4f 42 4a 45 43 54 2e 50				.text 	'OBJECT.PRG',0
>083e	52 47 00
.0841					SourceFile:
>0841	53 4f 55 52 43 45 2e 50				.text 	'SOURCE.PRG',0
>0849	52 47 00

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.084c					StartRuntime:
.084c	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.084f	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.0851	64 28		stz $28				stz 	codePtr
.0853	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0856	8c 06 04	sty $0406			sty 	storeEndHigh
.0859	8e 07 04	stx $0407			stx 	variableStartPage
.085c	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.085e	a2 66		ldx #$66			ldx 	#RuntimeErrorHandler & $FF
.0860	20 ed 1e	jsr $1eed			jsr 	SetErrorHandler
.0863	20 95 0a	jsr $0a95			jsr 	ClearMemory 				; clear memory.
.0866	20 74 16	jsr $1674			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0869	20 76 13	jsr $1376		 	jsr		SetDefaultChannel			; set default input/output channel.
.086c	20 ac 15	jsr $15ac			jsr 	RestoreCode 				; which we now call
.086f	a0 00		ldy #$00			ldy 	#0
.0871					NextCommand:
.0871	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.0873	30 5b		bmi $08d0			bmi 	NXCommand 					; -if -ve command
.0875	c8		iny				iny
.0876	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0878	90 39		bcc $08b3			bcc 	PushByteA 					; 0..63 is short constants.
.087a					NXLoadStore:
.087a	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.087c	b0 19		bcs $0897			bcs 	NXIndirectLoadStore
.087e	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.087f	4a		lsr a				lsr 	a
.0880	29 0e		and #$0e			and 	#$0E
.0882	da		phx				phx 								; get ready to jump
.0883	aa		tax				tax
.0884	7c 87 08	jmp ($0887,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.0887					ReadWriteVectors:
>0887	e2 14						.word 	ReadFloatCommand			; read float
>0889	bd 1a						.word 	WriteFloatCommand 			; write float
>088b	1e 15						.word 	ReadIntegerCommand 			; read integer
>088d	f9 1a						.word 	WriteIntegerCommand 		; write integer
>088f	63 15						.word 	ReadStringCommand 			; read string
>0891	38 1b						.word 	WriteStringCommand 			; write string
>0893	63 0c						.word 	Unimplemented
>0895	63 0c						.word 	Unimplemented
.0897					NXIndirectLoadStore:
.0897	29 07		and #$07			and 	#7
.0899	0a		asl a				asl 	a
.089a	da		phx				phx
.089b	aa		tax				tax
.089c	7c 9f 08	jmp ($089f,x)			jmp 	(IndirectVectors,x)
.089f					IndirectVectors:
>089f	18 0f						.word 	IndFloatRead 				; float read
>08a1	2c 0f						.word 	IndInt16Read 				; int16 read
>08a3	40 0f						.word 	IndStringRead 				; string read
>08a5	63 0c						.word 	Unimplemented
>08a7	54 0f						.word 	IndFloatWrite				; float write
>08a9	68 0f						.word 	IndInt16Write 				; int16 write
>08ab	7c 0f						.word 	IndStringWrite 				; string write
>08ad	63 0c						.word 	Unimplemented
.08af					PushByteCommand:
.08af	fa		plx				plx
.08b0	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.08b2	c8		iny				iny
.08b3					PushByteA:
.08b3	e8		inx				inx 								; push constant on stack
.08b4	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.08b6	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.08b8					ClearRestWord:
.08b8	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.08ba	74 62		stz $62,x			stz 	NSMantissa3,x
.08bc	74 6e		stz $6e,x			stz 	NSExponent,x
.08be	74 32		stz $32,x			stz 	NSStatus,x
.08c0	80 af		bra $0871			bra 	NextCommand
.08c2					PushWordCommand:
.08c2	fa		plx				plx
.08c3	e8		inx				inx
.08c4	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.08c6	c8		iny				iny
.08c7	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08c9	b1 28		lda ($28),y			lda 	(codePtr),y
.08cb	c8		iny				iny
.08cc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08ce	80 e8		bra $08b8			bra 	ClearRestWord 				; handle everything else.
.08d0					NXCommand:
.08d0	c8		iny				iny 								; consume command.
.08d1	10 03		bpl $08d6			bpl 	_NXCommandNoFixUp
.08d3	20 dc 08	jsr $08dc			jsr 	FixUpY
.08d6					_NXCommandNoFixUp:
.08d6	0a		asl a				asl 	a 							; shift left
.08d7	da		phx				phx 								; save SP on stack
.08d8	aa		tax				tax				 					; and jump indirect
.08d9	7c 9e 19	jmp ($199e,x)			jmp 	(VectorTable,x)
.08dc					FixUpY:
.08dc	48		pha				pha
.08dd	98		tya				tya
.08de	18		clc				clc
.08df	65 28		adc $28				adc 	codePtr
.08e1	85 28		sta $28				sta 	codePtr
.08e3	90 02		bcc $08e7			bcc 	_NoCPCarry
.08e5	e6 29		inc $29				inc 	codePtr+1
.08e7					_NoCPCarry:
.08e7	a0 00		ldy #$00			ldy 	#0
.08e9	68		pla				pla
.08ea	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.08eb					AbsoluteTOS:
.08eb	fa		plx				plx
.08ec	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08ee	4c 71 08	jmp $0871			jmp 	NextCommand
.08f1					CommandVarSpace:
.08f1	fa		plx				plx
.08f2	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08f4	85 26		sta $26				sta 	availableMemory
.08f6	c8		iny				iny
.08f7	b1 28		lda ($28),y			lda 	(codePtr),y
.08f9	18		clc				clc
.08fa	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08fd	85 27		sta $27				sta 	availableMemory+1
.08ff	c8		iny				iny
.0900	4c 71 08	jmp $0871			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.0903					BinaryAnd:
.0903	fa		plx				plx
.0904	38		sec				sec
.0905	80 02		bra $0909			bra 	AndOrCommon
.0907					BinaryOr:
.0907	fa		plx				plx
.0908	18		clc				clc
.0909					AndOrCommon:
.0909	08		php				php 								; save AND/OR flag
.090a	20 53 10	jsr $1053			jsr 	GetInteger16Bit
.090d	ca		dex				dex
.090e	20 53 10	jsr $1053			jsr 	GetInteger16Bit
.0911	28		plp				plp
.0912	90 0e		bcc $0922			bcc 	_AOCOrCode
.0914	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.0916	35 3f		and $3f,x			and		NSMantissa0+1,x
.0918	95 3e		sta $3e,x			sta 	NSMantissa0,x
.091a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.091c	35 4b		and $4b,x			and		NSMantissa1+1,x
.091e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0920	80 0c		bra $092e			bra 	_AOCComplete
.0922					_AOCOrCode:
.0922	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.0924	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.0926	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0928	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.092a	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.092c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.092e					_AOCComplete:
.092e	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.0930	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.0932	10 07		bpl $093b			bpl 	_AOCExit
.0934	20 63 10	jsr $1063			jsr 	Negate16Bit 				; 2's complement
.0937	a9 80		lda #$80			lda 	#$80 						; make it -ve
.0939	95 32		sta $32,x			sta 	NSStatus,x
.093b					_AOCExit:
.093b	4c 71 08	jmp $0871			jmp 	NextCommand
.093e					ArrayConvert:
.093e	fa		plx				plx
.093f	5a		phy				phy
.0940	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0942	85 2e		sta $2e				sta 	zTemp1
.0944	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0946	18		clc				clc
.0947	6d 07 04	adc $0407			adc 	variableStartPage
.094a	85 2f		sta $2f				sta 	zTemp1+1
.094c	ca		dex				dex 								; count of indices to follow -> zTemp2
.094d	20 4d 10	jsr $104d			jsr 	GetInteger8Bit
.0950	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.0952	8a		txa				txa
.0953	38		sec				sec
.0954	e5 30		sbc $30				sbc 	zTemp2
.0956	aa		tax				tax
.0957	da		phx				phx 								; stack points at the first index, which will be replaced.
.0958					_ACIndexLoop:
.0958	20 95 22	jsr $2295			jsr 	FloatIntegerPart 			; integer array index
.095b	20 53 10	jsr $1053			jsr 	GetInteger16Bit 			; get the index => zTemp0
.095e	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.0960	a5 2c		lda $2c				lda 	zTemp0
.0962	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0964	a5 2d		lda $2d				lda 	zTemp0+1
.0966	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0968	b0 79		bcs $09e3			bcs 	_ACBadIndex 				; index error.
.096a	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.096c	f0 29		beq $0997			beq 	_ACInnerLevel
.096e	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.0970	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0972	10 6f		bpl $09e3			bpl 	_ACBadIndex
.0974	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0976	26 2d		rol $2d				rol 	zTemp0+1
.0978	18		clc				clc
.0979	a5 2c		lda $2c				lda		zTemp0
.097b	65 2e		adc $2e				adc 	zTemp1
.097d	85 2c		sta $2c				sta 	zTemp0
.097f	a5 2d		lda $2d				lda		zTemp0+1
.0981	65 2f		adc $2f				adc 	zTemp1+1
.0983	85 2d		sta $2d				sta 	zTemp0+1
.0985	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.0987	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0989	85 2e		sta $2e				sta 	zTemp1
.098b	c8		iny				iny
.098c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.098e	18		clc				clc
.098f	6d 07 04	adc $0407			adc 	variableStartPage
.0992	85 2f		sta $2f				sta 	zTemp1+1
.0994	e8		inx				inx 								; next index
.0995	80 c1		bra $0958			bra 	_ACIndexLoop
.0997					_ACInnerLevel:
.0997	a0 02		ldy #$02			ldy 	#2
.0999	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.099b	30 46		bmi $09e3			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.099d	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.099f	c9 00		cmp #$00			cmp 	#NSSIFloat
.09a1	d0 13		bne $09b6			bne 	_ACNotFloat
.09a3	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.09a5	48		pha				pha
.09a6	a5 2c		lda $2c				lda 	zTemp0
.09a8	06 2c		asl $2c				asl 	zTemp0 						; x 2
.09aa	26 2d		rol $2d				rol 	zTemp0+1
.09ac	18		clc				clc 								; add back x 3
.09ad	65 2c		adc $2c				adc 	zTemp0
.09af	85 2c		sta $2c				sta 	zTemp0
.09b1	68		pla				pla
.09b2	65 2d		adc $2d				adc 	zTemp0+1
.09b4	85 2d		sta $2d				sta 	zTemp0+1
.09b6					_ACNotFloat:
.09b6	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.09b8	26 2d		rol $2d				rol 	zTemp0+1
.09ba	18		clc				clc
.09bb	a5 2c		lda $2c				lda 	zTemp0
.09bd	69 03		adc #$03			adc 	#3
.09bf	85 2c		sta $2c				sta 	zTemp0
.09c1	90 02		bcc $09c5			bcc 	_ACNoCarry
.09c3	e6 2d		inc $2d				inc 	zTemp0+1
.09c5					_ACNoCarry:
.09c5	fa		plx				plx 								; X points to first slot of array parameters
.09c6	18		clc				clc
.09c7	a5 2c		lda $2c				lda 	zTemp0
.09c9	65 2e		adc $2e				adc 	zTemp1
.09cb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.09cd	a5 2d		lda $2d				lda 	zTemp0+1
.09cf	65 2f		adc $2f				adc 	zTemp1+1
.09d1	38		sec				sec
.09d2	ed 07 04	sbc $0407			sbc 	variableStartPage
.09d5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.09d7	74 56		stz $56,x			stz 	NSMantissa2,x
.09d9	74 62		stz $62,x			stz 	NSMantissa3,x
.09db	74 32		stz $32,x			stz 	NSStatus,x
.09dd	74 6e		stz $6e,x			stz 	NSExponent,x
.09df	7a		ply				ply 	 							; restore code pointer
.09e0	4c 71 08	jmp $0871			jmp 	NextCommand
.09e3					_ACBadIndex:
.09e3	4c ef 1f	jmp $1fef		jmp	ErrorV_index
.09e6					UnaryAsc:
.09e6	fa		plx				plx
.09e7	5a		phy				phy
.09e8	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09ea	85 2c		sta $2c				sta 	zTemp0
.09ec	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09ee	85 2d		sta $2d				sta 	zTemp0+1
.09f0	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09f2	f0 06		beq $09fa			beq 	_UAExit
.09f4	5a		phy				phy 								; otherwise first character
.09f5	a0 01		ldy #$01			ldy 	#1
.09f7	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09f9	7a		ply				ply
.09fa					_UAExit:
.09fa	20 5c 26	jsr $265c			jsr 	FloatSetByte
.09fd	7a		ply				ply
.09fe	4c 71 08	jmp $0871			jmp 	NextCommand
.0a01					CommandAssert:
.0a01	fa		plx				plx
.0a02	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.0a04	d0 09		bne $0a0f			bne 	_CAFail
.0a06	20 7c 26	jsr $267c			jsr 	FloatIsZero 				; is it zero ?
.0a09	f0 04		beq $0a0f			beq 	_CAFail
.0a0b	ca		dex				dex
.0a0c	4c 71 08	jmp $0871			jmp 	NextCommand
.0a0f					_CAFail:
.0a0f	4c 48 1f	jmp $1f48		jmp	ErrorV_assert
.0a12					X16_Audio_Parameters8_16:
.0a12	20 18 0a	jsr $0a18			jsr 	X16_Audio_Parameters8_8
.0a15	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.0a17	60		rts				rts
.0a18					X16_Audio_Parameters8_8:
.0a18	a2 01		ldx #$01			ldx 	#1
.0a1a	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.0a1d	ca		dex				dex
.0a1e	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.0a21	20 4d 10	jsr $104d			jsr 	GetInteger8Bit
.0a24	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.0a26	a0 00		ldy #$00			ldy 	#0
.0a28	60		rts				rts
.0a29					X16_Audio_Parameters8_String:
.0a29	20 12 0a	jsr $0a12			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.0a2c	da		phx				phx 								; set the voice
.0a2d	5a		phy				phy
.0a2e	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.0a31	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>0a34	0a						.byte 	X16_AudioCodeBank
.0a35	7a		ply				ply
.0a36	fa		plx				plx
.0a37	86 2c		stx $2c				stx 	zTemp0
.0a39	84 2d		sty $2d				sty 	zTemp0+1
.0a3b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a3d	e8		inx				inx 								; point YX to first character.
.0a3e	d0 01		bne $0a41			bne 	_X16APSSkip
.0a40	c8		iny				iny
.0a41					_X16APSSkip:
.0a41	60		rts				rts
.0a42					Unary16Bin:
.0a42	fa		plx				plx
.0a43	20 53 10	jsr $1053			jsr 	GetInteger16Bit				; 16 bit int
.0a46	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a48	20 1d 17	jsr $171d			jsr 	StringAllocTemp
.0a4b	a5 2d		lda $2d				lda 	zTemp0+1
.0a4d	f0 03		beq $0a52			beq 	_UBNoHigh
.0a4f	20 5a 0a	jsr $0a5a			jsr 	_UBWriteBinary
.0a52					_UBNoHigh:
.0a52	a5 2c		lda $2c				lda 	zTemp0
.0a54	20 5a 0a	jsr $0a5a			jsr 	_UBWriteBinary
.0a57	4c 71 08	jmp $0871			jmp 	NextCommand
.0a5a					_UBWriteBinary:
.0a5a	5a		phy				phy
.0a5b	a0 08		ldy #$08			ldy 	#8
.0a5d					_UBWLoop:
.0a5d	0a		asl a				asl 	a
.0a5e	48		pha				pha
.0a5f	a9 00		lda #$00			lda  	#0
.0a61	69 30		adc #$30			adc 	#48
.0a63	20 46 17	jsr $1746			jsr 	StringWriteChar
.0a66	68		pla				pla
.0a67	88		dey				dey
.0a68	d0 f3		bne $0a5d			bne 	_UBWLoop
.0a6a	7a		ply				ply
.0a6b	60		rts				rts
.0a6c					PrintCharacterX:
.0a6c	fa		plx				plx
.0a6d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a6f	ca		dex				dex
.0a70	20 7a 13	jsr $137a			jsr 	VectorPrintCharacter
.0a73	4c 71 08	jmp $0871			jmp 	NextCommand
.0a76					UnaryChr:
.0a76	fa		plx				plx
.0a77	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; get integer to convert.
.0a7a	48		pha				pha 								; save it and allocate for it
.0a7b	a9 01		lda #$01			lda 	#1 							; 1 character
.0a7d	20 1d 17	jsr $171d			jsr 	StringAllocTemp
.0a80	a9 01		lda #$01			lda 	#1 							; length 1.
.0a82	92 22		sta ($22)			sta 	(zsTemp)
.0a84	68		pla				pla 								; character code makes string.
.0a85	5a		phy				phy
.0a86	a0 01		ldy #$01			ldy 	#1
.0a88	91 22		sta ($22),y			sta 	(zsTemp),y
.0a8a	7a		ply				ply
.0a8b	4c 71 08	jmp $0871			jmp 	NextCommand
.0a8e					CommandClr:
.0a8e	fa		plx				plx
.0a8f	20 95 0a	jsr $0a95			jsr 	ClearMemory
.0a92	4c 71 08	jmp $0871			jmp 	NextCommand
.0a95					ClearMemory:
.0a95	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a98	85 2d		sta $2d				sta 	zTemp0+1
.0a9a	64 2c		stz $2c				stz 	zTemp0
.0a9c	5a		phy				phy
.0a9d	a0 00		ldy #$00			ldy 	#0
.0a9f					_ClearLoop1:
.0a9f	a9 00		lda #$00			lda 	#0
.0aa1	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0aa3	c8		iny				iny
.0aa4	d0 f9		bne $0a9f			bne 	_ClearLoop1
.0aa6	e6 2d		inc $2d				inc 	zTemp0+1
.0aa8	a5 2d		lda $2d				lda 	zTemp0+1
.0aaa	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0aad	d0 f0		bne $0a9f			bne 	_ClearLoop1
.0aaf	38		sec				sec 											; stack space = number of pages in total / 4
.0ab0	ad 06 04	lda $0406			lda 	storeEndHigh
.0ab3	ed 05 04	sbc $0405			sbc		storeStartHigh
.0ab6	4a		lsr a				lsr 	a
.0ab7	4a		lsr a				lsr 	a
.0ab8	d0 02		bne $0abc			bne 	_NotEmpty 								; at least 1 !
.0aba	a9 01		lda #$01			lda 	#1
.0abc					_NotEmpty:
.0abc	38		sec				sec 											; subtract from high to give string high memory
.0abd	49 ff		eor #$ff			eor 	#$FF
.0abf	6d 06 04	adc $0406			adc 	storeEndHigh
.0ac2	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0ac5	9c 02 04	stz $0402			stz 	stringHighMemory
.0ac8	9c 68 05	stz $0568			stz 	stringInitialised 						; string system not initialised
.0acb	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0ace	3a		dec a				dec 	a
.0acf	85 25		sta $25				sta 	runtimeStackPtr+1
.0ad1	a9 ff		lda #$ff			lda 	#$FF
.0ad3	85 24		sta $24				sta 	runtimeStackPtr
.0ad5	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0ad7	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0ad9	7a		ply				ply
.0ada	60		rts				rts
.0adb					CompareStrings:
.0adb	fa		plx				plx
.0adc	ca		dex				dex
.0add	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0adf	85 2c		sta $2c				sta 	zTemp0
.0ae1	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ae3	85 2d		sta $2d				sta 	zTemp0+1
.0ae5	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0ae7	85 2e		sta $2e				sta 	zTemp1
.0ae9	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0aeb	85 2f		sta $2f				sta 	zTemp1+1
.0aed	da		phx				phx
.0aee	5a		phy				phy
.0aef	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0af1	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0af3	90 02		bcc $0af7			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0af5	b2 2e		lda ($2e)			lda 	(zTemp1)
.0af7					_CSNIsSmallest:
.0af7	aa		tax				tax 								; count in X
.0af8	f0 0c		beq $0b06			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0afa	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0afc					_CSNCompareString:
.0afc	c8		iny				iny 								; pre increment
.0afd	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0aff	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0b01	d0 0a		bne $0b0d			bne 	_CSNDifferent 				; numbers are different.
.0b03	ca		dex				dex
.0b04	d0 f6		bne $0afc			bne 	_CSNCompareString 			; compare common characters in two strings.
.0b06					_CSNMatches:
.0b06	38		sec				sec
.0b07	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0b09	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0b0b	f0 06		beq $0b13			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0b0d					_CSNDifferent:
.0b0d	a9 ff		lda #$ff			lda 	#$FF
.0b0f	90 02		bcc $0b13			bcc 	_CSNSExit
.0b11	a9 01		lda #$01			lda 	#$01
.0b13					_CSNSExit:
.0b13	7a		ply				ply
.0b14	fa		plx				plx
.0b15	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0b17	20 5c 26	jsr $265c			jsr 	FloatSetByte 				; output the byte
.0b1a	4c 71 08	jmp $0871			jmp 	NextCommand
.0b1d					StringConcrete:
.0b1d	9c 68 05	stz $0568			stz 	stringInitialised	 		; initialise next usage
.0b20	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0b22	85 30		sta $30				sta 	zTemp2
.0b24	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0b26	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0b27	18		clc				clc
.0b28	72 30		adc ($30)			adc 	(zTemp2)
.0b2a	90 02		bcc $0b2e			bcc 	_SCNoOverflow
.0b2c	a9 ff		lda #$ff			lda 	#255
.0b2e					_SCNoOverflow:
.0b2e	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0b30	b0 02		bcs $0b34			bcs 	_SCNoMinimum
.0b32	a9 0a		lda #$0a			lda 	#10
.0b34					_SCNoMinimum:
.0b34	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0b36	38		sec				sec
.0b37	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0b3a	e5 2e		sbc $2e				sbc 	zTemp1
.0b3c	a8		tay				tay
.0b3d	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b40	e9 00		sbc #$00			sbc 	#0
.0b42	48		pha				pha
.0b43	38		sec				sec 								; subtract 3 more
.0b44	98		tya				tya
.0b45	e9 03		sbc #$03			sbc 	#3
.0b47	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b4a	85 22		sta $22				sta 	zsTemp
.0b4c	68		pla				pla
.0b4d	e9 00		sbc #$00			sbc 	#0
.0b4f	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b52	85 23		sta $23				sta 	zsTemp+1
.0b54	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b56	92 22		sta ($22)			sta 	(zsTemp)
.0b58	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b5a	a9 00		lda #$00			lda 	#0
.0b5c	91 22		sta ($22),y			sta 	(zsTemp),y
.0b5e	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b60	a4 23		ldy $23				ldy 	zsTemp+1
.0b62	60		rts				rts
.0b63					CommandXData:
.0b63	fa		plx				plx
.0b64	98		tya				tya 								; data length +1 added to Y
.0b65	38		sec				sec
.0b66	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b68	a8		tay				tay
.0b69	4c 71 08	jmp $0871			jmp 	NextCommand
.0b6c					CommandXDIM:
.0b6c	fa		plx				plx
.0b6d	5a		phy				phy
.0b6e	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b71	8d 08 04	sta $0408			sta 	dimType
.0b74	ca		dex				dex 								; this is the number of indices
.0b75	20 4d 10	jsr $104d			jsr 	GetInteger8Bit
.0b78	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b7a	8a		txa				txa 								; dimension.
.0b7b	38		sec				sec
.0b7c	e5 2e		sbc $2e				sbc 	zTemp1
.0b7e	aa		tax				tax
.0b7f	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b81	20 95 0b	jsr $0b95			jsr 	DIMCreateOneLevel 			; create one at this level
.0b84	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b86	98		tya				tya
.0b87	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b89	74 56		stz $56,x			stz 	NSMantissa2,x
.0b8b	74 62		stz $62,x			stz 	NSMantissa3,x
.0b8d	74 32		stz $32,x			stz 	NSStatus,x
.0b8f	74 6e		stz $6e,x			stz 	NSExponent,x
.0b91	7a		ply				ply
.0b92	4c 71 08	jmp $0871			jmp 	NextCommand
.0b95					DIMCreateOneLevel:
.0b95	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b97	5a		phy				phy
.0b98	a4 27		ldy $27				ldy 	availableMemory+1
.0b9a	5a		phy				phy
.0b9b	a8		tay				tay 			 					; save current level into Y
.0b9c	20 53 10	jsr $1053			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b9f	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0ba1	d0 02		bne $0ba5			bne 	_DCOLNoCarry
.0ba3	e6 2d		inc $2d				inc 	zTemp0+1
.0ba5					_DCOLNoCarry:
.0ba5	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0ba7	20 48 0c	jsr $0c48			jsr 	DIMWriteByte
.0baa	a5 2d		lda $2d				lda 	zTemp0+1
.0bac	20 48 0c	jsr $0c48			jsr 	DIMWriteByte
.0baf	ad 08 04	lda $0408			lda 	dimType 					; get type information
.0bb2	29 7f		and #$7f			and 	#$7F
.0bb4	c0 01		cpy #$01			cpy 	#1
.0bb6	f0 02		beq $0bba			beq 	_DCOLNoSubLevel
.0bb8	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0bba					_DCOLNoSubLevel:
.0bba	20 48 0c	jsr $0c48			jsr 	DIMWriteByte
.0bbd	a5 26		lda $26				lda 	availableMemory
.0bbf	85 2e		sta $2e				sta 	zTemp1
.0bc1	a5 27		lda $27				lda 	availableMemory+1
.0bc3	85 2f		sta $2f				sta 	zTemp1+1
.0bc5	a5 2c		lda $2c				lda 	zTemp0
.0bc7	85 30		sta $30				sta 	zTemp2
.0bc9	a5 2d		lda $2d				lda 	zTemp0+1
.0bcb	85 31		sta $31				sta 	zTemp2+1
.0bcd					_DCOLFillArray:
.0bcd	20 2c 0c	jsr $0c2c			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0bd0	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0bd2	d0 02		bne $0bd6			bne 	_DCOLNoBorrow
.0bd4	c6 2d		dec $2d				dec 	zTemp0+1
.0bd6					_DCOLNoBorrow:
.0bd6	c6 2c		dec $2c				dec 	zTemp0
.0bd8	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0bda	05 2d		ora $2d				ora 	zTemp0+1
.0bdc	d0 ef		bne $0bcd			bne 	_DCOLFillArray
.0bde	c0 01		cpy #$01			cpy 	#1
.0be0	f0 42		beq $0c24			beq 	_DCOLExit
.0be2					_DCOLRecursionLoop:
.0be2	da		phx				phx 								; save XY
.0be3	5a		phy				phy
.0be4	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0be6	48		pha				pha
.0be7	a5 2f		lda $2f				lda 	zTemp1+1
.0be9	48		pha				pha
.0bea	a5 30		lda $30				lda 	zTemp2
.0bec	48		pha				pha
.0bed	a5 31		lda $31				lda 	zTemp2+1
.0bef	48		pha				pha
.0bf0	88		dey				dey  								; lower level -> A
.0bf1	98		tya				tya
.0bf2	e8		inx				inx 								; next index size
.0bf3	20 95 0b	jsr $0b95			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0bf6	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0bf7	86 31		stx $31				stx 	zTemp2+1
.0bf9	fa		plx				plx
.0bfa	86 30		stx $30				stx 	zTemp2
.0bfc	fa		plx				plx
.0bfd	86 2f		stx $2f				stx 	zTemp1+1
.0bff	fa		plx				plx
.0c00	86 2e		stx $2e				stx 	zTemp1
.0c02	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0c04	98		tya				tya
.0c05	a0 01		ldy #$01			ldy 	#1
.0c07	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0c09	7a		ply				ply 								; restore XY
.0c0a	fa		plx				plx
.0c0b	18		clc				clc
.0c0c	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0c0e	69 02		adc #$02			adc 	#2
.0c10	85 2e		sta $2e				sta 	zTemp1
.0c12	90 02		bcc $0c16			bcc 	_DCOLRNoCarry
.0c14	e6 2f		inc $2f				inc 	zTemp1+1
.0c16					_DCOLRNoCarry:
.0c16	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0c18	d0 02		bne $0c1c			bne 	_DCOLRNoBorrow
.0c1a	c6 31		dec $31				dec 	zTemp2+1
.0c1c					_DCOLRNoBorrow:
.0c1c	c6 30		dec $30				dec 	zTemp2
.0c1e	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0c20	05 31		ora $31				ora 	zTemp2+1
.0c22	d0 be		bne $0be2			bne 	_DCOLRecursionLoop
.0c24					_DCOLExit:
.0c24	68		pla				pla 								; get MSB, make offset again
.0c25	38		sec				sec
.0c26	ed 07 04	sbc $0407			sbc 	variableStartPage
.0c29	a8		tay				tay
.0c2a	68		pla				pla 								; YA now contains offset address.
.0c2b	60		rts				rts
.0c2c					DIMWriteElement:
.0c2c	da		phx				phx
.0c2d	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0c2f	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0c31	d0 0b		bne $0c3e			bne 	_DIMWENotFloat
.0c33	ad 08 04	lda $0408			lda 	dimType
.0c36	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0c38	c9 00		cmp #$00			cmp 	#NSSIFloat
.0c3a	d0 02		bne $0c3e			bne 	_DIMWENotFloat
.0c3c	a2 06		ldx #$06			ldx 	#6
.0c3e					_DIMWENotFloat:
.0c3e	a9 00		lda #$00			lda 	#0
.0c40	20 48 0c	jsr $0c48			jsr 	DIMWriteByte
.0c43	ca		dex				dex
.0c44	d0 f8		bne $0c3e			bne 	_DIMWENotFloat
.0c46	fa		plx				plx
.0c47	60		rts				rts
.0c48					DIMWriteByte:
.0c48	92 26		sta ($26)			sta 	(availableMemory)
.0c4a	e6 26		inc $26				inc 	availableMemory
.0c4c	d0 0b		bne $0c59			bne 	_DIMWBSkip
.0c4e	e6 27		inc $27				inc 	availableMemory+1
.0c50	48		pha				pha
.0c51	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c53	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c56	b0 02		bcs $0c5a			bcs 	_DIMWBMemory
.0c58	68		pla				pla
.0c59					_DIMWBSkip:
.0c59	60		rts				rts
.0c5a					_DIMWBMemory:
.0c5a	4c 02 20	jmp $2002		jmp	ErrorV_memory
.0408					dimType:
>0408							.fill 	1
.0c5d					CommandEnd:
.0c5d	fa		plx				plx
.0c5e	86 2c		stx $2c				stx 	zTemp0
.0c60	4c ff ff	jmp $ffff			jmp 	$FFFF
.0c63					Unimplemented:
.0c63	4c 35 1f	jmp $1f35			jmp 	ErrorV_unimplemented
.0c66					RuntimeErrorHandler:
.0c66	98		tya				tya
.0c67	18		clc				clc
.0c68	65 28		adc $28				adc 	codePtr
.0c6a	85 28		sta $28				sta 	codePtr
.0c6c	90 02		bcc $0c70			bcc 	_EHNoCarry
.0c6e	e6 29		inc $29				inc 	codePtr+1
.0c70					_EHNoCarry:
.0c70	68		pla				pla
.0c71	7a		ply				ply
.0c72	85 2c		sta $2c				sta 	zTemp0
.0c74	84 2d		sty $2d				sty 	zTemp0+1
.0c76	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c78	a0 01		ldy #$01			ldy 	#1
.0c7a					_EHDisplayMsg:
.0c7a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c7c	20 92 1c	jsr $1c92			jsr 	XPrintCharacterToChannel
.0c7f	c8		iny				iny
.0c80	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c82	d0 f6		bne $0c7a			bne 	_EHDisplayMsg
.0c84	a9 20		lda #$20			lda 	#32
.0c86	20 92 1c	jsr $1c92			jsr 	XPrintCharacterToChannel
.0c89	a9 40		lda #$40			lda 	#64
.0c8b	20 92 1c	jsr $1c92			jsr 	XPrintCharacterToChannel
.0c8e	a9 20		lda #$20			lda 	#32
.0c90	20 92 1c	jsr $1c92			jsr 	XPrintCharacterToChannel
.0c93	20 98 0c	jsr $0c98			jsr 	EHDisplayCodePtr
.0c96	80 fe		bra $0c96	_EHStop:bra 	_EHStop
.0c98					EHDisplayCodePtr:
.0c98	a9 24		lda #$24			lda 	#'$'
.0c9a	20 92 1c	jsr $1c92			jsr 	XPrintCharacterToChannel
.0c9d	38		sec				sec
.0c9e	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0ca0	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0ca3	20 ac 0c	jsr $0cac			jsr 	_EHDisplayHex
.0ca6	a5 28		lda $28				lda 	codePtr
.0ca8	20 ac 0c	jsr $0cac			jsr 	_EHDisplayHex
.0cab	60		rts				rts
.0cac					_EHDisplayHex:
.0cac	48		pha				pha
.0cad	4a		lsr a				lsr 	a
.0cae	4a		lsr a				lsr 	a
.0caf	4a		lsr a				lsr 	a
.0cb0	4a		lsr a				lsr 	a
.0cb1	20 b5 0c	jsr $0cb5			jsr 	_EHDisplayNibble
.0cb4	68		pla				pla
.0cb5					_EHDisplayNibble:
.0cb5	29 0f		and #$0f			and 	#15
.0cb7	c9 0a		cmp #$0a			cmp 	#10
.0cb9	90 02		bcc $0cbd			bcc 	_EHNotHex
.0cbb	69 06		adc #$06			adc 	#6
.0cbd					_EHNotHex:
.0cbd	69 30		adc #$30			adc 	#48
.0cbf	4c 92 1c	jmp $1c92			jmp 	XPrintCharacterToChannel
.0cc2					CommandXFor:
.0cc2	fa		plx				plx
.0cc3	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0cc5	20 45 0d	jsr $0d45			jsr 	StackOpenFrame
.0cc8	20 84 11	jsr $1184			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0ccb	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0ccd	20 27 0d	jsr $0d27			jsr 	CopyTOSToOffsetY
.0cd0	ca		dex				dex
.0cd1	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0cd3	20 27 0d	jsr $0d27			jsr 	CopyTOSToOffsetY
.0cd6	ca		dex				dex
.0cd7	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0cd9	29 80		and #$80			and 	#$80
.0cdb	a0 04		ldy #$04			ldy 	#4
.0cdd	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cdf	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0ce1	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0ce3	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ce5	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0ce7	c8		iny				iny
.0ce8	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cea	18		clc				clc
.0ceb	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0ced	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cef	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0cf2	85 2d		sta $2d				sta 	zTemp0+1
.0cf4	ca		dex				dex 								; throw reference.
.0cf5	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0cf7	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0cf9	a0 0c		ldy #$0c			ldy 	#12
.0cfb	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cfd	a0 12		ldy #$12			ldy 	#18
.0cff	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d01	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0d03	88		dey				dey 								; now the exponents.
.0d04	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0d06	a0 0b		ldy #$0b			ldy 	#11
.0d08	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d0a	a0 11		ldy #$11			ldy 	#17
.0d0c	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d0e	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0d10	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d12	c8		iny				iny
.0d13	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d15	c8		iny				iny
.0d16	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d18	d0 08		bne $0d22			bne 	_CFNoOptimise
.0d1a	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0d1c	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0d1e	09 40		ora #$40			ora 	#$40
.0d20	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d22					_CFNoOptimise:
.0d22	a0 00		ldy #$00			ldy 	#0
.0d24	4c 71 08	jmp $0871			jmp 	NextCommand
.0d27					CopyTOSToOffsetY:
.0d27	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0d29	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d2b	c8		iny				iny
.0d2c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0d2e	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d30	c8		iny				iny
.0d31	b5 56		lda $56,x			lda 	NSMantissa2,x
.0d33	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d35	c8		iny				iny
.0d36	b5 62		lda $62,x			lda 	NSMantissa3,x
.0d38	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d3a	c8		iny				iny
.0d3b	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d3d	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d3f	c8		iny				iny
.0d40	b5 32		lda $32,x			lda 	NSStatus,x
.0d42	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d44	60		rts				rts
.0d45					StackOpenFrame:
.0d45	48		pha				pha 								; save frame marker
.0d46	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d48	85 2c		sta $2c				sta 	zTemp0
.0d4a	38		sec				sec 								; subtract from runtime stack pointer.
.0d4b	a5 24		lda $24				lda		runtimeStackPtr
.0d4d	e5 2c		sbc $2c				sbc 	zTemp0
.0d4f	85 24		sta $24				sta 	runtimeStackPtr
.0d51	a5 25		lda $25				lda		runtimeStackPtr+1
.0d53	e9 00		sbc #$00			sbc 	#0
.0d55	85 25		sta $25				sta 	runtimeStackPtr+1
.0d57	68		pla				pla 								; put frame marker at +0
.0d58	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d5a	60		rts				rts
.0d5b					StackCloseFrame:
.0d5b	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d5d	29 1f		and #$1f			and 	#$1F 						; size
.0d5f	18		clc				clc
.0d60	65 24		adc $24				adc 	runtimeStackPtr
.0d62	85 24		sta $24				sta 	runtimeStackPtr
.0d64	90 02		bcc $0d68			bcc 	_SCFNoCarry
.0d66	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d68					_SCFNoCarry:
.0d68	60		rts				rts
.0d69					StackFindFrame:
.0d69	8d 09 04	sta $0409			sta 	requiredFrame
.0d6c					_SFFLoop:
.0d6c	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d6e	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d70	f0 10		beq $0d82			beq 	SCFFail
.0d72	cd 09 04	cmp $0409			cmp 	requiredFrame 				; found this type ?
.0d75	f0 05		beq $0d7c			beq 	_SFFFound
.0d77	20 5b 0d	jsr $0d5b			jsr 	StackCloseFrame 			; close the top frame
.0d7a	80 f0		bra $0d6c			bra 	_SFFLoop 					; and try te next.
.0d7c					_SFFFound:
.0d7c	60		rts				rts
.0d7d					StackCheckFrame:
.0d7d	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d7f	d0 01		bne $0d82			bne 	SCFFail
.0d81	60		rts				rts
.0d82					SCFFail:
.0d82	4c 92 1f	jmp $1f92		jmp	ErrorV_structure
.0409					requiredFrame:
>0409							.fill 	1
.0d85					UnaryFre:
.0d85	fa		plx				plx
.0d86	20 5a 26	jsr $265a			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d89	38		sec				sec
.0d8a	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d8d	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d90	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d92	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d95	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d98	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d9a	4c 71 08	jmp $0871			jmp 	NextCommand
.0d9d					CommandXGet:
.0d9d	fa		plx				plx
.0d9e	e8		inx				inx
.0d9f	a9 01		lda #$01			lda 	#1 							; 1 character space
.0da1	20 1d 17	jsr $171d			jsr 	StringAllocTemp
.0da4	20 83 13	jsr $1383			jsr 	VectorGetCharacter 			; get a character
.0da7	c9 00		cmp #$00			cmp 	#0
.0da9	f0 09		beq $0db4			beq 	_CGNone
.0dab	5a		phy				phy
.0dac	a0 01		ldy #$01			ldy 	#1 							; store char
.0dae	91 22		sta ($22),y			sta 	(zsTemp),y
.0db0	98		tya				tya 								; store length.
.0db1	92 22		sta ($22)			sta 	(zsTemp)
.0db3	7a		ply				ply
.0db4					_CGNone:
.0db4	4c 71 08	jmp $0871			jmp 	NextCommand
.0db7					CommandXGosub:
.0db7	fa		plx				plx
.0db8	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dba	20 45 0d	jsr $0d45			jsr 	StackOpenFrame
.0dbd	20 84 11	jsr $1184			jsr 	StackSaveCurrentPosition
.0dc0	4c d5 0d	jmp $0dd5			jmp 	PerformGOTO
.0dc3					CommandReturn:
.0dc3	fa		plx				plx
.0dc4	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dc6	20 69 0d	jsr $0d69			jsr 	StackFindFrame
.0dc9	20 95 11	jsr $1195			jsr 	StackLoadCurrentPosition
.0dcc	c8		iny				iny
.0dcd	c8		iny				iny
.0dce	20 5b 0d	jsr $0d5b			jsr 	StackCloseFrame
.0dd1	4c 71 08	jmp $0871			jmp 	NextCommand
.0dd4					CommandXGoto:
.0dd4	fa		plx				plx
.0dd5					PerformGOTO:
.0dd5	c8		iny				iny 								; push MSB of offset on stack
.0dd6	b1 28		lda ($28),y			lda 	(codePtr),y
.0dd8	48		pha				pha
.0dd9	88		dey				dey 								; point LSB of offset
.0dda	18		clc				clc 								; add LSB
.0ddb	b1 28		lda ($28),y			lda 	(codePtr),y
.0ddd	65 28		adc $28				adc 	codePtr
.0ddf	85 28		sta $28				sta 	codePtr
.0de1	68		pla				pla 								; restore offset MSB and add
.0de2	65 29		adc $29				adc 	codePtr+1
.0de4	85 29		sta $29				sta 	codePtr+1
.0de6	4c 71 08	jmp $0871			jmp 	NextCommand
.0de9					CommandGotoZ:
.0de9	fa		plx				plx
.0dea	20 7c 26	jsr $267c			jsr 	FloatIsZero
.0ded	ca		dex				dex
.0dee	c9 00		cmp #$00			cmp 	#0
.0df0	f0 e3		beq $0dd5			beq 	PerformGOTO
.0df2	c8		iny				iny
.0df3	c8		iny				iny
.0df4	4c 71 08	jmp $0871			jmp 	NextCommand
.0df7					CommandGotoNZ:
.0df7	fa		plx				plx
.0df8	20 7c 26	jsr $267c			jsr 	FloatIsZero
.0dfb	ca		dex				dex
.0dfc	c9 00		cmp #$00			cmp 	#0
.0dfe	d0 d5		bne $0dd5			bne 	PerformGOTO
.0e00	c8		iny				iny
.0e01	c8		iny				iny
.0e02	4c 71 08	jmp $0871			jmp 	NextCommand
.0e05					Command_PSET:
.0e05	fa		plx				plx
.0e06	5a		phy				phy
.0e07	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; get the colour
.0e0a	48		pha				pha
.0e0b	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e0d	a0 02		ldy #$02			ldy 	#X16_r0
.0e0f	20 91 0e	jsr $0e91			jsr 	GraphicsCopy2
.0e12	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0e15	68		pla				pla 								; set pixel.
.0e16	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0e19	7a		ply				ply
.0e1a	a2 ff		ldx #$ff			ldx 	#$FF
.0e1c	4c 71 08	jmp $0871			jmp 	NextCommand
.0e1f					Command_LINE:
.0e1f	fa		plx				plx
.0e20	5a		phy				phy
.0e21	20 84 0e	jsr $0e84			jsr 	GraphicsColour
.0e24	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0e26	a0 02		ldy #$02			ldy 	#X16_r0
.0e28	20 8e 0e	jsr $0e8e			jsr 	GraphicsCopy4
.0e2b	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0e2e	7a		ply				ply
.0e2f	a2 ff		ldx #$ff			ldx 	#$FF
.0e31	4c 71 08	jmp $0871			jmp 	NextCommand
.0e34					Command_RECT:
.0e34	fa		plx				plx
.0e35	5a		phy				phy
.0e36	20 a5 0e	jsr $0ea5			jsr 	GraphicsRectCoords
.0e39	38		sec				sec
.0e3a	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e3d	7a		ply				ply
.0e3e	a2 ff		ldx #$ff			ldx 	#$FF
.0e40	4c 71 08	jmp $0871			jmp 	NextCommand
.0e43					Command_FRAME:
.0e43	fa		plx				plx
.0e44	5a		phy				phy
.0e45	20 a5 0e	jsr $0ea5			jsr 	GraphicsRectCoords
.0e48	18		clc				clc
.0e49	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e4c	7a		ply				ply
.0e4d	a2 ff		ldx #$ff			ldx 	#$FF
.0e4f	4c 71 08	jmp $0871			jmp 	NextCommand
.0e52					Command_CHAR:
.0e52	fa		plx				plx
.0e53	5a		phy				phy
.0e54	ca		dex				dex  								; set the draw colour
.0e55	20 84 0e	jsr $0e84			jsr 	GraphicsColour
.0e58	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e5a	a0 02		ldy #$02			ldy 	#X16_r0
.0e5c	20 91 0e	jsr $0e91			jsr 	GraphicsCopy2
.0e5f	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e61	85 2c		sta $2c				sta 	zTemp0
.0e63	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e65	85 2d		sta $2d				sta 	zTemp0+1
.0e67	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e69	85 2e		sta $2e				sta 	zTemp1
.0e6b					_CCLoop:
.0e6b	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e6d	f0 0f		beq $0e7e			beq 	_CCExit
.0e6f	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e71	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e73	d0 02		bne $0e77			bne 	_CCNoCarry
.0e75	e6 2d		inc $2d				inc 	zTemp0+1
.0e77					_CCNoCarry:
.0e77	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e79	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e7c	80 ed		bra $0e6b			bra 	_CCLoop						; go round.
.0e7e					_CCExit:
.0e7e	7a		ply				ply
.0e7f	a2 ff		ldx #$ff			ldx 	#$FF
.0e81	4c 71 08	jmp $0871			jmp 	NextCommand
.0e84					GraphicsColour:
.0e84	20 4d 10	jsr $104d			jsr 	GetInteger8Bit
.0e87	aa		tax				tax
.0e88	a0 00		ldy #$00			ldy 	#0
.0e8a	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e8d	60		rts				rts
.0e8e					GraphicsCopy4:
.0e8e	20 91 0e	jsr $0e91			jsr 	GraphicsCopy2
.0e91					GraphicsCopy2:
.0e91	20 94 0e	jsr $0e94			jsr 	GraphicsCopy1
.0e94					GraphicsCopy1:
.0e94	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.0e97	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e99	99 00 00	sta $0000,y			sta 	0,y
.0e9c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e9e	99 01 00	sta $0001,y			sta 	1,y
.0ea1	e8		inx				inx
.0ea2	c8		iny				iny
.0ea3	c8		iny				iny
.0ea4	60		rts				rts
.0ea5					GraphicsRectCoords:
.0ea5	20 84 0e	jsr $0e84			jsr 	GraphicsColour 				; set colour
.0ea8	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0eaa	a0 02		ldy #$02			ldy 	#X16_r0
.0eac	20 8e 0e	jsr $0e8e			jsr 	GraphicsCopy4
.0eaf	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0eb1	20 be 0e	jsr $0ebe			jsr 	_GRCSortSubtract
.0eb4	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0eb6	20 be 0e	jsr $0ebe			jsr 	_GRCSortSubtract
.0eb9	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0ebb	74 09		stz $09,x			stz 	9,x
.0ebd	60		rts				rts
.0ebe					_GRCSortSubtract:
.0ebe	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0ec0	d5 00		cmp $00,x			cmp 	0,x
.0ec2	b5 05		lda $05,x			lda 	5,x
.0ec4	f5 01		sbc $01,x			sbc 	1,x
.0ec6	b0 08		bcs $0ed0			bcs 	_GRCNoSwap 					; >= swap.
.0ec8	20 de 0e	jsr $0ede			jsr 	_GRCSwapByte 				; swap 0/2
.0ecb	e8		inx				inx
.0ecc	20 de 0e	jsr $0ede			jsr 	_GRCSwapByte 				; swap 1/3
.0ecf	ca		dex				dex
.0ed0					_GRCNoSwap:
.0ed0	38		sec				sec 								; calculate width/height into 4,5
.0ed1	b5 04		lda $04,x			lda 	4,x
.0ed3	f5 00		sbc $00,x			sbc 	0,x
.0ed5	95 04		sta $04,x			sta 	4,x
.0ed7	b5 05		lda $05,x			lda 	5,x
.0ed9	f5 01		sbc $01,x			sbc 	1,x
.0edb	95 05		sta $05,x			sta 	5,x
.0edd	60		rts				rts
.0ede					_GRCSwapByte:
.0ede	b5 04		lda $04,x			lda 	4,x
.0ee0	48		pha				pha
.0ee1	b5 00		lda $00,x			lda 	0,x
.0ee3	95 04		sta $04,x			sta 	4,x
.0ee5	68		pla				pla
.0ee6	95 00		sta $00,x			sta 	0,x
.0ee8	60		rts				rts
.0ee9					Unary16Hex:
.0ee9	fa		plx				plx
.0eea	20 53 10	jsr $1053			jsr 	GetInteger16Bit
.0eed	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0eef	20 1d 17	jsr $171d			jsr 	StringAllocTemp
.0ef2	a5 2d		lda $2d				lda 	zTemp0+1
.0ef4	f0 03		beq $0ef9			beq 	_UHNoHigh
.0ef6	20 01 0f	jsr $0f01			jsr 	_UHWriteHex
.0ef9					_UHNoHigh:
.0ef9	a5 2c		lda $2c				lda 	zTemp0
.0efb	20 01 0f	jsr $0f01			jsr 	_UHWriteHex
.0efe	4c 71 08	jmp $0871			jmp 	NextCommand
.0f01					_UHWriteHex:
.0f01	48		pha				pha
.0f02	4a		lsr a				lsr 	a
.0f03	4a		lsr a				lsr 	a
.0f04	4a		lsr a				lsr 	a
.0f05	4a		lsr a				lsr 	a
.0f06	20 0a 0f	jsr $0f0a			jsr 	_UHWriteNibl
.0f09	68		pla				pla
.0f0a					_UHWriteNibl:
.0f0a	29 0f		and #$0f			and 	#15
.0f0c	c9 0a		cmp #$0a			cmp 	#10
.0f0e	90 02		bcc $0f12			bcc 	_UHDigit
.0f10	69 06		adc #$06			adc 	#6
.0f12					_UHDigit:
.0f12	69 30		adc #$30			adc 	#48
.0f14	20 46 17	jsr $1746			jsr 	StringWriteChar
.0f17	60		rts				rts
.0f18					IndFloatRead:
.0f18	fa		plx				plx
.0f19	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f1b	85 2c		sta $2c				sta 	zTemp0
.0f1d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f1f	18		clc				clc
.0f20	6d 07 04	adc $0407			adc 	variableStartPage
.0f23	85 2d		sta $2d				sta 	zTemp0+1
.0f25	ca		dex				dex 								; throw the address
.0f26	20 fc 14	jsr $14fc			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0f29	4c 71 08	jmp $0871			jmp 	NextCommand
.0f2c					IndInt16Read:
.0f2c	fa		plx				plx
.0f2d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f2f	85 2c		sta $2c				sta 	zTemp0
.0f31	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f33	18		clc				clc
.0f34	6d 07 04	adc $0407			adc 	variableStartPage
.0f37	85 2d		sta $2d				sta 	zTemp0+1
.0f39	ca		dex				dex 								; throw the address
.0f3a	20 38 15	jsr $1538			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f3d	4c 71 08	jmp $0871			jmp 	NextCommand
.0f40					IndStringRead:
.0f40	fa		plx				plx
.0f41	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f43	85 2c		sta $2c				sta 	zTemp0
.0f45	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f47	18		clc				clc
.0f48	6d 07 04	adc $0407			adc 	variableStartPage
.0f4b	85 2d		sta $2d				sta 	zTemp0+1
.0f4d	ca		dex				dex 								; throw the address
.0f4e	20 7d 15	jsr $157d			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f51	4c 71 08	jmp $0871			jmp 	NextCommand
.0f54					IndFloatWrite:
.0f54	fa		plx				plx
.0f55	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f57	85 2c		sta $2c				sta 	zTemp0
.0f59	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f5b	18		clc				clc
.0f5c	6d 07 04	adc $0407			adc 	variableStartPage
.0f5f	85 2d		sta $2d				sta 	zTemp0+1
.0f61	20 d7 1a	jsr $1ad7			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f64	ca		dex				dex 								; throw the address as well.
.0f65	4c 71 08	jmp $0871			jmp 	NextCommand
.0f68					IndInt16Write:
.0f68	fa		plx				plx
.0f69	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f6b	85 2c		sta $2c				sta 	zTemp0
.0f6d	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f6f	18		clc				clc
.0f70	6d 07 04	adc $0407			adc 	variableStartPage
.0f73	85 2d		sta $2d				sta 	zTemp0+1
.0f75	20 13 1b	jsr $1b13			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f78	ca		dex				dex 								; throw the address as well.
.0f79	4c 71 08	jmp $0871			jmp 	NextCommand
.0f7c					IndStringWrite:
.0f7c	fa		plx				plx
.0f7d	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f7f	85 2c		sta $2c				sta 	zTemp0
.0f81	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f83	18		clc				clc
.0f84	6d 07 04	adc $0407			adc 	variableStartPage
.0f87	85 2d		sta $2d				sta 	zTemp0+1
.0f89	20 52 1b	jsr $1b52			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f8c	ca		dex				dex 								; throw the address as well.
.0f8d	4c 71 08	jmp $0871			jmp 	NextCommand
.0f90					CommandXInput:
.0f90	fa		plx				plx
.0f91	5a		phy				phy 								; save Y
.0f92	e8		inx				inx									; space on stack
.0f93					_INError:
.0f93	20 c7 0f	jsr $0fc7			jsr 	InputStringToBuffer 		; input from keyboard
.0f96	a9 5f		lda #$5f			lda 	#((ReadBufferSize) & $FF)
.0f98	85 2c		sta $2c				sta 	0+zTemp0
.0f9a	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f9c	85 2d		sta $2d				sta 	1+zTemp0
.0f9e	20 64 19	jsr $1964			jsr 	ValEvaluateZTemp0
.0fa1	b0 f0		bcs $0f93			bcs 	_INError 					; failed, try again.
.0fa3	7a		ply				ply 								; restore Y
.0fa4	4c 71 08	jmp $0871			jmp 	NextCommand
.0fa7					CommandInputString:
.0fa7	fa		plx				plx
.0fa8	5a		phy				phy 								; save Y
.0fa9	20 c7 0f	jsr $0fc7			jsr 	InputStringToBuffer 		; input from keyboard
.0fac	e8		inx				inx 								; make space on stack
.0fad	20 5a 26	jsr $265a			jsr 	FloatSetZero 				; store as string on stack
.0fb0	a9 5f		lda #$5f			lda 	#ReadBufferSize & $FF
.0fb2	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0fb4	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0fb6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0fb8	a9 40		lda #$40			lda 	#NSSString
.0fba	95 32		sta $32,x			sta 	NSStatus,x
.0fbc	7a		ply				ply 								; restore Y
.0fbd	4c 71 08	jmp $0871			jmp 	NextCommand
.0fc0					CommandInputReset:
.0fc0	fa		plx				plx
.0fc1	9c 0a 04	stz $040a			stz 	InputBuffer
.0fc4	4c 71 08	jmp $0871			jmp 	NextCommand
.0fc7					InputStringToBuffer:
.0fc7	a9 01		lda #$01			lda 	#((InputBumpNext) & $FF)
.0fc9	8d 5f 05	sta $055f			sta 	0+ReadBumpNextVec
.0fcc	a9 10		lda #$10			lda 	#((InputBumpNext) >> 8) & $FF
.0fce	8d 60 05	sta $0560			sta 	1+ReadBumpNextVec
.0fd1	a9 de		lda #$de			lda 	#((InputLookNext) & $FF)
.0fd3	8d 61 05	sta $0561			sta 	0+ReadLookNextVec
.0fd6	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0fd8	8d 62 05	sta $0562			sta 	1+ReadLookNextVec
.0fdb	4c 59 14	jmp $1459			jmp 	GetStringToBuffer
.0fde					InputLookNext:
.0fde	da		phx				phx
.0fdf					_ILNRetry:
.0fdf	ad 0a 04	lda $040a			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fe2	d0 08		bne $0fec			bne 	_ILNNotEmpty
.0fe4	20 05 10	jsr $1005			jsr 	InputGetNewLine 			; get a new line
.0fe7	9c 5b 04	stz $045b			stz 	InputBufferPos 				; reset read position.
.0fea	80 f3		bra $0fdf			bra 	_ILNRetry
.0fec					_ILNNotEmpty:
.0fec	ae 5b 04	ldx $045b			ldx 	InputBufferPos 				; get head available character
.0fef	bd 0a 04	lda $040a,x			lda 	InputBuffer,x
.0ff2	d0 08		bne $0ffc			bne 	_ILNExit 					; if not EOS return it with CC.
.0ff4					_ILNNextLine:
.0ff4	9c 0a 04	stz $040a			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0ff7	38		sec				sec 								; return CS,Zero
.0ff8	fa		plx				plx
.0ff9	a9 0d		lda #$0d			lda 	#13
.0ffb	60		rts				rts
.0ffc					_ILNExit:
.0ffc	fa		plx				plx
.0ffd	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0fff	18		clc				clc
.1000	60		rts				rts
.1001					InputBumpNext:
.1001	ee 5b 04	inc $045b			inc 	InputBufferPos
.1004	60		rts				rts
.1005					InputGetNewLine:
.1005	48		pha				pha
.1006	da		phx				phx
.1007	5a		phy				phy
.1008	a9 3f		lda #$3f			lda 	#"?"
.100a	20 44 10	jsr $1044			jsr 	IGNLEchoIfScreen
.100d	a0 00		ldy #$00			ldy 	#0 							; line position.
.100f					_IGNLLoop:
.100f	20 83 13	jsr $1383			jsr 	VectorGetCharacter 			; get a character
.1012	c9 00		cmp #$00			cmp 	#0
.1014	f0 f9		beq $100f			beq 	_IGNLLoop
.1016	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.1018	f0 11		beq $102b			beq 	_IGNBackspace
.101a	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.101c	f0 17		beq $1035			beq 	_IGNExit
.101e	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.1020	f0 ed		beq $100f			beq 	_IGNLLoop
.1022	99 0a 04	sta $040a,y			sta 	InputBuffer,y
.1025	c8		iny				iny
.1026	20 44 10	jsr $1044			jsr 	IGNLEchoIfScreen
.1029	80 e4		bra $100f			bra 	_IGNLLoop
.102b					_IGNBackspace:
.102b	c0 00		cpy #$00			cpy 	#0
.102d	f0 e0		beq $100f			beq 	_IGNLLoop
.102f	20 44 10	jsr $1044			jsr 	IGNLEchoIfScreen
.1032	88		dey				dey
.1033	80 da		bra $100f			bra 	_IGNLLoop
.1035					_IGNExit:
.1035	20 44 10	jsr $1044			jsr 	IGNLEchoIfScreen
.1038	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.103a	99 0a 04	sta $040a,y			sta 	InputBuffer,y
.103d	9c 5b 04	stz $045b			stz 	InputBufferPos 				; reset position to start of input buffer.
.1040	7a		ply				ply
.1041	fa		plx				plx
.1042	68		pla				pla
.1043	60		rts				rts
.1044					IGNLEchoIfScreen:
.1044	ae 5d 04	ldx $045d			ldx 	currentChannel
.1047	d0 03		bne $104c			bne 	_IGNLEExit
.1049	20 7a 13	jsr $137a			jsr 	VectorPrintCharacter
.104c					_IGNLEExit:
.104c	60		rts				rts
.040a					InputBuffer:
>040a							.fill 	81
.045b					InputBufferPos:
>045b							.fill 	1
.104d					GetInteger8Bit:
.104d	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.1050	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1052	60		rts				rts
.1053					GetInteger16Bit:
.1053	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.1056	34 32		bit $32,x			bit 	NSStatus,x
.1058	30 09		bmi $1063			bmi 	Negate16Bit
.105a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.105c	85 2c		sta $2c				sta 	zTemp0
.105e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1060	85 2d		sta $2d				sta 	zTemp0+1
.1062	60		rts				rts
.1063					Negate16Bit:
.1063	38		sec				sec
.1064	a9 00		lda #$00			lda 	#0
.1066	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1068	95 3e		sta $3e,x			sta 	NSMantissa0,x
.106a	85 2c		sta $2c				sta 	zTemp0
.106c	a9 00		lda #$00			lda 	#0
.106e	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1070	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1072	85 2d		sta $2d				sta 	zTemp0+1
.1074	60		rts				rts
.1075					UnaryJoy:
.1075	fa		plx				plx
.1076	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; port #
.1079	48		pha				pha 								; zero the result.
.107a	20 5a 26	jsr $265a			jsr 	FloatSetZero
.107d	68		pla				pla
.107e	5a		phy				phy
.107f	da		phx				phx
.1080	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1083	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1085	d0 10		bne $1097			bne 	_UJNoHardware
.1087	a8		tay				tay 								; move XA -> AY
.1088	8a		txa				txa
.1089	fa		plx				plx 								; we can update it now.
.108a	49 ff		eor #$ff			eor 	#$FF
.108c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.108e	98		tya				tya
.108f	49 ff		eor #$ff			eor 	#$FF
.1091	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1093	7a		ply				ply 								; restore Y
.1094	4c 71 08	jmp $0871			jmp 	NextCommand
.1097					_UJNoHardware:
.1097	fa		plx				plx
.1098	7a		ply				ply
.1099	a9 01		lda #$01			lda 	#1 							; set result to -1
.109b	20 5c 26	jsr $265c			jsr 	FloatSetByte
.109e	20 1c 26	jsr $261c			jsr 	FloatNegate
.10a1	4c 71 08	jmp $0871			jmp 	NextCommand
.10a4					UnaryLen:
.10a4	fa		plx				plx
.10a5	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.10a7	85 2c		sta $2c				sta 	zTemp0
.10a9	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.10ab	85 2d		sta $2d				sta 	zTemp0+1
.10ad	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.10af	20 5c 26	jsr $265c			jsr 	FloatSetByte
.10b2	4c 71 08	jmp $0871			jmp 	NextCommand
.10b5					LinkFloatAdd:
.10b5	fa		plx				plx
.10b6	5a		phy			phy
.10b7	20 7e 20	jsr $207e		jsr	FloatAdd
.10ba	7a		ply			ply
.10bb	4c 71 08	jmp $0871			jmp 	NextCommand
.10be					LinkFloatSubtract:
.10be	fa		plx				plx
.10bf	5a		phy			phy
.10c0	20 78 20	jsr $2078		jsr	FloatSubtract
.10c3	7a		ply			ply
.10c4	4c 71 08	jmp $0871			jmp 	NextCommand
.10c7					LinkFloatMultiply:
.10c7	fa		plx				plx
.10c8	5a		phy			phy
.10c9	20 1a 23	jsr $231a		jsr	FloatMultiply
.10cc	7a		ply			ply
.10cd	4c 71 08	jmp $0871			jmp 	NextCommand
.10d0					LinkFloatDivide:
.10d0	fa		plx				plx
.10d1	5a		phy			phy
.10d2	20 a3 21	jsr $21a3		jsr	FloatDivide
.10d5	b0 5c		bcs $1133		bcs	DivZeroError
.10d7	7a		ply			ply
.10d8	4c 71 08	jmp $0871			jmp 	NextCommand
.10db					LinkFloatPower:
.10db	fa		plx				plx
.10dc	5a		phy			phy
.10dd	20 23 29	jsr $2923		jsr	FloatPower
.10e0	b0 4e		bcs $1130		bcs	MapRangeError
.10e2	7a		ply			ply
.10e3	4c 71 08	jmp $0871			jmp 	NextCommand
.10e6					LinkCompareGreater:
.10e6	fa		plx				plx
.10e7	5a		phy			phy
.10e8	20 27 21	jsr $2127		jsr	CompareGreater
.10eb	7a		ply			ply
.10ec	4c 71 08	jmp $0871			jmp 	NextCommand
.10ef					LinkCompareEqual:
.10ef	fa		plx				plx
.10f0	5a		phy			phy
.10f1	20 09 21	jsr $2109		jsr	CompareEqual
.10f4	7a		ply			ply
.10f5	4c 71 08	jmp $0871			jmp 	NextCommand
.10f8					LinkCompareLess:
.10f8	fa		plx				plx
.10f9	5a		phy			phy
.10fa	20 1f 21	jsr $211f		jsr	CompareLess
.10fd	7a		ply			ply
.10fe	4c 71 08	jmp $0871			jmp 	NextCommand
.1101					LinkCompareGreaterEqual:
.1101	fa		plx				plx
.1102	5a		phy			phy
.1103	20 37 21	jsr $2137		jsr	CompareGreaterEqual
.1106	7a		ply			ply
.1107	4c 71 08	jmp $0871			jmp 	NextCommand
.110a					LinkCompareNotEqual:
.110a	fa		plx				plx
.110b	5a		phy			phy
.110c	20 19 21	jsr $2119		jsr	CompareNotEqual
.110f	7a		ply			ply
.1110	4c 71 08	jmp $0871			jmp 	NextCommand
.1113					LinkCompareLessEqual:
.1113	fa		plx				plx
.1114	5a		phy			phy
.1115	20 2f 21	jsr $212f		jsr	CompareLessEqual
.1118	7a		ply			ply
.1119	4c 71 08	jmp $0871			jmp 	NextCommand
.111c					LinkFloatIntegerPartDown:
.111c	fa		plx				plx
.111d	5a		phy			phy
.111e	20 b9 22	jsr $22b9		jsr	FloatIntegerPartDown
.1121	7a		ply			ply
.1122	4c 71 08	jmp $0871			jmp 	NextCommand
.1125					LinkFloatSquareRoot:
.1125	fa		plx				plx
.1126	5a		phy			phy
.1127	20 a5 29	jsr $29a5		jsr	FloatSquareRoot
.112a	b0 04		bcs $1130		bcs	MapRangeError
.112c	7a		ply			ply
.112d	4c 71 08	jmp $0871			jmp 	NextCommand
.1130					MapRangeError:
.1130	4c f7 1e	jmp $1ef7		jmp	ErrorV_range
.1133					DivZeroError:
.1133	4c 80 1f	jmp $1f80		jmp	ErrorV_divzero
.1136					LinkFloatLogarithm:
.1136	fa		plx				plx
.1137	5a		phy			phy
.1138	20 af 28	jsr $28af		jsr	FloatLogarithm
.113b	b0 f3		bcs $1130		bcs	MapRangeError
.113d	7a		ply			ply
.113e	4c 71 08	jmp $0871			jmp 	NextCommand
.1141					LinkFloatExponent:
.1141	fa		plx				plx
.1142	5a		phy			phy
.1143	20 ac 27	jsr $27ac		jsr	FloatExponent
.1146	7a		ply			ply
.1147	4c 71 08	jmp $0871			jmp 	NextCommand
.114a					LinkFloatCosine:
.114a	fa		plx				plx
.114b	5a		phy			phy
.114c	20 a0 27	jsr $27a0		jsr	FloatCosine
.114f	7a		ply			ply
.1150	4c 71 08	jmp $0871			jmp 	NextCommand
.1153					LinkFloatSine:
.1153	fa		plx				plx
.1154	5a		phy			phy
.1155	20 40 29	jsr $2940		jsr	FloatSine
.1158	7a		ply			ply
.1159	4c 71 08	jmp $0871			jmp 	NextCommand
.115c					LinkFloatTangent:
.115c	fa		plx				plx
.115d	5a		phy			phy
.115e	20 b1 29	jsr $29b1		jsr	FloatTangent
.1161	7a		ply			ply
.1162	4c 71 08	jmp $0871			jmp 	NextCommand
.1165					LinkFloatArcTan:
.1165	fa		plx				plx
.1166	5a		phy			phy
.1167	20 85 26	jsr $2685		jsr	FloatArcTan
.116a	b0 c4		bcs $1130		bcs	MapRangeError
.116c	7a		ply			ply
.116d	4c 71 08	jmp $0871			jmp 	NextCommand
.1170					LinkFloatCompare:
.1170	fa		plx				plx
.1171	5a		phy			phy
.1172	20 3f 21	jsr $213f		jsr	FloatCompare
.1175	7a		ply			ply
.1176	4c 71 08	jmp $0871			jmp 	NextCommand
.1179					LinkDivideInt32:
.1179	fa		plx				plx
.117a	5a		phy			phy
.117b	20 cd 21	jsr $21cd		jsr	DivideInt32
.117e	b0 b0		bcs $1130		bcs	MapRangeError
.1180	7a		ply			ply
.1181	4c 71 08	jmp $0871			jmp 	NextCommand
.1184					StackSaveCurrentPosition:
.1184	20 dc 08	jsr $08dc			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.1187	5a		phy				phy
.1188	a0 02		ldy #$02			ldy 	#2
.118a	a5 28		lda $28				lda 	codePtr
.118c	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.118e	c8		iny				iny
.118f	a5 29		lda $29				lda 	codePtr+1
.1191	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1193	7a		ply				ply
.1194	60		rts				rts
.1195					StackLoadCurrentPosition:
.1195	a0 02		ldy #$02			ldy 	#2
.1197	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1199	85 28		sta $28				sta 	codePtr
.119b	c8		iny				iny
.119c	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.119e	85 29		sta $29				sta 	codePtr+1
.11a0	a0 00		ldy #$00			ldy 	#0
.11a2	60		rts				rts
.11a3					XCommandMouse:
.11a3	fa		plx				plx
.11a4	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; mouse control.
.11a7	ca		dex				dex
.11a8	da		phx				phx
.11a9	5a		phy				phy
.11aa	48		pha				pha
.11ab	38		sec				sec 								; get screen resolution
.11ac	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.11af	68		pla				pla
.11b0	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.11b3	7a		ply				ply
.11b4	fa		plx				plx
.11b5	4c 71 08	jmp $0871			jmp 	NextCommand
.11b8					XUnaryMB:
.11b8	fa		plx				plx
.11b9	20 e7 11	jsr $11e7			jsr 	XUnaryMouseCommon
.11bc	a5 30		lda $30				lda 	zTemp2
.11be	e8		inx				inx
.11bf	20 5c 26	jsr $265c			jsr 	FloatSetByte
.11c2	4c 71 08	jmp $0871			jmp 	NextCommand
.11c5					XUnaryMX:
.11c5	fa		plx				plx
.11c6	20 e7 11	jsr $11e7			jsr 	XUnaryMouseCommon
.11c9	a5 2c		lda $2c				lda 	zTemp0
.11cb	e8		inx				inx
.11cc	20 5c 26	jsr $265c			jsr 	FloatSetByte
.11cf	a5 2d		lda $2d				lda 	zTemp0+1
.11d1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11d3	4c 71 08	jmp $0871			jmp 	NextCommand
.11d6					XUnaryMY:
.11d6	fa		plx				plx
.11d7	20 e7 11	jsr $11e7			jsr 	XUnaryMouseCommon
.11da	a5 2e		lda $2e				lda 	zTemp1
.11dc	e8		inx				inx
.11dd	20 5c 26	jsr $265c			jsr 	FloatSetByte
.11e0	a5 2f		lda $2f				lda 	zTemp1+1
.11e2	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11e4	4c 71 08	jmp $0871			jmp 	NextCommand
.11e7					XUnaryMouseCommon:
.11e7	da		phx				phx
.11e8	5a		phy				phy
.11e9	a2 2c		ldx #$2c			ldx 	#zTemp0
.11eb	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.11ee	85 30		sta $30				sta 	zTemp2
.11f0	7a		ply				ply
.11f1	fa		plx				plx
.11f2	60		rts				rts
.11f3					NegateTOS:
.11f3	fa		plx				plx
.11f4	20 1c 26	jsr $261c			jsr 	FloatNegate
.11f7	4c 71 08	jmp $0871			jmp 	NextCommand
.11fa					CommandNewLine:
.11fa	fa		plx				plx
.11fb	9c 68 05	stz $0568			stz 	stringInitialised
.11fe	a2 ff		ldx #$ff			ldx 	#$FF
.1200	4c 71 08	jmp $0871			jmp 	NextCommand
.1203					CommandXNext:
.1203	fa		plx				plx
.1204					_CNRetry:
.1204	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.1206	20 69 0d	jsr $0d69			jsr 	StackFindFrame
.1209	20 dc 08	jsr $08dc			jsr 	FixUpY 						; so we can use Y
.120c	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.120e	35 4a		and $4a,x			and 	NSMantissa1,x
.1210	c9 ff		cmp #$ff			cmp 	#$FF
.1212	f0 16		beq $122a			beq 	_CNNoIndexVariable
.1214	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1216	a0 05		ldy #$05			ldy 	#5
.1218	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.121a	d0 07		bne $1223			bne 	_CNNIndexFail
.121c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.121e	c8		iny				iny
.121f	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.1221	f0 07		beq $122a			beq 	_CNNoIndexVariable
.1223					_CNNIndexFail:
.1223	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.1225	20 5b 0d	jsr $0d5b			jsr 	StackCloseFrame 			; close this frame
.1228	80 da		bra $1204			bra 	_CNRetry
.122a					_CNNoIndexVariable:
.122a	ca		dex				dex
.122b	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.122d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.122f	29 40		and #$40			and 	#$40	 					; bit 6
.1231	d0 55		bne $1288			bne 	_CNOptimisedNext
.1233	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1235	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1237	48		pha				pha
.1238	85 2c		sta $2c				sta 	zTemp0
.123a	c8		iny				iny
.123b	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.123d	18		clc				clc
.123e	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1241	48		pha				pha
.1242	85 2d		sta $2d				sta 	zTemp0+1
.1244	20 fc 14	jsr $14fc			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.1247	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.1249	e8		inx				inx
.124a	20 cb 12	jsr $12cb			jsr 	CopyOffsetYToTOS
.124d	20 7e 20	jsr $207e			jsr 	FloatAdd
.1250	68		pla				pla 								; restore address
.1251	85 2d		sta $2d				sta 	zTemp0+1
.1253	68		pla				pla
.1254	85 2c		sta $2c				sta 	zTemp0
.1256	20 d7 1a	jsr $1ad7			jsr 	WriteFloatZTemp0Sub			; write float.
.1259	e8		inx				inx  								; recover written
.125a	e8		inx				inx 								; load offset
.125b	a0 0d		ldy #$0d			ldy 	#13
.125d	20 cb 12	jsr $12cb			jsr 	CopyOffsetYToTOS
.1260	20 3f 21	jsr $213f			jsr 	FloatCompare 				; and compare the floats.
.1263	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1264	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.1266	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1268	30 08		bmi $1272			bmi 	_CNDownStep
.126a	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.126c	c9 01		cmp #$01			cmp 	#1 							; gone higher
.126e	f0 10		beq $1280			beq 	_CNExitFor 					; if so exit the loop
.1270	80 06		bra $1278			bra 	_CNLoopBack
.1272					_CNDownStep:
.1272	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1274	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.1276	f0 08		beq $1280			beq 	_CNExitFor
.1278					_CNLoopBack:
.1278	20 95 11	jsr $1195			jsr 	StackLoadCurrentPosition 	; loop back
.127b	a0 00		ldy #$00			ldy 	#0
.127d	4c 71 08	jmp $0871			jmp 	NextCommand
.1280					_CNExitFor:
.1280	20 5b 0d	jsr $0d5b			jsr 	StackCloseFrame 			; remove the frame and exit
.1283	a0 00		ldy #$00			ldy 	#0
.1285	4c 71 08	jmp $0871			jmp 	NextCommand
.1288					_CNOptimisedNext:
.1288	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.128a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.128c	85 2c		sta $2c				sta 	zTemp0
.128e	c8		iny				iny
.128f	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1291	18		clc				clc
.1292	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1295	85 2d		sta $2d				sta 	zTemp0+1
.1297	a0 07		ldy #$07			ldy 	#7 							; STEP value
.1299	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.129b	a0 ff		ldy #$ff			ldy 	#$FF
.129d	18		clc				clc
.129e					_CNOIncrement:
.129e	c8		iny				iny
.129f	71 2c		adc ($2c),y			adc 	(zTemp0),y
.12a1	91 2c		sta ($2c),y			sta 	(zTemp0),y
.12a3	f0 f9		beq $129e			beq 	_CNOIncrement
.12a5	18		clc				clc
.12a6	a5 24		lda $24				lda 	runtimeStackPtr
.12a8	69 0d		adc #$0d			adc 	#13
.12aa	85 2e		sta $2e				sta 	zTemp1
.12ac	a5 25		lda $25				lda 	runtimeStackPtr+1
.12ae	69 00		adc #$00			adc 	#0
.12b0	85 2f		sta $2f				sta 	zTemp1+1
.12b2	a0 00		ldy #$00			ldy 	#0
.12b4	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.12b6	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.12b8	c8		iny				iny
.12b9	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.12bb	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12bd	c8		iny				iny
.12be	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.12c0	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12c2	c8		iny				iny
.12c3	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.12c5	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12c7	90 b7		bcc $1280			bcc	 	_CNExitFor
.12c9	80 ad		bra $1278			bra 	_CNLoopBack
.12cb					CopyOffsetYToTOS:
.12cb	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12cd	95 3e		sta $3e,x			sta 	NSMantissa0,x
.12cf	c8		iny				iny
.12d0	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d2	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12d4	c8		iny				iny
.12d5	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d7	95 56		sta $56,x			sta 	NSMantissa2,x
.12d9	c8		iny				iny
.12da	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12dc	95 62		sta $62,x			sta 	NSMantissa3,x
.12de	c8		iny				iny
.12df	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12e1	95 6e		sta $6e,x			sta 	NSExponent,x
.12e3	c8		iny				iny
.12e4	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12e6	95 32		sta $32,x			sta 	NSStatus,x
.12e8	60		rts				rts
.12e9	4c 71 08	jmp $0871			jmp 	NextCommand
.12ec					NotTOS:
.12ec	fa		plx				plx
.12ed	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.12f0	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.12f2	74 62		stz $62,x			stz 	NSMantissa3,x
.12f4	20 1c 26	jsr $261c			jsr 	FloatNegate		 			; negate
.12f7	e8		inx				inx 								; and subtract 1.
.12f8	a9 01		lda #$01			lda 	#1
.12fa	20 5c 26	jsr $265c			jsr 	FloatSetByte
.12fd	20 78 20	jsr $2078			jsr 	FloatSubtract
.1300					_NotTOSSkip:
.1300	4c 71 08	jmp $0871			jmp 	NextCommand
.1303					CommandXOn:
.1303	fa		plx				plx
.1304	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.1307	8d 5c 04	sta $045c			sta 	onCount 					; save it.
.130a	20 dc 08	jsr $08dc			jsr 	FixUpY 						; Y = 0
.130d					_CONFind:
.130d	ce 5c 04	dec $045c			dec 	onCount 					; reached zero, do this one
.1310	f0 0b		beq $131d			beq 	_CONFound
.1312	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1313	c8		iny				iny
.1314	c8		iny				iny
.1315	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.1317	c8		iny				iny
.1318	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.131a	f0 f1		beq $130d			beq 	_CONFind
.131c	88		dey				dey 								; point to character after last GOTO/GOSUB
.131d					_CONFound:
.131d	4c 71 08	jmp $0871			jmp 	NextCommand
.1320					CommandMoreOn:
.1320	fa		plx				plx
.1321	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1322	c8		iny				iny
.1323	c8		iny				iny
.1324	4c 71 08	jmp $0871			jmp 	NextCommand
.045c					onCount:
>045c							.fill 	1
.1327					UnaryPeek:
.1327	fa		plx				plx
.1328	20 53 10	jsr $1053			jsr 	GetInteger16Bit
.132b	da		phx				phx
.132c	5a		phy				phy
.132d	a6 2c		ldx $2c				ldx 	zTemp0
.132f	a4 2d		ldy $2d				ldy 	zTemp0+1
.1331	20 68 1c	jsr $1c68			jsr 	XPeekMemory
.1334	7a		ply				ply
.1335	fa		plx				plx
.1336	20 5c 26	jsr $265c			jsr 	FloatSetByte
.1339	4c 71 08	jmp $0871			jmp 	NextCommand
.133c					CommandPOKE:
.133c	fa		plx				plx
.133d	da		phx				phx 								; save XY
.133e	5a		phy				phy
.133f	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1342	48		pha				pha
.1343	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1345	a8		tay				tay
.1346	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1348	aa		tax				tax
.1349	68		pla				pla
.134a	20 54 1c	jsr $1c54			jsr 	XPokeMemory
.134d	7a		ply				ply 								; restore YX and drop 2
.134e	fa		plx				plx
.134f	ca		dex				dex
.1350	ca		dex				dex
.1351	4c 71 08	jmp $0871			jmp 	NextCommand
.1354					UnaryPos:
.1354	fa		plx				plx
.1355	20 e7 1b	jsr $1be7			jsr 	XGetHPos
.1358	20 5c 26	jsr $265c			jsr 	FloatSetByte
.135b	4c 71 08	jmp $0871			jmp 	NextCommand
.135e					GetChannel:
.135e	fa		plx				plx
.135f	ad 5d 04	lda $045d			lda 	currentChannel
.1362	e8		inx				inx
.1363	20 5c 26	jsr $265c			jsr 	FloatSetByte
.1366	4c 71 08	jmp $0871			jmp 	NextCommand
.1369					SetChannel:
.1369	fa		plx				plx
.136a	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.136d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.136f	8d 5d 04	sta $045d			sta 	currentChannel
.1372	ca		dex				dex
.1373	4c 71 08	jmp $0871			jmp 	NextCommand
.1376					SetDefaultChannel:
.1376	9c 5d 04	stz $045d			stz 	currentChannel
.1379	60		rts				rts
.137a					VectorPrintCharacter:
.137a	da		phx				phx
.137b	ae 5d 04	ldx $045d			ldx 	currentChannel
.137e	20 92 1c	jsr $1c92			jsr 	XPrintCharacterToChannel
.1381	fa		plx				plx
.1382	60		rts				rts
.1383					VectorGetCharacter:
.1383	da		phx				phx
.1384	ae 5d 04	ldx $045d			ldx 	currentChannel
.1387	20 cb 1b	jsr $1bcb			jsr 	XGetCharacterFromChannel
.138a	fa		plx				plx
.138b	60		rts				rts
.045d					currentChannel:
>045d							.fill 	1
.138c					PrintNumber:
.138c	fa		plx				plx
.138d	a9 07		lda #$07			lda 	#7
.138f	20 42 25	jsr $2542			jsr 	FloatToString 				; to number in decimal buffer
.1392	ca		dex				dex 								; drop
.1393	da		phx				phx
.1394	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1396					_PNLoop:
.1396	bd 96 05	lda $0596,x			lda 	decimalBuffer,x
.1399	20 7a 13	jsr $137a			jsr 	VectorPrintCharacter
.139c	e8		inx				inx
.139d	bd 96 05	lda $0596,x			lda	 	decimalBuffer,x
.13a0	d0 f4		bne $1396			bne 	_PNLoop
.13a2	a9 20		lda #$20			lda 	#32 						; trailing space
.13a4	20 7a 13	jsr $137a			jsr 	VectorPrintCharacter
.13a7	fa		plx				plx
.13a8	4c 71 08	jmp $0871			jmp 	NextCommand
.13ab					PrintString:
.13ab	fa		plx				plx
.13ac	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.13ae	85 2c		sta $2c				sta 	zTemp0
.13b0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.13b2	85 2d		sta $2d				sta 	zTemp0+1
.13b4	ca		dex				dex 								; drop
.13b5	da		phx				phx
.13b6	5a		phy				phy
.13b7	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.13b9	aa		tax				tax
.13ba	a0 01		ldy #$01			ldy 	#1 							; Y = position
.13bc					_PSLoop:
.13bc	e0 00		cpx #$00			cpx 	#0 							; complete ?
.13be	f0 09		beq $13c9			beq 	_PSExit
.13c0	ca		dex				dex 								; dec count
.13c1	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.13c3	20 7a 13	jsr $137a			jsr 	VectorPrintCharacter
.13c6	c8		iny				iny
.13c7	80 f3		bra $13bc			bra 	_PSLoop
.13c9					_PSExit:
.13c9	7a		ply				ply
.13ca	fa		plx				plx
.13cb	4c 71 08	jmp $0871			jmp 	NextCommand
.13ce					CommandPushN:
.13ce	fa		plx				plx
.13cf	e8		inx				inx 								; next slot on stack
.13d0	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.13d2	95 6e		sta $6e,x			sta 	NSExponent,x
.13d4	c8		iny				iny
.13d5	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.13d7	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13d9	c8		iny				iny
.13da	b1 28		lda ($28),y			lda 	(codePtr),y
.13dc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13de	c8		iny				iny
.13df	b1 28		lda ($28),y			lda 	(codePtr),y
.13e1	95 56		sta $56,x			sta 	NSMantissa2,x
.13e3	c8		iny				iny
.13e4	b1 28		lda ($28),y			lda 	(codePtr),y
.13e6	48		pha				pha
.13e7	29 7f		and #$7f			and 	#$7F
.13e9	95 62		sta $62,x			sta 	NSMantissa3,x
.13eb	68		pla				pla 								; sign in mantissa3:7
.13ec	29 80		and #$80			and 	#$80
.13ee	95 32		sta $32,x			sta 	NSStatus,x
.13f0	c8		iny				iny
.13f1	4c 71 08	jmp $0871			jmp 	NextCommand
.13f4					CommandPushS:
.13f4	fa		plx				plx
.13f5	e8		inx				inx 								; next slot on stack
.13f6	18		clc				clc
.13f7	98		tya				tya
.13f8	65 28		adc $28				adc 	codePtr 					; the string is inline
.13fa	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13fc	a5 29		lda $29				lda 	codePtr+1
.13fe	69 00		adc #$00			adc 	#0
.1400	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1402	74 56		stz $56,x			stz 	NSMantissa2,x
.1404	74 62		stz $62,x			stz 	NSMantissa3,x
.1406	a9 40		lda #$40			lda 	#NSSString
.1408	95 32		sta $32,x			sta 	NSStatus,x
.140a	98		tya				tya 								; string length +1 added to Y
.140b	38		sec				sec
.140c	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.140e	a8		tay				tay
.140f	4c 71 08	jmp $0871			jmp 	NextCommand
.1412					CommandXRead:
.1412	fa		plx				plx
.1413	5a		phy				phy 								; save Y
.1414	20 45 14	jsr $1445			jsr 	ReadStringToBuffer 			; read element into buffer
.1417	e8		inx				inx									; space on stack
.1418	a9 5f		lda #$5f			lda 	#((ReadBufferSize) & $FF)
.141a	85 2c		sta $2c				sta 	0+zTemp0
.141c	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.141e	85 2d		sta $2d				sta 	1+zTemp0
.1420	20 64 19	jsr $1964			jsr 	ValEvaluateZTemp0
.1423	b0 04		bcs $1429			bcs 	_CRError 					; failed
.1425	7a		ply				ply 								; restore Y
.1426	4c 71 08	jmp $0871			jmp 	NextCommand
.1429					_CRError:
.1429	4c 07 1f	jmp $1f07		jmp	ErrorV_value
.142c					CommandReadString:
.142c	fa		plx				plx
.142d	5a		phy				phy 								; save Y
.142e	20 45 14	jsr $1445			jsr 	ReadStringToBuffer 			; read text
.1431	e8		inx				inx 								; make space on stack
.1432	20 5a 26	jsr $265a			jsr 	FloatSetZero 				; store as string on stack
.1435	a9 5f		lda #$5f			lda 	#ReadBufferSize & $FF
.1437	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1439	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.143b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.143d	a9 40		lda #$40			lda 	#NSSString
.143f	95 32		sta $32,x			sta 	NSStatus,x
.1441	7a		ply				ply 								; restore Y
.1442	4c 71 08	jmp $0871			jmp 	NextCommand
.1445					ReadStringToBuffer:
.1445	a9 d8		lda #$d8			lda 	#((ReadBumpNext) & $FF)
.1447	8d 5f 05	sta $055f			sta 	0+ReadBumpNextVec
.144a	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.144c	8d 60 05	sta $0560			sta 	1+ReadBumpNextVec
.144f	a9 ab		lda #$ab			lda 	#((ReadLookNext) & $FF)
.1451	8d 61 05	sta $0561			sta 	0+ReadLookNextVec
.1454	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.1456	8d 62 05	sta $0562			sta 	1+ReadLookNextVec
.1459					GetStringToBuffer:
.1459	20 a8 14	jsr $14a8			jsr		GetLookNext 				; skip all leading spaces.
.145c	f0 44		beq $14a2			beq 	_RBError 					; end of data
.145e	b0 f9		bcs $1459			bcs 	GetStringToBuffer 			; switched to new data line.
.1460	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1462	b0 05		bcs $1469			bcs 	_RBNoSpace
.1464	20 a5 14	jsr $14a5			jsr 	GetBumpNext 				; consume space and loop round.
.1467	80 f0		bra $1459			bra 	GetStringToBuffer
.1469					_RBNoSpace:
.1469	9c 5f 04	stz $045f			stz 	ReadBufferSize 				; empty the buffer.
.146c	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.146e	d0 08		bne $1478			bne 	_RBCommaSep
.1470	8d 5e 04	sta $045e			sta 	ReadSep 					; use as a seperator
.1473	20 a5 14	jsr $14a5			jsr 	GetBumpNext 				; consume the '"'
.1476	80 05		bra $147d			bra 	_RBGetText
.1478					_RBCommaSep:
.1478	a9 2c		lda #$2c			lda 	#","						; get till comma
.147a	8d 5e 04	sta $045e			sta 	ReadSep
.147d					_RBGetText:
.147d	20 a8 14	jsr $14a8			jsr 	GetLookNext 				; what follows
.1480	b0 18		bcs $149a			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.1482	20 a5 14	jsr $14a5			jsr 	GetBumpNext 				; consume it whatever
.1485	cd 5e 04	cmp $045e			cmp 	ReadSep 					; if found the seperator.
.1488	f0 10		beq $149a			beq 	_RBEndGet 					; exit after consumption
.148a	da		phx				phx
.148b	ae 5f 04	ldx $045f			ldx 	ReadBufferSize 				; copy into buffer.
.148e	ee 5f 04	inc $045f			inc 	ReadBufferSize
.1491	9d 60 04	sta $0460,x			sta 	ReadBuffer,x
.1494	9e 61 04	stz $0461,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.1497	fa		plx				plx
.1498	80 e3		bra $147d			bra 	_RBGetText
.149a					_RBEndGet:
.149a	c9 22		cmp #$22			cmp 	#'"'
.149c	d0 03		bne $14a1			bne 	_RBNotQuote
.149e	20 a5 14	jsr $14a5			jsr 	GetBumpNext
.14a1					_RBNotQuote:
.14a1	60		rts				rts
.14a2					_RBError:
.14a2	4c bc 1f	jmp $1fbc		jmp	ErrorV_data
.14a5					GetBumpNext:
.14a5	6c 5f 05	jmp ($055f)			jmp 	(ReadBumpNextVec)
.14a8					GetLookNext:
.14a8	6c 61 05	jmp ($0561)			jmp 	(ReadLookNextVec)
.14ab					ReadLookNext:
.14ab	ad 63 05	lda $0563			lda 	dataRemaining 				; any data remaining
.14ae	f0 04		beq $14b4			beq 	_RLNFindData
.14b0	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.14b2	18		clc				clc
.14b3	60		rts				rts
.14b4					_RLNFindData:
.14b4	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.14b6	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.14b8	f0 1a		beq $14d4			beq 	_RLNNoData
.14ba	c9 cf		cmp #$cf			cmp 	#PCD_CMD_DATA 				; Found DATA
.14bc	f0 05		beq $14c3			beq 	_RLNHaveData
.14be					_RLNNext:
.14be	20 29 20	jsr $2029			jsr 	MoveObjectForward			; else scan forward.
.14c1	80 f1		bra $14b4			bra 	_RLNFindData
.14c3					_RLNHaveData:
.14c3	a0 01		ldy #$01			ldy 	#1 							; get length
.14c5	b1 2a		lda ($2a),y			lda 	(objPtr),y
.14c7	f0 f5		beq $14be			beq 	_RLNNext 					; skip if DATA alone
.14c9	20 d8 14	jsr $14d8			jsr 	ReadBumpNext 				; advance by two
.14cc	20 d8 14	jsr $14d8			jsr 	ReadBumpNext
.14cf	8d 63 05	sta $0563			sta 	dataRemaining 				; set data left count.
.14d2	38		sec				sec
.14d3	60		rts				rts
.14d4					_RLNNoData:
.14d4	a9 00		lda #$00			lda 	#0
.14d6	38		sec				sec
.14d7	60		rts				rts
.14d8					ReadBumpNext:
.14d8	e6 2a		inc $2a				inc 	objPtr
.14da	d0 02		bne $14de			bne 	_RBNSkip
.14dc	e6 2b		inc $2b				inc 	objPtr+1
.14de					_RBNSkip:
.14de	ce 63 05	dec $0563			dec 	dataRemaining
.14e1	60		rts				rts
.045e					ReadSep:
>045e							.fill 	1
.045f					ReadBufferSize:
>045f							.fill 	1
.0460					ReadBuffer:
>0460							.fill 	255
.055f					ReadBumpNextVec:
>055f							.fill 	2
.0561					ReadLookNextVec:
>0561							.fill 	2
.14e2					ReadFloatCommand:
.14e2	fa		plx				plx
.14e3	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14e5	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14e7	88		dey				dey 								; get the upper 3 bits
.14e8	b1 28		lda ($28),y			lda 	(codePtr),y
.14ea	29 07		and #$07			and 	#7
.14ec	c8		iny				iny
.14ed	c8		iny				iny
.14ee	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14f0	2a		rol a				rol 	a 							; carry will be clear.
.14f1	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14f4	85 2d		sta $2d				sta 	zTemp0+1
.14f6	20 fc 14	jsr $14fc			jsr 	ReadFloatZTemp0Sub
.14f9	4c 71 08	jmp $0871			jmp 	NextCommand
.14fc					ReadFloatZTemp0Sub:
.14fc	5a		phy				phy 								; start write
.14fd	a0 01		ldy #$01			ldy 	#1
.14ff	e8		inx				inx
.1500	b2 2c		lda ($2c)			lda 	(zTemp0)
.1502	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1504	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1506	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1508	c8		iny				iny
.1509	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.150b	95 56		sta $56,x			sta 	NSMantissa2,x
.150d	c8		iny				iny
.150e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1510	95 62		sta $62,x			sta 	NSMantissa3,x
.1512	c8		iny				iny
.1513	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1515	95 6e		sta $6e,x			sta 	NSExponent,x
.1517	c8		iny				iny
.1518	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.151a	95 32		sta $32,x			sta 	NSStatus,x
.151c	7a		ply				ply
.151d	60		rts				rts
.151e					ReadIntegerCommand:
.151e	fa		plx				plx
.151f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1521	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1523	88		dey				dey 								; get the upper 3 bits
.1524	b1 28		lda ($28),y			lda 	(codePtr),y
.1526	29 07		and #$07			and 	#7
.1528	c8		iny				iny
.1529	c8		iny				iny
.152a	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.152c	2a		rol a				rol 	a 							; carry will be clear.
.152d	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1530	85 2d		sta $2d				sta 	zTemp0+1
.1532	20 38 15	jsr $1538			jsr 	ReadIntegerZTemp0Sub
.1535	4c 71 08	jmp $0871			jmp 	NextCommand
.1538					ReadIntegerZTemp0Sub:
.1538	5a		phy				phy 								; start write
.1539	a0 01		ldy #$01			ldy 	#1
.153b	e8		inx				inx 								; prepare
.153c	74 56		stz $56,x			stz 	NSMantissa2,x
.153e	74 62		stz $62,x			stz 	NSMantissa3,x
.1540	74 6e		stz $6e,x			stz 	NSExponent,x
.1542	74 32		stz $32,x			stz 	NSStatus,x
.1544	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1546	30 08		bmi $1550			bmi 	_RIZNegative
.1548	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.154a	b2 2c		lda ($2c)			lda 	(zTemp0)
.154c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.154e	7a		ply				ply
.154f	60		rts				rts
.1550					_RIZNegative:
.1550	38		sec				sec 								; -ve read
.1551	a9 00		lda #$00			lda 	#0
.1553	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.1555	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1557	a9 00		lda #$00			lda 	#0
.1559	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.155b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.155d	a9 80		lda #$80			lda 	#$80
.155f	95 32		sta $32,x			sta 	NSStatus,x
.1561	7a		ply				ply
.1562	60		rts				rts
.1563					ReadStringCommand:
.1563	fa		plx				plx
.1564	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1566	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1568	88		dey				dey 								; get the upper 3 bits
.1569	b1 28		lda ($28),y			lda 	(codePtr),y
.156b	29 07		and #$07			and 	#7
.156d	c8		iny				iny
.156e	c8		iny				iny
.156f	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1571	2a		rol a				rol 	a 							; carry will be clear.
.1572	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1575	85 2d		sta $2d				sta 	zTemp0+1
.1577	20 7d 15	jsr $157d			jsr 	ReadStringZTemp0Sub
.157a	4c 71 08	jmp $0871			jmp 	NextCommand
.157d					ReadStringZTemp0Sub:
.157d	5a		phy				phy 								; start write
.157e	e8		inx				inx 								; prepare
.157f	74 56		stz $56,x			stz 	NSMantissa2,x
.1581	74 62		stz $62,x			stz 	NSMantissa3,x
.1583	74 6e		stz $6e,x			stz 	NSExponent,x
.1585	a9 40		lda #$40			lda 	#NSSString
.1587	74 32		stz $32,x			stz 	NSStatus,x
.1589	18		clc				clc
.158a	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.158c	69 02		adc #$02			adc 	#2 							; this points to actual data
.158e	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.1590	a0 01		ldy #$01			ldy 	#1
.1592	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1594	69 00		adc #$00			adc 	#0
.1596	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1598	d0 08		bne $15a2			bne 	_RSZNoDefault 				; if read $00 use a default value.
.159a	a9 a4		lda #$a4			lda 	#_RSZNull & $FF
.159c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.159e	a9 15		lda #$15			lda 	#_RSZNull >> 8
.15a0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15a2					_RSZNoDefault:
.15a2	7a		ply				ply
.15a3	60		rts				rts
.15a4					_RSZNull:
>15a4	00						.byte 	0
.15a5					CommandRestore:
.15a5	fa		plx				plx
.15a6	20 ac 15	jsr $15ac			jsr 	RestoreCode
.15a9	4c 71 08	jmp $0871			jmp 	NextCommand
.15ac					RestoreCode:
.15ac	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.15af	85 2b		sta $2b				sta 	objPtr+1
.15b1	64 2a		stz $2a				stz 	objPtr
.15b3	9c 63 05	stz $0563			stz 	dataRemaining 				; no data remaining.
.15b6	60		rts				rts
.0563					dataRemaining:
>0563							.fill 	1		 					; 0 if not in data statement
.15b7					UnaryRND:
.15b7	fa		plx				plx
.15b8	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.15ba	10 17		bpl $15d3			bpl 	_URNoSeed
.15bc	20 af 23	jsr $23af			jsr 	FloatNormalise 				; some float value
.15bf	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.15c1	8d 64 05	sta $0564			sta 	randomSeed+0
.15c4	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15c6	8d 65 05	sta $0565			sta 	randomSeed+1
.15c9	b5 56		lda $56,x			lda 	NSMantissa2,x
.15cb	8d 66 05	sta $0566			sta 	randomSeed+2
.15ce	b5 62		lda $62,x			lda 	NSMantissa3,x
.15d0	8d 67 05	sta $0567			sta 	randomSeed+3
.15d3					_URNoSeed:
.15d3	20 f5 15	jsr $15f5			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.15d6	ad 64 05	lda $0564			lda 	randomSeed+0
.15d9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15db	ad 65 05	lda $0565			lda 	randomSeed+1
.15de	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15e0	ad 66 05	lda $0566			lda 	randomSeed+2
.15e3	95 56		sta $56,x			sta 	NSMantissa2,x
.15e5	ad 67 05	lda $0567			lda 	randomSeed+3
.15e8	29 7f		and #$7f			and 	#$7F
.15ea	95 62		sta $62,x			sta 	NSMantissa3,x
.15ec	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.15ee	95 6e		sta $6e,x			sta 	NSExponent,x
.15f0	74 32		stz $32,x			stz 	NSStatus,x
.15f2	4c 71 08	jmp $0871			jmp 	NextCommand
.15f5					RandomNumberGenerator:
.15f5	5a		phy				phy
.15f6	ad 64 05	lda $0564			lda 	randomSeed+0 				; check if zero
.15f9	0d 65 05	ora $0565			ora 	randomSeed+1
.15fc	0d 66 05	ora $0566			ora 	randomSeed+2
.15ff	0d 67 05	ora $0567			ora 	randomSeed+3
.1602	d0 07		bne $160b			bne 	_RNGNoSeed
.1604	ce 67 05	dec $0567			dec 	randomSeed+3 				; if so tweak and flog
.1607	a0 64		ldy #$64			ldy 	#100
.1609	80 05		bra $1610			bra 	_RNGLoop
.160b					_RNGNoSeed:
.160b	a0 08		ldy #$08			ldy 	#8
.160d	ad 64 05	lda $0564			lda 	randomSeed+0
.1610					_RNGLoop:
.1610	0a		asl a				asl		a
.1611	2e 65 05	rol $0565			rol 	randomSeed+1
.1614	2e 66 05	rol $0566			rol 	randomSeed+2
.1617	2e 67 05	rol $0567			rol 	randomSeed+3
.161a	90 02		bcc $161e			bcc		_RNGSkip
.161c	49 c5		eor #$c5			eor 	#$C5
.161e					_RNGSkip:
.161e	88		dey				dey
.161f	d0 ef		bne $1610			bne		_RNGLoop
.1621	8d 64 05	sta $0564			sta 	randomSeed+0
.1624	7a		ply				ply
.1625	60		rts				rts
.0564					randomSeed:
>0564							.fill 	4
.1626					StringConcatenate:
.1626	fa		plx				plx
.1627	ca		dex				dex
.1628	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.162a	85 2e		sta $2e				sta 	zTemp1
.162c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.162e	85 2f		sta $2f				sta 	zTemp1+1
.1630	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.1632	85 30		sta $30				sta 	zTemp2
.1634	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.1636	85 31		sta $31				sta 	zTemp2+1
.1638	18		clc				clc 								; work out total length
.1639	b2 2e		lda ($2e)			lda 	(zTemp1)
.163b	72 30		adc ($30)			adc 	(zTemp2)
.163d	b0 18		bcs $1657			bcs 	_BCLength 					; more than 255 characters.
.163f	48		pha				pha 								; save total
.1640	20 1d 17	jsr $171d			jsr 	StringAllocTemp 			; space for result.
.1643	68		pla				pla 								; write total as first.
.1644	92 22		sta ($22)			sta 	(zsTemp)
.1646	20 5a 16	jsr $165a			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.1649	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.164b	85 2e		sta $2e				sta 	zTemp1
.164d	a5 31		lda $31				lda 	zTemp2+1
.164f	85 2f		sta $2f				sta 	zTemp1+1
.1651	20 5a 16	jsr $165a			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1654	4c 71 08	jmp $0871			jmp 	NextCommand
.1657					_BCLength:
.1657	4c f7 1e	jmp $1ef7		jmp	ErrorV_range
.165a					_BCCopyZTemp1:
.165a	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.165c	f0 15		beq $1673			beq 	_BCCExit 					; none.
.165e	da		phx				phx 								; save XY
.165f	5a		phy				phy
.1660	aa		tax				tax 								; count in X.
.1661	a0 01		ldy #$01			ldy 	#1
.1663					_BCCLoop:
.1663	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1665	d0 02		bne $1669			bne 	_BCCNoCarry
.1667	e6 23		inc $23				inc 	zsTemp+1
.1669					_BCCNoCarry:
.1669	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.166b	92 22		sta ($22)			sta 	(zsTemp)
.166d	c8		iny				iny
.166e	ca		dex				dex 								; X times
.166f	d0 f2		bne $1663			bne 	_BCCLoop
.1671	7a		ply				ply 								; restore YX
.1672	fa		plx				plx
.1673					_BCCExit:
.1673	60		rts				rts
.1674					XRuntimeSetup:
.1674	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1676	8d 6b 05	sta $056b	 		sta 	ramBank
.1679	8d 6c 05	sta $056c	 		sta 	romBank
.167c	60		rts				rts
.167d					SignTOS:
.167d	fa		plx				plx
.167e	20 7c 26	jsr $267c			jsr 	FloatIsZero 				; if zero
.1681	f0 0f		beq $1692			beq 	_SGZero  					; return Int Zero
.1683	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.1685	48		pha				pha
.1686	a9 01		lda #$01			lda 	#1 							; set result to 1
.1688	20 5c 26	jsr $265c			jsr 	FloatSetByte
.168b	68		pla				pla
.168c	29 80		and #$80			and		#$80 						; copy the sign byte out
.168e	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.1690	80 03		bra $1695			bra 	_SGExit
.1692					_SGZero:
.1692	20 5a 26	jsr $265a			jsr 	FloatSetZero
.1695					_SGExit:
.1695	4c 71 08	jmp $0871			jmp 	NextCommand
.1698					CommandShift:
.1698	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.169a	c8		iny				iny
.169b	0a		asl a				asl 	a 							; double into X
.169c	aa		tax				tax
.169d	7c 48 1a	jmp ($1a48,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.16a0					PrintTab:
.16a0	fa		plx				plx
.16a1	20 e7 1b	jsr $1be7			jsr 	XGetHPos
.16a4					_PTMod10:
.16a4	38		sec				sec
.16a5	e9 0a		sbc #$0a			sbc 	#10
.16a7	b0 fb		bcs $16a4			bcs 	_PTMod10
.16a9	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.16ab	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.16ac	80 15		bra $16c3			bra 	PrintSpaceLoop
.16ae					PrintPos:
.16ae	fa		plx				plx
.16af	20 e7 1b	jsr $1be7			jsr		XGetHPos 					; get current position
.16b2	85 2c		sta $2c				sta 	zTemp0
.16b4	38		sec				sec 								; calculate spaces required
.16b5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16b7	ca		dex				dex
.16b8	e5 2c		sbc $2c				sbc 	zTemp0
.16ba	b0 07		bcs $16c3			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.16bc	4c 71 08	jmp $0871			jmp 	NextCommand
.16bf					PrintSpace:
.16bf	fa		plx				plx
.16c0	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16c2	ca		dex				dex
.16c3					PrintSpaceLoop:
.16c3	c9 00		cmp #$00			cmp 	#0
.16c5	f0 0a		beq $16d1			beq 	_PSExit
.16c7	48		pha				pha
.16c8	a9 20		lda #$20			lda 	#" "
.16ca	20 7a 13	jsr $137a			jsr 	VectorPrintCharacter
.16cd	68		pla				pla
.16ce	3a		dec a				dec 	a
.16cf	80 f2		bra $16c3			bra 	PrintSpaceLoop
.16d1					_PSExit:
.16d1	4c 71 08	jmp $0871			jmp 	NextCommand
.16d4					CommandStop:
.16d4	fa		plx				plx
.16d5	4c a9 1f	jmp $1fa9		jmp	ErrorV_stop
.16d8					Unary_Str:
.16d8	fa		plx				plx
.16d9	5a		phy				phy
.16da	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.16dc	20 42 25	jsr $2542			jsr 	FloatToString 				; do the conversion.
.16df	a9 21		lda #$21			lda		#33 						; create buffer
.16e1	20 1d 17	jsr $171d			jsr 	StringAllocTemp 			; allocate memory
.16e4	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.16e6					_USCopy:
.16e6	b9 95 05	lda $0595,y			lda 	decimalBuffer-1,y
.16e9	f0 05		beq $16f0			beq 	_USExit
.16eb	91 22		sta ($22),y			sta 	(zsTemp),y
.16ed	c8		iny				iny
.16ee	80 f6		bra $16e6			bra 	_USCopy
.16f0					_USExit:
.16f0	98		tya				tya
.16f1	3a		dec a				dec 	a
.16f2	92 22		sta ($22)			sta 	(zsTemp)
.16f4	7a		ply				ply
.16f5	4c 71 08	jmp $0871			jmp 	NextCommand
.16f8					StringInitialise:
.16f8	48		pha				pha
.16f9	ad 68 05	lda $0568			lda 	stringInitialised 			; already done
.16fc	d0 11		bne $170f			bne 	_SIExit
.16fe	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.1701	8d 69 05	sta $0569			sta 	stringTempPointer
.1704	ad 03 04	lda $0403			lda 	stringHighMemory+1
.1707	3a		dec a				dec 	a
.1708	3a		dec a				dec 	a
.1709	8d 6a 05	sta $056a			sta 	stringTempPointer+1
.170c	ce 68 05	dec $0568			dec 	stringInitialised 			; set the initialised flag.
.170f					_SIExit:
.170f	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.1711	1a		inc a				inc 	a
.1712	1a		inc a				inc 	a
.1713	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.1716	b0 02		bcs $171a			bcs 	_SIMemory
.1718	68		pla				pla
.1719	60		rts				rts
.171a					_SIMemory:
.171a	4c 02 20	jmp $2002		jmp	ErrorV_memory
.171d					StringAllocTemp:
.171d	20 f8 16	jsr $16f8			jsr 	StringInitialise 			; check it is initialised.
.1720	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.1722	18		clc				clc
.1723	6d 69 05	adc $0569			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.1726	8d 69 05	sta $0569			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.1729	85 22		sta $22				sta 	zsTemp
.172b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.172d	ad 6a 05	lda $056a			lda 	stringTempPointer+1
.1730	69 ff		adc #$ff			adc 	#$FF
.1732	8d 6a 05	sta $056a			sta 	stringTempPointer+1
.1735	85 23		sta $23				sta 	zsTemp+1
.1737	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1739	74 56		stz $56,x			stz 	NSMantissa2,x
.173b	74 62		stz $62,x			stz 	NSMantissa3,x
.173d	a9 00		lda #$00			lda 	#0 							; clear string.
.173f	92 22		sta ($22)			sta 	(zsTemp)
.1741	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1743	95 32		sta $32,x			sta 	NSStatus,x
.1745	60		rts				rts
.1746					StringWriteChar:
.1746	5a		phy				phy
.1747	48		pha				pha
.1748	b2 22		lda ($22)			lda 	(zsTemp)
.174a	1a		inc a				inc 	a
.174b	92 22		sta ($22)			sta 	(zsTemp)
.174d	a8		tay				tay
.174e	68		pla				pla
.174f	91 22		sta ($22),y			sta 	(zsTemp),y
.1751	7a		ply				ply
.1752	60		rts				rts
.0568					stringInitialised:
>0568							.fill 	1
.0569					stringTempPointer:
>0569							.fill 	2
.1753					Unary_Left:
.1753	fa		plx				plx
.1754	5a		phy				phy
.1755	18		clc				clc 								; only one parameter
.1756	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; push the length of the string.
.1759	48		pha				pha
.175a	ca		dex				dex
.175b	a9 00		lda #$00			lda 	#0 							; push the start position.
.175d	48		pha				pha
.175e	20 96 17	jsr $1796			jsr 	UnarySStringToZTemp0
.1761	80 3c		bra $179f			bra 	SubstringMain 				; stack now points to the string to slice.
.1763					Unary_Right:
.1763	fa		plx				plx
.1764	5a		phy				phy
.1765	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.1767	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; push the right length of the string.
.176a	48		pha				pha
.176b	ca		dex				dex
.176c	20 96 17	jsr $1796			jsr 	UnarySStringToZTemp0
.176f	68		pla				pla 								; this is the right requirement
.1770	38		sec				sec
.1771	49 ff		eor #$ff			eor 	#$FF
.1773	72 2c		adc ($2c)			adc 	(zTemp0)
.1775	b0 02		bcs $1779			bcs 	_URHaveCount
.1777	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.1779					_URHaveCount:
.1779	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.177b	5a		phy				phy
.177c	48		pha				pha 								; start position
.177d	80 20		bra $179f			bra 	SubstringMain
.177f					Unary_Mid:
.177f	fa		plx				plx
.1780	5a		phy				phy
.1781	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; push the length of the string required.
.1784	48		pha				pha
.1785	ca		dex				dex
.1786	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; put the start position.
.1789	f0 08		beq $1793			beq 	_UMError
.178b	3a		dec a				dec 	a
.178c	48		pha				pha
.178d	ca		dex				dex
.178e	20 96 17	jsr $1796			jsr 	UnarySStringToZTemp0
.1791	80 0c		bra $179f			bra 	SubstringMain 				; stack now points to the string to slice.
.1793					_UMError:
.1793	4c f7 1e	jmp $1ef7		jmp	ErrorV_range
.1796					UnarySStringToZTemp0:
.1796	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1798	85 2c		sta $2c				sta 	zTemp0
.179a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.179c	85 2d		sta $2d				sta 	zTemp0+1
.179e	60		rts				rts
.179f					SubstringMain:
.179f	68		pla				pla 								; get the start offset
.17a0	7a		ply				ply 								; get the count to do.
.17a1	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.17a3	b0 38		bcs $17dd			bcs 	_SSReturnNull
.17a5	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.17a7	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.17a9	18		clc				clc
.17aa	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.17ac	b0 06		bcs $17b4			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.17ae	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.17b0	f0 04		beq $17b6			beq 	_SMIsOkay
.17b2	90 02		bcc $17b6			bcc 	_SMIsOkay
.17b4					_SMTruncateToEnd:
.17b4	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.17b6					_SMIsOkay:
.17b6	85 2f		sta $2f				sta 	zTemp1+1
.17b8	38		sec				sec		 							; work out size
.17b9	a5 2f		lda $2f				lda 	zTemp1+1
.17bb	e5 2e		sbc $2e				sbc 	zTemp1
.17bd	f0 1e		beq $17dd			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.17bf	20 1d 17	jsr $171d			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.17c2	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.17c4					_SMCopy:
.17c4	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.17c6	f0 11		beq $17d9			beq 	_SMExit
.17c8	c8		iny				iny 								; bump and
.17c9	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.17cb	5a		phy				phy
.17cc	48		pha				pha
.17cd	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.17cf	1a		inc a				inc 	a
.17d0	a8		tay				tay
.17d1	92 22		sta ($22)			sta 	(zsTemp)
.17d3	68		pla				pla 								; write character out
.17d4	91 22		sta ($22),y			sta 	(zsTemp),y
.17d6	7a		ply				ply 								; restore Y
.17d7	80 eb		bra $17c4			bra 	_SMCopy
.17d9					_SMExit:
.17d9	7a		ply				ply
.17da	4c 71 08	jmp $0871			jmp 	NextCommand
.17dd					_SSReturnNull:
.17dd	a9 ef		lda #$ef			lda 	#SSRNull & $FF 				; set up mantissa
.17df	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17e1	a9 17		lda #$17			lda 	#SSRNull >> 8
.17e3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17e5	74 56		stz $56,x			stz 	NSMantissa2,x
.17e7	74 62		stz $62,x			stz 	NSMantissa3,x
.17e9	a9 40		lda #$40			lda 	#NSSString
.17eb	95 32		sta $32,x			sta 	NSStatus,x
.17ed	80 ea		bra $17d9			bra 	_SMExit
.17ef					SSRNull:
>17ef	00 00						.word 	0
.17f1					CommandSwap:
.17f1	fa		plx				plx
.17f2	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17f4	48		pha				pha
.17f5	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.17f7	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17f9	68		pla				pla
.17fa	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.17fc	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17fe	48		pha				pha
.17ff	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.1801	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1803	68		pla				pla
.1804	95 49		sta $49,x			sta 	NSMantissa1-1,x
.1806	b5 56		lda $56,x			lda 	NSMantissa2,x
.1808	48		pha				pha
.1809	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.180b	95 56		sta $56,x			sta 	NSMantissa2,x
.180d	68		pla				pla
.180e	95 55		sta $55,x			sta 	NSMantissa2-1,x
.1810	b5 62		lda $62,x			lda 	NSMantissa3,x
.1812	48		pha				pha
.1813	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.1815	95 62		sta $62,x			sta 	NSMantissa3,x
.1817	68		pla				pla
.1818	95 61		sta $61,x			sta 	NSMantissa3-1,x
.181a	b5 6e		lda $6e,x			lda 	NSExponent,x
.181c	48		pha				pha
.181d	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.181f	95 6e		sta $6e,x			sta 	NSExponent,x
.1821	68		pla				pla
.1822	95 6d		sta $6d,x			sta 	NSExponent-1,x
.1824	b5 32		lda $32,x			lda 	NSStatus,x
.1826	48		pha				pha
.1827	b5 31		lda $31,x			lda 	NSStatus-1,x
.1829	95 32		sta $32,x			sta 	NSStatus,x
.182b	68		pla				pla
.182c	95 31		sta $31,x			sta 	NSStatus-1,x
.182e	4c 71 08	jmp $0871			jmp 	NextCommand
.1831					CommandSYS:
.1831	fa		plx				plx
.1832	da		phx				phx 								; save XY
.1833	5a		phy				phy
.1834	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.1837	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.1839	85 2d		sta $2d				sta 	zTemp0+1
.183b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.183d	85 2c		sta $2c				sta 	zTemp0
.183f	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1842	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.1845	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.1848	48		pha				pha
.1849	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.184c	28		plp				plp
.184d	20 64 18	jsr $1864			jsr 	_CSZTemp0
.1850	08		php				php
.1851	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1854	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.1857	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.185a	68		pla				pla
.185b	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.185e	7a		ply				ply 								; restore YX and drop 2
.185f	fa		plx				plx
.1860	ca		dex				dex
.1861	4c 71 08	jmp $0871			jmp 	NextCommand
.1864					_CSZTemp0:
.1864	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.1867					TimeTOS:
.1867	fa		plx				plx
.1868	20 c2 18	jsr $18c2			jsr 	TIPushClock 				; push clock to TOS
.186b	4c 71 08	jmp $0871			jmp 	NextCommand
.186e					TimeString:
.186e	fa		plx				plx
.186f	20 c2 18	jsr $18c2			jsr 	TIPushClock 				; push clock to TOS
.1872	20 97 18	jsr $1897			jsr 	_TSDivMod60 				; result in seconds
.1875	20 97 18	jsr $1897			jsr 	_TSDivMod60 				; seconds
.1878	48		pha				pha
.1879	20 97 18	jsr $1897			jsr 	_TSDivMod60 				; minutes
.187c	48		pha				pha
.187d	a9 18		lda #$18			lda 	#24 						; hours
.187f	20 99 18	jsr $1899			jsr 	_TSDivModA
.1882	48		pha				pha
.1883	a9 06		lda #$06			lda 	#6
.1885	20 1d 17	jsr $171d			jsr 	StringAllocTemp
.1888	68		pla				pla
.1889	20 a9 18	jsr $18a9			jsr 	_TSWriteDecimal
.188c	68		pla				pla
.188d	20 a9 18	jsr $18a9			jsr 	_TSWriteDecimal
.1890	68		pla				pla
.1891	20 a9 18	jsr $18a9			jsr 	_TSWriteDecimal
.1894	4c 71 08	jmp $0871			jmp 	NextCommand
.1897					_TSDivMod60:
.1897	a9 3c		lda #$3c			lda 	#60
.1899					_TSDivModA:
.1899	e8		inx				inx
.189a	20 5c 26	jsr $265c			jsr 	FloatSetByte
.189d	ca		dex				dex
.189e	20 f0 21	jsr $21f0			jsr 	Int32Divide
.18a1	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.18a3	48		pha				pha
.18a4	20 df 21	jsr $21df			jsr 	NSMCopyPlusTwoToZero
.18a7	68		pla				pla
.18a8	60		rts				rts
.18a9					_TSWriteDecimal:
.18a9	da		phx				phx
.18aa	a2 30		ldx #$30			ldx 	#'0'
.18ac					_TSWDLoop:
.18ac	c9 0a		cmp #$0a			cmp 	#10
.18ae	90 05		bcc $18b5			bcc 	_TSWDEnd
.18b0	e9 0a		sbc #$0a			sbc 	#10
.18b2	e8		inx				inx
.18b3	80 f7		bra $18ac			bra 	_TSWDLoop
.18b5					_TSWDEnd:
.18b5	48		pha				pha
.18b6	8a		txa				txa
.18b7	20 46 17	jsr $1746			jsr 	StringWriteChar
.18ba	68		pla				pla
.18bb	09 30		ora #$30			ora 	#'0'
.18bd	20 46 17	jsr $1746			jsr 	StringWriteChar
.18c0	fa		plx				plx
.18c1	60		rts				rts
.18c2					TIPushClock:
.18c2	5a		phy				phy
.18c3	e8		inx				inx 								; push 0 on the stack
.18c4	20 5a 26	jsr $265a			jsr 	FloatSetZero
.18c7	da		phx				phx
.18c8	20 b2 1c	jsr $1cb2			jsr 	XReadClock 					; read time into YXA
.18cb	86 2c		stx $2c				stx 	zTemp0
.18cd	fa		plx				plx
.18ce	95 3e		sta $3e,x			sta 	NSMantissa0,x
.18d0	a5 2c		lda $2c				lda 	zTemp0
.18d2	95 4a		sta $4a,x			sta 	NSMantissa1,x
.18d4	98		tya				tya
.18d5	95 56		sta $56,x			sta 	NSMantissa2,x
.18d7	7a		ply				ply
.18d8	60		rts				rts
.18d9					CommandTIWrite:
.18d9	fa		plx				plx
.18da	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.18dc	85 22		sta $22				sta 	zsTemp
.18de	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.18e0	85 23		sta $23				sta 	zsTemp+1
.18e2	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.18e4	c9 06		cmp #$06			cmp 	#6
.18e6	d0 59		bne $1941			bne 	_CTIWError
.18e8	20 5a 26	jsr $265a			jsr 	FloatSetZero
.18eb	20 0d 19	jsr $190d			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.18ee	20 0d 19	jsr $190d			jsr 	_CTIWDigitPair
.18f1	20 0d 19	jsr $190d			jsr 	_CTIWDigitPair
.18f4	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.18f6	20 38 19	jsr $1938			jsr 	_CTIWMultiply
.18f9	da		phx				phx
.18fa	5a		phy				phy
.18fb	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.18fd	48		pha				pha
.18fe	b5 56		lda $56,x			lda 	NSMantissa2,x
.1900	a8		tay				tay
.1901	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1903	fa		plx				plx
.1904	20 b6 1c	jsr $1cb6			jsr 	XWriteClock 				; update the clock.
.1907	7a		ply				ply
.1908	fa		plx				plx
.1909	ca		dex				dex 								; throw result.
.190a	4c 71 08	jmp $0871			jmp 	NextCommand
.190d					_CTIWDigitPair:
.190d	a9 06		lda #$06			lda 	#6 							; x 6
.190f	20 38 19	jsr $1938			jsr 	_CTIWMultiply
.1912	20 1e 19	jsr $191e			jsr 	_CTIWAddDigit 				; add digit
.1915	a9 0a		lda #$0a			lda 	#10 						; x 10
.1917	20 38 19	jsr $1938			jsr 	_CTIWMultiply
.191a	20 1e 19	jsr $191e			jsr 	_CTIWAddDigit 				; add digit
.191d	60		rts				rts
.191e					_CTIWAddDigit:
.191e	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.1920	d0 02		bne $1924			bne 	_CTIWASkip
.1922	e6 23		inc $23				inc 	zsTemp+1
.1924					_CTIWASkip:
.1924	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.1926	38		sec				sec
.1927	e9 30		sbc #$30			sbc 	#"0"
.1929	90 16		bcc $1941			bcc 	_CTIWError
.192b	c9 0a		cmp #$0a			cmp 	#9+1
.192d	b0 12		bcs $1941			bcs 	_CTIWError
.192f	e8		inx				inx 								; store at +1
.1930	20 5c 26	jsr $265c			jsr 	FloatSetByte
.1933	ca		dex				dex
.1934	20 e6 23	jsr $23e6			jsr 	FloatAddTopTwoStack
.1937	60		rts				rts
.1938					_CTIWMultiply:
.1938	e8		inx				inx
.1939	20 5c 26	jsr $265c			jsr 	FloatSetByte
.193c	ca		dex				dex
.193d	20 67 23	jsr $2367			jsr 	FloatMultiplyShort
.1940	60		rts				rts
.1941					_CTIWError:
.1941	4c 07 1f	jmp $1f07		jmp	ErrorV_value
.1944					UnaryUsr:
.1944	fa		plx				plx
.1945	5a		phy				phy
.1946	20 4d 19	jsr $194d			jsr 	_UUCallVector
.1949	7a		ply				ply
.194a	4c 71 08	jmp $0871			jmp 	NextCommand
.194d					_UUCallVector:
.194d	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.1950					ValUnary:
.1950	fa		plx				plx
.1951	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1953	85 2c		sta $2c				sta 	zTemp0
.1955	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1957	85 2d		sta $2d				sta 	zTemp0+1
.1959	20 64 19	jsr $1964			jsr 	ValEvaluateZTemp0
.195c	b0 03		bcs $1961			bcs 	_VUError 					; couldn't convert
.195e	4c 71 08	jmp $0871			jmp 	NextCommand
.1961					_VUError:
.1961	4c 07 1f	jmp $1f07		jmp	ErrorV_value
.1964					ValEvaluateZTemp0:
.1964	5a		phy				phy
.1965	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.1967	f0 22		beq $198b			beq 	_VMCFail2
.1969	a0 00		ldy #$00			ldy 	#0 							; start position
.196b					_VMCSpaces:
.196b	c8		iny				iny 								; skip leading spaces
.196c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.196e	c9 20		cmp #$20			cmp 	#" "
.1970	f0 f9		beq $196b			beq 	_VMCSpaces
.1972	48		pha				pha 								; save first character
.1973	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.1975	d0 01		bne $1978			bne 	_VMCStart
.1977	c8		iny				iny 								; skip over - if so.
.1978					_VMCStart:
.1978	38		sec				sec 								; initialise first time round.
.1979					_VMCNext:
.1979	98		tya				tya 								; reached end of string
.197a	3a		dec a				dec 	a
.197b	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.197d	f0 0f		beq $198e			beq 	_VMCSuccess 				; successful.
.197f	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.1981	c8		iny				iny
.1982	20 3e 24	jsr $243e			jsr 	FloatEncode 				; send it to the number-builder
.1985	90 03		bcc $198a			bcc 	_VMCFail 					; if failed, give up.
.1987	18		clc				clc 								; next time round, countinue
.1988	80 ef		bra $1979			bra 	_VMCNext
.198a					_VMCFail:
.198a	68		pla				pla
.198b					_VMCFail2:
.198b	7a		ply				ply
.198c	38		sec				sec
.198d	60		rts				rts
.198e					_VMCSuccess:
.198e	a9 00		lda #$00			lda 	#0 							; construct final
.1990	20 3e 24	jsr $243e			jsr 	FloatEncode 				; by sending a duff value.
.1993	68		pla				pla 								; if it was -ve
.1994	c9 2d		cmp #$2d			cmp 	#"-"
.1996	d0 03		bne $199b			bne 	_VMCNotNegative
.1998	20 1c 26	jsr $261c			jsr		FloatNegate 				; negate it.
.199b					_VMCNotNegative:
.199b	7a		ply				ply
.199c	18		clc				clc
.199d	60		rts				rts
.199e					VectorTable:
>199e	b5 10					.word	LinkFloatAdd             ; $80 +
>19a0	be 10					.word	LinkFloatSubtract        ; $81 -
>19a2	c7 10					.word	LinkFloatMultiply        ; $82 *
>19a4	d0 10					.word	LinkFloatDivide          ; $83 /
>19a6	db 10					.word	LinkFloatPower           ; $84 ^
>19a8	03 09					.word	BinaryAnd                ; $85 and
>19aa	07 09					.word	BinaryOr                 ; $86 or
>19ac	e6 10					.word	LinkCompareGreater       ; $87 >
>19ae	ef 10					.word	LinkCompareEqual         ; $88 =
>19b0	f8 10					.word	LinkCompareLess          ; $89 <
>19b2	01 11					.word	LinkCompareGreaterEqual  ; $8a >=
>19b4	0a 11					.word	LinkCompareNotEqual      ; $8b <>
>19b6	13 11					.word	LinkCompareLessEqual     ; $8c <=
>19b8	eb 08					.word	AbsoluteTOS              ; $8d abs
>19ba	3e 09					.word	ArrayConvert             ; $8e array
>19bc	e6 09					.word	UnaryAsc                 ; $8f asc
>19be	01 0a					.word	CommandAssert            ; $90 assert
>19c0	42 0a					.word	Unary16Bin               ; $91 bin$
>19c2	6c 0a					.word	PrintCharacterX          ; $92 print.chr
>19c4	76 0a					.word	UnaryChr                 ; $93 chr$
>19c6	db 0a					.word	CompareStrings           ; $94 s.cmp
>19c8	c2 0c					.word	CommandXFor              ; $95 for
>19ca	85 0d					.word	UnaryFre                 ; $96 fre
>19cc	9d 0d					.word	CommandXGet              ; $97 get
>19ce	c3 0d					.word	CommandReturn            ; $98 return
>19d0	05 0e					.word	Command_PSET             ; $99 pset
>19d2	1f 0e					.word	Command_LINE             ; $9a line
>19d4	34 0e					.word	Command_RECT             ; $9b rect
>19d6	43 0e					.word	Command_FRAME            ; $9c frame
>19d8	52 0e					.word	Command_CHAR             ; $9d char
>19da	e9 0e					.word	Unary16Hex               ; $9e hex$
>19dc	90 0f					.word	CommandXInput            ; $9f input
>19de	a7 0f					.word	CommandInputString       ; $a0 input$
>19e0	c0 0f					.word	CommandInputReset        ; $a1 input.start
>19e2	a4 10					.word	UnaryLen                 ; $a2 len
>19e4	70 11					.word	LinkFloatCompare         ; $a3 f.cmp
>19e6	79 11					.word	LinkDivideInt32          ; $a4 int.div
>19e8	f3 11					.word	NegateTOS                ; $a5 negate
>19ea	fa 11					.word	CommandNewLine           ; $a6 new.line
>19ec	03 12					.word	CommandXNext             ; $a7 next
>19ee	ec 12					.word	NotTOS                   ; $a8 not
>19f0	03 13					.word	CommandXOn               ; $a9 on
>19f2	20 13					.word	CommandMoreOn            ; $aa moreon
>19f4	27 13					.word	UnaryPeek                ; $ab peek
>19f6	3c 13					.word	CommandPOKE              ; $ac poke
>19f8	54 13					.word	UnaryPos                 ; $ad pos
>19fa	5e 13					.word	GetChannel               ; $ae getchannel
>19fc	69 13					.word	SetChannel               ; $af setchannel
>19fe	8c 13					.word	PrintNumber              ; $b0 print.n
>1a00	ab 13					.word	PrintString              ; $b1 print.s
>1a02	12 14					.word	CommandXRead             ; $b2 read
>1a04	2c 14					.word	CommandReadString        ; $b3 read$
>1a06	b7 15					.word	UnaryRND                 ; $b4 rnd
>1a08	26 16					.word	StringConcatenate        ; $b5 concat
>1a0a	7d 16					.word	SignTOS                  ; $b6 sgn
>1a0c	a0 16					.word	PrintTab                 ; $b7 print.tab
>1a0e	ae 16					.word	PrintPos                 ; $b8 print.pos
>1a10	bf 16					.word	PrintSpace               ; $b9 print.spc
>1a12	d8 16					.word	Unary_Str                ; $ba str$
>1a14	53 17					.word	Unary_Left               ; $bb left$
>1a16	63 17					.word	Unary_Right              ; $bc right$
>1a18	7f 17					.word	Unary_Mid                ; $bd mid$
>1a1a	f1 17					.word	CommandSwap              ; $be swap
>1a1c	67 18					.word	TimeTOS                  ; $bf ti
>1a1e	6e 18					.word	TimeString               ; $c0 ti$
>1a20	44 19					.word	UnaryUsr                 ; $c1 usr
>1a22	50 19					.word	ValUnary                 ; $c2 val
>1a24	ae 1b					.word	CommandClose             ; $c3 close
>1a26	c0 1b					.word	CommandExit              ; $c4 exit
>1a28	c6 1b					.word	CommandDebug             ; $c5 debug
>1a2a	2c 1c					.word	CommandXOpen             ; $c6 open
>1a2c	c0 1c					.word	CommandScreen            ; $c7 screen
>1a2e	a7 1e					.word	CommandVPOKE             ; $c8 vpoke
>1a30	cc 1e					.word	CommandVPEEK             ; $c9 vpeek
>1a32	98 16					.word	CommandShift             ; $ca .shift
>1a34	af 08					.word	PushByteCommand          ; $cb .byte
>1a36	c2 08					.word	PushWordCommand          ; $cc .word
>1a38	ce 13					.word	CommandPushN             ; $cd .float
>1a3a	f4 13					.word	CommandPushS             ; $ce .string
>1a3c	63 0b					.word	CommandXData             ; $cf .data
>1a3e	d4 0d					.word	CommandXGoto             ; $d0 .goto
>1a40	b7 0d					.word	CommandXGosub            ; $d1 .gosub
>1a42	e9 0d					.word	CommandGotoZ             ; $d2 .goto.z
>1a44	f7 0d					.word	CommandGotoNZ            ; $d3 .goto.nz
>1a46	f1 08					.word	CommandVarSpace          ; $d4 .varspace
.1a48					ShiftVectorTable:
>1a48	8e 0a					.word	CommandClr               ; $ca80 clr
>1a4a	6c 0b					.word	CommandXDIM              ; $ca81 dim
>1a4c	5d 0c					.word	CommandEnd               ; $ca82 end
>1a4e	75 10					.word	UnaryJoy                 ; $ca83 joy
>1a50	1c 11					.word	LinkFloatIntegerPartDown ; $ca84 int
>1a52	25 11					.word	LinkFloatSquareRoot      ; $ca85 sqr
>1a54	36 11					.word	LinkFloatLogarithm       ; $ca86 log
>1a56	41 11					.word	LinkFloatExponent        ; $ca87 exp
>1a58	4a 11					.word	LinkFloatCosine          ; $ca88 cos
>1a5a	53 11					.word	LinkFloatSine            ; $ca89 sin
>1a5c	5c 11					.word	LinkFloatTangent         ; $ca8a tan
>1a5e	65 11					.word	LinkFloatArcTan          ; $ca8b atn
>1a60	a3 11					.word	XCommandMouse            ; $ca8c mouse
>1a62	b8 11					.word	XUnaryMB                 ; $ca8d mb
>1a64	c5 11					.word	XUnaryMX                 ; $ca8e mx
>1a66	d6 11					.word	XUnaryMY                 ; $ca8f my
>1a68	a5 15					.word	CommandRestore           ; $ca90 restore
>1a6a	d4 16					.word	CommandStop              ; $ca91 stop
>1a6c	31 18					.word	CommandSYS               ; $ca92 sys
>1a6e	d9 18					.word	CommandTIWrite           ; $ca93 ti$.write
>1a70	a6 1a					.word	CommandXWAIT             ; $ca94 wait
>1a72	f1 1b					.word	X16I2CPoke               ; $ca95 i2cpoke
>1a74	11 1c					.word	X16I2CPeek               ; $ca96 i2cpeek
>1a76	7c 1c					.word	CommandBank              ; $ca97 bank
>1a78	cf 1c					.word	XCommandSleep            ; $ca98 sleep
>1a7a	f3 1c					.word	X16_Audio_FMINIT         ; $ca99 fminit
>1a7c	01 1d					.word	X16_Audio_FMNOTE         ; $ca9a fmnote
>1a7e	13 1d					.word	X16_Audio_FMDRUM         ; $ca9b fmdrum
>1a80	25 1d					.word	X16_Audio_FMINST         ; $ca9c fminst
>1a82	37 1d					.word	X16_Audio_FMVIB          ; $ca9d fmvib
>1a84	49 1d					.word	X16_Audio_FMFREQ         ; $ca9e fmfreq
>1a86	5a 1d					.word	X16_Audio_FMVOL          ; $ca9f fmvol
>1a88	6c 1d					.word	X16_Audio_FMPAN          ; $caa0 fmpan
>1a8a	7e 1d					.word	X16_Audio_FMPLAY         ; $caa1 fmplay
>1a8c	8f 1d					.word	X16_Audio_FMCHORD        ; $caa2 fmchord
>1a8e	a0 1d					.word	X16_Audio_FMPOKE         ; $caa3 fmpoke
>1a90	b2 1d					.word	X16_Audio_PSGINIT        ; $caa4 psginit
>1a92	c0 1d					.word	X16_Audio_PSGNOTE        ; $caa5 psgnote
>1a94	d2 1d					.word	X16_Audio_PSGVOL         ; $caa6 psgvol
>1a96	e4 1d					.word	X16_Audio_PSGWAV         ; $caa7 psgwav
>1a98	f6 1d					.word	X16_Audio_PSGFREQ        ; $caa8 psgfreq
>1a9a	07 1e					.word	X16_Audio_PSGPAN         ; $caa9 psgpan
>1a9c	19 1e					.word	X16_Audio_PSGPLAY        ; $caaa psgplay
>1a9e	2a 1e					.word	X16_Audio_PSGCHORD       ; $caab psgchord
>1aa0	3b 1e					.word	CommandCls               ; $caac cls
>1aa2	44 1e					.word	CommandLocate            ; $caad locate
>1aa4	6e 1e					.word	CommandColor             ; $caae color
.1aa6					CommandXWAIT:
.1aa6	fa		plx				plx
.1aa7	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1aa9	85 2c		sta $2c				sta 	zTemp0
.1aab	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1aad	85 2d		sta $2d				sta 	zTemp0+1
.1aaf					_WaitLoop:
.1aaf	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1ab1	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1ab3	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1ab5	f0 f8		beq $1aaf			beq 	_WaitLoop 					; keep going if zero
.1ab7	ca		dex				dex 								; drop 3.
.1ab8	ca		dex				dex
.1ab9	ca		dex				dex
.1aba	4c 71 08	jmp $0871			jmp 	NextCommand
.1abd					WriteFloatCommand:
.1abd	fa		plx				plx
.1abe	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1ac0	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1ac2	88		dey				dey 								; get the upper 3 bits
.1ac3	b1 28		lda ($28),y			lda 	(codePtr),y
.1ac5	29 07		and #$07			and 	#7
.1ac7	c8		iny				iny
.1ac8	c8		iny				iny
.1ac9	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1acb	2a		rol a				rol 	a 							; carry will be clear.
.1acc	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1acf	85 2d		sta $2d				sta 	zTemp0+1
.1ad1	20 d7 1a	jsr $1ad7			jsr 	WriteFloatZTemp0Sub
.1ad4	4c 71 08	jmp $0871			jmp 	NextCommand
.1ad7					WriteFloatZTemp0Sub:
.1ad7	5a		phy				phy 								; ldart write
.1ad8	a0 01		ldy #$01			ldy 	#1
.1ada	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1adc	92 2c		sta ($2c)			sta 	(zTemp0)
.1ade	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ae0	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ae2	c8		iny				iny
.1ae3	b5 56		lda $56,x			lda 	NSMantissa2,x
.1ae5	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ae7	c8		iny				iny
.1ae8	b5 62		lda $62,x			lda 	NSMantissa3,x
.1aea	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1aec	c8		iny				iny
.1aed	b5 6e		lda $6e,x			lda 	NSExponent,x
.1aef	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1af1	c8		iny				iny
.1af2	b5 32		lda $32,x			lda 	NSStatus,x
.1af4	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1af6	ca		dex				dex
.1af7	7a		ply				ply
.1af8	60		rts				rts
.1af9					WriteIntegerCommand:
.1af9	fa		plx				plx
.1afa	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1afc	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1afe	88		dey				dey 								; get the upper 3 bits
.1aff	b1 28		lda ($28),y			lda 	(codePtr),y
.1b01	29 07		and #$07			and 	#7
.1b03	c8		iny				iny
.1b04	c8		iny				iny
.1b05	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b07	2a		rol a				rol 	a 							; carry will be clear.
.1b08	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b0b	85 2d		sta $2d				sta 	zTemp0+1
.1b0d	20 13 1b	jsr $1b13			jsr 	WriteIntegerZTemp0Sub
.1b10	4c 71 08	jmp $0871			jmp 	NextCommand
.1b13					WriteIntegerZTemp0Sub:
.1b13	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.1b16	5a		phy				phy 								; start write
.1b17	a0 01		ldy #$01			ldy 	#1
.1b19	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1b1b	30 0b		bmi $1b28			bmi 	_WIZNegative
.1b1d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1b1f	92 2c		sta ($2c)			sta 	(zTemp0)
.1b21	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b23	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b25	7a		ply				ply
.1b26	ca		dex				dex
.1b27	60		rts				rts
.1b28					_WIZNegative:
.1b28	38		sec				sec 								; -ve read
.1b29	a9 00		lda #$00			lda 	#0
.1b2b	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1b2d	92 2c		sta ($2c)			sta 	(zTemp0)
.1b2f	a9 00		lda #$00			lda 	#0
.1b31	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1b33	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b35	7a		ply				ply
.1b36	ca		dex				dex
.1b37	60		rts				rts
.1b38					WriteStringCommand:
.1b38	fa		plx				plx
.1b39	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b3b	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b3d	88		dey				dey 								; get the upper 3 bits
.1b3e	b1 28		lda ($28),y			lda 	(codePtr),y
.1b40	29 07		and #$07			and 	#7
.1b42	c8		iny				iny
.1b43	c8		iny				iny
.1b44	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b46	2a		rol a				rol 	a 							; carry will be clear.
.1b47	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b4a	85 2d		sta $2d				sta 	zTemp0+1
.1b4c	20 52 1b	jsr $1b52			jsr 	WriteStringZTemp0Sub
.1b4f	4c 71 08	jmp $0871			jmp 	NextCommand
.1b52					WriteStringZTemp0Sub:
.1b52	5a		phy				phy
.1b53	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b55	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b57	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b59	f0 1e		beq $1b79			beq 	_WSConcrete
.1b5b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b5d	85 2e		sta $2e				sta 	zTemp1
.1b5f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b61	85 2f		sta $2f				sta 	zTemp1+1
.1b63	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b65	85 30		sta $30				sta 	zTemp2
.1b67	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b69	85 31		sta $31				sta 	zTemp2+1
.1b6b	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1b6d	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1b6f	b0 17		bcs $1b88			bcs 	_WSCopy
.1b71	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1b73	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b75	09 80		ora #$80			ora 	#$80
.1b77	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1b79					_WSConcrete:
.1b79	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1b7b	a8		tay				tay
.1b7c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b7e	20 1d 0b	jsr $0b1d			jsr 	StringConcrete
.1b81	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1b83	98		tya				tya
.1b84	a0 01		ldy #$01			ldy 	#1
.1b86	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b88					_WSCopy
.1b88	18		clc				clc  								; copy target+2 to zTemp2
.1b89	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b8b	69 02		adc #$02			adc 	#2
.1b8d	85 30		sta $30				sta 	zTemp2
.1b8f	a0 01		ldy #$01			ldy 	#1
.1b91	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b93	69 00		adc #$00			adc 	#0
.1b95	85 31		sta $31				sta 	zTemp2+1
.1b97	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1b99	85 2e		sta $2e				sta 	zTemp1
.1b9b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b9d	85 2f		sta $2f				sta 	zTemp1+1
.1b9f	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1ba1	a8		tay				tay
.1ba2					_WSCopyLoop:
.1ba2	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1ba4	91 30		sta ($30),y			sta 	(zTemp2),y
.1ba6	88		dey				dey
.1ba7	c0 ff		cpy #$ff			cpy 	#$FF
.1ba9	d0 f7		bne $1ba2			bne 	_WSCopyLoop
.1bab	ca		dex				dex
.1bac	7a		ply				ply
.1bad	60		rts				rts
.1bae					CommandClose:
.1bae	fa		plx				plx
.1baf	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; channel to close
.1bb2	cd 5d 04	cmp $045d			cmp 	currentChannel 				; is it the current channel
.1bb5	d0 03		bne $1bba			bne 	_CCNotCurrent
.1bb7	9c 5d 04	stz $045d			stz 	currentChannel 				; effectively disables CMD
.1bba					_CCNotCurrent:
.1bba	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1bbd	4c 71 08	jmp $0871			jmp 	NextCommand
.1bc0					CommandExit:
.1bc0	fa		plx				plx
.1bc1	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1bc3	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1bc6					CommandDebug:
.1bc6	fa		plx				plx
>1bc7	db						.byte 	$DB 						; causes a break in the emulator
.1bc8	4c 71 08	jmp $0871			jmp 	NextCommand
.1bcb					XGetCharacterFromChannel:
.1bcb	da		phx				phx
.1bcc	5a		phy				phy
.1bcd	e0 00		cpx #$00			cpx 	#0 							; is it default
.1bcf	d0 05		bne $1bd6			bne 	_XGetChannel
.1bd1	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1bd4	80 08		bra $1bde			bra 	_XGetChar
.1bd6					_XGetChannel:
.1bd6	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1bd9	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1bdc	d0 06		bne $1be4			bne 	_XGCError
.1bde					_XGetChar:
.1bde	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1be1	7a		ply				ply
.1be2	fa		plx				plx
.1be3	60		rts				rts
.1be4					_XGCError:
.1be4	4c 13 20	jmp $2013		jmp	ErrorV_channel
.1be7					XGetHPos:
.1be7	da		phx				phx
.1be8	5a		phy				phy
.1be9	38		sec				sec
.1bea	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1bed	98		tya				tya
.1bee	7a		ply				ply
.1bef	fa		plx				plx
.1bf0	60		rts				rts
.1bf1					X16I2CPoke:
.1bf1	fa		plx				plx
.1bf2	5a		phy				phy
.1bf3	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; value
.1bf6	48		pha				pha
.1bf7	ca		dex				dex
.1bf8	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; register
.1bfb	48		pha				pha
.1bfc	ca		dex				dex
.1bfd	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; device
.1c00	aa		tax				tax
.1c01	7a		ply				ply
.1c02	68		pla				pla
.1c03	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1c06	b0 06		bcs $1c0e			bcs 	X16I2CError
.1c08	7a		ply				ply
.1c09	a2 ff		ldx #$ff			ldx 	#$FF
.1c0b	4c 71 08	jmp $0871			jmp 	NextCommand
.1c0e					X16I2CError:
.1c0e	4c 13 20	jmp $2013		jmp	ErrorV_channel
.1c11					X16I2CPeek:
.1c11	fa		plx				plx
.1c12	da		phx				phx
.1c13	5a		phy				phy
.1c14	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; register
.1c17	48		pha				pha
.1c18	ca		dex				dex
.1c19	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; device
.1c1c	aa		tax				tax 								; X device
.1c1d	7a		ply				ply 								; Y register
.1c1e	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1c21	b0 eb		bcs $1c0e			bcs 	X16I2CError
.1c23	7a		ply				ply 								; restore Y/X
.1c24	fa		plx				plx
.1c25	ca		dex				dex 								; drop TOS (register)
.1c26	20 5c 26	jsr $265c			jsr 	FloatSetByte 				; write read value to TOS.
.1c29	4c 71 08	jmp $0871			jmp 	NextCommand
.1c2c					CommandXOpen:
.1c2c	fa		plx				plx
.1c2d	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1c2f	85 2c		sta $2c				sta 	zTemp0
.1c31	aa		tax				tax
.1c32	a5 4d		lda $4d				lda 	NSMantissa1+3
.1c34	85 2d		sta $2d				sta 	zTemp0+1
.1c36	a8		tay				tay
.1c37	e8		inx				inx 								; XY points to first character
.1c38	d0 01		bne $1c3b			bne 	_CONoCarry
.1c3a	c8		iny				iny
.1c3b					_CONoCarry:
.1c3b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c3d	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c40	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c42	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c44	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c46	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c49	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c4c	b0 03		bcs $1c51			bcs 	_COError
.1c4e	4c 71 08	jmp $0871			jmp 	NextCommand
.1c51					_COError:
.1c51	4c 13 20	jmp $2013		jmp	ErrorV_channel
.1c54					XPokeMemory:
.1c54	86 2c		stx $2c				stx 	zTemp0
.1c56	84 2d		sty $2d				sty 	zTemp0+1
.1c58	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c5a	ae 6b 05	ldx $056b			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c5d	e0 ff		cpx #$ff			cpx 	#$FF
.1c5f	f0 02		beq $1c63			beq 	_XPMNoSwitch
.1c61	86 00		stx $00				stx 	SelectRAMBank
.1c63					_XPMNoSwitch:
.1c63	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1c65	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1c67					_XPMExit:
.1c67	60		rts				rts
.1c68					XPeekMemory:
.1c68	86 2c		stx $2c				stx 	zTemp0
.1c6a	84 2d		sty $2d				sty 	zTemp0+1
.1c6c	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c6e	ae 6b 05	ldx $056b			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c71	e0 ff		cpx #$ff			cpx 	#$FF
.1c73	f0 02		beq $1c77			beq 	_XPMNoSwitch
.1c75	86 00		stx $00				stx 	SelectRAMBank
.1c77					_XPMNoSwitch:
.1c77	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1c79	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1c7b	60		rts				rts
.1c7c					CommandBank:
.1c7c	fa		plx				plx
.1c7d	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1c7f	8d 6b 05	sta $056b			sta 	ramBank 					; store & make current
.1c82	85 00		sta $00				sta 	SelectRAMBank
.1c84	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1c86	c9 ff		cmp #$ff			cmp 	#$FF
.1c88	f0 03		beq $1c8d			beq 	_CBNoUpdate
.1c8a	8d 6c 05	sta $056c			sta 	romBank 					; this doesn't set the hardware page.
.1c8d					_CBNoUpdate:
.1c8d	a2 ff		ldx #$ff			ldx 	#$FF
.1c8f	4c 71 08	jmp $0871			jmp 	NextCommand
.056b					ramBank:
>056b							.fill 	1
.056c					romBank:
>056c							.fill 	1
.1c92					XPrintCharacterToChannel:
.1c92	48		pha				pha
.1c93	da		phx				phx
.1c94	5a		phy				phy
.1c95	48		pha				pha  								; save char
.1c96	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1c98	d0 05		bne $1c9f			bne 	_XPCNotDefault
.1c9a	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1c9d	80 08		bra $1ca7			bra 	_XPCSend
.1c9f					_XPCNotDefault:
.1c9f	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1ca2	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1ca5	d0 08		bne $1caf			bne 	_XPCError
.1ca7					_XPCSend:
.1ca7	68		pla				pla 								; restore character
.1ca8	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1cab	7a		ply				ply
.1cac	fa		plx				plx
.1cad	68		pla				pla
.1cae	60		rts				rts
.1caf					_XPCError:
.1caf	4c 13 20	jmp $2013		jmp	ErrorV_channel
.1cb2					XReadClock:
.1cb2	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1cb5	60		rts				rts
.1cb6					XWriteClock:
.1cb6	48		pha				pha
.1cb7	da		phx				phx
.1cb8	5a		phy				phy
.1cb9	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1cbc	7a		ply				ply
.1cbd	fa		plx				plx
.1cbe	68		pla				pla
.1cbf	60		rts				rts
.1cc0					CommandScreen:
.1cc0	fa		plx				plx
.1cc1	da		phx				phx
.1cc2	5a		phy				phy
.1cc3	20 4d 10	jsr $104d			jsr 	GetInteger8Bit
.1cc6	18		clc				clc
.1cc7	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1cca	7a		ply				ply
.1ccb	fa		plx				plx
.1ccc	4c 71 08	jmp $0871			jmp 	NextCommand
.1ccf					XCommandSleep:
.1ccf	fa		plx				plx
.1cd0	5a		phy				phy
.1cd1	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.1cd4	ca		dex				dex
.1cd5	20 b2 1c	jsr $1cb2			jsr 	XReadClock 					; read clock to YXA
.1cd8	18		clc				clc 								; calculate end time in zTemp0
.1cd9	65 3e		adc $3e				adc 	NSMantissa0
.1cdb	85 2c		sta $2c				sta 	zTemp0
.1cdd	8a		txa				txa
.1cde	65 4a		adc $4a				adc 	NSMantissa1
.1ce0	85 2d		sta $2d				sta 	zTemp0+1
.1ce2					_XCWait:
.1ce2	20 b2 1c	jsr $1cb2			jsr 	XReadClock 					; and wait for it.
.1ce5	c5 2c		cmp $2c				cmp 	zTemp0
.1ce7	d0 f9		bne $1ce2			bne 	_XCWait
.1ce9	e4 2d		cpx $2d				cpx 	zTemp0+1
.1ceb	d0 f5		bne $1ce2			bne 	_XCWait
.1ced	a2 ff		ldx #$ff			ldx 	#$FF
.1cef	7a		ply				ply
.1cf0	4c 71 08	jmp $0871			jmp 	NextCommand
.1cf3					X16_Audio_FMINIT:
.1cf3	fa		plx				plx
.1cf4	5a		phy			phy
.1cf5	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cf8	63 c0					.word	X16A_ym_init
>1cfa	0a					.byte	X16_AudioCodeBank
.1cfb	a2 ff		ldx #$ff		ldx	#$FF
.1cfd	7a		ply			ply
.1cfe	4c 71 08	jmp $0871			jmp 	NextCommand
.1d01					X16_Audio_FMNOTE:
.1d01	fa		plx				plx
.1d02	5a		phy			phy
.1d03	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_8
.1d06	18		clc			clc
.1d07	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d0a	03 c0					.word	X16A_bas_fmnote
>1d0c	0a					.byte	X16_AudioCodeBank
.1d0d	a2 ff		ldx #$ff		ldx	#$FF
.1d0f	7a		ply			ply
.1d10	4c 71 08	jmp $0871			jmp 	NextCommand
.1d13					X16_Audio_FMDRUM:
.1d13	fa		plx				plx
.1d14	5a		phy			phy
.1d15	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_8
.1d18	18		clc			clc
.1d19	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d1c	6f c0					.word	X16A_ym_playdrum
>1d1e	0a					.byte	X16_AudioCodeBank
.1d1f	a2 ff		ldx #$ff		ldx	#$FF
.1d21	7a		ply			ply
.1d22	4c 71 08	jmp $0871			jmp 	NextCommand
.1d25					X16_Audio_FMINST:
.1d25	fa		plx				plx
.1d26	5a		phy			phy
.1d27	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_8
.1d2a	38		sec			sec
.1d2b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d2e	69 c0					.word	X16A_ym_loadpatch
>1d30	0a					.byte	X16_AudioCodeBank
.1d31	a2 ff		ldx #$ff		ldx	#$FF
.1d33	7a		ply			ply
.1d34	4c 71 08	jmp $0871			jmp 	NextCommand
.1d37					X16_Audio_FMVIB:
.1d37	fa		plx				plx
.1d38	5a		phy			phy
.1d39	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_8
.1d3c	18		clc			clc
.1d3d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d40	09 c0					.word	X16A_bas_fmvib
>1d42	0a					.byte	X16_AudioCodeBank
.1d43	a2 ff		ldx #$ff		ldx	#$FF
.1d45	7a		ply			ply
.1d46	4c 71 08	jmp $0871			jmp 	NextCommand
.1d49					X16_Audio_FMFREQ:
.1d49	fa		plx				plx
.1d4a	5a		phy			phy
.1d4b	20 12 0a	jsr $0a12		jsr		X16_Audio_Parameters8_16
.1d4e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d51	00 c0					.word	X16A_bas_fmfreq
>1d53	0a					.byte	X16_AudioCodeBank
.1d54	a2 ff		ldx #$ff		ldx	#$FF
.1d56	7a		ply			ply
.1d57	4c 71 08	jmp $0871			jmp 	NextCommand
.1d5a					X16_Audio_FMVOL:
.1d5a	fa		plx				plx
.1d5b	5a		phy			phy
.1d5c	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_8
.1d5f	18		clc			clc
.1d60	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d63	75 c0					.word	X16A_ym_setatten
>1d65	0a					.byte	X16_AudioCodeBank
.1d66	a2 ff		ldx #$ff		ldx	#$FF
.1d68	7a		ply			ply
.1d69	4c 71 08	jmp $0871			jmp 	NextCommand
.1d6c					X16_Audio_FMPAN:
.1d6c	fa		plx				plx
.1d6d	5a		phy			phy
.1d6e	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_8
.1d71	18		clc			clc
.1d72	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d75	7e c0					.word	X16A_ym_setpan
>1d77	0a					.byte	X16_AudioCodeBank
.1d78	a2 ff		ldx #$ff		ldx	#$FF
.1d7a	7a		ply			ply
.1d7b	4c 71 08	jmp $0871			jmp 	NextCommand
.1d7e					X16_Audio_FMPLAY:
.1d7e	fa		plx				plx
.1d7f	5a		phy			phy
.1d80	20 29 0a	jsr $0a29		jsr		X16_Audio_Parameters8_String
.1d83	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d86	06 c0					.word	X16A_bas_fmplaystring
>1d88	0a					.byte	X16_AudioCodeBank
.1d89	a2 ff		ldx #$ff		ldx	#$FF
.1d8b	7a		ply			ply
.1d8c	4c 71 08	jmp $0871			jmp 	NextCommand
.1d8f					X16_Audio_FMCHORD:
.1d8f	fa		plx				plx
.1d90	5a		phy			phy
.1d91	20 29 0a	jsr $0a29		jsr		X16_Audio_Parameters8_String
.1d94	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d97	8d c0					.word	X16A_bas_fmchordstring
>1d99	0a					.byte	X16_AudioCodeBank
.1d9a	a2 ff		ldx #$ff		ldx	#$FF
.1d9c	7a		ply			ply
.1d9d	4c 71 08	jmp $0871			jmp 	NextCommand
.1da0					X16_Audio_FMPOKE:
.1da0	fa		plx				plx
.1da1	5a		phy			phy
.1da2	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_8
.1da5	18		clc			clc
.1da6	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1da9	8a c0					.word	X16A_ym_write
>1dab	0a					.byte	X16_AudioCodeBank
.1dac	a2 ff		ldx #$ff		ldx	#$FF
.1dae	7a		ply			ply
.1daf	4c 71 08	jmp $0871			jmp 	NextCommand
.1db2					X16_Audio_PSGINIT:
.1db2	fa		plx				plx
.1db3	5a		phy			phy
.1db4	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1db7	4b c0					.word	X16A_psg_init
>1db9	0a					.byte	X16_AudioCodeBank
.1dba	a2 ff		ldx #$ff		ldx	#$FF
.1dbc	7a		ply			ply
.1dbd	4c 71 08	jmp $0871			jmp 	NextCommand
.1dc0					X16_Audio_PSGNOTE:
.1dc0	fa		plx				plx
.1dc1	5a		phy			phy
.1dc2	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_8
.1dc5	18		clc			clc
.1dc6	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dc9	12 c0					.word	X16A_bas_psgnote
>1dcb	0a					.byte	X16_AudioCodeBank
.1dcc	a2 ff		ldx #$ff		ldx	#$FF
.1dce	7a		ply			ply
.1dcf	4c 71 08	jmp $0871			jmp 	NextCommand
.1dd2					X16_Audio_PSGVOL:
.1dd2	fa		plx				plx
.1dd3	5a		phy			phy
.1dd4	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_8
.1dd7	18		clc			clc
.1dd8	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1ddb	54 c0					.word	X16A_psg_setatten
>1ddd	0a					.byte	X16_AudioCodeBank
.1dde	a2 ff		ldx #$ff		ldx	#$FF
.1de0	7a		ply			ply
.1de1	4c 71 08	jmp $0871			jmp 	NextCommand
.1de4					X16_Audio_PSGWAV:
.1de4	fa		plx				plx
.1de5	5a		phy			phy
.1de6	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_8
.1de9	18		clc			clc
.1dea	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1ded	15 c0					.word	X16A_bas_psgwav
>1def	0a					.byte	X16_AudioCodeBank
.1df0	a2 ff		ldx #$ff		ldx	#$FF
.1df2	7a		ply			ply
.1df3	4c 71 08	jmp $0871			jmp 	NextCommand
.1df6					X16_Audio_PSGFREQ:
.1df6	fa		plx				plx
.1df7	5a		phy			phy
.1df8	20 12 0a	jsr $0a12		jsr		X16_Audio_Parameters8_16
.1dfb	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dfe	0f c0					.word	X16A_bas_psgfreq
>1e00	0a					.byte	X16_AudioCodeBank
.1e01	a2 ff		ldx #$ff		ldx	#$FF
.1e03	7a		ply			ply
.1e04	4c 71 08	jmp $0871			jmp 	NextCommand
.1e07					X16_Audio_PSGPAN:
.1e07	fa		plx				plx
.1e08	5a		phy			phy
.1e09	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_8
.1e0c	18		clc			clc
.1e0d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e10	5a c0					.word	X16A_psg_setpan
>1e12	0a					.byte	X16_AudioCodeBank
.1e13	a2 ff		ldx #$ff		ldx	#$FF
.1e15	7a		ply			ply
.1e16	4c 71 08	jmp $0871			jmp 	NextCommand
.1e19					X16_Audio_PSGPLAY:
.1e19	fa		plx				plx
.1e1a	5a		phy			phy
.1e1b	20 29 0a	jsr $0a29		jsr		X16_Audio_Parameters8_String
.1e1e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e21	18 c0					.word	X16A_bas_psgplaystring
>1e23	0a					.byte	X16_AudioCodeBank
.1e24	a2 ff		ldx #$ff		ldx	#$FF
.1e26	7a		ply			ply
.1e27	4c 71 08	jmp $0871			jmp 	NextCommand
.1e2a					X16_Audio_PSGCHORD:
.1e2a	fa		plx				plx
.1e2b	5a		phy			phy
.1e2c	20 29 0a	jsr $0a29		jsr		X16_Audio_Parameters8_String
.1e2f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e32	90 c0					.word	X16A_bas_psgchordstring
>1e34	0a					.byte	X16_AudioCodeBank
.1e35	a2 ff		ldx #$ff		ldx	#$FF
.1e37	7a		ply			ply
.1e38	4c 71 08	jmp $0871			jmp 	NextCommand
.1e3b					CommandCls:
.1e3b	fa		plx				plx
.1e3c	a9 93		lda #$93			lda 	#147
.1e3e	20 92 1c	jsr $1c92			jsr 	XPrintCharacterToChannel
.1e41	4c 71 08	jmp $0871			jmp 	NextCommand
.1e44					CommandLocate:
.1e44	fa		plx				plx
.1e45	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.1e48	ca		dex				dex
.1e49	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.1e4c	ca		dex				dex
.1e4d	a9 13		lda #$13			lda 	#$13 						; home.
.1e4f	20 92 1c	jsr $1c92			jsr 	XPrintCharacterToChannel
.1e52	a9 1d		lda #$1d			lda 	#$1D 						; do cursor rights
.1e54	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1e56	20 63 1e	jsr $1e63			jsr 	_CLOutputXA
.1e59	a9 11		lda #$11			lda 	#$11 						; do cursor downs.
.1e5b	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e5d	20 63 1e	jsr $1e63			jsr 	_CLOutputXA
.1e60	4c 71 08	jmp $0871			jmp 	NextCommand
.1e63					_CLOutputXA:
.1e63	ca		dex				dex
.1e64	f0 07		beq $1e6d			beq 	_CLOExit
.1e66	30 05		bmi $1e6d			bmi 	_CLOExit
.1e68	20 92 1c	jsr $1c92			jsr 	XPrintCharacterToChannel
.1e6b	80 f6		bra $1e63			bra 	_CLOutputXA
.1e6d					_CLOExit:
.1e6d	60		rts				rts
.1e6e					CommandColor:
.1e6e	fa		plx				plx
.1e6f	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.1e72	ca		dex				dex
.1e73	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.1e76	ca		dex				dex
.1e77	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1e79	c9 ff		cmp #$ff			cmp 	#$FF
.1e7b	f0 08		beq $1e85			beq 	_CCNoBGR 					; if so, change background
.1e7d	20 8d 1e	jsr $1e8d			jsr 	_CCSetColour
.1e80	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1e82	20 92 1c	jsr $1c92			jsr 	XPrintCharacterToChannel
.1e85					_CCNoBGR:
.1e85	a5 3e		lda $3e				lda 	NSMantissa0
.1e87	20 8d 1e	jsr $1e8d			jsr 	_CCSetColour
.1e8a	4c 71 08	jmp $0871			jmp 	NextCommand
.1e8d					_CCSetColour:
.1e8d	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1e8f	aa		tax				tax
.1e90	bd 97 1e	lda $1e97,x			lda 	_CCCommandTable,x
.1e93	20 92 1c	jsr $1c92			jsr 	XPrintCharacterToChannel
.1e96	60		rts				rts
.1e97					_CCCommandTable:
>1e97	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1e9f	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1ea7					CommandVPOKE:
.1ea7	fa		plx				plx
.1ea8	20 4d 10	jsr $104d			jsr 	GetInteger8Bit 				; poke value
.1eab	48		pha				pha
.1eac	ca		dex				dex
.1ead	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.1eb0	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1eb2	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1eb5	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1eb7	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1eba	ca		dex				dex
.1ebb	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.1ebe	20 4d 10	jsr $104d			jsr 	GetInteger8Bit
.1ec1	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1ec4	ca		dex				dex
.1ec5	68		pla				pla 								; poke value back
.1ec6	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1ec9	4c 71 08	jmp $0871			jmp 	NextCommand
.1ecc					CommandVPEEK:
.1ecc	fa		plx				plx
.1ecd	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.1ed0	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ed2	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1ed5	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ed7	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1eda	ca		dex				dex
.1edb	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.1ede	20 4d 10	jsr $104d			jsr 	GetInteger8Bit
.1ee1	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1ee4	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1ee7	20 5c 26	jsr $265c			jsr 	FloatSetByte 				; return as byte
.1eea	4c 71 08	jmp $0871			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1eed					SetErrorHandler:
.1eed	8c 6e 05	sty $056e			sty 	ErrorHandlerVector+1
.1ef0	8e 6d 05	stx $056d			stx 	ErrorHandlerVector
.1ef3	60		rts				rts
.1ef4					CallErrorHandler:
.1ef4	6c 6d 05	jmp ($056d)			jmp 	(ErrorHandlerVector)
.056d					ErrorHandlerVector:
>056d							.fill 	2
.1ef7					ErrorV_range:
.1ef7	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1efa	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f02	41 4e 47 45 00
.1f07					ErrorV_value:
.1f07	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1f0a	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f12	45 00
.1f14					ErrorV_syntax:
.1f14	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1f17	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f1f	52 52 4f 52 00
.1f24					ErrorV_type:
.1f24	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1f27	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f2f	4d 41 54 43 48 00
.1f35					ErrorV_unimplemented:
.1f35	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1f38	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f40	45 4d 45 4e 54 45 44 00
.1f48					ErrorV_assert:
.1f48	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1f4b	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f53	41 49 4c 00
.1f57					ErrorV_line:
.1f57	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1f5a	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f62	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f6e					ErrorV_internal:
.1f6e	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1f71	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f79	20 45 52 52 4f 52 00
.1f80					ErrorV_divzero:
.1f80	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1f83	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1f8b	59 20 5a 45 52 4f 00
.1f92					ErrorV_structure:
.1f92	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1f95	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1f9d	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fa9					ErrorV_stop:
.1fa9	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1fac	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fb4	53 54 4f 50 50 45 44 00
.1fbc					ErrorV_data:
.1fbc	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1fbf	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fc7	41 54 41 00
.1fcb					ErrorV_undeclared:
.1fcb	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1fce	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1fd6	41 52 52 41 59 00
.1fdc					ErrorV_redefine:
.1fdc	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1fdf	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1fe7	44 45 46 49 4e 45 44 00
.1fef					ErrorV_index:
.1fef	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>1ff2	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1ffa	59 20 49 4e 44 45 58 00
.2002					ErrorV_memory:
.2002	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>2005	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>200d	45 4d 4f 52 59 00
.2013					ErrorV_channel:
.2013	20 f4 1e	jsr $1ef4		jsr	CallErrorHandler
>2016	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>201e	54 50 55 54 20 45 52 52 4f 52 00
.2029					MoveObjectForward:
.2029	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.202b	c9 ff		cmp #$ff			cmp 	#$FF
.202d	f0 36		beq $2065			beq 	_MOFEnd
.202f	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.2031	90 24		bcc $2057			bcc 	_MOFAdvance1 				; forward 1
.2033	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.2035	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2037	90 20		bcc $2059			bcc 	_MOFAdvanceY
.2039	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.203b	90 1a		bcc $2057			bcc 	_MOFAdvance1 				; forward 1
.203d	a8		tay				tay 								; read the size.
.203e	b9 a3 1f	lda $1fa3,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.2041	a8		tay				tay
.2042	c8		iny				iny 								; add 1 for the system token.
.2043	d0 14		bne $2059			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2045	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2047	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2049	a8		tay				tay 								; into Y.
.204a	18		clc				clc
.204b	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.204d	69 02		adc #$02			adc 	#2
.204f	85 2a		sta $2a				sta 	objPtr
.2051	90 02		bcc $2055			bcc 	_MOFNoCarry1
.2053	e6 2b		inc $2b				inc 	objPtr+1
.2055					_MOFNoCarry1:
.2055	80 02		bra $2059			bra 	_MOFAdvanceY
.2057					_MOFAdvance1:
.2057	a0 01		ldy #$01			ldy 	#1
.2059					_MOFAdvanceY:
.2059	98		tya				tya 								; add Y to objPtr
.205a	18		clc				clc
.205b	65 2a		adc $2a				adc 	objPtr
.205d	85 2a		sta $2a				sta 	objPtr
.205f	90 02		bcc $2063			bcc 	_MOFNoCarry2
.2061	e6 2b		inc $2b				inc 	objPtr+1
.2063					_MOFNoCarry2:
.2063	18		clc				clc 								; not completed.
.2064	60		rts				rts
.2065					_MOFEnd:
.2065	e6 2a		inc $2a				inc 	objPtr
.2067	d0 02		bne $206b			bne 	_MOFENoCarry
.2069	e6 2b		inc $2b				inc 	objPtr+1
.206b					_MOFENoCarry:
.206b	38		sec				sec
.206c	60		rts				rts
.206d					MOFSizeTable:
>206d	01					.byte	1         	; $ca .shift
>206e	01					.byte	1         	; $cb .byte
>206f	02					.byte	2         	; $cc .word
>2070	05					.byte	5         	; $cd .float
>2071	ff					.byte	255       	; $ce .string
>2072	ff					.byte	255       	; $cf .data
>2073	02					.byte	2         	; $d0 .goto
>2074	02					.byte	2         	; $d1 .gosub
>2075	02					.byte	2         	; $d2 .goto.z
>2076	02					.byte	2         	; $d3 .goto.nz
>2077	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.056f					numberBuffer:
>056f							.fill 	34
.2078					FloatSubtract:
.2078	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.207a	49 80		eor #$80			eor 	#$80
.207c	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.207e					FloatAdd:
.207e	ca		dex				dex
.207f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.2081	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2083	15 62		ora $62,x			ora 	NSMantissa3,x
.2085	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2087	d0 04		bne $208d			bne 	_FAUseFloat
.2089	20 1a 24	jsr $241a			jsr 	FloatInt32Add 				; use the int32 one.
.208c	60		rts				rts
.208d					_FAUseFloat:
.208d	20 af 23	jsr $23af			jsr 	FloatNormalise 				; normalise S[X]
.2090	f0 51		beq $20e3			beq 	_FAReturn1
.2092	e8		inx				inx 								; normalise S[X+1]
.2093	20 af 23	jsr $23af			jsr 	FloatNormalise
.2096	ca		dex				dex
.2097	c9 00		cmp #$00			cmp 	#0
.2099	f0 60		beq $20fb			beq 	_FAExit 					; if so, just return A
.209b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.209d	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.209f	f0 18		beq $20b9			beq 	_FAExponentsEqual
.20a1	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20a3	a8		tay				tay
.20a4	38		sec				sec 								; do a signed comparison of the exponents.
.20a5	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20a7	50 02		bvc $20ab			bvc 	_FANoSignedChange
.20a9	49 80		eor #$80			eor 	#$80
.20ab					_FANoSignedChange:
.20ab	29 80		and #$80			and 	#$80
.20ad	10 02		bpl $20b1			bpl 	_FAHaveMax
.20af	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.20b1					_FAHaveMax:
.20b1	20 fc 20	jsr $20fc			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20b4	e8		inx				inx
.20b5	20 fc 20	jsr $20fc			jsr 	_FAShiftToExponent
.20b8	ca		dex				dex
.20b9					_FAExponentsEqual:
.20b9	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.20bb	55 33		eor $33,x			eor 	NSStatus+1,x
.20bd	30 0e		bmi $20cd			bmi 	_FADifferentSigns
.20bf	20 e6 23	jsr $23e6			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20c2	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20c4	10 35		bpl $20fb			bpl 	_FAExit 					; if no, we are done.
.20c6	20 73 26	jsr $2673			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20c9	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.20cb	80 2e		bra $20fb			bra 	_FAExit
.20cd					_FADifferentSigns:
.20cd	20 00 24	jsr $2400			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20d0	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.20d2	10 06		bpl $20da			bpl 	_FACheckZero 				; if no, check for -0
.20d4	20 1c 26	jsr $261c			jsr 	FloatNegate 					; netate result
.20d7	20 23 26	jsr $2623			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20da					_FACheckZero:
.20da	20 7c 26	jsr $267c			jsr 	FloatIsZero	 				; check for -0
.20dd	d0 1c		bne $20fb			bne 	_FAExit
.20df	74 32		stz $32,x			stz 	NSStatus,x
.20e1	80 18		bra $20fb			bra 	_FAExit
.20e3					_FAReturn1:
.20e3	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20e5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20e7	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.20e9	95 4a		sta $4a,x			sta 	NSMantissa1,x
.20eb	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.20ed	95 56		sta $56,x			sta 	NSMantissa2,x
.20ef	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.20f1	95 62		sta $62,x			sta 	NSMantissa3,x
.20f3	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.20f5	95 6e		sta $6e,x			sta 	NSExponent,x
.20f7	b5 33		lda $33,x			lda 	NSStatus+1,x
.20f9	95 32		sta $32,x			sta 	NSStatus,x
.20fb					_FAExit:
.20fb	60		rts				rts
.20fc					_FAShiftToExponent:
.20fc					_FAShiftToExponent2:
.20fc	98		tya				tya 								; compare Y to exponent
.20fd	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.20ff	f0 07		beq $2108			beq 	_FASEExit 					; exit if so.
.2101	20 73 26	jsr $2673			jsr 	FloatShiftRight	 			; shift the mantissa right
.2104	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.2106	80 f4		bra $20fc			bra 	_FAShiftToExponent2
.2108					_FASEExit:
.2108	60		rts				rts
.2109					CompareEqual:
.2109	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.210b	d0 09		bne $2116			bne 	ReturnFalse
.210d					ReturnTrue:
.210d	a9 01		lda #$01			lda 	#1
.210f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2111	a9 80		lda #$80			lda 	#$80
.2113	95 32		sta $32,x			sta 	NSStatus,x
.2115	60		rts				rts
.2116					ReturnFalse:
.2116	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2118	60		rts				rts
.2119					CompareNotEqual:
.2119	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.211b	d0 f0		bne $210d			bne 	ReturnTrue
.211d	80 f7		bra $2116			bra 	ReturnFalse
.211f					CompareLess:
.211f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2121	c9 ff		cmp #$ff			cmp 	#$FF
.2123	f0 e8		beq $210d			beq 	ReturnTrue
.2125	80 ef		bra $2116			bra 	ReturnFalse
.2127					CompareGreater:
.2127	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2129	c9 01		cmp #$01			cmp 	#$01
.212b	f0 e0		beq $210d			beq 	ReturnTrue
.212d	80 e7		bra $2116			bra 	ReturnFalse
.212f					CompareLessEqual:
.212f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2131	c9 01		cmp #$01			cmp 	#$01
.2133	d0 d8		bne $210d			bne 	ReturnTrue
.2135	80 df		bra $2116			bra 	ReturnFalse
.2137					CompareGreaterEqual:
.2137	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2139	c9 ff		cmp #$ff			cmp 	#$FF
.213b	d0 d0		bne $210d			bne 	ReturnTrue
.213d	80 d7		bra $2116			bra 	ReturnFalse
.213f					FloatCompare:
.213f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.2141	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.2143	48		pha				pha
.2144	20 78 20	jsr $2078			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2147	68		pla				pla
.2148	d0 0c		bne $2156			bne 	_FCCompareFloat
.214a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.214c	15 4a		ora $4a,x			ora 	NSMantissa1,x
.214e	15 56		ora $56,x			ora 	NSMantissa2,x
.2150	15 62		ora $62,x			ora 	NSMantissa3,x
.2152	f0 14		beq $2168			beq 	_FCExit 					; if zero, return zero
.2154	80 0a		bra $2160			bra 	_FCSign
.2156					_FCCompareFloat:
.2156	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2158	29 f0		and #$f0			and 	#$F0
.215a	15 56		ora $56,x			ora 	NSMantissa2,x
.215c	15 62		ora $62,x			ora 	NSMantissa3,x
.215e	f0 08		beq $2168			beq 	_FCExit 					; zero, so approximately identical
.2160					_FCSign:
.2160	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2162	34 32		bit $32,x			bit 	NSStatus,x
.2164	10 02		bpl $2168			bpl 	_FCExit
.2166					_FCNegative:
.2166	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2168					_FCExit:
.2168	20 5c 26	jsr $265c			jsr 	FloatSetByte 				; set the result 255,0,1
.216b	60		rts				rts
.216c					FloatScalarTable:
>216c	66 66 66 66				.dword $66666666 ; 0.1
>2170	de					.byte $de
>2171	1f 85 eb 51				.dword $51eb851f ; 0.01
>2175	db					.byte $db
>2176	4c 37 89 41				.dword $4189374c ; 0.001
>217a	d8					.byte $d8
>217b	ac 8b db 68				.dword $68db8bac ; 0.0001
>217f	d4					.byte $d4
>2180	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>2184	d1					.byte $d1
>2185	83 de 1b 43				.dword $431bde83 ; 1e-06
>2189	ce					.byte $ce
>218a	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>218e	ca					.byte $ca
>218f	89 3b e6 55				.dword $55e63b89 ; 1e-08
>2193	c7					.byte $c7
>2194	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>2198	c4					.byte $c4
>2199	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>219d	c0					.byte $c0
>219e	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21a2	bd					.byte $bd
.21a3					FloatDivide:
.21a3	48		pha				pha
.21a4	20 af 23	jsr $23af			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21a7	ca		dex				dex
.21a8	c9 00		cmp #$00			cmp 	#0
.21aa	f0 1e		beq $21ca			beq 	_FDZero
.21ac	20 af 23	jsr $23af			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21af	f0 16		beq $21c7			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21b1	20 12 22	jsr $2212			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21b4	20 df 21	jsr $21df			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21b7	20 af 23	jsr $23af			jsr		FloatNormalise 				; renormalise
.21ba	20 a5 23	jsr $23a5			jsr 	FloatCalculateSign 			; calculate result sign
.21bd	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.21bf	38		sec				sec
.21c0	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.21c2	38		sec				sec
.21c3	e9 1e		sbc #$1e			sbc 	#30
.21c5	95 6e		sta $6e,x			sta 	NSExponent,x
.21c7					_FDExit:
.21c7	68		pla				pla
.21c8	18		clc				clc
.21c9	60		rts				rts
.21ca					_FDZero:
.21ca	68		pla				pla
.21cb	38		sec				sec
.21cc	60		rts				rts
.21cd					DivideInt32:
.21cd	20 95 22	jsr $2295			jsr 	FloatIntegerPart 			; make both integers
.21d0	ca		dex				dex
.21d1	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.21d4	20 f0 21	jsr $21f0			jsr 	Int32Divide 				; divide
.21d7	20 df 21	jsr $21df			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21da	20 a5 23	jsr $23a5			jsr 	FloatCalculateSign 			; calculate result sign
.21dd	18		clc				clc
.21de	60		rts				rts
.21df					NSMCopyPlusTwoToZero:
.21df	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21e1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21e3	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21e5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.21e7	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.21e9	95 56		sta $56,x			sta 	NSMantissa2,x
.21eb	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.21ed	95 62		sta $62,x			sta 	NSMantissa3,x
.21ef	60		rts				rts
.21f0					Int32Divide:
.21f0	48		pha				pha 								; save AXY
.21f1	5a		phy				phy
.21f2	20 3d 26	jsr $263d			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.21f5	20 56 26	jsr $2656			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.21f8	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.21fa					_I32DivideLoop:
.21fa	e8		inx				inx
.21fb	e8		inx				inx
.21fc	20 69 26	jsr $2669			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.21ff	ca		dex				dex
.2200	ca		dex				dex
.2201	20 6a 26	jsr $266a			jsr 	FloatRotateLeft
.2204	20 30 22	jsr $2230			jsr 	FloatDivideCheck 			; check if subtract possible
.2207	90 02		bcc $220b			bcc 	_I32DivideNoCarryIn
.2209	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.220b					_I32DivideNoCarryIn:
.220b	88		dey				dey 								; loop round till division completed.
.220c	d0 ec		bne $21fa			bne 	_I32DivideLoop
.220e	7a		ply				ply 								; restore AXY and exit
.220f	68		pla				pla
.2210	18		clc				clc
.2211	60		rts				rts
.2212					Int32ShiftDivide:
.2212	48		pha				pha 								; save AY
.2213	5a		phy				phy
.2214	e8		inx				inx 								; clear S[X+2]
.2215	e8		inx				inx
.2216	20 5a 26	jsr $265a			jsr 	FloatSetZero
.2219	ca		dex				dex
.221a	ca		dex				dex
.221b	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.221d					_I32SDLoop:
.221d	20 30 22	jsr $2230			jsr 	FloatDivideCheck 			; check if subtract possible
.2220	e8		inx				inx
.2221	e8		inx				inx
.2222	20 6a 26	jsr $266a			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.2225	ca		dex				dex
.2226	ca		dex				dex
.2227	20 6a 26	jsr $266a			jsr 	FloatRotateLeft
.222a	88		dey				dey 	 							; do 31 times
.222b	d0 f0		bne $221d			bne 	_I32SDLoop
.222d	7a		ply				ply 								; restore AY and exit
.222e	68		pla				pla
.222f	60		rts				rts
.2230					FloatDivideCheck:
.2230	20 00 24	jsr $2400			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.2233	b0 04		bcs $2239			bcs 	_DCSExit 					; if carry set, then could do, exit
.2235	20 e6 23	jsr $23e6			jsr 	FloatAddTopTwoStack 		; add it back in
.2238	18		clc				clc 								; and return False
.2239					_DCSExit:
.2239	60		rts				rts
.223a					FloatFractionalPart:
.223a	5a		phy				phy
.223b	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.223d	29 7f		and #$7f			and 	#$7F
.223f	95 32		sta $32,x			sta 	NSStatus,x
.2241	20 af 23	jsr $23af			jsr 	FloatNormalise
.2244	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2246	38		sec				sec
.2247	e9 e0		sbc #$e0			sbc 	#$E0
.2249	90 29		bcc $2274			bcc 	_FFPExit 					; already fractional
.224b	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.224d	b0 22		bcs $2271			bcs 	_FFPZero
.224f	a8		tay				tay 								; put count to do in Y
.2250	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.2252	20 79 22	jsr $2279			jsr 	_FFPPartial
.2255	95 62		sta $62,x			sta 	NSMantissa3,x
.2257	b5 56		lda $56,x			lda 	NSMantissa2,x
.2259	20 79 22	jsr $2279			jsr 	_FFPPartial
.225c	95 56		sta $56,x			sta 	NSMantissa2,x
.225e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2260	20 79 22	jsr $2279			jsr 	_FFPPartial
.2263	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2265	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2267	20 79 22	jsr $2279			jsr 	_FFPPartial
.226a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.226c	20 7c 26	jsr $267c			jsr 	FloatIsZero 					; zeroed check.
.226f	d0 03		bne $2274			bne 	_FFPExit
.2271					_FFPZero:
.2271	20 5a 26	jsr $265a			jsr 	FloatSetZero
.2274					_FFPExit:
.2274	20 af 23	jsr $23af			jsr 	FloatNormalise
.2277	7a		ply				ply
.2278	60		rts				rts
.2279					_FFPPartial:
.2279	c0 00		cpy #$00			cpy 	#0 							; no more to do
.227b	f0 17		beq $2294			beq 	_FFFPPExit
.227d	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.227f	b0 0c		bcs $228d			bcs 	_FFFPPWholeByte
.2281	5a		phy				phy
.2282					_FFFPPLeft:
.2282	0a		asl a				asl 	a
.2283	88		dey				dey
.2284	d0 fc		bne $2282			bne 	_FFFPPLeft
.2286	7a		ply				ply
.2287					_FFFPPRight:
.2287	4a		lsr a				lsr 	a
.2288	88		dey				dey
.2289	d0 fc		bne $2287			bne 	_FFFPPRight
.228b	80 07		bra $2294			bra 	_FFFPPExit
.228d					_FFFPPWholeByte:
.228d	98		tya				tya 								; subtract 8 from count
.228e	38		sec				sec
.228f	e9 08		sbc #$08			sbc 	#8
.2291	a8		tay				tay
.2292	a9 00		lda #$00			lda 	#0 							; and clear all
.2294					_FFFPPExit:
.2294	60		rts				rts
.2295					FloatIntegerPart:
.2295	48		pha				pha
.2296	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.2298	f0 1d		beq $22b7			beq 	_FIPExit 					; if so do nothing
.229a	20 7c 26	jsr $267c			jsr 	FloatIsZero 				; is it zero ?
.229d	f0 15		beq $22b4			beq 	_FIPZero 					; if so return zero.
.229f	20 af 23	jsr $23af			jsr 	FloatNormalise 				; normalise
.22a2	f0 10		beq $22b4			beq 	_FIPZero 					; normalised to zero, exit zero
.22a4					_FIPShift:
.22a4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22a6	10 07		bpl $22af			bpl 	_FIPCheckZero
.22a8	20 73 26	jsr $2673			jsr 	FloatShiftRight 			; shift mantissa right
.22ab	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22ad	80 f5		bra $22a4			bra 	_FIPShift
.22af					_FIPCheckZero:
.22af	20 7c 26	jsr $267c			jsr 	FloatIsZero 				; avoid -0 problem
.22b2	d0 03		bne $22b7			bne 	_FIPExit 					; set to zero if mantissa zero.
.22b4					_FIPZero:
.22b4	20 5a 26	jsr $265a			jsr 	FloatSetZero
.22b7					_FIPExit:
.22b7	68		pla				pla
.22b8	60		rts				rts
.22b9					FloatIntegerPartDown:
.22b9	48		pha				pha
.22ba	5a		phy				phy
.22bb	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22bd	f0 36		beq $22f5			beq 	_FIPExit 					; if so do nothing
.22bf	20 7c 26	jsr $267c			jsr 	FloatIsZero 				; is it zero ?
.22c2	f0 2e		beq $22f2			beq 	_FIPZero 					; if so return zero.
.22c4	20 af 23	jsr $23af			jsr 	FloatNormalise 				; normalise
.22c7	f0 29		beq $22f2			beq 	_FIPZero 					; normalised to zero, exit zero
.22c9	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22cb					_FIPShift:
.22cb	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22cd	10 0a		bpl $22d9			bpl 	_FIPCheckDown
.22cf	20 73 26	jsr $2673			jsr 	FloatShiftRight 			; shift mantissa right
.22d2	90 01		bcc $22d5			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22d4	c8		iny				iny
.22d5					_FIPNoFrac:
.22d5	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22d7	80 f2		bra $22cb			bra 	_FIPShift
.22d9					_FIPCheckDown:
.22d9	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22db	f0 10		beq $22ed			beq 	_FIPCheckZero
.22dd	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22df	10 0c		bpl $22ed			bpl 	_FIPCheckZero
.22e1	e8		inx				inx 								; -ve so round *down*.
.22e2	a9 01		lda #$01			lda 	#1
.22e4	20 5c 26	jsr $265c			jsr 	FloatSetByte
.22e7	20 1c 26	jsr $261c			jsr 	FloatNegate
.22ea	20 7e 20	jsr $207e			jsr 	FloatAdd
.22ed					_FIPCheckZero:
.22ed	20 7c 26	jsr $267c			jsr 	FloatIsZero 				; avoid -0 problem
.22f0	d0 03		bne $22f5			bne 	_FIPExit 					; set to zero if mantissa zero.
.22f2					_FIPZero:
.22f2	20 5a 26	jsr $265a			jsr 	FloatSetZero
.22f5					_FIPExit:
.22f5	7a		ply				ply
.22f6	68		pla				pla
.22f7	60		rts				rts
.22f8					FloatInt8Multiply:
.22f8	5a		phy				phy
.22f9	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.22fb	a8		tay				tay
.22fc	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.22fe					_FI8MLoop:
.22fe	98		tya				tya 								; shift right shifter right into carry
.22ff	4a		lsr a				lsr 	a
.2300	a8		tay				tay
.2301	90 0d		bcc $2310			bcc 	_FI8MNoAdd
.2303	18		clc				clc
.2304	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2306	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.2308	95 3e		sta $3e,x			sta 	NSMantissa0,x
.230a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.230c	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.230e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2310					_FI8MNoAdd:
.2310	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.2312	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.2314	c0 00		cpy #$00			cpy 	#0
.2316	d0 e6		bne $22fe			bne 	_FI8MLoop 					; until right shifter zero.
.2318	7a		ply				ply
.2319	60		rts				rts
.231a					FloatMultiply:
.231a	ca		dex				dex
.231b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.231d	15 6f		ora $6f,x			ora 	NSExponent+1,x
.231f	15 62		ora $62,x			ora 	NSMantissa3,x
.2321	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2323	d0 21		bne $2346			bne 	_FMUseFloat
.2325	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2327	15 33		ora $33,x			ora 	NSStatus+1,x
.2329	29 80		and #$80			and 	#$80
.232b	15 62		ora $62,x			ora 	NSMantissa3,x
.232d	15 56		ora $56,x			ora 	NSMantissa2,x
.232f	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2331	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2333	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2335	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2337	d0 04		bne $233d			bne 	_FMInt32
.2339	20 f8 22	jsr $22f8			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.233c	60		rts				rts
.233d					_FMInt32:
.233d	20 67 23	jsr $2367			jsr 	FloatMultiplyShort			; use the int32 one.
.2340	18		clc				clc 								; fix it up if gone out of range
.2341	75 6e		adc $6e,x			adc 	NSExponent,x
.2343	95 6e		sta $6e,x			sta 	NSExponent,x
.2345	60		rts				rts
.2346					_FMUseFloat:
.2346	20 af 23	jsr $23af			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2349	f0 18		beq $2363			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.234b	e8		inx				inx
.234c	20 af 23	jsr $23af			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.234f	ca		dex				dex
.2350	c9 00		cmp #$00			cmp 	#0
.2352	f0 0c		beq $2360			beq 	_FDSetZero
.2354	20 67 23	jsr $2367			jsr 	FloatMultiplyShort 			; calculate the result.
.2357	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2359	18		clc				clc
.235a	75 6f		adc $6f,x			adc 	NSExponent+1,x
.235c	95 6e		sta $6e,x			sta 	NSExponent,x
.235e	80 03		bra $2363			bra 	_FDExit
.2360					_FDSetZero:
.2360	20 5a 26	jsr $265a			jsr 	FloatSetZero 				; return 0
.2363					_FDExit:
.2363	20 af 23	jsr $23af			jsr 	FloatNormalise 				; normalise the result
.2366	60		rts				rts
.2367					FloatMultiplyShort:
.2367	5a		phy				phy 								; save Y
.2368	20 3d 26	jsr $263d			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.236b	20 56 26	jsr $2656			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.236e	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2370					_I32MLoop:
.2370	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2372	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.2374	15 58		ora $58,x			ora 	NSMantissa2+2,x
.2376	15 64		ora $64,x			ora 	NSMantissa3+2,x
.2378	f0 25		beq $239f			beq 	_I32MExit 					; exit if zero
.237a	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.237c	29 01		and #$01			and 	#1
.237e	f0 0d		beq $238d			beq 	_I32MNoAdd
.2380	20 e6 23	jsr $23e6			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.2383	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.2385	10 06		bpl $238d			bpl 	_I32MNoAdd
.2387					_I32ShiftRight:
.2387	20 73 26	jsr $2673			jsr 	FloatShiftRight 			; shift S[X] right
.238a	c8		iny				iny 								; increment shift count
.238b	80 09		bra $2396			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.238d					_I32MNoAdd:
.238d	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.238f	70 f6		bvs $2387			bvs 	_I32ShiftRight 				; instead.
.2391	e8		inx				inx
.2392	20 69 26	jsr $2669			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.2395	ca		dex				dex
.2396					_I32MShiftUpper:
.2396	e8		inx				inx 								; shift S[X+2] right
.2397	e8		inx				inx
.2398	20 73 26	jsr $2673			jsr 	FloatShiftRight
.239b	ca		dex				dex
.239c	ca		dex				dex
.239d	80 d1		bra $2370			bra 	_I32MLoop 					; try again.
.239f					_I32MExit:
.239f	20 a5 23	jsr $23a5			jsr 	FloatCalculateSign
.23a2	98		tya				tya 								; shift in A
.23a3	7a		ply				ply 								; restore Y and exit
.23a4	60		rts				rts
.23a5					FloatCalculateSign:
.23a5	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23a7	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23a9	55 33		eor $33,x			eor 	NSStatus+1,x
.23ab	0a		asl a				asl 	a 							; shift bit 7 into carry
.23ac	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23ae	60		rts				rts
.23af					FloatNormalise:
.23af	20 7c 26	jsr $267c			jsr 	FloatIsZero 				; if zero exit
.23b2	d0 07		bne $23bb			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23b4	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.23b6	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.23b8	a9 00		lda #$00			lda 	#0 							; set Z flag
.23ba	60		rts				rts
.23bb					_NSNormaliseOptimise:
.23bb	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23bd	d0 19		bne $23d8			bne 	_NSNormaliseLoop
.23bf	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.23c1	30 15		bmi $23d8			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23c3	95 62		sta $62,x			sta 	NSMantissa3,x
.23c5	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.23c7	95 56		sta $56,x			sta 	NSMantissa2,x
.23c9	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.23cb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23cd	74 3e		stz $3e,x			stz 	NSMantissa0,x
.23cf	b5 6e		lda $6e,x			lda 	NSExponent,x
.23d1	38		sec				sec
.23d2	e9 08		sbc #$08			sbc 	#8
.23d4	95 6e		sta $6e,x			sta 	NSExponent,x
.23d6	80 e3		bra $23bb			bra 	_NSNormaliseOptimise
.23d8					_NSNormaliseLoop:
.23d8	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23da	70 07		bvs $23e3			bvs 	_NSNExit 					; exit if so with Z flag clear
.23dc	20 69 26	jsr $2669			jsr 	FloatShiftLeft 				; shift mantissa left
.23df	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23e1	80 f5		bra $23d8			bra 	_NSNormaliseLoop
.23e3					_NSNExit:
.23e3	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23e5	60		rts				rts
.23e6					FloatAddTopTwoStack:
.23e6	18		clc				clc
.23e7	b5 3e		lda $3e,x			lda		NSMantissa0,x
.23e9	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.23eb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.23ed	b5 4a		lda $4a,x			lda		NSMantissa1,x
.23ef	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.23f1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23f3	b5 56		lda $56,x			lda		NSMantissa2,x
.23f5	75 57		adc $57,x			adc 		NSMantissa2+1,x
.23f7	95 56		sta $56,x			sta 	NSMantissa2,x
.23f9	b5 62		lda $62,x			lda		NSMantissa3,x
.23fb	75 63		adc $63,x			adc 		NSMantissa3+1,x
.23fd	95 62		sta $62,x			sta 	NSMantissa3,x
.23ff	60		rts				rts
.2400					FloatSubTopTwoStack:
.2400	38		sec				sec
.2401	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2403	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.2405	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2407	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2409	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.240b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.240d	b5 56		lda $56,x			lda		NSMantissa2,x
.240f	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.2411	95 56		sta $56,x			sta 	NSMantissa2,x
.2413	b5 62		lda $62,x			lda		NSMantissa3,x
.2415	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.2417	95 62		sta $62,x			sta 	NSMantissa3,x
.2419	60		rts				rts
.241a					FloatInt32Add:
.241a	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.241c	55 33		eor $33,x			eor 	NSStatus+1,x
.241e	30 04		bmi $2424			bmi 	_DiffSigns
.2420	20 e6 23	jsr $23e6			jsr		FloatAddTopTwoStack
.2423	60		rts				rts
.2424					_DiffSigns:
.2424	20 00 24	jsr $2400			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2427	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2429	10 07		bpl $2432			bpl 	_AddExit
.242b	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.242d	95 32		sta $32,x			sta 	NSStatus,x
.242f	20 23 26	jsr $2623			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2432					_AddExit:
.2432	20 7c 26	jsr $267c			jsr 	FloatIsZero 				; check for -0
.2435	d0 02		bne $2439			bne 	_AddNonZero
.2437	74 32		stz $32,x			stz 	NSStatus,x
.2439					_AddNonZero:
.2439	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.243a					FloatEncodeStart:
.243a	38		sec				sec
.243b	80 01		bra $243e			bra 	FloatEncodeContinue+1
.243d					FloatEncodeContinue:
.243d	18		clc				clc
.243e					FloatEncode:
.243e	08		php				php 								; save reset flag.
.243f	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2441	f0 15		beq $2458			beq 	_ENIsOkay
.2443	c9 30		cmp #$30			cmp 	#"0"
.2445	90 04		bcc $244b			bcc 	_ENBadNumber
.2447	c9 3a		cmp #$3a			cmp 	#"9"+1
.2449	90 0d		bcc $2458			bcc 	_ENIsOkay
.244b					_ENBadNumber:
.244b	28		plp				plp 								; throw saved reset
.244c	ad 91 05	lda $0591			lda 	encodeState 				; if in decimal mode, construct final number
.244f	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2451	d0 03		bne $2456			bne 	_ENFail
.2453	4c d0 24	jmp $24d0			jmp 	_ENConstructFinal
.2456					_ENFail:
.2456	18		clc				clc 								; not allowed
.2457	60		rts				rts
.2458					_ENIsOkay:
.2458	28		plp				plp 								; are we restarting
.2459	90 15		bcc $2470			bcc 	_ENNoRestart
.245b					_ENStartEncode:
.245b	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.245d	f0 0c		beq $246b			beq 	_ENFirstDP
.245f	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2461	20 5c 26	jsr $265c			jsr 	FloatSetByte 				; in single byte mode.
.2464	a9 01		lda #$01			lda 	#ESTA_Low
.2466					_ENExitChange:
.2466	8d 91 05	sta $0591			sta 	encodeState 				; save new state
.2469	38		sec				sec
.246a	60		rts				rts
.246b					_ENFirstDP:
.246b	20 5a 26	jsr $265a			jsr 	FloatSetZero 				; clear integer part
.246e	80 3c		bra $24ac			bra 	_ESTASwitchFloat			; go straight to float and exi
.2470					_ENNoRestart:
.2470	48		pha				pha 								; save digit or DP on stack.
.2471	ad 91 05	lda $0591			lda 	encodeState 				; get current state
.2474	c9 01		cmp #$01			cmp 	#ESTA_Low
.2476	f0 09		beq $2481			beq  	_ESTALowState
.2478	c9 02		cmp #$02			cmp 	#ESTA_High
.247a	f0 26		beq $24a2			beq 	_ESTAHighState
.247c	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.247e	f0 38		beq $24b8			beq 	_ESTADecimalState
>2480	db						.byte 	$DB 						; causes a break in the emulator
.2481					_ESTALowState:
.2481	68		pla				pla 								; get value back
.2482	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.2484	f0 26		beq $24ac			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.2486	29 0f		and #$0f			and 	#15 						; make digit
.2488	8d 92 05	sta $0592			sta 	digitTemp 					; save it.
.248b	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.248d	0a		asl a				asl 	a
.248e	0a		asl a				asl 	a
.248f	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2491	0a		asl a				asl 	a
.2492	6d 92 05	adc $0592			adc 	digitTemp
.2495	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2497	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.2499	90 05		bcc $24a0			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.249b	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.249d	8d 91 05	sta $0591			sta 	encodeState
.24a0					_ESTANoSwitch:
.24a0	38		sec				sec
.24a1	60		rts				rts
.24a2					_ESTAHighState:
.24a2	68		pla				pla 								; get value back
.24a3	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24a5	f0 05		beq $24ac			beq 	_ESTASwitchFloat
.24a7	20 02 25	jsr $2502			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24aa	38		sec				sec
.24ab	60		rts				rts
.24ac					_ESTASwitchFloat:
.24ac	9c 93 05	stz $0593			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24af	e8		inx				inx 								; zero the decimal additive.
.24b0	20 5a 26	jsr $265a			jsr 	FloatSetZero
.24b3	ca		dex				dex
.24b4	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24b6	80 ae		bra $2466			bra 	_ENExitChange
.24b8					_ESTADecimalState:
.24b8	68		pla				pla 								; digit.
.24b9	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24bb	f0 99		beq $2456			beq 	_ENFail
.24bd	e8		inx				inx 								; put digit into fractional part of X+1
.24be	20 02 25	jsr $2502			jsr 	ESTAShiftDigitIntoMantissa
.24c1	ca		dex				dex
.24c2	ee 93 05	inc $0593			inc 	decimalCount 				; bump the count of decimals
.24c5	ad 93 05	lda $0593			lda 	decimalCount 				; too many decimal digits.
.24c8	c9 0b		cmp #$0b			cmp 	#11
.24ca	f0 02		beq $24ce			beq 	_ESTADSFail
.24cc	38		sec				sec
.24cd	60		rts				rts
.24ce					_ESTADSFail:
.24ce	18		clc				clc
.24cf	60		rts				rts
.24d0					_ENConstructFinal:
.24d0	ad 93 05	lda $0593			lda 	decimalCount 				; get decimal count
.24d3	f0 2b		beq $2500			beq 	_ENCFExit 					; no decimals
.24d5	5a		phy				phy
.24d6	0a		asl a				asl 	a 							; x 4 and CLC
.24d7	0a		asl a				asl 	a
.24d8	6d 93 05	adc $0593			adc 	decimalCount
.24db	a8		tay				tay
.24dc	b9 67 21	lda $2167,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24df	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24e1	b9 68 21	lda $2168,y			lda 	FloatScalarTable-5+1,y
.24e4	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.24e6	b9 69 21	lda $2169,y			lda 	FloatScalarTable-5+2,y
.24e9	95 58		sta $58,x			sta 	NSMantissa2+2,x
.24eb	b9 6a 21	lda $216a,y			lda 	FloatScalarTable-5+3,y
.24ee	95 64		sta $64,x			sta 	NSMantissa3+2,x
.24f0	b9 6b 21	lda $216b,y			lda 	FloatScalarTable-5+4,y
.24f3	95 70		sta $70,x			sta 	NSExponent+2,x
.24f5	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.24f7	e8		inx				inx 								; multiply decimal const by decimal scalar
.24f8	e8		inx				inx
.24f9	20 1a 23	jsr $231a			jsr 	FloatMultiply
.24fc	20 7e 20	jsr $207e			jsr 	FloatAdd 					; add to integer part.
.24ff	7a		ply				ply
.2500					_ENCFExit:
.2500	18		clc				clc 								; reject the digit.
.2501	60		rts				rts
.2502					ESTAShiftDigitIntoMantissa:
.2502	29 0f		and #$0f			and 	#15 						; save digit
.2504	48		pha				pha
.2505	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2507	48		pha				pha
.2508	b5 56		lda $56,x			lda 	NSMantissa2,x
.250a	48		pha				pha
.250b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.250d	48		pha				pha
.250e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2510	48		pha				pha
.2511	20 69 26	jsr $2669			jsr 	FloatShiftLeft 				; x 2
.2514	20 69 26	jsr $2669			jsr 	FloatShiftLeft 				; x 4
.2517	18		clc				clc 								; pop mantissa and add
.2518	68		pla				pla
.2519	75 3e		adc $3e,x			adc 	NSMantissa0,x
.251b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.251d	68		pla				pla
.251e	75 4a		adc $4a,x			adc 	NSMantissa1,x
.2520	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2522	68		pla				pla
.2523	75 56		adc $56,x			adc 	NSMantissa2,x
.2525	95 56		sta $56,x			sta 	NSMantissa2,x
.2527	68		pla				pla
.2528	75 62		adc $62,x			adc 	NSMantissa3,x
.252a	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.252c	20 69 26	jsr $2669			jsr 	FloatShiftLeft 				; x 10
.252f	68		pla				pla 								; add digit
.2530	18		clc				clc
.2531	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2533	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2535	90 0a		bcc $2541			bcc 	_ESTASDExit
.2537	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2539	d0 06		bne $2541			bne 	_ESTASDExit
.253b	f6 56		inc $56,x			inc 	NSMantissa2,x
.253d	d0 02		bne $2541			bne 	_ESTASDExit
.253f	f6 62		inc $62,x			inc 	NSMantissa3,x
.2541					_ESTASDExit:
.2541	60		rts				rts
.0591					encodeState:
>0591							.fill 	1
.0592					digitTemp:
>0592							.fill 	1
.0593					decimalCount:
>0593							.fill 	1
.2542					FloatToString:
.2542	da		phx				phx
.2543	5a		phy				phy 								; save code position
.2544	8d 94 05	sta $0594			sta 	decimalPlaces	 			; save number of DPs.
.2547	9c 95 05	stz $0595			stz 	dbOffset 					; offset into decimal buffer = start.
.254a	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.254c	10 08		bpl $2556			bpl 	_CNTSNotNegative
.254e	29 7f		and #$7f			and 	#$7F 						; make +ve
.2550	95 32		sta $32,x			sta 	NSStatus,x
.2552	a9 2d		lda #$2d			lda 	#"-"
.2554	80 02		bra $2558			bra 	_CNTMain
.2556					_CNTSNotNegative:
.2556	a9 20		lda #$20			lda 	#" "
.2558					_CNTMain:
.2558	20 ba 25	jsr $25ba			jsr 	WriteDecimalBuffer
.255b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.255d	f0 0d		beq $256c			beq 	_CNTSNotFloat
.255f	e8		inx				inx 								; round up so we don't get too many 6.999999
.2560	a9 01		lda #$01			lda 	#1
.2562	20 5c 26	jsr $265c			jsr 	FloatSetByte
.2565	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2567	95 6e		sta $6e,x			sta 	NSExponent,x
.2569	20 7e 20	jsr $207e			jsr 	FloatAdd
.256c					_CNTSNotFloat:
.256c	20 9c 25	jsr $259c			jsr 	MakePlusTwoString 			; do the integer part.
.256f	20 3a 22	jsr $223a			jsr 	FloatFractionalPart 		; get the fractional part
.2572	20 af 23	jsr $23af			jsr 	FloatNormalise					; normalise , exit if zero
.2575	f0 22		beq $2599			beq 	_CNTSExit
.2577	a9 2e		lda #$2e			lda 	#"."
.2579	20 ba 25	jsr $25ba			jsr 	WriteDecimalBuffer 			; write decimal place
.257c					_CNTSDecimal:
.257c	ce 94 05	dec $0594			dec 	decimalPlaces 				; done all the decimals
.257f	30 18		bmi $2599			bmi 	_CNTSExit
.2581	e8		inx				inx 								; x 10.0
.2582	a9 0a		lda #$0a			lda 	#10
.2584	20 5c 26	jsr $265c			jsr 	FloatSetByte
.2587	20 1a 23	jsr $231a			jsr 	FloatMultiply
.258a	20 9c 25	jsr $259c			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.258d	20 3a 22	jsr $223a			jsr 	FloatFractionalPart 		; get the fractional part
.2590	20 af 23	jsr $23af			jsr 	FloatNormalise 				; normalise it.
.2593	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.2595	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.2597	b0 e3		bcs $257c			bcs 	_CNTSDecimal 				; keep going.
.2599					_CNTSExit:
.2599	7a		ply				ply
.259a	fa		plx				plx
.259b	60		rts				rts
.259c					MakePlusTwoString:
.259c	da		phx				phx
.259d	20 3d 26	jsr $263d			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25a0	e8		inx				inx 								; access it
.25a1	e8		inx				inx
.25a2	20 95 22	jsr $2295			jsr 	FloatIntegerPart 			; make it an integer
.25a5	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25a7	20 d9 25	jsr $25d9			jsr 	ConvertInt32
.25aa	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25ac					_MPTSCopy:
.25ac	bd 6f 05	lda $056f,x			lda 	numberBuffer,x
.25af	20 ba 25	jsr $25ba			jsr 	WriteDecimalBuffer
.25b2	e8		inx				inx
.25b3	bd 6f 05	lda $056f,x			lda 	numberBuffer,x
.25b6	d0 f4		bne $25ac			bne 	_MPTSCopy
.25b8	fa		plx				plx
.25b9	60		rts				rts
.25ba					WriteDecimalBuffer:
.25ba	da		phx				phx
.25bb	ae 95 05	ldx $0595			ldx 	dbOffset
.25be	9d 96 05	sta $0596,x			sta 	decimalBuffer,x
.25c1	9e 97 05	stz $0597,x			stz 	decimalBuffer+1,x
.25c4	ee 95 05	inc $0595			inc 	dbOffset
.25c7	fa		plx				plx
.25c8	60		rts				rts
.0594					decimalPlaces:
>0594							.fill 	1
.0595					dbOffset:
>0595							.fill 	1
.0596					decimalBuffer:
>0596							.fill 	32
.25c9					ConvertInt16:
.25c9	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.25cb	86 4a		stx $4a				stx 	NSMantissa1
.25cd	64 56		stz $56				stz 	NSMantissa2
.25cf	64 62		stz $62				stz 	NSMantissa3
.25d1	64 32		stz $32				stz 	NSStatus 					; positive integer
.25d3	a2 00		ldx #$00			ldx 	#0 							; stack level
.25d5	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25d7	80 00		bra $25d9			bra 	ConvertInt32
.25d9					ConvertInt32:
.25d9	5a		phy				phy
.25da	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25dc	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25de	10 08		bpl $25e8			bpl 	_CI32NotNeg
.25e0	48		pha				pha
.25e1	a9 2d		lda #$2d			lda 	#'-'
.25e3	99 6f 05	sta $056f,y			sta 	numberBuffer,y
.25e6	c8		iny				iny
.25e7	68		pla				pla
.25e8					_CI32NotNeg:
.25e8	20 f6 25	jsr $25f6			jsr 	_CI32DivideConvert 			; recursive conversion
.25eb	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.25ed	99 6f 05	sta $056f,y			sta 	numberBuffer,y
.25f0	7a		ply				ply
.25f1	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.25f3	a9 6f		lda #$6f			lda 	#numberBuffer & $FF
.25f5	60		rts				rts
.25f6					_CI32DivideConvert:
.25f6	e8		inx				inx 								; write to next slot up
.25f7	20 5c 26	jsr $265c			jsr 	FloatSetByte 		 		; write the base out.
.25fa	ca		dex				dex
.25fb	20 f0 21	jsr $21f0			jsr 	Int32Divide 				; divide
.25fe	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.2600	48		pha				pha
.2601	20 df 21	jsr $21df			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2604	20 7c 26	jsr $267c			jsr 	FloatIsZero 				; is it zero ?
.2607	f0 05		beq $260e			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2609	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.260b	20 f6 25	jsr $25f6			jsr 	_CI32DivideConvert 			; and recusrively call.
.260e					_CI32NoRecurse:
.260e	68		pla				pla 								; remainder
.260f	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.2611	90 02		bcc $2615			bcc 	_CI32NotHex
.2613	69 26		adc #$26			adc 	#6+32
.2615					_CI32NotHex:
.2615	69 30		adc #$30			adc 	#48
.2617	99 6f 05	sta $056f,y			sta 	numberBuffer,y 				; write out and exit
.261a	c8		iny				iny
.261b	60		rts				rts
.261c					FloatNegate:
.261c	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.261e	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2620	95 32		sta $32,x			sta 	NSStatus,x
.2622	60		rts				rts
.2623					FloatNegateMantissa:
.2623	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2624	a9 00		lda #$00			lda 	#0
.2626	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2628	95 3e		sta $3e,x			sta 	NSMantissa0,x
.262a	a9 00		lda #$00			lda 	#0
.262c	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.262e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2630	a9 00		lda #$00			lda 	#0
.2632	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.2634	95 56		sta $56,x			sta 	NSMantissa2,x
.2636	a9 00		lda #$00			lda 	#0
.2638	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.263a	95 62		sta $62,x			sta 	NSMantissa3,x
.263c	60		rts				rts
.263d					FloatShiftUpTwo:
.263d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.263f	95 40		sta $40,x			sta 	NSMantissa0+2,x
.2641	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2643	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2645	b5 56		lda $56,x			lda 	NSMantissa2,x
.2647	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2649	b5 62		lda $62,x			lda 	NSMantissa3,x
.264b	95 64		sta $64,x			sta 	NSMantissa3+2,x
.264d	b5 6e		lda $6e,x			lda 	NSExponent,x
.264f	95 70		sta $70,x			sta 	NSExponent+2,x
.2651	b5 32		lda $32,x			lda 	NSStatus,x
.2653	95 34		sta $34,x			sta 	NSStatus+2,x
.2655	60		rts				rts
.2656					FloatSetZeroMantissaOnly:
.2656	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2658	80 08		bra $2662			bra 	FloatZero13
.265a					FloatSetZero:
.265a	a9 00		lda #$00			lda 	#0
.265c					FloatSetByte:
.265c	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.265e					FloatSetMantissa:
.265e	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.2660	74 32		stz $32,x			stz 	NSStatus,x
.2662					FloatZero13:
.2662	74 4a		stz $4a,x			stz 	NSMantissa1,x
.2664	74 56		stz $56,x			stz 	NSMantissa2,x
.2666	74 62		stz $62,x			stz 	NSMantissa3,x
.2668	60		rts				rts
.2669					FloatShiftLeft:
.2669	18		clc				clc
.266a					FloatRotateLeft:
.266a	36 3e		rol $3e,x			rol 	NSMantissa0,x
.266c	36 4a		rol $4a,x			rol		NSMantissa1,x
.266e	36 56		rol $56,x			rol		NSMantissa2,x
.2670	36 62		rol $62,x			rol		NSMantissa3,x
.2672	60		rts				rts
.2673					FloatShiftRight:
.2673	56 62		lsr $62,x			lsr 	NSMantissa3,x
.2675	76 56		ror $56,x			ror		NSMantissa2,x
.2677	76 4a		ror $4a,x			ror		NSMantissa1,x
.2679	76 3e		ror $3e,x			ror		NSMantissa0,x
.267b	60		rts				rts
.267c					FloatIsZero:
.267c	b5 62		lda $62,x			lda 	NSMantissa3,x
.267e	15 56		ora $56,x			ora		NSMantissa2,x
.2680	15 4a		ora $4a,x			ora		NSMantissa1,x
.2682	15 3e		ora $3e,x			ora		NSMantissa0,x
.2684	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.2685					FloatArcTan:
.2685	20 af 23	jsr $23af			jsr 	FloatNormalise 					; normalise x
.2688	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.268a	48		pha				pha
.268b	74 32		stz $32,x			stz 	NSStatus,x
.268d	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.268f	c9 e2		cmp #$e2			cmp 	#$E2
.2691	90 25		bcc $26b8			bcc 	_UANoFixup
.2693	8a		txa				txa 									; value in +1
.2694	a8		tay				tay
.2695	c8		iny				iny
.2696	20 3e 28	jsr $283e			jsr 	CopyFloatXY
.2699	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.269b	20 5c 26	jsr $265c			jsr 	FloatSetByte
.269e	e8		inx				inx
.269f	20 a3 21	jsr $21a3			jsr 	FloatDivide
.26a2	b0 21		bcs $26c5			bcs 	_FATError
.26a4	20 c8 26	jsr $26c8			jsr 	CoreAtn 						; calculate the root
.26a7	20 33 28	jsr $2833			jsr 	CompletePolynomial
.26aa	20 1c 26	jsr $261c			jsr 	FloatNegate 					; make -ve
.26ad	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.26af	20 8a 28	jsr $288a			jsr 	LoadConstant
.26b2	e8		inx				inx
.26b3	20 7e 20	jsr $207e			jsr 	FloatAdd
.26b6	80 06		bra $26be			bra 	_UAComplete
.26b8					_UANoFixup:
.26b8	20 c8 26	jsr $26c8			jsr 	CoreAtn
.26bb	20 33 28	jsr $2833			jsr 	CompletePolynomial
.26be					_UAComplete:
.26be	68		pla				pla 									; apply the result.
.26bf	55 32		eor $32,x			eor 	NSStatus,x
.26c1	95 32		sta $32,x			sta 	NSStatus,x
.26c3	18		clc				clc
.26c4	60		rts				rts
.26c5					_FATError:
.26c5	68		pla				pla
.26c6	38		sec				sec
.26c7	60		rts				rts
.26c8					CoreAtn:
.26c8	a9 36		lda #$36			lda 	#AtnCoefficients & $FF
.26ca	a0 27		ldy #$27			ldy 	#AtnCoefficients >> 8
.26cc	4c 87 29	jmp $2987			jmp 	CorePolySquared
.26cf					ExpCoefficients:
>26cf	07					.byte	7
>26d0	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>26d4	d2					.byte	$d2
>26d5	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>26d9	d5					.byte	$d5
>26da	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>26de	d8					.byte	$d8
>26df	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>26e3	db					.byte	$db
>26e4	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>26e8	dd					.byte	$dd
>26e9	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>26ed	df					.byte	$df
>26ee	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>26f2	e1					.byte	$e1
>26f3	00 00 00 40				.dword	$40000000 ; 1.0
>26f7	e2					.byte	$e2
.26f8					SinCoefficients:
>26f8	06					.byte	6
>26f9	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>26fd	e5					.byte	$e5
>26fe	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>2702	e7					.byte	$e7
>2703	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>2707	e8					.byte	$e8
>2708	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>270c	e8					.byte	$e8
>270d	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>2711	e7					.byte	$e7
>2712	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>2716	e4					.byte	$e4
>2717	00 00 00 00				.dword	$00000000 ; 0.0
>271b	00					.byte	$00
.271c					LogCoefficients:
>271c	04					.byte	4
>271d	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>2721	e0					.byte	$e0
>2722	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>2726	e1					.byte	$e1
>2727	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>272b	e1					.byte	$e1
>272c	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>2730	e3					.byte	$e3
>2731	00 00 00 c0				.dword	$c0000000 ; -0.5
>2735	e1					.byte	$e1
.2736					AtnCoefficients:
>2736	0c					.byte	12
>2737	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>273b	d7					.byte	$d7
>273c	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>2740	da					.byte	$da
>2741	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>2745	dc					.byte	$dc
>2746	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>274a	dd					.byte	$dd
>274b	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>274f	dd					.byte	$dd
>2750	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>2754	de					.byte	$de
>2755	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2759	de					.byte	$de
>275a	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>275e	de					.byte	$de
>275f	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>2763	df					.byte	$df
>2764	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>2768	df					.byte	$df
>2769	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>276d	e0					.byte	$e0
>276e	00 00 00 40				.dword	$40000000 ; 1.0
>2772	e2					.byte	$e2
>2773	00 00 00 00				.dword	$00000000 ; 0.0
>2777	00					.byte	$00
.2778					Const_Base:
.2778					Const_1Div2Pi:
>2778	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>277c	df					.byte	$df
.277d					Const_PiDiv2:
>277d	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>2781	e2					.byte	$e2
.2782					Const_Log2_e:
>2782	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>2786	e2					.byte	$e2
.2787					Const_sqrt_2:
>2787	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>278b	e2					.byte	$e2
.278c					Const_sqrt_half:
>278c	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>2790	e1					.byte	$e1
.2791					Const_pi:
>2791	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>2795	e3					.byte	$e3
.2796					Const_half:
>2796	00 00 00 40				.dword	$40000000 ; 0.50000000
>279a	e1					.byte	$e1
.279b					Const_ln_e:
>279b	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>279f	e1					.byte	$e1
.27a0					FloatCosine:
.27a0	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.27a2	20 8a 28	jsr $288a			jsr 	LoadConstant
.27a5	e8		inx				inx
.27a6	20 7e 20	jsr $207e			jsr 	FloatAdd
.27a9	4c 40 29	jmp $2940			jmp 	FloatSine
.27ac					FloatExponent:
.27ac	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.27ae	20 8a 28	jsr $288a			jsr 	LoadConstant
.27b1	e8		inx				inx
.27b2	20 1a 23	jsr $231a			jsr 	FloatMultiply
.27b5	20 f7 27	jsr $27f7			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.27b8	e8		inx				inx
.27b9	20 95 22	jsr $2295			jsr 	FloatIntegerPart
.27bc	ca		dex				dex
.27bd	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.27bf	15 57		ora $57,x			ora 	NSMantissa2+1,x
.27c1	15 63		ora $63,x			ora 	NSMantissa3+1,x
.27c3	d0 38		bne $27fd			bne 	_UERangeError
.27c5	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.27c7	c9 40		cmp #$40			cmp 	#64
.27c9	b0 32		bcs $27fd			bcs 	_UERangeError
.27cb	48		pha				pha
.27cc	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.27ce	48		pha				pha
.27cf	20 3a 22	jsr $223a			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.27d2	68		pla				pla
.27d3	10 14		bpl $27e9			bpl 	_UEPositive
.27d5	e8		inx				inx 							; 1-x
.27d6	a9 01		lda #$01			lda 	#1
.27d8	20 5c 26	jsr $265c			jsr 	FloatSetByte
.27db	ca		dex				dex
.27dc	20 1c 26	jsr $261c			jsr 	FloatNegate
.27df	e8		inx				inx
.27e0	20 7e 20	jsr $207e			jsr 	FloatAdd
.27e3	68		pla				pla 							; integer part +1 and negated.
.27e4	1a		inc a				inc 	a
.27e5	49 ff		eor #$ff			eor 	#$FF
.27e7	1a		inc a				inc 	a
.27e8	48		pha				pha
.27e9					_UEPositive:
.27e9	20 ff 27	jsr $27ff			jsr 	CoreExponent
.27ec	20 33 28	jsr $2833			jsr 	CompletePolynomial
.27ef	68		pla				pla
.27f0	18		clc				clc
.27f1	75 6e		adc $6e,x			adc 	NSExponent,x
.27f3	95 6e		sta $6e,x			sta 	NSExponent,x
.27f5	18		clc				clc
.27f6	60		rts				rts
.27f7					_UECopy01:
.27f7	8a		txa				txa
.27f8	a8		tay				tay
.27f9	c8		iny				iny
.27fa	4c 3e 28	jmp $283e			jmp 	CopyFloatXY
.27fd					_UERangeError:
.27fd	38		sec				sec
.27fe	60		rts				rts
.27ff					CoreExponent:
.27ff	a9 cf		lda #$cf			lda 	#ExpCoefficients & $FF
.2801	a0 26		ldy #$26			ldy 	#ExpCoefficients >> 8
.2803	20 07 28	jsr $2807			jsr 	CalculateHornerPolynomial
.2806	60		rts				rts
.2807					CalculateHornerPolynomial:
.2807	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.2809	84 2d		sty $2d				sty 	zTemp0+1
.280b	9c b6 05	stz $05b6			stz 	coefficientCount 			; zero the count.
.280e	8e b7 05	stx $05b7			stx 	xValueSlot 					; save xValue slot.
.2811	e8		inx				inx 								; set the count to zero.
.2812	20 5a 26	jsr $265a			jsr 	FloatSetZero
.2815					_CHPLoop:
.2815	8a		txa				txa 								; copy X-1 to X+1
.2816	a8		tay				tay
.2817	ca		dex				dex
.2818	c8		iny				iny
.2819	20 3e 28	jsr $283e			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.281c	e8		inx				inx
.281d	e8		inx				inx
.281e	20 1a 23	jsr $231a			jsr 	FloatMultiply 				; times current by X
.2821	e8		inx				inx
.2822	20 5d 28	jsr $285d			jsr 	GetCoefficient 				; coefficient into X+1
.2825	20 7e 20	jsr $207e			jsr 	FloatAdd 					; and add
.2828	ee b6 05	inc $05b6			inc 	coefficientCount
.282b	ad b6 05	lda $05b6			lda 	coefficientCount
.282e	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.2830	d0 e3		bne $2815			bne 	_CHPLoop
.2832	60		rts				rts
.2833					CompletePolynomial:
.2833	20 1a 23	jsr $231a			jsr 	FloatMultiply
.2836	e8		inx				inx 								; get the last value
.2837	20 5d 28	jsr $285d			jsr 	GetCoefficient
.283a	20 7e 20	jsr $207e			jsr 	FloatAdd 					; and add it
.283d	60		rts				rts
.283e					CopyFloatXY:
.283e	b5 6e		lda $6e,x			lda 	NSExponent,x
.2840	99 6e 00	sta $006e,y			sta 	NSExponent,y
.2843	b5 32		lda $32,x			lda 	NSStatus,x
.2845	99 32 00	sta $0032,y			sta 	NSStatus,y
.2848	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.284a	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.284d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.284f	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.2852	b5 56		lda $56,x			lda 	NSMantissa2,x
.2854	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.2857	b5 62		lda $62,x			lda 	NSMantissa3,x
.2859	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.285c	60		rts				rts
.285d					GetCoefficient:
.285d	5a		phy				phy
.285e	ad b6 05	lda $05b6			lda 	coefficientCount 			; 5 per block
.2861	0a		asl a				asl 	a
.2862	0a		asl a				asl 	a
.2863	38		sec				sec 								; +1 for count
.2864	6d b6 05	adc $05b6			adc 	coefficientCount
.2867	a8		tay				tay
.2868	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.286a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.286c	c8		iny				iny
.286d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.286f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2871	c8		iny				iny
.2872	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2874	95 56		sta $56,x			sta 	NSMantissa2,x
.2876	c8		iny				iny
.2877	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2879	48		pha				pha
.287a	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.287c	95 62		sta $62,x			sta 	NSMantissa3,x
.287e	c8		iny				iny
.287f	68		pla				pla
.2880	29 80		and #$80			and 	#$80
.2882	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.2884	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2886	95 6e		sta $6e,x			sta 	NSExponent,x
.2888	7a		ply				ply
.2889	60		rts				rts
.05b6					coefficientCount:
>05b6							.fill 	1
.05b7					xValueSlot:
>05b7							.fill 	1
.288a					LoadConstant:
.288a	5a		phy				phy
.288b	a8		tay				tay
.288c	b9 78 27	lda $2778,y			lda 	Const_Base+0,y
.288f	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.2891	b9 79 27	lda $2779,y			lda 	Const_Base+1,y
.2894	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.2896	b9 7a 27	lda $277a,y			lda 	Const_Base+2,y
.2899	95 57		sta $57,x			sta 	NSMantissa2+1,x
.289b	b9 7b 27	lda $277b,y			lda 	Const_Base+3,y
.289e	48		pha				pha
.289f	29 7f		and #$7f			and 	#$7F
.28a1	95 63		sta $63,x			sta 	NSMantissa3+1,x
.28a3	68		pla				pla
.28a4	29 80		and #$80			and 	#$80
.28a6	95 33		sta $33,x			sta 	NSStatus+1,x
.28a8	b9 7c 27	lda $277c,y			lda 	Const_Base+4,y
.28ab	95 6f		sta $6f,x			sta 	NSExponent+1,x
.28ad	7a		ply				ply
.28ae	60		rts				rts
.28af					FloatLogarithm:
.28af	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.28b1	30 5f		bmi $2912			bmi 	_ULRange
.28b3	20 7c 26	jsr $267c			jsr 	FloatIsZero
.28b6	f0 5a		beq $2912			beq 	_ULRange
.28b8	20 af 23	jsr $23af			jsr 	FloatNormalise 				; put into FP mode.
.28bb	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.28bd	48		pha				pha
.28be	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.28c0	95 6e		sta $6e,x			sta 	NSExponent,x
.28c2	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.28c4	20 8a 28	jsr $288a			jsr 	LoadConstant
.28c7	e8		inx				inx
.28c8	20 7e 20	jsr $207e			jsr 	FloatAdd
.28cb	8a		txa				txa 								; divide into sqrt 2.0
.28cc	a8		tay				tay
.28cd	c8		iny				iny
.28ce	20 3e 28	jsr $283e			jsr 	CopyFloatXY
.28d1	ca		dex				dex
.28d2	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.28d4	20 8a 28	jsr $288a			jsr 	LoadConstant
.28d7	e8		inx				inx
.28d8	e8		inx				inx
.28d9	20 a3 21	jsr $21a3			jsr 	FloatDivide 				; if zero, error.
.28dc	b0 33		bcs $2911			bcs 	_ULRangePla
.28de	20 1c 26	jsr $261c			jsr 	FloatNegate 				; subtract from 1
.28e1	e8		inx				inx
.28e2	a9 01		lda #$01			lda 	#1
.28e4	20 5c 26	jsr $265c			jsr 	FloatSetByte
.28e7	20 7e 20	jsr $207e			jsr 	FloatAdd
.28ea	20 14 29	jsr $2914			jsr 	CoreLog
.28ed	20 33 28	jsr $2833			jsr 	CompletePolynomial
.28f0	68		pla				pla 								; add exponent
.28f1	18		clc				clc
.28f2	69 1f		adc #$1f			adc 	#31 						; fix up
.28f4	48		pha				pha
.28f5	10 03		bpl $28fa			bpl 	_LogNotNeg
.28f7	49 ff		eor #$ff			eor 	#$FF
.28f9	1a		inc a				inc 	a
.28fa					_LogNotNeg:
.28fa	e8		inx				inx 								; set byte and sign.
.28fb	20 5c 26	jsr $265c			jsr 	FloatSetByte
.28fe	68		pla				pla
.28ff	29 80		and #$80			and 	#$80
.2901	95 32		sta $32,x			sta 	NSStatus,x
.2903	20 7e 20	jsr $207e			jsr 	FloatAdd
.2906	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.2908	20 8a 28	jsr $288a			jsr 	LoadConstant
.290b	e8		inx				inx
.290c	20 1a 23	jsr $231a			jsr 	FloatMultiply
.290f	18		clc				clc
.2910	60		rts				rts
.2911					_ULRangePla:
.2911	68		pla				pla
.2912					_ULRange:
.2912	38		sec				sec
.2913	60		rts				rts
.2914					CoreLog:
.2914	a9 1c		lda #$1c			lda 	#LogCoefficients & $FF
.2916	a0 27		ldy #$27			ldy 	#LogCoefficients >> 8
.2918	4c 87 29	jmp $2987			jmp 	CorePolySquared
.291b					FloatPI:
.291b	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.291d	20 8a 28	jsr $288a			jsr 	LoadConstant
.2920	e8		inx				inx
.2921	18		clc				clc
.2922	60		rts				rts
.2923					FloatPower:
.2923	ca		dex				dex
.2924	8a		txa				txa 							; copy 0 to 2, so we can process it
.2925	a8		tay				tay
.2926	c8		iny				iny
.2927	c8		iny				iny
.2928	20 3e 28	jsr $283e			jsr 	CopyFloatXY
.292b	e8		inx				inx 							; 2 = Log(0)
.292c	e8		inx				inx
.292d	20 af 28	jsr $28af			jsr 	FloatLogarithm
.2930	b0 0d		bcs $293f			bcs 	_FPWExit
.2932	20 1a 23	jsr $231a			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.2935	8a		txa				txa 							; copy to slot 0
.2936	a8		tay				tay
.2937	88		dey				dey
.2938	20 3e 28	jsr $283e			jsr 	CopyFloatXY
.293b	ca		dex				dex  							; Exponent code.
.293c	20 ac 27	jsr $27ac			jsr 	FloatExponent
.293f					_FPWExit:
.293f	60		rts				rts
.2940					FloatSine:
.2940	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.2942	48		pha				pha
.2943	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.2945	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.2947	20 8a 28	jsr $288a			jsr 	LoadConstant
.294a	e8		inx				inx
.294b	20 1a 23	jsr $231a			jsr 	FloatMultiply
.294e	20 3a 22	jsr $223a			jsr 	FloatFractionalPart 		; take the fractional part
.2951	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.2953	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.2955	90 1f		bcc $2976			bcc 	_USProcessExit
.2957	f0 06		beq $295f			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.2959	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.295b	c9 60		cmp #$60			cmp 	#$60
.295d	b0 0e		bcs $296d			bcs 	_USSubtractOne
.295f					_USSubtractFromHalf:
.295f	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.2961	20 8a 28	jsr $288a			jsr 	LoadConstant
.2964	e8		inx				inx
.2965	20 78 20	jsr $2078			jsr 	FloatSubtract
.2968	20 1c 26	jsr $261c			jsr 	FloatNegate 				; then negate it
.296b	80 09		bra $2976			bra 	_USProcessExit 				; and exit
.296d					_USSubtractOne:
.296d	e8		inx				inx
.296e	a9 01		lda #$01			lda 	#1
.2970	20 5c 26	jsr $265c			jsr 	FloatSetByte
.2973	20 78 20	jsr $2078			jsr 	FloatSubtract
.2976					_USProcessExit:
.2976	20 83 29	jsr $2983			jsr 	CoreSine
.2979	20 33 28	jsr $2833			jsr 	CompletePolynomial
.297c	68		pla				pla 								; restore sign and apply
.297d	55 32		eor $32,x			eor 	NSStatus,x
.297f	95 32		sta $32,x			sta 	NSStatus,x
.2981	18		clc				clc
.2982	60		rts				rts
.2983					CoreSine:
.2983	a9 f8		lda #$f8			lda 	#SinCoefficients & $FF
.2985	a0 26		ldy #$26			ldy 	#SinCoefficients >> 8
.2987					CorePolySquared:
.2987	48		pha				pha 								; save coefficient table
.2988	5a		phy				phy
.2989	8a		txa				txa 								; copy X to +1, +2
.298a	a8		tay				tay
.298b	c8		iny				iny
.298c	20 3e 28	jsr $283e			jsr 	CopyFloatXY
.298f	c8		iny				iny
.2990	20 3e 28	jsr $283e			jsr 	CopyFloatXY
.2993	e8		inx				inx 								; point to the pair and put x^2 on stack
.2994	e8		inx				inx
.2995	20 1a 23	jsr $231a			jsr 	FloatMultiply
.2998	7a		ply				ply 								; coefficient table back.
.2999	68		pla				pla
.299a	20 07 28	jsr $2807			jsr 	CalculateHornerPolynomial
.299d	8a		txa				txa 								; copy back to slot #1
.299e	a8		tay				tay
.299f	88		dey				dey
.29a0	20 3e 28	jsr $283e			jsr	 	CopyFloatXY
.29a3	ca		dex				dex 								; point at result
.29a4	60		rts				rts
.29a5					FloatSquareRoot:
.29a5	20 af 28	jsr $28af			jsr 	FloatLogarithm
.29a8	b0 06		bcs $29b0			bcs 	_FSQExit
.29aa	d6 6e		dec $6e,x			dec 	NSExponent,x
.29ac	20 ac 27	jsr $27ac			jsr 	FloatExponent
.29af	18		clc				clc
.29b0					_FSQExit:
.29b0	60		rts				rts
.29b1					FloatTangent:
.29b1	da		phx				phx
.29b2	8a		txa				txa 								; sin -> +1
.29b3	a8		tay				tay
.29b4	c8		iny				iny
.29b5	20 3e 28	jsr $283e			jsr 	CopyFloatXY
.29b8	e8		inx				inx
.29b9	20 40 29	jsr $2940			jsr 	FloatSine
.29bc	ca		dex				dex
.29bd	8a		txa				txa 								; cos -> +2
.29be	a8		tay				tay
.29bf	c8		iny				iny
.29c0	c8		iny				iny
.29c1	20 3e 28	jsr $283e			jsr 	CopyFloatXY
.29c4	e8		inx				inx
.29c5	e8		inx				inx
.29c6	20 a0 27	jsr $27a0			jsr 	FloatCosine
.29c9	20 a3 21	jsr $21a3			jsr 	FloatDivide 				; calculate sin/cos
.29cc	b0 07		bcs $29d5			bcs 	_FTExit 					; divide by zero
.29ce	8a		txa				txa 								; copy result down.
.29cf	a8		tay				tay
.29d0	88		dey				dey
.29d1	20 3e 28	jsr $283e			jsr 	CopyFloatXY
.29d4	18		clc				clc
.29d5					_FTExit:
.29d5	fa		plx				plx
.29d6	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.007a					srcPtr:
>007a							.fill 	2
.05b8					currentLineNumber:
>05b8							.fill 	2
.29d7					InlineNonDecimal:
.29d7	a2 02		ldx #$02			ldx 	#2 							; get size in X
.29d9	c9 25		cmp #$25			cmp 	#"%"
.29db	f0 02		beq $29df			beq 	_INDBinary
.29dd	a2 10		ldx #$10			ldx 	#16
.29df					_INDBinary:
.29df	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.29e1	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.29e3	64 2c		stz $2c				stz 	zTemp0 						; zero result
.29e5	64 2d		stz $2d				stz 	zTemp0+1
.29e7					_INDLoop:
.29e7	20 83 33	jsr $3383			jsr 	LookNext 					; check next character
.29ea	20 bf 33	jsr $33bf			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.29ed	90 1f		bcc $2a0e			bcc		_INDDone 					; didn't convert
.29ef	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.29f1	b0 1b		bcs $2a0e			bcs 	_INDDone
.29f3	20 1d 2a	jsr $2a1d			jsr 	_INDShift 					; x 2 or x 16
.29f6	e0 02		cpx #$02			cpx 	#2
.29f8	f0 09		beq $2a03			beq 	_INDNotHex
.29fa	20 1d 2a	jsr $2a1d			jsr 	_INDShift
.29fd	20 1d 2a	jsr $2a1d			jsr 	_INDShift
.2a00	20 1d 2a	jsr $2a1d			jsr 	_INDShift
.2a03					_INDNotHex:
.2a03	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.2a05	85 2c		sta $2c				sta 	zTemp0
.2a07	20 94 33	jsr $3394			jsr 	GetNext 					; consume
.2a0a	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.2a0c	80 d9		bra $29e7			bra 	_INDLoop
.2a0e					_INDDone:
.2a0e	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.2a10	f0 08		beq $2a1a			beq 	_INDError
.2a12	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.2a14	a5 2c		lda $2c				lda 	zTemp0
.2a16	20 3e 2b	jsr $2b3e			jsr 	PushIntegerYA
.2a19	60		rts				rts
.2a1a					_INDError:
.2a1a	4c 14 1f	jmp $1f14		jmp	ErrorV_syntax
.2a1d					_INDShift:
.2a1d	06 2c		asl $2c				asl 	zTemp0
.2a1f	26 2d		rol $2d				rol 	zTemp0+1
.2a21	60		rts				rts
.2a22					GetLineNumber:
.2a22	ac b9 05	ldy $05b9			ldy 	currentLineNumber+1
.2a25	ad b8 05	lda $05b8			lda 	currentLineNumber
.2a28	60		rts				rts
.2a29					WriteCodeByte:
.2a29	48		pha				pha 								; save on stack
.2a2a	da		phx				phx
.2a2b	5a		phy				phy
.2a2c	aa		tax				tax
.2a2d	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.2a2f	20 3b 2b	jsr $2b3b			jsr 	CallAPIHandler
.2a32	7a		ply				ply 								; restore from stack
.2a33	fa		plx				plx
.2a34	68		pla				pla
.2a35	60		rts				rts
.2a36					PrintCharacter
.2a36	48		pha				pha
.2a37	da		phx				phx
.2a38	5a		phy				phy
.2a39	aa		tax				tax
.2a3a	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.2a3c	20 3b 2b	jsr $2b3b			jsr 	CallAPIHandler
.2a3f	7a		ply				ply
.2a40	fa		plx				plx
.2a41	68		pla				pla
.2a42	60		rts				rts
.2a43					ProcessNewLine:
.2a43	86 2c		stx $2c				stx 	zTemp0 						; save address in zTemp0
.2a45	84 2d		sty $2d				sty 	zTemp0+1
.2a47	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.2a48	8a		txa				txa
.2a49	69 04		adc #$04			adc 	#4
.2a4b	85 7a		sta $7a				sta 	srcPtr
.2a4d	98		tya				tya
.2a4e	69 00		adc #$00			adc 	#0
.2a50	85 7b		sta $7b				sta 	srcPtr+1
.2a52	a0 02		ldy #$02			ldy 	#2							; read and save line number
.2a54	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a56	8d b8 05	sta $05b8			sta 	currentLineNumber
.2a59	c8		iny				iny
.2a5a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a5c	8d b9 05	sta $05b9			sta 	currentLineNumber+1
.2a5f	60		rts				rts
.2a60					BufferClear:
.2a60	9c ba 05	stz $05ba			stz 	bufferSize
.2a63	60		rts				rts
.2a64					BufferWrite:
.2a64	da		phx				phx
.2a65	ae ba 05	ldx $05ba			ldx 	bufferSize
.2a68	9d bb 05	sta $05bb,x			sta 	dataBuffer,x
.2a6b	ee ba 05	inc $05ba			inc 	bufferSize
.2a6e	fa		plx				plx
.2a6f	60		rts				rts
.2a70					BufferOutput:
.2a70	ad ba 05	lda $05ba			lda 	bufferSize
.2a73	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2a76	a2 00		ldx #$00			ldx 	#0
.2a78					_BOLoop:
.2a78	ec ba 05	cpx $05ba			cpx 	bufferSize
.2a7b	f0 09		beq $2a86			beq 	_BOExit
.2a7d	bd bb 05	lda $05bb,x			lda 	dataBuffer,x
.2a80	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2a83	e8		inx				inx
.2a84	80 f2		bra $2a78			bra 	_BOLoop
.2a86					_BOExit:
.2a86	60		rts				rts
.05ba					bufferSize:
>05ba							.fill 	1
.05bb					dataBuffer:
>05bb							.fill 	256
.2a87					CheckNextComma:
.2a87	a9 2c		lda #$2c			lda	 	#","
.2a89	80 06		bra $2a91			bra 	CheckNextA
.2a8b					CheckNextRParen:
.2a8b	a9 29		lda #$29			lda	 	#")"
.2a8d	80 02		bra $2a91			bra 	CheckNextA
.2a8f					CheckNextLParen:
.2a8f	a9 28		lda #$28			lda 	#"("
.2a91					CheckNextA:
.2a91	8d bb 06	sta $06bb			sta 	checkCharacter 				; save test character
.2a94					_CNALoop:
.2a94	20 9f 33	jsr $339f			jsr 	GetNextNonSpace 			; get next skipping spaces.
.2a97	cd bb 06	cmp $06bb			cmp 	checkCharacter 				; matches ?
.2a9a	f0 03		beq $2a9f			beq 	_CNAExit
.2a9c	4c 14 1f	jmp $1f14		jmp	ErrorV_syntax
.2a9f					_CNAExit:
.2a9f	60		rts				rts
.06bb					checkCharacter:
>06bb							.fill 	1
.2aa0					StartCompiler:
.2aa0	86 2c		stx $2c				stx 	zTemp0 						; access API
.2aa2	84 2d		sty $2d				sty 	zTemp0+1
.2aa4	a0 2c		ldy #$2c			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.2aa6	a2 f7		ldx #$f7			ldx 	#CompilerErrorHandler & $FF
.2aa8	20 ed 1e	jsr $1eed			jsr 	SetErrorHandler
.2aab	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.2aad	b2 2c		lda ($2c)			lda 	(zTemp0)
.2aaf	8d bd 06	sta $06bd			sta 	APIVector
.2ab2	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ab4	8d be 06	sta $06be			sta 	APIVector+1
.2ab7	c8		iny				iny 								; copy data area range.
.2ab8	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2aba	8d bf 06	sta $06bf			sta 	compilerStartHigh
.2abd	c8		iny				iny
.2abe	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ac0	8d c0 06	sta $06c0			sta 	compilerEndHigh
.2ac3	ba		tsx				tsx 								; save stack pointer
.2ac4	8e bc 06	stx $06bc			stx 	compilerSP
.2ac7	20 23 37	jsr $3723			jsr 	STRReset 					; reset storage (line#, variable)
.2aca	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.2acc	20 3b 2b	jsr $2b3b			jsr 	CallAPIHandler
.2acf	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.2ad1	20 3b 2b	jsr $2b3b			jsr 	CallAPIHandler
.2ad4	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.2ad6	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2ad9	a9 00		lda #$00			lda 	#0
.2adb	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2ade	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2ae1					MainCompileLoop:
.2ae1	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.2ae3	20 3b 2b	jsr $2b3b			jsr 	CallAPIHandler
.2ae6	90 31		bcc $2b19			bcc 	SaveCodeAndExit 			; end of source.
.2ae8	20 43 2a	jsr $2a43			jsr 	ProcessNewLine 				; set up pointer and line number.
.2aeb	20 22 2a	jsr $2a22			jsr 	GetLineNumber 				; get line #
.2aee	20 0d 35	jsr $350d			jsr 	STRMarkLine 				; remember the code position and number of this line.
.2af1	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.2af3	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2af6					_MCLSameLine:
.2af6	20 9f 33	jsr $339f			jsr 	GetNextNonSpace 			; get the first character.
.2af9	f0 e6		beq $2ae1			beq 	MainCompileLoop 			; end of line, get next line.
.2afb	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.2afd	f0 f7		beq $2af6			beq 	_MCLSameLine
.2aff	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.2b01	10 0c		bpl $2b0f			bpl 	_MCLCheckAssignment
.2b03	a2 5d		ldx #$5d			ldx 	#CommandTables & $FF 		; do command tables.
.2b05	a0 2f		ldy #$2f			ldy 	#CommandTables >> 8
.2b07	20 25 32	jsr $3225			jsr 	GeneratorProcess
.2b0a	b0 ea		bcs $2af6			bcs 	_MCLSameLine 				; keep trying to compile the line.
.2b0c					_MCLSyntax:
.2b0c	4c 14 1f	jmp $1f14		jmp	ErrorV_syntax
.2b0f					_MCLCheckAssignment:
.2b0f	20 b5 33	jsr $33b5			jsr 	CharIsAlpha 				; if not alpha then syntax error
.2b12	90 f8		bcc $2b0c			bcc 	_MCLSyntax
.2b14	20 db 34	jsr $34db			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.2b17	80 dd		bra $2af6			bra		_MCLSameLine 				; loop back.
.2b19					SaveCodeAndExit:
.2b19	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.2b1b	20 3b 2b	jsr $2b3b			jsr 	CallAPIHandler
.2b1e	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.2b20	a8		tay				tay
.2b21	20 0d 35	jsr $350d			jsr 	STRMarkLine
.2b24	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.2b26	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2b29	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.2b2b	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2b2e	20 55 2e	jsr $2e55			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.2b31	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.2b33	20 3b 2b	jsr $2b3b			jsr 	CallAPIHandler
.2b36					ExitCompiler:
.2b36	ae bc 06	ldx $06bc			ldx 	compilerSP 					; reload SP and exit.
.2b39	9a		txs				txs
.2b3a	60		rts				rts
.2b3b					CallAPIHandler:
.2b3b	6c bd 06	jmp ($06bd)			jmp 	(APIVector)
.06bc					compilerSP:
>06bc							.fill 	1
.06bd					APIVector:
>06bd							.fill 	2
.06bf					compilerStartHigh:
>06bf							.fill 	1
.06c0					compilerEndHigh:
>06c0							.fill 	1
.2b3e					PushIntegerYA:
.2b3e	c0 00		cpy #$00			cpy 	#0 							; 0-255
.2b40	f0 0f		beq $2b51			beq 	PushIntegerA
.2b42	48		pha				pha
.2b43	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.2b45	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2b48	68		pla				pla 								; then LSB
.2b49	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2b4c	98		tya				tya 								; then MSB
.2b4d	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2b50	60		rts				rts
.2b51					PushIntegerA:
.2b51	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.2b53	90 07		bcc $2b5c			bcc 	_PIWriteA
.2b55	48		pha				pha
.2b56	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.2b58	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2b5b	68		pla				pla
.2b5c					_PIWriteA:
.2b5c	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2b5f	60		rts				rts
.2b60					PushFloatCommand:
.2b60	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.2b62	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2b65	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.2b67	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2b6a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2b6c	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2b6f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2b71	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2b74	b5 56		lda $56,x			lda 	NSMantissa2,x
.2b76	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2b79	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.2b7b	29 80		and #$80			and 	#$80
.2b7d	15 62		ora $62,x			ora 	NSMantissa3,x
.2b7f	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2b82	60		rts				rts
.2b83					CreateVariableRecord:
.2b83	48		pha				pha
.2b84	ad cb 06	lda $06cb			lda 	freeVariableMemory 		; push current free address on stack.
.2b87	48		pha				pha
.2b88	ad cc 06	lda $06cc			lda 	freeVariableMemory+1
.2b8b	48		pha				pha
.2b8c	ad c9 06	lda $06c9			lda 	variableListEnd  		; copy end of list to zTemp0
.2b8f	85 2c		sta $2c				sta 	zTemp0
.2b91	ad ca 06	lda $06ca			lda 	variableListEnd+1
.2b94	85 2d		sta $2d				sta 	zTemp0+1
.2b96	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.2b98	92 2c		sta ($2c)			sta 	(zTemp0)
.2b9a	98		tya				tya
.2b9b	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.2b9d	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b9f	88		dey				dey
.2ba0	8a		txa				txa
.2ba1	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2ba3	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.2ba5	ad cb 06	lda $06cb			lda 	freeVariableMemory
.2ba8	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2baa	c8		iny				iny
.2bab	ad cc 06	lda $06cc			lda 	freeVariableMemory+1
.2bae	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bb0	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.2bb2	a9 00		lda #$00			lda 	#0
.2bb4	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bb6	18		clc				clc
.2bb7	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.2bb9	6d c9 06	adc $06c9			adc  	variableListEnd
.2bbc	8d c9 06	sta $06c9			sta 	variableListEnd
.2bbf	90 03		bcc $2bc4			bcc 	_CVNoCarry2
.2bc1	ee ca 06	inc $06ca			inc 	variableListEnd+1
.2bc4					_CVNoCarry2:
.2bc4	7a		ply				ply
.2bc5	fa		plx				plx
.2bc6	68		pla				pla
.2bc7	60		rts				rts
.2bc8					SetVariableRecordToCodePosition:
.2bc8	48		pha				pha
.2bc9	5a		phy				phy
.2bca	a0 03		ldy #$03			ldy 	#3
.2bcc	a5 2b		lda $2b				lda 	objPtr+1
.2bce	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bd0	c8		iny				iny
.2bd1	a5 2a		lda $2a				lda 	objPtr
.2bd3	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bd5	7a		ply				ply
.2bd6	68		pla				pla
.2bd7	60		rts				rts
.2bd8					AllocateBytesForType:
.2bd8	48		pha				pha
.2bd9	da		phx				phx
.2bda	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.2bdc	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2bde	c9 00		cmp #$00			cmp 	#NSSIFloat
.2be0	d0 02		bne $2be4			bne 	_CVNotFloat
.2be2	a2 06		ldx #$06			ldx 	#6
.2be4					_CVNotFloat:
.2be4	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.2be5	18		clc				clc
.2be6	6d cb 06	adc $06cb			adc 	freeVariableMemory
.2be9	8d cb 06	sta $06cb			sta 	freeVariableMemory
.2bec	90 03		bcc $2bf1			bcc 	_CVNoCarry1
.2bee	ee cc 06	inc $06cc			inc 	freeVariableMemory+1
.2bf1					_CVNoCarry1:
.2bf1	fa		plx				plx
.2bf2	68		pla				pla
.2bf3	60		rts				rts
.2bf4					CommandDATA:
.2bf4	20 60 2a	jsr $2a60			jsr 	BufferClear 				; copy it to the buffer
.2bf7	20 86 33	jsr $3386			jsr 	LookNextNonSpace
.2bfa					_CTDataLoop:
.2bfa	20 83 33	jsr $3383			jsr 	LookNext 					; reached EOL
.2bfd	f0 08		beq $2c07			beq 	_CTDataDone
.2bff	20 64 2a	jsr $2a64			jsr 	BufferWrite 				; write and consume
.2c02	20 94 33	jsr $3394			jsr 	GetNext
.2c05	80 f3		bra $2bfa			bra 	_CTDataLoop
.2c07					_CTDataDone:
.2c07	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.2c09	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2c0c	20 70 2a	jsr $2a70			jsr 	BufferOutput
.2c0f	60		rts				rts
.2c10					CommandDEF:
.2c10	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.2c12	20 51 2b	jsr $2b51			jsr 	PushIntegerA
.2c15	20 a4 34	jsr $34a4			jsr 	CompileGotoEOL 				; compile skip over DEF
.2c18	a9 a5		lda #$a5			lda 	#C64_FN
.2c1a	20 91 2a	jsr $2a91			jsr 	CheckNextA
.2c1d	20 9f 33	jsr $339f			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2c20	20 04 34	jsr $3404			jsr 	ExtractVariableName
.2c23	8a		txa				txa
.2c24	10 51		bpl $2c77			bpl 	_CDError
.2c26	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2c27	29 7f		and #$7f			and 	#$7F
.2c29	aa		tax				tax
.2c2a	98		tya				tya
.2c2b	09 80		ora #$80			ora 	#$80
.2c2d	a8		tay				tay
.2c2e	20 f9 2d	jsr $2df9			jsr 	FindVariable				; does it already exist ?
.2c31	b0 44		bcs $2c77			bcs 	_CDError 					; if so, that's an error.
.2c33	20 83 2b	jsr $2b83			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.2c36	20 c8 2b	jsr $2bc8			jsr 	SetVariableRecordToCodePosition
.2c39	20 9f 33	jsr $339f			jsr 	GetNextNonSpace
.2c3c	20 e0 36	jsr $36e0			jsr 	GetReferenceTerm 			; get var ref, not array
.2c3f	c9 00		cmp #$00			cmp 	#0
.2c41	30 34		bmi $2c77			bmi 	_CDError
.2c43	8d c1 06	sta $06c1			sta 	defType 					; save type
.2c46	8e c2 06	stx $06c2			stx 	defVariable 				; save var ref
.2c49	8c c3 06	sty $06c3			sty 	defVariable+1
.2c4c	29 40		and #$40			and 	#NSSString 					; only numbers.
.2c4e	d0 27		bne $2c77			bne 	_CDError
.2c50	20 8b 2a	jsr $2a8b			jsr 	CheckNextRParen 			; check )
.2c53	a9 b2		lda #$b2			lda 	#C64_EQUAL
.2c55	20 91 2a	jsr $2a91			jsr 	CheckNextA 					; check =
.2c58	18		clc				clc 								; if this is DEF FNxx(A), read A
.2c59	20 7a 2c	jsr $2c7a			jsr 	CDReadWriteVariable
.2c5c	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2c5e	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2c61	38		sec				sec
.2c62	20 7a 2c	jsr $2c7a			jsr 	CDReadWriteVariable 		; A is now updated
.2c65	20 3f 2d	jsr $2d3f			jsr 	CompileExpressionAt0 		; the actual body of the function.
.2c68	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2c6a	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2c6d	38		sec				sec
.2c6e	20 7a 2c	jsr $2c7a			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.2c71	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.2c73	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2c76	60		rts				rts
.2c77					_CDError:
.2c77	4c 14 1f	jmp $1f14		jmp	ErrorV_syntax
.2c7a					CDReadWriteVariable:
.2c7a	ac c3 06	ldy $06c3			ldy 	defVariable+1 				; set up YX
.2c7d	ae c2 06	ldx $06c2			ldx 	defVariable
.2c80	ad c1 06	lda $06c1			lda 	defType
.2c83	20 92 36	jsr $3692			jsr 	GetSetVariable
.2c86	60		rts				rts
.06c1					defType:
>06c1							.fill 	1
.06c2					defVariable:
>06c2							.fill 	2
.2c87					CommandDIM:
.2c87	20 9f 33	jsr $339f			jsr 	GetNextNonSpace 			; get the first non space character
.2c8a	20 04 34	jsr $3404			jsr 	ExtractVariableName 		; variable name to XY
.2c8d	da		phx				phx 								; save name with type bits.
.2c8e	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.2c90	10 37		bpl $2cc9			bpl 	_CDError
.2c92	20 f9 2d	jsr $2df9			jsr 	FindVariable	 			; see if already exist
.2c95	b0 35		bcs $2ccc			bcs 	_CDRedefine 				; it still exists.
.2c97	20 83 2b	jsr $2b83			jsr 	CreateVariableRecord 		; create the basic variable
.2c9a	20 d8 2b	jsr $2bd8			jsr 	AllocateBytesForType 		; allocate memory for it
.2c9d	68		pla				pla 								; restore type bits
.2c9e	5a		phy				phy 								; save the address of the basic storage
.2c9f	da		phx				phx
.2ca0	48		pha				pha
.2ca1	20 cf 2c	jsr $2ccf			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.2ca4	68		pla				pla
.2ca5	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.2ca7	20 51 2b	jsr $2b51			jsr 	PushIntegerA 				; push that type data out.
.2caa	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.2cac	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2caf	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.2cb1	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2cb4	fa		plx				plx 								; restore address
.2cb5	7a		ply				ply
.2cb6	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2cb8	38		sec				sec
.2cb9	20 92 36	jsr $3692			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.2cbc	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; , follows ?
.2cbf	c9 2c		cmp #$2c			cmp 	#","
.2cc1	d0 05		bne $2cc8			bne 	_CDExit
.2cc3	20 94 33	jsr $3394			jsr 	GetNext 					; consume comma
.2cc6	80 bf		bra $2c87			bra 	CommandDIM 					; do another DIM
.2cc8					_CDExit:
.2cc8	60		rts				rts
.2cc9					_CDError:
.2cc9	4c 14 1f	jmp $1f14		jmp	ErrorV_syntax
.2ccc					_CDRedefine:
.2ccc	4c dc 1f	jmp $1fdc		jmp	ErrorV_redefine
.2ccf					OutputIndexGroup:
.2ccf	9c c4 06	stz $06c4			stz 	IndexCount 					; count of number of indices.
.2cd2					_OIGNext:
.2cd2	20 3f 2d	jsr $2d3f			jsr 	CompileExpressionAt0 		; get a dimension
.2cd5	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2cd7	c9 00		cmp #$00			cmp 	#NSSIFloat
.2cd9	d0 19		bne $2cf4			bne 	_OIGType
.2cdb	ee c4 06	inc $06c4			inc 	IndexCount 					; bump the counter.
.2cde	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; does a , follow ?
.2ce1	c9 2c		cmp #$2c			cmp 	#","
.2ce3	d0 05		bne $2cea			bne 	_OIGCheckEnd
.2ce5	20 94 33	jsr $3394			jsr 	GetNext 					; consume comma
.2ce8	80 e8		bra $2cd2			bra 	_OIGNext 					; get next dimension
.2cea					_OIGCheckEnd:
.2cea	20 8b 2a	jsr $2a8b			jsr 	CheckNextRParen 			; check and consume )
.2ced	ad c4 06	lda $06c4			lda 	IndexCount
.2cf0	20 51 2b	jsr $2b51			jsr 	PushIntegerA 				; compile the dimension count.
.2cf3	60		rts				rts
.2cf4					_OIGType:
.2cf4	4c 24 1f	jmp $1f24		jmp	ErrorV_type
.06c4					IndexCount:
>06c4							.fill 	1
.2cf7					CompilerErrorHandler:
.2cf7	68		pla				pla
.2cf8	7a		ply				ply
.2cf9	85 2c		sta $2c				sta 	zTemp0
.2cfb	84 2d		sty $2d				sty 	zTemp0+1
.2cfd	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.2cff	a0 01		ldy #$01			ldy 	#1
.2d01					_EHDisplayMsg:
.2d01	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d03	20 36 2a	jsr $2a36			jsr 	PrintCharacter
.2d06	c8		iny				iny
.2d07	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d09	d0 f6		bne $2d01			bne 	_EHDisplayMsg
.2d0b	a9 20		lda #$20			lda 	#32
.2d0d	20 36 2a	jsr $2a36			jsr 	PrintCharacter
.2d10	a9 40		lda #$40			lda 	#64
.2d12	20 36 2a	jsr $2a36			jsr 	PrintCharacter
.2d15	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.2d17	20 5c 26	jsr $265c			jsr 	FloatSetByte
.2d1a	20 22 2a	jsr $2a22			jsr 	GetLineNumber
.2d1d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2d1f	98		tya				tya
.2d20	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2d22	20 42 25	jsr $2542			jsr 	FloatToString
.2d25	a0 00		ldy #$00			ldy 	#0 							; display that string.
.2d27	a2 00		ldx #$00			ldx 	#0
.2d29					_EHDisplayLine:
.2d29	b9 96 05	lda $0596,y			lda 	decimalBuffer,y
.2d2c	20 36 2a	jsr $2a36			jsr 	PrintCharacter
.2d2f	c8		iny				iny
.2d30	b9 96 05	lda $0596,y			lda 	decimalBuffer,y
.2d33	d0 f4		bne $2d29			bne 	_EHDisplayLine
.2d35	a9 0d		lda #$0d			lda 	#13
.2d37	20 36 2a	jsr $2a36			jsr 	PrintCharacter
.2d3a	80 fe		bra $2d3a	_EHHalt:bra 	_EHHalt
.2d3c	4c 36 2b	jmp $2b36			jmp 	ExitCompiler
.2d3f					CompileExpressionAt0:
.2d3f	a9 00		lda #$00			lda 	#0
.2d41					CompileExpressionAtA:
.2d41	48		pha				pha  								; save level
.2d42	20 4b 37	jsr $374b			jsr 	CompileTerm 				; compile a term.
.2d45	fa		plx				plx 								; get level back into X
.2d46					_ECALoop:
.2d46	48		pha				pha 								; save type on stack.
.2d47	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; get the next character
.2d4a	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.2d4c	90 04		bcc $2d52			bcc 	_ECAExit
.2d4e	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.2d50	90 02		bcc $2d54			bcc 	_ECAHaveToken
.2d52					_ECAExit:
.2d52	68		pla				pla 								; throw type off stack
.2d53	60		rts				rts
.2d54					_ECAHaveToken:
.2d54	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.2d56	aa		tax				tax 								; X contains the operator token
.2d57	bd 42 2d	lda $2d42,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.2d5a	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.2d5c	90 f4		bcc $2d52			bcc 	_ECAExit
.2d5e	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.2d60	20 94 33	jsr $3394			jsr 	GetNext 					; consume the token.
.2d63	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.2d65	f0 11		beq $2d78			beq 	_ECAGreaterCheck
.2d67	e0 b3		cpx #$b3			cpx 	#C64_LESS
.2d69	d0 1a		bne $2d85			bne 	_ECAHaveFullToken
.2d6b	20 83 33	jsr $3383			jsr 	LookNext 					; checks for < (<= or <>)
.2d6e	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.2d70	f0 0e		beq $2d80			beq	 	_ECAToNotEqual
.2d72	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.2d74	d0 0f		bne $2d85			bne 	_ECAHaveFullToken
.2d76	80 07		bra $2d7f			bra 	_ECAAddEqual
.2d78					_ECAGreaterCheck:
.2d78	20 83 33	jsr $3383			jsr 	LookNext
.2d7b	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.2d7d	d0 06		bne $2d85			bne 	_ECAHaveFullToken
.2d7f					_ECAAddEqual:
.2d7f	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.2d80					_ECAToNotEqual:
.2d80	e8		inx				inx
.2d81	e8		inx				inx
.2d82	20 94 33	jsr $3394			jsr 	GetNext 					; consume the = or > in >= <= <>
.2d85					_ECAHaveFullToken:
.2d85	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.2d87	d0 0a		bne $2d93			bne 	_ECANotConcat
.2d89	68		pla				pla 								; get type back
.2d8a	48		pha				pha
.2d8b	29 40		and #$40			and 	#NSSTypeMask
.2d8d	c9 40		cmp #$40			cmp 	#NSSString
.2d8f	d0 02		bne $2d93			bne 	_ECANotConcat
.2d91	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2d93					_ECANotConcat:
.2d93	da		phx				phx 								; save operator on the stack
.2d94	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.2d96	da		phx				phx
.2d97	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.2d99	1a		inc a				inc 	a
.2d9a	20 41 2d	jsr $2d41			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.2d9d	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.2d9f	fa		plx				plx 								; restore current precedence in X
.2da0	68		pla				pla 								; restore operator
.2da1	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.2da3	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.2da5	90 17		bcc $2dbe			bcc 	_ECANotCompare
.2da7	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.2da9	b0 13		bcs $2dbe			bcs 	_ECANotCompare
.2dab	7a		ply				ply 								; get type into Y
.2dac	5a		phy				phy
.2dad	48		pha				pha 								; save operator
.2dae	98		tya				tya 								; get type
.2daf	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.2db1	29 40		and #$40			and 	#NSSTypeMask
.2db3	c9 40		cmp #$40			cmp 	#NSSString
.2db5	f0 02		beq $2db9			beq 	_ECANotString
.2db7	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.2db9					_ECANotString:
.2db9	98		tya				tya									; output token Y
.2dba	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2dbd	68		pla				pla 								; restore operator.
.2dbe					_ECANotCompare:
.2dbe	18		clc				clc 								; convert to P-Code and compile.
.2dbf	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.2dc1	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2dc4	68		pla				pla 								; type of current result
.2dc5	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.2dc7	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.2dc9	d0 19		bne $2de4			bne		_ECAType
.2dcb	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.2dcd	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.2dcf	d0 18		bne $2de9			bne 	_ECAGoLoop
.2dd1	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.2dd3	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2dd5	f0 10		beq $2de7			beq 	_ECAOkayString 				; (this is post conversion)
.2dd7	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.2dd9	90 09		bcc $2de4			bcc 	_ECAType
.2ddb	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.2ddd	b0 05		bcs $2de4			bcs 	_ECAType
.2ddf	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.2de1	4c 46 2d	jmp $2d46			jmp 	_ECALoop
.2de4					_ECAType:
.2de4	4c 24 1f	jmp $1f24		jmp	ErrorV_type
.2de7					_ECAOkayString:
.2de7	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.2de9					_ECAGoLoop:
.2de9	4c 46 2d	jmp $2d46			jmp 	_ECALoop
.2dec					PrecedenceTable:
>2dec	03						.byte 	3 					; '+'
>2ded	03						.byte 	3 					; '-'
>2dee	04						.byte 	4 					; '*'
>2def	04						.byte 	4 					; '/'
>2df0	05						.byte 	5 					; '^'
>2df1	01						.byte 	1 					; 'and'
>2df2	00						.byte 	0 					; 'or'
>2df3	02						.byte 	2 					; '>'
>2df4	02						.byte 	2 					; '='
>2df5	02						.byte 	2 					; '<'
>2df6	02						.byte 	2 					; '>='
>2df7	02						.byte 	2 					; '<='
>2df8	02						.byte 	2 					; '<>'
.2df9					FindVariable:
.2df9	86 2e		stx $2e				stx 	zTemp1 						; save name.
.2dfb	84 2f		sty $2f				sty 	zTemp1+1
.2dfd					_IVCheckSpecial:
.2dfd	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.2dff	d0 18		bne $2e19			bne 	_IVStandard
.2e01	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.2e03	f0 0c		beq $2e11			beq 	_IVTIFloat
.2e05	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.2e07	d0 10		bne $2e19			bne 	_IVStandard
.2e09	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.2e0b	a2 01		ldx #$01			ldx 	#$01
.2e0d	a9 40		lda #$40			lda 	#NSSString
.2e0f	38		sec				sec
.2e10	60		rts				rts
.2e11					_IVTIFloat:
.2e11	a0 80		ldy #$80			ldy 	#$80
.2e13	a2 00		ldx #$00			ldx 	#$00
.2e15	a9 00		lda #$00			lda 	#0
.2e17	38		sec				sec
.2e18	60		rts				rts
.2e19					_IVStandard:
.2e19	ad bf 06	lda $06bf			lda 	compilerStartHigh			; start scanning from here.
.2e1c	85 2d		sta $2d				sta 	zTemp0+1
.2e1e	64 2c		stz $2c				stz 	zTemp0
.2e20					_IVCheckLoop:
.2e20	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.2e22	f0 2b		beq $2e4f			beq  	_IVNotFound 				; if so, return with CC.
.2e24	a0 01		ldy #$01			ldy 	#1 							; match ?
.2e26	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e28	c5 2e		cmp $2e				cmp 	zTemp1
.2e2a	d0 07		bne $2e33			bne	 	_IVNext
.2e2c	c8		iny				iny
.2e2d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e2f	c5 2f		cmp $2f				cmp 	zTemp1+1
.2e31	f0 0d		beq $2e40			beq 	_IVFound
.2e33					_IVNext:
.2e33	18		clc				clc
.2e34	a5 2c		lda $2c				lda 	zTemp0
.2e36	72 2c		adc ($2c)			adc 	(zTemp0)
.2e38	85 2c		sta $2c				sta 	zTemp0
.2e3a	90 e4		bcc $2e20			bcc 	_IVCheckLoop
.2e3c	e6 2d		inc $2d				inc 	zTemp0+1
.2e3e	80 e0		bra $2e20			bra 	_IVCheckLoop
.2e40					_IVFound:
.2e40	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.2e42	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e44	aa		tax				tax
.2e45	c8		iny				iny
.2e46	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e48	48		pha				pha
.2e49	c8		iny				iny
.2e4a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e4c	7a		ply				ply
.2e4d	38		sec				sec
.2e4e	60		rts				rts
.2e4f					_IVNotFound:
.2e4f	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.2e51	a4 2f		ldy $2f				ldy 	zTemp1+1
.2e53	18		clc				clc
.2e54	60		rts				rts
.2e55					FixBranches:
.2e55	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.2e57	20 3b 2b	jsr $2b3b			jsr 	CallAPIHandler
.2e5a					_FBLoop:
.2e5a	b2 2a		lda ($2a)			lda 	(objPtr) 					; get the next one.
.2e5c	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.2e5e	f0 16		beq $2e76			beq 	_FBFixGotoGosub
.2e60	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.2e62	f0 12		beq $2e76			beq 	_FBFixGotoGosub
.2e64	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.2e66	f0 0e		beq $2e76			beq 	_FBFixGotoGosub
.2e68	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.2e6a	f0 0a		beq $2e76			beq 	_FBFixGotoGosub
.2e6c	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.2e6e	f0 3b		beq $2eab			beq 	_FBFixVarSpace
.2e70					_FBNext:
.2e70	20 29 20	jsr $2029			jsr 	MoveObjectForward 			; move forward in object code.
.2e73	90 e5		bcc $2e5a			bcc 	_FBLoop 					; not finished
.2e75					_FBExit:
.2e75	60		rts				rts
.2e76					_FBFixGotoGosub:
.2e76	a0 01		ldy #$01			ldy 	#1							; line number in YA
.2e78	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e7a	48		pha				pha
.2e7b	c8		iny				iny
.2e7c	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e7e	a8		tay				tay
.2e7f	68		pla				pla
.2e80	20 36 35	jsr $3536			jsr 	STRFindLine			 		; find where it is YA
.2e83	90 08		bcc $2e8d			bcc 	_FBFFound 					; not found, so must be >
.2e85	48		pha				pha
.2e86	b2 2a		lda ($2a)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.2e88	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.2e8a	d0 0f		bne $2e9b			bne 	_FBFFail
.2e8c	68		pla				pla
.2e8d					_FBFFound:
.2e8d	20 86 35	jsr $3586			jsr 	STRMakeOffset 				; make it an offset from X:YA
.2e90	5a		phy				phy	 								; patch the GOTO/GOSUB
.2e91	a0 01		ldy #$01			ldy 	#1
.2e93	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e95	c8		iny				iny
.2e96	68		pla				pla
.2e97	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e99	80 d5		bra $2e70			bra 	_FBNext
.2e9b					_FBFFail:
.2e9b	a0 02		ldy #$02			ldy 	#2
.2e9d	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e9f	8d b8 05	sta $05b8			sta 	currentLineNumber
.2ea2	c8		iny				iny
.2ea3	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ea5	8d b9 05	sta $05b9			sta 	currentLineNumber+1
.2ea8	4c 57 1f	jmp $1f57		jmp	ErrorV_line
.2eab					_FBFixVarSpace:
.2eab	a0 01		ldy #$01			ldy 	#1
.2ead	ad cb 06	lda $06cb			lda 	freeVariableMemory
.2eb0	91 2a		sta ($2a),y			sta 	(objPtr),y
.2eb2	c8		iny				iny
.2eb3	ad cc 06	lda $06cc			lda 	freeVariableMemory+1
.2eb6	91 2a		sta ($2a),y			sta 	(objPtr),y
.2eb8	80 b6		bra $2e70			bra 	_FBNext
.2eba					CommandFOR:
.2eba	20 9f 33	jsr $339f			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.2ebd	20 b5 33	jsr $33b5			jsr 	CharIsAlpha 				; if not alpha , error
.2ec0	90 59		bcc $2f1b			bcc 	_CFFail
.2ec2	20 e0 36	jsr $36e0			jsr 	GetReferenceTerm 			; figure out the reference.
.2ec5	48		pha				pha 								; save type
.2ec6	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ec8	c9 00		cmp #$00			cmp 	#NSSIFloat
.2eca	d0 4f		bne $2f1b			bne 	_CFFail
.2ecc	5a		phy				phy 								; save reference on the stack
.2ecd	da		phx				phx
.2ece	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.2ed0	20 91 2a	jsr $2a91			jsr 	CheckNextA
.2ed3	20 3f 2d	jsr $2d3f			jsr 	CompileExpressionAt0 		; initial value
.2ed6	fa		plx				plx 								; get reference back.
.2ed7	7a		ply				ply
.2ed8	5a		phy				phy
.2ed9	da		phx				phx
.2eda	38		sec				sec 								; set initial value.
.2edb	20 92 36	jsr $3692			jsr 	GetSetVariable
.2ede	fa		plx				plx
.2edf	7a		ply				ply
.2ee0	68		pla				pla
.2ee1	29 20		and #$20			and 	#NSSIInt16
.2ee3	f0 04		beq $2ee9			beq 	_CFNotInt16
.2ee5	98		tya				tya
.2ee6	09 80		ora #$80			ora 	#$80
.2ee8	a8		tay				tay
.2ee9					_CFNotInt16:
.2ee9	8a		txa				txa 								; reference in YA
.2eea	20 3e 2b	jsr $2b3e			jsr 	PushIntegerYA
.2eed	a9 a4		lda #$a4			lda 	#C64_TO
.2eef	20 91 2a	jsr $2a91			jsr 	CheckNextA
.2ef2	20 3f 2d	jsr $2d3f			jsr 	CompileExpressionAt0 		; terminal value
.2ef5	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ef7	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ef9	d0 20		bne $2f1b			bne 	_CFFail
.2efb	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; followed by STEP
.2efe	c9 a9		cmp #$a9			cmp 	#C64_STEP
.2f00	d0 0e		bne $2f10			bne 	_CFNoStep
.2f02	20 94 33	jsr $3394			jsr 	GetNext 					; consume it.
.2f05	20 3f 2d	jsr $2d3f			jsr 	CompileExpressionAt0 		; terminal value
.2f08	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f0a	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f0c	d0 0d		bne $2f1b			bne 	_CFFail
.2f0e	80 05		bra $2f15			bra 	_CFParametersDone
.2f10					_CFNoStep:
.2f10	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.2f12	20 51 2b	jsr $2b51			jsr 	PushIntegerA
.2f15					_CFParametersDone:
.2f15	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2f17	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2f1a	60		rts				rts
.2f1b					_CFFail:
.2f1b	4c 14 1f	jmp $1f14		jmp	ErrorV_syntax
.2f1e					FNCompile:
.2f1e	20 9f 33	jsr $339f			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2f21	20 04 34	jsr $3404			jsr 	ExtractVariableName
.2f24	e0 00		cpx #$00			cpx 	#0
.2f26	10 32		bpl $2f5a			bpl 	_FNError
.2f28	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2f29	29 7f		and #$7f			and 	#$7F
.2f2b	aa		tax				tax
.2f2c	98		tya				tya
.2f2d	09 80		ora #$80			ora 	#$80
.2f2f	a8		tay				tay
.2f30	20 f9 2d	jsr $2df9			jsr 	FindVariable				; does it already exist ?
.2f33	90 25		bcc $2f5a			bcc 	_FNError 					; no.
.2f35	20 86 35	jsr $3586			jsr 	STRMakeOffset 				; convert to a relative address.
.2f38	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2f3a	d0 01		bne $2f3d			bne 	_FNNoBorrow
.2f3c	88		dey				dey
.2f3d					_FNNoBorrow:
.2f3d	3a		dec a				dec 	a
.2f3e	5a		phy				phy 								; save location of routine on stack.
.2f3f	48		pha				pha
.2f40	da		phx				phx
.2f41	20 3f 2d	jsr $2d3f			jsr 	CompileExpressionAt0
.2f44	20 8b 2a	jsr $2a8b			jsr 	CheckNextRParen
.2f47	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.2f49	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2f4c	68		pla				pla
.2f4d	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2f50	68		pla				pla
.2f51	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2f54	68		pla				pla
.2f55	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.2f58	18		clc				clc
.2f59	60		rts				rts
.2f5a					_FNError:
.2f5a	4c 07 1f	jmp $1f07		jmp	ErrorV_value
.2f5d					CommandTables:
>2f5d	07 cb 00 03 62 34 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2f64	07 89 00 03 69 34 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2f6b	07 8d 00 03 5c 34 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>2f72	07 88 00 03 d8 34 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2f79	07 85 00 03 b8 34 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>2f80	07 84 00 04 cc 34 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>2f87	07 99 00 03 0d 36 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2f8e	07 98 00 04 0d 36 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2f95	07 8f 00 03 18 37 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>2f9c	07 81 00 03 ba 2e 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>2fa3	07 82 00 03 90 35 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>2faa	07 a1 00 03 d5 33 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>2fb1	07 83 00 03 f4 2b 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>2fb8	07 87 00 03 56 36 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>2fbf	07 86 00 03 87 2c 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>2fc6	07 96 00 03 10 2c 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>2fcd	07 8b 00 e3 85 34 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>2fd4	08 92 00 ea e3 e4 37 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>2fdc	09 91 00 e1 a9 03 bc 35			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>2fe4	06
>2fe5	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>2fec	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>2ff3	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>2ff9	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>3000	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>3007	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>300e	07 9d 00 e3 0a 38 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>3015	0a 9f 00 ea e3 1d 38 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>301d	c6 06
>301f	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>3025	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>302c	0a ce 92 e3 52 33 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>3034	ad 06
>3036	0a ce 8d e3 52 33 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>303e	ae 06
>3040	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>3046	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>304e	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>3055	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>305c	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>3064	06
>3065	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>306d	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>3075	9a 06
>3077	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>307f	9b 06
>3081	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>3089	9c 06
>308b	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>3093	06
>3094	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>309b	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>30a3	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>30ab	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>30b3	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>30bb	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>30c3	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>30cb	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>30d3	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>30db	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>30e3	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>30eb	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>30f2	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>30fa	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>3102	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>310a	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>3112	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>311a	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>3122	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>312a	00						.byte 	0
.312b					UnaryTables:
>312b	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>3132	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>313a	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>3141	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>3148	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>314f	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>3156	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>315e	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>3165	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>316d	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>3175	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>317d	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>3185	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>318d	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>3195	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>319c	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>31a3	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>31aa	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>31b1	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>31b8	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>31bf	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>31c7	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>31cf	0b ca 00 8f ae 03 52 33			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>31d7	91 bd 07
>31da	07 a8 00 03 71 33 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>31e1	07 a5 00 03 1e 2f 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>31e8	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>31ef	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>31f6	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>31fe	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>3206	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>320d	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>3214	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>321b	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>3223	06
>3224	00						.byte 	0
.3225					GeneratorProcess:
.3225	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.3227	84 2d		sty $2d				sty 	zTemp0+1
.3229	85 2e		sta $2e				sta 	zTemp1 						; first match token
.322b	64 2f		stz $2f				stz 	zTemp1+1
.322d	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.322f	d0 05		bne $3236			bne 	_GPNotShifted
.3231	20 94 33	jsr $3394			jsr 	GetNext 					; get the shifted token
.3234	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.3236					_GPNotShifted:
.3236					_GPSearch:
.3236	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.3238	18		clc				clc
.3239	f0 2f		beq $326a			beq 	_GPExit
.323b	a0 01		ldy #$01			ldy 	#1 							; tokens match
.323d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.323f	c5 2e		cmp $2e				cmp 	zTemp1
.3241	d0 09		bne $324c			bne 	_GPNext
.3243	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.3245	f0 12		beq $3259			beq 	_GPFound
.3247	c8		iny				iny 								; check match.
.3248	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.324a	f0 0d		beq $3259			beq 	_GPFound
.324c					_GPNext:
.324c	18		clc				clc 								; follow to next
.324d	a5 2c		lda $2c				lda 	zTemp0
.324f	72 2c		adc ($2c)			adc 	(zTemp0)
.3251	85 2c		sta $2c				sta 	zTemp0
.3253	90 e1		bcc $3236			bcc 	_GPSearch
.3255	e6 2d		inc $2d				inc 	zTemp0+1
.3257	80 dd		bra $3236			bra 	_GPSearch
.3259					_GPFound:
.3259	18		clc				clc 								; skip to action bytes
.325a	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.325c	69 03		adc #$03			adc 	#3
.325e	85 2c		sta $2c				sta 	zTemp0
.3260	90 02		bcc $3264			bcc 	_GPNoCarry
.3262	e6 2d		inc $2d				inc 	zTemp0+1
.3264					_GPNoCarry:
.3264					_GPLoop:
.3264	20 6b 32	jsr $326b			jsr 	GeneratorExecute 			; execute one command
.3267	90 fb		bcc $3264			bcc 	_GPLoop 					; go back if not completed.
.3269	38		sec				sec 								; return with CS.
.326a					_GPExit:
.326a	60		rts				rts
.326b					GeneratorExecute:
.326b	20 17 33	jsr $3317			jsr 	_GEFetchZTemp0 				; get next.
.326e	48		pha				pha 								; split into 2 nibbles
.326f	4a		lsr a				lsr 	a
.3270	4a		lsr a				lsr 	a
.3271	4a		lsr a				lsr		a
.3272	4a		lsr a				lsr 	a
.3273	20 7d 32	jsr $327d			jsr 	_GEExecuteNibble 			; MSB first
.3276	68		pla				pla
.3277	b0 03		bcs $327c			bcs 	_GEHaveCompleted
.3279	20 7d 32	jsr $327d			jsr 	_GEExecuteNibble 			; LSB second
.327c					_GEHaveCompleted:
.327c	60		rts				rts
.327d					_GEExecuteNibble:
.327d	29 0f		and #$0f			and 	#$0F
.327f	0a		asl a				asl 	a
.3280	aa		tax				tax
.3281	7c 84 32	jmp ($3284,x)			jmp 	(_GEExecuteVectors,x)
.3284					_GEExecuteVectors:
>3284	a4 32						.word 	_GEXNop 					; 0  (no operation)
>3286	ac 32						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>3288	a6 32						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>328a	fa 32						.word 	_GEXExecute 				; 3  (run arbitrary code)
>328c	ed 32						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>328e	a4 32						.word 	_GEXNop 					; 5
>3290	b4 32						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>3292	b8 32						.word 	_GEXExitString 				; 7  exit return string type
>3294	bc 32						.word 	_GEXLParam 					; 8  check ( follows
>3296	c0 32						.word 	_GEXRParam 					; 9  check ) follows
>3298	c4 32						.word 	_GEXComma					; A  check , follows
>329a	a4 32						.word 	_GEXNop 					; B
>329c	a4 32						.word 	_GEXNop 					; C
>329e	a4 32						.word 	_GEXNop 					; D
>32a0	d4 32						.word 	_GEXNumber 					; E  compile get any number
>32a2	df 32						.word 	_GEXString 					; F  compile get any string
.32a4					_GEXNop:
.32a4	18		clc				clc
.32a5	60		rts				rts
.32a6					_GEXToken2:
.32a6	20 17 33	jsr $3317			jsr 	_GEFetchZTemp0
.32a9	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.32ac					_GEXToken1:
.32ac	20 17 33	jsr $3317			jsr 	_GEFetchZTemp0
.32af	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.32b2	18		clc				clc
.32b3	60		rts				rts
.32b4					_GEXExitNumber:
.32b4	a9 00		lda #$00			lda 	#NSSIFloat
.32b6	38		sec				sec
.32b7	60		rts				rts
.32b8					_GEXExitString:
.32b8	a9 40		lda #$40			lda 	#NSSString
.32ba	38		sec				sec
.32bb	60		rts				rts
.32bc					_GEXLParam:
.32bc	a9 28		lda #$28			lda 	#"("
.32be	80 06		bra $32c6			bra 	_GEXCheck
.32c0					_GEXRParam:
.32c0	a9 29		lda #$29			lda 	#")"
.32c2	80 02		bra $32c6			bra 	_GEXCheck
.32c4					_GEXComma:
.32c4	a9 2c		lda #$2c			lda 	#","
.32c6					_GEXCheck:
.32c6	85 30		sta $30				sta 	zTemp2 						; save match
.32c8	20 9f 33	jsr $339f			jsr 	GetNextNonSpace 			; get next skipping spaces
.32cb	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.32cd	d0 02		bne $32d1			bne 	_GEXSyntax
.32cf	18		clc				clc
.32d0	60		rts				rts
.32d1					_GEXSyntax:
.32d1	4c 14 1f	jmp $1f14		jmp	ErrorV_syntax
.32d4					_GEXNumber:
.32d4	20 20 33	jsr $3320			jsr 	GEXCompileExpression 		; compile expression
.32d7	29 40		and #$40			and 	#NSSTypeMask
.32d9	c9 00		cmp #$00			cmp  	#NSSIFloat
.32db	d0 0d		bne $32ea			bne 	_GEXType
.32dd	18		clc				clc
.32de	60		rts				rts
.32df					_GEXString:
.32df	20 20 33	jsr $3320			jsr 	GEXCompileExpression 		; compile expression
.32e2	29 40		and #$40			and 	#NSSTypeMask
.32e4	c9 40		cmp #$40			cmp  	#NSSString
.32e6	d0 02		bne $32ea			bne 	_GEXType
.32e8	18		clc				clc
.32e9	60		rts				rts
.32ea					_GEXType:
.32ea	4c 24 1f	jmp $1f24		jmp	ErrorV_type
.32ed					_GEXChannelExec:
.32ed	20 30 33	jsr $3330			jsr 	ChannelPrefix 				; set up default
.32f0	20 fa 32	jsr $32fa			jsr 	_GEXExecute
.32f3	08		php				php
.32f4	20 4b 33	jsr $334b			jsr 	ChannelPostfix 				; replace default.
.32f7	28		plp				plp
.32f8	60		rts				rts
>32f9	db						.byte 	$DB 						; causes a break in the emulator
.32fa					_GEXExecute:
.32fa	20 17 33	jsr $3317			jsr 	_GEFetchZTemp0 				; get vector
.32fd	85 30		sta $30				sta 	zTemp2
.32ff	20 17 33	jsr $3317			jsr 	_GEFetchZTemp0
.3302	85 31		sta $31				sta 	zTemp2+1
.3304	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.3306	da		phx				phx
.3307	a6 2d		ldx $2d				ldx 	zTemp0+1
.3309	da		phx				phx
.330a	20 14 33	jsr $3314			jsr 	_GECallZTemp2 				; execute code
.330d	fa		plx				plx 								; recover generation exec
.330e	86 2d		stx $2d				stx 	zTemp0+1
.3310	fa		plx				plx
.3311	86 2c		stx $2c				stx 	zTemp0
.3313	60		rts				rts
.3314					_GECallZTemp2:
.3314	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.3317					_GEFetchZTemp0:
.3317	b2 2c		lda ($2c)			lda 	(zTemp0)
.3319	e6 2c		inc $2c				inc 	zTemp0
.331b	d0 02		bne $331f			bne 	_GEFZ0Skip
.331d	e6 2d		inc $2d				inc 	zTemp0+1
.331f					_GEFZ0Skip:
.331f	60		rts				rts
.3320					GEXCompileExpression:
.3320	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.3322	da		phx				phx
.3323	a6 2d		ldx $2d				ldx 	zTemp0+1
.3325	da		phx				phx
.3326	20 3f 2d	jsr $2d3f			jsr 	CompileExpressionAt0 		; compile expression.
.3329	fa		plx				plx 								; recover generation exec
.332a	86 2d		stx $2d				stx 	zTemp0+1
.332c	fa		plx				plx
.332d	86 2c		stx $2c				stx 	zTemp0
.332f	60		rts				rts
.3330					ChannelPrefix:
.3330	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.3332	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.3335	20 20 33	jsr $3320			jsr 	GEXCompileExpression 		; channel #
.3338	29 40		and #$40			and 	#NSSTypeMask
.333a	c9 00		cmp #$00			cmp 	#NSSIFloat
.333c	d0 0a		bne $3348			bne 	_CPXType
.333e	20 87 2a	jsr $2a87			jsr 	CheckNextComma 				; check , follows.
.3341	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.3343	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.3346	18		clc				clc
.3347	60		rts				rts
.3348					_CPXType:
.3348	4c 24 1f	jmp $1f24		jmp	ErrorV_type
.334b					ChannelPostfix:
.334b	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.334d	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.3350	18		clc				clc
.3351	60		rts				rts
.3352					OptionalParameterCompile:
.3352	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; what follows.
.3355	c9 2c		cmp #$2c			cmp 	#","
.3357	d0 0e		bne $3367			bne 	_MidDefault
.3359	20 94 33	jsr $3394			jsr 	GetNext 					; consume ,
.335c	20 3f 2d	jsr $2d3f			jsr 	CompileExpressionAt0
.335f	29 40		and #$40			and 	#NSSTypeMask
.3361	c9 00		cmp #$00			cmp 	#NSSIFloat
.3363	d0 09		bne $336e			bne 	MidFailType
.3365	80 05		bra $336c			bra 	_MidComplete
.3367					_MidDefault:
.3367	a9 ff		lda #$ff			lda 	#255 						; default of 255
.3369	20 51 2b	jsr $2b51			jsr 	PushIntegerA
.336c					_MidComplete:
.336c	18		clc				clc
.336d	60		rts				rts
.336e					MidFailType:
.336e	4c 24 1f	jmp $1f24		jmp	ErrorV_type
.3371					NotUnaryCompile:
.3371	ad f4 2d	lda $2df4			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.3374	20 41 2d	jsr $2d41			jsr 	CompileExpressionAtA 		; evaluate at that level
.3377	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.3379	c9 00		cmp #$00			cmp 	#NSSIFloat
.337b	d0 f1		bne $336e			bne 	MidFailType
.337d	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.337f	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.3382	60		rts				rts
.3383					LookNext:
.3383	b2 7a		lda ($7a)			lda 	(srcPtr)
.3385	60		rts				rts
.3386					LookNextNonSpace:
.3386	b2 7a		lda ($7a)			lda 	(srcPtr)
.3388	c9 20		cmp #$20			cmp		#' '
.338a	f0 03		beq $338f			beq 	_LNNSkip
.338c	c9 00		cmp #$00			cmp 	#0
.338e	60		rts				rts
.338f					_LNNSkip:
.338f	20 94 33	jsr $3394			jsr 	GetNext
.3392	80 f2		bra $3386			bra 	LookNextNonSpace
.3394					GetNext:
.3394	b2 7a		lda ($7a)			lda 	(srcPtr) 					; get next
.3396	e6 7a		inc $7a				inc 	srcPtr
.3398	d0 02		bne $339c			bne 	_GNSkip
.339a	e6 7b		inc $7b				inc 	srcPtr+1
.339c					_GNSkip:
.339c	c9 00		cmp #$00			cmp 	#0
.339e	60		rts				rts
.339f					GetNextNonSpace:
.339f	20 94 33	jsr $3394			jsr 	GetNext
.33a2	c9 20		cmp #$20			cmp 	#' '
.33a4	f0 f9		beq $339f			beq 	GetNextNonSpace
.33a6	c9 00		cmp #$00			cmp 	#0
.33a8	60		rts				rts
.33a9					CharIsDigit:
.33a9	c9 30		cmp #$30			cmp 	#"0"
.33ab	90 06		bcc $33b3			bcc 	CCFalse
.33ad	c9 3a		cmp #$3a			cmp 	#"9"+1
.33af	b0 02		bcs $33b3			bcs 	CCFalse
.33b1					CCTrue:
.33b1	38		sec				sec
.33b2	60		rts				rts
.33b3					CCFalse:
.33b3	18		clc				clc
.33b4	60		rts				rts
.33b5					CharIsAlpha:
.33b5	c9 41		cmp #$41			cmp 	#"A"
.33b7	90 fa		bcc $33b3			bcc 	CCFalse
.33b9	c9 5b		cmp #$5b			cmp 	#"Z"+1
.33bb	b0 f6		bcs $33b3			bcs 	CCFalse
.33bd	80 f2		bra $33b1			bra 	CCTrue
.33bf					ConvertHexStyle:
.33bf	38		sec				sec
.33c0	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.33c2	90 ef		bcc $33b3			bcc 	CCFalse
.33c4	c9 0a		cmp #$0a			cmp 	#9+1
.33c6	90 e9		bcc $33b1			bcc 	CCTrue
.33c8	38		sec				sec 								; shift into hex space A=>0 Z=>25
.33c9	e9 11		sbc #$11			sbc 	#"A"-"0"
.33cb	90 e6		bcc $33b3			bcc 	CCFalse
.33cd	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.33cf	b0 e2		bcs $33b3			bcs 	CCFalse
.33d1	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.33d3	80 dc		bra $33b1			bra 	CCTrue
.33d5					CommandGET:
.33d5	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; # follows ?
.33d8	c9 23		cmp #$23			cmp 	#"#"
.33da	d0 0d		bne $33e9			bne 	CommandGetBody
.33dc	20 94 33	jsr $3394			jsr 	GetNext 					; consume #
.33df	20 30 33	jsr $3330			jsr 	ChannelPrefix 				; do it as GET#
.33e2	20 e9 33	jsr $33e9			jsr 	CommandGetBody
.33e5	20 4b 33	jsr $334b			jsr 	ChannelPostfix
.33e8	60		rts				rts
.33e9					CommandGetBody:
.33e9	20 9f 33	jsr $339f			jsr 	GetNextNonSpace 			; get the first character
.33ec	20 e0 36	jsr $36e0			jsr 	GetReferenceTerm 			; identify variable to assign to
.33ef	48		pha				pha
.33f0	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.33f2	c9 40		cmp #$40			cmp 	#NSSString
.33f4	d0 0b		bne $3401			bne 	_CGType
.33f6	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.33f8	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.33fb	38		sec				sec
.33fc	68		pla				pla
.33fd	20 92 36	jsr $3692			jsr		GetSetVariable
.3400	60		rts				rts
.3401					_CGType:
.3401	4c 24 1f	jmp $1f24		jmp	ErrorV_type
.3404					ExtractVariableName:
.3404	20 b5 33	jsr $33b5			jsr 	CharIsAlpha
.3407	90 50		bcc $3459			bcc 	_IVSyntax
.3409	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.340b	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.340d	64 2f		stz $2f				stz 	zTemp1+1
.340f	20 83 33	jsr $3383			jsr 	LookNext 					; is there a second character ?
.3412	20 b5 33	jsr $33b5			jsr 	CharIsAlpha  				; must be alphanumeric
.3415	b0 05		bcs $341c			bcs 	_IVHasSecond
.3417	20 a9 33	jsr $33a9			jsr 	CharIsDigit
.341a	90 07		bcc $3423			bcc 	_IVCheckType
.341c					_IVHasSecond:
.341c	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.341e	85 2f		sta $2f				sta 	zTemp1+1
.3420					_IVGetNextCheck:
.3420	20 94 33	jsr $3394			jsr 	GetNext 					; consume it
.3423					_IVCheckType:
.3423	20 83 33	jsr $3383			jsr 	LookNext					; check if string follows.
.3426	20 b5 33	jsr $33b5			jsr 	CharIsAlpha
.3429	b0 f5		bcs $3420			bcs 	_IVGetNextCheck
.342b	20 a9 33	jsr $33a9			jsr 	CharIsDigit
.342e	b0 f0		bcs $3420			bcs 	_IVGetNextCheck
.3430	a2 40		ldx #$40			ldx 	#NSSString
.3432	c9 24		cmp #$24			cmp 	#"$"
.3434	f0 06		beq $343c			beq 	_IVHasType
.3436	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.3438	c9 25		cmp #$25			cmp 	#"%"
.343a	d0 08		bne $3444			bne 	_IVCheckArray
.343c					_IVHasType:
.343c	8a		txa				txa 								; Or X into zTemp1
.343d	05 2e		ora $2e				ora 	zTemp1
.343f	85 2e		sta $2e				sta 	zTemp1
.3441	20 94 33	jsr $3394			jsr 	GetNext 					; consume it
.3444					_IVCheckArray:
.3444	20 83 33	jsr $3383			jsr 	LookNext 					; check if array follows
.3447	c9 28		cmp #$28			cmp 	#"("
.3449	d0 09		bne $3454			bne 	_IVNotArray
.344b	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.344d	09 80		ora #$80			ora 	#NSSArray
.344f	85 2e		sta $2e				sta 	zTemp1
.3451	20 94 33	jsr $3394			jsr 	GetNext 					; consume it
.3454					_IVNotArray:
.3454	a6 2e		ldx $2e				ldx 	zTemp1
.3456	a4 2f		ldy $2f				ldy 	zTemp1+1
.3458	60		rts				rts
.3459					_IVSyntax:
.3459	4c 14 1f	jmp $1f14		jmp	ErrorV_syntax
.345c					CommandGOSUB:
.345c	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.345e	20 6f 34	jsr $346f			jsr 	CompileBranchCommand
.3461	60		rts				rts
.3462					CommandGOAlt:
.3462	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.3464	20 91 2a	jsr $2a91			jsr 	CheckNextA
.3467	80 00		bra $3469			bra 	CommandGOTO
.3469					CommandGOTO:
.3469	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.346b	20 6f 34	jsr $346f			jsr 	CompileBranchCommand
.346e	60		rts				rts
.346f					CompileBranchCommand:
.346f	20 29 2a	jsr $2a29			jsr 	WriteCodeByte 				; write the command out.
.3472	20 9f 33	jsr $339f			jsr 	GetNextNonSpace
.3475	20 e8 35	jsr $35e8			jsr 	ParseConstant 				; get constant into YA
.3478	90 08		bcc $3482			bcc 	_CBCSyntax
.347a	20 29 2a	jsr $2a29			jsr 	WriteCodeByte				; and compile the actual line number
.347d	98		tya				tya
.347e	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.3481	60		rts				rts
.3482					_CBCSyntax:
.3482	4c 14 1f	jmp $1f14		jmp	ErrorV_syntax
.3485					CommandIF:
.3485	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; what follows the tests ?
.3488	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.348a	f0 0f		beq $349b			beq 	_CIGoto
.348c	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.348e	20 91 2a	jsr $2a91			jsr 	CheckNextA
.3491	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; THEN <number>
.3494	20 a9 33	jsr $33a9			jsr 	CharIsDigit
.3497	b0 05		bcs $349e			bcs 	_CIGoto2
.3499	80 09		bra $34a4			bra 	CompileGotoEOL
.349b					_CIGoto:
.349b	20 94 33	jsr $3394			jsr 	GetNext
.349e					_CIGoto2:
.349e	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.34a0	20 6f 34	jsr $346f			jsr 	CompileBranchCommand
.34a3	60		rts				rts
.34a4					CompileGotoEOL:
.34a4	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.34a6	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.34a9	20 22 2a	jsr $2a22			jsr 	GetLineNumber 				; Get the current line number => YA
.34ac	1a		inc a				inc 	a 							; and branch to +1
.34ad	d0 01		bne $34b0			bne 	_CGENoCarry
.34af	c8		iny				iny
.34b0					_CGENoCarry:
.34b0	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.34b3	98		tya				tya
.34b4	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.34b7	60		rts				rts
.34b8					CommandINPUT:
.34b8	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; check for "
.34bb	c9 22		cmp #$22			cmp 	#'"'
.34bd	d0 0d		bne $34cc			bne 	CommandINPUTStream
.34bf	20 3f 2d	jsr $2d3f			jsr 	CompileExpressionAt0
.34c2	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.34c4	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.34c7	a9 2c		lda #$2c			lda 	#","
.34c9	20 87 2a	jsr $2a87			jsr 	CheckNextComma
.34cc					CommandINPUTStream:
.34cc	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.34ce	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.34d1	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.34d3	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.34d5	4c 5a 36	jmp $365a			jmp 	CommandReadInputCommon
.34d8					CommandLET:
.34d8	20 9f 33	jsr $339f			jsr 	GetNextNonSpace 			; get the first character
.34db					CommandLETHaveFirst:
.34db	20 e0 36	jsr $36e0			jsr 	GetReferenceTerm 			; identify variable to assign to
.34de	da		phx				phx 								; save target on the stack.
.34df	5a		phy				phy
.34e0	48		pha				pha
.34e1	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.34e3	20 91 2a	jsr $2a91			jsr 	CheckNextA
.34e6	20 3f 2d	jsr $2d3f			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.34e9	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.34eb	68		pla				pla 								; get type of assignment
.34ec	48		pha				pha
.34ed	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.34ef	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.34f1	d0 17		bne $350a			bne 	_CLType
.34f3	68		pla				pla 								; restore and compile save code
.34f4	7a		ply				ply
.34f5	fa		plx				plx
.34f6	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.34f8	f0 05		beq $34ff			beq 	_CLTIString
.34fa	38		sec				sec
.34fb	20 92 36	jsr $3692			jsr		GetSetVariable
.34fe	60		rts				rts
.34ff					_CLTIString:
.34ff	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.3501	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.3504	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.3506	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.3509	60		rts				rts
.350a					_CLType:
.350a	4c 24 1f	jmp $1f24		jmp	ErrorV_type
.350d					STRMarkLine:
.350d	48		pha				pha
.350e	38		sec				sec 								; allocate 4 bytes (line #,address)
.350f	ad c7 06	lda $06c7			lda 	lineNumberTable 			; and copy to zTemp0
.3512	e9 04		sbc #$04			sbc 	#4
.3514	8d c7 06	sta $06c7			sta 	lineNumberTable
.3517	85 2c		sta $2c				sta 	zTemp0
.3519	ad c8 06	lda $06c8			lda 	lineNumberTable+1
.351c	e9 00		sbc #$00			sbc 	#0
.351e	8d c8 06	sta $06c8			sta 	lineNumberTable+1
.3521	85 2d		sta $2d				sta 	zTemp0+1
.3523	68		pla				pla
.3524	92 2c		sta ($2c)			sta 	(zTemp0) 					; line # save it in +0,+1
.3526	98		tya				tya
.3527	a0 01		ldy #$01			ldy 	#1
.3529	91 2c		sta ($2c),y			sta 	(zTemp0),y
.352b	a5 2a		lda $2a				lda 	objPtr 						; save current address in +2,+3
.352d	c8		iny				iny
.352e	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3530	a5 2b		lda $2b				lda 	objPtr+1
.3532	c8		iny				iny
.3533	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3535	60		rts				rts
.3536					STRFindLine:
.3536	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.3538	84 2d		sty $2d				sty 	zTemp0+1
.353a	ad c0 06	lda $06c0			lda 	compilerEndHigh 			; work backwards through table
.353d	85 2f		sta $2f				sta 	zTemp1+1
.353f	64 2e		stz $2e				stz 	zTemp1
.3541					_STRSearch:
.3541	20 78 35	jsr $3578			jsr 	_STRPrevLine 				; look at previous record.
.3544	a0 01		ldy #$01			ldy 	#1
.3546	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.3548	c5 2c		cmp $2c				cmp 	zTemp0
.354a	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.354c	e5 2d		sbc $2d				sbc 	zTemp0+1
.354e	b0 0b		bcs $355b			bcs 	_STRFound 					; >=
.3550					_STRNext:
.3550	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.3552	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3554	c9 ff		cmp #$ff			cmp 	#$FF
.3556	d0 e9		bne $3541			bne 	_STRSearch
.3558	4c 6e 1f	jmp $1f6e		jmp	ErrorV_internal
.355b					_STRFound:
.355b	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.355d	45 2c		eor $2c				eor 	zTemp0
.355f	d0 06		bne $3567			bne 	_STRDifferent
.3561	b2 2e		lda ($2e)			lda 	(zTemp1)
.3563	45 2c		eor $2c				eor 	zTemp0
.3565	f0 02		beq $3569			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.3567					_STRDifferent:
.3567	a9 ff		lda #$ff			lda 	#$FF
.3569					_STROut:
.3569	18		clc				clc  								; set carry if different, e.g. > rather than >=
.356a	69 ff		adc #$ff			adc 	#255
.356c	08		php				php
.356d	c8		iny				iny 								; address into YA
.356e	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3570	48		pha				pha
.3571	c8		iny				iny
.3572	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3574	a8		tay				tay
.3575	68		pla				pla
.3576	28		plp				plp
.3577	60		rts				rts
.3578					_STRPrevLine:
.3578	38		sec				sec 								; move backwards one entry.
.3579	a5 2e		lda $2e				lda 	zTemp1
.357b	e9 04		sbc #$04			sbc 	#4
.357d	85 2e		sta $2e				sta 	zTemp1
.357f	a5 2f		lda $2f				lda 	zTemp1+1
.3581	e9 00		sbc #$00			sbc 	#0
.3583	85 2f		sta $2f				sta 	zTemp1+1
.3585	60		rts				rts
.3586					STRMakeOffset:
.3586	18		clc				clc 								; borrow 1
.3587	e5 2a		sbc $2a				sbc 	objPtr
.3589	48		pha				pha
.358a	98		tya				tya
.358b	e5 2b		sbc $2b				sbc 	objPtr+1
.358d	a8		tay				tay
.358e	68		pla				pla
.358f	60		rts				rts
.3590					CommandNEXT:
.3590	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.3593	20 b5 33	jsr $33b5			jsr 	CharIsAlpha 				; if not alpha , error
.3596	90 0c		bcc $35a4			bcc 	_CNNoReferenceGiven
.3598	20 94 33	jsr $3394			jsr 	GetNext
.359b	20 e0 36	jsr $36e0			jsr 	GetReferenceTerm 			; figure out the reference.
.359e	8a		txa				txa 								; reference in YA
.359f	20 3e 2b	jsr $2b3e			jsr 	PushIntegerYA 				; write it out.
.35a2	80 06		bra $35aa			bra 	_CNParametersDone
.35a4					_CNNoReferenceGiven:
.35a4	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.35a6	a8		tay				tay
.35a7	20 3e 2b	jsr $2b3e			jsr 	PushIntegerYA 				; write it out.
.35aa					_CNParametersDone:
.35aa	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.35ac	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.35af	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; look for ,
.35b2	c9 2c		cmp #$2c			cmp 	#","
.35b4	d0 05		bne $35bb			bne 	_CNExit
.35b6	20 94 33	jsr $3394			jsr 	GetNext 					; consume ,
.35b9	80 d5		bra $3590			bra 	CommandNEXT 				; and go round.
.35bb					_CNExit:
.35bb	60		rts				rts
.35bc					CommandON:
.35bc	20 9f 33	jsr $339f			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.35bf	48		pha				pha 								; save on stack
.35c0	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.35c2	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.35c4	f0 09		beq $35cf			beq 	_COCreateLoop
.35c6	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.35c8	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.35ca	f0 03		beq $35cf			beq 	_COCreateLoop
.35cc	4c 14 1f	jmp $1f14		jmp	ErrorV_syntax
.35cf					_COCreateLoop:
.35cf	8a		txa				txa 								; compile a goto/gosub somewhere
.35d0	da		phx				phx
.35d1	20 6f 34	jsr $346f			jsr 	CompileBranchCommand
.35d4	fa		plx				plx
.35d5	20 86 33	jsr $3386			jsr 	LookNextNonSpace			; ',' follows
.35d8	c9 2c		cmp #$2c			cmp 	#","
.35da	d0 0a		bne $35e6			bne 	_COComplete 				; if so, more line numbers
.35dc	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.35de	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.35e1	20 94 33	jsr $3394			jsr 	GetNext
.35e4	80 e9		bra $35cf			bra 	_COCreateLoop
.35e6					_COComplete:
.35e6	68		pla				pla 								; throw GOTO/GOSUB
.35e7	60		rts				rts
.35e8					ParseConstant:
.35e8	a2 00		ldx #$00			ldx 	#0
.35ea	20 3a 24	jsr $243a			jsr 	FloatEncodeStart 			; send first
.35ed					_ParseLoop:
.35ed	20 83 33	jsr $3383			jsr 	LookNext 					; send subsequent
.35f0	20 3d 24	jsr $243d			jsr 	FloatEncodeContinue
.35f3	90 05		bcc $35fa			bcc 	_ParseDone
.35f5	20 94 33	jsr $3394			jsr 	GetNext 					; consume it
.35f8	80 f3		bra $35ed			bra 	_ParseLoop
.35fa					_ParseDone:
.35fa	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.35fc	29 80		and #$80			and 	#$80
.35fe	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.3600	15 56		ora $56,x			ora 	NSMantissa2,x
.3602	15 62		ora $62,x			ora 	NSMantissa3,x
.3604	18		clc				clc
.3605	d0 05		bne $360c			bne 	_ParseExit 					; exit with CC if need float to compile
.3607	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.3609	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.360b	38		sec				sec
.360c					_ParseExit:
.360c	60		rts				rts
.360d					CommandPRINT:
.360d	20 86 33	jsr $3386			jsr 	LookNextNonSpace			; what follows ?
.3610	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.3612	f0 1f		beq $3633			beq 	_CPCheckEnd
.3614	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.3616	f0 16		beq $362e			beq 	_CPTabCheckEnd
.3618	20 4a 36	jsr $364a			jsr 	_CPAtEnd 					; check for : and EOL
.361b	b0 22		bcs $363f			bcs 	_CPExitCR 					; exit with CR
.361d	20 3f 2d	jsr $2d3f			jsr 	CompileExpressionAt0 		; so it is something to print
.3620	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.3622	29 40		and #$40			and 	#NSSString 					; if string
.3624	d0 02		bne $3628			bne 	_CPOut
.3626	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.3628					_CPOut:
.3628	8a		txa				txa 								; print that thing
.3629	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.362c	80 df		bra $360d			bra 	CommandPRINT 				; and loop round/
.362e					_CPTabCheckEnd:
.362e	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.3630	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.3633					_CPCheckEnd:
.3633	20 94 33	jsr $3394			jsr 	GetNext 					; consume it.
.3636	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; what follows ?
.3639	20 4a 36	jsr $364a			jsr 	_CPAtEnd 					; reached end
.363c	90 cf		bcc $360d			bcc 	CommandPRINT 				; no, loop back
.363e	60		rts				rts
.363f					_CPExitCR:
.363f	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.3641	20 51 2b	jsr $2b51			jsr 	PushIntegerA
.3644	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.3646	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.3649	60		rts				rts
.364a					_CPAtEnd:
.364a	c9 00		cmp #$00			cmp 	#0
.364c	f0 06		beq $3654			beq 	_CPIsEnd
.364e	c9 3a		cmp #$3a			cmp 	#":"
.3650	f0 02		beq $3654			beq 	_CPIsEnd
.3652	18		clc				clc
.3653	60		rts				rts
.3654					_CPIsEnd:
.3654	38		sec				sec
.3655	60		rts				rts
.3656					CommandREAD:
.3656	a2 b2		ldx #$b2			ldx 	#PCD_READ
.3658	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.365a					CommandReadInputCommon:
.365a	8e c5 06	stx $06c5			stx 	numberPCode
.365d	8c c6 06	sty $06c6			sty 	stringPCode
.3660					_CRLoop:
.3660	20 9f 33	jsr $339f			jsr 	GetNextNonSpace 			; first char of identifier
.3663	20 b5 33	jsr $33b5			jsr 	CharIsAlpha 				; check A-Z
.3666	90 27		bcc $368f			bcc 	_CRSyntax
.3668	20 e0 36	jsr $36e0			jsr 	GetReferenceTerm 			; get the variable.
.366b	48		pha				pha 								; save type.
.366c	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.366e	c9 40		cmp #$40			cmp 	#NSSString
.3670	f0 05		beq $3677			beq 	_CRString
.3672	ad c5 06	lda $06c5			lda 	numberPCode 				; output read/input
.3675	80 03		bra $367a			bra 	_CRHaveType
.3677					_CRString:
.3677	ad c6 06	lda $06c6			lda 	stringPCode					; output read$/input$
.367a					_CRHaveType:
.367a	20 29 2a	jsr $2a29			jsr 	WriteCodeByte 				; so we have one typed data item.
.367d	68		pla				pla 								; restore type
.367e	38		sec				sec  								; write update code.
.367f	20 92 36	jsr $3692			jsr 	GetSetVariable
.3682	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; , follows ?
.3685	c9 2c		cmp #$2c			cmp 	#","
.3687	d0 05		bne $368e			bne 	_CRExit 					; if not, end of READ.
.3689	20 94 33	jsr $3394			jsr 	GetNext 					; consume comma
.368c	80 d2		bra $3660			bra 	_CRLoop 					; keep going
.368e					_CRExit:
.368e	60		rts				rts
.368f					_CRSyntax:
.368f	4c 14 1f	jmp $1f14		jmp	ErrorV_syntax
.06c5					numberPCode:
>06c5							.fill 	1
.06c6					stringPCode:
>06c6							.fill 	1
.3692					GetSetVariable:
.3692	08		php				php 								; save direction on stack
.3693	c0 00		cpy #$00			cpy 	#$00
.3695	30 21		bmi $36b8			bmi 	_GSVReadWriteSpecial
.3697	c9 00		cmp #$00			cmp 	#$00
.3699	30 33		bmi $36ce			bmi 	_GSVArray
.369b	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.369d	4a		lsr a				lsr 	a 							; divide by 2
.369e	09 40		ora #$40			ora 	#64 						; and set bit 6.
.36a0	28		plp				plp
.36a1	90 02		bcc $36a5			bcc 	_GSVNotWrite
.36a3	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.36a5					_GSVNotWrite:
.36a5	85 2c		sta $2c				sta 	zTemp0
.36a7	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.36a8	4a		lsr a				lsr 	a
.36a9	a8		tay				tay
.36aa	8a		txa				txa
.36ab	6a		ror a				ror 	a
.36ac	aa		tax				tax
.36ad	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.36ae	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.36b0	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.36b3	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.36b4	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.36b7	60		rts				rts
.36b8					_GSVReadWriteSpecial:
.36b8	28		plp				plp
.36b9	b0 10		bcs $36cb			bcs 	_GSVSyntax
.36bb	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.36bd	f0 06		beq $36c5			beq 	_GSVRWString
.36bf	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.36c1	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.36c4	60		rts				rts
.36c5					_GSVRWString:
.36c5	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.36c7	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.36ca	60		rts				rts
.36cb					_GSVSyntax:
.36cb	4c 14 1f	jmp $1f14		jmp	ErrorV_syntax
.36ce					_GSVArray:
.36ce	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.36d0	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.36d1	4a		lsr a				lsr 	a
.36d2	4a		lsr a				lsr 	a
.36d3	4a		lsr a				lsr 	a
.36d4	4a		lsr a				lsr 	a
.36d5	28		plp				plp 								; if writing array then set bit 2.
.36d6	90 02		bcc $36da			bcc 	_GSVANotWrite
.36d8	09 04		ora #$04			ora 	#4
.36da					_GSVANotWrite:
.36da	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.36dc	20 29 2a	jsr $2a29			jsr 	WriteCodeByte 				; and write it out
.36df	60		rts				rts
.36e0					GetReferenceTerm:
.36e0	20 04 34	jsr $3404			jsr 	ExtractVariableName 		; get name & type info
.36e3	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.36e5	30 10		bmi $36f7			bmi 	_GRTArray
.36e7	da		phx				phx 								; save type on stack
.36e8	20 f9 2d	jsr $2df9			jsr 	FindVariable 				; find it
.36eb	b0 06		bcs $36f3			bcs 	_GRTNoCreate 				; create if required.
.36ed	20 83 2b	jsr $2b83			jsr 	CreateVariableRecord 		; create a variable.
.36f0	20 d8 2b	jsr $2bd8			jsr 	AllocateBytesForType 		; allocate memory for it
.36f3					_GRTNoCreate:
.36f3	68		pla				pla 								; get type back, strip out type information.
.36f4	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.36f6	60		rts				rts
.36f7					_GRTArray:
.36f7	da		phx				phx 								; save type information
.36f8	20 f9 2d	jsr $2df9			jsr 	FindVariable 				; read its data, the base address in YX
.36fb	90 18		bcc $3715			bcc 	_GRTUndeclared 				; undeclared array.
.36fd	da		phx				phx 								; save base address
.36fe	5a		phy				phy
.36ff	20 cf 2c	jsr $2ccf			jsr 	OutputIndexGroup 			; create an index group and generate them
.3702	7a		ply				ply 								; get the array base address into YX
.3703	fa		plx				plx
.3704	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.3706	18		clc				clc
.3707	20 92 36	jsr $3692			jsr 	GetSetVariable 				; load the address of the array structure.
.370a	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.370c	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.370f	68		pla				pla 								; and the type data into A
.3710	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.3712	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.3714	60		rts				rts
.3715					_GRTUndeclared:
.3715	4c cb 1f	jmp $1fcb		jmp	ErrorV_undeclared
.3718					CommandREM:
.3718	20 83 33	jsr $3383			jsr 	LookNext
.371b	f0 05		beq $3722			beq 	_CRExit
.371d	20 94 33	jsr $3394			jsr 	GetNext
.3720	80 f6		bra $3718			bra 	CommandREM
.3722					_CRExit:
.3722	60		rts				rts
.3723					STRReset:
.3723	ad bf 06	lda $06bf			lda	 	compilerStartHigh 			; set up the two table pointers
.3726	8d ca 06	sta $06ca			sta 	variableListEnd+1
.3729	9c c9 06	stz $06c9			stz 	variableListEnd
.372c	ad c0 06	lda $06c0			lda 	compilerEndHigh
.372f	8d c8 06	sta $06c8			sta 	lineNumberTable+1
.3732	9c c7 06	stz $06c7			stz 	lineNumberTable
.3735	ad c9 06	lda $06c9			lda 	variableListEnd
.3738	85 2d		sta $2d				sta 	zTemp0+1
.373a	64 2c		stz $2c				stz 	zTemp0
.373c	a9 00		lda #$00			lda 	#0
.373e	92 2c		sta ($2c)			sta 	(zTemp0)
.3740	a9 00		lda #$00			lda 	#((0) & $FF)
.3742	8d cb 06	sta $06cb			sta 	0+freeVariableMemory
.3745	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.3747	8d cc 06	sta $06cc			sta 	1+freeVariableMemory
.374a	60		rts				rts
.06c7					lineNumberTable:
>06c7							.fill 	2
.06c9					variableListEnd:
>06c9							.fill 	2
.06cb					freeVariableMemory:
>06cb							.fill 	2
.374b					CompileTerm:
.374b	20 9f 33	jsr $339f			jsr 	GetNextNonSpace 			; get first non space character.
.374e	30 72		bmi $37c2			bmi 	_CTUnaryFunctions
.3750	20 a9 33	jsr $33a9			jsr 	CharIsDigit 				; found a number
.3753	b0 3a		bcs $378f			bcs 	_CTDigit
.3755	c9 2e		cmp #$2e			cmp 	#"."
.3757	f0 36		beq $378f			beq 	_CTDigit
.3759	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.375b	f0 43		beq $37a0			beq 	_CTString
.375d	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.375f	f0 28		beq $3789			beq 	_CTOtherBase
.3761	c9 24		cmp #$24			cmp 	#"$"
.3763	f0 24		beq $3789			beq 	_CTOtherBase
.3765	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.3767	f0 17		beq $3780			beq 	_CTBrackets
.3769	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.376b	90 10		bcc $377d			bcc 	_CTSyntax
.376d	c9 5b		cmp #$5b			cmp 	#"Z"+1
.376f	b0 0c		bcs $377d			bcs 	_CTSyntax
.3771	20 e0 36	jsr $36e0			jsr 	GetReferenceTerm 			; figure out what it is.
.3774	48		pha				pha 								; save type on stack
.3775	18		clc				clc 								; read it
.3776	20 92 36	jsr $3692			jsr 	GetSetVariable
.3779	68		pla				pla
.377a	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.377c	60		rts				rts
.377d					_CTSyntax:
.377d	4c 14 1f	jmp $1f14		jmp	ErrorV_syntax
.3780					_CTBrackets:
.3780	20 3f 2d	jsr $2d3f			jsr 	CompileExpressionAt0
.3783	48		pha				pha
.3784	20 8b 2a	jsr $2a8b			jsr 	CheckNextRParen
.3787	68		pla				pla
.3788	60		rts				rts
.3789					_CTOtherBase:
.3789	20 d7 29	jsr $29d7			jsr 	InlineNonDecimal 			; non decimal constant handler
.378c	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.378e	60		rts				rts
.378f					_CTDigit:
.378f	20 e8 35	jsr $35e8			jsr 	ParseConstant 				; parse out an number, first is in A already.
.3792	90 06		bcc $379a			bcc	 	_CTFloat 					; have a float or long int.
.3794	20 3e 2b	jsr $2b3e			jsr 	PushIntegerYA 				; code to push on stack
.3797	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.3799	60		rts				rts
.379a					_CTFloat:
.379a	20 60 2b	jsr $2b60			jsr 	PushFloatCommand			; code to push float
.379d	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.379f	60		rts				rts
.37a0					_CTString:
.37a0	20 60 2a	jsr $2a60			jsr 	BufferClear 				; copy it to the buffer
.37a3					_CTStringLoop:
.37a3	20 83 33	jsr $3383			jsr 	LookNext 					; reached EOL/EOS
.37a6	f0 d5		beq $377d			beq 	_CTSyntax
.37a8	c9 22		cmp #$22			cmp 	#'"'
.37aa	f0 08		beq $37b4			beq 	_CTStringDone
.37ac	20 64 2a	jsr $2a64			jsr 	BufferWrite 				; write and consume
.37af	20 94 33	jsr $3394			jsr 	GetNext
.37b2	80 ef		bra $37a3			bra 	_CTStringLoop
.37b4					_CTStringDone:
.37b4	20 94 33	jsr $3394			jsr 	GetNext 					; consume closing quote.
.37b7	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.37b9	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.37bc	20 70 2a	jsr $2a70			jsr 	BufferOutput
.37bf	a9 40		lda #$40			lda 	#NSSString 					; string type
.37c1	60		rts				rts
.37c2					_CTUnaryFunctions:
.37c2	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.37c4	f0 0a		beq $37d0			beq 	_CTNegation
.37c6	a2 2b		ldx #$2b			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.37c8	a0 31		ldy #$31			ldy 	#UnaryTables >> 8
.37ca	20 25 32	jsr $3225			jsr 	GeneratorProcess
.37cd	90 ae		bcc $377d			bcc		_CTSyntax
.37cf	60		rts				rts
.37d0					_CTNegation:
.37d0	20 4b 37	jsr $374b			jsr 	CompileTerm 				; compile a term.
.37d3	48		pha				pha
.37d4	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.37d6	c9 00		cmp #$00			cmp 	#NSSIFloat
.37d8	d0 07		bne $37e1			bne 	_CTType 					; error
.37da	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.37dc	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.37df	68		pla				pla 								; return original type.
.37e0	60		rts				rts
.37e1					_CTType:
.37e1	4c 24 1f	jmp $1f24		jmp	ErrorV_type
.37e4					CommandWAIT:
.37e4	20 86 33	jsr $3386			jsr 	LookNextNonSpace
.37e7	c9 2c		cmp #$2c			cmp 	#","
.37e9	f0 10		beq $37fb			beq 	_CWThirdParameter
.37eb	a9 00		lda #$00			lda 	#0
.37ed	20 51 2b	jsr $2b51			jsr 	PushIntegerA
.37f0					_CWExit:
.37f0	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.37f2	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.37f5	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.37f7	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.37fa	60		rts				rts
.37fb					_CWThirdParameter:
.37fb	20 94 33	jsr $3394			jsr 	GetNext
.37fe	20 41 2d	jsr $2d41			jsr 	CompileExpressionAtA
.3801	29 40		and #$40			and 	#NSSTypeMask
.3803	c9 00		cmp #$00			cmp 	#NSSIFloat
.3805	f0 e9		beq $37f0			beq 	_CWExit
.3807	4c 24 1f	jmp $1f24		jmp	ErrorV_type
.380a					CommandCMD:
.380a	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.380c	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.380f	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; followed by a , ?
.3812	c9 2c		cmp #$2c			cmp 	#","
.3814	d0 06		bne $381c			bne 	_CCMDExit
.3816	20 94 33	jsr $3394			jsr 	GetNext 					; consume comma.
.3819	20 0d 36	jsr $360d			jsr 	CommandPRINT 				; do the print code
.381c					_CCMDExit:
.381c	60		rts				rts
.381d					CommandOPEN:
.381d	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; followed by a , ?
.3820	c9 2c		cmp #$2c			cmp 	#","
.3822	d0 15		bne $3839			bne 	_COTwoDefaults
.3824	20 94 33	jsr $3394			jsr 	GetNext 					; consume comma
.3827	20 3f 2d	jsr $2d3f			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.382a	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.382c	f0 1e		beq $384c			beq 	_COThreeIntegers
.382e	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.3830	20 51 2b	jsr $2b51			jsr 	PushIntegerA
.3833	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.3835	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.3838	60		rts				rts
.3839					_COTwoDefaults:
.3839	a9 00		lda #$00			lda 	#0
.383b	20 51 2b	jsr $2b51			jsr 	PushIntegerA
.383e					_COCompileNullString:
.383e	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.3840	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.3843	a9 00		lda #$00			lda 	#0
.3845	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.3848	20 29 2a	jsr $2a29			jsr 	WriteCodeByte
.384b	60		rts				rts
.384c					_COThreeIntegers:
.384c	20 86 33	jsr $3386			jsr 	LookNextNonSpace 			; is there a ,
.384f	c9 2c		cmp #$2c			cmp 	#","
.3851	d0 eb		bne $383e			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.3853	20 94 33	jsr $3394			jsr 	GetNext
.3856	20 3f 2d	jsr $2d3f			jsr 	CompileExpressionAt0 		; should be a filename
.3859	29 40		and #$40			and 	#NSSString
.385b	f0 01		beq $385e			beq 	_COType
.385d	60		rts				rts
.385e					_COType:
.385e	4c 24 1f	jmp $1f24		jmp	ErrorV_type

;******  Processing input file: _library.asm

.3861					IOOpenRead:
.3861	a9 52		lda #$52			lda 	#'R' 						; read.
.3863	20 84 38	jsr $3884			jsr 	IOSetFileName 				; set up name/LFS
.3866	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for reading
.3868	20 c6 ff	jsr $ffc6			jsr 	$FFC6 						; CHKIN
.386b	60		rts				rts
.386c					IOReadByte:
.386c	da		phx				phx
.386d	5a		phy				phy
.386e	20 b7 ff	jsr $ffb7			jsr 	$FFB7 						; read ST
.3871	38		sec				sec
.3872	d0 04		bne $3878			bne 	_IORExit
.3874	20 cf ff	jsr $ffcf			jsr 	$FFCF 						; read a byte
.3877	18		clc				clc 								; status OK.
.3878					_IORExit:
.3878	7a		ply				ply
.3879	fa		plx				plx
.387a	60		rts				rts
.387b					IOReadClose:
.387b					IOWriteClose:
.387b	a9 03		lda #$03			lda 	#3 							; CLOSE# 3
.387d	20 c3 ff	jsr $ffc3			jsr 	$FFC3
.3880	20 cc ff	jsr $ffcc			jsr 	$FFCC 						; CLRCHN
.3883	60		rts				rts
.3884					IOSetFileName:
.3884	48		pha				pha 								; save R/W
.3885	86 2c		stx $2c				stx 	zTemp0
.3887	84 2d		sty $2d				sty 	zTemp0+1
.3889	a0 ff		ldy #$ff			ldy 	#$FF 						; copy name given
.388b					_IOSCopy:
.388b	c8		iny				iny 								; pre-increment copy
.388c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.388e	99 cd 06	sta $06cd,y			sta 	IONameBuffer,y
.3891	d0 f8		bne $388b			bne 	_IOSCopy
.3893	99 d1 06	sta $06d1,y			sta 	IONameBuffer+4,y
.3896	a9 2c		lda #$2c			lda 	#',' 						; append ,S,[R|W]
.3898	99 cd 06	sta $06cd,y			sta 	IONameBuffer+0,y
.389b	99 cf 06	sta $06cf,y			sta 	IONameBuffer+2,y
.389e	a9 53		lda #$53			lda 	#'S'
.38a0	99 ce 06	sta $06ce,y			sta 	IONameBuffer+1,y
.38a3	68		pla				pla 								; write R/W out
.38a4	99 d0 06	sta $06d0,y			sta 	IONameBuffer+3,y
.38a7	98		tya				tya 								; length of name to A
.38a8	18		clc				clc
.38a9	69 04		adc #$04			adc 	#4 							; we added 4 characters.
.38ab	a2 cd		ldx #$cd			ldx 	#IONameBuffer & $FF			; name address to YX
.38ad	a0 06		ldy #$06			ldy 	#IONameBuffer >> 8
.38af	20 bd ff	jsr $ffbd		    jsr $FFBD              				; call SETNAM
.38b2	a9 03		lda #$03	    	lda 	#3 							; set LFS to 3,8,3
.38b4	a2 08		ldx #$08			ldx 	#8
.38b6	a0 03		ldy #$03			ldy 	#3
.38b8	20 ba ff	jsr $ffba			jsr 	$FFBA
.38bb	20 c0 ff	jsr $ffc0			jsr 	$FFC0 						; OPEN
.38be	60		rts				rts
.06cd					IONameBuffer:
>06cd							.fill 	64
.38bf					IOOpenWrite:
.38bf	a9 57		lda #$57			lda 	#'W'			 			; write
.38c1	20 84 38	jsr $3884			jsr 	IOSetFileName 				; set up name/LFS
.38c4	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for writing
.38c6	20 c9 ff	jsr $ffc9			jsr 	$FFC9 						; CHKOUT
.38c9	60		rts				rts
.38ca					IOWriteByte:
.38ca	48		pha				pha
.38cb	da		phx				phx
.38cc	5a		phy				phy
.38cd	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.38d0	7a		ply				ply
.38d1	fa		plx				plx
.38d2	68		pla				pla
.38d3	60		rts				rts

;******  Processing input file: source/main/zzfree.footer

.38d4					FreeMemory:

;******  End of listing
