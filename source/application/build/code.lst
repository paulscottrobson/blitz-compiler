
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl source/main/00main.header /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library _library.asm source/main/zzfree.footer
; Mon Oct  9 02:19:12 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: source/main/00main.header

.0801					StartBasicProgram:
>0801	0c 08						.word 	$080C 						; offset to next.
>0803	0a 00						.word 	10 							; line #
>0805	9e						.byte 	$9E 						; token for 'SYS'
>0806	20 32 30 36 32					.text 	' 2062'						; space, $080E in decimal
>080b	00						.byte  	0 							; end of line
>080c	00 00						.word 	0 							; end of program
>080e	db						.byte 	$DB 						; causes a break in the emulator

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.080f					StartRuntime:
.080f	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.0812	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.0814	64 28		stz $28				stz 	codePtr
.0816	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0819	8c 06 04	sty $0406			sty 	storeEndHigh
.081c	8e 07 04	stx $0407			stx 	variableStartPage
.081f	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.0821	a2 29		ldx #$29			ldx 	#RuntimeErrorHandler & $FF
.0823	20 b0 1e	jsr $1eb0			jsr 	SetErrorHandler
.0826	20 58 0a	jsr $0a58			jsr 	ClearMemory 				; clear memory.
.0829	20 37 16	jsr $1637			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.082c	20 39 13	jsr $1339		 	jsr		SetDefaultChannel			; set default input/output channel.
.082f	20 6f 15	jsr $156f			jsr 	RestoreCode 				; which we now call
.0832	a0 00		ldy #$00			ldy 	#0
.0834					NextCommand:
.0834	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.0836	30 5b		bmi $0893			bmi 	NXCommand 					; -if -ve command
.0838	c8		iny				iny
.0839	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.083b	90 39		bcc $0876			bcc 	PushByteA 					; 0..63 is short constants.
.083d					NXLoadStore:
.083d	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.083f	b0 19		bcs $085a			bcs 	NXIndirectLoadStore
.0841	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.0842	4a		lsr a				lsr 	a
.0843	29 0e		and #$0e			and 	#$0E
.0845	da		phx				phx 								; get ready to jump
.0846	aa		tax				tax
.0847	7c 4a 08	jmp ($084a,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.084a					ReadWriteVectors:
>084a	a5 14						.word 	ReadFloatCommand			; read float
>084c	80 1a						.word 	WriteFloatCommand 			; write float
>084e	e1 14						.word 	ReadIntegerCommand 			; read integer
>0850	bc 1a						.word 	WriteIntegerCommand 		; write integer
>0852	26 15						.word 	ReadStringCommand 			; read string
>0854	fb 1a						.word 	WriteStringCommand 			; write string
>0856	26 0c						.word 	Unimplemented
>0858	26 0c						.word 	Unimplemented
.085a					NXIndirectLoadStore:
.085a	29 07		and #$07			and 	#7
.085c	0a		asl a				asl 	a
.085d	da		phx				phx
.085e	aa		tax				tax
.085f	7c 62 08	jmp ($0862,x)			jmp 	(IndirectVectors,x)
.0862					IndirectVectors:
>0862	db 0e						.word 	IndFloatRead 				; float read
>0864	ef 0e						.word 	IndInt16Read 				; int16 read
>0866	03 0f						.word 	IndStringRead 				; string read
>0868	26 0c						.word 	Unimplemented
>086a	17 0f						.word 	IndFloatWrite				; float write
>086c	2b 0f						.word 	IndInt16Write 				; int16 write
>086e	3f 0f						.word 	IndStringWrite 				; string write
>0870	26 0c						.word 	Unimplemented
.0872					PushByteCommand:
.0872	fa		plx				plx
.0873	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.0875	c8		iny				iny
.0876					PushByteA:
.0876	e8		inx				inx 								; push constant on stack
.0877	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.0879	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.087b					ClearRestWord:
.087b	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.087d	74 62		stz $62,x			stz 	NSMantissa3,x
.087f	74 6e		stz $6e,x			stz 	NSExponent,x
.0881	74 32		stz $32,x			stz 	NSStatus,x
.0883	80 af		bra $0834			bra 	NextCommand
.0885					PushWordCommand:
.0885	fa		plx				plx
.0886	e8		inx				inx
.0887	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.0889	c8		iny				iny
.088a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.088c	b1 28		lda ($28),y			lda 	(codePtr),y
.088e	c8		iny				iny
.088f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0891	80 e8		bra $087b			bra 	ClearRestWord 				; handle everything else.
.0893					NXCommand:
.0893	c8		iny				iny 								; consume command.
.0894	10 03		bpl $0899			bpl 	_NXCommandNoFixUp
.0896	20 9f 08	jsr $089f			jsr 	FixUpY
.0899					_NXCommandNoFixUp:
.0899	0a		asl a				asl 	a 							; shift left
.089a	da		phx				phx 								; save SP on stack
.089b	aa		tax				tax				 					; and jump indirect
.089c	7c 61 19	jmp ($1961,x)			jmp 	(VectorTable,x)
.089f					FixUpY:
.089f	48		pha				pha
.08a0	98		tya				tya
.08a1	18		clc				clc
.08a2	65 28		adc $28				adc 	codePtr
.08a4	85 28		sta $28				sta 	codePtr
.08a6	90 02		bcc $08aa			bcc 	_NoCPCarry
.08a8	e6 29		inc $29				inc 	codePtr+1
.08aa					_NoCPCarry:
.08aa	a0 00		ldy #$00			ldy 	#0
.08ac	68		pla				pla
.08ad	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.08ae					AbsoluteTOS:
.08ae	fa		plx				plx
.08af	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08b1	4c 34 08	jmp $0834			jmp 	NextCommand
.08b4					CommandVarSpace:
.08b4	fa		plx				plx
.08b5	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08b7	85 26		sta $26				sta 	availableMemory
.08b9	c8		iny				iny
.08ba	b1 28		lda ($28),y			lda 	(codePtr),y
.08bc	18		clc				clc
.08bd	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08c0	85 27		sta $27				sta 	availableMemory+1
.08c2	c8		iny				iny
.08c3	4c 34 08	jmp $0834			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08c6					BinaryAnd:
.08c6	fa		plx				plx
.08c7	38		sec				sec
.08c8	80 02		bra $08cc			bra 	AndOrCommon
.08ca					BinaryOr:
.08ca	fa		plx				plx
.08cb	18		clc				clc
.08cc					AndOrCommon:
.08cc	08		php				php 								; save AND/OR flag
.08cd	20 16 10	jsr $1016			jsr 	GetInteger16Bit
.08d0	ca		dex				dex
.08d1	20 16 10	jsr $1016			jsr 	GetInteger16Bit
.08d4	28		plp				plp
.08d5	90 0e		bcc $08e5			bcc 	_AOCOrCode
.08d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.08d9	35 3f		and $3f,x			and		NSMantissa0+1,x
.08db	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08dd	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.08df	35 4b		and $4b,x			and		NSMantissa1+1,x
.08e1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08e3	80 0c		bra $08f1			bra 	_AOCComplete
.08e5					_AOCOrCode:
.08e5	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.08e7	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.08e9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08eb	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.08ed	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.08ef	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08f1					_AOCComplete:
.08f1	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.08f3	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.08f5	10 07		bpl $08fe			bpl 	_AOCExit
.08f7	20 26 10	jsr $1026			jsr 	Negate16Bit 				; 2's complement
.08fa	a9 80		lda #$80			lda 	#$80 						; make it -ve
.08fc	95 32		sta $32,x			sta 	NSStatus,x
.08fe					_AOCExit:
.08fe	4c 34 08	jmp $0834			jmp 	NextCommand
.0901					ArrayConvert:
.0901	fa		plx				plx
.0902	5a		phy				phy
.0903	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0905	85 2e		sta $2e				sta 	zTemp1
.0907	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0909	18		clc				clc
.090a	6d 07 04	adc $0407			adc 	variableStartPage
.090d	85 2f		sta $2f				sta 	zTemp1+1
.090f	ca		dex				dex 								; count of indices to follow -> zTemp2
.0910	20 10 10	jsr $1010			jsr 	GetInteger8Bit
.0913	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.0915	8a		txa				txa
.0916	38		sec				sec
.0917	e5 30		sbc $30				sbc 	zTemp2
.0919	aa		tax				tax
.091a	da		phx				phx 								; stack points at the first index, which will be replaced.
.091b					_ACIndexLoop:
.091b	20 58 22	jsr $2258			jsr 	FloatIntegerPart 			; integer array index
.091e	20 16 10	jsr $1016			jsr 	GetInteger16Bit 			; get the index => zTemp0
.0921	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.0923	a5 2c		lda $2c				lda 	zTemp0
.0925	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0927	a5 2d		lda $2d				lda 	zTemp0+1
.0929	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.092b	b0 79		bcs $09a6			bcs 	_ACBadIndex 				; index error.
.092d	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.092f	f0 29		beq $095a			beq 	_ACInnerLevel
.0931	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.0933	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0935	10 6f		bpl $09a6			bpl 	_ACBadIndex
.0937	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0939	26 2d		rol $2d				rol 	zTemp0+1
.093b	18		clc				clc
.093c	a5 2c		lda $2c				lda		zTemp0
.093e	65 2e		adc $2e				adc 	zTemp1
.0940	85 2c		sta $2c				sta 	zTemp0
.0942	a5 2d		lda $2d				lda		zTemp0+1
.0944	65 2f		adc $2f				adc 	zTemp1+1
.0946	85 2d		sta $2d				sta 	zTemp0+1
.0948	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.094a	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.094c	85 2e		sta $2e				sta 	zTemp1
.094e	c8		iny				iny
.094f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0951	18		clc				clc
.0952	6d 07 04	adc $0407			adc 	variableStartPage
.0955	85 2f		sta $2f				sta 	zTemp1+1
.0957	e8		inx				inx 								; next index
.0958	80 c1		bra $091b			bra 	_ACIndexLoop
.095a					_ACInnerLevel:
.095a	a0 02		ldy #$02			ldy 	#2
.095c	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.095e	30 46		bmi $09a6			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.0960	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.0962	c9 00		cmp #$00			cmp 	#NSSIFloat
.0964	d0 13		bne $0979			bne 	_ACNotFloat
.0966	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.0968	48		pha				pha
.0969	a5 2c		lda $2c				lda 	zTemp0
.096b	06 2c		asl $2c				asl 	zTemp0 						; x 2
.096d	26 2d		rol $2d				rol 	zTemp0+1
.096f	18		clc				clc 								; add back x 3
.0970	65 2c		adc $2c				adc 	zTemp0
.0972	85 2c		sta $2c				sta 	zTemp0
.0974	68		pla				pla
.0975	65 2d		adc $2d				adc 	zTemp0+1
.0977	85 2d		sta $2d				sta 	zTemp0+1
.0979					_ACNotFloat:
.0979	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.097b	26 2d		rol $2d				rol 	zTemp0+1
.097d	18		clc				clc
.097e	a5 2c		lda $2c				lda 	zTemp0
.0980	69 03		adc #$03			adc 	#3
.0982	85 2c		sta $2c				sta 	zTemp0
.0984	90 02		bcc $0988			bcc 	_ACNoCarry
.0986	e6 2d		inc $2d				inc 	zTemp0+1
.0988					_ACNoCarry:
.0988	fa		plx				plx 								; X points to first slot of array parameters
.0989	18		clc				clc
.098a	a5 2c		lda $2c				lda 	zTemp0
.098c	65 2e		adc $2e				adc 	zTemp1
.098e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0990	a5 2d		lda $2d				lda 	zTemp0+1
.0992	65 2f		adc $2f				adc 	zTemp1+1
.0994	38		sec				sec
.0995	ed 07 04	sbc $0407			sbc 	variableStartPage
.0998	95 4a		sta $4a,x			sta 	NSMantissa1,x
.099a	74 56		stz $56,x			stz 	NSMantissa2,x
.099c	74 62		stz $62,x			stz 	NSMantissa3,x
.099e	74 32		stz $32,x			stz 	NSStatus,x
.09a0	74 6e		stz $6e,x			stz 	NSExponent,x
.09a2	7a		ply				ply 	 							; restore code pointer
.09a3	4c 34 08	jmp $0834			jmp 	NextCommand
.09a6					_ACBadIndex:
.09a6	4c b2 1f	jmp $1fb2		jmp	ErrorV_index
.09a9					UnaryAsc:
.09a9	fa		plx				plx
.09aa	5a		phy				phy
.09ab	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09ad	85 2c		sta $2c				sta 	zTemp0
.09af	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09b1	85 2d		sta $2d				sta 	zTemp0+1
.09b3	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09b5	f0 06		beq $09bd			beq 	_UAExit
.09b7	5a		phy				phy 								; otherwise first character
.09b8	a0 01		ldy #$01			ldy 	#1
.09ba	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09bc	7a		ply				ply
.09bd					_UAExit:
.09bd	20 1f 26	jsr $261f			jsr 	FloatSetByte
.09c0	7a		ply				ply
.09c1	4c 34 08	jmp $0834			jmp 	NextCommand
.09c4					CommandAssert:
.09c4	fa		plx				plx
.09c5	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09c7	d0 09		bne $09d2			bne 	_CAFail
.09c9	20 3f 26	jsr $263f			jsr 	FloatIsZero 				; is it zero ?
.09cc	f0 04		beq $09d2			beq 	_CAFail
.09ce	ca		dex				dex
.09cf	4c 34 08	jmp $0834			jmp 	NextCommand
.09d2					_CAFail:
.09d2	4c 0b 1f	jmp $1f0b		jmp	ErrorV_assert
.09d5					X16_Audio_Parameters8_16:
.09d5	20 db 09	jsr $09db			jsr 	X16_Audio_Parameters8_8
.09d8	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.09da	60		rts				rts
.09db					X16_Audio_Parameters8_8:
.09db	a2 01		ldx #$01			ldx 	#1
.09dd	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.09e0	ca		dex				dex
.09e1	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.09e4	20 10 10	jsr $1010			jsr 	GetInteger8Bit
.09e7	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.09e9	a0 00		ldy #$00			ldy 	#0
.09eb	60		rts				rts
.09ec					X16_Audio_Parameters8_String:
.09ec	20 d5 09	jsr $09d5			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.09ef	da		phx				phx 								; set the voice
.09f0	5a		phy				phy
.09f1	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.09f4	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>09f7	0a						.byte 	X16_AudioCodeBank
.09f8	7a		ply				ply
.09f9	fa		plx				plx
.09fa	86 2c		stx $2c				stx 	zTemp0
.09fc	84 2d		sty $2d				sty 	zTemp0+1
.09fe	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a00	e8		inx				inx 								; point YX to first character.
.0a01	d0 01		bne $0a04			bne 	_X16APSSkip
.0a03	c8		iny				iny
.0a04					_X16APSSkip:
.0a04	60		rts				rts
.0a05					Unary16Bin:
.0a05	fa		plx				plx
.0a06	20 16 10	jsr $1016			jsr 	GetInteger16Bit				; 16 bit int
.0a09	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a0b	20 e0 16	jsr $16e0			jsr 	StringAllocTemp
.0a0e	a5 2d		lda $2d				lda 	zTemp0+1
.0a10	f0 03		beq $0a15			beq 	_UBNoHigh
.0a12	20 1d 0a	jsr $0a1d			jsr 	_UBWriteBinary
.0a15					_UBNoHigh:
.0a15	a5 2c		lda $2c				lda 	zTemp0
.0a17	20 1d 0a	jsr $0a1d			jsr 	_UBWriteBinary
.0a1a	4c 34 08	jmp $0834			jmp 	NextCommand
.0a1d					_UBWriteBinary:
.0a1d	5a		phy				phy
.0a1e	a0 08		ldy #$08			ldy 	#8
.0a20					_UBWLoop:
.0a20	0a		asl a				asl 	a
.0a21	48		pha				pha
.0a22	a9 00		lda #$00			lda  	#0
.0a24	69 30		adc #$30			adc 	#48
.0a26	20 09 17	jsr $1709			jsr 	StringWriteChar
.0a29	68		pla				pla
.0a2a	88		dey				dey
.0a2b	d0 f3		bne $0a20			bne 	_UBWLoop
.0a2d	7a		ply				ply
.0a2e	60		rts				rts
.0a2f					PrintCharacterX:
.0a2f	fa		plx				plx
.0a30	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a32	ca		dex				dex
.0a33	20 3d 13	jsr $133d			jsr 	VectorPrintCharacter
.0a36	4c 34 08	jmp $0834			jmp 	NextCommand
.0a39					UnaryChr:
.0a39	fa		plx				plx
.0a3a	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; get integer to convert.
.0a3d	48		pha				pha 								; save it and allocate for it
.0a3e	a9 01		lda #$01			lda 	#1 							; 1 character
.0a40	20 e0 16	jsr $16e0			jsr 	StringAllocTemp
.0a43	a9 01		lda #$01			lda 	#1 							; length 1.
.0a45	92 22		sta ($22)			sta 	(zsTemp)
.0a47	68		pla				pla 								; character code makes string.
.0a48	5a		phy				phy
.0a49	a0 01		ldy #$01			ldy 	#1
.0a4b	91 22		sta ($22),y			sta 	(zsTemp),y
.0a4d	7a		ply				ply
.0a4e	4c 34 08	jmp $0834			jmp 	NextCommand
.0a51					CommandClr:
.0a51	fa		plx				plx
.0a52	20 58 0a	jsr $0a58			jsr 	ClearMemory
.0a55	4c 34 08	jmp $0834			jmp 	NextCommand
.0a58					ClearMemory:
.0a58	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a5b	85 2d		sta $2d				sta 	zTemp0+1
.0a5d	64 2c		stz $2c				stz 	zTemp0
.0a5f	5a		phy				phy
.0a60	a0 00		ldy #$00			ldy 	#0
.0a62					_ClearLoop1:
.0a62	a9 00		lda #$00			lda 	#0
.0a64	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a66	c8		iny				iny
.0a67	d0 f9		bne $0a62			bne 	_ClearLoop1
.0a69	e6 2d		inc $2d				inc 	zTemp0+1
.0a6b	a5 2d		lda $2d				lda 	zTemp0+1
.0a6d	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a70	d0 f0		bne $0a62			bne 	_ClearLoop1
.0a72	38		sec				sec 											; stack space = number of pages in total / 4
.0a73	ad 06 04	lda $0406			lda 	storeEndHigh
.0a76	ed 05 04	sbc $0405			sbc		storeStartHigh
.0a79	4a		lsr a				lsr 	a
.0a7a	4a		lsr a				lsr 	a
.0a7b	d0 02		bne $0a7f			bne 	_NotEmpty 								; at least 1 !
.0a7d	a9 01		lda #$01			lda 	#1
.0a7f					_NotEmpty:
.0a7f	38		sec				sec 											; subtract from high to give string high memory
.0a80	49 ff		eor #$ff			eor 	#$FF
.0a82	6d 06 04	adc $0406			adc 	storeEndHigh
.0a85	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0a88	9c 02 04	stz $0402			stz 	stringHighMemory
.0a8b	9c 68 05	stz $0568			stz 	stringInitialised 						; string system not initialised
.0a8e	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0a91	3a		dec a				dec 	a
.0a92	85 25		sta $25				sta 	runtimeStackPtr+1
.0a94	a9 ff		lda #$ff			lda 	#$FF
.0a96	85 24		sta $24				sta 	runtimeStackPtr
.0a98	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0a9a	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0a9c	7a		ply				ply
.0a9d	60		rts				rts
.0a9e					CompareStrings:
.0a9e	fa		plx				plx
.0a9f	ca		dex				dex
.0aa0	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0aa2	85 2c		sta $2c				sta 	zTemp0
.0aa4	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0aa6	85 2d		sta $2d				sta 	zTemp0+1
.0aa8	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0aaa	85 2e		sta $2e				sta 	zTemp1
.0aac	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0aae	85 2f		sta $2f				sta 	zTemp1+1
.0ab0	da		phx				phx
.0ab1	5a		phy				phy
.0ab2	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0ab4	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0ab6	90 02		bcc $0aba			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0ab8	b2 2e		lda ($2e)			lda 	(zTemp1)
.0aba					_CSNIsSmallest:
.0aba	aa		tax				tax 								; count in X
.0abb	f0 0c		beq $0ac9			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0abd	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0abf					_CSNCompareString:
.0abf	c8		iny				iny 								; pre increment
.0ac0	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0ac2	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0ac4	d0 0a		bne $0ad0			bne 	_CSNDifferent 				; numbers are different.
.0ac6	ca		dex				dex
.0ac7	d0 f6		bne $0abf			bne 	_CSNCompareString 			; compare common characters in two strings.
.0ac9					_CSNMatches:
.0ac9	38		sec				sec
.0aca	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0acc	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0ace	f0 06		beq $0ad6			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0ad0					_CSNDifferent:
.0ad0	a9 ff		lda #$ff			lda 	#$FF
.0ad2	90 02		bcc $0ad6			bcc 	_CSNSExit
.0ad4	a9 01		lda #$01			lda 	#$01
.0ad6					_CSNSExit:
.0ad6	7a		ply				ply
.0ad7	fa		plx				plx
.0ad8	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0ada	20 1f 26	jsr $261f			jsr 	FloatSetByte 				; output the byte
.0add	4c 34 08	jmp $0834			jmp 	NextCommand
.0ae0					StringConcrete:
.0ae0	9c 68 05	stz $0568			stz 	stringInitialised	 		; initialise next usage
.0ae3	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0ae5	85 30		sta $30				sta 	zTemp2
.0ae7	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0ae9	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0aea	18		clc				clc
.0aeb	72 30		adc ($30)			adc 	(zTemp2)
.0aed	90 02		bcc $0af1			bcc 	_SCNoOverflow
.0aef	a9 ff		lda #$ff			lda 	#255
.0af1					_SCNoOverflow:
.0af1	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0af3	b0 02		bcs $0af7			bcs 	_SCNoMinimum
.0af5	a9 0a		lda #$0a			lda 	#10
.0af7					_SCNoMinimum:
.0af7	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0af9	38		sec				sec
.0afa	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0afd	e5 2e		sbc $2e				sbc 	zTemp1
.0aff	a8		tay				tay
.0b00	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b03	e9 00		sbc #$00			sbc 	#0
.0b05	48		pha				pha
.0b06	38		sec				sec 								; subtract 3 more
.0b07	98		tya				tya
.0b08	e9 03		sbc #$03			sbc 	#3
.0b0a	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b0d	85 22		sta $22				sta 	zsTemp
.0b0f	68		pla				pla
.0b10	e9 00		sbc #$00			sbc 	#0
.0b12	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b15	85 23		sta $23				sta 	zsTemp+1
.0b17	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b19	92 22		sta ($22)			sta 	(zsTemp)
.0b1b	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b1d	a9 00		lda #$00			lda 	#0
.0b1f	91 22		sta ($22),y			sta 	(zsTemp),y
.0b21	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b23	a4 23		ldy $23				ldy 	zsTemp+1
.0b25	60		rts				rts
.0b26					CommandXData:
.0b26	fa		plx				plx
.0b27	98		tya				tya 								; data length +1 added to Y
.0b28	38		sec				sec
.0b29	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b2b	a8		tay				tay
.0b2c	4c 34 08	jmp $0834			jmp 	NextCommand
.0b2f					CommandXDIM:
.0b2f	fa		plx				plx
.0b30	5a		phy				phy
.0b31	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b34	8d 08 04	sta $0408			sta 	dimType
.0b37	ca		dex				dex 								; this is the number of indices
.0b38	20 10 10	jsr $1010			jsr 	GetInteger8Bit
.0b3b	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b3d	8a		txa				txa 								; dimension.
.0b3e	38		sec				sec
.0b3f	e5 2e		sbc $2e				sbc 	zTemp1
.0b41	aa		tax				tax
.0b42	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b44	20 58 0b	jsr $0b58			jsr 	DIMCreateOneLevel 			; create one at this level
.0b47	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b49	98		tya				tya
.0b4a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b4c	74 56		stz $56,x			stz 	NSMantissa2,x
.0b4e	74 62		stz $62,x			stz 	NSMantissa3,x
.0b50	74 32		stz $32,x			stz 	NSStatus,x
.0b52	74 6e		stz $6e,x			stz 	NSExponent,x
.0b54	7a		ply				ply
.0b55	4c 34 08	jmp $0834			jmp 	NextCommand
.0b58					DIMCreateOneLevel:
.0b58	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b5a	5a		phy				phy
.0b5b	a4 27		ldy $27				ldy 	availableMemory+1
.0b5d	5a		phy				phy
.0b5e	a8		tay				tay 			 					; save current level into Y
.0b5f	20 16 10	jsr $1016			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b62	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b64	d0 02		bne $0b68			bne 	_DCOLNoCarry
.0b66	e6 2d		inc $2d				inc 	zTemp0+1
.0b68					_DCOLNoCarry:
.0b68	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b6a	20 0b 0c	jsr $0c0b			jsr 	DIMWriteByte
.0b6d	a5 2d		lda $2d				lda 	zTemp0+1
.0b6f	20 0b 0c	jsr $0c0b			jsr 	DIMWriteByte
.0b72	ad 08 04	lda $0408			lda 	dimType 					; get type information
.0b75	29 7f		and #$7f			and 	#$7F
.0b77	c0 01		cpy #$01			cpy 	#1
.0b79	f0 02		beq $0b7d			beq 	_DCOLNoSubLevel
.0b7b	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0b7d					_DCOLNoSubLevel:
.0b7d	20 0b 0c	jsr $0c0b			jsr 	DIMWriteByte
.0b80	a5 26		lda $26				lda 	availableMemory
.0b82	85 2e		sta $2e				sta 	zTemp1
.0b84	a5 27		lda $27				lda 	availableMemory+1
.0b86	85 2f		sta $2f				sta 	zTemp1+1
.0b88	a5 2c		lda $2c				lda 	zTemp0
.0b8a	85 30		sta $30				sta 	zTemp2
.0b8c	a5 2d		lda $2d				lda 	zTemp0+1
.0b8e	85 31		sta $31				sta 	zTemp2+1
.0b90					_DCOLFillArray:
.0b90	20 ef 0b	jsr $0bef			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0b93	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0b95	d0 02		bne $0b99			bne 	_DCOLNoBorrow
.0b97	c6 2d		dec $2d				dec 	zTemp0+1
.0b99					_DCOLNoBorrow:
.0b99	c6 2c		dec $2c				dec 	zTemp0
.0b9b	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0b9d	05 2d		ora $2d				ora 	zTemp0+1
.0b9f	d0 ef		bne $0b90			bne 	_DCOLFillArray
.0ba1	c0 01		cpy #$01			cpy 	#1
.0ba3	f0 42		beq $0be7			beq 	_DCOLExit
.0ba5					_DCOLRecursionLoop:
.0ba5	da		phx				phx 								; save XY
.0ba6	5a		phy				phy
.0ba7	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0ba9	48		pha				pha
.0baa	a5 2f		lda $2f				lda 	zTemp1+1
.0bac	48		pha				pha
.0bad	a5 30		lda $30				lda 	zTemp2
.0baf	48		pha				pha
.0bb0	a5 31		lda $31				lda 	zTemp2+1
.0bb2	48		pha				pha
.0bb3	88		dey				dey  								; lower level -> A
.0bb4	98		tya				tya
.0bb5	e8		inx				inx 								; next index size
.0bb6	20 58 0b	jsr $0b58			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0bb9	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0bba	86 31		stx $31				stx 	zTemp2+1
.0bbc	fa		plx				plx
.0bbd	86 30		stx $30				stx 	zTemp2
.0bbf	fa		plx				plx
.0bc0	86 2f		stx $2f				stx 	zTemp1+1
.0bc2	fa		plx				plx
.0bc3	86 2e		stx $2e				stx 	zTemp1
.0bc5	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0bc7	98		tya				tya
.0bc8	a0 01		ldy #$01			ldy 	#1
.0bca	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0bcc	7a		ply				ply 								; restore XY
.0bcd	fa		plx				plx
.0bce	18		clc				clc
.0bcf	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0bd1	69 02		adc #$02			adc 	#2
.0bd3	85 2e		sta $2e				sta 	zTemp1
.0bd5	90 02		bcc $0bd9			bcc 	_DCOLRNoCarry
.0bd7	e6 2f		inc $2f				inc 	zTemp1+1
.0bd9					_DCOLRNoCarry:
.0bd9	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0bdb	d0 02		bne $0bdf			bne 	_DCOLRNoBorrow
.0bdd	c6 31		dec $31				dec 	zTemp2+1
.0bdf					_DCOLRNoBorrow:
.0bdf	c6 30		dec $30				dec 	zTemp2
.0be1	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0be3	05 31		ora $31				ora 	zTemp2+1
.0be5	d0 be		bne $0ba5			bne 	_DCOLRecursionLoop
.0be7					_DCOLExit:
.0be7	68		pla				pla 								; get MSB, make offset again
.0be8	38		sec				sec
.0be9	ed 07 04	sbc $0407			sbc 	variableStartPage
.0bec	a8		tay				tay
.0bed	68		pla				pla 								; YA now contains offset address.
.0bee	60		rts				rts
.0bef					DIMWriteElement:
.0bef	da		phx				phx
.0bf0	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0bf2	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0bf4	d0 0b		bne $0c01			bne 	_DIMWENotFloat
.0bf6	ad 08 04	lda $0408			lda 	dimType
.0bf9	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0bfb	c9 00		cmp #$00			cmp 	#NSSIFloat
.0bfd	d0 02		bne $0c01			bne 	_DIMWENotFloat
.0bff	a2 06		ldx #$06			ldx 	#6
.0c01					_DIMWENotFloat:
.0c01	a9 00		lda #$00			lda 	#0
.0c03	20 0b 0c	jsr $0c0b			jsr 	DIMWriteByte
.0c06	ca		dex				dex
.0c07	d0 f8		bne $0c01			bne 	_DIMWENotFloat
.0c09	fa		plx				plx
.0c0a	60		rts				rts
.0c0b					DIMWriteByte:
.0c0b	92 26		sta ($26)			sta 	(availableMemory)
.0c0d	e6 26		inc $26				inc 	availableMemory
.0c0f	d0 0b		bne $0c1c			bne 	_DIMWBSkip
.0c11	e6 27		inc $27				inc 	availableMemory+1
.0c13	48		pha				pha
.0c14	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c16	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c19	b0 02		bcs $0c1d			bcs 	_DIMWBMemory
.0c1b	68		pla				pla
.0c1c					_DIMWBSkip:
.0c1c	60		rts				rts
.0c1d					_DIMWBMemory:
.0c1d	4c c5 1f	jmp $1fc5		jmp	ErrorV_memory
.0408					dimType:
>0408							.fill 	1
.0c20					CommandEnd:
.0c20	fa		plx				plx
.0c21	86 2c		stx $2c				stx 	zTemp0
.0c23	4c ff ff	jmp $ffff			jmp 	$FFFF
.0c26					Unimplemented:
.0c26	4c f8 1e	jmp $1ef8			jmp 	ErrorV_unimplemented
.0c29					RuntimeErrorHandler:
.0c29	98		tya				tya
.0c2a	18		clc				clc
.0c2b	65 28		adc $28				adc 	codePtr
.0c2d	85 28		sta $28				sta 	codePtr
.0c2f	90 02		bcc $0c33			bcc 	_EHNoCarry
.0c31	e6 29		inc $29				inc 	codePtr+1
.0c33					_EHNoCarry:
.0c33	68		pla				pla
.0c34	7a		ply				ply
.0c35	85 2c		sta $2c				sta 	zTemp0
.0c37	84 2d		sty $2d				sty 	zTemp0+1
.0c39	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c3b	a0 01		ldy #$01			ldy 	#1
.0c3d					_EHDisplayMsg:
.0c3d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c3f	20 55 1c	jsr $1c55			jsr 	XPrintCharacterToChannel
.0c42	c8		iny				iny
.0c43	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c45	d0 f6		bne $0c3d			bne 	_EHDisplayMsg
.0c47	a9 20		lda #$20			lda 	#32
.0c49	20 55 1c	jsr $1c55			jsr 	XPrintCharacterToChannel
.0c4c	a9 40		lda #$40			lda 	#64
.0c4e	20 55 1c	jsr $1c55			jsr 	XPrintCharacterToChannel
.0c51	a9 20		lda #$20			lda 	#32
.0c53	20 55 1c	jsr $1c55			jsr 	XPrintCharacterToChannel
.0c56	20 5b 0c	jsr $0c5b			jsr 	EHDisplayCodePtr
.0c59	80 fe		bra $0c59	_EHStop:bra 	_EHStop
.0c5b					EHDisplayCodePtr:
.0c5b	a9 24		lda #$24			lda 	#'$'
.0c5d	20 55 1c	jsr $1c55			jsr 	XPrintCharacterToChannel
.0c60	38		sec				sec
.0c61	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c63	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c66	20 6f 0c	jsr $0c6f			jsr 	_EHDisplayHex
.0c69	a5 28		lda $28				lda 	codePtr
.0c6b	20 6f 0c	jsr $0c6f			jsr 	_EHDisplayHex
.0c6e	60		rts				rts
.0c6f					_EHDisplayHex:
.0c6f	48		pha				pha
.0c70	4a		lsr a				lsr 	a
.0c71	4a		lsr a				lsr 	a
.0c72	4a		lsr a				lsr 	a
.0c73	4a		lsr a				lsr 	a
.0c74	20 78 0c	jsr $0c78			jsr 	_EHDisplayNibble
.0c77	68		pla				pla
.0c78					_EHDisplayNibble:
.0c78	29 0f		and #$0f			and 	#15
.0c7a	c9 0a		cmp #$0a			cmp 	#10
.0c7c	90 02		bcc $0c80			bcc 	_EHNotHex
.0c7e	69 06		adc #$06			adc 	#6
.0c80					_EHNotHex:
.0c80	69 30		adc #$30			adc 	#48
.0c82	4c 55 1c	jmp $1c55			jmp 	XPrintCharacterToChannel
.0c85					CommandXFor:
.0c85	fa		plx				plx
.0c86	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0c88	20 08 0d	jsr $0d08			jsr 	StackOpenFrame
.0c8b	20 47 11	jsr $1147			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0c8e	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0c90	20 ea 0c	jsr $0cea			jsr 	CopyTOSToOffsetY
.0c93	ca		dex				dex
.0c94	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0c96	20 ea 0c	jsr $0cea			jsr 	CopyTOSToOffsetY
.0c99	ca		dex				dex
.0c9a	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0c9c	29 80		and #$80			and 	#$80
.0c9e	a0 04		ldy #$04			ldy 	#4
.0ca0	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ca2	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0ca4	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0ca6	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ca8	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0caa	c8		iny				iny
.0cab	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cad	18		clc				clc
.0cae	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0cb0	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cb2	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0cb5	85 2d		sta $2d				sta 	zTemp0+1
.0cb7	ca		dex				dex 								; throw reference.
.0cb8	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0cba	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0cbc	a0 0c		ldy #$0c			ldy 	#12
.0cbe	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cc0	a0 12		ldy #$12			ldy 	#18
.0cc2	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cc4	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0cc6	88		dey				dey 								; now the exponents.
.0cc7	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0cc9	a0 0b		ldy #$0b			ldy 	#11
.0ccb	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0ccd	a0 11		ldy #$11			ldy 	#17
.0ccf	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cd1	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0cd3	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cd5	c8		iny				iny
.0cd6	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cd8	c8		iny				iny
.0cd9	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cdb	d0 08		bne $0ce5			bne 	_CFNoOptimise
.0cdd	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0cdf	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0ce1	09 40		ora #$40			ora 	#$40
.0ce3	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ce5					_CFNoOptimise:
.0ce5	a0 00		ldy #$00			ldy 	#0
.0ce7	4c 34 08	jmp $0834			jmp 	NextCommand
.0cea					CopyTOSToOffsetY:
.0cea	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0cec	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cee	c8		iny				iny
.0cef	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cf1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cf3	c8		iny				iny
.0cf4	b5 56		lda $56,x			lda 	NSMantissa2,x
.0cf6	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cf8	c8		iny				iny
.0cf9	b5 62		lda $62,x			lda 	NSMantissa3,x
.0cfb	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cfd	c8		iny				iny
.0cfe	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d00	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d02	c8		iny				iny
.0d03	b5 32		lda $32,x			lda 	NSStatus,x
.0d05	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d07	60		rts				rts
.0d08					StackOpenFrame:
.0d08	48		pha				pha 								; save frame marker
.0d09	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d0b	85 2c		sta $2c				sta 	zTemp0
.0d0d	38		sec				sec 								; subtract from runtime stack pointer.
.0d0e	a5 24		lda $24				lda		runtimeStackPtr
.0d10	e5 2c		sbc $2c				sbc 	zTemp0
.0d12	85 24		sta $24				sta 	runtimeStackPtr
.0d14	a5 25		lda $25				lda		runtimeStackPtr+1
.0d16	e9 00		sbc #$00			sbc 	#0
.0d18	85 25		sta $25				sta 	runtimeStackPtr+1
.0d1a	68		pla				pla 								; put frame marker at +0
.0d1b	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d1d	60		rts				rts
.0d1e					StackCloseFrame:
.0d1e	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d20	29 1f		and #$1f			and 	#$1F 						; size
.0d22	18		clc				clc
.0d23	65 24		adc $24				adc 	runtimeStackPtr
.0d25	85 24		sta $24				sta 	runtimeStackPtr
.0d27	90 02		bcc $0d2b			bcc 	_SCFNoCarry
.0d29	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d2b					_SCFNoCarry:
.0d2b	60		rts				rts
.0d2c					StackFindFrame:
.0d2c	8d 09 04	sta $0409			sta 	requiredFrame
.0d2f					_SFFLoop:
.0d2f	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d31	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d33	f0 10		beq $0d45			beq 	SCFFail
.0d35	cd 09 04	cmp $0409			cmp 	requiredFrame 				; found this type ?
.0d38	f0 05		beq $0d3f			beq 	_SFFFound
.0d3a	20 1e 0d	jsr $0d1e			jsr 	StackCloseFrame 			; close the top frame
.0d3d	80 f0		bra $0d2f			bra 	_SFFLoop 					; and try te next.
.0d3f					_SFFFound:
.0d3f	60		rts				rts
.0d40					StackCheckFrame:
.0d40	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d42	d0 01		bne $0d45			bne 	SCFFail
.0d44	60		rts				rts
.0d45					SCFFail:
.0d45	4c 55 1f	jmp $1f55		jmp	ErrorV_structure
.0409					requiredFrame:
>0409							.fill 	1
.0d48					UnaryFre:
.0d48	fa		plx				plx
.0d49	20 1d 26	jsr $261d			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d4c	38		sec				sec
.0d4d	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d50	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d53	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d55	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d58	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d5b	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d5d	4c 34 08	jmp $0834			jmp 	NextCommand
.0d60					CommandXGet:
.0d60	fa		plx				plx
.0d61	e8		inx				inx
.0d62	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d64	20 e0 16	jsr $16e0			jsr 	StringAllocTemp
.0d67	20 46 13	jsr $1346			jsr 	VectorGetCharacter 			; get a character
.0d6a	c9 00		cmp #$00			cmp 	#0
.0d6c	f0 09		beq $0d77			beq 	_CGNone
.0d6e	5a		phy				phy
.0d6f	a0 01		ldy #$01			ldy 	#1 							; store char
.0d71	91 22		sta ($22),y			sta 	(zsTemp),y
.0d73	98		tya				tya 								; store length.
.0d74	92 22		sta ($22)			sta 	(zsTemp)
.0d76	7a		ply				ply
.0d77					_CGNone:
.0d77	4c 34 08	jmp $0834			jmp 	NextCommand
.0d7a					CommandXGosub:
.0d7a	fa		plx				plx
.0d7b	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0d7d	20 08 0d	jsr $0d08			jsr 	StackOpenFrame
.0d80	20 47 11	jsr $1147			jsr 	StackSaveCurrentPosition
.0d83	4c 98 0d	jmp $0d98			jmp 	PerformGOTO
.0d86					CommandReturn:
.0d86	fa		plx				plx
.0d87	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0d89	20 2c 0d	jsr $0d2c			jsr 	StackFindFrame
.0d8c	20 58 11	jsr $1158			jsr 	StackLoadCurrentPosition
.0d8f	c8		iny				iny
.0d90	c8		iny				iny
.0d91	20 1e 0d	jsr $0d1e			jsr 	StackCloseFrame
.0d94	4c 34 08	jmp $0834			jmp 	NextCommand
.0d97					CommandXGoto:
.0d97	fa		plx				plx
.0d98					PerformGOTO:
.0d98	c8		iny				iny 								; push MSB of offset on stack
.0d99	b1 28		lda ($28),y			lda 	(codePtr),y
.0d9b	48		pha				pha
.0d9c	88		dey				dey 								; point LSB of offset
.0d9d	18		clc				clc 								; add LSB
.0d9e	b1 28		lda ($28),y			lda 	(codePtr),y
.0da0	65 28		adc $28				adc 	codePtr
.0da2	85 28		sta $28				sta 	codePtr
.0da4	68		pla				pla 								; restore offset MSB and add
.0da5	65 29		adc $29				adc 	codePtr+1
.0da7	85 29		sta $29				sta 	codePtr+1
.0da9	4c 34 08	jmp $0834			jmp 	NextCommand
.0dac					CommandGotoZ:
.0dac	fa		plx				plx
.0dad	20 3f 26	jsr $263f			jsr 	FloatIsZero
.0db0	ca		dex				dex
.0db1	c9 00		cmp #$00			cmp 	#0
.0db3	f0 e3		beq $0d98			beq 	PerformGOTO
.0db5	c8		iny				iny
.0db6	c8		iny				iny
.0db7	4c 34 08	jmp $0834			jmp 	NextCommand
.0dba					CommandGotoNZ:
.0dba	fa		plx				plx
.0dbb	20 3f 26	jsr $263f			jsr 	FloatIsZero
.0dbe	ca		dex				dex
.0dbf	c9 00		cmp #$00			cmp 	#0
.0dc1	d0 d5		bne $0d98			bne 	PerformGOTO
.0dc3	c8		iny				iny
.0dc4	c8		iny				iny
.0dc5	4c 34 08	jmp $0834			jmp 	NextCommand
.0dc8					Command_PSET:
.0dc8	fa		plx				plx
.0dc9	5a		phy				phy
.0dca	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; get the colour
.0dcd	48		pha				pha
.0dce	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0dd0	a0 02		ldy #$02			ldy 	#X16_r0
.0dd2	20 54 0e	jsr $0e54			jsr 	GraphicsCopy2
.0dd5	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0dd8	68		pla				pla 								; set pixel.
.0dd9	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0ddc	7a		ply				ply
.0ddd	a2 ff		ldx #$ff			ldx 	#$FF
.0ddf	4c 34 08	jmp $0834			jmp 	NextCommand
.0de2					Command_LINE:
.0de2	fa		plx				plx
.0de3	5a		phy				phy
.0de4	20 47 0e	jsr $0e47			jsr 	GraphicsColour
.0de7	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0de9	a0 02		ldy #$02			ldy 	#X16_r0
.0deb	20 51 0e	jsr $0e51			jsr 	GraphicsCopy4
.0dee	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0df1	7a		ply				ply
.0df2	a2 ff		ldx #$ff			ldx 	#$FF
.0df4	4c 34 08	jmp $0834			jmp 	NextCommand
.0df7					Command_RECT:
.0df7	fa		plx				plx
.0df8	5a		phy				phy
.0df9	20 68 0e	jsr $0e68			jsr 	GraphicsRectCoords
.0dfc	38		sec				sec
.0dfd	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e00	7a		ply				ply
.0e01	a2 ff		ldx #$ff			ldx 	#$FF
.0e03	4c 34 08	jmp $0834			jmp 	NextCommand
.0e06					Command_FRAME:
.0e06	fa		plx				plx
.0e07	5a		phy				phy
.0e08	20 68 0e	jsr $0e68			jsr 	GraphicsRectCoords
.0e0b	18		clc				clc
.0e0c	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e0f	7a		ply				ply
.0e10	a2 ff		ldx #$ff			ldx 	#$FF
.0e12	4c 34 08	jmp $0834			jmp 	NextCommand
.0e15					Command_CHAR:
.0e15	fa		plx				plx
.0e16	5a		phy				phy
.0e17	ca		dex				dex  								; set the draw colour
.0e18	20 47 0e	jsr $0e47			jsr 	GraphicsColour
.0e1b	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e1d	a0 02		ldy #$02			ldy 	#X16_r0
.0e1f	20 54 0e	jsr $0e54			jsr 	GraphicsCopy2
.0e22	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e24	85 2c		sta $2c				sta 	zTemp0
.0e26	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e28	85 2d		sta $2d				sta 	zTemp0+1
.0e2a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e2c	85 2e		sta $2e				sta 	zTemp1
.0e2e					_CCLoop:
.0e2e	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e30	f0 0f		beq $0e41			beq 	_CCExit
.0e32	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e34	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e36	d0 02		bne $0e3a			bne 	_CCNoCarry
.0e38	e6 2d		inc $2d				inc 	zTemp0+1
.0e3a					_CCNoCarry:
.0e3a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e3c	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e3f	80 ed		bra $0e2e			bra 	_CCLoop						; go round.
.0e41					_CCExit:
.0e41	7a		ply				ply
.0e42	a2 ff		ldx #$ff			ldx 	#$FF
.0e44	4c 34 08	jmp $0834			jmp 	NextCommand
.0e47					GraphicsColour:
.0e47	20 10 10	jsr $1010			jsr 	GetInteger8Bit
.0e4a	aa		tax				tax
.0e4b	a0 00		ldy #$00			ldy 	#0
.0e4d	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e50	60		rts				rts
.0e51					GraphicsCopy4:
.0e51	20 54 0e	jsr $0e54			jsr 	GraphicsCopy2
.0e54					GraphicsCopy2:
.0e54	20 57 0e	jsr $0e57			jsr 	GraphicsCopy1
.0e57					GraphicsCopy1:
.0e57	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.0e5a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e5c	99 00 00	sta $0000,y			sta 	0,y
.0e5f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e61	99 01 00	sta $0001,y			sta 	1,y
.0e64	e8		inx				inx
.0e65	c8		iny				iny
.0e66	c8		iny				iny
.0e67	60		rts				rts
.0e68					GraphicsRectCoords:
.0e68	20 47 0e	jsr $0e47			jsr 	GraphicsColour 				; set colour
.0e6b	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e6d	a0 02		ldy #$02			ldy 	#X16_r0
.0e6f	20 51 0e	jsr $0e51			jsr 	GraphicsCopy4
.0e72	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0e74	20 81 0e	jsr $0e81			jsr 	_GRCSortSubtract
.0e77	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0e79	20 81 0e	jsr $0e81			jsr 	_GRCSortSubtract
.0e7c	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0e7e	74 09		stz $09,x			stz 	9,x
.0e80	60		rts				rts
.0e81					_GRCSortSubtract:
.0e81	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0e83	d5 00		cmp $00,x			cmp 	0,x
.0e85	b5 05		lda $05,x			lda 	5,x
.0e87	f5 01		sbc $01,x			sbc 	1,x
.0e89	b0 08		bcs $0e93			bcs 	_GRCNoSwap 					; >= swap.
.0e8b	20 a1 0e	jsr $0ea1			jsr 	_GRCSwapByte 				; swap 0/2
.0e8e	e8		inx				inx
.0e8f	20 a1 0e	jsr $0ea1			jsr 	_GRCSwapByte 				; swap 1/3
.0e92	ca		dex				dex
.0e93					_GRCNoSwap:
.0e93	38		sec				sec 								; calculate width/height into 4,5
.0e94	b5 04		lda $04,x			lda 	4,x
.0e96	f5 00		sbc $00,x			sbc 	0,x
.0e98	95 04		sta $04,x			sta 	4,x
.0e9a	b5 05		lda $05,x			lda 	5,x
.0e9c	f5 01		sbc $01,x			sbc 	1,x
.0e9e	95 05		sta $05,x			sta 	5,x
.0ea0	60		rts				rts
.0ea1					_GRCSwapByte:
.0ea1	b5 04		lda $04,x			lda 	4,x
.0ea3	48		pha				pha
.0ea4	b5 00		lda $00,x			lda 	0,x
.0ea6	95 04		sta $04,x			sta 	4,x
.0ea8	68		pla				pla
.0ea9	95 00		sta $00,x			sta 	0,x
.0eab	60		rts				rts
.0eac					Unary16Hex:
.0eac	fa		plx				plx
.0ead	20 16 10	jsr $1016			jsr 	GetInteger16Bit
.0eb0	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0eb2	20 e0 16	jsr $16e0			jsr 	StringAllocTemp
.0eb5	a5 2d		lda $2d				lda 	zTemp0+1
.0eb7	f0 03		beq $0ebc			beq 	_UHNoHigh
.0eb9	20 c4 0e	jsr $0ec4			jsr 	_UHWriteHex
.0ebc					_UHNoHigh:
.0ebc	a5 2c		lda $2c				lda 	zTemp0
.0ebe	20 c4 0e	jsr $0ec4			jsr 	_UHWriteHex
.0ec1	4c 34 08	jmp $0834			jmp 	NextCommand
.0ec4					_UHWriteHex:
.0ec4	48		pha				pha
.0ec5	4a		lsr a				lsr 	a
.0ec6	4a		lsr a				lsr 	a
.0ec7	4a		lsr a				lsr 	a
.0ec8	4a		lsr a				lsr 	a
.0ec9	20 cd 0e	jsr $0ecd			jsr 	_UHWriteNibl
.0ecc	68		pla				pla
.0ecd					_UHWriteNibl:
.0ecd	29 0f		and #$0f			and 	#15
.0ecf	c9 0a		cmp #$0a			cmp 	#10
.0ed1	90 02		bcc $0ed5			bcc 	_UHDigit
.0ed3	69 06		adc #$06			adc 	#6
.0ed5					_UHDigit:
.0ed5	69 30		adc #$30			adc 	#48
.0ed7	20 09 17	jsr $1709			jsr 	StringWriteChar
.0eda	60		rts				rts
.0edb					IndFloatRead:
.0edb	fa		plx				plx
.0edc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0ede	85 2c		sta $2c				sta 	zTemp0
.0ee0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ee2	18		clc				clc
.0ee3	6d 07 04	adc $0407			adc 	variableStartPage
.0ee6	85 2d		sta $2d				sta 	zTemp0+1
.0ee8	ca		dex				dex 								; throw the address
.0ee9	20 bf 14	jsr $14bf			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0eec	4c 34 08	jmp $0834			jmp 	NextCommand
.0eef					IndInt16Read:
.0eef	fa		plx				plx
.0ef0	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0ef2	85 2c		sta $2c				sta 	zTemp0
.0ef4	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ef6	18		clc				clc
.0ef7	6d 07 04	adc $0407			adc 	variableStartPage
.0efa	85 2d		sta $2d				sta 	zTemp0+1
.0efc	ca		dex				dex 								; throw the address
.0efd	20 fb 14	jsr $14fb			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f00	4c 34 08	jmp $0834			jmp 	NextCommand
.0f03					IndStringRead:
.0f03	fa		plx				plx
.0f04	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f06	85 2c		sta $2c				sta 	zTemp0
.0f08	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f0a	18		clc				clc
.0f0b	6d 07 04	adc $0407			adc 	variableStartPage
.0f0e	85 2d		sta $2d				sta 	zTemp0+1
.0f10	ca		dex				dex 								; throw the address
.0f11	20 40 15	jsr $1540			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f14	4c 34 08	jmp $0834			jmp 	NextCommand
.0f17					IndFloatWrite:
.0f17	fa		plx				plx
.0f18	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f1a	85 2c		sta $2c				sta 	zTemp0
.0f1c	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f1e	18		clc				clc
.0f1f	6d 07 04	adc $0407			adc 	variableStartPage
.0f22	85 2d		sta $2d				sta 	zTemp0+1
.0f24	20 9a 1a	jsr $1a9a			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f27	ca		dex				dex 								; throw the address as well.
.0f28	4c 34 08	jmp $0834			jmp 	NextCommand
.0f2b					IndInt16Write:
.0f2b	fa		plx				plx
.0f2c	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f2e	85 2c		sta $2c				sta 	zTemp0
.0f30	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f32	18		clc				clc
.0f33	6d 07 04	adc $0407			adc 	variableStartPage
.0f36	85 2d		sta $2d				sta 	zTemp0+1
.0f38	20 d6 1a	jsr $1ad6			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f3b	ca		dex				dex 								; throw the address as well.
.0f3c	4c 34 08	jmp $0834			jmp 	NextCommand
.0f3f					IndStringWrite:
.0f3f	fa		plx				plx
.0f40	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f42	85 2c		sta $2c				sta 	zTemp0
.0f44	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f46	18		clc				clc
.0f47	6d 07 04	adc $0407			adc 	variableStartPage
.0f4a	85 2d		sta $2d				sta 	zTemp0+1
.0f4c	20 15 1b	jsr $1b15			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f4f	ca		dex				dex 								; throw the address as well.
.0f50	4c 34 08	jmp $0834			jmp 	NextCommand
.0f53					CommandXInput:
.0f53	fa		plx				plx
.0f54	5a		phy				phy 								; save Y
.0f55	e8		inx				inx									; space on stack
.0f56					_INError:
.0f56	20 8a 0f	jsr $0f8a			jsr 	InputStringToBuffer 		; input from keyboard
.0f59	a9 5f		lda #$5f			lda 	#((ReadBufferSize) & $FF)
.0f5b	85 2c		sta $2c				sta 	0+zTemp0
.0f5d	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f5f	85 2d		sta $2d				sta 	1+zTemp0
.0f61	20 27 19	jsr $1927			jsr 	ValEvaluateZTemp0
.0f64	b0 f0		bcs $0f56			bcs 	_INError 					; failed, try again.
.0f66	7a		ply				ply 								; restore Y
.0f67	4c 34 08	jmp $0834			jmp 	NextCommand
.0f6a					CommandInputString:
.0f6a	fa		plx				plx
.0f6b	5a		phy				phy 								; save Y
.0f6c	20 8a 0f	jsr $0f8a			jsr 	InputStringToBuffer 		; input from keyboard
.0f6f	e8		inx				inx 								; make space on stack
.0f70	20 1d 26	jsr $261d			jsr 	FloatSetZero 				; store as string on stack
.0f73	a9 5f		lda #$5f			lda 	#ReadBufferSize & $FF
.0f75	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0f77	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0f79	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0f7b	a9 40		lda #$40			lda 	#NSSString
.0f7d	95 32		sta $32,x			sta 	NSStatus,x
.0f7f	7a		ply				ply 								; restore Y
.0f80	4c 34 08	jmp $0834			jmp 	NextCommand
.0f83					CommandInputReset:
.0f83	fa		plx				plx
.0f84	9c 0a 04	stz $040a			stz 	InputBuffer
.0f87	4c 34 08	jmp $0834			jmp 	NextCommand
.0f8a					InputStringToBuffer:
.0f8a	a9 c4		lda #$c4			lda 	#((InputBumpNext) & $FF)
.0f8c	8d 5f 05	sta $055f			sta 	0+ReadBumpNextVec
.0f8f	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0f91	8d 60 05	sta $0560			sta 	1+ReadBumpNextVec
.0f94	a9 a1		lda #$a1			lda 	#((InputLookNext) & $FF)
.0f96	8d 61 05	sta $0561			sta 	0+ReadLookNextVec
.0f99	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0f9b	8d 62 05	sta $0562			sta 	1+ReadLookNextVec
.0f9e	4c 1c 14	jmp $141c			jmp 	GetStringToBuffer
.0fa1					InputLookNext:
.0fa1	da		phx				phx
.0fa2					_ILNRetry:
.0fa2	ad 0a 04	lda $040a			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fa5	d0 08		bne $0faf			bne 	_ILNNotEmpty
.0fa7	20 c8 0f	jsr $0fc8			jsr 	InputGetNewLine 			; get a new line
.0faa	9c 5b 04	stz $045b			stz 	InputBufferPos 				; reset read position.
.0fad	80 f3		bra $0fa2			bra 	_ILNRetry
.0faf					_ILNNotEmpty:
.0faf	ae 5b 04	ldx $045b			ldx 	InputBufferPos 				; get head available character
.0fb2	bd 0a 04	lda $040a,x			lda 	InputBuffer,x
.0fb5	d0 08		bne $0fbf			bne 	_ILNExit 					; if not EOS return it with CC.
.0fb7					_ILNNextLine:
.0fb7	9c 0a 04	stz $040a			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0fba	38		sec				sec 								; return CS,Zero
.0fbb	fa		plx				plx
.0fbc	a9 0d		lda #$0d			lda 	#13
.0fbe	60		rts				rts
.0fbf					_ILNExit:
.0fbf	fa		plx				plx
.0fc0	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0fc2	18		clc				clc
.0fc3	60		rts				rts
.0fc4					InputBumpNext:
.0fc4	ee 5b 04	inc $045b			inc 	InputBufferPos
.0fc7	60		rts				rts
.0fc8					InputGetNewLine:
.0fc8	48		pha				pha
.0fc9	da		phx				phx
.0fca	5a		phy				phy
.0fcb	a9 3f		lda #$3f			lda 	#"?"
.0fcd	20 07 10	jsr $1007			jsr 	IGNLEchoIfScreen
.0fd0	a0 00		ldy #$00			ldy 	#0 							; line position.
.0fd2					_IGNLLoop:
.0fd2	20 46 13	jsr $1346			jsr 	VectorGetCharacter 			; get a character
.0fd5	c9 00		cmp #$00			cmp 	#0
.0fd7	f0 f9		beq $0fd2			beq 	_IGNLLoop
.0fd9	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.0fdb	f0 11		beq $0fee			beq 	_IGNBackspace
.0fdd	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.0fdf	f0 17		beq $0ff8			beq 	_IGNExit
.0fe1	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.0fe3	f0 ed		beq $0fd2			beq 	_IGNLLoop
.0fe5	99 0a 04	sta $040a,y			sta 	InputBuffer,y
.0fe8	c8		iny				iny
.0fe9	20 07 10	jsr $1007			jsr 	IGNLEchoIfScreen
.0fec	80 e4		bra $0fd2			bra 	_IGNLLoop
.0fee					_IGNBackspace:
.0fee	c0 00		cpy #$00			cpy 	#0
.0ff0	f0 e0		beq $0fd2			beq 	_IGNLLoop
.0ff2	20 07 10	jsr $1007			jsr 	IGNLEchoIfScreen
.0ff5	88		dey				dey
.0ff6	80 da		bra $0fd2			bra 	_IGNLLoop
.0ff8					_IGNExit:
.0ff8	20 07 10	jsr $1007			jsr 	IGNLEchoIfScreen
.0ffb	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.0ffd	99 0a 04	sta $040a,y			sta 	InputBuffer,y
.1000	9c 5b 04	stz $045b			stz 	InputBufferPos 				; reset position to start of input buffer.
.1003	7a		ply				ply
.1004	fa		plx				plx
.1005	68		pla				pla
.1006	60		rts				rts
.1007					IGNLEchoIfScreen:
.1007	ae 5d 04	ldx $045d			ldx 	currentChannel
.100a	d0 03		bne $100f			bne 	_IGNLEExit
.100c	20 3d 13	jsr $133d			jsr 	VectorPrintCharacter
.100f					_IGNLEExit:
.100f	60		rts				rts
.040a					InputBuffer:
>040a							.fill 	81
.045b					InputBufferPos:
>045b							.fill 	1
.1010					GetInteger8Bit:
.1010	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.1013	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1015	60		rts				rts
.1016					GetInteger16Bit:
.1016	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.1019	34 32		bit $32,x			bit 	NSStatus,x
.101b	30 09		bmi $1026			bmi 	Negate16Bit
.101d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.101f	85 2c		sta $2c				sta 	zTemp0
.1021	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1023	85 2d		sta $2d				sta 	zTemp0+1
.1025	60		rts				rts
.1026					Negate16Bit:
.1026	38		sec				sec
.1027	a9 00		lda #$00			lda 	#0
.1029	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.102b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.102d	85 2c		sta $2c				sta 	zTemp0
.102f	a9 00		lda #$00			lda 	#0
.1031	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1033	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1035	85 2d		sta $2d				sta 	zTemp0+1
.1037	60		rts				rts
.1038					UnaryJoy:
.1038	fa		plx				plx
.1039	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; port #
.103c	48		pha				pha 								; zero the result.
.103d	20 1d 26	jsr $261d			jsr 	FloatSetZero
.1040	68		pla				pla
.1041	5a		phy				phy
.1042	da		phx				phx
.1043	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1046	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1048	d0 10		bne $105a			bne 	_UJNoHardware
.104a	a8		tay				tay 								; move XA -> AY
.104b	8a		txa				txa
.104c	fa		plx				plx 								; we can update it now.
.104d	49 ff		eor #$ff			eor 	#$FF
.104f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1051	98		tya				tya
.1052	49 ff		eor #$ff			eor 	#$FF
.1054	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1056	7a		ply				ply 								; restore Y
.1057	4c 34 08	jmp $0834			jmp 	NextCommand
.105a					_UJNoHardware:
.105a	fa		plx				plx
.105b	7a		ply				ply
.105c	a9 01		lda #$01			lda 	#1 							; set result to -1
.105e	20 1f 26	jsr $261f			jsr 	FloatSetByte
.1061	20 df 25	jsr $25df			jsr 	FloatNegate
.1064	4c 34 08	jmp $0834			jmp 	NextCommand
.1067					UnaryLen:
.1067	fa		plx				plx
.1068	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.106a	85 2c		sta $2c				sta 	zTemp0
.106c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.106e	85 2d		sta $2d				sta 	zTemp0+1
.1070	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.1072	20 1f 26	jsr $261f			jsr 	FloatSetByte
.1075	4c 34 08	jmp $0834			jmp 	NextCommand
.1078					LinkFloatAdd:
.1078	fa		plx				plx
.1079	5a		phy			phy
.107a	20 41 20	jsr $2041		jsr	FloatAdd
.107d	7a		ply			ply
.107e	4c 34 08	jmp $0834			jmp 	NextCommand
.1081					LinkFloatSubtract:
.1081	fa		plx				plx
.1082	5a		phy			phy
.1083	20 3b 20	jsr $203b		jsr	FloatSubtract
.1086	7a		ply			ply
.1087	4c 34 08	jmp $0834			jmp 	NextCommand
.108a					LinkFloatMultiply:
.108a	fa		plx				plx
.108b	5a		phy			phy
.108c	20 dd 22	jsr $22dd		jsr	FloatMultiply
.108f	7a		ply			ply
.1090	4c 34 08	jmp $0834			jmp 	NextCommand
.1093					LinkFloatDivide:
.1093	fa		plx				plx
.1094	5a		phy			phy
.1095	20 66 21	jsr $2166		jsr	FloatDivide
.1098	b0 5c		bcs $10f6		bcs	DivZeroError
.109a	7a		ply			ply
.109b	4c 34 08	jmp $0834			jmp 	NextCommand
.109e					LinkFloatPower:
.109e	fa		plx				plx
.109f	5a		phy			phy
.10a0	20 e6 28	jsr $28e6		jsr	FloatPower
.10a3	b0 4e		bcs $10f3		bcs	MapRangeError
.10a5	7a		ply			ply
.10a6	4c 34 08	jmp $0834			jmp 	NextCommand
.10a9					LinkCompareGreater:
.10a9	fa		plx				plx
.10aa	5a		phy			phy
.10ab	20 ea 20	jsr $20ea		jsr	CompareGreater
.10ae	7a		ply			ply
.10af	4c 34 08	jmp $0834			jmp 	NextCommand
.10b2					LinkCompareEqual:
.10b2	fa		plx				plx
.10b3	5a		phy			phy
.10b4	20 cc 20	jsr $20cc		jsr	CompareEqual
.10b7	7a		ply			ply
.10b8	4c 34 08	jmp $0834			jmp 	NextCommand
.10bb					LinkCompareLess:
.10bb	fa		plx				plx
.10bc	5a		phy			phy
.10bd	20 e2 20	jsr $20e2		jsr	CompareLess
.10c0	7a		ply			ply
.10c1	4c 34 08	jmp $0834			jmp 	NextCommand
.10c4					LinkCompareGreaterEqual:
.10c4	fa		plx				plx
.10c5	5a		phy			phy
.10c6	20 fa 20	jsr $20fa		jsr	CompareGreaterEqual
.10c9	7a		ply			ply
.10ca	4c 34 08	jmp $0834			jmp 	NextCommand
.10cd					LinkCompareNotEqual:
.10cd	fa		plx				plx
.10ce	5a		phy			phy
.10cf	20 dc 20	jsr $20dc		jsr	CompareNotEqual
.10d2	7a		ply			ply
.10d3	4c 34 08	jmp $0834			jmp 	NextCommand
.10d6					LinkCompareLessEqual:
.10d6	fa		plx				plx
.10d7	5a		phy			phy
.10d8	20 f2 20	jsr $20f2		jsr	CompareLessEqual
.10db	7a		ply			ply
.10dc	4c 34 08	jmp $0834			jmp 	NextCommand
.10df					LinkFloatIntegerPartDown:
.10df	fa		plx				plx
.10e0	5a		phy			phy
.10e1	20 7c 22	jsr $227c		jsr	FloatIntegerPartDown
.10e4	7a		ply			ply
.10e5	4c 34 08	jmp $0834			jmp 	NextCommand
.10e8					LinkFloatSquareRoot:
.10e8	fa		plx				plx
.10e9	5a		phy			phy
.10ea	20 68 29	jsr $2968		jsr	FloatSquareRoot
.10ed	b0 04		bcs $10f3		bcs	MapRangeError
.10ef	7a		ply			ply
.10f0	4c 34 08	jmp $0834			jmp 	NextCommand
.10f3					MapRangeError:
.10f3	4c ba 1e	jmp $1eba		jmp	ErrorV_range
.10f6					DivZeroError:
.10f6	4c 43 1f	jmp $1f43		jmp	ErrorV_divzero
.10f9					LinkFloatLogarithm:
.10f9	fa		plx				plx
.10fa	5a		phy			phy
.10fb	20 72 28	jsr $2872		jsr	FloatLogarithm
.10fe	b0 f3		bcs $10f3		bcs	MapRangeError
.1100	7a		ply			ply
.1101	4c 34 08	jmp $0834			jmp 	NextCommand
.1104					LinkFloatExponent:
.1104	fa		plx				plx
.1105	5a		phy			phy
.1106	20 6f 27	jsr $276f		jsr	FloatExponent
.1109	7a		ply			ply
.110a	4c 34 08	jmp $0834			jmp 	NextCommand
.110d					LinkFloatCosine:
.110d	fa		plx				plx
.110e	5a		phy			phy
.110f	20 63 27	jsr $2763		jsr	FloatCosine
.1112	7a		ply			ply
.1113	4c 34 08	jmp $0834			jmp 	NextCommand
.1116					LinkFloatSine:
.1116	fa		plx				plx
.1117	5a		phy			phy
.1118	20 03 29	jsr $2903		jsr	FloatSine
.111b	7a		ply			ply
.111c	4c 34 08	jmp $0834			jmp 	NextCommand
.111f					LinkFloatTangent:
.111f	fa		plx				plx
.1120	5a		phy			phy
.1121	20 74 29	jsr $2974		jsr	FloatTangent
.1124	7a		ply			ply
.1125	4c 34 08	jmp $0834			jmp 	NextCommand
.1128					LinkFloatArcTan:
.1128	fa		plx				plx
.1129	5a		phy			phy
.112a	20 48 26	jsr $2648		jsr	FloatArcTan
.112d	b0 c4		bcs $10f3		bcs	MapRangeError
.112f	7a		ply			ply
.1130	4c 34 08	jmp $0834			jmp 	NextCommand
.1133					LinkFloatCompare:
.1133	fa		plx				plx
.1134	5a		phy			phy
.1135	20 02 21	jsr $2102		jsr	FloatCompare
.1138	7a		ply			ply
.1139	4c 34 08	jmp $0834			jmp 	NextCommand
.113c					LinkDivideInt32:
.113c	fa		plx				plx
.113d	5a		phy			phy
.113e	20 90 21	jsr $2190		jsr	DivideInt32
.1141	b0 b0		bcs $10f3		bcs	MapRangeError
.1143	7a		ply			ply
.1144	4c 34 08	jmp $0834			jmp 	NextCommand
.1147					StackSaveCurrentPosition:
.1147	20 9f 08	jsr $089f			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.114a	5a		phy				phy
.114b	a0 02		ldy #$02			ldy 	#2
.114d	a5 28		lda $28				lda 	codePtr
.114f	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1151	c8		iny				iny
.1152	a5 29		lda $29				lda 	codePtr+1
.1154	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1156	7a		ply				ply
.1157	60		rts				rts
.1158					StackLoadCurrentPosition:
.1158	a0 02		ldy #$02			ldy 	#2
.115a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.115c	85 28		sta $28				sta 	codePtr
.115e	c8		iny				iny
.115f	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1161	85 29		sta $29				sta 	codePtr+1
.1163	a0 00		ldy #$00			ldy 	#0
.1165	60		rts				rts
.1166					XCommandMouse:
.1166	fa		plx				plx
.1167	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; mouse control.
.116a	ca		dex				dex
.116b	da		phx				phx
.116c	5a		phy				phy
.116d	48		pha				pha
.116e	38		sec				sec 								; get screen resolution
.116f	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1172	68		pla				pla
.1173	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.1176	7a		ply				ply
.1177	fa		plx				plx
.1178	4c 34 08	jmp $0834			jmp 	NextCommand
.117b					XUnaryMB:
.117b	fa		plx				plx
.117c	20 aa 11	jsr $11aa			jsr 	XUnaryMouseCommon
.117f	a5 30		lda $30				lda 	zTemp2
.1181	e8		inx				inx
.1182	20 1f 26	jsr $261f			jsr 	FloatSetByte
.1185	4c 34 08	jmp $0834			jmp 	NextCommand
.1188					XUnaryMX:
.1188	fa		plx				plx
.1189	20 aa 11	jsr $11aa			jsr 	XUnaryMouseCommon
.118c	a5 2c		lda $2c				lda 	zTemp0
.118e	e8		inx				inx
.118f	20 1f 26	jsr $261f			jsr 	FloatSetByte
.1192	a5 2d		lda $2d				lda 	zTemp0+1
.1194	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1196	4c 34 08	jmp $0834			jmp 	NextCommand
.1199					XUnaryMY:
.1199	fa		plx				plx
.119a	20 aa 11	jsr $11aa			jsr 	XUnaryMouseCommon
.119d	a5 2e		lda $2e				lda 	zTemp1
.119f	e8		inx				inx
.11a0	20 1f 26	jsr $261f			jsr 	FloatSetByte
.11a3	a5 2f		lda $2f				lda 	zTemp1+1
.11a5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11a7	4c 34 08	jmp $0834			jmp 	NextCommand
.11aa					XUnaryMouseCommon:
.11aa	da		phx				phx
.11ab	5a		phy				phy
.11ac	a2 2c		ldx #$2c			ldx 	#zTemp0
.11ae	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.11b1	85 30		sta $30				sta 	zTemp2
.11b3	7a		ply				ply
.11b4	fa		plx				plx
.11b5	60		rts				rts
.11b6					NegateTOS:
.11b6	fa		plx				plx
.11b7	20 df 25	jsr $25df			jsr 	FloatNegate
.11ba	4c 34 08	jmp $0834			jmp 	NextCommand
.11bd					CommandNewLine:
.11bd	fa		plx				plx
.11be	9c 68 05	stz $0568			stz 	stringInitialised
.11c1	a2 ff		ldx #$ff			ldx 	#$FF
.11c3	4c 34 08	jmp $0834			jmp 	NextCommand
.11c6					CommandXNext:
.11c6	fa		plx				plx
.11c7					_CNRetry:
.11c7	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.11c9	20 2c 0d	jsr $0d2c			jsr 	StackFindFrame
.11cc	20 9f 08	jsr $089f			jsr 	FixUpY 						; so we can use Y
.11cf	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.11d1	35 4a		and $4a,x			and 	NSMantissa1,x
.11d3	c9 ff		cmp #$ff			cmp 	#$FF
.11d5	f0 16		beq $11ed			beq 	_CNNoIndexVariable
.11d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.11d9	a0 05		ldy #$05			ldy 	#5
.11db	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.11dd	d0 07		bne $11e6			bne 	_CNNIndexFail
.11df	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.11e1	c8		iny				iny
.11e2	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.11e4	f0 07		beq $11ed			beq 	_CNNoIndexVariable
.11e6					_CNNIndexFail:
.11e6	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.11e8	20 1e 0d	jsr $0d1e			jsr 	StackCloseFrame 			; close this frame
.11eb	80 da		bra $11c7			bra 	_CNRetry
.11ed					_CNNoIndexVariable:
.11ed	ca		dex				dex
.11ee	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.11f0	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.11f2	29 40		and #$40			and 	#$40	 					; bit 6
.11f4	d0 55		bne $124b			bne 	_CNOptimisedNext
.11f6	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.11f8	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.11fa	48		pha				pha
.11fb	85 2c		sta $2c				sta 	zTemp0
.11fd	c8		iny				iny
.11fe	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1200	18		clc				clc
.1201	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1204	48		pha				pha
.1205	85 2d		sta $2d				sta 	zTemp0+1
.1207	20 bf 14	jsr $14bf			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.120a	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.120c	e8		inx				inx
.120d	20 8e 12	jsr $128e			jsr 	CopyOffsetYToTOS
.1210	20 41 20	jsr $2041			jsr 	FloatAdd
.1213	68		pla				pla 								; restore address
.1214	85 2d		sta $2d				sta 	zTemp0+1
.1216	68		pla				pla
.1217	85 2c		sta $2c				sta 	zTemp0
.1219	20 9a 1a	jsr $1a9a			jsr 	WriteFloatZTemp0Sub			; write float.
.121c	e8		inx				inx  								; recover written
.121d	e8		inx				inx 								; load offset
.121e	a0 0d		ldy #$0d			ldy 	#13
.1220	20 8e 12	jsr $128e			jsr 	CopyOffsetYToTOS
.1223	20 02 21	jsr $2102			jsr 	FloatCompare 				; and compare the floats.
.1226	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1227	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.1229	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.122b	30 08		bmi $1235			bmi 	_CNDownStep
.122d	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.122f	c9 01		cmp #$01			cmp 	#1 							; gone higher
.1231	f0 10		beq $1243			beq 	_CNExitFor 					; if so exit the loop
.1233	80 06		bra $123b			bra 	_CNLoopBack
.1235					_CNDownStep:
.1235	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1237	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.1239	f0 08		beq $1243			beq 	_CNExitFor
.123b					_CNLoopBack:
.123b	20 58 11	jsr $1158			jsr 	StackLoadCurrentPosition 	; loop back
.123e	a0 00		ldy #$00			ldy 	#0
.1240	4c 34 08	jmp $0834			jmp 	NextCommand
.1243					_CNExitFor:
.1243	20 1e 0d	jsr $0d1e			jsr 	StackCloseFrame 			; remove the frame and exit
.1246	a0 00		ldy #$00			ldy 	#0
.1248	4c 34 08	jmp $0834			jmp 	NextCommand
.124b					_CNOptimisedNext:
.124b	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.124d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.124f	85 2c		sta $2c				sta 	zTemp0
.1251	c8		iny				iny
.1252	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1254	18		clc				clc
.1255	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1258	85 2d		sta $2d				sta 	zTemp0+1
.125a	a0 07		ldy #$07			ldy 	#7 							; STEP value
.125c	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.125e	a0 ff		ldy #$ff			ldy 	#$FF
.1260	18		clc				clc
.1261					_CNOIncrement:
.1261	c8		iny				iny
.1262	71 2c		adc ($2c),y			adc 	(zTemp0),y
.1264	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1266	f0 f9		beq $1261			beq 	_CNOIncrement
.1268	18		clc				clc
.1269	a5 24		lda $24				lda 	runtimeStackPtr
.126b	69 0d		adc #$0d			adc 	#13
.126d	85 2e		sta $2e				sta 	zTemp1
.126f	a5 25		lda $25				lda 	runtimeStackPtr+1
.1271	69 00		adc #$00			adc 	#0
.1273	85 2f		sta $2f				sta 	zTemp1+1
.1275	a0 00		ldy #$00			ldy 	#0
.1277	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.1279	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.127b	c8		iny				iny
.127c	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.127e	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1280	c8		iny				iny
.1281	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.1283	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1285	c8		iny				iny
.1286	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.1288	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.128a	90 b7		bcc $1243			bcc	 	_CNExitFor
.128c	80 ad		bra $123b			bra 	_CNLoopBack
.128e					CopyOffsetYToTOS:
.128e	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1290	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1292	c8		iny				iny
.1293	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1295	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1297	c8		iny				iny
.1298	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.129a	95 56		sta $56,x			sta 	NSMantissa2,x
.129c	c8		iny				iny
.129d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.129f	95 62		sta $62,x			sta 	NSMantissa3,x
.12a1	c8		iny				iny
.12a2	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12a4	95 6e		sta $6e,x			sta 	NSExponent,x
.12a6	c8		iny				iny
.12a7	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12a9	95 32		sta $32,x			sta 	NSStatus,x
.12ab	60		rts				rts
.12ac	4c 34 08	jmp $0834			jmp 	NextCommand
.12af					NotTOS:
.12af	fa		plx				plx
.12b0	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.12b3	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.12b5	74 62		stz $62,x			stz 	NSMantissa3,x
.12b7	20 df 25	jsr $25df			jsr 	FloatNegate		 			; negate
.12ba	e8		inx				inx 								; and subtract 1.
.12bb	a9 01		lda #$01			lda 	#1
.12bd	20 1f 26	jsr $261f			jsr 	FloatSetByte
.12c0	20 3b 20	jsr $203b			jsr 	FloatSubtract
.12c3					_NotTOSSkip:
.12c3	4c 34 08	jmp $0834			jmp 	NextCommand
.12c6					CommandXOn:
.12c6	fa		plx				plx
.12c7	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.12ca	8d 5c 04	sta $045c			sta 	onCount 					; save it.
.12cd	20 9f 08	jsr $089f			jsr 	FixUpY 						; Y = 0
.12d0					_CONFind:
.12d0	ce 5c 04	dec $045c			dec 	onCount 					; reached zero, do this one
.12d3	f0 0b		beq $12e0			beq 	_CONFound
.12d5	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.12d6	c8		iny				iny
.12d7	c8		iny				iny
.12d8	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.12da	c8		iny				iny
.12db	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.12dd	f0 f1		beq $12d0			beq 	_CONFind
.12df	88		dey				dey 								; point to character after last GOTO/GOSUB
.12e0					_CONFound:
.12e0	4c 34 08	jmp $0834			jmp 	NextCommand
.12e3					CommandMoreOn:
.12e3	fa		plx				plx
.12e4	c8		iny				iny 								; so it goes to the first non-goto/gosub
.12e5	c8		iny				iny
.12e6	c8		iny				iny
.12e7	4c 34 08	jmp $0834			jmp 	NextCommand
.045c					onCount:
>045c							.fill 	1
.12ea					UnaryPeek:
.12ea	fa		plx				plx
.12eb	20 16 10	jsr $1016			jsr 	GetInteger16Bit
.12ee	da		phx				phx
.12ef	5a		phy				phy
.12f0	a6 2c		ldx $2c				ldx 	zTemp0
.12f2	a4 2d		ldy $2d				ldy 	zTemp0+1
.12f4	20 2b 1c	jsr $1c2b			jsr 	XPeekMemory
.12f7	7a		ply				ply
.12f8	fa		plx				plx
.12f9	20 1f 26	jsr $261f			jsr 	FloatSetByte
.12fc	4c 34 08	jmp $0834			jmp 	NextCommand
.12ff					CommandPOKE:
.12ff	fa		plx				plx
.1300	da		phx				phx 								; save XY
.1301	5a		phy				phy
.1302	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1305	48		pha				pha
.1306	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1308	a8		tay				tay
.1309	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.130b	aa		tax				tax
.130c	68		pla				pla
.130d	20 17 1c	jsr $1c17			jsr 	XPokeMemory
.1310	7a		ply				ply 								; restore YX and drop 2
.1311	fa		plx				plx
.1312	ca		dex				dex
.1313	ca		dex				dex
.1314	4c 34 08	jmp $0834			jmp 	NextCommand
.1317					UnaryPos:
.1317	fa		plx				plx
.1318	20 aa 1b	jsr $1baa			jsr 	XGetHPos
.131b	20 1f 26	jsr $261f			jsr 	FloatSetByte
.131e	4c 34 08	jmp $0834			jmp 	NextCommand
.1321					GetChannel:
.1321	fa		plx				plx
.1322	ad 5d 04	lda $045d			lda 	currentChannel
.1325	e8		inx				inx
.1326	20 1f 26	jsr $261f			jsr 	FloatSetByte
.1329	4c 34 08	jmp $0834			jmp 	NextCommand
.132c					SetChannel:
.132c	fa		plx				plx
.132d	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.1330	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1332	8d 5d 04	sta $045d			sta 	currentChannel
.1335	ca		dex				dex
.1336	4c 34 08	jmp $0834			jmp 	NextCommand
.1339					SetDefaultChannel:
.1339	9c 5d 04	stz $045d			stz 	currentChannel
.133c	60		rts				rts
.133d					VectorPrintCharacter:
.133d	da		phx				phx
.133e	ae 5d 04	ldx $045d			ldx 	currentChannel
.1341	20 55 1c	jsr $1c55			jsr 	XPrintCharacterToChannel
.1344	fa		plx				plx
.1345	60		rts				rts
.1346					VectorGetCharacter:
.1346	da		phx				phx
.1347	ae 5d 04	ldx $045d			ldx 	currentChannel
.134a	20 8e 1b	jsr $1b8e			jsr 	XGetCharacterFromChannel
.134d	fa		plx				plx
.134e	60		rts				rts
.045d					currentChannel:
>045d							.fill 	1
.134f					PrintNumber:
.134f	fa		plx				plx
.1350	a9 07		lda #$07			lda 	#7
.1352	20 05 25	jsr $2505			jsr 	FloatToString 				; to number in decimal buffer
.1355	ca		dex				dex 								; drop
.1356	da		phx				phx
.1357	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1359					_PNLoop:
.1359	bd 96 05	lda $0596,x			lda 	decimalBuffer,x
.135c	20 3d 13	jsr $133d			jsr 	VectorPrintCharacter
.135f	e8		inx				inx
.1360	bd 96 05	lda $0596,x			lda	 	decimalBuffer,x
.1363	d0 f4		bne $1359			bne 	_PNLoop
.1365	a9 20		lda #$20			lda 	#32 						; trailing space
.1367	20 3d 13	jsr $133d			jsr 	VectorPrintCharacter
.136a	fa		plx				plx
.136b	4c 34 08	jmp $0834			jmp 	NextCommand
.136e					PrintString:
.136e	fa		plx				plx
.136f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.1371	85 2c		sta $2c				sta 	zTemp0
.1373	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1375	85 2d		sta $2d				sta 	zTemp0+1
.1377	ca		dex				dex 								; drop
.1378	da		phx				phx
.1379	5a		phy				phy
.137a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.137c	aa		tax				tax
.137d	a0 01		ldy #$01			ldy 	#1 							; Y = position
.137f					_PSLoop:
.137f	e0 00		cpx #$00			cpx 	#0 							; complete ?
.1381	f0 09		beq $138c			beq 	_PSExit
.1383	ca		dex				dex 								; dec count
.1384	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.1386	20 3d 13	jsr $133d			jsr 	VectorPrintCharacter
.1389	c8		iny				iny
.138a	80 f3		bra $137f			bra 	_PSLoop
.138c					_PSExit:
.138c	7a		ply				ply
.138d	fa		plx				plx
.138e	4c 34 08	jmp $0834			jmp 	NextCommand
.1391					CommandPushN:
.1391	fa		plx				plx
.1392	e8		inx				inx 								; next slot on stack
.1393	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.1395	95 6e		sta $6e,x			sta 	NSExponent,x
.1397	c8		iny				iny
.1398	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.139a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.139c	c8		iny				iny
.139d	b1 28		lda ($28),y			lda 	(codePtr),y
.139f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13a1	c8		iny				iny
.13a2	b1 28		lda ($28),y			lda 	(codePtr),y
.13a4	95 56		sta $56,x			sta 	NSMantissa2,x
.13a6	c8		iny				iny
.13a7	b1 28		lda ($28),y			lda 	(codePtr),y
.13a9	48		pha				pha
.13aa	29 7f		and #$7f			and 	#$7F
.13ac	95 62		sta $62,x			sta 	NSMantissa3,x
.13ae	68		pla				pla 								; sign in mantissa3:7
.13af	29 80		and #$80			and 	#$80
.13b1	95 32		sta $32,x			sta 	NSStatus,x
.13b3	c8		iny				iny
.13b4	4c 34 08	jmp $0834			jmp 	NextCommand
.13b7					CommandPushS:
.13b7	fa		plx				plx
.13b8	e8		inx				inx 								; next slot on stack
.13b9	18		clc				clc
.13ba	98		tya				tya
.13bb	65 28		adc $28				adc 	codePtr 					; the string is inline
.13bd	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13bf	a5 29		lda $29				lda 	codePtr+1
.13c1	69 00		adc #$00			adc 	#0
.13c3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13c5	74 56		stz $56,x			stz 	NSMantissa2,x
.13c7	74 62		stz $62,x			stz 	NSMantissa3,x
.13c9	a9 40		lda #$40			lda 	#NSSString
.13cb	95 32		sta $32,x			sta 	NSStatus,x
.13cd	98		tya				tya 								; string length +1 added to Y
.13ce	38		sec				sec
.13cf	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.13d1	a8		tay				tay
.13d2	4c 34 08	jmp $0834			jmp 	NextCommand
.13d5					CommandXRead:
.13d5	fa		plx				plx
.13d6	5a		phy				phy 								; save Y
.13d7	20 08 14	jsr $1408			jsr 	ReadStringToBuffer 			; read element into buffer
.13da	e8		inx				inx									; space on stack
.13db	a9 5f		lda #$5f			lda 	#((ReadBufferSize) & $FF)
.13dd	85 2c		sta $2c				sta 	0+zTemp0
.13df	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.13e1	85 2d		sta $2d				sta 	1+zTemp0
.13e3	20 27 19	jsr $1927			jsr 	ValEvaluateZTemp0
.13e6	b0 04		bcs $13ec			bcs 	_CRError 					; failed
.13e8	7a		ply				ply 								; restore Y
.13e9	4c 34 08	jmp $0834			jmp 	NextCommand
.13ec					_CRError:
.13ec	4c ca 1e	jmp $1eca		jmp	ErrorV_value
.13ef					CommandReadString:
.13ef	fa		plx				plx
.13f0	5a		phy				phy 								; save Y
.13f1	20 08 14	jsr $1408			jsr 	ReadStringToBuffer 			; read text
.13f4	e8		inx				inx 								; make space on stack
.13f5	20 1d 26	jsr $261d			jsr 	FloatSetZero 				; store as string on stack
.13f8	a9 5f		lda #$5f			lda 	#ReadBufferSize & $FF
.13fa	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13fc	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.13fe	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1400	a9 40		lda #$40			lda 	#NSSString
.1402	95 32		sta $32,x			sta 	NSStatus,x
.1404	7a		ply				ply 								; restore Y
.1405	4c 34 08	jmp $0834			jmp 	NextCommand
.1408					ReadStringToBuffer:
.1408	a9 9b		lda #$9b			lda 	#((ReadBumpNext) & $FF)
.140a	8d 5f 05	sta $055f			sta 	0+ReadBumpNextVec
.140d	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.140f	8d 60 05	sta $0560			sta 	1+ReadBumpNextVec
.1412	a9 6e		lda #$6e			lda 	#((ReadLookNext) & $FF)
.1414	8d 61 05	sta $0561			sta 	0+ReadLookNextVec
.1417	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.1419	8d 62 05	sta $0562			sta 	1+ReadLookNextVec
.141c					GetStringToBuffer:
.141c	20 6b 14	jsr $146b			jsr		GetLookNext 				; skip all leading spaces.
.141f	f0 44		beq $1465			beq 	_RBError 					; end of data
.1421	b0 f9		bcs $141c			bcs 	GetStringToBuffer 			; switched to new data line.
.1423	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1425	b0 05		bcs $142c			bcs 	_RBNoSpace
.1427	20 68 14	jsr $1468			jsr 	GetBumpNext 				; consume space and loop round.
.142a	80 f0		bra $141c			bra 	GetStringToBuffer
.142c					_RBNoSpace:
.142c	9c 5f 04	stz $045f			stz 	ReadBufferSize 				; empty the buffer.
.142f	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.1431	d0 08		bne $143b			bne 	_RBCommaSep
.1433	8d 5e 04	sta $045e			sta 	ReadSep 					; use as a seperator
.1436	20 68 14	jsr $1468			jsr 	GetBumpNext 				; consume the '"'
.1439	80 05		bra $1440			bra 	_RBGetText
.143b					_RBCommaSep:
.143b	a9 2c		lda #$2c			lda 	#","						; get till comma
.143d	8d 5e 04	sta $045e			sta 	ReadSep
.1440					_RBGetText:
.1440	20 6b 14	jsr $146b			jsr 	GetLookNext 				; what follows
.1443	b0 18		bcs $145d			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.1445	20 68 14	jsr $1468			jsr 	GetBumpNext 				; consume it whatever
.1448	cd 5e 04	cmp $045e			cmp 	ReadSep 					; if found the seperator.
.144b	f0 10		beq $145d			beq 	_RBEndGet 					; exit after consumption
.144d	da		phx				phx
.144e	ae 5f 04	ldx $045f			ldx 	ReadBufferSize 				; copy into buffer.
.1451	ee 5f 04	inc $045f			inc 	ReadBufferSize
.1454	9d 60 04	sta $0460,x			sta 	ReadBuffer,x
.1457	9e 61 04	stz $0461,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.145a	fa		plx				plx
.145b	80 e3		bra $1440			bra 	_RBGetText
.145d					_RBEndGet:
.145d	c9 22		cmp #$22			cmp 	#'"'
.145f	d0 03		bne $1464			bne 	_RBNotQuote
.1461	20 68 14	jsr $1468			jsr 	GetBumpNext
.1464					_RBNotQuote:
.1464	60		rts				rts
.1465					_RBError:
.1465	4c 7f 1f	jmp $1f7f		jmp	ErrorV_data
.1468					GetBumpNext:
.1468	6c 5f 05	jmp ($055f)			jmp 	(ReadBumpNextVec)
.146b					GetLookNext:
.146b	6c 61 05	jmp ($0561)			jmp 	(ReadLookNextVec)
.146e					ReadLookNext:
.146e	ad 63 05	lda $0563			lda 	dataRemaining 				; any data remaining
.1471	f0 04		beq $1477			beq 	_RLNFindData
.1473	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.1475	18		clc				clc
.1476	60		rts				rts
.1477					_RLNFindData:
.1477	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.1479	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.147b	f0 1a		beq $1497			beq 	_RLNNoData
.147d	c9 cf		cmp #$cf			cmp 	#PCD_CMD_DATA 				; Found DATA
.147f	f0 05		beq $1486			beq 	_RLNHaveData
.1481					_RLNNext:
.1481	20 ec 1f	jsr $1fec			jsr 	MoveObjectForward			; else scan forward.
.1484	80 f1		bra $1477			bra 	_RLNFindData
.1486					_RLNHaveData:
.1486	a0 01		ldy #$01			ldy 	#1 							; get length
.1488	b1 2a		lda ($2a),y			lda 	(objPtr),y
.148a	f0 f5		beq $1481			beq 	_RLNNext 					; skip if DATA alone
.148c	20 9b 14	jsr $149b			jsr 	ReadBumpNext 				; advance by two
.148f	20 9b 14	jsr $149b			jsr 	ReadBumpNext
.1492	8d 63 05	sta $0563			sta 	dataRemaining 				; set data left count.
.1495	38		sec				sec
.1496	60		rts				rts
.1497					_RLNNoData:
.1497	a9 00		lda #$00			lda 	#0
.1499	38		sec				sec
.149a	60		rts				rts
.149b					ReadBumpNext:
.149b	e6 2a		inc $2a				inc 	objPtr
.149d	d0 02		bne $14a1			bne 	_RBNSkip
.149f	e6 2b		inc $2b				inc 	objPtr+1
.14a1					_RBNSkip:
.14a1	ce 63 05	dec $0563			dec 	dataRemaining
.14a4	60		rts				rts
.045e					ReadSep:
>045e							.fill 	1
.045f					ReadBufferSize:
>045f							.fill 	1
.0460					ReadBuffer:
>0460							.fill 	255
.055f					ReadBumpNextVec:
>055f							.fill 	2
.0561					ReadLookNextVec:
>0561							.fill 	2
.14a5					ReadFloatCommand:
.14a5	fa		plx				plx
.14a6	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14a8	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14aa	88		dey				dey 								; get the upper 3 bits
.14ab	b1 28		lda ($28),y			lda 	(codePtr),y
.14ad	29 07		and #$07			and 	#7
.14af	c8		iny				iny
.14b0	c8		iny				iny
.14b1	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14b3	2a		rol a				rol 	a 							; carry will be clear.
.14b4	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14b7	85 2d		sta $2d				sta 	zTemp0+1
.14b9	20 bf 14	jsr $14bf			jsr 	ReadFloatZTemp0Sub
.14bc	4c 34 08	jmp $0834			jmp 	NextCommand
.14bf					ReadFloatZTemp0Sub:
.14bf	5a		phy				phy 								; start write
.14c0	a0 01		ldy #$01			ldy 	#1
.14c2	e8		inx				inx
.14c3	b2 2c		lda ($2c)			lda 	(zTemp0)
.14c5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.14c7	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14c9	95 4a		sta $4a,x			sta 	NSMantissa1,x
.14cb	c8		iny				iny
.14cc	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14ce	95 56		sta $56,x			sta 	NSMantissa2,x
.14d0	c8		iny				iny
.14d1	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14d3	95 62		sta $62,x			sta 	NSMantissa3,x
.14d5	c8		iny				iny
.14d6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14d8	95 6e		sta $6e,x			sta 	NSExponent,x
.14da	c8		iny				iny
.14db	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14dd	95 32		sta $32,x			sta 	NSStatus,x
.14df	7a		ply				ply
.14e0	60		rts				rts
.14e1					ReadIntegerCommand:
.14e1	fa		plx				plx
.14e2	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14e4	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14e6	88		dey				dey 								; get the upper 3 bits
.14e7	b1 28		lda ($28),y			lda 	(codePtr),y
.14e9	29 07		and #$07			and 	#7
.14eb	c8		iny				iny
.14ec	c8		iny				iny
.14ed	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14ef	2a		rol a				rol 	a 							; carry will be clear.
.14f0	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14f3	85 2d		sta $2d				sta 	zTemp0+1
.14f5	20 fb 14	jsr $14fb			jsr 	ReadIntegerZTemp0Sub
.14f8	4c 34 08	jmp $0834			jmp 	NextCommand
.14fb					ReadIntegerZTemp0Sub:
.14fb	5a		phy				phy 								; start write
.14fc	a0 01		ldy #$01			ldy 	#1
.14fe	e8		inx				inx 								; prepare
.14ff	74 56		stz $56,x			stz 	NSMantissa2,x
.1501	74 62		stz $62,x			stz 	NSMantissa3,x
.1503	74 6e		stz $6e,x			stz 	NSExponent,x
.1505	74 32		stz $32,x			stz 	NSStatus,x
.1507	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1509	30 08		bmi $1513			bmi 	_RIZNegative
.150b	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.150d	b2 2c		lda ($2c)			lda 	(zTemp0)
.150f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1511	7a		ply				ply
.1512	60		rts				rts
.1513					_RIZNegative:
.1513	38		sec				sec 								; -ve read
.1514	a9 00		lda #$00			lda 	#0
.1516	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.1518	95 3e		sta $3e,x			sta 	NSMantissa0,x
.151a	a9 00		lda #$00			lda 	#0
.151c	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.151e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1520	a9 80		lda #$80			lda 	#$80
.1522	95 32		sta $32,x			sta 	NSStatus,x
.1524	7a		ply				ply
.1525	60		rts				rts
.1526					ReadStringCommand:
.1526	fa		plx				plx
.1527	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1529	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.152b	88		dey				dey 								; get the upper 3 bits
.152c	b1 28		lda ($28),y			lda 	(codePtr),y
.152e	29 07		and #$07			and 	#7
.1530	c8		iny				iny
.1531	c8		iny				iny
.1532	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1534	2a		rol a				rol 	a 							; carry will be clear.
.1535	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1538	85 2d		sta $2d				sta 	zTemp0+1
.153a	20 40 15	jsr $1540			jsr 	ReadStringZTemp0Sub
.153d	4c 34 08	jmp $0834			jmp 	NextCommand
.1540					ReadStringZTemp0Sub:
.1540	5a		phy				phy 								; start write
.1541	e8		inx				inx 								; prepare
.1542	74 56		stz $56,x			stz 	NSMantissa2,x
.1544	74 62		stz $62,x			stz 	NSMantissa3,x
.1546	74 6e		stz $6e,x			stz 	NSExponent,x
.1548	a9 40		lda #$40			lda 	#NSSString
.154a	74 32		stz $32,x			stz 	NSStatus,x
.154c	18		clc				clc
.154d	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.154f	69 02		adc #$02			adc 	#2 							; this points to actual data
.1551	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.1553	a0 01		ldy #$01			ldy 	#1
.1555	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1557	69 00		adc #$00			adc 	#0
.1559	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.155b	d0 08		bne $1565			bne 	_RSZNoDefault 				; if read $00 use a default value.
.155d	a9 67		lda #$67			lda 	#_RSZNull & $FF
.155f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1561	a9 15		lda #$15			lda 	#_RSZNull >> 8
.1563	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1565					_RSZNoDefault:
.1565	7a		ply				ply
.1566	60		rts				rts
.1567					_RSZNull:
>1567	00						.byte 	0
.1568					CommandRestore:
.1568	fa		plx				plx
.1569	20 6f 15	jsr $156f			jsr 	RestoreCode
.156c	4c 34 08	jmp $0834			jmp 	NextCommand
.156f					RestoreCode:
.156f	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.1572	85 2b		sta $2b				sta 	objPtr+1
.1574	64 2a		stz $2a				stz 	objPtr
.1576	9c 63 05	stz $0563			stz 	dataRemaining 				; no data remaining.
.1579	60		rts				rts
.0563					dataRemaining:
>0563							.fill 	1		 					; 0 if not in data statement
.157a					UnaryRND:
.157a	fa		plx				plx
.157b	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.157d	10 17		bpl $1596			bpl 	_URNoSeed
.157f	20 72 23	jsr $2372			jsr 	FloatNormalise 				; some float value
.1582	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.1584	8d 64 05	sta $0564			sta 	randomSeed+0
.1587	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1589	8d 65 05	sta $0565			sta 	randomSeed+1
.158c	b5 56		lda $56,x			lda 	NSMantissa2,x
.158e	8d 66 05	sta $0566			sta 	randomSeed+2
.1591	b5 62		lda $62,x			lda 	NSMantissa3,x
.1593	8d 67 05	sta $0567			sta 	randomSeed+3
.1596					_URNoSeed:
.1596	20 b8 15	jsr $15b8			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.1599	ad 64 05	lda $0564			lda 	randomSeed+0
.159c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.159e	ad 65 05	lda $0565			lda 	randomSeed+1
.15a1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15a3	ad 66 05	lda $0566			lda 	randomSeed+2
.15a6	95 56		sta $56,x			sta 	NSMantissa2,x
.15a8	ad 67 05	lda $0567			lda 	randomSeed+3
.15ab	29 7f		and #$7f			and 	#$7F
.15ad	95 62		sta $62,x			sta 	NSMantissa3,x
.15af	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.15b1	95 6e		sta $6e,x			sta 	NSExponent,x
.15b3	74 32		stz $32,x			stz 	NSStatus,x
.15b5	4c 34 08	jmp $0834			jmp 	NextCommand
.15b8					RandomNumberGenerator:
.15b8	5a		phy				phy
.15b9	ad 64 05	lda $0564			lda 	randomSeed+0 				; check if zero
.15bc	0d 65 05	ora $0565			ora 	randomSeed+1
.15bf	0d 66 05	ora $0566			ora 	randomSeed+2
.15c2	0d 67 05	ora $0567			ora 	randomSeed+3
.15c5	d0 07		bne $15ce			bne 	_RNGNoSeed
.15c7	ce 67 05	dec $0567			dec 	randomSeed+3 				; if so tweak and flog
.15ca	a0 64		ldy #$64			ldy 	#100
.15cc	80 05		bra $15d3			bra 	_RNGLoop
.15ce					_RNGNoSeed:
.15ce	a0 08		ldy #$08			ldy 	#8
.15d0	ad 64 05	lda $0564			lda 	randomSeed+0
.15d3					_RNGLoop:
.15d3	0a		asl a				asl		a
.15d4	2e 65 05	rol $0565			rol 	randomSeed+1
.15d7	2e 66 05	rol $0566			rol 	randomSeed+2
.15da	2e 67 05	rol $0567			rol 	randomSeed+3
.15dd	90 02		bcc $15e1			bcc		_RNGSkip
.15df	49 c5		eor #$c5			eor 	#$C5
.15e1					_RNGSkip:
.15e1	88		dey				dey
.15e2	d0 ef		bne $15d3			bne		_RNGLoop
.15e4	8d 64 05	sta $0564			sta 	randomSeed+0
.15e7	7a		ply				ply
.15e8	60		rts				rts
.0564					randomSeed:
>0564							.fill 	4
.15e9					StringConcatenate:
.15e9	fa		plx				plx
.15ea	ca		dex				dex
.15eb	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.15ed	85 2e		sta $2e				sta 	zTemp1
.15ef	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15f1	85 2f		sta $2f				sta 	zTemp1+1
.15f3	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.15f5	85 30		sta $30				sta 	zTemp2
.15f7	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.15f9	85 31		sta $31				sta 	zTemp2+1
.15fb	18		clc				clc 								; work out total length
.15fc	b2 2e		lda ($2e)			lda 	(zTemp1)
.15fe	72 30		adc ($30)			adc 	(zTemp2)
.1600	b0 18		bcs $161a			bcs 	_BCLength 					; more than 255 characters.
.1602	48		pha				pha 								; save total
.1603	20 e0 16	jsr $16e0			jsr 	StringAllocTemp 			; space for result.
.1606	68		pla				pla 								; write total as first.
.1607	92 22		sta ($22)			sta 	(zsTemp)
.1609	20 1d 16	jsr $161d			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.160c	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.160e	85 2e		sta $2e				sta 	zTemp1
.1610	a5 31		lda $31				lda 	zTemp2+1
.1612	85 2f		sta $2f				sta 	zTemp1+1
.1614	20 1d 16	jsr $161d			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1617	4c 34 08	jmp $0834			jmp 	NextCommand
.161a					_BCLength:
.161a	4c ba 1e	jmp $1eba		jmp	ErrorV_range
.161d					_BCCopyZTemp1:
.161d	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.161f	f0 15		beq $1636			beq 	_BCCExit 					; none.
.1621	da		phx				phx 								; save XY
.1622	5a		phy				phy
.1623	aa		tax				tax 								; count in X.
.1624	a0 01		ldy #$01			ldy 	#1
.1626					_BCCLoop:
.1626	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1628	d0 02		bne $162c			bne 	_BCCNoCarry
.162a	e6 23		inc $23				inc 	zsTemp+1
.162c					_BCCNoCarry:
.162c	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.162e	92 22		sta ($22)			sta 	(zsTemp)
.1630	c8		iny				iny
.1631	ca		dex				dex 								; X times
.1632	d0 f2		bne $1626			bne 	_BCCLoop
.1634	7a		ply				ply 								; restore YX
.1635	fa		plx				plx
.1636					_BCCExit:
.1636	60		rts				rts
.1637					XRuntimeSetup:
.1637	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1639	8d 6b 05	sta $056b	 		sta 	ramBank
.163c	8d 6c 05	sta $056c	 		sta 	romBank
.163f	60		rts				rts
.1640					SignTOS:
.1640	fa		plx				plx
.1641	20 3f 26	jsr $263f			jsr 	FloatIsZero 				; if zero
.1644	f0 0f		beq $1655			beq 	_SGZero  					; return Int Zero
.1646	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.1648	48		pha				pha
.1649	a9 01		lda #$01			lda 	#1 							; set result to 1
.164b	20 1f 26	jsr $261f			jsr 	FloatSetByte
.164e	68		pla				pla
.164f	29 80		and #$80			and		#$80 						; copy the sign byte out
.1651	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.1653	80 03		bra $1658			bra 	_SGExit
.1655					_SGZero:
.1655	20 1d 26	jsr $261d			jsr 	FloatSetZero
.1658					_SGExit:
.1658	4c 34 08	jmp $0834			jmp 	NextCommand
.165b					CommandShift:
.165b	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.165d	c8		iny				iny
.165e	0a		asl a				asl 	a 							; double into X
.165f	aa		tax				tax
.1660	7c 0b 1a	jmp ($1a0b,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.1663					PrintTab:
.1663	fa		plx				plx
.1664	20 aa 1b	jsr $1baa			jsr 	XGetHPos
.1667					_PTMod10:
.1667	38		sec				sec
.1668	e9 0a		sbc #$0a			sbc 	#10
.166a	b0 fb		bcs $1667			bcs 	_PTMod10
.166c	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.166e	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.166f	80 15		bra $1686			bra 	PrintSpaceLoop
.1671					PrintPos:
.1671	fa		plx				plx
.1672	20 aa 1b	jsr $1baa			jsr		XGetHPos 					; get current position
.1675	85 2c		sta $2c				sta 	zTemp0
.1677	38		sec				sec 								; calculate spaces required
.1678	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.167a	ca		dex				dex
.167b	e5 2c		sbc $2c				sbc 	zTemp0
.167d	b0 07		bcs $1686			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.167f	4c 34 08	jmp $0834			jmp 	NextCommand
.1682					PrintSpace:
.1682	fa		plx				plx
.1683	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1685	ca		dex				dex
.1686					PrintSpaceLoop:
.1686	c9 00		cmp #$00			cmp 	#0
.1688	f0 0a		beq $1694			beq 	_PSExit
.168a	48		pha				pha
.168b	a9 20		lda #$20			lda 	#" "
.168d	20 3d 13	jsr $133d			jsr 	VectorPrintCharacter
.1690	68		pla				pla
.1691	3a		dec a				dec 	a
.1692	80 f2		bra $1686			bra 	PrintSpaceLoop
.1694					_PSExit:
.1694	4c 34 08	jmp $0834			jmp 	NextCommand
.1697					CommandStop:
.1697	fa		plx				plx
.1698	4c 6c 1f	jmp $1f6c		jmp	ErrorV_stop
.169b					Unary_Str:
.169b	fa		plx				plx
.169c	5a		phy				phy
.169d	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.169f	20 05 25	jsr $2505			jsr 	FloatToString 				; do the conversion.
.16a2	a9 21		lda #$21			lda		#33 						; create buffer
.16a4	20 e0 16	jsr $16e0			jsr 	StringAllocTemp 			; allocate memory
.16a7	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.16a9					_USCopy:
.16a9	b9 95 05	lda $0595,y			lda 	decimalBuffer-1,y
.16ac	f0 05		beq $16b3			beq 	_USExit
.16ae	91 22		sta ($22),y			sta 	(zsTemp),y
.16b0	c8		iny				iny
.16b1	80 f6		bra $16a9			bra 	_USCopy
.16b3					_USExit:
.16b3	98		tya				tya
.16b4	3a		dec a				dec 	a
.16b5	92 22		sta ($22)			sta 	(zsTemp)
.16b7	7a		ply				ply
.16b8	4c 34 08	jmp $0834			jmp 	NextCommand
.16bb					StringInitialise:
.16bb	48		pha				pha
.16bc	ad 68 05	lda $0568			lda 	stringInitialised 			; already done
.16bf	d0 11		bne $16d2			bne 	_SIExit
.16c1	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.16c4	8d 69 05	sta $0569			sta 	stringTempPointer
.16c7	ad 03 04	lda $0403			lda 	stringHighMemory+1
.16ca	3a		dec a				dec 	a
.16cb	3a		dec a				dec 	a
.16cc	8d 6a 05	sta $056a			sta 	stringTempPointer+1
.16cf	ce 68 05	dec $0568			dec 	stringInitialised 			; set the initialised flag.
.16d2					_SIExit:
.16d2	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.16d4	1a		inc a				inc 	a
.16d5	1a		inc a				inc 	a
.16d6	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.16d9	b0 02		bcs $16dd			bcs 	_SIMemory
.16db	68		pla				pla
.16dc	60		rts				rts
.16dd					_SIMemory:
.16dd	4c c5 1f	jmp $1fc5		jmp	ErrorV_memory
.16e0					StringAllocTemp:
.16e0	20 bb 16	jsr $16bb			jsr 	StringInitialise 			; check it is initialised.
.16e3	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.16e5	18		clc				clc
.16e6	6d 69 05	adc $0569			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.16e9	8d 69 05	sta $0569			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.16ec	85 22		sta $22				sta 	zsTemp
.16ee	95 3e		sta $3e,x			sta 	NSMantissa0,x
.16f0	ad 6a 05	lda $056a			lda 	stringTempPointer+1
.16f3	69 ff		adc #$ff			adc 	#$FF
.16f5	8d 6a 05	sta $056a			sta 	stringTempPointer+1
.16f8	85 23		sta $23				sta 	zsTemp+1
.16fa	95 4a		sta $4a,x			sta 	NSMantissa1,x
.16fc	74 56		stz $56,x			stz 	NSMantissa2,x
.16fe	74 62		stz $62,x			stz 	NSMantissa3,x
.1700	a9 00		lda #$00			lda 	#0 							; clear string.
.1702	92 22		sta ($22)			sta 	(zsTemp)
.1704	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1706	95 32		sta $32,x			sta 	NSStatus,x
.1708	60		rts				rts
.1709					StringWriteChar:
.1709	5a		phy				phy
.170a	48		pha				pha
.170b	b2 22		lda ($22)			lda 	(zsTemp)
.170d	1a		inc a				inc 	a
.170e	92 22		sta ($22)			sta 	(zsTemp)
.1710	a8		tay				tay
.1711	68		pla				pla
.1712	91 22		sta ($22),y			sta 	(zsTemp),y
.1714	7a		ply				ply
.1715	60		rts				rts
.0568					stringInitialised:
>0568							.fill 	1
.0569					stringTempPointer:
>0569							.fill 	2
.1716					Unary_Left:
.1716	fa		plx				plx
.1717	5a		phy				phy
.1718	18		clc				clc 								; only one parameter
.1719	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; push the length of the string.
.171c	48		pha				pha
.171d	ca		dex				dex
.171e	a9 00		lda #$00			lda 	#0 							; push the start position.
.1720	48		pha				pha
.1721	20 59 17	jsr $1759			jsr 	UnarySStringToZTemp0
.1724	80 3c		bra $1762			bra 	SubstringMain 				; stack now points to the string to slice.
.1726					Unary_Right:
.1726	fa		plx				plx
.1727	5a		phy				phy
.1728	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.172a	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; push the right length of the string.
.172d	48		pha				pha
.172e	ca		dex				dex
.172f	20 59 17	jsr $1759			jsr 	UnarySStringToZTemp0
.1732	68		pla				pla 								; this is the right requirement
.1733	38		sec				sec
.1734	49 ff		eor #$ff			eor 	#$FF
.1736	72 2c		adc ($2c)			adc 	(zTemp0)
.1738	b0 02		bcs $173c			bcs 	_URHaveCount
.173a	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.173c					_URHaveCount:
.173c	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.173e	5a		phy				phy
.173f	48		pha				pha 								; start position
.1740	80 20		bra $1762			bra 	SubstringMain
.1742					Unary_Mid:
.1742	fa		plx				plx
.1743	5a		phy				phy
.1744	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; push the length of the string required.
.1747	48		pha				pha
.1748	ca		dex				dex
.1749	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; put the start position.
.174c	f0 08		beq $1756			beq 	_UMError
.174e	3a		dec a				dec 	a
.174f	48		pha				pha
.1750	ca		dex				dex
.1751	20 59 17	jsr $1759			jsr 	UnarySStringToZTemp0
.1754	80 0c		bra $1762			bra 	SubstringMain 				; stack now points to the string to slice.
.1756					_UMError:
.1756	4c ba 1e	jmp $1eba		jmp	ErrorV_range
.1759					UnarySStringToZTemp0:
.1759	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.175b	85 2c		sta $2c				sta 	zTemp0
.175d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.175f	85 2d		sta $2d				sta 	zTemp0+1
.1761	60		rts				rts
.1762					SubstringMain:
.1762	68		pla				pla 								; get the start offset
.1763	7a		ply				ply 								; get the count to do.
.1764	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.1766	b0 38		bcs $17a0			bcs 	_SSReturnNull
.1768	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.176a	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.176c	18		clc				clc
.176d	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.176f	b0 06		bcs $1777			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.1771	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.1773	f0 04		beq $1779			beq 	_SMIsOkay
.1775	90 02		bcc $1779			bcc 	_SMIsOkay
.1777					_SMTruncateToEnd:
.1777	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.1779					_SMIsOkay:
.1779	85 2f		sta $2f				sta 	zTemp1+1
.177b	38		sec				sec		 							; work out size
.177c	a5 2f		lda $2f				lda 	zTemp1+1
.177e	e5 2e		sbc $2e				sbc 	zTemp1
.1780	f0 1e		beq $17a0			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.1782	20 e0 16	jsr $16e0			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.1785	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.1787					_SMCopy:
.1787	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.1789	f0 11		beq $179c			beq 	_SMExit
.178b	c8		iny				iny 								; bump and
.178c	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.178e	5a		phy				phy
.178f	48		pha				pha
.1790	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.1792	1a		inc a				inc 	a
.1793	a8		tay				tay
.1794	92 22		sta ($22)			sta 	(zsTemp)
.1796	68		pla				pla 								; write character out
.1797	91 22		sta ($22),y			sta 	(zsTemp),y
.1799	7a		ply				ply 								; restore Y
.179a	80 eb		bra $1787			bra 	_SMCopy
.179c					_SMExit:
.179c	7a		ply				ply
.179d	4c 34 08	jmp $0834			jmp 	NextCommand
.17a0					_SSReturnNull:
.17a0	a9 b2		lda #$b2			lda 	#SSRNull & $FF 				; set up mantissa
.17a2	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17a4	a9 17		lda #$17			lda 	#SSRNull >> 8
.17a6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17a8	74 56		stz $56,x			stz 	NSMantissa2,x
.17aa	74 62		stz $62,x			stz 	NSMantissa3,x
.17ac	a9 40		lda #$40			lda 	#NSSString
.17ae	95 32		sta $32,x			sta 	NSStatus,x
.17b0	80 ea		bra $179c			bra 	_SMExit
.17b2					SSRNull:
>17b2	00 00						.word 	0
.17b4					CommandSwap:
.17b4	fa		plx				plx
.17b5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17b7	48		pha				pha
.17b8	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.17ba	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17bc	68		pla				pla
.17bd	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.17bf	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17c1	48		pha				pha
.17c2	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.17c4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17c6	68		pla				pla
.17c7	95 49		sta $49,x			sta 	NSMantissa1-1,x
.17c9	b5 56		lda $56,x			lda 	NSMantissa2,x
.17cb	48		pha				pha
.17cc	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.17ce	95 56		sta $56,x			sta 	NSMantissa2,x
.17d0	68		pla				pla
.17d1	95 55		sta $55,x			sta 	NSMantissa2-1,x
.17d3	b5 62		lda $62,x			lda 	NSMantissa3,x
.17d5	48		pha				pha
.17d6	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.17d8	95 62		sta $62,x			sta 	NSMantissa3,x
.17da	68		pla				pla
.17db	95 61		sta $61,x			sta 	NSMantissa3-1,x
.17dd	b5 6e		lda $6e,x			lda 	NSExponent,x
.17df	48		pha				pha
.17e0	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.17e2	95 6e		sta $6e,x			sta 	NSExponent,x
.17e4	68		pla				pla
.17e5	95 6d		sta $6d,x			sta 	NSExponent-1,x
.17e7	b5 32		lda $32,x			lda 	NSStatus,x
.17e9	48		pha				pha
.17ea	b5 31		lda $31,x			lda 	NSStatus-1,x
.17ec	95 32		sta $32,x			sta 	NSStatus,x
.17ee	68		pla				pla
.17ef	95 31		sta $31,x			sta 	NSStatus-1,x
.17f1	4c 34 08	jmp $0834			jmp 	NextCommand
.17f4					CommandSYS:
.17f4	fa		plx				plx
.17f5	da		phx				phx 								; save XY
.17f6	5a		phy				phy
.17f7	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.17fa	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.17fc	85 2d		sta $2d				sta 	zTemp0+1
.17fe	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1800	85 2c		sta $2c				sta 	zTemp0
.1802	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1805	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.1808	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.180b	48		pha				pha
.180c	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.180f	28		plp				plp
.1810	20 27 18	jsr $1827			jsr 	_CSZTemp0
.1813	08		php				php
.1814	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1817	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.181a	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.181d	68		pla				pla
.181e	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.1821	7a		ply				ply 								; restore YX and drop 2
.1822	fa		plx				plx
.1823	ca		dex				dex
.1824	4c 34 08	jmp $0834			jmp 	NextCommand
.1827					_CSZTemp0:
.1827	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.182a					TimeTOS:
.182a	fa		plx				plx
.182b	20 85 18	jsr $1885			jsr 	TIPushClock 				; push clock to TOS
.182e	4c 34 08	jmp $0834			jmp 	NextCommand
.1831					TimeString:
.1831	fa		plx				plx
.1832	20 85 18	jsr $1885			jsr 	TIPushClock 				; push clock to TOS
.1835	20 5a 18	jsr $185a			jsr 	_TSDivMod60 				; result in seconds
.1838	20 5a 18	jsr $185a			jsr 	_TSDivMod60 				; seconds
.183b	48		pha				pha
.183c	20 5a 18	jsr $185a			jsr 	_TSDivMod60 				; minutes
.183f	48		pha				pha
.1840	a9 18		lda #$18			lda 	#24 						; hours
.1842	20 5c 18	jsr $185c			jsr 	_TSDivModA
.1845	48		pha				pha
.1846	a9 06		lda #$06			lda 	#6
.1848	20 e0 16	jsr $16e0			jsr 	StringAllocTemp
.184b	68		pla				pla
.184c	20 6c 18	jsr $186c			jsr 	_TSWriteDecimal
.184f	68		pla				pla
.1850	20 6c 18	jsr $186c			jsr 	_TSWriteDecimal
.1853	68		pla				pla
.1854	20 6c 18	jsr $186c			jsr 	_TSWriteDecimal
.1857	4c 34 08	jmp $0834			jmp 	NextCommand
.185a					_TSDivMod60:
.185a	a9 3c		lda #$3c			lda 	#60
.185c					_TSDivModA:
.185c	e8		inx				inx
.185d	20 1f 26	jsr $261f			jsr 	FloatSetByte
.1860	ca		dex				dex
.1861	20 b3 21	jsr $21b3			jsr 	Int32Divide
.1864	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.1866	48		pha				pha
.1867	20 a2 21	jsr $21a2			jsr 	NSMCopyPlusTwoToZero
.186a	68		pla				pla
.186b	60		rts				rts
.186c					_TSWriteDecimal:
.186c	da		phx				phx
.186d	a2 30		ldx #$30			ldx 	#'0'
.186f					_TSWDLoop:
.186f	c9 0a		cmp #$0a			cmp 	#10
.1871	90 05		bcc $1878			bcc 	_TSWDEnd
.1873	e9 0a		sbc #$0a			sbc 	#10
.1875	e8		inx				inx
.1876	80 f7		bra $186f			bra 	_TSWDLoop
.1878					_TSWDEnd:
.1878	48		pha				pha
.1879	8a		txa				txa
.187a	20 09 17	jsr $1709			jsr 	StringWriteChar
.187d	68		pla				pla
.187e	09 30		ora #$30			ora 	#'0'
.1880	20 09 17	jsr $1709			jsr 	StringWriteChar
.1883	fa		plx				plx
.1884	60		rts				rts
.1885					TIPushClock:
.1885	5a		phy				phy
.1886	e8		inx				inx 								; push 0 on the stack
.1887	20 1d 26	jsr $261d			jsr 	FloatSetZero
.188a	da		phx				phx
.188b	20 75 1c	jsr $1c75			jsr 	XReadClock 					; read time into YXA
.188e	86 2c		stx $2c				stx 	zTemp0
.1890	fa		plx				plx
.1891	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1893	a5 2c		lda $2c				lda 	zTemp0
.1895	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1897	98		tya				tya
.1898	95 56		sta $56,x			sta 	NSMantissa2,x
.189a	7a		ply				ply
.189b	60		rts				rts
.189c					CommandTIWrite:
.189c	fa		plx				plx
.189d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.189f	85 22		sta $22				sta 	zsTemp
.18a1	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.18a3	85 23		sta $23				sta 	zsTemp+1
.18a5	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.18a7	c9 06		cmp #$06			cmp 	#6
.18a9	d0 59		bne $1904			bne 	_CTIWError
.18ab	20 1d 26	jsr $261d			jsr 	FloatSetZero
.18ae	20 d0 18	jsr $18d0			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.18b1	20 d0 18	jsr $18d0			jsr 	_CTIWDigitPair
.18b4	20 d0 18	jsr $18d0			jsr 	_CTIWDigitPair
.18b7	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.18b9	20 fb 18	jsr $18fb			jsr 	_CTIWMultiply
.18bc	da		phx				phx
.18bd	5a		phy				phy
.18be	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.18c0	48		pha				pha
.18c1	b5 56		lda $56,x			lda 	NSMantissa2,x
.18c3	a8		tay				tay
.18c4	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.18c6	fa		plx				plx
.18c7	20 79 1c	jsr $1c79			jsr 	XWriteClock 				; update the clock.
.18ca	7a		ply				ply
.18cb	fa		plx				plx
.18cc	ca		dex				dex 								; throw result.
.18cd	4c 34 08	jmp $0834			jmp 	NextCommand
.18d0					_CTIWDigitPair:
.18d0	a9 06		lda #$06			lda 	#6 							; x 6
.18d2	20 fb 18	jsr $18fb			jsr 	_CTIWMultiply
.18d5	20 e1 18	jsr $18e1			jsr 	_CTIWAddDigit 				; add digit
.18d8	a9 0a		lda #$0a			lda 	#10 						; x 10
.18da	20 fb 18	jsr $18fb			jsr 	_CTIWMultiply
.18dd	20 e1 18	jsr $18e1			jsr 	_CTIWAddDigit 				; add digit
.18e0	60		rts				rts
.18e1					_CTIWAddDigit:
.18e1	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.18e3	d0 02		bne $18e7			bne 	_CTIWASkip
.18e5	e6 23		inc $23				inc 	zsTemp+1
.18e7					_CTIWASkip:
.18e7	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.18e9	38		sec				sec
.18ea	e9 30		sbc #$30			sbc 	#"0"
.18ec	90 16		bcc $1904			bcc 	_CTIWError
.18ee	c9 0a		cmp #$0a			cmp 	#9+1
.18f0	b0 12		bcs $1904			bcs 	_CTIWError
.18f2	e8		inx				inx 								; store at +1
.18f3	20 1f 26	jsr $261f			jsr 	FloatSetByte
.18f6	ca		dex				dex
.18f7	20 a9 23	jsr $23a9			jsr 	FloatAddTopTwoStack
.18fa	60		rts				rts
.18fb					_CTIWMultiply:
.18fb	e8		inx				inx
.18fc	20 1f 26	jsr $261f			jsr 	FloatSetByte
.18ff	ca		dex				dex
.1900	20 2a 23	jsr $232a			jsr 	FloatMultiplyShort
.1903	60		rts				rts
.1904					_CTIWError:
.1904	4c ca 1e	jmp $1eca		jmp	ErrorV_value
.1907					UnaryUsr:
.1907	fa		plx				plx
.1908	5a		phy				phy
.1909	20 10 19	jsr $1910			jsr 	_UUCallVector
.190c	7a		ply				ply
.190d	4c 34 08	jmp $0834			jmp 	NextCommand
.1910					_UUCallVector:
.1910	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.1913					ValUnary:
.1913	fa		plx				plx
.1914	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1916	85 2c		sta $2c				sta 	zTemp0
.1918	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.191a	85 2d		sta $2d				sta 	zTemp0+1
.191c	20 27 19	jsr $1927			jsr 	ValEvaluateZTemp0
.191f	b0 03		bcs $1924			bcs 	_VUError 					; couldn't convert
.1921	4c 34 08	jmp $0834			jmp 	NextCommand
.1924					_VUError:
.1924	4c ca 1e	jmp $1eca		jmp	ErrorV_value
.1927					ValEvaluateZTemp0:
.1927	5a		phy				phy
.1928	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.192a	f0 22		beq $194e			beq 	_VMCFail2
.192c	a0 00		ldy #$00			ldy 	#0 							; start position
.192e					_VMCSpaces:
.192e	c8		iny				iny 								; skip leading spaces
.192f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1931	c9 20		cmp #$20			cmp 	#" "
.1933	f0 f9		beq $192e			beq 	_VMCSpaces
.1935	48		pha				pha 								; save first character
.1936	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.1938	d0 01		bne $193b			bne 	_VMCStart
.193a	c8		iny				iny 								; skip over - if so.
.193b					_VMCStart:
.193b	38		sec				sec 								; initialise first time round.
.193c					_VMCNext:
.193c	98		tya				tya 								; reached end of string
.193d	3a		dec a				dec 	a
.193e	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.1940	f0 0f		beq $1951			beq 	_VMCSuccess 				; successful.
.1942	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.1944	c8		iny				iny
.1945	20 01 24	jsr $2401			jsr 	FloatEncode 				; send it to the number-builder
.1948	90 03		bcc $194d			bcc 	_VMCFail 					; if failed, give up.
.194a	18		clc				clc 								; next time round, countinue
.194b	80 ef		bra $193c			bra 	_VMCNext
.194d					_VMCFail:
.194d	68		pla				pla
.194e					_VMCFail2:
.194e	7a		ply				ply
.194f	38		sec				sec
.1950	60		rts				rts
.1951					_VMCSuccess:
.1951	a9 00		lda #$00			lda 	#0 							; construct final
.1953	20 01 24	jsr $2401			jsr 	FloatEncode 				; by sending a duff value.
.1956	68		pla				pla 								; if it was -ve
.1957	c9 2d		cmp #$2d			cmp 	#"-"
.1959	d0 03		bne $195e			bne 	_VMCNotNegative
.195b	20 df 25	jsr $25df			jsr		FloatNegate 				; negate it.
.195e					_VMCNotNegative:
.195e	7a		ply				ply
.195f	18		clc				clc
.1960	60		rts				rts
.1961					VectorTable:
>1961	78 10					.word	LinkFloatAdd             ; $80 +
>1963	81 10					.word	LinkFloatSubtract        ; $81 -
>1965	8a 10					.word	LinkFloatMultiply        ; $82 *
>1967	93 10					.word	LinkFloatDivide          ; $83 /
>1969	9e 10					.word	LinkFloatPower           ; $84 ^
>196b	c6 08					.word	BinaryAnd                ; $85 and
>196d	ca 08					.word	BinaryOr                 ; $86 or
>196f	a9 10					.word	LinkCompareGreater       ; $87 >
>1971	b2 10					.word	LinkCompareEqual         ; $88 =
>1973	bb 10					.word	LinkCompareLess          ; $89 <
>1975	c4 10					.word	LinkCompareGreaterEqual  ; $8a >=
>1977	cd 10					.word	LinkCompareNotEqual      ; $8b <>
>1979	d6 10					.word	LinkCompareLessEqual     ; $8c <=
>197b	ae 08					.word	AbsoluteTOS              ; $8d abs
>197d	01 09					.word	ArrayConvert             ; $8e array
>197f	a9 09					.word	UnaryAsc                 ; $8f asc
>1981	c4 09					.word	CommandAssert            ; $90 assert
>1983	05 0a					.word	Unary16Bin               ; $91 bin$
>1985	2f 0a					.word	PrintCharacterX          ; $92 print.chr
>1987	39 0a					.word	UnaryChr                 ; $93 chr$
>1989	9e 0a					.word	CompareStrings           ; $94 s.cmp
>198b	85 0c					.word	CommandXFor              ; $95 for
>198d	48 0d					.word	UnaryFre                 ; $96 fre
>198f	60 0d					.word	CommandXGet              ; $97 get
>1991	86 0d					.word	CommandReturn            ; $98 return
>1993	c8 0d					.word	Command_PSET             ; $99 pset
>1995	e2 0d					.word	Command_LINE             ; $9a line
>1997	f7 0d					.word	Command_RECT             ; $9b rect
>1999	06 0e					.word	Command_FRAME            ; $9c frame
>199b	15 0e					.word	Command_CHAR             ; $9d char
>199d	ac 0e					.word	Unary16Hex               ; $9e hex$
>199f	53 0f					.word	CommandXInput            ; $9f input
>19a1	6a 0f					.word	CommandInputString       ; $a0 input$
>19a3	83 0f					.word	CommandInputReset        ; $a1 input.start
>19a5	67 10					.word	UnaryLen                 ; $a2 len
>19a7	33 11					.word	LinkFloatCompare         ; $a3 f.cmp
>19a9	3c 11					.word	LinkDivideInt32          ; $a4 int.div
>19ab	b6 11					.word	NegateTOS                ; $a5 negate
>19ad	bd 11					.word	CommandNewLine           ; $a6 new.line
>19af	c6 11					.word	CommandXNext             ; $a7 next
>19b1	af 12					.word	NotTOS                   ; $a8 not
>19b3	c6 12					.word	CommandXOn               ; $a9 on
>19b5	e3 12					.word	CommandMoreOn            ; $aa moreon
>19b7	ea 12					.word	UnaryPeek                ; $ab peek
>19b9	ff 12					.word	CommandPOKE              ; $ac poke
>19bb	17 13					.word	UnaryPos                 ; $ad pos
>19bd	21 13					.word	GetChannel               ; $ae getchannel
>19bf	2c 13					.word	SetChannel               ; $af setchannel
>19c1	4f 13					.word	PrintNumber              ; $b0 print.n
>19c3	6e 13					.word	PrintString              ; $b1 print.s
>19c5	d5 13					.word	CommandXRead             ; $b2 read
>19c7	ef 13					.word	CommandReadString        ; $b3 read$
>19c9	7a 15					.word	UnaryRND                 ; $b4 rnd
>19cb	e9 15					.word	StringConcatenate        ; $b5 concat
>19cd	40 16					.word	SignTOS                  ; $b6 sgn
>19cf	63 16					.word	PrintTab                 ; $b7 print.tab
>19d1	71 16					.word	PrintPos                 ; $b8 print.pos
>19d3	82 16					.word	PrintSpace               ; $b9 print.spc
>19d5	9b 16					.word	Unary_Str                ; $ba str$
>19d7	16 17					.word	Unary_Left               ; $bb left$
>19d9	26 17					.word	Unary_Right              ; $bc right$
>19db	42 17					.word	Unary_Mid                ; $bd mid$
>19dd	b4 17					.word	CommandSwap              ; $be swap
>19df	2a 18					.word	TimeTOS                  ; $bf ti
>19e1	31 18					.word	TimeString               ; $c0 ti$
>19e3	07 19					.word	UnaryUsr                 ; $c1 usr
>19e5	13 19					.word	ValUnary                 ; $c2 val
>19e7	71 1b					.word	CommandClose             ; $c3 close
>19e9	83 1b					.word	CommandExit              ; $c4 exit
>19eb	89 1b					.word	CommandDebug             ; $c5 debug
>19ed	ef 1b					.word	CommandXOpen             ; $c6 open
>19ef	83 1c					.word	CommandScreen            ; $c7 screen
>19f1	6a 1e					.word	CommandVPOKE             ; $c8 vpoke
>19f3	8f 1e					.word	CommandVPEEK             ; $c9 vpeek
>19f5	5b 16					.word	CommandShift             ; $ca .shift
>19f7	72 08					.word	PushByteCommand          ; $cb .byte
>19f9	85 08					.word	PushWordCommand          ; $cc .word
>19fb	91 13					.word	CommandPushN             ; $cd .float
>19fd	b7 13					.word	CommandPushS             ; $ce .string
>19ff	26 0b					.word	CommandXData             ; $cf .data
>1a01	97 0d					.word	CommandXGoto             ; $d0 .goto
>1a03	7a 0d					.word	CommandXGosub            ; $d1 .gosub
>1a05	ac 0d					.word	CommandGotoZ             ; $d2 .goto.z
>1a07	ba 0d					.word	CommandGotoNZ            ; $d3 .goto.nz
>1a09	b4 08					.word	CommandVarSpace          ; $d4 .varspace
.1a0b					ShiftVectorTable:
>1a0b	51 0a					.word	CommandClr               ; $ca80 clr
>1a0d	2f 0b					.word	CommandXDIM              ; $ca81 dim
>1a0f	20 0c					.word	CommandEnd               ; $ca82 end
>1a11	38 10					.word	UnaryJoy                 ; $ca83 joy
>1a13	df 10					.word	LinkFloatIntegerPartDown ; $ca84 int
>1a15	e8 10					.word	LinkFloatSquareRoot      ; $ca85 sqr
>1a17	f9 10					.word	LinkFloatLogarithm       ; $ca86 log
>1a19	04 11					.word	LinkFloatExponent        ; $ca87 exp
>1a1b	0d 11					.word	LinkFloatCosine          ; $ca88 cos
>1a1d	16 11					.word	LinkFloatSine            ; $ca89 sin
>1a1f	1f 11					.word	LinkFloatTangent         ; $ca8a tan
>1a21	28 11					.word	LinkFloatArcTan          ; $ca8b atn
>1a23	66 11					.word	XCommandMouse            ; $ca8c mouse
>1a25	7b 11					.word	XUnaryMB                 ; $ca8d mb
>1a27	88 11					.word	XUnaryMX                 ; $ca8e mx
>1a29	99 11					.word	XUnaryMY                 ; $ca8f my
>1a2b	68 15					.word	CommandRestore           ; $ca90 restore
>1a2d	97 16					.word	CommandStop              ; $ca91 stop
>1a2f	f4 17					.word	CommandSYS               ; $ca92 sys
>1a31	9c 18					.word	CommandTIWrite           ; $ca93 ti$.write
>1a33	69 1a					.word	CommandXWAIT             ; $ca94 wait
>1a35	b4 1b					.word	X16I2CPoke               ; $ca95 i2cpoke
>1a37	d4 1b					.word	X16I2CPeek               ; $ca96 i2cpeek
>1a39	3f 1c					.word	CommandBank              ; $ca97 bank
>1a3b	92 1c					.word	XCommandSleep            ; $ca98 sleep
>1a3d	b6 1c					.word	X16_Audio_FMINIT         ; $ca99 fminit
>1a3f	c4 1c					.word	X16_Audio_FMNOTE         ; $ca9a fmnote
>1a41	d6 1c					.word	X16_Audio_FMDRUM         ; $ca9b fmdrum
>1a43	e8 1c					.word	X16_Audio_FMINST         ; $ca9c fminst
>1a45	fa 1c					.word	X16_Audio_FMVIB          ; $ca9d fmvib
>1a47	0c 1d					.word	X16_Audio_FMFREQ         ; $ca9e fmfreq
>1a49	1d 1d					.word	X16_Audio_FMVOL          ; $ca9f fmvol
>1a4b	2f 1d					.word	X16_Audio_FMPAN          ; $caa0 fmpan
>1a4d	41 1d					.word	X16_Audio_FMPLAY         ; $caa1 fmplay
>1a4f	52 1d					.word	X16_Audio_FMCHORD        ; $caa2 fmchord
>1a51	63 1d					.word	X16_Audio_FMPOKE         ; $caa3 fmpoke
>1a53	75 1d					.word	X16_Audio_PSGINIT        ; $caa4 psginit
>1a55	83 1d					.word	X16_Audio_PSGNOTE        ; $caa5 psgnote
>1a57	95 1d					.word	X16_Audio_PSGVOL         ; $caa6 psgvol
>1a59	a7 1d					.word	X16_Audio_PSGWAV         ; $caa7 psgwav
>1a5b	b9 1d					.word	X16_Audio_PSGFREQ        ; $caa8 psgfreq
>1a5d	ca 1d					.word	X16_Audio_PSGPAN         ; $caa9 psgpan
>1a5f	dc 1d					.word	X16_Audio_PSGPLAY        ; $caaa psgplay
>1a61	ed 1d					.word	X16_Audio_PSGCHORD       ; $caab psgchord
>1a63	fe 1d					.word	CommandCls               ; $caac cls
>1a65	07 1e					.word	CommandLocate            ; $caad locate
>1a67	31 1e					.word	CommandColor             ; $caae color
.1a69					CommandXWAIT:
.1a69	fa		plx				plx
.1a6a	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1a6c	85 2c		sta $2c				sta 	zTemp0
.1a6e	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1a70	85 2d		sta $2d				sta 	zTemp0+1
.1a72					_WaitLoop:
.1a72	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1a74	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1a76	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1a78	f0 f8		beq $1a72			beq 	_WaitLoop 					; keep going if zero
.1a7a	ca		dex				dex 								; drop 3.
.1a7b	ca		dex				dex
.1a7c	ca		dex				dex
.1a7d	4c 34 08	jmp $0834			jmp 	NextCommand
.1a80					WriteFloatCommand:
.1a80	fa		plx				plx
.1a81	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1a83	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1a85	88		dey				dey 								; get the upper 3 bits
.1a86	b1 28		lda ($28),y			lda 	(codePtr),y
.1a88	29 07		and #$07			and 	#7
.1a8a	c8		iny				iny
.1a8b	c8		iny				iny
.1a8c	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1a8e	2a		rol a				rol 	a 							; carry will be clear.
.1a8f	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1a92	85 2d		sta $2d				sta 	zTemp0+1
.1a94	20 9a 1a	jsr $1a9a			jsr 	WriteFloatZTemp0Sub
.1a97	4c 34 08	jmp $0834			jmp 	NextCommand
.1a9a					WriteFloatZTemp0Sub:
.1a9a	5a		phy				phy 								; ldart write
.1a9b	a0 01		ldy #$01			ldy 	#1
.1a9d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1a9f	92 2c		sta ($2c)			sta 	(zTemp0)
.1aa1	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1aa3	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1aa5	c8		iny				iny
.1aa6	b5 56		lda $56,x			lda 	NSMantissa2,x
.1aa8	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1aaa	c8		iny				iny
.1aab	b5 62		lda $62,x			lda 	NSMantissa3,x
.1aad	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1aaf	c8		iny				iny
.1ab0	b5 6e		lda $6e,x			lda 	NSExponent,x
.1ab2	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ab4	c8		iny				iny
.1ab5	b5 32		lda $32,x			lda 	NSStatus,x
.1ab7	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ab9	ca		dex				dex
.1aba	7a		ply				ply
.1abb	60		rts				rts
.1abc					WriteIntegerCommand:
.1abc	fa		plx				plx
.1abd	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1abf	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1ac1	88		dey				dey 								; get the upper 3 bits
.1ac2	b1 28		lda ($28),y			lda 	(codePtr),y
.1ac4	29 07		and #$07			and 	#7
.1ac6	c8		iny				iny
.1ac7	c8		iny				iny
.1ac8	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1aca	2a		rol a				rol 	a 							; carry will be clear.
.1acb	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1ace	85 2d		sta $2d				sta 	zTemp0+1
.1ad0	20 d6 1a	jsr $1ad6			jsr 	WriteIntegerZTemp0Sub
.1ad3	4c 34 08	jmp $0834			jmp 	NextCommand
.1ad6					WriteIntegerZTemp0Sub:
.1ad6	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.1ad9	5a		phy				phy 								; start write
.1ada	a0 01		ldy #$01			ldy 	#1
.1adc	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1ade	30 0b		bmi $1aeb			bmi 	_WIZNegative
.1ae0	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1ae2	92 2c		sta ($2c)			sta 	(zTemp0)
.1ae4	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ae6	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ae8	7a		ply				ply
.1ae9	ca		dex				dex
.1aea	60		rts				rts
.1aeb					_WIZNegative:
.1aeb	38		sec				sec 								; -ve read
.1aec	a9 00		lda #$00			lda 	#0
.1aee	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1af0	92 2c		sta ($2c)			sta 	(zTemp0)
.1af2	a9 00		lda #$00			lda 	#0
.1af4	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1af6	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1af8	7a		ply				ply
.1af9	ca		dex				dex
.1afa	60		rts				rts
.1afb					WriteStringCommand:
.1afb	fa		plx				plx
.1afc	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1afe	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b00	88		dey				dey 								; get the upper 3 bits
.1b01	b1 28		lda ($28),y			lda 	(codePtr),y
.1b03	29 07		and #$07			and 	#7
.1b05	c8		iny				iny
.1b06	c8		iny				iny
.1b07	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b09	2a		rol a				rol 	a 							; carry will be clear.
.1b0a	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b0d	85 2d		sta $2d				sta 	zTemp0+1
.1b0f	20 15 1b	jsr $1b15			jsr 	WriteStringZTemp0Sub
.1b12	4c 34 08	jmp $0834			jmp 	NextCommand
.1b15					WriteStringZTemp0Sub:
.1b15	5a		phy				phy
.1b16	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b18	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b1a	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b1c	f0 1e		beq $1b3c			beq 	_WSConcrete
.1b1e	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b20	85 2e		sta $2e				sta 	zTemp1
.1b22	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b24	85 2f		sta $2f				sta 	zTemp1+1
.1b26	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b28	85 30		sta $30				sta 	zTemp2
.1b2a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b2c	85 31		sta $31				sta 	zTemp2+1
.1b2e	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1b30	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1b32	b0 17		bcs $1b4b			bcs 	_WSCopy
.1b34	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1b36	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b38	09 80		ora #$80			ora 	#$80
.1b3a	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1b3c					_WSConcrete:
.1b3c	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1b3e	a8		tay				tay
.1b3f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b41	20 e0 0a	jsr $0ae0			jsr 	StringConcrete
.1b44	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1b46	98		tya				tya
.1b47	a0 01		ldy #$01			ldy 	#1
.1b49	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b4b					_WSCopy
.1b4b	18		clc				clc  								; copy target+2 to zTemp2
.1b4c	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b4e	69 02		adc #$02			adc 	#2
.1b50	85 30		sta $30				sta 	zTemp2
.1b52	a0 01		ldy #$01			ldy 	#1
.1b54	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b56	69 00		adc #$00			adc 	#0
.1b58	85 31		sta $31				sta 	zTemp2+1
.1b5a	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1b5c	85 2e		sta $2e				sta 	zTemp1
.1b5e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b60	85 2f		sta $2f				sta 	zTemp1+1
.1b62	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1b64	a8		tay				tay
.1b65					_WSCopyLoop:
.1b65	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b67	91 30		sta ($30),y			sta 	(zTemp2),y
.1b69	88		dey				dey
.1b6a	c0 ff		cpy #$ff			cpy 	#$FF
.1b6c	d0 f7		bne $1b65			bne 	_WSCopyLoop
.1b6e	ca		dex				dex
.1b6f	7a		ply				ply
.1b70	60		rts				rts
.1b71					CommandClose:
.1b71	fa		plx				plx
.1b72	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; channel to close
.1b75	cd 5d 04	cmp $045d			cmp 	currentChannel 				; is it the current channel
.1b78	d0 03		bne $1b7d			bne 	_CCNotCurrent
.1b7a	9c 5d 04	stz $045d			stz 	currentChannel 				; effectively disables CMD
.1b7d					_CCNotCurrent:
.1b7d	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1b80	4c 34 08	jmp $0834			jmp 	NextCommand
.1b83					CommandExit:
.1b83	fa		plx				plx
.1b84	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1b86	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1b89					CommandDebug:
.1b89	fa		plx				plx
>1b8a	db						.byte 	$DB 						; causes a break in the emulator
.1b8b	4c 34 08	jmp $0834			jmp 	NextCommand
.1b8e					XGetCharacterFromChannel:
.1b8e	da		phx				phx
.1b8f	5a		phy				phy
.1b90	e0 00		cpx #$00			cpx 	#0 							; is it default
.1b92	d0 05		bne $1b99			bne 	_XGetChannel
.1b94	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1b97	80 08		bra $1ba1			bra 	_XGetChar
.1b99					_XGetChannel:
.1b99	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1b9c	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1b9f	d0 06		bne $1ba7			bne 	_XGCError
.1ba1					_XGetChar:
.1ba1	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1ba4	7a		ply				ply
.1ba5	fa		plx				plx
.1ba6	60		rts				rts
.1ba7					_XGCError:
.1ba7	4c d6 1f	jmp $1fd6		jmp	ErrorV_channel
.1baa					XGetHPos:
.1baa	da		phx				phx
.1bab	5a		phy				phy
.1bac	38		sec				sec
.1bad	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1bb0	98		tya				tya
.1bb1	7a		ply				ply
.1bb2	fa		plx				plx
.1bb3	60		rts				rts
.1bb4					X16I2CPoke:
.1bb4	fa		plx				plx
.1bb5	5a		phy				phy
.1bb6	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; value
.1bb9	48		pha				pha
.1bba	ca		dex				dex
.1bbb	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; register
.1bbe	48		pha				pha
.1bbf	ca		dex				dex
.1bc0	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; device
.1bc3	aa		tax				tax
.1bc4	7a		ply				ply
.1bc5	68		pla				pla
.1bc6	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1bc9	b0 06		bcs $1bd1			bcs 	X16I2CError
.1bcb	7a		ply				ply
.1bcc	a2 ff		ldx #$ff			ldx 	#$FF
.1bce	4c 34 08	jmp $0834			jmp 	NextCommand
.1bd1					X16I2CError:
.1bd1	4c d6 1f	jmp $1fd6		jmp	ErrorV_channel
.1bd4					X16I2CPeek:
.1bd4	fa		plx				plx
.1bd5	da		phx				phx
.1bd6	5a		phy				phy
.1bd7	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; register
.1bda	48		pha				pha
.1bdb	ca		dex				dex
.1bdc	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; device
.1bdf	aa		tax				tax 								; X device
.1be0	7a		ply				ply 								; Y register
.1be1	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1be4	b0 eb		bcs $1bd1			bcs 	X16I2CError
.1be6	7a		ply				ply 								; restore Y/X
.1be7	fa		plx				plx
.1be8	ca		dex				dex 								; drop TOS (register)
.1be9	20 1f 26	jsr $261f			jsr 	FloatSetByte 				; write read value to TOS.
.1bec	4c 34 08	jmp $0834			jmp 	NextCommand
.1bef					CommandXOpen:
.1bef	fa		plx				plx
.1bf0	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1bf2	85 2c		sta $2c				sta 	zTemp0
.1bf4	aa		tax				tax
.1bf5	a5 4d		lda $4d				lda 	NSMantissa1+3
.1bf7	85 2d		sta $2d				sta 	zTemp0+1
.1bf9	a8		tay				tay
.1bfa	e8		inx				inx 								; XY points to first character
.1bfb	d0 01		bne $1bfe			bne 	_CONoCarry
.1bfd	c8		iny				iny
.1bfe					_CONoCarry:
.1bfe	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c00	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c03	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c05	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c07	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c09	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c0c	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c0f	b0 03		bcs $1c14			bcs 	_COError
.1c11	4c 34 08	jmp $0834			jmp 	NextCommand
.1c14					_COError:
.1c14	4c d6 1f	jmp $1fd6		jmp	ErrorV_channel
.1c17					XPokeMemory:
.1c17	86 2c		stx $2c				stx 	zTemp0
.1c19	84 2d		sty $2d				sty 	zTemp0+1
.1c1b	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c1d	ae 6b 05	ldx $056b			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c20	e0 ff		cpx #$ff			cpx 	#$FF
.1c22	f0 02		beq $1c26			beq 	_XPMNoSwitch
.1c24	86 00		stx $00				stx 	SelectRAMBank
.1c26					_XPMNoSwitch:
.1c26	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1c28	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1c2a					_XPMExit:
.1c2a	60		rts				rts
.1c2b					XPeekMemory:
.1c2b	86 2c		stx $2c				stx 	zTemp0
.1c2d	84 2d		sty $2d				sty 	zTemp0+1
.1c2f	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c31	ae 6b 05	ldx $056b			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c34	e0 ff		cpx #$ff			cpx 	#$FF
.1c36	f0 02		beq $1c3a			beq 	_XPMNoSwitch
.1c38	86 00		stx $00				stx 	SelectRAMBank
.1c3a					_XPMNoSwitch:
.1c3a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1c3c	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1c3e	60		rts				rts
.1c3f					CommandBank:
.1c3f	fa		plx				plx
.1c40	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1c42	8d 6b 05	sta $056b			sta 	ramBank 					; store & make current
.1c45	85 00		sta $00				sta 	SelectRAMBank
.1c47	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1c49	c9 ff		cmp #$ff			cmp 	#$FF
.1c4b	f0 03		beq $1c50			beq 	_CBNoUpdate
.1c4d	8d 6c 05	sta $056c			sta 	romBank 					; this doesn't set the hardware page.
.1c50					_CBNoUpdate:
.1c50	a2 ff		ldx #$ff			ldx 	#$FF
.1c52	4c 34 08	jmp $0834			jmp 	NextCommand
.056b					ramBank:
>056b							.fill 	1
.056c					romBank:
>056c							.fill 	1
.1c55					XPrintCharacterToChannel:
.1c55	48		pha				pha
.1c56	da		phx				phx
.1c57	5a		phy				phy
.1c58	48		pha				pha  								; save char
.1c59	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1c5b	d0 05		bne $1c62			bne 	_XPCNotDefault
.1c5d	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1c60	80 08		bra $1c6a			bra 	_XPCSend
.1c62					_XPCNotDefault:
.1c62	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1c65	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1c68	d0 08		bne $1c72			bne 	_XPCError
.1c6a					_XPCSend:
.1c6a	68		pla				pla 								; restore character
.1c6b	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1c6e	7a		ply				ply
.1c6f	fa		plx				plx
.1c70	68		pla				pla
.1c71	60		rts				rts
.1c72					_XPCError:
.1c72	4c d6 1f	jmp $1fd6		jmp	ErrorV_channel
.1c75					XReadClock:
.1c75	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1c78	60		rts				rts
.1c79					XWriteClock:
.1c79	48		pha				pha
.1c7a	da		phx				phx
.1c7b	5a		phy				phy
.1c7c	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1c7f	7a		ply				ply
.1c80	fa		plx				plx
.1c81	68		pla				pla
.1c82	60		rts				rts
.1c83					CommandScreen:
.1c83	fa		plx				plx
.1c84	da		phx				phx
.1c85	5a		phy				phy
.1c86	20 10 10	jsr $1010			jsr 	GetInteger8Bit
.1c89	18		clc				clc
.1c8a	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1c8d	7a		ply				ply
.1c8e	fa		plx				plx
.1c8f	4c 34 08	jmp $0834			jmp 	NextCommand
.1c92					XCommandSleep:
.1c92	fa		plx				plx
.1c93	5a		phy				phy
.1c94	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.1c97	ca		dex				dex
.1c98	20 75 1c	jsr $1c75			jsr 	XReadClock 					; read clock to YXA
.1c9b	18		clc				clc 								; calculate end time in zTemp0
.1c9c	65 3e		adc $3e				adc 	NSMantissa0
.1c9e	85 2c		sta $2c				sta 	zTemp0
.1ca0	8a		txa				txa
.1ca1	65 4a		adc $4a				adc 	NSMantissa1
.1ca3	85 2d		sta $2d				sta 	zTemp0+1
.1ca5					_XCWait:
.1ca5	20 75 1c	jsr $1c75			jsr 	XReadClock 					; and wait for it.
.1ca8	c5 2c		cmp $2c				cmp 	zTemp0
.1caa	d0 f9		bne $1ca5			bne 	_XCWait
.1cac	e4 2d		cpx $2d				cpx 	zTemp0+1
.1cae	d0 f5		bne $1ca5			bne 	_XCWait
.1cb0	a2 ff		ldx #$ff			ldx 	#$FF
.1cb2	7a		ply				ply
.1cb3	4c 34 08	jmp $0834			jmp 	NextCommand
.1cb6					X16_Audio_FMINIT:
.1cb6	fa		plx				plx
.1cb7	5a		phy			phy
.1cb8	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cbb	63 c0					.word	X16A_ym_init
>1cbd	0a					.byte	X16_AudioCodeBank
.1cbe	a2 ff		ldx #$ff		ldx	#$FF
.1cc0	7a		ply			ply
.1cc1	4c 34 08	jmp $0834			jmp 	NextCommand
.1cc4					X16_Audio_FMNOTE:
.1cc4	fa		plx				plx
.1cc5	5a		phy			phy
.1cc6	20 db 09	jsr $09db		jsr		X16_Audio_Parameters8_8
.1cc9	18		clc			clc
.1cca	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1ccd	03 c0					.word	X16A_bas_fmnote
>1ccf	0a					.byte	X16_AudioCodeBank
.1cd0	a2 ff		ldx #$ff		ldx	#$FF
.1cd2	7a		ply			ply
.1cd3	4c 34 08	jmp $0834			jmp 	NextCommand
.1cd6					X16_Audio_FMDRUM:
.1cd6	fa		plx				plx
.1cd7	5a		phy			phy
.1cd8	20 db 09	jsr $09db		jsr		X16_Audio_Parameters8_8
.1cdb	18		clc			clc
.1cdc	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cdf	6f c0					.word	X16A_ym_playdrum
>1ce1	0a					.byte	X16_AudioCodeBank
.1ce2	a2 ff		ldx #$ff		ldx	#$FF
.1ce4	7a		ply			ply
.1ce5	4c 34 08	jmp $0834			jmp 	NextCommand
.1ce8					X16_Audio_FMINST:
.1ce8	fa		plx				plx
.1ce9	5a		phy			phy
.1cea	20 db 09	jsr $09db		jsr		X16_Audio_Parameters8_8
.1ced	38		sec			sec
.1cee	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cf1	69 c0					.word	X16A_ym_loadpatch
>1cf3	0a					.byte	X16_AudioCodeBank
.1cf4	a2 ff		ldx #$ff		ldx	#$FF
.1cf6	7a		ply			ply
.1cf7	4c 34 08	jmp $0834			jmp 	NextCommand
.1cfa					X16_Audio_FMVIB:
.1cfa	fa		plx				plx
.1cfb	5a		phy			phy
.1cfc	20 db 09	jsr $09db		jsr		X16_Audio_Parameters8_8
.1cff	18		clc			clc
.1d00	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d03	09 c0					.word	X16A_bas_fmvib
>1d05	0a					.byte	X16_AudioCodeBank
.1d06	a2 ff		ldx #$ff		ldx	#$FF
.1d08	7a		ply			ply
.1d09	4c 34 08	jmp $0834			jmp 	NextCommand
.1d0c					X16_Audio_FMFREQ:
.1d0c	fa		plx				plx
.1d0d	5a		phy			phy
.1d0e	20 d5 09	jsr $09d5		jsr		X16_Audio_Parameters8_16
.1d11	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d14	00 c0					.word	X16A_bas_fmfreq
>1d16	0a					.byte	X16_AudioCodeBank
.1d17	a2 ff		ldx #$ff		ldx	#$FF
.1d19	7a		ply			ply
.1d1a	4c 34 08	jmp $0834			jmp 	NextCommand
.1d1d					X16_Audio_FMVOL:
.1d1d	fa		plx				plx
.1d1e	5a		phy			phy
.1d1f	20 db 09	jsr $09db		jsr		X16_Audio_Parameters8_8
.1d22	18		clc			clc
.1d23	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d26	75 c0					.word	X16A_ym_setatten
>1d28	0a					.byte	X16_AudioCodeBank
.1d29	a2 ff		ldx #$ff		ldx	#$FF
.1d2b	7a		ply			ply
.1d2c	4c 34 08	jmp $0834			jmp 	NextCommand
.1d2f					X16_Audio_FMPAN:
.1d2f	fa		plx				plx
.1d30	5a		phy			phy
.1d31	20 db 09	jsr $09db		jsr		X16_Audio_Parameters8_8
.1d34	18		clc			clc
.1d35	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d38	7e c0					.word	X16A_ym_setpan
>1d3a	0a					.byte	X16_AudioCodeBank
.1d3b	a2 ff		ldx #$ff		ldx	#$FF
.1d3d	7a		ply			ply
.1d3e	4c 34 08	jmp $0834			jmp 	NextCommand
.1d41					X16_Audio_FMPLAY:
.1d41	fa		plx				plx
.1d42	5a		phy			phy
.1d43	20 ec 09	jsr $09ec		jsr		X16_Audio_Parameters8_String
.1d46	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d49	06 c0					.word	X16A_bas_fmplaystring
>1d4b	0a					.byte	X16_AudioCodeBank
.1d4c	a2 ff		ldx #$ff		ldx	#$FF
.1d4e	7a		ply			ply
.1d4f	4c 34 08	jmp $0834			jmp 	NextCommand
.1d52					X16_Audio_FMCHORD:
.1d52	fa		plx				plx
.1d53	5a		phy			phy
.1d54	20 ec 09	jsr $09ec		jsr		X16_Audio_Parameters8_String
.1d57	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d5a	8d c0					.word	X16A_bas_fmchordstring
>1d5c	0a					.byte	X16_AudioCodeBank
.1d5d	a2 ff		ldx #$ff		ldx	#$FF
.1d5f	7a		ply			ply
.1d60	4c 34 08	jmp $0834			jmp 	NextCommand
.1d63					X16_Audio_FMPOKE:
.1d63	fa		plx				plx
.1d64	5a		phy			phy
.1d65	20 db 09	jsr $09db		jsr		X16_Audio_Parameters8_8
.1d68	18		clc			clc
.1d69	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d6c	8a c0					.word	X16A_ym_write
>1d6e	0a					.byte	X16_AudioCodeBank
.1d6f	a2 ff		ldx #$ff		ldx	#$FF
.1d71	7a		ply			ply
.1d72	4c 34 08	jmp $0834			jmp 	NextCommand
.1d75					X16_Audio_PSGINIT:
.1d75	fa		plx				plx
.1d76	5a		phy			phy
.1d77	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d7a	4b c0					.word	X16A_psg_init
>1d7c	0a					.byte	X16_AudioCodeBank
.1d7d	a2 ff		ldx #$ff		ldx	#$FF
.1d7f	7a		ply			ply
.1d80	4c 34 08	jmp $0834			jmp 	NextCommand
.1d83					X16_Audio_PSGNOTE:
.1d83	fa		plx				plx
.1d84	5a		phy			phy
.1d85	20 db 09	jsr $09db		jsr		X16_Audio_Parameters8_8
.1d88	18		clc			clc
.1d89	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d8c	12 c0					.word	X16A_bas_psgnote
>1d8e	0a					.byte	X16_AudioCodeBank
.1d8f	a2 ff		ldx #$ff		ldx	#$FF
.1d91	7a		ply			ply
.1d92	4c 34 08	jmp $0834			jmp 	NextCommand
.1d95					X16_Audio_PSGVOL:
.1d95	fa		plx				plx
.1d96	5a		phy			phy
.1d97	20 db 09	jsr $09db		jsr		X16_Audio_Parameters8_8
.1d9a	18		clc			clc
.1d9b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d9e	54 c0					.word	X16A_psg_setatten
>1da0	0a					.byte	X16_AudioCodeBank
.1da1	a2 ff		ldx #$ff		ldx	#$FF
.1da3	7a		ply			ply
.1da4	4c 34 08	jmp $0834			jmp 	NextCommand
.1da7					X16_Audio_PSGWAV:
.1da7	fa		plx				plx
.1da8	5a		phy			phy
.1da9	20 db 09	jsr $09db		jsr		X16_Audio_Parameters8_8
.1dac	18		clc			clc
.1dad	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1db0	15 c0					.word	X16A_bas_psgwav
>1db2	0a					.byte	X16_AudioCodeBank
.1db3	a2 ff		ldx #$ff		ldx	#$FF
.1db5	7a		ply			ply
.1db6	4c 34 08	jmp $0834			jmp 	NextCommand
.1db9					X16_Audio_PSGFREQ:
.1db9	fa		plx				plx
.1dba	5a		phy			phy
.1dbb	20 d5 09	jsr $09d5		jsr		X16_Audio_Parameters8_16
.1dbe	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dc1	0f c0					.word	X16A_bas_psgfreq
>1dc3	0a					.byte	X16_AudioCodeBank
.1dc4	a2 ff		ldx #$ff		ldx	#$FF
.1dc6	7a		ply			ply
.1dc7	4c 34 08	jmp $0834			jmp 	NextCommand
.1dca					X16_Audio_PSGPAN:
.1dca	fa		plx				plx
.1dcb	5a		phy			phy
.1dcc	20 db 09	jsr $09db		jsr		X16_Audio_Parameters8_8
.1dcf	18		clc			clc
.1dd0	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dd3	5a c0					.word	X16A_psg_setpan
>1dd5	0a					.byte	X16_AudioCodeBank
.1dd6	a2 ff		ldx #$ff		ldx	#$FF
.1dd8	7a		ply			ply
.1dd9	4c 34 08	jmp $0834			jmp 	NextCommand
.1ddc					X16_Audio_PSGPLAY:
.1ddc	fa		plx				plx
.1ddd	5a		phy			phy
.1dde	20 ec 09	jsr $09ec		jsr		X16_Audio_Parameters8_String
.1de1	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1de4	18 c0					.word	X16A_bas_psgplaystring
>1de6	0a					.byte	X16_AudioCodeBank
.1de7	a2 ff		ldx #$ff		ldx	#$FF
.1de9	7a		ply			ply
.1dea	4c 34 08	jmp $0834			jmp 	NextCommand
.1ded					X16_Audio_PSGCHORD:
.1ded	fa		plx				plx
.1dee	5a		phy			phy
.1def	20 ec 09	jsr $09ec		jsr		X16_Audio_Parameters8_String
.1df2	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1df5	90 c0					.word	X16A_bas_psgchordstring
>1df7	0a					.byte	X16_AudioCodeBank
.1df8	a2 ff		ldx #$ff		ldx	#$FF
.1dfa	7a		ply			ply
.1dfb	4c 34 08	jmp $0834			jmp 	NextCommand
.1dfe					CommandCls:
.1dfe	fa		plx				plx
.1dff	a9 93		lda #$93			lda 	#147
.1e01	20 55 1c	jsr $1c55			jsr 	XPrintCharacterToChannel
.1e04	4c 34 08	jmp $0834			jmp 	NextCommand
.1e07					CommandLocate:
.1e07	fa		plx				plx
.1e08	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.1e0b	ca		dex				dex
.1e0c	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.1e0f	ca		dex				dex
.1e10	a9 13		lda #$13			lda 	#$13 						; home.
.1e12	20 55 1c	jsr $1c55			jsr 	XPrintCharacterToChannel
.1e15	a9 1d		lda #$1d			lda 	#$1D 						; do cursor rights
.1e17	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1e19	20 26 1e	jsr $1e26			jsr 	_CLOutputXA
.1e1c	a9 11		lda #$11			lda 	#$11 						; do cursor downs.
.1e1e	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e20	20 26 1e	jsr $1e26			jsr 	_CLOutputXA
.1e23	4c 34 08	jmp $0834			jmp 	NextCommand
.1e26					_CLOutputXA:
.1e26	ca		dex				dex
.1e27	f0 07		beq $1e30			beq 	_CLOExit
.1e29	30 05		bmi $1e30			bmi 	_CLOExit
.1e2b	20 55 1c	jsr $1c55			jsr 	XPrintCharacterToChannel
.1e2e	80 f6		bra $1e26			bra 	_CLOutputXA
.1e30					_CLOExit:
.1e30	60		rts				rts
.1e31					CommandColor:
.1e31	fa		plx				plx
.1e32	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.1e35	ca		dex				dex
.1e36	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.1e39	ca		dex				dex
.1e3a	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1e3c	c9 ff		cmp #$ff			cmp 	#$FF
.1e3e	f0 08		beq $1e48			beq 	_CCNoBGR 					; if so, change background
.1e40	20 50 1e	jsr $1e50			jsr 	_CCSetColour
.1e43	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1e45	20 55 1c	jsr $1c55			jsr 	XPrintCharacterToChannel
.1e48					_CCNoBGR:
.1e48	a5 3e		lda $3e				lda 	NSMantissa0
.1e4a	20 50 1e	jsr $1e50			jsr 	_CCSetColour
.1e4d	4c 34 08	jmp $0834			jmp 	NextCommand
.1e50					_CCSetColour:
.1e50	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1e52	aa		tax				tax
.1e53	bd 5a 1e	lda $1e5a,x			lda 	_CCCommandTable,x
.1e56	20 55 1c	jsr $1c55			jsr 	XPrintCharacterToChannel
.1e59	60		rts				rts
.1e5a					_CCCommandTable:
>1e5a	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1e62	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1e6a					CommandVPOKE:
.1e6a	fa		plx				plx
.1e6b	20 10 10	jsr $1010			jsr 	GetInteger8Bit 				; poke value
.1e6e	48		pha				pha
.1e6f	ca		dex				dex
.1e70	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.1e73	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e75	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1e78	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1e7a	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1e7d	ca		dex				dex
.1e7e	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.1e81	20 10 10	jsr $1010			jsr 	GetInteger8Bit
.1e84	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1e87	ca		dex				dex
.1e88	68		pla				pla 								; poke value back
.1e89	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1e8c	4c 34 08	jmp $0834			jmp 	NextCommand
.1e8f					CommandVPEEK:
.1e8f	fa		plx				plx
.1e90	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.1e93	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e95	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1e98	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1e9a	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1e9d	ca		dex				dex
.1e9e	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.1ea1	20 10 10	jsr $1010			jsr 	GetInteger8Bit
.1ea4	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1ea7	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1eaa	20 1f 26	jsr $261f			jsr 	FloatSetByte 				; return as byte
.1ead	4c 34 08	jmp $0834			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1eb0					SetErrorHandler:
.1eb0	8c 6e 05	sty $056e			sty 	ErrorHandlerVector+1
.1eb3	8e 6d 05	stx $056d			stx 	ErrorHandlerVector
.1eb6	60		rts				rts
.1eb7					CallErrorHandler:
.1eb7	6c 6d 05	jmp ($056d)			jmp 	(ErrorHandlerVector)
.056d					ErrorHandlerVector:
>056d							.fill 	2
.1eba					ErrorV_range:
.1eba	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1ebd	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1ec5	41 4e 47 45 00
.1eca					ErrorV_value:
.1eca	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1ecd	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1ed5	45 00
.1ed7					ErrorV_syntax:
.1ed7	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1eda	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1ee2	52 52 4f 52 00
.1ee7					ErrorV_type:
.1ee7	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1eea	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1ef2	4d 41 54 43 48 00
.1ef8					ErrorV_unimplemented:
.1ef8	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1efb	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f03	45 4d 45 4e 54 45 44 00
.1f0b					ErrorV_assert:
.1f0b	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1f0e	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f16	41 49 4c 00
.1f1a					ErrorV_line:
.1f1a	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1f1d	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f25	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f31					ErrorV_internal:
.1f31	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1f34	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f3c	20 45 52 52 4f 52 00
.1f43					ErrorV_divzero:
.1f43	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1f46	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1f4e	59 20 5a 45 52 4f 00
.1f55					ErrorV_structure:
.1f55	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1f58	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1f60	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1f6c					ErrorV_stop:
.1f6c	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1f6f	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1f77	53 54 4f 50 50 45 44 00
.1f7f					ErrorV_data:
.1f7f	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1f82	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1f8a	41 54 41 00
.1f8e					ErrorV_undeclared:
.1f8e	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1f91	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1f99	41 52 52 41 59 00
.1f9f					ErrorV_redefine:
.1f9f	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1fa2	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1faa	44 45 46 49 4e 45 44 00
.1fb2					ErrorV_index:
.1fb2	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1fb5	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1fbd	59 20 49 4e 44 45 58 00
.1fc5					ErrorV_memory:
.1fc5	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1fc8	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>1fd0	45 4d 4f 52 59 00
.1fd6					ErrorV_channel:
.1fd6	20 b7 1e	jsr $1eb7		jsr	CallErrorHandler
>1fd9	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>1fe1	54 50 55 54 20 45 52 52 4f 52 00
.1fec					MoveObjectForward:
.1fec	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.1fee	c9 ff		cmp #$ff			cmp 	#$FF
.1ff0	f0 36		beq $2028			beq 	_MOFEnd
.1ff2	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.1ff4	90 24		bcc $201a			bcc 	_MOFAdvance1 				; forward 1
.1ff6	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.1ff8	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.1ffa	90 20		bcc $201c			bcc 	_MOFAdvanceY
.1ffc	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.1ffe	90 1a		bcc $201a			bcc 	_MOFAdvance1 				; forward 1
.2000	a8		tay				tay 								; read the size.
.2001	b9 66 1f	lda $1f66,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.2004	a8		tay				tay
.2005	c8		iny				iny 								; add 1 for the system token.
.2006	d0 14		bne $201c			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2008	a0 01		ldy #$01			ldy 	#1 							; get length byte
.200a	b1 2a		lda ($2a),y			lda 	(objPtr),y
.200c	a8		tay				tay 								; into Y.
.200d	18		clc				clc
.200e	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.2010	69 02		adc #$02			adc 	#2
.2012	85 2a		sta $2a				sta 	objPtr
.2014	90 02		bcc $2018			bcc 	_MOFNoCarry1
.2016	e6 2b		inc $2b				inc 	objPtr+1
.2018					_MOFNoCarry1:
.2018	80 02		bra $201c			bra 	_MOFAdvanceY
.201a					_MOFAdvance1:
.201a	a0 01		ldy #$01			ldy 	#1
.201c					_MOFAdvanceY:
.201c	98		tya				tya 								; add Y to objPtr
.201d	18		clc				clc
.201e	65 2a		adc $2a				adc 	objPtr
.2020	85 2a		sta $2a				sta 	objPtr
.2022	90 02		bcc $2026			bcc 	_MOFNoCarry2
.2024	e6 2b		inc $2b				inc 	objPtr+1
.2026					_MOFNoCarry2:
.2026	18		clc				clc 								; not completed.
.2027	60		rts				rts
.2028					_MOFEnd:
.2028	e6 2a		inc $2a				inc 	objPtr
.202a	d0 02		bne $202e			bne 	_MOFENoCarry
.202c	e6 2b		inc $2b				inc 	objPtr+1
.202e					_MOFENoCarry:
.202e	38		sec				sec
.202f	60		rts				rts
.2030					MOFSizeTable:
>2030	01					.byte	1         	; $ca .shift
>2031	01					.byte	1         	; $cb .byte
>2032	02					.byte	2         	; $cc .word
>2033	05					.byte	5         	; $cd .float
>2034	ff					.byte	255       	; $ce .string
>2035	ff					.byte	255       	; $cf .data
>2036	02					.byte	2         	; $d0 .goto
>2037	02					.byte	2         	; $d1 .gosub
>2038	02					.byte	2         	; $d2 .goto.z
>2039	02					.byte	2         	; $d3 .goto.nz
>203a	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.056f					numberBuffer:
>056f							.fill 	34
.203b					FloatSubtract:
.203b	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.203d	49 80		eor #$80			eor 	#$80
.203f	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.2041					FloatAdd:
.2041	ca		dex				dex
.2042	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.2044	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2046	15 62		ora $62,x			ora 	NSMantissa3,x
.2048	15 63		ora $63,x			ora 	NSMantissa3+1,x
.204a	d0 04		bne $2050			bne 	_FAUseFloat
.204c	20 dd 23	jsr $23dd			jsr 	FloatInt32Add 				; use the int32 one.
.204f	60		rts				rts
.2050					_FAUseFloat:
.2050	20 72 23	jsr $2372			jsr 	FloatNormalise 				; normalise S[X]
.2053	f0 51		beq $20a6			beq 	_FAReturn1
.2055	e8		inx				inx 								; normalise S[X+1]
.2056	20 72 23	jsr $2372			jsr 	FloatNormalise
.2059	ca		dex				dex
.205a	c9 00		cmp #$00			cmp 	#0
.205c	f0 60		beq $20be			beq 	_FAExit 					; if so, just return A
.205e	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.2060	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.2062	f0 18		beq $207c			beq 	_FAExponentsEqual
.2064	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.2066	a8		tay				tay
.2067	38		sec				sec 								; do a signed comparison of the exponents.
.2068	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.206a	50 02		bvc $206e			bvc 	_FANoSignedChange
.206c	49 80		eor #$80			eor 	#$80
.206e					_FANoSignedChange:
.206e	29 80		and #$80			and 	#$80
.2070	10 02		bpl $2074			bpl 	_FAHaveMax
.2072	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.2074					_FAHaveMax:
.2074	20 bf 20	jsr $20bf			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.2077	e8		inx				inx
.2078	20 bf 20	jsr $20bf			jsr 	_FAShiftToExponent
.207b	ca		dex				dex
.207c					_FAExponentsEqual:
.207c	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.207e	55 33		eor $33,x			eor 	NSStatus+1,x
.2080	30 0e		bmi $2090			bmi 	_FADifferentSigns
.2082	20 a9 23	jsr $23a9			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.2085	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.2087	10 35		bpl $20be			bpl 	_FAExit 					; if no, we are done.
.2089	20 36 26	jsr $2636			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.208c	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.208e	80 2e		bra $20be			bra 	_FAExit
.2090					_FADifferentSigns:
.2090	20 c3 23	jsr $23c3			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.2093	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.2095	10 06		bpl $209d			bpl 	_FACheckZero 				; if no, check for -0
.2097	20 df 25	jsr $25df			jsr 	FloatNegate 					; netate result
.209a	20 e6 25	jsr $25e6			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.209d					_FACheckZero:
.209d	20 3f 26	jsr $263f			jsr 	FloatIsZero	 				; check for -0
.20a0	d0 1c		bne $20be			bne 	_FAExit
.20a2	74 32		stz $32,x			stz 	NSStatus,x
.20a4	80 18		bra $20be			bra 	_FAExit
.20a6					_FAReturn1:
.20a6	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20a8	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20aa	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.20ac	95 4a		sta $4a,x			sta 	NSMantissa1,x
.20ae	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.20b0	95 56		sta $56,x			sta 	NSMantissa2,x
.20b2	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.20b4	95 62		sta $62,x			sta 	NSMantissa3,x
.20b6	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.20b8	95 6e		sta $6e,x			sta 	NSExponent,x
.20ba	b5 33		lda $33,x			lda 	NSStatus+1,x
.20bc	95 32		sta $32,x			sta 	NSStatus,x
.20be					_FAExit:
.20be	60		rts				rts
.20bf					_FAShiftToExponent:
.20bf					_FAShiftToExponent2:
.20bf	98		tya				tya 								; compare Y to exponent
.20c0	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.20c2	f0 07		beq $20cb			beq 	_FASEExit 					; exit if so.
.20c4	20 36 26	jsr $2636			jsr 	FloatShiftRight	 			; shift the mantissa right
.20c7	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.20c9	80 f4		bra $20bf			bra 	_FAShiftToExponent2
.20cb					_FASEExit:
.20cb	60		rts				rts
.20cc					CompareEqual:
.20cc	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20ce	d0 09		bne $20d9			bne 	ReturnFalse
.20d0					ReturnTrue:
.20d0	a9 01		lda #$01			lda 	#1
.20d2	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20d4	a9 80		lda #$80			lda 	#$80
.20d6	95 32		sta $32,x			sta 	NSStatus,x
.20d8	60		rts				rts
.20d9					ReturnFalse:
.20d9	74 3e		stz $3e,x			stz 	NSMantissa0,x
.20db	60		rts				rts
.20dc					CompareNotEqual:
.20dc	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20de	d0 f0		bne $20d0			bne 	ReturnTrue
.20e0	80 f7		bra $20d9			bra 	ReturnFalse
.20e2					CompareLess:
.20e2	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20e4	c9 ff		cmp #$ff			cmp 	#$FF
.20e6	f0 e8		beq $20d0			beq 	ReturnTrue
.20e8	80 ef		bra $20d9			bra 	ReturnFalse
.20ea					CompareGreater:
.20ea	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20ec	c9 01		cmp #$01			cmp 	#$01
.20ee	f0 e0		beq $20d0			beq 	ReturnTrue
.20f0	80 e7		bra $20d9			bra 	ReturnFalse
.20f2					CompareLessEqual:
.20f2	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20f4	c9 01		cmp #$01			cmp 	#$01
.20f6	d0 d8		bne $20d0			bne 	ReturnTrue
.20f8	80 df		bra $20d9			bra 	ReturnFalse
.20fa					CompareGreaterEqual:
.20fa	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20fc	c9 ff		cmp #$ff			cmp 	#$FF
.20fe	d0 d0		bne $20d0			bne 	ReturnTrue
.2100	80 d7		bra $20d9			bra 	ReturnFalse
.2102					FloatCompare:
.2102	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.2104	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.2106	48		pha				pha
.2107	20 3b 20	jsr $203b			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.210a	68		pla				pla
.210b	d0 0c		bne $2119			bne 	_FCCompareFloat
.210d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.210f	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2111	15 56		ora $56,x			ora 	NSMantissa2,x
.2113	15 62		ora $62,x			ora 	NSMantissa3,x
.2115	f0 14		beq $212b			beq 	_FCExit 					; if zero, return zero
.2117	80 0a		bra $2123			bra 	_FCSign
.2119					_FCCompareFloat:
.2119	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.211b	29 f0		and #$f0			and 	#$F0
.211d	15 56		ora $56,x			ora 	NSMantissa2,x
.211f	15 62		ora $62,x			ora 	NSMantissa3,x
.2121	f0 08		beq $212b			beq 	_FCExit 					; zero, so approximately identical
.2123					_FCSign:
.2123	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2125	34 32		bit $32,x			bit 	NSStatus,x
.2127	10 02		bpl $212b			bpl 	_FCExit
.2129					_FCNegative:
.2129	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.212b					_FCExit:
.212b	20 1f 26	jsr $261f			jsr 	FloatSetByte 				; set the result 255,0,1
.212e	60		rts				rts
.212f					FloatScalarTable:
>212f	66 66 66 66				.dword $66666666 ; 0.1
>2133	de					.byte $de
>2134	1f 85 eb 51				.dword $51eb851f ; 0.01
>2138	db					.byte $db
>2139	4c 37 89 41				.dword $4189374c ; 0.001
>213d	d8					.byte $d8
>213e	ac 8b db 68				.dword $68db8bac ; 0.0001
>2142	d4					.byte $d4
>2143	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>2147	d1					.byte $d1
>2148	83 de 1b 43				.dword $431bde83 ; 1e-06
>214c	ce					.byte $ce
>214d	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>2151	ca					.byte $ca
>2152	89 3b e6 55				.dword $55e63b89 ; 1e-08
>2156	c7					.byte $c7
>2157	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>215b	c4					.byte $c4
>215c	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>2160	c0					.byte $c0
>2161	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>2165	bd					.byte $bd
.2166					FloatDivide:
.2166	48		pha				pha
.2167	20 72 23	jsr $2372			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.216a	ca		dex				dex
.216b	c9 00		cmp #$00			cmp 	#0
.216d	f0 1e		beq $218d			beq 	_FDZero
.216f	20 72 23	jsr $2372			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2172	f0 16		beq $218a			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.2174	20 d5 21	jsr $21d5			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.2177	20 a2 21	jsr $21a2			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.217a	20 72 23	jsr $2372			jsr		FloatNormalise 				; renormalise
.217d	20 68 23	jsr $2368			jsr 	FloatCalculateSign 			; calculate result sign
.2180	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.2182	38		sec				sec
.2183	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.2185	38		sec				sec
.2186	e9 1e		sbc #$1e			sbc 	#30
.2188	95 6e		sta $6e,x			sta 	NSExponent,x
.218a					_FDExit:
.218a	68		pla				pla
.218b	18		clc				clc
.218c	60		rts				rts
.218d					_FDZero:
.218d	68		pla				pla
.218e	38		sec				sec
.218f	60		rts				rts
.2190					DivideInt32:
.2190	20 58 22	jsr $2258			jsr 	FloatIntegerPart 			; make both integers
.2193	ca		dex				dex
.2194	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.2197	20 b3 21	jsr $21b3			jsr 	Int32Divide 				; divide
.219a	20 a2 21	jsr $21a2			jsr 	NSMCopyPlusTwoToZero 		; copy result
.219d	20 68 23	jsr $2368			jsr 	FloatCalculateSign 			; calculate result sign
.21a0	18		clc				clc
.21a1	60		rts				rts
.21a2					NSMCopyPlusTwoToZero:
.21a2	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21a4	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21a6	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21a8	95 4a		sta $4a,x			sta 	NSMantissa1,x
.21aa	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.21ac	95 56		sta $56,x			sta 	NSMantissa2,x
.21ae	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.21b0	95 62		sta $62,x			sta 	NSMantissa3,x
.21b2	60		rts				rts
.21b3					Int32Divide:
.21b3	48		pha				pha 								; save AXY
.21b4	5a		phy				phy
.21b5	20 00 26	jsr $2600			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.21b8	20 19 26	jsr $2619			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.21bb	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.21bd					_I32DivideLoop:
.21bd	e8		inx				inx
.21be	e8		inx				inx
.21bf	20 2c 26	jsr $262c			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.21c2	ca		dex				dex
.21c3	ca		dex				dex
.21c4	20 2d 26	jsr $262d			jsr 	FloatRotateLeft
.21c7	20 f3 21	jsr $21f3			jsr 	FloatDivideCheck 			; check if subtract possible
.21ca	90 02		bcc $21ce			bcc 	_I32DivideNoCarryIn
.21cc	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.21ce					_I32DivideNoCarryIn:
.21ce	88		dey				dey 								; loop round till division completed.
.21cf	d0 ec		bne $21bd			bne 	_I32DivideLoop
.21d1	7a		ply				ply 								; restore AXY and exit
.21d2	68		pla				pla
.21d3	18		clc				clc
.21d4	60		rts				rts
.21d5					Int32ShiftDivide:
.21d5	48		pha				pha 								; save AY
.21d6	5a		phy				phy
.21d7	e8		inx				inx 								; clear S[X+2]
.21d8	e8		inx				inx
.21d9	20 1d 26	jsr $261d			jsr 	FloatSetZero
.21dc	ca		dex				dex
.21dd	ca		dex				dex
.21de	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.21e0					_I32SDLoop:
.21e0	20 f3 21	jsr $21f3			jsr 	FloatDivideCheck 			; check if subtract possible
.21e3	e8		inx				inx
.21e4	e8		inx				inx
.21e5	20 2d 26	jsr $262d			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.21e8	ca		dex				dex
.21e9	ca		dex				dex
.21ea	20 2d 26	jsr $262d			jsr 	FloatRotateLeft
.21ed	88		dey				dey 	 							; do 31 times
.21ee	d0 f0		bne $21e0			bne 	_I32SDLoop
.21f0	7a		ply				ply 								; restore AY and exit
.21f1	68		pla				pla
.21f2	60		rts				rts
.21f3					FloatDivideCheck:
.21f3	20 c3 23	jsr $23c3			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.21f6	b0 04		bcs $21fc			bcs 	_DCSExit 					; if carry set, then could do, exit
.21f8	20 a9 23	jsr $23a9			jsr 	FloatAddTopTwoStack 		; add it back in
.21fb	18		clc				clc 								; and return False
.21fc					_DCSExit:
.21fc	60		rts				rts
.21fd					FloatFractionalPart:
.21fd	5a		phy				phy
.21fe	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.2200	29 7f		and #$7f			and 	#$7F
.2202	95 32		sta $32,x			sta 	NSStatus,x
.2204	20 72 23	jsr $2372			jsr 	FloatNormalise
.2207	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2209	38		sec				sec
.220a	e9 e0		sbc #$e0			sbc 	#$E0
.220c	90 29		bcc $2237			bcc 	_FFPExit 					; already fractional
.220e	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2210	b0 22		bcs $2234			bcs 	_FFPZero
.2212	a8		tay				tay 								; put count to do in Y
.2213	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.2215	20 3c 22	jsr $223c			jsr 	_FFPPartial
.2218	95 62		sta $62,x			sta 	NSMantissa3,x
.221a	b5 56		lda $56,x			lda 	NSMantissa2,x
.221c	20 3c 22	jsr $223c			jsr 	_FFPPartial
.221f	95 56		sta $56,x			sta 	NSMantissa2,x
.2221	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2223	20 3c 22	jsr $223c			jsr 	_FFPPartial
.2226	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2228	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.222a	20 3c 22	jsr $223c			jsr 	_FFPPartial
.222d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.222f	20 3f 26	jsr $263f			jsr 	FloatIsZero 					; zeroed check.
.2232	d0 03		bne $2237			bne 	_FFPExit
.2234					_FFPZero:
.2234	20 1d 26	jsr $261d			jsr 	FloatSetZero
.2237					_FFPExit:
.2237	20 72 23	jsr $2372			jsr 	FloatNormalise
.223a	7a		ply				ply
.223b	60		rts				rts
.223c					_FFPPartial:
.223c	c0 00		cpy #$00			cpy 	#0 							; no more to do
.223e	f0 17		beq $2257			beq 	_FFFPPExit
.2240	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.2242	b0 0c		bcs $2250			bcs 	_FFFPPWholeByte
.2244	5a		phy				phy
.2245					_FFFPPLeft:
.2245	0a		asl a				asl 	a
.2246	88		dey				dey
.2247	d0 fc		bne $2245			bne 	_FFFPPLeft
.2249	7a		ply				ply
.224a					_FFFPPRight:
.224a	4a		lsr a				lsr 	a
.224b	88		dey				dey
.224c	d0 fc		bne $224a			bne 	_FFFPPRight
.224e	80 07		bra $2257			bra 	_FFFPPExit
.2250					_FFFPPWholeByte:
.2250	98		tya				tya 								; subtract 8 from count
.2251	38		sec				sec
.2252	e9 08		sbc #$08			sbc 	#8
.2254	a8		tay				tay
.2255	a9 00		lda #$00			lda 	#0 							; and clear all
.2257					_FFFPPExit:
.2257	60		rts				rts
.2258					FloatIntegerPart:
.2258	48		pha				pha
.2259	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.225b	f0 1d		beq $227a			beq 	_FIPExit 					; if so do nothing
.225d	20 3f 26	jsr $263f			jsr 	FloatIsZero 				; is it zero ?
.2260	f0 15		beq $2277			beq 	_FIPZero 					; if so return zero.
.2262	20 72 23	jsr $2372			jsr 	FloatNormalise 				; normalise
.2265	f0 10		beq $2277			beq 	_FIPZero 					; normalised to zero, exit zero
.2267					_FIPShift:
.2267	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2269	10 07		bpl $2272			bpl 	_FIPCheckZero
.226b	20 36 26	jsr $2636			jsr 	FloatShiftRight 			; shift mantissa right
.226e	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.2270	80 f5		bra $2267			bra 	_FIPShift
.2272					_FIPCheckZero:
.2272	20 3f 26	jsr $263f			jsr 	FloatIsZero 				; avoid -0 problem
.2275	d0 03		bne $227a			bne 	_FIPExit 					; set to zero if mantissa zero.
.2277					_FIPZero:
.2277	20 1d 26	jsr $261d			jsr 	FloatSetZero
.227a					_FIPExit:
.227a	68		pla				pla
.227b	60		rts				rts
.227c					FloatIntegerPartDown:
.227c	48		pha				pha
.227d	5a		phy				phy
.227e	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.2280	f0 36		beq $22b8			beq 	_FIPExit 					; if so do nothing
.2282	20 3f 26	jsr $263f			jsr 	FloatIsZero 				; is it zero ?
.2285	f0 2e		beq $22b5			beq 	_FIPZero 					; if so return zero.
.2287	20 72 23	jsr $2372			jsr 	FloatNormalise 				; normalise
.228a	f0 29		beq $22b5			beq 	_FIPZero 					; normalised to zero, exit zero
.228c	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.228e					_FIPShift:
.228e	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2290	10 0a		bpl $229c			bpl 	_FIPCheckDown
.2292	20 36 26	jsr $2636			jsr 	FloatShiftRight 			; shift mantissa right
.2295	90 01		bcc $2298			bcc 	_FIPNoFrac 					; shifted a zero out ?
.2297	c8		iny				iny
.2298					_FIPNoFrac:
.2298	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.229a	80 f2		bra $228e			bra 	_FIPShift
.229c					_FIPCheckDown:
.229c	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.229e	f0 10		beq $22b0			beq 	_FIPCheckZero
.22a0	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22a2	10 0c		bpl $22b0			bpl 	_FIPCheckZero
.22a4	e8		inx				inx 								; -ve so round *down*.
.22a5	a9 01		lda #$01			lda 	#1
.22a7	20 1f 26	jsr $261f			jsr 	FloatSetByte
.22aa	20 df 25	jsr $25df			jsr 	FloatNegate
.22ad	20 41 20	jsr $2041			jsr 	FloatAdd
.22b0					_FIPCheckZero:
.22b0	20 3f 26	jsr $263f			jsr 	FloatIsZero 				; avoid -0 problem
.22b3	d0 03		bne $22b8			bne 	_FIPExit 					; set to zero if mantissa zero.
.22b5					_FIPZero:
.22b5	20 1d 26	jsr $261d			jsr 	FloatSetZero
.22b8					_FIPExit:
.22b8	7a		ply				ply
.22b9	68		pla				pla
.22ba	60		rts				rts
.22bb					FloatInt8Multiply:
.22bb	5a		phy				phy
.22bc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.22be	a8		tay				tay
.22bf	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.22c1					_FI8MLoop:
.22c1	98		tya				tya 								; shift right shifter right into carry
.22c2	4a		lsr a				lsr 	a
.22c3	a8		tay				tay
.22c4	90 0d		bcc $22d3			bcc 	_FI8MNoAdd
.22c6	18		clc				clc
.22c7	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.22c9	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.22cb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.22cd	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.22cf	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.22d1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.22d3					_FI8MNoAdd:
.22d3	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.22d5	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.22d7	c0 00		cpy #$00			cpy 	#0
.22d9	d0 e6		bne $22c1			bne 	_FI8MLoop 					; until right shifter zero.
.22db	7a		ply				ply
.22dc	60		rts				rts
.22dd					FloatMultiply:
.22dd	ca		dex				dex
.22de	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.22e0	15 6f		ora $6f,x			ora 	NSExponent+1,x
.22e2	15 62		ora $62,x			ora 	NSMantissa3,x
.22e4	15 63		ora $63,x			ora 	NSMantissa3+1,x
.22e6	d0 21		bne $2309			bne 	_FMUseFloat
.22e8	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.22ea	15 33		ora $33,x			ora 	NSStatus+1,x
.22ec	29 80		and #$80			and 	#$80
.22ee	15 62		ora $62,x			ora 	NSMantissa3,x
.22f0	15 56		ora $56,x			ora 	NSMantissa2,x
.22f2	15 4a		ora $4a,x			ora 	NSMantissa1,x
.22f4	15 63		ora $63,x			ora 	NSMantissa3+1,x
.22f6	15 57		ora $57,x			ora 	NSMantissa2+1,x
.22f8	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.22fa	d0 04		bne $2300			bne 	_FMInt32
.22fc	20 bb 22	jsr $22bb			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.22ff	60		rts				rts
.2300					_FMInt32:
.2300	20 2a 23	jsr $232a			jsr 	FloatMultiplyShort			; use the int32 one.
.2303	18		clc				clc 								; fix it up if gone out of range
.2304	75 6e		adc $6e,x			adc 	NSExponent,x
.2306	95 6e		sta $6e,x			sta 	NSExponent,x
.2308	60		rts				rts
.2309					_FMUseFloat:
.2309	20 72 23	jsr $2372			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.230c	f0 18		beq $2326			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.230e	e8		inx				inx
.230f	20 72 23	jsr $2372			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2312	ca		dex				dex
.2313	c9 00		cmp #$00			cmp 	#0
.2315	f0 0c		beq $2323			beq 	_FDSetZero
.2317	20 2a 23	jsr $232a			jsr 	FloatMultiplyShort 			; calculate the result.
.231a	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.231c	18		clc				clc
.231d	75 6f		adc $6f,x			adc 	NSExponent+1,x
.231f	95 6e		sta $6e,x			sta 	NSExponent,x
.2321	80 03		bra $2326			bra 	_FDExit
.2323					_FDSetZero:
.2323	20 1d 26	jsr $261d			jsr 	FloatSetZero 				; return 0
.2326					_FDExit:
.2326	20 72 23	jsr $2372			jsr 	FloatNormalise 				; normalise the result
.2329	60		rts				rts
.232a					FloatMultiplyShort:
.232a	5a		phy				phy 								; save Y
.232b	20 00 26	jsr $2600			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.232e	20 19 26	jsr $2619			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2331	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2333					_I32MLoop:
.2333	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2335	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.2337	15 58		ora $58,x			ora 	NSMantissa2+2,x
.2339	15 64		ora $64,x			ora 	NSMantissa3+2,x
.233b	f0 25		beq $2362			beq 	_I32MExit 					; exit if zero
.233d	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.233f	29 01		and #$01			and 	#1
.2341	f0 0d		beq $2350			beq 	_I32MNoAdd
.2343	20 a9 23	jsr $23a9			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.2346	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.2348	10 06		bpl $2350			bpl 	_I32MNoAdd
.234a					_I32ShiftRight:
.234a	20 36 26	jsr $2636			jsr 	FloatShiftRight 			; shift S[X] right
.234d	c8		iny				iny 								; increment shift count
.234e	80 09		bra $2359			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.2350					_I32MNoAdd:
.2350	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.2352	70 f6		bvs $234a			bvs 	_I32ShiftRight 				; instead.
.2354	e8		inx				inx
.2355	20 2c 26	jsr $262c			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.2358	ca		dex				dex
.2359					_I32MShiftUpper:
.2359	e8		inx				inx 								; shift S[X+2] right
.235a	e8		inx				inx
.235b	20 36 26	jsr $2636			jsr 	FloatShiftRight
.235e	ca		dex				dex
.235f	ca		dex				dex
.2360	80 d1		bra $2333			bra 	_I32MLoop 					; try again.
.2362					_I32MExit:
.2362	20 68 23	jsr $2368			jsr 	FloatCalculateSign
.2365	98		tya				tya 								; shift in A
.2366	7a		ply				ply 								; restore Y and exit
.2367	60		rts				rts
.2368					FloatCalculateSign:
.2368	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.236a	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.236c	55 33		eor $33,x			eor 	NSStatus+1,x
.236e	0a		asl a				asl 	a 							; shift bit 7 into carry
.236f	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.2371	60		rts				rts
.2372					FloatNormalise:
.2372	20 3f 26	jsr $263f			jsr 	FloatIsZero 				; if zero exit
.2375	d0 07		bne $237e			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.2377	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.2379	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.237b	a9 00		lda #$00			lda 	#0 							; set Z flag
.237d	60		rts				rts
.237e					_NSNormaliseOptimise:
.237e	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.2380	d0 19		bne $239b			bne 	_NSNormaliseLoop
.2382	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.2384	30 15		bmi $239b			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.2386	95 62		sta $62,x			sta 	NSMantissa3,x
.2388	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.238a	95 56		sta $56,x			sta 	NSMantissa2,x
.238c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.238e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2390	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2392	b5 6e		lda $6e,x			lda 	NSExponent,x
.2394	38		sec				sec
.2395	e9 08		sbc #$08			sbc 	#8
.2397	95 6e		sta $6e,x			sta 	NSExponent,x
.2399	80 e3		bra $237e			bra 	_NSNormaliseOptimise
.239b					_NSNormaliseLoop:
.239b	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.239d	70 07		bvs $23a6			bvs 	_NSNExit 					; exit if so with Z flag clear
.239f	20 2c 26	jsr $262c			jsr 	FloatShiftLeft 				; shift mantissa left
.23a2	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23a4	80 f5		bra $239b			bra 	_NSNormaliseLoop
.23a6					_NSNExit:
.23a6	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23a8	60		rts				rts
.23a9					FloatAddTopTwoStack:
.23a9	18		clc				clc
.23aa	b5 3e		lda $3e,x			lda		NSMantissa0,x
.23ac	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.23ae	95 3e		sta $3e,x			sta 	NSMantissa0,x
.23b0	b5 4a		lda $4a,x			lda		NSMantissa1,x
.23b2	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.23b4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23b6	b5 56		lda $56,x			lda		NSMantissa2,x
.23b8	75 57		adc $57,x			adc 		NSMantissa2+1,x
.23ba	95 56		sta $56,x			sta 	NSMantissa2,x
.23bc	b5 62		lda $62,x			lda		NSMantissa3,x
.23be	75 63		adc $63,x			adc 		NSMantissa3+1,x
.23c0	95 62		sta $62,x			sta 	NSMantissa3,x
.23c2	60		rts				rts
.23c3					FloatSubTopTwoStack:
.23c3	38		sec				sec
.23c4	b5 3e		lda $3e,x			lda		NSMantissa0,x
.23c6	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.23c8	95 3e		sta $3e,x			sta 	NSMantissa0,x
.23ca	b5 4a		lda $4a,x			lda		NSMantissa1,x
.23cc	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.23ce	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23d0	b5 56		lda $56,x			lda		NSMantissa2,x
.23d2	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.23d4	95 56		sta $56,x			sta 	NSMantissa2,x
.23d6	b5 62		lda $62,x			lda		NSMantissa3,x
.23d8	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.23da	95 62		sta $62,x			sta 	NSMantissa3,x
.23dc	60		rts				rts
.23dd					FloatInt32Add:
.23dd	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.23df	55 33		eor $33,x			eor 	NSStatus+1,x
.23e1	30 04		bmi $23e7			bmi 	_DiffSigns
.23e3	20 a9 23	jsr $23a9			jsr		FloatAddTopTwoStack
.23e6	60		rts				rts
.23e7					_DiffSigns:
.23e7	20 c3 23	jsr $23c3			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.23ea	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.23ec	10 07		bpl $23f5			bpl 	_AddExit
.23ee	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.23f0	95 32		sta $32,x			sta 	NSStatus,x
.23f2	20 e6 25	jsr $25e6			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.23f5					_AddExit:
.23f5	20 3f 26	jsr $263f			jsr 	FloatIsZero 				; check for -0
.23f8	d0 02		bne $23fc			bne 	_AddNonZero
.23fa	74 32		stz $32,x			stz 	NSStatus,x
.23fc					_AddNonZero:
.23fc	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.23fd					FloatEncodeStart:
.23fd	38		sec				sec
.23fe	80 01		bra $2401			bra 	FloatEncodeContinue+1
.2400					FloatEncodeContinue:
.2400	18		clc				clc
.2401					FloatEncode:
.2401	08		php				php 								; save reset flag.
.2402	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2404	f0 15		beq $241b			beq 	_ENIsOkay
.2406	c9 30		cmp #$30			cmp 	#"0"
.2408	90 04		bcc $240e			bcc 	_ENBadNumber
.240a	c9 3a		cmp #$3a			cmp 	#"9"+1
.240c	90 0d		bcc $241b			bcc 	_ENIsOkay
.240e					_ENBadNumber:
.240e	28		plp				plp 								; throw saved reset
.240f	ad 91 05	lda $0591			lda 	encodeState 				; if in decimal mode, construct final number
.2412	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2414	d0 03		bne $2419			bne 	_ENFail
.2416	4c 93 24	jmp $2493			jmp 	_ENConstructFinal
.2419					_ENFail:
.2419	18		clc				clc 								; not allowed
.241a	60		rts				rts
.241b					_ENIsOkay:
.241b	28		plp				plp 								; are we restarting
.241c	90 15		bcc $2433			bcc 	_ENNoRestart
.241e					_ENStartEncode:
.241e	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2420	f0 0c		beq $242e			beq 	_ENFirstDP
.2422	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2424	20 1f 26	jsr $261f			jsr 	FloatSetByte 				; in single byte mode.
.2427	a9 01		lda #$01			lda 	#ESTA_Low
.2429					_ENExitChange:
.2429	8d 91 05	sta $0591			sta 	encodeState 				; save new state
.242c	38		sec				sec
.242d	60		rts				rts
.242e					_ENFirstDP:
.242e	20 1d 26	jsr $261d			jsr 	FloatSetZero 				; clear integer part
.2431	80 3c		bra $246f			bra 	_ESTASwitchFloat			; go straight to float and exi
.2433					_ENNoRestart:
.2433	48		pha				pha 								; save digit or DP on stack.
.2434	ad 91 05	lda $0591			lda 	encodeState 				; get current state
.2437	c9 01		cmp #$01			cmp 	#ESTA_Low
.2439	f0 09		beq $2444			beq  	_ESTALowState
.243b	c9 02		cmp #$02			cmp 	#ESTA_High
.243d	f0 26		beq $2465			beq 	_ESTAHighState
.243f	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2441	f0 38		beq $247b			beq 	_ESTADecimalState
>2443	db						.byte 	$DB 						; causes a break in the emulator
.2444					_ESTALowState:
.2444	68		pla				pla 								; get value back
.2445	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.2447	f0 26		beq $246f			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.2449	29 0f		and #$0f			and 	#15 						; make digit
.244b	8d 92 05	sta $0592			sta 	digitTemp 					; save it.
.244e	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.2450	0a		asl a				asl 	a
.2451	0a		asl a				asl 	a
.2452	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2454	0a		asl a				asl 	a
.2455	6d 92 05	adc $0592			adc 	digitTemp
.2458	95 3e		sta $3e,x			sta 	NSMantissa0,x
.245a	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.245c	90 05		bcc $2463			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.245e	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.2460	8d 91 05	sta $0591			sta 	encodeState
.2463					_ESTANoSwitch:
.2463	38		sec				sec
.2464	60		rts				rts
.2465					_ESTAHighState:
.2465	68		pla				pla 								; get value back
.2466	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.2468	f0 05		beq $246f			beq 	_ESTASwitchFloat
.246a	20 c5 24	jsr $24c5			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.246d	38		sec				sec
.246e	60		rts				rts
.246f					_ESTASwitchFloat:
.246f	9c 93 05	stz $0593			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.2472	e8		inx				inx 								; zero the decimal additive.
.2473	20 1d 26	jsr $261d			jsr 	FloatSetZero
.2476	ca		dex				dex
.2477	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.2479	80 ae		bra $2429			bra 	_ENExitChange
.247b					_ESTADecimalState:
.247b	68		pla				pla 								; digit.
.247c	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.247e	f0 99		beq $2419			beq 	_ENFail
.2480	e8		inx				inx 								; put digit into fractional part of X+1
.2481	20 c5 24	jsr $24c5			jsr 	ESTAShiftDigitIntoMantissa
.2484	ca		dex				dex
.2485	ee 93 05	inc $0593			inc 	decimalCount 				; bump the count of decimals
.2488	ad 93 05	lda $0593			lda 	decimalCount 				; too many decimal digits.
.248b	c9 0b		cmp #$0b			cmp 	#11
.248d	f0 02		beq $2491			beq 	_ESTADSFail
.248f	38		sec				sec
.2490	60		rts				rts
.2491					_ESTADSFail:
.2491	18		clc				clc
.2492	60		rts				rts
.2493					_ENConstructFinal:
.2493	ad 93 05	lda $0593			lda 	decimalCount 				; get decimal count
.2496	f0 2b		beq $24c3			beq 	_ENCFExit 					; no decimals
.2498	5a		phy				phy
.2499	0a		asl a				asl 	a 							; x 4 and CLC
.249a	0a		asl a				asl 	a
.249b	6d 93 05	adc $0593			adc 	decimalCount
.249e	a8		tay				tay
.249f	b9 2a 21	lda $212a,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24a2	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24a4	b9 2b 21	lda $212b,y			lda 	FloatScalarTable-5+1,y
.24a7	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.24a9	b9 2c 21	lda $212c,y			lda 	FloatScalarTable-5+2,y
.24ac	95 58		sta $58,x			sta 	NSMantissa2+2,x
.24ae	b9 2d 21	lda $212d,y			lda 	FloatScalarTable-5+3,y
.24b1	95 64		sta $64,x			sta 	NSMantissa3+2,x
.24b3	b9 2e 21	lda $212e,y			lda 	FloatScalarTable-5+4,y
.24b6	95 70		sta $70,x			sta 	NSExponent+2,x
.24b8	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.24ba	e8		inx				inx 								; multiply decimal const by decimal scalar
.24bb	e8		inx				inx
.24bc	20 dd 22	jsr $22dd			jsr 	FloatMultiply
.24bf	20 41 20	jsr $2041			jsr 	FloatAdd 					; add to integer part.
.24c2	7a		ply				ply
.24c3					_ENCFExit:
.24c3	18		clc				clc 								; reject the digit.
.24c4	60		rts				rts
.24c5					ESTAShiftDigitIntoMantissa:
.24c5	29 0f		and #$0f			and 	#15 						; save digit
.24c7	48		pha				pha
.24c8	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.24ca	48		pha				pha
.24cb	b5 56		lda $56,x			lda 	NSMantissa2,x
.24cd	48		pha				pha
.24ce	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.24d0	48		pha				pha
.24d1	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.24d3	48		pha				pha
.24d4	20 2c 26	jsr $262c			jsr 	FloatShiftLeft 				; x 2
.24d7	20 2c 26	jsr $262c			jsr 	FloatShiftLeft 				; x 4
.24da	18		clc				clc 								; pop mantissa and add
.24db	68		pla				pla
.24dc	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24de	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24e0	68		pla				pla
.24e1	75 4a		adc $4a,x			adc 	NSMantissa1,x
.24e3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.24e5	68		pla				pla
.24e6	75 56		adc $56,x			adc 	NSMantissa2,x
.24e8	95 56		sta $56,x			sta 	NSMantissa2,x
.24ea	68		pla				pla
.24eb	75 62		adc $62,x			adc 	NSMantissa3,x
.24ed	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.24ef	20 2c 26	jsr $262c			jsr 	FloatShiftLeft 				; x 10
.24f2	68		pla				pla 								; add digit
.24f3	18		clc				clc
.24f4	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24f6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24f8	90 0a		bcc $2504			bcc 	_ESTASDExit
.24fa	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.24fc	d0 06		bne $2504			bne 	_ESTASDExit
.24fe	f6 56		inc $56,x			inc 	NSMantissa2,x
.2500	d0 02		bne $2504			bne 	_ESTASDExit
.2502	f6 62		inc $62,x			inc 	NSMantissa3,x
.2504					_ESTASDExit:
.2504	60		rts				rts
.0591					encodeState:
>0591							.fill 	1
.0592					digitTemp:
>0592							.fill 	1
.0593					decimalCount:
>0593							.fill 	1
.2505					FloatToString:
.2505	da		phx				phx
.2506	5a		phy				phy 								; save code position
.2507	8d 94 05	sta $0594			sta 	decimalPlaces	 			; save number of DPs.
.250a	9c 95 05	stz $0595			stz 	dbOffset 					; offset into decimal buffer = start.
.250d	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.250f	10 08		bpl $2519			bpl 	_CNTSNotNegative
.2511	29 7f		and #$7f			and 	#$7F 						; make +ve
.2513	95 32		sta $32,x			sta 	NSStatus,x
.2515	a9 2d		lda #$2d			lda 	#"-"
.2517	80 02		bra $251b			bra 	_CNTMain
.2519					_CNTSNotNegative:
.2519	a9 20		lda #$20			lda 	#" "
.251b					_CNTMain:
.251b	20 7d 25	jsr $257d			jsr 	WriteDecimalBuffer
.251e	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.2520	f0 0d		beq $252f			beq 	_CNTSNotFloat
.2522	e8		inx				inx 								; round up so we don't get too many 6.999999
.2523	a9 01		lda #$01			lda 	#1
.2525	20 1f 26	jsr $261f			jsr 	FloatSetByte
.2528	b5 6d		lda $6d,x			lda		NSExponent-1,x
.252a	95 6e		sta $6e,x			sta 	NSExponent,x
.252c	20 41 20	jsr $2041			jsr 	FloatAdd
.252f					_CNTSNotFloat:
.252f	20 5f 25	jsr $255f			jsr 	MakePlusTwoString 			; do the integer part.
.2532	20 fd 21	jsr $21fd			jsr 	FloatFractionalPart 		; get the fractional part
.2535	20 72 23	jsr $2372			jsr 	FloatNormalise					; normalise , exit if zero
.2538	f0 22		beq $255c			beq 	_CNTSExit
.253a	a9 2e		lda #$2e			lda 	#"."
.253c	20 7d 25	jsr $257d			jsr 	WriteDecimalBuffer 			; write decimal place
.253f					_CNTSDecimal:
.253f	ce 94 05	dec $0594			dec 	decimalPlaces 				; done all the decimals
.2542	30 18		bmi $255c			bmi 	_CNTSExit
.2544	e8		inx				inx 								; x 10.0
.2545	a9 0a		lda #$0a			lda 	#10
.2547	20 1f 26	jsr $261f			jsr 	FloatSetByte
.254a	20 dd 22	jsr $22dd			jsr 	FloatMultiply
.254d	20 5f 25	jsr $255f			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.2550	20 fd 21	jsr $21fd			jsr 	FloatFractionalPart 		; get the fractional part
.2553	20 72 23	jsr $2372			jsr 	FloatNormalise 				; normalise it.
.2556	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.2558	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.255a	b0 e3		bcs $253f			bcs 	_CNTSDecimal 				; keep going.
.255c					_CNTSExit:
.255c	7a		ply				ply
.255d	fa		plx				plx
.255e	60		rts				rts
.255f					MakePlusTwoString:
.255f	da		phx				phx
.2560	20 00 26	jsr $2600			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.2563	e8		inx				inx 								; access it
.2564	e8		inx				inx
.2565	20 58 22	jsr $2258			jsr 	FloatIntegerPart 			; make it an integer
.2568	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.256a	20 9c 25	jsr $259c			jsr 	ConvertInt32
.256d	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.256f					_MPTSCopy:
.256f	bd 6f 05	lda $056f,x			lda 	numberBuffer,x
.2572	20 7d 25	jsr $257d			jsr 	WriteDecimalBuffer
.2575	e8		inx				inx
.2576	bd 6f 05	lda $056f,x			lda 	numberBuffer,x
.2579	d0 f4		bne $256f			bne 	_MPTSCopy
.257b	fa		plx				plx
.257c	60		rts				rts
.257d					WriteDecimalBuffer:
.257d	da		phx				phx
.257e	ae 95 05	ldx $0595			ldx 	dbOffset
.2581	9d 96 05	sta $0596,x			sta 	decimalBuffer,x
.2584	9e 97 05	stz $0597,x			stz 	decimalBuffer+1,x
.2587	ee 95 05	inc $0595			inc 	dbOffset
.258a	fa		plx				plx
.258b	60		rts				rts
.0594					decimalPlaces:
>0594							.fill 	1
.0595					dbOffset:
>0595							.fill 	1
.0596					decimalBuffer:
>0596							.fill 	32
.258c					ConvertInt16:
.258c	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.258e	86 4a		stx $4a				stx 	NSMantissa1
.2590	64 56		stz $56				stz 	NSMantissa2
.2592	64 62		stz $62				stz 	NSMantissa3
.2594	64 32		stz $32				stz 	NSStatus 					; positive integer
.2596	a2 00		ldx #$00			ldx 	#0 							; stack level
.2598	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.259a	80 00		bra $259c			bra 	ConvertInt32
.259c					ConvertInt32:
.259c	5a		phy				phy
.259d	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.259f	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25a1	10 08		bpl $25ab			bpl 	_CI32NotNeg
.25a3	48		pha				pha
.25a4	a9 2d		lda #$2d			lda 	#'-'
.25a6	99 6f 05	sta $056f,y			sta 	numberBuffer,y
.25a9	c8		iny				iny
.25aa	68		pla				pla
.25ab					_CI32NotNeg:
.25ab	20 b9 25	jsr $25b9			jsr 	_CI32DivideConvert 			; recursive conversion
.25ae	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.25b0	99 6f 05	sta $056f,y			sta 	numberBuffer,y
.25b3	7a		ply				ply
.25b4	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.25b6	a9 6f		lda #$6f			lda 	#numberBuffer & $FF
.25b8	60		rts				rts
.25b9					_CI32DivideConvert:
.25b9	e8		inx				inx 								; write to next slot up
.25ba	20 1f 26	jsr $261f			jsr 	FloatSetByte 		 		; write the base out.
.25bd	ca		dex				dex
.25be	20 b3 21	jsr $21b3			jsr 	Int32Divide 				; divide
.25c1	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.25c3	48		pha				pha
.25c4	20 a2 21	jsr $21a2			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.25c7	20 3f 26	jsr $263f			jsr 	FloatIsZero 				; is it zero ?
.25ca	f0 05		beq $25d1			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.25cc	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.25ce	20 b9 25	jsr $25b9			jsr 	_CI32DivideConvert 			; and recusrively call.
.25d1					_CI32NoRecurse:
.25d1	68		pla				pla 								; remainder
.25d2	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.25d4	90 02		bcc $25d8			bcc 	_CI32NotHex
.25d6	69 26		adc #$26			adc 	#6+32
.25d8					_CI32NotHex:
.25d8	69 30		adc #$30			adc 	#48
.25da	99 6f 05	sta $056f,y			sta 	numberBuffer,y 				; write out and exit
.25dd	c8		iny				iny
.25de	60		rts				rts
.25df					FloatNegate:
.25df	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.25e1	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.25e3	95 32		sta $32,x			sta 	NSStatus,x
.25e5	60		rts				rts
.25e6					FloatNegateMantissa:
.25e6	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.25e7	a9 00		lda #$00			lda 	#0
.25e9	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.25eb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.25ed	a9 00		lda #$00			lda 	#0
.25ef	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.25f1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.25f3	a9 00		lda #$00			lda 	#0
.25f5	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.25f7	95 56		sta $56,x			sta 	NSMantissa2,x
.25f9	a9 00		lda #$00			lda 	#0
.25fb	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.25fd	95 62		sta $62,x			sta 	NSMantissa3,x
.25ff	60		rts				rts
.2600					FloatShiftUpTwo:
.2600	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2602	95 40		sta $40,x			sta 	NSMantissa0+2,x
.2604	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2606	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2608	b5 56		lda $56,x			lda 	NSMantissa2,x
.260a	95 58		sta $58,x			sta 	NSMantissa2+2,x
.260c	b5 62		lda $62,x			lda 	NSMantissa3,x
.260e	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2610	b5 6e		lda $6e,x			lda 	NSExponent,x
.2612	95 70		sta $70,x			sta 	NSExponent+2,x
.2614	b5 32		lda $32,x			lda 	NSStatus,x
.2616	95 34		sta $34,x			sta 	NSStatus+2,x
.2618	60		rts				rts
.2619					FloatSetZeroMantissaOnly:
.2619	74 3e		stz $3e,x			stz 	NSMantissa0,x
.261b	80 08		bra $2625			bra 	FloatZero13
.261d					FloatSetZero:
.261d	a9 00		lda #$00			lda 	#0
.261f					FloatSetByte:
.261f	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2621					FloatSetMantissa:
.2621	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.2623	74 32		stz $32,x			stz 	NSStatus,x
.2625					FloatZero13:
.2625	74 4a		stz $4a,x			stz 	NSMantissa1,x
.2627	74 56		stz $56,x			stz 	NSMantissa2,x
.2629	74 62		stz $62,x			stz 	NSMantissa3,x
.262b	60		rts				rts
.262c					FloatShiftLeft:
.262c	18		clc				clc
.262d					FloatRotateLeft:
.262d	36 3e		rol $3e,x			rol 	NSMantissa0,x
.262f	36 4a		rol $4a,x			rol		NSMantissa1,x
.2631	36 56		rol $56,x			rol		NSMantissa2,x
.2633	36 62		rol $62,x			rol		NSMantissa3,x
.2635	60		rts				rts
.2636					FloatShiftRight:
.2636	56 62		lsr $62,x			lsr 	NSMantissa3,x
.2638	76 56		ror $56,x			ror		NSMantissa2,x
.263a	76 4a		ror $4a,x			ror		NSMantissa1,x
.263c	76 3e		ror $3e,x			ror		NSMantissa0,x
.263e	60		rts				rts
.263f					FloatIsZero:
.263f	b5 62		lda $62,x			lda 	NSMantissa3,x
.2641	15 56		ora $56,x			ora		NSMantissa2,x
.2643	15 4a		ora $4a,x			ora		NSMantissa1,x
.2645	15 3e		ora $3e,x			ora		NSMantissa0,x
.2647	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.2648					FloatArcTan:
.2648	20 72 23	jsr $2372			jsr 	FloatNormalise 					; normalise x
.264b	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.264d	48		pha				pha
.264e	74 32		stz $32,x			stz 	NSStatus,x
.2650	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.2652	c9 e2		cmp #$e2			cmp 	#$E2
.2654	90 25		bcc $267b			bcc 	_UANoFixup
.2656	8a		txa				txa 									; value in +1
.2657	a8		tay				tay
.2658	c8		iny				iny
.2659	20 01 28	jsr $2801			jsr 	CopyFloatXY
.265c	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.265e	20 1f 26	jsr $261f			jsr 	FloatSetByte
.2661	e8		inx				inx
.2662	20 66 21	jsr $2166			jsr 	FloatDivide
.2665	b0 21		bcs $2688			bcs 	_FATError
.2667	20 8b 26	jsr $268b			jsr 	CoreAtn 						; calculate the root
.266a	20 f6 27	jsr $27f6			jsr 	CompletePolynomial
.266d	20 df 25	jsr $25df			jsr 	FloatNegate 					; make -ve
.2670	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2672	20 4d 28	jsr $284d			jsr 	LoadConstant
.2675	e8		inx				inx
.2676	20 41 20	jsr $2041			jsr 	FloatAdd
.2679	80 06		bra $2681			bra 	_UAComplete
.267b					_UANoFixup:
.267b	20 8b 26	jsr $268b			jsr 	CoreAtn
.267e	20 f6 27	jsr $27f6			jsr 	CompletePolynomial
.2681					_UAComplete:
.2681	68		pla				pla 									; apply the result.
.2682	55 32		eor $32,x			eor 	NSStatus,x
.2684	95 32		sta $32,x			sta 	NSStatus,x
.2686	18		clc				clc
.2687	60		rts				rts
.2688					_FATError:
.2688	68		pla				pla
.2689	38		sec				sec
.268a	60		rts				rts
.268b					CoreAtn:
.268b	a9 f9		lda #$f9			lda 	#AtnCoefficients & $FF
.268d	a0 26		ldy #$26			ldy 	#AtnCoefficients >> 8
.268f	4c 4a 29	jmp $294a			jmp 	CorePolySquared
.2692					ExpCoefficients:
>2692	07					.byte	7
>2693	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>2697	d2					.byte	$d2
>2698	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>269c	d5					.byte	$d5
>269d	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>26a1	d8					.byte	$d8
>26a2	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>26a6	db					.byte	$db
>26a7	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>26ab	dd					.byte	$dd
>26ac	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>26b0	df					.byte	$df
>26b1	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>26b5	e1					.byte	$e1
>26b6	00 00 00 40				.dword	$40000000 ; 1.0
>26ba	e2					.byte	$e2
.26bb					SinCoefficients:
>26bb	06					.byte	6
>26bc	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>26c0	e5					.byte	$e5
>26c1	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>26c5	e7					.byte	$e7
>26c6	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>26ca	e8					.byte	$e8
>26cb	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>26cf	e8					.byte	$e8
>26d0	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>26d4	e7					.byte	$e7
>26d5	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>26d9	e4					.byte	$e4
>26da	00 00 00 00				.dword	$00000000 ; 0.0
>26de	00					.byte	$00
.26df					LogCoefficients:
>26df	04					.byte	4
>26e0	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>26e4	e0					.byte	$e0
>26e5	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>26e9	e1					.byte	$e1
>26ea	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>26ee	e1					.byte	$e1
>26ef	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>26f3	e3					.byte	$e3
>26f4	00 00 00 c0				.dword	$c0000000 ; -0.5
>26f8	e1					.byte	$e1
.26f9					AtnCoefficients:
>26f9	0c					.byte	12
>26fa	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>26fe	d7					.byte	$d7
>26ff	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>2703	da					.byte	$da
>2704	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>2708	dc					.byte	$dc
>2709	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>270d	dd					.byte	$dd
>270e	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>2712	dd					.byte	$dd
>2713	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>2717	de					.byte	$de
>2718	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>271c	de					.byte	$de
>271d	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>2721	de					.byte	$de
>2722	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>2726	df					.byte	$df
>2727	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>272b	df					.byte	$df
>272c	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>2730	e0					.byte	$e0
>2731	00 00 00 40				.dword	$40000000 ; 1.0
>2735	e2					.byte	$e2
>2736	00 00 00 00				.dword	$00000000 ; 0.0
>273a	00					.byte	$00
.273b					Const_Base:
.273b					Const_1Div2Pi:
>273b	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>273f	df					.byte	$df
.2740					Const_PiDiv2:
>2740	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>2744	e2					.byte	$e2
.2745					Const_Log2_e:
>2745	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>2749	e2					.byte	$e2
.274a					Const_sqrt_2:
>274a	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>274e	e2					.byte	$e2
.274f					Const_sqrt_half:
>274f	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>2753	e1					.byte	$e1
.2754					Const_pi:
>2754	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>2758	e3					.byte	$e3
.2759					Const_half:
>2759	00 00 00 40				.dword	$40000000 ; 0.50000000
>275d	e1					.byte	$e1
.275e					Const_ln_e:
>275e	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>2762	e1					.byte	$e1
.2763					FloatCosine:
.2763	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2765	20 4d 28	jsr $284d			jsr 	LoadConstant
.2768	e8		inx				inx
.2769	20 41 20	jsr $2041			jsr 	FloatAdd
.276c	4c 03 29	jmp $2903			jmp 	FloatSine
.276f					FloatExponent:
.276f	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.2771	20 4d 28	jsr $284d			jsr 	LoadConstant
.2774	e8		inx				inx
.2775	20 dd 22	jsr $22dd			jsr 	FloatMultiply
.2778	20 ba 27	jsr $27ba			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.277b	e8		inx				inx
.277c	20 58 22	jsr $2258			jsr 	FloatIntegerPart
.277f	ca		dex				dex
.2780	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2782	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2784	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2786	d0 38		bne $27c0			bne 	_UERangeError
.2788	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.278a	c9 40		cmp #$40			cmp 	#64
.278c	b0 32		bcs $27c0			bcs 	_UERangeError
.278e	48		pha				pha
.278f	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.2791	48		pha				pha
.2792	20 fd 21	jsr $21fd			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.2795	68		pla				pla
.2796	10 14		bpl $27ac			bpl 	_UEPositive
.2798	e8		inx				inx 							; 1-x
.2799	a9 01		lda #$01			lda 	#1
.279b	20 1f 26	jsr $261f			jsr 	FloatSetByte
.279e	ca		dex				dex
.279f	20 df 25	jsr $25df			jsr 	FloatNegate
.27a2	e8		inx				inx
.27a3	20 41 20	jsr $2041			jsr 	FloatAdd
.27a6	68		pla				pla 							; integer part +1 and negated.
.27a7	1a		inc a				inc 	a
.27a8	49 ff		eor #$ff			eor 	#$FF
.27aa	1a		inc a				inc 	a
.27ab	48		pha				pha
.27ac					_UEPositive:
.27ac	20 c2 27	jsr $27c2			jsr 	CoreExponent
.27af	20 f6 27	jsr $27f6			jsr 	CompletePolynomial
.27b2	68		pla				pla
.27b3	18		clc				clc
.27b4	75 6e		adc $6e,x			adc 	NSExponent,x
.27b6	95 6e		sta $6e,x			sta 	NSExponent,x
.27b8	18		clc				clc
.27b9	60		rts				rts
.27ba					_UECopy01:
.27ba	8a		txa				txa
.27bb	a8		tay				tay
.27bc	c8		iny				iny
.27bd	4c 01 28	jmp $2801			jmp 	CopyFloatXY
.27c0					_UERangeError:
.27c0	38		sec				sec
.27c1	60		rts				rts
.27c2					CoreExponent:
.27c2	a9 92		lda #$92			lda 	#ExpCoefficients & $FF
.27c4	a0 26		ldy #$26			ldy 	#ExpCoefficients >> 8
.27c6	20 ca 27	jsr $27ca			jsr 	CalculateHornerPolynomial
.27c9	60		rts				rts
.27ca					CalculateHornerPolynomial:
.27ca	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.27cc	84 2d		sty $2d				sty 	zTemp0+1
.27ce	9c b6 05	stz $05b6			stz 	coefficientCount 			; zero the count.
.27d1	8e b7 05	stx $05b7			stx 	xValueSlot 					; save xValue slot.
.27d4	e8		inx				inx 								; set the count to zero.
.27d5	20 1d 26	jsr $261d			jsr 	FloatSetZero
.27d8					_CHPLoop:
.27d8	8a		txa				txa 								; copy X-1 to X+1
.27d9	a8		tay				tay
.27da	ca		dex				dex
.27db	c8		iny				iny
.27dc	20 01 28	jsr $2801			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.27df	e8		inx				inx
.27e0	e8		inx				inx
.27e1	20 dd 22	jsr $22dd			jsr 	FloatMultiply 				; times current by X
.27e4	e8		inx				inx
.27e5	20 20 28	jsr $2820			jsr 	GetCoefficient 				; coefficient into X+1
.27e8	20 41 20	jsr $2041			jsr 	FloatAdd 					; and add
.27eb	ee b6 05	inc $05b6			inc 	coefficientCount
.27ee	ad b6 05	lda $05b6			lda 	coefficientCount
.27f1	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.27f3	d0 e3		bne $27d8			bne 	_CHPLoop
.27f5	60		rts				rts
.27f6					CompletePolynomial:
.27f6	20 dd 22	jsr $22dd			jsr 	FloatMultiply
.27f9	e8		inx				inx 								; get the last value
.27fa	20 20 28	jsr $2820			jsr 	GetCoefficient
.27fd	20 41 20	jsr $2041			jsr 	FloatAdd 					; and add it
.2800	60		rts				rts
.2801					CopyFloatXY:
.2801	b5 6e		lda $6e,x			lda 	NSExponent,x
.2803	99 6e 00	sta $006e,y			sta 	NSExponent,y
.2806	b5 32		lda $32,x			lda 	NSStatus,x
.2808	99 32 00	sta $0032,y			sta 	NSStatus,y
.280b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.280d	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.2810	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2812	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.2815	b5 56		lda $56,x			lda 	NSMantissa2,x
.2817	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.281a	b5 62		lda $62,x			lda 	NSMantissa3,x
.281c	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.281f	60		rts				rts
.2820					GetCoefficient:
.2820	5a		phy				phy
.2821	ad b6 05	lda $05b6			lda 	coefficientCount 			; 5 per block
.2824	0a		asl a				asl 	a
.2825	0a		asl a				asl 	a
.2826	38		sec				sec 								; +1 for count
.2827	6d b6 05	adc $05b6			adc 	coefficientCount
.282a	a8		tay				tay
.282b	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.282d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.282f	c8		iny				iny
.2830	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2832	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2834	c8		iny				iny
.2835	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2837	95 56		sta $56,x			sta 	NSMantissa2,x
.2839	c8		iny				iny
.283a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.283c	48		pha				pha
.283d	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.283f	95 62		sta $62,x			sta 	NSMantissa3,x
.2841	c8		iny				iny
.2842	68		pla				pla
.2843	29 80		and #$80			and 	#$80
.2845	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.2847	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2849	95 6e		sta $6e,x			sta 	NSExponent,x
.284b	7a		ply				ply
.284c	60		rts				rts
.05b6					coefficientCount:
>05b6							.fill 	1
.05b7					xValueSlot:
>05b7							.fill 	1
.284d					LoadConstant:
.284d	5a		phy				phy
.284e	a8		tay				tay
.284f	b9 3b 27	lda $273b,y			lda 	Const_Base+0,y
.2852	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.2854	b9 3c 27	lda $273c,y			lda 	Const_Base+1,y
.2857	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.2859	b9 3d 27	lda $273d,y			lda 	Const_Base+2,y
.285c	95 57		sta $57,x			sta 	NSMantissa2+1,x
.285e	b9 3e 27	lda $273e,y			lda 	Const_Base+3,y
.2861	48		pha				pha
.2862	29 7f		and #$7f			and 	#$7F
.2864	95 63		sta $63,x			sta 	NSMantissa3+1,x
.2866	68		pla				pla
.2867	29 80		and #$80			and 	#$80
.2869	95 33		sta $33,x			sta 	NSStatus+1,x
.286b	b9 3f 27	lda $273f,y			lda 	Const_Base+4,y
.286e	95 6f		sta $6f,x			sta 	NSExponent+1,x
.2870	7a		ply				ply
.2871	60		rts				rts
.2872					FloatLogarithm:
.2872	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.2874	30 5f		bmi $28d5			bmi 	_ULRange
.2876	20 3f 26	jsr $263f			jsr 	FloatIsZero
.2879	f0 5a		beq $28d5			beq 	_ULRange
.287b	20 72 23	jsr $2372			jsr 	FloatNormalise 				; put into FP mode.
.287e	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.2880	48		pha				pha
.2881	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.2883	95 6e		sta $6e,x			sta 	NSExponent,x
.2885	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.2887	20 4d 28	jsr $284d			jsr 	LoadConstant
.288a	e8		inx				inx
.288b	20 41 20	jsr $2041			jsr 	FloatAdd
.288e	8a		txa				txa 								; divide into sqrt 2.0
.288f	a8		tay				tay
.2890	c8		iny				iny
.2891	20 01 28	jsr $2801			jsr 	CopyFloatXY
.2894	ca		dex				dex
.2895	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.2897	20 4d 28	jsr $284d			jsr 	LoadConstant
.289a	e8		inx				inx
.289b	e8		inx				inx
.289c	20 66 21	jsr $2166			jsr 	FloatDivide 				; if zero, error.
.289f	b0 33		bcs $28d4			bcs 	_ULRangePla
.28a1	20 df 25	jsr $25df			jsr 	FloatNegate 				; subtract from 1
.28a4	e8		inx				inx
.28a5	a9 01		lda #$01			lda 	#1
.28a7	20 1f 26	jsr $261f			jsr 	FloatSetByte
.28aa	20 41 20	jsr $2041			jsr 	FloatAdd
.28ad	20 d7 28	jsr $28d7			jsr 	CoreLog
.28b0	20 f6 27	jsr $27f6			jsr 	CompletePolynomial
.28b3	68		pla				pla 								; add exponent
.28b4	18		clc				clc
.28b5	69 1f		adc #$1f			adc 	#31 						; fix up
.28b7	48		pha				pha
.28b8	10 03		bpl $28bd			bpl 	_LogNotNeg
.28ba	49 ff		eor #$ff			eor 	#$FF
.28bc	1a		inc a				inc 	a
.28bd					_LogNotNeg:
.28bd	e8		inx				inx 								; set byte and sign.
.28be	20 1f 26	jsr $261f			jsr 	FloatSetByte
.28c1	68		pla				pla
.28c2	29 80		and #$80			and 	#$80
.28c4	95 32		sta $32,x			sta 	NSStatus,x
.28c6	20 41 20	jsr $2041			jsr 	FloatAdd
.28c9	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.28cb	20 4d 28	jsr $284d			jsr 	LoadConstant
.28ce	e8		inx				inx
.28cf	20 dd 22	jsr $22dd			jsr 	FloatMultiply
.28d2	18		clc				clc
.28d3	60		rts				rts
.28d4					_ULRangePla:
.28d4	68		pla				pla
.28d5					_ULRange:
.28d5	38		sec				sec
.28d6	60		rts				rts
.28d7					CoreLog:
.28d7	a9 df		lda #$df			lda 	#LogCoefficients & $FF
.28d9	a0 26		ldy #$26			ldy 	#LogCoefficients >> 8
.28db	4c 4a 29	jmp $294a			jmp 	CorePolySquared
.28de					FloatPI:
.28de	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.28e0	20 4d 28	jsr $284d			jsr 	LoadConstant
.28e3	e8		inx				inx
.28e4	18		clc				clc
.28e5	60		rts				rts
.28e6					FloatPower:
.28e6	ca		dex				dex
.28e7	8a		txa				txa 							; copy 0 to 2, so we can process it
.28e8	a8		tay				tay
.28e9	c8		iny				iny
.28ea	c8		iny				iny
.28eb	20 01 28	jsr $2801			jsr 	CopyFloatXY
.28ee	e8		inx				inx 							; 2 = Log(0)
.28ef	e8		inx				inx
.28f0	20 72 28	jsr $2872			jsr 	FloatLogarithm
.28f3	b0 0d		bcs $2902			bcs 	_FPWExit
.28f5	20 dd 22	jsr $22dd			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.28f8	8a		txa				txa 							; copy to slot 0
.28f9	a8		tay				tay
.28fa	88		dey				dey
.28fb	20 01 28	jsr $2801			jsr 	CopyFloatXY
.28fe	ca		dex				dex  							; Exponent code.
.28ff	20 6f 27	jsr $276f			jsr 	FloatExponent
.2902					_FPWExit:
.2902	60		rts				rts
.2903					FloatSine:
.2903	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.2905	48		pha				pha
.2906	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.2908	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.290a	20 4d 28	jsr $284d			jsr 	LoadConstant
.290d	e8		inx				inx
.290e	20 dd 22	jsr $22dd			jsr 	FloatMultiply
.2911	20 fd 21	jsr $21fd			jsr 	FloatFractionalPart 		; take the fractional part
.2914	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.2916	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.2918	90 1f		bcc $2939			bcc 	_USProcessExit
.291a	f0 06		beq $2922			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.291c	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.291e	c9 60		cmp #$60			cmp 	#$60
.2920	b0 0e		bcs $2930			bcs 	_USSubtractOne
.2922					_USSubtractFromHalf:
.2922	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.2924	20 4d 28	jsr $284d			jsr 	LoadConstant
.2927	e8		inx				inx
.2928	20 3b 20	jsr $203b			jsr 	FloatSubtract
.292b	20 df 25	jsr $25df			jsr 	FloatNegate 				; then negate it
.292e	80 09		bra $2939			bra 	_USProcessExit 				; and exit
.2930					_USSubtractOne:
.2930	e8		inx				inx
.2931	a9 01		lda #$01			lda 	#1
.2933	20 1f 26	jsr $261f			jsr 	FloatSetByte
.2936	20 3b 20	jsr $203b			jsr 	FloatSubtract
.2939					_USProcessExit:
.2939	20 46 29	jsr $2946			jsr 	CoreSine
.293c	20 f6 27	jsr $27f6			jsr 	CompletePolynomial
.293f	68		pla				pla 								; restore sign and apply
.2940	55 32		eor $32,x			eor 	NSStatus,x
.2942	95 32		sta $32,x			sta 	NSStatus,x
.2944	18		clc				clc
.2945	60		rts				rts
.2946					CoreSine:
.2946	a9 bb		lda #$bb			lda 	#SinCoefficients & $FF
.2948	a0 26		ldy #$26			ldy 	#SinCoefficients >> 8
.294a					CorePolySquared:
.294a	48		pha				pha 								; save coefficient table
.294b	5a		phy				phy
.294c	8a		txa				txa 								; copy X to +1, +2
.294d	a8		tay				tay
.294e	c8		iny				iny
.294f	20 01 28	jsr $2801			jsr 	CopyFloatXY
.2952	c8		iny				iny
.2953	20 01 28	jsr $2801			jsr 	CopyFloatXY
.2956	e8		inx				inx 								; point to the pair and put x^2 on stack
.2957	e8		inx				inx
.2958	20 dd 22	jsr $22dd			jsr 	FloatMultiply
.295b	7a		ply				ply 								; coefficient table back.
.295c	68		pla				pla
.295d	20 ca 27	jsr $27ca			jsr 	CalculateHornerPolynomial
.2960	8a		txa				txa 								; copy back to slot #1
.2961	a8		tay				tay
.2962	88		dey				dey
.2963	20 01 28	jsr $2801			jsr	 	CopyFloatXY
.2966	ca		dex				dex 								; point at result
.2967	60		rts				rts
.2968					FloatSquareRoot:
.2968	20 72 28	jsr $2872			jsr 	FloatLogarithm
.296b	b0 06		bcs $2973			bcs 	_FSQExit
.296d	d6 6e		dec $6e,x			dec 	NSExponent,x
.296f	20 6f 27	jsr $276f			jsr 	FloatExponent
.2972	18		clc				clc
.2973					_FSQExit:
.2973	60		rts				rts
.2974					FloatTangent:
.2974	da		phx				phx
.2975	8a		txa				txa 								; sin -> +1
.2976	a8		tay				tay
.2977	c8		iny				iny
.2978	20 01 28	jsr $2801			jsr 	CopyFloatXY
.297b	e8		inx				inx
.297c	20 03 29	jsr $2903			jsr 	FloatSine
.297f	ca		dex				dex
.2980	8a		txa				txa 								; cos -> +2
.2981	a8		tay				tay
.2982	c8		iny				iny
.2983	c8		iny				iny
.2984	20 01 28	jsr $2801			jsr 	CopyFloatXY
.2987	e8		inx				inx
.2988	e8		inx				inx
.2989	20 63 27	jsr $2763			jsr 	FloatCosine
.298c	20 66 21	jsr $2166			jsr 	FloatDivide 				; calculate sin/cos
.298f	b0 07		bcs $2998			bcs 	_FTExit 					; divide by zero
.2991	8a		txa				txa 								; copy result down.
.2992	a8		tay				tay
.2993	88		dey				dey
.2994	20 01 28	jsr $2801			jsr 	CopyFloatXY
.2997	18		clc				clc
.2998					_FTExit:
.2998	fa		plx				plx
.2999	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.007a					srcPtr:
>007a							.fill 	2
.05b8					currentLineNumber:
>05b8							.fill 	2
.299a					InlineNonDecimal:
.299a	a2 02		ldx #$02			ldx 	#2 							; get size in X
.299c	c9 25		cmp #$25			cmp 	#"%"
.299e	f0 02		beq $29a2			beq 	_INDBinary
.29a0	a2 10		ldx #$10			ldx 	#16
.29a2					_INDBinary:
.29a2	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.29a4	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.29a6	64 2c		stz $2c				stz 	zTemp0 						; zero result
.29a8	64 2d		stz $2d				stz 	zTemp0+1
.29aa					_INDLoop:
.29aa	20 46 33	jsr $3346			jsr 	LookNext 					; check next character
.29ad	20 82 33	jsr $3382			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.29b0	90 1f		bcc $29d1			bcc		_INDDone 					; didn't convert
.29b2	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.29b4	b0 1b		bcs $29d1			bcs 	_INDDone
.29b6	20 e0 29	jsr $29e0			jsr 	_INDShift 					; x 2 or x 16
.29b9	e0 02		cpx #$02			cpx 	#2
.29bb	f0 09		beq $29c6			beq 	_INDNotHex
.29bd	20 e0 29	jsr $29e0			jsr 	_INDShift
.29c0	20 e0 29	jsr $29e0			jsr 	_INDShift
.29c3	20 e0 29	jsr $29e0			jsr 	_INDShift
.29c6					_INDNotHex:
.29c6	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.29c8	85 2c		sta $2c				sta 	zTemp0
.29ca	20 57 33	jsr $3357			jsr 	GetNext 					; consume
.29cd	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.29cf	80 d9		bra $29aa			bra 	_INDLoop
.29d1					_INDDone:
.29d1	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.29d3	f0 08		beq $29dd			beq 	_INDError
.29d5	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.29d7	a5 2c		lda $2c				lda 	zTemp0
.29d9	20 01 2b	jsr $2b01			jsr 	PushIntegerYA
.29dc	60		rts				rts
.29dd					_INDError:
.29dd	4c d7 1e	jmp $1ed7		jmp	ErrorV_syntax
.29e0					_INDShift:
.29e0	06 2c		asl $2c				asl 	zTemp0
.29e2	26 2d		rol $2d				rol 	zTemp0+1
.29e4	60		rts				rts
.29e5					GetLineNumber:
.29e5	ac b9 05	ldy $05b9			ldy 	currentLineNumber+1
.29e8	ad b8 05	lda $05b8			lda 	currentLineNumber
.29eb	60		rts				rts
.29ec					WriteCodeByte:
.29ec	48		pha				pha 								; save on stack
.29ed	da		phx				phx
.29ee	5a		phy				phy
.29ef	aa		tax				tax
.29f0	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.29f2	20 fe 2a	jsr $2afe			jsr 	CallAPIHandler
.29f5	7a		ply				ply 								; restore from stack
.29f6	fa		plx				plx
.29f7	68		pla				pla
.29f8	60		rts				rts
.29f9					PrintCharacter
.29f9	48		pha				pha
.29fa	da		phx				phx
.29fb	5a		phy				phy
.29fc	aa		tax				tax
.29fd	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.29ff	20 fe 2a	jsr $2afe			jsr 	CallAPIHandler
.2a02	7a		ply				ply
.2a03	fa		plx				plx
.2a04	68		pla				pla
.2a05	60		rts				rts
.2a06					ProcessNewLine:
.2a06	86 2c		stx $2c				stx 	zTemp0 						; save address in zTemp0
.2a08	84 2d		sty $2d				sty 	zTemp0+1
.2a0a	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.2a0b	8a		txa				txa
.2a0c	69 04		adc #$04			adc 	#4
.2a0e	85 7a		sta $7a				sta 	srcPtr
.2a10	98		tya				tya
.2a11	69 00		adc #$00			adc 	#0
.2a13	85 7b		sta $7b				sta 	srcPtr+1
.2a15	a0 02		ldy #$02			ldy 	#2							; read and save line number
.2a17	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a19	8d b8 05	sta $05b8			sta 	currentLineNumber
.2a1c	c8		iny				iny
.2a1d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a1f	8d b9 05	sta $05b9			sta 	currentLineNumber+1
.2a22	60		rts				rts
.2a23					BufferClear:
.2a23	9c ba 05	stz $05ba			stz 	bufferSize
.2a26	60		rts				rts
.2a27					BufferWrite:
.2a27	da		phx				phx
.2a28	ae ba 05	ldx $05ba			ldx 	bufferSize
.2a2b	9d bb 05	sta $05bb,x			sta 	dataBuffer,x
.2a2e	ee ba 05	inc $05ba			inc 	bufferSize
.2a31	fa		plx				plx
.2a32	60		rts				rts
.2a33					BufferOutput:
.2a33	ad ba 05	lda $05ba			lda 	bufferSize
.2a36	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2a39	a2 00		ldx #$00			ldx 	#0
.2a3b					_BOLoop:
.2a3b	ec ba 05	cpx $05ba			cpx 	bufferSize
.2a3e	f0 09		beq $2a49			beq 	_BOExit
.2a40	bd bb 05	lda $05bb,x			lda 	dataBuffer,x
.2a43	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2a46	e8		inx				inx
.2a47	80 f2		bra $2a3b			bra 	_BOLoop
.2a49					_BOExit:
.2a49	60		rts				rts
.05ba					bufferSize:
>05ba							.fill 	1
.05bb					dataBuffer:
>05bb							.fill 	256
.2a4a					CheckNextComma:
.2a4a	a9 2c		lda #$2c			lda	 	#","
.2a4c	80 06		bra $2a54			bra 	CheckNextA
.2a4e					CheckNextRParen:
.2a4e	a9 29		lda #$29			lda	 	#")"
.2a50	80 02		bra $2a54			bra 	CheckNextA
.2a52					CheckNextLParen:
.2a52	a9 28		lda #$28			lda 	#"("
.2a54					CheckNextA:
.2a54	8d bb 06	sta $06bb			sta 	checkCharacter 				; save test character
.2a57					_CNALoop:
.2a57	20 62 33	jsr $3362			jsr 	GetNextNonSpace 			; get next skipping spaces.
.2a5a	cd bb 06	cmp $06bb			cmp 	checkCharacter 				; matches ?
.2a5d	f0 03		beq $2a62			beq 	_CNAExit
.2a5f	4c d7 1e	jmp $1ed7		jmp	ErrorV_syntax
.2a62					_CNAExit:
.2a62	60		rts				rts
.06bb					checkCharacter:
>06bb							.fill 	1
.2a63					StartCompiler:
.2a63	86 2c		stx $2c				stx 	zTemp0 						; access API
.2a65	84 2d		sty $2d				sty 	zTemp0+1
.2a67	a0 2c		ldy #$2c			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.2a69	a2 ba		ldx #$ba			ldx 	#CompilerErrorHandler & $FF
.2a6b	20 b0 1e	jsr $1eb0			jsr 	SetErrorHandler
.2a6e	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.2a70	b2 2c		lda ($2c)			lda 	(zTemp0)
.2a72	8d bd 06	sta $06bd			sta 	APIVector
.2a75	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a77	8d be 06	sta $06be			sta 	APIVector+1
.2a7a	c8		iny				iny 								; copy data area range.
.2a7b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a7d	8d bf 06	sta $06bf			sta 	compilerStartHigh
.2a80	c8		iny				iny
.2a81	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a83	8d c0 06	sta $06c0			sta 	compilerEndHigh
.2a86	ba		tsx				tsx 								; save stack pointer
.2a87	8e bc 06	stx $06bc			stx 	compilerSP
.2a8a	20 e6 36	jsr $36e6			jsr 	STRReset 					; reset storage (line#, variable)
.2a8d	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.2a8f	20 fe 2a	jsr $2afe			jsr 	CallAPIHandler
.2a92	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.2a94	20 fe 2a	jsr $2afe			jsr 	CallAPIHandler
.2a97	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.2a99	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2a9c	a9 00		lda #$00			lda 	#0
.2a9e	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2aa1	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2aa4					MainCompileLoop:
.2aa4	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.2aa6	20 fe 2a	jsr $2afe			jsr 	CallAPIHandler
.2aa9	90 31		bcc $2adc			bcc 	SaveCodeAndExit 			; end of source.
.2aab	20 06 2a	jsr $2a06			jsr 	ProcessNewLine 				; set up pointer and line number.
.2aae	20 e5 29	jsr $29e5			jsr 	GetLineNumber 				; get line #
.2ab1	20 d0 34	jsr $34d0			jsr 	STRMarkLine 				; remember the code position and number of this line.
.2ab4	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.2ab6	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2ab9					_MCLSameLine:
.2ab9	20 62 33	jsr $3362			jsr 	GetNextNonSpace 			; get the first character.
.2abc	f0 e6		beq $2aa4			beq 	MainCompileLoop 			; end of line, get next line.
.2abe	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.2ac0	f0 f7		beq $2ab9			beq 	_MCLSameLine
.2ac2	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.2ac4	10 0c		bpl $2ad2			bpl 	_MCLCheckAssignment
.2ac6	a2 20		ldx #$20			ldx 	#CommandTables & $FF 		; do command tables.
.2ac8	a0 2f		ldy #$2f			ldy 	#CommandTables >> 8
.2aca	20 e8 31	jsr $31e8			jsr 	GeneratorProcess
.2acd	b0 ea		bcs $2ab9			bcs 	_MCLSameLine 				; keep trying to compile the line.
.2acf					_MCLSyntax:
.2acf	4c d7 1e	jmp $1ed7		jmp	ErrorV_syntax
.2ad2					_MCLCheckAssignment:
.2ad2	20 78 33	jsr $3378			jsr 	CharIsAlpha 				; if not alpha then syntax error
.2ad5	90 f8		bcc $2acf			bcc 	_MCLSyntax
.2ad7	20 9e 34	jsr $349e			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.2ada	80 dd		bra $2ab9			bra		_MCLSameLine 				; loop back.
.2adc					SaveCodeAndExit:
.2adc	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.2ade	20 fe 2a	jsr $2afe			jsr 	CallAPIHandler
.2ae1	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.2ae3	a8		tay				tay
.2ae4	20 d0 34	jsr $34d0			jsr 	STRMarkLine
.2ae7	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.2ae9	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2aec	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.2aee	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2af1	20 18 2e	jsr $2e18			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.2af4	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.2af6	20 fe 2a	jsr $2afe			jsr 	CallAPIHandler
.2af9					ExitCompiler:
.2af9	ae bc 06	ldx $06bc			ldx 	compilerSP 					; reload SP and exit.
.2afc	9a		txs				txs
.2afd	60		rts				rts
.2afe					CallAPIHandler:
.2afe	6c bd 06	jmp ($06bd)			jmp 	(APIVector)
.06bc					compilerSP:
>06bc							.fill 	1
.06bd					APIVector:
>06bd							.fill 	2
.06bf					compilerStartHigh:
>06bf							.fill 	1
.06c0					compilerEndHigh:
>06c0							.fill 	1
.2b01					PushIntegerYA:
.2b01	c0 00		cpy #$00			cpy 	#0 							; 0-255
.2b03	f0 0f		beq $2b14			beq 	PushIntegerA
.2b05	48		pha				pha
.2b06	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.2b08	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2b0b	68		pla				pla 								; then LSB
.2b0c	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2b0f	98		tya				tya 								; then MSB
.2b10	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2b13	60		rts				rts
.2b14					PushIntegerA:
.2b14	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.2b16	90 07		bcc $2b1f			bcc 	_PIWriteA
.2b18	48		pha				pha
.2b19	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.2b1b	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2b1e	68		pla				pla
.2b1f					_PIWriteA:
.2b1f	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2b22	60		rts				rts
.2b23					PushFloatCommand:
.2b23	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.2b25	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2b28	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.2b2a	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2b2d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2b2f	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2b32	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2b34	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2b37	b5 56		lda $56,x			lda 	NSMantissa2,x
.2b39	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2b3c	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.2b3e	29 80		and #$80			and 	#$80
.2b40	15 62		ora $62,x			ora 	NSMantissa3,x
.2b42	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2b45	60		rts				rts
.2b46					CreateVariableRecord:
.2b46	48		pha				pha
.2b47	ad cb 06	lda $06cb			lda 	freeVariableMemory 		; push current free address on stack.
.2b4a	48		pha				pha
.2b4b	ad cc 06	lda $06cc			lda 	freeVariableMemory+1
.2b4e	48		pha				pha
.2b4f	ad c9 06	lda $06c9			lda 	variableListEnd  		; copy end of list to zTemp0
.2b52	85 2c		sta $2c				sta 	zTemp0
.2b54	ad ca 06	lda $06ca			lda 	variableListEnd+1
.2b57	85 2d		sta $2d				sta 	zTemp0+1
.2b59	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.2b5b	92 2c		sta ($2c)			sta 	(zTemp0)
.2b5d	98		tya				tya
.2b5e	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.2b60	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b62	88		dey				dey
.2b63	8a		txa				txa
.2b64	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b66	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.2b68	ad cb 06	lda $06cb			lda 	freeVariableMemory
.2b6b	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b6d	c8		iny				iny
.2b6e	ad cc 06	lda $06cc			lda 	freeVariableMemory+1
.2b71	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b73	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.2b75	a9 00		lda #$00			lda 	#0
.2b77	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b79	18		clc				clc
.2b7a	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.2b7c	6d c9 06	adc $06c9			adc  	variableListEnd
.2b7f	8d c9 06	sta $06c9			sta 	variableListEnd
.2b82	90 03		bcc $2b87			bcc 	_CVNoCarry2
.2b84	ee ca 06	inc $06ca			inc 	variableListEnd+1
.2b87					_CVNoCarry2:
.2b87	7a		ply				ply
.2b88	fa		plx				plx
.2b89	68		pla				pla
.2b8a	60		rts				rts
.2b8b					SetVariableRecordToCodePosition:
.2b8b	48		pha				pha
.2b8c	5a		phy				phy
.2b8d	a0 03		ldy #$03			ldy 	#3
.2b8f	a5 2b		lda $2b				lda 	objPtr+1
.2b91	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b93	c8		iny				iny
.2b94	a5 2a		lda $2a				lda 	objPtr
.2b96	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b98	7a		ply				ply
.2b99	68		pla				pla
.2b9a	60		rts				rts
.2b9b					AllocateBytesForType:
.2b9b	48		pha				pha
.2b9c	da		phx				phx
.2b9d	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.2b9f	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2ba1	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ba3	d0 02		bne $2ba7			bne 	_CVNotFloat
.2ba5	a2 06		ldx #$06			ldx 	#6
.2ba7					_CVNotFloat:
.2ba7	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.2ba8	18		clc				clc
.2ba9	6d cb 06	adc $06cb			adc 	freeVariableMemory
.2bac	8d cb 06	sta $06cb			sta 	freeVariableMemory
.2baf	90 03		bcc $2bb4			bcc 	_CVNoCarry1
.2bb1	ee cc 06	inc $06cc			inc 	freeVariableMemory+1
.2bb4					_CVNoCarry1:
.2bb4	fa		plx				plx
.2bb5	68		pla				pla
.2bb6	60		rts				rts
.2bb7					CommandDATA:
.2bb7	20 23 2a	jsr $2a23			jsr 	BufferClear 				; copy it to the buffer
.2bba	20 49 33	jsr $3349			jsr 	LookNextNonSpace
.2bbd					_CTDataLoop:
.2bbd	20 46 33	jsr $3346			jsr 	LookNext 					; reached EOL
.2bc0	f0 08		beq $2bca			beq 	_CTDataDone
.2bc2	20 27 2a	jsr $2a27			jsr 	BufferWrite 				; write and consume
.2bc5	20 57 33	jsr $3357			jsr 	GetNext
.2bc8	80 f3		bra $2bbd			bra 	_CTDataLoop
.2bca					_CTDataDone:
.2bca	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.2bcc	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2bcf	20 33 2a	jsr $2a33			jsr 	BufferOutput
.2bd2	60		rts				rts
.2bd3					CommandDEF:
.2bd3	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.2bd5	20 14 2b	jsr $2b14			jsr 	PushIntegerA
.2bd8	20 67 34	jsr $3467			jsr 	CompileGotoEOL 				; compile skip over DEF
.2bdb	a9 a5		lda #$a5			lda 	#C64_FN
.2bdd	20 54 2a	jsr $2a54			jsr 	CheckNextA
.2be0	20 62 33	jsr $3362			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2be3	20 c7 33	jsr $33c7			jsr 	ExtractVariableName
.2be6	8a		txa				txa
.2be7	10 51		bpl $2c3a			bpl 	_CDError
.2be9	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2bea	29 7f		and #$7f			and 	#$7F
.2bec	aa		tax				tax
.2bed	98		tya				tya
.2bee	09 80		ora #$80			ora 	#$80
.2bf0	a8		tay				tay
.2bf1	20 bc 2d	jsr $2dbc			jsr 	FindVariable				; does it already exist ?
.2bf4	b0 44		bcs $2c3a			bcs 	_CDError 					; if so, that's an error.
.2bf6	20 46 2b	jsr $2b46			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.2bf9	20 8b 2b	jsr $2b8b			jsr 	SetVariableRecordToCodePosition
.2bfc	20 62 33	jsr $3362			jsr 	GetNextNonSpace
.2bff	20 a3 36	jsr $36a3			jsr 	GetReferenceTerm 			; get var ref, not array
.2c02	c9 00		cmp #$00			cmp 	#0
.2c04	30 34		bmi $2c3a			bmi 	_CDError
.2c06	8d c1 06	sta $06c1			sta 	defType 					; save type
.2c09	8e c2 06	stx $06c2			stx 	defVariable 				; save var ref
.2c0c	8c c3 06	sty $06c3			sty 	defVariable+1
.2c0f	29 40		and #$40			and 	#NSSString 					; only numbers.
.2c11	d0 27		bne $2c3a			bne 	_CDError
.2c13	20 4e 2a	jsr $2a4e			jsr 	CheckNextRParen 			; check )
.2c16	a9 b2		lda #$b2			lda 	#C64_EQUAL
.2c18	20 54 2a	jsr $2a54			jsr 	CheckNextA 					; check =
.2c1b	18		clc				clc 								; if this is DEF FNxx(A), read A
.2c1c	20 3d 2c	jsr $2c3d			jsr 	CDReadWriteVariable
.2c1f	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2c21	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2c24	38		sec				sec
.2c25	20 3d 2c	jsr $2c3d			jsr 	CDReadWriteVariable 		; A is now updated
.2c28	20 02 2d	jsr $2d02			jsr 	CompileExpressionAt0 		; the actual body of the function.
.2c2b	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2c2d	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2c30	38		sec				sec
.2c31	20 3d 2c	jsr $2c3d			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.2c34	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.2c36	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2c39	60		rts				rts
.2c3a					_CDError:
.2c3a	4c d7 1e	jmp $1ed7		jmp	ErrorV_syntax
.2c3d					CDReadWriteVariable:
.2c3d	ac c3 06	ldy $06c3			ldy 	defVariable+1 				; set up YX
.2c40	ae c2 06	ldx $06c2			ldx 	defVariable
.2c43	ad c1 06	lda $06c1			lda 	defType
.2c46	20 55 36	jsr $3655			jsr 	GetSetVariable
.2c49	60		rts				rts
.06c1					defType:
>06c1							.fill 	1
.06c2					defVariable:
>06c2							.fill 	2
.2c4a					CommandDIM:
.2c4a	20 62 33	jsr $3362			jsr 	GetNextNonSpace 			; get the first non space character
.2c4d	20 c7 33	jsr $33c7			jsr 	ExtractVariableName 		; variable name to XY
.2c50	da		phx				phx 								; save name with type bits.
.2c51	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.2c53	10 37		bpl $2c8c			bpl 	_CDError
.2c55	20 bc 2d	jsr $2dbc			jsr 	FindVariable	 			; see if already exist
.2c58	b0 35		bcs $2c8f			bcs 	_CDRedefine 				; it still exists.
.2c5a	20 46 2b	jsr $2b46			jsr 	CreateVariableRecord 		; create the basic variable
.2c5d	20 9b 2b	jsr $2b9b			jsr 	AllocateBytesForType 		; allocate memory for it
.2c60	68		pla				pla 								; restore type bits
.2c61	5a		phy				phy 								; save the address of the basic storage
.2c62	da		phx				phx
.2c63	48		pha				pha
.2c64	20 92 2c	jsr $2c92			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.2c67	68		pla				pla
.2c68	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.2c6a	20 14 2b	jsr $2b14			jsr 	PushIntegerA 				; push that type data out.
.2c6d	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.2c6f	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2c72	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.2c74	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2c77	fa		plx				plx 								; restore address
.2c78	7a		ply				ply
.2c79	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2c7b	38		sec				sec
.2c7c	20 55 36	jsr $3655			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.2c7f	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; , follows ?
.2c82	c9 2c		cmp #$2c			cmp 	#","
.2c84	d0 05		bne $2c8b			bne 	_CDExit
.2c86	20 57 33	jsr $3357			jsr 	GetNext 					; consume comma
.2c89	80 bf		bra $2c4a			bra 	CommandDIM 					; do another DIM
.2c8b					_CDExit:
.2c8b	60		rts				rts
.2c8c					_CDError:
.2c8c	4c d7 1e	jmp $1ed7		jmp	ErrorV_syntax
.2c8f					_CDRedefine:
.2c8f	4c 9f 1f	jmp $1f9f		jmp	ErrorV_redefine
.2c92					OutputIndexGroup:
.2c92	9c c4 06	stz $06c4			stz 	IndexCount 					; count of number of indices.
.2c95					_OIGNext:
.2c95	20 02 2d	jsr $2d02			jsr 	CompileExpressionAt0 		; get a dimension
.2c98	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2c9a	c9 00		cmp #$00			cmp 	#NSSIFloat
.2c9c	d0 19		bne $2cb7			bne 	_OIGType
.2c9e	ee c4 06	inc $06c4			inc 	IndexCount 					; bump the counter.
.2ca1	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; does a , follow ?
.2ca4	c9 2c		cmp #$2c			cmp 	#","
.2ca6	d0 05		bne $2cad			bne 	_OIGCheckEnd
.2ca8	20 57 33	jsr $3357			jsr 	GetNext 					; consume comma
.2cab	80 e8		bra $2c95			bra 	_OIGNext 					; get next dimension
.2cad					_OIGCheckEnd:
.2cad	20 4e 2a	jsr $2a4e			jsr 	CheckNextRParen 			; check and consume )
.2cb0	ad c4 06	lda $06c4			lda 	IndexCount
.2cb3	20 14 2b	jsr $2b14			jsr 	PushIntegerA 				; compile the dimension count.
.2cb6	60		rts				rts
.2cb7					_OIGType:
.2cb7	4c e7 1e	jmp $1ee7		jmp	ErrorV_type
.06c4					IndexCount:
>06c4							.fill 	1
.2cba					CompilerErrorHandler:
.2cba	68		pla				pla
.2cbb	7a		ply				ply
.2cbc	85 2c		sta $2c				sta 	zTemp0
.2cbe	84 2d		sty $2d				sty 	zTemp0+1
.2cc0	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.2cc2	a0 01		ldy #$01			ldy 	#1
.2cc4					_EHDisplayMsg:
.2cc4	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2cc6	20 f9 29	jsr $29f9			jsr 	PrintCharacter
.2cc9	c8		iny				iny
.2cca	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ccc	d0 f6		bne $2cc4			bne 	_EHDisplayMsg
.2cce	a9 20		lda #$20			lda 	#32
.2cd0	20 f9 29	jsr $29f9			jsr 	PrintCharacter
.2cd3	a9 40		lda #$40			lda 	#64
.2cd5	20 f9 29	jsr $29f9			jsr 	PrintCharacter
.2cd8	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.2cda	20 1f 26	jsr $261f			jsr 	FloatSetByte
.2cdd	20 e5 29	jsr $29e5			jsr 	GetLineNumber
.2ce0	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2ce2	98		tya				tya
.2ce3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2ce5	20 05 25	jsr $2505			jsr 	FloatToString
.2ce8	a0 00		ldy #$00			ldy 	#0 							; display that string.
.2cea	a2 00		ldx #$00			ldx 	#0
.2cec					_EHDisplayLine:
.2cec	b9 96 05	lda $0596,y			lda 	decimalBuffer,y
.2cef	20 f9 29	jsr $29f9			jsr 	PrintCharacter
.2cf2	c8		iny				iny
.2cf3	b9 96 05	lda $0596,y			lda 	decimalBuffer,y
.2cf6	d0 f4		bne $2cec			bne 	_EHDisplayLine
.2cf8	a9 0d		lda #$0d			lda 	#13
.2cfa	20 f9 29	jsr $29f9			jsr 	PrintCharacter
.2cfd	80 fe		bra $2cfd	_EHHalt:bra 	_EHHalt
.2cff	4c f9 2a	jmp $2af9			jmp 	ExitCompiler
.2d02					CompileExpressionAt0:
.2d02	a9 00		lda #$00			lda 	#0
.2d04					CompileExpressionAtA:
.2d04	48		pha				pha  								; save level
.2d05	20 0e 37	jsr $370e			jsr 	CompileTerm 				; compile a term.
.2d08	fa		plx				plx 								; get level back into X
.2d09					_ECALoop:
.2d09	48		pha				pha 								; save type on stack.
.2d0a	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; get the next character
.2d0d	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.2d0f	90 04		bcc $2d15			bcc 	_ECAExit
.2d11	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.2d13	90 02		bcc $2d17			bcc 	_ECAHaveToken
.2d15					_ECAExit:
.2d15	68		pla				pla 								; throw type off stack
.2d16	60		rts				rts
.2d17					_ECAHaveToken:
.2d17	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.2d19	aa		tax				tax 								; X contains the operator token
.2d1a	bd 05 2d	lda $2d05,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.2d1d	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.2d1f	90 f4		bcc $2d15			bcc 	_ECAExit
.2d21	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.2d23	20 57 33	jsr $3357			jsr 	GetNext 					; consume the token.
.2d26	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.2d28	f0 11		beq $2d3b			beq 	_ECAGreaterCheck
.2d2a	e0 b3		cpx #$b3			cpx 	#C64_LESS
.2d2c	d0 1a		bne $2d48			bne 	_ECAHaveFullToken
.2d2e	20 46 33	jsr $3346			jsr 	LookNext 					; checks for < (<= or <>)
.2d31	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.2d33	f0 0e		beq $2d43			beq	 	_ECAToNotEqual
.2d35	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.2d37	d0 0f		bne $2d48			bne 	_ECAHaveFullToken
.2d39	80 07		bra $2d42			bra 	_ECAAddEqual
.2d3b					_ECAGreaterCheck:
.2d3b	20 46 33	jsr $3346			jsr 	LookNext
.2d3e	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.2d40	d0 06		bne $2d48			bne 	_ECAHaveFullToken
.2d42					_ECAAddEqual:
.2d42	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.2d43					_ECAToNotEqual:
.2d43	e8		inx				inx
.2d44	e8		inx				inx
.2d45	20 57 33	jsr $3357			jsr 	GetNext 					; consume the = or > in >= <= <>
.2d48					_ECAHaveFullToken:
.2d48	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.2d4a	d0 0a		bne $2d56			bne 	_ECANotConcat
.2d4c	68		pla				pla 								; get type back
.2d4d	48		pha				pha
.2d4e	29 40		and #$40			and 	#NSSTypeMask
.2d50	c9 40		cmp #$40			cmp 	#NSSString
.2d52	d0 02		bne $2d56			bne 	_ECANotConcat
.2d54	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2d56					_ECANotConcat:
.2d56	da		phx				phx 								; save operator on the stack
.2d57	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.2d59	da		phx				phx
.2d5a	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.2d5c	1a		inc a				inc 	a
.2d5d	20 04 2d	jsr $2d04			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.2d60	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.2d62	fa		plx				plx 								; restore current precedence in X
.2d63	68		pla				pla 								; restore operator
.2d64	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.2d66	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.2d68	90 17		bcc $2d81			bcc 	_ECANotCompare
.2d6a	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.2d6c	b0 13		bcs $2d81			bcs 	_ECANotCompare
.2d6e	7a		ply				ply 								; get type into Y
.2d6f	5a		phy				phy
.2d70	48		pha				pha 								; save operator
.2d71	98		tya				tya 								; get type
.2d72	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.2d74	29 40		and #$40			and 	#NSSTypeMask
.2d76	c9 40		cmp #$40			cmp 	#NSSString
.2d78	f0 02		beq $2d7c			beq 	_ECANotString
.2d7a	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.2d7c					_ECANotString:
.2d7c	98		tya				tya									; output token Y
.2d7d	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2d80	68		pla				pla 								; restore operator.
.2d81					_ECANotCompare:
.2d81	18		clc				clc 								; convert to P-Code and compile.
.2d82	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.2d84	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2d87	68		pla				pla 								; type of current result
.2d88	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.2d8a	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.2d8c	d0 19		bne $2da7			bne		_ECAType
.2d8e	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.2d90	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.2d92	d0 18		bne $2dac			bne 	_ECAGoLoop
.2d94	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.2d96	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2d98	f0 10		beq $2daa			beq 	_ECAOkayString 				; (this is post conversion)
.2d9a	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.2d9c	90 09		bcc $2da7			bcc 	_ECAType
.2d9e	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.2da0	b0 05		bcs $2da7			bcs 	_ECAType
.2da2	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.2da4	4c 09 2d	jmp $2d09			jmp 	_ECALoop
.2da7					_ECAType:
.2da7	4c e7 1e	jmp $1ee7		jmp	ErrorV_type
.2daa					_ECAOkayString:
.2daa	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.2dac					_ECAGoLoop:
.2dac	4c 09 2d	jmp $2d09			jmp 	_ECALoop
.2daf					PrecedenceTable:
>2daf	03						.byte 	3 					; '+'
>2db0	03						.byte 	3 					; '-'
>2db1	04						.byte 	4 					; '*'
>2db2	04						.byte 	4 					; '/'
>2db3	05						.byte 	5 					; '^'
>2db4	01						.byte 	1 					; 'and'
>2db5	00						.byte 	0 					; 'or'
>2db6	02						.byte 	2 					; '>'
>2db7	02						.byte 	2 					; '='
>2db8	02						.byte 	2 					; '<'
>2db9	02						.byte 	2 					; '>='
>2dba	02						.byte 	2 					; '<='
>2dbb	02						.byte 	2 					; '<>'
.2dbc					FindVariable:
.2dbc	86 2e		stx $2e				stx 	zTemp1 						; save name.
.2dbe	84 2f		sty $2f				sty 	zTemp1+1
.2dc0					_IVCheckSpecial:
.2dc0	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.2dc2	d0 18		bne $2ddc			bne 	_IVStandard
.2dc4	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.2dc6	f0 0c		beq $2dd4			beq 	_IVTIFloat
.2dc8	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.2dca	d0 10		bne $2ddc			bne 	_IVStandard
.2dcc	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.2dce	a2 01		ldx #$01			ldx 	#$01
.2dd0	a9 40		lda #$40			lda 	#NSSString
.2dd2	38		sec				sec
.2dd3	60		rts				rts
.2dd4					_IVTIFloat:
.2dd4	a0 80		ldy #$80			ldy 	#$80
.2dd6	a2 00		ldx #$00			ldx 	#$00
.2dd8	a9 00		lda #$00			lda 	#0
.2dda	38		sec				sec
.2ddb	60		rts				rts
.2ddc					_IVStandard:
.2ddc	ad bf 06	lda $06bf			lda 	compilerStartHigh			; start scanning from here.
.2ddf	85 2d		sta $2d				sta 	zTemp0+1
.2de1	64 2c		stz $2c				stz 	zTemp0
.2de3					_IVCheckLoop:
.2de3	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.2de5	f0 2b		beq $2e12			beq  	_IVNotFound 				; if so, return with CC.
.2de7	a0 01		ldy #$01			ldy 	#1 							; match ?
.2de9	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2deb	c5 2e		cmp $2e				cmp 	zTemp1
.2ded	d0 07		bne $2df6			bne	 	_IVNext
.2def	c8		iny				iny
.2df0	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2df2	c5 2f		cmp $2f				cmp 	zTemp1+1
.2df4	f0 0d		beq $2e03			beq 	_IVFound
.2df6					_IVNext:
.2df6	18		clc				clc
.2df7	a5 2c		lda $2c				lda 	zTemp0
.2df9	72 2c		adc ($2c)			adc 	(zTemp0)
.2dfb	85 2c		sta $2c				sta 	zTemp0
.2dfd	90 e4		bcc $2de3			bcc 	_IVCheckLoop
.2dff	e6 2d		inc $2d				inc 	zTemp0+1
.2e01	80 e0		bra $2de3			bra 	_IVCheckLoop
.2e03					_IVFound:
.2e03	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.2e05	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e07	aa		tax				tax
.2e08	c8		iny				iny
.2e09	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e0b	48		pha				pha
.2e0c	c8		iny				iny
.2e0d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e0f	7a		ply				ply
.2e10	38		sec				sec
.2e11	60		rts				rts
.2e12					_IVNotFound:
.2e12	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.2e14	a4 2f		ldy $2f				ldy 	zTemp1+1
.2e16	18		clc				clc
.2e17	60		rts				rts
.2e18					FixBranches:
.2e18	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.2e1a	20 fe 2a	jsr $2afe			jsr 	CallAPIHandler
.2e1d					_FBLoop:
.2e1d	b2 2a		lda ($2a)			lda 	(objPtr) 					; get the next one.
.2e1f	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.2e21	f0 16		beq $2e39			beq 	_FBFixGotoGosub
.2e23	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.2e25	f0 12		beq $2e39			beq 	_FBFixGotoGosub
.2e27	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.2e29	f0 0e		beq $2e39			beq 	_FBFixGotoGosub
.2e2b	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.2e2d	f0 0a		beq $2e39			beq 	_FBFixGotoGosub
.2e2f	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.2e31	f0 3b		beq $2e6e			beq 	_FBFixVarSpace
.2e33					_FBNext:
.2e33	20 ec 1f	jsr $1fec			jsr 	MoveObjectForward 			; move forward in object code.
.2e36	90 e5		bcc $2e1d			bcc 	_FBLoop 					; not finished
.2e38					_FBExit:
.2e38	60		rts				rts
.2e39					_FBFixGotoGosub:
.2e39	a0 01		ldy #$01			ldy 	#1							; line number in YA
.2e3b	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e3d	48		pha				pha
.2e3e	c8		iny				iny
.2e3f	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e41	a8		tay				tay
.2e42	68		pla				pla
.2e43	20 f9 34	jsr $34f9			jsr 	STRFindLine			 		; find where it is YA
.2e46	90 08		bcc $2e50			bcc 	_FBFFound 					; not found, so must be >
.2e48	48		pha				pha
.2e49	b2 2a		lda ($2a)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.2e4b	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.2e4d	d0 0f		bne $2e5e			bne 	_FBFFail
.2e4f	68		pla				pla
.2e50					_FBFFound:
.2e50	20 49 35	jsr $3549			jsr 	STRMakeOffset 				; make it an offset from X:YA
.2e53	5a		phy				phy	 								; patch the GOTO/GOSUB
.2e54	a0 01		ldy #$01			ldy 	#1
.2e56	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e58	c8		iny				iny
.2e59	68		pla				pla
.2e5a	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e5c	80 d5		bra $2e33			bra 	_FBNext
.2e5e					_FBFFail:
.2e5e	a0 02		ldy #$02			ldy 	#2
.2e60	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e62	8d b8 05	sta $05b8			sta 	currentLineNumber
.2e65	c8		iny				iny
.2e66	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e68	8d b9 05	sta $05b9			sta 	currentLineNumber+1
.2e6b	4c 1a 1f	jmp $1f1a		jmp	ErrorV_line
.2e6e					_FBFixVarSpace:
.2e6e	a0 01		ldy #$01			ldy 	#1
.2e70	ad cb 06	lda $06cb			lda 	freeVariableMemory
.2e73	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e75	c8		iny				iny
.2e76	ad cc 06	lda $06cc			lda 	freeVariableMemory+1
.2e79	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e7b	80 b6		bra $2e33			bra 	_FBNext
.2e7d					CommandFOR:
.2e7d	20 62 33	jsr $3362			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.2e80	20 78 33	jsr $3378			jsr 	CharIsAlpha 				; if not alpha , error
.2e83	90 59		bcc $2ede			bcc 	_CFFail
.2e85	20 a3 36	jsr $36a3			jsr 	GetReferenceTerm 			; figure out the reference.
.2e88	48		pha				pha 								; save type
.2e89	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2e8b	c9 00		cmp #$00			cmp 	#NSSIFloat
.2e8d	d0 4f		bne $2ede			bne 	_CFFail
.2e8f	5a		phy				phy 								; save reference on the stack
.2e90	da		phx				phx
.2e91	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.2e93	20 54 2a	jsr $2a54			jsr 	CheckNextA
.2e96	20 02 2d	jsr $2d02			jsr 	CompileExpressionAt0 		; initial value
.2e99	fa		plx				plx 								; get reference back.
.2e9a	7a		ply				ply
.2e9b	5a		phy				phy
.2e9c	da		phx				phx
.2e9d	38		sec				sec 								; set initial value.
.2e9e	20 55 36	jsr $3655			jsr 	GetSetVariable
.2ea1	fa		plx				plx
.2ea2	7a		ply				ply
.2ea3	68		pla				pla
.2ea4	29 20		and #$20			and 	#NSSIInt16
.2ea6	f0 04		beq $2eac			beq 	_CFNotInt16
.2ea8	98		tya				tya
.2ea9	09 80		ora #$80			ora 	#$80
.2eab	a8		tay				tay
.2eac					_CFNotInt16:
.2eac	8a		txa				txa 								; reference in YA
.2ead	20 01 2b	jsr $2b01			jsr 	PushIntegerYA
.2eb0	a9 a4		lda #$a4			lda 	#C64_TO
.2eb2	20 54 2a	jsr $2a54			jsr 	CheckNextA
.2eb5	20 02 2d	jsr $2d02			jsr 	CompileExpressionAt0 		; terminal value
.2eb8	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2eba	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ebc	d0 20		bne $2ede			bne 	_CFFail
.2ebe	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; followed by STEP
.2ec1	c9 a9		cmp #$a9			cmp 	#C64_STEP
.2ec3	d0 0e		bne $2ed3			bne 	_CFNoStep
.2ec5	20 57 33	jsr $3357			jsr 	GetNext 					; consume it.
.2ec8	20 02 2d	jsr $2d02			jsr 	CompileExpressionAt0 		; terminal value
.2ecb	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ecd	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ecf	d0 0d		bne $2ede			bne 	_CFFail
.2ed1	80 05		bra $2ed8			bra 	_CFParametersDone
.2ed3					_CFNoStep:
.2ed3	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.2ed5	20 14 2b	jsr $2b14			jsr 	PushIntegerA
.2ed8					_CFParametersDone:
.2ed8	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2eda	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2edd	60		rts				rts
.2ede					_CFFail:
.2ede	4c d7 1e	jmp $1ed7		jmp	ErrorV_syntax
.2ee1					FNCompile:
.2ee1	20 62 33	jsr $3362			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2ee4	20 c7 33	jsr $33c7			jsr 	ExtractVariableName
.2ee7	e0 00		cpx #$00			cpx 	#0
.2ee9	10 32		bpl $2f1d			bpl 	_FNError
.2eeb	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2eec	29 7f		and #$7f			and 	#$7F
.2eee	aa		tax				tax
.2eef	98		tya				tya
.2ef0	09 80		ora #$80			ora 	#$80
.2ef2	a8		tay				tay
.2ef3	20 bc 2d	jsr $2dbc			jsr 	FindVariable				; does it already exist ?
.2ef6	90 25		bcc $2f1d			bcc 	_FNError 					; no.
.2ef8	20 49 35	jsr $3549			jsr 	STRMakeOffset 				; convert to a relative address.
.2efb	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2efd	d0 01		bne $2f00			bne 	_FNNoBorrow
.2eff	88		dey				dey
.2f00					_FNNoBorrow:
.2f00	3a		dec a				dec 	a
.2f01	5a		phy				phy 								; save location of routine on stack.
.2f02	48		pha				pha
.2f03	da		phx				phx
.2f04	20 02 2d	jsr $2d02			jsr 	CompileExpressionAt0
.2f07	20 4e 2a	jsr $2a4e			jsr 	CheckNextRParen
.2f0a	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.2f0c	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2f0f	68		pla				pla
.2f10	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2f13	68		pla				pla
.2f14	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2f17	68		pla				pla
.2f18	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.2f1b	18		clc				clc
.2f1c	60		rts				rts
.2f1d					_FNError:
.2f1d	4c ca 1e	jmp $1eca		jmp	ErrorV_value
.2f20					CommandTables:
>2f20	07 cb 00 03 25 34 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2f27	07 89 00 03 2c 34 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2f2e	07 8d 00 03 1f 34 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>2f35	07 88 00 03 9b 34 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2f3c	07 85 00 03 7b 34 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>2f43	07 84 00 04 8f 34 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>2f4a	07 99 00 03 d0 35 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2f51	07 98 00 04 d0 35 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2f58	07 8f 00 03 db 36 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>2f5f	07 81 00 03 7d 2e 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>2f66	07 82 00 03 53 35 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>2f6d	07 a1 00 03 98 33 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>2f74	07 83 00 03 b7 2b 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>2f7b	07 87 00 03 19 36 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>2f82	07 86 00 03 4a 2c 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>2f89	07 96 00 03 d3 2b 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>2f90	07 8b 00 e3 48 34 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>2f97	08 92 00 ea e3 a7 37 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>2f9f	09 91 00 e1 a9 03 7f 35			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>2fa7	06
>2fa8	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>2faf	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>2fb6	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>2fbc	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>2fc3	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>2fca	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>2fd1	07 9d 00 e3 cd 37 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>2fd8	0a 9f 00 ea e3 e0 37 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>2fe0	c6 06
>2fe2	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>2fe8	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>2fef	0a ce 92 e3 15 33 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>2ff7	ad 06
>2ff9	0a ce 8d e3 15 33 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>3001	ae 06
>3003	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>3009	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>3011	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>3018	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>301f	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>3027	06
>3028	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>3030	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>3038	9a 06
>303a	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>3042	9b 06
>3044	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>304c	9c 06
>304e	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>3056	06
>3057	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>305e	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>3066	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>306e	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>3076	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>307e	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>3086	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>308e	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>3096	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>309e	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>30a6	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>30ae	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>30b5	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>30bd	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>30c5	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>30cd	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>30d5	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>30dd	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>30e5	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>30ed	00						.byte 	0
.30ee					UnaryTables:
>30ee	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>30f5	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>30fd	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>3104	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>310b	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>3112	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>3119	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>3121	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>3128	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>3130	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>3138	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>3140	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>3148	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>3150	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>3158	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>315f	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>3166	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>316d	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>3174	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>317b	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>3182	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>318a	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>3192	0b ca 00 8f ae 03 15 33			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>319a	91 bd 07
>319d	07 a8 00 03 34 33 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>31a4	07 a5 00 03 e1 2e 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>31ab	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>31b2	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>31b9	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>31c1	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>31c9	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>31d0	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>31d7	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>31de	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>31e6	06
>31e7	00						.byte 	0
.31e8					GeneratorProcess:
.31e8	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.31ea	84 2d		sty $2d				sty 	zTemp0+1
.31ec	85 2e		sta $2e				sta 	zTemp1 						; first match token
.31ee	64 2f		stz $2f				stz 	zTemp1+1
.31f0	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.31f2	d0 05		bne $31f9			bne 	_GPNotShifted
.31f4	20 57 33	jsr $3357			jsr 	GetNext 					; get the shifted token
.31f7	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.31f9					_GPNotShifted:
.31f9					_GPSearch:
.31f9	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.31fb	18		clc				clc
.31fc	f0 2f		beq $322d			beq 	_GPExit
.31fe	a0 01		ldy #$01			ldy 	#1 							; tokens match
.3200	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.3202	c5 2e		cmp $2e				cmp 	zTemp1
.3204	d0 09		bne $320f			bne 	_GPNext
.3206	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.3208	f0 12		beq $321c			beq 	_GPFound
.320a	c8		iny				iny 								; check match.
.320b	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.320d	f0 0d		beq $321c			beq 	_GPFound
.320f					_GPNext:
.320f	18		clc				clc 								; follow to next
.3210	a5 2c		lda $2c				lda 	zTemp0
.3212	72 2c		adc ($2c)			adc 	(zTemp0)
.3214	85 2c		sta $2c				sta 	zTemp0
.3216	90 e1		bcc $31f9			bcc 	_GPSearch
.3218	e6 2d		inc $2d				inc 	zTemp0+1
.321a	80 dd		bra $31f9			bra 	_GPSearch
.321c					_GPFound:
.321c	18		clc				clc 								; skip to action bytes
.321d	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.321f	69 03		adc #$03			adc 	#3
.3221	85 2c		sta $2c				sta 	zTemp0
.3223	90 02		bcc $3227			bcc 	_GPNoCarry
.3225	e6 2d		inc $2d				inc 	zTemp0+1
.3227					_GPNoCarry:
.3227					_GPLoop:
.3227	20 2e 32	jsr $322e			jsr 	GeneratorExecute 			; execute one command
.322a	90 fb		bcc $3227			bcc 	_GPLoop 					; go back if not completed.
.322c	38		sec				sec 								; return with CS.
.322d					_GPExit:
.322d	60		rts				rts
.322e					GeneratorExecute:
.322e	20 da 32	jsr $32da			jsr 	_GEFetchZTemp0 				; get next.
.3231	48		pha				pha 								; split into 2 nibbles
.3232	4a		lsr a				lsr 	a
.3233	4a		lsr a				lsr 	a
.3234	4a		lsr a				lsr		a
.3235	4a		lsr a				lsr 	a
.3236	20 40 32	jsr $3240			jsr 	_GEExecuteNibble 			; MSB first
.3239	68		pla				pla
.323a	b0 03		bcs $323f			bcs 	_GEHaveCompleted
.323c	20 40 32	jsr $3240			jsr 	_GEExecuteNibble 			; LSB second
.323f					_GEHaveCompleted:
.323f	60		rts				rts
.3240					_GEExecuteNibble:
.3240	29 0f		and #$0f			and 	#$0F
.3242	0a		asl a				asl 	a
.3243	aa		tax				tax
.3244	7c 47 32	jmp ($3247,x)			jmp 	(_GEExecuteVectors,x)
.3247					_GEExecuteVectors:
>3247	67 32						.word 	_GEXNop 					; 0  (no operation)
>3249	6f 32						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>324b	69 32						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>324d	bd 32						.word 	_GEXExecute 				; 3  (run arbitrary code)
>324f	b0 32						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>3251	67 32						.word 	_GEXNop 					; 5
>3253	77 32						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>3255	7b 32						.word 	_GEXExitString 				; 7  exit return string type
>3257	7f 32						.word 	_GEXLParam 					; 8  check ( follows
>3259	83 32						.word 	_GEXRParam 					; 9  check ) follows
>325b	87 32						.word 	_GEXComma					; A  check , follows
>325d	67 32						.word 	_GEXNop 					; B
>325f	67 32						.word 	_GEXNop 					; C
>3261	67 32						.word 	_GEXNop 					; D
>3263	97 32						.word 	_GEXNumber 					; E  compile get any number
>3265	a2 32						.word 	_GEXString 					; F  compile get any string
.3267					_GEXNop:
.3267	18		clc				clc
.3268	60		rts				rts
.3269					_GEXToken2:
.3269	20 da 32	jsr $32da			jsr 	_GEFetchZTemp0
.326c	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.326f					_GEXToken1:
.326f	20 da 32	jsr $32da			jsr 	_GEFetchZTemp0
.3272	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.3275	18		clc				clc
.3276	60		rts				rts
.3277					_GEXExitNumber:
.3277	a9 00		lda #$00			lda 	#NSSIFloat
.3279	38		sec				sec
.327a	60		rts				rts
.327b					_GEXExitString:
.327b	a9 40		lda #$40			lda 	#NSSString
.327d	38		sec				sec
.327e	60		rts				rts
.327f					_GEXLParam:
.327f	a9 28		lda #$28			lda 	#"("
.3281	80 06		bra $3289			bra 	_GEXCheck
.3283					_GEXRParam:
.3283	a9 29		lda #$29			lda 	#")"
.3285	80 02		bra $3289			bra 	_GEXCheck
.3287					_GEXComma:
.3287	a9 2c		lda #$2c			lda 	#","
.3289					_GEXCheck:
.3289	85 30		sta $30				sta 	zTemp2 						; save match
.328b	20 62 33	jsr $3362			jsr 	GetNextNonSpace 			; get next skipping spaces
.328e	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.3290	d0 02		bne $3294			bne 	_GEXSyntax
.3292	18		clc				clc
.3293	60		rts				rts
.3294					_GEXSyntax:
.3294	4c d7 1e	jmp $1ed7		jmp	ErrorV_syntax
.3297					_GEXNumber:
.3297	20 e3 32	jsr $32e3			jsr 	GEXCompileExpression 		; compile expression
.329a	29 40		and #$40			and 	#NSSTypeMask
.329c	c9 00		cmp #$00			cmp  	#NSSIFloat
.329e	d0 0d		bne $32ad			bne 	_GEXType
.32a0	18		clc				clc
.32a1	60		rts				rts
.32a2					_GEXString:
.32a2	20 e3 32	jsr $32e3			jsr 	GEXCompileExpression 		; compile expression
.32a5	29 40		and #$40			and 	#NSSTypeMask
.32a7	c9 40		cmp #$40			cmp  	#NSSString
.32a9	d0 02		bne $32ad			bne 	_GEXType
.32ab	18		clc				clc
.32ac	60		rts				rts
.32ad					_GEXType:
.32ad	4c e7 1e	jmp $1ee7		jmp	ErrorV_type
.32b0					_GEXChannelExec:
.32b0	20 f3 32	jsr $32f3			jsr 	ChannelPrefix 				; set up default
.32b3	20 bd 32	jsr $32bd			jsr 	_GEXExecute
.32b6	08		php				php
.32b7	20 0e 33	jsr $330e			jsr 	ChannelPostfix 				; replace default.
.32ba	28		plp				plp
.32bb	60		rts				rts
>32bc	db						.byte 	$DB 						; causes a break in the emulator
.32bd					_GEXExecute:
.32bd	20 da 32	jsr $32da			jsr 	_GEFetchZTemp0 				; get vector
.32c0	85 30		sta $30				sta 	zTemp2
.32c2	20 da 32	jsr $32da			jsr 	_GEFetchZTemp0
.32c5	85 31		sta $31				sta 	zTemp2+1
.32c7	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.32c9	da		phx				phx
.32ca	a6 2d		ldx $2d				ldx 	zTemp0+1
.32cc	da		phx				phx
.32cd	20 d7 32	jsr $32d7			jsr 	_GECallZTemp2 				; execute code
.32d0	fa		plx				plx 								; recover generation exec
.32d1	86 2d		stx $2d				stx 	zTemp0+1
.32d3	fa		plx				plx
.32d4	86 2c		stx $2c				stx 	zTemp0
.32d6	60		rts				rts
.32d7					_GECallZTemp2:
.32d7	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.32da					_GEFetchZTemp0:
.32da	b2 2c		lda ($2c)			lda 	(zTemp0)
.32dc	e6 2c		inc $2c				inc 	zTemp0
.32de	d0 02		bne $32e2			bne 	_GEFZ0Skip
.32e0	e6 2d		inc $2d				inc 	zTemp0+1
.32e2					_GEFZ0Skip:
.32e2	60		rts				rts
.32e3					GEXCompileExpression:
.32e3	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.32e5	da		phx				phx
.32e6	a6 2d		ldx $2d				ldx 	zTemp0+1
.32e8	da		phx				phx
.32e9	20 02 2d	jsr $2d02			jsr 	CompileExpressionAt0 		; compile expression.
.32ec	fa		plx				plx 								; recover generation exec
.32ed	86 2d		stx $2d				stx 	zTemp0+1
.32ef	fa		plx				plx
.32f0	86 2c		stx $2c				stx 	zTemp0
.32f2	60		rts				rts
.32f3					ChannelPrefix:
.32f3	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.32f5	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.32f8	20 e3 32	jsr $32e3			jsr 	GEXCompileExpression 		; channel #
.32fb	29 40		and #$40			and 	#NSSTypeMask
.32fd	c9 00		cmp #$00			cmp 	#NSSIFloat
.32ff	d0 0a		bne $330b			bne 	_CPXType
.3301	20 4a 2a	jsr $2a4a			jsr 	CheckNextComma 				; check , follows.
.3304	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.3306	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.3309	18		clc				clc
.330a	60		rts				rts
.330b					_CPXType:
.330b	4c e7 1e	jmp $1ee7		jmp	ErrorV_type
.330e					ChannelPostfix:
.330e	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.3310	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.3313	18		clc				clc
.3314	60		rts				rts
.3315					OptionalParameterCompile:
.3315	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; what follows.
.3318	c9 2c		cmp #$2c			cmp 	#","
.331a	d0 0e		bne $332a			bne 	_MidDefault
.331c	20 57 33	jsr $3357			jsr 	GetNext 					; consume ,
.331f	20 02 2d	jsr $2d02			jsr 	CompileExpressionAt0
.3322	29 40		and #$40			and 	#NSSTypeMask
.3324	c9 00		cmp #$00			cmp 	#NSSIFloat
.3326	d0 09		bne $3331			bne 	MidFailType
.3328	80 05		bra $332f			bra 	_MidComplete
.332a					_MidDefault:
.332a	a9 ff		lda #$ff			lda 	#255 						; default of 255
.332c	20 14 2b	jsr $2b14			jsr 	PushIntegerA
.332f					_MidComplete:
.332f	18		clc				clc
.3330	60		rts				rts
.3331					MidFailType:
.3331	4c e7 1e	jmp $1ee7		jmp	ErrorV_type
.3334					NotUnaryCompile:
.3334	ad b7 2d	lda $2db7			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.3337	20 04 2d	jsr $2d04			jsr 	CompileExpressionAtA 		; evaluate at that level
.333a	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.333c	c9 00		cmp #$00			cmp 	#NSSIFloat
.333e	d0 f1		bne $3331			bne 	MidFailType
.3340	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.3342	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.3345	60		rts				rts
.3346					LookNext:
.3346	b2 7a		lda ($7a)			lda 	(srcPtr)
.3348	60		rts				rts
.3349					LookNextNonSpace:
.3349	b2 7a		lda ($7a)			lda 	(srcPtr)
.334b	c9 20		cmp #$20			cmp		#' '
.334d	f0 03		beq $3352			beq 	_LNNSkip
.334f	c9 00		cmp #$00			cmp 	#0
.3351	60		rts				rts
.3352					_LNNSkip:
.3352	20 57 33	jsr $3357			jsr 	GetNext
.3355	80 f2		bra $3349			bra 	LookNextNonSpace
.3357					GetNext:
.3357	b2 7a		lda ($7a)			lda 	(srcPtr) 					; get next
.3359	e6 7a		inc $7a				inc 	srcPtr
.335b	d0 02		bne $335f			bne 	_GNSkip
.335d	e6 7b		inc $7b				inc 	srcPtr+1
.335f					_GNSkip:
.335f	c9 00		cmp #$00			cmp 	#0
.3361	60		rts				rts
.3362					GetNextNonSpace:
.3362	20 57 33	jsr $3357			jsr 	GetNext
.3365	c9 20		cmp #$20			cmp 	#' '
.3367	f0 f9		beq $3362			beq 	GetNextNonSpace
.3369	c9 00		cmp #$00			cmp 	#0
.336b	60		rts				rts
.336c					CharIsDigit:
.336c	c9 30		cmp #$30			cmp 	#"0"
.336e	90 06		bcc $3376			bcc 	CCFalse
.3370	c9 3a		cmp #$3a			cmp 	#"9"+1
.3372	b0 02		bcs $3376			bcs 	CCFalse
.3374					CCTrue:
.3374	38		sec				sec
.3375	60		rts				rts
.3376					CCFalse:
.3376	18		clc				clc
.3377	60		rts				rts
.3378					CharIsAlpha:
.3378	c9 41		cmp #$41			cmp 	#"A"
.337a	90 fa		bcc $3376			bcc 	CCFalse
.337c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.337e	b0 f6		bcs $3376			bcs 	CCFalse
.3380	80 f2		bra $3374			bra 	CCTrue
.3382					ConvertHexStyle:
.3382	38		sec				sec
.3383	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.3385	90 ef		bcc $3376			bcc 	CCFalse
.3387	c9 0a		cmp #$0a			cmp 	#9+1
.3389	90 e9		bcc $3374			bcc 	CCTrue
.338b	38		sec				sec 								; shift into hex space A=>0 Z=>25
.338c	e9 11		sbc #$11			sbc 	#"A"-"0"
.338e	90 e6		bcc $3376			bcc 	CCFalse
.3390	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.3392	b0 e2		bcs $3376			bcs 	CCFalse
.3394	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.3396	80 dc		bra $3374			bra 	CCTrue
.3398					CommandGET:
.3398	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; # follows ?
.339b	c9 23		cmp #$23			cmp 	#"#"
.339d	d0 0d		bne $33ac			bne 	CommandGetBody
.339f	20 57 33	jsr $3357			jsr 	GetNext 					; consume #
.33a2	20 f3 32	jsr $32f3			jsr 	ChannelPrefix 				; do it as GET#
.33a5	20 ac 33	jsr $33ac			jsr 	CommandGetBody
.33a8	20 0e 33	jsr $330e			jsr 	ChannelPostfix
.33ab	60		rts				rts
.33ac					CommandGetBody:
.33ac	20 62 33	jsr $3362			jsr 	GetNextNonSpace 			; get the first character
.33af	20 a3 36	jsr $36a3			jsr 	GetReferenceTerm 			; identify variable to assign to
.33b2	48		pha				pha
.33b3	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.33b5	c9 40		cmp #$40			cmp 	#NSSString
.33b7	d0 0b		bne $33c4			bne 	_CGType
.33b9	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.33bb	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.33be	38		sec				sec
.33bf	68		pla				pla
.33c0	20 55 36	jsr $3655			jsr		GetSetVariable
.33c3	60		rts				rts
.33c4					_CGType:
.33c4	4c e7 1e	jmp $1ee7		jmp	ErrorV_type
.33c7					ExtractVariableName:
.33c7	20 78 33	jsr $3378			jsr 	CharIsAlpha
.33ca	90 50		bcc $341c			bcc 	_IVSyntax
.33cc	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.33ce	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.33d0	64 2f		stz $2f				stz 	zTemp1+1
.33d2	20 46 33	jsr $3346			jsr 	LookNext 					; is there a second character ?
.33d5	20 78 33	jsr $3378			jsr 	CharIsAlpha  				; must be alphanumeric
.33d8	b0 05		bcs $33df			bcs 	_IVHasSecond
.33da	20 6c 33	jsr $336c			jsr 	CharIsDigit
.33dd	90 07		bcc $33e6			bcc 	_IVCheckType
.33df					_IVHasSecond:
.33df	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.33e1	85 2f		sta $2f				sta 	zTemp1+1
.33e3					_IVGetNextCheck:
.33e3	20 57 33	jsr $3357			jsr 	GetNext 					; consume it
.33e6					_IVCheckType:
.33e6	20 46 33	jsr $3346			jsr 	LookNext					; check if string follows.
.33e9	20 78 33	jsr $3378			jsr 	CharIsAlpha
.33ec	b0 f5		bcs $33e3			bcs 	_IVGetNextCheck
.33ee	20 6c 33	jsr $336c			jsr 	CharIsDigit
.33f1	b0 f0		bcs $33e3			bcs 	_IVGetNextCheck
.33f3	a2 40		ldx #$40			ldx 	#NSSString
.33f5	c9 24		cmp #$24			cmp 	#"$"
.33f7	f0 06		beq $33ff			beq 	_IVHasType
.33f9	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.33fb	c9 25		cmp #$25			cmp 	#"%"
.33fd	d0 08		bne $3407			bne 	_IVCheckArray
.33ff					_IVHasType:
.33ff	8a		txa				txa 								; Or X into zTemp1
.3400	05 2e		ora $2e				ora 	zTemp1
.3402	85 2e		sta $2e				sta 	zTemp1
.3404	20 57 33	jsr $3357			jsr 	GetNext 					; consume it
.3407					_IVCheckArray:
.3407	20 46 33	jsr $3346			jsr 	LookNext 					; check if array follows
.340a	c9 28		cmp #$28			cmp 	#"("
.340c	d0 09		bne $3417			bne 	_IVNotArray
.340e	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.3410	09 80		ora #$80			ora 	#NSSArray
.3412	85 2e		sta $2e				sta 	zTemp1
.3414	20 57 33	jsr $3357			jsr 	GetNext 					; consume it
.3417					_IVNotArray:
.3417	a6 2e		ldx $2e				ldx 	zTemp1
.3419	a4 2f		ldy $2f				ldy 	zTemp1+1
.341b	60		rts				rts
.341c					_IVSyntax:
.341c	4c d7 1e	jmp $1ed7		jmp	ErrorV_syntax
.341f					CommandGOSUB:
.341f	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.3421	20 32 34	jsr $3432			jsr 	CompileBranchCommand
.3424	60		rts				rts
.3425					CommandGOAlt:
.3425	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.3427	20 54 2a	jsr $2a54			jsr 	CheckNextA
.342a	80 00		bra $342c			bra 	CommandGOTO
.342c					CommandGOTO:
.342c	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.342e	20 32 34	jsr $3432			jsr 	CompileBranchCommand
.3431	60		rts				rts
.3432					CompileBranchCommand:
.3432	20 ec 29	jsr $29ec			jsr 	WriteCodeByte 				; write the command out.
.3435	20 62 33	jsr $3362			jsr 	GetNextNonSpace
.3438	20 ab 35	jsr $35ab			jsr 	ParseConstant 				; get constant into YA
.343b	90 08		bcc $3445			bcc 	_CBCSyntax
.343d	20 ec 29	jsr $29ec			jsr 	WriteCodeByte				; and compile the actual line number
.3440	98		tya				tya
.3441	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.3444	60		rts				rts
.3445					_CBCSyntax:
.3445	4c d7 1e	jmp $1ed7		jmp	ErrorV_syntax
.3448					CommandIF:
.3448	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; what follows the tests ?
.344b	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.344d	f0 0f		beq $345e			beq 	_CIGoto
.344f	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.3451	20 54 2a	jsr $2a54			jsr 	CheckNextA
.3454	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; THEN <number>
.3457	20 6c 33	jsr $336c			jsr 	CharIsDigit
.345a	b0 05		bcs $3461			bcs 	_CIGoto2
.345c	80 09		bra $3467			bra 	CompileGotoEOL
.345e					_CIGoto:
.345e	20 57 33	jsr $3357			jsr 	GetNext
.3461					_CIGoto2:
.3461	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.3463	20 32 34	jsr $3432			jsr 	CompileBranchCommand
.3466	60		rts				rts
.3467					CompileGotoEOL:
.3467	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.3469	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.346c	20 e5 29	jsr $29e5			jsr 	GetLineNumber 				; Get the current line number => YA
.346f	1a		inc a				inc 	a 							; and branch to +1
.3470	d0 01		bne $3473			bne 	_CGENoCarry
.3472	c8		iny				iny
.3473					_CGENoCarry:
.3473	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.3476	98		tya				tya
.3477	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.347a	60		rts				rts
.347b					CommandINPUT:
.347b	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; check for "
.347e	c9 22		cmp #$22			cmp 	#'"'
.3480	d0 0d		bne $348f			bne 	CommandINPUTStream
.3482	20 02 2d	jsr $2d02			jsr 	CompileExpressionAt0
.3485	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.3487	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.348a	a9 2c		lda #$2c			lda 	#","
.348c	20 4a 2a	jsr $2a4a			jsr 	CheckNextComma
.348f					CommandINPUTStream:
.348f	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.3491	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.3494	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.3496	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.3498	4c 1d 36	jmp $361d			jmp 	CommandReadInputCommon
.349b					CommandLET:
.349b	20 62 33	jsr $3362			jsr 	GetNextNonSpace 			; get the first character
.349e					CommandLETHaveFirst:
.349e	20 a3 36	jsr $36a3			jsr 	GetReferenceTerm 			; identify variable to assign to
.34a1	da		phx				phx 								; save target on the stack.
.34a2	5a		phy				phy
.34a3	48		pha				pha
.34a4	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.34a6	20 54 2a	jsr $2a54			jsr 	CheckNextA
.34a9	20 02 2d	jsr $2d02			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.34ac	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.34ae	68		pla				pla 								; get type of assignment
.34af	48		pha				pha
.34b0	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.34b2	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.34b4	d0 17		bne $34cd			bne 	_CLType
.34b6	68		pla				pla 								; restore and compile save code
.34b7	7a		ply				ply
.34b8	fa		plx				plx
.34b9	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.34bb	f0 05		beq $34c2			beq 	_CLTIString
.34bd	38		sec				sec
.34be	20 55 36	jsr $3655			jsr		GetSetVariable
.34c1	60		rts				rts
.34c2					_CLTIString:
.34c2	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.34c4	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.34c7	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.34c9	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.34cc	60		rts				rts
.34cd					_CLType:
.34cd	4c e7 1e	jmp $1ee7		jmp	ErrorV_type
.34d0					STRMarkLine:
.34d0	48		pha				pha
.34d1	38		sec				sec 								; allocate 4 bytes (line #,address)
.34d2	ad c7 06	lda $06c7			lda 	lineNumberTable 			; and copy to zTemp0
.34d5	e9 04		sbc #$04			sbc 	#4
.34d7	8d c7 06	sta $06c7			sta 	lineNumberTable
.34da	85 2c		sta $2c				sta 	zTemp0
.34dc	ad c8 06	lda $06c8			lda 	lineNumberTable+1
.34df	e9 00		sbc #$00			sbc 	#0
.34e1	8d c8 06	sta $06c8			sta 	lineNumberTable+1
.34e4	85 2d		sta $2d				sta 	zTemp0+1
.34e6	68		pla				pla
.34e7	92 2c		sta ($2c)			sta 	(zTemp0) 					; line # save it in +0,+1
.34e9	98		tya				tya
.34ea	a0 01		ldy #$01			ldy 	#1
.34ec	91 2c		sta ($2c),y			sta 	(zTemp0),y
.34ee	a5 2a		lda $2a				lda 	objPtr 						; save current address in +2,+3
.34f0	c8		iny				iny
.34f1	91 2c		sta ($2c),y			sta 	(zTemp0),y
.34f3	a5 2b		lda $2b				lda 	objPtr+1
.34f5	c8		iny				iny
.34f6	91 2c		sta ($2c),y			sta 	(zTemp0),y
.34f8	60		rts				rts
.34f9					STRFindLine:
.34f9	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.34fb	84 2d		sty $2d				sty 	zTemp0+1
.34fd	ad c0 06	lda $06c0			lda 	compilerEndHigh 			; work backwards through table
.3500	85 2f		sta $2f				sta 	zTemp1+1
.3502	64 2e		stz $2e				stz 	zTemp1
.3504					_STRSearch:
.3504	20 3b 35	jsr $353b			jsr 	_STRPrevLine 				; look at previous record.
.3507	a0 01		ldy #$01			ldy 	#1
.3509	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.350b	c5 2c		cmp $2c				cmp 	zTemp0
.350d	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.350f	e5 2d		sbc $2d				sbc 	zTemp0+1
.3511	b0 0b		bcs $351e			bcs 	_STRFound 					; >=
.3513					_STRNext:
.3513	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.3515	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3517	c9 ff		cmp #$ff			cmp 	#$FF
.3519	d0 e9		bne $3504			bne 	_STRSearch
.351b	4c 31 1f	jmp $1f31		jmp	ErrorV_internal
.351e					_STRFound:
.351e	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.3520	45 2c		eor $2c				eor 	zTemp0
.3522	d0 06		bne $352a			bne 	_STRDifferent
.3524	b2 2e		lda ($2e)			lda 	(zTemp1)
.3526	45 2c		eor $2c				eor 	zTemp0
.3528	f0 02		beq $352c			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.352a					_STRDifferent:
.352a	a9 ff		lda #$ff			lda 	#$FF
.352c					_STROut:
.352c	18		clc				clc  								; set carry if different, e.g. > rather than >=
.352d	69 ff		adc #$ff			adc 	#255
.352f	08		php				php
.3530	c8		iny				iny 								; address into YA
.3531	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3533	48		pha				pha
.3534	c8		iny				iny
.3535	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3537	a8		tay				tay
.3538	68		pla				pla
.3539	28		plp				plp
.353a	60		rts				rts
.353b					_STRPrevLine:
.353b	38		sec				sec 								; move backwards one entry.
.353c	a5 2e		lda $2e				lda 	zTemp1
.353e	e9 04		sbc #$04			sbc 	#4
.3540	85 2e		sta $2e				sta 	zTemp1
.3542	a5 2f		lda $2f				lda 	zTemp1+1
.3544	e9 00		sbc #$00			sbc 	#0
.3546	85 2f		sta $2f				sta 	zTemp1+1
.3548	60		rts				rts
.3549					STRMakeOffset:
.3549	18		clc				clc 								; borrow 1
.354a	e5 2a		sbc $2a				sbc 	objPtr
.354c	48		pha				pha
.354d	98		tya				tya
.354e	e5 2b		sbc $2b				sbc 	objPtr+1
.3550	a8		tay				tay
.3551	68		pla				pla
.3552	60		rts				rts
.3553					CommandNEXT:
.3553	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.3556	20 78 33	jsr $3378			jsr 	CharIsAlpha 				; if not alpha , error
.3559	90 0c		bcc $3567			bcc 	_CNNoReferenceGiven
.355b	20 57 33	jsr $3357			jsr 	GetNext
.355e	20 a3 36	jsr $36a3			jsr 	GetReferenceTerm 			; figure out the reference.
.3561	8a		txa				txa 								; reference in YA
.3562	20 01 2b	jsr $2b01			jsr 	PushIntegerYA 				; write it out.
.3565	80 06		bra $356d			bra 	_CNParametersDone
.3567					_CNNoReferenceGiven:
.3567	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.3569	a8		tay				tay
.356a	20 01 2b	jsr $2b01			jsr 	PushIntegerYA 				; write it out.
.356d					_CNParametersDone:
.356d	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.356f	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.3572	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; look for ,
.3575	c9 2c		cmp #$2c			cmp 	#","
.3577	d0 05		bne $357e			bne 	_CNExit
.3579	20 57 33	jsr $3357			jsr 	GetNext 					; consume ,
.357c	80 d5		bra $3553			bra 	CommandNEXT 				; and go round.
.357e					_CNExit:
.357e	60		rts				rts
.357f					CommandON:
.357f	20 62 33	jsr $3362			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.3582	48		pha				pha 								; save on stack
.3583	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.3585	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.3587	f0 09		beq $3592			beq 	_COCreateLoop
.3589	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.358b	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.358d	f0 03		beq $3592			beq 	_COCreateLoop
.358f	4c d7 1e	jmp $1ed7		jmp	ErrorV_syntax
.3592					_COCreateLoop:
.3592	8a		txa				txa 								; compile a goto/gosub somewhere
.3593	da		phx				phx
.3594	20 32 34	jsr $3432			jsr 	CompileBranchCommand
.3597	fa		plx				plx
.3598	20 49 33	jsr $3349			jsr 	LookNextNonSpace			; ',' follows
.359b	c9 2c		cmp #$2c			cmp 	#","
.359d	d0 0a		bne $35a9			bne 	_COComplete 				; if so, more line numbers
.359f	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.35a1	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.35a4	20 57 33	jsr $3357			jsr 	GetNext
.35a7	80 e9		bra $3592			bra 	_COCreateLoop
.35a9					_COComplete:
.35a9	68		pla				pla 								; throw GOTO/GOSUB
.35aa	60		rts				rts
.35ab					ParseConstant:
.35ab	a2 00		ldx #$00			ldx 	#0
.35ad	20 fd 23	jsr $23fd			jsr 	FloatEncodeStart 			; send first
.35b0					_ParseLoop:
.35b0	20 46 33	jsr $3346			jsr 	LookNext 					; send subsequent
.35b3	20 00 24	jsr $2400			jsr 	FloatEncodeContinue
.35b6	90 05		bcc $35bd			bcc 	_ParseDone
.35b8	20 57 33	jsr $3357			jsr 	GetNext 					; consume it
.35bb	80 f3		bra $35b0			bra 	_ParseLoop
.35bd					_ParseDone:
.35bd	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.35bf	29 80		and #$80			and 	#$80
.35c1	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.35c3	15 56		ora $56,x			ora 	NSMantissa2,x
.35c5	15 62		ora $62,x			ora 	NSMantissa3,x
.35c7	18		clc				clc
.35c8	d0 05		bne $35cf			bne 	_ParseExit 					; exit with CC if need float to compile
.35ca	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.35cc	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.35ce	38		sec				sec
.35cf					_ParseExit:
.35cf	60		rts				rts
.35d0					CommandPRINT:
.35d0	20 49 33	jsr $3349			jsr 	LookNextNonSpace			; what follows ?
.35d3	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.35d5	f0 1f		beq $35f6			beq 	_CPCheckEnd
.35d7	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.35d9	f0 16		beq $35f1			beq 	_CPTabCheckEnd
.35db	20 0d 36	jsr $360d			jsr 	_CPAtEnd 					; check for : and EOL
.35de	b0 22		bcs $3602			bcs 	_CPExitCR 					; exit with CR
.35e0	20 02 2d	jsr $2d02			jsr 	CompileExpressionAt0 		; so it is something to print
.35e3	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.35e5	29 40		and #$40			and 	#NSSString 					; if string
.35e7	d0 02		bne $35eb			bne 	_CPOut
.35e9	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.35eb					_CPOut:
.35eb	8a		txa				txa 								; print that thing
.35ec	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.35ef	80 df		bra $35d0			bra 	CommandPRINT 				; and loop round/
.35f1					_CPTabCheckEnd:
.35f1	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.35f3	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.35f6					_CPCheckEnd:
.35f6	20 57 33	jsr $3357			jsr 	GetNext 					; consume it.
.35f9	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; what follows ?
.35fc	20 0d 36	jsr $360d			jsr 	_CPAtEnd 					; reached end
.35ff	90 cf		bcc $35d0			bcc 	CommandPRINT 				; no, loop back
.3601	60		rts				rts
.3602					_CPExitCR:
.3602	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.3604	20 14 2b	jsr $2b14			jsr 	PushIntegerA
.3607	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.3609	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.360c	60		rts				rts
.360d					_CPAtEnd:
.360d	c9 00		cmp #$00			cmp 	#0
.360f	f0 06		beq $3617			beq 	_CPIsEnd
.3611	c9 3a		cmp #$3a			cmp 	#":"
.3613	f0 02		beq $3617			beq 	_CPIsEnd
.3615	18		clc				clc
.3616	60		rts				rts
.3617					_CPIsEnd:
.3617	38		sec				sec
.3618	60		rts				rts
.3619					CommandREAD:
.3619	a2 b2		ldx #$b2			ldx 	#PCD_READ
.361b	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.361d					CommandReadInputCommon:
.361d	8e c5 06	stx $06c5			stx 	numberPCode
.3620	8c c6 06	sty $06c6			sty 	stringPCode
.3623					_CRLoop:
.3623	20 62 33	jsr $3362			jsr 	GetNextNonSpace 			; first char of identifier
.3626	20 78 33	jsr $3378			jsr 	CharIsAlpha 				; check A-Z
.3629	90 27		bcc $3652			bcc 	_CRSyntax
.362b	20 a3 36	jsr $36a3			jsr 	GetReferenceTerm 			; get the variable.
.362e	48		pha				pha 								; save type.
.362f	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.3631	c9 40		cmp #$40			cmp 	#NSSString
.3633	f0 05		beq $363a			beq 	_CRString
.3635	ad c5 06	lda $06c5			lda 	numberPCode 				; output read/input
.3638	80 03		bra $363d			bra 	_CRHaveType
.363a					_CRString:
.363a	ad c6 06	lda $06c6			lda 	stringPCode					; output read$/input$
.363d					_CRHaveType:
.363d	20 ec 29	jsr $29ec			jsr 	WriteCodeByte 				; so we have one typed data item.
.3640	68		pla				pla 								; restore type
.3641	38		sec				sec  								; write update code.
.3642	20 55 36	jsr $3655			jsr 	GetSetVariable
.3645	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; , follows ?
.3648	c9 2c		cmp #$2c			cmp 	#","
.364a	d0 05		bne $3651			bne 	_CRExit 					; if not, end of READ.
.364c	20 57 33	jsr $3357			jsr 	GetNext 					; consume comma
.364f	80 d2		bra $3623			bra 	_CRLoop 					; keep going
.3651					_CRExit:
.3651	60		rts				rts
.3652					_CRSyntax:
.3652	4c d7 1e	jmp $1ed7		jmp	ErrorV_syntax
.06c5					numberPCode:
>06c5							.fill 	1
.06c6					stringPCode:
>06c6							.fill 	1
.3655					GetSetVariable:
.3655	08		php				php 								; save direction on stack
.3656	c0 00		cpy #$00			cpy 	#$00
.3658	30 21		bmi $367b			bmi 	_GSVReadWriteSpecial
.365a	c9 00		cmp #$00			cmp 	#$00
.365c	30 33		bmi $3691			bmi 	_GSVArray
.365e	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.3660	4a		lsr a				lsr 	a 							; divide by 2
.3661	09 40		ora #$40			ora 	#64 						; and set bit 6.
.3663	28		plp				plp
.3664	90 02		bcc $3668			bcc 	_GSVNotWrite
.3666	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.3668					_GSVNotWrite:
.3668	85 2c		sta $2c				sta 	zTemp0
.366a	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.366b	4a		lsr a				lsr 	a
.366c	a8		tay				tay
.366d	8a		txa				txa
.366e	6a		ror a				ror 	a
.366f	aa		tax				tax
.3670	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.3671	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.3673	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.3676	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.3677	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.367a	60		rts				rts
.367b					_GSVReadWriteSpecial:
.367b	28		plp				plp
.367c	b0 10		bcs $368e			bcs 	_GSVSyntax
.367e	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.3680	f0 06		beq $3688			beq 	_GSVRWString
.3682	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.3684	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.3687	60		rts				rts
.3688					_GSVRWString:
.3688	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.368a	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.368d	60		rts				rts
.368e					_GSVSyntax:
.368e	4c d7 1e	jmp $1ed7		jmp	ErrorV_syntax
.3691					_GSVArray:
.3691	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.3693	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.3694	4a		lsr a				lsr 	a
.3695	4a		lsr a				lsr 	a
.3696	4a		lsr a				lsr 	a
.3697	4a		lsr a				lsr 	a
.3698	28		plp				plp 								; if writing array then set bit 2.
.3699	90 02		bcc $369d			bcc 	_GSVANotWrite
.369b	09 04		ora #$04			ora 	#4
.369d					_GSVANotWrite:
.369d	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.369f	20 ec 29	jsr $29ec			jsr 	WriteCodeByte 				; and write it out
.36a2	60		rts				rts
.36a3					GetReferenceTerm:
.36a3	20 c7 33	jsr $33c7			jsr 	ExtractVariableName 		; get name & type info
.36a6	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.36a8	30 10		bmi $36ba			bmi 	_GRTArray
.36aa	da		phx				phx 								; save type on stack
.36ab	20 bc 2d	jsr $2dbc			jsr 	FindVariable 				; find it
.36ae	b0 06		bcs $36b6			bcs 	_GRTNoCreate 				; create if required.
.36b0	20 46 2b	jsr $2b46			jsr 	CreateVariableRecord 		; create a variable.
.36b3	20 9b 2b	jsr $2b9b			jsr 	AllocateBytesForType 		; allocate memory for it
.36b6					_GRTNoCreate:
.36b6	68		pla				pla 								; get type back, strip out type information.
.36b7	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.36b9	60		rts				rts
.36ba					_GRTArray:
.36ba	da		phx				phx 								; save type information
.36bb	20 bc 2d	jsr $2dbc			jsr 	FindVariable 				; read its data, the base address in YX
.36be	90 18		bcc $36d8			bcc 	_GRTUndeclared 				; undeclared array.
.36c0	da		phx				phx 								; save base address
.36c1	5a		phy				phy
.36c2	20 92 2c	jsr $2c92			jsr 	OutputIndexGroup 			; create an index group and generate them
.36c5	7a		ply				ply 								; get the array base address into YX
.36c6	fa		plx				plx
.36c7	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.36c9	18		clc				clc
.36ca	20 55 36	jsr $3655			jsr 	GetSetVariable 				; load the address of the array structure.
.36cd	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.36cf	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.36d2	68		pla				pla 								; and the type data into A
.36d3	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.36d5	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.36d7	60		rts				rts
.36d8					_GRTUndeclared:
.36d8	4c 8e 1f	jmp $1f8e		jmp	ErrorV_undeclared
.36db					CommandREM:
.36db	20 46 33	jsr $3346			jsr 	LookNext
.36de	f0 05		beq $36e5			beq 	_CRExit
.36e0	20 57 33	jsr $3357			jsr 	GetNext
.36e3	80 f6		bra $36db			bra 	CommandREM
.36e5					_CRExit:
.36e5	60		rts				rts
.36e6					STRReset:
.36e6	ad bf 06	lda $06bf			lda	 	compilerStartHigh 			; set up the two table pointers
.36e9	8d ca 06	sta $06ca			sta 	variableListEnd+1
.36ec	9c c9 06	stz $06c9			stz 	variableListEnd
.36ef	ad c0 06	lda $06c0			lda 	compilerEndHigh
.36f2	8d c8 06	sta $06c8			sta 	lineNumberTable+1
.36f5	9c c7 06	stz $06c7			stz 	lineNumberTable
.36f8	ad c9 06	lda $06c9			lda 	variableListEnd
.36fb	85 2d		sta $2d				sta 	zTemp0+1
.36fd	64 2c		stz $2c				stz 	zTemp0
.36ff	a9 00		lda #$00			lda 	#0
.3701	92 2c		sta ($2c)			sta 	(zTemp0)
.3703	a9 00		lda #$00			lda 	#((0) & $FF)
.3705	8d cb 06	sta $06cb			sta 	0+freeVariableMemory
.3708	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.370a	8d cc 06	sta $06cc			sta 	1+freeVariableMemory
.370d	60		rts				rts
.06c7					lineNumberTable:
>06c7							.fill 	2
.06c9					variableListEnd:
>06c9							.fill 	2
.06cb					freeVariableMemory:
>06cb							.fill 	2
.370e					CompileTerm:
.370e	20 62 33	jsr $3362			jsr 	GetNextNonSpace 			; get first non space character.
.3711	30 72		bmi $3785			bmi 	_CTUnaryFunctions
.3713	20 6c 33	jsr $336c			jsr 	CharIsDigit 				; found a number
.3716	b0 3a		bcs $3752			bcs 	_CTDigit
.3718	c9 2e		cmp #$2e			cmp 	#"."
.371a	f0 36		beq $3752			beq 	_CTDigit
.371c	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.371e	f0 43		beq $3763			beq 	_CTString
.3720	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.3722	f0 28		beq $374c			beq 	_CTOtherBase
.3724	c9 24		cmp #$24			cmp 	#"$"
.3726	f0 24		beq $374c			beq 	_CTOtherBase
.3728	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.372a	f0 17		beq $3743			beq 	_CTBrackets
.372c	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.372e	90 10		bcc $3740			bcc 	_CTSyntax
.3730	c9 5b		cmp #$5b			cmp 	#"Z"+1
.3732	b0 0c		bcs $3740			bcs 	_CTSyntax
.3734	20 a3 36	jsr $36a3			jsr 	GetReferenceTerm 			; figure out what it is.
.3737	48		pha				pha 								; save type on stack
.3738	18		clc				clc 								; read it
.3739	20 55 36	jsr $3655			jsr 	GetSetVariable
.373c	68		pla				pla
.373d	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.373f	60		rts				rts
.3740					_CTSyntax:
.3740	4c d7 1e	jmp $1ed7		jmp	ErrorV_syntax
.3743					_CTBrackets:
.3743	20 02 2d	jsr $2d02			jsr 	CompileExpressionAt0
.3746	48		pha				pha
.3747	20 4e 2a	jsr $2a4e			jsr 	CheckNextRParen
.374a	68		pla				pla
.374b	60		rts				rts
.374c					_CTOtherBase:
.374c	20 9a 29	jsr $299a			jsr 	InlineNonDecimal 			; non decimal constant handler
.374f	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.3751	60		rts				rts
.3752					_CTDigit:
.3752	20 ab 35	jsr $35ab			jsr 	ParseConstant 				; parse out an number, first is in A already.
.3755	90 06		bcc $375d			bcc	 	_CTFloat 					; have a float or long int.
.3757	20 01 2b	jsr $2b01			jsr 	PushIntegerYA 				; code to push on stack
.375a	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.375c	60		rts				rts
.375d					_CTFloat:
.375d	20 23 2b	jsr $2b23			jsr 	PushFloatCommand			; code to push float
.3760	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.3762	60		rts				rts
.3763					_CTString:
.3763	20 23 2a	jsr $2a23			jsr 	BufferClear 				; copy it to the buffer
.3766					_CTStringLoop:
.3766	20 46 33	jsr $3346			jsr 	LookNext 					; reached EOL/EOS
.3769	f0 d5		beq $3740			beq 	_CTSyntax
.376b	c9 22		cmp #$22			cmp 	#'"'
.376d	f0 08		beq $3777			beq 	_CTStringDone
.376f	20 27 2a	jsr $2a27			jsr 	BufferWrite 				; write and consume
.3772	20 57 33	jsr $3357			jsr 	GetNext
.3775	80 ef		bra $3766			bra 	_CTStringLoop
.3777					_CTStringDone:
.3777	20 57 33	jsr $3357			jsr 	GetNext 					; consume closing quote.
.377a	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.377c	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.377f	20 33 2a	jsr $2a33			jsr 	BufferOutput
.3782	a9 40		lda #$40			lda 	#NSSString 					; string type
.3784	60		rts				rts
.3785					_CTUnaryFunctions:
.3785	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.3787	f0 0a		beq $3793			beq 	_CTNegation
.3789	a2 ee		ldx #$ee			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.378b	a0 30		ldy #$30			ldy 	#UnaryTables >> 8
.378d	20 e8 31	jsr $31e8			jsr 	GeneratorProcess
.3790	90 ae		bcc $3740			bcc		_CTSyntax
.3792	60		rts				rts
.3793					_CTNegation:
.3793	20 0e 37	jsr $370e			jsr 	CompileTerm 				; compile a term.
.3796	48		pha				pha
.3797	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.3799	c9 00		cmp #$00			cmp 	#NSSIFloat
.379b	d0 07		bne $37a4			bne 	_CTType 					; error
.379d	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.379f	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.37a2	68		pla				pla 								; return original type.
.37a3	60		rts				rts
.37a4					_CTType:
.37a4	4c e7 1e	jmp $1ee7		jmp	ErrorV_type
.37a7					CommandWAIT:
.37a7	20 49 33	jsr $3349			jsr 	LookNextNonSpace
.37aa	c9 2c		cmp #$2c			cmp 	#","
.37ac	f0 10		beq $37be			beq 	_CWThirdParameter
.37ae	a9 00		lda #$00			lda 	#0
.37b0	20 14 2b	jsr $2b14			jsr 	PushIntegerA
.37b3					_CWExit:
.37b3	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.37b5	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.37b8	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.37ba	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.37bd	60		rts				rts
.37be					_CWThirdParameter:
.37be	20 57 33	jsr $3357			jsr 	GetNext
.37c1	20 04 2d	jsr $2d04			jsr 	CompileExpressionAtA
.37c4	29 40		and #$40			and 	#NSSTypeMask
.37c6	c9 00		cmp #$00			cmp 	#NSSIFloat
.37c8	f0 e9		beq $37b3			beq 	_CWExit
.37ca	4c e7 1e	jmp $1ee7		jmp	ErrorV_type
.37cd					CommandCMD:
.37cd	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.37cf	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.37d2	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; followed by a , ?
.37d5	c9 2c		cmp #$2c			cmp 	#","
.37d7	d0 06		bne $37df			bne 	_CCMDExit
.37d9	20 57 33	jsr $3357			jsr 	GetNext 					; consume comma.
.37dc	20 d0 35	jsr $35d0			jsr 	CommandPRINT 				; do the print code
.37df					_CCMDExit:
.37df	60		rts				rts
.37e0					CommandOPEN:
.37e0	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; followed by a , ?
.37e3	c9 2c		cmp #$2c			cmp 	#","
.37e5	d0 15		bne $37fc			bne 	_COTwoDefaults
.37e7	20 57 33	jsr $3357			jsr 	GetNext 					; consume comma
.37ea	20 02 2d	jsr $2d02			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.37ed	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.37ef	f0 1e		beq $380f			beq 	_COThreeIntegers
.37f1	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.37f3	20 14 2b	jsr $2b14			jsr 	PushIntegerA
.37f6	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.37f8	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.37fb	60		rts				rts
.37fc					_COTwoDefaults:
.37fc	a9 00		lda #$00			lda 	#0
.37fe	20 14 2b	jsr $2b14			jsr 	PushIntegerA
.3801					_COCompileNullString:
.3801	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.3803	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.3806	a9 00		lda #$00			lda 	#0
.3808	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.380b	20 ec 29	jsr $29ec			jsr 	WriteCodeByte
.380e	60		rts				rts
.380f					_COThreeIntegers:
.380f	20 49 33	jsr $3349			jsr 	LookNextNonSpace 			; is there a ,
.3812	c9 2c		cmp #$2c			cmp 	#","
.3814	d0 eb		bne $3801			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.3816	20 57 33	jsr $3357			jsr 	GetNext
.3819	20 02 2d	jsr $2d02			jsr 	CompileExpressionAt0 		; should be a filename
.381c	29 40		and #$40			and 	#NSSString
.381e	f0 01		beq $3821			beq 	_COType
.3820	60		rts				rts
.3821					_COType:
.3821	4c e7 1e	jmp $1ee7		jmp	ErrorV_type

;******  Processing input file: _library.asm


;******  Processing input file: source/main/zzfree.footer

.3824					FreeMemory:

;******  End of listing
