
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl source/main/00main.header /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library _library.asm source/main/zzfree.footer
; Mon Oct  9 06:43:07 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: source/main/00main.header

.0801					StartBasicProgram:
>0801	0c 08						.word 	$080C 						; offset to next.
>0803	0a 00						.word 	10 							; line #
>0805	9e						.byte 	$9E 						; token for 'SYS'
>0806	20 32 30 36 32					.text 	' 2062'						; space, $080E in decimal
>080b	00						.byte  	0 							; end of line
>080c	00 00						.word 	0 							; end of program
.080e					StartCode:
.080e	4c 8d 38	jmp $388d			jmp 	CompileCode 				; to starting the runtime in the saved code.
.0811	a9 39		lda #$39			lda 	#FreeMemory >> 8 			; address of object code to run.
.0813	a2 80		ldx #$80			ldx 	#$80 						; 8000-9EFF is used for workspace.
.0815	a0 9f		ldy #$9f			ldy 	#$9F
.0817	4c 1a 08	jmp $081a			jmp 	StartRuntime 				; and go do it !

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.081a					StartRuntime:
.081a	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.081d	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.081f	64 28		stz $28				stz 	codePtr
.0821	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0824	8c 06 04	sty $0406			sty 	storeEndHigh
.0827	8e 07 04	stx $0407			stx 	variableStartPage
.082a	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.082c	a2 34		ldx #$34			ldx 	#RuntimeErrorHandler & $FF
.082e	20 bb 1e	jsr $1ebb			jsr 	SetErrorHandler
.0831	20 63 0a	jsr $0a63			jsr 	ClearMemory 				; clear memory.
.0834	20 42 16	jsr $1642			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0837	20 44 13	jsr $1344		 	jsr		SetDefaultChannel			; set default input/output channel.
.083a	20 7a 15	jsr $157a			jsr 	RestoreCode 				; which we now call
.083d	a0 00		ldy #$00			ldy 	#0
.083f					NextCommand:
.083f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.0841	30 5b		bmi $089e			bmi 	NXCommand 					; -if -ve command
.0843	c8		iny				iny
.0844	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0846	90 39		bcc $0881			bcc 	PushByteA 					; 0..63 is short constants.
.0848					NXLoadStore:
.0848	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.084a	b0 19		bcs $0865			bcs 	NXIndirectLoadStore
.084c	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.084d	4a		lsr a				lsr 	a
.084e	29 0e		and #$0e			and 	#$0E
.0850	da		phx				phx 								; get ready to jump
.0851	aa		tax				tax
.0852	7c 55 08	jmp ($0855,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.0855					ReadWriteVectors:
>0855	b0 14						.word 	ReadFloatCommand			; read float
>0857	8b 1a						.word 	WriteFloatCommand 			; write float
>0859	ec 14						.word 	ReadIntegerCommand 			; read integer
>085b	c7 1a						.word 	WriteIntegerCommand 		; write integer
>085d	31 15						.word 	ReadStringCommand 			; read string
>085f	06 1b						.word 	WriteStringCommand 			; write string
>0861	31 0c						.word 	Unimplemented
>0863	31 0c						.word 	Unimplemented
.0865					NXIndirectLoadStore:
.0865	29 07		and #$07			and 	#7
.0867	0a		asl a				asl 	a
.0868	da		phx				phx
.0869	aa		tax				tax
.086a	7c 6d 08	jmp ($086d,x)			jmp 	(IndirectVectors,x)
.086d					IndirectVectors:
>086d	e6 0e						.word 	IndFloatRead 				; float read
>086f	fa 0e						.word 	IndInt16Read 				; int16 read
>0871	0e 0f						.word 	IndStringRead 				; string read
>0873	31 0c						.word 	Unimplemented
>0875	22 0f						.word 	IndFloatWrite				; float write
>0877	36 0f						.word 	IndInt16Write 				; int16 write
>0879	4a 0f						.word 	IndStringWrite 				; string write
>087b	31 0c						.word 	Unimplemented
.087d					PushByteCommand:
.087d	fa		plx				plx
.087e	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.0880	c8		iny				iny
.0881					PushByteA:
.0881	e8		inx				inx 								; push constant on stack
.0882	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.0884	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.0886					ClearRestWord:
.0886	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.0888	74 62		stz $62,x			stz 	NSMantissa3,x
.088a	74 6e		stz $6e,x			stz 	NSExponent,x
.088c	74 32		stz $32,x			stz 	NSStatus,x
.088e	80 af		bra $083f			bra 	NextCommand
.0890					PushWordCommand:
.0890	fa		plx				plx
.0891	e8		inx				inx
.0892	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.0894	c8		iny				iny
.0895	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0897	b1 28		lda ($28),y			lda 	(codePtr),y
.0899	c8		iny				iny
.089a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.089c	80 e8		bra $0886			bra 	ClearRestWord 				; handle everything else.
.089e					NXCommand:
.089e	c8		iny				iny 								; consume command.
.089f	10 03		bpl $08a4			bpl 	_NXCommandNoFixUp
.08a1	20 aa 08	jsr $08aa			jsr 	FixUpY
.08a4					_NXCommandNoFixUp:
.08a4	0a		asl a				asl 	a 							; shift left
.08a5	da		phx				phx 								; save SP on stack
.08a6	aa		tax				tax				 					; and jump indirect
.08a7	7c 6c 19	jmp ($196c,x)			jmp 	(VectorTable,x)
.08aa					FixUpY:
.08aa	48		pha				pha
.08ab	98		tya				tya
.08ac	18		clc				clc
.08ad	65 28		adc $28				adc 	codePtr
.08af	85 28		sta $28				sta 	codePtr
.08b1	90 02		bcc $08b5			bcc 	_NoCPCarry
.08b3	e6 29		inc $29				inc 	codePtr+1
.08b5					_NoCPCarry:
.08b5	a0 00		ldy #$00			ldy 	#0
.08b7	68		pla				pla
.08b8	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.08b9					AbsoluteTOS:
.08b9	fa		plx				plx
.08ba	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08bc	4c 3f 08	jmp $083f			jmp 	NextCommand
.08bf					CommandVarSpace:
.08bf	fa		plx				plx
.08c0	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08c2	85 26		sta $26				sta 	availableMemory
.08c4	c8		iny				iny
.08c5	b1 28		lda ($28),y			lda 	(codePtr),y
.08c7	18		clc				clc
.08c8	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08cb	85 27		sta $27				sta 	availableMemory+1
.08cd	c8		iny				iny
.08ce	4c 3f 08	jmp $083f			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08d1					BinaryAnd:
.08d1	fa		plx				plx
.08d2	38		sec				sec
.08d3	80 02		bra $08d7			bra 	AndOrCommon
.08d5					BinaryOr:
.08d5	fa		plx				plx
.08d6	18		clc				clc
.08d7					AndOrCommon:
.08d7	08		php				php 								; save AND/OR flag
.08d8	20 21 10	jsr $1021			jsr 	GetInteger16Bit
.08db	ca		dex				dex
.08dc	20 21 10	jsr $1021			jsr 	GetInteger16Bit
.08df	28		plp				plp
.08e0	90 0e		bcc $08f0			bcc 	_AOCOrCode
.08e2	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.08e4	35 3f		and $3f,x			and		NSMantissa0+1,x
.08e6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08e8	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.08ea	35 4b		and $4b,x			and		NSMantissa1+1,x
.08ec	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08ee	80 0c		bra $08fc			bra 	_AOCComplete
.08f0					_AOCOrCode:
.08f0	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.08f2	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.08f4	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08f6	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.08f8	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.08fa	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08fc					_AOCComplete:
.08fc	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.08fe	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.0900	10 07		bpl $0909			bpl 	_AOCExit
.0902	20 31 10	jsr $1031			jsr 	Negate16Bit 				; 2's complement
.0905	a9 80		lda #$80			lda 	#$80 						; make it -ve
.0907	95 32		sta $32,x			sta 	NSStatus,x
.0909					_AOCExit:
.0909	4c 3f 08	jmp $083f			jmp 	NextCommand
.090c					ArrayConvert:
.090c	fa		plx				plx
.090d	5a		phy				phy
.090e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0910	85 2e		sta $2e				sta 	zTemp1
.0912	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0914	18		clc				clc
.0915	6d 07 04	adc $0407			adc 	variableStartPage
.0918	85 2f		sta $2f				sta 	zTemp1+1
.091a	ca		dex				dex 								; count of indices to follow -> zTemp2
.091b	20 1b 10	jsr $101b			jsr 	GetInteger8Bit
.091e	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.0920	8a		txa				txa
.0921	38		sec				sec
.0922	e5 30		sbc $30				sbc 	zTemp2
.0924	aa		tax				tax
.0925	da		phx				phx 								; stack points at the first index, which will be replaced.
.0926					_ACIndexLoop:
.0926	20 63 22	jsr $2263			jsr 	FloatIntegerPart 			; integer array index
.0929	20 21 10	jsr $1021			jsr 	GetInteger16Bit 			; get the index => zTemp0
.092c	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.092e	a5 2c		lda $2c				lda 	zTemp0
.0930	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0932	a5 2d		lda $2d				lda 	zTemp0+1
.0934	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0936	b0 79		bcs $09b1			bcs 	_ACBadIndex 				; index error.
.0938	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.093a	f0 29		beq $0965			beq 	_ACInnerLevel
.093c	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.093e	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0940	10 6f		bpl $09b1			bpl 	_ACBadIndex
.0942	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0944	26 2d		rol $2d				rol 	zTemp0+1
.0946	18		clc				clc
.0947	a5 2c		lda $2c				lda		zTemp0
.0949	65 2e		adc $2e				adc 	zTemp1
.094b	85 2c		sta $2c				sta 	zTemp0
.094d	a5 2d		lda $2d				lda		zTemp0+1
.094f	65 2f		adc $2f				adc 	zTemp1+1
.0951	85 2d		sta $2d				sta 	zTemp0+1
.0953	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.0955	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0957	85 2e		sta $2e				sta 	zTemp1
.0959	c8		iny				iny
.095a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.095c	18		clc				clc
.095d	6d 07 04	adc $0407			adc 	variableStartPage
.0960	85 2f		sta $2f				sta 	zTemp1+1
.0962	e8		inx				inx 								; next index
.0963	80 c1		bra $0926			bra 	_ACIndexLoop
.0965					_ACInnerLevel:
.0965	a0 02		ldy #$02			ldy 	#2
.0967	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0969	30 46		bmi $09b1			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.096b	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.096d	c9 00		cmp #$00			cmp 	#NSSIFloat
.096f	d0 13		bne $0984			bne 	_ACNotFloat
.0971	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.0973	48		pha				pha
.0974	a5 2c		lda $2c				lda 	zTemp0
.0976	06 2c		asl $2c				asl 	zTemp0 						; x 2
.0978	26 2d		rol $2d				rol 	zTemp0+1
.097a	18		clc				clc 								; add back x 3
.097b	65 2c		adc $2c				adc 	zTemp0
.097d	85 2c		sta $2c				sta 	zTemp0
.097f	68		pla				pla
.0980	65 2d		adc $2d				adc 	zTemp0+1
.0982	85 2d		sta $2d				sta 	zTemp0+1
.0984					_ACNotFloat:
.0984	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.0986	26 2d		rol $2d				rol 	zTemp0+1
.0988	18		clc				clc
.0989	a5 2c		lda $2c				lda 	zTemp0
.098b	69 03		adc #$03			adc 	#3
.098d	85 2c		sta $2c				sta 	zTemp0
.098f	90 02		bcc $0993			bcc 	_ACNoCarry
.0991	e6 2d		inc $2d				inc 	zTemp0+1
.0993					_ACNoCarry:
.0993	fa		plx				plx 								; X points to first slot of array parameters
.0994	18		clc				clc
.0995	a5 2c		lda $2c				lda 	zTemp0
.0997	65 2e		adc $2e				adc 	zTemp1
.0999	95 3e		sta $3e,x			sta 	NSMantissa0,x
.099b	a5 2d		lda $2d				lda 	zTemp0+1
.099d	65 2f		adc $2f				adc 	zTemp1+1
.099f	38		sec				sec
.09a0	ed 07 04	sbc $0407			sbc 	variableStartPage
.09a3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.09a5	74 56		stz $56,x			stz 	NSMantissa2,x
.09a7	74 62		stz $62,x			stz 	NSMantissa3,x
.09a9	74 32		stz $32,x			stz 	NSStatus,x
.09ab	74 6e		stz $6e,x			stz 	NSExponent,x
.09ad	7a		ply				ply 	 							; restore code pointer
.09ae	4c 3f 08	jmp $083f			jmp 	NextCommand
.09b1					_ACBadIndex:
.09b1	4c bd 1f	jmp $1fbd		jmp	ErrorV_index
.09b4					UnaryAsc:
.09b4	fa		plx				plx
.09b5	5a		phy				phy
.09b6	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09b8	85 2c		sta $2c				sta 	zTemp0
.09ba	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09bc	85 2d		sta $2d				sta 	zTemp0+1
.09be	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09c0	f0 06		beq $09c8			beq 	_UAExit
.09c2	5a		phy				phy 								; otherwise first character
.09c3	a0 01		ldy #$01			ldy 	#1
.09c5	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09c7	7a		ply				ply
.09c8					_UAExit:
.09c8	20 2a 26	jsr $262a			jsr 	FloatSetByte
.09cb	7a		ply				ply
.09cc	4c 3f 08	jmp $083f			jmp 	NextCommand
.09cf					CommandAssert:
.09cf	fa		plx				plx
.09d0	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09d2	d0 09		bne $09dd			bne 	_CAFail
.09d4	20 4a 26	jsr $264a			jsr 	FloatIsZero 				; is it zero ?
.09d7	f0 04		beq $09dd			beq 	_CAFail
.09d9	ca		dex				dex
.09da	4c 3f 08	jmp $083f			jmp 	NextCommand
.09dd					_CAFail:
.09dd	4c 16 1f	jmp $1f16		jmp	ErrorV_assert
.09e0					X16_Audio_Parameters8_16:
.09e0	20 e6 09	jsr $09e6			jsr 	X16_Audio_Parameters8_8
.09e3	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.09e5	60		rts				rts
.09e6					X16_Audio_Parameters8_8:
.09e6	a2 01		ldx #$01			ldx 	#1
.09e8	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.09eb	ca		dex				dex
.09ec	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.09ef	20 1b 10	jsr $101b			jsr 	GetInteger8Bit
.09f2	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.09f4	a0 00		ldy #$00			ldy 	#0
.09f6	60		rts				rts
.09f7					X16_Audio_Parameters8_String:
.09f7	20 e0 09	jsr $09e0			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.09fa	da		phx				phx 								; set the voice
.09fb	5a		phy				phy
.09fc	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.09ff	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>0a02	0a						.byte 	X16_AudioCodeBank
.0a03	7a		ply				ply
.0a04	fa		plx				plx
.0a05	86 2c		stx $2c				stx 	zTemp0
.0a07	84 2d		sty $2d				sty 	zTemp0+1
.0a09	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a0b	e8		inx				inx 								; point YX to first character.
.0a0c	d0 01		bne $0a0f			bne 	_X16APSSkip
.0a0e	c8		iny				iny
.0a0f					_X16APSSkip:
.0a0f	60		rts				rts
.0a10					Unary16Bin:
.0a10	fa		plx				plx
.0a11	20 21 10	jsr $1021			jsr 	GetInteger16Bit				; 16 bit int
.0a14	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a16	20 eb 16	jsr $16eb			jsr 	StringAllocTemp
.0a19	a5 2d		lda $2d				lda 	zTemp0+1
.0a1b	f0 03		beq $0a20			beq 	_UBNoHigh
.0a1d	20 28 0a	jsr $0a28			jsr 	_UBWriteBinary
.0a20					_UBNoHigh:
.0a20	a5 2c		lda $2c				lda 	zTemp0
.0a22	20 28 0a	jsr $0a28			jsr 	_UBWriteBinary
.0a25	4c 3f 08	jmp $083f			jmp 	NextCommand
.0a28					_UBWriteBinary:
.0a28	5a		phy				phy
.0a29	a0 08		ldy #$08			ldy 	#8
.0a2b					_UBWLoop:
.0a2b	0a		asl a				asl 	a
.0a2c	48		pha				pha
.0a2d	a9 00		lda #$00			lda  	#0
.0a2f	69 30		adc #$30			adc 	#48
.0a31	20 14 17	jsr $1714			jsr 	StringWriteChar
.0a34	68		pla				pla
.0a35	88		dey				dey
.0a36	d0 f3		bne $0a2b			bne 	_UBWLoop
.0a38	7a		ply				ply
.0a39	60		rts				rts
.0a3a					PrintCharacterX:
.0a3a	fa		plx				plx
.0a3b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a3d	ca		dex				dex
.0a3e	20 48 13	jsr $1348			jsr 	VectorPrintCharacter
.0a41	4c 3f 08	jmp $083f			jmp 	NextCommand
.0a44					UnaryChr:
.0a44	fa		plx				plx
.0a45	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; get integer to convert.
.0a48	48		pha				pha 								; save it and allocate for it
.0a49	a9 01		lda #$01			lda 	#1 							; 1 character
.0a4b	20 eb 16	jsr $16eb			jsr 	StringAllocTemp
.0a4e	a9 01		lda #$01			lda 	#1 							; length 1.
.0a50	92 22		sta ($22)			sta 	(zsTemp)
.0a52	68		pla				pla 								; character code makes string.
.0a53	5a		phy				phy
.0a54	a0 01		ldy #$01			ldy 	#1
.0a56	91 22		sta ($22),y			sta 	(zsTemp),y
.0a58	7a		ply				ply
.0a59	4c 3f 08	jmp $083f			jmp 	NextCommand
.0a5c					CommandClr:
.0a5c	fa		plx				plx
.0a5d	20 63 0a	jsr $0a63			jsr 	ClearMemory
.0a60	4c 3f 08	jmp $083f			jmp 	NextCommand
.0a63					ClearMemory:
.0a63	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a66	85 2d		sta $2d				sta 	zTemp0+1
.0a68	64 2c		stz $2c				stz 	zTemp0
.0a6a	5a		phy				phy
.0a6b	a0 00		ldy #$00			ldy 	#0
.0a6d					_ClearLoop1:
.0a6d	a9 00		lda #$00			lda 	#0
.0a6f	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a71	c8		iny				iny
.0a72	d0 f9		bne $0a6d			bne 	_ClearLoop1
.0a74	e6 2d		inc $2d				inc 	zTemp0+1
.0a76	a5 2d		lda $2d				lda 	zTemp0+1
.0a78	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a7b	d0 f0		bne $0a6d			bne 	_ClearLoop1
.0a7d	38		sec				sec 											; stack space = number of pages in total / 4
.0a7e	ad 06 04	lda $0406			lda 	storeEndHigh
.0a81	ed 05 04	sbc $0405			sbc		storeStartHigh
.0a84	4a		lsr a				lsr 	a
.0a85	4a		lsr a				lsr 	a
.0a86	d0 02		bne $0a8a			bne 	_NotEmpty 								; at least 1 !
.0a88	a9 01		lda #$01			lda 	#1
.0a8a					_NotEmpty:
.0a8a	38		sec				sec 											; subtract from high to give string high memory
.0a8b	49 ff		eor #$ff			eor 	#$FF
.0a8d	6d 06 04	adc $0406			adc 	storeEndHigh
.0a90	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0a93	9c 02 04	stz $0402			stz 	stringHighMemory
.0a96	9c 68 05	stz $0568			stz 	stringInitialised 						; string system not initialised
.0a99	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0a9c	3a		dec a				dec 	a
.0a9d	85 25		sta $25				sta 	runtimeStackPtr+1
.0a9f	a9 ff		lda #$ff			lda 	#$FF
.0aa1	85 24		sta $24				sta 	runtimeStackPtr
.0aa3	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0aa5	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0aa7	7a		ply				ply
.0aa8	60		rts				rts
.0aa9					CompareStrings:
.0aa9	fa		plx				plx
.0aaa	ca		dex				dex
.0aab	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0aad	85 2c		sta $2c				sta 	zTemp0
.0aaf	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ab1	85 2d		sta $2d				sta 	zTemp0+1
.0ab3	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0ab5	85 2e		sta $2e				sta 	zTemp1
.0ab7	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0ab9	85 2f		sta $2f				sta 	zTemp1+1
.0abb	da		phx				phx
.0abc	5a		phy				phy
.0abd	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0abf	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0ac1	90 02		bcc $0ac5			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0ac3	b2 2e		lda ($2e)			lda 	(zTemp1)
.0ac5					_CSNIsSmallest:
.0ac5	aa		tax				tax 								; count in X
.0ac6	f0 0c		beq $0ad4			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0ac8	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0aca					_CSNCompareString:
.0aca	c8		iny				iny 								; pre increment
.0acb	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0acd	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0acf	d0 0a		bne $0adb			bne 	_CSNDifferent 				; numbers are different.
.0ad1	ca		dex				dex
.0ad2	d0 f6		bne $0aca			bne 	_CSNCompareString 			; compare common characters in two strings.
.0ad4					_CSNMatches:
.0ad4	38		sec				sec
.0ad5	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0ad7	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0ad9	f0 06		beq $0ae1			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0adb					_CSNDifferent:
.0adb	a9 ff		lda #$ff			lda 	#$FF
.0add	90 02		bcc $0ae1			bcc 	_CSNSExit
.0adf	a9 01		lda #$01			lda 	#$01
.0ae1					_CSNSExit:
.0ae1	7a		ply				ply
.0ae2	fa		plx				plx
.0ae3	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0ae5	20 2a 26	jsr $262a			jsr 	FloatSetByte 				; output the byte
.0ae8	4c 3f 08	jmp $083f			jmp 	NextCommand
.0aeb					StringConcrete:
.0aeb	9c 68 05	stz $0568			stz 	stringInitialised	 		; initialise next usage
.0aee	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0af0	85 30		sta $30				sta 	zTemp2
.0af2	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0af4	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0af5	18		clc				clc
.0af6	72 30		adc ($30)			adc 	(zTemp2)
.0af8	90 02		bcc $0afc			bcc 	_SCNoOverflow
.0afa	a9 ff		lda #$ff			lda 	#255
.0afc					_SCNoOverflow:
.0afc	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0afe	b0 02		bcs $0b02			bcs 	_SCNoMinimum
.0b00	a9 0a		lda #$0a			lda 	#10
.0b02					_SCNoMinimum:
.0b02	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0b04	38		sec				sec
.0b05	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0b08	e5 2e		sbc $2e				sbc 	zTemp1
.0b0a	a8		tay				tay
.0b0b	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b0e	e9 00		sbc #$00			sbc 	#0
.0b10	48		pha				pha
.0b11	38		sec				sec 								; subtract 3 more
.0b12	98		tya				tya
.0b13	e9 03		sbc #$03			sbc 	#3
.0b15	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b18	85 22		sta $22				sta 	zsTemp
.0b1a	68		pla				pla
.0b1b	e9 00		sbc #$00			sbc 	#0
.0b1d	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b20	85 23		sta $23				sta 	zsTemp+1
.0b22	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b24	92 22		sta ($22)			sta 	(zsTemp)
.0b26	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b28	a9 00		lda #$00			lda 	#0
.0b2a	91 22		sta ($22),y			sta 	(zsTemp),y
.0b2c	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b2e	a4 23		ldy $23				ldy 	zsTemp+1
.0b30	60		rts				rts
.0b31					CommandXData:
.0b31	fa		plx				plx
.0b32	98		tya				tya 								; data length +1 added to Y
.0b33	38		sec				sec
.0b34	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b36	a8		tay				tay
.0b37	4c 3f 08	jmp $083f			jmp 	NextCommand
.0b3a					CommandXDIM:
.0b3a	fa		plx				plx
.0b3b	5a		phy				phy
.0b3c	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b3f	8d 08 04	sta $0408			sta 	dimType
.0b42	ca		dex				dex 								; this is the number of indices
.0b43	20 1b 10	jsr $101b			jsr 	GetInteger8Bit
.0b46	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b48	8a		txa				txa 								; dimension.
.0b49	38		sec				sec
.0b4a	e5 2e		sbc $2e				sbc 	zTemp1
.0b4c	aa		tax				tax
.0b4d	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b4f	20 63 0b	jsr $0b63			jsr 	DIMCreateOneLevel 			; create one at this level
.0b52	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b54	98		tya				tya
.0b55	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b57	74 56		stz $56,x			stz 	NSMantissa2,x
.0b59	74 62		stz $62,x			stz 	NSMantissa3,x
.0b5b	74 32		stz $32,x			stz 	NSStatus,x
.0b5d	74 6e		stz $6e,x			stz 	NSExponent,x
.0b5f	7a		ply				ply
.0b60	4c 3f 08	jmp $083f			jmp 	NextCommand
.0b63					DIMCreateOneLevel:
.0b63	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b65	5a		phy				phy
.0b66	a4 27		ldy $27				ldy 	availableMemory+1
.0b68	5a		phy				phy
.0b69	a8		tay				tay 			 					; save current level into Y
.0b6a	20 21 10	jsr $1021			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b6d	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b6f	d0 02		bne $0b73			bne 	_DCOLNoCarry
.0b71	e6 2d		inc $2d				inc 	zTemp0+1
.0b73					_DCOLNoCarry:
.0b73	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b75	20 16 0c	jsr $0c16			jsr 	DIMWriteByte
.0b78	a5 2d		lda $2d				lda 	zTemp0+1
.0b7a	20 16 0c	jsr $0c16			jsr 	DIMWriteByte
.0b7d	ad 08 04	lda $0408			lda 	dimType 					; get type information
.0b80	29 7f		and #$7f			and 	#$7F
.0b82	c0 01		cpy #$01			cpy 	#1
.0b84	f0 02		beq $0b88			beq 	_DCOLNoSubLevel
.0b86	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0b88					_DCOLNoSubLevel:
.0b88	20 16 0c	jsr $0c16			jsr 	DIMWriteByte
.0b8b	a5 26		lda $26				lda 	availableMemory
.0b8d	85 2e		sta $2e				sta 	zTemp1
.0b8f	a5 27		lda $27				lda 	availableMemory+1
.0b91	85 2f		sta $2f				sta 	zTemp1+1
.0b93	a5 2c		lda $2c				lda 	zTemp0
.0b95	85 30		sta $30				sta 	zTemp2
.0b97	a5 2d		lda $2d				lda 	zTemp0+1
.0b99	85 31		sta $31				sta 	zTemp2+1
.0b9b					_DCOLFillArray:
.0b9b	20 fa 0b	jsr $0bfa			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0b9e	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0ba0	d0 02		bne $0ba4			bne 	_DCOLNoBorrow
.0ba2	c6 2d		dec $2d				dec 	zTemp0+1
.0ba4					_DCOLNoBorrow:
.0ba4	c6 2c		dec $2c				dec 	zTemp0
.0ba6	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0ba8	05 2d		ora $2d				ora 	zTemp0+1
.0baa	d0 ef		bne $0b9b			bne 	_DCOLFillArray
.0bac	c0 01		cpy #$01			cpy 	#1
.0bae	f0 42		beq $0bf2			beq 	_DCOLExit
.0bb0					_DCOLRecursionLoop:
.0bb0	da		phx				phx 								; save XY
.0bb1	5a		phy				phy
.0bb2	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0bb4	48		pha				pha
.0bb5	a5 2f		lda $2f				lda 	zTemp1+1
.0bb7	48		pha				pha
.0bb8	a5 30		lda $30				lda 	zTemp2
.0bba	48		pha				pha
.0bbb	a5 31		lda $31				lda 	zTemp2+1
.0bbd	48		pha				pha
.0bbe	88		dey				dey  								; lower level -> A
.0bbf	98		tya				tya
.0bc0	e8		inx				inx 								; next index size
.0bc1	20 63 0b	jsr $0b63			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0bc4	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0bc5	86 31		stx $31				stx 	zTemp2+1
.0bc7	fa		plx				plx
.0bc8	86 30		stx $30				stx 	zTemp2
.0bca	fa		plx				plx
.0bcb	86 2f		stx $2f				stx 	zTemp1+1
.0bcd	fa		plx				plx
.0bce	86 2e		stx $2e				stx 	zTemp1
.0bd0	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0bd2	98		tya				tya
.0bd3	a0 01		ldy #$01			ldy 	#1
.0bd5	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0bd7	7a		ply				ply 								; restore XY
.0bd8	fa		plx				plx
.0bd9	18		clc				clc
.0bda	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0bdc	69 02		adc #$02			adc 	#2
.0bde	85 2e		sta $2e				sta 	zTemp1
.0be0	90 02		bcc $0be4			bcc 	_DCOLRNoCarry
.0be2	e6 2f		inc $2f				inc 	zTemp1+1
.0be4					_DCOLRNoCarry:
.0be4	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0be6	d0 02		bne $0bea			bne 	_DCOLRNoBorrow
.0be8	c6 31		dec $31				dec 	zTemp2+1
.0bea					_DCOLRNoBorrow:
.0bea	c6 30		dec $30				dec 	zTemp2
.0bec	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0bee	05 31		ora $31				ora 	zTemp2+1
.0bf0	d0 be		bne $0bb0			bne 	_DCOLRecursionLoop
.0bf2					_DCOLExit:
.0bf2	68		pla				pla 								; get MSB, make offset again
.0bf3	38		sec				sec
.0bf4	ed 07 04	sbc $0407			sbc 	variableStartPage
.0bf7	a8		tay				tay
.0bf8	68		pla				pla 								; YA now contains offset address.
.0bf9	60		rts				rts
.0bfa					DIMWriteElement:
.0bfa	da		phx				phx
.0bfb	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0bfd	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0bff	d0 0b		bne $0c0c			bne 	_DIMWENotFloat
.0c01	ad 08 04	lda $0408			lda 	dimType
.0c04	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0c06	c9 00		cmp #$00			cmp 	#NSSIFloat
.0c08	d0 02		bne $0c0c			bne 	_DIMWENotFloat
.0c0a	a2 06		ldx #$06			ldx 	#6
.0c0c					_DIMWENotFloat:
.0c0c	a9 00		lda #$00			lda 	#0
.0c0e	20 16 0c	jsr $0c16			jsr 	DIMWriteByte
.0c11	ca		dex				dex
.0c12	d0 f8		bne $0c0c			bne 	_DIMWENotFloat
.0c14	fa		plx				plx
.0c15	60		rts				rts
.0c16					DIMWriteByte:
.0c16	92 26		sta ($26)			sta 	(availableMemory)
.0c18	e6 26		inc $26				inc 	availableMemory
.0c1a	d0 0b		bne $0c27			bne 	_DIMWBSkip
.0c1c	e6 27		inc $27				inc 	availableMemory+1
.0c1e	48		pha				pha
.0c1f	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c21	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c24	b0 02		bcs $0c28			bcs 	_DIMWBMemory
.0c26	68		pla				pla
.0c27					_DIMWBSkip:
.0c27	60		rts				rts
.0c28					_DIMWBMemory:
.0c28	4c d0 1f	jmp $1fd0		jmp	ErrorV_memory
.0408					dimType:
>0408							.fill 	1
.0c2b					CommandEnd:
.0c2b	fa		plx				plx
.0c2c	86 2c		stx $2c				stx 	zTemp0
.0c2e	4c ff ff	jmp $ffff			jmp 	$FFFF
.0c31					Unimplemented:
.0c31	4c 03 1f	jmp $1f03			jmp 	ErrorV_unimplemented
.0c34					RuntimeErrorHandler:
.0c34	98		tya				tya
.0c35	18		clc				clc
.0c36	65 28		adc $28				adc 	codePtr
.0c38	85 28		sta $28				sta 	codePtr
.0c3a	90 02		bcc $0c3e			bcc 	_EHNoCarry
.0c3c	e6 29		inc $29				inc 	codePtr+1
.0c3e					_EHNoCarry:
.0c3e	68		pla				pla
.0c3f	7a		ply				ply
.0c40	85 2c		sta $2c				sta 	zTemp0
.0c42	84 2d		sty $2d				sty 	zTemp0+1
.0c44	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c46	a0 01		ldy #$01			ldy 	#1
.0c48					_EHDisplayMsg:
.0c48	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c4a	20 60 1c	jsr $1c60			jsr 	XPrintCharacterToChannel
.0c4d	c8		iny				iny
.0c4e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c50	d0 f6		bne $0c48			bne 	_EHDisplayMsg
.0c52	a9 20		lda #$20			lda 	#32
.0c54	20 60 1c	jsr $1c60			jsr 	XPrintCharacterToChannel
.0c57	a9 40		lda #$40			lda 	#64
.0c59	20 60 1c	jsr $1c60			jsr 	XPrintCharacterToChannel
.0c5c	a9 20		lda #$20			lda 	#32
.0c5e	20 60 1c	jsr $1c60			jsr 	XPrintCharacterToChannel
.0c61	20 66 0c	jsr $0c66			jsr 	EHDisplayCodePtr
.0c64	80 fe		bra $0c64	_EHStop:bra 	_EHStop
.0c66					EHDisplayCodePtr:
.0c66	a9 24		lda #$24			lda 	#'$'
.0c68	20 60 1c	jsr $1c60			jsr 	XPrintCharacterToChannel
.0c6b	38		sec				sec
.0c6c	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c6e	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c71	20 7a 0c	jsr $0c7a			jsr 	_EHDisplayHex
.0c74	a5 28		lda $28				lda 	codePtr
.0c76	20 7a 0c	jsr $0c7a			jsr 	_EHDisplayHex
.0c79	60		rts				rts
.0c7a					_EHDisplayHex:
.0c7a	48		pha				pha
.0c7b	4a		lsr a				lsr 	a
.0c7c	4a		lsr a				lsr 	a
.0c7d	4a		lsr a				lsr 	a
.0c7e	4a		lsr a				lsr 	a
.0c7f	20 83 0c	jsr $0c83			jsr 	_EHDisplayNibble
.0c82	68		pla				pla
.0c83					_EHDisplayNibble:
.0c83	29 0f		and #$0f			and 	#15
.0c85	c9 0a		cmp #$0a			cmp 	#10
.0c87	90 02		bcc $0c8b			bcc 	_EHNotHex
.0c89	69 06		adc #$06			adc 	#6
.0c8b					_EHNotHex:
.0c8b	69 30		adc #$30			adc 	#48
.0c8d	4c 60 1c	jmp $1c60			jmp 	XPrintCharacterToChannel
.0c90					CommandXFor:
.0c90	fa		plx				plx
.0c91	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0c93	20 13 0d	jsr $0d13			jsr 	StackOpenFrame
.0c96	20 52 11	jsr $1152			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0c99	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0c9b	20 f5 0c	jsr $0cf5			jsr 	CopyTOSToOffsetY
.0c9e	ca		dex				dex
.0c9f	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0ca1	20 f5 0c	jsr $0cf5			jsr 	CopyTOSToOffsetY
.0ca4	ca		dex				dex
.0ca5	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0ca7	29 80		and #$80			and 	#$80
.0ca9	a0 04		ldy #$04			ldy 	#4
.0cab	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cad	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0caf	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0cb1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cb3	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0cb5	c8		iny				iny
.0cb6	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cb8	18		clc				clc
.0cb9	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0cbb	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cbd	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0cc0	85 2d		sta $2d				sta 	zTemp0+1
.0cc2	ca		dex				dex 								; throw reference.
.0cc3	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0cc5	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0cc7	a0 0c		ldy #$0c			ldy 	#12
.0cc9	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0ccb	a0 12		ldy #$12			ldy 	#18
.0ccd	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0ccf	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0cd1	88		dey				dey 								; now the exponents.
.0cd2	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0cd4	a0 0b		ldy #$0b			ldy 	#11
.0cd6	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cd8	a0 11		ldy #$11			ldy 	#17
.0cda	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cdc	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0cde	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0ce0	c8		iny				iny
.0ce1	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0ce3	c8		iny				iny
.0ce4	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0ce6	d0 08		bne $0cf0			bne 	_CFNoOptimise
.0ce8	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0cea	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0cec	09 40		ora #$40			ora 	#$40
.0cee	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cf0					_CFNoOptimise:
.0cf0	a0 00		ldy #$00			ldy 	#0
.0cf2	4c 3f 08	jmp $083f			jmp 	NextCommand
.0cf5					CopyTOSToOffsetY:
.0cf5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0cf7	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cf9	c8		iny				iny
.0cfa	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cfc	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cfe	c8		iny				iny
.0cff	b5 56		lda $56,x			lda 	NSMantissa2,x
.0d01	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d03	c8		iny				iny
.0d04	b5 62		lda $62,x			lda 	NSMantissa3,x
.0d06	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d08	c8		iny				iny
.0d09	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d0b	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d0d	c8		iny				iny
.0d0e	b5 32		lda $32,x			lda 	NSStatus,x
.0d10	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d12	60		rts				rts
.0d13					StackOpenFrame:
.0d13	48		pha				pha 								; save frame marker
.0d14	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d16	85 2c		sta $2c				sta 	zTemp0
.0d18	38		sec				sec 								; subtract from runtime stack pointer.
.0d19	a5 24		lda $24				lda		runtimeStackPtr
.0d1b	e5 2c		sbc $2c				sbc 	zTemp0
.0d1d	85 24		sta $24				sta 	runtimeStackPtr
.0d1f	a5 25		lda $25				lda		runtimeStackPtr+1
.0d21	e9 00		sbc #$00			sbc 	#0
.0d23	85 25		sta $25				sta 	runtimeStackPtr+1
.0d25	68		pla				pla 								; put frame marker at +0
.0d26	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d28	60		rts				rts
.0d29					StackCloseFrame:
.0d29	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d2b	29 1f		and #$1f			and 	#$1F 						; size
.0d2d	18		clc				clc
.0d2e	65 24		adc $24				adc 	runtimeStackPtr
.0d30	85 24		sta $24				sta 	runtimeStackPtr
.0d32	90 02		bcc $0d36			bcc 	_SCFNoCarry
.0d34	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d36					_SCFNoCarry:
.0d36	60		rts				rts
.0d37					StackFindFrame:
.0d37	8d 09 04	sta $0409			sta 	requiredFrame
.0d3a					_SFFLoop:
.0d3a	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d3c	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d3e	f0 10		beq $0d50			beq 	SCFFail
.0d40	cd 09 04	cmp $0409			cmp 	requiredFrame 				; found this type ?
.0d43	f0 05		beq $0d4a			beq 	_SFFFound
.0d45	20 29 0d	jsr $0d29			jsr 	StackCloseFrame 			; close the top frame
.0d48	80 f0		bra $0d3a			bra 	_SFFLoop 					; and try te next.
.0d4a					_SFFFound:
.0d4a	60		rts				rts
.0d4b					StackCheckFrame:
.0d4b	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d4d	d0 01		bne $0d50			bne 	SCFFail
.0d4f	60		rts				rts
.0d50					SCFFail:
.0d50	4c 60 1f	jmp $1f60		jmp	ErrorV_structure
.0409					requiredFrame:
>0409							.fill 	1
.0d53					UnaryFre:
.0d53	fa		plx				plx
.0d54	20 28 26	jsr $2628			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d57	38		sec				sec
.0d58	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d5b	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d5e	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d60	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d63	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d66	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d68	4c 3f 08	jmp $083f			jmp 	NextCommand
.0d6b					CommandXGet:
.0d6b	fa		plx				plx
.0d6c	e8		inx				inx
.0d6d	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d6f	20 eb 16	jsr $16eb			jsr 	StringAllocTemp
.0d72	20 51 13	jsr $1351			jsr 	VectorGetCharacter 			; get a character
.0d75	c9 00		cmp #$00			cmp 	#0
.0d77	f0 09		beq $0d82			beq 	_CGNone
.0d79	5a		phy				phy
.0d7a	a0 01		ldy #$01			ldy 	#1 							; store char
.0d7c	91 22		sta ($22),y			sta 	(zsTemp),y
.0d7e	98		tya				tya 								; store length.
.0d7f	92 22		sta ($22)			sta 	(zsTemp)
.0d81	7a		ply				ply
.0d82					_CGNone:
.0d82	4c 3f 08	jmp $083f			jmp 	NextCommand
.0d85					CommandXGosub:
.0d85	fa		plx				plx
.0d86	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0d88	20 13 0d	jsr $0d13			jsr 	StackOpenFrame
.0d8b	20 52 11	jsr $1152			jsr 	StackSaveCurrentPosition
.0d8e	4c a3 0d	jmp $0da3			jmp 	PerformGOTO
.0d91					CommandReturn:
.0d91	fa		plx				plx
.0d92	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0d94	20 37 0d	jsr $0d37			jsr 	StackFindFrame
.0d97	20 63 11	jsr $1163			jsr 	StackLoadCurrentPosition
.0d9a	c8		iny				iny
.0d9b	c8		iny				iny
.0d9c	20 29 0d	jsr $0d29			jsr 	StackCloseFrame
.0d9f	4c 3f 08	jmp $083f			jmp 	NextCommand
.0da2					CommandXGoto:
.0da2	fa		plx				plx
.0da3					PerformGOTO:
.0da3	c8		iny				iny 								; push MSB of offset on stack
.0da4	b1 28		lda ($28),y			lda 	(codePtr),y
.0da6	48		pha				pha
.0da7	88		dey				dey 								; point LSB of offset
.0da8	18		clc				clc 								; add LSB
.0da9	b1 28		lda ($28),y			lda 	(codePtr),y
.0dab	65 28		adc $28				adc 	codePtr
.0dad	85 28		sta $28				sta 	codePtr
.0daf	68		pla				pla 								; restore offset MSB and add
.0db0	65 29		adc $29				adc 	codePtr+1
.0db2	85 29		sta $29				sta 	codePtr+1
.0db4	4c 3f 08	jmp $083f			jmp 	NextCommand
.0db7					CommandGotoZ:
.0db7	fa		plx				plx
.0db8	20 4a 26	jsr $264a			jsr 	FloatIsZero
.0dbb	ca		dex				dex
.0dbc	c9 00		cmp #$00			cmp 	#0
.0dbe	f0 e3		beq $0da3			beq 	PerformGOTO
.0dc0	c8		iny				iny
.0dc1	c8		iny				iny
.0dc2	4c 3f 08	jmp $083f			jmp 	NextCommand
.0dc5					CommandGotoNZ:
.0dc5	fa		plx				plx
.0dc6	20 4a 26	jsr $264a			jsr 	FloatIsZero
.0dc9	ca		dex				dex
.0dca	c9 00		cmp #$00			cmp 	#0
.0dcc	d0 d5		bne $0da3			bne 	PerformGOTO
.0dce	c8		iny				iny
.0dcf	c8		iny				iny
.0dd0	4c 3f 08	jmp $083f			jmp 	NextCommand
.0dd3					Command_PSET:
.0dd3	fa		plx				plx
.0dd4	5a		phy				phy
.0dd5	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; get the colour
.0dd8	48		pha				pha
.0dd9	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0ddb	a0 02		ldy #$02			ldy 	#X16_r0
.0ddd	20 5f 0e	jsr $0e5f			jsr 	GraphicsCopy2
.0de0	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0de3	68		pla				pla 								; set pixel.
.0de4	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0de7	7a		ply				ply
.0de8	a2 ff		ldx #$ff			ldx 	#$FF
.0dea	4c 3f 08	jmp $083f			jmp 	NextCommand
.0ded					Command_LINE:
.0ded	fa		plx				plx
.0dee	5a		phy				phy
.0def	20 52 0e	jsr $0e52			jsr 	GraphicsColour
.0df2	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0df4	a0 02		ldy #$02			ldy 	#X16_r0
.0df6	20 5c 0e	jsr $0e5c			jsr 	GraphicsCopy4
.0df9	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0dfc	7a		ply				ply
.0dfd	a2 ff		ldx #$ff			ldx 	#$FF
.0dff	4c 3f 08	jmp $083f			jmp 	NextCommand
.0e02					Command_RECT:
.0e02	fa		plx				plx
.0e03	5a		phy				phy
.0e04	20 73 0e	jsr $0e73			jsr 	GraphicsRectCoords
.0e07	38		sec				sec
.0e08	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e0b	7a		ply				ply
.0e0c	a2 ff		ldx #$ff			ldx 	#$FF
.0e0e	4c 3f 08	jmp $083f			jmp 	NextCommand
.0e11					Command_FRAME:
.0e11	fa		plx				plx
.0e12	5a		phy				phy
.0e13	20 73 0e	jsr $0e73			jsr 	GraphicsRectCoords
.0e16	18		clc				clc
.0e17	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e1a	7a		ply				ply
.0e1b	a2 ff		ldx #$ff			ldx 	#$FF
.0e1d	4c 3f 08	jmp $083f			jmp 	NextCommand
.0e20					Command_CHAR:
.0e20	fa		plx				plx
.0e21	5a		phy				phy
.0e22	ca		dex				dex  								; set the draw colour
.0e23	20 52 0e	jsr $0e52			jsr 	GraphicsColour
.0e26	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e28	a0 02		ldy #$02			ldy 	#X16_r0
.0e2a	20 5f 0e	jsr $0e5f			jsr 	GraphicsCopy2
.0e2d	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e2f	85 2c		sta $2c				sta 	zTemp0
.0e31	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e33	85 2d		sta $2d				sta 	zTemp0+1
.0e35	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e37	85 2e		sta $2e				sta 	zTemp1
.0e39					_CCLoop:
.0e39	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e3b	f0 0f		beq $0e4c			beq 	_CCExit
.0e3d	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e3f	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e41	d0 02		bne $0e45			bne 	_CCNoCarry
.0e43	e6 2d		inc $2d				inc 	zTemp0+1
.0e45					_CCNoCarry:
.0e45	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e47	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e4a	80 ed		bra $0e39			bra 	_CCLoop						; go round.
.0e4c					_CCExit:
.0e4c	7a		ply				ply
.0e4d	a2 ff		ldx #$ff			ldx 	#$FF
.0e4f	4c 3f 08	jmp $083f			jmp 	NextCommand
.0e52					GraphicsColour:
.0e52	20 1b 10	jsr $101b			jsr 	GetInteger8Bit
.0e55	aa		tax				tax
.0e56	a0 00		ldy #$00			ldy 	#0
.0e58	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e5b	60		rts				rts
.0e5c					GraphicsCopy4:
.0e5c	20 5f 0e	jsr $0e5f			jsr 	GraphicsCopy2
.0e5f					GraphicsCopy2:
.0e5f	20 62 0e	jsr $0e62			jsr 	GraphicsCopy1
.0e62					GraphicsCopy1:
.0e62	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.0e65	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e67	99 00 00	sta $0000,y			sta 	0,y
.0e6a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e6c	99 01 00	sta $0001,y			sta 	1,y
.0e6f	e8		inx				inx
.0e70	c8		iny				iny
.0e71	c8		iny				iny
.0e72	60		rts				rts
.0e73					GraphicsRectCoords:
.0e73	20 52 0e	jsr $0e52			jsr 	GraphicsColour 				; set colour
.0e76	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e78	a0 02		ldy #$02			ldy 	#X16_r0
.0e7a	20 5c 0e	jsr $0e5c			jsr 	GraphicsCopy4
.0e7d	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0e7f	20 8c 0e	jsr $0e8c			jsr 	_GRCSortSubtract
.0e82	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0e84	20 8c 0e	jsr $0e8c			jsr 	_GRCSortSubtract
.0e87	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0e89	74 09		stz $09,x			stz 	9,x
.0e8b	60		rts				rts
.0e8c					_GRCSortSubtract:
.0e8c	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0e8e	d5 00		cmp $00,x			cmp 	0,x
.0e90	b5 05		lda $05,x			lda 	5,x
.0e92	f5 01		sbc $01,x			sbc 	1,x
.0e94	b0 08		bcs $0e9e			bcs 	_GRCNoSwap 					; >= swap.
.0e96	20 ac 0e	jsr $0eac			jsr 	_GRCSwapByte 				; swap 0/2
.0e99	e8		inx				inx
.0e9a	20 ac 0e	jsr $0eac			jsr 	_GRCSwapByte 				; swap 1/3
.0e9d	ca		dex				dex
.0e9e					_GRCNoSwap:
.0e9e	38		sec				sec 								; calculate width/height into 4,5
.0e9f	b5 04		lda $04,x			lda 	4,x
.0ea1	f5 00		sbc $00,x			sbc 	0,x
.0ea3	95 04		sta $04,x			sta 	4,x
.0ea5	b5 05		lda $05,x			lda 	5,x
.0ea7	f5 01		sbc $01,x			sbc 	1,x
.0ea9	95 05		sta $05,x			sta 	5,x
.0eab	60		rts				rts
.0eac					_GRCSwapByte:
.0eac	b5 04		lda $04,x			lda 	4,x
.0eae	48		pha				pha
.0eaf	b5 00		lda $00,x			lda 	0,x
.0eb1	95 04		sta $04,x			sta 	4,x
.0eb3	68		pla				pla
.0eb4	95 00		sta $00,x			sta 	0,x
.0eb6	60		rts				rts
.0eb7					Unary16Hex:
.0eb7	fa		plx				plx
.0eb8	20 21 10	jsr $1021			jsr 	GetInteger16Bit
.0ebb	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0ebd	20 eb 16	jsr $16eb			jsr 	StringAllocTemp
.0ec0	a5 2d		lda $2d				lda 	zTemp0+1
.0ec2	f0 03		beq $0ec7			beq 	_UHNoHigh
.0ec4	20 cf 0e	jsr $0ecf			jsr 	_UHWriteHex
.0ec7					_UHNoHigh:
.0ec7	a5 2c		lda $2c				lda 	zTemp0
.0ec9	20 cf 0e	jsr $0ecf			jsr 	_UHWriteHex
.0ecc	4c 3f 08	jmp $083f			jmp 	NextCommand
.0ecf					_UHWriteHex:
.0ecf	48		pha				pha
.0ed0	4a		lsr a				lsr 	a
.0ed1	4a		lsr a				lsr 	a
.0ed2	4a		lsr a				lsr 	a
.0ed3	4a		lsr a				lsr 	a
.0ed4	20 d8 0e	jsr $0ed8			jsr 	_UHWriteNibl
.0ed7	68		pla				pla
.0ed8					_UHWriteNibl:
.0ed8	29 0f		and #$0f			and 	#15
.0eda	c9 0a		cmp #$0a			cmp 	#10
.0edc	90 02		bcc $0ee0			bcc 	_UHDigit
.0ede	69 06		adc #$06			adc 	#6
.0ee0					_UHDigit:
.0ee0	69 30		adc #$30			adc 	#48
.0ee2	20 14 17	jsr $1714			jsr 	StringWriteChar
.0ee5	60		rts				rts
.0ee6					IndFloatRead:
.0ee6	fa		plx				plx
.0ee7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0ee9	85 2c		sta $2c				sta 	zTemp0
.0eeb	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0eed	18		clc				clc
.0eee	6d 07 04	adc $0407			adc 	variableStartPage
.0ef1	85 2d		sta $2d				sta 	zTemp0+1
.0ef3	ca		dex				dex 								; throw the address
.0ef4	20 ca 14	jsr $14ca			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0ef7	4c 3f 08	jmp $083f			jmp 	NextCommand
.0efa					IndInt16Read:
.0efa	fa		plx				plx
.0efb	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0efd	85 2c		sta $2c				sta 	zTemp0
.0eff	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f01	18		clc				clc
.0f02	6d 07 04	adc $0407			adc 	variableStartPage
.0f05	85 2d		sta $2d				sta 	zTemp0+1
.0f07	ca		dex				dex 								; throw the address
.0f08	20 06 15	jsr $1506			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f0b	4c 3f 08	jmp $083f			jmp 	NextCommand
.0f0e					IndStringRead:
.0f0e	fa		plx				plx
.0f0f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f11	85 2c		sta $2c				sta 	zTemp0
.0f13	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f15	18		clc				clc
.0f16	6d 07 04	adc $0407			adc 	variableStartPage
.0f19	85 2d		sta $2d				sta 	zTemp0+1
.0f1b	ca		dex				dex 								; throw the address
.0f1c	20 4b 15	jsr $154b			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f1f	4c 3f 08	jmp $083f			jmp 	NextCommand
.0f22					IndFloatWrite:
.0f22	fa		plx				plx
.0f23	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f25	85 2c		sta $2c				sta 	zTemp0
.0f27	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f29	18		clc				clc
.0f2a	6d 07 04	adc $0407			adc 	variableStartPage
.0f2d	85 2d		sta $2d				sta 	zTemp0+1
.0f2f	20 a5 1a	jsr $1aa5			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f32	ca		dex				dex 								; throw the address as well.
.0f33	4c 3f 08	jmp $083f			jmp 	NextCommand
.0f36					IndInt16Write:
.0f36	fa		plx				plx
.0f37	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f39	85 2c		sta $2c				sta 	zTemp0
.0f3b	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f3d	18		clc				clc
.0f3e	6d 07 04	adc $0407			adc 	variableStartPage
.0f41	85 2d		sta $2d				sta 	zTemp0+1
.0f43	20 e1 1a	jsr $1ae1			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f46	ca		dex				dex 								; throw the address as well.
.0f47	4c 3f 08	jmp $083f			jmp 	NextCommand
.0f4a					IndStringWrite:
.0f4a	fa		plx				plx
.0f4b	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f4d	85 2c		sta $2c				sta 	zTemp0
.0f4f	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f51	18		clc				clc
.0f52	6d 07 04	adc $0407			adc 	variableStartPage
.0f55	85 2d		sta $2d				sta 	zTemp0+1
.0f57	20 20 1b	jsr $1b20			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f5a	ca		dex				dex 								; throw the address as well.
.0f5b	4c 3f 08	jmp $083f			jmp 	NextCommand
.0f5e					CommandXInput:
.0f5e	fa		plx				plx
.0f5f	5a		phy				phy 								; save Y
.0f60	e8		inx				inx									; space on stack
.0f61					_INError:
.0f61	20 95 0f	jsr $0f95			jsr 	InputStringToBuffer 		; input from keyboard
.0f64	a9 5f		lda #$5f			lda 	#((ReadBufferSize) & $FF)
.0f66	85 2c		sta $2c				sta 	0+zTemp0
.0f68	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f6a	85 2d		sta $2d				sta 	1+zTemp0
.0f6c	20 32 19	jsr $1932			jsr 	ValEvaluateZTemp0
.0f6f	b0 f0		bcs $0f61			bcs 	_INError 					; failed, try again.
.0f71	7a		ply				ply 								; restore Y
.0f72	4c 3f 08	jmp $083f			jmp 	NextCommand
.0f75					CommandInputString:
.0f75	fa		plx				plx
.0f76	5a		phy				phy 								; save Y
.0f77	20 95 0f	jsr $0f95			jsr 	InputStringToBuffer 		; input from keyboard
.0f7a	e8		inx				inx 								; make space on stack
.0f7b	20 28 26	jsr $2628			jsr 	FloatSetZero 				; store as string on stack
.0f7e	a9 5f		lda #$5f			lda 	#ReadBufferSize & $FF
.0f80	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0f82	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0f84	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0f86	a9 40		lda #$40			lda 	#NSSString
.0f88	95 32		sta $32,x			sta 	NSStatus,x
.0f8a	7a		ply				ply 								; restore Y
.0f8b	4c 3f 08	jmp $083f			jmp 	NextCommand
.0f8e					CommandInputReset:
.0f8e	fa		plx				plx
.0f8f	9c 0a 04	stz $040a			stz 	InputBuffer
.0f92	4c 3f 08	jmp $083f			jmp 	NextCommand
.0f95					InputStringToBuffer:
.0f95	a9 cf		lda #$cf			lda 	#((InputBumpNext) & $FF)
.0f97	8d 5f 05	sta $055f			sta 	0+ReadBumpNextVec
.0f9a	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0f9c	8d 60 05	sta $0560			sta 	1+ReadBumpNextVec
.0f9f	a9 ac		lda #$ac			lda 	#((InputLookNext) & $FF)
.0fa1	8d 61 05	sta $0561			sta 	0+ReadLookNextVec
.0fa4	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0fa6	8d 62 05	sta $0562			sta 	1+ReadLookNextVec
.0fa9	4c 27 14	jmp $1427			jmp 	GetStringToBuffer
.0fac					InputLookNext:
.0fac	da		phx				phx
.0fad					_ILNRetry:
.0fad	ad 0a 04	lda $040a			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fb0	d0 08		bne $0fba			bne 	_ILNNotEmpty
.0fb2	20 d3 0f	jsr $0fd3			jsr 	InputGetNewLine 			; get a new line
.0fb5	9c 5b 04	stz $045b			stz 	InputBufferPos 				; reset read position.
.0fb8	80 f3		bra $0fad			bra 	_ILNRetry
.0fba					_ILNNotEmpty:
.0fba	ae 5b 04	ldx $045b			ldx 	InputBufferPos 				; get head available character
.0fbd	bd 0a 04	lda $040a,x			lda 	InputBuffer,x
.0fc0	d0 08		bne $0fca			bne 	_ILNExit 					; if not EOS return it with CC.
.0fc2					_ILNNextLine:
.0fc2	9c 0a 04	stz $040a			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0fc5	38		sec				sec 								; return CS,Zero
.0fc6	fa		plx				plx
.0fc7	a9 0d		lda #$0d			lda 	#13
.0fc9	60		rts				rts
.0fca					_ILNExit:
.0fca	fa		plx				plx
.0fcb	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0fcd	18		clc				clc
.0fce	60		rts				rts
.0fcf					InputBumpNext:
.0fcf	ee 5b 04	inc $045b			inc 	InputBufferPos
.0fd2	60		rts				rts
.0fd3					InputGetNewLine:
.0fd3	48		pha				pha
.0fd4	da		phx				phx
.0fd5	5a		phy				phy
.0fd6	a9 3f		lda #$3f			lda 	#"?"
.0fd8	20 12 10	jsr $1012			jsr 	IGNLEchoIfScreen
.0fdb	a0 00		ldy #$00			ldy 	#0 							; line position.
.0fdd					_IGNLLoop:
.0fdd	20 51 13	jsr $1351			jsr 	VectorGetCharacter 			; get a character
.0fe0	c9 00		cmp #$00			cmp 	#0
.0fe2	f0 f9		beq $0fdd			beq 	_IGNLLoop
.0fe4	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.0fe6	f0 11		beq $0ff9			beq 	_IGNBackspace
.0fe8	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.0fea	f0 17		beq $1003			beq 	_IGNExit
.0fec	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.0fee	f0 ed		beq $0fdd			beq 	_IGNLLoop
.0ff0	99 0a 04	sta $040a,y			sta 	InputBuffer,y
.0ff3	c8		iny				iny
.0ff4	20 12 10	jsr $1012			jsr 	IGNLEchoIfScreen
.0ff7	80 e4		bra $0fdd			bra 	_IGNLLoop
.0ff9					_IGNBackspace:
.0ff9	c0 00		cpy #$00			cpy 	#0
.0ffb	f0 e0		beq $0fdd			beq 	_IGNLLoop
.0ffd	20 12 10	jsr $1012			jsr 	IGNLEchoIfScreen
.1000	88		dey				dey
.1001	80 da		bra $0fdd			bra 	_IGNLLoop
.1003					_IGNExit:
.1003	20 12 10	jsr $1012			jsr 	IGNLEchoIfScreen
.1006	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.1008	99 0a 04	sta $040a,y			sta 	InputBuffer,y
.100b	9c 5b 04	stz $045b			stz 	InputBufferPos 				; reset position to start of input buffer.
.100e	7a		ply				ply
.100f	fa		plx				plx
.1010	68		pla				pla
.1011	60		rts				rts
.1012					IGNLEchoIfScreen:
.1012	ae 5d 04	ldx $045d			ldx 	currentChannel
.1015	d0 03		bne $101a			bne 	_IGNLEExit
.1017	20 48 13	jsr $1348			jsr 	VectorPrintCharacter
.101a					_IGNLEExit:
.101a	60		rts				rts
.040a					InputBuffer:
>040a							.fill 	81
.045b					InputBufferPos:
>045b							.fill 	1
.101b					GetInteger8Bit:
.101b	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.101e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1020	60		rts				rts
.1021					GetInteger16Bit:
.1021	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.1024	34 32		bit $32,x			bit 	NSStatus,x
.1026	30 09		bmi $1031			bmi 	Negate16Bit
.1028	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.102a	85 2c		sta $2c				sta 	zTemp0
.102c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.102e	85 2d		sta $2d				sta 	zTemp0+1
.1030	60		rts				rts
.1031					Negate16Bit:
.1031	38		sec				sec
.1032	a9 00		lda #$00			lda 	#0
.1034	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1036	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1038	85 2c		sta $2c				sta 	zTemp0
.103a	a9 00		lda #$00			lda 	#0
.103c	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.103e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1040	85 2d		sta $2d				sta 	zTemp0+1
.1042	60		rts				rts
.1043					UnaryJoy:
.1043	fa		plx				plx
.1044	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; port #
.1047	48		pha				pha 								; zero the result.
.1048	20 28 26	jsr $2628			jsr 	FloatSetZero
.104b	68		pla				pla
.104c	5a		phy				phy
.104d	da		phx				phx
.104e	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1051	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1053	d0 10		bne $1065			bne 	_UJNoHardware
.1055	a8		tay				tay 								; move XA -> AY
.1056	8a		txa				txa
.1057	fa		plx				plx 								; we can update it now.
.1058	49 ff		eor #$ff			eor 	#$FF
.105a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.105c	98		tya				tya
.105d	49 ff		eor #$ff			eor 	#$FF
.105f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1061	7a		ply				ply 								; restore Y
.1062	4c 3f 08	jmp $083f			jmp 	NextCommand
.1065					_UJNoHardware:
.1065	fa		plx				plx
.1066	7a		ply				ply
.1067	a9 01		lda #$01			lda 	#1 							; set result to -1
.1069	20 2a 26	jsr $262a			jsr 	FloatSetByte
.106c	20 ea 25	jsr $25ea			jsr 	FloatNegate
.106f	4c 3f 08	jmp $083f			jmp 	NextCommand
.1072					UnaryLen:
.1072	fa		plx				plx
.1073	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.1075	85 2c		sta $2c				sta 	zTemp0
.1077	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1079	85 2d		sta $2d				sta 	zTemp0+1
.107b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.107d	20 2a 26	jsr $262a			jsr 	FloatSetByte
.1080	4c 3f 08	jmp $083f			jmp 	NextCommand
.1083					LinkFloatAdd:
.1083	fa		plx				plx
.1084	5a		phy			phy
.1085	20 4c 20	jsr $204c		jsr	FloatAdd
.1088	7a		ply			ply
.1089	4c 3f 08	jmp $083f			jmp 	NextCommand
.108c					LinkFloatSubtract:
.108c	fa		plx				plx
.108d	5a		phy			phy
.108e	20 46 20	jsr $2046		jsr	FloatSubtract
.1091	7a		ply			ply
.1092	4c 3f 08	jmp $083f			jmp 	NextCommand
.1095					LinkFloatMultiply:
.1095	fa		plx				plx
.1096	5a		phy			phy
.1097	20 e8 22	jsr $22e8		jsr	FloatMultiply
.109a	7a		ply			ply
.109b	4c 3f 08	jmp $083f			jmp 	NextCommand
.109e					LinkFloatDivide:
.109e	fa		plx				plx
.109f	5a		phy			phy
.10a0	20 71 21	jsr $2171		jsr	FloatDivide
.10a3	b0 5c		bcs $1101		bcs	DivZeroError
.10a5	7a		ply			ply
.10a6	4c 3f 08	jmp $083f			jmp 	NextCommand
.10a9					LinkFloatPower:
.10a9	fa		plx				plx
.10aa	5a		phy			phy
.10ab	20 f1 28	jsr $28f1		jsr	FloatPower
.10ae	b0 4e		bcs $10fe		bcs	MapRangeError
.10b0	7a		ply			ply
.10b1	4c 3f 08	jmp $083f			jmp 	NextCommand
.10b4					LinkCompareGreater:
.10b4	fa		plx				plx
.10b5	5a		phy			phy
.10b6	20 f5 20	jsr $20f5		jsr	CompareGreater
.10b9	7a		ply			ply
.10ba	4c 3f 08	jmp $083f			jmp 	NextCommand
.10bd					LinkCompareEqual:
.10bd	fa		plx				plx
.10be	5a		phy			phy
.10bf	20 d7 20	jsr $20d7		jsr	CompareEqual
.10c2	7a		ply			ply
.10c3	4c 3f 08	jmp $083f			jmp 	NextCommand
.10c6					LinkCompareLess:
.10c6	fa		plx				plx
.10c7	5a		phy			phy
.10c8	20 ed 20	jsr $20ed		jsr	CompareLess
.10cb	7a		ply			ply
.10cc	4c 3f 08	jmp $083f			jmp 	NextCommand
.10cf					LinkCompareGreaterEqual:
.10cf	fa		plx				plx
.10d0	5a		phy			phy
.10d1	20 05 21	jsr $2105		jsr	CompareGreaterEqual
.10d4	7a		ply			ply
.10d5	4c 3f 08	jmp $083f			jmp 	NextCommand
.10d8					LinkCompareNotEqual:
.10d8	fa		plx				plx
.10d9	5a		phy			phy
.10da	20 e7 20	jsr $20e7		jsr	CompareNotEqual
.10dd	7a		ply			ply
.10de	4c 3f 08	jmp $083f			jmp 	NextCommand
.10e1					LinkCompareLessEqual:
.10e1	fa		plx				plx
.10e2	5a		phy			phy
.10e3	20 fd 20	jsr $20fd		jsr	CompareLessEqual
.10e6	7a		ply			ply
.10e7	4c 3f 08	jmp $083f			jmp 	NextCommand
.10ea					LinkFloatIntegerPartDown:
.10ea	fa		plx				plx
.10eb	5a		phy			phy
.10ec	20 87 22	jsr $2287		jsr	FloatIntegerPartDown
.10ef	7a		ply			ply
.10f0	4c 3f 08	jmp $083f			jmp 	NextCommand
.10f3					LinkFloatSquareRoot:
.10f3	fa		plx				plx
.10f4	5a		phy			phy
.10f5	20 73 29	jsr $2973		jsr	FloatSquareRoot
.10f8	b0 04		bcs $10fe		bcs	MapRangeError
.10fa	7a		ply			ply
.10fb	4c 3f 08	jmp $083f			jmp 	NextCommand
.10fe					MapRangeError:
.10fe	4c c5 1e	jmp $1ec5		jmp	ErrorV_range
.1101					DivZeroError:
.1101	4c 4e 1f	jmp $1f4e		jmp	ErrorV_divzero
.1104					LinkFloatLogarithm:
.1104	fa		plx				plx
.1105	5a		phy			phy
.1106	20 7d 28	jsr $287d		jsr	FloatLogarithm
.1109	b0 f3		bcs $10fe		bcs	MapRangeError
.110b	7a		ply			ply
.110c	4c 3f 08	jmp $083f			jmp 	NextCommand
.110f					LinkFloatExponent:
.110f	fa		plx				plx
.1110	5a		phy			phy
.1111	20 7a 27	jsr $277a		jsr	FloatExponent
.1114	7a		ply			ply
.1115	4c 3f 08	jmp $083f			jmp 	NextCommand
.1118					LinkFloatCosine:
.1118	fa		plx				plx
.1119	5a		phy			phy
.111a	20 6e 27	jsr $276e		jsr	FloatCosine
.111d	7a		ply			ply
.111e	4c 3f 08	jmp $083f			jmp 	NextCommand
.1121					LinkFloatSine:
.1121	fa		plx				plx
.1122	5a		phy			phy
.1123	20 0e 29	jsr $290e		jsr	FloatSine
.1126	7a		ply			ply
.1127	4c 3f 08	jmp $083f			jmp 	NextCommand
.112a					LinkFloatTangent:
.112a	fa		plx				plx
.112b	5a		phy			phy
.112c	20 7f 29	jsr $297f		jsr	FloatTangent
.112f	7a		ply			ply
.1130	4c 3f 08	jmp $083f			jmp 	NextCommand
.1133					LinkFloatArcTan:
.1133	fa		plx				plx
.1134	5a		phy			phy
.1135	20 53 26	jsr $2653		jsr	FloatArcTan
.1138	b0 c4		bcs $10fe		bcs	MapRangeError
.113a	7a		ply			ply
.113b	4c 3f 08	jmp $083f			jmp 	NextCommand
.113e					LinkFloatCompare:
.113e	fa		plx				plx
.113f	5a		phy			phy
.1140	20 0d 21	jsr $210d		jsr	FloatCompare
.1143	7a		ply			ply
.1144	4c 3f 08	jmp $083f			jmp 	NextCommand
.1147					LinkDivideInt32:
.1147	fa		plx				plx
.1148	5a		phy			phy
.1149	20 9b 21	jsr $219b		jsr	DivideInt32
.114c	b0 b0		bcs $10fe		bcs	MapRangeError
.114e	7a		ply			ply
.114f	4c 3f 08	jmp $083f			jmp 	NextCommand
.1152					StackSaveCurrentPosition:
.1152	20 aa 08	jsr $08aa			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.1155	5a		phy				phy
.1156	a0 02		ldy #$02			ldy 	#2
.1158	a5 28		lda $28				lda 	codePtr
.115a	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.115c	c8		iny				iny
.115d	a5 29		lda $29				lda 	codePtr+1
.115f	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1161	7a		ply				ply
.1162	60		rts				rts
.1163					StackLoadCurrentPosition:
.1163	a0 02		ldy #$02			ldy 	#2
.1165	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1167	85 28		sta $28				sta 	codePtr
.1169	c8		iny				iny
.116a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.116c	85 29		sta $29				sta 	codePtr+1
.116e	a0 00		ldy #$00			ldy 	#0
.1170	60		rts				rts
.1171					XCommandMouse:
.1171	fa		plx				plx
.1172	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; mouse control.
.1175	ca		dex				dex
.1176	da		phx				phx
.1177	5a		phy				phy
.1178	48		pha				pha
.1179	38		sec				sec 								; get screen resolution
.117a	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.117d	68		pla				pla
.117e	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.1181	7a		ply				ply
.1182	fa		plx				plx
.1183	4c 3f 08	jmp $083f			jmp 	NextCommand
.1186					XUnaryMB:
.1186	fa		plx				plx
.1187	20 b5 11	jsr $11b5			jsr 	XUnaryMouseCommon
.118a	a5 30		lda $30				lda 	zTemp2
.118c	e8		inx				inx
.118d	20 2a 26	jsr $262a			jsr 	FloatSetByte
.1190	4c 3f 08	jmp $083f			jmp 	NextCommand
.1193					XUnaryMX:
.1193	fa		plx				plx
.1194	20 b5 11	jsr $11b5			jsr 	XUnaryMouseCommon
.1197	a5 2c		lda $2c				lda 	zTemp0
.1199	e8		inx				inx
.119a	20 2a 26	jsr $262a			jsr 	FloatSetByte
.119d	a5 2d		lda $2d				lda 	zTemp0+1
.119f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11a1	4c 3f 08	jmp $083f			jmp 	NextCommand
.11a4					XUnaryMY:
.11a4	fa		plx				plx
.11a5	20 b5 11	jsr $11b5			jsr 	XUnaryMouseCommon
.11a8	a5 2e		lda $2e				lda 	zTemp1
.11aa	e8		inx				inx
.11ab	20 2a 26	jsr $262a			jsr 	FloatSetByte
.11ae	a5 2f		lda $2f				lda 	zTemp1+1
.11b0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11b2	4c 3f 08	jmp $083f			jmp 	NextCommand
.11b5					XUnaryMouseCommon:
.11b5	da		phx				phx
.11b6	5a		phy				phy
.11b7	a2 2c		ldx #$2c			ldx 	#zTemp0
.11b9	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.11bc	85 30		sta $30				sta 	zTemp2
.11be	7a		ply				ply
.11bf	fa		plx				plx
.11c0	60		rts				rts
.11c1					NegateTOS:
.11c1	fa		plx				plx
.11c2	20 ea 25	jsr $25ea			jsr 	FloatNegate
.11c5	4c 3f 08	jmp $083f			jmp 	NextCommand
.11c8					CommandNewLine:
.11c8	fa		plx				plx
.11c9	9c 68 05	stz $0568			stz 	stringInitialised
.11cc	a2 ff		ldx #$ff			ldx 	#$FF
.11ce	4c 3f 08	jmp $083f			jmp 	NextCommand
.11d1					CommandXNext:
.11d1	fa		plx				plx
.11d2					_CNRetry:
.11d2	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.11d4	20 37 0d	jsr $0d37			jsr 	StackFindFrame
.11d7	20 aa 08	jsr $08aa			jsr 	FixUpY 						; so we can use Y
.11da	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.11dc	35 4a		and $4a,x			and 	NSMantissa1,x
.11de	c9 ff		cmp #$ff			cmp 	#$FF
.11e0	f0 16		beq $11f8			beq 	_CNNoIndexVariable
.11e2	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.11e4	a0 05		ldy #$05			ldy 	#5
.11e6	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.11e8	d0 07		bne $11f1			bne 	_CNNIndexFail
.11ea	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.11ec	c8		iny				iny
.11ed	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.11ef	f0 07		beq $11f8			beq 	_CNNoIndexVariable
.11f1					_CNNIndexFail:
.11f1	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.11f3	20 29 0d	jsr $0d29			jsr 	StackCloseFrame 			; close this frame
.11f6	80 da		bra $11d2			bra 	_CNRetry
.11f8					_CNNoIndexVariable:
.11f8	ca		dex				dex
.11f9	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.11fb	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.11fd	29 40		and #$40			and 	#$40	 					; bit 6
.11ff	d0 55		bne $1256			bne 	_CNOptimisedNext
.1201	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1203	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1205	48		pha				pha
.1206	85 2c		sta $2c				sta 	zTemp0
.1208	c8		iny				iny
.1209	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.120b	18		clc				clc
.120c	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.120f	48		pha				pha
.1210	85 2d		sta $2d				sta 	zTemp0+1
.1212	20 ca 14	jsr $14ca			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.1215	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.1217	e8		inx				inx
.1218	20 99 12	jsr $1299			jsr 	CopyOffsetYToTOS
.121b	20 4c 20	jsr $204c			jsr 	FloatAdd
.121e	68		pla				pla 								; restore address
.121f	85 2d		sta $2d				sta 	zTemp0+1
.1221	68		pla				pla
.1222	85 2c		sta $2c				sta 	zTemp0
.1224	20 a5 1a	jsr $1aa5			jsr 	WriteFloatZTemp0Sub			; write float.
.1227	e8		inx				inx  								; recover written
.1228	e8		inx				inx 								; load offset
.1229	a0 0d		ldy #$0d			ldy 	#13
.122b	20 99 12	jsr $1299			jsr 	CopyOffsetYToTOS
.122e	20 0d 21	jsr $210d			jsr 	FloatCompare 				; and compare the floats.
.1231	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1232	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.1234	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1236	30 08		bmi $1240			bmi 	_CNDownStep
.1238	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.123a	c9 01		cmp #$01			cmp 	#1 							; gone higher
.123c	f0 10		beq $124e			beq 	_CNExitFor 					; if so exit the loop
.123e	80 06		bra $1246			bra 	_CNLoopBack
.1240					_CNDownStep:
.1240	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1242	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.1244	f0 08		beq $124e			beq 	_CNExitFor
.1246					_CNLoopBack:
.1246	20 63 11	jsr $1163			jsr 	StackLoadCurrentPosition 	; loop back
.1249	a0 00		ldy #$00			ldy 	#0
.124b	4c 3f 08	jmp $083f			jmp 	NextCommand
.124e					_CNExitFor:
.124e	20 29 0d	jsr $0d29			jsr 	StackCloseFrame 			; remove the frame and exit
.1251	a0 00		ldy #$00			ldy 	#0
.1253	4c 3f 08	jmp $083f			jmp 	NextCommand
.1256					_CNOptimisedNext:
.1256	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1258	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.125a	85 2c		sta $2c				sta 	zTemp0
.125c	c8		iny				iny
.125d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.125f	18		clc				clc
.1260	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1263	85 2d		sta $2d				sta 	zTemp0+1
.1265	a0 07		ldy #$07			ldy 	#7 							; STEP value
.1267	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1269	a0 ff		ldy #$ff			ldy 	#$FF
.126b	18		clc				clc
.126c					_CNOIncrement:
.126c	c8		iny				iny
.126d	71 2c		adc ($2c),y			adc 	(zTemp0),y
.126f	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1271	f0 f9		beq $126c			beq 	_CNOIncrement
.1273	18		clc				clc
.1274	a5 24		lda $24				lda 	runtimeStackPtr
.1276	69 0d		adc #$0d			adc 	#13
.1278	85 2e		sta $2e				sta 	zTemp1
.127a	a5 25		lda $25				lda 	runtimeStackPtr+1
.127c	69 00		adc #$00			adc 	#0
.127e	85 2f		sta $2f				sta 	zTemp1+1
.1280	a0 00		ldy #$00			ldy 	#0
.1282	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.1284	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.1286	c8		iny				iny
.1287	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.1289	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.128b	c8		iny				iny
.128c	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.128e	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1290	c8		iny				iny
.1291	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.1293	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1295	90 b7		bcc $124e			bcc	 	_CNExitFor
.1297	80 ad		bra $1246			bra 	_CNLoopBack
.1299					CopyOffsetYToTOS:
.1299	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.129b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.129d	c8		iny				iny
.129e	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12a0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12a2	c8		iny				iny
.12a3	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12a5	95 56		sta $56,x			sta 	NSMantissa2,x
.12a7	c8		iny				iny
.12a8	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12aa	95 62		sta $62,x			sta 	NSMantissa3,x
.12ac	c8		iny				iny
.12ad	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12af	95 6e		sta $6e,x			sta 	NSExponent,x
.12b1	c8		iny				iny
.12b2	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12b4	95 32		sta $32,x			sta 	NSStatus,x
.12b6	60		rts				rts
.12b7	4c 3f 08	jmp $083f			jmp 	NextCommand
.12ba					NotTOS:
.12ba	fa		plx				plx
.12bb	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.12be	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.12c0	74 62		stz $62,x			stz 	NSMantissa3,x
.12c2	20 ea 25	jsr $25ea			jsr 	FloatNegate		 			; negate
.12c5	e8		inx				inx 								; and subtract 1.
.12c6	a9 01		lda #$01			lda 	#1
.12c8	20 2a 26	jsr $262a			jsr 	FloatSetByte
.12cb	20 46 20	jsr $2046			jsr 	FloatSubtract
.12ce					_NotTOSSkip:
.12ce	4c 3f 08	jmp $083f			jmp 	NextCommand
.12d1					CommandXOn:
.12d1	fa		plx				plx
.12d2	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.12d5	8d 5c 04	sta $045c			sta 	onCount 					; save it.
.12d8	20 aa 08	jsr $08aa			jsr 	FixUpY 						; Y = 0
.12db					_CONFind:
.12db	ce 5c 04	dec $045c			dec 	onCount 					; reached zero, do this one
.12de	f0 0b		beq $12eb			beq 	_CONFound
.12e0	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.12e1	c8		iny				iny
.12e2	c8		iny				iny
.12e3	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.12e5	c8		iny				iny
.12e6	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.12e8	f0 f1		beq $12db			beq 	_CONFind
.12ea	88		dey				dey 								; point to character after last GOTO/GOSUB
.12eb					_CONFound:
.12eb	4c 3f 08	jmp $083f			jmp 	NextCommand
.12ee					CommandMoreOn:
.12ee	fa		plx				plx
.12ef	c8		iny				iny 								; so it goes to the first non-goto/gosub
.12f0	c8		iny				iny
.12f1	c8		iny				iny
.12f2	4c 3f 08	jmp $083f			jmp 	NextCommand
.045c					onCount:
>045c							.fill 	1
.12f5					UnaryPeek:
.12f5	fa		plx				plx
.12f6	20 21 10	jsr $1021			jsr 	GetInteger16Bit
.12f9	da		phx				phx
.12fa	5a		phy				phy
.12fb	a6 2c		ldx $2c				ldx 	zTemp0
.12fd	a4 2d		ldy $2d				ldy 	zTemp0+1
.12ff	20 36 1c	jsr $1c36			jsr 	XPeekMemory
.1302	7a		ply				ply
.1303	fa		plx				plx
.1304	20 2a 26	jsr $262a			jsr 	FloatSetByte
.1307	4c 3f 08	jmp $083f			jmp 	NextCommand
.130a					CommandPOKE:
.130a	fa		plx				plx
.130b	da		phx				phx 								; save XY
.130c	5a		phy				phy
.130d	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1310	48		pha				pha
.1311	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1313	a8		tay				tay
.1314	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1316	aa		tax				tax
.1317	68		pla				pla
.1318	20 22 1c	jsr $1c22			jsr 	XPokeMemory
.131b	7a		ply				ply 								; restore YX and drop 2
.131c	fa		plx				plx
.131d	ca		dex				dex
.131e	ca		dex				dex
.131f	4c 3f 08	jmp $083f			jmp 	NextCommand
.1322					UnaryPos:
.1322	fa		plx				plx
.1323	20 b5 1b	jsr $1bb5			jsr 	XGetHPos
.1326	20 2a 26	jsr $262a			jsr 	FloatSetByte
.1329	4c 3f 08	jmp $083f			jmp 	NextCommand
.132c					GetChannel:
.132c	fa		plx				plx
.132d	ad 5d 04	lda $045d			lda 	currentChannel
.1330	e8		inx				inx
.1331	20 2a 26	jsr $262a			jsr 	FloatSetByte
.1334	4c 3f 08	jmp $083f			jmp 	NextCommand
.1337					SetChannel:
.1337	fa		plx				plx
.1338	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.133b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.133d	8d 5d 04	sta $045d			sta 	currentChannel
.1340	ca		dex				dex
.1341	4c 3f 08	jmp $083f			jmp 	NextCommand
.1344					SetDefaultChannel:
.1344	9c 5d 04	stz $045d			stz 	currentChannel
.1347	60		rts				rts
.1348					VectorPrintCharacter:
.1348	da		phx				phx
.1349	ae 5d 04	ldx $045d			ldx 	currentChannel
.134c	20 60 1c	jsr $1c60			jsr 	XPrintCharacterToChannel
.134f	fa		plx				plx
.1350	60		rts				rts
.1351					VectorGetCharacter:
.1351	da		phx				phx
.1352	ae 5d 04	ldx $045d			ldx 	currentChannel
.1355	20 99 1b	jsr $1b99			jsr 	XGetCharacterFromChannel
.1358	fa		plx				plx
.1359	60		rts				rts
.045d					currentChannel:
>045d							.fill 	1
.135a					PrintNumber:
.135a	fa		plx				plx
.135b	a9 07		lda #$07			lda 	#7
.135d	20 10 25	jsr $2510			jsr 	FloatToString 				; to number in decimal buffer
.1360	ca		dex				dex 								; drop
.1361	da		phx				phx
.1362	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1364					_PNLoop:
.1364	bd 96 05	lda $0596,x			lda 	decimalBuffer,x
.1367	20 48 13	jsr $1348			jsr 	VectorPrintCharacter
.136a	e8		inx				inx
.136b	bd 96 05	lda $0596,x			lda	 	decimalBuffer,x
.136e	d0 f4		bne $1364			bne 	_PNLoop
.1370	a9 20		lda #$20			lda 	#32 						; trailing space
.1372	20 48 13	jsr $1348			jsr 	VectorPrintCharacter
.1375	fa		plx				plx
.1376	4c 3f 08	jmp $083f			jmp 	NextCommand
.1379					PrintString:
.1379	fa		plx				plx
.137a	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.137c	85 2c		sta $2c				sta 	zTemp0
.137e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1380	85 2d		sta $2d				sta 	zTemp0+1
.1382	ca		dex				dex 								; drop
.1383	da		phx				phx
.1384	5a		phy				phy
.1385	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.1387	aa		tax				tax
.1388	a0 01		ldy #$01			ldy 	#1 							; Y = position
.138a					_PSLoop:
.138a	e0 00		cpx #$00			cpx 	#0 							; complete ?
.138c	f0 09		beq $1397			beq 	_PSExit
.138e	ca		dex				dex 								; dec count
.138f	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.1391	20 48 13	jsr $1348			jsr 	VectorPrintCharacter
.1394	c8		iny				iny
.1395	80 f3		bra $138a			bra 	_PSLoop
.1397					_PSExit:
.1397	7a		ply				ply
.1398	fa		plx				plx
.1399	4c 3f 08	jmp $083f			jmp 	NextCommand
.139c					CommandPushN:
.139c	fa		plx				plx
.139d	e8		inx				inx 								; next slot on stack
.139e	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.13a0	95 6e		sta $6e,x			sta 	NSExponent,x
.13a2	c8		iny				iny
.13a3	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.13a5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13a7	c8		iny				iny
.13a8	b1 28		lda ($28),y			lda 	(codePtr),y
.13aa	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13ac	c8		iny				iny
.13ad	b1 28		lda ($28),y			lda 	(codePtr),y
.13af	95 56		sta $56,x			sta 	NSMantissa2,x
.13b1	c8		iny				iny
.13b2	b1 28		lda ($28),y			lda 	(codePtr),y
.13b4	48		pha				pha
.13b5	29 7f		and #$7f			and 	#$7F
.13b7	95 62		sta $62,x			sta 	NSMantissa3,x
.13b9	68		pla				pla 								; sign in mantissa3:7
.13ba	29 80		and #$80			and 	#$80
.13bc	95 32		sta $32,x			sta 	NSStatus,x
.13be	c8		iny				iny
.13bf	4c 3f 08	jmp $083f			jmp 	NextCommand
.13c2					CommandPushS:
.13c2	fa		plx				plx
.13c3	e8		inx				inx 								; next slot on stack
.13c4	18		clc				clc
.13c5	98		tya				tya
.13c6	65 28		adc $28				adc 	codePtr 					; the string is inline
.13c8	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13ca	a5 29		lda $29				lda 	codePtr+1
.13cc	69 00		adc #$00			adc 	#0
.13ce	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13d0	74 56		stz $56,x			stz 	NSMantissa2,x
.13d2	74 62		stz $62,x			stz 	NSMantissa3,x
.13d4	a9 40		lda #$40			lda 	#NSSString
.13d6	95 32		sta $32,x			sta 	NSStatus,x
.13d8	98		tya				tya 								; string length +1 added to Y
.13d9	38		sec				sec
.13da	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.13dc	a8		tay				tay
.13dd	4c 3f 08	jmp $083f			jmp 	NextCommand
.13e0					CommandXRead:
.13e0	fa		plx				plx
.13e1	5a		phy				phy 								; save Y
.13e2	20 13 14	jsr $1413			jsr 	ReadStringToBuffer 			; read element into buffer
.13e5	e8		inx				inx									; space on stack
.13e6	a9 5f		lda #$5f			lda 	#((ReadBufferSize) & $FF)
.13e8	85 2c		sta $2c				sta 	0+zTemp0
.13ea	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.13ec	85 2d		sta $2d				sta 	1+zTemp0
.13ee	20 32 19	jsr $1932			jsr 	ValEvaluateZTemp0
.13f1	b0 04		bcs $13f7			bcs 	_CRError 					; failed
.13f3	7a		ply				ply 								; restore Y
.13f4	4c 3f 08	jmp $083f			jmp 	NextCommand
.13f7					_CRError:
.13f7	4c d5 1e	jmp $1ed5		jmp	ErrorV_value
.13fa					CommandReadString:
.13fa	fa		plx				plx
.13fb	5a		phy				phy 								; save Y
.13fc	20 13 14	jsr $1413			jsr 	ReadStringToBuffer 			; read text
.13ff	e8		inx				inx 								; make space on stack
.1400	20 28 26	jsr $2628			jsr 	FloatSetZero 				; store as string on stack
.1403	a9 5f		lda #$5f			lda 	#ReadBufferSize & $FF
.1405	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1407	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.1409	95 4a		sta $4a,x			sta 	NSMantissa1,x
.140b	a9 40		lda #$40			lda 	#NSSString
.140d	95 32		sta $32,x			sta 	NSStatus,x
.140f	7a		ply				ply 								; restore Y
.1410	4c 3f 08	jmp $083f			jmp 	NextCommand
.1413					ReadStringToBuffer:
.1413	a9 a6		lda #$a6			lda 	#((ReadBumpNext) & $FF)
.1415	8d 5f 05	sta $055f			sta 	0+ReadBumpNextVec
.1418	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.141a	8d 60 05	sta $0560			sta 	1+ReadBumpNextVec
.141d	a9 79		lda #$79			lda 	#((ReadLookNext) & $FF)
.141f	8d 61 05	sta $0561			sta 	0+ReadLookNextVec
.1422	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.1424	8d 62 05	sta $0562			sta 	1+ReadLookNextVec
.1427					GetStringToBuffer:
.1427	20 76 14	jsr $1476			jsr		GetLookNext 				; skip all leading spaces.
.142a	f0 44		beq $1470			beq 	_RBError 					; end of data
.142c	b0 f9		bcs $1427			bcs 	GetStringToBuffer 			; switched to new data line.
.142e	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1430	b0 05		bcs $1437			bcs 	_RBNoSpace
.1432	20 73 14	jsr $1473			jsr 	GetBumpNext 				; consume space and loop round.
.1435	80 f0		bra $1427			bra 	GetStringToBuffer
.1437					_RBNoSpace:
.1437	9c 5f 04	stz $045f			stz 	ReadBufferSize 				; empty the buffer.
.143a	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.143c	d0 08		bne $1446			bne 	_RBCommaSep
.143e	8d 5e 04	sta $045e			sta 	ReadSep 					; use as a seperator
.1441	20 73 14	jsr $1473			jsr 	GetBumpNext 				; consume the '"'
.1444	80 05		bra $144b			bra 	_RBGetText
.1446					_RBCommaSep:
.1446	a9 2c		lda #$2c			lda 	#","						; get till comma
.1448	8d 5e 04	sta $045e			sta 	ReadSep
.144b					_RBGetText:
.144b	20 76 14	jsr $1476			jsr 	GetLookNext 				; what follows
.144e	b0 18		bcs $1468			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.1450	20 73 14	jsr $1473			jsr 	GetBumpNext 				; consume it whatever
.1453	cd 5e 04	cmp $045e			cmp 	ReadSep 					; if found the seperator.
.1456	f0 10		beq $1468			beq 	_RBEndGet 					; exit after consumption
.1458	da		phx				phx
.1459	ae 5f 04	ldx $045f			ldx 	ReadBufferSize 				; copy into buffer.
.145c	ee 5f 04	inc $045f			inc 	ReadBufferSize
.145f	9d 60 04	sta $0460,x			sta 	ReadBuffer,x
.1462	9e 61 04	stz $0461,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.1465	fa		plx				plx
.1466	80 e3		bra $144b			bra 	_RBGetText
.1468					_RBEndGet:
.1468	c9 22		cmp #$22			cmp 	#'"'
.146a	d0 03		bne $146f			bne 	_RBNotQuote
.146c	20 73 14	jsr $1473			jsr 	GetBumpNext
.146f					_RBNotQuote:
.146f	60		rts				rts
.1470					_RBError:
.1470	4c 8a 1f	jmp $1f8a		jmp	ErrorV_data
.1473					GetBumpNext:
.1473	6c 5f 05	jmp ($055f)			jmp 	(ReadBumpNextVec)
.1476					GetLookNext:
.1476	6c 61 05	jmp ($0561)			jmp 	(ReadLookNextVec)
.1479					ReadLookNext:
.1479	ad 63 05	lda $0563			lda 	dataRemaining 				; any data remaining
.147c	f0 04		beq $1482			beq 	_RLNFindData
.147e	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.1480	18		clc				clc
.1481	60		rts				rts
.1482					_RLNFindData:
.1482	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.1484	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.1486	f0 1a		beq $14a2			beq 	_RLNNoData
.1488	c9 cf		cmp #$cf			cmp 	#PCD_CMD_DATA 				; Found DATA
.148a	f0 05		beq $1491			beq 	_RLNHaveData
.148c					_RLNNext:
.148c	20 f7 1f	jsr $1ff7			jsr 	MoveObjectForward			; else scan forward.
.148f	80 f1		bra $1482			bra 	_RLNFindData
.1491					_RLNHaveData:
.1491	a0 01		ldy #$01			ldy 	#1 							; get length
.1493	b1 2a		lda ($2a),y			lda 	(objPtr),y
.1495	f0 f5		beq $148c			beq 	_RLNNext 					; skip if DATA alone
.1497	20 a6 14	jsr $14a6			jsr 	ReadBumpNext 				; advance by two
.149a	20 a6 14	jsr $14a6			jsr 	ReadBumpNext
.149d	8d 63 05	sta $0563			sta 	dataRemaining 				; set data left count.
.14a0	38		sec				sec
.14a1	60		rts				rts
.14a2					_RLNNoData:
.14a2	a9 00		lda #$00			lda 	#0
.14a4	38		sec				sec
.14a5	60		rts				rts
.14a6					ReadBumpNext:
.14a6	e6 2a		inc $2a				inc 	objPtr
.14a8	d0 02		bne $14ac			bne 	_RBNSkip
.14aa	e6 2b		inc $2b				inc 	objPtr+1
.14ac					_RBNSkip:
.14ac	ce 63 05	dec $0563			dec 	dataRemaining
.14af	60		rts				rts
.045e					ReadSep:
>045e							.fill 	1
.045f					ReadBufferSize:
>045f							.fill 	1
.0460					ReadBuffer:
>0460							.fill 	255
.055f					ReadBumpNextVec:
>055f							.fill 	2
.0561					ReadLookNextVec:
>0561							.fill 	2
.14b0					ReadFloatCommand:
.14b0	fa		plx				plx
.14b1	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14b3	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14b5	88		dey				dey 								; get the upper 3 bits
.14b6	b1 28		lda ($28),y			lda 	(codePtr),y
.14b8	29 07		and #$07			and 	#7
.14ba	c8		iny				iny
.14bb	c8		iny				iny
.14bc	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14be	2a		rol a				rol 	a 							; carry will be clear.
.14bf	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14c2	85 2d		sta $2d				sta 	zTemp0+1
.14c4	20 ca 14	jsr $14ca			jsr 	ReadFloatZTemp0Sub
.14c7	4c 3f 08	jmp $083f			jmp 	NextCommand
.14ca					ReadFloatZTemp0Sub:
.14ca	5a		phy				phy 								; start write
.14cb	a0 01		ldy #$01			ldy 	#1
.14cd	e8		inx				inx
.14ce	b2 2c		lda ($2c)			lda 	(zTemp0)
.14d0	95 3e		sta $3e,x			sta 	NSMantissa0,x
.14d2	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14d4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.14d6	c8		iny				iny
.14d7	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14d9	95 56		sta $56,x			sta 	NSMantissa2,x
.14db	c8		iny				iny
.14dc	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14de	95 62		sta $62,x			sta 	NSMantissa3,x
.14e0	c8		iny				iny
.14e1	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14e3	95 6e		sta $6e,x			sta 	NSExponent,x
.14e5	c8		iny				iny
.14e6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14e8	95 32		sta $32,x			sta 	NSStatus,x
.14ea	7a		ply				ply
.14eb	60		rts				rts
.14ec					ReadIntegerCommand:
.14ec	fa		plx				plx
.14ed	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14ef	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14f1	88		dey				dey 								; get the upper 3 bits
.14f2	b1 28		lda ($28),y			lda 	(codePtr),y
.14f4	29 07		and #$07			and 	#7
.14f6	c8		iny				iny
.14f7	c8		iny				iny
.14f8	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14fa	2a		rol a				rol 	a 							; carry will be clear.
.14fb	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14fe	85 2d		sta $2d				sta 	zTemp0+1
.1500	20 06 15	jsr $1506			jsr 	ReadIntegerZTemp0Sub
.1503	4c 3f 08	jmp $083f			jmp 	NextCommand
.1506					ReadIntegerZTemp0Sub:
.1506	5a		phy				phy 								; start write
.1507	a0 01		ldy #$01			ldy 	#1
.1509	e8		inx				inx 								; prepare
.150a	74 56		stz $56,x			stz 	NSMantissa2,x
.150c	74 62		stz $62,x			stz 	NSMantissa3,x
.150e	74 6e		stz $6e,x			stz 	NSExponent,x
.1510	74 32		stz $32,x			stz 	NSStatus,x
.1512	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1514	30 08		bmi $151e			bmi 	_RIZNegative
.1516	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1518	b2 2c		lda ($2c)			lda 	(zTemp0)
.151a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.151c	7a		ply				ply
.151d	60		rts				rts
.151e					_RIZNegative:
.151e	38		sec				sec 								; -ve read
.151f	a9 00		lda #$00			lda 	#0
.1521	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.1523	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1525	a9 00		lda #$00			lda 	#0
.1527	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1529	95 4a		sta $4a,x			sta 	NSMantissa1,x
.152b	a9 80		lda #$80			lda 	#$80
.152d	95 32		sta $32,x			sta 	NSStatus,x
.152f	7a		ply				ply
.1530	60		rts				rts
.1531					ReadStringCommand:
.1531	fa		plx				plx
.1532	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1534	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1536	88		dey				dey 								; get the upper 3 bits
.1537	b1 28		lda ($28),y			lda 	(codePtr),y
.1539	29 07		and #$07			and 	#7
.153b	c8		iny				iny
.153c	c8		iny				iny
.153d	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.153f	2a		rol a				rol 	a 							; carry will be clear.
.1540	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1543	85 2d		sta $2d				sta 	zTemp0+1
.1545	20 4b 15	jsr $154b			jsr 	ReadStringZTemp0Sub
.1548	4c 3f 08	jmp $083f			jmp 	NextCommand
.154b					ReadStringZTemp0Sub:
.154b	5a		phy				phy 								; start write
.154c	e8		inx				inx 								; prepare
.154d	74 56		stz $56,x			stz 	NSMantissa2,x
.154f	74 62		stz $62,x			stz 	NSMantissa3,x
.1551	74 6e		stz $6e,x			stz 	NSExponent,x
.1553	a9 40		lda #$40			lda 	#NSSString
.1555	74 32		stz $32,x			stz 	NSStatus,x
.1557	18		clc				clc
.1558	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.155a	69 02		adc #$02			adc 	#2 							; this points to actual data
.155c	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.155e	a0 01		ldy #$01			ldy 	#1
.1560	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1562	69 00		adc #$00			adc 	#0
.1564	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1566	d0 08		bne $1570			bne 	_RSZNoDefault 				; if read $00 use a default value.
.1568	a9 72		lda #$72			lda 	#_RSZNull & $FF
.156a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.156c	a9 15		lda #$15			lda 	#_RSZNull >> 8
.156e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1570					_RSZNoDefault:
.1570	7a		ply				ply
.1571	60		rts				rts
.1572					_RSZNull:
>1572	00						.byte 	0
.1573					CommandRestore:
.1573	fa		plx				plx
.1574	20 7a 15	jsr $157a			jsr 	RestoreCode
.1577	4c 3f 08	jmp $083f			jmp 	NextCommand
.157a					RestoreCode:
.157a	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.157d	85 2b		sta $2b				sta 	objPtr+1
.157f	64 2a		stz $2a				stz 	objPtr
.1581	9c 63 05	stz $0563			stz 	dataRemaining 				; no data remaining.
.1584	60		rts				rts
.0563					dataRemaining:
>0563							.fill 	1		 					; 0 if not in data statement
.1585					UnaryRND:
.1585	fa		plx				plx
.1586	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.1588	10 17		bpl $15a1			bpl 	_URNoSeed
.158a	20 7d 23	jsr $237d			jsr 	FloatNormalise 				; some float value
.158d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.158f	8d 64 05	sta $0564			sta 	randomSeed+0
.1592	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1594	8d 65 05	sta $0565			sta 	randomSeed+1
.1597	b5 56		lda $56,x			lda 	NSMantissa2,x
.1599	8d 66 05	sta $0566			sta 	randomSeed+2
.159c	b5 62		lda $62,x			lda 	NSMantissa3,x
.159e	8d 67 05	sta $0567			sta 	randomSeed+3
.15a1					_URNoSeed:
.15a1	20 c3 15	jsr $15c3			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.15a4	ad 64 05	lda $0564			lda 	randomSeed+0
.15a7	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15a9	ad 65 05	lda $0565			lda 	randomSeed+1
.15ac	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15ae	ad 66 05	lda $0566			lda 	randomSeed+2
.15b1	95 56		sta $56,x			sta 	NSMantissa2,x
.15b3	ad 67 05	lda $0567			lda 	randomSeed+3
.15b6	29 7f		and #$7f			and 	#$7F
.15b8	95 62		sta $62,x			sta 	NSMantissa3,x
.15ba	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.15bc	95 6e		sta $6e,x			sta 	NSExponent,x
.15be	74 32		stz $32,x			stz 	NSStatus,x
.15c0	4c 3f 08	jmp $083f			jmp 	NextCommand
.15c3					RandomNumberGenerator:
.15c3	5a		phy				phy
.15c4	ad 64 05	lda $0564			lda 	randomSeed+0 				; check if zero
.15c7	0d 65 05	ora $0565			ora 	randomSeed+1
.15ca	0d 66 05	ora $0566			ora 	randomSeed+2
.15cd	0d 67 05	ora $0567			ora 	randomSeed+3
.15d0	d0 07		bne $15d9			bne 	_RNGNoSeed
.15d2	ce 67 05	dec $0567			dec 	randomSeed+3 				; if so tweak and flog
.15d5	a0 64		ldy #$64			ldy 	#100
.15d7	80 05		bra $15de			bra 	_RNGLoop
.15d9					_RNGNoSeed:
.15d9	a0 08		ldy #$08			ldy 	#8
.15db	ad 64 05	lda $0564			lda 	randomSeed+0
.15de					_RNGLoop:
.15de	0a		asl a				asl		a
.15df	2e 65 05	rol $0565			rol 	randomSeed+1
.15e2	2e 66 05	rol $0566			rol 	randomSeed+2
.15e5	2e 67 05	rol $0567			rol 	randomSeed+3
.15e8	90 02		bcc $15ec			bcc		_RNGSkip
.15ea	49 c5		eor #$c5			eor 	#$C5
.15ec					_RNGSkip:
.15ec	88		dey				dey
.15ed	d0 ef		bne $15de			bne		_RNGLoop
.15ef	8d 64 05	sta $0564			sta 	randomSeed+0
.15f2	7a		ply				ply
.15f3	60		rts				rts
.0564					randomSeed:
>0564							.fill 	4
.15f4					StringConcatenate:
.15f4	fa		plx				plx
.15f5	ca		dex				dex
.15f6	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.15f8	85 2e		sta $2e				sta 	zTemp1
.15fa	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15fc	85 2f		sta $2f				sta 	zTemp1+1
.15fe	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.1600	85 30		sta $30				sta 	zTemp2
.1602	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.1604	85 31		sta $31				sta 	zTemp2+1
.1606	18		clc				clc 								; work out total length
.1607	b2 2e		lda ($2e)			lda 	(zTemp1)
.1609	72 30		adc ($30)			adc 	(zTemp2)
.160b	b0 18		bcs $1625			bcs 	_BCLength 					; more than 255 characters.
.160d	48		pha				pha 								; save total
.160e	20 eb 16	jsr $16eb			jsr 	StringAllocTemp 			; space for result.
.1611	68		pla				pla 								; write total as first.
.1612	92 22		sta ($22)			sta 	(zsTemp)
.1614	20 28 16	jsr $1628			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.1617	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.1619	85 2e		sta $2e				sta 	zTemp1
.161b	a5 31		lda $31				lda 	zTemp2+1
.161d	85 2f		sta $2f				sta 	zTemp1+1
.161f	20 28 16	jsr $1628			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1622	4c 3f 08	jmp $083f			jmp 	NextCommand
.1625					_BCLength:
.1625	4c c5 1e	jmp $1ec5		jmp	ErrorV_range
.1628					_BCCopyZTemp1:
.1628	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.162a	f0 15		beq $1641			beq 	_BCCExit 					; none.
.162c	da		phx				phx 								; save XY
.162d	5a		phy				phy
.162e	aa		tax				tax 								; count in X.
.162f	a0 01		ldy #$01			ldy 	#1
.1631					_BCCLoop:
.1631	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1633	d0 02		bne $1637			bne 	_BCCNoCarry
.1635	e6 23		inc $23				inc 	zsTemp+1
.1637					_BCCNoCarry:
.1637	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.1639	92 22		sta ($22)			sta 	(zsTemp)
.163b	c8		iny				iny
.163c	ca		dex				dex 								; X times
.163d	d0 f2		bne $1631			bne 	_BCCLoop
.163f	7a		ply				ply 								; restore YX
.1640	fa		plx				plx
.1641					_BCCExit:
.1641	60		rts				rts
.1642					XRuntimeSetup:
.1642	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1644	8d 6b 05	sta $056b	 		sta 	ramBank
.1647	8d 6c 05	sta $056c	 		sta 	romBank
.164a	60		rts				rts
.164b					SignTOS:
.164b	fa		plx				plx
.164c	20 4a 26	jsr $264a			jsr 	FloatIsZero 				; if zero
.164f	f0 0f		beq $1660			beq 	_SGZero  					; return Int Zero
.1651	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.1653	48		pha				pha
.1654	a9 01		lda #$01			lda 	#1 							; set result to 1
.1656	20 2a 26	jsr $262a			jsr 	FloatSetByte
.1659	68		pla				pla
.165a	29 80		and #$80			and		#$80 						; copy the sign byte out
.165c	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.165e	80 03		bra $1663			bra 	_SGExit
.1660					_SGZero:
.1660	20 28 26	jsr $2628			jsr 	FloatSetZero
.1663					_SGExit:
.1663	4c 3f 08	jmp $083f			jmp 	NextCommand
.1666					CommandShift:
.1666	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.1668	c8		iny				iny
.1669	0a		asl a				asl 	a 							; double into X
.166a	aa		tax				tax
.166b	7c 16 1a	jmp ($1a16,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.166e					PrintTab:
.166e	fa		plx				plx
.166f	20 b5 1b	jsr $1bb5			jsr 	XGetHPos
.1672					_PTMod10:
.1672	38		sec				sec
.1673	e9 0a		sbc #$0a			sbc 	#10
.1675	b0 fb		bcs $1672			bcs 	_PTMod10
.1677	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.1679	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.167a	80 15		bra $1691			bra 	PrintSpaceLoop
.167c					PrintPos:
.167c	fa		plx				plx
.167d	20 b5 1b	jsr $1bb5			jsr		XGetHPos 					; get current position
.1680	85 2c		sta $2c				sta 	zTemp0
.1682	38		sec				sec 								; calculate spaces required
.1683	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1685	ca		dex				dex
.1686	e5 2c		sbc $2c				sbc 	zTemp0
.1688	b0 07		bcs $1691			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.168a	4c 3f 08	jmp $083f			jmp 	NextCommand
.168d					PrintSpace:
.168d	fa		plx				plx
.168e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1690	ca		dex				dex
.1691					PrintSpaceLoop:
.1691	c9 00		cmp #$00			cmp 	#0
.1693	f0 0a		beq $169f			beq 	_PSExit
.1695	48		pha				pha
.1696	a9 20		lda #$20			lda 	#" "
.1698	20 48 13	jsr $1348			jsr 	VectorPrintCharacter
.169b	68		pla				pla
.169c	3a		dec a				dec 	a
.169d	80 f2		bra $1691			bra 	PrintSpaceLoop
.169f					_PSExit:
.169f	4c 3f 08	jmp $083f			jmp 	NextCommand
.16a2					CommandStop:
.16a2	fa		plx				plx
.16a3	4c 77 1f	jmp $1f77		jmp	ErrorV_stop
.16a6					Unary_Str:
.16a6	fa		plx				plx
.16a7	5a		phy				phy
.16a8	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.16aa	20 10 25	jsr $2510			jsr 	FloatToString 				; do the conversion.
.16ad	a9 21		lda #$21			lda		#33 						; create buffer
.16af	20 eb 16	jsr $16eb			jsr 	StringAllocTemp 			; allocate memory
.16b2	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.16b4					_USCopy:
.16b4	b9 95 05	lda $0595,y			lda 	decimalBuffer-1,y
.16b7	f0 05		beq $16be			beq 	_USExit
.16b9	91 22		sta ($22),y			sta 	(zsTemp),y
.16bb	c8		iny				iny
.16bc	80 f6		bra $16b4			bra 	_USCopy
.16be					_USExit:
.16be	98		tya				tya
.16bf	3a		dec a				dec 	a
.16c0	92 22		sta ($22)			sta 	(zsTemp)
.16c2	7a		ply				ply
.16c3	4c 3f 08	jmp $083f			jmp 	NextCommand
.16c6					StringInitialise:
.16c6	48		pha				pha
.16c7	ad 68 05	lda $0568			lda 	stringInitialised 			; already done
.16ca	d0 11		bne $16dd			bne 	_SIExit
.16cc	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.16cf	8d 69 05	sta $0569			sta 	stringTempPointer
.16d2	ad 03 04	lda $0403			lda 	stringHighMemory+1
.16d5	3a		dec a				dec 	a
.16d6	3a		dec a				dec 	a
.16d7	8d 6a 05	sta $056a			sta 	stringTempPointer+1
.16da	ce 68 05	dec $0568			dec 	stringInitialised 			; set the initialised flag.
.16dd					_SIExit:
.16dd	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.16df	1a		inc a				inc 	a
.16e0	1a		inc a				inc 	a
.16e1	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.16e4	b0 02		bcs $16e8			bcs 	_SIMemory
.16e6	68		pla				pla
.16e7	60		rts				rts
.16e8					_SIMemory:
.16e8	4c d0 1f	jmp $1fd0		jmp	ErrorV_memory
.16eb					StringAllocTemp:
.16eb	20 c6 16	jsr $16c6			jsr 	StringInitialise 			; check it is initialised.
.16ee	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.16f0	18		clc				clc
.16f1	6d 69 05	adc $0569			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.16f4	8d 69 05	sta $0569			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.16f7	85 22		sta $22				sta 	zsTemp
.16f9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.16fb	ad 6a 05	lda $056a			lda 	stringTempPointer+1
.16fe	69 ff		adc #$ff			adc 	#$FF
.1700	8d 6a 05	sta $056a			sta 	stringTempPointer+1
.1703	85 23		sta $23				sta 	zsTemp+1
.1705	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1707	74 56		stz $56,x			stz 	NSMantissa2,x
.1709	74 62		stz $62,x			stz 	NSMantissa3,x
.170b	a9 00		lda #$00			lda 	#0 							; clear string.
.170d	92 22		sta ($22)			sta 	(zsTemp)
.170f	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1711	95 32		sta $32,x			sta 	NSStatus,x
.1713	60		rts				rts
.1714					StringWriteChar:
.1714	5a		phy				phy
.1715	48		pha				pha
.1716	b2 22		lda ($22)			lda 	(zsTemp)
.1718	1a		inc a				inc 	a
.1719	92 22		sta ($22)			sta 	(zsTemp)
.171b	a8		tay				tay
.171c	68		pla				pla
.171d	91 22		sta ($22),y			sta 	(zsTemp),y
.171f	7a		ply				ply
.1720	60		rts				rts
.0568					stringInitialised:
>0568							.fill 	1
.0569					stringTempPointer:
>0569							.fill 	2
.1721					Unary_Left:
.1721	fa		plx				plx
.1722	5a		phy				phy
.1723	18		clc				clc 								; only one parameter
.1724	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; push the length of the string.
.1727	48		pha				pha
.1728	ca		dex				dex
.1729	a9 00		lda #$00			lda 	#0 							; push the start position.
.172b	48		pha				pha
.172c	20 64 17	jsr $1764			jsr 	UnarySStringToZTemp0
.172f	80 3c		bra $176d			bra 	SubstringMain 				; stack now points to the string to slice.
.1731					Unary_Right:
.1731	fa		plx				plx
.1732	5a		phy				phy
.1733	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.1735	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; push the right length of the string.
.1738	48		pha				pha
.1739	ca		dex				dex
.173a	20 64 17	jsr $1764			jsr 	UnarySStringToZTemp0
.173d	68		pla				pla 								; this is the right requirement
.173e	38		sec				sec
.173f	49 ff		eor #$ff			eor 	#$FF
.1741	72 2c		adc ($2c)			adc 	(zTemp0)
.1743	b0 02		bcs $1747			bcs 	_URHaveCount
.1745	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.1747					_URHaveCount:
.1747	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.1749	5a		phy				phy
.174a	48		pha				pha 								; start position
.174b	80 20		bra $176d			bra 	SubstringMain
.174d					Unary_Mid:
.174d	fa		plx				plx
.174e	5a		phy				phy
.174f	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; push the length of the string required.
.1752	48		pha				pha
.1753	ca		dex				dex
.1754	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; put the start position.
.1757	f0 08		beq $1761			beq 	_UMError
.1759	3a		dec a				dec 	a
.175a	48		pha				pha
.175b	ca		dex				dex
.175c	20 64 17	jsr $1764			jsr 	UnarySStringToZTemp0
.175f	80 0c		bra $176d			bra 	SubstringMain 				; stack now points to the string to slice.
.1761					_UMError:
.1761	4c c5 1e	jmp $1ec5		jmp	ErrorV_range
.1764					UnarySStringToZTemp0:
.1764	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1766	85 2c		sta $2c				sta 	zTemp0
.1768	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.176a	85 2d		sta $2d				sta 	zTemp0+1
.176c	60		rts				rts
.176d					SubstringMain:
.176d	68		pla				pla 								; get the start offset
.176e	7a		ply				ply 								; get the count to do.
.176f	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.1771	b0 38		bcs $17ab			bcs 	_SSReturnNull
.1773	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.1775	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.1777	18		clc				clc
.1778	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.177a	b0 06		bcs $1782			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.177c	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.177e	f0 04		beq $1784			beq 	_SMIsOkay
.1780	90 02		bcc $1784			bcc 	_SMIsOkay
.1782					_SMTruncateToEnd:
.1782	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.1784					_SMIsOkay:
.1784	85 2f		sta $2f				sta 	zTemp1+1
.1786	38		sec				sec		 							; work out size
.1787	a5 2f		lda $2f				lda 	zTemp1+1
.1789	e5 2e		sbc $2e				sbc 	zTemp1
.178b	f0 1e		beq $17ab			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.178d	20 eb 16	jsr $16eb			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.1790	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.1792					_SMCopy:
.1792	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.1794	f0 11		beq $17a7			beq 	_SMExit
.1796	c8		iny				iny 								; bump and
.1797	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.1799	5a		phy				phy
.179a	48		pha				pha
.179b	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.179d	1a		inc a				inc 	a
.179e	a8		tay				tay
.179f	92 22		sta ($22)			sta 	(zsTemp)
.17a1	68		pla				pla 								; write character out
.17a2	91 22		sta ($22),y			sta 	(zsTemp),y
.17a4	7a		ply				ply 								; restore Y
.17a5	80 eb		bra $1792			bra 	_SMCopy
.17a7					_SMExit:
.17a7	7a		ply				ply
.17a8	4c 3f 08	jmp $083f			jmp 	NextCommand
.17ab					_SSReturnNull:
.17ab	a9 bd		lda #$bd			lda 	#SSRNull & $FF 				; set up mantissa
.17ad	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17af	a9 17		lda #$17			lda 	#SSRNull >> 8
.17b1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17b3	74 56		stz $56,x			stz 	NSMantissa2,x
.17b5	74 62		stz $62,x			stz 	NSMantissa3,x
.17b7	a9 40		lda #$40			lda 	#NSSString
.17b9	95 32		sta $32,x			sta 	NSStatus,x
.17bb	80 ea		bra $17a7			bra 	_SMExit
.17bd					SSRNull:
>17bd	00 00						.word 	0
.17bf					CommandSwap:
.17bf	fa		plx				plx
.17c0	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17c2	48		pha				pha
.17c3	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.17c5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17c7	68		pla				pla
.17c8	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.17ca	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17cc	48		pha				pha
.17cd	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.17cf	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17d1	68		pla				pla
.17d2	95 49		sta $49,x			sta 	NSMantissa1-1,x
.17d4	b5 56		lda $56,x			lda 	NSMantissa2,x
.17d6	48		pha				pha
.17d7	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.17d9	95 56		sta $56,x			sta 	NSMantissa2,x
.17db	68		pla				pla
.17dc	95 55		sta $55,x			sta 	NSMantissa2-1,x
.17de	b5 62		lda $62,x			lda 	NSMantissa3,x
.17e0	48		pha				pha
.17e1	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.17e3	95 62		sta $62,x			sta 	NSMantissa3,x
.17e5	68		pla				pla
.17e6	95 61		sta $61,x			sta 	NSMantissa3-1,x
.17e8	b5 6e		lda $6e,x			lda 	NSExponent,x
.17ea	48		pha				pha
.17eb	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.17ed	95 6e		sta $6e,x			sta 	NSExponent,x
.17ef	68		pla				pla
.17f0	95 6d		sta $6d,x			sta 	NSExponent-1,x
.17f2	b5 32		lda $32,x			lda 	NSStatus,x
.17f4	48		pha				pha
.17f5	b5 31		lda $31,x			lda 	NSStatus-1,x
.17f7	95 32		sta $32,x			sta 	NSStatus,x
.17f9	68		pla				pla
.17fa	95 31		sta $31,x			sta 	NSStatus-1,x
.17fc	4c 3f 08	jmp $083f			jmp 	NextCommand
.17ff					CommandSYS:
.17ff	fa		plx				plx
.1800	da		phx				phx 								; save XY
.1801	5a		phy				phy
.1802	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.1805	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.1807	85 2d		sta $2d				sta 	zTemp0+1
.1809	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.180b	85 2c		sta $2c				sta 	zTemp0
.180d	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1810	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.1813	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.1816	48		pha				pha
.1817	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.181a	28		plp				plp
.181b	20 32 18	jsr $1832			jsr 	_CSZTemp0
.181e	08		php				php
.181f	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1822	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.1825	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.1828	68		pla				pla
.1829	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.182c	7a		ply				ply 								; restore YX and drop 2
.182d	fa		plx				plx
.182e	ca		dex				dex
.182f	4c 3f 08	jmp $083f			jmp 	NextCommand
.1832					_CSZTemp0:
.1832	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.1835					TimeTOS:
.1835	fa		plx				plx
.1836	20 90 18	jsr $1890			jsr 	TIPushClock 				; push clock to TOS
.1839	4c 3f 08	jmp $083f			jmp 	NextCommand
.183c					TimeString:
.183c	fa		plx				plx
.183d	20 90 18	jsr $1890			jsr 	TIPushClock 				; push clock to TOS
.1840	20 65 18	jsr $1865			jsr 	_TSDivMod60 				; result in seconds
.1843	20 65 18	jsr $1865			jsr 	_TSDivMod60 				; seconds
.1846	48		pha				pha
.1847	20 65 18	jsr $1865			jsr 	_TSDivMod60 				; minutes
.184a	48		pha				pha
.184b	a9 18		lda #$18			lda 	#24 						; hours
.184d	20 67 18	jsr $1867			jsr 	_TSDivModA
.1850	48		pha				pha
.1851	a9 06		lda #$06			lda 	#6
.1853	20 eb 16	jsr $16eb			jsr 	StringAllocTemp
.1856	68		pla				pla
.1857	20 77 18	jsr $1877			jsr 	_TSWriteDecimal
.185a	68		pla				pla
.185b	20 77 18	jsr $1877			jsr 	_TSWriteDecimal
.185e	68		pla				pla
.185f	20 77 18	jsr $1877			jsr 	_TSWriteDecimal
.1862	4c 3f 08	jmp $083f			jmp 	NextCommand
.1865					_TSDivMod60:
.1865	a9 3c		lda #$3c			lda 	#60
.1867					_TSDivModA:
.1867	e8		inx				inx
.1868	20 2a 26	jsr $262a			jsr 	FloatSetByte
.186b	ca		dex				dex
.186c	20 be 21	jsr $21be			jsr 	Int32Divide
.186f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.1871	48		pha				pha
.1872	20 ad 21	jsr $21ad			jsr 	NSMCopyPlusTwoToZero
.1875	68		pla				pla
.1876	60		rts				rts
.1877					_TSWriteDecimal:
.1877	da		phx				phx
.1878	a2 30		ldx #$30			ldx 	#'0'
.187a					_TSWDLoop:
.187a	c9 0a		cmp #$0a			cmp 	#10
.187c	90 05		bcc $1883			bcc 	_TSWDEnd
.187e	e9 0a		sbc #$0a			sbc 	#10
.1880	e8		inx				inx
.1881	80 f7		bra $187a			bra 	_TSWDLoop
.1883					_TSWDEnd:
.1883	48		pha				pha
.1884	8a		txa				txa
.1885	20 14 17	jsr $1714			jsr 	StringWriteChar
.1888	68		pla				pla
.1889	09 30		ora #$30			ora 	#'0'
.188b	20 14 17	jsr $1714			jsr 	StringWriteChar
.188e	fa		plx				plx
.188f	60		rts				rts
.1890					TIPushClock:
.1890	5a		phy				phy
.1891	e8		inx				inx 								; push 0 on the stack
.1892	20 28 26	jsr $2628			jsr 	FloatSetZero
.1895	da		phx				phx
.1896	20 80 1c	jsr $1c80			jsr 	XReadClock 					; read time into YXA
.1899	86 2c		stx $2c				stx 	zTemp0
.189b	fa		plx				plx
.189c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.189e	a5 2c		lda $2c				lda 	zTemp0
.18a0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.18a2	98		tya				tya
.18a3	95 56		sta $56,x			sta 	NSMantissa2,x
.18a5	7a		ply				ply
.18a6	60		rts				rts
.18a7					CommandTIWrite:
.18a7	fa		plx				plx
.18a8	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.18aa	85 22		sta $22				sta 	zsTemp
.18ac	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.18ae	85 23		sta $23				sta 	zsTemp+1
.18b0	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.18b2	c9 06		cmp #$06			cmp 	#6
.18b4	d0 59		bne $190f			bne 	_CTIWError
.18b6	20 28 26	jsr $2628			jsr 	FloatSetZero
.18b9	20 db 18	jsr $18db			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.18bc	20 db 18	jsr $18db			jsr 	_CTIWDigitPair
.18bf	20 db 18	jsr $18db			jsr 	_CTIWDigitPair
.18c2	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.18c4	20 06 19	jsr $1906			jsr 	_CTIWMultiply
.18c7	da		phx				phx
.18c8	5a		phy				phy
.18c9	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.18cb	48		pha				pha
.18cc	b5 56		lda $56,x			lda 	NSMantissa2,x
.18ce	a8		tay				tay
.18cf	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.18d1	fa		plx				plx
.18d2	20 84 1c	jsr $1c84			jsr 	XWriteClock 				; update the clock.
.18d5	7a		ply				ply
.18d6	fa		plx				plx
.18d7	ca		dex				dex 								; throw result.
.18d8	4c 3f 08	jmp $083f			jmp 	NextCommand
.18db					_CTIWDigitPair:
.18db	a9 06		lda #$06			lda 	#6 							; x 6
.18dd	20 06 19	jsr $1906			jsr 	_CTIWMultiply
.18e0	20 ec 18	jsr $18ec			jsr 	_CTIWAddDigit 				; add digit
.18e3	a9 0a		lda #$0a			lda 	#10 						; x 10
.18e5	20 06 19	jsr $1906			jsr 	_CTIWMultiply
.18e8	20 ec 18	jsr $18ec			jsr 	_CTIWAddDigit 				; add digit
.18eb	60		rts				rts
.18ec					_CTIWAddDigit:
.18ec	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.18ee	d0 02		bne $18f2			bne 	_CTIWASkip
.18f0	e6 23		inc $23				inc 	zsTemp+1
.18f2					_CTIWASkip:
.18f2	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.18f4	38		sec				sec
.18f5	e9 30		sbc #$30			sbc 	#"0"
.18f7	90 16		bcc $190f			bcc 	_CTIWError
.18f9	c9 0a		cmp #$0a			cmp 	#9+1
.18fb	b0 12		bcs $190f			bcs 	_CTIWError
.18fd	e8		inx				inx 								; store at +1
.18fe	20 2a 26	jsr $262a			jsr 	FloatSetByte
.1901	ca		dex				dex
.1902	20 b4 23	jsr $23b4			jsr 	FloatAddTopTwoStack
.1905	60		rts				rts
.1906					_CTIWMultiply:
.1906	e8		inx				inx
.1907	20 2a 26	jsr $262a			jsr 	FloatSetByte
.190a	ca		dex				dex
.190b	20 35 23	jsr $2335			jsr 	FloatMultiplyShort
.190e	60		rts				rts
.190f					_CTIWError:
.190f	4c d5 1e	jmp $1ed5		jmp	ErrorV_value
.1912					UnaryUsr:
.1912	fa		plx				plx
.1913	5a		phy				phy
.1914	20 1b 19	jsr $191b			jsr 	_UUCallVector
.1917	7a		ply				ply
.1918	4c 3f 08	jmp $083f			jmp 	NextCommand
.191b					_UUCallVector:
.191b	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.191e					ValUnary:
.191e	fa		plx				plx
.191f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1921	85 2c		sta $2c				sta 	zTemp0
.1923	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1925	85 2d		sta $2d				sta 	zTemp0+1
.1927	20 32 19	jsr $1932			jsr 	ValEvaluateZTemp0
.192a	b0 03		bcs $192f			bcs 	_VUError 					; couldn't convert
.192c	4c 3f 08	jmp $083f			jmp 	NextCommand
.192f					_VUError:
.192f	4c d5 1e	jmp $1ed5		jmp	ErrorV_value
.1932					ValEvaluateZTemp0:
.1932	5a		phy				phy
.1933	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.1935	f0 22		beq $1959			beq 	_VMCFail2
.1937	a0 00		ldy #$00			ldy 	#0 							; start position
.1939					_VMCSpaces:
.1939	c8		iny				iny 								; skip leading spaces
.193a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.193c	c9 20		cmp #$20			cmp 	#" "
.193e	f0 f9		beq $1939			beq 	_VMCSpaces
.1940	48		pha				pha 								; save first character
.1941	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.1943	d0 01		bne $1946			bne 	_VMCStart
.1945	c8		iny				iny 								; skip over - if so.
.1946					_VMCStart:
.1946	38		sec				sec 								; initialise first time round.
.1947					_VMCNext:
.1947	98		tya				tya 								; reached end of string
.1948	3a		dec a				dec 	a
.1949	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.194b	f0 0f		beq $195c			beq 	_VMCSuccess 				; successful.
.194d	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.194f	c8		iny				iny
.1950	20 0c 24	jsr $240c			jsr 	FloatEncode 				; send it to the number-builder
.1953	90 03		bcc $1958			bcc 	_VMCFail 					; if failed, give up.
.1955	18		clc				clc 								; next time round, countinue
.1956	80 ef		bra $1947			bra 	_VMCNext
.1958					_VMCFail:
.1958	68		pla				pla
.1959					_VMCFail2:
.1959	7a		ply				ply
.195a	38		sec				sec
.195b	60		rts				rts
.195c					_VMCSuccess:
.195c	a9 00		lda #$00			lda 	#0 							; construct final
.195e	20 0c 24	jsr $240c			jsr 	FloatEncode 				; by sending a duff value.
.1961	68		pla				pla 								; if it was -ve
.1962	c9 2d		cmp #$2d			cmp 	#"-"
.1964	d0 03		bne $1969			bne 	_VMCNotNegative
.1966	20 ea 25	jsr $25ea			jsr		FloatNegate 				; negate it.
.1969					_VMCNotNegative:
.1969	7a		ply				ply
.196a	18		clc				clc
.196b	60		rts				rts
.196c					VectorTable:
>196c	83 10					.word	LinkFloatAdd             ; $80 +
>196e	8c 10					.word	LinkFloatSubtract        ; $81 -
>1970	95 10					.word	LinkFloatMultiply        ; $82 *
>1972	9e 10					.word	LinkFloatDivide          ; $83 /
>1974	a9 10					.word	LinkFloatPower           ; $84 ^
>1976	d1 08					.word	BinaryAnd                ; $85 and
>1978	d5 08					.word	BinaryOr                 ; $86 or
>197a	b4 10					.word	LinkCompareGreater       ; $87 >
>197c	bd 10					.word	LinkCompareEqual         ; $88 =
>197e	c6 10					.word	LinkCompareLess          ; $89 <
>1980	cf 10					.word	LinkCompareGreaterEqual  ; $8a >=
>1982	d8 10					.word	LinkCompareNotEqual      ; $8b <>
>1984	e1 10					.word	LinkCompareLessEqual     ; $8c <=
>1986	b9 08					.word	AbsoluteTOS              ; $8d abs
>1988	0c 09					.word	ArrayConvert             ; $8e array
>198a	b4 09					.word	UnaryAsc                 ; $8f asc
>198c	cf 09					.word	CommandAssert            ; $90 assert
>198e	10 0a					.word	Unary16Bin               ; $91 bin$
>1990	3a 0a					.word	PrintCharacterX          ; $92 print.chr
>1992	44 0a					.word	UnaryChr                 ; $93 chr$
>1994	a9 0a					.word	CompareStrings           ; $94 s.cmp
>1996	90 0c					.word	CommandXFor              ; $95 for
>1998	53 0d					.word	UnaryFre                 ; $96 fre
>199a	6b 0d					.word	CommandXGet              ; $97 get
>199c	91 0d					.word	CommandReturn            ; $98 return
>199e	d3 0d					.word	Command_PSET             ; $99 pset
>19a0	ed 0d					.word	Command_LINE             ; $9a line
>19a2	02 0e					.word	Command_RECT             ; $9b rect
>19a4	11 0e					.word	Command_FRAME            ; $9c frame
>19a6	20 0e					.word	Command_CHAR             ; $9d char
>19a8	b7 0e					.word	Unary16Hex               ; $9e hex$
>19aa	5e 0f					.word	CommandXInput            ; $9f input
>19ac	75 0f					.word	CommandInputString       ; $a0 input$
>19ae	8e 0f					.word	CommandInputReset        ; $a1 input.start
>19b0	72 10					.word	UnaryLen                 ; $a2 len
>19b2	3e 11					.word	LinkFloatCompare         ; $a3 f.cmp
>19b4	47 11					.word	LinkDivideInt32          ; $a4 int.div
>19b6	c1 11					.word	NegateTOS                ; $a5 negate
>19b8	c8 11					.word	CommandNewLine           ; $a6 new.line
>19ba	d1 11					.word	CommandXNext             ; $a7 next
>19bc	ba 12					.word	NotTOS                   ; $a8 not
>19be	d1 12					.word	CommandXOn               ; $a9 on
>19c0	ee 12					.word	CommandMoreOn            ; $aa moreon
>19c2	f5 12					.word	UnaryPeek                ; $ab peek
>19c4	0a 13					.word	CommandPOKE              ; $ac poke
>19c6	22 13					.word	UnaryPos                 ; $ad pos
>19c8	2c 13					.word	GetChannel               ; $ae getchannel
>19ca	37 13					.word	SetChannel               ; $af setchannel
>19cc	5a 13					.word	PrintNumber              ; $b0 print.n
>19ce	79 13					.word	PrintString              ; $b1 print.s
>19d0	e0 13					.word	CommandXRead             ; $b2 read
>19d2	fa 13					.word	CommandReadString        ; $b3 read$
>19d4	85 15					.word	UnaryRND                 ; $b4 rnd
>19d6	f4 15					.word	StringConcatenate        ; $b5 concat
>19d8	4b 16					.word	SignTOS                  ; $b6 sgn
>19da	6e 16					.word	PrintTab                 ; $b7 print.tab
>19dc	7c 16					.word	PrintPos                 ; $b8 print.pos
>19de	8d 16					.word	PrintSpace               ; $b9 print.spc
>19e0	a6 16					.word	Unary_Str                ; $ba str$
>19e2	21 17					.word	Unary_Left               ; $bb left$
>19e4	31 17					.word	Unary_Right              ; $bc right$
>19e6	4d 17					.word	Unary_Mid                ; $bd mid$
>19e8	bf 17					.word	CommandSwap              ; $be swap
>19ea	35 18					.word	TimeTOS                  ; $bf ti
>19ec	3c 18					.word	TimeString               ; $c0 ti$
>19ee	12 19					.word	UnaryUsr                 ; $c1 usr
>19f0	1e 19					.word	ValUnary                 ; $c2 val
>19f2	7c 1b					.word	CommandClose             ; $c3 close
>19f4	8e 1b					.word	CommandExit              ; $c4 exit
>19f6	94 1b					.word	CommandDebug             ; $c5 debug
>19f8	fa 1b					.word	CommandXOpen             ; $c6 open
>19fa	8e 1c					.word	CommandScreen            ; $c7 screen
>19fc	75 1e					.word	CommandVPOKE             ; $c8 vpoke
>19fe	9a 1e					.word	CommandVPEEK             ; $c9 vpeek
>1a00	66 16					.word	CommandShift             ; $ca .shift
>1a02	7d 08					.word	PushByteCommand          ; $cb .byte
>1a04	90 08					.word	PushWordCommand          ; $cc .word
>1a06	9c 13					.word	CommandPushN             ; $cd .float
>1a08	c2 13					.word	CommandPushS             ; $ce .string
>1a0a	31 0b					.word	CommandXData             ; $cf .data
>1a0c	a2 0d					.word	CommandXGoto             ; $d0 .goto
>1a0e	85 0d					.word	CommandXGosub            ; $d1 .gosub
>1a10	b7 0d					.word	CommandGotoZ             ; $d2 .goto.z
>1a12	c5 0d					.word	CommandGotoNZ            ; $d3 .goto.nz
>1a14	bf 08					.word	CommandVarSpace          ; $d4 .varspace
.1a16					ShiftVectorTable:
>1a16	5c 0a					.word	CommandClr               ; $ca80 clr
>1a18	3a 0b					.word	CommandXDIM              ; $ca81 dim
>1a1a	2b 0c					.word	CommandEnd               ; $ca82 end
>1a1c	43 10					.word	UnaryJoy                 ; $ca83 joy
>1a1e	ea 10					.word	LinkFloatIntegerPartDown ; $ca84 int
>1a20	f3 10					.word	LinkFloatSquareRoot      ; $ca85 sqr
>1a22	04 11					.word	LinkFloatLogarithm       ; $ca86 log
>1a24	0f 11					.word	LinkFloatExponent        ; $ca87 exp
>1a26	18 11					.word	LinkFloatCosine          ; $ca88 cos
>1a28	21 11					.word	LinkFloatSine            ; $ca89 sin
>1a2a	2a 11					.word	LinkFloatTangent         ; $ca8a tan
>1a2c	33 11					.word	LinkFloatArcTan          ; $ca8b atn
>1a2e	71 11					.word	XCommandMouse            ; $ca8c mouse
>1a30	86 11					.word	XUnaryMB                 ; $ca8d mb
>1a32	93 11					.word	XUnaryMX                 ; $ca8e mx
>1a34	a4 11					.word	XUnaryMY                 ; $ca8f my
>1a36	73 15					.word	CommandRestore           ; $ca90 restore
>1a38	a2 16					.word	CommandStop              ; $ca91 stop
>1a3a	ff 17					.word	CommandSYS               ; $ca92 sys
>1a3c	a7 18					.word	CommandTIWrite           ; $ca93 ti$.write
>1a3e	74 1a					.word	CommandXWAIT             ; $ca94 wait
>1a40	bf 1b					.word	X16I2CPoke               ; $ca95 i2cpoke
>1a42	df 1b					.word	X16I2CPeek               ; $ca96 i2cpeek
>1a44	4a 1c					.word	CommandBank              ; $ca97 bank
>1a46	9d 1c					.word	XCommandSleep            ; $ca98 sleep
>1a48	c1 1c					.word	X16_Audio_FMINIT         ; $ca99 fminit
>1a4a	cf 1c					.word	X16_Audio_FMNOTE         ; $ca9a fmnote
>1a4c	e1 1c					.word	X16_Audio_FMDRUM         ; $ca9b fmdrum
>1a4e	f3 1c					.word	X16_Audio_FMINST         ; $ca9c fminst
>1a50	05 1d					.word	X16_Audio_FMVIB          ; $ca9d fmvib
>1a52	17 1d					.word	X16_Audio_FMFREQ         ; $ca9e fmfreq
>1a54	28 1d					.word	X16_Audio_FMVOL          ; $ca9f fmvol
>1a56	3a 1d					.word	X16_Audio_FMPAN          ; $caa0 fmpan
>1a58	4c 1d					.word	X16_Audio_FMPLAY         ; $caa1 fmplay
>1a5a	5d 1d					.word	X16_Audio_FMCHORD        ; $caa2 fmchord
>1a5c	6e 1d					.word	X16_Audio_FMPOKE         ; $caa3 fmpoke
>1a5e	80 1d					.word	X16_Audio_PSGINIT        ; $caa4 psginit
>1a60	8e 1d					.word	X16_Audio_PSGNOTE        ; $caa5 psgnote
>1a62	a0 1d					.word	X16_Audio_PSGVOL         ; $caa6 psgvol
>1a64	b2 1d					.word	X16_Audio_PSGWAV         ; $caa7 psgwav
>1a66	c4 1d					.word	X16_Audio_PSGFREQ        ; $caa8 psgfreq
>1a68	d5 1d					.word	X16_Audio_PSGPAN         ; $caa9 psgpan
>1a6a	e7 1d					.word	X16_Audio_PSGPLAY        ; $caaa psgplay
>1a6c	f8 1d					.word	X16_Audio_PSGCHORD       ; $caab psgchord
>1a6e	09 1e					.word	CommandCls               ; $caac cls
>1a70	12 1e					.word	CommandLocate            ; $caad locate
>1a72	3c 1e					.word	CommandColor             ; $caae color
.1a74					CommandXWAIT:
.1a74	fa		plx				plx
.1a75	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1a77	85 2c		sta $2c				sta 	zTemp0
.1a79	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1a7b	85 2d		sta $2d				sta 	zTemp0+1
.1a7d					_WaitLoop:
.1a7d	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1a7f	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1a81	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1a83	f0 f8		beq $1a7d			beq 	_WaitLoop 					; keep going if zero
.1a85	ca		dex				dex 								; drop 3.
.1a86	ca		dex				dex
.1a87	ca		dex				dex
.1a88	4c 3f 08	jmp $083f			jmp 	NextCommand
.1a8b					WriteFloatCommand:
.1a8b	fa		plx				plx
.1a8c	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1a8e	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1a90	88		dey				dey 								; get the upper 3 bits
.1a91	b1 28		lda ($28),y			lda 	(codePtr),y
.1a93	29 07		and #$07			and 	#7
.1a95	c8		iny				iny
.1a96	c8		iny				iny
.1a97	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1a99	2a		rol a				rol 	a 							; carry will be clear.
.1a9a	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1a9d	85 2d		sta $2d				sta 	zTemp0+1
.1a9f	20 a5 1a	jsr $1aa5			jsr 	WriteFloatZTemp0Sub
.1aa2	4c 3f 08	jmp $083f			jmp 	NextCommand
.1aa5					WriteFloatZTemp0Sub:
.1aa5	5a		phy				phy 								; ldart write
.1aa6	a0 01		ldy #$01			ldy 	#1
.1aa8	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1aaa	92 2c		sta ($2c)			sta 	(zTemp0)
.1aac	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1aae	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ab0	c8		iny				iny
.1ab1	b5 56		lda $56,x			lda 	NSMantissa2,x
.1ab3	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ab5	c8		iny				iny
.1ab6	b5 62		lda $62,x			lda 	NSMantissa3,x
.1ab8	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1aba	c8		iny				iny
.1abb	b5 6e		lda $6e,x			lda 	NSExponent,x
.1abd	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1abf	c8		iny				iny
.1ac0	b5 32		lda $32,x			lda 	NSStatus,x
.1ac2	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ac4	ca		dex				dex
.1ac5	7a		ply				ply
.1ac6	60		rts				rts
.1ac7					WriteIntegerCommand:
.1ac7	fa		plx				plx
.1ac8	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1aca	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1acc	88		dey				dey 								; get the upper 3 bits
.1acd	b1 28		lda ($28),y			lda 	(codePtr),y
.1acf	29 07		and #$07			and 	#7
.1ad1	c8		iny				iny
.1ad2	c8		iny				iny
.1ad3	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1ad5	2a		rol a				rol 	a 							; carry will be clear.
.1ad6	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1ad9	85 2d		sta $2d				sta 	zTemp0+1
.1adb	20 e1 1a	jsr $1ae1			jsr 	WriteIntegerZTemp0Sub
.1ade	4c 3f 08	jmp $083f			jmp 	NextCommand
.1ae1					WriteIntegerZTemp0Sub:
.1ae1	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.1ae4	5a		phy				phy 								; start write
.1ae5	a0 01		ldy #$01			ldy 	#1
.1ae7	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1ae9	30 0b		bmi $1af6			bmi 	_WIZNegative
.1aeb	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1aed	92 2c		sta ($2c)			sta 	(zTemp0)
.1aef	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1af1	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1af3	7a		ply				ply
.1af4	ca		dex				dex
.1af5	60		rts				rts
.1af6					_WIZNegative:
.1af6	38		sec				sec 								; -ve read
.1af7	a9 00		lda #$00			lda 	#0
.1af9	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1afb	92 2c		sta ($2c)			sta 	(zTemp0)
.1afd	a9 00		lda #$00			lda 	#0
.1aff	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1b01	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b03	7a		ply				ply
.1b04	ca		dex				dex
.1b05	60		rts				rts
.1b06					WriteStringCommand:
.1b06	fa		plx				plx
.1b07	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b09	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b0b	88		dey				dey 								; get the upper 3 bits
.1b0c	b1 28		lda ($28),y			lda 	(codePtr),y
.1b0e	29 07		and #$07			and 	#7
.1b10	c8		iny				iny
.1b11	c8		iny				iny
.1b12	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b14	2a		rol a				rol 	a 							; carry will be clear.
.1b15	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b18	85 2d		sta $2d				sta 	zTemp0+1
.1b1a	20 20 1b	jsr $1b20			jsr 	WriteStringZTemp0Sub
.1b1d	4c 3f 08	jmp $083f			jmp 	NextCommand
.1b20					WriteStringZTemp0Sub:
.1b20	5a		phy				phy
.1b21	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b23	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b25	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b27	f0 1e		beq $1b47			beq 	_WSConcrete
.1b29	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b2b	85 2e		sta $2e				sta 	zTemp1
.1b2d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b2f	85 2f		sta $2f				sta 	zTemp1+1
.1b31	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b33	85 30		sta $30				sta 	zTemp2
.1b35	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b37	85 31		sta $31				sta 	zTemp2+1
.1b39	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1b3b	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1b3d	b0 17		bcs $1b56			bcs 	_WSCopy
.1b3f	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1b41	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b43	09 80		ora #$80			ora 	#$80
.1b45	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1b47					_WSConcrete:
.1b47	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1b49	a8		tay				tay
.1b4a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b4c	20 eb 0a	jsr $0aeb			jsr 	StringConcrete
.1b4f	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1b51	98		tya				tya
.1b52	a0 01		ldy #$01			ldy 	#1
.1b54	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b56					_WSCopy
.1b56	18		clc				clc  								; copy target+2 to zTemp2
.1b57	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b59	69 02		adc #$02			adc 	#2
.1b5b	85 30		sta $30				sta 	zTemp2
.1b5d	a0 01		ldy #$01			ldy 	#1
.1b5f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b61	69 00		adc #$00			adc 	#0
.1b63	85 31		sta $31				sta 	zTemp2+1
.1b65	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1b67	85 2e		sta $2e				sta 	zTemp1
.1b69	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b6b	85 2f		sta $2f				sta 	zTemp1+1
.1b6d	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1b6f	a8		tay				tay
.1b70					_WSCopyLoop:
.1b70	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b72	91 30		sta ($30),y			sta 	(zTemp2),y
.1b74	88		dey				dey
.1b75	c0 ff		cpy #$ff			cpy 	#$FF
.1b77	d0 f7		bne $1b70			bne 	_WSCopyLoop
.1b79	ca		dex				dex
.1b7a	7a		ply				ply
.1b7b	60		rts				rts
.1b7c					CommandClose:
.1b7c	fa		plx				plx
.1b7d	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; channel to close
.1b80	cd 5d 04	cmp $045d			cmp 	currentChannel 				; is it the current channel
.1b83	d0 03		bne $1b88			bne 	_CCNotCurrent
.1b85	9c 5d 04	stz $045d			stz 	currentChannel 				; effectively disables CMD
.1b88					_CCNotCurrent:
.1b88	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1b8b	4c 3f 08	jmp $083f			jmp 	NextCommand
.1b8e					CommandExit:
.1b8e	fa		plx				plx
.1b8f	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1b91	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1b94					CommandDebug:
.1b94	fa		plx				plx
>1b95	db						.byte 	$DB 						; causes a break in the emulator
.1b96	4c 3f 08	jmp $083f			jmp 	NextCommand
.1b99					XGetCharacterFromChannel:
.1b99	da		phx				phx
.1b9a	5a		phy				phy
.1b9b	e0 00		cpx #$00			cpx 	#0 							; is it default
.1b9d	d0 05		bne $1ba4			bne 	_XGetChannel
.1b9f	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1ba2	80 08		bra $1bac			bra 	_XGetChar
.1ba4					_XGetChannel:
.1ba4	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1ba7	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1baa	d0 06		bne $1bb2			bne 	_XGCError
.1bac					_XGetChar:
.1bac	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1baf	7a		ply				ply
.1bb0	fa		plx				plx
.1bb1	60		rts				rts
.1bb2					_XGCError:
.1bb2	4c e1 1f	jmp $1fe1		jmp	ErrorV_channel
.1bb5					XGetHPos:
.1bb5	da		phx				phx
.1bb6	5a		phy				phy
.1bb7	38		sec				sec
.1bb8	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1bbb	98		tya				tya
.1bbc	7a		ply				ply
.1bbd	fa		plx				plx
.1bbe	60		rts				rts
.1bbf					X16I2CPoke:
.1bbf	fa		plx				plx
.1bc0	5a		phy				phy
.1bc1	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; value
.1bc4	48		pha				pha
.1bc5	ca		dex				dex
.1bc6	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; register
.1bc9	48		pha				pha
.1bca	ca		dex				dex
.1bcb	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; device
.1bce	aa		tax				tax
.1bcf	7a		ply				ply
.1bd0	68		pla				pla
.1bd1	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1bd4	b0 06		bcs $1bdc			bcs 	X16I2CError
.1bd6	7a		ply				ply
.1bd7	a2 ff		ldx #$ff			ldx 	#$FF
.1bd9	4c 3f 08	jmp $083f			jmp 	NextCommand
.1bdc					X16I2CError:
.1bdc	4c e1 1f	jmp $1fe1		jmp	ErrorV_channel
.1bdf					X16I2CPeek:
.1bdf	fa		plx				plx
.1be0	da		phx				phx
.1be1	5a		phy				phy
.1be2	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; register
.1be5	48		pha				pha
.1be6	ca		dex				dex
.1be7	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; device
.1bea	aa		tax				tax 								; X device
.1beb	7a		ply				ply 								; Y register
.1bec	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1bef	b0 eb		bcs $1bdc			bcs 	X16I2CError
.1bf1	7a		ply				ply 								; restore Y/X
.1bf2	fa		plx				plx
.1bf3	ca		dex				dex 								; drop TOS (register)
.1bf4	20 2a 26	jsr $262a			jsr 	FloatSetByte 				; write read value to TOS.
.1bf7	4c 3f 08	jmp $083f			jmp 	NextCommand
.1bfa					CommandXOpen:
.1bfa	fa		plx				plx
.1bfb	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1bfd	85 2c		sta $2c				sta 	zTemp0
.1bff	aa		tax				tax
.1c00	a5 4d		lda $4d				lda 	NSMantissa1+3
.1c02	85 2d		sta $2d				sta 	zTemp0+1
.1c04	a8		tay				tay
.1c05	e8		inx				inx 								; XY points to first character
.1c06	d0 01		bne $1c09			bne 	_CONoCarry
.1c08	c8		iny				iny
.1c09					_CONoCarry:
.1c09	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c0b	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c0e	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c10	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c12	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c14	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c17	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c1a	b0 03		bcs $1c1f			bcs 	_COError
.1c1c	4c 3f 08	jmp $083f			jmp 	NextCommand
.1c1f					_COError:
.1c1f	4c e1 1f	jmp $1fe1		jmp	ErrorV_channel
.1c22					XPokeMemory:
.1c22	86 2c		stx $2c				stx 	zTemp0
.1c24	84 2d		sty $2d				sty 	zTemp0+1
.1c26	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c28	ae 6b 05	ldx $056b			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c2b	e0 ff		cpx #$ff			cpx 	#$FF
.1c2d	f0 02		beq $1c31			beq 	_XPMNoSwitch
.1c2f	86 00		stx $00				stx 	SelectRAMBank
.1c31					_XPMNoSwitch:
.1c31	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1c33	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1c35					_XPMExit:
.1c35	60		rts				rts
.1c36					XPeekMemory:
.1c36	86 2c		stx $2c				stx 	zTemp0
.1c38	84 2d		sty $2d				sty 	zTemp0+1
.1c3a	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c3c	ae 6b 05	ldx $056b			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c3f	e0 ff		cpx #$ff			cpx 	#$FF
.1c41	f0 02		beq $1c45			beq 	_XPMNoSwitch
.1c43	86 00		stx $00				stx 	SelectRAMBank
.1c45					_XPMNoSwitch:
.1c45	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1c47	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1c49	60		rts				rts
.1c4a					CommandBank:
.1c4a	fa		plx				plx
.1c4b	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1c4d	8d 6b 05	sta $056b			sta 	ramBank 					; store & make current
.1c50	85 00		sta $00				sta 	SelectRAMBank
.1c52	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1c54	c9 ff		cmp #$ff			cmp 	#$FF
.1c56	f0 03		beq $1c5b			beq 	_CBNoUpdate
.1c58	8d 6c 05	sta $056c			sta 	romBank 					; this doesn't set the hardware page.
.1c5b					_CBNoUpdate:
.1c5b	a2 ff		ldx #$ff			ldx 	#$FF
.1c5d	4c 3f 08	jmp $083f			jmp 	NextCommand
.056b					ramBank:
>056b							.fill 	1
.056c					romBank:
>056c							.fill 	1
.1c60					XPrintCharacterToChannel:
.1c60	48		pha				pha
.1c61	da		phx				phx
.1c62	5a		phy				phy
.1c63	48		pha				pha  								; save char
.1c64	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1c66	d0 05		bne $1c6d			bne 	_XPCNotDefault
.1c68	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1c6b	80 08		bra $1c75			bra 	_XPCSend
.1c6d					_XPCNotDefault:
.1c6d	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1c70	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1c73	d0 08		bne $1c7d			bne 	_XPCError
.1c75					_XPCSend:
.1c75	68		pla				pla 								; restore character
.1c76	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1c79	7a		ply				ply
.1c7a	fa		plx				plx
.1c7b	68		pla				pla
.1c7c	60		rts				rts
.1c7d					_XPCError:
.1c7d	4c e1 1f	jmp $1fe1		jmp	ErrorV_channel
.1c80					XReadClock:
.1c80	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1c83	60		rts				rts
.1c84					XWriteClock:
.1c84	48		pha				pha
.1c85	da		phx				phx
.1c86	5a		phy				phy
.1c87	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1c8a	7a		ply				ply
.1c8b	fa		plx				plx
.1c8c	68		pla				pla
.1c8d	60		rts				rts
.1c8e					CommandScreen:
.1c8e	fa		plx				plx
.1c8f	da		phx				phx
.1c90	5a		phy				phy
.1c91	20 1b 10	jsr $101b			jsr 	GetInteger8Bit
.1c94	18		clc				clc
.1c95	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1c98	7a		ply				ply
.1c99	fa		plx				plx
.1c9a	4c 3f 08	jmp $083f			jmp 	NextCommand
.1c9d					XCommandSleep:
.1c9d	fa		plx				plx
.1c9e	5a		phy				phy
.1c9f	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.1ca2	ca		dex				dex
.1ca3	20 80 1c	jsr $1c80			jsr 	XReadClock 					; read clock to YXA
.1ca6	18		clc				clc 								; calculate end time in zTemp0
.1ca7	65 3e		adc $3e				adc 	NSMantissa0
.1ca9	85 2c		sta $2c				sta 	zTemp0
.1cab	8a		txa				txa
.1cac	65 4a		adc $4a				adc 	NSMantissa1
.1cae	85 2d		sta $2d				sta 	zTemp0+1
.1cb0					_XCWait:
.1cb0	20 80 1c	jsr $1c80			jsr 	XReadClock 					; and wait for it.
.1cb3	c5 2c		cmp $2c				cmp 	zTemp0
.1cb5	d0 f9		bne $1cb0			bne 	_XCWait
.1cb7	e4 2d		cpx $2d				cpx 	zTemp0+1
.1cb9	d0 f5		bne $1cb0			bne 	_XCWait
.1cbb	a2 ff		ldx #$ff			ldx 	#$FF
.1cbd	7a		ply				ply
.1cbe	4c 3f 08	jmp $083f			jmp 	NextCommand
.1cc1					X16_Audio_FMINIT:
.1cc1	fa		plx				plx
.1cc2	5a		phy			phy
.1cc3	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cc6	63 c0					.word	X16A_ym_init
>1cc8	0a					.byte	X16_AudioCodeBank
.1cc9	a2 ff		ldx #$ff		ldx	#$FF
.1ccb	7a		ply			ply
.1ccc	4c 3f 08	jmp $083f			jmp 	NextCommand
.1ccf					X16_Audio_FMNOTE:
.1ccf	fa		plx				plx
.1cd0	5a		phy			phy
.1cd1	20 e6 09	jsr $09e6		jsr		X16_Audio_Parameters8_8
.1cd4	18		clc			clc
.1cd5	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cd8	03 c0					.word	X16A_bas_fmnote
>1cda	0a					.byte	X16_AudioCodeBank
.1cdb	a2 ff		ldx #$ff		ldx	#$FF
.1cdd	7a		ply			ply
.1cde	4c 3f 08	jmp $083f			jmp 	NextCommand
.1ce1					X16_Audio_FMDRUM:
.1ce1	fa		plx				plx
.1ce2	5a		phy			phy
.1ce3	20 e6 09	jsr $09e6		jsr		X16_Audio_Parameters8_8
.1ce6	18		clc			clc
.1ce7	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cea	6f c0					.word	X16A_ym_playdrum
>1cec	0a					.byte	X16_AudioCodeBank
.1ced	a2 ff		ldx #$ff		ldx	#$FF
.1cef	7a		ply			ply
.1cf0	4c 3f 08	jmp $083f			jmp 	NextCommand
.1cf3					X16_Audio_FMINST:
.1cf3	fa		plx				plx
.1cf4	5a		phy			phy
.1cf5	20 e6 09	jsr $09e6		jsr		X16_Audio_Parameters8_8
.1cf8	38		sec			sec
.1cf9	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cfc	69 c0					.word	X16A_ym_loadpatch
>1cfe	0a					.byte	X16_AudioCodeBank
.1cff	a2 ff		ldx #$ff		ldx	#$FF
.1d01	7a		ply			ply
.1d02	4c 3f 08	jmp $083f			jmp 	NextCommand
.1d05					X16_Audio_FMVIB:
.1d05	fa		plx				plx
.1d06	5a		phy			phy
.1d07	20 e6 09	jsr $09e6		jsr		X16_Audio_Parameters8_8
.1d0a	18		clc			clc
.1d0b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d0e	09 c0					.word	X16A_bas_fmvib
>1d10	0a					.byte	X16_AudioCodeBank
.1d11	a2 ff		ldx #$ff		ldx	#$FF
.1d13	7a		ply			ply
.1d14	4c 3f 08	jmp $083f			jmp 	NextCommand
.1d17					X16_Audio_FMFREQ:
.1d17	fa		plx				plx
.1d18	5a		phy			phy
.1d19	20 e0 09	jsr $09e0		jsr		X16_Audio_Parameters8_16
.1d1c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d1f	00 c0					.word	X16A_bas_fmfreq
>1d21	0a					.byte	X16_AudioCodeBank
.1d22	a2 ff		ldx #$ff		ldx	#$FF
.1d24	7a		ply			ply
.1d25	4c 3f 08	jmp $083f			jmp 	NextCommand
.1d28					X16_Audio_FMVOL:
.1d28	fa		plx				plx
.1d29	5a		phy			phy
.1d2a	20 e6 09	jsr $09e6		jsr		X16_Audio_Parameters8_8
.1d2d	18		clc			clc
.1d2e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d31	75 c0					.word	X16A_ym_setatten
>1d33	0a					.byte	X16_AudioCodeBank
.1d34	a2 ff		ldx #$ff		ldx	#$FF
.1d36	7a		ply			ply
.1d37	4c 3f 08	jmp $083f			jmp 	NextCommand
.1d3a					X16_Audio_FMPAN:
.1d3a	fa		plx				plx
.1d3b	5a		phy			phy
.1d3c	20 e6 09	jsr $09e6		jsr		X16_Audio_Parameters8_8
.1d3f	18		clc			clc
.1d40	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d43	7e c0					.word	X16A_ym_setpan
>1d45	0a					.byte	X16_AudioCodeBank
.1d46	a2 ff		ldx #$ff		ldx	#$FF
.1d48	7a		ply			ply
.1d49	4c 3f 08	jmp $083f			jmp 	NextCommand
.1d4c					X16_Audio_FMPLAY:
.1d4c	fa		plx				plx
.1d4d	5a		phy			phy
.1d4e	20 f7 09	jsr $09f7		jsr		X16_Audio_Parameters8_String
.1d51	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d54	06 c0					.word	X16A_bas_fmplaystring
>1d56	0a					.byte	X16_AudioCodeBank
.1d57	a2 ff		ldx #$ff		ldx	#$FF
.1d59	7a		ply			ply
.1d5a	4c 3f 08	jmp $083f			jmp 	NextCommand
.1d5d					X16_Audio_FMCHORD:
.1d5d	fa		plx				plx
.1d5e	5a		phy			phy
.1d5f	20 f7 09	jsr $09f7		jsr		X16_Audio_Parameters8_String
.1d62	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d65	8d c0					.word	X16A_bas_fmchordstring
>1d67	0a					.byte	X16_AudioCodeBank
.1d68	a2 ff		ldx #$ff		ldx	#$FF
.1d6a	7a		ply			ply
.1d6b	4c 3f 08	jmp $083f			jmp 	NextCommand
.1d6e					X16_Audio_FMPOKE:
.1d6e	fa		plx				plx
.1d6f	5a		phy			phy
.1d70	20 e6 09	jsr $09e6		jsr		X16_Audio_Parameters8_8
.1d73	18		clc			clc
.1d74	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d77	8a c0					.word	X16A_ym_write
>1d79	0a					.byte	X16_AudioCodeBank
.1d7a	a2 ff		ldx #$ff		ldx	#$FF
.1d7c	7a		ply			ply
.1d7d	4c 3f 08	jmp $083f			jmp 	NextCommand
.1d80					X16_Audio_PSGINIT:
.1d80	fa		plx				plx
.1d81	5a		phy			phy
.1d82	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d85	4b c0					.word	X16A_psg_init
>1d87	0a					.byte	X16_AudioCodeBank
.1d88	a2 ff		ldx #$ff		ldx	#$FF
.1d8a	7a		ply			ply
.1d8b	4c 3f 08	jmp $083f			jmp 	NextCommand
.1d8e					X16_Audio_PSGNOTE:
.1d8e	fa		plx				plx
.1d8f	5a		phy			phy
.1d90	20 e6 09	jsr $09e6		jsr		X16_Audio_Parameters8_8
.1d93	18		clc			clc
.1d94	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d97	12 c0					.word	X16A_bas_psgnote
>1d99	0a					.byte	X16_AudioCodeBank
.1d9a	a2 ff		ldx #$ff		ldx	#$FF
.1d9c	7a		ply			ply
.1d9d	4c 3f 08	jmp $083f			jmp 	NextCommand
.1da0					X16_Audio_PSGVOL:
.1da0	fa		plx				plx
.1da1	5a		phy			phy
.1da2	20 e6 09	jsr $09e6		jsr		X16_Audio_Parameters8_8
.1da5	18		clc			clc
.1da6	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1da9	54 c0					.word	X16A_psg_setatten
>1dab	0a					.byte	X16_AudioCodeBank
.1dac	a2 ff		ldx #$ff		ldx	#$FF
.1dae	7a		ply			ply
.1daf	4c 3f 08	jmp $083f			jmp 	NextCommand
.1db2					X16_Audio_PSGWAV:
.1db2	fa		plx				plx
.1db3	5a		phy			phy
.1db4	20 e6 09	jsr $09e6		jsr		X16_Audio_Parameters8_8
.1db7	18		clc			clc
.1db8	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dbb	15 c0					.word	X16A_bas_psgwav
>1dbd	0a					.byte	X16_AudioCodeBank
.1dbe	a2 ff		ldx #$ff		ldx	#$FF
.1dc0	7a		ply			ply
.1dc1	4c 3f 08	jmp $083f			jmp 	NextCommand
.1dc4					X16_Audio_PSGFREQ:
.1dc4	fa		plx				plx
.1dc5	5a		phy			phy
.1dc6	20 e0 09	jsr $09e0		jsr		X16_Audio_Parameters8_16
.1dc9	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dcc	0f c0					.word	X16A_bas_psgfreq
>1dce	0a					.byte	X16_AudioCodeBank
.1dcf	a2 ff		ldx #$ff		ldx	#$FF
.1dd1	7a		ply			ply
.1dd2	4c 3f 08	jmp $083f			jmp 	NextCommand
.1dd5					X16_Audio_PSGPAN:
.1dd5	fa		plx				plx
.1dd6	5a		phy			phy
.1dd7	20 e6 09	jsr $09e6		jsr		X16_Audio_Parameters8_8
.1dda	18		clc			clc
.1ddb	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dde	5a c0					.word	X16A_psg_setpan
>1de0	0a					.byte	X16_AudioCodeBank
.1de1	a2 ff		ldx #$ff		ldx	#$FF
.1de3	7a		ply			ply
.1de4	4c 3f 08	jmp $083f			jmp 	NextCommand
.1de7					X16_Audio_PSGPLAY:
.1de7	fa		plx				plx
.1de8	5a		phy			phy
.1de9	20 f7 09	jsr $09f7		jsr		X16_Audio_Parameters8_String
.1dec	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1def	18 c0					.word	X16A_bas_psgplaystring
>1df1	0a					.byte	X16_AudioCodeBank
.1df2	a2 ff		ldx #$ff		ldx	#$FF
.1df4	7a		ply			ply
.1df5	4c 3f 08	jmp $083f			jmp 	NextCommand
.1df8					X16_Audio_PSGCHORD:
.1df8	fa		plx				plx
.1df9	5a		phy			phy
.1dfa	20 f7 09	jsr $09f7		jsr		X16_Audio_Parameters8_String
.1dfd	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e00	90 c0					.word	X16A_bas_psgchordstring
>1e02	0a					.byte	X16_AudioCodeBank
.1e03	a2 ff		ldx #$ff		ldx	#$FF
.1e05	7a		ply			ply
.1e06	4c 3f 08	jmp $083f			jmp 	NextCommand
.1e09					CommandCls:
.1e09	fa		plx				plx
.1e0a	a9 93		lda #$93			lda 	#147
.1e0c	20 60 1c	jsr $1c60			jsr 	XPrintCharacterToChannel
.1e0f	4c 3f 08	jmp $083f			jmp 	NextCommand
.1e12					CommandLocate:
.1e12	fa		plx				plx
.1e13	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.1e16	ca		dex				dex
.1e17	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.1e1a	ca		dex				dex
.1e1b	a9 13		lda #$13			lda 	#$13 						; home.
.1e1d	20 60 1c	jsr $1c60			jsr 	XPrintCharacterToChannel
.1e20	a9 1d		lda #$1d			lda 	#$1D 						; do cursor rights
.1e22	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1e24	20 31 1e	jsr $1e31			jsr 	_CLOutputXA
.1e27	a9 11		lda #$11			lda 	#$11 						; do cursor downs.
.1e29	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e2b	20 31 1e	jsr $1e31			jsr 	_CLOutputXA
.1e2e	4c 3f 08	jmp $083f			jmp 	NextCommand
.1e31					_CLOutputXA:
.1e31	ca		dex				dex
.1e32	f0 07		beq $1e3b			beq 	_CLOExit
.1e34	30 05		bmi $1e3b			bmi 	_CLOExit
.1e36	20 60 1c	jsr $1c60			jsr 	XPrintCharacterToChannel
.1e39	80 f6		bra $1e31			bra 	_CLOutputXA
.1e3b					_CLOExit:
.1e3b	60		rts				rts
.1e3c					CommandColor:
.1e3c	fa		plx				plx
.1e3d	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.1e40	ca		dex				dex
.1e41	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.1e44	ca		dex				dex
.1e45	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1e47	c9 ff		cmp #$ff			cmp 	#$FF
.1e49	f0 08		beq $1e53			beq 	_CCNoBGR 					; if so, change background
.1e4b	20 5b 1e	jsr $1e5b			jsr 	_CCSetColour
.1e4e	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1e50	20 60 1c	jsr $1c60			jsr 	XPrintCharacterToChannel
.1e53					_CCNoBGR:
.1e53	a5 3e		lda $3e				lda 	NSMantissa0
.1e55	20 5b 1e	jsr $1e5b			jsr 	_CCSetColour
.1e58	4c 3f 08	jmp $083f			jmp 	NextCommand
.1e5b					_CCSetColour:
.1e5b	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1e5d	aa		tax				tax
.1e5e	bd 65 1e	lda $1e65,x			lda 	_CCCommandTable,x
.1e61	20 60 1c	jsr $1c60			jsr 	XPrintCharacterToChannel
.1e64	60		rts				rts
.1e65					_CCCommandTable:
>1e65	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1e6d	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1e75					CommandVPOKE:
.1e75	fa		plx				plx
.1e76	20 1b 10	jsr $101b			jsr 	GetInteger8Bit 				; poke value
.1e79	48		pha				pha
.1e7a	ca		dex				dex
.1e7b	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.1e7e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e80	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1e83	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1e85	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1e88	ca		dex				dex
.1e89	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.1e8c	20 1b 10	jsr $101b			jsr 	GetInteger8Bit
.1e8f	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1e92	ca		dex				dex
.1e93	68		pla				pla 								; poke value back
.1e94	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1e97	4c 3f 08	jmp $083f			jmp 	NextCommand
.1e9a					CommandVPEEK:
.1e9a	fa		plx				plx
.1e9b	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.1e9e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ea0	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1ea3	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ea5	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ea8	ca		dex				dex
.1ea9	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.1eac	20 1b 10	jsr $101b			jsr 	GetInteger8Bit
.1eaf	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1eb2	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1eb5	20 2a 26	jsr $262a			jsr 	FloatSetByte 				; return as byte
.1eb8	4c 3f 08	jmp $083f			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1ebb					SetErrorHandler:
.1ebb	8c 6e 05	sty $056e			sty 	ErrorHandlerVector+1
.1ebe	8e 6d 05	stx $056d			stx 	ErrorHandlerVector
.1ec1	60		rts				rts
.1ec2					CallErrorHandler:
.1ec2	6c 6d 05	jmp ($056d)			jmp 	(ErrorHandlerVector)
.056d					ErrorHandlerVector:
>056d							.fill 	2
.1ec5					ErrorV_range:
.1ec5	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1ec8	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1ed0	41 4e 47 45 00
.1ed5					ErrorV_value:
.1ed5	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1ed8	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1ee0	45 00
.1ee2					ErrorV_syntax:
.1ee2	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1ee5	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1eed	52 52 4f 52 00
.1ef2					ErrorV_type:
.1ef2	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1ef5	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1efd	4d 41 54 43 48 00
.1f03					ErrorV_unimplemented:
.1f03	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1f06	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f0e	45 4d 45 4e 54 45 44 00
.1f16					ErrorV_assert:
.1f16	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1f19	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f21	41 49 4c 00
.1f25					ErrorV_line:
.1f25	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1f28	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f30	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f3c					ErrorV_internal:
.1f3c	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1f3f	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f47	20 45 52 52 4f 52 00
.1f4e					ErrorV_divzero:
.1f4e	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1f51	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1f59	59 20 5a 45 52 4f 00
.1f60					ErrorV_structure:
.1f60	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1f63	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1f6b	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1f77					ErrorV_stop:
.1f77	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1f7a	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1f82	53 54 4f 50 50 45 44 00
.1f8a					ErrorV_data:
.1f8a	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1f8d	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1f95	41 54 41 00
.1f99					ErrorV_undeclared:
.1f99	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1f9c	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1fa4	41 52 52 41 59 00
.1faa					ErrorV_redefine:
.1faa	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1fad	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1fb5	44 45 46 49 4e 45 44 00
.1fbd					ErrorV_index:
.1fbd	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1fc0	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1fc8	59 20 49 4e 44 45 58 00
.1fd0					ErrorV_memory:
.1fd0	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1fd3	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>1fdb	45 4d 4f 52 59 00
.1fe1					ErrorV_channel:
.1fe1	20 c2 1e	jsr $1ec2		jsr	CallErrorHandler
>1fe4	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>1fec	54 50 55 54 20 45 52 52 4f 52 00
.1ff7					MoveObjectForward:
.1ff7	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.1ff9	c9 ff		cmp #$ff			cmp 	#$FF
.1ffb	f0 36		beq $2033			beq 	_MOFEnd
.1ffd	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.1fff	90 24		bcc $2025			bcc 	_MOFAdvance1 				; forward 1
.2001	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.2003	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2005	90 20		bcc $2027			bcc 	_MOFAdvanceY
.2007	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2009	90 1a		bcc $2025			bcc 	_MOFAdvance1 				; forward 1
.200b	a8		tay				tay 								; read the size.
.200c	b9 71 1f	lda $1f71,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.200f	a8		tay				tay
.2010	c8		iny				iny 								; add 1 for the system token.
.2011	d0 14		bne $2027			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2013	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2015	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2017	a8		tay				tay 								; into Y.
.2018	18		clc				clc
.2019	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.201b	69 02		adc #$02			adc 	#2
.201d	85 2a		sta $2a				sta 	objPtr
.201f	90 02		bcc $2023			bcc 	_MOFNoCarry1
.2021	e6 2b		inc $2b				inc 	objPtr+1
.2023					_MOFNoCarry1:
.2023	80 02		bra $2027			bra 	_MOFAdvanceY
.2025					_MOFAdvance1:
.2025	a0 01		ldy #$01			ldy 	#1
.2027					_MOFAdvanceY:
.2027	98		tya				tya 								; add Y to objPtr
.2028	18		clc				clc
.2029	65 2a		adc $2a				adc 	objPtr
.202b	85 2a		sta $2a				sta 	objPtr
.202d	90 02		bcc $2031			bcc 	_MOFNoCarry2
.202f	e6 2b		inc $2b				inc 	objPtr+1
.2031					_MOFNoCarry2:
.2031	18		clc				clc 								; not completed.
.2032	60		rts				rts
.2033					_MOFEnd:
.2033	e6 2a		inc $2a				inc 	objPtr
.2035	d0 02		bne $2039			bne 	_MOFENoCarry
.2037	e6 2b		inc $2b				inc 	objPtr+1
.2039					_MOFENoCarry:
.2039	38		sec				sec
.203a	60		rts				rts
.203b					MOFSizeTable:
>203b	01					.byte	1         	; $ca .shift
>203c	01					.byte	1         	; $cb .byte
>203d	02					.byte	2         	; $cc .word
>203e	05					.byte	5         	; $cd .float
>203f	ff					.byte	255       	; $ce .string
>2040	ff					.byte	255       	; $cf .data
>2041	02					.byte	2         	; $d0 .goto
>2042	02					.byte	2         	; $d1 .gosub
>2043	02					.byte	2         	; $d2 .goto.z
>2044	02					.byte	2         	; $d3 .goto.nz
>2045	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.056f					numberBuffer:
>056f							.fill 	34
.2046					FloatSubtract:
.2046	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.2048	49 80		eor #$80			eor 	#$80
.204a	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.204c					FloatAdd:
.204c	ca		dex				dex
.204d	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.204f	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2051	15 62		ora $62,x			ora 	NSMantissa3,x
.2053	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2055	d0 04		bne $205b			bne 	_FAUseFloat
.2057	20 e8 23	jsr $23e8			jsr 	FloatInt32Add 				; use the int32 one.
.205a	60		rts				rts
.205b					_FAUseFloat:
.205b	20 7d 23	jsr $237d			jsr 	FloatNormalise 				; normalise S[X]
.205e	f0 51		beq $20b1			beq 	_FAReturn1
.2060	e8		inx				inx 								; normalise S[X+1]
.2061	20 7d 23	jsr $237d			jsr 	FloatNormalise
.2064	ca		dex				dex
.2065	c9 00		cmp #$00			cmp 	#0
.2067	f0 60		beq $20c9			beq 	_FAExit 					; if so, just return A
.2069	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.206b	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.206d	f0 18		beq $2087			beq 	_FAExponentsEqual
.206f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.2071	a8		tay				tay
.2072	38		sec				sec 								; do a signed comparison of the exponents.
.2073	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.2075	50 02		bvc $2079			bvc 	_FANoSignedChange
.2077	49 80		eor #$80			eor 	#$80
.2079					_FANoSignedChange:
.2079	29 80		and #$80			and 	#$80
.207b	10 02		bpl $207f			bpl 	_FAHaveMax
.207d	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.207f					_FAHaveMax:
.207f	20 ca 20	jsr $20ca			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.2082	e8		inx				inx
.2083	20 ca 20	jsr $20ca			jsr 	_FAShiftToExponent
.2086	ca		dex				dex
.2087					_FAExponentsEqual:
.2087	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.2089	55 33		eor $33,x			eor 	NSStatus+1,x
.208b	30 0e		bmi $209b			bmi 	_FADifferentSigns
.208d	20 b4 23	jsr $23b4			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.2090	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.2092	10 35		bpl $20c9			bpl 	_FAExit 					; if no, we are done.
.2094	20 41 26	jsr $2641			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.2097	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.2099	80 2e		bra $20c9			bra 	_FAExit
.209b					_FADifferentSigns:
.209b	20 ce 23	jsr $23ce			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.209e	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.20a0	10 06		bpl $20a8			bpl 	_FACheckZero 				; if no, check for -0
.20a2	20 ea 25	jsr $25ea			jsr 	FloatNegate 					; netate result
.20a5	20 f1 25	jsr $25f1			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20a8					_FACheckZero:
.20a8	20 4a 26	jsr $264a			jsr 	FloatIsZero	 				; check for -0
.20ab	d0 1c		bne $20c9			bne 	_FAExit
.20ad	74 32		stz $32,x			stz 	NSStatus,x
.20af	80 18		bra $20c9			bra 	_FAExit
.20b1					_FAReturn1:
.20b1	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20b3	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20b5	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.20b7	95 4a		sta $4a,x			sta 	NSMantissa1,x
.20b9	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.20bb	95 56		sta $56,x			sta 	NSMantissa2,x
.20bd	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.20bf	95 62		sta $62,x			sta 	NSMantissa3,x
.20c1	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.20c3	95 6e		sta $6e,x			sta 	NSExponent,x
.20c5	b5 33		lda $33,x			lda 	NSStatus+1,x
.20c7	95 32		sta $32,x			sta 	NSStatus,x
.20c9					_FAExit:
.20c9	60		rts				rts
.20ca					_FAShiftToExponent:
.20ca					_FAShiftToExponent2:
.20ca	98		tya				tya 								; compare Y to exponent
.20cb	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.20cd	f0 07		beq $20d6			beq 	_FASEExit 					; exit if so.
.20cf	20 41 26	jsr $2641			jsr 	FloatShiftRight	 			; shift the mantissa right
.20d2	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.20d4	80 f4		bra $20ca			bra 	_FAShiftToExponent2
.20d6					_FASEExit:
.20d6	60		rts				rts
.20d7					CompareEqual:
.20d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20d9	d0 09		bne $20e4			bne 	ReturnFalse
.20db					ReturnTrue:
.20db	a9 01		lda #$01			lda 	#1
.20dd	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20df	a9 80		lda #$80			lda 	#$80
.20e1	95 32		sta $32,x			sta 	NSStatus,x
.20e3	60		rts				rts
.20e4					ReturnFalse:
.20e4	74 3e		stz $3e,x			stz 	NSMantissa0,x
.20e6	60		rts				rts
.20e7					CompareNotEqual:
.20e7	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20e9	d0 f0		bne $20db			bne 	ReturnTrue
.20eb	80 f7		bra $20e4			bra 	ReturnFalse
.20ed					CompareLess:
.20ed	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20ef	c9 ff		cmp #$ff			cmp 	#$FF
.20f1	f0 e8		beq $20db			beq 	ReturnTrue
.20f3	80 ef		bra $20e4			bra 	ReturnFalse
.20f5					CompareGreater:
.20f5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20f7	c9 01		cmp #$01			cmp 	#$01
.20f9	f0 e0		beq $20db			beq 	ReturnTrue
.20fb	80 e7		bra $20e4			bra 	ReturnFalse
.20fd					CompareLessEqual:
.20fd	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20ff	c9 01		cmp #$01			cmp 	#$01
.2101	d0 d8		bne $20db			bne 	ReturnTrue
.2103	80 df		bra $20e4			bra 	ReturnFalse
.2105					CompareGreaterEqual:
.2105	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2107	c9 ff		cmp #$ff			cmp 	#$FF
.2109	d0 d0		bne $20db			bne 	ReturnTrue
.210b	80 d7		bra $20e4			bra 	ReturnFalse
.210d					FloatCompare:
.210d	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.210f	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.2111	48		pha				pha
.2112	20 46 20	jsr $2046			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2115	68		pla				pla
.2116	d0 0c		bne $2124			bne 	_FCCompareFloat
.2118	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.211a	15 4a		ora $4a,x			ora 	NSMantissa1,x
.211c	15 56		ora $56,x			ora 	NSMantissa2,x
.211e	15 62		ora $62,x			ora 	NSMantissa3,x
.2120	f0 14		beq $2136			beq 	_FCExit 					; if zero, return zero
.2122	80 0a		bra $212e			bra 	_FCSign
.2124					_FCCompareFloat:
.2124	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2126	29 f0		and #$f0			and 	#$F0
.2128	15 56		ora $56,x			ora 	NSMantissa2,x
.212a	15 62		ora $62,x			ora 	NSMantissa3,x
.212c	f0 08		beq $2136			beq 	_FCExit 					; zero, so approximately identical
.212e					_FCSign:
.212e	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2130	34 32		bit $32,x			bit 	NSStatus,x
.2132	10 02		bpl $2136			bpl 	_FCExit
.2134					_FCNegative:
.2134	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2136					_FCExit:
.2136	20 2a 26	jsr $262a			jsr 	FloatSetByte 				; set the result 255,0,1
.2139	60		rts				rts
.213a					FloatScalarTable:
>213a	66 66 66 66				.dword $66666666 ; 0.1
>213e	de					.byte $de
>213f	1f 85 eb 51				.dword $51eb851f ; 0.01
>2143	db					.byte $db
>2144	4c 37 89 41				.dword $4189374c ; 0.001
>2148	d8					.byte $d8
>2149	ac 8b db 68				.dword $68db8bac ; 0.0001
>214d	d4					.byte $d4
>214e	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>2152	d1					.byte $d1
>2153	83 de 1b 43				.dword $431bde83 ; 1e-06
>2157	ce					.byte $ce
>2158	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>215c	ca					.byte $ca
>215d	89 3b e6 55				.dword $55e63b89 ; 1e-08
>2161	c7					.byte $c7
>2162	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>2166	c4					.byte $c4
>2167	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>216b	c0					.byte $c0
>216c	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>2170	bd					.byte $bd
.2171					FloatDivide:
.2171	48		pha				pha
.2172	20 7d 23	jsr $237d			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2175	ca		dex				dex
.2176	c9 00		cmp #$00			cmp 	#0
.2178	f0 1e		beq $2198			beq 	_FDZero
.217a	20 7d 23	jsr $237d			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.217d	f0 16		beq $2195			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.217f	20 e0 21	jsr $21e0			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.2182	20 ad 21	jsr $21ad			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.2185	20 7d 23	jsr $237d			jsr		FloatNormalise 				; renormalise
.2188	20 73 23	jsr $2373			jsr 	FloatCalculateSign 			; calculate result sign
.218b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.218d	38		sec				sec
.218e	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.2190	38		sec				sec
.2191	e9 1e		sbc #$1e			sbc 	#30
.2193	95 6e		sta $6e,x			sta 	NSExponent,x
.2195					_FDExit:
.2195	68		pla				pla
.2196	18		clc				clc
.2197	60		rts				rts
.2198					_FDZero:
.2198	68		pla				pla
.2199	38		sec				sec
.219a	60		rts				rts
.219b					DivideInt32:
.219b	20 63 22	jsr $2263			jsr 	FloatIntegerPart 			; make both integers
.219e	ca		dex				dex
.219f	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.21a2	20 be 21	jsr $21be			jsr 	Int32Divide 				; divide
.21a5	20 ad 21	jsr $21ad			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21a8	20 73 23	jsr $2373			jsr 	FloatCalculateSign 			; calculate result sign
.21ab	18		clc				clc
.21ac	60		rts				rts
.21ad					NSMCopyPlusTwoToZero:
.21ad	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21af	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21b1	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21b3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.21b5	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.21b7	95 56		sta $56,x			sta 	NSMantissa2,x
.21b9	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.21bb	95 62		sta $62,x			sta 	NSMantissa3,x
.21bd	60		rts				rts
.21be					Int32Divide:
.21be	48		pha				pha 								; save AXY
.21bf	5a		phy				phy
.21c0	20 0b 26	jsr $260b			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.21c3	20 24 26	jsr $2624			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.21c6	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.21c8					_I32DivideLoop:
.21c8	e8		inx				inx
.21c9	e8		inx				inx
.21ca	20 37 26	jsr $2637			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.21cd	ca		dex				dex
.21ce	ca		dex				dex
.21cf	20 38 26	jsr $2638			jsr 	FloatRotateLeft
.21d2	20 fe 21	jsr $21fe			jsr 	FloatDivideCheck 			; check if subtract possible
.21d5	90 02		bcc $21d9			bcc 	_I32DivideNoCarryIn
.21d7	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.21d9					_I32DivideNoCarryIn:
.21d9	88		dey				dey 								; loop round till division completed.
.21da	d0 ec		bne $21c8			bne 	_I32DivideLoop
.21dc	7a		ply				ply 								; restore AXY and exit
.21dd	68		pla				pla
.21de	18		clc				clc
.21df	60		rts				rts
.21e0					Int32ShiftDivide:
.21e0	48		pha				pha 								; save AY
.21e1	5a		phy				phy
.21e2	e8		inx				inx 								; clear S[X+2]
.21e3	e8		inx				inx
.21e4	20 28 26	jsr $2628			jsr 	FloatSetZero
.21e7	ca		dex				dex
.21e8	ca		dex				dex
.21e9	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.21eb					_I32SDLoop:
.21eb	20 fe 21	jsr $21fe			jsr 	FloatDivideCheck 			; check if subtract possible
.21ee	e8		inx				inx
.21ef	e8		inx				inx
.21f0	20 38 26	jsr $2638			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.21f3	ca		dex				dex
.21f4	ca		dex				dex
.21f5	20 38 26	jsr $2638			jsr 	FloatRotateLeft
.21f8	88		dey				dey 	 							; do 31 times
.21f9	d0 f0		bne $21eb			bne 	_I32SDLoop
.21fb	7a		ply				ply 								; restore AY and exit
.21fc	68		pla				pla
.21fd	60		rts				rts
.21fe					FloatDivideCheck:
.21fe	20 ce 23	jsr $23ce			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.2201	b0 04		bcs $2207			bcs 	_DCSExit 					; if carry set, then could do, exit
.2203	20 b4 23	jsr $23b4			jsr 	FloatAddTopTwoStack 		; add it back in
.2206	18		clc				clc 								; and return False
.2207					_DCSExit:
.2207	60		rts				rts
.2208					FloatFractionalPart:
.2208	5a		phy				phy
.2209	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.220b	29 7f		and #$7f			and 	#$7F
.220d	95 32		sta $32,x			sta 	NSStatus,x
.220f	20 7d 23	jsr $237d			jsr 	FloatNormalise
.2212	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2214	38		sec				sec
.2215	e9 e0		sbc #$e0			sbc 	#$E0
.2217	90 29		bcc $2242			bcc 	_FFPExit 					; already fractional
.2219	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.221b	b0 22		bcs $223f			bcs 	_FFPZero
.221d	a8		tay				tay 								; put count to do in Y
.221e	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.2220	20 47 22	jsr $2247			jsr 	_FFPPartial
.2223	95 62		sta $62,x			sta 	NSMantissa3,x
.2225	b5 56		lda $56,x			lda 	NSMantissa2,x
.2227	20 47 22	jsr $2247			jsr 	_FFPPartial
.222a	95 56		sta $56,x			sta 	NSMantissa2,x
.222c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.222e	20 47 22	jsr $2247			jsr 	_FFPPartial
.2231	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2233	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2235	20 47 22	jsr $2247			jsr 	_FFPPartial
.2238	95 3e		sta $3e,x			sta 	NSMantissa0,x
.223a	20 4a 26	jsr $264a			jsr 	FloatIsZero 					; zeroed check.
.223d	d0 03		bne $2242			bne 	_FFPExit
.223f					_FFPZero:
.223f	20 28 26	jsr $2628			jsr 	FloatSetZero
.2242					_FFPExit:
.2242	20 7d 23	jsr $237d			jsr 	FloatNormalise
.2245	7a		ply				ply
.2246	60		rts				rts
.2247					_FFPPartial:
.2247	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2249	f0 17		beq $2262			beq 	_FFFPPExit
.224b	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.224d	b0 0c		bcs $225b			bcs 	_FFFPPWholeByte
.224f	5a		phy				phy
.2250					_FFFPPLeft:
.2250	0a		asl a				asl 	a
.2251	88		dey				dey
.2252	d0 fc		bne $2250			bne 	_FFFPPLeft
.2254	7a		ply				ply
.2255					_FFFPPRight:
.2255	4a		lsr a				lsr 	a
.2256	88		dey				dey
.2257	d0 fc		bne $2255			bne 	_FFFPPRight
.2259	80 07		bra $2262			bra 	_FFFPPExit
.225b					_FFFPPWholeByte:
.225b	98		tya				tya 								; subtract 8 from count
.225c	38		sec				sec
.225d	e9 08		sbc #$08			sbc 	#8
.225f	a8		tay				tay
.2260	a9 00		lda #$00			lda 	#0 							; and clear all
.2262					_FFFPPExit:
.2262	60		rts				rts
.2263					FloatIntegerPart:
.2263	48		pha				pha
.2264	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.2266	f0 1d		beq $2285			beq 	_FIPExit 					; if so do nothing
.2268	20 4a 26	jsr $264a			jsr 	FloatIsZero 				; is it zero ?
.226b	f0 15		beq $2282			beq 	_FIPZero 					; if so return zero.
.226d	20 7d 23	jsr $237d			jsr 	FloatNormalise 				; normalise
.2270	f0 10		beq $2282			beq 	_FIPZero 					; normalised to zero, exit zero
.2272					_FIPShift:
.2272	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2274	10 07		bpl $227d			bpl 	_FIPCheckZero
.2276	20 41 26	jsr $2641			jsr 	FloatShiftRight 			; shift mantissa right
.2279	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.227b	80 f5		bra $2272			bra 	_FIPShift
.227d					_FIPCheckZero:
.227d	20 4a 26	jsr $264a			jsr 	FloatIsZero 				; avoid -0 problem
.2280	d0 03		bne $2285			bne 	_FIPExit 					; set to zero if mantissa zero.
.2282					_FIPZero:
.2282	20 28 26	jsr $2628			jsr 	FloatSetZero
.2285					_FIPExit:
.2285	68		pla				pla
.2286	60		rts				rts
.2287					FloatIntegerPartDown:
.2287	48		pha				pha
.2288	5a		phy				phy
.2289	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.228b	f0 36		beq $22c3			beq 	_FIPExit 					; if so do nothing
.228d	20 4a 26	jsr $264a			jsr 	FloatIsZero 				; is it zero ?
.2290	f0 2e		beq $22c0			beq 	_FIPZero 					; if so return zero.
.2292	20 7d 23	jsr $237d			jsr 	FloatNormalise 				; normalise
.2295	f0 29		beq $22c0			beq 	_FIPZero 					; normalised to zero, exit zero
.2297	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.2299					_FIPShift:
.2299	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.229b	10 0a		bpl $22a7			bpl 	_FIPCheckDown
.229d	20 41 26	jsr $2641			jsr 	FloatShiftRight 			; shift mantissa right
.22a0	90 01		bcc $22a3			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22a2	c8		iny				iny
.22a3					_FIPNoFrac:
.22a3	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22a5	80 f2		bra $2299			bra 	_FIPShift
.22a7					_FIPCheckDown:
.22a7	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22a9	f0 10		beq $22bb			beq 	_FIPCheckZero
.22ab	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22ad	10 0c		bpl $22bb			bpl 	_FIPCheckZero
.22af	e8		inx				inx 								; -ve so round *down*.
.22b0	a9 01		lda #$01			lda 	#1
.22b2	20 2a 26	jsr $262a			jsr 	FloatSetByte
.22b5	20 ea 25	jsr $25ea			jsr 	FloatNegate
.22b8	20 4c 20	jsr $204c			jsr 	FloatAdd
.22bb					_FIPCheckZero:
.22bb	20 4a 26	jsr $264a			jsr 	FloatIsZero 				; avoid -0 problem
.22be	d0 03		bne $22c3			bne 	_FIPExit 					; set to zero if mantissa zero.
.22c0					_FIPZero:
.22c0	20 28 26	jsr $2628			jsr 	FloatSetZero
.22c3					_FIPExit:
.22c3	7a		ply				ply
.22c4	68		pla				pla
.22c5	60		rts				rts
.22c6					FloatInt8Multiply:
.22c6	5a		phy				phy
.22c7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.22c9	a8		tay				tay
.22ca	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.22cc					_FI8MLoop:
.22cc	98		tya				tya 								; shift right shifter right into carry
.22cd	4a		lsr a				lsr 	a
.22ce	a8		tay				tay
.22cf	90 0d		bcc $22de			bcc 	_FI8MNoAdd
.22d1	18		clc				clc
.22d2	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.22d4	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.22d6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.22d8	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.22da	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.22dc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.22de					_FI8MNoAdd:
.22de	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.22e0	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.22e2	c0 00		cpy #$00			cpy 	#0
.22e4	d0 e6		bne $22cc			bne 	_FI8MLoop 					; until right shifter zero.
.22e6	7a		ply				ply
.22e7	60		rts				rts
.22e8					FloatMultiply:
.22e8	ca		dex				dex
.22e9	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.22eb	15 6f		ora $6f,x			ora 	NSExponent+1,x
.22ed	15 62		ora $62,x			ora 	NSMantissa3,x
.22ef	15 63		ora $63,x			ora 	NSMantissa3+1,x
.22f1	d0 21		bne $2314			bne 	_FMUseFloat
.22f3	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.22f5	15 33		ora $33,x			ora 	NSStatus+1,x
.22f7	29 80		and #$80			and 	#$80
.22f9	15 62		ora $62,x			ora 	NSMantissa3,x
.22fb	15 56		ora $56,x			ora 	NSMantissa2,x
.22fd	15 4a		ora $4a,x			ora 	NSMantissa1,x
.22ff	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2301	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2303	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2305	d0 04		bne $230b			bne 	_FMInt32
.2307	20 c6 22	jsr $22c6			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.230a	60		rts				rts
.230b					_FMInt32:
.230b	20 35 23	jsr $2335			jsr 	FloatMultiplyShort			; use the int32 one.
.230e	18		clc				clc 								; fix it up if gone out of range
.230f	75 6e		adc $6e,x			adc 	NSExponent,x
.2311	95 6e		sta $6e,x			sta 	NSExponent,x
.2313	60		rts				rts
.2314					_FMUseFloat:
.2314	20 7d 23	jsr $237d			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2317	f0 18		beq $2331			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2319	e8		inx				inx
.231a	20 7d 23	jsr $237d			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.231d	ca		dex				dex
.231e	c9 00		cmp #$00			cmp 	#0
.2320	f0 0c		beq $232e			beq 	_FDSetZero
.2322	20 35 23	jsr $2335			jsr 	FloatMultiplyShort 			; calculate the result.
.2325	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2327	18		clc				clc
.2328	75 6f		adc $6f,x			adc 	NSExponent+1,x
.232a	95 6e		sta $6e,x			sta 	NSExponent,x
.232c	80 03		bra $2331			bra 	_FDExit
.232e					_FDSetZero:
.232e	20 28 26	jsr $2628			jsr 	FloatSetZero 				; return 0
.2331					_FDExit:
.2331	20 7d 23	jsr $237d			jsr 	FloatNormalise 				; normalise the result
.2334	60		rts				rts
.2335					FloatMultiplyShort:
.2335	5a		phy				phy 								; save Y
.2336	20 0b 26	jsr $260b			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2339	20 24 26	jsr $2624			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.233c	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.233e					_I32MLoop:
.233e	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2340	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.2342	15 58		ora $58,x			ora 	NSMantissa2+2,x
.2344	15 64		ora $64,x			ora 	NSMantissa3+2,x
.2346	f0 25		beq $236d			beq 	_I32MExit 					; exit if zero
.2348	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.234a	29 01		and #$01			and 	#1
.234c	f0 0d		beq $235b			beq 	_I32MNoAdd
.234e	20 b4 23	jsr $23b4			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.2351	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.2353	10 06		bpl $235b			bpl 	_I32MNoAdd
.2355					_I32ShiftRight:
.2355	20 41 26	jsr $2641			jsr 	FloatShiftRight 			; shift S[X] right
.2358	c8		iny				iny 								; increment shift count
.2359	80 09		bra $2364			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.235b					_I32MNoAdd:
.235b	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.235d	70 f6		bvs $2355			bvs 	_I32ShiftRight 				; instead.
.235f	e8		inx				inx
.2360	20 37 26	jsr $2637			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.2363	ca		dex				dex
.2364					_I32MShiftUpper:
.2364	e8		inx				inx 								; shift S[X+2] right
.2365	e8		inx				inx
.2366	20 41 26	jsr $2641			jsr 	FloatShiftRight
.2369	ca		dex				dex
.236a	ca		dex				dex
.236b	80 d1		bra $233e			bra 	_I32MLoop 					; try again.
.236d					_I32MExit:
.236d	20 73 23	jsr $2373			jsr 	FloatCalculateSign
.2370	98		tya				tya 								; shift in A
.2371	7a		ply				ply 								; restore Y and exit
.2372	60		rts				rts
.2373					FloatCalculateSign:
.2373	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.2375	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.2377	55 33		eor $33,x			eor 	NSStatus+1,x
.2379	0a		asl a				asl 	a 							; shift bit 7 into carry
.237a	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.237c	60		rts				rts
.237d					FloatNormalise:
.237d	20 4a 26	jsr $264a			jsr 	FloatIsZero 				; if zero exit
.2380	d0 07		bne $2389			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.2382	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.2384	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.2386	a9 00		lda #$00			lda 	#0 							; set Z flag
.2388	60		rts				rts
.2389					_NSNormaliseOptimise:
.2389	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.238b	d0 19		bne $23a6			bne 	_NSNormaliseLoop
.238d	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.238f	30 15		bmi $23a6			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.2391	95 62		sta $62,x			sta 	NSMantissa3,x
.2393	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2395	95 56		sta $56,x			sta 	NSMantissa2,x
.2397	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2399	95 4a		sta $4a,x			sta 	NSMantissa1,x
.239b	74 3e		stz $3e,x			stz 	NSMantissa0,x
.239d	b5 6e		lda $6e,x			lda 	NSExponent,x
.239f	38		sec				sec
.23a0	e9 08		sbc #$08			sbc 	#8
.23a2	95 6e		sta $6e,x			sta 	NSExponent,x
.23a4	80 e3		bra $2389			bra 	_NSNormaliseOptimise
.23a6					_NSNormaliseLoop:
.23a6	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23a8	70 07		bvs $23b1			bvs 	_NSNExit 					; exit if so with Z flag clear
.23aa	20 37 26	jsr $2637			jsr 	FloatShiftLeft 				; shift mantissa left
.23ad	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23af	80 f5		bra $23a6			bra 	_NSNormaliseLoop
.23b1					_NSNExit:
.23b1	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23b3	60		rts				rts
.23b4					FloatAddTopTwoStack:
.23b4	18		clc				clc
.23b5	b5 3e		lda $3e,x			lda		NSMantissa0,x
.23b7	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.23b9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.23bb	b5 4a		lda $4a,x			lda		NSMantissa1,x
.23bd	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.23bf	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23c1	b5 56		lda $56,x			lda		NSMantissa2,x
.23c3	75 57		adc $57,x			adc 		NSMantissa2+1,x
.23c5	95 56		sta $56,x			sta 	NSMantissa2,x
.23c7	b5 62		lda $62,x			lda		NSMantissa3,x
.23c9	75 63		adc $63,x			adc 		NSMantissa3+1,x
.23cb	95 62		sta $62,x			sta 	NSMantissa3,x
.23cd	60		rts				rts
.23ce					FloatSubTopTwoStack:
.23ce	38		sec				sec
.23cf	b5 3e		lda $3e,x			lda		NSMantissa0,x
.23d1	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.23d3	95 3e		sta $3e,x			sta 	NSMantissa0,x
.23d5	b5 4a		lda $4a,x			lda		NSMantissa1,x
.23d7	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.23d9	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23db	b5 56		lda $56,x			lda		NSMantissa2,x
.23dd	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.23df	95 56		sta $56,x			sta 	NSMantissa2,x
.23e1	b5 62		lda $62,x			lda		NSMantissa3,x
.23e3	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.23e5	95 62		sta $62,x			sta 	NSMantissa3,x
.23e7	60		rts				rts
.23e8					FloatInt32Add:
.23e8	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.23ea	55 33		eor $33,x			eor 	NSStatus+1,x
.23ec	30 04		bmi $23f2			bmi 	_DiffSigns
.23ee	20 b4 23	jsr $23b4			jsr		FloatAddTopTwoStack
.23f1	60		rts				rts
.23f2					_DiffSigns:
.23f2	20 ce 23	jsr $23ce			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.23f5	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.23f7	10 07		bpl $2400			bpl 	_AddExit
.23f9	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.23fb	95 32		sta $32,x			sta 	NSStatus,x
.23fd	20 f1 25	jsr $25f1			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2400					_AddExit:
.2400	20 4a 26	jsr $264a			jsr 	FloatIsZero 				; check for -0
.2403	d0 02		bne $2407			bne 	_AddNonZero
.2405	74 32		stz $32,x			stz 	NSStatus,x
.2407					_AddNonZero:
.2407	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2408					FloatEncodeStart:
.2408	38		sec				sec
.2409	80 01		bra $240c			bra 	FloatEncodeContinue+1
.240b					FloatEncodeContinue:
.240b	18		clc				clc
.240c					FloatEncode:
.240c	08		php				php 								; save reset flag.
.240d	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.240f	f0 15		beq $2426			beq 	_ENIsOkay
.2411	c9 30		cmp #$30			cmp 	#"0"
.2413	90 04		bcc $2419			bcc 	_ENBadNumber
.2415	c9 3a		cmp #$3a			cmp 	#"9"+1
.2417	90 0d		bcc $2426			bcc 	_ENIsOkay
.2419					_ENBadNumber:
.2419	28		plp				plp 								; throw saved reset
.241a	ad 91 05	lda $0591			lda 	encodeState 				; if in decimal mode, construct final number
.241d	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.241f	d0 03		bne $2424			bne 	_ENFail
.2421	4c 9e 24	jmp $249e			jmp 	_ENConstructFinal
.2424					_ENFail:
.2424	18		clc				clc 								; not allowed
.2425	60		rts				rts
.2426					_ENIsOkay:
.2426	28		plp				plp 								; are we restarting
.2427	90 15		bcc $243e			bcc 	_ENNoRestart
.2429					_ENStartEncode:
.2429	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.242b	f0 0c		beq $2439			beq 	_ENFirstDP
.242d	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.242f	20 2a 26	jsr $262a			jsr 	FloatSetByte 				; in single byte mode.
.2432	a9 01		lda #$01			lda 	#ESTA_Low
.2434					_ENExitChange:
.2434	8d 91 05	sta $0591			sta 	encodeState 				; save new state
.2437	38		sec				sec
.2438	60		rts				rts
.2439					_ENFirstDP:
.2439	20 28 26	jsr $2628			jsr 	FloatSetZero 				; clear integer part
.243c	80 3c		bra $247a			bra 	_ESTASwitchFloat			; go straight to float and exi
.243e					_ENNoRestart:
.243e	48		pha				pha 								; save digit or DP on stack.
.243f	ad 91 05	lda $0591			lda 	encodeState 				; get current state
.2442	c9 01		cmp #$01			cmp 	#ESTA_Low
.2444	f0 09		beq $244f			beq  	_ESTALowState
.2446	c9 02		cmp #$02			cmp 	#ESTA_High
.2448	f0 26		beq $2470			beq 	_ESTAHighState
.244a	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.244c	f0 38		beq $2486			beq 	_ESTADecimalState
>244e	db						.byte 	$DB 						; causes a break in the emulator
.244f					_ESTALowState:
.244f	68		pla				pla 								; get value back
.2450	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.2452	f0 26		beq $247a			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.2454	29 0f		and #$0f			and 	#15 						; make digit
.2456	8d 92 05	sta $0592			sta 	digitTemp 					; save it.
.2459	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.245b	0a		asl a				asl 	a
.245c	0a		asl a				asl 	a
.245d	75 3e		adc $3e,x			adc 	NSMantissa0,x
.245f	0a		asl a				asl 	a
.2460	6d 92 05	adc $0592			adc 	digitTemp
.2463	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2465	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.2467	90 05		bcc $246e			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.2469	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.246b	8d 91 05	sta $0591			sta 	encodeState
.246e					_ESTANoSwitch:
.246e	38		sec				sec
.246f	60		rts				rts
.2470					_ESTAHighState:
.2470	68		pla				pla 								; get value back
.2471	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.2473	f0 05		beq $247a			beq 	_ESTASwitchFloat
.2475	20 d0 24	jsr $24d0			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.2478	38		sec				sec
.2479	60		rts				rts
.247a					_ESTASwitchFloat:
.247a	9c 93 05	stz $0593			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.247d	e8		inx				inx 								; zero the decimal additive.
.247e	20 28 26	jsr $2628			jsr 	FloatSetZero
.2481	ca		dex				dex
.2482	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.2484	80 ae		bra $2434			bra 	_ENExitChange
.2486					_ESTADecimalState:
.2486	68		pla				pla 								; digit.
.2487	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.2489	f0 99		beq $2424			beq 	_ENFail
.248b	e8		inx				inx 								; put digit into fractional part of X+1
.248c	20 d0 24	jsr $24d0			jsr 	ESTAShiftDigitIntoMantissa
.248f	ca		dex				dex
.2490	ee 93 05	inc $0593			inc 	decimalCount 				; bump the count of decimals
.2493	ad 93 05	lda $0593			lda 	decimalCount 				; too many decimal digits.
.2496	c9 0b		cmp #$0b			cmp 	#11
.2498	f0 02		beq $249c			beq 	_ESTADSFail
.249a	38		sec				sec
.249b	60		rts				rts
.249c					_ESTADSFail:
.249c	18		clc				clc
.249d	60		rts				rts
.249e					_ENConstructFinal:
.249e	ad 93 05	lda $0593			lda 	decimalCount 				; get decimal count
.24a1	f0 2b		beq $24ce			beq 	_ENCFExit 					; no decimals
.24a3	5a		phy				phy
.24a4	0a		asl a				asl 	a 							; x 4 and CLC
.24a5	0a		asl a				asl 	a
.24a6	6d 93 05	adc $0593			adc 	decimalCount
.24a9	a8		tay				tay
.24aa	b9 35 21	lda $2135,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24ad	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24af	b9 36 21	lda $2136,y			lda 	FloatScalarTable-5+1,y
.24b2	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.24b4	b9 37 21	lda $2137,y			lda 	FloatScalarTable-5+2,y
.24b7	95 58		sta $58,x			sta 	NSMantissa2+2,x
.24b9	b9 38 21	lda $2138,y			lda 	FloatScalarTable-5+3,y
.24bc	95 64		sta $64,x			sta 	NSMantissa3+2,x
.24be	b9 39 21	lda $2139,y			lda 	FloatScalarTable-5+4,y
.24c1	95 70		sta $70,x			sta 	NSExponent+2,x
.24c3	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.24c5	e8		inx				inx 								; multiply decimal const by decimal scalar
.24c6	e8		inx				inx
.24c7	20 e8 22	jsr $22e8			jsr 	FloatMultiply
.24ca	20 4c 20	jsr $204c			jsr 	FloatAdd 					; add to integer part.
.24cd	7a		ply				ply
.24ce					_ENCFExit:
.24ce	18		clc				clc 								; reject the digit.
.24cf	60		rts				rts
.24d0					ESTAShiftDigitIntoMantissa:
.24d0	29 0f		and #$0f			and 	#15 						; save digit
.24d2	48		pha				pha
.24d3	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.24d5	48		pha				pha
.24d6	b5 56		lda $56,x			lda 	NSMantissa2,x
.24d8	48		pha				pha
.24d9	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.24db	48		pha				pha
.24dc	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.24de	48		pha				pha
.24df	20 37 26	jsr $2637			jsr 	FloatShiftLeft 				; x 2
.24e2	20 37 26	jsr $2637			jsr 	FloatShiftLeft 				; x 4
.24e5	18		clc				clc 								; pop mantissa and add
.24e6	68		pla				pla
.24e7	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24e9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24eb	68		pla				pla
.24ec	75 4a		adc $4a,x			adc 	NSMantissa1,x
.24ee	95 4a		sta $4a,x			sta 	NSMantissa1,x
.24f0	68		pla				pla
.24f1	75 56		adc $56,x			adc 	NSMantissa2,x
.24f3	95 56		sta $56,x			sta 	NSMantissa2,x
.24f5	68		pla				pla
.24f6	75 62		adc $62,x			adc 	NSMantissa3,x
.24f8	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.24fa	20 37 26	jsr $2637			jsr 	FloatShiftLeft 				; x 10
.24fd	68		pla				pla 								; add digit
.24fe	18		clc				clc
.24ff	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2501	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2503	90 0a		bcc $250f			bcc 	_ESTASDExit
.2505	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2507	d0 06		bne $250f			bne 	_ESTASDExit
.2509	f6 56		inc $56,x			inc 	NSMantissa2,x
.250b	d0 02		bne $250f			bne 	_ESTASDExit
.250d	f6 62		inc $62,x			inc 	NSMantissa3,x
.250f					_ESTASDExit:
.250f	60		rts				rts
.0591					encodeState:
>0591							.fill 	1
.0592					digitTemp:
>0592							.fill 	1
.0593					decimalCount:
>0593							.fill 	1
.2510					FloatToString:
.2510	da		phx				phx
.2511	5a		phy				phy 								; save code position
.2512	8d 94 05	sta $0594			sta 	decimalPlaces	 			; save number of DPs.
.2515	9c 95 05	stz $0595			stz 	dbOffset 					; offset into decimal buffer = start.
.2518	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.251a	10 08		bpl $2524			bpl 	_CNTSNotNegative
.251c	29 7f		and #$7f			and 	#$7F 						; make +ve
.251e	95 32		sta $32,x			sta 	NSStatus,x
.2520	a9 2d		lda #$2d			lda 	#"-"
.2522	80 02		bra $2526			bra 	_CNTMain
.2524					_CNTSNotNegative:
.2524	a9 20		lda #$20			lda 	#" "
.2526					_CNTMain:
.2526	20 88 25	jsr $2588			jsr 	WriteDecimalBuffer
.2529	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.252b	f0 0d		beq $253a			beq 	_CNTSNotFloat
.252d	e8		inx				inx 								; round up so we don't get too many 6.999999
.252e	a9 01		lda #$01			lda 	#1
.2530	20 2a 26	jsr $262a			jsr 	FloatSetByte
.2533	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2535	95 6e		sta $6e,x			sta 	NSExponent,x
.2537	20 4c 20	jsr $204c			jsr 	FloatAdd
.253a					_CNTSNotFloat:
.253a	20 6a 25	jsr $256a			jsr 	MakePlusTwoString 			; do the integer part.
.253d	20 08 22	jsr $2208			jsr 	FloatFractionalPart 		; get the fractional part
.2540	20 7d 23	jsr $237d			jsr 	FloatNormalise					; normalise , exit if zero
.2543	f0 22		beq $2567			beq 	_CNTSExit
.2545	a9 2e		lda #$2e			lda 	#"."
.2547	20 88 25	jsr $2588			jsr 	WriteDecimalBuffer 			; write decimal place
.254a					_CNTSDecimal:
.254a	ce 94 05	dec $0594			dec 	decimalPlaces 				; done all the decimals
.254d	30 18		bmi $2567			bmi 	_CNTSExit
.254f	e8		inx				inx 								; x 10.0
.2550	a9 0a		lda #$0a			lda 	#10
.2552	20 2a 26	jsr $262a			jsr 	FloatSetByte
.2555	20 e8 22	jsr $22e8			jsr 	FloatMultiply
.2558	20 6a 25	jsr $256a			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.255b	20 08 22	jsr $2208			jsr 	FloatFractionalPart 		; get the fractional part
.255e	20 7d 23	jsr $237d			jsr 	FloatNormalise 				; normalise it.
.2561	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.2563	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.2565	b0 e3		bcs $254a			bcs 	_CNTSDecimal 				; keep going.
.2567					_CNTSExit:
.2567	7a		ply				ply
.2568	fa		plx				plx
.2569	60		rts				rts
.256a					MakePlusTwoString:
.256a	da		phx				phx
.256b	20 0b 26	jsr $260b			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.256e	e8		inx				inx 								; access it
.256f	e8		inx				inx
.2570	20 63 22	jsr $2263			jsr 	FloatIntegerPart 			; make it an integer
.2573	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.2575	20 a7 25	jsr $25a7			jsr 	ConvertInt32
.2578	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.257a					_MPTSCopy:
.257a	bd 6f 05	lda $056f,x			lda 	numberBuffer,x
.257d	20 88 25	jsr $2588			jsr 	WriteDecimalBuffer
.2580	e8		inx				inx
.2581	bd 6f 05	lda $056f,x			lda 	numberBuffer,x
.2584	d0 f4		bne $257a			bne 	_MPTSCopy
.2586	fa		plx				plx
.2587	60		rts				rts
.2588					WriteDecimalBuffer:
.2588	da		phx				phx
.2589	ae 95 05	ldx $0595			ldx 	dbOffset
.258c	9d 96 05	sta $0596,x			sta 	decimalBuffer,x
.258f	9e 97 05	stz $0597,x			stz 	decimalBuffer+1,x
.2592	ee 95 05	inc $0595			inc 	dbOffset
.2595	fa		plx				plx
.2596	60		rts				rts
.0594					decimalPlaces:
>0594							.fill 	1
.0595					dbOffset:
>0595							.fill 	1
.0596					decimalBuffer:
>0596							.fill 	32
.2597					ConvertInt16:
.2597	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.2599	86 4a		stx $4a				stx 	NSMantissa1
.259b	64 56		stz $56				stz 	NSMantissa2
.259d	64 62		stz $62				stz 	NSMantissa3
.259f	64 32		stz $32				stz 	NSStatus 					; positive integer
.25a1	a2 00		ldx #$00			ldx 	#0 							; stack level
.25a3	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25a5	80 00		bra $25a7			bra 	ConvertInt32
.25a7					ConvertInt32:
.25a7	5a		phy				phy
.25a8	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25aa	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25ac	10 08		bpl $25b6			bpl 	_CI32NotNeg
.25ae	48		pha				pha
.25af	a9 2d		lda #$2d			lda 	#'-'
.25b1	99 6f 05	sta $056f,y			sta 	numberBuffer,y
.25b4	c8		iny				iny
.25b5	68		pla				pla
.25b6					_CI32NotNeg:
.25b6	20 c4 25	jsr $25c4			jsr 	_CI32DivideConvert 			; recursive conversion
.25b9	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.25bb	99 6f 05	sta $056f,y			sta 	numberBuffer,y
.25be	7a		ply				ply
.25bf	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.25c1	a9 6f		lda #$6f			lda 	#numberBuffer & $FF
.25c3	60		rts				rts
.25c4					_CI32DivideConvert:
.25c4	e8		inx				inx 								; write to next slot up
.25c5	20 2a 26	jsr $262a			jsr 	FloatSetByte 		 		; write the base out.
.25c8	ca		dex				dex
.25c9	20 be 21	jsr $21be			jsr 	Int32Divide 				; divide
.25cc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.25ce	48		pha				pha
.25cf	20 ad 21	jsr $21ad			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.25d2	20 4a 26	jsr $264a			jsr 	FloatIsZero 				; is it zero ?
.25d5	f0 05		beq $25dc			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.25d7	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.25d9	20 c4 25	jsr $25c4			jsr 	_CI32DivideConvert 			; and recusrively call.
.25dc					_CI32NoRecurse:
.25dc	68		pla				pla 								; remainder
.25dd	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.25df	90 02		bcc $25e3			bcc 	_CI32NotHex
.25e1	69 26		adc #$26			adc 	#6+32
.25e3					_CI32NotHex:
.25e3	69 30		adc #$30			adc 	#48
.25e5	99 6f 05	sta $056f,y			sta 	numberBuffer,y 				; write out and exit
.25e8	c8		iny				iny
.25e9	60		rts				rts
.25ea					FloatNegate:
.25ea	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.25ec	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.25ee	95 32		sta $32,x			sta 	NSStatus,x
.25f0	60		rts				rts
.25f1					FloatNegateMantissa:
.25f1	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.25f2	a9 00		lda #$00			lda 	#0
.25f4	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.25f6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.25f8	a9 00		lda #$00			lda 	#0
.25fa	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.25fc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.25fe	a9 00		lda #$00			lda 	#0
.2600	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.2602	95 56		sta $56,x			sta 	NSMantissa2,x
.2604	a9 00		lda #$00			lda 	#0
.2606	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2608	95 62		sta $62,x			sta 	NSMantissa3,x
.260a	60		rts				rts
.260b					FloatShiftUpTwo:
.260b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.260d	95 40		sta $40,x			sta 	NSMantissa0+2,x
.260f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2611	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2613	b5 56		lda $56,x			lda 	NSMantissa2,x
.2615	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2617	b5 62		lda $62,x			lda 	NSMantissa3,x
.2619	95 64		sta $64,x			sta 	NSMantissa3+2,x
.261b	b5 6e		lda $6e,x			lda 	NSExponent,x
.261d	95 70		sta $70,x			sta 	NSExponent+2,x
.261f	b5 32		lda $32,x			lda 	NSStatus,x
.2621	95 34		sta $34,x			sta 	NSStatus+2,x
.2623	60		rts				rts
.2624					FloatSetZeroMantissaOnly:
.2624	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2626	80 08		bra $2630			bra 	FloatZero13
.2628					FloatSetZero:
.2628	a9 00		lda #$00			lda 	#0
.262a					FloatSetByte:
.262a	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.262c					FloatSetMantissa:
.262c	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.262e	74 32		stz $32,x			stz 	NSStatus,x
.2630					FloatZero13:
.2630	74 4a		stz $4a,x			stz 	NSMantissa1,x
.2632	74 56		stz $56,x			stz 	NSMantissa2,x
.2634	74 62		stz $62,x			stz 	NSMantissa3,x
.2636	60		rts				rts
.2637					FloatShiftLeft:
.2637	18		clc				clc
.2638					FloatRotateLeft:
.2638	36 3e		rol $3e,x			rol 	NSMantissa0,x
.263a	36 4a		rol $4a,x			rol		NSMantissa1,x
.263c	36 56		rol $56,x			rol		NSMantissa2,x
.263e	36 62		rol $62,x			rol		NSMantissa3,x
.2640	60		rts				rts
.2641					FloatShiftRight:
.2641	56 62		lsr $62,x			lsr 	NSMantissa3,x
.2643	76 56		ror $56,x			ror		NSMantissa2,x
.2645	76 4a		ror $4a,x			ror		NSMantissa1,x
.2647	76 3e		ror $3e,x			ror		NSMantissa0,x
.2649	60		rts				rts
.264a					FloatIsZero:
.264a	b5 62		lda $62,x			lda 	NSMantissa3,x
.264c	15 56		ora $56,x			ora		NSMantissa2,x
.264e	15 4a		ora $4a,x			ora		NSMantissa1,x
.2650	15 3e		ora $3e,x			ora		NSMantissa0,x
.2652	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.2653					FloatArcTan:
.2653	20 7d 23	jsr $237d			jsr 	FloatNormalise 					; normalise x
.2656	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.2658	48		pha				pha
.2659	74 32		stz $32,x			stz 	NSStatus,x
.265b	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.265d	c9 e2		cmp #$e2			cmp 	#$E2
.265f	90 25		bcc $2686			bcc 	_UANoFixup
.2661	8a		txa				txa 									; value in +1
.2662	a8		tay				tay
.2663	c8		iny				iny
.2664	20 0c 28	jsr $280c			jsr 	CopyFloatXY
.2667	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.2669	20 2a 26	jsr $262a			jsr 	FloatSetByte
.266c	e8		inx				inx
.266d	20 71 21	jsr $2171			jsr 	FloatDivide
.2670	b0 21		bcs $2693			bcs 	_FATError
.2672	20 96 26	jsr $2696			jsr 	CoreAtn 						; calculate the root
.2675	20 01 28	jsr $2801			jsr 	CompletePolynomial
.2678	20 ea 25	jsr $25ea			jsr 	FloatNegate 					; make -ve
.267b	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.267d	20 58 28	jsr $2858			jsr 	LoadConstant
.2680	e8		inx				inx
.2681	20 4c 20	jsr $204c			jsr 	FloatAdd
.2684	80 06		bra $268c			bra 	_UAComplete
.2686					_UANoFixup:
.2686	20 96 26	jsr $2696			jsr 	CoreAtn
.2689	20 01 28	jsr $2801			jsr 	CompletePolynomial
.268c					_UAComplete:
.268c	68		pla				pla 									; apply the result.
.268d	55 32		eor $32,x			eor 	NSStatus,x
.268f	95 32		sta $32,x			sta 	NSStatus,x
.2691	18		clc				clc
.2692	60		rts				rts
.2693					_FATError:
.2693	68		pla				pla
.2694	38		sec				sec
.2695	60		rts				rts
.2696					CoreAtn:
.2696	a9 04		lda #$04			lda 	#AtnCoefficients & $FF
.2698	a0 27		ldy #$27			ldy 	#AtnCoefficients >> 8
.269a	4c 55 29	jmp $2955			jmp 	CorePolySquared
.269d					ExpCoefficients:
>269d	07					.byte	7
>269e	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>26a2	d2					.byte	$d2
>26a3	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>26a7	d5					.byte	$d5
>26a8	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>26ac	d8					.byte	$d8
>26ad	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>26b1	db					.byte	$db
>26b2	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>26b6	dd					.byte	$dd
>26b7	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>26bb	df					.byte	$df
>26bc	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>26c0	e1					.byte	$e1
>26c1	00 00 00 40				.dword	$40000000 ; 1.0
>26c5	e2					.byte	$e2
.26c6					SinCoefficients:
>26c6	06					.byte	6
>26c7	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>26cb	e5					.byte	$e5
>26cc	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>26d0	e7					.byte	$e7
>26d1	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>26d5	e8					.byte	$e8
>26d6	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>26da	e8					.byte	$e8
>26db	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>26df	e7					.byte	$e7
>26e0	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>26e4	e4					.byte	$e4
>26e5	00 00 00 00				.dword	$00000000 ; 0.0
>26e9	00					.byte	$00
.26ea					LogCoefficients:
>26ea	04					.byte	4
>26eb	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>26ef	e0					.byte	$e0
>26f0	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>26f4	e1					.byte	$e1
>26f5	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>26f9	e1					.byte	$e1
>26fa	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>26fe	e3					.byte	$e3
>26ff	00 00 00 c0				.dword	$c0000000 ; -0.5
>2703	e1					.byte	$e1
.2704					AtnCoefficients:
>2704	0c					.byte	12
>2705	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2709	d7					.byte	$d7
>270a	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>270e	da					.byte	$da
>270f	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>2713	dc					.byte	$dc
>2714	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2718	dd					.byte	$dd
>2719	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>271d	dd					.byte	$dd
>271e	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>2722	de					.byte	$de
>2723	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2727	de					.byte	$de
>2728	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>272c	de					.byte	$de
>272d	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>2731	df					.byte	$df
>2732	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>2736	df					.byte	$df
>2737	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>273b	e0					.byte	$e0
>273c	00 00 00 40				.dword	$40000000 ; 1.0
>2740	e2					.byte	$e2
>2741	00 00 00 00				.dword	$00000000 ; 0.0
>2745	00					.byte	$00
.2746					Const_Base:
.2746					Const_1Div2Pi:
>2746	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>274a	df					.byte	$df
.274b					Const_PiDiv2:
>274b	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>274f	e2					.byte	$e2
.2750					Const_Log2_e:
>2750	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>2754	e2					.byte	$e2
.2755					Const_sqrt_2:
>2755	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>2759	e2					.byte	$e2
.275a					Const_sqrt_half:
>275a	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>275e	e1					.byte	$e1
.275f					Const_pi:
>275f	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>2763	e3					.byte	$e3
.2764					Const_half:
>2764	00 00 00 40				.dword	$40000000 ; 0.50000000
>2768	e1					.byte	$e1
.2769					Const_ln_e:
>2769	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>276d	e1					.byte	$e1
.276e					FloatCosine:
.276e	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2770	20 58 28	jsr $2858			jsr 	LoadConstant
.2773	e8		inx				inx
.2774	20 4c 20	jsr $204c			jsr 	FloatAdd
.2777	4c 0e 29	jmp $290e			jmp 	FloatSine
.277a					FloatExponent:
.277a	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.277c	20 58 28	jsr $2858			jsr 	LoadConstant
.277f	e8		inx				inx
.2780	20 e8 22	jsr $22e8			jsr 	FloatMultiply
.2783	20 c5 27	jsr $27c5			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.2786	e8		inx				inx
.2787	20 63 22	jsr $2263			jsr 	FloatIntegerPart
.278a	ca		dex				dex
.278b	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.278d	15 57		ora $57,x			ora 	NSMantissa2+1,x
.278f	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2791	d0 38		bne $27cb			bne 	_UERangeError
.2793	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.2795	c9 40		cmp #$40			cmp 	#64
.2797	b0 32		bcs $27cb			bcs 	_UERangeError
.2799	48		pha				pha
.279a	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.279c	48		pha				pha
.279d	20 08 22	jsr $2208			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.27a0	68		pla				pla
.27a1	10 14		bpl $27b7			bpl 	_UEPositive
.27a3	e8		inx				inx 							; 1-x
.27a4	a9 01		lda #$01			lda 	#1
.27a6	20 2a 26	jsr $262a			jsr 	FloatSetByte
.27a9	ca		dex				dex
.27aa	20 ea 25	jsr $25ea			jsr 	FloatNegate
.27ad	e8		inx				inx
.27ae	20 4c 20	jsr $204c			jsr 	FloatAdd
.27b1	68		pla				pla 							; integer part +1 and negated.
.27b2	1a		inc a				inc 	a
.27b3	49 ff		eor #$ff			eor 	#$FF
.27b5	1a		inc a				inc 	a
.27b6	48		pha				pha
.27b7					_UEPositive:
.27b7	20 cd 27	jsr $27cd			jsr 	CoreExponent
.27ba	20 01 28	jsr $2801			jsr 	CompletePolynomial
.27bd	68		pla				pla
.27be	18		clc				clc
.27bf	75 6e		adc $6e,x			adc 	NSExponent,x
.27c1	95 6e		sta $6e,x			sta 	NSExponent,x
.27c3	18		clc				clc
.27c4	60		rts				rts
.27c5					_UECopy01:
.27c5	8a		txa				txa
.27c6	a8		tay				tay
.27c7	c8		iny				iny
.27c8	4c 0c 28	jmp $280c			jmp 	CopyFloatXY
.27cb					_UERangeError:
.27cb	38		sec				sec
.27cc	60		rts				rts
.27cd					CoreExponent:
.27cd	a9 9d		lda #$9d			lda 	#ExpCoefficients & $FF
.27cf	a0 26		ldy #$26			ldy 	#ExpCoefficients >> 8
.27d1	20 d5 27	jsr $27d5			jsr 	CalculateHornerPolynomial
.27d4	60		rts				rts
.27d5					CalculateHornerPolynomial:
.27d5	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.27d7	84 2d		sty $2d				sty 	zTemp0+1
.27d9	9c b6 05	stz $05b6			stz 	coefficientCount 			; zero the count.
.27dc	8e b7 05	stx $05b7			stx 	xValueSlot 					; save xValue slot.
.27df	e8		inx				inx 								; set the count to zero.
.27e0	20 28 26	jsr $2628			jsr 	FloatSetZero
.27e3					_CHPLoop:
.27e3	8a		txa				txa 								; copy X-1 to X+1
.27e4	a8		tay				tay
.27e5	ca		dex				dex
.27e6	c8		iny				iny
.27e7	20 0c 28	jsr $280c			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.27ea	e8		inx				inx
.27eb	e8		inx				inx
.27ec	20 e8 22	jsr $22e8			jsr 	FloatMultiply 				; times current by X
.27ef	e8		inx				inx
.27f0	20 2b 28	jsr $282b			jsr 	GetCoefficient 				; coefficient into X+1
.27f3	20 4c 20	jsr $204c			jsr 	FloatAdd 					; and add
.27f6	ee b6 05	inc $05b6			inc 	coefficientCount
.27f9	ad b6 05	lda $05b6			lda 	coefficientCount
.27fc	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.27fe	d0 e3		bne $27e3			bne 	_CHPLoop
.2800	60		rts				rts
.2801					CompletePolynomial:
.2801	20 e8 22	jsr $22e8			jsr 	FloatMultiply
.2804	e8		inx				inx 								; get the last value
.2805	20 2b 28	jsr $282b			jsr 	GetCoefficient
.2808	20 4c 20	jsr $204c			jsr 	FloatAdd 					; and add it
.280b	60		rts				rts
.280c					CopyFloatXY:
.280c	b5 6e		lda $6e,x			lda 	NSExponent,x
.280e	99 6e 00	sta $006e,y			sta 	NSExponent,y
.2811	b5 32		lda $32,x			lda 	NSStatus,x
.2813	99 32 00	sta $0032,y			sta 	NSStatus,y
.2816	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2818	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.281b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.281d	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.2820	b5 56		lda $56,x			lda 	NSMantissa2,x
.2822	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.2825	b5 62		lda $62,x			lda 	NSMantissa3,x
.2827	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.282a	60		rts				rts
.282b					GetCoefficient:
.282b	5a		phy				phy
.282c	ad b6 05	lda $05b6			lda 	coefficientCount 			; 5 per block
.282f	0a		asl a				asl 	a
.2830	0a		asl a				asl 	a
.2831	38		sec				sec 								; +1 for count
.2832	6d b6 05	adc $05b6			adc 	coefficientCount
.2835	a8		tay				tay
.2836	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.2838	95 3e		sta $3e,x			sta 	NSMantissa0,x
.283a	c8		iny				iny
.283b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.283d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.283f	c8		iny				iny
.2840	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2842	95 56		sta $56,x			sta 	NSMantissa2,x
.2844	c8		iny				iny
.2845	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2847	48		pha				pha
.2848	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.284a	95 62		sta $62,x			sta 	NSMantissa3,x
.284c	c8		iny				iny
.284d	68		pla				pla
.284e	29 80		and #$80			and 	#$80
.2850	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.2852	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2854	95 6e		sta $6e,x			sta 	NSExponent,x
.2856	7a		ply				ply
.2857	60		rts				rts
.05b6					coefficientCount:
>05b6							.fill 	1
.05b7					xValueSlot:
>05b7							.fill 	1
.2858					LoadConstant:
.2858	5a		phy				phy
.2859	a8		tay				tay
.285a	b9 46 27	lda $2746,y			lda 	Const_Base+0,y
.285d	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.285f	b9 47 27	lda $2747,y			lda 	Const_Base+1,y
.2862	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.2864	b9 48 27	lda $2748,y			lda 	Const_Base+2,y
.2867	95 57		sta $57,x			sta 	NSMantissa2+1,x
.2869	b9 49 27	lda $2749,y			lda 	Const_Base+3,y
.286c	48		pha				pha
.286d	29 7f		and #$7f			and 	#$7F
.286f	95 63		sta $63,x			sta 	NSMantissa3+1,x
.2871	68		pla				pla
.2872	29 80		and #$80			and 	#$80
.2874	95 33		sta $33,x			sta 	NSStatus+1,x
.2876	b9 4a 27	lda $274a,y			lda 	Const_Base+4,y
.2879	95 6f		sta $6f,x			sta 	NSExponent+1,x
.287b	7a		ply				ply
.287c	60		rts				rts
.287d					FloatLogarithm:
.287d	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.287f	30 5f		bmi $28e0			bmi 	_ULRange
.2881	20 4a 26	jsr $264a			jsr 	FloatIsZero
.2884	f0 5a		beq $28e0			beq 	_ULRange
.2886	20 7d 23	jsr $237d			jsr 	FloatNormalise 				; put into FP mode.
.2889	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.288b	48		pha				pha
.288c	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.288e	95 6e		sta $6e,x			sta 	NSExponent,x
.2890	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.2892	20 58 28	jsr $2858			jsr 	LoadConstant
.2895	e8		inx				inx
.2896	20 4c 20	jsr $204c			jsr 	FloatAdd
.2899	8a		txa				txa 								; divide into sqrt 2.0
.289a	a8		tay				tay
.289b	c8		iny				iny
.289c	20 0c 28	jsr $280c			jsr 	CopyFloatXY
.289f	ca		dex				dex
.28a0	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.28a2	20 58 28	jsr $2858			jsr 	LoadConstant
.28a5	e8		inx				inx
.28a6	e8		inx				inx
.28a7	20 71 21	jsr $2171			jsr 	FloatDivide 				; if zero, error.
.28aa	b0 33		bcs $28df			bcs 	_ULRangePla
.28ac	20 ea 25	jsr $25ea			jsr 	FloatNegate 				; subtract from 1
.28af	e8		inx				inx
.28b0	a9 01		lda #$01			lda 	#1
.28b2	20 2a 26	jsr $262a			jsr 	FloatSetByte
.28b5	20 4c 20	jsr $204c			jsr 	FloatAdd
.28b8	20 e2 28	jsr $28e2			jsr 	CoreLog
.28bb	20 01 28	jsr $2801			jsr 	CompletePolynomial
.28be	68		pla				pla 								; add exponent
.28bf	18		clc				clc
.28c0	69 1f		adc #$1f			adc 	#31 						; fix up
.28c2	48		pha				pha
.28c3	10 03		bpl $28c8			bpl 	_LogNotNeg
.28c5	49 ff		eor #$ff			eor 	#$FF
.28c7	1a		inc a				inc 	a
.28c8					_LogNotNeg:
.28c8	e8		inx				inx 								; set byte and sign.
.28c9	20 2a 26	jsr $262a			jsr 	FloatSetByte
.28cc	68		pla				pla
.28cd	29 80		and #$80			and 	#$80
.28cf	95 32		sta $32,x			sta 	NSStatus,x
.28d1	20 4c 20	jsr $204c			jsr 	FloatAdd
.28d4	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.28d6	20 58 28	jsr $2858			jsr 	LoadConstant
.28d9	e8		inx				inx
.28da	20 e8 22	jsr $22e8			jsr 	FloatMultiply
.28dd	18		clc				clc
.28de	60		rts				rts
.28df					_ULRangePla:
.28df	68		pla				pla
.28e0					_ULRange:
.28e0	38		sec				sec
.28e1	60		rts				rts
.28e2					CoreLog:
.28e2	a9 ea		lda #$ea			lda 	#LogCoefficients & $FF
.28e4	a0 26		ldy #$26			ldy 	#LogCoefficients >> 8
.28e6	4c 55 29	jmp $2955			jmp 	CorePolySquared
.28e9					FloatPI:
.28e9	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.28eb	20 58 28	jsr $2858			jsr 	LoadConstant
.28ee	e8		inx				inx
.28ef	18		clc				clc
.28f0	60		rts				rts
.28f1					FloatPower:
.28f1	ca		dex				dex
.28f2	8a		txa				txa 							; copy 0 to 2, so we can process it
.28f3	a8		tay				tay
.28f4	c8		iny				iny
.28f5	c8		iny				iny
.28f6	20 0c 28	jsr $280c			jsr 	CopyFloatXY
.28f9	e8		inx				inx 							; 2 = Log(0)
.28fa	e8		inx				inx
.28fb	20 7d 28	jsr $287d			jsr 	FloatLogarithm
.28fe	b0 0d		bcs $290d			bcs 	_FPWExit
.2900	20 e8 22	jsr $22e8			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.2903	8a		txa				txa 							; copy to slot 0
.2904	a8		tay				tay
.2905	88		dey				dey
.2906	20 0c 28	jsr $280c			jsr 	CopyFloatXY
.2909	ca		dex				dex  							; Exponent code.
.290a	20 7a 27	jsr $277a			jsr 	FloatExponent
.290d					_FPWExit:
.290d	60		rts				rts
.290e					FloatSine:
.290e	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.2910	48		pha				pha
.2911	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.2913	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.2915	20 58 28	jsr $2858			jsr 	LoadConstant
.2918	e8		inx				inx
.2919	20 e8 22	jsr $22e8			jsr 	FloatMultiply
.291c	20 08 22	jsr $2208			jsr 	FloatFractionalPart 		; take the fractional part
.291f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.2921	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.2923	90 1f		bcc $2944			bcc 	_USProcessExit
.2925	f0 06		beq $292d			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.2927	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.2929	c9 60		cmp #$60			cmp 	#$60
.292b	b0 0e		bcs $293b			bcs 	_USSubtractOne
.292d					_USSubtractFromHalf:
.292d	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.292f	20 58 28	jsr $2858			jsr 	LoadConstant
.2932	e8		inx				inx
.2933	20 46 20	jsr $2046			jsr 	FloatSubtract
.2936	20 ea 25	jsr $25ea			jsr 	FloatNegate 				; then negate it
.2939	80 09		bra $2944			bra 	_USProcessExit 				; and exit
.293b					_USSubtractOne:
.293b	e8		inx				inx
.293c	a9 01		lda #$01			lda 	#1
.293e	20 2a 26	jsr $262a			jsr 	FloatSetByte
.2941	20 46 20	jsr $2046			jsr 	FloatSubtract
.2944					_USProcessExit:
.2944	20 51 29	jsr $2951			jsr 	CoreSine
.2947	20 01 28	jsr $2801			jsr 	CompletePolynomial
.294a	68		pla				pla 								; restore sign and apply
.294b	55 32		eor $32,x			eor 	NSStatus,x
.294d	95 32		sta $32,x			sta 	NSStatus,x
.294f	18		clc				clc
.2950	60		rts				rts
.2951					CoreSine:
.2951	a9 c6		lda #$c6			lda 	#SinCoefficients & $FF
.2953	a0 26		ldy #$26			ldy 	#SinCoefficients >> 8
.2955					CorePolySquared:
.2955	48		pha				pha 								; save coefficient table
.2956	5a		phy				phy
.2957	8a		txa				txa 								; copy X to +1, +2
.2958	a8		tay				tay
.2959	c8		iny				iny
.295a	20 0c 28	jsr $280c			jsr 	CopyFloatXY
.295d	c8		iny				iny
.295e	20 0c 28	jsr $280c			jsr 	CopyFloatXY
.2961	e8		inx				inx 								; point to the pair and put x^2 on stack
.2962	e8		inx				inx
.2963	20 e8 22	jsr $22e8			jsr 	FloatMultiply
.2966	7a		ply				ply 								; coefficient table back.
.2967	68		pla				pla
.2968	20 d5 27	jsr $27d5			jsr 	CalculateHornerPolynomial
.296b	8a		txa				txa 								; copy back to slot #1
.296c	a8		tay				tay
.296d	88		dey				dey
.296e	20 0c 28	jsr $280c			jsr	 	CopyFloatXY
.2971	ca		dex				dex 								; point at result
.2972	60		rts				rts
.2973					FloatSquareRoot:
.2973	20 7d 28	jsr $287d			jsr 	FloatLogarithm
.2976	b0 06		bcs $297e			bcs 	_FSQExit
.2978	d6 6e		dec $6e,x			dec 	NSExponent,x
.297a	20 7a 27	jsr $277a			jsr 	FloatExponent
.297d	18		clc				clc
.297e					_FSQExit:
.297e	60		rts				rts
.297f					FloatTangent:
.297f	da		phx				phx
.2980	8a		txa				txa 								; sin -> +1
.2981	a8		tay				tay
.2982	c8		iny				iny
.2983	20 0c 28	jsr $280c			jsr 	CopyFloatXY
.2986	e8		inx				inx
.2987	20 0e 29	jsr $290e			jsr 	FloatSine
.298a	ca		dex				dex
.298b	8a		txa				txa 								; cos -> +2
.298c	a8		tay				tay
.298d	c8		iny				iny
.298e	c8		iny				iny
.298f	20 0c 28	jsr $280c			jsr 	CopyFloatXY
.2992	e8		inx				inx
.2993	e8		inx				inx
.2994	20 6e 27	jsr $276e			jsr 	FloatCosine
.2997	20 71 21	jsr $2171			jsr 	FloatDivide 				; calculate sin/cos
.299a	b0 07		bcs $29a3			bcs 	_FTExit 					; divide by zero
.299c	8a		txa				txa 								; copy result down.
.299d	a8		tay				tay
.299e	88		dey				dey
.299f	20 0c 28	jsr $280c			jsr 	CopyFloatXY
.29a2	18		clc				clc
.29a3					_FTExit:
.29a3	fa		plx				plx
.29a4	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.007a					srcPtr:
>007a							.fill 	2
.05b8					currentLineNumber:
>05b8							.fill 	2
.29a5					InlineNonDecimal:
.29a5	a2 02		ldx #$02			ldx 	#2 							; get size in X
.29a7	c9 25		cmp #$25			cmp 	#"%"
.29a9	f0 02		beq $29ad			beq 	_INDBinary
.29ab	a2 10		ldx #$10			ldx 	#16
.29ad					_INDBinary:
.29ad	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.29af	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.29b1	64 2c		stz $2c				stz 	zTemp0 						; zero result
.29b3	64 2d		stz $2d				stz 	zTemp0+1
.29b5					_INDLoop:
.29b5	20 51 33	jsr $3351			jsr 	LookNext 					; check next character
.29b8	20 8d 33	jsr $338d			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.29bb	90 1f		bcc $29dc			bcc		_INDDone 					; didn't convert
.29bd	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.29bf	b0 1b		bcs $29dc			bcs 	_INDDone
.29c1	20 eb 29	jsr $29eb			jsr 	_INDShift 					; x 2 or x 16
.29c4	e0 02		cpx #$02			cpx 	#2
.29c6	f0 09		beq $29d1			beq 	_INDNotHex
.29c8	20 eb 29	jsr $29eb			jsr 	_INDShift
.29cb	20 eb 29	jsr $29eb			jsr 	_INDShift
.29ce	20 eb 29	jsr $29eb			jsr 	_INDShift
.29d1					_INDNotHex:
.29d1	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.29d3	85 2c		sta $2c				sta 	zTemp0
.29d5	20 62 33	jsr $3362			jsr 	GetNext 					; consume
.29d8	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.29da	80 d9		bra $29b5			bra 	_INDLoop
.29dc					_INDDone:
.29dc	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.29de	f0 08		beq $29e8			beq 	_INDError
.29e0	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.29e2	a5 2c		lda $2c				lda 	zTemp0
.29e4	20 0c 2b	jsr $2b0c			jsr 	PushIntegerYA
.29e7	60		rts				rts
.29e8					_INDError:
.29e8	4c e2 1e	jmp $1ee2		jmp	ErrorV_syntax
.29eb					_INDShift:
.29eb	06 2c		asl $2c				asl 	zTemp0
.29ed	26 2d		rol $2d				rol 	zTemp0+1
.29ef	60		rts				rts
.29f0					GetLineNumber:
.29f0	ac b9 05	ldy $05b9			ldy 	currentLineNumber+1
.29f3	ad b8 05	lda $05b8			lda 	currentLineNumber
.29f6	60		rts				rts
.29f7					WriteCodeByte:
.29f7	48		pha				pha 								; save on stack
.29f8	da		phx				phx
.29f9	5a		phy				phy
.29fa	aa		tax				tax
.29fb	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.29fd	20 09 2b	jsr $2b09			jsr 	CallAPIHandler
.2a00	7a		ply				ply 								; restore from stack
.2a01	fa		plx				plx
.2a02	68		pla				pla
.2a03	60		rts				rts
.2a04					PrintCharacter
.2a04	48		pha				pha
.2a05	da		phx				phx
.2a06	5a		phy				phy
.2a07	aa		tax				tax
.2a08	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.2a0a	20 09 2b	jsr $2b09			jsr 	CallAPIHandler
.2a0d	7a		ply				ply
.2a0e	fa		plx				plx
.2a0f	68		pla				pla
.2a10	60		rts				rts
.2a11					ProcessNewLine:
.2a11	86 2c		stx $2c				stx 	zTemp0 						; save address in zTemp0
.2a13	84 2d		sty $2d				sty 	zTemp0+1
.2a15	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.2a16	8a		txa				txa
.2a17	69 04		adc #$04			adc 	#4
.2a19	85 7a		sta $7a				sta 	srcPtr
.2a1b	98		tya				tya
.2a1c	69 00		adc #$00			adc 	#0
.2a1e	85 7b		sta $7b				sta 	srcPtr+1
.2a20	a0 02		ldy #$02			ldy 	#2							; read and save line number
.2a22	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a24	8d b8 05	sta $05b8			sta 	currentLineNumber
.2a27	c8		iny				iny
.2a28	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a2a	8d b9 05	sta $05b9			sta 	currentLineNumber+1
.2a2d	60		rts				rts
.2a2e					BufferClear:
.2a2e	9c ba 05	stz $05ba			stz 	bufferSize
.2a31	60		rts				rts
.2a32					BufferWrite:
.2a32	da		phx				phx
.2a33	ae ba 05	ldx $05ba			ldx 	bufferSize
.2a36	9d bb 05	sta $05bb,x			sta 	dataBuffer,x
.2a39	ee ba 05	inc $05ba			inc 	bufferSize
.2a3c	fa		plx				plx
.2a3d	60		rts				rts
.2a3e					BufferOutput:
.2a3e	ad ba 05	lda $05ba			lda 	bufferSize
.2a41	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2a44	a2 00		ldx #$00			ldx 	#0
.2a46					_BOLoop:
.2a46	ec ba 05	cpx $05ba			cpx 	bufferSize
.2a49	f0 09		beq $2a54			beq 	_BOExit
.2a4b	bd bb 05	lda $05bb,x			lda 	dataBuffer,x
.2a4e	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2a51	e8		inx				inx
.2a52	80 f2		bra $2a46			bra 	_BOLoop
.2a54					_BOExit:
.2a54	60		rts				rts
.05ba					bufferSize:
>05ba							.fill 	1
.05bb					dataBuffer:
>05bb							.fill 	256
.2a55					CheckNextComma:
.2a55	a9 2c		lda #$2c			lda	 	#","
.2a57	80 06		bra $2a5f			bra 	CheckNextA
.2a59					CheckNextRParen:
.2a59	a9 29		lda #$29			lda	 	#")"
.2a5b	80 02		bra $2a5f			bra 	CheckNextA
.2a5d					CheckNextLParen:
.2a5d	a9 28		lda #$28			lda 	#"("
.2a5f					CheckNextA:
.2a5f	8d bb 06	sta $06bb			sta 	checkCharacter 				; save test character
.2a62					_CNALoop:
.2a62	20 6d 33	jsr $336d			jsr 	GetNextNonSpace 			; get next skipping spaces.
.2a65	cd bb 06	cmp $06bb			cmp 	checkCharacter 				; matches ?
.2a68	f0 03		beq $2a6d			beq 	_CNAExit
.2a6a	4c e2 1e	jmp $1ee2		jmp	ErrorV_syntax
.2a6d					_CNAExit:
.2a6d	60		rts				rts
.06bb					checkCharacter:
>06bb							.fill 	1
.2a6e					StartCompiler:
.2a6e	86 2c		stx $2c				stx 	zTemp0 						; access API
.2a70	84 2d		sty $2d				sty 	zTemp0+1
.2a72	a0 2c		ldy #$2c			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.2a74	a2 c5		ldx #$c5			ldx 	#CompilerErrorHandler & $FF
.2a76	20 bb 1e	jsr $1ebb			jsr 	SetErrorHandler
.2a79	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.2a7b	b2 2c		lda ($2c)			lda 	(zTemp0)
.2a7d	8d bd 06	sta $06bd			sta 	APIVector
.2a80	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a82	8d be 06	sta $06be			sta 	APIVector+1
.2a85	c8		iny				iny 								; copy data area range.
.2a86	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a88	8d bf 06	sta $06bf			sta 	compilerStartHigh
.2a8b	c8		iny				iny
.2a8c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a8e	8d c0 06	sta $06c0			sta 	compilerEndHigh
.2a91	ba		tsx				tsx 								; save stack pointer
.2a92	8e bc 06	stx $06bc			stx 	compilerSP
.2a95	20 f1 36	jsr $36f1			jsr 	STRReset 					; reset storage (line#, variable)
.2a98	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.2a9a	20 09 2b	jsr $2b09			jsr 	CallAPIHandler
.2a9d	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.2a9f	20 09 2b	jsr $2b09			jsr 	CallAPIHandler
.2aa2	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.2aa4	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2aa7	a9 00		lda #$00			lda 	#0
.2aa9	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2aac	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2aaf					MainCompileLoop:
.2aaf	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.2ab1	20 09 2b	jsr $2b09			jsr 	CallAPIHandler
.2ab4	90 31		bcc $2ae7			bcc 	SaveCodeAndExit 			; end of source.
.2ab6	20 11 2a	jsr $2a11			jsr 	ProcessNewLine 				; set up pointer and line number.
.2ab9	20 f0 29	jsr $29f0			jsr 	GetLineNumber 				; get line #
.2abc	20 db 34	jsr $34db			jsr 	STRMarkLine 				; remember the code position and number of this line.
.2abf	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.2ac1	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2ac4					_MCLSameLine:
.2ac4	20 6d 33	jsr $336d			jsr 	GetNextNonSpace 			; get the first character.
.2ac7	f0 e6		beq $2aaf			beq 	MainCompileLoop 			; end of line, get next line.
.2ac9	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.2acb	f0 f7		beq $2ac4			beq 	_MCLSameLine
.2acd	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.2acf	10 0c		bpl $2add			bpl 	_MCLCheckAssignment
.2ad1	a2 2b		ldx #$2b			ldx 	#CommandTables & $FF 		; do command tables.
.2ad3	a0 2f		ldy #$2f			ldy 	#CommandTables >> 8
.2ad5	20 f3 31	jsr $31f3			jsr 	GeneratorProcess
.2ad8	b0 ea		bcs $2ac4			bcs 	_MCLSameLine 				; keep trying to compile the line.
.2ada					_MCLSyntax:
.2ada	4c e2 1e	jmp $1ee2		jmp	ErrorV_syntax
.2add					_MCLCheckAssignment:
.2add	20 83 33	jsr $3383			jsr 	CharIsAlpha 				; if not alpha then syntax error
.2ae0	90 f8		bcc $2ada			bcc 	_MCLSyntax
.2ae2	20 a9 34	jsr $34a9			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.2ae5	80 dd		bra $2ac4			bra		_MCLSameLine 				; loop back.
.2ae7					SaveCodeAndExit:
.2ae7	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.2ae9	20 09 2b	jsr $2b09			jsr 	CallAPIHandler
.2aec	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.2aee	a8		tay				tay
.2aef	20 db 34	jsr $34db			jsr 	STRMarkLine
.2af2	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.2af4	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2af7	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.2af9	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2afc	20 23 2e	jsr $2e23			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.2aff	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.2b01	20 09 2b	jsr $2b09			jsr 	CallAPIHandler
.2b04					ExitCompiler:
.2b04	ae bc 06	ldx $06bc			ldx 	compilerSP 					; reload SP and exit.
.2b07	9a		txs				txs
.2b08	60		rts				rts
.2b09					CallAPIHandler:
.2b09	6c bd 06	jmp ($06bd)			jmp 	(APIVector)
.06bc					compilerSP:
>06bc							.fill 	1
.06bd					APIVector:
>06bd							.fill 	2
.06bf					compilerStartHigh:
>06bf							.fill 	1
.06c0					compilerEndHigh:
>06c0							.fill 	1
.2b0c					PushIntegerYA:
.2b0c	c0 00		cpy #$00			cpy 	#0 							; 0-255
.2b0e	f0 0f		beq $2b1f			beq 	PushIntegerA
.2b10	48		pha				pha
.2b11	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.2b13	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2b16	68		pla				pla 								; then LSB
.2b17	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2b1a	98		tya				tya 								; then MSB
.2b1b	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2b1e	60		rts				rts
.2b1f					PushIntegerA:
.2b1f	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.2b21	90 07		bcc $2b2a			bcc 	_PIWriteA
.2b23	48		pha				pha
.2b24	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.2b26	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2b29	68		pla				pla
.2b2a					_PIWriteA:
.2b2a	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2b2d	60		rts				rts
.2b2e					PushFloatCommand:
.2b2e	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.2b30	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2b33	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.2b35	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2b38	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2b3a	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2b3d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2b3f	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2b42	b5 56		lda $56,x			lda 	NSMantissa2,x
.2b44	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2b47	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.2b49	29 80		and #$80			and 	#$80
.2b4b	15 62		ora $62,x			ora 	NSMantissa3,x
.2b4d	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2b50	60		rts				rts
.2b51					CreateVariableRecord:
.2b51	48		pha				pha
.2b52	ad cb 06	lda $06cb			lda 	freeVariableMemory 		; push current free address on stack.
.2b55	48		pha				pha
.2b56	ad cc 06	lda $06cc			lda 	freeVariableMemory+1
.2b59	48		pha				pha
.2b5a	ad c9 06	lda $06c9			lda 	variableListEnd  		; copy end of list to zTemp0
.2b5d	85 2c		sta $2c				sta 	zTemp0
.2b5f	ad ca 06	lda $06ca			lda 	variableListEnd+1
.2b62	85 2d		sta $2d				sta 	zTemp0+1
.2b64	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.2b66	92 2c		sta ($2c)			sta 	(zTemp0)
.2b68	98		tya				tya
.2b69	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.2b6b	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b6d	88		dey				dey
.2b6e	8a		txa				txa
.2b6f	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b71	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.2b73	ad cb 06	lda $06cb			lda 	freeVariableMemory
.2b76	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b78	c8		iny				iny
.2b79	ad cc 06	lda $06cc			lda 	freeVariableMemory+1
.2b7c	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b7e	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.2b80	a9 00		lda #$00			lda 	#0
.2b82	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b84	18		clc				clc
.2b85	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.2b87	6d c9 06	adc $06c9			adc  	variableListEnd
.2b8a	8d c9 06	sta $06c9			sta 	variableListEnd
.2b8d	90 03		bcc $2b92			bcc 	_CVNoCarry2
.2b8f	ee ca 06	inc $06ca			inc 	variableListEnd+1
.2b92					_CVNoCarry2:
.2b92	7a		ply				ply
.2b93	fa		plx				plx
.2b94	68		pla				pla
.2b95	60		rts				rts
.2b96					SetVariableRecordToCodePosition:
.2b96	48		pha				pha
.2b97	5a		phy				phy
.2b98	a0 03		ldy #$03			ldy 	#3
.2b9a	a5 2b		lda $2b				lda 	objPtr+1
.2b9c	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b9e	c8		iny				iny
.2b9f	a5 2a		lda $2a				lda 	objPtr
.2ba1	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2ba3	7a		ply				ply
.2ba4	68		pla				pla
.2ba5	60		rts				rts
.2ba6					AllocateBytesForType:
.2ba6	48		pha				pha
.2ba7	da		phx				phx
.2ba8	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.2baa	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2bac	c9 00		cmp #$00			cmp 	#NSSIFloat
.2bae	d0 02		bne $2bb2			bne 	_CVNotFloat
.2bb0	a2 06		ldx #$06			ldx 	#6
.2bb2					_CVNotFloat:
.2bb2	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.2bb3	18		clc				clc
.2bb4	6d cb 06	adc $06cb			adc 	freeVariableMemory
.2bb7	8d cb 06	sta $06cb			sta 	freeVariableMemory
.2bba	90 03		bcc $2bbf			bcc 	_CVNoCarry1
.2bbc	ee cc 06	inc $06cc			inc 	freeVariableMemory+1
.2bbf					_CVNoCarry1:
.2bbf	fa		plx				plx
.2bc0	68		pla				pla
.2bc1	60		rts				rts
.2bc2					CommandDATA:
.2bc2	20 2e 2a	jsr $2a2e			jsr 	BufferClear 				; copy it to the buffer
.2bc5	20 54 33	jsr $3354			jsr 	LookNextNonSpace
.2bc8					_CTDataLoop:
.2bc8	20 51 33	jsr $3351			jsr 	LookNext 					; reached EOL
.2bcb	f0 08		beq $2bd5			beq 	_CTDataDone
.2bcd	20 32 2a	jsr $2a32			jsr 	BufferWrite 				; write and consume
.2bd0	20 62 33	jsr $3362			jsr 	GetNext
.2bd3	80 f3		bra $2bc8			bra 	_CTDataLoop
.2bd5					_CTDataDone:
.2bd5	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.2bd7	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2bda	20 3e 2a	jsr $2a3e			jsr 	BufferOutput
.2bdd	60		rts				rts
.2bde					CommandDEF:
.2bde	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.2be0	20 1f 2b	jsr $2b1f			jsr 	PushIntegerA
.2be3	20 72 34	jsr $3472			jsr 	CompileGotoEOL 				; compile skip over DEF
.2be6	a9 a5		lda #$a5			lda 	#C64_FN
.2be8	20 5f 2a	jsr $2a5f			jsr 	CheckNextA
.2beb	20 6d 33	jsr $336d			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2bee	20 d2 33	jsr $33d2			jsr 	ExtractVariableName
.2bf1	8a		txa				txa
.2bf2	10 51		bpl $2c45			bpl 	_CDError
.2bf4	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2bf5	29 7f		and #$7f			and 	#$7F
.2bf7	aa		tax				tax
.2bf8	98		tya				tya
.2bf9	09 80		ora #$80			ora 	#$80
.2bfb	a8		tay				tay
.2bfc	20 c7 2d	jsr $2dc7			jsr 	FindVariable				; does it already exist ?
.2bff	b0 44		bcs $2c45			bcs 	_CDError 					; if so, that's an error.
.2c01	20 51 2b	jsr $2b51			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.2c04	20 96 2b	jsr $2b96			jsr 	SetVariableRecordToCodePosition
.2c07	20 6d 33	jsr $336d			jsr 	GetNextNonSpace
.2c0a	20 ae 36	jsr $36ae			jsr 	GetReferenceTerm 			; get var ref, not array
.2c0d	c9 00		cmp #$00			cmp 	#0
.2c0f	30 34		bmi $2c45			bmi 	_CDError
.2c11	8d c1 06	sta $06c1			sta 	defType 					; save type
.2c14	8e c2 06	stx $06c2			stx 	defVariable 				; save var ref
.2c17	8c c3 06	sty $06c3			sty 	defVariable+1
.2c1a	29 40		and #$40			and 	#NSSString 					; only numbers.
.2c1c	d0 27		bne $2c45			bne 	_CDError
.2c1e	20 59 2a	jsr $2a59			jsr 	CheckNextRParen 			; check )
.2c21	a9 b2		lda #$b2			lda 	#C64_EQUAL
.2c23	20 5f 2a	jsr $2a5f			jsr 	CheckNextA 					; check =
.2c26	18		clc				clc 								; if this is DEF FNxx(A), read A
.2c27	20 48 2c	jsr $2c48			jsr 	CDReadWriteVariable
.2c2a	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2c2c	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2c2f	38		sec				sec
.2c30	20 48 2c	jsr $2c48			jsr 	CDReadWriteVariable 		; A is now updated
.2c33	20 0d 2d	jsr $2d0d			jsr 	CompileExpressionAt0 		; the actual body of the function.
.2c36	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2c38	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2c3b	38		sec				sec
.2c3c	20 48 2c	jsr $2c48			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.2c3f	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.2c41	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2c44	60		rts				rts
.2c45					_CDError:
.2c45	4c e2 1e	jmp $1ee2		jmp	ErrorV_syntax
.2c48					CDReadWriteVariable:
.2c48	ac c3 06	ldy $06c3			ldy 	defVariable+1 				; set up YX
.2c4b	ae c2 06	ldx $06c2			ldx 	defVariable
.2c4e	ad c1 06	lda $06c1			lda 	defType
.2c51	20 60 36	jsr $3660			jsr 	GetSetVariable
.2c54	60		rts				rts
.06c1					defType:
>06c1							.fill 	1
.06c2					defVariable:
>06c2							.fill 	2
.2c55					CommandDIM:
.2c55	20 6d 33	jsr $336d			jsr 	GetNextNonSpace 			; get the first non space character
.2c58	20 d2 33	jsr $33d2			jsr 	ExtractVariableName 		; variable name to XY
.2c5b	da		phx				phx 								; save name with type bits.
.2c5c	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.2c5e	10 37		bpl $2c97			bpl 	_CDError
.2c60	20 c7 2d	jsr $2dc7			jsr 	FindVariable	 			; see if already exist
.2c63	b0 35		bcs $2c9a			bcs 	_CDRedefine 				; it still exists.
.2c65	20 51 2b	jsr $2b51			jsr 	CreateVariableRecord 		; create the basic variable
.2c68	20 a6 2b	jsr $2ba6			jsr 	AllocateBytesForType 		; allocate memory for it
.2c6b	68		pla				pla 								; restore type bits
.2c6c	5a		phy				phy 								; save the address of the basic storage
.2c6d	da		phx				phx
.2c6e	48		pha				pha
.2c6f	20 9d 2c	jsr $2c9d			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.2c72	68		pla				pla
.2c73	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.2c75	20 1f 2b	jsr $2b1f			jsr 	PushIntegerA 				; push that type data out.
.2c78	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.2c7a	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2c7d	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.2c7f	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2c82	fa		plx				plx 								; restore address
.2c83	7a		ply				ply
.2c84	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2c86	38		sec				sec
.2c87	20 60 36	jsr $3660			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.2c8a	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; , follows ?
.2c8d	c9 2c		cmp #$2c			cmp 	#","
.2c8f	d0 05		bne $2c96			bne 	_CDExit
.2c91	20 62 33	jsr $3362			jsr 	GetNext 					; consume comma
.2c94	80 bf		bra $2c55			bra 	CommandDIM 					; do another DIM
.2c96					_CDExit:
.2c96	60		rts				rts
.2c97					_CDError:
.2c97	4c e2 1e	jmp $1ee2		jmp	ErrorV_syntax
.2c9a					_CDRedefine:
.2c9a	4c aa 1f	jmp $1faa		jmp	ErrorV_redefine
.2c9d					OutputIndexGroup:
.2c9d	9c c4 06	stz $06c4			stz 	IndexCount 					; count of number of indices.
.2ca0					_OIGNext:
.2ca0	20 0d 2d	jsr $2d0d			jsr 	CompileExpressionAt0 		; get a dimension
.2ca3	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ca5	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ca7	d0 19		bne $2cc2			bne 	_OIGType
.2ca9	ee c4 06	inc $06c4			inc 	IndexCount 					; bump the counter.
.2cac	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; does a , follow ?
.2caf	c9 2c		cmp #$2c			cmp 	#","
.2cb1	d0 05		bne $2cb8			bne 	_OIGCheckEnd
.2cb3	20 62 33	jsr $3362			jsr 	GetNext 					; consume comma
.2cb6	80 e8		bra $2ca0			bra 	_OIGNext 					; get next dimension
.2cb8					_OIGCheckEnd:
.2cb8	20 59 2a	jsr $2a59			jsr 	CheckNextRParen 			; check and consume )
.2cbb	ad c4 06	lda $06c4			lda 	IndexCount
.2cbe	20 1f 2b	jsr $2b1f			jsr 	PushIntegerA 				; compile the dimension count.
.2cc1	60		rts				rts
.2cc2					_OIGType:
.2cc2	4c f2 1e	jmp $1ef2		jmp	ErrorV_type
.06c4					IndexCount:
>06c4							.fill 	1
.2cc5					CompilerErrorHandler:
.2cc5	68		pla				pla
.2cc6	7a		ply				ply
.2cc7	85 2c		sta $2c				sta 	zTemp0
.2cc9	84 2d		sty $2d				sty 	zTemp0+1
.2ccb	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.2ccd	a0 01		ldy #$01			ldy 	#1
.2ccf					_EHDisplayMsg:
.2ccf	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2cd1	20 04 2a	jsr $2a04			jsr 	PrintCharacter
.2cd4	c8		iny				iny
.2cd5	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2cd7	d0 f6		bne $2ccf			bne 	_EHDisplayMsg
.2cd9	a9 20		lda #$20			lda 	#32
.2cdb	20 04 2a	jsr $2a04			jsr 	PrintCharacter
.2cde	a9 40		lda #$40			lda 	#64
.2ce0	20 04 2a	jsr $2a04			jsr 	PrintCharacter
.2ce3	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.2ce5	20 2a 26	jsr $262a			jsr 	FloatSetByte
.2ce8	20 f0 29	jsr $29f0			jsr 	GetLineNumber
.2ceb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2ced	98		tya				tya
.2cee	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2cf0	20 10 25	jsr $2510			jsr 	FloatToString
.2cf3	a0 00		ldy #$00			ldy 	#0 							; display that string.
.2cf5	a2 00		ldx #$00			ldx 	#0
.2cf7					_EHDisplayLine:
.2cf7	b9 96 05	lda $0596,y			lda 	decimalBuffer,y
.2cfa	20 04 2a	jsr $2a04			jsr 	PrintCharacter
.2cfd	c8		iny				iny
.2cfe	b9 96 05	lda $0596,y			lda 	decimalBuffer,y
.2d01	d0 f4		bne $2cf7			bne 	_EHDisplayLine
.2d03	a9 0d		lda #$0d			lda 	#13
.2d05	20 04 2a	jsr $2a04			jsr 	PrintCharacter
.2d08	80 fe		bra $2d08	_EHHalt:bra 	_EHHalt
.2d0a	4c 04 2b	jmp $2b04			jmp 	ExitCompiler
.2d0d					CompileExpressionAt0:
.2d0d	a9 00		lda #$00			lda 	#0
.2d0f					CompileExpressionAtA:
.2d0f	48		pha				pha  								; save level
.2d10	20 19 37	jsr $3719			jsr 	CompileTerm 				; compile a term.
.2d13	fa		plx				plx 								; get level back into X
.2d14					_ECALoop:
.2d14	48		pha				pha 								; save type on stack.
.2d15	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; get the next character
.2d18	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.2d1a	90 04		bcc $2d20			bcc 	_ECAExit
.2d1c	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.2d1e	90 02		bcc $2d22			bcc 	_ECAHaveToken
.2d20					_ECAExit:
.2d20	68		pla				pla 								; throw type off stack
.2d21	60		rts				rts
.2d22					_ECAHaveToken:
.2d22	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.2d24	aa		tax				tax 								; X contains the operator token
.2d25	bd 10 2d	lda $2d10,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.2d28	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.2d2a	90 f4		bcc $2d20			bcc 	_ECAExit
.2d2c	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.2d2e	20 62 33	jsr $3362			jsr 	GetNext 					; consume the token.
.2d31	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.2d33	f0 11		beq $2d46			beq 	_ECAGreaterCheck
.2d35	e0 b3		cpx #$b3			cpx 	#C64_LESS
.2d37	d0 1a		bne $2d53			bne 	_ECAHaveFullToken
.2d39	20 51 33	jsr $3351			jsr 	LookNext 					; checks for < (<= or <>)
.2d3c	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.2d3e	f0 0e		beq $2d4e			beq	 	_ECAToNotEqual
.2d40	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.2d42	d0 0f		bne $2d53			bne 	_ECAHaveFullToken
.2d44	80 07		bra $2d4d			bra 	_ECAAddEqual
.2d46					_ECAGreaterCheck:
.2d46	20 51 33	jsr $3351			jsr 	LookNext
.2d49	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.2d4b	d0 06		bne $2d53			bne 	_ECAHaveFullToken
.2d4d					_ECAAddEqual:
.2d4d	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.2d4e					_ECAToNotEqual:
.2d4e	e8		inx				inx
.2d4f	e8		inx				inx
.2d50	20 62 33	jsr $3362			jsr 	GetNext 					; consume the = or > in >= <= <>
.2d53					_ECAHaveFullToken:
.2d53	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.2d55	d0 0a		bne $2d61			bne 	_ECANotConcat
.2d57	68		pla				pla 								; get type back
.2d58	48		pha				pha
.2d59	29 40		and #$40			and 	#NSSTypeMask
.2d5b	c9 40		cmp #$40			cmp 	#NSSString
.2d5d	d0 02		bne $2d61			bne 	_ECANotConcat
.2d5f	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2d61					_ECANotConcat:
.2d61	da		phx				phx 								; save operator on the stack
.2d62	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.2d64	da		phx				phx
.2d65	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.2d67	1a		inc a				inc 	a
.2d68	20 0f 2d	jsr $2d0f			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.2d6b	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.2d6d	fa		plx				plx 								; restore current precedence in X
.2d6e	68		pla				pla 								; restore operator
.2d6f	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.2d71	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.2d73	90 17		bcc $2d8c			bcc 	_ECANotCompare
.2d75	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.2d77	b0 13		bcs $2d8c			bcs 	_ECANotCompare
.2d79	7a		ply				ply 								; get type into Y
.2d7a	5a		phy				phy
.2d7b	48		pha				pha 								; save operator
.2d7c	98		tya				tya 								; get type
.2d7d	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.2d7f	29 40		and #$40			and 	#NSSTypeMask
.2d81	c9 40		cmp #$40			cmp 	#NSSString
.2d83	f0 02		beq $2d87			beq 	_ECANotString
.2d85	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.2d87					_ECANotString:
.2d87	98		tya				tya									; output token Y
.2d88	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2d8b	68		pla				pla 								; restore operator.
.2d8c					_ECANotCompare:
.2d8c	18		clc				clc 								; convert to P-Code and compile.
.2d8d	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.2d8f	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2d92	68		pla				pla 								; type of current result
.2d93	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.2d95	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.2d97	d0 19		bne $2db2			bne		_ECAType
.2d99	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.2d9b	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.2d9d	d0 18		bne $2db7			bne 	_ECAGoLoop
.2d9f	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.2da1	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2da3	f0 10		beq $2db5			beq 	_ECAOkayString 				; (this is post conversion)
.2da5	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.2da7	90 09		bcc $2db2			bcc 	_ECAType
.2da9	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.2dab	b0 05		bcs $2db2			bcs 	_ECAType
.2dad	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.2daf	4c 14 2d	jmp $2d14			jmp 	_ECALoop
.2db2					_ECAType:
.2db2	4c f2 1e	jmp $1ef2		jmp	ErrorV_type
.2db5					_ECAOkayString:
.2db5	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.2db7					_ECAGoLoop:
.2db7	4c 14 2d	jmp $2d14			jmp 	_ECALoop
.2dba					PrecedenceTable:
>2dba	03						.byte 	3 					; '+'
>2dbb	03						.byte 	3 					; '-'
>2dbc	04						.byte 	4 					; '*'
>2dbd	04						.byte 	4 					; '/'
>2dbe	05						.byte 	5 					; '^'
>2dbf	01						.byte 	1 					; 'and'
>2dc0	00						.byte 	0 					; 'or'
>2dc1	02						.byte 	2 					; '>'
>2dc2	02						.byte 	2 					; '='
>2dc3	02						.byte 	2 					; '<'
>2dc4	02						.byte 	2 					; '>='
>2dc5	02						.byte 	2 					; '<='
>2dc6	02						.byte 	2 					; '<>'
.2dc7					FindVariable:
.2dc7	86 2e		stx $2e				stx 	zTemp1 						; save name.
.2dc9	84 2f		sty $2f				sty 	zTemp1+1
.2dcb					_IVCheckSpecial:
.2dcb	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.2dcd	d0 18		bne $2de7			bne 	_IVStandard
.2dcf	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.2dd1	f0 0c		beq $2ddf			beq 	_IVTIFloat
.2dd3	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.2dd5	d0 10		bne $2de7			bne 	_IVStandard
.2dd7	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.2dd9	a2 01		ldx #$01			ldx 	#$01
.2ddb	a9 40		lda #$40			lda 	#NSSString
.2ddd	38		sec				sec
.2dde	60		rts				rts
.2ddf					_IVTIFloat:
.2ddf	a0 80		ldy #$80			ldy 	#$80
.2de1	a2 00		ldx #$00			ldx 	#$00
.2de3	a9 00		lda #$00			lda 	#0
.2de5	38		sec				sec
.2de6	60		rts				rts
.2de7					_IVStandard:
.2de7	ad bf 06	lda $06bf			lda 	compilerStartHigh			; start scanning from here.
.2dea	85 2d		sta $2d				sta 	zTemp0+1
.2dec	64 2c		stz $2c				stz 	zTemp0
.2dee					_IVCheckLoop:
.2dee	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.2df0	f0 2b		beq $2e1d			beq  	_IVNotFound 				; if so, return with CC.
.2df2	a0 01		ldy #$01			ldy 	#1 							; match ?
.2df4	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2df6	c5 2e		cmp $2e				cmp 	zTemp1
.2df8	d0 07		bne $2e01			bne	 	_IVNext
.2dfa	c8		iny				iny
.2dfb	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2dfd	c5 2f		cmp $2f				cmp 	zTemp1+1
.2dff	f0 0d		beq $2e0e			beq 	_IVFound
.2e01					_IVNext:
.2e01	18		clc				clc
.2e02	a5 2c		lda $2c				lda 	zTemp0
.2e04	72 2c		adc ($2c)			adc 	(zTemp0)
.2e06	85 2c		sta $2c				sta 	zTemp0
.2e08	90 e4		bcc $2dee			bcc 	_IVCheckLoop
.2e0a	e6 2d		inc $2d				inc 	zTemp0+1
.2e0c	80 e0		bra $2dee			bra 	_IVCheckLoop
.2e0e					_IVFound:
.2e0e	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.2e10	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e12	aa		tax				tax
.2e13	c8		iny				iny
.2e14	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e16	48		pha				pha
.2e17	c8		iny				iny
.2e18	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e1a	7a		ply				ply
.2e1b	38		sec				sec
.2e1c	60		rts				rts
.2e1d					_IVNotFound:
.2e1d	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.2e1f	a4 2f		ldy $2f				ldy 	zTemp1+1
.2e21	18		clc				clc
.2e22	60		rts				rts
.2e23					FixBranches:
.2e23	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.2e25	20 09 2b	jsr $2b09			jsr 	CallAPIHandler
.2e28					_FBLoop:
.2e28	b2 2a		lda ($2a)			lda 	(objPtr) 					; get the next one.
.2e2a	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.2e2c	f0 16		beq $2e44			beq 	_FBFixGotoGosub
.2e2e	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.2e30	f0 12		beq $2e44			beq 	_FBFixGotoGosub
.2e32	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.2e34	f0 0e		beq $2e44			beq 	_FBFixGotoGosub
.2e36	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.2e38	f0 0a		beq $2e44			beq 	_FBFixGotoGosub
.2e3a	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.2e3c	f0 3b		beq $2e79			beq 	_FBFixVarSpace
.2e3e					_FBNext:
.2e3e	20 f7 1f	jsr $1ff7			jsr 	MoveObjectForward 			; move forward in object code.
.2e41	90 e5		bcc $2e28			bcc 	_FBLoop 					; not finished
.2e43					_FBExit:
.2e43	60		rts				rts
.2e44					_FBFixGotoGosub:
.2e44	a0 01		ldy #$01			ldy 	#1							; line number in YA
.2e46	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e48	48		pha				pha
.2e49	c8		iny				iny
.2e4a	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e4c	a8		tay				tay
.2e4d	68		pla				pla
.2e4e	20 04 35	jsr $3504			jsr 	STRFindLine			 		; find where it is YA
.2e51	90 08		bcc $2e5b			bcc 	_FBFFound 					; not found, so must be >
.2e53	48		pha				pha
.2e54	b2 2a		lda ($2a)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.2e56	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.2e58	d0 0f		bne $2e69			bne 	_FBFFail
.2e5a	68		pla				pla
.2e5b					_FBFFound:
.2e5b	20 54 35	jsr $3554			jsr 	STRMakeOffset 				; make it an offset from X:YA
.2e5e	5a		phy				phy	 								; patch the GOTO/GOSUB
.2e5f	a0 01		ldy #$01			ldy 	#1
.2e61	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e63	c8		iny				iny
.2e64	68		pla				pla
.2e65	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e67	80 d5		bra $2e3e			bra 	_FBNext
.2e69					_FBFFail:
.2e69	a0 02		ldy #$02			ldy 	#2
.2e6b	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e6d	8d b8 05	sta $05b8			sta 	currentLineNumber
.2e70	c8		iny				iny
.2e71	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e73	8d b9 05	sta $05b9			sta 	currentLineNumber+1
.2e76	4c 25 1f	jmp $1f25		jmp	ErrorV_line
.2e79					_FBFixVarSpace:
.2e79	a0 01		ldy #$01			ldy 	#1
.2e7b	ad cb 06	lda $06cb			lda 	freeVariableMemory
.2e7e	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e80	c8		iny				iny
.2e81	ad cc 06	lda $06cc			lda 	freeVariableMemory+1
.2e84	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e86	80 b6		bra $2e3e			bra 	_FBNext
.2e88					CommandFOR:
.2e88	20 6d 33	jsr $336d			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.2e8b	20 83 33	jsr $3383			jsr 	CharIsAlpha 				; if not alpha , error
.2e8e	90 59		bcc $2ee9			bcc 	_CFFail
.2e90	20 ae 36	jsr $36ae			jsr 	GetReferenceTerm 			; figure out the reference.
.2e93	48		pha				pha 								; save type
.2e94	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2e96	c9 00		cmp #$00			cmp 	#NSSIFloat
.2e98	d0 4f		bne $2ee9			bne 	_CFFail
.2e9a	5a		phy				phy 								; save reference on the stack
.2e9b	da		phx				phx
.2e9c	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.2e9e	20 5f 2a	jsr $2a5f			jsr 	CheckNextA
.2ea1	20 0d 2d	jsr $2d0d			jsr 	CompileExpressionAt0 		; initial value
.2ea4	fa		plx				plx 								; get reference back.
.2ea5	7a		ply				ply
.2ea6	5a		phy				phy
.2ea7	da		phx				phx
.2ea8	38		sec				sec 								; set initial value.
.2ea9	20 60 36	jsr $3660			jsr 	GetSetVariable
.2eac	fa		plx				plx
.2ead	7a		ply				ply
.2eae	68		pla				pla
.2eaf	29 20		and #$20			and 	#NSSIInt16
.2eb1	f0 04		beq $2eb7			beq 	_CFNotInt16
.2eb3	98		tya				tya
.2eb4	09 80		ora #$80			ora 	#$80
.2eb6	a8		tay				tay
.2eb7					_CFNotInt16:
.2eb7	8a		txa				txa 								; reference in YA
.2eb8	20 0c 2b	jsr $2b0c			jsr 	PushIntegerYA
.2ebb	a9 a4		lda #$a4			lda 	#C64_TO
.2ebd	20 5f 2a	jsr $2a5f			jsr 	CheckNextA
.2ec0	20 0d 2d	jsr $2d0d			jsr 	CompileExpressionAt0 		; terminal value
.2ec3	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ec5	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ec7	d0 20		bne $2ee9			bne 	_CFFail
.2ec9	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; followed by STEP
.2ecc	c9 a9		cmp #$a9			cmp 	#C64_STEP
.2ece	d0 0e		bne $2ede			bne 	_CFNoStep
.2ed0	20 62 33	jsr $3362			jsr 	GetNext 					; consume it.
.2ed3	20 0d 2d	jsr $2d0d			jsr 	CompileExpressionAt0 		; terminal value
.2ed6	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ed8	c9 00		cmp #$00			cmp 	#NSSIFloat
.2eda	d0 0d		bne $2ee9			bne 	_CFFail
.2edc	80 05		bra $2ee3			bra 	_CFParametersDone
.2ede					_CFNoStep:
.2ede	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.2ee0	20 1f 2b	jsr $2b1f			jsr 	PushIntegerA
.2ee3					_CFParametersDone:
.2ee3	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2ee5	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2ee8	60		rts				rts
.2ee9					_CFFail:
.2ee9	4c e2 1e	jmp $1ee2		jmp	ErrorV_syntax
.2eec					FNCompile:
.2eec	20 6d 33	jsr $336d			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2eef	20 d2 33	jsr $33d2			jsr 	ExtractVariableName
.2ef2	e0 00		cpx #$00			cpx 	#0
.2ef4	10 32		bpl $2f28			bpl 	_FNError
.2ef6	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2ef7	29 7f		and #$7f			and 	#$7F
.2ef9	aa		tax				tax
.2efa	98		tya				tya
.2efb	09 80		ora #$80			ora 	#$80
.2efd	a8		tay				tay
.2efe	20 c7 2d	jsr $2dc7			jsr 	FindVariable				; does it already exist ?
.2f01	90 25		bcc $2f28			bcc 	_FNError 					; no.
.2f03	20 54 35	jsr $3554			jsr 	STRMakeOffset 				; convert to a relative address.
.2f06	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2f08	d0 01		bne $2f0b			bne 	_FNNoBorrow
.2f0a	88		dey				dey
.2f0b					_FNNoBorrow:
.2f0b	3a		dec a				dec 	a
.2f0c	5a		phy				phy 								; save location of routine on stack.
.2f0d	48		pha				pha
.2f0e	da		phx				phx
.2f0f	20 0d 2d	jsr $2d0d			jsr 	CompileExpressionAt0
.2f12	20 59 2a	jsr $2a59			jsr 	CheckNextRParen
.2f15	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.2f17	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2f1a	68		pla				pla
.2f1b	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2f1e	68		pla				pla
.2f1f	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2f22	68		pla				pla
.2f23	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.2f26	18		clc				clc
.2f27	60		rts				rts
.2f28					_FNError:
.2f28	4c d5 1e	jmp $1ed5		jmp	ErrorV_value
.2f2b					CommandTables:
>2f2b	07 cb 00 03 30 34 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2f32	07 89 00 03 37 34 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2f39	07 8d 00 03 2a 34 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>2f40	07 88 00 03 a6 34 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2f47	07 85 00 03 86 34 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>2f4e	07 84 00 04 9a 34 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>2f55	07 99 00 03 db 35 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2f5c	07 98 00 04 db 35 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2f63	07 8f 00 03 e6 36 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>2f6a	07 81 00 03 88 2e 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>2f71	07 82 00 03 5e 35 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>2f78	07 a1 00 03 a3 33 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>2f7f	07 83 00 03 c2 2b 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>2f86	07 87 00 03 24 36 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>2f8d	07 86 00 03 55 2c 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>2f94	07 96 00 03 de 2b 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>2f9b	07 8b 00 e3 53 34 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>2fa2	08 92 00 ea e3 b2 37 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>2faa	09 91 00 e1 a9 03 8a 35			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>2fb2	06
>2fb3	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>2fba	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>2fc1	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>2fc7	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>2fce	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>2fd5	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>2fdc	07 9d 00 e3 d8 37 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>2fe3	0a 9f 00 ea e3 eb 37 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>2feb	c6 06
>2fed	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>2ff3	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>2ffa	0a ce 92 e3 20 33 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>3002	ad 06
>3004	0a ce 8d e3 20 33 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>300c	ae 06
>300e	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>3014	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>301c	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>3023	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>302a	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>3032	06
>3033	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>303b	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>3043	9a 06
>3045	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>304d	9b 06
>304f	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>3057	9c 06
>3059	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>3061	06
>3062	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>3069	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>3071	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>3079	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>3081	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>3089	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>3091	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>3099	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>30a1	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>30a9	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>30b1	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>30b9	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>30c0	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>30c8	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>30d0	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>30d8	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>30e0	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>30e8	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>30f0	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>30f8	00						.byte 	0
.30f9					UnaryTables:
>30f9	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>3100	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>3108	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>310f	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>3116	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>311d	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>3124	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>312c	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>3133	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>313b	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>3143	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>314b	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>3153	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>315b	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>3163	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>316a	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>3171	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>3178	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>317f	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>3186	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>318d	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>3195	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>319d	0b ca 00 8f ae 03 20 33			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>31a5	91 bd 07
>31a8	07 a8 00 03 3f 33 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>31af	07 a5 00 03 ec 2e 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>31b6	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>31bd	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>31c4	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>31cc	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>31d4	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>31db	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>31e2	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>31e9	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>31f1	06
>31f2	00						.byte 	0
.31f3					GeneratorProcess:
.31f3	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.31f5	84 2d		sty $2d				sty 	zTemp0+1
.31f7	85 2e		sta $2e				sta 	zTemp1 						; first match token
.31f9	64 2f		stz $2f				stz 	zTemp1+1
.31fb	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.31fd	d0 05		bne $3204			bne 	_GPNotShifted
.31ff	20 62 33	jsr $3362			jsr 	GetNext 					; get the shifted token
.3202	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.3204					_GPNotShifted:
.3204					_GPSearch:
.3204	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.3206	18		clc				clc
.3207	f0 2f		beq $3238			beq 	_GPExit
.3209	a0 01		ldy #$01			ldy 	#1 							; tokens match
.320b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.320d	c5 2e		cmp $2e				cmp 	zTemp1
.320f	d0 09		bne $321a			bne 	_GPNext
.3211	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.3213	f0 12		beq $3227			beq 	_GPFound
.3215	c8		iny				iny 								; check match.
.3216	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.3218	f0 0d		beq $3227			beq 	_GPFound
.321a					_GPNext:
.321a	18		clc				clc 								; follow to next
.321b	a5 2c		lda $2c				lda 	zTemp0
.321d	72 2c		adc ($2c)			adc 	(zTemp0)
.321f	85 2c		sta $2c				sta 	zTemp0
.3221	90 e1		bcc $3204			bcc 	_GPSearch
.3223	e6 2d		inc $2d				inc 	zTemp0+1
.3225	80 dd		bra $3204			bra 	_GPSearch
.3227					_GPFound:
.3227	18		clc				clc 								; skip to action bytes
.3228	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.322a	69 03		adc #$03			adc 	#3
.322c	85 2c		sta $2c				sta 	zTemp0
.322e	90 02		bcc $3232			bcc 	_GPNoCarry
.3230	e6 2d		inc $2d				inc 	zTemp0+1
.3232					_GPNoCarry:
.3232					_GPLoop:
.3232	20 39 32	jsr $3239			jsr 	GeneratorExecute 			; execute one command
.3235	90 fb		bcc $3232			bcc 	_GPLoop 					; go back if not completed.
.3237	38		sec				sec 								; return with CS.
.3238					_GPExit:
.3238	60		rts				rts
.3239					GeneratorExecute:
.3239	20 e5 32	jsr $32e5			jsr 	_GEFetchZTemp0 				; get next.
.323c	48		pha				pha 								; split into 2 nibbles
.323d	4a		lsr a				lsr 	a
.323e	4a		lsr a				lsr 	a
.323f	4a		lsr a				lsr		a
.3240	4a		lsr a				lsr 	a
.3241	20 4b 32	jsr $324b			jsr 	_GEExecuteNibble 			; MSB first
.3244	68		pla				pla
.3245	b0 03		bcs $324a			bcs 	_GEHaveCompleted
.3247	20 4b 32	jsr $324b			jsr 	_GEExecuteNibble 			; LSB second
.324a					_GEHaveCompleted:
.324a	60		rts				rts
.324b					_GEExecuteNibble:
.324b	29 0f		and #$0f			and 	#$0F
.324d	0a		asl a				asl 	a
.324e	aa		tax				tax
.324f	7c 52 32	jmp ($3252,x)			jmp 	(_GEExecuteVectors,x)
.3252					_GEExecuteVectors:
>3252	72 32						.word 	_GEXNop 					; 0  (no operation)
>3254	7a 32						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>3256	74 32						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>3258	c8 32						.word 	_GEXExecute 				; 3  (run arbitrary code)
>325a	bb 32						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>325c	72 32						.word 	_GEXNop 					; 5
>325e	82 32						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>3260	86 32						.word 	_GEXExitString 				; 7  exit return string type
>3262	8a 32						.word 	_GEXLParam 					; 8  check ( follows
>3264	8e 32						.word 	_GEXRParam 					; 9  check ) follows
>3266	92 32						.word 	_GEXComma					; A  check , follows
>3268	72 32						.word 	_GEXNop 					; B
>326a	72 32						.word 	_GEXNop 					; C
>326c	72 32						.word 	_GEXNop 					; D
>326e	a2 32						.word 	_GEXNumber 					; E  compile get any number
>3270	ad 32						.word 	_GEXString 					; F  compile get any string
.3272					_GEXNop:
.3272	18		clc				clc
.3273	60		rts				rts
.3274					_GEXToken2:
.3274	20 e5 32	jsr $32e5			jsr 	_GEFetchZTemp0
.3277	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.327a					_GEXToken1:
.327a	20 e5 32	jsr $32e5			jsr 	_GEFetchZTemp0
.327d	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3280	18		clc				clc
.3281	60		rts				rts
.3282					_GEXExitNumber:
.3282	a9 00		lda #$00			lda 	#NSSIFloat
.3284	38		sec				sec
.3285	60		rts				rts
.3286					_GEXExitString:
.3286	a9 40		lda #$40			lda 	#NSSString
.3288	38		sec				sec
.3289	60		rts				rts
.328a					_GEXLParam:
.328a	a9 28		lda #$28			lda 	#"("
.328c	80 06		bra $3294			bra 	_GEXCheck
.328e					_GEXRParam:
.328e	a9 29		lda #$29			lda 	#")"
.3290	80 02		bra $3294			bra 	_GEXCheck
.3292					_GEXComma:
.3292	a9 2c		lda #$2c			lda 	#","
.3294					_GEXCheck:
.3294	85 30		sta $30				sta 	zTemp2 						; save match
.3296	20 6d 33	jsr $336d			jsr 	GetNextNonSpace 			; get next skipping spaces
.3299	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.329b	d0 02		bne $329f			bne 	_GEXSyntax
.329d	18		clc				clc
.329e	60		rts				rts
.329f					_GEXSyntax:
.329f	4c e2 1e	jmp $1ee2		jmp	ErrorV_syntax
.32a2					_GEXNumber:
.32a2	20 ee 32	jsr $32ee			jsr 	GEXCompileExpression 		; compile expression
.32a5	29 40		and #$40			and 	#NSSTypeMask
.32a7	c9 00		cmp #$00			cmp  	#NSSIFloat
.32a9	d0 0d		bne $32b8			bne 	_GEXType
.32ab	18		clc				clc
.32ac	60		rts				rts
.32ad					_GEXString:
.32ad	20 ee 32	jsr $32ee			jsr 	GEXCompileExpression 		; compile expression
.32b0	29 40		and #$40			and 	#NSSTypeMask
.32b2	c9 40		cmp #$40			cmp  	#NSSString
.32b4	d0 02		bne $32b8			bne 	_GEXType
.32b6	18		clc				clc
.32b7	60		rts				rts
.32b8					_GEXType:
.32b8	4c f2 1e	jmp $1ef2		jmp	ErrorV_type
.32bb					_GEXChannelExec:
.32bb	20 fe 32	jsr $32fe			jsr 	ChannelPrefix 				; set up default
.32be	20 c8 32	jsr $32c8			jsr 	_GEXExecute
.32c1	08		php				php
.32c2	20 19 33	jsr $3319			jsr 	ChannelPostfix 				; replace default.
.32c5	28		plp				plp
.32c6	60		rts				rts
>32c7	db						.byte 	$DB 						; causes a break in the emulator
.32c8					_GEXExecute:
.32c8	20 e5 32	jsr $32e5			jsr 	_GEFetchZTemp0 				; get vector
.32cb	85 30		sta $30				sta 	zTemp2
.32cd	20 e5 32	jsr $32e5			jsr 	_GEFetchZTemp0
.32d0	85 31		sta $31				sta 	zTemp2+1
.32d2	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.32d4	da		phx				phx
.32d5	a6 2d		ldx $2d				ldx 	zTemp0+1
.32d7	da		phx				phx
.32d8	20 e2 32	jsr $32e2			jsr 	_GECallZTemp2 				; execute code
.32db	fa		plx				plx 								; recover generation exec
.32dc	86 2d		stx $2d				stx 	zTemp0+1
.32de	fa		plx				plx
.32df	86 2c		stx $2c				stx 	zTemp0
.32e1	60		rts				rts
.32e2					_GECallZTemp2:
.32e2	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.32e5					_GEFetchZTemp0:
.32e5	b2 2c		lda ($2c)			lda 	(zTemp0)
.32e7	e6 2c		inc $2c				inc 	zTemp0
.32e9	d0 02		bne $32ed			bne 	_GEFZ0Skip
.32eb	e6 2d		inc $2d				inc 	zTemp0+1
.32ed					_GEFZ0Skip:
.32ed	60		rts				rts
.32ee					GEXCompileExpression:
.32ee	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.32f0	da		phx				phx
.32f1	a6 2d		ldx $2d				ldx 	zTemp0+1
.32f3	da		phx				phx
.32f4	20 0d 2d	jsr $2d0d			jsr 	CompileExpressionAt0 		; compile expression.
.32f7	fa		plx				plx 								; recover generation exec
.32f8	86 2d		stx $2d				stx 	zTemp0+1
.32fa	fa		plx				plx
.32fb	86 2c		stx $2c				stx 	zTemp0
.32fd	60		rts				rts
.32fe					ChannelPrefix:
.32fe	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.3300	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3303	20 ee 32	jsr $32ee			jsr 	GEXCompileExpression 		; channel #
.3306	29 40		and #$40			and 	#NSSTypeMask
.3308	c9 00		cmp #$00			cmp 	#NSSIFloat
.330a	d0 0a		bne $3316			bne 	_CPXType
.330c	20 55 2a	jsr $2a55			jsr 	CheckNextComma 				; check , follows.
.330f	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.3311	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3314	18		clc				clc
.3315	60		rts				rts
.3316					_CPXType:
.3316	4c f2 1e	jmp $1ef2		jmp	ErrorV_type
.3319					ChannelPostfix:
.3319	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.331b	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.331e	18		clc				clc
.331f	60		rts				rts
.3320					OptionalParameterCompile:
.3320	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; what follows.
.3323	c9 2c		cmp #$2c			cmp 	#","
.3325	d0 0e		bne $3335			bne 	_MidDefault
.3327	20 62 33	jsr $3362			jsr 	GetNext 					; consume ,
.332a	20 0d 2d	jsr $2d0d			jsr 	CompileExpressionAt0
.332d	29 40		and #$40			and 	#NSSTypeMask
.332f	c9 00		cmp #$00			cmp 	#NSSIFloat
.3331	d0 09		bne $333c			bne 	MidFailType
.3333	80 05		bra $333a			bra 	_MidComplete
.3335					_MidDefault:
.3335	a9 ff		lda #$ff			lda 	#255 						; default of 255
.3337	20 1f 2b	jsr $2b1f			jsr 	PushIntegerA
.333a					_MidComplete:
.333a	18		clc				clc
.333b	60		rts				rts
.333c					MidFailType:
.333c	4c f2 1e	jmp $1ef2		jmp	ErrorV_type
.333f					NotUnaryCompile:
.333f	ad c2 2d	lda $2dc2			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.3342	20 0f 2d	jsr $2d0f			jsr 	CompileExpressionAtA 		; evaluate at that level
.3345	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.3347	c9 00		cmp #$00			cmp 	#NSSIFloat
.3349	d0 f1		bne $333c			bne 	MidFailType
.334b	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.334d	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3350	60		rts				rts
.3351					LookNext:
.3351	b2 7a		lda ($7a)			lda 	(srcPtr)
.3353	60		rts				rts
.3354					LookNextNonSpace:
.3354	b2 7a		lda ($7a)			lda 	(srcPtr)
.3356	c9 20		cmp #$20			cmp		#' '
.3358	f0 03		beq $335d			beq 	_LNNSkip
.335a	c9 00		cmp #$00			cmp 	#0
.335c	60		rts				rts
.335d					_LNNSkip:
.335d	20 62 33	jsr $3362			jsr 	GetNext
.3360	80 f2		bra $3354			bra 	LookNextNonSpace
.3362					GetNext:
.3362	b2 7a		lda ($7a)			lda 	(srcPtr) 					; get next
.3364	e6 7a		inc $7a				inc 	srcPtr
.3366	d0 02		bne $336a			bne 	_GNSkip
.3368	e6 7b		inc $7b				inc 	srcPtr+1
.336a					_GNSkip:
.336a	c9 00		cmp #$00			cmp 	#0
.336c	60		rts				rts
.336d					GetNextNonSpace:
.336d	20 62 33	jsr $3362			jsr 	GetNext
.3370	c9 20		cmp #$20			cmp 	#' '
.3372	f0 f9		beq $336d			beq 	GetNextNonSpace
.3374	c9 00		cmp #$00			cmp 	#0
.3376	60		rts				rts
.3377					CharIsDigit:
.3377	c9 30		cmp #$30			cmp 	#"0"
.3379	90 06		bcc $3381			bcc 	CCFalse
.337b	c9 3a		cmp #$3a			cmp 	#"9"+1
.337d	b0 02		bcs $3381			bcs 	CCFalse
.337f					CCTrue:
.337f	38		sec				sec
.3380	60		rts				rts
.3381					CCFalse:
.3381	18		clc				clc
.3382	60		rts				rts
.3383					CharIsAlpha:
.3383	c9 41		cmp #$41			cmp 	#"A"
.3385	90 fa		bcc $3381			bcc 	CCFalse
.3387	c9 5b		cmp #$5b			cmp 	#"Z"+1
.3389	b0 f6		bcs $3381			bcs 	CCFalse
.338b	80 f2		bra $337f			bra 	CCTrue
.338d					ConvertHexStyle:
.338d	38		sec				sec
.338e	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.3390	90 ef		bcc $3381			bcc 	CCFalse
.3392	c9 0a		cmp #$0a			cmp 	#9+1
.3394	90 e9		bcc $337f			bcc 	CCTrue
.3396	38		sec				sec 								; shift into hex space A=>0 Z=>25
.3397	e9 11		sbc #$11			sbc 	#"A"-"0"
.3399	90 e6		bcc $3381			bcc 	CCFalse
.339b	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.339d	b0 e2		bcs $3381			bcs 	CCFalse
.339f	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.33a1	80 dc		bra $337f			bra 	CCTrue
.33a3					CommandGET:
.33a3	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; # follows ?
.33a6	c9 23		cmp #$23			cmp 	#"#"
.33a8	d0 0d		bne $33b7			bne 	CommandGetBody
.33aa	20 62 33	jsr $3362			jsr 	GetNext 					; consume #
.33ad	20 fe 32	jsr $32fe			jsr 	ChannelPrefix 				; do it as GET#
.33b0	20 b7 33	jsr $33b7			jsr 	CommandGetBody
.33b3	20 19 33	jsr $3319			jsr 	ChannelPostfix
.33b6	60		rts				rts
.33b7					CommandGetBody:
.33b7	20 6d 33	jsr $336d			jsr 	GetNextNonSpace 			; get the first character
.33ba	20 ae 36	jsr $36ae			jsr 	GetReferenceTerm 			; identify variable to assign to
.33bd	48		pha				pha
.33be	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.33c0	c9 40		cmp #$40			cmp 	#NSSString
.33c2	d0 0b		bne $33cf			bne 	_CGType
.33c4	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.33c6	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.33c9	38		sec				sec
.33ca	68		pla				pla
.33cb	20 60 36	jsr $3660			jsr		GetSetVariable
.33ce	60		rts				rts
.33cf					_CGType:
.33cf	4c f2 1e	jmp $1ef2		jmp	ErrorV_type
.33d2					ExtractVariableName:
.33d2	20 83 33	jsr $3383			jsr 	CharIsAlpha
.33d5	90 50		bcc $3427			bcc 	_IVSyntax
.33d7	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.33d9	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.33db	64 2f		stz $2f				stz 	zTemp1+1
.33dd	20 51 33	jsr $3351			jsr 	LookNext 					; is there a second character ?
.33e0	20 83 33	jsr $3383			jsr 	CharIsAlpha  				; must be alphanumeric
.33e3	b0 05		bcs $33ea			bcs 	_IVHasSecond
.33e5	20 77 33	jsr $3377			jsr 	CharIsDigit
.33e8	90 07		bcc $33f1			bcc 	_IVCheckType
.33ea					_IVHasSecond:
.33ea	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.33ec	85 2f		sta $2f				sta 	zTemp1+1
.33ee					_IVGetNextCheck:
.33ee	20 62 33	jsr $3362			jsr 	GetNext 					; consume it
.33f1					_IVCheckType:
.33f1	20 51 33	jsr $3351			jsr 	LookNext					; check if string follows.
.33f4	20 83 33	jsr $3383			jsr 	CharIsAlpha
.33f7	b0 f5		bcs $33ee			bcs 	_IVGetNextCheck
.33f9	20 77 33	jsr $3377			jsr 	CharIsDigit
.33fc	b0 f0		bcs $33ee			bcs 	_IVGetNextCheck
.33fe	a2 40		ldx #$40			ldx 	#NSSString
.3400	c9 24		cmp #$24			cmp 	#"$"
.3402	f0 06		beq $340a			beq 	_IVHasType
.3404	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.3406	c9 25		cmp #$25			cmp 	#"%"
.3408	d0 08		bne $3412			bne 	_IVCheckArray
.340a					_IVHasType:
.340a	8a		txa				txa 								; Or X into zTemp1
.340b	05 2e		ora $2e				ora 	zTemp1
.340d	85 2e		sta $2e				sta 	zTemp1
.340f	20 62 33	jsr $3362			jsr 	GetNext 					; consume it
.3412					_IVCheckArray:
.3412	20 51 33	jsr $3351			jsr 	LookNext 					; check if array follows
.3415	c9 28		cmp #$28			cmp 	#"("
.3417	d0 09		bne $3422			bne 	_IVNotArray
.3419	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.341b	09 80		ora #$80			ora 	#NSSArray
.341d	85 2e		sta $2e				sta 	zTemp1
.341f	20 62 33	jsr $3362			jsr 	GetNext 					; consume it
.3422					_IVNotArray:
.3422	a6 2e		ldx $2e				ldx 	zTemp1
.3424	a4 2f		ldy $2f				ldy 	zTemp1+1
.3426	60		rts				rts
.3427					_IVSyntax:
.3427	4c e2 1e	jmp $1ee2		jmp	ErrorV_syntax
.342a					CommandGOSUB:
.342a	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.342c	20 3d 34	jsr $343d			jsr 	CompileBranchCommand
.342f	60		rts				rts
.3430					CommandGOAlt:
.3430	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.3432	20 5f 2a	jsr $2a5f			jsr 	CheckNextA
.3435	80 00		bra $3437			bra 	CommandGOTO
.3437					CommandGOTO:
.3437	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.3439	20 3d 34	jsr $343d			jsr 	CompileBranchCommand
.343c	60		rts				rts
.343d					CompileBranchCommand:
.343d	20 f7 29	jsr $29f7			jsr 	WriteCodeByte 				; write the command out.
.3440	20 6d 33	jsr $336d			jsr 	GetNextNonSpace
.3443	20 b6 35	jsr $35b6			jsr 	ParseConstant 				; get constant into YA
.3446	90 08		bcc $3450			bcc 	_CBCSyntax
.3448	20 f7 29	jsr $29f7			jsr 	WriteCodeByte				; and compile the actual line number
.344b	98		tya				tya
.344c	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.344f	60		rts				rts
.3450					_CBCSyntax:
.3450	4c e2 1e	jmp $1ee2		jmp	ErrorV_syntax
.3453					CommandIF:
.3453	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; what follows the tests ?
.3456	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.3458	f0 0f		beq $3469			beq 	_CIGoto
.345a	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.345c	20 5f 2a	jsr $2a5f			jsr 	CheckNextA
.345f	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; THEN <number>
.3462	20 77 33	jsr $3377			jsr 	CharIsDigit
.3465	b0 05		bcs $346c			bcs 	_CIGoto2
.3467	80 09		bra $3472			bra 	CompileGotoEOL
.3469					_CIGoto:
.3469	20 62 33	jsr $3362			jsr 	GetNext
.346c					_CIGoto2:
.346c	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.346e	20 3d 34	jsr $343d			jsr 	CompileBranchCommand
.3471	60		rts				rts
.3472					CompileGotoEOL:
.3472	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.3474	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3477	20 f0 29	jsr $29f0			jsr 	GetLineNumber 				; Get the current line number => YA
.347a	1a		inc a				inc 	a 							; and branch to +1
.347b	d0 01		bne $347e			bne 	_CGENoCarry
.347d	c8		iny				iny
.347e					_CGENoCarry:
.347e	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3481	98		tya				tya
.3482	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3485	60		rts				rts
.3486					CommandINPUT:
.3486	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; check for "
.3489	c9 22		cmp #$22			cmp 	#'"'
.348b	d0 0d		bne $349a			bne 	CommandINPUTStream
.348d	20 0d 2d	jsr $2d0d			jsr 	CompileExpressionAt0
.3490	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.3492	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3495	a9 2c		lda #$2c			lda 	#","
.3497	20 55 2a	jsr $2a55			jsr 	CheckNextComma
.349a					CommandINPUTStream:
.349a	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.349c	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.349f	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.34a1	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.34a3	4c 28 36	jmp $3628			jmp 	CommandReadInputCommon
.34a6					CommandLET:
.34a6	20 6d 33	jsr $336d			jsr 	GetNextNonSpace 			; get the first character
.34a9					CommandLETHaveFirst:
.34a9	20 ae 36	jsr $36ae			jsr 	GetReferenceTerm 			; identify variable to assign to
.34ac	da		phx				phx 								; save target on the stack.
.34ad	5a		phy				phy
.34ae	48		pha				pha
.34af	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.34b1	20 5f 2a	jsr $2a5f			jsr 	CheckNextA
.34b4	20 0d 2d	jsr $2d0d			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.34b7	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.34b9	68		pla				pla 								; get type of assignment
.34ba	48		pha				pha
.34bb	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.34bd	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.34bf	d0 17		bne $34d8			bne 	_CLType
.34c1	68		pla				pla 								; restore and compile save code
.34c2	7a		ply				ply
.34c3	fa		plx				plx
.34c4	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.34c6	f0 05		beq $34cd			beq 	_CLTIString
.34c8	38		sec				sec
.34c9	20 60 36	jsr $3660			jsr		GetSetVariable
.34cc	60		rts				rts
.34cd					_CLTIString:
.34cd	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.34cf	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.34d2	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.34d4	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.34d7	60		rts				rts
.34d8					_CLType:
.34d8	4c f2 1e	jmp $1ef2		jmp	ErrorV_type
.34db					STRMarkLine:
.34db	48		pha				pha
.34dc	38		sec				sec 								; allocate 4 bytes (line #,address)
.34dd	ad c7 06	lda $06c7			lda 	lineNumberTable 			; and copy to zTemp0
.34e0	e9 04		sbc #$04			sbc 	#4
.34e2	8d c7 06	sta $06c7			sta 	lineNumberTable
.34e5	85 2c		sta $2c				sta 	zTemp0
.34e7	ad c8 06	lda $06c8			lda 	lineNumberTable+1
.34ea	e9 00		sbc #$00			sbc 	#0
.34ec	8d c8 06	sta $06c8			sta 	lineNumberTable+1
.34ef	85 2d		sta $2d				sta 	zTemp0+1
.34f1	68		pla				pla
.34f2	92 2c		sta ($2c)			sta 	(zTemp0) 					; line # save it in +0,+1
.34f4	98		tya				tya
.34f5	a0 01		ldy #$01			ldy 	#1
.34f7	91 2c		sta ($2c),y			sta 	(zTemp0),y
.34f9	a5 2a		lda $2a				lda 	objPtr 						; save current address in +2,+3
.34fb	c8		iny				iny
.34fc	91 2c		sta ($2c),y			sta 	(zTemp0),y
.34fe	a5 2b		lda $2b				lda 	objPtr+1
.3500	c8		iny				iny
.3501	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3503	60		rts				rts
.3504					STRFindLine:
.3504	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.3506	84 2d		sty $2d				sty 	zTemp0+1
.3508	ad c0 06	lda $06c0			lda 	compilerEndHigh 			; work backwards through table
.350b	85 2f		sta $2f				sta 	zTemp1+1
.350d	64 2e		stz $2e				stz 	zTemp1
.350f					_STRSearch:
.350f	20 46 35	jsr $3546			jsr 	_STRPrevLine 				; look at previous record.
.3512	a0 01		ldy #$01			ldy 	#1
.3514	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.3516	c5 2c		cmp $2c				cmp 	zTemp0
.3518	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.351a	e5 2d		sbc $2d				sbc 	zTemp0+1
.351c	b0 0b		bcs $3529			bcs 	_STRFound 					; >=
.351e					_STRNext:
.351e	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.3520	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3522	c9 ff		cmp #$ff			cmp 	#$FF
.3524	d0 e9		bne $350f			bne 	_STRSearch
.3526	4c 3c 1f	jmp $1f3c		jmp	ErrorV_internal
.3529					_STRFound:
.3529	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.352b	45 2c		eor $2c				eor 	zTemp0
.352d	d0 06		bne $3535			bne 	_STRDifferent
.352f	b2 2e		lda ($2e)			lda 	(zTemp1)
.3531	45 2c		eor $2c				eor 	zTemp0
.3533	f0 02		beq $3537			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.3535					_STRDifferent:
.3535	a9 ff		lda #$ff			lda 	#$FF
.3537					_STROut:
.3537	18		clc				clc  								; set carry if different, e.g. > rather than >=
.3538	69 ff		adc #$ff			adc 	#255
.353a	08		php				php
.353b	c8		iny				iny 								; address into YA
.353c	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.353e	48		pha				pha
.353f	c8		iny				iny
.3540	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3542	a8		tay				tay
.3543	68		pla				pla
.3544	28		plp				plp
.3545	60		rts				rts
.3546					_STRPrevLine:
.3546	38		sec				sec 								; move backwards one entry.
.3547	a5 2e		lda $2e				lda 	zTemp1
.3549	e9 04		sbc #$04			sbc 	#4
.354b	85 2e		sta $2e				sta 	zTemp1
.354d	a5 2f		lda $2f				lda 	zTemp1+1
.354f	e9 00		sbc #$00			sbc 	#0
.3551	85 2f		sta $2f				sta 	zTemp1+1
.3553	60		rts				rts
.3554					STRMakeOffset:
.3554	18		clc				clc 								; borrow 1
.3555	e5 2a		sbc $2a				sbc 	objPtr
.3557	48		pha				pha
.3558	98		tya				tya
.3559	e5 2b		sbc $2b				sbc 	objPtr+1
.355b	a8		tay				tay
.355c	68		pla				pla
.355d	60		rts				rts
.355e					CommandNEXT:
.355e	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.3561	20 83 33	jsr $3383			jsr 	CharIsAlpha 				; if not alpha , error
.3564	90 0c		bcc $3572			bcc 	_CNNoReferenceGiven
.3566	20 62 33	jsr $3362			jsr 	GetNext
.3569	20 ae 36	jsr $36ae			jsr 	GetReferenceTerm 			; figure out the reference.
.356c	8a		txa				txa 								; reference in YA
.356d	20 0c 2b	jsr $2b0c			jsr 	PushIntegerYA 				; write it out.
.3570	80 06		bra $3578			bra 	_CNParametersDone
.3572					_CNNoReferenceGiven:
.3572	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.3574	a8		tay				tay
.3575	20 0c 2b	jsr $2b0c			jsr 	PushIntegerYA 				; write it out.
.3578					_CNParametersDone:
.3578	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.357a	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.357d	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; look for ,
.3580	c9 2c		cmp #$2c			cmp 	#","
.3582	d0 05		bne $3589			bne 	_CNExit
.3584	20 62 33	jsr $3362			jsr 	GetNext 					; consume ,
.3587	80 d5		bra $355e			bra 	CommandNEXT 				; and go round.
.3589					_CNExit:
.3589	60		rts				rts
.358a					CommandON:
.358a	20 6d 33	jsr $336d			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.358d	48		pha				pha 								; save on stack
.358e	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.3590	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.3592	f0 09		beq $359d			beq 	_COCreateLoop
.3594	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.3596	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.3598	f0 03		beq $359d			beq 	_COCreateLoop
.359a	4c e2 1e	jmp $1ee2		jmp	ErrorV_syntax
.359d					_COCreateLoop:
.359d	8a		txa				txa 								; compile a goto/gosub somewhere
.359e	da		phx				phx
.359f	20 3d 34	jsr $343d			jsr 	CompileBranchCommand
.35a2	fa		plx				plx
.35a3	20 54 33	jsr $3354			jsr 	LookNextNonSpace			; ',' follows
.35a6	c9 2c		cmp #$2c			cmp 	#","
.35a8	d0 0a		bne $35b4			bne 	_COComplete 				; if so, more line numbers
.35aa	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.35ac	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.35af	20 62 33	jsr $3362			jsr 	GetNext
.35b2	80 e9		bra $359d			bra 	_COCreateLoop
.35b4					_COComplete:
.35b4	68		pla				pla 								; throw GOTO/GOSUB
.35b5	60		rts				rts
.35b6					ParseConstant:
.35b6	a2 00		ldx #$00			ldx 	#0
.35b8	20 08 24	jsr $2408			jsr 	FloatEncodeStart 			; send first
.35bb					_ParseLoop:
.35bb	20 51 33	jsr $3351			jsr 	LookNext 					; send subsequent
.35be	20 0b 24	jsr $240b			jsr 	FloatEncodeContinue
.35c1	90 05		bcc $35c8			bcc 	_ParseDone
.35c3	20 62 33	jsr $3362			jsr 	GetNext 					; consume it
.35c6	80 f3		bra $35bb			bra 	_ParseLoop
.35c8					_ParseDone:
.35c8	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.35ca	29 80		and #$80			and 	#$80
.35cc	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.35ce	15 56		ora $56,x			ora 	NSMantissa2,x
.35d0	15 62		ora $62,x			ora 	NSMantissa3,x
.35d2	18		clc				clc
.35d3	d0 05		bne $35da			bne 	_ParseExit 					; exit with CC if need float to compile
.35d5	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.35d7	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.35d9	38		sec				sec
.35da					_ParseExit:
.35da	60		rts				rts
.35db					CommandPRINT:
.35db	20 54 33	jsr $3354			jsr 	LookNextNonSpace			; what follows ?
.35de	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.35e0	f0 1f		beq $3601			beq 	_CPCheckEnd
.35e2	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.35e4	f0 16		beq $35fc			beq 	_CPTabCheckEnd
.35e6	20 18 36	jsr $3618			jsr 	_CPAtEnd 					; check for : and EOL
.35e9	b0 22		bcs $360d			bcs 	_CPExitCR 					; exit with CR
.35eb	20 0d 2d	jsr $2d0d			jsr 	CompileExpressionAt0 		; so it is something to print
.35ee	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.35f0	29 40		and #$40			and 	#NSSString 					; if string
.35f2	d0 02		bne $35f6			bne 	_CPOut
.35f4	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.35f6					_CPOut:
.35f6	8a		txa				txa 								; print that thing
.35f7	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.35fa	80 df		bra $35db			bra 	CommandPRINT 				; and loop round/
.35fc					_CPTabCheckEnd:
.35fc	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.35fe	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3601					_CPCheckEnd:
.3601	20 62 33	jsr $3362			jsr 	GetNext 					; consume it.
.3604	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; what follows ?
.3607	20 18 36	jsr $3618			jsr 	_CPAtEnd 					; reached end
.360a	90 cf		bcc $35db			bcc 	CommandPRINT 				; no, loop back
.360c	60		rts				rts
.360d					_CPExitCR:
.360d	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.360f	20 1f 2b	jsr $2b1f			jsr 	PushIntegerA
.3612	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.3614	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3617	60		rts				rts
.3618					_CPAtEnd:
.3618	c9 00		cmp #$00			cmp 	#0
.361a	f0 06		beq $3622			beq 	_CPIsEnd
.361c	c9 3a		cmp #$3a			cmp 	#":"
.361e	f0 02		beq $3622			beq 	_CPIsEnd
.3620	18		clc				clc
.3621	60		rts				rts
.3622					_CPIsEnd:
.3622	38		sec				sec
.3623	60		rts				rts
.3624					CommandREAD:
.3624	a2 b2		ldx #$b2			ldx 	#PCD_READ
.3626	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.3628					CommandReadInputCommon:
.3628	8e c5 06	stx $06c5			stx 	numberPCode
.362b	8c c6 06	sty $06c6			sty 	stringPCode
.362e					_CRLoop:
.362e	20 6d 33	jsr $336d			jsr 	GetNextNonSpace 			; first char of identifier
.3631	20 83 33	jsr $3383			jsr 	CharIsAlpha 				; check A-Z
.3634	90 27		bcc $365d			bcc 	_CRSyntax
.3636	20 ae 36	jsr $36ae			jsr 	GetReferenceTerm 			; get the variable.
.3639	48		pha				pha 								; save type.
.363a	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.363c	c9 40		cmp #$40			cmp 	#NSSString
.363e	f0 05		beq $3645			beq 	_CRString
.3640	ad c5 06	lda $06c5			lda 	numberPCode 				; output read/input
.3643	80 03		bra $3648			bra 	_CRHaveType
.3645					_CRString:
.3645	ad c6 06	lda $06c6			lda 	stringPCode					; output read$/input$
.3648					_CRHaveType:
.3648	20 f7 29	jsr $29f7			jsr 	WriteCodeByte 				; so we have one typed data item.
.364b	68		pla				pla 								; restore type
.364c	38		sec				sec  								; write update code.
.364d	20 60 36	jsr $3660			jsr 	GetSetVariable
.3650	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; , follows ?
.3653	c9 2c		cmp #$2c			cmp 	#","
.3655	d0 05		bne $365c			bne 	_CRExit 					; if not, end of READ.
.3657	20 62 33	jsr $3362			jsr 	GetNext 					; consume comma
.365a	80 d2		bra $362e			bra 	_CRLoop 					; keep going
.365c					_CRExit:
.365c	60		rts				rts
.365d					_CRSyntax:
.365d	4c e2 1e	jmp $1ee2		jmp	ErrorV_syntax
.06c5					numberPCode:
>06c5							.fill 	1
.06c6					stringPCode:
>06c6							.fill 	1
.3660					GetSetVariable:
.3660	08		php				php 								; save direction on stack
.3661	c0 00		cpy #$00			cpy 	#$00
.3663	30 21		bmi $3686			bmi 	_GSVReadWriteSpecial
.3665	c9 00		cmp #$00			cmp 	#$00
.3667	30 33		bmi $369c			bmi 	_GSVArray
.3669	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.366b	4a		lsr a				lsr 	a 							; divide by 2
.366c	09 40		ora #$40			ora 	#64 						; and set bit 6.
.366e	28		plp				plp
.366f	90 02		bcc $3673			bcc 	_GSVNotWrite
.3671	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.3673					_GSVNotWrite:
.3673	85 2c		sta $2c				sta 	zTemp0
.3675	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.3676	4a		lsr a				lsr 	a
.3677	a8		tay				tay
.3678	8a		txa				txa
.3679	6a		ror a				ror 	a
.367a	aa		tax				tax
.367b	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.367c	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.367e	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3681	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.3682	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3685	60		rts				rts
.3686					_GSVReadWriteSpecial:
.3686	28		plp				plp
.3687	b0 10		bcs $3699			bcs 	_GSVSyntax
.3689	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.368b	f0 06		beq $3693			beq 	_GSVRWString
.368d	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.368f	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3692	60		rts				rts
.3693					_GSVRWString:
.3693	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.3695	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3698	60		rts				rts
.3699					_GSVSyntax:
.3699	4c e2 1e	jmp $1ee2		jmp	ErrorV_syntax
.369c					_GSVArray:
.369c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.369e	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.369f	4a		lsr a				lsr 	a
.36a0	4a		lsr a				lsr 	a
.36a1	4a		lsr a				lsr 	a
.36a2	4a		lsr a				lsr 	a
.36a3	28		plp				plp 								; if writing array then set bit 2.
.36a4	90 02		bcc $36a8			bcc 	_GSVANotWrite
.36a6	09 04		ora #$04			ora 	#4
.36a8					_GSVANotWrite:
.36a8	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.36aa	20 f7 29	jsr $29f7			jsr 	WriteCodeByte 				; and write it out
.36ad	60		rts				rts
.36ae					GetReferenceTerm:
.36ae	20 d2 33	jsr $33d2			jsr 	ExtractVariableName 		; get name & type info
.36b1	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.36b3	30 10		bmi $36c5			bmi 	_GRTArray
.36b5	da		phx				phx 								; save type on stack
.36b6	20 c7 2d	jsr $2dc7			jsr 	FindVariable 				; find it
.36b9	b0 06		bcs $36c1			bcs 	_GRTNoCreate 				; create if required.
.36bb	20 51 2b	jsr $2b51			jsr 	CreateVariableRecord 		; create a variable.
.36be	20 a6 2b	jsr $2ba6			jsr 	AllocateBytesForType 		; allocate memory for it
.36c1					_GRTNoCreate:
.36c1	68		pla				pla 								; get type back, strip out type information.
.36c2	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.36c4	60		rts				rts
.36c5					_GRTArray:
.36c5	da		phx				phx 								; save type information
.36c6	20 c7 2d	jsr $2dc7			jsr 	FindVariable 				; read its data, the base address in YX
.36c9	90 18		bcc $36e3			bcc 	_GRTUndeclared 				; undeclared array.
.36cb	da		phx				phx 								; save base address
.36cc	5a		phy				phy
.36cd	20 9d 2c	jsr $2c9d			jsr 	OutputIndexGroup 			; create an index group and generate them
.36d0	7a		ply				ply 								; get the array base address into YX
.36d1	fa		plx				plx
.36d2	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.36d4	18		clc				clc
.36d5	20 60 36	jsr $3660			jsr 	GetSetVariable 				; load the address of the array structure.
.36d8	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.36da	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.36dd	68		pla				pla 								; and the type data into A
.36de	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.36e0	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.36e2	60		rts				rts
.36e3					_GRTUndeclared:
.36e3	4c 99 1f	jmp $1f99		jmp	ErrorV_undeclared
.36e6					CommandREM:
.36e6	20 51 33	jsr $3351			jsr 	LookNext
.36e9	f0 05		beq $36f0			beq 	_CRExit
.36eb	20 62 33	jsr $3362			jsr 	GetNext
.36ee	80 f6		bra $36e6			bra 	CommandREM
.36f0					_CRExit:
.36f0	60		rts				rts
.36f1					STRReset:
.36f1	ad bf 06	lda $06bf			lda	 	compilerStartHigh 			; set up the two table pointers
.36f4	8d ca 06	sta $06ca			sta 	variableListEnd+1
.36f7	9c c9 06	stz $06c9			stz 	variableListEnd
.36fa	ad c0 06	lda $06c0			lda 	compilerEndHigh
.36fd	8d c8 06	sta $06c8			sta 	lineNumberTable+1
.3700	9c c7 06	stz $06c7			stz 	lineNumberTable
.3703	ad c9 06	lda $06c9			lda 	variableListEnd
.3706	85 2d		sta $2d				sta 	zTemp0+1
.3708	64 2c		stz $2c				stz 	zTemp0
.370a	a9 00		lda #$00			lda 	#0
.370c	92 2c		sta ($2c)			sta 	(zTemp0)
.370e	a9 00		lda #$00			lda 	#((0) & $FF)
.3710	8d cb 06	sta $06cb			sta 	0+freeVariableMemory
.3713	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.3715	8d cc 06	sta $06cc			sta 	1+freeVariableMemory
.3718	60		rts				rts
.06c7					lineNumberTable:
>06c7							.fill 	2
.06c9					variableListEnd:
>06c9							.fill 	2
.06cb					freeVariableMemory:
>06cb							.fill 	2
.3719					CompileTerm:
.3719	20 6d 33	jsr $336d			jsr 	GetNextNonSpace 			; get first non space character.
.371c	30 72		bmi $3790			bmi 	_CTUnaryFunctions
.371e	20 77 33	jsr $3377			jsr 	CharIsDigit 				; found a number
.3721	b0 3a		bcs $375d			bcs 	_CTDigit
.3723	c9 2e		cmp #$2e			cmp 	#"."
.3725	f0 36		beq $375d			beq 	_CTDigit
.3727	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.3729	f0 43		beq $376e			beq 	_CTString
.372b	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.372d	f0 28		beq $3757			beq 	_CTOtherBase
.372f	c9 24		cmp #$24			cmp 	#"$"
.3731	f0 24		beq $3757			beq 	_CTOtherBase
.3733	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.3735	f0 17		beq $374e			beq 	_CTBrackets
.3737	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.3739	90 10		bcc $374b			bcc 	_CTSyntax
.373b	c9 5b		cmp #$5b			cmp 	#"Z"+1
.373d	b0 0c		bcs $374b			bcs 	_CTSyntax
.373f	20 ae 36	jsr $36ae			jsr 	GetReferenceTerm 			; figure out what it is.
.3742	48		pha				pha 								; save type on stack
.3743	18		clc				clc 								; read it
.3744	20 60 36	jsr $3660			jsr 	GetSetVariable
.3747	68		pla				pla
.3748	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.374a	60		rts				rts
.374b					_CTSyntax:
.374b	4c e2 1e	jmp $1ee2		jmp	ErrorV_syntax
.374e					_CTBrackets:
.374e	20 0d 2d	jsr $2d0d			jsr 	CompileExpressionAt0
.3751	48		pha				pha
.3752	20 59 2a	jsr $2a59			jsr 	CheckNextRParen
.3755	68		pla				pla
.3756	60		rts				rts
.3757					_CTOtherBase:
.3757	20 a5 29	jsr $29a5			jsr 	InlineNonDecimal 			; non decimal constant handler
.375a	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.375c	60		rts				rts
.375d					_CTDigit:
.375d	20 b6 35	jsr $35b6			jsr 	ParseConstant 				; parse out an number, first is in A already.
.3760	90 06		bcc $3768			bcc	 	_CTFloat 					; have a float or long int.
.3762	20 0c 2b	jsr $2b0c			jsr 	PushIntegerYA 				; code to push on stack
.3765	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.3767	60		rts				rts
.3768					_CTFloat:
.3768	20 2e 2b	jsr $2b2e			jsr 	PushFloatCommand			; code to push float
.376b	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.376d	60		rts				rts
.376e					_CTString:
.376e	20 2e 2a	jsr $2a2e			jsr 	BufferClear 				; copy it to the buffer
.3771					_CTStringLoop:
.3771	20 51 33	jsr $3351			jsr 	LookNext 					; reached EOL/EOS
.3774	f0 d5		beq $374b			beq 	_CTSyntax
.3776	c9 22		cmp #$22			cmp 	#'"'
.3778	f0 08		beq $3782			beq 	_CTStringDone
.377a	20 32 2a	jsr $2a32			jsr 	BufferWrite 				; write and consume
.377d	20 62 33	jsr $3362			jsr 	GetNext
.3780	80 ef		bra $3771			bra 	_CTStringLoop
.3782					_CTStringDone:
.3782	20 62 33	jsr $3362			jsr 	GetNext 					; consume closing quote.
.3785	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.3787	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.378a	20 3e 2a	jsr $2a3e			jsr 	BufferOutput
.378d	a9 40		lda #$40			lda 	#NSSString 					; string type
.378f	60		rts				rts
.3790					_CTUnaryFunctions:
.3790	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.3792	f0 0a		beq $379e			beq 	_CTNegation
.3794	a2 f9		ldx #$f9			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.3796	a0 30		ldy #$30			ldy 	#UnaryTables >> 8
.3798	20 f3 31	jsr $31f3			jsr 	GeneratorProcess
.379b	90 ae		bcc $374b			bcc		_CTSyntax
.379d	60		rts				rts
.379e					_CTNegation:
.379e	20 19 37	jsr $3719			jsr 	CompileTerm 				; compile a term.
.37a1	48		pha				pha
.37a2	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.37a4	c9 00		cmp #$00			cmp 	#NSSIFloat
.37a6	d0 07		bne $37af			bne 	_CTType 					; error
.37a8	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.37aa	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.37ad	68		pla				pla 								; return original type.
.37ae	60		rts				rts
.37af					_CTType:
.37af	4c f2 1e	jmp $1ef2		jmp	ErrorV_type
.37b2					CommandWAIT:
.37b2	20 54 33	jsr $3354			jsr 	LookNextNonSpace
.37b5	c9 2c		cmp #$2c			cmp 	#","
.37b7	f0 10		beq $37c9			beq 	_CWThirdParameter
.37b9	a9 00		lda #$00			lda 	#0
.37bb	20 1f 2b	jsr $2b1f			jsr 	PushIntegerA
.37be					_CWExit:
.37be	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.37c0	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.37c3	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.37c5	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.37c8	60		rts				rts
.37c9					_CWThirdParameter:
.37c9	20 62 33	jsr $3362			jsr 	GetNext
.37cc	20 0f 2d	jsr $2d0f			jsr 	CompileExpressionAtA
.37cf	29 40		and #$40			and 	#NSSTypeMask
.37d1	c9 00		cmp #$00			cmp 	#NSSIFloat
.37d3	f0 e9		beq $37be			beq 	_CWExit
.37d5	4c f2 1e	jmp $1ef2		jmp	ErrorV_type
.37d8					CommandCMD:
.37d8	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.37da	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.37dd	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; followed by a , ?
.37e0	c9 2c		cmp #$2c			cmp 	#","
.37e2	d0 06		bne $37ea			bne 	_CCMDExit
.37e4	20 62 33	jsr $3362			jsr 	GetNext 					; consume comma.
.37e7	20 db 35	jsr $35db			jsr 	CommandPRINT 				; do the print code
.37ea					_CCMDExit:
.37ea	60		rts				rts
.37eb					CommandOPEN:
.37eb	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; followed by a , ?
.37ee	c9 2c		cmp #$2c			cmp 	#","
.37f0	d0 15		bne $3807			bne 	_COTwoDefaults
.37f2	20 62 33	jsr $3362			jsr 	GetNext 					; consume comma
.37f5	20 0d 2d	jsr $2d0d			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.37f8	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.37fa	f0 1e		beq $381a			beq 	_COThreeIntegers
.37fc	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.37fe	20 1f 2b	jsr $2b1f			jsr 	PushIntegerA
.3801	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.3803	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3806	60		rts				rts
.3807					_COTwoDefaults:
.3807	a9 00		lda #$00			lda 	#0
.3809	20 1f 2b	jsr $2b1f			jsr 	PushIntegerA
.380c					_COCompileNullString:
.380c	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.380e	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3811	a9 00		lda #$00			lda 	#0
.3813	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3816	20 f7 29	jsr $29f7			jsr 	WriteCodeByte
.3819	60		rts				rts
.381a					_COThreeIntegers:
.381a	20 54 33	jsr $3354			jsr 	LookNextNonSpace 			; is there a ,
.381d	c9 2c		cmp #$2c			cmp 	#","
.381f	d0 eb		bne $380c			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.3821	20 62 33	jsr $3362			jsr 	GetNext
.3824	20 0d 2d	jsr $2d0d			jsr 	CompileExpressionAt0 		; should be a filename
.3827	29 40		and #$40			and 	#NSSString
.3829	f0 01		beq $382c			beq 	_COType
.382b	60		rts				rts
.382c					_COType:
.382c	4c f2 1e	jmp $1ef2		jmp	ErrorV_type

;******  Processing input file: _library.asm

.382f					IOOpenRead:
.382f	a9 52		lda #$52			lda 	#'R' 						; read.
.3831	20 52 38	jsr $3852			jsr 	IOSetFileName 				; set up name/LFS
.3834	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for reading
.3836	20 c6 ff	jsr $ffc6			jsr 	$FFC6 						; CHKIN
.3839	60		rts				rts
.383a					IOReadByte:
.383a	da		phx				phx
.383b	5a		phy				phy
.383c	20 b7 ff	jsr $ffb7			jsr 	$FFB7 						; read ST
.383f	38		sec				sec
.3840	d0 04		bne $3846			bne 	_IORExit
.3842	20 cf ff	jsr $ffcf			jsr 	$FFCF 						; read a byte
.3845	18		clc				clc 								; status OK.
.3846					_IORExit:
.3846	7a		ply				ply
.3847	fa		plx				plx
.3848	60		rts				rts
.3849					IOReadClose:
.3849					IOWriteClose:
.3849	a9 03		lda #$03			lda 	#3 							; CLOSE# 3
.384b	20 c3 ff	jsr $ffc3			jsr 	$FFC3
.384e	20 cc ff	jsr $ffcc			jsr 	$FFCC 						; CLRCHN
.3851	60		rts				rts
.3852					IOSetFileName:
.3852	48		pha				pha 								; save R/W
.3853	86 2c		stx $2c				stx 	zTemp0
.3855	84 2d		sty $2d				sty 	zTemp0+1
.3857	a0 ff		ldy #$ff			ldy 	#$FF 						; copy name given
.3859					_IOSCopy:
.3859	c8		iny				iny 								; pre-increment copy
.385a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.385c	99 cd 06	sta $06cd,y			sta 	IONameBuffer,y
.385f	d0 f8		bne $3859			bne 	_IOSCopy
.3861	99 d1 06	sta $06d1,y			sta 	IONameBuffer+4,y
.3864	a9 2c		lda #$2c			lda 	#',' 						; append ,S,[R|W]
.3866	99 cd 06	sta $06cd,y			sta 	IONameBuffer+0,y
.3869	99 cf 06	sta $06cf,y			sta 	IONameBuffer+2,y
.386c	a9 53		lda #$53			lda 	#'S'
.386e	99 ce 06	sta $06ce,y			sta 	IONameBuffer+1,y
.3871	68		pla				pla 								; write R/W out
.3872	99 d0 06	sta $06d0,y			sta 	IONameBuffer+3,y
.3875	98		tya				tya 								; length of name to A
.3876	18		clc				clc
.3877	69 04		adc #$04			adc 	#4 							; we added 4 characters.
.3879	a2 cd		ldx #$cd			ldx 	#IONameBuffer & $FF			; name address to YX
.387b	a0 06		ldy #$06			ldy 	#IONameBuffer >> 8
.387d	20 bd ff	jsr $ffbd		    jsr 	$FFBD          				; call SETNAM
.3880	a9 03		lda #$03	    	lda 	#3 							; set LFS to 3,8,3
.3882	a2 08		ldx #$08			ldx 	#8
.3884	a0 03		ldy #$03			ldy 	#3
.3886	20 ba ff	jsr $ffba			jsr 	$FFBA
.3889	20 c0 ff	jsr $ffc0			jsr 	$FFC0 						; OPEN
.388c	60		rts				rts
.06cd					IONameBuffer:
>06cd							.fill 	64
.388d					CompileCode:
.388d	a0 38		ldy #$38			ldy 	#ObjectFile >> 8
.388f	a2 b5		ldx #$b5			ldx 	#ObjectFile & $FF
.3891	20 cb 38	jsr $38cb			jsr 	IOOpenWrite
.3894	a9 0c		lda #$0c			lda 	#12
.3896	20 d6 38	jsr $38d6			jsr 	IOWriteByte
.3899	a9 0d		lda #$0d			lda 	#13
.389b	20 d6 38	jsr $38d6			jsr 	IOWriteByte
.389e	20 49 38	jsr $3849			jsr 	IOWriteClose
.38a1	a0 38		ldy #$38			ldy 	#SourceFile >> 8
.38a3	a2 c0		ldx #$c0			ldx 	#SourceFile & $FF
.38a5	20 2f 38	jsr $382f			jsr 	IOOpenRead
>38a8	db						.byte 	$DB 						; causes a break in the emulator
.38a9	20 3a 38	jsr $383a			jsr 	IOReadByte
.38ac	20 3a 38	jsr $383a			jsr 	IOReadByte
.38af	20 49 38	jsr $3849			jsr 	IOReadClose
.38b2	4c ff ff	jmp $ffff			jmp 	$FFFF
.38b5					ObjectFile:
>38b5	4f 42 4a 45 43 54 2e 50				.text 	'OBJECT.PRG',0
>38bd	52 47 00
.38c0					SourceFile:
>38c0	53 4f 55 52 43 45 2e 50				.text 	'SOURCE.PRG',0
>38c8	52 47 00
.38cb					IOOpenWrite:
.38cb	a9 57		lda #$57			lda 	#'W'			 			; write
.38cd	20 52 38	jsr $3852			jsr 	IOSetFileName 				; set up name/LFS
.38d0	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for writing
.38d2	20 c9 ff	jsr $ffc9			jsr 	$FFC9 						; CHKOUT
.38d5	60		rts				rts
.38d6					IOWriteByte:
.38d6	48		pha				pha
.38d7	da		phx				phx
.38d8	5a		phy				phy
.38d9	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.38dc	7a		ply				ply
.38dd	fa		plx				plx
.38de	68		pla				pla
.38df	60		rts				rts

;******  Processing input file: source/main/zzfree.footer

>38e0							.align 	256
.3900					FreeMemory:

;******  End of listing
