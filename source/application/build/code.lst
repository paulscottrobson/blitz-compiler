
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl source/main/00main.header /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library _library.asm source/main/zzfree.footer
; Wed Oct 11 16:52:57 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: source/main/00main.header

.0801					StartBasicProgram:
>0801	0c 08						.word 	$080C 						; offset to next.
>0803	0a 00						.word 	10 							; line #
>0805	9e						.byte 	$9E 						; token for 'SYS'
>0806	20 32 30 36 32					.text 	' 2062'						; space, $080E in decimal
>080b	00						.byte  	0 							; end of line
>080c	00 00						.word 	0 							; end of program
.080e					StartCode:
.080e	4c 8c 39	jmp $398c			jmp 	CompileCode 				; to starting the runtime in the saved code.
.0811	a9 3b		lda #$3b			lda 	#FreeMemory >> 8 			; address of object code to run.
.0813	a2 80		ldx #$80			ldx 	#$80 						; 8000-9EFF is used for workspace.
.0815	a0 9f		ldy #$9f			ldy 	#$9F
.0817	4c 26 08	jmp $0826			jmp 	StartRuntime 				; and go do it !
.081a					PatchOutCompile:
.081a	a9 ea		lda #$ea			lda 	#$EA 						; $EA is NOP 65C02
.081c	8d 0e 08	sta $080e			sta 	StartCode 					; patch out "JMP COMPILECODE"
.081f	8d 0f 08	sta $080f			sta 	StartCode+1
.0822	8d 10 08	sta $0810			sta 	StartCode+2
.0825	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.0826					StartRuntime:
.0826	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.0829	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.082b	64 28		stz $28				stz 	codePtr
.082d	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0830	8c 06 04	sty $0406			sty 	storeEndHigh
.0833	8e 07 04	stx $0407			stx 	variableStartPage
.0836	ba		tsx				tsx 								; save the stack.
.0837	8e 08 04	stx $0408			stx 	Runtime6502SP
.083a	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.083c	a2 58		ldx #$58			ldx 	#RuntimeErrorHandler & $FF
.083e	20 f5 1e	jsr $1ef5			jsr 	SetErrorHandler
.0841	20 84 0a	jsr $0a84			jsr 	ClearMemory 				; clear memory.
.0844	20 71 16	jsr $1671			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0847	20 73 13	jsr $1373		 	jsr		SetDefaultChannel			; set default input/output channel.
.084a	20 a9 15	jsr $15a9			jsr 	RestoreCode 				; which we now call
.084d	a0 00		ldy #$00			ldy 	#0
.084f					NextCommand:
.084f	ad 09 04	lda $0409			lda  	breakCount 					; only check every 16 instructions.
.0852	69 10		adc #$10			adc 	#16
.0854	8d 09 04	sta $0409			sta 	breakCount
.0857	90 07		bcc $0860			bcc 	_NXNoCheck
.0859	da		phx				phx
.085a	5a		phy				phy 								; check Ctrl+C
.085b	20 ad 1b	jsr $1bad			jsr 	XCheckStop
.085e	7a		ply				ply
.085f	fa		plx				plx
.0860					_NXNoCheck:
.0860	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.0862	30 5b		bmi $08bf			bmi 	NXCommand 					; -if -ve command
.0864	c8		iny				iny
.0865	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0867	90 39		bcc $08a2			bcc 	PushByteA 					; 0..63 is short constants.
.0869					NXLoadStore:
.0869	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.086b	b0 19		bcs $0886			bcs 	NXIndirectLoadStore
.086d	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.086e	4a		lsr a				lsr 	a
.086f	29 0e		and #$0e			and 	#$0E
.0871	da		phx				phx 								; get ready to jump
.0872	aa		tax				tax
.0873	7c 76 08	jmp ($0876,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.0876					ReadWriteVectors:
>0876	df 14						.word 	ReadFloatCommand			; read float
>0878	bc 1a						.word 	WriteFloatCommand 			; write float
>087a	1b 15						.word 	ReadIntegerCommand 			; read integer
>087c	f8 1a						.word 	WriteIntegerCommand 		; write integer
>087e	60 15						.word 	ReadStringCommand 			; read string
>0880	37 1b						.word 	WriteStringCommand 			; write string
>0882	55 0c						.word 	Unimplemented
>0884	55 0c						.word 	Unimplemented
.0886					NXIndirectLoadStore:
.0886	29 07		and #$07			and 	#7
.0888	0a		asl a				asl 	a
.0889	da		phx				phx
.088a	aa		tax				tax
.088b	7c 8e 08	jmp ($088e,x)			jmp 	(IndirectVectors,x)
.088e					IndirectVectors:
>088e	0c 0f						.word 	IndFloatRead 				; float read
>0890	20 0f						.word 	IndInt16Read 				; int16 read
>0892	34 0f						.word 	IndStringRead 				; string read
>0894	55 0c						.word 	Unimplemented
>0896	48 0f						.word 	IndFloatWrite				; float write
>0898	5c 0f						.word 	IndInt16Write 				; int16 write
>089a	70 0f						.word 	IndStringWrite 				; string write
>089c	55 0c						.word 	Unimplemented
.089e					PushByteCommand:
.089e	fa		plx				plx
.089f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.08a1	c8		iny				iny
.08a2					PushByteA:
.08a2	e8		inx				inx 								; push constant on stack
.08a3	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.08a5	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.08a7					ClearRestWord:
.08a7	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.08a9	74 62		stz $62,x			stz 	NSMantissa3,x
.08ab	74 6e		stz $6e,x			stz 	NSExponent,x
.08ad	74 32		stz $32,x			stz 	NSStatus,x
.08af	80 9e		bra $084f			bra 	NextCommand
.08b1					PushWordCommand:
.08b1	fa		plx				plx
.08b2	e8		inx				inx
.08b3	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.08b5	c8		iny				iny
.08b6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08b8	b1 28		lda ($28),y			lda 	(codePtr),y
.08ba	c8		iny				iny
.08bb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08bd	80 e8		bra $08a7			bra 	ClearRestWord 				; handle everything else.
.08bf					NXCommand:
.08bf	c8		iny				iny 								; consume command.
.08c0	10 03		bpl $08c5			bpl 	_NXCommandNoFixUp
.08c2	20 cb 08	jsr $08cb			jsr 	FixUpY
.08c5					_NXCommandNoFixUp:
.08c5	0a		asl a				asl 	a 							; shift left
.08c6	da		phx				phx 								; save SP on stack
.08c7	aa		tax				tax				 					; and jump indirect
.08c8	7c 9b 19	jmp ($199b,x)			jmp 	(VectorTable,x)
.08cb					FixUpY:
.08cb	48		pha				pha
.08cc	98		tya				tya
.08cd	18		clc				clc
.08ce	65 28		adc $28				adc 	codePtr
.08d0	85 28		sta $28				sta 	codePtr
.08d2	90 02		bcc $08d6			bcc 	_NoCPCarry
.08d4	e6 29		inc $29				inc 	codePtr+1
.08d6					_NoCPCarry:
.08d6	a0 00		ldy #$00			ldy 	#0
.08d8	68		pla				pla
.08d9	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.0408					Runtime6502SP:
>0408							.fill 	1
.0409					breakCount:
>0409							.fill 	1
.08da					AbsoluteTOS:
.08da	fa		plx				plx
.08db	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.08e0					CommandVarSpace:
.08e0	fa		plx				plx
.08e1	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08e3	85 26		sta $26				sta 	availableMemory
.08e5	c8		iny				iny
.08e6	b1 28		lda ($28),y			lda 	(codePtr),y
.08e8	18		clc				clc
.08e9	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08ec	85 27		sta $27				sta 	availableMemory+1
.08ee	c8		iny				iny
.08ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08f2					BinaryAnd:
.08f2	fa		plx				plx
.08f3	38		sec				sec
.08f4	80 02		bra $08f8			bra 	AndOrCommon
.08f6					BinaryOr:
.08f6	fa		plx				plx
.08f7	18		clc				clc
.08f8					AndOrCommon:
.08f8	08		php				php 								; save AND/OR flag
.08f9	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.08fc	ca		dex				dex
.08fd	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.0900	28		plp				plp
.0901	90 0e		bcc $0911			bcc 	_AOCOrCode
.0903	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.0905	35 3f		and $3f,x			and		NSMantissa0+1,x
.0907	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0909	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.090b	35 4b		and $4b,x			and		NSMantissa1+1,x
.090d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.090f	80 0c		bra $091d			bra 	_AOCComplete
.0911					_AOCOrCode:
.0911	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.0913	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.0915	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0917	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0919	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.091b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.091d					_AOCComplete:
.091d	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.091f	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.0921	10 07		bpl $092a			bpl 	_AOCExit
.0923	20 57 10	jsr $1057			jsr 	Negate16Bit 				; 2's complement
.0926	a9 80		lda #$80			lda 	#$80 						; make it -ve
.0928	95 32		sta $32,x			sta 	NSStatus,x
.092a					_AOCExit:
.092a	4c 4f 08	jmp $084f			jmp 	NextCommand
.092d					ArrayConvert:
.092d	fa		plx				plx
.092e	5a		phy				phy
.092f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0931	85 2e		sta $2e				sta 	zTemp1
.0933	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0935	18		clc				clc
.0936	6d 07 04	adc $0407			adc 	variableStartPage
.0939	85 2f		sta $2f				sta 	zTemp1+1
.093b	ca		dex				dex 								; count of indices to follow -> zTemp2
.093c	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.093f	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.0941	8a		txa				txa
.0942	38		sec				sec
.0943	e5 30		sbc $30				sbc 	zTemp2
.0945	aa		tax				tax
.0946	da		phx				phx 								; stack points at the first index, which will be replaced.
.0947					_ACIndexLoop:
.0947	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart 			; integer array index
.094a	20 47 10	jsr $1047			jsr 	GetInteger16Bit 			; get the index => zTemp0
.094d	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.094f	a5 2c		lda $2c				lda 	zTemp0
.0951	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0953	a5 2d		lda $2d				lda 	zTemp0+1
.0955	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0957	b0 79		bcs $09d2			bcs 	_ACBadIndex 				; index error.
.0959	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.095b	f0 29		beq $0986			beq 	_ACInnerLevel
.095d	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.095f	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0961	10 6f		bpl $09d2			bpl 	_ACBadIndex
.0963	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0965	26 2d		rol $2d				rol 	zTemp0+1
.0967	18		clc				clc
.0968	a5 2c		lda $2c				lda		zTemp0
.096a	65 2e		adc $2e				adc 	zTemp1
.096c	85 2c		sta $2c				sta 	zTemp0
.096e	a5 2d		lda $2d				lda		zTemp0+1
.0970	65 2f		adc $2f				adc 	zTemp1+1
.0972	85 2d		sta $2d				sta 	zTemp0+1
.0974	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.0976	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0978	85 2e		sta $2e				sta 	zTemp1
.097a	c8		iny				iny
.097b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.097d	18		clc				clc
.097e	6d 07 04	adc $0407			adc 	variableStartPage
.0981	85 2f		sta $2f				sta 	zTemp1+1
.0983	e8		inx				inx 								; next index
.0984	80 c1		bra $0947			bra 	_ACIndexLoop
.0986					_ACInnerLevel:
.0986	a0 02		ldy #$02			ldy 	#2
.0988	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.098a	30 46		bmi $09d2			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.098c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.098e	c9 00		cmp #$00			cmp 	#NSSIFloat
.0990	d0 13		bne $09a5			bne 	_ACNotFloat
.0992	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.0994	48		pha				pha
.0995	a5 2c		lda $2c				lda 	zTemp0
.0997	06 2c		asl $2c				asl 	zTemp0 						; x 2
.0999	26 2d		rol $2d				rol 	zTemp0+1
.099b	18		clc				clc 								; add back x 3
.099c	65 2c		adc $2c				adc 	zTemp0
.099e	85 2c		sta $2c				sta 	zTemp0
.09a0	68		pla				pla
.09a1	65 2d		adc $2d				adc 	zTemp0+1
.09a3	85 2d		sta $2d				sta 	zTemp0+1
.09a5					_ACNotFloat:
.09a5	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.09a7	26 2d		rol $2d				rol 	zTemp0+1
.09a9	18		clc				clc
.09aa	a5 2c		lda $2c				lda 	zTemp0
.09ac	69 03		adc #$03			adc 	#3
.09ae	85 2c		sta $2c				sta 	zTemp0
.09b0	90 02		bcc $09b4			bcc 	_ACNoCarry
.09b2	e6 2d		inc $2d				inc 	zTemp0+1
.09b4					_ACNoCarry:
.09b4	fa		plx				plx 								; X points to first slot of array parameters
.09b5	18		clc				clc
.09b6	a5 2c		lda $2c				lda 	zTemp0
.09b8	65 2e		adc $2e				adc 	zTemp1
.09ba	95 3e		sta $3e,x			sta 	NSMantissa0,x
.09bc	a5 2d		lda $2d				lda 	zTemp0+1
.09be	65 2f		adc $2f				adc 	zTemp1+1
.09c0	38		sec				sec
.09c1	ed 07 04	sbc $0407			sbc 	variableStartPage
.09c4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.09c6	74 56		stz $56,x			stz 	NSMantissa2,x
.09c8	74 62		stz $62,x			stz 	NSMantissa3,x
.09ca	74 32		stz $32,x			stz 	NSStatus,x
.09cc	74 6e		stz $6e,x			stz 	NSExponent,x
.09ce	7a		ply				ply 	 							; restore code pointer
.09cf	4c 4f 08	jmp $084f			jmp 	NextCommand
.09d2					_ACBadIndex:
.09d2	4c f7 1f	jmp $1ff7		jmp	ErrorV_index
.09d5					UnaryAsc:
.09d5	fa		plx				plx
.09d6	5a		phy				phy
.09d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09d9	85 2c		sta $2c				sta 	zTemp0
.09db	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09dd	85 2d		sta $2d				sta 	zTemp0+1
.09df	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09e1	f0 06		beq $09e9			beq 	_UAExit
.09e3	5a		phy				phy 								; otherwise first character
.09e4	a0 01		ldy #$01			ldy 	#1
.09e6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09e8	7a		ply				ply
.09e9					_UAExit:
.09e9	20 75 26	jsr $2675			jsr 	FloatSetByte
.09ec	7a		ply				ply
.09ed	4c 4f 08	jmp $084f			jmp 	NextCommand
.09f0					CommandAssert:
.09f0	fa		plx				plx
.09f1	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09f3	d0 09		bne $09fe			bne 	_CAFail
.09f5	20 95 26	jsr $2695			jsr 	FloatIsZero 				; is it zero ?
.09f8	f0 04		beq $09fe			beq 	_CAFail
.09fa	ca		dex				dex
.09fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.09fe					_CAFail:
.09fe	4c 50 1f	jmp $1f50		jmp	ErrorV_assert
.0a01					X16_Audio_Parameters8_16:
.0a01	20 07 0a	jsr $0a07			jsr 	X16_Audio_Parameters8_8
.0a04	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.0a06	60		rts				rts
.0a07					X16_Audio_Parameters8_8:
.0a07	a2 01		ldx #$01			ldx 	#1
.0a09	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.0a0c	ca		dex				dex
.0a0d	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.0a10	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0a13	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.0a15	a0 00		ldy #$00			ldy 	#0
.0a17	60		rts				rts
.0a18					X16_Audio_Parameters8_String:
.0a18	20 01 0a	jsr $0a01			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.0a1b	da		phx				phx 								; set the voice
.0a1c	5a		phy				phy
.0a1d	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.0a20	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>0a23	0a						.byte 	X16_AudioCodeBank
.0a24	7a		ply				ply
.0a25	fa		plx				plx
.0a26	86 2c		stx $2c				stx 	zTemp0
.0a28	84 2d		sty $2d				sty 	zTemp0+1
.0a2a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a2c	e8		inx				inx 								; point YX to first character.
.0a2d	d0 01		bne $0a30			bne 	_X16APSSkip
.0a2f	c8		iny				iny
.0a30					_X16APSSkip:
.0a30	60		rts				rts
.0a31					Unary16Bin:
.0a31	fa		plx				plx
.0a32	20 47 10	jsr $1047			jsr 	GetInteger16Bit				; 16 bit int
.0a35	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a37	20 1a 17	jsr $171a			jsr 	StringAllocTemp
.0a3a	a5 2d		lda $2d				lda 	zTemp0+1
.0a3c	f0 03		beq $0a41			beq 	_UBNoHigh
.0a3e	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a41					_UBNoHigh:
.0a41	a5 2c		lda $2c				lda 	zTemp0
.0a43	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a46	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a49					_UBWriteBinary:
.0a49	5a		phy				phy
.0a4a	a0 08		ldy #$08			ldy 	#8
.0a4c					_UBWLoop:
.0a4c	0a		asl a				asl 	a
.0a4d	48		pha				pha
.0a4e	a9 00		lda #$00			lda  	#0
.0a50	69 30		adc #$30			adc 	#48
.0a52	20 43 17	jsr $1743			jsr 	StringWriteChar
.0a55	68		pla				pla
.0a56	88		dey				dey
.0a57	d0 f3		bne $0a4c			bne 	_UBWLoop
.0a59	7a		ply				ply
.0a5a	60		rts				rts
.0a5b					PrintCharacterX:
.0a5b	fa		plx				plx
.0a5c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a5e	ca		dex				dex
.0a5f	20 77 13	jsr $1377			jsr 	VectorPrintCharacter
.0a62	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a65					UnaryChr:
.0a65	fa		plx				plx
.0a66	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get integer to convert.
.0a69	48		pha				pha 								; save it and allocate for it
.0a6a	a9 01		lda #$01			lda 	#1 							; 1 character
.0a6c	20 1a 17	jsr $171a			jsr 	StringAllocTemp
.0a6f	a9 01		lda #$01			lda 	#1 							; length 1.
.0a71	92 22		sta ($22)			sta 	(zsTemp)
.0a73	68		pla				pla 								; character code makes string.
.0a74	5a		phy				phy
.0a75	a0 01		ldy #$01			ldy 	#1
.0a77	91 22		sta ($22),y			sta 	(zsTemp),y
.0a79	7a		ply				ply
.0a7a	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a7d					CommandClr:
.0a7d	fa		plx				plx
.0a7e	20 84 0a	jsr $0a84			jsr 	ClearMemory
.0a81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a84					ClearMemory:
.0a84	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a87	85 2d		sta $2d				sta 	zTemp0+1
.0a89	64 2c		stz $2c				stz 	zTemp0
.0a8b	5a		phy				phy
.0a8c	a0 00		ldy #$00			ldy 	#0
.0a8e					_ClearLoop1:
.0a8e	a9 00		lda #$00			lda 	#0
.0a90	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a92	c8		iny				iny
.0a93	d0 f9		bne $0a8e			bne 	_ClearLoop1
.0a95	e6 2d		inc $2d				inc 	zTemp0+1
.0a97	a5 2d		lda $2d				lda 	zTemp0+1
.0a99	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a9c	d0 f0		bne $0a8e			bne 	_ClearLoop1
.0a9e	38		sec				sec 											; stack space = number of pages in total / 4
.0a9f	ad 06 04	lda $0406			lda 	storeEndHigh
.0aa2	ed 05 04	sbc $0405			sbc		storeStartHigh
.0aa5	4a		lsr a				lsr 	a
.0aa6	4a		lsr a				lsr 	a
.0aa7	d0 02		bne $0aab			bne 	_NotEmpty 								; at least 1 !
.0aa9	a9 01		lda #$01			lda 	#1
.0aab					_NotEmpty:
.0aab	38		sec				sec 											; subtract from high to give string high memory
.0aac	49 ff		eor #$ff			eor 	#$FF
.0aae	6d 06 04	adc $0406			adc 	storeEndHigh
.0ab1	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0ab4	9c 02 04	stz $0402			stz 	stringHighMemory
.0ab7	9c 6a 05	stz $056a			stz 	stringInitialised 						; string system not initialised
.0aba	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0abd	3a		dec a				dec 	a
.0abe	85 25		sta $25				sta 	runtimeStackPtr+1
.0ac0	a9 ff		lda #$ff			lda 	#$FF
.0ac2	85 24		sta $24				sta 	runtimeStackPtr
.0ac4	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0ac6	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0ac8	7a		ply				ply
.0ac9	60		rts				rts
.0aca					CompareStrings:
.0aca	fa		plx				plx
.0acb	ca		dex				dex
.0acc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0ace	85 2c		sta $2c				sta 	zTemp0
.0ad0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ad2	85 2d		sta $2d				sta 	zTemp0+1
.0ad4	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0ad6	85 2e		sta $2e				sta 	zTemp1
.0ad8	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0ada	85 2f		sta $2f				sta 	zTemp1+1
.0adc	da		phx				phx
.0add	5a		phy				phy
.0ade	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0ae0	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0ae2	90 02		bcc $0ae6			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0ae4	b2 2e		lda ($2e)			lda 	(zTemp1)
.0ae6					_CSNIsSmallest:
.0ae6	aa		tax				tax 								; count in X
.0ae7	f0 0c		beq $0af5			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0ae9	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0aeb					_CSNCompareString:
.0aeb	c8		iny				iny 								; pre increment
.0aec	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0aee	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0af0	d0 0a		bne $0afc			bne 	_CSNDifferent 				; numbers are different.
.0af2	ca		dex				dex
.0af3	d0 f6		bne $0aeb			bne 	_CSNCompareString 			; compare common characters in two strings.
.0af5					_CSNMatches:
.0af5	38		sec				sec
.0af6	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0af8	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0afa	f0 06		beq $0b02			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0afc					_CSNDifferent:
.0afc	a9 ff		lda #$ff			lda 	#$FF
.0afe	90 02		bcc $0b02			bcc 	_CSNSExit
.0b00	a9 01		lda #$01			lda 	#$01
.0b02					_CSNSExit:
.0b02	7a		ply				ply
.0b03	fa		plx				plx
.0b04	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0b06	20 75 26	jsr $2675			jsr 	FloatSetByte 				; output the byte
.0b09	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b0c					StringConcrete:
.0b0c	9c 6a 05	stz $056a			stz 	stringInitialised	 		; initialise next usage
.0b0f	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0b11	85 30		sta $30				sta 	zTemp2
.0b13	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0b15	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0b16	18		clc				clc
.0b17	72 30		adc ($30)			adc 	(zTemp2)
.0b19	90 02		bcc $0b1d			bcc 	_SCNoOverflow
.0b1b	a9 ff		lda #$ff			lda 	#255
.0b1d					_SCNoOverflow:
.0b1d	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0b1f	b0 02		bcs $0b23			bcs 	_SCNoMinimum
.0b21	a9 0a		lda #$0a			lda 	#10
.0b23					_SCNoMinimum:
.0b23	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0b25	38		sec				sec
.0b26	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0b29	e5 2e		sbc $2e				sbc 	zTemp1
.0b2b	a8		tay				tay
.0b2c	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b2f	e9 00		sbc #$00			sbc 	#0
.0b31	48		pha				pha
.0b32	38		sec				sec 								; subtract 3 more
.0b33	98		tya				tya
.0b34	e9 03		sbc #$03			sbc 	#3
.0b36	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b39	85 22		sta $22				sta 	zsTemp
.0b3b	68		pla				pla
.0b3c	e9 00		sbc #$00			sbc 	#0
.0b3e	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b41	85 23		sta $23				sta 	zsTemp+1
.0b43	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b45	92 22		sta ($22)			sta 	(zsTemp)
.0b47	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b49	a9 00		lda #$00			lda 	#0
.0b4b	91 22		sta ($22),y			sta 	(zsTemp),y
.0b4d	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b4f	a4 23		ldy $23				ldy 	zsTemp+1
.0b51	60		rts				rts
.0b52					CommandXData:
.0b52	fa		plx				plx
.0b53	98		tya				tya 								; data length +1 added to Y
.0b54	38		sec				sec
.0b55	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b57	a8		tay				tay
.0b58	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b5b					CommandXDIM:
.0b5b	fa		plx				plx
.0b5c	5a		phy				phy
.0b5d	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b60	8d 0a 04	sta $040a			sta 	dimType
.0b63	ca		dex				dex 								; this is the number of indices
.0b64	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0b67	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b69	8a		txa				txa 								; dimension.
.0b6a	38		sec				sec
.0b6b	e5 2e		sbc $2e				sbc 	zTemp1
.0b6d	aa		tax				tax
.0b6e	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b70	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create one at this level
.0b73	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b75	98		tya				tya
.0b76	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b78	74 56		stz $56,x			stz 	NSMantissa2,x
.0b7a	74 62		stz $62,x			stz 	NSMantissa3,x
.0b7c	74 32		stz $32,x			stz 	NSStatus,x
.0b7e	74 6e		stz $6e,x			stz 	NSExponent,x
.0b80	7a		ply				ply
.0b81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b84					DIMCreateOneLevel:
.0b84	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b86	5a		phy				phy
.0b87	a4 27		ldy $27				ldy 	availableMemory+1
.0b89	5a		phy				phy
.0b8a	a8		tay				tay 			 					; save current level into Y
.0b8b	20 47 10	jsr $1047			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b8e	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b90	d0 02		bne $0b94			bne 	_DCOLNoCarry
.0b92	e6 2d		inc $2d				inc 	zTemp0+1
.0b94					_DCOLNoCarry:
.0b94	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b96	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b99	a5 2d		lda $2d				lda 	zTemp0+1
.0b9b	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b9e	ad 0a 04	lda $040a			lda 	dimType 					; get type information
.0ba1	29 7f		and #$7f			and 	#$7F
.0ba3	c0 01		cpy #$01			cpy 	#1
.0ba5	f0 02		beq $0ba9			beq 	_DCOLNoSubLevel
.0ba7	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0ba9					_DCOLNoSubLevel:
.0ba9	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0bac	a5 26		lda $26				lda 	availableMemory
.0bae	85 2e		sta $2e				sta 	zTemp1
.0bb0	a5 27		lda $27				lda 	availableMemory+1
.0bb2	85 2f		sta $2f				sta 	zTemp1+1
.0bb4	a5 2c		lda $2c				lda 	zTemp0
.0bb6	85 30		sta $30				sta 	zTemp2
.0bb8	a5 2d		lda $2d				lda 	zTemp0+1
.0bba	85 31		sta $31				sta 	zTemp2+1
.0bbc					_DCOLFillArray:
.0bbc	20 1b 0c	jsr $0c1b			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0bbf	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0bc1	d0 02		bne $0bc5			bne 	_DCOLNoBorrow
.0bc3	c6 2d		dec $2d				dec 	zTemp0+1
.0bc5					_DCOLNoBorrow:
.0bc5	c6 2c		dec $2c				dec 	zTemp0
.0bc7	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0bc9	05 2d		ora $2d				ora 	zTemp0+1
.0bcb	d0 ef		bne $0bbc			bne 	_DCOLFillArray
.0bcd	c0 01		cpy #$01			cpy 	#1
.0bcf	f0 42		beq $0c13			beq 	_DCOLExit
.0bd1					_DCOLRecursionLoop:
.0bd1	da		phx				phx 								; save XY
.0bd2	5a		phy				phy
.0bd3	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0bd5	48		pha				pha
.0bd6	a5 2f		lda $2f				lda 	zTemp1+1
.0bd8	48		pha				pha
.0bd9	a5 30		lda $30				lda 	zTemp2
.0bdb	48		pha				pha
.0bdc	a5 31		lda $31				lda 	zTemp2+1
.0bde	48		pha				pha
.0bdf	88		dey				dey  								; lower level -> A
.0be0	98		tya				tya
.0be1	e8		inx				inx 								; next index size
.0be2	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0be5	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0be6	86 31		stx $31				stx 	zTemp2+1
.0be8	fa		plx				plx
.0be9	86 30		stx $30				stx 	zTemp2
.0beb	fa		plx				plx
.0bec	86 2f		stx $2f				stx 	zTemp1+1
.0bee	fa		plx				plx
.0bef	86 2e		stx $2e				stx 	zTemp1
.0bf1	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0bf3	98		tya				tya
.0bf4	a0 01		ldy #$01			ldy 	#1
.0bf6	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0bf8	7a		ply				ply 								; restore XY
.0bf9	fa		plx				plx
.0bfa	18		clc				clc
.0bfb	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0bfd	69 02		adc #$02			adc 	#2
.0bff	85 2e		sta $2e				sta 	zTemp1
.0c01	90 02		bcc $0c05			bcc 	_DCOLRNoCarry
.0c03	e6 2f		inc $2f				inc 	zTemp1+1
.0c05					_DCOLRNoCarry:
.0c05	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0c07	d0 02		bne $0c0b			bne 	_DCOLRNoBorrow
.0c09	c6 31		dec $31				dec 	zTemp2+1
.0c0b					_DCOLRNoBorrow:
.0c0b	c6 30		dec $30				dec 	zTemp2
.0c0d	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0c0f	05 31		ora $31				ora 	zTemp2+1
.0c11	d0 be		bne $0bd1			bne 	_DCOLRecursionLoop
.0c13					_DCOLExit:
.0c13	68		pla				pla 								; get MSB, make offset again
.0c14	38		sec				sec
.0c15	ed 07 04	sbc $0407			sbc 	variableStartPage
.0c18	a8		tay				tay
.0c19	68		pla				pla 								; YA now contains offset address.
.0c1a	60		rts				rts
.0c1b					DIMWriteElement:
.0c1b	da		phx				phx
.0c1c	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0c1e	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0c20	d0 0b		bne $0c2d			bne 	_DIMWENotFloat
.0c22	ad 0a 04	lda $040a			lda 	dimType
.0c25	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0c27	c9 00		cmp #$00			cmp 	#NSSIFloat
.0c29	d0 02		bne $0c2d			bne 	_DIMWENotFloat
.0c2b	a2 06		ldx #$06			ldx 	#6
.0c2d					_DIMWENotFloat:
.0c2d	a9 00		lda #$00			lda 	#0
.0c2f	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0c32	ca		dex				dex
.0c33	d0 f8		bne $0c2d			bne 	_DIMWENotFloat
.0c35	fa		plx				plx
.0c36	60		rts				rts
.0c37					DIMWriteByte:
.0c37	92 26		sta ($26)			sta 	(availableMemory)
.0c39	e6 26		inc $26				inc 	availableMemory
.0c3b	d0 0b		bne $0c48			bne 	_DIMWBSkip
.0c3d	e6 27		inc $27				inc 	availableMemory+1
.0c3f	48		pha				pha
.0c40	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c42	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c45	b0 02		bcs $0c49			bcs 	_DIMWBMemory
.0c47	68		pla				pla
.0c48					_DIMWBSkip:
.0c48	60		rts				rts
.0c49					_DIMWBMemory:
.0c49	4c 0a 20	jmp $200a		jmp	ErrorV_memory
.040a					dimType:
>040a							.fill 	1
.0c4c					CommandEnd:
.0c4c	fa		plx				plx
.0c4d	86 2c		stx $2c				stx 	zTemp0
.0c4f	18		clc				clc 								; exited okay.
.0c50					EndRuntime:
.0c50	ae 08 04	ldx $0408			ldx 	Runtime6502SP 				; set up the stack pointer
.0c53	9a		txs				txs
.0c54	60		rts				rts
.0c55					Unimplemented:
.0c55	4c 3d 1f	jmp $1f3d			jmp 	ErrorV_unimplemented
.0c58					RuntimeErrorHandler:
.0c58	98		tya				tya
.0c59	18		clc				clc
.0c5a	65 28		adc $28				adc 	codePtr
.0c5c	85 28		sta $28				sta 	codePtr
.0c5e	90 02		bcc $0c62			bcc 	_EHNoCarry
.0c60	e6 29		inc $29				inc 	codePtr+1
.0c62					_EHNoCarry:
.0c62	68		pla				pla
.0c63	7a		ply				ply
.0c64	85 2c		sta $2c				sta 	zTemp0
.0c66	84 2d		sty $2d				sty 	zTemp0+1
.0c68	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c6a	a0 01		ldy #$01			ldy 	#1
.0c6c					_EHDisplayMsg:
.0c6c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c6e	20 9a 1c	jsr $1c9a			jsr 	XPrintCharacterToChannel
.0c71	c8		iny				iny
.0c72	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c74	d0 f6		bne $0c6c			bne 	_EHDisplayMsg
.0c76	a9 20		lda #$20			lda 	#32
.0c78	20 9a 1c	jsr $1c9a			jsr 	XPrintCharacterToChannel
.0c7b	a9 40		lda #$40			lda 	#64
.0c7d	20 9a 1c	jsr $1c9a			jsr 	XPrintCharacterToChannel
.0c80	a9 20		lda #$20			lda 	#32
.0c82	20 9a 1c	jsr $1c9a			jsr 	XPrintCharacterToChannel
.0c85	20 8c 0c	jsr $0c8c			jsr 	EHDisplayCodePtr
.0c88	38		sec				sec 								; report error.
.0c89	4c 50 0c	jmp $0c50			jmp 	EndRuntime
.0c8c					EHDisplayCodePtr:
.0c8c	a9 24		lda #$24			lda 	#'$'
.0c8e	20 9a 1c	jsr $1c9a			jsr 	XPrintCharacterToChannel
.0c91	38		sec				sec
.0c92	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c94	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c97	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9a	a5 28		lda $28				lda 	codePtr
.0c9c	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9f	60		rts				rts
.0ca0					_EHDisplayHex:
.0ca0	48		pha				pha
.0ca1	4a		lsr a				lsr 	a
.0ca2	4a		lsr a				lsr 	a
.0ca3	4a		lsr a				lsr 	a
.0ca4	4a		lsr a				lsr 	a
.0ca5	20 a9 0c	jsr $0ca9			jsr 	_EHDisplayNibble
.0ca8	68		pla				pla
.0ca9					_EHDisplayNibble:
.0ca9	29 0f		and #$0f			and 	#15
.0cab	c9 0a		cmp #$0a			cmp 	#10
.0cad	90 02		bcc $0cb1			bcc 	_EHNotHex
.0caf	69 06		adc #$06			adc 	#6
.0cb1					_EHNotHex:
.0cb1	69 30		adc #$30			adc 	#48
.0cb3	4c 9a 1c	jmp $1c9a			jmp 	XPrintCharacterToChannel
.0cb6					CommandXFor:
.0cb6	fa		plx				plx
.0cb7	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0cb9	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0cbc	20 78 11	jsr $1178			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0cbf	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0cc1	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cc4	ca		dex				dex
.0cc5	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0cc7	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cca	ca		dex				dex
.0ccb	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0ccd	29 80		and #$80			and 	#$80
.0ccf	a0 04		ldy #$04			ldy 	#4
.0cd1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd3	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0cd5	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0cd7	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd9	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0cdb	c8		iny				iny
.0cdc	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cde	18		clc				clc
.0cdf	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0ce1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ce3	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0ce6	85 2d		sta $2d				sta 	zTemp0+1
.0ce8	ca		dex				dex 								; throw reference.
.0ce9	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0ceb	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0ced	a0 0c		ldy #$0c			ldy 	#12
.0cef	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf1	a0 12		ldy #$12			ldy 	#18
.0cf3	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf5	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0cf7	88		dey				dey 								; now the exponents.
.0cf8	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0cfa	a0 0b		ldy #$0b			ldy 	#11
.0cfc	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cfe	a0 11		ldy #$11			ldy 	#17
.0d00	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d02	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0d04	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d06	c8		iny				iny
.0d07	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d09	c8		iny				iny
.0d0a	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d0c	d0 08		bne $0d16			bne 	_CFNoOptimise
.0d0e	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0d10	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0d12	09 40		ora #$40			ora 	#$40
.0d14	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d16					_CFNoOptimise:
.0d16	a0 00		ldy #$00			ldy 	#0
.0d18	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d1b					CopyTOSToOffsetY:
.0d1b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0d1d	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d1f	c8		iny				iny
.0d20	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0d22	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d24	c8		iny				iny
.0d25	b5 56		lda $56,x			lda 	NSMantissa2,x
.0d27	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d29	c8		iny				iny
.0d2a	b5 62		lda $62,x			lda 	NSMantissa3,x
.0d2c	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d2e	c8		iny				iny
.0d2f	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d31	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d33	c8		iny				iny
.0d34	b5 32		lda $32,x			lda 	NSStatus,x
.0d36	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d38	60		rts				rts
.0d39					StackOpenFrame:
.0d39	48		pha				pha 								; save frame marker
.0d3a	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d3c	85 2c		sta $2c				sta 	zTemp0
.0d3e	38		sec				sec 								; subtract from runtime stack pointer.
.0d3f	a5 24		lda $24				lda		runtimeStackPtr
.0d41	e5 2c		sbc $2c				sbc 	zTemp0
.0d43	85 24		sta $24				sta 	runtimeStackPtr
.0d45	a5 25		lda $25				lda		runtimeStackPtr+1
.0d47	e9 00		sbc #$00			sbc 	#0
.0d49	85 25		sta $25				sta 	runtimeStackPtr+1
.0d4b	68		pla				pla 								; put frame marker at +0
.0d4c	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d4e	60		rts				rts
.0d4f					StackCloseFrame:
.0d4f	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d51	29 1f		and #$1f			and 	#$1F 						; size
.0d53	18		clc				clc
.0d54	65 24		adc $24				adc 	runtimeStackPtr
.0d56	85 24		sta $24				sta 	runtimeStackPtr
.0d58	90 02		bcc $0d5c			bcc 	_SCFNoCarry
.0d5a	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d5c					_SCFNoCarry:
.0d5c	60		rts				rts
.0d5d					StackFindFrame:
.0d5d	8d 0b 04	sta $040b			sta 	requiredFrame
.0d60					_SFFLoop:
.0d60	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d62	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d64	f0 10		beq $0d76			beq 	SCFFail
.0d66	cd 0b 04	cmp $040b			cmp 	requiredFrame 				; found this type ?
.0d69	f0 05		beq $0d70			beq 	_SFFFound
.0d6b	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close the top frame
.0d6e	80 f0		bra $0d60			bra 	_SFFLoop 					; and try te next.
.0d70					_SFFFound:
.0d70	60		rts				rts
.0d71					StackCheckFrame:
.0d71	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d73	d0 01		bne $0d76			bne 	SCFFail
.0d75	60		rts				rts
.0d76					SCFFail:
.0d76	4c 9a 1f	jmp $1f9a		jmp	ErrorV_structure
.040b					requiredFrame:
>040b							.fill 	1
.0d79					UnaryFre:
.0d79	fa		plx				plx
.0d7a	20 73 26	jsr $2673			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d7d	38		sec				sec
.0d7e	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d81	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d84	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d86	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d89	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d8c	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d8e	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d91					CommandXGet:
.0d91	fa		plx				plx
.0d92	e8		inx				inx
.0d93	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d95	20 1a 17	jsr $171a			jsr 	StringAllocTemp
.0d98	20 80 13	jsr $1380			jsr 	VectorGetCharacter 			; get a character
.0d9b	c9 00		cmp #$00			cmp 	#0
.0d9d	f0 09		beq $0da8			beq 	_CGNone
.0d9f	5a		phy				phy
.0da0	a0 01		ldy #$01			ldy 	#1 							; store char
.0da2	91 22		sta ($22),y			sta 	(zsTemp),y
.0da4	98		tya				tya 								; store length.
.0da5	92 22		sta ($22)			sta 	(zsTemp)
.0da7	7a		ply				ply
.0da8					_CGNone:
.0da8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dab					CommandXGosub:
.0dab	fa		plx				plx
.0dac	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dae	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0db1	20 78 11	jsr $1178			jsr 	StackSaveCurrentPosition
.0db4	4c c9 0d	jmp $0dc9			jmp 	PerformGOTO
.0db7					CommandReturn:
.0db7	fa		plx				plx
.0db8	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dba	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.0dbd	20 89 11	jsr $1189			jsr 	StackLoadCurrentPosition
.0dc0	c8		iny				iny
.0dc1	c8		iny				iny
.0dc2	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame
.0dc5	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dc8					CommandXGoto:
.0dc8	fa		plx				plx
.0dc9					PerformGOTO:
.0dc9	c8		iny				iny 								; push MSB of offset on stack
.0dca	b1 28		lda ($28),y			lda 	(codePtr),y
.0dcc	48		pha				pha
.0dcd	88		dey				dey 								; point LSB of offset
.0dce	18		clc				clc 								; add LSB
.0dcf	b1 28		lda ($28),y			lda 	(codePtr),y
.0dd1	65 28		adc $28				adc 	codePtr
.0dd3	85 28		sta $28				sta 	codePtr
.0dd5	68		pla				pla 								; restore offset MSB and add
.0dd6	65 29		adc $29				adc 	codePtr+1
.0dd8	85 29		sta $29				sta 	codePtr+1
.0dda	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ddd					CommandGotoZ:
.0ddd	fa		plx				plx
.0dde	20 95 26	jsr $2695			jsr 	FloatIsZero
.0de1	ca		dex				dex
.0de2	c9 00		cmp #$00			cmp 	#0
.0de4	f0 e3		beq $0dc9			beq 	PerformGOTO
.0de6	c8		iny				iny
.0de7	c8		iny				iny
.0de8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0deb					CommandGotoNZ:
.0deb	fa		plx				plx
.0dec	20 95 26	jsr $2695			jsr 	FloatIsZero
.0def	ca		dex				dex
.0df0	c9 00		cmp #$00			cmp 	#0
.0df2	d0 d5		bne $0dc9			bne 	PerformGOTO
.0df4	c8		iny				iny
.0df5	c8		iny				iny
.0df6	4c 4f 08	jmp $084f			jmp 	NextCommand
.0df9					Command_PSET:
.0df9	fa		plx				plx
.0dfa	5a		phy				phy
.0dfb	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the colour
.0dfe	48		pha				pha
.0dff	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e01	a0 02		ldy #$02			ldy 	#X16_r0
.0e03	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e06	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0e09	68		pla				pla 								; set pixel.
.0e0a	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0e0d	7a		ply				ply
.0e0e	a2 ff		ldx #$ff			ldx 	#$FF
.0e10	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e13					Command_LINE:
.0e13	fa		plx				plx
.0e14	5a		phy				phy
.0e15	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e18	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0e1a	a0 02		ldy #$02			ldy 	#X16_r0
.0e1c	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0e1f	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0e22	7a		ply				ply
.0e23	a2 ff		ldx #$ff			ldx 	#$FF
.0e25	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e28					Command_RECT:
.0e28	fa		plx				plx
.0e29	5a		phy				phy
.0e2a	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e2d	38		sec				sec
.0e2e	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e31	7a		ply				ply
.0e32	a2 ff		ldx #$ff			ldx 	#$FF
.0e34	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e37					Command_FRAME:
.0e37	fa		plx				plx
.0e38	5a		phy				phy
.0e39	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e3c	18		clc				clc
.0e3d	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e40	7a		ply				ply
.0e41	a2 ff		ldx #$ff			ldx 	#$FF
.0e43	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e46					Command_CHAR:
.0e46	fa		plx				plx
.0e47	5a		phy				phy
.0e48	ca		dex				dex  								; set the draw colour
.0e49	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e4c	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e4e	a0 02		ldy #$02			ldy 	#X16_r0
.0e50	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e53	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e55	85 2c		sta $2c				sta 	zTemp0
.0e57	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e59	85 2d		sta $2d				sta 	zTemp0+1
.0e5b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e5d	85 2e		sta $2e				sta 	zTemp1
.0e5f					_CCLoop:
.0e5f	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e61	f0 0f		beq $0e72			beq 	_CCExit
.0e63	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e65	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e67	d0 02		bne $0e6b			bne 	_CCNoCarry
.0e69	e6 2d		inc $2d				inc 	zTemp0+1
.0e6b					_CCNoCarry:
.0e6b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e6d	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e70	80 ed		bra $0e5f			bra 	_CCLoop						; go round.
.0e72					_CCExit:
.0e72	7a		ply				ply
.0e73	a2 ff		ldx #$ff			ldx 	#$FF
.0e75	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e78					GraphicsColour:
.0e78	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0e7b	aa		tax				tax
.0e7c	a0 00		ldy #$00			ldy 	#0
.0e7e	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e81	60		rts				rts
.0e82					GraphicsCopy4:
.0e82	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e85					GraphicsCopy2:
.0e85	20 88 0e	jsr $0e88			jsr 	GraphicsCopy1
.0e88					GraphicsCopy1:
.0e88	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.0e8b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e8d	99 00 00	sta $0000,y			sta 	0,y
.0e90	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e92	99 01 00	sta $0001,y			sta 	1,y
.0e95	e8		inx				inx
.0e96	c8		iny				iny
.0e97	c8		iny				iny
.0e98	60		rts				rts
.0e99					GraphicsRectCoords:
.0e99	20 78 0e	jsr $0e78			jsr 	GraphicsColour 				; set colour
.0e9c	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e9e	a0 02		ldy #$02			ldy 	#X16_r0
.0ea0	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0ea3	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0ea5	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ea8	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0eaa	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ead	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0eaf	74 09		stz $09,x			stz 	9,x
.0eb1	60		rts				rts
.0eb2					_GRCSortSubtract:
.0eb2	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0eb4	d5 00		cmp $00,x			cmp 	0,x
.0eb6	b5 05		lda $05,x			lda 	5,x
.0eb8	f5 01		sbc $01,x			sbc 	1,x
.0eba	b0 08		bcs $0ec4			bcs 	_GRCNoSwap 					; >= swap.
.0ebc	20 d2 0e	jsr $0ed2			jsr 	_GRCSwapByte 				; swap 0/2
.0ebf	e8		inx				inx
.0ec0	20 d2 0e	jsr $0ed2			jsr 	_GRCSwapByte 				; swap 1/3
.0ec3	ca		dex				dex
.0ec4					_GRCNoSwap:
.0ec4	38		sec				sec 								; calculate width/height into 4,5
.0ec5	b5 04		lda $04,x			lda 	4,x
.0ec7	f5 00		sbc $00,x			sbc 	0,x
.0ec9	95 04		sta $04,x			sta 	4,x
.0ecb	b5 05		lda $05,x			lda 	5,x
.0ecd	f5 01		sbc $01,x			sbc 	1,x
.0ecf	95 05		sta $05,x			sta 	5,x
.0ed1	60		rts				rts
.0ed2					_GRCSwapByte:
.0ed2	b5 04		lda $04,x			lda 	4,x
.0ed4	48		pha				pha
.0ed5	b5 00		lda $00,x			lda 	0,x
.0ed7	95 04		sta $04,x			sta 	4,x
.0ed9	68		pla				pla
.0eda	95 00		sta $00,x			sta 	0,x
.0edc	60		rts				rts
.0edd					Unary16Hex:
.0edd	fa		plx				plx
.0ede	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.0ee1	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0ee3	20 1a 17	jsr $171a			jsr 	StringAllocTemp
.0ee6	a5 2d		lda $2d				lda 	zTemp0+1
.0ee8	f0 03		beq $0eed			beq 	_UHNoHigh
.0eea	20 f5 0e	jsr $0ef5			jsr 	_UHWriteHex
.0eed					_UHNoHigh:
.0eed	a5 2c		lda $2c				lda 	zTemp0
.0eef	20 f5 0e	jsr $0ef5			jsr 	_UHWriteHex
.0ef2	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ef5					_UHWriteHex:
.0ef5	48		pha				pha
.0ef6	4a		lsr a				lsr 	a
.0ef7	4a		lsr a				lsr 	a
.0ef8	4a		lsr a				lsr 	a
.0ef9	4a		lsr a				lsr 	a
.0efa	20 fe 0e	jsr $0efe			jsr 	_UHWriteNibl
.0efd	68		pla				pla
.0efe					_UHWriteNibl:
.0efe	29 0f		and #$0f			and 	#15
.0f00	c9 0a		cmp #$0a			cmp 	#10
.0f02	90 02		bcc $0f06			bcc 	_UHDigit
.0f04	69 06		adc #$06			adc 	#6
.0f06					_UHDigit:
.0f06	69 30		adc #$30			adc 	#48
.0f08	20 43 17	jsr $1743			jsr 	StringWriteChar
.0f0b	60		rts				rts
.0f0c					IndFloatRead:
.0f0c	fa		plx				plx
.0f0d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f0f	85 2c		sta $2c				sta 	zTemp0
.0f11	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f13	18		clc				clc
.0f14	6d 07 04	adc $0407			adc 	variableStartPage
.0f17	85 2d		sta $2d				sta 	zTemp0+1
.0f19	ca		dex				dex 								; throw the address
.0f1a	20 f9 14	jsr $14f9			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0f1d	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f20					IndInt16Read:
.0f20	fa		plx				plx
.0f21	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f23	85 2c		sta $2c				sta 	zTemp0
.0f25	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f27	18		clc				clc
.0f28	6d 07 04	adc $0407			adc 	variableStartPage
.0f2b	85 2d		sta $2d				sta 	zTemp0+1
.0f2d	ca		dex				dex 								; throw the address
.0f2e	20 35 15	jsr $1535			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f31	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f34					IndStringRead:
.0f34	fa		plx				plx
.0f35	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f37	85 2c		sta $2c				sta 	zTemp0
.0f39	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f3b	18		clc				clc
.0f3c	6d 07 04	adc $0407			adc 	variableStartPage
.0f3f	85 2d		sta $2d				sta 	zTemp0+1
.0f41	ca		dex				dex 								; throw the address
.0f42	20 7a 15	jsr $157a			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f45	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f48					IndFloatWrite:
.0f48	fa		plx				plx
.0f49	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f4b	85 2c		sta $2c				sta 	zTemp0
.0f4d	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f4f	18		clc				clc
.0f50	6d 07 04	adc $0407			adc 	variableStartPage
.0f53	85 2d		sta $2d				sta 	zTemp0+1
.0f55	20 d6 1a	jsr $1ad6			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f58	ca		dex				dex 								; throw the address as well.
.0f59	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f5c					IndInt16Write:
.0f5c	fa		plx				plx
.0f5d	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f5f	85 2c		sta $2c				sta 	zTemp0
.0f61	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f63	18		clc				clc
.0f64	6d 07 04	adc $0407			adc 	variableStartPage
.0f67	85 2d		sta $2d				sta 	zTemp0+1
.0f69	20 12 1b	jsr $1b12			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f6c	ca		dex				dex 								; throw the address as well.
.0f6d	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f70					IndStringWrite:
.0f70	fa		plx				plx
.0f71	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f73	85 2c		sta $2c				sta 	zTemp0
.0f75	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f77	18		clc				clc
.0f78	6d 07 04	adc $0407			adc 	variableStartPage
.0f7b	85 2d		sta $2d				sta 	zTemp0+1
.0f7d	20 51 1b	jsr $1b51			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f80	ca		dex				dex 								; throw the address as well.
.0f81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f84					CommandXInput:
.0f84	fa		plx				plx
.0f85	5a		phy				phy 								; save Y
.0f86	e8		inx				inx									; space on stack
.0f87					_INError:
.0f87	20 bb 0f	jsr $0fbb			jsr 	InputStringToBuffer 		; input from keyboard
.0f8a	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.0f8c	85 2c		sta $2c				sta 	0+zTemp0
.0f8e	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f90	85 2d		sta $2d				sta 	1+zTemp0
.0f92	20 61 19	jsr $1961			jsr 	ValEvaluateZTemp0
.0f95	b0 f0		bcs $0f87			bcs 	_INError 					; failed, try again.
.0f97	7a		ply				ply 								; restore Y
.0f98	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f9b					CommandInputString:
.0f9b	fa		plx				plx
.0f9c	5a		phy				phy 								; save Y
.0f9d	20 bb 0f	jsr $0fbb			jsr 	InputStringToBuffer 		; input from keyboard
.0fa0	e8		inx				inx 								; make space on stack
.0fa1	20 73 26	jsr $2673			jsr 	FloatSetZero 				; store as string on stack
.0fa4	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.0fa6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0fa8	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0faa	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0fac	a9 40		lda #$40			lda 	#NSSString
.0fae	95 32		sta $32,x			sta 	NSStatus,x
.0fb0	7a		ply				ply 								; restore Y
.0fb1	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fb4					CommandInputReset:
.0fb4	fa		plx				plx
.0fb5	9c 0c 04	stz $040c			stz 	InputBuffer
.0fb8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fbb					InputStringToBuffer:
.0fbb	a9 f5		lda #$f5			lda 	#((InputBumpNext) & $FF)
.0fbd	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.0fc0	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0fc2	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.0fc5	a9 d2		lda #$d2			lda 	#((InputLookNext) & $FF)
.0fc7	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.0fca	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0fcc	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.0fcf	4c 56 14	jmp $1456			jmp 	GetStringToBuffer
.0fd2					InputLookNext:
.0fd2	da		phx				phx
.0fd3					_ILNRetry:
.0fd3	ad 0c 04	lda $040c			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fd6	d0 08		bne $0fe0			bne 	_ILNNotEmpty
.0fd8	20 f9 0f	jsr $0ff9			jsr 	InputGetNewLine 			; get a new line
.0fdb	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset read position.
.0fde	80 f3		bra $0fd3			bra 	_ILNRetry
.0fe0					_ILNNotEmpty:
.0fe0	ae 5d 04	ldx $045d			ldx 	InputBufferPos 				; get head available character
.0fe3	bd 0c 04	lda $040c,x			lda 	InputBuffer,x
.0fe6	d0 08		bne $0ff0			bne 	_ILNExit 					; if not EOS return it with CC.
.0fe8					_ILNNextLine:
.0fe8	9c 0c 04	stz $040c			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0feb	38		sec				sec 								; return CS,Zero
.0fec	fa		plx				plx
.0fed	a9 0d		lda #$0d			lda 	#13
.0fef	60		rts				rts
.0ff0					_ILNExit:
.0ff0	fa		plx				plx
.0ff1	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0ff3	18		clc				clc
.0ff4	60		rts				rts
.0ff5					InputBumpNext:
.0ff5	ee 5d 04	inc $045d			inc 	InputBufferPos
.0ff8	60		rts				rts
.0ff9					InputGetNewLine:
.0ff9	48		pha				pha
.0ffa	da		phx				phx
.0ffb	5a		phy				phy
.0ffc	a9 3f		lda #$3f			lda 	#"?"
.0ffe	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.1001	a0 00		ldy #$00			ldy 	#0 							; line position.
.1003					_IGNLLoop:
.1003	20 80 13	jsr $1380			jsr 	VectorGetCharacter 			; get a character
.1006	c9 00		cmp #$00			cmp 	#0
.1008	f0 f9		beq $1003			beq 	_IGNLLoop
.100a	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.100c	f0 11		beq $101f			beq 	_IGNBackspace
.100e	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.1010	f0 17		beq $1029			beq 	_IGNExit
.1012	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.1014	f0 ed		beq $1003			beq 	_IGNLLoop
.1016	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1019	c8		iny				iny
.101a	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.101d	80 e4		bra $1003			bra 	_IGNLLoop
.101f					_IGNBackspace:
.101f	c0 00		cpy #$00			cpy 	#0
.1021	f0 e0		beq $1003			beq 	_IGNLLoop
.1023	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.1026	88		dey				dey
.1027	80 da		bra $1003			bra 	_IGNLLoop
.1029					_IGNExit:
.1029	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.102c	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.102e	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1031	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset position to start of input buffer.
.1034	7a		ply				ply
.1035	fa		plx				plx
.1036	68		pla				pla
.1037	60		rts				rts
.1038					IGNLEchoIfScreen:
.1038	ae 5f 04	ldx $045f			ldx 	currentChannel
.103b	d0 03		bne $1040			bne 	_IGNLEExit
.103d	20 77 13	jsr $1377			jsr 	VectorPrintCharacter
.1040					_IGNLEExit:
.1040	60		rts				rts
.040c					InputBuffer:
>040c							.fill 	81
.045d					InputBufferPos:
>045d							.fill 	1
.1041					GetInteger8Bit:
.1041	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.1044	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1046	60		rts				rts
.1047					GetInteger16Bit:
.1047	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.104a	34 32		bit $32,x			bit 	NSStatus,x
.104c	30 09		bmi $1057			bmi 	Negate16Bit
.104e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1050	85 2c		sta $2c				sta 	zTemp0
.1052	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1054	85 2d		sta $2d				sta 	zTemp0+1
.1056	60		rts				rts
.1057					Negate16Bit:
.1057	38		sec				sec
.1058	a9 00		lda #$00			lda 	#0
.105a	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.105c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.105e	85 2c		sta $2c				sta 	zTemp0
.1060	a9 00		lda #$00			lda 	#0
.1062	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1064	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1066	85 2d		sta $2d				sta 	zTemp0+1
.1068	60		rts				rts
.1069					UnaryJoy:
.1069	fa		plx				plx
.106a	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; port #
.106d	48		pha				pha 								; zero the result.
.106e	20 73 26	jsr $2673			jsr 	FloatSetZero
.1071	68		pla				pla
.1072	5a		phy				phy
.1073	da		phx				phx
.1074	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1077	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1079	d0 10		bne $108b			bne 	_UJNoHardware
.107b	a8		tay				tay 								; move XA -> AY
.107c	8a		txa				txa
.107d	fa		plx				plx 								; we can update it now.
.107e	49 ff		eor #$ff			eor 	#$FF
.1080	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1082	98		tya				tya
.1083	49 ff		eor #$ff			eor 	#$FF
.1085	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1087	7a		ply				ply 								; restore Y
.1088	4c 4f 08	jmp $084f			jmp 	NextCommand
.108b					_UJNoHardware:
.108b	fa		plx				plx
.108c	7a		ply				ply
.108d	a9 01		lda #$01			lda 	#1 							; set result to -1
.108f	20 75 26	jsr $2675			jsr 	FloatSetByte
.1092	20 35 26	jsr $2635			jsr 	FloatNegate
.1095	4c 4f 08	jmp $084f			jmp 	NextCommand
.1098					UnaryLen:
.1098	fa		plx				plx
.1099	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.109b	85 2c		sta $2c				sta 	zTemp0
.109d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.109f	85 2d		sta $2d				sta 	zTemp0+1
.10a1	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.10a3	20 75 26	jsr $2675			jsr 	FloatSetByte
.10a6	4c 4f 08	jmp $084f			jmp 	NextCommand
.10a9					LinkFloatAdd:
.10a9	fa		plx				plx
.10aa	5a		phy			phy
.10ab	20 97 20	jsr $2097		jsr	FloatAdd
.10ae	7a		ply			ply
.10af	4c 4f 08	jmp $084f			jmp 	NextCommand
.10b2					LinkFloatSubtract:
.10b2	fa		plx				plx
.10b3	5a		phy			phy
.10b4	20 91 20	jsr $2091		jsr	FloatSubtract
.10b7	7a		ply			ply
.10b8	4c 4f 08	jmp $084f			jmp 	NextCommand
.10bb					LinkFloatMultiply:
.10bb	fa		plx				plx
.10bc	5a		phy			phy
.10bd	20 33 23	jsr $2333		jsr	FloatMultiply
.10c0	7a		ply			ply
.10c1	4c 4f 08	jmp $084f			jmp 	NextCommand
.10c4					LinkFloatDivide:
.10c4	fa		plx				plx
.10c5	5a		phy			phy
.10c6	20 bc 21	jsr $21bc		jsr	FloatDivide
.10c9	b0 5c		bcs $1127		bcs	DivZeroError
.10cb	7a		ply			ply
.10cc	4c 4f 08	jmp $084f			jmp 	NextCommand
.10cf					LinkFloatPower:
.10cf	fa		plx				plx
.10d0	5a		phy			phy
.10d1	20 3c 29	jsr $293c		jsr	FloatPower
.10d4	b0 4e		bcs $1124		bcs	MapRangeError
.10d6	7a		ply			ply
.10d7	4c 4f 08	jmp $084f			jmp 	NextCommand
.10da					LinkCompareGreater:
.10da	fa		plx				plx
.10db	5a		phy			phy
.10dc	20 40 21	jsr $2140		jsr	CompareGreater
.10df	7a		ply			ply
.10e0	4c 4f 08	jmp $084f			jmp 	NextCommand
.10e3					LinkCompareEqual:
.10e3	fa		plx				plx
.10e4	5a		phy			phy
.10e5	20 22 21	jsr $2122		jsr	CompareEqual
.10e8	7a		ply			ply
.10e9	4c 4f 08	jmp $084f			jmp 	NextCommand
.10ec					LinkCompareLess:
.10ec	fa		plx				plx
.10ed	5a		phy			phy
.10ee	20 38 21	jsr $2138		jsr	CompareLess
.10f1	7a		ply			ply
.10f2	4c 4f 08	jmp $084f			jmp 	NextCommand
.10f5					LinkCompareGreaterEqual:
.10f5	fa		plx				plx
.10f6	5a		phy			phy
.10f7	20 50 21	jsr $2150		jsr	CompareGreaterEqual
.10fa	7a		ply			ply
.10fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.10fe					LinkCompareNotEqual:
.10fe	fa		plx				plx
.10ff	5a		phy			phy
.1100	20 32 21	jsr $2132		jsr	CompareNotEqual
.1103	7a		ply			ply
.1104	4c 4f 08	jmp $084f			jmp 	NextCommand
.1107					LinkCompareLessEqual:
.1107	fa		plx				plx
.1108	5a		phy			phy
.1109	20 48 21	jsr $2148		jsr	CompareLessEqual
.110c	7a		ply			ply
.110d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1110					LinkFloatIntegerPartDown:
.1110	fa		plx				plx
.1111	5a		phy			phy
.1112	20 d2 22	jsr $22d2		jsr	FloatIntegerPartDown
.1115	7a		ply			ply
.1116	4c 4f 08	jmp $084f			jmp 	NextCommand
.1119					LinkFloatSquareRoot:
.1119	fa		plx				plx
.111a	5a		phy			phy
.111b	20 be 29	jsr $29be		jsr	FloatSquareRoot
.111e	b0 04		bcs $1124		bcs	MapRangeError
.1120	7a		ply			ply
.1121	4c 4f 08	jmp $084f			jmp 	NextCommand
.1124					MapRangeError:
.1124	4c ff 1e	jmp $1eff		jmp	ErrorV_range
.1127					DivZeroError:
.1127	4c 88 1f	jmp $1f88		jmp	ErrorV_divzero
.112a					LinkFloatLogarithm:
.112a	fa		plx				plx
.112b	5a		phy			phy
.112c	20 c8 28	jsr $28c8		jsr	FloatLogarithm
.112f	b0 f3		bcs $1124		bcs	MapRangeError
.1131	7a		ply			ply
.1132	4c 4f 08	jmp $084f			jmp 	NextCommand
.1135					LinkFloatExponent:
.1135	fa		plx				plx
.1136	5a		phy			phy
.1137	20 c5 27	jsr $27c5		jsr	FloatExponent
.113a	7a		ply			ply
.113b	4c 4f 08	jmp $084f			jmp 	NextCommand
.113e					LinkFloatCosine:
.113e	fa		plx				plx
.113f	5a		phy			phy
.1140	20 b9 27	jsr $27b9		jsr	FloatCosine
.1143	7a		ply			ply
.1144	4c 4f 08	jmp $084f			jmp 	NextCommand
.1147					LinkFloatSine:
.1147	fa		plx				plx
.1148	5a		phy			phy
.1149	20 59 29	jsr $2959		jsr	FloatSine
.114c	7a		ply			ply
.114d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1150					LinkFloatTangent:
.1150	fa		plx				plx
.1151	5a		phy			phy
.1152	20 ca 29	jsr $29ca		jsr	FloatTangent
.1155	7a		ply			ply
.1156	4c 4f 08	jmp $084f			jmp 	NextCommand
.1159					LinkFloatArcTan:
.1159	fa		plx				plx
.115a	5a		phy			phy
.115b	20 9e 26	jsr $269e		jsr	FloatArcTan
.115e	b0 c4		bcs $1124		bcs	MapRangeError
.1160	7a		ply			ply
.1161	4c 4f 08	jmp $084f			jmp 	NextCommand
.1164					LinkFloatCompare:
.1164	fa		plx				plx
.1165	5a		phy			phy
.1166	20 58 21	jsr $2158		jsr	FloatCompare
.1169	7a		ply			ply
.116a	4c 4f 08	jmp $084f			jmp 	NextCommand
.116d					LinkDivideInt32:
.116d	fa		plx				plx
.116e	5a		phy			phy
.116f	20 e6 21	jsr $21e6		jsr	DivideInt32
.1172	b0 b0		bcs $1124		bcs	MapRangeError
.1174	7a		ply			ply
.1175	4c 4f 08	jmp $084f			jmp 	NextCommand
.1178					StackSaveCurrentPosition:
.1178	20 cb 08	jsr $08cb			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.117b	5a		phy				phy
.117c	a0 02		ldy #$02			ldy 	#2
.117e	a5 28		lda $28				lda 	codePtr
.1180	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1182	c8		iny				iny
.1183	a5 29		lda $29				lda 	codePtr+1
.1185	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1187	7a		ply				ply
.1188	60		rts				rts
.1189					StackLoadCurrentPosition:
.1189	a0 02		ldy #$02			ldy 	#2
.118b	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.118d	85 28		sta $28				sta 	codePtr
.118f	c8		iny				iny
.1190	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1192	85 29		sta $29				sta 	codePtr+1
.1194	a0 00		ldy #$00			ldy 	#0
.1196	60		rts				rts
.1197					XCommandMouse:
.1197	fa		plx				plx
.1198	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; mouse control.
.119b	ca		dex				dex
.119c	da		phx				phx
.119d	5a		phy				phy
.119e	48		pha				pha
.119f	38		sec				sec 								; get screen resolution
.11a0	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.11a3	68		pla				pla
.11a4	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.11a7	7a		ply				ply
.11a8	fa		plx				plx
.11a9	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ac					XUnaryMB:
.11ac	fa		plx				plx
.11ad	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11b0	a5 30		lda $30				lda 	zTemp2
.11b2	e8		inx				inx
.11b3	20 75 26	jsr $2675			jsr 	FloatSetByte
.11b6	4c 4f 08	jmp $084f			jmp 	NextCommand
.11b9					XUnaryMX:
.11b9	fa		plx				plx
.11ba	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11bd	a5 2c		lda $2c				lda 	zTemp0
.11bf	e8		inx				inx
.11c0	20 75 26	jsr $2675			jsr 	FloatSetByte
.11c3	a5 2d		lda $2d				lda 	zTemp0+1
.11c5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11c7	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ca					XUnaryMY:
.11ca	fa		plx				plx
.11cb	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11ce	a5 2e		lda $2e				lda 	zTemp1
.11d0	e8		inx				inx
.11d1	20 75 26	jsr $2675			jsr 	FloatSetByte
.11d4	a5 2f		lda $2f				lda 	zTemp1+1
.11d6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11d8	4c 4f 08	jmp $084f			jmp 	NextCommand
.11db					XUnaryMouseCommon:
.11db	da		phx				phx
.11dc	5a		phy				phy
.11dd	a2 2c		ldx #$2c			ldx 	#zTemp0
.11df	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.11e2	85 30		sta $30				sta 	zTemp2
.11e4	7a		ply				ply
.11e5	fa		plx				plx
.11e6	60		rts				rts
.11e7					NegateTOS:
.11e7	fa		plx				plx
.11e8	20 35 26	jsr $2635			jsr 	FloatNegate
.11eb	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ee					CommandNewLine:
.11ee	fa		plx				plx
.11ef	9c 6a 05	stz $056a			stz 	stringInitialised
.11f2	a2 ff		ldx #$ff			ldx 	#$FF
.11f4	4c 4f 08	jmp $084f			jmp 	NextCommand
.11f7					CommandXNext:
.11f7	fa		plx				plx
.11f8					_CNRetry:
.11f8	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.11fa	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.11fd	20 cb 08	jsr $08cb			jsr 	FixUpY 						; so we can use Y
.1200	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.1202	35 4a		and $4a,x			and 	NSMantissa1,x
.1204	c9 ff		cmp #$ff			cmp 	#$FF
.1206	f0 16		beq $121e			beq 	_CNNoIndexVariable
.1208	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.120a	a0 05		ldy #$05			ldy 	#5
.120c	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.120e	d0 07		bne $1217			bne 	_CNNIndexFail
.1210	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1212	c8		iny				iny
.1213	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.1215	f0 07		beq $121e			beq 	_CNNoIndexVariable
.1217					_CNNIndexFail:
.1217	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.1219	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close this frame
.121c	80 da		bra $11f8			bra 	_CNRetry
.121e					_CNNoIndexVariable:
.121e	ca		dex				dex
.121f	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.1221	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1223	29 40		and #$40			and 	#$40	 					; bit 6
.1225	d0 55		bne $127c			bne 	_CNOptimisedNext
.1227	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1229	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.122b	48		pha				pha
.122c	85 2c		sta $2c				sta 	zTemp0
.122e	c8		iny				iny
.122f	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1231	18		clc				clc
.1232	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1235	48		pha				pha
.1236	85 2d		sta $2d				sta 	zTemp0+1
.1238	20 f9 14	jsr $14f9			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.123b	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.123d	e8		inx				inx
.123e	20 bf 12	jsr $12bf			jsr 	CopyOffsetYToTOS
.1241	20 97 20	jsr $2097			jsr 	FloatAdd
.1244	68		pla				pla 								; restore address
.1245	85 2d		sta $2d				sta 	zTemp0+1
.1247	68		pla				pla
.1248	85 2c		sta $2c				sta 	zTemp0
.124a	20 d6 1a	jsr $1ad6			jsr 	WriteFloatZTemp0Sub			; write float.
.124d	e8		inx				inx  								; recover written
.124e	e8		inx				inx 								; load offset
.124f	a0 0d		ldy #$0d			ldy 	#13
.1251	20 bf 12	jsr $12bf			jsr 	CopyOffsetYToTOS
.1254	20 58 21	jsr $2158			jsr 	FloatCompare 				; and compare the floats.
.1257	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1258	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.125a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.125c	30 08		bmi $1266			bmi 	_CNDownStep
.125e	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1260	c9 01		cmp #$01			cmp 	#1 							; gone higher
.1262	f0 10		beq $1274			beq 	_CNExitFor 					; if so exit the loop
.1264	80 06		bra $126c			bra 	_CNLoopBack
.1266					_CNDownStep:
.1266	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1268	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.126a	f0 08		beq $1274			beq 	_CNExitFor
.126c					_CNLoopBack:
.126c	20 89 11	jsr $1189			jsr 	StackLoadCurrentPosition 	; loop back
.126f	a0 00		ldy #$00			ldy 	#0
.1271	4c 4f 08	jmp $084f			jmp 	NextCommand
.1274					_CNExitFor:
.1274	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; remove the frame and exit
.1277	a0 00		ldy #$00			ldy 	#0
.1279	4c 4f 08	jmp $084f			jmp 	NextCommand
.127c					_CNOptimisedNext:
.127c	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.127e	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1280	85 2c		sta $2c				sta 	zTemp0
.1282	c8		iny				iny
.1283	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1285	18		clc				clc
.1286	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1289	85 2d		sta $2d				sta 	zTemp0+1
.128b	a0 07		ldy #$07			ldy 	#7 							; STEP value
.128d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.128f	a0 ff		ldy #$ff			ldy 	#$FF
.1291	18		clc				clc
.1292					_CNOIncrement:
.1292	c8		iny				iny
.1293	71 2c		adc ($2c),y			adc 	(zTemp0),y
.1295	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1297	f0 f9		beq $1292			beq 	_CNOIncrement
.1299	18		clc				clc
.129a	a5 24		lda $24				lda 	runtimeStackPtr
.129c	69 0d		adc #$0d			adc 	#13
.129e	85 2e		sta $2e				sta 	zTemp1
.12a0	a5 25		lda $25				lda 	runtimeStackPtr+1
.12a2	69 00		adc #$00			adc 	#0
.12a4	85 2f		sta $2f				sta 	zTemp1+1
.12a6	a0 00		ldy #$00			ldy 	#0
.12a8	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.12aa	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.12ac	c8		iny				iny
.12ad	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.12af	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12b1	c8		iny				iny
.12b2	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.12b4	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12b6	c8		iny				iny
.12b7	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.12b9	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12bb	90 b7		bcc $1274			bcc	 	_CNExitFor
.12bd	80 ad		bra $126c			bra 	_CNLoopBack
.12bf					CopyOffsetYToTOS:
.12bf	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.12c3	c8		iny				iny
.12c4	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12c8	c8		iny				iny
.12c9	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12cb	95 56		sta $56,x			sta 	NSMantissa2,x
.12cd	c8		iny				iny
.12ce	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d0	95 62		sta $62,x			sta 	NSMantissa3,x
.12d2	c8		iny				iny
.12d3	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d5	95 6e		sta $6e,x			sta 	NSExponent,x
.12d7	c8		iny				iny
.12d8	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12da	95 32		sta $32,x			sta 	NSStatus,x
.12dc	60		rts				rts
.12dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.12e0					NotTOS:
.12e0	fa		plx				plx
.12e1	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.12e4	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.12e6	74 62		stz $62,x			stz 	NSMantissa3,x
.12e8	20 35 26	jsr $2635			jsr 	FloatNegate		 			; negate
.12eb	e8		inx				inx 								; and subtract 1.
.12ec	a9 01		lda #$01			lda 	#1
.12ee	20 75 26	jsr $2675			jsr 	FloatSetByte
.12f1	20 91 20	jsr $2091			jsr 	FloatSubtract
.12f4					_NotTOSSkip:
.12f4	4c 4f 08	jmp $084f			jmp 	NextCommand
.12f7					CommandXOn:
.12f7	fa		plx				plx
.12f8	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.12fb	8d 5e 04	sta $045e			sta 	onCount 					; save it.
.12fe	20 cb 08	jsr $08cb			jsr 	FixUpY 						; Y = 0
.1301					_CONFind:
.1301	ce 5e 04	dec $045e			dec 	onCount 					; reached zero, do this one
.1304	f0 0b		beq $1311			beq 	_CONFound
.1306	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1307	c8		iny				iny
.1308	c8		iny				iny
.1309	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.130b	c8		iny				iny
.130c	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.130e	f0 f1		beq $1301			beq 	_CONFind
.1310	88		dey				dey 								; point to character after last GOTO/GOSUB
.1311					_CONFound:
.1311	4c 4f 08	jmp $084f			jmp 	NextCommand
.1314					CommandMoreOn:
.1314	fa		plx				plx
.1315	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1316	c8		iny				iny
.1317	c8		iny				iny
.1318	4c 4f 08	jmp $084f			jmp 	NextCommand
.045e					onCount:
>045e							.fill 	1
.131b					UnaryPeek:
.131b	fa		plx				plx
.131c	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.131f	da		phx				phx
.1320	5a		phy				phy
.1321	a6 2c		ldx $2c				ldx 	zTemp0
.1323	a4 2d		ldy $2d				ldy 	zTemp0+1
.1325	20 70 1c	jsr $1c70			jsr 	XPeekMemory
.1328	7a		ply				ply
.1329	fa		plx				plx
.132a	20 75 26	jsr $2675			jsr 	FloatSetByte
.132d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1330					UnaryPI:
.1330	fa		plx				plx
.1331	a9 2a		lda #$2a			lda 	#42
.1333	20 75 26	jsr $2675			jsr 	FloatSetByte
.1336	4c 4f 08	jmp $084f			jmp 	NextCommand
.1339					CommandPOKE:
.1339	fa		plx				plx
.133a	da		phx				phx 								; save XY
.133b	5a		phy				phy
.133c	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.133f	48		pha				pha
.1340	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1342	a8		tay				tay
.1343	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1345	aa		tax				tax
.1346	68		pla				pla
.1347	20 5c 1c	jsr $1c5c			jsr 	XPokeMemory
.134a	7a		ply				ply 								; restore YX and drop 2
.134b	fa		plx				plx
.134c	ca		dex				dex
.134d	ca		dex				dex
.134e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1351					UnaryPos:
.1351	fa		plx				plx
.1352	20 ef 1b	jsr $1bef			jsr 	XGetHPos
.1355	20 75 26	jsr $2675			jsr 	FloatSetByte
.1358	4c 4f 08	jmp $084f			jmp 	NextCommand
.135b					GetChannel:
.135b	fa		plx				plx
.135c	ad 5f 04	lda $045f			lda 	currentChannel
.135f	e8		inx				inx
.1360	20 75 26	jsr $2675			jsr 	FloatSetByte
.1363	4c 4f 08	jmp $084f			jmp 	NextCommand
.1366					SetChannel:
.1366	fa		plx				plx
.1367	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.136a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.136c	8d 5f 04	sta $045f			sta 	currentChannel
.136f	ca		dex				dex
.1370	4c 4f 08	jmp $084f			jmp 	NextCommand
.1373					SetDefaultChannel:
.1373	9c 5f 04	stz $045f			stz 	currentChannel
.1376	60		rts				rts
.1377					VectorPrintCharacter:
.1377	da		phx				phx
.1378	ae 5f 04	ldx $045f			ldx 	currentChannel
.137b	20 9a 1c	jsr $1c9a			jsr 	XPrintCharacterToChannel
.137e	fa		plx				plx
.137f	60		rts				rts
.1380					VectorGetCharacter:
.1380	da		phx				phx
.1381	ae 5f 04	ldx $045f			ldx 	currentChannel
.1384	20 d3 1b	jsr $1bd3			jsr 	XGetCharacterFromChannel
.1387	fa		plx				plx
.1388	60		rts				rts
.045f					currentChannel:
>045f							.fill 	1
.1389					PrintNumber:
.1389	fa		plx				plx
.138a	a9 07		lda #$07			lda 	#7
.138c	20 5b 25	jsr $255b			jsr 	FloatToString 				; to number in decimal buffer
.138f	ca		dex				dex 								; drop
.1390	da		phx				phx
.1391	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1393					_PNLoop:
.1393	bd 98 05	lda $0598,x			lda 	decimalBuffer,x
.1396	20 77 13	jsr $1377			jsr 	VectorPrintCharacter
.1399	e8		inx				inx
.139a	bd 98 05	lda $0598,x			lda	 	decimalBuffer,x
.139d	d0 f4		bne $1393			bne 	_PNLoop
.139f	a9 20		lda #$20			lda 	#32 						; trailing space
.13a1	20 77 13	jsr $1377			jsr 	VectorPrintCharacter
.13a4	fa		plx				plx
.13a5	4c 4f 08	jmp $084f			jmp 	NextCommand
.13a8					PrintString:
.13a8	fa		plx				plx
.13a9	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.13ab	85 2c		sta $2c				sta 	zTemp0
.13ad	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.13af	85 2d		sta $2d				sta 	zTemp0+1
.13b1	ca		dex				dex 								; drop
.13b2	da		phx				phx
.13b3	5a		phy				phy
.13b4	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.13b6	aa		tax				tax
.13b7	a0 01		ldy #$01			ldy 	#1 							; Y = position
.13b9					_PSLoop:
.13b9	e0 00		cpx #$00			cpx 	#0 							; complete ?
.13bb	f0 09		beq $13c6			beq 	_PSExit
.13bd	ca		dex				dex 								; dec count
.13be	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.13c0	20 77 13	jsr $1377			jsr 	VectorPrintCharacter
.13c3	c8		iny				iny
.13c4	80 f3		bra $13b9			bra 	_PSLoop
.13c6					_PSExit:
.13c6	7a		ply				ply
.13c7	fa		plx				plx
.13c8	4c 4f 08	jmp $084f			jmp 	NextCommand
.13cb					CommandPushN:
.13cb	fa		plx				plx
.13cc	e8		inx				inx 								; next slot on stack
.13cd	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.13cf	95 6e		sta $6e,x			sta 	NSExponent,x
.13d1	c8		iny				iny
.13d2	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.13d4	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13d6	c8		iny				iny
.13d7	b1 28		lda ($28),y			lda 	(codePtr),y
.13d9	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13db	c8		iny				iny
.13dc	b1 28		lda ($28),y			lda 	(codePtr),y
.13de	95 56		sta $56,x			sta 	NSMantissa2,x
.13e0	c8		iny				iny
.13e1	b1 28		lda ($28),y			lda 	(codePtr),y
.13e3	48		pha				pha
.13e4	29 7f		and #$7f			and 	#$7F
.13e6	95 62		sta $62,x			sta 	NSMantissa3,x
.13e8	68		pla				pla 								; sign in mantissa3:7
.13e9	29 80		and #$80			and 	#$80
.13eb	95 32		sta $32,x			sta 	NSStatus,x
.13ed	c8		iny				iny
.13ee	4c 4f 08	jmp $084f			jmp 	NextCommand
.13f1					CommandPushS:
.13f1	fa		plx				plx
.13f2	e8		inx				inx 								; next slot on stack
.13f3	18		clc				clc
.13f4	98		tya				tya
.13f5	65 28		adc $28				adc 	codePtr 					; the string is inline
.13f7	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13f9	a5 29		lda $29				lda 	codePtr+1
.13fb	69 00		adc #$00			adc 	#0
.13fd	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13ff	74 56		stz $56,x			stz 	NSMantissa2,x
.1401	74 62		stz $62,x			stz 	NSMantissa3,x
.1403	a9 40		lda #$40			lda 	#NSSString
.1405	95 32		sta $32,x			sta 	NSStatus,x
.1407	98		tya				tya 								; string length +1 added to Y
.1408	38		sec				sec
.1409	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.140b	a8		tay				tay
.140c	4c 4f 08	jmp $084f			jmp 	NextCommand
.140f					CommandXRead:
.140f	fa		plx				plx
.1410	5a		phy				phy 								; save Y
.1411	20 42 14	jsr $1442			jsr 	ReadStringToBuffer 			; read element into buffer
.1414	e8		inx				inx									; space on stack
.1415	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.1417	85 2c		sta $2c				sta 	0+zTemp0
.1419	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.141b	85 2d		sta $2d				sta 	1+zTemp0
.141d	20 61 19	jsr $1961			jsr 	ValEvaluateZTemp0
.1420	b0 04		bcs $1426			bcs 	_CRError 					; failed
.1422	7a		ply				ply 								; restore Y
.1423	4c 4f 08	jmp $084f			jmp 	NextCommand
.1426					_CRError:
.1426	4c 0f 1f	jmp $1f0f		jmp	ErrorV_value
.1429					CommandReadString:
.1429	fa		plx				plx
.142a	5a		phy				phy 								; save Y
.142b	20 42 14	jsr $1442			jsr 	ReadStringToBuffer 			; read text
.142e	e8		inx				inx 								; make space on stack
.142f	20 73 26	jsr $2673			jsr 	FloatSetZero 				; store as string on stack
.1432	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.1434	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1436	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.1438	95 4a		sta $4a,x			sta 	NSMantissa1,x
.143a	a9 40		lda #$40			lda 	#NSSString
.143c	95 32		sta $32,x			sta 	NSStatus,x
.143e	7a		ply				ply 								; restore Y
.143f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1442					ReadStringToBuffer:
.1442	a9 d5		lda #$d5			lda 	#((ReadBumpNext) & $FF)
.1444	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.1447	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.1449	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.144c	a9 a8		lda #$a8			lda 	#((ReadLookNext) & $FF)
.144e	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.1451	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.1453	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.1456					GetStringToBuffer:
.1456	20 a5 14	jsr $14a5			jsr		GetLookNext 				; skip all leading spaces.
.1459	f0 44		beq $149f			beq 	_RBError 					; end of data
.145b	b0 f9		bcs $1456			bcs 	GetStringToBuffer 			; switched to new data line.
.145d	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.145f	b0 05		bcs $1466			bcs 	_RBNoSpace
.1461	20 a2 14	jsr $14a2			jsr 	GetBumpNext 				; consume space and loop round.
.1464	80 f0		bra $1456			bra 	GetStringToBuffer
.1466					_RBNoSpace:
.1466	9c 61 04	stz $0461			stz 	ReadBufferSize 				; empty the buffer.
.1469	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.146b	d0 08		bne $1475			bne 	_RBCommaSep
.146d	8d 60 04	sta $0460			sta 	ReadSep 					; use as a seperator
.1470	20 a2 14	jsr $14a2			jsr 	GetBumpNext 				; consume the '"'
.1473	80 05		bra $147a			bra 	_RBGetText
.1475					_RBCommaSep:
.1475	a9 2c		lda #$2c			lda 	#","						; get till comma
.1477	8d 60 04	sta $0460			sta 	ReadSep
.147a					_RBGetText:
.147a	20 a5 14	jsr $14a5			jsr 	GetLookNext 				; what follows
.147d	b0 18		bcs $1497			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.147f	20 a2 14	jsr $14a2			jsr 	GetBumpNext 				; consume it whatever
.1482	cd 60 04	cmp $0460			cmp 	ReadSep 					; if found the seperator.
.1485	f0 10		beq $1497			beq 	_RBEndGet 					; exit after consumption
.1487	da		phx				phx
.1488	ae 61 04	ldx $0461			ldx 	ReadBufferSize 				; copy into buffer.
.148b	ee 61 04	inc $0461			inc 	ReadBufferSize
.148e	9d 62 04	sta $0462,x			sta 	ReadBuffer,x
.1491	9e 63 04	stz $0463,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.1494	fa		plx				plx
.1495	80 e3		bra $147a			bra 	_RBGetText
.1497					_RBEndGet:
.1497	c9 22		cmp #$22			cmp 	#'"'
.1499	d0 03		bne $149e			bne 	_RBNotQuote
.149b	20 a2 14	jsr $14a2			jsr 	GetBumpNext
.149e					_RBNotQuote:
.149e	60		rts				rts
.149f					_RBError:
.149f	4c c4 1f	jmp $1fc4		jmp	ErrorV_data
.14a2					GetBumpNext:
.14a2	6c 61 05	jmp ($0561)			jmp 	(ReadBumpNextVec)
.14a5					GetLookNext:
.14a5	6c 63 05	jmp ($0563)			jmp 	(ReadLookNextVec)
.14a8					ReadLookNext:
.14a8	ad 65 05	lda $0565			lda 	dataRemaining 				; any data remaining
.14ab	f0 04		beq $14b1			beq 	_RLNFindData
.14ad	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.14af	18		clc				clc
.14b0	60		rts				rts
.14b1					_RLNFindData:
.14b1	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.14b3	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.14b5	f0 1a		beq $14d1			beq 	_RLNNoData
.14b7	c9 d0		cmp #$d0			cmp 	#PCD_CMD_DATA 				; Found DATA
.14b9	f0 05		beq $14c0			beq 	_RLNHaveData
.14bb					_RLNNext:
.14bb	20 42 20	jsr $2042			jsr 	MoveObjectForward			; else scan forward.
.14be	80 f1		bra $14b1			bra 	_RLNFindData
.14c0					_RLNHaveData:
.14c0	a0 01		ldy #$01			ldy 	#1 							; get length
.14c2	b1 2a		lda ($2a),y			lda 	(objPtr),y
.14c4	f0 f5		beq $14bb			beq 	_RLNNext 					; skip if DATA alone
.14c6	20 d5 14	jsr $14d5			jsr 	ReadBumpNext 				; advance by two
.14c9	20 d5 14	jsr $14d5			jsr 	ReadBumpNext
.14cc	8d 65 05	sta $0565			sta 	dataRemaining 				; set data left count.
.14cf	38		sec				sec
.14d0	60		rts				rts
.14d1					_RLNNoData:
.14d1	a9 00		lda #$00			lda 	#0
.14d3	38		sec				sec
.14d4	60		rts				rts
.14d5					ReadBumpNext:
.14d5	e6 2a		inc $2a				inc 	objPtr
.14d7	d0 02		bne $14db			bne 	_RBNSkip
.14d9	e6 2b		inc $2b				inc 	objPtr+1
.14db					_RBNSkip:
.14db	ce 65 05	dec $0565			dec 	dataRemaining
.14de	60		rts				rts
.0460					ReadSep:
>0460							.fill 	1
.0461					ReadBufferSize:
>0461							.fill 	1
.0462					ReadBuffer:
>0462							.fill 	255
.0561					ReadBumpNextVec:
>0561							.fill 	2
.0563					ReadLookNextVec:
>0563							.fill 	2
.14df					ReadFloatCommand:
.14df	fa		plx				plx
.14e0	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14e2	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14e4	88		dey				dey 								; get the upper 3 bits
.14e5	b1 28		lda ($28),y			lda 	(codePtr),y
.14e7	29 07		and #$07			and 	#7
.14e9	c8		iny				iny
.14ea	c8		iny				iny
.14eb	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14ed	2a		rol a				rol 	a 							; carry will be clear.
.14ee	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14f1	85 2d		sta $2d				sta 	zTemp0+1
.14f3	20 f9 14	jsr $14f9			jsr 	ReadFloatZTemp0Sub
.14f6	4c 4f 08	jmp $084f			jmp 	NextCommand
.14f9					ReadFloatZTemp0Sub:
.14f9	5a		phy				phy 								; start write
.14fa	a0 01		ldy #$01			ldy 	#1
.14fc	e8		inx				inx
.14fd	b2 2c		lda ($2c)			lda 	(zTemp0)
.14ff	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1501	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1503	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1505	c8		iny				iny
.1506	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1508	95 56		sta $56,x			sta 	NSMantissa2,x
.150a	c8		iny				iny
.150b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.150d	95 62		sta $62,x			sta 	NSMantissa3,x
.150f	c8		iny				iny
.1510	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1512	95 6e		sta $6e,x			sta 	NSExponent,x
.1514	c8		iny				iny
.1515	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1517	95 32		sta $32,x			sta 	NSStatus,x
.1519	7a		ply				ply
.151a	60		rts				rts
.151b					ReadIntegerCommand:
.151b	fa		plx				plx
.151c	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.151e	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1520	88		dey				dey 								; get the upper 3 bits
.1521	b1 28		lda ($28),y			lda 	(codePtr),y
.1523	29 07		and #$07			and 	#7
.1525	c8		iny				iny
.1526	c8		iny				iny
.1527	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1529	2a		rol a				rol 	a 							; carry will be clear.
.152a	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.152d	85 2d		sta $2d				sta 	zTemp0+1
.152f	20 35 15	jsr $1535			jsr 	ReadIntegerZTemp0Sub
.1532	4c 4f 08	jmp $084f			jmp 	NextCommand
.1535					ReadIntegerZTemp0Sub:
.1535	5a		phy				phy 								; start write
.1536	a0 01		ldy #$01			ldy 	#1
.1538	e8		inx				inx 								; prepare
.1539	74 56		stz $56,x			stz 	NSMantissa2,x
.153b	74 62		stz $62,x			stz 	NSMantissa3,x
.153d	74 6e		stz $6e,x			stz 	NSExponent,x
.153f	74 32		stz $32,x			stz 	NSStatus,x
.1541	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1543	30 08		bmi $154d			bmi 	_RIZNegative
.1545	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1547	b2 2c		lda ($2c)			lda 	(zTemp0)
.1549	95 3e		sta $3e,x			sta 	NSMantissa0,x
.154b	7a		ply				ply
.154c	60		rts				rts
.154d					_RIZNegative:
.154d	38		sec				sec 								; -ve read
.154e	a9 00		lda #$00			lda 	#0
.1550	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.1552	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1554	a9 00		lda #$00			lda 	#0
.1556	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1558	95 4a		sta $4a,x			sta 	NSMantissa1,x
.155a	a9 80		lda #$80			lda 	#$80
.155c	95 32		sta $32,x			sta 	NSStatus,x
.155e	7a		ply				ply
.155f	60		rts				rts
.1560					ReadStringCommand:
.1560	fa		plx				plx
.1561	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1563	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1565	88		dey				dey 								; get the upper 3 bits
.1566	b1 28		lda ($28),y			lda 	(codePtr),y
.1568	29 07		and #$07			and 	#7
.156a	c8		iny				iny
.156b	c8		iny				iny
.156c	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.156e	2a		rol a				rol 	a 							; carry will be clear.
.156f	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1572	85 2d		sta $2d				sta 	zTemp0+1
.1574	20 7a 15	jsr $157a			jsr 	ReadStringZTemp0Sub
.1577	4c 4f 08	jmp $084f			jmp 	NextCommand
.157a					ReadStringZTemp0Sub:
.157a	5a		phy				phy 								; start write
.157b	e8		inx				inx 								; prepare
.157c	74 56		stz $56,x			stz 	NSMantissa2,x
.157e	74 62		stz $62,x			stz 	NSMantissa3,x
.1580	74 6e		stz $6e,x			stz 	NSExponent,x
.1582	a9 40		lda #$40			lda 	#NSSString
.1584	74 32		stz $32,x			stz 	NSStatus,x
.1586	18		clc				clc
.1587	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.1589	69 02		adc #$02			adc 	#2 							; this points to actual data
.158b	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.158d	a0 01		ldy #$01			ldy 	#1
.158f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1591	69 00		adc #$00			adc 	#0
.1593	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1595	d0 08		bne $159f			bne 	_RSZNoDefault 				; if read $00 use a default value.
.1597	a9 a1		lda #$a1			lda 	#_RSZNull & $FF
.1599	95 3e		sta $3e,x			sta 	NSMantissa0,x
.159b	a9 15		lda #$15			lda 	#_RSZNull >> 8
.159d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.159f					_RSZNoDefault:
.159f	7a		ply				ply
.15a0	60		rts				rts
.15a1					_RSZNull:
>15a1	00						.byte 	0
.15a2					CommandRestore:
.15a2	fa		plx				plx
.15a3	20 a9 15	jsr $15a9			jsr 	RestoreCode
.15a6	4c 4f 08	jmp $084f			jmp 	NextCommand
.15a9					RestoreCode:
.15a9	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.15ac	85 2b		sta $2b				sta 	objPtr+1
.15ae	64 2a		stz $2a				stz 	objPtr
.15b0	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15b3	60		rts				rts
.0565					dataRemaining:
>0565							.fill 	1		 					; 0 if not in data statement
.15b4					UnaryRND:
.15b4	fa		plx				plx
.15b5	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.15b7	10 17		bpl $15d0			bpl 	_URNoSeed
.15b9	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; some float value
.15bc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.15be	8d 66 05	sta $0566			sta 	randomSeed+0
.15c1	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15c3	8d 67 05	sta $0567			sta 	randomSeed+1
.15c6	b5 56		lda $56,x			lda 	NSMantissa2,x
.15c8	8d 68 05	sta $0568			sta 	randomSeed+2
.15cb	b5 62		lda $62,x			lda 	NSMantissa3,x
.15cd	8d 69 05	sta $0569			sta 	randomSeed+3
.15d0					_URNoSeed:
.15d0	20 f2 15	jsr $15f2			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.15d3	ad 66 05	lda $0566			lda 	randomSeed+0
.15d6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15d8	ad 67 05	lda $0567			lda 	randomSeed+1
.15db	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15dd	ad 68 05	lda $0568			lda 	randomSeed+2
.15e0	95 56		sta $56,x			sta 	NSMantissa2,x
.15e2	ad 69 05	lda $0569			lda 	randomSeed+3
.15e5	29 7f		and #$7f			and 	#$7F
.15e7	95 62		sta $62,x			sta 	NSMantissa3,x
.15e9	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.15eb	95 6e		sta $6e,x			sta 	NSExponent,x
.15ed	74 32		stz $32,x			stz 	NSStatus,x
.15ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.15f2					RandomNumberGenerator:
.15f2	5a		phy				phy
.15f3	ad 66 05	lda $0566			lda 	randomSeed+0 				; check if zero
.15f6	0d 67 05	ora $0567			ora 	randomSeed+1
.15f9	0d 68 05	ora $0568			ora 	randomSeed+2
.15fc	0d 69 05	ora $0569			ora 	randomSeed+3
.15ff	d0 07		bne $1608			bne 	_RNGNoSeed
.1601	ce 69 05	dec $0569			dec 	randomSeed+3 				; if so tweak and flog
.1604	a0 64		ldy #$64			ldy 	#100
.1606	80 05		bra $160d			bra 	_RNGLoop
.1608					_RNGNoSeed:
.1608	a0 08		ldy #$08			ldy 	#8
.160a	ad 66 05	lda $0566			lda 	randomSeed+0
.160d					_RNGLoop:
.160d	0a		asl a				asl		a
.160e	2e 67 05	rol $0567			rol 	randomSeed+1
.1611	2e 68 05	rol $0568			rol 	randomSeed+2
.1614	2e 69 05	rol $0569			rol 	randomSeed+3
.1617	90 02		bcc $161b			bcc		_RNGSkip
.1619	49 c5		eor #$c5			eor 	#$C5
.161b					_RNGSkip:
.161b	88		dey				dey
.161c	d0 ef		bne $160d			bne		_RNGLoop
.161e	8d 66 05	sta $0566			sta 	randomSeed+0
.1621	7a		ply				ply
.1622	60		rts				rts
.0566					randomSeed:
>0566							.fill 	4
.1623					StringConcatenate:
.1623	fa		plx				plx
.1624	ca		dex				dex
.1625	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.1627	85 2e		sta $2e				sta 	zTemp1
.1629	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.162b	85 2f		sta $2f				sta 	zTemp1+1
.162d	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.162f	85 30		sta $30				sta 	zTemp2
.1631	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.1633	85 31		sta $31				sta 	zTemp2+1
.1635	18		clc				clc 								; work out total length
.1636	b2 2e		lda ($2e)			lda 	(zTemp1)
.1638	72 30		adc ($30)			adc 	(zTemp2)
.163a	b0 18		bcs $1654			bcs 	_BCLength 					; more than 255 characters.
.163c	48		pha				pha 								; save total
.163d	20 1a 17	jsr $171a			jsr 	StringAllocTemp 			; space for result.
.1640	68		pla				pla 								; write total as first.
.1641	92 22		sta ($22)			sta 	(zsTemp)
.1643	20 57 16	jsr $1657			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.1646	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.1648	85 2e		sta $2e				sta 	zTemp1
.164a	a5 31		lda $31				lda 	zTemp2+1
.164c	85 2f		sta $2f				sta 	zTemp1+1
.164e	20 57 16	jsr $1657			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1651	4c 4f 08	jmp $084f			jmp 	NextCommand
.1654					_BCLength:
.1654	4c ff 1e	jmp $1eff		jmp	ErrorV_range
.1657					_BCCopyZTemp1:
.1657	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.1659	f0 15		beq $1670			beq 	_BCCExit 					; none.
.165b	da		phx				phx 								; save XY
.165c	5a		phy				phy
.165d	aa		tax				tax 								; count in X.
.165e	a0 01		ldy #$01			ldy 	#1
.1660					_BCCLoop:
.1660	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1662	d0 02		bne $1666			bne 	_BCCNoCarry
.1664	e6 23		inc $23				inc 	zsTemp+1
.1666					_BCCNoCarry:
.1666	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.1668	92 22		sta ($22)			sta 	(zsTemp)
.166a	c8		iny				iny
.166b	ca		dex				dex 								; X times
.166c	d0 f2		bne $1660			bne 	_BCCLoop
.166e	7a		ply				ply 								; restore YX
.166f	fa		plx				plx
.1670					_BCCExit:
.1670	60		rts				rts
.1671					XRuntimeSetup:
.1671	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1673	8d 6d 05	sta $056d	 		sta 	ramBank
.1676	8d 6e 05	sta $056e	 		sta 	romBank
.1679	60		rts				rts
.167a					SignTOS:
.167a	fa		plx				plx
.167b	20 95 26	jsr $2695			jsr 	FloatIsZero 				; if zero
.167e	f0 0f		beq $168f			beq 	_SGZero  					; return Int Zero
.1680	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.1682	48		pha				pha
.1683	a9 01		lda #$01			lda 	#1 							; set result to 1
.1685	20 75 26	jsr $2675			jsr 	FloatSetByte
.1688	68		pla				pla
.1689	29 80		and #$80			and		#$80 						; copy the sign byte out
.168b	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.168d	80 03		bra $1692			bra 	_SGExit
.168f					_SGZero:
.168f	20 73 26	jsr $2673			jsr 	FloatSetZero
.1692					_SGExit:
.1692	4c 4f 08	jmp $084f			jmp 	NextCommand
.1695					CommandShift:
.1695	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.1697	c8		iny				iny
.1698	0a		asl a				asl 	a 							; double into X
.1699	aa		tax				tax
.169a	7c 47 1a	jmp ($1a47,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.169d					PrintTab:
.169d	fa		plx				plx
.169e	20 ef 1b	jsr $1bef			jsr 	XGetHPos
.16a1					_PTMod10:
.16a1	38		sec				sec
.16a2	e9 0a		sbc #$0a			sbc 	#10
.16a4	b0 fb		bcs $16a1			bcs 	_PTMod10
.16a6	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.16a8	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.16a9	80 15		bra $16c0			bra 	PrintSpaceLoop
.16ab					PrintPos:
.16ab	fa		plx				plx
.16ac	20 ef 1b	jsr $1bef			jsr		XGetHPos 					; get current position
.16af	85 2c		sta $2c				sta 	zTemp0
.16b1	38		sec				sec 								; calculate spaces required
.16b2	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16b4	ca		dex				dex
.16b5	e5 2c		sbc $2c				sbc 	zTemp0
.16b7	b0 07		bcs $16c0			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.16b9	4c 4f 08	jmp $084f			jmp 	NextCommand
.16bc					PrintSpace:
.16bc	fa		plx				plx
.16bd	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16bf	ca		dex				dex
.16c0					PrintSpaceLoop:
.16c0	c9 00		cmp #$00			cmp 	#0
.16c2	f0 0a		beq $16ce			beq 	_PSExit
.16c4	48		pha				pha
.16c5	a9 20		lda #$20			lda 	#" "
.16c7	20 77 13	jsr $1377			jsr 	VectorPrintCharacter
.16ca	68		pla				pla
.16cb	3a		dec a				dec 	a
.16cc	80 f2		bra $16c0			bra 	PrintSpaceLoop
.16ce					_PSExit:
.16ce	4c 4f 08	jmp $084f			jmp 	NextCommand
.16d1					CommandStop:
.16d1	fa		plx				plx
.16d2	4c b1 1f	jmp $1fb1		jmp	ErrorV_stop
.16d5					Unary_Str:
.16d5	fa		plx				plx
.16d6	5a		phy				phy
.16d7	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.16d9	20 5b 25	jsr $255b			jsr 	FloatToString 				; do the conversion.
.16dc	a9 21		lda #$21			lda		#33 						; create buffer
.16de	20 1a 17	jsr $171a			jsr 	StringAllocTemp 			; allocate memory
.16e1	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.16e3					_USCopy:
.16e3	b9 97 05	lda $0597,y			lda 	decimalBuffer-1,y
.16e6	f0 05		beq $16ed			beq 	_USExit
.16e8	91 22		sta ($22),y			sta 	(zsTemp),y
.16ea	c8		iny				iny
.16eb	80 f6		bra $16e3			bra 	_USCopy
.16ed					_USExit:
.16ed	98		tya				tya
.16ee	3a		dec a				dec 	a
.16ef	92 22		sta ($22)			sta 	(zsTemp)
.16f1	7a		ply				ply
.16f2	4c 4f 08	jmp $084f			jmp 	NextCommand
.16f5					StringInitialise:
.16f5	48		pha				pha
.16f6	ad 6a 05	lda $056a			lda 	stringInitialised 			; already done
.16f9	d0 11		bne $170c			bne 	_SIExit
.16fb	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.16fe	8d 6b 05	sta $056b			sta 	stringTempPointer
.1701	ad 03 04	lda $0403			lda 	stringHighMemory+1
.1704	3a		dec a				dec 	a
.1705	3a		dec a				dec 	a
.1706	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.1709	ce 6a 05	dec $056a			dec 	stringInitialised 			; set the initialised flag.
.170c					_SIExit:
.170c	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.170e	1a		inc a				inc 	a
.170f	1a		inc a				inc 	a
.1710	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.1713	b0 02		bcs $1717			bcs 	_SIMemory
.1715	68		pla				pla
.1716	60		rts				rts
.1717					_SIMemory:
.1717	4c 0a 20	jmp $200a		jmp	ErrorV_memory
.171a					StringAllocTemp:
.171a	20 f5 16	jsr $16f5			jsr 	StringInitialise 			; check it is initialised.
.171d	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.171f	18		clc				clc
.1720	6d 6b 05	adc $056b			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.1723	8d 6b 05	sta $056b			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.1726	85 22		sta $22				sta 	zsTemp
.1728	95 3e		sta $3e,x			sta 	NSMantissa0,x
.172a	ad 6c 05	lda $056c			lda 	stringTempPointer+1
.172d	69 ff		adc #$ff			adc 	#$FF
.172f	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.1732	85 23		sta $23				sta 	zsTemp+1
.1734	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1736	74 56		stz $56,x			stz 	NSMantissa2,x
.1738	74 62		stz $62,x			stz 	NSMantissa3,x
.173a	a9 00		lda #$00			lda 	#0 							; clear string.
.173c	92 22		sta ($22)			sta 	(zsTemp)
.173e	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1740	95 32		sta $32,x			sta 	NSStatus,x
.1742	60		rts				rts
.1743					StringWriteChar:
.1743	5a		phy				phy
.1744	48		pha				pha
.1745	b2 22		lda ($22)			lda 	(zsTemp)
.1747	1a		inc a				inc 	a
.1748	92 22		sta ($22)			sta 	(zsTemp)
.174a	a8		tay				tay
.174b	68		pla				pla
.174c	91 22		sta ($22),y			sta 	(zsTemp),y
.174e	7a		ply				ply
.174f	60		rts				rts
.056a					stringInitialised:
>056a							.fill 	1
.056b					stringTempPointer:
>056b							.fill 	2
.1750					Unary_Left:
.1750	fa		plx				plx
.1751	5a		phy				phy
.1752	18		clc				clc 								; only one parameter
.1753	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the length of the string.
.1756	48		pha				pha
.1757	ca		dex				dex
.1758	a9 00		lda #$00			lda 	#0 							; push the start position.
.175a	48		pha				pha
.175b	20 93 17	jsr $1793			jsr 	UnarySStringToZTemp0
.175e	80 3c		bra $179c			bra 	SubstringMain 				; stack now points to the string to slice.
.1760					Unary_Right:
.1760	fa		plx				plx
.1761	5a		phy				phy
.1762	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.1764	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the right length of the string.
.1767	48		pha				pha
.1768	ca		dex				dex
.1769	20 93 17	jsr $1793			jsr 	UnarySStringToZTemp0
.176c	68		pla				pla 								; this is the right requirement
.176d	38		sec				sec
.176e	49 ff		eor #$ff			eor 	#$FF
.1770	72 2c		adc ($2c)			adc 	(zTemp0)
.1772	b0 02		bcs $1776			bcs 	_URHaveCount
.1774	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.1776					_URHaveCount:
.1776	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.1778	5a		phy				phy
.1779	48		pha				pha 								; start position
.177a	80 20		bra $179c			bra 	SubstringMain
.177c					Unary_Mid:
.177c	fa		plx				plx
.177d	5a		phy				phy
.177e	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the length of the string required.
.1781	48		pha				pha
.1782	ca		dex				dex
.1783	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; put the start position.
.1786	f0 08		beq $1790			beq 	_UMError
.1788	3a		dec a				dec 	a
.1789	48		pha				pha
.178a	ca		dex				dex
.178b	20 93 17	jsr $1793			jsr 	UnarySStringToZTemp0
.178e	80 0c		bra $179c			bra 	SubstringMain 				; stack now points to the string to slice.
.1790					_UMError:
.1790	4c ff 1e	jmp $1eff		jmp	ErrorV_range
.1793					UnarySStringToZTemp0:
.1793	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1795	85 2c		sta $2c				sta 	zTemp0
.1797	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1799	85 2d		sta $2d				sta 	zTemp0+1
.179b	60		rts				rts
.179c					SubstringMain:
.179c	68		pla				pla 								; get the start offset
.179d	7a		ply				ply 								; get the count to do.
.179e	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.17a0	b0 38		bcs $17da			bcs 	_SSReturnNull
.17a2	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.17a4	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.17a6	18		clc				clc
.17a7	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.17a9	b0 06		bcs $17b1			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.17ab	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.17ad	f0 04		beq $17b3			beq 	_SMIsOkay
.17af	90 02		bcc $17b3			bcc 	_SMIsOkay
.17b1					_SMTruncateToEnd:
.17b1	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.17b3					_SMIsOkay:
.17b3	85 2f		sta $2f				sta 	zTemp1+1
.17b5	38		sec				sec		 							; work out size
.17b6	a5 2f		lda $2f				lda 	zTemp1+1
.17b8	e5 2e		sbc $2e				sbc 	zTemp1
.17ba	f0 1e		beq $17da			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.17bc	20 1a 17	jsr $171a			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.17bf	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.17c1					_SMCopy:
.17c1	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.17c3	f0 11		beq $17d6			beq 	_SMExit
.17c5	c8		iny				iny 								; bump and
.17c6	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.17c8	5a		phy				phy
.17c9	48		pha				pha
.17ca	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.17cc	1a		inc a				inc 	a
.17cd	a8		tay				tay
.17ce	92 22		sta ($22)			sta 	(zsTemp)
.17d0	68		pla				pla 								; write character out
.17d1	91 22		sta ($22),y			sta 	(zsTemp),y
.17d3	7a		ply				ply 								; restore Y
.17d4	80 eb		bra $17c1			bra 	_SMCopy
.17d6					_SMExit:
.17d6	7a		ply				ply
.17d7	4c 4f 08	jmp $084f			jmp 	NextCommand
.17da					_SSReturnNull:
.17da	a9 ec		lda #$ec			lda 	#SSRNull & $FF 				; set up mantissa
.17dc	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17de	a9 17		lda #$17			lda 	#SSRNull >> 8
.17e0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17e2	74 56		stz $56,x			stz 	NSMantissa2,x
.17e4	74 62		stz $62,x			stz 	NSMantissa3,x
.17e6	a9 40		lda #$40			lda 	#NSSString
.17e8	95 32		sta $32,x			sta 	NSStatus,x
.17ea	80 ea		bra $17d6			bra 	_SMExit
.17ec					SSRNull:
>17ec	00 00						.word 	0
.17ee					CommandSwap:
.17ee	fa		plx				plx
.17ef	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17f1	48		pha				pha
.17f2	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.17f4	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17f6	68		pla				pla
.17f7	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.17f9	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17fb	48		pha				pha
.17fc	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.17fe	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1800	68		pla				pla
.1801	95 49		sta $49,x			sta 	NSMantissa1-1,x
.1803	b5 56		lda $56,x			lda 	NSMantissa2,x
.1805	48		pha				pha
.1806	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.1808	95 56		sta $56,x			sta 	NSMantissa2,x
.180a	68		pla				pla
.180b	95 55		sta $55,x			sta 	NSMantissa2-1,x
.180d	b5 62		lda $62,x			lda 	NSMantissa3,x
.180f	48		pha				pha
.1810	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.1812	95 62		sta $62,x			sta 	NSMantissa3,x
.1814	68		pla				pla
.1815	95 61		sta $61,x			sta 	NSMantissa3-1,x
.1817	b5 6e		lda $6e,x			lda 	NSExponent,x
.1819	48		pha				pha
.181a	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.181c	95 6e		sta $6e,x			sta 	NSExponent,x
.181e	68		pla				pla
.181f	95 6d		sta $6d,x			sta 	NSExponent-1,x
.1821	b5 32		lda $32,x			lda 	NSStatus,x
.1823	48		pha				pha
.1824	b5 31		lda $31,x			lda 	NSStatus-1,x
.1826	95 32		sta $32,x			sta 	NSStatus,x
.1828	68		pla				pla
.1829	95 31		sta $31,x			sta 	NSStatus-1,x
.182b	4c 4f 08	jmp $084f			jmp 	NextCommand
.182e					CommandSYS:
.182e	fa		plx				plx
.182f	da		phx				phx 								; save XY
.1830	5a		phy				phy
.1831	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.1834	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.1836	85 2d		sta $2d				sta 	zTemp0+1
.1838	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.183a	85 2c		sta $2c				sta 	zTemp0
.183c	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.183f	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.1842	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.1845	48		pha				pha
.1846	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.1849	28		plp				plp
.184a	20 61 18	jsr $1861			jsr 	_CSZTemp0
.184d	08		php				php
.184e	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1851	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.1854	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.1857	68		pla				pla
.1858	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.185b	7a		ply				ply 								; restore YX and drop 2
.185c	fa		plx				plx
.185d	ca		dex				dex
.185e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1861					_CSZTemp0:
.1861	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.1864					TimeTOS:
.1864	fa		plx				plx
.1865	20 bf 18	jsr $18bf			jsr 	TIPushClock 				; push clock to TOS
.1868	4c 4f 08	jmp $084f			jmp 	NextCommand
.186b					TimeString:
.186b	fa		plx				plx
.186c	20 bf 18	jsr $18bf			jsr 	TIPushClock 				; push clock to TOS
.186f	20 94 18	jsr $1894			jsr 	_TSDivMod60 				; result in seconds
.1872	20 94 18	jsr $1894			jsr 	_TSDivMod60 				; seconds
.1875	48		pha				pha
.1876	20 94 18	jsr $1894			jsr 	_TSDivMod60 				; minutes
.1879	48		pha				pha
.187a	a9 18		lda #$18			lda 	#24 						; hours
.187c	20 96 18	jsr $1896			jsr 	_TSDivModA
.187f	48		pha				pha
.1880	a9 06		lda #$06			lda 	#6
.1882	20 1a 17	jsr $171a			jsr 	StringAllocTemp
.1885	68		pla				pla
.1886	20 a6 18	jsr $18a6			jsr 	_TSWriteDecimal
.1889	68		pla				pla
.188a	20 a6 18	jsr $18a6			jsr 	_TSWriteDecimal
.188d	68		pla				pla
.188e	20 a6 18	jsr $18a6			jsr 	_TSWriteDecimal
.1891	4c 4f 08	jmp $084f			jmp 	NextCommand
.1894					_TSDivMod60:
.1894	a9 3c		lda #$3c			lda 	#60
.1896					_TSDivModA:
.1896	e8		inx				inx
.1897	20 75 26	jsr $2675			jsr 	FloatSetByte
.189a	ca		dex				dex
.189b	20 09 22	jsr $2209			jsr 	Int32Divide
.189e	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.18a0	48		pha				pha
.18a1	20 f8 21	jsr $21f8			jsr 	NSMCopyPlusTwoToZero
.18a4	68		pla				pla
.18a5	60		rts				rts
.18a6					_TSWriteDecimal:
.18a6	da		phx				phx
.18a7	a2 30		ldx #$30			ldx 	#'0'
.18a9					_TSWDLoop:
.18a9	c9 0a		cmp #$0a			cmp 	#10
.18ab	90 05		bcc $18b2			bcc 	_TSWDEnd
.18ad	e9 0a		sbc #$0a			sbc 	#10
.18af	e8		inx				inx
.18b0	80 f7		bra $18a9			bra 	_TSWDLoop
.18b2					_TSWDEnd:
.18b2	48		pha				pha
.18b3	8a		txa				txa
.18b4	20 43 17	jsr $1743			jsr 	StringWriteChar
.18b7	68		pla				pla
.18b8	09 30		ora #$30			ora 	#'0'
.18ba	20 43 17	jsr $1743			jsr 	StringWriteChar
.18bd	fa		plx				plx
.18be	60		rts				rts
.18bf					TIPushClock:
.18bf	5a		phy				phy
.18c0	e8		inx				inx 								; push 0 on the stack
.18c1	20 73 26	jsr $2673			jsr 	FloatSetZero
.18c4	da		phx				phx
.18c5	20 ba 1c	jsr $1cba			jsr 	XReadClock 					; read time into YXA
.18c8	86 2c		stx $2c				stx 	zTemp0
.18ca	fa		plx				plx
.18cb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.18cd	a5 2c		lda $2c				lda 	zTemp0
.18cf	95 4a		sta $4a,x			sta 	NSMantissa1,x
.18d1	98		tya				tya
.18d2	95 56		sta $56,x			sta 	NSMantissa2,x
.18d4	7a		ply				ply
.18d5	60		rts				rts
.18d6					CommandTIWrite:
.18d6	fa		plx				plx
.18d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.18d9	85 22		sta $22				sta 	zsTemp
.18db	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.18dd	85 23		sta $23				sta 	zsTemp+1
.18df	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.18e1	c9 06		cmp #$06			cmp 	#6
.18e3	d0 59		bne $193e			bne 	_CTIWError
.18e5	20 73 26	jsr $2673			jsr 	FloatSetZero
.18e8	20 0a 19	jsr $190a			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.18eb	20 0a 19	jsr $190a			jsr 	_CTIWDigitPair
.18ee	20 0a 19	jsr $190a			jsr 	_CTIWDigitPair
.18f1	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.18f3	20 35 19	jsr $1935			jsr 	_CTIWMultiply
.18f6	da		phx				phx
.18f7	5a		phy				phy
.18f8	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.18fa	48		pha				pha
.18fb	b5 56		lda $56,x			lda 	NSMantissa2,x
.18fd	a8		tay				tay
.18fe	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1900	fa		plx				plx
.1901	20 be 1c	jsr $1cbe			jsr 	XWriteClock 				; update the clock.
.1904	7a		ply				ply
.1905	fa		plx				plx
.1906	ca		dex				dex 								; throw result.
.1907	4c 4f 08	jmp $084f			jmp 	NextCommand
.190a					_CTIWDigitPair:
.190a	a9 06		lda #$06			lda 	#6 							; x 6
.190c	20 35 19	jsr $1935			jsr 	_CTIWMultiply
.190f	20 1b 19	jsr $191b			jsr 	_CTIWAddDigit 				; add digit
.1912	a9 0a		lda #$0a			lda 	#10 						; x 10
.1914	20 35 19	jsr $1935			jsr 	_CTIWMultiply
.1917	20 1b 19	jsr $191b			jsr 	_CTIWAddDigit 				; add digit
.191a	60		rts				rts
.191b					_CTIWAddDigit:
.191b	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.191d	d0 02		bne $1921			bne 	_CTIWASkip
.191f	e6 23		inc $23				inc 	zsTemp+1
.1921					_CTIWASkip:
.1921	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.1923	38		sec				sec
.1924	e9 30		sbc #$30			sbc 	#"0"
.1926	90 16		bcc $193e			bcc 	_CTIWError
.1928	c9 0a		cmp #$0a			cmp 	#9+1
.192a	b0 12		bcs $193e			bcs 	_CTIWError
.192c	e8		inx				inx 								; store at +1
.192d	20 75 26	jsr $2675			jsr 	FloatSetByte
.1930	ca		dex				dex
.1931	20 ff 23	jsr $23ff			jsr 	FloatAddTopTwoStack
.1934	60		rts				rts
.1935					_CTIWMultiply:
.1935	e8		inx				inx
.1936	20 75 26	jsr $2675			jsr 	FloatSetByte
.1939	ca		dex				dex
.193a	20 80 23	jsr $2380			jsr 	FloatMultiplyShort
.193d	60		rts				rts
.193e					_CTIWError:
.193e	4c 0f 1f	jmp $1f0f		jmp	ErrorV_value
.1941					UnaryUsr:
.1941	fa		plx				plx
.1942	5a		phy				phy
.1943	20 4a 19	jsr $194a			jsr 	_UUCallVector
.1946	7a		ply				ply
.1947	4c 4f 08	jmp $084f			jmp 	NextCommand
.194a					_UUCallVector:
.194a	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.194d					ValUnary:
.194d	fa		plx				plx
.194e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1950	85 2c		sta $2c				sta 	zTemp0
.1952	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1954	85 2d		sta $2d				sta 	zTemp0+1
.1956	20 61 19	jsr $1961			jsr 	ValEvaluateZTemp0
.1959	b0 03		bcs $195e			bcs 	_VUError 					; couldn't convert
.195b	4c 4f 08	jmp $084f			jmp 	NextCommand
.195e					_VUError:
.195e	4c 0f 1f	jmp $1f0f		jmp	ErrorV_value
.1961					ValEvaluateZTemp0:
.1961	5a		phy				phy
.1962	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.1964	f0 22		beq $1988			beq 	_VMCFail2
.1966	a0 00		ldy #$00			ldy 	#0 							; start position
.1968					_VMCSpaces:
.1968	c8		iny				iny 								; skip leading spaces
.1969	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.196b	c9 20		cmp #$20			cmp 	#" "
.196d	f0 f9		beq $1968			beq 	_VMCSpaces
.196f	48		pha				pha 								; save first character
.1970	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.1972	d0 01		bne $1975			bne 	_VMCStart
.1974	c8		iny				iny 								; skip over - if so.
.1975					_VMCStart:
.1975	38		sec				sec 								; initialise first time round.
.1976					_VMCNext:
.1976	98		tya				tya 								; reached end of string
.1977	3a		dec a				dec 	a
.1978	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.197a	f0 0f		beq $198b			beq 	_VMCSuccess 				; successful.
.197c	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.197e	c8		iny				iny
.197f	20 57 24	jsr $2457			jsr 	FloatEncode 				; send it to the number-builder
.1982	90 03		bcc $1987			bcc 	_VMCFail 					; if failed, give up.
.1984	18		clc				clc 								; next time round, countinue
.1985	80 ef		bra $1976			bra 	_VMCNext
.1987					_VMCFail:
.1987	68		pla				pla
.1988					_VMCFail2:
.1988	7a		ply				ply
.1989	38		sec				sec
.198a	60		rts				rts
.198b					_VMCSuccess:
.198b	a9 00		lda #$00			lda 	#0 							; construct final
.198d	20 57 24	jsr $2457			jsr 	FloatEncode 				; by sending a duff value.
.1990	68		pla				pla 								; if it was -ve
.1991	c9 2d		cmp #$2d			cmp 	#"-"
.1993	d0 03		bne $1998			bne 	_VMCNotNegative
.1995	20 35 26	jsr $2635			jsr		FloatNegate 				; negate it.
.1998					_VMCNotNegative:
.1998	7a		ply				ply
.1999	18		clc				clc
.199a	60		rts				rts
.199b					VectorTable:
>199b	a9 10					.word	LinkFloatAdd             ; $80 +
>199d	b2 10					.word	LinkFloatSubtract        ; $81 -
>199f	bb 10					.word	LinkFloatMultiply        ; $82 *
>19a1	c4 10					.word	LinkFloatDivide          ; $83 /
>19a3	cf 10					.word	LinkFloatPower           ; $84 ^
>19a5	f2 08					.word	BinaryAnd                ; $85 and
>19a7	f6 08					.word	BinaryOr                 ; $86 or
>19a9	da 10					.word	LinkCompareGreater       ; $87 >
>19ab	e3 10					.word	LinkCompareEqual         ; $88 =
>19ad	ec 10					.word	LinkCompareLess          ; $89 <
>19af	f5 10					.word	LinkCompareGreaterEqual  ; $8a >=
>19b1	fe 10					.word	LinkCompareNotEqual      ; $8b <>
>19b3	07 11					.word	LinkCompareLessEqual     ; $8c <=
>19b5	da 08					.word	AbsoluteTOS              ; $8d abs
>19b7	2d 09					.word	ArrayConvert             ; $8e array
>19b9	d5 09					.word	UnaryAsc                 ; $8f asc
>19bb	f0 09					.word	CommandAssert            ; $90 assert
>19bd	31 0a					.word	Unary16Bin               ; $91 bin$
>19bf	5b 0a					.word	PrintCharacterX          ; $92 print.chr
>19c1	65 0a					.word	UnaryChr                 ; $93 chr$
>19c3	ca 0a					.word	CompareStrings           ; $94 s.cmp
>19c5	b6 0c					.word	CommandXFor              ; $95 for
>19c7	79 0d					.word	UnaryFre                 ; $96 fre
>19c9	91 0d					.word	CommandXGet              ; $97 get
>19cb	b7 0d					.word	CommandReturn            ; $98 return
>19cd	f9 0d					.word	Command_PSET             ; $99 pset
>19cf	13 0e					.word	Command_LINE             ; $9a line
>19d1	28 0e					.word	Command_RECT             ; $9b rect
>19d3	37 0e					.word	Command_FRAME            ; $9c frame
>19d5	46 0e					.word	Command_CHAR             ; $9d char
>19d7	dd 0e					.word	Unary16Hex               ; $9e hex$
>19d9	84 0f					.word	CommandXInput            ; $9f input
>19db	9b 0f					.word	CommandInputString       ; $a0 input$
>19dd	b4 0f					.word	CommandInputReset        ; $a1 input.start
>19df	98 10					.word	UnaryLen                 ; $a2 len
>19e1	64 11					.word	LinkFloatCompare         ; $a3 f.cmp
>19e3	6d 11					.word	LinkDivideInt32          ; $a4 int.div
>19e5	e7 11					.word	NegateTOS                ; $a5 negate
>19e7	ee 11					.word	CommandNewLine           ; $a6 new.line
>19e9	f7 11					.word	CommandXNext             ; $a7 next
>19eb	e0 12					.word	NotTOS                   ; $a8 not
>19ed	f7 12					.word	CommandXOn               ; $a9 on
>19ef	14 13					.word	CommandMoreOn            ; $aa moreon
>19f1	1b 13					.word	UnaryPeek                ; $ab peek
>19f3	30 13					.word	UnaryPI                  ; $ac pi
>19f5	39 13					.word	CommandPOKE              ; $ad poke
>19f7	51 13					.word	UnaryPos                 ; $ae pos
>19f9	5b 13					.word	GetChannel               ; $af getchannel
>19fb	66 13					.word	SetChannel               ; $b0 setchannel
>19fd	89 13					.word	PrintNumber              ; $b1 print.n
>19ff	a8 13					.word	PrintString              ; $b2 print.s
>1a01	0f 14					.word	CommandXRead             ; $b3 read
>1a03	29 14					.word	CommandReadString        ; $b4 read$
>1a05	b4 15					.word	UnaryRND                 ; $b5 rnd
>1a07	23 16					.word	StringConcatenate        ; $b6 concat
>1a09	7a 16					.word	SignTOS                  ; $b7 sgn
>1a0b	9d 16					.word	PrintTab                 ; $b8 print.tab
>1a0d	ab 16					.word	PrintPos                 ; $b9 print.pos
>1a0f	bc 16					.word	PrintSpace               ; $ba print.spc
>1a11	d5 16					.word	Unary_Str                ; $bb str$
>1a13	50 17					.word	Unary_Left               ; $bc left$
>1a15	60 17					.word	Unary_Right              ; $bd right$
>1a17	7c 17					.word	Unary_Mid                ; $be mid$
>1a19	ee 17					.word	CommandSwap              ; $bf swap
>1a1b	64 18					.word	TimeTOS                  ; $c0 ti
>1a1d	6b 18					.word	TimeString               ; $c1 ti$
>1a1f	41 19					.word	UnaryUsr                 ; $c2 usr
>1a21	4d 19					.word	ValUnary                 ; $c3 val
>1a23	b6 1b					.word	CommandClose             ; $c4 close
>1a25	c8 1b					.word	CommandExit              ; $c5 exit
>1a27	ce 1b					.word	CommandDebug             ; $c6 debug
>1a29	34 1c					.word	CommandXOpen             ; $c7 open
>1a2b	c8 1c					.word	CommandScreen            ; $c8 screen
>1a2d	af 1e					.word	CommandVPOKE             ; $c9 vpoke
>1a2f	d4 1e					.word	CommandVPEEK             ; $ca vpeek
>1a31	95 16					.word	CommandShift             ; $cb .shift
>1a33	9e 08					.word	PushByteCommand          ; $cc .byte
>1a35	b1 08					.word	PushWordCommand          ; $cd .word
>1a37	cb 13					.word	CommandPushN             ; $ce .float
>1a39	f1 13					.word	CommandPushS             ; $cf .string
>1a3b	52 0b					.word	CommandXData             ; $d0 .data
>1a3d	c8 0d					.word	CommandXGoto             ; $d1 .goto
>1a3f	ab 0d					.word	CommandXGosub            ; $d2 .gosub
>1a41	dd 0d					.word	CommandGotoZ             ; $d3 .goto.z
>1a43	eb 0d					.word	CommandGotoNZ            ; $d4 .goto.nz
>1a45	e0 08					.word	CommandVarSpace          ; $d5 .varspace
.1a47					ShiftVectorTable:
>1a47	7d 0a					.word	CommandClr               ; $cb80 clr
>1a49	5b 0b					.word	CommandXDIM              ; $cb81 dim
>1a4b	4c 0c					.word	CommandEnd               ; $cb82 end
>1a4d	69 10					.word	UnaryJoy                 ; $cb83 joy
>1a4f	10 11					.word	LinkFloatIntegerPartDown ; $cb84 int
>1a51	19 11					.word	LinkFloatSquareRoot      ; $cb85 sqr
>1a53	2a 11					.word	LinkFloatLogarithm       ; $cb86 log
>1a55	35 11					.word	LinkFloatExponent        ; $cb87 exp
>1a57	3e 11					.word	LinkFloatCosine          ; $cb88 cos
>1a59	47 11					.word	LinkFloatSine            ; $cb89 sin
>1a5b	50 11					.word	LinkFloatTangent         ; $cb8a tan
>1a5d	59 11					.word	LinkFloatArcTan          ; $cb8b atn
>1a5f	97 11					.word	XCommandMouse            ; $cb8c mouse
>1a61	ac 11					.word	XUnaryMB                 ; $cb8d mb
>1a63	b9 11					.word	XUnaryMX                 ; $cb8e mx
>1a65	ca 11					.word	XUnaryMY                 ; $cb8f my
>1a67	a2 15					.word	CommandRestore           ; $cb90 restore
>1a69	d1 16					.word	CommandStop              ; $cb91 stop
>1a6b	2e 18					.word	CommandSYS               ; $cb92 sys
>1a6d	d6 18					.word	CommandTIWrite           ; $cb93 ti$.write
>1a6f	a5 1a					.word	CommandXWAIT             ; $cb94 wait
>1a71	f9 1b					.word	X16I2CPoke               ; $cb95 i2cpoke
>1a73	19 1c					.word	X16I2CPeek               ; $cb96 i2cpeek
>1a75	84 1c					.word	CommandBank              ; $cb97 bank
>1a77	d7 1c					.word	XCommandSleep            ; $cb98 sleep
>1a79	fb 1c					.word	X16_Audio_FMINIT         ; $cb99 fminit
>1a7b	09 1d					.word	X16_Audio_FMNOTE         ; $cb9a fmnote
>1a7d	1b 1d					.word	X16_Audio_FMDRUM         ; $cb9b fmdrum
>1a7f	2d 1d					.word	X16_Audio_FMINST         ; $cb9c fminst
>1a81	3f 1d					.word	X16_Audio_FMVIB          ; $cb9d fmvib
>1a83	51 1d					.word	X16_Audio_FMFREQ         ; $cb9e fmfreq
>1a85	62 1d					.word	X16_Audio_FMVOL          ; $cb9f fmvol
>1a87	74 1d					.word	X16_Audio_FMPAN          ; $cba0 fmpan
>1a89	86 1d					.word	X16_Audio_FMPLAY         ; $cba1 fmplay
>1a8b	97 1d					.word	X16_Audio_FMCHORD        ; $cba2 fmchord
>1a8d	a8 1d					.word	X16_Audio_FMPOKE         ; $cba3 fmpoke
>1a8f	ba 1d					.word	X16_Audio_PSGINIT        ; $cba4 psginit
>1a91	c8 1d					.word	X16_Audio_PSGNOTE        ; $cba5 psgnote
>1a93	da 1d					.word	X16_Audio_PSGVOL         ; $cba6 psgvol
>1a95	ec 1d					.word	X16_Audio_PSGWAV         ; $cba7 psgwav
>1a97	fe 1d					.word	X16_Audio_PSGFREQ        ; $cba8 psgfreq
>1a99	0f 1e					.word	X16_Audio_PSGPAN         ; $cba9 psgpan
>1a9b	21 1e					.word	X16_Audio_PSGPLAY        ; $cbaa psgplay
>1a9d	32 1e					.word	X16_Audio_PSGCHORD       ; $cbab psgchord
>1a9f	43 1e					.word	CommandCls               ; $cbac cls
>1aa1	4c 1e					.word	CommandLocate            ; $cbad locate
>1aa3	76 1e					.word	CommandColor             ; $cbae color
.1aa5					CommandXWAIT:
.1aa5	fa		plx				plx
.1aa6	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1aa8	85 2c		sta $2c				sta 	zTemp0
.1aaa	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1aac	85 2d		sta $2d				sta 	zTemp0+1
.1aae					_WaitLoop:
.1aae	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1ab0	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1ab2	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1ab4	f0 f8		beq $1aae			beq 	_WaitLoop 					; keep going if zero
.1ab6	ca		dex				dex 								; drop 3.
.1ab7	ca		dex				dex
.1ab8	ca		dex				dex
.1ab9	4c 4f 08	jmp $084f			jmp 	NextCommand
.1abc					WriteFloatCommand:
.1abc	fa		plx				plx
.1abd	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1abf	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1ac1	88		dey				dey 								; get the upper 3 bits
.1ac2	b1 28		lda ($28),y			lda 	(codePtr),y
.1ac4	29 07		and #$07			and 	#7
.1ac6	c8		iny				iny
.1ac7	c8		iny				iny
.1ac8	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1aca	2a		rol a				rol 	a 							; carry will be clear.
.1acb	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1ace	85 2d		sta $2d				sta 	zTemp0+1
.1ad0	20 d6 1a	jsr $1ad6			jsr 	WriteFloatZTemp0Sub
.1ad3	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ad6					WriteFloatZTemp0Sub:
.1ad6	5a		phy				phy 								; ldart write
.1ad7	a0 01		ldy #$01			ldy 	#1
.1ad9	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1adb	92 2c		sta ($2c)			sta 	(zTemp0)
.1add	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1adf	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ae1	c8		iny				iny
.1ae2	b5 56		lda $56,x			lda 	NSMantissa2,x
.1ae4	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ae6	c8		iny				iny
.1ae7	b5 62		lda $62,x			lda 	NSMantissa3,x
.1ae9	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1aeb	c8		iny				iny
.1aec	b5 6e		lda $6e,x			lda 	NSExponent,x
.1aee	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1af0	c8		iny				iny
.1af1	b5 32		lda $32,x			lda 	NSStatus,x
.1af3	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1af5	ca		dex				dex
.1af6	7a		ply				ply
.1af7	60		rts				rts
.1af8					WriteIntegerCommand:
.1af8	fa		plx				plx
.1af9	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1afb	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1afd	88		dey				dey 								; get the upper 3 bits
.1afe	b1 28		lda ($28),y			lda 	(codePtr),y
.1b00	29 07		and #$07			and 	#7
.1b02	c8		iny				iny
.1b03	c8		iny				iny
.1b04	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b06	2a		rol a				rol 	a 							; carry will be clear.
.1b07	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b0a	85 2d		sta $2d				sta 	zTemp0+1
.1b0c	20 12 1b	jsr $1b12			jsr 	WriteIntegerZTemp0Sub
.1b0f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b12					WriteIntegerZTemp0Sub:
.1b12	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.1b15	5a		phy				phy 								; start write
.1b16	a0 01		ldy #$01			ldy 	#1
.1b18	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1b1a	30 0b		bmi $1b27			bmi 	_WIZNegative
.1b1c	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1b1e	92 2c		sta ($2c)			sta 	(zTemp0)
.1b20	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b22	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b24	7a		ply				ply
.1b25	ca		dex				dex
.1b26	60		rts				rts
.1b27					_WIZNegative:
.1b27	38		sec				sec 								; -ve read
.1b28	a9 00		lda #$00			lda 	#0
.1b2a	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1b2c	92 2c		sta ($2c)			sta 	(zTemp0)
.1b2e	a9 00		lda #$00			lda 	#0
.1b30	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1b32	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b34	7a		ply				ply
.1b35	ca		dex				dex
.1b36	60		rts				rts
.1b37					WriteStringCommand:
.1b37	fa		plx				plx
.1b38	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b3a	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b3c	88		dey				dey 								; get the upper 3 bits
.1b3d	b1 28		lda ($28),y			lda 	(codePtr),y
.1b3f	29 07		and #$07			and 	#7
.1b41	c8		iny				iny
.1b42	c8		iny				iny
.1b43	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b45	2a		rol a				rol 	a 							; carry will be clear.
.1b46	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b49	85 2d		sta $2d				sta 	zTemp0+1
.1b4b	20 51 1b	jsr $1b51			jsr 	WriteStringZTemp0Sub
.1b4e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b51					WriteStringZTemp0Sub:
.1b51	5a		phy				phy
.1b52	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b54	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b56	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b58	f0 1e		beq $1b78			beq 	_WSConcrete
.1b5a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b5c	85 2e		sta $2e				sta 	zTemp1
.1b5e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b60	85 2f		sta $2f				sta 	zTemp1+1
.1b62	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b64	85 30		sta $30				sta 	zTemp2
.1b66	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b68	85 31		sta $31				sta 	zTemp2+1
.1b6a	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1b6c	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1b6e	b0 17		bcs $1b87			bcs 	_WSCopy
.1b70	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1b72	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b74	09 80		ora #$80			ora 	#$80
.1b76	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1b78					_WSConcrete:
.1b78	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1b7a	a8		tay				tay
.1b7b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b7d	20 0c 0b	jsr $0b0c			jsr 	StringConcrete
.1b80	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1b82	98		tya				tya
.1b83	a0 01		ldy #$01			ldy 	#1
.1b85	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b87					_WSCopy
.1b87	18		clc				clc  								; copy target+2 to zTemp2
.1b88	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b8a	69 02		adc #$02			adc 	#2
.1b8c	85 30		sta $30				sta 	zTemp2
.1b8e	a0 01		ldy #$01			ldy 	#1
.1b90	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b92	69 00		adc #$00			adc 	#0
.1b94	85 31		sta $31				sta 	zTemp2+1
.1b96	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1b98	85 2e		sta $2e				sta 	zTemp1
.1b9a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b9c	85 2f		sta $2f				sta 	zTemp1+1
.1b9e	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1ba0	a8		tay				tay
.1ba1					_WSCopyLoop:
.1ba1	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1ba3	91 30		sta ($30),y			sta 	(zTemp2),y
.1ba5	88		dey				dey
.1ba6	c0 ff		cpy #$ff			cpy 	#$FF
.1ba8	d0 f7		bne $1ba1			bne 	_WSCopyLoop
.1baa	ca		dex				dex
.1bab	7a		ply				ply
.1bac	60		rts				rts
.1bad					XCheckStop:
.1bad	20 e1 ff	jsr $ffe1			jsr 	$FFE1 						; check stop
.1bb0	f0 01		beq $1bb3			beq 	_XCSStop
.1bb2	60		rts				rts
.1bb3					_XCSStop:
.1bb3	4c 31 20	jmp $2031		jmp	ErrorV_break
.1bb6					CommandClose:
.1bb6	fa		plx				plx
.1bb7	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; channel to close
.1bba	cd 5f 04	cmp $045f			cmp 	currentChannel 				; is it the current channel
.1bbd	d0 03		bne $1bc2			bne 	_CCNotCurrent
.1bbf	9c 5f 04	stz $045f			stz 	currentChannel 				; effectively disables CMD
.1bc2					_CCNotCurrent:
.1bc2	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1bc5	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bc8					CommandExit:
.1bc8	fa		plx				plx
.1bc9	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1bcb	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1bce					CommandDebug:
.1bce	fa		plx				plx
>1bcf	db						.byte 	$DB 						; causes a break in the emulator
.1bd0	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bd3					XGetCharacterFromChannel:
.1bd3	da		phx				phx
.1bd4	5a		phy				phy
.1bd5	e0 00		cpx #$00			cpx 	#0 							; is it default
.1bd7	d0 05		bne $1bde			bne 	_XGetChannel
.1bd9	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1bdc	80 08		bra $1be6			bra 	_XGetChar
.1bde					_XGetChannel:
.1bde	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1be1	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1be4	d0 06		bne $1bec			bne 	_XGCError
.1be6					_XGetChar:
.1be6	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1be9	7a		ply				ply
.1bea	fa		plx				plx
.1beb	60		rts				rts
.1bec					_XGCError:
.1bec	4c 1b 20	jmp $201b		jmp	ErrorV_channel
.1bef					XGetHPos:
.1bef	da		phx				phx
.1bf0	5a		phy				phy
.1bf1	38		sec				sec
.1bf2	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1bf5	98		tya				tya
.1bf6	7a		ply				ply
.1bf7	fa		plx				plx
.1bf8	60		rts				rts
.1bf9					X16I2CPoke:
.1bf9	fa		plx				plx
.1bfa	5a		phy				phy
.1bfb	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; value
.1bfe	48		pha				pha
.1bff	ca		dex				dex
.1c00	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; register
.1c03	48		pha				pha
.1c04	ca		dex				dex
.1c05	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; device
.1c08	aa		tax				tax
.1c09	7a		ply				ply
.1c0a	68		pla				pla
.1c0b	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1c0e	b0 06		bcs $1c16			bcs 	X16I2CError
.1c10	7a		ply				ply
.1c11	a2 ff		ldx #$ff			ldx 	#$FF
.1c13	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c16					X16I2CError:
.1c16	4c 1b 20	jmp $201b		jmp	ErrorV_channel
.1c19					X16I2CPeek:
.1c19	fa		plx				plx
.1c1a	da		phx				phx
.1c1b	5a		phy				phy
.1c1c	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; register
.1c1f	48		pha				pha
.1c20	ca		dex				dex
.1c21	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; device
.1c24	aa		tax				tax 								; X device
.1c25	7a		ply				ply 								; Y register
.1c26	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1c29	b0 eb		bcs $1c16			bcs 	X16I2CError
.1c2b	7a		ply				ply 								; restore Y/X
.1c2c	fa		plx				plx
.1c2d	ca		dex				dex 								; drop TOS (register)
.1c2e	20 75 26	jsr $2675			jsr 	FloatSetByte 				; write read value to TOS.
.1c31	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c34					CommandXOpen:
.1c34	fa		plx				plx
.1c35	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1c37	85 2c		sta $2c				sta 	zTemp0
.1c39	aa		tax				tax
.1c3a	a5 4d		lda $4d				lda 	NSMantissa1+3
.1c3c	85 2d		sta $2d				sta 	zTemp0+1
.1c3e	a8		tay				tay
.1c3f	e8		inx				inx 								; XY points to first character
.1c40	d0 01		bne $1c43			bne 	_CONoCarry
.1c42	c8		iny				iny
.1c43					_CONoCarry:
.1c43	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c45	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c48	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c4a	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c4c	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c4e	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c51	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c54	b0 03		bcs $1c59			bcs 	_COError
.1c56	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c59					_COError:
.1c59	4c 1b 20	jmp $201b		jmp	ErrorV_channel
.1c5c					XPokeMemory:
.1c5c	86 2c		stx $2c				stx 	zTemp0
.1c5e	84 2d		sty $2d				sty 	zTemp0+1
.1c60	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c62	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c65	e0 ff		cpx #$ff			cpx 	#$FF
.1c67	f0 02		beq $1c6b			beq 	_XPMNoSwitch
.1c69	86 00		stx $00				stx 	SelectRAMBank
.1c6b					_XPMNoSwitch:
.1c6b	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1c6d	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1c6f					_XPMExit:
.1c6f	60		rts				rts
.1c70					XPeekMemory:
.1c70	86 2c		stx $2c				stx 	zTemp0
.1c72	84 2d		sty $2d				sty 	zTemp0+1
.1c74	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c76	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c79	e0 ff		cpx #$ff			cpx 	#$FF
.1c7b	f0 02		beq $1c7f			beq 	_XPMNoSwitch
.1c7d	86 00		stx $00				stx 	SelectRAMBank
.1c7f					_XPMNoSwitch:
.1c7f	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1c81	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1c83	60		rts				rts
.1c84					CommandBank:
.1c84	fa		plx				plx
.1c85	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1c87	8d 6d 05	sta $056d			sta 	ramBank 					; store & make current
.1c8a	85 00		sta $00				sta 	SelectRAMBank
.1c8c	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1c8e	c9 ff		cmp #$ff			cmp 	#$FF
.1c90	f0 03		beq $1c95			beq 	_CBNoUpdate
.1c92	8d 6e 05	sta $056e			sta 	romBank 					; this doesn't set the hardware page.
.1c95					_CBNoUpdate:
.1c95	a2 ff		ldx #$ff			ldx 	#$FF
.1c97	4c 4f 08	jmp $084f			jmp 	NextCommand
.056d					ramBank:
>056d							.fill 	1
.056e					romBank:
>056e							.fill 	1
.1c9a					XPrintCharacterToChannel:
.1c9a	48		pha				pha
.1c9b	da		phx				phx
.1c9c	5a		phy				phy
.1c9d	48		pha				pha  								; save char
.1c9e	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1ca0	d0 05		bne $1ca7			bne 	_XPCNotDefault
.1ca2	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1ca5	80 08		bra $1caf			bra 	_XPCSend
.1ca7					_XPCNotDefault:
.1ca7	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1caa	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1cad	d0 08		bne $1cb7			bne 	_XPCError
.1caf					_XPCSend:
.1caf	68		pla				pla 								; restore character
.1cb0	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1cb3	7a		ply				ply
.1cb4	fa		plx				plx
.1cb5	68		pla				pla
.1cb6	60		rts				rts
.1cb7					_XPCError:
.1cb7	4c 1b 20	jmp $201b		jmp	ErrorV_channel
.1cba					XReadClock:
.1cba	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1cbd	60		rts				rts
.1cbe					XWriteClock:
.1cbe	48		pha				pha
.1cbf	da		phx				phx
.1cc0	5a		phy				phy
.1cc1	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1cc4	7a		ply				ply
.1cc5	fa		plx				plx
.1cc6	68		pla				pla
.1cc7	60		rts				rts
.1cc8					CommandScreen:
.1cc8	fa		plx				plx
.1cc9	da		phx				phx
.1cca	5a		phy				phy
.1ccb	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1cce	18		clc				clc
.1ccf	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1cd2	7a		ply				ply
.1cd3	fa		plx				plx
.1cd4	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cd7					XCommandSleep:
.1cd7	fa		plx				plx
.1cd8	5a		phy				phy
.1cd9	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.1cdc	ca		dex				dex
.1cdd	20 ba 1c	jsr $1cba			jsr 	XReadClock 					; read clock to YXA
.1ce0	18		clc				clc 								; calculate end time in zTemp0
.1ce1	65 3e		adc $3e				adc 	NSMantissa0
.1ce3	85 2c		sta $2c				sta 	zTemp0
.1ce5	8a		txa				txa
.1ce6	65 4a		adc $4a				adc 	NSMantissa1
.1ce8	85 2d		sta $2d				sta 	zTemp0+1
.1cea					_XCWait:
.1cea	20 ba 1c	jsr $1cba			jsr 	XReadClock 					; and wait for it.
.1ced	c5 2c		cmp $2c				cmp 	zTemp0
.1cef	d0 f9		bne $1cea			bne 	_XCWait
.1cf1	e4 2d		cpx $2d				cpx 	zTemp0+1
.1cf3	d0 f5		bne $1cea			bne 	_XCWait
.1cf5	a2 ff		ldx #$ff			ldx 	#$FF
.1cf7	7a		ply				ply
.1cf8	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cfb					X16_Audio_FMINIT:
.1cfb	fa		plx				plx
.1cfc	5a		phy			phy
.1cfd	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d00	63 c0					.word	X16A_ym_init
>1d02	0a					.byte	X16_AudioCodeBank
.1d03	a2 ff		ldx #$ff		ldx	#$FF
.1d05	7a		ply			ply
.1d06	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d09					X16_Audio_FMNOTE:
.1d09	fa		plx				plx
.1d0a	5a		phy			phy
.1d0b	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d0e	18		clc			clc
.1d0f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d12	03 c0					.word	X16A_bas_fmnote
>1d14	0a					.byte	X16_AudioCodeBank
.1d15	a2 ff		ldx #$ff		ldx	#$FF
.1d17	7a		ply			ply
.1d18	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d1b					X16_Audio_FMDRUM:
.1d1b	fa		plx				plx
.1d1c	5a		phy			phy
.1d1d	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d20	18		clc			clc
.1d21	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d24	6f c0					.word	X16A_ym_playdrum
>1d26	0a					.byte	X16_AudioCodeBank
.1d27	a2 ff		ldx #$ff		ldx	#$FF
.1d29	7a		ply			ply
.1d2a	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d2d					X16_Audio_FMINST:
.1d2d	fa		plx				plx
.1d2e	5a		phy			phy
.1d2f	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d32	38		sec			sec
.1d33	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d36	69 c0					.word	X16A_ym_loadpatch
>1d38	0a					.byte	X16_AudioCodeBank
.1d39	a2 ff		ldx #$ff		ldx	#$FF
.1d3b	7a		ply			ply
.1d3c	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d3f					X16_Audio_FMVIB:
.1d3f	fa		plx				plx
.1d40	5a		phy			phy
.1d41	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d44	18		clc			clc
.1d45	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d48	09 c0					.word	X16A_bas_fmvib
>1d4a	0a					.byte	X16_AudioCodeBank
.1d4b	a2 ff		ldx #$ff		ldx	#$FF
.1d4d	7a		ply			ply
.1d4e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d51					X16_Audio_FMFREQ:
.1d51	fa		plx				plx
.1d52	5a		phy			phy
.1d53	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1d56	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d59	00 c0					.word	X16A_bas_fmfreq
>1d5b	0a					.byte	X16_AudioCodeBank
.1d5c	a2 ff		ldx #$ff		ldx	#$FF
.1d5e	7a		ply			ply
.1d5f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d62					X16_Audio_FMVOL:
.1d62	fa		plx				plx
.1d63	5a		phy			phy
.1d64	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d67	18		clc			clc
.1d68	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d6b	75 c0					.word	X16A_ym_setatten
>1d6d	0a					.byte	X16_AudioCodeBank
.1d6e	a2 ff		ldx #$ff		ldx	#$FF
.1d70	7a		ply			ply
.1d71	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d74					X16_Audio_FMPAN:
.1d74	fa		plx				plx
.1d75	5a		phy			phy
.1d76	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d79	18		clc			clc
.1d7a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d7d	7e c0					.word	X16A_ym_setpan
>1d7f	0a					.byte	X16_AudioCodeBank
.1d80	a2 ff		ldx #$ff		ldx	#$FF
.1d82	7a		ply			ply
.1d83	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d86					X16_Audio_FMPLAY:
.1d86	fa		plx				plx
.1d87	5a		phy			phy
.1d88	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1d8b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d8e	06 c0					.word	X16A_bas_fmplaystring
>1d90	0a					.byte	X16_AudioCodeBank
.1d91	a2 ff		ldx #$ff		ldx	#$FF
.1d93	7a		ply			ply
.1d94	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d97					X16_Audio_FMCHORD:
.1d97	fa		plx				plx
.1d98	5a		phy			phy
.1d99	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1d9c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d9f	8d c0					.word	X16A_bas_fmchordstring
>1da1	0a					.byte	X16_AudioCodeBank
.1da2	a2 ff		ldx #$ff		ldx	#$FF
.1da4	7a		ply			ply
.1da5	4c 4f 08	jmp $084f			jmp 	NextCommand
.1da8					X16_Audio_FMPOKE:
.1da8	fa		plx				plx
.1da9	5a		phy			phy
.1daa	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1dad	18		clc			clc
.1dae	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1db1	8a c0					.word	X16A_ym_write
>1db3	0a					.byte	X16_AudioCodeBank
.1db4	a2 ff		ldx #$ff		ldx	#$FF
.1db6	7a		ply			ply
.1db7	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dba					X16_Audio_PSGINIT:
.1dba	fa		plx				plx
.1dbb	5a		phy			phy
.1dbc	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dbf	4b c0					.word	X16A_psg_init
>1dc1	0a					.byte	X16_AudioCodeBank
.1dc2	a2 ff		ldx #$ff		ldx	#$FF
.1dc4	7a		ply			ply
.1dc5	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dc8					X16_Audio_PSGNOTE:
.1dc8	fa		plx				plx
.1dc9	5a		phy			phy
.1dca	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1dcd	18		clc			clc
.1dce	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dd1	12 c0					.word	X16A_bas_psgnote
>1dd3	0a					.byte	X16_AudioCodeBank
.1dd4	a2 ff		ldx #$ff		ldx	#$FF
.1dd6	7a		ply			ply
.1dd7	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dda					X16_Audio_PSGVOL:
.1dda	fa		plx				plx
.1ddb	5a		phy			phy
.1ddc	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1ddf	18		clc			clc
.1de0	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1de3	54 c0					.word	X16A_psg_setatten
>1de5	0a					.byte	X16_AudioCodeBank
.1de6	a2 ff		ldx #$ff		ldx	#$FF
.1de8	7a		ply			ply
.1de9	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dec					X16_Audio_PSGWAV:
.1dec	fa		plx				plx
.1ded	5a		phy			phy
.1dee	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1df1	18		clc			clc
.1df2	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1df5	15 c0					.word	X16A_bas_psgwav
>1df7	0a					.byte	X16_AudioCodeBank
.1df8	a2 ff		ldx #$ff		ldx	#$FF
.1dfa	7a		ply			ply
.1dfb	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dfe					X16_Audio_PSGFREQ:
.1dfe	fa		plx				plx
.1dff	5a		phy			phy
.1e00	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1e03	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e06	0f c0					.word	X16A_bas_psgfreq
>1e08	0a					.byte	X16_AudioCodeBank
.1e09	a2 ff		ldx #$ff		ldx	#$FF
.1e0b	7a		ply			ply
.1e0c	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e0f					X16_Audio_PSGPAN:
.1e0f	fa		plx				plx
.1e10	5a		phy			phy
.1e11	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e14	18		clc			clc
.1e15	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e18	5a c0					.word	X16A_psg_setpan
>1e1a	0a					.byte	X16_AudioCodeBank
.1e1b	a2 ff		ldx #$ff		ldx	#$FF
.1e1d	7a		ply			ply
.1e1e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e21					X16_Audio_PSGPLAY:
.1e21	fa		plx				plx
.1e22	5a		phy			phy
.1e23	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e26	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e29	18 c0					.word	X16A_bas_psgplaystring
>1e2b	0a					.byte	X16_AudioCodeBank
.1e2c	a2 ff		ldx #$ff		ldx	#$FF
.1e2e	7a		ply			ply
.1e2f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e32					X16_Audio_PSGCHORD:
.1e32	fa		plx				plx
.1e33	5a		phy			phy
.1e34	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e37	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e3a	90 c0					.word	X16A_bas_psgchordstring
>1e3c	0a					.byte	X16_AudioCodeBank
.1e3d	a2 ff		ldx #$ff		ldx	#$FF
.1e3f	7a		ply			ply
.1e40	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e43					CommandCls:
.1e43	fa		plx				plx
.1e44	a9 93		lda #$93			lda 	#147
.1e46	20 9a 1c	jsr $1c9a			jsr 	XPrintCharacterToChannel
.1e49	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e4c					CommandLocate:
.1e4c	fa		plx				plx
.1e4d	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.1e50	ca		dex				dex
.1e51	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.1e54	ca		dex				dex
.1e55	a9 13		lda #$13			lda 	#$13 						; home.
.1e57	20 9a 1c	jsr $1c9a			jsr 	XPrintCharacterToChannel
.1e5a	a9 1d		lda #$1d			lda 	#$1D 						; do cursor rights
.1e5c	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1e5e	20 6b 1e	jsr $1e6b			jsr 	_CLOutputXA
.1e61	a9 11		lda #$11			lda 	#$11 						; do cursor downs.
.1e63	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e65	20 6b 1e	jsr $1e6b			jsr 	_CLOutputXA
.1e68	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e6b					_CLOutputXA:
.1e6b	ca		dex				dex
.1e6c	f0 07		beq $1e75			beq 	_CLOExit
.1e6e	30 05		bmi $1e75			bmi 	_CLOExit
.1e70	20 9a 1c	jsr $1c9a			jsr 	XPrintCharacterToChannel
.1e73	80 f6		bra $1e6b			bra 	_CLOutputXA
.1e75					_CLOExit:
.1e75	60		rts				rts
.1e76					CommandColor:
.1e76	fa		plx				plx
.1e77	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.1e7a	ca		dex				dex
.1e7b	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.1e7e	ca		dex				dex
.1e7f	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1e81	c9 ff		cmp #$ff			cmp 	#$FF
.1e83	f0 08		beq $1e8d			beq 	_CCNoBGR 					; if so, change background
.1e85	20 95 1e	jsr $1e95			jsr 	_CCSetColour
.1e88	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1e8a	20 9a 1c	jsr $1c9a			jsr 	XPrintCharacterToChannel
.1e8d					_CCNoBGR:
.1e8d	a5 3e		lda $3e				lda 	NSMantissa0
.1e8f	20 95 1e	jsr $1e95			jsr 	_CCSetColour
.1e92	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e95					_CCSetColour:
.1e95	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1e97	aa		tax				tax
.1e98	bd 9f 1e	lda $1e9f,x			lda 	_CCCommandTable,x
.1e9b	20 9a 1c	jsr $1c9a			jsr 	XPrintCharacterToChannel
.1e9e	60		rts				rts
.1e9f					_CCCommandTable:
>1e9f	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1ea7	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1eaf					CommandVPOKE:
.1eaf	fa		plx				plx
.1eb0	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; poke value
.1eb3	48		pha				pha
.1eb4	ca		dex				dex
.1eb5	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.1eb8	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1eba	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1ebd	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ebf	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ec2	ca		dex				dex
.1ec3	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.1ec6	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1ec9	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1ecc	ca		dex				dex
.1ecd	68		pla				pla 								; poke value back
.1ece	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1ed1	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ed4					CommandVPEEK:
.1ed4	fa		plx				plx
.1ed5	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.1ed8	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1eda	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1edd	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1edf	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ee2	ca		dex				dex
.1ee3	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.1ee6	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1ee9	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1eec	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1eef	20 75 26	jsr $2675			jsr 	FloatSetByte 				; return as byte
.1ef2	4c 4f 08	jmp $084f			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ff					C64_PI                   = $ff ; $ff pi
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ceb7					C64_BANNER               = $ceb7 ; $ceb7 banner
=$ceb8					C64_EXEC                 = $ceb8 ; $ceb8 exec
=$ceb9					C64_TILE                 = $ceb9 ; $ceb9 tile
=$ceba					C64_EDIT                 = $ceba ; $ceba edit
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$cedb					C64_MWHEEL               = $cedb ; $cedb mwheel
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$cb					PCD_ENDCOMMAND = $cb
=$cb					PCD_STARTSYSTEM = $cb
=$d6					PCD_ENDSYSTEM = $d6
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_PI               = $ac ; pi
=$ad					PCD_POKE             = $ad ; poke
=$ae					PCD_POS              = $ae ; pos
=$af					PCD_GETCHANNEL       = $af ; getchannel
=$b0					PCD_SETCHANNEL       = $b0 ; setchannel
=$b1					PCD_PRINTCMD_N       = $b1 ; print.n
=$b2					PCD_PRINTCMD_S       = $b2 ; print.s
=$b3					PCD_READ             = $b3 ; read
=$b4					PCD_READDOLLAR       = $b4 ; read$
=$b5					PCD_RND              = $b5 ; rnd
=$b6					PCD_CONCAT           = $b6 ; concat
=$b7					PCD_SGN              = $b7 ; sgn
=$b8					PCD_PRINTCMD_TAB     = $b8 ; print.tab
=$b9					PCD_PRINTCMD_POS     = $b9 ; print.pos
=$ba					PCD_PRINTCMD_SPC     = $ba ; print.spc
=$bb					PCD_STRDOLLAR        = $bb ; str$
=$bc					PCD_LEFTDOLLAR       = $bc ; left$
=$bd					PCD_RIGHTDOLLAR      = $bd ; right$
=$be					PCD_MIDDOLLAR        = $be ; mid$
=$bf					PCD_SWAP             = $bf ; swap
=$c0					PCD_TI               = $c0 ; ti
=$c1					PCD_TIDOLLAR         = $c1 ; ti$
=$c2					PCD_USR              = $c2 ; usr
=$c3					PCD_VAL              = $c3 ; val
=$c4					PCD_CLOSE            = $c4 ; close
=$c5					PCD_EXIT             = $c5 ; exit
=$c6					PCD_DEBUG            = $c6 ; debug
=$c7					PCD_OPEN             = $c7 ; open
=$c8					PCD_SCREEN           = $c8 ; screen
=$c9					PCD_VPOKE            = $c9 ; vpoke
=$ca					PCD_VPEEK            = $ca ; vpeek
=$cb					PCD_CMD_SHIFT        = $cb ; .shift
=$cc					PCD_CMD_BYTE         = $cc ; .byte
=$cd					PCD_CMD_WORD         = $cd ; .word
=$ce					PCD_CMD_FLOAT        = $ce ; .float
=$cf					PCD_CMD_STRING       = $cf ; .string
=$d0					PCD_CMD_DATA         = $d0 ; .data
=$d1					PCD_CMD_GOTO         = $d1 ; .goto
=$d2					PCD_CMD_GOSUB        = $d2 ; .gosub
=$d3					PCD_CMD_GOTOCMD_Z    = $d3 ; .goto.z
=$d4					PCD_CMD_GOTOCMD_NZ   = $d4 ; .goto.nz
=$d5					PCD_CMD_VARSPACE     = $d5 ; .varspace
=$cb80					PCD_CLR              = $cb80 ; clr
=$cb81					PCD_DIM              = $cb81 ; dim
=$cb82					PCD_END              = $cb82 ; end
=$cb83					PCD_JOY              = $cb83 ; joy
=$cb84					PCD_INT              = $cb84 ; int
=$cb85					PCD_SQR              = $cb85 ; sqr
=$cb86					PCD_LOG              = $cb86 ; log
=$cb87					PCD_EXP              = $cb87 ; exp
=$cb88					PCD_COS              = $cb88 ; cos
=$cb89					PCD_SIN              = $cb89 ; sin
=$cb8a					PCD_TAN              = $cb8a ; tan
=$cb8b					PCD_ATN              = $cb8b ; atn
=$cb8c					PCD_MOUSE            = $cb8c ; mouse
=$cb8d					PCD_MB               = $cb8d ; mb
=$cb8e					PCD_MX               = $cb8e ; mx
=$cb8f					PCD_MY               = $cb8f ; my
=$cb90					PCD_RESTORE          = $cb90 ; restore
=$cb91					PCD_STOP             = $cb91 ; stop
=$cb92					PCD_SYS              = $cb92 ; sys
=$cb93					PCD_TIDOLLARCMD_WRITE = $cb93 ; ti$.write
=$cb94					PCD_WAIT             = $cb94 ; wait
=$cb95					PCD_I2CPOKE          = $cb95 ; i2cpoke
=$cb96					PCD_I2CPEEK          = $cb96 ; i2cpeek
=$cb97					PCD_BANK             = $cb97 ; bank
=$cb98					PCD_SLEEP            = $cb98 ; sleep
=$cb99					PCD_FMINIT           = $cb99 ; fminit
=$cb9a					PCD_FMNOTE           = $cb9a ; fmnote
=$cb9b					PCD_FMDRUM           = $cb9b ; fmdrum
=$cb9c					PCD_FMINST           = $cb9c ; fminst
=$cb9d					PCD_FMVIB            = $cb9d ; fmvib
=$cb9e					PCD_FMFREQ           = $cb9e ; fmfreq
=$cb9f					PCD_FMVOL            = $cb9f ; fmvol
=$cba0					PCD_FMPAN            = $cba0 ; fmpan
=$cba1					PCD_FMPLAY           = $cba1 ; fmplay
=$cba2					PCD_FMCHORD          = $cba2 ; fmchord
=$cba3					PCD_FMPOKE           = $cba3 ; fmpoke
=$cba4					PCD_PSGINIT          = $cba4 ; psginit
=$cba5					PCD_PSGNOTE          = $cba5 ; psgnote
=$cba6					PCD_PSGVOL           = $cba6 ; psgvol
=$cba7					PCD_PSGWAV           = $cba7 ; psgwav
=$cba8					PCD_PSGFREQ          = $cba8 ; psgfreq
=$cba9					PCD_PSGPAN           = $cba9 ; psgpan
=$cbaa					PCD_PSGPLAY          = $cbaa ; psgplay
=$cbab					PCD_PSGCHORD         = $cbab ; psgchord
=$cbac					PCD_CLS              = $cbac ; cls
=$cbad					PCD_LOCATE           = $cbad ; locate
=$cbae					PCD_COLOR            = $cbae ; color
.1ef5					SetErrorHandler:
.1ef5	8c 70 05	sty $0570			sty 	ErrorHandlerVector+1
.1ef8	8e 6f 05	stx $056f			stx 	ErrorHandlerVector
.1efb	60		rts				rts
.1efc					CallErrorHandler:
.1efc	6c 6f 05	jmp ($056f)			jmp 	(ErrorHandlerVector)
.056f					ErrorHandlerVector:
>056f							.fill 	2
.1eff					ErrorV_range:
.1eff	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f02	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f0a	41 4e 47 45 00
.1f0f					ErrorV_value:
.1f0f	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f12	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f1a	45 00
.1f1c					ErrorV_syntax:
.1f1c	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f1f	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f27	52 52 4f 52 00
.1f2c					ErrorV_type:
.1f2c	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f2f	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f37	4d 41 54 43 48 00
.1f3d					ErrorV_unimplemented:
.1f3d	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f40	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f48	45 4d 45 4e 54 45 44 00
.1f50					ErrorV_assert:
.1f50	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f53	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f5b	41 49 4c 00
.1f5f					ErrorV_line:
.1f5f	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f62	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f6a	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f76					ErrorV_internal:
.1f76	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f79	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f81	20 45 52 52 4f 52 00
.1f88					ErrorV_divzero:
.1f88	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f8b	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1f93	59 20 5a 45 52 4f 00
.1f9a					ErrorV_structure:
.1f9a	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f9d	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fa5	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fb1					ErrorV_stop:
.1fb1	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1fb4	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fbc	53 54 4f 50 50 45 44 00
.1fc4					ErrorV_data:
.1fc4	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1fc7	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fcf	41 54 41 00
.1fd3					ErrorV_undeclared:
.1fd3	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1fd6	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1fde	41 52 52 41 59 00
.1fe4					ErrorV_redefine:
.1fe4	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1fe7	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1fef	44 45 46 49 4e 45 44 00
.1ff7					ErrorV_index:
.1ff7	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1ffa	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2002	59 20 49 4e 44 45 58 00
.200a					ErrorV_memory:
.200a	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>200d	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2015	45 4d 4f 52 59 00
.201b					ErrorV_channel:
.201b	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>201e	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2026	54 50 55 54 20 45 52 52 4f 52 00
.2031					ErrorV_break:
.2031	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>2034	42 52 45 41 4b 20 50 52			.text	"BREAK PRESSED",0
>203c	45 53 53 45 44 00
.2042					MoveObjectForward:
.2042	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.2044	c9 ff		cmp #$ff			cmp 	#$FF
.2046	f0 36		beq $207e			beq 	_MOFEnd
.2048	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.204a	90 24		bcc $2070			bcc 	_MOFAdvance1 				; forward 1
.204c	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.204e	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2050	90 20		bcc $2072			bcc 	_MOFAdvanceY
.2052	c9 cb		cmp #$cb			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2054	90 1a		bcc $2070			bcc 	_MOFAdvance1 				; forward 1
.2056	a8		tay				tay 								; read the size.
.2057	b9 bb 1f	lda $1fbb,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.205a	a8		tay				tay
.205b	c8		iny				iny 								; add 1 for the system token.
.205c	d0 14		bne $2072			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.205e	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2060	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2062	a8		tay				tay 								; into Y.
.2063	18		clc				clc
.2064	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.2066	69 02		adc #$02			adc 	#2
.2068	85 2a		sta $2a				sta 	objPtr
.206a	90 02		bcc $206e			bcc 	_MOFNoCarry1
.206c	e6 2b		inc $2b				inc 	objPtr+1
.206e					_MOFNoCarry1:
.206e	80 02		bra $2072			bra 	_MOFAdvanceY
.2070					_MOFAdvance1:
.2070	a0 01		ldy #$01			ldy 	#1
.2072					_MOFAdvanceY:
.2072	98		tya				tya 								; add Y to objPtr
.2073	18		clc				clc
.2074	65 2a		adc $2a				adc 	objPtr
.2076	85 2a		sta $2a				sta 	objPtr
.2078	90 02		bcc $207c			bcc 	_MOFNoCarry2
.207a	e6 2b		inc $2b				inc 	objPtr+1
.207c					_MOFNoCarry2:
.207c	18		clc				clc 								; not completed.
.207d	60		rts				rts
.207e					_MOFEnd:
.207e	e6 2a		inc $2a				inc 	objPtr
.2080	d0 02		bne $2084			bne 	_MOFENoCarry
.2082	e6 2b		inc $2b				inc 	objPtr+1
.2084					_MOFENoCarry:
.2084	38		sec				sec
.2085	60		rts				rts
.2086					MOFSizeTable:
>2086	01					.byte	1         	; $cb .shift
>2087	01					.byte	1         	; $cc .byte
>2088	02					.byte	2         	; $cd .word
>2089	05					.byte	5         	; $ce .float
>208a	ff					.byte	255       	; $cf .string
>208b	ff					.byte	255       	; $d0 .data
>208c	02					.byte	2         	; $d1 .goto
>208d	02					.byte	2         	; $d2 .gosub
>208e	02					.byte	2         	; $d3 .goto.z
>208f	02					.byte	2         	; $d4 .goto.nz
>2090	02					.byte	2         	; $d5 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0571					numberBuffer:
>0571							.fill 	34
.2091					FloatSubtract:
.2091	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.2093	49 80		eor #$80			eor 	#$80
.2095	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.2097					FloatAdd:
.2097	ca		dex				dex
.2098	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.209a	15 6f		ora $6f,x			ora 	NSExponent+1,x
.209c	15 62		ora $62,x			ora 	NSMantissa3,x
.209e	15 63		ora $63,x			ora 	NSMantissa3+1,x
.20a0	d0 04		bne $20a6			bne 	_FAUseFloat
.20a2	20 33 24	jsr $2433			jsr 	FloatInt32Add 				; use the int32 one.
.20a5	60		rts				rts
.20a6					_FAUseFloat:
.20a6	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise S[X]
.20a9	f0 51		beq $20fc			beq 	_FAReturn1
.20ab	e8		inx				inx 								; normalise S[X+1]
.20ac	20 c8 23	jsr $23c8			jsr 	FloatNormalise
.20af	ca		dex				dex
.20b0	c9 00		cmp #$00			cmp 	#0
.20b2	f0 60		beq $2114			beq 	_FAExit 					; if so, just return A
.20b4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20b6	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20b8	f0 18		beq $20d2			beq 	_FAExponentsEqual
.20ba	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20bc	a8		tay				tay
.20bd	38		sec				sec 								; do a signed comparison of the exponents.
.20be	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20c0	50 02		bvc $20c4			bvc 	_FANoSignedChange
.20c2	49 80		eor #$80			eor 	#$80
.20c4					_FANoSignedChange:
.20c4	29 80		and #$80			and 	#$80
.20c6	10 02		bpl $20ca			bpl 	_FAHaveMax
.20c8	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.20ca					_FAHaveMax:
.20ca	20 15 21	jsr $2115			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20cd	e8		inx				inx
.20ce	20 15 21	jsr $2115			jsr 	_FAShiftToExponent
.20d1	ca		dex				dex
.20d2					_FAExponentsEqual:
.20d2	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.20d4	55 33		eor $33,x			eor 	NSStatus+1,x
.20d6	30 0e		bmi $20e6			bmi 	_FADifferentSigns
.20d8	20 ff 23	jsr $23ff			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20db	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20dd	10 35		bpl $2114			bpl 	_FAExit 					; if no, we are done.
.20df	20 8c 26	jsr $268c			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20e2	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.20e4	80 2e		bra $2114			bra 	_FAExit
.20e6					_FADifferentSigns:
.20e6	20 19 24	jsr $2419			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20e9	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.20eb	10 06		bpl $20f3			bpl 	_FACheckZero 				; if no, check for -0
.20ed	20 35 26	jsr $2635			jsr 	FloatNegate 					; netate result
.20f0	20 3c 26	jsr $263c			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20f3					_FACheckZero:
.20f3	20 95 26	jsr $2695			jsr 	FloatIsZero	 				; check for -0
.20f6	d0 1c		bne $2114			bne 	_FAExit
.20f8	74 32		stz $32,x			stz 	NSStatus,x
.20fa	80 18		bra $2114			bra 	_FAExit
.20fc					_FAReturn1:
.20fc	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20fe	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2100	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2102	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2104	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.2106	95 56		sta $56,x			sta 	NSMantissa2,x
.2108	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.210a	95 62		sta $62,x			sta 	NSMantissa3,x
.210c	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.210e	95 6e		sta $6e,x			sta 	NSExponent,x
.2110	b5 33		lda $33,x			lda 	NSStatus+1,x
.2112	95 32		sta $32,x			sta 	NSStatus,x
.2114					_FAExit:
.2114	60		rts				rts
.2115					_FAShiftToExponent:
.2115					_FAShiftToExponent2:
.2115	98		tya				tya 								; compare Y to exponent
.2116	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2118	f0 07		beq $2121			beq 	_FASEExit 					; exit if so.
.211a	20 8c 26	jsr $268c			jsr 	FloatShiftRight	 			; shift the mantissa right
.211d	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.211f	80 f4		bra $2115			bra 	_FAShiftToExponent2
.2121					_FASEExit:
.2121	60		rts				rts
.2122					CompareEqual:
.2122	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2124	d0 09		bne $212f			bne 	ReturnFalse
.2126					ReturnTrue:
.2126	a9 01		lda #$01			lda 	#1
.2128	95 3e		sta $3e,x			sta 	NSMantissa0,x
.212a	a9 80		lda #$80			lda 	#$80
.212c	95 32		sta $32,x			sta 	NSStatus,x
.212e	60		rts				rts
.212f					ReturnFalse:
.212f	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2131	60		rts				rts
.2132					CompareNotEqual:
.2132	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2134	d0 f0		bne $2126			bne 	ReturnTrue
.2136	80 f7		bra $212f			bra 	ReturnFalse
.2138					CompareLess:
.2138	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.213a	c9 ff		cmp #$ff			cmp 	#$FF
.213c	f0 e8		beq $2126			beq 	ReturnTrue
.213e	80 ef		bra $212f			bra 	ReturnFalse
.2140					CompareGreater:
.2140	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2142	c9 01		cmp #$01			cmp 	#$01
.2144	f0 e0		beq $2126			beq 	ReturnTrue
.2146	80 e7		bra $212f			bra 	ReturnFalse
.2148					CompareLessEqual:
.2148	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.214a	c9 01		cmp #$01			cmp 	#$01
.214c	d0 d8		bne $2126			bne 	ReturnTrue
.214e	80 df		bra $212f			bra 	ReturnFalse
.2150					CompareGreaterEqual:
.2150	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2152	c9 ff		cmp #$ff			cmp 	#$FF
.2154	d0 d0		bne $2126			bne 	ReturnTrue
.2156	80 d7		bra $212f			bra 	ReturnFalse
.2158					FloatCompare:
.2158	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.215a	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.215c	48		pha				pha
.215d	20 91 20	jsr $2091			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2160	68		pla				pla
.2161	d0 0c		bne $216f			bne 	_FCCompareFloat
.2163	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2165	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2167	15 56		ora $56,x			ora 	NSMantissa2,x
.2169	15 62		ora $62,x			ora 	NSMantissa3,x
.216b	f0 14		beq $2181			beq 	_FCExit 					; if zero, return zero
.216d	80 0a		bra $2179			bra 	_FCSign
.216f					_FCCompareFloat:
.216f	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2171	29 f0		and #$f0			and 	#$F0
.2173	15 56		ora $56,x			ora 	NSMantissa2,x
.2175	15 62		ora $62,x			ora 	NSMantissa3,x
.2177	f0 08		beq $2181			beq 	_FCExit 					; zero, so approximately identical
.2179					_FCSign:
.2179	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.217b	34 32		bit $32,x			bit 	NSStatus,x
.217d	10 02		bpl $2181			bpl 	_FCExit
.217f					_FCNegative:
.217f	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2181					_FCExit:
.2181	20 75 26	jsr $2675			jsr 	FloatSetByte 				; set the result 255,0,1
.2184	60		rts				rts
.2185					FloatScalarTable:
>2185	66 66 66 66				.dword $66666666 ; 0.1
>2189	de					.byte $de
>218a	1f 85 eb 51				.dword $51eb851f ; 0.01
>218e	db					.byte $db
>218f	4c 37 89 41				.dword $4189374c ; 0.001
>2193	d8					.byte $d8
>2194	ac 8b db 68				.dword $68db8bac ; 0.0001
>2198	d4					.byte $d4
>2199	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>219d	d1					.byte $d1
>219e	83 de 1b 43				.dword $431bde83 ; 1e-06
>21a2	ce					.byte $ce
>21a3	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21a7	ca					.byte $ca
>21a8	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21ac	c7					.byte $c7
>21ad	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21b1	c4					.byte $c4
>21b2	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21b6	c0					.byte $c0
>21b7	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21bb	bd					.byte $bd
.21bc					FloatDivide:
.21bc	48		pha				pha
.21bd	20 c8 23	jsr $23c8			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21c0	ca		dex				dex
.21c1	c9 00		cmp #$00			cmp 	#0
.21c3	f0 1e		beq $21e3			beq 	_FDZero
.21c5	20 c8 23	jsr $23c8			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21c8	f0 16		beq $21e0			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21ca	20 2b 22	jsr $222b			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21cd	20 f8 21	jsr $21f8			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21d0	20 c8 23	jsr $23c8			jsr		FloatNormalise 				; renormalise
.21d3	20 be 23	jsr $23be			jsr 	FloatCalculateSign 			; calculate result sign
.21d6	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.21d8	38		sec				sec
.21d9	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.21db	38		sec				sec
.21dc	e9 1e		sbc #$1e			sbc 	#30
.21de	95 6e		sta $6e,x			sta 	NSExponent,x
.21e0					_FDExit:
.21e0	68		pla				pla
.21e1	18		clc				clc
.21e2	60		rts				rts
.21e3					_FDZero:
.21e3	68		pla				pla
.21e4	38		sec				sec
.21e5	60		rts				rts
.21e6					DivideInt32:
.21e6	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart 			; make both integers
.21e9	ca		dex				dex
.21ea	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.21ed	20 09 22	jsr $2209			jsr 	Int32Divide 				; divide
.21f0	20 f8 21	jsr $21f8			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21f3	20 be 23	jsr $23be			jsr 	FloatCalculateSign 			; calculate result sign
.21f6	18		clc				clc
.21f7	60		rts				rts
.21f8					NSMCopyPlusTwoToZero:
.21f8	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21fa	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21fc	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21fe	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2200	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.2202	95 56		sta $56,x			sta 	NSMantissa2,x
.2204	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.2206	95 62		sta $62,x			sta 	NSMantissa3,x
.2208	60		rts				rts
.2209					Int32Divide:
.2209	48		pha				pha 								; save AXY
.220a	5a		phy				phy
.220b	20 56 26	jsr $2656			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.220e	20 6f 26	jsr $266f			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2211	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2213					_I32DivideLoop:
.2213	e8		inx				inx
.2214	e8		inx				inx
.2215	20 82 26	jsr $2682			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2218	ca		dex				dex
.2219	ca		dex				dex
.221a	20 83 26	jsr $2683			jsr 	FloatRotateLeft
.221d	20 49 22	jsr $2249			jsr 	FloatDivideCheck 			; check if subtract possible
.2220	90 02		bcc $2224			bcc 	_I32DivideNoCarryIn
.2222	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2224					_I32DivideNoCarryIn:
.2224	88		dey				dey 								; loop round till division completed.
.2225	d0 ec		bne $2213			bne 	_I32DivideLoop
.2227	7a		ply				ply 								; restore AXY and exit
.2228	68		pla				pla
.2229	18		clc				clc
.222a	60		rts				rts
.222b					Int32ShiftDivide:
.222b	48		pha				pha 								; save AY
.222c	5a		phy				phy
.222d	e8		inx				inx 								; clear S[X+2]
.222e	e8		inx				inx
.222f	20 73 26	jsr $2673			jsr 	FloatSetZero
.2232	ca		dex				dex
.2233	ca		dex				dex
.2234	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2236					_I32SDLoop:
.2236	20 49 22	jsr $2249			jsr 	FloatDivideCheck 			; check if subtract possible
.2239	e8		inx				inx
.223a	e8		inx				inx
.223b	20 83 26	jsr $2683			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.223e	ca		dex				dex
.223f	ca		dex				dex
.2240	20 83 26	jsr $2683			jsr 	FloatRotateLeft
.2243	88		dey				dey 	 							; do 31 times
.2244	d0 f0		bne $2236			bne 	_I32SDLoop
.2246	7a		ply				ply 								; restore AY and exit
.2247	68		pla				pla
.2248	60		rts				rts
.2249					FloatDivideCheck:
.2249	20 19 24	jsr $2419			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.224c	b0 04		bcs $2252			bcs 	_DCSExit 					; if carry set, then could do, exit
.224e	20 ff 23	jsr $23ff			jsr 	FloatAddTopTwoStack 		; add it back in
.2251	18		clc				clc 								; and return False
.2252					_DCSExit:
.2252	60		rts				rts
.2253					FloatFractionalPart:
.2253	5a		phy				phy
.2254	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.2256	29 7f		and #$7f			and 	#$7F
.2258	95 32		sta $32,x			sta 	NSStatus,x
.225a	20 c8 23	jsr $23c8			jsr 	FloatNormalise
.225d	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.225f	38		sec				sec
.2260	e9 e0		sbc #$e0			sbc 	#$E0
.2262	90 29		bcc $228d			bcc 	_FFPExit 					; already fractional
.2264	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2266	b0 22		bcs $228a			bcs 	_FFPZero
.2268	a8		tay				tay 								; put count to do in Y
.2269	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.226b	20 92 22	jsr $2292			jsr 	_FFPPartial
.226e	95 62		sta $62,x			sta 	NSMantissa3,x
.2270	b5 56		lda $56,x			lda 	NSMantissa2,x
.2272	20 92 22	jsr $2292			jsr 	_FFPPartial
.2275	95 56		sta $56,x			sta 	NSMantissa2,x
.2277	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2279	20 92 22	jsr $2292			jsr 	_FFPPartial
.227c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.227e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2280	20 92 22	jsr $2292			jsr 	_FFPPartial
.2283	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2285	20 95 26	jsr $2695			jsr 	FloatIsZero 					; zeroed check.
.2288	d0 03		bne $228d			bne 	_FFPExit
.228a					_FFPZero:
.228a	20 73 26	jsr $2673			jsr 	FloatSetZero
.228d					_FFPExit:
.228d	20 c8 23	jsr $23c8			jsr 	FloatNormalise
.2290	7a		ply				ply
.2291	60		rts				rts
.2292					_FFPPartial:
.2292	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2294	f0 17		beq $22ad			beq 	_FFFPPExit
.2296	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.2298	b0 0c		bcs $22a6			bcs 	_FFFPPWholeByte
.229a	5a		phy				phy
.229b					_FFFPPLeft:
.229b	0a		asl a				asl 	a
.229c	88		dey				dey
.229d	d0 fc		bne $229b			bne 	_FFFPPLeft
.229f	7a		ply				ply
.22a0					_FFFPPRight:
.22a0	4a		lsr a				lsr 	a
.22a1	88		dey				dey
.22a2	d0 fc		bne $22a0			bne 	_FFFPPRight
.22a4	80 07		bra $22ad			bra 	_FFFPPExit
.22a6					_FFFPPWholeByte:
.22a6	98		tya				tya 								; subtract 8 from count
.22a7	38		sec				sec
.22a8	e9 08		sbc #$08			sbc 	#8
.22aa	a8		tay				tay
.22ab	a9 00		lda #$00			lda 	#0 							; and clear all
.22ad					_FFFPPExit:
.22ad	60		rts				rts
.22ae					FloatIntegerPart:
.22ae	48		pha				pha
.22af	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22b1	f0 1d		beq $22d0			beq 	_FIPExit 					; if so do nothing
.22b3	20 95 26	jsr $2695			jsr 	FloatIsZero 				; is it zero ?
.22b6	f0 15		beq $22cd			beq 	_FIPZero 					; if so return zero.
.22b8	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise
.22bb	f0 10		beq $22cd			beq 	_FIPZero 					; normalised to zero, exit zero
.22bd					_FIPShift:
.22bd	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22bf	10 07		bpl $22c8			bpl 	_FIPCheckZero
.22c1	20 8c 26	jsr $268c			jsr 	FloatShiftRight 			; shift mantissa right
.22c4	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22c6	80 f5		bra $22bd			bra 	_FIPShift
.22c8					_FIPCheckZero:
.22c8	20 95 26	jsr $2695			jsr 	FloatIsZero 				; avoid -0 problem
.22cb	d0 03		bne $22d0			bne 	_FIPExit 					; set to zero if mantissa zero.
.22cd					_FIPZero:
.22cd	20 73 26	jsr $2673			jsr 	FloatSetZero
.22d0					_FIPExit:
.22d0	68		pla				pla
.22d1	60		rts				rts
.22d2					FloatIntegerPartDown:
.22d2	48		pha				pha
.22d3	5a		phy				phy
.22d4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22d6	f0 36		beq $230e			beq 	_FIPExit 					; if so do nothing
.22d8	20 95 26	jsr $2695			jsr 	FloatIsZero 				; is it zero ?
.22db	f0 2e		beq $230b			beq 	_FIPZero 					; if so return zero.
.22dd	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise
.22e0	f0 29		beq $230b			beq 	_FIPZero 					; normalised to zero, exit zero
.22e2	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22e4					_FIPShift:
.22e4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22e6	10 0a		bpl $22f2			bpl 	_FIPCheckDown
.22e8	20 8c 26	jsr $268c			jsr 	FloatShiftRight 			; shift mantissa right
.22eb	90 01		bcc $22ee			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22ed	c8		iny				iny
.22ee					_FIPNoFrac:
.22ee	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22f0	80 f2		bra $22e4			bra 	_FIPShift
.22f2					_FIPCheckDown:
.22f2	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22f4	f0 10		beq $2306			beq 	_FIPCheckZero
.22f6	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22f8	10 0c		bpl $2306			bpl 	_FIPCheckZero
.22fa	e8		inx				inx 								; -ve so round *down*.
.22fb	a9 01		lda #$01			lda 	#1
.22fd	20 75 26	jsr $2675			jsr 	FloatSetByte
.2300	20 35 26	jsr $2635			jsr 	FloatNegate
.2303	20 97 20	jsr $2097			jsr 	FloatAdd
.2306					_FIPCheckZero:
.2306	20 95 26	jsr $2695			jsr 	FloatIsZero 				; avoid -0 problem
.2309	d0 03		bne $230e			bne 	_FIPExit 					; set to zero if mantissa zero.
.230b					_FIPZero:
.230b	20 73 26	jsr $2673			jsr 	FloatSetZero
.230e					_FIPExit:
.230e	7a		ply				ply
.230f	68		pla				pla
.2310	60		rts				rts
.2311					FloatInt8Multiply:
.2311	5a		phy				phy
.2312	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2314	a8		tay				tay
.2315	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2317					_FI8MLoop:
.2317	98		tya				tya 								; shift right shifter right into carry
.2318	4a		lsr a				lsr 	a
.2319	a8		tay				tay
.231a	90 0d		bcc $2329			bcc 	_FI8MNoAdd
.231c	18		clc				clc
.231d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.231f	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.2321	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2323	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2325	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.2327	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2329					_FI8MNoAdd:
.2329	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.232b	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.232d	c0 00		cpy #$00			cpy 	#0
.232f	d0 e6		bne $2317			bne 	_FI8MLoop 					; until right shifter zero.
.2331	7a		ply				ply
.2332	60		rts				rts
.2333					FloatMultiply:
.2333	ca		dex				dex
.2334	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.2336	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2338	15 62		ora $62,x			ora 	NSMantissa3,x
.233a	15 63		ora $63,x			ora 	NSMantissa3+1,x
.233c	d0 21		bne $235f			bne 	_FMUseFloat
.233e	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2340	15 33		ora $33,x			ora 	NSStatus+1,x
.2342	29 80		and #$80			and 	#$80
.2344	15 62		ora $62,x			ora 	NSMantissa3,x
.2346	15 56		ora $56,x			ora 	NSMantissa2,x
.2348	15 4a		ora $4a,x			ora 	NSMantissa1,x
.234a	15 63		ora $63,x			ora 	NSMantissa3+1,x
.234c	15 57		ora $57,x			ora 	NSMantissa2+1,x
.234e	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2350	d0 04		bne $2356			bne 	_FMInt32
.2352	20 11 23	jsr $2311			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2355	60		rts				rts
.2356					_FMInt32:
.2356	20 80 23	jsr $2380			jsr 	FloatMultiplyShort			; use the int32 one.
.2359	18		clc				clc 								; fix it up if gone out of range
.235a	75 6e		adc $6e,x			adc 	NSExponent,x
.235c	95 6e		sta $6e,x			sta 	NSExponent,x
.235e	60		rts				rts
.235f					_FMUseFloat:
.235f	20 c8 23	jsr $23c8			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2362	f0 18		beq $237c			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2364	e8		inx				inx
.2365	20 c8 23	jsr $23c8			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2368	ca		dex				dex
.2369	c9 00		cmp #$00			cmp 	#0
.236b	f0 0c		beq $2379			beq 	_FDSetZero
.236d	20 80 23	jsr $2380			jsr 	FloatMultiplyShort 			; calculate the result.
.2370	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2372	18		clc				clc
.2373	75 6f		adc $6f,x			adc 	NSExponent+1,x
.2375	95 6e		sta $6e,x			sta 	NSExponent,x
.2377	80 03		bra $237c			bra 	_FDExit
.2379					_FDSetZero:
.2379	20 73 26	jsr $2673			jsr 	FloatSetZero 				; return 0
.237c					_FDExit:
.237c	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise the result
.237f	60		rts				rts
.2380					FloatMultiplyShort:
.2380	5a		phy				phy 								; save Y
.2381	20 56 26	jsr $2656			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2384	20 6f 26	jsr $266f			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2387	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2389					_I32MLoop:
.2389	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.238b	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.238d	15 58		ora $58,x			ora 	NSMantissa2+2,x
.238f	15 64		ora $64,x			ora 	NSMantissa3+2,x
.2391	f0 25		beq $23b8			beq 	_I32MExit 					; exit if zero
.2393	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2395	29 01		and #$01			and 	#1
.2397	f0 0d		beq $23a6			beq 	_I32MNoAdd
.2399	20 ff 23	jsr $23ff			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.239c	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.239e	10 06		bpl $23a6			bpl 	_I32MNoAdd
.23a0					_I32ShiftRight:
.23a0	20 8c 26	jsr $268c			jsr 	FloatShiftRight 			; shift S[X] right
.23a3	c8		iny				iny 								; increment shift count
.23a4	80 09		bra $23af			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23a6					_I32MNoAdd:
.23a6	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23a8	70 f6		bvs $23a0			bvs 	_I32ShiftRight 				; instead.
.23aa	e8		inx				inx
.23ab	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23ae	ca		dex				dex
.23af					_I32MShiftUpper:
.23af	e8		inx				inx 								; shift S[X+2] right
.23b0	e8		inx				inx
.23b1	20 8c 26	jsr $268c			jsr 	FloatShiftRight
.23b4	ca		dex				dex
.23b5	ca		dex				dex
.23b6	80 d1		bra $2389			bra 	_I32MLoop 					; try again.
.23b8					_I32MExit:
.23b8	20 be 23	jsr $23be			jsr 	FloatCalculateSign
.23bb	98		tya				tya 								; shift in A
.23bc	7a		ply				ply 								; restore Y and exit
.23bd	60		rts				rts
.23be					FloatCalculateSign:
.23be	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23c0	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23c2	55 33		eor $33,x			eor 	NSStatus+1,x
.23c4	0a		asl a				asl 	a 							; shift bit 7 into carry
.23c5	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23c7	60		rts				rts
.23c8					FloatNormalise:
.23c8	20 95 26	jsr $2695			jsr 	FloatIsZero 				; if zero exit
.23cb	d0 07		bne $23d4			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23cd	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.23cf	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.23d1	a9 00		lda #$00			lda 	#0 							; set Z flag
.23d3	60		rts				rts
.23d4					_NSNormaliseOptimise:
.23d4	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23d6	d0 19		bne $23f1			bne 	_NSNormaliseLoop
.23d8	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.23da	30 15		bmi $23f1			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23dc	95 62		sta $62,x			sta 	NSMantissa3,x
.23de	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.23e0	95 56		sta $56,x			sta 	NSMantissa2,x
.23e2	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.23e4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23e6	74 3e		stz $3e,x			stz 	NSMantissa0,x
.23e8	b5 6e		lda $6e,x			lda 	NSExponent,x
.23ea	38		sec				sec
.23eb	e9 08		sbc #$08			sbc 	#8
.23ed	95 6e		sta $6e,x			sta 	NSExponent,x
.23ef	80 e3		bra $23d4			bra 	_NSNormaliseOptimise
.23f1					_NSNormaliseLoop:
.23f1	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23f3	70 07		bvs $23fc			bvs 	_NSNExit 					; exit if so with Z flag clear
.23f5	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; shift mantissa left
.23f8	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23fa	80 f5		bra $23f1			bra 	_NSNormaliseLoop
.23fc					_NSNExit:
.23fc	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23fe	60		rts				rts
.23ff					FloatAddTopTwoStack:
.23ff	18		clc				clc
.2400	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2402	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.2404	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2406	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2408	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.240a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.240c	b5 56		lda $56,x			lda		NSMantissa2,x
.240e	75 57		adc $57,x			adc 		NSMantissa2+1,x
.2410	95 56		sta $56,x			sta 	NSMantissa2,x
.2412	b5 62		lda $62,x			lda		NSMantissa3,x
.2414	75 63		adc $63,x			adc 		NSMantissa3+1,x
.2416	95 62		sta $62,x			sta 	NSMantissa3,x
.2418	60		rts				rts
.2419					FloatSubTopTwoStack:
.2419	38		sec				sec
.241a	b5 3e		lda $3e,x			lda		NSMantissa0,x
.241c	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.241e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2420	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2422	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.2424	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2426	b5 56		lda $56,x			lda		NSMantissa2,x
.2428	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.242a	95 56		sta $56,x			sta 	NSMantissa2,x
.242c	b5 62		lda $62,x			lda		NSMantissa3,x
.242e	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.2430	95 62		sta $62,x			sta 	NSMantissa3,x
.2432	60		rts				rts
.2433					FloatInt32Add:
.2433	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2435	55 33		eor $33,x			eor 	NSStatus+1,x
.2437	30 04		bmi $243d			bmi 	_DiffSigns
.2439	20 ff 23	jsr $23ff			jsr		FloatAddTopTwoStack
.243c	60		rts				rts
.243d					_DiffSigns:
.243d	20 19 24	jsr $2419			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2440	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2442	10 07		bpl $244b			bpl 	_AddExit
.2444	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2446	95 32		sta $32,x			sta 	NSStatus,x
.2448	20 3c 26	jsr $263c			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.244b					_AddExit:
.244b	20 95 26	jsr $2695			jsr 	FloatIsZero 				; check for -0
.244e	d0 02		bne $2452			bne 	_AddNonZero
.2450	74 32		stz $32,x			stz 	NSStatus,x
.2452					_AddNonZero:
.2452	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2453					FloatEncodeStart:
.2453	38		sec				sec
.2454	80 01		bra $2457			bra 	FloatEncodeContinue+1
.2456					FloatEncodeContinue:
.2456	18		clc				clc
.2457					FloatEncode:
.2457	08		php				php 								; save reset flag.
.2458	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.245a	f0 15		beq $2471			beq 	_ENIsOkay
.245c	c9 30		cmp #$30			cmp 	#"0"
.245e	90 04		bcc $2464			bcc 	_ENBadNumber
.2460	c9 3a		cmp #$3a			cmp 	#"9"+1
.2462	90 0d		bcc $2471			bcc 	_ENIsOkay
.2464					_ENBadNumber:
.2464	28		plp				plp 								; throw saved reset
.2465	ad 93 05	lda $0593			lda 	encodeState 				; if in decimal mode, construct final number
.2468	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.246a	d0 03		bne $246f			bne 	_ENFail
.246c	4c e9 24	jmp $24e9			jmp 	_ENConstructFinal
.246f					_ENFail:
.246f	18		clc				clc 								; not allowed
.2470	60		rts				rts
.2471					_ENIsOkay:
.2471	28		plp				plp 								; are we restarting
.2472	90 15		bcc $2489			bcc 	_ENNoRestart
.2474					_ENStartEncode:
.2474	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2476	f0 0c		beq $2484			beq 	_ENFirstDP
.2478	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.247a	20 75 26	jsr $2675			jsr 	FloatSetByte 				; in single byte mode.
.247d	a9 01		lda #$01			lda 	#ESTA_Low
.247f					_ENExitChange:
.247f	8d 93 05	sta $0593			sta 	encodeState 				; save new state
.2482	38		sec				sec
.2483	60		rts				rts
.2484					_ENFirstDP:
.2484	20 73 26	jsr $2673			jsr 	FloatSetZero 				; clear integer part
.2487	80 3c		bra $24c5			bra 	_ESTASwitchFloat			; go straight to float and exi
.2489					_ENNoRestart:
.2489	48		pha				pha 								; save digit or DP on stack.
.248a	ad 93 05	lda $0593			lda 	encodeState 				; get current state
.248d	c9 01		cmp #$01			cmp 	#ESTA_Low
.248f	f0 09		beq $249a			beq  	_ESTALowState
.2491	c9 02		cmp #$02			cmp 	#ESTA_High
.2493	f0 26		beq $24bb			beq 	_ESTAHighState
.2495	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2497	f0 38		beq $24d1			beq 	_ESTADecimalState
>2499	db						.byte 	$DB 						; causes a break in the emulator
.249a					_ESTALowState:
.249a	68		pla				pla 								; get value back
.249b	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.249d	f0 26		beq $24c5			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.249f	29 0f		and #$0f			and 	#15 						; make digit
.24a1	8d 94 05	sta $0594			sta 	digitTemp 					; save it.
.24a4	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24a6	0a		asl a				asl 	a
.24a7	0a		asl a				asl 	a
.24a8	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24aa	0a		asl a				asl 	a
.24ab	6d 94 05	adc $0594			adc 	digitTemp
.24ae	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24b0	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24b2	90 05		bcc $24b9			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24b4	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24b6	8d 93 05	sta $0593			sta 	encodeState
.24b9					_ESTANoSwitch:
.24b9	38		sec				sec
.24ba	60		rts				rts
.24bb					_ESTAHighState:
.24bb	68		pla				pla 								; get value back
.24bc	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24be	f0 05		beq $24c5			beq 	_ESTASwitchFloat
.24c0	20 1b 25	jsr $251b			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24c3	38		sec				sec
.24c4	60		rts				rts
.24c5					_ESTASwitchFloat:
.24c5	9c 95 05	stz $0595			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24c8	e8		inx				inx 								; zero the decimal additive.
.24c9	20 73 26	jsr $2673			jsr 	FloatSetZero
.24cc	ca		dex				dex
.24cd	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24cf	80 ae		bra $247f			bra 	_ENExitChange
.24d1					_ESTADecimalState:
.24d1	68		pla				pla 								; digit.
.24d2	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24d4	f0 99		beq $246f			beq 	_ENFail
.24d6	e8		inx				inx 								; put digit into fractional part of X+1
.24d7	20 1b 25	jsr $251b			jsr 	ESTAShiftDigitIntoMantissa
.24da	ca		dex				dex
.24db	ee 95 05	inc $0595			inc 	decimalCount 				; bump the count of decimals
.24de	ad 95 05	lda $0595			lda 	decimalCount 				; too many decimal digits.
.24e1	c9 0b		cmp #$0b			cmp 	#11
.24e3	f0 02		beq $24e7			beq 	_ESTADSFail
.24e5	38		sec				sec
.24e6	60		rts				rts
.24e7					_ESTADSFail:
.24e7	18		clc				clc
.24e8	60		rts				rts
.24e9					_ENConstructFinal:
.24e9	ad 95 05	lda $0595			lda 	decimalCount 				; get decimal count
.24ec	f0 2b		beq $2519			beq 	_ENCFExit 					; no decimals
.24ee	5a		phy				phy
.24ef	0a		asl a				asl 	a 							; x 4 and CLC
.24f0	0a		asl a				asl 	a
.24f1	6d 95 05	adc $0595			adc 	decimalCount
.24f4	a8		tay				tay
.24f5	b9 80 21	lda $2180,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24f8	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24fa	b9 81 21	lda $2181,y			lda 	FloatScalarTable-5+1,y
.24fd	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.24ff	b9 82 21	lda $2182,y			lda 	FloatScalarTable-5+2,y
.2502	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2504	b9 83 21	lda $2183,y			lda 	FloatScalarTable-5+3,y
.2507	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2509	b9 84 21	lda $2184,y			lda 	FloatScalarTable-5+4,y
.250c	95 70		sta $70,x			sta 	NSExponent+2,x
.250e	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.2510	e8		inx				inx 								; multiply decimal const by decimal scalar
.2511	e8		inx				inx
.2512	20 33 23	jsr $2333			jsr 	FloatMultiply
.2515	20 97 20	jsr $2097			jsr 	FloatAdd 					; add to integer part.
.2518	7a		ply				ply
.2519					_ENCFExit:
.2519	18		clc				clc 								; reject the digit.
.251a	60		rts				rts
.251b					ESTAShiftDigitIntoMantissa:
.251b	29 0f		and #$0f			and 	#15 						; save digit
.251d	48		pha				pha
.251e	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2520	48		pha				pha
.2521	b5 56		lda $56,x			lda 	NSMantissa2,x
.2523	48		pha				pha
.2524	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2526	48		pha				pha
.2527	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2529	48		pha				pha
.252a	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; x 2
.252d	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; x 4
.2530	18		clc				clc 								; pop mantissa and add
.2531	68		pla				pla
.2532	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2534	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2536	68		pla				pla
.2537	75 4a		adc $4a,x			adc 	NSMantissa1,x
.2539	95 4a		sta $4a,x			sta 	NSMantissa1,x
.253b	68		pla				pla
.253c	75 56		adc $56,x			adc 	NSMantissa2,x
.253e	95 56		sta $56,x			sta 	NSMantissa2,x
.2540	68		pla				pla
.2541	75 62		adc $62,x			adc 	NSMantissa3,x
.2543	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.2545	20 82 26	jsr $2682			jsr 	FloatShiftLeft 				; x 10
.2548	68		pla				pla 								; add digit
.2549	18		clc				clc
.254a	75 3e		adc $3e,x			adc 	NSMantissa0,x
.254c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.254e	90 0a		bcc $255a			bcc 	_ESTASDExit
.2550	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2552	d0 06		bne $255a			bne 	_ESTASDExit
.2554	f6 56		inc $56,x			inc 	NSMantissa2,x
.2556	d0 02		bne $255a			bne 	_ESTASDExit
.2558	f6 62		inc $62,x			inc 	NSMantissa3,x
.255a					_ESTASDExit:
.255a	60		rts				rts
.0593					encodeState:
>0593							.fill 	1
.0594					digitTemp:
>0594							.fill 	1
.0595					decimalCount:
>0595							.fill 	1
.255b					FloatToString:
.255b	da		phx				phx
.255c	5a		phy				phy 								; save code position
.255d	8d 96 05	sta $0596			sta 	decimalPlaces	 			; save number of DPs.
.2560	9c 97 05	stz $0597			stz 	dbOffset 					; offset into decimal buffer = start.
.2563	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.2565	10 08		bpl $256f			bpl 	_CNTSNotNegative
.2567	29 7f		and #$7f			and 	#$7F 						; make +ve
.2569	95 32		sta $32,x			sta 	NSStatus,x
.256b	a9 2d		lda #$2d			lda 	#"-"
.256d	80 02		bra $2571			bra 	_CNTMain
.256f					_CNTSNotNegative:
.256f	a9 20		lda #$20			lda 	#" "
.2571					_CNTMain:
.2571	20 d3 25	jsr $25d3			jsr 	WriteDecimalBuffer
.2574	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.2576	f0 0d		beq $2585			beq 	_CNTSNotFloat
.2578	e8		inx				inx 								; round up so we don't get too many 6.999999
.2579	a9 01		lda #$01			lda 	#1
.257b	20 75 26	jsr $2675			jsr 	FloatSetByte
.257e	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2580	95 6e		sta $6e,x			sta 	NSExponent,x
.2582	20 97 20	jsr $2097			jsr 	FloatAdd
.2585					_CNTSNotFloat:
.2585	20 b5 25	jsr $25b5			jsr 	MakePlusTwoString 			; do the integer part.
.2588	20 53 22	jsr $2253			jsr 	FloatFractionalPart 		; get the fractional part
.258b	20 c8 23	jsr $23c8			jsr 	FloatNormalise					; normalise , exit if zero
.258e	f0 22		beq $25b2			beq 	_CNTSExit
.2590	a9 2e		lda #$2e			lda 	#"."
.2592	20 d3 25	jsr $25d3			jsr 	WriteDecimalBuffer 			; write decimal place
.2595					_CNTSDecimal:
.2595	ce 96 05	dec $0596			dec 	decimalPlaces 				; done all the decimals
.2598	30 18		bmi $25b2			bmi 	_CNTSExit
.259a	e8		inx				inx 								; x 10.0
.259b	a9 0a		lda #$0a			lda 	#10
.259d	20 75 26	jsr $2675			jsr 	FloatSetByte
.25a0	20 33 23	jsr $2333			jsr 	FloatMultiply
.25a3	20 b5 25	jsr $25b5			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25a6	20 53 22	jsr $2253			jsr 	FloatFractionalPart 		; get the fractional part
.25a9	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; normalise it.
.25ac	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25ae	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25b0	b0 e3		bcs $2595			bcs 	_CNTSDecimal 				; keep going.
.25b2					_CNTSExit:
.25b2	7a		ply				ply
.25b3	fa		plx				plx
.25b4	60		rts				rts
.25b5					MakePlusTwoString:
.25b5	da		phx				phx
.25b6	20 56 26	jsr $2656			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25b9	e8		inx				inx 								; access it
.25ba	e8		inx				inx
.25bb	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart 			; make it an integer
.25be	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25c0	20 f2 25	jsr $25f2			jsr 	ConvertInt32
.25c3	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25c5					_MPTSCopy:
.25c5	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25c8	20 d3 25	jsr $25d3			jsr 	WriteDecimalBuffer
.25cb	e8		inx				inx
.25cc	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25cf	d0 f4		bne $25c5			bne 	_MPTSCopy
.25d1	fa		plx				plx
.25d2	60		rts				rts
.25d3					WriteDecimalBuffer:
.25d3	da		phx				phx
.25d4	ae 97 05	ldx $0597			ldx 	dbOffset
.25d7	9d 98 05	sta $0598,x			sta 	decimalBuffer,x
.25da	9e 99 05	stz $0599,x			stz 	decimalBuffer+1,x
.25dd	ee 97 05	inc $0597			inc 	dbOffset
.25e0	fa		plx				plx
.25e1	60		rts				rts
.0596					decimalPlaces:
>0596							.fill 	1
.0597					dbOffset:
>0597							.fill 	1
.0598					decimalBuffer:
>0598							.fill 	32
.25e2					ConvertInt16:
.25e2	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.25e4	86 4a		stx $4a				stx 	NSMantissa1
.25e6	64 56		stz $56				stz 	NSMantissa2
.25e8	64 62		stz $62				stz 	NSMantissa3
.25ea	64 32		stz $32				stz 	NSStatus 					; positive integer
.25ec	a2 00		ldx #$00			ldx 	#0 							; stack level
.25ee	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25f0	80 00		bra $25f2			bra 	ConvertInt32
.25f2					ConvertInt32:
.25f2	5a		phy				phy
.25f3	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25f5	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25f7	10 08		bpl $2601			bpl 	_CI32NotNeg
.25f9	48		pha				pha
.25fa	a9 2d		lda #$2d			lda 	#'-'
.25fc	99 71 05	sta $0571,y			sta 	numberBuffer,y
.25ff	c8		iny				iny
.2600	68		pla				pla
.2601					_CI32NotNeg:
.2601	20 0f 26	jsr $260f			jsr 	_CI32DivideConvert 			; recursive conversion
.2604	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2606	99 71 05	sta $0571,y			sta 	numberBuffer,y
.2609	7a		ply				ply
.260a	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.260c	a9 71		lda #$71			lda 	#numberBuffer & $FF
.260e	60		rts				rts
.260f					_CI32DivideConvert:
.260f	e8		inx				inx 								; write to next slot up
.2610	20 75 26	jsr $2675			jsr 	FloatSetByte 		 		; write the base out.
.2613	ca		dex				dex
.2614	20 09 22	jsr $2209			jsr 	Int32Divide 				; divide
.2617	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.2619	48		pha				pha
.261a	20 f8 21	jsr $21f8			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.261d	20 95 26	jsr $2695			jsr 	FloatIsZero 				; is it zero ?
.2620	f0 05		beq $2627			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2622	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2624	20 0f 26	jsr $260f			jsr 	_CI32DivideConvert 			; and recusrively call.
.2627					_CI32NoRecurse:
.2627	68		pla				pla 								; remainder
.2628	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.262a	90 02		bcc $262e			bcc 	_CI32NotHex
.262c	69 26		adc #$26			adc 	#6+32
.262e					_CI32NotHex:
.262e	69 30		adc #$30			adc 	#48
.2630	99 71 05	sta $0571,y			sta 	numberBuffer,y 				; write out and exit
.2633	c8		iny				iny
.2634	60		rts				rts
.2635					FloatNegate:
.2635	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2637	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2639	95 32		sta $32,x			sta 	NSStatus,x
.263b	60		rts				rts
.263c					FloatNegateMantissa:
.263c	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.263d	a9 00		lda #$00			lda 	#0
.263f	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2641	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2643	a9 00		lda #$00			lda 	#0
.2645	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.2647	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2649	a9 00		lda #$00			lda 	#0
.264b	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.264d	95 56		sta $56,x			sta 	NSMantissa2,x
.264f	a9 00		lda #$00			lda 	#0
.2651	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2653	95 62		sta $62,x			sta 	NSMantissa3,x
.2655	60		rts				rts
.2656					FloatShiftUpTwo:
.2656	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2658	95 40		sta $40,x			sta 	NSMantissa0+2,x
.265a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.265c	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.265e	b5 56		lda $56,x			lda 	NSMantissa2,x
.2660	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2662	b5 62		lda $62,x			lda 	NSMantissa3,x
.2664	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2666	b5 6e		lda $6e,x			lda 	NSExponent,x
.2668	95 70		sta $70,x			sta 	NSExponent+2,x
.266a	b5 32		lda $32,x			lda 	NSStatus,x
.266c	95 34		sta $34,x			sta 	NSStatus+2,x
.266e	60		rts				rts
.266f					FloatSetZeroMantissaOnly:
.266f	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2671	80 08		bra $267b			bra 	FloatZero13
.2673					FloatSetZero:
.2673	a9 00		lda #$00			lda 	#0
.2675					FloatSetByte:
.2675	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2677					FloatSetMantissa:
.2677	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.2679	74 32		stz $32,x			stz 	NSStatus,x
.267b					FloatZero13:
.267b	74 4a		stz $4a,x			stz 	NSMantissa1,x
.267d	74 56		stz $56,x			stz 	NSMantissa2,x
.267f	74 62		stz $62,x			stz 	NSMantissa3,x
.2681	60		rts				rts
.2682					FloatShiftLeft:
.2682	18		clc				clc
.2683					FloatRotateLeft:
.2683	36 3e		rol $3e,x			rol 	NSMantissa0,x
.2685	36 4a		rol $4a,x			rol		NSMantissa1,x
.2687	36 56		rol $56,x			rol		NSMantissa2,x
.2689	36 62		rol $62,x			rol		NSMantissa3,x
.268b	60		rts				rts
.268c					FloatShiftRight:
.268c	56 62		lsr $62,x			lsr 	NSMantissa3,x
.268e	76 56		ror $56,x			ror		NSMantissa2,x
.2690	76 4a		ror $4a,x			ror		NSMantissa1,x
.2692	76 3e		ror $3e,x			ror		NSMantissa0,x
.2694	60		rts				rts
.2695					FloatIsZero:
.2695	b5 62		lda $62,x			lda 	NSMantissa3,x
.2697	15 56		ora $56,x			ora		NSMantissa2,x
.2699	15 4a		ora $4a,x			ora		NSMantissa1,x
.269b	15 3e		ora $3e,x			ora		NSMantissa0,x
.269d	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.269e					FloatArcTan:
.269e	20 c8 23	jsr $23c8			jsr 	FloatNormalise 					; normalise x
.26a1	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.26a3	48		pha				pha
.26a4	74 32		stz $32,x			stz 	NSStatus,x
.26a6	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.26a8	c9 e2		cmp #$e2			cmp 	#$E2
.26aa	90 25		bcc $26d1			bcc 	_UANoFixup
.26ac	8a		txa				txa 									; value in +1
.26ad	a8		tay				tay
.26ae	c8		iny				iny
.26af	20 57 28	jsr $2857			jsr 	CopyFloatXY
.26b2	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.26b4	20 75 26	jsr $2675			jsr 	FloatSetByte
.26b7	e8		inx				inx
.26b8	20 bc 21	jsr $21bc			jsr 	FloatDivide
.26bb	b0 21		bcs $26de			bcs 	_FATError
.26bd	20 e1 26	jsr $26e1			jsr 	CoreAtn 						; calculate the root
.26c0	20 4c 28	jsr $284c			jsr 	CompletePolynomial
.26c3	20 35 26	jsr $2635			jsr 	FloatNegate 					; make -ve
.26c6	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.26c8	20 a3 28	jsr $28a3			jsr 	LoadConstant
.26cb	e8		inx				inx
.26cc	20 97 20	jsr $2097			jsr 	FloatAdd
.26cf	80 06		bra $26d7			bra 	_UAComplete
.26d1					_UANoFixup:
.26d1	20 e1 26	jsr $26e1			jsr 	CoreAtn
.26d4	20 4c 28	jsr $284c			jsr 	CompletePolynomial
.26d7					_UAComplete:
.26d7	68		pla				pla 									; apply the result.
.26d8	55 32		eor $32,x			eor 	NSStatus,x
.26da	95 32		sta $32,x			sta 	NSStatus,x
.26dc	18		clc				clc
.26dd	60		rts				rts
.26de					_FATError:
.26de	68		pla				pla
.26df	38		sec				sec
.26e0	60		rts				rts
.26e1					CoreAtn:
.26e1	a9 4f		lda #$4f			lda 	#AtnCoefficients & $FF
.26e3	a0 27		ldy #$27			ldy 	#AtnCoefficients >> 8
.26e5	4c a0 29	jmp $29a0			jmp 	CorePolySquared
.26e8					ExpCoefficients:
>26e8	07					.byte	7
>26e9	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>26ed	d2					.byte	$d2
>26ee	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>26f2	d5					.byte	$d5
>26f3	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>26f7	d8					.byte	$d8
>26f8	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>26fc	db					.byte	$db
>26fd	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>2701	dd					.byte	$dd
>2702	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>2706	df					.byte	$df
>2707	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>270b	e1					.byte	$e1
>270c	00 00 00 40				.dword	$40000000 ; 1.0
>2710	e2					.byte	$e2
.2711					SinCoefficients:
>2711	06					.byte	6
>2712	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>2716	e5					.byte	$e5
>2717	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>271b	e7					.byte	$e7
>271c	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>2720	e8					.byte	$e8
>2721	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>2725	e8					.byte	$e8
>2726	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>272a	e7					.byte	$e7
>272b	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>272f	e4					.byte	$e4
>2730	00 00 00 00				.dword	$00000000 ; 0.0
>2734	00					.byte	$00
.2735					LogCoefficients:
>2735	04					.byte	4
>2736	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>273a	e0					.byte	$e0
>273b	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>273f	e1					.byte	$e1
>2740	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>2744	e1					.byte	$e1
>2745	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>2749	e3					.byte	$e3
>274a	00 00 00 c0				.dword	$c0000000 ; -0.5
>274e	e1					.byte	$e1
.274f					AtnCoefficients:
>274f	0c					.byte	12
>2750	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2754	d7					.byte	$d7
>2755	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>2759	da					.byte	$da
>275a	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>275e	dc					.byte	$dc
>275f	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2763	dd					.byte	$dd
>2764	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>2768	dd					.byte	$dd
>2769	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>276d	de					.byte	$de
>276e	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2772	de					.byte	$de
>2773	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>2777	de					.byte	$de
>2778	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>277c	df					.byte	$df
>277d	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>2781	df					.byte	$df
>2782	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>2786	e0					.byte	$e0
>2787	00 00 00 40				.dword	$40000000 ; 1.0
>278b	e2					.byte	$e2
>278c	00 00 00 00				.dword	$00000000 ; 0.0
>2790	00					.byte	$00
.2791					Const_Base:
.2791					Const_1Div2Pi:
>2791	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>2795	df					.byte	$df
.2796					Const_PiDiv2:
>2796	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>279a	e2					.byte	$e2
.279b					Const_Log2_e:
>279b	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>279f	e2					.byte	$e2
.27a0					Const_sqrt_2:
>27a0	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>27a4	e2					.byte	$e2
.27a5					Const_sqrt_half:
>27a5	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>27a9	e1					.byte	$e1
.27aa					Const_pi:
>27aa	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>27ae	e3					.byte	$e3
.27af					Const_half:
>27af	00 00 00 40				.dword	$40000000 ; 0.50000000
>27b3	e1					.byte	$e1
.27b4					Const_ln_e:
>27b4	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>27b8	e1					.byte	$e1
.27b9					FloatCosine:
.27b9	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.27bb	20 a3 28	jsr $28a3			jsr 	LoadConstant
.27be	e8		inx				inx
.27bf	20 97 20	jsr $2097			jsr 	FloatAdd
.27c2	4c 59 29	jmp $2959			jmp 	FloatSine
.27c5					FloatExponent:
.27c5	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.27c7	20 a3 28	jsr $28a3			jsr 	LoadConstant
.27ca	e8		inx				inx
.27cb	20 33 23	jsr $2333			jsr 	FloatMultiply
.27ce	20 10 28	jsr $2810			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.27d1	e8		inx				inx
.27d2	20 ae 22	jsr $22ae			jsr 	FloatIntegerPart
.27d5	ca		dex				dex
.27d6	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.27d8	15 57		ora $57,x			ora 	NSMantissa2+1,x
.27da	15 63		ora $63,x			ora 	NSMantissa3+1,x
.27dc	d0 38		bne $2816			bne 	_UERangeError
.27de	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.27e0	c9 40		cmp #$40			cmp 	#64
.27e2	b0 32		bcs $2816			bcs 	_UERangeError
.27e4	48		pha				pha
.27e5	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.27e7	48		pha				pha
.27e8	20 53 22	jsr $2253			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.27eb	68		pla				pla
.27ec	10 14		bpl $2802			bpl 	_UEPositive
.27ee	e8		inx				inx 							; 1-x
.27ef	a9 01		lda #$01			lda 	#1
.27f1	20 75 26	jsr $2675			jsr 	FloatSetByte
.27f4	ca		dex				dex
.27f5	20 35 26	jsr $2635			jsr 	FloatNegate
.27f8	e8		inx				inx
.27f9	20 97 20	jsr $2097			jsr 	FloatAdd
.27fc	68		pla				pla 							; integer part +1 and negated.
.27fd	1a		inc a				inc 	a
.27fe	49 ff		eor #$ff			eor 	#$FF
.2800	1a		inc a				inc 	a
.2801	48		pha				pha
.2802					_UEPositive:
.2802	20 18 28	jsr $2818			jsr 	CoreExponent
.2805	20 4c 28	jsr $284c			jsr 	CompletePolynomial
.2808	68		pla				pla
.2809	18		clc				clc
.280a	75 6e		adc $6e,x			adc 	NSExponent,x
.280c	95 6e		sta $6e,x			sta 	NSExponent,x
.280e	18		clc				clc
.280f	60		rts				rts
.2810					_UECopy01:
.2810	8a		txa				txa
.2811	a8		tay				tay
.2812	c8		iny				iny
.2813	4c 57 28	jmp $2857			jmp 	CopyFloatXY
.2816					_UERangeError:
.2816	38		sec				sec
.2817	60		rts				rts
.2818					CoreExponent:
.2818	a9 e8		lda #$e8			lda 	#ExpCoefficients & $FF
.281a	a0 26		ldy #$26			ldy 	#ExpCoefficients >> 8
.281c	20 20 28	jsr $2820			jsr 	CalculateHornerPolynomial
.281f	60		rts				rts
.2820					CalculateHornerPolynomial:
.2820	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.2822	84 2d		sty $2d				sty 	zTemp0+1
.2824	9c b8 05	stz $05b8			stz 	coefficientCount 			; zero the count.
.2827	8e b9 05	stx $05b9			stx 	xValueSlot 					; save xValue slot.
.282a	e8		inx				inx 								; set the count to zero.
.282b	20 73 26	jsr $2673			jsr 	FloatSetZero
.282e					_CHPLoop:
.282e	8a		txa				txa 								; copy X-1 to X+1
.282f	a8		tay				tay
.2830	ca		dex				dex
.2831	c8		iny				iny
.2832	20 57 28	jsr $2857			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.2835	e8		inx				inx
.2836	e8		inx				inx
.2837	20 33 23	jsr $2333			jsr 	FloatMultiply 				; times current by X
.283a	e8		inx				inx
.283b	20 76 28	jsr $2876			jsr 	GetCoefficient 				; coefficient into X+1
.283e	20 97 20	jsr $2097			jsr 	FloatAdd 					; and add
.2841	ee b8 05	inc $05b8			inc 	coefficientCount
.2844	ad b8 05	lda $05b8			lda 	coefficientCount
.2847	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.2849	d0 e3		bne $282e			bne 	_CHPLoop
.284b	60		rts				rts
.284c					CompletePolynomial:
.284c	20 33 23	jsr $2333			jsr 	FloatMultiply
.284f	e8		inx				inx 								; get the last value
.2850	20 76 28	jsr $2876			jsr 	GetCoefficient
.2853	20 97 20	jsr $2097			jsr 	FloatAdd 					; and add it
.2856	60		rts				rts
.2857					CopyFloatXY:
.2857	b5 6e		lda $6e,x			lda 	NSExponent,x
.2859	99 6e 00	sta $006e,y			sta 	NSExponent,y
.285c	b5 32		lda $32,x			lda 	NSStatus,x
.285e	99 32 00	sta $0032,y			sta 	NSStatus,y
.2861	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2863	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.2866	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2868	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.286b	b5 56		lda $56,x			lda 	NSMantissa2,x
.286d	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.2870	b5 62		lda $62,x			lda 	NSMantissa3,x
.2872	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.2875	60		rts				rts
.2876					GetCoefficient:
.2876	5a		phy				phy
.2877	ad b8 05	lda $05b8			lda 	coefficientCount 			; 5 per block
.287a	0a		asl a				asl 	a
.287b	0a		asl a				asl 	a
.287c	38		sec				sec 								; +1 for count
.287d	6d b8 05	adc $05b8			adc 	coefficientCount
.2880	a8		tay				tay
.2881	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.2883	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2885	c8		iny				iny
.2886	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2888	95 4a		sta $4a,x			sta 	NSMantissa1,x
.288a	c8		iny				iny
.288b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.288d	95 56		sta $56,x			sta 	NSMantissa2,x
.288f	c8		iny				iny
.2890	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2892	48		pha				pha
.2893	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.2895	95 62		sta $62,x			sta 	NSMantissa3,x
.2897	c8		iny				iny
.2898	68		pla				pla
.2899	29 80		and #$80			and 	#$80
.289b	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.289d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.289f	95 6e		sta $6e,x			sta 	NSExponent,x
.28a1	7a		ply				ply
.28a2	60		rts				rts
.05b8					coefficientCount:
>05b8							.fill 	1
.05b9					xValueSlot:
>05b9							.fill 	1
.28a3					LoadConstant:
.28a3	5a		phy				phy
.28a4	a8		tay				tay
.28a5	b9 91 27	lda $2791,y			lda 	Const_Base+0,y
.28a8	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.28aa	b9 92 27	lda $2792,y			lda 	Const_Base+1,y
.28ad	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.28af	b9 93 27	lda $2793,y			lda 	Const_Base+2,y
.28b2	95 57		sta $57,x			sta 	NSMantissa2+1,x
.28b4	b9 94 27	lda $2794,y			lda 	Const_Base+3,y
.28b7	48		pha				pha
.28b8	29 7f		and #$7f			and 	#$7F
.28ba	95 63		sta $63,x			sta 	NSMantissa3+1,x
.28bc	68		pla				pla
.28bd	29 80		and #$80			and 	#$80
.28bf	95 33		sta $33,x			sta 	NSStatus+1,x
.28c1	b9 95 27	lda $2795,y			lda 	Const_Base+4,y
.28c4	95 6f		sta $6f,x			sta 	NSExponent+1,x
.28c6	7a		ply				ply
.28c7	60		rts				rts
.28c8					FloatLogarithm:
.28c8	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.28ca	30 5f		bmi $292b			bmi 	_ULRange
.28cc	20 95 26	jsr $2695			jsr 	FloatIsZero
.28cf	f0 5a		beq $292b			beq 	_ULRange
.28d1	20 c8 23	jsr $23c8			jsr 	FloatNormalise 				; put into FP mode.
.28d4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.28d6	48		pha				pha
.28d7	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.28d9	95 6e		sta $6e,x			sta 	NSExponent,x
.28db	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.28dd	20 a3 28	jsr $28a3			jsr 	LoadConstant
.28e0	e8		inx				inx
.28e1	20 97 20	jsr $2097			jsr 	FloatAdd
.28e4	8a		txa				txa 								; divide into sqrt 2.0
.28e5	a8		tay				tay
.28e6	c8		iny				iny
.28e7	20 57 28	jsr $2857			jsr 	CopyFloatXY
.28ea	ca		dex				dex
.28eb	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.28ed	20 a3 28	jsr $28a3			jsr 	LoadConstant
.28f0	e8		inx				inx
.28f1	e8		inx				inx
.28f2	20 bc 21	jsr $21bc			jsr 	FloatDivide 				; if zero, error.
.28f5	b0 33		bcs $292a			bcs 	_ULRangePla
.28f7	20 35 26	jsr $2635			jsr 	FloatNegate 				; subtract from 1
.28fa	e8		inx				inx
.28fb	a9 01		lda #$01			lda 	#1
.28fd	20 75 26	jsr $2675			jsr 	FloatSetByte
.2900	20 97 20	jsr $2097			jsr 	FloatAdd
.2903	20 2d 29	jsr $292d			jsr 	CoreLog
.2906	20 4c 28	jsr $284c			jsr 	CompletePolynomial
.2909	68		pla				pla 								; add exponent
.290a	18		clc				clc
.290b	69 1f		adc #$1f			adc 	#31 						; fix up
.290d	48		pha				pha
.290e	10 03		bpl $2913			bpl 	_LogNotNeg
.2910	49 ff		eor #$ff			eor 	#$FF
.2912	1a		inc a				inc 	a
.2913					_LogNotNeg:
.2913	e8		inx				inx 								; set byte and sign.
.2914	20 75 26	jsr $2675			jsr 	FloatSetByte
.2917	68		pla				pla
.2918	29 80		and #$80			and 	#$80
.291a	95 32		sta $32,x			sta 	NSStatus,x
.291c	20 97 20	jsr $2097			jsr 	FloatAdd
.291f	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.2921	20 a3 28	jsr $28a3			jsr 	LoadConstant
.2924	e8		inx				inx
.2925	20 33 23	jsr $2333			jsr 	FloatMultiply
.2928	18		clc				clc
.2929	60		rts				rts
.292a					_ULRangePla:
.292a	68		pla				pla
.292b					_ULRange:
.292b	38		sec				sec
.292c	60		rts				rts
.292d					CoreLog:
.292d	a9 35		lda #$35			lda 	#LogCoefficients & $FF
.292f	a0 27		ldy #$27			ldy 	#LogCoefficients >> 8
.2931	4c a0 29	jmp $29a0			jmp 	CorePolySquared
.2934					FloatPI:
.2934	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.2936	20 a3 28	jsr $28a3			jsr 	LoadConstant
.2939	e8		inx				inx
.293a	18		clc				clc
.293b	60		rts				rts
.293c					FloatPower:
.293c	ca		dex				dex
.293d	8a		txa				txa 							; copy 0 to 2, so we can process it
.293e	a8		tay				tay
.293f	c8		iny				iny
.2940	c8		iny				iny
.2941	20 57 28	jsr $2857			jsr 	CopyFloatXY
.2944	e8		inx				inx 							; 2 = Log(0)
.2945	e8		inx				inx
.2946	20 c8 28	jsr $28c8			jsr 	FloatLogarithm
.2949	b0 0d		bcs $2958			bcs 	_FPWExit
.294b	20 33 23	jsr $2333			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.294e	8a		txa				txa 							; copy to slot 0
.294f	a8		tay				tay
.2950	88		dey				dey
.2951	20 57 28	jsr $2857			jsr 	CopyFloatXY
.2954	ca		dex				dex  							; Exponent code.
.2955	20 c5 27	jsr $27c5			jsr 	FloatExponent
.2958					_FPWExit:
.2958	60		rts				rts
.2959					FloatSine:
.2959	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.295b	48		pha				pha
.295c	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.295e	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.2960	20 a3 28	jsr $28a3			jsr 	LoadConstant
.2963	e8		inx				inx
.2964	20 33 23	jsr $2333			jsr 	FloatMultiply
.2967	20 53 22	jsr $2253			jsr 	FloatFractionalPart 		; take the fractional part
.296a	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.296c	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.296e	90 1f		bcc $298f			bcc 	_USProcessExit
.2970	f0 06		beq $2978			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.2972	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.2974	c9 60		cmp #$60			cmp 	#$60
.2976	b0 0e		bcs $2986			bcs 	_USSubtractOne
.2978					_USSubtractFromHalf:
.2978	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.297a	20 a3 28	jsr $28a3			jsr 	LoadConstant
.297d	e8		inx				inx
.297e	20 91 20	jsr $2091			jsr 	FloatSubtract
.2981	20 35 26	jsr $2635			jsr 	FloatNegate 				; then negate it
.2984	80 09		bra $298f			bra 	_USProcessExit 				; and exit
.2986					_USSubtractOne:
.2986	e8		inx				inx
.2987	a9 01		lda #$01			lda 	#1
.2989	20 75 26	jsr $2675			jsr 	FloatSetByte
.298c	20 91 20	jsr $2091			jsr 	FloatSubtract
.298f					_USProcessExit:
.298f	20 9c 29	jsr $299c			jsr 	CoreSine
.2992	20 4c 28	jsr $284c			jsr 	CompletePolynomial
.2995	68		pla				pla 								; restore sign and apply
.2996	55 32		eor $32,x			eor 	NSStatus,x
.2998	95 32		sta $32,x			sta 	NSStatus,x
.299a	18		clc				clc
.299b	60		rts				rts
.299c					CoreSine:
.299c	a9 11		lda #$11			lda 	#SinCoefficients & $FF
.299e	a0 27		ldy #$27			ldy 	#SinCoefficients >> 8
.29a0					CorePolySquared:
.29a0	48		pha				pha 								; save coefficient table
.29a1	5a		phy				phy
.29a2	8a		txa				txa 								; copy X to +1, +2
.29a3	a8		tay				tay
.29a4	c8		iny				iny
.29a5	20 57 28	jsr $2857			jsr 	CopyFloatXY
.29a8	c8		iny				iny
.29a9	20 57 28	jsr $2857			jsr 	CopyFloatXY
.29ac	e8		inx				inx 								; point to the pair and put x^2 on stack
.29ad	e8		inx				inx
.29ae	20 33 23	jsr $2333			jsr 	FloatMultiply
.29b1	7a		ply				ply 								; coefficient table back.
.29b2	68		pla				pla
.29b3	20 20 28	jsr $2820			jsr 	CalculateHornerPolynomial
.29b6	8a		txa				txa 								; copy back to slot #1
.29b7	a8		tay				tay
.29b8	88		dey				dey
.29b9	20 57 28	jsr $2857			jsr	 	CopyFloatXY
.29bc	ca		dex				dex 								; point at result
.29bd	60		rts				rts
.29be					FloatSquareRoot:
.29be	20 c8 28	jsr $28c8			jsr 	FloatLogarithm
.29c1	b0 06		bcs $29c9			bcs 	_FSQExit
.29c3	d6 6e		dec $6e,x			dec 	NSExponent,x
.29c5	20 c5 27	jsr $27c5			jsr 	FloatExponent
.29c8	18		clc				clc
.29c9					_FSQExit:
.29c9	60		rts				rts
.29ca					FloatTangent:
.29ca	da		phx				phx
.29cb	8a		txa				txa 								; sin -> +1
.29cc	a8		tay				tay
.29cd	c8		iny				iny
.29ce	20 57 28	jsr $2857			jsr 	CopyFloatXY
.29d1	e8		inx				inx
.29d2	20 59 29	jsr $2959			jsr 	FloatSine
.29d5	ca		dex				dex
.29d6	8a		txa				txa 								; cos -> +2
.29d7	a8		tay				tay
.29d8	c8		iny				iny
.29d9	c8		iny				iny
.29da	20 57 28	jsr $2857			jsr 	CopyFloatXY
.29dd	e8		inx				inx
.29de	e8		inx				inx
.29df	20 b9 27	jsr $27b9			jsr 	FloatCosine
.29e2	20 bc 21	jsr $21bc			jsr 	FloatDivide 				; calculate sin/cos
.29e5	b0 07		bcs $29ee			bcs 	_FTExit 					; divide by zero
.29e7	8a		txa				txa 								; copy result down.
.29e8	a8		tay				tay
.29e9	88		dey				dey
.29ea	20 57 28	jsr $2857			jsr 	CopyFloatXY
.29ed	18		clc				clc
.29ee					_FTExit:
.29ee	fa		plx				plx
.29ef	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.007a					srcPtr:
>007a							.fill 	2
.05ba					currentLineNumber:
>05ba							.fill 	2
.29f0					InlineNonDecimal:
.29f0	a2 02		ldx #$02			ldx 	#2 							; get size in X
.29f2	c9 25		cmp #$25			cmp 	#"%"
.29f4	f0 02		beq $29f8			beq 	_INDBinary
.29f6	a2 10		ldx #$10			ldx 	#16
.29f8					_INDBinary:
.29f8	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.29fa	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.29fc	64 2c		stz $2c				stz 	zTemp0 						; zero result
.29fe	64 2d		stz $2d				stz 	zTemp0+1
.2a00					_INDLoop:
.2a00	20 a2 33	jsr $33a2			jsr 	LookNext 					; check next character
.2a03	20 de 33	jsr $33de			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.2a06	90 1f		bcc $2a27			bcc		_INDDone 					; didn't convert
.2a08	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.2a0a	b0 1b		bcs $2a27			bcs 	_INDDone
.2a0c	20 36 2a	jsr $2a36			jsr 	_INDShift 					; x 2 or x 16
.2a0f	e0 02		cpx #$02			cpx 	#2
.2a11	f0 09		beq $2a1c			beq 	_INDNotHex
.2a13	20 36 2a	jsr $2a36			jsr 	_INDShift
.2a16	20 36 2a	jsr $2a36			jsr 	_INDShift
.2a19	20 36 2a	jsr $2a36			jsr 	_INDShift
.2a1c					_INDNotHex:
.2a1c	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.2a1e	85 2c		sta $2c				sta 	zTemp0
.2a20	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume
.2a23	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.2a25	80 d9		bra $2a00			bra 	_INDLoop
.2a27					_INDDone:
.2a27	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.2a29	f0 08		beq $2a33			beq 	_INDError
.2a2b	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.2a2d	a5 2c		lda $2c				lda 	zTemp0
.2a2f	20 58 2b	jsr $2b58			jsr 	PushIntegerYA
.2a32	60		rts				rts
.2a33					_INDError:
.2a33	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.2a36					_INDShift:
.2a36	06 2c		asl $2c				asl 	zTemp0
.2a38	26 2d		rol $2d				rol 	zTemp0+1
.2a3a	60		rts				rts
.2a3b					GetLineNumber:
.2a3b	ac bb 05	ldy $05bb			ldy 	currentLineNumber+1
.2a3e	ad ba 05	lda $05ba			lda 	currentLineNumber
.2a41	60		rts				rts
.2a42					WriteCodeByte:
.2a42	48		pha				pha 								; save on stack
.2a43	da		phx				phx
.2a44	5a		phy				phy
.2a45	aa		tax				tax
.2a46	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.2a48	20 55 2b	jsr $2b55			jsr 	CallAPIHandler
.2a4b	7a		ply				ply 								; restore from stack
.2a4c	fa		plx				plx
.2a4d	68		pla				pla
.2a4e	60		rts				rts
.2a4f					PrintCharacter
.2a4f	48		pha				pha
.2a50	da		phx				phx
.2a51	5a		phy				phy
.2a52	aa		tax				tax
.2a53	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.2a55	20 55 2b	jsr $2b55			jsr 	CallAPIHandler
.2a58	7a		ply				ply
.2a59	fa		plx				plx
.2a5a	68		pla				pla
.2a5b	60		rts				rts
.2a5c					ProcessNewLine:
.2a5c	86 2c		stx $2c				stx 	zTemp0 						; save address in zTemp0
.2a5e	84 2d		sty $2d				sty 	zTemp0+1
.2a60	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.2a61	8a		txa				txa
.2a62	69 04		adc #$04			adc 	#4
.2a64	85 7a		sta $7a				sta 	srcPtr
.2a66	98		tya				tya
.2a67	69 00		adc #$00			adc 	#0
.2a69	85 7b		sta $7b				sta 	srcPtr+1
.2a6b	a0 02		ldy #$02			ldy 	#2							; read and save line number
.2a6d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a6f	8d ba 05	sta $05ba			sta 	currentLineNumber
.2a72	c8		iny				iny
.2a73	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a75	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2a78	60		rts				rts
.2a79					BufferClear:
.2a79	9c bc 05	stz $05bc			stz 	bufferSize
.2a7c	60		rts				rts
.2a7d					BufferWrite:
.2a7d	da		phx				phx
.2a7e	ae bc 05	ldx $05bc			ldx 	bufferSize
.2a81	9d bd 05	sta $05bd,x			sta 	dataBuffer,x
.2a84	ee bc 05	inc $05bc			inc 	bufferSize
.2a87	fa		plx				plx
.2a88	60		rts				rts
.2a89					BufferOutput:
.2a89	ad bc 05	lda $05bc			lda 	bufferSize
.2a8c	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2a8f	a2 00		ldx #$00			ldx 	#0
.2a91					_BOLoop:
.2a91	ec bc 05	cpx $05bc			cpx 	bufferSize
.2a94	f0 09		beq $2a9f			beq 	_BOExit
.2a96	bd bd 05	lda $05bd,x			lda 	dataBuffer,x
.2a99	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2a9c	e8		inx				inx
.2a9d	80 f2		bra $2a91			bra 	_BOLoop
.2a9f					_BOExit:
.2a9f	60		rts				rts
.05bc					bufferSize:
>05bc							.fill 	1
.05bd					dataBuffer:
>05bd							.fill 	256
.2aa0					CheckNextComma:
.2aa0	a9 2c		lda #$2c			lda	 	#","
.2aa2	80 06		bra $2aaa			bra 	CheckNextA
.2aa4					CheckNextRParen:
.2aa4	a9 29		lda #$29			lda	 	#")"
.2aa6	80 02		bra $2aaa			bra 	CheckNextA
.2aa8					CheckNextLParen:
.2aa8	a9 28		lda #$28			lda 	#"("
.2aaa					CheckNextA:
.2aaa	8d bd 06	sta $06bd			sta 	checkCharacter 				; save test character
.2aad					_CNALoop:
.2aad	20 be 33	jsr $33be			jsr 	GetNextNonSpace 			; get next skipping spaces.
.2ab0	cd bd 06	cmp $06bd			cmp 	checkCharacter 				; matches ?
.2ab3	f0 03		beq $2ab8			beq 	_CNAExit
.2ab5	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.2ab8					_CNAExit:
.2ab8	60		rts				rts
.06bd					checkCharacter:
>06bd							.fill 	1
.2ab9					StartCompiler:
.2ab9	86 2c		stx $2c				stx 	zTemp0 						; access API
.2abb	84 2d		sty $2d				sty 	zTemp0+1
.2abd	a0 2d		ldy #$2d			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.2abf	a2 11		ldx #$11			ldx 	#CompilerErrorHandler & $FF
.2ac1	20 f5 1e	jsr $1ef5			jsr 	SetErrorHandler
.2ac4	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.2ac6	b2 2c		lda ($2c)			lda 	(zTemp0)
.2ac8	8d bf 06	sta $06bf			sta 	APIVector
.2acb	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2acd	8d c0 06	sta $06c0			sta 	APIVector+1
.2ad0	c8		iny				iny 								; copy data area range.
.2ad1	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ad3	8d c1 06	sta $06c1			sta 	compilerStartHigh
.2ad6	c8		iny				iny
.2ad7	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ad9	8d c2 06	sta $06c2			sta 	compilerEndHigh
.2adc	ba		tsx				tsx 								; save stack pointer
.2add	8e be 06	stx $06be			stx 	compilerSP
.2ae0	20 42 37	jsr $3742			jsr 	STRReset 					; reset storage (line#, variable)
.2ae3	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.2ae5	20 55 2b	jsr $2b55			jsr 	CallAPIHandler
.2ae8	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.2aea	20 55 2b	jsr $2b55			jsr 	CallAPIHandler
.2aed	a9 d5		lda #$d5			lda 	#PCD_CMD_VARSPACE
.2aef	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2af2	a9 00		lda #$00			lda 	#0
.2af4	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2af7	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2afa					MainCompileLoop:
.2afa	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.2afc	20 55 2b	jsr $2b55			jsr 	CallAPIHandler
.2aff	90 31		bcc $2b32			bcc 	SaveCodeAndExit 			; end of source.
.2b01	20 5c 2a	jsr $2a5c			jsr 	ProcessNewLine 				; set up pointer and line number.
.2b04	20 3b 2a	jsr $2a3b			jsr 	GetLineNumber 				; get line #
.2b07	20 2c 35	jsr $352c			jsr 	STRMarkLine 				; remember the code position and number of this line.
.2b0a	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.2b0c	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2b0f					_MCLSameLine:
.2b0f	20 be 33	jsr $33be			jsr 	GetNextNonSpace 			; get the first character.
.2b12	f0 e6		beq $2afa			beq 	MainCompileLoop 			; end of line, get next line.
.2b14	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.2b16	f0 f7		beq $2b0f			beq 	_MCLSameLine
.2b18	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.2b1a	10 0c		bpl $2b28			bpl 	_MCLCheckAssignment
.2b1c	a2 76		ldx #$76			ldx 	#CommandTables & $FF 		; do command tables.
.2b1e	a0 2f		ldy #$2f			ldy 	#CommandTables >> 8
.2b20	20 44 32	jsr $3244			jsr 	GeneratorProcess
.2b23	b0 ea		bcs $2b0f			bcs 	_MCLSameLine 				; keep trying to compile the line.
.2b25					_MCLSyntax:
.2b25	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.2b28					_MCLCheckAssignment:
.2b28	20 d4 33	jsr $33d4			jsr 	CharIsAlpha 				; if not alpha then syntax error
.2b2b	90 f8		bcc $2b25			bcc 	_MCLSyntax
.2b2d	20 fa 34	jsr $34fa			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.2b30	80 dd		bra $2b0f			bra		_MCLSameLine 				; loop back.
.2b32					SaveCodeAndExit:
.2b32	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.2b34	20 55 2b	jsr $2b55			jsr 	CallAPIHandler
.2b37	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.2b39	a8		tay				tay
.2b3a	20 2c 35	jsr $352c			jsr 	STRMarkLine
.2b3d	a9 c5		lda #$c5			lda 	#PCD_EXIT 					; add an END
.2b3f	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2b42	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.2b44	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2b47	20 6e 2e	jsr $2e6e			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.2b4a	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.2b4c	20 55 2b	jsr $2b55			jsr 	CallAPIHandler
.2b4f	18		clc				clc 								; CC = success
.2b50					ExitCompiler:
.2b50	ae be 06	ldx $06be			ldx 	compilerSP 					; reload SP and exit.
.2b53	9a		txs				txs
.2b54	60		rts				rts
.2b55					CallAPIHandler:
.2b55	6c bf 06	jmp ($06bf)			jmp 	(APIVector)
.06be					compilerSP:
>06be							.fill 	1
.06bf					APIVector:
>06bf							.fill 	2
.06c1					compilerStartHigh:
>06c1							.fill 	1
.06c2					compilerEndHigh:
>06c2							.fill 	1
.2b58					PushIntegerYA:
.2b58	c0 00		cpy #$00			cpy 	#0 							; 0-255
.2b5a	f0 0f		beq $2b6b			beq 	PushIntegerA
.2b5c	48		pha				pha
.2b5d	a9 cd		lda #$cd			lda 	#PCD_CMD_WORD 				; send .word
.2b5f	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2b62	68		pla				pla 								; then LSB
.2b63	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2b66	98		tya				tya 								; then MSB
.2b67	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2b6a	60		rts				rts
.2b6b					PushIntegerA:
.2b6b	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.2b6d	90 07		bcc $2b76			bcc 	_PIWriteA
.2b6f	48		pha				pha
.2b70	a9 cc		lda #$cc			lda 	#PCD_CMD_BYTE 				; send .byte
.2b72	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2b75	68		pla				pla
.2b76					_PIWriteA:
.2b76	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2b79	60		rts				rts
.2b7a					PushFloatCommand:
.2b7a	a9 ce		lda #$ce			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.2b7c	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2b7f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.2b81	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2b84	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2b86	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2b89	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2b8b	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2b8e	b5 56		lda $56,x			lda 	NSMantissa2,x
.2b90	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2b93	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.2b95	29 80		and #$80			and 	#$80
.2b97	15 62		ora $62,x			ora 	NSMantissa3,x
.2b99	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2b9c	60		rts				rts
.2b9d					CreateVariableRecord:
.2b9d	48		pha				pha
.2b9e	ad cd 06	lda $06cd			lda 	freeVariableMemory 		; push current free address on stack.
.2ba1	48		pha				pha
.2ba2	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2ba5	48		pha				pha
.2ba6	ad cb 06	lda $06cb			lda 	variableListEnd  		; copy end of list to zTemp0
.2ba9	85 2c		sta $2c				sta 	zTemp0
.2bab	ad cc 06	lda $06cc			lda 	variableListEnd+1
.2bae	85 2d		sta $2d				sta 	zTemp0+1
.2bb0	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.2bb2	92 2c		sta ($2c)			sta 	(zTemp0)
.2bb4	98		tya				tya
.2bb5	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.2bb7	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bb9	88		dey				dey
.2bba	8a		txa				txa
.2bbb	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bbd	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.2bbf	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2bc2	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bc4	c8		iny				iny
.2bc5	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2bc8	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bca	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.2bcc	a9 00		lda #$00			lda 	#0
.2bce	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bd0	18		clc				clc
.2bd1	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.2bd3	6d cb 06	adc $06cb			adc  	variableListEnd
.2bd6	8d cb 06	sta $06cb			sta 	variableListEnd
.2bd9	90 03		bcc $2bde			bcc 	_CVNoCarry2
.2bdb	ee cc 06	inc $06cc			inc 	variableListEnd+1
.2bde					_CVNoCarry2:
.2bde	7a		ply				ply
.2bdf	fa		plx				plx
.2be0	68		pla				pla
.2be1	60		rts				rts
.2be2					SetVariableRecordToCodePosition:
.2be2	48		pha				pha
.2be3	5a		phy				phy
.2be4	a0 03		ldy #$03			ldy 	#3
.2be6	a5 2b		lda $2b				lda 	objPtr+1
.2be8	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bea	c8		iny				iny
.2beb	a5 2a		lda $2a				lda 	objPtr
.2bed	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bef	7a		ply				ply
.2bf0	68		pla				pla
.2bf1	60		rts				rts
.2bf2					AllocateBytesForType:
.2bf2	48		pha				pha
.2bf3	da		phx				phx
.2bf4	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.2bf6	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2bf8	c9 00		cmp #$00			cmp 	#NSSIFloat
.2bfa	d0 02		bne $2bfe			bne 	_CVNotFloat
.2bfc	a2 06		ldx #$06			ldx 	#6
.2bfe					_CVNotFloat:
.2bfe	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.2bff	18		clc				clc
.2c00	6d cd 06	adc $06cd			adc 	freeVariableMemory
.2c03	8d cd 06	sta $06cd			sta 	freeVariableMemory
.2c06	90 03		bcc $2c0b			bcc 	_CVNoCarry1
.2c08	ee ce 06	inc $06ce			inc 	freeVariableMemory+1
.2c0b					_CVNoCarry1:
.2c0b	fa		plx				plx
.2c0c	68		pla				pla
.2c0d	60		rts				rts
.2c0e					CommandDATA:
.2c0e	20 79 2a	jsr $2a79			jsr 	BufferClear 				; copy it to the buffer
.2c11	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace
.2c14					_CTDataLoop:
.2c14	20 a2 33	jsr $33a2			jsr 	LookNext 					; reached EOL
.2c17	f0 08		beq $2c21			beq 	_CTDataDone
.2c19	20 7d 2a	jsr $2a7d			jsr 	BufferWrite 				; write and consume
.2c1c	20 b3 33	jsr $33b3			jsr 	GetNext
.2c1f	80 f3		bra $2c14			bra 	_CTDataLoop
.2c21					_CTDataDone:
.2c21	a9 d0		lda #$d0			lda 	#PCD_CMD_DATA 				; output command and buffer
.2c23	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2c26	20 89 2a	jsr $2a89			jsr 	BufferOutput
.2c29	60		rts				rts
.2c2a					CommandDEF:
.2c2a	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.2c2c	20 6b 2b	jsr $2b6b			jsr 	PushIntegerA
.2c2f	20 c3 34	jsr $34c3			jsr 	CompileGotoEOL 				; compile skip over DEF
.2c32	a9 a5		lda #$a5			lda 	#C64_FN
.2c34	20 aa 2a	jsr $2aaa			jsr 	CheckNextA
.2c37	20 be 33	jsr $33be			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2c3a	20 23 34	jsr $3423			jsr 	ExtractVariableName
.2c3d	8a		txa				txa
.2c3e	10 51		bpl $2c91			bpl 	_CDError
.2c40	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2c41	29 7f		and #$7f			and 	#$7F
.2c43	aa		tax				tax
.2c44	98		tya				tya
.2c45	09 80		ora #$80			ora 	#$80
.2c47	a8		tay				tay
.2c48	20 12 2e	jsr $2e12			jsr 	FindVariable				; does it already exist ?
.2c4b	b0 44		bcs $2c91			bcs 	_CDError 					; if so, that's an error.
.2c4d	20 9d 2b	jsr $2b9d			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.2c50	20 e2 2b	jsr $2be2			jsr 	SetVariableRecordToCodePosition
.2c53	20 be 33	jsr $33be			jsr 	GetNextNonSpace
.2c56	20 ff 36	jsr $36ff			jsr 	GetReferenceTerm 			; get var ref, not array
.2c59	c9 00		cmp #$00			cmp 	#0
.2c5b	30 34		bmi $2c91			bmi 	_CDError
.2c5d	8d c3 06	sta $06c3			sta 	defType 					; save type
.2c60	8e c4 06	stx $06c4			stx 	defVariable 				; save var ref
.2c63	8c c5 06	sty $06c5			sty 	defVariable+1
.2c66	29 40		and #$40			and 	#NSSString 					; only numbers.
.2c68	d0 27		bne $2c91			bne 	_CDError
.2c6a	20 a4 2a	jsr $2aa4			jsr 	CheckNextRParen 			; check )
.2c6d	a9 b2		lda #$b2			lda 	#C64_EQUAL
.2c6f	20 aa 2a	jsr $2aaa			jsr 	CheckNextA 					; check =
.2c72	18		clc				clc 								; if this is DEF FNxx(A), read A
.2c73	20 94 2c	jsr $2c94			jsr 	CDReadWriteVariable
.2c76	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.2c78	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2c7b	38		sec				sec
.2c7c	20 94 2c	jsr $2c94			jsr 	CDReadWriteVariable 		; A is now updated
.2c7f	20 58 2d	jsr $2d58			jsr 	CompileExpressionAt0 		; the actual body of the function.
.2c82	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.2c84	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2c87	38		sec				sec
.2c88	20 94 2c	jsr $2c94			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.2c8b	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.2c8d	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2c90	60		rts				rts
.2c91					_CDError:
.2c91	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.2c94					CDReadWriteVariable:
.2c94	ac c5 06	ldy $06c5			ldy 	defVariable+1 				; set up YX
.2c97	ae c4 06	ldx $06c4			ldx 	defVariable
.2c9a	ad c3 06	lda $06c3			lda 	defType
.2c9d	20 b1 36	jsr $36b1			jsr 	GetSetVariable
.2ca0	60		rts				rts
.06c3					defType:
>06c3							.fill 	1
.06c4					defVariable:
>06c4							.fill 	2
.2ca1					CommandDIM:
.2ca1	20 be 33	jsr $33be			jsr 	GetNextNonSpace 			; get the first non space character
.2ca4	20 23 34	jsr $3423			jsr 	ExtractVariableName 		; variable name to XY
.2ca7	da		phx				phx 								; save name with type bits.
.2ca8	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.2caa	10 37		bpl $2ce3			bpl 	_CDError
.2cac	20 12 2e	jsr $2e12			jsr 	FindVariable	 			; see if already exist
.2caf	b0 35		bcs $2ce6			bcs 	_CDRedefine 				; it still exists.
.2cb1	20 9d 2b	jsr $2b9d			jsr 	CreateVariableRecord 		; create the basic variable
.2cb4	20 f2 2b	jsr $2bf2			jsr 	AllocateBytesForType 		; allocate memory for it
.2cb7	68		pla				pla 								; restore type bits
.2cb8	5a		phy				phy 								; save the address of the basic storage
.2cb9	da		phx				phx
.2cba	48		pha				pha
.2cbb	20 e9 2c	jsr $2ce9			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.2cbe	68		pla				pla
.2cbf	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.2cc1	20 6b 2b	jsr $2b6b			jsr 	PushIntegerA 				; push that type data out.
.2cc4	a9 cb		lda #$cb			lda 	#(PCD_DIM) >> 8
.2cc6	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2cc9	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.2ccb	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2cce	fa		plx				plx 								; restore address
.2ccf	7a		ply				ply
.2cd0	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2cd2	38		sec				sec
.2cd3	20 b1 36	jsr $36b1			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.2cd6	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; , follows ?
.2cd9	c9 2c		cmp #$2c			cmp 	#","
.2cdb	d0 05		bne $2ce2			bne 	_CDExit
.2cdd	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume comma
.2ce0	80 bf		bra $2ca1			bra 	CommandDIM 					; do another DIM
.2ce2					_CDExit:
.2ce2	60		rts				rts
.2ce3					_CDError:
.2ce3	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.2ce6					_CDRedefine:
.2ce6	4c e4 1f	jmp $1fe4		jmp	ErrorV_redefine
.2ce9					OutputIndexGroup:
.2ce9	9c c6 06	stz $06c6			stz 	IndexCount 					; count of number of indices.
.2cec					_OIGNext:
.2cec	20 58 2d	jsr $2d58			jsr 	CompileExpressionAt0 		; get a dimension
.2cef	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2cf1	c9 00		cmp #$00			cmp 	#NSSIFloat
.2cf3	d0 19		bne $2d0e			bne 	_OIGType
.2cf5	ee c6 06	inc $06c6			inc 	IndexCount 					; bump the counter.
.2cf8	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; does a , follow ?
.2cfb	c9 2c		cmp #$2c			cmp 	#","
.2cfd	d0 05		bne $2d04			bne 	_OIGCheckEnd
.2cff	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume comma
.2d02	80 e8		bra $2cec			bra 	_OIGNext 					; get next dimension
.2d04					_OIGCheckEnd:
.2d04	20 a4 2a	jsr $2aa4			jsr 	CheckNextRParen 			; check and consume )
.2d07	ad c6 06	lda $06c6			lda 	IndexCount
.2d0a	20 6b 2b	jsr $2b6b			jsr 	PushIntegerA 				; compile the dimension count.
.2d0d	60		rts				rts
.2d0e					_OIGType:
.2d0e	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.06c6					IndexCount:
>06c6							.fill 	1
.2d11					CompilerErrorHandler:
.2d11	68		pla				pla
.2d12	7a		ply				ply
.2d13	85 2c		sta $2c				sta 	zTemp0
.2d15	84 2d		sty $2d				sty 	zTemp0+1
.2d17	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.2d19	a0 01		ldy #$01			ldy 	#1
.2d1b					_EHDisplayMsg:
.2d1b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d1d	20 4f 2a	jsr $2a4f			jsr 	PrintCharacter
.2d20	c8		iny				iny
.2d21	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d23	d0 f6		bne $2d1b			bne 	_EHDisplayMsg
.2d25	a9 20		lda #$20			lda 	#32
.2d27	20 4f 2a	jsr $2a4f			jsr 	PrintCharacter
.2d2a	a9 40		lda #$40			lda 	#64
.2d2c	20 4f 2a	jsr $2a4f			jsr 	PrintCharacter
.2d2f	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.2d31	20 75 26	jsr $2675			jsr 	FloatSetByte
.2d34	20 3b 2a	jsr $2a3b			jsr 	GetLineNumber
.2d37	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2d39	98		tya				tya
.2d3a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2d3c	20 5b 25	jsr $255b			jsr 	FloatToString
.2d3f	a0 00		ldy #$00			ldy 	#0 							; display that string.
.2d41	a2 00		ldx #$00			ldx 	#0
.2d43					_EHDisplayLine:
.2d43	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d46	20 4f 2a	jsr $2a4f			jsr 	PrintCharacter
.2d49	c8		iny				iny
.2d4a	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d4d	d0 f4		bne $2d43			bne 	_EHDisplayLine
.2d4f	a9 0d		lda #$0d			lda 	#13
.2d51	20 4f 2a	jsr $2a4f			jsr 	PrintCharacter
.2d54	38		sec				sec 								; CS = error
.2d55	4c 50 2b	jmp $2b50			jmp 	ExitCompiler
.2d58					CompileExpressionAt0:
.2d58	a9 00		lda #$00			lda 	#0
.2d5a					CompileExpressionAtA:
.2d5a	48		pha				pha  								; save level
.2d5b	20 6a 37	jsr $376a			jsr 	CompileTerm 				; compile a term.
.2d5e	fa		plx				plx 								; get level back into X
.2d5f					_ECALoop:
.2d5f	48		pha				pha 								; save type on stack.
.2d60	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; get the next character
.2d63	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.2d65	90 04		bcc $2d6b			bcc 	_ECAExit
.2d67	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.2d69	90 02		bcc $2d6d			bcc 	_ECAHaveToken
.2d6b					_ECAExit:
.2d6b	68		pla				pla 								; throw type off stack
.2d6c	60		rts				rts
.2d6d					_ECAHaveToken:
.2d6d	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.2d6f	aa		tax				tax 								; X contains the operator token
.2d70	bd 5b 2d	lda $2d5b,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.2d73	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.2d75	90 f4		bcc $2d6b			bcc 	_ECAExit
.2d77	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.2d79	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume the token.
.2d7c	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.2d7e	f0 11		beq $2d91			beq 	_ECAGreaterCheck
.2d80	e0 b3		cpx #$b3			cpx 	#C64_LESS
.2d82	d0 1a		bne $2d9e			bne 	_ECAHaveFullToken
.2d84	20 a2 33	jsr $33a2			jsr 	LookNext 					; checks for < (<= or <>)
.2d87	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.2d89	f0 0e		beq $2d99			beq	 	_ECAToNotEqual
.2d8b	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.2d8d	d0 0f		bne $2d9e			bne 	_ECAHaveFullToken
.2d8f	80 07		bra $2d98			bra 	_ECAAddEqual
.2d91					_ECAGreaterCheck:
.2d91	20 a2 33	jsr $33a2			jsr 	LookNext
.2d94	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.2d96	d0 06		bne $2d9e			bne 	_ECAHaveFullToken
.2d98					_ECAAddEqual:
.2d98	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.2d99					_ECAToNotEqual:
.2d99	e8		inx				inx
.2d9a	e8		inx				inx
.2d9b	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume the = or > in >= <= <>
.2d9e					_ECAHaveFullToken:
.2d9e	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.2da0	d0 0a		bne $2dac			bne 	_ECANotConcat
.2da2	68		pla				pla 								; get type back
.2da3	48		pha				pha
.2da4	29 40		and #$40			and 	#NSSTypeMask
.2da6	c9 40		cmp #$40			cmp 	#NSSString
.2da8	d0 02		bne $2dac			bne 	_ECANotConcat
.2daa	a2 e0		ldx #$e0			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2dac					_ECANotConcat:
.2dac	da		phx				phx 								; save operator on the stack
.2dad	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.2daf	da		phx				phx
.2db0	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.2db2	1a		inc a				inc 	a
.2db3	20 5a 2d	jsr $2d5a			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.2db6	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.2db8	fa		plx				plx 								; restore current precedence in X
.2db9	68		pla				pla 								; restore operator
.2dba	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.2dbc	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.2dbe	90 17		bcc $2dd7			bcc 	_ECANotCompare
.2dc0	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.2dc2	b0 13		bcs $2dd7			bcs 	_ECANotCompare
.2dc4	7a		ply				ply 								; get type into Y
.2dc5	5a		phy				phy
.2dc6	48		pha				pha 								; save operator
.2dc7	98		tya				tya 								; get type
.2dc8	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.2dca	29 40		and #$40			and 	#NSSTypeMask
.2dcc	c9 40		cmp #$40			cmp 	#NSSString
.2dce	f0 02		beq $2dd2			beq 	_ECANotString
.2dd0	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.2dd2					_ECANotString:
.2dd2	98		tya				tya									; output token Y
.2dd3	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2dd6	68		pla				pla 								; restore operator.
.2dd7					_ECANotCompare:
.2dd7	18		clc				clc 								; convert to P-Code and compile.
.2dd8	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.2dda	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2ddd	68		pla				pla 								; type of current result
.2dde	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.2de0	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.2de2	d0 19		bne $2dfd			bne		_ECAType
.2de4	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.2de6	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.2de8	d0 18		bne $2e02			bne 	_ECAGoLoop
.2dea	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.2dec	c9 e0		cmp #$e0			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2dee	f0 10		beq $2e00			beq 	_ECAOkayString 				; (this is post conversion)
.2df0	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.2df2	90 09		bcc $2dfd			bcc 	_ECAType
.2df4	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.2df6	b0 05		bcs $2dfd			bcs 	_ECAType
.2df8	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.2dfa	4c 5f 2d	jmp $2d5f			jmp 	_ECALoop
.2dfd					_ECAType:
.2dfd	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.2e00					_ECAOkayString:
.2e00	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.2e02					_ECAGoLoop:
.2e02	4c 5f 2d	jmp $2d5f			jmp 	_ECALoop
.2e05					PrecedenceTable:
>2e05	03						.byte 	3 					; '+'
>2e06	03						.byte 	3 					; '-'
>2e07	04						.byte 	4 					; '*'
>2e08	04						.byte 	4 					; '/'
>2e09	05						.byte 	5 					; '^'
>2e0a	01						.byte 	1 					; 'and'
>2e0b	00						.byte 	0 					; 'or'
>2e0c	02						.byte 	2 					; '>'
>2e0d	02						.byte 	2 					; '='
>2e0e	02						.byte 	2 					; '<'
>2e0f	02						.byte 	2 					; '>='
>2e10	02						.byte 	2 					; '<='
>2e11	02						.byte 	2 					; '<>'
.2e12					FindVariable:
.2e12	86 2e		stx $2e				stx 	zTemp1 						; save name.
.2e14	84 2f		sty $2f				sty 	zTemp1+1
.2e16					_IVCheckSpecial:
.2e16	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.2e18	d0 18		bne $2e32			bne 	_IVStandard
.2e1a	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.2e1c	f0 0c		beq $2e2a			beq 	_IVTIFloat
.2e1e	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.2e20	d0 10		bne $2e32			bne 	_IVStandard
.2e22	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.2e24	a2 01		ldx #$01			ldx 	#$01
.2e26	a9 40		lda #$40			lda 	#NSSString
.2e28	38		sec				sec
.2e29	60		rts				rts
.2e2a					_IVTIFloat:
.2e2a	a0 80		ldy #$80			ldy 	#$80
.2e2c	a2 00		ldx #$00			ldx 	#$00
.2e2e	a9 00		lda #$00			lda 	#0
.2e30	38		sec				sec
.2e31	60		rts				rts
.2e32					_IVStandard:
.2e32	ad c1 06	lda $06c1			lda 	compilerStartHigh			; start scanning from here.
.2e35	85 2d		sta $2d				sta 	zTemp0+1
.2e37	64 2c		stz $2c				stz 	zTemp0
.2e39					_IVCheckLoop:
.2e39	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.2e3b	f0 2b		beq $2e68			beq  	_IVNotFound 				; if so, return with CC.
.2e3d	a0 01		ldy #$01			ldy 	#1 							; match ?
.2e3f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e41	c5 2e		cmp $2e				cmp 	zTemp1
.2e43	d0 07		bne $2e4c			bne	 	_IVNext
.2e45	c8		iny				iny
.2e46	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e48	c5 2f		cmp $2f				cmp 	zTemp1+1
.2e4a	f0 0d		beq $2e59			beq 	_IVFound
.2e4c					_IVNext:
.2e4c	18		clc				clc
.2e4d	a5 2c		lda $2c				lda 	zTemp0
.2e4f	72 2c		adc ($2c)			adc 	(zTemp0)
.2e51	85 2c		sta $2c				sta 	zTemp0
.2e53	90 e4		bcc $2e39			bcc 	_IVCheckLoop
.2e55	e6 2d		inc $2d				inc 	zTemp0+1
.2e57	80 e0		bra $2e39			bra 	_IVCheckLoop
.2e59					_IVFound:
.2e59	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.2e5b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e5d	aa		tax				tax
.2e5e	c8		iny				iny
.2e5f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e61	48		pha				pha
.2e62	c8		iny				iny
.2e63	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e65	7a		ply				ply
.2e66	38		sec				sec
.2e67	60		rts				rts
.2e68					_IVNotFound:
.2e68	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.2e6a	a4 2f		ldy $2f				ldy 	zTemp1+1
.2e6c	18		clc				clc
.2e6d	60		rts				rts
.2e6e					FixBranches:
.2e6e	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.2e70	20 55 2b	jsr $2b55			jsr 	CallAPIHandler
.2e73					_FBLoop:
.2e73	b2 2a		lda ($2a)			lda 	(objPtr) 					; get the next one.
.2e75	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.2e77	f0 16		beq $2e8f			beq 	_FBFixGotoGosub
.2e79	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOSUB
.2e7b	f0 12		beq $2e8f			beq 	_FBFixGotoGosub
.2e7d	c9 d4		cmp #$d4			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.2e7f	f0 0e		beq $2e8f			beq 	_FBFixGotoGosub
.2e81	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_Z
.2e83	f0 0a		beq $2e8f			beq 	_FBFixGotoGosub
.2e85	c9 d5		cmp #$d5			cmp 	#PCD_CMD_VARSPACE
.2e87	f0 3b		beq $2ec4			beq 	_FBFixVarSpace
.2e89					_FBNext:
.2e89	20 42 20	jsr $2042			jsr 	MoveObjectForward 			; move forward in object code.
.2e8c	90 e5		bcc $2e73			bcc 	_FBLoop 					; not finished
.2e8e					_FBExit:
.2e8e	60		rts				rts
.2e8f					_FBFixGotoGosub:
.2e8f	a0 01		ldy #$01			ldy 	#1							; line number in YA
.2e91	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e93	48		pha				pha
.2e94	c8		iny				iny
.2e95	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e97	a8		tay				tay
.2e98	68		pla				pla
.2e99	20 55 35	jsr $3555			jsr 	STRFindLine			 		; find where it is YA
.2e9c	90 08		bcc $2ea6			bcc 	_FBFFound 					; not found, so must be >
.2e9e	48		pha				pha
.2e9f	b2 2a		lda ($2a)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.2ea1	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_Z
.2ea3	d0 0f		bne $2eb4			bne 	_FBFFail
.2ea5	68		pla				pla
.2ea6					_FBFFound:
.2ea6	20 a5 35	jsr $35a5			jsr 	STRMakeOffset 				; make it an offset from X:YA
.2ea9	5a		phy				phy	 								; patch the GOTO/GOSUB
.2eaa	a0 01		ldy #$01			ldy 	#1
.2eac	91 2a		sta ($2a),y			sta 	(objPtr),y
.2eae	c8		iny				iny
.2eaf	68		pla				pla
.2eb0	91 2a		sta ($2a),y			sta 	(objPtr),y
.2eb2	80 d5		bra $2e89			bra 	_FBNext
.2eb4					_FBFFail:
.2eb4	a0 02		ldy #$02			ldy 	#2
.2eb6	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2eb8	8d ba 05	sta $05ba			sta 	currentLineNumber
.2ebb	c8		iny				iny
.2ebc	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ebe	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2ec1	4c 5f 1f	jmp $1f5f		jmp	ErrorV_line
.2ec4					_FBFixVarSpace:
.2ec4	a0 01		ldy #$01			ldy 	#1
.2ec6	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2ec9	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ecb	c8		iny				iny
.2ecc	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2ecf	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ed1	80 b6		bra $2e89			bra 	_FBNext
.2ed3					CommandFOR:
.2ed3	20 be 33	jsr $33be			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.2ed6	20 d4 33	jsr $33d4			jsr 	CharIsAlpha 				; if not alpha , error
.2ed9	90 59		bcc $2f34			bcc 	_CFFail
.2edb	20 ff 36	jsr $36ff			jsr 	GetReferenceTerm 			; figure out the reference.
.2ede	48		pha				pha 								; save type
.2edf	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ee1	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ee3	d0 4f		bne $2f34			bne 	_CFFail
.2ee5	5a		phy				phy 								; save reference on the stack
.2ee6	da		phx				phx
.2ee7	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.2ee9	20 aa 2a	jsr $2aaa			jsr 	CheckNextA
.2eec	20 58 2d	jsr $2d58			jsr 	CompileExpressionAt0 		; initial value
.2eef	fa		plx				plx 								; get reference back.
.2ef0	7a		ply				ply
.2ef1	5a		phy				phy
.2ef2	da		phx				phx
.2ef3	38		sec				sec 								; set initial value.
.2ef4	20 b1 36	jsr $36b1			jsr 	GetSetVariable
.2ef7	fa		plx				plx
.2ef8	7a		ply				ply
.2ef9	68		pla				pla
.2efa	29 20		and #$20			and 	#NSSIInt16
.2efc	f0 04		beq $2f02			beq 	_CFNotInt16
.2efe	98		tya				tya
.2eff	09 80		ora #$80			ora 	#$80
.2f01	a8		tay				tay
.2f02					_CFNotInt16:
.2f02	8a		txa				txa 								; reference in YA
.2f03	20 58 2b	jsr $2b58			jsr 	PushIntegerYA
.2f06	a9 a4		lda #$a4			lda 	#C64_TO
.2f08	20 aa 2a	jsr $2aaa			jsr 	CheckNextA
.2f0b	20 58 2d	jsr $2d58			jsr 	CompileExpressionAt0 		; terminal value
.2f0e	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f10	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f12	d0 20		bne $2f34			bne 	_CFFail
.2f14	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; followed by STEP
.2f17	c9 a9		cmp #$a9			cmp 	#C64_STEP
.2f19	d0 0e		bne $2f29			bne 	_CFNoStep
.2f1b	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume it.
.2f1e	20 58 2d	jsr $2d58			jsr 	CompileExpressionAt0 		; terminal value
.2f21	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f23	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f25	d0 0d		bne $2f34			bne 	_CFFail
.2f27	80 05		bra $2f2e			bra 	_CFParametersDone
.2f29					_CFNoStep:
.2f29	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.2f2b	20 6b 2b	jsr $2b6b			jsr 	PushIntegerA
.2f2e					_CFParametersDone:
.2f2e	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2f30	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2f33	60		rts				rts
.2f34					_CFFail:
.2f34	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.2f37					FNCompile:
.2f37	20 be 33	jsr $33be			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2f3a	20 23 34	jsr $3423			jsr 	ExtractVariableName
.2f3d	e0 00		cpx #$00			cpx 	#0
.2f3f	10 32		bpl $2f73			bpl 	_FNError
.2f41	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2f42	29 7f		and #$7f			and 	#$7F
.2f44	aa		tax				tax
.2f45	98		tya				tya
.2f46	09 80		ora #$80			ora 	#$80
.2f48	a8		tay				tay
.2f49	20 12 2e	jsr $2e12			jsr 	FindVariable				; does it already exist ?
.2f4c	90 25		bcc $2f73			bcc 	_FNError 					; no.
.2f4e	20 a5 35	jsr $35a5			jsr 	STRMakeOffset 				; convert to a relative address.
.2f51	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2f53	d0 01		bne $2f56			bne 	_FNNoBorrow
.2f55	88		dey				dey
.2f56					_FNNoBorrow:
.2f56	3a		dec a				dec 	a
.2f57	5a		phy				phy 								; save location of routine on stack.
.2f58	48		pha				pha
.2f59	da		phx				phx
.2f5a	20 58 2d	jsr $2d58			jsr 	CompileExpressionAt0
.2f5d	20 a4 2a	jsr $2aa4			jsr 	CheckNextRParen
.2f60	a9 d2		lda #$d2			lda 	#PCD_CMD_GOSUB
.2f62	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2f65	68		pla				pla
.2f66	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2f69	68		pla				pla
.2f6a	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2f6d	68		pla				pla
.2f6e	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.2f71	18		clc				clc
.2f72	60		rts				rts
.2f73					_FNError:
.2f73	4c 0f 1f	jmp $1f0f		jmp	ErrorV_value
.2f76					CommandTables:
>2f76	07 cb 00 03 81 34 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2f7d	07 89 00 03 88 34 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2f84	07 8d 00 03 7b 34 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>2f8b	07 88 00 03 f7 34 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2f92	07 85 00 03 d7 34 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>2f99	07 84 00 04 eb 34 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>2fa0	07 99 00 03 2c 36 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2fa7	07 98 00 04 2c 36 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2fae	07 8f 00 03 37 37 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>2fb5	07 81 00 03 d3 2e 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>2fbc	07 82 00 03 af 35 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>2fc3	07 a1 00 03 f4 33 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>2fca	07 83 00 03 0e 2c 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>2fd1	07 87 00 03 75 36 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>2fd8	07 86 00 03 a1 2c 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>2fdf	07 96 00 03 2a 2c 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>2fe6	07 8b 00 e3 a4 34 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>2fed	08 92 00 ea e3 03 38 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>2ff5	09 91 00 e1 a9 03 db 35			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>2ffd	06
>2ffe	07 9e 00 e2 cb 92 06			.byte	$07,$9e,$00,$e2,37579 & $FF,37579 >> 8,$06
>3005	07 97 00 ea e1 ad 06			.byte	$07,$97,$00,$ea,$e1,173,$06
>300c	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>3012	07 90 00 20 cb 91 06			.byte	$07,$90,$00,$20,37323 & $FF,37323 >> 8,$06
>3019	07 80 00 20 cb 82 06			.byte	$07,$80,$00,$20,33483 & $FF,33483 >> 8,$06
>3020	07 8c 00 20 cb 90 06			.byte	$07,$8c,$00,$20,37067 & $FF,37067 >> 8,$06
>3027	07 9d 00 e3 29 38 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>302e	0a 9f 00 ea e3 3c 38 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,199,$06
>3036	c7 06
>3038	06 a0 00 e1 c4 06			.byte	$06,$a0,$00,$e1,196,$06
>303e	07 ce 90 20 cb ac 06			.byte	$07,$ce,$90,$20,44235 & $FF,44235 >> 8,$06
>3045	0a ce 92 e3 71 33 20 cb			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44491 & $FF,44491 >> 8,$06
>304d	ad 06
>304f	0a ce 8d e3 71 33 20 cb			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44747 & $FF,44747 >> 8,$06
>3057	ae 06
>3059	06 ce 86 e1 c8 06			.byte	$06,$ce,$86,$e1,200,$06
>305f	08 ce 84 ea ea e1 c9 06			.byte	$08,$ce,$84,$ea,$ea,$e1,201,$06
>3067	07 ce af e2 cb 98 06			.byte	$07,$ce,$af,$e2,39115 & $FF,39115 >> 8,$06
>306e	07 ce 8c e2 cb 8c 06			.byte	$07,$ce,$8c,$e2,36043 & $FF,36043 >> 8,$06
>3075	09 ce ae ea ea e2 cb 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38347 & $FF,38347 >> 8,$06
>307d	06
>307e	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>3086	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>308e	9a 06
>3090	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>3098	9b 06
>309a	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>30a2	9c 06
>30a4	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>30ac	06
>30ad	07 ce 99 20 cb 99 06			.byte	$07,$ce,$99,$20,39371 & $FF,39371 >> 8,$06
>30b4	08 ce 9a ea e2 cb 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39627 & $FF,39627 >> 8,$06
>30bc	08 ce 9b ea e2 cb 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39883 & $FF,39883 >> 8,$06
>30c4	08 ce 9c ea e2 cb 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40139 & $FF,40139 >> 8,$06
>30cc	08 ce 9d ea e2 cb 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40395 & $FF,40395 >> 8,$06
>30d4	08 ce 9e ea e2 cb 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40651 & $FF,40651 >> 8,$06
>30dc	08 ce 9f ea e2 cb 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40907 & $FF,40907 >> 8,$06
>30e4	08 ce a0 ea e2 cb a0 06			.byte	$08,$ce,$a0,$ea,$e2,41163 & $FF,41163 >> 8,$06
>30ec	08 ce a1 ea f2 cb a1 06			.byte	$08,$ce,$a1,$ea,$f2,41419 & $FF,41419 >> 8,$06
>30f4	08 ce a2 ea f2 cb a2 06			.byte	$08,$ce,$a2,$ea,$f2,41675 & $FF,41675 >> 8,$06
>30fc	08 ce a3 ea e2 cb a3 06			.byte	$08,$ce,$a3,$ea,$e2,41931 & $FF,41931 >> 8,$06
>3104	07 ce a4 20 cb a4 06			.byte	$07,$ce,$a4,$20,42187 & $FF,42187 >> 8,$06
>310b	08 ce a5 ea e2 cb a5 06			.byte	$08,$ce,$a5,$ea,$e2,42443 & $FF,42443 >> 8,$06
>3113	08 ce a6 ea e2 cb a6 06			.byte	$08,$ce,$a6,$ea,$e2,42699 & $FF,42699 >> 8,$06
>311b	08 ce a7 ea e2 cb a7 06			.byte	$08,$ce,$a7,$ea,$e2,42955 & $FF,42955 >> 8,$06
>3123	08 ce a8 ea e2 cb a8 06			.byte	$08,$ce,$a8,$ea,$e2,43211 & $FF,43211 >> 8,$06
>312b	08 ce a9 ea e2 cb a9 06			.byte	$08,$ce,$a9,$ea,$e2,43467 & $FF,43467 >> 8,$06
>3133	08 ce aa ea f2 cb aa 06			.byte	$08,$ce,$aa,$ea,$f2,43723 & $FF,43723 >> 8,$06
>313b	08 ce ab ea f2 cb ab 06			.byte	$08,$ce,$ab,$ea,$f2,43979 & $FF,43979 >> 8,$06
>3143	00						.byte 	0
.3144					UnaryTables:
>3144	07 b4 00 8e 91 b7 06			.byte	$07,$b4,$00,$8e,$91,183,$06
>314b	08 b5 00 8e 92 cb 84 06			.byte	$08,$b5,$00,$8e,$92,33995 & $FF,33995 >> 8,$06
>3153	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>315a	07 b7 00 8e 91 c2 06			.byte	$07,$b7,$00,$8e,$91,194,$06
>3161	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>3168	07 b9 00 8e 91 ae 06			.byte	$07,$b9,$00,$8e,$91,174,$06
>316f	08 ba 00 8e 92 cb 85 06			.byte	$08,$ba,$00,$8e,$92,34251 & $FF,34251 >> 8,$06
>3177	07 bb 00 8e 91 b5 06			.byte	$07,$bb,$00,$8e,$91,181,$06
>317e	08 bc 00 8e 92 cb 86 06			.byte	$08,$bc,$00,$8e,$92,34507 & $FF,34507 >> 8,$06
>3186	08 bd 00 8e 92 cb 87 06			.byte	$08,$bd,$00,$8e,$92,34763 & $FF,34763 >> 8,$06
>318e	08 be 00 8e 92 cb 88 06			.byte	$08,$be,$00,$8e,$92,35019 & $FF,35019 >> 8,$06
>3196	08 bf 00 8e 92 cb 89 06			.byte	$08,$bf,$00,$8e,$92,35275 & $FF,35275 >> 8,$06
>319e	08 c0 00 8e 92 cb 8a 06			.byte	$08,$c0,$00,$8e,$92,35531 & $FF,35531 >> 8,$06
>31a6	08 c1 00 8e 92 cb 8b 06			.byte	$08,$c1,$00,$8e,$92,35787 & $FF,35787 >> 8,$06
>31ae	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>31b5	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>31bc	07 c4 00 8e 91 bb 07			.byte	$07,$c4,$00,$8e,$91,187,$07
>31c3	07 c5 00 8f 91 c3 06			.byte	$07,$c5,$00,$8f,$91,195,$06
>31ca	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>31d1	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>31d8	08 c8 00 8f ae 91 bc 07			.byte	$08,$c8,$00,$8f,$ae,$91,188,$07
>31e0	08 c9 00 8f ae 91 bd 07			.byte	$08,$c9,$00,$8f,$ae,$91,189,$07
>31e8	0b ca 00 8f ae 03 71 33			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,190,$07
>31f0	91 be 07
>31f3	07 a8 00 03 90 33 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>31fa	07 a5 00 03 37 2f 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>3201	06 ff 00 10 ac 06			.byte	$06,$ff,$00,$10,172,$06
>3207	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>320e	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>3215	08 ce d0 8e ae 91 ca 06			.byte	$08,$ce,$d0,$8e,$ae,$91,202,$06
>321d	08 ce d4 8e 92 cb 83 06			.byte	$08,$ce,$d4,$8e,$92,33739 & $FF,33739 >> 8,$06
>3225	07 ce d3 20 cb 8d 06			.byte	$07,$ce,$d3,$20,36299 & $FF,36299 >> 8,$06
>322c	07 ce d1 20 cb 8e 06			.byte	$07,$ce,$d1,$20,36555 & $FF,36555 >> 8,$06
>3233	07 ce d2 20 cb 8f 06			.byte	$07,$ce,$d2,$20,36811 & $FF,36811 >> 8,$06
>323a	09 ce d7 8e ae 92 cb 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38603 & $FF,38603 >> 8,$06
>3242	06
>3243	00						.byte 	0
.3244					GeneratorProcess:
.3244	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.3246	84 2d		sty $2d				sty 	zTemp0+1
.3248	85 2e		sta $2e				sta 	zTemp1 						; first match token
.324a	64 2f		stz $2f				stz 	zTemp1+1
.324c	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.324e	d0 05		bne $3255			bne 	_GPNotShifted
.3250	20 b3 33	jsr $33b3			jsr 	GetNext 					; get the shifted token
.3253	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.3255					_GPNotShifted:
.3255					_GPSearch:
.3255	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.3257	18		clc				clc
.3258	f0 2f		beq $3289			beq 	_GPExit
.325a	a0 01		ldy #$01			ldy 	#1 							; tokens match
.325c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.325e	c5 2e		cmp $2e				cmp 	zTemp1
.3260	d0 09		bne $326b			bne 	_GPNext
.3262	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.3264	f0 12		beq $3278			beq 	_GPFound
.3266	c8		iny				iny 								; check match.
.3267	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.3269	f0 0d		beq $3278			beq 	_GPFound
.326b					_GPNext:
.326b	18		clc				clc 								; follow to next
.326c	a5 2c		lda $2c				lda 	zTemp0
.326e	72 2c		adc ($2c)			adc 	(zTemp0)
.3270	85 2c		sta $2c				sta 	zTemp0
.3272	90 e1		bcc $3255			bcc 	_GPSearch
.3274	e6 2d		inc $2d				inc 	zTemp0+1
.3276	80 dd		bra $3255			bra 	_GPSearch
.3278					_GPFound:
.3278	18		clc				clc 								; skip to action bytes
.3279	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.327b	69 03		adc #$03			adc 	#3
.327d	85 2c		sta $2c				sta 	zTemp0
.327f	90 02		bcc $3283			bcc 	_GPNoCarry
.3281	e6 2d		inc $2d				inc 	zTemp0+1
.3283					_GPNoCarry:
.3283					_GPLoop:
.3283	20 8a 32	jsr $328a			jsr 	GeneratorExecute 			; execute one command
.3286	90 fb		bcc $3283			bcc 	_GPLoop 					; go back if not completed.
.3288	38		sec				sec 								; return with CS.
.3289					_GPExit:
.3289	60		rts				rts
.328a					GeneratorExecute:
.328a	20 36 33	jsr $3336			jsr 	_GEFetchZTemp0 				; get next.
.328d	48		pha				pha 								; split into 2 nibbles
.328e	4a		lsr a				lsr 	a
.328f	4a		lsr a				lsr 	a
.3290	4a		lsr a				lsr		a
.3291	4a		lsr a				lsr 	a
.3292	20 9c 32	jsr $329c			jsr 	_GEExecuteNibble 			; MSB first
.3295	68		pla				pla
.3296	b0 03		bcs $329b			bcs 	_GEHaveCompleted
.3298	20 9c 32	jsr $329c			jsr 	_GEExecuteNibble 			; LSB second
.329b					_GEHaveCompleted:
.329b	60		rts				rts
.329c					_GEExecuteNibble:
.329c	29 0f		and #$0f			and 	#$0F
.329e	0a		asl a				asl 	a
.329f	aa		tax				tax
.32a0	7c a3 32	jmp ($32a3,x)			jmp 	(_GEExecuteVectors,x)
.32a3					_GEExecuteVectors:
>32a3	c3 32						.word 	_GEXNop 					; 0  (no operation)
>32a5	cb 32						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>32a7	c5 32						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>32a9	19 33						.word 	_GEXExecute 				; 3  (run arbitrary code)
>32ab	0c 33						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>32ad	c3 32						.word 	_GEXNop 					; 5
>32af	d3 32						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>32b1	d7 32						.word 	_GEXExitString 				; 7  exit return string type
>32b3	db 32						.word 	_GEXLParam 					; 8  check ( follows
>32b5	df 32						.word 	_GEXRParam 					; 9  check ) follows
>32b7	e3 32						.word 	_GEXComma					; A  check , follows
>32b9	c3 32						.word 	_GEXNop 					; B
>32bb	c3 32						.word 	_GEXNop 					; C
>32bd	c3 32						.word 	_GEXNop 					; D
>32bf	f3 32						.word 	_GEXNumber 					; E  compile get any number
>32c1	fe 32						.word 	_GEXString 					; F  compile get any string
.32c3					_GEXNop:
.32c3	18		clc				clc
.32c4	60		rts				rts
.32c5					_GEXToken2:
.32c5	20 36 33	jsr $3336			jsr 	_GEFetchZTemp0
.32c8	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.32cb					_GEXToken1:
.32cb	20 36 33	jsr $3336			jsr 	_GEFetchZTemp0
.32ce	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.32d1	18		clc				clc
.32d2	60		rts				rts
.32d3					_GEXExitNumber:
.32d3	a9 00		lda #$00			lda 	#NSSIFloat
.32d5	38		sec				sec
.32d6	60		rts				rts
.32d7					_GEXExitString:
.32d7	a9 40		lda #$40			lda 	#NSSString
.32d9	38		sec				sec
.32da	60		rts				rts
.32db					_GEXLParam:
.32db	a9 28		lda #$28			lda 	#"("
.32dd	80 06		bra $32e5			bra 	_GEXCheck
.32df					_GEXRParam:
.32df	a9 29		lda #$29			lda 	#")"
.32e1	80 02		bra $32e5			bra 	_GEXCheck
.32e3					_GEXComma:
.32e3	a9 2c		lda #$2c			lda 	#","
.32e5					_GEXCheck:
.32e5	85 30		sta $30				sta 	zTemp2 						; save match
.32e7	20 be 33	jsr $33be			jsr 	GetNextNonSpace 			; get next skipping spaces
.32ea	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.32ec	d0 02		bne $32f0			bne 	_GEXSyntax
.32ee	18		clc				clc
.32ef	60		rts				rts
.32f0					_GEXSyntax:
.32f0	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.32f3					_GEXNumber:
.32f3	20 3f 33	jsr $333f			jsr 	GEXCompileExpression 		; compile expression
.32f6	29 40		and #$40			and 	#NSSTypeMask
.32f8	c9 00		cmp #$00			cmp  	#NSSIFloat
.32fa	d0 0d		bne $3309			bne 	_GEXType
.32fc	18		clc				clc
.32fd	60		rts				rts
.32fe					_GEXString:
.32fe	20 3f 33	jsr $333f			jsr 	GEXCompileExpression 		; compile expression
.3301	29 40		and #$40			and 	#NSSTypeMask
.3303	c9 40		cmp #$40			cmp  	#NSSString
.3305	d0 02		bne $3309			bne 	_GEXType
.3307	18		clc				clc
.3308	60		rts				rts
.3309					_GEXType:
.3309	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.330c					_GEXChannelExec:
.330c	20 4f 33	jsr $334f			jsr 	ChannelPrefix 				; set up default
.330f	20 19 33	jsr $3319			jsr 	_GEXExecute
.3312	08		php				php
.3313	20 6a 33	jsr $336a			jsr 	ChannelPostfix 				; replace default.
.3316	28		plp				plp
.3317	60		rts				rts
>3318	db						.byte 	$DB 						; causes a break in the emulator
.3319					_GEXExecute:
.3319	20 36 33	jsr $3336			jsr 	_GEFetchZTemp0 				; get vector
.331c	85 30		sta $30				sta 	zTemp2
.331e	20 36 33	jsr $3336			jsr 	_GEFetchZTemp0
.3321	85 31		sta $31				sta 	zTemp2+1
.3323	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.3325	da		phx				phx
.3326	a6 2d		ldx $2d				ldx 	zTemp0+1
.3328	da		phx				phx
.3329	20 33 33	jsr $3333			jsr 	_GECallZTemp2 				; execute code
.332c	fa		plx				plx 								; recover generation exec
.332d	86 2d		stx $2d				stx 	zTemp0+1
.332f	fa		plx				plx
.3330	86 2c		stx $2c				stx 	zTemp0
.3332	60		rts				rts
.3333					_GECallZTemp2:
.3333	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.3336					_GEFetchZTemp0:
.3336	b2 2c		lda ($2c)			lda 	(zTemp0)
.3338	e6 2c		inc $2c				inc 	zTemp0
.333a	d0 02		bne $333e			bne 	_GEFZ0Skip
.333c	e6 2d		inc $2d				inc 	zTemp0+1
.333e					_GEFZ0Skip:
.333e	60		rts				rts
.333f					GEXCompileExpression:
.333f	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.3341	da		phx				phx
.3342	a6 2d		ldx $2d				ldx 	zTemp0+1
.3344	da		phx				phx
.3345	20 58 2d	jsr $2d58			jsr 	CompileExpressionAt0 		; compile expression.
.3348	fa		plx				plx 								; recover generation exec
.3349	86 2d		stx $2d				stx 	zTemp0+1
.334b	fa		plx				plx
.334c	86 2c		stx $2c				stx 	zTemp0
.334e	60		rts				rts
.334f					ChannelPrefix:
.334f	a9 af		lda #$af			lda 	#PCD_GETCHANNEL				; set channel onto stack
.3351	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.3354	20 3f 33	jsr $333f			jsr 	GEXCompileExpression 		; channel #
.3357	29 40		and #$40			and 	#NSSTypeMask
.3359	c9 00		cmp #$00			cmp 	#NSSIFloat
.335b	d0 0a		bne $3367			bne 	_CPXType
.335d	20 a0 2a	jsr $2aa0			jsr 	CheckNextComma 				; check , follows.
.3360	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL				; set channel
.3362	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.3365	18		clc				clc
.3366	60		rts				rts
.3367					_CPXType:
.3367	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.336a					ChannelPostfix:
.336a	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.336c	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.336f	18		clc				clc
.3370	60		rts				rts
.3371					OptionalParameterCompile:
.3371	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; what follows.
.3374	c9 2c		cmp #$2c			cmp 	#","
.3376	d0 0e		bne $3386			bne 	_MidDefault
.3378	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume ,
.337b	20 58 2d	jsr $2d58			jsr 	CompileExpressionAt0
.337e	29 40		and #$40			and 	#NSSTypeMask
.3380	c9 00		cmp #$00			cmp 	#NSSIFloat
.3382	d0 09		bne $338d			bne 	MidFailType
.3384	80 05		bra $338b			bra 	_MidComplete
.3386					_MidDefault:
.3386	a9 ff		lda #$ff			lda 	#255 						; default of 255
.3388	20 6b 2b	jsr $2b6b			jsr 	PushIntegerA
.338b					_MidComplete:
.338b	18		clc				clc
.338c	60		rts				rts
.338d					MidFailType:
.338d	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.3390					NotUnaryCompile:
.3390	ad 0d 2e	lda $2e0d			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.3393	20 5a 2d	jsr $2d5a			jsr 	CompileExpressionAtA 		; evaluate at that level
.3396	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.3398	c9 00		cmp #$00			cmp 	#NSSIFloat
.339a	d0 f1		bne $338d			bne 	MidFailType
.339c	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.339e	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.33a1	60		rts				rts
.33a2					LookNext:
.33a2	b2 7a		lda ($7a)			lda 	(srcPtr)
.33a4	60		rts				rts
.33a5					LookNextNonSpace:
.33a5	b2 7a		lda ($7a)			lda 	(srcPtr)
.33a7	c9 20		cmp #$20			cmp		#' '
.33a9	f0 03		beq $33ae			beq 	_LNNSkip
.33ab	c9 00		cmp #$00			cmp 	#0
.33ad	60		rts				rts
.33ae					_LNNSkip:
.33ae	20 b3 33	jsr $33b3			jsr 	GetNext
.33b1	80 f2		bra $33a5			bra 	LookNextNonSpace
.33b3					GetNext:
.33b3	b2 7a		lda ($7a)			lda 	(srcPtr) 					; get next
.33b5	e6 7a		inc $7a				inc 	srcPtr
.33b7	d0 02		bne $33bb			bne 	_GNSkip
.33b9	e6 7b		inc $7b				inc 	srcPtr+1
.33bb					_GNSkip:
.33bb	c9 00		cmp #$00			cmp 	#0
.33bd	60		rts				rts
.33be					GetNextNonSpace:
.33be	20 b3 33	jsr $33b3			jsr 	GetNext
.33c1	c9 20		cmp #$20			cmp 	#' '
.33c3	f0 f9		beq $33be			beq 	GetNextNonSpace
.33c5	c9 00		cmp #$00			cmp 	#0
.33c7	60		rts				rts
.33c8					CharIsDigit:
.33c8	c9 30		cmp #$30			cmp 	#"0"
.33ca	90 06		bcc $33d2			bcc 	CCFalse
.33cc	c9 3a		cmp #$3a			cmp 	#"9"+1
.33ce	b0 02		bcs $33d2			bcs 	CCFalse
.33d0					CCTrue:
.33d0	38		sec				sec
.33d1	60		rts				rts
.33d2					CCFalse:
.33d2	18		clc				clc
.33d3	60		rts				rts
.33d4					CharIsAlpha:
.33d4	c9 41		cmp #$41			cmp 	#"A"
.33d6	90 fa		bcc $33d2			bcc 	CCFalse
.33d8	c9 5b		cmp #$5b			cmp 	#"Z"+1
.33da	b0 f6		bcs $33d2			bcs 	CCFalse
.33dc	80 f2		bra $33d0			bra 	CCTrue
.33de					ConvertHexStyle:
.33de	38		sec				sec
.33df	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.33e1	90 ef		bcc $33d2			bcc 	CCFalse
.33e3	c9 0a		cmp #$0a			cmp 	#9+1
.33e5	90 e9		bcc $33d0			bcc 	CCTrue
.33e7	38		sec				sec 								; shift into hex space A=>0 Z=>25
.33e8	e9 11		sbc #$11			sbc 	#"A"-"0"
.33ea	90 e6		bcc $33d2			bcc 	CCFalse
.33ec	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.33ee	b0 e2		bcs $33d2			bcs 	CCFalse
.33f0	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.33f2	80 dc		bra $33d0			bra 	CCTrue
.33f4					CommandGET:
.33f4	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; # follows ?
.33f7	c9 23		cmp #$23			cmp 	#"#"
.33f9	d0 0d		bne $3408			bne 	CommandGetBody
.33fb	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume #
.33fe	20 4f 33	jsr $334f			jsr 	ChannelPrefix 				; do it as GET#
.3401	20 08 34	jsr $3408			jsr 	CommandGetBody
.3404	20 6a 33	jsr $336a			jsr 	ChannelPostfix
.3407	60		rts				rts
.3408					CommandGetBody:
.3408	20 be 33	jsr $33be			jsr 	GetNextNonSpace 			; get the first character
.340b	20 ff 36	jsr $36ff			jsr 	GetReferenceTerm 			; identify variable to assign to
.340e	48		pha				pha
.340f	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.3411	c9 40		cmp #$40			cmp 	#NSSString
.3413	d0 0b		bne $3420			bne 	_CGType
.3415	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.3417	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.341a	38		sec				sec
.341b	68		pla				pla
.341c	20 b1 36	jsr $36b1			jsr		GetSetVariable
.341f	60		rts				rts
.3420					_CGType:
.3420	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.3423					ExtractVariableName:
.3423	20 d4 33	jsr $33d4			jsr 	CharIsAlpha
.3426	90 50		bcc $3478			bcc 	_IVSyntax
.3428	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.342a	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.342c	64 2f		stz $2f				stz 	zTemp1+1
.342e	20 a2 33	jsr $33a2			jsr 	LookNext 					; is there a second character ?
.3431	20 d4 33	jsr $33d4			jsr 	CharIsAlpha  				; must be alphanumeric
.3434	b0 05		bcs $343b			bcs 	_IVHasSecond
.3436	20 c8 33	jsr $33c8			jsr 	CharIsDigit
.3439	90 07		bcc $3442			bcc 	_IVCheckType
.343b					_IVHasSecond:
.343b	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.343d	85 2f		sta $2f				sta 	zTemp1+1
.343f					_IVGetNextCheck:
.343f	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume it
.3442					_IVCheckType:
.3442	20 a2 33	jsr $33a2			jsr 	LookNext					; check if string follows.
.3445	20 d4 33	jsr $33d4			jsr 	CharIsAlpha
.3448	b0 f5		bcs $343f			bcs 	_IVGetNextCheck
.344a	20 c8 33	jsr $33c8			jsr 	CharIsDigit
.344d	b0 f0		bcs $343f			bcs 	_IVGetNextCheck
.344f	a2 40		ldx #$40			ldx 	#NSSString
.3451	c9 24		cmp #$24			cmp 	#"$"
.3453	f0 06		beq $345b			beq 	_IVHasType
.3455	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.3457	c9 25		cmp #$25			cmp 	#"%"
.3459	d0 08		bne $3463			bne 	_IVCheckArray
.345b					_IVHasType:
.345b	8a		txa				txa 								; Or X into zTemp1
.345c	05 2e		ora $2e				ora 	zTemp1
.345e	85 2e		sta $2e				sta 	zTemp1
.3460	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume it
.3463					_IVCheckArray:
.3463	20 a2 33	jsr $33a2			jsr 	LookNext 					; check if array follows
.3466	c9 28		cmp #$28			cmp 	#"("
.3468	d0 09		bne $3473			bne 	_IVNotArray
.346a	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.346c	09 80		ora #$80			ora 	#NSSArray
.346e	85 2e		sta $2e				sta 	zTemp1
.3470	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume it
.3473					_IVNotArray:
.3473	a6 2e		ldx $2e				ldx 	zTemp1
.3475	a4 2f		ldy $2f				ldy 	zTemp1+1
.3477	60		rts				rts
.3478					_IVSyntax:
.3478	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.347b					CommandGOSUB:
.347b	a9 d2		lda #$d2			lda 	#PCD_CMD_GOSUB
.347d	20 8e 34	jsr $348e			jsr 	CompileBranchCommand
.3480	60		rts				rts
.3481					CommandGOAlt:
.3481	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.3483	20 aa 2a	jsr $2aaa			jsr 	CheckNextA
.3486	80 00		bra $3488			bra 	CommandGOTO
.3488					CommandGOTO:
.3488	a9 d1		lda #$d1			lda 	#PCD_CMD_GOTO
.348a	20 8e 34	jsr $348e			jsr 	CompileBranchCommand
.348d	60		rts				rts
.348e					CompileBranchCommand:
.348e	20 42 2a	jsr $2a42			jsr 	WriteCodeByte 				; write the command out.
.3491	20 be 33	jsr $33be			jsr 	GetNextNonSpace
.3494	20 07 36	jsr $3607			jsr 	ParseConstant 				; get constant into YA
.3497	90 08		bcc $34a1			bcc 	_CBCSyntax
.3499	20 42 2a	jsr $2a42			jsr 	WriteCodeByte				; and compile the actual line number
.349c	98		tya				tya
.349d	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.34a0	60		rts				rts
.34a1					_CBCSyntax:
.34a1	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.34a4					CommandIF:
.34a4	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; what follows the tests ?
.34a7	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.34a9	f0 0f		beq $34ba			beq 	_CIGoto
.34ab	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.34ad	20 aa 2a	jsr $2aaa			jsr 	CheckNextA
.34b0	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; THEN <number>
.34b3	20 c8 33	jsr $33c8			jsr 	CharIsDigit
.34b6	b0 05		bcs $34bd			bcs 	_CIGoto2
.34b8	80 09		bra $34c3			bra 	CompileGotoEOL
.34ba					_CIGoto:
.34ba	20 b3 33	jsr $33b3			jsr 	GetNext
.34bd					_CIGoto2:
.34bd	a9 d4		lda #$d4			lda 	#PCD_CMD_GOTOCMD_NZ
.34bf	20 8e 34	jsr $348e			jsr 	CompileBranchCommand
.34c2	60		rts				rts
.34c3					CompileGotoEOL:
.34c3	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_Z
.34c5	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.34c8	20 3b 2a	jsr $2a3b			jsr 	GetLineNumber 				; Get the current line number => YA
.34cb	1a		inc a				inc 	a 							; and branch to +1
.34cc	d0 01		bne $34cf			bne 	_CGENoCarry
.34ce	c8		iny				iny
.34cf					_CGENoCarry:
.34cf	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.34d2	98		tya				tya
.34d3	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.34d6	60		rts				rts
.34d7					CommandINPUT:
.34d7	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; check for "
.34da	c9 22		cmp #$22			cmp 	#'"'
.34dc	d0 0d		bne $34eb			bne 	CommandINPUTStream
.34de	20 58 2d	jsr $2d58			jsr 	CompileExpressionAt0
.34e1	a9 b2		lda #$b2			lda 	#(PCD_PRINTCMD_S) & $FF
.34e3	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.34e6	a9 2c		lda #$2c			lda 	#","
.34e8	20 a0 2a	jsr $2aa0			jsr 	CheckNextComma
.34eb					CommandINPUTStream:
.34eb	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.34ed	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.34f0	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.34f2	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.34f4	4c 79 36	jmp $3679			jmp 	CommandReadInputCommon
.34f7					CommandLET:
.34f7	20 be 33	jsr $33be			jsr 	GetNextNonSpace 			; get the first character
.34fa					CommandLETHaveFirst:
.34fa	20 ff 36	jsr $36ff			jsr 	GetReferenceTerm 			; identify variable to assign to
.34fd	da		phx				phx 								; save target on the stack.
.34fe	5a		phy				phy
.34ff	48		pha				pha
.3500	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.3502	20 aa 2a	jsr $2aaa			jsr 	CheckNextA
.3505	20 58 2d	jsr $2d58			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.3508	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.350a	68		pla				pla 								; get type of assignment
.350b	48		pha				pha
.350c	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.350e	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.3510	d0 17		bne $3529			bne 	_CLType
.3512	68		pla				pla 								; restore and compile save code
.3513	7a		ply				ply
.3514	fa		plx				plx
.3515	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.3517	f0 05		beq $351e			beq 	_CLTIString
.3519	38		sec				sec
.351a	20 b1 36	jsr $36b1			jsr		GetSetVariable
.351d	60		rts				rts
.351e					_CLTIString:
.351e	a9 cb		lda #$cb			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.3520	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.3523	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.3525	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.3528	60		rts				rts
.3529					_CLType:
.3529	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.352c					STRMarkLine:
.352c	48		pha				pha
.352d	38		sec				sec 								; allocate 4 bytes (line #,address)
.352e	ad c9 06	lda $06c9			lda 	lineNumberTable 			; and copy to zTemp0
.3531	e9 04		sbc #$04			sbc 	#4
.3533	8d c9 06	sta $06c9			sta 	lineNumberTable
.3536	85 2c		sta $2c				sta 	zTemp0
.3538	ad ca 06	lda $06ca			lda 	lineNumberTable+1
.353b	e9 00		sbc #$00			sbc 	#0
.353d	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.3540	85 2d		sta $2d				sta 	zTemp0+1
.3542	68		pla				pla
.3543	92 2c		sta ($2c)			sta 	(zTemp0) 					; line # save it in +0,+1
.3545	98		tya				tya
.3546	a0 01		ldy #$01			ldy 	#1
.3548	91 2c		sta ($2c),y			sta 	(zTemp0),y
.354a	a5 2a		lda $2a				lda 	objPtr 						; save current address in +2,+3
.354c	c8		iny				iny
.354d	91 2c		sta ($2c),y			sta 	(zTemp0),y
.354f	a5 2b		lda $2b				lda 	objPtr+1
.3551	c8		iny				iny
.3552	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3554	60		rts				rts
.3555					STRFindLine:
.3555	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.3557	84 2d		sty $2d				sty 	zTemp0+1
.3559	ad c2 06	lda $06c2			lda 	compilerEndHigh 			; work backwards through table
.355c	85 2f		sta $2f				sta 	zTemp1+1
.355e	64 2e		stz $2e				stz 	zTemp1
.3560					_STRSearch:
.3560	20 97 35	jsr $3597			jsr 	_STRPrevLine 				; look at previous record.
.3563	a0 01		ldy #$01			ldy 	#1
.3565	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.3567	c5 2c		cmp $2c				cmp 	zTemp0
.3569	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.356b	e5 2d		sbc $2d				sbc 	zTemp0+1
.356d	b0 0b		bcs $357a			bcs 	_STRFound 					; >=
.356f					_STRNext:
.356f	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.3571	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3573	c9 ff		cmp #$ff			cmp 	#$FF
.3575	d0 e9		bne $3560			bne 	_STRSearch
.3577	4c 76 1f	jmp $1f76		jmp	ErrorV_internal
.357a					_STRFound:
.357a	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.357c	45 2c		eor $2c				eor 	zTemp0
.357e	d0 06		bne $3586			bne 	_STRDifferent
.3580	b2 2e		lda ($2e)			lda 	(zTemp1)
.3582	45 2c		eor $2c				eor 	zTemp0
.3584	f0 02		beq $3588			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.3586					_STRDifferent:
.3586	a9 ff		lda #$ff			lda 	#$FF
.3588					_STROut:
.3588	18		clc				clc  								; set carry if different, e.g. > rather than >=
.3589	69 ff		adc #$ff			adc 	#255
.358b	08		php				php
.358c	c8		iny				iny 								; address into YA
.358d	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.358f	48		pha				pha
.3590	c8		iny				iny
.3591	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3593	a8		tay				tay
.3594	68		pla				pla
.3595	28		plp				plp
.3596	60		rts				rts
.3597					_STRPrevLine:
.3597	38		sec				sec 								; move backwards one entry.
.3598	a5 2e		lda $2e				lda 	zTemp1
.359a	e9 04		sbc #$04			sbc 	#4
.359c	85 2e		sta $2e				sta 	zTemp1
.359e	a5 2f		lda $2f				lda 	zTemp1+1
.35a0	e9 00		sbc #$00			sbc 	#0
.35a2	85 2f		sta $2f				sta 	zTemp1+1
.35a4	60		rts				rts
.35a5					STRMakeOffset:
.35a5	18		clc				clc 								; borrow 1
.35a6	e5 2a		sbc $2a				sbc 	objPtr
.35a8	48		pha				pha
.35a9	98		tya				tya
.35aa	e5 2b		sbc $2b				sbc 	objPtr+1
.35ac	a8		tay				tay
.35ad	68		pla				pla
.35ae	60		rts				rts
.35af					CommandNEXT:
.35af	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.35b2	20 d4 33	jsr $33d4			jsr 	CharIsAlpha 				; if not alpha , error
.35b5	90 0c		bcc $35c3			bcc 	_CNNoReferenceGiven
.35b7	20 b3 33	jsr $33b3			jsr 	GetNext
.35ba	20 ff 36	jsr $36ff			jsr 	GetReferenceTerm 			; figure out the reference.
.35bd	8a		txa				txa 								; reference in YA
.35be	20 58 2b	jsr $2b58			jsr 	PushIntegerYA 				; write it out.
.35c1	80 06		bra $35c9			bra 	_CNParametersDone
.35c3					_CNNoReferenceGiven:
.35c3	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.35c5	a8		tay				tay
.35c6	20 58 2b	jsr $2b58			jsr 	PushIntegerYA 				; write it out.
.35c9					_CNParametersDone:
.35c9	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.35cb	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.35ce	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; look for ,
.35d1	c9 2c		cmp #$2c			cmp 	#","
.35d3	d0 05		bne $35da			bne 	_CNExit
.35d5	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume ,
.35d8	80 d5		bra $35af			bra 	CommandNEXT 				; and go round.
.35da					_CNExit:
.35da	60		rts				rts
.35db					CommandON:
.35db	20 be 33	jsr $33be			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.35de	48		pha				pha 								; save on stack
.35df	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOTO
.35e1	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.35e3	f0 09		beq $35ee			beq 	_COCreateLoop
.35e5	a2 d2		ldx #$d2			ldx 	#PCD_CMD_GOSUB
.35e7	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.35e9	f0 03		beq $35ee			beq 	_COCreateLoop
.35eb	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.35ee					_COCreateLoop:
.35ee	8a		txa				txa 								; compile a goto/gosub somewhere
.35ef	da		phx				phx
.35f0	20 8e 34	jsr $348e			jsr 	CompileBranchCommand
.35f3	fa		plx				plx
.35f4	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace			; ',' follows
.35f7	c9 2c		cmp #$2c			cmp 	#","
.35f9	d0 0a		bne $3605			bne 	_COComplete 				; if so, more line numbers
.35fb	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.35fd	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.3600	20 b3 33	jsr $33b3			jsr 	GetNext
.3603	80 e9		bra $35ee			bra 	_COCreateLoop
.3605					_COComplete:
.3605	68		pla				pla 								; throw GOTO/GOSUB
.3606	60		rts				rts
.3607					ParseConstant:
.3607	a2 00		ldx #$00			ldx 	#0
.3609	20 53 24	jsr $2453			jsr 	FloatEncodeStart 			; send first
.360c					_ParseLoop:
.360c	20 a2 33	jsr $33a2			jsr 	LookNext 					; send subsequent
.360f	20 56 24	jsr $2456			jsr 	FloatEncodeContinue
.3612	90 05		bcc $3619			bcc 	_ParseDone
.3614	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume it
.3617	80 f3		bra $360c			bra 	_ParseLoop
.3619					_ParseDone:
.3619	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.361b	29 80		and #$80			and 	#$80
.361d	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.361f	15 56		ora $56,x			ora 	NSMantissa2,x
.3621	15 62		ora $62,x			ora 	NSMantissa3,x
.3623	18		clc				clc
.3624	d0 05		bne $362b			bne 	_ParseExit 					; exit with CC if need float to compile
.3626	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.3628	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.362a	38		sec				sec
.362b					_ParseExit:
.362b	60		rts				rts
.362c					CommandPRINT:
.362c	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace			; what follows ?
.362f	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.3631	f0 1f		beq $3652			beq 	_CPCheckEnd
.3633	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.3635	f0 16		beq $364d			beq 	_CPTabCheckEnd
.3637	20 69 36	jsr $3669			jsr 	_CPAtEnd 					; check for : and EOL
.363a	b0 22		bcs $365e			bcs 	_CPExitCR 					; exit with CR
.363c	20 58 2d	jsr $2d58			jsr 	CompileExpressionAt0 		; so it is something to print
.363f	a2 b2		ldx #$b2			ldx 	#PCD_PRINTCMD_S
.3641	29 40		and #$40			and 	#NSSString 					; if string
.3643	d0 02		bne $3647			bne 	_CPOut
.3645	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_N
.3647					_CPOut:
.3647	8a		txa				txa 								; print that thing
.3648	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.364b	80 df		bra $362c			bra 	CommandPRINT 				; and loop round/
.364d					_CPTabCheckEnd:
.364d	a9 b8		lda #$b8			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.364f	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.3652					_CPCheckEnd:
.3652	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume it.
.3655	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; what follows ?
.3658	20 69 36	jsr $3669			jsr 	_CPAtEnd 					; reached end
.365b	90 cf		bcc $362c			bcc 	CommandPRINT 				; no, loop back
.365d	60		rts				rts
.365e					_CPExitCR:
.365e	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.3660	20 6b 2b	jsr $2b6b			jsr 	PushIntegerA
.3663	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.3665	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.3668	60		rts				rts
.3669					_CPAtEnd:
.3669	c9 00		cmp #$00			cmp 	#0
.366b	f0 06		beq $3673			beq 	_CPIsEnd
.366d	c9 3a		cmp #$3a			cmp 	#":"
.366f	f0 02		beq $3673			beq 	_CPIsEnd
.3671	18		clc				clc
.3672	60		rts				rts
.3673					_CPIsEnd:
.3673	38		sec				sec
.3674	60		rts				rts
.3675					CommandREAD:
.3675	a2 b3		ldx #$b3			ldx 	#PCD_READ
.3677	a0 b4		ldy #$b4			ldy 	#PCD_READDOLLAR
.3679					CommandReadInputCommon:
.3679	8e c7 06	stx $06c7			stx 	numberPCode
.367c	8c c8 06	sty $06c8			sty 	stringPCode
.367f					_CRLoop:
.367f	20 be 33	jsr $33be			jsr 	GetNextNonSpace 			; first char of identifier
.3682	20 d4 33	jsr $33d4			jsr 	CharIsAlpha 				; check A-Z
.3685	90 27		bcc $36ae			bcc 	_CRSyntax
.3687	20 ff 36	jsr $36ff			jsr 	GetReferenceTerm 			; get the variable.
.368a	48		pha				pha 								; save type.
.368b	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.368d	c9 40		cmp #$40			cmp 	#NSSString
.368f	f0 05		beq $3696			beq 	_CRString
.3691	ad c7 06	lda $06c7			lda 	numberPCode 				; output read/input
.3694	80 03		bra $3699			bra 	_CRHaveType
.3696					_CRString:
.3696	ad c8 06	lda $06c8			lda 	stringPCode					; output read$/input$
.3699					_CRHaveType:
.3699	20 42 2a	jsr $2a42			jsr 	WriteCodeByte 				; so we have one typed data item.
.369c	68		pla				pla 								; restore type
.369d	38		sec				sec  								; write update code.
.369e	20 b1 36	jsr $36b1			jsr 	GetSetVariable
.36a1	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; , follows ?
.36a4	c9 2c		cmp #$2c			cmp 	#","
.36a6	d0 05		bne $36ad			bne 	_CRExit 					; if not, end of READ.
.36a8	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume comma
.36ab	80 d2		bra $367f			bra 	_CRLoop 					; keep going
.36ad					_CRExit:
.36ad	60		rts				rts
.36ae					_CRSyntax:
.36ae	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.06c7					numberPCode:
>06c7							.fill 	1
.06c8					stringPCode:
>06c8							.fill 	1
.36b1					GetSetVariable:
.36b1	08		php				php 								; save direction on stack
.36b2	c0 00		cpy #$00			cpy 	#$00
.36b4	30 21		bmi $36d7			bmi 	_GSVReadWriteSpecial
.36b6	c9 00		cmp #$00			cmp 	#$00
.36b8	30 33		bmi $36ed			bmi 	_GSVArray
.36ba	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.36bc	4a		lsr a				lsr 	a 							; divide by 2
.36bd	09 40		ora #$40			ora 	#64 						; and set bit 6.
.36bf	28		plp				plp
.36c0	90 02		bcc $36c4			bcc 	_GSVNotWrite
.36c2	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.36c4					_GSVNotWrite:
.36c4	85 2c		sta $2c				sta 	zTemp0
.36c6	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.36c7	4a		lsr a				lsr 	a
.36c8	a8		tay				tay
.36c9	8a		txa				txa
.36ca	6a		ror a				ror 	a
.36cb	aa		tax				tax
.36cc	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.36cd	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.36cf	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.36d2	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.36d3	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.36d6	60		rts				rts
.36d7					_GSVReadWriteSpecial:
.36d7	28		plp				plp
.36d8	b0 10		bcs $36ea			bcs 	_GSVSyntax
.36da	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.36dc	f0 06		beq $36e4			beq 	_GSVRWString
.36de	a9 c0		lda #$c0			lda 	#(PCD_TI) & $FF
.36e0	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.36e3	60		rts				rts
.36e4					_GSVRWString:
.36e4	a9 c1		lda #$c1			lda 	#(PCD_TIDOLLAR) & $FF
.36e6	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.36e9	60		rts				rts
.36ea					_GSVSyntax:
.36ea	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.36ed					_GSVArray:
.36ed	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.36ef	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.36f0	4a		lsr a				lsr 	a
.36f1	4a		lsr a				lsr 	a
.36f2	4a		lsr a				lsr 	a
.36f3	4a		lsr a				lsr 	a
.36f4	28		plp				plp 								; if writing array then set bit 2.
.36f5	90 02		bcc $36f9			bcc 	_GSVANotWrite
.36f7	09 04		ora #$04			ora 	#4
.36f9					_GSVANotWrite:
.36f9	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.36fb	20 42 2a	jsr $2a42			jsr 	WriteCodeByte 				; and write it out
.36fe	60		rts				rts
.36ff					GetReferenceTerm:
.36ff	20 23 34	jsr $3423			jsr 	ExtractVariableName 		; get name & type info
.3702	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.3704	30 10		bmi $3716			bmi 	_GRTArray
.3706	da		phx				phx 								; save type on stack
.3707	20 12 2e	jsr $2e12			jsr 	FindVariable 				; find it
.370a	b0 06		bcs $3712			bcs 	_GRTNoCreate 				; create if required.
.370c	20 9d 2b	jsr $2b9d			jsr 	CreateVariableRecord 		; create a variable.
.370f	20 f2 2b	jsr $2bf2			jsr 	AllocateBytesForType 		; allocate memory for it
.3712					_GRTNoCreate:
.3712	68		pla				pla 								; get type back, strip out type information.
.3713	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.3715	60		rts				rts
.3716					_GRTArray:
.3716	da		phx				phx 								; save type information
.3717	20 12 2e	jsr $2e12			jsr 	FindVariable 				; read its data, the base address in YX
.371a	90 18		bcc $3734			bcc 	_GRTUndeclared 				; undeclared array.
.371c	da		phx				phx 								; save base address
.371d	5a		phy				phy
.371e	20 e9 2c	jsr $2ce9			jsr 	OutputIndexGroup 			; create an index group and generate them
.3721	7a		ply				ply 								; get the array base address into YX
.3722	fa		plx				plx
.3723	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.3725	18		clc				clc
.3726	20 b1 36	jsr $36b1			jsr 	GetSetVariable 				; load the address of the array structure.
.3729	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.372b	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.372e	68		pla				pla 								; and the type data into A
.372f	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.3731	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.3733	60		rts				rts
.3734					_GRTUndeclared:
.3734	4c d3 1f	jmp $1fd3		jmp	ErrorV_undeclared
.3737					CommandREM:
.3737	20 a2 33	jsr $33a2			jsr 	LookNext
.373a	f0 05		beq $3741			beq 	_CRExit
.373c	20 b3 33	jsr $33b3			jsr 	GetNext
.373f	80 f6		bra $3737			bra 	CommandREM
.3741					_CRExit:
.3741	60		rts				rts
.3742					STRReset:
.3742	ad c1 06	lda $06c1			lda	 	compilerStartHigh 			; set up the two table pointers
.3745	8d cc 06	sta $06cc			sta 	variableListEnd+1
.3748	9c cb 06	stz $06cb			stz 	variableListEnd
.374b	ad c2 06	lda $06c2			lda 	compilerEndHigh
.374e	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.3751	9c c9 06	stz $06c9			stz 	lineNumberTable
.3754	ad cb 06	lda $06cb			lda 	variableListEnd
.3757	85 2d		sta $2d				sta 	zTemp0+1
.3759	64 2c		stz $2c				stz 	zTemp0
.375b	a9 00		lda #$00			lda 	#0
.375d	92 2c		sta ($2c)			sta 	(zTemp0)
.375f	a9 00		lda #$00			lda 	#((0) & $FF)
.3761	8d cd 06	sta $06cd			sta 	0+freeVariableMemory
.3764	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.3766	8d ce 06	sta $06ce			sta 	1+freeVariableMemory
.3769	60		rts				rts
.06c9					lineNumberTable:
>06c9							.fill 	2
.06cb					variableListEnd:
>06cb							.fill 	2
.06cd					freeVariableMemory:
>06cd							.fill 	2
.376a					CompileTerm:
.376a	20 be 33	jsr $33be			jsr 	GetNextNonSpace 			; get first non space character.
.376d	30 72		bmi $37e1			bmi 	_CTUnaryFunctions
.376f	20 c8 33	jsr $33c8			jsr 	CharIsDigit 				; found a number
.3772	b0 3a		bcs $37ae			bcs 	_CTDigit
.3774	c9 2e		cmp #$2e			cmp 	#"."
.3776	f0 36		beq $37ae			beq 	_CTDigit
.3778	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.377a	f0 43		beq $37bf			beq 	_CTString
.377c	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.377e	f0 28		beq $37a8			beq 	_CTOtherBase
.3780	c9 24		cmp #$24			cmp 	#"$"
.3782	f0 24		beq $37a8			beq 	_CTOtherBase
.3784	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.3786	f0 17		beq $379f			beq 	_CTBrackets
.3788	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.378a	90 10		bcc $379c			bcc 	_CTSyntax
.378c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.378e	b0 0c		bcs $379c			bcs 	_CTSyntax
.3790	20 ff 36	jsr $36ff			jsr 	GetReferenceTerm 			; figure out what it is.
.3793	48		pha				pha 								; save type on stack
.3794	18		clc				clc 								; read it
.3795	20 b1 36	jsr $36b1			jsr 	GetSetVariable
.3798	68		pla				pla
.3799	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.379b	60		rts				rts
.379c					_CTSyntax:
.379c	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.379f					_CTBrackets:
.379f	20 58 2d	jsr $2d58			jsr 	CompileExpressionAt0
.37a2	48		pha				pha
.37a3	20 a4 2a	jsr $2aa4			jsr 	CheckNextRParen
.37a6	68		pla				pla
.37a7	60		rts				rts
.37a8					_CTOtherBase:
.37a8	20 f0 29	jsr $29f0			jsr 	InlineNonDecimal 			; non decimal constant handler
.37ab	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.37ad	60		rts				rts
.37ae					_CTDigit:
.37ae	20 07 36	jsr $3607			jsr 	ParseConstant 				; parse out an number, first is in A already.
.37b1	90 06		bcc $37b9			bcc	 	_CTFloat 					; have a float or long int.
.37b3	20 58 2b	jsr $2b58			jsr 	PushIntegerYA 				; code to push on stack
.37b6	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.37b8	60		rts				rts
.37b9					_CTFloat:
.37b9	20 7a 2b	jsr $2b7a			jsr 	PushFloatCommand			; code to push float
.37bc	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.37be	60		rts				rts
.37bf					_CTString:
.37bf	20 79 2a	jsr $2a79			jsr 	BufferClear 				; copy it to the buffer
.37c2					_CTStringLoop:
.37c2	20 a2 33	jsr $33a2			jsr 	LookNext 					; reached EOL/EOS
.37c5	f0 d5		beq $379c			beq 	_CTSyntax
.37c7	c9 22		cmp #$22			cmp 	#'"'
.37c9	f0 08		beq $37d3			beq 	_CTStringDone
.37cb	20 7d 2a	jsr $2a7d			jsr 	BufferWrite 				; write and consume
.37ce	20 b3 33	jsr $33b3			jsr 	GetNext
.37d1	80 ef		bra $37c2			bra 	_CTStringLoop
.37d3					_CTStringDone:
.37d3	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume closing quote.
.37d6	a9 cf		lda #$cf			lda 	#PCD_CMD_STRING 			; output command and buffer
.37d8	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.37db	20 89 2a	jsr $2a89			jsr 	BufferOutput
.37de	a9 40		lda #$40			lda 	#NSSString 					; string type
.37e0	60		rts				rts
.37e1					_CTUnaryFunctions:
.37e1	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.37e3	f0 0a		beq $37ef			beq 	_CTNegation
.37e5	a2 44		ldx #$44			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.37e7	a0 31		ldy #$31			ldy 	#UnaryTables >> 8
.37e9	20 44 32	jsr $3244			jsr 	GeneratorProcess
.37ec	90 ae		bcc $379c			bcc		_CTSyntax
.37ee	60		rts				rts
.37ef					_CTNegation:
.37ef	20 6a 37	jsr $376a			jsr 	CompileTerm 				; compile a term.
.37f2	48		pha				pha
.37f3	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.37f5	c9 00		cmp #$00			cmp 	#NSSIFloat
.37f7	d0 07		bne $3800			bne 	_CTType 					; error
.37f9	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.37fb	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.37fe	68		pla				pla 								; return original type.
.37ff	60		rts				rts
.3800					_CTType:
.3800	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.3803					CommandWAIT:
.3803	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace
.3806	c9 2c		cmp #$2c			cmp 	#","
.3808	f0 10		beq $381a			beq 	_CWThirdParameter
.380a	a9 00		lda #$00			lda 	#0
.380c	20 6b 2b	jsr $2b6b			jsr 	PushIntegerA
.380f					_CWExit:
.380f	a9 cb		lda #$cb			lda 	#(PCD_WAIT) >> 8
.3811	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.3814	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.3816	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.3819	60		rts				rts
.381a					_CWThirdParameter:
.381a	20 b3 33	jsr $33b3			jsr 	GetNext
.381d	20 5a 2d	jsr $2d5a			jsr 	CompileExpressionAtA
.3820	29 40		and #$40			and 	#NSSTypeMask
.3822	c9 00		cmp #$00			cmp 	#NSSIFloat
.3824	f0 e9		beq $380f			beq 	_CWExit
.3826	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.3829					CommandCMD:
.3829	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.382b	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.382e	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; followed by a , ?
.3831	c9 2c		cmp #$2c			cmp 	#","
.3833	d0 06		bne $383b			bne 	_CCMDExit
.3835	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume comma.
.3838	20 2c 36	jsr $362c			jsr 	CommandPRINT 				; do the print code
.383b					_CCMDExit:
.383b	60		rts				rts
.383c					CommandOPEN:
.383c	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; followed by a , ?
.383f	c9 2c		cmp #$2c			cmp 	#","
.3841	d0 15		bne $3858			bne 	_COTwoDefaults
.3843	20 b3 33	jsr $33b3			jsr 	GetNext 					; consume comma
.3846	20 58 2d	jsr $2d58			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.3849	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.384b	f0 1e		beq $386b			beq 	_COThreeIntegers
.384d	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.384f	20 6b 2b	jsr $2b6b			jsr 	PushIntegerA
.3852	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.3854	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.3857	60		rts				rts
.3858					_COTwoDefaults:
.3858	a9 00		lda #$00			lda 	#0
.385a	20 6b 2b	jsr $2b6b			jsr 	PushIntegerA
.385d					_COCompileNullString:
.385d	a9 cf		lda #$cf			lda 	#(PCD_CMD_STRING) & $FF
.385f	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.3862	a9 00		lda #$00			lda 	#0
.3864	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.3867	20 42 2a	jsr $2a42			jsr 	WriteCodeByte
.386a	60		rts				rts
.386b					_COThreeIntegers:
.386b	20 a5 33	jsr $33a5			jsr 	LookNextNonSpace 			; is there a ,
.386e	c9 2c		cmp #$2c			cmp 	#","
.3870	d0 eb		bne $385d			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.3872	20 b3 33	jsr $33b3			jsr 	GetNext
.3875	20 58 2d	jsr $2d58			jsr 	CompileExpressionAt0 		; should be a filename
.3878	29 40		and #$40			and 	#NSSString
.387a	f0 01		beq $387d			beq 	_COType
.387c	60		rts				rts
.387d					_COType:
.387d	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type

;******  Processing input file: _library.asm

.3880					CompilerAPI:
.3880	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.3882	f0 19		beq $389d			beq 	_CAOpenIn
.3884	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.3886	f0 23		beq $38ab			beq 	_CACloseIn
.3888	c9 02		cmp #$02			cmp 	#BLC_READIN
.388a	f0 3a		beq $38c6			beq 	_CARead
.388c	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.388e	f0 1e		beq $38ae			beq 	_CAResetOut
.3890	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.3892	f0 23		beq $38b7			beq 	_CACloseOut
.3894	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.3896	f0 20		beq $38b8			beq 	_CAWriteByte
.3898	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.389a	f0 26		beq $38c2			beq 	_CAPrintScreen
>389c	db						.byte 	$DB 						; causes a break in the emulator
.389d					_CAOpenIn:
.389d	a0 39		ldy #$39			ldy 	#SourceFile >> 8 			; name of file
.389f	a2 bd		ldx #$bd			ldx 	#SourceFile & $FF
.38a1	20 2e 39	jsr $392e			jsr 	IOOpenRead 					; open file
.38a4	20 39 39	jsr $3939			jsr 	IOReadByte 					; skip the 2 byte load address header
.38a7	20 39 39	jsr $3939			jsr 	IOReadByte
.38aa	60		rts				rts
.38ab					_CACloseIn:
.38ab	4c 48 39	jmp $3948			jmp 	IOReadClose
.38ae					_CAResetOut:
.38ae	a9 00		lda #$00			lda 	#((FreeMemory) & $FF)
.38b0	85 2a		sta $2a				sta 	0+objPtr
.38b2	a9 3b		lda #$3b			lda 	#((FreeMemory) >> 8) & $FF
.38b4	85 2b		sta $2b				sta 	1+objPtr
.38b6	60		rts				rts
.38b7					_CACloseOut:
.38b7	60		rts				rts
.38b8					_CAWriteByte:
.38b8	8a		txa				txa
.38b9	92 2a		sta ($2a)			sta 	(objPtr)
.38bb	e6 2a		inc $2a				inc 	objPtr
.38bd	d0 02		bne $38c1			bne 	_HWOWBNoCarry
.38bf	e6 2b		inc $2b				inc 	objPtr+1
.38c1					_HWOWBNoCarry:
.38c1	60		rts				rts
.38c2					_CAPrintScreen:
.38c2	8a		txa				txa
.38c3	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.38c6					_CARead:
.38c6	20 39 39	jsr $3939			jsr 	IOReadByte 				; copy the address of next into the buffer
.38c9	8d cf 06	sta $06cf			sta 	SourceLine+0
.38cc	20 39 39	jsr $3939			jsr 	IOReadByte
.38cf	8d d0 06	sta $06d0			sta 	SourceLine+1
.38d2	0d cf 06	ora $06cf			ora 	sourceLine				; if both were zero, exit with CC (e.g. fail)
.38d5	18		clc				clc
.38d6	f0 1e		beq $38f6			beq		_CARExit
.38d8	20 39 39	jsr $3939			jsr 	IOReadByte 				; read the line # into the buffer.
.38db	8d d1 06	sta $06d1			sta 	SourceLine+2
.38de	20 39 39	jsr $3939			jsr 	IOReadByte
.38e1	8d d2 06	sta $06d2			sta 	SourceLine+3
.38e4	a2 04		ldx #$04			ldx 	#4 						; read the body of the line.
.38e6					_CAReadLine:
.38e6	20 39 39	jsr $3939			jsr 	IOReadByte 				; now keep copying to EOL
.38e9	9d cf 06	sta $06cf,x			sta 	SourceLine,x
.38ec	e8		inx				inx
.38ed	c9 00		cmp #$00			cmp 	#0
.38ef	d0 f5		bne $38e6			bne 	_CAReadLine
.38f1	38		sec				sec 							; read a line okay
.38f2	a0 06		ldy #$06			ldy 	#SourceLine >> 8
.38f4	a2 cf		ldx #$cf			ldx 	#SourceLine & $FF
.38f6					_CARExit:
.38f6	60		rts				rts
.06cf					SourceLine:
>06cf							.fill 	256
.38f7					WriteObjectCode:
.38f7	20 1a 08	jsr $081a			jsr 	PatchOutCompile 			; makes it run the runtime on reload
.38fa	a0 39		ldy #$39			ldy 	#ObjectFile >> 8
.38fc	a2 b2		ldx #$b2			ldx 	#ObjectFile & $FF
.38fe	20 21 3a	jsr $3a21			jsr 	IOOpenWrite 				; open write
.3901	a9 01		lda #$01			lda 	#1 							; write out the load address $0801
.3903	20 2c 3a	jsr $3a2c			jsr 	IOWriteByte
.3906	a9 08		lda #$08			lda 	#8
.3908	20 2c 3a	jsr $3a2c			jsr 	IOWriteByte
.390b	a9 01		lda #$01			lda 	#((StartBasicProgram) & $FF)
.390d	85 2c		sta $2c				sta 	0+zTemp0
.390f	a9 08		lda #$08			lda 	#((StartBasicProgram) >> 8) & $FF
.3911	85 2d		sta $2d				sta 	1+zTemp0
.3913					_WOCLoop:
.3913	b2 2c		lda ($2c)			lda 	(zTemp0) 					; write code
.3915	20 2c 3a	jsr $3a2c			jsr 	IOWriteByte
.3918	e6 2c		inc $2c				inc 	zTemp0 						; advance pointer
.391a	d0 02		bne $391e			bne 	_WOCSkip
.391c	e6 2d		inc $2d				inc 	zTemp0+1
.391e					_WOCSkip:
.391e	a5 2c		lda $2c				lda 	zTemp0 						; check end
.3920	c5 2a		cmp $2a				cmp 	objPtr
.3922	d0 ef		bne $3913			bne 	_WOCLoop
.3924	a5 2d		lda $2d				lda 	zTemp0+1
.3926	c5 2b		cmp $2b				cmp 	objPtr+1
.3928	d0 e9		bne $3913			bne 	_WOCLoop
.392a	20 48 39	jsr $3948			jsr 	IOWriteClose 				; close the file.
.392d	60		rts				rts
.392e					IOOpenRead:
.392e	a9 52		lda #$52			lda 	#'R' 						; read.
.3930	20 51 39	jsr $3951			jsr 	IOSetFileName 				; set up name/LFS
.3933	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for reading
.3935	20 c6 ff	jsr $ffc6			jsr 	$FFC6 						; CHKIN
.3938	60		rts				rts
.3939					IOReadByte:
.3939	da		phx				phx
.393a	5a		phy				phy
.393b	20 b7 ff	jsr $ffb7			jsr 	$FFB7 						; read ST
.393e	38		sec				sec
.393f	d0 04		bne $3945			bne 	_IORExit
.3941	20 cf ff	jsr $ffcf			jsr 	$FFCF 						; read a byte
.3944	18		clc				clc 								; status OK.
.3945					_IORExit:
.3945	7a		ply				ply
.3946	fa		plx				plx
.3947	60		rts				rts
.3948					IOReadClose:
.3948					IOWriteClose:
.3948	a9 03		lda #$03			lda 	#3 							; CLOSE# 3
.394a	20 c3 ff	jsr $ffc3			jsr 	$FFC3
.394d	20 cc ff	jsr $ffcc			jsr 	$FFCC 						; CLRCHN
.3950	60		rts				rts
.3951					IOSetFileName:
.3951	48		pha				pha 								; save R/W
.3952	86 2c		stx $2c				stx 	zTemp0
.3954	84 2d		sty $2d				sty 	zTemp0+1
.3956	a0 ff		ldy #$ff			ldy 	#$FF 						; copy name given
.3958					_IOSCopy:
.3958	c8		iny				iny 								; pre-increment copy
.3959	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.395b	99 cf 07	sta $07cf,y			sta 	IONameBuffer,y
.395e	d0 f8		bne $3958			bne 	_IOSCopy
.3960	99 d3 07	sta $07d3,y			sta 	IONameBuffer+4,y
.3963	a9 2c		lda #$2c			lda 	#',' 						; append ,S,[R|W]
.3965	99 cf 07	sta $07cf,y			sta 	IONameBuffer+0,y
.3968	99 d1 07	sta $07d1,y			sta 	IONameBuffer+2,y
.396b	a9 53		lda #$53			lda 	#'S'
.396d	99 d0 07	sta $07d0,y			sta 	IONameBuffer+1,y
.3970	68		pla				pla 								; write R/W out
.3971	99 d2 07	sta $07d2,y			sta 	IONameBuffer+3,y
.3974	98		tya				tya 								; length of name to A
.3975	18		clc				clc
.3976	69 04		adc #$04			adc 	#4 							; we added 4 characters.
.3978	a2 cf		ldx #$cf			ldx 	#IONameBuffer & $FF			; name address to YX
.397a	a0 07		ldy #$07			ldy 	#IONameBuffer >> 8
.397c	20 bd ff	jsr $ffbd		    jsr 	$FFBD          				; call SETNAM
.397f	a9 03		lda #$03	    	lda 	#3 							; set LFS to 3,8,3
.3981	a2 08		ldx #$08			ldx 	#8
.3983	a0 03		ldy #$03			ldy 	#3
.3985	20 ba ff	jsr $ffba			jsr 	$FFBA
.3988	20 c0 ff	jsr $ffc0			jsr 	$FFC0 						; OPEN
.398b	60		rts				rts
.07cf					IONameBuffer:
>07cf							.fill 	64
.398c					CompileCode:
.398c	a2 00		ldx #$00			ldx 	#0
.398e	bd c8 39	lda $39c8,x	_Prompt:lda 	Prompt,x
.3991	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3994	e8		inx				inx
.3995	c9 00		cmp #$00			cmp 	#0
.3997	d0 f5		bne $398e			bne 	_Prompt
.3999	a2 ae		ldx #$ae			ldx 	#APIDesc & $FF
.399b	a0 39		ldy #$39			ldy 	#APIDesc >> 8
.399d	20 b9 2a	jsr $2ab9			jsr 	StartCompiler
.39a0	20 f7 38	jsr $38f7			jsr 	WriteObjectCode
.39a3	a9 4f		lda #$4f			lda 	#"O"
.39a5	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.39a8	a9 4b		lda #$4b			lda 	#"K"
.39aa	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.39ad	60		rts				rts
.39ae					APIDesc:
>39ae	80 38						.word 	CompilerAPI 				; the compiler API Implementeation
>39b0	80						.byte 	$80 						; start of workspace for compiler $8000
>39b1	9f						.byte 	$9F							; end of workspace for compiler $9F00
.39b2					ObjectFile:
>39b2	4f 42 4a 45 43 54 2e 50				.text 	'OBJECT.PRG',0
>39ba	52 47 00
.39bd					SourceFile:
>39bd	53 4f 55 52 43 45 2e 50				.text 	'SOURCE.PRG',0
>39c5	52 47 00
.39c8					Prompt:
>39c8	2a 2a 2a 20 42 4c 49 54				.text 	'*** BLITZ (ALPHA 09-10-23) ***',13,13
>39d0	5a 20 28 41 4c 50 48 41 20 30 39 2d 31 30 2d 32
>39e0	33 29 20 2a 2a 2a 0d 0d
>39e8	42 55 47 53 3a 48 54 54				.text 	'BUGS:HTTPS://GITHUB.COM/PAULSCOTTROBSON/BLITZ-COMPILER',13,13,0
>39f0	50 53 3a 2f 2f 47 49 54 48 55 42 2e 43 4f 4d 2f
>3a00	50 41 55 4c 53 43 4f 54 54 52 4f 42 53 4f 4e 2f
>3a10	42 4c 49 54 5a 2d 43 4f 4d 50 49 4c 45 52 0d 0d
>3a20	00
.3a21					IOOpenWrite:
.3a21	a9 57		lda #$57			lda 	#'W'			 			; write
.3a23	20 51 39	jsr $3951			jsr 	IOSetFileName 				; set up name/LFS
.3a26	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for writing
.3a28	20 c9 ff	jsr $ffc9			jsr 	$FFC9 						; CHKOUT
.3a2b	60		rts				rts
.3a2c					IOWriteByte:
.3a2c	48		pha				pha
.3a2d	da		phx				phx
.3a2e	5a		phy				phy
.3a2f	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a32	7a		ply				ply
.3a33	fa		plx				plx
.3a34	68		pla				pla
.3a35	60		rts				rts

;******  Processing input file: source/main/zzfree.footer

>3a36							.align 	256
.3b00					FreeMemory:

;******  End of listing
