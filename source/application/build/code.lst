
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl source/main/00main.header /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library _library.asm source/main/zzfree.footer
; Mon Oct  9 14:14:58 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: source/main/00main.header

.0801					StartBasicProgram:
>0801	0c 08						.word 	$080C 						; offset to next.
>0803	0a 00						.word 	10 							; line #
>0805	9e						.byte 	$9E 						; token for 'SYS'
>0806	20 32 30 36 32					.text 	' 2062'						; space, $080E in decimal
>080b	00						.byte  	0 							; end of line
>080c	00 00						.word 	0 							; end of program
.080e					StartCode:
.080e	4c 4e 39	jmp $394e			jmp 	CompileCode 				; to starting the runtime in the saved code.
.0811	a9 3a		lda #$3a			lda 	#FreeMemory >> 8 			; address of object code to run.
.0813	a2 80		ldx #$80			ldx 	#$80 						; 8000-9EFF is used for workspace.
.0815	a0 9f		ldy #$9f			ldy 	#$9F
.0817	4c 26 08	jmp $0826			jmp 	StartRuntime 				; and go do it !
.081a					PatchOutCompile:
.081a	a9 ea		lda #$ea			lda 	#$EA 						; $EA is NOP 65C02
.081c	8d 0e 08	sta $080e			sta 	StartCode 					; patch out "JMP COMPILECODE"
.081f	8d 0f 08	sta $080f			sta 	StartCode+1
.0822	8d 10 08	sta $0810			sta 	StartCode+2
.0825	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.0826					StartRuntime:
.0826	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.0829	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.082b	64 28		stz $28				stz 	codePtr
.082d	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0830	8c 06 04	sty $0406			sty 	storeEndHigh
.0833	8e 07 04	stx $0407			stx 	variableStartPage
.0836	ba		tsx				tsx 								; save the stack.
.0837	8e 08 04	stx $0408			stx 	Runtime6502SP
.083a	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.083c	a2 46		ldx #$46			ldx 	#RuntimeErrorHandler & $FF
.083e	20 ce 1e	jsr $1ece			jsr 	SetErrorHandler
.0841	20 73 0a	jsr $0a73			jsr 	ClearMemory 				; clear memory.
.0844	20 55 16	jsr $1655			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0847	20 57 13	jsr $1357		 	jsr		SetDefaultChannel			; set default input/output channel.
.084a	20 8d 15	jsr $158d			jsr 	RestoreCode 				; which we now call
.084d	a0 00		ldy #$00			ldy 	#0
.084f					NextCommand:
.084f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.0851	30 5b		bmi $08ae			bmi 	NXCommand 					; -if -ve command
.0853	c8		iny				iny
.0854	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0856	90 39		bcc $0891			bcc 	PushByteA 					; 0..63 is short constants.
.0858					NXLoadStore:
.0858	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.085a	b0 19		bcs $0875			bcs 	NXIndirectLoadStore
.085c	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.085d	4a		lsr a				lsr 	a
.085e	29 0e		and #$0e			and 	#$0E
.0860	da		phx				phx 								; get ready to jump
.0861	aa		tax				tax
.0862	7c 65 08	jmp ($0865,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.0865					ReadWriteVectors:
>0865	c3 14						.word 	ReadFloatCommand			; read float
>0867	9e 1a						.word 	WriteFloatCommand 			; write float
>0869	ff 14						.word 	ReadIntegerCommand 			; read integer
>086b	da 1a						.word 	WriteIntegerCommand 		; write integer
>086d	44 15						.word 	ReadStringCommand 			; read string
>086f	19 1b						.word 	WriteStringCommand 			; write string
>0871	43 0c						.word 	Unimplemented
>0873	43 0c						.word 	Unimplemented
.0875					NXIndirectLoadStore:
.0875	29 07		and #$07			and 	#7
.0877	0a		asl a				asl 	a
.0878	da		phx				phx
.0879	aa		tax				tax
.087a	7c 7d 08	jmp ($087d,x)			jmp 	(IndirectVectors,x)
.087d					IndirectVectors:
>087d	f9 0e						.word 	IndFloatRead 				; float read
>087f	0d 0f						.word 	IndInt16Read 				; int16 read
>0881	21 0f						.word 	IndStringRead 				; string read
>0883	43 0c						.word 	Unimplemented
>0885	35 0f						.word 	IndFloatWrite				; float write
>0887	49 0f						.word 	IndInt16Write 				; int16 write
>0889	5d 0f						.word 	IndStringWrite 				; string write
>088b	43 0c						.word 	Unimplemented
.088d					PushByteCommand:
.088d	fa		plx				plx
.088e	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.0890	c8		iny				iny
.0891					PushByteA:
.0891	e8		inx				inx 								; push constant on stack
.0892	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.0894	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.0896					ClearRestWord:
.0896	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.0898	74 62		stz $62,x			stz 	NSMantissa3,x
.089a	74 6e		stz $6e,x			stz 	NSExponent,x
.089c	74 32		stz $32,x			stz 	NSStatus,x
.089e	80 af		bra $084f			bra 	NextCommand
.08a0					PushWordCommand:
.08a0	fa		plx				plx
.08a1	e8		inx				inx
.08a2	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.08a4	c8		iny				iny
.08a5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08a7	b1 28		lda ($28),y			lda 	(codePtr),y
.08a9	c8		iny				iny
.08aa	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08ac	80 e8		bra $0896			bra 	ClearRestWord 				; handle everything else.
.08ae					NXCommand:
.08ae	c8		iny				iny 								; consume command.
.08af	10 03		bpl $08b4			bpl 	_NXCommandNoFixUp
.08b1	20 ba 08	jsr $08ba			jsr 	FixUpY
.08b4					_NXCommandNoFixUp:
.08b4	0a		asl a				asl 	a 							; shift left
.08b5	da		phx				phx 								; save SP on stack
.08b6	aa		tax				tax				 					; and jump indirect
.08b7	7c 7f 19	jmp ($197f,x)			jmp 	(VectorTable,x)
.08ba					FixUpY:
.08ba	48		pha				pha
.08bb	98		tya				tya
.08bc	18		clc				clc
.08bd	65 28		adc $28				adc 	codePtr
.08bf	85 28		sta $28				sta 	codePtr
.08c1	90 02		bcc $08c5			bcc 	_NoCPCarry
.08c3	e6 29		inc $29				inc 	codePtr+1
.08c5					_NoCPCarry:
.08c5	a0 00		ldy #$00			ldy 	#0
.08c7	68		pla				pla
.08c8	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.0408					Runtime6502SP:
>0408							.fill 	1
.08c9					AbsoluteTOS:
.08c9	fa		plx				plx
.08ca	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08cc	4c 4f 08	jmp $084f			jmp 	NextCommand
.08cf					CommandVarSpace:
.08cf	fa		plx				plx
.08d0	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08d2	85 26		sta $26				sta 	availableMemory
.08d4	c8		iny				iny
.08d5	b1 28		lda ($28),y			lda 	(codePtr),y
.08d7	18		clc				clc
.08d8	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08db	85 27		sta $27				sta 	availableMemory+1
.08dd	c8		iny				iny
.08de	4c 4f 08	jmp $084f			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08e1					BinaryAnd:
.08e1	fa		plx				plx
.08e2	38		sec				sec
.08e3	80 02		bra $08e7			bra 	AndOrCommon
.08e5					BinaryOr:
.08e5	fa		plx				plx
.08e6	18		clc				clc
.08e7					AndOrCommon:
.08e7	08		php				php 								; save AND/OR flag
.08e8	20 34 10	jsr $1034			jsr 	GetInteger16Bit
.08eb	ca		dex				dex
.08ec	20 34 10	jsr $1034			jsr 	GetInteger16Bit
.08ef	28		plp				plp
.08f0	90 0e		bcc $0900			bcc 	_AOCOrCode
.08f2	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.08f4	35 3f		and $3f,x			and		NSMantissa0+1,x
.08f6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08f8	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.08fa	35 4b		and $4b,x			and		NSMantissa1+1,x
.08fc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08fe	80 0c		bra $090c			bra 	_AOCComplete
.0900					_AOCOrCode:
.0900	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.0902	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.0904	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0906	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0908	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.090a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.090c					_AOCComplete:
.090c	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.090e	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.0910	10 07		bpl $0919			bpl 	_AOCExit
.0912	20 44 10	jsr $1044			jsr 	Negate16Bit 				; 2's complement
.0915	a9 80		lda #$80			lda 	#$80 						; make it -ve
.0917	95 32		sta $32,x			sta 	NSStatus,x
.0919					_AOCExit:
.0919	4c 4f 08	jmp $084f			jmp 	NextCommand
.091c					ArrayConvert:
.091c	fa		plx				plx
.091d	5a		phy				phy
.091e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0920	85 2e		sta $2e				sta 	zTemp1
.0922	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0924	18		clc				clc
.0925	6d 07 04	adc $0407			adc 	variableStartPage
.0928	85 2f		sta $2f				sta 	zTemp1+1
.092a	ca		dex				dex 								; count of indices to follow -> zTemp2
.092b	20 2e 10	jsr $102e			jsr 	GetInteger8Bit
.092e	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.0930	8a		txa				txa
.0931	38		sec				sec
.0932	e5 30		sbc $30				sbc 	zTemp2
.0934	aa		tax				tax
.0935	da		phx				phx 								; stack points at the first index, which will be replaced.
.0936					_ACIndexLoop:
.0936	20 76 22	jsr $2276			jsr 	FloatIntegerPart 			; integer array index
.0939	20 34 10	jsr $1034			jsr 	GetInteger16Bit 			; get the index => zTemp0
.093c	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.093e	a5 2c		lda $2c				lda 	zTemp0
.0940	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0942	a5 2d		lda $2d				lda 	zTemp0+1
.0944	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0946	b0 79		bcs $09c1			bcs 	_ACBadIndex 				; index error.
.0948	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.094a	f0 29		beq $0975			beq 	_ACInnerLevel
.094c	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.094e	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0950	10 6f		bpl $09c1			bpl 	_ACBadIndex
.0952	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0954	26 2d		rol $2d				rol 	zTemp0+1
.0956	18		clc				clc
.0957	a5 2c		lda $2c				lda		zTemp0
.0959	65 2e		adc $2e				adc 	zTemp1
.095b	85 2c		sta $2c				sta 	zTemp0
.095d	a5 2d		lda $2d				lda		zTemp0+1
.095f	65 2f		adc $2f				adc 	zTemp1+1
.0961	85 2d		sta $2d				sta 	zTemp0+1
.0963	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.0965	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0967	85 2e		sta $2e				sta 	zTemp1
.0969	c8		iny				iny
.096a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.096c	18		clc				clc
.096d	6d 07 04	adc $0407			adc 	variableStartPage
.0970	85 2f		sta $2f				sta 	zTemp1+1
.0972	e8		inx				inx 								; next index
.0973	80 c1		bra $0936			bra 	_ACIndexLoop
.0975					_ACInnerLevel:
.0975	a0 02		ldy #$02			ldy 	#2
.0977	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0979	30 46		bmi $09c1			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.097b	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.097d	c9 00		cmp #$00			cmp 	#NSSIFloat
.097f	d0 13		bne $0994			bne 	_ACNotFloat
.0981	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.0983	48		pha				pha
.0984	a5 2c		lda $2c				lda 	zTemp0
.0986	06 2c		asl $2c				asl 	zTemp0 						; x 2
.0988	26 2d		rol $2d				rol 	zTemp0+1
.098a	18		clc				clc 								; add back x 3
.098b	65 2c		adc $2c				adc 	zTemp0
.098d	85 2c		sta $2c				sta 	zTemp0
.098f	68		pla				pla
.0990	65 2d		adc $2d				adc 	zTemp0+1
.0992	85 2d		sta $2d				sta 	zTemp0+1
.0994					_ACNotFloat:
.0994	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.0996	26 2d		rol $2d				rol 	zTemp0+1
.0998	18		clc				clc
.0999	a5 2c		lda $2c				lda 	zTemp0
.099b	69 03		adc #$03			adc 	#3
.099d	85 2c		sta $2c				sta 	zTemp0
.099f	90 02		bcc $09a3			bcc 	_ACNoCarry
.09a1	e6 2d		inc $2d				inc 	zTemp0+1
.09a3					_ACNoCarry:
.09a3	fa		plx				plx 								; X points to first slot of array parameters
.09a4	18		clc				clc
.09a5	a5 2c		lda $2c				lda 	zTemp0
.09a7	65 2e		adc $2e				adc 	zTemp1
.09a9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.09ab	a5 2d		lda $2d				lda 	zTemp0+1
.09ad	65 2f		adc $2f				adc 	zTemp1+1
.09af	38		sec				sec
.09b0	ed 07 04	sbc $0407			sbc 	variableStartPage
.09b3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.09b5	74 56		stz $56,x			stz 	NSMantissa2,x
.09b7	74 62		stz $62,x			stz 	NSMantissa3,x
.09b9	74 32		stz $32,x			stz 	NSStatus,x
.09bb	74 6e		stz $6e,x			stz 	NSExponent,x
.09bd	7a		ply				ply 	 							; restore code pointer
.09be	4c 4f 08	jmp $084f			jmp 	NextCommand
.09c1					_ACBadIndex:
.09c1	4c d0 1f	jmp $1fd0		jmp	ErrorV_index
.09c4					UnaryAsc:
.09c4	fa		plx				plx
.09c5	5a		phy				phy
.09c6	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09c8	85 2c		sta $2c				sta 	zTemp0
.09ca	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09cc	85 2d		sta $2d				sta 	zTemp0+1
.09ce	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09d0	f0 06		beq $09d8			beq 	_UAExit
.09d2	5a		phy				phy 								; otherwise first character
.09d3	a0 01		ldy #$01			ldy 	#1
.09d5	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09d7	7a		ply				ply
.09d8					_UAExit:
.09d8	20 3d 26	jsr $263d			jsr 	FloatSetByte
.09db	7a		ply				ply
.09dc	4c 4f 08	jmp $084f			jmp 	NextCommand
.09df					CommandAssert:
.09df	fa		plx				plx
.09e0	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09e2	d0 09		bne $09ed			bne 	_CAFail
.09e4	20 5d 26	jsr $265d			jsr 	FloatIsZero 				; is it zero ?
.09e7	f0 04		beq $09ed			beq 	_CAFail
.09e9	ca		dex				dex
.09ea	4c 4f 08	jmp $084f			jmp 	NextCommand
.09ed					_CAFail:
.09ed	4c 29 1f	jmp $1f29		jmp	ErrorV_assert
.09f0					X16_Audio_Parameters8_16:
.09f0	20 f6 09	jsr $09f6			jsr 	X16_Audio_Parameters8_8
.09f3	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.09f5	60		rts				rts
.09f6					X16_Audio_Parameters8_8:
.09f6	a2 01		ldx #$01			ldx 	#1
.09f8	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.09fb	ca		dex				dex
.09fc	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.09ff	20 2e 10	jsr $102e			jsr 	GetInteger8Bit
.0a02	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.0a04	a0 00		ldy #$00			ldy 	#0
.0a06	60		rts				rts
.0a07					X16_Audio_Parameters8_String:
.0a07	20 f0 09	jsr $09f0			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.0a0a	da		phx				phx 								; set the voice
.0a0b	5a		phy				phy
.0a0c	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.0a0f	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>0a12	0a						.byte 	X16_AudioCodeBank
.0a13	7a		ply				ply
.0a14	fa		plx				plx
.0a15	86 2c		stx $2c				stx 	zTemp0
.0a17	84 2d		sty $2d				sty 	zTemp0+1
.0a19	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a1b	e8		inx				inx 								; point YX to first character.
.0a1c	d0 01		bne $0a1f			bne 	_X16APSSkip
.0a1e	c8		iny				iny
.0a1f					_X16APSSkip:
.0a1f	60		rts				rts
.0a20					Unary16Bin:
.0a20	fa		plx				plx
.0a21	20 34 10	jsr $1034			jsr 	GetInteger16Bit				; 16 bit int
.0a24	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a26	20 fe 16	jsr $16fe			jsr 	StringAllocTemp
.0a29	a5 2d		lda $2d				lda 	zTemp0+1
.0a2b	f0 03		beq $0a30			beq 	_UBNoHigh
.0a2d	20 38 0a	jsr $0a38			jsr 	_UBWriteBinary
.0a30					_UBNoHigh:
.0a30	a5 2c		lda $2c				lda 	zTemp0
.0a32	20 38 0a	jsr $0a38			jsr 	_UBWriteBinary
.0a35	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a38					_UBWriteBinary:
.0a38	5a		phy				phy
.0a39	a0 08		ldy #$08			ldy 	#8
.0a3b					_UBWLoop:
.0a3b	0a		asl a				asl 	a
.0a3c	48		pha				pha
.0a3d	a9 00		lda #$00			lda  	#0
.0a3f	69 30		adc #$30			adc 	#48
.0a41	20 27 17	jsr $1727			jsr 	StringWriteChar
.0a44	68		pla				pla
.0a45	88		dey				dey
.0a46	d0 f3		bne $0a3b			bne 	_UBWLoop
.0a48	7a		ply				ply
.0a49	60		rts				rts
.0a4a					PrintCharacterX:
.0a4a	fa		plx				plx
.0a4b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a4d	ca		dex				dex
.0a4e	20 5b 13	jsr $135b			jsr 	VectorPrintCharacter
.0a51	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a54					UnaryChr:
.0a54	fa		plx				plx
.0a55	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; get integer to convert.
.0a58	48		pha				pha 								; save it and allocate for it
.0a59	a9 01		lda #$01			lda 	#1 							; 1 character
.0a5b	20 fe 16	jsr $16fe			jsr 	StringAllocTemp
.0a5e	a9 01		lda #$01			lda 	#1 							; length 1.
.0a60	92 22		sta ($22)			sta 	(zsTemp)
.0a62	68		pla				pla 								; character code makes string.
.0a63	5a		phy				phy
.0a64	a0 01		ldy #$01			ldy 	#1
.0a66	91 22		sta ($22),y			sta 	(zsTemp),y
.0a68	7a		ply				ply
.0a69	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a6c					CommandClr:
.0a6c	fa		plx				plx
.0a6d	20 73 0a	jsr $0a73			jsr 	ClearMemory
.0a70	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a73					ClearMemory:
.0a73	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a76	85 2d		sta $2d				sta 	zTemp0+1
.0a78	64 2c		stz $2c				stz 	zTemp0
.0a7a	5a		phy				phy
.0a7b	a0 00		ldy #$00			ldy 	#0
.0a7d					_ClearLoop1:
.0a7d	a9 00		lda #$00			lda 	#0
.0a7f	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a81	c8		iny				iny
.0a82	d0 f9		bne $0a7d			bne 	_ClearLoop1
.0a84	e6 2d		inc $2d				inc 	zTemp0+1
.0a86	a5 2d		lda $2d				lda 	zTemp0+1
.0a88	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a8b	d0 f0		bne $0a7d			bne 	_ClearLoop1
.0a8d	38		sec				sec 											; stack space = number of pages in total / 4
.0a8e	ad 06 04	lda $0406			lda 	storeEndHigh
.0a91	ed 05 04	sbc $0405			sbc		storeStartHigh
.0a94	4a		lsr a				lsr 	a
.0a95	4a		lsr a				lsr 	a
.0a96	d0 02		bne $0a9a			bne 	_NotEmpty 								; at least 1 !
.0a98	a9 01		lda #$01			lda 	#1
.0a9a					_NotEmpty:
.0a9a	38		sec				sec 											; subtract from high to give string high memory
.0a9b	49 ff		eor #$ff			eor 	#$FF
.0a9d	6d 06 04	adc $0406			adc 	storeEndHigh
.0aa0	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0aa3	9c 02 04	stz $0402			stz 	stringHighMemory
.0aa6	9c 69 05	stz $0569			stz 	stringInitialised 						; string system not initialised
.0aa9	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0aac	3a		dec a				dec 	a
.0aad	85 25		sta $25				sta 	runtimeStackPtr+1
.0aaf	a9 ff		lda #$ff			lda 	#$FF
.0ab1	85 24		sta $24				sta 	runtimeStackPtr
.0ab3	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0ab5	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0ab7	7a		ply				ply
.0ab8	60		rts				rts
.0ab9					CompareStrings:
.0ab9	fa		plx				plx
.0aba	ca		dex				dex
.0abb	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0abd	85 2c		sta $2c				sta 	zTemp0
.0abf	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ac1	85 2d		sta $2d				sta 	zTemp0+1
.0ac3	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0ac5	85 2e		sta $2e				sta 	zTemp1
.0ac7	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0ac9	85 2f		sta $2f				sta 	zTemp1+1
.0acb	da		phx				phx
.0acc	5a		phy				phy
.0acd	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0acf	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0ad1	90 02		bcc $0ad5			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0ad3	b2 2e		lda ($2e)			lda 	(zTemp1)
.0ad5					_CSNIsSmallest:
.0ad5	aa		tax				tax 								; count in X
.0ad6	f0 0c		beq $0ae4			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0ad8	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0ada					_CSNCompareString:
.0ada	c8		iny				iny 								; pre increment
.0adb	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0add	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0adf	d0 0a		bne $0aeb			bne 	_CSNDifferent 				; numbers are different.
.0ae1	ca		dex				dex
.0ae2	d0 f6		bne $0ada			bne 	_CSNCompareString 			; compare common characters in two strings.
.0ae4					_CSNMatches:
.0ae4	38		sec				sec
.0ae5	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0ae7	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0ae9	f0 06		beq $0af1			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0aeb					_CSNDifferent:
.0aeb	a9 ff		lda #$ff			lda 	#$FF
.0aed	90 02		bcc $0af1			bcc 	_CSNSExit
.0aef	a9 01		lda #$01			lda 	#$01
.0af1					_CSNSExit:
.0af1	7a		ply				ply
.0af2	fa		plx				plx
.0af3	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0af5	20 3d 26	jsr $263d			jsr 	FloatSetByte 				; output the byte
.0af8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0afb					StringConcrete:
.0afb	9c 69 05	stz $0569			stz 	stringInitialised	 		; initialise next usage
.0afe	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0b00	85 30		sta $30				sta 	zTemp2
.0b02	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0b04	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0b05	18		clc				clc
.0b06	72 30		adc ($30)			adc 	(zTemp2)
.0b08	90 02		bcc $0b0c			bcc 	_SCNoOverflow
.0b0a	a9 ff		lda #$ff			lda 	#255
.0b0c					_SCNoOverflow:
.0b0c	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0b0e	b0 02		bcs $0b12			bcs 	_SCNoMinimum
.0b10	a9 0a		lda #$0a			lda 	#10
.0b12					_SCNoMinimum:
.0b12	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0b14	38		sec				sec
.0b15	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0b18	e5 2e		sbc $2e				sbc 	zTemp1
.0b1a	a8		tay				tay
.0b1b	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b1e	e9 00		sbc #$00			sbc 	#0
.0b20	48		pha				pha
.0b21	38		sec				sec 								; subtract 3 more
.0b22	98		tya				tya
.0b23	e9 03		sbc #$03			sbc 	#3
.0b25	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b28	85 22		sta $22				sta 	zsTemp
.0b2a	68		pla				pla
.0b2b	e9 00		sbc #$00			sbc 	#0
.0b2d	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b30	85 23		sta $23				sta 	zsTemp+1
.0b32	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b34	92 22		sta ($22)			sta 	(zsTemp)
.0b36	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b38	a9 00		lda #$00			lda 	#0
.0b3a	91 22		sta ($22),y			sta 	(zsTemp),y
.0b3c	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b3e	a4 23		ldy $23				ldy 	zsTemp+1
.0b40	60		rts				rts
.0b41					CommandXData:
.0b41	fa		plx				plx
.0b42	98		tya				tya 								; data length +1 added to Y
.0b43	38		sec				sec
.0b44	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b46	a8		tay				tay
.0b47	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b4a					CommandXDIM:
.0b4a	fa		plx				plx
.0b4b	5a		phy				phy
.0b4c	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b4f	8d 09 04	sta $0409			sta 	dimType
.0b52	ca		dex				dex 								; this is the number of indices
.0b53	20 2e 10	jsr $102e			jsr 	GetInteger8Bit
.0b56	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b58	8a		txa				txa 								; dimension.
.0b59	38		sec				sec
.0b5a	e5 2e		sbc $2e				sbc 	zTemp1
.0b5c	aa		tax				tax
.0b5d	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b5f	20 73 0b	jsr $0b73			jsr 	DIMCreateOneLevel 			; create one at this level
.0b62	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b64	98		tya				tya
.0b65	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b67	74 56		stz $56,x			stz 	NSMantissa2,x
.0b69	74 62		stz $62,x			stz 	NSMantissa3,x
.0b6b	74 32		stz $32,x			stz 	NSStatus,x
.0b6d	74 6e		stz $6e,x			stz 	NSExponent,x
.0b6f	7a		ply				ply
.0b70	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b73					DIMCreateOneLevel:
.0b73	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b75	5a		phy				phy
.0b76	a4 27		ldy $27				ldy 	availableMemory+1
.0b78	5a		phy				phy
.0b79	a8		tay				tay 			 					; save current level into Y
.0b7a	20 34 10	jsr $1034			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b7d	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b7f	d0 02		bne $0b83			bne 	_DCOLNoCarry
.0b81	e6 2d		inc $2d				inc 	zTemp0+1
.0b83					_DCOLNoCarry:
.0b83	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b85	20 26 0c	jsr $0c26			jsr 	DIMWriteByte
.0b88	a5 2d		lda $2d				lda 	zTemp0+1
.0b8a	20 26 0c	jsr $0c26			jsr 	DIMWriteByte
.0b8d	ad 09 04	lda $0409			lda 	dimType 					; get type information
.0b90	29 7f		and #$7f			and 	#$7F
.0b92	c0 01		cpy #$01			cpy 	#1
.0b94	f0 02		beq $0b98			beq 	_DCOLNoSubLevel
.0b96	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0b98					_DCOLNoSubLevel:
.0b98	20 26 0c	jsr $0c26			jsr 	DIMWriteByte
.0b9b	a5 26		lda $26				lda 	availableMemory
.0b9d	85 2e		sta $2e				sta 	zTemp1
.0b9f	a5 27		lda $27				lda 	availableMemory+1
.0ba1	85 2f		sta $2f				sta 	zTemp1+1
.0ba3	a5 2c		lda $2c				lda 	zTemp0
.0ba5	85 30		sta $30				sta 	zTemp2
.0ba7	a5 2d		lda $2d				lda 	zTemp0+1
.0ba9	85 31		sta $31				sta 	zTemp2+1
.0bab					_DCOLFillArray:
.0bab	20 0a 0c	jsr $0c0a			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0bae	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0bb0	d0 02		bne $0bb4			bne 	_DCOLNoBorrow
.0bb2	c6 2d		dec $2d				dec 	zTemp0+1
.0bb4					_DCOLNoBorrow:
.0bb4	c6 2c		dec $2c				dec 	zTemp0
.0bb6	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0bb8	05 2d		ora $2d				ora 	zTemp0+1
.0bba	d0 ef		bne $0bab			bne 	_DCOLFillArray
.0bbc	c0 01		cpy #$01			cpy 	#1
.0bbe	f0 42		beq $0c02			beq 	_DCOLExit
.0bc0					_DCOLRecursionLoop:
.0bc0	da		phx				phx 								; save XY
.0bc1	5a		phy				phy
.0bc2	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0bc4	48		pha				pha
.0bc5	a5 2f		lda $2f				lda 	zTemp1+1
.0bc7	48		pha				pha
.0bc8	a5 30		lda $30				lda 	zTemp2
.0bca	48		pha				pha
.0bcb	a5 31		lda $31				lda 	zTemp2+1
.0bcd	48		pha				pha
.0bce	88		dey				dey  								; lower level -> A
.0bcf	98		tya				tya
.0bd0	e8		inx				inx 								; next index size
.0bd1	20 73 0b	jsr $0b73			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0bd4	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0bd5	86 31		stx $31				stx 	zTemp2+1
.0bd7	fa		plx				plx
.0bd8	86 30		stx $30				stx 	zTemp2
.0bda	fa		plx				plx
.0bdb	86 2f		stx $2f				stx 	zTemp1+1
.0bdd	fa		plx				plx
.0bde	86 2e		stx $2e				stx 	zTemp1
.0be0	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0be2	98		tya				tya
.0be3	a0 01		ldy #$01			ldy 	#1
.0be5	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0be7	7a		ply				ply 								; restore XY
.0be8	fa		plx				plx
.0be9	18		clc				clc
.0bea	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0bec	69 02		adc #$02			adc 	#2
.0bee	85 2e		sta $2e				sta 	zTemp1
.0bf0	90 02		bcc $0bf4			bcc 	_DCOLRNoCarry
.0bf2	e6 2f		inc $2f				inc 	zTemp1+1
.0bf4					_DCOLRNoCarry:
.0bf4	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0bf6	d0 02		bne $0bfa			bne 	_DCOLRNoBorrow
.0bf8	c6 31		dec $31				dec 	zTemp2+1
.0bfa					_DCOLRNoBorrow:
.0bfa	c6 30		dec $30				dec 	zTemp2
.0bfc	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0bfe	05 31		ora $31				ora 	zTemp2+1
.0c00	d0 be		bne $0bc0			bne 	_DCOLRecursionLoop
.0c02					_DCOLExit:
.0c02	68		pla				pla 								; get MSB, make offset again
.0c03	38		sec				sec
.0c04	ed 07 04	sbc $0407			sbc 	variableStartPage
.0c07	a8		tay				tay
.0c08	68		pla				pla 								; YA now contains offset address.
.0c09	60		rts				rts
.0c0a					DIMWriteElement:
.0c0a	da		phx				phx
.0c0b	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0c0d	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0c0f	d0 0b		bne $0c1c			bne 	_DIMWENotFloat
.0c11	ad 09 04	lda $0409			lda 	dimType
.0c14	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0c16	c9 00		cmp #$00			cmp 	#NSSIFloat
.0c18	d0 02		bne $0c1c			bne 	_DIMWENotFloat
.0c1a	a2 06		ldx #$06			ldx 	#6
.0c1c					_DIMWENotFloat:
.0c1c	a9 00		lda #$00			lda 	#0
.0c1e	20 26 0c	jsr $0c26			jsr 	DIMWriteByte
.0c21	ca		dex				dex
.0c22	d0 f8		bne $0c1c			bne 	_DIMWENotFloat
.0c24	fa		plx				plx
.0c25	60		rts				rts
.0c26					DIMWriteByte:
.0c26	92 26		sta ($26)			sta 	(availableMemory)
.0c28	e6 26		inc $26				inc 	availableMemory
.0c2a	d0 0b		bne $0c37			bne 	_DIMWBSkip
.0c2c	e6 27		inc $27				inc 	availableMemory+1
.0c2e	48		pha				pha
.0c2f	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c31	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c34	b0 02		bcs $0c38			bcs 	_DIMWBMemory
.0c36	68		pla				pla
.0c37					_DIMWBSkip:
.0c37	60		rts				rts
.0c38					_DIMWBMemory:
.0c38	4c e3 1f	jmp $1fe3		jmp	ErrorV_memory
.0409					dimType:
>0409							.fill 	1
.0c3b					CommandEnd:
.0c3b	fa		plx				plx
.0c3c	86 2c		stx $2c				stx 	zTemp0
.0c3e					EndRuntime:
.0c3e	ae 08 04	ldx $0408			ldx 	Runtime6502SP 				; set up the stack pointer
.0c41	9a		txs				txs
.0c42	60		rts				rts
.0c43					Unimplemented:
.0c43	4c 16 1f	jmp $1f16			jmp 	ErrorV_unimplemented
.0c46					RuntimeErrorHandler:
.0c46	98		tya				tya
.0c47	18		clc				clc
.0c48	65 28		adc $28				adc 	codePtr
.0c4a	85 28		sta $28				sta 	codePtr
.0c4c	90 02		bcc $0c50			bcc 	_EHNoCarry
.0c4e	e6 29		inc $29				inc 	codePtr+1
.0c50					_EHNoCarry:
.0c50	68		pla				pla
.0c51	7a		ply				ply
.0c52	85 2c		sta $2c				sta 	zTemp0
.0c54	84 2d		sty $2d				sty 	zTemp0+1
.0c56	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c58	a0 01		ldy #$01			ldy 	#1
.0c5a					_EHDisplayMsg:
.0c5a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c5c	20 73 1c	jsr $1c73			jsr 	XPrintCharacterToChannel
.0c5f	c8		iny				iny
.0c60	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c62	d0 f6		bne $0c5a			bne 	_EHDisplayMsg
.0c64	a9 20		lda #$20			lda 	#32
.0c66	20 73 1c	jsr $1c73			jsr 	XPrintCharacterToChannel
.0c69	a9 40		lda #$40			lda 	#64
.0c6b	20 73 1c	jsr $1c73			jsr 	XPrintCharacterToChannel
.0c6e	a9 20		lda #$20			lda 	#32
.0c70	20 73 1c	jsr $1c73			jsr 	XPrintCharacterToChannel
.0c73	20 79 0c	jsr $0c79			jsr 	EHDisplayCodePtr
.0c76	4c 3e 0c	jmp $0c3e			jmp 	EndRuntime
.0c79					EHDisplayCodePtr:
.0c79	a9 24		lda #$24			lda 	#'$'
.0c7b	20 73 1c	jsr $1c73			jsr 	XPrintCharacterToChannel
.0c7e	38		sec				sec
.0c7f	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c81	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c84	20 8d 0c	jsr $0c8d			jsr 	_EHDisplayHex
.0c87	a5 28		lda $28				lda 	codePtr
.0c89	20 8d 0c	jsr $0c8d			jsr 	_EHDisplayHex
.0c8c	60		rts				rts
.0c8d					_EHDisplayHex:
.0c8d	48		pha				pha
.0c8e	4a		lsr a				lsr 	a
.0c8f	4a		lsr a				lsr 	a
.0c90	4a		lsr a				lsr 	a
.0c91	4a		lsr a				lsr 	a
.0c92	20 96 0c	jsr $0c96			jsr 	_EHDisplayNibble
.0c95	68		pla				pla
.0c96					_EHDisplayNibble:
.0c96	29 0f		and #$0f			and 	#15
.0c98	c9 0a		cmp #$0a			cmp 	#10
.0c9a	90 02		bcc $0c9e			bcc 	_EHNotHex
.0c9c	69 06		adc #$06			adc 	#6
.0c9e					_EHNotHex:
.0c9e	69 30		adc #$30			adc 	#48
.0ca0	4c 73 1c	jmp $1c73			jmp 	XPrintCharacterToChannel
.0ca3					CommandXFor:
.0ca3	fa		plx				plx
.0ca4	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0ca6	20 26 0d	jsr $0d26			jsr 	StackOpenFrame
.0ca9	20 65 11	jsr $1165			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0cac	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0cae	20 08 0d	jsr $0d08			jsr 	CopyTOSToOffsetY
.0cb1	ca		dex				dex
.0cb2	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0cb4	20 08 0d	jsr $0d08			jsr 	CopyTOSToOffsetY
.0cb7	ca		dex				dex
.0cb8	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0cba	29 80		and #$80			and 	#$80
.0cbc	a0 04		ldy #$04			ldy 	#4
.0cbe	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cc0	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0cc2	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0cc4	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cc6	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0cc8	c8		iny				iny
.0cc9	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ccb	18		clc				clc
.0ccc	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0cce	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd0	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0cd3	85 2d		sta $2d				sta 	zTemp0+1
.0cd5	ca		dex				dex 								; throw reference.
.0cd6	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0cd8	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0cda	a0 0c		ldy #$0c			ldy 	#12
.0cdc	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cde	a0 12		ldy #$12			ldy 	#18
.0ce0	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0ce2	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0ce4	88		dey				dey 								; now the exponents.
.0ce5	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0ce7	a0 0b		ldy #$0b			ldy 	#11
.0ce9	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0ceb	a0 11		ldy #$11			ldy 	#17
.0ced	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cef	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0cf1	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf3	c8		iny				iny
.0cf4	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf6	c8		iny				iny
.0cf7	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf9	d0 08		bne $0d03			bne 	_CFNoOptimise
.0cfb	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0cfd	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0cff	09 40		ora #$40			ora 	#$40
.0d01	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d03					_CFNoOptimise:
.0d03	a0 00		ldy #$00			ldy 	#0
.0d05	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d08					CopyTOSToOffsetY:
.0d08	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0d0a	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d0c	c8		iny				iny
.0d0d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0d0f	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d11	c8		iny				iny
.0d12	b5 56		lda $56,x			lda 	NSMantissa2,x
.0d14	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d16	c8		iny				iny
.0d17	b5 62		lda $62,x			lda 	NSMantissa3,x
.0d19	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d1b	c8		iny				iny
.0d1c	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d1e	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d20	c8		iny				iny
.0d21	b5 32		lda $32,x			lda 	NSStatus,x
.0d23	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d25	60		rts				rts
.0d26					StackOpenFrame:
.0d26	48		pha				pha 								; save frame marker
.0d27	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d29	85 2c		sta $2c				sta 	zTemp0
.0d2b	38		sec				sec 								; subtract from runtime stack pointer.
.0d2c	a5 24		lda $24				lda		runtimeStackPtr
.0d2e	e5 2c		sbc $2c				sbc 	zTemp0
.0d30	85 24		sta $24				sta 	runtimeStackPtr
.0d32	a5 25		lda $25				lda		runtimeStackPtr+1
.0d34	e9 00		sbc #$00			sbc 	#0
.0d36	85 25		sta $25				sta 	runtimeStackPtr+1
.0d38	68		pla				pla 								; put frame marker at +0
.0d39	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d3b	60		rts				rts
.0d3c					StackCloseFrame:
.0d3c	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d3e	29 1f		and #$1f			and 	#$1F 						; size
.0d40	18		clc				clc
.0d41	65 24		adc $24				adc 	runtimeStackPtr
.0d43	85 24		sta $24				sta 	runtimeStackPtr
.0d45	90 02		bcc $0d49			bcc 	_SCFNoCarry
.0d47	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d49					_SCFNoCarry:
.0d49	60		rts				rts
.0d4a					StackFindFrame:
.0d4a	8d 0a 04	sta $040a			sta 	requiredFrame
.0d4d					_SFFLoop:
.0d4d	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d4f	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d51	f0 10		beq $0d63			beq 	SCFFail
.0d53	cd 0a 04	cmp $040a			cmp 	requiredFrame 				; found this type ?
.0d56	f0 05		beq $0d5d			beq 	_SFFFound
.0d58	20 3c 0d	jsr $0d3c			jsr 	StackCloseFrame 			; close the top frame
.0d5b	80 f0		bra $0d4d			bra 	_SFFLoop 					; and try te next.
.0d5d					_SFFFound:
.0d5d	60		rts				rts
.0d5e					StackCheckFrame:
.0d5e	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d60	d0 01		bne $0d63			bne 	SCFFail
.0d62	60		rts				rts
.0d63					SCFFail:
.0d63	4c 73 1f	jmp $1f73		jmp	ErrorV_structure
.040a					requiredFrame:
>040a							.fill 	1
.0d66					UnaryFre:
.0d66	fa		plx				plx
.0d67	20 3b 26	jsr $263b			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d6a	38		sec				sec
.0d6b	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d6e	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d71	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d73	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d76	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d79	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d7b	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d7e					CommandXGet:
.0d7e	fa		plx				plx
.0d7f	e8		inx				inx
.0d80	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d82	20 fe 16	jsr $16fe			jsr 	StringAllocTemp
.0d85	20 64 13	jsr $1364			jsr 	VectorGetCharacter 			; get a character
.0d88	c9 00		cmp #$00			cmp 	#0
.0d8a	f0 09		beq $0d95			beq 	_CGNone
.0d8c	5a		phy				phy
.0d8d	a0 01		ldy #$01			ldy 	#1 							; store char
.0d8f	91 22		sta ($22),y			sta 	(zsTemp),y
.0d91	98		tya				tya 								; store length.
.0d92	92 22		sta ($22)			sta 	(zsTemp)
.0d94	7a		ply				ply
.0d95					_CGNone:
.0d95	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d98					CommandXGosub:
.0d98	fa		plx				plx
.0d99	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0d9b	20 26 0d	jsr $0d26			jsr 	StackOpenFrame
.0d9e	20 65 11	jsr $1165			jsr 	StackSaveCurrentPosition
.0da1	4c b6 0d	jmp $0db6			jmp 	PerformGOTO
.0da4					CommandReturn:
.0da4	fa		plx				plx
.0da5	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0da7	20 4a 0d	jsr $0d4a			jsr 	StackFindFrame
.0daa	20 76 11	jsr $1176			jsr 	StackLoadCurrentPosition
.0dad	c8		iny				iny
.0dae	c8		iny				iny
.0daf	20 3c 0d	jsr $0d3c			jsr 	StackCloseFrame
.0db2	4c 4f 08	jmp $084f			jmp 	NextCommand
.0db5					CommandXGoto:
.0db5	fa		plx				plx
.0db6					PerformGOTO:
.0db6	c8		iny				iny 								; push MSB of offset on stack
.0db7	b1 28		lda ($28),y			lda 	(codePtr),y
.0db9	48		pha				pha
.0dba	88		dey				dey 								; point LSB of offset
.0dbb	18		clc				clc 								; add LSB
.0dbc	b1 28		lda ($28),y			lda 	(codePtr),y
.0dbe	65 28		adc $28				adc 	codePtr
.0dc0	85 28		sta $28				sta 	codePtr
.0dc2	68		pla				pla 								; restore offset MSB and add
.0dc3	65 29		adc $29				adc 	codePtr+1
.0dc5	85 29		sta $29				sta 	codePtr+1
.0dc7	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dca					CommandGotoZ:
.0dca	fa		plx				plx
.0dcb	20 5d 26	jsr $265d			jsr 	FloatIsZero
.0dce	ca		dex				dex
.0dcf	c9 00		cmp #$00			cmp 	#0
.0dd1	f0 e3		beq $0db6			beq 	PerformGOTO
.0dd3	c8		iny				iny
.0dd4	c8		iny				iny
.0dd5	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dd8					CommandGotoNZ:
.0dd8	fa		plx				plx
.0dd9	20 5d 26	jsr $265d			jsr 	FloatIsZero
.0ddc	ca		dex				dex
.0ddd	c9 00		cmp #$00			cmp 	#0
.0ddf	d0 d5		bne $0db6			bne 	PerformGOTO
.0de1	c8		iny				iny
.0de2	c8		iny				iny
.0de3	4c 4f 08	jmp $084f			jmp 	NextCommand
.0de6					Command_PSET:
.0de6	fa		plx				plx
.0de7	5a		phy				phy
.0de8	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; get the colour
.0deb	48		pha				pha
.0dec	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0dee	a0 02		ldy #$02			ldy 	#X16_r0
.0df0	20 72 0e	jsr $0e72			jsr 	GraphicsCopy2
.0df3	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0df6	68		pla				pla 								; set pixel.
.0df7	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0dfa	7a		ply				ply
.0dfb	a2 ff		ldx #$ff			ldx 	#$FF
.0dfd	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e00					Command_LINE:
.0e00	fa		plx				plx
.0e01	5a		phy				phy
.0e02	20 65 0e	jsr $0e65			jsr 	GraphicsColour
.0e05	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0e07	a0 02		ldy #$02			ldy 	#X16_r0
.0e09	20 6f 0e	jsr $0e6f			jsr 	GraphicsCopy4
.0e0c	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0e0f	7a		ply				ply
.0e10	a2 ff		ldx #$ff			ldx 	#$FF
.0e12	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e15					Command_RECT:
.0e15	fa		plx				plx
.0e16	5a		phy				phy
.0e17	20 86 0e	jsr $0e86			jsr 	GraphicsRectCoords
.0e1a	38		sec				sec
.0e1b	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e1e	7a		ply				ply
.0e1f	a2 ff		ldx #$ff			ldx 	#$FF
.0e21	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e24					Command_FRAME:
.0e24	fa		plx				plx
.0e25	5a		phy				phy
.0e26	20 86 0e	jsr $0e86			jsr 	GraphicsRectCoords
.0e29	18		clc				clc
.0e2a	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e2d	7a		ply				ply
.0e2e	a2 ff		ldx #$ff			ldx 	#$FF
.0e30	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e33					Command_CHAR:
.0e33	fa		plx				plx
.0e34	5a		phy				phy
.0e35	ca		dex				dex  								; set the draw colour
.0e36	20 65 0e	jsr $0e65			jsr 	GraphicsColour
.0e39	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e3b	a0 02		ldy #$02			ldy 	#X16_r0
.0e3d	20 72 0e	jsr $0e72			jsr 	GraphicsCopy2
.0e40	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e42	85 2c		sta $2c				sta 	zTemp0
.0e44	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e46	85 2d		sta $2d				sta 	zTemp0+1
.0e48	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e4a	85 2e		sta $2e				sta 	zTemp1
.0e4c					_CCLoop:
.0e4c	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e4e	f0 0f		beq $0e5f			beq 	_CCExit
.0e50	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e52	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e54	d0 02		bne $0e58			bne 	_CCNoCarry
.0e56	e6 2d		inc $2d				inc 	zTemp0+1
.0e58					_CCNoCarry:
.0e58	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e5a	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e5d	80 ed		bra $0e4c			bra 	_CCLoop						; go round.
.0e5f					_CCExit:
.0e5f	7a		ply				ply
.0e60	a2 ff		ldx #$ff			ldx 	#$FF
.0e62	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e65					GraphicsColour:
.0e65	20 2e 10	jsr $102e			jsr 	GetInteger8Bit
.0e68	aa		tax				tax
.0e69	a0 00		ldy #$00			ldy 	#0
.0e6b	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e6e	60		rts				rts
.0e6f					GraphicsCopy4:
.0e6f	20 72 0e	jsr $0e72			jsr 	GraphicsCopy2
.0e72					GraphicsCopy2:
.0e72	20 75 0e	jsr $0e75			jsr 	GraphicsCopy1
.0e75					GraphicsCopy1:
.0e75	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.0e78	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e7a	99 00 00	sta $0000,y			sta 	0,y
.0e7d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e7f	99 01 00	sta $0001,y			sta 	1,y
.0e82	e8		inx				inx
.0e83	c8		iny				iny
.0e84	c8		iny				iny
.0e85	60		rts				rts
.0e86					GraphicsRectCoords:
.0e86	20 65 0e	jsr $0e65			jsr 	GraphicsColour 				; set colour
.0e89	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e8b	a0 02		ldy #$02			ldy 	#X16_r0
.0e8d	20 6f 0e	jsr $0e6f			jsr 	GraphicsCopy4
.0e90	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0e92	20 9f 0e	jsr $0e9f			jsr 	_GRCSortSubtract
.0e95	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0e97	20 9f 0e	jsr $0e9f			jsr 	_GRCSortSubtract
.0e9a	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0e9c	74 09		stz $09,x			stz 	9,x
.0e9e	60		rts				rts
.0e9f					_GRCSortSubtract:
.0e9f	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0ea1	d5 00		cmp $00,x			cmp 	0,x
.0ea3	b5 05		lda $05,x			lda 	5,x
.0ea5	f5 01		sbc $01,x			sbc 	1,x
.0ea7	b0 08		bcs $0eb1			bcs 	_GRCNoSwap 					; >= swap.
.0ea9	20 bf 0e	jsr $0ebf			jsr 	_GRCSwapByte 				; swap 0/2
.0eac	e8		inx				inx
.0ead	20 bf 0e	jsr $0ebf			jsr 	_GRCSwapByte 				; swap 1/3
.0eb0	ca		dex				dex
.0eb1					_GRCNoSwap:
.0eb1	38		sec				sec 								; calculate width/height into 4,5
.0eb2	b5 04		lda $04,x			lda 	4,x
.0eb4	f5 00		sbc $00,x			sbc 	0,x
.0eb6	95 04		sta $04,x			sta 	4,x
.0eb8	b5 05		lda $05,x			lda 	5,x
.0eba	f5 01		sbc $01,x			sbc 	1,x
.0ebc	95 05		sta $05,x			sta 	5,x
.0ebe	60		rts				rts
.0ebf					_GRCSwapByte:
.0ebf	b5 04		lda $04,x			lda 	4,x
.0ec1	48		pha				pha
.0ec2	b5 00		lda $00,x			lda 	0,x
.0ec4	95 04		sta $04,x			sta 	4,x
.0ec6	68		pla				pla
.0ec7	95 00		sta $00,x			sta 	0,x
.0ec9	60		rts				rts
.0eca					Unary16Hex:
.0eca	fa		plx				plx
.0ecb	20 34 10	jsr $1034			jsr 	GetInteger16Bit
.0ece	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0ed0	20 fe 16	jsr $16fe			jsr 	StringAllocTemp
.0ed3	a5 2d		lda $2d				lda 	zTemp0+1
.0ed5	f0 03		beq $0eda			beq 	_UHNoHigh
.0ed7	20 e2 0e	jsr $0ee2			jsr 	_UHWriteHex
.0eda					_UHNoHigh:
.0eda	a5 2c		lda $2c				lda 	zTemp0
.0edc	20 e2 0e	jsr $0ee2			jsr 	_UHWriteHex
.0edf	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ee2					_UHWriteHex:
.0ee2	48		pha				pha
.0ee3	4a		lsr a				lsr 	a
.0ee4	4a		lsr a				lsr 	a
.0ee5	4a		lsr a				lsr 	a
.0ee6	4a		lsr a				lsr 	a
.0ee7	20 eb 0e	jsr $0eeb			jsr 	_UHWriteNibl
.0eea	68		pla				pla
.0eeb					_UHWriteNibl:
.0eeb	29 0f		and #$0f			and 	#15
.0eed	c9 0a		cmp #$0a			cmp 	#10
.0eef	90 02		bcc $0ef3			bcc 	_UHDigit
.0ef1	69 06		adc #$06			adc 	#6
.0ef3					_UHDigit:
.0ef3	69 30		adc #$30			adc 	#48
.0ef5	20 27 17	jsr $1727			jsr 	StringWriteChar
.0ef8	60		rts				rts
.0ef9					IndFloatRead:
.0ef9	fa		plx				plx
.0efa	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0efc	85 2c		sta $2c				sta 	zTemp0
.0efe	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f00	18		clc				clc
.0f01	6d 07 04	adc $0407			adc 	variableStartPage
.0f04	85 2d		sta $2d				sta 	zTemp0+1
.0f06	ca		dex				dex 								; throw the address
.0f07	20 dd 14	jsr $14dd			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0f0a	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f0d					IndInt16Read:
.0f0d	fa		plx				plx
.0f0e	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f10	85 2c		sta $2c				sta 	zTemp0
.0f12	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f14	18		clc				clc
.0f15	6d 07 04	adc $0407			adc 	variableStartPage
.0f18	85 2d		sta $2d				sta 	zTemp0+1
.0f1a	ca		dex				dex 								; throw the address
.0f1b	20 19 15	jsr $1519			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f1e	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f21					IndStringRead:
.0f21	fa		plx				plx
.0f22	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f24	85 2c		sta $2c				sta 	zTemp0
.0f26	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f28	18		clc				clc
.0f29	6d 07 04	adc $0407			adc 	variableStartPage
.0f2c	85 2d		sta $2d				sta 	zTemp0+1
.0f2e	ca		dex				dex 								; throw the address
.0f2f	20 5e 15	jsr $155e			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f32	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f35					IndFloatWrite:
.0f35	fa		plx				plx
.0f36	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f38	85 2c		sta $2c				sta 	zTemp0
.0f3a	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f3c	18		clc				clc
.0f3d	6d 07 04	adc $0407			adc 	variableStartPage
.0f40	85 2d		sta $2d				sta 	zTemp0+1
.0f42	20 b8 1a	jsr $1ab8			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f45	ca		dex				dex 								; throw the address as well.
.0f46	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f49					IndInt16Write:
.0f49	fa		plx				plx
.0f4a	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f4c	85 2c		sta $2c				sta 	zTemp0
.0f4e	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f50	18		clc				clc
.0f51	6d 07 04	adc $0407			adc 	variableStartPage
.0f54	85 2d		sta $2d				sta 	zTemp0+1
.0f56	20 f4 1a	jsr $1af4			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f59	ca		dex				dex 								; throw the address as well.
.0f5a	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f5d					IndStringWrite:
.0f5d	fa		plx				plx
.0f5e	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f60	85 2c		sta $2c				sta 	zTemp0
.0f62	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f64	18		clc				clc
.0f65	6d 07 04	adc $0407			adc 	variableStartPage
.0f68	85 2d		sta $2d				sta 	zTemp0+1
.0f6a	20 33 1b	jsr $1b33			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f6d	ca		dex				dex 								; throw the address as well.
.0f6e	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f71					CommandXInput:
.0f71	fa		plx				plx
.0f72	5a		phy				phy 								; save Y
.0f73	e8		inx				inx									; space on stack
.0f74					_INError:
.0f74	20 a8 0f	jsr $0fa8			jsr 	InputStringToBuffer 		; input from keyboard
.0f77	a9 60		lda #$60			lda 	#((ReadBufferSize) & $FF)
.0f79	85 2c		sta $2c				sta 	0+zTemp0
.0f7b	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f7d	85 2d		sta $2d				sta 	1+zTemp0
.0f7f	20 45 19	jsr $1945			jsr 	ValEvaluateZTemp0
.0f82	b0 f0		bcs $0f74			bcs 	_INError 					; failed, try again.
.0f84	7a		ply				ply 								; restore Y
.0f85	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f88					CommandInputString:
.0f88	fa		plx				plx
.0f89	5a		phy				phy 								; save Y
.0f8a	20 a8 0f	jsr $0fa8			jsr 	InputStringToBuffer 		; input from keyboard
.0f8d	e8		inx				inx 								; make space on stack
.0f8e	20 3b 26	jsr $263b			jsr 	FloatSetZero 				; store as string on stack
.0f91	a9 60		lda #$60			lda 	#ReadBufferSize & $FF
.0f93	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0f95	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0f97	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0f99	a9 40		lda #$40			lda 	#NSSString
.0f9b	95 32		sta $32,x			sta 	NSStatus,x
.0f9d	7a		ply				ply 								; restore Y
.0f9e	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fa1					CommandInputReset:
.0fa1	fa		plx				plx
.0fa2	9c 0b 04	stz $040b			stz 	InputBuffer
.0fa5	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fa8					InputStringToBuffer:
.0fa8	a9 e2		lda #$e2			lda 	#((InputBumpNext) & $FF)
.0faa	8d 60 05	sta $0560			sta 	0+ReadBumpNextVec
.0fad	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0faf	8d 61 05	sta $0561			sta 	1+ReadBumpNextVec
.0fb2	a9 bf		lda #$bf			lda 	#((InputLookNext) & $FF)
.0fb4	8d 62 05	sta $0562			sta 	0+ReadLookNextVec
.0fb7	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0fb9	8d 63 05	sta $0563			sta 	1+ReadLookNextVec
.0fbc	4c 3a 14	jmp $143a			jmp 	GetStringToBuffer
.0fbf					InputLookNext:
.0fbf	da		phx				phx
.0fc0					_ILNRetry:
.0fc0	ad 0b 04	lda $040b			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fc3	d0 08		bne $0fcd			bne 	_ILNNotEmpty
.0fc5	20 e6 0f	jsr $0fe6			jsr 	InputGetNewLine 			; get a new line
.0fc8	9c 5c 04	stz $045c			stz 	InputBufferPos 				; reset read position.
.0fcb	80 f3		bra $0fc0			bra 	_ILNRetry
.0fcd					_ILNNotEmpty:
.0fcd	ae 5c 04	ldx $045c			ldx 	InputBufferPos 				; get head available character
.0fd0	bd 0b 04	lda $040b,x			lda 	InputBuffer,x
.0fd3	d0 08		bne $0fdd			bne 	_ILNExit 					; if not EOS return it with CC.
.0fd5					_ILNNextLine:
.0fd5	9c 0b 04	stz $040b			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0fd8	38		sec				sec 								; return CS,Zero
.0fd9	fa		plx				plx
.0fda	a9 0d		lda #$0d			lda 	#13
.0fdc	60		rts				rts
.0fdd					_ILNExit:
.0fdd	fa		plx				plx
.0fde	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0fe0	18		clc				clc
.0fe1	60		rts				rts
.0fe2					InputBumpNext:
.0fe2	ee 5c 04	inc $045c			inc 	InputBufferPos
.0fe5	60		rts				rts
.0fe6					InputGetNewLine:
.0fe6	48		pha				pha
.0fe7	da		phx				phx
.0fe8	5a		phy				phy
.0fe9	a9 3f		lda #$3f			lda 	#"?"
.0feb	20 25 10	jsr $1025			jsr 	IGNLEchoIfScreen
.0fee	a0 00		ldy #$00			ldy 	#0 							; line position.
.0ff0					_IGNLLoop:
.0ff0	20 64 13	jsr $1364			jsr 	VectorGetCharacter 			; get a character
.0ff3	c9 00		cmp #$00			cmp 	#0
.0ff5	f0 f9		beq $0ff0			beq 	_IGNLLoop
.0ff7	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.0ff9	f0 11		beq $100c			beq 	_IGNBackspace
.0ffb	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.0ffd	f0 17		beq $1016			beq 	_IGNExit
.0fff	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.1001	f0 ed		beq $0ff0			beq 	_IGNLLoop
.1003	99 0b 04	sta $040b,y			sta 	InputBuffer,y
.1006	c8		iny				iny
.1007	20 25 10	jsr $1025			jsr 	IGNLEchoIfScreen
.100a	80 e4		bra $0ff0			bra 	_IGNLLoop
.100c					_IGNBackspace:
.100c	c0 00		cpy #$00			cpy 	#0
.100e	f0 e0		beq $0ff0			beq 	_IGNLLoop
.1010	20 25 10	jsr $1025			jsr 	IGNLEchoIfScreen
.1013	88		dey				dey
.1014	80 da		bra $0ff0			bra 	_IGNLLoop
.1016					_IGNExit:
.1016	20 25 10	jsr $1025			jsr 	IGNLEchoIfScreen
.1019	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.101b	99 0b 04	sta $040b,y			sta 	InputBuffer,y
.101e	9c 5c 04	stz $045c			stz 	InputBufferPos 				; reset position to start of input buffer.
.1021	7a		ply				ply
.1022	fa		plx				plx
.1023	68		pla				pla
.1024	60		rts				rts
.1025					IGNLEchoIfScreen:
.1025	ae 5e 04	ldx $045e			ldx 	currentChannel
.1028	d0 03		bne $102d			bne 	_IGNLEExit
.102a	20 5b 13	jsr $135b			jsr 	VectorPrintCharacter
.102d					_IGNLEExit:
.102d	60		rts				rts
.040b					InputBuffer:
>040b							.fill 	81
.045c					InputBufferPos:
>045c							.fill 	1
.102e					GetInteger8Bit:
.102e	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.1031	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1033	60		rts				rts
.1034					GetInteger16Bit:
.1034	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.1037	34 32		bit $32,x			bit 	NSStatus,x
.1039	30 09		bmi $1044			bmi 	Negate16Bit
.103b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.103d	85 2c		sta $2c				sta 	zTemp0
.103f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1041	85 2d		sta $2d				sta 	zTemp0+1
.1043	60		rts				rts
.1044					Negate16Bit:
.1044	38		sec				sec
.1045	a9 00		lda #$00			lda 	#0
.1047	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1049	95 3e		sta $3e,x			sta 	NSMantissa0,x
.104b	85 2c		sta $2c				sta 	zTemp0
.104d	a9 00		lda #$00			lda 	#0
.104f	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1051	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1053	85 2d		sta $2d				sta 	zTemp0+1
.1055	60		rts				rts
.1056					UnaryJoy:
.1056	fa		plx				plx
.1057	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; port #
.105a	48		pha				pha 								; zero the result.
.105b	20 3b 26	jsr $263b			jsr 	FloatSetZero
.105e	68		pla				pla
.105f	5a		phy				phy
.1060	da		phx				phx
.1061	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1064	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1066	d0 10		bne $1078			bne 	_UJNoHardware
.1068	a8		tay				tay 								; move XA -> AY
.1069	8a		txa				txa
.106a	fa		plx				plx 								; we can update it now.
.106b	49 ff		eor #$ff			eor 	#$FF
.106d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.106f	98		tya				tya
.1070	49 ff		eor #$ff			eor 	#$FF
.1072	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1074	7a		ply				ply 								; restore Y
.1075	4c 4f 08	jmp $084f			jmp 	NextCommand
.1078					_UJNoHardware:
.1078	fa		plx				plx
.1079	7a		ply				ply
.107a	a9 01		lda #$01			lda 	#1 							; set result to -1
.107c	20 3d 26	jsr $263d			jsr 	FloatSetByte
.107f	20 fd 25	jsr $25fd			jsr 	FloatNegate
.1082	4c 4f 08	jmp $084f			jmp 	NextCommand
.1085					UnaryLen:
.1085	fa		plx				plx
.1086	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.1088	85 2c		sta $2c				sta 	zTemp0
.108a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.108c	85 2d		sta $2d				sta 	zTemp0+1
.108e	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.1090	20 3d 26	jsr $263d			jsr 	FloatSetByte
.1093	4c 4f 08	jmp $084f			jmp 	NextCommand
.1096					LinkFloatAdd:
.1096	fa		plx				plx
.1097	5a		phy			phy
.1098	20 5f 20	jsr $205f		jsr	FloatAdd
.109b	7a		ply			ply
.109c	4c 4f 08	jmp $084f			jmp 	NextCommand
.109f					LinkFloatSubtract:
.109f	fa		plx				plx
.10a0	5a		phy			phy
.10a1	20 59 20	jsr $2059		jsr	FloatSubtract
.10a4	7a		ply			ply
.10a5	4c 4f 08	jmp $084f			jmp 	NextCommand
.10a8					LinkFloatMultiply:
.10a8	fa		plx				plx
.10a9	5a		phy			phy
.10aa	20 fb 22	jsr $22fb		jsr	FloatMultiply
.10ad	7a		ply			ply
.10ae	4c 4f 08	jmp $084f			jmp 	NextCommand
.10b1					LinkFloatDivide:
.10b1	fa		plx				plx
.10b2	5a		phy			phy
.10b3	20 84 21	jsr $2184		jsr	FloatDivide
.10b6	b0 5c		bcs $1114		bcs	DivZeroError
.10b8	7a		ply			ply
.10b9	4c 4f 08	jmp $084f			jmp 	NextCommand
.10bc					LinkFloatPower:
.10bc	fa		plx				plx
.10bd	5a		phy			phy
.10be	20 04 29	jsr $2904		jsr	FloatPower
.10c1	b0 4e		bcs $1111		bcs	MapRangeError
.10c3	7a		ply			ply
.10c4	4c 4f 08	jmp $084f			jmp 	NextCommand
.10c7					LinkCompareGreater:
.10c7	fa		plx				plx
.10c8	5a		phy			phy
.10c9	20 08 21	jsr $2108		jsr	CompareGreater
.10cc	7a		ply			ply
.10cd	4c 4f 08	jmp $084f			jmp 	NextCommand
.10d0					LinkCompareEqual:
.10d0	fa		plx				plx
.10d1	5a		phy			phy
.10d2	20 ea 20	jsr $20ea		jsr	CompareEqual
.10d5	7a		ply			ply
.10d6	4c 4f 08	jmp $084f			jmp 	NextCommand
.10d9					LinkCompareLess:
.10d9	fa		plx				plx
.10da	5a		phy			phy
.10db	20 00 21	jsr $2100		jsr	CompareLess
.10de	7a		ply			ply
.10df	4c 4f 08	jmp $084f			jmp 	NextCommand
.10e2					LinkCompareGreaterEqual:
.10e2	fa		plx				plx
.10e3	5a		phy			phy
.10e4	20 18 21	jsr $2118		jsr	CompareGreaterEqual
.10e7	7a		ply			ply
.10e8	4c 4f 08	jmp $084f			jmp 	NextCommand
.10eb					LinkCompareNotEqual:
.10eb	fa		plx				plx
.10ec	5a		phy			phy
.10ed	20 fa 20	jsr $20fa		jsr	CompareNotEqual
.10f0	7a		ply			ply
.10f1	4c 4f 08	jmp $084f			jmp 	NextCommand
.10f4					LinkCompareLessEqual:
.10f4	fa		plx				plx
.10f5	5a		phy			phy
.10f6	20 10 21	jsr $2110		jsr	CompareLessEqual
.10f9	7a		ply			ply
.10fa	4c 4f 08	jmp $084f			jmp 	NextCommand
.10fd					LinkFloatIntegerPartDown:
.10fd	fa		plx				plx
.10fe	5a		phy			phy
.10ff	20 9a 22	jsr $229a		jsr	FloatIntegerPartDown
.1102	7a		ply			ply
.1103	4c 4f 08	jmp $084f			jmp 	NextCommand
.1106					LinkFloatSquareRoot:
.1106	fa		plx				plx
.1107	5a		phy			phy
.1108	20 86 29	jsr $2986		jsr	FloatSquareRoot
.110b	b0 04		bcs $1111		bcs	MapRangeError
.110d	7a		ply			ply
.110e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1111					MapRangeError:
.1111	4c d8 1e	jmp $1ed8		jmp	ErrorV_range
.1114					DivZeroError:
.1114	4c 61 1f	jmp $1f61		jmp	ErrorV_divzero
.1117					LinkFloatLogarithm:
.1117	fa		plx				plx
.1118	5a		phy			phy
.1119	20 90 28	jsr $2890		jsr	FloatLogarithm
.111c	b0 f3		bcs $1111		bcs	MapRangeError
.111e	7a		ply			ply
.111f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1122					LinkFloatExponent:
.1122	fa		plx				plx
.1123	5a		phy			phy
.1124	20 8d 27	jsr $278d		jsr	FloatExponent
.1127	7a		ply			ply
.1128	4c 4f 08	jmp $084f			jmp 	NextCommand
.112b					LinkFloatCosine:
.112b	fa		plx				plx
.112c	5a		phy			phy
.112d	20 81 27	jsr $2781		jsr	FloatCosine
.1130	7a		ply			ply
.1131	4c 4f 08	jmp $084f			jmp 	NextCommand
.1134					LinkFloatSine:
.1134	fa		plx				plx
.1135	5a		phy			phy
.1136	20 21 29	jsr $2921		jsr	FloatSine
.1139	7a		ply			ply
.113a	4c 4f 08	jmp $084f			jmp 	NextCommand
.113d					LinkFloatTangent:
.113d	fa		plx				plx
.113e	5a		phy			phy
.113f	20 92 29	jsr $2992		jsr	FloatTangent
.1142	7a		ply			ply
.1143	4c 4f 08	jmp $084f			jmp 	NextCommand
.1146					LinkFloatArcTan:
.1146	fa		plx				plx
.1147	5a		phy			phy
.1148	20 66 26	jsr $2666		jsr	FloatArcTan
.114b	b0 c4		bcs $1111		bcs	MapRangeError
.114d	7a		ply			ply
.114e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1151					LinkFloatCompare:
.1151	fa		plx				plx
.1152	5a		phy			phy
.1153	20 20 21	jsr $2120		jsr	FloatCompare
.1156	7a		ply			ply
.1157	4c 4f 08	jmp $084f			jmp 	NextCommand
.115a					LinkDivideInt32:
.115a	fa		plx				plx
.115b	5a		phy			phy
.115c	20 ae 21	jsr $21ae		jsr	DivideInt32
.115f	b0 b0		bcs $1111		bcs	MapRangeError
.1161	7a		ply			ply
.1162	4c 4f 08	jmp $084f			jmp 	NextCommand
.1165					StackSaveCurrentPosition:
.1165	20 ba 08	jsr $08ba			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.1168	5a		phy				phy
.1169	a0 02		ldy #$02			ldy 	#2
.116b	a5 28		lda $28				lda 	codePtr
.116d	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.116f	c8		iny				iny
.1170	a5 29		lda $29				lda 	codePtr+1
.1172	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1174	7a		ply				ply
.1175	60		rts				rts
.1176					StackLoadCurrentPosition:
.1176	a0 02		ldy #$02			ldy 	#2
.1178	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.117a	85 28		sta $28				sta 	codePtr
.117c	c8		iny				iny
.117d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.117f	85 29		sta $29				sta 	codePtr+1
.1181	a0 00		ldy #$00			ldy 	#0
.1183	60		rts				rts
.1184					XCommandMouse:
.1184	fa		plx				plx
.1185	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; mouse control.
.1188	ca		dex				dex
.1189	da		phx				phx
.118a	5a		phy				phy
.118b	48		pha				pha
.118c	38		sec				sec 								; get screen resolution
.118d	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1190	68		pla				pla
.1191	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.1194	7a		ply				ply
.1195	fa		plx				plx
.1196	4c 4f 08	jmp $084f			jmp 	NextCommand
.1199					XUnaryMB:
.1199	fa		plx				plx
.119a	20 c8 11	jsr $11c8			jsr 	XUnaryMouseCommon
.119d	a5 30		lda $30				lda 	zTemp2
.119f	e8		inx				inx
.11a0	20 3d 26	jsr $263d			jsr 	FloatSetByte
.11a3	4c 4f 08	jmp $084f			jmp 	NextCommand
.11a6					XUnaryMX:
.11a6	fa		plx				plx
.11a7	20 c8 11	jsr $11c8			jsr 	XUnaryMouseCommon
.11aa	a5 2c		lda $2c				lda 	zTemp0
.11ac	e8		inx				inx
.11ad	20 3d 26	jsr $263d			jsr 	FloatSetByte
.11b0	a5 2d		lda $2d				lda 	zTemp0+1
.11b2	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11b4	4c 4f 08	jmp $084f			jmp 	NextCommand
.11b7					XUnaryMY:
.11b7	fa		plx				plx
.11b8	20 c8 11	jsr $11c8			jsr 	XUnaryMouseCommon
.11bb	a5 2e		lda $2e				lda 	zTemp1
.11bd	e8		inx				inx
.11be	20 3d 26	jsr $263d			jsr 	FloatSetByte
.11c1	a5 2f		lda $2f				lda 	zTemp1+1
.11c3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11c5	4c 4f 08	jmp $084f			jmp 	NextCommand
.11c8					XUnaryMouseCommon:
.11c8	da		phx				phx
.11c9	5a		phy				phy
.11ca	a2 2c		ldx #$2c			ldx 	#zTemp0
.11cc	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.11cf	85 30		sta $30				sta 	zTemp2
.11d1	7a		ply				ply
.11d2	fa		plx				plx
.11d3	60		rts				rts
.11d4					NegateTOS:
.11d4	fa		plx				plx
.11d5	20 fd 25	jsr $25fd			jsr 	FloatNegate
.11d8	4c 4f 08	jmp $084f			jmp 	NextCommand
.11db					CommandNewLine:
.11db	fa		plx				plx
.11dc	9c 69 05	stz $0569			stz 	stringInitialised
.11df	a2 ff		ldx #$ff			ldx 	#$FF
.11e1	4c 4f 08	jmp $084f			jmp 	NextCommand
.11e4					CommandXNext:
.11e4	fa		plx				plx
.11e5					_CNRetry:
.11e5	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.11e7	20 4a 0d	jsr $0d4a			jsr 	StackFindFrame
.11ea	20 ba 08	jsr $08ba			jsr 	FixUpY 						; so we can use Y
.11ed	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.11ef	35 4a		and $4a,x			and 	NSMantissa1,x
.11f1	c9 ff		cmp #$ff			cmp 	#$FF
.11f3	f0 16		beq $120b			beq 	_CNNoIndexVariable
.11f5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.11f7	a0 05		ldy #$05			ldy 	#5
.11f9	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.11fb	d0 07		bne $1204			bne 	_CNNIndexFail
.11fd	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.11ff	c8		iny				iny
.1200	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.1202	f0 07		beq $120b			beq 	_CNNoIndexVariable
.1204					_CNNIndexFail:
.1204	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.1206	20 3c 0d	jsr $0d3c			jsr 	StackCloseFrame 			; close this frame
.1209	80 da		bra $11e5			bra 	_CNRetry
.120b					_CNNoIndexVariable:
.120b	ca		dex				dex
.120c	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.120e	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1210	29 40		and #$40			and 	#$40	 					; bit 6
.1212	d0 55		bne $1269			bne 	_CNOptimisedNext
.1214	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1216	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1218	48		pha				pha
.1219	85 2c		sta $2c				sta 	zTemp0
.121b	c8		iny				iny
.121c	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.121e	18		clc				clc
.121f	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1222	48		pha				pha
.1223	85 2d		sta $2d				sta 	zTemp0+1
.1225	20 dd 14	jsr $14dd			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.1228	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.122a	e8		inx				inx
.122b	20 ac 12	jsr $12ac			jsr 	CopyOffsetYToTOS
.122e	20 5f 20	jsr $205f			jsr 	FloatAdd
.1231	68		pla				pla 								; restore address
.1232	85 2d		sta $2d				sta 	zTemp0+1
.1234	68		pla				pla
.1235	85 2c		sta $2c				sta 	zTemp0
.1237	20 b8 1a	jsr $1ab8			jsr 	WriteFloatZTemp0Sub			; write float.
.123a	e8		inx				inx  								; recover written
.123b	e8		inx				inx 								; load offset
.123c	a0 0d		ldy #$0d			ldy 	#13
.123e	20 ac 12	jsr $12ac			jsr 	CopyOffsetYToTOS
.1241	20 20 21	jsr $2120			jsr 	FloatCompare 				; and compare the floats.
.1244	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1245	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.1247	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1249	30 08		bmi $1253			bmi 	_CNDownStep
.124b	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.124d	c9 01		cmp #$01			cmp 	#1 							; gone higher
.124f	f0 10		beq $1261			beq 	_CNExitFor 					; if so exit the loop
.1251	80 06		bra $1259			bra 	_CNLoopBack
.1253					_CNDownStep:
.1253	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1255	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.1257	f0 08		beq $1261			beq 	_CNExitFor
.1259					_CNLoopBack:
.1259	20 76 11	jsr $1176			jsr 	StackLoadCurrentPosition 	; loop back
.125c	a0 00		ldy #$00			ldy 	#0
.125e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1261					_CNExitFor:
.1261	20 3c 0d	jsr $0d3c			jsr 	StackCloseFrame 			; remove the frame and exit
.1264	a0 00		ldy #$00			ldy 	#0
.1266	4c 4f 08	jmp $084f			jmp 	NextCommand
.1269					_CNOptimisedNext:
.1269	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.126b	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.126d	85 2c		sta $2c				sta 	zTemp0
.126f	c8		iny				iny
.1270	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1272	18		clc				clc
.1273	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1276	85 2d		sta $2d				sta 	zTemp0+1
.1278	a0 07		ldy #$07			ldy 	#7 							; STEP value
.127a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.127c	a0 ff		ldy #$ff			ldy 	#$FF
.127e	18		clc				clc
.127f					_CNOIncrement:
.127f	c8		iny				iny
.1280	71 2c		adc ($2c),y			adc 	(zTemp0),y
.1282	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1284	f0 f9		beq $127f			beq 	_CNOIncrement
.1286	18		clc				clc
.1287	a5 24		lda $24				lda 	runtimeStackPtr
.1289	69 0d		adc #$0d			adc 	#13
.128b	85 2e		sta $2e				sta 	zTemp1
.128d	a5 25		lda $25				lda 	runtimeStackPtr+1
.128f	69 00		adc #$00			adc 	#0
.1291	85 2f		sta $2f				sta 	zTemp1+1
.1293	a0 00		ldy #$00			ldy 	#0
.1295	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.1297	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.1299	c8		iny				iny
.129a	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.129c	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.129e	c8		iny				iny
.129f	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.12a1	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12a3	c8		iny				iny
.12a4	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.12a6	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12a8	90 b7		bcc $1261			bcc	 	_CNExitFor
.12aa	80 ad		bra $1259			bra 	_CNLoopBack
.12ac					CopyOffsetYToTOS:
.12ac	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12ae	95 3e		sta $3e,x			sta 	NSMantissa0,x
.12b0	c8		iny				iny
.12b1	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12b3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12b5	c8		iny				iny
.12b6	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12b8	95 56		sta $56,x			sta 	NSMantissa2,x
.12ba	c8		iny				iny
.12bb	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12bd	95 62		sta $62,x			sta 	NSMantissa3,x
.12bf	c8		iny				iny
.12c0	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c2	95 6e		sta $6e,x			sta 	NSExponent,x
.12c4	c8		iny				iny
.12c5	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c7	95 32		sta $32,x			sta 	NSStatus,x
.12c9	60		rts				rts
.12ca	4c 4f 08	jmp $084f			jmp 	NextCommand
.12cd					NotTOS:
.12cd	fa		plx				plx
.12ce	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.12d1	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.12d3	74 62		stz $62,x			stz 	NSMantissa3,x
.12d5	20 fd 25	jsr $25fd			jsr 	FloatNegate		 			; negate
.12d8	e8		inx				inx 								; and subtract 1.
.12d9	a9 01		lda #$01			lda 	#1
.12db	20 3d 26	jsr $263d			jsr 	FloatSetByte
.12de	20 59 20	jsr $2059			jsr 	FloatSubtract
.12e1					_NotTOSSkip:
.12e1	4c 4f 08	jmp $084f			jmp 	NextCommand
.12e4					CommandXOn:
.12e4	fa		plx				plx
.12e5	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.12e8	8d 5d 04	sta $045d			sta 	onCount 					; save it.
.12eb	20 ba 08	jsr $08ba			jsr 	FixUpY 						; Y = 0
.12ee					_CONFind:
.12ee	ce 5d 04	dec $045d			dec 	onCount 					; reached zero, do this one
.12f1	f0 0b		beq $12fe			beq 	_CONFound
.12f3	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.12f4	c8		iny				iny
.12f5	c8		iny				iny
.12f6	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.12f8	c8		iny				iny
.12f9	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.12fb	f0 f1		beq $12ee			beq 	_CONFind
.12fd	88		dey				dey 								; point to character after last GOTO/GOSUB
.12fe					_CONFound:
.12fe	4c 4f 08	jmp $084f			jmp 	NextCommand
.1301					CommandMoreOn:
.1301	fa		plx				plx
.1302	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1303	c8		iny				iny
.1304	c8		iny				iny
.1305	4c 4f 08	jmp $084f			jmp 	NextCommand
.045d					onCount:
>045d							.fill 	1
.1308					UnaryPeek:
.1308	fa		plx				plx
.1309	20 34 10	jsr $1034			jsr 	GetInteger16Bit
.130c	da		phx				phx
.130d	5a		phy				phy
.130e	a6 2c		ldx $2c				ldx 	zTemp0
.1310	a4 2d		ldy $2d				ldy 	zTemp0+1
.1312	20 49 1c	jsr $1c49			jsr 	XPeekMemory
.1315	7a		ply				ply
.1316	fa		plx				plx
.1317	20 3d 26	jsr $263d			jsr 	FloatSetByte
.131a	4c 4f 08	jmp $084f			jmp 	NextCommand
.131d					CommandPOKE:
.131d	fa		plx				plx
.131e	da		phx				phx 								; save XY
.131f	5a		phy				phy
.1320	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1323	48		pha				pha
.1324	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1326	a8		tay				tay
.1327	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1329	aa		tax				tax
.132a	68		pla				pla
.132b	20 35 1c	jsr $1c35			jsr 	XPokeMemory
.132e	7a		ply				ply 								; restore YX and drop 2
.132f	fa		plx				plx
.1330	ca		dex				dex
.1331	ca		dex				dex
.1332	4c 4f 08	jmp $084f			jmp 	NextCommand
.1335					UnaryPos:
.1335	fa		plx				plx
.1336	20 c8 1b	jsr $1bc8			jsr 	XGetHPos
.1339	20 3d 26	jsr $263d			jsr 	FloatSetByte
.133c	4c 4f 08	jmp $084f			jmp 	NextCommand
.133f					GetChannel:
.133f	fa		plx				plx
.1340	ad 5e 04	lda $045e			lda 	currentChannel
.1343	e8		inx				inx
.1344	20 3d 26	jsr $263d			jsr 	FloatSetByte
.1347	4c 4f 08	jmp $084f			jmp 	NextCommand
.134a					SetChannel:
.134a	fa		plx				plx
.134b	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.134e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1350	8d 5e 04	sta $045e			sta 	currentChannel
.1353	ca		dex				dex
.1354	4c 4f 08	jmp $084f			jmp 	NextCommand
.1357					SetDefaultChannel:
.1357	9c 5e 04	stz $045e			stz 	currentChannel
.135a	60		rts				rts
.135b					VectorPrintCharacter:
.135b	da		phx				phx
.135c	ae 5e 04	ldx $045e			ldx 	currentChannel
.135f	20 73 1c	jsr $1c73			jsr 	XPrintCharacterToChannel
.1362	fa		plx				plx
.1363	60		rts				rts
.1364					VectorGetCharacter:
.1364	da		phx				phx
.1365	ae 5e 04	ldx $045e			ldx 	currentChannel
.1368	20 ac 1b	jsr $1bac			jsr 	XGetCharacterFromChannel
.136b	fa		plx				plx
.136c	60		rts				rts
.045e					currentChannel:
>045e							.fill 	1
.136d					PrintNumber:
.136d	fa		plx				plx
.136e	a9 07		lda #$07			lda 	#7
.1370	20 23 25	jsr $2523			jsr 	FloatToString 				; to number in decimal buffer
.1373	ca		dex				dex 								; drop
.1374	da		phx				phx
.1375	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1377					_PNLoop:
.1377	bd 97 05	lda $0597,x			lda 	decimalBuffer,x
.137a	20 5b 13	jsr $135b			jsr 	VectorPrintCharacter
.137d	e8		inx				inx
.137e	bd 97 05	lda $0597,x			lda	 	decimalBuffer,x
.1381	d0 f4		bne $1377			bne 	_PNLoop
.1383	a9 20		lda #$20			lda 	#32 						; trailing space
.1385	20 5b 13	jsr $135b			jsr 	VectorPrintCharacter
.1388	fa		plx				plx
.1389	4c 4f 08	jmp $084f			jmp 	NextCommand
.138c					PrintString:
.138c	fa		plx				plx
.138d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.138f	85 2c		sta $2c				sta 	zTemp0
.1391	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1393	85 2d		sta $2d				sta 	zTemp0+1
.1395	ca		dex				dex 								; drop
.1396	da		phx				phx
.1397	5a		phy				phy
.1398	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.139a	aa		tax				tax
.139b	a0 01		ldy #$01			ldy 	#1 							; Y = position
.139d					_PSLoop:
.139d	e0 00		cpx #$00			cpx 	#0 							; complete ?
.139f	f0 09		beq $13aa			beq 	_PSExit
.13a1	ca		dex				dex 								; dec count
.13a2	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.13a4	20 5b 13	jsr $135b			jsr 	VectorPrintCharacter
.13a7	c8		iny				iny
.13a8	80 f3		bra $139d			bra 	_PSLoop
.13aa					_PSExit:
.13aa	7a		ply				ply
.13ab	fa		plx				plx
.13ac	4c 4f 08	jmp $084f			jmp 	NextCommand
.13af					CommandPushN:
.13af	fa		plx				plx
.13b0	e8		inx				inx 								; next slot on stack
.13b1	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.13b3	95 6e		sta $6e,x			sta 	NSExponent,x
.13b5	c8		iny				iny
.13b6	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.13b8	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13ba	c8		iny				iny
.13bb	b1 28		lda ($28),y			lda 	(codePtr),y
.13bd	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13bf	c8		iny				iny
.13c0	b1 28		lda ($28),y			lda 	(codePtr),y
.13c2	95 56		sta $56,x			sta 	NSMantissa2,x
.13c4	c8		iny				iny
.13c5	b1 28		lda ($28),y			lda 	(codePtr),y
.13c7	48		pha				pha
.13c8	29 7f		and #$7f			and 	#$7F
.13ca	95 62		sta $62,x			sta 	NSMantissa3,x
.13cc	68		pla				pla 								; sign in mantissa3:7
.13cd	29 80		and #$80			and 	#$80
.13cf	95 32		sta $32,x			sta 	NSStatus,x
.13d1	c8		iny				iny
.13d2	4c 4f 08	jmp $084f			jmp 	NextCommand
.13d5					CommandPushS:
.13d5	fa		plx				plx
.13d6	e8		inx				inx 								; next slot on stack
.13d7	18		clc				clc
.13d8	98		tya				tya
.13d9	65 28		adc $28				adc 	codePtr 					; the string is inline
.13db	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13dd	a5 29		lda $29				lda 	codePtr+1
.13df	69 00		adc #$00			adc 	#0
.13e1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13e3	74 56		stz $56,x			stz 	NSMantissa2,x
.13e5	74 62		stz $62,x			stz 	NSMantissa3,x
.13e7	a9 40		lda #$40			lda 	#NSSString
.13e9	95 32		sta $32,x			sta 	NSStatus,x
.13eb	98		tya				tya 								; string length +1 added to Y
.13ec	38		sec				sec
.13ed	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.13ef	a8		tay				tay
.13f0	4c 4f 08	jmp $084f			jmp 	NextCommand
.13f3					CommandXRead:
.13f3	fa		plx				plx
.13f4	5a		phy				phy 								; save Y
.13f5	20 26 14	jsr $1426			jsr 	ReadStringToBuffer 			; read element into buffer
.13f8	e8		inx				inx									; space on stack
.13f9	a9 60		lda #$60			lda 	#((ReadBufferSize) & $FF)
.13fb	85 2c		sta $2c				sta 	0+zTemp0
.13fd	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.13ff	85 2d		sta $2d				sta 	1+zTemp0
.1401	20 45 19	jsr $1945			jsr 	ValEvaluateZTemp0
.1404	b0 04		bcs $140a			bcs 	_CRError 					; failed
.1406	7a		ply				ply 								; restore Y
.1407	4c 4f 08	jmp $084f			jmp 	NextCommand
.140a					_CRError:
.140a	4c e8 1e	jmp $1ee8		jmp	ErrorV_value
.140d					CommandReadString:
.140d	fa		plx				plx
.140e	5a		phy				phy 								; save Y
.140f	20 26 14	jsr $1426			jsr 	ReadStringToBuffer 			; read text
.1412	e8		inx				inx 								; make space on stack
.1413	20 3b 26	jsr $263b			jsr 	FloatSetZero 				; store as string on stack
.1416	a9 60		lda #$60			lda 	#ReadBufferSize & $FF
.1418	95 3e		sta $3e,x			sta 	NSMantissa0,x
.141a	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.141c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.141e	a9 40		lda #$40			lda 	#NSSString
.1420	95 32		sta $32,x			sta 	NSStatus,x
.1422	7a		ply				ply 								; restore Y
.1423	4c 4f 08	jmp $084f			jmp 	NextCommand
.1426					ReadStringToBuffer:
.1426	a9 b9		lda #$b9			lda 	#((ReadBumpNext) & $FF)
.1428	8d 60 05	sta $0560			sta 	0+ReadBumpNextVec
.142b	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.142d	8d 61 05	sta $0561			sta 	1+ReadBumpNextVec
.1430	a9 8c		lda #$8c			lda 	#((ReadLookNext) & $FF)
.1432	8d 62 05	sta $0562			sta 	0+ReadLookNextVec
.1435	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.1437	8d 63 05	sta $0563			sta 	1+ReadLookNextVec
.143a					GetStringToBuffer:
.143a	20 89 14	jsr $1489			jsr		GetLookNext 				; skip all leading spaces.
.143d	f0 44		beq $1483			beq 	_RBError 					; end of data
.143f	b0 f9		bcs $143a			bcs 	GetStringToBuffer 			; switched to new data line.
.1441	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1443	b0 05		bcs $144a			bcs 	_RBNoSpace
.1445	20 86 14	jsr $1486			jsr 	GetBumpNext 				; consume space and loop round.
.1448	80 f0		bra $143a			bra 	GetStringToBuffer
.144a					_RBNoSpace:
.144a	9c 60 04	stz $0460			stz 	ReadBufferSize 				; empty the buffer.
.144d	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.144f	d0 08		bne $1459			bne 	_RBCommaSep
.1451	8d 5f 04	sta $045f			sta 	ReadSep 					; use as a seperator
.1454	20 86 14	jsr $1486			jsr 	GetBumpNext 				; consume the '"'
.1457	80 05		bra $145e			bra 	_RBGetText
.1459					_RBCommaSep:
.1459	a9 2c		lda #$2c			lda 	#","						; get till comma
.145b	8d 5f 04	sta $045f			sta 	ReadSep
.145e					_RBGetText:
.145e	20 89 14	jsr $1489			jsr 	GetLookNext 				; what follows
.1461	b0 18		bcs $147b			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.1463	20 86 14	jsr $1486			jsr 	GetBumpNext 				; consume it whatever
.1466	cd 5f 04	cmp $045f			cmp 	ReadSep 					; if found the seperator.
.1469	f0 10		beq $147b			beq 	_RBEndGet 					; exit after consumption
.146b	da		phx				phx
.146c	ae 60 04	ldx $0460			ldx 	ReadBufferSize 				; copy into buffer.
.146f	ee 60 04	inc $0460			inc 	ReadBufferSize
.1472	9d 61 04	sta $0461,x			sta 	ReadBuffer,x
.1475	9e 62 04	stz $0462,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.1478	fa		plx				plx
.1479	80 e3		bra $145e			bra 	_RBGetText
.147b					_RBEndGet:
.147b	c9 22		cmp #$22			cmp 	#'"'
.147d	d0 03		bne $1482			bne 	_RBNotQuote
.147f	20 86 14	jsr $1486			jsr 	GetBumpNext
.1482					_RBNotQuote:
.1482	60		rts				rts
.1483					_RBError:
.1483	4c 9d 1f	jmp $1f9d		jmp	ErrorV_data
.1486					GetBumpNext:
.1486	6c 60 05	jmp ($0560)			jmp 	(ReadBumpNextVec)
.1489					GetLookNext:
.1489	6c 62 05	jmp ($0562)			jmp 	(ReadLookNextVec)
.148c					ReadLookNext:
.148c	ad 64 05	lda $0564			lda 	dataRemaining 				; any data remaining
.148f	f0 04		beq $1495			beq 	_RLNFindData
.1491	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.1493	18		clc				clc
.1494	60		rts				rts
.1495					_RLNFindData:
.1495	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.1497	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.1499	f0 1a		beq $14b5			beq 	_RLNNoData
.149b	c9 cf		cmp #$cf			cmp 	#PCD_CMD_DATA 				; Found DATA
.149d	f0 05		beq $14a4			beq 	_RLNHaveData
.149f					_RLNNext:
.149f	20 0a 20	jsr $200a			jsr 	MoveObjectForward			; else scan forward.
.14a2	80 f1		bra $1495			bra 	_RLNFindData
.14a4					_RLNHaveData:
.14a4	a0 01		ldy #$01			ldy 	#1 							; get length
.14a6	b1 2a		lda ($2a),y			lda 	(objPtr),y
.14a8	f0 f5		beq $149f			beq 	_RLNNext 					; skip if DATA alone
.14aa	20 b9 14	jsr $14b9			jsr 	ReadBumpNext 				; advance by two
.14ad	20 b9 14	jsr $14b9			jsr 	ReadBumpNext
.14b0	8d 64 05	sta $0564			sta 	dataRemaining 				; set data left count.
.14b3	38		sec				sec
.14b4	60		rts				rts
.14b5					_RLNNoData:
.14b5	a9 00		lda #$00			lda 	#0
.14b7	38		sec				sec
.14b8	60		rts				rts
.14b9					ReadBumpNext:
.14b9	e6 2a		inc $2a				inc 	objPtr
.14bb	d0 02		bne $14bf			bne 	_RBNSkip
.14bd	e6 2b		inc $2b				inc 	objPtr+1
.14bf					_RBNSkip:
.14bf	ce 64 05	dec $0564			dec 	dataRemaining
.14c2	60		rts				rts
.045f					ReadSep:
>045f							.fill 	1
.0460					ReadBufferSize:
>0460							.fill 	1
.0461					ReadBuffer:
>0461							.fill 	255
.0560					ReadBumpNextVec:
>0560							.fill 	2
.0562					ReadLookNextVec:
>0562							.fill 	2
.14c3					ReadFloatCommand:
.14c3	fa		plx				plx
.14c4	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14c6	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14c8	88		dey				dey 								; get the upper 3 bits
.14c9	b1 28		lda ($28),y			lda 	(codePtr),y
.14cb	29 07		and #$07			and 	#7
.14cd	c8		iny				iny
.14ce	c8		iny				iny
.14cf	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14d1	2a		rol a				rol 	a 							; carry will be clear.
.14d2	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14d5	85 2d		sta $2d				sta 	zTemp0+1
.14d7	20 dd 14	jsr $14dd			jsr 	ReadFloatZTemp0Sub
.14da	4c 4f 08	jmp $084f			jmp 	NextCommand
.14dd					ReadFloatZTemp0Sub:
.14dd	5a		phy				phy 								; start write
.14de	a0 01		ldy #$01			ldy 	#1
.14e0	e8		inx				inx
.14e1	b2 2c		lda ($2c)			lda 	(zTemp0)
.14e3	95 3e		sta $3e,x			sta 	NSMantissa0,x
.14e5	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14e7	95 4a		sta $4a,x			sta 	NSMantissa1,x
.14e9	c8		iny				iny
.14ea	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14ec	95 56		sta $56,x			sta 	NSMantissa2,x
.14ee	c8		iny				iny
.14ef	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14f1	95 62		sta $62,x			sta 	NSMantissa3,x
.14f3	c8		iny				iny
.14f4	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14f6	95 6e		sta $6e,x			sta 	NSExponent,x
.14f8	c8		iny				iny
.14f9	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14fb	95 32		sta $32,x			sta 	NSStatus,x
.14fd	7a		ply				ply
.14fe	60		rts				rts
.14ff					ReadIntegerCommand:
.14ff	fa		plx				plx
.1500	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1502	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1504	88		dey				dey 								; get the upper 3 bits
.1505	b1 28		lda ($28),y			lda 	(codePtr),y
.1507	29 07		and #$07			and 	#7
.1509	c8		iny				iny
.150a	c8		iny				iny
.150b	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.150d	2a		rol a				rol 	a 							; carry will be clear.
.150e	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1511	85 2d		sta $2d				sta 	zTemp0+1
.1513	20 19 15	jsr $1519			jsr 	ReadIntegerZTemp0Sub
.1516	4c 4f 08	jmp $084f			jmp 	NextCommand
.1519					ReadIntegerZTemp0Sub:
.1519	5a		phy				phy 								; start write
.151a	a0 01		ldy #$01			ldy 	#1
.151c	e8		inx				inx 								; prepare
.151d	74 56		stz $56,x			stz 	NSMantissa2,x
.151f	74 62		stz $62,x			stz 	NSMantissa3,x
.1521	74 6e		stz $6e,x			stz 	NSExponent,x
.1523	74 32		stz $32,x			stz 	NSStatus,x
.1525	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1527	30 08		bmi $1531			bmi 	_RIZNegative
.1529	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.152b	b2 2c		lda ($2c)			lda 	(zTemp0)
.152d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.152f	7a		ply				ply
.1530	60		rts				rts
.1531					_RIZNegative:
.1531	38		sec				sec 								; -ve read
.1532	a9 00		lda #$00			lda 	#0
.1534	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.1536	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1538	a9 00		lda #$00			lda 	#0
.153a	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.153c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.153e	a9 80		lda #$80			lda 	#$80
.1540	95 32		sta $32,x			sta 	NSStatus,x
.1542	7a		ply				ply
.1543	60		rts				rts
.1544					ReadStringCommand:
.1544	fa		plx				plx
.1545	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1547	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1549	88		dey				dey 								; get the upper 3 bits
.154a	b1 28		lda ($28),y			lda 	(codePtr),y
.154c	29 07		and #$07			and 	#7
.154e	c8		iny				iny
.154f	c8		iny				iny
.1550	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1552	2a		rol a				rol 	a 							; carry will be clear.
.1553	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1556	85 2d		sta $2d				sta 	zTemp0+1
.1558	20 5e 15	jsr $155e			jsr 	ReadStringZTemp0Sub
.155b	4c 4f 08	jmp $084f			jmp 	NextCommand
.155e					ReadStringZTemp0Sub:
.155e	5a		phy				phy 								; start write
.155f	e8		inx				inx 								; prepare
.1560	74 56		stz $56,x			stz 	NSMantissa2,x
.1562	74 62		stz $62,x			stz 	NSMantissa3,x
.1564	74 6e		stz $6e,x			stz 	NSExponent,x
.1566	a9 40		lda #$40			lda 	#NSSString
.1568	74 32		stz $32,x			stz 	NSStatus,x
.156a	18		clc				clc
.156b	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.156d	69 02		adc #$02			adc 	#2 							; this points to actual data
.156f	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.1571	a0 01		ldy #$01			ldy 	#1
.1573	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1575	69 00		adc #$00			adc 	#0
.1577	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1579	d0 08		bne $1583			bne 	_RSZNoDefault 				; if read $00 use a default value.
.157b	a9 85		lda #$85			lda 	#_RSZNull & $FF
.157d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.157f	a9 15		lda #$15			lda 	#_RSZNull >> 8
.1581	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1583					_RSZNoDefault:
.1583	7a		ply				ply
.1584	60		rts				rts
.1585					_RSZNull:
>1585	00						.byte 	0
.1586					CommandRestore:
.1586	fa		plx				plx
.1587	20 8d 15	jsr $158d			jsr 	RestoreCode
.158a	4c 4f 08	jmp $084f			jmp 	NextCommand
.158d					RestoreCode:
.158d	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.1590	85 2b		sta $2b				sta 	objPtr+1
.1592	64 2a		stz $2a				stz 	objPtr
.1594	9c 64 05	stz $0564			stz 	dataRemaining 				; no data remaining.
.1597	60		rts				rts
.0564					dataRemaining:
>0564							.fill 	1		 					; 0 if not in data statement
.1598					UnaryRND:
.1598	fa		plx				plx
.1599	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.159b	10 17		bpl $15b4			bpl 	_URNoSeed
.159d	20 90 23	jsr $2390			jsr 	FloatNormalise 				; some float value
.15a0	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.15a2	8d 65 05	sta $0565			sta 	randomSeed+0
.15a5	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15a7	8d 66 05	sta $0566			sta 	randomSeed+1
.15aa	b5 56		lda $56,x			lda 	NSMantissa2,x
.15ac	8d 67 05	sta $0567			sta 	randomSeed+2
.15af	b5 62		lda $62,x			lda 	NSMantissa3,x
.15b1	8d 68 05	sta $0568			sta 	randomSeed+3
.15b4					_URNoSeed:
.15b4	20 d6 15	jsr $15d6			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.15b7	ad 65 05	lda $0565			lda 	randomSeed+0
.15ba	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15bc	ad 66 05	lda $0566			lda 	randomSeed+1
.15bf	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15c1	ad 67 05	lda $0567			lda 	randomSeed+2
.15c4	95 56		sta $56,x			sta 	NSMantissa2,x
.15c6	ad 68 05	lda $0568			lda 	randomSeed+3
.15c9	29 7f		and #$7f			and 	#$7F
.15cb	95 62		sta $62,x			sta 	NSMantissa3,x
.15cd	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.15cf	95 6e		sta $6e,x			sta 	NSExponent,x
.15d1	74 32		stz $32,x			stz 	NSStatus,x
.15d3	4c 4f 08	jmp $084f			jmp 	NextCommand
.15d6					RandomNumberGenerator:
.15d6	5a		phy				phy
.15d7	ad 65 05	lda $0565			lda 	randomSeed+0 				; check if zero
.15da	0d 66 05	ora $0566			ora 	randomSeed+1
.15dd	0d 67 05	ora $0567			ora 	randomSeed+2
.15e0	0d 68 05	ora $0568			ora 	randomSeed+3
.15e3	d0 07		bne $15ec			bne 	_RNGNoSeed
.15e5	ce 68 05	dec $0568			dec 	randomSeed+3 				; if so tweak and flog
.15e8	a0 64		ldy #$64			ldy 	#100
.15ea	80 05		bra $15f1			bra 	_RNGLoop
.15ec					_RNGNoSeed:
.15ec	a0 08		ldy #$08			ldy 	#8
.15ee	ad 65 05	lda $0565			lda 	randomSeed+0
.15f1					_RNGLoop:
.15f1	0a		asl a				asl		a
.15f2	2e 66 05	rol $0566			rol 	randomSeed+1
.15f5	2e 67 05	rol $0567			rol 	randomSeed+2
.15f8	2e 68 05	rol $0568			rol 	randomSeed+3
.15fb	90 02		bcc $15ff			bcc		_RNGSkip
.15fd	49 c5		eor #$c5			eor 	#$C5
.15ff					_RNGSkip:
.15ff	88		dey				dey
.1600	d0 ef		bne $15f1			bne		_RNGLoop
.1602	8d 65 05	sta $0565			sta 	randomSeed+0
.1605	7a		ply				ply
.1606	60		rts				rts
.0565					randomSeed:
>0565							.fill 	4
.1607					StringConcatenate:
.1607	fa		plx				plx
.1608	ca		dex				dex
.1609	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.160b	85 2e		sta $2e				sta 	zTemp1
.160d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.160f	85 2f		sta $2f				sta 	zTemp1+1
.1611	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.1613	85 30		sta $30				sta 	zTemp2
.1615	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.1617	85 31		sta $31				sta 	zTemp2+1
.1619	18		clc				clc 								; work out total length
.161a	b2 2e		lda ($2e)			lda 	(zTemp1)
.161c	72 30		adc ($30)			adc 	(zTemp2)
.161e	b0 18		bcs $1638			bcs 	_BCLength 					; more than 255 characters.
.1620	48		pha				pha 								; save total
.1621	20 fe 16	jsr $16fe			jsr 	StringAllocTemp 			; space for result.
.1624	68		pla				pla 								; write total as first.
.1625	92 22		sta ($22)			sta 	(zsTemp)
.1627	20 3b 16	jsr $163b			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.162a	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.162c	85 2e		sta $2e				sta 	zTemp1
.162e	a5 31		lda $31				lda 	zTemp2+1
.1630	85 2f		sta $2f				sta 	zTemp1+1
.1632	20 3b 16	jsr $163b			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1635	4c 4f 08	jmp $084f			jmp 	NextCommand
.1638					_BCLength:
.1638	4c d8 1e	jmp $1ed8		jmp	ErrorV_range
.163b					_BCCopyZTemp1:
.163b	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.163d	f0 15		beq $1654			beq 	_BCCExit 					; none.
.163f	da		phx				phx 								; save XY
.1640	5a		phy				phy
.1641	aa		tax				tax 								; count in X.
.1642	a0 01		ldy #$01			ldy 	#1
.1644					_BCCLoop:
.1644	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1646	d0 02		bne $164a			bne 	_BCCNoCarry
.1648	e6 23		inc $23				inc 	zsTemp+1
.164a					_BCCNoCarry:
.164a	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.164c	92 22		sta ($22)			sta 	(zsTemp)
.164e	c8		iny				iny
.164f	ca		dex				dex 								; X times
.1650	d0 f2		bne $1644			bne 	_BCCLoop
.1652	7a		ply				ply 								; restore YX
.1653	fa		plx				plx
.1654					_BCCExit:
.1654	60		rts				rts
.1655					XRuntimeSetup:
.1655	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1657	8d 6c 05	sta $056c	 		sta 	ramBank
.165a	8d 6d 05	sta $056d	 		sta 	romBank
.165d	60		rts				rts
.165e					SignTOS:
.165e	fa		plx				plx
.165f	20 5d 26	jsr $265d			jsr 	FloatIsZero 				; if zero
.1662	f0 0f		beq $1673			beq 	_SGZero  					; return Int Zero
.1664	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.1666	48		pha				pha
.1667	a9 01		lda #$01			lda 	#1 							; set result to 1
.1669	20 3d 26	jsr $263d			jsr 	FloatSetByte
.166c	68		pla				pla
.166d	29 80		and #$80			and		#$80 						; copy the sign byte out
.166f	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.1671	80 03		bra $1676			bra 	_SGExit
.1673					_SGZero:
.1673	20 3b 26	jsr $263b			jsr 	FloatSetZero
.1676					_SGExit:
.1676	4c 4f 08	jmp $084f			jmp 	NextCommand
.1679					CommandShift:
.1679	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.167b	c8		iny				iny
.167c	0a		asl a				asl 	a 							; double into X
.167d	aa		tax				tax
.167e	7c 29 1a	jmp ($1a29,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.1681					PrintTab:
.1681	fa		plx				plx
.1682	20 c8 1b	jsr $1bc8			jsr 	XGetHPos
.1685					_PTMod10:
.1685	38		sec				sec
.1686	e9 0a		sbc #$0a			sbc 	#10
.1688	b0 fb		bcs $1685			bcs 	_PTMod10
.168a	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.168c	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.168d	80 15		bra $16a4			bra 	PrintSpaceLoop
.168f					PrintPos:
.168f	fa		plx				plx
.1690	20 c8 1b	jsr $1bc8			jsr		XGetHPos 					; get current position
.1693	85 2c		sta $2c				sta 	zTemp0
.1695	38		sec				sec 								; calculate spaces required
.1696	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1698	ca		dex				dex
.1699	e5 2c		sbc $2c				sbc 	zTemp0
.169b	b0 07		bcs $16a4			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.169d	4c 4f 08	jmp $084f			jmp 	NextCommand
.16a0					PrintSpace:
.16a0	fa		plx				plx
.16a1	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16a3	ca		dex				dex
.16a4					PrintSpaceLoop:
.16a4	c9 00		cmp #$00			cmp 	#0
.16a6	f0 0a		beq $16b2			beq 	_PSExit
.16a8	48		pha				pha
.16a9	a9 20		lda #$20			lda 	#" "
.16ab	20 5b 13	jsr $135b			jsr 	VectorPrintCharacter
.16ae	68		pla				pla
.16af	3a		dec a				dec 	a
.16b0	80 f2		bra $16a4			bra 	PrintSpaceLoop
.16b2					_PSExit:
.16b2	4c 4f 08	jmp $084f			jmp 	NextCommand
.16b5					CommandStop:
.16b5	fa		plx				plx
.16b6	4c 8a 1f	jmp $1f8a		jmp	ErrorV_stop
.16b9					Unary_Str:
.16b9	fa		plx				plx
.16ba	5a		phy				phy
.16bb	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.16bd	20 23 25	jsr $2523			jsr 	FloatToString 				; do the conversion.
.16c0	a9 21		lda #$21			lda		#33 						; create buffer
.16c2	20 fe 16	jsr $16fe			jsr 	StringAllocTemp 			; allocate memory
.16c5	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.16c7					_USCopy:
.16c7	b9 96 05	lda $0596,y			lda 	decimalBuffer-1,y
.16ca	f0 05		beq $16d1			beq 	_USExit
.16cc	91 22		sta ($22),y			sta 	(zsTemp),y
.16ce	c8		iny				iny
.16cf	80 f6		bra $16c7			bra 	_USCopy
.16d1					_USExit:
.16d1	98		tya				tya
.16d2	3a		dec a				dec 	a
.16d3	92 22		sta ($22)			sta 	(zsTemp)
.16d5	7a		ply				ply
.16d6	4c 4f 08	jmp $084f			jmp 	NextCommand
.16d9					StringInitialise:
.16d9	48		pha				pha
.16da	ad 69 05	lda $0569			lda 	stringInitialised 			; already done
.16dd	d0 11		bne $16f0			bne 	_SIExit
.16df	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.16e2	8d 6a 05	sta $056a			sta 	stringTempPointer
.16e5	ad 03 04	lda $0403			lda 	stringHighMemory+1
.16e8	3a		dec a				dec 	a
.16e9	3a		dec a				dec 	a
.16ea	8d 6b 05	sta $056b			sta 	stringTempPointer+1
.16ed	ce 69 05	dec $0569			dec 	stringInitialised 			; set the initialised flag.
.16f0					_SIExit:
.16f0	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.16f2	1a		inc a				inc 	a
.16f3	1a		inc a				inc 	a
.16f4	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.16f7	b0 02		bcs $16fb			bcs 	_SIMemory
.16f9	68		pla				pla
.16fa	60		rts				rts
.16fb					_SIMemory:
.16fb	4c e3 1f	jmp $1fe3		jmp	ErrorV_memory
.16fe					StringAllocTemp:
.16fe	20 d9 16	jsr $16d9			jsr 	StringInitialise 			; check it is initialised.
.1701	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.1703	18		clc				clc
.1704	6d 6a 05	adc $056a			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.1707	8d 6a 05	sta $056a			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.170a	85 22		sta $22				sta 	zsTemp
.170c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.170e	ad 6b 05	lda $056b			lda 	stringTempPointer+1
.1711	69 ff		adc #$ff			adc 	#$FF
.1713	8d 6b 05	sta $056b			sta 	stringTempPointer+1
.1716	85 23		sta $23				sta 	zsTemp+1
.1718	95 4a		sta $4a,x			sta 	NSMantissa1,x
.171a	74 56		stz $56,x			stz 	NSMantissa2,x
.171c	74 62		stz $62,x			stz 	NSMantissa3,x
.171e	a9 00		lda #$00			lda 	#0 							; clear string.
.1720	92 22		sta ($22)			sta 	(zsTemp)
.1722	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1724	95 32		sta $32,x			sta 	NSStatus,x
.1726	60		rts				rts
.1727					StringWriteChar:
.1727	5a		phy				phy
.1728	48		pha				pha
.1729	b2 22		lda ($22)			lda 	(zsTemp)
.172b	1a		inc a				inc 	a
.172c	92 22		sta ($22)			sta 	(zsTemp)
.172e	a8		tay				tay
.172f	68		pla				pla
.1730	91 22		sta ($22),y			sta 	(zsTemp),y
.1732	7a		ply				ply
.1733	60		rts				rts
.0569					stringInitialised:
>0569							.fill 	1
.056a					stringTempPointer:
>056a							.fill 	2
.1734					Unary_Left:
.1734	fa		plx				plx
.1735	5a		phy				phy
.1736	18		clc				clc 								; only one parameter
.1737	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; push the length of the string.
.173a	48		pha				pha
.173b	ca		dex				dex
.173c	a9 00		lda #$00			lda 	#0 							; push the start position.
.173e	48		pha				pha
.173f	20 77 17	jsr $1777			jsr 	UnarySStringToZTemp0
.1742	80 3c		bra $1780			bra 	SubstringMain 				; stack now points to the string to slice.
.1744					Unary_Right:
.1744	fa		plx				plx
.1745	5a		phy				phy
.1746	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.1748	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; push the right length of the string.
.174b	48		pha				pha
.174c	ca		dex				dex
.174d	20 77 17	jsr $1777			jsr 	UnarySStringToZTemp0
.1750	68		pla				pla 								; this is the right requirement
.1751	38		sec				sec
.1752	49 ff		eor #$ff			eor 	#$FF
.1754	72 2c		adc ($2c)			adc 	(zTemp0)
.1756	b0 02		bcs $175a			bcs 	_URHaveCount
.1758	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.175a					_URHaveCount:
.175a	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.175c	5a		phy				phy
.175d	48		pha				pha 								; start position
.175e	80 20		bra $1780			bra 	SubstringMain
.1760					Unary_Mid:
.1760	fa		plx				plx
.1761	5a		phy				phy
.1762	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; push the length of the string required.
.1765	48		pha				pha
.1766	ca		dex				dex
.1767	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; put the start position.
.176a	f0 08		beq $1774			beq 	_UMError
.176c	3a		dec a				dec 	a
.176d	48		pha				pha
.176e	ca		dex				dex
.176f	20 77 17	jsr $1777			jsr 	UnarySStringToZTemp0
.1772	80 0c		bra $1780			bra 	SubstringMain 				; stack now points to the string to slice.
.1774					_UMError:
.1774	4c d8 1e	jmp $1ed8		jmp	ErrorV_range
.1777					UnarySStringToZTemp0:
.1777	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1779	85 2c		sta $2c				sta 	zTemp0
.177b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.177d	85 2d		sta $2d				sta 	zTemp0+1
.177f	60		rts				rts
.1780					SubstringMain:
.1780	68		pla				pla 								; get the start offset
.1781	7a		ply				ply 								; get the count to do.
.1782	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.1784	b0 38		bcs $17be			bcs 	_SSReturnNull
.1786	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.1788	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.178a	18		clc				clc
.178b	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.178d	b0 06		bcs $1795			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.178f	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.1791	f0 04		beq $1797			beq 	_SMIsOkay
.1793	90 02		bcc $1797			bcc 	_SMIsOkay
.1795					_SMTruncateToEnd:
.1795	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.1797					_SMIsOkay:
.1797	85 2f		sta $2f				sta 	zTemp1+1
.1799	38		sec				sec		 							; work out size
.179a	a5 2f		lda $2f				lda 	zTemp1+1
.179c	e5 2e		sbc $2e				sbc 	zTemp1
.179e	f0 1e		beq $17be			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.17a0	20 fe 16	jsr $16fe			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.17a3	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.17a5					_SMCopy:
.17a5	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.17a7	f0 11		beq $17ba			beq 	_SMExit
.17a9	c8		iny				iny 								; bump and
.17aa	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.17ac	5a		phy				phy
.17ad	48		pha				pha
.17ae	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.17b0	1a		inc a				inc 	a
.17b1	a8		tay				tay
.17b2	92 22		sta ($22)			sta 	(zsTemp)
.17b4	68		pla				pla 								; write character out
.17b5	91 22		sta ($22),y			sta 	(zsTemp),y
.17b7	7a		ply				ply 								; restore Y
.17b8	80 eb		bra $17a5			bra 	_SMCopy
.17ba					_SMExit:
.17ba	7a		ply				ply
.17bb	4c 4f 08	jmp $084f			jmp 	NextCommand
.17be					_SSReturnNull:
.17be	a9 d0		lda #$d0			lda 	#SSRNull & $FF 				; set up mantissa
.17c0	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17c2	a9 17		lda #$17			lda 	#SSRNull >> 8
.17c4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17c6	74 56		stz $56,x			stz 	NSMantissa2,x
.17c8	74 62		stz $62,x			stz 	NSMantissa3,x
.17ca	a9 40		lda #$40			lda 	#NSSString
.17cc	95 32		sta $32,x			sta 	NSStatus,x
.17ce	80 ea		bra $17ba			bra 	_SMExit
.17d0					SSRNull:
>17d0	00 00						.word 	0
.17d2					CommandSwap:
.17d2	fa		plx				plx
.17d3	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17d5	48		pha				pha
.17d6	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.17d8	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17da	68		pla				pla
.17db	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.17dd	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17df	48		pha				pha
.17e0	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.17e2	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17e4	68		pla				pla
.17e5	95 49		sta $49,x			sta 	NSMantissa1-1,x
.17e7	b5 56		lda $56,x			lda 	NSMantissa2,x
.17e9	48		pha				pha
.17ea	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.17ec	95 56		sta $56,x			sta 	NSMantissa2,x
.17ee	68		pla				pla
.17ef	95 55		sta $55,x			sta 	NSMantissa2-1,x
.17f1	b5 62		lda $62,x			lda 	NSMantissa3,x
.17f3	48		pha				pha
.17f4	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.17f6	95 62		sta $62,x			sta 	NSMantissa3,x
.17f8	68		pla				pla
.17f9	95 61		sta $61,x			sta 	NSMantissa3-1,x
.17fb	b5 6e		lda $6e,x			lda 	NSExponent,x
.17fd	48		pha				pha
.17fe	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.1800	95 6e		sta $6e,x			sta 	NSExponent,x
.1802	68		pla				pla
.1803	95 6d		sta $6d,x			sta 	NSExponent-1,x
.1805	b5 32		lda $32,x			lda 	NSStatus,x
.1807	48		pha				pha
.1808	b5 31		lda $31,x			lda 	NSStatus-1,x
.180a	95 32		sta $32,x			sta 	NSStatus,x
.180c	68		pla				pla
.180d	95 31		sta $31,x			sta 	NSStatus-1,x
.180f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1812					CommandSYS:
.1812	fa		plx				plx
.1813	da		phx				phx 								; save XY
.1814	5a		phy				phy
.1815	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.1818	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.181a	85 2d		sta $2d				sta 	zTemp0+1
.181c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.181e	85 2c		sta $2c				sta 	zTemp0
.1820	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1823	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.1826	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.1829	48		pha				pha
.182a	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.182d	28		plp				plp
.182e	20 45 18	jsr $1845			jsr 	_CSZTemp0
.1831	08		php				php
.1832	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1835	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.1838	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.183b	68		pla				pla
.183c	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.183f	7a		ply				ply 								; restore YX and drop 2
.1840	fa		plx				plx
.1841	ca		dex				dex
.1842	4c 4f 08	jmp $084f			jmp 	NextCommand
.1845					_CSZTemp0:
.1845	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.1848					TimeTOS:
.1848	fa		plx				plx
.1849	20 a3 18	jsr $18a3			jsr 	TIPushClock 				; push clock to TOS
.184c	4c 4f 08	jmp $084f			jmp 	NextCommand
.184f					TimeString:
.184f	fa		plx				plx
.1850	20 a3 18	jsr $18a3			jsr 	TIPushClock 				; push clock to TOS
.1853	20 78 18	jsr $1878			jsr 	_TSDivMod60 				; result in seconds
.1856	20 78 18	jsr $1878			jsr 	_TSDivMod60 				; seconds
.1859	48		pha				pha
.185a	20 78 18	jsr $1878			jsr 	_TSDivMod60 				; minutes
.185d	48		pha				pha
.185e	a9 18		lda #$18			lda 	#24 						; hours
.1860	20 7a 18	jsr $187a			jsr 	_TSDivModA
.1863	48		pha				pha
.1864	a9 06		lda #$06			lda 	#6
.1866	20 fe 16	jsr $16fe			jsr 	StringAllocTemp
.1869	68		pla				pla
.186a	20 8a 18	jsr $188a			jsr 	_TSWriteDecimal
.186d	68		pla				pla
.186e	20 8a 18	jsr $188a			jsr 	_TSWriteDecimal
.1871	68		pla				pla
.1872	20 8a 18	jsr $188a			jsr 	_TSWriteDecimal
.1875	4c 4f 08	jmp $084f			jmp 	NextCommand
.1878					_TSDivMod60:
.1878	a9 3c		lda #$3c			lda 	#60
.187a					_TSDivModA:
.187a	e8		inx				inx
.187b	20 3d 26	jsr $263d			jsr 	FloatSetByte
.187e	ca		dex				dex
.187f	20 d1 21	jsr $21d1			jsr 	Int32Divide
.1882	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.1884	48		pha				pha
.1885	20 c0 21	jsr $21c0			jsr 	NSMCopyPlusTwoToZero
.1888	68		pla				pla
.1889	60		rts				rts
.188a					_TSWriteDecimal:
.188a	da		phx				phx
.188b	a2 30		ldx #$30			ldx 	#'0'
.188d					_TSWDLoop:
.188d	c9 0a		cmp #$0a			cmp 	#10
.188f	90 05		bcc $1896			bcc 	_TSWDEnd
.1891	e9 0a		sbc #$0a			sbc 	#10
.1893	e8		inx				inx
.1894	80 f7		bra $188d			bra 	_TSWDLoop
.1896					_TSWDEnd:
.1896	48		pha				pha
.1897	8a		txa				txa
.1898	20 27 17	jsr $1727			jsr 	StringWriteChar
.189b	68		pla				pla
.189c	09 30		ora #$30			ora 	#'0'
.189e	20 27 17	jsr $1727			jsr 	StringWriteChar
.18a1	fa		plx				plx
.18a2	60		rts				rts
.18a3					TIPushClock:
.18a3	5a		phy				phy
.18a4	e8		inx				inx 								; push 0 on the stack
.18a5	20 3b 26	jsr $263b			jsr 	FloatSetZero
.18a8	da		phx				phx
.18a9	20 93 1c	jsr $1c93			jsr 	XReadClock 					; read time into YXA
.18ac	86 2c		stx $2c				stx 	zTemp0
.18ae	fa		plx				plx
.18af	95 3e		sta $3e,x			sta 	NSMantissa0,x
.18b1	a5 2c		lda $2c				lda 	zTemp0
.18b3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.18b5	98		tya				tya
.18b6	95 56		sta $56,x			sta 	NSMantissa2,x
.18b8	7a		ply				ply
.18b9	60		rts				rts
.18ba					CommandTIWrite:
.18ba	fa		plx				plx
.18bb	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.18bd	85 22		sta $22				sta 	zsTemp
.18bf	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.18c1	85 23		sta $23				sta 	zsTemp+1
.18c3	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.18c5	c9 06		cmp #$06			cmp 	#6
.18c7	d0 59		bne $1922			bne 	_CTIWError
.18c9	20 3b 26	jsr $263b			jsr 	FloatSetZero
.18cc	20 ee 18	jsr $18ee			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.18cf	20 ee 18	jsr $18ee			jsr 	_CTIWDigitPair
.18d2	20 ee 18	jsr $18ee			jsr 	_CTIWDigitPair
.18d5	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.18d7	20 19 19	jsr $1919			jsr 	_CTIWMultiply
.18da	da		phx				phx
.18db	5a		phy				phy
.18dc	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.18de	48		pha				pha
.18df	b5 56		lda $56,x			lda 	NSMantissa2,x
.18e1	a8		tay				tay
.18e2	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.18e4	fa		plx				plx
.18e5	20 97 1c	jsr $1c97			jsr 	XWriteClock 				; update the clock.
.18e8	7a		ply				ply
.18e9	fa		plx				plx
.18ea	ca		dex				dex 								; throw result.
.18eb	4c 4f 08	jmp $084f			jmp 	NextCommand
.18ee					_CTIWDigitPair:
.18ee	a9 06		lda #$06			lda 	#6 							; x 6
.18f0	20 19 19	jsr $1919			jsr 	_CTIWMultiply
.18f3	20 ff 18	jsr $18ff			jsr 	_CTIWAddDigit 				; add digit
.18f6	a9 0a		lda #$0a			lda 	#10 						; x 10
.18f8	20 19 19	jsr $1919			jsr 	_CTIWMultiply
.18fb	20 ff 18	jsr $18ff			jsr 	_CTIWAddDigit 				; add digit
.18fe	60		rts				rts
.18ff					_CTIWAddDigit:
.18ff	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.1901	d0 02		bne $1905			bne 	_CTIWASkip
.1903	e6 23		inc $23				inc 	zsTemp+1
.1905					_CTIWASkip:
.1905	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.1907	38		sec				sec
.1908	e9 30		sbc #$30			sbc 	#"0"
.190a	90 16		bcc $1922			bcc 	_CTIWError
.190c	c9 0a		cmp #$0a			cmp 	#9+1
.190e	b0 12		bcs $1922			bcs 	_CTIWError
.1910	e8		inx				inx 								; store at +1
.1911	20 3d 26	jsr $263d			jsr 	FloatSetByte
.1914	ca		dex				dex
.1915	20 c7 23	jsr $23c7			jsr 	FloatAddTopTwoStack
.1918	60		rts				rts
.1919					_CTIWMultiply:
.1919	e8		inx				inx
.191a	20 3d 26	jsr $263d			jsr 	FloatSetByte
.191d	ca		dex				dex
.191e	20 48 23	jsr $2348			jsr 	FloatMultiplyShort
.1921	60		rts				rts
.1922					_CTIWError:
.1922	4c e8 1e	jmp $1ee8		jmp	ErrorV_value
.1925					UnaryUsr:
.1925	fa		plx				plx
.1926	5a		phy				phy
.1927	20 2e 19	jsr $192e			jsr 	_UUCallVector
.192a	7a		ply				ply
.192b	4c 4f 08	jmp $084f			jmp 	NextCommand
.192e					_UUCallVector:
.192e	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.1931					ValUnary:
.1931	fa		plx				plx
.1932	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1934	85 2c		sta $2c				sta 	zTemp0
.1936	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1938	85 2d		sta $2d				sta 	zTemp0+1
.193a	20 45 19	jsr $1945			jsr 	ValEvaluateZTemp0
.193d	b0 03		bcs $1942			bcs 	_VUError 					; couldn't convert
.193f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1942					_VUError:
.1942	4c e8 1e	jmp $1ee8		jmp	ErrorV_value
.1945					ValEvaluateZTemp0:
.1945	5a		phy				phy
.1946	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.1948	f0 22		beq $196c			beq 	_VMCFail2
.194a	a0 00		ldy #$00			ldy 	#0 							; start position
.194c					_VMCSpaces:
.194c	c8		iny				iny 								; skip leading spaces
.194d	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.194f	c9 20		cmp #$20			cmp 	#" "
.1951	f0 f9		beq $194c			beq 	_VMCSpaces
.1953	48		pha				pha 								; save first character
.1954	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.1956	d0 01		bne $1959			bne 	_VMCStart
.1958	c8		iny				iny 								; skip over - if so.
.1959					_VMCStart:
.1959	38		sec				sec 								; initialise first time round.
.195a					_VMCNext:
.195a	98		tya				tya 								; reached end of string
.195b	3a		dec a				dec 	a
.195c	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.195e	f0 0f		beq $196f			beq 	_VMCSuccess 				; successful.
.1960	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.1962	c8		iny				iny
.1963	20 1f 24	jsr $241f			jsr 	FloatEncode 				; send it to the number-builder
.1966	90 03		bcc $196b			bcc 	_VMCFail 					; if failed, give up.
.1968	18		clc				clc 								; next time round, countinue
.1969	80 ef		bra $195a			bra 	_VMCNext
.196b					_VMCFail:
.196b	68		pla				pla
.196c					_VMCFail2:
.196c	7a		ply				ply
.196d	38		sec				sec
.196e	60		rts				rts
.196f					_VMCSuccess:
.196f	a9 00		lda #$00			lda 	#0 							; construct final
.1971	20 1f 24	jsr $241f			jsr 	FloatEncode 				; by sending a duff value.
.1974	68		pla				pla 								; if it was -ve
.1975	c9 2d		cmp #$2d			cmp 	#"-"
.1977	d0 03		bne $197c			bne 	_VMCNotNegative
.1979	20 fd 25	jsr $25fd			jsr		FloatNegate 				; negate it.
.197c					_VMCNotNegative:
.197c	7a		ply				ply
.197d	18		clc				clc
.197e	60		rts				rts
.197f					VectorTable:
>197f	96 10					.word	LinkFloatAdd             ; $80 +
>1981	9f 10					.word	LinkFloatSubtract        ; $81 -
>1983	a8 10					.word	LinkFloatMultiply        ; $82 *
>1985	b1 10					.word	LinkFloatDivide          ; $83 /
>1987	bc 10					.word	LinkFloatPower           ; $84 ^
>1989	e1 08					.word	BinaryAnd                ; $85 and
>198b	e5 08					.word	BinaryOr                 ; $86 or
>198d	c7 10					.word	LinkCompareGreater       ; $87 >
>198f	d0 10					.word	LinkCompareEqual         ; $88 =
>1991	d9 10					.word	LinkCompareLess          ; $89 <
>1993	e2 10					.word	LinkCompareGreaterEqual  ; $8a >=
>1995	eb 10					.word	LinkCompareNotEqual      ; $8b <>
>1997	f4 10					.word	LinkCompareLessEqual     ; $8c <=
>1999	c9 08					.word	AbsoluteTOS              ; $8d abs
>199b	1c 09					.word	ArrayConvert             ; $8e array
>199d	c4 09					.word	UnaryAsc                 ; $8f asc
>199f	df 09					.word	CommandAssert            ; $90 assert
>19a1	20 0a					.word	Unary16Bin               ; $91 bin$
>19a3	4a 0a					.word	PrintCharacterX          ; $92 print.chr
>19a5	54 0a					.word	UnaryChr                 ; $93 chr$
>19a7	b9 0a					.word	CompareStrings           ; $94 s.cmp
>19a9	a3 0c					.word	CommandXFor              ; $95 for
>19ab	66 0d					.word	UnaryFre                 ; $96 fre
>19ad	7e 0d					.word	CommandXGet              ; $97 get
>19af	a4 0d					.word	CommandReturn            ; $98 return
>19b1	e6 0d					.word	Command_PSET             ; $99 pset
>19b3	00 0e					.word	Command_LINE             ; $9a line
>19b5	15 0e					.word	Command_RECT             ; $9b rect
>19b7	24 0e					.word	Command_FRAME            ; $9c frame
>19b9	33 0e					.word	Command_CHAR             ; $9d char
>19bb	ca 0e					.word	Unary16Hex               ; $9e hex$
>19bd	71 0f					.word	CommandXInput            ; $9f input
>19bf	88 0f					.word	CommandInputString       ; $a0 input$
>19c1	a1 0f					.word	CommandInputReset        ; $a1 input.start
>19c3	85 10					.word	UnaryLen                 ; $a2 len
>19c5	51 11					.word	LinkFloatCompare         ; $a3 f.cmp
>19c7	5a 11					.word	LinkDivideInt32          ; $a4 int.div
>19c9	d4 11					.word	NegateTOS                ; $a5 negate
>19cb	db 11					.word	CommandNewLine           ; $a6 new.line
>19cd	e4 11					.word	CommandXNext             ; $a7 next
>19cf	cd 12					.word	NotTOS                   ; $a8 not
>19d1	e4 12					.word	CommandXOn               ; $a9 on
>19d3	01 13					.word	CommandMoreOn            ; $aa moreon
>19d5	08 13					.word	UnaryPeek                ; $ab peek
>19d7	1d 13					.word	CommandPOKE              ; $ac poke
>19d9	35 13					.word	UnaryPos                 ; $ad pos
>19db	3f 13					.word	GetChannel               ; $ae getchannel
>19dd	4a 13					.word	SetChannel               ; $af setchannel
>19df	6d 13					.word	PrintNumber              ; $b0 print.n
>19e1	8c 13					.word	PrintString              ; $b1 print.s
>19e3	f3 13					.word	CommandXRead             ; $b2 read
>19e5	0d 14					.word	CommandReadString        ; $b3 read$
>19e7	98 15					.word	UnaryRND                 ; $b4 rnd
>19e9	07 16					.word	StringConcatenate        ; $b5 concat
>19eb	5e 16					.word	SignTOS                  ; $b6 sgn
>19ed	81 16					.word	PrintTab                 ; $b7 print.tab
>19ef	8f 16					.word	PrintPos                 ; $b8 print.pos
>19f1	a0 16					.word	PrintSpace               ; $b9 print.spc
>19f3	b9 16					.word	Unary_Str                ; $ba str$
>19f5	34 17					.word	Unary_Left               ; $bb left$
>19f7	44 17					.word	Unary_Right              ; $bc right$
>19f9	60 17					.word	Unary_Mid                ; $bd mid$
>19fb	d2 17					.word	CommandSwap              ; $be swap
>19fd	48 18					.word	TimeTOS                  ; $bf ti
>19ff	4f 18					.word	TimeString               ; $c0 ti$
>1a01	25 19					.word	UnaryUsr                 ; $c1 usr
>1a03	31 19					.word	ValUnary                 ; $c2 val
>1a05	8f 1b					.word	CommandClose             ; $c3 close
>1a07	a1 1b					.word	CommandExit              ; $c4 exit
>1a09	a7 1b					.word	CommandDebug             ; $c5 debug
>1a0b	0d 1c					.word	CommandXOpen             ; $c6 open
>1a0d	a1 1c					.word	CommandScreen            ; $c7 screen
>1a0f	88 1e					.word	CommandVPOKE             ; $c8 vpoke
>1a11	ad 1e					.word	CommandVPEEK             ; $c9 vpeek
>1a13	79 16					.word	CommandShift             ; $ca .shift
>1a15	8d 08					.word	PushByteCommand          ; $cb .byte
>1a17	a0 08					.word	PushWordCommand          ; $cc .word
>1a19	af 13					.word	CommandPushN             ; $cd .float
>1a1b	d5 13					.word	CommandPushS             ; $ce .string
>1a1d	41 0b					.word	CommandXData             ; $cf .data
>1a1f	b5 0d					.word	CommandXGoto             ; $d0 .goto
>1a21	98 0d					.word	CommandXGosub            ; $d1 .gosub
>1a23	ca 0d					.word	CommandGotoZ             ; $d2 .goto.z
>1a25	d8 0d					.word	CommandGotoNZ            ; $d3 .goto.nz
>1a27	cf 08					.word	CommandVarSpace          ; $d4 .varspace
.1a29					ShiftVectorTable:
>1a29	6c 0a					.word	CommandClr               ; $ca80 clr
>1a2b	4a 0b					.word	CommandXDIM              ; $ca81 dim
>1a2d	3b 0c					.word	CommandEnd               ; $ca82 end
>1a2f	56 10					.word	UnaryJoy                 ; $ca83 joy
>1a31	fd 10					.word	LinkFloatIntegerPartDown ; $ca84 int
>1a33	06 11					.word	LinkFloatSquareRoot      ; $ca85 sqr
>1a35	17 11					.word	LinkFloatLogarithm       ; $ca86 log
>1a37	22 11					.word	LinkFloatExponent        ; $ca87 exp
>1a39	2b 11					.word	LinkFloatCosine          ; $ca88 cos
>1a3b	34 11					.word	LinkFloatSine            ; $ca89 sin
>1a3d	3d 11					.word	LinkFloatTangent         ; $ca8a tan
>1a3f	46 11					.word	LinkFloatArcTan          ; $ca8b atn
>1a41	84 11					.word	XCommandMouse            ; $ca8c mouse
>1a43	99 11					.word	XUnaryMB                 ; $ca8d mb
>1a45	a6 11					.word	XUnaryMX                 ; $ca8e mx
>1a47	b7 11					.word	XUnaryMY                 ; $ca8f my
>1a49	86 15					.word	CommandRestore           ; $ca90 restore
>1a4b	b5 16					.word	CommandStop              ; $ca91 stop
>1a4d	12 18					.word	CommandSYS               ; $ca92 sys
>1a4f	ba 18					.word	CommandTIWrite           ; $ca93 ti$.write
>1a51	87 1a					.word	CommandXWAIT             ; $ca94 wait
>1a53	d2 1b					.word	X16I2CPoke               ; $ca95 i2cpoke
>1a55	f2 1b					.word	X16I2CPeek               ; $ca96 i2cpeek
>1a57	5d 1c					.word	CommandBank              ; $ca97 bank
>1a59	b0 1c					.word	XCommandSleep            ; $ca98 sleep
>1a5b	d4 1c					.word	X16_Audio_FMINIT         ; $ca99 fminit
>1a5d	e2 1c					.word	X16_Audio_FMNOTE         ; $ca9a fmnote
>1a5f	f4 1c					.word	X16_Audio_FMDRUM         ; $ca9b fmdrum
>1a61	06 1d					.word	X16_Audio_FMINST         ; $ca9c fminst
>1a63	18 1d					.word	X16_Audio_FMVIB          ; $ca9d fmvib
>1a65	2a 1d					.word	X16_Audio_FMFREQ         ; $ca9e fmfreq
>1a67	3b 1d					.word	X16_Audio_FMVOL          ; $ca9f fmvol
>1a69	4d 1d					.word	X16_Audio_FMPAN          ; $caa0 fmpan
>1a6b	5f 1d					.word	X16_Audio_FMPLAY         ; $caa1 fmplay
>1a6d	70 1d					.word	X16_Audio_FMCHORD        ; $caa2 fmchord
>1a6f	81 1d					.word	X16_Audio_FMPOKE         ; $caa3 fmpoke
>1a71	93 1d					.word	X16_Audio_PSGINIT        ; $caa4 psginit
>1a73	a1 1d					.word	X16_Audio_PSGNOTE        ; $caa5 psgnote
>1a75	b3 1d					.word	X16_Audio_PSGVOL         ; $caa6 psgvol
>1a77	c5 1d					.word	X16_Audio_PSGWAV         ; $caa7 psgwav
>1a79	d7 1d					.word	X16_Audio_PSGFREQ        ; $caa8 psgfreq
>1a7b	e8 1d					.word	X16_Audio_PSGPAN         ; $caa9 psgpan
>1a7d	fa 1d					.word	X16_Audio_PSGPLAY        ; $caaa psgplay
>1a7f	0b 1e					.word	X16_Audio_PSGCHORD       ; $caab psgchord
>1a81	1c 1e					.word	CommandCls               ; $caac cls
>1a83	25 1e					.word	CommandLocate            ; $caad locate
>1a85	4f 1e					.word	CommandColor             ; $caae color
.1a87					CommandXWAIT:
.1a87	fa		plx				plx
.1a88	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1a8a	85 2c		sta $2c				sta 	zTemp0
.1a8c	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1a8e	85 2d		sta $2d				sta 	zTemp0+1
.1a90					_WaitLoop:
.1a90	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1a92	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1a94	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1a96	f0 f8		beq $1a90			beq 	_WaitLoop 					; keep going if zero
.1a98	ca		dex				dex 								; drop 3.
.1a99	ca		dex				dex
.1a9a	ca		dex				dex
.1a9b	4c 4f 08	jmp $084f			jmp 	NextCommand
.1a9e					WriteFloatCommand:
.1a9e	fa		plx				plx
.1a9f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1aa1	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1aa3	88		dey				dey 								; get the upper 3 bits
.1aa4	b1 28		lda ($28),y			lda 	(codePtr),y
.1aa6	29 07		and #$07			and 	#7
.1aa8	c8		iny				iny
.1aa9	c8		iny				iny
.1aaa	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1aac	2a		rol a				rol 	a 							; carry will be clear.
.1aad	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1ab0	85 2d		sta $2d				sta 	zTemp0+1
.1ab2	20 b8 1a	jsr $1ab8			jsr 	WriteFloatZTemp0Sub
.1ab5	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ab8					WriteFloatZTemp0Sub:
.1ab8	5a		phy				phy 								; ldart write
.1ab9	a0 01		ldy #$01			ldy 	#1
.1abb	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1abd	92 2c		sta ($2c)			sta 	(zTemp0)
.1abf	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ac1	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ac3	c8		iny				iny
.1ac4	b5 56		lda $56,x			lda 	NSMantissa2,x
.1ac6	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ac8	c8		iny				iny
.1ac9	b5 62		lda $62,x			lda 	NSMantissa3,x
.1acb	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1acd	c8		iny				iny
.1ace	b5 6e		lda $6e,x			lda 	NSExponent,x
.1ad0	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ad2	c8		iny				iny
.1ad3	b5 32		lda $32,x			lda 	NSStatus,x
.1ad5	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ad7	ca		dex				dex
.1ad8	7a		ply				ply
.1ad9	60		rts				rts
.1ada					WriteIntegerCommand:
.1ada	fa		plx				plx
.1adb	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1add	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1adf	88		dey				dey 								; get the upper 3 bits
.1ae0	b1 28		lda ($28),y			lda 	(codePtr),y
.1ae2	29 07		and #$07			and 	#7
.1ae4	c8		iny				iny
.1ae5	c8		iny				iny
.1ae6	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1ae8	2a		rol a				rol 	a 							; carry will be clear.
.1ae9	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1aec	85 2d		sta $2d				sta 	zTemp0+1
.1aee	20 f4 1a	jsr $1af4			jsr 	WriteIntegerZTemp0Sub
.1af1	4c 4f 08	jmp $084f			jmp 	NextCommand
.1af4					WriteIntegerZTemp0Sub:
.1af4	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.1af7	5a		phy				phy 								; start write
.1af8	a0 01		ldy #$01			ldy 	#1
.1afa	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1afc	30 0b		bmi $1b09			bmi 	_WIZNegative
.1afe	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1b00	92 2c		sta ($2c)			sta 	(zTemp0)
.1b02	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b04	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b06	7a		ply				ply
.1b07	ca		dex				dex
.1b08	60		rts				rts
.1b09					_WIZNegative:
.1b09	38		sec				sec 								; -ve read
.1b0a	a9 00		lda #$00			lda 	#0
.1b0c	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1b0e	92 2c		sta ($2c)			sta 	(zTemp0)
.1b10	a9 00		lda #$00			lda 	#0
.1b12	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1b14	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b16	7a		ply				ply
.1b17	ca		dex				dex
.1b18	60		rts				rts
.1b19					WriteStringCommand:
.1b19	fa		plx				plx
.1b1a	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b1c	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b1e	88		dey				dey 								; get the upper 3 bits
.1b1f	b1 28		lda ($28),y			lda 	(codePtr),y
.1b21	29 07		and #$07			and 	#7
.1b23	c8		iny				iny
.1b24	c8		iny				iny
.1b25	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b27	2a		rol a				rol 	a 							; carry will be clear.
.1b28	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b2b	85 2d		sta $2d				sta 	zTemp0+1
.1b2d	20 33 1b	jsr $1b33			jsr 	WriteStringZTemp0Sub
.1b30	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b33					WriteStringZTemp0Sub:
.1b33	5a		phy				phy
.1b34	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b36	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b38	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b3a	f0 1e		beq $1b5a			beq 	_WSConcrete
.1b3c	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b3e	85 2e		sta $2e				sta 	zTemp1
.1b40	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b42	85 2f		sta $2f				sta 	zTemp1+1
.1b44	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b46	85 30		sta $30				sta 	zTemp2
.1b48	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b4a	85 31		sta $31				sta 	zTemp2+1
.1b4c	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1b4e	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1b50	b0 17		bcs $1b69			bcs 	_WSCopy
.1b52	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1b54	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b56	09 80		ora #$80			ora 	#$80
.1b58	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1b5a					_WSConcrete:
.1b5a	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1b5c	a8		tay				tay
.1b5d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b5f	20 fb 0a	jsr $0afb			jsr 	StringConcrete
.1b62	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1b64	98		tya				tya
.1b65	a0 01		ldy #$01			ldy 	#1
.1b67	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b69					_WSCopy
.1b69	18		clc				clc  								; copy target+2 to zTemp2
.1b6a	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b6c	69 02		adc #$02			adc 	#2
.1b6e	85 30		sta $30				sta 	zTemp2
.1b70	a0 01		ldy #$01			ldy 	#1
.1b72	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b74	69 00		adc #$00			adc 	#0
.1b76	85 31		sta $31				sta 	zTemp2+1
.1b78	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1b7a	85 2e		sta $2e				sta 	zTemp1
.1b7c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b7e	85 2f		sta $2f				sta 	zTemp1+1
.1b80	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1b82	a8		tay				tay
.1b83					_WSCopyLoop:
.1b83	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b85	91 30		sta ($30),y			sta 	(zTemp2),y
.1b87	88		dey				dey
.1b88	c0 ff		cpy #$ff			cpy 	#$FF
.1b8a	d0 f7		bne $1b83			bne 	_WSCopyLoop
.1b8c	ca		dex				dex
.1b8d	7a		ply				ply
.1b8e	60		rts				rts
.1b8f					CommandClose:
.1b8f	fa		plx				plx
.1b90	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; channel to close
.1b93	cd 5e 04	cmp $045e			cmp 	currentChannel 				; is it the current channel
.1b96	d0 03		bne $1b9b			bne 	_CCNotCurrent
.1b98	9c 5e 04	stz $045e			stz 	currentChannel 				; effectively disables CMD
.1b9b					_CCNotCurrent:
.1b9b	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1b9e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ba1					CommandExit:
.1ba1	fa		plx				plx
.1ba2	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1ba4	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1ba7					CommandDebug:
.1ba7	fa		plx				plx
>1ba8	db						.byte 	$DB 						; causes a break in the emulator
.1ba9	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bac					XGetCharacterFromChannel:
.1bac	da		phx				phx
.1bad	5a		phy				phy
.1bae	e0 00		cpx #$00			cpx 	#0 							; is it default
.1bb0	d0 05		bne $1bb7			bne 	_XGetChannel
.1bb2	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1bb5	80 08		bra $1bbf			bra 	_XGetChar
.1bb7					_XGetChannel:
.1bb7	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1bba	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1bbd	d0 06		bne $1bc5			bne 	_XGCError
.1bbf					_XGetChar:
.1bbf	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1bc2	7a		ply				ply
.1bc3	fa		plx				plx
.1bc4	60		rts				rts
.1bc5					_XGCError:
.1bc5	4c f4 1f	jmp $1ff4		jmp	ErrorV_channel
.1bc8					XGetHPos:
.1bc8	da		phx				phx
.1bc9	5a		phy				phy
.1bca	38		sec				sec
.1bcb	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1bce	98		tya				tya
.1bcf	7a		ply				ply
.1bd0	fa		plx				plx
.1bd1	60		rts				rts
.1bd2					X16I2CPoke:
.1bd2	fa		plx				plx
.1bd3	5a		phy				phy
.1bd4	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; value
.1bd7	48		pha				pha
.1bd8	ca		dex				dex
.1bd9	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; register
.1bdc	48		pha				pha
.1bdd	ca		dex				dex
.1bde	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; device
.1be1	aa		tax				tax
.1be2	7a		ply				ply
.1be3	68		pla				pla
.1be4	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1be7	b0 06		bcs $1bef			bcs 	X16I2CError
.1be9	7a		ply				ply
.1bea	a2 ff		ldx #$ff			ldx 	#$FF
.1bec	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bef					X16I2CError:
.1bef	4c f4 1f	jmp $1ff4		jmp	ErrorV_channel
.1bf2					X16I2CPeek:
.1bf2	fa		plx				plx
.1bf3	da		phx				phx
.1bf4	5a		phy				phy
.1bf5	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; register
.1bf8	48		pha				pha
.1bf9	ca		dex				dex
.1bfa	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; device
.1bfd	aa		tax				tax 								; X device
.1bfe	7a		ply				ply 								; Y register
.1bff	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1c02	b0 eb		bcs $1bef			bcs 	X16I2CError
.1c04	7a		ply				ply 								; restore Y/X
.1c05	fa		plx				plx
.1c06	ca		dex				dex 								; drop TOS (register)
.1c07	20 3d 26	jsr $263d			jsr 	FloatSetByte 				; write read value to TOS.
.1c0a	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c0d					CommandXOpen:
.1c0d	fa		plx				plx
.1c0e	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1c10	85 2c		sta $2c				sta 	zTemp0
.1c12	aa		tax				tax
.1c13	a5 4d		lda $4d				lda 	NSMantissa1+3
.1c15	85 2d		sta $2d				sta 	zTemp0+1
.1c17	a8		tay				tay
.1c18	e8		inx				inx 								; XY points to first character
.1c19	d0 01		bne $1c1c			bne 	_CONoCarry
.1c1b	c8		iny				iny
.1c1c					_CONoCarry:
.1c1c	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c1e	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c21	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c23	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c25	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c27	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c2a	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c2d	b0 03		bcs $1c32			bcs 	_COError
.1c2f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c32					_COError:
.1c32	4c f4 1f	jmp $1ff4		jmp	ErrorV_channel
.1c35					XPokeMemory:
.1c35	86 2c		stx $2c				stx 	zTemp0
.1c37	84 2d		sty $2d				sty 	zTemp0+1
.1c39	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c3b	ae 6c 05	ldx $056c			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c3e	e0 ff		cpx #$ff			cpx 	#$FF
.1c40	f0 02		beq $1c44			beq 	_XPMNoSwitch
.1c42	86 00		stx $00				stx 	SelectRAMBank
.1c44					_XPMNoSwitch:
.1c44	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1c46	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1c48					_XPMExit:
.1c48	60		rts				rts
.1c49					XPeekMemory:
.1c49	86 2c		stx $2c				stx 	zTemp0
.1c4b	84 2d		sty $2d				sty 	zTemp0+1
.1c4d	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c4f	ae 6c 05	ldx $056c			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c52	e0 ff		cpx #$ff			cpx 	#$FF
.1c54	f0 02		beq $1c58			beq 	_XPMNoSwitch
.1c56	86 00		stx $00				stx 	SelectRAMBank
.1c58					_XPMNoSwitch:
.1c58	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1c5a	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1c5c	60		rts				rts
.1c5d					CommandBank:
.1c5d	fa		plx				plx
.1c5e	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1c60	8d 6c 05	sta $056c			sta 	ramBank 					; store & make current
.1c63	85 00		sta $00				sta 	SelectRAMBank
.1c65	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1c67	c9 ff		cmp #$ff			cmp 	#$FF
.1c69	f0 03		beq $1c6e			beq 	_CBNoUpdate
.1c6b	8d 6d 05	sta $056d			sta 	romBank 					; this doesn't set the hardware page.
.1c6e					_CBNoUpdate:
.1c6e	a2 ff		ldx #$ff			ldx 	#$FF
.1c70	4c 4f 08	jmp $084f			jmp 	NextCommand
.056c					ramBank:
>056c							.fill 	1
.056d					romBank:
>056d							.fill 	1
.1c73					XPrintCharacterToChannel:
.1c73	48		pha				pha
.1c74	da		phx				phx
.1c75	5a		phy				phy
.1c76	48		pha				pha  								; save char
.1c77	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1c79	d0 05		bne $1c80			bne 	_XPCNotDefault
.1c7b	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1c7e	80 08		bra $1c88			bra 	_XPCSend
.1c80					_XPCNotDefault:
.1c80	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1c83	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1c86	d0 08		bne $1c90			bne 	_XPCError
.1c88					_XPCSend:
.1c88	68		pla				pla 								; restore character
.1c89	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1c8c	7a		ply				ply
.1c8d	fa		plx				plx
.1c8e	68		pla				pla
.1c8f	60		rts				rts
.1c90					_XPCError:
.1c90	4c f4 1f	jmp $1ff4		jmp	ErrorV_channel
.1c93					XReadClock:
.1c93	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1c96	60		rts				rts
.1c97					XWriteClock:
.1c97	48		pha				pha
.1c98	da		phx				phx
.1c99	5a		phy				phy
.1c9a	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1c9d	7a		ply				ply
.1c9e	fa		plx				plx
.1c9f	68		pla				pla
.1ca0	60		rts				rts
.1ca1					CommandScreen:
.1ca1	fa		plx				plx
.1ca2	da		phx				phx
.1ca3	5a		phy				phy
.1ca4	20 2e 10	jsr $102e			jsr 	GetInteger8Bit
.1ca7	18		clc				clc
.1ca8	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1cab	7a		ply				ply
.1cac	fa		plx				plx
.1cad	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cb0					XCommandSleep:
.1cb0	fa		plx				plx
.1cb1	5a		phy				phy
.1cb2	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.1cb5	ca		dex				dex
.1cb6	20 93 1c	jsr $1c93			jsr 	XReadClock 					; read clock to YXA
.1cb9	18		clc				clc 								; calculate end time in zTemp0
.1cba	65 3e		adc $3e				adc 	NSMantissa0
.1cbc	85 2c		sta $2c				sta 	zTemp0
.1cbe	8a		txa				txa
.1cbf	65 4a		adc $4a				adc 	NSMantissa1
.1cc1	85 2d		sta $2d				sta 	zTemp0+1
.1cc3					_XCWait:
.1cc3	20 93 1c	jsr $1c93			jsr 	XReadClock 					; and wait for it.
.1cc6	c5 2c		cmp $2c				cmp 	zTemp0
.1cc8	d0 f9		bne $1cc3			bne 	_XCWait
.1cca	e4 2d		cpx $2d				cpx 	zTemp0+1
.1ccc	d0 f5		bne $1cc3			bne 	_XCWait
.1cce	a2 ff		ldx #$ff			ldx 	#$FF
.1cd0	7a		ply				ply
.1cd1	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cd4					X16_Audio_FMINIT:
.1cd4	fa		plx				plx
.1cd5	5a		phy			phy
.1cd6	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cd9	63 c0					.word	X16A_ym_init
>1cdb	0a					.byte	X16_AudioCodeBank
.1cdc	a2 ff		ldx #$ff		ldx	#$FF
.1cde	7a		ply			ply
.1cdf	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ce2					X16_Audio_FMNOTE:
.1ce2	fa		plx				plx
.1ce3	5a		phy			phy
.1ce4	20 f6 09	jsr $09f6		jsr		X16_Audio_Parameters8_8
.1ce7	18		clc			clc
.1ce8	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1ceb	03 c0					.word	X16A_bas_fmnote
>1ced	0a					.byte	X16_AudioCodeBank
.1cee	a2 ff		ldx #$ff		ldx	#$FF
.1cf0	7a		ply			ply
.1cf1	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cf4					X16_Audio_FMDRUM:
.1cf4	fa		plx				plx
.1cf5	5a		phy			phy
.1cf6	20 f6 09	jsr $09f6		jsr		X16_Audio_Parameters8_8
.1cf9	18		clc			clc
.1cfa	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cfd	6f c0					.word	X16A_ym_playdrum
>1cff	0a					.byte	X16_AudioCodeBank
.1d00	a2 ff		ldx #$ff		ldx	#$FF
.1d02	7a		ply			ply
.1d03	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d06					X16_Audio_FMINST:
.1d06	fa		plx				plx
.1d07	5a		phy			phy
.1d08	20 f6 09	jsr $09f6		jsr		X16_Audio_Parameters8_8
.1d0b	38		sec			sec
.1d0c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d0f	69 c0					.word	X16A_ym_loadpatch
>1d11	0a					.byte	X16_AudioCodeBank
.1d12	a2 ff		ldx #$ff		ldx	#$FF
.1d14	7a		ply			ply
.1d15	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d18					X16_Audio_FMVIB:
.1d18	fa		plx				plx
.1d19	5a		phy			phy
.1d1a	20 f6 09	jsr $09f6		jsr		X16_Audio_Parameters8_8
.1d1d	18		clc			clc
.1d1e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d21	09 c0					.word	X16A_bas_fmvib
>1d23	0a					.byte	X16_AudioCodeBank
.1d24	a2 ff		ldx #$ff		ldx	#$FF
.1d26	7a		ply			ply
.1d27	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d2a					X16_Audio_FMFREQ:
.1d2a	fa		plx				plx
.1d2b	5a		phy			phy
.1d2c	20 f0 09	jsr $09f0		jsr		X16_Audio_Parameters8_16
.1d2f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d32	00 c0					.word	X16A_bas_fmfreq
>1d34	0a					.byte	X16_AudioCodeBank
.1d35	a2 ff		ldx #$ff		ldx	#$FF
.1d37	7a		ply			ply
.1d38	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d3b					X16_Audio_FMVOL:
.1d3b	fa		plx				plx
.1d3c	5a		phy			phy
.1d3d	20 f6 09	jsr $09f6		jsr		X16_Audio_Parameters8_8
.1d40	18		clc			clc
.1d41	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d44	75 c0					.word	X16A_ym_setatten
>1d46	0a					.byte	X16_AudioCodeBank
.1d47	a2 ff		ldx #$ff		ldx	#$FF
.1d49	7a		ply			ply
.1d4a	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d4d					X16_Audio_FMPAN:
.1d4d	fa		plx				plx
.1d4e	5a		phy			phy
.1d4f	20 f6 09	jsr $09f6		jsr		X16_Audio_Parameters8_8
.1d52	18		clc			clc
.1d53	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d56	7e c0					.word	X16A_ym_setpan
>1d58	0a					.byte	X16_AudioCodeBank
.1d59	a2 ff		ldx #$ff		ldx	#$FF
.1d5b	7a		ply			ply
.1d5c	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d5f					X16_Audio_FMPLAY:
.1d5f	fa		plx				plx
.1d60	5a		phy			phy
.1d61	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_String
.1d64	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d67	06 c0					.word	X16A_bas_fmplaystring
>1d69	0a					.byte	X16_AudioCodeBank
.1d6a	a2 ff		ldx #$ff		ldx	#$FF
.1d6c	7a		ply			ply
.1d6d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d70					X16_Audio_FMCHORD:
.1d70	fa		plx				plx
.1d71	5a		phy			phy
.1d72	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_String
.1d75	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d78	8d c0					.word	X16A_bas_fmchordstring
>1d7a	0a					.byte	X16_AudioCodeBank
.1d7b	a2 ff		ldx #$ff		ldx	#$FF
.1d7d	7a		ply			ply
.1d7e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d81					X16_Audio_FMPOKE:
.1d81	fa		plx				plx
.1d82	5a		phy			phy
.1d83	20 f6 09	jsr $09f6		jsr		X16_Audio_Parameters8_8
.1d86	18		clc			clc
.1d87	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d8a	8a c0					.word	X16A_ym_write
>1d8c	0a					.byte	X16_AudioCodeBank
.1d8d	a2 ff		ldx #$ff		ldx	#$FF
.1d8f	7a		ply			ply
.1d90	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d93					X16_Audio_PSGINIT:
.1d93	fa		plx				plx
.1d94	5a		phy			phy
.1d95	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d98	4b c0					.word	X16A_psg_init
>1d9a	0a					.byte	X16_AudioCodeBank
.1d9b	a2 ff		ldx #$ff		ldx	#$FF
.1d9d	7a		ply			ply
.1d9e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1da1					X16_Audio_PSGNOTE:
.1da1	fa		plx				plx
.1da2	5a		phy			phy
.1da3	20 f6 09	jsr $09f6		jsr		X16_Audio_Parameters8_8
.1da6	18		clc			clc
.1da7	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1daa	12 c0					.word	X16A_bas_psgnote
>1dac	0a					.byte	X16_AudioCodeBank
.1dad	a2 ff		ldx #$ff		ldx	#$FF
.1daf	7a		ply			ply
.1db0	4c 4f 08	jmp $084f			jmp 	NextCommand
.1db3					X16_Audio_PSGVOL:
.1db3	fa		plx				plx
.1db4	5a		phy			phy
.1db5	20 f6 09	jsr $09f6		jsr		X16_Audio_Parameters8_8
.1db8	18		clc			clc
.1db9	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dbc	54 c0					.word	X16A_psg_setatten
>1dbe	0a					.byte	X16_AudioCodeBank
.1dbf	a2 ff		ldx #$ff		ldx	#$FF
.1dc1	7a		ply			ply
.1dc2	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dc5					X16_Audio_PSGWAV:
.1dc5	fa		plx				plx
.1dc6	5a		phy			phy
.1dc7	20 f6 09	jsr $09f6		jsr		X16_Audio_Parameters8_8
.1dca	18		clc			clc
.1dcb	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dce	15 c0					.word	X16A_bas_psgwav
>1dd0	0a					.byte	X16_AudioCodeBank
.1dd1	a2 ff		ldx #$ff		ldx	#$FF
.1dd3	7a		ply			ply
.1dd4	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dd7					X16_Audio_PSGFREQ:
.1dd7	fa		plx				plx
.1dd8	5a		phy			phy
.1dd9	20 f0 09	jsr $09f0		jsr		X16_Audio_Parameters8_16
.1ddc	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1ddf	0f c0					.word	X16A_bas_psgfreq
>1de1	0a					.byte	X16_AudioCodeBank
.1de2	a2 ff		ldx #$ff		ldx	#$FF
.1de4	7a		ply			ply
.1de5	4c 4f 08	jmp $084f			jmp 	NextCommand
.1de8					X16_Audio_PSGPAN:
.1de8	fa		plx				plx
.1de9	5a		phy			phy
.1dea	20 f6 09	jsr $09f6		jsr		X16_Audio_Parameters8_8
.1ded	18		clc			clc
.1dee	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1df1	5a c0					.word	X16A_psg_setpan
>1df3	0a					.byte	X16_AudioCodeBank
.1df4	a2 ff		ldx #$ff		ldx	#$FF
.1df6	7a		ply			ply
.1df7	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dfa					X16_Audio_PSGPLAY:
.1dfa	fa		plx				plx
.1dfb	5a		phy			phy
.1dfc	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_String
.1dff	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e02	18 c0					.word	X16A_bas_psgplaystring
>1e04	0a					.byte	X16_AudioCodeBank
.1e05	a2 ff		ldx #$ff		ldx	#$FF
.1e07	7a		ply			ply
.1e08	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e0b					X16_Audio_PSGCHORD:
.1e0b	fa		plx				plx
.1e0c	5a		phy			phy
.1e0d	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_String
.1e10	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e13	90 c0					.word	X16A_bas_psgchordstring
>1e15	0a					.byte	X16_AudioCodeBank
.1e16	a2 ff		ldx #$ff		ldx	#$FF
.1e18	7a		ply			ply
.1e19	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e1c					CommandCls:
.1e1c	fa		plx				plx
.1e1d	a9 93		lda #$93			lda 	#147
.1e1f	20 73 1c	jsr $1c73			jsr 	XPrintCharacterToChannel
.1e22	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e25					CommandLocate:
.1e25	fa		plx				plx
.1e26	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.1e29	ca		dex				dex
.1e2a	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.1e2d	ca		dex				dex
.1e2e	a9 13		lda #$13			lda 	#$13 						; home.
.1e30	20 73 1c	jsr $1c73			jsr 	XPrintCharacterToChannel
.1e33	a9 1d		lda #$1d			lda 	#$1D 						; do cursor rights
.1e35	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1e37	20 44 1e	jsr $1e44			jsr 	_CLOutputXA
.1e3a	a9 11		lda #$11			lda 	#$11 						; do cursor downs.
.1e3c	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e3e	20 44 1e	jsr $1e44			jsr 	_CLOutputXA
.1e41	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e44					_CLOutputXA:
.1e44	ca		dex				dex
.1e45	f0 07		beq $1e4e			beq 	_CLOExit
.1e47	30 05		bmi $1e4e			bmi 	_CLOExit
.1e49	20 73 1c	jsr $1c73			jsr 	XPrintCharacterToChannel
.1e4c	80 f6		bra $1e44			bra 	_CLOutputXA
.1e4e					_CLOExit:
.1e4e	60		rts				rts
.1e4f					CommandColor:
.1e4f	fa		plx				plx
.1e50	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.1e53	ca		dex				dex
.1e54	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.1e57	ca		dex				dex
.1e58	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1e5a	c9 ff		cmp #$ff			cmp 	#$FF
.1e5c	f0 08		beq $1e66			beq 	_CCNoBGR 					; if so, change background
.1e5e	20 6e 1e	jsr $1e6e			jsr 	_CCSetColour
.1e61	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1e63	20 73 1c	jsr $1c73			jsr 	XPrintCharacterToChannel
.1e66					_CCNoBGR:
.1e66	a5 3e		lda $3e				lda 	NSMantissa0
.1e68	20 6e 1e	jsr $1e6e			jsr 	_CCSetColour
.1e6b	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e6e					_CCSetColour:
.1e6e	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1e70	aa		tax				tax
.1e71	bd 78 1e	lda $1e78,x			lda 	_CCCommandTable,x
.1e74	20 73 1c	jsr $1c73			jsr 	XPrintCharacterToChannel
.1e77	60		rts				rts
.1e78					_CCCommandTable:
>1e78	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1e80	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1e88					CommandVPOKE:
.1e88	fa		plx				plx
.1e89	20 2e 10	jsr $102e			jsr 	GetInteger8Bit 				; poke value
.1e8c	48		pha				pha
.1e8d	ca		dex				dex
.1e8e	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.1e91	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1e93	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1e96	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1e98	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1e9b	ca		dex				dex
.1e9c	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.1e9f	20 2e 10	jsr $102e			jsr 	GetInteger8Bit
.1ea2	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1ea5	ca		dex				dex
.1ea6	68		pla				pla 								; poke value back
.1ea7	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1eaa	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ead					CommandVPEEK:
.1ead	fa		plx				plx
.1eae	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.1eb1	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1eb3	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1eb6	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1eb8	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ebb	ca		dex				dex
.1ebc	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.1ebf	20 2e 10	jsr $102e			jsr 	GetInteger8Bit
.1ec2	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1ec5	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1ec8	20 3d 26	jsr $263d			jsr 	FloatSetByte 				; return as byte
.1ecb	4c 4f 08	jmp $084f			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1ece					SetErrorHandler:
.1ece	8c 6f 05	sty $056f			sty 	ErrorHandlerVector+1
.1ed1	8e 6e 05	stx $056e			stx 	ErrorHandlerVector
.1ed4	60		rts				rts
.1ed5					CallErrorHandler:
.1ed5	6c 6e 05	jmp ($056e)			jmp 	(ErrorHandlerVector)
.056e					ErrorHandlerVector:
>056e							.fill 	2
.1ed8					ErrorV_range:
.1ed8	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1edb	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1ee3	41 4e 47 45 00
.1ee8					ErrorV_value:
.1ee8	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1eeb	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1ef3	45 00
.1ef5					ErrorV_syntax:
.1ef5	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1ef8	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f00	52 52 4f 52 00
.1f05					ErrorV_type:
.1f05	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1f08	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f10	4d 41 54 43 48 00
.1f16					ErrorV_unimplemented:
.1f16	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1f19	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f21	45 4d 45 4e 54 45 44 00
.1f29					ErrorV_assert:
.1f29	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1f2c	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f34	41 49 4c 00
.1f38					ErrorV_line:
.1f38	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1f3b	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f43	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f4f					ErrorV_internal:
.1f4f	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1f52	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f5a	20 45 52 52 4f 52 00
.1f61					ErrorV_divzero:
.1f61	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1f64	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1f6c	59 20 5a 45 52 4f 00
.1f73					ErrorV_structure:
.1f73	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1f76	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1f7e	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1f8a					ErrorV_stop:
.1f8a	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1f8d	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1f95	53 54 4f 50 50 45 44 00
.1f9d					ErrorV_data:
.1f9d	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1fa0	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fa8	41 54 41 00
.1fac					ErrorV_undeclared:
.1fac	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1faf	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1fb7	41 52 52 41 59 00
.1fbd					ErrorV_redefine:
.1fbd	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1fc0	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1fc8	44 45 46 49 4e 45 44 00
.1fd0					ErrorV_index:
.1fd0	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1fd3	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1fdb	59 20 49 4e 44 45 58 00
.1fe3					ErrorV_memory:
.1fe3	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1fe6	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>1fee	45 4d 4f 52 59 00
.1ff4					ErrorV_channel:
.1ff4	20 d5 1e	jsr $1ed5		jsr	CallErrorHandler
>1ff7	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>1fff	54 50 55 54 20 45 52 52 4f 52 00
.200a					MoveObjectForward:
.200a	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.200c	c9 ff		cmp #$ff			cmp 	#$FF
.200e	f0 36		beq $2046			beq 	_MOFEnd
.2010	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.2012	90 24		bcc $2038			bcc 	_MOFAdvance1 				; forward 1
.2014	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.2016	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2018	90 20		bcc $203a			bcc 	_MOFAdvanceY
.201a	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.201c	90 1a		bcc $2038			bcc 	_MOFAdvance1 				; forward 1
.201e	a8		tay				tay 								; read the size.
.201f	b9 84 1f	lda $1f84,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.2022	a8		tay				tay
.2023	c8		iny				iny 								; add 1 for the system token.
.2024	d0 14		bne $203a			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2026	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2028	b1 2a		lda ($2a),y			lda 	(objPtr),y
.202a	a8		tay				tay 								; into Y.
.202b	18		clc				clc
.202c	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.202e	69 02		adc #$02			adc 	#2
.2030	85 2a		sta $2a				sta 	objPtr
.2032	90 02		bcc $2036			bcc 	_MOFNoCarry1
.2034	e6 2b		inc $2b				inc 	objPtr+1
.2036					_MOFNoCarry1:
.2036	80 02		bra $203a			bra 	_MOFAdvanceY
.2038					_MOFAdvance1:
.2038	a0 01		ldy #$01			ldy 	#1
.203a					_MOFAdvanceY:
.203a	98		tya				tya 								; add Y to objPtr
.203b	18		clc				clc
.203c	65 2a		adc $2a				adc 	objPtr
.203e	85 2a		sta $2a				sta 	objPtr
.2040	90 02		bcc $2044			bcc 	_MOFNoCarry2
.2042	e6 2b		inc $2b				inc 	objPtr+1
.2044					_MOFNoCarry2:
.2044	18		clc				clc 								; not completed.
.2045	60		rts				rts
.2046					_MOFEnd:
.2046	e6 2a		inc $2a				inc 	objPtr
.2048	d0 02		bne $204c			bne 	_MOFENoCarry
.204a	e6 2b		inc $2b				inc 	objPtr+1
.204c					_MOFENoCarry:
.204c	38		sec				sec
.204d	60		rts				rts
.204e					MOFSizeTable:
>204e	01					.byte	1         	; $ca .shift
>204f	01					.byte	1         	; $cb .byte
>2050	02					.byte	2         	; $cc .word
>2051	05					.byte	5         	; $cd .float
>2052	ff					.byte	255       	; $ce .string
>2053	ff					.byte	255       	; $cf .data
>2054	02					.byte	2         	; $d0 .goto
>2055	02					.byte	2         	; $d1 .gosub
>2056	02					.byte	2         	; $d2 .goto.z
>2057	02					.byte	2         	; $d3 .goto.nz
>2058	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0570					numberBuffer:
>0570							.fill 	34
.2059					FloatSubtract:
.2059	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.205b	49 80		eor #$80			eor 	#$80
.205d	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.205f					FloatAdd:
.205f	ca		dex				dex
.2060	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.2062	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2064	15 62		ora $62,x			ora 	NSMantissa3,x
.2066	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2068	d0 04		bne $206e			bne 	_FAUseFloat
.206a	20 fb 23	jsr $23fb			jsr 	FloatInt32Add 				; use the int32 one.
.206d	60		rts				rts
.206e					_FAUseFloat:
.206e	20 90 23	jsr $2390			jsr 	FloatNormalise 				; normalise S[X]
.2071	f0 51		beq $20c4			beq 	_FAReturn1
.2073	e8		inx				inx 								; normalise S[X+1]
.2074	20 90 23	jsr $2390			jsr 	FloatNormalise
.2077	ca		dex				dex
.2078	c9 00		cmp #$00			cmp 	#0
.207a	f0 60		beq $20dc			beq 	_FAExit 					; if so, just return A
.207c	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.207e	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.2080	f0 18		beq $209a			beq 	_FAExponentsEqual
.2082	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.2084	a8		tay				tay
.2085	38		sec				sec 								; do a signed comparison of the exponents.
.2086	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.2088	50 02		bvc $208c			bvc 	_FANoSignedChange
.208a	49 80		eor #$80			eor 	#$80
.208c					_FANoSignedChange:
.208c	29 80		and #$80			and 	#$80
.208e	10 02		bpl $2092			bpl 	_FAHaveMax
.2090	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.2092					_FAHaveMax:
.2092	20 dd 20	jsr $20dd			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.2095	e8		inx				inx
.2096	20 dd 20	jsr $20dd			jsr 	_FAShiftToExponent
.2099	ca		dex				dex
.209a					_FAExponentsEqual:
.209a	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.209c	55 33		eor $33,x			eor 	NSStatus+1,x
.209e	30 0e		bmi $20ae			bmi 	_FADifferentSigns
.20a0	20 c7 23	jsr $23c7			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20a3	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20a5	10 35		bpl $20dc			bpl 	_FAExit 					; if no, we are done.
.20a7	20 54 26	jsr $2654			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20aa	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.20ac	80 2e		bra $20dc			bra 	_FAExit
.20ae					_FADifferentSigns:
.20ae	20 e1 23	jsr $23e1			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20b1	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.20b3	10 06		bpl $20bb			bpl 	_FACheckZero 				; if no, check for -0
.20b5	20 fd 25	jsr $25fd			jsr 	FloatNegate 					; netate result
.20b8	20 04 26	jsr $2604			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20bb					_FACheckZero:
.20bb	20 5d 26	jsr $265d			jsr 	FloatIsZero	 				; check for -0
.20be	d0 1c		bne $20dc			bne 	_FAExit
.20c0	74 32		stz $32,x			stz 	NSStatus,x
.20c2	80 18		bra $20dc			bra 	_FAExit
.20c4					_FAReturn1:
.20c4	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20c6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20c8	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.20ca	95 4a		sta $4a,x			sta 	NSMantissa1,x
.20cc	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.20ce	95 56		sta $56,x			sta 	NSMantissa2,x
.20d0	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.20d2	95 62		sta $62,x			sta 	NSMantissa3,x
.20d4	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.20d6	95 6e		sta $6e,x			sta 	NSExponent,x
.20d8	b5 33		lda $33,x			lda 	NSStatus+1,x
.20da	95 32		sta $32,x			sta 	NSStatus,x
.20dc					_FAExit:
.20dc	60		rts				rts
.20dd					_FAShiftToExponent:
.20dd					_FAShiftToExponent2:
.20dd	98		tya				tya 								; compare Y to exponent
.20de	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.20e0	f0 07		beq $20e9			beq 	_FASEExit 					; exit if so.
.20e2	20 54 26	jsr $2654			jsr 	FloatShiftRight	 			; shift the mantissa right
.20e5	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.20e7	80 f4		bra $20dd			bra 	_FAShiftToExponent2
.20e9					_FASEExit:
.20e9	60		rts				rts
.20ea					CompareEqual:
.20ea	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20ec	d0 09		bne $20f7			bne 	ReturnFalse
.20ee					ReturnTrue:
.20ee	a9 01		lda #$01			lda 	#1
.20f0	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20f2	a9 80		lda #$80			lda 	#$80
.20f4	95 32		sta $32,x			sta 	NSStatus,x
.20f6	60		rts				rts
.20f7					ReturnFalse:
.20f7	74 3e		stz $3e,x			stz 	NSMantissa0,x
.20f9	60		rts				rts
.20fa					CompareNotEqual:
.20fa	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.20fc	d0 f0		bne $20ee			bne 	ReturnTrue
.20fe	80 f7		bra $20f7			bra 	ReturnFalse
.2100					CompareLess:
.2100	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2102	c9 ff		cmp #$ff			cmp 	#$FF
.2104	f0 e8		beq $20ee			beq 	ReturnTrue
.2106	80 ef		bra $20f7			bra 	ReturnFalse
.2108					CompareGreater:
.2108	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.210a	c9 01		cmp #$01			cmp 	#$01
.210c	f0 e0		beq $20ee			beq 	ReturnTrue
.210e	80 e7		bra $20f7			bra 	ReturnFalse
.2110					CompareLessEqual:
.2110	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2112	c9 01		cmp #$01			cmp 	#$01
.2114	d0 d8		bne $20ee			bne 	ReturnTrue
.2116	80 df		bra $20f7			bra 	ReturnFalse
.2118					CompareGreaterEqual:
.2118	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.211a	c9 ff		cmp #$ff			cmp 	#$FF
.211c	d0 d0		bne $20ee			bne 	ReturnTrue
.211e	80 d7		bra $20f7			bra 	ReturnFalse
.2120					FloatCompare:
.2120	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.2122	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.2124	48		pha				pha
.2125	20 59 20	jsr $2059			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2128	68		pla				pla
.2129	d0 0c		bne $2137			bne 	_FCCompareFloat
.212b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.212d	15 4a		ora $4a,x			ora 	NSMantissa1,x
.212f	15 56		ora $56,x			ora 	NSMantissa2,x
.2131	15 62		ora $62,x			ora 	NSMantissa3,x
.2133	f0 14		beq $2149			beq 	_FCExit 					; if zero, return zero
.2135	80 0a		bra $2141			bra 	_FCSign
.2137					_FCCompareFloat:
.2137	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2139	29 f0		and #$f0			and 	#$F0
.213b	15 56		ora $56,x			ora 	NSMantissa2,x
.213d	15 62		ora $62,x			ora 	NSMantissa3,x
.213f	f0 08		beq $2149			beq 	_FCExit 					; zero, so approximately identical
.2141					_FCSign:
.2141	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2143	34 32		bit $32,x			bit 	NSStatus,x
.2145	10 02		bpl $2149			bpl 	_FCExit
.2147					_FCNegative:
.2147	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2149					_FCExit:
.2149	20 3d 26	jsr $263d			jsr 	FloatSetByte 				; set the result 255,0,1
.214c	60		rts				rts
.214d					FloatScalarTable:
>214d	66 66 66 66				.dword $66666666 ; 0.1
>2151	de					.byte $de
>2152	1f 85 eb 51				.dword $51eb851f ; 0.01
>2156	db					.byte $db
>2157	4c 37 89 41				.dword $4189374c ; 0.001
>215b	d8					.byte $d8
>215c	ac 8b db 68				.dword $68db8bac ; 0.0001
>2160	d4					.byte $d4
>2161	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>2165	d1					.byte $d1
>2166	83 de 1b 43				.dword $431bde83 ; 1e-06
>216a	ce					.byte $ce
>216b	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>216f	ca					.byte $ca
>2170	89 3b e6 55				.dword $55e63b89 ; 1e-08
>2174	c7					.byte $c7
>2175	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>2179	c4					.byte $c4
>217a	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>217e	c0					.byte $c0
>217f	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>2183	bd					.byte $bd
.2184					FloatDivide:
.2184	48		pha				pha
.2185	20 90 23	jsr $2390			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2188	ca		dex				dex
.2189	c9 00		cmp #$00			cmp 	#0
.218b	f0 1e		beq $21ab			beq 	_FDZero
.218d	20 90 23	jsr $2390			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2190	f0 16		beq $21a8			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.2192	20 f3 21	jsr $21f3			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.2195	20 c0 21	jsr $21c0			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.2198	20 90 23	jsr $2390			jsr		FloatNormalise 				; renormalise
.219b	20 86 23	jsr $2386			jsr 	FloatCalculateSign 			; calculate result sign
.219e	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.21a0	38		sec				sec
.21a1	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.21a3	38		sec				sec
.21a4	e9 1e		sbc #$1e			sbc 	#30
.21a6	95 6e		sta $6e,x			sta 	NSExponent,x
.21a8					_FDExit:
.21a8	68		pla				pla
.21a9	18		clc				clc
.21aa	60		rts				rts
.21ab					_FDZero:
.21ab	68		pla				pla
.21ac	38		sec				sec
.21ad	60		rts				rts
.21ae					DivideInt32:
.21ae	20 76 22	jsr $2276			jsr 	FloatIntegerPart 			; make both integers
.21b1	ca		dex				dex
.21b2	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.21b5	20 d1 21	jsr $21d1			jsr 	Int32Divide 				; divide
.21b8	20 c0 21	jsr $21c0			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21bb	20 86 23	jsr $2386			jsr 	FloatCalculateSign 			; calculate result sign
.21be	18		clc				clc
.21bf	60		rts				rts
.21c0					NSMCopyPlusTwoToZero:
.21c0	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21c2	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21c4	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21c6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.21c8	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.21ca	95 56		sta $56,x			sta 	NSMantissa2,x
.21cc	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.21ce	95 62		sta $62,x			sta 	NSMantissa3,x
.21d0	60		rts				rts
.21d1					Int32Divide:
.21d1	48		pha				pha 								; save AXY
.21d2	5a		phy				phy
.21d3	20 1e 26	jsr $261e			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.21d6	20 37 26	jsr $2637			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.21d9	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.21db					_I32DivideLoop:
.21db	e8		inx				inx
.21dc	e8		inx				inx
.21dd	20 4a 26	jsr $264a			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.21e0	ca		dex				dex
.21e1	ca		dex				dex
.21e2	20 4b 26	jsr $264b			jsr 	FloatRotateLeft
.21e5	20 11 22	jsr $2211			jsr 	FloatDivideCheck 			; check if subtract possible
.21e8	90 02		bcc $21ec			bcc 	_I32DivideNoCarryIn
.21ea	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.21ec					_I32DivideNoCarryIn:
.21ec	88		dey				dey 								; loop round till division completed.
.21ed	d0 ec		bne $21db			bne 	_I32DivideLoop
.21ef	7a		ply				ply 								; restore AXY and exit
.21f0	68		pla				pla
.21f1	18		clc				clc
.21f2	60		rts				rts
.21f3					Int32ShiftDivide:
.21f3	48		pha				pha 								; save AY
.21f4	5a		phy				phy
.21f5	e8		inx				inx 								; clear S[X+2]
.21f6	e8		inx				inx
.21f7	20 3b 26	jsr $263b			jsr 	FloatSetZero
.21fa	ca		dex				dex
.21fb	ca		dex				dex
.21fc	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.21fe					_I32SDLoop:
.21fe	20 11 22	jsr $2211			jsr 	FloatDivideCheck 			; check if subtract possible
.2201	e8		inx				inx
.2202	e8		inx				inx
.2203	20 4b 26	jsr $264b			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.2206	ca		dex				dex
.2207	ca		dex				dex
.2208	20 4b 26	jsr $264b			jsr 	FloatRotateLeft
.220b	88		dey				dey 	 							; do 31 times
.220c	d0 f0		bne $21fe			bne 	_I32SDLoop
.220e	7a		ply				ply 								; restore AY and exit
.220f	68		pla				pla
.2210	60		rts				rts
.2211					FloatDivideCheck:
.2211	20 e1 23	jsr $23e1			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.2214	b0 04		bcs $221a			bcs 	_DCSExit 					; if carry set, then could do, exit
.2216	20 c7 23	jsr $23c7			jsr 	FloatAddTopTwoStack 		; add it back in
.2219	18		clc				clc 								; and return False
.221a					_DCSExit:
.221a	60		rts				rts
.221b					FloatFractionalPart:
.221b	5a		phy				phy
.221c	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.221e	29 7f		and #$7f			and 	#$7F
.2220	95 32		sta $32,x			sta 	NSStatus,x
.2222	20 90 23	jsr $2390			jsr 	FloatNormalise
.2225	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2227	38		sec				sec
.2228	e9 e0		sbc #$e0			sbc 	#$E0
.222a	90 29		bcc $2255			bcc 	_FFPExit 					; already fractional
.222c	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.222e	b0 22		bcs $2252			bcs 	_FFPZero
.2230	a8		tay				tay 								; put count to do in Y
.2231	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.2233	20 5a 22	jsr $225a			jsr 	_FFPPartial
.2236	95 62		sta $62,x			sta 	NSMantissa3,x
.2238	b5 56		lda $56,x			lda 	NSMantissa2,x
.223a	20 5a 22	jsr $225a			jsr 	_FFPPartial
.223d	95 56		sta $56,x			sta 	NSMantissa2,x
.223f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2241	20 5a 22	jsr $225a			jsr 	_FFPPartial
.2244	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2246	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2248	20 5a 22	jsr $225a			jsr 	_FFPPartial
.224b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.224d	20 5d 26	jsr $265d			jsr 	FloatIsZero 					; zeroed check.
.2250	d0 03		bne $2255			bne 	_FFPExit
.2252					_FFPZero:
.2252	20 3b 26	jsr $263b			jsr 	FloatSetZero
.2255					_FFPExit:
.2255	20 90 23	jsr $2390			jsr 	FloatNormalise
.2258	7a		ply				ply
.2259	60		rts				rts
.225a					_FFPPartial:
.225a	c0 00		cpy #$00			cpy 	#0 							; no more to do
.225c	f0 17		beq $2275			beq 	_FFFPPExit
.225e	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.2260	b0 0c		bcs $226e			bcs 	_FFFPPWholeByte
.2262	5a		phy				phy
.2263					_FFFPPLeft:
.2263	0a		asl a				asl 	a
.2264	88		dey				dey
.2265	d0 fc		bne $2263			bne 	_FFFPPLeft
.2267	7a		ply				ply
.2268					_FFFPPRight:
.2268	4a		lsr a				lsr 	a
.2269	88		dey				dey
.226a	d0 fc		bne $2268			bne 	_FFFPPRight
.226c	80 07		bra $2275			bra 	_FFFPPExit
.226e					_FFFPPWholeByte:
.226e	98		tya				tya 								; subtract 8 from count
.226f	38		sec				sec
.2270	e9 08		sbc #$08			sbc 	#8
.2272	a8		tay				tay
.2273	a9 00		lda #$00			lda 	#0 							; and clear all
.2275					_FFFPPExit:
.2275	60		rts				rts
.2276					FloatIntegerPart:
.2276	48		pha				pha
.2277	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.2279	f0 1d		beq $2298			beq 	_FIPExit 					; if so do nothing
.227b	20 5d 26	jsr $265d			jsr 	FloatIsZero 				; is it zero ?
.227e	f0 15		beq $2295			beq 	_FIPZero 					; if so return zero.
.2280	20 90 23	jsr $2390			jsr 	FloatNormalise 				; normalise
.2283	f0 10		beq $2295			beq 	_FIPZero 					; normalised to zero, exit zero
.2285					_FIPShift:
.2285	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.2287	10 07		bpl $2290			bpl 	_FIPCheckZero
.2289	20 54 26	jsr $2654			jsr 	FloatShiftRight 			; shift mantissa right
.228c	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.228e	80 f5		bra $2285			bra 	_FIPShift
.2290					_FIPCheckZero:
.2290	20 5d 26	jsr $265d			jsr 	FloatIsZero 				; avoid -0 problem
.2293	d0 03		bne $2298			bne 	_FIPExit 					; set to zero if mantissa zero.
.2295					_FIPZero:
.2295	20 3b 26	jsr $263b			jsr 	FloatSetZero
.2298					_FIPExit:
.2298	68		pla				pla
.2299	60		rts				rts
.229a					FloatIntegerPartDown:
.229a	48		pha				pha
.229b	5a		phy				phy
.229c	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.229e	f0 36		beq $22d6			beq 	_FIPExit 					; if so do nothing
.22a0	20 5d 26	jsr $265d			jsr 	FloatIsZero 				; is it zero ?
.22a3	f0 2e		beq $22d3			beq 	_FIPZero 					; if so return zero.
.22a5	20 90 23	jsr $2390			jsr 	FloatNormalise 				; normalise
.22a8	f0 29		beq $22d3			beq 	_FIPZero 					; normalised to zero, exit zero
.22aa	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22ac					_FIPShift:
.22ac	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22ae	10 0a		bpl $22ba			bpl 	_FIPCheckDown
.22b0	20 54 26	jsr $2654			jsr 	FloatShiftRight 			; shift mantissa right
.22b3	90 01		bcc $22b6			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22b5	c8		iny				iny
.22b6					_FIPNoFrac:
.22b6	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22b8	80 f2		bra $22ac			bra 	_FIPShift
.22ba					_FIPCheckDown:
.22ba	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22bc	f0 10		beq $22ce			beq 	_FIPCheckZero
.22be	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22c0	10 0c		bpl $22ce			bpl 	_FIPCheckZero
.22c2	e8		inx				inx 								; -ve so round *down*.
.22c3	a9 01		lda #$01			lda 	#1
.22c5	20 3d 26	jsr $263d			jsr 	FloatSetByte
.22c8	20 fd 25	jsr $25fd			jsr 	FloatNegate
.22cb	20 5f 20	jsr $205f			jsr 	FloatAdd
.22ce					_FIPCheckZero:
.22ce	20 5d 26	jsr $265d			jsr 	FloatIsZero 				; avoid -0 problem
.22d1	d0 03		bne $22d6			bne 	_FIPExit 					; set to zero if mantissa zero.
.22d3					_FIPZero:
.22d3	20 3b 26	jsr $263b			jsr 	FloatSetZero
.22d6					_FIPExit:
.22d6	7a		ply				ply
.22d7	68		pla				pla
.22d8	60		rts				rts
.22d9					FloatInt8Multiply:
.22d9	5a		phy				phy
.22da	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.22dc	a8		tay				tay
.22dd	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.22df					_FI8MLoop:
.22df	98		tya				tya 								; shift right shifter right into carry
.22e0	4a		lsr a				lsr 	a
.22e1	a8		tay				tay
.22e2	90 0d		bcc $22f1			bcc 	_FI8MNoAdd
.22e4	18		clc				clc
.22e5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.22e7	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.22e9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.22eb	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.22ed	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.22ef	95 4a		sta $4a,x			sta 	NSMantissa1,x
.22f1					_FI8MNoAdd:
.22f1	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.22f3	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.22f5	c0 00		cpy #$00			cpy 	#0
.22f7	d0 e6		bne $22df			bne 	_FI8MLoop 					; until right shifter zero.
.22f9	7a		ply				ply
.22fa	60		rts				rts
.22fb					FloatMultiply:
.22fb	ca		dex				dex
.22fc	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.22fe	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2300	15 62		ora $62,x			ora 	NSMantissa3,x
.2302	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2304	d0 21		bne $2327			bne 	_FMUseFloat
.2306	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2308	15 33		ora $33,x			ora 	NSStatus+1,x
.230a	29 80		and #$80			and 	#$80
.230c	15 62		ora $62,x			ora 	NSMantissa3,x
.230e	15 56		ora $56,x			ora 	NSMantissa2,x
.2310	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2312	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2314	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2316	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2318	d0 04		bne $231e			bne 	_FMInt32
.231a	20 d9 22	jsr $22d9			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.231d	60		rts				rts
.231e					_FMInt32:
.231e	20 48 23	jsr $2348			jsr 	FloatMultiplyShort			; use the int32 one.
.2321	18		clc				clc 								; fix it up if gone out of range
.2322	75 6e		adc $6e,x			adc 	NSExponent,x
.2324	95 6e		sta $6e,x			sta 	NSExponent,x
.2326	60		rts				rts
.2327					_FMUseFloat:
.2327	20 90 23	jsr $2390			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.232a	f0 18		beq $2344			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.232c	e8		inx				inx
.232d	20 90 23	jsr $2390			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2330	ca		dex				dex
.2331	c9 00		cmp #$00			cmp 	#0
.2333	f0 0c		beq $2341			beq 	_FDSetZero
.2335	20 48 23	jsr $2348			jsr 	FloatMultiplyShort 			; calculate the result.
.2338	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.233a	18		clc				clc
.233b	75 6f		adc $6f,x			adc 	NSExponent+1,x
.233d	95 6e		sta $6e,x			sta 	NSExponent,x
.233f	80 03		bra $2344			bra 	_FDExit
.2341					_FDSetZero:
.2341	20 3b 26	jsr $263b			jsr 	FloatSetZero 				; return 0
.2344					_FDExit:
.2344	20 90 23	jsr $2390			jsr 	FloatNormalise 				; normalise the result
.2347	60		rts				rts
.2348					FloatMultiplyShort:
.2348	5a		phy				phy 								; save Y
.2349	20 1e 26	jsr $261e			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.234c	20 37 26	jsr $2637			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.234f	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.2351					_I32MLoop:
.2351	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.2353	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.2355	15 58		ora $58,x			ora 	NSMantissa2+2,x
.2357	15 64		ora $64,x			ora 	NSMantissa3+2,x
.2359	f0 25		beq $2380			beq 	_I32MExit 					; exit if zero
.235b	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.235d	29 01		and #$01			and 	#1
.235f	f0 0d		beq $236e			beq 	_I32MNoAdd
.2361	20 c7 23	jsr $23c7			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.2364	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.2366	10 06		bpl $236e			bpl 	_I32MNoAdd
.2368					_I32ShiftRight:
.2368	20 54 26	jsr $2654			jsr 	FloatShiftRight 			; shift S[X] right
.236b	c8		iny				iny 								; increment shift count
.236c	80 09		bra $2377			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.236e					_I32MNoAdd:
.236e	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.2370	70 f6		bvs $2368			bvs 	_I32ShiftRight 				; instead.
.2372	e8		inx				inx
.2373	20 4a 26	jsr $264a			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.2376	ca		dex				dex
.2377					_I32MShiftUpper:
.2377	e8		inx				inx 								; shift S[X+2] right
.2378	e8		inx				inx
.2379	20 54 26	jsr $2654			jsr 	FloatShiftRight
.237c	ca		dex				dex
.237d	ca		dex				dex
.237e	80 d1		bra $2351			bra 	_I32MLoop 					; try again.
.2380					_I32MExit:
.2380	20 86 23	jsr $2386			jsr 	FloatCalculateSign
.2383	98		tya				tya 								; shift in A
.2384	7a		ply				ply 								; restore Y and exit
.2385	60		rts				rts
.2386					FloatCalculateSign:
.2386	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.2388	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.238a	55 33		eor $33,x			eor 	NSStatus+1,x
.238c	0a		asl a				asl 	a 							; shift bit 7 into carry
.238d	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.238f	60		rts				rts
.2390					FloatNormalise:
.2390	20 5d 26	jsr $265d			jsr 	FloatIsZero 				; if zero exit
.2393	d0 07		bne $239c			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.2395	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.2397	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.2399	a9 00		lda #$00			lda 	#0 							; set Z flag
.239b	60		rts				rts
.239c					_NSNormaliseOptimise:
.239c	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.239e	d0 19		bne $23b9			bne 	_NSNormaliseLoop
.23a0	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.23a2	30 15		bmi $23b9			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23a4	95 62		sta $62,x			sta 	NSMantissa3,x
.23a6	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.23a8	95 56		sta $56,x			sta 	NSMantissa2,x
.23aa	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.23ac	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23ae	74 3e		stz $3e,x			stz 	NSMantissa0,x
.23b0	b5 6e		lda $6e,x			lda 	NSExponent,x
.23b2	38		sec				sec
.23b3	e9 08		sbc #$08			sbc 	#8
.23b5	95 6e		sta $6e,x			sta 	NSExponent,x
.23b7	80 e3		bra $239c			bra 	_NSNormaliseOptimise
.23b9					_NSNormaliseLoop:
.23b9	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23bb	70 07		bvs $23c4			bvs 	_NSNExit 					; exit if so with Z flag clear
.23bd	20 4a 26	jsr $264a			jsr 	FloatShiftLeft 				; shift mantissa left
.23c0	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23c2	80 f5		bra $23b9			bra 	_NSNormaliseLoop
.23c4					_NSNExit:
.23c4	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23c6	60		rts				rts
.23c7					FloatAddTopTwoStack:
.23c7	18		clc				clc
.23c8	b5 3e		lda $3e,x			lda		NSMantissa0,x
.23ca	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.23cc	95 3e		sta $3e,x			sta 	NSMantissa0,x
.23ce	b5 4a		lda $4a,x			lda		NSMantissa1,x
.23d0	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.23d2	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23d4	b5 56		lda $56,x			lda		NSMantissa2,x
.23d6	75 57		adc $57,x			adc 		NSMantissa2+1,x
.23d8	95 56		sta $56,x			sta 	NSMantissa2,x
.23da	b5 62		lda $62,x			lda		NSMantissa3,x
.23dc	75 63		adc $63,x			adc 		NSMantissa3+1,x
.23de	95 62		sta $62,x			sta 	NSMantissa3,x
.23e0	60		rts				rts
.23e1					FloatSubTopTwoStack:
.23e1	38		sec				sec
.23e2	b5 3e		lda $3e,x			lda		NSMantissa0,x
.23e4	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.23e6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.23e8	b5 4a		lda $4a,x			lda		NSMantissa1,x
.23ea	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.23ec	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23ee	b5 56		lda $56,x			lda		NSMantissa2,x
.23f0	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.23f2	95 56		sta $56,x			sta 	NSMantissa2,x
.23f4	b5 62		lda $62,x			lda		NSMantissa3,x
.23f6	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.23f8	95 62		sta $62,x			sta 	NSMantissa3,x
.23fa	60		rts				rts
.23fb					FloatInt32Add:
.23fb	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.23fd	55 33		eor $33,x			eor 	NSStatus+1,x
.23ff	30 04		bmi $2405			bmi 	_DiffSigns
.2401	20 c7 23	jsr $23c7			jsr		FloatAddTopTwoStack
.2404	60		rts				rts
.2405					_DiffSigns:
.2405	20 e1 23	jsr $23e1			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2408	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.240a	10 07		bpl $2413			bpl 	_AddExit
.240c	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.240e	95 32		sta $32,x			sta 	NSStatus,x
.2410	20 04 26	jsr $2604			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2413					_AddExit:
.2413	20 5d 26	jsr $265d			jsr 	FloatIsZero 				; check for -0
.2416	d0 02		bne $241a			bne 	_AddNonZero
.2418	74 32		stz $32,x			stz 	NSStatus,x
.241a					_AddNonZero:
.241a	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.241b					FloatEncodeStart:
.241b	38		sec				sec
.241c	80 01		bra $241f			bra 	FloatEncodeContinue+1
.241e					FloatEncodeContinue:
.241e	18		clc				clc
.241f					FloatEncode:
.241f	08		php				php 								; save reset flag.
.2420	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.2422	f0 15		beq $2439			beq 	_ENIsOkay
.2424	c9 30		cmp #$30			cmp 	#"0"
.2426	90 04		bcc $242c			bcc 	_ENBadNumber
.2428	c9 3a		cmp #$3a			cmp 	#"9"+1
.242a	90 0d		bcc $2439			bcc 	_ENIsOkay
.242c					_ENBadNumber:
.242c	28		plp				plp 								; throw saved reset
.242d	ad 92 05	lda $0592			lda 	encodeState 				; if in decimal mode, construct final number
.2430	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2432	d0 03		bne $2437			bne 	_ENFail
.2434	4c b1 24	jmp $24b1			jmp 	_ENConstructFinal
.2437					_ENFail:
.2437	18		clc				clc 								; not allowed
.2438	60		rts				rts
.2439					_ENIsOkay:
.2439	28		plp				plp 								; are we restarting
.243a	90 15		bcc $2451			bcc 	_ENNoRestart
.243c					_ENStartEncode:
.243c	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.243e	f0 0c		beq $244c			beq 	_ENFirstDP
.2440	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.2442	20 3d 26	jsr $263d			jsr 	FloatSetByte 				; in single byte mode.
.2445	a9 01		lda #$01			lda 	#ESTA_Low
.2447					_ENExitChange:
.2447	8d 92 05	sta $0592			sta 	encodeState 				; save new state
.244a	38		sec				sec
.244b	60		rts				rts
.244c					_ENFirstDP:
.244c	20 3b 26	jsr $263b			jsr 	FloatSetZero 				; clear integer part
.244f	80 3c		bra $248d			bra 	_ESTASwitchFloat			; go straight to float and exi
.2451					_ENNoRestart:
.2451	48		pha				pha 								; save digit or DP on stack.
.2452	ad 92 05	lda $0592			lda 	encodeState 				; get current state
.2455	c9 01		cmp #$01			cmp 	#ESTA_Low
.2457	f0 09		beq $2462			beq  	_ESTALowState
.2459	c9 02		cmp #$02			cmp 	#ESTA_High
.245b	f0 26		beq $2483			beq 	_ESTAHighState
.245d	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.245f	f0 38		beq $2499			beq 	_ESTADecimalState
>2461	db						.byte 	$DB 						; causes a break in the emulator
.2462					_ESTALowState:
.2462	68		pla				pla 								; get value back
.2463	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.2465	f0 26		beq $248d			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.2467	29 0f		and #$0f			and 	#15 						; make digit
.2469	8d 93 05	sta $0593			sta 	digitTemp 					; save it.
.246c	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.246e	0a		asl a				asl 	a
.246f	0a		asl a				asl 	a
.2470	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2472	0a		asl a				asl 	a
.2473	6d 93 05	adc $0593			adc 	digitTemp
.2476	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2478	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.247a	90 05		bcc $2481			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.247c	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.247e	8d 92 05	sta $0592			sta 	encodeState
.2481					_ESTANoSwitch:
.2481	38		sec				sec
.2482	60		rts				rts
.2483					_ESTAHighState:
.2483	68		pla				pla 								; get value back
.2484	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.2486	f0 05		beq $248d			beq 	_ESTASwitchFloat
.2488	20 e3 24	jsr $24e3			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.248b	38		sec				sec
.248c	60		rts				rts
.248d					_ESTASwitchFloat:
.248d	9c 94 05	stz $0594			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.2490	e8		inx				inx 								; zero the decimal additive.
.2491	20 3b 26	jsr $263b			jsr 	FloatSetZero
.2494	ca		dex				dex
.2495	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.2497	80 ae		bra $2447			bra 	_ENExitChange
.2499					_ESTADecimalState:
.2499	68		pla				pla 								; digit.
.249a	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.249c	f0 99		beq $2437			beq 	_ENFail
.249e	e8		inx				inx 								; put digit into fractional part of X+1
.249f	20 e3 24	jsr $24e3			jsr 	ESTAShiftDigitIntoMantissa
.24a2	ca		dex				dex
.24a3	ee 94 05	inc $0594			inc 	decimalCount 				; bump the count of decimals
.24a6	ad 94 05	lda $0594			lda 	decimalCount 				; too many decimal digits.
.24a9	c9 0b		cmp #$0b			cmp 	#11
.24ab	f0 02		beq $24af			beq 	_ESTADSFail
.24ad	38		sec				sec
.24ae	60		rts				rts
.24af					_ESTADSFail:
.24af	18		clc				clc
.24b0	60		rts				rts
.24b1					_ENConstructFinal:
.24b1	ad 94 05	lda $0594			lda 	decimalCount 				; get decimal count
.24b4	f0 2b		beq $24e1			beq 	_ENCFExit 					; no decimals
.24b6	5a		phy				phy
.24b7	0a		asl a				asl 	a 							; x 4 and CLC
.24b8	0a		asl a				asl 	a
.24b9	6d 94 05	adc $0594			adc 	decimalCount
.24bc	a8		tay				tay
.24bd	b9 48 21	lda $2148,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24c0	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24c2	b9 49 21	lda $2149,y			lda 	FloatScalarTable-5+1,y
.24c5	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.24c7	b9 4a 21	lda $214a,y			lda 	FloatScalarTable-5+2,y
.24ca	95 58		sta $58,x			sta 	NSMantissa2+2,x
.24cc	b9 4b 21	lda $214b,y			lda 	FloatScalarTable-5+3,y
.24cf	95 64		sta $64,x			sta 	NSMantissa3+2,x
.24d1	b9 4c 21	lda $214c,y			lda 	FloatScalarTable-5+4,y
.24d4	95 70		sta $70,x			sta 	NSExponent+2,x
.24d6	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.24d8	e8		inx				inx 								; multiply decimal const by decimal scalar
.24d9	e8		inx				inx
.24da	20 fb 22	jsr $22fb			jsr 	FloatMultiply
.24dd	20 5f 20	jsr $205f			jsr 	FloatAdd 					; add to integer part.
.24e0	7a		ply				ply
.24e1					_ENCFExit:
.24e1	18		clc				clc 								; reject the digit.
.24e2	60		rts				rts
.24e3					ESTAShiftDigitIntoMantissa:
.24e3	29 0f		and #$0f			and 	#15 						; save digit
.24e5	48		pha				pha
.24e6	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.24e8	48		pha				pha
.24e9	b5 56		lda $56,x			lda 	NSMantissa2,x
.24eb	48		pha				pha
.24ec	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.24ee	48		pha				pha
.24ef	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.24f1	48		pha				pha
.24f2	20 4a 26	jsr $264a			jsr 	FloatShiftLeft 				; x 2
.24f5	20 4a 26	jsr $264a			jsr 	FloatShiftLeft 				; x 4
.24f8	18		clc				clc 								; pop mantissa and add
.24f9	68		pla				pla
.24fa	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24fc	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24fe	68		pla				pla
.24ff	75 4a		adc $4a,x			adc 	NSMantissa1,x
.2501	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2503	68		pla				pla
.2504	75 56		adc $56,x			adc 	NSMantissa2,x
.2506	95 56		sta $56,x			sta 	NSMantissa2,x
.2508	68		pla				pla
.2509	75 62		adc $62,x			adc 	NSMantissa3,x
.250b	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.250d	20 4a 26	jsr $264a			jsr 	FloatShiftLeft 				; x 10
.2510	68		pla				pla 								; add digit
.2511	18		clc				clc
.2512	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2514	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2516	90 0a		bcc $2522			bcc 	_ESTASDExit
.2518	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.251a	d0 06		bne $2522			bne 	_ESTASDExit
.251c	f6 56		inc $56,x			inc 	NSMantissa2,x
.251e	d0 02		bne $2522			bne 	_ESTASDExit
.2520	f6 62		inc $62,x			inc 	NSMantissa3,x
.2522					_ESTASDExit:
.2522	60		rts				rts
.0592					encodeState:
>0592							.fill 	1
.0593					digitTemp:
>0593							.fill 	1
.0594					decimalCount:
>0594							.fill 	1
.2523					FloatToString:
.2523	da		phx				phx
.2524	5a		phy				phy 								; save code position
.2525	8d 95 05	sta $0595			sta 	decimalPlaces	 			; save number of DPs.
.2528	9c 96 05	stz $0596			stz 	dbOffset 					; offset into decimal buffer = start.
.252b	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.252d	10 08		bpl $2537			bpl 	_CNTSNotNegative
.252f	29 7f		and #$7f			and 	#$7F 						; make +ve
.2531	95 32		sta $32,x			sta 	NSStatus,x
.2533	a9 2d		lda #$2d			lda 	#"-"
.2535	80 02		bra $2539			bra 	_CNTMain
.2537					_CNTSNotNegative:
.2537	a9 20		lda #$20			lda 	#" "
.2539					_CNTMain:
.2539	20 9b 25	jsr $259b			jsr 	WriteDecimalBuffer
.253c	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.253e	f0 0d		beq $254d			beq 	_CNTSNotFloat
.2540	e8		inx				inx 								; round up so we don't get too many 6.999999
.2541	a9 01		lda #$01			lda 	#1
.2543	20 3d 26	jsr $263d			jsr 	FloatSetByte
.2546	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2548	95 6e		sta $6e,x			sta 	NSExponent,x
.254a	20 5f 20	jsr $205f			jsr 	FloatAdd
.254d					_CNTSNotFloat:
.254d	20 7d 25	jsr $257d			jsr 	MakePlusTwoString 			; do the integer part.
.2550	20 1b 22	jsr $221b			jsr 	FloatFractionalPart 		; get the fractional part
.2553	20 90 23	jsr $2390			jsr 	FloatNormalise					; normalise , exit if zero
.2556	f0 22		beq $257a			beq 	_CNTSExit
.2558	a9 2e		lda #$2e			lda 	#"."
.255a	20 9b 25	jsr $259b			jsr 	WriteDecimalBuffer 			; write decimal place
.255d					_CNTSDecimal:
.255d	ce 95 05	dec $0595			dec 	decimalPlaces 				; done all the decimals
.2560	30 18		bmi $257a			bmi 	_CNTSExit
.2562	e8		inx				inx 								; x 10.0
.2563	a9 0a		lda #$0a			lda 	#10
.2565	20 3d 26	jsr $263d			jsr 	FloatSetByte
.2568	20 fb 22	jsr $22fb			jsr 	FloatMultiply
.256b	20 7d 25	jsr $257d			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.256e	20 1b 22	jsr $221b			jsr 	FloatFractionalPart 		; get the fractional part
.2571	20 90 23	jsr $2390			jsr 	FloatNormalise 				; normalise it.
.2574	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.2576	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.2578	b0 e3		bcs $255d			bcs 	_CNTSDecimal 				; keep going.
.257a					_CNTSExit:
.257a	7a		ply				ply
.257b	fa		plx				plx
.257c	60		rts				rts
.257d					MakePlusTwoString:
.257d	da		phx				phx
.257e	20 1e 26	jsr $261e			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.2581	e8		inx				inx 								; access it
.2582	e8		inx				inx
.2583	20 76 22	jsr $2276			jsr 	FloatIntegerPart 			; make it an integer
.2586	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.2588	20 ba 25	jsr $25ba			jsr 	ConvertInt32
.258b	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.258d					_MPTSCopy:
.258d	bd 70 05	lda $0570,x			lda 	numberBuffer,x
.2590	20 9b 25	jsr $259b			jsr 	WriteDecimalBuffer
.2593	e8		inx				inx
.2594	bd 70 05	lda $0570,x			lda 	numberBuffer,x
.2597	d0 f4		bne $258d			bne 	_MPTSCopy
.2599	fa		plx				plx
.259a	60		rts				rts
.259b					WriteDecimalBuffer:
.259b	da		phx				phx
.259c	ae 96 05	ldx $0596			ldx 	dbOffset
.259f	9d 97 05	sta $0597,x			sta 	decimalBuffer,x
.25a2	9e 98 05	stz $0598,x			stz 	decimalBuffer+1,x
.25a5	ee 96 05	inc $0596			inc 	dbOffset
.25a8	fa		plx				plx
.25a9	60		rts				rts
.0595					decimalPlaces:
>0595							.fill 	1
.0596					dbOffset:
>0596							.fill 	1
.0597					decimalBuffer:
>0597							.fill 	32
.25aa					ConvertInt16:
.25aa	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.25ac	86 4a		stx $4a				stx 	NSMantissa1
.25ae	64 56		stz $56				stz 	NSMantissa2
.25b0	64 62		stz $62				stz 	NSMantissa3
.25b2	64 32		stz $32				stz 	NSStatus 					; positive integer
.25b4	a2 00		ldx #$00			ldx 	#0 							; stack level
.25b6	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25b8	80 00		bra $25ba			bra 	ConvertInt32
.25ba					ConvertInt32:
.25ba	5a		phy				phy
.25bb	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25bd	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25bf	10 08		bpl $25c9			bpl 	_CI32NotNeg
.25c1	48		pha				pha
.25c2	a9 2d		lda #$2d			lda 	#'-'
.25c4	99 70 05	sta $0570,y			sta 	numberBuffer,y
.25c7	c8		iny				iny
.25c8	68		pla				pla
.25c9					_CI32NotNeg:
.25c9	20 d7 25	jsr $25d7			jsr 	_CI32DivideConvert 			; recursive conversion
.25cc	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.25ce	99 70 05	sta $0570,y			sta 	numberBuffer,y
.25d1	7a		ply				ply
.25d2	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.25d4	a9 70		lda #$70			lda 	#numberBuffer & $FF
.25d6	60		rts				rts
.25d7					_CI32DivideConvert:
.25d7	e8		inx				inx 								; write to next slot up
.25d8	20 3d 26	jsr $263d			jsr 	FloatSetByte 		 		; write the base out.
.25db	ca		dex				dex
.25dc	20 d1 21	jsr $21d1			jsr 	Int32Divide 				; divide
.25df	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.25e1	48		pha				pha
.25e2	20 c0 21	jsr $21c0			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.25e5	20 5d 26	jsr $265d			jsr 	FloatIsZero 				; is it zero ?
.25e8	f0 05		beq $25ef			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.25ea	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.25ec	20 d7 25	jsr $25d7			jsr 	_CI32DivideConvert 			; and recusrively call.
.25ef					_CI32NoRecurse:
.25ef	68		pla				pla 								; remainder
.25f0	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.25f2	90 02		bcc $25f6			bcc 	_CI32NotHex
.25f4	69 26		adc #$26			adc 	#6+32
.25f6					_CI32NotHex:
.25f6	69 30		adc #$30			adc 	#48
.25f8	99 70 05	sta $0570,y			sta 	numberBuffer,y 				; write out and exit
.25fb	c8		iny				iny
.25fc	60		rts				rts
.25fd					FloatNegate:
.25fd	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.25ff	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.2601	95 32		sta $32,x			sta 	NSStatus,x
.2603	60		rts				rts
.2604					FloatNegateMantissa:
.2604	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2605	a9 00		lda #$00			lda 	#0
.2607	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2609	95 3e		sta $3e,x			sta 	NSMantissa0,x
.260b	a9 00		lda #$00			lda 	#0
.260d	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.260f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2611	a9 00		lda #$00			lda 	#0
.2613	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.2615	95 56		sta $56,x			sta 	NSMantissa2,x
.2617	a9 00		lda #$00			lda 	#0
.2619	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.261b	95 62		sta $62,x			sta 	NSMantissa3,x
.261d	60		rts				rts
.261e					FloatShiftUpTwo:
.261e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2620	95 40		sta $40,x			sta 	NSMantissa0+2,x
.2622	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2624	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2626	b5 56		lda $56,x			lda 	NSMantissa2,x
.2628	95 58		sta $58,x			sta 	NSMantissa2+2,x
.262a	b5 62		lda $62,x			lda 	NSMantissa3,x
.262c	95 64		sta $64,x			sta 	NSMantissa3+2,x
.262e	b5 6e		lda $6e,x			lda 	NSExponent,x
.2630	95 70		sta $70,x			sta 	NSExponent+2,x
.2632	b5 32		lda $32,x			lda 	NSStatus,x
.2634	95 34		sta $34,x			sta 	NSStatus+2,x
.2636	60		rts				rts
.2637					FloatSetZeroMantissaOnly:
.2637	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2639	80 08		bra $2643			bra 	FloatZero13
.263b					FloatSetZero:
.263b	a9 00		lda #$00			lda 	#0
.263d					FloatSetByte:
.263d	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.263f					FloatSetMantissa:
.263f	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.2641	74 32		stz $32,x			stz 	NSStatus,x
.2643					FloatZero13:
.2643	74 4a		stz $4a,x			stz 	NSMantissa1,x
.2645	74 56		stz $56,x			stz 	NSMantissa2,x
.2647	74 62		stz $62,x			stz 	NSMantissa3,x
.2649	60		rts				rts
.264a					FloatShiftLeft:
.264a	18		clc				clc
.264b					FloatRotateLeft:
.264b	36 3e		rol $3e,x			rol 	NSMantissa0,x
.264d	36 4a		rol $4a,x			rol		NSMantissa1,x
.264f	36 56		rol $56,x			rol		NSMantissa2,x
.2651	36 62		rol $62,x			rol		NSMantissa3,x
.2653	60		rts				rts
.2654					FloatShiftRight:
.2654	56 62		lsr $62,x			lsr 	NSMantissa3,x
.2656	76 56		ror $56,x			ror		NSMantissa2,x
.2658	76 4a		ror $4a,x			ror		NSMantissa1,x
.265a	76 3e		ror $3e,x			ror		NSMantissa0,x
.265c	60		rts				rts
.265d					FloatIsZero:
.265d	b5 62		lda $62,x			lda 	NSMantissa3,x
.265f	15 56		ora $56,x			ora		NSMantissa2,x
.2661	15 4a		ora $4a,x			ora		NSMantissa1,x
.2663	15 3e		ora $3e,x			ora		NSMantissa0,x
.2665	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.2666					FloatArcTan:
.2666	20 90 23	jsr $2390			jsr 	FloatNormalise 					; normalise x
.2669	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.266b	48		pha				pha
.266c	74 32		stz $32,x			stz 	NSStatus,x
.266e	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.2670	c9 e2		cmp #$e2			cmp 	#$E2
.2672	90 25		bcc $2699			bcc 	_UANoFixup
.2674	8a		txa				txa 									; value in +1
.2675	a8		tay				tay
.2676	c8		iny				iny
.2677	20 1f 28	jsr $281f			jsr 	CopyFloatXY
.267a	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.267c	20 3d 26	jsr $263d			jsr 	FloatSetByte
.267f	e8		inx				inx
.2680	20 84 21	jsr $2184			jsr 	FloatDivide
.2683	b0 21		bcs $26a6			bcs 	_FATError
.2685	20 a9 26	jsr $26a9			jsr 	CoreAtn 						; calculate the root
.2688	20 14 28	jsr $2814			jsr 	CompletePolynomial
.268b	20 fd 25	jsr $25fd			jsr 	FloatNegate 					; make -ve
.268e	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2690	20 6b 28	jsr $286b			jsr 	LoadConstant
.2693	e8		inx				inx
.2694	20 5f 20	jsr $205f			jsr 	FloatAdd
.2697	80 06		bra $269f			bra 	_UAComplete
.2699					_UANoFixup:
.2699	20 a9 26	jsr $26a9			jsr 	CoreAtn
.269c	20 14 28	jsr $2814			jsr 	CompletePolynomial
.269f					_UAComplete:
.269f	68		pla				pla 									; apply the result.
.26a0	55 32		eor $32,x			eor 	NSStatus,x
.26a2	95 32		sta $32,x			sta 	NSStatus,x
.26a4	18		clc				clc
.26a5	60		rts				rts
.26a6					_FATError:
.26a6	68		pla				pla
.26a7	38		sec				sec
.26a8	60		rts				rts
.26a9					CoreAtn:
.26a9	a9 17		lda #$17			lda 	#AtnCoefficients & $FF
.26ab	a0 27		ldy #$27			ldy 	#AtnCoefficients >> 8
.26ad	4c 68 29	jmp $2968			jmp 	CorePolySquared
.26b0					ExpCoefficients:
>26b0	07					.byte	7
>26b1	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>26b5	d2					.byte	$d2
>26b6	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>26ba	d5					.byte	$d5
>26bb	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>26bf	d8					.byte	$d8
>26c0	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>26c4	db					.byte	$db
>26c5	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>26c9	dd					.byte	$dd
>26ca	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>26ce	df					.byte	$df
>26cf	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>26d3	e1					.byte	$e1
>26d4	00 00 00 40				.dword	$40000000 ; 1.0
>26d8	e2					.byte	$e2
.26d9					SinCoefficients:
>26d9	06					.byte	6
>26da	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>26de	e5					.byte	$e5
>26df	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>26e3	e7					.byte	$e7
>26e4	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>26e8	e8					.byte	$e8
>26e9	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>26ed	e8					.byte	$e8
>26ee	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>26f2	e7					.byte	$e7
>26f3	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>26f7	e4					.byte	$e4
>26f8	00 00 00 00				.dword	$00000000 ; 0.0
>26fc	00					.byte	$00
.26fd					LogCoefficients:
>26fd	04					.byte	4
>26fe	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>2702	e0					.byte	$e0
>2703	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>2707	e1					.byte	$e1
>2708	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>270c	e1					.byte	$e1
>270d	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>2711	e3					.byte	$e3
>2712	00 00 00 c0				.dword	$c0000000 ; -0.5
>2716	e1					.byte	$e1
.2717					AtnCoefficients:
>2717	0c					.byte	12
>2718	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>271c	d7					.byte	$d7
>271d	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>2721	da					.byte	$da
>2722	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>2726	dc					.byte	$dc
>2727	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>272b	dd					.byte	$dd
>272c	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>2730	dd					.byte	$dd
>2731	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>2735	de					.byte	$de
>2736	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>273a	de					.byte	$de
>273b	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>273f	de					.byte	$de
>2740	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>2744	df					.byte	$df
>2745	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>2749	df					.byte	$df
>274a	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>274e	e0					.byte	$e0
>274f	00 00 00 40				.dword	$40000000 ; 1.0
>2753	e2					.byte	$e2
>2754	00 00 00 00				.dword	$00000000 ; 0.0
>2758	00					.byte	$00
.2759					Const_Base:
.2759					Const_1Div2Pi:
>2759	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>275d	df					.byte	$df
.275e					Const_PiDiv2:
>275e	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>2762	e2					.byte	$e2
.2763					Const_Log2_e:
>2763	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>2767	e2					.byte	$e2
.2768					Const_sqrt_2:
>2768	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>276c	e2					.byte	$e2
.276d					Const_sqrt_half:
>276d	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>2771	e1					.byte	$e1
.2772					Const_pi:
>2772	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>2776	e3					.byte	$e3
.2777					Const_half:
>2777	00 00 00 40				.dword	$40000000 ; 0.50000000
>277b	e1					.byte	$e1
.277c					Const_ln_e:
>277c	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>2780	e1					.byte	$e1
.2781					FloatCosine:
.2781	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.2783	20 6b 28	jsr $286b			jsr 	LoadConstant
.2786	e8		inx				inx
.2787	20 5f 20	jsr $205f			jsr 	FloatAdd
.278a	4c 21 29	jmp $2921			jmp 	FloatSine
.278d					FloatExponent:
.278d	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.278f	20 6b 28	jsr $286b			jsr 	LoadConstant
.2792	e8		inx				inx
.2793	20 fb 22	jsr $22fb			jsr 	FloatMultiply
.2796	20 d8 27	jsr $27d8			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.2799	e8		inx				inx
.279a	20 76 22	jsr $2276			jsr 	FloatIntegerPart
.279d	ca		dex				dex
.279e	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.27a0	15 57		ora $57,x			ora 	NSMantissa2+1,x
.27a2	15 63		ora $63,x			ora 	NSMantissa3+1,x
.27a4	d0 38		bne $27de			bne 	_UERangeError
.27a6	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.27a8	c9 40		cmp #$40			cmp 	#64
.27aa	b0 32		bcs $27de			bcs 	_UERangeError
.27ac	48		pha				pha
.27ad	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.27af	48		pha				pha
.27b0	20 1b 22	jsr $221b			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.27b3	68		pla				pla
.27b4	10 14		bpl $27ca			bpl 	_UEPositive
.27b6	e8		inx				inx 							; 1-x
.27b7	a9 01		lda #$01			lda 	#1
.27b9	20 3d 26	jsr $263d			jsr 	FloatSetByte
.27bc	ca		dex				dex
.27bd	20 fd 25	jsr $25fd			jsr 	FloatNegate
.27c0	e8		inx				inx
.27c1	20 5f 20	jsr $205f			jsr 	FloatAdd
.27c4	68		pla				pla 							; integer part +1 and negated.
.27c5	1a		inc a				inc 	a
.27c6	49 ff		eor #$ff			eor 	#$FF
.27c8	1a		inc a				inc 	a
.27c9	48		pha				pha
.27ca					_UEPositive:
.27ca	20 e0 27	jsr $27e0			jsr 	CoreExponent
.27cd	20 14 28	jsr $2814			jsr 	CompletePolynomial
.27d0	68		pla				pla
.27d1	18		clc				clc
.27d2	75 6e		adc $6e,x			adc 	NSExponent,x
.27d4	95 6e		sta $6e,x			sta 	NSExponent,x
.27d6	18		clc				clc
.27d7	60		rts				rts
.27d8					_UECopy01:
.27d8	8a		txa				txa
.27d9	a8		tay				tay
.27da	c8		iny				iny
.27db	4c 1f 28	jmp $281f			jmp 	CopyFloatXY
.27de					_UERangeError:
.27de	38		sec				sec
.27df	60		rts				rts
.27e0					CoreExponent:
.27e0	a9 b0		lda #$b0			lda 	#ExpCoefficients & $FF
.27e2	a0 26		ldy #$26			ldy 	#ExpCoefficients >> 8
.27e4	20 e8 27	jsr $27e8			jsr 	CalculateHornerPolynomial
.27e7	60		rts				rts
.27e8					CalculateHornerPolynomial:
.27e8	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.27ea	84 2d		sty $2d				sty 	zTemp0+1
.27ec	9c b7 05	stz $05b7			stz 	coefficientCount 			; zero the count.
.27ef	8e b8 05	stx $05b8			stx 	xValueSlot 					; save xValue slot.
.27f2	e8		inx				inx 								; set the count to zero.
.27f3	20 3b 26	jsr $263b			jsr 	FloatSetZero
.27f6					_CHPLoop:
.27f6	8a		txa				txa 								; copy X-1 to X+1
.27f7	a8		tay				tay
.27f8	ca		dex				dex
.27f9	c8		iny				iny
.27fa	20 1f 28	jsr $281f			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.27fd	e8		inx				inx
.27fe	e8		inx				inx
.27ff	20 fb 22	jsr $22fb			jsr 	FloatMultiply 				; times current by X
.2802	e8		inx				inx
.2803	20 3e 28	jsr $283e			jsr 	GetCoefficient 				; coefficient into X+1
.2806	20 5f 20	jsr $205f			jsr 	FloatAdd 					; and add
.2809	ee b7 05	inc $05b7			inc 	coefficientCount
.280c	ad b7 05	lda $05b7			lda 	coefficientCount
.280f	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.2811	d0 e3		bne $27f6			bne 	_CHPLoop
.2813	60		rts				rts
.2814					CompletePolynomial:
.2814	20 fb 22	jsr $22fb			jsr 	FloatMultiply
.2817	e8		inx				inx 								; get the last value
.2818	20 3e 28	jsr $283e			jsr 	GetCoefficient
.281b	20 5f 20	jsr $205f			jsr 	FloatAdd 					; and add it
.281e	60		rts				rts
.281f					CopyFloatXY:
.281f	b5 6e		lda $6e,x			lda 	NSExponent,x
.2821	99 6e 00	sta $006e,y			sta 	NSExponent,y
.2824	b5 32		lda $32,x			lda 	NSStatus,x
.2826	99 32 00	sta $0032,y			sta 	NSStatus,y
.2829	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.282b	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.282e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2830	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.2833	b5 56		lda $56,x			lda 	NSMantissa2,x
.2835	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.2838	b5 62		lda $62,x			lda 	NSMantissa3,x
.283a	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.283d	60		rts				rts
.283e					GetCoefficient:
.283e	5a		phy				phy
.283f	ad b7 05	lda $05b7			lda 	coefficientCount 			; 5 per block
.2842	0a		asl a				asl 	a
.2843	0a		asl a				asl 	a
.2844	38		sec				sec 								; +1 for count
.2845	6d b7 05	adc $05b7			adc 	coefficientCount
.2848	a8		tay				tay
.2849	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.284b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.284d	c8		iny				iny
.284e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2850	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2852	c8		iny				iny
.2853	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2855	95 56		sta $56,x			sta 	NSMantissa2,x
.2857	c8		iny				iny
.2858	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.285a	48		pha				pha
.285b	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.285d	95 62		sta $62,x			sta 	NSMantissa3,x
.285f	c8		iny				iny
.2860	68		pla				pla
.2861	29 80		and #$80			and 	#$80
.2863	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.2865	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2867	95 6e		sta $6e,x			sta 	NSExponent,x
.2869	7a		ply				ply
.286a	60		rts				rts
.05b7					coefficientCount:
>05b7							.fill 	1
.05b8					xValueSlot:
>05b8							.fill 	1
.286b					LoadConstant:
.286b	5a		phy				phy
.286c	a8		tay				tay
.286d	b9 59 27	lda $2759,y			lda 	Const_Base+0,y
.2870	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.2872	b9 5a 27	lda $275a,y			lda 	Const_Base+1,y
.2875	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.2877	b9 5b 27	lda $275b,y			lda 	Const_Base+2,y
.287a	95 57		sta $57,x			sta 	NSMantissa2+1,x
.287c	b9 5c 27	lda $275c,y			lda 	Const_Base+3,y
.287f	48		pha				pha
.2880	29 7f		and #$7f			and 	#$7F
.2882	95 63		sta $63,x			sta 	NSMantissa3+1,x
.2884	68		pla				pla
.2885	29 80		and #$80			and 	#$80
.2887	95 33		sta $33,x			sta 	NSStatus+1,x
.2889	b9 5d 27	lda $275d,y			lda 	Const_Base+4,y
.288c	95 6f		sta $6f,x			sta 	NSExponent+1,x
.288e	7a		ply				ply
.288f	60		rts				rts
.2890					FloatLogarithm:
.2890	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.2892	30 5f		bmi $28f3			bmi 	_ULRange
.2894	20 5d 26	jsr $265d			jsr 	FloatIsZero
.2897	f0 5a		beq $28f3			beq 	_ULRange
.2899	20 90 23	jsr $2390			jsr 	FloatNormalise 				; put into FP mode.
.289c	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.289e	48		pha				pha
.289f	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.28a1	95 6e		sta $6e,x			sta 	NSExponent,x
.28a3	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.28a5	20 6b 28	jsr $286b			jsr 	LoadConstant
.28a8	e8		inx				inx
.28a9	20 5f 20	jsr $205f			jsr 	FloatAdd
.28ac	8a		txa				txa 								; divide into sqrt 2.0
.28ad	a8		tay				tay
.28ae	c8		iny				iny
.28af	20 1f 28	jsr $281f			jsr 	CopyFloatXY
.28b2	ca		dex				dex
.28b3	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.28b5	20 6b 28	jsr $286b			jsr 	LoadConstant
.28b8	e8		inx				inx
.28b9	e8		inx				inx
.28ba	20 84 21	jsr $2184			jsr 	FloatDivide 				; if zero, error.
.28bd	b0 33		bcs $28f2			bcs 	_ULRangePla
.28bf	20 fd 25	jsr $25fd			jsr 	FloatNegate 				; subtract from 1
.28c2	e8		inx				inx
.28c3	a9 01		lda #$01			lda 	#1
.28c5	20 3d 26	jsr $263d			jsr 	FloatSetByte
.28c8	20 5f 20	jsr $205f			jsr 	FloatAdd
.28cb	20 f5 28	jsr $28f5			jsr 	CoreLog
.28ce	20 14 28	jsr $2814			jsr 	CompletePolynomial
.28d1	68		pla				pla 								; add exponent
.28d2	18		clc				clc
.28d3	69 1f		adc #$1f			adc 	#31 						; fix up
.28d5	48		pha				pha
.28d6	10 03		bpl $28db			bpl 	_LogNotNeg
.28d8	49 ff		eor #$ff			eor 	#$FF
.28da	1a		inc a				inc 	a
.28db					_LogNotNeg:
.28db	e8		inx				inx 								; set byte and sign.
.28dc	20 3d 26	jsr $263d			jsr 	FloatSetByte
.28df	68		pla				pla
.28e0	29 80		and #$80			and 	#$80
.28e2	95 32		sta $32,x			sta 	NSStatus,x
.28e4	20 5f 20	jsr $205f			jsr 	FloatAdd
.28e7	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.28e9	20 6b 28	jsr $286b			jsr 	LoadConstant
.28ec	e8		inx				inx
.28ed	20 fb 22	jsr $22fb			jsr 	FloatMultiply
.28f0	18		clc				clc
.28f1	60		rts				rts
.28f2					_ULRangePla:
.28f2	68		pla				pla
.28f3					_ULRange:
.28f3	38		sec				sec
.28f4	60		rts				rts
.28f5					CoreLog:
.28f5	a9 fd		lda #$fd			lda 	#LogCoefficients & $FF
.28f7	a0 26		ldy #$26			ldy 	#LogCoefficients >> 8
.28f9	4c 68 29	jmp $2968			jmp 	CorePolySquared
.28fc					FloatPI:
.28fc	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.28fe	20 6b 28	jsr $286b			jsr 	LoadConstant
.2901	e8		inx				inx
.2902	18		clc				clc
.2903	60		rts				rts
.2904					FloatPower:
.2904	ca		dex				dex
.2905	8a		txa				txa 							; copy 0 to 2, so we can process it
.2906	a8		tay				tay
.2907	c8		iny				iny
.2908	c8		iny				iny
.2909	20 1f 28	jsr $281f			jsr 	CopyFloatXY
.290c	e8		inx				inx 							; 2 = Log(0)
.290d	e8		inx				inx
.290e	20 90 28	jsr $2890			jsr 	FloatLogarithm
.2911	b0 0d		bcs $2920			bcs 	_FPWExit
.2913	20 fb 22	jsr $22fb			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.2916	8a		txa				txa 							; copy to slot 0
.2917	a8		tay				tay
.2918	88		dey				dey
.2919	20 1f 28	jsr $281f			jsr 	CopyFloatXY
.291c	ca		dex				dex  							; Exponent code.
.291d	20 8d 27	jsr $278d			jsr 	FloatExponent
.2920					_FPWExit:
.2920	60		rts				rts
.2921					FloatSine:
.2921	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.2923	48		pha				pha
.2924	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.2926	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.2928	20 6b 28	jsr $286b			jsr 	LoadConstant
.292b	e8		inx				inx
.292c	20 fb 22	jsr $22fb			jsr 	FloatMultiply
.292f	20 1b 22	jsr $221b			jsr 	FloatFractionalPart 		; take the fractional part
.2932	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.2934	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.2936	90 1f		bcc $2957			bcc 	_USProcessExit
.2938	f0 06		beq $2940			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.293a	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.293c	c9 60		cmp #$60			cmp 	#$60
.293e	b0 0e		bcs $294e			bcs 	_USSubtractOne
.2940					_USSubtractFromHalf:
.2940	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.2942	20 6b 28	jsr $286b			jsr 	LoadConstant
.2945	e8		inx				inx
.2946	20 59 20	jsr $2059			jsr 	FloatSubtract
.2949	20 fd 25	jsr $25fd			jsr 	FloatNegate 				; then negate it
.294c	80 09		bra $2957			bra 	_USProcessExit 				; and exit
.294e					_USSubtractOne:
.294e	e8		inx				inx
.294f	a9 01		lda #$01			lda 	#1
.2951	20 3d 26	jsr $263d			jsr 	FloatSetByte
.2954	20 59 20	jsr $2059			jsr 	FloatSubtract
.2957					_USProcessExit:
.2957	20 64 29	jsr $2964			jsr 	CoreSine
.295a	20 14 28	jsr $2814			jsr 	CompletePolynomial
.295d	68		pla				pla 								; restore sign and apply
.295e	55 32		eor $32,x			eor 	NSStatus,x
.2960	95 32		sta $32,x			sta 	NSStatus,x
.2962	18		clc				clc
.2963	60		rts				rts
.2964					CoreSine:
.2964	a9 d9		lda #$d9			lda 	#SinCoefficients & $FF
.2966	a0 26		ldy #$26			ldy 	#SinCoefficients >> 8
.2968					CorePolySquared:
.2968	48		pha				pha 								; save coefficient table
.2969	5a		phy				phy
.296a	8a		txa				txa 								; copy X to +1, +2
.296b	a8		tay				tay
.296c	c8		iny				iny
.296d	20 1f 28	jsr $281f			jsr 	CopyFloatXY
.2970	c8		iny				iny
.2971	20 1f 28	jsr $281f			jsr 	CopyFloatXY
.2974	e8		inx				inx 								; point to the pair and put x^2 on stack
.2975	e8		inx				inx
.2976	20 fb 22	jsr $22fb			jsr 	FloatMultiply
.2979	7a		ply				ply 								; coefficient table back.
.297a	68		pla				pla
.297b	20 e8 27	jsr $27e8			jsr 	CalculateHornerPolynomial
.297e	8a		txa				txa 								; copy back to slot #1
.297f	a8		tay				tay
.2980	88		dey				dey
.2981	20 1f 28	jsr $281f			jsr	 	CopyFloatXY
.2984	ca		dex				dex 								; point at result
.2985	60		rts				rts
.2986					FloatSquareRoot:
.2986	20 90 28	jsr $2890			jsr 	FloatLogarithm
.2989	b0 06		bcs $2991			bcs 	_FSQExit
.298b	d6 6e		dec $6e,x			dec 	NSExponent,x
.298d	20 8d 27	jsr $278d			jsr 	FloatExponent
.2990	18		clc				clc
.2991					_FSQExit:
.2991	60		rts				rts
.2992					FloatTangent:
.2992	da		phx				phx
.2993	8a		txa				txa 								; sin -> +1
.2994	a8		tay				tay
.2995	c8		iny				iny
.2996	20 1f 28	jsr $281f			jsr 	CopyFloatXY
.2999	e8		inx				inx
.299a	20 21 29	jsr $2921			jsr 	FloatSine
.299d	ca		dex				dex
.299e	8a		txa				txa 								; cos -> +2
.299f	a8		tay				tay
.29a0	c8		iny				iny
.29a1	c8		iny				iny
.29a2	20 1f 28	jsr $281f			jsr 	CopyFloatXY
.29a5	e8		inx				inx
.29a6	e8		inx				inx
.29a7	20 81 27	jsr $2781			jsr 	FloatCosine
.29aa	20 84 21	jsr $2184			jsr 	FloatDivide 				; calculate sin/cos
.29ad	b0 07		bcs $29b6			bcs 	_FTExit 					; divide by zero
.29af	8a		txa				txa 								; copy result down.
.29b0	a8		tay				tay
.29b1	88		dey				dey
.29b2	20 1f 28	jsr $281f			jsr 	CopyFloatXY
.29b5	18		clc				clc
.29b6					_FTExit:
.29b6	fa		plx				plx
.29b7	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.007a					srcPtr:
>007a							.fill 	2
.05b9					currentLineNumber:
>05b9							.fill 	2
.29b8					InlineNonDecimal:
.29b8	a2 02		ldx #$02			ldx 	#2 							; get size in X
.29ba	c9 25		cmp #$25			cmp 	#"%"
.29bc	f0 02		beq $29c0			beq 	_INDBinary
.29be	a2 10		ldx #$10			ldx 	#16
.29c0					_INDBinary:
.29c0	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.29c2	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.29c4	64 2c		stz $2c				stz 	zTemp0 						; zero result
.29c6	64 2d		stz $2d				stz 	zTemp0+1
.29c8					_INDLoop:
.29c8	20 64 33	jsr $3364			jsr 	LookNext 					; check next character
.29cb	20 a0 33	jsr $33a0			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.29ce	90 1f		bcc $29ef			bcc		_INDDone 					; didn't convert
.29d0	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.29d2	b0 1b		bcs $29ef			bcs 	_INDDone
.29d4	20 fe 29	jsr $29fe			jsr 	_INDShift 					; x 2 or x 16
.29d7	e0 02		cpx #$02			cpx 	#2
.29d9	f0 09		beq $29e4			beq 	_INDNotHex
.29db	20 fe 29	jsr $29fe			jsr 	_INDShift
.29de	20 fe 29	jsr $29fe			jsr 	_INDShift
.29e1	20 fe 29	jsr $29fe			jsr 	_INDShift
.29e4					_INDNotHex:
.29e4	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.29e6	85 2c		sta $2c				sta 	zTemp0
.29e8	20 75 33	jsr $3375			jsr 	GetNext 					; consume
.29eb	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.29ed	80 d9		bra $29c8			bra 	_INDLoop
.29ef					_INDDone:
.29ef	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.29f1	f0 08		beq $29fb			beq 	_INDError
.29f3	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.29f5	a5 2c		lda $2c				lda 	zTemp0
.29f7	20 20 2b	jsr $2b20			jsr 	PushIntegerYA
.29fa	60		rts				rts
.29fb					_INDError:
.29fb	4c f5 1e	jmp $1ef5		jmp	ErrorV_syntax
.29fe					_INDShift:
.29fe	06 2c		asl $2c				asl 	zTemp0
.2a00	26 2d		rol $2d				rol 	zTemp0+1
.2a02	60		rts				rts
.2a03					GetLineNumber:
.2a03	ac ba 05	ldy $05ba			ldy 	currentLineNumber+1
.2a06	ad b9 05	lda $05b9			lda 	currentLineNumber
.2a09	60		rts				rts
.2a0a					WriteCodeByte:
.2a0a	48		pha				pha 								; save on stack
.2a0b	da		phx				phx
.2a0c	5a		phy				phy
.2a0d	aa		tax				tax
.2a0e	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.2a10	20 1d 2b	jsr $2b1d			jsr 	CallAPIHandler
.2a13	7a		ply				ply 								; restore from stack
.2a14	fa		plx				plx
.2a15	68		pla				pla
.2a16	60		rts				rts
.2a17					PrintCharacter
.2a17	48		pha				pha
.2a18	da		phx				phx
.2a19	5a		phy				phy
.2a1a	aa		tax				tax
.2a1b	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.2a1d	20 1d 2b	jsr $2b1d			jsr 	CallAPIHandler
.2a20	7a		ply				ply
.2a21	fa		plx				plx
.2a22	68		pla				pla
.2a23	60		rts				rts
.2a24					ProcessNewLine:
.2a24	86 2c		stx $2c				stx 	zTemp0 						; save address in zTemp0
.2a26	84 2d		sty $2d				sty 	zTemp0+1
.2a28	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.2a29	8a		txa				txa
.2a2a	69 04		adc #$04			adc 	#4
.2a2c	85 7a		sta $7a				sta 	srcPtr
.2a2e	98		tya				tya
.2a2f	69 00		adc #$00			adc 	#0
.2a31	85 7b		sta $7b				sta 	srcPtr+1
.2a33	a0 02		ldy #$02			ldy 	#2							; read and save line number
.2a35	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a37	8d b9 05	sta $05b9			sta 	currentLineNumber
.2a3a	c8		iny				iny
.2a3b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a3d	8d ba 05	sta $05ba			sta 	currentLineNumber+1
.2a40	60		rts				rts
.2a41					BufferClear:
.2a41	9c bb 05	stz $05bb			stz 	bufferSize
.2a44	60		rts				rts
.2a45					BufferWrite:
.2a45	da		phx				phx
.2a46	ae bb 05	ldx $05bb			ldx 	bufferSize
.2a49	9d bc 05	sta $05bc,x			sta 	dataBuffer,x
.2a4c	ee bb 05	inc $05bb			inc 	bufferSize
.2a4f	fa		plx				plx
.2a50	60		rts				rts
.2a51					BufferOutput:
.2a51	ad bb 05	lda $05bb			lda 	bufferSize
.2a54	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2a57	a2 00		ldx #$00			ldx 	#0
.2a59					_BOLoop:
.2a59	ec bb 05	cpx $05bb			cpx 	bufferSize
.2a5c	f0 09		beq $2a67			beq 	_BOExit
.2a5e	bd bc 05	lda $05bc,x			lda 	dataBuffer,x
.2a61	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2a64	e8		inx				inx
.2a65	80 f2		bra $2a59			bra 	_BOLoop
.2a67					_BOExit:
.2a67	60		rts				rts
.05bb					bufferSize:
>05bb							.fill 	1
.05bc					dataBuffer:
>05bc							.fill 	256
.2a68					CheckNextComma:
.2a68	a9 2c		lda #$2c			lda	 	#","
.2a6a	80 06		bra $2a72			bra 	CheckNextA
.2a6c					CheckNextRParen:
.2a6c	a9 29		lda #$29			lda	 	#")"
.2a6e	80 02		bra $2a72			bra 	CheckNextA
.2a70					CheckNextLParen:
.2a70	a9 28		lda #$28			lda 	#"("
.2a72					CheckNextA:
.2a72	8d bc 06	sta $06bc			sta 	checkCharacter 				; save test character
.2a75					_CNALoop:
.2a75	20 80 33	jsr $3380			jsr 	GetNextNonSpace 			; get next skipping spaces.
.2a78	cd bc 06	cmp $06bc			cmp 	checkCharacter 				; matches ?
.2a7b	f0 03		beq $2a80			beq 	_CNAExit
.2a7d	4c f5 1e	jmp $1ef5		jmp	ErrorV_syntax
.2a80					_CNAExit:
.2a80	60		rts				rts
.06bc					checkCharacter:
>06bc							.fill 	1
.2a81					StartCompiler:
.2a81	86 2c		stx $2c				stx 	zTemp0 						; access API
.2a83	84 2d		sty $2d				sty 	zTemp0+1
.2a85	a0 2c		ldy #$2c			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.2a87	a2 d9		ldx #$d9			ldx 	#CompilerErrorHandler & $FF
.2a89	20 ce 1e	jsr $1ece			jsr 	SetErrorHandler
.2a8c	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.2a8e	b2 2c		lda ($2c)			lda 	(zTemp0)
.2a90	8d be 06	sta $06be			sta 	APIVector
.2a93	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a95	8d bf 06	sta $06bf			sta 	APIVector+1
.2a98	c8		iny				iny 								; copy data area range.
.2a99	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a9b	8d c0 06	sta $06c0			sta 	compilerStartHigh
.2a9e	c8		iny				iny
.2a9f	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2aa1	8d c1 06	sta $06c1			sta 	compilerEndHigh
.2aa4	ba		tsx				tsx 								; save stack pointer
.2aa5	8e bd 06	stx $06bd			stx 	compilerSP
.2aa8	20 04 37	jsr $3704			jsr 	STRReset 					; reset storage (line#, variable)
.2aab	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.2aad	20 1d 2b	jsr $2b1d			jsr 	CallAPIHandler
.2ab0	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.2ab2	20 1d 2b	jsr $2b1d			jsr 	CallAPIHandler
.2ab5	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.2ab7	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2aba	a9 00		lda #$00			lda 	#0
.2abc	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2abf	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2ac2					MainCompileLoop:
.2ac2	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.2ac4	20 1d 2b	jsr $2b1d			jsr 	CallAPIHandler
.2ac7	90 31		bcc $2afa			bcc 	SaveCodeAndExit 			; end of source.
.2ac9	20 24 2a	jsr $2a24			jsr 	ProcessNewLine 				; set up pointer and line number.
.2acc	20 03 2a	jsr $2a03			jsr 	GetLineNumber 				; get line #
.2acf	20 ee 34	jsr $34ee			jsr 	STRMarkLine 				; remember the code position and number of this line.
.2ad2	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.2ad4	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2ad7					_MCLSameLine:
.2ad7	20 80 33	jsr $3380			jsr 	GetNextNonSpace 			; get the first character.
.2ada	f0 e6		beq $2ac2			beq 	MainCompileLoop 			; end of line, get next line.
.2adc	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.2ade	f0 f7		beq $2ad7			beq 	_MCLSameLine
.2ae0	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.2ae2	10 0c		bpl $2af0			bpl 	_MCLCheckAssignment
.2ae4	a2 3e		ldx #$3e			ldx 	#CommandTables & $FF 		; do command tables.
.2ae6	a0 2f		ldy #$2f			ldy 	#CommandTables >> 8
.2ae8	20 06 32	jsr $3206			jsr 	GeneratorProcess
.2aeb	b0 ea		bcs $2ad7			bcs 	_MCLSameLine 				; keep trying to compile the line.
.2aed					_MCLSyntax:
.2aed	4c f5 1e	jmp $1ef5		jmp	ErrorV_syntax
.2af0					_MCLCheckAssignment:
.2af0	20 96 33	jsr $3396			jsr 	CharIsAlpha 				; if not alpha then syntax error
.2af3	90 f8		bcc $2aed			bcc 	_MCLSyntax
.2af5	20 bc 34	jsr $34bc			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.2af8	80 dd		bra $2ad7			bra		_MCLSameLine 				; loop back.
.2afa					SaveCodeAndExit:
.2afa	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.2afc	20 1d 2b	jsr $2b1d			jsr 	CallAPIHandler
.2aff	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.2b01	a8		tay				tay
.2b02	20 ee 34	jsr $34ee			jsr 	STRMarkLine
.2b05	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.2b07	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2b0a	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.2b0c	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2b0f	20 36 2e	jsr $2e36			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.2b12	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.2b14	20 1d 2b	jsr $2b1d			jsr 	CallAPIHandler
.2b17	18		clc				clc 								; CC = success
.2b18					ExitCompiler:
.2b18	ae bd 06	ldx $06bd			ldx 	compilerSP 					; reload SP and exit.
.2b1b	9a		txs				txs
.2b1c	60		rts				rts
.2b1d					CallAPIHandler:
.2b1d	6c be 06	jmp ($06be)			jmp 	(APIVector)
.06bd					compilerSP:
>06bd							.fill 	1
.06be					APIVector:
>06be							.fill 	2
.06c0					compilerStartHigh:
>06c0							.fill 	1
.06c1					compilerEndHigh:
>06c1							.fill 	1
.2b20					PushIntegerYA:
.2b20	c0 00		cpy #$00			cpy 	#0 							; 0-255
.2b22	f0 0f		beq $2b33			beq 	PushIntegerA
.2b24	48		pha				pha
.2b25	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.2b27	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2b2a	68		pla				pla 								; then LSB
.2b2b	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2b2e	98		tya				tya 								; then MSB
.2b2f	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2b32	60		rts				rts
.2b33					PushIntegerA:
.2b33	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.2b35	90 07		bcc $2b3e			bcc 	_PIWriteA
.2b37	48		pha				pha
.2b38	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.2b3a	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2b3d	68		pla				pla
.2b3e					_PIWriteA:
.2b3e	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2b41	60		rts				rts
.2b42					PushFloatCommand:
.2b42	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.2b44	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2b47	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.2b49	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2b4c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2b4e	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2b51	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2b53	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2b56	b5 56		lda $56,x			lda 	NSMantissa2,x
.2b58	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2b5b	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.2b5d	29 80		and #$80			and 	#$80
.2b5f	15 62		ora $62,x			ora 	NSMantissa3,x
.2b61	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2b64	60		rts				rts
.2b65					CreateVariableRecord:
.2b65	48		pha				pha
.2b66	ad cc 06	lda $06cc			lda 	freeVariableMemory 		; push current free address on stack.
.2b69	48		pha				pha
.2b6a	ad cd 06	lda $06cd			lda 	freeVariableMemory+1
.2b6d	48		pha				pha
.2b6e	ad ca 06	lda $06ca			lda 	variableListEnd  		; copy end of list to zTemp0
.2b71	85 2c		sta $2c				sta 	zTemp0
.2b73	ad cb 06	lda $06cb			lda 	variableListEnd+1
.2b76	85 2d		sta $2d				sta 	zTemp0+1
.2b78	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.2b7a	92 2c		sta ($2c)			sta 	(zTemp0)
.2b7c	98		tya				tya
.2b7d	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.2b7f	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b81	88		dey				dey
.2b82	8a		txa				txa
.2b83	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b85	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.2b87	ad cc 06	lda $06cc			lda 	freeVariableMemory
.2b8a	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b8c	c8		iny				iny
.2b8d	ad cd 06	lda $06cd			lda 	freeVariableMemory+1
.2b90	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b92	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.2b94	a9 00		lda #$00			lda 	#0
.2b96	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2b98	18		clc				clc
.2b99	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.2b9b	6d ca 06	adc $06ca			adc  	variableListEnd
.2b9e	8d ca 06	sta $06ca			sta 	variableListEnd
.2ba1	90 03		bcc $2ba6			bcc 	_CVNoCarry2
.2ba3	ee cb 06	inc $06cb			inc 	variableListEnd+1
.2ba6					_CVNoCarry2:
.2ba6	7a		ply				ply
.2ba7	fa		plx				plx
.2ba8	68		pla				pla
.2ba9	60		rts				rts
.2baa					SetVariableRecordToCodePosition:
.2baa	48		pha				pha
.2bab	5a		phy				phy
.2bac	a0 03		ldy #$03			ldy 	#3
.2bae	a5 2b		lda $2b				lda 	objPtr+1
.2bb0	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bb2	c8		iny				iny
.2bb3	a5 2a		lda $2a				lda 	objPtr
.2bb5	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bb7	7a		ply				ply
.2bb8	68		pla				pla
.2bb9	60		rts				rts
.2bba					AllocateBytesForType:
.2bba	48		pha				pha
.2bbb	da		phx				phx
.2bbc	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.2bbe	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2bc0	c9 00		cmp #$00			cmp 	#NSSIFloat
.2bc2	d0 02		bne $2bc6			bne 	_CVNotFloat
.2bc4	a2 06		ldx #$06			ldx 	#6
.2bc6					_CVNotFloat:
.2bc6	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.2bc7	18		clc				clc
.2bc8	6d cc 06	adc $06cc			adc 	freeVariableMemory
.2bcb	8d cc 06	sta $06cc			sta 	freeVariableMemory
.2bce	90 03		bcc $2bd3			bcc 	_CVNoCarry1
.2bd0	ee cd 06	inc $06cd			inc 	freeVariableMemory+1
.2bd3					_CVNoCarry1:
.2bd3	fa		plx				plx
.2bd4	68		pla				pla
.2bd5	60		rts				rts
.2bd6					CommandDATA:
.2bd6	20 41 2a	jsr $2a41			jsr 	BufferClear 				; copy it to the buffer
.2bd9	20 67 33	jsr $3367			jsr 	LookNextNonSpace
.2bdc					_CTDataLoop:
.2bdc	20 64 33	jsr $3364			jsr 	LookNext 					; reached EOL
.2bdf	f0 08		beq $2be9			beq 	_CTDataDone
.2be1	20 45 2a	jsr $2a45			jsr 	BufferWrite 				; write and consume
.2be4	20 75 33	jsr $3375			jsr 	GetNext
.2be7	80 f3		bra $2bdc			bra 	_CTDataLoop
.2be9					_CTDataDone:
.2be9	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.2beb	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2bee	20 51 2a	jsr $2a51			jsr 	BufferOutput
.2bf1	60		rts				rts
.2bf2					CommandDEF:
.2bf2	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.2bf4	20 33 2b	jsr $2b33			jsr 	PushIntegerA
.2bf7	20 85 34	jsr $3485			jsr 	CompileGotoEOL 				; compile skip over DEF
.2bfa	a9 a5		lda #$a5			lda 	#C64_FN
.2bfc	20 72 2a	jsr $2a72			jsr 	CheckNextA
.2bff	20 80 33	jsr $3380			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2c02	20 e5 33	jsr $33e5			jsr 	ExtractVariableName
.2c05	8a		txa				txa
.2c06	10 51		bpl $2c59			bpl 	_CDError
.2c08	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2c09	29 7f		and #$7f			and 	#$7F
.2c0b	aa		tax				tax
.2c0c	98		tya				tya
.2c0d	09 80		ora #$80			ora 	#$80
.2c0f	a8		tay				tay
.2c10	20 da 2d	jsr $2dda			jsr 	FindVariable				; does it already exist ?
.2c13	b0 44		bcs $2c59			bcs 	_CDError 					; if so, that's an error.
.2c15	20 65 2b	jsr $2b65			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.2c18	20 aa 2b	jsr $2baa			jsr 	SetVariableRecordToCodePosition
.2c1b	20 80 33	jsr $3380			jsr 	GetNextNonSpace
.2c1e	20 c1 36	jsr $36c1			jsr 	GetReferenceTerm 			; get var ref, not array
.2c21	c9 00		cmp #$00			cmp 	#0
.2c23	30 34		bmi $2c59			bmi 	_CDError
.2c25	8d c2 06	sta $06c2			sta 	defType 					; save type
.2c28	8e c3 06	stx $06c3			stx 	defVariable 				; save var ref
.2c2b	8c c4 06	sty $06c4			sty 	defVariable+1
.2c2e	29 40		and #$40			and 	#NSSString 					; only numbers.
.2c30	d0 27		bne $2c59			bne 	_CDError
.2c32	20 6c 2a	jsr $2a6c			jsr 	CheckNextRParen 			; check )
.2c35	a9 b2		lda #$b2			lda 	#C64_EQUAL
.2c37	20 72 2a	jsr $2a72			jsr 	CheckNextA 					; check =
.2c3a	18		clc				clc 								; if this is DEF FNxx(A), read A
.2c3b	20 5c 2c	jsr $2c5c			jsr 	CDReadWriteVariable
.2c3e	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2c40	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2c43	38		sec				sec
.2c44	20 5c 2c	jsr $2c5c			jsr 	CDReadWriteVariable 		; A is now updated
.2c47	20 20 2d	jsr $2d20			jsr 	CompileExpressionAt0 		; the actual body of the function.
.2c4a	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2c4c	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2c4f	38		sec				sec
.2c50	20 5c 2c	jsr $2c5c			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.2c53	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.2c55	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2c58	60		rts				rts
.2c59					_CDError:
.2c59	4c f5 1e	jmp $1ef5		jmp	ErrorV_syntax
.2c5c					CDReadWriteVariable:
.2c5c	ac c4 06	ldy $06c4			ldy 	defVariable+1 				; set up YX
.2c5f	ae c3 06	ldx $06c3			ldx 	defVariable
.2c62	ad c2 06	lda $06c2			lda 	defType
.2c65	20 73 36	jsr $3673			jsr 	GetSetVariable
.2c68	60		rts				rts
.06c2					defType:
>06c2							.fill 	1
.06c3					defVariable:
>06c3							.fill 	2
.2c69					CommandDIM:
.2c69	20 80 33	jsr $3380			jsr 	GetNextNonSpace 			; get the first non space character
.2c6c	20 e5 33	jsr $33e5			jsr 	ExtractVariableName 		; variable name to XY
.2c6f	da		phx				phx 								; save name with type bits.
.2c70	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.2c72	10 37		bpl $2cab			bpl 	_CDError
.2c74	20 da 2d	jsr $2dda			jsr 	FindVariable	 			; see if already exist
.2c77	b0 35		bcs $2cae			bcs 	_CDRedefine 				; it still exists.
.2c79	20 65 2b	jsr $2b65			jsr 	CreateVariableRecord 		; create the basic variable
.2c7c	20 ba 2b	jsr $2bba			jsr 	AllocateBytesForType 		; allocate memory for it
.2c7f	68		pla				pla 								; restore type bits
.2c80	5a		phy				phy 								; save the address of the basic storage
.2c81	da		phx				phx
.2c82	48		pha				pha
.2c83	20 b1 2c	jsr $2cb1			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.2c86	68		pla				pla
.2c87	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.2c89	20 33 2b	jsr $2b33			jsr 	PushIntegerA 				; push that type data out.
.2c8c	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.2c8e	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2c91	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.2c93	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2c96	fa		plx				plx 								; restore address
.2c97	7a		ply				ply
.2c98	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2c9a	38		sec				sec
.2c9b	20 73 36	jsr $3673			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.2c9e	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; , follows ?
.2ca1	c9 2c		cmp #$2c			cmp 	#","
.2ca3	d0 05		bne $2caa			bne 	_CDExit
.2ca5	20 75 33	jsr $3375			jsr 	GetNext 					; consume comma
.2ca8	80 bf		bra $2c69			bra 	CommandDIM 					; do another DIM
.2caa					_CDExit:
.2caa	60		rts				rts
.2cab					_CDError:
.2cab	4c f5 1e	jmp $1ef5		jmp	ErrorV_syntax
.2cae					_CDRedefine:
.2cae	4c bd 1f	jmp $1fbd		jmp	ErrorV_redefine
.2cb1					OutputIndexGroup:
.2cb1	9c c5 06	stz $06c5			stz 	IndexCount 					; count of number of indices.
.2cb4					_OIGNext:
.2cb4	20 20 2d	jsr $2d20			jsr 	CompileExpressionAt0 		; get a dimension
.2cb7	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2cb9	c9 00		cmp #$00			cmp 	#NSSIFloat
.2cbb	d0 19		bne $2cd6			bne 	_OIGType
.2cbd	ee c5 06	inc $06c5			inc 	IndexCount 					; bump the counter.
.2cc0	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; does a , follow ?
.2cc3	c9 2c		cmp #$2c			cmp 	#","
.2cc5	d0 05		bne $2ccc			bne 	_OIGCheckEnd
.2cc7	20 75 33	jsr $3375			jsr 	GetNext 					; consume comma
.2cca	80 e8		bra $2cb4			bra 	_OIGNext 					; get next dimension
.2ccc					_OIGCheckEnd:
.2ccc	20 6c 2a	jsr $2a6c			jsr 	CheckNextRParen 			; check and consume )
.2ccf	ad c5 06	lda $06c5			lda 	IndexCount
.2cd2	20 33 2b	jsr $2b33			jsr 	PushIntegerA 				; compile the dimension count.
.2cd5	60		rts				rts
.2cd6					_OIGType:
.2cd6	4c 05 1f	jmp $1f05		jmp	ErrorV_type
.06c5					IndexCount:
>06c5							.fill 	1
.2cd9					CompilerErrorHandler:
.2cd9	68		pla				pla
.2cda	7a		ply				ply
.2cdb	85 2c		sta $2c				sta 	zTemp0
.2cdd	84 2d		sty $2d				sty 	zTemp0+1
.2cdf	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.2ce1	a0 01		ldy #$01			ldy 	#1
.2ce3					_EHDisplayMsg:
.2ce3	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ce5	20 17 2a	jsr $2a17			jsr 	PrintCharacter
.2ce8	c8		iny				iny
.2ce9	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ceb	d0 f6		bne $2ce3			bne 	_EHDisplayMsg
.2ced	a9 20		lda #$20			lda 	#32
.2cef	20 17 2a	jsr $2a17			jsr 	PrintCharacter
.2cf2	a9 40		lda #$40			lda 	#64
.2cf4	20 17 2a	jsr $2a17			jsr 	PrintCharacter
.2cf7	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.2cf9	20 3d 26	jsr $263d			jsr 	FloatSetByte
.2cfc	20 03 2a	jsr $2a03			jsr 	GetLineNumber
.2cff	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2d01	98		tya				tya
.2d02	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2d04	20 23 25	jsr $2523			jsr 	FloatToString
.2d07	a0 00		ldy #$00			ldy 	#0 							; display that string.
.2d09	a2 00		ldx #$00			ldx 	#0
.2d0b					_EHDisplayLine:
.2d0b	b9 97 05	lda $0597,y			lda 	decimalBuffer,y
.2d0e	20 17 2a	jsr $2a17			jsr 	PrintCharacter
.2d11	c8		iny				iny
.2d12	b9 97 05	lda $0597,y			lda 	decimalBuffer,y
.2d15	d0 f4		bne $2d0b			bne 	_EHDisplayLine
.2d17	a9 0d		lda #$0d			lda 	#13
.2d19	20 17 2a	jsr $2a17			jsr 	PrintCharacter
.2d1c	38		sec				sec 								; CS = error
.2d1d	4c 18 2b	jmp $2b18			jmp 	ExitCompiler
.2d20					CompileExpressionAt0:
.2d20	a9 00		lda #$00			lda 	#0
.2d22					CompileExpressionAtA:
.2d22	48		pha				pha  								; save level
.2d23	20 2c 37	jsr $372c			jsr 	CompileTerm 				; compile a term.
.2d26	fa		plx				plx 								; get level back into X
.2d27					_ECALoop:
.2d27	48		pha				pha 								; save type on stack.
.2d28	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; get the next character
.2d2b	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.2d2d	90 04		bcc $2d33			bcc 	_ECAExit
.2d2f	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.2d31	90 02		bcc $2d35			bcc 	_ECAHaveToken
.2d33					_ECAExit:
.2d33	68		pla				pla 								; throw type off stack
.2d34	60		rts				rts
.2d35					_ECAHaveToken:
.2d35	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.2d37	aa		tax				tax 								; X contains the operator token
.2d38	bd 23 2d	lda $2d23,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.2d3b	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.2d3d	90 f4		bcc $2d33			bcc 	_ECAExit
.2d3f	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.2d41	20 75 33	jsr $3375			jsr 	GetNext 					; consume the token.
.2d44	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.2d46	f0 11		beq $2d59			beq 	_ECAGreaterCheck
.2d48	e0 b3		cpx #$b3			cpx 	#C64_LESS
.2d4a	d0 1a		bne $2d66			bne 	_ECAHaveFullToken
.2d4c	20 64 33	jsr $3364			jsr 	LookNext 					; checks for < (<= or <>)
.2d4f	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.2d51	f0 0e		beq $2d61			beq	 	_ECAToNotEqual
.2d53	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.2d55	d0 0f		bne $2d66			bne 	_ECAHaveFullToken
.2d57	80 07		bra $2d60			bra 	_ECAAddEqual
.2d59					_ECAGreaterCheck:
.2d59	20 64 33	jsr $3364			jsr 	LookNext
.2d5c	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.2d5e	d0 06		bne $2d66			bne 	_ECAHaveFullToken
.2d60					_ECAAddEqual:
.2d60	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.2d61					_ECAToNotEqual:
.2d61	e8		inx				inx
.2d62	e8		inx				inx
.2d63	20 75 33	jsr $3375			jsr 	GetNext 					; consume the = or > in >= <= <>
.2d66					_ECAHaveFullToken:
.2d66	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.2d68	d0 0a		bne $2d74			bne 	_ECANotConcat
.2d6a	68		pla				pla 								; get type back
.2d6b	48		pha				pha
.2d6c	29 40		and #$40			and 	#NSSTypeMask
.2d6e	c9 40		cmp #$40			cmp 	#NSSString
.2d70	d0 02		bne $2d74			bne 	_ECANotConcat
.2d72	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2d74					_ECANotConcat:
.2d74	da		phx				phx 								; save operator on the stack
.2d75	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.2d77	da		phx				phx
.2d78	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.2d7a	1a		inc a				inc 	a
.2d7b	20 22 2d	jsr $2d22			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.2d7e	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.2d80	fa		plx				plx 								; restore current precedence in X
.2d81	68		pla				pla 								; restore operator
.2d82	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.2d84	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.2d86	90 17		bcc $2d9f			bcc 	_ECANotCompare
.2d88	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.2d8a	b0 13		bcs $2d9f			bcs 	_ECANotCompare
.2d8c	7a		ply				ply 								; get type into Y
.2d8d	5a		phy				phy
.2d8e	48		pha				pha 								; save operator
.2d8f	98		tya				tya 								; get type
.2d90	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.2d92	29 40		and #$40			and 	#NSSTypeMask
.2d94	c9 40		cmp #$40			cmp 	#NSSString
.2d96	f0 02		beq $2d9a			beq 	_ECANotString
.2d98	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.2d9a					_ECANotString:
.2d9a	98		tya				tya									; output token Y
.2d9b	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2d9e	68		pla				pla 								; restore operator.
.2d9f					_ECANotCompare:
.2d9f	18		clc				clc 								; convert to P-Code and compile.
.2da0	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.2da2	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2da5	68		pla				pla 								; type of current result
.2da6	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.2da8	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.2daa	d0 19		bne $2dc5			bne		_ECAType
.2dac	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.2dae	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.2db0	d0 18		bne $2dca			bne 	_ECAGoLoop
.2db2	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.2db4	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2db6	f0 10		beq $2dc8			beq 	_ECAOkayString 				; (this is post conversion)
.2db8	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.2dba	90 09		bcc $2dc5			bcc 	_ECAType
.2dbc	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.2dbe	b0 05		bcs $2dc5			bcs 	_ECAType
.2dc0	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.2dc2	4c 27 2d	jmp $2d27			jmp 	_ECALoop
.2dc5					_ECAType:
.2dc5	4c 05 1f	jmp $1f05		jmp	ErrorV_type
.2dc8					_ECAOkayString:
.2dc8	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.2dca					_ECAGoLoop:
.2dca	4c 27 2d	jmp $2d27			jmp 	_ECALoop
.2dcd					PrecedenceTable:
>2dcd	03						.byte 	3 					; '+'
>2dce	03						.byte 	3 					; '-'
>2dcf	04						.byte 	4 					; '*'
>2dd0	04						.byte 	4 					; '/'
>2dd1	05						.byte 	5 					; '^'
>2dd2	01						.byte 	1 					; 'and'
>2dd3	00						.byte 	0 					; 'or'
>2dd4	02						.byte 	2 					; '>'
>2dd5	02						.byte 	2 					; '='
>2dd6	02						.byte 	2 					; '<'
>2dd7	02						.byte 	2 					; '>='
>2dd8	02						.byte 	2 					; '<='
>2dd9	02						.byte 	2 					; '<>'
.2dda					FindVariable:
.2dda	86 2e		stx $2e				stx 	zTemp1 						; save name.
.2ddc	84 2f		sty $2f				sty 	zTemp1+1
.2dde					_IVCheckSpecial:
.2dde	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.2de0	d0 18		bne $2dfa			bne 	_IVStandard
.2de2	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.2de4	f0 0c		beq $2df2			beq 	_IVTIFloat
.2de6	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.2de8	d0 10		bne $2dfa			bne 	_IVStandard
.2dea	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.2dec	a2 01		ldx #$01			ldx 	#$01
.2dee	a9 40		lda #$40			lda 	#NSSString
.2df0	38		sec				sec
.2df1	60		rts				rts
.2df2					_IVTIFloat:
.2df2	a0 80		ldy #$80			ldy 	#$80
.2df4	a2 00		ldx #$00			ldx 	#$00
.2df6	a9 00		lda #$00			lda 	#0
.2df8	38		sec				sec
.2df9	60		rts				rts
.2dfa					_IVStandard:
.2dfa	ad c0 06	lda $06c0			lda 	compilerStartHigh			; start scanning from here.
.2dfd	85 2d		sta $2d				sta 	zTemp0+1
.2dff	64 2c		stz $2c				stz 	zTemp0
.2e01					_IVCheckLoop:
.2e01	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.2e03	f0 2b		beq $2e30			beq  	_IVNotFound 				; if so, return with CC.
.2e05	a0 01		ldy #$01			ldy 	#1 							; match ?
.2e07	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e09	c5 2e		cmp $2e				cmp 	zTemp1
.2e0b	d0 07		bne $2e14			bne	 	_IVNext
.2e0d	c8		iny				iny
.2e0e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e10	c5 2f		cmp $2f				cmp 	zTemp1+1
.2e12	f0 0d		beq $2e21			beq 	_IVFound
.2e14					_IVNext:
.2e14	18		clc				clc
.2e15	a5 2c		lda $2c				lda 	zTemp0
.2e17	72 2c		adc ($2c)			adc 	(zTemp0)
.2e19	85 2c		sta $2c				sta 	zTemp0
.2e1b	90 e4		bcc $2e01			bcc 	_IVCheckLoop
.2e1d	e6 2d		inc $2d				inc 	zTemp0+1
.2e1f	80 e0		bra $2e01			bra 	_IVCheckLoop
.2e21					_IVFound:
.2e21	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.2e23	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e25	aa		tax				tax
.2e26	c8		iny				iny
.2e27	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e29	48		pha				pha
.2e2a	c8		iny				iny
.2e2b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e2d	7a		ply				ply
.2e2e	38		sec				sec
.2e2f	60		rts				rts
.2e30					_IVNotFound:
.2e30	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.2e32	a4 2f		ldy $2f				ldy 	zTemp1+1
.2e34	18		clc				clc
.2e35	60		rts				rts
.2e36					FixBranches:
.2e36	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.2e38	20 1d 2b	jsr $2b1d			jsr 	CallAPIHandler
.2e3b					_FBLoop:
.2e3b	b2 2a		lda ($2a)			lda 	(objPtr) 					; get the next one.
.2e3d	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.2e3f	f0 16		beq $2e57			beq 	_FBFixGotoGosub
.2e41	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.2e43	f0 12		beq $2e57			beq 	_FBFixGotoGosub
.2e45	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.2e47	f0 0e		beq $2e57			beq 	_FBFixGotoGosub
.2e49	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.2e4b	f0 0a		beq $2e57			beq 	_FBFixGotoGosub
.2e4d	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.2e4f	f0 3b		beq $2e8c			beq 	_FBFixVarSpace
.2e51					_FBNext:
.2e51	20 0a 20	jsr $200a			jsr 	MoveObjectForward 			; move forward in object code.
.2e54	90 e5		bcc $2e3b			bcc 	_FBLoop 					; not finished
.2e56					_FBExit:
.2e56	60		rts				rts
.2e57					_FBFixGotoGosub:
.2e57	a0 01		ldy #$01			ldy 	#1							; line number in YA
.2e59	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e5b	48		pha				pha
.2e5c	c8		iny				iny
.2e5d	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e5f	a8		tay				tay
.2e60	68		pla				pla
.2e61	20 17 35	jsr $3517			jsr 	STRFindLine			 		; find where it is YA
.2e64	90 08		bcc $2e6e			bcc 	_FBFFound 					; not found, so must be >
.2e66	48		pha				pha
.2e67	b2 2a		lda ($2a)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.2e69	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.2e6b	d0 0f		bne $2e7c			bne 	_FBFFail
.2e6d	68		pla				pla
.2e6e					_FBFFound:
.2e6e	20 67 35	jsr $3567			jsr 	STRMakeOffset 				; make it an offset from X:YA
.2e71	5a		phy				phy	 								; patch the GOTO/GOSUB
.2e72	a0 01		ldy #$01			ldy 	#1
.2e74	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e76	c8		iny				iny
.2e77	68		pla				pla
.2e78	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e7a	80 d5		bra $2e51			bra 	_FBNext
.2e7c					_FBFFail:
.2e7c	a0 02		ldy #$02			ldy 	#2
.2e7e	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e80	8d b9 05	sta $05b9			sta 	currentLineNumber
.2e83	c8		iny				iny
.2e84	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e86	8d ba 05	sta $05ba			sta 	currentLineNumber+1
.2e89	4c 38 1f	jmp $1f38		jmp	ErrorV_line
.2e8c					_FBFixVarSpace:
.2e8c	a0 01		ldy #$01			ldy 	#1
.2e8e	ad cc 06	lda $06cc			lda 	freeVariableMemory
.2e91	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e93	c8		iny				iny
.2e94	ad cd 06	lda $06cd			lda 	freeVariableMemory+1
.2e97	91 2a		sta ($2a),y			sta 	(objPtr),y
.2e99	80 b6		bra $2e51			bra 	_FBNext
.2e9b					CommandFOR:
.2e9b	20 80 33	jsr $3380			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.2e9e	20 96 33	jsr $3396			jsr 	CharIsAlpha 				; if not alpha , error
.2ea1	90 59		bcc $2efc			bcc 	_CFFail
.2ea3	20 c1 36	jsr $36c1			jsr 	GetReferenceTerm 			; figure out the reference.
.2ea6	48		pha				pha 								; save type
.2ea7	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ea9	c9 00		cmp #$00			cmp 	#NSSIFloat
.2eab	d0 4f		bne $2efc			bne 	_CFFail
.2ead	5a		phy				phy 								; save reference on the stack
.2eae	da		phx				phx
.2eaf	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.2eb1	20 72 2a	jsr $2a72			jsr 	CheckNextA
.2eb4	20 20 2d	jsr $2d20			jsr 	CompileExpressionAt0 		; initial value
.2eb7	fa		plx				plx 								; get reference back.
.2eb8	7a		ply				ply
.2eb9	5a		phy				phy
.2eba	da		phx				phx
.2ebb	38		sec				sec 								; set initial value.
.2ebc	20 73 36	jsr $3673			jsr 	GetSetVariable
.2ebf	fa		plx				plx
.2ec0	7a		ply				ply
.2ec1	68		pla				pla
.2ec2	29 20		and #$20			and 	#NSSIInt16
.2ec4	f0 04		beq $2eca			beq 	_CFNotInt16
.2ec6	98		tya				tya
.2ec7	09 80		ora #$80			ora 	#$80
.2ec9	a8		tay				tay
.2eca					_CFNotInt16:
.2eca	8a		txa				txa 								; reference in YA
.2ecb	20 20 2b	jsr $2b20			jsr 	PushIntegerYA
.2ece	a9 a4		lda #$a4			lda 	#C64_TO
.2ed0	20 72 2a	jsr $2a72			jsr 	CheckNextA
.2ed3	20 20 2d	jsr $2d20			jsr 	CompileExpressionAt0 		; terminal value
.2ed6	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ed8	c9 00		cmp #$00			cmp 	#NSSIFloat
.2eda	d0 20		bne $2efc			bne 	_CFFail
.2edc	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; followed by STEP
.2edf	c9 a9		cmp #$a9			cmp 	#C64_STEP
.2ee1	d0 0e		bne $2ef1			bne 	_CFNoStep
.2ee3	20 75 33	jsr $3375			jsr 	GetNext 					; consume it.
.2ee6	20 20 2d	jsr $2d20			jsr 	CompileExpressionAt0 		; terminal value
.2ee9	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2eeb	c9 00		cmp #$00			cmp 	#NSSIFloat
.2eed	d0 0d		bne $2efc			bne 	_CFFail
.2eef	80 05		bra $2ef6			bra 	_CFParametersDone
.2ef1					_CFNoStep:
.2ef1	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.2ef3	20 33 2b	jsr $2b33			jsr 	PushIntegerA
.2ef6					_CFParametersDone:
.2ef6	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2ef8	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2efb	60		rts				rts
.2efc					_CFFail:
.2efc	4c f5 1e	jmp $1ef5		jmp	ErrorV_syntax
.2eff					FNCompile:
.2eff	20 80 33	jsr $3380			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2f02	20 e5 33	jsr $33e5			jsr 	ExtractVariableName
.2f05	e0 00		cpx #$00			cpx 	#0
.2f07	10 32		bpl $2f3b			bpl 	_FNError
.2f09	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2f0a	29 7f		and #$7f			and 	#$7F
.2f0c	aa		tax				tax
.2f0d	98		tya				tya
.2f0e	09 80		ora #$80			ora 	#$80
.2f10	a8		tay				tay
.2f11	20 da 2d	jsr $2dda			jsr 	FindVariable				; does it already exist ?
.2f14	90 25		bcc $2f3b			bcc 	_FNError 					; no.
.2f16	20 67 35	jsr $3567			jsr 	STRMakeOffset 				; convert to a relative address.
.2f19	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2f1b	d0 01		bne $2f1e			bne 	_FNNoBorrow
.2f1d	88		dey				dey
.2f1e					_FNNoBorrow:
.2f1e	3a		dec a				dec 	a
.2f1f	5a		phy				phy 								; save location of routine on stack.
.2f20	48		pha				pha
.2f21	da		phx				phx
.2f22	20 20 2d	jsr $2d20			jsr 	CompileExpressionAt0
.2f25	20 6c 2a	jsr $2a6c			jsr 	CheckNextRParen
.2f28	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.2f2a	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2f2d	68		pla				pla
.2f2e	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2f31	68		pla				pla
.2f32	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2f35	68		pla				pla
.2f36	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.2f39	18		clc				clc
.2f3a	60		rts				rts
.2f3b					_FNError:
.2f3b	4c e8 1e	jmp $1ee8		jmp	ErrorV_value
.2f3e					CommandTables:
>2f3e	07 cb 00 03 43 34 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2f45	07 89 00 03 4a 34 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2f4c	07 8d 00 03 3d 34 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>2f53	07 88 00 03 b9 34 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2f5a	07 85 00 03 99 34 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>2f61	07 84 00 04 ad 34 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>2f68	07 99 00 03 ee 35 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2f6f	07 98 00 04 ee 35 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2f76	07 8f 00 03 f9 36 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>2f7d	07 81 00 03 9b 2e 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>2f84	07 82 00 03 71 35 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>2f8b	07 a1 00 03 b6 33 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>2f92	07 83 00 03 d6 2b 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>2f99	07 87 00 03 37 36 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>2fa0	07 86 00 03 69 2c 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>2fa7	07 96 00 03 f2 2b 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>2fae	07 8b 00 e3 66 34 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>2fb5	08 92 00 ea e3 c5 37 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>2fbd	09 91 00 e1 a9 03 9d 35			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>2fc5	06
>2fc6	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>2fcd	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>2fd4	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>2fda	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>2fe1	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>2fe8	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>2fef	07 9d 00 e3 eb 37 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>2ff6	0a 9f 00 ea e3 fe 37 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>2ffe	c6 06
>3000	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>3006	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>300d	0a ce 92 e3 33 33 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>3015	ad 06
>3017	0a ce 8d e3 33 33 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>301f	ae 06
>3021	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>3027	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>302f	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>3036	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>303d	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>3045	06
>3046	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>304e	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>3056	9a 06
>3058	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>3060	9b 06
>3062	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>306a	9c 06
>306c	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>3074	06
>3075	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>307c	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>3084	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>308c	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>3094	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>309c	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>30a4	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>30ac	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>30b4	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>30bc	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>30c4	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>30cc	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>30d3	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>30db	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>30e3	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>30eb	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>30f3	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>30fb	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>3103	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>310b	00						.byte 	0
.310c					UnaryTables:
>310c	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>3113	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>311b	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>3122	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>3129	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>3130	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>3137	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>313f	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>3146	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>314e	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>3156	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>315e	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>3166	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>316e	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>3176	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>317d	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>3184	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>318b	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>3192	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>3199	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>31a0	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>31a8	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>31b0	0b ca 00 8f ae 03 33 33			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>31b8	91 bd 07
>31bb	07 a8 00 03 52 33 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>31c2	07 a5 00 03 ff 2e 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>31c9	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>31d0	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>31d7	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>31df	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>31e7	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>31ee	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>31f5	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>31fc	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>3204	06
>3205	00						.byte 	0
.3206					GeneratorProcess:
.3206	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.3208	84 2d		sty $2d				sty 	zTemp0+1
.320a	85 2e		sta $2e				sta 	zTemp1 						; first match token
.320c	64 2f		stz $2f				stz 	zTemp1+1
.320e	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.3210	d0 05		bne $3217			bne 	_GPNotShifted
.3212	20 75 33	jsr $3375			jsr 	GetNext 					; get the shifted token
.3215	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.3217					_GPNotShifted:
.3217					_GPSearch:
.3217	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.3219	18		clc				clc
.321a	f0 2f		beq $324b			beq 	_GPExit
.321c	a0 01		ldy #$01			ldy 	#1 							; tokens match
.321e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.3220	c5 2e		cmp $2e				cmp 	zTemp1
.3222	d0 09		bne $322d			bne 	_GPNext
.3224	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.3226	f0 12		beq $323a			beq 	_GPFound
.3228	c8		iny				iny 								; check match.
.3229	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.322b	f0 0d		beq $323a			beq 	_GPFound
.322d					_GPNext:
.322d	18		clc				clc 								; follow to next
.322e	a5 2c		lda $2c				lda 	zTemp0
.3230	72 2c		adc ($2c)			adc 	(zTemp0)
.3232	85 2c		sta $2c				sta 	zTemp0
.3234	90 e1		bcc $3217			bcc 	_GPSearch
.3236	e6 2d		inc $2d				inc 	zTemp0+1
.3238	80 dd		bra $3217			bra 	_GPSearch
.323a					_GPFound:
.323a	18		clc				clc 								; skip to action bytes
.323b	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.323d	69 03		adc #$03			adc 	#3
.323f	85 2c		sta $2c				sta 	zTemp0
.3241	90 02		bcc $3245			bcc 	_GPNoCarry
.3243	e6 2d		inc $2d				inc 	zTemp0+1
.3245					_GPNoCarry:
.3245					_GPLoop:
.3245	20 4c 32	jsr $324c			jsr 	GeneratorExecute 			; execute one command
.3248	90 fb		bcc $3245			bcc 	_GPLoop 					; go back if not completed.
.324a	38		sec				sec 								; return with CS.
.324b					_GPExit:
.324b	60		rts				rts
.324c					GeneratorExecute:
.324c	20 f8 32	jsr $32f8			jsr 	_GEFetchZTemp0 				; get next.
.324f	48		pha				pha 								; split into 2 nibbles
.3250	4a		lsr a				lsr 	a
.3251	4a		lsr a				lsr 	a
.3252	4a		lsr a				lsr		a
.3253	4a		lsr a				lsr 	a
.3254	20 5e 32	jsr $325e			jsr 	_GEExecuteNibble 			; MSB first
.3257	68		pla				pla
.3258	b0 03		bcs $325d			bcs 	_GEHaveCompleted
.325a	20 5e 32	jsr $325e			jsr 	_GEExecuteNibble 			; LSB second
.325d					_GEHaveCompleted:
.325d	60		rts				rts
.325e					_GEExecuteNibble:
.325e	29 0f		and #$0f			and 	#$0F
.3260	0a		asl a				asl 	a
.3261	aa		tax				tax
.3262	7c 65 32	jmp ($3265,x)			jmp 	(_GEExecuteVectors,x)
.3265					_GEExecuteVectors:
>3265	85 32						.word 	_GEXNop 					; 0  (no operation)
>3267	8d 32						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>3269	87 32						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>326b	db 32						.word 	_GEXExecute 				; 3  (run arbitrary code)
>326d	ce 32						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>326f	85 32						.word 	_GEXNop 					; 5
>3271	95 32						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>3273	99 32						.word 	_GEXExitString 				; 7  exit return string type
>3275	9d 32						.word 	_GEXLParam 					; 8  check ( follows
>3277	a1 32						.word 	_GEXRParam 					; 9  check ) follows
>3279	a5 32						.word 	_GEXComma					; A  check , follows
>327b	85 32						.word 	_GEXNop 					; B
>327d	85 32						.word 	_GEXNop 					; C
>327f	85 32						.word 	_GEXNop 					; D
>3281	b5 32						.word 	_GEXNumber 					; E  compile get any number
>3283	c0 32						.word 	_GEXString 					; F  compile get any string
.3285					_GEXNop:
.3285	18		clc				clc
.3286	60		rts				rts
.3287					_GEXToken2:
.3287	20 f8 32	jsr $32f8			jsr 	_GEFetchZTemp0
.328a	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.328d					_GEXToken1:
.328d	20 f8 32	jsr $32f8			jsr 	_GEFetchZTemp0
.3290	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3293	18		clc				clc
.3294	60		rts				rts
.3295					_GEXExitNumber:
.3295	a9 00		lda #$00			lda 	#NSSIFloat
.3297	38		sec				sec
.3298	60		rts				rts
.3299					_GEXExitString:
.3299	a9 40		lda #$40			lda 	#NSSString
.329b	38		sec				sec
.329c	60		rts				rts
.329d					_GEXLParam:
.329d	a9 28		lda #$28			lda 	#"("
.329f	80 06		bra $32a7			bra 	_GEXCheck
.32a1					_GEXRParam:
.32a1	a9 29		lda #$29			lda 	#")"
.32a3	80 02		bra $32a7			bra 	_GEXCheck
.32a5					_GEXComma:
.32a5	a9 2c		lda #$2c			lda 	#","
.32a7					_GEXCheck:
.32a7	85 30		sta $30				sta 	zTemp2 						; save match
.32a9	20 80 33	jsr $3380			jsr 	GetNextNonSpace 			; get next skipping spaces
.32ac	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.32ae	d0 02		bne $32b2			bne 	_GEXSyntax
.32b0	18		clc				clc
.32b1	60		rts				rts
.32b2					_GEXSyntax:
.32b2	4c f5 1e	jmp $1ef5		jmp	ErrorV_syntax
.32b5					_GEXNumber:
.32b5	20 01 33	jsr $3301			jsr 	GEXCompileExpression 		; compile expression
.32b8	29 40		and #$40			and 	#NSSTypeMask
.32ba	c9 00		cmp #$00			cmp  	#NSSIFloat
.32bc	d0 0d		bne $32cb			bne 	_GEXType
.32be	18		clc				clc
.32bf	60		rts				rts
.32c0					_GEXString:
.32c0	20 01 33	jsr $3301			jsr 	GEXCompileExpression 		; compile expression
.32c3	29 40		and #$40			and 	#NSSTypeMask
.32c5	c9 40		cmp #$40			cmp  	#NSSString
.32c7	d0 02		bne $32cb			bne 	_GEXType
.32c9	18		clc				clc
.32ca	60		rts				rts
.32cb					_GEXType:
.32cb	4c 05 1f	jmp $1f05		jmp	ErrorV_type
.32ce					_GEXChannelExec:
.32ce	20 11 33	jsr $3311			jsr 	ChannelPrefix 				; set up default
.32d1	20 db 32	jsr $32db			jsr 	_GEXExecute
.32d4	08		php				php
.32d5	20 2c 33	jsr $332c			jsr 	ChannelPostfix 				; replace default.
.32d8	28		plp				plp
.32d9	60		rts				rts
>32da	db						.byte 	$DB 						; causes a break in the emulator
.32db					_GEXExecute:
.32db	20 f8 32	jsr $32f8			jsr 	_GEFetchZTemp0 				; get vector
.32de	85 30		sta $30				sta 	zTemp2
.32e0	20 f8 32	jsr $32f8			jsr 	_GEFetchZTemp0
.32e3	85 31		sta $31				sta 	zTemp2+1
.32e5	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.32e7	da		phx				phx
.32e8	a6 2d		ldx $2d				ldx 	zTemp0+1
.32ea	da		phx				phx
.32eb	20 f5 32	jsr $32f5			jsr 	_GECallZTemp2 				; execute code
.32ee	fa		plx				plx 								; recover generation exec
.32ef	86 2d		stx $2d				stx 	zTemp0+1
.32f1	fa		plx				plx
.32f2	86 2c		stx $2c				stx 	zTemp0
.32f4	60		rts				rts
.32f5					_GECallZTemp2:
.32f5	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.32f8					_GEFetchZTemp0:
.32f8	b2 2c		lda ($2c)			lda 	(zTemp0)
.32fa	e6 2c		inc $2c				inc 	zTemp0
.32fc	d0 02		bne $3300			bne 	_GEFZ0Skip
.32fe	e6 2d		inc $2d				inc 	zTemp0+1
.3300					_GEFZ0Skip:
.3300	60		rts				rts
.3301					GEXCompileExpression:
.3301	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.3303	da		phx				phx
.3304	a6 2d		ldx $2d				ldx 	zTemp0+1
.3306	da		phx				phx
.3307	20 20 2d	jsr $2d20			jsr 	CompileExpressionAt0 		; compile expression.
.330a	fa		plx				plx 								; recover generation exec
.330b	86 2d		stx $2d				stx 	zTemp0+1
.330d	fa		plx				plx
.330e	86 2c		stx $2c				stx 	zTemp0
.3310	60		rts				rts
.3311					ChannelPrefix:
.3311	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.3313	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3316	20 01 33	jsr $3301			jsr 	GEXCompileExpression 		; channel #
.3319	29 40		and #$40			and 	#NSSTypeMask
.331b	c9 00		cmp #$00			cmp 	#NSSIFloat
.331d	d0 0a		bne $3329			bne 	_CPXType
.331f	20 68 2a	jsr $2a68			jsr 	CheckNextComma 				; check , follows.
.3322	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.3324	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3327	18		clc				clc
.3328	60		rts				rts
.3329					_CPXType:
.3329	4c 05 1f	jmp $1f05		jmp	ErrorV_type
.332c					ChannelPostfix:
.332c	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.332e	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3331	18		clc				clc
.3332	60		rts				rts
.3333					OptionalParameterCompile:
.3333	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; what follows.
.3336	c9 2c		cmp #$2c			cmp 	#","
.3338	d0 0e		bne $3348			bne 	_MidDefault
.333a	20 75 33	jsr $3375			jsr 	GetNext 					; consume ,
.333d	20 20 2d	jsr $2d20			jsr 	CompileExpressionAt0
.3340	29 40		and #$40			and 	#NSSTypeMask
.3342	c9 00		cmp #$00			cmp 	#NSSIFloat
.3344	d0 09		bne $334f			bne 	MidFailType
.3346	80 05		bra $334d			bra 	_MidComplete
.3348					_MidDefault:
.3348	a9 ff		lda #$ff			lda 	#255 						; default of 255
.334a	20 33 2b	jsr $2b33			jsr 	PushIntegerA
.334d					_MidComplete:
.334d	18		clc				clc
.334e	60		rts				rts
.334f					MidFailType:
.334f	4c 05 1f	jmp $1f05		jmp	ErrorV_type
.3352					NotUnaryCompile:
.3352	ad d5 2d	lda $2dd5			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.3355	20 22 2d	jsr $2d22			jsr 	CompileExpressionAtA 		; evaluate at that level
.3358	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.335a	c9 00		cmp #$00			cmp 	#NSSIFloat
.335c	d0 f1		bne $334f			bne 	MidFailType
.335e	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.3360	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3363	60		rts				rts
.3364					LookNext:
.3364	b2 7a		lda ($7a)			lda 	(srcPtr)
.3366	60		rts				rts
.3367					LookNextNonSpace:
.3367	b2 7a		lda ($7a)			lda 	(srcPtr)
.3369	c9 20		cmp #$20			cmp		#' '
.336b	f0 03		beq $3370			beq 	_LNNSkip
.336d	c9 00		cmp #$00			cmp 	#0
.336f	60		rts				rts
.3370					_LNNSkip:
.3370	20 75 33	jsr $3375			jsr 	GetNext
.3373	80 f2		bra $3367			bra 	LookNextNonSpace
.3375					GetNext:
.3375	b2 7a		lda ($7a)			lda 	(srcPtr) 					; get next
.3377	e6 7a		inc $7a				inc 	srcPtr
.3379	d0 02		bne $337d			bne 	_GNSkip
.337b	e6 7b		inc $7b				inc 	srcPtr+1
.337d					_GNSkip:
.337d	c9 00		cmp #$00			cmp 	#0
.337f	60		rts				rts
.3380					GetNextNonSpace:
.3380	20 75 33	jsr $3375			jsr 	GetNext
.3383	c9 20		cmp #$20			cmp 	#' '
.3385	f0 f9		beq $3380			beq 	GetNextNonSpace
.3387	c9 00		cmp #$00			cmp 	#0
.3389	60		rts				rts
.338a					CharIsDigit:
.338a	c9 30		cmp #$30			cmp 	#"0"
.338c	90 06		bcc $3394			bcc 	CCFalse
.338e	c9 3a		cmp #$3a			cmp 	#"9"+1
.3390	b0 02		bcs $3394			bcs 	CCFalse
.3392					CCTrue:
.3392	38		sec				sec
.3393	60		rts				rts
.3394					CCFalse:
.3394	18		clc				clc
.3395	60		rts				rts
.3396					CharIsAlpha:
.3396	c9 41		cmp #$41			cmp 	#"A"
.3398	90 fa		bcc $3394			bcc 	CCFalse
.339a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.339c	b0 f6		bcs $3394			bcs 	CCFalse
.339e	80 f2		bra $3392			bra 	CCTrue
.33a0					ConvertHexStyle:
.33a0	38		sec				sec
.33a1	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.33a3	90 ef		bcc $3394			bcc 	CCFalse
.33a5	c9 0a		cmp #$0a			cmp 	#9+1
.33a7	90 e9		bcc $3392			bcc 	CCTrue
.33a9	38		sec				sec 								; shift into hex space A=>0 Z=>25
.33aa	e9 11		sbc #$11			sbc 	#"A"-"0"
.33ac	90 e6		bcc $3394			bcc 	CCFalse
.33ae	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.33b0	b0 e2		bcs $3394			bcs 	CCFalse
.33b2	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.33b4	80 dc		bra $3392			bra 	CCTrue
.33b6					CommandGET:
.33b6	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; # follows ?
.33b9	c9 23		cmp #$23			cmp 	#"#"
.33bb	d0 0d		bne $33ca			bne 	CommandGetBody
.33bd	20 75 33	jsr $3375			jsr 	GetNext 					; consume #
.33c0	20 11 33	jsr $3311			jsr 	ChannelPrefix 				; do it as GET#
.33c3	20 ca 33	jsr $33ca			jsr 	CommandGetBody
.33c6	20 2c 33	jsr $332c			jsr 	ChannelPostfix
.33c9	60		rts				rts
.33ca					CommandGetBody:
.33ca	20 80 33	jsr $3380			jsr 	GetNextNonSpace 			; get the first character
.33cd	20 c1 36	jsr $36c1			jsr 	GetReferenceTerm 			; identify variable to assign to
.33d0	48		pha				pha
.33d1	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.33d3	c9 40		cmp #$40			cmp 	#NSSString
.33d5	d0 0b		bne $33e2			bne 	_CGType
.33d7	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.33d9	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.33dc	38		sec				sec
.33dd	68		pla				pla
.33de	20 73 36	jsr $3673			jsr		GetSetVariable
.33e1	60		rts				rts
.33e2					_CGType:
.33e2	4c 05 1f	jmp $1f05		jmp	ErrorV_type
.33e5					ExtractVariableName:
.33e5	20 96 33	jsr $3396			jsr 	CharIsAlpha
.33e8	90 50		bcc $343a			bcc 	_IVSyntax
.33ea	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.33ec	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.33ee	64 2f		stz $2f				stz 	zTemp1+1
.33f0	20 64 33	jsr $3364			jsr 	LookNext 					; is there a second character ?
.33f3	20 96 33	jsr $3396			jsr 	CharIsAlpha  				; must be alphanumeric
.33f6	b0 05		bcs $33fd			bcs 	_IVHasSecond
.33f8	20 8a 33	jsr $338a			jsr 	CharIsDigit
.33fb	90 07		bcc $3404			bcc 	_IVCheckType
.33fd					_IVHasSecond:
.33fd	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.33ff	85 2f		sta $2f				sta 	zTemp1+1
.3401					_IVGetNextCheck:
.3401	20 75 33	jsr $3375			jsr 	GetNext 					; consume it
.3404					_IVCheckType:
.3404	20 64 33	jsr $3364			jsr 	LookNext					; check if string follows.
.3407	20 96 33	jsr $3396			jsr 	CharIsAlpha
.340a	b0 f5		bcs $3401			bcs 	_IVGetNextCheck
.340c	20 8a 33	jsr $338a			jsr 	CharIsDigit
.340f	b0 f0		bcs $3401			bcs 	_IVGetNextCheck
.3411	a2 40		ldx #$40			ldx 	#NSSString
.3413	c9 24		cmp #$24			cmp 	#"$"
.3415	f0 06		beq $341d			beq 	_IVHasType
.3417	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.3419	c9 25		cmp #$25			cmp 	#"%"
.341b	d0 08		bne $3425			bne 	_IVCheckArray
.341d					_IVHasType:
.341d	8a		txa				txa 								; Or X into zTemp1
.341e	05 2e		ora $2e				ora 	zTemp1
.3420	85 2e		sta $2e				sta 	zTemp1
.3422	20 75 33	jsr $3375			jsr 	GetNext 					; consume it
.3425					_IVCheckArray:
.3425	20 64 33	jsr $3364			jsr 	LookNext 					; check if array follows
.3428	c9 28		cmp #$28			cmp 	#"("
.342a	d0 09		bne $3435			bne 	_IVNotArray
.342c	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.342e	09 80		ora #$80			ora 	#NSSArray
.3430	85 2e		sta $2e				sta 	zTemp1
.3432	20 75 33	jsr $3375			jsr 	GetNext 					; consume it
.3435					_IVNotArray:
.3435	a6 2e		ldx $2e				ldx 	zTemp1
.3437	a4 2f		ldy $2f				ldy 	zTemp1+1
.3439	60		rts				rts
.343a					_IVSyntax:
.343a	4c f5 1e	jmp $1ef5		jmp	ErrorV_syntax
.343d					CommandGOSUB:
.343d	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.343f	20 50 34	jsr $3450			jsr 	CompileBranchCommand
.3442	60		rts				rts
.3443					CommandGOAlt:
.3443	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.3445	20 72 2a	jsr $2a72			jsr 	CheckNextA
.3448	80 00		bra $344a			bra 	CommandGOTO
.344a					CommandGOTO:
.344a	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.344c	20 50 34	jsr $3450			jsr 	CompileBranchCommand
.344f	60		rts				rts
.3450					CompileBranchCommand:
.3450	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte 				; write the command out.
.3453	20 80 33	jsr $3380			jsr 	GetNextNonSpace
.3456	20 c9 35	jsr $35c9			jsr 	ParseConstant 				; get constant into YA
.3459	90 08		bcc $3463			bcc 	_CBCSyntax
.345b	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte				; and compile the actual line number
.345e	98		tya				tya
.345f	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3462	60		rts				rts
.3463					_CBCSyntax:
.3463	4c f5 1e	jmp $1ef5		jmp	ErrorV_syntax
.3466					CommandIF:
.3466	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; what follows the tests ?
.3469	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.346b	f0 0f		beq $347c			beq 	_CIGoto
.346d	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.346f	20 72 2a	jsr $2a72			jsr 	CheckNextA
.3472	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; THEN <number>
.3475	20 8a 33	jsr $338a			jsr 	CharIsDigit
.3478	b0 05		bcs $347f			bcs 	_CIGoto2
.347a	80 09		bra $3485			bra 	CompileGotoEOL
.347c					_CIGoto:
.347c	20 75 33	jsr $3375			jsr 	GetNext
.347f					_CIGoto2:
.347f	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.3481	20 50 34	jsr $3450			jsr 	CompileBranchCommand
.3484	60		rts				rts
.3485					CompileGotoEOL:
.3485	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.3487	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.348a	20 03 2a	jsr $2a03			jsr 	GetLineNumber 				; Get the current line number => YA
.348d	1a		inc a				inc 	a 							; and branch to +1
.348e	d0 01		bne $3491			bne 	_CGENoCarry
.3490	c8		iny				iny
.3491					_CGENoCarry:
.3491	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3494	98		tya				tya
.3495	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3498	60		rts				rts
.3499					CommandINPUT:
.3499	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; check for "
.349c	c9 22		cmp #$22			cmp 	#'"'
.349e	d0 0d		bne $34ad			bne 	CommandINPUTStream
.34a0	20 20 2d	jsr $2d20			jsr 	CompileExpressionAt0
.34a3	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.34a5	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.34a8	a9 2c		lda #$2c			lda 	#","
.34aa	20 68 2a	jsr $2a68			jsr 	CheckNextComma
.34ad					CommandINPUTStream:
.34ad	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.34af	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.34b2	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.34b4	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.34b6	4c 3b 36	jmp $363b			jmp 	CommandReadInputCommon
.34b9					CommandLET:
.34b9	20 80 33	jsr $3380			jsr 	GetNextNonSpace 			; get the first character
.34bc					CommandLETHaveFirst:
.34bc	20 c1 36	jsr $36c1			jsr 	GetReferenceTerm 			; identify variable to assign to
.34bf	da		phx				phx 								; save target on the stack.
.34c0	5a		phy				phy
.34c1	48		pha				pha
.34c2	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.34c4	20 72 2a	jsr $2a72			jsr 	CheckNextA
.34c7	20 20 2d	jsr $2d20			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.34ca	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.34cc	68		pla				pla 								; get type of assignment
.34cd	48		pha				pha
.34ce	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.34d0	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.34d2	d0 17		bne $34eb			bne 	_CLType
.34d4	68		pla				pla 								; restore and compile save code
.34d5	7a		ply				ply
.34d6	fa		plx				plx
.34d7	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.34d9	f0 05		beq $34e0			beq 	_CLTIString
.34db	38		sec				sec
.34dc	20 73 36	jsr $3673			jsr		GetSetVariable
.34df	60		rts				rts
.34e0					_CLTIString:
.34e0	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.34e2	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.34e5	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.34e7	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.34ea	60		rts				rts
.34eb					_CLType:
.34eb	4c 05 1f	jmp $1f05		jmp	ErrorV_type
.34ee					STRMarkLine:
.34ee	48		pha				pha
.34ef	38		sec				sec 								; allocate 4 bytes (line #,address)
.34f0	ad c8 06	lda $06c8			lda 	lineNumberTable 			; and copy to zTemp0
.34f3	e9 04		sbc #$04			sbc 	#4
.34f5	8d c8 06	sta $06c8			sta 	lineNumberTable
.34f8	85 2c		sta $2c				sta 	zTemp0
.34fa	ad c9 06	lda $06c9			lda 	lineNumberTable+1
.34fd	e9 00		sbc #$00			sbc 	#0
.34ff	8d c9 06	sta $06c9			sta 	lineNumberTable+1
.3502	85 2d		sta $2d				sta 	zTemp0+1
.3504	68		pla				pla
.3505	92 2c		sta ($2c)			sta 	(zTemp0) 					; line # save it in +0,+1
.3507	98		tya				tya
.3508	a0 01		ldy #$01			ldy 	#1
.350a	91 2c		sta ($2c),y			sta 	(zTemp0),y
.350c	a5 2a		lda $2a				lda 	objPtr 						; save current address in +2,+3
.350e	c8		iny				iny
.350f	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3511	a5 2b		lda $2b				lda 	objPtr+1
.3513	c8		iny				iny
.3514	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3516	60		rts				rts
.3517					STRFindLine:
.3517	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.3519	84 2d		sty $2d				sty 	zTemp0+1
.351b	ad c1 06	lda $06c1			lda 	compilerEndHigh 			; work backwards through table
.351e	85 2f		sta $2f				sta 	zTemp1+1
.3520	64 2e		stz $2e				stz 	zTemp1
.3522					_STRSearch:
.3522	20 59 35	jsr $3559			jsr 	_STRPrevLine 				; look at previous record.
.3525	a0 01		ldy #$01			ldy 	#1
.3527	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.3529	c5 2c		cmp $2c				cmp 	zTemp0
.352b	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.352d	e5 2d		sbc $2d				sbc 	zTemp0+1
.352f	b0 0b		bcs $353c			bcs 	_STRFound 					; >=
.3531					_STRNext:
.3531	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.3533	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3535	c9 ff		cmp #$ff			cmp 	#$FF
.3537	d0 e9		bne $3522			bne 	_STRSearch
.3539	4c 4f 1f	jmp $1f4f		jmp	ErrorV_internal
.353c					_STRFound:
.353c	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.353e	45 2c		eor $2c				eor 	zTemp0
.3540	d0 06		bne $3548			bne 	_STRDifferent
.3542	b2 2e		lda ($2e)			lda 	(zTemp1)
.3544	45 2c		eor $2c				eor 	zTemp0
.3546	f0 02		beq $354a			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.3548					_STRDifferent:
.3548	a9 ff		lda #$ff			lda 	#$FF
.354a					_STROut:
.354a	18		clc				clc  								; set carry if different, e.g. > rather than >=
.354b	69 ff		adc #$ff			adc 	#255
.354d	08		php				php
.354e	c8		iny				iny 								; address into YA
.354f	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3551	48		pha				pha
.3552	c8		iny				iny
.3553	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3555	a8		tay				tay
.3556	68		pla				pla
.3557	28		plp				plp
.3558	60		rts				rts
.3559					_STRPrevLine:
.3559	38		sec				sec 								; move backwards one entry.
.355a	a5 2e		lda $2e				lda 	zTemp1
.355c	e9 04		sbc #$04			sbc 	#4
.355e	85 2e		sta $2e				sta 	zTemp1
.3560	a5 2f		lda $2f				lda 	zTemp1+1
.3562	e9 00		sbc #$00			sbc 	#0
.3564	85 2f		sta $2f				sta 	zTemp1+1
.3566	60		rts				rts
.3567					STRMakeOffset:
.3567	18		clc				clc 								; borrow 1
.3568	e5 2a		sbc $2a				sbc 	objPtr
.356a	48		pha				pha
.356b	98		tya				tya
.356c	e5 2b		sbc $2b				sbc 	objPtr+1
.356e	a8		tay				tay
.356f	68		pla				pla
.3570	60		rts				rts
.3571					CommandNEXT:
.3571	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.3574	20 96 33	jsr $3396			jsr 	CharIsAlpha 				; if not alpha , error
.3577	90 0c		bcc $3585			bcc 	_CNNoReferenceGiven
.3579	20 75 33	jsr $3375			jsr 	GetNext
.357c	20 c1 36	jsr $36c1			jsr 	GetReferenceTerm 			; figure out the reference.
.357f	8a		txa				txa 								; reference in YA
.3580	20 20 2b	jsr $2b20			jsr 	PushIntegerYA 				; write it out.
.3583	80 06		bra $358b			bra 	_CNParametersDone
.3585					_CNNoReferenceGiven:
.3585	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.3587	a8		tay				tay
.3588	20 20 2b	jsr $2b20			jsr 	PushIntegerYA 				; write it out.
.358b					_CNParametersDone:
.358b	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.358d	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3590	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; look for ,
.3593	c9 2c		cmp #$2c			cmp 	#","
.3595	d0 05		bne $359c			bne 	_CNExit
.3597	20 75 33	jsr $3375			jsr 	GetNext 					; consume ,
.359a	80 d5		bra $3571			bra 	CommandNEXT 				; and go round.
.359c					_CNExit:
.359c	60		rts				rts
.359d					CommandON:
.359d	20 80 33	jsr $3380			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.35a0	48		pha				pha 								; save on stack
.35a1	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.35a3	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.35a5	f0 09		beq $35b0			beq 	_COCreateLoop
.35a7	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.35a9	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.35ab	f0 03		beq $35b0			beq 	_COCreateLoop
.35ad	4c f5 1e	jmp $1ef5		jmp	ErrorV_syntax
.35b0					_COCreateLoop:
.35b0	8a		txa				txa 								; compile a goto/gosub somewhere
.35b1	da		phx				phx
.35b2	20 50 34	jsr $3450			jsr 	CompileBranchCommand
.35b5	fa		plx				plx
.35b6	20 67 33	jsr $3367			jsr 	LookNextNonSpace			; ',' follows
.35b9	c9 2c		cmp #$2c			cmp 	#","
.35bb	d0 0a		bne $35c7			bne 	_COComplete 				; if so, more line numbers
.35bd	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.35bf	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.35c2	20 75 33	jsr $3375			jsr 	GetNext
.35c5	80 e9		bra $35b0			bra 	_COCreateLoop
.35c7					_COComplete:
.35c7	68		pla				pla 								; throw GOTO/GOSUB
.35c8	60		rts				rts
.35c9					ParseConstant:
.35c9	a2 00		ldx #$00			ldx 	#0
.35cb	20 1b 24	jsr $241b			jsr 	FloatEncodeStart 			; send first
.35ce					_ParseLoop:
.35ce	20 64 33	jsr $3364			jsr 	LookNext 					; send subsequent
.35d1	20 1e 24	jsr $241e			jsr 	FloatEncodeContinue
.35d4	90 05		bcc $35db			bcc 	_ParseDone
.35d6	20 75 33	jsr $3375			jsr 	GetNext 					; consume it
.35d9	80 f3		bra $35ce			bra 	_ParseLoop
.35db					_ParseDone:
.35db	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.35dd	29 80		and #$80			and 	#$80
.35df	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.35e1	15 56		ora $56,x			ora 	NSMantissa2,x
.35e3	15 62		ora $62,x			ora 	NSMantissa3,x
.35e5	18		clc				clc
.35e6	d0 05		bne $35ed			bne 	_ParseExit 					; exit with CC if need float to compile
.35e8	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.35ea	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.35ec	38		sec				sec
.35ed					_ParseExit:
.35ed	60		rts				rts
.35ee					CommandPRINT:
.35ee	20 67 33	jsr $3367			jsr 	LookNextNonSpace			; what follows ?
.35f1	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.35f3	f0 1f		beq $3614			beq 	_CPCheckEnd
.35f5	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.35f7	f0 16		beq $360f			beq 	_CPTabCheckEnd
.35f9	20 2b 36	jsr $362b			jsr 	_CPAtEnd 					; check for : and EOL
.35fc	b0 22		bcs $3620			bcs 	_CPExitCR 					; exit with CR
.35fe	20 20 2d	jsr $2d20			jsr 	CompileExpressionAt0 		; so it is something to print
.3601	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.3603	29 40		and #$40			and 	#NSSString 					; if string
.3605	d0 02		bne $3609			bne 	_CPOut
.3607	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.3609					_CPOut:
.3609	8a		txa				txa 								; print that thing
.360a	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.360d	80 df		bra $35ee			bra 	CommandPRINT 				; and loop round/
.360f					_CPTabCheckEnd:
.360f	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.3611	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3614					_CPCheckEnd:
.3614	20 75 33	jsr $3375			jsr 	GetNext 					; consume it.
.3617	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; what follows ?
.361a	20 2b 36	jsr $362b			jsr 	_CPAtEnd 					; reached end
.361d	90 cf		bcc $35ee			bcc 	CommandPRINT 				; no, loop back
.361f	60		rts				rts
.3620					_CPExitCR:
.3620	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.3622	20 33 2b	jsr $2b33			jsr 	PushIntegerA
.3625	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.3627	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.362a	60		rts				rts
.362b					_CPAtEnd:
.362b	c9 00		cmp #$00			cmp 	#0
.362d	f0 06		beq $3635			beq 	_CPIsEnd
.362f	c9 3a		cmp #$3a			cmp 	#":"
.3631	f0 02		beq $3635			beq 	_CPIsEnd
.3633	18		clc				clc
.3634	60		rts				rts
.3635					_CPIsEnd:
.3635	38		sec				sec
.3636	60		rts				rts
.3637					CommandREAD:
.3637	a2 b2		ldx #$b2			ldx 	#PCD_READ
.3639	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.363b					CommandReadInputCommon:
.363b	8e c6 06	stx $06c6			stx 	numberPCode
.363e	8c c7 06	sty $06c7			sty 	stringPCode
.3641					_CRLoop:
.3641	20 80 33	jsr $3380			jsr 	GetNextNonSpace 			; first char of identifier
.3644	20 96 33	jsr $3396			jsr 	CharIsAlpha 				; check A-Z
.3647	90 27		bcc $3670			bcc 	_CRSyntax
.3649	20 c1 36	jsr $36c1			jsr 	GetReferenceTerm 			; get the variable.
.364c	48		pha				pha 								; save type.
.364d	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.364f	c9 40		cmp #$40			cmp 	#NSSString
.3651	f0 05		beq $3658			beq 	_CRString
.3653	ad c6 06	lda $06c6			lda 	numberPCode 				; output read/input
.3656	80 03		bra $365b			bra 	_CRHaveType
.3658					_CRString:
.3658	ad c7 06	lda $06c7			lda 	stringPCode					; output read$/input$
.365b					_CRHaveType:
.365b	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte 				; so we have one typed data item.
.365e	68		pla				pla 								; restore type
.365f	38		sec				sec  								; write update code.
.3660	20 73 36	jsr $3673			jsr 	GetSetVariable
.3663	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; , follows ?
.3666	c9 2c		cmp #$2c			cmp 	#","
.3668	d0 05		bne $366f			bne 	_CRExit 					; if not, end of READ.
.366a	20 75 33	jsr $3375			jsr 	GetNext 					; consume comma
.366d	80 d2		bra $3641			bra 	_CRLoop 					; keep going
.366f					_CRExit:
.366f	60		rts				rts
.3670					_CRSyntax:
.3670	4c f5 1e	jmp $1ef5		jmp	ErrorV_syntax
.06c6					numberPCode:
>06c6							.fill 	1
.06c7					stringPCode:
>06c7							.fill 	1
.3673					GetSetVariable:
.3673	08		php				php 								; save direction on stack
.3674	c0 00		cpy #$00			cpy 	#$00
.3676	30 21		bmi $3699			bmi 	_GSVReadWriteSpecial
.3678	c9 00		cmp #$00			cmp 	#$00
.367a	30 33		bmi $36af			bmi 	_GSVArray
.367c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.367e	4a		lsr a				lsr 	a 							; divide by 2
.367f	09 40		ora #$40			ora 	#64 						; and set bit 6.
.3681	28		plp				plp
.3682	90 02		bcc $3686			bcc 	_GSVNotWrite
.3684	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.3686					_GSVNotWrite:
.3686	85 2c		sta $2c				sta 	zTemp0
.3688	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.3689	4a		lsr a				lsr 	a
.368a	a8		tay				tay
.368b	8a		txa				txa
.368c	6a		ror a				ror 	a
.368d	aa		tax				tax
.368e	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.368f	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.3691	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3694	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.3695	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3698	60		rts				rts
.3699					_GSVReadWriteSpecial:
.3699	28		plp				plp
.369a	b0 10		bcs $36ac			bcs 	_GSVSyntax
.369c	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.369e	f0 06		beq $36a6			beq 	_GSVRWString
.36a0	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.36a2	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.36a5	60		rts				rts
.36a6					_GSVRWString:
.36a6	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.36a8	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.36ab	60		rts				rts
.36ac					_GSVSyntax:
.36ac	4c f5 1e	jmp $1ef5		jmp	ErrorV_syntax
.36af					_GSVArray:
.36af	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.36b1	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.36b2	4a		lsr a				lsr 	a
.36b3	4a		lsr a				lsr 	a
.36b4	4a		lsr a				lsr 	a
.36b5	4a		lsr a				lsr 	a
.36b6	28		plp				plp 								; if writing array then set bit 2.
.36b7	90 02		bcc $36bb			bcc 	_GSVANotWrite
.36b9	09 04		ora #$04			ora 	#4
.36bb					_GSVANotWrite:
.36bb	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.36bd	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte 				; and write it out
.36c0	60		rts				rts
.36c1					GetReferenceTerm:
.36c1	20 e5 33	jsr $33e5			jsr 	ExtractVariableName 		; get name & type info
.36c4	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.36c6	30 10		bmi $36d8			bmi 	_GRTArray
.36c8	da		phx				phx 								; save type on stack
.36c9	20 da 2d	jsr $2dda			jsr 	FindVariable 				; find it
.36cc	b0 06		bcs $36d4			bcs 	_GRTNoCreate 				; create if required.
.36ce	20 65 2b	jsr $2b65			jsr 	CreateVariableRecord 		; create a variable.
.36d1	20 ba 2b	jsr $2bba			jsr 	AllocateBytesForType 		; allocate memory for it
.36d4					_GRTNoCreate:
.36d4	68		pla				pla 								; get type back, strip out type information.
.36d5	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.36d7	60		rts				rts
.36d8					_GRTArray:
.36d8	da		phx				phx 								; save type information
.36d9	20 da 2d	jsr $2dda			jsr 	FindVariable 				; read its data, the base address in YX
.36dc	90 18		bcc $36f6			bcc 	_GRTUndeclared 				; undeclared array.
.36de	da		phx				phx 								; save base address
.36df	5a		phy				phy
.36e0	20 b1 2c	jsr $2cb1			jsr 	OutputIndexGroup 			; create an index group and generate them
.36e3	7a		ply				ply 								; get the array base address into YX
.36e4	fa		plx				plx
.36e5	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.36e7	18		clc				clc
.36e8	20 73 36	jsr $3673			jsr 	GetSetVariable 				; load the address of the array structure.
.36eb	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.36ed	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.36f0	68		pla				pla 								; and the type data into A
.36f1	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.36f3	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.36f5	60		rts				rts
.36f6					_GRTUndeclared:
.36f6	4c ac 1f	jmp $1fac		jmp	ErrorV_undeclared
.36f9					CommandREM:
.36f9	20 64 33	jsr $3364			jsr 	LookNext
.36fc	f0 05		beq $3703			beq 	_CRExit
.36fe	20 75 33	jsr $3375			jsr 	GetNext
.3701	80 f6		bra $36f9			bra 	CommandREM
.3703					_CRExit:
.3703	60		rts				rts
.3704					STRReset:
.3704	ad c0 06	lda $06c0			lda	 	compilerStartHigh 			; set up the two table pointers
.3707	8d cb 06	sta $06cb			sta 	variableListEnd+1
.370a	9c ca 06	stz $06ca			stz 	variableListEnd
.370d	ad c1 06	lda $06c1			lda 	compilerEndHigh
.3710	8d c9 06	sta $06c9			sta 	lineNumberTable+1
.3713	9c c8 06	stz $06c8			stz 	lineNumberTable
.3716	ad ca 06	lda $06ca			lda 	variableListEnd
.3719	85 2d		sta $2d				sta 	zTemp0+1
.371b	64 2c		stz $2c				stz 	zTemp0
.371d	a9 00		lda #$00			lda 	#0
.371f	92 2c		sta ($2c)			sta 	(zTemp0)
.3721	a9 00		lda #$00			lda 	#((0) & $FF)
.3723	8d cc 06	sta $06cc			sta 	0+freeVariableMemory
.3726	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.3728	8d cd 06	sta $06cd			sta 	1+freeVariableMemory
.372b	60		rts				rts
.06c8					lineNumberTable:
>06c8							.fill 	2
.06ca					variableListEnd:
>06ca							.fill 	2
.06cc					freeVariableMemory:
>06cc							.fill 	2
.372c					CompileTerm:
.372c	20 80 33	jsr $3380			jsr 	GetNextNonSpace 			; get first non space character.
.372f	30 72		bmi $37a3			bmi 	_CTUnaryFunctions
.3731	20 8a 33	jsr $338a			jsr 	CharIsDigit 				; found a number
.3734	b0 3a		bcs $3770			bcs 	_CTDigit
.3736	c9 2e		cmp #$2e			cmp 	#"."
.3738	f0 36		beq $3770			beq 	_CTDigit
.373a	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.373c	f0 43		beq $3781			beq 	_CTString
.373e	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.3740	f0 28		beq $376a			beq 	_CTOtherBase
.3742	c9 24		cmp #$24			cmp 	#"$"
.3744	f0 24		beq $376a			beq 	_CTOtherBase
.3746	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.3748	f0 17		beq $3761			beq 	_CTBrackets
.374a	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.374c	90 10		bcc $375e			bcc 	_CTSyntax
.374e	c9 5b		cmp #$5b			cmp 	#"Z"+1
.3750	b0 0c		bcs $375e			bcs 	_CTSyntax
.3752	20 c1 36	jsr $36c1			jsr 	GetReferenceTerm 			; figure out what it is.
.3755	48		pha				pha 								; save type on stack
.3756	18		clc				clc 								; read it
.3757	20 73 36	jsr $3673			jsr 	GetSetVariable
.375a	68		pla				pla
.375b	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.375d	60		rts				rts
.375e					_CTSyntax:
.375e	4c f5 1e	jmp $1ef5		jmp	ErrorV_syntax
.3761					_CTBrackets:
.3761	20 20 2d	jsr $2d20			jsr 	CompileExpressionAt0
.3764	48		pha				pha
.3765	20 6c 2a	jsr $2a6c			jsr 	CheckNextRParen
.3768	68		pla				pla
.3769	60		rts				rts
.376a					_CTOtherBase:
.376a	20 b8 29	jsr $29b8			jsr 	InlineNonDecimal 			; non decimal constant handler
.376d	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.376f	60		rts				rts
.3770					_CTDigit:
.3770	20 c9 35	jsr $35c9			jsr 	ParseConstant 				; parse out an number, first is in A already.
.3773	90 06		bcc $377b			bcc	 	_CTFloat 					; have a float or long int.
.3775	20 20 2b	jsr $2b20			jsr 	PushIntegerYA 				; code to push on stack
.3778	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.377a	60		rts				rts
.377b					_CTFloat:
.377b	20 42 2b	jsr $2b42			jsr 	PushFloatCommand			; code to push float
.377e	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.3780	60		rts				rts
.3781					_CTString:
.3781	20 41 2a	jsr $2a41			jsr 	BufferClear 				; copy it to the buffer
.3784					_CTStringLoop:
.3784	20 64 33	jsr $3364			jsr 	LookNext 					; reached EOL/EOS
.3787	f0 d5		beq $375e			beq 	_CTSyntax
.3789	c9 22		cmp #$22			cmp 	#'"'
.378b	f0 08		beq $3795			beq 	_CTStringDone
.378d	20 45 2a	jsr $2a45			jsr 	BufferWrite 				; write and consume
.3790	20 75 33	jsr $3375			jsr 	GetNext
.3793	80 ef		bra $3784			bra 	_CTStringLoop
.3795					_CTStringDone:
.3795	20 75 33	jsr $3375			jsr 	GetNext 					; consume closing quote.
.3798	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.379a	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.379d	20 51 2a	jsr $2a51			jsr 	BufferOutput
.37a0	a9 40		lda #$40			lda 	#NSSString 					; string type
.37a2	60		rts				rts
.37a3					_CTUnaryFunctions:
.37a3	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.37a5	f0 0a		beq $37b1			beq 	_CTNegation
.37a7	a2 0c		ldx #$0c			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.37a9	a0 31		ldy #$31			ldy 	#UnaryTables >> 8
.37ab	20 06 32	jsr $3206			jsr 	GeneratorProcess
.37ae	90 ae		bcc $375e			bcc		_CTSyntax
.37b0	60		rts				rts
.37b1					_CTNegation:
.37b1	20 2c 37	jsr $372c			jsr 	CompileTerm 				; compile a term.
.37b4	48		pha				pha
.37b5	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.37b7	c9 00		cmp #$00			cmp 	#NSSIFloat
.37b9	d0 07		bne $37c2			bne 	_CTType 					; error
.37bb	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.37bd	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.37c0	68		pla				pla 								; return original type.
.37c1	60		rts				rts
.37c2					_CTType:
.37c2	4c 05 1f	jmp $1f05		jmp	ErrorV_type
.37c5					CommandWAIT:
.37c5	20 67 33	jsr $3367			jsr 	LookNextNonSpace
.37c8	c9 2c		cmp #$2c			cmp 	#","
.37ca	f0 10		beq $37dc			beq 	_CWThirdParameter
.37cc	a9 00		lda #$00			lda 	#0
.37ce	20 33 2b	jsr $2b33			jsr 	PushIntegerA
.37d1					_CWExit:
.37d1	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.37d3	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.37d6	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.37d8	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.37db	60		rts				rts
.37dc					_CWThirdParameter:
.37dc	20 75 33	jsr $3375			jsr 	GetNext
.37df	20 22 2d	jsr $2d22			jsr 	CompileExpressionAtA
.37e2	29 40		and #$40			and 	#NSSTypeMask
.37e4	c9 00		cmp #$00			cmp 	#NSSIFloat
.37e6	f0 e9		beq $37d1			beq 	_CWExit
.37e8	4c 05 1f	jmp $1f05		jmp	ErrorV_type
.37eb					CommandCMD:
.37eb	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.37ed	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.37f0	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; followed by a , ?
.37f3	c9 2c		cmp #$2c			cmp 	#","
.37f5	d0 06		bne $37fd			bne 	_CCMDExit
.37f7	20 75 33	jsr $3375			jsr 	GetNext 					; consume comma.
.37fa	20 ee 35	jsr $35ee			jsr 	CommandPRINT 				; do the print code
.37fd					_CCMDExit:
.37fd	60		rts				rts
.37fe					CommandOPEN:
.37fe	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; followed by a , ?
.3801	c9 2c		cmp #$2c			cmp 	#","
.3803	d0 15		bne $381a			bne 	_COTwoDefaults
.3805	20 75 33	jsr $3375			jsr 	GetNext 					; consume comma
.3808	20 20 2d	jsr $2d20			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.380b	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.380d	f0 1e		beq $382d			beq 	_COThreeIntegers
.380f	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.3811	20 33 2b	jsr $2b33			jsr 	PushIntegerA
.3814	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.3816	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3819	60		rts				rts
.381a					_COTwoDefaults:
.381a	a9 00		lda #$00			lda 	#0
.381c	20 33 2b	jsr $2b33			jsr 	PushIntegerA
.381f					_COCompileNullString:
.381f	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.3821	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3824	a9 00		lda #$00			lda 	#0
.3826	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.3829	20 0a 2a	jsr $2a0a			jsr 	WriteCodeByte
.382c	60		rts				rts
.382d					_COThreeIntegers:
.382d	20 67 33	jsr $3367			jsr 	LookNextNonSpace 			; is there a ,
.3830	c9 2c		cmp #$2c			cmp 	#","
.3832	d0 eb		bne $381f			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.3834	20 75 33	jsr $3375			jsr 	GetNext
.3837	20 20 2d	jsr $2d20			jsr 	CompileExpressionAt0 		; should be a filename
.383a	29 40		and #$40			and 	#NSSString
.383c	f0 01		beq $383f			beq 	_COType
.383e	60		rts				rts
.383f					_COType:
.383f	4c 05 1f	jmp $1f05		jmp	ErrorV_type

;******  Processing input file: _library.asm

.3842					CompilerAPI:
.3842	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.3844	f0 19		beq $385f			beq 	_CAOpenIn
.3846	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.3848	f0 23		beq $386d			beq 	_CACloseIn
.384a	c9 02		cmp #$02			cmp 	#BLC_READIN
.384c	f0 3a		beq $3888			beq 	_CARead
.384e	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.3850	f0 1e		beq $3870			beq 	_CAResetOut
.3852	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.3854	f0 23		beq $3879			beq 	_CACloseOut
.3856	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.3858	f0 20		beq $387a			beq 	_CAWriteByte
.385a	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.385c	f0 26		beq $3884			beq 	_CAPrintScreen
>385e	db						.byte 	$DB 						; causes a break in the emulator
.385f					_CAOpenIn:
.385f	a0 39		ldy #$39			ldy 	#SourceFile >> 8 			; name of file
.3861	a2 7f		ldx #$7f			ldx 	#SourceFile & $FF
.3863	20 f0 38	jsr $38f0			jsr 	IOOpenRead 					; open file
.3866	20 fb 38	jsr $38fb			jsr 	IOReadByte 					; skip the 2 byte load address header
.3869	20 fb 38	jsr $38fb			jsr 	IOReadByte
.386c	60		rts				rts
.386d					_CACloseIn:
.386d	4c 0a 39	jmp $390a			jmp 	IOReadClose
.3870					_CAResetOut:
.3870	a9 00		lda #$00			lda 	#((FreeMemory) & $FF)
.3872	85 2a		sta $2a				sta 	0+objPtr
.3874	a9 3a		lda #$3a			lda 	#((FreeMemory) >> 8) & $FF
.3876	85 2b		sta $2b				sta 	1+objPtr
.3878	60		rts				rts
.3879					_CACloseOut:
.3879	60		rts				rts
.387a					_CAWriteByte:
.387a	8a		txa				txa
.387b	92 2a		sta ($2a)			sta 	(objPtr)
.387d	e6 2a		inc $2a				inc 	objPtr
.387f	d0 02		bne $3883			bne 	_HWOWBNoCarry
.3881	e6 2b		inc $2b				inc 	objPtr+1
.3883					_HWOWBNoCarry:
.3883	60		rts				rts
.3884					_CAPrintScreen:
.3884	8a		txa				txa
.3885	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.3888					_CARead:
.3888	20 fb 38	jsr $38fb			jsr 	IOReadByte 				; copy the address of next into the buffer
.388b	8d ce 06	sta $06ce			sta 	SourceLine+0
.388e	20 fb 38	jsr $38fb			jsr 	IOReadByte
.3891	8d cf 06	sta $06cf			sta 	SourceLine+1
.3894	0d ce 06	ora $06ce			ora 	sourceLine				; if both were zero, exit with CC (e.g. fail)
.3897	18		clc				clc
.3898	f0 1e		beq $38b8			beq		_CARExit
.389a	20 fb 38	jsr $38fb			jsr 	IOReadByte 				; read the line # into the buffer.
.389d	8d d0 06	sta $06d0			sta 	SourceLine+2
.38a0	20 fb 38	jsr $38fb			jsr 	IOReadByte
.38a3	8d d1 06	sta $06d1			sta 	SourceLine+3
.38a6	a2 04		ldx #$04			ldx 	#4 						; read the body of the line.
.38a8					_CAReadLine:
.38a8	20 fb 38	jsr $38fb			jsr 	IOReadByte 				; now keep copying to EOL
.38ab	9d ce 06	sta $06ce,x			sta 	SourceLine,x
.38ae	e8		inx				inx
.38af	c9 00		cmp #$00			cmp 	#0
.38b1	d0 f5		bne $38a8			bne 	_CAReadLine
.38b3	38		sec				sec 							; read a line okay
.38b4	a0 06		ldy #$06			ldy 	#SourceLine >> 8
.38b6	a2 ce		ldx #$ce			ldx 	#SourceLine & $FF
.38b8					_CARExit:
.38b8	60		rts				rts
.06ce					SourceLine:
>06ce							.fill 	256
.38b9					WriteObjectCode:
.38b9	20 1a 08	jsr $081a			jsr 	PatchOutCompile 			; makes it run the runtime on reload
.38bc	a0 39		ldy #$39			ldy 	#ObjectFile >> 8
.38be	a2 74		ldx #$74			ldx 	#ObjectFile & $FF
.38c0	20 e3 39	jsr $39e3			jsr 	IOOpenWrite 				; open write
.38c3	a9 01		lda #$01			lda 	#1 							; write out the load address $0801
.38c5	20 ee 39	jsr $39ee			jsr 	IOWriteByte
.38c8	a9 08		lda #$08			lda 	#8
.38ca	20 ee 39	jsr $39ee			jsr 	IOWriteByte
.38cd	a9 01		lda #$01			lda 	#((StartBasicProgram) & $FF)
.38cf	85 2c		sta $2c				sta 	0+zTemp0
.38d1	a9 08		lda #$08			lda 	#((StartBasicProgram) >> 8) & $FF
.38d3	85 2d		sta $2d				sta 	1+zTemp0
.38d5					_WOCLoop:
.38d5	b2 2c		lda ($2c)			lda 	(zTemp0) 					; write code
.38d7	20 ee 39	jsr $39ee			jsr 	IOWriteByte
.38da	e6 2c		inc $2c				inc 	zTemp0 						; advance pointer
.38dc	d0 02		bne $38e0			bne 	_WOCSkip
.38de	e6 2d		inc $2d				inc 	zTemp0+1
.38e0					_WOCSkip:
.38e0	a5 2c		lda $2c				lda 	zTemp0 						; check end
.38e2	c5 2a		cmp $2a				cmp 	objPtr
.38e4	d0 ef		bne $38d5			bne 	_WOCLoop
.38e6	a5 2d		lda $2d				lda 	zTemp0+1
.38e8	c5 2b		cmp $2b				cmp 	objPtr+1
.38ea	d0 e9		bne $38d5			bne 	_WOCLoop
.38ec	20 0a 39	jsr $390a			jsr 	IOWriteClose 				; close the file.
.38ef	60		rts				rts
.38f0					IOOpenRead:
.38f0	a9 52		lda #$52			lda 	#'R' 						; read.
.38f2	20 13 39	jsr $3913			jsr 	IOSetFileName 				; set up name/LFS
.38f5	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for reading
.38f7	20 c6 ff	jsr $ffc6			jsr 	$FFC6 						; CHKIN
.38fa	60		rts				rts
.38fb					IOReadByte:
.38fb	da		phx				phx
.38fc	5a		phy				phy
.38fd	20 b7 ff	jsr $ffb7			jsr 	$FFB7 						; read ST
.3900	38		sec				sec
.3901	d0 04		bne $3907			bne 	_IORExit
.3903	20 cf ff	jsr $ffcf			jsr 	$FFCF 						; read a byte
.3906	18		clc				clc 								; status OK.
.3907					_IORExit:
.3907	7a		ply				ply
.3908	fa		plx				plx
.3909	60		rts				rts
.390a					IOReadClose:
.390a					IOWriteClose:
.390a	a9 03		lda #$03			lda 	#3 							; CLOSE# 3
.390c	20 c3 ff	jsr $ffc3			jsr 	$FFC3
.390f	20 cc ff	jsr $ffcc			jsr 	$FFCC 						; CLRCHN
.3912	60		rts				rts
.3913					IOSetFileName:
.3913	48		pha				pha 								; save R/W
.3914	86 2c		stx $2c				stx 	zTemp0
.3916	84 2d		sty $2d				sty 	zTemp0+1
.3918	a0 ff		ldy #$ff			ldy 	#$FF 						; copy name given
.391a					_IOSCopy:
.391a	c8		iny				iny 								; pre-increment copy
.391b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.391d	99 ce 07	sta $07ce,y			sta 	IONameBuffer,y
.3920	d0 f8		bne $391a			bne 	_IOSCopy
.3922	99 d2 07	sta $07d2,y			sta 	IONameBuffer+4,y
.3925	a9 2c		lda #$2c			lda 	#',' 						; append ,S,[R|W]
.3927	99 ce 07	sta $07ce,y			sta 	IONameBuffer+0,y
.392a	99 d0 07	sta $07d0,y			sta 	IONameBuffer+2,y
.392d	a9 53		lda #$53			lda 	#'S'
.392f	99 cf 07	sta $07cf,y			sta 	IONameBuffer+1,y
.3932	68		pla				pla 								; write R/W out
.3933	99 d1 07	sta $07d1,y			sta 	IONameBuffer+3,y
.3936	98		tya				tya 								; length of name to A
.3937	18		clc				clc
.3938	69 04		adc #$04			adc 	#4 							; we added 4 characters.
.393a	a2 ce		ldx #$ce			ldx 	#IONameBuffer & $FF			; name address to YX
.393c	a0 07		ldy #$07			ldy 	#IONameBuffer >> 8
.393e	20 bd ff	jsr $ffbd		    jsr 	$FFBD          				; call SETNAM
.3941	a9 03		lda #$03	    	lda 	#3 							; set LFS to 3,8,3
.3943	a2 08		ldx #$08			ldx 	#8
.3945	a0 03		ldy #$03			ldy 	#3
.3947	20 ba ff	jsr $ffba			jsr 	$FFBA
.394a	20 c0 ff	jsr $ffc0			jsr 	$FFC0 						; OPEN
.394d	60		rts				rts
.07ce					IONameBuffer:
>07ce							.fill 	64
.394e					CompileCode:
.394e	a2 00		ldx #$00			ldx 	#0
.3950	bd 8a 39	lda $398a,x	_Prompt:lda 	Prompt,x
.3953	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3956	e8		inx				inx
.3957	c9 00		cmp #$00			cmp 	#0
.3959	d0 f5		bne $3950			bne 	_Prompt
.395b	a2 70		ldx #$70			ldx 	#APIDesc & $FF
.395d	a0 39		ldy #$39			ldy 	#APIDesc >> 8
.395f	20 81 2a	jsr $2a81			jsr 	StartCompiler
.3962	20 b9 38	jsr $38b9			jsr 	WriteObjectCode
.3965	a9 4f		lda #$4f			lda 	#"O"
.3967	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.396a	a9 4b		lda #$4b			lda 	#"K"
.396c	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.396f	60		rts				rts
.3970					APIDesc:
>3970	42 38						.word 	CompilerAPI 				; the compiler API Implementeation
>3972	80						.byte 	$80 						; start of workspace for compiler $8000
>3973	9f						.byte 	$9F							; end of workspace for compiler $9F00
.3974					ObjectFile:
>3974	4f 42 4a 45 43 54 2e 50				.text 	'OBJECT.PRG',0
>397c	52 47 00
.397f					SourceFile:
>397f	53 4f 55 52 43 45 2e 50				.text 	'SOURCE.PRG',0
>3987	52 47 00
.398a					Prompt:
>398a	2a 2a 2a 20 42 4c 49 54				.text 	'*** BLITZ (ALPHA 09-10-23) ***',13,13
>3992	5a 20 28 41 4c 50 48 41 20 30 39 2d 31 30 2d 32
>39a2	33 29 20 2a 2a 2a 0d 0d
>39aa	42 55 47 53 3a 48 54 54				.text 	'BUGS:HTTPS://GITHUB.COM/PAULSCOTTROBSON/BLITZ-COMPILER',13,13,0
>39b2	50 53 3a 2f 2f 47 49 54 48 55 42 2e 43 4f 4d 2f
>39c2	50 41 55 4c 53 43 4f 54 54 52 4f 42 53 4f 4e 2f
>39d2	42 4c 49 54 5a 2d 43 4f 4d 50 49 4c 45 52 0d 0d
>39e2	00
.39e3					IOOpenWrite:
.39e3	a9 57		lda #$57			lda 	#'W'			 			; write
.39e5	20 13 39	jsr $3913			jsr 	IOSetFileName 				; set up name/LFS
.39e8	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for writing
.39ea	20 c9 ff	jsr $ffc9			jsr 	$FFC9 						; CHKOUT
.39ed	60		rts				rts
.39ee					IOWriteByte:
.39ee	48		pha				pha
.39ef	da		phx				phx
.39f0	5a		phy				phy
.39f1	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.39f4	7a		ply				ply
.39f5	fa		plx				plx
.39f6	68		pla				pla
.39f7	60		rts				rts

;******  Processing input file: source/main/zzfree.footer

>39f8							.align 	256
.3a00					FreeMemory:

;******  End of listing
