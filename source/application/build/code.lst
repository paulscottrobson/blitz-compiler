
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl source/main/00main.header /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library _library.asm source/main/zzfree.footer
; Thu Oct 12 05:14:53 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: source/main/00main.header

.0801					StartBasicProgram:
>0801	0c 08						.word 	$080C 						; offset to next.
>0803	0a 00						.word 	10 							; line #
>0805	9e						.byte 	$9E 						; token for 'SYS'
>0806	20 32 30 36 32					.text 	' 2062'						; space, $080E in decimal
>080b	00						.byte  	0 							; end of line
>080c	00 00						.word 	0 							; end of program
.080e					StartCode:
.080e	4c c8 39	jmp $39c8			jmp 	CompileCode 				; to starting the runtime in the saved code.
.0811	a9 3b		lda #$3b			lda 	#FreeMemory >> 8 			; address of object code to run.
.0813	a2 80		ldx #$80			ldx 	#$80 						; 8000-9EFF is used for workspace.
.0815	a0 9f		ldy #$9f			ldy 	#$9F
.0817	4c 26 08	jmp $0826			jmp 	StartRuntime 				; and go do it !
.081a					PatchOutCompile:
.081a	a9 ea		lda #$ea			lda 	#$EA 						; $EA is NOP 65C02
.081c	8d 0e 08	sta $080e			sta 	StartCode 					; patch out "JMP COMPILECODE"
.081f	8d 0f 08	sta $080f			sta 	StartCode+1
.0822	8d 10 08	sta $0810			sta 	StartCode+2
.0825	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.0826					StartRuntime:
.0826	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.0829	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.082b	64 28		stz $28				stz 	codePtr
.082d	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0830	8c 06 04	sty $0406			sty 	storeEndHigh
.0833	8e 07 04	stx $0407			stx 	variableStartPage
.0836	ba		tsx				tsx 								; save the stack.
.0837	8e 08 04	stx $0408			stx 	Runtime6502SP
.083a	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.083c	a2 58		ldx #$58			ldx 	#RuntimeErrorHandler & $FF
.083e	20 09 1f	jsr $1f09			jsr 	SetErrorHandler
.0841	20 84 0a	jsr $0a84			jsr 	ClearMemory 				; clear memory.
.0844	20 88 16	jsr $1688			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0847	20 74 13	jsr $1374		 	jsr		SetDefaultChannel			; set default input/output channel.
.084a	20 c0 15	jsr $15c0			jsr 	RestoreCode 				; which we now call
.084d	a0 00		ldy #$00			ldy 	#0
.084f					NextCommand:
.084f	ad 09 04	lda $0409			lda  	breakCount 					; only check every 16 instructions.
.0852	69 10		adc #$10			adc 	#16
.0854	8d 09 04	sta $0409			sta 	breakCount
.0857	90 07		bcc $0860			bcc 	_NXNoCheck
.0859	da		phx				phx
.085a	5a		phy				phy 								; check Ctrl+C
.085b	20 c4 1b	jsr $1bc4			jsr 	XCheckStop
.085e	7a		ply				ply
.085f	fa		plx				plx
.0860					_NXNoCheck:
.0860	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.0862	30 5b		bmi $08bf			bmi 	NXCommand 					; -if -ve command
.0864	c8		iny				iny
.0865	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0867	90 39		bcc $08a2			bcc 	PushByteA 					; 0..63 is short constants.
.0869					NXLoadStore:
.0869	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.086b	b0 19		bcs $0886			bcs 	NXIndirectLoadStore
.086d	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.086e	4a		lsr a				lsr 	a
.086f	29 0e		and #$0e			and 	#$0E
.0871	da		phx				phx 								; get ready to jump
.0872	aa		tax				tax
.0873	7c 76 08	jmp ($0876,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.0876					ReadWriteVectors:
>0876	e0 14						.word 	ReadFloatCommand			; read float
>0878	d3 1a						.word 	WriteFloatCommand 			; write float
>087a	1c 15						.word 	ReadIntegerCommand 			; read integer
>087c	0f 1b						.word 	WriteIntegerCommand 		; write integer
>087e	61 15						.word 	ReadStringCommand 			; read string
>0880	4e 1b						.word 	WriteStringCommand 			; write string
>0882	55 0c						.word 	Unimplemented
>0884	55 0c						.word 	Unimplemented
.0886					NXIndirectLoadStore:
.0886	29 07		and #$07			and 	#7
.0888	0a		asl a				asl 	a
.0889	da		phx				phx
.088a	aa		tax				tax
.088b	7c 8e 08	jmp ($088e,x)			jmp 	(IndirectVectors,x)
.088e					IndirectVectors:
>088e	0c 0f						.word 	IndFloatRead 				; float read
>0890	20 0f						.word 	IndInt16Read 				; int16 read
>0892	34 0f						.word 	IndStringRead 				; string read
>0894	55 0c						.word 	Unimplemented
>0896	48 0f						.word 	IndFloatWrite				; float write
>0898	5c 0f						.word 	IndInt16Write 				; int16 write
>089a	70 0f						.word 	IndStringWrite 				; string write
>089c	55 0c						.word 	Unimplemented
.089e					PushByteCommand:
.089e	fa		plx				plx
.089f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.08a1	c8		iny				iny
.08a2					PushByteA:
.08a2	e8		inx				inx 								; push constant on stack
.08a3	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.08a5	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.08a7					ClearRestWord:
.08a7	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.08a9	74 62		stz $62,x			stz 	NSMantissa3,x
.08ab	74 6e		stz $6e,x			stz 	NSExponent,x
.08ad	74 32		stz $32,x			stz 	NSStatus,x
.08af	80 9e		bra $084f			bra 	NextCommand
.08b1					PushWordCommand:
.08b1	fa		plx				plx
.08b2	e8		inx				inx
.08b3	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.08b5	c8		iny				iny
.08b6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08b8	b1 28		lda ($28),y			lda 	(codePtr),y
.08ba	c8		iny				iny
.08bb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08bd	80 e8		bra $08a7			bra 	ClearRestWord 				; handle everything else.
.08bf					NXCommand:
.08bf	c8		iny				iny 								; consume command.
.08c0	10 03		bpl $08c5			bpl 	_NXCommandNoFixUp
.08c2	20 cb 08	jsr $08cb			jsr 	FixUpY
.08c5					_NXCommandNoFixUp:
.08c5	0a		asl a				asl 	a 							; shift left
.08c6	da		phx				phx 								; save SP on stack
.08c7	aa		tax				tax				 					; and jump indirect
.08c8	7c b2 19	jmp ($19b2,x)			jmp 	(VectorTable,x)
.08cb					FixUpY:
.08cb	48		pha				pha
.08cc	98		tya				tya
.08cd	18		clc				clc
.08ce	65 28		adc $28				adc 	codePtr
.08d0	85 28		sta $28				sta 	codePtr
.08d2	90 02		bcc $08d6			bcc 	_NoCPCarry
.08d4	e6 29		inc $29				inc 	codePtr+1
.08d6					_NoCPCarry:
.08d6	a0 00		ldy #$00			ldy 	#0
.08d8	68		pla				pla
.08d9	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.0408					Runtime6502SP:
>0408							.fill 	1
.0409					breakCount:
>0409							.fill 	1
.08da					AbsoluteTOS:
.08da	fa		plx				plx
.08db	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.08e0					CommandVarSpace:
.08e0	fa		plx				plx
.08e1	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08e3	85 26		sta $26				sta 	availableMemory
.08e5	c8		iny				iny
.08e6	b1 28		lda ($28),y			lda 	(codePtr),y
.08e8	18		clc				clc
.08e9	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08ec	85 27		sta $27				sta 	availableMemory+1
.08ee	c8		iny				iny
.08ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08f2					BinaryAnd:
.08f2	fa		plx				plx
.08f3	38		sec				sec
.08f4	80 02		bra $08f8			bra 	AndOrCommon
.08f6					BinaryOr:
.08f6	fa		plx				plx
.08f7	18		clc				clc
.08f8					AndOrCommon:
.08f8	08		php				php 								; save AND/OR flag
.08f9	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.08fc	ca		dex				dex
.08fd	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.0900	28		plp				plp
.0901	90 0e		bcc $0911			bcc 	_AOCOrCode
.0903	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.0905	35 3f		and $3f,x			and		NSMantissa0+1,x
.0907	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0909	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.090b	35 4b		and $4b,x			and		NSMantissa1+1,x
.090d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.090f	80 0c		bra $091d			bra 	_AOCComplete
.0911					_AOCOrCode:
.0911	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.0913	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.0915	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0917	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0919	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.091b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.091d					_AOCComplete:
.091d	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.091f	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.0921	10 07		bpl $092a			bpl 	_AOCExit
.0923	20 57 10	jsr $1057			jsr 	Negate16Bit 				; 2's complement
.0926	a9 80		lda #$80			lda 	#$80 						; make it -ve
.0928	95 32		sta $32,x			sta 	NSStatus,x
.092a					_AOCExit:
.092a	4c 4f 08	jmp $084f			jmp 	NextCommand
.092d					ArrayConvert:
.092d	fa		plx				plx
.092e	5a		phy				phy
.092f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0931	85 2e		sta $2e				sta 	zTemp1
.0933	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0935	18		clc				clc
.0936	6d 07 04	adc $0407			adc 	variableStartPage
.0939	85 2f		sta $2f				sta 	zTemp1+1
.093b	ca		dex				dex 								; count of indices to follow -> zTemp2
.093c	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.093f	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.0941	8a		txa				txa
.0942	38		sec				sec
.0943	e5 30		sbc $30				sbc 	zTemp2
.0945	aa		tax				tax
.0946	da		phx				phx 								; stack points at the first index, which will be replaced.
.0947					_ACIndexLoop:
.0947	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart 			; integer array index
.094a	20 47 10	jsr $1047			jsr 	GetInteger16Bit 			; get the index => zTemp0
.094d	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.094f	a5 2c		lda $2c				lda 	zTemp0
.0951	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0953	a5 2d		lda $2d				lda 	zTemp0+1
.0955	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0957	b0 79		bcs $09d2			bcs 	_ACBadIndex 				; index error.
.0959	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.095b	f0 29		beq $0986			beq 	_ACInnerLevel
.095d	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.095f	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0961	10 6f		bpl $09d2			bpl 	_ACBadIndex
.0963	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0965	26 2d		rol $2d				rol 	zTemp0+1
.0967	18		clc				clc
.0968	a5 2c		lda $2c				lda		zTemp0
.096a	65 2e		adc $2e				adc 	zTemp1
.096c	85 2c		sta $2c				sta 	zTemp0
.096e	a5 2d		lda $2d				lda		zTemp0+1
.0970	65 2f		adc $2f				adc 	zTemp1+1
.0972	85 2d		sta $2d				sta 	zTemp0+1
.0974	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.0976	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0978	85 2e		sta $2e				sta 	zTemp1
.097a	c8		iny				iny
.097b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.097d	18		clc				clc
.097e	6d 07 04	adc $0407			adc 	variableStartPage
.0981	85 2f		sta $2f				sta 	zTemp1+1
.0983	e8		inx				inx 								; next index
.0984	80 c1		bra $0947			bra 	_ACIndexLoop
.0986					_ACInnerLevel:
.0986	a0 02		ldy #$02			ldy 	#2
.0988	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.098a	30 46		bmi $09d2			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.098c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.098e	c9 00		cmp #$00			cmp 	#NSSIFloat
.0990	d0 13		bne $09a5			bne 	_ACNotFloat
.0992	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.0994	48		pha				pha
.0995	a5 2c		lda $2c				lda 	zTemp0
.0997	06 2c		asl $2c				asl 	zTemp0 						; x 2
.0999	26 2d		rol $2d				rol 	zTemp0+1
.099b	18		clc				clc 								; add back x 3
.099c	65 2c		adc $2c				adc 	zTemp0
.099e	85 2c		sta $2c				sta 	zTemp0
.09a0	68		pla				pla
.09a1	65 2d		adc $2d				adc 	zTemp0+1
.09a3	85 2d		sta $2d				sta 	zTemp0+1
.09a5					_ACNotFloat:
.09a5	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.09a7	26 2d		rol $2d				rol 	zTemp0+1
.09a9	18		clc				clc
.09aa	a5 2c		lda $2c				lda 	zTemp0
.09ac	69 03		adc #$03			adc 	#3
.09ae	85 2c		sta $2c				sta 	zTemp0
.09b0	90 02		bcc $09b4			bcc 	_ACNoCarry
.09b2	e6 2d		inc $2d				inc 	zTemp0+1
.09b4					_ACNoCarry:
.09b4	fa		plx				plx 								; X points to first slot of array parameters
.09b5	18		clc				clc
.09b6	a5 2c		lda $2c				lda 	zTemp0
.09b8	65 2e		adc $2e				adc 	zTemp1
.09ba	95 3e		sta $3e,x			sta 	NSMantissa0,x
.09bc	a5 2d		lda $2d				lda 	zTemp0+1
.09be	65 2f		adc $2f				adc 	zTemp1+1
.09c0	38		sec				sec
.09c1	ed 07 04	sbc $0407			sbc 	variableStartPage
.09c4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.09c6	74 56		stz $56,x			stz 	NSMantissa2,x
.09c8	74 62		stz $62,x			stz 	NSMantissa3,x
.09ca	74 32		stz $32,x			stz 	NSStatus,x
.09cc	74 6e		stz $6e,x			stz 	NSExponent,x
.09ce	7a		ply				ply 	 							; restore code pointer
.09cf	4c 4f 08	jmp $084f			jmp 	NextCommand
.09d2					_ACBadIndex:
.09d2	4c 0b 20	jmp $200b		jmp	ErrorV_index
.09d5					UnaryAsc:
.09d5	fa		plx				plx
.09d6	5a		phy				phy
.09d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09d9	85 2c		sta $2c				sta 	zTemp0
.09db	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09dd	85 2d		sta $2d				sta 	zTemp0+1
.09df	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09e1	f0 06		beq $09e9			beq 	_UAExit
.09e3	5a		phy				phy 								; otherwise first character
.09e4	a0 01		ldy #$01			ldy 	#1
.09e6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09e8	7a		ply				ply
.09e9					_UAExit:
.09e9	20 8a 26	jsr $268a			jsr 	FloatSetByte
.09ec	7a		ply				ply
.09ed	4c 4f 08	jmp $084f			jmp 	NextCommand
.09f0					CommandAssert:
.09f0	fa		plx				plx
.09f1	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09f3	d0 09		bne $09fe			bne 	_CAFail
.09f5	20 aa 26	jsr $26aa			jsr 	FloatIsZero 				; is it zero ?
.09f8	f0 04		beq $09fe			beq 	_CAFail
.09fa	ca		dex				dex
.09fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.09fe					_CAFail:
.09fe	4c 64 1f	jmp $1f64		jmp	ErrorV_assert
.0a01					X16_Audio_Parameters8_16:
.0a01	20 07 0a	jsr $0a07			jsr 	X16_Audio_Parameters8_8
.0a04	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.0a06	60		rts				rts
.0a07					X16_Audio_Parameters8_8:
.0a07	a2 01		ldx #$01			ldx 	#1
.0a09	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.0a0c	ca		dex				dex
.0a0d	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.0a10	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0a13	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.0a15	a0 00		ldy #$00			ldy 	#0
.0a17	60		rts				rts
.0a18					X16_Audio_Parameters8_String:
.0a18	20 01 0a	jsr $0a01			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.0a1b	da		phx				phx 								; set the voice
.0a1c	5a		phy				phy
.0a1d	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.0a20	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>0a23	0a						.byte 	X16_AudioCodeBank
.0a24	7a		ply				ply
.0a25	fa		plx				plx
.0a26	86 2c		stx $2c				stx 	zTemp0
.0a28	84 2d		sty $2d				sty 	zTemp0+1
.0a2a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a2c	e8		inx				inx 								; point YX to first character.
.0a2d	d0 01		bne $0a30			bne 	_X16APSSkip
.0a2f	c8		iny				iny
.0a30					_X16APSSkip:
.0a30	60		rts				rts
.0a31					Unary16Bin:
.0a31	fa		plx				plx
.0a32	20 47 10	jsr $1047			jsr 	GetInteger16Bit				; 16 bit int
.0a35	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a37	20 31 17	jsr $1731			jsr 	StringAllocTemp
.0a3a	a5 2d		lda $2d				lda 	zTemp0+1
.0a3c	f0 03		beq $0a41			beq 	_UBNoHigh
.0a3e	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a41					_UBNoHigh:
.0a41	a5 2c		lda $2c				lda 	zTemp0
.0a43	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a46	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a49					_UBWriteBinary:
.0a49	5a		phy				phy
.0a4a	a0 08		ldy #$08			ldy 	#8
.0a4c					_UBWLoop:
.0a4c	0a		asl a				asl 	a
.0a4d	48		pha				pha
.0a4e	a9 00		lda #$00			lda  	#0
.0a50	69 30		adc #$30			adc 	#48
.0a52	20 5a 17	jsr $175a			jsr 	StringWriteChar
.0a55	68		pla				pla
.0a56	88		dey				dey
.0a57	d0 f3		bne $0a4c			bne 	_UBWLoop
.0a59	7a		ply				ply
.0a5a	60		rts				rts
.0a5b					PrintCharacterX:
.0a5b	fa		plx				plx
.0a5c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a5e	ca		dex				dex
.0a5f	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.0a62	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a65					UnaryChr:
.0a65	fa		plx				plx
.0a66	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get integer to convert.
.0a69	48		pha				pha 								; save it and allocate for it
.0a6a	a9 01		lda #$01			lda 	#1 							; 1 character
.0a6c	20 31 17	jsr $1731			jsr 	StringAllocTemp
.0a6f	a9 01		lda #$01			lda 	#1 							; length 1.
.0a71	92 22		sta ($22)			sta 	(zsTemp)
.0a73	68		pla				pla 								; character code makes string.
.0a74	5a		phy				phy
.0a75	a0 01		ldy #$01			ldy 	#1
.0a77	91 22		sta ($22),y			sta 	(zsTemp),y
.0a79	7a		ply				ply
.0a7a	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a7d					CommandClr:
.0a7d	fa		plx				plx
.0a7e	20 84 0a	jsr $0a84			jsr 	ClearMemory
.0a81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a84					ClearMemory:
.0a84	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a87	85 2d		sta $2d				sta 	zTemp0+1
.0a89	64 2c		stz $2c				stz 	zTemp0
.0a8b	5a		phy				phy
.0a8c	a0 00		ldy #$00			ldy 	#0
.0a8e					_ClearLoop1:
.0a8e	a9 00		lda #$00			lda 	#0
.0a90	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a92	c8		iny				iny
.0a93	d0 f9		bne $0a8e			bne 	_ClearLoop1
.0a95	e6 2d		inc $2d				inc 	zTemp0+1
.0a97	a5 2d		lda $2d				lda 	zTemp0+1
.0a99	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a9c	d0 f0		bne $0a8e			bne 	_ClearLoop1
.0a9e	38		sec				sec 											; stack space = number of pages in total / 4
.0a9f	ad 06 04	lda $0406			lda 	storeEndHigh
.0aa2	ed 05 04	sbc $0405			sbc		storeStartHigh
.0aa5	4a		lsr a				lsr 	a
.0aa6	4a		lsr a				lsr 	a
.0aa7	d0 02		bne $0aab			bne 	_NotEmpty 								; at least 1 !
.0aa9	a9 01		lda #$01			lda 	#1
.0aab					_NotEmpty:
.0aab	38		sec				sec 											; subtract from high to give string high memory
.0aac	49 ff		eor #$ff			eor 	#$FF
.0aae	6d 06 04	adc $0406			adc 	storeEndHigh
.0ab1	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0ab4	9c 02 04	stz $0402			stz 	stringHighMemory
.0ab7	9c 6a 05	stz $056a			stz 	stringInitialised 						; string system not initialised
.0aba	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0abd	3a		dec a				dec 	a
.0abe	85 25		sta $25				sta 	runtimeStackPtr+1
.0ac0	a9 ff		lda #$ff			lda 	#$FF
.0ac2	85 24		sta $24				sta 	runtimeStackPtr
.0ac4	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0ac6	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0ac8	7a		ply				ply
.0ac9	60		rts				rts
.0aca					CompareStrings:
.0aca	fa		plx				plx
.0acb	ca		dex				dex
.0acc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0ace	85 2c		sta $2c				sta 	zTemp0
.0ad0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ad2	85 2d		sta $2d				sta 	zTemp0+1
.0ad4	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0ad6	85 2e		sta $2e				sta 	zTemp1
.0ad8	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0ada	85 2f		sta $2f				sta 	zTemp1+1
.0adc	da		phx				phx
.0add	5a		phy				phy
.0ade	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0ae0	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0ae2	90 02		bcc $0ae6			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0ae4	b2 2e		lda ($2e)			lda 	(zTemp1)
.0ae6					_CSNIsSmallest:
.0ae6	aa		tax				tax 								; count in X
.0ae7	f0 0c		beq $0af5			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0ae9	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0aeb					_CSNCompareString:
.0aeb	c8		iny				iny 								; pre increment
.0aec	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0aee	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0af0	d0 0a		bne $0afc			bne 	_CSNDifferent 				; numbers are different.
.0af2	ca		dex				dex
.0af3	d0 f6		bne $0aeb			bne 	_CSNCompareString 			; compare common characters in two strings.
.0af5					_CSNMatches:
.0af5	38		sec				sec
.0af6	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0af8	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0afa	f0 06		beq $0b02			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0afc					_CSNDifferent:
.0afc	a9 ff		lda #$ff			lda 	#$FF
.0afe	90 02		bcc $0b02			bcc 	_CSNSExit
.0b00	a9 01		lda #$01			lda 	#$01
.0b02					_CSNSExit:
.0b02	7a		ply				ply
.0b03	fa		plx				plx
.0b04	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0b06	20 8a 26	jsr $268a			jsr 	FloatSetByte 				; output the byte
.0b09	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b0c					StringConcrete:
.0b0c	9c 6a 05	stz $056a			stz 	stringInitialised	 		; initialise next usage
.0b0f	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0b11	85 30		sta $30				sta 	zTemp2
.0b13	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0b15	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0b16	18		clc				clc
.0b17	72 30		adc ($30)			adc 	(zTemp2)
.0b19	90 02		bcc $0b1d			bcc 	_SCNoOverflow
.0b1b	a9 ff		lda #$ff			lda 	#255
.0b1d					_SCNoOverflow:
.0b1d	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0b1f	b0 02		bcs $0b23			bcs 	_SCNoMinimum
.0b21	a9 0a		lda #$0a			lda 	#10
.0b23					_SCNoMinimum:
.0b23	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0b25	38		sec				sec
.0b26	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0b29	e5 2e		sbc $2e				sbc 	zTemp1
.0b2b	a8		tay				tay
.0b2c	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b2f	e9 00		sbc #$00			sbc 	#0
.0b31	48		pha				pha
.0b32	38		sec				sec 								; subtract 3 more
.0b33	98		tya				tya
.0b34	e9 03		sbc #$03			sbc 	#3
.0b36	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b39	85 22		sta $22				sta 	zsTemp
.0b3b	68		pla				pla
.0b3c	e9 00		sbc #$00			sbc 	#0
.0b3e	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b41	85 23		sta $23				sta 	zsTemp+1
.0b43	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b45	92 22		sta ($22)			sta 	(zsTemp)
.0b47	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b49	a9 00		lda #$00			lda 	#0
.0b4b	91 22		sta ($22),y			sta 	(zsTemp),y
.0b4d	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b4f	a4 23		ldy $23				ldy 	zsTemp+1
.0b51	60		rts				rts
.0b52					CommandXData:
.0b52	fa		plx				plx
.0b53	98		tya				tya 								; data length +1 added to Y
.0b54	38		sec				sec
.0b55	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b57	a8		tay				tay
.0b58	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b5b					CommandXDIM:
.0b5b	fa		plx				plx
.0b5c	5a		phy				phy
.0b5d	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b60	8d 0a 04	sta $040a			sta 	dimType
.0b63	ca		dex				dex 								; this is the number of indices
.0b64	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0b67	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b69	8a		txa				txa 								; dimension.
.0b6a	38		sec				sec
.0b6b	e5 2e		sbc $2e				sbc 	zTemp1
.0b6d	aa		tax				tax
.0b6e	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b70	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create one at this level
.0b73	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b75	98		tya				tya
.0b76	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b78	74 56		stz $56,x			stz 	NSMantissa2,x
.0b7a	74 62		stz $62,x			stz 	NSMantissa3,x
.0b7c	74 32		stz $32,x			stz 	NSStatus,x
.0b7e	74 6e		stz $6e,x			stz 	NSExponent,x
.0b80	7a		ply				ply
.0b81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b84					DIMCreateOneLevel:
.0b84	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b86	5a		phy				phy
.0b87	a4 27		ldy $27				ldy 	availableMemory+1
.0b89	5a		phy				phy
.0b8a	a8		tay				tay 			 					; save current level into Y
.0b8b	20 47 10	jsr $1047			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b8e	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b90	d0 02		bne $0b94			bne 	_DCOLNoCarry
.0b92	e6 2d		inc $2d				inc 	zTemp0+1
.0b94					_DCOLNoCarry:
.0b94	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b96	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b99	a5 2d		lda $2d				lda 	zTemp0+1
.0b9b	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b9e	ad 0a 04	lda $040a			lda 	dimType 					; get type information
.0ba1	29 7f		and #$7f			and 	#$7F
.0ba3	c0 01		cpy #$01			cpy 	#1
.0ba5	f0 02		beq $0ba9			beq 	_DCOLNoSubLevel
.0ba7	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0ba9					_DCOLNoSubLevel:
.0ba9	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0bac	a5 26		lda $26				lda 	availableMemory
.0bae	85 2e		sta $2e				sta 	zTemp1
.0bb0	a5 27		lda $27				lda 	availableMemory+1
.0bb2	85 2f		sta $2f				sta 	zTemp1+1
.0bb4	a5 2c		lda $2c				lda 	zTemp0
.0bb6	85 30		sta $30				sta 	zTemp2
.0bb8	a5 2d		lda $2d				lda 	zTemp0+1
.0bba	85 31		sta $31				sta 	zTemp2+1
.0bbc					_DCOLFillArray:
.0bbc	20 1b 0c	jsr $0c1b			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0bbf	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0bc1	d0 02		bne $0bc5			bne 	_DCOLNoBorrow
.0bc3	c6 2d		dec $2d				dec 	zTemp0+1
.0bc5					_DCOLNoBorrow:
.0bc5	c6 2c		dec $2c				dec 	zTemp0
.0bc7	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0bc9	05 2d		ora $2d				ora 	zTemp0+1
.0bcb	d0 ef		bne $0bbc			bne 	_DCOLFillArray
.0bcd	c0 01		cpy #$01			cpy 	#1
.0bcf	f0 42		beq $0c13			beq 	_DCOLExit
.0bd1					_DCOLRecursionLoop:
.0bd1	da		phx				phx 								; save XY
.0bd2	5a		phy				phy
.0bd3	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0bd5	48		pha				pha
.0bd6	a5 2f		lda $2f				lda 	zTemp1+1
.0bd8	48		pha				pha
.0bd9	a5 30		lda $30				lda 	zTemp2
.0bdb	48		pha				pha
.0bdc	a5 31		lda $31				lda 	zTemp2+1
.0bde	48		pha				pha
.0bdf	88		dey				dey  								; lower level -> A
.0be0	98		tya				tya
.0be1	e8		inx				inx 								; next index size
.0be2	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0be5	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0be6	86 31		stx $31				stx 	zTemp2+1
.0be8	fa		plx				plx
.0be9	86 30		stx $30				stx 	zTemp2
.0beb	fa		plx				plx
.0bec	86 2f		stx $2f				stx 	zTemp1+1
.0bee	fa		plx				plx
.0bef	86 2e		stx $2e				stx 	zTemp1
.0bf1	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0bf3	98		tya				tya
.0bf4	a0 01		ldy #$01			ldy 	#1
.0bf6	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0bf8	7a		ply				ply 								; restore XY
.0bf9	fa		plx				plx
.0bfa	18		clc				clc
.0bfb	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0bfd	69 02		adc #$02			adc 	#2
.0bff	85 2e		sta $2e				sta 	zTemp1
.0c01	90 02		bcc $0c05			bcc 	_DCOLRNoCarry
.0c03	e6 2f		inc $2f				inc 	zTemp1+1
.0c05					_DCOLRNoCarry:
.0c05	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0c07	d0 02		bne $0c0b			bne 	_DCOLRNoBorrow
.0c09	c6 31		dec $31				dec 	zTemp2+1
.0c0b					_DCOLRNoBorrow:
.0c0b	c6 30		dec $30				dec 	zTemp2
.0c0d	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0c0f	05 31		ora $31				ora 	zTemp2+1
.0c11	d0 be		bne $0bd1			bne 	_DCOLRecursionLoop
.0c13					_DCOLExit:
.0c13	68		pla				pla 								; get MSB, make offset again
.0c14	38		sec				sec
.0c15	ed 07 04	sbc $0407			sbc 	variableStartPage
.0c18	a8		tay				tay
.0c19	68		pla				pla 								; YA now contains offset address.
.0c1a	60		rts				rts
.0c1b					DIMWriteElement:
.0c1b	da		phx				phx
.0c1c	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0c1e	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0c20	d0 0b		bne $0c2d			bne 	_DIMWENotFloat
.0c22	ad 0a 04	lda $040a			lda 	dimType
.0c25	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0c27	c9 00		cmp #$00			cmp 	#NSSIFloat
.0c29	d0 02		bne $0c2d			bne 	_DIMWENotFloat
.0c2b	a2 06		ldx #$06			ldx 	#6
.0c2d					_DIMWENotFloat:
.0c2d	a9 00		lda #$00			lda 	#0
.0c2f	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0c32	ca		dex				dex
.0c33	d0 f8		bne $0c2d			bne 	_DIMWENotFloat
.0c35	fa		plx				plx
.0c36	60		rts				rts
.0c37					DIMWriteByte:
.0c37	92 26		sta ($26)			sta 	(availableMemory)
.0c39	e6 26		inc $26				inc 	availableMemory
.0c3b	d0 0b		bne $0c48			bne 	_DIMWBSkip
.0c3d	e6 27		inc $27				inc 	availableMemory+1
.0c3f	48		pha				pha
.0c40	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c42	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c45	b0 02		bcs $0c49			bcs 	_DIMWBMemory
.0c47	68		pla				pla
.0c48					_DIMWBSkip:
.0c48	60		rts				rts
.0c49					_DIMWBMemory:
.0c49	4c 1e 20	jmp $201e		jmp	ErrorV_memory
.040a					dimType:
>040a							.fill 	1
.0c4c					CommandEnd:
.0c4c	fa		plx				plx
.0c4d	86 2c		stx $2c				stx 	zTemp0
.0c4f	18		clc				clc 								; exited okay.
.0c50					EndRuntime:
.0c50	ae 08 04	ldx $0408			ldx 	Runtime6502SP 				; set up the stack pointer
.0c53	9a		txs				txs
.0c54	60		rts				rts
.0c55					Unimplemented:
.0c55	4c 51 1f	jmp $1f51			jmp 	ErrorV_unimplemented
.0c58					RuntimeErrorHandler:
.0c58	98		tya				tya
.0c59	18		clc				clc
.0c5a	65 28		adc $28				adc 	codePtr
.0c5c	85 28		sta $28				sta 	codePtr
.0c5e	90 02		bcc $0c62			bcc 	_EHNoCarry
.0c60	e6 29		inc $29				inc 	codePtr+1
.0c62					_EHNoCarry:
.0c62	68		pla				pla
.0c63	7a		ply				ply
.0c64	85 2c		sta $2c				sta 	zTemp0
.0c66	84 2d		sty $2d				sty 	zTemp0+1
.0c68	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c6a	a0 01		ldy #$01			ldy 	#1
.0c6c					_EHDisplayMsg:
.0c6c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c6e	20 b1 1c	jsr $1cb1			jsr 	XPrintCharacterToChannel
.0c71	c8		iny				iny
.0c72	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c74	d0 f6		bne $0c6c			bne 	_EHDisplayMsg
.0c76	a9 20		lda #$20			lda 	#32
.0c78	20 b1 1c	jsr $1cb1			jsr 	XPrintCharacterToChannel
.0c7b	a9 40		lda #$40			lda 	#64
.0c7d	20 b1 1c	jsr $1cb1			jsr 	XPrintCharacterToChannel
.0c80	a9 20		lda #$20			lda 	#32
.0c82	20 b1 1c	jsr $1cb1			jsr 	XPrintCharacterToChannel
.0c85	20 8c 0c	jsr $0c8c			jsr 	EHDisplayCodePtr
.0c88	38		sec				sec 								; report error.
.0c89	4c 50 0c	jmp $0c50			jmp 	EndRuntime
.0c8c					EHDisplayCodePtr:
.0c8c	a9 24		lda #$24			lda 	#'$'
.0c8e	20 b1 1c	jsr $1cb1			jsr 	XPrintCharacterToChannel
.0c91	38		sec				sec
.0c92	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c94	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c97	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9a	a5 28		lda $28				lda 	codePtr
.0c9c	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9f	60		rts				rts
.0ca0					_EHDisplayHex:
.0ca0	48		pha				pha
.0ca1	4a		lsr a				lsr 	a
.0ca2	4a		lsr a				lsr 	a
.0ca3	4a		lsr a				lsr 	a
.0ca4	4a		lsr a				lsr 	a
.0ca5	20 a9 0c	jsr $0ca9			jsr 	_EHDisplayNibble
.0ca8	68		pla				pla
.0ca9					_EHDisplayNibble:
.0ca9	29 0f		and #$0f			and 	#15
.0cab	c9 0a		cmp #$0a			cmp 	#10
.0cad	90 02		bcc $0cb1			bcc 	_EHNotHex
.0caf	69 06		adc #$06			adc 	#6
.0cb1					_EHNotHex:
.0cb1	69 30		adc #$30			adc 	#48
.0cb3	4c b1 1c	jmp $1cb1			jmp 	XPrintCharacterToChannel
.0cb6					CommandXFor:
.0cb6	fa		plx				plx
.0cb7	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0cb9	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0cbc	20 78 11	jsr $1178			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0cbf	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0cc1	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cc4	ca		dex				dex
.0cc5	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0cc7	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cca	ca		dex				dex
.0ccb	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0ccd	29 80		and #$80			and 	#$80
.0ccf	a0 04		ldy #$04			ldy 	#4
.0cd1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd3	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0cd5	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0cd7	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd9	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0cdb	c8		iny				iny
.0cdc	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cde	18		clc				clc
.0cdf	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0ce1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ce3	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0ce6	85 2d		sta $2d				sta 	zTemp0+1
.0ce8	ca		dex				dex 								; throw reference.
.0ce9	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0ceb	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0ced	a0 0c		ldy #$0c			ldy 	#12
.0cef	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf1	a0 12		ldy #$12			ldy 	#18
.0cf3	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf5	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0cf7	88		dey				dey 								; now the exponents.
.0cf8	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0cfa	a0 0b		ldy #$0b			ldy 	#11
.0cfc	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cfe	a0 11		ldy #$11			ldy 	#17
.0d00	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d02	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0d04	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d06	c8		iny				iny
.0d07	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d09	c8		iny				iny
.0d0a	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d0c	d0 08		bne $0d16			bne 	_CFNoOptimise
.0d0e	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0d10	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0d12	09 40		ora #$40			ora 	#$40
.0d14	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d16					_CFNoOptimise:
.0d16	a0 00		ldy #$00			ldy 	#0
.0d18	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d1b					CopyTOSToOffsetY:
.0d1b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0d1d	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d1f	c8		iny				iny
.0d20	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0d22	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d24	c8		iny				iny
.0d25	b5 56		lda $56,x			lda 	NSMantissa2,x
.0d27	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d29	c8		iny				iny
.0d2a	b5 62		lda $62,x			lda 	NSMantissa3,x
.0d2c	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d2e	c8		iny				iny
.0d2f	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d31	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d33	c8		iny				iny
.0d34	b5 32		lda $32,x			lda 	NSStatus,x
.0d36	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d38	60		rts				rts
.0d39					StackOpenFrame:
.0d39	48		pha				pha 								; save frame marker
.0d3a	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d3c	85 2c		sta $2c				sta 	zTemp0
.0d3e	38		sec				sec 								; subtract from runtime stack pointer.
.0d3f	a5 24		lda $24				lda		runtimeStackPtr
.0d41	e5 2c		sbc $2c				sbc 	zTemp0
.0d43	85 24		sta $24				sta 	runtimeStackPtr
.0d45	a5 25		lda $25				lda		runtimeStackPtr+1
.0d47	e9 00		sbc #$00			sbc 	#0
.0d49	85 25		sta $25				sta 	runtimeStackPtr+1
.0d4b	68		pla				pla 								; put frame marker at +0
.0d4c	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d4e	60		rts				rts
.0d4f					StackCloseFrame:
.0d4f	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d51	29 1f		and #$1f			and 	#$1F 						; size
.0d53	18		clc				clc
.0d54	65 24		adc $24				adc 	runtimeStackPtr
.0d56	85 24		sta $24				sta 	runtimeStackPtr
.0d58	90 02		bcc $0d5c			bcc 	_SCFNoCarry
.0d5a	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d5c					_SCFNoCarry:
.0d5c	60		rts				rts
.0d5d					StackFindFrame:
.0d5d	8d 0b 04	sta $040b			sta 	requiredFrame
.0d60					_SFFLoop:
.0d60	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d62	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d64	f0 10		beq $0d76			beq 	SCFFail
.0d66	cd 0b 04	cmp $040b			cmp 	requiredFrame 				; found this type ?
.0d69	f0 05		beq $0d70			beq 	_SFFFound
.0d6b	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close the top frame
.0d6e	80 f0		bra $0d60			bra 	_SFFLoop 					; and try te next.
.0d70					_SFFFound:
.0d70	60		rts				rts
.0d71					StackCheckFrame:
.0d71	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d73	d0 01		bne $0d76			bne 	SCFFail
.0d75	60		rts				rts
.0d76					SCFFail:
.0d76	4c ae 1f	jmp $1fae		jmp	ErrorV_structure
.040b					requiredFrame:
>040b							.fill 	1
.0d79					UnaryFre:
.0d79	fa		plx				plx
.0d7a	20 88 26	jsr $2688			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d7d	38		sec				sec
.0d7e	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d81	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d84	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d86	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d89	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d8c	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d8e	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d91					CommandXGet:
.0d91	fa		plx				plx
.0d92	e8		inx				inx
.0d93	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d95	20 31 17	jsr $1731			jsr 	StringAllocTemp
.0d98	20 81 13	jsr $1381			jsr 	VectorGetCharacter 			; get a character
.0d9b	c9 00		cmp #$00			cmp 	#0
.0d9d	f0 09		beq $0da8			beq 	_CGNone
.0d9f	5a		phy				phy
.0da0	a0 01		ldy #$01			ldy 	#1 							; store char
.0da2	91 22		sta ($22),y			sta 	(zsTemp),y
.0da4	98		tya				tya 								; store length.
.0da5	92 22		sta ($22)			sta 	(zsTemp)
.0da7	7a		ply				ply
.0da8					_CGNone:
.0da8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dab					CommandXGosub:
.0dab	fa		plx				plx
.0dac	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dae	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0db1	20 78 11	jsr $1178			jsr 	StackSaveCurrentPosition
.0db4	4c c9 0d	jmp $0dc9			jmp 	PerformGOTO
.0db7					CommandReturn:
.0db7	fa		plx				plx
.0db8	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dba	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.0dbd	20 89 11	jsr $1189			jsr 	StackLoadCurrentPosition
.0dc0	c8		iny				iny
.0dc1	c8		iny				iny
.0dc2	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame
.0dc5	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dc8					CommandXGoto:
.0dc8	fa		plx				plx
.0dc9					PerformGOTO:
.0dc9	c8		iny				iny 								; push MSB of offset on stack
.0dca	b1 28		lda ($28),y			lda 	(codePtr),y
.0dcc	48		pha				pha
.0dcd	88		dey				dey 								; point LSB of offset
.0dce	18		clc				clc 								; add LSB
.0dcf	b1 28		lda ($28),y			lda 	(codePtr),y
.0dd1	65 28		adc $28				adc 	codePtr
.0dd3	85 28		sta $28				sta 	codePtr
.0dd5	68		pla				pla 								; restore offset MSB and add
.0dd6	65 29		adc $29				adc 	codePtr+1
.0dd8	85 29		sta $29				sta 	codePtr+1
.0dda	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ddd					CommandGotoZ:
.0ddd	fa		plx				plx
.0dde	20 aa 26	jsr $26aa			jsr 	FloatIsZero
.0de1	ca		dex				dex
.0de2	c9 00		cmp #$00			cmp 	#0
.0de4	f0 e3		beq $0dc9			beq 	PerformGOTO
.0de6	c8		iny				iny
.0de7	c8		iny				iny
.0de8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0deb					CommandGotoNZ:
.0deb	fa		plx				plx
.0dec	20 aa 26	jsr $26aa			jsr 	FloatIsZero
.0def	ca		dex				dex
.0df0	c9 00		cmp #$00			cmp 	#0
.0df2	d0 d5		bne $0dc9			bne 	PerformGOTO
.0df4	c8		iny				iny
.0df5	c8		iny				iny
.0df6	4c 4f 08	jmp $084f			jmp 	NextCommand
.0df9					Command_PSET:
.0df9	fa		plx				plx
.0dfa	5a		phy				phy
.0dfb	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the colour
.0dfe	48		pha				pha
.0dff	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e01	a0 02		ldy #$02			ldy 	#X16_r0
.0e03	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e06	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0e09	68		pla				pla 								; set pixel.
.0e0a	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0e0d	7a		ply				ply
.0e0e	a2 ff		ldx #$ff			ldx 	#$FF
.0e10	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e13					Command_LINE:
.0e13	fa		plx				plx
.0e14	5a		phy				phy
.0e15	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e18	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0e1a	a0 02		ldy #$02			ldy 	#X16_r0
.0e1c	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0e1f	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0e22	7a		ply				ply
.0e23	a2 ff		ldx #$ff			ldx 	#$FF
.0e25	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e28					Command_RECT:
.0e28	fa		plx				plx
.0e29	5a		phy				phy
.0e2a	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e2d	38		sec				sec
.0e2e	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e31	7a		ply				ply
.0e32	a2 ff		ldx #$ff			ldx 	#$FF
.0e34	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e37					Command_FRAME:
.0e37	fa		plx				plx
.0e38	5a		phy				phy
.0e39	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e3c	18		clc				clc
.0e3d	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e40	7a		ply				ply
.0e41	a2 ff		ldx #$ff			ldx 	#$FF
.0e43	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e46					Command_CHAR:
.0e46	fa		plx				plx
.0e47	5a		phy				phy
.0e48	ca		dex				dex  								; set the draw colour
.0e49	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e4c	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e4e	a0 02		ldy #$02			ldy 	#X16_r0
.0e50	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e53	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e55	85 2c		sta $2c				sta 	zTemp0
.0e57	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e59	85 2d		sta $2d				sta 	zTemp0+1
.0e5b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e5d	85 2e		sta $2e				sta 	zTemp1
.0e5f					_CCLoop:
.0e5f	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e61	f0 0f		beq $0e72			beq 	_CCExit
.0e63	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e65	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e67	d0 02		bne $0e6b			bne 	_CCNoCarry
.0e69	e6 2d		inc $2d				inc 	zTemp0+1
.0e6b					_CCNoCarry:
.0e6b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e6d	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e70	80 ed		bra $0e5f			bra 	_CCLoop						; go round.
.0e72					_CCExit:
.0e72	7a		ply				ply
.0e73	a2 ff		ldx #$ff			ldx 	#$FF
.0e75	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e78					GraphicsColour:
.0e78	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0e7b	aa		tax				tax
.0e7c	a0 00		ldy #$00			ldy 	#0
.0e7e	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e81	60		rts				rts
.0e82					GraphicsCopy4:
.0e82	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e85					GraphicsCopy2:
.0e85	20 88 0e	jsr $0e88			jsr 	GraphicsCopy1
.0e88					GraphicsCopy1:
.0e88	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.0e8b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e8d	99 00 00	sta $0000,y			sta 	0,y
.0e90	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e92	99 01 00	sta $0001,y			sta 	1,y
.0e95	e8		inx				inx
.0e96	c8		iny				iny
.0e97	c8		iny				iny
.0e98	60		rts				rts
.0e99					GraphicsRectCoords:
.0e99	20 78 0e	jsr $0e78			jsr 	GraphicsColour 				; set colour
.0e9c	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e9e	a0 02		ldy #$02			ldy 	#X16_r0
.0ea0	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0ea3	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0ea5	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ea8	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0eaa	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ead	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0eaf	74 09		stz $09,x			stz 	9,x
.0eb1	60		rts				rts
.0eb2					_GRCSortSubtract:
.0eb2	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0eb4	d5 00		cmp $00,x			cmp 	0,x
.0eb6	b5 05		lda $05,x			lda 	5,x
.0eb8	f5 01		sbc $01,x			sbc 	1,x
.0eba	b0 08		bcs $0ec4			bcs 	_GRCNoSwap 					; >= swap.
.0ebc	20 d2 0e	jsr $0ed2			jsr 	_GRCSwapByte 				; swap 0/2
.0ebf	e8		inx				inx
.0ec0	20 d2 0e	jsr $0ed2			jsr 	_GRCSwapByte 				; swap 1/3
.0ec3	ca		dex				dex
.0ec4					_GRCNoSwap:
.0ec4	38		sec				sec 								; calculate width/height into 4,5
.0ec5	b5 04		lda $04,x			lda 	4,x
.0ec7	f5 00		sbc $00,x			sbc 	0,x
.0ec9	95 04		sta $04,x			sta 	4,x
.0ecb	b5 05		lda $05,x			lda 	5,x
.0ecd	f5 01		sbc $01,x			sbc 	1,x
.0ecf	95 05		sta $05,x			sta 	5,x
.0ed1	60		rts				rts
.0ed2					_GRCSwapByte:
.0ed2	b5 04		lda $04,x			lda 	4,x
.0ed4	48		pha				pha
.0ed5	b5 00		lda $00,x			lda 	0,x
.0ed7	95 04		sta $04,x			sta 	4,x
.0ed9	68		pla				pla
.0eda	95 00		sta $00,x			sta 	0,x
.0edc	60		rts				rts
.0edd					Unary16Hex:
.0edd	fa		plx				plx
.0ede	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.0ee1	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0ee3	20 31 17	jsr $1731			jsr 	StringAllocTemp
.0ee6	a5 2d		lda $2d				lda 	zTemp0+1
.0ee8	f0 03		beq $0eed			beq 	_UHNoHigh
.0eea	20 f5 0e	jsr $0ef5			jsr 	_UHWriteHex
.0eed					_UHNoHigh:
.0eed	a5 2c		lda $2c				lda 	zTemp0
.0eef	20 f5 0e	jsr $0ef5			jsr 	_UHWriteHex
.0ef2	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ef5					_UHWriteHex:
.0ef5	48		pha				pha
.0ef6	4a		lsr a				lsr 	a
.0ef7	4a		lsr a				lsr 	a
.0ef8	4a		lsr a				lsr 	a
.0ef9	4a		lsr a				lsr 	a
.0efa	20 fe 0e	jsr $0efe			jsr 	_UHWriteNibl
.0efd	68		pla				pla
.0efe					_UHWriteNibl:
.0efe	29 0f		and #$0f			and 	#15
.0f00	c9 0a		cmp #$0a			cmp 	#10
.0f02	90 02		bcc $0f06			bcc 	_UHDigit
.0f04	69 06		adc #$06			adc 	#6
.0f06					_UHDigit:
.0f06	69 30		adc #$30			adc 	#48
.0f08	20 5a 17	jsr $175a			jsr 	StringWriteChar
.0f0b	60		rts				rts
.0f0c					IndFloatRead:
.0f0c	fa		plx				plx
.0f0d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f0f	85 2c		sta $2c				sta 	zTemp0
.0f11	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f13	18		clc				clc
.0f14	6d 07 04	adc $0407			adc 	variableStartPage
.0f17	85 2d		sta $2d				sta 	zTemp0+1
.0f19	ca		dex				dex 								; throw the address
.0f1a	20 fa 14	jsr $14fa			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0f1d	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f20					IndInt16Read:
.0f20	fa		plx				plx
.0f21	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f23	85 2c		sta $2c				sta 	zTemp0
.0f25	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f27	18		clc				clc
.0f28	6d 07 04	adc $0407			adc 	variableStartPage
.0f2b	85 2d		sta $2d				sta 	zTemp0+1
.0f2d	ca		dex				dex 								; throw the address
.0f2e	20 36 15	jsr $1536			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f31	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f34					IndStringRead:
.0f34	fa		plx				plx
.0f35	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f37	85 2c		sta $2c				sta 	zTemp0
.0f39	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f3b	18		clc				clc
.0f3c	6d 07 04	adc $0407			adc 	variableStartPage
.0f3f	85 2d		sta $2d				sta 	zTemp0+1
.0f41	ca		dex				dex 								; throw the address
.0f42	20 7b 15	jsr $157b			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f45	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f48					IndFloatWrite:
.0f48	fa		plx				plx
.0f49	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f4b	85 2c		sta $2c				sta 	zTemp0
.0f4d	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f4f	18		clc				clc
.0f50	6d 07 04	adc $0407			adc 	variableStartPage
.0f53	85 2d		sta $2d				sta 	zTemp0+1
.0f55	20 ed 1a	jsr $1aed			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f58	ca		dex				dex 								; throw the address as well.
.0f59	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f5c					IndInt16Write:
.0f5c	fa		plx				plx
.0f5d	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f5f	85 2c		sta $2c				sta 	zTemp0
.0f61	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f63	18		clc				clc
.0f64	6d 07 04	adc $0407			adc 	variableStartPage
.0f67	85 2d		sta $2d				sta 	zTemp0+1
.0f69	20 29 1b	jsr $1b29			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f6c	ca		dex				dex 								; throw the address as well.
.0f6d	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f70					IndStringWrite:
.0f70	fa		plx				plx
.0f71	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f73	85 2c		sta $2c				sta 	zTemp0
.0f75	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f77	18		clc				clc
.0f78	6d 07 04	adc $0407			adc 	variableStartPage
.0f7b	85 2d		sta $2d				sta 	zTemp0+1
.0f7d	20 68 1b	jsr $1b68			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f80	ca		dex				dex 								; throw the address as well.
.0f81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f84					CommandXInput:
.0f84	fa		plx				plx
.0f85	5a		phy				phy 								; save Y
.0f86	e8		inx				inx									; space on stack
.0f87					_INError:
.0f87	20 bb 0f	jsr $0fbb			jsr 	InputStringToBuffer 		; input from keyboard
.0f8a	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.0f8c	85 2c		sta $2c				sta 	0+zTemp0
.0f8e	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f90	85 2d		sta $2d				sta 	1+zTemp0
.0f92	20 78 19	jsr $1978			jsr 	ValEvaluateZTemp0
.0f95	b0 f0		bcs $0f87			bcs 	_INError 					; failed, try again.
.0f97	7a		ply				ply 								; restore Y
.0f98	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f9b					CommandInputString:
.0f9b	fa		plx				plx
.0f9c	5a		phy				phy 								; save Y
.0f9d	20 bb 0f	jsr $0fbb			jsr 	InputStringToBuffer 		; input from keyboard
.0fa0	e8		inx				inx 								; make space on stack
.0fa1	20 88 26	jsr $2688			jsr 	FloatSetZero 				; store as string on stack
.0fa4	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.0fa6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0fa8	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0faa	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0fac	a9 40		lda #$40			lda 	#NSSString
.0fae	95 32		sta $32,x			sta 	NSStatus,x
.0fb0	7a		ply				ply 								; restore Y
.0fb1	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fb4					CommandInputReset:
.0fb4	fa		plx				plx
.0fb5	9c 0c 04	stz $040c			stz 	InputBuffer
.0fb8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fbb					InputStringToBuffer:
.0fbb	a9 f5		lda #$f5			lda 	#((InputBumpNext) & $FF)
.0fbd	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.0fc0	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0fc2	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.0fc5	a9 d2		lda #$d2			lda 	#((InputLookNext) & $FF)
.0fc7	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.0fca	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0fcc	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.0fcf	4c 57 14	jmp $1457			jmp 	GetStringToBuffer
.0fd2					InputLookNext:
.0fd2	da		phx				phx
.0fd3					_ILNRetry:
.0fd3	ad 0c 04	lda $040c			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fd6	d0 08		bne $0fe0			bne 	_ILNNotEmpty
.0fd8	20 f9 0f	jsr $0ff9			jsr 	InputGetNewLine 			; get a new line
.0fdb	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset read position.
.0fde	80 f3		bra $0fd3			bra 	_ILNRetry
.0fe0					_ILNNotEmpty:
.0fe0	ae 5d 04	ldx $045d			ldx 	InputBufferPos 				; get head available character
.0fe3	bd 0c 04	lda $040c,x			lda 	InputBuffer,x
.0fe6	d0 08		bne $0ff0			bne 	_ILNExit 					; if not EOS return it with CC.
.0fe8					_ILNNextLine:
.0fe8	9c 0c 04	stz $040c			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0feb	38		sec				sec 								; return CS,Zero
.0fec	fa		plx				plx
.0fed	a9 0d		lda #$0d			lda 	#13
.0fef	60		rts				rts
.0ff0					_ILNExit:
.0ff0	fa		plx				plx
.0ff1	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0ff3	18		clc				clc
.0ff4	60		rts				rts
.0ff5					InputBumpNext:
.0ff5	ee 5d 04	inc $045d			inc 	InputBufferPos
.0ff8	60		rts				rts
.0ff9					InputGetNewLine:
.0ff9	48		pha				pha
.0ffa	da		phx				phx
.0ffb	5a		phy				phy
.0ffc	a9 3f		lda #$3f			lda 	#"?"
.0ffe	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.1001	a0 00		ldy #$00			ldy 	#0 							; line position.
.1003					_IGNLLoop:
.1003	20 81 13	jsr $1381			jsr 	VectorGetCharacter 			; get a character
.1006	c9 00		cmp #$00			cmp 	#0
.1008	f0 f9		beq $1003			beq 	_IGNLLoop
.100a	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.100c	f0 11		beq $101f			beq 	_IGNBackspace
.100e	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.1010	f0 17		beq $1029			beq 	_IGNExit
.1012	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.1014	f0 ed		beq $1003			beq 	_IGNLLoop
.1016	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1019	c8		iny				iny
.101a	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.101d	80 e4		bra $1003			bra 	_IGNLLoop
.101f					_IGNBackspace:
.101f	c0 00		cpy #$00			cpy 	#0
.1021	f0 e0		beq $1003			beq 	_IGNLLoop
.1023	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.1026	88		dey				dey
.1027	80 da		bra $1003			bra 	_IGNLLoop
.1029					_IGNExit:
.1029	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.102c	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.102e	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1031	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset position to start of input buffer.
.1034	7a		ply				ply
.1035	fa		plx				plx
.1036	68		pla				pla
.1037	60		rts				rts
.1038					IGNLEchoIfScreen:
.1038	ae 5f 04	ldx $045f			ldx 	currentChannel
.103b	d0 03		bne $1040			bne 	_IGNLEExit
.103d	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.1040					_IGNLEExit:
.1040	60		rts				rts
.040c					InputBuffer:
>040c							.fill 	81
.045d					InputBufferPos:
>045d							.fill 	1
.1041					GetInteger8Bit:
.1041	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.1044	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1046	60		rts				rts
.1047					GetInteger16Bit:
.1047	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.104a	34 32		bit $32,x			bit 	NSStatus,x
.104c	30 09		bmi $1057			bmi 	Negate16Bit
.104e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1050	85 2c		sta $2c				sta 	zTemp0
.1052	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1054	85 2d		sta $2d				sta 	zTemp0+1
.1056	60		rts				rts
.1057					Negate16Bit:
.1057	38		sec				sec
.1058	a9 00		lda #$00			lda 	#0
.105a	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.105c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.105e	85 2c		sta $2c				sta 	zTemp0
.1060	a9 00		lda #$00			lda 	#0
.1062	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1064	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1066	85 2d		sta $2d				sta 	zTemp0+1
.1068	60		rts				rts
.1069					UnaryJoy:
.1069	fa		plx				plx
.106a	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; port #
.106d	48		pha				pha 								; zero the result.
.106e	20 88 26	jsr $2688			jsr 	FloatSetZero
.1071	68		pla				pla
.1072	5a		phy				phy
.1073	da		phx				phx
.1074	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1077	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1079	d0 10		bne $108b			bne 	_UJNoHardware
.107b	a8		tay				tay 								; move XA -> AY
.107c	8a		txa				txa
.107d	fa		plx				plx 								; we can update it now.
.107e	49 ff		eor #$ff			eor 	#$FF
.1080	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1082	98		tya				tya
.1083	49 ff		eor #$ff			eor 	#$FF
.1085	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1087	7a		ply				ply 								; restore Y
.1088	4c 4f 08	jmp $084f			jmp 	NextCommand
.108b					_UJNoHardware:
.108b	fa		plx				plx
.108c	7a		ply				ply
.108d	a9 01		lda #$01			lda 	#1 							; set result to -1
.108f	20 8a 26	jsr $268a			jsr 	FloatSetByte
.1092	20 4a 26	jsr $264a			jsr 	FloatNegate
.1095	4c 4f 08	jmp $084f			jmp 	NextCommand
.1098					UnaryLen:
.1098	fa		plx				plx
.1099	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.109b	85 2c		sta $2c				sta 	zTemp0
.109d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.109f	85 2d		sta $2d				sta 	zTemp0+1
.10a1	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.10a3	20 8a 26	jsr $268a			jsr 	FloatSetByte
.10a6	4c 4f 08	jmp $084f			jmp 	NextCommand
.10a9					LinkFloatAdd:
.10a9	fa		plx				plx
.10aa	5a		phy			phy
.10ab	20 ac 20	jsr $20ac		jsr	FloatAdd
.10ae	7a		ply			ply
.10af	4c 4f 08	jmp $084f			jmp 	NextCommand
.10b2					LinkFloatSubtract:
.10b2	fa		plx				plx
.10b3	5a		phy			phy
.10b4	20 a6 20	jsr $20a6		jsr	FloatSubtract
.10b7	7a		ply			ply
.10b8	4c 4f 08	jmp $084f			jmp 	NextCommand
.10bb					LinkFloatMultiply:
.10bb	fa		plx				plx
.10bc	5a		phy			phy
.10bd	20 48 23	jsr $2348		jsr	FloatMultiply
.10c0	7a		ply			ply
.10c1	4c 4f 08	jmp $084f			jmp 	NextCommand
.10c4					LinkFloatDivide:
.10c4	fa		plx				plx
.10c5	5a		phy			phy
.10c6	20 d1 21	jsr $21d1		jsr	FloatDivide
.10c9	b0 5c		bcs $1127		bcs	DivZeroError
.10cb	7a		ply			ply
.10cc	4c 4f 08	jmp $084f			jmp 	NextCommand
.10cf					LinkFloatPower:
.10cf	fa		plx				plx
.10d0	5a		phy			phy
.10d1	20 51 29	jsr $2951		jsr	FloatPower
.10d4	b0 4e		bcs $1124		bcs	MapRangeError
.10d6	7a		ply			ply
.10d7	4c 4f 08	jmp $084f			jmp 	NextCommand
.10da					LinkCompareGreater:
.10da	fa		plx				plx
.10db	5a		phy			phy
.10dc	20 55 21	jsr $2155		jsr	CompareGreater
.10df	7a		ply			ply
.10e0	4c 4f 08	jmp $084f			jmp 	NextCommand
.10e3					LinkCompareEqual:
.10e3	fa		plx				plx
.10e4	5a		phy			phy
.10e5	20 37 21	jsr $2137		jsr	CompareEqual
.10e8	7a		ply			ply
.10e9	4c 4f 08	jmp $084f			jmp 	NextCommand
.10ec					LinkCompareLess:
.10ec	fa		plx				plx
.10ed	5a		phy			phy
.10ee	20 4d 21	jsr $214d		jsr	CompareLess
.10f1	7a		ply			ply
.10f2	4c 4f 08	jmp $084f			jmp 	NextCommand
.10f5					LinkCompareGreaterEqual:
.10f5	fa		plx				plx
.10f6	5a		phy			phy
.10f7	20 65 21	jsr $2165		jsr	CompareGreaterEqual
.10fa	7a		ply			ply
.10fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.10fe					LinkCompareNotEqual:
.10fe	fa		plx				plx
.10ff	5a		phy			phy
.1100	20 47 21	jsr $2147		jsr	CompareNotEqual
.1103	7a		ply			ply
.1104	4c 4f 08	jmp $084f			jmp 	NextCommand
.1107					LinkCompareLessEqual:
.1107	fa		plx				plx
.1108	5a		phy			phy
.1109	20 5d 21	jsr $215d		jsr	CompareLessEqual
.110c	7a		ply			ply
.110d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1110					LinkFloatIntegerPartDown:
.1110	fa		plx				plx
.1111	5a		phy			phy
.1112	20 e7 22	jsr $22e7		jsr	FloatIntegerPartDown
.1115	7a		ply			ply
.1116	4c 4f 08	jmp $084f			jmp 	NextCommand
.1119					LinkFloatSquareRoot:
.1119	fa		plx				plx
.111a	5a		phy			phy
.111b	20 d3 29	jsr $29d3		jsr	FloatSquareRoot
.111e	b0 04		bcs $1124		bcs	MapRangeError
.1120	7a		ply			ply
.1121	4c 4f 08	jmp $084f			jmp 	NextCommand
.1124					MapRangeError:
.1124	4c 13 1f	jmp $1f13		jmp	ErrorV_range
.1127					DivZeroError:
.1127	4c 9c 1f	jmp $1f9c		jmp	ErrorV_divzero
.112a					LinkFloatLogarithm:
.112a	fa		plx				plx
.112b	5a		phy			phy
.112c	20 dd 28	jsr $28dd		jsr	FloatLogarithm
.112f	b0 f3		bcs $1124		bcs	MapRangeError
.1131	7a		ply			ply
.1132	4c 4f 08	jmp $084f			jmp 	NextCommand
.1135					LinkFloatExponent:
.1135	fa		plx				plx
.1136	5a		phy			phy
.1137	20 da 27	jsr $27da		jsr	FloatExponent
.113a	7a		ply			ply
.113b	4c 4f 08	jmp $084f			jmp 	NextCommand
.113e					LinkFloatCosine:
.113e	fa		plx				plx
.113f	5a		phy			phy
.1140	20 ce 27	jsr $27ce		jsr	FloatCosine
.1143	7a		ply			ply
.1144	4c 4f 08	jmp $084f			jmp 	NextCommand
.1147					LinkFloatSine:
.1147	fa		plx				plx
.1148	5a		phy			phy
.1149	20 6e 29	jsr $296e		jsr	FloatSine
.114c	7a		ply			ply
.114d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1150					LinkFloatTangent:
.1150	fa		plx				plx
.1151	5a		phy			phy
.1152	20 df 29	jsr $29df		jsr	FloatTangent
.1155	7a		ply			ply
.1156	4c 4f 08	jmp $084f			jmp 	NextCommand
.1159					LinkFloatArcTan:
.1159	fa		plx				plx
.115a	5a		phy			phy
.115b	20 b3 26	jsr $26b3		jsr	FloatArcTan
.115e	b0 c4		bcs $1124		bcs	MapRangeError
.1160	7a		ply			ply
.1161	4c 4f 08	jmp $084f			jmp 	NextCommand
.1164					LinkFloatCompare:
.1164	fa		plx				plx
.1165	5a		phy			phy
.1166	20 6d 21	jsr $216d		jsr	FloatCompare
.1169	7a		ply			ply
.116a	4c 4f 08	jmp $084f			jmp 	NextCommand
.116d					LinkDivideInt32:
.116d	fa		plx				plx
.116e	5a		phy			phy
.116f	20 fb 21	jsr $21fb		jsr	DivideInt32
.1172	b0 b0		bcs $1124		bcs	MapRangeError
.1174	7a		ply			ply
.1175	4c 4f 08	jmp $084f			jmp 	NextCommand
.1178					StackSaveCurrentPosition:
.1178	20 cb 08	jsr $08cb			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.117b	5a		phy				phy
.117c	a0 02		ldy #$02			ldy 	#2
.117e	a5 28		lda $28				lda 	codePtr
.1180	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1182	c8		iny				iny
.1183	a5 29		lda $29				lda 	codePtr+1
.1185	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1187	7a		ply				ply
.1188	60		rts				rts
.1189					StackLoadCurrentPosition:
.1189	a0 02		ldy #$02			ldy 	#2
.118b	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.118d	85 28		sta $28				sta 	codePtr
.118f	c8		iny				iny
.1190	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1192	85 29		sta $29				sta 	codePtr+1
.1194	a0 00		ldy #$00			ldy 	#0
.1196	60		rts				rts
.1197					XCommandMouse:
.1197	fa		plx				plx
.1198	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; mouse control.
.119b	ca		dex				dex
.119c	da		phx				phx
.119d	5a		phy				phy
.119e	48		pha				pha
.119f	38		sec				sec 								; get screen resolution
.11a0	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.11a3	68		pla				pla
.11a4	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.11a7	7a		ply				ply
.11a8	fa		plx				plx
.11a9	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ac					XUnaryMB:
.11ac	fa		plx				plx
.11ad	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11b0	a5 30		lda $30				lda 	zTemp2
.11b2	e8		inx				inx
.11b3	20 8a 26	jsr $268a			jsr 	FloatSetByte
.11b6	4c 4f 08	jmp $084f			jmp 	NextCommand
.11b9					XUnaryMX:
.11b9	fa		plx				plx
.11ba	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11bd	a5 2c		lda $2c				lda 	zTemp0
.11bf	e8		inx				inx
.11c0	20 8a 26	jsr $268a			jsr 	FloatSetByte
.11c3	a5 2d		lda $2d				lda 	zTemp0+1
.11c5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11c7	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ca					XUnaryMY:
.11ca	fa		plx				plx
.11cb	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11ce	a5 2e		lda $2e				lda 	zTemp1
.11d0	e8		inx				inx
.11d1	20 8a 26	jsr $268a			jsr 	FloatSetByte
.11d4	a5 2f		lda $2f				lda 	zTemp1+1
.11d6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11d8	4c 4f 08	jmp $084f			jmp 	NextCommand
.11db					XUnaryMouseCommon:
.11db	da		phx				phx
.11dc	5a		phy				phy
.11dd	a2 2c		ldx #$2c			ldx 	#zTemp0
.11df	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.11e2	85 30		sta $30				sta 	zTemp2
.11e4	7a		ply				ply
.11e5	fa		plx				plx
.11e6	60		rts				rts
.11e7					NegateTOS:
.11e7	fa		plx				plx
.11e8	20 4a 26	jsr $264a			jsr 	FloatNegate
.11eb	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ee					CommandNewLine:
.11ee	fa		plx				plx
.11ef	9c 6a 05	stz $056a			stz 	stringInitialised
.11f2	a2 ff		ldx #$ff			ldx 	#$FF
.11f4	4c 4f 08	jmp $084f			jmp 	NextCommand
.11f7					CommandXNext:
.11f7	fa		plx				plx
.11f8					_CNRetry:
.11f8	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.11fa	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.11fd	20 cb 08	jsr $08cb			jsr 	FixUpY 						; so we can use Y
.1200	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.1202	35 4a		and $4a,x			and 	NSMantissa1,x
.1204	c9 ff		cmp #$ff			cmp 	#$FF
.1206	f0 16		beq $121e			beq 	_CNNoIndexVariable
.1208	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.120a	a0 05		ldy #$05			ldy 	#5
.120c	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.120e	d0 07		bne $1217			bne 	_CNNIndexFail
.1210	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1212	c8		iny				iny
.1213	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.1215	f0 07		beq $121e			beq 	_CNNoIndexVariable
.1217					_CNNIndexFail:
.1217	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.1219	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close this frame
.121c	80 da		bra $11f8			bra 	_CNRetry
.121e					_CNNoIndexVariable:
.121e	ca		dex				dex
.121f	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.1221	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1223	29 40		and #$40			and 	#$40	 					; bit 6
.1225	d0 55		bne $127c			bne 	_CNOptimisedNext
.1227	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1229	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.122b	48		pha				pha
.122c	85 2c		sta $2c				sta 	zTemp0
.122e	c8		iny				iny
.122f	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1231	18		clc				clc
.1232	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1235	48		pha				pha
.1236	85 2d		sta $2d				sta 	zTemp0+1
.1238	20 fa 14	jsr $14fa			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.123b	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.123d	e8		inx				inx
.123e	20 bf 12	jsr $12bf			jsr 	CopyOffsetYToTOS
.1241	20 ac 20	jsr $20ac			jsr 	FloatAdd
.1244	68		pla				pla 								; restore address
.1245	85 2d		sta $2d				sta 	zTemp0+1
.1247	68		pla				pla
.1248	85 2c		sta $2c				sta 	zTemp0
.124a	20 ed 1a	jsr $1aed			jsr 	WriteFloatZTemp0Sub			; write float.
.124d	e8		inx				inx  								; recover written
.124e	e8		inx				inx 								; load offset
.124f	a0 0d		ldy #$0d			ldy 	#13
.1251	20 bf 12	jsr $12bf			jsr 	CopyOffsetYToTOS
.1254	20 6d 21	jsr $216d			jsr 	FloatCompare 				; and compare the floats.
.1257	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1258	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.125a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.125c	30 08		bmi $1266			bmi 	_CNDownStep
.125e	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1260	c9 01		cmp #$01			cmp 	#1 							; gone higher
.1262	f0 10		beq $1274			beq 	_CNExitFor 					; if so exit the loop
.1264	80 06		bra $126c			bra 	_CNLoopBack
.1266					_CNDownStep:
.1266	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1268	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.126a	f0 08		beq $1274			beq 	_CNExitFor
.126c					_CNLoopBack:
.126c	20 89 11	jsr $1189			jsr 	StackLoadCurrentPosition 	; loop back
.126f	a0 00		ldy #$00			ldy 	#0
.1271	4c 4f 08	jmp $084f			jmp 	NextCommand
.1274					_CNExitFor:
.1274	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; remove the frame and exit
.1277	a0 00		ldy #$00			ldy 	#0
.1279	4c 4f 08	jmp $084f			jmp 	NextCommand
.127c					_CNOptimisedNext:
.127c	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.127e	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1280	85 2c		sta $2c				sta 	zTemp0
.1282	c8		iny				iny
.1283	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1285	18		clc				clc
.1286	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1289	85 2d		sta $2d				sta 	zTemp0+1
.128b	a0 07		ldy #$07			ldy 	#7 							; STEP value
.128d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.128f	a0 ff		ldy #$ff			ldy 	#$FF
.1291	18		clc				clc
.1292					_CNOIncrement:
.1292	c8		iny				iny
.1293	71 2c		adc ($2c),y			adc 	(zTemp0),y
.1295	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1297	f0 f9		beq $1292			beq 	_CNOIncrement
.1299	18		clc				clc
.129a	a5 24		lda $24				lda 	runtimeStackPtr
.129c	69 0d		adc #$0d			adc 	#13
.129e	85 2e		sta $2e				sta 	zTemp1
.12a0	a5 25		lda $25				lda 	runtimeStackPtr+1
.12a2	69 00		adc #$00			adc 	#0
.12a4	85 2f		sta $2f				sta 	zTemp1+1
.12a6	a0 00		ldy #$00			ldy 	#0
.12a8	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.12aa	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.12ac	c8		iny				iny
.12ad	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.12af	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12b1	c8		iny				iny
.12b2	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.12b4	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12b6	c8		iny				iny
.12b7	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.12b9	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12bb	90 b7		bcc $1274			bcc	 	_CNExitFor
.12bd	80 ad		bra $126c			bra 	_CNLoopBack
.12bf					CopyOffsetYToTOS:
.12bf	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.12c3	c8		iny				iny
.12c4	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12c8	c8		iny				iny
.12c9	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12cb	95 56		sta $56,x			sta 	NSMantissa2,x
.12cd	c8		iny				iny
.12ce	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d0	95 62		sta $62,x			sta 	NSMantissa3,x
.12d2	c8		iny				iny
.12d3	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d5	95 6e		sta $6e,x			sta 	NSExponent,x
.12d7	c8		iny				iny
.12d8	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12da	95 32		sta $32,x			sta 	NSStatus,x
.12dc	60		rts				rts
.12dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.12e0					NotTOS:
.12e0	fa		plx				plx
.12e1	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.12e4	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.12e6	74 62		stz $62,x			stz 	NSMantissa3,x
.12e8	20 4a 26	jsr $264a			jsr 	FloatNegate		 			; negate
.12eb	e8		inx				inx 								; and subtract 1.
.12ec	a9 01		lda #$01			lda 	#1
.12ee	20 8a 26	jsr $268a			jsr 	FloatSetByte
.12f1	20 a6 20	jsr $20a6			jsr 	FloatSubtract
.12f4					_NotTOSSkip:
.12f4	4c 4f 08	jmp $084f			jmp 	NextCommand
.12f7					CommandXOn:
.12f7	fa		plx				plx
.12f8	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.12fb	8d 5e 04	sta $045e			sta 	onCount 					; save it.
.12fe	20 cb 08	jsr $08cb			jsr 	FixUpY 						; Y = 0
.1301					_CONFind:
.1301	ce 5e 04	dec $045e			dec 	onCount 					; reached zero, do this one
.1304	f0 0b		beq $1311			beq 	_CONFound
.1306	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1307	c8		iny				iny
.1308	c8		iny				iny
.1309	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.130b	c8		iny				iny
.130c	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.130e	f0 f1		beq $1301			beq 	_CONFind
.1310	88		dey				dey 								; point to character after last GOTO/GOSUB
.1311					_CONFound:
.1311	4c 4f 08	jmp $084f			jmp 	NextCommand
.1314					CommandMoreOn:
.1314	fa		plx				plx
.1315	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1316	c8		iny				iny
.1317	c8		iny				iny
.1318	4c 4f 08	jmp $084f			jmp 	NextCommand
.045e					onCount:
>045e							.fill 	1
.131b					UnaryPeek:
.131b	fa		plx				plx
.131c	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.131f	da		phx				phx
.1320	5a		phy				phy
.1321	a6 2c		ldx $2c				ldx 	zTemp0
.1323	a4 2d		ldy $2d				ldy 	zTemp0+1
.1325	20 87 1c	jsr $1c87			jsr 	XPeekMemory
.1328	7a		ply				ply
.1329	fa		plx				plx
.132a	20 8a 26	jsr $268a			jsr 	FloatSetByte
.132d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1330					UnaryPI:
.1330	fa		plx				plx
.1331	a9 19		lda #$19			lda 	#Const_pi-Const_base
.1333	20 b8 28	jsr $28b8			jsr 	LoadConstant
.1336	e8		inx				inx
.1337	4c 4f 08	jmp $084f			jmp 	NextCommand
.133a					CommandPOKE:
.133a	fa		plx				plx
.133b	da		phx				phx 								; save XY
.133c	5a		phy				phy
.133d	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1340	48		pha				pha
.1341	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1343	a8		tay				tay
.1344	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1346	aa		tax				tax
.1347	68		pla				pla
.1348	20 73 1c	jsr $1c73			jsr 	XPokeMemory
.134b	7a		ply				ply 								; restore YX and drop 2
.134c	fa		plx				plx
.134d	ca		dex				dex
.134e	ca		dex				dex
.134f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1352					UnaryPos:
.1352	fa		plx				plx
.1353	20 06 1c	jsr $1c06			jsr 	XGetHPos
.1356	20 8a 26	jsr $268a			jsr 	FloatSetByte
.1359	4c 4f 08	jmp $084f			jmp 	NextCommand
.135c					GetChannel:
.135c	fa		plx				plx
.135d	ad 5f 04	lda $045f			lda 	currentChannel
.1360	e8		inx				inx
.1361	20 8a 26	jsr $268a			jsr 	FloatSetByte
.1364	4c 4f 08	jmp $084f			jmp 	NextCommand
.1367					SetChannel:
.1367	fa		plx				plx
.1368	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.136b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.136d	8d 5f 04	sta $045f			sta 	currentChannel
.1370	ca		dex				dex
.1371	4c 4f 08	jmp $084f			jmp 	NextCommand
.1374					SetDefaultChannel:
.1374	9c 5f 04	stz $045f			stz 	currentChannel
.1377	60		rts				rts
.1378					VectorPrintCharacter:
.1378	da		phx				phx
.1379	ae 5f 04	ldx $045f			ldx 	currentChannel
.137c	20 b1 1c	jsr $1cb1			jsr 	XPrintCharacterToChannel
.137f	fa		plx				plx
.1380	60		rts				rts
.1381					VectorGetCharacter:
.1381	da		phx				phx
.1382	ae 5f 04	ldx $045f			ldx 	currentChannel
.1385	20 ea 1b	jsr $1bea			jsr 	XGetCharacterFromChannel
.1388	fa		plx				plx
.1389	60		rts				rts
.045f					currentChannel:
>045f							.fill 	1
.138a					PrintNumber:
.138a	fa		plx				plx
.138b	a9 07		lda #$07			lda 	#7
.138d	20 70 25	jsr $2570			jsr 	FloatToString 				; to number in decimal buffer
.1390	ca		dex				dex 								; drop
.1391	da		phx				phx
.1392	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1394					_PNLoop:
.1394	bd 98 05	lda $0598,x			lda 	decimalBuffer,x
.1397	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.139a	e8		inx				inx
.139b	bd 98 05	lda $0598,x			lda	 	decimalBuffer,x
.139e	d0 f4		bne $1394			bne 	_PNLoop
.13a0	a9 20		lda #$20			lda 	#32 						; trailing space
.13a2	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.13a5	fa		plx				plx
.13a6	4c 4f 08	jmp $084f			jmp 	NextCommand
.13a9					PrintString:
.13a9	fa		plx				plx
.13aa	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.13ac	85 2c		sta $2c				sta 	zTemp0
.13ae	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.13b0	85 2d		sta $2d				sta 	zTemp0+1
.13b2	ca		dex				dex 								; drop
.13b3	da		phx				phx
.13b4	5a		phy				phy
.13b5	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.13b7	aa		tax				tax
.13b8	a0 01		ldy #$01			ldy 	#1 							; Y = position
.13ba					_PSLoop:
.13ba	e0 00		cpx #$00			cpx 	#0 							; complete ?
.13bc	f0 09		beq $13c7			beq 	_PSExit
.13be	ca		dex				dex 								; dec count
.13bf	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.13c1	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.13c4	c8		iny				iny
.13c5	80 f3		bra $13ba			bra 	_PSLoop
.13c7					_PSExit:
.13c7	7a		ply				ply
.13c8	fa		plx				plx
.13c9	4c 4f 08	jmp $084f			jmp 	NextCommand
.13cc					CommandPushN:
.13cc	fa		plx				plx
.13cd	e8		inx				inx 								; next slot on stack
.13ce	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.13d0	95 6e		sta $6e,x			sta 	NSExponent,x
.13d2	c8		iny				iny
.13d3	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.13d5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13d7	c8		iny				iny
.13d8	b1 28		lda ($28),y			lda 	(codePtr),y
.13da	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13dc	c8		iny				iny
.13dd	b1 28		lda ($28),y			lda 	(codePtr),y
.13df	95 56		sta $56,x			sta 	NSMantissa2,x
.13e1	c8		iny				iny
.13e2	b1 28		lda ($28),y			lda 	(codePtr),y
.13e4	48		pha				pha
.13e5	29 7f		and #$7f			and 	#$7F
.13e7	95 62		sta $62,x			sta 	NSMantissa3,x
.13e9	68		pla				pla 								; sign in mantissa3:7
.13ea	29 80		and #$80			and 	#$80
.13ec	95 32		sta $32,x			sta 	NSStatus,x
.13ee	c8		iny				iny
.13ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.13f2					CommandPushS:
.13f2	fa		plx				plx
.13f3	e8		inx				inx 								; next slot on stack
.13f4	18		clc				clc
.13f5	98		tya				tya
.13f6	65 28		adc $28				adc 	codePtr 					; the string is inline
.13f8	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13fa	a5 29		lda $29				lda 	codePtr+1
.13fc	69 00		adc #$00			adc 	#0
.13fe	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1400	74 56		stz $56,x			stz 	NSMantissa2,x
.1402	74 62		stz $62,x			stz 	NSMantissa3,x
.1404	a9 40		lda #$40			lda 	#NSSString
.1406	95 32		sta $32,x			sta 	NSStatus,x
.1408	98		tya				tya 								; string length +1 added to Y
.1409	38		sec				sec
.140a	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.140c	a8		tay				tay
.140d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1410					CommandXRead:
.1410	fa		plx				plx
.1411	5a		phy				phy 								; save Y
.1412	20 43 14	jsr $1443			jsr 	ReadStringToBuffer 			; read element into buffer
.1415	e8		inx				inx									; space on stack
.1416	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.1418	85 2c		sta $2c				sta 	0+zTemp0
.141a	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.141c	85 2d		sta $2d				sta 	1+zTemp0
.141e	20 78 19	jsr $1978			jsr 	ValEvaluateZTemp0
.1421	b0 04		bcs $1427			bcs 	_CRError 					; failed
.1423	7a		ply				ply 								; restore Y
.1424	4c 4f 08	jmp $084f			jmp 	NextCommand
.1427					_CRError:
.1427	4c 23 1f	jmp $1f23		jmp	ErrorV_value
.142a					CommandReadString:
.142a	fa		plx				plx
.142b	5a		phy				phy 								; save Y
.142c	20 43 14	jsr $1443			jsr 	ReadStringToBuffer 			; read text
.142f	e8		inx				inx 								; make space on stack
.1430	20 88 26	jsr $2688			jsr 	FloatSetZero 				; store as string on stack
.1433	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.1435	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1437	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.1439	95 4a		sta $4a,x			sta 	NSMantissa1,x
.143b	a9 40		lda #$40			lda 	#NSSString
.143d	95 32		sta $32,x			sta 	NSStatus,x
.143f	7a		ply				ply 								; restore Y
.1440	4c 4f 08	jmp $084f			jmp 	NextCommand
.1443					ReadStringToBuffer:
.1443	a9 d6		lda #$d6			lda 	#((ReadBumpNext) & $FF)
.1445	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.1448	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.144a	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.144d	a9 a9		lda #$a9			lda 	#((ReadLookNext) & $FF)
.144f	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.1452	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.1454	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.1457					GetStringToBuffer:
.1457	20 a6 14	jsr $14a6			jsr		GetLookNext 				; skip all leading spaces.
.145a	f0 44		beq $14a0			beq 	_RBError 					; end of data
.145c	b0 f9		bcs $1457			bcs 	GetStringToBuffer 			; switched to new data line.
.145e	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1460	b0 05		bcs $1467			bcs 	_RBNoSpace
.1462	20 a3 14	jsr $14a3			jsr 	GetBumpNext 				; consume space and loop round.
.1465	80 f0		bra $1457			bra 	GetStringToBuffer
.1467					_RBNoSpace:
.1467	9c 61 04	stz $0461			stz 	ReadBufferSize 				; empty the buffer.
.146a	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.146c	d0 08		bne $1476			bne 	_RBCommaSep
.146e	8d 60 04	sta $0460			sta 	ReadSep 					; use as a seperator
.1471	20 a3 14	jsr $14a3			jsr 	GetBumpNext 				; consume the '"'
.1474	80 05		bra $147b			bra 	_RBGetText
.1476					_RBCommaSep:
.1476	a9 2c		lda #$2c			lda 	#","						; get till comma
.1478	8d 60 04	sta $0460			sta 	ReadSep
.147b					_RBGetText:
.147b	20 a6 14	jsr $14a6			jsr 	GetLookNext 				; what follows
.147e	b0 18		bcs $1498			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.1480	20 a3 14	jsr $14a3			jsr 	GetBumpNext 				; consume it whatever
.1483	cd 60 04	cmp $0460			cmp 	ReadSep 					; if found the seperator.
.1486	f0 10		beq $1498			beq 	_RBEndGet 					; exit after consumption
.1488	da		phx				phx
.1489	ae 61 04	ldx $0461			ldx 	ReadBufferSize 				; copy into buffer.
.148c	ee 61 04	inc $0461			inc 	ReadBufferSize
.148f	9d 62 04	sta $0462,x			sta 	ReadBuffer,x
.1492	9e 63 04	stz $0463,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.1495	fa		plx				plx
.1496	80 e3		bra $147b			bra 	_RBGetText
.1498					_RBEndGet:
.1498	c9 22		cmp #$22			cmp 	#'"'
.149a	d0 03		bne $149f			bne 	_RBNotQuote
.149c	20 a3 14	jsr $14a3			jsr 	GetBumpNext
.149f					_RBNotQuote:
.149f	60		rts				rts
.14a0					_RBError:
.14a0	4c d8 1f	jmp $1fd8		jmp	ErrorV_data
.14a3					GetBumpNext:
.14a3	6c 61 05	jmp ($0561)			jmp 	(ReadBumpNextVec)
.14a6					GetLookNext:
.14a6	6c 63 05	jmp ($0563)			jmp 	(ReadLookNextVec)
.14a9					ReadLookNext:
.14a9	ad 65 05	lda $0565			lda 	dataRemaining 				; any data remaining
.14ac	f0 04		beq $14b2			beq 	_RLNFindData
.14ae	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.14b0	18		clc				clc
.14b1	60		rts				rts
.14b2					_RLNFindData:
.14b2	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.14b4	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.14b6	f0 1a		beq $14d2			beq 	_RLNNoData
.14b8	c9 d0		cmp #$d0			cmp 	#PCD_CMD_DATA 				; Found DATA
.14ba	f0 05		beq $14c1			beq 	_RLNHaveData
.14bc					_RLNNext:
.14bc	20 56 20	jsr $2056			jsr 	MoveObjectForward			; else scan forward.
.14bf	80 f1		bra $14b2			bra 	_RLNFindData
.14c1					_RLNHaveData:
.14c1	a0 01		ldy #$01			ldy 	#1 							; get length
.14c3	b1 2a		lda ($2a),y			lda 	(objPtr),y
.14c5	f0 f5		beq $14bc			beq 	_RLNNext 					; skip if DATA alone
.14c7	20 d6 14	jsr $14d6			jsr 	ReadBumpNext 				; advance by two
.14ca	20 d6 14	jsr $14d6			jsr 	ReadBumpNext
.14cd	8d 65 05	sta $0565			sta 	dataRemaining 				; set data left count.
.14d0	38		sec				sec
.14d1	60		rts				rts
.14d2					_RLNNoData:
.14d2	a9 00		lda #$00			lda 	#0
.14d4	38		sec				sec
.14d5	60		rts				rts
.14d6					ReadBumpNext:
.14d6	e6 2a		inc $2a				inc 	objPtr
.14d8	d0 02		bne $14dc			bne 	_RBNSkip
.14da	e6 2b		inc $2b				inc 	objPtr+1
.14dc					_RBNSkip:
.14dc	ce 65 05	dec $0565			dec 	dataRemaining
.14df	60		rts				rts
.0460					ReadSep:
>0460							.fill 	1
.0461					ReadBufferSize:
>0461							.fill 	1
.0462					ReadBuffer:
>0462							.fill 	255
.0561					ReadBumpNextVec:
>0561							.fill 	2
.0563					ReadLookNextVec:
>0563							.fill 	2
.14e0					ReadFloatCommand:
.14e0	fa		plx				plx
.14e1	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14e3	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14e5	88		dey				dey 								; get the upper 3 bits
.14e6	b1 28		lda ($28),y			lda 	(codePtr),y
.14e8	29 07		and #$07			and 	#7
.14ea	c8		iny				iny
.14eb	c8		iny				iny
.14ec	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14ee	2a		rol a				rol 	a 							; carry will be clear.
.14ef	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14f2	85 2d		sta $2d				sta 	zTemp0+1
.14f4	20 fa 14	jsr $14fa			jsr 	ReadFloatZTemp0Sub
.14f7	4c 4f 08	jmp $084f			jmp 	NextCommand
.14fa					ReadFloatZTemp0Sub:
.14fa	5a		phy				phy 								; start write
.14fb	a0 01		ldy #$01			ldy 	#1
.14fd	e8		inx				inx
.14fe	b2 2c		lda ($2c)			lda 	(zTemp0)
.1500	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1502	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1504	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1506	c8		iny				iny
.1507	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1509	95 56		sta $56,x			sta 	NSMantissa2,x
.150b	c8		iny				iny
.150c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.150e	95 62		sta $62,x			sta 	NSMantissa3,x
.1510	c8		iny				iny
.1511	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1513	95 6e		sta $6e,x			sta 	NSExponent,x
.1515	c8		iny				iny
.1516	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1518	95 32		sta $32,x			sta 	NSStatus,x
.151a	7a		ply				ply
.151b	60		rts				rts
.151c					ReadIntegerCommand:
.151c	fa		plx				plx
.151d	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.151f	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1521	88		dey				dey 								; get the upper 3 bits
.1522	b1 28		lda ($28),y			lda 	(codePtr),y
.1524	29 07		and #$07			and 	#7
.1526	c8		iny				iny
.1527	c8		iny				iny
.1528	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.152a	2a		rol a				rol 	a 							; carry will be clear.
.152b	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.152e	85 2d		sta $2d				sta 	zTemp0+1
.1530	20 36 15	jsr $1536			jsr 	ReadIntegerZTemp0Sub
.1533	4c 4f 08	jmp $084f			jmp 	NextCommand
.1536					ReadIntegerZTemp0Sub:
.1536	5a		phy				phy 								; start write
.1537	a0 01		ldy #$01			ldy 	#1
.1539	e8		inx				inx 								; prepare
.153a	74 56		stz $56,x			stz 	NSMantissa2,x
.153c	74 62		stz $62,x			stz 	NSMantissa3,x
.153e	74 6e		stz $6e,x			stz 	NSExponent,x
.1540	74 32		stz $32,x			stz 	NSStatus,x
.1542	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1544	30 08		bmi $154e			bmi 	_RIZNegative
.1546	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1548	b2 2c		lda ($2c)			lda 	(zTemp0)
.154a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.154c	7a		ply				ply
.154d	60		rts				rts
.154e					_RIZNegative:
.154e	38		sec				sec 								; -ve read
.154f	a9 00		lda #$00			lda 	#0
.1551	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.1553	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1555	a9 00		lda #$00			lda 	#0
.1557	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1559	95 4a		sta $4a,x			sta 	NSMantissa1,x
.155b	a9 80		lda #$80			lda 	#$80
.155d	95 32		sta $32,x			sta 	NSStatus,x
.155f	7a		ply				ply
.1560	60		rts				rts
.1561					ReadStringCommand:
.1561	fa		plx				plx
.1562	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1564	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1566	88		dey				dey 								; get the upper 3 bits
.1567	b1 28		lda ($28),y			lda 	(codePtr),y
.1569	29 07		and #$07			and 	#7
.156b	c8		iny				iny
.156c	c8		iny				iny
.156d	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.156f	2a		rol a				rol 	a 							; carry will be clear.
.1570	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1573	85 2d		sta $2d				sta 	zTemp0+1
.1575	20 7b 15	jsr $157b			jsr 	ReadStringZTemp0Sub
.1578	4c 4f 08	jmp $084f			jmp 	NextCommand
.157b					ReadStringZTemp0Sub:
.157b	5a		phy				phy 								; start write
.157c	e8		inx				inx 								; prepare
.157d	74 56		stz $56,x			stz 	NSMantissa2,x
.157f	74 62		stz $62,x			stz 	NSMantissa3,x
.1581	74 6e		stz $6e,x			stz 	NSExponent,x
.1583	a9 40		lda #$40			lda 	#NSSString
.1585	74 32		stz $32,x			stz 	NSStatus,x
.1587	18		clc				clc
.1588	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.158a	69 02		adc #$02			adc 	#2 							; this points to actual data
.158c	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.158e	a0 01		ldy #$01			ldy 	#1
.1590	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1592	69 00		adc #$00			adc 	#0
.1594	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1596	d0 08		bne $15a0			bne 	_RSZNoDefault 				; if read $00 use a default value.
.1598	a9 a2		lda #$a2			lda 	#_RSZNull & $FF
.159a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.159c	a9 15		lda #$15			lda 	#_RSZNull >> 8
.159e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15a0					_RSZNoDefault:
.15a0	7a		ply				ply
.15a1	60		rts				rts
.15a2					_RSZNull:
>15a2	00						.byte 	0
.15a3					CommandRestoreX:
.15a3	fa		plx				plx
.15a4	20 aa 15	jsr $15aa			jsr 	RestoreCodeOffset
.15a7	4c 4f 08	jmp $084f			jmp 	NextCommand
.15aa					RestoreCodeOffset:
.15aa	20 cb 08	jsr $08cb			jsr 	FixUpY  					; make Y = 0 adjusting code Ptr.
.15ad	18		clc				clc 								; add LSB
.15ae	b1 28		lda ($28),y			lda 	(codePtr),y
.15b0	65 28		adc $28				adc 	codePtr
.15b2	85 2a		sta $2a				sta 	objPtr
.15b4	c8		iny				iny 								; add MSB
.15b5	b1 28		lda ($28),y			lda 	(codePtr),y
.15b7	65 29		adc $29				adc 	codePtr+1
.15b9	85 2b		sta $2b				sta 	objPtr+1
.15bb	c8		iny				iny 								; next command.
.15bc	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15bf	60		rts				rts
.15c0					RestoreCode:
.15c0	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.15c3	85 2b		sta $2b				sta 	objPtr+1
.15c5	64 2a		stz $2a				stz 	objPtr
.15c7	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15ca	60		rts				rts
.0565					dataRemaining:
>0565							.fill 	1		 					; 0 if not in data statement
.15cb					UnaryRND:
.15cb	fa		plx				plx
.15cc	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.15ce	10 17		bpl $15e7			bpl 	_URNoSeed
.15d0	20 dd 23	jsr $23dd			jsr 	FloatNormalise 				; some float value
.15d3	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.15d5	8d 66 05	sta $0566			sta 	randomSeed+0
.15d8	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15da	8d 67 05	sta $0567			sta 	randomSeed+1
.15dd	b5 56		lda $56,x			lda 	NSMantissa2,x
.15df	8d 68 05	sta $0568			sta 	randomSeed+2
.15e2	b5 62		lda $62,x			lda 	NSMantissa3,x
.15e4	8d 69 05	sta $0569			sta 	randomSeed+3
.15e7					_URNoSeed:
.15e7	20 09 16	jsr $1609			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.15ea	ad 66 05	lda $0566			lda 	randomSeed+0
.15ed	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15ef	ad 67 05	lda $0567			lda 	randomSeed+1
.15f2	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15f4	ad 68 05	lda $0568			lda 	randomSeed+2
.15f7	95 56		sta $56,x			sta 	NSMantissa2,x
.15f9	ad 69 05	lda $0569			lda 	randomSeed+3
.15fc	29 7f		and #$7f			and 	#$7F
.15fe	95 62		sta $62,x			sta 	NSMantissa3,x
.1600	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.1602	95 6e		sta $6e,x			sta 	NSExponent,x
.1604	74 32		stz $32,x			stz 	NSStatus,x
.1606	4c 4f 08	jmp $084f			jmp 	NextCommand
.1609					RandomNumberGenerator:
.1609	5a		phy				phy
.160a	ad 66 05	lda $0566			lda 	randomSeed+0 				; check if zero
.160d	0d 67 05	ora $0567			ora 	randomSeed+1
.1610	0d 68 05	ora $0568			ora 	randomSeed+2
.1613	0d 69 05	ora $0569			ora 	randomSeed+3
.1616	d0 07		bne $161f			bne 	_RNGNoSeed
.1618	ce 69 05	dec $0569			dec 	randomSeed+3 				; if so tweak and flog
.161b	a0 64		ldy #$64			ldy 	#100
.161d	80 05		bra $1624			bra 	_RNGLoop
.161f					_RNGNoSeed:
.161f	a0 08		ldy #$08			ldy 	#8
.1621	ad 66 05	lda $0566			lda 	randomSeed+0
.1624					_RNGLoop:
.1624	0a		asl a				asl		a
.1625	2e 67 05	rol $0567			rol 	randomSeed+1
.1628	2e 68 05	rol $0568			rol 	randomSeed+2
.162b	2e 69 05	rol $0569			rol 	randomSeed+3
.162e	90 02		bcc $1632			bcc		_RNGSkip
.1630	49 c5		eor #$c5			eor 	#$C5
.1632					_RNGSkip:
.1632	88		dey				dey
.1633	d0 ef		bne $1624			bne		_RNGLoop
.1635	8d 66 05	sta $0566			sta 	randomSeed+0
.1638	7a		ply				ply
.1639	60		rts				rts
.0566					randomSeed:
>0566							.fill 	4
.163a					StringConcatenate:
.163a	fa		plx				plx
.163b	ca		dex				dex
.163c	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.163e	85 2e		sta $2e				sta 	zTemp1
.1640	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1642	85 2f		sta $2f				sta 	zTemp1+1
.1644	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.1646	85 30		sta $30				sta 	zTemp2
.1648	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.164a	85 31		sta $31				sta 	zTemp2+1
.164c	18		clc				clc 								; work out total length
.164d	b2 2e		lda ($2e)			lda 	(zTemp1)
.164f	72 30		adc ($30)			adc 	(zTemp2)
.1651	b0 18		bcs $166b			bcs 	_BCLength 					; more than 255 characters.
.1653	48		pha				pha 								; save total
.1654	20 31 17	jsr $1731			jsr 	StringAllocTemp 			; space for result.
.1657	68		pla				pla 								; write total as first.
.1658	92 22		sta ($22)			sta 	(zsTemp)
.165a	20 6e 16	jsr $166e			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.165d	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.165f	85 2e		sta $2e				sta 	zTemp1
.1661	a5 31		lda $31				lda 	zTemp2+1
.1663	85 2f		sta $2f				sta 	zTemp1+1
.1665	20 6e 16	jsr $166e			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1668	4c 4f 08	jmp $084f			jmp 	NextCommand
.166b					_BCLength:
.166b	4c 13 1f	jmp $1f13		jmp	ErrorV_range
.166e					_BCCopyZTemp1:
.166e	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.1670	f0 15		beq $1687			beq 	_BCCExit 					; none.
.1672	da		phx				phx 								; save XY
.1673	5a		phy				phy
.1674	aa		tax				tax 								; count in X.
.1675	a0 01		ldy #$01			ldy 	#1
.1677					_BCCLoop:
.1677	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1679	d0 02		bne $167d			bne 	_BCCNoCarry
.167b	e6 23		inc $23				inc 	zsTemp+1
.167d					_BCCNoCarry:
.167d	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.167f	92 22		sta ($22)			sta 	(zsTemp)
.1681	c8		iny				iny
.1682	ca		dex				dex 								; X times
.1683	d0 f2		bne $1677			bne 	_BCCLoop
.1685	7a		ply				ply 								; restore YX
.1686	fa		plx				plx
.1687					_BCCExit:
.1687	60		rts				rts
.1688					XRuntimeSetup:
.1688	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.168a	8d 6d 05	sta $056d	 		sta 	ramBank
.168d	8d 6e 05	sta $056e	 		sta 	romBank
.1690	60		rts				rts
.1691					SignTOS:
.1691	fa		plx				plx
.1692	20 aa 26	jsr $26aa			jsr 	FloatIsZero 				; if zero
.1695	f0 0f		beq $16a6			beq 	_SGZero  					; return Int Zero
.1697	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.1699	48		pha				pha
.169a	a9 01		lda #$01			lda 	#1 							; set result to 1
.169c	20 8a 26	jsr $268a			jsr 	FloatSetByte
.169f	68		pla				pla
.16a0	29 80		and #$80			and		#$80 						; copy the sign byte out
.16a2	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.16a4	80 03		bra $16a9			bra 	_SGExit
.16a6					_SGZero:
.16a6	20 88 26	jsr $2688			jsr 	FloatSetZero
.16a9					_SGExit:
.16a9	4c 4f 08	jmp $084f			jmp 	NextCommand
.16ac					CommandShift:
.16ac	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.16ae	c8		iny				iny
.16af	0a		asl a				asl 	a 							; double into X
.16b0	aa		tax				tax
.16b1	7c 60 1a	jmp ($1a60,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.16b4					PrintTab:
.16b4	fa		plx				plx
.16b5	20 06 1c	jsr $1c06			jsr 	XGetHPos
.16b8					_PTMod10:
.16b8	38		sec				sec
.16b9	e9 0a		sbc #$0a			sbc 	#10
.16bb	b0 fb		bcs $16b8			bcs 	_PTMod10
.16bd	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.16bf	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.16c0	80 15		bra $16d7			bra 	PrintSpaceLoop
.16c2					PrintPos:
.16c2	fa		plx				plx
.16c3	20 06 1c	jsr $1c06			jsr		XGetHPos 					; get current position
.16c6	85 2c		sta $2c				sta 	zTemp0
.16c8	38		sec				sec 								; calculate spaces required
.16c9	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16cb	ca		dex				dex
.16cc	e5 2c		sbc $2c				sbc 	zTemp0
.16ce	b0 07		bcs $16d7			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.16d0	4c 4f 08	jmp $084f			jmp 	NextCommand
.16d3					PrintSpace:
.16d3	fa		plx				plx
.16d4	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16d6	ca		dex				dex
.16d7					PrintSpaceLoop:
.16d7	c9 00		cmp #$00			cmp 	#0
.16d9	f0 0a		beq $16e5			beq 	_PSExit
.16db	48		pha				pha
.16dc	a9 20		lda #$20			lda 	#" "
.16de	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.16e1	68		pla				pla
.16e2	3a		dec a				dec 	a
.16e3	80 f2		bra $16d7			bra 	PrintSpaceLoop
.16e5					_PSExit:
.16e5	4c 4f 08	jmp $084f			jmp 	NextCommand
.16e8					CommandStop:
.16e8	fa		plx				plx
.16e9	4c c5 1f	jmp $1fc5		jmp	ErrorV_stop
.16ec					Unary_Str:
.16ec	fa		plx				plx
.16ed	5a		phy				phy
.16ee	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.16f0	20 70 25	jsr $2570			jsr 	FloatToString 				; do the conversion.
.16f3	a9 21		lda #$21			lda		#33 						; create buffer
.16f5	20 31 17	jsr $1731			jsr 	StringAllocTemp 			; allocate memory
.16f8	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.16fa					_USCopy:
.16fa	b9 97 05	lda $0597,y			lda 	decimalBuffer-1,y
.16fd	f0 05		beq $1704			beq 	_USExit
.16ff	91 22		sta ($22),y			sta 	(zsTemp),y
.1701	c8		iny				iny
.1702	80 f6		bra $16fa			bra 	_USCopy
.1704					_USExit:
.1704	98		tya				tya
.1705	3a		dec a				dec 	a
.1706	92 22		sta ($22)			sta 	(zsTemp)
.1708	7a		ply				ply
.1709	4c 4f 08	jmp $084f			jmp 	NextCommand
.170c					StringInitialise:
.170c	48		pha				pha
.170d	ad 6a 05	lda $056a			lda 	stringInitialised 			; already done
.1710	d0 11		bne $1723			bne 	_SIExit
.1712	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.1715	8d 6b 05	sta $056b			sta 	stringTempPointer
.1718	ad 03 04	lda $0403			lda 	stringHighMemory+1
.171b	3a		dec a				dec 	a
.171c	3a		dec a				dec 	a
.171d	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.1720	ce 6a 05	dec $056a			dec 	stringInitialised 			; set the initialised flag.
.1723					_SIExit:
.1723	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.1725	1a		inc a				inc 	a
.1726	1a		inc a				inc 	a
.1727	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.172a	b0 02		bcs $172e			bcs 	_SIMemory
.172c	68		pla				pla
.172d	60		rts				rts
.172e					_SIMemory:
.172e	4c 1e 20	jmp $201e		jmp	ErrorV_memory
.1731					StringAllocTemp:
.1731	20 0c 17	jsr $170c			jsr 	StringInitialise 			; check it is initialised.
.1734	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.1736	18		clc				clc
.1737	6d 6b 05	adc $056b			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.173a	8d 6b 05	sta $056b			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.173d	85 22		sta $22				sta 	zsTemp
.173f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1741	ad 6c 05	lda $056c			lda 	stringTempPointer+1
.1744	69 ff		adc #$ff			adc 	#$FF
.1746	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.1749	85 23		sta $23				sta 	zsTemp+1
.174b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.174d	74 56		stz $56,x			stz 	NSMantissa2,x
.174f	74 62		stz $62,x			stz 	NSMantissa3,x
.1751	a9 00		lda #$00			lda 	#0 							; clear string.
.1753	92 22		sta ($22)			sta 	(zsTemp)
.1755	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1757	95 32		sta $32,x			sta 	NSStatus,x
.1759	60		rts				rts
.175a					StringWriteChar:
.175a	5a		phy				phy
.175b	48		pha				pha
.175c	b2 22		lda ($22)			lda 	(zsTemp)
.175e	1a		inc a				inc 	a
.175f	92 22		sta ($22)			sta 	(zsTemp)
.1761	a8		tay				tay
.1762	68		pla				pla
.1763	91 22		sta ($22),y			sta 	(zsTemp),y
.1765	7a		ply				ply
.1766	60		rts				rts
.056a					stringInitialised:
>056a							.fill 	1
.056b					stringTempPointer:
>056b							.fill 	2
.1767					Unary_Left:
.1767	fa		plx				plx
.1768	5a		phy				phy
.1769	18		clc				clc 								; only one parameter
.176a	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the length of the string.
.176d	48		pha				pha
.176e	ca		dex				dex
.176f	a9 00		lda #$00			lda 	#0 							; push the start position.
.1771	48		pha				pha
.1772	20 aa 17	jsr $17aa			jsr 	UnarySStringToZTemp0
.1775	80 3c		bra $17b3			bra 	SubstringMain 				; stack now points to the string to slice.
.1777					Unary_Right:
.1777	fa		plx				plx
.1778	5a		phy				phy
.1779	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.177b	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the right length of the string.
.177e	48		pha				pha
.177f	ca		dex				dex
.1780	20 aa 17	jsr $17aa			jsr 	UnarySStringToZTemp0
.1783	68		pla				pla 								; this is the right requirement
.1784	38		sec				sec
.1785	49 ff		eor #$ff			eor 	#$FF
.1787	72 2c		adc ($2c)			adc 	(zTemp0)
.1789	b0 02		bcs $178d			bcs 	_URHaveCount
.178b	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.178d					_URHaveCount:
.178d	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.178f	5a		phy				phy
.1790	48		pha				pha 								; start position
.1791	80 20		bra $17b3			bra 	SubstringMain
.1793					Unary_Mid:
.1793	fa		plx				plx
.1794	5a		phy				phy
.1795	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the length of the string required.
.1798	48		pha				pha
.1799	ca		dex				dex
.179a	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; put the start position.
.179d	f0 08		beq $17a7			beq 	_UMError
.179f	3a		dec a				dec 	a
.17a0	48		pha				pha
.17a1	ca		dex				dex
.17a2	20 aa 17	jsr $17aa			jsr 	UnarySStringToZTemp0
.17a5	80 0c		bra $17b3			bra 	SubstringMain 				; stack now points to the string to slice.
.17a7					_UMError:
.17a7	4c 13 1f	jmp $1f13		jmp	ErrorV_range
.17aa					UnarySStringToZTemp0:
.17aa	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17ac	85 2c		sta $2c				sta 	zTemp0
.17ae	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17b0	85 2d		sta $2d				sta 	zTemp0+1
.17b2	60		rts				rts
.17b3					SubstringMain:
.17b3	68		pla				pla 								; get the start offset
.17b4	7a		ply				ply 								; get the count to do.
.17b5	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.17b7	b0 38		bcs $17f1			bcs 	_SSReturnNull
.17b9	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.17bb	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.17bd	18		clc				clc
.17be	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.17c0	b0 06		bcs $17c8			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.17c2	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.17c4	f0 04		beq $17ca			beq 	_SMIsOkay
.17c6	90 02		bcc $17ca			bcc 	_SMIsOkay
.17c8					_SMTruncateToEnd:
.17c8	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.17ca					_SMIsOkay:
.17ca	85 2f		sta $2f				sta 	zTemp1+1
.17cc	38		sec				sec		 							; work out size
.17cd	a5 2f		lda $2f				lda 	zTemp1+1
.17cf	e5 2e		sbc $2e				sbc 	zTemp1
.17d1	f0 1e		beq $17f1			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.17d3	20 31 17	jsr $1731			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.17d6	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.17d8					_SMCopy:
.17d8	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.17da	f0 11		beq $17ed			beq 	_SMExit
.17dc	c8		iny				iny 								; bump and
.17dd	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.17df	5a		phy				phy
.17e0	48		pha				pha
.17e1	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.17e3	1a		inc a				inc 	a
.17e4	a8		tay				tay
.17e5	92 22		sta ($22)			sta 	(zsTemp)
.17e7	68		pla				pla 								; write character out
.17e8	91 22		sta ($22),y			sta 	(zsTemp),y
.17ea	7a		ply				ply 								; restore Y
.17eb	80 eb		bra $17d8			bra 	_SMCopy
.17ed					_SMExit:
.17ed	7a		ply				ply
.17ee	4c 4f 08	jmp $084f			jmp 	NextCommand
.17f1					_SSReturnNull:
.17f1	a9 03		lda #$03			lda 	#SSRNull & $FF 				; set up mantissa
.17f3	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17f5	a9 18		lda #$18			lda 	#SSRNull >> 8
.17f7	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17f9	74 56		stz $56,x			stz 	NSMantissa2,x
.17fb	74 62		stz $62,x			stz 	NSMantissa3,x
.17fd	a9 40		lda #$40			lda 	#NSSString
.17ff	95 32		sta $32,x			sta 	NSStatus,x
.1801	80 ea		bra $17ed			bra 	_SMExit
.1803					SSRNull:
>1803	00 00						.word 	0
.1805					CommandSwap:
.1805	fa		plx				plx
.1806	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1808	48		pha				pha
.1809	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.180b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.180d	68		pla				pla
.180e	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.1810	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1812	48		pha				pha
.1813	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.1815	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1817	68		pla				pla
.1818	95 49		sta $49,x			sta 	NSMantissa1-1,x
.181a	b5 56		lda $56,x			lda 	NSMantissa2,x
.181c	48		pha				pha
.181d	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.181f	95 56		sta $56,x			sta 	NSMantissa2,x
.1821	68		pla				pla
.1822	95 55		sta $55,x			sta 	NSMantissa2-1,x
.1824	b5 62		lda $62,x			lda 	NSMantissa3,x
.1826	48		pha				pha
.1827	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.1829	95 62		sta $62,x			sta 	NSMantissa3,x
.182b	68		pla				pla
.182c	95 61		sta $61,x			sta 	NSMantissa3-1,x
.182e	b5 6e		lda $6e,x			lda 	NSExponent,x
.1830	48		pha				pha
.1831	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.1833	95 6e		sta $6e,x			sta 	NSExponent,x
.1835	68		pla				pla
.1836	95 6d		sta $6d,x			sta 	NSExponent-1,x
.1838	b5 32		lda $32,x			lda 	NSStatus,x
.183a	48		pha				pha
.183b	b5 31		lda $31,x			lda 	NSStatus-1,x
.183d	95 32		sta $32,x			sta 	NSStatus,x
.183f	68		pla				pla
.1840	95 31		sta $31,x			sta 	NSStatus-1,x
.1842	4c 4f 08	jmp $084f			jmp 	NextCommand
.1845					CommandSYS:
.1845	fa		plx				plx
.1846	da		phx				phx 								; save XY
.1847	5a		phy				phy
.1848	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.184b	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.184d	85 2d		sta $2d				sta 	zTemp0+1
.184f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1851	85 2c		sta $2c				sta 	zTemp0
.1853	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1856	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.1859	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.185c	48		pha				pha
.185d	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.1860	28		plp				plp
.1861	20 78 18	jsr $1878			jsr 	_CSZTemp0
.1864	08		php				php
.1865	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1868	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.186b	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.186e	68		pla				pla
.186f	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.1872	7a		ply				ply 								; restore YX and drop 2
.1873	fa		plx				plx
.1874	ca		dex				dex
.1875	4c 4f 08	jmp $084f			jmp 	NextCommand
.1878					_CSZTemp0:
.1878	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.187b					TimeTOS:
.187b	fa		plx				plx
.187c	20 d6 18	jsr $18d6			jsr 	TIPushClock 				; push clock to TOS
.187f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1882					TimeString:
.1882	fa		plx				plx
.1883	20 d6 18	jsr $18d6			jsr 	TIPushClock 				; push clock to TOS
.1886	20 ab 18	jsr $18ab			jsr 	_TSDivMod60 				; result in seconds
.1889	20 ab 18	jsr $18ab			jsr 	_TSDivMod60 				; seconds
.188c	48		pha				pha
.188d	20 ab 18	jsr $18ab			jsr 	_TSDivMod60 				; minutes
.1890	48		pha				pha
.1891	a9 18		lda #$18			lda 	#24 						; hours
.1893	20 ad 18	jsr $18ad			jsr 	_TSDivModA
.1896	48		pha				pha
.1897	a9 06		lda #$06			lda 	#6
.1899	20 31 17	jsr $1731			jsr 	StringAllocTemp
.189c	68		pla				pla
.189d	20 bd 18	jsr $18bd			jsr 	_TSWriteDecimal
.18a0	68		pla				pla
.18a1	20 bd 18	jsr $18bd			jsr 	_TSWriteDecimal
.18a4	68		pla				pla
.18a5	20 bd 18	jsr $18bd			jsr 	_TSWriteDecimal
.18a8	4c 4f 08	jmp $084f			jmp 	NextCommand
.18ab					_TSDivMod60:
.18ab	a9 3c		lda #$3c			lda 	#60
.18ad					_TSDivModA:
.18ad	e8		inx				inx
.18ae	20 8a 26	jsr $268a			jsr 	FloatSetByte
.18b1	ca		dex				dex
.18b2	20 1e 22	jsr $221e			jsr 	Int32Divide
.18b5	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.18b7	48		pha				pha
.18b8	20 0d 22	jsr $220d			jsr 	NSMCopyPlusTwoToZero
.18bb	68		pla				pla
.18bc	60		rts				rts
.18bd					_TSWriteDecimal:
.18bd	da		phx				phx
.18be	a2 30		ldx #$30			ldx 	#'0'
.18c0					_TSWDLoop:
.18c0	c9 0a		cmp #$0a			cmp 	#10
.18c2	90 05		bcc $18c9			bcc 	_TSWDEnd
.18c4	e9 0a		sbc #$0a			sbc 	#10
.18c6	e8		inx				inx
.18c7	80 f7		bra $18c0			bra 	_TSWDLoop
.18c9					_TSWDEnd:
.18c9	48		pha				pha
.18ca	8a		txa				txa
.18cb	20 5a 17	jsr $175a			jsr 	StringWriteChar
.18ce	68		pla				pla
.18cf	09 30		ora #$30			ora 	#'0'
.18d1	20 5a 17	jsr $175a			jsr 	StringWriteChar
.18d4	fa		plx				plx
.18d5	60		rts				rts
.18d6					TIPushClock:
.18d6	5a		phy				phy
.18d7	e8		inx				inx 								; push 0 on the stack
.18d8	20 88 26	jsr $2688			jsr 	FloatSetZero
.18db	da		phx				phx
.18dc	20 d1 1c	jsr $1cd1			jsr 	XReadClock 					; read time into YXA
.18df	86 2c		stx $2c				stx 	zTemp0
.18e1	fa		plx				plx
.18e2	95 3e		sta $3e,x			sta 	NSMantissa0,x
.18e4	a5 2c		lda $2c				lda 	zTemp0
.18e6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.18e8	98		tya				tya
.18e9	95 56		sta $56,x			sta 	NSMantissa2,x
.18eb	7a		ply				ply
.18ec	60		rts				rts
.18ed					CommandTIWrite:
.18ed	fa		plx				plx
.18ee	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.18f0	85 22		sta $22				sta 	zsTemp
.18f2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.18f4	85 23		sta $23				sta 	zsTemp+1
.18f6	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.18f8	c9 06		cmp #$06			cmp 	#6
.18fa	d0 59		bne $1955			bne 	_CTIWError
.18fc	20 88 26	jsr $2688			jsr 	FloatSetZero
.18ff	20 21 19	jsr $1921			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.1902	20 21 19	jsr $1921			jsr 	_CTIWDigitPair
.1905	20 21 19	jsr $1921			jsr 	_CTIWDigitPair
.1908	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.190a	20 4c 19	jsr $194c			jsr 	_CTIWMultiply
.190d	da		phx				phx
.190e	5a		phy				phy
.190f	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.1911	48		pha				pha
.1912	b5 56		lda $56,x			lda 	NSMantissa2,x
.1914	a8		tay				tay
.1915	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1917	fa		plx				plx
.1918	20 d5 1c	jsr $1cd5			jsr 	XWriteClock 				; update the clock.
.191b	7a		ply				ply
.191c	fa		plx				plx
.191d	ca		dex				dex 								; throw result.
.191e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1921					_CTIWDigitPair:
.1921	a9 06		lda #$06			lda 	#6 							; x 6
.1923	20 4c 19	jsr $194c			jsr 	_CTIWMultiply
.1926	20 32 19	jsr $1932			jsr 	_CTIWAddDigit 				; add digit
.1929	a9 0a		lda #$0a			lda 	#10 						; x 10
.192b	20 4c 19	jsr $194c			jsr 	_CTIWMultiply
.192e	20 32 19	jsr $1932			jsr 	_CTIWAddDigit 				; add digit
.1931	60		rts				rts
.1932					_CTIWAddDigit:
.1932	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.1934	d0 02		bne $1938			bne 	_CTIWASkip
.1936	e6 23		inc $23				inc 	zsTemp+1
.1938					_CTIWASkip:
.1938	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.193a	38		sec				sec
.193b	e9 30		sbc #$30			sbc 	#"0"
.193d	90 16		bcc $1955			bcc 	_CTIWError
.193f	c9 0a		cmp #$0a			cmp 	#9+1
.1941	b0 12		bcs $1955			bcs 	_CTIWError
.1943	e8		inx				inx 								; store at +1
.1944	20 8a 26	jsr $268a			jsr 	FloatSetByte
.1947	ca		dex				dex
.1948	20 14 24	jsr $2414			jsr 	FloatAddTopTwoStack
.194b	60		rts				rts
.194c					_CTIWMultiply:
.194c	e8		inx				inx
.194d	20 8a 26	jsr $268a			jsr 	FloatSetByte
.1950	ca		dex				dex
.1951	20 95 23	jsr $2395			jsr 	FloatMultiplyShort
.1954	60		rts				rts
.1955					_CTIWError:
.1955	4c 23 1f	jmp $1f23		jmp	ErrorV_value
.1958					UnaryUsr:
.1958	fa		plx				plx
.1959	5a		phy				phy
.195a	20 61 19	jsr $1961			jsr 	_UUCallVector
.195d	7a		ply				ply
.195e	4c 4f 08	jmp $084f			jmp 	NextCommand
.1961					_UUCallVector:
.1961	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.1964					ValUnary:
.1964	fa		plx				plx
.1965	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1967	85 2c		sta $2c				sta 	zTemp0
.1969	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.196b	85 2d		sta $2d				sta 	zTemp0+1
.196d	20 78 19	jsr $1978			jsr 	ValEvaluateZTemp0
.1970	b0 03		bcs $1975			bcs 	_VUError 					; couldn't convert
.1972	4c 4f 08	jmp $084f			jmp 	NextCommand
.1975					_VUError:
.1975	4c 23 1f	jmp $1f23		jmp	ErrorV_value
.1978					ValEvaluateZTemp0:
.1978	5a		phy				phy
.1979	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.197b	f0 22		beq $199f			beq 	_VMCFail2
.197d	a0 00		ldy #$00			ldy 	#0 							; start position
.197f					_VMCSpaces:
.197f	c8		iny				iny 								; skip leading spaces
.1980	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1982	c9 20		cmp #$20			cmp 	#" "
.1984	f0 f9		beq $197f			beq 	_VMCSpaces
.1986	48		pha				pha 								; save first character
.1987	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.1989	d0 01		bne $198c			bne 	_VMCStart
.198b	c8		iny				iny 								; skip over - if so.
.198c					_VMCStart:
.198c	38		sec				sec 								; initialise first time round.
.198d					_VMCNext:
.198d	98		tya				tya 								; reached end of string
.198e	3a		dec a				dec 	a
.198f	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.1991	f0 0f		beq $19a2			beq 	_VMCSuccess 				; successful.
.1993	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.1995	c8		iny				iny
.1996	20 6c 24	jsr $246c			jsr 	FloatEncode 				; send it to the number-builder
.1999	90 03		bcc $199e			bcc 	_VMCFail 					; if failed, give up.
.199b	18		clc				clc 								; next time round, countinue
.199c	80 ef		bra $198d			bra 	_VMCNext
.199e					_VMCFail:
.199e	68		pla				pla
.199f					_VMCFail2:
.199f	7a		ply				ply
.19a0	38		sec				sec
.19a1	60		rts				rts
.19a2					_VMCSuccess:
.19a2	a9 00		lda #$00			lda 	#0 							; construct final
.19a4	20 6c 24	jsr $246c			jsr 	FloatEncode 				; by sending a duff value.
.19a7	68		pla				pla 								; if it was -ve
.19a8	c9 2d		cmp #$2d			cmp 	#"-"
.19aa	d0 03		bne $19af			bne 	_VMCNotNegative
.19ac	20 4a 26	jsr $264a			jsr		FloatNegate 				; negate it.
.19af					_VMCNotNegative:
.19af	7a		ply				ply
.19b0	18		clc				clc
.19b1	60		rts				rts
.19b2					VectorTable:
>19b2	a9 10					.word	LinkFloatAdd             ; $80 +
>19b4	b2 10					.word	LinkFloatSubtract        ; $81 -
>19b6	bb 10					.word	LinkFloatMultiply        ; $82 *
>19b8	c4 10					.word	LinkFloatDivide          ; $83 /
>19ba	cf 10					.word	LinkFloatPower           ; $84 ^
>19bc	f2 08					.word	BinaryAnd                ; $85 and
>19be	f6 08					.word	BinaryOr                 ; $86 or
>19c0	da 10					.word	LinkCompareGreater       ; $87 >
>19c2	e3 10					.word	LinkCompareEqual         ; $88 =
>19c4	ec 10					.word	LinkCompareLess          ; $89 <
>19c6	f5 10					.word	LinkCompareGreaterEqual  ; $8a >=
>19c8	fe 10					.word	LinkCompareNotEqual      ; $8b <>
>19ca	07 11					.word	LinkCompareLessEqual     ; $8c <=
>19cc	da 08					.word	AbsoluteTOS              ; $8d abs
>19ce	2d 09					.word	ArrayConvert             ; $8e array
>19d0	d5 09					.word	UnaryAsc                 ; $8f asc
>19d2	f0 09					.word	CommandAssert            ; $90 assert
>19d4	31 0a					.word	Unary16Bin               ; $91 bin$
>19d6	5b 0a					.word	PrintCharacterX          ; $92 print.chr
>19d8	65 0a					.word	UnaryChr                 ; $93 chr$
>19da	ca 0a					.word	CompareStrings           ; $94 s.cmp
>19dc	b6 0c					.word	CommandXFor              ; $95 for
>19de	79 0d					.word	UnaryFre                 ; $96 fre
>19e0	91 0d					.word	CommandXGet              ; $97 get
>19e2	b7 0d					.word	CommandReturn            ; $98 return
>19e4	f9 0d					.word	Command_PSET             ; $99 pset
>19e6	13 0e					.word	Command_LINE             ; $9a line
>19e8	28 0e					.word	Command_RECT             ; $9b rect
>19ea	37 0e					.word	Command_FRAME            ; $9c frame
>19ec	46 0e					.word	Command_CHAR             ; $9d char
>19ee	dd 0e					.word	Unary16Hex               ; $9e hex$
>19f0	84 0f					.word	CommandXInput            ; $9f input
>19f2	9b 0f					.word	CommandInputString       ; $a0 input$
>19f4	b4 0f					.word	CommandInputReset        ; $a1 input.start
>19f6	98 10					.word	UnaryLen                 ; $a2 len
>19f8	64 11					.word	LinkFloatCompare         ; $a3 f.cmp
>19fa	6d 11					.word	LinkDivideInt32          ; $a4 int.div
>19fc	e7 11					.word	NegateTOS                ; $a5 negate
>19fe	ee 11					.word	CommandNewLine           ; $a6 new.line
>1a00	f7 11					.word	CommandXNext             ; $a7 next
>1a02	e0 12					.word	NotTOS                   ; $a8 not
>1a04	f7 12					.word	CommandXOn               ; $a9 on
>1a06	14 13					.word	CommandMoreOn            ; $aa moreon
>1a08	1b 13					.word	UnaryPeek                ; $ab peek
>1a0a	30 13					.word	UnaryPI                  ; $ac pi
>1a0c	3a 13					.word	CommandPOKE              ; $ad poke
>1a0e	52 13					.word	UnaryPos                 ; $ae pos
>1a10	5c 13					.word	GetChannel               ; $af getchannel
>1a12	67 13					.word	SetChannel               ; $b0 setchannel
>1a14	8a 13					.word	PrintNumber              ; $b1 print.n
>1a16	a9 13					.word	PrintString              ; $b2 print.s
>1a18	10 14					.word	CommandXRead             ; $b3 read
>1a1a	2a 14					.word	CommandReadString        ; $b4 read$
>1a1c	cb 15					.word	UnaryRND                 ; $b5 rnd
>1a1e	3a 16					.word	StringConcatenate        ; $b6 concat
>1a20	91 16					.word	SignTOS                  ; $b7 sgn
>1a22	b4 16					.word	PrintTab                 ; $b8 print.tab
>1a24	c2 16					.word	PrintPos                 ; $b9 print.pos
>1a26	d3 16					.word	PrintSpace               ; $ba print.spc
>1a28	ec 16					.word	Unary_Str                ; $bb str$
>1a2a	67 17					.word	Unary_Left               ; $bc left$
>1a2c	77 17					.word	Unary_Right              ; $bd right$
>1a2e	93 17					.word	Unary_Mid                ; $be mid$
>1a30	05 18					.word	CommandSwap              ; $bf swap
>1a32	7b 18					.word	TimeTOS                  ; $c0 ti
>1a34	82 18					.word	TimeString               ; $c1 ti$
>1a36	58 19					.word	UnaryUsr                 ; $c2 usr
>1a38	64 19					.word	ValUnary                 ; $c3 val
>1a3a	cd 1b					.word	CommandClose             ; $c4 close
>1a3c	df 1b					.word	CommandExit              ; $c5 exit
>1a3e	e5 1b					.word	CommandDebug             ; $c6 debug
>1a40	4b 1c					.word	CommandXOpen             ; $c7 open
>1a42	df 1c					.word	CommandScreen            ; $c8 screen
>1a44	c3 1e					.word	CommandVPOKE             ; $c9 vpoke
>1a46	e8 1e					.word	CommandVPEEK             ; $ca vpeek
>1a48	ac 16					.word	CommandShift             ; $cb .shift
>1a4a	9e 08					.word	PushByteCommand          ; $cc .byte
>1a4c	b1 08					.word	PushWordCommand          ; $cd .word
>1a4e	cc 13					.word	CommandPushN             ; $ce .float
>1a50	f2 13					.word	CommandPushS             ; $cf .string
>1a52	52 0b					.word	CommandXData             ; $d0 .data
>1a54	c8 0d					.word	CommandXGoto             ; $d1 .goto
>1a56	ab 0d					.word	CommandXGosub            ; $d2 .gosub
>1a58	dd 0d					.word	CommandGotoZ             ; $d3 .goto.z
>1a5a	eb 0d					.word	CommandGotoNZ            ; $d4 .goto.nz
>1a5c	e0 08					.word	CommandVarSpace          ; $d5 .varspace
>1a5e	a3 15					.word	CommandRestoreX          ; $d6 .restore
.1a60					ShiftVectorTable:
>1a60	7d 0a					.word	CommandClr               ; $cb80 clr
>1a62	5b 0b					.word	CommandXDIM              ; $cb81 dim
>1a64	4c 0c					.word	CommandEnd               ; $cb82 end
>1a66	69 10					.word	UnaryJoy                 ; $cb83 joy
>1a68	10 11					.word	LinkFloatIntegerPartDown ; $cb84 int
>1a6a	19 11					.word	LinkFloatSquareRoot      ; $cb85 sqr
>1a6c	2a 11					.word	LinkFloatLogarithm       ; $cb86 log
>1a6e	35 11					.word	LinkFloatExponent        ; $cb87 exp
>1a70	3e 11					.word	LinkFloatCosine          ; $cb88 cos
>1a72	47 11					.word	LinkFloatSine            ; $cb89 sin
>1a74	50 11					.word	LinkFloatTangent         ; $cb8a tan
>1a76	59 11					.word	LinkFloatArcTan          ; $cb8b atn
>1a78	97 11					.word	XCommandMouse            ; $cb8c mouse
>1a7a	ac 11					.word	XUnaryMB                 ; $cb8d mb
>1a7c	b9 11					.word	XUnaryMX                 ; $cb8e mx
>1a7e	ca 11					.word	XUnaryMY                 ; $cb8f my
>1a80	e8 16					.word	CommandStop              ; $cb90 stop
>1a82	45 18					.word	CommandSYS               ; $cb91 sys
>1a84	ed 18					.word	CommandTIWrite           ; $cb92 ti$.write
>1a86	bc 1a					.word	CommandXWAIT             ; $cb93 wait
>1a88	10 1c					.word	X16I2CPoke               ; $cb94 i2cpoke
>1a8a	30 1c					.word	X16I2CPeek               ; $cb95 i2cpeek
>1a8c	9b 1c					.word	CommandBank              ; $cb96 bank
>1a8e	ee 1c					.word	XCommandSleep            ; $cb97 sleep
>1a90	12 1d					.word	X16_Audio_FMINIT         ; $cb98 fminit
>1a92	20 1d					.word	X16_Audio_FMNOTE         ; $cb99 fmnote
>1a94	32 1d					.word	X16_Audio_FMDRUM         ; $cb9a fmdrum
>1a96	44 1d					.word	X16_Audio_FMINST         ; $cb9b fminst
>1a98	56 1d					.word	X16_Audio_FMVIB          ; $cb9c fmvib
>1a9a	68 1d					.word	X16_Audio_FMFREQ         ; $cb9d fmfreq
>1a9c	79 1d					.word	X16_Audio_FMVOL          ; $cb9e fmvol
>1a9e	8b 1d					.word	X16_Audio_FMPAN          ; $cb9f fmpan
>1aa0	9d 1d					.word	X16_Audio_FMPLAY         ; $cba0 fmplay
>1aa2	ae 1d					.word	X16_Audio_FMCHORD        ; $cba1 fmchord
>1aa4	bf 1d					.word	X16_Audio_FMPOKE         ; $cba2 fmpoke
>1aa6	d1 1d					.word	X16_Audio_PSGINIT        ; $cba3 psginit
>1aa8	df 1d					.word	X16_Audio_PSGNOTE        ; $cba4 psgnote
>1aaa	f1 1d					.word	X16_Audio_PSGVOL         ; $cba5 psgvol
>1aac	03 1e					.word	X16_Audio_PSGWAV         ; $cba6 psgwav
>1aae	15 1e					.word	X16_Audio_PSGFREQ        ; $cba7 psgfreq
>1ab0	26 1e					.word	X16_Audio_PSGPAN         ; $cba8 psgpan
>1ab2	38 1e					.word	X16_Audio_PSGPLAY        ; $cba9 psgplay
>1ab4	49 1e					.word	X16_Audio_PSGCHORD       ; $cbaa psgchord
>1ab6	5a 1e					.word	CommandCls               ; $cbab cls
>1ab8	63 1e					.word	CommandLocate            ; $cbac locate
>1aba	8a 1e					.word	CommandColor             ; $cbad color
.1abc					CommandXWAIT:
.1abc	fa		plx				plx
.1abd	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1abf	85 2c		sta $2c				sta 	zTemp0
.1ac1	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1ac3	85 2d		sta $2d				sta 	zTemp0+1
.1ac5					_WaitLoop:
.1ac5	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1ac7	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1ac9	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1acb	f0 f8		beq $1ac5			beq 	_WaitLoop 					; keep going if zero
.1acd	ca		dex				dex 								; drop 3.
.1ace	ca		dex				dex
.1acf	ca		dex				dex
.1ad0	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ad3					WriteFloatCommand:
.1ad3	fa		plx				plx
.1ad4	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1ad6	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1ad8	88		dey				dey 								; get the upper 3 bits
.1ad9	b1 28		lda ($28),y			lda 	(codePtr),y
.1adb	29 07		and #$07			and 	#7
.1add	c8		iny				iny
.1ade	c8		iny				iny
.1adf	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1ae1	2a		rol a				rol 	a 							; carry will be clear.
.1ae2	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1ae5	85 2d		sta $2d				sta 	zTemp0+1
.1ae7	20 ed 1a	jsr $1aed			jsr 	WriteFloatZTemp0Sub
.1aea	4c 4f 08	jmp $084f			jmp 	NextCommand
.1aed					WriteFloatZTemp0Sub:
.1aed	5a		phy				phy 								; ldart write
.1aee	a0 01		ldy #$01			ldy 	#1
.1af0	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1af2	92 2c		sta ($2c)			sta 	(zTemp0)
.1af4	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1af6	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1af8	c8		iny				iny
.1af9	b5 56		lda $56,x			lda 	NSMantissa2,x
.1afb	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1afd	c8		iny				iny
.1afe	b5 62		lda $62,x			lda 	NSMantissa3,x
.1b00	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b02	c8		iny				iny
.1b03	b5 6e		lda $6e,x			lda 	NSExponent,x
.1b05	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b07	c8		iny				iny
.1b08	b5 32		lda $32,x			lda 	NSStatus,x
.1b0a	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b0c	ca		dex				dex
.1b0d	7a		ply				ply
.1b0e	60		rts				rts
.1b0f					WriteIntegerCommand:
.1b0f	fa		plx				plx
.1b10	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b12	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b14	88		dey				dey 								; get the upper 3 bits
.1b15	b1 28		lda ($28),y			lda 	(codePtr),y
.1b17	29 07		and #$07			and 	#7
.1b19	c8		iny				iny
.1b1a	c8		iny				iny
.1b1b	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b1d	2a		rol a				rol 	a 							; carry will be clear.
.1b1e	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b21	85 2d		sta $2d				sta 	zTemp0+1
.1b23	20 29 1b	jsr $1b29			jsr 	WriteIntegerZTemp0Sub
.1b26	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b29					WriteIntegerZTemp0Sub:
.1b29	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.1b2c	5a		phy				phy 								; start write
.1b2d	a0 01		ldy #$01			ldy 	#1
.1b2f	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1b31	30 0b		bmi $1b3e			bmi 	_WIZNegative
.1b33	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1b35	92 2c		sta ($2c)			sta 	(zTemp0)
.1b37	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b39	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b3b	7a		ply				ply
.1b3c	ca		dex				dex
.1b3d	60		rts				rts
.1b3e					_WIZNegative:
.1b3e	38		sec				sec 								; -ve read
.1b3f	a9 00		lda #$00			lda 	#0
.1b41	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1b43	92 2c		sta ($2c)			sta 	(zTemp0)
.1b45	a9 00		lda #$00			lda 	#0
.1b47	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1b49	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b4b	7a		ply				ply
.1b4c	ca		dex				dex
.1b4d	60		rts				rts
.1b4e					WriteStringCommand:
.1b4e	fa		plx				plx
.1b4f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b51	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b53	88		dey				dey 								; get the upper 3 bits
.1b54	b1 28		lda ($28),y			lda 	(codePtr),y
.1b56	29 07		and #$07			and 	#7
.1b58	c8		iny				iny
.1b59	c8		iny				iny
.1b5a	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b5c	2a		rol a				rol 	a 							; carry will be clear.
.1b5d	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b60	85 2d		sta $2d				sta 	zTemp0+1
.1b62	20 68 1b	jsr $1b68			jsr 	WriteStringZTemp0Sub
.1b65	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b68					WriteStringZTemp0Sub:
.1b68	5a		phy				phy
.1b69	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b6b	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b6d	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b6f	f0 1e		beq $1b8f			beq 	_WSConcrete
.1b71	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b73	85 2e		sta $2e				sta 	zTemp1
.1b75	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b77	85 2f		sta $2f				sta 	zTemp1+1
.1b79	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b7b	85 30		sta $30				sta 	zTemp2
.1b7d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b7f	85 31		sta $31				sta 	zTemp2+1
.1b81	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1b83	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1b85	b0 17		bcs $1b9e			bcs 	_WSCopy
.1b87	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1b89	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b8b	09 80		ora #$80			ora 	#$80
.1b8d	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1b8f					_WSConcrete:
.1b8f	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1b91	a8		tay				tay
.1b92	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b94	20 0c 0b	jsr $0b0c			jsr 	StringConcrete
.1b97	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1b99	98		tya				tya
.1b9a	a0 01		ldy #$01			ldy 	#1
.1b9c	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b9e					_WSCopy
.1b9e	18		clc				clc  								; copy target+2 to zTemp2
.1b9f	b2 2c		lda ($2c)			lda 	(zTemp0)
.1ba1	69 02		adc #$02			adc 	#2
.1ba3	85 30		sta $30				sta 	zTemp2
.1ba5	a0 01		ldy #$01			ldy 	#1
.1ba7	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1ba9	69 00		adc #$00			adc 	#0
.1bab	85 31		sta $31				sta 	zTemp2+1
.1bad	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1baf	85 2e		sta $2e				sta 	zTemp1
.1bb1	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1bb3	85 2f		sta $2f				sta 	zTemp1+1
.1bb5	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1bb7	a8		tay				tay
.1bb8					_WSCopyLoop:
.1bb8	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1bba	91 30		sta ($30),y			sta 	(zTemp2),y
.1bbc	88		dey				dey
.1bbd	c0 ff		cpy #$ff			cpy 	#$FF
.1bbf	d0 f7		bne $1bb8			bne 	_WSCopyLoop
.1bc1	ca		dex				dex
.1bc2	7a		ply				ply
.1bc3	60		rts				rts
.1bc4					XCheckStop:
.1bc4	20 e1 ff	jsr $ffe1			jsr 	$FFE1 						; check stop
.1bc7	f0 01		beq $1bca			beq 	_XCSStop
.1bc9	60		rts				rts
.1bca					_XCSStop:
.1bca	4c 45 20	jmp $2045		jmp	ErrorV_break
.1bcd					CommandClose:
.1bcd	fa		plx				plx
.1bce	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; channel to close
.1bd1	cd 5f 04	cmp $045f			cmp 	currentChannel 				; is it the current channel
.1bd4	d0 03		bne $1bd9			bne 	_CCNotCurrent
.1bd6	9c 5f 04	stz $045f			stz 	currentChannel 				; effectively disables CMD
.1bd9					_CCNotCurrent:
.1bd9	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1bdc	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bdf					CommandExit:
.1bdf	fa		plx				plx
.1be0	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1be2	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1be5					CommandDebug:
.1be5	fa		plx				plx
>1be6	db						.byte 	$DB 						; causes a break in the emulator
.1be7	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bea					XGetCharacterFromChannel:
.1bea	da		phx				phx
.1beb	5a		phy				phy
.1bec	e0 00		cpx #$00			cpx 	#0 							; is it default
.1bee	d0 05		bne $1bf5			bne 	_XGetChannel
.1bf0	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1bf3	80 08		bra $1bfd			bra 	_XGetChar
.1bf5					_XGetChannel:
.1bf5	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1bf8	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1bfb	d0 06		bne $1c03			bne 	_XGCError
.1bfd					_XGetChar:
.1bfd	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1c00	7a		ply				ply
.1c01	fa		plx				plx
.1c02	60		rts				rts
.1c03					_XGCError:
.1c03	4c 2f 20	jmp $202f		jmp	ErrorV_channel
.1c06					XGetHPos:
.1c06	da		phx				phx
.1c07	5a		phy				phy
.1c08	38		sec				sec
.1c09	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1c0c	98		tya				tya
.1c0d	7a		ply				ply
.1c0e	fa		plx				plx
.1c0f	60		rts				rts
.1c10					X16I2CPoke:
.1c10	fa		plx				plx
.1c11	5a		phy				phy
.1c12	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; value
.1c15	48		pha				pha
.1c16	ca		dex				dex
.1c17	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; register
.1c1a	48		pha				pha
.1c1b	ca		dex				dex
.1c1c	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; device
.1c1f	aa		tax				tax
.1c20	7a		ply				ply
.1c21	68		pla				pla
.1c22	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1c25	b0 06		bcs $1c2d			bcs 	X16I2CError
.1c27	7a		ply				ply
.1c28	a2 ff		ldx #$ff			ldx 	#$FF
.1c2a	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c2d					X16I2CError:
.1c2d	4c 2f 20	jmp $202f		jmp	ErrorV_channel
.1c30					X16I2CPeek:
.1c30	fa		plx				plx
.1c31	da		phx				phx
.1c32	5a		phy				phy
.1c33	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; register
.1c36	48		pha				pha
.1c37	ca		dex				dex
.1c38	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; device
.1c3b	aa		tax				tax 								; X device
.1c3c	7a		ply				ply 								; Y register
.1c3d	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1c40	b0 eb		bcs $1c2d			bcs 	X16I2CError
.1c42	7a		ply				ply 								; restore Y/X
.1c43	fa		plx				plx
.1c44	ca		dex				dex 								; drop TOS (register)
.1c45	20 8a 26	jsr $268a			jsr 	FloatSetByte 				; write read value to TOS.
.1c48	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c4b					CommandXOpen:
.1c4b	fa		plx				plx
.1c4c	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1c4e	85 2c		sta $2c				sta 	zTemp0
.1c50	aa		tax				tax
.1c51	a5 4d		lda $4d				lda 	NSMantissa1+3
.1c53	85 2d		sta $2d				sta 	zTemp0+1
.1c55	a8		tay				tay
.1c56	e8		inx				inx 								; XY points to first character
.1c57	d0 01		bne $1c5a			bne 	_CONoCarry
.1c59	c8		iny				iny
.1c5a					_CONoCarry:
.1c5a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c5c	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c5f	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c61	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c63	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c65	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c68	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c6b	b0 03		bcs $1c70			bcs 	_COError
.1c6d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c70					_COError:
.1c70	4c 2f 20	jmp $202f		jmp	ErrorV_channel
.1c73					XPokeMemory:
.1c73	86 2c		stx $2c				stx 	zTemp0
.1c75	84 2d		sty $2d				sty 	zTemp0+1
.1c77	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c79	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c7c	e0 ff		cpx #$ff			cpx 	#$FF
.1c7e	f0 02		beq $1c82			beq 	_XPMNoSwitch
.1c80	86 00		stx $00				stx 	SelectRAMBank
.1c82					_XPMNoSwitch:
.1c82	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1c84	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1c86					_XPMExit:
.1c86	60		rts				rts
.1c87					XPeekMemory:
.1c87	86 2c		stx $2c				stx 	zTemp0
.1c89	84 2d		sty $2d				sty 	zTemp0+1
.1c8b	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c8d	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c90	e0 ff		cpx #$ff			cpx 	#$FF
.1c92	f0 02		beq $1c96			beq 	_XPMNoSwitch
.1c94	86 00		stx $00				stx 	SelectRAMBank
.1c96					_XPMNoSwitch:
.1c96	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1c98	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1c9a	60		rts				rts
.1c9b					CommandBank:
.1c9b	fa		plx				plx
.1c9c	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1c9e	8d 6d 05	sta $056d			sta 	ramBank 					; store & make current
.1ca1	85 00		sta $00				sta 	SelectRAMBank
.1ca3	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1ca5	c9 ff		cmp #$ff			cmp 	#$FF
.1ca7	f0 03		beq $1cac			beq 	_CBNoUpdate
.1ca9	8d 6e 05	sta $056e			sta 	romBank 					; this doesn't set the hardware page.
.1cac					_CBNoUpdate:
.1cac	a2 ff		ldx #$ff			ldx 	#$FF
.1cae	4c 4f 08	jmp $084f			jmp 	NextCommand
.056d					ramBank:
>056d							.fill 	1
.056e					romBank:
>056e							.fill 	1
.1cb1					XPrintCharacterToChannel:
.1cb1	48		pha				pha
.1cb2	da		phx				phx
.1cb3	5a		phy				phy
.1cb4	48		pha				pha  								; save char
.1cb5	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1cb7	d0 05		bne $1cbe			bne 	_XPCNotDefault
.1cb9	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1cbc	80 08		bra $1cc6			bra 	_XPCSend
.1cbe					_XPCNotDefault:
.1cbe	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1cc1	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1cc4	d0 08		bne $1cce			bne 	_XPCError
.1cc6					_XPCSend:
.1cc6	68		pla				pla 								; restore character
.1cc7	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1cca	7a		ply				ply
.1ccb	fa		plx				plx
.1ccc	68		pla				pla
.1ccd	60		rts				rts
.1cce					_XPCError:
.1cce	4c 2f 20	jmp $202f		jmp	ErrorV_channel
.1cd1					XReadClock:
.1cd1	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1cd4	60		rts				rts
.1cd5					XWriteClock:
.1cd5	48		pha				pha
.1cd6	da		phx				phx
.1cd7	5a		phy				phy
.1cd8	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1cdb	7a		ply				ply
.1cdc	fa		plx				plx
.1cdd	68		pla				pla
.1cde	60		rts				rts
.1cdf					CommandScreen:
.1cdf	fa		plx				plx
.1ce0	da		phx				phx
.1ce1	5a		phy				phy
.1ce2	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1ce5	18		clc				clc
.1ce6	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1ce9	7a		ply				ply
.1cea	fa		plx				plx
.1ceb	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cee					XCommandSleep:
.1cee	fa		plx				plx
.1cef	5a		phy				phy
.1cf0	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.1cf3	ca		dex				dex
.1cf4	20 d1 1c	jsr $1cd1			jsr 	XReadClock 					; read clock to YXA
.1cf7	18		clc				clc 								; calculate end time in zTemp0
.1cf8	65 3e		adc $3e				adc 	NSMantissa0
.1cfa	85 2c		sta $2c				sta 	zTemp0
.1cfc	8a		txa				txa
.1cfd	65 4a		adc $4a				adc 	NSMantissa1
.1cff	85 2d		sta $2d				sta 	zTemp0+1
.1d01					_XCWait:
.1d01	20 d1 1c	jsr $1cd1			jsr 	XReadClock 					; and wait for it.
.1d04	c5 2c		cmp $2c				cmp 	zTemp0
.1d06	d0 f9		bne $1d01			bne 	_XCWait
.1d08	e4 2d		cpx $2d				cpx 	zTemp0+1
.1d0a	d0 f5		bne $1d01			bne 	_XCWait
.1d0c	a2 ff		ldx #$ff			ldx 	#$FF
.1d0e	7a		ply				ply
.1d0f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d12					X16_Audio_FMINIT:
.1d12	fa		plx				plx
.1d13	5a		phy			phy
.1d14	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d17	63 c0					.word	X16A_ym_init
>1d19	0a					.byte	X16_AudioCodeBank
.1d1a	a2 ff		ldx #$ff		ldx	#$FF
.1d1c	7a		ply			ply
.1d1d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d20					X16_Audio_FMNOTE:
.1d20	fa		plx				plx
.1d21	5a		phy			phy
.1d22	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d25	18		clc			clc
.1d26	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d29	03 c0					.word	X16A_bas_fmnote
>1d2b	0a					.byte	X16_AudioCodeBank
.1d2c	a2 ff		ldx #$ff		ldx	#$FF
.1d2e	7a		ply			ply
.1d2f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d32					X16_Audio_FMDRUM:
.1d32	fa		plx				plx
.1d33	5a		phy			phy
.1d34	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d37	18		clc			clc
.1d38	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d3b	6f c0					.word	X16A_ym_playdrum
>1d3d	0a					.byte	X16_AudioCodeBank
.1d3e	a2 ff		ldx #$ff		ldx	#$FF
.1d40	7a		ply			ply
.1d41	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d44					X16_Audio_FMINST:
.1d44	fa		plx				plx
.1d45	5a		phy			phy
.1d46	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d49	38		sec			sec
.1d4a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d4d	69 c0					.word	X16A_ym_loadpatch
>1d4f	0a					.byte	X16_AudioCodeBank
.1d50	a2 ff		ldx #$ff		ldx	#$FF
.1d52	7a		ply			ply
.1d53	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d56					X16_Audio_FMVIB:
.1d56	fa		plx				plx
.1d57	5a		phy			phy
.1d58	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d5b	18		clc			clc
.1d5c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d5f	09 c0					.word	X16A_bas_fmvib
>1d61	0a					.byte	X16_AudioCodeBank
.1d62	a2 ff		ldx #$ff		ldx	#$FF
.1d64	7a		ply			ply
.1d65	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d68					X16_Audio_FMFREQ:
.1d68	fa		plx				plx
.1d69	5a		phy			phy
.1d6a	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1d6d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d70	00 c0					.word	X16A_bas_fmfreq
>1d72	0a					.byte	X16_AudioCodeBank
.1d73	a2 ff		ldx #$ff		ldx	#$FF
.1d75	7a		ply			ply
.1d76	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d79					X16_Audio_FMVOL:
.1d79	fa		plx				plx
.1d7a	5a		phy			phy
.1d7b	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d7e	18		clc			clc
.1d7f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d82	75 c0					.word	X16A_ym_setatten
>1d84	0a					.byte	X16_AudioCodeBank
.1d85	a2 ff		ldx #$ff		ldx	#$FF
.1d87	7a		ply			ply
.1d88	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d8b					X16_Audio_FMPAN:
.1d8b	fa		plx				plx
.1d8c	5a		phy			phy
.1d8d	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d90	18		clc			clc
.1d91	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d94	7e c0					.word	X16A_ym_setpan
>1d96	0a					.byte	X16_AudioCodeBank
.1d97	a2 ff		ldx #$ff		ldx	#$FF
.1d99	7a		ply			ply
.1d9a	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d9d					X16_Audio_FMPLAY:
.1d9d	fa		plx				plx
.1d9e	5a		phy			phy
.1d9f	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1da2	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1da5	06 c0					.word	X16A_bas_fmplaystring
>1da7	0a					.byte	X16_AudioCodeBank
.1da8	a2 ff		ldx #$ff		ldx	#$FF
.1daa	7a		ply			ply
.1dab	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dae					X16_Audio_FMCHORD:
.1dae	fa		plx				plx
.1daf	5a		phy			phy
.1db0	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1db3	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1db6	8d c0					.word	X16A_bas_fmchordstring
>1db8	0a					.byte	X16_AudioCodeBank
.1db9	a2 ff		ldx #$ff		ldx	#$FF
.1dbb	7a		ply			ply
.1dbc	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dbf					X16_Audio_FMPOKE:
.1dbf	fa		plx				plx
.1dc0	5a		phy			phy
.1dc1	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1dc4	18		clc			clc
.1dc5	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dc8	8a c0					.word	X16A_ym_write
>1dca	0a					.byte	X16_AudioCodeBank
.1dcb	a2 ff		ldx #$ff		ldx	#$FF
.1dcd	7a		ply			ply
.1dce	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dd1					X16_Audio_PSGINIT:
.1dd1	fa		plx				plx
.1dd2	5a		phy			phy
.1dd3	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dd6	4b c0					.word	X16A_psg_init
>1dd8	0a					.byte	X16_AudioCodeBank
.1dd9	a2 ff		ldx #$ff		ldx	#$FF
.1ddb	7a		ply			ply
.1ddc	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ddf					X16_Audio_PSGNOTE:
.1ddf	fa		plx				plx
.1de0	5a		phy			phy
.1de1	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1de4	18		clc			clc
.1de5	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1de8	12 c0					.word	X16A_bas_psgnote
>1dea	0a					.byte	X16_AudioCodeBank
.1deb	a2 ff		ldx #$ff		ldx	#$FF
.1ded	7a		ply			ply
.1dee	4c 4f 08	jmp $084f			jmp 	NextCommand
.1df1					X16_Audio_PSGVOL:
.1df1	fa		plx				plx
.1df2	5a		phy			phy
.1df3	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1df6	18		clc			clc
.1df7	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dfa	54 c0					.word	X16A_psg_setatten
>1dfc	0a					.byte	X16_AudioCodeBank
.1dfd	a2 ff		ldx #$ff		ldx	#$FF
.1dff	7a		ply			ply
.1e00	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e03					X16_Audio_PSGWAV:
.1e03	fa		plx				plx
.1e04	5a		phy			phy
.1e05	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e08	18		clc			clc
.1e09	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e0c	15 c0					.word	X16A_bas_psgwav
>1e0e	0a					.byte	X16_AudioCodeBank
.1e0f	a2 ff		ldx #$ff		ldx	#$FF
.1e11	7a		ply			ply
.1e12	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e15					X16_Audio_PSGFREQ:
.1e15	fa		plx				plx
.1e16	5a		phy			phy
.1e17	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1e1a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e1d	0f c0					.word	X16A_bas_psgfreq
>1e1f	0a					.byte	X16_AudioCodeBank
.1e20	a2 ff		ldx #$ff		ldx	#$FF
.1e22	7a		ply			ply
.1e23	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e26					X16_Audio_PSGPAN:
.1e26	fa		plx				plx
.1e27	5a		phy			phy
.1e28	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e2b	18		clc			clc
.1e2c	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e2f	5a c0					.word	X16A_psg_setpan
>1e31	0a					.byte	X16_AudioCodeBank
.1e32	a2 ff		ldx #$ff		ldx	#$FF
.1e34	7a		ply			ply
.1e35	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e38					X16_Audio_PSGPLAY:
.1e38	fa		plx				plx
.1e39	5a		phy			phy
.1e3a	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e3d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e40	18 c0					.word	X16A_bas_psgplaystring
>1e42	0a					.byte	X16_AudioCodeBank
.1e43	a2 ff		ldx #$ff		ldx	#$FF
.1e45	7a		ply			ply
.1e46	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e49					X16_Audio_PSGCHORD:
.1e49	fa		plx				plx
.1e4a	5a		phy			phy
.1e4b	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e4e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e51	90 c0					.word	X16A_bas_psgchordstring
>1e53	0a					.byte	X16_AudioCodeBank
.1e54	a2 ff		ldx #$ff		ldx	#$FF
.1e56	7a		ply			ply
.1e57	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e5a					CommandCls:
.1e5a	fa		plx				plx
.1e5b	a9 93		lda #$93			lda 	#147
.1e5d	20 b1 1c	jsr $1cb1			jsr 	XPrintCharacterToChannel
.1e60	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e63					CommandLocate:
.1e63	fa		plx				plx
.1e64	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.1e67	ca		dex				dex
.1e68	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.1e6b	ca		dex				dex
.1e6c	48		pha				pha 								; save registers
.1e6d	da		phx				phx
.1e6e	5a		phy				phy
.1e6f	18		clc				clc
.1e70	a4 3f		ldy $3f				ldy 	NSMantissa0+1 				; get coords
.1e72	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e74	88		dey				dey 								; fix up
.1e75	ca		dex				dex
.1e76	20 f0 ff	jsr $fff0			jsr 	$FFF0 						; PLOT
.1e79	7a		ply				ply 								; restore registers
.1e7a	fa		plx				plx
.1e7b	68		pla				pla
.1e7c	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e7f					_CLOutputXA:
.1e7f	ca		dex				dex
.1e80	f0 07		beq $1e89			beq 	_CLOExit
.1e82	30 05		bmi $1e89			bmi 	_CLOExit
.1e84	20 b1 1c	jsr $1cb1			jsr 	XPrintCharacterToChannel
.1e87	80 f6		bra $1e7f			bra 	_CLOutputXA
.1e89					_CLOExit:
.1e89	60		rts				rts
.1e8a					CommandColor:
.1e8a	fa		plx				plx
.1e8b	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.1e8e	ca		dex				dex
.1e8f	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.1e92	ca		dex				dex
.1e93	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1e95	c9 ff		cmp #$ff			cmp 	#$FF
.1e97	f0 08		beq $1ea1			beq 	_CCNoBGR 					; if so, change background
.1e99	20 a9 1e	jsr $1ea9			jsr 	_CCSetColour
.1e9c	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1e9e	20 b1 1c	jsr $1cb1			jsr 	XPrintCharacterToChannel
.1ea1					_CCNoBGR:
.1ea1	a5 3e		lda $3e				lda 	NSMantissa0
.1ea3	20 a9 1e	jsr $1ea9			jsr 	_CCSetColour
.1ea6	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ea9					_CCSetColour:
.1ea9	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1eab	aa		tax				tax
.1eac	bd b3 1e	lda $1eb3,x			lda 	_CCCommandTable,x
.1eaf	20 b1 1c	jsr $1cb1			jsr 	XPrintCharacterToChannel
.1eb2	60		rts				rts
.1eb3					_CCCommandTable:
>1eb3	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1ebb	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1ec3					CommandVPOKE:
.1ec3	fa		plx				plx
.1ec4	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; poke value
.1ec7	48		pha				pha
.1ec8	ca		dex				dex
.1ec9	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.1ecc	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ece	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1ed1	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ed3	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ed6	ca		dex				dex
.1ed7	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.1eda	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1edd	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1ee0	ca		dex				dex
.1ee1	68		pla				pla 								; poke value back
.1ee2	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1ee5	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ee8					CommandVPEEK:
.1ee8	fa		plx				plx
.1ee9	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.1eec	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1eee	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1ef1	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ef3	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ef6	ca		dex				dex
.1ef7	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.1efa	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1efd	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1f00	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1f03	20 8a 26	jsr $268a			jsr 	FloatSetByte 				; return as byte
.1f06	4c 4f 08	jmp $084f			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ff					C64_PI                   = $ff ; $ff pi
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ceb7					C64_BANNER               = $ceb7 ; $ceb7 banner
=$ceb8					C64_EXEC                 = $ceb8 ; $ceb8 exec
=$ceb9					C64_TILE                 = $ceb9 ; $ceb9 tile
=$ceba					C64_EDIT                 = $ceba ; $ceba edit
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$cedb					C64_MWHEEL               = $cedb ; $cedb mwheel
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$cb					PCD_ENDCOMMAND = $cb
=$cb					PCD_STARTSYSTEM = $cb
=$d7					PCD_ENDSYSTEM = $d7
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_PI               = $ac ; pi
=$ad					PCD_POKE             = $ad ; poke
=$ae					PCD_POS              = $ae ; pos
=$af					PCD_GETCHANNEL       = $af ; getchannel
=$b0					PCD_SETCHANNEL       = $b0 ; setchannel
=$b1					PCD_PRINTCMD_N       = $b1 ; print.n
=$b2					PCD_PRINTCMD_S       = $b2 ; print.s
=$b3					PCD_READ             = $b3 ; read
=$b4					PCD_READDOLLAR       = $b4 ; read$
=$b5					PCD_RND              = $b5 ; rnd
=$b6					PCD_CONCAT           = $b6 ; concat
=$b7					PCD_SGN              = $b7 ; sgn
=$b8					PCD_PRINTCMD_TAB     = $b8 ; print.tab
=$b9					PCD_PRINTCMD_POS     = $b9 ; print.pos
=$ba					PCD_PRINTCMD_SPC     = $ba ; print.spc
=$bb					PCD_STRDOLLAR        = $bb ; str$
=$bc					PCD_LEFTDOLLAR       = $bc ; left$
=$bd					PCD_RIGHTDOLLAR      = $bd ; right$
=$be					PCD_MIDDOLLAR        = $be ; mid$
=$bf					PCD_SWAP             = $bf ; swap
=$c0					PCD_TI               = $c0 ; ti
=$c1					PCD_TIDOLLAR         = $c1 ; ti$
=$c2					PCD_USR              = $c2 ; usr
=$c3					PCD_VAL              = $c3 ; val
=$c4					PCD_CLOSE            = $c4 ; close
=$c5					PCD_EXIT             = $c5 ; exit
=$c6					PCD_DEBUG            = $c6 ; debug
=$c7					PCD_OPEN             = $c7 ; open
=$c8					PCD_SCREEN           = $c8 ; screen
=$c9					PCD_VPOKE            = $c9 ; vpoke
=$ca					PCD_VPEEK            = $ca ; vpeek
=$cb					PCD_CMD_SHIFT        = $cb ; .shift
=$cc					PCD_CMD_BYTE         = $cc ; .byte
=$cd					PCD_CMD_WORD         = $cd ; .word
=$ce					PCD_CMD_FLOAT        = $ce ; .float
=$cf					PCD_CMD_STRING       = $cf ; .string
=$d0					PCD_CMD_DATA         = $d0 ; .data
=$d1					PCD_CMD_GOTO         = $d1 ; .goto
=$d2					PCD_CMD_GOSUB        = $d2 ; .gosub
=$d3					PCD_CMD_GOTOCMD_Z    = $d3 ; .goto.z
=$d4					PCD_CMD_GOTOCMD_NZ   = $d4 ; .goto.nz
=$d5					PCD_CMD_VARSPACE     = $d5 ; .varspace
=$d6					PCD_CMD_RESTORE      = $d6 ; .restore
=$cb80					PCD_CLR              = $cb80 ; clr
=$cb81					PCD_DIM              = $cb81 ; dim
=$cb82					PCD_END              = $cb82 ; end
=$cb83					PCD_JOY              = $cb83 ; joy
=$cb84					PCD_INT              = $cb84 ; int
=$cb85					PCD_SQR              = $cb85 ; sqr
=$cb86					PCD_LOG              = $cb86 ; log
=$cb87					PCD_EXP              = $cb87 ; exp
=$cb88					PCD_COS              = $cb88 ; cos
=$cb89					PCD_SIN              = $cb89 ; sin
=$cb8a					PCD_TAN              = $cb8a ; tan
=$cb8b					PCD_ATN              = $cb8b ; atn
=$cb8c					PCD_MOUSE            = $cb8c ; mouse
=$cb8d					PCD_MB               = $cb8d ; mb
=$cb8e					PCD_MX               = $cb8e ; mx
=$cb8f					PCD_MY               = $cb8f ; my
=$cb90					PCD_STOP             = $cb90 ; stop
=$cb91					PCD_SYS              = $cb91 ; sys
=$cb92					PCD_TIDOLLARCMD_WRITE = $cb92 ; ti$.write
=$cb93					PCD_WAIT             = $cb93 ; wait
=$cb94					PCD_I2CPOKE          = $cb94 ; i2cpoke
=$cb95					PCD_I2CPEEK          = $cb95 ; i2cpeek
=$cb96					PCD_BANK             = $cb96 ; bank
=$cb97					PCD_SLEEP            = $cb97 ; sleep
=$cb98					PCD_FMINIT           = $cb98 ; fminit
=$cb99					PCD_FMNOTE           = $cb99 ; fmnote
=$cb9a					PCD_FMDRUM           = $cb9a ; fmdrum
=$cb9b					PCD_FMINST           = $cb9b ; fminst
=$cb9c					PCD_FMVIB            = $cb9c ; fmvib
=$cb9d					PCD_FMFREQ           = $cb9d ; fmfreq
=$cb9e					PCD_FMVOL            = $cb9e ; fmvol
=$cb9f					PCD_FMPAN            = $cb9f ; fmpan
=$cba0					PCD_FMPLAY           = $cba0 ; fmplay
=$cba1					PCD_FMCHORD          = $cba1 ; fmchord
=$cba2					PCD_FMPOKE           = $cba2 ; fmpoke
=$cba3					PCD_PSGINIT          = $cba3 ; psginit
=$cba4					PCD_PSGNOTE          = $cba4 ; psgnote
=$cba5					PCD_PSGVOL           = $cba5 ; psgvol
=$cba6					PCD_PSGWAV           = $cba6 ; psgwav
=$cba7					PCD_PSGFREQ          = $cba7 ; psgfreq
=$cba8					PCD_PSGPAN           = $cba8 ; psgpan
=$cba9					PCD_PSGPLAY          = $cba9 ; psgplay
=$cbaa					PCD_PSGCHORD         = $cbaa ; psgchord
=$cbab					PCD_CLS              = $cbab ; cls
=$cbac					PCD_LOCATE           = $cbac ; locate
=$cbad					PCD_COLOR            = $cbad ; color
.1f09					SetErrorHandler:
.1f09	8c 70 05	sty $0570			sty 	ErrorHandlerVector+1
.1f0c	8e 6f 05	stx $056f			stx 	ErrorHandlerVector
.1f0f	60		rts				rts
.1f10					CallErrorHandler:
.1f10	6c 6f 05	jmp ($056f)			jmp 	(ErrorHandlerVector)
.056f					ErrorHandlerVector:
>056f							.fill 	2
.1f13					ErrorV_range:
.1f13	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>1f16	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f1e	41 4e 47 45 00
.1f23					ErrorV_value:
.1f23	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>1f26	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f2e	45 00
.1f30					ErrorV_syntax:
.1f30	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>1f33	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f3b	52 52 4f 52 00
.1f40					ErrorV_type:
.1f40	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>1f43	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f4b	4d 41 54 43 48 00
.1f51					ErrorV_unimplemented:
.1f51	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>1f54	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f5c	45 4d 45 4e 54 45 44 00
.1f64					ErrorV_assert:
.1f64	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>1f67	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f6f	41 49 4c 00
.1f73					ErrorV_line:
.1f73	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>1f76	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f7e	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f8a					ErrorV_internal:
.1f8a	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>1f8d	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f95	20 45 52 52 4f 52 00
.1f9c					ErrorV_divzero:
.1f9c	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>1f9f	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1fa7	59 20 5a 45 52 4f 00
.1fae					ErrorV_structure:
.1fae	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>1fb1	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fb9	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fc5					ErrorV_stop:
.1fc5	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>1fc8	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fd0	53 54 4f 50 50 45 44 00
.1fd8					ErrorV_data:
.1fd8	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>1fdb	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fe3	41 54 41 00
.1fe7					ErrorV_undeclared:
.1fe7	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>1fea	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1ff2	41 52 52 41 59 00
.1ff8					ErrorV_redefine:
.1ff8	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>1ffb	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>2003	44 45 46 49 4e 45 44 00
.200b					ErrorV_index:
.200b	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>200e	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2016	59 20 49 4e 44 45 58 00
.201e					ErrorV_memory:
.201e	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>2021	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2029	45 4d 4f 52 59 00
.202f					ErrorV_channel:
.202f	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>2032	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>203a	54 50 55 54 20 45 52 52 4f 52 00
.2045					ErrorV_break:
.2045	20 10 1f	jsr $1f10		jsr	CallErrorHandler
>2048	42 52 45 41 4b 20 50 52			.text	"BREAK PRESSED",0
>2050	45 53 53 45 44 00
.2056					MoveObjectForward:
.2056	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.2058	c9 ff		cmp #$ff			cmp 	#$FF
.205a	f0 36		beq $2092			beq 	_MOFEnd
.205c	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.205e	90 24		bcc $2084			bcc 	_MOFAdvance1 				; forward 1
.2060	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.2062	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2064	90 20		bcc $2086			bcc 	_MOFAdvanceY
.2066	c9 cb		cmp #$cb			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2068	90 1a		bcc $2084			bcc 	_MOFAdvance1 				; forward 1
.206a	a8		tay				tay 								; read the size.
.206b	b9 cf 1f	lda $1fcf,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.206e	a8		tay				tay
.206f	c8		iny				iny 								; add 1 for the system token.
.2070	d0 14		bne $2086			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2072	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2074	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2076	a8		tay				tay 								; into Y.
.2077	18		clc				clc
.2078	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.207a	69 02		adc #$02			adc 	#2
.207c	85 2a		sta $2a				sta 	objPtr
.207e	90 02		bcc $2082			bcc 	_MOFNoCarry1
.2080	e6 2b		inc $2b				inc 	objPtr+1
.2082					_MOFNoCarry1:
.2082	80 02		bra $2086			bra 	_MOFAdvanceY
.2084					_MOFAdvance1:
.2084	a0 01		ldy #$01			ldy 	#1
.2086					_MOFAdvanceY:
.2086	98		tya				tya 								; add Y to objPtr
.2087	18		clc				clc
.2088	65 2a		adc $2a				adc 	objPtr
.208a	85 2a		sta $2a				sta 	objPtr
.208c	90 02		bcc $2090			bcc 	_MOFNoCarry2
.208e	e6 2b		inc $2b				inc 	objPtr+1
.2090					_MOFNoCarry2:
.2090	18		clc				clc 								; not completed.
.2091	60		rts				rts
.2092					_MOFEnd:
.2092	e6 2a		inc $2a				inc 	objPtr
.2094	d0 02		bne $2098			bne 	_MOFENoCarry
.2096	e6 2b		inc $2b				inc 	objPtr+1
.2098					_MOFENoCarry:
.2098	38		sec				sec
.2099	60		rts				rts
.209a					MOFSizeTable:
>209a	01					.byte	1         	; $cb .shift
>209b	01					.byte	1         	; $cc .byte
>209c	02					.byte	2         	; $cd .word
>209d	05					.byte	5         	; $ce .float
>209e	ff					.byte	255       	; $cf .string
>209f	ff					.byte	255       	; $d0 .data
>20a0	02					.byte	2         	; $d1 .goto
>20a1	02					.byte	2         	; $d2 .gosub
>20a2	02					.byte	2         	; $d3 .goto.z
>20a3	02					.byte	2         	; $d4 .goto.nz
>20a4	02					.byte	2         	; $d5 .varspace
>20a5	02					.byte	2         	; $d6 .restore

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0571					numberBuffer:
>0571							.fill 	34
.20a6					FloatSubtract:
.20a6	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.20a8	49 80		eor #$80			eor 	#$80
.20aa	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.20ac					FloatAdd:
.20ac	ca		dex				dex
.20ad	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.20af	15 6f		ora $6f,x			ora 	NSExponent+1,x
.20b1	15 62		ora $62,x			ora 	NSMantissa3,x
.20b3	15 63		ora $63,x			ora 	NSMantissa3+1,x
.20b5	d0 04		bne $20bb			bne 	_FAUseFloat
.20b7	20 48 24	jsr $2448			jsr 	FloatInt32Add 				; use the int32 one.
.20ba	60		rts				rts
.20bb					_FAUseFloat:
.20bb	20 dd 23	jsr $23dd			jsr 	FloatNormalise 				; normalise S[X]
.20be	f0 51		beq $2111			beq 	_FAReturn1
.20c0	e8		inx				inx 								; normalise S[X+1]
.20c1	20 dd 23	jsr $23dd			jsr 	FloatNormalise
.20c4	ca		dex				dex
.20c5	c9 00		cmp #$00			cmp 	#0
.20c7	f0 60		beq $2129			beq 	_FAExit 					; if so, just return A
.20c9	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20cb	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20cd	f0 18		beq $20e7			beq 	_FAExponentsEqual
.20cf	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20d1	a8		tay				tay
.20d2	38		sec				sec 								; do a signed comparison of the exponents.
.20d3	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20d5	50 02		bvc $20d9			bvc 	_FANoSignedChange
.20d7	49 80		eor #$80			eor 	#$80
.20d9					_FANoSignedChange:
.20d9	29 80		and #$80			and 	#$80
.20db	10 02		bpl $20df			bpl 	_FAHaveMax
.20dd	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.20df					_FAHaveMax:
.20df	20 2a 21	jsr $212a			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20e2	e8		inx				inx
.20e3	20 2a 21	jsr $212a			jsr 	_FAShiftToExponent
.20e6	ca		dex				dex
.20e7					_FAExponentsEqual:
.20e7	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.20e9	55 33		eor $33,x			eor 	NSStatus+1,x
.20eb	30 0e		bmi $20fb			bmi 	_FADifferentSigns
.20ed	20 14 24	jsr $2414			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20f0	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20f2	10 35		bpl $2129			bpl 	_FAExit 					; if no, we are done.
.20f4	20 a1 26	jsr $26a1			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20f7	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.20f9	80 2e		bra $2129			bra 	_FAExit
.20fb					_FADifferentSigns:
.20fb	20 2e 24	jsr $242e			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20fe	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.2100	10 06		bpl $2108			bpl 	_FACheckZero 				; if no, check for -0
.2102	20 4a 26	jsr $264a			jsr 	FloatNegate 					; netate result
.2105	20 51 26	jsr $2651			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.2108					_FACheckZero:
.2108	20 aa 26	jsr $26aa			jsr 	FloatIsZero	 				; check for -0
.210b	d0 1c		bne $2129			bne 	_FAExit
.210d	74 32		stz $32,x			stz 	NSStatus,x
.210f	80 18		bra $2129			bra 	_FAExit
.2111					_FAReturn1:
.2111	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.2113	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2115	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2117	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2119	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.211b	95 56		sta $56,x			sta 	NSMantissa2,x
.211d	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.211f	95 62		sta $62,x			sta 	NSMantissa3,x
.2121	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.2123	95 6e		sta $6e,x			sta 	NSExponent,x
.2125	b5 33		lda $33,x			lda 	NSStatus+1,x
.2127	95 32		sta $32,x			sta 	NSStatus,x
.2129					_FAExit:
.2129	60		rts				rts
.212a					_FAShiftToExponent:
.212a					_FAShiftToExponent2:
.212a	98		tya				tya 								; compare Y to exponent
.212b	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.212d	f0 07		beq $2136			beq 	_FASEExit 					; exit if so.
.212f	20 a1 26	jsr $26a1			jsr 	FloatShiftRight	 			; shift the mantissa right
.2132	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.2134	80 f4		bra $212a			bra 	_FAShiftToExponent2
.2136					_FASEExit:
.2136	60		rts				rts
.2137					CompareEqual:
.2137	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2139	d0 09		bne $2144			bne 	ReturnFalse
.213b					ReturnTrue:
.213b	a9 01		lda #$01			lda 	#1
.213d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.213f	a9 80		lda #$80			lda 	#$80
.2141	95 32		sta $32,x			sta 	NSStatus,x
.2143	60		rts				rts
.2144					ReturnFalse:
.2144	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2146	60		rts				rts
.2147					CompareNotEqual:
.2147	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2149	d0 f0		bne $213b			bne 	ReturnTrue
.214b	80 f7		bra $2144			bra 	ReturnFalse
.214d					CompareLess:
.214d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.214f	c9 ff		cmp #$ff			cmp 	#$FF
.2151	f0 e8		beq $213b			beq 	ReturnTrue
.2153	80 ef		bra $2144			bra 	ReturnFalse
.2155					CompareGreater:
.2155	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2157	c9 01		cmp #$01			cmp 	#$01
.2159	f0 e0		beq $213b			beq 	ReturnTrue
.215b	80 e7		bra $2144			bra 	ReturnFalse
.215d					CompareLessEqual:
.215d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.215f	c9 01		cmp #$01			cmp 	#$01
.2161	d0 d8		bne $213b			bne 	ReturnTrue
.2163	80 df		bra $2144			bra 	ReturnFalse
.2165					CompareGreaterEqual:
.2165	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2167	c9 ff		cmp #$ff			cmp 	#$FF
.2169	d0 d0		bne $213b			bne 	ReturnTrue
.216b	80 d7		bra $2144			bra 	ReturnFalse
.216d					FloatCompare:
.216d	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.216f	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.2171	48		pha				pha
.2172	20 a6 20	jsr $20a6			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2175	68		pla				pla
.2176	d0 0c		bne $2184			bne 	_FCCompareFloat
.2178	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.217a	15 4a		ora $4a,x			ora 	NSMantissa1,x
.217c	15 56		ora $56,x			ora 	NSMantissa2,x
.217e	15 62		ora $62,x			ora 	NSMantissa3,x
.2180	f0 14		beq $2196			beq 	_FCExit 					; if zero, return zero
.2182	80 0a		bra $218e			bra 	_FCSign
.2184					_FCCompareFloat:
.2184	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2186	29 f0		and #$f0			and 	#$F0
.2188	15 56		ora $56,x			ora 	NSMantissa2,x
.218a	15 62		ora $62,x			ora 	NSMantissa3,x
.218c	f0 08		beq $2196			beq 	_FCExit 					; zero, so approximately identical
.218e					_FCSign:
.218e	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.2190	34 32		bit $32,x			bit 	NSStatus,x
.2192	10 02		bpl $2196			bpl 	_FCExit
.2194					_FCNegative:
.2194	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2196					_FCExit:
.2196	20 8a 26	jsr $268a			jsr 	FloatSetByte 				; set the result 255,0,1
.2199	60		rts				rts
.219a					FloatScalarTable:
>219a	66 66 66 66				.dword $66666666 ; 0.1
>219e	de					.byte $de
>219f	1f 85 eb 51				.dword $51eb851f ; 0.01
>21a3	db					.byte $db
>21a4	4c 37 89 41				.dword $4189374c ; 0.001
>21a8	d8					.byte $d8
>21a9	ac 8b db 68				.dword $68db8bac ; 0.0001
>21ad	d4					.byte $d4
>21ae	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>21b2	d1					.byte $d1
>21b3	83 de 1b 43				.dword $431bde83 ; 1e-06
>21b7	ce					.byte $ce
>21b8	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21bc	ca					.byte $ca
>21bd	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21c1	c7					.byte $c7
>21c2	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21c6	c4					.byte $c4
>21c7	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21cb	c0					.byte $c0
>21cc	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21d0	bd					.byte $bd
.21d1					FloatDivide:
.21d1	48		pha				pha
.21d2	20 dd 23	jsr $23dd			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21d5	ca		dex				dex
.21d6	c9 00		cmp #$00			cmp 	#0
.21d8	f0 1e		beq $21f8			beq 	_FDZero
.21da	20 dd 23	jsr $23dd			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21dd	f0 16		beq $21f5			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21df	20 40 22	jsr $2240			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21e2	20 0d 22	jsr $220d			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21e5	20 dd 23	jsr $23dd			jsr		FloatNormalise 				; renormalise
.21e8	20 d3 23	jsr $23d3			jsr 	FloatCalculateSign 			; calculate result sign
.21eb	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.21ed	38		sec				sec
.21ee	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.21f0	38		sec				sec
.21f1	e9 1e		sbc #$1e			sbc 	#30
.21f3	95 6e		sta $6e,x			sta 	NSExponent,x
.21f5					_FDExit:
.21f5	68		pla				pla
.21f6	18		clc				clc
.21f7	60		rts				rts
.21f8					_FDZero:
.21f8	68		pla				pla
.21f9	38		sec				sec
.21fa	60		rts				rts
.21fb					DivideInt32:
.21fb	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart 			; make both integers
.21fe	ca		dex				dex
.21ff	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.2202	20 1e 22	jsr $221e			jsr 	Int32Divide 				; divide
.2205	20 0d 22	jsr $220d			jsr 	NSMCopyPlusTwoToZero 		; copy result
.2208	20 d3 23	jsr $23d3			jsr 	FloatCalculateSign 			; calculate result sign
.220b	18		clc				clc
.220c	60		rts				rts
.220d					NSMCopyPlusTwoToZero:
.220d	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.220f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2211	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.2213	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2215	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.2217	95 56		sta $56,x			sta 	NSMantissa2,x
.2219	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.221b	95 62		sta $62,x			sta 	NSMantissa3,x
.221d	60		rts				rts
.221e					Int32Divide:
.221e	48		pha				pha 								; save AXY
.221f	5a		phy				phy
.2220	20 6b 26	jsr $266b			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2223	20 84 26	jsr $2684			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2226	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2228					_I32DivideLoop:
.2228	e8		inx				inx
.2229	e8		inx				inx
.222a	20 97 26	jsr $2697			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.222d	ca		dex				dex
.222e	ca		dex				dex
.222f	20 98 26	jsr $2698			jsr 	FloatRotateLeft
.2232	20 5e 22	jsr $225e			jsr 	FloatDivideCheck 			; check if subtract possible
.2235	90 02		bcc $2239			bcc 	_I32DivideNoCarryIn
.2237	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2239					_I32DivideNoCarryIn:
.2239	88		dey				dey 								; loop round till division completed.
.223a	d0 ec		bne $2228			bne 	_I32DivideLoop
.223c	7a		ply				ply 								; restore AXY and exit
.223d	68		pla				pla
.223e	18		clc				clc
.223f	60		rts				rts
.2240					Int32ShiftDivide:
.2240	48		pha				pha 								; save AY
.2241	5a		phy				phy
.2242	e8		inx				inx 								; clear S[X+2]
.2243	e8		inx				inx
.2244	20 88 26	jsr $2688			jsr 	FloatSetZero
.2247	ca		dex				dex
.2248	ca		dex				dex
.2249	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.224b					_I32SDLoop:
.224b	20 5e 22	jsr $225e			jsr 	FloatDivideCheck 			; check if subtract possible
.224e	e8		inx				inx
.224f	e8		inx				inx
.2250	20 98 26	jsr $2698			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.2253	ca		dex				dex
.2254	ca		dex				dex
.2255	20 98 26	jsr $2698			jsr 	FloatRotateLeft
.2258	88		dey				dey 	 							; do 31 times
.2259	d0 f0		bne $224b			bne 	_I32SDLoop
.225b	7a		ply				ply 								; restore AY and exit
.225c	68		pla				pla
.225d	60		rts				rts
.225e					FloatDivideCheck:
.225e	20 2e 24	jsr $242e			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.2261	b0 04		bcs $2267			bcs 	_DCSExit 					; if carry set, then could do, exit
.2263	20 14 24	jsr $2414			jsr 	FloatAddTopTwoStack 		; add it back in
.2266	18		clc				clc 								; and return False
.2267					_DCSExit:
.2267	60		rts				rts
.2268					FloatFractionalPart:
.2268	5a		phy				phy
.2269	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.226b	29 7f		and #$7f			and 	#$7F
.226d	95 32		sta $32,x			sta 	NSStatus,x
.226f	20 dd 23	jsr $23dd			jsr 	FloatNormalise
.2272	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2274	38		sec				sec
.2275	e9 e0		sbc #$e0			sbc 	#$E0
.2277	90 29		bcc $22a2			bcc 	_FFPExit 					; already fractional
.2279	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.227b	b0 22		bcs $229f			bcs 	_FFPZero
.227d	a8		tay				tay 								; put count to do in Y
.227e	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.2280	20 a7 22	jsr $22a7			jsr 	_FFPPartial
.2283	95 62		sta $62,x			sta 	NSMantissa3,x
.2285	b5 56		lda $56,x			lda 	NSMantissa2,x
.2287	20 a7 22	jsr $22a7			jsr 	_FFPPartial
.228a	95 56		sta $56,x			sta 	NSMantissa2,x
.228c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.228e	20 a7 22	jsr $22a7			jsr 	_FFPPartial
.2291	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2293	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2295	20 a7 22	jsr $22a7			jsr 	_FFPPartial
.2298	95 3e		sta $3e,x			sta 	NSMantissa0,x
.229a	20 aa 26	jsr $26aa			jsr 	FloatIsZero 					; zeroed check.
.229d	d0 03		bne $22a2			bne 	_FFPExit
.229f					_FFPZero:
.229f	20 88 26	jsr $2688			jsr 	FloatSetZero
.22a2					_FFPExit:
.22a2	20 dd 23	jsr $23dd			jsr 	FloatNormalise
.22a5	7a		ply				ply
.22a6	60		rts				rts
.22a7					_FFPPartial:
.22a7	c0 00		cpy #$00			cpy 	#0 							; no more to do
.22a9	f0 17		beq $22c2			beq 	_FFFPPExit
.22ab	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.22ad	b0 0c		bcs $22bb			bcs 	_FFFPPWholeByte
.22af	5a		phy				phy
.22b0					_FFFPPLeft:
.22b0	0a		asl a				asl 	a
.22b1	88		dey				dey
.22b2	d0 fc		bne $22b0			bne 	_FFFPPLeft
.22b4	7a		ply				ply
.22b5					_FFFPPRight:
.22b5	4a		lsr a				lsr 	a
.22b6	88		dey				dey
.22b7	d0 fc		bne $22b5			bne 	_FFFPPRight
.22b9	80 07		bra $22c2			bra 	_FFFPPExit
.22bb					_FFFPPWholeByte:
.22bb	98		tya				tya 								; subtract 8 from count
.22bc	38		sec				sec
.22bd	e9 08		sbc #$08			sbc 	#8
.22bf	a8		tay				tay
.22c0	a9 00		lda #$00			lda 	#0 							; and clear all
.22c2					_FFFPPExit:
.22c2	60		rts				rts
.22c3					FloatIntegerPart:
.22c3	48		pha				pha
.22c4	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22c6	f0 1d		beq $22e5			beq 	_FIPExit 					; if so do nothing
.22c8	20 aa 26	jsr $26aa			jsr 	FloatIsZero 				; is it zero ?
.22cb	f0 15		beq $22e2			beq 	_FIPZero 					; if so return zero.
.22cd	20 dd 23	jsr $23dd			jsr 	FloatNormalise 				; normalise
.22d0	f0 10		beq $22e2			beq 	_FIPZero 					; normalised to zero, exit zero
.22d2					_FIPShift:
.22d2	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22d4	10 07		bpl $22dd			bpl 	_FIPCheckZero
.22d6	20 a1 26	jsr $26a1			jsr 	FloatShiftRight 			; shift mantissa right
.22d9	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22db	80 f5		bra $22d2			bra 	_FIPShift
.22dd					_FIPCheckZero:
.22dd	20 aa 26	jsr $26aa			jsr 	FloatIsZero 				; avoid -0 problem
.22e0	d0 03		bne $22e5			bne 	_FIPExit 					; set to zero if mantissa zero.
.22e2					_FIPZero:
.22e2	20 88 26	jsr $2688			jsr 	FloatSetZero
.22e5					_FIPExit:
.22e5	68		pla				pla
.22e6	60		rts				rts
.22e7					FloatIntegerPartDown:
.22e7	48		pha				pha
.22e8	5a		phy				phy
.22e9	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22eb	f0 36		beq $2323			beq 	_FIPExit 					; if so do nothing
.22ed	20 aa 26	jsr $26aa			jsr 	FloatIsZero 				; is it zero ?
.22f0	f0 2e		beq $2320			beq 	_FIPZero 					; if so return zero.
.22f2	20 dd 23	jsr $23dd			jsr 	FloatNormalise 				; normalise
.22f5	f0 29		beq $2320			beq 	_FIPZero 					; normalised to zero, exit zero
.22f7	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22f9					_FIPShift:
.22f9	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22fb	10 0a		bpl $2307			bpl 	_FIPCheckDown
.22fd	20 a1 26	jsr $26a1			jsr 	FloatShiftRight 			; shift mantissa right
.2300	90 01		bcc $2303			bcc 	_FIPNoFrac 					; shifted a zero out ?
.2302	c8		iny				iny
.2303					_FIPNoFrac:
.2303	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.2305	80 f2		bra $22f9			bra 	_FIPShift
.2307					_FIPCheckDown:
.2307	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.2309	f0 10		beq $231b			beq 	_FIPCheckZero
.230b	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.230d	10 0c		bpl $231b			bpl 	_FIPCheckZero
.230f	e8		inx				inx 								; -ve so round *down*.
.2310	a9 01		lda #$01			lda 	#1
.2312	20 8a 26	jsr $268a			jsr 	FloatSetByte
.2315	20 4a 26	jsr $264a			jsr 	FloatNegate
.2318	20 ac 20	jsr $20ac			jsr 	FloatAdd
.231b					_FIPCheckZero:
.231b	20 aa 26	jsr $26aa			jsr 	FloatIsZero 				; avoid -0 problem
.231e	d0 03		bne $2323			bne 	_FIPExit 					; set to zero if mantissa zero.
.2320					_FIPZero:
.2320	20 88 26	jsr $2688			jsr 	FloatSetZero
.2323					_FIPExit:
.2323	7a		ply				ply
.2324	68		pla				pla
.2325	60		rts				rts
.2326					FloatInt8Multiply:
.2326	5a		phy				phy
.2327	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2329	a8		tay				tay
.232a	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.232c					_FI8MLoop:
.232c	98		tya				tya 								; shift right shifter right into carry
.232d	4a		lsr a				lsr 	a
.232e	a8		tay				tay
.232f	90 0d		bcc $233e			bcc 	_FI8MNoAdd
.2331	18		clc				clc
.2332	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2334	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.2336	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2338	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.233a	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.233c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.233e					_FI8MNoAdd:
.233e	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.2340	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.2342	c0 00		cpy #$00			cpy 	#0
.2344	d0 e6		bne $232c			bne 	_FI8MLoop 					; until right shifter zero.
.2346	7a		ply				ply
.2347	60		rts				rts
.2348					FloatMultiply:
.2348	ca		dex				dex
.2349	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.234b	15 6f		ora $6f,x			ora 	NSExponent+1,x
.234d	15 62		ora $62,x			ora 	NSMantissa3,x
.234f	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2351	d0 21		bne $2374			bne 	_FMUseFloat
.2353	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2355	15 33		ora $33,x			ora 	NSStatus+1,x
.2357	29 80		and #$80			and 	#$80
.2359	15 62		ora $62,x			ora 	NSMantissa3,x
.235b	15 56		ora $56,x			ora 	NSMantissa2,x
.235d	15 4a		ora $4a,x			ora 	NSMantissa1,x
.235f	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2361	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2363	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2365	d0 04		bne $236b			bne 	_FMInt32
.2367	20 26 23	jsr $2326			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.236a	60		rts				rts
.236b					_FMInt32:
.236b	20 95 23	jsr $2395			jsr 	FloatMultiplyShort			; use the int32 one.
.236e	18		clc				clc 								; fix it up if gone out of range
.236f	75 6e		adc $6e,x			adc 	NSExponent,x
.2371	95 6e		sta $6e,x			sta 	NSExponent,x
.2373	60		rts				rts
.2374					_FMUseFloat:
.2374	20 dd 23	jsr $23dd			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2377	f0 18		beq $2391			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2379	e8		inx				inx
.237a	20 dd 23	jsr $23dd			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.237d	ca		dex				dex
.237e	c9 00		cmp #$00			cmp 	#0
.2380	f0 0c		beq $238e			beq 	_FDSetZero
.2382	20 95 23	jsr $2395			jsr 	FloatMultiplyShort 			; calculate the result.
.2385	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2387	18		clc				clc
.2388	75 6f		adc $6f,x			adc 	NSExponent+1,x
.238a	95 6e		sta $6e,x			sta 	NSExponent,x
.238c	80 03		bra $2391			bra 	_FDExit
.238e					_FDSetZero:
.238e	20 88 26	jsr $2688			jsr 	FloatSetZero 				; return 0
.2391					_FDExit:
.2391	20 dd 23	jsr $23dd			jsr 	FloatNormalise 				; normalise the result
.2394	60		rts				rts
.2395					FloatMultiplyShort:
.2395	5a		phy				phy 								; save Y
.2396	20 6b 26	jsr $266b			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2399	20 84 26	jsr $2684			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.239c	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.239e					_I32MLoop:
.239e	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.23a0	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.23a2	15 58		ora $58,x			ora 	NSMantissa2+2,x
.23a4	15 64		ora $64,x			ora 	NSMantissa3+2,x
.23a6	f0 25		beq $23cd			beq 	_I32MExit 					; exit if zero
.23a8	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.23aa	29 01		and #$01			and 	#1
.23ac	f0 0d		beq $23bb			beq 	_I32MNoAdd
.23ae	20 14 24	jsr $2414			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.23b1	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.23b3	10 06		bpl $23bb			bpl 	_I32MNoAdd
.23b5					_I32ShiftRight:
.23b5	20 a1 26	jsr $26a1			jsr 	FloatShiftRight 			; shift S[X] right
.23b8	c8		iny				iny 								; increment shift count
.23b9	80 09		bra $23c4			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23bb					_I32MNoAdd:
.23bb	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23bd	70 f6		bvs $23b5			bvs 	_I32ShiftRight 				; instead.
.23bf	e8		inx				inx
.23c0	20 97 26	jsr $2697			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23c3	ca		dex				dex
.23c4					_I32MShiftUpper:
.23c4	e8		inx				inx 								; shift S[X+2] right
.23c5	e8		inx				inx
.23c6	20 a1 26	jsr $26a1			jsr 	FloatShiftRight
.23c9	ca		dex				dex
.23ca	ca		dex				dex
.23cb	80 d1		bra $239e			bra 	_I32MLoop 					; try again.
.23cd					_I32MExit:
.23cd	20 d3 23	jsr $23d3			jsr 	FloatCalculateSign
.23d0	98		tya				tya 								; shift in A
.23d1	7a		ply				ply 								; restore Y and exit
.23d2	60		rts				rts
.23d3					FloatCalculateSign:
.23d3	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23d5	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23d7	55 33		eor $33,x			eor 	NSStatus+1,x
.23d9	0a		asl a				asl 	a 							; shift bit 7 into carry
.23da	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23dc	60		rts				rts
.23dd					FloatNormalise:
.23dd	20 aa 26	jsr $26aa			jsr 	FloatIsZero 				; if zero exit
.23e0	d0 07		bne $23e9			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23e2	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.23e4	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.23e6	a9 00		lda #$00			lda 	#0 							; set Z flag
.23e8	60		rts				rts
.23e9					_NSNormaliseOptimise:
.23e9	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23eb	d0 19		bne $2406			bne 	_NSNormaliseLoop
.23ed	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.23ef	30 15		bmi $2406			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23f1	95 62		sta $62,x			sta 	NSMantissa3,x
.23f3	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.23f5	95 56		sta $56,x			sta 	NSMantissa2,x
.23f7	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.23f9	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23fb	74 3e		stz $3e,x			stz 	NSMantissa0,x
.23fd	b5 6e		lda $6e,x			lda 	NSExponent,x
.23ff	38		sec				sec
.2400	e9 08		sbc #$08			sbc 	#8
.2402	95 6e		sta $6e,x			sta 	NSExponent,x
.2404	80 e3		bra $23e9			bra 	_NSNormaliseOptimise
.2406					_NSNormaliseLoop:
.2406	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.2408	70 07		bvs $2411			bvs 	_NSNExit 					; exit if so with Z flag clear
.240a	20 97 26	jsr $2697			jsr 	FloatShiftLeft 				; shift mantissa left
.240d	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.240f	80 f5		bra $2406			bra 	_NSNormaliseLoop
.2411					_NSNExit:
.2411	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.2413	60		rts				rts
.2414					FloatAddTopTwoStack:
.2414	18		clc				clc
.2415	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2417	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.2419	95 3e		sta $3e,x			sta 	NSMantissa0,x
.241b	b5 4a		lda $4a,x			lda		NSMantissa1,x
.241d	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.241f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2421	b5 56		lda $56,x			lda		NSMantissa2,x
.2423	75 57		adc $57,x			adc 		NSMantissa2+1,x
.2425	95 56		sta $56,x			sta 	NSMantissa2,x
.2427	b5 62		lda $62,x			lda		NSMantissa3,x
.2429	75 63		adc $63,x			adc 		NSMantissa3+1,x
.242b	95 62		sta $62,x			sta 	NSMantissa3,x
.242d	60		rts				rts
.242e					FloatSubTopTwoStack:
.242e	38		sec				sec
.242f	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2431	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.2433	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2435	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2437	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.2439	95 4a		sta $4a,x			sta 	NSMantissa1,x
.243b	b5 56		lda $56,x			lda		NSMantissa2,x
.243d	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.243f	95 56		sta $56,x			sta 	NSMantissa2,x
.2441	b5 62		lda $62,x			lda		NSMantissa3,x
.2443	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.2445	95 62		sta $62,x			sta 	NSMantissa3,x
.2447	60		rts				rts
.2448					FloatInt32Add:
.2448	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.244a	55 33		eor $33,x			eor 	NSStatus+1,x
.244c	30 04		bmi $2452			bmi 	_DiffSigns
.244e	20 14 24	jsr $2414			jsr		FloatAddTopTwoStack
.2451	60		rts				rts
.2452					_DiffSigns:
.2452	20 2e 24	jsr $242e			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2455	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2457	10 07		bpl $2460			bpl 	_AddExit
.2459	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.245b	95 32		sta $32,x			sta 	NSStatus,x
.245d	20 51 26	jsr $2651			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.2460					_AddExit:
.2460	20 aa 26	jsr $26aa			jsr 	FloatIsZero 				; check for -0
.2463	d0 02		bne $2467			bne 	_AddNonZero
.2465	74 32		stz $32,x			stz 	NSStatus,x
.2467					_AddNonZero:
.2467	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2468					FloatEncodeStart:
.2468	38		sec				sec
.2469	80 01		bra $246c			bra 	FloatEncodeContinue+1
.246b					FloatEncodeContinue:
.246b	18		clc				clc
.246c					FloatEncode:
.246c	08		php				php 								; save reset flag.
.246d	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.246f	f0 15		beq $2486			beq 	_ENIsOkay
.2471	c9 30		cmp #$30			cmp 	#"0"
.2473	90 04		bcc $2479			bcc 	_ENBadNumber
.2475	c9 3a		cmp #$3a			cmp 	#"9"+1
.2477	90 0d		bcc $2486			bcc 	_ENIsOkay
.2479					_ENBadNumber:
.2479	28		plp				plp 								; throw saved reset
.247a	ad 93 05	lda $0593			lda 	encodeState 				; if in decimal mode, construct final number
.247d	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.247f	d0 03		bne $2484			bne 	_ENFail
.2481	4c fe 24	jmp $24fe			jmp 	_ENConstructFinal
.2484					_ENFail:
.2484	18		clc				clc 								; not allowed
.2485	60		rts				rts
.2486					_ENIsOkay:
.2486	28		plp				plp 								; are we restarting
.2487	90 15		bcc $249e			bcc 	_ENNoRestart
.2489					_ENStartEncode:
.2489	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.248b	f0 0c		beq $2499			beq 	_ENFirstDP
.248d	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.248f	20 8a 26	jsr $268a			jsr 	FloatSetByte 				; in single byte mode.
.2492	a9 01		lda #$01			lda 	#ESTA_Low
.2494					_ENExitChange:
.2494	8d 93 05	sta $0593			sta 	encodeState 				; save new state
.2497	38		sec				sec
.2498	60		rts				rts
.2499					_ENFirstDP:
.2499	20 88 26	jsr $2688			jsr 	FloatSetZero 				; clear integer part
.249c	80 3c		bra $24da			bra 	_ESTASwitchFloat			; go straight to float and exi
.249e					_ENNoRestart:
.249e	48		pha				pha 								; save digit or DP on stack.
.249f	ad 93 05	lda $0593			lda 	encodeState 				; get current state
.24a2	c9 01		cmp #$01			cmp 	#ESTA_Low
.24a4	f0 09		beq $24af			beq  	_ESTALowState
.24a6	c9 02		cmp #$02			cmp 	#ESTA_High
.24a8	f0 26		beq $24d0			beq 	_ESTAHighState
.24aa	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.24ac	f0 38		beq $24e6			beq 	_ESTADecimalState
>24ae	db						.byte 	$DB 						; causes a break in the emulator
.24af					_ESTALowState:
.24af	68		pla				pla 								; get value back
.24b0	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.24b2	f0 26		beq $24da			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24b4	29 0f		and #$0f			and 	#15 						; make digit
.24b6	8d 94 05	sta $0594			sta 	digitTemp 					; save it.
.24b9	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24bb	0a		asl a				asl 	a
.24bc	0a		asl a				asl 	a
.24bd	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24bf	0a		asl a				asl 	a
.24c0	6d 94 05	adc $0594			adc 	digitTemp
.24c3	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24c5	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24c7	90 05		bcc $24ce			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24c9	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24cb	8d 93 05	sta $0593			sta 	encodeState
.24ce					_ESTANoSwitch:
.24ce	38		sec				sec
.24cf	60		rts				rts
.24d0					_ESTAHighState:
.24d0	68		pla				pla 								; get value back
.24d1	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24d3	f0 05		beq $24da			beq 	_ESTASwitchFloat
.24d5	20 30 25	jsr $2530			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24d8	38		sec				sec
.24d9	60		rts				rts
.24da					_ESTASwitchFloat:
.24da	9c 95 05	stz $0595			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24dd	e8		inx				inx 								; zero the decimal additive.
.24de	20 88 26	jsr $2688			jsr 	FloatSetZero
.24e1	ca		dex				dex
.24e2	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24e4	80 ae		bra $2494			bra 	_ENExitChange
.24e6					_ESTADecimalState:
.24e6	68		pla				pla 								; digit.
.24e7	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24e9	f0 99		beq $2484			beq 	_ENFail
.24eb	e8		inx				inx 								; put digit into fractional part of X+1
.24ec	20 30 25	jsr $2530			jsr 	ESTAShiftDigitIntoMantissa
.24ef	ca		dex				dex
.24f0	ee 95 05	inc $0595			inc 	decimalCount 				; bump the count of decimals
.24f3	ad 95 05	lda $0595			lda 	decimalCount 				; too many decimal digits.
.24f6	c9 0b		cmp #$0b			cmp 	#11
.24f8	f0 02		beq $24fc			beq 	_ESTADSFail
.24fa	38		sec				sec
.24fb	60		rts				rts
.24fc					_ESTADSFail:
.24fc	18		clc				clc
.24fd	60		rts				rts
.24fe					_ENConstructFinal:
.24fe	ad 95 05	lda $0595			lda 	decimalCount 				; get decimal count
.2501	f0 2b		beq $252e			beq 	_ENCFExit 					; no decimals
.2503	5a		phy				phy
.2504	0a		asl a				asl 	a 							; x 4 and CLC
.2505	0a		asl a				asl 	a
.2506	6d 95 05	adc $0595			adc 	decimalCount
.2509	a8		tay				tay
.250a	b9 95 21	lda $2195,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.250d	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.250f	b9 96 21	lda $2196,y			lda 	FloatScalarTable-5+1,y
.2512	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2514	b9 97 21	lda $2197,y			lda 	FloatScalarTable-5+2,y
.2517	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2519	b9 98 21	lda $2198,y			lda 	FloatScalarTable-5+3,y
.251c	95 64		sta $64,x			sta 	NSMantissa3+2,x
.251e	b9 99 21	lda $2199,y			lda 	FloatScalarTable-5+4,y
.2521	95 70		sta $70,x			sta 	NSExponent+2,x
.2523	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.2525	e8		inx				inx 								; multiply decimal const by decimal scalar
.2526	e8		inx				inx
.2527	20 48 23	jsr $2348			jsr 	FloatMultiply
.252a	20 ac 20	jsr $20ac			jsr 	FloatAdd 					; add to integer part.
.252d	7a		ply				ply
.252e					_ENCFExit:
.252e	18		clc				clc 								; reject the digit.
.252f	60		rts				rts
.2530					ESTAShiftDigitIntoMantissa:
.2530	29 0f		and #$0f			and 	#15 						; save digit
.2532	48		pha				pha
.2533	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2535	48		pha				pha
.2536	b5 56		lda $56,x			lda 	NSMantissa2,x
.2538	48		pha				pha
.2539	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.253b	48		pha				pha
.253c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.253e	48		pha				pha
.253f	20 97 26	jsr $2697			jsr 	FloatShiftLeft 				; x 2
.2542	20 97 26	jsr $2697			jsr 	FloatShiftLeft 				; x 4
.2545	18		clc				clc 								; pop mantissa and add
.2546	68		pla				pla
.2547	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2549	95 3e		sta $3e,x			sta 	NSMantissa0,x
.254b	68		pla				pla
.254c	75 4a		adc $4a,x			adc 	NSMantissa1,x
.254e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2550	68		pla				pla
.2551	75 56		adc $56,x			adc 	NSMantissa2,x
.2553	95 56		sta $56,x			sta 	NSMantissa2,x
.2555	68		pla				pla
.2556	75 62		adc $62,x			adc 	NSMantissa3,x
.2558	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.255a	20 97 26	jsr $2697			jsr 	FloatShiftLeft 				; x 10
.255d	68		pla				pla 								; add digit
.255e	18		clc				clc
.255f	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2561	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2563	90 0a		bcc $256f			bcc 	_ESTASDExit
.2565	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2567	d0 06		bne $256f			bne 	_ESTASDExit
.2569	f6 56		inc $56,x			inc 	NSMantissa2,x
.256b	d0 02		bne $256f			bne 	_ESTASDExit
.256d	f6 62		inc $62,x			inc 	NSMantissa3,x
.256f					_ESTASDExit:
.256f	60		rts				rts
.0593					encodeState:
>0593							.fill 	1
.0594					digitTemp:
>0594							.fill 	1
.0595					decimalCount:
>0595							.fill 	1
.2570					FloatToString:
.2570	da		phx				phx
.2571	5a		phy				phy 								; save code position
.2572	8d 96 05	sta $0596			sta 	decimalPlaces	 			; save number of DPs.
.2575	9c 97 05	stz $0597			stz 	dbOffset 					; offset into decimal buffer = start.
.2578	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.257a	10 08		bpl $2584			bpl 	_CNTSNotNegative
.257c	29 7f		and #$7f			and 	#$7F 						; make +ve
.257e	95 32		sta $32,x			sta 	NSStatus,x
.2580	a9 2d		lda #$2d			lda 	#"-"
.2582	80 02		bra $2586			bra 	_CNTMain
.2584					_CNTSNotNegative:
.2584	a9 20		lda #$20			lda 	#" "
.2586					_CNTMain:
.2586	20 e8 25	jsr $25e8			jsr 	WriteDecimalBuffer
.2589	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.258b	f0 0d		beq $259a			beq 	_CNTSNotFloat
.258d	e8		inx				inx 								; round up so we don't get too many 6.999999
.258e	a9 01		lda #$01			lda 	#1
.2590	20 8a 26	jsr $268a			jsr 	FloatSetByte
.2593	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2595	95 6e		sta $6e,x			sta 	NSExponent,x
.2597	20 ac 20	jsr $20ac			jsr 	FloatAdd
.259a					_CNTSNotFloat:
.259a	20 ca 25	jsr $25ca			jsr 	MakePlusTwoString 			; do the integer part.
.259d	20 68 22	jsr $2268			jsr 	FloatFractionalPart 		; get the fractional part
.25a0	20 dd 23	jsr $23dd			jsr 	FloatNormalise					; normalise , exit if zero
.25a3	f0 22		beq $25c7			beq 	_CNTSExit
.25a5	a9 2e		lda #$2e			lda 	#"."
.25a7	20 e8 25	jsr $25e8			jsr 	WriteDecimalBuffer 			; write decimal place
.25aa					_CNTSDecimal:
.25aa	ce 96 05	dec $0596			dec 	decimalPlaces 				; done all the decimals
.25ad	30 18		bmi $25c7			bmi 	_CNTSExit
.25af	e8		inx				inx 								; x 10.0
.25b0	a9 0a		lda #$0a			lda 	#10
.25b2	20 8a 26	jsr $268a			jsr 	FloatSetByte
.25b5	20 48 23	jsr $2348			jsr 	FloatMultiply
.25b8	20 ca 25	jsr $25ca			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25bb	20 68 22	jsr $2268			jsr 	FloatFractionalPart 		; get the fractional part
.25be	20 dd 23	jsr $23dd			jsr 	FloatNormalise 				; normalise it.
.25c1	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25c3	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25c5	b0 e3		bcs $25aa			bcs 	_CNTSDecimal 				; keep going.
.25c7					_CNTSExit:
.25c7	7a		ply				ply
.25c8	fa		plx				plx
.25c9	60		rts				rts
.25ca					MakePlusTwoString:
.25ca	da		phx				phx
.25cb	20 6b 26	jsr $266b			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25ce	e8		inx				inx 								; access it
.25cf	e8		inx				inx
.25d0	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart 			; make it an integer
.25d3	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25d5	20 07 26	jsr $2607			jsr 	ConvertInt32
.25d8	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25da					_MPTSCopy:
.25da	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25dd	20 e8 25	jsr $25e8			jsr 	WriteDecimalBuffer
.25e0	e8		inx				inx
.25e1	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25e4	d0 f4		bne $25da			bne 	_MPTSCopy
.25e6	fa		plx				plx
.25e7	60		rts				rts
.25e8					WriteDecimalBuffer:
.25e8	da		phx				phx
.25e9	ae 97 05	ldx $0597			ldx 	dbOffset
.25ec	9d 98 05	sta $0598,x			sta 	decimalBuffer,x
.25ef	9e 99 05	stz $0599,x			stz 	decimalBuffer+1,x
.25f2	ee 97 05	inc $0597			inc 	dbOffset
.25f5	fa		plx				plx
.25f6	60		rts				rts
.0596					decimalPlaces:
>0596							.fill 	1
.0597					dbOffset:
>0597							.fill 	1
.0598					decimalBuffer:
>0598							.fill 	32
.25f7					ConvertInt16:
.25f7	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.25f9	86 4a		stx $4a				stx 	NSMantissa1
.25fb	64 56		stz $56				stz 	NSMantissa2
.25fd	64 62		stz $62				stz 	NSMantissa3
.25ff	64 32		stz $32				stz 	NSStatus 					; positive integer
.2601	a2 00		ldx #$00			ldx 	#0 							; stack level
.2603	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.2605	80 00		bra $2607			bra 	ConvertInt32
.2607					ConvertInt32:
.2607	5a		phy				phy
.2608	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.260a	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.260c	10 08		bpl $2616			bpl 	_CI32NotNeg
.260e	48		pha				pha
.260f	a9 2d		lda #$2d			lda 	#'-'
.2611	99 71 05	sta $0571,y			sta 	numberBuffer,y
.2614	c8		iny				iny
.2615	68		pla				pla
.2616					_CI32NotNeg:
.2616	20 24 26	jsr $2624			jsr 	_CI32DivideConvert 			; recursive conversion
.2619	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.261b	99 71 05	sta $0571,y			sta 	numberBuffer,y
.261e	7a		ply				ply
.261f	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.2621	a9 71		lda #$71			lda 	#numberBuffer & $FF
.2623	60		rts				rts
.2624					_CI32DivideConvert:
.2624	e8		inx				inx 								; write to next slot up
.2625	20 8a 26	jsr $268a			jsr 	FloatSetByte 		 		; write the base out.
.2628	ca		dex				dex
.2629	20 1e 22	jsr $221e			jsr 	Int32Divide 				; divide
.262c	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.262e	48		pha				pha
.262f	20 0d 22	jsr $220d			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2632	20 aa 26	jsr $26aa			jsr 	FloatIsZero 				; is it zero ?
.2635	f0 05		beq $263c			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2637	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2639	20 24 26	jsr $2624			jsr 	_CI32DivideConvert 			; and recusrively call.
.263c					_CI32NoRecurse:
.263c	68		pla				pla 								; remainder
.263d	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.263f	90 02		bcc $2643			bcc 	_CI32NotHex
.2641	69 26		adc #$26			adc 	#6+32
.2643					_CI32NotHex:
.2643	69 30		adc #$30			adc 	#48
.2645	99 71 05	sta $0571,y			sta 	numberBuffer,y 				; write out and exit
.2648	c8		iny				iny
.2649	60		rts				rts
.264a					FloatNegate:
.264a	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.264c	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.264e	95 32		sta $32,x			sta 	NSStatus,x
.2650	60		rts				rts
.2651					FloatNegateMantissa:
.2651	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2652	a9 00		lda #$00			lda 	#0
.2654	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2656	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2658	a9 00		lda #$00			lda 	#0
.265a	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.265c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.265e	a9 00		lda #$00			lda 	#0
.2660	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.2662	95 56		sta $56,x			sta 	NSMantissa2,x
.2664	a9 00		lda #$00			lda 	#0
.2666	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2668	95 62		sta $62,x			sta 	NSMantissa3,x
.266a	60		rts				rts
.266b					FloatShiftUpTwo:
.266b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.266d	95 40		sta $40,x			sta 	NSMantissa0+2,x
.266f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2671	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2673	b5 56		lda $56,x			lda 	NSMantissa2,x
.2675	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2677	b5 62		lda $62,x			lda 	NSMantissa3,x
.2679	95 64		sta $64,x			sta 	NSMantissa3+2,x
.267b	b5 6e		lda $6e,x			lda 	NSExponent,x
.267d	95 70		sta $70,x			sta 	NSExponent+2,x
.267f	b5 32		lda $32,x			lda 	NSStatus,x
.2681	95 34		sta $34,x			sta 	NSStatus+2,x
.2683	60		rts				rts
.2684					FloatSetZeroMantissaOnly:
.2684	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2686	80 08		bra $2690			bra 	FloatZero13
.2688					FloatSetZero:
.2688	a9 00		lda #$00			lda 	#0
.268a					FloatSetByte:
.268a	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.268c					FloatSetMantissa:
.268c	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.268e	74 32		stz $32,x			stz 	NSStatus,x
.2690					FloatZero13:
.2690	74 4a		stz $4a,x			stz 	NSMantissa1,x
.2692	74 56		stz $56,x			stz 	NSMantissa2,x
.2694	74 62		stz $62,x			stz 	NSMantissa3,x
.2696	60		rts				rts
.2697					FloatShiftLeft:
.2697	18		clc				clc
.2698					FloatRotateLeft:
.2698	36 3e		rol $3e,x			rol 	NSMantissa0,x
.269a	36 4a		rol $4a,x			rol		NSMantissa1,x
.269c	36 56		rol $56,x			rol		NSMantissa2,x
.269e	36 62		rol $62,x			rol		NSMantissa3,x
.26a0	60		rts				rts
.26a1					FloatShiftRight:
.26a1	56 62		lsr $62,x			lsr 	NSMantissa3,x
.26a3	76 56		ror $56,x			ror		NSMantissa2,x
.26a5	76 4a		ror $4a,x			ror		NSMantissa1,x
.26a7	76 3e		ror $3e,x			ror		NSMantissa0,x
.26a9	60		rts				rts
.26aa					FloatIsZero:
.26aa	b5 62		lda $62,x			lda 	NSMantissa3,x
.26ac	15 56		ora $56,x			ora		NSMantissa2,x
.26ae	15 4a		ora $4a,x			ora		NSMantissa1,x
.26b0	15 3e		ora $3e,x			ora		NSMantissa0,x
.26b2	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.26b3					FloatArcTan:
.26b3	20 dd 23	jsr $23dd			jsr 	FloatNormalise 					; normalise x
.26b6	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.26b8	48		pha				pha
.26b9	74 32		stz $32,x			stz 	NSStatus,x
.26bb	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.26bd	c9 e2		cmp #$e2			cmp 	#$E2
.26bf	90 25		bcc $26e6			bcc 	_UANoFixup
.26c1	8a		txa				txa 									; value in +1
.26c2	a8		tay				tay
.26c3	c8		iny				iny
.26c4	20 6c 28	jsr $286c			jsr 	CopyFloatXY
.26c7	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.26c9	20 8a 26	jsr $268a			jsr 	FloatSetByte
.26cc	e8		inx				inx
.26cd	20 d1 21	jsr $21d1			jsr 	FloatDivide
.26d0	b0 21		bcs $26f3			bcs 	_FATError
.26d2	20 f6 26	jsr $26f6			jsr 	CoreAtn 						; calculate the root
.26d5	20 61 28	jsr $2861			jsr 	CompletePolynomial
.26d8	20 4a 26	jsr $264a			jsr 	FloatNegate 					; make -ve
.26db	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.26dd	20 b8 28	jsr $28b8			jsr 	LoadConstant
.26e0	e8		inx				inx
.26e1	20 ac 20	jsr $20ac			jsr 	FloatAdd
.26e4	80 06		bra $26ec			bra 	_UAComplete
.26e6					_UANoFixup:
.26e6	20 f6 26	jsr $26f6			jsr 	CoreAtn
.26e9	20 61 28	jsr $2861			jsr 	CompletePolynomial
.26ec					_UAComplete:
.26ec	68		pla				pla 									; apply the result.
.26ed	55 32		eor $32,x			eor 	NSStatus,x
.26ef	95 32		sta $32,x			sta 	NSStatus,x
.26f1	18		clc				clc
.26f2	60		rts				rts
.26f3					_FATError:
.26f3	68		pla				pla
.26f4	38		sec				sec
.26f5	60		rts				rts
.26f6					CoreAtn:
.26f6	a9 64		lda #$64			lda 	#AtnCoefficients & $FF
.26f8	a0 27		ldy #$27			ldy 	#AtnCoefficients >> 8
.26fa	4c b5 29	jmp $29b5			jmp 	CorePolySquared
.26fd					ExpCoefficients:
>26fd	07					.byte	7
>26fe	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>2702	d2					.byte	$d2
>2703	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>2707	d5					.byte	$d5
>2708	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>270c	d8					.byte	$d8
>270d	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>2711	db					.byte	$db
>2712	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>2716	dd					.byte	$dd
>2717	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>271b	df					.byte	$df
>271c	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>2720	e1					.byte	$e1
>2721	00 00 00 40				.dword	$40000000 ; 1.0
>2725	e2					.byte	$e2
.2726					SinCoefficients:
>2726	06					.byte	6
>2727	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>272b	e5					.byte	$e5
>272c	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>2730	e7					.byte	$e7
>2731	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>2735	e8					.byte	$e8
>2736	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>273a	e8					.byte	$e8
>273b	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>273f	e7					.byte	$e7
>2740	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>2744	e4					.byte	$e4
>2745	00 00 00 00				.dword	$00000000 ; 0.0
>2749	00					.byte	$00
.274a					LogCoefficients:
>274a	04					.byte	4
>274b	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>274f	e0					.byte	$e0
>2750	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>2754	e1					.byte	$e1
>2755	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>2759	e1					.byte	$e1
>275a	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>275e	e3					.byte	$e3
>275f	00 00 00 c0				.dword	$c0000000 ; -0.5
>2763	e1					.byte	$e1
.2764					AtnCoefficients:
>2764	0c					.byte	12
>2765	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2769	d7					.byte	$d7
>276a	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>276e	da					.byte	$da
>276f	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>2773	dc					.byte	$dc
>2774	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2778	dd					.byte	$dd
>2779	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>277d	dd					.byte	$dd
>277e	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>2782	de					.byte	$de
>2783	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2787	de					.byte	$de
>2788	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>278c	de					.byte	$de
>278d	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>2791	df					.byte	$df
>2792	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>2796	df					.byte	$df
>2797	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>279b	e0					.byte	$e0
>279c	00 00 00 40				.dword	$40000000 ; 1.0
>27a0	e2					.byte	$e2
>27a1	00 00 00 00				.dword	$00000000 ; 0.0
>27a5	00					.byte	$00
.27a6					Const_Base:
.27a6					Const_1Div2Pi:
>27a6	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>27aa	df					.byte	$df
.27ab					Const_PiDiv2:
>27ab	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>27af	e2					.byte	$e2
.27b0					Const_Log2_e:
>27b0	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>27b4	e2					.byte	$e2
.27b5					Const_sqrt_2:
>27b5	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>27b9	e2					.byte	$e2
.27ba					Const_sqrt_half:
>27ba	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>27be	e1					.byte	$e1
.27bf					Const_pi:
>27bf	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>27c3	e3					.byte	$e3
.27c4					Const_half:
>27c4	00 00 00 40				.dword	$40000000 ; 0.50000000
>27c8	e1					.byte	$e1
.27c9					Const_ln_e:
>27c9	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>27cd	e1					.byte	$e1
.27ce					FloatCosine:
.27ce	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.27d0	20 b8 28	jsr $28b8			jsr 	LoadConstant
.27d3	e8		inx				inx
.27d4	20 ac 20	jsr $20ac			jsr 	FloatAdd
.27d7	4c 6e 29	jmp $296e			jmp 	FloatSine
.27da					FloatExponent:
.27da	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.27dc	20 b8 28	jsr $28b8			jsr 	LoadConstant
.27df	e8		inx				inx
.27e0	20 48 23	jsr $2348			jsr 	FloatMultiply
.27e3	20 25 28	jsr $2825			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.27e6	e8		inx				inx
.27e7	20 c3 22	jsr $22c3			jsr 	FloatIntegerPart
.27ea	ca		dex				dex
.27eb	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.27ed	15 57		ora $57,x			ora 	NSMantissa2+1,x
.27ef	15 63		ora $63,x			ora 	NSMantissa3+1,x
.27f1	d0 38		bne $282b			bne 	_UERangeError
.27f3	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.27f5	c9 40		cmp #$40			cmp 	#64
.27f7	b0 32		bcs $282b			bcs 	_UERangeError
.27f9	48		pha				pha
.27fa	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.27fc	48		pha				pha
.27fd	20 68 22	jsr $2268			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.2800	68		pla				pla
.2801	10 14		bpl $2817			bpl 	_UEPositive
.2803	e8		inx				inx 							; 1-x
.2804	a9 01		lda #$01			lda 	#1
.2806	20 8a 26	jsr $268a			jsr 	FloatSetByte
.2809	ca		dex				dex
.280a	20 4a 26	jsr $264a			jsr 	FloatNegate
.280d	e8		inx				inx
.280e	20 ac 20	jsr $20ac			jsr 	FloatAdd
.2811	68		pla				pla 							; integer part +1 and negated.
.2812	1a		inc a				inc 	a
.2813	49 ff		eor #$ff			eor 	#$FF
.2815	1a		inc a				inc 	a
.2816	48		pha				pha
.2817					_UEPositive:
.2817	20 2d 28	jsr $282d			jsr 	CoreExponent
.281a	20 61 28	jsr $2861			jsr 	CompletePolynomial
.281d	68		pla				pla
.281e	18		clc				clc
.281f	75 6e		adc $6e,x			adc 	NSExponent,x
.2821	95 6e		sta $6e,x			sta 	NSExponent,x
.2823	18		clc				clc
.2824	60		rts				rts
.2825					_UECopy01:
.2825	8a		txa				txa
.2826	a8		tay				tay
.2827	c8		iny				iny
.2828	4c 6c 28	jmp $286c			jmp 	CopyFloatXY
.282b					_UERangeError:
.282b	38		sec				sec
.282c	60		rts				rts
.282d					CoreExponent:
.282d	a9 fd		lda #$fd			lda 	#ExpCoefficients & $FF
.282f	a0 26		ldy #$26			ldy 	#ExpCoefficients >> 8
.2831	20 35 28	jsr $2835			jsr 	CalculateHornerPolynomial
.2834	60		rts				rts
.2835					CalculateHornerPolynomial:
.2835	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.2837	84 2d		sty $2d				sty 	zTemp0+1
.2839	9c b8 05	stz $05b8			stz 	coefficientCount 			; zero the count.
.283c	8e b9 05	stx $05b9			stx 	xValueSlot 					; save xValue slot.
.283f	e8		inx				inx 								; set the count to zero.
.2840	20 88 26	jsr $2688			jsr 	FloatSetZero
.2843					_CHPLoop:
.2843	8a		txa				txa 								; copy X-1 to X+1
.2844	a8		tay				tay
.2845	ca		dex				dex
.2846	c8		iny				iny
.2847	20 6c 28	jsr $286c			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.284a	e8		inx				inx
.284b	e8		inx				inx
.284c	20 48 23	jsr $2348			jsr 	FloatMultiply 				; times current by X
.284f	e8		inx				inx
.2850	20 8b 28	jsr $288b			jsr 	GetCoefficient 				; coefficient into X+1
.2853	20 ac 20	jsr $20ac			jsr 	FloatAdd 					; and add
.2856	ee b8 05	inc $05b8			inc 	coefficientCount
.2859	ad b8 05	lda $05b8			lda 	coefficientCount
.285c	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.285e	d0 e3		bne $2843			bne 	_CHPLoop
.2860	60		rts				rts
.2861					CompletePolynomial:
.2861	20 48 23	jsr $2348			jsr 	FloatMultiply
.2864	e8		inx				inx 								; get the last value
.2865	20 8b 28	jsr $288b			jsr 	GetCoefficient
.2868	20 ac 20	jsr $20ac			jsr 	FloatAdd 					; and add it
.286b	60		rts				rts
.286c					CopyFloatXY:
.286c	b5 6e		lda $6e,x			lda 	NSExponent,x
.286e	99 6e 00	sta $006e,y			sta 	NSExponent,y
.2871	b5 32		lda $32,x			lda 	NSStatus,x
.2873	99 32 00	sta $0032,y			sta 	NSStatus,y
.2876	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2878	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.287b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.287d	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.2880	b5 56		lda $56,x			lda 	NSMantissa2,x
.2882	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.2885	b5 62		lda $62,x			lda 	NSMantissa3,x
.2887	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.288a	60		rts				rts
.288b					GetCoefficient:
.288b	5a		phy				phy
.288c	ad b8 05	lda $05b8			lda 	coefficientCount 			; 5 per block
.288f	0a		asl a				asl 	a
.2890	0a		asl a				asl 	a
.2891	38		sec				sec 								; +1 for count
.2892	6d b8 05	adc $05b8			adc 	coefficientCount
.2895	a8		tay				tay
.2896	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.2898	95 3e		sta $3e,x			sta 	NSMantissa0,x
.289a	c8		iny				iny
.289b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.289d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.289f	c8		iny				iny
.28a0	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28a2	95 56		sta $56,x			sta 	NSMantissa2,x
.28a4	c8		iny				iny
.28a5	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28a7	48		pha				pha
.28a8	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.28aa	95 62		sta $62,x			sta 	NSMantissa3,x
.28ac	c8		iny				iny
.28ad	68		pla				pla
.28ae	29 80		and #$80			and 	#$80
.28b0	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.28b2	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28b4	95 6e		sta $6e,x			sta 	NSExponent,x
.28b6	7a		ply				ply
.28b7	60		rts				rts
.05b8					coefficientCount:
>05b8							.fill 	1
.05b9					xValueSlot:
>05b9							.fill 	1
.28b8					LoadConstant:
.28b8	5a		phy				phy
.28b9	a8		tay				tay
.28ba	b9 a6 27	lda $27a6,y			lda 	Const_Base+0,y
.28bd	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.28bf	b9 a7 27	lda $27a7,y			lda 	Const_Base+1,y
.28c2	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.28c4	b9 a8 27	lda $27a8,y			lda 	Const_Base+2,y
.28c7	95 57		sta $57,x			sta 	NSMantissa2+1,x
.28c9	b9 a9 27	lda $27a9,y			lda 	Const_Base+3,y
.28cc	48		pha				pha
.28cd	29 7f		and #$7f			and 	#$7F
.28cf	95 63		sta $63,x			sta 	NSMantissa3+1,x
.28d1	68		pla				pla
.28d2	29 80		and #$80			and 	#$80
.28d4	95 33		sta $33,x			sta 	NSStatus+1,x
.28d6	b9 aa 27	lda $27aa,y			lda 	Const_Base+4,y
.28d9	95 6f		sta $6f,x			sta 	NSExponent+1,x
.28db	7a		ply				ply
.28dc	60		rts				rts
.28dd					FloatLogarithm:
.28dd	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.28df	30 5f		bmi $2940			bmi 	_ULRange
.28e1	20 aa 26	jsr $26aa			jsr 	FloatIsZero
.28e4	f0 5a		beq $2940			beq 	_ULRange
.28e6	20 dd 23	jsr $23dd			jsr 	FloatNormalise 				; put into FP mode.
.28e9	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.28eb	48		pha				pha
.28ec	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.28ee	95 6e		sta $6e,x			sta 	NSExponent,x
.28f0	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.28f2	20 b8 28	jsr $28b8			jsr 	LoadConstant
.28f5	e8		inx				inx
.28f6	20 ac 20	jsr $20ac			jsr 	FloatAdd
.28f9	8a		txa				txa 								; divide into sqrt 2.0
.28fa	a8		tay				tay
.28fb	c8		iny				iny
.28fc	20 6c 28	jsr $286c			jsr 	CopyFloatXY
.28ff	ca		dex				dex
.2900	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.2902	20 b8 28	jsr $28b8			jsr 	LoadConstant
.2905	e8		inx				inx
.2906	e8		inx				inx
.2907	20 d1 21	jsr $21d1			jsr 	FloatDivide 				; if zero, error.
.290a	b0 33		bcs $293f			bcs 	_ULRangePla
.290c	20 4a 26	jsr $264a			jsr 	FloatNegate 				; subtract from 1
.290f	e8		inx				inx
.2910	a9 01		lda #$01			lda 	#1
.2912	20 8a 26	jsr $268a			jsr 	FloatSetByte
.2915	20 ac 20	jsr $20ac			jsr 	FloatAdd
.2918	20 42 29	jsr $2942			jsr 	CoreLog
.291b	20 61 28	jsr $2861			jsr 	CompletePolynomial
.291e	68		pla				pla 								; add exponent
.291f	18		clc				clc
.2920	69 1f		adc #$1f			adc 	#31 						; fix up
.2922	48		pha				pha
.2923	10 03		bpl $2928			bpl 	_LogNotNeg
.2925	49 ff		eor #$ff			eor 	#$FF
.2927	1a		inc a				inc 	a
.2928					_LogNotNeg:
.2928	e8		inx				inx 								; set byte and sign.
.2929	20 8a 26	jsr $268a			jsr 	FloatSetByte
.292c	68		pla				pla
.292d	29 80		and #$80			and 	#$80
.292f	95 32		sta $32,x			sta 	NSStatus,x
.2931	20 ac 20	jsr $20ac			jsr 	FloatAdd
.2934	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.2936	20 b8 28	jsr $28b8			jsr 	LoadConstant
.2939	e8		inx				inx
.293a	20 48 23	jsr $2348			jsr 	FloatMultiply
.293d	18		clc				clc
.293e	60		rts				rts
.293f					_ULRangePla:
.293f	68		pla				pla
.2940					_ULRange:
.2940	38		sec				sec
.2941	60		rts				rts
.2942					CoreLog:
.2942	a9 4a		lda #$4a			lda 	#LogCoefficients & $FF
.2944	a0 27		ldy #$27			ldy 	#LogCoefficients >> 8
.2946	4c b5 29	jmp $29b5			jmp 	CorePolySquared
.2949					FloatPI:
.2949	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.294b	20 b8 28	jsr $28b8			jsr 	LoadConstant
.294e	e8		inx				inx
.294f	18		clc				clc
.2950	60		rts				rts
.2951					FloatPower:
.2951	ca		dex				dex
.2952	8a		txa				txa 							; copy 0 to 2, so we can process it
.2953	a8		tay				tay
.2954	c8		iny				iny
.2955	c8		iny				iny
.2956	20 6c 28	jsr $286c			jsr 	CopyFloatXY
.2959	e8		inx				inx 							; 2 = Log(0)
.295a	e8		inx				inx
.295b	20 dd 28	jsr $28dd			jsr 	FloatLogarithm
.295e	b0 0d		bcs $296d			bcs 	_FPWExit
.2960	20 48 23	jsr $2348			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.2963	8a		txa				txa 							; copy to slot 0
.2964	a8		tay				tay
.2965	88		dey				dey
.2966	20 6c 28	jsr $286c			jsr 	CopyFloatXY
.2969	ca		dex				dex  							; Exponent code.
.296a	20 da 27	jsr $27da			jsr 	FloatExponent
.296d					_FPWExit:
.296d	60		rts				rts
.296e					FloatSine:
.296e	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.2970	48		pha				pha
.2971	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.2973	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.2975	20 b8 28	jsr $28b8			jsr 	LoadConstant
.2978	e8		inx				inx
.2979	20 48 23	jsr $2348			jsr 	FloatMultiply
.297c	20 68 22	jsr $2268			jsr 	FloatFractionalPart 		; take the fractional part
.297f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.2981	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.2983	90 1f		bcc $29a4			bcc 	_USProcessExit
.2985	f0 06		beq $298d			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.2987	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.2989	c9 60		cmp #$60			cmp 	#$60
.298b	b0 0e		bcs $299b			bcs 	_USSubtractOne
.298d					_USSubtractFromHalf:
.298d	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.298f	20 b8 28	jsr $28b8			jsr 	LoadConstant
.2992	e8		inx				inx
.2993	20 a6 20	jsr $20a6			jsr 	FloatSubtract
.2996	20 4a 26	jsr $264a			jsr 	FloatNegate 				; then negate it
.2999	80 09		bra $29a4			bra 	_USProcessExit 				; and exit
.299b					_USSubtractOne:
.299b	e8		inx				inx
.299c	a9 01		lda #$01			lda 	#1
.299e	20 8a 26	jsr $268a			jsr 	FloatSetByte
.29a1	20 a6 20	jsr $20a6			jsr 	FloatSubtract
.29a4					_USProcessExit:
.29a4	20 b1 29	jsr $29b1			jsr 	CoreSine
.29a7	20 61 28	jsr $2861			jsr 	CompletePolynomial
.29aa	68		pla				pla 								; restore sign and apply
.29ab	55 32		eor $32,x			eor 	NSStatus,x
.29ad	95 32		sta $32,x			sta 	NSStatus,x
.29af	18		clc				clc
.29b0	60		rts				rts
.29b1					CoreSine:
.29b1	a9 26		lda #$26			lda 	#SinCoefficients & $FF
.29b3	a0 27		ldy #$27			ldy 	#SinCoefficients >> 8
.29b5					CorePolySquared:
.29b5	48		pha				pha 								; save coefficient table
.29b6	5a		phy				phy
.29b7	8a		txa				txa 								; copy X to +1, +2
.29b8	a8		tay				tay
.29b9	c8		iny				iny
.29ba	20 6c 28	jsr $286c			jsr 	CopyFloatXY
.29bd	c8		iny				iny
.29be	20 6c 28	jsr $286c			jsr 	CopyFloatXY
.29c1	e8		inx				inx 								; point to the pair and put x^2 on stack
.29c2	e8		inx				inx
.29c3	20 48 23	jsr $2348			jsr 	FloatMultiply
.29c6	7a		ply				ply 								; coefficient table back.
.29c7	68		pla				pla
.29c8	20 35 28	jsr $2835			jsr 	CalculateHornerPolynomial
.29cb	8a		txa				txa 								; copy back to slot #1
.29cc	a8		tay				tay
.29cd	88		dey				dey
.29ce	20 6c 28	jsr $286c			jsr	 	CopyFloatXY
.29d1	ca		dex				dex 								; point at result
.29d2	60		rts				rts
.29d3					FloatSquareRoot:
.29d3	20 dd 28	jsr $28dd			jsr 	FloatLogarithm
.29d6	b0 06		bcs $29de			bcs 	_FSQExit
.29d8	d6 6e		dec $6e,x			dec 	NSExponent,x
.29da	20 da 27	jsr $27da			jsr 	FloatExponent
.29dd	18		clc				clc
.29de					_FSQExit:
.29de	60		rts				rts
.29df					FloatTangent:
.29df	da		phx				phx
.29e0	8a		txa				txa 								; sin -> +1
.29e1	a8		tay				tay
.29e2	c8		iny				iny
.29e3	20 6c 28	jsr $286c			jsr 	CopyFloatXY
.29e6	e8		inx				inx
.29e7	20 6e 29	jsr $296e			jsr 	FloatSine
.29ea	ca		dex				dex
.29eb	8a		txa				txa 								; cos -> +2
.29ec	a8		tay				tay
.29ed	c8		iny				iny
.29ee	c8		iny				iny
.29ef	20 6c 28	jsr $286c			jsr 	CopyFloatXY
.29f2	e8		inx				inx
.29f3	e8		inx				inx
.29f4	20 ce 27	jsr $27ce			jsr 	FloatCosine
.29f7	20 d1 21	jsr $21d1			jsr 	FloatDivide 				; calculate sin/cos
.29fa	b0 07		bcs $2a03			bcs 	_FTExit 					; divide by zero
.29fc	8a		txa				txa 								; copy result down.
.29fd	a8		tay				tay
.29fe	88		dey				dey
.29ff	20 6c 28	jsr $286c			jsr 	CopyFloatXY
.2a02	18		clc				clc
.2a03					_FTExit:
.2a03	fa		plx				plx
.2a04	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.007a					srcPtr:
>007a							.fill 	2
.05ba					currentLineNumber:
>05ba							.fill 	2
.2a05					InlineNonDecimal:
.2a05	a2 02		ldx #$02			ldx 	#2 							; get size in X
.2a07	c9 25		cmp #$25			cmp 	#"%"
.2a09	f0 02		beq $2a0d			beq 	_INDBinary
.2a0b	a2 10		ldx #$10			ldx 	#16
.2a0d					_INDBinary:
.2a0d	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.2a0f	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.2a11	64 2c		stz $2c				stz 	zTemp0 						; zero result
.2a13	64 2d		stz $2d				stz 	zTemp0+1
.2a15					_INDLoop:
.2a15	20 bf 33	jsr $33bf			jsr 	LookNext 					; check next character
.2a18	20 fb 33	jsr $33fb			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.2a1b	90 1f		bcc $2a3c			bcc		_INDDone 					; didn't convert
.2a1d	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.2a1f	b0 1b		bcs $2a3c			bcs 	_INDDone
.2a21	20 4b 2a	jsr $2a4b			jsr 	_INDShift 					; x 2 or x 16
.2a24	e0 02		cpx #$02			cpx 	#2
.2a26	f0 09		beq $2a31			beq 	_INDNotHex
.2a28	20 4b 2a	jsr $2a4b			jsr 	_INDShift
.2a2b	20 4b 2a	jsr $2a4b			jsr 	_INDShift
.2a2e	20 4b 2a	jsr $2a4b			jsr 	_INDShift
.2a31					_INDNotHex:
.2a31	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.2a33	85 2c		sta $2c				sta 	zTemp0
.2a35	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume
.2a38	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.2a3a	80 d9		bra $2a15			bra 	_INDLoop
.2a3c					_INDDone:
.2a3c	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.2a3e	f0 08		beq $2a48			beq 	_INDError
.2a40	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.2a42	a5 2c		lda $2c				lda 	zTemp0
.2a44	20 6d 2b	jsr $2b6d			jsr 	PushIntegerYA
.2a47	60		rts				rts
.2a48					_INDError:
.2a48	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.2a4b					_INDShift:
.2a4b	06 2c		asl $2c				asl 	zTemp0
.2a4d	26 2d		rol $2d				rol 	zTemp0+1
.2a4f	60		rts				rts
.2a50					GetLineNumber:
.2a50	ac bb 05	ldy $05bb			ldy 	currentLineNumber+1
.2a53	ad ba 05	lda $05ba			lda 	currentLineNumber
.2a56	60		rts				rts
.2a57					WriteCodeByte:
.2a57	48		pha				pha 								; save on stack
.2a58	da		phx				phx
.2a59	5a		phy				phy
.2a5a	aa		tax				tax
.2a5b	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.2a5d	20 6a 2b	jsr $2b6a			jsr 	CallAPIHandler
.2a60	7a		ply				ply 								; restore from stack
.2a61	fa		plx				plx
.2a62	68		pla				pla
.2a63	60		rts				rts
.2a64					PrintCharacter
.2a64	48		pha				pha
.2a65	da		phx				phx
.2a66	5a		phy				phy
.2a67	aa		tax				tax
.2a68	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.2a6a	20 6a 2b	jsr $2b6a			jsr 	CallAPIHandler
.2a6d	7a		ply				ply
.2a6e	fa		plx				plx
.2a6f	68		pla				pla
.2a70	60		rts				rts
.2a71					ProcessNewLine:
.2a71	86 2c		stx $2c				stx 	zTemp0 						; save address in zTemp0
.2a73	84 2d		sty $2d				sty 	zTemp0+1
.2a75	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.2a76	8a		txa				txa
.2a77	69 04		adc #$04			adc 	#4
.2a79	85 7a		sta $7a				sta 	srcPtr
.2a7b	98		tya				tya
.2a7c	69 00		adc #$00			adc 	#0
.2a7e	85 7b		sta $7b				sta 	srcPtr+1
.2a80	a0 02		ldy #$02			ldy 	#2							; read and save line number
.2a82	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a84	8d ba 05	sta $05ba			sta 	currentLineNumber
.2a87	c8		iny				iny
.2a88	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a8a	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2a8d	60		rts				rts
.2a8e					BufferClear:
.2a8e	9c bc 05	stz $05bc			stz 	bufferSize
.2a91	60		rts				rts
.2a92					BufferWrite:
.2a92	da		phx				phx
.2a93	ae bc 05	ldx $05bc			ldx 	bufferSize
.2a96	9d bd 05	sta $05bd,x			sta 	dataBuffer,x
.2a99	ee bc 05	inc $05bc			inc 	bufferSize
.2a9c	fa		plx				plx
.2a9d	60		rts				rts
.2a9e					BufferOutput:
.2a9e	ad bc 05	lda $05bc			lda 	bufferSize
.2aa1	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2aa4	a2 00		ldx #$00			ldx 	#0
.2aa6					_BOLoop:
.2aa6	ec bc 05	cpx $05bc			cpx 	bufferSize
.2aa9	f0 09		beq $2ab4			beq 	_BOExit
.2aab	bd bd 05	lda $05bd,x			lda 	dataBuffer,x
.2aae	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2ab1	e8		inx				inx
.2ab2	80 f2		bra $2aa6			bra 	_BOLoop
.2ab4					_BOExit:
.2ab4	60		rts				rts
.05bc					bufferSize:
>05bc							.fill 	1
.05bd					dataBuffer:
>05bd							.fill 	256
.2ab5					CheckNextComma:
.2ab5	a9 2c		lda #$2c			lda	 	#","
.2ab7	80 06		bra $2abf			bra 	CheckNextA
.2ab9					CheckNextRParen:
.2ab9	a9 29		lda #$29			lda	 	#")"
.2abb	80 02		bra $2abf			bra 	CheckNextA
.2abd					CheckNextLParen:
.2abd	a9 28		lda #$28			lda 	#"("
.2abf					CheckNextA:
.2abf	8d bd 06	sta $06bd			sta 	checkCharacter 				; save test character
.2ac2					_CNALoop:
.2ac2	20 db 33	jsr $33db			jsr 	GetNextNonSpace 			; get next skipping spaces.
.2ac5	cd bd 06	cmp $06bd			cmp 	checkCharacter 				; matches ?
.2ac8	f0 03		beq $2acd			beq 	_CNAExit
.2aca	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.2acd					_CNAExit:
.2acd	60		rts				rts
.06bd					checkCharacter:
>06bd							.fill 	1
.2ace					StartCompiler:
.2ace	86 2c		stx $2c				stx 	zTemp0 						; access API
.2ad0	84 2d		sty $2d				sty 	zTemp0+1
.2ad2	a0 2d		ldy #$2d			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.2ad4	a2 26		ldx #$26			ldx 	#CompilerErrorHandler & $FF
.2ad6	20 09 1f	jsr $1f09			jsr 	SetErrorHandler
.2ad9	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.2adb	b2 2c		lda ($2c)			lda 	(zTemp0)
.2add	8d bf 06	sta $06bf			sta 	APIVector
.2ae0	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ae2	8d c0 06	sta $06c0			sta 	APIVector+1
.2ae5	c8		iny				iny 								; copy data area range.
.2ae6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ae8	8d c1 06	sta $06c1			sta 	compilerStartHigh
.2aeb	c8		iny				iny
.2aec	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2aee	8d c2 06	sta $06c2			sta 	compilerEndHigh
.2af1	ba		tsx				tsx 								; save stack pointer
.2af2	8e be 06	stx $06be			stx 	compilerSP
.2af5	20 5f 37	jsr $375f			jsr 	STRReset 					; reset storage (line#, variable)
.2af8	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.2afa	20 6a 2b	jsr $2b6a			jsr 	CallAPIHandler
.2afd	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.2aff	20 6a 2b	jsr $2b6a			jsr 	CallAPIHandler
.2b02	a9 d5		lda #$d5			lda 	#PCD_CMD_VARSPACE
.2b04	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2b07	a9 00		lda #$00			lda 	#0
.2b09	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2b0c	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2b0f					MainCompileLoop:
.2b0f	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.2b11	20 6a 2b	jsr $2b6a			jsr 	CallAPIHandler
.2b14	90 31		bcc $2b47			bcc 	SaveCodeAndExit 			; end of source.
.2b16	20 71 2a	jsr $2a71			jsr 	ProcessNewLine 				; set up pointer and line number.
.2b19	20 50 2a	jsr $2a50			jsr 	GetLineNumber 				; get line #
.2b1c	20 49 35	jsr $3549			jsr 	STRMarkLine 				; remember the code position and number of this line.
.2b1f	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.2b21	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2b24					_MCLSameLine:
.2b24	20 db 33	jsr $33db			jsr 	GetNextNonSpace 			; get the first character.
.2b27	f0 e6		beq $2b0f			beq 	MainCompileLoop 			; end of line, get next line.
.2b29	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.2b2b	f0 f7		beq $2b24			beq 	_MCLSameLine
.2b2d	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.2b2f	10 0c		bpl $2b3d			bpl 	_MCLCheckAssignment
.2b31	a2 93		ldx #$93			ldx 	#CommandTables & $FF 		; do command tables.
.2b33	a0 2f		ldy #$2f			ldy 	#CommandTables >> 8
.2b35	20 61 32	jsr $3261			jsr 	GeneratorProcess
.2b38	b0 ea		bcs $2b24			bcs 	_MCLSameLine 				; keep trying to compile the line.
.2b3a					_MCLSyntax:
.2b3a	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.2b3d					_MCLCheckAssignment:
.2b3d	20 f1 33	jsr $33f1			jsr 	CharIsAlpha 				; if not alpha then syntax error
.2b40	90 f8		bcc $2b3a			bcc 	_MCLSyntax
.2b42	20 17 35	jsr $3517			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.2b45	80 dd		bra $2b24			bra		_MCLSameLine 				; loop back.
.2b47					SaveCodeAndExit:
.2b47	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.2b49	20 6a 2b	jsr $2b6a			jsr 	CallAPIHandler
.2b4c	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.2b4e	a8		tay				tay
.2b4f	20 49 35	jsr $3549			jsr 	STRMarkLine
.2b52	a9 c5		lda #$c5			lda 	#PCD_EXIT 					; add an END
.2b54	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2b57	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.2b59	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2b5c	20 83 2e	jsr $2e83			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.2b5f	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.2b61	20 6a 2b	jsr $2b6a			jsr 	CallAPIHandler
.2b64	18		clc				clc 								; CC = success
.2b65					ExitCompiler:
.2b65	ae be 06	ldx $06be			ldx 	compilerSP 					; reload SP and exit.
.2b68	9a		txs				txs
.2b69	60		rts				rts
.2b6a					CallAPIHandler:
.2b6a	6c bf 06	jmp ($06bf)			jmp 	(APIVector)
.06be					compilerSP:
>06be							.fill 	1
.06bf					APIVector:
>06bf							.fill 	2
.06c1					compilerStartHigh:
>06c1							.fill 	1
.06c2					compilerEndHigh:
>06c2							.fill 	1
.2b6d					PushIntegerYA:
.2b6d	c0 00		cpy #$00			cpy 	#0 							; 0-255
.2b6f	f0 0f		beq $2b80			beq 	PushIntegerA
.2b71	48		pha				pha
.2b72	a9 cd		lda #$cd			lda 	#PCD_CMD_WORD 				; send .word
.2b74	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2b77	68		pla				pla 								; then LSB
.2b78	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2b7b	98		tya				tya 								; then MSB
.2b7c	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2b7f	60		rts				rts
.2b80					PushIntegerA:
.2b80	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.2b82	90 07		bcc $2b8b			bcc 	_PIWriteA
.2b84	48		pha				pha
.2b85	a9 cc		lda #$cc			lda 	#PCD_CMD_BYTE 				; send .byte
.2b87	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2b8a	68		pla				pla
.2b8b					_PIWriteA:
.2b8b	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2b8e	60		rts				rts
.2b8f					PushFloatCommand:
.2b8f	a9 ce		lda #$ce			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.2b91	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2b94	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.2b96	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2b99	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2b9b	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2b9e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2ba0	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2ba3	b5 56		lda $56,x			lda 	NSMantissa2,x
.2ba5	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2ba8	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.2baa	29 80		and #$80			and 	#$80
.2bac	15 62		ora $62,x			ora 	NSMantissa3,x
.2bae	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2bb1	60		rts				rts
.2bb2					CreateVariableRecord:
.2bb2	48		pha				pha
.2bb3	ad cd 06	lda $06cd			lda 	freeVariableMemory 		; push current free address on stack.
.2bb6	48		pha				pha
.2bb7	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2bba	48		pha				pha
.2bbb	ad cb 06	lda $06cb			lda 	variableListEnd  		; copy end of list to zTemp0
.2bbe	85 2c		sta $2c				sta 	zTemp0
.2bc0	ad cc 06	lda $06cc			lda 	variableListEnd+1
.2bc3	85 2d		sta $2d				sta 	zTemp0+1
.2bc5	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.2bc7	92 2c		sta ($2c)			sta 	(zTemp0)
.2bc9	98		tya				tya
.2bca	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.2bcc	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bce	88		dey				dey
.2bcf	8a		txa				txa
.2bd0	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bd2	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.2bd4	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2bd7	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bd9	c8		iny				iny
.2bda	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2bdd	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bdf	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.2be1	a9 00		lda #$00			lda 	#0
.2be3	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2be5	18		clc				clc
.2be6	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.2be8	6d cb 06	adc $06cb			adc  	variableListEnd
.2beb	8d cb 06	sta $06cb			sta 	variableListEnd
.2bee	90 03		bcc $2bf3			bcc 	_CVNoCarry2
.2bf0	ee cc 06	inc $06cc			inc 	variableListEnd+1
.2bf3					_CVNoCarry2:
.2bf3	7a		ply				ply
.2bf4	fa		plx				plx
.2bf5	68		pla				pla
.2bf6	60		rts				rts
.2bf7					SetVariableRecordToCodePosition:
.2bf7	48		pha				pha
.2bf8	5a		phy				phy
.2bf9	a0 03		ldy #$03			ldy 	#3
.2bfb	a5 2b		lda $2b				lda 	objPtr+1
.2bfd	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bff	c8		iny				iny
.2c00	a5 2a		lda $2a				lda 	objPtr
.2c02	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2c04	7a		ply				ply
.2c05	68		pla				pla
.2c06	60		rts				rts
.2c07					AllocateBytesForType:
.2c07	48		pha				pha
.2c08	da		phx				phx
.2c09	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.2c0b	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2c0d	c9 00		cmp #$00			cmp 	#NSSIFloat
.2c0f	d0 02		bne $2c13			bne 	_CVNotFloat
.2c11	a2 06		ldx #$06			ldx 	#6
.2c13					_CVNotFloat:
.2c13	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.2c14	18		clc				clc
.2c15	6d cd 06	adc $06cd			adc 	freeVariableMemory
.2c18	8d cd 06	sta $06cd			sta 	freeVariableMemory
.2c1b	90 03		bcc $2c20			bcc 	_CVNoCarry1
.2c1d	ee ce 06	inc $06ce			inc 	freeVariableMemory+1
.2c20					_CVNoCarry1:
.2c20	fa		plx				plx
.2c21	68		pla				pla
.2c22	60		rts				rts
.2c23					CommandDATA:
.2c23	20 8e 2a	jsr $2a8e			jsr 	BufferClear 				; copy it to the buffer
.2c26	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace
.2c29					_CTDataLoop:
.2c29	20 bf 33	jsr $33bf			jsr 	LookNext 					; reached EOL
.2c2c	f0 08		beq $2c36			beq 	_CTDataDone
.2c2e	20 92 2a	jsr $2a92			jsr 	BufferWrite 				; write and consume
.2c31	20 d0 33	jsr $33d0			jsr 	GetNext
.2c34	80 f3		bra $2c29			bra 	_CTDataLoop
.2c36					_CTDataDone:
.2c36	a9 d0		lda #$d0			lda 	#PCD_CMD_DATA 				; output command and buffer
.2c38	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2c3b	20 9e 2a	jsr $2a9e			jsr 	BufferOutput
.2c3e	60		rts				rts
.2c3f					CommandDEF:
.2c3f	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.2c41	20 80 2b	jsr $2b80			jsr 	PushIntegerA
.2c44	20 e0 34	jsr $34e0			jsr 	CompileGotoEOL 				; compile skip over DEF
.2c47	a9 a5		lda #$a5			lda 	#C64_FN
.2c49	20 bf 2a	jsr $2abf			jsr 	CheckNextA
.2c4c	20 db 33	jsr $33db			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2c4f	20 40 34	jsr $3440			jsr 	ExtractVariableName
.2c52	8a		txa				txa
.2c53	10 51		bpl $2ca6			bpl 	_CDError
.2c55	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2c56	29 7f		and #$7f			and 	#$7F
.2c58	aa		tax				tax
.2c59	98		tya				tya
.2c5a	09 80		ora #$80			ora 	#$80
.2c5c	a8		tay				tay
.2c5d	20 27 2e	jsr $2e27			jsr 	FindVariable				; does it already exist ?
.2c60	b0 44		bcs $2ca6			bcs 	_CDError 					; if so, that's an error.
.2c62	20 b2 2b	jsr $2bb2			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.2c65	20 f7 2b	jsr $2bf7			jsr 	SetVariableRecordToCodePosition
.2c68	20 db 33	jsr $33db			jsr 	GetNextNonSpace
.2c6b	20 1c 37	jsr $371c			jsr 	GetReferenceTerm 			; get var ref, not array
.2c6e	c9 00		cmp #$00			cmp 	#0
.2c70	30 34		bmi $2ca6			bmi 	_CDError
.2c72	8d c3 06	sta $06c3			sta 	defType 					; save type
.2c75	8e c4 06	stx $06c4			stx 	defVariable 				; save var ref
.2c78	8c c5 06	sty $06c5			sty 	defVariable+1
.2c7b	29 40		and #$40			and 	#NSSString 					; only numbers.
.2c7d	d0 27		bne $2ca6			bne 	_CDError
.2c7f	20 b9 2a	jsr $2ab9			jsr 	CheckNextRParen 			; check )
.2c82	a9 b2		lda #$b2			lda 	#C64_EQUAL
.2c84	20 bf 2a	jsr $2abf			jsr 	CheckNextA 					; check =
.2c87	18		clc				clc 								; if this is DEF FNxx(A), read A
.2c88	20 a9 2c	jsr $2ca9			jsr 	CDReadWriteVariable
.2c8b	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.2c8d	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2c90	38		sec				sec
.2c91	20 a9 2c	jsr $2ca9			jsr 	CDReadWriteVariable 		; A is now updated
.2c94	20 6d 2d	jsr $2d6d			jsr 	CompileExpressionAt0 		; the actual body of the function.
.2c97	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.2c99	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2c9c	38		sec				sec
.2c9d	20 a9 2c	jsr $2ca9			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.2ca0	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.2ca2	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2ca5	60		rts				rts
.2ca6					_CDError:
.2ca6	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.2ca9					CDReadWriteVariable:
.2ca9	ac c5 06	ldy $06c5			ldy 	defVariable+1 				; set up YX
.2cac	ae c4 06	ldx $06c4			ldx 	defVariable
.2caf	ad c3 06	lda $06c3			lda 	defType
.2cb2	20 ce 36	jsr $36ce			jsr 	GetSetVariable
.2cb5	60		rts				rts
.06c3					defType:
>06c3							.fill 	1
.06c4					defVariable:
>06c4							.fill 	2
.2cb6					CommandDIM:
.2cb6	20 db 33	jsr $33db			jsr 	GetNextNonSpace 			; get the first non space character
.2cb9	20 40 34	jsr $3440			jsr 	ExtractVariableName 		; variable name to XY
.2cbc	da		phx				phx 								; save name with type bits.
.2cbd	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.2cbf	10 37		bpl $2cf8			bpl 	_CDError
.2cc1	20 27 2e	jsr $2e27			jsr 	FindVariable	 			; see if already exist
.2cc4	b0 35		bcs $2cfb			bcs 	_CDRedefine 				; it still exists.
.2cc6	20 b2 2b	jsr $2bb2			jsr 	CreateVariableRecord 		; create the basic variable
.2cc9	20 07 2c	jsr $2c07			jsr 	AllocateBytesForType 		; allocate memory for it
.2ccc	68		pla				pla 								; restore type bits
.2ccd	5a		phy				phy 								; save the address of the basic storage
.2cce	da		phx				phx
.2ccf	48		pha				pha
.2cd0	20 fe 2c	jsr $2cfe			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.2cd3	68		pla				pla
.2cd4	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.2cd6	20 80 2b	jsr $2b80			jsr 	PushIntegerA 				; push that type data out.
.2cd9	a9 cb		lda #$cb			lda 	#(PCD_DIM) >> 8
.2cdb	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2cde	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.2ce0	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2ce3	fa		plx				plx 								; restore address
.2ce4	7a		ply				ply
.2ce5	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2ce7	38		sec				sec
.2ce8	20 ce 36	jsr $36ce			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.2ceb	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; , follows ?
.2cee	c9 2c		cmp #$2c			cmp 	#","
.2cf0	d0 05		bne $2cf7			bne 	_CDExit
.2cf2	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume comma
.2cf5	80 bf		bra $2cb6			bra 	CommandDIM 					; do another DIM
.2cf7					_CDExit:
.2cf7	60		rts				rts
.2cf8					_CDError:
.2cf8	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.2cfb					_CDRedefine:
.2cfb	4c f8 1f	jmp $1ff8		jmp	ErrorV_redefine
.2cfe					OutputIndexGroup:
.2cfe	9c c6 06	stz $06c6			stz 	IndexCount 					; count of number of indices.
.2d01					_OIGNext:
.2d01	20 6d 2d	jsr $2d6d			jsr 	CompileExpressionAt0 		; get a dimension
.2d04	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2d06	c9 00		cmp #$00			cmp 	#NSSIFloat
.2d08	d0 19		bne $2d23			bne 	_OIGType
.2d0a	ee c6 06	inc $06c6			inc 	IndexCount 					; bump the counter.
.2d0d	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; does a , follow ?
.2d10	c9 2c		cmp #$2c			cmp 	#","
.2d12	d0 05		bne $2d19			bne 	_OIGCheckEnd
.2d14	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume comma
.2d17	80 e8		bra $2d01			bra 	_OIGNext 					; get next dimension
.2d19					_OIGCheckEnd:
.2d19	20 b9 2a	jsr $2ab9			jsr 	CheckNextRParen 			; check and consume )
.2d1c	ad c6 06	lda $06c6			lda 	IndexCount
.2d1f	20 80 2b	jsr $2b80			jsr 	PushIntegerA 				; compile the dimension count.
.2d22	60		rts				rts
.2d23					_OIGType:
.2d23	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.06c6					IndexCount:
>06c6							.fill 	1
.2d26					CompilerErrorHandler:
.2d26	68		pla				pla
.2d27	7a		ply				ply
.2d28	85 2c		sta $2c				sta 	zTemp0
.2d2a	84 2d		sty $2d				sty 	zTemp0+1
.2d2c	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.2d2e	a0 01		ldy #$01			ldy 	#1
.2d30					_EHDisplayMsg:
.2d30	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d32	20 64 2a	jsr $2a64			jsr 	PrintCharacter
.2d35	c8		iny				iny
.2d36	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d38	d0 f6		bne $2d30			bne 	_EHDisplayMsg
.2d3a	a9 20		lda #$20			lda 	#32
.2d3c	20 64 2a	jsr $2a64			jsr 	PrintCharacter
.2d3f	a9 40		lda #$40			lda 	#64
.2d41	20 64 2a	jsr $2a64			jsr 	PrintCharacter
.2d44	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.2d46	20 8a 26	jsr $268a			jsr 	FloatSetByte
.2d49	20 50 2a	jsr $2a50			jsr 	GetLineNumber
.2d4c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2d4e	98		tya				tya
.2d4f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2d51	20 70 25	jsr $2570			jsr 	FloatToString
.2d54	a0 00		ldy #$00			ldy 	#0 							; display that string.
.2d56	a2 00		ldx #$00			ldx 	#0
.2d58					_EHDisplayLine:
.2d58	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d5b	20 64 2a	jsr $2a64			jsr 	PrintCharacter
.2d5e	c8		iny				iny
.2d5f	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d62	d0 f4		bne $2d58			bne 	_EHDisplayLine
.2d64	a9 0d		lda #$0d			lda 	#13
.2d66	20 64 2a	jsr $2a64			jsr 	PrintCharacter
.2d69	38		sec				sec 								; CS = error
.2d6a	4c 65 2b	jmp $2b65			jmp 	ExitCompiler
.2d6d					CompileExpressionAt0:
.2d6d	a9 00		lda #$00			lda 	#0
.2d6f					CompileExpressionAtA:
.2d6f	48		pha				pha  								; save level
.2d70	20 a6 37	jsr $37a6			jsr 	CompileTerm 				; compile a term.
.2d73	fa		plx				plx 								; get level back into X
.2d74					_ECALoop:
.2d74	48		pha				pha 								; save type on stack.
.2d75	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; get the next character
.2d78	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.2d7a	90 04		bcc $2d80			bcc 	_ECAExit
.2d7c	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.2d7e	90 02		bcc $2d82			bcc 	_ECAHaveToken
.2d80					_ECAExit:
.2d80	68		pla				pla 								; throw type off stack
.2d81	60		rts				rts
.2d82					_ECAHaveToken:
.2d82	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.2d84	aa		tax				tax 								; X contains the operator token
.2d85	bd 70 2d	lda $2d70,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.2d88	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.2d8a	90 f4		bcc $2d80			bcc 	_ECAExit
.2d8c	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.2d8e	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume the token.
.2d91	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.2d93	f0 11		beq $2da6			beq 	_ECAGreaterCheck
.2d95	e0 b3		cpx #$b3			cpx 	#C64_LESS
.2d97	d0 1a		bne $2db3			bne 	_ECAHaveFullToken
.2d99	20 bf 33	jsr $33bf			jsr 	LookNext 					; checks for < (<= or <>)
.2d9c	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.2d9e	f0 0e		beq $2dae			beq	 	_ECAToNotEqual
.2da0	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.2da2	d0 0f		bne $2db3			bne 	_ECAHaveFullToken
.2da4	80 07		bra $2dad			bra 	_ECAAddEqual
.2da6					_ECAGreaterCheck:
.2da6	20 bf 33	jsr $33bf			jsr 	LookNext
.2da9	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.2dab	d0 06		bne $2db3			bne 	_ECAHaveFullToken
.2dad					_ECAAddEqual:
.2dad	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.2dae					_ECAToNotEqual:
.2dae	e8		inx				inx
.2daf	e8		inx				inx
.2db0	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume the = or > in >= <= <>
.2db3					_ECAHaveFullToken:
.2db3	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.2db5	d0 0a		bne $2dc1			bne 	_ECANotConcat
.2db7	68		pla				pla 								; get type back
.2db8	48		pha				pha
.2db9	29 40		and #$40			and 	#NSSTypeMask
.2dbb	c9 40		cmp #$40			cmp 	#NSSString
.2dbd	d0 02		bne $2dc1			bne 	_ECANotConcat
.2dbf	a2 e0		ldx #$e0			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2dc1					_ECANotConcat:
.2dc1	da		phx				phx 								; save operator on the stack
.2dc2	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.2dc4	da		phx				phx
.2dc5	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.2dc7	1a		inc a				inc 	a
.2dc8	20 6f 2d	jsr $2d6f			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.2dcb	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.2dcd	fa		plx				plx 								; restore current precedence in X
.2dce	68		pla				pla 								; restore operator
.2dcf	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.2dd1	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.2dd3	90 17		bcc $2dec			bcc 	_ECANotCompare
.2dd5	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.2dd7	b0 13		bcs $2dec			bcs 	_ECANotCompare
.2dd9	7a		ply				ply 								; get type into Y
.2dda	5a		phy				phy
.2ddb	48		pha				pha 								; save operator
.2ddc	98		tya				tya 								; get type
.2ddd	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.2ddf	29 40		and #$40			and 	#NSSTypeMask
.2de1	c9 40		cmp #$40			cmp 	#NSSString
.2de3	f0 02		beq $2de7			beq 	_ECANotString
.2de5	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.2de7					_ECANotString:
.2de7	98		tya				tya									; output token Y
.2de8	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2deb	68		pla				pla 								; restore operator.
.2dec					_ECANotCompare:
.2dec	18		clc				clc 								; convert to P-Code and compile.
.2ded	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.2def	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2df2	68		pla				pla 								; type of current result
.2df3	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.2df5	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.2df7	d0 19		bne $2e12			bne		_ECAType
.2df9	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.2dfb	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.2dfd	d0 18		bne $2e17			bne 	_ECAGoLoop
.2dff	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.2e01	c9 e0		cmp #$e0			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2e03	f0 10		beq $2e15			beq 	_ECAOkayString 				; (this is post conversion)
.2e05	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.2e07	90 09		bcc $2e12			bcc 	_ECAType
.2e09	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.2e0b	b0 05		bcs $2e12			bcs 	_ECAType
.2e0d	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.2e0f	4c 74 2d	jmp $2d74			jmp 	_ECALoop
.2e12					_ECAType:
.2e12	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.2e15					_ECAOkayString:
.2e15	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.2e17					_ECAGoLoop:
.2e17	4c 74 2d	jmp $2d74			jmp 	_ECALoop
.2e1a					PrecedenceTable:
>2e1a	03						.byte 	3 					; '+'
>2e1b	03						.byte 	3 					; '-'
>2e1c	04						.byte 	4 					; '*'
>2e1d	04						.byte 	4 					; '/'
>2e1e	05						.byte 	5 					; '^'
>2e1f	01						.byte 	1 					; 'and'
>2e20	00						.byte 	0 					; 'or'
>2e21	02						.byte 	2 					; '>'
>2e22	02						.byte 	2 					; '='
>2e23	02						.byte 	2 					; '<'
>2e24	02						.byte 	2 					; '>='
>2e25	02						.byte 	2 					; '<='
>2e26	02						.byte 	2 					; '<>'
.2e27					FindVariable:
.2e27	86 2e		stx $2e				stx 	zTemp1 						; save name.
.2e29	84 2f		sty $2f				sty 	zTemp1+1
.2e2b					_IVCheckSpecial:
.2e2b	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.2e2d	d0 18		bne $2e47			bne 	_IVStandard
.2e2f	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.2e31	f0 0c		beq $2e3f			beq 	_IVTIFloat
.2e33	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.2e35	d0 10		bne $2e47			bne 	_IVStandard
.2e37	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.2e39	a2 01		ldx #$01			ldx 	#$01
.2e3b	a9 40		lda #$40			lda 	#NSSString
.2e3d	38		sec				sec
.2e3e	60		rts				rts
.2e3f					_IVTIFloat:
.2e3f	a0 80		ldy #$80			ldy 	#$80
.2e41	a2 00		ldx #$00			ldx 	#$00
.2e43	a9 00		lda #$00			lda 	#0
.2e45	38		sec				sec
.2e46	60		rts				rts
.2e47					_IVStandard:
.2e47	ad c1 06	lda $06c1			lda 	compilerStartHigh			; start scanning from here.
.2e4a	85 2d		sta $2d				sta 	zTemp0+1
.2e4c	64 2c		stz $2c				stz 	zTemp0
.2e4e					_IVCheckLoop:
.2e4e	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.2e50	f0 2b		beq $2e7d			beq  	_IVNotFound 				; if so, return with CC.
.2e52	a0 01		ldy #$01			ldy 	#1 							; match ?
.2e54	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e56	c5 2e		cmp $2e				cmp 	zTemp1
.2e58	d0 07		bne $2e61			bne	 	_IVNext
.2e5a	c8		iny				iny
.2e5b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e5d	c5 2f		cmp $2f				cmp 	zTemp1+1
.2e5f	f0 0d		beq $2e6e			beq 	_IVFound
.2e61					_IVNext:
.2e61	18		clc				clc
.2e62	a5 2c		lda $2c				lda 	zTemp0
.2e64	72 2c		adc ($2c)			adc 	(zTemp0)
.2e66	85 2c		sta $2c				sta 	zTemp0
.2e68	90 e4		bcc $2e4e			bcc 	_IVCheckLoop
.2e6a	e6 2d		inc $2d				inc 	zTemp0+1
.2e6c	80 e0		bra $2e4e			bra 	_IVCheckLoop
.2e6e					_IVFound:
.2e6e	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.2e70	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e72	aa		tax				tax
.2e73	c8		iny				iny
.2e74	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e76	48		pha				pha
.2e77	c8		iny				iny
.2e78	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e7a	7a		ply				ply
.2e7b	38		sec				sec
.2e7c	60		rts				rts
.2e7d					_IVNotFound:
.2e7d	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.2e7f	a4 2f		ldy $2f				ldy 	zTemp1+1
.2e81	18		clc				clc
.2e82	60		rts				rts
.2e83					FixBranches:
.2e83	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.2e85	20 6a 2b	jsr $2b6a			jsr 	CallAPIHandler
.2e88					_FBLoop:
.2e88	b2 2a		lda ($2a)			lda 	(objPtr) 					; get the next one.
.2e8a	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.2e8c	f0 1a		beq $2ea8			beq 	_FBFixGotoGosub
.2e8e	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOSUB
.2e90	f0 16		beq $2ea8			beq 	_FBFixGotoGosub
.2e92	c9 d4		cmp #$d4			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.2e94	f0 12		beq $2ea8			beq 	_FBFixGotoGosub
.2e96	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_Z
.2e98	f0 0e		beq $2ea8			beq 	_FBFixGotoGosub
.2e9a	c9 d5		cmp #$d5			cmp 	#PCD_CMD_VARSPACE
.2e9c	f0 43		beq $2ee1			beq 	_FBFixVarSpace
.2e9e	c9 d6		cmp #$d6			cmp 	#PCD_CMD_RESTORE 			; patch restore.
.2ea0	f0 06		beq $2ea8			beq 	_FBFixRestore
.2ea2					_FBNext:
.2ea2	20 56 20	jsr $2056			jsr 	MoveObjectForward 			; move forward in object code.
.2ea5	90 e1		bcc $2e88			bcc 	_FBLoop 					; not finished
.2ea7					_FBExit:
.2ea7	60		rts				rts
.2ea8					_FBFixGotoGosub:
.2ea8					_FBFixRestore:
.2ea8	a0 01		ldy #$01			ldy 	#1							; line number in YA
.2eaa	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2eac	48		pha				pha
.2ead	c8		iny				iny
.2eae	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2eb0	a8		tay				tay
.2eb1	68		pla				pla
.2eb2	20 72 35	jsr $3572			jsr 	STRFindLine			 		; find where it is YA
.2eb5	90 0c		bcc $2ec3			bcc 	_FBFFound 					; not found, so must be >
.2eb7	48		pha				pha
.2eb8	b2 2a		lda ($2a)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.2eba	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_Z 			; or RESTORE. These go to the next line
.2ebc	f0 04		beq $2ec2			beq 	_FBFAllowZero 				; after ; for IF forward scanning, and
.2ebe	c9 d6		cmp #$d6			cmp 	#PCD_CMD_RESTORE 			; because RESTORE <n> <n> is optional.
.2ec0	d0 0f		bne $2ed1			bne 	_FBFFail
.2ec2					_FBFAllowZero:
.2ec2	68		pla				pla
.2ec3					_FBFFound:
.2ec3	20 c2 35	jsr $35c2			jsr 	STRMakeOffset 				; make it an offset from X:YA
.2ec6	5a		phy				phy	 								; patch the GOTO/GOSUB
.2ec7	a0 01		ldy #$01			ldy 	#1
.2ec9	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ecb	c8		iny				iny
.2ecc	68		pla				pla
.2ecd	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ecf	80 d1		bra $2ea2			bra 	_FBNext
.2ed1					_FBFFail:
.2ed1	a0 02		ldy #$02			ldy 	#2
.2ed3	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ed5	8d ba 05	sta $05ba			sta 	currentLineNumber
.2ed8	c8		iny				iny
.2ed9	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2edb	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2ede	4c 73 1f	jmp $1f73		jmp	ErrorV_line
.2ee1					_FBFixVarSpace:
.2ee1	a0 01		ldy #$01			ldy 	#1
.2ee3	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2ee6	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ee8	c8		iny				iny
.2ee9	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2eec	91 2a		sta ($2a),y			sta 	(objPtr),y
.2eee	80 b2		bra $2ea2			bra 	_FBNext
.2ef0					CommandFOR:
.2ef0	20 db 33	jsr $33db			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.2ef3	20 f1 33	jsr $33f1			jsr 	CharIsAlpha 				; if not alpha , error
.2ef6	90 59		bcc $2f51			bcc 	_CFFail
.2ef8	20 1c 37	jsr $371c			jsr 	GetReferenceTerm 			; figure out the reference.
.2efb	48		pha				pha 								; save type
.2efc	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2efe	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f00	d0 4f		bne $2f51			bne 	_CFFail
.2f02	5a		phy				phy 								; save reference on the stack
.2f03	da		phx				phx
.2f04	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.2f06	20 bf 2a	jsr $2abf			jsr 	CheckNextA
.2f09	20 6d 2d	jsr $2d6d			jsr 	CompileExpressionAt0 		; initial value
.2f0c	fa		plx				plx 								; get reference back.
.2f0d	7a		ply				ply
.2f0e	5a		phy				phy
.2f0f	da		phx				phx
.2f10	38		sec				sec 								; set initial value.
.2f11	20 ce 36	jsr $36ce			jsr 	GetSetVariable
.2f14	fa		plx				plx
.2f15	7a		ply				ply
.2f16	68		pla				pla
.2f17	29 20		and #$20			and 	#NSSIInt16
.2f19	f0 04		beq $2f1f			beq 	_CFNotInt16
.2f1b	98		tya				tya
.2f1c	09 80		ora #$80			ora 	#$80
.2f1e	a8		tay				tay
.2f1f					_CFNotInt16:
.2f1f	8a		txa				txa 								; reference in YA
.2f20	20 6d 2b	jsr $2b6d			jsr 	PushIntegerYA
.2f23	a9 a4		lda #$a4			lda 	#C64_TO
.2f25	20 bf 2a	jsr $2abf			jsr 	CheckNextA
.2f28	20 6d 2d	jsr $2d6d			jsr 	CompileExpressionAt0 		; terminal value
.2f2b	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f2d	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f2f	d0 20		bne $2f51			bne 	_CFFail
.2f31	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; followed by STEP
.2f34	c9 a9		cmp #$a9			cmp 	#C64_STEP
.2f36	d0 0e		bne $2f46			bne 	_CFNoStep
.2f38	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume it.
.2f3b	20 6d 2d	jsr $2d6d			jsr 	CompileExpressionAt0 		; terminal value
.2f3e	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f40	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f42	d0 0d		bne $2f51			bne 	_CFFail
.2f44	80 05		bra $2f4b			bra 	_CFParametersDone
.2f46					_CFNoStep:
.2f46	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.2f48	20 80 2b	jsr $2b80			jsr 	PushIntegerA
.2f4b					_CFParametersDone:
.2f4b	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2f4d	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2f50	60		rts				rts
.2f51					_CFFail:
.2f51	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.2f54					FNCompile:
.2f54	20 db 33	jsr $33db			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2f57	20 40 34	jsr $3440			jsr 	ExtractVariableName
.2f5a	e0 00		cpx #$00			cpx 	#0
.2f5c	10 32		bpl $2f90			bpl 	_FNError
.2f5e	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2f5f	29 7f		and #$7f			and 	#$7F
.2f61	aa		tax				tax
.2f62	98		tya				tya
.2f63	09 80		ora #$80			ora 	#$80
.2f65	a8		tay				tay
.2f66	20 27 2e	jsr $2e27			jsr 	FindVariable				; does it already exist ?
.2f69	90 25		bcc $2f90			bcc 	_FNError 					; no.
.2f6b	20 c2 35	jsr $35c2			jsr 	STRMakeOffset 				; convert to a relative address.
.2f6e	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2f70	d0 01		bne $2f73			bne 	_FNNoBorrow
.2f72	88		dey				dey
.2f73					_FNNoBorrow:
.2f73	3a		dec a				dec 	a
.2f74	5a		phy				phy 								; save location of routine on stack.
.2f75	48		pha				pha
.2f76	da		phx				phx
.2f77	20 6d 2d	jsr $2d6d			jsr 	CompileExpressionAt0
.2f7a	20 b9 2a	jsr $2ab9			jsr 	CheckNextRParen
.2f7d	a9 d2		lda #$d2			lda 	#PCD_CMD_GOSUB
.2f7f	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2f82	68		pla				pla
.2f83	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2f86	68		pla				pla
.2f87	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2f8a	68		pla				pla
.2f8b	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.2f8e	18		clc				clc
.2f8f	60		rts				rts
.2f90					_FNError:
.2f90	4c 23 1f	jmp $1f23		jmp	ErrorV_value
.2f93					CommandTables:
>2f93	07 cb 00 03 9e 34 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2f9a	07 89 00 03 a5 34 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2fa1	07 8d 00 03 98 34 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>2fa8	07 8c 00 03 87 37 06			.byte	$07,$8c,$00,$03,CommandRESTORE & $FF,CommandRESTORE >> 8,$06
>2faf	07 88 00 03 14 35 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2fb6	07 85 00 03 f4 34 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>2fbd	07 84 00 04 08 35 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>2fc4	07 99 00 03 49 36 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2fcb	07 98 00 04 49 36 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2fd2	07 8f 00 03 54 37 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>2fd9	07 81 00 03 f0 2e 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>2fe0	07 82 00 03 cc 35 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>2fe7	07 a1 00 03 11 34 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>2fee	07 83 00 03 23 2c 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>2ff5	07 87 00 03 92 36 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>2ffc	07 86 00 03 b6 2c 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>3003	07 96 00 03 3f 2c 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>300a	07 8b 00 e3 c1 34 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>3011	08 92 00 ea e3 3f 38 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>3019	09 91 00 e1 a9 03 f8 35			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>3021	06
>3022	07 9e 00 e2 cb 91 06			.byte	$07,$9e,$00,$e2,37323 & $FF,37323 >> 8,$06
>3029	07 97 00 ea e1 ad 06			.byte	$07,$97,$00,$ea,$e1,173,$06
>3030	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>3036	07 90 00 20 cb 90 06			.byte	$07,$90,$00,$20,37067 & $FF,37067 >> 8,$06
>303d	07 80 00 20 cb 82 06			.byte	$07,$80,$00,$20,33483 & $FF,33483 >> 8,$06
>3044	07 9d 00 e3 65 38 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>304b	0a 9f 00 ea e3 78 38 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,199,$06
>3053	c7 06
>3055	06 a0 00 e1 c4 06			.byte	$06,$a0,$00,$e1,196,$06
>305b	07 ce 90 20 cb ab 06			.byte	$07,$ce,$90,$20,43979 & $FF,43979 >> 8,$06
>3062	0a ce 92 e3 8e 33 20 cb			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44235 & $FF,44235 >> 8,$06
>306a	ac 06
>306c	0a ce 8d e3 8e 33 20 cb			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44491 & $FF,44491 >> 8,$06
>3074	ad 06
>3076	06 ce 86 e1 c8 06			.byte	$06,$ce,$86,$e1,200,$06
>307c	08 ce 84 ea ea e1 c9 06			.byte	$08,$ce,$84,$ea,$ea,$e1,201,$06
>3084	07 ce af e2 cb 97 06			.byte	$07,$ce,$af,$e2,38859 & $FF,38859 >> 8,$06
>308b	07 ce 8c e2 cb 8c 06			.byte	$07,$ce,$8c,$e2,36043 & $FF,36043 >> 8,$06
>3092	09 ce ae ea ea e2 cb 94			.byte	$09,$ce,$ae,$ea,$ea,$e2,38091 & $FF,38091 >> 8,$06
>309a	06
>309b	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>30a3	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>30ab	9a 06
>30ad	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>30b5	9b 06
>30b7	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>30bf	9c 06
>30c1	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>30c9	06
>30ca	07 ce 99 20 cb 98 06			.byte	$07,$ce,$99,$20,39115 & $FF,39115 >> 8,$06
>30d1	08 ce 9a ea e2 cb 99 06			.byte	$08,$ce,$9a,$ea,$e2,39371 & $FF,39371 >> 8,$06
>30d9	08 ce 9b ea e2 cb 9a 06			.byte	$08,$ce,$9b,$ea,$e2,39627 & $FF,39627 >> 8,$06
>30e1	08 ce 9c ea e2 cb 9b 06			.byte	$08,$ce,$9c,$ea,$e2,39883 & $FF,39883 >> 8,$06
>30e9	08 ce 9d ea e2 cb 9c 06			.byte	$08,$ce,$9d,$ea,$e2,40139 & $FF,40139 >> 8,$06
>30f1	08 ce 9e ea e2 cb 9d 06			.byte	$08,$ce,$9e,$ea,$e2,40395 & $FF,40395 >> 8,$06
>30f9	08 ce 9f ea e2 cb 9e 06			.byte	$08,$ce,$9f,$ea,$e2,40651 & $FF,40651 >> 8,$06
>3101	08 ce a0 ea e2 cb 9f 06			.byte	$08,$ce,$a0,$ea,$e2,40907 & $FF,40907 >> 8,$06
>3109	08 ce a1 ea f2 cb a0 06			.byte	$08,$ce,$a1,$ea,$f2,41163 & $FF,41163 >> 8,$06
>3111	08 ce a2 ea f2 cb a1 06			.byte	$08,$ce,$a2,$ea,$f2,41419 & $FF,41419 >> 8,$06
>3119	08 ce a3 ea e2 cb a2 06			.byte	$08,$ce,$a3,$ea,$e2,41675 & $FF,41675 >> 8,$06
>3121	07 ce a4 20 cb a3 06			.byte	$07,$ce,$a4,$20,41931 & $FF,41931 >> 8,$06
>3128	08 ce a5 ea e2 cb a4 06			.byte	$08,$ce,$a5,$ea,$e2,42187 & $FF,42187 >> 8,$06
>3130	08 ce a6 ea e2 cb a5 06			.byte	$08,$ce,$a6,$ea,$e2,42443 & $FF,42443 >> 8,$06
>3138	08 ce a7 ea e2 cb a6 06			.byte	$08,$ce,$a7,$ea,$e2,42699 & $FF,42699 >> 8,$06
>3140	08 ce a8 ea e2 cb a7 06			.byte	$08,$ce,$a8,$ea,$e2,42955 & $FF,42955 >> 8,$06
>3148	08 ce a9 ea e2 cb a8 06			.byte	$08,$ce,$a9,$ea,$e2,43211 & $FF,43211 >> 8,$06
>3150	08 ce aa ea f2 cb a9 06			.byte	$08,$ce,$aa,$ea,$f2,43467 & $FF,43467 >> 8,$06
>3158	08 ce ab ea f2 cb aa 06			.byte	$08,$ce,$ab,$ea,$f2,43723 & $FF,43723 >> 8,$06
>3160	00						.byte 	0
.3161					UnaryTables:
>3161	07 b4 00 8e 91 b7 06			.byte	$07,$b4,$00,$8e,$91,183,$06
>3168	08 b5 00 8e 92 cb 84 06			.byte	$08,$b5,$00,$8e,$92,33995 & $FF,33995 >> 8,$06
>3170	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>3177	07 b7 00 8e 91 c2 06			.byte	$07,$b7,$00,$8e,$91,194,$06
>317e	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>3185	07 b9 00 8e 91 ae 06			.byte	$07,$b9,$00,$8e,$91,174,$06
>318c	08 ba 00 8e 92 cb 85 06			.byte	$08,$ba,$00,$8e,$92,34251 & $FF,34251 >> 8,$06
>3194	07 bb 00 8e 91 b5 06			.byte	$07,$bb,$00,$8e,$91,181,$06
>319b	08 bc 00 8e 92 cb 86 06			.byte	$08,$bc,$00,$8e,$92,34507 & $FF,34507 >> 8,$06
>31a3	08 bd 00 8e 92 cb 87 06			.byte	$08,$bd,$00,$8e,$92,34763 & $FF,34763 >> 8,$06
>31ab	08 be 00 8e 92 cb 88 06			.byte	$08,$be,$00,$8e,$92,35019 & $FF,35019 >> 8,$06
>31b3	08 bf 00 8e 92 cb 89 06			.byte	$08,$bf,$00,$8e,$92,35275 & $FF,35275 >> 8,$06
>31bb	08 c0 00 8e 92 cb 8a 06			.byte	$08,$c0,$00,$8e,$92,35531 & $FF,35531 >> 8,$06
>31c3	08 c1 00 8e 92 cb 8b 06			.byte	$08,$c1,$00,$8e,$92,35787 & $FF,35787 >> 8,$06
>31cb	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>31d2	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>31d9	07 c4 00 8e 91 bb 07			.byte	$07,$c4,$00,$8e,$91,187,$07
>31e0	07 c5 00 8f 91 c3 06			.byte	$07,$c5,$00,$8f,$91,195,$06
>31e7	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>31ee	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>31f5	08 c8 00 8f ae 91 bc 07			.byte	$08,$c8,$00,$8f,$ae,$91,188,$07
>31fd	08 c9 00 8f ae 91 bd 07			.byte	$08,$c9,$00,$8f,$ae,$91,189,$07
>3205	0b ca 00 8f ae 03 8e 33			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,190,$07
>320d	91 be 07
>3210	07 a8 00 03 ad 33 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>3217	07 a5 00 03 54 2f 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>321e	06 ff 00 10 ac 06			.byte	$06,$ff,$00,$10,172,$06
>3224	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>322b	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>3232	08 ce d0 8e ae 91 ca 06			.byte	$08,$ce,$d0,$8e,$ae,$91,202,$06
>323a	08 ce d4 8e 92 cb 83 06			.byte	$08,$ce,$d4,$8e,$92,33739 & $FF,33739 >> 8,$06
>3242	07 ce d3 20 cb 8d 06			.byte	$07,$ce,$d3,$20,36299 & $FF,36299 >> 8,$06
>3249	07 ce d1 20 cb 8e 06			.byte	$07,$ce,$d1,$20,36555 & $FF,36555 >> 8,$06
>3250	07 ce d2 20 cb 8f 06			.byte	$07,$ce,$d2,$20,36811 & $FF,36811 >> 8,$06
>3257	09 ce d7 8e ae 92 cb 95			.byte	$09,$ce,$d7,$8e,$ae,$92,38347 & $FF,38347 >> 8,$06
>325f	06
>3260	00						.byte 	0
.3261					GeneratorProcess:
.3261	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.3263	84 2d		sty $2d				sty 	zTemp0+1
.3265	85 2e		sta $2e				sta 	zTemp1 						; first match token
.3267	64 2f		stz $2f				stz 	zTemp1+1
.3269	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.326b	d0 05		bne $3272			bne 	_GPNotShifted
.326d	20 d0 33	jsr $33d0			jsr 	GetNext 					; get the shifted token
.3270	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.3272					_GPNotShifted:
.3272					_GPSearch:
.3272	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.3274	18		clc				clc
.3275	f0 2f		beq $32a6			beq 	_GPExit
.3277	a0 01		ldy #$01			ldy 	#1 							; tokens match
.3279	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.327b	c5 2e		cmp $2e				cmp 	zTemp1
.327d	d0 09		bne $3288			bne 	_GPNext
.327f	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.3281	f0 12		beq $3295			beq 	_GPFound
.3283	c8		iny				iny 								; check match.
.3284	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.3286	f0 0d		beq $3295			beq 	_GPFound
.3288					_GPNext:
.3288	18		clc				clc 								; follow to next
.3289	a5 2c		lda $2c				lda 	zTemp0
.328b	72 2c		adc ($2c)			adc 	(zTemp0)
.328d	85 2c		sta $2c				sta 	zTemp0
.328f	90 e1		bcc $3272			bcc 	_GPSearch
.3291	e6 2d		inc $2d				inc 	zTemp0+1
.3293	80 dd		bra $3272			bra 	_GPSearch
.3295					_GPFound:
.3295	18		clc				clc 								; skip to action bytes
.3296	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.3298	69 03		adc #$03			adc 	#3
.329a	85 2c		sta $2c				sta 	zTemp0
.329c	90 02		bcc $32a0			bcc 	_GPNoCarry
.329e	e6 2d		inc $2d				inc 	zTemp0+1
.32a0					_GPNoCarry:
.32a0					_GPLoop:
.32a0	20 a7 32	jsr $32a7			jsr 	GeneratorExecute 			; execute one command
.32a3	90 fb		bcc $32a0			bcc 	_GPLoop 					; go back if not completed.
.32a5	38		sec				sec 								; return with CS.
.32a6					_GPExit:
.32a6	60		rts				rts
.32a7					GeneratorExecute:
.32a7	20 53 33	jsr $3353			jsr 	_GEFetchZTemp0 				; get next.
.32aa	48		pha				pha 								; split into 2 nibbles
.32ab	4a		lsr a				lsr 	a
.32ac	4a		lsr a				lsr 	a
.32ad	4a		lsr a				lsr		a
.32ae	4a		lsr a				lsr 	a
.32af	20 b9 32	jsr $32b9			jsr 	_GEExecuteNibble 			; MSB first
.32b2	68		pla				pla
.32b3	b0 03		bcs $32b8			bcs 	_GEHaveCompleted
.32b5	20 b9 32	jsr $32b9			jsr 	_GEExecuteNibble 			; LSB second
.32b8					_GEHaveCompleted:
.32b8	60		rts				rts
.32b9					_GEExecuteNibble:
.32b9	29 0f		and #$0f			and 	#$0F
.32bb	0a		asl a				asl 	a
.32bc	aa		tax				tax
.32bd	7c c0 32	jmp ($32c0,x)			jmp 	(_GEExecuteVectors,x)
.32c0					_GEExecuteVectors:
>32c0	e0 32						.word 	_GEXNop 					; 0  (no operation)
>32c2	e8 32						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>32c4	e2 32						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>32c6	36 33						.word 	_GEXExecute 				; 3  (run arbitrary code)
>32c8	29 33						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>32ca	e0 32						.word 	_GEXNop 					; 5
>32cc	f0 32						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>32ce	f4 32						.word 	_GEXExitString 				; 7  exit return string type
>32d0	f8 32						.word 	_GEXLParam 					; 8  check ( follows
>32d2	fc 32						.word 	_GEXRParam 					; 9  check ) follows
>32d4	00 33						.word 	_GEXComma					; A  check , follows
>32d6	e0 32						.word 	_GEXNop 					; B
>32d8	e0 32						.word 	_GEXNop 					; C
>32da	e0 32						.word 	_GEXNop 					; D
>32dc	10 33						.word 	_GEXNumber 					; E  compile get any number
>32de	1b 33						.word 	_GEXString 					; F  compile get any string
.32e0					_GEXNop:
.32e0	18		clc				clc
.32e1	60		rts				rts
.32e2					_GEXToken2:
.32e2	20 53 33	jsr $3353			jsr 	_GEFetchZTemp0
.32e5	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.32e8					_GEXToken1:
.32e8	20 53 33	jsr $3353			jsr 	_GEFetchZTemp0
.32eb	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.32ee	18		clc				clc
.32ef	60		rts				rts
.32f0					_GEXExitNumber:
.32f0	a9 00		lda #$00			lda 	#NSSIFloat
.32f2	38		sec				sec
.32f3	60		rts				rts
.32f4					_GEXExitString:
.32f4	a9 40		lda #$40			lda 	#NSSString
.32f6	38		sec				sec
.32f7	60		rts				rts
.32f8					_GEXLParam:
.32f8	a9 28		lda #$28			lda 	#"("
.32fa	80 06		bra $3302			bra 	_GEXCheck
.32fc					_GEXRParam:
.32fc	a9 29		lda #$29			lda 	#")"
.32fe	80 02		bra $3302			bra 	_GEXCheck
.3300					_GEXComma:
.3300	a9 2c		lda #$2c			lda 	#","
.3302					_GEXCheck:
.3302	85 30		sta $30				sta 	zTemp2 						; save match
.3304	20 db 33	jsr $33db			jsr 	GetNextNonSpace 			; get next skipping spaces
.3307	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.3309	d0 02		bne $330d			bne 	_GEXSyntax
.330b	18		clc				clc
.330c	60		rts				rts
.330d					_GEXSyntax:
.330d	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.3310					_GEXNumber:
.3310	20 5c 33	jsr $335c			jsr 	GEXCompileExpression 		; compile expression
.3313	29 40		and #$40			and 	#NSSTypeMask
.3315	c9 00		cmp #$00			cmp  	#NSSIFloat
.3317	d0 0d		bne $3326			bne 	_GEXType
.3319	18		clc				clc
.331a	60		rts				rts
.331b					_GEXString:
.331b	20 5c 33	jsr $335c			jsr 	GEXCompileExpression 		; compile expression
.331e	29 40		and #$40			and 	#NSSTypeMask
.3320	c9 40		cmp #$40			cmp  	#NSSString
.3322	d0 02		bne $3326			bne 	_GEXType
.3324	18		clc				clc
.3325	60		rts				rts
.3326					_GEXType:
.3326	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.3329					_GEXChannelExec:
.3329	20 6c 33	jsr $336c			jsr 	ChannelPrefix 				; set up default
.332c	20 36 33	jsr $3336			jsr 	_GEXExecute
.332f	08		php				php
.3330	20 87 33	jsr $3387			jsr 	ChannelPostfix 				; replace default.
.3333	28		plp				plp
.3334	60		rts				rts
>3335	db						.byte 	$DB 						; causes a break in the emulator
.3336					_GEXExecute:
.3336	20 53 33	jsr $3353			jsr 	_GEFetchZTemp0 				; get vector
.3339	85 30		sta $30				sta 	zTemp2
.333b	20 53 33	jsr $3353			jsr 	_GEFetchZTemp0
.333e	85 31		sta $31				sta 	zTemp2+1
.3340	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.3342	da		phx				phx
.3343	a6 2d		ldx $2d				ldx 	zTemp0+1
.3345	da		phx				phx
.3346	20 50 33	jsr $3350			jsr 	_GECallZTemp2 				; execute code
.3349	fa		plx				plx 								; recover generation exec
.334a	86 2d		stx $2d				stx 	zTemp0+1
.334c	fa		plx				plx
.334d	86 2c		stx $2c				stx 	zTemp0
.334f	60		rts				rts
.3350					_GECallZTemp2:
.3350	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.3353					_GEFetchZTemp0:
.3353	b2 2c		lda ($2c)			lda 	(zTemp0)
.3355	e6 2c		inc $2c				inc 	zTemp0
.3357	d0 02		bne $335b			bne 	_GEFZ0Skip
.3359	e6 2d		inc $2d				inc 	zTemp0+1
.335b					_GEFZ0Skip:
.335b	60		rts				rts
.335c					GEXCompileExpression:
.335c	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.335e	da		phx				phx
.335f	a6 2d		ldx $2d				ldx 	zTemp0+1
.3361	da		phx				phx
.3362	20 6d 2d	jsr $2d6d			jsr 	CompileExpressionAt0 		; compile expression.
.3365	fa		plx				plx 								; recover generation exec
.3366	86 2d		stx $2d				stx 	zTemp0+1
.3368	fa		plx				plx
.3369	86 2c		stx $2c				stx 	zTemp0
.336b	60		rts				rts
.336c					ChannelPrefix:
.336c	a9 af		lda #$af			lda 	#PCD_GETCHANNEL				; set channel onto stack
.336e	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.3371	20 5c 33	jsr $335c			jsr 	GEXCompileExpression 		; channel #
.3374	29 40		and #$40			and 	#NSSTypeMask
.3376	c9 00		cmp #$00			cmp 	#NSSIFloat
.3378	d0 0a		bne $3384			bne 	_CPXType
.337a	20 b5 2a	jsr $2ab5			jsr 	CheckNextComma 				; check , follows.
.337d	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL				; set channel
.337f	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.3382	18		clc				clc
.3383	60		rts				rts
.3384					_CPXType:
.3384	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.3387					ChannelPostfix:
.3387	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.3389	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.338c	18		clc				clc
.338d	60		rts				rts
.338e					OptionalParameterCompile:
.338e	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; what follows.
.3391	c9 2c		cmp #$2c			cmp 	#","
.3393	d0 0e		bne $33a3			bne 	_MidDefault
.3395	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume ,
.3398	20 6d 2d	jsr $2d6d			jsr 	CompileExpressionAt0
.339b	29 40		and #$40			and 	#NSSTypeMask
.339d	c9 00		cmp #$00			cmp 	#NSSIFloat
.339f	d0 09		bne $33aa			bne 	MidFailType
.33a1	80 05		bra $33a8			bra 	_MidComplete
.33a3					_MidDefault:
.33a3	a9 ff		lda #$ff			lda 	#255 						; default of 255
.33a5	20 80 2b	jsr $2b80			jsr 	PushIntegerA
.33a8					_MidComplete:
.33a8	18		clc				clc
.33a9	60		rts				rts
.33aa					MidFailType:
.33aa	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.33ad					NotUnaryCompile:
.33ad	ad 22 2e	lda $2e22			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.33b0	20 6f 2d	jsr $2d6f			jsr 	CompileExpressionAtA 		; evaluate at that level
.33b3	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.33b5	c9 00		cmp #$00			cmp 	#NSSIFloat
.33b7	d0 f1		bne $33aa			bne 	MidFailType
.33b9	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.33bb	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.33be	60		rts				rts
.33bf					LookNext:
.33bf	b2 7a		lda ($7a)			lda 	(srcPtr)
.33c1	60		rts				rts
.33c2					LookNextNonSpace:
.33c2	b2 7a		lda ($7a)			lda 	(srcPtr)
.33c4	c9 20		cmp #$20			cmp		#' '
.33c6	f0 03		beq $33cb			beq 	_LNNSkip
.33c8	c9 00		cmp #$00			cmp 	#0
.33ca	60		rts				rts
.33cb					_LNNSkip:
.33cb	20 d0 33	jsr $33d0			jsr 	GetNext
.33ce	80 f2		bra $33c2			bra 	LookNextNonSpace
.33d0					GetNext:
.33d0	b2 7a		lda ($7a)			lda 	(srcPtr) 					; get next
.33d2	e6 7a		inc $7a				inc 	srcPtr
.33d4	d0 02		bne $33d8			bne 	_GNSkip
.33d6	e6 7b		inc $7b				inc 	srcPtr+1
.33d8					_GNSkip:
.33d8	c9 00		cmp #$00			cmp 	#0
.33da	60		rts				rts
.33db					GetNextNonSpace:
.33db	20 d0 33	jsr $33d0			jsr 	GetNext
.33de	c9 20		cmp #$20			cmp 	#' '
.33e0	f0 f9		beq $33db			beq 	GetNextNonSpace
.33e2	c9 00		cmp #$00			cmp 	#0
.33e4	60		rts				rts
.33e5					CharIsDigit:
.33e5	c9 30		cmp #$30			cmp 	#"0"
.33e7	90 06		bcc $33ef			bcc 	CCFalse
.33e9	c9 3a		cmp #$3a			cmp 	#"9"+1
.33eb	b0 02		bcs $33ef			bcs 	CCFalse
.33ed					CCTrue:
.33ed	38		sec				sec
.33ee	60		rts				rts
.33ef					CCFalse:
.33ef	18		clc				clc
.33f0	60		rts				rts
.33f1					CharIsAlpha:
.33f1	c9 41		cmp #$41			cmp 	#"A"
.33f3	90 fa		bcc $33ef			bcc 	CCFalse
.33f5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.33f7	b0 f6		bcs $33ef			bcs 	CCFalse
.33f9	80 f2		bra $33ed			bra 	CCTrue
.33fb					ConvertHexStyle:
.33fb	38		sec				sec
.33fc	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.33fe	90 ef		bcc $33ef			bcc 	CCFalse
.3400	c9 0a		cmp #$0a			cmp 	#9+1
.3402	90 e9		bcc $33ed			bcc 	CCTrue
.3404	38		sec				sec 								; shift into hex space A=>0 Z=>25
.3405	e9 11		sbc #$11			sbc 	#"A"-"0"
.3407	90 e6		bcc $33ef			bcc 	CCFalse
.3409	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.340b	b0 e2		bcs $33ef			bcs 	CCFalse
.340d	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.340f	80 dc		bra $33ed			bra 	CCTrue
.3411					CommandGET:
.3411	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; # follows ?
.3414	c9 23		cmp #$23			cmp 	#"#"
.3416	d0 0d		bne $3425			bne 	CommandGetBody
.3418	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume #
.341b	20 6c 33	jsr $336c			jsr 	ChannelPrefix 				; do it as GET#
.341e	20 25 34	jsr $3425			jsr 	CommandGetBody
.3421	20 87 33	jsr $3387			jsr 	ChannelPostfix
.3424	60		rts				rts
.3425					CommandGetBody:
.3425	20 db 33	jsr $33db			jsr 	GetNextNonSpace 			; get the first character
.3428	20 1c 37	jsr $371c			jsr 	GetReferenceTerm 			; identify variable to assign to
.342b	48		pha				pha
.342c	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.342e	c9 40		cmp #$40			cmp 	#NSSString
.3430	d0 0b		bne $343d			bne 	_CGType
.3432	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.3434	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.3437	38		sec				sec
.3438	68		pla				pla
.3439	20 ce 36	jsr $36ce			jsr		GetSetVariable
.343c	60		rts				rts
.343d					_CGType:
.343d	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.3440					ExtractVariableName:
.3440	20 f1 33	jsr $33f1			jsr 	CharIsAlpha
.3443	90 50		bcc $3495			bcc 	_IVSyntax
.3445	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.3447	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.3449	64 2f		stz $2f				stz 	zTemp1+1
.344b	20 bf 33	jsr $33bf			jsr 	LookNext 					; is there a second character ?
.344e	20 f1 33	jsr $33f1			jsr 	CharIsAlpha  				; must be alphanumeric
.3451	b0 05		bcs $3458			bcs 	_IVHasSecond
.3453	20 e5 33	jsr $33e5			jsr 	CharIsDigit
.3456	90 07		bcc $345f			bcc 	_IVCheckType
.3458					_IVHasSecond:
.3458	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.345a	85 2f		sta $2f				sta 	zTemp1+1
.345c					_IVGetNextCheck:
.345c	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume it
.345f					_IVCheckType:
.345f	20 bf 33	jsr $33bf			jsr 	LookNext					; check if string follows.
.3462	20 f1 33	jsr $33f1			jsr 	CharIsAlpha
.3465	b0 f5		bcs $345c			bcs 	_IVGetNextCheck
.3467	20 e5 33	jsr $33e5			jsr 	CharIsDigit
.346a	b0 f0		bcs $345c			bcs 	_IVGetNextCheck
.346c	a2 40		ldx #$40			ldx 	#NSSString
.346e	c9 24		cmp #$24			cmp 	#"$"
.3470	f0 06		beq $3478			beq 	_IVHasType
.3472	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.3474	c9 25		cmp #$25			cmp 	#"%"
.3476	d0 08		bne $3480			bne 	_IVCheckArray
.3478					_IVHasType:
.3478	8a		txa				txa 								; Or X into zTemp1
.3479	05 2e		ora $2e				ora 	zTemp1
.347b	85 2e		sta $2e				sta 	zTemp1
.347d	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume it
.3480					_IVCheckArray:
.3480	20 bf 33	jsr $33bf			jsr 	LookNext 					; check if array follows
.3483	c9 28		cmp #$28			cmp 	#"("
.3485	d0 09		bne $3490			bne 	_IVNotArray
.3487	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.3489	09 80		ora #$80			ora 	#NSSArray
.348b	85 2e		sta $2e				sta 	zTemp1
.348d	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume it
.3490					_IVNotArray:
.3490	a6 2e		ldx $2e				ldx 	zTemp1
.3492	a4 2f		ldy $2f				ldy 	zTemp1+1
.3494	60		rts				rts
.3495					_IVSyntax:
.3495	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.3498					CommandGOSUB:
.3498	a9 d2		lda #$d2			lda 	#PCD_CMD_GOSUB
.349a	20 ab 34	jsr $34ab			jsr 	CompileBranchCommand
.349d	60		rts				rts
.349e					CommandGOAlt:
.349e	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.34a0	20 bf 2a	jsr $2abf			jsr 	CheckNextA
.34a3	80 00		bra $34a5			bra 	CommandGOTO
.34a5					CommandGOTO:
.34a5	a9 d1		lda #$d1			lda 	#PCD_CMD_GOTO
.34a7	20 ab 34	jsr $34ab			jsr 	CompileBranchCommand
.34aa	60		rts				rts
.34ab					CompileBranchCommand:
.34ab	20 57 2a	jsr $2a57			jsr 	WriteCodeByte 				; write the command out.
.34ae	20 db 33	jsr $33db			jsr 	GetNextNonSpace
.34b1	20 24 36	jsr $3624			jsr 	ParseConstant 				; get constant into YA
.34b4	90 08		bcc $34be			bcc 	_CBCSyntax
.34b6	20 57 2a	jsr $2a57			jsr 	WriteCodeByte				; and compile the actual line number
.34b9	98		tya				tya
.34ba	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.34bd	60		rts				rts
.34be					_CBCSyntax:
.34be	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.34c1					CommandIF:
.34c1	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; what follows the tests ?
.34c4	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.34c6	f0 0f		beq $34d7			beq 	_CIGoto
.34c8	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.34ca	20 bf 2a	jsr $2abf			jsr 	CheckNextA
.34cd	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; THEN <number>
.34d0	20 e5 33	jsr $33e5			jsr 	CharIsDigit
.34d3	b0 05		bcs $34da			bcs 	_CIGoto2
.34d5	80 09		bra $34e0			bra 	CompileGotoEOL
.34d7					_CIGoto:
.34d7	20 d0 33	jsr $33d0			jsr 	GetNext
.34da					_CIGoto2:
.34da	a9 d4		lda #$d4			lda 	#PCD_CMD_GOTOCMD_NZ
.34dc	20 ab 34	jsr $34ab			jsr 	CompileBranchCommand
.34df	60		rts				rts
.34e0					CompileGotoEOL:
.34e0	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_Z
.34e2	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.34e5	20 50 2a	jsr $2a50			jsr 	GetLineNumber 				; Get the current line number => YA
.34e8	1a		inc a				inc 	a 							; and branch to +1
.34e9	d0 01		bne $34ec			bne 	_CGENoCarry
.34eb	c8		iny				iny
.34ec					_CGENoCarry:
.34ec	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.34ef	98		tya				tya
.34f0	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.34f3	60		rts				rts
.34f4					CommandINPUT:
.34f4	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; check for "
.34f7	c9 22		cmp #$22			cmp 	#'"'
.34f9	d0 0d		bne $3508			bne 	CommandINPUTStream
.34fb	20 6d 2d	jsr $2d6d			jsr 	CompileExpressionAt0
.34fe	a9 b2		lda #$b2			lda 	#(PCD_PRINTCMD_S) & $FF
.3500	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.3503	a9 2c		lda #$2c			lda 	#","
.3505	20 b5 2a	jsr $2ab5			jsr 	CheckNextComma
.3508					CommandINPUTStream:
.3508	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.350a	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.350d	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.350f	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.3511	4c 96 36	jmp $3696			jmp 	CommandReadInputCommon
.3514					CommandLET:
.3514	20 db 33	jsr $33db			jsr 	GetNextNonSpace 			; get the first character
.3517					CommandLETHaveFirst:
.3517	20 1c 37	jsr $371c			jsr 	GetReferenceTerm 			; identify variable to assign to
.351a	da		phx				phx 								; save target on the stack.
.351b	5a		phy				phy
.351c	48		pha				pha
.351d	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.351f	20 bf 2a	jsr $2abf			jsr 	CheckNextA
.3522	20 6d 2d	jsr $2d6d			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.3525	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.3527	68		pla				pla 								; get type of assignment
.3528	48		pha				pha
.3529	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.352b	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.352d	d0 17		bne $3546			bne 	_CLType
.352f	68		pla				pla 								; restore and compile save code
.3530	7a		ply				ply
.3531	fa		plx				plx
.3532	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.3534	f0 05		beq $353b			beq 	_CLTIString
.3536	38		sec				sec
.3537	20 ce 36	jsr $36ce			jsr		GetSetVariable
.353a	60		rts				rts
.353b					_CLTIString:
.353b	a9 cb		lda #$cb			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.353d	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.3540	a9 92		lda #$92			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.3542	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.3545	60		rts				rts
.3546					_CLType:
.3546	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.3549					STRMarkLine:
.3549	48		pha				pha
.354a	38		sec				sec 								; allocate 4 bytes (line #,address)
.354b	ad c9 06	lda $06c9			lda 	lineNumberTable 			; and copy to zTemp0
.354e	e9 04		sbc #$04			sbc 	#4
.3550	8d c9 06	sta $06c9			sta 	lineNumberTable
.3553	85 2c		sta $2c				sta 	zTemp0
.3555	ad ca 06	lda $06ca			lda 	lineNumberTable+1
.3558	e9 00		sbc #$00			sbc 	#0
.355a	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.355d	85 2d		sta $2d				sta 	zTemp0+1
.355f	68		pla				pla
.3560	92 2c		sta ($2c)			sta 	(zTemp0) 					; line # save it in +0,+1
.3562	98		tya				tya
.3563	a0 01		ldy #$01			ldy 	#1
.3565	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3567	a5 2a		lda $2a				lda 	objPtr 						; save current address in +2,+3
.3569	c8		iny				iny
.356a	91 2c		sta ($2c),y			sta 	(zTemp0),y
.356c	a5 2b		lda $2b				lda 	objPtr+1
.356e	c8		iny				iny
.356f	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3571	60		rts				rts
.3572					STRFindLine:
.3572	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.3574	84 2d		sty $2d				sty 	zTemp0+1
.3576	ad c2 06	lda $06c2			lda 	compilerEndHigh 			; work backwards through table
.3579	85 2f		sta $2f				sta 	zTemp1+1
.357b	64 2e		stz $2e				stz 	zTemp1
.357d					_STRSearch:
.357d	20 b4 35	jsr $35b4			jsr 	_STRPrevLine 				; look at previous record.
.3580	a0 01		ldy #$01			ldy 	#1
.3582	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.3584	c5 2c		cmp $2c				cmp 	zTemp0
.3586	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3588	e5 2d		sbc $2d				sbc 	zTemp0+1
.358a	b0 0b		bcs $3597			bcs 	_STRFound 					; >=
.358c					_STRNext:
.358c	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.358e	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3590	c9 ff		cmp #$ff			cmp 	#$FF
.3592	d0 e9		bne $357d			bne 	_STRSearch
.3594	4c 8a 1f	jmp $1f8a		jmp	ErrorV_internal
.3597					_STRFound:
.3597	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.3599	45 2c		eor $2c				eor 	zTemp0
.359b	d0 06		bne $35a3			bne 	_STRDifferent
.359d	b2 2e		lda ($2e)			lda 	(zTemp1)
.359f	45 2c		eor $2c				eor 	zTemp0
.35a1	f0 02		beq $35a5			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.35a3					_STRDifferent:
.35a3	a9 ff		lda #$ff			lda 	#$FF
.35a5					_STROut:
.35a5	18		clc				clc  								; set carry if different, e.g. > rather than >=
.35a6	69 ff		adc #$ff			adc 	#255
.35a8	08		php				php
.35a9	c8		iny				iny 								; address into YA
.35aa	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.35ac	48		pha				pha
.35ad	c8		iny				iny
.35ae	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.35b0	a8		tay				tay
.35b1	68		pla				pla
.35b2	28		plp				plp
.35b3	60		rts				rts
.35b4					_STRPrevLine:
.35b4	38		sec				sec 								; move backwards one entry.
.35b5	a5 2e		lda $2e				lda 	zTemp1
.35b7	e9 04		sbc #$04			sbc 	#4
.35b9	85 2e		sta $2e				sta 	zTemp1
.35bb	a5 2f		lda $2f				lda 	zTemp1+1
.35bd	e9 00		sbc #$00			sbc 	#0
.35bf	85 2f		sta $2f				sta 	zTemp1+1
.35c1	60		rts				rts
.35c2					STRMakeOffset:
.35c2	18		clc				clc 								; borrow 1
.35c3	e5 2a		sbc $2a				sbc 	objPtr
.35c5	48		pha				pha
.35c6	98		tya				tya
.35c7	e5 2b		sbc $2b				sbc 	objPtr+1
.35c9	a8		tay				tay
.35ca	68		pla				pla
.35cb	60		rts				rts
.35cc					CommandNEXT:
.35cc	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.35cf	20 f1 33	jsr $33f1			jsr 	CharIsAlpha 				; if not alpha , error
.35d2	90 0c		bcc $35e0			bcc 	_CNNoReferenceGiven
.35d4	20 d0 33	jsr $33d0			jsr 	GetNext
.35d7	20 1c 37	jsr $371c			jsr 	GetReferenceTerm 			; figure out the reference.
.35da	8a		txa				txa 								; reference in YA
.35db	20 6d 2b	jsr $2b6d			jsr 	PushIntegerYA 				; write it out.
.35de	80 06		bra $35e6			bra 	_CNParametersDone
.35e0					_CNNoReferenceGiven:
.35e0	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.35e2	a8		tay				tay
.35e3	20 6d 2b	jsr $2b6d			jsr 	PushIntegerYA 				; write it out.
.35e6					_CNParametersDone:
.35e6	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.35e8	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.35eb	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; look for ,
.35ee	c9 2c		cmp #$2c			cmp 	#","
.35f0	d0 05		bne $35f7			bne 	_CNExit
.35f2	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume ,
.35f5	80 d5		bra $35cc			bra 	CommandNEXT 				; and go round.
.35f7					_CNExit:
.35f7	60		rts				rts
.35f8					CommandON:
.35f8	20 db 33	jsr $33db			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.35fb	48		pha				pha 								; save on stack
.35fc	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOTO
.35fe	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.3600	f0 09		beq $360b			beq 	_COCreateLoop
.3602	a2 d2		ldx #$d2			ldx 	#PCD_CMD_GOSUB
.3604	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.3606	f0 03		beq $360b			beq 	_COCreateLoop
.3608	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.360b					_COCreateLoop:
.360b	8a		txa				txa 								; compile a goto/gosub somewhere
.360c	da		phx				phx
.360d	20 ab 34	jsr $34ab			jsr 	CompileBranchCommand
.3610	fa		plx				plx
.3611	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace			; ',' follows
.3614	c9 2c		cmp #$2c			cmp 	#","
.3616	d0 0a		bne $3622			bne 	_COComplete 				; if so, more line numbers
.3618	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.361a	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.361d	20 d0 33	jsr $33d0			jsr 	GetNext
.3620	80 e9		bra $360b			bra 	_COCreateLoop
.3622					_COComplete:
.3622	68		pla				pla 								; throw GOTO/GOSUB
.3623	60		rts				rts
.3624					ParseConstant:
.3624	a2 00		ldx #$00			ldx 	#0
.3626	20 68 24	jsr $2468			jsr 	FloatEncodeStart 			; send first
.3629					_ParseLoop:
.3629	20 bf 33	jsr $33bf			jsr 	LookNext 					; send subsequent
.362c	20 6b 24	jsr $246b			jsr 	FloatEncodeContinue
.362f	90 05		bcc $3636			bcc 	_ParseDone
.3631	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume it
.3634	80 f3		bra $3629			bra 	_ParseLoop
.3636					_ParseDone:
.3636	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.3638	29 80		and #$80			and 	#$80
.363a	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.363c	15 56		ora $56,x			ora 	NSMantissa2,x
.363e	15 62		ora $62,x			ora 	NSMantissa3,x
.3640	18		clc				clc
.3641	d0 05		bne $3648			bne 	_ParseExit 					; exit with CC if need float to compile
.3643	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.3645	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.3647	38		sec				sec
.3648					_ParseExit:
.3648	60		rts				rts
.3649					CommandPRINT:
.3649	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace			; what follows ?
.364c	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.364e	f0 1f		beq $366f			beq 	_CPCheckEnd
.3650	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.3652	f0 16		beq $366a			beq 	_CPTabCheckEnd
.3654	20 86 36	jsr $3686			jsr 	_CPAtEnd 					; check for : and EOL
.3657	b0 22		bcs $367b			bcs 	_CPExitCR 					; exit with CR
.3659	20 6d 2d	jsr $2d6d			jsr 	CompileExpressionAt0 		; so it is something to print
.365c	a2 b2		ldx #$b2			ldx 	#PCD_PRINTCMD_S
.365e	29 40		and #$40			and 	#NSSString 					; if string
.3660	d0 02		bne $3664			bne 	_CPOut
.3662	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_N
.3664					_CPOut:
.3664	8a		txa				txa 								; print that thing
.3665	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.3668	80 df		bra $3649			bra 	CommandPRINT 				; and loop round/
.366a					_CPTabCheckEnd:
.366a	a9 b8		lda #$b8			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.366c	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.366f					_CPCheckEnd:
.366f	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume it.
.3672	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; what follows ?
.3675	20 86 36	jsr $3686			jsr 	_CPAtEnd 					; reached end
.3678	90 cf		bcc $3649			bcc 	CommandPRINT 				; no, loop back
.367a	60		rts				rts
.367b					_CPExitCR:
.367b	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.367d	20 80 2b	jsr $2b80			jsr 	PushIntegerA
.3680	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.3682	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.3685	60		rts				rts
.3686					_CPAtEnd:
.3686	c9 00		cmp #$00			cmp 	#0
.3688	f0 06		beq $3690			beq 	_CPIsEnd
.368a	c9 3a		cmp #$3a			cmp 	#":"
.368c	f0 02		beq $3690			beq 	_CPIsEnd
.368e	18		clc				clc
.368f	60		rts				rts
.3690					_CPIsEnd:
.3690	38		sec				sec
.3691	60		rts				rts
.3692					CommandREAD:
.3692	a2 b3		ldx #$b3			ldx 	#PCD_READ
.3694	a0 b4		ldy #$b4			ldy 	#PCD_READDOLLAR
.3696					CommandReadInputCommon:
.3696	8e c7 06	stx $06c7			stx 	numberPCode
.3699	8c c8 06	sty $06c8			sty 	stringPCode
.369c					_CRLoop:
.369c	20 db 33	jsr $33db			jsr 	GetNextNonSpace 			; first char of identifier
.369f	20 f1 33	jsr $33f1			jsr 	CharIsAlpha 				; check A-Z
.36a2	90 27		bcc $36cb			bcc 	_CRSyntax
.36a4	20 1c 37	jsr $371c			jsr 	GetReferenceTerm 			; get the variable.
.36a7	48		pha				pha 								; save type.
.36a8	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.36aa	c9 40		cmp #$40			cmp 	#NSSString
.36ac	f0 05		beq $36b3			beq 	_CRString
.36ae	ad c7 06	lda $06c7			lda 	numberPCode 				; output read/input
.36b1	80 03		bra $36b6			bra 	_CRHaveType
.36b3					_CRString:
.36b3	ad c8 06	lda $06c8			lda 	stringPCode					; output read$/input$
.36b6					_CRHaveType:
.36b6	20 57 2a	jsr $2a57			jsr 	WriteCodeByte 				; so we have one typed data item.
.36b9	68		pla				pla 								; restore type
.36ba	38		sec				sec  								; write update code.
.36bb	20 ce 36	jsr $36ce			jsr 	GetSetVariable
.36be	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; , follows ?
.36c1	c9 2c		cmp #$2c			cmp 	#","
.36c3	d0 05		bne $36ca			bne 	_CRExit 					; if not, end of READ.
.36c5	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume comma
.36c8	80 d2		bra $369c			bra 	_CRLoop 					; keep going
.36ca					_CRExit:
.36ca	60		rts				rts
.36cb					_CRSyntax:
.36cb	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.06c7					numberPCode:
>06c7							.fill 	1
.06c8					stringPCode:
>06c8							.fill 	1
.36ce					GetSetVariable:
.36ce	08		php				php 								; save direction on stack
.36cf	c0 00		cpy #$00			cpy 	#$00
.36d1	30 21		bmi $36f4			bmi 	_GSVReadWriteSpecial
.36d3	c9 00		cmp #$00			cmp 	#$00
.36d5	30 33		bmi $370a			bmi 	_GSVArray
.36d7	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.36d9	4a		lsr a				lsr 	a 							; divide by 2
.36da	09 40		ora #$40			ora 	#64 						; and set bit 6.
.36dc	28		plp				plp
.36dd	90 02		bcc $36e1			bcc 	_GSVNotWrite
.36df	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.36e1					_GSVNotWrite:
.36e1	85 2c		sta $2c				sta 	zTemp0
.36e3	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.36e4	4a		lsr a				lsr 	a
.36e5	a8		tay				tay
.36e6	8a		txa				txa
.36e7	6a		ror a				ror 	a
.36e8	aa		tax				tax
.36e9	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.36ea	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.36ec	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.36ef	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.36f0	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.36f3	60		rts				rts
.36f4					_GSVReadWriteSpecial:
.36f4	28		plp				plp
.36f5	b0 10		bcs $3707			bcs 	_GSVSyntax
.36f7	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.36f9	f0 06		beq $3701			beq 	_GSVRWString
.36fb	a9 c0		lda #$c0			lda 	#(PCD_TI) & $FF
.36fd	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.3700	60		rts				rts
.3701					_GSVRWString:
.3701	a9 c1		lda #$c1			lda 	#(PCD_TIDOLLAR) & $FF
.3703	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.3706	60		rts				rts
.3707					_GSVSyntax:
.3707	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.370a					_GSVArray:
.370a	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.370c	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.370d	4a		lsr a				lsr 	a
.370e	4a		lsr a				lsr 	a
.370f	4a		lsr a				lsr 	a
.3710	4a		lsr a				lsr 	a
.3711	28		plp				plp 								; if writing array then set bit 2.
.3712	90 02		bcc $3716			bcc 	_GSVANotWrite
.3714	09 04		ora #$04			ora 	#4
.3716					_GSVANotWrite:
.3716	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.3718	20 57 2a	jsr $2a57			jsr 	WriteCodeByte 				; and write it out
.371b	60		rts				rts
.371c					GetReferenceTerm:
.371c	20 40 34	jsr $3440			jsr 	ExtractVariableName 		; get name & type info
.371f	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.3721	30 10		bmi $3733			bmi 	_GRTArray
.3723	da		phx				phx 								; save type on stack
.3724	20 27 2e	jsr $2e27			jsr 	FindVariable 				; find it
.3727	b0 06		bcs $372f			bcs 	_GRTNoCreate 				; create if required.
.3729	20 b2 2b	jsr $2bb2			jsr 	CreateVariableRecord 		; create a variable.
.372c	20 07 2c	jsr $2c07			jsr 	AllocateBytesForType 		; allocate memory for it
.372f					_GRTNoCreate:
.372f	68		pla				pla 								; get type back, strip out type information.
.3730	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.3732	60		rts				rts
.3733					_GRTArray:
.3733	da		phx				phx 								; save type information
.3734	20 27 2e	jsr $2e27			jsr 	FindVariable 				; read its data, the base address in YX
.3737	90 18		bcc $3751			bcc 	_GRTUndeclared 				; undeclared array.
.3739	da		phx				phx 								; save base address
.373a	5a		phy				phy
.373b	20 fe 2c	jsr $2cfe			jsr 	OutputIndexGroup 			; create an index group and generate them
.373e	7a		ply				ply 								; get the array base address into YX
.373f	fa		plx				plx
.3740	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.3742	18		clc				clc
.3743	20 ce 36	jsr $36ce			jsr 	GetSetVariable 				; load the address of the array structure.
.3746	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.3748	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.374b	68		pla				pla 								; and the type data into A
.374c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.374e	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.3750	60		rts				rts
.3751					_GRTUndeclared:
.3751	4c e7 1f	jmp $1fe7		jmp	ErrorV_undeclared
.3754					CommandREM:
.3754	20 bf 33	jsr $33bf			jsr 	LookNext
.3757	f0 05		beq $375e			beq 	_CRExit
.3759	20 d0 33	jsr $33d0			jsr 	GetNext
.375c	80 f6		bra $3754			bra 	CommandREM
.375e					_CRExit:
.375e	60		rts				rts
.375f					STRReset:
.375f	ad c1 06	lda $06c1			lda	 	compilerStartHigh 			; set up the two table pointers
.3762	8d cc 06	sta $06cc			sta 	variableListEnd+1
.3765	9c cb 06	stz $06cb			stz 	variableListEnd
.3768	ad c2 06	lda $06c2			lda 	compilerEndHigh
.376b	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.376e	9c c9 06	stz $06c9			stz 	lineNumberTable
.3771	ad cb 06	lda $06cb			lda 	variableListEnd
.3774	85 2d		sta $2d				sta 	zTemp0+1
.3776	64 2c		stz $2c				stz 	zTemp0
.3778	a9 00		lda #$00			lda 	#0
.377a	92 2c		sta ($2c)			sta 	(zTemp0)
.377c	a9 00		lda #$00			lda 	#((0) & $FF)
.377e	8d cd 06	sta $06cd			sta 	0+freeVariableMemory
.3781	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.3783	8d ce 06	sta $06ce			sta 	1+freeVariableMemory
.3786	60		rts				rts
.06c9					lineNumberTable:
>06c9							.fill 	2
.06cb					variableListEnd:
>06cb							.fill 	2
.06cd					freeVariableMemory:
>06cd							.fill 	2
.3787					CommandRESTORE:
.3787	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; what follows ?
.378a	c9 3a		cmp #$3a			cmp 	#':'						; if : or EOL then default
.378c	f0 0a		beq $3798			beq 	_CRDefault
.378e	c9 00		cmp #$00			cmp 	#0
.3790	f0 06		beq $3798			beq 	_CRDefault
.3792	a9 d6		lda #$d6			lda 	#PCD_CMD_RESTORE 			; no, we have a parameter like GOTO/GOSUB
.3794	20 ab 34	jsr $34ab			jsr 	CompileBranchCommand
.3797	60		rts				rts
.3798					_CRDefault:
.3798	a9 d6		lda #$d6			lda 	#PCD_CMD_RESTORE 			; compile RESTORE
.379a	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.379d	a9 00		lda #$00			lda 	#0		 					; with zero "line#"
.379f	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.37a2	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.37a5	60		rts				rts
.37a6					CompileTerm:
.37a6	20 db 33	jsr $33db			jsr 	GetNextNonSpace 			; get first non space character.
.37a9	30 72		bmi $381d			bmi 	_CTUnaryFunctions
.37ab	20 e5 33	jsr $33e5			jsr 	CharIsDigit 				; found a number
.37ae	b0 3a		bcs $37ea			bcs 	_CTDigit
.37b0	c9 2e		cmp #$2e			cmp 	#"."
.37b2	f0 36		beq $37ea			beq 	_CTDigit
.37b4	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.37b6	f0 43		beq $37fb			beq 	_CTString
.37b8	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.37ba	f0 28		beq $37e4			beq 	_CTOtherBase
.37bc	c9 24		cmp #$24			cmp 	#"$"
.37be	f0 24		beq $37e4			beq 	_CTOtherBase
.37c0	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.37c2	f0 17		beq $37db			beq 	_CTBrackets
.37c4	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.37c6	90 10		bcc $37d8			bcc 	_CTSyntax
.37c8	c9 5b		cmp #$5b			cmp 	#"Z"+1
.37ca	b0 0c		bcs $37d8			bcs 	_CTSyntax
.37cc	20 1c 37	jsr $371c			jsr 	GetReferenceTerm 			; figure out what it is.
.37cf	48		pha				pha 								; save type on stack
.37d0	18		clc				clc 								; read it
.37d1	20 ce 36	jsr $36ce			jsr 	GetSetVariable
.37d4	68		pla				pla
.37d5	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.37d7	60		rts				rts
.37d8					_CTSyntax:
.37d8	4c 30 1f	jmp $1f30		jmp	ErrorV_syntax
.37db					_CTBrackets:
.37db	20 6d 2d	jsr $2d6d			jsr 	CompileExpressionAt0
.37de	48		pha				pha
.37df	20 b9 2a	jsr $2ab9			jsr 	CheckNextRParen
.37e2	68		pla				pla
.37e3	60		rts				rts
.37e4					_CTOtherBase:
.37e4	20 05 2a	jsr $2a05			jsr 	InlineNonDecimal 			; non decimal constant handler
.37e7	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.37e9	60		rts				rts
.37ea					_CTDigit:
.37ea	20 24 36	jsr $3624			jsr 	ParseConstant 				; parse out an number, first is in A already.
.37ed	90 06		bcc $37f5			bcc	 	_CTFloat 					; have a float or long int.
.37ef	20 6d 2b	jsr $2b6d			jsr 	PushIntegerYA 				; code to push on stack
.37f2	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.37f4	60		rts				rts
.37f5					_CTFloat:
.37f5	20 8f 2b	jsr $2b8f			jsr 	PushFloatCommand			; code to push float
.37f8	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.37fa	60		rts				rts
.37fb					_CTString:
.37fb	20 8e 2a	jsr $2a8e			jsr 	BufferClear 				; copy it to the buffer
.37fe					_CTStringLoop:
.37fe	20 bf 33	jsr $33bf			jsr 	LookNext 					; reached EOL/EOS
.3801	f0 d5		beq $37d8			beq 	_CTSyntax
.3803	c9 22		cmp #$22			cmp 	#'"'
.3805	f0 08		beq $380f			beq 	_CTStringDone
.3807	20 92 2a	jsr $2a92			jsr 	BufferWrite 				; write and consume
.380a	20 d0 33	jsr $33d0			jsr 	GetNext
.380d	80 ef		bra $37fe			bra 	_CTStringLoop
.380f					_CTStringDone:
.380f	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume closing quote.
.3812	a9 cf		lda #$cf			lda 	#PCD_CMD_STRING 			; output command and buffer
.3814	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.3817	20 9e 2a	jsr $2a9e			jsr 	BufferOutput
.381a	a9 40		lda #$40			lda 	#NSSString 					; string type
.381c	60		rts				rts
.381d					_CTUnaryFunctions:
.381d	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.381f	f0 0a		beq $382b			beq 	_CTNegation
.3821	a2 61		ldx #$61			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.3823	a0 31		ldy #$31			ldy 	#UnaryTables >> 8
.3825	20 61 32	jsr $3261			jsr 	GeneratorProcess
.3828	90 ae		bcc $37d8			bcc		_CTSyntax
.382a	60		rts				rts
.382b					_CTNegation:
.382b	20 a6 37	jsr $37a6			jsr 	CompileTerm 				; compile a term.
.382e	48		pha				pha
.382f	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.3831	c9 00		cmp #$00			cmp 	#NSSIFloat
.3833	d0 07		bne $383c			bne 	_CTType 					; error
.3835	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.3837	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.383a	68		pla				pla 								; return original type.
.383b	60		rts				rts
.383c					_CTType:
.383c	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.383f					CommandWAIT:
.383f	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace
.3842	c9 2c		cmp #$2c			cmp 	#","
.3844	f0 10		beq $3856			beq 	_CWThirdParameter
.3846	a9 00		lda #$00			lda 	#0
.3848	20 80 2b	jsr $2b80			jsr 	PushIntegerA
.384b					_CWExit:
.384b	a9 cb		lda #$cb			lda 	#(PCD_WAIT) >> 8
.384d	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.3850	a9 93		lda #$93			lda 	#(PCD_WAIT) & $FF
.3852	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.3855	60		rts				rts
.3856					_CWThirdParameter:
.3856	20 d0 33	jsr $33d0			jsr 	GetNext
.3859	20 6f 2d	jsr $2d6f			jsr 	CompileExpressionAtA
.385c	29 40		and #$40			and 	#NSSTypeMask
.385e	c9 00		cmp #$00			cmp 	#NSSIFloat
.3860	f0 e9		beq $384b			beq 	_CWExit
.3862	4c 40 1f	jmp $1f40		jmp	ErrorV_type
.3865					CommandCMD:
.3865	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.3867	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.386a	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; followed by a , ?
.386d	c9 2c		cmp #$2c			cmp 	#","
.386f	d0 06		bne $3877			bne 	_CCMDExit
.3871	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume comma.
.3874	20 49 36	jsr $3649			jsr 	CommandPRINT 				; do the print code
.3877					_CCMDExit:
.3877	60		rts				rts
.3878					CommandOPEN:
.3878	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; followed by a , ?
.387b	c9 2c		cmp #$2c			cmp 	#","
.387d	d0 15		bne $3894			bne 	_COTwoDefaults
.387f	20 d0 33	jsr $33d0			jsr 	GetNext 					; consume comma
.3882	20 6d 2d	jsr $2d6d			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.3885	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.3887	f0 1e		beq $38a7			beq 	_COThreeIntegers
.3889	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.388b	20 80 2b	jsr $2b80			jsr 	PushIntegerA
.388e	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.3890	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.3893	60		rts				rts
.3894					_COTwoDefaults:
.3894	a9 00		lda #$00			lda 	#0
.3896	20 80 2b	jsr $2b80			jsr 	PushIntegerA
.3899					_COCompileNullString:
.3899	a9 cf		lda #$cf			lda 	#(PCD_CMD_STRING) & $FF
.389b	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.389e	a9 00		lda #$00			lda 	#0
.38a0	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.38a3	20 57 2a	jsr $2a57			jsr 	WriteCodeByte
.38a6	60		rts				rts
.38a7					_COThreeIntegers:
.38a7	20 c2 33	jsr $33c2			jsr 	LookNextNonSpace 			; is there a ,
.38aa	c9 2c		cmp #$2c			cmp 	#","
.38ac	d0 eb		bne $3899			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.38ae	20 d0 33	jsr $33d0			jsr 	GetNext
.38b1	20 6d 2d	jsr $2d6d			jsr 	CompileExpressionAt0 		; should be a filename
.38b4	29 40		and #$40			and 	#NSSString
.38b6	f0 01		beq $38b9			beq 	_COType
.38b8	60		rts				rts
.38b9					_COType:
.38b9	4c 40 1f	jmp $1f40		jmp	ErrorV_type

;******  Processing input file: _library.asm

.38bc					CompilerAPI:
.38bc	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.38be	f0 19		beq $38d9			beq 	_CAOpenIn
.38c0	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.38c2	f0 23		beq $38e7			beq 	_CACloseIn
.38c4	c9 02		cmp #$02			cmp 	#BLC_READIN
.38c6	f0 3a		beq $3902			beq 	_CARead
.38c8	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.38ca	f0 1e		beq $38ea			beq 	_CAResetOut
.38cc	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.38ce	f0 23		beq $38f3			beq 	_CACloseOut
.38d0	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.38d2	f0 20		beq $38f4			beq 	_CAWriteByte
.38d4	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.38d6	f0 26		beq $38fe			beq 	_CAPrintScreen
>38d8	db						.byte 	$DB 						; causes a break in the emulator
.38d9					_CAOpenIn:
.38d9	a0 39		ldy #$39			ldy 	#SourceFile >> 8 			; name of file
.38db	a2 f9		ldx #$f9			ldx 	#SourceFile & $FF
.38dd	20 6a 39	jsr $396a			jsr 	IOOpenRead 					; open file
.38e0	20 75 39	jsr $3975			jsr 	IOReadByte 					; skip the 2 byte load address header
.38e3	20 75 39	jsr $3975			jsr 	IOReadByte
.38e6	60		rts				rts
.38e7					_CACloseIn:
.38e7	4c 84 39	jmp $3984			jmp 	IOReadClose
.38ea					_CAResetOut:
.38ea	a9 00		lda #$00			lda 	#((FreeMemory) & $FF)
.38ec	85 2a		sta $2a				sta 	0+objPtr
.38ee	a9 3b		lda #$3b			lda 	#((FreeMemory) >> 8) & $FF
.38f0	85 2b		sta $2b				sta 	1+objPtr
.38f2	60		rts				rts
.38f3					_CACloseOut:
.38f3	60		rts				rts
.38f4					_CAWriteByte:
.38f4	8a		txa				txa
.38f5	92 2a		sta ($2a)			sta 	(objPtr)
.38f7	e6 2a		inc $2a				inc 	objPtr
.38f9	d0 02		bne $38fd			bne 	_HWOWBNoCarry
.38fb	e6 2b		inc $2b				inc 	objPtr+1
.38fd					_HWOWBNoCarry:
.38fd	60		rts				rts
.38fe					_CAPrintScreen:
.38fe	8a		txa				txa
.38ff	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.3902					_CARead:
.3902	20 75 39	jsr $3975			jsr 	IOReadByte 				; copy the address of next into the buffer
.3905	8d cf 06	sta $06cf			sta 	SourceLine+0
.3908	20 75 39	jsr $3975			jsr 	IOReadByte
.390b	8d d0 06	sta $06d0			sta 	SourceLine+1
.390e	0d cf 06	ora $06cf			ora 	sourceLine				; if both were zero, exit with CC (e.g. fail)
.3911	18		clc				clc
.3912	f0 1e		beq $3932			beq		_CARExit
.3914	20 75 39	jsr $3975			jsr 	IOReadByte 				; read the line # into the buffer.
.3917	8d d1 06	sta $06d1			sta 	SourceLine+2
.391a	20 75 39	jsr $3975			jsr 	IOReadByte
.391d	8d d2 06	sta $06d2			sta 	SourceLine+3
.3920	a2 04		ldx #$04			ldx 	#4 						; read the body of the line.
.3922					_CAReadLine:
.3922	20 75 39	jsr $3975			jsr 	IOReadByte 				; now keep copying to EOL
.3925	9d cf 06	sta $06cf,x			sta 	SourceLine,x
.3928	e8		inx				inx
.3929	c9 00		cmp #$00			cmp 	#0
.392b	d0 f5		bne $3922			bne 	_CAReadLine
.392d	38		sec				sec 							; read a line okay
.392e	a0 06		ldy #$06			ldy 	#SourceLine >> 8
.3930	a2 cf		ldx #$cf			ldx 	#SourceLine & $FF
.3932					_CARExit:
.3932	60		rts				rts
.06cf					SourceLine:
>06cf							.fill 	256
.3933					WriteObjectCode:
.3933	20 1a 08	jsr $081a			jsr 	PatchOutCompile 			; makes it run the runtime on reload
.3936	a0 39		ldy #$39			ldy 	#ObjectFile >> 8
.3938	a2 ee		ldx #$ee			ldx 	#ObjectFile & $FF
.393a	20 5d 3a	jsr $3a5d			jsr 	IOOpenWrite 				; open write
.393d	a9 01		lda #$01			lda 	#1 							; write out the load address $0801
.393f	20 68 3a	jsr $3a68			jsr 	IOWriteByte
.3942	a9 08		lda #$08			lda 	#8
.3944	20 68 3a	jsr $3a68			jsr 	IOWriteByte
.3947	a9 01		lda #$01			lda 	#((StartBasicProgram) & $FF)
.3949	85 2c		sta $2c				sta 	0+zTemp0
.394b	a9 08		lda #$08			lda 	#((StartBasicProgram) >> 8) & $FF
.394d	85 2d		sta $2d				sta 	1+zTemp0
.394f					_WOCLoop:
.394f	b2 2c		lda ($2c)			lda 	(zTemp0) 					; write code
.3951	20 68 3a	jsr $3a68			jsr 	IOWriteByte
.3954	e6 2c		inc $2c				inc 	zTemp0 						; advance pointer
.3956	d0 02		bne $395a			bne 	_WOCSkip
.3958	e6 2d		inc $2d				inc 	zTemp0+1
.395a					_WOCSkip:
.395a	a5 2c		lda $2c				lda 	zTemp0 						; check end
.395c	c5 2a		cmp $2a				cmp 	objPtr
.395e	d0 ef		bne $394f			bne 	_WOCLoop
.3960	a5 2d		lda $2d				lda 	zTemp0+1
.3962	c5 2b		cmp $2b				cmp 	objPtr+1
.3964	d0 e9		bne $394f			bne 	_WOCLoop
.3966	20 84 39	jsr $3984			jsr 	IOWriteClose 				; close the file.
.3969	60		rts				rts
.396a					IOOpenRead:
.396a	a9 52		lda #$52			lda 	#'R' 						; read.
.396c	20 8d 39	jsr $398d			jsr 	IOSetFileName 				; set up name/LFS
.396f	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for reading
.3971	20 c6 ff	jsr $ffc6			jsr 	$FFC6 						; CHKIN
.3974	60		rts				rts
.3975					IOReadByte:
.3975	da		phx				phx
.3976	5a		phy				phy
.3977	20 b7 ff	jsr $ffb7			jsr 	$FFB7 						; read ST
.397a	38		sec				sec
.397b	d0 04		bne $3981			bne 	_IORExit
.397d	20 cf ff	jsr $ffcf			jsr 	$FFCF 						; read a byte
.3980	18		clc				clc 								; status OK.
.3981					_IORExit:
.3981	7a		ply				ply
.3982	fa		plx				plx
.3983	60		rts				rts
.3984					IOReadClose:
.3984					IOWriteClose:
.3984	a9 03		lda #$03			lda 	#3 							; CLOSE# 3
.3986	20 c3 ff	jsr $ffc3			jsr 	$FFC3
.3989	20 cc ff	jsr $ffcc			jsr 	$FFCC 						; CLRCHN
.398c	60		rts				rts
.398d					IOSetFileName:
.398d	48		pha				pha 								; save R/W
.398e	86 2c		stx $2c				stx 	zTemp0
.3990	84 2d		sty $2d				sty 	zTemp0+1
.3992	a0 ff		ldy #$ff			ldy 	#$FF 						; copy name given
.3994					_IOSCopy:
.3994	c8		iny				iny 								; pre-increment copy
.3995	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.3997	99 cf 07	sta $07cf,y			sta 	IONameBuffer,y
.399a	d0 f8		bne $3994			bne 	_IOSCopy
.399c	99 d3 07	sta $07d3,y			sta 	IONameBuffer+4,y
.399f	a9 2c		lda #$2c			lda 	#',' 						; append ,S,[R|W]
.39a1	99 cf 07	sta $07cf,y			sta 	IONameBuffer+0,y
.39a4	99 d1 07	sta $07d1,y			sta 	IONameBuffer+2,y
.39a7	a9 53		lda #$53			lda 	#'S'
.39a9	99 d0 07	sta $07d0,y			sta 	IONameBuffer+1,y
.39ac	68		pla				pla 								; write R/W out
.39ad	99 d2 07	sta $07d2,y			sta 	IONameBuffer+3,y
.39b0	98		tya				tya 								; length of name to A
.39b1	18		clc				clc
.39b2	69 04		adc #$04			adc 	#4 							; we added 4 characters.
.39b4	a2 cf		ldx #$cf			ldx 	#IONameBuffer & $FF			; name address to YX
.39b6	a0 07		ldy #$07			ldy 	#IONameBuffer >> 8
.39b8	20 bd ff	jsr $ffbd		    jsr 	$FFBD          				; call SETNAM
.39bb	a9 03		lda #$03	    	lda 	#3 							; set LFS to 3,8,3
.39bd	a2 08		ldx #$08			ldx 	#8
.39bf	a0 03		ldy #$03			ldy 	#3
.39c1	20 ba ff	jsr $ffba			jsr 	$FFBA
.39c4	20 c0 ff	jsr $ffc0			jsr 	$FFC0 						; OPEN
.39c7	60		rts				rts
.07cf					IONameBuffer:
>07cf							.fill 	64
.39c8					CompileCode:
.39c8	a2 00		ldx #$00			ldx 	#0
.39ca	bd 04 3a	lda $3a04,x	_Prompt:lda 	Prompt,x
.39cd	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.39d0	e8		inx				inx
.39d1	c9 00		cmp #$00			cmp 	#0
.39d3	d0 f5		bne $39ca			bne 	_Prompt
.39d5	a2 ea		ldx #$ea			ldx 	#APIDesc & $FF
.39d7	a0 39		ldy #$39			ldy 	#APIDesc >> 8
.39d9	20 ce 2a	jsr $2ace			jsr 	StartCompiler
.39dc	20 33 39	jsr $3933			jsr 	WriteObjectCode
.39df	a9 4f		lda #$4f			lda 	#"O"
.39e1	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.39e4	a9 4b		lda #$4b			lda 	#"K"
.39e6	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.39e9	60		rts				rts
.39ea					APIDesc:
>39ea	bc 38						.word 	CompilerAPI 				; the compiler API Implementeation
>39ec	80						.byte 	$80 						; start of workspace for compiler $8000
>39ed	9f						.byte 	$9F							; end of workspace for compiler $9F00
.39ee					ObjectFile:
>39ee	4f 42 4a 45 43 54 2e 50				.text 	'OBJECT.PRG',0
>39f6	52 47 00
.39f9					SourceFile:
>39f9	53 4f 55 52 43 45 2e 50				.text 	'SOURCE.PRG',0
>3a01	52 47 00
.3a04					Prompt:
>3a04	2a 2a 2a 20 42 4c 49 54				.text 	'*** BLITZ (ALPHA 09-10-23) ***',13,13
>3a0c	5a 20 28 41 4c 50 48 41 20 30 39 2d 31 30 2d 32
>3a1c	33 29 20 2a 2a 2a 0d 0d
>3a24	42 55 47 53 3a 48 54 54				.text 	'BUGS:HTTPS://GITHUB.COM/PAULSCOTTROBSON/BLITZ-COMPILER',13,13,0
>3a2c	50 53 3a 2f 2f 47 49 54 48 55 42 2e 43 4f 4d 2f
>3a3c	50 41 55 4c 53 43 4f 54 54 52 4f 42 53 4f 4e 2f
>3a4c	42 4c 49 54 5a 2d 43 4f 4d 50 49 4c 45 52 0d 0d
>3a5c	00
.3a5d					IOOpenWrite:
.3a5d	a9 57		lda #$57			lda 	#'W'			 			; write
.3a5f	20 8d 39	jsr $398d			jsr 	IOSetFileName 				; set up name/LFS
.3a62	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for writing
.3a64	20 c9 ff	jsr $ffc9			jsr 	$FFC9 						; CHKOUT
.3a67	60		rts				rts
.3a68					IOWriteByte:
.3a68	48		pha				pha
.3a69	da		phx				phx
.3a6a	5a		phy				phy
.3a6b	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a6e	7a		ply				ply
.3a6f	fa		plx				plx
.3a70	68		pla				pla
.3a71	60		rts				rts

;******  Processing input file: source/main/zzfree.footer

>3a72							.align 	256
.3b00					FreeMemory:

;******  End of listing
