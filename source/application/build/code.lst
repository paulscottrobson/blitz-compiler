
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl source/main/00main.header /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library _library.asm source/main/zzfree.footer
; Wed Oct 11 10:54:32 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: source/main/00main.header

.0801					StartBasicProgram:
>0801	0c 08						.word 	$080C 						; offset to next.
>0803	0a 00						.word 	10 							; line #
>0805	9e						.byte 	$9E 						; token for 'SYS'
>0806	20 32 30 36 32					.text 	' 2062'						; space, $080E in decimal
>080b	00						.byte  	0 							; end of line
>080c	00 00						.word 	0 							; end of program
.080e					StartCode:
.080e	4c 79 39	jmp $3979			jmp 	CompileCode 				; to starting the runtime in the saved code.
.0811	a9 3b		lda #$3b			lda 	#FreeMemory >> 8 			; address of object code to run.
.0813	a2 80		ldx #$80			ldx 	#$80 						; 8000-9EFF is used for workspace.
.0815	a0 9f		ldy #$9f			ldy 	#$9F
.0817	4c 26 08	jmp $0826			jmp 	StartRuntime 				; and go do it !
.081a					PatchOutCompile:
.081a	a9 ea		lda #$ea			lda 	#$EA 						; $EA is NOP 65C02
.081c	8d 0e 08	sta $080e			sta 	StartCode 					; patch out "JMP COMPILECODE"
.081f	8d 0f 08	sta $080f			sta 	StartCode+1
.0822	8d 10 08	sta $0810			sta 	StartCode+2
.0825	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.0826					StartRuntime:
.0826	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.0829	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.082b	64 28		stz $28				stz 	codePtr
.082d	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0830	8c 06 04	sty $0406			sty 	storeEndHigh
.0833	8e 07 04	stx $0407			stx 	variableStartPage
.0836	ba		tsx				tsx 								; save the stack.
.0837	8e 08 04	stx $0408			stx 	Runtime6502SP
.083a	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.083c	a2 57		ldx #$57			ldx 	#RuntimeErrorHandler & $FF
.083e	20 e8 1e	jsr $1ee8			jsr 	SetErrorHandler
.0841	20 84 0a	jsr $0a84			jsr 	ClearMemory 				; clear memory.
.0844	20 66 16	jsr $1666			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0847	20 68 13	jsr $1368		 	jsr		SetDefaultChannel			; set default input/output channel.
.084a	20 9e 15	jsr $159e			jsr 	RestoreCode 				; which we now call
.084d	a0 00		ldy #$00			ldy 	#0
.084f					NextCommand:
.084f	ad 09 04	lda $0409			lda  	breakCount 					; only check every 16 instructions.
.0852	69 10		adc #$10			adc 	#16
.0854	8d 09 04	sta $0409			sta 	breakCount
.0857	90 07		bcc $0860			bcc 	_NXNoCheck
.0859	da		phx				phx
.085a	5a		phy				phy 								; check Ctrl+C
.085b	20 a0 1b	jsr $1ba0			jsr 	XCheckStop
.085e	7a		ply				ply
.085f	fa		plx				plx
.0860					_NXNoCheck:
.0860	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.0862	30 5b		bmi $08bf			bmi 	NXCommand 					; -if -ve command
.0864	c8		iny				iny
.0865	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0867	90 39		bcc $08a2			bcc 	PushByteA 					; 0..63 is short constants.
.0869					NXLoadStore:
.0869	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.086b	b0 19		bcs $0886			bcs 	NXIndirectLoadStore
.086d	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.086e	4a		lsr a				lsr 	a
.086f	29 0e		and #$0e			and 	#$0E
.0871	da		phx				phx 								; get ready to jump
.0872	aa		tax				tax
.0873	7c 76 08	jmp ($0876,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.0876					ReadWriteVectors:
>0876	d4 14						.word 	ReadFloatCommand			; read float
>0878	af 1a						.word 	WriteFloatCommand 			; write float
>087a	10 15						.word 	ReadIntegerCommand 			; read integer
>087c	eb 1a						.word 	WriteIntegerCommand 		; write integer
>087e	55 15						.word 	ReadStringCommand 			; read string
>0880	2a 1b						.word 	WriteStringCommand 			; write string
>0882	54 0c						.word 	Unimplemented
>0884	54 0c						.word 	Unimplemented
.0886					NXIndirectLoadStore:
.0886	29 07		and #$07			and 	#7
.0888	0a		asl a				asl 	a
.0889	da		phx				phx
.088a	aa		tax				tax
.088b	7c 8e 08	jmp ($088e,x)			jmp 	(IndirectVectors,x)
.088e					IndirectVectors:
>088e	0a 0f						.word 	IndFloatRead 				; float read
>0890	1e 0f						.word 	IndInt16Read 				; int16 read
>0892	32 0f						.word 	IndStringRead 				; string read
>0894	54 0c						.word 	Unimplemented
>0896	46 0f						.word 	IndFloatWrite				; float write
>0898	5a 0f						.word 	IndInt16Write 				; int16 write
>089a	6e 0f						.word 	IndStringWrite 				; string write
>089c	54 0c						.word 	Unimplemented
.089e					PushByteCommand:
.089e	fa		plx				plx
.089f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.08a1	c8		iny				iny
.08a2					PushByteA:
.08a2	e8		inx				inx 								; push constant on stack
.08a3	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.08a5	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.08a7					ClearRestWord:
.08a7	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.08a9	74 62		stz $62,x			stz 	NSMantissa3,x
.08ab	74 6e		stz $6e,x			stz 	NSExponent,x
.08ad	74 32		stz $32,x			stz 	NSStatus,x
.08af	80 9e		bra $084f			bra 	NextCommand
.08b1					PushWordCommand:
.08b1	fa		plx				plx
.08b2	e8		inx				inx
.08b3	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.08b5	c8		iny				iny
.08b6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08b8	b1 28		lda ($28),y			lda 	(codePtr),y
.08ba	c8		iny				iny
.08bb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08bd	80 e8		bra $08a7			bra 	ClearRestWord 				; handle everything else.
.08bf					NXCommand:
.08bf	c8		iny				iny 								; consume command.
.08c0	10 03		bpl $08c5			bpl 	_NXCommandNoFixUp
.08c2	20 cb 08	jsr $08cb			jsr 	FixUpY
.08c5					_NXCommandNoFixUp:
.08c5	0a		asl a				asl 	a 							; shift left
.08c6	da		phx				phx 								; save SP on stack
.08c7	aa		tax				tax				 					; and jump indirect
.08c8	7c 90 19	jmp ($1990,x)			jmp 	(VectorTable,x)
.08cb					FixUpY:
.08cb	48		pha				pha
.08cc	98		tya				tya
.08cd	18		clc				clc
.08ce	65 28		adc $28				adc 	codePtr
.08d0	85 28		sta $28				sta 	codePtr
.08d2	90 02		bcc $08d6			bcc 	_NoCPCarry
.08d4	e6 29		inc $29				inc 	codePtr+1
.08d6					_NoCPCarry:
.08d6	a0 00		ldy #$00			ldy 	#0
.08d8	68		pla				pla
.08d9	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.0408					Runtime6502SP:
>0408							.fill 	1
.0409					breakCount:
>0409							.fill 	1
.08da					AbsoluteTOS:
.08da	fa		plx				plx
.08db	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.08e0					CommandVarSpace:
.08e0	fa		plx				plx
.08e1	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08e3	85 26		sta $26				sta 	availableMemory
.08e5	c8		iny				iny
.08e6	b1 28		lda ($28),y			lda 	(codePtr),y
.08e8	18		clc				clc
.08e9	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08ec	85 27		sta $27				sta 	availableMemory+1
.08ee	c8		iny				iny
.08ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08f2					BinaryAnd:
.08f2	fa		plx				plx
.08f3	38		sec				sec
.08f4	80 02		bra $08f8			bra 	AndOrCommon
.08f6					BinaryOr:
.08f6	fa		plx				plx
.08f7	18		clc				clc
.08f8					AndOrCommon:
.08f8	08		php				php 								; save AND/OR flag
.08f9	20 45 10	jsr $1045			jsr 	GetInteger16Bit
.08fc	ca		dex				dex
.08fd	20 45 10	jsr $1045			jsr 	GetInteger16Bit
.0900	28		plp				plp
.0901	90 0e		bcc $0911			bcc 	_AOCOrCode
.0903	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.0905	35 3f		and $3f,x			and		NSMantissa0+1,x
.0907	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0909	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.090b	35 4b		and $4b,x			and		NSMantissa1+1,x
.090d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.090f	80 0c		bra $091d			bra 	_AOCComplete
.0911					_AOCOrCode:
.0911	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.0913	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.0915	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0917	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0919	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.091b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.091d					_AOCComplete:
.091d	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.091f	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.0921	10 07		bpl $092a			bpl 	_AOCExit
.0923	20 55 10	jsr $1055			jsr 	Negate16Bit 				; 2's complement
.0926	a9 80		lda #$80			lda 	#$80 						; make it -ve
.0928	95 32		sta $32,x			sta 	NSStatus,x
.092a					_AOCExit:
.092a	4c 4f 08	jmp $084f			jmp 	NextCommand
.092d					ArrayConvert:
.092d	fa		plx				plx
.092e	5a		phy				phy
.092f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0931	85 2e		sta $2e				sta 	zTemp1
.0933	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0935	18		clc				clc
.0936	6d 07 04	adc $0407			adc 	variableStartPage
.0939	85 2f		sta $2f				sta 	zTemp1+1
.093b	ca		dex				dex 								; count of indices to follow -> zTemp2
.093c	20 3f 10	jsr $103f			jsr 	GetInteger8Bit
.093f	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.0941	8a		txa				txa
.0942	38		sec				sec
.0943	e5 30		sbc $30				sbc 	zTemp2
.0945	aa		tax				tax
.0946	da		phx				phx 								; stack points at the first index, which will be replaced.
.0947					_ACIndexLoop:
.0947	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart 			; integer array index
.094a	20 45 10	jsr $1045			jsr 	GetInteger16Bit 			; get the index => zTemp0
.094d	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.094f	a5 2c		lda $2c				lda 	zTemp0
.0951	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0953	a5 2d		lda $2d				lda 	zTemp0+1
.0955	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0957	b0 79		bcs $09d2			bcs 	_ACBadIndex 				; index error.
.0959	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.095b	f0 29		beq $0986			beq 	_ACInnerLevel
.095d	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.095f	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0961	10 6f		bpl $09d2			bpl 	_ACBadIndex
.0963	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0965	26 2d		rol $2d				rol 	zTemp0+1
.0967	18		clc				clc
.0968	a5 2c		lda $2c				lda		zTemp0
.096a	65 2e		adc $2e				adc 	zTemp1
.096c	85 2c		sta $2c				sta 	zTemp0
.096e	a5 2d		lda $2d				lda		zTemp0+1
.0970	65 2f		adc $2f				adc 	zTemp1+1
.0972	85 2d		sta $2d				sta 	zTemp0+1
.0974	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.0976	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0978	85 2e		sta $2e				sta 	zTemp1
.097a	c8		iny				iny
.097b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.097d	18		clc				clc
.097e	6d 07 04	adc $0407			adc 	variableStartPage
.0981	85 2f		sta $2f				sta 	zTemp1+1
.0983	e8		inx				inx 								; next index
.0984	80 c1		bra $0947			bra 	_ACIndexLoop
.0986					_ACInnerLevel:
.0986	a0 02		ldy #$02			ldy 	#2
.0988	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.098a	30 46		bmi $09d2			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.098c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.098e	c9 00		cmp #$00			cmp 	#NSSIFloat
.0990	d0 13		bne $09a5			bne 	_ACNotFloat
.0992	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.0994	48		pha				pha
.0995	a5 2c		lda $2c				lda 	zTemp0
.0997	06 2c		asl $2c				asl 	zTemp0 						; x 2
.0999	26 2d		rol $2d				rol 	zTemp0+1
.099b	18		clc				clc 								; add back x 3
.099c	65 2c		adc $2c				adc 	zTemp0
.099e	85 2c		sta $2c				sta 	zTemp0
.09a0	68		pla				pla
.09a1	65 2d		adc $2d				adc 	zTemp0+1
.09a3	85 2d		sta $2d				sta 	zTemp0+1
.09a5					_ACNotFloat:
.09a5	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.09a7	26 2d		rol $2d				rol 	zTemp0+1
.09a9	18		clc				clc
.09aa	a5 2c		lda $2c				lda 	zTemp0
.09ac	69 03		adc #$03			adc 	#3
.09ae	85 2c		sta $2c				sta 	zTemp0
.09b0	90 02		bcc $09b4			bcc 	_ACNoCarry
.09b2	e6 2d		inc $2d				inc 	zTemp0+1
.09b4					_ACNoCarry:
.09b4	fa		plx				plx 								; X points to first slot of array parameters
.09b5	18		clc				clc
.09b6	a5 2c		lda $2c				lda 	zTemp0
.09b8	65 2e		adc $2e				adc 	zTemp1
.09ba	95 3e		sta $3e,x			sta 	NSMantissa0,x
.09bc	a5 2d		lda $2d				lda 	zTemp0+1
.09be	65 2f		adc $2f				adc 	zTemp1+1
.09c0	38		sec				sec
.09c1	ed 07 04	sbc $0407			sbc 	variableStartPage
.09c4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.09c6	74 56		stz $56,x			stz 	NSMantissa2,x
.09c8	74 62		stz $62,x			stz 	NSMantissa3,x
.09ca	74 32		stz $32,x			stz 	NSStatus,x
.09cc	74 6e		stz $6e,x			stz 	NSExponent,x
.09ce	7a		ply				ply 	 							; restore code pointer
.09cf	4c 4f 08	jmp $084f			jmp 	NextCommand
.09d2					_ACBadIndex:
.09d2	4c ea 1f	jmp $1fea		jmp	ErrorV_index
.09d5					UnaryAsc:
.09d5	fa		plx				plx
.09d6	5a		phy				phy
.09d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09d9	85 2c		sta $2c				sta 	zTemp0
.09db	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09dd	85 2d		sta $2d				sta 	zTemp0+1
.09df	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09e1	f0 06		beq $09e9			beq 	_UAExit
.09e3	5a		phy				phy 								; otherwise first character
.09e4	a0 01		ldy #$01			ldy 	#1
.09e6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09e8	7a		ply				ply
.09e9					_UAExit:
.09e9	20 68 26	jsr $2668			jsr 	FloatSetByte
.09ec	7a		ply				ply
.09ed	4c 4f 08	jmp $084f			jmp 	NextCommand
.09f0					CommandAssert:
.09f0	fa		plx				plx
.09f1	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09f3	d0 09		bne $09fe			bne 	_CAFail
.09f5	20 88 26	jsr $2688			jsr 	FloatIsZero 				; is it zero ?
.09f8	f0 04		beq $09fe			beq 	_CAFail
.09fa	ca		dex				dex
.09fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.09fe					_CAFail:
.09fe	4c 43 1f	jmp $1f43		jmp	ErrorV_assert
.0a01					X16_Audio_Parameters8_16:
.0a01	20 07 0a	jsr $0a07			jsr 	X16_Audio_Parameters8_8
.0a04	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.0a06	60		rts				rts
.0a07					X16_Audio_Parameters8_8:
.0a07	a2 01		ldx #$01			ldx 	#1
.0a09	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.0a0c	ca		dex				dex
.0a0d	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.0a10	20 3f 10	jsr $103f			jsr 	GetInteger8Bit
.0a13	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.0a15	a0 00		ldy #$00			ldy 	#0
.0a17	60		rts				rts
.0a18					X16_Audio_Parameters8_String:
.0a18	20 01 0a	jsr $0a01			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.0a1b	da		phx				phx 								; set the voice
.0a1c	5a		phy				phy
.0a1d	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.0a20	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>0a23	0a						.byte 	X16_AudioCodeBank
.0a24	7a		ply				ply
.0a25	fa		plx				plx
.0a26	86 2c		stx $2c				stx 	zTemp0
.0a28	84 2d		sty $2d				sty 	zTemp0+1
.0a2a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a2c	e8		inx				inx 								; point YX to first character.
.0a2d	d0 01		bne $0a30			bne 	_X16APSSkip
.0a2f	c8		iny				iny
.0a30					_X16APSSkip:
.0a30	60		rts				rts
.0a31					Unary16Bin:
.0a31	fa		plx				plx
.0a32	20 45 10	jsr $1045			jsr 	GetInteger16Bit				; 16 bit int
.0a35	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a37	20 0f 17	jsr $170f			jsr 	StringAllocTemp
.0a3a	a5 2d		lda $2d				lda 	zTemp0+1
.0a3c	f0 03		beq $0a41			beq 	_UBNoHigh
.0a3e	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a41					_UBNoHigh:
.0a41	a5 2c		lda $2c				lda 	zTemp0
.0a43	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a46	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a49					_UBWriteBinary:
.0a49	5a		phy				phy
.0a4a	a0 08		ldy #$08			ldy 	#8
.0a4c					_UBWLoop:
.0a4c	0a		asl a				asl 	a
.0a4d	48		pha				pha
.0a4e	a9 00		lda #$00			lda  	#0
.0a50	69 30		adc #$30			adc 	#48
.0a52	20 38 17	jsr $1738			jsr 	StringWriteChar
.0a55	68		pla				pla
.0a56	88		dey				dey
.0a57	d0 f3		bne $0a4c			bne 	_UBWLoop
.0a59	7a		ply				ply
.0a5a	60		rts				rts
.0a5b					PrintCharacterX:
.0a5b	fa		plx				plx
.0a5c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a5e	ca		dex				dex
.0a5f	20 6c 13	jsr $136c			jsr 	VectorPrintCharacter
.0a62	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a65					UnaryChr:
.0a65	fa		plx				plx
.0a66	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; get integer to convert.
.0a69	48		pha				pha 								; save it and allocate for it
.0a6a	a9 01		lda #$01			lda 	#1 							; 1 character
.0a6c	20 0f 17	jsr $170f			jsr 	StringAllocTemp
.0a6f	a9 01		lda #$01			lda 	#1 							; length 1.
.0a71	92 22		sta ($22)			sta 	(zsTemp)
.0a73	68		pla				pla 								; character code makes string.
.0a74	5a		phy				phy
.0a75	a0 01		ldy #$01			ldy 	#1
.0a77	91 22		sta ($22),y			sta 	(zsTemp),y
.0a79	7a		ply				ply
.0a7a	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a7d					CommandClr:
.0a7d	fa		plx				plx
.0a7e	20 84 0a	jsr $0a84			jsr 	ClearMemory
.0a81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a84					ClearMemory:
.0a84	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a87	85 2d		sta $2d				sta 	zTemp0+1
.0a89	64 2c		stz $2c				stz 	zTemp0
.0a8b	5a		phy				phy
.0a8c	a0 00		ldy #$00			ldy 	#0
.0a8e					_ClearLoop1:
.0a8e	a9 00		lda #$00			lda 	#0
.0a90	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a92	c8		iny				iny
.0a93	d0 f9		bne $0a8e			bne 	_ClearLoop1
.0a95	e6 2d		inc $2d				inc 	zTemp0+1
.0a97	a5 2d		lda $2d				lda 	zTemp0+1
.0a99	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a9c	d0 f0		bne $0a8e			bne 	_ClearLoop1
.0a9e	38		sec				sec 											; stack space = number of pages in total / 4
.0a9f	ad 06 04	lda $0406			lda 	storeEndHigh
.0aa2	ed 05 04	sbc $0405			sbc		storeStartHigh
.0aa5	4a		lsr a				lsr 	a
.0aa6	4a		lsr a				lsr 	a
.0aa7	d0 02		bne $0aab			bne 	_NotEmpty 								; at least 1 !
.0aa9	a9 01		lda #$01			lda 	#1
.0aab					_NotEmpty:
.0aab	38		sec				sec 											; subtract from high to give string high memory
.0aac	49 ff		eor #$ff			eor 	#$FF
.0aae	6d 06 04	adc $0406			adc 	storeEndHigh
.0ab1	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0ab4	9c 02 04	stz $0402			stz 	stringHighMemory
.0ab7	9c 6a 05	stz $056a			stz 	stringInitialised 						; string system not initialised
.0aba	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0abd	3a		dec a				dec 	a
.0abe	85 25		sta $25				sta 	runtimeStackPtr+1
.0ac0	a9 ff		lda #$ff			lda 	#$FF
.0ac2	85 24		sta $24				sta 	runtimeStackPtr
.0ac4	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0ac6	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0ac8	7a		ply				ply
.0ac9	60		rts				rts
.0aca					CompareStrings:
.0aca	fa		plx				plx
.0acb	ca		dex				dex
.0acc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0ace	85 2c		sta $2c				sta 	zTemp0
.0ad0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ad2	85 2d		sta $2d				sta 	zTemp0+1
.0ad4	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0ad6	85 2e		sta $2e				sta 	zTemp1
.0ad8	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0ada	85 2f		sta $2f				sta 	zTemp1+1
.0adc	da		phx				phx
.0add	5a		phy				phy
.0ade	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0ae0	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0ae2	90 02		bcc $0ae6			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0ae4	b2 2e		lda ($2e)			lda 	(zTemp1)
.0ae6					_CSNIsSmallest:
.0ae6	aa		tax				tax 								; count in X
.0ae7	f0 0c		beq $0af5			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0ae9	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0aeb					_CSNCompareString:
.0aeb	c8		iny				iny 								; pre increment
.0aec	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0aee	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0af0	d0 0a		bne $0afc			bne 	_CSNDifferent 				; numbers are different.
.0af2	ca		dex				dex
.0af3	d0 f6		bne $0aeb			bne 	_CSNCompareString 			; compare common characters in two strings.
.0af5					_CSNMatches:
.0af5	38		sec				sec
.0af6	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0af8	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0afa	f0 06		beq $0b02			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0afc					_CSNDifferent:
.0afc	a9 ff		lda #$ff			lda 	#$FF
.0afe	90 02		bcc $0b02			bcc 	_CSNSExit
.0b00	a9 01		lda #$01			lda 	#$01
.0b02					_CSNSExit:
.0b02	7a		ply				ply
.0b03	fa		plx				plx
.0b04	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0b06	20 68 26	jsr $2668			jsr 	FloatSetByte 				; output the byte
.0b09	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b0c					StringConcrete:
.0b0c	9c 6a 05	stz $056a			stz 	stringInitialised	 		; initialise next usage
.0b0f	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0b11	85 30		sta $30				sta 	zTemp2
.0b13	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0b15	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0b16	18		clc				clc
.0b17	72 30		adc ($30)			adc 	(zTemp2)
.0b19	90 02		bcc $0b1d			bcc 	_SCNoOverflow
.0b1b	a9 ff		lda #$ff			lda 	#255
.0b1d					_SCNoOverflow:
.0b1d	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0b1f	b0 02		bcs $0b23			bcs 	_SCNoMinimum
.0b21	a9 0a		lda #$0a			lda 	#10
.0b23					_SCNoMinimum:
.0b23	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0b25	38		sec				sec
.0b26	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0b29	e5 2e		sbc $2e				sbc 	zTemp1
.0b2b	a8		tay				tay
.0b2c	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b2f	e9 00		sbc #$00			sbc 	#0
.0b31	48		pha				pha
.0b32	38		sec				sec 								; subtract 3 more
.0b33	98		tya				tya
.0b34	e9 03		sbc #$03			sbc 	#3
.0b36	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b39	85 22		sta $22				sta 	zsTemp
.0b3b	68		pla				pla
.0b3c	e9 00		sbc #$00			sbc 	#0
.0b3e	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b41	85 23		sta $23				sta 	zsTemp+1
.0b43	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b45	92 22		sta ($22)			sta 	(zsTemp)
.0b47	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b49	a9 00		lda #$00			lda 	#0
.0b4b	91 22		sta ($22),y			sta 	(zsTemp),y
.0b4d	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b4f	a4 23		ldy $23				ldy 	zsTemp+1
.0b51	60		rts				rts
.0b52					CommandXData:
.0b52	fa		plx				plx
.0b53	98		tya				tya 								; data length +1 added to Y
.0b54	38		sec				sec
.0b55	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b57	a8		tay				tay
.0b58	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b5b					CommandXDIM:
.0b5b	fa		plx				plx
.0b5c	5a		phy				phy
.0b5d	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b60	8d 0a 04	sta $040a			sta 	dimType
.0b63	ca		dex				dex 								; this is the number of indices
.0b64	20 3f 10	jsr $103f			jsr 	GetInteger8Bit
.0b67	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b69	8a		txa				txa 								; dimension.
.0b6a	38		sec				sec
.0b6b	e5 2e		sbc $2e				sbc 	zTemp1
.0b6d	aa		tax				tax
.0b6e	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b70	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create one at this level
.0b73	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b75	98		tya				tya
.0b76	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b78	74 56		stz $56,x			stz 	NSMantissa2,x
.0b7a	74 62		stz $62,x			stz 	NSMantissa3,x
.0b7c	74 32		stz $32,x			stz 	NSStatus,x
.0b7e	74 6e		stz $6e,x			stz 	NSExponent,x
.0b80	7a		ply				ply
.0b81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b84					DIMCreateOneLevel:
.0b84	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b86	5a		phy				phy
.0b87	a4 27		ldy $27				ldy 	availableMemory+1
.0b89	5a		phy				phy
.0b8a	a8		tay				tay 			 					; save current level into Y
.0b8b	20 45 10	jsr $1045			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b8e	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b90	d0 02		bne $0b94			bne 	_DCOLNoCarry
.0b92	e6 2d		inc $2d				inc 	zTemp0+1
.0b94					_DCOLNoCarry:
.0b94	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b96	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b99	a5 2d		lda $2d				lda 	zTemp0+1
.0b9b	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b9e	ad 0a 04	lda $040a			lda 	dimType 					; get type information
.0ba1	29 7f		and #$7f			and 	#$7F
.0ba3	c0 01		cpy #$01			cpy 	#1
.0ba5	f0 02		beq $0ba9			beq 	_DCOLNoSubLevel
.0ba7	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0ba9					_DCOLNoSubLevel:
.0ba9	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0bac	a5 26		lda $26				lda 	availableMemory
.0bae	85 2e		sta $2e				sta 	zTemp1
.0bb0	a5 27		lda $27				lda 	availableMemory+1
.0bb2	85 2f		sta $2f				sta 	zTemp1+1
.0bb4	a5 2c		lda $2c				lda 	zTemp0
.0bb6	85 30		sta $30				sta 	zTemp2
.0bb8	a5 2d		lda $2d				lda 	zTemp0+1
.0bba	85 31		sta $31				sta 	zTemp2+1
.0bbc					_DCOLFillArray:
.0bbc	20 1b 0c	jsr $0c1b			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0bbf	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0bc1	d0 02		bne $0bc5			bne 	_DCOLNoBorrow
.0bc3	c6 2d		dec $2d				dec 	zTemp0+1
.0bc5					_DCOLNoBorrow:
.0bc5	c6 2c		dec $2c				dec 	zTemp0
.0bc7	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0bc9	05 2d		ora $2d				ora 	zTemp0+1
.0bcb	d0 ef		bne $0bbc			bne 	_DCOLFillArray
.0bcd	c0 01		cpy #$01			cpy 	#1
.0bcf	f0 42		beq $0c13			beq 	_DCOLExit
.0bd1					_DCOLRecursionLoop:
.0bd1	da		phx				phx 								; save XY
.0bd2	5a		phy				phy
.0bd3	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0bd5	48		pha				pha
.0bd6	a5 2f		lda $2f				lda 	zTemp1+1
.0bd8	48		pha				pha
.0bd9	a5 30		lda $30				lda 	zTemp2
.0bdb	48		pha				pha
.0bdc	a5 31		lda $31				lda 	zTemp2+1
.0bde	48		pha				pha
.0bdf	88		dey				dey  								; lower level -> A
.0be0	98		tya				tya
.0be1	e8		inx				inx 								; next index size
.0be2	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0be5	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0be6	86 31		stx $31				stx 	zTemp2+1
.0be8	fa		plx				plx
.0be9	86 30		stx $30				stx 	zTemp2
.0beb	fa		plx				plx
.0bec	86 2f		stx $2f				stx 	zTemp1+1
.0bee	fa		plx				plx
.0bef	86 2e		stx $2e				stx 	zTemp1
.0bf1	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0bf3	98		tya				tya
.0bf4	a0 01		ldy #$01			ldy 	#1
.0bf6	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0bf8	7a		ply				ply 								; restore XY
.0bf9	fa		plx				plx
.0bfa	18		clc				clc
.0bfb	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0bfd	69 02		adc #$02			adc 	#2
.0bff	85 2e		sta $2e				sta 	zTemp1
.0c01	90 02		bcc $0c05			bcc 	_DCOLRNoCarry
.0c03	e6 2f		inc $2f				inc 	zTemp1+1
.0c05					_DCOLRNoCarry:
.0c05	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0c07	d0 02		bne $0c0b			bne 	_DCOLRNoBorrow
.0c09	c6 31		dec $31				dec 	zTemp2+1
.0c0b					_DCOLRNoBorrow:
.0c0b	c6 30		dec $30				dec 	zTemp2
.0c0d	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0c0f	05 31		ora $31				ora 	zTemp2+1
.0c11	d0 be		bne $0bd1			bne 	_DCOLRecursionLoop
.0c13					_DCOLExit:
.0c13	68		pla				pla 								; get MSB, make offset again
.0c14	38		sec				sec
.0c15	ed 07 04	sbc $0407			sbc 	variableStartPage
.0c18	a8		tay				tay
.0c19	68		pla				pla 								; YA now contains offset address.
.0c1a	60		rts				rts
.0c1b					DIMWriteElement:
.0c1b	da		phx				phx
.0c1c	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0c1e	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0c20	d0 0b		bne $0c2d			bne 	_DIMWENotFloat
.0c22	ad 0a 04	lda $040a			lda 	dimType
.0c25	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0c27	c9 00		cmp #$00			cmp 	#NSSIFloat
.0c29	d0 02		bne $0c2d			bne 	_DIMWENotFloat
.0c2b	a2 06		ldx #$06			ldx 	#6
.0c2d					_DIMWENotFloat:
.0c2d	a9 00		lda #$00			lda 	#0
.0c2f	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0c32	ca		dex				dex
.0c33	d0 f8		bne $0c2d			bne 	_DIMWENotFloat
.0c35	fa		plx				plx
.0c36	60		rts				rts
.0c37					DIMWriteByte:
.0c37	92 26		sta ($26)			sta 	(availableMemory)
.0c39	e6 26		inc $26				inc 	availableMemory
.0c3b	d0 0b		bne $0c48			bne 	_DIMWBSkip
.0c3d	e6 27		inc $27				inc 	availableMemory+1
.0c3f	48		pha				pha
.0c40	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c42	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c45	b0 02		bcs $0c49			bcs 	_DIMWBMemory
.0c47	68		pla				pla
.0c48					_DIMWBSkip:
.0c48	60		rts				rts
.0c49					_DIMWBMemory:
.0c49	4c fd 1f	jmp $1ffd		jmp	ErrorV_memory
.040a					dimType:
>040a							.fill 	1
.0c4c					CommandEnd:
.0c4c	fa		plx				plx
.0c4d	86 2c		stx $2c				stx 	zTemp0
.0c4f					EndRuntime:
.0c4f	ae 08 04	ldx $0408			ldx 	Runtime6502SP 				; set up the stack pointer
.0c52	9a		txs				txs
.0c53	60		rts				rts
.0c54					Unimplemented:
.0c54	4c 30 1f	jmp $1f30			jmp 	ErrorV_unimplemented
.0c57					RuntimeErrorHandler:
.0c57	98		tya				tya
.0c58	18		clc				clc
.0c59	65 28		adc $28				adc 	codePtr
.0c5b	85 28		sta $28				sta 	codePtr
.0c5d	90 02		bcc $0c61			bcc 	_EHNoCarry
.0c5f	e6 29		inc $29				inc 	codePtr+1
.0c61					_EHNoCarry:
.0c61	68		pla				pla
.0c62	7a		ply				ply
.0c63	85 2c		sta $2c				sta 	zTemp0
.0c65	84 2d		sty $2d				sty 	zTemp0+1
.0c67	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c69	a0 01		ldy #$01			ldy 	#1
.0c6b					_EHDisplayMsg:
.0c6b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c6d	20 8d 1c	jsr $1c8d			jsr 	XPrintCharacterToChannel
.0c70	c8		iny				iny
.0c71	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c73	d0 f6		bne $0c6b			bne 	_EHDisplayMsg
.0c75	a9 20		lda #$20			lda 	#32
.0c77	20 8d 1c	jsr $1c8d			jsr 	XPrintCharacterToChannel
.0c7a	a9 40		lda #$40			lda 	#64
.0c7c	20 8d 1c	jsr $1c8d			jsr 	XPrintCharacterToChannel
.0c7f	a9 20		lda #$20			lda 	#32
.0c81	20 8d 1c	jsr $1c8d			jsr 	XPrintCharacterToChannel
.0c84	20 8a 0c	jsr $0c8a			jsr 	EHDisplayCodePtr
.0c87	4c 4f 0c	jmp $0c4f			jmp 	EndRuntime
.0c8a					EHDisplayCodePtr:
.0c8a	a9 24		lda #$24			lda 	#'$'
.0c8c	20 8d 1c	jsr $1c8d			jsr 	XPrintCharacterToChannel
.0c8f	38		sec				sec
.0c90	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c92	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c95	20 9e 0c	jsr $0c9e			jsr 	_EHDisplayHex
.0c98	a5 28		lda $28				lda 	codePtr
.0c9a	20 9e 0c	jsr $0c9e			jsr 	_EHDisplayHex
.0c9d	60		rts				rts
.0c9e					_EHDisplayHex:
.0c9e	48		pha				pha
.0c9f	4a		lsr a				lsr 	a
.0ca0	4a		lsr a				lsr 	a
.0ca1	4a		lsr a				lsr 	a
.0ca2	4a		lsr a				lsr 	a
.0ca3	20 a7 0c	jsr $0ca7			jsr 	_EHDisplayNibble
.0ca6	68		pla				pla
.0ca7					_EHDisplayNibble:
.0ca7	29 0f		and #$0f			and 	#15
.0ca9	c9 0a		cmp #$0a			cmp 	#10
.0cab	90 02		bcc $0caf			bcc 	_EHNotHex
.0cad	69 06		adc #$06			adc 	#6
.0caf					_EHNotHex:
.0caf	69 30		adc #$30			adc 	#48
.0cb1	4c 8d 1c	jmp $1c8d			jmp 	XPrintCharacterToChannel
.0cb4					CommandXFor:
.0cb4	fa		plx				plx
.0cb5	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0cb7	20 37 0d	jsr $0d37			jsr 	StackOpenFrame
.0cba	20 76 11	jsr $1176			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0cbd	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0cbf	20 19 0d	jsr $0d19			jsr 	CopyTOSToOffsetY
.0cc2	ca		dex				dex
.0cc3	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0cc5	20 19 0d	jsr $0d19			jsr 	CopyTOSToOffsetY
.0cc8	ca		dex				dex
.0cc9	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0ccb	29 80		and #$80			and 	#$80
.0ccd	a0 04		ldy #$04			ldy 	#4
.0ccf	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd1	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0cd3	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0cd5	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd7	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0cd9	c8		iny				iny
.0cda	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cdc	18		clc				clc
.0cdd	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0cdf	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ce1	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0ce4	85 2d		sta $2d				sta 	zTemp0+1
.0ce6	ca		dex				dex 								; throw reference.
.0ce7	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0ce9	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0ceb	a0 0c		ldy #$0c			ldy 	#12
.0ced	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cef	a0 12		ldy #$12			ldy 	#18
.0cf1	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf3	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0cf5	88		dey				dey 								; now the exponents.
.0cf6	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0cf8	a0 0b		ldy #$0b			ldy 	#11
.0cfa	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cfc	a0 11		ldy #$11			ldy 	#17
.0cfe	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d00	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0d02	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d04	c8		iny				iny
.0d05	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d07	c8		iny				iny
.0d08	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d0a	d0 08		bne $0d14			bne 	_CFNoOptimise
.0d0c	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0d0e	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0d10	09 40		ora #$40			ora 	#$40
.0d12	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d14					_CFNoOptimise:
.0d14	a0 00		ldy #$00			ldy 	#0
.0d16	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d19					CopyTOSToOffsetY:
.0d19	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0d1b	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d1d	c8		iny				iny
.0d1e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0d20	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d22	c8		iny				iny
.0d23	b5 56		lda $56,x			lda 	NSMantissa2,x
.0d25	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d27	c8		iny				iny
.0d28	b5 62		lda $62,x			lda 	NSMantissa3,x
.0d2a	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d2c	c8		iny				iny
.0d2d	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d2f	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d31	c8		iny				iny
.0d32	b5 32		lda $32,x			lda 	NSStatus,x
.0d34	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d36	60		rts				rts
.0d37					StackOpenFrame:
.0d37	48		pha				pha 								; save frame marker
.0d38	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d3a	85 2c		sta $2c				sta 	zTemp0
.0d3c	38		sec				sec 								; subtract from runtime stack pointer.
.0d3d	a5 24		lda $24				lda		runtimeStackPtr
.0d3f	e5 2c		sbc $2c				sbc 	zTemp0
.0d41	85 24		sta $24				sta 	runtimeStackPtr
.0d43	a5 25		lda $25				lda		runtimeStackPtr+1
.0d45	e9 00		sbc #$00			sbc 	#0
.0d47	85 25		sta $25				sta 	runtimeStackPtr+1
.0d49	68		pla				pla 								; put frame marker at +0
.0d4a	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d4c	60		rts				rts
.0d4d					StackCloseFrame:
.0d4d	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d4f	29 1f		and #$1f			and 	#$1F 						; size
.0d51	18		clc				clc
.0d52	65 24		adc $24				adc 	runtimeStackPtr
.0d54	85 24		sta $24				sta 	runtimeStackPtr
.0d56	90 02		bcc $0d5a			bcc 	_SCFNoCarry
.0d58	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d5a					_SCFNoCarry:
.0d5a	60		rts				rts
.0d5b					StackFindFrame:
.0d5b	8d 0b 04	sta $040b			sta 	requiredFrame
.0d5e					_SFFLoop:
.0d5e	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d60	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d62	f0 10		beq $0d74			beq 	SCFFail
.0d64	cd 0b 04	cmp $040b			cmp 	requiredFrame 				; found this type ?
.0d67	f0 05		beq $0d6e			beq 	_SFFFound
.0d69	20 4d 0d	jsr $0d4d			jsr 	StackCloseFrame 			; close the top frame
.0d6c	80 f0		bra $0d5e			bra 	_SFFLoop 					; and try te next.
.0d6e					_SFFFound:
.0d6e	60		rts				rts
.0d6f					StackCheckFrame:
.0d6f	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d71	d0 01		bne $0d74			bne 	SCFFail
.0d73	60		rts				rts
.0d74					SCFFail:
.0d74	4c 8d 1f	jmp $1f8d		jmp	ErrorV_structure
.040b					requiredFrame:
>040b							.fill 	1
.0d77					UnaryFre:
.0d77	fa		plx				plx
.0d78	20 66 26	jsr $2666			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d7b	38		sec				sec
.0d7c	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d7f	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d82	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d84	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d87	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d8a	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d8c	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d8f					CommandXGet:
.0d8f	fa		plx				plx
.0d90	e8		inx				inx
.0d91	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d93	20 0f 17	jsr $170f			jsr 	StringAllocTemp
.0d96	20 75 13	jsr $1375			jsr 	VectorGetCharacter 			; get a character
.0d99	c9 00		cmp #$00			cmp 	#0
.0d9b	f0 09		beq $0da6			beq 	_CGNone
.0d9d	5a		phy				phy
.0d9e	a0 01		ldy #$01			ldy 	#1 							; store char
.0da0	91 22		sta ($22),y			sta 	(zsTemp),y
.0da2	98		tya				tya 								; store length.
.0da3	92 22		sta ($22)			sta 	(zsTemp)
.0da5	7a		ply				ply
.0da6					_CGNone:
.0da6	4c 4f 08	jmp $084f			jmp 	NextCommand
.0da9					CommandXGosub:
.0da9	fa		plx				plx
.0daa	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dac	20 37 0d	jsr $0d37			jsr 	StackOpenFrame
.0daf	20 76 11	jsr $1176			jsr 	StackSaveCurrentPosition
.0db2	4c c7 0d	jmp $0dc7			jmp 	PerformGOTO
.0db5					CommandReturn:
.0db5	fa		plx				plx
.0db6	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0db8	20 5b 0d	jsr $0d5b			jsr 	StackFindFrame
.0dbb	20 87 11	jsr $1187			jsr 	StackLoadCurrentPosition
.0dbe	c8		iny				iny
.0dbf	c8		iny				iny
.0dc0	20 4d 0d	jsr $0d4d			jsr 	StackCloseFrame
.0dc3	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dc6					CommandXGoto:
.0dc6	fa		plx				plx
.0dc7					PerformGOTO:
.0dc7	c8		iny				iny 								; push MSB of offset on stack
.0dc8	b1 28		lda ($28),y			lda 	(codePtr),y
.0dca	48		pha				pha
.0dcb	88		dey				dey 								; point LSB of offset
.0dcc	18		clc				clc 								; add LSB
.0dcd	b1 28		lda ($28),y			lda 	(codePtr),y
.0dcf	65 28		adc $28				adc 	codePtr
.0dd1	85 28		sta $28				sta 	codePtr
.0dd3	68		pla				pla 								; restore offset MSB and add
.0dd4	65 29		adc $29				adc 	codePtr+1
.0dd6	85 29		sta $29				sta 	codePtr+1
.0dd8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ddb					CommandGotoZ:
.0ddb	fa		plx				plx
.0ddc	20 88 26	jsr $2688			jsr 	FloatIsZero
.0ddf	ca		dex				dex
.0de0	c9 00		cmp #$00			cmp 	#0
.0de2	f0 e3		beq $0dc7			beq 	PerformGOTO
.0de4	c8		iny				iny
.0de5	c8		iny				iny
.0de6	4c 4f 08	jmp $084f			jmp 	NextCommand
.0de9					CommandGotoNZ:
.0de9	fa		plx				plx
.0dea	20 88 26	jsr $2688			jsr 	FloatIsZero
.0ded	ca		dex				dex
.0dee	c9 00		cmp #$00			cmp 	#0
.0df0	d0 d5		bne $0dc7			bne 	PerformGOTO
.0df2	c8		iny				iny
.0df3	c8		iny				iny
.0df4	4c 4f 08	jmp $084f			jmp 	NextCommand
.0df7					Command_PSET:
.0df7	fa		plx				plx
.0df8	5a		phy				phy
.0df9	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; get the colour
.0dfc	48		pha				pha
.0dfd	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0dff	a0 02		ldy #$02			ldy 	#X16_r0
.0e01	20 83 0e	jsr $0e83			jsr 	GraphicsCopy2
.0e04	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0e07	68		pla				pla 								; set pixel.
.0e08	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0e0b	7a		ply				ply
.0e0c	a2 ff		ldx #$ff			ldx 	#$FF
.0e0e	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e11					Command_LINE:
.0e11	fa		plx				plx
.0e12	5a		phy				phy
.0e13	20 76 0e	jsr $0e76			jsr 	GraphicsColour
.0e16	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0e18	a0 02		ldy #$02			ldy 	#X16_r0
.0e1a	20 80 0e	jsr $0e80			jsr 	GraphicsCopy4
.0e1d	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0e20	7a		ply				ply
.0e21	a2 ff		ldx #$ff			ldx 	#$FF
.0e23	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e26					Command_RECT:
.0e26	fa		plx				plx
.0e27	5a		phy				phy
.0e28	20 97 0e	jsr $0e97			jsr 	GraphicsRectCoords
.0e2b	38		sec				sec
.0e2c	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e2f	7a		ply				ply
.0e30	a2 ff		ldx #$ff			ldx 	#$FF
.0e32	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e35					Command_FRAME:
.0e35	fa		plx				plx
.0e36	5a		phy				phy
.0e37	20 97 0e	jsr $0e97			jsr 	GraphicsRectCoords
.0e3a	18		clc				clc
.0e3b	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e3e	7a		ply				ply
.0e3f	a2 ff		ldx #$ff			ldx 	#$FF
.0e41	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e44					Command_CHAR:
.0e44	fa		plx				plx
.0e45	5a		phy				phy
.0e46	ca		dex				dex  								; set the draw colour
.0e47	20 76 0e	jsr $0e76			jsr 	GraphicsColour
.0e4a	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e4c	a0 02		ldy #$02			ldy 	#X16_r0
.0e4e	20 83 0e	jsr $0e83			jsr 	GraphicsCopy2
.0e51	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e53	85 2c		sta $2c				sta 	zTemp0
.0e55	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e57	85 2d		sta $2d				sta 	zTemp0+1
.0e59	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e5b	85 2e		sta $2e				sta 	zTemp1
.0e5d					_CCLoop:
.0e5d	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e5f	f0 0f		beq $0e70			beq 	_CCExit
.0e61	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e63	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e65	d0 02		bne $0e69			bne 	_CCNoCarry
.0e67	e6 2d		inc $2d				inc 	zTemp0+1
.0e69					_CCNoCarry:
.0e69	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e6b	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e6e	80 ed		bra $0e5d			bra 	_CCLoop						; go round.
.0e70					_CCExit:
.0e70	7a		ply				ply
.0e71	a2 ff		ldx #$ff			ldx 	#$FF
.0e73	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e76					GraphicsColour:
.0e76	20 3f 10	jsr $103f			jsr 	GetInteger8Bit
.0e79	aa		tax				tax
.0e7a	a0 00		ldy #$00			ldy 	#0
.0e7c	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e7f	60		rts				rts
.0e80					GraphicsCopy4:
.0e80	20 83 0e	jsr $0e83			jsr 	GraphicsCopy2
.0e83					GraphicsCopy2:
.0e83	20 86 0e	jsr $0e86			jsr 	GraphicsCopy1
.0e86					GraphicsCopy1:
.0e86	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.0e89	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e8b	99 00 00	sta $0000,y			sta 	0,y
.0e8e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e90	99 01 00	sta $0001,y			sta 	1,y
.0e93	e8		inx				inx
.0e94	c8		iny				iny
.0e95	c8		iny				iny
.0e96	60		rts				rts
.0e97					GraphicsRectCoords:
.0e97	20 76 0e	jsr $0e76			jsr 	GraphicsColour 				; set colour
.0e9a	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e9c	a0 02		ldy #$02			ldy 	#X16_r0
.0e9e	20 80 0e	jsr $0e80			jsr 	GraphicsCopy4
.0ea1	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0ea3	20 b0 0e	jsr $0eb0			jsr 	_GRCSortSubtract
.0ea6	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0ea8	20 b0 0e	jsr $0eb0			jsr 	_GRCSortSubtract
.0eab	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0ead	74 09		stz $09,x			stz 	9,x
.0eaf	60		rts				rts
.0eb0					_GRCSortSubtract:
.0eb0	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0eb2	d5 00		cmp $00,x			cmp 	0,x
.0eb4	b5 05		lda $05,x			lda 	5,x
.0eb6	f5 01		sbc $01,x			sbc 	1,x
.0eb8	b0 08		bcs $0ec2			bcs 	_GRCNoSwap 					; >= swap.
.0eba	20 d0 0e	jsr $0ed0			jsr 	_GRCSwapByte 				; swap 0/2
.0ebd	e8		inx				inx
.0ebe	20 d0 0e	jsr $0ed0			jsr 	_GRCSwapByte 				; swap 1/3
.0ec1	ca		dex				dex
.0ec2					_GRCNoSwap:
.0ec2	38		sec				sec 								; calculate width/height into 4,5
.0ec3	b5 04		lda $04,x			lda 	4,x
.0ec5	f5 00		sbc $00,x			sbc 	0,x
.0ec7	95 04		sta $04,x			sta 	4,x
.0ec9	b5 05		lda $05,x			lda 	5,x
.0ecb	f5 01		sbc $01,x			sbc 	1,x
.0ecd	95 05		sta $05,x			sta 	5,x
.0ecf	60		rts				rts
.0ed0					_GRCSwapByte:
.0ed0	b5 04		lda $04,x			lda 	4,x
.0ed2	48		pha				pha
.0ed3	b5 00		lda $00,x			lda 	0,x
.0ed5	95 04		sta $04,x			sta 	4,x
.0ed7	68		pla				pla
.0ed8	95 00		sta $00,x			sta 	0,x
.0eda	60		rts				rts
.0edb					Unary16Hex:
.0edb	fa		plx				plx
.0edc	20 45 10	jsr $1045			jsr 	GetInteger16Bit
.0edf	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0ee1	20 0f 17	jsr $170f			jsr 	StringAllocTemp
.0ee4	a5 2d		lda $2d				lda 	zTemp0+1
.0ee6	f0 03		beq $0eeb			beq 	_UHNoHigh
.0ee8	20 f3 0e	jsr $0ef3			jsr 	_UHWriteHex
.0eeb					_UHNoHigh:
.0eeb	a5 2c		lda $2c				lda 	zTemp0
.0eed	20 f3 0e	jsr $0ef3			jsr 	_UHWriteHex
.0ef0	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ef3					_UHWriteHex:
.0ef3	48		pha				pha
.0ef4	4a		lsr a				lsr 	a
.0ef5	4a		lsr a				lsr 	a
.0ef6	4a		lsr a				lsr 	a
.0ef7	4a		lsr a				lsr 	a
.0ef8	20 fc 0e	jsr $0efc			jsr 	_UHWriteNibl
.0efb	68		pla				pla
.0efc					_UHWriteNibl:
.0efc	29 0f		and #$0f			and 	#15
.0efe	c9 0a		cmp #$0a			cmp 	#10
.0f00	90 02		bcc $0f04			bcc 	_UHDigit
.0f02	69 06		adc #$06			adc 	#6
.0f04					_UHDigit:
.0f04	69 30		adc #$30			adc 	#48
.0f06	20 38 17	jsr $1738			jsr 	StringWriteChar
.0f09	60		rts				rts
.0f0a					IndFloatRead:
.0f0a	fa		plx				plx
.0f0b	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f0d	85 2c		sta $2c				sta 	zTemp0
.0f0f	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f11	18		clc				clc
.0f12	6d 07 04	adc $0407			adc 	variableStartPage
.0f15	85 2d		sta $2d				sta 	zTemp0+1
.0f17	ca		dex				dex 								; throw the address
.0f18	20 ee 14	jsr $14ee			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0f1b	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f1e					IndInt16Read:
.0f1e	fa		plx				plx
.0f1f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f21	85 2c		sta $2c				sta 	zTemp0
.0f23	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f25	18		clc				clc
.0f26	6d 07 04	adc $0407			adc 	variableStartPage
.0f29	85 2d		sta $2d				sta 	zTemp0+1
.0f2b	ca		dex				dex 								; throw the address
.0f2c	20 2a 15	jsr $152a			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f2f	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f32					IndStringRead:
.0f32	fa		plx				plx
.0f33	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f35	85 2c		sta $2c				sta 	zTemp0
.0f37	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f39	18		clc				clc
.0f3a	6d 07 04	adc $0407			adc 	variableStartPage
.0f3d	85 2d		sta $2d				sta 	zTemp0+1
.0f3f	ca		dex				dex 								; throw the address
.0f40	20 6f 15	jsr $156f			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f43	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f46					IndFloatWrite:
.0f46	fa		plx				plx
.0f47	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f49	85 2c		sta $2c				sta 	zTemp0
.0f4b	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f4d	18		clc				clc
.0f4e	6d 07 04	adc $0407			adc 	variableStartPage
.0f51	85 2d		sta $2d				sta 	zTemp0+1
.0f53	20 c9 1a	jsr $1ac9			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f56	ca		dex				dex 								; throw the address as well.
.0f57	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f5a					IndInt16Write:
.0f5a	fa		plx				plx
.0f5b	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f5d	85 2c		sta $2c				sta 	zTemp0
.0f5f	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f61	18		clc				clc
.0f62	6d 07 04	adc $0407			adc 	variableStartPage
.0f65	85 2d		sta $2d				sta 	zTemp0+1
.0f67	20 05 1b	jsr $1b05			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f6a	ca		dex				dex 								; throw the address as well.
.0f6b	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f6e					IndStringWrite:
.0f6e	fa		plx				plx
.0f6f	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f71	85 2c		sta $2c				sta 	zTemp0
.0f73	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f75	18		clc				clc
.0f76	6d 07 04	adc $0407			adc 	variableStartPage
.0f79	85 2d		sta $2d				sta 	zTemp0+1
.0f7b	20 44 1b	jsr $1b44			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f7e	ca		dex				dex 								; throw the address as well.
.0f7f	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f82					CommandXInput:
.0f82	fa		plx				plx
.0f83	5a		phy				phy 								; save Y
.0f84	e8		inx				inx									; space on stack
.0f85					_INError:
.0f85	20 b9 0f	jsr $0fb9			jsr 	InputStringToBuffer 		; input from keyboard
.0f88	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.0f8a	85 2c		sta $2c				sta 	0+zTemp0
.0f8c	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f8e	85 2d		sta $2d				sta 	1+zTemp0
.0f90	20 56 19	jsr $1956			jsr 	ValEvaluateZTemp0
.0f93	b0 f0		bcs $0f85			bcs 	_INError 					; failed, try again.
.0f95	7a		ply				ply 								; restore Y
.0f96	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f99					CommandInputString:
.0f99	fa		plx				plx
.0f9a	5a		phy				phy 								; save Y
.0f9b	20 b9 0f	jsr $0fb9			jsr 	InputStringToBuffer 		; input from keyboard
.0f9e	e8		inx				inx 								; make space on stack
.0f9f	20 66 26	jsr $2666			jsr 	FloatSetZero 				; store as string on stack
.0fa2	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.0fa4	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0fa6	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0fa8	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0faa	a9 40		lda #$40			lda 	#NSSString
.0fac	95 32		sta $32,x			sta 	NSStatus,x
.0fae	7a		ply				ply 								; restore Y
.0faf	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fb2					CommandInputReset:
.0fb2	fa		plx				plx
.0fb3	9c 0c 04	stz $040c			stz 	InputBuffer
.0fb6	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fb9					InputStringToBuffer:
.0fb9	a9 f3		lda #$f3			lda 	#((InputBumpNext) & $FF)
.0fbb	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.0fbe	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0fc0	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.0fc3	a9 d0		lda #$d0			lda 	#((InputLookNext) & $FF)
.0fc5	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.0fc8	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0fca	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.0fcd	4c 4b 14	jmp $144b			jmp 	GetStringToBuffer
.0fd0					InputLookNext:
.0fd0	da		phx				phx
.0fd1					_ILNRetry:
.0fd1	ad 0c 04	lda $040c			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fd4	d0 08		bne $0fde			bne 	_ILNNotEmpty
.0fd6	20 f7 0f	jsr $0ff7			jsr 	InputGetNewLine 			; get a new line
.0fd9	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset read position.
.0fdc	80 f3		bra $0fd1			bra 	_ILNRetry
.0fde					_ILNNotEmpty:
.0fde	ae 5d 04	ldx $045d			ldx 	InputBufferPos 				; get head available character
.0fe1	bd 0c 04	lda $040c,x			lda 	InputBuffer,x
.0fe4	d0 08		bne $0fee			bne 	_ILNExit 					; if not EOS return it with CC.
.0fe6					_ILNNextLine:
.0fe6	9c 0c 04	stz $040c			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0fe9	38		sec				sec 								; return CS,Zero
.0fea	fa		plx				plx
.0feb	a9 0d		lda #$0d			lda 	#13
.0fed	60		rts				rts
.0fee					_ILNExit:
.0fee	fa		plx				plx
.0fef	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0ff1	18		clc				clc
.0ff2	60		rts				rts
.0ff3					InputBumpNext:
.0ff3	ee 5d 04	inc $045d			inc 	InputBufferPos
.0ff6	60		rts				rts
.0ff7					InputGetNewLine:
.0ff7	48		pha				pha
.0ff8	da		phx				phx
.0ff9	5a		phy				phy
.0ffa	a9 3f		lda #$3f			lda 	#"?"
.0ffc	20 36 10	jsr $1036			jsr 	IGNLEchoIfScreen
.0fff	a0 00		ldy #$00			ldy 	#0 							; line position.
.1001					_IGNLLoop:
.1001	20 75 13	jsr $1375			jsr 	VectorGetCharacter 			; get a character
.1004	c9 00		cmp #$00			cmp 	#0
.1006	f0 f9		beq $1001			beq 	_IGNLLoop
.1008	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.100a	f0 11		beq $101d			beq 	_IGNBackspace
.100c	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.100e	f0 17		beq $1027			beq 	_IGNExit
.1010	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.1012	f0 ed		beq $1001			beq 	_IGNLLoop
.1014	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1017	c8		iny				iny
.1018	20 36 10	jsr $1036			jsr 	IGNLEchoIfScreen
.101b	80 e4		bra $1001			bra 	_IGNLLoop
.101d					_IGNBackspace:
.101d	c0 00		cpy #$00			cpy 	#0
.101f	f0 e0		beq $1001			beq 	_IGNLLoop
.1021	20 36 10	jsr $1036			jsr 	IGNLEchoIfScreen
.1024	88		dey				dey
.1025	80 da		bra $1001			bra 	_IGNLLoop
.1027					_IGNExit:
.1027	20 36 10	jsr $1036			jsr 	IGNLEchoIfScreen
.102a	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.102c	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.102f	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset position to start of input buffer.
.1032	7a		ply				ply
.1033	fa		plx				plx
.1034	68		pla				pla
.1035	60		rts				rts
.1036					IGNLEchoIfScreen:
.1036	ae 5f 04	ldx $045f			ldx 	currentChannel
.1039	d0 03		bne $103e			bne 	_IGNLEExit
.103b	20 6c 13	jsr $136c			jsr 	VectorPrintCharacter
.103e					_IGNLEExit:
.103e	60		rts				rts
.040c					InputBuffer:
>040c							.fill 	81
.045d					InputBufferPos:
>045d							.fill 	1
.103f					GetInteger8Bit:
.103f	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.1042	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1044	60		rts				rts
.1045					GetInteger16Bit:
.1045	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.1048	34 32		bit $32,x			bit 	NSStatus,x
.104a	30 09		bmi $1055			bmi 	Negate16Bit
.104c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.104e	85 2c		sta $2c				sta 	zTemp0
.1050	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1052	85 2d		sta $2d				sta 	zTemp0+1
.1054	60		rts				rts
.1055					Negate16Bit:
.1055	38		sec				sec
.1056	a9 00		lda #$00			lda 	#0
.1058	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.105a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.105c	85 2c		sta $2c				sta 	zTemp0
.105e	a9 00		lda #$00			lda 	#0
.1060	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1062	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1064	85 2d		sta $2d				sta 	zTemp0+1
.1066	60		rts				rts
.1067					UnaryJoy:
.1067	fa		plx				plx
.1068	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; port #
.106b	48		pha				pha 								; zero the result.
.106c	20 66 26	jsr $2666			jsr 	FloatSetZero
.106f	68		pla				pla
.1070	5a		phy				phy
.1071	da		phx				phx
.1072	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1075	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1077	d0 10		bne $1089			bne 	_UJNoHardware
.1079	a8		tay				tay 								; move XA -> AY
.107a	8a		txa				txa
.107b	fa		plx				plx 								; we can update it now.
.107c	49 ff		eor #$ff			eor 	#$FF
.107e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1080	98		tya				tya
.1081	49 ff		eor #$ff			eor 	#$FF
.1083	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1085	7a		ply				ply 								; restore Y
.1086	4c 4f 08	jmp $084f			jmp 	NextCommand
.1089					_UJNoHardware:
.1089	fa		plx				plx
.108a	7a		ply				ply
.108b	a9 01		lda #$01			lda 	#1 							; set result to -1
.108d	20 68 26	jsr $2668			jsr 	FloatSetByte
.1090	20 28 26	jsr $2628			jsr 	FloatNegate
.1093	4c 4f 08	jmp $084f			jmp 	NextCommand
.1096					UnaryLen:
.1096	fa		plx				plx
.1097	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.1099	85 2c		sta $2c				sta 	zTemp0
.109b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.109d	85 2d		sta $2d				sta 	zTemp0+1
.109f	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.10a1	20 68 26	jsr $2668			jsr 	FloatSetByte
.10a4	4c 4f 08	jmp $084f			jmp 	NextCommand
.10a7					LinkFloatAdd:
.10a7	fa		plx				plx
.10a8	5a		phy			phy
.10a9	20 8a 20	jsr $208a		jsr	FloatAdd
.10ac	7a		ply			ply
.10ad	4c 4f 08	jmp $084f			jmp 	NextCommand
.10b0					LinkFloatSubtract:
.10b0	fa		plx				plx
.10b1	5a		phy			phy
.10b2	20 84 20	jsr $2084		jsr	FloatSubtract
.10b5	7a		ply			ply
.10b6	4c 4f 08	jmp $084f			jmp 	NextCommand
.10b9					LinkFloatMultiply:
.10b9	fa		plx				plx
.10ba	5a		phy			phy
.10bb	20 26 23	jsr $2326		jsr	FloatMultiply
.10be	7a		ply			ply
.10bf	4c 4f 08	jmp $084f			jmp 	NextCommand
.10c2					LinkFloatDivide:
.10c2	fa		plx				plx
.10c3	5a		phy			phy
.10c4	20 af 21	jsr $21af		jsr	FloatDivide
.10c7	b0 5c		bcs $1125		bcs	DivZeroError
.10c9	7a		ply			ply
.10ca	4c 4f 08	jmp $084f			jmp 	NextCommand
.10cd					LinkFloatPower:
.10cd	fa		plx				plx
.10ce	5a		phy			phy
.10cf	20 2f 29	jsr $292f		jsr	FloatPower
.10d2	b0 4e		bcs $1122		bcs	MapRangeError
.10d4	7a		ply			ply
.10d5	4c 4f 08	jmp $084f			jmp 	NextCommand
.10d8					LinkCompareGreater:
.10d8	fa		plx				plx
.10d9	5a		phy			phy
.10da	20 33 21	jsr $2133		jsr	CompareGreater
.10dd	7a		ply			ply
.10de	4c 4f 08	jmp $084f			jmp 	NextCommand
.10e1					LinkCompareEqual:
.10e1	fa		plx				plx
.10e2	5a		phy			phy
.10e3	20 15 21	jsr $2115		jsr	CompareEqual
.10e6	7a		ply			ply
.10e7	4c 4f 08	jmp $084f			jmp 	NextCommand
.10ea					LinkCompareLess:
.10ea	fa		plx				plx
.10eb	5a		phy			phy
.10ec	20 2b 21	jsr $212b		jsr	CompareLess
.10ef	7a		ply			ply
.10f0	4c 4f 08	jmp $084f			jmp 	NextCommand
.10f3					LinkCompareGreaterEqual:
.10f3	fa		plx				plx
.10f4	5a		phy			phy
.10f5	20 43 21	jsr $2143		jsr	CompareGreaterEqual
.10f8	7a		ply			ply
.10f9	4c 4f 08	jmp $084f			jmp 	NextCommand
.10fc					LinkCompareNotEqual:
.10fc	fa		plx				plx
.10fd	5a		phy			phy
.10fe	20 25 21	jsr $2125		jsr	CompareNotEqual
.1101	7a		ply			ply
.1102	4c 4f 08	jmp $084f			jmp 	NextCommand
.1105					LinkCompareLessEqual:
.1105	fa		plx				plx
.1106	5a		phy			phy
.1107	20 3b 21	jsr $213b		jsr	CompareLessEqual
.110a	7a		ply			ply
.110b	4c 4f 08	jmp $084f			jmp 	NextCommand
.110e					LinkFloatIntegerPartDown:
.110e	fa		plx				plx
.110f	5a		phy			phy
.1110	20 c5 22	jsr $22c5		jsr	FloatIntegerPartDown
.1113	7a		ply			ply
.1114	4c 4f 08	jmp $084f			jmp 	NextCommand
.1117					LinkFloatSquareRoot:
.1117	fa		plx				plx
.1118	5a		phy			phy
.1119	20 b1 29	jsr $29b1		jsr	FloatSquareRoot
.111c	b0 04		bcs $1122		bcs	MapRangeError
.111e	7a		ply			ply
.111f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1122					MapRangeError:
.1122	4c f2 1e	jmp $1ef2		jmp	ErrorV_range
.1125					DivZeroError:
.1125	4c 7b 1f	jmp $1f7b		jmp	ErrorV_divzero
.1128					LinkFloatLogarithm:
.1128	fa		plx				plx
.1129	5a		phy			phy
.112a	20 bb 28	jsr $28bb		jsr	FloatLogarithm
.112d	b0 f3		bcs $1122		bcs	MapRangeError
.112f	7a		ply			ply
.1130	4c 4f 08	jmp $084f			jmp 	NextCommand
.1133					LinkFloatExponent:
.1133	fa		plx				plx
.1134	5a		phy			phy
.1135	20 b8 27	jsr $27b8		jsr	FloatExponent
.1138	7a		ply			ply
.1139	4c 4f 08	jmp $084f			jmp 	NextCommand
.113c					LinkFloatCosine:
.113c	fa		plx				plx
.113d	5a		phy			phy
.113e	20 ac 27	jsr $27ac		jsr	FloatCosine
.1141	7a		ply			ply
.1142	4c 4f 08	jmp $084f			jmp 	NextCommand
.1145					LinkFloatSine:
.1145	fa		plx				plx
.1146	5a		phy			phy
.1147	20 4c 29	jsr $294c		jsr	FloatSine
.114a	7a		ply			ply
.114b	4c 4f 08	jmp $084f			jmp 	NextCommand
.114e					LinkFloatTangent:
.114e	fa		plx				plx
.114f	5a		phy			phy
.1150	20 bd 29	jsr $29bd		jsr	FloatTangent
.1153	7a		ply			ply
.1154	4c 4f 08	jmp $084f			jmp 	NextCommand
.1157					LinkFloatArcTan:
.1157	fa		plx				plx
.1158	5a		phy			phy
.1159	20 91 26	jsr $2691		jsr	FloatArcTan
.115c	b0 c4		bcs $1122		bcs	MapRangeError
.115e	7a		ply			ply
.115f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1162					LinkFloatCompare:
.1162	fa		plx				plx
.1163	5a		phy			phy
.1164	20 4b 21	jsr $214b		jsr	FloatCompare
.1167	7a		ply			ply
.1168	4c 4f 08	jmp $084f			jmp 	NextCommand
.116b					LinkDivideInt32:
.116b	fa		plx				plx
.116c	5a		phy			phy
.116d	20 d9 21	jsr $21d9		jsr	DivideInt32
.1170	b0 b0		bcs $1122		bcs	MapRangeError
.1172	7a		ply			ply
.1173	4c 4f 08	jmp $084f			jmp 	NextCommand
.1176					StackSaveCurrentPosition:
.1176	20 cb 08	jsr $08cb			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.1179	5a		phy				phy
.117a	a0 02		ldy #$02			ldy 	#2
.117c	a5 28		lda $28				lda 	codePtr
.117e	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1180	c8		iny				iny
.1181	a5 29		lda $29				lda 	codePtr+1
.1183	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1185	7a		ply				ply
.1186	60		rts				rts
.1187					StackLoadCurrentPosition:
.1187	a0 02		ldy #$02			ldy 	#2
.1189	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.118b	85 28		sta $28				sta 	codePtr
.118d	c8		iny				iny
.118e	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1190	85 29		sta $29				sta 	codePtr+1
.1192	a0 00		ldy #$00			ldy 	#0
.1194	60		rts				rts
.1195					XCommandMouse:
.1195	fa		plx				plx
.1196	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; mouse control.
.1199	ca		dex				dex
.119a	da		phx				phx
.119b	5a		phy				phy
.119c	48		pha				pha
.119d	38		sec				sec 								; get screen resolution
.119e	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.11a1	68		pla				pla
.11a2	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.11a5	7a		ply				ply
.11a6	fa		plx				plx
.11a7	4c 4f 08	jmp $084f			jmp 	NextCommand
.11aa					XUnaryMB:
.11aa	fa		plx				plx
.11ab	20 d9 11	jsr $11d9			jsr 	XUnaryMouseCommon
.11ae	a5 30		lda $30				lda 	zTemp2
.11b0	e8		inx				inx
.11b1	20 68 26	jsr $2668			jsr 	FloatSetByte
.11b4	4c 4f 08	jmp $084f			jmp 	NextCommand
.11b7					XUnaryMX:
.11b7	fa		plx				plx
.11b8	20 d9 11	jsr $11d9			jsr 	XUnaryMouseCommon
.11bb	a5 2c		lda $2c				lda 	zTemp0
.11bd	e8		inx				inx
.11be	20 68 26	jsr $2668			jsr 	FloatSetByte
.11c1	a5 2d		lda $2d				lda 	zTemp0+1
.11c3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11c5	4c 4f 08	jmp $084f			jmp 	NextCommand
.11c8					XUnaryMY:
.11c8	fa		plx				plx
.11c9	20 d9 11	jsr $11d9			jsr 	XUnaryMouseCommon
.11cc	a5 2e		lda $2e				lda 	zTemp1
.11ce	e8		inx				inx
.11cf	20 68 26	jsr $2668			jsr 	FloatSetByte
.11d2	a5 2f		lda $2f				lda 	zTemp1+1
.11d4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11d6	4c 4f 08	jmp $084f			jmp 	NextCommand
.11d9					XUnaryMouseCommon:
.11d9	da		phx				phx
.11da	5a		phy				phy
.11db	a2 2c		ldx #$2c			ldx 	#zTemp0
.11dd	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.11e0	85 30		sta $30				sta 	zTemp2
.11e2	7a		ply				ply
.11e3	fa		plx				plx
.11e4	60		rts				rts
.11e5					NegateTOS:
.11e5	fa		plx				plx
.11e6	20 28 26	jsr $2628			jsr 	FloatNegate
.11e9	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ec					CommandNewLine:
.11ec	fa		plx				plx
.11ed	9c 6a 05	stz $056a			stz 	stringInitialised
.11f0	a2 ff		ldx #$ff			ldx 	#$FF
.11f2	4c 4f 08	jmp $084f			jmp 	NextCommand
.11f5					CommandXNext:
.11f5	fa		plx				plx
.11f6					_CNRetry:
.11f6	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.11f8	20 5b 0d	jsr $0d5b			jsr 	StackFindFrame
.11fb	20 cb 08	jsr $08cb			jsr 	FixUpY 						; so we can use Y
.11fe	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.1200	35 4a		and $4a,x			and 	NSMantissa1,x
.1202	c9 ff		cmp #$ff			cmp 	#$FF
.1204	f0 16		beq $121c			beq 	_CNNoIndexVariable
.1206	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1208	a0 05		ldy #$05			ldy 	#5
.120a	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.120c	d0 07		bne $1215			bne 	_CNNIndexFail
.120e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1210	c8		iny				iny
.1211	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.1213	f0 07		beq $121c			beq 	_CNNoIndexVariable
.1215					_CNNIndexFail:
.1215	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.1217	20 4d 0d	jsr $0d4d			jsr 	StackCloseFrame 			; close this frame
.121a	80 da		bra $11f6			bra 	_CNRetry
.121c					_CNNoIndexVariable:
.121c	ca		dex				dex
.121d	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.121f	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1221	29 40		and #$40			and 	#$40	 					; bit 6
.1223	d0 55		bne $127a			bne 	_CNOptimisedNext
.1225	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1227	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1229	48		pha				pha
.122a	85 2c		sta $2c				sta 	zTemp0
.122c	c8		iny				iny
.122d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.122f	18		clc				clc
.1230	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1233	48		pha				pha
.1234	85 2d		sta $2d				sta 	zTemp0+1
.1236	20 ee 14	jsr $14ee			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.1239	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.123b	e8		inx				inx
.123c	20 bd 12	jsr $12bd			jsr 	CopyOffsetYToTOS
.123f	20 8a 20	jsr $208a			jsr 	FloatAdd
.1242	68		pla				pla 								; restore address
.1243	85 2d		sta $2d				sta 	zTemp0+1
.1245	68		pla				pla
.1246	85 2c		sta $2c				sta 	zTemp0
.1248	20 c9 1a	jsr $1ac9			jsr 	WriteFloatZTemp0Sub			; write float.
.124b	e8		inx				inx  								; recover written
.124c	e8		inx				inx 								; load offset
.124d	a0 0d		ldy #$0d			ldy 	#13
.124f	20 bd 12	jsr $12bd			jsr 	CopyOffsetYToTOS
.1252	20 4b 21	jsr $214b			jsr 	FloatCompare 				; and compare the floats.
.1255	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1256	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.1258	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.125a	30 08		bmi $1264			bmi 	_CNDownStep
.125c	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.125e	c9 01		cmp #$01			cmp 	#1 							; gone higher
.1260	f0 10		beq $1272			beq 	_CNExitFor 					; if so exit the loop
.1262	80 06		bra $126a			bra 	_CNLoopBack
.1264					_CNDownStep:
.1264	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1266	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.1268	f0 08		beq $1272			beq 	_CNExitFor
.126a					_CNLoopBack:
.126a	20 87 11	jsr $1187			jsr 	StackLoadCurrentPosition 	; loop back
.126d	a0 00		ldy #$00			ldy 	#0
.126f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1272					_CNExitFor:
.1272	20 4d 0d	jsr $0d4d			jsr 	StackCloseFrame 			; remove the frame and exit
.1275	a0 00		ldy #$00			ldy 	#0
.1277	4c 4f 08	jmp $084f			jmp 	NextCommand
.127a					_CNOptimisedNext:
.127a	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.127c	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.127e	85 2c		sta $2c				sta 	zTemp0
.1280	c8		iny				iny
.1281	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1283	18		clc				clc
.1284	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1287	85 2d		sta $2d				sta 	zTemp0+1
.1289	a0 07		ldy #$07			ldy 	#7 							; STEP value
.128b	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.128d	a0 ff		ldy #$ff			ldy 	#$FF
.128f	18		clc				clc
.1290					_CNOIncrement:
.1290	c8		iny				iny
.1291	71 2c		adc ($2c),y			adc 	(zTemp0),y
.1293	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1295	f0 f9		beq $1290			beq 	_CNOIncrement
.1297	18		clc				clc
.1298	a5 24		lda $24				lda 	runtimeStackPtr
.129a	69 0d		adc #$0d			adc 	#13
.129c	85 2e		sta $2e				sta 	zTemp1
.129e	a5 25		lda $25				lda 	runtimeStackPtr+1
.12a0	69 00		adc #$00			adc 	#0
.12a2	85 2f		sta $2f				sta 	zTemp1+1
.12a4	a0 00		ldy #$00			ldy 	#0
.12a6	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.12a8	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.12aa	c8		iny				iny
.12ab	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.12ad	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12af	c8		iny				iny
.12b0	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.12b2	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12b4	c8		iny				iny
.12b5	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.12b7	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12b9	90 b7		bcc $1272			bcc	 	_CNExitFor
.12bb	80 ad		bra $126a			bra 	_CNLoopBack
.12bd					CopyOffsetYToTOS:
.12bd	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12bf	95 3e		sta $3e,x			sta 	NSMantissa0,x
.12c1	c8		iny				iny
.12c2	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12c6	c8		iny				iny
.12c7	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c9	95 56		sta $56,x			sta 	NSMantissa2,x
.12cb	c8		iny				iny
.12cc	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12ce	95 62		sta $62,x			sta 	NSMantissa3,x
.12d0	c8		iny				iny
.12d1	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d3	95 6e		sta $6e,x			sta 	NSExponent,x
.12d5	c8		iny				iny
.12d6	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d8	95 32		sta $32,x			sta 	NSStatus,x
.12da	60		rts				rts
.12db	4c 4f 08	jmp $084f			jmp 	NextCommand
.12de					NotTOS:
.12de	fa		plx				plx
.12df	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.12e2	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.12e4	74 62		stz $62,x			stz 	NSMantissa3,x
.12e6	20 28 26	jsr $2628			jsr 	FloatNegate		 			; negate
.12e9	e8		inx				inx 								; and subtract 1.
.12ea	a9 01		lda #$01			lda 	#1
.12ec	20 68 26	jsr $2668			jsr 	FloatSetByte
.12ef	20 84 20	jsr $2084			jsr 	FloatSubtract
.12f2					_NotTOSSkip:
.12f2	4c 4f 08	jmp $084f			jmp 	NextCommand
.12f5					CommandXOn:
.12f5	fa		plx				plx
.12f6	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.12f9	8d 5e 04	sta $045e			sta 	onCount 					; save it.
.12fc	20 cb 08	jsr $08cb			jsr 	FixUpY 						; Y = 0
.12ff					_CONFind:
.12ff	ce 5e 04	dec $045e			dec 	onCount 					; reached zero, do this one
.1302	f0 0b		beq $130f			beq 	_CONFound
.1304	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1305	c8		iny				iny
.1306	c8		iny				iny
.1307	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.1309	c8		iny				iny
.130a	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.130c	f0 f1		beq $12ff			beq 	_CONFind
.130e	88		dey				dey 								; point to character after last GOTO/GOSUB
.130f					_CONFound:
.130f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1312					CommandMoreOn:
.1312	fa		plx				plx
.1313	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1314	c8		iny				iny
.1315	c8		iny				iny
.1316	4c 4f 08	jmp $084f			jmp 	NextCommand
.045e					onCount:
>045e							.fill 	1
.1319					UnaryPeek:
.1319	fa		plx				plx
.131a	20 45 10	jsr $1045			jsr 	GetInteger16Bit
.131d	da		phx				phx
.131e	5a		phy				phy
.131f	a6 2c		ldx $2c				ldx 	zTemp0
.1321	a4 2d		ldy $2d				ldy 	zTemp0+1
.1323	20 63 1c	jsr $1c63			jsr 	XPeekMemory
.1326	7a		ply				ply
.1327	fa		plx				plx
.1328	20 68 26	jsr $2668			jsr 	FloatSetByte
.132b	4c 4f 08	jmp $084f			jmp 	NextCommand
.132e					CommandPOKE:
.132e	fa		plx				plx
.132f	da		phx				phx 								; save XY
.1330	5a		phy				phy
.1331	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1334	48		pha				pha
.1335	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1337	a8		tay				tay
.1338	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.133a	aa		tax				tax
.133b	68		pla				pla
.133c	20 4f 1c	jsr $1c4f			jsr 	XPokeMemory
.133f	7a		ply				ply 								; restore YX and drop 2
.1340	fa		plx				plx
.1341	ca		dex				dex
.1342	ca		dex				dex
.1343	4c 4f 08	jmp $084f			jmp 	NextCommand
.1346					UnaryPos:
.1346	fa		plx				plx
.1347	20 e2 1b	jsr $1be2			jsr 	XGetHPos
.134a	20 68 26	jsr $2668			jsr 	FloatSetByte
.134d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1350					GetChannel:
.1350	fa		plx				plx
.1351	ad 5f 04	lda $045f			lda 	currentChannel
.1354	e8		inx				inx
.1355	20 68 26	jsr $2668			jsr 	FloatSetByte
.1358	4c 4f 08	jmp $084f			jmp 	NextCommand
.135b					SetChannel:
.135b	fa		plx				plx
.135c	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.135f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1361	8d 5f 04	sta $045f			sta 	currentChannel
.1364	ca		dex				dex
.1365	4c 4f 08	jmp $084f			jmp 	NextCommand
.1368					SetDefaultChannel:
.1368	9c 5f 04	stz $045f			stz 	currentChannel
.136b	60		rts				rts
.136c					VectorPrintCharacter:
.136c	da		phx				phx
.136d	ae 5f 04	ldx $045f			ldx 	currentChannel
.1370	20 8d 1c	jsr $1c8d			jsr 	XPrintCharacterToChannel
.1373	fa		plx				plx
.1374	60		rts				rts
.1375					VectorGetCharacter:
.1375	da		phx				phx
.1376	ae 5f 04	ldx $045f			ldx 	currentChannel
.1379	20 c6 1b	jsr $1bc6			jsr 	XGetCharacterFromChannel
.137c	fa		plx				plx
.137d	60		rts				rts
.045f					currentChannel:
>045f							.fill 	1
.137e					PrintNumber:
.137e	fa		plx				plx
.137f	a9 07		lda #$07			lda 	#7
.1381	20 4e 25	jsr $254e			jsr 	FloatToString 				; to number in decimal buffer
.1384	ca		dex				dex 								; drop
.1385	da		phx				phx
.1386	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1388					_PNLoop:
.1388	bd 98 05	lda $0598,x			lda 	decimalBuffer,x
.138b	20 6c 13	jsr $136c			jsr 	VectorPrintCharacter
.138e	e8		inx				inx
.138f	bd 98 05	lda $0598,x			lda	 	decimalBuffer,x
.1392	d0 f4		bne $1388			bne 	_PNLoop
.1394	a9 20		lda #$20			lda 	#32 						; trailing space
.1396	20 6c 13	jsr $136c			jsr 	VectorPrintCharacter
.1399	fa		plx				plx
.139a	4c 4f 08	jmp $084f			jmp 	NextCommand
.139d					PrintString:
.139d	fa		plx				plx
.139e	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.13a0	85 2c		sta $2c				sta 	zTemp0
.13a2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.13a4	85 2d		sta $2d				sta 	zTemp0+1
.13a6	ca		dex				dex 								; drop
.13a7	da		phx				phx
.13a8	5a		phy				phy
.13a9	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.13ab	aa		tax				tax
.13ac	a0 01		ldy #$01			ldy 	#1 							; Y = position
.13ae					_PSLoop:
.13ae	e0 00		cpx #$00			cpx 	#0 							; complete ?
.13b0	f0 09		beq $13bb			beq 	_PSExit
.13b2	ca		dex				dex 								; dec count
.13b3	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.13b5	20 6c 13	jsr $136c			jsr 	VectorPrintCharacter
.13b8	c8		iny				iny
.13b9	80 f3		bra $13ae			bra 	_PSLoop
.13bb					_PSExit:
.13bb	7a		ply				ply
.13bc	fa		plx				plx
.13bd	4c 4f 08	jmp $084f			jmp 	NextCommand
.13c0					CommandPushN:
.13c0	fa		plx				plx
.13c1	e8		inx				inx 								; next slot on stack
.13c2	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.13c4	95 6e		sta $6e,x			sta 	NSExponent,x
.13c6	c8		iny				iny
.13c7	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.13c9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13cb	c8		iny				iny
.13cc	b1 28		lda ($28),y			lda 	(codePtr),y
.13ce	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13d0	c8		iny				iny
.13d1	b1 28		lda ($28),y			lda 	(codePtr),y
.13d3	95 56		sta $56,x			sta 	NSMantissa2,x
.13d5	c8		iny				iny
.13d6	b1 28		lda ($28),y			lda 	(codePtr),y
.13d8	48		pha				pha
.13d9	29 7f		and #$7f			and 	#$7F
.13db	95 62		sta $62,x			sta 	NSMantissa3,x
.13dd	68		pla				pla 								; sign in mantissa3:7
.13de	29 80		and #$80			and 	#$80
.13e0	95 32		sta $32,x			sta 	NSStatus,x
.13e2	c8		iny				iny
.13e3	4c 4f 08	jmp $084f			jmp 	NextCommand
.13e6					CommandPushS:
.13e6	fa		plx				plx
.13e7	e8		inx				inx 								; next slot on stack
.13e8	18		clc				clc
.13e9	98		tya				tya
.13ea	65 28		adc $28				adc 	codePtr 					; the string is inline
.13ec	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13ee	a5 29		lda $29				lda 	codePtr+1
.13f0	69 00		adc #$00			adc 	#0
.13f2	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13f4	74 56		stz $56,x			stz 	NSMantissa2,x
.13f6	74 62		stz $62,x			stz 	NSMantissa3,x
.13f8	a9 40		lda #$40			lda 	#NSSString
.13fa	95 32		sta $32,x			sta 	NSStatus,x
.13fc	98		tya				tya 								; string length +1 added to Y
.13fd	38		sec				sec
.13fe	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.1400	a8		tay				tay
.1401	4c 4f 08	jmp $084f			jmp 	NextCommand
.1404					CommandXRead:
.1404	fa		plx				plx
.1405	5a		phy				phy 								; save Y
.1406	20 37 14	jsr $1437			jsr 	ReadStringToBuffer 			; read element into buffer
.1409	e8		inx				inx									; space on stack
.140a	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.140c	85 2c		sta $2c				sta 	0+zTemp0
.140e	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.1410	85 2d		sta $2d				sta 	1+zTemp0
.1412	20 56 19	jsr $1956			jsr 	ValEvaluateZTemp0
.1415	b0 04		bcs $141b			bcs 	_CRError 					; failed
.1417	7a		ply				ply 								; restore Y
.1418	4c 4f 08	jmp $084f			jmp 	NextCommand
.141b					_CRError:
.141b	4c 02 1f	jmp $1f02		jmp	ErrorV_value
.141e					CommandReadString:
.141e	fa		plx				plx
.141f	5a		phy				phy 								; save Y
.1420	20 37 14	jsr $1437			jsr 	ReadStringToBuffer 			; read text
.1423	e8		inx				inx 								; make space on stack
.1424	20 66 26	jsr $2666			jsr 	FloatSetZero 				; store as string on stack
.1427	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.1429	95 3e		sta $3e,x			sta 	NSMantissa0,x
.142b	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.142d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.142f	a9 40		lda #$40			lda 	#NSSString
.1431	95 32		sta $32,x			sta 	NSStatus,x
.1433	7a		ply				ply 								; restore Y
.1434	4c 4f 08	jmp $084f			jmp 	NextCommand
.1437					ReadStringToBuffer:
.1437	a9 ca		lda #$ca			lda 	#((ReadBumpNext) & $FF)
.1439	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.143c	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.143e	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.1441	a9 9d		lda #$9d			lda 	#((ReadLookNext) & $FF)
.1443	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.1446	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.1448	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.144b					GetStringToBuffer:
.144b	20 9a 14	jsr $149a			jsr		GetLookNext 				; skip all leading spaces.
.144e	f0 44		beq $1494			beq 	_RBError 					; end of data
.1450	b0 f9		bcs $144b			bcs 	GetStringToBuffer 			; switched to new data line.
.1452	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1454	b0 05		bcs $145b			bcs 	_RBNoSpace
.1456	20 97 14	jsr $1497			jsr 	GetBumpNext 				; consume space and loop round.
.1459	80 f0		bra $144b			bra 	GetStringToBuffer
.145b					_RBNoSpace:
.145b	9c 61 04	stz $0461			stz 	ReadBufferSize 				; empty the buffer.
.145e	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.1460	d0 08		bne $146a			bne 	_RBCommaSep
.1462	8d 60 04	sta $0460			sta 	ReadSep 					; use as a seperator
.1465	20 97 14	jsr $1497			jsr 	GetBumpNext 				; consume the '"'
.1468	80 05		bra $146f			bra 	_RBGetText
.146a					_RBCommaSep:
.146a	a9 2c		lda #$2c			lda 	#","						; get till comma
.146c	8d 60 04	sta $0460			sta 	ReadSep
.146f					_RBGetText:
.146f	20 9a 14	jsr $149a			jsr 	GetLookNext 				; what follows
.1472	b0 18		bcs $148c			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.1474	20 97 14	jsr $1497			jsr 	GetBumpNext 				; consume it whatever
.1477	cd 60 04	cmp $0460			cmp 	ReadSep 					; if found the seperator.
.147a	f0 10		beq $148c			beq 	_RBEndGet 					; exit after consumption
.147c	da		phx				phx
.147d	ae 61 04	ldx $0461			ldx 	ReadBufferSize 				; copy into buffer.
.1480	ee 61 04	inc $0461			inc 	ReadBufferSize
.1483	9d 62 04	sta $0462,x			sta 	ReadBuffer,x
.1486	9e 63 04	stz $0463,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.1489	fa		plx				plx
.148a	80 e3		bra $146f			bra 	_RBGetText
.148c					_RBEndGet:
.148c	c9 22		cmp #$22			cmp 	#'"'
.148e	d0 03		bne $1493			bne 	_RBNotQuote
.1490	20 97 14	jsr $1497			jsr 	GetBumpNext
.1493					_RBNotQuote:
.1493	60		rts				rts
.1494					_RBError:
.1494	4c b7 1f	jmp $1fb7		jmp	ErrorV_data
.1497					GetBumpNext:
.1497	6c 61 05	jmp ($0561)			jmp 	(ReadBumpNextVec)
.149a					GetLookNext:
.149a	6c 63 05	jmp ($0563)			jmp 	(ReadLookNextVec)
.149d					ReadLookNext:
.149d	ad 65 05	lda $0565			lda 	dataRemaining 				; any data remaining
.14a0	f0 04		beq $14a6			beq 	_RLNFindData
.14a2	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.14a4	18		clc				clc
.14a5	60		rts				rts
.14a6					_RLNFindData:
.14a6	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.14a8	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.14aa	f0 1a		beq $14c6			beq 	_RLNNoData
.14ac	c9 cf		cmp #$cf			cmp 	#PCD_CMD_DATA 				; Found DATA
.14ae	f0 05		beq $14b5			beq 	_RLNHaveData
.14b0					_RLNNext:
.14b0	20 35 20	jsr $2035			jsr 	MoveObjectForward			; else scan forward.
.14b3	80 f1		bra $14a6			bra 	_RLNFindData
.14b5					_RLNHaveData:
.14b5	a0 01		ldy #$01			ldy 	#1 							; get length
.14b7	b1 2a		lda ($2a),y			lda 	(objPtr),y
.14b9	f0 f5		beq $14b0			beq 	_RLNNext 					; skip if DATA alone
.14bb	20 ca 14	jsr $14ca			jsr 	ReadBumpNext 				; advance by two
.14be	20 ca 14	jsr $14ca			jsr 	ReadBumpNext
.14c1	8d 65 05	sta $0565			sta 	dataRemaining 				; set data left count.
.14c4	38		sec				sec
.14c5	60		rts				rts
.14c6					_RLNNoData:
.14c6	a9 00		lda #$00			lda 	#0
.14c8	38		sec				sec
.14c9	60		rts				rts
.14ca					ReadBumpNext:
.14ca	e6 2a		inc $2a				inc 	objPtr
.14cc	d0 02		bne $14d0			bne 	_RBNSkip
.14ce	e6 2b		inc $2b				inc 	objPtr+1
.14d0					_RBNSkip:
.14d0	ce 65 05	dec $0565			dec 	dataRemaining
.14d3	60		rts				rts
.0460					ReadSep:
>0460							.fill 	1
.0461					ReadBufferSize:
>0461							.fill 	1
.0462					ReadBuffer:
>0462							.fill 	255
.0561					ReadBumpNextVec:
>0561							.fill 	2
.0563					ReadLookNextVec:
>0563							.fill 	2
.14d4					ReadFloatCommand:
.14d4	fa		plx				plx
.14d5	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14d7	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14d9	88		dey				dey 								; get the upper 3 bits
.14da	b1 28		lda ($28),y			lda 	(codePtr),y
.14dc	29 07		and #$07			and 	#7
.14de	c8		iny				iny
.14df	c8		iny				iny
.14e0	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14e2	2a		rol a				rol 	a 							; carry will be clear.
.14e3	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14e6	85 2d		sta $2d				sta 	zTemp0+1
.14e8	20 ee 14	jsr $14ee			jsr 	ReadFloatZTemp0Sub
.14eb	4c 4f 08	jmp $084f			jmp 	NextCommand
.14ee					ReadFloatZTemp0Sub:
.14ee	5a		phy				phy 								; start write
.14ef	a0 01		ldy #$01			ldy 	#1
.14f1	e8		inx				inx
.14f2	b2 2c		lda ($2c)			lda 	(zTemp0)
.14f4	95 3e		sta $3e,x			sta 	NSMantissa0,x
.14f6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14f8	95 4a		sta $4a,x			sta 	NSMantissa1,x
.14fa	c8		iny				iny
.14fb	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.14fd	95 56		sta $56,x			sta 	NSMantissa2,x
.14ff	c8		iny				iny
.1500	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1502	95 62		sta $62,x			sta 	NSMantissa3,x
.1504	c8		iny				iny
.1505	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1507	95 6e		sta $6e,x			sta 	NSExponent,x
.1509	c8		iny				iny
.150a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.150c	95 32		sta $32,x			sta 	NSStatus,x
.150e	7a		ply				ply
.150f	60		rts				rts
.1510					ReadIntegerCommand:
.1510	fa		plx				plx
.1511	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1513	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1515	88		dey				dey 								; get the upper 3 bits
.1516	b1 28		lda ($28),y			lda 	(codePtr),y
.1518	29 07		and #$07			and 	#7
.151a	c8		iny				iny
.151b	c8		iny				iny
.151c	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.151e	2a		rol a				rol 	a 							; carry will be clear.
.151f	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1522	85 2d		sta $2d				sta 	zTemp0+1
.1524	20 2a 15	jsr $152a			jsr 	ReadIntegerZTemp0Sub
.1527	4c 4f 08	jmp $084f			jmp 	NextCommand
.152a					ReadIntegerZTemp0Sub:
.152a	5a		phy				phy 								; start write
.152b	a0 01		ldy #$01			ldy 	#1
.152d	e8		inx				inx 								; prepare
.152e	74 56		stz $56,x			stz 	NSMantissa2,x
.1530	74 62		stz $62,x			stz 	NSMantissa3,x
.1532	74 6e		stz $6e,x			stz 	NSExponent,x
.1534	74 32		stz $32,x			stz 	NSStatus,x
.1536	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1538	30 08		bmi $1542			bmi 	_RIZNegative
.153a	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.153c	b2 2c		lda ($2c)			lda 	(zTemp0)
.153e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1540	7a		ply				ply
.1541	60		rts				rts
.1542					_RIZNegative:
.1542	38		sec				sec 								; -ve read
.1543	a9 00		lda #$00			lda 	#0
.1545	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.1547	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1549	a9 00		lda #$00			lda 	#0
.154b	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.154d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.154f	a9 80		lda #$80			lda 	#$80
.1551	95 32		sta $32,x			sta 	NSStatus,x
.1553	7a		ply				ply
.1554	60		rts				rts
.1555					ReadStringCommand:
.1555	fa		plx				plx
.1556	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1558	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.155a	88		dey				dey 								; get the upper 3 bits
.155b	b1 28		lda ($28),y			lda 	(codePtr),y
.155d	29 07		and #$07			and 	#7
.155f	c8		iny				iny
.1560	c8		iny				iny
.1561	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1563	2a		rol a				rol 	a 							; carry will be clear.
.1564	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1567	85 2d		sta $2d				sta 	zTemp0+1
.1569	20 6f 15	jsr $156f			jsr 	ReadStringZTemp0Sub
.156c	4c 4f 08	jmp $084f			jmp 	NextCommand
.156f					ReadStringZTemp0Sub:
.156f	5a		phy				phy 								; start write
.1570	e8		inx				inx 								; prepare
.1571	74 56		stz $56,x			stz 	NSMantissa2,x
.1573	74 62		stz $62,x			stz 	NSMantissa3,x
.1575	74 6e		stz $6e,x			stz 	NSExponent,x
.1577	a9 40		lda #$40			lda 	#NSSString
.1579	74 32		stz $32,x			stz 	NSStatus,x
.157b	18		clc				clc
.157c	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.157e	69 02		adc #$02			adc 	#2 							; this points to actual data
.1580	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.1582	a0 01		ldy #$01			ldy 	#1
.1584	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1586	69 00		adc #$00			adc 	#0
.1588	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.158a	d0 08		bne $1594			bne 	_RSZNoDefault 				; if read $00 use a default value.
.158c	a9 96		lda #$96			lda 	#_RSZNull & $FF
.158e	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1590	a9 15		lda #$15			lda 	#_RSZNull >> 8
.1592	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1594					_RSZNoDefault:
.1594	7a		ply				ply
.1595	60		rts				rts
.1596					_RSZNull:
>1596	00						.byte 	0
.1597					CommandRestore:
.1597	fa		plx				plx
.1598	20 9e 15	jsr $159e			jsr 	RestoreCode
.159b	4c 4f 08	jmp $084f			jmp 	NextCommand
.159e					RestoreCode:
.159e	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.15a1	85 2b		sta $2b				sta 	objPtr+1
.15a3	64 2a		stz $2a				stz 	objPtr
.15a5	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15a8	60		rts				rts
.0565					dataRemaining:
>0565							.fill 	1		 					; 0 if not in data statement
.15a9					UnaryRND:
.15a9	fa		plx				plx
.15aa	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.15ac	10 17		bpl $15c5			bpl 	_URNoSeed
.15ae	20 bb 23	jsr $23bb			jsr 	FloatNormalise 				; some float value
.15b1	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.15b3	8d 66 05	sta $0566			sta 	randomSeed+0
.15b6	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15b8	8d 67 05	sta $0567			sta 	randomSeed+1
.15bb	b5 56		lda $56,x			lda 	NSMantissa2,x
.15bd	8d 68 05	sta $0568			sta 	randomSeed+2
.15c0	b5 62		lda $62,x			lda 	NSMantissa3,x
.15c2	8d 69 05	sta $0569			sta 	randomSeed+3
.15c5					_URNoSeed:
.15c5	20 e7 15	jsr $15e7			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.15c8	ad 66 05	lda $0566			lda 	randomSeed+0
.15cb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15cd	ad 67 05	lda $0567			lda 	randomSeed+1
.15d0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15d2	ad 68 05	lda $0568			lda 	randomSeed+2
.15d5	95 56		sta $56,x			sta 	NSMantissa2,x
.15d7	ad 69 05	lda $0569			lda 	randomSeed+3
.15da	29 7f		and #$7f			and 	#$7F
.15dc	95 62		sta $62,x			sta 	NSMantissa3,x
.15de	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.15e0	95 6e		sta $6e,x			sta 	NSExponent,x
.15e2	74 32		stz $32,x			stz 	NSStatus,x
.15e4	4c 4f 08	jmp $084f			jmp 	NextCommand
.15e7					RandomNumberGenerator:
.15e7	5a		phy				phy
.15e8	ad 66 05	lda $0566			lda 	randomSeed+0 				; check if zero
.15eb	0d 67 05	ora $0567			ora 	randomSeed+1
.15ee	0d 68 05	ora $0568			ora 	randomSeed+2
.15f1	0d 69 05	ora $0569			ora 	randomSeed+3
.15f4	d0 07		bne $15fd			bne 	_RNGNoSeed
.15f6	ce 69 05	dec $0569			dec 	randomSeed+3 				; if so tweak and flog
.15f9	a0 64		ldy #$64			ldy 	#100
.15fb	80 05		bra $1602			bra 	_RNGLoop
.15fd					_RNGNoSeed:
.15fd	a0 08		ldy #$08			ldy 	#8
.15ff	ad 66 05	lda $0566			lda 	randomSeed+0
.1602					_RNGLoop:
.1602	0a		asl a				asl		a
.1603	2e 67 05	rol $0567			rol 	randomSeed+1
.1606	2e 68 05	rol $0568			rol 	randomSeed+2
.1609	2e 69 05	rol $0569			rol 	randomSeed+3
.160c	90 02		bcc $1610			bcc		_RNGSkip
.160e	49 c5		eor #$c5			eor 	#$C5
.1610					_RNGSkip:
.1610	88		dey				dey
.1611	d0 ef		bne $1602			bne		_RNGLoop
.1613	8d 66 05	sta $0566			sta 	randomSeed+0
.1616	7a		ply				ply
.1617	60		rts				rts
.0566					randomSeed:
>0566							.fill 	4
.1618					StringConcatenate:
.1618	fa		plx				plx
.1619	ca		dex				dex
.161a	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.161c	85 2e		sta $2e				sta 	zTemp1
.161e	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1620	85 2f		sta $2f				sta 	zTemp1+1
.1622	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.1624	85 30		sta $30				sta 	zTemp2
.1626	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.1628	85 31		sta $31				sta 	zTemp2+1
.162a	18		clc				clc 								; work out total length
.162b	b2 2e		lda ($2e)			lda 	(zTemp1)
.162d	72 30		adc ($30)			adc 	(zTemp2)
.162f	b0 18		bcs $1649			bcs 	_BCLength 					; more than 255 characters.
.1631	48		pha				pha 								; save total
.1632	20 0f 17	jsr $170f			jsr 	StringAllocTemp 			; space for result.
.1635	68		pla				pla 								; write total as first.
.1636	92 22		sta ($22)			sta 	(zsTemp)
.1638	20 4c 16	jsr $164c			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.163b	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.163d	85 2e		sta $2e				sta 	zTemp1
.163f	a5 31		lda $31				lda 	zTemp2+1
.1641	85 2f		sta $2f				sta 	zTemp1+1
.1643	20 4c 16	jsr $164c			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1646	4c 4f 08	jmp $084f			jmp 	NextCommand
.1649					_BCLength:
.1649	4c f2 1e	jmp $1ef2		jmp	ErrorV_range
.164c					_BCCopyZTemp1:
.164c	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.164e	f0 15		beq $1665			beq 	_BCCExit 					; none.
.1650	da		phx				phx 								; save XY
.1651	5a		phy				phy
.1652	aa		tax				tax 								; count in X.
.1653	a0 01		ldy #$01			ldy 	#1
.1655					_BCCLoop:
.1655	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1657	d0 02		bne $165b			bne 	_BCCNoCarry
.1659	e6 23		inc $23				inc 	zsTemp+1
.165b					_BCCNoCarry:
.165b	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.165d	92 22		sta ($22)			sta 	(zsTemp)
.165f	c8		iny				iny
.1660	ca		dex				dex 								; X times
.1661	d0 f2		bne $1655			bne 	_BCCLoop
.1663	7a		ply				ply 								; restore YX
.1664	fa		plx				plx
.1665					_BCCExit:
.1665	60		rts				rts
.1666					XRuntimeSetup:
.1666	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1668	8d 6d 05	sta $056d	 		sta 	ramBank
.166b	8d 6e 05	sta $056e	 		sta 	romBank
.166e	60		rts				rts
.166f					SignTOS:
.166f	fa		plx				plx
.1670	20 88 26	jsr $2688			jsr 	FloatIsZero 				; if zero
.1673	f0 0f		beq $1684			beq 	_SGZero  					; return Int Zero
.1675	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.1677	48		pha				pha
.1678	a9 01		lda #$01			lda 	#1 							; set result to 1
.167a	20 68 26	jsr $2668			jsr 	FloatSetByte
.167d	68		pla				pla
.167e	29 80		and #$80			and		#$80 						; copy the sign byte out
.1680	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.1682	80 03		bra $1687			bra 	_SGExit
.1684					_SGZero:
.1684	20 66 26	jsr $2666			jsr 	FloatSetZero
.1687					_SGExit:
.1687	4c 4f 08	jmp $084f			jmp 	NextCommand
.168a					CommandShift:
.168a	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.168c	c8		iny				iny
.168d	0a		asl a				asl 	a 							; double into X
.168e	aa		tax				tax
.168f	7c 3a 1a	jmp ($1a3a,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.1692					PrintTab:
.1692	fa		plx				plx
.1693	20 e2 1b	jsr $1be2			jsr 	XGetHPos
.1696					_PTMod10:
.1696	38		sec				sec
.1697	e9 0a		sbc #$0a			sbc 	#10
.1699	b0 fb		bcs $1696			bcs 	_PTMod10
.169b	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.169d	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.169e	80 15		bra $16b5			bra 	PrintSpaceLoop
.16a0					PrintPos:
.16a0	fa		plx				plx
.16a1	20 e2 1b	jsr $1be2			jsr		XGetHPos 					; get current position
.16a4	85 2c		sta $2c				sta 	zTemp0
.16a6	38		sec				sec 								; calculate spaces required
.16a7	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16a9	ca		dex				dex
.16aa	e5 2c		sbc $2c				sbc 	zTemp0
.16ac	b0 07		bcs $16b5			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.16ae	4c 4f 08	jmp $084f			jmp 	NextCommand
.16b1					PrintSpace:
.16b1	fa		plx				plx
.16b2	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16b4	ca		dex				dex
.16b5					PrintSpaceLoop:
.16b5	c9 00		cmp #$00			cmp 	#0
.16b7	f0 0a		beq $16c3			beq 	_PSExit
.16b9	48		pha				pha
.16ba	a9 20		lda #$20			lda 	#" "
.16bc	20 6c 13	jsr $136c			jsr 	VectorPrintCharacter
.16bf	68		pla				pla
.16c0	3a		dec a				dec 	a
.16c1	80 f2		bra $16b5			bra 	PrintSpaceLoop
.16c3					_PSExit:
.16c3	4c 4f 08	jmp $084f			jmp 	NextCommand
.16c6					CommandStop:
.16c6	fa		plx				plx
.16c7	4c a4 1f	jmp $1fa4		jmp	ErrorV_stop
.16ca					Unary_Str:
.16ca	fa		plx				plx
.16cb	5a		phy				phy
.16cc	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.16ce	20 4e 25	jsr $254e			jsr 	FloatToString 				; do the conversion.
.16d1	a9 21		lda #$21			lda		#33 						; create buffer
.16d3	20 0f 17	jsr $170f			jsr 	StringAllocTemp 			; allocate memory
.16d6	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.16d8					_USCopy:
.16d8	b9 97 05	lda $0597,y			lda 	decimalBuffer-1,y
.16db	f0 05		beq $16e2			beq 	_USExit
.16dd	91 22		sta ($22),y			sta 	(zsTemp),y
.16df	c8		iny				iny
.16e0	80 f6		bra $16d8			bra 	_USCopy
.16e2					_USExit:
.16e2	98		tya				tya
.16e3	3a		dec a				dec 	a
.16e4	92 22		sta ($22)			sta 	(zsTemp)
.16e6	7a		ply				ply
.16e7	4c 4f 08	jmp $084f			jmp 	NextCommand
.16ea					StringInitialise:
.16ea	48		pha				pha
.16eb	ad 6a 05	lda $056a			lda 	stringInitialised 			; already done
.16ee	d0 11		bne $1701			bne 	_SIExit
.16f0	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.16f3	8d 6b 05	sta $056b			sta 	stringTempPointer
.16f6	ad 03 04	lda $0403			lda 	stringHighMemory+1
.16f9	3a		dec a				dec 	a
.16fa	3a		dec a				dec 	a
.16fb	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.16fe	ce 6a 05	dec $056a			dec 	stringInitialised 			; set the initialised flag.
.1701					_SIExit:
.1701	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.1703	1a		inc a				inc 	a
.1704	1a		inc a				inc 	a
.1705	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.1708	b0 02		bcs $170c			bcs 	_SIMemory
.170a	68		pla				pla
.170b	60		rts				rts
.170c					_SIMemory:
.170c	4c fd 1f	jmp $1ffd		jmp	ErrorV_memory
.170f					StringAllocTemp:
.170f	20 ea 16	jsr $16ea			jsr 	StringInitialise 			; check it is initialised.
.1712	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.1714	18		clc				clc
.1715	6d 6b 05	adc $056b			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.1718	8d 6b 05	sta $056b			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.171b	85 22		sta $22				sta 	zsTemp
.171d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.171f	ad 6c 05	lda $056c			lda 	stringTempPointer+1
.1722	69 ff		adc #$ff			adc 	#$FF
.1724	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.1727	85 23		sta $23				sta 	zsTemp+1
.1729	95 4a		sta $4a,x			sta 	NSMantissa1,x
.172b	74 56		stz $56,x			stz 	NSMantissa2,x
.172d	74 62		stz $62,x			stz 	NSMantissa3,x
.172f	a9 00		lda #$00			lda 	#0 							; clear string.
.1731	92 22		sta ($22)			sta 	(zsTemp)
.1733	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1735	95 32		sta $32,x			sta 	NSStatus,x
.1737	60		rts				rts
.1738					StringWriteChar:
.1738	5a		phy				phy
.1739	48		pha				pha
.173a	b2 22		lda ($22)			lda 	(zsTemp)
.173c	1a		inc a				inc 	a
.173d	92 22		sta ($22)			sta 	(zsTemp)
.173f	a8		tay				tay
.1740	68		pla				pla
.1741	91 22		sta ($22),y			sta 	(zsTemp),y
.1743	7a		ply				ply
.1744	60		rts				rts
.056a					stringInitialised:
>056a							.fill 	1
.056b					stringTempPointer:
>056b							.fill 	2
.1745					Unary_Left:
.1745	fa		plx				plx
.1746	5a		phy				phy
.1747	18		clc				clc 								; only one parameter
.1748	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; push the length of the string.
.174b	48		pha				pha
.174c	ca		dex				dex
.174d	a9 00		lda #$00			lda 	#0 							; push the start position.
.174f	48		pha				pha
.1750	20 88 17	jsr $1788			jsr 	UnarySStringToZTemp0
.1753	80 3c		bra $1791			bra 	SubstringMain 				; stack now points to the string to slice.
.1755					Unary_Right:
.1755	fa		plx				plx
.1756	5a		phy				phy
.1757	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.1759	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; push the right length of the string.
.175c	48		pha				pha
.175d	ca		dex				dex
.175e	20 88 17	jsr $1788			jsr 	UnarySStringToZTemp0
.1761	68		pla				pla 								; this is the right requirement
.1762	38		sec				sec
.1763	49 ff		eor #$ff			eor 	#$FF
.1765	72 2c		adc ($2c)			adc 	(zTemp0)
.1767	b0 02		bcs $176b			bcs 	_URHaveCount
.1769	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.176b					_URHaveCount:
.176b	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.176d	5a		phy				phy
.176e	48		pha				pha 								; start position
.176f	80 20		bra $1791			bra 	SubstringMain
.1771					Unary_Mid:
.1771	fa		plx				plx
.1772	5a		phy				phy
.1773	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; push the length of the string required.
.1776	48		pha				pha
.1777	ca		dex				dex
.1778	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; put the start position.
.177b	f0 08		beq $1785			beq 	_UMError
.177d	3a		dec a				dec 	a
.177e	48		pha				pha
.177f	ca		dex				dex
.1780	20 88 17	jsr $1788			jsr 	UnarySStringToZTemp0
.1783	80 0c		bra $1791			bra 	SubstringMain 				; stack now points to the string to slice.
.1785					_UMError:
.1785	4c f2 1e	jmp $1ef2		jmp	ErrorV_range
.1788					UnarySStringToZTemp0:
.1788	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.178a	85 2c		sta $2c				sta 	zTemp0
.178c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.178e	85 2d		sta $2d				sta 	zTemp0+1
.1790	60		rts				rts
.1791					SubstringMain:
.1791	68		pla				pla 								; get the start offset
.1792	7a		ply				ply 								; get the count to do.
.1793	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.1795	b0 38		bcs $17cf			bcs 	_SSReturnNull
.1797	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.1799	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.179b	18		clc				clc
.179c	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.179e	b0 06		bcs $17a6			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.17a0	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.17a2	f0 04		beq $17a8			beq 	_SMIsOkay
.17a4	90 02		bcc $17a8			bcc 	_SMIsOkay
.17a6					_SMTruncateToEnd:
.17a6	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.17a8					_SMIsOkay:
.17a8	85 2f		sta $2f				sta 	zTemp1+1
.17aa	38		sec				sec		 							; work out size
.17ab	a5 2f		lda $2f				lda 	zTemp1+1
.17ad	e5 2e		sbc $2e				sbc 	zTemp1
.17af	f0 1e		beq $17cf			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.17b1	20 0f 17	jsr $170f			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.17b4	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.17b6					_SMCopy:
.17b6	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.17b8	f0 11		beq $17cb			beq 	_SMExit
.17ba	c8		iny				iny 								; bump and
.17bb	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.17bd	5a		phy				phy
.17be	48		pha				pha
.17bf	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.17c1	1a		inc a				inc 	a
.17c2	a8		tay				tay
.17c3	92 22		sta ($22)			sta 	(zsTemp)
.17c5	68		pla				pla 								; write character out
.17c6	91 22		sta ($22),y			sta 	(zsTemp),y
.17c8	7a		ply				ply 								; restore Y
.17c9	80 eb		bra $17b6			bra 	_SMCopy
.17cb					_SMExit:
.17cb	7a		ply				ply
.17cc	4c 4f 08	jmp $084f			jmp 	NextCommand
.17cf					_SSReturnNull:
.17cf	a9 e1		lda #$e1			lda 	#SSRNull & $FF 				; set up mantissa
.17d1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17d3	a9 17		lda #$17			lda 	#SSRNull >> 8
.17d5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17d7	74 56		stz $56,x			stz 	NSMantissa2,x
.17d9	74 62		stz $62,x			stz 	NSMantissa3,x
.17db	a9 40		lda #$40			lda 	#NSSString
.17dd	95 32		sta $32,x			sta 	NSStatus,x
.17df	80 ea		bra $17cb			bra 	_SMExit
.17e1					SSRNull:
>17e1	00 00						.word 	0
.17e3					CommandSwap:
.17e3	fa		plx				plx
.17e4	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17e6	48		pha				pha
.17e7	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.17e9	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17eb	68		pla				pla
.17ec	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.17ee	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17f0	48		pha				pha
.17f1	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.17f3	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17f5	68		pla				pla
.17f6	95 49		sta $49,x			sta 	NSMantissa1-1,x
.17f8	b5 56		lda $56,x			lda 	NSMantissa2,x
.17fa	48		pha				pha
.17fb	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.17fd	95 56		sta $56,x			sta 	NSMantissa2,x
.17ff	68		pla				pla
.1800	95 55		sta $55,x			sta 	NSMantissa2-1,x
.1802	b5 62		lda $62,x			lda 	NSMantissa3,x
.1804	48		pha				pha
.1805	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.1807	95 62		sta $62,x			sta 	NSMantissa3,x
.1809	68		pla				pla
.180a	95 61		sta $61,x			sta 	NSMantissa3-1,x
.180c	b5 6e		lda $6e,x			lda 	NSExponent,x
.180e	48		pha				pha
.180f	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.1811	95 6e		sta $6e,x			sta 	NSExponent,x
.1813	68		pla				pla
.1814	95 6d		sta $6d,x			sta 	NSExponent-1,x
.1816	b5 32		lda $32,x			lda 	NSStatus,x
.1818	48		pha				pha
.1819	b5 31		lda $31,x			lda 	NSStatus-1,x
.181b	95 32		sta $32,x			sta 	NSStatus,x
.181d	68		pla				pla
.181e	95 31		sta $31,x			sta 	NSStatus-1,x
.1820	4c 4f 08	jmp $084f			jmp 	NextCommand
.1823					CommandSYS:
.1823	fa		plx				plx
.1824	da		phx				phx 								; save XY
.1825	5a		phy				phy
.1826	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.1829	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.182b	85 2d		sta $2d				sta 	zTemp0+1
.182d	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.182f	85 2c		sta $2c				sta 	zTemp0
.1831	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1834	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.1837	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.183a	48		pha				pha
.183b	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.183e	28		plp				plp
.183f	20 56 18	jsr $1856			jsr 	_CSZTemp0
.1842	08		php				php
.1843	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1846	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.1849	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.184c	68		pla				pla
.184d	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.1850	7a		ply				ply 								; restore YX and drop 2
.1851	fa		plx				plx
.1852	ca		dex				dex
.1853	4c 4f 08	jmp $084f			jmp 	NextCommand
.1856					_CSZTemp0:
.1856	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.1859					TimeTOS:
.1859	fa		plx				plx
.185a	20 b4 18	jsr $18b4			jsr 	TIPushClock 				; push clock to TOS
.185d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1860					TimeString:
.1860	fa		plx				plx
.1861	20 b4 18	jsr $18b4			jsr 	TIPushClock 				; push clock to TOS
.1864	20 89 18	jsr $1889			jsr 	_TSDivMod60 				; result in seconds
.1867	20 89 18	jsr $1889			jsr 	_TSDivMod60 				; seconds
.186a	48		pha				pha
.186b	20 89 18	jsr $1889			jsr 	_TSDivMod60 				; minutes
.186e	48		pha				pha
.186f	a9 18		lda #$18			lda 	#24 						; hours
.1871	20 8b 18	jsr $188b			jsr 	_TSDivModA
.1874	48		pha				pha
.1875	a9 06		lda #$06			lda 	#6
.1877	20 0f 17	jsr $170f			jsr 	StringAllocTemp
.187a	68		pla				pla
.187b	20 9b 18	jsr $189b			jsr 	_TSWriteDecimal
.187e	68		pla				pla
.187f	20 9b 18	jsr $189b			jsr 	_TSWriteDecimal
.1882	68		pla				pla
.1883	20 9b 18	jsr $189b			jsr 	_TSWriteDecimal
.1886	4c 4f 08	jmp $084f			jmp 	NextCommand
.1889					_TSDivMod60:
.1889	a9 3c		lda #$3c			lda 	#60
.188b					_TSDivModA:
.188b	e8		inx				inx
.188c	20 68 26	jsr $2668			jsr 	FloatSetByte
.188f	ca		dex				dex
.1890	20 fc 21	jsr $21fc			jsr 	Int32Divide
.1893	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.1895	48		pha				pha
.1896	20 eb 21	jsr $21eb			jsr 	NSMCopyPlusTwoToZero
.1899	68		pla				pla
.189a	60		rts				rts
.189b					_TSWriteDecimal:
.189b	da		phx				phx
.189c	a2 30		ldx #$30			ldx 	#'0'
.189e					_TSWDLoop:
.189e	c9 0a		cmp #$0a			cmp 	#10
.18a0	90 05		bcc $18a7			bcc 	_TSWDEnd
.18a2	e9 0a		sbc #$0a			sbc 	#10
.18a4	e8		inx				inx
.18a5	80 f7		bra $189e			bra 	_TSWDLoop
.18a7					_TSWDEnd:
.18a7	48		pha				pha
.18a8	8a		txa				txa
.18a9	20 38 17	jsr $1738			jsr 	StringWriteChar
.18ac	68		pla				pla
.18ad	09 30		ora #$30			ora 	#'0'
.18af	20 38 17	jsr $1738			jsr 	StringWriteChar
.18b2	fa		plx				plx
.18b3	60		rts				rts
.18b4					TIPushClock:
.18b4	5a		phy				phy
.18b5	e8		inx				inx 								; push 0 on the stack
.18b6	20 66 26	jsr $2666			jsr 	FloatSetZero
.18b9	da		phx				phx
.18ba	20 ad 1c	jsr $1cad			jsr 	XReadClock 					; read time into YXA
.18bd	86 2c		stx $2c				stx 	zTemp0
.18bf	fa		plx				plx
.18c0	95 3e		sta $3e,x			sta 	NSMantissa0,x
.18c2	a5 2c		lda $2c				lda 	zTemp0
.18c4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.18c6	98		tya				tya
.18c7	95 56		sta $56,x			sta 	NSMantissa2,x
.18c9	7a		ply				ply
.18ca	60		rts				rts
.18cb					CommandTIWrite:
.18cb	fa		plx				plx
.18cc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.18ce	85 22		sta $22				sta 	zsTemp
.18d0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.18d2	85 23		sta $23				sta 	zsTemp+1
.18d4	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.18d6	c9 06		cmp #$06			cmp 	#6
.18d8	d0 59		bne $1933			bne 	_CTIWError
.18da	20 66 26	jsr $2666			jsr 	FloatSetZero
.18dd	20 ff 18	jsr $18ff			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.18e0	20 ff 18	jsr $18ff			jsr 	_CTIWDigitPair
.18e3	20 ff 18	jsr $18ff			jsr 	_CTIWDigitPair
.18e6	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.18e8	20 2a 19	jsr $192a			jsr 	_CTIWMultiply
.18eb	da		phx				phx
.18ec	5a		phy				phy
.18ed	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.18ef	48		pha				pha
.18f0	b5 56		lda $56,x			lda 	NSMantissa2,x
.18f2	a8		tay				tay
.18f3	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.18f5	fa		plx				plx
.18f6	20 b1 1c	jsr $1cb1			jsr 	XWriteClock 				; update the clock.
.18f9	7a		ply				ply
.18fa	fa		plx				plx
.18fb	ca		dex				dex 								; throw result.
.18fc	4c 4f 08	jmp $084f			jmp 	NextCommand
.18ff					_CTIWDigitPair:
.18ff	a9 06		lda #$06			lda 	#6 							; x 6
.1901	20 2a 19	jsr $192a			jsr 	_CTIWMultiply
.1904	20 10 19	jsr $1910			jsr 	_CTIWAddDigit 				; add digit
.1907	a9 0a		lda #$0a			lda 	#10 						; x 10
.1909	20 2a 19	jsr $192a			jsr 	_CTIWMultiply
.190c	20 10 19	jsr $1910			jsr 	_CTIWAddDigit 				; add digit
.190f	60		rts				rts
.1910					_CTIWAddDigit:
.1910	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.1912	d0 02		bne $1916			bne 	_CTIWASkip
.1914	e6 23		inc $23				inc 	zsTemp+1
.1916					_CTIWASkip:
.1916	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.1918	38		sec				sec
.1919	e9 30		sbc #$30			sbc 	#"0"
.191b	90 16		bcc $1933			bcc 	_CTIWError
.191d	c9 0a		cmp #$0a			cmp 	#9+1
.191f	b0 12		bcs $1933			bcs 	_CTIWError
.1921	e8		inx				inx 								; store at +1
.1922	20 68 26	jsr $2668			jsr 	FloatSetByte
.1925	ca		dex				dex
.1926	20 f2 23	jsr $23f2			jsr 	FloatAddTopTwoStack
.1929	60		rts				rts
.192a					_CTIWMultiply:
.192a	e8		inx				inx
.192b	20 68 26	jsr $2668			jsr 	FloatSetByte
.192e	ca		dex				dex
.192f	20 73 23	jsr $2373			jsr 	FloatMultiplyShort
.1932	60		rts				rts
.1933					_CTIWError:
.1933	4c 02 1f	jmp $1f02		jmp	ErrorV_value
.1936					UnaryUsr:
.1936	fa		plx				plx
.1937	5a		phy				phy
.1938	20 3f 19	jsr $193f			jsr 	_UUCallVector
.193b	7a		ply				ply
.193c	4c 4f 08	jmp $084f			jmp 	NextCommand
.193f					_UUCallVector:
.193f	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.1942					ValUnary:
.1942	fa		plx				plx
.1943	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1945	85 2c		sta $2c				sta 	zTemp0
.1947	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1949	85 2d		sta $2d				sta 	zTemp0+1
.194b	20 56 19	jsr $1956			jsr 	ValEvaluateZTemp0
.194e	b0 03		bcs $1953			bcs 	_VUError 					; couldn't convert
.1950	4c 4f 08	jmp $084f			jmp 	NextCommand
.1953					_VUError:
.1953	4c 02 1f	jmp $1f02		jmp	ErrorV_value
.1956					ValEvaluateZTemp0:
.1956	5a		phy				phy
.1957	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.1959	f0 22		beq $197d			beq 	_VMCFail2
.195b	a0 00		ldy #$00			ldy 	#0 							; start position
.195d					_VMCSpaces:
.195d	c8		iny				iny 								; skip leading spaces
.195e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1960	c9 20		cmp #$20			cmp 	#" "
.1962	f0 f9		beq $195d			beq 	_VMCSpaces
.1964	48		pha				pha 								; save first character
.1965	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.1967	d0 01		bne $196a			bne 	_VMCStart
.1969	c8		iny				iny 								; skip over - if so.
.196a					_VMCStart:
.196a	38		sec				sec 								; initialise first time round.
.196b					_VMCNext:
.196b	98		tya				tya 								; reached end of string
.196c	3a		dec a				dec 	a
.196d	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.196f	f0 0f		beq $1980			beq 	_VMCSuccess 				; successful.
.1971	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.1973	c8		iny				iny
.1974	20 4a 24	jsr $244a			jsr 	FloatEncode 				; send it to the number-builder
.1977	90 03		bcc $197c			bcc 	_VMCFail 					; if failed, give up.
.1979	18		clc				clc 								; next time round, countinue
.197a	80 ef		bra $196b			bra 	_VMCNext
.197c					_VMCFail:
.197c	68		pla				pla
.197d					_VMCFail2:
.197d	7a		ply				ply
.197e	38		sec				sec
.197f	60		rts				rts
.1980					_VMCSuccess:
.1980	a9 00		lda #$00			lda 	#0 							; construct final
.1982	20 4a 24	jsr $244a			jsr 	FloatEncode 				; by sending a duff value.
.1985	68		pla				pla 								; if it was -ve
.1986	c9 2d		cmp #$2d			cmp 	#"-"
.1988	d0 03		bne $198d			bne 	_VMCNotNegative
.198a	20 28 26	jsr $2628			jsr		FloatNegate 				; negate it.
.198d					_VMCNotNegative:
.198d	7a		ply				ply
.198e	18		clc				clc
.198f	60		rts				rts
.1990					VectorTable:
>1990	a7 10					.word	LinkFloatAdd             ; $80 +
>1992	b0 10					.word	LinkFloatSubtract        ; $81 -
>1994	b9 10					.word	LinkFloatMultiply        ; $82 *
>1996	c2 10					.word	LinkFloatDivide          ; $83 /
>1998	cd 10					.word	LinkFloatPower           ; $84 ^
>199a	f2 08					.word	BinaryAnd                ; $85 and
>199c	f6 08					.word	BinaryOr                 ; $86 or
>199e	d8 10					.word	LinkCompareGreater       ; $87 >
>19a0	e1 10					.word	LinkCompareEqual         ; $88 =
>19a2	ea 10					.word	LinkCompareLess          ; $89 <
>19a4	f3 10					.word	LinkCompareGreaterEqual  ; $8a >=
>19a6	fc 10					.word	LinkCompareNotEqual      ; $8b <>
>19a8	05 11					.word	LinkCompareLessEqual     ; $8c <=
>19aa	da 08					.word	AbsoluteTOS              ; $8d abs
>19ac	2d 09					.word	ArrayConvert             ; $8e array
>19ae	d5 09					.word	UnaryAsc                 ; $8f asc
>19b0	f0 09					.word	CommandAssert            ; $90 assert
>19b2	31 0a					.word	Unary16Bin               ; $91 bin$
>19b4	5b 0a					.word	PrintCharacterX          ; $92 print.chr
>19b6	65 0a					.word	UnaryChr                 ; $93 chr$
>19b8	ca 0a					.word	CompareStrings           ; $94 s.cmp
>19ba	b4 0c					.word	CommandXFor              ; $95 for
>19bc	77 0d					.word	UnaryFre                 ; $96 fre
>19be	8f 0d					.word	CommandXGet              ; $97 get
>19c0	b5 0d					.word	CommandReturn            ; $98 return
>19c2	f7 0d					.word	Command_PSET             ; $99 pset
>19c4	11 0e					.word	Command_LINE             ; $9a line
>19c6	26 0e					.word	Command_RECT             ; $9b rect
>19c8	35 0e					.word	Command_FRAME            ; $9c frame
>19ca	44 0e					.word	Command_CHAR             ; $9d char
>19cc	db 0e					.word	Unary16Hex               ; $9e hex$
>19ce	82 0f					.word	CommandXInput            ; $9f input
>19d0	99 0f					.word	CommandInputString       ; $a0 input$
>19d2	b2 0f					.word	CommandInputReset        ; $a1 input.start
>19d4	96 10					.word	UnaryLen                 ; $a2 len
>19d6	62 11					.word	LinkFloatCompare         ; $a3 f.cmp
>19d8	6b 11					.word	LinkDivideInt32          ; $a4 int.div
>19da	e5 11					.word	NegateTOS                ; $a5 negate
>19dc	ec 11					.word	CommandNewLine           ; $a6 new.line
>19de	f5 11					.word	CommandXNext             ; $a7 next
>19e0	de 12					.word	NotTOS                   ; $a8 not
>19e2	f5 12					.word	CommandXOn               ; $a9 on
>19e4	12 13					.word	CommandMoreOn            ; $aa moreon
>19e6	19 13					.word	UnaryPeek                ; $ab peek
>19e8	2e 13					.word	CommandPOKE              ; $ac poke
>19ea	46 13					.word	UnaryPos                 ; $ad pos
>19ec	50 13					.word	GetChannel               ; $ae getchannel
>19ee	5b 13					.word	SetChannel               ; $af setchannel
>19f0	7e 13					.word	PrintNumber              ; $b0 print.n
>19f2	9d 13					.word	PrintString              ; $b1 print.s
>19f4	04 14					.word	CommandXRead             ; $b2 read
>19f6	1e 14					.word	CommandReadString        ; $b3 read$
>19f8	a9 15					.word	UnaryRND                 ; $b4 rnd
>19fa	18 16					.word	StringConcatenate        ; $b5 concat
>19fc	6f 16					.word	SignTOS                  ; $b6 sgn
>19fe	92 16					.word	PrintTab                 ; $b7 print.tab
>1a00	a0 16					.word	PrintPos                 ; $b8 print.pos
>1a02	b1 16					.word	PrintSpace               ; $b9 print.spc
>1a04	ca 16					.word	Unary_Str                ; $ba str$
>1a06	45 17					.word	Unary_Left               ; $bb left$
>1a08	55 17					.word	Unary_Right              ; $bc right$
>1a0a	71 17					.word	Unary_Mid                ; $bd mid$
>1a0c	e3 17					.word	CommandSwap              ; $be swap
>1a0e	59 18					.word	TimeTOS                  ; $bf ti
>1a10	60 18					.word	TimeString               ; $c0 ti$
>1a12	36 19					.word	UnaryUsr                 ; $c1 usr
>1a14	42 19					.word	ValUnary                 ; $c2 val
>1a16	a9 1b					.word	CommandClose             ; $c3 close
>1a18	bb 1b					.word	CommandExit              ; $c4 exit
>1a1a	c1 1b					.word	CommandDebug             ; $c5 debug
>1a1c	27 1c					.word	CommandXOpen             ; $c6 open
>1a1e	bb 1c					.word	CommandScreen            ; $c7 screen
>1a20	a2 1e					.word	CommandVPOKE             ; $c8 vpoke
>1a22	c7 1e					.word	CommandVPEEK             ; $c9 vpeek
>1a24	8a 16					.word	CommandShift             ; $ca .shift
>1a26	9e 08					.word	PushByteCommand          ; $cb .byte
>1a28	b1 08					.word	PushWordCommand          ; $cc .word
>1a2a	c0 13					.word	CommandPushN             ; $cd .float
>1a2c	e6 13					.word	CommandPushS             ; $ce .string
>1a2e	52 0b					.word	CommandXData             ; $cf .data
>1a30	c6 0d					.word	CommandXGoto             ; $d0 .goto
>1a32	a9 0d					.word	CommandXGosub            ; $d1 .gosub
>1a34	db 0d					.word	CommandGotoZ             ; $d2 .goto.z
>1a36	e9 0d					.word	CommandGotoNZ            ; $d3 .goto.nz
>1a38	e0 08					.word	CommandVarSpace          ; $d4 .varspace
.1a3a					ShiftVectorTable:
>1a3a	7d 0a					.word	CommandClr               ; $ca80 clr
>1a3c	5b 0b					.word	CommandXDIM              ; $ca81 dim
>1a3e	4c 0c					.word	CommandEnd               ; $ca82 end
>1a40	67 10					.word	UnaryJoy                 ; $ca83 joy
>1a42	0e 11					.word	LinkFloatIntegerPartDown ; $ca84 int
>1a44	17 11					.word	LinkFloatSquareRoot      ; $ca85 sqr
>1a46	28 11					.word	LinkFloatLogarithm       ; $ca86 log
>1a48	33 11					.word	LinkFloatExponent        ; $ca87 exp
>1a4a	3c 11					.word	LinkFloatCosine          ; $ca88 cos
>1a4c	45 11					.word	LinkFloatSine            ; $ca89 sin
>1a4e	4e 11					.word	LinkFloatTangent         ; $ca8a tan
>1a50	57 11					.word	LinkFloatArcTan          ; $ca8b atn
>1a52	95 11					.word	XCommandMouse            ; $ca8c mouse
>1a54	aa 11					.word	XUnaryMB                 ; $ca8d mb
>1a56	b7 11					.word	XUnaryMX                 ; $ca8e mx
>1a58	c8 11					.word	XUnaryMY                 ; $ca8f my
>1a5a	97 15					.word	CommandRestore           ; $ca90 restore
>1a5c	c6 16					.word	CommandStop              ; $ca91 stop
>1a5e	23 18					.word	CommandSYS               ; $ca92 sys
>1a60	cb 18					.word	CommandTIWrite           ; $ca93 ti$.write
>1a62	98 1a					.word	CommandXWAIT             ; $ca94 wait
>1a64	ec 1b					.word	X16I2CPoke               ; $ca95 i2cpoke
>1a66	0c 1c					.word	X16I2CPeek               ; $ca96 i2cpeek
>1a68	77 1c					.word	CommandBank              ; $ca97 bank
>1a6a	ca 1c					.word	XCommandSleep            ; $ca98 sleep
>1a6c	ee 1c					.word	X16_Audio_FMINIT         ; $ca99 fminit
>1a6e	fc 1c					.word	X16_Audio_FMNOTE         ; $ca9a fmnote
>1a70	0e 1d					.word	X16_Audio_FMDRUM         ; $ca9b fmdrum
>1a72	20 1d					.word	X16_Audio_FMINST         ; $ca9c fminst
>1a74	32 1d					.word	X16_Audio_FMVIB          ; $ca9d fmvib
>1a76	44 1d					.word	X16_Audio_FMFREQ         ; $ca9e fmfreq
>1a78	55 1d					.word	X16_Audio_FMVOL          ; $ca9f fmvol
>1a7a	67 1d					.word	X16_Audio_FMPAN          ; $caa0 fmpan
>1a7c	79 1d					.word	X16_Audio_FMPLAY         ; $caa1 fmplay
>1a7e	8a 1d					.word	X16_Audio_FMCHORD        ; $caa2 fmchord
>1a80	9b 1d					.word	X16_Audio_FMPOKE         ; $caa3 fmpoke
>1a82	ad 1d					.word	X16_Audio_PSGINIT        ; $caa4 psginit
>1a84	bb 1d					.word	X16_Audio_PSGNOTE        ; $caa5 psgnote
>1a86	cd 1d					.word	X16_Audio_PSGVOL         ; $caa6 psgvol
>1a88	df 1d					.word	X16_Audio_PSGWAV         ; $caa7 psgwav
>1a8a	f1 1d					.word	X16_Audio_PSGFREQ        ; $caa8 psgfreq
>1a8c	02 1e					.word	X16_Audio_PSGPAN         ; $caa9 psgpan
>1a8e	14 1e					.word	X16_Audio_PSGPLAY        ; $caaa psgplay
>1a90	25 1e					.word	X16_Audio_PSGCHORD       ; $caab psgchord
>1a92	36 1e					.word	CommandCls               ; $caac cls
>1a94	3f 1e					.word	CommandLocate            ; $caad locate
>1a96	69 1e					.word	CommandColor             ; $caae color
.1a98					CommandXWAIT:
.1a98	fa		plx				plx
.1a99	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1a9b	85 2c		sta $2c				sta 	zTemp0
.1a9d	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1a9f	85 2d		sta $2d				sta 	zTemp0+1
.1aa1					_WaitLoop:
.1aa1	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1aa3	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1aa5	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1aa7	f0 f8		beq $1aa1			beq 	_WaitLoop 					; keep going if zero
.1aa9	ca		dex				dex 								; drop 3.
.1aaa	ca		dex				dex
.1aab	ca		dex				dex
.1aac	4c 4f 08	jmp $084f			jmp 	NextCommand
.1aaf					WriteFloatCommand:
.1aaf	fa		plx				plx
.1ab0	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1ab2	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1ab4	88		dey				dey 								; get the upper 3 bits
.1ab5	b1 28		lda ($28),y			lda 	(codePtr),y
.1ab7	29 07		and #$07			and 	#7
.1ab9	c8		iny				iny
.1aba	c8		iny				iny
.1abb	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1abd	2a		rol a				rol 	a 							; carry will be clear.
.1abe	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1ac1	85 2d		sta $2d				sta 	zTemp0+1
.1ac3	20 c9 1a	jsr $1ac9			jsr 	WriteFloatZTemp0Sub
.1ac6	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ac9					WriteFloatZTemp0Sub:
.1ac9	5a		phy				phy 								; ldart write
.1aca	a0 01		ldy #$01			ldy 	#1
.1acc	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ace	92 2c		sta ($2c)			sta 	(zTemp0)
.1ad0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ad2	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ad4	c8		iny				iny
.1ad5	b5 56		lda $56,x			lda 	NSMantissa2,x
.1ad7	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ad9	c8		iny				iny
.1ada	b5 62		lda $62,x			lda 	NSMantissa3,x
.1adc	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ade	c8		iny				iny
.1adf	b5 6e		lda $6e,x			lda 	NSExponent,x
.1ae1	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ae3	c8		iny				iny
.1ae4	b5 32		lda $32,x			lda 	NSStatus,x
.1ae6	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ae8	ca		dex				dex
.1ae9	7a		ply				ply
.1aea	60		rts				rts
.1aeb					WriteIntegerCommand:
.1aeb	fa		plx				plx
.1aec	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1aee	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1af0	88		dey				dey 								; get the upper 3 bits
.1af1	b1 28		lda ($28),y			lda 	(codePtr),y
.1af3	29 07		and #$07			and 	#7
.1af5	c8		iny				iny
.1af6	c8		iny				iny
.1af7	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1af9	2a		rol a				rol 	a 							; carry will be clear.
.1afa	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1afd	85 2d		sta $2d				sta 	zTemp0+1
.1aff	20 05 1b	jsr $1b05			jsr 	WriteIntegerZTemp0Sub
.1b02	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b05					WriteIntegerZTemp0Sub:
.1b05	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.1b08	5a		phy				phy 								; start write
.1b09	a0 01		ldy #$01			ldy 	#1
.1b0b	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1b0d	30 0b		bmi $1b1a			bmi 	_WIZNegative
.1b0f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1b11	92 2c		sta ($2c)			sta 	(zTemp0)
.1b13	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b15	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b17	7a		ply				ply
.1b18	ca		dex				dex
.1b19	60		rts				rts
.1b1a					_WIZNegative:
.1b1a	38		sec				sec 								; -ve read
.1b1b	a9 00		lda #$00			lda 	#0
.1b1d	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1b1f	92 2c		sta ($2c)			sta 	(zTemp0)
.1b21	a9 00		lda #$00			lda 	#0
.1b23	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1b25	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b27	7a		ply				ply
.1b28	ca		dex				dex
.1b29	60		rts				rts
.1b2a					WriteStringCommand:
.1b2a	fa		plx				plx
.1b2b	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b2d	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b2f	88		dey				dey 								; get the upper 3 bits
.1b30	b1 28		lda ($28),y			lda 	(codePtr),y
.1b32	29 07		and #$07			and 	#7
.1b34	c8		iny				iny
.1b35	c8		iny				iny
.1b36	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b38	2a		rol a				rol 	a 							; carry will be clear.
.1b39	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b3c	85 2d		sta $2d				sta 	zTemp0+1
.1b3e	20 44 1b	jsr $1b44			jsr 	WriteStringZTemp0Sub
.1b41	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b44					WriteStringZTemp0Sub:
.1b44	5a		phy				phy
.1b45	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b47	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b49	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b4b	f0 1e		beq $1b6b			beq 	_WSConcrete
.1b4d	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b4f	85 2e		sta $2e				sta 	zTemp1
.1b51	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b53	85 2f		sta $2f				sta 	zTemp1+1
.1b55	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b57	85 30		sta $30				sta 	zTemp2
.1b59	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b5b	85 31		sta $31				sta 	zTemp2+1
.1b5d	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1b5f	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1b61	b0 17		bcs $1b7a			bcs 	_WSCopy
.1b63	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1b65	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b67	09 80		ora #$80			ora 	#$80
.1b69	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1b6b					_WSConcrete:
.1b6b	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1b6d	a8		tay				tay
.1b6e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b70	20 0c 0b	jsr $0b0c			jsr 	StringConcrete
.1b73	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1b75	98		tya				tya
.1b76	a0 01		ldy #$01			ldy 	#1
.1b78	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b7a					_WSCopy
.1b7a	18		clc				clc  								; copy target+2 to zTemp2
.1b7b	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b7d	69 02		adc #$02			adc 	#2
.1b7f	85 30		sta $30				sta 	zTemp2
.1b81	a0 01		ldy #$01			ldy 	#1
.1b83	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b85	69 00		adc #$00			adc 	#0
.1b87	85 31		sta $31				sta 	zTemp2+1
.1b89	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1b8b	85 2e		sta $2e				sta 	zTemp1
.1b8d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b8f	85 2f		sta $2f				sta 	zTemp1+1
.1b91	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1b93	a8		tay				tay
.1b94					_WSCopyLoop:
.1b94	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b96	91 30		sta ($30),y			sta 	(zTemp2),y
.1b98	88		dey				dey
.1b99	c0 ff		cpy #$ff			cpy 	#$FF
.1b9b	d0 f7		bne $1b94			bne 	_WSCopyLoop
.1b9d	ca		dex				dex
.1b9e	7a		ply				ply
.1b9f	60		rts				rts
.1ba0					XCheckStop:
.1ba0	20 e1 ff	jsr $ffe1			jsr 	$FFE1 						; check stop
.1ba3	f0 01		beq $1ba6			beq 	_XCSStop
.1ba5	60		rts				rts
.1ba6					_XCSStop:
.1ba6	4c 24 20	jmp $2024		jmp	ErrorV_break
.1ba9					CommandClose:
.1ba9	fa		plx				plx
.1baa	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; channel to close
.1bad	cd 5f 04	cmp $045f			cmp 	currentChannel 				; is it the current channel
.1bb0	d0 03		bne $1bb5			bne 	_CCNotCurrent
.1bb2	9c 5f 04	stz $045f			stz 	currentChannel 				; effectively disables CMD
.1bb5					_CCNotCurrent:
.1bb5	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1bb8	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bbb					CommandExit:
.1bbb	fa		plx				plx
.1bbc	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1bbe	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1bc1					CommandDebug:
.1bc1	fa		plx				plx
>1bc2	db						.byte 	$DB 						; causes a break in the emulator
.1bc3	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bc6					XGetCharacterFromChannel:
.1bc6	da		phx				phx
.1bc7	5a		phy				phy
.1bc8	e0 00		cpx #$00			cpx 	#0 							; is it default
.1bca	d0 05		bne $1bd1			bne 	_XGetChannel
.1bcc	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1bcf	80 08		bra $1bd9			bra 	_XGetChar
.1bd1					_XGetChannel:
.1bd1	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1bd4	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1bd7	d0 06		bne $1bdf			bne 	_XGCError
.1bd9					_XGetChar:
.1bd9	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1bdc	7a		ply				ply
.1bdd	fa		plx				plx
.1bde	60		rts				rts
.1bdf					_XGCError:
.1bdf	4c 0e 20	jmp $200e		jmp	ErrorV_channel
.1be2					XGetHPos:
.1be2	da		phx				phx
.1be3	5a		phy				phy
.1be4	38		sec				sec
.1be5	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1be8	98		tya				tya
.1be9	7a		ply				ply
.1bea	fa		plx				plx
.1beb	60		rts				rts
.1bec					X16I2CPoke:
.1bec	fa		plx				plx
.1bed	5a		phy				phy
.1bee	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; value
.1bf1	48		pha				pha
.1bf2	ca		dex				dex
.1bf3	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; register
.1bf6	48		pha				pha
.1bf7	ca		dex				dex
.1bf8	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; device
.1bfb	aa		tax				tax
.1bfc	7a		ply				ply
.1bfd	68		pla				pla
.1bfe	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1c01	b0 06		bcs $1c09			bcs 	X16I2CError
.1c03	7a		ply				ply
.1c04	a2 ff		ldx #$ff			ldx 	#$FF
.1c06	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c09					X16I2CError:
.1c09	4c 0e 20	jmp $200e		jmp	ErrorV_channel
.1c0c					X16I2CPeek:
.1c0c	fa		plx				plx
.1c0d	da		phx				phx
.1c0e	5a		phy				phy
.1c0f	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; register
.1c12	48		pha				pha
.1c13	ca		dex				dex
.1c14	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; device
.1c17	aa		tax				tax 								; X device
.1c18	7a		ply				ply 								; Y register
.1c19	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1c1c	b0 eb		bcs $1c09			bcs 	X16I2CError
.1c1e	7a		ply				ply 								; restore Y/X
.1c1f	fa		plx				plx
.1c20	ca		dex				dex 								; drop TOS (register)
.1c21	20 68 26	jsr $2668			jsr 	FloatSetByte 				; write read value to TOS.
.1c24	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c27					CommandXOpen:
.1c27	fa		plx				plx
.1c28	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1c2a	85 2c		sta $2c				sta 	zTemp0
.1c2c	aa		tax				tax
.1c2d	a5 4d		lda $4d				lda 	NSMantissa1+3
.1c2f	85 2d		sta $2d				sta 	zTemp0+1
.1c31	a8		tay				tay
.1c32	e8		inx				inx 								; XY points to first character
.1c33	d0 01		bne $1c36			bne 	_CONoCarry
.1c35	c8		iny				iny
.1c36					_CONoCarry:
.1c36	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c38	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c3b	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c3d	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c3f	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c41	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c44	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c47	b0 03		bcs $1c4c			bcs 	_COError
.1c49	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c4c					_COError:
.1c4c	4c 0e 20	jmp $200e		jmp	ErrorV_channel
.1c4f					XPokeMemory:
.1c4f	86 2c		stx $2c				stx 	zTemp0
.1c51	84 2d		sty $2d				sty 	zTemp0+1
.1c53	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c55	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c58	e0 ff		cpx #$ff			cpx 	#$FF
.1c5a	f0 02		beq $1c5e			beq 	_XPMNoSwitch
.1c5c	86 00		stx $00				stx 	SelectRAMBank
.1c5e					_XPMNoSwitch:
.1c5e	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1c60	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1c62					_XPMExit:
.1c62	60		rts				rts
.1c63					XPeekMemory:
.1c63	86 2c		stx $2c				stx 	zTemp0
.1c65	84 2d		sty $2d				sty 	zTemp0+1
.1c67	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c69	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c6c	e0 ff		cpx #$ff			cpx 	#$FF
.1c6e	f0 02		beq $1c72			beq 	_XPMNoSwitch
.1c70	86 00		stx $00				stx 	SelectRAMBank
.1c72					_XPMNoSwitch:
.1c72	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1c74	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1c76	60		rts				rts
.1c77					CommandBank:
.1c77	fa		plx				plx
.1c78	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1c7a	8d 6d 05	sta $056d			sta 	ramBank 					; store & make current
.1c7d	85 00		sta $00				sta 	SelectRAMBank
.1c7f	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1c81	c9 ff		cmp #$ff			cmp 	#$FF
.1c83	f0 03		beq $1c88			beq 	_CBNoUpdate
.1c85	8d 6e 05	sta $056e			sta 	romBank 					; this doesn't set the hardware page.
.1c88					_CBNoUpdate:
.1c88	a2 ff		ldx #$ff			ldx 	#$FF
.1c8a	4c 4f 08	jmp $084f			jmp 	NextCommand
.056d					ramBank:
>056d							.fill 	1
.056e					romBank:
>056e							.fill 	1
.1c8d					XPrintCharacterToChannel:
.1c8d	48		pha				pha
.1c8e	da		phx				phx
.1c8f	5a		phy				phy
.1c90	48		pha				pha  								; save char
.1c91	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1c93	d0 05		bne $1c9a			bne 	_XPCNotDefault
.1c95	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1c98	80 08		bra $1ca2			bra 	_XPCSend
.1c9a					_XPCNotDefault:
.1c9a	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1c9d	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1ca0	d0 08		bne $1caa			bne 	_XPCError
.1ca2					_XPCSend:
.1ca2	68		pla				pla 								; restore character
.1ca3	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1ca6	7a		ply				ply
.1ca7	fa		plx				plx
.1ca8	68		pla				pla
.1ca9	60		rts				rts
.1caa					_XPCError:
.1caa	4c 0e 20	jmp $200e		jmp	ErrorV_channel
.1cad					XReadClock:
.1cad	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1cb0	60		rts				rts
.1cb1					XWriteClock:
.1cb1	48		pha				pha
.1cb2	da		phx				phx
.1cb3	5a		phy				phy
.1cb4	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1cb7	7a		ply				ply
.1cb8	fa		plx				plx
.1cb9	68		pla				pla
.1cba	60		rts				rts
.1cbb					CommandScreen:
.1cbb	fa		plx				plx
.1cbc	da		phx				phx
.1cbd	5a		phy				phy
.1cbe	20 3f 10	jsr $103f			jsr 	GetInteger8Bit
.1cc1	18		clc				clc
.1cc2	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1cc5	7a		ply				ply
.1cc6	fa		plx				plx
.1cc7	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cca					XCommandSleep:
.1cca	fa		plx				plx
.1ccb	5a		phy				phy
.1ccc	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.1ccf	ca		dex				dex
.1cd0	20 ad 1c	jsr $1cad			jsr 	XReadClock 					; read clock to YXA
.1cd3	18		clc				clc 								; calculate end time in zTemp0
.1cd4	65 3e		adc $3e				adc 	NSMantissa0
.1cd6	85 2c		sta $2c				sta 	zTemp0
.1cd8	8a		txa				txa
.1cd9	65 4a		adc $4a				adc 	NSMantissa1
.1cdb	85 2d		sta $2d				sta 	zTemp0+1
.1cdd					_XCWait:
.1cdd	20 ad 1c	jsr $1cad			jsr 	XReadClock 					; and wait for it.
.1ce0	c5 2c		cmp $2c				cmp 	zTemp0
.1ce2	d0 f9		bne $1cdd			bne 	_XCWait
.1ce4	e4 2d		cpx $2d				cpx 	zTemp0+1
.1ce6	d0 f5		bne $1cdd			bne 	_XCWait
.1ce8	a2 ff		ldx #$ff			ldx 	#$FF
.1cea	7a		ply				ply
.1ceb	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cee					X16_Audio_FMINIT:
.1cee	fa		plx				plx
.1cef	5a		phy			phy
.1cf0	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1cf3	63 c0					.word	X16A_ym_init
>1cf5	0a					.byte	X16_AudioCodeBank
.1cf6	a2 ff		ldx #$ff		ldx	#$FF
.1cf8	7a		ply			ply
.1cf9	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cfc					X16_Audio_FMNOTE:
.1cfc	fa		plx				plx
.1cfd	5a		phy			phy
.1cfe	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d01	18		clc			clc
.1d02	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d05	03 c0					.word	X16A_bas_fmnote
>1d07	0a					.byte	X16_AudioCodeBank
.1d08	a2 ff		ldx #$ff		ldx	#$FF
.1d0a	7a		ply			ply
.1d0b	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d0e					X16_Audio_FMDRUM:
.1d0e	fa		plx				plx
.1d0f	5a		phy			phy
.1d10	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d13	18		clc			clc
.1d14	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d17	6f c0					.word	X16A_ym_playdrum
>1d19	0a					.byte	X16_AudioCodeBank
.1d1a	a2 ff		ldx #$ff		ldx	#$FF
.1d1c	7a		ply			ply
.1d1d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d20					X16_Audio_FMINST:
.1d20	fa		plx				plx
.1d21	5a		phy			phy
.1d22	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d25	38		sec			sec
.1d26	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d29	69 c0					.word	X16A_ym_loadpatch
>1d2b	0a					.byte	X16_AudioCodeBank
.1d2c	a2 ff		ldx #$ff		ldx	#$FF
.1d2e	7a		ply			ply
.1d2f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d32					X16_Audio_FMVIB:
.1d32	fa		plx				plx
.1d33	5a		phy			phy
.1d34	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d37	18		clc			clc
.1d38	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d3b	09 c0					.word	X16A_bas_fmvib
>1d3d	0a					.byte	X16_AudioCodeBank
.1d3e	a2 ff		ldx #$ff		ldx	#$FF
.1d40	7a		ply			ply
.1d41	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d44					X16_Audio_FMFREQ:
.1d44	fa		plx				plx
.1d45	5a		phy			phy
.1d46	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1d49	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d4c	00 c0					.word	X16A_bas_fmfreq
>1d4e	0a					.byte	X16_AudioCodeBank
.1d4f	a2 ff		ldx #$ff		ldx	#$FF
.1d51	7a		ply			ply
.1d52	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d55					X16_Audio_FMVOL:
.1d55	fa		plx				plx
.1d56	5a		phy			phy
.1d57	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d5a	18		clc			clc
.1d5b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d5e	75 c0					.word	X16A_ym_setatten
>1d60	0a					.byte	X16_AudioCodeBank
.1d61	a2 ff		ldx #$ff		ldx	#$FF
.1d63	7a		ply			ply
.1d64	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d67					X16_Audio_FMPAN:
.1d67	fa		plx				plx
.1d68	5a		phy			phy
.1d69	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d6c	18		clc			clc
.1d6d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d70	7e c0					.word	X16A_ym_setpan
>1d72	0a					.byte	X16_AudioCodeBank
.1d73	a2 ff		ldx #$ff		ldx	#$FF
.1d75	7a		ply			ply
.1d76	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d79					X16_Audio_FMPLAY:
.1d79	fa		plx				plx
.1d7a	5a		phy			phy
.1d7b	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1d7e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d81	06 c0					.word	X16A_bas_fmplaystring
>1d83	0a					.byte	X16_AudioCodeBank
.1d84	a2 ff		ldx #$ff		ldx	#$FF
.1d86	7a		ply			ply
.1d87	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d8a					X16_Audio_FMCHORD:
.1d8a	fa		plx				plx
.1d8b	5a		phy			phy
.1d8c	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1d8f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d92	8d c0					.word	X16A_bas_fmchordstring
>1d94	0a					.byte	X16_AudioCodeBank
.1d95	a2 ff		ldx #$ff		ldx	#$FF
.1d97	7a		ply			ply
.1d98	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d9b					X16_Audio_FMPOKE:
.1d9b	fa		plx				plx
.1d9c	5a		phy			phy
.1d9d	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1da0	18		clc			clc
.1da1	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1da4	8a c0					.word	X16A_ym_write
>1da6	0a					.byte	X16_AudioCodeBank
.1da7	a2 ff		ldx #$ff		ldx	#$FF
.1da9	7a		ply			ply
.1daa	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dad					X16_Audio_PSGINIT:
.1dad	fa		plx				plx
.1dae	5a		phy			phy
.1daf	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1db2	4b c0					.word	X16A_psg_init
>1db4	0a					.byte	X16_AudioCodeBank
.1db5	a2 ff		ldx #$ff		ldx	#$FF
.1db7	7a		ply			ply
.1db8	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dbb					X16_Audio_PSGNOTE:
.1dbb	fa		plx				plx
.1dbc	5a		phy			phy
.1dbd	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1dc0	18		clc			clc
.1dc1	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dc4	12 c0					.word	X16A_bas_psgnote
>1dc6	0a					.byte	X16_AudioCodeBank
.1dc7	a2 ff		ldx #$ff		ldx	#$FF
.1dc9	7a		ply			ply
.1dca	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dcd					X16_Audio_PSGVOL:
.1dcd	fa		plx				plx
.1dce	5a		phy			phy
.1dcf	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1dd2	18		clc			clc
.1dd3	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dd6	54 c0					.word	X16A_psg_setatten
>1dd8	0a					.byte	X16_AudioCodeBank
.1dd9	a2 ff		ldx #$ff		ldx	#$FF
.1ddb	7a		ply			ply
.1ddc	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ddf					X16_Audio_PSGWAV:
.1ddf	fa		plx				plx
.1de0	5a		phy			phy
.1de1	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1de4	18		clc			clc
.1de5	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1de8	15 c0					.word	X16A_bas_psgwav
>1dea	0a					.byte	X16_AudioCodeBank
.1deb	a2 ff		ldx #$ff		ldx	#$FF
.1ded	7a		ply			ply
.1dee	4c 4f 08	jmp $084f			jmp 	NextCommand
.1df1					X16_Audio_PSGFREQ:
.1df1	fa		plx				plx
.1df2	5a		phy			phy
.1df3	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1df6	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1df9	0f c0					.word	X16A_bas_psgfreq
>1dfb	0a					.byte	X16_AudioCodeBank
.1dfc	a2 ff		ldx #$ff		ldx	#$FF
.1dfe	7a		ply			ply
.1dff	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e02					X16_Audio_PSGPAN:
.1e02	fa		plx				plx
.1e03	5a		phy			phy
.1e04	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e07	18		clc			clc
.1e08	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e0b	5a c0					.word	X16A_psg_setpan
>1e0d	0a					.byte	X16_AudioCodeBank
.1e0e	a2 ff		ldx #$ff		ldx	#$FF
.1e10	7a		ply			ply
.1e11	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e14					X16_Audio_PSGPLAY:
.1e14	fa		plx				plx
.1e15	5a		phy			phy
.1e16	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e19	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e1c	18 c0					.word	X16A_bas_psgplaystring
>1e1e	0a					.byte	X16_AudioCodeBank
.1e1f	a2 ff		ldx #$ff		ldx	#$FF
.1e21	7a		ply			ply
.1e22	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e25					X16_Audio_PSGCHORD:
.1e25	fa		plx				plx
.1e26	5a		phy			phy
.1e27	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e2a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e2d	90 c0					.word	X16A_bas_psgchordstring
>1e2f	0a					.byte	X16_AudioCodeBank
.1e30	a2 ff		ldx #$ff		ldx	#$FF
.1e32	7a		ply			ply
.1e33	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e36					CommandCls:
.1e36	fa		plx				plx
.1e37	a9 93		lda #$93			lda 	#147
.1e39	20 8d 1c	jsr $1c8d			jsr 	XPrintCharacterToChannel
.1e3c	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e3f					CommandLocate:
.1e3f	fa		plx				plx
.1e40	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.1e43	ca		dex				dex
.1e44	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.1e47	ca		dex				dex
.1e48	a9 13		lda #$13			lda 	#$13 						; home.
.1e4a	20 8d 1c	jsr $1c8d			jsr 	XPrintCharacterToChannel
.1e4d	a9 1d		lda #$1d			lda 	#$1D 						; do cursor rights
.1e4f	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1e51	20 5e 1e	jsr $1e5e			jsr 	_CLOutputXA
.1e54	a9 11		lda #$11			lda 	#$11 						; do cursor downs.
.1e56	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e58	20 5e 1e	jsr $1e5e			jsr 	_CLOutputXA
.1e5b	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e5e					_CLOutputXA:
.1e5e	ca		dex				dex
.1e5f	f0 07		beq $1e68			beq 	_CLOExit
.1e61	30 05		bmi $1e68			bmi 	_CLOExit
.1e63	20 8d 1c	jsr $1c8d			jsr 	XPrintCharacterToChannel
.1e66	80 f6		bra $1e5e			bra 	_CLOutputXA
.1e68					_CLOExit:
.1e68	60		rts				rts
.1e69					CommandColor:
.1e69	fa		plx				plx
.1e6a	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.1e6d	ca		dex				dex
.1e6e	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.1e71	ca		dex				dex
.1e72	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1e74	c9 ff		cmp #$ff			cmp 	#$FF
.1e76	f0 08		beq $1e80			beq 	_CCNoBGR 					; if so, change background
.1e78	20 88 1e	jsr $1e88			jsr 	_CCSetColour
.1e7b	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1e7d	20 8d 1c	jsr $1c8d			jsr 	XPrintCharacterToChannel
.1e80					_CCNoBGR:
.1e80	a5 3e		lda $3e				lda 	NSMantissa0
.1e82	20 88 1e	jsr $1e88			jsr 	_CCSetColour
.1e85	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e88					_CCSetColour:
.1e88	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1e8a	aa		tax				tax
.1e8b	bd 92 1e	lda $1e92,x			lda 	_CCCommandTable,x
.1e8e	20 8d 1c	jsr $1c8d			jsr 	XPrintCharacterToChannel
.1e91	60		rts				rts
.1e92					_CCCommandTable:
>1e92	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1e9a	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1ea2					CommandVPOKE:
.1ea2	fa		plx				plx
.1ea3	20 3f 10	jsr $103f			jsr 	GetInteger8Bit 				; poke value
.1ea6	48		pha				pha
.1ea7	ca		dex				dex
.1ea8	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.1eab	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ead	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1eb0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1eb2	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1eb5	ca		dex				dex
.1eb6	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.1eb9	20 3f 10	jsr $103f			jsr 	GetInteger8Bit
.1ebc	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1ebf	ca		dex				dex
.1ec0	68		pla				pla 								; poke value back
.1ec1	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1ec4	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ec7					CommandVPEEK:
.1ec7	fa		plx				plx
.1ec8	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.1ecb	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ecd	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1ed0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ed2	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ed5	ca		dex				dex
.1ed6	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.1ed9	20 3f 10	jsr $103f			jsr 	GetInteger8Bit
.1edc	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1edf	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1ee2	20 68 26	jsr $2668			jsr 	FloatSetByte 				; return as byte
.1ee5	4c 4f 08	jmp $084f			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$ca					PCD_ENDCOMMAND = $ca
=$ca					PCD_STARTSYSTEM = $ca
=$d5					PCD_ENDSYSTEM = $d5
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_POKE             = $ac ; poke
=$ad					PCD_POS              = $ad ; pos
=$ae					PCD_GETCHANNEL       = $ae ; getchannel
=$af					PCD_SETCHANNEL       = $af ; setchannel
=$b0					PCD_PRINTCMD_N       = $b0 ; print.n
=$b1					PCD_PRINTCMD_S       = $b1 ; print.s
=$b2					PCD_READ             = $b2 ; read
=$b3					PCD_READDOLLAR       = $b3 ; read$
=$b4					PCD_RND              = $b4 ; rnd
=$b5					PCD_CONCAT           = $b5 ; concat
=$b6					PCD_SGN              = $b6 ; sgn
=$b7					PCD_PRINTCMD_TAB     = $b7 ; print.tab
=$b8					PCD_PRINTCMD_POS     = $b8 ; print.pos
=$b9					PCD_PRINTCMD_SPC     = $b9 ; print.spc
=$ba					PCD_STRDOLLAR        = $ba ; str$
=$bb					PCD_LEFTDOLLAR       = $bb ; left$
=$bc					PCD_RIGHTDOLLAR      = $bc ; right$
=$bd					PCD_MIDDOLLAR        = $bd ; mid$
=$be					PCD_SWAP             = $be ; swap
=$bf					PCD_TI               = $bf ; ti
=$c0					PCD_TIDOLLAR         = $c0 ; ti$
=$c1					PCD_USR              = $c1 ; usr
=$c2					PCD_VAL              = $c2 ; val
=$c3					PCD_CLOSE            = $c3 ; close
=$c4					PCD_EXIT             = $c4 ; exit
=$c5					PCD_DEBUG            = $c5 ; debug
=$c6					PCD_OPEN             = $c6 ; open
=$c7					PCD_SCREEN           = $c7 ; screen
=$c8					PCD_VPOKE            = $c8 ; vpoke
=$c9					PCD_VPEEK            = $c9 ; vpeek
=$ca					PCD_CMD_SHIFT        = $ca ; .shift
=$cb					PCD_CMD_BYTE         = $cb ; .byte
=$cc					PCD_CMD_WORD         = $cc ; .word
=$cd					PCD_CMD_FLOAT        = $cd ; .float
=$ce					PCD_CMD_STRING       = $ce ; .string
=$cf					PCD_CMD_DATA         = $cf ; .data
=$d0					PCD_CMD_GOTO         = $d0 ; .goto
=$d1					PCD_CMD_GOSUB        = $d1 ; .gosub
=$d2					PCD_CMD_GOTOCMD_Z    = $d2 ; .goto.z
=$d3					PCD_CMD_GOTOCMD_NZ   = $d3 ; .goto.nz
=$d4					PCD_CMD_VARSPACE     = $d4 ; .varspace
=$ca80					PCD_CLR              = $ca80 ; clr
=$ca81					PCD_DIM              = $ca81 ; dim
=$ca82					PCD_END              = $ca82 ; end
=$ca83					PCD_JOY              = $ca83 ; joy
=$ca84					PCD_INT              = $ca84 ; int
=$ca85					PCD_SQR              = $ca85 ; sqr
=$ca86					PCD_LOG              = $ca86 ; log
=$ca87					PCD_EXP              = $ca87 ; exp
=$ca88					PCD_COS              = $ca88 ; cos
=$ca89					PCD_SIN              = $ca89 ; sin
=$ca8a					PCD_TAN              = $ca8a ; tan
=$ca8b					PCD_ATN              = $ca8b ; atn
=$ca8c					PCD_MOUSE            = $ca8c ; mouse
=$ca8d					PCD_MB               = $ca8d ; mb
=$ca8e					PCD_MX               = $ca8e ; mx
=$ca8f					PCD_MY               = $ca8f ; my
=$ca90					PCD_RESTORE          = $ca90 ; restore
=$ca91					PCD_STOP             = $ca91 ; stop
=$ca92					PCD_SYS              = $ca92 ; sys
=$ca93					PCD_TIDOLLARCMD_WRITE = $ca93 ; ti$.write
=$ca94					PCD_WAIT             = $ca94 ; wait
=$ca95					PCD_I2CPOKE          = $ca95 ; i2cpoke
=$ca96					PCD_I2CPEEK          = $ca96 ; i2cpeek
=$ca97					PCD_BANK             = $ca97 ; bank
=$ca98					PCD_SLEEP            = $ca98 ; sleep
=$ca99					PCD_FMINIT           = $ca99 ; fminit
=$ca9a					PCD_FMNOTE           = $ca9a ; fmnote
=$ca9b					PCD_FMDRUM           = $ca9b ; fmdrum
=$ca9c					PCD_FMINST           = $ca9c ; fminst
=$ca9d					PCD_FMVIB            = $ca9d ; fmvib
=$ca9e					PCD_FMFREQ           = $ca9e ; fmfreq
=$ca9f					PCD_FMVOL            = $ca9f ; fmvol
=$caa0					PCD_FMPAN            = $caa0 ; fmpan
=$caa1					PCD_FMPLAY           = $caa1 ; fmplay
=$caa2					PCD_FMCHORD          = $caa2 ; fmchord
=$caa3					PCD_FMPOKE           = $caa3 ; fmpoke
=$caa4					PCD_PSGINIT          = $caa4 ; psginit
=$caa5					PCD_PSGNOTE          = $caa5 ; psgnote
=$caa6					PCD_PSGVOL           = $caa6 ; psgvol
=$caa7					PCD_PSGWAV           = $caa7 ; psgwav
=$caa8					PCD_PSGFREQ          = $caa8 ; psgfreq
=$caa9					PCD_PSGPAN           = $caa9 ; psgpan
=$caaa					PCD_PSGPLAY          = $caaa ; psgplay
=$caab					PCD_PSGCHORD         = $caab ; psgchord
=$caac					PCD_CLS              = $caac ; cls
=$caad					PCD_LOCATE           = $caad ; locate
=$caae					PCD_COLOR            = $caae ; color
.1ee8					SetErrorHandler:
.1ee8	8c 70 05	sty $0570			sty 	ErrorHandlerVector+1
.1eeb	8e 6f 05	stx $056f			stx 	ErrorHandlerVector
.1eee	60		rts				rts
.1eef					CallErrorHandler:
.1eef	6c 6f 05	jmp ($056f)			jmp 	(ErrorHandlerVector)
.056f					ErrorHandlerVector:
>056f							.fill 	2
.1ef2					ErrorV_range:
.1ef2	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1ef5	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1efd	41 4e 47 45 00
.1f02					ErrorV_value:
.1f02	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1f05	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f0d	45 00
.1f0f					ErrorV_syntax:
.1f0f	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1f12	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f1a	52 52 4f 52 00
.1f1f					ErrorV_type:
.1f1f	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1f22	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f2a	4d 41 54 43 48 00
.1f30					ErrorV_unimplemented:
.1f30	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1f33	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f3b	45 4d 45 4e 54 45 44 00
.1f43					ErrorV_assert:
.1f43	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1f46	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f4e	41 49 4c 00
.1f52					ErrorV_line:
.1f52	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1f55	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f5d	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f69					ErrorV_internal:
.1f69	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1f6c	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f74	20 45 52 52 4f 52 00
.1f7b					ErrorV_divzero:
.1f7b	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1f7e	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1f86	59 20 5a 45 52 4f 00
.1f8d					ErrorV_structure:
.1f8d	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1f90	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1f98	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fa4					ErrorV_stop:
.1fa4	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1fa7	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1faf	53 54 4f 50 50 45 44 00
.1fb7					ErrorV_data:
.1fb7	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1fba	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fc2	41 54 41 00
.1fc6					ErrorV_undeclared:
.1fc6	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1fc9	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1fd1	41 52 52 41 59 00
.1fd7					ErrorV_redefine:
.1fd7	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1fda	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1fe2	44 45 46 49 4e 45 44 00
.1fea					ErrorV_index:
.1fea	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>1fed	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>1ff5	59 20 49 4e 44 45 58 00
.1ffd					ErrorV_memory:
.1ffd	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>2000	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2008	45 4d 4f 52 59 00
.200e					ErrorV_channel:
.200e	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>2011	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2019	54 50 55 54 20 45 52 52 4f 52 00
.2024					ErrorV_break:
.2024	20 ef 1e	jsr $1eef		jsr	CallErrorHandler
>2027	42 52 45 41 4b 20 50 52			.text	"BREAK PRESSED",0
>202f	45 53 53 45 44 00
.2035					MoveObjectForward:
.2035	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.2037	c9 ff		cmp #$ff			cmp 	#$FF
.2039	f0 36		beq $2071			beq 	_MOFEnd
.203b	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.203d	90 24		bcc $2063			bcc 	_MOFAdvance1 				; forward 1
.203f	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.2041	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2043	90 20		bcc $2065			bcc 	_MOFAdvanceY
.2045	c9 ca		cmp #$ca			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2047	90 1a		bcc $2063			bcc 	_MOFAdvance1 				; forward 1
.2049	a8		tay				tay 								; read the size.
.204a	b9 af 1f	lda $1faf,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.204d	a8		tay				tay
.204e	c8		iny				iny 								; add 1 for the system token.
.204f	d0 14		bne $2065			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.2051	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2053	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2055	a8		tay				tay 								; into Y.
.2056	18		clc				clc
.2057	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.2059	69 02		adc #$02			adc 	#2
.205b	85 2a		sta $2a				sta 	objPtr
.205d	90 02		bcc $2061			bcc 	_MOFNoCarry1
.205f	e6 2b		inc $2b				inc 	objPtr+1
.2061					_MOFNoCarry1:
.2061	80 02		bra $2065			bra 	_MOFAdvanceY
.2063					_MOFAdvance1:
.2063	a0 01		ldy #$01			ldy 	#1
.2065					_MOFAdvanceY:
.2065	98		tya				tya 								; add Y to objPtr
.2066	18		clc				clc
.2067	65 2a		adc $2a				adc 	objPtr
.2069	85 2a		sta $2a				sta 	objPtr
.206b	90 02		bcc $206f			bcc 	_MOFNoCarry2
.206d	e6 2b		inc $2b				inc 	objPtr+1
.206f					_MOFNoCarry2:
.206f	18		clc				clc 								; not completed.
.2070	60		rts				rts
.2071					_MOFEnd:
.2071	e6 2a		inc $2a				inc 	objPtr
.2073	d0 02		bne $2077			bne 	_MOFENoCarry
.2075	e6 2b		inc $2b				inc 	objPtr+1
.2077					_MOFENoCarry:
.2077	38		sec				sec
.2078	60		rts				rts
.2079					MOFSizeTable:
>2079	01					.byte	1         	; $ca .shift
>207a	01					.byte	1         	; $cb .byte
>207b	02					.byte	2         	; $cc .word
>207c	05					.byte	5         	; $cd .float
>207d	ff					.byte	255       	; $ce .string
>207e	ff					.byte	255       	; $cf .data
>207f	02					.byte	2         	; $d0 .goto
>2080	02					.byte	2         	; $d1 .gosub
>2081	02					.byte	2         	; $d2 .goto.z
>2082	02					.byte	2         	; $d3 .goto.nz
>2083	02					.byte	2         	; $d4 .varspace

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0571					numberBuffer:
>0571							.fill 	34
.2084					FloatSubtract:
.2084	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.2086	49 80		eor #$80			eor 	#$80
.2088	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.208a					FloatAdd:
.208a	ca		dex				dex
.208b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.208d	15 6f		ora $6f,x			ora 	NSExponent+1,x
.208f	15 62		ora $62,x			ora 	NSMantissa3,x
.2091	15 63		ora $63,x			ora 	NSMantissa3+1,x
.2093	d0 04		bne $2099			bne 	_FAUseFloat
.2095	20 26 24	jsr $2426			jsr 	FloatInt32Add 				; use the int32 one.
.2098	60		rts				rts
.2099					_FAUseFloat:
.2099	20 bb 23	jsr $23bb			jsr 	FloatNormalise 				; normalise S[X]
.209c	f0 51		beq $20ef			beq 	_FAReturn1
.209e	e8		inx				inx 								; normalise S[X+1]
.209f	20 bb 23	jsr $23bb			jsr 	FloatNormalise
.20a2	ca		dex				dex
.20a3	c9 00		cmp #$00			cmp 	#0
.20a5	f0 60		beq $2107			beq 	_FAExit 					; if so, just return A
.20a7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20a9	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20ab	f0 18		beq $20c5			beq 	_FAExponentsEqual
.20ad	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20af	a8		tay				tay
.20b0	38		sec				sec 								; do a signed comparison of the exponents.
.20b1	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20b3	50 02		bvc $20b7			bvc 	_FANoSignedChange
.20b5	49 80		eor #$80			eor 	#$80
.20b7					_FANoSignedChange:
.20b7	29 80		and #$80			and 	#$80
.20b9	10 02		bpl $20bd			bpl 	_FAHaveMax
.20bb	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.20bd					_FAHaveMax:
.20bd	20 08 21	jsr $2108			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20c0	e8		inx				inx
.20c1	20 08 21	jsr $2108			jsr 	_FAShiftToExponent
.20c4	ca		dex				dex
.20c5					_FAExponentsEqual:
.20c5	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.20c7	55 33		eor $33,x			eor 	NSStatus+1,x
.20c9	30 0e		bmi $20d9			bmi 	_FADifferentSigns
.20cb	20 f2 23	jsr $23f2			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20ce	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20d0	10 35		bpl $2107			bpl 	_FAExit 					; if no, we are done.
.20d2	20 7f 26	jsr $267f			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20d5	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.20d7	80 2e		bra $2107			bra 	_FAExit
.20d9					_FADifferentSigns:
.20d9	20 0c 24	jsr $240c			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20dc	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.20de	10 06		bpl $20e6			bpl 	_FACheckZero 				; if no, check for -0
.20e0	20 28 26	jsr $2628			jsr 	FloatNegate 					; netate result
.20e3	20 2f 26	jsr $262f			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20e6					_FACheckZero:
.20e6	20 88 26	jsr $2688			jsr 	FloatIsZero	 				; check for -0
.20e9	d0 1c		bne $2107			bne 	_FAExit
.20eb	74 32		stz $32,x			stz 	NSStatus,x
.20ed	80 18		bra $2107			bra 	_FAExit
.20ef					_FAReturn1:
.20ef	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20f1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.20f3	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.20f5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.20f7	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.20f9	95 56		sta $56,x			sta 	NSMantissa2,x
.20fb	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.20fd	95 62		sta $62,x			sta 	NSMantissa3,x
.20ff	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.2101	95 6e		sta $6e,x			sta 	NSExponent,x
.2103	b5 33		lda $33,x			lda 	NSStatus+1,x
.2105	95 32		sta $32,x			sta 	NSStatus,x
.2107					_FAExit:
.2107	60		rts				rts
.2108					_FAShiftToExponent:
.2108					_FAShiftToExponent2:
.2108	98		tya				tya 								; compare Y to exponent
.2109	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.210b	f0 07		beq $2114			beq 	_FASEExit 					; exit if so.
.210d	20 7f 26	jsr $267f			jsr 	FloatShiftRight	 			; shift the mantissa right
.2110	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.2112	80 f4		bra $2108			bra 	_FAShiftToExponent2
.2114					_FASEExit:
.2114	60		rts				rts
.2115					CompareEqual:
.2115	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2117	d0 09		bne $2122			bne 	ReturnFalse
.2119					ReturnTrue:
.2119	a9 01		lda #$01			lda 	#1
.211b	95 3e		sta $3e,x			sta 	NSMantissa0,x
.211d	a9 80		lda #$80			lda 	#$80
.211f	95 32		sta $32,x			sta 	NSStatus,x
.2121	60		rts				rts
.2122					ReturnFalse:
.2122	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2124	60		rts				rts
.2125					CompareNotEqual:
.2125	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2127	d0 f0		bne $2119			bne 	ReturnTrue
.2129	80 f7		bra $2122			bra 	ReturnFalse
.212b					CompareLess:
.212b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.212d	c9 ff		cmp #$ff			cmp 	#$FF
.212f	f0 e8		beq $2119			beq 	ReturnTrue
.2131	80 ef		bra $2122			bra 	ReturnFalse
.2133					CompareGreater:
.2133	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2135	c9 01		cmp #$01			cmp 	#$01
.2137	f0 e0		beq $2119			beq 	ReturnTrue
.2139	80 e7		bra $2122			bra 	ReturnFalse
.213b					CompareLessEqual:
.213b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.213d	c9 01		cmp #$01			cmp 	#$01
.213f	d0 d8		bne $2119			bne 	ReturnTrue
.2141	80 df		bra $2122			bra 	ReturnFalse
.2143					CompareGreaterEqual:
.2143	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2145	c9 ff		cmp #$ff			cmp 	#$FF
.2147	d0 d0		bne $2119			bne 	ReturnTrue
.2149	80 d7		bra $2122			bra 	ReturnFalse
.214b					FloatCompare:
.214b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.214d	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.214f	48		pha				pha
.2150	20 84 20	jsr $2084			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2153	68		pla				pla
.2154	d0 0c		bne $2162			bne 	_FCCompareFloat
.2156	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2158	15 4a		ora $4a,x			ora 	NSMantissa1,x
.215a	15 56		ora $56,x			ora 	NSMantissa2,x
.215c	15 62		ora $62,x			ora 	NSMantissa3,x
.215e	f0 14		beq $2174			beq 	_FCExit 					; if zero, return zero
.2160	80 0a		bra $216c			bra 	_FCSign
.2162					_FCCompareFloat:
.2162	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2164	29 f0		and #$f0			and 	#$F0
.2166	15 56		ora $56,x			ora 	NSMantissa2,x
.2168	15 62		ora $62,x			ora 	NSMantissa3,x
.216a	f0 08		beq $2174			beq 	_FCExit 					; zero, so approximately identical
.216c					_FCSign:
.216c	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.216e	34 32		bit $32,x			bit 	NSStatus,x
.2170	10 02		bpl $2174			bpl 	_FCExit
.2172					_FCNegative:
.2172	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2174					_FCExit:
.2174	20 68 26	jsr $2668			jsr 	FloatSetByte 				; set the result 255,0,1
.2177	60		rts				rts
.2178					FloatScalarTable:
>2178	66 66 66 66				.dword $66666666 ; 0.1
>217c	de					.byte $de
>217d	1f 85 eb 51				.dword $51eb851f ; 0.01
>2181	db					.byte $db
>2182	4c 37 89 41				.dword $4189374c ; 0.001
>2186	d8					.byte $d8
>2187	ac 8b db 68				.dword $68db8bac ; 0.0001
>218b	d4					.byte $d4
>218c	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>2190	d1					.byte $d1
>2191	83 de 1b 43				.dword $431bde83 ; 1e-06
>2195	ce					.byte $ce
>2196	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>219a	ca					.byte $ca
>219b	89 3b e6 55				.dword $55e63b89 ; 1e-08
>219f	c7					.byte $c7
>21a0	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21a4	c4					.byte $c4
>21a5	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21a9	c0					.byte $c0
>21aa	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21ae	bd					.byte $bd
.21af					FloatDivide:
.21af	48		pha				pha
.21b0	20 bb 23	jsr $23bb			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21b3	ca		dex				dex
.21b4	c9 00		cmp #$00			cmp 	#0
.21b6	f0 1e		beq $21d6			beq 	_FDZero
.21b8	20 bb 23	jsr $23bb			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21bb	f0 16		beq $21d3			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21bd	20 1e 22	jsr $221e			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21c0	20 eb 21	jsr $21eb			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21c3	20 bb 23	jsr $23bb			jsr		FloatNormalise 				; renormalise
.21c6	20 b1 23	jsr $23b1			jsr 	FloatCalculateSign 			; calculate result sign
.21c9	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.21cb	38		sec				sec
.21cc	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.21ce	38		sec				sec
.21cf	e9 1e		sbc #$1e			sbc 	#30
.21d1	95 6e		sta $6e,x			sta 	NSExponent,x
.21d3					_FDExit:
.21d3	68		pla				pla
.21d4	18		clc				clc
.21d5	60		rts				rts
.21d6					_FDZero:
.21d6	68		pla				pla
.21d7	38		sec				sec
.21d8	60		rts				rts
.21d9					DivideInt32:
.21d9	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart 			; make both integers
.21dc	ca		dex				dex
.21dd	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.21e0	20 fc 21	jsr $21fc			jsr 	Int32Divide 				; divide
.21e3	20 eb 21	jsr $21eb			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21e6	20 b1 23	jsr $23b1			jsr 	FloatCalculateSign 			; calculate result sign
.21e9	18		clc				clc
.21ea	60		rts				rts
.21eb					NSMCopyPlusTwoToZero:
.21eb	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21ed	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21ef	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21f1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.21f3	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.21f5	95 56		sta $56,x			sta 	NSMantissa2,x
.21f7	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.21f9	95 62		sta $62,x			sta 	NSMantissa3,x
.21fb	60		rts				rts
.21fc					Int32Divide:
.21fc	48		pha				pha 								; save AXY
.21fd	5a		phy				phy
.21fe	20 49 26	jsr $2649			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2201	20 62 26	jsr $2662			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2204	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2206					_I32DivideLoop:
.2206	e8		inx				inx
.2207	e8		inx				inx
.2208	20 75 26	jsr $2675			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.220b	ca		dex				dex
.220c	ca		dex				dex
.220d	20 76 26	jsr $2676			jsr 	FloatRotateLeft
.2210	20 3c 22	jsr $223c			jsr 	FloatDivideCheck 			; check if subtract possible
.2213	90 02		bcc $2217			bcc 	_I32DivideNoCarryIn
.2215	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2217					_I32DivideNoCarryIn:
.2217	88		dey				dey 								; loop round till division completed.
.2218	d0 ec		bne $2206			bne 	_I32DivideLoop
.221a	7a		ply				ply 								; restore AXY and exit
.221b	68		pla				pla
.221c	18		clc				clc
.221d	60		rts				rts
.221e					Int32ShiftDivide:
.221e	48		pha				pha 								; save AY
.221f	5a		phy				phy
.2220	e8		inx				inx 								; clear S[X+2]
.2221	e8		inx				inx
.2222	20 66 26	jsr $2666			jsr 	FloatSetZero
.2225	ca		dex				dex
.2226	ca		dex				dex
.2227	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2229					_I32SDLoop:
.2229	20 3c 22	jsr $223c			jsr 	FloatDivideCheck 			; check if subtract possible
.222c	e8		inx				inx
.222d	e8		inx				inx
.222e	20 76 26	jsr $2676			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.2231	ca		dex				dex
.2232	ca		dex				dex
.2233	20 76 26	jsr $2676			jsr 	FloatRotateLeft
.2236	88		dey				dey 	 							; do 31 times
.2237	d0 f0		bne $2229			bne 	_I32SDLoop
.2239	7a		ply				ply 								; restore AY and exit
.223a	68		pla				pla
.223b	60		rts				rts
.223c					FloatDivideCheck:
.223c	20 0c 24	jsr $240c			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.223f	b0 04		bcs $2245			bcs 	_DCSExit 					; if carry set, then could do, exit
.2241	20 f2 23	jsr $23f2			jsr 	FloatAddTopTwoStack 		; add it back in
.2244	18		clc				clc 								; and return False
.2245					_DCSExit:
.2245	60		rts				rts
.2246					FloatFractionalPart:
.2246	5a		phy				phy
.2247	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.2249	29 7f		and #$7f			and 	#$7F
.224b	95 32		sta $32,x			sta 	NSStatus,x
.224d	20 bb 23	jsr $23bb			jsr 	FloatNormalise
.2250	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2252	38		sec				sec
.2253	e9 e0		sbc #$e0			sbc 	#$E0
.2255	90 29		bcc $2280			bcc 	_FFPExit 					; already fractional
.2257	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2259	b0 22		bcs $227d			bcs 	_FFPZero
.225b	a8		tay				tay 								; put count to do in Y
.225c	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.225e	20 85 22	jsr $2285			jsr 	_FFPPartial
.2261	95 62		sta $62,x			sta 	NSMantissa3,x
.2263	b5 56		lda $56,x			lda 	NSMantissa2,x
.2265	20 85 22	jsr $2285			jsr 	_FFPPartial
.2268	95 56		sta $56,x			sta 	NSMantissa2,x
.226a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.226c	20 85 22	jsr $2285			jsr 	_FFPPartial
.226f	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2271	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2273	20 85 22	jsr $2285			jsr 	_FFPPartial
.2276	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2278	20 88 26	jsr $2688			jsr 	FloatIsZero 					; zeroed check.
.227b	d0 03		bne $2280			bne 	_FFPExit
.227d					_FFPZero:
.227d	20 66 26	jsr $2666			jsr 	FloatSetZero
.2280					_FFPExit:
.2280	20 bb 23	jsr $23bb			jsr 	FloatNormalise
.2283	7a		ply				ply
.2284	60		rts				rts
.2285					_FFPPartial:
.2285	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2287	f0 17		beq $22a0			beq 	_FFFPPExit
.2289	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.228b	b0 0c		bcs $2299			bcs 	_FFFPPWholeByte
.228d	5a		phy				phy
.228e					_FFFPPLeft:
.228e	0a		asl a				asl 	a
.228f	88		dey				dey
.2290	d0 fc		bne $228e			bne 	_FFFPPLeft
.2292	7a		ply				ply
.2293					_FFFPPRight:
.2293	4a		lsr a				lsr 	a
.2294	88		dey				dey
.2295	d0 fc		bne $2293			bne 	_FFFPPRight
.2297	80 07		bra $22a0			bra 	_FFFPPExit
.2299					_FFFPPWholeByte:
.2299	98		tya				tya 								; subtract 8 from count
.229a	38		sec				sec
.229b	e9 08		sbc #$08			sbc 	#8
.229d	a8		tay				tay
.229e	a9 00		lda #$00			lda 	#0 							; and clear all
.22a0					_FFFPPExit:
.22a0	60		rts				rts
.22a1					FloatIntegerPart:
.22a1	48		pha				pha
.22a2	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22a4	f0 1d		beq $22c3			beq 	_FIPExit 					; if so do nothing
.22a6	20 88 26	jsr $2688			jsr 	FloatIsZero 				; is it zero ?
.22a9	f0 15		beq $22c0			beq 	_FIPZero 					; if so return zero.
.22ab	20 bb 23	jsr $23bb			jsr 	FloatNormalise 				; normalise
.22ae	f0 10		beq $22c0			beq 	_FIPZero 					; normalised to zero, exit zero
.22b0					_FIPShift:
.22b0	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22b2	10 07		bpl $22bb			bpl 	_FIPCheckZero
.22b4	20 7f 26	jsr $267f			jsr 	FloatShiftRight 			; shift mantissa right
.22b7	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22b9	80 f5		bra $22b0			bra 	_FIPShift
.22bb					_FIPCheckZero:
.22bb	20 88 26	jsr $2688			jsr 	FloatIsZero 				; avoid -0 problem
.22be	d0 03		bne $22c3			bne 	_FIPExit 					; set to zero if mantissa zero.
.22c0					_FIPZero:
.22c0	20 66 26	jsr $2666			jsr 	FloatSetZero
.22c3					_FIPExit:
.22c3	68		pla				pla
.22c4	60		rts				rts
.22c5					FloatIntegerPartDown:
.22c5	48		pha				pha
.22c6	5a		phy				phy
.22c7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22c9	f0 36		beq $2301			beq 	_FIPExit 					; if so do nothing
.22cb	20 88 26	jsr $2688			jsr 	FloatIsZero 				; is it zero ?
.22ce	f0 2e		beq $22fe			beq 	_FIPZero 					; if so return zero.
.22d0	20 bb 23	jsr $23bb			jsr 	FloatNormalise 				; normalise
.22d3	f0 29		beq $22fe			beq 	_FIPZero 					; normalised to zero, exit zero
.22d5	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22d7					_FIPShift:
.22d7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22d9	10 0a		bpl $22e5			bpl 	_FIPCheckDown
.22db	20 7f 26	jsr $267f			jsr 	FloatShiftRight 			; shift mantissa right
.22de	90 01		bcc $22e1			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22e0	c8		iny				iny
.22e1					_FIPNoFrac:
.22e1	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22e3	80 f2		bra $22d7			bra 	_FIPShift
.22e5					_FIPCheckDown:
.22e5	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22e7	f0 10		beq $22f9			beq 	_FIPCheckZero
.22e9	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22eb	10 0c		bpl $22f9			bpl 	_FIPCheckZero
.22ed	e8		inx				inx 								; -ve so round *down*.
.22ee	a9 01		lda #$01			lda 	#1
.22f0	20 68 26	jsr $2668			jsr 	FloatSetByte
.22f3	20 28 26	jsr $2628			jsr 	FloatNegate
.22f6	20 8a 20	jsr $208a			jsr 	FloatAdd
.22f9					_FIPCheckZero:
.22f9	20 88 26	jsr $2688			jsr 	FloatIsZero 				; avoid -0 problem
.22fc	d0 03		bne $2301			bne 	_FIPExit 					; set to zero if mantissa zero.
.22fe					_FIPZero:
.22fe	20 66 26	jsr $2666			jsr 	FloatSetZero
.2301					_FIPExit:
.2301	7a		ply				ply
.2302	68		pla				pla
.2303	60		rts				rts
.2304					FloatInt8Multiply:
.2304	5a		phy				phy
.2305	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2307	a8		tay				tay
.2308	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.230a					_FI8MLoop:
.230a	98		tya				tya 								; shift right shifter right into carry
.230b	4a		lsr a				lsr 	a
.230c	a8		tay				tay
.230d	90 0d		bcc $231c			bcc 	_FI8MNoAdd
.230f	18		clc				clc
.2310	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2312	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.2314	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2316	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2318	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.231a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.231c					_FI8MNoAdd:
.231c	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.231e	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.2320	c0 00		cpy #$00			cpy 	#0
.2322	d0 e6		bne $230a			bne 	_FI8MLoop 					; until right shifter zero.
.2324	7a		ply				ply
.2325	60		rts				rts
.2326					FloatMultiply:
.2326	ca		dex				dex
.2327	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.2329	15 6f		ora $6f,x			ora 	NSExponent+1,x
.232b	15 62		ora $62,x			ora 	NSMantissa3,x
.232d	15 63		ora $63,x			ora 	NSMantissa3+1,x
.232f	d0 21		bne $2352			bne 	_FMUseFloat
.2331	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2333	15 33		ora $33,x			ora 	NSStatus+1,x
.2335	29 80		and #$80			and 	#$80
.2337	15 62		ora $62,x			ora 	NSMantissa3,x
.2339	15 56		ora $56,x			ora 	NSMantissa2,x
.233b	15 4a		ora $4a,x			ora 	NSMantissa1,x
.233d	15 63		ora $63,x			ora 	NSMantissa3+1,x
.233f	15 57		ora $57,x			ora 	NSMantissa2+1,x
.2341	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2343	d0 04		bne $2349			bne 	_FMInt32
.2345	20 04 23	jsr $2304			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2348	60		rts				rts
.2349					_FMInt32:
.2349	20 73 23	jsr $2373			jsr 	FloatMultiplyShort			; use the int32 one.
.234c	18		clc				clc 								; fix it up if gone out of range
.234d	75 6e		adc $6e,x			adc 	NSExponent,x
.234f	95 6e		sta $6e,x			sta 	NSExponent,x
.2351	60		rts				rts
.2352					_FMUseFloat:
.2352	20 bb 23	jsr $23bb			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2355	f0 18		beq $236f			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2357	e8		inx				inx
.2358	20 bb 23	jsr $23bb			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.235b	ca		dex				dex
.235c	c9 00		cmp #$00			cmp 	#0
.235e	f0 0c		beq $236c			beq 	_FDSetZero
.2360	20 73 23	jsr $2373			jsr 	FloatMultiplyShort 			; calculate the result.
.2363	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2365	18		clc				clc
.2366	75 6f		adc $6f,x			adc 	NSExponent+1,x
.2368	95 6e		sta $6e,x			sta 	NSExponent,x
.236a	80 03		bra $236f			bra 	_FDExit
.236c					_FDSetZero:
.236c	20 66 26	jsr $2666			jsr 	FloatSetZero 				; return 0
.236f					_FDExit:
.236f	20 bb 23	jsr $23bb			jsr 	FloatNormalise 				; normalise the result
.2372	60		rts				rts
.2373					FloatMultiplyShort:
.2373	5a		phy				phy 								; save Y
.2374	20 49 26	jsr $2649			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2377	20 62 26	jsr $2662			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.237a	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.237c					_I32MLoop:
.237c	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.237e	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.2380	15 58		ora $58,x			ora 	NSMantissa2+2,x
.2382	15 64		ora $64,x			ora 	NSMantissa3+2,x
.2384	f0 25		beq $23ab			beq 	_I32MExit 					; exit if zero
.2386	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2388	29 01		and #$01			and 	#1
.238a	f0 0d		beq $2399			beq 	_I32MNoAdd
.238c	20 f2 23	jsr $23f2			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.238f	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.2391	10 06		bpl $2399			bpl 	_I32MNoAdd
.2393					_I32ShiftRight:
.2393	20 7f 26	jsr $267f			jsr 	FloatShiftRight 			; shift S[X] right
.2396	c8		iny				iny 								; increment shift count
.2397	80 09		bra $23a2			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.2399					_I32MNoAdd:
.2399	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.239b	70 f6		bvs $2393			bvs 	_I32ShiftRight 				; instead.
.239d	e8		inx				inx
.239e	20 75 26	jsr $2675			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23a1	ca		dex				dex
.23a2					_I32MShiftUpper:
.23a2	e8		inx				inx 								; shift S[X+2] right
.23a3	e8		inx				inx
.23a4	20 7f 26	jsr $267f			jsr 	FloatShiftRight
.23a7	ca		dex				dex
.23a8	ca		dex				dex
.23a9	80 d1		bra $237c			bra 	_I32MLoop 					; try again.
.23ab					_I32MExit:
.23ab	20 b1 23	jsr $23b1			jsr 	FloatCalculateSign
.23ae	98		tya				tya 								; shift in A
.23af	7a		ply				ply 								; restore Y and exit
.23b0	60		rts				rts
.23b1					FloatCalculateSign:
.23b1	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23b3	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23b5	55 33		eor $33,x			eor 	NSStatus+1,x
.23b7	0a		asl a				asl 	a 							; shift bit 7 into carry
.23b8	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23ba	60		rts				rts
.23bb					FloatNormalise:
.23bb	20 88 26	jsr $2688			jsr 	FloatIsZero 				; if zero exit
.23be	d0 07		bne $23c7			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23c0	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.23c2	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.23c4	a9 00		lda #$00			lda 	#0 							; set Z flag
.23c6	60		rts				rts
.23c7					_NSNormaliseOptimise:
.23c7	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23c9	d0 19		bne $23e4			bne 	_NSNormaliseLoop
.23cb	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.23cd	30 15		bmi $23e4			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23cf	95 62		sta $62,x			sta 	NSMantissa3,x
.23d1	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.23d3	95 56		sta $56,x			sta 	NSMantissa2,x
.23d5	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.23d7	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23d9	74 3e		stz $3e,x			stz 	NSMantissa0,x
.23db	b5 6e		lda $6e,x			lda 	NSExponent,x
.23dd	38		sec				sec
.23de	e9 08		sbc #$08			sbc 	#8
.23e0	95 6e		sta $6e,x			sta 	NSExponent,x
.23e2	80 e3		bra $23c7			bra 	_NSNormaliseOptimise
.23e4					_NSNormaliseLoop:
.23e4	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23e6	70 07		bvs $23ef			bvs 	_NSNExit 					; exit if so with Z flag clear
.23e8	20 75 26	jsr $2675			jsr 	FloatShiftLeft 				; shift mantissa left
.23eb	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23ed	80 f5		bra $23e4			bra 	_NSNormaliseLoop
.23ef					_NSNExit:
.23ef	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23f1	60		rts				rts
.23f2					FloatAddTopTwoStack:
.23f2	18		clc				clc
.23f3	b5 3e		lda $3e,x			lda		NSMantissa0,x
.23f5	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.23f7	95 3e		sta $3e,x			sta 	NSMantissa0,x
.23f9	b5 4a		lda $4a,x			lda		NSMantissa1,x
.23fb	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.23fd	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23ff	b5 56		lda $56,x			lda		NSMantissa2,x
.2401	75 57		adc $57,x			adc 		NSMantissa2+1,x
.2403	95 56		sta $56,x			sta 	NSMantissa2,x
.2405	b5 62		lda $62,x			lda		NSMantissa3,x
.2407	75 63		adc $63,x			adc 		NSMantissa3+1,x
.2409	95 62		sta $62,x			sta 	NSMantissa3,x
.240b	60		rts				rts
.240c					FloatSubTopTwoStack:
.240c	38		sec				sec
.240d	b5 3e		lda $3e,x			lda		NSMantissa0,x
.240f	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.2411	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2413	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2415	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.2417	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2419	b5 56		lda $56,x			lda		NSMantissa2,x
.241b	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.241d	95 56		sta $56,x			sta 	NSMantissa2,x
.241f	b5 62		lda $62,x			lda		NSMantissa3,x
.2421	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.2423	95 62		sta $62,x			sta 	NSMantissa3,x
.2425	60		rts				rts
.2426					FloatInt32Add:
.2426	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2428	55 33		eor $33,x			eor 	NSStatus+1,x
.242a	30 04		bmi $2430			bmi 	_DiffSigns
.242c	20 f2 23	jsr $23f2			jsr		FloatAddTopTwoStack
.242f	60		rts				rts
.2430					_DiffSigns:
.2430	20 0c 24	jsr $240c			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2433	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2435	10 07		bpl $243e			bpl 	_AddExit
.2437	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2439	95 32		sta $32,x			sta 	NSStatus,x
.243b	20 2f 26	jsr $262f			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.243e					_AddExit:
.243e	20 88 26	jsr $2688			jsr 	FloatIsZero 				; check for -0
.2441	d0 02		bne $2445			bne 	_AddNonZero
.2443	74 32		stz $32,x			stz 	NSStatus,x
.2445					_AddNonZero:
.2445	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2446					FloatEncodeStart:
.2446	38		sec				sec
.2447	80 01		bra $244a			bra 	FloatEncodeContinue+1
.2449					FloatEncodeContinue:
.2449	18		clc				clc
.244a					FloatEncode:
.244a	08		php				php 								; save reset flag.
.244b	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.244d	f0 15		beq $2464			beq 	_ENIsOkay
.244f	c9 30		cmp #$30			cmp 	#"0"
.2451	90 04		bcc $2457			bcc 	_ENBadNumber
.2453	c9 3a		cmp #$3a			cmp 	#"9"+1
.2455	90 0d		bcc $2464			bcc 	_ENIsOkay
.2457					_ENBadNumber:
.2457	28		plp				plp 								; throw saved reset
.2458	ad 93 05	lda $0593			lda 	encodeState 				; if in decimal mode, construct final number
.245b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.245d	d0 03		bne $2462			bne 	_ENFail
.245f	4c dc 24	jmp $24dc			jmp 	_ENConstructFinal
.2462					_ENFail:
.2462	18		clc				clc 								; not allowed
.2463	60		rts				rts
.2464					_ENIsOkay:
.2464	28		plp				plp 								; are we restarting
.2465	90 15		bcc $247c			bcc 	_ENNoRestart
.2467					_ENStartEncode:
.2467	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2469	f0 0c		beq $2477			beq 	_ENFirstDP
.246b	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.246d	20 68 26	jsr $2668			jsr 	FloatSetByte 				; in single byte mode.
.2470	a9 01		lda #$01			lda 	#ESTA_Low
.2472					_ENExitChange:
.2472	8d 93 05	sta $0593			sta 	encodeState 				; save new state
.2475	38		sec				sec
.2476	60		rts				rts
.2477					_ENFirstDP:
.2477	20 66 26	jsr $2666			jsr 	FloatSetZero 				; clear integer part
.247a	80 3c		bra $24b8			bra 	_ESTASwitchFloat			; go straight to float and exi
.247c					_ENNoRestart:
.247c	48		pha				pha 								; save digit or DP on stack.
.247d	ad 93 05	lda $0593			lda 	encodeState 				; get current state
.2480	c9 01		cmp #$01			cmp 	#ESTA_Low
.2482	f0 09		beq $248d			beq  	_ESTALowState
.2484	c9 02		cmp #$02			cmp 	#ESTA_High
.2486	f0 26		beq $24ae			beq 	_ESTAHighState
.2488	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.248a	f0 38		beq $24c4			beq 	_ESTADecimalState
>248c	db						.byte 	$DB 						; causes a break in the emulator
.248d					_ESTALowState:
.248d	68		pla				pla 								; get value back
.248e	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.2490	f0 26		beq $24b8			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.2492	29 0f		and #$0f			and 	#15 						; make digit
.2494	8d 94 05	sta $0594			sta 	digitTemp 					; save it.
.2497	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.2499	0a		asl a				asl 	a
.249a	0a		asl a				asl 	a
.249b	75 3e		adc $3e,x			adc 	NSMantissa0,x
.249d	0a		asl a				asl 	a
.249e	6d 94 05	adc $0594			adc 	digitTemp
.24a1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24a3	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24a5	90 05		bcc $24ac			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24a7	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24a9	8d 93 05	sta $0593			sta 	encodeState
.24ac					_ESTANoSwitch:
.24ac	38		sec				sec
.24ad	60		rts				rts
.24ae					_ESTAHighState:
.24ae	68		pla				pla 								; get value back
.24af	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24b1	f0 05		beq $24b8			beq 	_ESTASwitchFloat
.24b3	20 0e 25	jsr $250e			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24b6	38		sec				sec
.24b7	60		rts				rts
.24b8					_ESTASwitchFloat:
.24b8	9c 95 05	stz $0595			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24bb	e8		inx				inx 								; zero the decimal additive.
.24bc	20 66 26	jsr $2666			jsr 	FloatSetZero
.24bf	ca		dex				dex
.24c0	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24c2	80 ae		bra $2472			bra 	_ENExitChange
.24c4					_ESTADecimalState:
.24c4	68		pla				pla 								; digit.
.24c5	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24c7	f0 99		beq $2462			beq 	_ENFail
.24c9	e8		inx				inx 								; put digit into fractional part of X+1
.24ca	20 0e 25	jsr $250e			jsr 	ESTAShiftDigitIntoMantissa
.24cd	ca		dex				dex
.24ce	ee 95 05	inc $0595			inc 	decimalCount 				; bump the count of decimals
.24d1	ad 95 05	lda $0595			lda 	decimalCount 				; too many decimal digits.
.24d4	c9 0b		cmp #$0b			cmp 	#11
.24d6	f0 02		beq $24da			beq 	_ESTADSFail
.24d8	38		sec				sec
.24d9	60		rts				rts
.24da					_ESTADSFail:
.24da	18		clc				clc
.24db	60		rts				rts
.24dc					_ENConstructFinal:
.24dc	ad 95 05	lda $0595			lda 	decimalCount 				; get decimal count
.24df	f0 2b		beq $250c			beq 	_ENCFExit 					; no decimals
.24e1	5a		phy				phy
.24e2	0a		asl a				asl 	a 							; x 4 and CLC
.24e3	0a		asl a				asl 	a
.24e4	6d 95 05	adc $0595			adc 	decimalCount
.24e7	a8		tay				tay
.24e8	b9 73 21	lda $2173,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24eb	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24ed	b9 74 21	lda $2174,y			lda 	FloatScalarTable-5+1,y
.24f0	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.24f2	b9 75 21	lda $2175,y			lda 	FloatScalarTable-5+2,y
.24f5	95 58		sta $58,x			sta 	NSMantissa2+2,x
.24f7	b9 76 21	lda $2176,y			lda 	FloatScalarTable-5+3,y
.24fa	95 64		sta $64,x			sta 	NSMantissa3+2,x
.24fc	b9 77 21	lda $2177,y			lda 	FloatScalarTable-5+4,y
.24ff	95 70		sta $70,x			sta 	NSExponent+2,x
.2501	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.2503	e8		inx				inx 								; multiply decimal const by decimal scalar
.2504	e8		inx				inx
.2505	20 26 23	jsr $2326			jsr 	FloatMultiply
.2508	20 8a 20	jsr $208a			jsr 	FloatAdd 					; add to integer part.
.250b	7a		ply				ply
.250c					_ENCFExit:
.250c	18		clc				clc 								; reject the digit.
.250d	60		rts				rts
.250e					ESTAShiftDigitIntoMantissa:
.250e	29 0f		and #$0f			and 	#15 						; save digit
.2510	48		pha				pha
.2511	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2513	48		pha				pha
.2514	b5 56		lda $56,x			lda 	NSMantissa2,x
.2516	48		pha				pha
.2517	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2519	48		pha				pha
.251a	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.251c	48		pha				pha
.251d	20 75 26	jsr $2675			jsr 	FloatShiftLeft 				; x 2
.2520	20 75 26	jsr $2675			jsr 	FloatShiftLeft 				; x 4
.2523	18		clc				clc 								; pop mantissa and add
.2524	68		pla				pla
.2525	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2527	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2529	68		pla				pla
.252a	75 4a		adc $4a,x			adc 	NSMantissa1,x
.252c	95 4a		sta $4a,x			sta 	NSMantissa1,x
.252e	68		pla				pla
.252f	75 56		adc $56,x			adc 	NSMantissa2,x
.2531	95 56		sta $56,x			sta 	NSMantissa2,x
.2533	68		pla				pla
.2534	75 62		adc $62,x			adc 	NSMantissa3,x
.2536	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.2538	20 75 26	jsr $2675			jsr 	FloatShiftLeft 				; x 10
.253b	68		pla				pla 								; add digit
.253c	18		clc				clc
.253d	75 3e		adc $3e,x			adc 	NSMantissa0,x
.253f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2541	90 0a		bcc $254d			bcc 	_ESTASDExit
.2543	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2545	d0 06		bne $254d			bne 	_ESTASDExit
.2547	f6 56		inc $56,x			inc 	NSMantissa2,x
.2549	d0 02		bne $254d			bne 	_ESTASDExit
.254b	f6 62		inc $62,x			inc 	NSMantissa3,x
.254d					_ESTASDExit:
.254d	60		rts				rts
.0593					encodeState:
>0593							.fill 	1
.0594					digitTemp:
>0594							.fill 	1
.0595					decimalCount:
>0595							.fill 	1
.254e					FloatToString:
.254e	da		phx				phx
.254f	5a		phy				phy 								; save code position
.2550	8d 96 05	sta $0596			sta 	decimalPlaces	 			; save number of DPs.
.2553	9c 97 05	stz $0597			stz 	dbOffset 					; offset into decimal buffer = start.
.2556	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.2558	10 08		bpl $2562			bpl 	_CNTSNotNegative
.255a	29 7f		and #$7f			and 	#$7F 						; make +ve
.255c	95 32		sta $32,x			sta 	NSStatus,x
.255e	a9 2d		lda #$2d			lda 	#"-"
.2560	80 02		bra $2564			bra 	_CNTMain
.2562					_CNTSNotNegative:
.2562	a9 20		lda #$20			lda 	#" "
.2564					_CNTMain:
.2564	20 c6 25	jsr $25c6			jsr 	WriteDecimalBuffer
.2567	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.2569	f0 0d		beq $2578			beq 	_CNTSNotFloat
.256b	e8		inx				inx 								; round up so we don't get too many 6.999999
.256c	a9 01		lda #$01			lda 	#1
.256e	20 68 26	jsr $2668			jsr 	FloatSetByte
.2571	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2573	95 6e		sta $6e,x			sta 	NSExponent,x
.2575	20 8a 20	jsr $208a			jsr 	FloatAdd
.2578					_CNTSNotFloat:
.2578	20 a8 25	jsr $25a8			jsr 	MakePlusTwoString 			; do the integer part.
.257b	20 46 22	jsr $2246			jsr 	FloatFractionalPart 		; get the fractional part
.257e	20 bb 23	jsr $23bb			jsr 	FloatNormalise					; normalise , exit if zero
.2581	f0 22		beq $25a5			beq 	_CNTSExit
.2583	a9 2e		lda #$2e			lda 	#"."
.2585	20 c6 25	jsr $25c6			jsr 	WriteDecimalBuffer 			; write decimal place
.2588					_CNTSDecimal:
.2588	ce 96 05	dec $0596			dec 	decimalPlaces 				; done all the decimals
.258b	30 18		bmi $25a5			bmi 	_CNTSExit
.258d	e8		inx				inx 								; x 10.0
.258e	a9 0a		lda #$0a			lda 	#10
.2590	20 68 26	jsr $2668			jsr 	FloatSetByte
.2593	20 26 23	jsr $2326			jsr 	FloatMultiply
.2596	20 a8 25	jsr $25a8			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.2599	20 46 22	jsr $2246			jsr 	FloatFractionalPart 		; get the fractional part
.259c	20 bb 23	jsr $23bb			jsr 	FloatNormalise 				; normalise it.
.259f	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25a1	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25a3	b0 e3		bcs $2588			bcs 	_CNTSDecimal 				; keep going.
.25a5					_CNTSExit:
.25a5	7a		ply				ply
.25a6	fa		plx				plx
.25a7	60		rts				rts
.25a8					MakePlusTwoString:
.25a8	da		phx				phx
.25a9	20 49 26	jsr $2649			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25ac	e8		inx				inx 								; access it
.25ad	e8		inx				inx
.25ae	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart 			; make it an integer
.25b1	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25b3	20 e5 25	jsr $25e5			jsr 	ConvertInt32
.25b6	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25b8					_MPTSCopy:
.25b8	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25bb	20 c6 25	jsr $25c6			jsr 	WriteDecimalBuffer
.25be	e8		inx				inx
.25bf	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25c2	d0 f4		bne $25b8			bne 	_MPTSCopy
.25c4	fa		plx				plx
.25c5	60		rts				rts
.25c6					WriteDecimalBuffer:
.25c6	da		phx				phx
.25c7	ae 97 05	ldx $0597			ldx 	dbOffset
.25ca	9d 98 05	sta $0598,x			sta 	decimalBuffer,x
.25cd	9e 99 05	stz $0599,x			stz 	decimalBuffer+1,x
.25d0	ee 97 05	inc $0597			inc 	dbOffset
.25d3	fa		plx				plx
.25d4	60		rts				rts
.0596					decimalPlaces:
>0596							.fill 	1
.0597					dbOffset:
>0597							.fill 	1
.0598					decimalBuffer:
>0598							.fill 	32
.25d5					ConvertInt16:
.25d5	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.25d7	86 4a		stx $4a				stx 	NSMantissa1
.25d9	64 56		stz $56				stz 	NSMantissa2
.25db	64 62		stz $62				stz 	NSMantissa3
.25dd	64 32		stz $32				stz 	NSStatus 					; positive integer
.25df	a2 00		ldx #$00			ldx 	#0 							; stack level
.25e1	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25e3	80 00		bra $25e5			bra 	ConvertInt32
.25e5					ConvertInt32:
.25e5	5a		phy				phy
.25e6	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25e8	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25ea	10 08		bpl $25f4			bpl 	_CI32NotNeg
.25ec	48		pha				pha
.25ed	a9 2d		lda #$2d			lda 	#'-'
.25ef	99 71 05	sta $0571,y			sta 	numberBuffer,y
.25f2	c8		iny				iny
.25f3	68		pla				pla
.25f4					_CI32NotNeg:
.25f4	20 02 26	jsr $2602			jsr 	_CI32DivideConvert 			; recursive conversion
.25f7	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.25f9	99 71 05	sta $0571,y			sta 	numberBuffer,y
.25fc	7a		ply				ply
.25fd	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.25ff	a9 71		lda #$71			lda 	#numberBuffer & $FF
.2601	60		rts				rts
.2602					_CI32DivideConvert:
.2602	e8		inx				inx 								; write to next slot up
.2603	20 68 26	jsr $2668			jsr 	FloatSetByte 		 		; write the base out.
.2606	ca		dex				dex
.2607	20 fc 21	jsr $21fc			jsr 	Int32Divide 				; divide
.260a	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.260c	48		pha				pha
.260d	20 eb 21	jsr $21eb			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.2610	20 88 26	jsr $2688			jsr 	FloatIsZero 				; is it zero ?
.2613	f0 05		beq $261a			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2615	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2617	20 02 26	jsr $2602			jsr 	_CI32DivideConvert 			; and recusrively call.
.261a					_CI32NoRecurse:
.261a	68		pla				pla 								; remainder
.261b	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.261d	90 02		bcc $2621			bcc 	_CI32NotHex
.261f	69 26		adc #$26			adc 	#6+32
.2621					_CI32NotHex:
.2621	69 30		adc #$30			adc 	#48
.2623	99 71 05	sta $0571,y			sta 	numberBuffer,y 				; write out and exit
.2626	c8		iny				iny
.2627	60		rts				rts
.2628					FloatNegate:
.2628	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.262a	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.262c	95 32		sta $32,x			sta 	NSStatus,x
.262e	60		rts				rts
.262f					FloatNegateMantissa:
.262f	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.2630	a9 00		lda #$00			lda 	#0
.2632	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2634	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2636	a9 00		lda #$00			lda 	#0
.2638	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.263a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.263c	a9 00		lda #$00			lda 	#0
.263e	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.2640	95 56		sta $56,x			sta 	NSMantissa2,x
.2642	a9 00		lda #$00			lda 	#0
.2644	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2646	95 62		sta $62,x			sta 	NSMantissa3,x
.2648	60		rts				rts
.2649					FloatShiftUpTwo:
.2649	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.264b	95 40		sta $40,x			sta 	NSMantissa0+2,x
.264d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.264f	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2651	b5 56		lda $56,x			lda 	NSMantissa2,x
.2653	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2655	b5 62		lda $62,x			lda 	NSMantissa3,x
.2657	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2659	b5 6e		lda $6e,x			lda 	NSExponent,x
.265b	95 70		sta $70,x			sta 	NSExponent+2,x
.265d	b5 32		lda $32,x			lda 	NSStatus,x
.265f	95 34		sta $34,x			sta 	NSStatus+2,x
.2661	60		rts				rts
.2662					FloatSetZeroMantissaOnly:
.2662	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2664	80 08		bra $266e			bra 	FloatZero13
.2666					FloatSetZero:
.2666	a9 00		lda #$00			lda 	#0
.2668					FloatSetByte:
.2668	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.266a					FloatSetMantissa:
.266a	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.266c	74 32		stz $32,x			stz 	NSStatus,x
.266e					FloatZero13:
.266e	74 4a		stz $4a,x			stz 	NSMantissa1,x
.2670	74 56		stz $56,x			stz 	NSMantissa2,x
.2672	74 62		stz $62,x			stz 	NSMantissa3,x
.2674	60		rts				rts
.2675					FloatShiftLeft:
.2675	18		clc				clc
.2676					FloatRotateLeft:
.2676	36 3e		rol $3e,x			rol 	NSMantissa0,x
.2678	36 4a		rol $4a,x			rol		NSMantissa1,x
.267a	36 56		rol $56,x			rol		NSMantissa2,x
.267c	36 62		rol $62,x			rol		NSMantissa3,x
.267e	60		rts				rts
.267f					FloatShiftRight:
.267f	56 62		lsr $62,x			lsr 	NSMantissa3,x
.2681	76 56		ror $56,x			ror		NSMantissa2,x
.2683	76 4a		ror $4a,x			ror		NSMantissa1,x
.2685	76 3e		ror $3e,x			ror		NSMantissa0,x
.2687	60		rts				rts
.2688					FloatIsZero:
.2688	b5 62		lda $62,x			lda 	NSMantissa3,x
.268a	15 56		ora $56,x			ora		NSMantissa2,x
.268c	15 4a		ora $4a,x			ora		NSMantissa1,x
.268e	15 3e		ora $3e,x			ora		NSMantissa0,x
.2690	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.2691					FloatArcTan:
.2691	20 bb 23	jsr $23bb			jsr 	FloatNormalise 					; normalise x
.2694	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.2696	48		pha				pha
.2697	74 32		stz $32,x			stz 	NSStatus,x
.2699	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.269b	c9 e2		cmp #$e2			cmp 	#$E2
.269d	90 25		bcc $26c4			bcc 	_UANoFixup
.269f	8a		txa				txa 									; value in +1
.26a0	a8		tay				tay
.26a1	c8		iny				iny
.26a2	20 4a 28	jsr $284a			jsr 	CopyFloatXY
.26a5	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.26a7	20 68 26	jsr $2668			jsr 	FloatSetByte
.26aa	e8		inx				inx
.26ab	20 af 21	jsr $21af			jsr 	FloatDivide
.26ae	b0 21		bcs $26d1			bcs 	_FATError
.26b0	20 d4 26	jsr $26d4			jsr 	CoreAtn 						; calculate the root
.26b3	20 3f 28	jsr $283f			jsr 	CompletePolynomial
.26b6	20 28 26	jsr $2628			jsr 	FloatNegate 					; make -ve
.26b9	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.26bb	20 96 28	jsr $2896			jsr 	LoadConstant
.26be	e8		inx				inx
.26bf	20 8a 20	jsr $208a			jsr 	FloatAdd
.26c2	80 06		bra $26ca			bra 	_UAComplete
.26c4					_UANoFixup:
.26c4	20 d4 26	jsr $26d4			jsr 	CoreAtn
.26c7	20 3f 28	jsr $283f			jsr 	CompletePolynomial
.26ca					_UAComplete:
.26ca	68		pla				pla 									; apply the result.
.26cb	55 32		eor $32,x			eor 	NSStatus,x
.26cd	95 32		sta $32,x			sta 	NSStatus,x
.26cf	18		clc				clc
.26d0	60		rts				rts
.26d1					_FATError:
.26d1	68		pla				pla
.26d2	38		sec				sec
.26d3	60		rts				rts
.26d4					CoreAtn:
.26d4	a9 42		lda #$42			lda 	#AtnCoefficients & $FF
.26d6	a0 27		ldy #$27			ldy 	#AtnCoefficients >> 8
.26d8	4c 93 29	jmp $2993			jmp 	CorePolySquared
.26db					ExpCoefficients:
>26db	07					.byte	7
>26dc	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>26e0	d2					.byte	$d2
>26e1	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>26e5	d5					.byte	$d5
>26e6	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>26ea	d8					.byte	$d8
>26eb	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>26ef	db					.byte	$db
>26f0	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>26f4	dd					.byte	$dd
>26f5	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>26f9	df					.byte	$df
>26fa	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>26fe	e1					.byte	$e1
>26ff	00 00 00 40				.dword	$40000000 ; 1.0
>2703	e2					.byte	$e2
.2704					SinCoefficients:
>2704	06					.byte	6
>2705	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>2709	e5					.byte	$e5
>270a	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>270e	e7					.byte	$e7
>270f	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>2713	e8					.byte	$e8
>2714	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>2718	e8					.byte	$e8
>2719	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>271d	e7					.byte	$e7
>271e	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>2722	e4					.byte	$e4
>2723	00 00 00 00				.dword	$00000000 ; 0.0
>2727	00					.byte	$00
.2728					LogCoefficients:
>2728	04					.byte	4
>2729	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>272d	e0					.byte	$e0
>272e	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>2732	e1					.byte	$e1
>2733	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>2737	e1					.byte	$e1
>2738	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>273c	e3					.byte	$e3
>273d	00 00 00 c0				.dword	$c0000000 ; -0.5
>2741	e1					.byte	$e1
.2742					AtnCoefficients:
>2742	0c					.byte	12
>2743	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2747	d7					.byte	$d7
>2748	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>274c	da					.byte	$da
>274d	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>2751	dc					.byte	$dc
>2752	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2756	dd					.byte	$dd
>2757	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>275b	dd					.byte	$dd
>275c	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>2760	de					.byte	$de
>2761	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2765	de					.byte	$de
>2766	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>276a	de					.byte	$de
>276b	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>276f	df					.byte	$df
>2770	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>2774	df					.byte	$df
>2775	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>2779	e0					.byte	$e0
>277a	00 00 00 40				.dword	$40000000 ; 1.0
>277e	e2					.byte	$e2
>277f	00 00 00 00				.dword	$00000000 ; 0.0
>2783	00					.byte	$00
.2784					Const_Base:
.2784					Const_1Div2Pi:
>2784	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>2788	df					.byte	$df
.2789					Const_PiDiv2:
>2789	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>278d	e2					.byte	$e2
.278e					Const_Log2_e:
>278e	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>2792	e2					.byte	$e2
.2793					Const_sqrt_2:
>2793	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>2797	e2					.byte	$e2
.2798					Const_sqrt_half:
>2798	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>279c	e1					.byte	$e1
.279d					Const_pi:
>279d	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>27a1	e3					.byte	$e3
.27a2					Const_half:
>27a2	00 00 00 40				.dword	$40000000 ; 0.50000000
>27a6	e1					.byte	$e1
.27a7					Const_ln_e:
>27a7	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>27ab	e1					.byte	$e1
.27ac					FloatCosine:
.27ac	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.27ae	20 96 28	jsr $2896			jsr 	LoadConstant
.27b1	e8		inx				inx
.27b2	20 8a 20	jsr $208a			jsr 	FloatAdd
.27b5	4c 4c 29	jmp $294c			jmp 	FloatSine
.27b8					FloatExponent:
.27b8	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.27ba	20 96 28	jsr $2896			jsr 	LoadConstant
.27bd	e8		inx				inx
.27be	20 26 23	jsr $2326			jsr 	FloatMultiply
.27c1	20 03 28	jsr $2803			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.27c4	e8		inx				inx
.27c5	20 a1 22	jsr $22a1			jsr 	FloatIntegerPart
.27c8	ca		dex				dex
.27c9	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.27cb	15 57		ora $57,x			ora 	NSMantissa2+1,x
.27cd	15 63		ora $63,x			ora 	NSMantissa3+1,x
.27cf	d0 38		bne $2809			bne 	_UERangeError
.27d1	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.27d3	c9 40		cmp #$40			cmp 	#64
.27d5	b0 32		bcs $2809			bcs 	_UERangeError
.27d7	48		pha				pha
.27d8	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.27da	48		pha				pha
.27db	20 46 22	jsr $2246			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.27de	68		pla				pla
.27df	10 14		bpl $27f5			bpl 	_UEPositive
.27e1	e8		inx				inx 							; 1-x
.27e2	a9 01		lda #$01			lda 	#1
.27e4	20 68 26	jsr $2668			jsr 	FloatSetByte
.27e7	ca		dex				dex
.27e8	20 28 26	jsr $2628			jsr 	FloatNegate
.27eb	e8		inx				inx
.27ec	20 8a 20	jsr $208a			jsr 	FloatAdd
.27ef	68		pla				pla 							; integer part +1 and negated.
.27f0	1a		inc a				inc 	a
.27f1	49 ff		eor #$ff			eor 	#$FF
.27f3	1a		inc a				inc 	a
.27f4	48		pha				pha
.27f5					_UEPositive:
.27f5	20 0b 28	jsr $280b			jsr 	CoreExponent
.27f8	20 3f 28	jsr $283f			jsr 	CompletePolynomial
.27fb	68		pla				pla
.27fc	18		clc				clc
.27fd	75 6e		adc $6e,x			adc 	NSExponent,x
.27ff	95 6e		sta $6e,x			sta 	NSExponent,x
.2801	18		clc				clc
.2802	60		rts				rts
.2803					_UECopy01:
.2803	8a		txa				txa
.2804	a8		tay				tay
.2805	c8		iny				iny
.2806	4c 4a 28	jmp $284a			jmp 	CopyFloatXY
.2809					_UERangeError:
.2809	38		sec				sec
.280a	60		rts				rts
.280b					CoreExponent:
.280b	a9 db		lda #$db			lda 	#ExpCoefficients & $FF
.280d	a0 26		ldy #$26			ldy 	#ExpCoefficients >> 8
.280f	20 13 28	jsr $2813			jsr 	CalculateHornerPolynomial
.2812	60		rts				rts
.2813					CalculateHornerPolynomial:
.2813	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.2815	84 2d		sty $2d				sty 	zTemp0+1
.2817	9c b8 05	stz $05b8			stz 	coefficientCount 			; zero the count.
.281a	8e b9 05	stx $05b9			stx 	xValueSlot 					; save xValue slot.
.281d	e8		inx				inx 								; set the count to zero.
.281e	20 66 26	jsr $2666			jsr 	FloatSetZero
.2821					_CHPLoop:
.2821	8a		txa				txa 								; copy X-1 to X+1
.2822	a8		tay				tay
.2823	ca		dex				dex
.2824	c8		iny				iny
.2825	20 4a 28	jsr $284a			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.2828	e8		inx				inx
.2829	e8		inx				inx
.282a	20 26 23	jsr $2326			jsr 	FloatMultiply 				; times current by X
.282d	e8		inx				inx
.282e	20 69 28	jsr $2869			jsr 	GetCoefficient 				; coefficient into X+1
.2831	20 8a 20	jsr $208a			jsr 	FloatAdd 					; and add
.2834	ee b8 05	inc $05b8			inc 	coefficientCount
.2837	ad b8 05	lda $05b8			lda 	coefficientCount
.283a	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.283c	d0 e3		bne $2821			bne 	_CHPLoop
.283e	60		rts				rts
.283f					CompletePolynomial:
.283f	20 26 23	jsr $2326			jsr 	FloatMultiply
.2842	e8		inx				inx 								; get the last value
.2843	20 69 28	jsr $2869			jsr 	GetCoefficient
.2846	20 8a 20	jsr $208a			jsr 	FloatAdd 					; and add it
.2849	60		rts				rts
.284a					CopyFloatXY:
.284a	b5 6e		lda $6e,x			lda 	NSExponent,x
.284c	99 6e 00	sta $006e,y			sta 	NSExponent,y
.284f	b5 32		lda $32,x			lda 	NSStatus,x
.2851	99 32 00	sta $0032,y			sta 	NSStatus,y
.2854	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2856	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.2859	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.285b	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.285e	b5 56		lda $56,x			lda 	NSMantissa2,x
.2860	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.2863	b5 62		lda $62,x			lda 	NSMantissa3,x
.2865	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.2868	60		rts				rts
.2869					GetCoefficient:
.2869	5a		phy				phy
.286a	ad b8 05	lda $05b8			lda 	coefficientCount 			; 5 per block
.286d	0a		asl a				asl 	a
.286e	0a		asl a				asl 	a
.286f	38		sec				sec 								; +1 for count
.2870	6d b8 05	adc $05b8			adc 	coefficientCount
.2873	a8		tay				tay
.2874	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.2876	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2878	c8		iny				iny
.2879	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.287b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.287d	c8		iny				iny
.287e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2880	95 56		sta $56,x			sta 	NSMantissa2,x
.2882	c8		iny				iny
.2883	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2885	48		pha				pha
.2886	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.2888	95 62		sta $62,x			sta 	NSMantissa3,x
.288a	c8		iny				iny
.288b	68		pla				pla
.288c	29 80		and #$80			and 	#$80
.288e	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.2890	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2892	95 6e		sta $6e,x			sta 	NSExponent,x
.2894	7a		ply				ply
.2895	60		rts				rts
.05b8					coefficientCount:
>05b8							.fill 	1
.05b9					xValueSlot:
>05b9							.fill 	1
.2896					LoadConstant:
.2896	5a		phy				phy
.2897	a8		tay				tay
.2898	b9 84 27	lda $2784,y			lda 	Const_Base+0,y
.289b	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.289d	b9 85 27	lda $2785,y			lda 	Const_Base+1,y
.28a0	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.28a2	b9 86 27	lda $2786,y			lda 	Const_Base+2,y
.28a5	95 57		sta $57,x			sta 	NSMantissa2+1,x
.28a7	b9 87 27	lda $2787,y			lda 	Const_Base+3,y
.28aa	48		pha				pha
.28ab	29 7f		and #$7f			and 	#$7F
.28ad	95 63		sta $63,x			sta 	NSMantissa3+1,x
.28af	68		pla				pla
.28b0	29 80		and #$80			and 	#$80
.28b2	95 33		sta $33,x			sta 	NSStatus+1,x
.28b4	b9 88 27	lda $2788,y			lda 	Const_Base+4,y
.28b7	95 6f		sta $6f,x			sta 	NSExponent+1,x
.28b9	7a		ply				ply
.28ba	60		rts				rts
.28bb					FloatLogarithm:
.28bb	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.28bd	30 5f		bmi $291e			bmi 	_ULRange
.28bf	20 88 26	jsr $2688			jsr 	FloatIsZero
.28c2	f0 5a		beq $291e			beq 	_ULRange
.28c4	20 bb 23	jsr $23bb			jsr 	FloatNormalise 				; put into FP mode.
.28c7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.28c9	48		pha				pha
.28ca	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.28cc	95 6e		sta $6e,x			sta 	NSExponent,x
.28ce	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.28d0	20 96 28	jsr $2896			jsr 	LoadConstant
.28d3	e8		inx				inx
.28d4	20 8a 20	jsr $208a			jsr 	FloatAdd
.28d7	8a		txa				txa 								; divide into sqrt 2.0
.28d8	a8		tay				tay
.28d9	c8		iny				iny
.28da	20 4a 28	jsr $284a			jsr 	CopyFloatXY
.28dd	ca		dex				dex
.28de	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.28e0	20 96 28	jsr $2896			jsr 	LoadConstant
.28e3	e8		inx				inx
.28e4	e8		inx				inx
.28e5	20 af 21	jsr $21af			jsr 	FloatDivide 				; if zero, error.
.28e8	b0 33		bcs $291d			bcs 	_ULRangePla
.28ea	20 28 26	jsr $2628			jsr 	FloatNegate 				; subtract from 1
.28ed	e8		inx				inx
.28ee	a9 01		lda #$01			lda 	#1
.28f0	20 68 26	jsr $2668			jsr 	FloatSetByte
.28f3	20 8a 20	jsr $208a			jsr 	FloatAdd
.28f6	20 20 29	jsr $2920			jsr 	CoreLog
.28f9	20 3f 28	jsr $283f			jsr 	CompletePolynomial
.28fc	68		pla				pla 								; add exponent
.28fd	18		clc				clc
.28fe	69 1f		adc #$1f			adc 	#31 						; fix up
.2900	48		pha				pha
.2901	10 03		bpl $2906			bpl 	_LogNotNeg
.2903	49 ff		eor #$ff			eor 	#$FF
.2905	1a		inc a				inc 	a
.2906					_LogNotNeg:
.2906	e8		inx				inx 								; set byte and sign.
.2907	20 68 26	jsr $2668			jsr 	FloatSetByte
.290a	68		pla				pla
.290b	29 80		and #$80			and 	#$80
.290d	95 32		sta $32,x			sta 	NSStatus,x
.290f	20 8a 20	jsr $208a			jsr 	FloatAdd
.2912	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.2914	20 96 28	jsr $2896			jsr 	LoadConstant
.2917	e8		inx				inx
.2918	20 26 23	jsr $2326			jsr 	FloatMultiply
.291b	18		clc				clc
.291c	60		rts				rts
.291d					_ULRangePla:
.291d	68		pla				pla
.291e					_ULRange:
.291e	38		sec				sec
.291f	60		rts				rts
.2920					CoreLog:
.2920	a9 28		lda #$28			lda 	#LogCoefficients & $FF
.2922	a0 27		ldy #$27			ldy 	#LogCoefficients >> 8
.2924	4c 93 29	jmp $2993			jmp 	CorePolySquared
.2927					FloatPI:
.2927	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.2929	20 96 28	jsr $2896			jsr 	LoadConstant
.292c	e8		inx				inx
.292d	18		clc				clc
.292e	60		rts				rts
.292f					FloatPower:
.292f	ca		dex				dex
.2930	8a		txa				txa 							; copy 0 to 2, so we can process it
.2931	a8		tay				tay
.2932	c8		iny				iny
.2933	c8		iny				iny
.2934	20 4a 28	jsr $284a			jsr 	CopyFloatXY
.2937	e8		inx				inx 							; 2 = Log(0)
.2938	e8		inx				inx
.2939	20 bb 28	jsr $28bb			jsr 	FloatLogarithm
.293c	b0 0d		bcs $294b			bcs 	_FPWExit
.293e	20 26 23	jsr $2326			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.2941	8a		txa				txa 							; copy to slot 0
.2942	a8		tay				tay
.2943	88		dey				dey
.2944	20 4a 28	jsr $284a			jsr 	CopyFloatXY
.2947	ca		dex				dex  							; Exponent code.
.2948	20 b8 27	jsr $27b8			jsr 	FloatExponent
.294b					_FPWExit:
.294b	60		rts				rts
.294c					FloatSine:
.294c	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.294e	48		pha				pha
.294f	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.2951	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.2953	20 96 28	jsr $2896			jsr 	LoadConstant
.2956	e8		inx				inx
.2957	20 26 23	jsr $2326			jsr 	FloatMultiply
.295a	20 46 22	jsr $2246			jsr 	FloatFractionalPart 		; take the fractional part
.295d	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.295f	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.2961	90 1f		bcc $2982			bcc 	_USProcessExit
.2963	f0 06		beq $296b			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.2965	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.2967	c9 60		cmp #$60			cmp 	#$60
.2969	b0 0e		bcs $2979			bcs 	_USSubtractOne
.296b					_USSubtractFromHalf:
.296b	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.296d	20 96 28	jsr $2896			jsr 	LoadConstant
.2970	e8		inx				inx
.2971	20 84 20	jsr $2084			jsr 	FloatSubtract
.2974	20 28 26	jsr $2628			jsr 	FloatNegate 				; then negate it
.2977	80 09		bra $2982			bra 	_USProcessExit 				; and exit
.2979					_USSubtractOne:
.2979	e8		inx				inx
.297a	a9 01		lda #$01			lda 	#1
.297c	20 68 26	jsr $2668			jsr 	FloatSetByte
.297f	20 84 20	jsr $2084			jsr 	FloatSubtract
.2982					_USProcessExit:
.2982	20 8f 29	jsr $298f			jsr 	CoreSine
.2985	20 3f 28	jsr $283f			jsr 	CompletePolynomial
.2988	68		pla				pla 								; restore sign and apply
.2989	55 32		eor $32,x			eor 	NSStatus,x
.298b	95 32		sta $32,x			sta 	NSStatus,x
.298d	18		clc				clc
.298e	60		rts				rts
.298f					CoreSine:
.298f	a9 04		lda #$04			lda 	#SinCoefficients & $FF
.2991	a0 27		ldy #$27			ldy 	#SinCoefficients >> 8
.2993					CorePolySquared:
.2993	48		pha				pha 								; save coefficient table
.2994	5a		phy				phy
.2995	8a		txa				txa 								; copy X to +1, +2
.2996	a8		tay				tay
.2997	c8		iny				iny
.2998	20 4a 28	jsr $284a			jsr 	CopyFloatXY
.299b	c8		iny				iny
.299c	20 4a 28	jsr $284a			jsr 	CopyFloatXY
.299f	e8		inx				inx 								; point to the pair and put x^2 on stack
.29a0	e8		inx				inx
.29a1	20 26 23	jsr $2326			jsr 	FloatMultiply
.29a4	7a		ply				ply 								; coefficient table back.
.29a5	68		pla				pla
.29a6	20 13 28	jsr $2813			jsr 	CalculateHornerPolynomial
.29a9	8a		txa				txa 								; copy back to slot #1
.29aa	a8		tay				tay
.29ab	88		dey				dey
.29ac	20 4a 28	jsr $284a			jsr	 	CopyFloatXY
.29af	ca		dex				dex 								; point at result
.29b0	60		rts				rts
.29b1					FloatSquareRoot:
.29b1	20 bb 28	jsr $28bb			jsr 	FloatLogarithm
.29b4	b0 06		bcs $29bc			bcs 	_FSQExit
.29b6	d6 6e		dec $6e,x			dec 	NSExponent,x
.29b8	20 b8 27	jsr $27b8			jsr 	FloatExponent
.29bb	18		clc				clc
.29bc					_FSQExit:
.29bc	60		rts				rts
.29bd					FloatTangent:
.29bd	da		phx				phx
.29be	8a		txa				txa 								; sin -> +1
.29bf	a8		tay				tay
.29c0	c8		iny				iny
.29c1	20 4a 28	jsr $284a			jsr 	CopyFloatXY
.29c4	e8		inx				inx
.29c5	20 4c 29	jsr $294c			jsr 	FloatSine
.29c8	ca		dex				dex
.29c9	8a		txa				txa 								; cos -> +2
.29ca	a8		tay				tay
.29cb	c8		iny				iny
.29cc	c8		iny				iny
.29cd	20 4a 28	jsr $284a			jsr 	CopyFloatXY
.29d0	e8		inx				inx
.29d1	e8		inx				inx
.29d2	20 ac 27	jsr $27ac			jsr 	FloatCosine
.29d5	20 af 21	jsr $21af			jsr 	FloatDivide 				; calculate sin/cos
.29d8	b0 07		bcs $29e1			bcs 	_FTExit 					; divide by zero
.29da	8a		txa				txa 								; copy result down.
.29db	a8		tay				tay
.29dc	88		dey				dey
.29dd	20 4a 28	jsr $284a			jsr 	CopyFloatXY
.29e0	18		clc				clc
.29e1					_FTExit:
.29e1	fa		plx				plx
.29e2	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.007a					srcPtr:
>007a							.fill 	2
.05ba					currentLineNumber:
>05ba							.fill 	2
.29e3					InlineNonDecimal:
.29e3	a2 02		ldx #$02			ldx 	#2 							; get size in X
.29e5	c9 25		cmp #$25			cmp 	#"%"
.29e7	f0 02		beq $29eb			beq 	_INDBinary
.29e9	a2 10		ldx #$10			ldx 	#16
.29eb					_INDBinary:
.29eb	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.29ed	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.29ef	64 2c		stz $2c				stz 	zTemp0 						; zero result
.29f1	64 2d		stz $2d				stz 	zTemp0+1
.29f3					_INDLoop:
.29f3	20 8f 33	jsr $338f			jsr 	LookNext 					; check next character
.29f6	20 cb 33	jsr $33cb			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.29f9	90 1f		bcc $2a1a			bcc		_INDDone 					; didn't convert
.29fb	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.29fd	b0 1b		bcs $2a1a			bcs 	_INDDone
.29ff	20 29 2a	jsr $2a29			jsr 	_INDShift 					; x 2 or x 16
.2a02	e0 02		cpx #$02			cpx 	#2
.2a04	f0 09		beq $2a0f			beq 	_INDNotHex
.2a06	20 29 2a	jsr $2a29			jsr 	_INDShift
.2a09	20 29 2a	jsr $2a29			jsr 	_INDShift
.2a0c	20 29 2a	jsr $2a29			jsr 	_INDShift
.2a0f					_INDNotHex:
.2a0f	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.2a11	85 2c		sta $2c				sta 	zTemp0
.2a13	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume
.2a16	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.2a18	80 d9		bra $29f3			bra 	_INDLoop
.2a1a					_INDDone:
.2a1a	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.2a1c	f0 08		beq $2a26			beq 	_INDError
.2a1e	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.2a20	a5 2c		lda $2c				lda 	zTemp0
.2a22	20 4b 2b	jsr $2b4b			jsr 	PushIntegerYA
.2a25	60		rts				rts
.2a26					_INDError:
.2a26	4c 0f 1f	jmp $1f0f		jmp	ErrorV_syntax
.2a29					_INDShift:
.2a29	06 2c		asl $2c				asl 	zTemp0
.2a2b	26 2d		rol $2d				rol 	zTemp0+1
.2a2d	60		rts				rts
.2a2e					GetLineNumber:
.2a2e	ac bb 05	ldy $05bb			ldy 	currentLineNumber+1
.2a31	ad ba 05	lda $05ba			lda 	currentLineNumber
.2a34	60		rts				rts
.2a35					WriteCodeByte:
.2a35	48		pha				pha 								; save on stack
.2a36	da		phx				phx
.2a37	5a		phy				phy
.2a38	aa		tax				tax
.2a39	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.2a3b	20 48 2b	jsr $2b48			jsr 	CallAPIHandler
.2a3e	7a		ply				ply 								; restore from stack
.2a3f	fa		plx				plx
.2a40	68		pla				pla
.2a41	60		rts				rts
.2a42					PrintCharacter
.2a42	48		pha				pha
.2a43	da		phx				phx
.2a44	5a		phy				phy
.2a45	aa		tax				tax
.2a46	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.2a48	20 48 2b	jsr $2b48			jsr 	CallAPIHandler
.2a4b	7a		ply				ply
.2a4c	fa		plx				plx
.2a4d	68		pla				pla
.2a4e	60		rts				rts
.2a4f					ProcessNewLine:
.2a4f	86 2c		stx $2c				stx 	zTemp0 						; save address in zTemp0
.2a51	84 2d		sty $2d				sty 	zTemp0+1
.2a53	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.2a54	8a		txa				txa
.2a55	69 04		adc #$04			adc 	#4
.2a57	85 7a		sta $7a				sta 	srcPtr
.2a59	98		tya				tya
.2a5a	69 00		adc #$00			adc 	#0
.2a5c	85 7b		sta $7b				sta 	srcPtr+1
.2a5e	a0 02		ldy #$02			ldy 	#2							; read and save line number
.2a60	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a62	8d ba 05	sta $05ba			sta 	currentLineNumber
.2a65	c8		iny				iny
.2a66	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a68	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2a6b	60		rts				rts
.2a6c					BufferClear:
.2a6c	9c bc 05	stz $05bc			stz 	bufferSize
.2a6f	60		rts				rts
.2a70					BufferWrite:
.2a70	da		phx				phx
.2a71	ae bc 05	ldx $05bc			ldx 	bufferSize
.2a74	9d bd 05	sta $05bd,x			sta 	dataBuffer,x
.2a77	ee bc 05	inc $05bc			inc 	bufferSize
.2a7a	fa		plx				plx
.2a7b	60		rts				rts
.2a7c					BufferOutput:
.2a7c	ad bc 05	lda $05bc			lda 	bufferSize
.2a7f	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2a82	a2 00		ldx #$00			ldx 	#0
.2a84					_BOLoop:
.2a84	ec bc 05	cpx $05bc			cpx 	bufferSize
.2a87	f0 09		beq $2a92			beq 	_BOExit
.2a89	bd bd 05	lda $05bd,x			lda 	dataBuffer,x
.2a8c	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2a8f	e8		inx				inx
.2a90	80 f2		bra $2a84			bra 	_BOLoop
.2a92					_BOExit:
.2a92	60		rts				rts
.05bc					bufferSize:
>05bc							.fill 	1
.05bd					dataBuffer:
>05bd							.fill 	256
.2a93					CheckNextComma:
.2a93	a9 2c		lda #$2c			lda	 	#","
.2a95	80 06		bra $2a9d			bra 	CheckNextA
.2a97					CheckNextRParen:
.2a97	a9 29		lda #$29			lda	 	#")"
.2a99	80 02		bra $2a9d			bra 	CheckNextA
.2a9b					CheckNextLParen:
.2a9b	a9 28		lda #$28			lda 	#"("
.2a9d					CheckNextA:
.2a9d	8d bd 06	sta $06bd			sta 	checkCharacter 				; save test character
.2aa0					_CNALoop:
.2aa0	20 ab 33	jsr $33ab			jsr 	GetNextNonSpace 			; get next skipping spaces.
.2aa3	cd bd 06	cmp $06bd			cmp 	checkCharacter 				; matches ?
.2aa6	f0 03		beq $2aab			beq 	_CNAExit
.2aa8	4c 0f 1f	jmp $1f0f		jmp	ErrorV_syntax
.2aab					_CNAExit:
.2aab	60		rts				rts
.06bd					checkCharacter:
>06bd							.fill 	1
.2aac					StartCompiler:
.2aac	86 2c		stx $2c				stx 	zTemp0 						; access API
.2aae	84 2d		sty $2d				sty 	zTemp0+1
.2ab0	a0 2d		ldy #$2d			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.2ab2	a2 04		ldx #$04			ldx 	#CompilerErrorHandler & $FF
.2ab4	20 e8 1e	jsr $1ee8			jsr 	SetErrorHandler
.2ab7	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.2ab9	b2 2c		lda ($2c)			lda 	(zTemp0)
.2abb	8d bf 06	sta $06bf			sta 	APIVector
.2abe	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ac0	8d c0 06	sta $06c0			sta 	APIVector+1
.2ac3	c8		iny				iny 								; copy data area range.
.2ac4	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ac6	8d c1 06	sta $06c1			sta 	compilerStartHigh
.2ac9	c8		iny				iny
.2aca	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2acc	8d c2 06	sta $06c2			sta 	compilerEndHigh
.2acf	ba		tsx				tsx 								; save stack pointer
.2ad0	8e be 06	stx $06be			stx 	compilerSP
.2ad3	20 2f 37	jsr $372f			jsr 	STRReset 					; reset storage (line#, variable)
.2ad6	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.2ad8	20 48 2b	jsr $2b48			jsr 	CallAPIHandler
.2adb	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.2add	20 48 2b	jsr $2b48			jsr 	CallAPIHandler
.2ae0	a9 d4		lda #$d4			lda 	#PCD_CMD_VARSPACE
.2ae2	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2ae5	a9 00		lda #$00			lda 	#0
.2ae7	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2aea	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2aed					MainCompileLoop:
.2aed	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.2aef	20 48 2b	jsr $2b48			jsr 	CallAPIHandler
.2af2	90 31		bcc $2b25			bcc 	SaveCodeAndExit 			; end of source.
.2af4	20 4f 2a	jsr $2a4f			jsr 	ProcessNewLine 				; set up pointer and line number.
.2af7	20 2e 2a	jsr $2a2e			jsr 	GetLineNumber 				; get line #
.2afa	20 19 35	jsr $3519			jsr 	STRMarkLine 				; remember the code position and number of this line.
.2afd	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.2aff	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2b02					_MCLSameLine:
.2b02	20 ab 33	jsr $33ab			jsr 	GetNextNonSpace 			; get the first character.
.2b05	f0 e6		beq $2aed			beq 	MainCompileLoop 			; end of line, get next line.
.2b07	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.2b09	f0 f7		beq $2b02			beq 	_MCLSameLine
.2b0b	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.2b0d	10 0c		bpl $2b1b			bpl 	_MCLCheckAssignment
.2b0f	a2 69		ldx #$69			ldx 	#CommandTables & $FF 		; do command tables.
.2b11	a0 2f		ldy #$2f			ldy 	#CommandTables >> 8
.2b13	20 31 32	jsr $3231			jsr 	GeneratorProcess
.2b16	b0 ea		bcs $2b02			bcs 	_MCLSameLine 				; keep trying to compile the line.
.2b18					_MCLSyntax:
.2b18	4c 0f 1f	jmp $1f0f		jmp	ErrorV_syntax
.2b1b					_MCLCheckAssignment:
.2b1b	20 c1 33	jsr $33c1			jsr 	CharIsAlpha 				; if not alpha then syntax error
.2b1e	90 f8		bcc $2b18			bcc 	_MCLSyntax
.2b20	20 e7 34	jsr $34e7			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.2b23	80 dd		bra $2b02			bra		_MCLSameLine 				; loop back.
.2b25					SaveCodeAndExit:
.2b25	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.2b27	20 48 2b	jsr $2b48			jsr 	CallAPIHandler
.2b2a	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.2b2c	a8		tay				tay
.2b2d	20 19 35	jsr $3519			jsr 	STRMarkLine
.2b30	a9 c4		lda #$c4			lda 	#PCD_EXIT 					; add an END
.2b32	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2b35	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.2b37	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2b3a	20 61 2e	jsr $2e61			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.2b3d	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.2b3f	20 48 2b	jsr $2b48			jsr 	CallAPIHandler
.2b42	18		clc				clc 								; CC = success
.2b43					ExitCompiler:
.2b43	ae be 06	ldx $06be			ldx 	compilerSP 					; reload SP and exit.
.2b46	9a		txs				txs
.2b47	60		rts				rts
.2b48					CallAPIHandler:
.2b48	6c bf 06	jmp ($06bf)			jmp 	(APIVector)
.06be					compilerSP:
>06be							.fill 	1
.06bf					APIVector:
>06bf							.fill 	2
.06c1					compilerStartHigh:
>06c1							.fill 	1
.06c2					compilerEndHigh:
>06c2							.fill 	1
.2b4b					PushIntegerYA:
.2b4b	c0 00		cpy #$00			cpy 	#0 							; 0-255
.2b4d	f0 0f		beq $2b5e			beq 	PushIntegerA
.2b4f	48		pha				pha
.2b50	a9 cc		lda #$cc			lda 	#PCD_CMD_WORD 				; send .word
.2b52	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2b55	68		pla				pla 								; then LSB
.2b56	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2b59	98		tya				tya 								; then MSB
.2b5a	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2b5d	60		rts				rts
.2b5e					PushIntegerA:
.2b5e	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.2b60	90 07		bcc $2b69			bcc 	_PIWriteA
.2b62	48		pha				pha
.2b63	a9 cb		lda #$cb			lda 	#PCD_CMD_BYTE 				; send .byte
.2b65	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2b68	68		pla				pla
.2b69					_PIWriteA:
.2b69	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2b6c	60		rts				rts
.2b6d					PushFloatCommand:
.2b6d	a9 cd		lda #$cd			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.2b6f	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2b72	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.2b74	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2b77	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2b79	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2b7c	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2b7e	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2b81	b5 56		lda $56,x			lda 	NSMantissa2,x
.2b83	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2b86	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.2b88	29 80		and #$80			and 	#$80
.2b8a	15 62		ora $62,x			ora 	NSMantissa3,x
.2b8c	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2b8f	60		rts				rts
.2b90					CreateVariableRecord:
.2b90	48		pha				pha
.2b91	ad cd 06	lda $06cd			lda 	freeVariableMemory 		; push current free address on stack.
.2b94	48		pha				pha
.2b95	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2b98	48		pha				pha
.2b99	ad cb 06	lda $06cb			lda 	variableListEnd  		; copy end of list to zTemp0
.2b9c	85 2c		sta $2c				sta 	zTemp0
.2b9e	ad cc 06	lda $06cc			lda 	variableListEnd+1
.2ba1	85 2d		sta $2d				sta 	zTemp0+1
.2ba3	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.2ba5	92 2c		sta ($2c)			sta 	(zTemp0)
.2ba7	98		tya				tya
.2ba8	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.2baa	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bac	88		dey				dey
.2bad	8a		txa				txa
.2bae	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bb0	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.2bb2	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2bb5	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bb7	c8		iny				iny
.2bb8	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2bbb	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bbd	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.2bbf	a9 00		lda #$00			lda 	#0
.2bc1	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bc3	18		clc				clc
.2bc4	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.2bc6	6d cb 06	adc $06cb			adc  	variableListEnd
.2bc9	8d cb 06	sta $06cb			sta 	variableListEnd
.2bcc	90 03		bcc $2bd1			bcc 	_CVNoCarry2
.2bce	ee cc 06	inc $06cc			inc 	variableListEnd+1
.2bd1					_CVNoCarry2:
.2bd1	7a		ply				ply
.2bd2	fa		plx				plx
.2bd3	68		pla				pla
.2bd4	60		rts				rts
.2bd5					SetVariableRecordToCodePosition:
.2bd5	48		pha				pha
.2bd6	5a		phy				phy
.2bd7	a0 03		ldy #$03			ldy 	#3
.2bd9	a5 2b		lda $2b				lda 	objPtr+1
.2bdb	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bdd	c8		iny				iny
.2bde	a5 2a		lda $2a				lda 	objPtr
.2be0	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2be2	7a		ply				ply
.2be3	68		pla				pla
.2be4	60		rts				rts
.2be5					AllocateBytesForType:
.2be5	48		pha				pha
.2be6	da		phx				phx
.2be7	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.2be9	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2beb	c9 00		cmp #$00			cmp 	#NSSIFloat
.2bed	d0 02		bne $2bf1			bne 	_CVNotFloat
.2bef	a2 06		ldx #$06			ldx 	#6
.2bf1					_CVNotFloat:
.2bf1	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.2bf2	18		clc				clc
.2bf3	6d cd 06	adc $06cd			adc 	freeVariableMemory
.2bf6	8d cd 06	sta $06cd			sta 	freeVariableMemory
.2bf9	90 03		bcc $2bfe			bcc 	_CVNoCarry1
.2bfb	ee ce 06	inc $06ce			inc 	freeVariableMemory+1
.2bfe					_CVNoCarry1:
.2bfe	fa		plx				plx
.2bff	68		pla				pla
.2c00	60		rts				rts
.2c01					CommandDATA:
.2c01	20 6c 2a	jsr $2a6c			jsr 	BufferClear 				; copy it to the buffer
.2c04	20 92 33	jsr $3392			jsr 	LookNextNonSpace
.2c07					_CTDataLoop:
.2c07	20 8f 33	jsr $338f			jsr 	LookNext 					; reached EOL
.2c0a	f0 08		beq $2c14			beq 	_CTDataDone
.2c0c	20 70 2a	jsr $2a70			jsr 	BufferWrite 				; write and consume
.2c0f	20 a0 33	jsr $33a0			jsr 	GetNext
.2c12	80 f3		bra $2c07			bra 	_CTDataLoop
.2c14					_CTDataDone:
.2c14	a9 cf		lda #$cf			lda 	#PCD_CMD_DATA 				; output command and buffer
.2c16	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2c19	20 7c 2a	jsr $2a7c			jsr 	BufferOutput
.2c1c	60		rts				rts
.2c1d					CommandDEF:
.2c1d	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.2c1f	20 5e 2b	jsr $2b5e			jsr 	PushIntegerA
.2c22	20 b0 34	jsr $34b0			jsr 	CompileGotoEOL 				; compile skip over DEF
.2c25	a9 a5		lda #$a5			lda 	#C64_FN
.2c27	20 9d 2a	jsr $2a9d			jsr 	CheckNextA
.2c2a	20 ab 33	jsr $33ab			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2c2d	20 10 34	jsr $3410			jsr 	ExtractVariableName
.2c30	8a		txa				txa
.2c31	10 51		bpl $2c84			bpl 	_CDError
.2c33	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2c34	29 7f		and #$7f			and 	#$7F
.2c36	aa		tax				tax
.2c37	98		tya				tya
.2c38	09 80		ora #$80			ora 	#$80
.2c3a	a8		tay				tay
.2c3b	20 05 2e	jsr $2e05			jsr 	FindVariable				; does it already exist ?
.2c3e	b0 44		bcs $2c84			bcs 	_CDError 					; if so, that's an error.
.2c40	20 90 2b	jsr $2b90			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.2c43	20 d5 2b	jsr $2bd5			jsr 	SetVariableRecordToCodePosition
.2c46	20 ab 33	jsr $33ab			jsr 	GetNextNonSpace
.2c49	20 ec 36	jsr $36ec			jsr 	GetReferenceTerm 			; get var ref, not array
.2c4c	c9 00		cmp #$00			cmp 	#0
.2c4e	30 34		bmi $2c84			bmi 	_CDError
.2c50	8d c3 06	sta $06c3			sta 	defType 					; save type
.2c53	8e c4 06	stx $06c4			stx 	defVariable 				; save var ref
.2c56	8c c5 06	sty $06c5			sty 	defVariable+1
.2c59	29 40		and #$40			and 	#NSSString 					; only numbers.
.2c5b	d0 27		bne $2c84			bne 	_CDError
.2c5d	20 97 2a	jsr $2a97			jsr 	CheckNextRParen 			; check )
.2c60	a9 b2		lda #$b2			lda 	#C64_EQUAL
.2c62	20 9d 2a	jsr $2a9d			jsr 	CheckNextA 					; check =
.2c65	18		clc				clc 								; if this is DEF FNxx(A), read A
.2c66	20 87 2c	jsr $2c87			jsr 	CDReadWriteVariable
.2c69	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2c6b	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2c6e	38		sec				sec
.2c6f	20 87 2c	jsr $2c87			jsr 	CDReadWriteVariable 		; A is now updated
.2c72	20 4b 2d	jsr $2d4b			jsr 	CompileExpressionAt0 		; the actual body of the function.
.2c75	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.2c77	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2c7a	38		sec				sec
.2c7b	20 87 2c	jsr $2c87			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.2c7e	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.2c80	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2c83	60		rts				rts
.2c84					_CDError:
.2c84	4c 0f 1f	jmp $1f0f		jmp	ErrorV_syntax
.2c87					CDReadWriteVariable:
.2c87	ac c5 06	ldy $06c5			ldy 	defVariable+1 				; set up YX
.2c8a	ae c4 06	ldx $06c4			ldx 	defVariable
.2c8d	ad c3 06	lda $06c3			lda 	defType
.2c90	20 9e 36	jsr $369e			jsr 	GetSetVariable
.2c93	60		rts				rts
.06c3					defType:
>06c3							.fill 	1
.06c4					defVariable:
>06c4							.fill 	2
.2c94					CommandDIM:
.2c94	20 ab 33	jsr $33ab			jsr 	GetNextNonSpace 			; get the first non space character
.2c97	20 10 34	jsr $3410			jsr 	ExtractVariableName 		; variable name to XY
.2c9a	da		phx				phx 								; save name with type bits.
.2c9b	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.2c9d	10 37		bpl $2cd6			bpl 	_CDError
.2c9f	20 05 2e	jsr $2e05			jsr 	FindVariable	 			; see if already exist
.2ca2	b0 35		bcs $2cd9			bcs 	_CDRedefine 				; it still exists.
.2ca4	20 90 2b	jsr $2b90			jsr 	CreateVariableRecord 		; create the basic variable
.2ca7	20 e5 2b	jsr $2be5			jsr 	AllocateBytesForType 		; allocate memory for it
.2caa	68		pla				pla 								; restore type bits
.2cab	5a		phy				phy 								; save the address of the basic storage
.2cac	da		phx				phx
.2cad	48		pha				pha
.2cae	20 dc 2c	jsr $2cdc			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.2cb1	68		pla				pla
.2cb2	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.2cb4	20 5e 2b	jsr $2b5e			jsr 	PushIntegerA 				; push that type data out.
.2cb7	a9 ca		lda #$ca			lda 	#(PCD_DIM) >> 8
.2cb9	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2cbc	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.2cbe	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2cc1	fa		plx				plx 								; restore address
.2cc2	7a		ply				ply
.2cc3	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2cc5	38		sec				sec
.2cc6	20 9e 36	jsr $369e			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.2cc9	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; , follows ?
.2ccc	c9 2c		cmp #$2c			cmp 	#","
.2cce	d0 05		bne $2cd5			bne 	_CDExit
.2cd0	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume comma
.2cd3	80 bf		bra $2c94			bra 	CommandDIM 					; do another DIM
.2cd5					_CDExit:
.2cd5	60		rts				rts
.2cd6					_CDError:
.2cd6	4c 0f 1f	jmp $1f0f		jmp	ErrorV_syntax
.2cd9					_CDRedefine:
.2cd9	4c d7 1f	jmp $1fd7		jmp	ErrorV_redefine
.2cdc					OutputIndexGroup:
.2cdc	9c c6 06	stz $06c6			stz 	IndexCount 					; count of number of indices.
.2cdf					_OIGNext:
.2cdf	20 4b 2d	jsr $2d4b			jsr 	CompileExpressionAt0 		; get a dimension
.2ce2	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ce4	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ce6	d0 19		bne $2d01			bne 	_OIGType
.2ce8	ee c6 06	inc $06c6			inc 	IndexCount 					; bump the counter.
.2ceb	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; does a , follow ?
.2cee	c9 2c		cmp #$2c			cmp 	#","
.2cf0	d0 05		bne $2cf7			bne 	_OIGCheckEnd
.2cf2	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume comma
.2cf5	80 e8		bra $2cdf			bra 	_OIGNext 					; get next dimension
.2cf7					_OIGCheckEnd:
.2cf7	20 97 2a	jsr $2a97			jsr 	CheckNextRParen 			; check and consume )
.2cfa	ad c6 06	lda $06c6			lda 	IndexCount
.2cfd	20 5e 2b	jsr $2b5e			jsr 	PushIntegerA 				; compile the dimension count.
.2d00	60		rts				rts
.2d01					_OIGType:
.2d01	4c 1f 1f	jmp $1f1f		jmp	ErrorV_type
.06c6					IndexCount:
>06c6							.fill 	1
.2d04					CompilerErrorHandler:
.2d04	68		pla				pla
.2d05	7a		ply				ply
.2d06	85 2c		sta $2c				sta 	zTemp0
.2d08	84 2d		sty $2d				sty 	zTemp0+1
.2d0a	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.2d0c	a0 01		ldy #$01			ldy 	#1
.2d0e					_EHDisplayMsg:
.2d0e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d10	20 42 2a	jsr $2a42			jsr 	PrintCharacter
.2d13	c8		iny				iny
.2d14	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d16	d0 f6		bne $2d0e			bne 	_EHDisplayMsg
.2d18	a9 20		lda #$20			lda 	#32
.2d1a	20 42 2a	jsr $2a42			jsr 	PrintCharacter
.2d1d	a9 40		lda #$40			lda 	#64
.2d1f	20 42 2a	jsr $2a42			jsr 	PrintCharacter
.2d22	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.2d24	20 68 26	jsr $2668			jsr 	FloatSetByte
.2d27	20 2e 2a	jsr $2a2e			jsr 	GetLineNumber
.2d2a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2d2c	98		tya				tya
.2d2d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2d2f	20 4e 25	jsr $254e			jsr 	FloatToString
.2d32	a0 00		ldy #$00			ldy 	#0 							; display that string.
.2d34	a2 00		ldx #$00			ldx 	#0
.2d36					_EHDisplayLine:
.2d36	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d39	20 42 2a	jsr $2a42			jsr 	PrintCharacter
.2d3c	c8		iny				iny
.2d3d	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d40	d0 f4		bne $2d36			bne 	_EHDisplayLine
.2d42	a9 0d		lda #$0d			lda 	#13
.2d44	20 42 2a	jsr $2a42			jsr 	PrintCharacter
.2d47	38		sec				sec 								; CS = error
.2d48	4c 43 2b	jmp $2b43			jmp 	ExitCompiler
.2d4b					CompileExpressionAt0:
.2d4b	a9 00		lda #$00			lda 	#0
.2d4d					CompileExpressionAtA:
.2d4d	48		pha				pha  								; save level
.2d4e	20 57 37	jsr $3757			jsr 	CompileTerm 				; compile a term.
.2d51	fa		plx				plx 								; get level back into X
.2d52					_ECALoop:
.2d52	48		pha				pha 								; save type on stack.
.2d53	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; get the next character
.2d56	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.2d58	90 04		bcc $2d5e			bcc 	_ECAExit
.2d5a	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.2d5c	90 02		bcc $2d60			bcc 	_ECAHaveToken
.2d5e					_ECAExit:
.2d5e	68		pla				pla 								; throw type off stack
.2d5f	60		rts				rts
.2d60					_ECAHaveToken:
.2d60	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.2d62	aa		tax				tax 								; X contains the operator token
.2d63	bd 4e 2d	lda $2d4e,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.2d66	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.2d68	90 f4		bcc $2d5e			bcc 	_ECAExit
.2d6a	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.2d6c	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume the token.
.2d6f	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.2d71	f0 11		beq $2d84			beq 	_ECAGreaterCheck
.2d73	e0 b3		cpx #$b3			cpx 	#C64_LESS
.2d75	d0 1a		bne $2d91			bne 	_ECAHaveFullToken
.2d77	20 8f 33	jsr $338f			jsr 	LookNext 					; checks for < (<= or <>)
.2d7a	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.2d7c	f0 0e		beq $2d8c			beq	 	_ECAToNotEqual
.2d7e	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.2d80	d0 0f		bne $2d91			bne 	_ECAHaveFullToken
.2d82	80 07		bra $2d8b			bra 	_ECAAddEqual
.2d84					_ECAGreaterCheck:
.2d84	20 8f 33	jsr $338f			jsr 	LookNext
.2d87	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.2d89	d0 06		bne $2d91			bne 	_ECAHaveFullToken
.2d8b					_ECAAddEqual:
.2d8b	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.2d8c					_ECAToNotEqual:
.2d8c	e8		inx				inx
.2d8d	e8		inx				inx
.2d8e	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume the = or > in >= <= <>
.2d91					_ECAHaveFullToken:
.2d91	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.2d93	d0 0a		bne $2d9f			bne 	_ECANotConcat
.2d95	68		pla				pla 								; get type back
.2d96	48		pha				pha
.2d97	29 40		and #$40			and 	#NSSTypeMask
.2d99	c9 40		cmp #$40			cmp 	#NSSString
.2d9b	d0 02		bne $2d9f			bne 	_ECANotConcat
.2d9d	a2 df		ldx #$df			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2d9f					_ECANotConcat:
.2d9f	da		phx				phx 								; save operator on the stack
.2da0	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.2da2	da		phx				phx
.2da3	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.2da5	1a		inc a				inc 	a
.2da6	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.2da9	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.2dab	fa		plx				plx 								; restore current precedence in X
.2dac	68		pla				pla 								; restore operator
.2dad	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.2daf	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.2db1	90 17		bcc $2dca			bcc 	_ECANotCompare
.2db3	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.2db5	b0 13		bcs $2dca			bcs 	_ECANotCompare
.2db7	7a		ply				ply 								; get type into Y
.2db8	5a		phy				phy
.2db9	48		pha				pha 								; save operator
.2dba	98		tya				tya 								; get type
.2dbb	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.2dbd	29 40		and #$40			and 	#NSSTypeMask
.2dbf	c9 40		cmp #$40			cmp 	#NSSString
.2dc1	f0 02		beq $2dc5			beq 	_ECANotString
.2dc3	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.2dc5					_ECANotString:
.2dc5	98		tya				tya									; output token Y
.2dc6	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2dc9	68		pla				pla 								; restore operator.
.2dca					_ECANotCompare:
.2dca	18		clc				clc 								; convert to P-Code and compile.
.2dcb	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.2dcd	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2dd0	68		pla				pla 								; type of current result
.2dd1	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.2dd3	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.2dd5	d0 19		bne $2df0			bne		_ECAType
.2dd7	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.2dd9	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.2ddb	d0 18		bne $2df5			bne 	_ECAGoLoop
.2ddd	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.2ddf	c9 df		cmp #$df			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2de1	f0 10		beq $2df3			beq 	_ECAOkayString 				; (this is post conversion)
.2de3	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.2de5	90 09		bcc $2df0			bcc 	_ECAType
.2de7	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.2de9	b0 05		bcs $2df0			bcs 	_ECAType
.2deb	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.2ded	4c 52 2d	jmp $2d52			jmp 	_ECALoop
.2df0					_ECAType:
.2df0	4c 1f 1f	jmp $1f1f		jmp	ErrorV_type
.2df3					_ECAOkayString:
.2df3	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.2df5					_ECAGoLoop:
.2df5	4c 52 2d	jmp $2d52			jmp 	_ECALoop
.2df8					PrecedenceTable:
>2df8	03						.byte 	3 					; '+'
>2df9	03						.byte 	3 					; '-'
>2dfa	04						.byte 	4 					; '*'
>2dfb	04						.byte 	4 					; '/'
>2dfc	05						.byte 	5 					; '^'
>2dfd	01						.byte 	1 					; 'and'
>2dfe	00						.byte 	0 					; 'or'
>2dff	02						.byte 	2 					; '>'
>2e00	02						.byte 	2 					; '='
>2e01	02						.byte 	2 					; '<'
>2e02	02						.byte 	2 					; '>='
>2e03	02						.byte 	2 					; '<='
>2e04	02						.byte 	2 					; '<>'
.2e05					FindVariable:
.2e05	86 2e		stx $2e				stx 	zTemp1 						; save name.
.2e07	84 2f		sty $2f				sty 	zTemp1+1
.2e09					_IVCheckSpecial:
.2e09	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.2e0b	d0 18		bne $2e25			bne 	_IVStandard
.2e0d	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.2e0f	f0 0c		beq $2e1d			beq 	_IVTIFloat
.2e11	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.2e13	d0 10		bne $2e25			bne 	_IVStandard
.2e15	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.2e17	a2 01		ldx #$01			ldx 	#$01
.2e19	a9 40		lda #$40			lda 	#NSSString
.2e1b	38		sec				sec
.2e1c	60		rts				rts
.2e1d					_IVTIFloat:
.2e1d	a0 80		ldy #$80			ldy 	#$80
.2e1f	a2 00		ldx #$00			ldx 	#$00
.2e21	a9 00		lda #$00			lda 	#0
.2e23	38		sec				sec
.2e24	60		rts				rts
.2e25					_IVStandard:
.2e25	ad c1 06	lda $06c1			lda 	compilerStartHigh			; start scanning from here.
.2e28	85 2d		sta $2d				sta 	zTemp0+1
.2e2a	64 2c		stz $2c				stz 	zTemp0
.2e2c					_IVCheckLoop:
.2e2c	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.2e2e	f0 2b		beq $2e5b			beq  	_IVNotFound 				; if so, return with CC.
.2e30	a0 01		ldy #$01			ldy 	#1 							; match ?
.2e32	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e34	c5 2e		cmp $2e				cmp 	zTemp1
.2e36	d0 07		bne $2e3f			bne	 	_IVNext
.2e38	c8		iny				iny
.2e39	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e3b	c5 2f		cmp $2f				cmp 	zTemp1+1
.2e3d	f0 0d		beq $2e4c			beq 	_IVFound
.2e3f					_IVNext:
.2e3f	18		clc				clc
.2e40	a5 2c		lda $2c				lda 	zTemp0
.2e42	72 2c		adc ($2c)			adc 	(zTemp0)
.2e44	85 2c		sta $2c				sta 	zTemp0
.2e46	90 e4		bcc $2e2c			bcc 	_IVCheckLoop
.2e48	e6 2d		inc $2d				inc 	zTemp0+1
.2e4a	80 e0		bra $2e2c			bra 	_IVCheckLoop
.2e4c					_IVFound:
.2e4c	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.2e4e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e50	aa		tax				tax
.2e51	c8		iny				iny
.2e52	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e54	48		pha				pha
.2e55	c8		iny				iny
.2e56	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e58	7a		ply				ply
.2e59	38		sec				sec
.2e5a	60		rts				rts
.2e5b					_IVNotFound:
.2e5b	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.2e5d	a4 2f		ldy $2f				ldy 	zTemp1+1
.2e5f	18		clc				clc
.2e60	60		rts				rts
.2e61					FixBranches:
.2e61	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.2e63	20 48 2b	jsr $2b48			jsr 	CallAPIHandler
.2e66					_FBLoop:
.2e66	b2 2a		lda ($2a)			lda 	(objPtr) 					; get the next one.
.2e68	c9 d0		cmp #$d0			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.2e6a	f0 16		beq $2e82			beq 	_FBFixGotoGosub
.2e6c	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOSUB
.2e6e	f0 12		beq $2e82			beq 	_FBFixGotoGosub
.2e70	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.2e72	f0 0e		beq $2e82			beq 	_FBFixGotoGosub
.2e74	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.2e76	f0 0a		beq $2e82			beq 	_FBFixGotoGosub
.2e78	c9 d4		cmp #$d4			cmp 	#PCD_CMD_VARSPACE
.2e7a	f0 3b		beq $2eb7			beq 	_FBFixVarSpace
.2e7c					_FBNext:
.2e7c	20 35 20	jsr $2035			jsr 	MoveObjectForward 			; move forward in object code.
.2e7f	90 e5		bcc $2e66			bcc 	_FBLoop 					; not finished
.2e81					_FBExit:
.2e81	60		rts				rts
.2e82					_FBFixGotoGosub:
.2e82	a0 01		ldy #$01			ldy 	#1							; line number in YA
.2e84	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e86	48		pha				pha
.2e87	c8		iny				iny
.2e88	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e8a	a8		tay				tay
.2e8b	68		pla				pla
.2e8c	20 42 35	jsr $3542			jsr 	STRFindLine			 		; find where it is YA
.2e8f	90 08		bcc $2e99			bcc 	_FBFFound 					; not found, so must be >
.2e91	48		pha				pha
.2e92	b2 2a		lda ($2a)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.2e94	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOTOCMD_Z
.2e96	d0 0f		bne $2ea7			bne 	_FBFFail
.2e98	68		pla				pla
.2e99					_FBFFound:
.2e99	20 92 35	jsr $3592			jsr 	STRMakeOffset 				; make it an offset from X:YA
.2e9c	5a		phy				phy	 								; patch the GOTO/GOSUB
.2e9d	a0 01		ldy #$01			ldy 	#1
.2e9f	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ea1	c8		iny				iny
.2ea2	68		pla				pla
.2ea3	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ea5	80 d5		bra $2e7c			bra 	_FBNext
.2ea7					_FBFFail:
.2ea7	a0 02		ldy #$02			ldy 	#2
.2ea9	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2eab	8d ba 05	sta $05ba			sta 	currentLineNumber
.2eae	c8		iny				iny
.2eaf	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2eb1	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2eb4	4c 52 1f	jmp $1f52		jmp	ErrorV_line
.2eb7					_FBFixVarSpace:
.2eb7	a0 01		ldy #$01			ldy 	#1
.2eb9	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2ebc	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ebe	c8		iny				iny
.2ebf	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2ec2	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ec4	80 b6		bra $2e7c			bra 	_FBNext
.2ec6					CommandFOR:
.2ec6	20 ab 33	jsr $33ab			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.2ec9	20 c1 33	jsr $33c1			jsr 	CharIsAlpha 				; if not alpha , error
.2ecc	90 59		bcc $2f27			bcc 	_CFFail
.2ece	20 ec 36	jsr $36ec			jsr 	GetReferenceTerm 			; figure out the reference.
.2ed1	48		pha				pha 								; save type
.2ed2	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2ed4	c9 00		cmp #$00			cmp 	#NSSIFloat
.2ed6	d0 4f		bne $2f27			bne 	_CFFail
.2ed8	5a		phy				phy 								; save reference on the stack
.2ed9	da		phx				phx
.2eda	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.2edc	20 9d 2a	jsr $2a9d			jsr 	CheckNextA
.2edf	20 4b 2d	jsr $2d4b			jsr 	CompileExpressionAt0 		; initial value
.2ee2	fa		plx				plx 								; get reference back.
.2ee3	7a		ply				ply
.2ee4	5a		phy				phy
.2ee5	da		phx				phx
.2ee6	38		sec				sec 								; set initial value.
.2ee7	20 9e 36	jsr $369e			jsr 	GetSetVariable
.2eea	fa		plx				plx
.2eeb	7a		ply				ply
.2eec	68		pla				pla
.2eed	29 20		and #$20			and 	#NSSIInt16
.2eef	f0 04		beq $2ef5			beq 	_CFNotInt16
.2ef1	98		tya				tya
.2ef2	09 80		ora #$80			ora 	#$80
.2ef4	a8		tay				tay
.2ef5					_CFNotInt16:
.2ef5	8a		txa				txa 								; reference in YA
.2ef6	20 4b 2b	jsr $2b4b			jsr 	PushIntegerYA
.2ef9	a9 a4		lda #$a4			lda 	#C64_TO
.2efb	20 9d 2a	jsr $2a9d			jsr 	CheckNextA
.2efe	20 4b 2d	jsr $2d4b			jsr 	CompileExpressionAt0 		; terminal value
.2f01	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f03	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f05	d0 20		bne $2f27			bne 	_CFFail
.2f07	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; followed by STEP
.2f0a	c9 a9		cmp #$a9			cmp 	#C64_STEP
.2f0c	d0 0e		bne $2f1c			bne 	_CFNoStep
.2f0e	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume it.
.2f11	20 4b 2d	jsr $2d4b			jsr 	CompileExpressionAt0 		; terminal value
.2f14	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f16	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f18	d0 0d		bne $2f27			bne 	_CFFail
.2f1a	80 05		bra $2f21			bra 	_CFParametersDone
.2f1c					_CFNoStep:
.2f1c	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.2f1e	20 5e 2b	jsr $2b5e			jsr 	PushIntegerA
.2f21					_CFParametersDone:
.2f21	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2f23	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2f26	60		rts				rts
.2f27					_CFFail:
.2f27	4c 0f 1f	jmp $1f0f		jmp	ErrorV_syntax
.2f2a					FNCompile:
.2f2a	20 ab 33	jsr $33ab			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2f2d	20 10 34	jsr $3410			jsr 	ExtractVariableName
.2f30	e0 00		cpx #$00			cpx 	#0
.2f32	10 32		bpl $2f66			bpl 	_FNError
.2f34	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2f35	29 7f		and #$7f			and 	#$7F
.2f37	aa		tax				tax
.2f38	98		tya				tya
.2f39	09 80		ora #$80			ora 	#$80
.2f3b	a8		tay				tay
.2f3c	20 05 2e	jsr $2e05			jsr 	FindVariable				; does it already exist ?
.2f3f	90 25		bcc $2f66			bcc 	_FNError 					; no.
.2f41	20 92 35	jsr $3592			jsr 	STRMakeOffset 				; convert to a relative address.
.2f44	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2f46	d0 01		bne $2f49			bne 	_FNNoBorrow
.2f48	88		dey				dey
.2f49					_FNNoBorrow:
.2f49	3a		dec a				dec 	a
.2f4a	5a		phy				phy 								; save location of routine on stack.
.2f4b	48		pha				pha
.2f4c	da		phx				phx
.2f4d	20 4b 2d	jsr $2d4b			jsr 	CompileExpressionAt0
.2f50	20 97 2a	jsr $2a97			jsr 	CheckNextRParen
.2f53	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.2f55	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2f58	68		pla				pla
.2f59	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2f5c	68		pla				pla
.2f5d	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2f60	68		pla				pla
.2f61	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.2f64	18		clc				clc
.2f65	60		rts				rts
.2f66					_FNError:
.2f66	4c 02 1f	jmp $1f02		jmp	ErrorV_value
.2f69					CommandTables:
>2f69	07 cb 00 03 6e 34 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2f70	07 89 00 03 75 34 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2f77	07 8d 00 03 68 34 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>2f7e	07 88 00 03 e4 34 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2f85	07 85 00 03 c4 34 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>2f8c	07 84 00 04 d8 34 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>2f93	07 99 00 03 19 36 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2f9a	07 98 00 04 19 36 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2fa1	07 8f 00 03 24 37 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>2fa8	07 81 00 03 c6 2e 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>2faf	07 82 00 03 9c 35 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>2fb6	07 a1 00 03 e1 33 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>2fbd	07 83 00 03 01 2c 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>2fc4	07 87 00 03 62 36 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>2fcb	07 86 00 03 94 2c 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>2fd2	07 96 00 03 1d 2c 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>2fd9	07 8b 00 e3 91 34 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>2fe0	08 92 00 ea e3 f0 37 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>2fe8	09 91 00 e1 a9 03 c8 35			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>2ff0	06
>2ff1	07 9e 00 e2 ca 92 06			.byte	$07,$9e,$00,$e2,37578 & $FF,37578 >> 8,$06
>2ff8	07 97 00 ea e1 ac 06			.byte	$07,$97,$00,$ea,$e1,172,$06
>2fff	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>3005	07 90 00 20 ca 91 06			.byte	$07,$90,$00,$20,37322 & $FF,37322 >> 8,$06
>300c	07 80 00 20 ca 82 06			.byte	$07,$80,$00,$20,33482 & $FF,33482 >> 8,$06
>3013	07 8c 00 20 ca 90 06			.byte	$07,$8c,$00,$20,37066 & $FF,37066 >> 8,$06
>301a	07 9d 00 e3 16 38 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>3021	0a 9f 00 ea e3 29 38 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,198,$06
>3029	c6 06
>302b	06 a0 00 e1 c3 06			.byte	$06,$a0,$00,$e1,195,$06
>3031	07 ce 90 20 ca ac 06			.byte	$07,$ce,$90,$20,44234 & $FF,44234 >> 8,$06
>3038	0a ce 92 e3 5e 33 20 ca			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44490 & $FF,44490 >> 8,$06
>3040	ad 06
>3042	0a ce 8d e3 5e 33 20 ca			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44746 & $FF,44746 >> 8,$06
>304a	ae 06
>304c	06 ce 86 e1 c7 06			.byte	$06,$ce,$86,$e1,199,$06
>3052	08 ce 84 ea ea e1 c8 06			.byte	$08,$ce,$84,$ea,$ea,$e1,200,$06
>305a	07 ce af e2 ca 98 06			.byte	$07,$ce,$af,$e2,39114 & $FF,39114 >> 8,$06
>3061	07 ce 8c e2 ca 8c 06			.byte	$07,$ce,$8c,$e2,36042 & $FF,36042 >> 8,$06
>3068	09 ce ae ea ea e2 ca 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38346 & $FF,38346 >> 8,$06
>3070	06
>3071	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>3079	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>3081	9a 06
>3083	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>308b	9b 06
>308d	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>3095	9c 06
>3097	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>309f	06
>30a0	07 ce 99 20 ca 99 06			.byte	$07,$ce,$99,$20,39370 & $FF,39370 >> 8,$06
>30a7	08 ce 9a ea e2 ca 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39626 & $FF,39626 >> 8,$06
>30af	08 ce 9b ea e2 ca 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39882 & $FF,39882 >> 8,$06
>30b7	08 ce 9c ea e2 ca 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40138 & $FF,40138 >> 8,$06
>30bf	08 ce 9d ea e2 ca 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40394 & $FF,40394 >> 8,$06
>30c7	08 ce 9e ea e2 ca 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40650 & $FF,40650 >> 8,$06
>30cf	08 ce 9f ea e2 ca 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40906 & $FF,40906 >> 8,$06
>30d7	08 ce a0 ea e2 ca a0 06			.byte	$08,$ce,$a0,$ea,$e2,41162 & $FF,41162 >> 8,$06
>30df	08 ce a1 ea f2 ca a1 06			.byte	$08,$ce,$a1,$ea,$f2,41418 & $FF,41418 >> 8,$06
>30e7	08 ce a2 ea f2 ca a2 06			.byte	$08,$ce,$a2,$ea,$f2,41674 & $FF,41674 >> 8,$06
>30ef	08 ce a3 ea e2 ca a3 06			.byte	$08,$ce,$a3,$ea,$e2,41930 & $FF,41930 >> 8,$06
>30f7	07 ce a4 20 ca a4 06			.byte	$07,$ce,$a4,$20,42186 & $FF,42186 >> 8,$06
>30fe	08 ce a5 ea e2 ca a5 06			.byte	$08,$ce,$a5,$ea,$e2,42442 & $FF,42442 >> 8,$06
>3106	08 ce a6 ea e2 ca a6 06			.byte	$08,$ce,$a6,$ea,$e2,42698 & $FF,42698 >> 8,$06
>310e	08 ce a7 ea e2 ca a7 06			.byte	$08,$ce,$a7,$ea,$e2,42954 & $FF,42954 >> 8,$06
>3116	08 ce a8 ea e2 ca a8 06			.byte	$08,$ce,$a8,$ea,$e2,43210 & $FF,43210 >> 8,$06
>311e	08 ce a9 ea e2 ca a9 06			.byte	$08,$ce,$a9,$ea,$e2,43466 & $FF,43466 >> 8,$06
>3126	08 ce aa ea f2 ca aa 06			.byte	$08,$ce,$aa,$ea,$f2,43722 & $FF,43722 >> 8,$06
>312e	08 ce ab ea f2 ca ab 06			.byte	$08,$ce,$ab,$ea,$f2,43978 & $FF,43978 >> 8,$06
>3136	00						.byte 	0
.3137					UnaryTables:
>3137	07 b4 00 8e 91 b6 06			.byte	$07,$b4,$00,$8e,$91,182,$06
>313e	08 b5 00 8e 92 ca 84 06			.byte	$08,$b5,$00,$8e,$92,33994 & $FF,33994 >> 8,$06
>3146	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>314d	07 b7 00 8e 91 c1 06			.byte	$07,$b7,$00,$8e,$91,193,$06
>3154	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>315b	07 b9 00 8e 91 ad 06			.byte	$07,$b9,$00,$8e,$91,173,$06
>3162	08 ba 00 8e 92 ca 85 06			.byte	$08,$ba,$00,$8e,$92,34250 & $FF,34250 >> 8,$06
>316a	07 bb 00 8e 91 b4 06			.byte	$07,$bb,$00,$8e,$91,180,$06
>3171	08 bc 00 8e 92 ca 86 06			.byte	$08,$bc,$00,$8e,$92,34506 & $FF,34506 >> 8,$06
>3179	08 bd 00 8e 92 ca 87 06			.byte	$08,$bd,$00,$8e,$92,34762 & $FF,34762 >> 8,$06
>3181	08 be 00 8e 92 ca 88 06			.byte	$08,$be,$00,$8e,$92,35018 & $FF,35018 >> 8,$06
>3189	08 bf 00 8e 92 ca 89 06			.byte	$08,$bf,$00,$8e,$92,35274 & $FF,35274 >> 8,$06
>3191	08 c0 00 8e 92 ca 8a 06			.byte	$08,$c0,$00,$8e,$92,35530 & $FF,35530 >> 8,$06
>3199	08 c1 00 8e 92 ca 8b 06			.byte	$08,$c1,$00,$8e,$92,35786 & $FF,35786 >> 8,$06
>31a1	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>31a8	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>31af	07 c4 00 8e 91 ba 07			.byte	$07,$c4,$00,$8e,$91,186,$07
>31b6	07 c5 00 8f 91 c2 06			.byte	$07,$c5,$00,$8f,$91,194,$06
>31bd	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>31c4	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>31cb	08 c8 00 8f ae 91 bb 07			.byte	$08,$c8,$00,$8f,$ae,$91,187,$07
>31d3	08 c9 00 8f ae 91 bc 07			.byte	$08,$c9,$00,$8f,$ae,$91,188,$07
>31db	0b ca 00 8f ae 03 5e 33			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,189,$07
>31e3	91 bd 07
>31e6	07 a8 00 03 7d 33 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>31ed	07 a5 00 03 2a 2f 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>31f4	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>31fb	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>3202	08 ce d0 8e ae 91 c9 06			.byte	$08,$ce,$d0,$8e,$ae,$91,201,$06
>320a	08 ce d4 8e 92 ca 83 06			.byte	$08,$ce,$d4,$8e,$92,33738 & $FF,33738 >> 8,$06
>3212	07 ce d3 20 ca 8d 06			.byte	$07,$ce,$d3,$20,36298 & $FF,36298 >> 8,$06
>3219	07 ce d1 20 ca 8e 06			.byte	$07,$ce,$d1,$20,36554 & $FF,36554 >> 8,$06
>3220	07 ce d2 20 ca 8f 06			.byte	$07,$ce,$d2,$20,36810 & $FF,36810 >> 8,$06
>3227	09 ce d7 8e ae 92 ca 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38602 & $FF,38602 >> 8,$06
>322f	06
>3230	00						.byte 	0
.3231					GeneratorProcess:
.3231	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.3233	84 2d		sty $2d				sty 	zTemp0+1
.3235	85 2e		sta $2e				sta 	zTemp1 						; first match token
.3237	64 2f		stz $2f				stz 	zTemp1+1
.3239	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.323b	d0 05		bne $3242			bne 	_GPNotShifted
.323d	20 a0 33	jsr $33a0			jsr 	GetNext 					; get the shifted token
.3240	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.3242					_GPNotShifted:
.3242					_GPSearch:
.3242	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.3244	18		clc				clc
.3245	f0 2f		beq $3276			beq 	_GPExit
.3247	a0 01		ldy #$01			ldy 	#1 							; tokens match
.3249	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.324b	c5 2e		cmp $2e				cmp 	zTemp1
.324d	d0 09		bne $3258			bne 	_GPNext
.324f	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.3251	f0 12		beq $3265			beq 	_GPFound
.3253	c8		iny				iny 								; check match.
.3254	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.3256	f0 0d		beq $3265			beq 	_GPFound
.3258					_GPNext:
.3258	18		clc				clc 								; follow to next
.3259	a5 2c		lda $2c				lda 	zTemp0
.325b	72 2c		adc ($2c)			adc 	(zTemp0)
.325d	85 2c		sta $2c				sta 	zTemp0
.325f	90 e1		bcc $3242			bcc 	_GPSearch
.3261	e6 2d		inc $2d				inc 	zTemp0+1
.3263	80 dd		bra $3242			bra 	_GPSearch
.3265					_GPFound:
.3265	18		clc				clc 								; skip to action bytes
.3266	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.3268	69 03		adc #$03			adc 	#3
.326a	85 2c		sta $2c				sta 	zTemp0
.326c	90 02		bcc $3270			bcc 	_GPNoCarry
.326e	e6 2d		inc $2d				inc 	zTemp0+1
.3270					_GPNoCarry:
.3270					_GPLoop:
.3270	20 77 32	jsr $3277			jsr 	GeneratorExecute 			; execute one command
.3273	90 fb		bcc $3270			bcc 	_GPLoop 					; go back if not completed.
.3275	38		sec				sec 								; return with CS.
.3276					_GPExit:
.3276	60		rts				rts
.3277					GeneratorExecute:
.3277	20 23 33	jsr $3323			jsr 	_GEFetchZTemp0 				; get next.
.327a	48		pha				pha 								; split into 2 nibbles
.327b	4a		lsr a				lsr 	a
.327c	4a		lsr a				lsr 	a
.327d	4a		lsr a				lsr		a
.327e	4a		lsr a				lsr 	a
.327f	20 89 32	jsr $3289			jsr 	_GEExecuteNibble 			; MSB first
.3282	68		pla				pla
.3283	b0 03		bcs $3288			bcs 	_GEHaveCompleted
.3285	20 89 32	jsr $3289			jsr 	_GEExecuteNibble 			; LSB second
.3288					_GEHaveCompleted:
.3288	60		rts				rts
.3289					_GEExecuteNibble:
.3289	29 0f		and #$0f			and 	#$0F
.328b	0a		asl a				asl 	a
.328c	aa		tax				tax
.328d	7c 90 32	jmp ($3290,x)			jmp 	(_GEExecuteVectors,x)
.3290					_GEExecuteVectors:
>3290	b0 32						.word 	_GEXNop 					; 0  (no operation)
>3292	b8 32						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>3294	b2 32						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>3296	06 33						.word 	_GEXExecute 				; 3  (run arbitrary code)
>3298	f9 32						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>329a	b0 32						.word 	_GEXNop 					; 5
>329c	c0 32						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>329e	c4 32						.word 	_GEXExitString 				; 7  exit return string type
>32a0	c8 32						.word 	_GEXLParam 					; 8  check ( follows
>32a2	cc 32						.word 	_GEXRParam 					; 9  check ) follows
>32a4	d0 32						.word 	_GEXComma					; A  check , follows
>32a6	b0 32						.word 	_GEXNop 					; B
>32a8	b0 32						.word 	_GEXNop 					; C
>32aa	b0 32						.word 	_GEXNop 					; D
>32ac	e0 32						.word 	_GEXNumber 					; E  compile get any number
>32ae	eb 32						.word 	_GEXString 					; F  compile get any string
.32b0					_GEXNop:
.32b0	18		clc				clc
.32b1	60		rts				rts
.32b2					_GEXToken2:
.32b2	20 23 33	jsr $3323			jsr 	_GEFetchZTemp0
.32b5	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.32b8					_GEXToken1:
.32b8	20 23 33	jsr $3323			jsr 	_GEFetchZTemp0
.32bb	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.32be	18		clc				clc
.32bf	60		rts				rts
.32c0					_GEXExitNumber:
.32c0	a9 00		lda #$00			lda 	#NSSIFloat
.32c2	38		sec				sec
.32c3	60		rts				rts
.32c4					_GEXExitString:
.32c4	a9 40		lda #$40			lda 	#NSSString
.32c6	38		sec				sec
.32c7	60		rts				rts
.32c8					_GEXLParam:
.32c8	a9 28		lda #$28			lda 	#"("
.32ca	80 06		bra $32d2			bra 	_GEXCheck
.32cc					_GEXRParam:
.32cc	a9 29		lda #$29			lda 	#")"
.32ce	80 02		bra $32d2			bra 	_GEXCheck
.32d0					_GEXComma:
.32d0	a9 2c		lda #$2c			lda 	#","
.32d2					_GEXCheck:
.32d2	85 30		sta $30				sta 	zTemp2 						; save match
.32d4	20 ab 33	jsr $33ab			jsr 	GetNextNonSpace 			; get next skipping spaces
.32d7	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.32d9	d0 02		bne $32dd			bne 	_GEXSyntax
.32db	18		clc				clc
.32dc	60		rts				rts
.32dd					_GEXSyntax:
.32dd	4c 0f 1f	jmp $1f0f		jmp	ErrorV_syntax
.32e0					_GEXNumber:
.32e0	20 2c 33	jsr $332c			jsr 	GEXCompileExpression 		; compile expression
.32e3	29 40		and #$40			and 	#NSSTypeMask
.32e5	c9 00		cmp #$00			cmp  	#NSSIFloat
.32e7	d0 0d		bne $32f6			bne 	_GEXType
.32e9	18		clc				clc
.32ea	60		rts				rts
.32eb					_GEXString:
.32eb	20 2c 33	jsr $332c			jsr 	GEXCompileExpression 		; compile expression
.32ee	29 40		and #$40			and 	#NSSTypeMask
.32f0	c9 40		cmp #$40			cmp  	#NSSString
.32f2	d0 02		bne $32f6			bne 	_GEXType
.32f4	18		clc				clc
.32f5	60		rts				rts
.32f6					_GEXType:
.32f6	4c 1f 1f	jmp $1f1f		jmp	ErrorV_type
.32f9					_GEXChannelExec:
.32f9	20 3c 33	jsr $333c			jsr 	ChannelPrefix 				; set up default
.32fc	20 06 33	jsr $3306			jsr 	_GEXExecute
.32ff	08		php				php
.3300	20 57 33	jsr $3357			jsr 	ChannelPostfix 				; replace default.
.3303	28		plp				plp
.3304	60		rts				rts
>3305	db						.byte 	$DB 						; causes a break in the emulator
.3306					_GEXExecute:
.3306	20 23 33	jsr $3323			jsr 	_GEFetchZTemp0 				; get vector
.3309	85 30		sta $30				sta 	zTemp2
.330b	20 23 33	jsr $3323			jsr 	_GEFetchZTemp0
.330e	85 31		sta $31				sta 	zTemp2+1
.3310	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.3312	da		phx				phx
.3313	a6 2d		ldx $2d				ldx 	zTemp0+1
.3315	da		phx				phx
.3316	20 20 33	jsr $3320			jsr 	_GECallZTemp2 				; execute code
.3319	fa		plx				plx 								; recover generation exec
.331a	86 2d		stx $2d				stx 	zTemp0+1
.331c	fa		plx				plx
.331d	86 2c		stx $2c				stx 	zTemp0
.331f	60		rts				rts
.3320					_GECallZTemp2:
.3320	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.3323					_GEFetchZTemp0:
.3323	b2 2c		lda ($2c)			lda 	(zTemp0)
.3325	e6 2c		inc $2c				inc 	zTemp0
.3327	d0 02		bne $332b			bne 	_GEFZ0Skip
.3329	e6 2d		inc $2d				inc 	zTemp0+1
.332b					_GEFZ0Skip:
.332b	60		rts				rts
.332c					GEXCompileExpression:
.332c	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.332e	da		phx				phx
.332f	a6 2d		ldx $2d				ldx 	zTemp0+1
.3331	da		phx				phx
.3332	20 4b 2d	jsr $2d4b			jsr 	CompileExpressionAt0 		; compile expression.
.3335	fa		plx				plx 								; recover generation exec
.3336	86 2d		stx $2d				stx 	zTemp0+1
.3338	fa		plx				plx
.3339	86 2c		stx $2c				stx 	zTemp0
.333b	60		rts				rts
.333c					ChannelPrefix:
.333c	a9 ae		lda #$ae			lda 	#PCD_GETCHANNEL				; set channel onto stack
.333e	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.3341	20 2c 33	jsr $332c			jsr 	GEXCompileExpression 		; channel #
.3344	29 40		and #$40			and 	#NSSTypeMask
.3346	c9 00		cmp #$00			cmp 	#NSSIFloat
.3348	d0 0a		bne $3354			bne 	_CPXType
.334a	20 93 2a	jsr $2a93			jsr 	CheckNextComma 				; check , follows.
.334d	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel
.334f	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.3352	18		clc				clc
.3353	60		rts				rts
.3354					_CPXType:
.3354	4c 1f 1f	jmp $1f1f		jmp	ErrorV_type
.3357					ChannelPostfix:
.3357	a9 af		lda #$af			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.3359	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.335c	18		clc				clc
.335d	60		rts				rts
.335e					OptionalParameterCompile:
.335e	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; what follows.
.3361	c9 2c		cmp #$2c			cmp 	#","
.3363	d0 0e		bne $3373			bne 	_MidDefault
.3365	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume ,
.3368	20 4b 2d	jsr $2d4b			jsr 	CompileExpressionAt0
.336b	29 40		and #$40			and 	#NSSTypeMask
.336d	c9 00		cmp #$00			cmp 	#NSSIFloat
.336f	d0 09		bne $337a			bne 	MidFailType
.3371	80 05		bra $3378			bra 	_MidComplete
.3373					_MidDefault:
.3373	a9 ff		lda #$ff			lda 	#255 						; default of 255
.3375	20 5e 2b	jsr $2b5e			jsr 	PushIntegerA
.3378					_MidComplete:
.3378	18		clc				clc
.3379	60		rts				rts
.337a					MidFailType:
.337a	4c 1f 1f	jmp $1f1f		jmp	ErrorV_type
.337d					NotUnaryCompile:
.337d	ad 00 2e	lda $2e00			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.3380	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAtA 		; evaluate at that level
.3383	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.3385	c9 00		cmp #$00			cmp 	#NSSIFloat
.3387	d0 f1		bne $337a			bne 	MidFailType
.3389	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.338b	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.338e	60		rts				rts
.338f					LookNext:
.338f	b2 7a		lda ($7a)			lda 	(srcPtr)
.3391	60		rts				rts
.3392					LookNextNonSpace:
.3392	b2 7a		lda ($7a)			lda 	(srcPtr)
.3394	c9 20		cmp #$20			cmp		#' '
.3396	f0 03		beq $339b			beq 	_LNNSkip
.3398	c9 00		cmp #$00			cmp 	#0
.339a	60		rts				rts
.339b					_LNNSkip:
.339b	20 a0 33	jsr $33a0			jsr 	GetNext
.339e	80 f2		bra $3392			bra 	LookNextNonSpace
.33a0					GetNext:
.33a0	b2 7a		lda ($7a)			lda 	(srcPtr) 					; get next
.33a2	e6 7a		inc $7a				inc 	srcPtr
.33a4	d0 02		bne $33a8			bne 	_GNSkip
.33a6	e6 7b		inc $7b				inc 	srcPtr+1
.33a8					_GNSkip:
.33a8	c9 00		cmp #$00			cmp 	#0
.33aa	60		rts				rts
.33ab					GetNextNonSpace:
.33ab	20 a0 33	jsr $33a0			jsr 	GetNext
.33ae	c9 20		cmp #$20			cmp 	#' '
.33b0	f0 f9		beq $33ab			beq 	GetNextNonSpace
.33b2	c9 00		cmp #$00			cmp 	#0
.33b4	60		rts				rts
.33b5					CharIsDigit:
.33b5	c9 30		cmp #$30			cmp 	#"0"
.33b7	90 06		bcc $33bf			bcc 	CCFalse
.33b9	c9 3a		cmp #$3a			cmp 	#"9"+1
.33bb	b0 02		bcs $33bf			bcs 	CCFalse
.33bd					CCTrue:
.33bd	38		sec				sec
.33be	60		rts				rts
.33bf					CCFalse:
.33bf	18		clc				clc
.33c0	60		rts				rts
.33c1					CharIsAlpha:
.33c1	c9 41		cmp #$41			cmp 	#"A"
.33c3	90 fa		bcc $33bf			bcc 	CCFalse
.33c5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.33c7	b0 f6		bcs $33bf			bcs 	CCFalse
.33c9	80 f2		bra $33bd			bra 	CCTrue
.33cb					ConvertHexStyle:
.33cb	38		sec				sec
.33cc	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.33ce	90 ef		bcc $33bf			bcc 	CCFalse
.33d0	c9 0a		cmp #$0a			cmp 	#9+1
.33d2	90 e9		bcc $33bd			bcc 	CCTrue
.33d4	38		sec				sec 								; shift into hex space A=>0 Z=>25
.33d5	e9 11		sbc #$11			sbc 	#"A"-"0"
.33d7	90 e6		bcc $33bf			bcc 	CCFalse
.33d9	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.33db	b0 e2		bcs $33bf			bcs 	CCFalse
.33dd	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.33df	80 dc		bra $33bd			bra 	CCTrue
.33e1					CommandGET:
.33e1	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; # follows ?
.33e4	c9 23		cmp #$23			cmp 	#"#"
.33e6	d0 0d		bne $33f5			bne 	CommandGetBody
.33e8	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume #
.33eb	20 3c 33	jsr $333c			jsr 	ChannelPrefix 				; do it as GET#
.33ee	20 f5 33	jsr $33f5			jsr 	CommandGetBody
.33f1	20 57 33	jsr $3357			jsr 	ChannelPostfix
.33f4	60		rts				rts
.33f5					CommandGetBody:
.33f5	20 ab 33	jsr $33ab			jsr 	GetNextNonSpace 			; get the first character
.33f8	20 ec 36	jsr $36ec			jsr 	GetReferenceTerm 			; identify variable to assign to
.33fb	48		pha				pha
.33fc	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.33fe	c9 40		cmp #$40			cmp 	#NSSString
.3400	d0 0b		bne $340d			bne 	_CGType
.3402	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.3404	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.3407	38		sec				sec
.3408	68		pla				pla
.3409	20 9e 36	jsr $369e			jsr		GetSetVariable
.340c	60		rts				rts
.340d					_CGType:
.340d	4c 1f 1f	jmp $1f1f		jmp	ErrorV_type
.3410					ExtractVariableName:
.3410	20 c1 33	jsr $33c1			jsr 	CharIsAlpha
.3413	90 50		bcc $3465			bcc 	_IVSyntax
.3415	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.3417	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.3419	64 2f		stz $2f				stz 	zTemp1+1
.341b	20 8f 33	jsr $338f			jsr 	LookNext 					; is there a second character ?
.341e	20 c1 33	jsr $33c1			jsr 	CharIsAlpha  				; must be alphanumeric
.3421	b0 05		bcs $3428			bcs 	_IVHasSecond
.3423	20 b5 33	jsr $33b5			jsr 	CharIsDigit
.3426	90 07		bcc $342f			bcc 	_IVCheckType
.3428					_IVHasSecond:
.3428	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.342a	85 2f		sta $2f				sta 	zTemp1+1
.342c					_IVGetNextCheck:
.342c	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume it
.342f					_IVCheckType:
.342f	20 8f 33	jsr $338f			jsr 	LookNext					; check if string follows.
.3432	20 c1 33	jsr $33c1			jsr 	CharIsAlpha
.3435	b0 f5		bcs $342c			bcs 	_IVGetNextCheck
.3437	20 b5 33	jsr $33b5			jsr 	CharIsDigit
.343a	b0 f0		bcs $342c			bcs 	_IVGetNextCheck
.343c	a2 40		ldx #$40			ldx 	#NSSString
.343e	c9 24		cmp #$24			cmp 	#"$"
.3440	f0 06		beq $3448			beq 	_IVHasType
.3442	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.3444	c9 25		cmp #$25			cmp 	#"%"
.3446	d0 08		bne $3450			bne 	_IVCheckArray
.3448					_IVHasType:
.3448	8a		txa				txa 								; Or X into zTemp1
.3449	05 2e		ora $2e				ora 	zTemp1
.344b	85 2e		sta $2e				sta 	zTemp1
.344d	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume it
.3450					_IVCheckArray:
.3450	20 8f 33	jsr $338f			jsr 	LookNext 					; check if array follows
.3453	c9 28		cmp #$28			cmp 	#"("
.3455	d0 09		bne $3460			bne 	_IVNotArray
.3457	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.3459	09 80		ora #$80			ora 	#NSSArray
.345b	85 2e		sta $2e				sta 	zTemp1
.345d	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume it
.3460					_IVNotArray:
.3460	a6 2e		ldx $2e				ldx 	zTemp1
.3462	a4 2f		ldy $2f				ldy 	zTemp1+1
.3464	60		rts				rts
.3465					_IVSyntax:
.3465	4c 0f 1f	jmp $1f0f		jmp	ErrorV_syntax
.3468					CommandGOSUB:
.3468	a9 d1		lda #$d1			lda 	#PCD_CMD_GOSUB
.346a	20 7b 34	jsr $347b			jsr 	CompileBranchCommand
.346d	60		rts				rts
.346e					CommandGOAlt:
.346e	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.3470	20 9d 2a	jsr $2a9d			jsr 	CheckNextA
.3473	80 00		bra $3475			bra 	CommandGOTO
.3475					CommandGOTO:
.3475	a9 d0		lda #$d0			lda 	#PCD_CMD_GOTO
.3477	20 7b 34	jsr $347b			jsr 	CompileBranchCommand
.347a	60		rts				rts
.347b					CompileBranchCommand:
.347b	20 35 2a	jsr $2a35			jsr 	WriteCodeByte 				; write the command out.
.347e	20 ab 33	jsr $33ab			jsr 	GetNextNonSpace
.3481	20 f4 35	jsr $35f4			jsr 	ParseConstant 				; get constant into YA
.3484	90 08		bcc $348e			bcc 	_CBCSyntax
.3486	20 35 2a	jsr $2a35			jsr 	WriteCodeByte				; and compile the actual line number
.3489	98		tya				tya
.348a	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.348d	60		rts				rts
.348e					_CBCSyntax:
.348e	4c 0f 1f	jmp $1f0f		jmp	ErrorV_syntax
.3491					CommandIF:
.3491	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; what follows the tests ?
.3494	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.3496	f0 0f		beq $34a7			beq 	_CIGoto
.3498	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.349a	20 9d 2a	jsr $2a9d			jsr 	CheckNextA
.349d	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; THEN <number>
.34a0	20 b5 33	jsr $33b5			jsr 	CharIsDigit
.34a3	b0 05		bcs $34aa			bcs 	_CIGoto2
.34a5	80 09		bra $34b0			bra 	CompileGotoEOL
.34a7					_CIGoto:
.34a7	20 a0 33	jsr $33a0			jsr 	GetNext
.34aa					_CIGoto2:
.34aa	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_NZ
.34ac	20 7b 34	jsr $347b			jsr 	CompileBranchCommand
.34af	60		rts				rts
.34b0					CompileGotoEOL:
.34b0	a9 d2		lda #$d2			lda 	#PCD_CMD_GOTOCMD_Z
.34b2	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.34b5	20 2e 2a	jsr $2a2e			jsr 	GetLineNumber 				; Get the current line number => YA
.34b8	1a		inc a				inc 	a 							; and branch to +1
.34b9	d0 01		bne $34bc			bne 	_CGENoCarry
.34bb	c8		iny				iny
.34bc					_CGENoCarry:
.34bc	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.34bf	98		tya				tya
.34c0	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.34c3	60		rts				rts
.34c4					CommandINPUT:
.34c4	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; check for "
.34c7	c9 22		cmp #$22			cmp 	#'"'
.34c9	d0 0d		bne $34d8			bne 	CommandINPUTStream
.34cb	20 4b 2d	jsr $2d4b			jsr 	CompileExpressionAt0
.34ce	a9 b1		lda #$b1			lda 	#(PCD_PRINTCMD_S) & $FF
.34d0	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.34d3	a9 2c		lda #$2c			lda 	#","
.34d5	20 93 2a	jsr $2a93			jsr 	CheckNextComma
.34d8					CommandINPUTStream:
.34d8	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.34da	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.34dd	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.34df	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.34e1	4c 66 36	jmp $3666			jmp 	CommandReadInputCommon
.34e4					CommandLET:
.34e4	20 ab 33	jsr $33ab			jsr 	GetNextNonSpace 			; get the first character
.34e7					CommandLETHaveFirst:
.34e7	20 ec 36	jsr $36ec			jsr 	GetReferenceTerm 			; identify variable to assign to
.34ea	da		phx				phx 								; save target on the stack.
.34eb	5a		phy				phy
.34ec	48		pha				pha
.34ed	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.34ef	20 9d 2a	jsr $2a9d			jsr 	CheckNextA
.34f2	20 4b 2d	jsr $2d4b			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.34f5	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.34f7	68		pla				pla 								; get type of assignment
.34f8	48		pha				pha
.34f9	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.34fb	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.34fd	d0 17		bne $3516			bne 	_CLType
.34ff	68		pla				pla 								; restore and compile save code
.3500	7a		ply				ply
.3501	fa		plx				plx
.3502	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.3504	f0 05		beq $350b			beq 	_CLTIString
.3506	38		sec				sec
.3507	20 9e 36	jsr $369e			jsr		GetSetVariable
.350a	60		rts				rts
.350b					_CLTIString:
.350b	a9 ca		lda #$ca			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.350d	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.3510	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.3512	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.3515	60		rts				rts
.3516					_CLType:
.3516	4c 1f 1f	jmp $1f1f		jmp	ErrorV_type
.3519					STRMarkLine:
.3519	48		pha				pha
.351a	38		sec				sec 								; allocate 4 bytes (line #,address)
.351b	ad c9 06	lda $06c9			lda 	lineNumberTable 			; and copy to zTemp0
.351e	e9 04		sbc #$04			sbc 	#4
.3520	8d c9 06	sta $06c9			sta 	lineNumberTable
.3523	85 2c		sta $2c				sta 	zTemp0
.3525	ad ca 06	lda $06ca			lda 	lineNumberTable+1
.3528	e9 00		sbc #$00			sbc 	#0
.352a	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.352d	85 2d		sta $2d				sta 	zTemp0+1
.352f	68		pla				pla
.3530	92 2c		sta ($2c)			sta 	(zTemp0) 					; line # save it in +0,+1
.3532	98		tya				tya
.3533	a0 01		ldy #$01			ldy 	#1
.3535	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3537	a5 2a		lda $2a				lda 	objPtr 						; save current address in +2,+3
.3539	c8		iny				iny
.353a	91 2c		sta ($2c),y			sta 	(zTemp0),y
.353c	a5 2b		lda $2b				lda 	objPtr+1
.353e	c8		iny				iny
.353f	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3541	60		rts				rts
.3542					STRFindLine:
.3542	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.3544	84 2d		sty $2d				sty 	zTemp0+1
.3546	ad c2 06	lda $06c2			lda 	compilerEndHigh 			; work backwards through table
.3549	85 2f		sta $2f				sta 	zTemp1+1
.354b	64 2e		stz $2e				stz 	zTemp1
.354d					_STRSearch:
.354d	20 84 35	jsr $3584			jsr 	_STRPrevLine 				; look at previous record.
.3550	a0 01		ldy #$01			ldy 	#1
.3552	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.3554	c5 2c		cmp $2c				cmp 	zTemp0
.3556	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3558	e5 2d		sbc $2d				sbc 	zTemp0+1
.355a	b0 0b		bcs $3567			bcs 	_STRFound 					; >=
.355c					_STRNext:
.355c	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.355e	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3560	c9 ff		cmp #$ff			cmp 	#$FF
.3562	d0 e9		bne $354d			bne 	_STRSearch
.3564	4c 69 1f	jmp $1f69		jmp	ErrorV_internal
.3567					_STRFound:
.3567	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.3569	45 2c		eor $2c				eor 	zTemp0
.356b	d0 06		bne $3573			bne 	_STRDifferent
.356d	b2 2e		lda ($2e)			lda 	(zTemp1)
.356f	45 2c		eor $2c				eor 	zTemp0
.3571	f0 02		beq $3575			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.3573					_STRDifferent:
.3573	a9 ff		lda #$ff			lda 	#$FF
.3575					_STROut:
.3575	18		clc				clc  								; set carry if different, e.g. > rather than >=
.3576	69 ff		adc #$ff			adc 	#255
.3578	08		php				php
.3579	c8		iny				iny 								; address into YA
.357a	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.357c	48		pha				pha
.357d	c8		iny				iny
.357e	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3580	a8		tay				tay
.3581	68		pla				pla
.3582	28		plp				plp
.3583	60		rts				rts
.3584					_STRPrevLine:
.3584	38		sec				sec 								; move backwards one entry.
.3585	a5 2e		lda $2e				lda 	zTemp1
.3587	e9 04		sbc #$04			sbc 	#4
.3589	85 2e		sta $2e				sta 	zTemp1
.358b	a5 2f		lda $2f				lda 	zTemp1+1
.358d	e9 00		sbc #$00			sbc 	#0
.358f	85 2f		sta $2f				sta 	zTemp1+1
.3591	60		rts				rts
.3592					STRMakeOffset:
.3592	18		clc				clc 								; borrow 1
.3593	e5 2a		sbc $2a				sbc 	objPtr
.3595	48		pha				pha
.3596	98		tya				tya
.3597	e5 2b		sbc $2b				sbc 	objPtr+1
.3599	a8		tay				tay
.359a	68		pla				pla
.359b	60		rts				rts
.359c					CommandNEXT:
.359c	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.359f	20 c1 33	jsr $33c1			jsr 	CharIsAlpha 				; if not alpha , error
.35a2	90 0c		bcc $35b0			bcc 	_CNNoReferenceGiven
.35a4	20 a0 33	jsr $33a0			jsr 	GetNext
.35a7	20 ec 36	jsr $36ec			jsr 	GetReferenceTerm 			; figure out the reference.
.35aa	8a		txa				txa 								; reference in YA
.35ab	20 4b 2b	jsr $2b4b			jsr 	PushIntegerYA 				; write it out.
.35ae	80 06		bra $35b6			bra 	_CNParametersDone
.35b0					_CNNoReferenceGiven:
.35b0	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.35b2	a8		tay				tay
.35b3	20 4b 2b	jsr $2b4b			jsr 	PushIntegerYA 				; write it out.
.35b6					_CNParametersDone:
.35b6	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.35b8	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.35bb	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; look for ,
.35be	c9 2c		cmp #$2c			cmp 	#","
.35c0	d0 05		bne $35c7			bne 	_CNExit
.35c2	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume ,
.35c5	80 d5		bra $359c			bra 	CommandNEXT 				; and go round.
.35c7					_CNExit:
.35c7	60		rts				rts
.35c8					CommandON:
.35c8	20 ab 33	jsr $33ab			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.35cb	48		pha				pha 								; save on stack
.35cc	a2 d0		ldx #$d0			ldx 	#PCD_CMD_GOTO
.35ce	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.35d0	f0 09		beq $35db			beq 	_COCreateLoop
.35d2	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOSUB
.35d4	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.35d6	f0 03		beq $35db			beq 	_COCreateLoop
.35d8	4c 0f 1f	jmp $1f0f		jmp	ErrorV_syntax
.35db					_COCreateLoop:
.35db	8a		txa				txa 								; compile a goto/gosub somewhere
.35dc	da		phx				phx
.35dd	20 7b 34	jsr $347b			jsr 	CompileBranchCommand
.35e0	fa		plx				plx
.35e1	20 92 33	jsr $3392			jsr 	LookNextNonSpace			; ',' follows
.35e4	c9 2c		cmp #$2c			cmp 	#","
.35e6	d0 0a		bne $35f2			bne 	_COComplete 				; if so, more line numbers
.35e8	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.35ea	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.35ed	20 a0 33	jsr $33a0			jsr 	GetNext
.35f0	80 e9		bra $35db			bra 	_COCreateLoop
.35f2					_COComplete:
.35f2	68		pla				pla 								; throw GOTO/GOSUB
.35f3	60		rts				rts
.35f4					ParseConstant:
.35f4	a2 00		ldx #$00			ldx 	#0
.35f6	20 46 24	jsr $2446			jsr 	FloatEncodeStart 			; send first
.35f9					_ParseLoop:
.35f9	20 8f 33	jsr $338f			jsr 	LookNext 					; send subsequent
.35fc	20 49 24	jsr $2449			jsr 	FloatEncodeContinue
.35ff	90 05		bcc $3606			bcc 	_ParseDone
.3601	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume it
.3604	80 f3		bra $35f9			bra 	_ParseLoop
.3606					_ParseDone:
.3606	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.3608	29 80		and #$80			and 	#$80
.360a	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.360c	15 56		ora $56,x			ora 	NSMantissa2,x
.360e	15 62		ora $62,x			ora 	NSMantissa3,x
.3610	18		clc				clc
.3611	d0 05		bne $3618			bne 	_ParseExit 					; exit with CC if need float to compile
.3613	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.3615	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.3617	38		sec				sec
.3618					_ParseExit:
.3618	60		rts				rts
.3619					CommandPRINT:
.3619	20 92 33	jsr $3392			jsr 	LookNextNonSpace			; what follows ?
.361c	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.361e	f0 1f		beq $363f			beq 	_CPCheckEnd
.3620	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.3622	f0 16		beq $363a			beq 	_CPTabCheckEnd
.3624	20 56 36	jsr $3656			jsr 	_CPAtEnd 					; check for : and EOL
.3627	b0 22		bcs $364b			bcs 	_CPExitCR 					; exit with CR
.3629	20 4b 2d	jsr $2d4b			jsr 	CompileExpressionAt0 		; so it is something to print
.362c	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_S
.362e	29 40		and #$40			and 	#NSSString 					; if string
.3630	d0 02		bne $3634			bne 	_CPOut
.3632	a2 b0		ldx #$b0			ldx 	#PCD_PRINTCMD_N
.3634					_CPOut:
.3634	8a		txa				txa 								; print that thing
.3635	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.3638	80 df		bra $3619			bra 	CommandPRINT 				; and loop round/
.363a					_CPTabCheckEnd:
.363a	a9 b7		lda #$b7			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.363c	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.363f					_CPCheckEnd:
.363f	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume it.
.3642	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; what follows ?
.3645	20 56 36	jsr $3656			jsr 	_CPAtEnd 					; reached end
.3648	90 cf		bcc $3619			bcc 	CommandPRINT 				; no, loop back
.364a	60		rts				rts
.364b					_CPExitCR:
.364b	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.364d	20 5e 2b	jsr $2b5e			jsr 	PushIntegerA
.3650	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.3652	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.3655	60		rts				rts
.3656					_CPAtEnd:
.3656	c9 00		cmp #$00			cmp 	#0
.3658	f0 06		beq $3660			beq 	_CPIsEnd
.365a	c9 3a		cmp #$3a			cmp 	#":"
.365c	f0 02		beq $3660			beq 	_CPIsEnd
.365e	18		clc				clc
.365f	60		rts				rts
.3660					_CPIsEnd:
.3660	38		sec				sec
.3661	60		rts				rts
.3662					CommandREAD:
.3662	a2 b2		ldx #$b2			ldx 	#PCD_READ
.3664	a0 b3		ldy #$b3			ldy 	#PCD_READDOLLAR
.3666					CommandReadInputCommon:
.3666	8e c7 06	stx $06c7			stx 	numberPCode
.3669	8c c8 06	sty $06c8			sty 	stringPCode
.366c					_CRLoop:
.366c	20 ab 33	jsr $33ab			jsr 	GetNextNonSpace 			; first char of identifier
.366f	20 c1 33	jsr $33c1			jsr 	CharIsAlpha 				; check A-Z
.3672	90 27		bcc $369b			bcc 	_CRSyntax
.3674	20 ec 36	jsr $36ec			jsr 	GetReferenceTerm 			; get the variable.
.3677	48		pha				pha 								; save type.
.3678	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.367a	c9 40		cmp #$40			cmp 	#NSSString
.367c	f0 05		beq $3683			beq 	_CRString
.367e	ad c7 06	lda $06c7			lda 	numberPCode 				; output read/input
.3681	80 03		bra $3686			bra 	_CRHaveType
.3683					_CRString:
.3683	ad c8 06	lda $06c8			lda 	stringPCode					; output read$/input$
.3686					_CRHaveType:
.3686	20 35 2a	jsr $2a35			jsr 	WriteCodeByte 				; so we have one typed data item.
.3689	68		pla				pla 								; restore type
.368a	38		sec				sec  								; write update code.
.368b	20 9e 36	jsr $369e			jsr 	GetSetVariable
.368e	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; , follows ?
.3691	c9 2c		cmp #$2c			cmp 	#","
.3693	d0 05		bne $369a			bne 	_CRExit 					; if not, end of READ.
.3695	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume comma
.3698	80 d2		bra $366c			bra 	_CRLoop 					; keep going
.369a					_CRExit:
.369a	60		rts				rts
.369b					_CRSyntax:
.369b	4c 0f 1f	jmp $1f0f		jmp	ErrorV_syntax
.06c7					numberPCode:
>06c7							.fill 	1
.06c8					stringPCode:
>06c8							.fill 	1
.369e					GetSetVariable:
.369e	08		php				php 								; save direction on stack
.369f	c0 00		cpy #$00			cpy 	#$00
.36a1	30 21		bmi $36c4			bmi 	_GSVReadWriteSpecial
.36a3	c9 00		cmp #$00			cmp 	#$00
.36a5	30 33		bmi $36da			bmi 	_GSVArray
.36a7	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.36a9	4a		lsr a				lsr 	a 							; divide by 2
.36aa	09 40		ora #$40			ora 	#64 						; and set bit 6.
.36ac	28		plp				plp
.36ad	90 02		bcc $36b1			bcc 	_GSVNotWrite
.36af	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.36b1					_GSVNotWrite:
.36b1	85 2c		sta $2c				sta 	zTemp0
.36b3	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.36b4	4a		lsr a				lsr 	a
.36b5	a8		tay				tay
.36b6	8a		txa				txa
.36b7	6a		ror a				ror 	a
.36b8	aa		tax				tax
.36b9	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.36ba	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.36bc	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.36bf	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.36c0	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.36c3	60		rts				rts
.36c4					_GSVReadWriteSpecial:
.36c4	28		plp				plp
.36c5	b0 10		bcs $36d7			bcs 	_GSVSyntax
.36c7	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.36c9	f0 06		beq $36d1			beq 	_GSVRWString
.36cb	a9 bf		lda #$bf			lda 	#(PCD_TI) & $FF
.36cd	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.36d0	60		rts				rts
.36d1					_GSVRWString:
.36d1	a9 c0		lda #$c0			lda 	#(PCD_TIDOLLAR) & $FF
.36d3	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.36d6	60		rts				rts
.36d7					_GSVSyntax:
.36d7	4c 0f 1f	jmp $1f0f		jmp	ErrorV_syntax
.36da					_GSVArray:
.36da	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.36dc	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.36dd	4a		lsr a				lsr 	a
.36de	4a		lsr a				lsr 	a
.36df	4a		lsr a				lsr 	a
.36e0	4a		lsr a				lsr 	a
.36e1	28		plp				plp 								; if writing array then set bit 2.
.36e2	90 02		bcc $36e6			bcc 	_GSVANotWrite
.36e4	09 04		ora #$04			ora 	#4
.36e6					_GSVANotWrite:
.36e6	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.36e8	20 35 2a	jsr $2a35			jsr 	WriteCodeByte 				; and write it out
.36eb	60		rts				rts
.36ec					GetReferenceTerm:
.36ec	20 10 34	jsr $3410			jsr 	ExtractVariableName 		; get name & type info
.36ef	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.36f1	30 10		bmi $3703			bmi 	_GRTArray
.36f3	da		phx				phx 								; save type on stack
.36f4	20 05 2e	jsr $2e05			jsr 	FindVariable 				; find it
.36f7	b0 06		bcs $36ff			bcs 	_GRTNoCreate 				; create if required.
.36f9	20 90 2b	jsr $2b90			jsr 	CreateVariableRecord 		; create a variable.
.36fc	20 e5 2b	jsr $2be5			jsr 	AllocateBytesForType 		; allocate memory for it
.36ff					_GRTNoCreate:
.36ff	68		pla				pla 								; get type back, strip out type information.
.3700	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.3702	60		rts				rts
.3703					_GRTArray:
.3703	da		phx				phx 								; save type information
.3704	20 05 2e	jsr $2e05			jsr 	FindVariable 				; read its data, the base address in YX
.3707	90 18		bcc $3721			bcc 	_GRTUndeclared 				; undeclared array.
.3709	da		phx				phx 								; save base address
.370a	5a		phy				phy
.370b	20 dc 2c	jsr $2cdc			jsr 	OutputIndexGroup 			; create an index group and generate them
.370e	7a		ply				ply 								; get the array base address into YX
.370f	fa		plx				plx
.3710	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.3712	18		clc				clc
.3713	20 9e 36	jsr $369e			jsr 	GetSetVariable 				; load the address of the array structure.
.3716	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.3718	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.371b	68		pla				pla 								; and the type data into A
.371c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.371e	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.3720	60		rts				rts
.3721					_GRTUndeclared:
.3721	4c c6 1f	jmp $1fc6		jmp	ErrorV_undeclared
.3724					CommandREM:
.3724	20 8f 33	jsr $338f			jsr 	LookNext
.3727	f0 05		beq $372e			beq 	_CRExit
.3729	20 a0 33	jsr $33a0			jsr 	GetNext
.372c	80 f6		bra $3724			bra 	CommandREM
.372e					_CRExit:
.372e	60		rts				rts
.372f					STRReset:
.372f	ad c1 06	lda $06c1			lda	 	compilerStartHigh 			; set up the two table pointers
.3732	8d cc 06	sta $06cc			sta 	variableListEnd+1
.3735	9c cb 06	stz $06cb			stz 	variableListEnd
.3738	ad c2 06	lda $06c2			lda 	compilerEndHigh
.373b	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.373e	9c c9 06	stz $06c9			stz 	lineNumberTable
.3741	ad cb 06	lda $06cb			lda 	variableListEnd
.3744	85 2d		sta $2d				sta 	zTemp0+1
.3746	64 2c		stz $2c				stz 	zTemp0
.3748	a9 00		lda #$00			lda 	#0
.374a	92 2c		sta ($2c)			sta 	(zTemp0)
.374c	a9 00		lda #$00			lda 	#((0) & $FF)
.374e	8d cd 06	sta $06cd			sta 	0+freeVariableMemory
.3751	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.3753	8d ce 06	sta $06ce			sta 	1+freeVariableMemory
.3756	60		rts				rts
.06c9					lineNumberTable:
>06c9							.fill 	2
.06cb					variableListEnd:
>06cb							.fill 	2
.06cd					freeVariableMemory:
>06cd							.fill 	2
.3757					CompileTerm:
.3757	20 ab 33	jsr $33ab			jsr 	GetNextNonSpace 			; get first non space character.
.375a	30 72		bmi $37ce			bmi 	_CTUnaryFunctions
.375c	20 b5 33	jsr $33b5			jsr 	CharIsDigit 				; found a number
.375f	b0 3a		bcs $379b			bcs 	_CTDigit
.3761	c9 2e		cmp #$2e			cmp 	#"."
.3763	f0 36		beq $379b			beq 	_CTDigit
.3765	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.3767	f0 43		beq $37ac			beq 	_CTString
.3769	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.376b	f0 28		beq $3795			beq 	_CTOtherBase
.376d	c9 24		cmp #$24			cmp 	#"$"
.376f	f0 24		beq $3795			beq 	_CTOtherBase
.3771	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.3773	f0 17		beq $378c			beq 	_CTBrackets
.3775	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.3777	90 10		bcc $3789			bcc 	_CTSyntax
.3779	c9 5b		cmp #$5b			cmp 	#"Z"+1
.377b	b0 0c		bcs $3789			bcs 	_CTSyntax
.377d	20 ec 36	jsr $36ec			jsr 	GetReferenceTerm 			; figure out what it is.
.3780	48		pha				pha 								; save type on stack
.3781	18		clc				clc 								; read it
.3782	20 9e 36	jsr $369e			jsr 	GetSetVariable
.3785	68		pla				pla
.3786	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.3788	60		rts				rts
.3789					_CTSyntax:
.3789	4c 0f 1f	jmp $1f0f		jmp	ErrorV_syntax
.378c					_CTBrackets:
.378c	20 4b 2d	jsr $2d4b			jsr 	CompileExpressionAt0
.378f	48		pha				pha
.3790	20 97 2a	jsr $2a97			jsr 	CheckNextRParen
.3793	68		pla				pla
.3794	60		rts				rts
.3795					_CTOtherBase:
.3795	20 e3 29	jsr $29e3			jsr 	InlineNonDecimal 			; non decimal constant handler
.3798	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.379a	60		rts				rts
.379b					_CTDigit:
.379b	20 f4 35	jsr $35f4			jsr 	ParseConstant 				; parse out an number, first is in A already.
.379e	90 06		bcc $37a6			bcc	 	_CTFloat 					; have a float or long int.
.37a0	20 4b 2b	jsr $2b4b			jsr 	PushIntegerYA 				; code to push on stack
.37a3	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.37a5	60		rts				rts
.37a6					_CTFloat:
.37a6	20 6d 2b	jsr $2b6d			jsr 	PushFloatCommand			; code to push float
.37a9	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.37ab	60		rts				rts
.37ac					_CTString:
.37ac	20 6c 2a	jsr $2a6c			jsr 	BufferClear 				; copy it to the buffer
.37af					_CTStringLoop:
.37af	20 8f 33	jsr $338f			jsr 	LookNext 					; reached EOL/EOS
.37b2	f0 d5		beq $3789			beq 	_CTSyntax
.37b4	c9 22		cmp #$22			cmp 	#'"'
.37b6	f0 08		beq $37c0			beq 	_CTStringDone
.37b8	20 70 2a	jsr $2a70			jsr 	BufferWrite 				; write and consume
.37bb	20 a0 33	jsr $33a0			jsr 	GetNext
.37be	80 ef		bra $37af			bra 	_CTStringLoop
.37c0					_CTStringDone:
.37c0	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume closing quote.
.37c3	a9 ce		lda #$ce			lda 	#PCD_CMD_STRING 			; output command and buffer
.37c5	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.37c8	20 7c 2a	jsr $2a7c			jsr 	BufferOutput
.37cb	a9 40		lda #$40			lda 	#NSSString 					; string type
.37cd	60		rts				rts
.37ce					_CTUnaryFunctions:
.37ce	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.37d0	f0 0a		beq $37dc			beq 	_CTNegation
.37d2	a2 37		ldx #$37			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.37d4	a0 31		ldy #$31			ldy 	#UnaryTables >> 8
.37d6	20 31 32	jsr $3231			jsr 	GeneratorProcess
.37d9	90 ae		bcc $3789			bcc		_CTSyntax
.37db	60		rts				rts
.37dc					_CTNegation:
.37dc	20 57 37	jsr $3757			jsr 	CompileTerm 				; compile a term.
.37df	48		pha				pha
.37e0	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.37e2	c9 00		cmp #$00			cmp 	#NSSIFloat
.37e4	d0 07		bne $37ed			bne 	_CTType 					; error
.37e6	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.37e8	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.37eb	68		pla				pla 								; return original type.
.37ec	60		rts				rts
.37ed					_CTType:
.37ed	4c 1f 1f	jmp $1f1f		jmp	ErrorV_type
.37f0					CommandWAIT:
.37f0	20 92 33	jsr $3392			jsr 	LookNextNonSpace
.37f3	c9 2c		cmp #$2c			cmp 	#","
.37f5	f0 10		beq $3807			beq 	_CWThirdParameter
.37f7	a9 00		lda #$00			lda 	#0
.37f9	20 5e 2b	jsr $2b5e			jsr 	PushIntegerA
.37fc					_CWExit:
.37fc	a9 ca		lda #$ca			lda 	#(PCD_WAIT) >> 8
.37fe	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.3801	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.3803	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.3806	60		rts				rts
.3807					_CWThirdParameter:
.3807	20 a0 33	jsr $33a0			jsr 	GetNext
.380a	20 4d 2d	jsr $2d4d			jsr 	CompileExpressionAtA
.380d	29 40		and #$40			and 	#NSSTypeMask
.380f	c9 00		cmp #$00			cmp 	#NSSIFloat
.3811	f0 e9		beq $37fc			beq 	_CWExit
.3813	4c 1f 1f	jmp $1f1f		jmp	ErrorV_type
.3816					CommandCMD:
.3816	a9 af		lda #$af			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.3818	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.381b	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; followed by a , ?
.381e	c9 2c		cmp #$2c			cmp 	#","
.3820	d0 06		bne $3828			bne 	_CCMDExit
.3822	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume comma.
.3825	20 19 36	jsr $3619			jsr 	CommandPRINT 				; do the print code
.3828					_CCMDExit:
.3828	60		rts				rts
.3829					CommandOPEN:
.3829	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; followed by a , ?
.382c	c9 2c		cmp #$2c			cmp 	#","
.382e	d0 15		bne $3845			bne 	_COTwoDefaults
.3830	20 a0 33	jsr $33a0			jsr 	GetNext 					; consume comma
.3833	20 4b 2d	jsr $2d4b			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.3836	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.3838	f0 1e		beq $3858			beq 	_COThreeIntegers
.383a	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.383c	20 5e 2b	jsr $2b5e			jsr 	PushIntegerA
.383f	a9 be		lda #$be			lda 	#(PCD_SWAP) & $FF
.3841	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.3844	60		rts				rts
.3845					_COTwoDefaults:
.3845	a9 00		lda #$00			lda 	#0
.3847	20 5e 2b	jsr $2b5e			jsr 	PushIntegerA
.384a					_COCompileNullString:
.384a	a9 ce		lda #$ce			lda 	#(PCD_CMD_STRING) & $FF
.384c	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.384f	a9 00		lda #$00			lda 	#0
.3851	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.3854	20 35 2a	jsr $2a35			jsr 	WriteCodeByte
.3857	60		rts				rts
.3858					_COThreeIntegers:
.3858	20 92 33	jsr $3392			jsr 	LookNextNonSpace 			; is there a ,
.385b	c9 2c		cmp #$2c			cmp 	#","
.385d	d0 eb		bne $384a			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.385f	20 a0 33	jsr $33a0			jsr 	GetNext
.3862	20 4b 2d	jsr $2d4b			jsr 	CompileExpressionAt0 		; should be a filename
.3865	29 40		and #$40			and 	#NSSString
.3867	f0 01		beq $386a			beq 	_COType
.3869	60		rts				rts
.386a					_COType:
.386a	4c 1f 1f	jmp $1f1f		jmp	ErrorV_type

;******  Processing input file: _library.asm

.386d					CompilerAPI:
.386d	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.386f	f0 19		beq $388a			beq 	_CAOpenIn
.3871	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.3873	f0 23		beq $3898			beq 	_CACloseIn
.3875	c9 02		cmp #$02			cmp 	#BLC_READIN
.3877	f0 3a		beq $38b3			beq 	_CARead
.3879	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.387b	f0 1e		beq $389b			beq 	_CAResetOut
.387d	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.387f	f0 23		beq $38a4			beq 	_CACloseOut
.3881	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.3883	f0 20		beq $38a5			beq 	_CAWriteByte
.3885	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.3887	f0 26		beq $38af			beq 	_CAPrintScreen
>3889	db						.byte 	$DB 						; causes a break in the emulator
.388a					_CAOpenIn:
.388a	a0 39		ldy #$39			ldy 	#SourceFile >> 8 			; name of file
.388c	a2 aa		ldx #$aa			ldx 	#SourceFile & $FF
.388e	20 1b 39	jsr $391b			jsr 	IOOpenRead 					; open file
.3891	20 26 39	jsr $3926			jsr 	IOReadByte 					; skip the 2 byte load address header
.3894	20 26 39	jsr $3926			jsr 	IOReadByte
.3897	60		rts				rts
.3898					_CACloseIn:
.3898	4c 35 39	jmp $3935			jmp 	IOReadClose
.389b					_CAResetOut:
.389b	a9 00		lda #$00			lda 	#((FreeMemory) & $FF)
.389d	85 2a		sta $2a				sta 	0+objPtr
.389f	a9 3b		lda #$3b			lda 	#((FreeMemory) >> 8) & $FF
.38a1	85 2b		sta $2b				sta 	1+objPtr
.38a3	60		rts				rts
.38a4					_CACloseOut:
.38a4	60		rts				rts
.38a5					_CAWriteByte:
.38a5	8a		txa				txa
.38a6	92 2a		sta ($2a)			sta 	(objPtr)
.38a8	e6 2a		inc $2a				inc 	objPtr
.38aa	d0 02		bne $38ae			bne 	_HWOWBNoCarry
.38ac	e6 2b		inc $2b				inc 	objPtr+1
.38ae					_HWOWBNoCarry:
.38ae	60		rts				rts
.38af					_CAPrintScreen:
.38af	8a		txa				txa
.38b0	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.38b3					_CARead:
.38b3	20 26 39	jsr $3926			jsr 	IOReadByte 				; copy the address of next into the buffer
.38b6	8d cf 06	sta $06cf			sta 	SourceLine+0
.38b9	20 26 39	jsr $3926			jsr 	IOReadByte
.38bc	8d d0 06	sta $06d0			sta 	SourceLine+1
.38bf	0d cf 06	ora $06cf			ora 	sourceLine				; if both were zero, exit with CC (e.g. fail)
.38c2	18		clc				clc
.38c3	f0 1e		beq $38e3			beq		_CARExit
.38c5	20 26 39	jsr $3926			jsr 	IOReadByte 				; read the line # into the buffer.
.38c8	8d d1 06	sta $06d1			sta 	SourceLine+2
.38cb	20 26 39	jsr $3926			jsr 	IOReadByte
.38ce	8d d2 06	sta $06d2			sta 	SourceLine+3
.38d1	a2 04		ldx #$04			ldx 	#4 						; read the body of the line.
.38d3					_CAReadLine:
.38d3	20 26 39	jsr $3926			jsr 	IOReadByte 				; now keep copying to EOL
.38d6	9d cf 06	sta $06cf,x			sta 	SourceLine,x
.38d9	e8		inx				inx
.38da	c9 00		cmp #$00			cmp 	#0
.38dc	d0 f5		bne $38d3			bne 	_CAReadLine
.38de	38		sec				sec 							; read a line okay
.38df	a0 06		ldy #$06			ldy 	#SourceLine >> 8
.38e1	a2 cf		ldx #$cf			ldx 	#SourceLine & $FF
.38e3					_CARExit:
.38e3	60		rts				rts
.06cf					SourceLine:
>06cf							.fill 	256
.38e4					WriteObjectCode:
.38e4	20 1a 08	jsr $081a			jsr 	PatchOutCompile 			; makes it run the runtime on reload
.38e7	a0 39		ldy #$39			ldy 	#ObjectFile >> 8
.38e9	a2 9f		ldx #$9f			ldx 	#ObjectFile & $FF
.38eb	20 0e 3a	jsr $3a0e			jsr 	IOOpenWrite 				; open write
.38ee	a9 01		lda #$01			lda 	#1 							; write out the load address $0801
.38f0	20 19 3a	jsr $3a19			jsr 	IOWriteByte
.38f3	a9 08		lda #$08			lda 	#8
.38f5	20 19 3a	jsr $3a19			jsr 	IOWriteByte
.38f8	a9 01		lda #$01			lda 	#((StartBasicProgram) & $FF)
.38fa	85 2c		sta $2c				sta 	0+zTemp0
.38fc	a9 08		lda #$08			lda 	#((StartBasicProgram) >> 8) & $FF
.38fe	85 2d		sta $2d				sta 	1+zTemp0
.3900					_WOCLoop:
.3900	b2 2c		lda ($2c)			lda 	(zTemp0) 					; write code
.3902	20 19 3a	jsr $3a19			jsr 	IOWriteByte
.3905	e6 2c		inc $2c				inc 	zTemp0 						; advance pointer
.3907	d0 02		bne $390b			bne 	_WOCSkip
.3909	e6 2d		inc $2d				inc 	zTemp0+1
.390b					_WOCSkip:
.390b	a5 2c		lda $2c				lda 	zTemp0 						; check end
.390d	c5 2a		cmp $2a				cmp 	objPtr
.390f	d0 ef		bne $3900			bne 	_WOCLoop
.3911	a5 2d		lda $2d				lda 	zTemp0+1
.3913	c5 2b		cmp $2b				cmp 	objPtr+1
.3915	d0 e9		bne $3900			bne 	_WOCLoop
.3917	20 35 39	jsr $3935			jsr 	IOWriteClose 				; close the file.
.391a	60		rts				rts
.391b					IOOpenRead:
.391b	a9 52		lda #$52			lda 	#'R' 						; read.
.391d	20 3e 39	jsr $393e			jsr 	IOSetFileName 				; set up name/LFS
.3920	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for reading
.3922	20 c6 ff	jsr $ffc6			jsr 	$FFC6 						; CHKIN
.3925	60		rts				rts
.3926					IOReadByte:
.3926	da		phx				phx
.3927	5a		phy				phy
.3928	20 b7 ff	jsr $ffb7			jsr 	$FFB7 						; read ST
.392b	38		sec				sec
.392c	d0 04		bne $3932			bne 	_IORExit
.392e	20 cf ff	jsr $ffcf			jsr 	$FFCF 						; read a byte
.3931	18		clc				clc 								; status OK.
.3932					_IORExit:
.3932	7a		ply				ply
.3933	fa		plx				plx
.3934	60		rts				rts
.3935					IOReadClose:
.3935					IOWriteClose:
.3935	a9 03		lda #$03			lda 	#3 							; CLOSE# 3
.3937	20 c3 ff	jsr $ffc3			jsr 	$FFC3
.393a	20 cc ff	jsr $ffcc			jsr 	$FFCC 						; CLRCHN
.393d	60		rts				rts
.393e					IOSetFileName:
.393e	48		pha				pha 								; save R/W
.393f	86 2c		stx $2c				stx 	zTemp0
.3941	84 2d		sty $2d				sty 	zTemp0+1
.3943	a0 ff		ldy #$ff			ldy 	#$FF 						; copy name given
.3945					_IOSCopy:
.3945	c8		iny				iny 								; pre-increment copy
.3946	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.3948	99 cf 07	sta $07cf,y			sta 	IONameBuffer,y
.394b	d0 f8		bne $3945			bne 	_IOSCopy
.394d	99 d3 07	sta $07d3,y			sta 	IONameBuffer+4,y
.3950	a9 2c		lda #$2c			lda 	#',' 						; append ,S,[R|W]
.3952	99 cf 07	sta $07cf,y			sta 	IONameBuffer+0,y
.3955	99 d1 07	sta $07d1,y			sta 	IONameBuffer+2,y
.3958	a9 53		lda #$53			lda 	#'S'
.395a	99 d0 07	sta $07d0,y			sta 	IONameBuffer+1,y
.395d	68		pla				pla 								; write R/W out
.395e	99 d2 07	sta $07d2,y			sta 	IONameBuffer+3,y
.3961	98		tya				tya 								; length of name to A
.3962	18		clc				clc
.3963	69 04		adc #$04			adc 	#4 							; we added 4 characters.
.3965	a2 cf		ldx #$cf			ldx 	#IONameBuffer & $FF			; name address to YX
.3967	a0 07		ldy #$07			ldy 	#IONameBuffer >> 8
.3969	20 bd ff	jsr $ffbd		    jsr 	$FFBD          				; call SETNAM
.396c	a9 03		lda #$03	    	lda 	#3 							; set LFS to 3,8,3
.396e	a2 08		ldx #$08			ldx 	#8
.3970	a0 03		ldy #$03			ldy 	#3
.3972	20 ba ff	jsr $ffba			jsr 	$FFBA
.3975	20 c0 ff	jsr $ffc0			jsr 	$FFC0 						; OPEN
.3978	60		rts				rts
.07cf					IONameBuffer:
>07cf							.fill 	64
.3979					CompileCode:
.3979	a2 00		ldx #$00			ldx 	#0
.397b	bd b5 39	lda $39b5,x	_Prompt:lda 	Prompt,x
.397e	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3981	e8		inx				inx
.3982	c9 00		cmp #$00			cmp 	#0
.3984	d0 f5		bne $397b			bne 	_Prompt
.3986	a2 9b		ldx #$9b			ldx 	#APIDesc & $FF
.3988	a0 39		ldy #$39			ldy 	#APIDesc >> 8
.398a	20 ac 2a	jsr $2aac			jsr 	StartCompiler
.398d	20 e4 38	jsr $38e4			jsr 	WriteObjectCode
.3990	a9 4f		lda #$4f			lda 	#"O"
.3992	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3995	a9 4b		lda #$4b			lda 	#"K"
.3997	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.399a	60		rts				rts
.399b					APIDesc:
>399b	6d 38						.word 	CompilerAPI 				; the compiler API Implementeation
>399d	80						.byte 	$80 						; start of workspace for compiler $8000
>399e	9f						.byte 	$9F							; end of workspace for compiler $9F00
.399f					ObjectFile:
>399f	4f 42 4a 45 43 54 2e 50				.text 	'OBJECT.PRG',0
>39a7	52 47 00
.39aa					SourceFile:
>39aa	53 4f 55 52 43 45 2e 50				.text 	'SOURCE.PRG',0
>39b2	52 47 00
.39b5					Prompt:
>39b5	2a 2a 2a 20 42 4c 49 54				.text 	'*** BLITZ (ALPHA 09-10-23) ***',13,13
>39bd	5a 20 28 41 4c 50 48 41 20 30 39 2d 31 30 2d 32
>39cd	33 29 20 2a 2a 2a 0d 0d
>39d5	42 55 47 53 3a 48 54 54				.text 	'BUGS:HTTPS://GITHUB.COM/PAULSCOTTROBSON/BLITZ-COMPILER',13,13,0
>39dd	50 53 3a 2f 2f 47 49 54 48 55 42 2e 43 4f 4d 2f
>39ed	50 41 55 4c 53 43 4f 54 54 52 4f 42 53 4f 4e 2f
>39fd	42 4c 49 54 5a 2d 43 4f 4d 50 49 4c 45 52 0d 0d
>3a0d	00
.3a0e					IOOpenWrite:
.3a0e	a9 57		lda #$57			lda 	#'W'			 			; write
.3a10	20 3e 39	jsr $393e			jsr 	IOSetFileName 				; set up name/LFS
.3a13	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for writing
.3a15	20 c9 ff	jsr $ffc9			jsr 	$FFC9 						; CHKOUT
.3a18	60		rts				rts
.3a19					IOWriteByte:
.3a19	48		pha				pha
.3a1a	da		phx				phx
.3a1b	5a		phy				phy
.3a1c	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a1f	7a		ply				ply
.3a20	fa		plx				plx
.3a21	68		pla				pla
.3a22	60		rts				rts

;******  Processing input file: source/main/zzfree.footer

>3a23							.align 	256
.3b00					FreeMemory:

;******  End of listing
