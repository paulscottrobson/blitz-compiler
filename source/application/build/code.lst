
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -q -c -Wall -o build/code.prg -L build/code.lst -l build/code.lbl source/main/00main.header /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library /home/paulr/Projects/blitz-compiler/documents/../bin/common.library /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library _library.asm source/main/zzfree.footer
; Thu Oct 12 03:07:20 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: source/main/00main.header

.0801					StartBasicProgram:
>0801	0c 08						.word 	$080C 						; offset to next.
>0803	0a 00						.word 	10 							; line #
>0805	9e						.byte 	$9E 						; token for 'SYS'
>0806	20 32 30 36 32					.text 	' 2062'						; space, $080E in decimal
>080b	00						.byte  	0 							; end of line
>080c	00 00						.word 	0 							; end of program
.080e					StartCode:
.080e	4c b4 39	jmp $39b4			jmp 	CompileCode 				; to starting the runtime in the saved code.
.0811	a9 3b		lda #$3b			lda 	#FreeMemory >> 8 			; address of object code to run.
.0813	a2 80		ldx #$80			ldx 	#$80 						; 8000-9EFF is used for workspace.
.0815	a0 9f		ldy #$9f			ldy 	#$9F
.0817	4c 26 08	jmp $0826			jmp 	StartRuntime 				; and go do it !
.081a					PatchOutCompile:
.081a	a9 ea		lda #$ea			lda 	#$EA 						; $EA is NOP 65C02
.081c	8d 0e 08	sta $080e			sta 	StartCode 					; patch out "JMP COMPILECODE"
.081f	8d 0f 08	sta $080f			sta 	StartCode+1
.0822	8d 10 08	sta $0810			sta 	StartCode+2
.0825	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/runtime.library

.0022					zsTemp:
>0022							.fill 	2
.0024					runtimeStackPtr:
>0024							.fill 	2
.0400					stringLowMemory:
>0400							.fill 	2
.0402					stringHighMemory:
>0402							.fill 	2
=$e4					FRAME_GOSUB = $E4 							; Gosub has 4 bytes
=211					FRAME_FOR = $C0+19 							; For has 19 bytes
=$9f20					VRAMLow0 = $9F20
=$9f21					VRAMMed0 = $9F21
=$9f22					VRAMHigh0 = $9F22
=$9f23					VRAMData0 = $9F23
=$c09f					X16A_audio_init=$C09F
=$c08d					X16A_bas_fmchordstring=$C08D
=$c000					X16A_bas_fmfreq=$C000
=$c003					X16A_bas_fmnote=$C003
=$c006					X16A_bas_fmplaystring=$C006
=$c009					X16A_bas_fmvib=$C009
=$c00c					X16A_bas_playstringvoice=$C00C
=$c090					X16A_bas_psgchordstring=$C090
=$c00f					X16A_bas_psgfreq=$C00F
=$c012					X16A_bas_psgnote=$C012
=$c015					X16A_bas_psgwav=$C015
=$c018					X16A_bas_psgplaystring=$C018
=$c01b					X16A_notecon_bas2fm=$C01B
=$c01e					X16A_notecon_bas2midi=$C01E
=$c021					X16A_notecon_bas2psg=$C021
=$c024					X16A_notecon_fm2bas=$C024
=$c027					X16A_notecon_fm2midi=$C027
=$c02a					X16A_notecon_fm2psg=$C02A
=$c02d					X16A_notecon_freq2bas=$C02D
=$c030					X16A_notecon_freq2fm=$C030
=$c033					X16A_notecon_freq2midi=$C033
=$c036					X16A_notecon_freq2psg=$C036
=$c039					X16A_notecon_midi2bas=$C039
=$c03c					X16A_notecon_midi2fm=$C03C
=$c03f					X16A_notecon_midi2psg=$C03F
=$c042					X16A_notecon_psg2bas=$C042
=$c045					X16A_notecon_psg2fm=$C045
=$c048					X16A_notecon_psg2midi=$C048
=$c093					X16A_psg_getatten=$C093
=$c096					X16A_psg_getpan=$C096
=$c04b					X16A_psg_init=$C04B
=$c04e					X16A_psg_playfreq=$C04E
=$c051					X16A_psg_read=$C051
=$c054					X16A_psg_setatten=$C054
=$c057					X16A_psg_setfreq=$C057
=$c05a					X16A_psg_setpan=$C05A
=$c05d					X16A_psg_setvol=$C05D
=$c060					X16A_psg_write=$C060
=$c0a2					X16A_psg_write_fast=$C0A2
=$c099					X16A_ym_getatten=$C099
=$c09c					X16A_ym_getpan=$C09C
=$c063					X16A_ym_init=$C063
=$c066					X16A_ym_loaddefpatches=$C066
=$c069					X16A_ym_loadpatch=$C069
=$c06c					X16A_ym_loadpatchlfn=$C06C
=$c06f					X16A_ym_playdrum=$C06F
=$c072					X16A_ym_playnote=$C072
=$c075					X16A_ym_setatten=$C075
=$c078					X16A_ym_setdrum=$C078
=$c07b					X16A_ym_setnote=$C07B
=$c07e					X16A_ym_setpan=$C07E
=$c081					X16A_ym_read=$C081
=$c084					X16A_ym_release=$C084
=$c087					X16A_ym_trigger=$C087
=$c08a					X16A_ym_write=$C08A
=2					X16_r0 = 2
=4					X16_r1 = 4
=6					X16_r2 = 6
=8					X16_r3 = 8
=10					X16_r4 = 10
=$ffa5					X16_ACPTR=$FFA5
=$ffcf					X16_BASIN=$FFCF
=$feba					X16_BSAVE=$FEBA
=$ffd2					X16_BSOUT=$FFD2
=$ffa8					X16_CIOUT=$FFA8
=$ffe7					X16_CLALL=$FFE7
=$ffc3					X16_CLOSE=$FFC3
=$ffc6					X16_CHKIN=$FFC6
=$ffc9					X16_CHKOUT=$FFC9
=$ff50					X16_clock_get_date_time=$FF50
=$ff4d					X16_clock_set_date_time=$FF4D
=$ffcf					X16_CHRIN=$FFCF
=$ffd2					X16_CHROUT=$FFD2
=$ff4a					X16_CLOSE_ALL=$FF4A
=$ffcc					X16_CLRCHN=$FFCC
=$fedb					X16_console_init=$FEDB
=$fee1					X16_console_get_char=$FEE1
=$fede					X16_console_put_char=$FEDE
=$fed8					X16_console_put_image=$FED8
=$fed5					X16_console_set_paging_message=$FED5
=$ff47					X16_enter_basic=$FF47
=$fecf					X16_entropy_get=$FECF
=$ff74					X16_fetch=$FF74
=$ff02					X16_FB_cursor_next_line=$FF02
=$feff					X16_FB_cursor_position=$FEFF
=$ff17					X16_FB_fill_pixels=$FF17
=$ff1a					X16_FB_filter_pixels=$FF1A
=$fef9					X16_FB_get_info=$FEF9
=$ff05					X16_FB_get_pixel=$FF05
=$ff08					X16_FB_get_pixels=$FF08
=$fef6					X16_FB_init=$FEF6
=$ff1d					X16_FB_move_pixels=$FF1D
=$ff11					X16_FB_set_8_pixels=$FF11
=$ff14					X16_FB_set_8_pixels_opaque=$FF14
=$fefc					X16_FB_set_palette=$FEFC
=$ff0b					X16_FB_set_pixel=$FF0B
=$ff0e					X16_FB_set_pixels=$FF0E
=$ffe4					X16_GETIN=$FFE4
=$ff23					X16_GRAPH_clear=$FF23
=$ff38					X16_GRAPH_draw_image=$FF38
=$ff2c					X16_GRAPH_draw_line=$FF2C
=$ff35					X16_GRAPH_draw_oval=$FF35
=$ff2f					X16_GRAPH_draw_rect=$FF2F
=$ff3e					X16_GRAPH_get_char_size=$FF3E
=$ff20					X16_GRAPH_init=$FF20
=$ff32					X16_GRAPH_move_rect=$FF32
=$ff41					X16_GRAPH_put_char=$FF41
=$ff29					X16_GRAPH_set_colors=$FF29
=$ff3b					X16_GRAPH_set_font=$FF3B
=$ff26					X16_GRAPH_set_window=$FF26
=$fec6					X16_i2c_read_byte=$FEC6
=$fec9					X16_i2c_write_byte=$FEC9
=$fff3					X16_IOBASE=$FFF3
=$ff6e					X16_JSRFAR=$FF6E
=$ff56					X16_joystick_get=$FF56
=$ff53					X16_joystick_scan=$FF53
=$fec0					X16_kbdbuf_get_modifiers=$FEC0
=$febd					X16_kbdbuf_peek=$FEBD
=$fec3					X16_kbdbuf_put=$FEC3
=$fed2					X16_keymap=$FED2
=$ffb1					X16_LISTEN=$FFB1
=$ff59					X16_LKUPLA=$FF59
=$ff5c					X16_LKUPSA=$FF5C
=$ffd5					X16_LOAD=$FFD5
=$ff44					X16_MACPTR=$FF44
=$ff9c					X16_MEMBOT=$FF9C
=$fee7					X16_memory_copy=$FEE7
=$feea					X16_memory_crc=$FEEA
=$feed					X16_memory_decompress=$FEED
=$fee4					X16_memory_fill=$FEE4
=$ff99					X16_MEMTOP=$FF99
=$fecc					X16_monitor=$FECC
=$ff68					X16_mouse_config=$FF68
=$ff6b					X16_mouse_get=$FF6B
=$ff71					X16_mouse_scan=$FF71
=$ffc0					X16_OPEN=$FFC0
=$ff65					X16_PFKEY=$FF65
=$fff0					X16_PLOT=$FFF0
=$ff7d					X16_PRIMM=$FF7D
=$ffde					X16_RDTIM=$FFDE
=$ffb7					X16_READST=$FFB7
=$ffd8					X16_SAVE=$FFD8
=$ffed					X16_SCREEN=$FFED
=$ff5f					X16_screen_mode=$FF5F
=$ff62					X16_screen_set_charset=$FF62
=$ff93					X16_SECOND=$FF93
=$ffba					X16_SETLFS=$FFBA
=$ff90					X16_SETMSG=$FF90
=$ffbd					X16_SETNAM=$FFBD
=$ffdb					X16_SETTIM=$FFDB
=$ffa2					X16_SETTMO=$FFA2
=$fef0					X16_sprite_set_image=$FEF0
=$fef3					X16_sprite_set_position=$FEF3
=$ff77					X16_stash=$FF77
=$ffe1					X16_STOP=$FFE1
=$ffb4					X16_TALK=$FFB4
=$ff96					X16_TKSA=$FF96
=$ffea					X16_UDTIM=$FFEA
=$ffae					X16_UNLSN=$FFAE
=$ffab					X16_UNTLK=$FFAB
=$311					USRRoutineAddress = $311
=$30c					SYS_Reg_A = $30C
=$30d					SYS_Reg_X = $30D
=$30e					SYS_Reg_Y = $30E
=$30f					SYS_Reg_S = $30F
=0					SelectRAMBank = 0
=1					SelectROMBank = 1
=$0a					X16_AudioCodeBank = $0A
.0826					StartRuntime:
.0826	8d 04 04	sta $0404			sta 	runtimeHigh 				; save address of code.
.0829	85 29		sta $29				sta 	codePtr+1 					; set pointer to code.
.082b	64 28		stz $28				stz 	codePtr
.082d	8e 05 04	stx $0405			stx 	storeStartHigh 				; save from-to address.
.0830	8c 06 04	sty $0406			sty 	storeEndHigh
.0833	8e 07 04	stx $0407			stx 	variableStartPage
.0836	ba		tsx				tsx 								; save the stack.
.0837	8e 08 04	stx $0408			stx 	Runtime6502SP
.083a	a0 0c		ldy #$0c			ldy 	#RuntimeErrorHandler >> 8 	; set error handler to runtime one.
.083c	a2 58		ldx #$58			ldx 	#RuntimeErrorHandler & $FF
.083e	20 f5 1e	jsr $1ef5			jsr 	SetErrorHandler
.0841	20 84 0a	jsr $0a84			jsr 	ClearMemory 				; clear memory.
.0844	20 72 16	jsr $1672			jsr 	XRuntimeSetup 				; initialise the runtime stuff.
.0847	20 74 13	jsr $1374		 	jsr		SetDefaultChannel			; set default input/output channel.
.084a	20 aa 15	jsr $15aa			jsr 	RestoreCode 				; which we now call
.084d	a0 00		ldy #$00			ldy 	#0
.084f					NextCommand:
.084f	ad 09 04	lda $0409			lda  	breakCount 					; only check every 16 instructions.
.0852	69 10		adc #$10			adc 	#16
.0854	8d 09 04	sta $0409			sta 	breakCount
.0857	90 07		bcc $0860			bcc 	_NXNoCheck
.0859	da		phx				phx
.085a	5a		phy				phy 								; check Ctrl+C
.085b	20 b0 1b	jsr $1bb0			jsr 	XCheckStop
.085e	7a		ply				ply
.085f	fa		plx				plx
.0860					_NXNoCheck:
.0860	b1 28		lda ($28),y			lda 	(codePtr),y 				; get next
.0862	30 5b		bmi $08bf			bmi 	NXCommand 					; -if -ve command
.0864	c8		iny				iny
.0865	c9 40		cmp #$40			cmp 	#64 						; 64..127 is load and store.
.0867	90 39		bcc $08a2			bcc 	PushByteA 					; 0..63 is short constants.
.0869					NXLoadStore:
.0869	c9 78		cmp #$78			cmp		#120 						; is it an indirect read/write
.086b	b0 19		bcs $0886			bcs 	NXIndirectLoadStore
.086d	4a		lsr a				lsr 	a 							; / 4, so $48 => $12,
.086e	4a		lsr a				lsr 	a
.086f	29 0e		and #$0e			and 	#$0E
.0871	da		phx				phx 								; get ready to jump
.0872	aa		tax				tax
.0873	7c 76 08	jmp ($0876,x)			jmp 	(ReadWriteVectors,x) 		; go via the jump table.
.0876					ReadWriteVectors:
>0876	e0 14						.word 	ReadFloatCommand			; read float
>0878	bf 1a						.word 	WriteFloatCommand 			; write float
>087a	1c 15						.word 	ReadIntegerCommand 			; read integer
>087c	fb 1a						.word 	WriteIntegerCommand 		; write integer
>087e	61 15						.word 	ReadStringCommand 			; read string
>0880	3a 1b						.word 	WriteStringCommand 			; write string
>0882	55 0c						.word 	Unimplemented
>0884	55 0c						.word 	Unimplemented
.0886					NXIndirectLoadStore:
.0886	29 07		and #$07			and 	#7
.0888	0a		asl a				asl 	a
.0889	da		phx				phx
.088a	aa		tax				tax
.088b	7c 8e 08	jmp ($088e,x)			jmp 	(IndirectVectors,x)
.088e					IndirectVectors:
>088e	0c 0f						.word 	IndFloatRead 				; float read
>0890	20 0f						.word 	IndInt16Read 				; int16 read
>0892	34 0f						.word 	IndStringRead 				; string read
>0894	55 0c						.word 	Unimplemented
>0896	48 0f						.word 	IndFloatWrite				; float write
>0898	5c 0f						.word 	IndInt16Write 				; int16 write
>089a	70 0f						.word 	IndStringWrite 				; string write
>089c	55 0c						.word 	Unimplemented
.089e					PushByteCommand:
.089e	fa		plx				plx
.089f	b1 28		lda ($28),y			lda 	(codePtr),y 				; get byte to write.
.08a1	c8		iny				iny
.08a2					PushByteA:
.08a2	e8		inx				inx 								; push constant on stack
.08a3	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; save byte
.08a5	74 4a		stz $4a,x			stz 	NSMantissa1,x 				; clear MSB
.08a7					ClearRestWord:
.08a7	74 56		stz $56,x			stz 	NSMantissa2,x 				; zero upper bytes, exponent, make iFloat32
.08a9	74 62		stz $62,x			stz 	NSMantissa3,x
.08ab	74 6e		stz $6e,x			stz 	NSExponent,x
.08ad	74 32		stz $32,x			stz 	NSStatus,x
.08af	80 9e		bra $084f			bra 	NextCommand
.08b1					PushWordCommand:
.08b1	fa		plx				plx
.08b2	e8		inx				inx
.08b3	b1 28		lda ($28),y			lda 	(codePtr),y 				; word to stack
.08b5	c8		iny				iny
.08b6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.08b8	b1 28		lda ($28),y			lda 	(codePtr),y
.08ba	c8		iny				iny
.08bb	95 4a		sta $4a,x			sta 	NSMantissa1,x
.08bd	80 e8		bra $08a7			bra 	ClearRestWord 				; handle everything else.
.08bf					NXCommand:
.08bf	c8		iny				iny 								; consume command.
.08c0	10 03		bpl $08c5			bpl 	_NXCommandNoFixUp
.08c2	20 cb 08	jsr $08cb			jsr 	FixUpY
.08c5					_NXCommandNoFixUp:
.08c5	0a		asl a				asl 	a 							; shift left
.08c6	da		phx				phx 								; save SP on stack
.08c7	aa		tax				tax				 					; and jump indirect
.08c8	7c 9c 19	jmp ($199c,x)			jmp 	(VectorTable,x)
.08cb					FixUpY:
.08cb	48		pha				pha
.08cc	98		tya				tya
.08cd	18		clc				clc
.08ce	65 28		adc $28				adc 	codePtr
.08d0	85 28		sta $28				sta 	codePtr
.08d2	90 02		bcc $08d6			bcc 	_NoCPCarry
.08d4	e6 29		inc $29				inc 	codePtr+1
.08d6					_NoCPCarry:
.08d6	a0 00		ldy #$00			ldy 	#0
.08d8	68		pla				pla
.08d9	60		rts				rts
.0404					runtimeHigh:
>0404							.fill 	1
.0405					storeStartHigh:
>0405							.fill 	1
.0406					storeEndHigh:
>0406							.fill 	1
.0407					variableStartPage:
>0407							.fill 	1
.0408					Runtime6502SP:
>0408							.fill 	1
.0409					breakCount:
>0409							.fill 	1
.08da					AbsoluteTOS:
.08da	fa		plx				plx
.08db	74 32		stz $32,x			stz 	NSStatus,x 					; dereferenced so just clear the status byte.
.08dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.08e0					CommandVarSpace:
.08e0	fa		plx				plx
.08e1	b1 28		lda ($28),y			lda 	(codePtr),y					; 3 byte opcode, which is 'free' memory in variable area.
.08e3	85 26		sta $26				sta 	availableMemory
.08e5	c8		iny				iny
.08e6	b1 28		lda ($28),y			lda 	(codePtr),y
.08e8	18		clc				clc
.08e9	6d 07 04	adc $0407			adc 	variableStartPage			; offset to actual address.
.08ec	85 27		sta $27				sta 	availableMemory+1
.08ee	c8		iny				iny
.08ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.0026					availableMemory:
>0026							.fill 	2
.08f2					BinaryAnd:
.08f2	fa		plx				plx
.08f3	38		sec				sec
.08f4	80 02		bra $08f8			bra 	AndOrCommon
.08f6					BinaryOr:
.08f6	fa		plx				plx
.08f7	18		clc				clc
.08f8					AndOrCommon:
.08f8	08		php				php 								; save AND/OR flag
.08f9	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.08fc	ca		dex				dex
.08fd	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.0900	28		plp				plp
.0901	90 0e		bcc $0911			bcc 	_AOCOrCode
.0903	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; AND code
.0905	35 3f		and $3f,x			and		NSMantissa0+1,x
.0907	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0909	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.090b	35 4b		and $4b,x			and		NSMantissa1+1,x
.090d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.090f	80 0c		bra $091d			bra 	_AOCComplete
.0911					_AOCOrCode:
.0911	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; OR code
.0913	15 3f		ora $3f,x			ora		NSMantissa0+1,x
.0915	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0917	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0919	15 4b		ora $4b,x			ora		NSMantissa1+1,x
.091b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.091d					_AOCComplete:
.091d	74 32		stz $32,x			stz 	NSStatus,x 					; make integer ?
.091f	34 4a		bit $4a,x			bit 	NSMantissa1,x 				; result is -ve
.0921	10 07		bpl $092a			bpl 	_AOCExit
.0923	20 57 10	jsr $1057			jsr 	Negate16Bit 				; 2's complement
.0926	a9 80		lda #$80			lda 	#$80 						; make it -ve
.0928	95 32		sta $32,x			sta 	NSStatus,x
.092a					_AOCExit:
.092a	4c 4f 08	jmp $084f			jmp 	NextCommand
.092d					ArrayConvert:
.092d	fa		plx				plx
.092e	5a		phy				phy
.092f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0931	85 2e		sta $2e				sta 	zTemp1
.0933	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0935	18		clc				clc
.0936	6d 07 04	adc $0407			adc 	variableStartPage
.0939	85 2f		sta $2f				sta 	zTemp1+1
.093b	ca		dex				dex 								; count of indices to follow -> zTemp2
.093c	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.093f	85 30		sta $30				sta 	zTemp2 						; subtract from stack.
.0941	8a		txa				txa
.0942	38		sec				sec
.0943	e5 30		sbc $30				sbc 	zTemp2
.0945	aa		tax				tax
.0946	da		phx				phx 								; stack points at the first index, which will be replaced.
.0947					_ACIndexLoop:
.0947	20 af 22	jsr $22af			jsr 	FloatIntegerPart 			; integer array index
.094a	20 47 10	jsr $1047			jsr 	GetInteger16Bit 			; get the index => zTemp0
.094d	a0 01		ldy #$01			ldy 	#1 							; compare against the index count.
.094f	a5 2c		lda $2c				lda 	zTemp0
.0951	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0953	a5 2d		lda $2d				lda 	zTemp0+1
.0955	f1 2e		sbc ($2e),y			sbc 	(zTemp1),y
.0957	b0 79		bcs $09d2			bcs 	_ACBadIndex 				; index error.
.0959	c6 30		dec $30				dec 	zTemp2 						; decrement count, if zero, then innermost level
.095b	f0 29		beq $0986			beq 	_ACInnerLevel
.095d	a0 02		ldy #$02			ldy 	#2 							; check sub index.
.095f	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.0961	10 6f		bpl $09d2			bpl 	_ACBadIndex
.0963	06 2c		asl $2c				asl 	zTemp0 						; double the index and add it to the base address
.0965	26 2d		rol $2d				rol 	zTemp0+1
.0967	18		clc				clc
.0968	a5 2c		lda $2c				lda		zTemp0
.096a	65 2e		adc $2e				adc 	zTemp1
.096c	85 2c		sta $2c				sta 	zTemp0
.096e	a5 2d		lda $2d				lda		zTemp0+1
.0970	65 2f		adc $2f				adc 	zTemp1+1
.0972	85 2d		sta $2d				sta 	zTemp0+1
.0974	a0 03		ldy #$03			ldy 	#3 							; we offset by 3 because 3 at entry, now get the address
.0976	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; into zTemp1 as a real address, not offset
.0978	85 2e		sta $2e				sta 	zTemp1
.097a	c8		iny				iny
.097b	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.097d	18		clc				clc
.097e	6d 07 04	adc $0407			adc 	variableStartPage
.0981	85 2f		sta $2f				sta 	zTemp1+1
.0983	e8		inx				inx 								; next index
.0984	80 c1		bra $0947			bra 	_ACIndexLoop
.0986					_ACInnerLevel:
.0986	a0 02		ldy #$02			ldy 	#2
.0988	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.098a	30 46		bmi $09d2			bmi 	_ACBadIndex 				; it has sub arrays, so bad index.
.098c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; check if it is an iFloat
.098e	c9 00		cmp #$00			cmp 	#NSSIFloat
.0990	d0 13		bne $09a5			bne 	_ACNotFloat
.0992	a5 2d		lda $2d				lda 	zTemp0+1 					; double and add zTemp0 (x3)
.0994	48		pha				pha
.0995	a5 2c		lda $2c				lda 	zTemp0
.0997	06 2c		asl $2c				asl 	zTemp0 						; x 2
.0999	26 2d		rol $2d				rol 	zTemp0+1
.099b	18		clc				clc 								; add back x 3
.099c	65 2c		adc $2c				adc 	zTemp0
.099e	85 2c		sta $2c				sta 	zTemp0
.09a0	68		pla				pla
.09a1	65 2d		adc $2d				adc 	zTemp0+1
.09a3	85 2d		sta $2d				sta 	zTemp0+1
.09a5					_ACNotFloat:
.09a5	06 2c		asl $2c				asl 	zTemp0 						; x 2 or x 6 depending.
.09a7	26 2d		rol $2d				rol 	zTemp0+1
.09a9	18		clc				clc
.09aa	a5 2c		lda $2c				lda 	zTemp0
.09ac	69 03		adc #$03			adc 	#3
.09ae	85 2c		sta $2c				sta 	zTemp0
.09b0	90 02		bcc $09b4			bcc 	_ACNoCarry
.09b2	e6 2d		inc $2d				inc 	zTemp0+1
.09b4					_ACNoCarry:
.09b4	fa		plx				plx 								; X points to first slot of array parameters
.09b5	18		clc				clc
.09b6	a5 2c		lda $2c				lda 	zTemp0
.09b8	65 2e		adc $2e				adc 	zTemp1
.09ba	95 3e		sta $3e,x			sta 	NSMantissa0,x
.09bc	a5 2d		lda $2d				lda 	zTemp0+1
.09be	65 2f		adc $2f				adc 	zTemp1+1
.09c0	38		sec				sec
.09c1	ed 07 04	sbc $0407			sbc 	variableStartPage
.09c4	95 4a		sta $4a,x			sta 	NSMantissa1,x
.09c6	74 56		stz $56,x			stz 	NSMantissa2,x
.09c8	74 62		stz $62,x			stz 	NSMantissa3,x
.09ca	74 32		stz $32,x			stz 	NSStatus,x
.09cc	74 6e		stz $6e,x			stz 	NSExponent,x
.09ce	7a		ply				ply 	 							; restore code pointer
.09cf	4c 4f 08	jmp $084f			jmp 	NextCommand
.09d2					_ACBadIndex:
.09d2	4c f7 1f	jmp $1ff7		jmp	ErrorV_index
.09d5					UnaryAsc:
.09d5	fa		plx				plx
.09d6	5a		phy				phy
.09d7	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.09d9	85 2c		sta $2c				sta 	zTemp0
.09db	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.09dd	85 2d		sta $2d				sta 	zTemp0+1
.09df	b2 2c		lda ($2c)			lda 	(zTemp0) 					; if empty string return zero
.09e1	f0 06		beq $09e9			beq 	_UAExit
.09e3	5a		phy				phy 								; otherwise first character
.09e4	a0 01		ldy #$01			ldy 	#1
.09e6	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.09e8	7a		ply				ply
.09e9					_UAExit:
.09e9	20 76 26	jsr $2676			jsr 	FloatSetByte
.09ec	7a		ply				ply
.09ed	4c 4f 08	jmp $084f			jmp 	NextCommand
.09f0					CommandAssert:
.09f0	fa		plx				plx
.09f1	e0 00		cpx #$00			cpx 	#0 							; check only one element on stack
.09f3	d0 09		bne $09fe			bne 	_CAFail
.09f5	20 96 26	jsr $2696			jsr 	FloatIsZero 				; is it zero ?
.09f8	f0 04		beq $09fe			beq 	_CAFail
.09fa	ca		dex				dex
.09fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.09fe					_CAFail:
.09fe	4c 50 1f	jmp $1f50		jmp	ErrorV_assert
.0a01					X16_Audio_Parameters8_16:
.0a01	20 07 0a	jsr $0a07			jsr 	X16_Audio_Parameters8_8
.0a04	a4 4b		ldy $4b				ldy 	NSMantissa1+1
.0a06	60		rts				rts
.0a07					X16_Audio_Parameters8_8:
.0a07	a2 01		ldx #$01			ldx 	#1
.0a09	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.0a0c	ca		dex				dex
.0a0d	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.0a10	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0a13	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.0a15	a0 00		ldy #$00			ldy 	#0
.0a17	60		rts				rts
.0a18					X16_Audio_Parameters8_String:
.0a18	20 01 0a	jsr $0a01			jsr 	X16_Audio_Parameters8_16 	; get as numbers.
.0a1b	da		phx				phx 								; set the voice
.0a1c	5a		phy				phy
.0a1d	20 6e ff	jsr $ff6e			jsr 	X16_JSRFAR
.0a20	20 0c c0	jsr $c00c			jsr 	X16A_bas_playstringvoice
>0a23	0a						.byte 	X16_AudioCodeBank
.0a24	7a		ply				ply
.0a25	fa		plx				plx
.0a26	86 2c		stx $2c				stx 	zTemp0
.0a28	84 2d		sty $2d				sty 	zTemp0+1
.0a2a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read length
.0a2c	e8		inx				inx 								; point YX to first character.
.0a2d	d0 01		bne $0a30			bne 	_X16APSSkip
.0a2f	c8		iny				iny
.0a30					_X16APSSkip:
.0a30	60		rts				rts
.0a31					Unary16Bin:
.0a31	fa		plx				plx
.0a32	20 47 10	jsr $1047			jsr 	GetInteger16Bit				; 16 bit int
.0a35	a9 10		lda #$10			lda 	#16 						; allocate / set 16 bytes.
.0a37	20 1b 17	jsr $171b			jsr 	StringAllocTemp
.0a3a	a5 2d		lda $2d				lda 	zTemp0+1
.0a3c	f0 03		beq $0a41			beq 	_UBNoHigh
.0a3e	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a41					_UBNoHigh:
.0a41	a5 2c		lda $2c				lda 	zTemp0
.0a43	20 49 0a	jsr $0a49			jsr 	_UBWriteBinary
.0a46	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a49					_UBWriteBinary:
.0a49	5a		phy				phy
.0a4a	a0 08		ldy #$08			ldy 	#8
.0a4c					_UBWLoop:
.0a4c	0a		asl a				asl 	a
.0a4d	48		pha				pha
.0a4e	a9 00		lda #$00			lda  	#0
.0a50	69 30		adc #$30			adc 	#48
.0a52	20 44 17	jsr $1744			jsr 	StringWriteChar
.0a55	68		pla				pla
.0a56	88		dey				dey
.0a57	d0 f3		bne $0a4c			bne 	_UBWLoop
.0a59	7a		ply				ply
.0a5a	60		rts				rts
.0a5b					PrintCharacterX:
.0a5b	fa		plx				plx
.0a5c	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0a5e	ca		dex				dex
.0a5f	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.0a62	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a65					UnaryChr:
.0a65	fa		plx				plx
.0a66	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get integer to convert.
.0a69	48		pha				pha 								; save it and allocate for it
.0a6a	a9 01		lda #$01			lda 	#1 							; 1 character
.0a6c	20 1b 17	jsr $171b			jsr 	StringAllocTemp
.0a6f	a9 01		lda #$01			lda 	#1 							; length 1.
.0a71	92 22		sta ($22)			sta 	(zsTemp)
.0a73	68		pla				pla 								; character code makes string.
.0a74	5a		phy				phy
.0a75	a0 01		ldy #$01			ldy 	#1
.0a77	91 22		sta ($22),y			sta 	(zsTemp),y
.0a79	7a		ply				ply
.0a7a	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a7d					CommandClr:
.0a7d	fa		plx				plx
.0a7e	20 84 0a	jsr $0a84			jsr 	ClearMemory
.0a81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0a84					ClearMemory:
.0a84	ad 05 04	lda $0405			lda 	storeStartHigh 							; erase the work area
.0a87	85 2d		sta $2d				sta 	zTemp0+1
.0a89	64 2c		stz $2c				stz 	zTemp0
.0a8b	5a		phy				phy
.0a8c	a0 00		ldy #$00			ldy 	#0
.0a8e					_ClearLoop1:
.0a8e	a9 00		lda #$00			lda 	#0
.0a90	91 2c		sta ($2c),y			sta 	(zTemp0),y
.0a92	c8		iny				iny
.0a93	d0 f9		bne $0a8e			bne 	_ClearLoop1
.0a95	e6 2d		inc $2d				inc 	zTemp0+1
.0a97	a5 2d		lda $2d				lda 	zTemp0+1
.0a99	cd 06 04	cmp $0406			cmp 	storeEndHigh
.0a9c	d0 f0		bne $0a8e			bne 	_ClearLoop1
.0a9e	38		sec				sec 											; stack space = number of pages in total / 4
.0a9f	ad 06 04	lda $0406			lda 	storeEndHigh
.0aa2	ed 05 04	sbc $0405			sbc		storeStartHigh
.0aa5	4a		lsr a				lsr 	a
.0aa6	4a		lsr a				lsr 	a
.0aa7	d0 02		bne $0aab			bne 	_NotEmpty 								; at least 1 !
.0aa9	a9 01		lda #$01			lda 	#1
.0aab					_NotEmpty:
.0aab	38		sec				sec 											; subtract from high to give string high memory
.0aac	49 ff		eor #$ff			eor 	#$FF
.0aae	6d 06 04	adc $0406			adc 	storeEndHigh
.0ab1	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0ab4	9c 02 04	stz $0402			stz 	stringHighMemory
.0ab7	9c 6a 05	stz $056a			stz 	stringInitialised 						; string system not initialised
.0aba	ad 05 04	lda $0405			lda 	storeStartHigh 							; stack at end of start memory.
.0abd	3a		dec a				dec 	a
.0abe	85 25		sta $25				sta 	runtimeStackPtr+1
.0ac0	a9 ff		lda #$ff			lda 	#$FF
.0ac2	85 24		sta $24				sta 	runtimeStackPtr
.0ac4	a9 ff		lda #$ff			lda 	#$FF 									; duff marker in case we try to remove it.
.0ac6	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0ac8	7a		ply				ply
.0ac9	60		rts				rts
.0aca					CompareStrings:
.0aca	fa		plx				plx
.0acb	ca		dex				dex
.0acc	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp0 and zTemp1
.0ace	85 2c		sta $2c				sta 	zTemp0
.0ad0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0ad2	85 2d		sta $2d				sta 	zTemp0+1
.0ad4	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.0ad6	85 2e		sta $2e				sta 	zTemp1
.0ad8	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.0ada	85 2f		sta $2f				sta 	zTemp1+1
.0adc	da		phx				phx
.0add	5a		phy				phy
.0ade	b2 2c		lda ($2c)			lda 	(zTemp0)					; work out number to compare
.0ae0	d2 2e		cmp ($2e)			cmp 	(zTemp1)
.0ae2	90 02		bcc $0ae6			bcc 	_CSNIsSmallest 				; as min(len(s1),len(s2))
.0ae4	b2 2e		lda ($2e)			lda 	(zTemp1)
.0ae6					_CSNIsSmallest:
.0ae6	aa		tax				tax 								; count in X
.0ae7	f0 0c		beq $0af5			beq 	_CSNMatches 				; if zero already matches as far as we can go.
.0ae9	a0 00		ldy #$00			ldy 	#0 							; start from offset 1
.0aeb					_CSNCompareString:
.0aeb	c8		iny				iny 								; pre increment
.0aec	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0aee	d1 2e		cmp ($2e),y			cmp 	(zTemp1),y
.0af0	d0 0a		bne $0afc			bne 	_CSNDifferent 				; numbers are different.
.0af2	ca		dex				dex
.0af3	d0 f6		bne $0aeb			bne 	_CSNCompareString 			; compare common characters in two strings.
.0af5					_CSNMatches:
.0af5	38		sec				sec
.0af6	b2 2c		lda ($2c)			lda 	(zTemp0)					; compare lengths
.0af8	f2 2e		sbc ($2e)			sbc 	(zTemp1)
.0afa	f0 06		beq $0b02			beq 	_CSNSExit 					; if zero, then strings match and exit.
.0afc					_CSNDifferent:
.0afc	a9 ff		lda #$ff			lda 	#$FF
.0afe	90 02		bcc $0b02			bcc 	_CSNSExit
.0b00	a9 01		lda #$01			lda 	#$01
.0b02					_CSNSExit:
.0b02	7a		ply				ply
.0b03	fa		plx				plx
.0b04	c9 00		cmp #$00			cmp 	#0 							; set the flags.
.0b06	20 76 26	jsr $2676			jsr 	FloatSetByte 				; output the byte
.0b09	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b0c					StringConcrete:
.0b0c	9c 6a 05	stz $056a			stz 	stringInitialised	 		; initialise next usage
.0b0f	84 31		sty $31				sty 	zTemp2+1 					; save pointer to new string
.0b11	85 30		sta $30				sta 	zTemp2
.0b13	b2 30		lda ($30)			lda 	(zTemp2) 					; length required
.0b15	4a		lsr a				lsr 	a 							; allow half as much for expansion.
.0b16	18		clc				clc
.0b17	72 30		adc ($30)			adc 	(zTemp2)
.0b19	90 02		bcc $0b1d			bcc 	_SCNoOverflow
.0b1b	a9 ff		lda #$ff			lda 	#255
.0b1d					_SCNoOverflow:
.0b1d	c9 0a		cmp #$0a			cmp 	#10 						; and a minimum of 10
.0b1f	b0 02		bcs $0b23			bcs 	_SCNoMinimum
.0b21	a9 0a		lda #$0a			lda 	#10
.0b23					_SCNoMinimum:
.0b23	85 2e		sta $2e				sta 	zTemp1 						; save max length.
.0b25	38		sec				sec
.0b26	ad 02 04	lda $0402			lda		stringHighMemory 			; subtract max length from high memory.
.0b29	e5 2e		sbc $2e				sbc 	zTemp1
.0b2b	a8		tay				tay
.0b2c	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0b2f	e9 00		sbc #$00			sbc 	#0
.0b31	48		pha				pha
.0b32	38		sec				sec 								; subtract 3 more
.0b33	98		tya				tya
.0b34	e9 03		sbc #$03			sbc 	#3
.0b36	8d 02 04	sta $0402			sta 	stringHighMemory 			; to string high memory/zsTemp
.0b39	85 22		sta $22				sta 	zsTemp
.0b3b	68		pla				pla
.0b3c	e9 00		sbc #$00			sbc 	#0
.0b3e	8d 03 04	sta $0403			sta 	stringHighMemory+1
.0b41	85 23		sta $23				sta 	zsTemp+1
.0b43	a5 2e		lda $2e				lda 	zTemp1 						; set max length.
.0b45	92 22		sta ($22)			sta 	(zsTemp)
.0b47	a0 01		ldy #$01			ldy 	#1 							; clear control byte.
.0b49	a9 00		lda #$00			lda 	#0
.0b4b	91 22		sta ($22),y			sta 	(zsTemp),y
.0b4d	a5 22		lda $22				lda 	zsTemp 						; new empty string in YA.
.0b4f	a4 23		ldy $23				ldy 	zsTemp+1
.0b51	60		rts				rts
.0b52					CommandXData:
.0b52	fa		plx				plx
.0b53	98		tya				tya 								; data length +1 added to Y
.0b54	38		sec				sec
.0b55	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.0b57	a8		tay				tay
.0b58	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b5b					CommandXDIM:
.0b5b	fa		plx				plx
.0b5c	5a		phy				phy
.0b5d	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the type we are building for (bits 6 & 5)
.0b60	8d 0a 04	sta $040a			sta 	dimType
.0b63	ca		dex				dex 								; this is the number of indices
.0b64	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0b67	85 2e		sta $2e				sta 	zTemp1 						; subtract n from X so X points at the *first*
.0b69	8a		txa				txa 								; dimension.
.0b6a	38		sec				sec
.0b6b	e5 2e		sbc $2e				sbc 	zTemp1
.0b6d	aa		tax				tax
.0b6e	a5 2e		lda $2e				lda 	zTemp1 						; number of indices.
.0b70	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create one at this level
.0b73	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; set it as a return address as an integer
.0b75	98		tya				tya
.0b76	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0b78	74 56		stz $56,x			stz 	NSMantissa2,x
.0b7a	74 62		stz $62,x			stz 	NSMantissa3,x
.0b7c	74 32		stz $32,x			stz 	NSStatus,x
.0b7e	74 6e		stz $6e,x			stz 	NSExponent,x
.0b80	7a		ply				ply
.0b81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0b84					DIMCreateOneLevel:
.0b84	a4 26		ldy $26				ldy 	availableMemory 			; push the start of this block on the stack.
.0b86	5a		phy				phy
.0b87	a4 27		ldy $27				ldy 	availableMemory+1
.0b89	5a		phy				phy
.0b8a	a8		tay				tay 			 					; save current level into Y
.0b8b	20 47 10	jsr $1047			jsr		GetInteger16Bit 			; size of dimension to zTemp0
.0b8e	e6 2c		inc $2c				inc 	zTemp0 						; bump the size of the dimension as we need one more
.0b90	d0 02		bne $0b94			bne 	_DCOLNoCarry
.0b92	e6 2d		inc $2d				inc 	zTemp0+1
.0b94					_DCOLNoCarry:
.0b94	a5 2c		lda $2c				lda 	zTemp0 						; write out the +1 size of the dimension
.0b96	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b99	a5 2d		lda $2d				lda 	zTemp0+1
.0b9b	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0b9e	ad 0a 04	lda $040a			lda 	dimType 					; get type information
.0ba1	29 7f		and #$7f			and 	#$7F
.0ba3	c0 01		cpy #$01			cpy 	#1
.0ba5	f0 02		beq $0ba9			beq 	_DCOLNoSubLevel
.0ba7	09 80		ora #$80			ora 	#$80 						; set sublevel bit if there is one.
.0ba9					_DCOLNoSubLevel:
.0ba9	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0bac	a5 26		lda $26				lda 	availableMemory
.0bae	85 2e		sta $2e				sta 	zTemp1
.0bb0	a5 27		lda $27				lda 	availableMemory+1
.0bb2	85 2f		sta $2f				sta 	zTemp1+1
.0bb4	a5 2c		lda $2c				lda 	zTemp0
.0bb6	85 30		sta $30				sta 	zTemp2
.0bb8	a5 2d		lda $2d				lda 	zTemp0+1
.0bba	85 31		sta $31				sta 	zTemp2+1
.0bbc					_DCOLFillArray:
.0bbc	20 1b 0c	jsr $0c1b			jsr 	DIMWriteElement 			; write out an element, could be a sub-level or individual data
.0bbf	a5 2c		lda $2c				lda 	zTemp0 						; decrement one from count.
.0bc1	d0 02		bne $0bc5			bne 	_DCOLNoBorrow
.0bc3	c6 2d		dec $2d				dec 	zTemp0+1
.0bc5					_DCOLNoBorrow:
.0bc5	c6 2c		dec $2c				dec 	zTemp0
.0bc7	a5 2c		lda $2c				lda 	zTemp0 						; until completed.
.0bc9	05 2d		ora $2d				ora 	zTemp0+1
.0bcb	d0 ef		bne $0bbc			bne 	_DCOLFillArray
.0bcd	c0 01		cpy #$01			cpy 	#1
.0bcf	f0 42		beq $0c13			beq 	_DCOLExit
.0bd1					_DCOLRecursionLoop:
.0bd1	da		phx				phx 								; save XY
.0bd2	5a		phy				phy
.0bd3	a5 2e		lda $2e				lda 	zTemp1 						; push zTemp1 (position) zTemp2 (count)
.0bd5	48		pha				pha
.0bd6	a5 2f		lda $2f				lda 	zTemp1+1
.0bd8	48		pha				pha
.0bd9	a5 30		lda $30				lda 	zTemp2
.0bdb	48		pha				pha
.0bdc	a5 31		lda $31				lda 	zTemp2+1
.0bde	48		pha				pha
.0bdf	88		dey				dey  								; lower level -> A
.0be0	98		tya				tya
.0be1	e8		inx				inx 								; next index size
.0be2	20 84 0b	jsr $0b84			jsr 	DIMCreateOneLevel 			; create a level, return in YA
.0be5	fa		plx				plx 								; restore zTemp2 (count) and zTemp1 (position)
.0be6	86 31		stx $31				stx 	zTemp2+1
.0be8	fa		plx				plx
.0be9	86 30		stx $30				stx 	zTemp2
.0beb	fa		plx				plx
.0bec	86 2f		stx $2f				stx 	zTemp1+1
.0bee	fa		plx				plx
.0bef	86 2e		stx $2e				stx 	zTemp1
.0bf1	92 2e		sta ($2e)			sta 	(zTemp1) 					; write out position
.0bf3	98		tya				tya
.0bf4	a0 01		ldy #$01			ldy 	#1
.0bf6	91 2e		sta ($2e),y			sta 	(zTemp1),y
.0bf8	7a		ply				ply 								; restore XY
.0bf9	fa		plx				plx
.0bfa	18		clc				clc
.0bfb	a5 2e		lda $2e				lda 	zTemp1 						; add 2 to zTemp1
.0bfd	69 02		adc #$02			adc 	#2
.0bff	85 2e		sta $2e				sta 	zTemp1
.0c01	90 02		bcc $0c05			bcc 	_DCOLRNoCarry
.0c03	e6 2f		inc $2f				inc 	zTemp1+1
.0c05					_DCOLRNoCarry:
.0c05	a5 30		lda $30				lda 	zTemp2 						; decrement one from count in zTemp2
.0c07	d0 02		bne $0c0b			bne 	_DCOLRNoBorrow
.0c09	c6 31		dec $31				dec 	zTemp2+1
.0c0b					_DCOLRNoBorrow:
.0c0b	c6 30		dec $30				dec 	zTemp2
.0c0d	a5 30		lda $30				lda 	zTemp2 						; until completed.
.0c0f	05 31		ora $31				ora 	zTemp2+1
.0c11	d0 be		bne $0bd1			bne 	_DCOLRecursionLoop
.0c13					_DCOLExit:
.0c13	68		pla				pla 								; get MSB, make offset again
.0c14	38		sec				sec
.0c15	ed 07 04	sbc $0407			sbc 	variableStartPage
.0c18	a8		tay				tay
.0c19	68		pla				pla 								; YA now contains offset address.
.0c1a	60		rts				rts
.0c1b					DIMWriteElement:
.0c1b	da		phx				phx
.0c1c	a2 02		ldx #$02			ldx	 	#2 							; work out size is 2 or 6
.0c1e	c0 01		cpy #$01			cpy 	#1 							; do we have a sub level, if so 2.
.0c20	d0 0b		bne $0c2d			bne 	_DIMWENotFloat
.0c22	ad 0a 04	lda $040a			lda 	dimType
.0c25	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.0c27	c9 00		cmp #$00			cmp 	#NSSIFloat
.0c29	d0 02		bne $0c2d			bne 	_DIMWENotFloat
.0c2b	a2 06		ldx #$06			ldx 	#6
.0c2d					_DIMWENotFloat:
.0c2d	a9 00		lda #$00			lda 	#0
.0c2f	20 37 0c	jsr $0c37			jsr 	DIMWriteByte
.0c32	ca		dex				dex
.0c33	d0 f8		bne $0c2d			bne 	_DIMWENotFloat
.0c35	fa		plx				plx
.0c36	60		rts				rts
.0c37					DIMWriteByte:
.0c37	92 26		sta ($26)			sta 	(availableMemory)
.0c39	e6 26		inc $26				inc 	availableMemory
.0c3b	d0 0b		bne $0c48			bne 	_DIMWBSkip
.0c3d	e6 27		inc $27				inc 	availableMemory+1
.0c3f	48		pha				pha
.0c40	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.0c42	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.0c45	b0 02		bcs $0c49			bcs 	_DIMWBMemory
.0c47	68		pla				pla
.0c48					_DIMWBSkip:
.0c48	60		rts				rts
.0c49					_DIMWBMemory:
.0c49	4c 0a 20	jmp $200a		jmp	ErrorV_memory
.040a					dimType:
>040a							.fill 	1
.0c4c					CommandEnd:
.0c4c	fa		plx				plx
.0c4d	86 2c		stx $2c				stx 	zTemp0
.0c4f	18		clc				clc 								; exited okay.
.0c50					EndRuntime:
.0c50	ae 08 04	ldx $0408			ldx 	Runtime6502SP 				; set up the stack pointer
.0c53	9a		txs				txs
.0c54	60		rts				rts
.0c55					Unimplemented:
.0c55	4c 3d 1f	jmp $1f3d			jmp 	ErrorV_unimplemented
.0c58					RuntimeErrorHandler:
.0c58	98		tya				tya
.0c59	18		clc				clc
.0c5a	65 28		adc $28				adc 	codePtr
.0c5c	85 28		sta $28				sta 	codePtr
.0c5e	90 02		bcc $0c62			bcc 	_EHNoCarry
.0c60	e6 29		inc $29				inc 	codePtr+1
.0c62					_EHNoCarry:
.0c62	68		pla				pla
.0c63	7a		ply				ply
.0c64	85 2c		sta $2c				sta 	zTemp0
.0c66	84 2d		sty $2d				sty 	zTemp0+1
.0c68	a2 00		ldx #$00			ldx 	#0 							; output to channel #0
.0c6a	a0 01		ldy #$01			ldy 	#1
.0c6c					_EHDisplayMsg:
.0c6c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c6e	20 9d 1c	jsr $1c9d			jsr 	XPrintCharacterToChannel
.0c71	c8		iny				iny
.0c72	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.0c74	d0 f6		bne $0c6c			bne 	_EHDisplayMsg
.0c76	a9 20		lda #$20			lda 	#32
.0c78	20 9d 1c	jsr $1c9d			jsr 	XPrintCharacterToChannel
.0c7b	a9 40		lda #$40			lda 	#64
.0c7d	20 9d 1c	jsr $1c9d			jsr 	XPrintCharacterToChannel
.0c80	a9 20		lda #$20			lda 	#32
.0c82	20 9d 1c	jsr $1c9d			jsr 	XPrintCharacterToChannel
.0c85	20 8c 0c	jsr $0c8c			jsr 	EHDisplayCodePtr
.0c88	38		sec				sec 								; report error.
.0c89	4c 50 0c	jmp $0c50			jmp 	EndRuntime
.0c8c					EHDisplayCodePtr:
.0c8c	a9 24		lda #$24			lda 	#'$'
.0c8e	20 9d 1c	jsr $1c9d			jsr 	XPrintCharacterToChannel
.0c91	38		sec				sec
.0c92	a5 29		lda $29				lda 	codePtr+1 					; display the p-code address of the error.
.0c94	ed 04 04	sbc $0404			sbc 	runtimeHigh
.0c97	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9a	a5 28		lda $28				lda 	codePtr
.0c9c	20 a0 0c	jsr $0ca0			jsr 	_EHDisplayHex
.0c9f	60		rts				rts
.0ca0					_EHDisplayHex:
.0ca0	48		pha				pha
.0ca1	4a		lsr a				lsr 	a
.0ca2	4a		lsr a				lsr 	a
.0ca3	4a		lsr a				lsr 	a
.0ca4	4a		lsr a				lsr 	a
.0ca5	20 a9 0c	jsr $0ca9			jsr 	_EHDisplayNibble
.0ca8	68		pla				pla
.0ca9					_EHDisplayNibble:
.0ca9	29 0f		and #$0f			and 	#15
.0cab	c9 0a		cmp #$0a			cmp 	#10
.0cad	90 02		bcc $0cb1			bcc 	_EHNotHex
.0caf	69 06		adc #$06			adc 	#6
.0cb1					_EHNotHex:
.0cb1	69 30		adc #$30			adc 	#48
.0cb3	4c 9d 1c	jmp $1c9d			jmp 	XPrintCharacterToChannel
.0cb6					CommandXFor:
.0cb6	fa		plx				plx
.0cb7	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; open frame
.0cb9	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0cbc	20 78 11	jsr $1178			jsr 	StackSaveCurrentPosition 	; normalise to Y=0 and save position.
.0cbf	a0 07		ldy #$07			ldy 	#7 							; copy step out
.0cc1	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cc4	ca		dex				dex
.0cc5	a0 0d		ldy #$0d			ldy 	#13 						; copy terminal value.
.0cc7	20 1b 0d	jsr $0d1b			jsr 	CopyTOSToOffsetY
.0cca	ca		dex				dex
.0ccb	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; bit 15 of reference indicates type int16
.0ccd	29 80		and #$80			and 	#$80
.0ccf	a0 04		ldy #$04			ldy 	#4
.0cd1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd3	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy the reference address
.0cd5	a0 05		ldy #$05			ldy 	#5 							; adjusted to be a real address
.0cd7	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0cd9	85 2c		sta $2c				sta 	zTemp0 						; also to zTemp0
.0cdb	c8		iny				iny
.0cdc	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0cde	18		clc				clc
.0cdf	29 7f		and #$7f			and 	#$7F 						; throw the type bit.
.0ce1	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0ce3	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.0ce6	85 2d		sta $2d				sta 	zTemp0+1
.0ce8	ca		dex				dex 								; throw reference.
.0ce9	a0 05		ldy #$05			ldy 	#5 							; check the index, step and terminal values
.0ceb	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; are all +ve integers, sign bits first.
.0ced	a0 0c		ldy #$0c			ldy 	#12
.0cef	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf1	a0 12		ldy #$12			ldy 	#18
.0cf3	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cf5	29 80		and #$80			and 	#$80 						; only interested in sign bit.
.0cf7	88		dey				dey 								; now the exponents.
.0cf8	11 2c		ora ($2c),y			ora 	(zTemp0),y
.0cfa	a0 0b		ldy #$0b			ldy 	#11
.0cfc	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0cfe	a0 11		ldy #$11			ldy 	#17
.0d00	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d02	a0 08		ldy #$08			ldy 	#8 							; step must be 1 byte.
.0d04	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d06	c8		iny				iny
.0d07	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d09	c8		iny				iny
.0d0a	11 24		ora ($24),y			ora 	(runtimeStackPtr),y
.0d0c	d0 08		bne $0d16			bne 	_CFNoOptimise
.0d0e	a0 04		ldy #$04			ldy 	#4 							; set the runtime stack pointer optimisation flag.
.0d10	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.0d12	09 40		ora #$40			ora 	#$40
.0d14	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d16					_CFNoOptimise:
.0d16	a0 00		ldy #$00			ldy 	#0
.0d18	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d1b					CopyTOSToOffsetY:
.0d1b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0d1d	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d1f	c8		iny				iny
.0d20	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0d22	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d24	c8		iny				iny
.0d25	b5 56		lda $56,x			lda 	NSMantissa2,x
.0d27	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d29	c8		iny				iny
.0d2a	b5 62		lda $62,x			lda 	NSMantissa3,x
.0d2c	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d2e	c8		iny				iny
.0d2f	b5 6e		lda $6e,x			lda 	NSExponent,x
.0d31	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d33	c8		iny				iny
.0d34	b5 32		lda $32,x			lda 	NSStatus,x
.0d36	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.0d38	60		rts				rts
.0d39					StackOpenFrame:
.0d39	48		pha				pha 								; save frame marker
.0d3a	29 1f		and #$1f			and 	#$1F 						; bytes required.
.0d3c	85 2c		sta $2c				sta 	zTemp0
.0d3e	38		sec				sec 								; subtract from runtime stack pointer.
.0d3f	a5 24		lda $24				lda		runtimeStackPtr
.0d41	e5 2c		sbc $2c				sbc 	zTemp0
.0d43	85 24		sta $24				sta 	runtimeStackPtr
.0d45	a5 25		lda $25				lda		runtimeStackPtr+1
.0d47	e9 00		sbc #$00			sbc 	#0
.0d49	85 25		sta $25				sta 	runtimeStackPtr+1
.0d4b	68		pla				pla 								; put frame marker at +0
.0d4c	92 24		sta ($24)			sta 	(runtimeStackPtr)
.0d4e	60		rts				rts
.0d4f					StackCloseFrame:
.0d4f	b2 24		lda ($24)			lda 	(runtimeStackPtr)			; get frame marker
.0d51	29 1f		and #$1f			and 	#$1F 						; size
.0d53	18		clc				clc
.0d54	65 24		adc $24				adc 	runtimeStackPtr
.0d56	85 24		sta $24				sta 	runtimeStackPtr
.0d58	90 02		bcc $0d5c			bcc 	_SCFNoCarry
.0d5a	e6 25		inc $25				inc 	runtimeStackPtr+1
.0d5c					_SCFNoCarry:
.0d5c	60		rts				rts
.0d5d					StackFindFrame:
.0d5d	8d 0b 04	sta $040b			sta 	requiredFrame
.0d60					_SFFLoop:
.0d60	b2 24		lda ($24)			lda 	(runtimeStackPtr) 			; get TOS
.0d62	c9 ff		cmp #$ff			cmp 	#$FF 						; if found $FF then this is a fail.
.0d64	f0 10		beq $0d76			beq 	SCFFail
.0d66	cd 0b 04	cmp $040b			cmp 	requiredFrame 				; found this type ?
.0d69	f0 05		beq $0d70			beq 	_SFFFound
.0d6b	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close the top frame
.0d6e	80 f0		bra $0d60			bra 	_SFFLoop 					; and try te next.
.0d70					_SFFFound:
.0d70	60		rts				rts
.0d71					StackCheckFrame:
.0d71	d2 24		cmp ($24)			cmp 	(runtimeStackPtr) 			; matches current frame
.0d73	d0 01		bne $0d76			bne 	SCFFail
.0d75	60		rts				rts
.0d76					SCFFail:
.0d76	4c 9a 1f	jmp $1f9a		jmp	ErrorV_structure
.040b					requiredFrame:
>040b							.fill 	1
.0d79					UnaryFre:
.0d79	fa		plx				plx
.0d7a	20 74 26	jsr $2674			jsr 	FloatSetZero 				; zero the result (32 bit integer)
.0d7d	38		sec				sec
.0d7e	ad 02 04	lda $0402			lda 	stringHighMemory 			; calculate the free memory.
.0d81	ed 00 04	sbc $0400			sbc 	stringLowMemory
.0d84	95 3e		sta $3e,x			sta		NSMantissa0,x
.0d86	ad 03 04	lda $0403			lda 	stringHighMemory+1
.0d89	ed 01 04	sbc $0401			sbc 	stringLowMemory+1
.0d8c	95 4a		sta $4a,x			sta		NSMantissa1,x
.0d8e	4c 4f 08	jmp $084f			jmp 	NextCommand
.0d91					CommandXGet:
.0d91	fa		plx				plx
.0d92	e8		inx				inx
.0d93	a9 01		lda #$01			lda 	#1 							; 1 character space
.0d95	20 1b 17	jsr $171b			jsr 	StringAllocTemp
.0d98	20 81 13	jsr $1381			jsr 	VectorGetCharacter 			; get a character
.0d9b	c9 00		cmp #$00			cmp 	#0
.0d9d	f0 09		beq $0da8			beq 	_CGNone
.0d9f	5a		phy				phy
.0da0	a0 01		ldy #$01			ldy 	#1 							; store char
.0da2	91 22		sta ($22),y			sta 	(zsTemp),y
.0da4	98		tya				tya 								; store length.
.0da5	92 22		sta ($22)			sta 	(zsTemp)
.0da7	7a		ply				ply
.0da8					_CGNone:
.0da8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dab					CommandXGosub:
.0dab	fa		plx				plx
.0dac	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dae	20 39 0d	jsr $0d39			jsr 	StackOpenFrame
.0db1	20 78 11	jsr $1178			jsr 	StackSaveCurrentPosition
.0db4	4c c9 0d	jmp $0dc9			jmp 	PerformGOTO
.0db7					CommandReturn:
.0db7	fa		plx				plx
.0db8	a9 e4		lda #$e4			lda 	#FRAME_GOSUB
.0dba	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.0dbd	20 89 11	jsr $1189			jsr 	StackLoadCurrentPosition
.0dc0	c8		iny				iny
.0dc1	c8		iny				iny
.0dc2	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame
.0dc5	4c 4f 08	jmp $084f			jmp 	NextCommand
.0dc8					CommandXGoto:
.0dc8	fa		plx				plx
.0dc9					PerformGOTO:
.0dc9	c8		iny				iny 								; push MSB of offset on stack
.0dca	b1 28		lda ($28),y			lda 	(codePtr),y
.0dcc	48		pha				pha
.0dcd	88		dey				dey 								; point LSB of offset
.0dce	18		clc				clc 								; add LSB
.0dcf	b1 28		lda ($28),y			lda 	(codePtr),y
.0dd1	65 28		adc $28				adc 	codePtr
.0dd3	85 28		sta $28				sta 	codePtr
.0dd5	68		pla				pla 								; restore offset MSB and add
.0dd6	65 29		adc $29				adc 	codePtr+1
.0dd8	85 29		sta $29				sta 	codePtr+1
.0dda	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ddd					CommandGotoZ:
.0ddd	fa		plx				plx
.0dde	20 96 26	jsr $2696			jsr 	FloatIsZero
.0de1	ca		dex				dex
.0de2	c9 00		cmp #$00			cmp 	#0
.0de4	f0 e3		beq $0dc9			beq 	PerformGOTO
.0de6	c8		iny				iny
.0de7	c8		iny				iny
.0de8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0deb					CommandGotoNZ:
.0deb	fa		plx				plx
.0dec	20 96 26	jsr $2696			jsr 	FloatIsZero
.0def	ca		dex				dex
.0df0	c9 00		cmp #$00			cmp 	#0
.0df2	d0 d5		bne $0dc9			bne 	PerformGOTO
.0df4	c8		iny				iny
.0df5	c8		iny				iny
.0df6	4c 4f 08	jmp $084f			jmp 	NextCommand
.0df9					Command_PSET:
.0df9	fa		plx				plx
.0dfa	5a		phy				phy
.0dfb	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the colour
.0dfe	48		pha				pha
.0dff	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e01	a0 02		ldy #$02			ldy 	#X16_r0
.0e03	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e06	20 ff fe	jsr $feff			jsr 	X16_FB_cursor_position 		; set position.
.0e09	68		pla				pla 								; set pixel.
.0e0a	20 0b ff	jsr $ff0b			jsr 	X16_FB_set_pixel
.0e0d	7a		ply				ply
.0e0e	a2 ff		ldx #$ff			ldx 	#$FF
.0e10	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e13					Command_LINE:
.0e13	fa		plx				plx
.0e14	5a		phy				phy
.0e15	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e18	a2 00		ldx #$00			ldx 	#0 							; copy 0/1/2/3 to r0,1,2,3
.0e1a	a0 02		ldy #$02			ldy 	#X16_r0
.0e1c	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0e1f	20 2c ff	jsr $ff2c			jsr 	X16_GRAPH_draw_line
.0e22	7a		ply				ply
.0e23	a2 ff		ldx #$ff			ldx 	#$FF
.0e25	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e28					Command_RECT:
.0e28	fa		plx				plx
.0e29	5a		phy				phy
.0e2a	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e2d	38		sec				sec
.0e2e	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e31	7a		ply				ply
.0e32	a2 ff		ldx #$ff			ldx 	#$FF
.0e34	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e37					Command_FRAME:
.0e37	fa		plx				plx
.0e38	5a		phy				phy
.0e39	20 99 0e	jsr $0e99			jsr 	GraphicsRectCoords
.0e3c	18		clc				clc
.0e3d	20 2f ff	jsr $ff2f			jsr 	X16_GRAPH_draw_rect
.0e40	7a		ply				ply
.0e41	a2 ff		ldx #$ff			ldx 	#$FF
.0e43	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e46					Command_CHAR:
.0e46	fa		plx				plx
.0e47	5a		phy				phy
.0e48	ca		dex				dex  								; set the draw colour
.0e49	20 78 0e	jsr $0e78			jsr 	GraphicsColour
.0e4c	a2 00		ldx #$00			ldx 	#0 							; copy 0/1 to r0,r1
.0e4e	a0 02		ldy #$02			ldy 	#X16_r0
.0e50	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e53	a5 41		lda $41				lda 	NSMantissa0+3 				; copy string address to zTemp0
.0e55	85 2c		sta $2c				sta 	zTemp0
.0e57	a5 4d		lda $4d				lda 	NSMantissa1+3
.0e59	85 2d		sta $2d				sta 	zTemp0+1
.0e5b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; count of chars to zTemp1
.0e5d	85 2e		sta $2e				sta 	zTemp1
.0e5f					_CCLoop:
.0e5f	a5 2e		lda $2e				lda 	zTemp1 						; done all chars ?
.0e61	f0 0f		beq $0e72			beq 	_CCExit
.0e63	c6 2e		dec $2e				dec 	zTemp1 						; dec counter
.0e65	e6 2c		inc $2c				inc 	zTemp0 						; pre-bump pointer
.0e67	d0 02		bne $0e6b			bne 	_CCNoCarry
.0e69	e6 2d		inc $2d				inc 	zTemp0+1
.0e6b					_CCNoCarry:
.0e6b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get character
.0e6d	20 41 ff	jsr $ff41			jsr 	X16_GRAPH_put_char 			; write it
.0e70	80 ed		bra $0e5f			bra 	_CCLoop						; go round.
.0e72					_CCExit:
.0e72	7a		ply				ply
.0e73	a2 ff		ldx #$ff			ldx 	#$FF
.0e75	4c 4f 08	jmp $084f			jmp 	NextCommand
.0e78					GraphicsColour:
.0e78	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.0e7b	aa		tax				tax
.0e7c	a0 00		ldy #$00			ldy 	#0
.0e7e	20 29 ff	jsr $ff29			jsr 	X16_GRAPH_set_colors
.0e81	60		rts				rts
.0e82					GraphicsCopy4:
.0e82	20 85 0e	jsr $0e85			jsr 	GraphicsCopy2
.0e85					GraphicsCopy2:
.0e85	20 88 0e	jsr $0e88			jsr 	GraphicsCopy1
.0e88					GraphicsCopy1:
.0e88	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.0e8b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.0e8d	99 00 00	sta $0000,y			sta 	0,y
.0e90	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0e92	99 01 00	sta $0001,y			sta 	1,y
.0e95	e8		inx				inx
.0e96	c8		iny				iny
.0e97	c8		iny				iny
.0e98	60		rts				rts
.0e99					GraphicsRectCoords:
.0e99	20 78 0e	jsr $0e78			jsr 	GraphicsColour 				; set colour
.0e9c	a2 00		ldx #$00			ldx 	#0 							; copy in order.
.0e9e	a0 02		ldy #$02			ldy 	#X16_r0
.0ea0	20 82 0e	jsr $0e82			jsr 	GraphicsCopy4
.0ea3	a2 02		ldx #$02			ldx 	#X16_r0 					; sort r0/r2
.0ea5	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ea8	a2 04		ldx #$04			ldx 	#X16_r1 					; sort r1/r3
.0eaa	20 b2 0e	jsr $0eb2			jsr 	_GRCSortSubtract
.0ead	74 08		stz $08,x			stz 	8,x 						; zero rounding
.0eaf	74 09		stz $09,x			stz 	9,x
.0eb1	60		rts				rts
.0eb2					_GRCSortSubtract:
.0eb2	b5 04		lda $04,x			lda 	4,x 						; calculate r2-r0
.0eb4	d5 00		cmp $00,x			cmp 	0,x
.0eb6	b5 05		lda $05,x			lda 	5,x
.0eb8	f5 01		sbc $01,x			sbc 	1,x
.0eba	b0 08		bcs $0ec4			bcs 	_GRCNoSwap 					; >= swap.
.0ebc	20 d2 0e	jsr $0ed2			jsr 	_GRCSwapByte 				; swap 0/2
.0ebf	e8		inx				inx
.0ec0	20 d2 0e	jsr $0ed2			jsr 	_GRCSwapByte 				; swap 1/3
.0ec3	ca		dex				dex
.0ec4					_GRCNoSwap:
.0ec4	38		sec				sec 								; calculate width/height into 4,5
.0ec5	b5 04		lda $04,x			lda 	4,x
.0ec7	f5 00		sbc $00,x			sbc 	0,x
.0ec9	95 04		sta $04,x			sta 	4,x
.0ecb	b5 05		lda $05,x			lda 	5,x
.0ecd	f5 01		sbc $01,x			sbc 	1,x
.0ecf	95 05		sta $05,x			sta 	5,x
.0ed1	60		rts				rts
.0ed2					_GRCSwapByte:
.0ed2	b5 04		lda $04,x			lda 	4,x
.0ed4	48		pha				pha
.0ed5	b5 00		lda $00,x			lda 	0,x
.0ed7	95 04		sta $04,x			sta 	4,x
.0ed9	68		pla				pla
.0eda	95 00		sta $00,x			sta 	0,x
.0edc	60		rts				rts
.0edd					Unary16Hex:
.0edd	fa		plx				plx
.0ede	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.0ee1	a9 04		lda #$04			lda 	#4 							; allocate / set 4 bytes.
.0ee3	20 1b 17	jsr $171b			jsr 	StringAllocTemp
.0ee6	a5 2d		lda $2d				lda 	zTemp0+1
.0ee8	f0 03		beq $0eed			beq 	_UHNoHigh
.0eea	20 f5 0e	jsr $0ef5			jsr 	_UHWriteHex
.0eed					_UHNoHigh:
.0eed	a5 2c		lda $2c				lda 	zTemp0
.0eef	20 f5 0e	jsr $0ef5			jsr 	_UHWriteHex
.0ef2	4c 4f 08	jmp $084f			jmp 	NextCommand
.0ef5					_UHWriteHex:
.0ef5	48		pha				pha
.0ef6	4a		lsr a				lsr 	a
.0ef7	4a		lsr a				lsr 	a
.0ef8	4a		lsr a				lsr 	a
.0ef9	4a		lsr a				lsr 	a
.0efa	20 fe 0e	jsr $0efe			jsr 	_UHWriteNibl
.0efd	68		pla				pla
.0efe					_UHWriteNibl:
.0efe	29 0f		and #$0f			and 	#15
.0f00	c9 0a		cmp #$0a			cmp 	#10
.0f02	90 02		bcc $0f06			bcc 	_UHDigit
.0f04	69 06		adc #$06			adc 	#6
.0f06					_UHDigit:
.0f06	69 30		adc #$30			adc 	#48
.0f08	20 44 17	jsr $1744			jsr 	StringWriteChar
.0f0b	60		rts				rts
.0f0c					IndFloatRead:
.0f0c	fa		plx				plx
.0f0d	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f0f	85 2c		sta $2c				sta 	zTemp0
.0f11	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f13	18		clc				clc
.0f14	6d 07 04	adc $0407			adc 	variableStartPage
.0f17	85 2d		sta $2d				sta 	zTemp0+1
.0f19	ca		dex				dex 								; throw the address
.0f1a	20 fa 14	jsr $14fa			jsr 	ReadFloatZTemp0Sub 							; call read routine
.0f1d	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f20					IndInt16Read:
.0f20	fa		plx				plx
.0f21	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f23	85 2c		sta $2c				sta 	zTemp0
.0f25	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f27	18		clc				clc
.0f28	6d 07 04	adc $0407			adc 	variableStartPage
.0f2b	85 2d		sta $2d				sta 	zTemp0+1
.0f2d	ca		dex				dex 								; throw the address
.0f2e	20 36 15	jsr $1536			jsr 	ReadIntegerZTemp0Sub 							; call read routine
.0f31	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f34					IndStringRead:
.0f34	fa		plx				plx
.0f35	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy address
.0f37	85 2c		sta $2c				sta 	zTemp0
.0f39	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.0f3b	18		clc				clc
.0f3c	6d 07 04	adc $0407			adc 	variableStartPage
.0f3f	85 2d		sta $2d				sta 	zTemp0+1
.0f41	ca		dex				dex 								; throw the address
.0f42	20 7b 15	jsr $157b			jsr 	ReadStringZTemp0Sub 							; call read routine
.0f45	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f48					IndFloatWrite:
.0f48	fa		plx				plx
.0f49	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f4b	85 2c		sta $2c				sta 	zTemp0
.0f4d	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f4f	18		clc				clc
.0f50	6d 07 04	adc $0407			adc 	variableStartPage
.0f53	85 2d		sta $2d				sta 	zTemp0+1
.0f55	20 d9 1a	jsr $1ad9			jsr 	WriteFloatZTemp0Sub 							; call write routine
.0f58	ca		dex				dex 								; throw the address as well.
.0f59	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f5c					IndInt16Write:
.0f5c	fa		plx				plx
.0f5d	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f5f	85 2c		sta $2c				sta 	zTemp0
.0f61	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f63	18		clc				clc
.0f64	6d 07 04	adc $0407			adc 	variableStartPage
.0f67	85 2d		sta $2d				sta 	zTemp0+1
.0f69	20 15 1b	jsr $1b15			jsr 	WriteIntegerZTemp0Sub 							; call write routine
.0f6c	ca		dex				dex 								; throw the address as well.
.0f6d	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f70					IndStringWrite:
.0f70	fa		plx				plx
.0f71	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x 			; copy address
.0f73	85 2c		sta $2c				sta 	zTemp0
.0f75	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.0f77	18		clc				clc
.0f78	6d 07 04	adc $0407			adc 	variableStartPage
.0f7b	85 2d		sta $2d				sta 	zTemp0+1
.0f7d	20 54 1b	jsr $1b54			jsr 	WriteStringZTemp0Sub 							; call write routine
.0f80	ca		dex				dex 								; throw the address as well.
.0f81	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f84					CommandXInput:
.0f84	fa		plx				plx
.0f85	5a		phy				phy 								; save Y
.0f86	e8		inx				inx									; space on stack
.0f87					_INError:
.0f87	20 bb 0f	jsr $0fbb			jsr 	InputStringToBuffer 		; input from keyboard
.0f8a	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.0f8c	85 2c		sta $2c				sta 	0+zTemp0
.0f8e	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.0f90	85 2d		sta $2d				sta 	1+zTemp0
.0f92	20 62 19	jsr $1962			jsr 	ValEvaluateZTemp0
.0f95	b0 f0		bcs $0f87			bcs 	_INError 					; failed, try again.
.0f97	7a		ply				ply 								; restore Y
.0f98	4c 4f 08	jmp $084f			jmp 	NextCommand
.0f9b					CommandInputString:
.0f9b	fa		plx				plx
.0f9c	5a		phy				phy 								; save Y
.0f9d	20 bb 0f	jsr $0fbb			jsr 	InputStringToBuffer 		; input from keyboard
.0fa0	e8		inx				inx 								; make space on stack
.0fa1	20 74 26	jsr $2674			jsr 	FloatSetZero 				; store as string on stack
.0fa4	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.0fa6	95 3e		sta $3e,x			sta 	NSMantissa0,x
.0fa8	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.0faa	95 4a		sta $4a,x			sta 	NSMantissa1,x
.0fac	a9 40		lda #$40			lda 	#NSSString
.0fae	95 32		sta $32,x			sta 	NSStatus,x
.0fb0	7a		ply				ply 								; restore Y
.0fb1	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fb4					CommandInputReset:
.0fb4	fa		plx				plx
.0fb5	9c 0c 04	stz $040c			stz 	InputBuffer
.0fb8	4c 4f 08	jmp $084f			jmp 	NextCommand
.0fbb					InputStringToBuffer:
.0fbb	a9 f5		lda #$f5			lda 	#((InputBumpNext) & $FF)
.0fbd	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.0fc0	a9 0f		lda #$0f			lda 	#((InputBumpNext) >> 8) & $FF
.0fc2	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.0fc5	a9 d2		lda #$d2			lda 	#((InputLookNext) & $FF)
.0fc7	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.0fca	a9 0f		lda #$0f			lda 	#((InputLookNext) >> 8) & $FF
.0fcc	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.0fcf	4c 57 14	jmp $1457			jmp 	GetStringToBuffer
.0fd2					InputLookNext:
.0fd2	da		phx				phx
.0fd3					_ILNRetry:
.0fd3	ad 0c 04	lda $040c			lda 	InputBuffer 				; do we need to read more (e.g. the buffer is empty)
.0fd6	d0 08		bne $0fe0			bne 	_ILNNotEmpty
.0fd8	20 f9 0f	jsr $0ff9			jsr 	InputGetNewLine 			; get a new line
.0fdb	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset read position.
.0fde	80 f3		bra $0fd3			bra 	_ILNRetry
.0fe0					_ILNNotEmpty:
.0fe0	ae 5d 04	ldx $045d			ldx 	InputBufferPos 				; get head available character
.0fe3	bd 0c 04	lda $040c,x			lda 	InputBuffer,x
.0fe6	d0 08		bne $0ff0			bne 	_ILNExit 					; if not EOS return it with CC.
.0fe8					_ILNNextLine:
.0fe8	9c 0c 04	stz $040c			stz 	InputBuffer 				; clear the buffer, indicating new line next time.
.0feb	38		sec				sec 								; return CS,Zero
.0fec	fa		plx				plx
.0fed	a9 0d		lda #$0d			lda 	#13
.0fef	60		rts				rts
.0ff0					_ILNExit:
.0ff0	fa		plx				plx
.0ff1	c9 00		cmp #$00			cmp 	#0 							; return CC, Z Flag set.
.0ff3	18		clc				clc
.0ff4	60		rts				rts
.0ff5					InputBumpNext:
.0ff5	ee 5d 04	inc $045d			inc 	InputBufferPos
.0ff8	60		rts				rts
.0ff9					InputGetNewLine:
.0ff9	48		pha				pha
.0ffa	da		phx				phx
.0ffb	5a		phy				phy
.0ffc	a9 3f		lda #$3f			lda 	#"?"
.0ffe	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.1001	a0 00		ldy #$00			ldy 	#0 							; line position.
.1003					_IGNLLoop:
.1003	20 81 13	jsr $1381			jsr 	VectorGetCharacter 			; get a character
.1006	c9 00		cmp #$00			cmp 	#0
.1008	f0 f9		beq $1003			beq 	_IGNLLoop
.100a	c9 14		cmp #$14			cmp 	#$14 						; Backspace ?
.100c	f0 11		beq $101f			beq 	_IGNBackspace
.100e	c9 0d		cmp #$0d			cmp 	#$0D 						; Return ?
.1010	f0 17		beq $1029			beq 	_IGNExit
.1012	c0 50		cpy #$50			cpy 	#80 						; buffer full ?
.1014	f0 ed		beq $1003			beq 	_IGNLLoop
.1016	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1019	c8		iny				iny
.101a	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.101d	80 e4		bra $1003			bra 	_IGNLLoop
.101f					_IGNBackspace:
.101f	c0 00		cpy #$00			cpy 	#0
.1021	f0 e0		beq $1003			beq 	_IGNLLoop
.1023	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.1026	88		dey				dey
.1027	80 da		bra $1003			bra 	_IGNLLoop
.1029					_IGNExit:
.1029	20 38 10	jsr $1038			jsr 	IGNLEchoIfScreen
.102c	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.102e	99 0c 04	sta $040c,y			sta 	InputBuffer,y
.1031	9c 5d 04	stz $045d			stz 	InputBufferPos 				; reset position to start of input buffer.
.1034	7a		ply				ply
.1035	fa		plx				plx
.1036	68		pla				pla
.1037	60		rts				rts
.1038					IGNLEchoIfScreen:
.1038	ae 5f 04	ldx $045f			ldx 	currentChannel
.103b	d0 03		bne $1040			bne 	_IGNLEExit
.103d	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.1040					_IGNLEExit:
.1040	60		rts				rts
.040c					InputBuffer:
>040c							.fill 	81
.045d					InputBufferPos:
>045d							.fill 	1
.1041					GetInteger8Bit:
.1041	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.1044	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1046	60		rts				rts
.1047					GetInteger16Bit:
.1047	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.104a	34 32		bit $32,x			bit 	NSStatus,x
.104c	30 09		bmi $1057			bmi 	Negate16Bit
.104e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1050	85 2c		sta $2c				sta 	zTemp0
.1052	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1054	85 2d		sta $2d				sta 	zTemp0+1
.1056	60		rts				rts
.1057					Negate16Bit:
.1057	38		sec				sec
.1058	a9 00		lda #$00			lda 	#0
.105a	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.105c	95 3e		sta $3e,x			sta 	NSMantissa0,x
.105e	85 2c		sta $2c				sta 	zTemp0
.1060	a9 00		lda #$00			lda 	#0
.1062	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1064	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1066	85 2d		sta $2d				sta 	zTemp0+1
.1068	60		rts				rts
.1069					UnaryJoy:
.1069	fa		plx				plx
.106a	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; port #
.106d	48		pha				pha 								; zero the result.
.106e	20 74 26	jsr $2674			jsr 	FloatSetZero
.1071	68		pla				pla
.1072	5a		phy				phy
.1073	da		phx				phx
.1074	20 56 ff	jsr $ff56			jsr 	X16_joystick_get 			; read joystick.
.1077	c0 00		cpy #$00			cpy 	#0 							; check no hardware
.1079	d0 10		bne $108b			bne 	_UJNoHardware
.107b	a8		tay				tay 								; move XA -> AY
.107c	8a		txa				txa
.107d	fa		plx				plx 								; we can update it now.
.107e	49 ff		eor #$ff			eor 	#$FF
.1080	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1082	98		tya				tya
.1083	49 ff		eor #$ff			eor 	#$FF
.1085	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1087	7a		ply				ply 								; restore Y
.1088	4c 4f 08	jmp $084f			jmp 	NextCommand
.108b					_UJNoHardware:
.108b	fa		plx				plx
.108c	7a		ply				ply
.108d	a9 01		lda #$01			lda 	#1 							; set result to -1
.108f	20 76 26	jsr $2676			jsr 	FloatSetByte
.1092	20 36 26	jsr $2636			jsr 	FloatNegate
.1095	4c 4f 08	jmp $084f			jmp 	NextCommand
.1098					UnaryLen:
.1098	fa		plx				plx
.1099	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; string address.
.109b	85 2c		sta $2c				sta 	zTemp0
.109d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.109f	85 2d		sta $2d				sta 	zTemp0+1
.10a1	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length
.10a3	20 76 26	jsr $2676			jsr 	FloatSetByte
.10a6	4c 4f 08	jmp $084f			jmp 	NextCommand
.10a9					LinkFloatAdd:
.10a9	fa		plx				plx
.10aa	5a		phy			phy
.10ab	20 98 20	jsr $2098		jsr	FloatAdd
.10ae	7a		ply			ply
.10af	4c 4f 08	jmp $084f			jmp 	NextCommand
.10b2					LinkFloatSubtract:
.10b2	fa		plx				plx
.10b3	5a		phy			phy
.10b4	20 92 20	jsr $2092		jsr	FloatSubtract
.10b7	7a		ply			ply
.10b8	4c 4f 08	jmp $084f			jmp 	NextCommand
.10bb					LinkFloatMultiply:
.10bb	fa		plx				plx
.10bc	5a		phy			phy
.10bd	20 34 23	jsr $2334		jsr	FloatMultiply
.10c0	7a		ply			ply
.10c1	4c 4f 08	jmp $084f			jmp 	NextCommand
.10c4					LinkFloatDivide:
.10c4	fa		plx				plx
.10c5	5a		phy			phy
.10c6	20 bd 21	jsr $21bd		jsr	FloatDivide
.10c9	b0 5c		bcs $1127		bcs	DivZeroError
.10cb	7a		ply			ply
.10cc	4c 4f 08	jmp $084f			jmp 	NextCommand
.10cf					LinkFloatPower:
.10cf	fa		plx				plx
.10d0	5a		phy			phy
.10d1	20 3d 29	jsr $293d		jsr	FloatPower
.10d4	b0 4e		bcs $1124		bcs	MapRangeError
.10d6	7a		ply			ply
.10d7	4c 4f 08	jmp $084f			jmp 	NextCommand
.10da					LinkCompareGreater:
.10da	fa		plx				plx
.10db	5a		phy			phy
.10dc	20 41 21	jsr $2141		jsr	CompareGreater
.10df	7a		ply			ply
.10e0	4c 4f 08	jmp $084f			jmp 	NextCommand
.10e3					LinkCompareEqual:
.10e3	fa		plx				plx
.10e4	5a		phy			phy
.10e5	20 23 21	jsr $2123		jsr	CompareEqual
.10e8	7a		ply			ply
.10e9	4c 4f 08	jmp $084f			jmp 	NextCommand
.10ec					LinkCompareLess:
.10ec	fa		plx				plx
.10ed	5a		phy			phy
.10ee	20 39 21	jsr $2139		jsr	CompareLess
.10f1	7a		ply			ply
.10f2	4c 4f 08	jmp $084f			jmp 	NextCommand
.10f5					LinkCompareGreaterEqual:
.10f5	fa		plx				plx
.10f6	5a		phy			phy
.10f7	20 51 21	jsr $2151		jsr	CompareGreaterEqual
.10fa	7a		ply			ply
.10fb	4c 4f 08	jmp $084f			jmp 	NextCommand
.10fe					LinkCompareNotEqual:
.10fe	fa		plx				plx
.10ff	5a		phy			phy
.1100	20 33 21	jsr $2133		jsr	CompareNotEqual
.1103	7a		ply			ply
.1104	4c 4f 08	jmp $084f			jmp 	NextCommand
.1107					LinkCompareLessEqual:
.1107	fa		plx				plx
.1108	5a		phy			phy
.1109	20 49 21	jsr $2149		jsr	CompareLessEqual
.110c	7a		ply			ply
.110d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1110					LinkFloatIntegerPartDown:
.1110	fa		plx				plx
.1111	5a		phy			phy
.1112	20 d3 22	jsr $22d3		jsr	FloatIntegerPartDown
.1115	7a		ply			ply
.1116	4c 4f 08	jmp $084f			jmp 	NextCommand
.1119					LinkFloatSquareRoot:
.1119	fa		plx				plx
.111a	5a		phy			phy
.111b	20 bf 29	jsr $29bf		jsr	FloatSquareRoot
.111e	b0 04		bcs $1124		bcs	MapRangeError
.1120	7a		ply			ply
.1121	4c 4f 08	jmp $084f			jmp 	NextCommand
.1124					MapRangeError:
.1124	4c ff 1e	jmp $1eff		jmp	ErrorV_range
.1127					DivZeroError:
.1127	4c 88 1f	jmp $1f88		jmp	ErrorV_divzero
.112a					LinkFloatLogarithm:
.112a	fa		plx				plx
.112b	5a		phy			phy
.112c	20 c9 28	jsr $28c9		jsr	FloatLogarithm
.112f	b0 f3		bcs $1124		bcs	MapRangeError
.1131	7a		ply			ply
.1132	4c 4f 08	jmp $084f			jmp 	NextCommand
.1135					LinkFloatExponent:
.1135	fa		plx				plx
.1136	5a		phy			phy
.1137	20 c6 27	jsr $27c6		jsr	FloatExponent
.113a	7a		ply			ply
.113b	4c 4f 08	jmp $084f			jmp 	NextCommand
.113e					LinkFloatCosine:
.113e	fa		plx				plx
.113f	5a		phy			phy
.1140	20 ba 27	jsr $27ba		jsr	FloatCosine
.1143	7a		ply			ply
.1144	4c 4f 08	jmp $084f			jmp 	NextCommand
.1147					LinkFloatSine:
.1147	fa		plx				plx
.1148	5a		phy			phy
.1149	20 5a 29	jsr $295a		jsr	FloatSine
.114c	7a		ply			ply
.114d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1150					LinkFloatTangent:
.1150	fa		plx				plx
.1151	5a		phy			phy
.1152	20 cb 29	jsr $29cb		jsr	FloatTangent
.1155	7a		ply			ply
.1156	4c 4f 08	jmp $084f			jmp 	NextCommand
.1159					LinkFloatArcTan:
.1159	fa		plx				plx
.115a	5a		phy			phy
.115b	20 9f 26	jsr $269f		jsr	FloatArcTan
.115e	b0 c4		bcs $1124		bcs	MapRangeError
.1160	7a		ply			ply
.1161	4c 4f 08	jmp $084f			jmp 	NextCommand
.1164					LinkFloatCompare:
.1164	fa		plx				plx
.1165	5a		phy			phy
.1166	20 59 21	jsr $2159		jsr	FloatCompare
.1169	7a		ply			ply
.116a	4c 4f 08	jmp $084f			jmp 	NextCommand
.116d					LinkDivideInt32:
.116d	fa		plx				plx
.116e	5a		phy			phy
.116f	20 e7 21	jsr $21e7		jsr	DivideInt32
.1172	b0 b0		bcs $1124		bcs	MapRangeError
.1174	7a		ply			ply
.1175	4c 4f 08	jmp $084f			jmp 	NextCommand
.1178					StackSaveCurrentPosition:
.1178	20 cb 08	jsr $08cb			jsr 	FixUpY 						; codePtr,Y is corrected so Y = 0
.117b	5a		phy				phy
.117c	a0 02		ldy #$02			ldy 	#2
.117e	a5 28		lda $28				lda 	codePtr
.1180	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1182	c8		iny				iny
.1183	a5 29		lda $29				lda 	codePtr+1
.1185	91 24		sta ($24),y			sta 	(runtimeStackPtr),y
.1187	7a		ply				ply
.1188	60		rts				rts
.1189					StackLoadCurrentPosition:
.1189	a0 02		ldy #$02			ldy 	#2
.118b	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.118d	85 28		sta $28				sta 	codePtr
.118f	c8		iny				iny
.1190	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1192	85 29		sta $29				sta 	codePtr+1
.1194	a0 00		ldy #$00			ldy 	#0
.1196	60		rts				rts
.1197					XCommandMouse:
.1197	fa		plx				plx
.1198	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; mouse control.
.119b	ca		dex				dex
.119c	da		phx				phx
.119d	5a		phy				phy
.119e	48		pha				pha
.119f	38		sec				sec 								; get screen resolution
.11a0	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.11a3	68		pla				pla
.11a4	20 68 ff	jsr $ff68			jsr 	X16_mouse_config 			; config the mouse
.11a7	7a		ply				ply
.11a8	fa		plx				plx
.11a9	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ac					XUnaryMB:
.11ac	fa		plx				plx
.11ad	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11b0	a5 30		lda $30				lda 	zTemp2
.11b2	e8		inx				inx
.11b3	20 76 26	jsr $2676			jsr 	FloatSetByte
.11b6	4c 4f 08	jmp $084f			jmp 	NextCommand
.11b9					XUnaryMX:
.11b9	fa		plx				plx
.11ba	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11bd	a5 2c		lda $2c				lda 	zTemp0
.11bf	e8		inx				inx
.11c0	20 76 26	jsr $2676			jsr 	FloatSetByte
.11c3	a5 2d		lda $2d				lda 	zTemp0+1
.11c5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11c7	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ca					XUnaryMY:
.11ca	fa		plx				plx
.11cb	20 db 11	jsr $11db			jsr 	XUnaryMouseCommon
.11ce	a5 2e		lda $2e				lda 	zTemp1
.11d0	e8		inx				inx
.11d1	20 76 26	jsr $2676			jsr 	FloatSetByte
.11d4	a5 2f		lda $2f				lda 	zTemp1+1
.11d6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.11d8	4c 4f 08	jmp $084f			jmp 	NextCommand
.11db					XUnaryMouseCommon:
.11db	da		phx				phx
.11dc	5a		phy				phy
.11dd	a2 2c		ldx #$2c			ldx 	#zTemp0
.11df	20 6b ff	jsr $ff6b			jsr 	X16_mouse_get
.11e2	85 30		sta $30				sta 	zTemp2
.11e4	7a		ply				ply
.11e5	fa		plx				plx
.11e6	60		rts				rts
.11e7					NegateTOS:
.11e7	fa		plx				plx
.11e8	20 36 26	jsr $2636			jsr 	FloatNegate
.11eb	4c 4f 08	jmp $084f			jmp 	NextCommand
.11ee					CommandNewLine:
.11ee	fa		plx				plx
.11ef	9c 6a 05	stz $056a			stz 	stringInitialised
.11f2	a2 ff		ldx #$ff			ldx 	#$FF
.11f4	4c 4f 08	jmp $084f			jmp 	NextCommand
.11f7					CommandXNext:
.11f7	fa		plx				plx
.11f8					_CNRetry:
.11f8	a9 d3		lda #$d3			lda 	#FRAME_FOR 					; find the FOR
.11fa	20 5d 0d	jsr $0d5d			jsr 	StackFindFrame
.11fd	20 cb 08	jsr $08cb			jsr 	FixUpY 						; so we can use Y
.1200	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; check no index variable, both are $FF
.1202	35 4a		and $4a,x			and 	NSMantissa1,x
.1204	c9 ff		cmp #$ff			cmp 	#$FF
.1206	f0 16		beq $121e			beq 	_CNNoIndexVariable
.1208	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.120a	a0 05		ldy #$05			ldy 	#5
.120c	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.120e	d0 07		bne $1217			bne 	_CNNIndexFail
.1210	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1212	c8		iny				iny
.1213	d1 24		cmp ($24),y			cmp 	(runtimeStackPtr),y
.1215	f0 07		beq $121e			beq 	_CNNoIndexVariable
.1217					_CNNIndexFail:
.1217	a0 00		ldy #$00			ldy 	#0 							; so we don't fix up Y again !
.1219	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; close this frame
.121c	80 da		bra $11f8			bra 	_CNRetry
.121e					_CNNoIndexVariable:
.121e	ca		dex				dex
.121f	a0 04		ldy #$04			ldy 	#4 							; check for optimised NEXT
.1221	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1223	29 40		and #$40			and 	#$40	 					; bit 6
.1225	d0 55		bne $127c			bne 	_CNOptimisedNext
.1227	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.1229	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.122b	48		pha				pha
.122c	85 2c		sta $2c				sta 	zTemp0
.122e	c8		iny				iny
.122f	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1231	18		clc				clc
.1232	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1235	48		pha				pha
.1236	85 2d		sta $2d				sta 	zTemp0+1
.1238	20 fa 14	jsr $14fa			jsr 	ReadFloatZTemp0Sub 			; read current index onto stack.
.123b	a0 07		ldy #$07			ldy 	#7  						; read step onto stack +1
.123d	e8		inx				inx
.123e	20 bf 12	jsr $12bf			jsr 	CopyOffsetYToTOS
.1241	20 98 20	jsr $2098			jsr 	FloatAdd
.1244	68		pla				pla 								; restore address
.1245	85 2d		sta $2d				sta 	zTemp0+1
.1247	68		pla				pla
.1248	85 2c		sta $2c				sta 	zTemp0
.124a	20 d9 1a	jsr $1ad9			jsr 	WriteFloatZTemp0Sub			; write float.
.124d	e8		inx				inx  								; recover written
.124e	e8		inx				inx 								; load offset
.124f	a0 0d		ldy #$0d			ldy 	#13
.1251	20 bf 12	jsr $12bf			jsr 	CopyOffsetYToTOS
.1254	20 59 21	jsr $2159			jsr 	FloatCompare 				; and compare the floats.
.1257	ca		dex				dex 								; throw result (in NSMantissa0+1)
.1258	a0 0c		ldy #$0c			ldy 	#12 						; get the sign of the step.
.125a	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.125c	30 08		bmi $1266			bmi 	_CNDownStep
.125e	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1260	c9 01		cmp #$01			cmp 	#1 							; gone higher
.1262	f0 10		beq $1274			beq 	_CNExitFor 					; if so exit the loop
.1264	80 06		bra $126c			bra 	_CNLoopBack
.1266					_CNDownStep:
.1266	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; get comparator
.1268	c9 ff		cmp #$ff			cmp 	#255 						; gone lower
.126a	f0 08		beq $1274			beq 	_CNExitFor
.126c					_CNLoopBack:
.126c	20 89 11	jsr $1189			jsr 	StackLoadCurrentPosition 	; loop back
.126f	a0 00		ldy #$00			ldy 	#0
.1271	4c 4f 08	jmp $084f			jmp 	NextCommand
.1274					_CNExitFor:
.1274	20 4f 0d	jsr $0d4f			jsr 	StackCloseFrame 			; remove the frame and exit
.1277	a0 00		ldy #$00			ldy 	#0
.1279	4c 4f 08	jmp $084f			jmp 	NextCommand
.127c					_CNOptimisedNext:
.127c	a0 05		ldy #$05			ldy 	#5 							; copy address to zTemp0, save for write back
.127e	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1280	85 2c		sta $2c				sta 	zTemp0
.1282	c8		iny				iny
.1283	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.1285	18		clc				clc
.1286	6d 07 04	adc $0407			adc 	variableStartPage 			; point to variable page.
.1289	85 2d		sta $2d				sta 	zTemp0+1
.128b	a0 07		ldy #$07			ldy 	#7 							; STEP value
.128d	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.128f	a0 ff		ldy #$ff			ldy 	#$FF
.1291	18		clc				clc
.1292					_CNOIncrement:
.1292	c8		iny				iny
.1293	71 2c		adc ($2c),y			adc 	(zTemp0),y
.1295	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1297	f0 f9		beq $1292			beq 	_CNOIncrement
.1299	18		clc				clc
.129a	a5 24		lda $24				lda 	runtimeStackPtr
.129c	69 0d		adc #$0d			adc 	#13
.129e	85 2e		sta $2e				sta 	zTemp1
.12a0	a5 25		lda $25				lda 	runtimeStackPtr+1
.12a2	69 00		adc #$00			adc 	#0
.12a4	85 2f		sta $2f				sta 	zTemp1+1
.12a6	a0 00		ldy #$00			ldy 	#0
.12a8	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 0
.12aa	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.12ac	c8		iny				iny
.12ad	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 1
.12af	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12b1	c8		iny				iny
.12b2	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 2
.12b4	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12b6	c8		iny				iny
.12b7	b1 2e		lda ($2e),y			lda 	(zTemp1),y 					; byte 3
.12b9	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.12bb	90 b7		bcc $1274			bcc	 	_CNExitFor
.12bd	80 ad		bra $126c			bra 	_CNLoopBack
.12bf					CopyOffsetYToTOS:
.12bf	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c1	95 3e		sta $3e,x			sta 	NSMantissa0,x
.12c3	c8		iny				iny
.12c4	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12c6	95 4a		sta $4a,x			sta 	NSMantissa1,x
.12c8	c8		iny				iny
.12c9	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12cb	95 56		sta $56,x			sta 	NSMantissa2,x
.12cd	c8		iny				iny
.12ce	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d0	95 62		sta $62,x			sta 	NSMantissa3,x
.12d2	c8		iny				iny
.12d3	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12d5	95 6e		sta $6e,x			sta 	NSExponent,x
.12d7	c8		iny				iny
.12d8	b1 24		lda ($24),y			lda 	(runtimeStackPtr),y
.12da	95 32		sta $32,x			sta 	NSStatus,x
.12dc	60		rts				rts
.12dd	4c 4f 08	jmp $084f			jmp 	NextCommand
.12e0					NotTOS:
.12e0	fa		plx				plx
.12e1	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.12e4	74 56		stz $56,x			stz 	NSMantissa2,x 				; chop down to 16 bit.
.12e6	74 62		stz $62,x			stz 	NSMantissa3,x
.12e8	20 36 26	jsr $2636			jsr 	FloatNegate		 			; negate
.12eb	e8		inx				inx 								; and subtract 1.
.12ec	a9 01		lda #$01			lda 	#1
.12ee	20 76 26	jsr $2676			jsr 	FloatSetByte
.12f1	20 92 20	jsr $2092			jsr 	FloatSubtract
.12f4					_NotTOSSkip:
.12f4	4c 4f 08	jmp $084f			jmp 	NextCommand
.12f7					CommandXOn:
.12f7	fa		plx				plx
.12f8	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get the integer part, the ON x GOTO bit
.12fb	8d 5e 04	sta $045e			sta 	onCount 					; save it.
.12fe	20 cb 08	jsr $08cb			jsr 	FixUpY 						; Y = 0
.1301					_CONFind:
.1301	ce 5e 04	dec $045e			dec 	onCount 					; reached zero, do this one
.1304	f0 0b		beq $1311			beq 	_CONFound
.1306	c8		iny				iny 								; skip over the token (GOTO or GOSUB page, and line #)
.1307	c8		iny				iny
.1308	c8		iny				iny
.1309	b1 28		lda ($28),y			lda 	(codePtr),y 				; is there a moreon after it, if so we can keep going.
.130b	c8		iny				iny
.130c	c9 aa		cmp #$aa			cmp 	#PCD_MOREON
.130e	f0 f1		beq $1301			beq 	_CONFind
.1310	88		dey				dey 								; point to character after last GOTO/GOSUB
.1311					_CONFound:
.1311	4c 4f 08	jmp $084f			jmp 	NextCommand
.1314					CommandMoreOn:
.1314	fa		plx				plx
.1315	c8		iny				iny 								; so it goes to the first non-goto/gosub
.1316	c8		iny				iny
.1317	c8		iny				iny
.1318	4c 4f 08	jmp $084f			jmp 	NextCommand
.045e					onCount:
>045e							.fill 	1
.131b					UnaryPeek:
.131b	fa		plx				plx
.131c	20 47 10	jsr $1047			jsr 	GetInteger16Bit
.131f	da		phx				phx
.1320	5a		phy				phy
.1321	a6 2c		ldx $2c				ldx 	zTemp0
.1323	a4 2d		ldy $2d				ldy 	zTemp0+1
.1325	20 73 1c	jsr $1c73			jsr 	XPeekMemory
.1328	7a		ply				ply
.1329	fa		plx				plx
.132a	20 76 26	jsr $2676			jsr 	FloatSetByte
.132d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1330					UnaryPI:
.1330	fa		plx				plx
.1331	a9 19		lda #$19			lda 	#Const_pi-Const_base
.1333	20 a4 28	jsr $28a4			jsr 	LoadConstant
.1336	e8		inx				inx
.1337	4c 4f 08	jmp $084f			jmp 	NextCommand
.133a					CommandPOKE:
.133a	fa		plx				plx
.133b	da		phx				phx 								; save XY
.133c	5a		phy				phy
.133d	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; get byte to POKE and save it
.1340	48		pha				pha
.1341	b5 49		lda $49,x			lda 	NSMantissa1-1,x 			; YX = address from Mantissa next up
.1343	a8		tay				tay
.1344	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.1346	aa		tax				tax
.1347	68		pla				pla
.1348	20 5f 1c	jsr $1c5f			jsr 	XPokeMemory
.134b	7a		ply				ply 								; restore YX and drop 2
.134c	fa		plx				plx
.134d	ca		dex				dex
.134e	ca		dex				dex
.134f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1352					UnaryPos:
.1352	fa		plx				plx
.1353	20 f2 1b	jsr $1bf2			jsr 	XGetHPos
.1356	20 76 26	jsr $2676			jsr 	FloatSetByte
.1359	4c 4f 08	jmp $084f			jmp 	NextCommand
.135c					GetChannel:
.135c	fa		plx				plx
.135d	ad 5f 04	lda $045f			lda 	currentChannel
.1360	e8		inx				inx
.1361	20 76 26	jsr $2676			jsr 	FloatSetByte
.1364	4c 4f 08	jmp $084f			jmp 	NextCommand
.1367					SetChannel:
.1367	fa		plx				plx
.1368	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.136b	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.136d	8d 5f 04	sta $045f			sta 	currentChannel
.1370	ca		dex				dex
.1371	4c 4f 08	jmp $084f			jmp 	NextCommand
.1374					SetDefaultChannel:
.1374	9c 5f 04	stz $045f			stz 	currentChannel
.1377	60		rts				rts
.1378					VectorPrintCharacter:
.1378	da		phx				phx
.1379	ae 5f 04	ldx $045f			ldx 	currentChannel
.137c	20 9d 1c	jsr $1c9d			jsr 	XPrintCharacterToChannel
.137f	fa		plx				plx
.1380	60		rts				rts
.1381					VectorGetCharacter:
.1381	da		phx				phx
.1382	ae 5f 04	ldx $045f			ldx 	currentChannel
.1385	20 d6 1b	jsr $1bd6			jsr 	XGetCharacterFromChannel
.1388	fa		plx				plx
.1389	60		rts				rts
.045f					currentChannel:
>045f							.fill 	1
.138a					PrintNumber:
.138a	fa		plx				plx
.138b	a9 07		lda #$07			lda 	#7
.138d	20 5c 25	jsr $255c			jsr 	FloatToString 				; to number in decimal buffer
.1390	ca		dex				dex 								; drop
.1391	da		phx				phx
.1392	a2 00		ldx #$00			ldx 	#0 							; print buffer.
.1394					_PNLoop:
.1394	bd 98 05	lda $0598,x			lda 	decimalBuffer,x
.1397	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.139a	e8		inx				inx
.139b	bd 98 05	lda $0598,x			lda	 	decimalBuffer,x
.139e	d0 f4		bne $1394			bne 	_PNLoop
.13a0	a9 20		lda #$20			lda 	#32 						; trailing space
.13a2	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.13a5	fa		plx				plx
.13a6	4c 4f 08	jmp $084f			jmp 	NextCommand
.13a9					PrintString:
.13a9	fa		plx				plx
.13aa	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; point zTemp0 to string
.13ac	85 2c		sta $2c				sta 	zTemp0
.13ae	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.13b0	85 2d		sta $2d				sta 	zTemp0+1
.13b2	ca		dex				dex 								; drop
.13b3	da		phx				phx
.13b4	5a		phy				phy
.13b5	b2 2c		lda ($2c)			lda 	(zTemp0) 					; X = count
.13b7	aa		tax				tax
.13b8	a0 01		ldy #$01			ldy 	#1 							; Y = position
.13ba					_PSLoop:
.13ba	e0 00		cpx #$00			cpx 	#0 							; complete ?
.13bc	f0 09		beq $13c7			beq 	_PSExit
.13be	ca		dex				dex 								; dec count
.13bf	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; print char and bump
.13c1	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.13c4	c8		iny				iny
.13c5	80 f3		bra $13ba			bra 	_PSLoop
.13c7					_PSExit:
.13c7	7a		ply				ply
.13c8	fa		plx				plx
.13c9	4c 4f 08	jmp $084f			jmp 	NextCommand
.13cc					CommandPushN:
.13cc	fa		plx				plx
.13cd	e8		inx				inx 								; next slot on stack
.13ce	b1 28		lda ($28),y			lda 	(codePtr),y 				; exponent
.13d0	95 6e		sta $6e,x			sta 	NSExponent,x
.13d2	c8		iny				iny
.13d3	b1 28		lda ($28),y			lda 	(codePtr),y 				; mantissa
.13d5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13d7	c8		iny				iny
.13d8	b1 28		lda ($28),y			lda 	(codePtr),y
.13da	95 4a		sta $4a,x			sta 	NSMantissa1,x
.13dc	c8		iny				iny
.13dd	b1 28		lda ($28),y			lda 	(codePtr),y
.13df	95 56		sta $56,x			sta 	NSMantissa2,x
.13e1	c8		iny				iny
.13e2	b1 28		lda ($28),y			lda 	(codePtr),y
.13e4	48		pha				pha
.13e5	29 7f		and #$7f			and 	#$7F
.13e7	95 62		sta $62,x			sta 	NSMantissa3,x
.13e9	68		pla				pla 								; sign in mantissa3:7
.13ea	29 80		and #$80			and 	#$80
.13ec	95 32		sta $32,x			sta 	NSStatus,x
.13ee	c8		iny				iny
.13ef	4c 4f 08	jmp $084f			jmp 	NextCommand
.13f2					CommandPushS:
.13f2	fa		plx				plx
.13f3	e8		inx				inx 								; next slot on stack
.13f4	18		clc				clc
.13f5	98		tya				tya
.13f6	65 28		adc $28				adc 	codePtr 					; the string is inline
.13f8	95 3e		sta $3e,x			sta 	NSMantissa0,x
.13fa	a5 29		lda $29				lda 	codePtr+1
.13fc	69 00		adc #$00			adc 	#0
.13fe	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1400	74 56		stz $56,x			stz 	NSMantissa2,x
.1402	74 62		stz $62,x			stz 	NSMantissa3,x
.1404	a9 40		lda #$40			lda 	#NSSString
.1406	95 32		sta $32,x			sta 	NSStatus,x
.1408	98		tya				tya 								; string length +1 added to Y
.1409	38		sec				sec
.140a	71 28		adc ($28),y			adc 	(codePtr),y 				; next instruction
.140c	a8		tay				tay
.140d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1410					CommandXRead:
.1410	fa		plx				plx
.1411	5a		phy				phy 								; save Y
.1412	20 43 14	jsr $1443			jsr 	ReadStringToBuffer 			; read element into buffer
.1415	e8		inx				inx									; space on stack
.1416	a9 61		lda #$61			lda 	#((ReadBufferSize) & $FF)
.1418	85 2c		sta $2c				sta 	0+zTemp0
.141a	a9 04		lda #$04			lda 	#((ReadBufferSize) >> 8) & $FF
.141c	85 2d		sta $2d				sta 	1+zTemp0
.141e	20 62 19	jsr $1962			jsr 	ValEvaluateZTemp0
.1421	b0 04		bcs $1427			bcs 	_CRError 					; failed
.1423	7a		ply				ply 								; restore Y
.1424	4c 4f 08	jmp $084f			jmp 	NextCommand
.1427					_CRError:
.1427	4c 0f 1f	jmp $1f0f		jmp	ErrorV_value
.142a					CommandReadString:
.142a	fa		plx				plx
.142b	5a		phy				phy 								; save Y
.142c	20 43 14	jsr $1443			jsr 	ReadStringToBuffer 			; read text
.142f	e8		inx				inx 								; make space on stack
.1430	20 74 26	jsr $2674			jsr 	FloatSetZero 				; store as string on stack
.1433	a9 61		lda #$61			lda 	#ReadBufferSize & $FF
.1435	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1437	a9 04		lda #$04			lda 	#ReadBufferSize >> 8
.1439	95 4a		sta $4a,x			sta 	NSMantissa1,x
.143b	a9 40		lda #$40			lda 	#NSSString
.143d	95 32		sta $32,x			sta 	NSStatus,x
.143f	7a		ply				ply 								; restore Y
.1440	4c 4f 08	jmp $084f			jmp 	NextCommand
.1443					ReadStringToBuffer:
.1443	a9 d6		lda #$d6			lda 	#((ReadBumpNext) & $FF)
.1445	8d 61 05	sta $0561			sta 	0+ReadBumpNextVec
.1448	a9 14		lda #$14			lda 	#((ReadBumpNext) >> 8) & $FF
.144a	8d 62 05	sta $0562			sta 	1+ReadBumpNextVec
.144d	a9 a9		lda #$a9			lda 	#((ReadLookNext) & $FF)
.144f	8d 63 05	sta $0563			sta 	0+ReadLookNextVec
.1452	a9 14		lda #$14			lda 	#((ReadLookNext) >> 8) & $FF
.1454	8d 64 05	sta $0564			sta 	1+ReadLookNextVec
.1457					GetStringToBuffer:
.1457	20 a6 14	jsr $14a6			jsr		GetLookNext 				; skip all leading spaces.
.145a	f0 44		beq $14a0			beq 	_RBError 					; end of data
.145c	b0 f9		bcs $1457			bcs 	GetStringToBuffer 			; switched to new data line.
.145e	c9 20		cmp #$20			cmp 	#' ' 						; non space got something
.1460	b0 05		bcs $1467			bcs 	_RBNoSpace
.1462	20 a3 14	jsr $14a3			jsr 	GetBumpNext 				; consume space and loop round.
.1465	80 f0		bra $1457			bra 	GetStringToBuffer
.1467					_RBNoSpace:
.1467	9c 61 04	stz $0461			stz 	ReadBufferSize 				; empty the buffer.
.146a	c9 22		cmp #$22			cmp 	#'"' 						; is it a '"'
.146c	d0 08		bne $1476			bne 	_RBCommaSep
.146e	8d 60 04	sta $0460			sta 	ReadSep 					; use as a seperator
.1471	20 a3 14	jsr $14a3			jsr 	GetBumpNext 				; consume the '"'
.1474	80 05		bra $147b			bra 	_RBGetText
.1476					_RBCommaSep:
.1476	a9 2c		lda #$2c			lda 	#","						; get till comma
.1478	8d 60 04	sta $0460			sta 	ReadSep
.147b					_RBGetText:
.147b	20 a6 14	jsr $14a6			jsr 	GetLookNext 				; what follows
.147e	b0 18		bcs $1498			bcs 	_RBEndGet 					; if new DATA line, the end without consumption
.1480	20 a3 14	jsr $14a3			jsr 	GetBumpNext 				; consume it whatever
.1483	cd 60 04	cmp $0460			cmp 	ReadSep 					; if found the seperator.
.1486	f0 10		beq $1498			beq 	_RBEndGet 					; exit after consumption
.1488	da		phx				phx
.1489	ae 61 04	ldx $0461			ldx 	ReadBufferSize 				; copy into buffer.
.148c	ee 61 04	inc $0461			inc 	ReadBufferSize
.148f	9d 62 04	sta $0462,x			sta 	ReadBuffer,x
.1492	9e 63 04	stz $0463,x			stz 	ReadBuffer+1,x 				; make ASCIIZ as well.
.1495	fa		plx				plx
.1496	80 e3		bra $147b			bra 	_RBGetText
.1498					_RBEndGet:
.1498	c9 22		cmp #$22			cmp 	#'"'
.149a	d0 03		bne $149f			bne 	_RBNotQuote
.149c	20 a3 14	jsr $14a3			jsr 	GetBumpNext
.149f					_RBNotQuote:
.149f	60		rts				rts
.14a0					_RBError:
.14a0	4c c4 1f	jmp $1fc4		jmp	ErrorV_data
.14a3					GetBumpNext:
.14a3	6c 61 05	jmp ($0561)			jmp 	(ReadBumpNextVec)
.14a6					GetLookNext:
.14a6	6c 63 05	jmp ($0563)			jmp 	(ReadLookNextVec)
.14a9					ReadLookNext:
.14a9	ad 65 05	lda $0565			lda 	dataRemaining 				; any data remaining
.14ac	f0 04		beq $14b2			beq 	_RLNFindData
.14ae	b2 2a		lda ($2a)			lda 	(objPtr) 					; return that object.
.14b0	18		clc				clc
.14b1	60		rts				rts
.14b2					_RLNFindData:
.14b2	b2 2a		lda ($2a)			lda 	(objPtr) 					; see where we are
.14b4	c9 ff		cmp #$ff			cmp 	#$FF 						; if at $FF then end, error.
.14b6	f0 1a		beq $14d2			beq 	_RLNNoData
.14b8	c9 d0		cmp #$d0			cmp 	#PCD_CMD_DATA 				; Found DATA
.14ba	f0 05		beq $14c1			beq 	_RLNHaveData
.14bc					_RLNNext:
.14bc	20 42 20	jsr $2042			jsr 	MoveObjectForward			; else scan forward.
.14bf	80 f1		bra $14b2			bra 	_RLNFindData
.14c1					_RLNHaveData:
.14c1	a0 01		ldy #$01			ldy 	#1 							; get length
.14c3	b1 2a		lda ($2a),y			lda 	(objPtr),y
.14c5	f0 f5		beq $14bc			beq 	_RLNNext 					; skip if DATA alone
.14c7	20 d6 14	jsr $14d6			jsr 	ReadBumpNext 				; advance by two
.14ca	20 d6 14	jsr $14d6			jsr 	ReadBumpNext
.14cd	8d 65 05	sta $0565			sta 	dataRemaining 				; set data left count.
.14d0	38		sec				sec
.14d1	60		rts				rts
.14d2					_RLNNoData:
.14d2	a9 00		lda #$00			lda 	#0
.14d4	38		sec				sec
.14d5	60		rts				rts
.14d6					ReadBumpNext:
.14d6	e6 2a		inc $2a				inc 	objPtr
.14d8	d0 02		bne $14dc			bne 	_RBNSkip
.14da	e6 2b		inc $2b				inc 	objPtr+1
.14dc					_RBNSkip:
.14dc	ce 65 05	dec $0565			dec 	dataRemaining
.14df	60		rts				rts
.0460					ReadSep:
>0460							.fill 	1
.0461					ReadBufferSize:
>0461							.fill 	1
.0462					ReadBuffer:
>0462							.fill 	255
.0561					ReadBumpNextVec:
>0561							.fill 	2
.0563					ReadLookNextVec:
>0563							.fill 	2
.14e0					ReadFloatCommand:
.14e0	fa		plx				plx
.14e1	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.14e3	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.14e5	88		dey				dey 								; get the upper 3 bits
.14e6	b1 28		lda ($28),y			lda 	(codePtr),y
.14e8	29 07		and #$07			and 	#7
.14ea	c8		iny				iny
.14eb	c8		iny				iny
.14ec	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.14ee	2a		rol a				rol 	a 							; carry will be clear.
.14ef	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.14f2	85 2d		sta $2d				sta 	zTemp0+1
.14f4	20 fa 14	jsr $14fa			jsr 	ReadFloatZTemp0Sub
.14f7	4c 4f 08	jmp $084f			jmp 	NextCommand
.14fa					ReadFloatZTemp0Sub:
.14fa	5a		phy				phy 								; start write
.14fb	a0 01		ldy #$01			ldy 	#1
.14fd	e8		inx				inx
.14fe	b2 2c		lda ($2c)			lda 	(zTemp0)
.1500	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1502	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1504	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1506	c8		iny				iny
.1507	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1509	95 56		sta $56,x			sta 	NSMantissa2,x
.150b	c8		iny				iny
.150c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.150e	95 62		sta $62,x			sta 	NSMantissa3,x
.1510	c8		iny				iny
.1511	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1513	95 6e		sta $6e,x			sta 	NSExponent,x
.1515	c8		iny				iny
.1516	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1518	95 32		sta $32,x			sta 	NSStatus,x
.151a	7a		ply				ply
.151b	60		rts				rts
.151c					ReadIntegerCommand:
.151c	fa		plx				plx
.151d	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.151f	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1521	88		dey				dey 								; get the upper 3 bits
.1522	b1 28		lda ($28),y			lda 	(codePtr),y
.1524	29 07		and #$07			and 	#7
.1526	c8		iny				iny
.1527	c8		iny				iny
.1528	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.152a	2a		rol a				rol 	a 							; carry will be clear.
.152b	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.152e	85 2d		sta $2d				sta 	zTemp0+1
.1530	20 36 15	jsr $1536			jsr 	ReadIntegerZTemp0Sub
.1533	4c 4f 08	jmp $084f			jmp 	NextCommand
.1536					ReadIntegerZTemp0Sub:
.1536	5a		phy				phy 								; start write
.1537	a0 01		ldy #$01			ldy 	#1
.1539	e8		inx				inx 								; prepare
.153a	74 56		stz $56,x			stz 	NSMantissa2,x
.153c	74 62		stz $62,x			stz 	NSMantissa3,x
.153e	74 6e		stz $6e,x			stz 	NSExponent,x
.1540	74 32		stz $32,x			stz 	NSStatus,x
.1542	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get MSB, do -ve code.
.1544	30 08		bmi $154e			bmi 	_RIZNegative
.1546	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1548	b2 2c		lda ($2c)			lda 	(zTemp0)
.154a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.154c	7a		ply				ply
.154d	60		rts				rts
.154e					_RIZNegative:
.154e	38		sec				sec 								; -ve read
.154f	a9 00		lda #$00			lda 	#0
.1551	f2 2c		sbc ($2c)			sbc 	(zTemp0)
.1553	95 3e		sta $3e,x			sta 	NSMantissa0,x
.1555	a9 00		lda #$00			lda 	#0
.1557	f1 2c		sbc ($2c),y			sbc 	(zTemp0),y
.1559	95 4a		sta $4a,x			sta 	NSMantissa1,x
.155b	a9 80		lda #$80			lda 	#$80
.155d	95 32		sta $32,x			sta 	NSStatus,x
.155f	7a		ply				ply
.1560	60		rts				rts
.1561					ReadStringCommand:
.1561	fa		plx				plx
.1562	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1564	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1566	88		dey				dey 								; get the upper 3 bits
.1567	b1 28		lda ($28),y			lda 	(codePtr),y
.1569	29 07		and #$07			and 	#7
.156b	c8		iny				iny
.156c	c8		iny				iny
.156d	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.156f	2a		rol a				rol 	a 							; carry will be clear.
.1570	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1573	85 2d		sta $2d				sta 	zTemp0+1
.1575	20 7b 15	jsr $157b			jsr 	ReadStringZTemp0Sub
.1578	4c 4f 08	jmp $084f			jmp 	NextCommand
.157b					ReadStringZTemp0Sub:
.157b	5a		phy				phy 								; start write
.157c	e8		inx				inx 								; prepare
.157d	74 56		stz $56,x			stz 	NSMantissa2,x
.157f	74 62		stz $62,x			stz 	NSMantissa3,x
.1581	74 6e		stz $6e,x			stz 	NSExponent,x
.1583	a9 40		lda #$40			lda 	#NSSString
.1585	74 32		stz $32,x			stz 	NSStatus,x
.1587	18		clc				clc
.1588	b2 2c		lda ($2c)			lda 	(zTemp0)					; read address of block add 2.
.158a	69 02		adc #$02			adc 	#2 							; this points to actual data
.158c	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; if address 0 the MSB will still be 0
.158e	a0 01		ldy #$01			ldy 	#1
.1590	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1592	69 00		adc #$00			adc 	#0
.1594	95 4a		sta $4a,x			sta 	NSMantissa1,x 				; +ve read
.1596	d0 08		bne $15a0			bne 	_RSZNoDefault 				; if read $00 use a default value.
.1598	a9 a2		lda #$a2			lda 	#_RSZNull & $FF
.159a	95 3e		sta $3e,x			sta 	NSMantissa0,x
.159c	a9 15		lda #$15			lda 	#_RSZNull >> 8
.159e	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15a0					_RSZNoDefault:
.15a0	7a		ply				ply
.15a1	60		rts				rts
.15a2					_RSZNull:
>15a2	00						.byte 	0
.15a3					CommandRestoreX:
.15a3	fa		plx				plx
.15a4	20 aa 15	jsr $15aa			jsr 	RestoreCode
.15a7	4c 4f 08	jmp $084f			jmp 	NextCommand
.15aa					RestoreCode:
.15aa	ad 04 04	lda $0404			lda 	runtimeHigh 				; reset pointer
.15ad	85 2b		sta $2b				sta 	objPtr+1
.15af	64 2a		stz $2a				stz 	objPtr
.15b1	9c 65 05	stz $0565			stz 	dataRemaining 				; no data remaining.
.15b4	60		rts				rts
.0565					dataRemaining:
>0565							.fill 	1		 					; 0 if not in data statement
.15b5					UnaryRND:
.15b5	fa		plx				plx
.15b6	34 32		bit $32,x			bit 	NSStatus,x 					; -ve then set seed from operand
.15b8	10 17		bpl $15d1			bpl 	_URNoSeed
.15ba	20 c9 23	jsr $23c9			jsr 	FloatNormalise 				; some float value
.15bd	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy to Mantissa
.15bf	8d 66 05	sta $0566			sta 	randomSeed+0
.15c2	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.15c4	8d 67 05	sta $0567			sta 	randomSeed+1
.15c7	b5 56		lda $56,x			lda 	NSMantissa2,x
.15c9	8d 68 05	sta $0568			sta 	randomSeed+2
.15cc	b5 62		lda $62,x			lda 	NSMantissa3,x
.15ce	8d 69 05	sta $0569			sta 	randomSeed+3
.15d1					_URNoSeed:
.15d1	20 f3 15	jsr $15f3			jsr 	RandomNumberGenerator 		; create a number and copy to mantissa
.15d4	ad 66 05	lda $0566			lda 	randomSeed+0
.15d7	95 3e		sta $3e,x			sta 	NSMantissa0,x
.15d9	ad 67 05	lda $0567			lda 	randomSeed+1
.15dc	95 4a		sta $4a,x			sta 	NSMantissa1,x
.15de	ad 68 05	lda $0568			lda 	randomSeed+2
.15e1	95 56		sta $56,x			sta 	NSMantissa2,x
.15e3	ad 69 05	lda $0569			lda 	randomSeed+3
.15e6	29 7f		and #$7f			and 	#$7F
.15e8	95 62		sta $62,x			sta 	NSMantissa3,x
.15ea	a9 e1		lda #$e1			lda 	#(-31 & $FF)
.15ec	95 6e		sta $6e,x			sta 	NSExponent,x
.15ee	74 32		stz $32,x			stz 	NSStatus,x
.15f0	4c 4f 08	jmp $084f			jmp 	NextCommand
.15f3					RandomNumberGenerator:
.15f3	5a		phy				phy
.15f4	ad 66 05	lda $0566			lda 	randomSeed+0 				; check if zero
.15f7	0d 67 05	ora $0567			ora 	randomSeed+1
.15fa	0d 68 05	ora $0568			ora 	randomSeed+2
.15fd	0d 69 05	ora $0569			ora 	randomSeed+3
.1600	d0 07		bne $1609			bne 	_RNGNoSeed
.1602	ce 69 05	dec $0569			dec 	randomSeed+3 				; if so tweak and flog
.1605	a0 64		ldy #$64			ldy 	#100
.1607	80 05		bra $160e			bra 	_RNGLoop
.1609					_RNGNoSeed:
.1609	a0 08		ldy #$08			ldy 	#8
.160b	ad 66 05	lda $0566			lda 	randomSeed+0
.160e					_RNGLoop:
.160e	0a		asl a				asl		a
.160f	2e 67 05	rol $0567			rol 	randomSeed+1
.1612	2e 68 05	rol $0568			rol 	randomSeed+2
.1615	2e 69 05	rol $0569			rol 	randomSeed+3
.1618	90 02		bcc $161c			bcc		_RNGSkip
.161a	49 c5		eor #$c5			eor 	#$C5
.161c					_RNGSkip:
.161c	88		dey				dey
.161d	d0 ef		bne $160e			bne		_RNGLoop
.161f	8d 66 05	sta $0566			sta 	randomSeed+0
.1622	7a		ply				ply
.1623	60		rts				rts
.0566					randomSeed:
>0566							.fill 	4
.1624					StringConcatenate:
.1624	fa		plx				plx
.1625	ca		dex				dex
.1626	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy strings to zTemp1 and zTemp2
.1628	85 2e		sta $2e				sta 	zTemp1
.162a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.162c	85 2f		sta $2f				sta 	zTemp1+1
.162e	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x
.1630	85 30		sta $30				sta 	zTemp2
.1632	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.1634	85 31		sta $31				sta 	zTemp2+1
.1636	18		clc				clc 								; work out total length
.1637	b2 2e		lda ($2e)			lda 	(zTemp1)
.1639	72 30		adc ($30)			adc 	(zTemp2)
.163b	b0 18		bcs $1655			bcs 	_BCLength 					; more than 255 characters.
.163d	48		pha				pha 								; save total
.163e	20 1b 17	jsr $171b			jsr 	StringAllocTemp 			; space for result.
.1641	68		pla				pla 								; write total as first.
.1642	92 22		sta ($22)			sta 	(zsTemp)
.1644	20 58 16	jsr $1658			jsr 	_BCCopyZTemp1 				; copy zTemp1 to target
.1647	a5 30		lda $30				lda 	zTemp2 						; copy address zTemp2->1
.1649	85 2e		sta $2e				sta 	zTemp1
.164b	a5 31		lda $31				lda 	zTemp2+1
.164d	85 2f		sta $2f				sta 	zTemp1+1
.164f	20 58 16	jsr $1658			jsr 	_BCCopyZTemp1 				; and copy it, e.g. zTemp2
.1652	4c 4f 08	jmp $084f			jmp 	NextCommand
.1655					_BCLength:
.1655	4c ff 1e	jmp $1eff		jmp	ErrorV_range
.1658					_BCCopyZTemp1:
.1658	b2 2e		lda ($2e)			lda 	(zTemp1) 					; bytes to copy
.165a	f0 15		beq $1671			beq 	_BCCExit 					; none.
.165c	da		phx				phx 								; save XY
.165d	5a		phy				phy
.165e	aa		tax				tax 								; count in X.
.165f	a0 01		ldy #$01			ldy 	#1
.1661					_BCCLoop:
.1661	e6 22		inc $22				inc 	zsTemp 						; bump pointer, pre-increment
.1663	d0 02		bne $1667			bne 	_BCCNoCarry
.1665	e6 23		inc $23				inc 	zsTemp+1
.1667					_BCCNoCarry:
.1667	b1 2e		lda ($2e),y			lda 	(zTemp1),y				 	; copy bytes
.1669	92 22		sta ($22)			sta 	(zsTemp)
.166b	c8		iny				iny
.166c	ca		dex				dex 								; X times
.166d	d0 f2		bne $1661			bne 	_BCCLoop
.166f	7a		ply				ply 								; restore YX
.1670	fa		plx				plx
.1671					_BCCExit:
.1671	60		rts				rts
.1672					XRuntimeSetup:
.1672	a9 ff		lda #$ff	 		lda 	#$FF 						; default banks to access.
.1674	8d 6d 05	sta $056d	 		sta 	ramBank
.1677	8d 6e 05	sta $056e	 		sta 	romBank
.167a	60		rts				rts
.167b					SignTOS:
.167b	fa		plx				plx
.167c	20 96 26	jsr $2696			jsr 	FloatIsZero 				; if zero
.167f	f0 0f		beq $1690			beq 	_SGZero  					; return Int Zero
.1681	b5 32		lda $32,x			lda 	NSStatus,x 					; get status w/sign
.1683	48		pha				pha
.1684	a9 01		lda #$01			lda 	#1 							; set result to 1
.1686	20 76 26	jsr $2676			jsr 	FloatSetByte
.1689	68		pla				pla
.168a	29 80		and #$80			and		#$80 						; copy the sign byte out
.168c	95 32		sta $32,x			sta 	NSStatus,x  				; so it will be -1 or 1
.168e	80 03		bra $1693			bra 	_SGExit
.1690					_SGZero:
.1690	20 74 26	jsr $2674			jsr 	FloatSetZero
.1693					_SGExit:
.1693	4c 4f 08	jmp $084f			jmp 	NextCommand
.1696					CommandShift:
.1696	b1 28		lda ($28),y			lda 	(codePtr),y 				; get shifted command (X already pushed)
.1698	c8		iny				iny
.1699	0a		asl a				asl 	a 							; double into X
.169a	aa		tax				tax
.169b	7c 4a 1a	jmp ($1a4a,x)			jmp 	(ShiftVectorTable,x) 		; go there.
.169e					PrintTab:
.169e	fa		plx				plx
.169f	20 f2 1b	jsr $1bf2			jsr 	XGetHPos
.16a2					_PTMod10:
.16a2	38		sec				sec
.16a3	e9 0a		sbc #$0a			sbc 	#10
.16a5	b0 fb		bcs $16a2			bcs 	_PTMod10
.16a7	49 ff		eor #$ff			eor 	#255 						; subtract from 10 effectively. negate it
.16a9	1a		inc a				inc 	a 							; if modulus is 0, then this will be -10 => 10
.16aa	80 15		bra $16c1			bra 	PrintSpaceLoop
.16ac					PrintPos:
.16ac	fa		plx				plx
.16ad	20 f2 1b	jsr $1bf2			jsr		XGetHPos 					; get current position
.16b0	85 2c		sta $2c				sta 	zTemp0
.16b2	38		sec				sec 								; calculate spaces required
.16b3	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16b5	ca		dex				dex
.16b6	e5 2c		sbc $2c				sbc 	zTemp0
.16b8	b0 07		bcs $16c1			bcs 	PrintSpaceLoop 				; if >= 0 then do that many spaces
.16ba	4c 4f 08	jmp $084f			jmp 	NextCommand
.16bd					PrintSpace:
.16bd	fa		plx				plx
.16be	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.16c0	ca		dex				dex
.16c1					PrintSpaceLoop:
.16c1	c9 00		cmp #$00			cmp 	#0
.16c3	f0 0a		beq $16cf			beq 	_PSExit
.16c5	48		pha				pha
.16c6	a9 20		lda #$20			lda 	#" "
.16c8	20 78 13	jsr $1378			jsr 	VectorPrintCharacter
.16cb	68		pla				pla
.16cc	3a		dec a				dec 	a
.16cd	80 f2		bra $16c1			bra 	PrintSpaceLoop
.16cf					_PSExit:
.16cf	4c 4f 08	jmp $084f			jmp 	NextCommand
.16d2					CommandStop:
.16d2	fa		plx				plx
.16d3	4c b1 1f	jmp $1fb1		jmp	ErrorV_stop
.16d6					Unary_Str:
.16d6	fa		plx				plx
.16d7	5a		phy				phy
.16d8	a9 08		lda #$08			lda 	#8 							; maximum decimal places.
.16da	20 5c 25	jsr $255c			jsr 	FloatToString 				; do the conversion.
.16dd	a9 21		lda #$21			lda		#33 						; create buffer
.16df	20 1b 17	jsr $171b			jsr 	StringAllocTemp 			; allocate memory
.16e2	a0 01		ldy #$01			ldy 	#1  						; copy the converted string into the buffer.
.16e4					_USCopy:
.16e4	b9 97 05	lda $0597,y			lda 	decimalBuffer-1,y
.16e7	f0 05		beq $16ee			beq 	_USExit
.16e9	91 22		sta ($22),y			sta 	(zsTemp),y
.16eb	c8		iny				iny
.16ec	80 f6		bra $16e4			bra 	_USCopy
.16ee					_USExit:
.16ee	98		tya				tya
.16ef	3a		dec a				dec 	a
.16f0	92 22		sta ($22)			sta 	(zsTemp)
.16f2	7a		ply				ply
.16f3	4c 4f 08	jmp $084f			jmp 	NextCommand
.16f6					StringInitialise:
.16f6	48		pha				pha
.16f7	ad 6a 05	lda $056a			lda 	stringInitialised 			; already done
.16fa	d0 11		bne $170d			bne 	_SIExit
.16fc	ad 02 04	lda $0402			lda 	stringHighMemory 			; copy high memory - 512 => stringTempPointer
.16ff	8d 6b 05	sta $056b			sta 	stringTempPointer
.1702	ad 03 04	lda $0403			lda 	stringHighMemory+1
.1705	3a		dec a				dec 	a
.1706	3a		dec a				dec 	a
.1707	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.170a	ce 6a 05	dec $056a			dec 	stringInitialised 			; set the initialised flag.
.170d					_SIExit:
.170d	a5 27		lda $27				lda 	availableMemory+1 			; check out of memory
.170f	1a		inc a				inc 	a
.1710	1a		inc a				inc 	a
.1711	cd 03 04	cmp $0403			cmp 	stringHighMemory+1
.1714	b0 02		bcs $1718			bcs 	_SIMemory
.1716	68		pla				pla
.1717	60		rts				rts
.1718					_SIMemory:
.1718	4c 0a 20	jmp $200a		jmp	ErrorV_memory
.171b					StringAllocTemp:
.171b	20 f6 16	jsr $16f6			jsr 	StringInitialise 			; check it is initialised.
.171e	49 ff		eor #$ff			eor 	#$FF 						; subtract A+1 from temp pointer.
.1720	18		clc				clc
.1721	6d 6b 05	adc $056b			adc 	stringTempPointer 			; subtract 32 from temp pointer and
.1724	8d 6b 05	sta $056b			sta 	stringTempPointer 			; save in zsTemp and stackas well.
.1727	85 22		sta $22				sta 	zsTemp
.1729	95 3e		sta $3e,x			sta 	NSMantissa0,x
.172b	ad 6c 05	lda $056c			lda 	stringTempPointer+1
.172e	69 ff		adc #$ff			adc 	#$FF
.1730	8d 6c 05	sta $056c			sta 	stringTempPointer+1
.1733	85 23		sta $23				sta 	zsTemp+1
.1735	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1737	74 56		stz $56,x			stz 	NSMantissa2,x
.1739	74 62		stz $62,x			stz 	NSMantissa3,x
.173b	a9 00		lda #$00			lda 	#0 							; clear string.
.173d	92 22		sta ($22)			sta 	(zsTemp)
.173f	a9 40		lda #$40			lda 	#NSSString 			 		; mark as string
.1741	95 32		sta $32,x			sta 	NSStatus,x
.1743	60		rts				rts
.1744					StringWriteChar:
.1744	5a		phy				phy
.1745	48		pha				pha
.1746	b2 22		lda ($22)			lda 	(zsTemp)
.1748	1a		inc a				inc 	a
.1749	92 22		sta ($22)			sta 	(zsTemp)
.174b	a8		tay				tay
.174c	68		pla				pla
.174d	91 22		sta ($22),y			sta 	(zsTemp),y
.174f	7a		ply				ply
.1750	60		rts				rts
.056a					stringInitialised:
>056a							.fill 	1
.056b					stringTempPointer:
>056b							.fill 	2
.1751					Unary_Left:
.1751	fa		plx				plx
.1752	5a		phy				phy
.1753	18		clc				clc 								; only one parameter
.1754	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the length of the string.
.1757	48		pha				pha
.1758	ca		dex				dex
.1759	a9 00		lda #$00			lda 	#0 							; push the start position.
.175b	48		pha				pha
.175c	20 94 17	jsr $1794			jsr 	UnarySStringToZTemp0
.175f	80 3c		bra $179d			bra 	SubstringMain 				; stack now points to the string to slice.
.1761					Unary_Right:
.1761	fa		plx				plx
.1762	5a		phy				phy
.1763	a9 ff		lda #$ff			lda 	#255 						; push 255, we want all the string.
.1765	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the right length of the string.
.1768	48		pha				pha
.1769	ca		dex				dex
.176a	20 94 17	jsr $1794			jsr 	UnarySStringToZTemp0
.176d	68		pla				pla 								; this is the right requirement
.176e	38		sec				sec
.176f	49 ff		eor #$ff			eor 	#$FF
.1771	72 2c		adc ($2c)			adc 	(zTemp0)
.1773	b0 02		bcs $1777			bcs 	_URHaveCount
.1775	a9 00		lda #$00			lda 	#0 							; overflow, start from 0
.1777					_URHaveCount:
.1777	a0 ff		ldy #$ff			ldy 	#255 						; whole string
.1779	5a		phy				phy
.177a	48		pha				pha 								; start position
.177b	80 20		bra $179d			bra 	SubstringMain
.177d					Unary_Mid:
.177d	fa		plx				plx
.177e	5a		phy				phy
.177f	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; push the length of the string required.
.1782	48		pha				pha
.1783	ca		dex				dex
.1784	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; put the start position.
.1787	f0 08		beq $1791			beq 	_UMError
.1789	3a		dec a				dec 	a
.178a	48		pha				pha
.178b	ca		dex				dex
.178c	20 94 17	jsr $1794			jsr 	UnarySStringToZTemp0
.178f	80 0c		bra $179d			bra 	SubstringMain 				; stack now points to the string to slice.
.1791					_UMError:
.1791	4c ff 1e	jmp $1eff		jmp	ErrorV_range
.1794					UnarySStringToZTemp0:
.1794	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1796	85 2c		sta $2c				sta 	zTemp0
.1798	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.179a	85 2d		sta $2d				sta 	zTemp0+1
.179c	60		rts				rts
.179d					SubstringMain:
.179d	68		pla				pla 								; get the start offset
.179e	7a		ply				ply 								; get the count to do.
.179f	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; if start >= length then return NULL.
.17a1	b0 38		bcs $17db			bcs 	_SSReturnNull
.17a3	85 2e		sta $2e				sta 	zTemp1 						; save start position.
.17a5	84 2f		sty $2f				sty 	zTemp1+1 					; save count
.17a7	18		clc				clc
.17a8	65 2f		adc $2f				adc 	zTemp1+1 					; this is the end position.
.17aa	b0 06		bcs $17b2			bcs 	_SMTruncateToEnd 			; if overflow, limit to length-start.
.17ac	d2 2c		cmp ($2c)			cmp 	(zTemp0) 					; ok if limit is <= length.
.17ae	f0 04		beq $17b4			beq 	_SMIsOkay
.17b0	90 02		bcc $17b4			bcc 	_SMIsOkay
.17b2					_SMTruncateToEnd:
.17b2	b2 2c		lda ($2c)			lda 	(zTemp0) 					; end position is length.
.17b4					_SMIsOkay:
.17b4	85 2f		sta $2f				sta 	zTemp1+1
.17b6	38		sec				sec		 							; work out size
.17b7	a5 2f		lda $2f				lda 	zTemp1+1
.17b9	e5 2e		sbc $2e				sbc 	zTemp1
.17bb	f0 1e		beq $17db			beq 	_SSReturnNull 				; if size = 0 then return empty string.
.17bd	20 1b 17	jsr $171b			jsr 	StringAllocTemp 			; zsTemp & mantissa = the new string.
.17c0	a4 2e		ldy $2e				ldy 	zTemp1 						; start
.17c2					_SMCopy:
.17c2	c4 2f		cpy $2f				cpy 	zTemp1+1 					; exit if reached end
.17c4	f0 11		beq $17d7			beq 	_SMExit
.17c6	c8		iny				iny 								; bump and
.17c7	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; get character (prefix)
.17c9	5a		phy				phy
.17ca	48		pha				pha
.17cb	b2 22		lda ($22)			lda 	(zsTemp) 					; bump length => Y
.17cd	1a		inc a				inc 	a
.17ce	a8		tay				tay
.17cf	92 22		sta ($22)			sta 	(zsTemp)
.17d1	68		pla				pla 								; write character out
.17d2	91 22		sta ($22),y			sta 	(zsTemp),y
.17d4	7a		ply				ply 								; restore Y
.17d5	80 eb		bra $17c2			bra 	_SMCopy
.17d7					_SMExit:
.17d7	7a		ply				ply
.17d8	4c 4f 08	jmp $084f			jmp 	NextCommand
.17db					_SSReturnNull:
.17db	a9 ed		lda #$ed			lda 	#SSRNull & $FF 				; set up mantissa
.17dd	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17df	a9 17		lda #$17			lda 	#SSRNull >> 8
.17e1	95 4a		sta $4a,x			sta 	NSMantissa1,x
.17e3	74 56		stz $56,x			stz 	NSMantissa2,x
.17e5	74 62		stz $62,x			stz 	NSMantissa3,x
.17e7	a9 40		lda #$40			lda 	#NSSString
.17e9	95 32		sta $32,x			sta 	NSStatus,x
.17eb	80 ea		bra $17d7			bra 	_SMExit
.17ed					SSRNull:
>17ed	00 00						.word 	0
.17ef					CommandSwap:
.17ef	fa		plx				plx
.17f0	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.17f2	48		pha				pha
.17f3	b5 3d		lda $3d,x			lda 	NSMantissa0-1,x
.17f5	95 3e		sta $3e,x			sta 	NSMantissa0,x
.17f7	68		pla				pla
.17f8	95 3d		sta $3d,x			sta 	NSMantissa0-1,x
.17fa	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.17fc	48		pha				pha
.17fd	b5 49		lda $49,x			lda 	NSMantissa1-1,x
.17ff	95 4a		sta $4a,x			sta 	NSMantissa1,x
.1801	68		pla				pla
.1802	95 49		sta $49,x			sta 	NSMantissa1-1,x
.1804	b5 56		lda $56,x			lda 	NSMantissa2,x
.1806	48		pha				pha
.1807	b5 55		lda $55,x			lda 	NSMantissa2-1,x
.1809	95 56		sta $56,x			sta 	NSMantissa2,x
.180b	68		pla				pla
.180c	95 55		sta $55,x			sta 	NSMantissa2-1,x
.180e	b5 62		lda $62,x			lda 	NSMantissa3,x
.1810	48		pha				pha
.1811	b5 61		lda $61,x			lda 	NSMantissa3-1,x
.1813	95 62		sta $62,x			sta 	NSMantissa3,x
.1815	68		pla				pla
.1816	95 61		sta $61,x			sta 	NSMantissa3-1,x
.1818	b5 6e		lda $6e,x			lda 	NSExponent,x
.181a	48		pha				pha
.181b	b5 6d		lda $6d,x			lda 	NSExponent-1,x
.181d	95 6e		sta $6e,x			sta 	NSExponent,x
.181f	68		pla				pla
.1820	95 6d		sta $6d,x			sta 	NSExponent-1,x
.1822	b5 32		lda $32,x			lda 	NSStatus,x
.1824	48		pha				pha
.1825	b5 31		lda $31,x			lda 	NSStatus-1,x
.1827	95 32		sta $32,x			sta 	NSStatus,x
.1829	68		pla				pla
.182a	95 31		sta $31,x			sta 	NSStatus-1,x
.182c	4c 4f 08	jmp $084f			jmp 	NextCommand
.182f					CommandSYS:
.182f	fa		plx				plx
.1830	da		phx				phx 								; save XY
.1831	5a		phy				phy
.1832	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.1835	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get call address => zTemp0
.1837	85 2d		sta $2d				sta 	zTemp0+1
.1839	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.183b	85 2c		sta $2c				sta 	zTemp0
.183d	ae 0d 03	ldx $030d			ldx 	SYS_Reg_X 					; load registers
.1840	ac 0e 03	ldy $030e			ldy 	SYS_Reg_Y
.1843	ad 0f 03	lda $030f			lda 	SYS_Reg_S
.1846	48		pha				pha
.1847	ad 0c 03	lda $030c			lda 	SYS_Reg_A
.184a	28		plp				plp
.184b	20 62 18	jsr $1862			jsr 	_CSZTemp0
.184e	08		php				php
.184f	8e 0d 03	stx $030d			stx 	SYS_Reg_X 					; load registers
.1852	8c 0e 03	sty $030e			sty 	SYS_Reg_Y
.1855	8d 0c 03	sta $030c			sta 	SYS_Reg_A
.1858	68		pla				pla
.1859	8d 0f 03	sta $030f			sta 	SYS_Reg_S
.185c	7a		ply				ply 								; restore YX and drop 2
.185d	fa		plx				plx
.185e	ca		dex				dex
.185f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1862					_CSZTemp0:
.1862	6c 2c 00	jmp ($002c)			jmp 	(zTemp0)
.1865					TimeTOS:
.1865	fa		plx				plx
.1866	20 c0 18	jsr $18c0			jsr 	TIPushClock 				; push clock to TOS
.1869	4c 4f 08	jmp $084f			jmp 	NextCommand
.186c					TimeString:
.186c	fa		plx				plx
.186d	20 c0 18	jsr $18c0			jsr 	TIPushClock 				; push clock to TOS
.1870	20 95 18	jsr $1895			jsr 	_TSDivMod60 				; result in seconds
.1873	20 95 18	jsr $1895			jsr 	_TSDivMod60 				; seconds
.1876	48		pha				pha
.1877	20 95 18	jsr $1895			jsr 	_TSDivMod60 				; minutes
.187a	48		pha				pha
.187b	a9 18		lda #$18			lda 	#24 						; hours
.187d	20 97 18	jsr $1897			jsr 	_TSDivModA
.1880	48		pha				pha
.1881	a9 06		lda #$06			lda 	#6
.1883	20 1b 17	jsr $171b			jsr 	StringAllocTemp
.1886	68		pla				pla
.1887	20 a7 18	jsr $18a7			jsr 	_TSWriteDecimal
.188a	68		pla				pla
.188b	20 a7 18	jsr $18a7			jsr 	_TSWriteDecimal
.188e	68		pla				pla
.188f	20 a7 18	jsr $18a7			jsr 	_TSWriteDecimal
.1892	4c 4f 08	jmp $084f			jmp 	NextCommand
.1895					_TSDivMod60:
.1895	a9 3c		lda #$3c			lda 	#60
.1897					_TSDivModA:
.1897	e8		inx				inx
.1898	20 76 26	jsr $2676			jsr 	FloatSetByte
.189b	ca		dex				dex
.189c	20 0a 22	jsr $220a			jsr 	Int32Divide
.189f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; get modulus
.18a1	48		pha				pha
.18a2	20 f9 21	jsr $21f9			jsr 	NSMCopyPlusTwoToZero
.18a5	68		pla				pla
.18a6	60		rts				rts
.18a7					_TSWriteDecimal:
.18a7	da		phx				phx
.18a8	a2 30		ldx #$30			ldx 	#'0'
.18aa					_TSWDLoop:
.18aa	c9 0a		cmp #$0a			cmp 	#10
.18ac	90 05		bcc $18b3			bcc 	_TSWDEnd
.18ae	e9 0a		sbc #$0a			sbc 	#10
.18b0	e8		inx				inx
.18b1	80 f7		bra $18aa			bra 	_TSWDLoop
.18b3					_TSWDEnd:
.18b3	48		pha				pha
.18b4	8a		txa				txa
.18b5	20 44 17	jsr $1744			jsr 	StringWriteChar
.18b8	68		pla				pla
.18b9	09 30		ora #$30			ora 	#'0'
.18bb	20 44 17	jsr $1744			jsr 	StringWriteChar
.18be	fa		plx				plx
.18bf	60		rts				rts
.18c0					TIPushClock:
.18c0	5a		phy				phy
.18c1	e8		inx				inx 								; push 0 on the stack
.18c2	20 74 26	jsr $2674			jsr 	FloatSetZero
.18c5	da		phx				phx
.18c6	20 bd 1c	jsr $1cbd			jsr 	XReadClock 					; read time into YXA
.18c9	86 2c		stx $2c				stx 	zTemp0
.18cb	fa		plx				plx
.18cc	95 3e		sta $3e,x			sta 	NSMantissa0,x
.18ce	a5 2c		lda $2c				lda 	zTemp0
.18d0	95 4a		sta $4a,x			sta 	NSMantissa1,x
.18d2	98		tya				tya
.18d3	95 56		sta $56,x			sta 	NSMantissa2,x
.18d5	7a		ply				ply
.18d6	60		rts				rts
.18d7					CommandTIWrite:
.18d7	fa		plx				plx
.18d8	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy string address to ZSTemp
.18da	85 22		sta $22				sta 	zsTemp
.18dc	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.18de	85 23		sta $23				sta 	zsTemp+1
.18e0	b2 22		lda ($22)			lda 	(zsTemp) 					; check if it is six
.18e2	c9 06		cmp #$06			cmp 	#6
.18e4	d0 59		bne $193f			bne 	_CTIWError
.18e6	20 74 26	jsr $2674			jsr 	FloatSetZero
.18e9	20 0b 19	jsr $190b			jsr 	_CTIWDigitPair 				; do a digit pair 3 times
.18ec	20 0b 19	jsr $190b			jsr 	_CTIWDigitPair
.18ef	20 0b 19	jsr $190b			jsr 	_CTIWDigitPair
.18f2	a9 3c		lda #$3c			lda 	#60 						; multiply the result by 60.
.18f4	20 36 19	jsr $1936			jsr 	_CTIWMultiply
.18f7	da		phx				phx
.18f8	5a		phy				phy
.18f9	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; get time into YXA
.18fb	48		pha				pha
.18fc	b5 56		lda $56,x			lda 	NSMantissa2,x
.18fe	a8		tay				tay
.18ff	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1901	fa		plx				plx
.1902	20 c1 1c	jsr $1cc1			jsr 	XWriteClock 				; update the clock.
.1905	7a		ply				ply
.1906	fa		plx				plx
.1907	ca		dex				dex 								; throw result.
.1908	4c 4f 08	jmp $084f			jmp 	NextCommand
.190b					_CTIWDigitPair:
.190b	a9 06		lda #$06			lda 	#6 							; x 6
.190d	20 36 19	jsr $1936			jsr 	_CTIWMultiply
.1910	20 1c 19	jsr $191c			jsr 	_CTIWAddDigit 				; add digit
.1913	a9 0a		lda #$0a			lda 	#10 						; x 10
.1915	20 36 19	jsr $1936			jsr 	_CTIWMultiply
.1918	20 1c 19	jsr $191c			jsr 	_CTIWAddDigit 				; add digit
.191b	60		rts				rts
.191c					_CTIWAddDigit:
.191c	e6 22		inc $22				inc 	zsTemp 						; pre-increment
.191e	d0 02		bne $1922			bne 	_CTIWASkip
.1920	e6 23		inc $23				inc 	zsTemp+1
.1922					_CTIWASkip:
.1922	b2 22		lda ($22)			lda 	(zsTemp) 					; read and validate it
.1924	38		sec				sec
.1925	e9 30		sbc #$30			sbc 	#"0"
.1927	90 16		bcc $193f			bcc 	_CTIWError
.1929	c9 0a		cmp #$0a			cmp 	#9+1
.192b	b0 12		bcs $193f			bcs 	_CTIWError
.192d	e8		inx				inx 								; store at +1
.192e	20 76 26	jsr $2676			jsr 	FloatSetByte
.1931	ca		dex				dex
.1932	20 00 24	jsr $2400			jsr 	FloatAddTopTwoStack
.1935	60		rts				rts
.1936					_CTIWMultiply:
.1936	e8		inx				inx
.1937	20 76 26	jsr $2676			jsr 	FloatSetByte
.193a	ca		dex				dex
.193b	20 81 23	jsr $2381			jsr 	FloatMultiplyShort
.193e	60		rts				rts
.193f					_CTIWError:
.193f	4c 0f 1f	jmp $1f0f		jmp	ErrorV_value
.1942					UnaryUsr:
.1942	fa		plx				plx
.1943	5a		phy				phy
.1944	20 4b 19	jsr $194b			jsr 	_UUCallVector
.1947	7a		ply				ply
.1948	4c 4f 08	jmp $084f			jmp 	NextCommand
.194b					_UUCallVector:
.194b	6c 11 03	jmp ($0311)			jmp 	(USRRoutineAddress)
.194e					ValUnary:
.194e	fa		plx				plx
.194f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1951	85 2c		sta $2c				sta 	zTemp0
.1953	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1955	85 2d		sta $2d				sta 	zTemp0+1
.1957	20 62 19	jsr $1962			jsr 	ValEvaluateZTemp0
.195a	b0 03		bcs $195f			bcs 	_VUError 					; couldn't convert
.195c	4c 4f 08	jmp $084f			jmp 	NextCommand
.195f					_VUError:
.195f	4c 0f 1f	jmp $1f0f		jmp	ErrorV_value
.1962					ValEvaluateZTemp0:
.1962	5a		phy				phy
.1963	b2 2c		lda ($2c)			lda 	(zTemp0) 					; check not empty string
.1965	f0 22		beq $1989			beq 	_VMCFail2
.1967	a0 00		ldy #$00			ldy 	#0 							; start position
.1969					_VMCSpaces:
.1969	c8		iny				iny 								; skip leading spaces
.196a	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.196c	c9 20		cmp #$20			cmp 	#" "
.196e	f0 f9		beq $1969			beq 	_VMCSpaces
.1970	48		pha				pha 								; save first character
.1971	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.1973	d0 01		bne $1976			bne 	_VMCStart
.1975	c8		iny				iny 								; skip over - if so.
.1976					_VMCStart:
.1976	38		sec				sec 								; initialise first time round.
.1977					_VMCNext:
.1977	98		tya				tya 								; reached end of string
.1978	3a		dec a				dec 	a
.1979	52 2c		eor ($2c)			eor 	(zTemp0) 					; compare length preserve carry.
.197b	f0 0f		beq $198c			beq 	_VMCSuccess 				; successful.
.197d	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; encode a number.
.197f	c8		iny				iny
.1980	20 58 24	jsr $2458			jsr 	FloatEncode 				; send it to the number-builder
.1983	90 03		bcc $1988			bcc 	_VMCFail 					; if failed, give up.
.1985	18		clc				clc 								; next time round, countinue
.1986	80 ef		bra $1977			bra 	_VMCNext
.1988					_VMCFail:
.1988	68		pla				pla
.1989					_VMCFail2:
.1989	7a		ply				ply
.198a	38		sec				sec
.198b	60		rts				rts
.198c					_VMCSuccess:
.198c	a9 00		lda #$00			lda 	#0 							; construct final
.198e	20 58 24	jsr $2458			jsr 	FloatEncode 				; by sending a duff value.
.1991	68		pla				pla 								; if it was -ve
.1992	c9 2d		cmp #$2d			cmp 	#"-"
.1994	d0 03		bne $1999			bne 	_VMCNotNegative
.1996	20 36 26	jsr $2636			jsr		FloatNegate 				; negate it.
.1999					_VMCNotNegative:
.1999	7a		ply				ply
.199a	18		clc				clc
.199b	60		rts				rts
.199c					VectorTable:
>199c	a9 10					.word	LinkFloatAdd             ; $80 +
>199e	b2 10					.word	LinkFloatSubtract        ; $81 -
>19a0	bb 10					.word	LinkFloatMultiply        ; $82 *
>19a2	c4 10					.word	LinkFloatDivide          ; $83 /
>19a4	cf 10					.word	LinkFloatPower           ; $84 ^
>19a6	f2 08					.word	BinaryAnd                ; $85 and
>19a8	f6 08					.word	BinaryOr                 ; $86 or
>19aa	da 10					.word	LinkCompareGreater       ; $87 >
>19ac	e3 10					.word	LinkCompareEqual         ; $88 =
>19ae	ec 10					.word	LinkCompareLess          ; $89 <
>19b0	f5 10					.word	LinkCompareGreaterEqual  ; $8a >=
>19b2	fe 10					.word	LinkCompareNotEqual      ; $8b <>
>19b4	07 11					.word	LinkCompareLessEqual     ; $8c <=
>19b6	da 08					.word	AbsoluteTOS              ; $8d abs
>19b8	2d 09					.word	ArrayConvert             ; $8e array
>19ba	d5 09					.word	UnaryAsc                 ; $8f asc
>19bc	f0 09					.word	CommandAssert            ; $90 assert
>19be	31 0a					.word	Unary16Bin               ; $91 bin$
>19c0	5b 0a					.word	PrintCharacterX          ; $92 print.chr
>19c2	65 0a					.word	UnaryChr                 ; $93 chr$
>19c4	ca 0a					.word	CompareStrings           ; $94 s.cmp
>19c6	b6 0c					.word	CommandXFor              ; $95 for
>19c8	79 0d					.word	UnaryFre                 ; $96 fre
>19ca	91 0d					.word	CommandXGet              ; $97 get
>19cc	b7 0d					.word	CommandReturn            ; $98 return
>19ce	f9 0d					.word	Command_PSET             ; $99 pset
>19d0	13 0e					.word	Command_LINE             ; $9a line
>19d2	28 0e					.word	Command_RECT             ; $9b rect
>19d4	37 0e					.word	Command_FRAME            ; $9c frame
>19d6	46 0e					.word	Command_CHAR             ; $9d char
>19d8	dd 0e					.word	Unary16Hex               ; $9e hex$
>19da	84 0f					.word	CommandXInput            ; $9f input
>19dc	9b 0f					.word	CommandInputString       ; $a0 input$
>19de	b4 0f					.word	CommandInputReset        ; $a1 input.start
>19e0	98 10					.word	UnaryLen                 ; $a2 len
>19e2	64 11					.word	LinkFloatCompare         ; $a3 f.cmp
>19e4	6d 11					.word	LinkDivideInt32          ; $a4 int.div
>19e6	e7 11					.word	NegateTOS                ; $a5 negate
>19e8	ee 11					.word	CommandNewLine           ; $a6 new.line
>19ea	f7 11					.word	CommandXNext             ; $a7 next
>19ec	e0 12					.word	NotTOS                   ; $a8 not
>19ee	f7 12					.word	CommandXOn               ; $a9 on
>19f0	14 13					.word	CommandMoreOn            ; $aa moreon
>19f2	1b 13					.word	UnaryPeek                ; $ab peek
>19f4	30 13					.word	UnaryPI                  ; $ac pi
>19f6	3a 13					.word	CommandPOKE              ; $ad poke
>19f8	52 13					.word	UnaryPos                 ; $ae pos
>19fa	5c 13					.word	GetChannel               ; $af getchannel
>19fc	67 13					.word	SetChannel               ; $b0 setchannel
>19fe	8a 13					.word	PrintNumber              ; $b1 print.n
>1a00	a9 13					.word	PrintString              ; $b2 print.s
>1a02	10 14					.word	CommandXRead             ; $b3 read
>1a04	2a 14					.word	CommandReadString        ; $b4 read$
>1a06	b5 15					.word	UnaryRND                 ; $b5 rnd
>1a08	24 16					.word	StringConcatenate        ; $b6 concat
>1a0a	7b 16					.word	SignTOS                  ; $b7 sgn
>1a0c	9e 16					.word	PrintTab                 ; $b8 print.tab
>1a0e	ac 16					.word	PrintPos                 ; $b9 print.pos
>1a10	bd 16					.word	PrintSpace               ; $ba print.spc
>1a12	d6 16					.word	Unary_Str                ; $bb str$
>1a14	51 17					.word	Unary_Left               ; $bc left$
>1a16	61 17					.word	Unary_Right              ; $bd right$
>1a18	7d 17					.word	Unary_Mid                ; $be mid$
>1a1a	ef 17					.word	CommandSwap              ; $bf swap
>1a1c	65 18					.word	TimeTOS                  ; $c0 ti
>1a1e	6c 18					.word	TimeString               ; $c1 ti$
>1a20	42 19					.word	UnaryUsr                 ; $c2 usr
>1a22	4e 19					.word	ValUnary                 ; $c3 val
>1a24	b9 1b					.word	CommandClose             ; $c4 close
>1a26	cb 1b					.word	CommandExit              ; $c5 exit
>1a28	d1 1b					.word	CommandDebug             ; $c6 debug
>1a2a	37 1c					.word	CommandXOpen             ; $c7 open
>1a2c	cb 1c					.word	CommandScreen            ; $c8 screen
>1a2e	af 1e					.word	CommandVPOKE             ; $c9 vpoke
>1a30	d4 1e					.word	CommandVPEEK             ; $ca vpeek
>1a32	96 16					.word	CommandShift             ; $cb .shift
>1a34	9e 08					.word	PushByteCommand          ; $cc .byte
>1a36	b1 08					.word	PushWordCommand          ; $cd .word
>1a38	cc 13					.word	CommandPushN             ; $ce .float
>1a3a	f2 13					.word	CommandPushS             ; $cf .string
>1a3c	52 0b					.word	CommandXData             ; $d0 .data
>1a3e	c8 0d					.word	CommandXGoto             ; $d1 .goto
>1a40	ab 0d					.word	CommandXGosub            ; $d2 .gosub
>1a42	dd 0d					.word	CommandGotoZ             ; $d3 .goto.z
>1a44	eb 0d					.word	CommandGotoNZ            ; $d4 .goto.nz
>1a46	e0 08					.word	CommandVarSpace          ; $d5 .varspace
>1a48	55 0c					.word	Unimplemented            ; $d6 .restore
.1a4a					ShiftVectorTable:
>1a4a	7d 0a					.word	CommandClr               ; $cb80 clr
>1a4c	5b 0b					.word	CommandXDIM              ; $cb81 dim
>1a4e	4c 0c					.word	CommandEnd               ; $cb82 end
>1a50	69 10					.word	UnaryJoy                 ; $cb83 joy
>1a52	10 11					.word	LinkFloatIntegerPartDown ; $cb84 int
>1a54	19 11					.word	LinkFloatSquareRoot      ; $cb85 sqr
>1a56	2a 11					.word	LinkFloatLogarithm       ; $cb86 log
>1a58	35 11					.word	LinkFloatExponent        ; $cb87 exp
>1a5a	3e 11					.word	LinkFloatCosine          ; $cb88 cos
>1a5c	47 11					.word	LinkFloatSine            ; $cb89 sin
>1a5e	50 11					.word	LinkFloatTangent         ; $cb8a tan
>1a60	59 11					.word	LinkFloatArcTan          ; $cb8b atn
>1a62	97 11					.word	XCommandMouse            ; $cb8c mouse
>1a64	ac 11					.word	XUnaryMB                 ; $cb8d mb
>1a66	b9 11					.word	XUnaryMX                 ; $cb8e mx
>1a68	ca 11					.word	XUnaryMY                 ; $cb8f my
>1a6a	a3 15					.word	CommandRestoreX          ; $cb90 restore
>1a6c	d2 16					.word	CommandStop              ; $cb91 stop
>1a6e	2f 18					.word	CommandSYS               ; $cb92 sys
>1a70	d7 18					.word	CommandTIWrite           ; $cb93 ti$.write
>1a72	a8 1a					.word	CommandXWAIT             ; $cb94 wait
>1a74	fc 1b					.word	X16I2CPoke               ; $cb95 i2cpoke
>1a76	1c 1c					.word	X16I2CPeek               ; $cb96 i2cpeek
>1a78	87 1c					.word	CommandBank              ; $cb97 bank
>1a7a	da 1c					.word	XCommandSleep            ; $cb98 sleep
>1a7c	fe 1c					.word	X16_Audio_FMINIT         ; $cb99 fminit
>1a7e	0c 1d					.word	X16_Audio_FMNOTE         ; $cb9a fmnote
>1a80	1e 1d					.word	X16_Audio_FMDRUM         ; $cb9b fmdrum
>1a82	30 1d					.word	X16_Audio_FMINST         ; $cb9c fminst
>1a84	42 1d					.word	X16_Audio_FMVIB          ; $cb9d fmvib
>1a86	54 1d					.word	X16_Audio_FMFREQ         ; $cb9e fmfreq
>1a88	65 1d					.word	X16_Audio_FMVOL          ; $cb9f fmvol
>1a8a	77 1d					.word	X16_Audio_FMPAN          ; $cba0 fmpan
>1a8c	89 1d					.word	X16_Audio_FMPLAY         ; $cba1 fmplay
>1a8e	9a 1d					.word	X16_Audio_FMCHORD        ; $cba2 fmchord
>1a90	ab 1d					.word	X16_Audio_FMPOKE         ; $cba3 fmpoke
>1a92	bd 1d					.word	X16_Audio_PSGINIT        ; $cba4 psginit
>1a94	cb 1d					.word	X16_Audio_PSGNOTE        ; $cba5 psgnote
>1a96	dd 1d					.word	X16_Audio_PSGVOL         ; $cba6 psgvol
>1a98	ef 1d					.word	X16_Audio_PSGWAV         ; $cba7 psgwav
>1a9a	01 1e					.word	X16_Audio_PSGFREQ        ; $cba8 psgfreq
>1a9c	12 1e					.word	X16_Audio_PSGPAN         ; $cba9 psgpan
>1a9e	24 1e					.word	X16_Audio_PSGPLAY        ; $cbaa psgplay
>1aa0	35 1e					.word	X16_Audio_PSGCHORD       ; $cbab psgchord
>1aa2	46 1e					.word	CommandCls               ; $cbac cls
>1aa4	4f 1e					.word	CommandLocate            ; $cbad locate
>1aa6	76 1e					.word	CommandColor             ; $cbae color
.1aa8					CommandXWAIT:
.1aa8	fa		plx				plx
.1aa9	b5 3c		lda $3c,x			lda 	NSMantissa0-2,x 			; get wait address
.1aab	85 2c		sta $2c				sta 	zTemp0
.1aad	b5 48		lda $48,x			lda 	NSMantissa1-2,x
.1aaf	85 2d		sta $2d				sta 	zTemp0+1
.1ab1					_WaitLoop:
.1ab1	b2 2c		lda ($2c)			lda 	(zTemp0) 					; read it
.1ab3	35 3d		and $3d,x			and 	NSMantissa0-1,x		 		; and with mask
.1ab5	55 3e		eor $3e,x			eor 	NSMantissa0-0,x 			; toggle
.1ab7	f0 f8		beq $1ab1			beq 	_WaitLoop 					; keep going if zero
.1ab9	ca		dex				dex 								; drop 3.
.1aba	ca		dex				dex
.1abb	ca		dex				dex
.1abc	4c 4f 08	jmp $084f			jmp 	NextCommand
.1abf					WriteFloatCommand:
.1abf	fa		plx				plx
.1ac0	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1ac2	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1ac4	88		dey				dey 								; get the upper 3 bits
.1ac5	b1 28		lda ($28),y			lda 	(codePtr),y
.1ac7	29 07		and #$07			and 	#7
.1ac9	c8		iny				iny
.1aca	c8		iny				iny
.1acb	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1acd	2a		rol a				rol 	a 							; carry will be clear.
.1ace	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1ad1	85 2d		sta $2d				sta 	zTemp0+1
.1ad3	20 d9 1a	jsr $1ad9			jsr 	WriteFloatZTemp0Sub
.1ad6	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ad9					WriteFloatZTemp0Sub:
.1ad9	5a		phy				phy 								; ldart write
.1ada	a0 01		ldy #$01			ldy 	#1
.1adc	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1ade	92 2c		sta ($2c)			sta 	(zTemp0)
.1ae0	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ae2	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ae4	c8		iny				iny
.1ae5	b5 56		lda $56,x			lda 	NSMantissa2,x
.1ae7	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1ae9	c8		iny				iny
.1aea	b5 62		lda $62,x			lda 	NSMantissa3,x
.1aec	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1aee	c8		iny				iny
.1aef	b5 6e		lda $6e,x			lda 	NSExponent,x
.1af1	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1af3	c8		iny				iny
.1af4	b5 32		lda $32,x			lda 	NSStatus,x
.1af6	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1af8	ca		dex				dex
.1af9	7a		ply				ply
.1afa	60		rts				rts
.1afb					WriteIntegerCommand:
.1afb	fa		plx				plx
.1afc	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1afe	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b00	88		dey				dey 								; get the upper 3 bits
.1b01	b1 28		lda ($28),y			lda 	(codePtr),y
.1b03	29 07		and #$07			and 	#7
.1b05	c8		iny				iny
.1b06	c8		iny				iny
.1b07	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b09	2a		rol a				rol 	a 							; carry will be clear.
.1b0a	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b0d	85 2d		sta $2d				sta 	zTemp0+1
.1b0f	20 15 1b	jsr $1b15			jsr 	WriteIntegerZTemp0Sub
.1b12	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b15					WriteIntegerZTemp0Sub:
.1b15	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.1b18	5a		phy				phy 								; start write
.1b19	a0 01		ldy #$01			ldy 	#1
.1b1b	b5 32		lda $32,x			lda 	NSStatus,x 					; negate 2's comp if -ve
.1b1d	30 0b		bmi $1b2a			bmi 	_WIZNegative
.1b1f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; +ve write
.1b21	92 2c		sta ($2c)			sta 	(zTemp0)
.1b23	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b25	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b27	7a		ply				ply
.1b28	ca		dex				dex
.1b29	60		rts				rts
.1b2a					_WIZNegative:
.1b2a	38		sec				sec 								; -ve read
.1b2b	a9 00		lda #$00			lda 	#0
.1b2d	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.1b2f	92 2c		sta ($2c)			sta 	(zTemp0)
.1b31	a9 00		lda #$00			lda 	#0
.1b33	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.1b35	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b37	7a		ply				ply
.1b38	ca		dex				dex
.1b39	60		rts				rts
.1b3a					WriteStringCommand:
.1b3a	fa		plx				plx
.1b3b	b1 28		lda ($28),y			lda 	(codePtr),y 				; get the LSB of the halved offset.
.1b3d	85 2c		sta $2c				sta 	zTemp0 						; save in MSB
.1b3f	88		dey				dey 								; get the upper 3 bits
.1b40	b1 28		lda ($28),y			lda 	(codePtr),y
.1b42	29 07		and #$07			and 	#7
.1b44	c8		iny				iny
.1b45	c8		iny				iny
.1b46	06 2c		asl $2c				asl 	zTemp0 						; shift zTemp0:A left
.1b48	2a		rol a				rol 	a 							; carry will be clear.
.1b49	6d 07 04	adc $0407			adc 	variableStartPage			; make it point to variable page.
.1b4c	85 2d		sta $2d				sta 	zTemp0+1
.1b4e	20 54 1b	jsr $1b54			jsr 	WriteStringZTemp0Sub
.1b51	4c 4f 08	jmp $084f			jmp 	NextCommand
.1b54					WriteStringZTemp0Sub:
.1b54	5a		phy				phy
.1b55	a0 01		ldy #$01			ldy 	#1 							; if it is zero we must concrete whatever.
.1b57	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b59	11 2c		ora ($2c),y			ora 	(zTemp0),y
.1b5b	f0 1e		beq $1b7b			beq 	_WSConcrete
.1b5d	b2 2c		lda ($2c)			lda 	(zTemp0) 					; put address of actual string in zTemp1
.1b5f	85 2e		sta $2e				sta 	zTemp1
.1b61	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b63	85 2f		sta $2f				sta 	zTemp1+1
.1b65	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp2
.1b67	85 30		sta $30				sta 	zTemp2
.1b69	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b6b	85 31		sta $31				sta 	zTemp2+1
.1b6d	b2 2e		lda ($2e)			lda 	(zTemp1) 					; space available
.1b6f	d2 30		cmp ($30)			cmp 	(zTemp2) 					; if >= required length then copy
.1b71	b0 17		bcs $1b8a			bcs 	_WSCopy
.1b73	a0 01		ldy #$01			ldy 	#1 							; set the 'available for reclaim' flag
.1b75	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1b77	09 80		ora #$80			ora 	#$80
.1b79	91 2e		sta ($2e),y			sta 	(zTemp1),y
.1b7b					_WSConcrete:
.1b7b	b5 4a		lda $4a,x			lda 	NSMantissa1,x 				; string in YA
.1b7d	a8		tay				tay
.1b7e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1b80	20 0c 0b	jsr $0b0c			jsr 	StringConcrete
.1b83	92 2c		sta ($2c)			sta 	(zTemp0) 					; save returned address
.1b85	98		tya				tya
.1b86	a0 01		ldy #$01			ldy 	#1
.1b88	91 2c		sta ($2c),y			sta 	(zTemp0),y
.1b8a					_WSCopy
.1b8a	18		clc				clc  								; copy target+2 to zTemp2
.1b8b	b2 2c		lda ($2c)			lda 	(zTemp0)
.1b8d	69 02		adc #$02			adc 	#2
.1b8f	85 30		sta $30				sta 	zTemp2
.1b91	a0 01		ldy #$01			ldy 	#1
.1b93	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.1b95	69 00		adc #$00			adc 	#0
.1b97	85 31		sta $31				sta 	zTemp2+1
.1b99	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; copy source to zTemp1
.1b9b	85 2e		sta $2e				sta 	zTemp1
.1b9d	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1b9f	85 2f		sta $2f				sta 	zTemp1+1
.1ba1	b2 2e		lda ($2e)			lda 	(zTemp1) 					; length of string .. 0 inclusive
.1ba3	a8		tay				tay
.1ba4					_WSCopyLoop:
.1ba4	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.1ba6	91 30		sta ($30),y			sta 	(zTemp2),y
.1ba8	88		dey				dey
.1ba9	c0 ff		cpy #$ff			cpy 	#$FF
.1bab	d0 f7		bne $1ba4			bne 	_WSCopyLoop
.1bad	ca		dex				dex
.1bae	7a		ply				ply
.1baf	60		rts				rts
.1bb0					XCheckStop:
.1bb0	20 e1 ff	jsr $ffe1			jsr 	$FFE1 						; check stop
.1bb3	f0 01		beq $1bb6			beq 	_XCSStop
.1bb5	60		rts				rts
.1bb6					_XCSStop:
.1bb6	4c 31 20	jmp $2031		jmp	ErrorV_break
.1bb9					CommandClose:
.1bb9	fa		plx				plx
.1bba	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; channel to close
.1bbd	cd 5f 04	cmp $045f			cmp 	currentChannel 				; is it the current channel
.1bc0	d0 03		bne $1bc5			bne 	_CCNotCurrent
.1bc2	9c 5f 04	stz $045f			stz 	currentChannel 				; effectively disables CMD
.1bc5					_CCNotCurrent:
.1bc5	20 c3 ff	jsr $ffc3			jsr 	X16_CLOSE 					; close the file
.1bc8	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bcb					CommandExit:
.1bcb	fa		plx				plx
.1bcc	86 2c		stx $2c				stx 	zTemp0 						; stack position.
.1bce	4c ff ff	jmp $ffff			jmp 	$FFFF 						; exits the emulator.
.1bd1					CommandDebug:
.1bd1	fa		plx				plx
>1bd2	db						.byte 	$DB 						; causes a break in the emulator
.1bd3	4c 4f 08	jmp $084f			jmp 	NextCommand
.1bd6					XGetCharacterFromChannel:
.1bd6	da		phx				phx
.1bd7	5a		phy				phy
.1bd8	e0 00		cpx #$00			cpx 	#0 							; is it default
.1bda	d0 05		bne $1be1			bne 	_XGetChannel
.1bdc	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN 					; set default channel
.1bdf	80 08		bra $1be9			bra 	_XGetChar
.1be1					_XGetChannel:
.1be1	20 c6 ff	jsr $ffc6			jsr 	X16_CHKIN					; CHKIN set channel
.1be4	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1be7	d0 06		bne $1bef			bne 	_XGCError
.1be9					_XGetChar:
.1be9	20 e4 ff	jsr $ffe4			jsr 	X16_GETIN
.1bec	7a		ply				ply
.1bed	fa		plx				plx
.1bee	60		rts				rts
.1bef					_XGCError:
.1bef	4c 1b 20	jmp $201b		jmp	ErrorV_channel
.1bf2					XGetHPos:
.1bf2	da		phx				phx
.1bf3	5a		phy				phy
.1bf4	38		sec				sec
.1bf5	20 f0 ff	jsr $fff0			jsr 	X16_PLOT
.1bf8	98		tya				tya
.1bf9	7a		ply				ply
.1bfa	fa		plx				plx
.1bfb	60		rts				rts
.1bfc					X16I2CPoke:
.1bfc	fa		plx				plx
.1bfd	5a		phy				phy
.1bfe	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; value
.1c01	48		pha				pha
.1c02	ca		dex				dex
.1c03	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; register
.1c06	48		pha				pha
.1c07	ca		dex				dex
.1c08	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; device
.1c0b	aa		tax				tax
.1c0c	7a		ply				ply
.1c0d	68		pla				pla
.1c0e	20 c9 fe	jsr $fec9			jsr 	X16_i2c_write_byte 			; write the byte out.
.1c11	b0 06		bcs $1c19			bcs 	X16I2CError
.1c13	7a		ply				ply
.1c14	a2 ff		ldx #$ff			ldx 	#$FF
.1c16	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c19					X16I2CError:
.1c19	4c 1b 20	jmp $201b		jmp	ErrorV_channel
.1c1c					X16I2CPeek:
.1c1c	fa		plx				plx
.1c1d	da		phx				phx
.1c1e	5a		phy				phy
.1c1f	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; register
.1c22	48		pha				pha
.1c23	ca		dex				dex
.1c24	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; device
.1c27	aa		tax				tax 								; X device
.1c28	7a		ply				ply 								; Y register
.1c29	20 c6 fe	jsr $fec6			jsr 	X16_i2c_read_byte 			; read I2C
.1c2c	b0 eb		bcs $1c19			bcs 	X16I2CError
.1c2e	7a		ply				ply 								; restore Y/X
.1c2f	fa		plx				plx
.1c30	ca		dex				dex 								; drop TOS (register)
.1c31	20 76 26	jsr $2676			jsr 	FloatSetByte 				; write read value to TOS.
.1c34	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c37					CommandXOpen:
.1c37	fa		plx				plx
.1c38	a5 41		lda $41				lda 	NSMantissa0+3  				; point zTemp0 to string head, also in XY
.1c3a	85 2c		sta $2c				sta 	zTemp0
.1c3c	aa		tax				tax
.1c3d	a5 4d		lda $4d				lda 	NSMantissa1+3
.1c3f	85 2d		sta $2d				sta 	zTemp0+1
.1c41	a8		tay				tay
.1c42	e8		inx				inx 								; XY points to first character
.1c43	d0 01		bne $1c46			bne 	_CONoCarry
.1c45	c8		iny				iny
.1c46					_CONoCarry:
.1c46	b2 2c		lda ($2c)			lda 	(zTemp0) 					; get length of filename
.1c48	20 bd ff	jsr $ffbd			jsr 	X16_SETNAM
.1c4b	a5 3e		lda $3e				lda 	NSMantissa0+0
.1c4d	a6 3f		ldx $3f				ldx 	NSMantissa0+1
.1c4f	a4 40		ldy $40				ldy 	NSMantissa0+2
.1c51	20 ba ff	jsr $ffba			jsr 	X16_SETLFS
.1c54	20 c0 ff	jsr $ffc0			jsr 	X16_OPEN
.1c57	b0 03		bcs $1c5c			bcs 	_COError
.1c59	4c 4f 08	jmp $084f			jmp 	NextCommand
.1c5c					_COError:
.1c5c	4c 1b 20	jmp $201b		jmp	ErrorV_channel
.1c5f					XPokeMemory:
.1c5f	86 2c		stx $2c				stx 	zTemp0
.1c61	84 2d		sty $2d				sty 	zTemp0+1
.1c63	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c65	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c68	e0 ff		cpx #$ff			cpx 	#$FF
.1c6a	f0 02		beq $1c6e			beq 	_XPMNoSwitch
.1c6c	86 00		stx $00				stx 	SelectRAMBank
.1c6e					_XPMNoSwitch:
.1c6e	92 2c		sta ($2c)			sta 	(zTemp0) 					; do the POKE
.1c70	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM Bank.
.1c72					_XPMExit:
.1c72	60		rts				rts
.1c73					XPeekMemory:
.1c73	86 2c		stx $2c				stx 	zTemp0
.1c75	84 2d		sty $2d				sty 	zTemp0+1
.1c77	a4 00		ldy $00				ldy 	SelectRAMBank 				; old RAM bank in Y
.1c79	ae 6d 05	ldx $056d			ldx 	ramBank 					; switch to BANKed RAMBank if not $FF
.1c7c	e0 ff		cpx #$ff			cpx 	#$FF
.1c7e	f0 02		beq $1c82			beq 	_XPMNoSwitch
.1c80	86 00		stx $00				stx 	SelectRAMBank
.1c82					_XPMNoSwitch:
.1c82	b2 2c		lda ($2c)			lda 	(zTemp0) 					; do the PEEK
.1c84	84 00		sty $00				sty 	SelectRAMBank 				; reselect previous RAM bank.
.1c86	60		rts				rts
.1c87					CommandBank:
.1c87	fa		plx				plx
.1c88	a5 3e		lda $3e				lda 	NSMantissa0 				; RAM bank
.1c8a	8d 6d 05	sta $056d			sta 	ramBank 					; store & make current
.1c8d	85 00		sta $00				sta 	SelectRAMBank
.1c8f	a5 3f		lda $3f				lda 	NSMantissa0+1 		 		; ROM specified
.1c91	c9 ff		cmp #$ff			cmp 	#$FF
.1c93	f0 03		beq $1c98			beq 	_CBNoUpdate
.1c95	8d 6e 05	sta $056e			sta 	romBank 					; this doesn't set the hardware page.
.1c98					_CBNoUpdate:
.1c98	a2 ff		ldx #$ff			ldx 	#$FF
.1c9a	4c 4f 08	jmp $084f			jmp 	NextCommand
.056d					ramBank:
>056d							.fill 	1
.056e					romBank:
>056e							.fill 	1
.1c9d					XPrintCharacterToChannel:
.1c9d	48		pha				pha
.1c9e	da		phx				phx
.1c9f	5a		phy				phy
.1ca0	48		pha				pha  								; save char
.1ca1	e0 00		cpx #$00			cpx 	#0 							; check default (0)
.1ca3	d0 05		bne $1caa			bne 	_XPCNotDefault
.1ca5	20 cc ff	jsr $ffcc			jsr 	X16_CLRCHN					; set default channel
.1ca8	80 08		bra $1cb2			bra 	_XPCSend
.1caa					_XPCNotDefault:
.1caa	20 c9 ff	jsr $ffc9			jsr 	X16_CHKOUT 					; CHKOUT set channel
.1cad	20 b7 ff	jsr $ffb7			jsr 	X16_READST 					; check okay
.1cb0	d0 08		bne $1cba			bne 	_XPCError
.1cb2					_XPCSend:
.1cb2	68		pla				pla 								; restore character
.1cb3	20 d2 ff	jsr $ffd2			jsr 	X16_BSOUT 					; print
.1cb6	7a		ply				ply
.1cb7	fa		plx				plx
.1cb8	68		pla				pla
.1cb9	60		rts				rts
.1cba					_XPCError:
.1cba	4c 1b 20	jmp $201b		jmp	ErrorV_channel
.1cbd					XReadClock:
.1cbd	20 de ff	jsr $ffde			jsr 	X16_RDTIM
.1cc0	60		rts				rts
.1cc1					XWriteClock:
.1cc1	48		pha				pha
.1cc2	da		phx				phx
.1cc3	5a		phy				phy
.1cc4	20 db ff	jsr $ffdb			jsr 	X16_SETTIM
.1cc7	7a		ply				ply
.1cc8	fa		plx				plx
.1cc9	68		pla				pla
.1cca	60		rts				rts
.1ccb					CommandScreen:
.1ccb	fa		plx				plx
.1ccc	da		phx				phx
.1ccd	5a		phy				phy
.1cce	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1cd1	18		clc				clc
.1cd2	20 5f ff	jsr $ff5f			jsr 	X16_screen_mode
.1cd5	7a		ply				ply
.1cd6	fa		plx				plx
.1cd7	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cda					XCommandSleep:
.1cda	fa		plx				plx
.1cdb	5a		phy				phy
.1cdc	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.1cdf	ca		dex				dex
.1ce0	20 bd 1c	jsr $1cbd			jsr 	XReadClock 					; read clock to YXA
.1ce3	18		clc				clc 								; calculate end time in zTemp0
.1ce4	65 3e		adc $3e				adc 	NSMantissa0
.1ce6	85 2c		sta $2c				sta 	zTemp0
.1ce8	8a		txa				txa
.1ce9	65 4a		adc $4a				adc 	NSMantissa1
.1ceb	85 2d		sta $2d				sta 	zTemp0+1
.1ced					_XCWait:
.1ced	20 bd 1c	jsr $1cbd			jsr 	XReadClock 					; and wait for it.
.1cf0	c5 2c		cmp $2c				cmp 	zTemp0
.1cf2	d0 f9		bne $1ced			bne 	_XCWait
.1cf4	e4 2d		cpx $2d				cpx 	zTemp0+1
.1cf6	d0 f5		bne $1ced			bne 	_XCWait
.1cf8	a2 ff		ldx #$ff			ldx 	#$FF
.1cfa	7a		ply				ply
.1cfb	4c 4f 08	jmp $084f			jmp 	NextCommand
.1cfe					X16_Audio_FMINIT:
.1cfe	fa		plx				plx
.1cff	5a		phy			phy
.1d00	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d03	63 c0					.word	X16A_ym_init
>1d05	0a					.byte	X16_AudioCodeBank
.1d06	a2 ff		ldx #$ff		ldx	#$FF
.1d08	7a		ply			ply
.1d09	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d0c					X16_Audio_FMNOTE:
.1d0c	fa		plx				plx
.1d0d	5a		phy			phy
.1d0e	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d11	18		clc			clc
.1d12	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d15	03 c0					.word	X16A_bas_fmnote
>1d17	0a					.byte	X16_AudioCodeBank
.1d18	a2 ff		ldx #$ff		ldx	#$FF
.1d1a	7a		ply			ply
.1d1b	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d1e					X16_Audio_FMDRUM:
.1d1e	fa		plx				plx
.1d1f	5a		phy			phy
.1d20	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d23	18		clc			clc
.1d24	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d27	6f c0					.word	X16A_ym_playdrum
>1d29	0a					.byte	X16_AudioCodeBank
.1d2a	a2 ff		ldx #$ff		ldx	#$FF
.1d2c	7a		ply			ply
.1d2d	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d30					X16_Audio_FMINST:
.1d30	fa		plx				plx
.1d31	5a		phy			phy
.1d32	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d35	38		sec			sec
.1d36	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d39	69 c0					.word	X16A_ym_loadpatch
>1d3b	0a					.byte	X16_AudioCodeBank
.1d3c	a2 ff		ldx #$ff		ldx	#$FF
.1d3e	7a		ply			ply
.1d3f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d42					X16_Audio_FMVIB:
.1d42	fa		plx				plx
.1d43	5a		phy			phy
.1d44	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d47	18		clc			clc
.1d48	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d4b	09 c0					.word	X16A_bas_fmvib
>1d4d	0a					.byte	X16_AudioCodeBank
.1d4e	a2 ff		ldx #$ff		ldx	#$FF
.1d50	7a		ply			ply
.1d51	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d54					X16_Audio_FMFREQ:
.1d54	fa		plx				plx
.1d55	5a		phy			phy
.1d56	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1d59	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d5c	00 c0					.word	X16A_bas_fmfreq
>1d5e	0a					.byte	X16_AudioCodeBank
.1d5f	a2 ff		ldx #$ff		ldx	#$FF
.1d61	7a		ply			ply
.1d62	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d65					X16_Audio_FMVOL:
.1d65	fa		plx				plx
.1d66	5a		phy			phy
.1d67	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d6a	18		clc			clc
.1d6b	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d6e	75 c0					.word	X16A_ym_setatten
>1d70	0a					.byte	X16_AudioCodeBank
.1d71	a2 ff		ldx #$ff		ldx	#$FF
.1d73	7a		ply			ply
.1d74	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d77					X16_Audio_FMPAN:
.1d77	fa		plx				plx
.1d78	5a		phy			phy
.1d79	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1d7c	18		clc			clc
.1d7d	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d80	7e c0					.word	X16A_ym_setpan
>1d82	0a					.byte	X16_AudioCodeBank
.1d83	a2 ff		ldx #$ff		ldx	#$FF
.1d85	7a		ply			ply
.1d86	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d89					X16_Audio_FMPLAY:
.1d89	fa		plx				plx
.1d8a	5a		phy			phy
.1d8b	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1d8e	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1d91	06 c0					.word	X16A_bas_fmplaystring
>1d93	0a					.byte	X16_AudioCodeBank
.1d94	a2 ff		ldx #$ff		ldx	#$FF
.1d96	7a		ply			ply
.1d97	4c 4f 08	jmp $084f			jmp 	NextCommand
.1d9a					X16_Audio_FMCHORD:
.1d9a	fa		plx				plx
.1d9b	5a		phy			phy
.1d9c	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1d9f	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1da2	8d c0					.word	X16A_bas_fmchordstring
>1da4	0a					.byte	X16_AudioCodeBank
.1da5	a2 ff		ldx #$ff		ldx	#$FF
.1da7	7a		ply			ply
.1da8	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dab					X16_Audio_FMPOKE:
.1dab	fa		plx				plx
.1dac	5a		phy			phy
.1dad	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1db0	18		clc			clc
.1db1	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1db4	8a c0					.word	X16A_ym_write
>1db6	0a					.byte	X16_AudioCodeBank
.1db7	a2 ff		ldx #$ff		ldx	#$FF
.1db9	7a		ply			ply
.1dba	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dbd					X16_Audio_PSGINIT:
.1dbd	fa		plx				plx
.1dbe	5a		phy			phy
.1dbf	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dc2	4b c0					.word	X16A_psg_init
>1dc4	0a					.byte	X16_AudioCodeBank
.1dc5	a2 ff		ldx #$ff		ldx	#$FF
.1dc7	7a		ply			ply
.1dc8	4c 4f 08	jmp $084f			jmp 	NextCommand
.1dcb					X16_Audio_PSGNOTE:
.1dcb	fa		plx				plx
.1dcc	5a		phy			phy
.1dcd	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1dd0	18		clc			clc
.1dd1	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1dd4	12 c0					.word	X16A_bas_psgnote
>1dd6	0a					.byte	X16_AudioCodeBank
.1dd7	a2 ff		ldx #$ff		ldx	#$FF
.1dd9	7a		ply			ply
.1dda	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ddd					X16_Audio_PSGVOL:
.1ddd	fa		plx				plx
.1dde	5a		phy			phy
.1ddf	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1de2	18		clc			clc
.1de3	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1de6	54 c0					.word	X16A_psg_setatten
>1de8	0a					.byte	X16_AudioCodeBank
.1de9	a2 ff		ldx #$ff		ldx	#$FF
.1deb	7a		ply			ply
.1dec	4c 4f 08	jmp $084f			jmp 	NextCommand
.1def					X16_Audio_PSGWAV:
.1def	fa		plx				plx
.1df0	5a		phy			phy
.1df1	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1df4	18		clc			clc
.1df5	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1df8	15 c0					.word	X16A_bas_psgwav
>1dfa	0a					.byte	X16_AudioCodeBank
.1dfb	a2 ff		ldx #$ff		ldx	#$FF
.1dfd	7a		ply			ply
.1dfe	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e01					X16_Audio_PSGFREQ:
.1e01	fa		plx				plx
.1e02	5a		phy			phy
.1e03	20 01 0a	jsr $0a01		jsr		X16_Audio_Parameters8_16
.1e06	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e09	0f c0					.word	X16A_bas_psgfreq
>1e0b	0a					.byte	X16_AudioCodeBank
.1e0c	a2 ff		ldx #$ff		ldx	#$FF
.1e0e	7a		ply			ply
.1e0f	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e12					X16_Audio_PSGPAN:
.1e12	fa		plx				plx
.1e13	5a		phy			phy
.1e14	20 07 0a	jsr $0a07		jsr		X16_Audio_Parameters8_8
.1e17	18		clc			clc
.1e18	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e1b	5a c0					.word	X16A_psg_setpan
>1e1d	0a					.byte	X16_AudioCodeBank
.1e1e	a2 ff		ldx #$ff		ldx	#$FF
.1e20	7a		ply			ply
.1e21	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e24					X16_Audio_PSGPLAY:
.1e24	fa		plx				plx
.1e25	5a		phy			phy
.1e26	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e29	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e2c	18 c0					.word	X16A_bas_psgplaystring
>1e2e	0a					.byte	X16_AudioCodeBank
.1e2f	a2 ff		ldx #$ff		ldx	#$FF
.1e31	7a		ply			ply
.1e32	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e35					X16_Audio_PSGCHORD:
.1e35	fa		plx				plx
.1e36	5a		phy			phy
.1e37	20 18 0a	jsr $0a18		jsr		X16_Audio_Parameters8_String
.1e3a	20 6e ff	jsr $ff6e		jsr		X16_JSRFAR
>1e3d	90 c0					.word	X16A_bas_psgchordstring
>1e3f	0a					.byte	X16_AudioCodeBank
.1e40	a2 ff		ldx #$ff		ldx	#$FF
.1e42	7a		ply			ply
.1e43	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e46					CommandCls:
.1e46	fa		plx				plx
.1e47	a9 93		lda #$93			lda 	#147
.1e49	20 9d 1c	jsr $1c9d			jsr 	XPrintCharacterToChannel
.1e4c	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e4f					CommandLocate:
.1e4f	fa		plx				plx
.1e50	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.1e53	ca		dex				dex
.1e54	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.1e57	ca		dex				dex
.1e58	48		pha				pha 								; save registers
.1e59	da		phx				phx
.1e5a	5a		phy				phy
.1e5b	18		clc				clc
.1e5c	a4 3f		ldy $3f				ldy 	NSMantissa0+1 				; get coords
.1e5e	a6 3e		ldx $3e				ldx 	NSMantissa0
.1e60	88		dey				dey 								; fix up
.1e61	ca		dex				dex
.1e62	20 f0 ff	jsr $fff0			jsr 	$FFF0 						; PLOT
.1e65	7a		ply				ply 								; restore registers
.1e66	fa		plx				plx
.1e67	68		pla				pla
.1e68	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e6b					_CLOutputXA:
.1e6b	ca		dex				dex
.1e6c	f0 07		beq $1e75			beq 	_CLOExit
.1e6e	30 05		bmi $1e75			bmi 	_CLOExit
.1e70	20 9d 1c	jsr $1c9d			jsr 	XPrintCharacterToChannel
.1e73	80 f6		bra $1e6b			bra 	_CLOutputXA
.1e75					_CLOExit:
.1e75	60		rts				rts
.1e76					CommandColor:
.1e76	fa		plx				plx
.1e77	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.1e7a	ca		dex				dex
.1e7b	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.1e7e	ca		dex				dex
.1e7f	a5 3f		lda $3f				lda 	NSMantissa0+1 				; bgr specified
.1e81	c9 ff		cmp #$ff			cmp 	#$FF
.1e83	f0 08		beq $1e8d			beq 	_CCNoBGR 					; if so, change background
.1e85	20 95 1e	jsr $1e95			jsr 	_CCSetColour
.1e88	a9 01		lda #$01			lda 	#$01 						; swap FGR/BGR
.1e8a	20 9d 1c	jsr $1c9d			jsr 	XPrintCharacterToChannel
.1e8d					_CCNoBGR:
.1e8d	a5 3e		lda $3e				lda 	NSMantissa0
.1e8f	20 95 1e	jsr $1e95			jsr 	_CCSetColour
.1e92	4c 4f 08	jmp $084f			jmp 	NextCommand
.1e95					_CCSetColour:
.1e95	29 0f		and #$0f			and 	#15 						; look up in control codes table.
.1e97	aa		tax				tax
.1e98	bd 9f 1e	lda $1e9f,x			lda 	_CCCommandTable,x
.1e9b	20 9d 1c	jsr $1c9d			jsr 	XPrintCharacterToChannel
.1e9e	60		rts				rts
.1e9f					_CCCommandTable:
>1e9f	90 05 1c 9f 9c 1e 1f 9e				.byte	 $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>1ea7	81 95 96 97 98 99 9a 9b				.byte	 $81,$95,$96,$97,$98,$99,$9a,$9b
.1eaf					CommandVPOKE:
.1eaf	fa		plx				plx
.1eb0	20 41 10	jsr $1041			jsr 	GetInteger8Bit 				; poke value
.1eb3	48		pha				pha
.1eb4	ca		dex				dex
.1eb5	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.1eb8	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1eba	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1ebd	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1ebf	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ec2	ca		dex				dex
.1ec3	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.1ec6	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1ec9	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1ecc	ca		dex				dex
.1ecd	68		pla				pla 								; poke value back
.1ece	8d 23 9f	sta $9f23			sta 	VRAMData0					; and write it out.
.1ed1	4c 4f 08	jmp $084f			jmp 	NextCommand
.1ed4					CommandVPEEK:
.1ed4	fa		plx				plx
.1ed5	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.1ed8	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.1eda	8d 20 9f	sta $9f20			sta 	VRAMLow0
.1edd	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.1edf	8d 21 9f	sta $9f21			sta 	VRAMMed0
.1ee2	ca		dex				dex
.1ee3	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.1ee6	20 41 10	jsr $1041			jsr 	GetInteger8Bit
.1ee9	8d 22 9f	sta $9f22			sta 	VRAMHigh0
.1eec	ad 23 9f	lda $9f23			lda 	VRAMData0					; read data
.1eef	20 76 26	jsr $2676			jsr 	FloatSetByte 				; return as byte
.1ef2	4c 4f 08	jmp $084f			jmp 	NextCommand

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/common.library

=$80					C64_END                  = $80 ; $80 end
=$81					C64_FOR                  = $81 ; $81 for
=$82					C64_NEXT                 = $82 ; $82 next
=$83					C64_DATA                 = $83 ; $83 data
=$84					C64_INPUTHASH            = $84 ; $84 input#
=$85					C64_INPUT                = $85 ; $85 input
=$86					C64_DIM                  = $86 ; $86 dim
=$87					C64_READ                 = $87 ; $87 read
=$88					C64_LET                  = $88 ; $88 let
=$89					C64_GOTO                 = $89 ; $89 goto
=$8a					C64_RUN                  = $8a ; $8a run
=$8b					C64_IF                   = $8b ; $8b if
=$8c					C64_RESTORE              = $8c ; $8c restore
=$8d					C64_GOSUB                = $8d ; $8d gosub
=$8e					C64_RETURN               = $8e ; $8e return
=$8f					C64_REM                  = $8f ; $8f rem
=$90					C64_STOP                 = $90 ; $90 stop
=$91					C64_ON                   = $91 ; $91 on
=$92					C64_WAIT                 = $92 ; $92 wait
=$93					C64_LOAD                 = $93 ; $93 load
=$94					C64_SAVE                 = $94 ; $94 save
=$95					C64_VERIFY               = $95 ; $95 verify
=$96					C64_DEF                  = $96 ; $96 def
=$97					C64_POKE                 = $97 ; $97 poke
=$98					C64_PRINTHASH            = $98 ; $98 print#
=$99					C64_PRINT                = $99 ; $99 print
=$9a					C64_CONT                 = $9a ; $9a cont
=$9b					C64_LIST                 = $9b ; $9b list
=$9c					C64_CLR                  = $9c ; $9c clr
=$9d					C64_CMD                  = $9d ; $9d cmd
=$9e					C64_SYS                  = $9e ; $9e sys
=$9f					C64_OPEN                 = $9f ; $9f open
=$a0					C64_CLOSE                = $a0 ; $a0 close
=$a1					C64_GET                  = $a1 ; $a1 get
=$a2					C64_NEW                  = $a2 ; $a2 new
=$a3					C64_TABLB                = $a3 ; $a3 tab(
=$a4					C64_TO                   = $a4 ; $a4 to
=$a5					C64_FN                   = $a5 ; $a5 fn
=$a6					C64_SPCLB                = $a6 ; $a6 spc(
=$a7					C64_THEN                 = $a7 ; $a7 then
=$a8					C64_NOT                  = $a8 ; $a8 not
=$a9					C64_STEP                 = $a9 ; $a9 step
=$aa					C64_PLUS                 = $aa ; $aa +
=$ab					C64_MINUS                = $ab ; $ab -
=$ac					C64_TIMES                = $ac ; $ac *
=$ad					C64_DIVIDE               = $ad ; $ad /
=$ae					C64_POWER                = $ae ; $ae ^
=$af					C64_AND                  = $af ; $af and
=$b0					C64_OR                   = $b0 ; $b0 or
=$b1					C64_GREATER              = $b1 ; $b1 >
=$b2					C64_EQUAL                = $b2 ; $b2 =
=$b3					C64_LESS                 = $b3 ; $b3 <
=$b4					C64_SGN                  = $b4 ; $b4 sgn
=$b5					C64_INT                  = $b5 ; $b5 int
=$b6					C64_ABS                  = $b6 ; $b6 abs
=$b7					C64_USR                  = $b7 ; $b7 usr
=$b8					C64_FRE                  = $b8 ; $b8 fre
=$b9					C64_POS                  = $b9 ; $b9 pos
=$ba					C64_SQR                  = $ba ; $ba sqr
=$bb					C64_RND                  = $bb ; $bb rnd
=$bc					C64_LOG                  = $bc ; $bc log
=$bd					C64_EXP                  = $bd ; $bd exp
=$be					C64_COS                  = $be ; $be cos
=$bf					C64_SIN                  = $bf ; $bf sin
=$c0					C64_TAN                  = $c0 ; $c0 tan
=$c1					C64_ATN                  = $c1 ; $c1 atn
=$c2					C64_PEEK                 = $c2 ; $c2 peek
=$c3					C64_LEN                  = $c3 ; $c3 len
=$c4					C64_STRDOLLAR            = $c4 ; $c4 str$
=$c5					C64_VAL                  = $c5 ; $c5 val
=$c6					C64_ASC                  = $c6 ; $c6 asc
=$c7					C64_CHRDOLLAR            = $c7 ; $c7 chr$
=$c8					C64_LEFTDOLLAR           = $c8 ; $c8 left$
=$c9					C64_RIGHTDOLLAR          = $c9 ; $c9 right$
=$ca					C64_MIDDOLLAR            = $ca ; $ca mid$
=$cb					C64_GO                   = $cb ; $cb go
=$ff					C64_PI                   = $ff ; $ff pi
=$ce80					C64_MON                  = $ce80 ; $ce80 mon
=$ce81					C64_DOS                  = $ce81 ; $ce81 dos
=$ce82					C64_OLD                  = $ce82 ; $ce82 old
=$ce83					C64_GEOS                 = $ce83 ; $ce83 geos
=$ce84					C64_VPOKE                = $ce84 ; $ce84 vpoke
=$ce85					C64_VLOAD                = $ce85 ; $ce85 vload
=$ce86					C64_SCREEN               = $ce86 ; $ce86 screen
=$ce87					C64_PSET                 = $ce87 ; $ce87 pset
=$ce88					C64_LINE                 = $ce88 ; $ce88 line
=$ce89					C64_FRAME                = $ce89 ; $ce89 frame
=$ce8a					C64_RECT                 = $ce8a ; $ce8a rect
=$ce8b					C64_CHAR                 = $ce8b ; $ce8b char
=$ce8c					C64_MOUSE                = $ce8c ; $ce8c mouse
=$ce8d					C64_COLOR                = $ce8d ; $ce8d color
=$ce8e					C64_TEST                 = $ce8e ; $ce8e test
=$ce8f					C64_RESET                = $ce8f ; $ce8f reset
=$ce90					C64_CLS                  = $ce90 ; $ce90 cls
=$ce91					C64_CODEX                = $ce91 ; $ce91 codex
=$ce92					C64_LOCATE               = $ce92 ; $ce92 locate
=$ce93					C64_BOOT                 = $ce93 ; $ce93 boot
=$ce94					C64_KEYMAP               = $ce94 ; $ce94 keymap
=$ce95					C64_BLOAD                = $ce95 ; $ce95 bload
=$ce96					C64_BVLOAD               = $ce96 ; $ce96 bvload
=$ce97					C64_BVERIFY              = $ce97 ; $ce97 bverify
=$ce98					C64_BANK                 = $ce98 ; $ce98 bank
=$ce99					C64_FMINIT               = $ce99 ; $ce99 fminit
=$ce9a					C64_FMNOTE               = $ce9a ; $ce9a fmnote
=$ce9b					C64_FMDRUM               = $ce9b ; $ce9b fmdrum
=$ce9c					C64_FMINST               = $ce9c ; $ce9c fminst
=$ce9d					C64_FMVIB                = $ce9d ; $ce9d fmvib
=$ce9e					C64_FMFREQ               = $ce9e ; $ce9e fmfreq
=$ce9f					C64_FMVOL                = $ce9f ; $ce9f fmvol
=$cea0					C64_FMPAN                = $cea0 ; $cea0 fmpan
=$cea1					C64_FMPLAY               = $cea1 ; $cea1 fmplay
=$cea2					C64_FMCHORD              = $cea2 ; $cea2 fmchord
=$cea3					C64_FMPOKE               = $cea3 ; $cea3 fmpoke
=$cea4					C64_PSGINIT              = $cea4 ; $cea4 psginit
=$cea5					C64_PSGNOTE              = $cea5 ; $cea5 psgnote
=$cea6					C64_PSGVOL               = $cea6 ; $cea6 psgvol
=$cea7					C64_PSGWAV               = $cea7 ; $cea7 psgwav
=$cea8					C64_PSGFREQ              = $cea8 ; $cea8 psgfreq
=$cea9					C64_PSGPAN               = $cea9 ; $cea9 psgpan
=$ceaa					C64_PSGPLAY              = $ceaa ; $ceaa psgplay
=$ceab					C64_PSGCHORD             = $ceab ; $ceab psgchord
=$ceac					C64_REBOOT               = $ceac ; $ceac reboot
=$cead					C64_POWEROFF             = $cead ; $cead poweroff
=$ceae					C64_I2CPOKE              = $ceae ; $ceae i2cpoke
=$ceaf					C64_SLEEP                = $ceaf ; $ceaf sleep
=$ceb0					C64_BSAVE                = $ceb0 ; $ceb0 bsave
=$ceb1					C64_MENU                 = $ceb1 ; $ceb1 menu
=$ceb2					C64_REN                  = $ceb2 ; $ceb2 ren
=$ceb3					C64_LINPUT               = $ceb3 ; $ceb3 linput
=$ceb4					C64_LINPUTHASH           = $ceb4 ; $ceb4 linput#
=$ceb5					C64_BINPUTHASH           = $ceb5 ; $ceb5 binput#
=$ceb6					C64_HELP                 = $ceb6 ; $ceb6 help
=$ceb7					C64_BANNER               = $ceb7 ; $ceb7 banner
=$ceb8					C64_EXEC                 = $ceb8 ; $ceb8 exec
=$ceb9					C64_TILE                 = $ceb9 ; $ceb9 tile
=$ceba					C64_EDIT                 = $ceba ; $ceba edit
=$ced0					C64_VPEEK                = $ced0 ; $ced0 vpeek
=$ced1					C64_MX                   = $ced1 ; $ced1 mx
=$ced2					C64_MY                   = $ced2 ; $ced2 my
=$ced3					C64_MB                   = $ced3 ; $ced3 mb
=$ced4					C64_JOY                  = $ced4 ; $ced4 joy
=$ced5					C64_HEXDOLLAR            = $ced5 ; $ced5 hex$
=$ced6					C64_BINDOLLAR            = $ced6 ; $ced6 bin$
=$ced7					C64_I2CPEEK              = $ced7 ; $ced7 i2cpeek
=$ced8					C64_POINTER              = $ced8 ; $ced8 pointer
=$ced9					C64_STRPTR               = $ced9 ; $ced9 strptr
=$ceda					C64_RPTDOLLAR            = $ceda ; $ceda rpt$
=$cedb					C64_MWHEEL               = $cedb ; $cedb mwheel
=$801					CodeStart = $801
=$22					ZeroPageMandatory = $22
=$400					MemoryStorage = $400
.0028					codePtr:
>0028							.fill 	2
.002a					objPtr:
>002a							.fill 	2
.002c					zTemp0:
>002c							.fill 	2
.002e					zTemp1:
>002e							.fill 	2
.0030					zTemp2:
>0030							.fill 	2
=$80					PCD_STARTBINARY = $80
=$8d					PCD_ENDBINARY = $8d
=$8d					PCD_STARTCOMMAND = $8d
=$cb					PCD_ENDCOMMAND = $cb
=$cb					PCD_STARTSYSTEM = $cb
=$d7					PCD_ENDSYSTEM = $d7
=$80					PCD_PLUS             = $80 ; +
=$81					PCD_MINUS            = $81 ; -
=$82					PCD_TIMES            = $82 ; *
=$83					PCD_DIVIDE           = $83 ; /
=$84					PCD_POWER            = $84 ; ^
=$85					PCD_AND              = $85 ; and
=$86					PCD_OR               = $86 ; or
=$87					PCD_GREATER          = $87 ; >
=$88					PCD_EQUAL            = $88 ; =
=$89					PCD_LESS             = $89 ; <
=$8a					PCD_GREATEREQUAL     = $8a ; >=
=$8b					PCD_LESSGREATER      = $8b ; <>
=$8c					PCD_LESSEQUAL        = $8c ; <=
=$8d					PCD_ABS              = $8d ; abs
=$8e					PCD_ARRAY            = $8e ; array
=$8f					PCD_ASC              = $8f ; asc
=$90					PCD_ASSERT           = $90 ; assert
=$91					PCD_BINDOLLAR        = $91 ; bin$
=$92					PCD_PRINTCMD_CHR     = $92 ; print.chr
=$93					PCD_CHRDOLLAR        = $93 ; chr$
=$94					PCD_SCMD_CMP         = $94 ; s.cmp
=$95					PCD_FOR              = $95 ; for
=$96					PCD_FRE              = $96 ; fre
=$97					PCD_GET              = $97 ; get
=$98					PCD_RETURN           = $98 ; return
=$99					PCD_PSET             = $99 ; pset
=$9a					PCD_LINE             = $9a ; line
=$9b					PCD_RECT             = $9b ; rect
=$9c					PCD_FRAME            = $9c ; frame
=$9d					PCD_CHAR             = $9d ; char
=$9e					PCD_HEXDOLLAR        = $9e ; hex$
=$9f					PCD_INPUT            = $9f ; input
=$a0					PCD_INPUTDOLLAR      = $a0 ; input$
=$a1					PCD_INPUTCMD_START   = $a1 ; input.start
=$a2					PCD_LEN              = $a2 ; len
=$a3					PCD_FCMD_CMP         = $a3 ; f.cmp
=$a4					PCD_INTCMD_DIV       = $a4 ; int.div
=$a5					PCD_NEGATE           = $a5 ; negate
=$a6					PCD_NEWCMD_LINE      = $a6 ; new.line
=$a7					PCD_NEXT             = $a7 ; next
=$a8					PCD_NOT              = $a8 ; not
=$a9					PCD_ON               = $a9 ; on
=$aa					PCD_MOREON           = $aa ; moreon
=$ab					PCD_PEEK             = $ab ; peek
=$ac					PCD_PI               = $ac ; pi
=$ad					PCD_POKE             = $ad ; poke
=$ae					PCD_POS              = $ae ; pos
=$af					PCD_GETCHANNEL       = $af ; getchannel
=$b0					PCD_SETCHANNEL       = $b0 ; setchannel
=$b1					PCD_PRINTCMD_N       = $b1 ; print.n
=$b2					PCD_PRINTCMD_S       = $b2 ; print.s
=$b3					PCD_READ             = $b3 ; read
=$b4					PCD_READDOLLAR       = $b4 ; read$
=$b5					PCD_RND              = $b5 ; rnd
=$b6					PCD_CONCAT           = $b6 ; concat
=$b7					PCD_SGN              = $b7 ; sgn
=$b8					PCD_PRINTCMD_TAB     = $b8 ; print.tab
=$b9					PCD_PRINTCMD_POS     = $b9 ; print.pos
=$ba					PCD_PRINTCMD_SPC     = $ba ; print.spc
=$bb					PCD_STRDOLLAR        = $bb ; str$
=$bc					PCD_LEFTDOLLAR       = $bc ; left$
=$bd					PCD_RIGHTDOLLAR      = $bd ; right$
=$be					PCD_MIDDOLLAR        = $be ; mid$
=$bf					PCD_SWAP             = $bf ; swap
=$c0					PCD_TI               = $c0 ; ti
=$c1					PCD_TIDOLLAR         = $c1 ; ti$
=$c2					PCD_USR              = $c2 ; usr
=$c3					PCD_VAL              = $c3 ; val
=$c4					PCD_CLOSE            = $c4 ; close
=$c5					PCD_EXIT             = $c5 ; exit
=$c6					PCD_DEBUG            = $c6 ; debug
=$c7					PCD_OPEN             = $c7 ; open
=$c8					PCD_SCREEN           = $c8 ; screen
=$c9					PCD_VPOKE            = $c9 ; vpoke
=$ca					PCD_VPEEK            = $ca ; vpeek
=$cb					PCD_CMD_SHIFT        = $cb ; .shift
=$cc					PCD_CMD_BYTE         = $cc ; .byte
=$cd					PCD_CMD_WORD         = $cd ; .word
=$ce					PCD_CMD_FLOAT        = $ce ; .float
=$cf					PCD_CMD_STRING       = $cf ; .string
=$d0					PCD_CMD_DATA         = $d0 ; .data
=$d1					PCD_CMD_GOTO         = $d1 ; .goto
=$d2					PCD_CMD_GOSUB        = $d2 ; .gosub
=$d3					PCD_CMD_GOTOCMD_Z    = $d3 ; .goto.z
=$d4					PCD_CMD_GOTOCMD_NZ   = $d4 ; .goto.nz
=$d5					PCD_CMD_VARSPACE     = $d5 ; .varspace
=$d6					PCD_CMD_RESTORE      = $d6 ; .restore
=$cb80					PCD_CLR              = $cb80 ; clr
=$cb81					PCD_DIM              = $cb81 ; dim
=$cb82					PCD_END              = $cb82 ; end
=$cb83					PCD_JOY              = $cb83 ; joy
=$cb84					PCD_INT              = $cb84 ; int
=$cb85					PCD_SQR              = $cb85 ; sqr
=$cb86					PCD_LOG              = $cb86 ; log
=$cb87					PCD_EXP              = $cb87 ; exp
=$cb88					PCD_COS              = $cb88 ; cos
=$cb89					PCD_SIN              = $cb89 ; sin
=$cb8a					PCD_TAN              = $cb8a ; tan
=$cb8b					PCD_ATN              = $cb8b ; atn
=$cb8c					PCD_MOUSE            = $cb8c ; mouse
=$cb8d					PCD_MB               = $cb8d ; mb
=$cb8e					PCD_MX               = $cb8e ; mx
=$cb8f					PCD_MY               = $cb8f ; my
=$cb90					PCD_RESTORE          = $cb90 ; restore
=$cb91					PCD_STOP             = $cb91 ; stop
=$cb92					PCD_SYS              = $cb92 ; sys
=$cb93					PCD_TIDOLLARCMD_WRITE = $cb93 ; ti$.write
=$cb94					PCD_WAIT             = $cb94 ; wait
=$cb95					PCD_I2CPOKE          = $cb95 ; i2cpoke
=$cb96					PCD_I2CPEEK          = $cb96 ; i2cpeek
=$cb97					PCD_BANK             = $cb97 ; bank
=$cb98					PCD_SLEEP            = $cb98 ; sleep
=$cb99					PCD_FMINIT           = $cb99 ; fminit
=$cb9a					PCD_FMNOTE           = $cb9a ; fmnote
=$cb9b					PCD_FMDRUM           = $cb9b ; fmdrum
=$cb9c					PCD_FMINST           = $cb9c ; fminst
=$cb9d					PCD_FMVIB            = $cb9d ; fmvib
=$cb9e					PCD_FMFREQ           = $cb9e ; fmfreq
=$cb9f					PCD_FMVOL            = $cb9f ; fmvol
=$cba0					PCD_FMPAN            = $cba0 ; fmpan
=$cba1					PCD_FMPLAY           = $cba1 ; fmplay
=$cba2					PCD_FMCHORD          = $cba2 ; fmchord
=$cba3					PCD_FMPOKE           = $cba3 ; fmpoke
=$cba4					PCD_PSGINIT          = $cba4 ; psginit
=$cba5					PCD_PSGNOTE          = $cba5 ; psgnote
=$cba6					PCD_PSGVOL           = $cba6 ; psgvol
=$cba7					PCD_PSGWAV           = $cba7 ; psgwav
=$cba8					PCD_PSGFREQ          = $cba8 ; psgfreq
=$cba9					PCD_PSGPAN           = $cba9 ; psgpan
=$cbaa					PCD_PSGPLAY          = $cbaa ; psgplay
=$cbab					PCD_PSGCHORD         = $cbab ; psgchord
=$cbac					PCD_CLS              = $cbac ; cls
=$cbad					PCD_LOCATE           = $cbad ; locate
=$cbae					PCD_COLOR            = $cbae ; color
.1ef5					SetErrorHandler:
.1ef5	8c 70 05	sty $0570			sty 	ErrorHandlerVector+1
.1ef8	8e 6f 05	stx $056f			stx 	ErrorHandlerVector
.1efb	60		rts				rts
.1efc					CallErrorHandler:
.1efc	6c 6f 05	jmp ($056f)			jmp 	(ErrorHandlerVector)
.056f					ErrorHandlerVector:
>056f							.fill 	2
.1eff					ErrorV_range:
.1eff	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f02	4f 55 54 20 4f 46 20 52			.text	"OUT OF RANGE",0
>1f0a	41 4e 47 45 00
.1f0f					ErrorV_value:
.1f0f	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f12	42 41 44 20 56 41 4c 55			.text	"BAD VALUE",0
>1f1a	45 00
.1f1c					ErrorV_syntax:
.1f1c	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f1f	53 59 4e 54 41 58 20 45			.text	"SYNTAX ERROR",0
>1f27	52 52 4f 52 00
.1f2c					ErrorV_type:
.1f2c	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f2f	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATCH",0
>1f37	4d 41 54 43 48 00
.1f3d					ErrorV_unimplemented:
.1f3d	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f40	4e 4f 54 20 49 4d 50 4c			.text	"NOT IMPLEMENTED",0
>1f48	45 4d 45 4e 54 45 44 00
.1f50					ErrorV_assert:
.1f50	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f53	41 53 53 45 52 54 20 46			.text	"ASSERT FAIL",0
>1f5b	41 49 4c 00
.1f5f					ErrorV_line:
.1f5f	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f62	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN LINE NUMBER",0
>1f6a	4c 49 4e 45 20 4e 55 4d 42 45 52 00
.1f76					ErrorV_internal:
.1f76	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f79	49 4e 54 45 52 4e 41 4c			.text	"INTERNAL ERROR",0
>1f81	20 45 52 52 4f 52 00
.1f88					ErrorV_divzero:
.1f88	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f8b	44 49 56 49 44 45 20 42			.text	"DIVIDE BY ZERO",0
>1f93	59 20 5a 45 52 4f 00
.1f9a					ErrorV_structure:
.1f9a	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1f9d	53 54 52 55 43 54 55 52			.text	"STRUCTURE IMBALANCE",0
>1fa5	45 20 49 4d 42 41 4c 41 4e 43 45 00
.1fb1					ErrorV_stop:
.1fb1	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1fb4	50 52 4f 47 52 41 4d 20			.text	"PROGRAM STOPPED",0
>1fbc	53 54 4f 50 50 45 44 00
.1fc4					ErrorV_data:
.1fc4	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1fc7	4f 55 54 20 4f 46 20 44			.text	"OUT OF DATA",0
>1fcf	41 54 41 00
.1fd3					ErrorV_undeclared:
.1fd3	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1fd6	55 4e 4b 4e 4f 57 4e 20			.text	"UNKNOWN ARRAY",0
>1fde	41 52 52 41 59 00
.1fe4					ErrorV_redefine:
.1fe4	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1fe7	41 52 52 41 59 20 52 45			.text	"ARRAY REDEFINED",0
>1fef	44 45 46 49 4e 45 44 00
.1ff7					ErrorV_index:
.1ff7	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>1ffa	42 41 44 20 41 52 52 41			.text	"BAD ARRAY INDEX",0
>2002	59 20 49 4e 44 45 58 00
.200a					ErrorV_memory:
.200a	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>200d	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMORY",0
>2015	45 4d 4f 52 59 00
.201b					ErrorV_channel:
.201b	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>201e	49 4e 50 55 54 2f 4f 55			.text	"INPUT/OUTPUT ERROR",0
>2026	54 50 55 54 20 45 52 52 4f 52 00
.2031					ErrorV_break:
.2031	20 fc 1e	jsr $1efc		jsr	CallErrorHandler
>2034	42 52 45 41 4b 20 50 52			.text	"BREAK PRESSED",0
>203c	45 53 53 45 44 00
.2042					MoveObjectForward:
.2042	b2 2a		lda ($2a)			lda 	(objPtr) 					; get next
.2044	c9 ff		cmp #$ff			cmp 	#$FF
.2046	f0 36		beq $207e			beq 	_MOFEnd
.2048	c9 40		cmp #$40			cmp 	#$40 						; 00-3F
.204a	90 24		bcc $2070			bcc 	_MOFAdvance1 				; forward 1
.204c	a0 02		ldy #$02			ldy 	#2 							; 40-6F
.204e	c9 70		cmp #$70			cmp 	#$70 						; forward 2
.2050	90 20		bcc $2072			bcc 	_MOFAdvanceY
.2052	c9 cb		cmp #$cb			cmp 	#PCD_STARTSYSTEM 			; 70 - System tokens.
.2054	90 1a		bcc $2070			bcc 	_MOFAdvance1 				; forward 1
.2056	a8		tay				tay 								; read the size.
.2057	b9 bb 1f	lda $1fbb,y			lda 	MOFSizeTable-PCD_STARTSYSTEM,y
.205a	a8		tay				tay
.205b	c8		iny				iny 								; add 1 for the system token.
.205c	d0 14		bne $2072			bne 	_MOFAdvanceY 				; if 0, was $FF thus a string/data skip.
.205e	a0 01		ldy #$01			ldy 	#1 							; get length byte
.2060	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2062	a8		tay				tay 								; into Y.
.2063	18		clc				clc
.2064	a5 2a		lda $2a				lda 	objPtr						; add 2 to the object pointer
.2066	69 02		adc #$02			adc 	#2
.2068	85 2a		sta $2a				sta 	objPtr
.206a	90 02		bcc $206e			bcc 	_MOFNoCarry1
.206c	e6 2b		inc $2b				inc 	objPtr+1
.206e					_MOFNoCarry1:
.206e	80 02		bra $2072			bra 	_MOFAdvanceY
.2070					_MOFAdvance1:
.2070	a0 01		ldy #$01			ldy 	#1
.2072					_MOFAdvanceY:
.2072	98		tya				tya 								; add Y to objPtr
.2073	18		clc				clc
.2074	65 2a		adc $2a				adc 	objPtr
.2076	85 2a		sta $2a				sta 	objPtr
.2078	90 02		bcc $207c			bcc 	_MOFNoCarry2
.207a	e6 2b		inc $2b				inc 	objPtr+1
.207c					_MOFNoCarry2:
.207c	18		clc				clc 								; not completed.
.207d	60		rts				rts
.207e					_MOFEnd:
.207e	e6 2a		inc $2a				inc 	objPtr
.2080	d0 02		bne $2084			bne 	_MOFENoCarry
.2082	e6 2b		inc $2b				inc 	objPtr+1
.2084					_MOFENoCarry:
.2084	38		sec				sec
.2085	60		rts				rts
.2086					MOFSizeTable:
>2086	01					.byte	1         	; $cb .shift
>2087	01					.byte	1         	; $cc .byte
>2088	02					.byte	2         	; $cd .word
>2089	05					.byte	5         	; $ce .float
>208a	ff					.byte	255       	; $cf .string
>208b	ff					.byte	255       	; $d0 .data
>208c	02					.byte	2         	; $d1 .goto
>208d	02					.byte	2         	; $d2 .gosub
>208e	02					.byte	2         	; $d3 .goto.z
>208f	02					.byte	2         	; $d4 .goto.nz
>2090	02					.byte	2         	; $d5 .varspace
>2091	02					.byte	2         	; $d6 .restore

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/ifloat32.library

=12					MathStackSize = 12
=$40					NSSString = $40 							; string vs typemask
=$00					NSSIFloat = $00 							; ifloat vs typemask
=$20					NSSIInt16 = $20								; when set, a reference is a 16 bit reference (e.g. a%)
=$40					NSSTypeMask = $40
=$80					NSSArray = $80  							; array (in variable code)
.0032					NSStatus:
>0032							.fill 	MathStackSize
.003e					NSMantissa0:
>003e							.fill 	MathStackSize 				; (this is my integer mantissa system)
.004a					NSMantissa1:
>004a							.fill 	MathStackSize
.0056					NSMantissa2:
>0056							.fill 	MathStackSize
.0062					NSMantissa3:
>0062							.fill 	MathStackSize
.006e					NSExponent:
>006e							.fill 	MathStackSize
.0571					numberBuffer:
>0571							.fill 	34
.2092					FloatSubtract:
.2092	b5 32		lda $32,x			lda 	NSStatus,x 					; negate top of stack
.2094	49 80		eor #$80			eor 	#$80
.2096	95 32		sta $32,x			sta 	NSStatus,x					; and fall through.
.2098					FloatAdd:
.2098	ca		dex				dex
.2099	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised.
.209b	15 6f		ora $6f,x			ora 	NSExponent+1,x
.209d	15 62		ora $62,x			ora 	NSMantissa3,x
.209f	15 63		ora $63,x			ora 	NSMantissa3+1,x
.20a1	d0 04		bne $20a7			bne 	_FAUseFloat
.20a3	20 34 24	jsr $2434			jsr 	FloatInt32Add 				; use the int32 one.
.20a6	60		rts				rts
.20a7					_FAUseFloat:
.20a7	20 c9 23	jsr $23c9			jsr 	FloatNormalise 				; normalise S[X]
.20aa	f0 51		beq $20fd			beq 	_FAReturn1
.20ac	e8		inx				inx 								; normalise S[X+1]
.20ad	20 c9 23	jsr $23c9			jsr 	FloatNormalise
.20b0	ca		dex				dex
.20b1	c9 00		cmp #$00			cmp 	#0
.20b3	f0 60		beq $2115			beq 	_FAExit 					; if so, just return A
.20b5	b5 6e		lda $6e,x			lda 	NSExponent,x 				; are the exponents the same ?
.20b7	d5 6f		cmp $6f,x			cmp 	NSExponent+1,x
.20b9	f0 18		beq $20d3			beq 	_FAExponentsEqual
.20bb	b5 6e		lda $6e,x			lda 	NSExponent,x 				; work out the larger exponent
.20bd	a8		tay				tay
.20be	38		sec				sec 								; do a signed comparison of the exponents.
.20bf	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.20c1	50 02		bvc $20c5			bvc 	_FANoSignedChange
.20c3	49 80		eor #$80			eor 	#$80
.20c5					_FANoSignedChange:
.20c5	29 80		and #$80			and 	#$80
.20c7	10 02		bpl $20cb			bpl 	_FAHaveMax
.20c9	b4 6f		ldy $6f,x			ldy 	NSExponent+1,x
.20cb					_FAHaveMax:
.20cb	20 16 21	jsr $2116			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.20ce	e8		inx				inx
.20cf	20 16 21	jsr $2116			jsr 	_FAShiftToExponent
.20d2	ca		dex				dex
.20d3					_FAExponentsEqual:
.20d3	b5 32		lda $32,x			lda 	NSStatus,x 					; are the signs the same
.20d5	55 33		eor $33,x			eor 	NSStatus+1,x
.20d7	30 0e		bmi $20e7			bmi 	_FADifferentSigns
.20d9	20 00 24	jsr $2400			jsr 	FloatAddTopTwoStack 		; do the add of the mantissae
.20dc	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.20de	10 35		bpl $2115			bpl 	_FAExit 					; if no, we are done.
.20e0	20 8d 26	jsr $268d			jsr 	FloatShiftRight 				; shift A right, renormalising it.
.20e3	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump the exponent and exit
.20e5	80 2e		bra $2115			bra 	_FAExit
.20e7					_FADifferentSigns:
.20e7	20 1a 24	jsr $241a			jsr 	FloatSubTopTwoStack 		; subtract mantissa B from A
.20ea	b5 62		lda $62,x			lda 	NSMantissa3,x 				; is the result negative ?
.20ec	10 06		bpl $20f4			bpl 	_FACheckZero 				; if no, check for -0
.20ee	20 36 26	jsr $2636			jsr 	FloatNegate 					; netate result
.20f1	20 3d 26	jsr $263d			jsr 	FloatNegateMantissa 			; negate (2'c) the mantissa
.20f4					_FACheckZero:
.20f4	20 96 26	jsr $2696			jsr 	FloatIsZero	 				; check for -0
.20f7	d0 1c		bne $2115			bne 	_FAExit
.20f9	74 32		stz $32,x			stz 	NSStatus,x
.20fb	80 18		bra $2115			bra 	_FAExit
.20fd					_FAReturn1:
.20fd	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.20ff	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2101	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.2103	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2105	b5 57		lda $57,x			lda 	NSMantissa2+1,x
.2107	95 56		sta $56,x			sta 	NSMantissa2,x
.2109	b5 63		lda $63,x			lda 	NSMantissa3+1,x
.210b	95 62		sta $62,x			sta 	NSMantissa3,x
.210d	b5 6f		lda $6f,x			lda 	NSExponent+1,x
.210f	95 6e		sta $6e,x			sta 	NSExponent,x
.2111	b5 33		lda $33,x			lda 	NSStatus+1,x
.2113	95 32		sta $32,x			sta 	NSStatus,x
.2115					_FAExit:
.2115	60		rts				rts
.2116					_FAShiftToExponent:
.2116					_FAShiftToExponent2:
.2116	98		tya				tya 								; compare Y to exponent
.2117	d5 6e		cmp $6e,x			cmp 	NSExponent,x 				; reached the exponent required ?
.2119	f0 07		beq $2122			beq 	_FASEExit 					; exit if so.
.211b	20 8d 26	jsr $268d			jsr 	FloatShiftRight	 			; shift the mantissa right
.211e	f6 6e		inc $6e,x			inc 	NSExponent,x 				; increment exponent
.2120	80 f4		bra $2116			bra 	_FAShiftToExponent2
.2122					_FASEExit:
.2122	60		rts				rts
.2123					CompareEqual:
.2123	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2125	d0 09		bne $2130			bne 	ReturnFalse
.2127					ReturnTrue:
.2127	a9 01		lda #$01			lda 	#1
.2129	95 3e		sta $3e,x			sta 	NSMantissa0,x
.212b	a9 80		lda #$80			lda 	#$80
.212d	95 32		sta $32,x			sta 	NSStatus,x
.212f	60		rts				rts
.2130					ReturnFalse:
.2130	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2132	60		rts				rts
.2133					CompareNotEqual:
.2133	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2135	d0 f0		bne $2127			bne 	ReturnTrue
.2137	80 f7		bra $2130			bra 	ReturnFalse
.2139					CompareLess:
.2139	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.213b	c9 ff		cmp #$ff			cmp 	#$FF
.213d	f0 e8		beq $2127			beq 	ReturnTrue
.213f	80 ef		bra $2130			bra 	ReturnFalse
.2141					CompareGreater:
.2141	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2143	c9 01		cmp #$01			cmp 	#$01
.2145	f0 e0		beq $2127			beq 	ReturnTrue
.2147	80 e7		bra $2130			bra 	ReturnFalse
.2149					CompareLessEqual:
.2149	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.214b	c9 01		cmp #$01			cmp 	#$01
.214d	d0 d8		bne $2127			bne 	ReturnTrue
.214f	80 df		bra $2130			bra 	ReturnFalse
.2151					CompareGreaterEqual:
.2151	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2153	c9 ff		cmp #$ff			cmp 	#$FF
.2155	d0 d0		bne $2127			bne 	ReturnTrue
.2157	80 d7		bra $2130			bra 	ReturnFalse
.2159					FloatCompare:
.2159	b5 6e		lda $6e,x			lda 	NSExponent,x 				; float comparison.
.215b	15 6d		ora $6d,x			ora 	NSExponent-1,x 				; integer if both integer.
.215d	48		pha				pha
.215e	20 92 20	jsr $2092			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.2161	68		pla				pla
.2162	d0 0c		bne $2170			bne 	_FCCompareFloat
.2164	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2166	15 4a		ora $4a,x			ora 	NSMantissa1,x
.2168	15 56		ora $56,x			ora 	NSMantissa2,x
.216a	15 62		ora $62,x			ora 	NSMantissa3,x
.216c	f0 14		beq $2182			beq 	_FCExit 					; if zero, return zero
.216e	80 0a		bra $217a			bra 	_FCSign
.2170					_FCCompareFloat:
.2170	b5 4a		lda $4a,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.2172	29 f0		and #$f0			and 	#$F0
.2174	15 56		ora $56,x			ora 	NSMantissa2,x
.2176	15 62		ora $62,x			ora 	NSMantissa3,x
.2178	f0 08		beq $2182			beq 	_FCExit 					; zero, so approximately identical
.217a					_FCSign:
.217a	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.217c	34 32		bit $32,x			bit 	NSStatus,x
.217e	10 02		bpl $2182			bpl 	_FCExit
.2180					_FCNegative:
.2180	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.2182					_FCExit:
.2182	20 76 26	jsr $2676			jsr 	FloatSetByte 				; set the result 255,0,1
.2185	60		rts				rts
.2186					FloatScalarTable:
>2186	66 66 66 66				.dword $66666666 ; 0.1
>218a	de					.byte $de
>218b	1f 85 eb 51				.dword $51eb851f ; 0.01
>218f	db					.byte $db
>2190	4c 37 89 41				.dword $4189374c ; 0.001
>2194	d8					.byte $d8
>2195	ac 8b db 68				.dword $68db8bac ; 0.0001
>2199	d4					.byte $d4
>219a	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>219e	d1					.byte $d1
>219f	83 de 1b 43				.dword $431bde83 ; 1e-06
>21a3	ce					.byte $ce
>21a4	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>21a8	ca					.byte $ca
>21a9	89 3b e6 55				.dword $55e63b89 ; 1e-08
>21ad	c7					.byte $c7
>21ae	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>21b2	c4					.byte $c4
>21b3	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>21b7	c0					.byte $c0
>21b8	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>21bc	bd					.byte $bd
.21bd					FloatDivide:
.21bd	48		pha				pha
.21be	20 c9 23	jsr $23c9			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.21c1	ca		dex				dex
.21c2	c9 00		cmp #$00			cmp 	#0
.21c4	f0 1e		beq $21e4			beq 	_FDZero
.21c6	20 c9 23	jsr $23c9			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.21c9	f0 16		beq $21e1			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.21cb	20 2c 22	jsr $222c			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.21ce	20 f9 21	jsr $21f9			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.21d1	20 c9 23	jsr $23c9			jsr		FloatNormalise 				; renormalise
.21d4	20 bf 23	jsr $23bf			jsr 	FloatCalculateSign 			; calculate result sign
.21d7	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent
.21d9	38		sec				sec
.21da	f5 6f		sbc $6f,x			sbc 	NSExponent+1,x
.21dc	38		sec				sec
.21dd	e9 1e		sbc #$1e			sbc 	#30
.21df	95 6e		sta $6e,x			sta 	NSExponent,x
.21e1					_FDExit:
.21e1	68		pla				pla
.21e2	18		clc				clc
.21e3	60		rts				rts
.21e4					_FDZero:
.21e4	68		pla				pla
.21e5	38		sec				sec
.21e6	60		rts				rts
.21e7					DivideInt32:
.21e7	20 af 22	jsr $22af			jsr 	FloatIntegerPart 			; make both integers
.21ea	ca		dex				dex
.21eb	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.21ee	20 0a 22	jsr $220a			jsr 	Int32Divide 				; divide
.21f1	20 f9 21	jsr $21f9			jsr 	NSMCopyPlusTwoToZero 		; copy result
.21f4	20 bf 23	jsr $23bf			jsr 	FloatCalculateSign 			; calculate result sign
.21f7	18		clc				clc
.21f8	60		rts				rts
.21f9					NSMCopyPlusTwoToZero:
.21f9	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.21fb	95 3e		sta $3e,x			sta 	NSMantissa0,x
.21fd	b5 4c		lda $4c,x			lda 	NSMantissa1+2,x
.21ff	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2201	b5 58		lda $58,x			lda 	NSMantissa2+2,x
.2203	95 56		sta $56,x			sta 	NSMantissa2,x
.2205	b5 64		lda $64,x			lda 	NSMantissa3+2,x
.2207	95 62		sta $62,x			sta 	NSMantissa3,x
.2209	60		rts				rts
.220a					Int32Divide:
.220a	48		pha				pha 								; save AXY
.220b	5a		phy				phy
.220c	20 57 26	jsr $2657			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.220f	20 70 26	jsr $2670			jsr 	FloatSetZeroMantissaOnly 	; set S[X] to zero
.2212	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.2214					_I32DivideLoop:
.2214	e8		inx				inx
.2215	e8		inx				inx
.2216	20 83 26	jsr $2683			jsr 	FloatShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.2219	ca		dex				dex
.221a	ca		dex				dex
.221b	20 84 26	jsr $2684			jsr 	FloatRotateLeft
.221e	20 4a 22	jsr $224a			jsr 	FloatDivideCheck 			; check if subtract possible
.2221	90 02		bcc $2225			bcc 	_I32DivideNoCarryIn
.2223	f6 40		inc $40,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.2225					_I32DivideNoCarryIn:
.2225	88		dey				dey 								; loop round till division completed.
.2226	d0 ec		bne $2214			bne 	_I32DivideLoop
.2228	7a		ply				ply 								; restore AXY and exit
.2229	68		pla				pla
.222a	18		clc				clc
.222b	60		rts				rts
.222c					Int32ShiftDivide:
.222c	48		pha				pha 								; save AY
.222d	5a		phy				phy
.222e	e8		inx				inx 								; clear S[X+2]
.222f	e8		inx				inx
.2230	20 74 26	jsr $2674			jsr 	FloatSetZero
.2233	ca		dex				dex
.2234	ca		dex				dex
.2235	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.2237					_I32SDLoop:
.2237	20 4a 22	jsr $224a			jsr 	FloatDivideCheck 			; check if subtract possible
.223a	e8		inx				inx
.223b	e8		inx				inx
.223c	20 84 26	jsr $2684			jsr 	FloatRotateLeft				; shift 64 bit FPA left, rotating carry in
.223f	ca		dex				dex
.2240	ca		dex				dex
.2241	20 84 26	jsr $2684			jsr 	FloatRotateLeft
.2244	88		dey				dey 	 							; do 31 times
.2245	d0 f0		bne $2237			bne 	_I32SDLoop
.2247	7a		ply				ply 								; restore AY and exit
.2248	68		pla				pla
.2249	60		rts				rts
.224a					FloatDivideCheck:
.224a	20 1a 24	jsr $241a			jsr 	FloatSubTopTwoStack 		; subtract Stack[X+1] from Stack[X+0]
.224d	b0 04		bcs $2253			bcs 	_DCSExit 					; if carry set, then could do, exit
.224f	20 00 24	jsr $2400			jsr 	FloatAddTopTwoStack 		; add it back in
.2252	18		clc				clc 								; and return False
.2253					_DCSExit:
.2253	60		rts				rts
.2254					FloatFractionalPart:
.2254	5a		phy				phy
.2255	b5 32		lda $32,x			lda 	NSStatus,x 					; take absolute value
.2257	29 7f		and #$7f			and 	#$7F
.2259	95 32		sta $32,x			sta 	NSStatus,x
.225b	20 c9 23	jsr $23c9			jsr 	FloatNormalise
.225e	b5 6e		lda $6e,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.2260	38		sec				sec
.2261	e9 e0		sbc #$e0			sbc 	#$E0
.2263	90 29		bcc $228e			bcc 	_FFPExit 					; already fractional
.2265	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.2267	b0 22		bcs $228b			bcs 	_FFPZero
.2269	a8		tay				tay 								; put count to do in Y
.226a	b5 62		lda $62,x			lda 	NSMantissa3,x 				; do each in turn.
.226c	20 93 22	jsr $2293			jsr 	_FFPPartial
.226f	95 62		sta $62,x			sta 	NSMantissa3,x
.2271	b5 56		lda $56,x			lda 	NSMantissa2,x
.2273	20 93 22	jsr $2293			jsr 	_FFPPartial
.2276	95 56		sta $56,x			sta 	NSMantissa2,x
.2278	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.227a	20 93 22	jsr $2293			jsr 	_FFPPartial
.227d	95 4a		sta $4a,x			sta 	NSMantissa1,x
.227f	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2281	20 93 22	jsr $2293			jsr 	_FFPPartial
.2284	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2286	20 96 26	jsr $2696			jsr 	FloatIsZero 					; zeroed check.
.2289	d0 03		bne $228e			bne 	_FFPExit
.228b					_FFPZero:
.228b	20 74 26	jsr $2674			jsr 	FloatSetZero
.228e					_FFPExit:
.228e	20 c9 23	jsr $23c9			jsr 	FloatNormalise
.2291	7a		ply				ply
.2292	60		rts				rts
.2293					_FFPPartial:
.2293	c0 00		cpy #$00			cpy 	#0 							; no more to do
.2295	f0 17		beq $22ae			beq 	_FFFPPExit
.2297	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.2299	b0 0c		bcs $22a7			bcs 	_FFFPPWholeByte
.229b	5a		phy				phy
.229c					_FFFPPLeft:
.229c	0a		asl a				asl 	a
.229d	88		dey				dey
.229e	d0 fc		bne $229c			bne 	_FFFPPLeft
.22a0	7a		ply				ply
.22a1					_FFFPPRight:
.22a1	4a		lsr a				lsr 	a
.22a2	88		dey				dey
.22a3	d0 fc		bne $22a1			bne 	_FFFPPRight
.22a5	80 07		bra $22ae			bra 	_FFFPPExit
.22a7					_FFFPPWholeByte:
.22a7	98		tya				tya 								; subtract 8 from count
.22a8	38		sec				sec
.22a9	e9 08		sbc #$08			sbc 	#8
.22ab	a8		tay				tay
.22ac	a9 00		lda #$00			lda 	#0 							; and clear all
.22ae					_FFFPPExit:
.22ae	60		rts				rts
.22af					FloatIntegerPart:
.22af	48		pha				pha
.22b0	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22b2	f0 1d		beq $22d1			beq 	_FIPExit 					; if so do nothing
.22b4	20 96 26	jsr $2696			jsr 	FloatIsZero 				; is it zero ?
.22b7	f0 15		beq $22ce			beq 	_FIPZero 					; if so return zero.
.22b9	20 c9 23	jsr $23c9			jsr 	FloatNormalise 				; normalise
.22bc	f0 10		beq $22ce			beq 	_FIPZero 					; normalised to zero, exit zero
.22be					_FIPShift:
.22be	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22c0	10 07		bpl $22c9			bpl 	_FIPCheckZero
.22c2	20 8d 26	jsr $268d			jsr 	FloatShiftRight 			; shift mantissa right
.22c5	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22c7	80 f5		bra $22be			bra 	_FIPShift
.22c9					_FIPCheckZero:
.22c9	20 96 26	jsr $2696			jsr 	FloatIsZero 				; avoid -0 problem
.22cc	d0 03		bne $22d1			bne 	_FIPExit 					; set to zero if mantissa zero.
.22ce					_FIPZero:
.22ce	20 74 26	jsr $2674			jsr 	FloatSetZero
.22d1					_FIPExit:
.22d1	68		pla				pla
.22d2	60		rts				rts
.22d3					FloatIntegerPartDown:
.22d3	48		pha				pha
.22d4	5a		phy				phy
.22d5	b5 6e		lda $6e,x			lda 	NSExponent,x 				; is it integer already ?
.22d7	f0 36		beq $230f			beq 	_FIPExit 					; if so do nothing
.22d9	20 96 26	jsr $2696			jsr 	FloatIsZero 				; is it zero ?
.22dc	f0 2e		beq $230c			beq 	_FIPZero 					; if so return zero.
.22de	20 c9 23	jsr $23c9			jsr 	FloatNormalise 				; normalise
.22e1	f0 29		beq $230c			beq 	_FIPZero 					; normalised to zero, exit zero
.22e3	a0 00		ldy #$00			ldy 	#0 							; reset the count of bits.
.22e5					_FIPShift:
.22e5	b5 6e		lda $6e,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.22e7	10 0a		bpl $22f3			bpl 	_FIPCheckDown
.22e9	20 8d 26	jsr $268d			jsr 	FloatShiftRight 			; shift mantissa right
.22ec	90 01		bcc $22ef			bcc 	_FIPNoFrac 					; shifted a zero out ?
.22ee	c8		iny				iny
.22ef					_FIPNoFrac:
.22ef	f6 6e		inc $6e,x			inc 	NSExponent,x 				; bump exponent
.22f1	80 f2		bra $22e5			bra 	_FIPShift
.22f3					_FIPCheckDown:
.22f3	c0 00		cpy #$00			cpy 	#0 							; were there any fractional bits.
.22f5	f0 10		beq $2307			beq 	_FIPCheckZero
.22f7	34 32		bit $32,x			bit 	NSStatus,x 					; +ve
.22f9	10 0c		bpl $2307			bpl 	_FIPCheckZero
.22fb	e8		inx				inx 								; -ve so round *down*.
.22fc	a9 01		lda #$01			lda 	#1
.22fe	20 76 26	jsr $2676			jsr 	FloatSetByte
.2301	20 36 26	jsr $2636			jsr 	FloatNegate
.2304	20 98 20	jsr $2098			jsr 	FloatAdd
.2307					_FIPCheckZero:
.2307	20 96 26	jsr $2696			jsr 	FloatIsZero 				; avoid -0 problem
.230a	d0 03		bne $230f			bne 	_FIPExit 					; set to zero if mantissa zero.
.230c					_FIPZero:
.230c	20 74 26	jsr $2674			jsr 	FloatSetZero
.230f					_FIPExit:
.230f	7a		ply				ply
.2310	68		pla				pla
.2311	60		rts				rts
.2312					FloatInt8Multiply:
.2312	5a		phy				phy
.2313	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; right shifted multiplier in Y
.2315	a8		tay				tay
.2316	74 3e		stz $3e,x			stz 	NSMantissa0,x 				; zero the result (already 8 bit constant)
.2318					_FI8MLoop:
.2318	98		tya				tya 								; shift right shifter right into carry
.2319	4a		lsr a				lsr 	a
.231a	a8		tay				tay
.231b	90 0d		bcc $232a			bcc 	_FI8MNoAdd
.231d	18		clc				clc
.231e	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2320	75 3f		adc $3f,x			adc 	NSMantissa0+1,x
.2322	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2324	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2326	75 4b		adc $4b,x			adc 	NSMantissa1+1,x
.2328	95 4a		sta $4a,x			sta 	NSMantissa1,x
.232a					_FI8MNoAdd:
.232a	16 3f		asl $3f,x			asl 	NSMantissa0+1,x 			; shift adder left
.232c	36 4b		rol $4b,x			rol 	NSMantissa1+1,x
.232e	c0 00		cpy #$00			cpy 	#0
.2330	d0 e6		bne $2318			bne 	_FI8MLoop 					; until right shifter zero.
.2332	7a		ply				ply
.2333	60		rts				rts
.2334					FloatMultiply:
.2334	ca		dex				dex
.2335	b5 6e		lda $6e,x			lda 	NSExponent,x 				; can use optimised ?
.2337	15 6f		ora $6f,x			ora 	NSExponent+1,x
.2339	15 62		ora $62,x			ora 	NSMantissa3,x
.233b	15 63		ora $63,x			ora 	NSMantissa3+1,x
.233d	d0 21		bne $2360			bne 	_FMUseFloat
.233f	b5 32		lda $32,x			lda 	NSStatus,x 					; check if it is 8 bit unsigned
.2341	15 33		ora $33,x			ora 	NSStatus+1,x
.2343	29 80		and #$80			and 	#$80
.2345	15 62		ora $62,x			ora 	NSMantissa3,x
.2347	15 56		ora $56,x			ora 	NSMantissa2,x
.2349	15 4a		ora $4a,x			ora 	NSMantissa1,x
.234b	15 63		ora $63,x			ora 	NSMantissa3+1,x
.234d	15 57		ora $57,x			ora 	NSMantissa2+1,x
.234f	15 4b		ora $4b,x			ora 	NSMantissa1+1,x
.2351	d0 04		bne $2357			bne 	_FMInt32
.2353	20 12 23	jsr $2312			jsr 	FloatInt8Multiply 			; use fast 8x8 multiply.
.2356	60		rts				rts
.2357					_FMInt32:
.2357	20 81 23	jsr $2381			jsr 	FloatMultiplyShort			; use the int32 one.
.235a	18		clc				clc 								; fix it up if gone out of range
.235b	75 6e		adc $6e,x			adc 	NSExponent,x
.235d	95 6e		sta $6e,x			sta 	NSExponent,x
.235f	60		rts				rts
.2360					_FMUseFloat:
.2360	20 c9 23	jsr $23c9			jsr 	FloatNormalise		 		; normalise S[X] and exit if zero
.2363	f0 18		beq $237d			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.2365	e8		inx				inx
.2366	20 c9 23	jsr $23c9			jsr 	FloatNormalise		 		; normalise S[x+1] and error if zero.
.2369	ca		dex				dex
.236a	c9 00		cmp #$00			cmp 	#0
.236c	f0 0c		beq $237a			beq 	_FDSetZero
.236e	20 81 23	jsr $2381			jsr 	FloatMultiplyShort 			; calculate the result.
.2371	75 6e		adc $6e,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.2373	18		clc				clc
.2374	75 6f		adc $6f,x			adc 	NSExponent+1,x
.2376	95 6e		sta $6e,x			sta 	NSExponent,x
.2378	80 03		bra $237d			bra 	_FDExit
.237a					_FDSetZero:
.237a	20 74 26	jsr $2674			jsr 	FloatSetZero 				; return 0
.237d					_FDExit:
.237d	20 c9 23	jsr $23c9			jsr 	FloatNormalise 				; normalise the result
.2380	60		rts				rts
.2381					FloatMultiplyShort:
.2381	5a		phy				phy 								; save Y
.2382	20 57 26	jsr $2657			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2]
.2385	20 70 26	jsr $2670			jsr 	FloatSetZeroMantissaOnly 	; set mantissa S[X] to zero
.2388	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.238a					_I32MLoop:
.238a	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.238c	15 4c		ora $4c,x			ora 	NSMantissa1+2,x
.238e	15 58		ora $58,x			ora 	NSMantissa2+2,x
.2390	15 64		ora $64,x			ora 	NSMantissa3+2,x
.2392	f0 25		beq $23b9			beq 	_I32MExit 					; exit if zero
.2394	b5 40		lda $40,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.2396	29 01		and #$01			and 	#1
.2398	f0 0d		beq $23a7			beq 	_I32MNoAdd
.239a	20 00 24	jsr $2400			jsr 	FloatAddTopTwoStack 		; if so add S[X+1] to S[X+0]
.239d	b5 62		lda $62,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.239f	10 06		bpl $23a7			bpl 	_I32MNoAdd
.23a1					_I32ShiftRight:
.23a1	20 8d 26	jsr $268d			jsr 	FloatShiftRight 			; shift S[X] right
.23a4	c8		iny				iny 								; increment shift count
.23a5	80 09		bra $23b0			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.23a7					_I32MNoAdd:
.23a7	34 63		bit $63,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.23a9	70 f6		bvs $23a1			bvs 	_I32ShiftRight 				; instead.
.23ab	e8		inx				inx
.23ac	20 83 26	jsr $2683			jsr 	FloatShiftLeft 				; shift additive S[X+1] left
.23af	ca		dex				dex
.23b0					_I32MShiftUpper:
.23b0	e8		inx				inx 								; shift S[X+2] right
.23b1	e8		inx				inx
.23b2	20 8d 26	jsr $268d			jsr 	FloatShiftRight
.23b5	ca		dex				dex
.23b6	ca		dex				dex
.23b7	80 d1		bra $238a			bra 	_I32MLoop 					; try again.
.23b9					_I32MExit:
.23b9	20 bf 23	jsr $23bf			jsr 	FloatCalculateSign
.23bc	98		tya				tya 								; shift in A
.23bd	7a		ply				ply 								; restore Y and exit
.23be	60		rts				rts
.23bf					FloatCalculateSign:
.23bf	b5 32		lda $32,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.23c1	16 32		asl $32,x			asl 	NSStatus,x 					; shift result left
.23c3	55 33		eor $33,x			eor 	NSStatus+1,x
.23c5	0a		asl a				asl 	a 							; shift bit 7 into carry
.23c6	76 32		ror $32,x			ror 	NSStatus,x 					; shift right into status byte.
.23c8	60		rts				rts
.23c9					FloatNormalise:
.23c9	20 96 26	jsr $2696			jsr 	FloatIsZero 				; if zero exit
.23cc	d0 07		bne $23d5			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.23ce	16 32		asl $32,x			asl 	NSStatus,x 					; clear the sign bit.
.23d0	76 32		ror $32,x			ror 	NSStatus,x 					; (no -0)
.23d2	a9 00		lda #$00			lda 	#0 							; set Z flag
.23d4	60		rts				rts
.23d5					_NSNormaliseOptimise:
.23d5	b5 62		lda $62,x			lda 	NSMantissa3,x 				; upper byte zero ?
.23d7	d0 19		bne $23f2			bne 	_NSNormaliseLoop
.23d9	b5 56		lda $56,x			lda 	NSMantissa2,x 				; byte normalise
.23db	30 15		bmi $23f2			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.23dd	95 62		sta $62,x			sta 	NSMantissa3,x
.23df	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.23e1	95 56		sta $56,x			sta 	NSMantissa2,x
.23e3	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.23e5	95 4a		sta $4a,x			sta 	NSMantissa1,x
.23e7	74 3e		stz $3e,x			stz 	NSMantissa0,x
.23e9	b5 6e		lda $6e,x			lda 	NSExponent,x
.23eb	38		sec				sec
.23ec	e9 08		sbc #$08			sbc 	#8
.23ee	95 6e		sta $6e,x			sta 	NSExponent,x
.23f0	80 e3		bra $23d5			bra 	_NSNormaliseOptimise
.23f2					_NSNormaliseLoop:
.23f2	34 62		bit $62,x			bit 	NSMantissa3,x 				; bit 30 set ?
.23f4	70 07		bvs $23fd			bvs 	_NSNExit 					; exit if so with Z flag clear
.23f6	20 83 26	jsr $2683			jsr 	FloatShiftLeft 				; shift mantissa left
.23f9	d6 6e		dec $6e,x			dec 	NSExponent,x 				; adjust exponent
.23fb	80 f5		bra $23f2			bra 	_NSNormaliseLoop
.23fd					_NSNExit:
.23fd	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.23ff	60		rts				rts
.2400					FloatAddTopTwoStack:
.2400	18		clc				clc
.2401	b5 3e		lda $3e,x			lda		NSMantissa0,x
.2403	75 3f		adc $3f,x			adc 		NSMantissa0+1,x
.2405	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2407	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2409	75 4b		adc $4b,x			adc 		NSMantissa1+1,x
.240b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.240d	b5 56		lda $56,x			lda		NSMantissa2,x
.240f	75 57		adc $57,x			adc 		NSMantissa2+1,x
.2411	95 56		sta $56,x			sta 	NSMantissa2,x
.2413	b5 62		lda $62,x			lda		NSMantissa3,x
.2415	75 63		adc $63,x			adc 		NSMantissa3+1,x
.2417	95 62		sta $62,x			sta 	NSMantissa3,x
.2419	60		rts				rts
.241a					FloatSubTopTwoStack:
.241a	38		sec				sec
.241b	b5 3e		lda $3e,x			lda		NSMantissa0,x
.241d	f5 3f		sbc $3f,x			sbc 		NSMantissa0+1,x
.241f	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2421	b5 4a		lda $4a,x			lda		NSMantissa1,x
.2423	f5 4b		sbc $4b,x			sbc 		NSMantissa1+1,x
.2425	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2427	b5 56		lda $56,x			lda		NSMantissa2,x
.2429	f5 57		sbc $57,x			sbc 		NSMantissa2+1,x
.242b	95 56		sta $56,x			sta 	NSMantissa2,x
.242d	b5 62		lda $62,x			lda		NSMantissa3,x
.242f	f5 63		sbc $63,x			sbc 		NSMantissa3+1,x
.2431	95 62		sta $62,x			sta 	NSMantissa3,x
.2433	60		rts				rts
.2434					FloatInt32Add:
.2434	b5 32		lda $32,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.2436	55 33		eor $33,x			eor 	NSStatus+1,x
.2438	30 04		bmi $243e			bmi 	_DiffSigns
.243a	20 00 24	jsr $2400			jsr		FloatAddTopTwoStack
.243d	60		rts				rts
.243e					_DiffSigns:
.243e	20 1a 24	jsr $241a			jsr 	FloatSubTopTwoStack 		; do a physical subtraction
.2441	34 62		bit $62,x			bit 	NSMantissa3,x 				; result is +ve, okay
.2443	10 07		bpl $244c			bpl 	_AddExit
.2445	b5 33		lda $33,x			lda 	NSStatus+1,x 				; sign is that of 11th value
.2447	95 32		sta $32,x			sta 	NSStatus,x
.2449	20 3d 26	jsr $263d			jsr 	FloatNegateMantissa 		; negate the mantissa and exit
.244c					_AddExit:
.244c	20 96 26	jsr $2696			jsr 	FloatIsZero 				; check for -0
.244f	d0 02		bne $2453			bne 	_AddNonZero
.2451	74 32		stz $32,x			stz 	NSStatus,x
.2453					_AddNonZero:
.2453	60		rts				rts
=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.2454					FloatEncodeStart:
.2454	38		sec				sec
.2455	80 01		bra $2458			bra 	FloatEncodeContinue+1
.2457					FloatEncodeContinue:
.2457	18		clc				clc
.2458					FloatEncode:
.2458	08		php				php 								; save reset flag.
.2459	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.245b	f0 15		beq $2472			beq 	_ENIsOkay
.245d	c9 30		cmp #$30			cmp 	#"0"
.245f	90 04		bcc $2465			bcc 	_ENBadNumber
.2461	c9 3a		cmp #$3a			cmp 	#"9"+1
.2463	90 0d		bcc $2472			bcc 	_ENIsOkay
.2465					_ENBadNumber:
.2465	28		plp				plp 								; throw saved reset
.2466	ad 93 05	lda $0593			lda 	encodeState 				; if in decimal mode, construct final number
.2469	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.246b	d0 03		bne $2470			bne 	_ENFail
.246d	4c ea 24	jmp $24ea			jmp 	_ENConstructFinal
.2470					_ENFail:
.2470	18		clc				clc 								; not allowed
.2471	60		rts				rts
.2472					_ENIsOkay:
.2472	28		plp				plp 								; are we restarting
.2473	90 15		bcc $248a			bcc 	_ENNoRestart
.2475					_ENStartEncode:
.2475	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.2477	f0 0c		beq $2485			beq 	_ENFirstDP
.2479	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.247b	20 76 26	jsr $2676			jsr 	FloatSetByte 				; in single byte mode.
.247e	a9 01		lda #$01			lda 	#ESTA_Low
.2480					_ENExitChange:
.2480	8d 93 05	sta $0593			sta 	encodeState 				; save new state
.2483	38		sec				sec
.2484	60		rts				rts
.2485					_ENFirstDP:
.2485	20 74 26	jsr $2674			jsr 	FloatSetZero 				; clear integer part
.2488	80 3c		bra $24c6			bra 	_ESTASwitchFloat			; go straight to float and exi
.248a					_ENNoRestart:
.248a	48		pha				pha 								; save digit or DP on stack.
.248b	ad 93 05	lda $0593			lda 	encodeState 				; get current state
.248e	c9 01		cmp #$01			cmp 	#ESTA_Low
.2490	f0 09		beq $249b			beq  	_ESTALowState
.2492	c9 02		cmp #$02			cmp 	#ESTA_High
.2494	f0 26		beq $24bc			beq 	_ESTAHighState
.2496	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.2498	f0 38		beq $24d2			beq 	_ESTADecimalState
>249a	db						.byte 	$DB 						; causes a break in the emulator
.249b					_ESTALowState:
.249b	68		pla				pla 								; get value back
.249c	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.249e	f0 26		beq $24c6			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.24a0	29 0f		and #$0f			and 	#15 						; make digit
.24a2	8d 94 05	sta $0594			sta 	digitTemp 					; save it.
.24a5	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.24a7	0a		asl a				asl 	a
.24a8	0a		asl a				asl 	a
.24a9	75 3e		adc $3e,x			adc 	NSMantissa0,x
.24ab	0a		asl a				asl 	a
.24ac	6d 94 05	adc $0594			adc 	digitTemp
.24af	95 3e		sta $3e,x			sta 	NSMantissa0,x
.24b1	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.24b3	90 05		bcc $24ba			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.24b5	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.24b7	8d 93 05	sta $0593			sta 	encodeState
.24ba					_ESTANoSwitch:
.24ba	38		sec				sec
.24bb	60		rts				rts
.24bc					_ESTAHighState:
.24bc	68		pla				pla 								; get value back
.24bd	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.24bf	f0 05		beq $24c6			beq 	_ESTASwitchFloat
.24c1	20 1c 25	jsr $251c			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.24c4	38		sec				sec
.24c5	60		rts				rts
.24c6					_ESTASwitchFloat:
.24c6	9c 95 05	stz $0595			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.24c9	e8		inx				inx 								; zero the decimal additive.
.24ca	20 74 26	jsr $2674			jsr 	FloatSetZero
.24cd	ca		dex				dex
.24ce	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.24d0	80 ae		bra $2480			bra 	_ENExitChange
.24d2					_ESTADecimalState:
.24d2	68		pla				pla 								; digit.
.24d3	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 11th decimal point.
.24d5	f0 99		beq $2470			beq 	_ENFail
.24d7	e8		inx				inx 								; put digit into fractional part of X+1
.24d8	20 1c 25	jsr $251c			jsr 	ESTAShiftDigitIntoMantissa
.24db	ca		dex				dex
.24dc	ee 95 05	inc $0595			inc 	decimalCount 				; bump the count of decimals
.24df	ad 95 05	lda $0595			lda 	decimalCount 				; too many decimal digits.
.24e2	c9 0b		cmp #$0b			cmp 	#11
.24e4	f0 02		beq $24e8			beq 	_ESTADSFail
.24e6	38		sec				sec
.24e7	60		rts				rts
.24e8					_ESTADSFail:
.24e8	18		clc				clc
.24e9	60		rts				rts
.24ea					_ENConstructFinal:
.24ea	ad 95 05	lda $0595			lda 	decimalCount 				; get decimal count
.24ed	f0 2b		beq $251a			beq 	_ENCFExit 					; no decimals
.24ef	5a		phy				phy
.24f0	0a		asl a				asl 	a 							; x 4 and CLC
.24f1	0a		asl a				asl 	a
.24f2	6d 95 05	adc $0595			adc 	decimalCount
.24f5	a8		tay				tay
.24f6	b9 81 21	lda $2181,y			lda 	FloatScalarTable-5,y 		; copy decimal scalar to X+2
.24f9	95 40		sta $40,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.24fb	b9 82 21	lda $2182,y			lda 	FloatScalarTable-5+1,y
.24fe	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.2500	b9 83 21	lda $2183,y			lda 	FloatScalarTable-5+2,y
.2503	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2505	b9 84 21	lda $2184,y			lda 	FloatScalarTable-5+3,y
.2508	95 64		sta $64,x			sta 	NSMantissa3+2,x
.250a	b9 85 21	lda $2185,y			lda 	FloatScalarTable-5+4,y
.250d	95 70		sta $70,x			sta 	NSExponent+2,x
.250f	74 34		stz $34,x			stz 	NSStatus+2,x 				; make +ve
.2511	e8		inx				inx 								; multiply decimal const by decimal scalar
.2512	e8		inx				inx
.2513	20 34 23	jsr $2334			jsr 	FloatMultiply
.2516	20 98 20	jsr $2098			jsr 	FloatAdd 					; add to integer part.
.2519	7a		ply				ply
.251a					_ENCFExit:
.251a	18		clc				clc 								; reject the digit.
.251b	60		rts				rts
.251c					ESTAShiftDigitIntoMantissa:
.251c	29 0f		and #$0f			and 	#15 						; save digit
.251e	48		pha				pha
.251f	b5 62		lda $62,x			lda 	NSMantissa3,x 				; push mantissa on stack
.2521	48		pha				pha
.2522	b5 56		lda $56,x			lda 	NSMantissa2,x
.2524	48		pha				pha
.2525	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2527	48		pha				pha
.2528	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.252a	48		pha				pha
.252b	20 83 26	jsr $2683			jsr 	FloatShiftLeft 				; x 2
.252e	20 83 26	jsr $2683			jsr 	FloatShiftLeft 				; x 4
.2531	18		clc				clc 								; pop mantissa and add
.2532	68		pla				pla
.2533	75 3e		adc $3e,x			adc 	NSMantissa0,x
.2535	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2537	68		pla				pla
.2538	75 4a		adc $4a,x			adc 	NSMantissa1,x
.253a	95 4a		sta $4a,x			sta 	NSMantissa1,x
.253c	68		pla				pla
.253d	75 56		adc $56,x			adc 	NSMantissa2,x
.253f	95 56		sta $56,x			sta 	NSMantissa2,x
.2541	68		pla				pla
.2542	75 62		adc $62,x			adc 	NSMantissa3,x
.2544	95 62		sta $62,x			sta 	NSMantissa3,x 				; x 5
.2546	20 83 26	jsr $2683			jsr 	FloatShiftLeft 				; x 10
.2549	68		pla				pla 								; add digit
.254a	18		clc				clc
.254b	75 3e		adc $3e,x			adc 	NSMantissa0,x
.254d	95 3e		sta $3e,x			sta 	NSMantissa0,x
.254f	90 0a		bcc $255b			bcc 	_ESTASDExit
.2551	f6 4a		inc $4a,x			inc 	NSMantissa1,x
.2553	d0 06		bne $255b			bne 	_ESTASDExit
.2555	f6 56		inc $56,x			inc 	NSMantissa2,x
.2557	d0 02		bne $255b			bne 	_ESTASDExit
.2559	f6 62		inc $62,x			inc 	NSMantissa3,x
.255b					_ESTASDExit:
.255b	60		rts				rts
.0593					encodeState:
>0593							.fill 	1
.0594					digitTemp:
>0594							.fill 	1
.0595					decimalCount:
>0595							.fill 	1
.255c					FloatToString:
.255c	da		phx				phx
.255d	5a		phy				phy 								; save code position
.255e	8d 96 05	sta $0596			sta 	decimalPlaces	 			; save number of DPs.
.2561	9c 97 05	stz $0597			stz 	dbOffset 					; offset into decimal buffer = start.
.2564	b5 32		lda $32,x			lda 	NSStatus,x  				; is it -ve.
.2566	10 08		bpl $2570			bpl 	_CNTSNotNegative
.2568	29 7f		and #$7f			and 	#$7F 						; make +ve
.256a	95 32		sta $32,x			sta 	NSStatus,x
.256c	a9 2d		lda #$2d			lda 	#"-"
.256e	80 02		bra $2572			bra 	_CNTMain
.2570					_CNTSNotNegative:
.2570	a9 20		lda #$20			lda 	#" "
.2572					_CNTMain:
.2572	20 d4 25	jsr $25d4			jsr 	WriteDecimalBuffer
.2575	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check if decimal
.2577	f0 0d		beq $2586			beq 	_CNTSNotFloat
.2579	e8		inx				inx 								; round up so we don't get too many 6.999999
.257a	a9 01		lda #$01			lda 	#1
.257c	20 76 26	jsr $2676			jsr 	FloatSetByte
.257f	b5 6d		lda $6d,x			lda		NSExponent-1,x
.2581	95 6e		sta $6e,x			sta 	NSExponent,x
.2583	20 98 20	jsr $2098			jsr 	FloatAdd
.2586					_CNTSNotFloat:
.2586	20 b6 25	jsr $25b6			jsr 	MakePlusTwoString 			; do the integer part.
.2589	20 54 22	jsr $2254			jsr 	FloatFractionalPart 		; get the fractional part
.258c	20 c9 23	jsr $23c9			jsr 	FloatNormalise					; normalise , exit if zero
.258f	f0 22		beq $25b3			beq 	_CNTSExit
.2591	a9 2e		lda #$2e			lda 	#"."
.2593	20 d4 25	jsr $25d4			jsr 	WriteDecimalBuffer 			; write decimal place
.2596					_CNTSDecimal:
.2596	ce 96 05	dec $0596			dec 	decimalPlaces 				; done all the decimals
.2599	30 18		bmi $25b3			bmi 	_CNTSExit
.259b	e8		inx				inx 								; x 10.0
.259c	a9 0a		lda #$0a			lda 	#10
.259e	20 76 26	jsr $2676			jsr 	FloatSetByte
.25a1	20 34 23	jsr $2334			jsr 	FloatMultiply
.25a4	20 b6 25	jsr $25b6			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.25a7	20 54 22	jsr $2254			jsr 	FloatFractionalPart 		; get the fractional part
.25aa	20 c9 23	jsr $23c9			jsr 	FloatNormalise 				; normalise it.
.25ad	b5 6e		lda $6e,x			lda 	NSExponent,x 				; gone to zero, exit.
.25af	c9 d0		cmp #$d0			cmp 	#$D0 						; very small remainder, so don't bother.
.25b1	b0 e3		bcs $2596			bcs 	_CNTSDecimal 				; keep going.
.25b3					_CNTSExit:
.25b3	7a		ply				ply
.25b4	fa		plx				plx
.25b5	60		rts				rts
.25b6					MakePlusTwoString:
.25b6	da		phx				phx
.25b7	20 57 26	jsr $2657			jsr 	FloatShiftUpTwo 			; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.25ba	e8		inx				inx 								; access it
.25bb	e8		inx				inx
.25bc	20 af 22	jsr $22af			jsr 	FloatIntegerPart 			; make it an integer
.25bf	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.25c1	20 f3 25	jsr $25f3			jsr 	ConvertInt32
.25c4	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.25c6					_MPTSCopy:
.25c6	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25c9	20 d4 25	jsr $25d4			jsr 	WriteDecimalBuffer
.25cc	e8		inx				inx
.25cd	bd 71 05	lda $0571,x			lda 	numberBuffer,x
.25d0	d0 f4		bne $25c6			bne 	_MPTSCopy
.25d2	fa		plx				plx
.25d3	60		rts				rts
.25d4					WriteDecimalBuffer:
.25d4	da		phx				phx
.25d5	ae 97 05	ldx $0597			ldx 	dbOffset
.25d8	9d 98 05	sta $0598,x			sta 	decimalBuffer,x
.25db	9e 99 05	stz $0599,x			stz 	decimalBuffer+1,x
.25de	ee 97 05	inc $0597			inc 	dbOffset
.25e1	fa		plx				plx
.25e2	60		rts				rts
.0596					decimalPlaces:
>0596							.fill 	1
.0597					dbOffset:
>0597							.fill 	1
.0598					decimalBuffer:
>0598							.fill 	32
.25e3					ConvertInt16:
.25e3	85 3e		sta $3e				sta 	NSMantissa0 				; set up as 32 bit conversion
.25e5	86 4a		stx $4a				stx 	NSMantissa1
.25e7	64 56		stz $56				stz 	NSMantissa2
.25e9	64 62		stz $62				stz 	NSMantissa3
.25eb	64 32		stz $32				stz 	NSStatus 					; positive integer
.25ed	a2 00		ldx #$00			ldx 	#0 							; stack level
.25ef	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.25f1	80 00		bra $25f3			bra 	ConvertInt32
.25f3					ConvertInt32:
.25f3	5a		phy				phy
.25f4	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.25f6	24 32		bit $32				bit 	NSStatus 					; output a - if not negative.
.25f8	10 08		bpl $2602			bpl 	_CI32NotNeg
.25fa	48		pha				pha
.25fb	a9 2d		lda #$2d			lda 	#'-'
.25fd	99 71 05	sta $0571,y			sta 	numberBuffer,y
.2600	c8		iny				iny
.2601	68		pla				pla
.2602					_CI32NotNeg:
.2602	20 10 26	jsr $2610			jsr 	_CI32DivideConvert 			; recursive conversion
.2605	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.2607	99 71 05	sta $0571,y			sta 	numberBuffer,y
.260a	7a		ply				ply
.260b	a2 05		ldx #$05			ldx 	#numberBuffer >> 8 			; return address in XA
.260d	a9 71		lda #$71			lda 	#numberBuffer & $FF
.260f	60		rts				rts
.2610					_CI32DivideConvert:
.2610	e8		inx				inx 								; write to next slot up
.2611	20 76 26	jsr $2676			jsr 	FloatSetByte 		 		; write the base out.
.2614	ca		dex				dex
.2615	20 0a 22	jsr $220a			jsr 	Int32Divide 				; divide
.2618	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; save remainder
.261a	48		pha				pha
.261b	20 f9 21	jsr $21f9			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.261e	20 96 26	jsr $2696			jsr 	FloatIsZero 				; is it zero ?
.2621	f0 05		beq $2628			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.2623	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.2625	20 10 26	jsr $2610			jsr 	_CI32DivideConvert 			; and recusrively call.
.2628					_CI32NoRecurse:
.2628	68		pla				pla 								; remainder
.2629	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.262b	90 02		bcc $262f			bcc 	_CI32NotHex
.262d	69 26		adc #$26			adc 	#6+32
.262f					_CI32NotHex:
.262f	69 30		adc #$30			adc 	#48
.2631	99 71 05	sta $0571,y			sta 	numberBuffer,y 				; write out and exit
.2634	c8		iny				iny
.2635	60		rts				rts
.2636					FloatNegate:
.2636	b5 32		lda $32,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.2638	49 80		eor #$80			eor 	#$80  						; toggle the negative flag
.263a	95 32		sta $32,x			sta 	NSStatus,x
.263c	60		rts				rts
.263d					FloatNegateMantissa:
.263d	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.263e	a9 00		lda #$00			lda 	#0
.2640	f5 3e		sbc $3e,x			sbc 	NSMantissa0,x
.2642	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2644	a9 00		lda #$00			lda 	#0
.2646	f5 4a		sbc $4a,x			sbc 	NSMantissa1,x
.2648	95 4a		sta $4a,x			sta 	NSMantissa1,x
.264a	a9 00		lda #$00			lda 	#0
.264c	f5 56		sbc $56,x			sbc 	NSMantissa2,x
.264e	95 56		sta $56,x			sta 	NSMantissa2,x
.2650	a9 00		lda #$00			lda 	#0
.2652	f5 62		sbc $62,x			sbc 	NSMantissa3,x
.2654	95 62		sta $62,x			sta 	NSMantissa3,x
.2656	60		rts				rts
.2657					FloatShiftUpTwo:
.2657	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2659	95 40		sta $40,x			sta 	NSMantissa0+2,x
.265b	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.265d	95 4c		sta $4c,x			sta 	NSMantissa1+2,x
.265f	b5 56		lda $56,x			lda 	NSMantissa2,x
.2661	95 58		sta $58,x			sta 	NSMantissa2+2,x
.2663	b5 62		lda $62,x			lda 	NSMantissa3,x
.2665	95 64		sta $64,x			sta 	NSMantissa3+2,x
.2667	b5 6e		lda $6e,x			lda 	NSExponent,x
.2669	95 70		sta $70,x			sta 	NSExponent+2,x
.266b	b5 32		lda $32,x			lda 	NSStatus,x
.266d	95 34		sta $34,x			sta 	NSStatus+2,x
.266f	60		rts				rts
.2670					FloatSetZeroMantissaOnly:
.2670	74 3e		stz $3e,x			stz 	NSMantissa0,x
.2672	80 08		bra $267c			bra 	FloatZero13
.2674					FloatSetZero:
.2674	a9 00		lda #$00			lda 	#0
.2676					FloatSetByte:
.2676	74 6e		stz $6e,x			stz 	NSExponent,x 				; zero exponent, as +ve integer value.
.2678					FloatSetMantissa:
.2678	95 3e		sta $3e,x			sta 	NSMantissa0,x 				; zero mantissa
.267a	74 32		stz $32,x			stz 	NSStatus,x
.267c					FloatZero13:
.267c	74 4a		stz $4a,x			stz 	NSMantissa1,x
.267e	74 56		stz $56,x			stz 	NSMantissa2,x
.2680	74 62		stz $62,x			stz 	NSMantissa3,x
.2682	60		rts				rts
.2683					FloatShiftLeft:
.2683	18		clc				clc
.2684					FloatRotateLeft:
.2684	36 3e		rol $3e,x			rol 	NSMantissa0,x
.2686	36 4a		rol $4a,x			rol		NSMantissa1,x
.2688	36 56		rol $56,x			rol		NSMantissa2,x
.268a	36 62		rol $62,x			rol		NSMantissa3,x
.268c	60		rts				rts
.268d					FloatShiftRight:
.268d	56 62		lsr $62,x			lsr 	NSMantissa3,x
.268f	76 56		ror $56,x			ror		NSMantissa2,x
.2691	76 4a		ror $4a,x			ror		NSMantissa1,x
.2693	76 3e		ror $3e,x			ror		NSMantissa0,x
.2695	60		rts				rts
.2696					FloatIsZero:
.2696	b5 62		lda $62,x			lda 	NSMantissa3,x
.2698	15 56		ora $56,x			ora		NSMantissa2,x
.269a	15 4a		ora $4a,x			ora		NSMantissa1,x
.269c	15 3e		ora $3e,x			ora		NSMantissa0,x
.269e	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/polynomials.library

.269f					FloatArcTan:
.269f	20 c9 23	jsr $23c9			jsr 	FloatNormalise 					; normalise x
.26a2	b5 32		lda $32,x			lda 	NSStatus,x 						; save sign, make absolute
.26a4	48		pha				pha
.26a5	74 32		stz $32,x			stz 	NSStatus,x
.26a7	b5 6e		lda $6e,x			lda 	NSExponent,x 					; $40000000 ^ $E2 is 1.0
.26a9	c9 e2		cmp #$e2			cmp 	#$E2
.26ab	90 25		bcc $26d2			bcc 	_UANoFixup
.26ad	8a		txa				txa 									; value in +1
.26ae	a8		tay				tay
.26af	c8		iny				iny
.26b0	20 58 28	jsr $2858			jsr 	CopyFloatXY
.26b3	a9 01		lda #$01			lda 	#1 								; 1.0 in +0
.26b5	20 76 26	jsr $2676			jsr 	FloatSetByte
.26b8	e8		inx				inx
.26b9	20 bd 21	jsr $21bd			jsr 	FloatDivide
.26bc	b0 21		bcs $26df			bcs 	_FATError
.26be	20 e2 26	jsr $26e2			jsr 	CoreAtn 						; calculate the root
.26c1	20 4d 28	jsr $284d			jsr 	CompletePolynomial
.26c4	20 36 26	jsr $2636			jsr 	FloatNegate 					; make -ve
.26c7	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.26c9	20 a4 28	jsr $28a4			jsr 	LoadConstant
.26cc	e8		inx				inx
.26cd	20 98 20	jsr $2098			jsr 	FloatAdd
.26d0	80 06		bra $26d8			bra 	_UAComplete
.26d2					_UANoFixup:
.26d2	20 e2 26	jsr $26e2			jsr 	CoreAtn
.26d5	20 4d 28	jsr $284d			jsr 	CompletePolynomial
.26d8					_UAComplete:
.26d8	68		pla				pla 									; apply the result.
.26d9	55 32		eor $32,x			eor 	NSStatus,x
.26db	95 32		sta $32,x			sta 	NSStatus,x
.26dd	18		clc				clc
.26de	60		rts				rts
.26df					_FATError:
.26df	68		pla				pla
.26e0	38		sec				sec
.26e1	60		rts				rts
.26e2					CoreAtn:
.26e2	a9 50		lda #$50			lda 	#AtnCoefficients & $FF
.26e4	a0 27		ldy #$27			ldy 	#AtnCoefficients >> 8
.26e6	4c a1 29	jmp $29a1			jmp 	CorePolySquared
.26e9					ExpCoefficients:
>26e9	07					.byte	7
>26ea	2b 1f 2c 5a				.dword	$5a2c1f2b ; 2.1498763701e-05
>26ee	d2					.byte	$d2
>26ef	8e 59 3f 4b				.dword	$4b3f598e ; 0.00014352314037
>26f3	d5					.byte	$d5
>26f4	c3 71 f7 57				.dword	$57f771c3 ; 0.0013422634825
>26f8	d8					.byte	$d8
>26f9	15 0e c2 4e				.dword	$4ec20e15 ; 0.0096140170135
>26fd	db					.byte	$db
>26fe	05 ac ac 71				.dword	$71acac05 ; 0.05550512686
>2702	dd					.byte	$dd
>2703	e3 f3 fe 7a				.dword	$7afef3e3 ; 0.2402263846
>2707	df					.byte	$df
>2708	08 0c b9 58				.dword	$58b90c08 ; 0.69314718618
>270c	e1					.byte	$e1
>270d	00 00 00 40				.dword	$40000000 ; 1.0
>2711	e2					.byte	$e2
.2712					SinCoefficients:
>2712	06					.byte	6
>2713	8d 16 0d f3				.dword	$f30d168d ; -14.381390672
>2717	e5					.byte	$e5
>2718	fc fd 03 54				.dword	$5403fdfc ; 42.007797122
>271c	e7					.byte	$e7
>271d	81 44 b4 cc				.dword	$ccb44481 ; -76.704170257
>2721	e8					.byte	$e8
>2722	f1 ef 9a 51				.dword	$519aeff1 ; 81.605223686
>2726	e8					.byte	$e8
>2727	94 f3 ae d2				.dword	$d2aef394 ; -41.341702104
>272b	e7					.byte	$e7
>272c	51 ed 87 64				.dword	$6487ed51 ; 6.2831853069
>2730	e4					.byte	$e4
>2731	00 00 00 00				.dword	$00000000 ; 0.0
>2735	00					.byte	$00
.2736					LogCoefficients:
>2736	04					.byte	4
>2737	bd 65 2b 6f				.dword	$6f2b65bd ; 0.43425594189
>273b	e0					.byte	$e0
>273c	b2 85 cd 49				.dword	$49cd85b2 ; 0.57658454124
>2740	e1					.byte	$e1
>2741	8b 49 1c 7b				.dword	$7b1c498b ; 0.96180075919
>2745	e1					.byte	$e1
>2746	90 1d 55 5c				.dword	$5c551d90 ; 2.8853900731
>274a	e3					.byte	$e3
>274b	00 00 00 c0				.dword	$c0000000 ; -0.5
>274f	e1					.byte	$e1
.2750					AtnCoefficients:
>2750	0c					.byte	12
>2751	ea de c1 d9				.dword	$d9c1deea ; -0.00068479391189
>2755	d7					.byte	$d7
>2756	7a 53 7a 4f				.dword	$4f7a537a ; 0.0048509421558
>275a	da					.byte	$da
>275b	08 58 fe c1				.dword	$c1fe5808 ; -0.016111701843
>275f	dc					.byte	$dc
>2760	e5 b3 0f 46				.dword	$460fb3e5 ; 0.034209638048
>2764	dd					.byte	$dd
>2765	e1 e5 29 ef				.dword	$ef29e5e1 ; -0.054279132761
>2769	dd					.byte	$dd
>276a	26 38 32 4a				.dword	$4a323826 ; 0.07245719654
>276e	de					.byte	$de
>276f	bd 28 f5 db				.dword	$dbf528bd ; -0.089802395378
>2773	de					.byte	$de
>2774	3f 44 98 71				.dword	$7198443f ; 0.11093241343
>2778	de					.byte	$de
>2779	9d 4c 22 c9				.dword	$c9224c9d ; -0.14283980767
>277d	df					.byte	$df
>277e	e3 48 66 66				.dword	$666648e3 ; 0.19999912049
>2782	df					.byte	$df
>2783	0a 55 55 d5				.dword	$d555550a ; -0.33333331568
>2787	e0					.byte	$e0
>2788	00 00 00 40				.dword	$40000000 ; 1.0
>278c	e2					.byte	$e2
>278d	00 00 00 00				.dword	$00000000 ; 0.0
>2791	00					.byte	$00
.2792					Const_Base:
.2792					Const_1Div2Pi:
>2792	b7 c1 7c 51				.dword	$517cc1b7 ; 0.15915494
>2796	df					.byte	$df
.2797					Const_PiDiv2:
>2797	51 ed 87 64				.dword	$6487ed51 ; 1.57079633
>279b	e2					.byte	$e2
.279c					Const_Log2_e:
>279c	95 1d 55 5c				.dword	$5c551d95 ; 1.44269504
>27a0	e2					.byte	$e2
.27a1					Const_sqrt_2:
>27a1	9a 79 82 5a				.dword	$5a82799a ; 1.41421356
>27a5	e2					.byte	$e2
.27a6					Const_sqrt_half:
>27a6	9a 79 82 5a				.dword	$5a82799a ; 0.70710678
>27aa	e1					.byte	$e1
.27ab					Const_pi:
>27ab	51 ed 87 64				.dword	$6487ed51 ; 3.14159265
>27af	e3					.byte	$e3
.27b0					Const_half:
>27b0	00 00 00 40				.dword	$40000000 ; 0.50000000
>27b4	e1					.byte	$e1
.27b5					Const_ln_e:
>27b5	fc 0b b9 58				.dword	$58b90bfc ; 0.69314718
>27b9	e1					.byte	$e1
.27ba					FloatCosine:
.27ba	a9 05		lda #$05			lda 	#Const_PiDiv2-Const_Base
.27bc	20 a4 28	jsr $28a4			jsr 	LoadConstant
.27bf	e8		inx				inx
.27c0	20 98 20	jsr $2098			jsr 	FloatAdd
.27c3	4c 5a 29	jmp $295a			jmp 	FloatSine
.27c6					FloatExponent:
.27c6	a9 0a		lda #$0a			lda 	#Const_Log2_e-Const_Base
.27c8	20 a4 28	jsr $28a4			jsr 	LoadConstant
.27cb	e8		inx				inx
.27cc	20 34 23	jsr $2334			jsr 	FloatMultiply
.27cf	20 11 28	jsr $2811			jsr 	_UECopy01 				; copy 0 to 1, get integer part to 1
.27d2	e8		inx				inx
.27d3	20 af 22	jsr $22af			jsr 	FloatIntegerPart
.27d6	ca		dex				dex
.27d7	b5 4b		lda $4b,x			lda 	NSMantissa1+1,x
.27d9	15 57		ora $57,x			ora 	NSMantissa2+1,x
.27db	15 63		ora $63,x			ora 	NSMantissa3+1,x
.27dd	d0 38		bne $2817			bne 	_UERangeError
.27df	b5 3f		lda $3f,x			lda 	NSMantissa0+1,x 		; push integer part on stack.
.27e1	c9 40		cmp #$40			cmp 	#64
.27e3	b0 32		bcs $2817			bcs 	_UERangeError
.27e5	48		pha				pha
.27e6	b5 32		lda $32,x			lda 	NSStatus,x 				; push sign
.27e8	48		pha				pha
.27e9	20 54 22	jsr $2254			jsr 	FloatFractionalPart		; copy 0 to 1, get fractional part to 0
.27ec	68		pla				pla
.27ed	10 14		bpl $2803			bpl 	_UEPositive
.27ef	e8		inx				inx 							; 1-x
.27f0	a9 01		lda #$01			lda 	#1
.27f2	20 76 26	jsr $2676			jsr 	FloatSetByte
.27f5	ca		dex				dex
.27f6	20 36 26	jsr $2636			jsr 	FloatNegate
.27f9	e8		inx				inx
.27fa	20 98 20	jsr $2098			jsr 	FloatAdd
.27fd	68		pla				pla 							; integer part +1 and negated.
.27fe	1a		inc a				inc 	a
.27ff	49 ff		eor #$ff			eor 	#$FF
.2801	1a		inc a				inc 	a
.2802	48		pha				pha
.2803					_UEPositive:
.2803	20 19 28	jsr $2819			jsr 	CoreExponent
.2806	20 4d 28	jsr $284d			jsr 	CompletePolynomial
.2809	68		pla				pla
.280a	18		clc				clc
.280b	75 6e		adc $6e,x			adc 	NSExponent,x
.280d	95 6e		sta $6e,x			sta 	NSExponent,x
.280f	18		clc				clc
.2810	60		rts				rts
.2811					_UECopy01:
.2811	8a		txa				txa
.2812	a8		tay				tay
.2813	c8		iny				iny
.2814	4c 58 28	jmp $2858			jmp 	CopyFloatXY
.2817					_UERangeError:
.2817	38		sec				sec
.2818	60		rts				rts
.2819					CoreExponent:
.2819	a9 e9		lda #$e9			lda 	#ExpCoefficients & $FF
.281b	a0 26		ldy #$26			ldy 	#ExpCoefficients >> 8
.281d	20 21 28	jsr $2821			jsr 	CalculateHornerPolynomial
.2820	60		rts				rts
.2821					CalculateHornerPolynomial:
.2821	85 2c		sta $2c				sta 	zTemp0 						; save poly data from YA
.2823	84 2d		sty $2d				sty 	zTemp0+1
.2825	9c b8 05	stz $05b8			stz 	coefficientCount 			; zero the count.
.2828	8e b9 05	stx $05b9			stx 	xValueSlot 					; save xValue slot.
.282b	e8		inx				inx 								; set the count to zero.
.282c	20 74 26	jsr $2674			jsr 	FloatSetZero
.282f					_CHPLoop:
.282f	8a		txa				txa 								; copy X-1 to X+1
.2830	a8		tay				tay
.2831	ca		dex				dex
.2832	c8		iny				iny
.2833	20 58 28	jsr $2858			jsr 	CopyFloatXY 				; e.g. stack is <current> <x>
.2836	e8		inx				inx
.2837	e8		inx				inx
.2838	20 34 23	jsr $2334			jsr 	FloatMultiply 				; times current by X
.283b	e8		inx				inx
.283c	20 77 28	jsr $2877			jsr 	GetCoefficient 				; coefficient into X+1
.283f	20 98 20	jsr $2098			jsr 	FloatAdd 					; and add
.2842	ee b8 05	inc $05b8			inc 	coefficientCount
.2845	ad b8 05	lda $05b8			lda 	coefficientCount
.2848	d2 2c		cmp ($2c)			cmp 	(zTemp0)
.284a	d0 e3		bne $282f			bne 	_CHPLoop
.284c	60		rts				rts
.284d					CompletePolynomial:
.284d	20 34 23	jsr $2334			jsr 	FloatMultiply
.2850	e8		inx				inx 								; get the last value
.2851	20 77 28	jsr $2877			jsr 	GetCoefficient
.2854	20 98 20	jsr $2098			jsr 	FloatAdd 					; and add it
.2857	60		rts				rts
.2858					CopyFloatXY:
.2858	b5 6e		lda $6e,x			lda 	NSExponent,x
.285a	99 6e 00	sta $006e,y			sta 	NSExponent,y
.285d	b5 32		lda $32,x			lda 	NSStatus,x
.285f	99 32 00	sta $0032,y			sta 	NSStatus,y
.2862	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2864	99 3e 00	sta $003e,y			sta 	NSMantissa0,y
.2867	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2869	99 4a 00	sta $004a,y			sta 	NSMantissa1,y
.286c	b5 56		lda $56,x			lda 	NSMantissa2,x
.286e	99 56 00	sta $0056,y			sta 	NSMantissa2,y
.2871	b5 62		lda $62,x			lda 	NSMantissa3,x
.2873	99 62 00	sta $0062,y			sta 	NSMantissa3,y
.2876	60		rts				rts
.2877					GetCoefficient:
.2877	5a		phy				phy
.2878	ad b8 05	lda $05b8			lda 	coefficientCount 			; 5 per block
.287b	0a		asl a				asl 	a
.287c	0a		asl a				asl 	a
.287d	38		sec				sec 								; +1 for count
.287e	6d b8 05	adc $05b8			adc 	coefficientCount
.2881	a8		tay				tay
.2882	b1 2c		lda ($2c),y			lda 	(zTemp0),y 					; copy mantissa
.2884	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2886	c8		iny				iny
.2887	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2889	95 4a		sta $4a,x			sta 	NSMantissa1,x
.288b	c8		iny				iny
.288c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.288e	95 56		sta $56,x			sta 	NSMantissa2,x
.2890	c8		iny				iny
.2891	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2893	48		pha				pha
.2894	29 7f		and #$7f			and 	#$7F 						; clear sign bit.
.2896	95 62		sta $62,x			sta 	NSMantissa3,x
.2898	c8		iny				iny
.2899	68		pla				pla
.289a	29 80		and #$80			and 	#$80
.289c	95 32		sta $32,x			sta 	NSStatus,x 					; put in status
.289e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.28a0	95 6e		sta $6e,x			sta 	NSExponent,x
.28a2	7a		ply				ply
.28a3	60		rts				rts
.05b8					coefficientCount:
>05b8							.fill 	1
.05b9					xValueSlot:
>05b9							.fill 	1
.28a4					LoadConstant:
.28a4	5a		phy				phy
.28a5	a8		tay				tay
.28a6	b9 92 27	lda $2792,y			lda 	Const_Base+0,y
.28a9	95 3f		sta $3f,x			sta 	NSMantissa0+1,x
.28ab	b9 93 27	lda $2793,y			lda 	Const_Base+1,y
.28ae	95 4b		sta $4b,x			sta 	NSMantissa1+1,x
.28b0	b9 94 27	lda $2794,y			lda 	Const_Base+2,y
.28b3	95 57		sta $57,x			sta 	NSMantissa2+1,x
.28b5	b9 95 27	lda $2795,y			lda 	Const_Base+3,y
.28b8	48		pha				pha
.28b9	29 7f		and #$7f			and 	#$7F
.28bb	95 63		sta $63,x			sta 	NSMantissa3+1,x
.28bd	68		pla				pla
.28be	29 80		and #$80			and 	#$80
.28c0	95 33		sta $33,x			sta 	NSStatus+1,x
.28c2	b9 96 27	lda $2796,y			lda 	Const_Base+4,y
.28c5	95 6f		sta $6f,x			sta 	NSExponent+1,x
.28c7	7a		ply				ply
.28c8	60		rts				rts
.28c9					FloatLogarithm:
.28c9	b5 32		lda $32,x			lda 	NSStatus,x 					; check > 0
.28cb	30 5f		bmi $292c			bmi 	_ULRange
.28cd	20 96 26	jsr $2696			jsr 	FloatIsZero
.28d0	f0 5a		beq $292c			beq 	_ULRange
.28d2	20 c9 23	jsr $23c9			jsr 	FloatNormalise 				; put into FP mode.
.28d5	b5 6e		lda $6e,x			lda 	NSExponent,x 				; get power
.28d7	48		pha				pha
.28d8	a9 e1		lda #$e1			lda 	#(-31) & $FF 				; force into range 0.5 -> 1
.28da	95 6e		sta $6e,x			sta 	NSExponent,x
.28dc	a9 14		lda #$14			lda 	#Const_sqrt_half-Const_Base
.28de	20 a4 28	jsr $28a4			jsr 	LoadConstant
.28e1	e8		inx				inx
.28e2	20 98 20	jsr $2098			jsr 	FloatAdd
.28e5	8a		txa				txa 								; divide into sqrt 2.0
.28e6	a8		tay				tay
.28e7	c8		iny				iny
.28e8	20 58 28	jsr $2858			jsr 	CopyFloatXY
.28eb	ca		dex				dex
.28ec	a9 0f		lda #$0f			lda 	#Const_sqrt_2-Const_Base
.28ee	20 a4 28	jsr $28a4			jsr 	LoadConstant
.28f1	e8		inx				inx
.28f2	e8		inx				inx
.28f3	20 bd 21	jsr $21bd			jsr 	FloatDivide 				; if zero, error.
.28f6	b0 33		bcs $292b			bcs 	_ULRangePla
.28f8	20 36 26	jsr $2636			jsr 	FloatNegate 				; subtract from 1
.28fb	e8		inx				inx
.28fc	a9 01		lda #$01			lda 	#1
.28fe	20 76 26	jsr $2676			jsr 	FloatSetByte
.2901	20 98 20	jsr $2098			jsr 	FloatAdd
.2904	20 2e 29	jsr $292e			jsr 	CoreLog
.2907	20 4d 28	jsr $284d			jsr 	CompletePolynomial
.290a	68		pla				pla 								; add exponent
.290b	18		clc				clc
.290c	69 1f		adc #$1f			adc 	#31 						; fix up
.290e	48		pha				pha
.290f	10 03		bpl $2914			bpl 	_LogNotNeg
.2911	49 ff		eor #$ff			eor 	#$FF
.2913	1a		inc a				inc 	a
.2914					_LogNotNeg:
.2914	e8		inx				inx 								; set byte and sign.
.2915	20 76 26	jsr $2676			jsr 	FloatSetByte
.2918	68		pla				pla
.2919	29 80		and #$80			and 	#$80
.291b	95 32		sta $32,x			sta 	NSStatus,x
.291d	20 98 20	jsr $2098			jsr 	FloatAdd
.2920	a9 23		lda #$23			lda 	#Const_ln_e-Const_Base
.2922	20 a4 28	jsr $28a4			jsr 	LoadConstant
.2925	e8		inx				inx
.2926	20 34 23	jsr $2334			jsr 	FloatMultiply
.2929	18		clc				clc
.292a	60		rts				rts
.292b					_ULRangePla:
.292b	68		pla				pla
.292c					_ULRange:
.292c	38		sec				sec
.292d	60		rts				rts
.292e					CoreLog:
.292e	a9 36		lda #$36			lda 	#LogCoefficients & $FF
.2930	a0 27		ldy #$27			ldy 	#LogCoefficients >> 8
.2932	4c a1 29	jmp $29a1			jmp 	CorePolySquared
.2935					FloatPI:
.2935	a9 19		lda #$19			lda 	#Const_pi-Const_Base
.2937	20 a4 28	jsr $28a4			jsr 	LoadConstant
.293a	e8		inx				inx
.293b	18		clc				clc
.293c	60		rts				rts
.293d					FloatPower:
.293d	ca		dex				dex
.293e	8a		txa				txa 							; copy 0 to 2, so we can process it
.293f	a8		tay				tay
.2940	c8		iny				iny
.2941	c8		iny				iny
.2942	20 58 28	jsr $2858			jsr 	CopyFloatXY
.2945	e8		inx				inx 							; 2 = Log(0)
.2946	e8		inx				inx
.2947	20 c9 28	jsr $28c9			jsr 	FloatLogarithm
.294a	b0 0d		bcs $2959			bcs 	_FPWExit
.294c	20 34 23	jsr $2334			jsr 	FloatMultiply			; Multiply by original 1, into 1.
.294f	8a		txa				txa 							; copy to slot 0
.2950	a8		tay				tay
.2951	88		dey				dey
.2952	20 58 28	jsr $2858			jsr 	CopyFloatXY
.2955	ca		dex				dex  							; Exponent code.
.2956	20 c6 27	jsr $27c6			jsr 	FloatExponent
.2959					_FPWExit:
.2959	60		rts				rts
.295a					FloatSine:
.295a	b5 32		lda $32,x			lda 	NSStatus,x 					; save sign
.295c	48		pha				pha
.295d	74 32		stz $32,x			stz 	NSStatus,x 					; make +ve
.295f	a9 00		lda #$00			lda 	#Const_1Div2Pi-Const_Base
.2961	20 a4 28	jsr $28a4			jsr 	LoadConstant
.2964	e8		inx				inx
.2965	20 34 23	jsr $2334			jsr 	FloatMultiply
.2968	20 54 22	jsr $2254			jsr 	FloatFractionalPart 		; take the fractional part
.296b	b5 6e		lda $6e,x			lda 	NSExponent,x 				; check exponent
.296d	c9 e0		cmp #$e0			cmp 	#$E0 						; < $E0 exponent : 0-0.25
.296f	90 1f		bcc $2990			bcc 	_USProcessExit
.2971	f0 06		beq $2979			beq 	_USSubtractFromHalf 		; = $E0 exponent : 0.25-0.5
.2973	b5 62		lda $62,x			lda 	NSMantissa3,x 				; if > 0.75 which is $60000000:$E1
.2975	c9 60		cmp #$60			cmp 	#$60
.2977	b0 0e		bcs $2987			bcs 	_USSubtractOne
.2979					_USSubtractFromHalf:
.2979	a9 1e		lda #$1e			lda 	#Const_half-Const_Base
.297b	20 a4 28	jsr $28a4			jsr 	LoadConstant
.297e	e8		inx				inx
.297f	20 92 20	jsr $2092			jsr 	FloatSubtract
.2982	20 36 26	jsr $2636			jsr 	FloatNegate 				; then negate it
.2985	80 09		bra $2990			bra 	_USProcessExit 				; and exit
.2987					_USSubtractOne:
.2987	e8		inx				inx
.2988	a9 01		lda #$01			lda 	#1
.298a	20 76 26	jsr $2676			jsr 	FloatSetByte
.298d	20 92 20	jsr $2092			jsr 	FloatSubtract
.2990					_USProcessExit:
.2990	20 9d 29	jsr $299d			jsr 	CoreSine
.2993	20 4d 28	jsr $284d			jsr 	CompletePolynomial
.2996	68		pla				pla 								; restore sign and apply
.2997	55 32		eor $32,x			eor 	NSStatus,x
.2999	95 32		sta $32,x			sta 	NSStatus,x
.299b	18		clc				clc
.299c	60		rts				rts
.299d					CoreSine:
.299d	a9 12		lda #$12			lda 	#SinCoefficients & $FF
.299f	a0 27		ldy #$27			ldy 	#SinCoefficients >> 8
.29a1					CorePolySquared:
.29a1	48		pha				pha 								; save coefficient table
.29a2	5a		phy				phy
.29a3	8a		txa				txa 								; copy X to +1, +2
.29a4	a8		tay				tay
.29a5	c8		iny				iny
.29a6	20 58 28	jsr $2858			jsr 	CopyFloatXY
.29a9	c8		iny				iny
.29aa	20 58 28	jsr $2858			jsr 	CopyFloatXY
.29ad	e8		inx				inx 								; point to the pair and put x^2 on stack
.29ae	e8		inx				inx
.29af	20 34 23	jsr $2334			jsr 	FloatMultiply
.29b2	7a		ply				ply 								; coefficient table back.
.29b3	68		pla				pla
.29b4	20 21 28	jsr $2821			jsr 	CalculateHornerPolynomial
.29b7	8a		txa				txa 								; copy back to slot #1
.29b8	a8		tay				tay
.29b9	88		dey				dey
.29ba	20 58 28	jsr $2858			jsr	 	CopyFloatXY
.29bd	ca		dex				dex 								; point at result
.29be	60		rts				rts
.29bf					FloatSquareRoot:
.29bf	20 c9 28	jsr $28c9			jsr 	FloatLogarithm
.29c2	b0 06		bcs $29ca			bcs 	_FSQExit
.29c4	d6 6e		dec $6e,x			dec 	NSExponent,x
.29c6	20 c6 27	jsr $27c6			jsr 	FloatExponent
.29c9	18		clc				clc
.29ca					_FSQExit:
.29ca	60		rts				rts
.29cb					FloatTangent:
.29cb	da		phx				phx
.29cc	8a		txa				txa 								; sin -> +1
.29cd	a8		tay				tay
.29ce	c8		iny				iny
.29cf	20 58 28	jsr $2858			jsr 	CopyFloatXY
.29d2	e8		inx				inx
.29d3	20 5a 29	jsr $295a			jsr 	FloatSine
.29d6	ca		dex				dex
.29d7	8a		txa				txa 								; cos -> +2
.29d8	a8		tay				tay
.29d9	c8		iny				iny
.29da	c8		iny				iny
.29db	20 58 28	jsr $2858			jsr 	CopyFloatXY
.29de	e8		inx				inx
.29df	e8		inx				inx
.29e0	20 ba 27	jsr $27ba			jsr 	FloatCosine
.29e3	20 bd 21	jsr $21bd			jsr 	FloatDivide 				; calculate sin/cos
.29e6	b0 07		bcs $29ef			bcs 	_FTExit 					; divide by zero
.29e8	8a		txa				txa 								; copy result down.
.29e9	a8		tay				tay
.29ea	88		dey				dey
.29eb	20 58 28	jsr $2858			jsr 	CopyFloatXY
.29ee	18		clc				clc
.29ef					_FTExit:
.29ef	fa		plx				plx
.29f0	60		rts				rts

;******  Processing input file: /home/paulr/Projects/blitz-compiler/documents/../bin/compiler.library

=0					BLC_OPENIN = 0
=1					BLC_CLOSEIN = 1
=2					BLC_READIN = 2
=3					BLC_RESETOUT = 3
=4					BLC_CLOSEOUT = 4
=5					BLC_WRITEOUT = 5
=6					BLC_PRINTCHAR = 6
.007a					srcPtr:
>007a							.fill 	2
.05ba					currentLineNumber:
>05ba							.fill 	2
.29f1					InlineNonDecimal:
.29f1	a2 02		ldx #$02			ldx 	#2 							; get size in X
.29f3	c9 25		cmp #$25			cmp 	#"%"
.29f5	f0 02		beq $29f9			beq 	_INDBinary
.29f7	a2 10		ldx #$10			ldx 	#16
.29f9					_INDBinary:
.29f9	85 2e		sta $2e				sta 	zTemp1 						; size => zTemp1
.29fb	64 2f		stz $2f				stz 	zTemp1+1 					; count => zTemp1+1, at least 1 !
.29fd	64 2c		stz $2c				stz 	zTemp0 						; zero result
.29ff	64 2d		stz $2d				stz 	zTemp0+1
.2a01					_INDLoop:
.2a01	20 ab 33	jsr $33ab			jsr 	LookNext 					; check next character
.2a04	20 e7 33	jsr $33e7			jsr 	ConvertHexStyle		 		; convert into range 0-35 for 0-9A-Z
.2a07	90 1f		bcc $2a28			bcc		_INDDone 					; didn't convert
.2a09	c5 2e		cmp $2e				cmp 	zTemp1 						; size too large ?
.2a0b	b0 1b		bcs $2a28			bcs 	_INDDone
.2a0d	20 37 2a	jsr $2a37			jsr 	_INDShift 					; x 2 or x 16
.2a10	e0 02		cpx #$02			cpx 	#2
.2a12	f0 09		beq $2a1d			beq 	_INDNotHex
.2a14	20 37 2a	jsr $2a37			jsr 	_INDShift
.2a17	20 37 2a	jsr $2a37			jsr 	_INDShift
.2a1a	20 37 2a	jsr $2a37			jsr 	_INDShift
.2a1d					_INDNotHex:
.2a1d	05 2c		ora $2c				ora 	zTemp0 						; or digit into result
.2a1f	85 2c		sta $2c				sta 	zTemp0
.2a21	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume
.2a24	e6 2f		inc $2f				inc 	zTemp1+1 					; bump count
.2a26	80 d9		bra $2a01			bra 	_INDLoop
.2a28					_INDDone:
.2a28	a5 2f		lda $2f				lda 	zTemp1+1 					; done at least 1 ?
.2a2a	f0 08		beq $2a34			beq 	_INDError
.2a2c	a4 2d		ldy $2d				ldy 	zTemp0+1 					; push constant
.2a2e	a5 2c		lda $2c				lda 	zTemp0
.2a30	20 59 2b	jsr $2b59			jsr 	PushIntegerYA
.2a33	60		rts				rts
.2a34					_INDError:
.2a34	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.2a37					_INDShift:
.2a37	06 2c		asl $2c				asl 	zTemp0
.2a39	26 2d		rol $2d				rol 	zTemp0+1
.2a3b	60		rts				rts
.2a3c					GetLineNumber:
.2a3c	ac bb 05	ldy $05bb			ldy 	currentLineNumber+1
.2a3f	ad ba 05	lda $05ba			lda 	currentLineNumber
.2a42	60		rts				rts
.2a43					WriteCodeByte:
.2a43	48		pha				pha 								; save on stack
.2a44	da		phx				phx
.2a45	5a		phy				phy
.2a46	aa		tax				tax
.2a47	a9 05		lda #$05			lda 	#BLC_WRITEOUT
.2a49	20 56 2b	jsr $2b56			jsr 	CallAPIHandler
.2a4c	7a		ply				ply 								; restore from stack
.2a4d	fa		plx				plx
.2a4e	68		pla				pla
.2a4f	60		rts				rts
.2a50					PrintCharacter
.2a50	48		pha				pha
.2a51	da		phx				phx
.2a52	5a		phy				phy
.2a53	aa		tax				tax
.2a54	a9 06		lda #$06			lda 	#BLC_PRINTCHAR
.2a56	20 56 2b	jsr $2b56			jsr 	CallAPIHandler
.2a59	7a		ply				ply
.2a5a	fa		plx				plx
.2a5b	68		pla				pla
.2a5c	60		rts				rts
.2a5d					ProcessNewLine:
.2a5d	86 2c		stx $2c				stx 	zTemp0 						; save address in zTemp0
.2a5f	84 2d		sty $2d				sty 	zTemp0+1
.2a61	18		clc				clc 								; set the srcPtr to the start of the actual code (e.g. offset 4)
.2a62	8a		txa				txa
.2a63	69 04		adc #$04			adc 	#4
.2a65	85 7a		sta $7a				sta 	srcPtr
.2a67	98		tya				tya
.2a68	69 00		adc #$00			adc 	#0
.2a6a	85 7b		sta $7b				sta 	srcPtr+1
.2a6c	a0 02		ldy #$02			ldy 	#2							; read and save line number
.2a6e	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a70	8d ba 05	sta $05ba			sta 	currentLineNumber
.2a73	c8		iny				iny
.2a74	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2a76	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2a79	60		rts				rts
.2a7a					BufferClear:
.2a7a	9c bc 05	stz $05bc			stz 	bufferSize
.2a7d	60		rts				rts
.2a7e					BufferWrite:
.2a7e	da		phx				phx
.2a7f	ae bc 05	ldx $05bc			ldx 	bufferSize
.2a82	9d bd 05	sta $05bd,x			sta 	dataBuffer,x
.2a85	ee bc 05	inc $05bc			inc 	bufferSize
.2a88	fa		plx				plx
.2a89	60		rts				rts
.2a8a					BufferOutput:
.2a8a	ad bc 05	lda $05bc			lda 	bufferSize
.2a8d	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2a90	a2 00		ldx #$00			ldx 	#0
.2a92					_BOLoop:
.2a92	ec bc 05	cpx $05bc			cpx 	bufferSize
.2a95	f0 09		beq $2aa0			beq 	_BOExit
.2a97	bd bd 05	lda $05bd,x			lda 	dataBuffer,x
.2a9a	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2a9d	e8		inx				inx
.2a9e	80 f2		bra $2a92			bra 	_BOLoop
.2aa0					_BOExit:
.2aa0	60		rts				rts
.05bc					bufferSize:
>05bc							.fill 	1
.05bd					dataBuffer:
>05bd							.fill 	256
.2aa1					CheckNextComma:
.2aa1	a9 2c		lda #$2c			lda	 	#","
.2aa3	80 06		bra $2aab			bra 	CheckNextA
.2aa5					CheckNextRParen:
.2aa5	a9 29		lda #$29			lda	 	#")"
.2aa7	80 02		bra $2aab			bra 	CheckNextA
.2aa9					CheckNextLParen:
.2aa9	a9 28		lda #$28			lda 	#"("
.2aab					CheckNextA:
.2aab	8d bd 06	sta $06bd			sta 	checkCharacter 				; save test character
.2aae					_CNALoop:
.2aae	20 c7 33	jsr $33c7			jsr 	GetNextNonSpace 			; get next skipping spaces.
.2ab1	cd bd 06	cmp $06bd			cmp 	checkCharacter 				; matches ?
.2ab4	f0 03		beq $2ab9			beq 	_CNAExit
.2ab6	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.2ab9					_CNAExit:
.2ab9	60		rts				rts
.06bd					checkCharacter:
>06bd							.fill 	1
.2aba					StartCompiler:
.2aba	86 2c		stx $2c				stx 	zTemp0 						; access API
.2abc	84 2d		sty $2d				sty 	zTemp0+1
.2abe	a0 2d		ldy #$2d			ldy 	#CompilerErrorHandler >> 8 	; set error handler to compiler one.
.2ac0	a2 12		ldx #$12			ldx 	#CompilerErrorHandler & $FF
.2ac2	20 f5 1e	jsr $1ef5			jsr 	SetErrorHandler
.2ac5	a0 01		ldy #$01			ldy 	#1 							; copy API vector
.2ac7	b2 2c		lda ($2c)			lda 	(zTemp0)
.2ac9	8d bf 06	sta $06bf			sta 	APIVector
.2acc	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ace	8d c0 06	sta $06c0			sta 	APIVector+1
.2ad1	c8		iny				iny 								; copy data area range.
.2ad2	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ad4	8d c1 06	sta $06c1			sta 	compilerStartHigh
.2ad7	c8		iny				iny
.2ad8	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2ada	8d c2 06	sta $06c2			sta 	compilerEndHigh
.2add	ba		tsx				tsx 								; save stack pointer
.2ade	8e be 06	stx $06be			stx 	compilerSP
.2ae1	20 4b 37	jsr $374b			jsr 	STRReset 					; reset storage (line#, variable)
.2ae4	a9 00		lda #$00			lda 	#BLC_OPENIN					; reset data input
.2ae6	20 56 2b	jsr $2b56			jsr 	CallAPIHandler
.2ae9	a9 03		lda #$03			lda 	#BLC_RESETOUT 				; reset data output.
.2aeb	20 56 2b	jsr $2b56			jsr 	CallAPIHandler
.2aee	a9 d5		lda #$d5			lda 	#PCD_CMD_VARSPACE
.2af0	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2af3	a9 00		lda #$00			lda 	#0
.2af5	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2af8	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2afb					MainCompileLoop:
.2afb	a9 02		lda #$02			lda 	#BLC_READIN 				; read next line into the buffer.
.2afd	20 56 2b	jsr $2b56			jsr 	CallAPIHandler
.2b00	90 31		bcc $2b33			bcc 	SaveCodeAndExit 			; end of source.
.2b02	20 5d 2a	jsr $2a5d			jsr 	ProcessNewLine 				; set up pointer and line number.
.2b05	20 3c 2a	jsr $2a3c			jsr 	GetLineNumber 				; get line #
.2b08	20 35 35	jsr $3535			jsr 	STRMarkLine 				; remember the code position and number of this line.
.2b0b	a9 a6		lda #$a6			lda 	#PCD_NEWCMD_LINE 			; generate new command line
.2b0d	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2b10					_MCLSameLine:
.2b10	20 c7 33	jsr $33c7			jsr 	GetNextNonSpace 			; get the first character.
.2b13	f0 e6		beq $2afb			beq 	MainCompileLoop 			; end of line, get next line.
.2b15	c9 3a		cmp #$3a			cmp 	#":"						; if : then loop back.
.2b17	f0 f7		beq $2b10			beq 	_MCLSameLine
.2b19	c9 00		cmp #$00			cmp 	#0 							; if ASCII then check for implied LET.
.2b1b	10 0c		bpl $2b29			bpl 	_MCLCheckAssignment
.2b1d	a2 7f		ldx #$7f			ldx 	#CommandTables & $FF 		; do command tables.
.2b1f	a0 2f		ldy #$2f			ldy 	#CommandTables >> 8
.2b21	20 4d 32	jsr $324d			jsr 	GeneratorProcess
.2b24	b0 ea		bcs $2b10			bcs 	_MCLSameLine 				; keep trying to compile the line.
.2b26					_MCLSyntax:
.2b26	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.2b29					_MCLCheckAssignment:
.2b29	20 dd 33	jsr $33dd			jsr 	CharIsAlpha 				; if not alpha then syntax error
.2b2c	90 f8		bcc $2b26			bcc 	_MCLSyntax
.2b2e	20 03 35	jsr $3503			jsr 	CommandLETHaveFirst  		; LET first character, do assign
.2b31	80 dd		bra $2b10			bra		_MCLSameLine 				; loop back.
.2b33					SaveCodeAndExit:
.2b33	a9 01		lda #$01			lda 	#BLC_CLOSEIN				; finish input.
.2b35	20 56 2b	jsr $2b56			jsr 	CallAPIHandler
.2b38	a9 ff		lda #$ff			lda 	#$FF 						; fake line number $FFFF for forward THEN.
.2b3a	a8		tay				tay
.2b3b	20 35 35	jsr $3535			jsr 	STRMarkLine
.2b3e	a9 c5		lda #$c5			lda 	#PCD_EXIT 					; add an END
.2b40	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2b43	a9 ff		lda #$ff			lda 	#$FF 						; add end marker
.2b45	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2b48	20 6f 2e	jsr $2e6f			jsr 	FixBranches 				; fix up GOTO/GOSUB etc.
.2b4b	a9 04		lda #$04			lda 	#BLC_CLOSEOUT 				; close output store
.2b4d	20 56 2b	jsr $2b56			jsr 	CallAPIHandler
.2b50	18		clc				clc 								; CC = success
.2b51					ExitCompiler:
.2b51	ae be 06	ldx $06be			ldx 	compilerSP 					; reload SP and exit.
.2b54	9a		txs				txs
.2b55	60		rts				rts
.2b56					CallAPIHandler:
.2b56	6c bf 06	jmp ($06bf)			jmp 	(APIVector)
.06be					compilerSP:
>06be							.fill 	1
.06bf					APIVector:
>06bf							.fill 	2
.06c1					compilerStartHigh:
>06c1							.fill 	1
.06c2					compilerEndHigh:
>06c2							.fill 	1
.2b59					PushIntegerYA:
.2b59	c0 00		cpy #$00			cpy 	#0 							; 0-255
.2b5b	f0 0f		beq $2b6c			beq 	PushIntegerA
.2b5d	48		pha				pha
.2b5e	a9 cd		lda #$cd			lda 	#PCD_CMD_WORD 				; send .word
.2b60	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2b63	68		pla				pla 								; then LSB
.2b64	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2b67	98		tya				tya 								; then MSB
.2b68	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2b6b	60		rts				rts
.2b6c					PushIntegerA:
.2b6c	c9 40		cmp #$40			cmp 	#64 						; if > 64 send byte as is
.2b6e	90 07		bcc $2b77			bcc 	_PIWriteA
.2b70	48		pha				pha
.2b71	a9 cc		lda #$cc			lda 	#PCD_CMD_BYTE 				; send .byte
.2b73	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2b76	68		pla				pla
.2b77					_PIWriteA:
.2b77	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2b7a	60		rts				rts
.2b7b					PushFloatCommand:
.2b7b	a9 ce		lda #$ce			lda 	#PCD_CMD_FLOAT 				; write CMD_FLOAT
.2b7d	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2b80	b5 6e		lda $6e,x			lda 	NSExponent,x 				; and the data
.2b82	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2b85	b5 3e		lda $3e,x			lda 	NSMantissa0,x
.2b87	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2b8a	b5 4a		lda $4a,x			lda 	NSMantissa1,x
.2b8c	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2b8f	b5 56		lda $56,x			lda 	NSMantissa2,x
.2b91	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2b94	b5 32		lda $32,x			lda 	NSStatus,x 					; with sign packed in byte 3 MSB
.2b96	29 80		and #$80			and 	#$80
.2b98	15 62		ora $62,x			ora 	NSMantissa3,x
.2b9a	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2b9d	60		rts				rts
.2b9e					CreateVariableRecord:
.2b9e	48		pha				pha
.2b9f	ad cd 06	lda $06cd			lda 	freeVariableMemory 		; push current free address on stack.
.2ba2	48		pha				pha
.2ba3	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2ba6	48		pha				pha
.2ba7	ad cb 06	lda $06cb			lda 	variableListEnd  		; copy end of list to zTemp0
.2baa	85 2c		sta $2c				sta 	zTemp0
.2bac	ad cc 06	lda $06cc			lda 	variableListEnd+1
.2baf	85 2d		sta $2d				sta 	zTemp0+1
.2bb1	a9 06		lda #$06			lda 	#6 						; default size if 6 (offset link 3 bytes)
.2bb3	92 2c		sta ($2c)			sta 	(zTemp0)
.2bb5	98		tya				tya
.2bb6	a0 02		ldy #$02			ldy 	#2 						; write out the name.
.2bb8	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bba	88		dey				dey
.2bbb	8a		txa				txa
.2bbc	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bbe	a0 03		ldy #$03			ldy 	#3 						; write out the address.
.2bc0	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2bc3	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bc5	c8		iny				iny
.2bc6	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2bc9	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bcb	a0 06		ldy #$06			ldy 	#6 						; write EOL marker next record.
.2bcd	a9 00		lda #$00			lda 	#0
.2bcf	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bd1	18		clc				clc
.2bd2	b2 2c		lda ($2c)			lda 	(zTemp0) 				; add offset to variableListEnd
.2bd4	6d cb 06	adc $06cb			adc  	variableListEnd
.2bd7	8d cb 06	sta $06cb			sta 	variableListEnd
.2bda	90 03		bcc $2bdf			bcc 	_CVNoCarry2
.2bdc	ee cc 06	inc $06cc			inc 	variableListEnd+1
.2bdf					_CVNoCarry2:
.2bdf	7a		ply				ply
.2be0	fa		plx				plx
.2be1	68		pla				pla
.2be2	60		rts				rts
.2be3					SetVariableRecordToCodePosition:
.2be3	48		pha				pha
.2be4	5a		phy				phy
.2be5	a0 03		ldy #$03			ldy 	#3
.2be7	a5 2b		lda $2b				lda 	objPtr+1
.2be9	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2beb	c8		iny				iny
.2bec	a5 2a		lda $2a				lda 	objPtr
.2bee	91 2c		sta ($2c),y			sta 	(zTemp0),y
.2bf0	7a		ply				ply
.2bf1	68		pla				pla
.2bf2	60		rts				rts
.2bf3					AllocateBytesForType:
.2bf3	48		pha				pha
.2bf4	da		phx				phx
.2bf5	a2 02		ldx #$02			ldx 	#2 						; bytes to allocate
.2bf7	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.2bf9	c9 00		cmp #$00			cmp 	#NSSIFloat
.2bfb	d0 02		bne $2bff			bne 	_CVNotFloat
.2bfd	a2 06		ldx #$06			ldx 	#6
.2bff					_CVNotFloat:
.2bff	8a		txa				txa 							; add 6 or 2 to the free memory pointer.
.2c00	18		clc				clc
.2c01	6d cd 06	adc $06cd			adc 	freeVariableMemory
.2c04	8d cd 06	sta $06cd			sta 	freeVariableMemory
.2c07	90 03		bcc $2c0c			bcc 	_CVNoCarry1
.2c09	ee ce 06	inc $06ce			inc 	freeVariableMemory+1
.2c0c					_CVNoCarry1:
.2c0c	fa		plx				plx
.2c0d	68		pla				pla
.2c0e	60		rts				rts
.2c0f					CommandDATA:
.2c0f	20 7a 2a	jsr $2a7a			jsr 	BufferClear 				; copy it to the buffer
.2c12	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace
.2c15					_CTDataLoop:
.2c15	20 ab 33	jsr $33ab			jsr 	LookNext 					; reached EOL
.2c18	f0 08		beq $2c22			beq 	_CTDataDone
.2c1a	20 7e 2a	jsr $2a7e			jsr 	BufferWrite 				; write and consume
.2c1d	20 bc 33	jsr $33bc			jsr 	GetNext
.2c20	80 f3		bra $2c15			bra 	_CTDataLoop
.2c22					_CTDataDone:
.2c22	a9 d0		lda #$d0			lda 	#PCD_CMD_DATA 				; output command and buffer
.2c24	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2c27	20 8a 2a	jsr $2a8a			jsr 	BufferOutput
.2c2a	60		rts				rts
.2c2b					CommandDEF:
.2c2b	a9 00		lda #$00			lda 	#0 							; constant 0 (for GOTOZ)
.2c2d	20 6c 2b	jsr $2b6c			jsr 	PushIntegerA
.2c30	20 cc 34	jsr $34cc			jsr 	CompileGotoEOL 				; compile skip over DEF
.2c33	a9 a5		lda #$a5			lda 	#C64_FN
.2c35	20 ab 2a	jsr $2aab			jsr 	CheckNextA
.2c38	20 c7 33	jsr $33c7			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2c3b	20 2c 34	jsr $342c			jsr 	ExtractVariableName
.2c3e	8a		txa				txa
.2c3f	10 51		bpl $2c92			bpl 	_CDError
.2c41	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2c42	29 7f		and #$7f			and 	#$7F
.2c44	aa		tax				tax
.2c45	98		tya				tya
.2c46	09 80		ora #$80			ora 	#$80
.2c48	a8		tay				tay
.2c49	20 13 2e	jsr $2e13			jsr 	FindVariable				; does it already exist ?
.2c4c	b0 44		bcs $2c92			bcs 	_CDError 					; if so, that's an error.
.2c4e	20 9e 2b	jsr $2b9e			jsr 	CreateVariableRecord 		; create the record for it & put the data in it.
.2c51	20 e3 2b	jsr $2be3			jsr 	SetVariableRecordToCodePosition
.2c54	20 c7 33	jsr $33c7			jsr 	GetNextNonSpace
.2c57	20 08 37	jsr $3708			jsr 	GetReferenceTerm 			; get var ref, not array
.2c5a	c9 00		cmp #$00			cmp 	#0
.2c5c	30 34		bmi $2c92			bmi 	_CDError
.2c5e	8d c3 06	sta $06c3			sta 	defType 					; save type
.2c61	8e c4 06	stx $06c4			stx 	defVariable 				; save var ref
.2c64	8c c5 06	sty $06c5			sty 	defVariable+1
.2c67	29 40		and #$40			and 	#NSSString 					; only numbers.
.2c69	d0 27		bne $2c92			bne 	_CDError
.2c6b	20 a5 2a	jsr $2aa5			jsr 	CheckNextRParen 			; check )
.2c6e	a9 b2		lda #$b2			lda 	#C64_EQUAL
.2c70	20 ab 2a	jsr $2aab			jsr 	CheckNextA 					; check =
.2c73	18		clc				clc 								; if this is DEF FNxx(A), read A
.2c74	20 95 2c	jsr $2c95			jsr 	CDReadWriteVariable
.2c77	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.2c79	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2c7c	38		sec				sec
.2c7d	20 95 2c	jsr $2c95			jsr 	CDReadWriteVariable 		; A is now updated
.2c80	20 59 2d	jsr $2d59			jsr 	CompileExpressionAt0 		; the actual body of the function.
.2c83	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.2c85	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2c88	38		sec				sec
.2c89	20 95 2c	jsr $2c95			jsr 	CDReadWriteVariable 		; A is now reset to its old value
.2c8c	a9 98		lda #$98			lda 	#(PCD_RETURN) & $FF
.2c8e	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2c91	60		rts				rts
.2c92					_CDError:
.2c92	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.2c95					CDReadWriteVariable:
.2c95	ac c5 06	ldy $06c5			ldy 	defVariable+1 				; set up YX
.2c98	ae c4 06	ldx $06c4			ldx 	defVariable
.2c9b	ad c3 06	lda $06c3			lda 	defType
.2c9e	20 ba 36	jsr $36ba			jsr 	GetSetVariable
.2ca1	60		rts				rts
.06c3					defType:
>06c3							.fill 	1
.06c4					defVariable:
>06c4							.fill 	2
.2ca2					CommandDIM:
.2ca2	20 c7 33	jsr $33c7			jsr 	GetNextNonSpace 			; get the first non space character
.2ca5	20 2c 34	jsr $342c			jsr 	ExtractVariableName 		; variable name to XY
.2ca8	da		phx				phx 								; save name with type bits.
.2ca9	e0 00		cpx #$00			cpx 	#0 							; check it is an array.
.2cab	10 37		bpl $2ce4			bpl 	_CDError
.2cad	20 13 2e	jsr $2e13			jsr 	FindVariable	 			; see if already exist
.2cb0	b0 35		bcs $2ce7			bcs 	_CDRedefine 				; it still exists.
.2cb2	20 9e 2b	jsr $2b9e			jsr 	CreateVariableRecord 		; create the basic variable
.2cb5	20 f3 2b	jsr $2bf3			jsr 	AllocateBytesForType 		; allocate memory for it
.2cb8	68		pla				pla 								; restore type bits
.2cb9	5a		phy				phy 								; save the address of the basic storage
.2cba	da		phx				phx
.2cbb	48		pha				pha
.2cbc	20 ea 2c	jsr $2cea			jsr 	OutputIndexGroup 			; create an index group and generate them, preserving type data
.2cbf	68		pla				pla
.2cc0	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; 2 bit type data
.2cc2	20 6c 2b	jsr $2b6c			jsr 	PushIntegerA 				; push that type data out.
.2cc5	a9 cb		lda #$cb			lda 	#(PCD_DIM) >> 8
.2cc7	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2cca	a9 81		lda #$81			lda 	#(PCD_DIM) & $FF
.2ccc	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2ccf	fa		plx				plx 								; restore address
.2cd0	7a		ply				ply
.2cd1	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.2cd3	38		sec				sec
.2cd4	20 ba 36	jsr $36ba			jsr 	GetSetVariable 				; store the address in the reference to the array structure.
.2cd7	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; , follows ?
.2cda	c9 2c		cmp #$2c			cmp 	#","
.2cdc	d0 05		bne $2ce3			bne 	_CDExit
.2cde	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume comma
.2ce1	80 bf		bra $2ca2			bra 	CommandDIM 					; do another DIM
.2ce3					_CDExit:
.2ce3	60		rts				rts
.2ce4					_CDError:
.2ce4	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.2ce7					_CDRedefine:
.2ce7	4c e4 1f	jmp $1fe4		jmp	ErrorV_redefine
.2cea					OutputIndexGroup:
.2cea	9c c6 06	stz $06c6			stz 	IndexCount 					; count of number of indices.
.2ced					_OIGNext:
.2ced	20 59 2d	jsr $2d59			jsr 	CompileExpressionAt0 		; get a dimension
.2cf0	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2cf2	c9 00		cmp #$00			cmp 	#NSSIFloat
.2cf4	d0 19		bne $2d0f			bne 	_OIGType
.2cf6	ee c6 06	inc $06c6			inc 	IndexCount 					; bump the counter.
.2cf9	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; does a , follow ?
.2cfc	c9 2c		cmp #$2c			cmp 	#","
.2cfe	d0 05		bne $2d05			bne 	_OIGCheckEnd
.2d00	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume comma
.2d03	80 e8		bra $2ced			bra 	_OIGNext 					; get next dimension
.2d05					_OIGCheckEnd:
.2d05	20 a5 2a	jsr $2aa5			jsr 	CheckNextRParen 			; check and consume )
.2d08	ad c6 06	lda $06c6			lda 	IndexCount
.2d0b	20 6c 2b	jsr $2b6c			jsr 	PushIntegerA 				; compile the dimension count.
.2d0e	60		rts				rts
.2d0f					_OIGType:
.2d0f	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.06c6					IndexCount:
>06c6							.fill 	1
.2d12					CompilerErrorHandler:
.2d12	68		pla				pla
.2d13	7a		ply				ply
.2d14	85 2c		sta $2c				sta 	zTemp0
.2d16	84 2d		sty $2d				sty 	zTemp0+1
.2d18	a2 00		ldx #$00			ldx 	#0 							; output msg to channel #0
.2d1a	a0 01		ldy #$01			ldy 	#1
.2d1c					_EHDisplayMsg:
.2d1c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d1e	20 50 2a	jsr $2a50			jsr 	PrintCharacter
.2d21	c8		iny				iny
.2d22	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2d24	d0 f6		bne $2d1c			bne 	_EHDisplayMsg
.2d26	a9 20		lda #$20			lda 	#32
.2d28	20 50 2a	jsr $2a50			jsr 	PrintCharacter
.2d2b	a9 40		lda #$40			lda 	#64
.2d2d	20 50 2a	jsr $2a50			jsr 	PrintCharacter
.2d30	a2 00		ldx #$00			ldx 	#0 							; convert line# to string
.2d32	20 76 26	jsr $2676			jsr 	FloatSetByte
.2d35	20 3c 2a	jsr $2a3c			jsr 	GetLineNumber
.2d38	95 3e		sta $3e,x			sta 	NSMantissa0,x
.2d3a	98		tya				tya
.2d3b	95 4a		sta $4a,x			sta 	NSMantissa1,x
.2d3d	20 5c 25	jsr $255c			jsr 	FloatToString
.2d40	a0 00		ldy #$00			ldy 	#0 							; display that string.
.2d42	a2 00		ldx #$00			ldx 	#0
.2d44					_EHDisplayLine:
.2d44	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d47	20 50 2a	jsr $2a50			jsr 	PrintCharacter
.2d4a	c8		iny				iny
.2d4b	b9 98 05	lda $0598,y			lda 	decimalBuffer,y
.2d4e	d0 f4		bne $2d44			bne 	_EHDisplayLine
.2d50	a9 0d		lda #$0d			lda 	#13
.2d52	20 50 2a	jsr $2a50			jsr 	PrintCharacter
.2d55	38		sec				sec 								; CS = error
.2d56	4c 51 2b	jmp $2b51			jmp 	ExitCompiler
.2d59					CompileExpressionAt0:
.2d59	a9 00		lda #$00			lda 	#0
.2d5b					CompileExpressionAtA:
.2d5b	48		pha				pha  								; save level
.2d5c	20 92 37	jsr $3792			jsr 	CompileTerm 				; compile a term.
.2d5f	fa		plx				plx 								; get level back into X
.2d60					_ECALoop:
.2d60	48		pha				pha 								; save type on stack.
.2d61	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; get the next character
.2d64	c9 aa		cmp #$aa			cmp 	#C64_PLUS 					; go to be + ... < in the C64 code.
.2d66	90 04		bcc $2d6c			bcc 	_ECAExit
.2d68	c9 b4		cmp #$b4			cmp 	#C64_LESS+1
.2d6a	90 02		bcc $2d6e			bcc 	_ECAHaveToken
.2d6c					_ECAExit:
.2d6c	68		pla				pla 								; throw type off stack
.2d6d	60		rts				rts
.2d6e					_ECAHaveToken:
.2d6e	86 2c		stx $2c				stx 	zTemp0 						; save current precedence in zTemp0
.2d70	aa		tax				tax 								; X contains the operator token
.2d71	bd 5c 2d	lda $2d5c,x			lda 	PrecedenceTable-C64_PLUS,x  ; read precedence.
.2d74	c5 2c		cmp $2c				cmp 	zTemp0 						; if < then exit
.2d76	90 f4		bcc $2d6c			bcc 	_ECAExit
.2d78	85 2d		sta $2d				sta 	zTemp0+1 					; save the precedence of the operator.
.2d7a	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume the token.
.2d7d	e0 b1		cpx #$b1			cpx 	#C64_GREATER				; checks for < or > which could be two character tokens
.2d7f	f0 11		beq $2d92			beq 	_ECAGreaterCheck
.2d81	e0 b3		cpx #$b3			cpx 	#C64_LESS
.2d83	d0 1a		bne $2d9f			bne 	_ECAHaveFullToken
.2d85	20 ab 33	jsr $33ab			jsr 	LookNext 					; checks for < (<= or <>)
.2d88	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; <> is 2 on from <
.2d8a	f0 0e		beq $2d9a			beq	 	_ECAToNotEqual
.2d8c	c9 b2		cmp #$b2			cmp 	#C64_EQUAL 					; <= is 3 on from <
.2d8e	d0 0f		bne $2d9f			bne 	_ECAHaveFullToken
.2d90	80 07		bra $2d99			bra 	_ECAAddEqual
.2d92					_ECAGreaterCheck:
.2d92	20 ab 33	jsr $33ab			jsr 	LookNext
.2d95	c9 b2		cmp #$b2			cmp 	#C64_EQUAL
.2d97	d0 06		bne $2d9f			bne 	_ECAHaveFullToken
.2d99					_ECAAddEqual:
.2d99	e8		inx				inx 								; > => >= and < to <= is three tokens on.
.2d9a					_ECAToNotEqual:
.2d9a	e8		inx				inx
.2d9b	e8		inx				inx
.2d9c	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume the = or > in >= <= <>
.2d9f					_ECAHaveFullToken:
.2d9f	e0 aa		cpx #$aa			cpx 	#C64_PLUS
.2da1	d0 0a		bne $2dad			bne 	_ECANotConcat
.2da3	68		pla				pla 								; get type back
.2da4	48		pha				pha
.2da5	29 40		and #$40			and 	#NSSTypeMask
.2da7	c9 40		cmp #$40			cmp 	#NSSString
.2da9	d0 02		bne $2dad			bne 	_ECANotConcat
.2dab	a2 e0		ldx #$e0			ldx 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2dad					_ECANotConcat:
.2dad	da		phx				phx 								; save operator on the stack
.2dae	a6 2c		ldx $2c				ldx 	zTemp0 						; push current precedence on the stack
.2db0	da		phx				phx
.2db1	a5 2d		lda $2d				lda 	zTemp0+1 					; get precedence of operator
.2db3	1a		inc a				inc 	a
.2db4	20 5b 2d	jsr $2d5b			jsr 	CompileExpressionAtA 		; and compile at the next level up.
.2db7	85 2c		sta $2c				sta 	zTemp0 						; save type in zTemp0
.2db9	fa		plx				plx 								; restore current precedence in X
.2dba	68		pla				pla 								; restore operator
.2dbb	85 2d		sta $2d				sta 	zTemp0+1 					; save it in zTemp0+1.
.2dbd	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; check for not compare
.2dbf	90 17		bcc $2dd8			bcc 	_ECANotCompare
.2dc1	c9 b7		cmp #$b7			cmp 	#C64_GREATER+6
.2dc3	b0 13		bcs $2dd8			bcs 	_ECANotCompare
.2dc5	7a		ply				ply 								; get type into Y
.2dc6	5a		phy				phy
.2dc7	48		pha				pha 								; save operator
.2dc8	98		tya				tya 								; get type
.2dc9	a0 94		ldy #$94			ldy 	#PCD_SCMD_CMP 				; Y is the token to use
.2dcb	29 40		and #$40			and 	#NSSTypeMask
.2dcd	c9 40		cmp #$40			cmp 	#NSSString
.2dcf	f0 02		beq $2dd3			beq 	_ECANotString
.2dd1	a0 a3		ldy #$a3			ldy 	#PCD_FCMD_CMP
.2dd3					_ECANotString:
.2dd3	98		tya				tya									; output token Y
.2dd4	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2dd7	68		pla				pla 								; restore operator.
.2dd8					_ECANotCompare:
.2dd8	18		clc				clc 								; convert to P-Code and compile.
.2dd9	69 d6		adc #$d6			adc 	#(PCD_PLUS-C64_PLUS) & $FF 	; it might be invalid at this point
.2ddb	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2dde	68		pla				pla 								; type of current result
.2ddf	45 2c		eor $2c				eor 	zTemp0 						; check compatible with r-expr type
.2de1	29 40		and #$40			and 	#NSSTypeMask 				; the types should be compatible, only interested in number vs float
.2de3	d0 19		bne $2dfe			bne		_ECAType
.2de5	a5 2c		lda $2c				lda 	zTemp0 						; get type back
.2de7	c9 40		cmp #$40			cmp 	#NSSString 					; if it is a number, then all operators work.
.2de9	d0 18		bne $2e03			bne 	_ECAGoLoop
.2deb	a5 2d		lda $2d				lda 	zTemp0+1 					; check operator is + or comparator
.2ded	c9 e0		cmp #$e0			cmp 	#(PCD_CONCAT-(PCD_PLUS-C64_PLUS)) & $FF
.2def	f0 10		beq $2e01			beq 	_ECAOkayString 				; (this is post conversion)
.2df1	c9 b1		cmp #$b1			cmp 	#C64_GREATER 				; must be a comparison then.
.2df3	90 09		bcc $2dfe			bcc 	_ECAType
.2df5	c9 b7		cmp #$b7			cmp 	#C64_LESS+1+3 				; the +3 is because of >= <= <>
.2df7	b0 05		bcs $2dfe			bcs 	_ECAType
.2df9	a9 00		lda #$00			lda 	#NSSIFloat 					; compare returns number.
.2dfb	4c 60 2d	jmp $2d60			jmp 	_ECALoop
.2dfe					_ECAType:
.2dfe	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.2e01					_ECAOkayString:
.2e01	a9 40		lda #$40			lda 	#NSSString 					; current is string, go round again.
.2e03					_ECAGoLoop:
.2e03	4c 60 2d	jmp $2d60			jmp 	_ECALoop
.2e06					PrecedenceTable:
>2e06	03						.byte 	3 					; '+'
>2e07	03						.byte 	3 					; '-'
>2e08	04						.byte 	4 					; '*'
>2e09	04						.byte 	4 					; '/'
>2e0a	05						.byte 	5 					; '^'
>2e0b	01						.byte 	1 					; 'and'
>2e0c	00						.byte 	0 					; 'or'
>2e0d	02						.byte 	2 					; '>'
>2e0e	02						.byte 	2 					; '='
>2e0f	02						.byte 	2 					; '<'
>2e10	02						.byte 	2 					; '>='
>2e11	02						.byte 	2 					; '<='
>2e12	02						.byte 	2 					; '<>'
.2e13					FindVariable:
.2e13	86 2e		stx $2e				stx 	zTemp1 						; save name.
.2e15	84 2f		sty $2f				sty 	zTemp1+1
.2e17					_IVCheckSpecial:
.2e17	c0 09		cpy #$09			cpy 	#$09	 					; both end $09 e.g. I
.2e19	d0 18		bne $2e33			bne 	_IVStandard
.2e1b	e0 14		cpx #$14			cpx 	#$14 						; TI is $14
.2e1d	f0 0c		beq $2e2b			beq 	_IVTIFloat
.2e1f	e0 54		cpx #$54			cpx 	#$54 						; TI$ is $54
.2e21	d0 10		bne $2e33			bne 	_IVStandard
.2e23	a0 c0		ldy #$c0			ldy 	#$C0 						; TI$ returns string $C001
.2e25	a2 01		ldx #$01			ldx 	#$01
.2e27	a9 40		lda #$40			lda 	#NSSString
.2e29	38		sec				sec
.2e2a	60		rts				rts
.2e2b					_IVTIFloat:
.2e2b	a0 80		ldy #$80			ldy 	#$80
.2e2d	a2 00		ldx #$00			ldx 	#$00
.2e2f	a9 00		lda #$00			lda 	#0
.2e31	38		sec				sec
.2e32	60		rts				rts
.2e33					_IVStandard:
.2e33	ad c1 06	lda $06c1			lda 	compilerStartHigh			; start scanning from here.
.2e36	85 2d		sta $2d				sta 	zTemp0+1
.2e38	64 2c		stz $2c				stz 	zTemp0
.2e3a					_IVCheckLoop:
.2e3a	b2 2c		lda ($2c)			lda 	(zTemp0) 					; finished ?
.2e3c	f0 2b		beq $2e69			beq  	_IVNotFound 				; if so, return with CC.
.2e3e	a0 01		ldy #$01			ldy 	#1 							; match ?
.2e40	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e42	c5 2e		cmp $2e				cmp 	zTemp1
.2e44	d0 07		bne $2e4d			bne	 	_IVNext
.2e46	c8		iny				iny
.2e47	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e49	c5 2f		cmp $2f				cmp 	zTemp1+1
.2e4b	f0 0d		beq $2e5a			beq 	_IVFound
.2e4d					_IVNext:
.2e4d	18		clc				clc
.2e4e	a5 2c		lda $2c				lda 	zTemp0
.2e50	72 2c		adc ($2c)			adc 	(zTemp0)
.2e52	85 2c		sta $2c				sta 	zTemp0
.2e54	90 e4		bcc $2e3a			bcc 	_IVCheckLoop
.2e56	e6 2d		inc $2d				inc 	zTemp0+1
.2e58	80 e0		bra $2e3a			bra 	_IVCheckLoop
.2e5a					_IVFound:
.2e5a	a0 03		ldy #$03			ldy 	#3 							; get address into YX
.2e5c	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e5e	aa		tax				tax
.2e5f	c8		iny				iny
.2e60	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e62	48		pha				pha
.2e63	c8		iny				iny
.2e64	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.2e66	7a		ply				ply
.2e67	38		sec				sec
.2e68	60		rts				rts
.2e69					_IVNotFound:
.2e69	a6 2e		ldx $2e				ldx 	zTemp1 						; get variable name back
.2e6b	a4 2f		ldy $2f				ldy 	zTemp1+1
.2e6d	18		clc				clc
.2e6e	60		rts				rts
.2e6f					FixBranches:
.2e6f	a9 03		lda #$03			lda 	#BLC_RESETOUT				; back to the start of the *object* code.
.2e71	20 56 2b	jsr $2b56			jsr 	CallAPIHandler
.2e74					_FBLoop:
.2e74	b2 2a		lda ($2a)			lda 	(objPtr) 					; get the next one.
.2e76	c9 d1		cmp #$d1			cmp 	#PCD_CMD_GOTO 				; found GOTO or GOSUB, patch up.
.2e78	f0 1a		beq $2e94			beq 	_FBFixGotoGosub
.2e7a	c9 d2		cmp #$d2			cmp 	#PCD_CMD_GOSUB
.2e7c	f0 16		beq $2e94			beq 	_FBFixGotoGosub
.2e7e	c9 d4		cmp #$d4			cmp 	#PCD_CMD_GOTOCMD_NZ 		; patch the conditional GOTOs for Z/NZ TOS.
.2e80	f0 12		beq $2e94			beq 	_FBFixGotoGosub
.2e82	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_Z
.2e84	f0 0e		beq $2e94			beq 	_FBFixGotoGosub
.2e86	c9 d5		cmp #$d5			cmp 	#PCD_CMD_VARSPACE
.2e88	f0 43		beq $2ecd			beq 	_FBFixVarSpace
.2e8a	c9 d6		cmp #$d6			cmp 	#PCD_CMD_RESTORE 			; patch restore.
.2e8c	f0 06		beq $2e94			beq 	_FBFixRestore
.2e8e					_FBNext:
.2e8e	20 42 20	jsr $2042			jsr 	MoveObjectForward 			; move forward in object code.
.2e91	90 e1		bcc $2e74			bcc 	_FBLoop 					; not finished
.2e93					_FBExit:
.2e93	60		rts				rts
.2e94					_FBFixGotoGosub:
.2e94					_FBFixRestore:
.2e94	a0 01		ldy #$01			ldy 	#1							; line number in YA
.2e96	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e98	48		pha				pha
.2e99	c8		iny				iny
.2e9a	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2e9c	a8		tay				tay
.2e9d	68		pla				pla
.2e9e	20 5e 35	jsr $355e			jsr 	STRFindLine			 		; find where it is YA
.2ea1	90 0c		bcc $2eaf			bcc 	_FBFFound 					; not found, so must be >
.2ea3	48		pha				pha
.2ea4	b2 2a		lda ($2a)			lda 	(objPtr) 					; which is a fail if not CMD_GOTOCMD_Z
.2ea6	c9 d3		cmp #$d3			cmp 	#PCD_CMD_GOTOCMD_Z 			; or RESTORE. These go to the next line
.2ea8	f0 04		beq $2eae			beq 	_FBFAllowZero 				; after ; for IF forward scanning, and
.2eaa	c9 d6		cmp #$d6			cmp 	#PCD_CMD_RESTORE 			; because RESTORE <n> <n> is optional.
.2eac	d0 0f		bne $2ebd			bne 	_FBFFail
.2eae					_FBFAllowZero:
.2eae	68		pla				pla
.2eaf					_FBFFound:
.2eaf	20 ae 35	jsr $35ae			jsr 	STRMakeOffset 				; make it an offset from X:YA
.2eb2	5a		phy				phy	 								; patch the GOTO/GOSUB
.2eb3	a0 01		ldy #$01			ldy 	#1
.2eb5	91 2a		sta ($2a),y			sta 	(objPtr),y
.2eb7	c8		iny				iny
.2eb8	68		pla				pla
.2eb9	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ebb	80 d1		bra $2e8e			bra 	_FBNext
.2ebd					_FBFFail:
.2ebd	a0 02		ldy #$02			ldy 	#2
.2ebf	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ec1	8d ba 05	sta $05ba			sta 	currentLineNumber
.2ec4	c8		iny				iny
.2ec5	b1 2a		lda ($2a),y			lda 	(objPtr),y
.2ec7	8d bb 05	sta $05bb			sta 	currentLineNumber+1
.2eca	4c 5f 1f	jmp $1f5f		jmp	ErrorV_line
.2ecd					_FBFixVarSpace:
.2ecd	a0 01		ldy #$01			ldy 	#1
.2ecf	ad cd 06	lda $06cd			lda 	freeVariableMemory
.2ed2	91 2a		sta ($2a),y			sta 	(objPtr),y
.2ed4	c8		iny				iny
.2ed5	ad ce 06	lda $06ce			lda 	freeVariableMemory+1
.2ed8	91 2a		sta ($2a),y			sta 	(objPtr),y
.2eda	80 b2		bra $2e8e			bra 	_FBNext
.2edc					CommandFOR:
.2edc	20 c7 33	jsr $33c7			jsr 	GetNextNonSpace 			; first letter of index variable, should be.
.2edf	20 dd 33	jsr $33dd			jsr 	CharIsAlpha 				; if not alpha , error
.2ee2	90 59		bcc $2f3d			bcc 	_CFFail
.2ee4	20 08 37	jsr $3708			jsr 	GetReferenceTerm 			; figure out the reference.
.2ee7	48		pha				pha 								; save type
.2ee8	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2eea	c9 00		cmp #$00			cmp 	#NSSIFloat
.2eec	d0 4f		bne $2f3d			bne 	_CFFail
.2eee	5a		phy				phy 								; save reference on the stack
.2eef	da		phx				phx
.2ef0	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check for equal.
.2ef2	20 ab 2a	jsr $2aab			jsr 	CheckNextA
.2ef5	20 59 2d	jsr $2d59			jsr 	CompileExpressionAt0 		; initial value
.2ef8	fa		plx				plx 								; get reference back.
.2ef9	7a		ply				ply
.2efa	5a		phy				phy
.2efb	da		phx				phx
.2efc	38		sec				sec 								; set initial value.
.2efd	20 ba 36	jsr $36ba			jsr 	GetSetVariable
.2f00	fa		plx				plx
.2f01	7a		ply				ply
.2f02	68		pla				pla
.2f03	29 20		and #$20			and 	#NSSIInt16
.2f05	f0 04		beq $2f0b			beq 	_CFNotInt16
.2f07	98		tya				tya
.2f08	09 80		ora #$80			ora 	#$80
.2f0a	a8		tay				tay
.2f0b					_CFNotInt16:
.2f0b	8a		txa				txa 								; reference in YA
.2f0c	20 59 2b	jsr $2b59			jsr 	PushIntegerYA
.2f0f	a9 a4		lda #$a4			lda 	#C64_TO
.2f11	20 ab 2a	jsr $2aab			jsr 	CheckNextA
.2f14	20 59 2d	jsr $2d59			jsr 	CompileExpressionAt0 		; terminal value
.2f17	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f19	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f1b	d0 20		bne $2f3d			bne 	_CFFail
.2f1d	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; followed by STEP
.2f20	c9 a9		cmp #$a9			cmp 	#C64_STEP
.2f22	d0 0e		bne $2f32			bne 	_CFNoStep
.2f24	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume it.
.2f27	20 59 2d	jsr $2d59			jsr 	CompileExpressionAt0 		; terminal value
.2f2a	29 40		and #$40			and 	#NSSTypeMask 				; check it is numeric
.2f2c	c9 00		cmp #$00			cmp 	#NSSIFloat
.2f2e	d0 0d		bne $2f3d			bne 	_CFFail
.2f30	80 05		bra $2f37			bra 	_CFParametersDone
.2f32					_CFNoStep:
.2f32	a9 01		lda #$01			lda 	#1 							; default STEP e.g. 1
.2f34	20 6c 2b	jsr $2b6c			jsr 	PushIntegerA
.2f37					_CFParametersDone:
.2f37	a9 95		lda #$95			lda 	#PCD_FOR  					; compile FOR word.
.2f39	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2f3c	60		rts				rts
.2f3d					_CFFail:
.2f3d	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.2f40					FNCompile:
.2f40	20 c7 33	jsr $33c7			jsr 	GetNextNonSpace				; get variable name w/type must be array e.g. DEF FNx(a)
.2f43	20 2c 34	jsr $342c			jsr 	ExtractVariableName
.2f46	e0 00		cpx #$00			cpx 	#0
.2f48	10 32		bpl $2f7c			bpl 	_FNError
.2f4a	8a		txa				txa 								; convert to a function reference - bit 7:0 clear bit 7:1 set
.2f4b	29 7f		and #$7f			and 	#$7F
.2f4d	aa		tax				tax
.2f4e	98		tya				tya
.2f4f	09 80		ora #$80			ora 	#$80
.2f51	a8		tay				tay
.2f52	20 13 2e	jsr $2e13			jsr 	FindVariable				; does it already exist ?
.2f55	90 25		bcc $2f7c			bcc 	_FNError 					; no.
.2f57	20 ae 35	jsr $35ae			jsr 	STRMakeOffset 				; convert to a relative address.
.2f5a	c9 00		cmp #$00			cmp 	#0 							; fix up.
.2f5c	d0 01		bne $2f5f			bne 	_FNNoBorrow
.2f5e	88		dey				dey
.2f5f					_FNNoBorrow:
.2f5f	3a		dec a				dec 	a
.2f60	5a		phy				phy 								; save location of routine on stack.
.2f61	48		pha				pha
.2f62	da		phx				phx
.2f63	20 59 2d	jsr $2d59			jsr 	CompileExpressionAt0
.2f66	20 a5 2a	jsr $2aa5			jsr 	CheckNextRParen
.2f69	a9 d2		lda #$d2			lda 	#PCD_CMD_GOSUB
.2f6b	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2f6e	68		pla				pla
.2f6f	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2f72	68		pla				pla
.2f73	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2f76	68		pla				pla
.2f77	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.2f7a	18		clc				clc
.2f7b	60		rts				rts
.2f7c					_FNError:
.2f7c	4c 0f 1f	jmp $1f0f		jmp	ErrorV_value
.2f7f					CommandTables:
>2f7f	07 cb 00 03 8a 34 06			.byte	$07,$cb,$00,$03,CommandGOAlt & $FF,CommandGOAlt >> 8,$06
>2f86	07 89 00 03 91 34 06			.byte	$07,$89,$00,$03,CommandGOTO & $FF,CommandGOTO >> 8,$06
>2f8d	07 8d 00 03 84 34 06			.byte	$07,$8d,$00,$03,CommandGOSUB & $FF,CommandGOSUB >> 8,$06
>2f94	07 8c 00 03 73 37 06			.byte	$07,$8c,$00,$03,CommandRESTORE & $FF,CommandRESTORE >> 8,$06
>2f9b	07 88 00 03 00 35 06			.byte	$07,$88,$00,$03,CommandLET & $FF,CommandLET >> 8,$06
>2fa2	07 85 00 03 e0 34 06			.byte	$07,$85,$00,$03,CommandINPUT & $FF,CommandINPUT >> 8,$06
>2fa9	07 84 00 04 f4 34 06			.byte	$07,$84,$00,$04,CommandINPUTStream & $FF,CommandINPUTStream >> 8,$06
>2fb0	07 99 00 03 35 36 06			.byte	$07,$99,$00,$03,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2fb7	07 98 00 04 35 36 06			.byte	$07,$98,$00,$04,CommandPRINT & $FF,CommandPRINT >> 8,$06
>2fbe	07 8f 00 03 40 37 06			.byte	$07,$8f,$00,$03,CommandREM & $FF,CommandREM >> 8,$06
>2fc5	07 81 00 03 dc 2e 06			.byte	$07,$81,$00,$03,CommandFOR & $FF,CommandFOR >> 8,$06
>2fcc	07 82 00 03 b8 35 06			.byte	$07,$82,$00,$03,CommandNEXT & $FF,CommandNEXT >> 8,$06
>2fd3	07 a1 00 03 fd 33 06			.byte	$07,$a1,$00,$03,CommandGET & $FF,CommandGET >> 8,$06
>2fda	07 83 00 03 0f 2c 06			.byte	$07,$83,$00,$03,CommandDATA & $FF,CommandDATA >> 8,$06
>2fe1	07 87 00 03 7e 36 06			.byte	$07,$87,$00,$03,CommandREAD & $FF,CommandREAD >> 8,$06
>2fe8	07 86 00 03 a2 2c 06			.byte	$07,$86,$00,$03,CommandDIM & $FF,CommandDIM >> 8,$06
>2fef	07 96 00 03 2b 2c 06			.byte	$07,$96,$00,$03,CommandDEF & $FF,CommandDEF >> 8,$06
>2ff6	07 8b 00 e3 ad 34 06			.byte	$07,$8b,$00,$e3,CommandIF & $FF,CommandIF >> 8,$06
>2ffd	08 92 00 ea e3 2b 38 06			.byte	$08,$92,$00,$ea,$e3,CommandWAIT & $FF,CommandWAIT >> 8,$06
>3005	09 91 00 e1 a9 03 e4 35			.byte	$09,$91,$00,$e1,169,$03,CommandON & $FF,CommandON >> 8,$06
>300d	06
>300e	07 9e 00 e2 cb 92 06			.byte	$07,$9e,$00,$e2,37579 & $FF,37579 >> 8,$06
>3015	07 97 00 ea e1 ad 06			.byte	$07,$97,$00,$ea,$e1,173,$06
>301c	06 8e 00 10 98 06			.byte	$06,$8e,$00,$10,152,$06
>3022	07 90 00 20 cb 91 06			.byte	$07,$90,$00,$20,37323 & $FF,37323 >> 8,$06
>3029	07 80 00 20 cb 82 06			.byte	$07,$80,$00,$20,33483 & $FF,33483 >> 8,$06
>3030	07 9d 00 e3 51 38 06			.byte	$07,$9d,$00,$e3,CommandCMD & $FF,CommandCMD >> 8,$06
>3037	0a 9f 00 ea e3 64 38 10			.byte	$0a,$9f,$00,$ea,$e3,CommandOPEN & $FF,CommandOPEN >> 8,$10,199,$06
>303f	c7 06
>3041	06 a0 00 e1 c4 06			.byte	$06,$a0,$00,$e1,196,$06
>3047	07 ce 90 20 cb ac 06			.byte	$07,$ce,$90,$20,44235 & $FF,44235 >> 8,$06
>304e	0a ce 92 e3 7a 33 20 cb			.byte	$0a,$ce,$92,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44491 & $FF,44491 >> 8,$06
>3056	ad 06
>3058	0a ce 8d e3 7a 33 20 cb			.byte	$0a,$ce,$8d,$e3,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$20,44747 & $FF,44747 >> 8,$06
>3060	ae 06
>3062	06 ce 86 e1 c8 06			.byte	$06,$ce,$86,$e1,200,$06
>3068	08 ce 84 ea ea e1 c9 06			.byte	$08,$ce,$84,$ea,$ea,$e1,201,$06
>3070	07 ce af e2 cb 98 06			.byte	$07,$ce,$af,$e2,39115 & $FF,39115 >> 8,$06
>3077	07 ce 8c e2 cb 8c 06			.byte	$07,$ce,$8c,$e2,36043 & $FF,36043 >> 8,$06
>307e	09 ce ae ea ea e2 cb 95			.byte	$09,$ce,$ae,$ea,$ea,$e2,38347 & $FF,38347 >> 8,$06
>3086	06
>3087	08 ce 87 ea ea e1 99 06			.byte	$08,$ce,$87,$ea,$ea,$e1,153,$06
>308f	0a ce 88 ea ea ea ea e1			.byte	$0a,$ce,$88,$ea,$ea,$ea,$ea,$e1,154,$06
>3097	9a 06
>3099	0a ce 8a ea ea ea ea e1			.byte	$0a,$ce,$8a,$ea,$ea,$ea,$ea,$e1,155,$06
>30a1	9b 06
>30a3	0a ce 89 ea ea ea ea e1			.byte	$0a,$ce,$89,$ea,$ea,$ea,$ea,$e1,156,$06
>30ab	9c 06
>30ad	09 ce 8b ea ea ea f1 9d			.byte	$09,$ce,$8b,$ea,$ea,$ea,$f1,157,$06
>30b5	06
>30b6	07 ce 99 20 cb 99 06			.byte	$07,$ce,$99,$20,39371 & $FF,39371 >> 8,$06
>30bd	08 ce 9a ea e2 cb 9a 06			.byte	$08,$ce,$9a,$ea,$e2,39627 & $FF,39627 >> 8,$06
>30c5	08 ce 9b ea e2 cb 9b 06			.byte	$08,$ce,$9b,$ea,$e2,39883 & $FF,39883 >> 8,$06
>30cd	08 ce 9c ea e2 cb 9c 06			.byte	$08,$ce,$9c,$ea,$e2,40139 & $FF,40139 >> 8,$06
>30d5	08 ce 9d ea e2 cb 9d 06			.byte	$08,$ce,$9d,$ea,$e2,40395 & $FF,40395 >> 8,$06
>30dd	08 ce 9e ea e2 cb 9e 06			.byte	$08,$ce,$9e,$ea,$e2,40651 & $FF,40651 >> 8,$06
>30e5	08 ce 9f ea e2 cb 9f 06			.byte	$08,$ce,$9f,$ea,$e2,40907 & $FF,40907 >> 8,$06
>30ed	08 ce a0 ea e2 cb a0 06			.byte	$08,$ce,$a0,$ea,$e2,41163 & $FF,41163 >> 8,$06
>30f5	08 ce a1 ea f2 cb a1 06			.byte	$08,$ce,$a1,$ea,$f2,41419 & $FF,41419 >> 8,$06
>30fd	08 ce a2 ea f2 cb a2 06			.byte	$08,$ce,$a2,$ea,$f2,41675 & $FF,41675 >> 8,$06
>3105	08 ce a3 ea e2 cb a3 06			.byte	$08,$ce,$a3,$ea,$e2,41931 & $FF,41931 >> 8,$06
>310d	07 ce a4 20 cb a4 06			.byte	$07,$ce,$a4,$20,42187 & $FF,42187 >> 8,$06
>3114	08 ce a5 ea e2 cb a5 06			.byte	$08,$ce,$a5,$ea,$e2,42443 & $FF,42443 >> 8,$06
>311c	08 ce a6 ea e2 cb a6 06			.byte	$08,$ce,$a6,$ea,$e2,42699 & $FF,42699 >> 8,$06
>3124	08 ce a7 ea e2 cb a7 06			.byte	$08,$ce,$a7,$ea,$e2,42955 & $FF,42955 >> 8,$06
>312c	08 ce a8 ea e2 cb a8 06			.byte	$08,$ce,$a8,$ea,$e2,43211 & $FF,43211 >> 8,$06
>3134	08 ce a9 ea e2 cb a9 06			.byte	$08,$ce,$a9,$ea,$e2,43467 & $FF,43467 >> 8,$06
>313c	08 ce aa ea f2 cb aa 06			.byte	$08,$ce,$aa,$ea,$f2,43723 & $FF,43723 >> 8,$06
>3144	08 ce ab ea f2 cb ab 06			.byte	$08,$ce,$ab,$ea,$f2,43979 & $FF,43979 >> 8,$06
>314c	00						.byte 	0
.314d					UnaryTables:
>314d	07 b4 00 8e 91 b7 06			.byte	$07,$b4,$00,$8e,$91,183,$06
>3154	08 b5 00 8e 92 cb 84 06			.byte	$08,$b5,$00,$8e,$92,33995 & $FF,33995 >> 8,$06
>315c	07 b6 00 8e 91 8d 06			.byte	$07,$b6,$00,$8e,$91,141,$06
>3163	07 b7 00 8e 91 c2 06			.byte	$07,$b7,$00,$8e,$91,194,$06
>316a	07 b8 00 8e 91 96 06			.byte	$07,$b8,$00,$8e,$91,150,$06
>3171	07 b9 00 8e 91 ae 06			.byte	$07,$b9,$00,$8e,$91,174,$06
>3178	08 ba 00 8e 92 cb 85 06			.byte	$08,$ba,$00,$8e,$92,34251 & $FF,34251 >> 8,$06
>3180	07 bb 00 8e 91 b5 06			.byte	$07,$bb,$00,$8e,$91,181,$06
>3187	08 bc 00 8e 92 cb 86 06			.byte	$08,$bc,$00,$8e,$92,34507 & $FF,34507 >> 8,$06
>318f	08 bd 00 8e 92 cb 87 06			.byte	$08,$bd,$00,$8e,$92,34763 & $FF,34763 >> 8,$06
>3197	08 be 00 8e 92 cb 88 06			.byte	$08,$be,$00,$8e,$92,35019 & $FF,35019 >> 8,$06
>319f	08 bf 00 8e 92 cb 89 06			.byte	$08,$bf,$00,$8e,$92,35275 & $FF,35275 >> 8,$06
>31a7	08 c0 00 8e 92 cb 8a 06			.byte	$08,$c0,$00,$8e,$92,35531 & $FF,35531 >> 8,$06
>31af	08 c1 00 8e 92 cb 8b 06			.byte	$08,$c1,$00,$8e,$92,35787 & $FF,35787 >> 8,$06
>31b7	07 c2 00 8e 91 ab 06			.byte	$07,$c2,$00,$8e,$91,171,$06
>31be	07 c3 00 8f 91 a2 06			.byte	$07,$c3,$00,$8f,$91,162,$06
>31c5	07 c4 00 8e 91 bb 07			.byte	$07,$c4,$00,$8e,$91,187,$07
>31cc	07 c5 00 8f 91 c3 06			.byte	$07,$c5,$00,$8f,$91,195,$06
>31d3	07 c6 00 8f 91 8f 06			.byte	$07,$c6,$00,$8f,$91,143,$06
>31da	07 c7 00 8e 91 93 07			.byte	$07,$c7,$00,$8e,$91,147,$07
>31e1	08 c8 00 8f ae 91 bc 07			.byte	$08,$c8,$00,$8f,$ae,$91,188,$07
>31e9	08 c9 00 8f ae 91 bd 07			.byte	$08,$c9,$00,$8f,$ae,$91,189,$07
>31f1	0b ca 00 8f ae 03 7a 33			.byte	$0b,$ca,$00,$8f,$ae,$03,OptionalParameterCompile & $FF,OptionalParameterCompile >> 8,$91,190,$07
>31f9	91 be 07
>31fc	07 a8 00 03 99 33 06			.byte	$07,$a8,$00,$03,NotUnaryCompile & $FF,NotUnaryCompile >> 8,$06
>3203	07 a5 00 03 40 2f 06			.byte	$07,$a5,$00,$03,FNCompile & $FF,FNCompile >> 8,$06
>320a	06 ff 00 10 ac 06			.byte	$06,$ff,$00,$10,172,$06
>3210	07 ce d6 8e 91 91 07			.byte	$07,$ce,$d6,$8e,$91,145,$07
>3217	07 ce d5 8e 91 9e 07			.byte	$07,$ce,$d5,$8e,$91,158,$07
>321e	08 ce d0 8e ae 91 ca 06			.byte	$08,$ce,$d0,$8e,$ae,$91,202,$06
>3226	08 ce d4 8e 92 cb 83 06			.byte	$08,$ce,$d4,$8e,$92,33739 & $FF,33739 >> 8,$06
>322e	07 ce d3 20 cb 8d 06			.byte	$07,$ce,$d3,$20,36299 & $FF,36299 >> 8,$06
>3235	07 ce d1 20 cb 8e 06			.byte	$07,$ce,$d1,$20,36555 & $FF,36555 >> 8,$06
>323c	07 ce d2 20 cb 8f 06			.byte	$07,$ce,$d2,$20,36811 & $FF,36811 >> 8,$06
>3243	09 ce d7 8e ae 92 cb 96			.byte	$09,$ce,$d7,$8e,$ae,$92,38603 & $FF,38603 >> 8,$06
>324b	06
>324c	00						.byte 	0
.324d					GeneratorProcess:
.324d	86 2c		stx $2c				stx 	zTemp0 						; save generation pointer in zTemp0
.324f	84 2d		sty $2d				sty 	zTemp0+1
.3251	85 2e		sta $2e				sta 	zTemp1 						; first match token
.3253	64 2f		stz $2f				stz 	zTemp1+1
.3255	c9 ce		cmp #$ce			cmp 	#$CE 						; check if shift
.3257	d0 05		bne $325e			bne 	_GPNotShifted
.3259	20 bc 33	jsr $33bc			jsr 	GetNext 					; get the shifted token
.325c	85 2f		sta $2f				sta 	zTemp1+1 					; match CE xx
.325e					_GPNotShifted:
.325e					_GPSearch:
.325e	b2 2c		lda ($2c)			lda 	(zTemp0) 					; reached end ?
.3260	18		clc				clc
.3261	f0 2f		beq $3292			beq 	_GPExit
.3263	a0 01		ldy #$01			ldy 	#1 							; tokens match
.3265	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.3267	c5 2e		cmp $2e				cmp 	zTemp1
.3269	d0 09		bne $3274			bne 	_GPNext
.326b	a5 2f		lda $2f				lda 	zTemp1+1 					; 2nd token ?
.326d	f0 12		beq $3281			beq 	_GPFound
.326f	c8		iny				iny 								; check match.
.3270	d1 2c		cmp ($2c),y			cmp 	(zTemp0),y
.3272	f0 0d		beq $3281			beq 	_GPFound
.3274					_GPNext:
.3274	18		clc				clc 								; follow to next
.3275	a5 2c		lda $2c				lda 	zTemp0
.3277	72 2c		adc ($2c)			adc 	(zTemp0)
.3279	85 2c		sta $2c				sta 	zTemp0
.327b	90 e1		bcc $325e			bcc 	_GPSearch
.327d	e6 2d		inc $2d				inc 	zTemp0+1
.327f	80 dd		bra $325e			bra 	_GPSearch
.3281					_GPFound:
.3281	18		clc				clc 								; skip to action bytes
.3282	a5 2c		lda $2c				lda 	zTemp0 						; <offset> <token lo> <token hi> first
.3284	69 03		adc #$03			adc 	#3
.3286	85 2c		sta $2c				sta 	zTemp0
.3288	90 02		bcc $328c			bcc 	_GPNoCarry
.328a	e6 2d		inc $2d				inc 	zTemp0+1
.328c					_GPNoCarry:
.328c					_GPLoop:
.328c	20 93 32	jsr $3293			jsr 	GeneratorExecute 			; execute one command
.328f	90 fb		bcc $328c			bcc 	_GPLoop 					; go back if not completed.
.3291	38		sec				sec 								; return with CS.
.3292					_GPExit:
.3292	60		rts				rts
.3293					GeneratorExecute:
.3293	20 3f 33	jsr $333f			jsr 	_GEFetchZTemp0 				; get next.
.3296	48		pha				pha 								; split into 2 nibbles
.3297	4a		lsr a				lsr 	a
.3298	4a		lsr a				lsr 	a
.3299	4a		lsr a				lsr		a
.329a	4a		lsr a				lsr 	a
.329b	20 a5 32	jsr $32a5			jsr 	_GEExecuteNibble 			; MSB first
.329e	68		pla				pla
.329f	b0 03		bcs $32a4			bcs 	_GEHaveCompleted
.32a1	20 a5 32	jsr $32a5			jsr 	_GEExecuteNibble 			; LSB second
.32a4					_GEHaveCompleted:
.32a4	60		rts				rts
.32a5					_GEExecuteNibble:
.32a5	29 0f		and #$0f			and 	#$0F
.32a7	0a		asl a				asl 	a
.32a8	aa		tax				tax
.32a9	7c ac 32	jmp ($32ac,x)			jmp 	(_GEExecuteVectors,x)
.32ac					_GEExecuteVectors:
>32ac	cc 32						.word 	_GEXNop 					; 0  (no operation)
>32ae	d4 32						.word 	_GEXToken1 					; 1  (compile 1 byte token)
>32b0	ce 32						.word 	_GEXToken2 					; 2  (compile 2 byte token)
>32b2	22 33						.word 	_GEXExecute 				; 3  (run arbitrary code)
>32b4	15 33						.word 	_GEXChannelExec 			; 4  (run arbitrary code with possible channel redirection)
>32b6	cc 32						.word 	_GEXNop 					; 5
>32b8	dc 32						.word 	_GEXExitNumber 				; 6  exit return ifloat32 type
>32ba	e0 32						.word 	_GEXExitString 				; 7  exit return string type
>32bc	e4 32						.word 	_GEXLParam 					; 8  check ( follows
>32be	e8 32						.word 	_GEXRParam 					; 9  check ) follows
>32c0	ec 32						.word 	_GEXComma					; A  check , follows
>32c2	cc 32						.word 	_GEXNop 					; B
>32c4	cc 32						.word 	_GEXNop 					; C
>32c6	cc 32						.word 	_GEXNop 					; D
>32c8	fc 32						.word 	_GEXNumber 					; E  compile get any number
>32ca	07 33						.word 	_GEXString 					; F  compile get any string
.32cc					_GEXNop:
.32cc	18		clc				clc
.32cd	60		rts				rts
.32ce					_GEXToken2:
.32ce	20 3f 33	jsr $333f			jsr 	_GEFetchZTemp0
.32d1	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.32d4					_GEXToken1:
.32d4	20 3f 33	jsr $333f			jsr 	_GEFetchZTemp0
.32d7	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.32da	18		clc				clc
.32db	60		rts				rts
.32dc					_GEXExitNumber:
.32dc	a9 00		lda #$00			lda 	#NSSIFloat
.32de	38		sec				sec
.32df	60		rts				rts
.32e0					_GEXExitString:
.32e0	a9 40		lda #$40			lda 	#NSSString
.32e2	38		sec				sec
.32e3	60		rts				rts
.32e4					_GEXLParam:
.32e4	a9 28		lda #$28			lda 	#"("
.32e6	80 06		bra $32ee			bra 	_GEXCheck
.32e8					_GEXRParam:
.32e8	a9 29		lda #$29			lda 	#")"
.32ea	80 02		bra $32ee			bra 	_GEXCheck
.32ec					_GEXComma:
.32ec	a9 2c		lda #$2c			lda 	#","
.32ee					_GEXCheck:
.32ee	85 30		sta $30				sta 	zTemp2 						; save match
.32f0	20 c7 33	jsr $33c7			jsr 	GetNextNonSpace 			; get next skipping spaces
.32f3	c5 30		cmp $30				cmp 	zTemp2 						; check matches.
.32f5	d0 02		bne $32f9			bne 	_GEXSyntax
.32f7	18		clc				clc
.32f8	60		rts				rts
.32f9					_GEXSyntax:
.32f9	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.32fc					_GEXNumber:
.32fc	20 48 33	jsr $3348			jsr 	GEXCompileExpression 		; compile expression
.32ff	29 40		and #$40			and 	#NSSTypeMask
.3301	c9 00		cmp #$00			cmp  	#NSSIFloat
.3303	d0 0d		bne $3312			bne 	_GEXType
.3305	18		clc				clc
.3306	60		rts				rts
.3307					_GEXString:
.3307	20 48 33	jsr $3348			jsr 	GEXCompileExpression 		; compile expression
.330a	29 40		and #$40			and 	#NSSTypeMask
.330c	c9 40		cmp #$40			cmp  	#NSSString
.330e	d0 02		bne $3312			bne 	_GEXType
.3310	18		clc				clc
.3311	60		rts				rts
.3312					_GEXType:
.3312	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.3315					_GEXChannelExec:
.3315	20 58 33	jsr $3358			jsr 	ChannelPrefix 				; set up default
.3318	20 22 33	jsr $3322			jsr 	_GEXExecute
.331b	08		php				php
.331c	20 73 33	jsr $3373			jsr 	ChannelPostfix 				; replace default.
.331f	28		plp				plp
.3320	60		rts				rts
>3321	db						.byte 	$DB 						; causes a break in the emulator
.3322					_GEXExecute:
.3322	20 3f 33	jsr $333f			jsr 	_GEFetchZTemp0 				; get vector
.3325	85 30		sta $30				sta 	zTemp2
.3327	20 3f 33	jsr $333f			jsr 	_GEFetchZTemp0
.332a	85 31		sta $31				sta 	zTemp2+1
.332c	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.332e	da		phx				phx
.332f	a6 2d		ldx $2d				ldx 	zTemp0+1
.3331	da		phx				phx
.3332	20 3c 33	jsr $333c			jsr 	_GECallZTemp2 				; execute code
.3335	fa		plx				plx 								; recover generation exec
.3336	86 2d		stx $2d				stx 	zTemp0+1
.3338	fa		plx				plx
.3339	86 2c		stx $2c				stx 	zTemp0
.333b	60		rts				rts
.333c					_GECallZTemp2:
.333c	6c 30 00	jmp ($0030)			jmp 	(zTemp2)
.333f					_GEFetchZTemp0:
.333f	b2 2c		lda ($2c)			lda 	(zTemp0)
.3341	e6 2c		inc $2c				inc 	zTemp0
.3343	d0 02		bne $3347			bne 	_GEFZ0Skip
.3345	e6 2d		inc $2d				inc 	zTemp0+1
.3347					_GEFZ0Skip:
.3347	60		rts				rts
.3348					GEXCompileExpression:
.3348	a6 2c		ldx $2c				ldx 	zTemp0 						; push generation exec on to stack for reentrancy
.334a	da		phx				phx
.334b	a6 2d		ldx $2d				ldx 	zTemp0+1
.334d	da		phx				phx
.334e	20 59 2d	jsr $2d59			jsr 	CompileExpressionAt0 		; compile expression.
.3351	fa		plx				plx 								; recover generation exec
.3352	86 2d		stx $2d				stx 	zTemp0+1
.3354	fa		plx				plx
.3355	86 2c		stx $2c				stx 	zTemp0
.3357	60		rts				rts
.3358					ChannelPrefix:
.3358	a9 af		lda #$af			lda 	#PCD_GETCHANNEL				; set channel onto stack
.335a	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.335d	20 48 33	jsr $3348			jsr 	GEXCompileExpression 		; channel #
.3360	29 40		and #$40			and 	#NSSTypeMask
.3362	c9 00		cmp #$00			cmp 	#NSSIFloat
.3364	d0 0a		bne $3370			bne 	_CPXType
.3366	20 a1 2a	jsr $2aa1			jsr 	CheckNextComma 				; check , follows.
.3369	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL				; set channel
.336b	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.336e	18		clc				clc
.336f	60		rts				rts
.3370					_CPXType:
.3370	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.3373					ChannelPostfix:
.3373	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL				; set channel from TOS.
.3375	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.3378	18		clc				clc
.3379	60		rts				rts
.337a					OptionalParameterCompile:
.337a	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; what follows.
.337d	c9 2c		cmp #$2c			cmp 	#","
.337f	d0 0e		bne $338f			bne 	_MidDefault
.3381	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume ,
.3384	20 59 2d	jsr $2d59			jsr 	CompileExpressionAt0
.3387	29 40		and #$40			and 	#NSSTypeMask
.3389	c9 00		cmp #$00			cmp 	#NSSIFloat
.338b	d0 09		bne $3396			bne 	MidFailType
.338d	80 05		bra $3394			bra 	_MidComplete
.338f					_MidDefault:
.338f	a9 ff		lda #$ff			lda 	#255 						; default of 255
.3391	20 6c 2b	jsr $2b6c			jsr 	PushIntegerA
.3394					_MidComplete:
.3394	18		clc				clc
.3395	60		rts				rts
.3396					MidFailType:
.3396	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.3399					NotUnaryCompile:
.3399	ad 0e 2e	lda $2e0e			lda 	PrecedenceTable+C64_EQUAL-C64_PLUS
.339c	20 5b 2d	jsr $2d5b			jsr 	CompileExpressionAtA 		; evaluate at that level
.339f	29 40		and #$40			and 	#NSSTypeMask 				; check compile returns number.
.33a1	c9 00		cmp #$00			cmp 	#NSSIFloat
.33a3	d0 f1		bne $3396			bne 	MidFailType
.33a5	a9 a8		lda #$a8			lda 	#PCD_NOT 					; and NOT it.
.33a7	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.33aa	60		rts				rts
.33ab					LookNext:
.33ab	b2 7a		lda ($7a)			lda 	(srcPtr)
.33ad	60		rts				rts
.33ae					LookNextNonSpace:
.33ae	b2 7a		lda ($7a)			lda 	(srcPtr)
.33b0	c9 20		cmp #$20			cmp		#' '
.33b2	f0 03		beq $33b7			beq 	_LNNSkip
.33b4	c9 00		cmp #$00			cmp 	#0
.33b6	60		rts				rts
.33b7					_LNNSkip:
.33b7	20 bc 33	jsr $33bc			jsr 	GetNext
.33ba	80 f2		bra $33ae			bra 	LookNextNonSpace
.33bc					GetNext:
.33bc	b2 7a		lda ($7a)			lda 	(srcPtr) 					; get next
.33be	e6 7a		inc $7a				inc 	srcPtr
.33c0	d0 02		bne $33c4			bne 	_GNSkip
.33c2	e6 7b		inc $7b				inc 	srcPtr+1
.33c4					_GNSkip:
.33c4	c9 00		cmp #$00			cmp 	#0
.33c6	60		rts				rts
.33c7					GetNextNonSpace:
.33c7	20 bc 33	jsr $33bc			jsr 	GetNext
.33ca	c9 20		cmp #$20			cmp 	#' '
.33cc	f0 f9		beq $33c7			beq 	GetNextNonSpace
.33ce	c9 00		cmp #$00			cmp 	#0
.33d0	60		rts				rts
.33d1					CharIsDigit:
.33d1	c9 30		cmp #$30			cmp 	#"0"
.33d3	90 06		bcc $33db			bcc 	CCFalse
.33d5	c9 3a		cmp #$3a			cmp 	#"9"+1
.33d7	b0 02		bcs $33db			bcs 	CCFalse
.33d9					CCTrue:
.33d9	38		sec				sec
.33da	60		rts				rts
.33db					CCFalse:
.33db	18		clc				clc
.33dc	60		rts				rts
.33dd					CharIsAlpha:
.33dd	c9 41		cmp #$41			cmp 	#"A"
.33df	90 fa		bcc $33db			bcc 	CCFalse
.33e1	c9 5b		cmp #$5b			cmp 	#"Z"+1
.33e3	b0 f6		bcs $33db			bcs 	CCFalse
.33e5	80 f2		bra $33d9			bra 	CCTrue
.33e7					ConvertHexStyle:
.33e7	38		sec				sec
.33e8	e9 30		sbc #$30			sbc 	#"0" 						; check in range 0-9 first
.33ea	90 ef		bcc $33db			bcc 	CCFalse
.33ec	c9 0a		cmp #$0a			cmp 	#9+1
.33ee	90 e9		bcc $33d9			bcc 	CCTrue
.33f0	38		sec				sec 								; shift into hex space A=>0 Z=>25
.33f1	e9 11		sbc #$11			sbc 	#"A"-"0"
.33f3	90 e6		bcc $33db			bcc 	CCFalse
.33f5	c9 1a		cmp #$1a			cmp 	#26 						; past Z ?
.33f7	b0 e2		bcs $33db			bcs 	CCFalse
.33f9	69 0a		adc #$0a			adc 	#10 						; make valid quasi-hex 0-35
.33fb	80 dc		bra $33d9			bra 	CCTrue
.33fd					CommandGET:
.33fd	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; # follows ?
.3400	c9 23		cmp #$23			cmp 	#"#"
.3402	d0 0d		bne $3411			bne 	CommandGetBody
.3404	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume #
.3407	20 58 33	jsr $3358			jsr 	ChannelPrefix 				; do it as GET#
.340a	20 11 34	jsr $3411			jsr 	CommandGetBody
.340d	20 73 33	jsr $3373			jsr 	ChannelPostfix
.3410	60		rts				rts
.3411					CommandGetBody:
.3411	20 c7 33	jsr $33c7			jsr 	GetNextNonSpace 			; get the first character
.3414	20 08 37	jsr $3708			jsr 	GetReferenceTerm 			; identify variable to assign to
.3417	48		pha				pha
.3418	29 40		and #$40			and 	#NSSTypeMask 				; check if it is a string
.341a	c9 40		cmp #$40			cmp 	#NSSString
.341c	d0 0b		bne $3429			bne 	_CGType
.341e	a9 97		lda #$97			lda 	#PCD_GET 					; compile GET
.3420	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.3423	38		sec				sec
.3424	68		pla				pla
.3425	20 ba 36	jsr $36ba			jsr		GetSetVariable
.3428	60		rts				rts
.3429					_CGType:
.3429	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.342c					ExtractVariableName:
.342c	20 dd 33	jsr $33dd			jsr 	CharIsAlpha
.342f	90 50		bcc $3481			bcc 	_IVSyntax
.3431	29 1f		and #$1f			and 	#31 						; reduce first character to 5 bits
.3433	85 2e		sta $2e				sta 	zTemp1 						; we'll build it in zTemp1
.3435	64 2f		stz $2f				stz 	zTemp1+1
.3437	20 ab 33	jsr $33ab			jsr 	LookNext 					; is there a second character ?
.343a	20 dd 33	jsr $33dd			jsr 	CharIsAlpha  				; must be alphanumeric
.343d	b0 05		bcs $3444			bcs 	_IVHasSecond
.343f	20 d1 33	jsr $33d1			jsr 	CharIsDigit
.3442	90 07		bcc $344b			bcc 	_IVCheckType
.3444					_IVHasSecond:
.3444	29 3f		and #$3f			and 	#63 						; 6 bit ASCII.
.3446	85 2f		sta $2f				sta 	zTemp1+1
.3448					_IVGetNextCheck:
.3448	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume it
.344b					_IVCheckType:
.344b	20 ab 33	jsr $33ab			jsr 	LookNext					; check if string follows.
.344e	20 dd 33	jsr $33dd			jsr 	CharIsAlpha
.3451	b0 f5		bcs $3448			bcs 	_IVGetNextCheck
.3453	20 d1 33	jsr $33d1			jsr 	CharIsDigit
.3456	b0 f0		bcs $3448			bcs 	_IVGetNextCheck
.3458	a2 40		ldx #$40			ldx 	#NSSString
.345a	c9 24		cmp #$24			cmp 	#"$"
.345c	f0 06		beq $3464			beq 	_IVHasType
.345e	a2 20		ldx #$20			ldx 	#NSSIInt16 					; check if short int follows e.g. 16 bit
.3460	c9 25		cmp #$25			cmp 	#"%"
.3462	d0 08		bne $346c			bne 	_IVCheckArray
.3464					_IVHasType:
.3464	8a		txa				txa 								; Or X into zTemp1
.3465	05 2e		ora $2e				ora 	zTemp1
.3467	85 2e		sta $2e				sta 	zTemp1
.3469	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume it
.346c					_IVCheckArray:
.346c	20 ab 33	jsr $33ab			jsr 	LookNext 					; check if array follows
.346f	c9 28		cmp #$28			cmp 	#"("
.3471	d0 09		bne $347c			bne 	_IVNotArray
.3473	a5 2e		lda $2e				lda 	zTemp1 						; set array bit
.3475	09 80		ora #$80			ora 	#NSSArray
.3477	85 2e		sta $2e				sta 	zTemp1
.3479	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume it
.347c					_IVNotArray:
.347c	a6 2e		ldx $2e				ldx 	zTemp1
.347e	a4 2f		ldy $2f				ldy 	zTemp1+1
.3480	60		rts				rts
.3481					_IVSyntax:
.3481	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.3484					CommandGOSUB:
.3484	a9 d2		lda #$d2			lda 	#PCD_CMD_GOSUB
.3486	20 97 34	jsr $3497			jsr 	CompileBranchCommand
.3489	60		rts				rts
.348a					CommandGOAlt:
.348a	a9 a4		lda #$a4			lda 	#C64_TO 					; GO TO alternative
.348c	20 ab 2a	jsr $2aab			jsr 	CheckNextA
.348f	80 00		bra $3491			bra 	CommandGOTO
.3491					CommandGOTO:
.3491	a9 d1		lda #$d1			lda 	#PCD_CMD_GOTO
.3493	20 97 34	jsr $3497			jsr 	CompileBranchCommand
.3496	60		rts				rts
.3497					CompileBranchCommand:
.3497	20 43 2a	jsr $2a43			jsr 	WriteCodeByte 				; write the command out.
.349a	20 c7 33	jsr $33c7			jsr 	GetNextNonSpace
.349d	20 10 36	jsr $3610			jsr 	ParseConstant 				; get constant into YA
.34a0	90 08		bcc $34aa			bcc 	_CBCSyntax
.34a2	20 43 2a	jsr $2a43			jsr 	WriteCodeByte				; and compile the actual line number
.34a5	98		tya				tya
.34a6	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.34a9	60		rts				rts
.34aa					_CBCSyntax:
.34aa	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.34ad					CommandIF:
.34ad	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; what follows the tests ?
.34b0	c9 89		cmp #$89			cmp 	#C64_GOTO 					; IF .. GOTO
.34b2	f0 0f		beq $34c3			beq 	_CIGoto
.34b4	a9 a7		lda #$a7			lda 	#C64_THEN 					; should be THEN
.34b6	20 ab 2a	jsr $2aab			jsr 	CheckNextA
.34b9	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; THEN <number>
.34bc	20 d1 33	jsr $33d1			jsr 	CharIsDigit
.34bf	b0 05		bcs $34c6			bcs 	_CIGoto2
.34c1	80 09		bra $34cc			bra 	CompileGotoEOL
.34c3					_CIGoto:
.34c3	20 bc 33	jsr $33bc			jsr 	GetNext
.34c6					_CIGoto2:
.34c6	a9 d4		lda #$d4			lda 	#PCD_CMD_GOTOCMD_NZ
.34c8	20 97 34	jsr $3497			jsr 	CompileBranchCommand
.34cb	60		rts				rts
.34cc					CompileGotoEOL:
.34cc	a9 d3		lda #$d3			lda 	#PCD_CMD_GOTOCMD_Z
.34ce	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.34d1	20 3c 2a	jsr $2a3c			jsr 	GetLineNumber 				; Get the current line number => YA
.34d4	1a		inc a				inc 	a 							; and branch to +1
.34d5	d0 01		bne $34d8			bne 	_CGENoCarry
.34d7	c8		iny				iny
.34d8					_CGENoCarry:
.34d8	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.34db	98		tya				tya
.34dc	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.34df	60		rts				rts
.34e0					CommandINPUT:
.34e0	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; check for "
.34e3	c9 22		cmp #$22			cmp 	#'"'
.34e5	d0 0d		bne $34f4			bne 	CommandINPUTStream
.34e7	20 59 2d	jsr $2d59			jsr 	CompileExpressionAt0
.34ea	a9 b2		lda #$b2			lda 	#(PCD_PRINTCMD_S) & $FF
.34ec	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.34ef	a9 2c		lda #$2c			lda 	#","
.34f1	20 a1 2a	jsr $2aa1			jsr 	CheckNextComma
.34f4					CommandINPUTStream:
.34f4	a9 a1		lda #$a1			lda 	#(PCD_INPUTCMD_START) & $FF
.34f6	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.34f9	a2 9f		ldx #$9f			ldx 	#PCD_INPUT 					; do READ with Data from INPUT
.34fb	a0 a0		ldy #$a0			ldy 	#PCD_INPUTDOLLAR
.34fd	4c 82 36	jmp $3682			jmp 	CommandReadInputCommon
.3500					CommandLET:
.3500	20 c7 33	jsr $33c7			jsr 	GetNextNonSpace 			; get the first character
.3503					CommandLETHaveFirst:
.3503	20 08 37	jsr $3708			jsr 	GetReferenceTerm 			; identify variable to assign to
.3506	da		phx				phx 								; save target on the stack.
.3507	5a		phy				phy
.3508	48		pha				pha
.3509	a9 b2		lda #$b2			lda 	#C64_EQUAL 					; check next is =
.350b	20 ab 2a	jsr $2aab			jsr 	CheckNextA
.350e	20 59 2d	jsr $2d59			jsr 	CompileExpressionAt0 		; evaluate the RHS.
.3511	85 2c		sta $2c				sta 	zTemp0 						; save type returned
.3513	68		pla				pla 								; get type of assignment
.3514	48		pha				pha
.3515	45 2c		eor $2c				eor 	zTemp0 						; compare using EOR
.3517	29 40		and #$40			and 	#NSSTypeMask 				; so we can mask type as we only need n/s
.3519	d0 17		bne $3532			bne 	_CLType
.351b	68		pla				pla 								; restore and compile save code
.351c	7a		ply				ply
.351d	fa		plx				plx
.351e	c0 c0		cpy #$c0			cpy 	#$C0 						; is it TI$ = "xxxxx"
.3520	f0 05		beq $3527			beq 	_CLTIString
.3522	38		sec				sec
.3523	20 ba 36	jsr $36ba			jsr		GetSetVariable
.3526	60		rts				rts
.3527					_CLTIString:
.3527	a9 cb		lda #$cb			lda 	#(PCD_TIDOLLARCMD_WRITE) >> 8
.3529	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.352c	a9 93		lda #$93			lda 	#(PCD_TIDOLLARCMD_WRITE) & $FF
.352e	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.3531	60		rts				rts
.3532					_CLType:
.3532	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.3535					STRMarkLine:
.3535	48		pha				pha
.3536	38		sec				sec 								; allocate 4 bytes (line #,address)
.3537	ad c9 06	lda $06c9			lda 	lineNumberTable 			; and copy to zTemp0
.353a	e9 04		sbc #$04			sbc 	#4
.353c	8d c9 06	sta $06c9			sta 	lineNumberTable
.353f	85 2c		sta $2c				sta 	zTemp0
.3541	ad ca 06	lda $06ca			lda 	lineNumberTable+1
.3544	e9 00		sbc #$00			sbc 	#0
.3546	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.3549	85 2d		sta $2d				sta 	zTemp0+1
.354b	68		pla				pla
.354c	92 2c		sta ($2c)			sta 	(zTemp0) 					; line # save it in +0,+1
.354e	98		tya				tya
.354f	a0 01		ldy #$01			ldy 	#1
.3551	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3553	a5 2a		lda $2a				lda 	objPtr 						; save current address in +2,+3
.3555	c8		iny				iny
.3556	91 2c		sta ($2c),y			sta 	(zTemp0),y
.3558	a5 2b		lda $2b				lda 	objPtr+1
.355a	c8		iny				iny
.355b	91 2c		sta ($2c),y			sta 	(zTemp0),y
.355d	60		rts				rts
.355e					STRFindLine:
.355e	85 2c		sta $2c				sta 	zTemp0 						; zTemp0 line number being searched
.3560	84 2d		sty $2d				sty 	zTemp0+1
.3562	ad c2 06	lda $06c2			lda 	compilerEndHigh 			; work backwards through table
.3565	85 2f		sta $2f				sta 	zTemp1+1
.3567	64 2e		stz $2e				stz 	zTemp1
.3569					_STRSearch:
.3569	20 a0 35	jsr $35a0			jsr 	_STRPrevLine 				; look at previous record.
.356c	a0 01		ldy #$01			ldy 	#1
.356e	b2 2e		lda ($2e)			lda 	(zTemp1) 					; check table line # >= target
.3570	c5 2c		cmp $2c				cmp 	zTemp0
.3572	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3574	e5 2d		sbc $2d				sbc 	zTemp0+1
.3576	b0 0b		bcs $3583			bcs 	_STRFound 					; >=
.3578					_STRNext:
.3578	a0 01		ldy #$01			ldy 	#1 							; should not be required !
.357a	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.357c	c9 ff		cmp #$ff			cmp 	#$FF
.357e	d0 e9		bne $3569			bne 	_STRSearch
.3580	4c 76 1f	jmp $1f76		jmp	ErrorV_internal
.3583					_STRFound:
.3583	b2 2e		lda ($2e)			lda 	(zTemp1) 					; set A = 0 if the same, 0 if different.
.3585	45 2c		eor $2c				eor 	zTemp0
.3587	d0 06		bne $358f			bne 	_STRDifferent
.3589	b2 2e		lda ($2e)			lda 	(zTemp1)
.358b	45 2c		eor $2c				eor 	zTemp0
.358d	f0 02		beq $3591			beq 	_STROut 					; if zero, exit with A = 0 and correct line.
.358f					_STRDifferent:
.358f	a9 ff		lda #$ff			lda 	#$FF
.3591					_STROut:
.3591	18		clc				clc  								; set carry if different, e.g. > rather than >=
.3592	69 ff		adc #$ff			adc 	#255
.3594	08		php				php
.3595	c8		iny				iny 								; address into YA
.3596	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.3598	48		pha				pha
.3599	c8		iny				iny
.359a	b1 2e		lda ($2e),y			lda 	(zTemp1),y
.359c	a8		tay				tay
.359d	68		pla				pla
.359e	28		plp				plp
.359f	60		rts				rts
.35a0					_STRPrevLine:
.35a0	38		sec				sec 								; move backwards one entry.
.35a1	a5 2e		lda $2e				lda 	zTemp1
.35a3	e9 04		sbc #$04			sbc 	#4
.35a5	85 2e		sta $2e				sta 	zTemp1
.35a7	a5 2f		lda $2f				lda 	zTemp1+1
.35a9	e9 00		sbc #$00			sbc 	#0
.35ab	85 2f		sta $2f				sta 	zTemp1+1
.35ad	60		rts				rts
.35ae					STRMakeOffset:
.35ae	18		clc				clc 								; borrow 1
.35af	e5 2a		sbc $2a				sbc 	objPtr
.35b1	48		pha				pha
.35b2	98		tya				tya
.35b3	e5 2b		sbc $2b				sbc 	objPtr+1
.35b5	a8		tay				tay
.35b6	68		pla				pla
.35b7	60		rts				rts
.35b8					CommandNEXT:
.35b8	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; first letter of index variable, should be.
.35bb	20 dd 33	jsr $33dd			jsr 	CharIsAlpha 				; if not alpha , error
.35be	90 0c		bcc $35cc			bcc 	_CNNoReferenceGiven
.35c0	20 bc 33	jsr $33bc			jsr 	GetNext
.35c3	20 08 37	jsr $3708			jsr 	GetReferenceTerm 			; figure out the reference.
.35c6	8a		txa				txa 								; reference in YA
.35c7	20 59 2b	jsr $2b59			jsr 	PushIntegerYA 				; write it out.
.35ca	80 06		bra $35d2			bra 	_CNParametersDone
.35cc					_CNNoReferenceGiven:
.35cc	a9 ff		lda #$ff			lda 	#255 						; write out -1 no
.35ce	a8		tay				tay
.35cf	20 59 2b	jsr $2b59			jsr 	PushIntegerYA 				; write it out.
.35d2					_CNParametersDone:
.35d2	a9 a7		lda #$a7			lda 	#PCD_NEXT  					; compile FOR word.
.35d4	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.35d7	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; look for ,
.35da	c9 2c		cmp #$2c			cmp 	#","
.35dc	d0 05		bne $35e3			bne 	_CNExit
.35de	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume ,
.35e1	80 d5		bra $35b8			bra 	CommandNEXT 				; and go round.
.35e3					_CNExit:
.35e3	60		rts				rts
.35e4					CommandON:
.35e4	20 c7 33	jsr $33c7			jsr 	GetNextNonSpace 			; GOTO / GOSUB must follow
.35e7	48		pha				pha 								; save on stack
.35e8	a2 d1		ldx #$d1			ldx 	#PCD_CMD_GOTO
.35ea	c9 89		cmp #$89			cmp 	#C64_GOTO 					; must be GOTO/GOSUB
.35ec	f0 09		beq $35f7			beq 	_COCreateLoop
.35ee	a2 d2		ldx #$d2			ldx 	#PCD_CMD_GOSUB
.35f0	c9 8d		cmp #$8d			cmp 	#C64_GOSUB
.35f2	f0 03		beq $35f7			beq 	_COCreateLoop
.35f4	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.35f7					_COCreateLoop:
.35f7	8a		txa				txa 								; compile a goto/gosub somewhere
.35f8	da		phx				phx
.35f9	20 97 34	jsr $3497			jsr 	CompileBranchCommand
.35fc	fa		plx				plx
.35fd	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace			; ',' follows
.3600	c9 2c		cmp #$2c			cmp 	#","
.3602	d0 0a		bne $360e			bne 	_COComplete 				; if so, more line numbers
.3604	a9 aa		lda #$aa			lda 	#PCD_MOREON 				; ON extends.
.3606	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.3609	20 bc 33	jsr $33bc			jsr 	GetNext
.360c	80 e9		bra $35f7			bra 	_COCreateLoop
.360e					_COComplete:
.360e	68		pla				pla 								; throw GOTO/GOSUB
.360f	60		rts				rts
.3610					ParseConstant:
.3610	a2 00		ldx #$00			ldx 	#0
.3612	20 54 24	jsr $2454			jsr 	FloatEncodeStart 			; send first
.3615					_ParseLoop:
.3615	20 ab 33	jsr $33ab			jsr 	LookNext 					; send subsequent
.3618	20 57 24	jsr $2457			jsr 	FloatEncodeContinue
.361b	90 05		bcc $3622			bcc 	_ParseDone
.361d	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume it
.3620	80 f3		bra $3615			bra 	_ParseLoop
.3622					_ParseDone:
.3622	b5 32		lda $32,x			lda 	NSStatus,x 					; shouldn't be -ve ....
.3624	29 80		and #$80			and 	#$80
.3626	15 6e		ora $6e,x			ora 	NSExponent,x 				; 16 bit int check
.3628	15 56		ora $56,x			ora 	NSMantissa2,x
.362a	15 62		ora $62,x			ora 	NSMantissa3,x
.362c	18		clc				clc
.362d	d0 05		bne $3634			bne 	_ParseExit 					; exit with CC if need float to compile
.362f	b5 3e		lda $3e,x			lda 	NSMantissa0,x 				; read into YA.
.3631	b4 4a		ldy $4a,x			ldy		NSMantissa1,x
.3633	38		sec				sec
.3634					_ParseExit:
.3634	60		rts				rts
.3635					CommandPRINT:
.3635	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace			; what follows ?
.3638	c9 3b		cmp #$3b			cmp 	#";" 						; semicolon, check end of command
.363a	f0 1f		beq $365b			beq 	_CPCheckEnd
.363c	c9 2c		cmp #$2c			cmp 	#"," 						; , TAB and check end of command
.363e	f0 16		beq $3656			beq 	_CPTabCheckEnd
.3640	20 72 36	jsr $3672			jsr 	_CPAtEnd 					; check for : and EOL
.3643	b0 22		bcs $3667			bcs 	_CPExitCR 					; exit with CR
.3645	20 59 2d	jsr $2d59			jsr 	CompileExpressionAt0 		; so it is something to print
.3648	a2 b2		ldx #$b2			ldx 	#PCD_PRINTCMD_S
.364a	29 40		and #$40			and 	#NSSString 					; if string
.364c	d0 02		bne $3650			bne 	_CPOut
.364e	a2 b1		ldx #$b1			ldx 	#PCD_PRINTCMD_N
.3650					_CPOut:
.3650	8a		txa				txa 								; print that thing
.3651	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.3654	80 df		bra $3635			bra 	CommandPRINT 				; and loop round/
.3656					_CPTabCheckEnd:
.3656	a9 b8		lda #$b8			lda 	#PCD_PRINTCMD_TAB 			; , next tab stop
.3658	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.365b					_CPCheckEnd:
.365b	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume it.
.365e	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; what follows ?
.3661	20 72 36	jsr $3672			jsr 	_CPAtEnd 					; reached end
.3664	90 cf		bcc $3635			bcc 	CommandPRINT 				; no, loop back
.3666	60		rts				rts
.3667					_CPExitCR:
.3667	a9 0d		lda #$0d			lda 	#13 						; code to print CR
.3669	20 6c 2b	jsr $2b6c			jsr 	PushIntegerA
.366c	a9 92		lda #$92			lda 	#PCD_PRINTCMD_CHR
.366e	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.3671	60		rts				rts
.3672					_CPAtEnd:
.3672	c9 00		cmp #$00			cmp 	#0
.3674	f0 06		beq $367c			beq 	_CPIsEnd
.3676	c9 3a		cmp #$3a			cmp 	#":"
.3678	f0 02		beq $367c			beq 	_CPIsEnd
.367a	18		clc				clc
.367b	60		rts				rts
.367c					_CPIsEnd:
.367c	38		sec				sec
.367d	60		rts				rts
.367e					CommandREAD:
.367e	a2 b3		ldx #$b3			ldx 	#PCD_READ
.3680	a0 b4		ldy #$b4			ldy 	#PCD_READDOLLAR
.3682					CommandReadInputCommon:
.3682	8e c7 06	stx $06c7			stx 	numberPCode
.3685	8c c8 06	sty $06c8			sty 	stringPCode
.3688					_CRLoop:
.3688	20 c7 33	jsr $33c7			jsr 	GetNextNonSpace 			; first char of identifier
.368b	20 dd 33	jsr $33dd			jsr 	CharIsAlpha 				; check A-Z
.368e	90 27		bcc $36b7			bcc 	_CRSyntax
.3690	20 08 37	jsr $3708			jsr 	GetReferenceTerm 			; get the variable.
.3693	48		pha				pha 								; save type.
.3694	29 40		and #$40			and 	#NSSTypeMask 				; is it a string ?
.3696	c9 40		cmp #$40			cmp 	#NSSString
.3698	f0 05		beq $369f			beq 	_CRString
.369a	ad c7 06	lda $06c7			lda 	numberPCode 				; output read/input
.369d	80 03		bra $36a2			bra 	_CRHaveType
.369f					_CRString:
.369f	ad c8 06	lda $06c8			lda 	stringPCode					; output read$/input$
.36a2					_CRHaveType:
.36a2	20 43 2a	jsr $2a43			jsr 	WriteCodeByte 				; so we have one typed data item.
.36a5	68		pla				pla 								; restore type
.36a6	38		sec				sec  								; write update code.
.36a7	20 ba 36	jsr $36ba			jsr 	GetSetVariable
.36aa	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; , follows ?
.36ad	c9 2c		cmp #$2c			cmp 	#","
.36af	d0 05		bne $36b6			bne 	_CRExit 					; if not, end of READ.
.36b1	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume comma
.36b4	80 d2		bra $3688			bra 	_CRLoop 					; keep going
.36b6					_CRExit:
.36b6	60		rts				rts
.36b7					_CRSyntax:
.36b7	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.06c7					numberPCode:
>06c7							.fill 	1
.06c8					stringPCode:
>06c8							.fill 	1
.36ba					GetSetVariable:
.36ba	08		php				php 								; save direction on stack
.36bb	c0 00		cpy #$00			cpy 	#$00
.36bd	30 21		bmi $36e0			bmi 	_GSVReadWriteSpecial
.36bf	c9 00		cmp #$00			cmp 	#$00
.36c1	30 33		bmi $36f6			bmi 	_GSVArray
.36c3	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; get type bits
.36c5	4a		lsr a				lsr 	a 							; divide by 2
.36c6	09 40		ora #$40			ora 	#64 						; and set bit 6.
.36c8	28		plp				plp
.36c9	90 02		bcc $36cd			bcc 	_GSVNotWrite
.36cb	09 08		ora #$08			ora 	#8  						; set bit 3 if it is write.
.36cd					_GSVNotWrite:
.36cd	85 2c		sta $2c				sta 	zTemp0
.36cf	98		tya				tya 	 							; shift X/Y right as the address stored is halved
.36d0	4a		lsr a				lsr 	a
.36d1	a8		tay				tay
.36d2	8a		txa				txa
.36d3	6a		ror a				ror 	a
.36d4	aa		tax				tax
.36d5	98		tya				tya 								; lower 3 bits of YX are ORed into the opcode
.36d6	05 2c		ora $2c				ora 	zTemp0 						; which is the first byte of the opcode
.36d8	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.36db	8a		txa				txa 								; and the lower 8 bits of YX are the second byte
.36dc	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.36df	60		rts				rts
.36e0					_GSVReadWriteSpecial:
.36e0	28		plp				plp
.36e1	b0 10		bcs $36f3			bcs 	_GSVSyntax
.36e3	c0 c0		cpy #$c0			cpy 	#$C0 						; TI$ ?
.36e5	f0 06		beq $36ed			beq 	_GSVRWString
.36e7	a9 c0		lda #$c0			lda 	#(PCD_TI) & $FF
.36e9	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.36ec	60		rts				rts
.36ed					_GSVRWString:
.36ed	a9 c1		lda #$c1			lda 	#(PCD_TIDOLLAR) & $FF
.36ef	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.36f2	60		rts				rts
.36f3					_GSVSyntax:
.36f3	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.36f6					_GSVArray:
.36f6	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16 		; mask out 2 bits of type data
.36f8	4a		lsr a				lsr 	a		 					; shift from 5,6 to 0,1
.36f9	4a		lsr a				lsr 	a
.36fa	4a		lsr a				lsr 	a
.36fb	4a		lsr a				lsr 	a
.36fc	4a		lsr a				lsr 	a
.36fd	28		plp				plp 								; if writing array then set bit 2.
.36fe	90 02		bcc $3702			bcc 	_GSVANotWrite
.3700	09 04		ora #$04			ora 	#4
.3702					_GSVANotWrite:
.3702	09 78		ora #$78			ora 	#$78 						; make a valid opcode.
.3704	20 43 2a	jsr $2a43			jsr 	WriteCodeByte 				; and write it out
.3707	60		rts				rts
.3708					GetReferenceTerm:
.3708	20 2c 34	jsr $342c			jsr 	ExtractVariableName 		; get name & type info
.370b	e0 00		cpx #$00			cpx 	#0 							; check for array handler
.370d	30 10		bmi $371f			bmi 	_GRTArray
.370f	da		phx				phx 								; save type on stack
.3710	20 13 2e	jsr $2e13			jsr 	FindVariable 				; find it
.3713	b0 06		bcs $371b			bcs 	_GRTNoCreate 				; create if required.
.3715	20 9e 2b	jsr $2b9e			jsr 	CreateVariableRecord 		; create a variable.
.3718	20 f3 2b	jsr $2bf3			jsr 	AllocateBytesForType 		; allocate memory for it
.371b					_GRTNoCreate:
.371b	68		pla				pla 								; get type back, strip out type information.
.371c	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.371e	60		rts				rts
.371f					_GRTArray:
.371f	da		phx				phx 								; save type information
.3720	20 13 2e	jsr $2e13			jsr 	FindVariable 				; read its data, the base address in YX
.3723	90 18		bcc $373d			bcc 	_GRTUndeclared 				; undeclared array.
.3725	da		phx				phx 								; save base address
.3726	5a		phy				phy
.3727	20 ea 2c	jsr $2cea			jsr 	OutputIndexGroup 			; create an index group and generate them
.372a	7a		ply				ply 								; get the array base address into YX
.372b	fa		plx				plx
.372c	a9 20		lda #$20			lda 	#NSSIFloat+NSSIInt16 		; pretend it is an int16 reference.
.372e	18		clc				clc
.372f	20 ba 36	jsr $36ba			jsr 	GetSetVariable 				; load the address of the array structure.
.3732	a9 8e		lda #$8e			lda 	#(PCD_ARRAY) & $FF
.3734	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.3737	68		pla				pla 								; and the type data into A
.3738	29 60		and #$60			and 	#NSSTypeMask+NSSIInt16
.373a	09 80		ora #$80			ora 	#$80 						; with the array flag set.
.373c	60		rts				rts
.373d					_GRTUndeclared:
.373d	4c d3 1f	jmp $1fd3		jmp	ErrorV_undeclared
.3740					CommandREM:
.3740	20 ab 33	jsr $33ab			jsr 	LookNext
.3743	f0 05		beq $374a			beq 	_CRExit
.3745	20 bc 33	jsr $33bc			jsr 	GetNext
.3748	80 f6		bra $3740			bra 	CommandREM
.374a					_CRExit:
.374a	60		rts				rts
.374b					STRReset:
.374b	ad c1 06	lda $06c1			lda	 	compilerStartHigh 			; set up the two table pointers
.374e	8d cc 06	sta $06cc			sta 	variableListEnd+1
.3751	9c cb 06	stz $06cb			stz 	variableListEnd
.3754	ad c2 06	lda $06c2			lda 	compilerEndHigh
.3757	8d ca 06	sta $06ca			sta 	lineNumberTable+1
.375a	9c c9 06	stz $06c9			stz 	lineNumberTable
.375d	ad cb 06	lda $06cb			lda 	variableListEnd
.3760	85 2d		sta $2d				sta 	zTemp0+1
.3762	64 2c		stz $2c				stz 	zTemp0
.3764	a9 00		lda #$00			lda 	#0
.3766	92 2c		sta ($2c)			sta 	(zTemp0)
.3768	a9 00		lda #$00			lda 	#((0) & $FF)
.376a	8d cd 06	sta $06cd			sta 	0+freeVariableMemory
.376d	a9 00		lda #$00			lda 	#((0) >> 8) & $FF
.376f	8d ce 06	sta $06ce			sta 	1+freeVariableMemory
.3772	60		rts				rts
.06c9					lineNumberTable:
>06c9							.fill 	2
.06cb					variableListEnd:
>06cb							.fill 	2
.06cd					freeVariableMemory:
>06cd							.fill 	2
.3773					CommandRESTORE:
.3773	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; what follows ?
.3776	c9 3a		cmp #$3a			cmp 	#':'						; if : or EOL then default
.3778	f0 0a		beq $3784			beq 	_CRDefault
.377a	c9 00		cmp #$00			cmp 	#0
.377c	f0 06		beq $3784			beq 	_CRDefault
.377e	a9 d6		lda #$d6			lda 	#PCD_CMD_RESTORE 			; no, we have a parameter like GOTO/GOSUB
.3780	20 97 34	jsr $3497			jsr 	CompileBranchCommand
.3783	60		rts				rts
.3784					_CRDefault:
.3784	a9 d6		lda #$d6			lda 	#PCD_CMD_RESTORE 			; compile RESTORE
.3786	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.3789	a9 00		lda #$00			lda 	#0		 					; with zero "line#"
.378b	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.378e	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.3791	60		rts				rts
.3792					CompileTerm:
.3792	20 c7 33	jsr $33c7			jsr 	GetNextNonSpace 			; get first non space character.
.3795	30 72		bmi $3809			bmi 	_CTUnaryFunctions
.3797	20 d1 33	jsr $33d1			jsr 	CharIsDigit 				; found a number
.379a	b0 3a		bcs $37d6			bcs 	_CTDigit
.379c	c9 2e		cmp #$2e			cmp 	#"."
.379e	f0 36		beq $37d6			beq 	_CTDigit
.37a0	c9 22		cmp #$22			cmp 	#'"' 						; found a string ?
.37a2	f0 43		beq $37e7			beq 	_CTString
.37a4	c9 25		cmp #$25			cmp 	#"%"						; binary or hexadecimal ?
.37a6	f0 28		beq $37d0			beq 	_CTOtherBase
.37a8	c9 24		cmp #$24			cmp 	#"$"
.37aa	f0 24		beq $37d0			beq 	_CTOtherBase
.37ac	c9 28		cmp #$28			cmp 	#"(" 						; check parenthesis
.37ae	f0 17		beq $37c7			beq 	_CTBrackets
.37b0	c9 41		cmp #$41			cmp 	#"A" 						; check variable/array ?
.37b2	90 10		bcc $37c4			bcc 	_CTSyntax
.37b4	c9 5b		cmp #$5b			cmp 	#"Z"+1
.37b6	b0 0c		bcs $37c4			bcs 	_CTSyntax
.37b8	20 08 37	jsr $3708			jsr 	GetReferenceTerm 			; figure out what it is.
.37bb	48		pha				pha 								; save type on stack
.37bc	18		clc				clc 								; read it
.37bd	20 ba 36	jsr $36ba			jsr 	GetSetVariable
.37c0	68		pla				pla
.37c1	29 40		and #$40			and 	#NSSTypeMask 				; reduce to basic type
.37c3	60		rts				rts
.37c4					_CTSyntax:
.37c4	4c 1c 1f	jmp $1f1c		jmp	ErrorV_syntax
.37c7					_CTBrackets:
.37c7	20 59 2d	jsr $2d59			jsr 	CompileExpressionAt0
.37ca	48		pha				pha
.37cb	20 a5 2a	jsr $2aa5			jsr 	CheckNextRParen
.37ce	68		pla				pla
.37cf	60		rts				rts
.37d0					_CTOtherBase:
.37d0	20 f1 29	jsr $29f1			jsr 	InlineNonDecimal 			; non decimal constant handler
.37d3	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.37d5	60		rts				rts
.37d6					_CTDigit:
.37d6	20 10 36	jsr $3610			jsr 	ParseConstant 				; parse out an number, first is in A already.
.37d9	90 06		bcc $37e1			bcc	 	_CTFloat 					; have a float or long int.
.37db	20 59 2b	jsr $2b59			jsr 	PushIntegerYA 				; code to push on stack
.37de	a9 00		lda #$00			lda 	#NSSIFloat					; return a iFloat32 integer
.37e0	60		rts				rts
.37e1					_CTFloat:
.37e1	20 7b 2b	jsr $2b7b			jsr 	PushFloatCommand			; code to push float
.37e4	a9 00		lda #$00			lda 	#NSSIFloat 					; return a iFloat32
.37e6	60		rts				rts
.37e7					_CTString:
.37e7	20 7a 2a	jsr $2a7a			jsr 	BufferClear 				; copy it to the buffer
.37ea					_CTStringLoop:
.37ea	20 ab 33	jsr $33ab			jsr 	LookNext 					; reached EOL/EOS
.37ed	f0 d5		beq $37c4			beq 	_CTSyntax
.37ef	c9 22		cmp #$22			cmp 	#'"'
.37f1	f0 08		beq $37fb			beq 	_CTStringDone
.37f3	20 7e 2a	jsr $2a7e			jsr 	BufferWrite 				; write and consume
.37f6	20 bc 33	jsr $33bc			jsr 	GetNext
.37f9	80 ef		bra $37ea			bra 	_CTStringLoop
.37fb					_CTStringDone:
.37fb	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume closing quote.
.37fe	a9 cf		lda #$cf			lda 	#PCD_CMD_STRING 			; output command and buffer
.3800	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.3803	20 8a 2a	jsr $2a8a			jsr 	BufferOutput
.3806	a9 40		lda #$40			lda 	#NSSString 					; string type
.3808	60		rts				rts
.3809					_CTUnaryFunctions:
.3809	c9 ab		cmp #$ab			cmp 	#C64_MINUS 					; negation of term.
.380b	f0 0a		beq $3817			beq 	_CTNegation
.380d	a2 4d		ldx #$4d			ldx 	#UnaryTables & $FF 			; check vs unary tables.
.380f	a0 31		ldy #$31			ldy 	#UnaryTables >> 8
.3811	20 4d 32	jsr $324d			jsr 	GeneratorProcess
.3814	90 ae		bcc $37c4			bcc		_CTSyntax
.3816	60		rts				rts
.3817					_CTNegation:
.3817	20 92 37	jsr $3792			jsr 	CompileTerm 				; compile a term.
.381a	48		pha				pha
.381b	29 40		and #$40			and 	#NSSTypeMask 				; if not an ifloat32 of some sort.
.381d	c9 00		cmp #$00			cmp 	#NSSIFloat
.381f	d0 07		bne $3828			bne 	_CTType 					; error
.3821	a9 a5		lda #$a5			lda 	#PCD_NEGATE 				; compile negate
.3823	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.3826	68		pla				pla 								; return original type.
.3827	60		rts				rts
.3828					_CTType:
.3828	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.382b					CommandWAIT:
.382b	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace
.382e	c9 2c		cmp #$2c			cmp 	#","
.3830	f0 10		beq $3842			beq 	_CWThirdParameter
.3832	a9 00		lda #$00			lda 	#0
.3834	20 6c 2b	jsr $2b6c			jsr 	PushIntegerA
.3837					_CWExit:
.3837	a9 cb		lda #$cb			lda 	#(PCD_WAIT) >> 8
.3839	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.383c	a9 94		lda #$94			lda 	#(PCD_WAIT) & $FF
.383e	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.3841	60		rts				rts
.3842					_CWThirdParameter:
.3842	20 bc 33	jsr $33bc			jsr 	GetNext
.3845	20 5b 2d	jsr $2d5b			jsr 	CompileExpressionAtA
.3848	29 40		and #$40			and 	#NSSTypeMask
.384a	c9 00		cmp #$00			cmp 	#NSSIFloat
.384c	f0 e9		beq $3837			beq 	_CWExit
.384e	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type
.3851					CommandCMD:
.3851	a9 b0		lda #$b0			lda 	#PCD_SETCHANNEL 			; set the channel to this now forever.
.3853	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.3856	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; followed by a , ?
.3859	c9 2c		cmp #$2c			cmp 	#","
.385b	d0 06		bne $3863			bne 	_CCMDExit
.385d	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume comma.
.3860	20 35 36	jsr $3635			jsr 	CommandPRINT 				; do the print code
.3863					_CCMDExit:
.3863	60		rts				rts
.3864					CommandOPEN:
.3864	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; followed by a , ?
.3867	c9 2c		cmp #$2c			cmp 	#","
.3869	d0 15		bne $3880			bne 	_COTwoDefaults
.386b	20 bc 33	jsr $33bc			jsr 	GetNext 					; consume comma
.386e	20 59 2d	jsr $2d59			jsr 	CompileExpressionAt0 		; what follows could be text or number.
.3871	29 40		and #$40			and 	#NSSString 					; if a number want a string to follow
.3873	f0 1e		beq $3893			beq 	_COThreeIntegers
.3875	a9 00		lda #$00			lda 	#0		 					; so we have n,n,$,0 so swap !
.3877	20 6c 2b	jsr $2b6c			jsr 	PushIntegerA
.387a	a9 bf		lda #$bf			lda 	#(PCD_SWAP) & $FF
.387c	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.387f	60		rts				rts
.3880					_COTwoDefaults:
.3880	a9 00		lda #$00			lda 	#0
.3882	20 6c 2b	jsr $2b6c			jsr 	PushIntegerA
.3885					_COCompileNullString:
.3885	a9 cf		lda #$cf			lda 	#(PCD_CMD_STRING) & $FF
.3887	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.388a	a9 00		lda #$00			lda 	#0
.388c	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.388f	20 43 2a	jsr $2a43			jsr 	WriteCodeByte
.3892	60		rts				rts
.3893					_COThreeIntegers:
.3893	20 ae 33	jsr $33ae			jsr 	LookNextNonSpace 			; is there a ,
.3896	c9 2c		cmp #$2c			cmp 	#","
.3898	d0 eb		bne $3885			bne 	_COCompileNullString 		; if not it is n,n,n so default filename.
.389a	20 bc 33	jsr $33bc			jsr 	GetNext
.389d	20 59 2d	jsr $2d59			jsr 	CompileExpressionAt0 		; should be a filename
.38a0	29 40		and #$40			and 	#NSSString
.38a2	f0 01		beq $38a5			beq 	_COType
.38a4	60		rts				rts
.38a5					_COType:
.38a5	4c 2c 1f	jmp $1f2c		jmp	ErrorV_type

;******  Processing input file: _library.asm

.38a8					CompilerAPI:
.38a8	c9 00		cmp #$00			cmp 	#BLC_OPENIN
.38aa	f0 19		beq $38c5			beq 	_CAOpenIn
.38ac	c9 01		cmp #$01			cmp 	#BLC_CLOSEIN
.38ae	f0 23		beq $38d3			beq 	_CACloseIn
.38b0	c9 02		cmp #$02			cmp 	#BLC_READIN
.38b2	f0 3a		beq $38ee			beq 	_CARead
.38b4	c9 03		cmp #$03			cmp 	#BLC_RESETOUT
.38b6	f0 1e		beq $38d6			beq 	_CAResetOut
.38b8	c9 04		cmp #$04			cmp 	#BLC_CLOSEOUT
.38ba	f0 23		beq $38df			beq 	_CACloseOut
.38bc	c9 05		cmp #$05			cmp 	#BLC_WRITEOUT
.38be	f0 20		beq $38e0			beq 	_CAWriteByte
.38c0	c9 06		cmp #$06			cmp 	#BLC_PRINTCHAR
.38c2	f0 26		beq $38ea			beq 	_CAPrintScreen
>38c4	db						.byte 	$DB 						; causes a break in the emulator
.38c5					_CAOpenIn:
.38c5	a0 39		ldy #$39			ldy 	#SourceFile >> 8 			; name of file
.38c7	a2 e5		ldx #$e5			ldx 	#SourceFile & $FF
.38c9	20 56 39	jsr $3956			jsr 	IOOpenRead 					; open file
.38cc	20 61 39	jsr $3961			jsr 	IOReadByte 					; skip the 2 byte load address header
.38cf	20 61 39	jsr $3961			jsr 	IOReadByte
.38d2	60		rts				rts
.38d3					_CACloseIn:
.38d3	4c 70 39	jmp $3970			jmp 	IOReadClose
.38d6					_CAResetOut:
.38d6	a9 00		lda #$00			lda 	#((FreeMemory) & $FF)
.38d8	85 2a		sta $2a				sta 	0+objPtr
.38da	a9 3b		lda #$3b			lda 	#((FreeMemory) >> 8) & $FF
.38dc	85 2b		sta $2b				sta 	1+objPtr
.38de	60		rts				rts
.38df					_CACloseOut:
.38df	60		rts				rts
.38e0					_CAWriteByte:
.38e0	8a		txa				txa
.38e1	92 2a		sta ($2a)			sta 	(objPtr)
.38e3	e6 2a		inc $2a				inc 	objPtr
.38e5	d0 02		bne $38e9			bne 	_HWOWBNoCarry
.38e7	e6 2b		inc $2b				inc 	objPtr+1
.38e9					_HWOWBNoCarry:
.38e9	60		rts				rts
.38ea					_CAPrintScreen:
.38ea	8a		txa				txa
.38eb	4c d2 ff	jmp $ffd2			jmp 	$FFD2
.38ee					_CARead:
.38ee	20 61 39	jsr $3961			jsr 	IOReadByte 				; copy the address of next into the buffer
.38f1	8d cf 06	sta $06cf			sta 	SourceLine+0
.38f4	20 61 39	jsr $3961			jsr 	IOReadByte
.38f7	8d d0 06	sta $06d0			sta 	SourceLine+1
.38fa	0d cf 06	ora $06cf			ora 	sourceLine				; if both were zero, exit with CC (e.g. fail)
.38fd	18		clc				clc
.38fe	f0 1e		beq $391e			beq		_CARExit
.3900	20 61 39	jsr $3961			jsr 	IOReadByte 				; read the line # into the buffer.
.3903	8d d1 06	sta $06d1			sta 	SourceLine+2
.3906	20 61 39	jsr $3961			jsr 	IOReadByte
.3909	8d d2 06	sta $06d2			sta 	SourceLine+3
.390c	a2 04		ldx #$04			ldx 	#4 						; read the body of the line.
.390e					_CAReadLine:
.390e	20 61 39	jsr $3961			jsr 	IOReadByte 				; now keep copying to EOL
.3911	9d cf 06	sta $06cf,x			sta 	SourceLine,x
.3914	e8		inx				inx
.3915	c9 00		cmp #$00			cmp 	#0
.3917	d0 f5		bne $390e			bne 	_CAReadLine
.3919	38		sec				sec 							; read a line okay
.391a	a0 06		ldy #$06			ldy 	#SourceLine >> 8
.391c	a2 cf		ldx #$cf			ldx 	#SourceLine & $FF
.391e					_CARExit:
.391e	60		rts				rts
.06cf					SourceLine:
>06cf							.fill 	256
.391f					WriteObjectCode:
.391f	20 1a 08	jsr $081a			jsr 	PatchOutCompile 			; makes it run the runtime on reload
.3922	a0 39		ldy #$39			ldy 	#ObjectFile >> 8
.3924	a2 da		ldx #$da			ldx 	#ObjectFile & $FF
.3926	20 49 3a	jsr $3a49			jsr 	IOOpenWrite 				; open write
.3929	a9 01		lda #$01			lda 	#1 							; write out the load address $0801
.392b	20 54 3a	jsr $3a54			jsr 	IOWriteByte
.392e	a9 08		lda #$08			lda 	#8
.3930	20 54 3a	jsr $3a54			jsr 	IOWriteByte
.3933	a9 01		lda #$01			lda 	#((StartBasicProgram) & $FF)
.3935	85 2c		sta $2c				sta 	0+zTemp0
.3937	a9 08		lda #$08			lda 	#((StartBasicProgram) >> 8) & $FF
.3939	85 2d		sta $2d				sta 	1+zTemp0
.393b					_WOCLoop:
.393b	b2 2c		lda ($2c)			lda 	(zTemp0) 					; write code
.393d	20 54 3a	jsr $3a54			jsr 	IOWriteByte
.3940	e6 2c		inc $2c				inc 	zTemp0 						; advance pointer
.3942	d0 02		bne $3946			bne 	_WOCSkip
.3944	e6 2d		inc $2d				inc 	zTemp0+1
.3946					_WOCSkip:
.3946	a5 2c		lda $2c				lda 	zTemp0 						; check end
.3948	c5 2a		cmp $2a				cmp 	objPtr
.394a	d0 ef		bne $393b			bne 	_WOCLoop
.394c	a5 2d		lda $2d				lda 	zTemp0+1
.394e	c5 2b		cmp $2b				cmp 	objPtr+1
.3950	d0 e9		bne $393b			bne 	_WOCLoop
.3952	20 70 39	jsr $3970			jsr 	IOWriteClose 				; close the file.
.3955	60		rts				rts
.3956					IOOpenRead:
.3956	a9 52		lda #$52			lda 	#'R' 						; read.
.3958	20 79 39	jsr $3979			jsr 	IOSetFileName 				; set up name/LFS
.395b	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for reading
.395d	20 c6 ff	jsr $ffc6			jsr 	$FFC6 						; CHKIN
.3960	60		rts				rts
.3961					IOReadByte:
.3961	da		phx				phx
.3962	5a		phy				phy
.3963	20 b7 ff	jsr $ffb7			jsr 	$FFB7 						; read ST
.3966	38		sec				sec
.3967	d0 04		bne $396d			bne 	_IORExit
.3969	20 cf ff	jsr $ffcf			jsr 	$FFCF 						; read a byte
.396c	18		clc				clc 								; status OK.
.396d					_IORExit:
.396d	7a		ply				ply
.396e	fa		plx				plx
.396f	60		rts				rts
.3970					IOReadClose:
.3970					IOWriteClose:
.3970	a9 03		lda #$03			lda 	#3 							; CLOSE# 3
.3972	20 c3 ff	jsr $ffc3			jsr 	$FFC3
.3975	20 cc ff	jsr $ffcc			jsr 	$FFCC 						; CLRCHN
.3978	60		rts				rts
.3979					IOSetFileName:
.3979	48		pha				pha 								; save R/W
.397a	86 2c		stx $2c				stx 	zTemp0
.397c	84 2d		sty $2d				sty 	zTemp0+1
.397e	a0 ff		ldy #$ff			ldy 	#$FF 						; copy name given
.3980					_IOSCopy:
.3980	c8		iny				iny 								; pre-increment copy
.3981	b1 2c		lda ($2c),y			lda 	(zTemp0),y
.3983	99 cf 07	sta $07cf,y			sta 	IONameBuffer,y
.3986	d0 f8		bne $3980			bne 	_IOSCopy
.3988	99 d3 07	sta $07d3,y			sta 	IONameBuffer+4,y
.398b	a9 2c		lda #$2c			lda 	#',' 						; append ,S,[R|W]
.398d	99 cf 07	sta $07cf,y			sta 	IONameBuffer+0,y
.3990	99 d1 07	sta $07d1,y			sta 	IONameBuffer+2,y
.3993	a9 53		lda #$53			lda 	#'S'
.3995	99 d0 07	sta $07d0,y			sta 	IONameBuffer+1,y
.3998	68		pla				pla 								; write R/W out
.3999	99 d2 07	sta $07d2,y			sta 	IONameBuffer+3,y
.399c	98		tya				tya 								; length of name to A
.399d	18		clc				clc
.399e	69 04		adc #$04			adc 	#4 							; we added 4 characters.
.39a0	a2 cf		ldx #$cf			ldx 	#IONameBuffer & $FF			; name address to YX
.39a2	a0 07		ldy #$07			ldy 	#IONameBuffer >> 8
.39a4	20 bd ff	jsr $ffbd		    jsr 	$FFBD          				; call SETNAM
.39a7	a9 03		lda #$03	    	lda 	#3 							; set LFS to 3,8,3
.39a9	a2 08		ldx #$08			ldx 	#8
.39ab	a0 03		ldy #$03			ldy 	#3
.39ad	20 ba ff	jsr $ffba			jsr 	$FFBA
.39b0	20 c0 ff	jsr $ffc0			jsr 	$FFC0 						; OPEN
.39b3	60		rts				rts
.07cf					IONameBuffer:
>07cf							.fill 	64
.39b4					CompileCode:
.39b4	a2 00		ldx #$00			ldx 	#0
.39b6	bd f0 39	lda $39f0,x	_Prompt:lda 	Prompt,x
.39b9	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.39bc	e8		inx				inx
.39bd	c9 00		cmp #$00			cmp 	#0
.39bf	d0 f5		bne $39b6			bne 	_Prompt
.39c1	a2 d6		ldx #$d6			ldx 	#APIDesc & $FF
.39c3	a0 39		ldy #$39			ldy 	#APIDesc >> 8
.39c5	20 ba 2a	jsr $2aba			jsr 	StartCompiler
.39c8	20 1f 39	jsr $391f			jsr 	WriteObjectCode
.39cb	a9 4f		lda #$4f			lda 	#"O"
.39cd	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.39d0	a9 4b		lda #$4b			lda 	#"K"
.39d2	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.39d5	60		rts				rts
.39d6					APIDesc:
>39d6	a8 38						.word 	CompilerAPI 				; the compiler API Implementeation
>39d8	80						.byte 	$80 						; start of workspace for compiler $8000
>39d9	9f						.byte 	$9F							; end of workspace for compiler $9F00
.39da					ObjectFile:
>39da	4f 42 4a 45 43 54 2e 50				.text 	'OBJECT.PRG',0
>39e2	52 47 00
.39e5					SourceFile:
>39e5	53 4f 55 52 43 45 2e 50				.text 	'SOURCE.PRG',0
>39ed	52 47 00
.39f0					Prompt:
>39f0	2a 2a 2a 20 42 4c 49 54				.text 	'*** BLITZ (ALPHA 09-10-23) ***',13,13
>39f8	5a 20 28 41 4c 50 48 41 20 30 39 2d 31 30 2d 32
>3a08	33 29 20 2a 2a 2a 0d 0d
>3a10	42 55 47 53 3a 48 54 54				.text 	'BUGS:HTTPS://GITHUB.COM/PAULSCOTTROBSON/BLITZ-COMPILER',13,13,0
>3a18	50 53 3a 2f 2f 47 49 54 48 55 42 2e 43 4f 4d 2f
>3a28	50 41 55 4c 53 43 4f 54 54 52 4f 42 53 4f 4e 2f
>3a38	42 4c 49 54 5a 2d 43 4f 4d 50 49 4c 45 52 0d 0d
>3a48	00
.3a49					IOOpenWrite:
.3a49	a9 57		lda #$57			lda 	#'W'			 			; write
.3a4b	20 79 39	jsr $3979			jsr 	IOSetFileName 				; set up name/LFS
.3a4e	a2 03		ldx #$03			ldx	 	#3 							; use file 3 for writing
.3a50	20 c9 ff	jsr $ffc9			jsr 	$FFC9 						; CHKOUT
.3a53	60		rts				rts
.3a54					IOWriteByte:
.3a54	48		pha				pha
.3a55	da		phx				phx
.3a56	5a		phy				phy
.3a57	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.3a5a	7a		ply				ply
.3a5b	fa		plx				plx
.3a5c	68		pla				pla
.3a5d	60		rts				rts

;******  Processing input file: source/main/zzfree.footer

>3a5e							.align 	256
.3b00					FreeMemory:

;******  End of listing
